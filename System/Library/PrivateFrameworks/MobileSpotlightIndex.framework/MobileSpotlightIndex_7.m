uint64_t ___ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIfLi256EE3aNNEjtPKv14vec_dimensions15vec_data_formatfjbU13block_pointerFvPvfE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

_DWORD *IVFVectorIndexTemplate<float,256>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::lookupForInsert(uint64_t a1, unsigned int a2, const void *a3, unsigned int a4, float a5)
{
  unsigned int Vector;
  uint64_t v9;
  _DWORD *Ptr;
  const UInt8 *data;
  int v12;
  NSObject *v13;
  int v14;
  NSObject *v15;
  int v16;
  NSObject *v17;
  _BYTE *v18;
  int v19;
  NSObject *v20;
  _BYTE *v21;
  const void *v22;
  std::__shared_weak_count *v23;
  unint64_t *p_shared_owners;
  unint64_t v25;
  std::__shared_weak_count *v26;
  _DWORD *v27;
  unint64_t *v28;
  unint64_t v29;
  uint64_t v30;
  size_t OffsetFromEnd;
  uint64_t v32;
  int v33;
  NSObject *v34;
  _OWORD *v35;
  uint64_t v36;
  unint64_t *v37;
  unint64_t v38;
  unint64_t *v39;
  unint64_t v40;
  NSObject *v41;
  const UInt8 *v42;
  int v43;
  NSObject *v44;
  size_t v45;
  int v46;
  NSObject *v47;
  int v48;
  NSObject *v49;
  _BYTE *v50;
  int v51;
  NSObject *v52;
  _BYTE *v53;
  NSObject *v54;
  int v55;
  NSObject *v56;
  int v58;
  int v59;
  int v60;
  char *v61;
  char *v62;
  const char *v63;
  char *v64;
  char *v65;
  const char *v66;
  char *v67;
  const char *v68;
  char *v69;
  const char *v70;
  char *v71;
  const char *v72;
  uint64_t v73;
  char *v74;
  const char *v75;
  char *v76;
  const char *v77;
  unsigned int v78;
  uint64_t v79;
  float v80;
  unsigned int v81;
  uint8_t buf[4];
  _BYTE *v83;
  _BYTE __p[12];
  __int16 v85;
  int v86;
  __int16 v87;
  _BYTE v88[14];
  __int16 v89;
  uint64_t v90;
  uint64_t v91;

  v91 = *MEMORY[0x1E0C80C00];
  v81 = a4;
  v80 = a5;
  if (*(_BYTE *)(a1 + 144))
  {
    v61 = __si_assert_copy_extra_268();
    v62 = v61;
    v63 = "";
    if (v61)
      v63 = v61;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2430, "!readOnly", v63);
    goto LABEL_104;
  }
  Vector = IVFVectorIndexTemplate<float,256>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::findVector(a1, (uint64_t)a3, (int *)&v81, &v80, a2);
  v9 = v81;
  if (v81 == -1)
  {
    v64 = __si_assert_copy_extra_268();
    v65 = v64;
    v66 = "";
    if (v64)
      v66 = v64;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2435, "partID != VECTOR_NOT_FOUND", v66);
    goto LABEL_94;
  }
  if (Vector != -1)
  {
    Ptr = (_DWORD *)vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(*(_QWORD *)(a1 + 32) + 16), Vector, 1044);
    if (Ptr[260] == a2)
      return Ptr;
    v79 = 0;
    data = data_map_get_data(*(_QWORD *)(a1 + 128), a2, &v79);
    v12 = *__error();
    v13 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__p = 136316162;
      *(_QWORD *)&__p[4] = "lookupForInsert";
      v85 = 1024;
      v86 = 2463;
      v87 = 1024;
      *(_DWORD *)v88 = a2;
      *(_WORD *)&v88[4] = 2048;
      *(_QWORD *)&v88[6] = data;
      v89 = 2048;
      v90 = v79;
      _os_log_error_impl(&dword_1B8270000, v13, OS_LOG_TYPE_ERROR, "%s:%d: vectorId=%u in datamap: %p size=%zd", __p, 0x2Cu);
    }
    *__error() = v12;
    if (v79 < 1)
    {
      v19 = *__error();
      v41 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__p = 136315394;
        *(_QWORD *)&__p[4] = "lookupForInsert";
        v85 = 1024;
        v86 = 2472;
        _os_log_error_impl(&dword_1B8270000, v41, OS_LOG_TYPE_ERROR, "%s:%d: vectorId is invalid", __p, 0x12u);
      }
    }
    else
    {
      if (v79 != 1024)
      {
        v74 = __si_assert_copy_extra_268();
        v62 = v74;
        v75 = "";
        if (v74)
          v75 = v74;
        __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2465, "size == D * sizeof(ELEM_TYPE)", v75);
        goto LABEL_104;
      }
      if (!data || !memcmp(data, a3, 0x400uLL))
        goto LABEL_51;
      v14 = *__error();
      v15 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__p = 136315394;
        *(_QWORD *)&__p[4] = "lookupForInsert";
        v85 = 1024;
        v86 = 2467;
        _os_log_error_impl(&dword_1B8270000, v15, OS_LOG_TYPE_ERROR, "%s:%d: vector in datamap is not same as vector passed in", __p, 0x12u);
      }
      *__error() = v14;
      v16 = *__error();
      v17 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        data2hexString(__p, (uint64_t)data, v79);
        v18 = v88[3] >= 0 ? __p : *(_BYTE **)__p;
        *(_DWORD *)buf = 136315138;
        v83 = v18;
        _os_log_impl(&dword_1B8270000, v17, OS_LOG_TYPE_DEFAULT, "vector in datamap: %s", buf, 0xCu);
        if ((v88[3] & 0x80000000) != 0)
          operator delete(*(void **)__p);
      }
      *__error() = v16;
      v19 = *__error();
      v20 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        data2hexString(__p, (uint64_t)a3, v79);
        v21 = v88[3] >= 0 ? __p : *(_BYTE **)__p;
        *(_DWORD *)buf = 136315138;
        v83 = v21;
        _os_log_impl(&dword_1B8270000, v20, OS_LOG_TYPE_DEFAULT, "vector passed in: %s", buf, 0xCu);
        if ((v88[3] & 0x80000000) != 0)
          operator delete(*(void **)__p);
      }
    }
    *__error() = v19;
LABEL_51:
    v42 = data_map_get_data(*(_QWORD *)(a1 + 128), Ptr[260], &v79);
    v43 = *__error();
    v44 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
    {
      v58 = Ptr[260];
      *(_DWORD *)__p = 136316162;
      *(_QWORD *)&__p[4] = "lookupForInsert";
      v85 = 1024;
      v86 = 2475;
      v87 = 1024;
      *(_DWORD *)v88 = v58;
      *(_WORD *)&v88[4] = 2048;
      *(_QWORD *)&v88[6] = v42;
      v89 = 2048;
      v90 = v79;
      _os_log_error_impl(&dword_1B8270000, v44, OS_LOG_TYPE_ERROR, "%s:%d: old vectorId=%u in datamap: %p size=%zd", __p, 0x2Cu);
    }
    *__error() = v43;
    if (v79 < 1)
    {
      v51 = *__error();
      v54 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__p = 136315394;
        *(_QWORD *)&__p[4] = "lookupForInsert";
        v85 = 1024;
        v86 = 2484;
        _os_log_error_impl(&dword_1B8270000, v54, OS_LOG_TYPE_ERROR, "%s:%d: old vectorId is invalid", __p, 0x12u);
      }
      goto LABEL_73;
    }
    if (v79 == 1024)
    {
      v45 = 1024;
      if (!v42 || !memcmp(v42, Ptr, 0x400uLL))
        goto LABEL_74;
      v46 = *__error();
      v47 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__p = 136315394;
        *(_QWORD *)&__p[4] = "lookupForInsert";
        v85 = 1024;
        v86 = 2479;
        _os_log_error_impl(&dword_1B8270000, v47, OS_LOG_TYPE_ERROR, "%s:%d: vector in datamap is not same as vector passed in", __p, 0x12u);
      }
      *__error() = v46;
      v48 = *__error();
      v49 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
      {
        data2hexString(__p, (uint64_t)v42, v79);
        v50 = v88[3] >= 0 ? __p : *(_BYTE **)__p;
        *(_DWORD *)buf = 136315138;
        v83 = v50;
        _os_log_impl(&dword_1B8270000, v49, OS_LOG_TYPE_DEFAULT, "vector in datamap: %s", buf, 0xCu);
        if ((v88[3] & 0x80000000) != 0)
          operator delete(*(void **)__p);
      }
      *__error() = v48;
      v51 = *__error();
      v52 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
      {
        data2hexString(__p, (uint64_t)Ptr, v79);
        v53 = v88[3] >= 0 ? __p : *(_BYTE **)__p;
        *(_DWORD *)buf = 136315138;
        v83 = v53;
        _os_log_impl(&dword_1B8270000, v52, OS_LOG_TYPE_DEFAULT, "vector in vector store: %s", buf, 0xCu);
        if ((v88[3] & 0x80000000) != 0)
          operator delete(*(void **)__p);
      }
LABEL_73:
      *__error() = v51;
      v45 = v79;
LABEL_74:
      if (!memcmp(a3, Ptr, v45))
      {
        v55 = *__error();
        v56 = _SILogForLogForCategory(16);
        if (os_log_type_enabled(v56, OS_LOG_TYPE_FAULT))
        {
          v59 = Ptr[260];
          *(_DWORD *)__p = 136315906;
          *(_QWORD *)&__p[4] = "lookupForInsert";
          v85 = 1024;
          v86 = 2487;
          v87 = 1024;
          *(_DWORD *)v88 = a2;
          *(_WORD *)&v88[4] = 1024;
          *(_DWORD *)&v88[6] = v59;
          _os_log_fault_impl(&dword_1B8270000, v56, OS_LOG_TYPE_FAULT, "%s:%d: Dup vector with new vectorId=%u old=%u", __p, 0x1Eu);
        }
        *__error() = v55;
        return Ptr;
      }
      v71 = __si_assert_copy_extra_268();
      v65 = v71;
      v72 = "";
      if (v71)
        v72 = v71;
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2486, "memcmp(vec.vec, entry->vec.vec, size) == 0", v72);
LABEL_94:
      free(v65);
      if (__valid_fs(-1))
        v73 = 2989;
      else
        v73 = 3072;
      *(_DWORD *)v73 = -559038737;
      abort();
    }
    v76 = __si_assert_copy_extra_268();
    v62 = v76;
    v77 = "";
    if (v76)
      v77 = v76;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2477, "size == D * sizeof(ELEM_TYPE)", v77);
LABEL_104:
    free(v62);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v78 = a2;
  v22 = a3;
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  v23 = *(std::__shared_weak_count **)(a1 + 72);
  if (v23)
  {
    p_shared_owners = (unint64_t *)&v23->__shared_owners_;
    do
      v25 = __ldxr(p_shared_owners);
    while (__stxr(v25 + 1, p_shared_owners));
  }
  v27 = *(_DWORD **)(a1 + 80);
  v26 = *(std::__shared_weak_count **)(a1 + 88);
  if (v26)
  {
    v28 = (unint64_t *)&v26->__shared_owners_;
    do
      v29 = __ldxr(v28);
    while (__stxr(v29 + 1, v28));
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
  v30 = *(_QWORD *)(a1 + 32);
  OffsetFromEnd = vi_onefixedsize_memory_allocator::allocateOffsetFromEnd(*(_QWORD *)(v30 + 16), 0x414u);
  v32 = *(unsigned int *)(v30 + 24);
  if (OffsetFromEnd != v32)
  {
    v33 = *__error();
    v34 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
    {
      v60 = *(_DWORD *)(v30 + 24);
      *(_DWORD *)__p = 136315906;
      *(_QWORD *)&__p[4] = "newEntry";
      v85 = 1024;
      v86 = 1779;
      v87 = 2048;
      *(_QWORD *)v88 = OffsetFromEnd;
      *(_WORD *)&v88[8] = 1024;
      *(_DWORD *)&v88[10] = v60;
      _os_log_error_impl(&dword_1B8270000, v34, OS_LOG_TYPE_ERROR, "%s:%d: offset: %llu, nVectors: %u", __p, 0x22u);
    }
    *__error() = v33;
    v32 = *(unsigned int *)(v30 + 24);
    if (OffsetFromEnd != v32)
    {
      v69 = __si_assert_copy_extra_268();
      v62 = v69;
      v70 = "";
      if (v69)
        v70 = v69;
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1782, "offset == nVectors", v70);
      goto LABEL_104;
    }
  }
  *(_DWORD *)(v30 + 24) = v32 + 1;
  v35 = (_OWORD *)vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(v30 + 16), OffsetFromEnd, 1044);
  memcpy(v35, v22, 0x400uLL);
  v35[64] = 0u;
  (*(void (**)(_DWORD *, uint64_t, size_t, float))(*(_QWORD *)v27 + 56))(v27, v9, OffsetFromEnd, v80);
  v36 = *(_QWORD *)(a1 + 32);
  if (v27[18] != *(_DWORD *)(v36 + 24))
  {
    v67 = __si_assert_copy_extra_268();
    v62 = v67;
    v68 = "";
    if (v67)
      v68 = v67;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2440, "cur.partitions->nVectors() == vectors->count()", v68);
    goto LABEL_104;
  }
  Ptr = (_DWORD *)vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(v36 + 16), OffsetFromEnd, 1044);
  Ptr[260] = v78;
  if (*(_DWORD *)(*(_QWORD *)(a1 + 32) + 24) == 1)
    *(_DWORD *)(a1 + 148) = v78;
  *(_DWORD *)(a1 + 152) = v78;
  if (v26)
  {
    v37 = (unint64_t *)&v26->__shared_owners_;
    do
      v38 = __ldaxr(v37);
    while (__stlxr(v38 - 1, v37));
    if (!v38)
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
    }
  }
  if (v23)
  {
    v39 = (unint64_t *)&v23->__shared_owners_;
    do
      v40 = __ldaxr(v39);
    while (__stlxr(v40 - 1, v39));
    if (!v40)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
  return Ptr;
}

uint64_t IVFVectorIndexTemplate<float,256>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::findVector(uint64_t a1, uint64_t a2, int *a3, _DWORD *a4, int a5)
{
  os_unfair_lock_s *v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  std::__shared_weak_count *v15;
  _DWORD *v16;
  unint64_t *v17;
  unint64_t v18;
  uint64_t v19;
  _DWORD *v20;
  unsigned int v21;
  uint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  unint64_t *v25;
  unint64_t v26;
  char *v28;
  char *v29;
  const char *v30;
  char *v31;
  const char *v32;
  char *v33;
  char *v34;
  const char *v35;
  int v36;
  int v37;
  int v38;
  int v39;
  _QWORD v40[8];
  int v41;
  _DWORD *v42;
  char *v43;
  uint64_t v44;
  int v45;

  v10 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  v12 = *(_QWORD *)(a1 + 64);
  v11 = *(std::__shared_weak_count **)(a1 + 72);
  if (v11)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      v14 = __ldxr(p_shared_owners);
    while (__stxr(v14 + 1, p_shared_owners));
  }
  v16 = *(_DWORD **)(a1 + 80);
  v15 = *(std::__shared_weak_count **)(a1 + 88);
  if (v15)
  {
    v17 = (unint64_t *)&v15->__shared_owners_;
    do
      v18 = __ldxr(v17);
    while (__stxr(v18 + 1, v17));
  }
  os_unfair_lock_unlock(v10);
  v19 = *a3;
  if ((_DWORD)v19 == -1)
  {
    if (*(_DWORD *)(a1 + 140) == -1)
    {
      v42 = 0;
      v43 = 0;
      v44 = 0;
      (*(void (**)(_DWORD **__return_ptr, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v12 + 72))(&v42, v12, a2, 1);
      v20 = v42;
      if (v43 - (char *)v42 == 8)
      {
        v21 = *v42;
        *a3 = *v42;
        *a4 = v20[1];
        if (v21 >= IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nPartitions(a1))
        {
          v33 = __si_assert_copy_extra_268();
          v34 = v33;
          if (v33)
            v35 = v33;
          else
            v35 = "";
          v36 = *a3;
          v37 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nPartitions(a1);
          v38 = v16[19];
          v39 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v12 + 16))(v12);
          __message_assert("%s:%u: failed assertion '%s' %s Invalid partId %u >= %u (partitions: v%u quantizer v%u", "IVFVectorIndex.hh", 2403, "partID < nPartitions()", v35, v36, v37, v38, v39);
          free(v34);
          if (__valid_fs(-1))
          {
            MEMORY[0xBAD] = -559038737;
            abort();
          }
          MEMORY[0xC00] = -559038737;
          abort();
        }
        if (v42)
        {
          v43 = (char *)v42;
          operator delete(v42);
        }
        v19 = *a3;
        goto LABEL_14;
      }
      v31 = __si_assert_copy_extra_268();
      v29 = v31;
      v32 = "";
      if (v31)
        v32 = v31;
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2398, "topPartition.size() == 1", v32);
    }
    else
    {
      v28 = __si_assert_copy_extra_268();
      v29 = v28;
      v30 = "";
      if (v28)
        v30 = v28;
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2396, "mergeBeginVectorOffset == VECTOR_NOT_FOUND", v30);
    }
    free(v29);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
LABEL_14:
  v42 = 0;
  v43 = (char *)&v42;
  v45 = -1;
  v44 = 0x2000000000;
  v40[0] = MEMORY[0x1E0C809B0];
  v40[1] = 0x40000000;
  v40[2] = ___ZN22IVFVectorIndexTemplateIfLi256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE10findVectorERK10CIVector_sIfLi256EERjRfj_block_invoke;
  v40[3] = &unk_1E6E32588;
  v41 = a5;
  v40[6] = a4;
  v40[7] = a2;
  v40[4] = &v42;
  v40[5] = a1;
  (*(void (**)(_DWORD *, uint64_t, _QWORD *))(*(_QWORD *)v16 + 80))(v16, v19, v40);
  v22 = *((unsigned int *)v43 + 6);
  _Block_object_dispose(&v42, 8);
  if (v15)
  {
    v23 = (unint64_t *)&v15->__shared_owners_;
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  if (v11)
  {
    v25 = (unint64_t *)&v11->__shared_owners_;
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  return v22;
}

unint64_t ___ZN22IVFVectorIndexTemplateIfLi256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE10findVectorERK10CIVector_sIfLi256EERjRfj_block_invoke(unint64_t result, uint64_t a2, float *a3, _BYTE *a4)
{
  uint64_t v5;
  uint64_t v6;
  unint64_t v8;
  float v9;
  float v10;
  BOOL v11;
  float v12;
  float v13;
  int v15;
  const void *v16;
  const void *Ptr;

  v5 = *(_QWORD *)(result + 40);
  v6 = *(unsigned int *)a3;
  if (v6 >= *(_DWORD *)(v5 + 140))
    goto LABEL_12;
  v8 = result;
  v9 = **(float **)(result + 48);
  v10 = a3[1];
  v11 = v9 == v10;
  v12 = vabds_f32(v9, v10);
  v13 = fmaxf(fminf(fabsf(v10), fabsf(v9)) * 0.000015259, 0.000015259);
  if (v11 || v12 <= v13)
  {
    v15 = *(_DWORD *)(result + 64);
    if (v15)
    {
      result = vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(*(_QWORD *)(v5 + 32) + 16), v6, 1044);
      if (v15 != *(_DWORD *)(result + 1040))
        return result;
      *(float *)&v6 = *a3;
    }
    v16 = *(const void **)(v8 + 56);
    Ptr = (const void *)vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(*(_QWORD *)(v5 + 32) + 16), v6, 1044);
    result = memcmp(v16, Ptr, 0x400uLL);
    if (!(_DWORD)result)
    {
      *(float *)(*(_QWORD *)(*(_QWORD *)(v8 + 32) + 8) + 24) = *a3;
LABEL_12:
      *a4 = 1;
    }
  }
  return result;
}

int *IVFVectorIndexTemplate<float,256>::VectorStore<vi_onefixedsize_memory_allocator,vi_memory_postings>::truncate(uint64_t a1)
{
  int v2;
  NSObject *v3;
  _QWORD *v4;
  int v5;
  int v6;
  int v7;
  int *result;
  int v9;
  _QWORD *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  int v14;
  __int16 v15;
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v2 = *__error();
  v3 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = (_QWORD *)(a1 + 40);
    if (*(char *)(a1 + 63) < 0)
      v4 = (_QWORD *)*v4;
    v5 = *(_DWORD *)(a1 + 24);
    v6 = *(_DWORD *)(vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(a1 + 16), 0, 1044) + 1040);
    v7 = *(_DWORD *)(vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(a1 + 16), (*(_DWORD *)(a1 + 24) - 1), 1044)+ 1040);
    v9 = 136315906;
    v10 = v4;
    v11 = 1024;
    v12 = v5;
    v13 = 1024;
    v14 = v6;
    v15 = 1024;
    v16 = v7;
    _os_log_impl(&dword_1B8270000, v3, OS_LOG_TYPE_DEFAULT, "truncate VectorStore %s(%u)[%u,%u]", (uint8_t *)&v9, 0x1Eu);
  }
  result = __error();
  *result = v2;
  return result;
}

void ___ZNK22IVFVectorIndexTemplateIfLi256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE4dumpEbbPViPvU13block_pointerFbjPKvybjfE_block_invoke()
{
  char *v0;
  char *v1;
  const char *v2;

  v0 = __si_assert_copy_extra_268();
  v1 = v0;
  v2 = "";
  if (v0)
    v2 = v0;
  __message_assert("%s:%u: failed assertion '%s' %s ", "VectorIndexSupport.hh", 2544, "0", v2);
  free(v1);
  if (__valid_fs(-1))
  {
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  MEMORY[0xC00] = -559038737;
  abort();
}

BOOL IVFVectorIndexTemplate<float,256>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::exists(uint64_t a1, uint64_t a2)
{
  int Vector;
  int v6;
  NSObject *v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  std::__shared_weak_count *v12;
  uint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  unsigned int v16;
  uint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  _QWORD v32[8];
  std::__shared_weak_count *v33;
  uint64_t v34;
  std::__shared_weak_count *v35;
  unsigned int v36;
  _QWORD v37[7];
  unsigned int v38;
  float v39;
  float v40;
  unsigned int v41;
  _BYTE buf[24];
  _DWORD v43[4];
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  v40 = 3.4028e38;
  v41 = -1;
  Vector = IVFVectorIndexTemplate<float,256>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::findVector(a1, a2, (int *)&v41, &v40, 0);
  if (Vector == -1)
  {
    v6 = *__error();
    v7 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = "exists";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 2632;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v41;
      LOWORD(v43[0]) = 2048;
      *(double *)((char *)v43 + 2) = v40;
      _os_log_error_impl(&dword_1B8270000, v7, OS_LOG_TYPE_ERROR, "%s:%d: Vector not found partID=%u distsq=%e", buf, 0x22u);
    }
    *__error() = v6;
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
    v9 = *(_QWORD *)(a1 + 64);
    v8 = *(std::__shared_weak_count **)(a1 + 72);
    if (v8)
    {
      p_shared_owners = (unint64_t *)&v8->__shared_owners_;
      do
        v11 = __ldxr(p_shared_owners);
      while (__stxr(v11 + 1, p_shared_owners));
    }
    v13 = *(_QWORD *)(a1 + 80);
    v12 = *(std::__shared_weak_count **)(a1 + 88);
    if (v12)
    {
      v14 = (unint64_t *)&v12->__shared_owners_;
      do
        v15 = __ldxr(v14);
      while (__stxr(v15 + 1, v14));
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    v43[0] = -1;
    *(_QWORD *)&buf[16] = 0x2000000000;
    v16 = v41;
    v17 = MEMORY[0x1E0C809B0];
    v37[0] = MEMORY[0x1E0C809B0];
    v37[1] = 0x40000000;
    v37[2] = ___ZN22IVFVectorIndexTemplateIfLi256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE6existsERK10CIVector_sIfLi256EE_block_invoke;
    v37[3] = &unk_1E6E32528;
    v37[5] = a1;
    v37[6] = a2;
    v38 = v41;
    v39 = v40;
    v37[4] = buf;
    (*(void (**)(uint64_t, _QWORD, _QWORD *))(*(_QWORD *)v13 + 80))(v13, v41, v37);
    if (*(_DWORD *)(*(_QWORD *)&buf[8] + 24) == -1)
    {
      v32[0] = v17;
      v32[1] = 1174405120;
      v32[2] = ___ZN22IVFVectorIndexTemplateIfLi256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE6existsERK10CIVector_sIfLi256EE_block_invoke_522;
      v32[3] = &unk_1E6E32550;
      v32[5] = a1;
      v32[6] = a2;
      v32[7] = v9;
      v33 = v8;
      if (v8)
      {
        v22 = (unint64_t *)&v8->__shared_owners_;
        do
          v23 = __ldxr(v22);
        while (__stxr(v23 + 1, v22));
      }
      v34 = v13;
      v35 = v12;
      if (v12)
      {
        v24 = (unint64_t *)&v12->__shared_owners_;
        do
          v25 = __ldxr(v24);
        while (__stxr(v25 + 1, v24));
      }
      v36 = v16;
      v32[4] = buf;
      (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v13 + 64))(v13, v32);
      v26 = v35;
      if (v35)
      {
        v27 = (unint64_t *)&v35->__shared_owners_;
        do
          v28 = __ldaxr(v27);
        while (__stlxr(v28 - 1, v27));
        if (!v28)
        {
          ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
          std::__shared_weak_count::__release_weak(v26);
        }
      }
      v29 = v33;
      if (v33)
      {
        v30 = (unint64_t *)&v33->__shared_owners_;
        do
          v31 = __ldaxr(v30);
        while (__stlxr(v31 - 1, v30));
        if (!v31)
        {
          ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
          std::__shared_weak_count::__release_weak(v29);
        }
      }
    }
    _Block_object_dispose(buf, 8);
    if (v12)
    {
      v18 = (unint64_t *)&v12->__shared_owners_;
      do
        v19 = __ldaxr(v18);
      while (__stlxr(v19 - 1, v18));
      if (!v19)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
    if (v8)
    {
      v20 = (unint64_t *)&v8->__shared_owners_;
      do
        v21 = __ldaxr(v20);
      while (__stlxr(v21 - 1, v20));
      if (!v21)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }
  }
  return Vector != -1;
}

void ___ZN22IVFVectorIndexTemplateIfLi256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE6existsERK10CIVector_sIfLi256EE_block_invoke_522(uint64_t a1, int a2, float *a3, _BYTE *a4)
{
  const void *v8;
  uint64_t v9;
  const void *Ptr;
  int v11;
  NSObject *v12;
  const float *v13;
  const float *v14;
  float v15;
  int v16;
  NSObject *v17;
  int v18;
  NSObject *v19;
  int v20;
  NSObject *v21;
  int v22;
  NSObject *v23;
  int v24;
  NSObject *v25;
  int v26;
  NSObject *v27;
  uint64_t v28;
  unint64_t v29;
  int v30;
  NSObject *v31;
  int v32;
  NSObject *v33;
  int v34;
  NSObject *v35;
  int v36;
  NSObject *v37;
  int v38;
  NSObject *v39;
  double v40;
  int v41;
  int v42;
  float v43;
  int v44;
  float v45;
  _BOOL4 v46;
  int v47;
  int v48;
  _BOOL4 v49;
  int v50;
  int v51;
  _BOOL4 v52;
  int v53;
  int v54;
  _BOOL4 v55;
  int v56;
  int v57;
  float v58;
  float v59;
  double v60;
  float v61;
  _BOOL4 v62;
  _BOOL4 v63;
  int v64;
  float v65;
  int v66;
  float v67;
  _BOOL4 v68;
  int v69;
  int v70;
  _BOOL4 v71;
  int v72;
  int v73;
  _BOOL4 v74;
  int v75;
  int v76;
  _BOOL4 v77;
  int v78;
  int v79;
  float v80;
  float v81;
  float v82;
  _BOOL4 v83;
  _BOOL4 v84;
  _BOOL4 v85;
  float v86;
  float v87;
  float v88;
  float v89;
  void *__p;
  void *v91;
  uint64_t v92;
  void *v93;
  void *v94;
  uint64_t v95;
  float __C;
  const char *v97;
  __int16 v98;
  int v99;
  __int16 v100;
  int v101;
  __int16 v102;
  _BYTE v103[14];
  __int16 v104;
  double v105;
  __int16 v106;
  uint64_t v107;
  __int16 v108;
  _BOOL4 v109;
  __int16 v110;
  _BOOL4 v111;
  __int16 v112;
  _BOOL4 v113;
  __int16 v114;
  _BOOL4 v115;
  uint64_t v116;

  v116 = *MEMORY[0x1E0C80C00];
  v9 = *(_QWORD *)(a1 + 40);
  v8 = *(const void **)(a1 + 48);
  Ptr = (const void *)vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(*(_QWORD *)(v9 + 32) + 16), *(unsigned int *)a3, 1044);
  if (!memcmp(v8, Ptr, 0x400uLL))
  {
    v11 = *__error();
    v12 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      v40 = a3[1];
      __C = 4.8153e-34;
      v97 = "exists_block_invoke";
      v98 = 1024;
      v99 = 2647;
      v100 = 1024;
      v101 = a2;
      v102 = 2048;
      *(double *)v103 = v40;
      _os_log_error_impl(&dword_1B8270000, v12, OS_LOG_TYPE_ERROR, "%s:%d: Vector not found actually in partID=%u distsq=%e", (uint8_t *)&__C, 0x22u);
    }
    *__error() = v11;
    v13 = *(const float **)(a1 + 48);
    v14 = (const float *)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 56) + 64))(*(_QWORD *)(a1 + 56), *(unsigned int *)(a1 + 88));
    __C = 3.4028e38;
    vDSP_distancesq(v13, 1, v14, 1, &__C, 0x100uLL);
    v15 = __C;
    v16 = *__error();
    v17 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      v41 = *(_DWORD *)(a1 + 88);
      __C = 4.8153e-34;
      v97 = "exists_block_invoke";
      v98 = 1024;
      v99 = 2649;
      v100 = 1024;
      v101 = v41;
      v102 = 2048;
      *(double *)v103 = v15;
      _os_log_error_impl(&dword_1B8270000, v17, OS_LOG_TYPE_ERROR, "%s:%d: Vec distance to centroid %u distsq=%e", (uint8_t *)&__C, 0x22u);
    }
    *__error() = v16;
    v93 = 0;
    v94 = 0;
    v95 = 0;
    (*(void (**)(void **__return_ptr, _QWORD, _QWORD, uint64_t))(**(_QWORD **)(a1 + 56) + 72))(&v93, *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 48), 2);
    v18 = *__error();
    v19 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      v42 = *(_DWORD *)v93;
      v43 = *((float *)v93 + 1);
      v44 = *((_DWORD *)v93 + 2);
      v45 = *((float *)v93 + 3);
      v46 = v43 == v45 || vabds_f32(v43, v45) <= fmaxf(fminf(fabsf(v45), fabsf(v43)) * 0.000015259, 0.000015259);
      __C = 4.8156e-34;
      v97 = "exists_block_invoke";
      v98 = 1024;
      v99 = 2651;
      v100 = 1024;
      v101 = v42;
      v102 = 2048;
      *(double *)v103 = v43;
      *(_WORD *)&v103[8] = 1024;
      *(_DWORD *)&v103[10] = v44;
      v104 = 2048;
      v105 = v45;
      v106 = 1024;
      LODWORD(v107) = v46;
      _os_log_error_impl(&dword_1B8270000, v19, OS_LOG_TYPE_ERROR, "%s:%d: topKPartition(vec, 2) <%u, %e>, <%u, %e>, %d", (uint8_t *)&__C, 0x38u);
    }
    *__error() = v18;
    v20 = *__error();
    v21 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      v47 = *(_DWORD *)v93;
      v48 = *((_DWORD *)v93 + 2);
      v49 = *((float *)v93 + 1) == *((float *)v93 + 3);
      __C = 4.8154e-34;
      v97 = "exists_block_invoke";
      v98 = 1024;
      v99 = 2652;
      v100 = 1024;
      v101 = v47;
      v102 = 1024;
      *(_DWORD *)v103 = v48;
      *(_WORD *)&v103[4] = 1024;
      *(_DWORD *)&v103[6] = v49;
      _os_log_error_impl(&dword_1B8270000, v21, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) == distsq(%u) is %d", (uint8_t *)&__C, 0x24u);
    }
    *__error() = v20;
    v22 = *__error();
    v23 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      v50 = *(_DWORD *)v93;
      v51 = *((_DWORD *)v93 + 2);
      v52 = *((float *)v93 + 1) < *((float *)v93 + 3);
      __C = 4.8154e-34;
      v97 = "exists_block_invoke";
      v98 = 1024;
      v99 = 2653;
      v100 = 1024;
      v101 = v50;
      v102 = 1024;
      *(_DWORD *)v103 = v51;
      *(_WORD *)&v103[4] = 1024;
      *(_DWORD *)&v103[6] = v52;
      _os_log_error_impl(&dword_1B8270000, v23, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) < distsq(%u) is %d", (uint8_t *)&__C, 0x24u);
    }
    *__error() = v22;
    v24 = *__error();
    v25 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      v53 = *(_DWORD *)v93;
      v54 = *((_DWORD *)v93 + 2);
      v55 = *((float *)v93 + 1) > *((float *)v93 + 3);
      __C = 4.8154e-34;
      v97 = "exists_block_invoke";
      v98 = 1024;
      v99 = 2654;
      v100 = 1024;
      v101 = v53;
      v102 = 1024;
      *(_DWORD *)v103 = v54;
      *(_WORD *)&v103[4] = 1024;
      *(_DWORD *)&v103[6] = v55;
      _os_log_error_impl(&dword_1B8270000, v25, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) > distsq(%u) is %d", (uint8_t *)&__C, 0x24u);
    }
    *__error() = v24;
    v26 = *__error();
    v27 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      v56 = *(_DWORD *)v93;
      v57 = *((_DWORD *)v93 + 2);
      v58 = *((float *)v93 + 1);
      v59 = *((float *)v93 + 3);
      v60 = (float)(v58 - v59);
      v61 = vabds_f32(v58, v59);
      if (v58 == v59)
      {
        v62 = 1;
        v63 = 1;
      }
      else
      {
        v86 = fabsf(v58);
        v87 = fabsf(v59);
        v62 = v61 <= fmaxf(fminf(v87, v86) * 0.000015259, 0.000015259);
        v63 = v61 <= (float)(fmaxf(v86, v87) * 0.000015259);
      }
      __C = 4.8161e-34;
      v97 = "exists_block_invoke";
      v98 = 1024;
      v99 = 2655;
      v100 = 1024;
      v101 = v56;
      v102 = 1024;
      *(_DWORD *)v103 = v57;
      *(_WORD *)&v103[4] = 2048;
      *(double *)&v103[6] = v60;
      v104 = 2048;
      v105 = 1.17549435e-38;
      v106 = 2048;
      v107 = 0x3E80000000000000;
      v108 = 1024;
      v109 = v61 < 1.1755e-38;
      v110 = 1024;
      v111 = v61 < 0.00000011921;
      v112 = 1024;
      v113 = v62;
      v114 = 1024;
      v115 = v63;
      _os_log_error_impl(&dword_1B8270000, v27, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) - distsq(%u) = %e, FLT_MIN=%e, EPSILON=%e, %d, %d, %d, %d", (uint8_t *)&__C, 0x54u);
    }
    *__error() = v26;
    v91 = 0;
    v92 = 0;
    __p = 0;
    v28 = *(_QWORD *)(a1 + 56);
    v29 = vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(*(_QWORD *)(v9 + 32) + 16), *(unsigned int *)a3, 1044);
    (*(void (**)(void **__return_ptr, uint64_t, unint64_t, uint64_t))(*(_QWORD *)v28 + 72))(&__p, v28, v29, 2);
    v30 = *__error();
    v31 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
    {
      v64 = *(_DWORD *)__p;
      v65 = *((float *)__p + 1);
      v66 = *((_DWORD *)__p + 2);
      v67 = *((float *)__p + 3);
      v68 = v65 == v67 || vabds_f32(v65, v67) <= fmaxf(fminf(fabsf(v67), fabsf(v65)) * 0.000015259, 0.000015259);
      __C = 4.8156e-34;
      v97 = "exists_block_invoke";
      v98 = 1024;
      v99 = 2658;
      v100 = 1024;
      v101 = v64;
      v102 = 2048;
      *(double *)v103 = v65;
      *(_WORD *)&v103[8] = 1024;
      *(_DWORD *)&v103[10] = v66;
      v104 = 2048;
      v105 = v67;
      v106 = 1024;
      LODWORD(v107) = v68;
      _os_log_error_impl(&dword_1B8270000, v31, OS_LOG_TYPE_ERROR, "%s:%d: topKPartition(entry->vec, 2) <%u, %e>, <%u, %e>, %d", (uint8_t *)&__C, 0x38u);
    }
    *__error() = v30;
    v32 = *__error();
    v33 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
    {
      v69 = *(_DWORD *)__p;
      v70 = *((_DWORD *)__p + 2);
      v71 = *((float *)__p + 1) == *((float *)__p + 3);
      __C = 4.8154e-34;
      v97 = "exists_block_invoke";
      v98 = 1024;
      v99 = 2659;
      v100 = 1024;
      v101 = v69;
      v102 = 1024;
      *(_DWORD *)v103 = v70;
      *(_WORD *)&v103[4] = 1024;
      *(_DWORD *)&v103[6] = v71;
      _os_log_error_impl(&dword_1B8270000, v33, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) == distsq(%u) is %d", (uint8_t *)&__C, 0x24u);
    }
    *__error() = v32;
    v34 = *__error();
    v35 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
    {
      v72 = *(_DWORD *)__p;
      v73 = *((_DWORD *)__p + 2);
      v74 = *((float *)__p + 1) < *((float *)__p + 3);
      __C = 4.8154e-34;
      v97 = "exists_block_invoke";
      v98 = 1024;
      v99 = 2660;
      v100 = 1024;
      v101 = v72;
      v102 = 1024;
      *(_DWORD *)v103 = v73;
      *(_WORD *)&v103[4] = 1024;
      *(_DWORD *)&v103[6] = v74;
      _os_log_error_impl(&dword_1B8270000, v35, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) < distsq(%u) is %d", (uint8_t *)&__C, 0x24u);
    }
    *__error() = v34;
    v36 = *__error();
    v37 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
    {
      v75 = *(_DWORD *)__p;
      v76 = *((_DWORD *)__p + 2);
      v77 = *((float *)__p + 1) > *((float *)__p + 3);
      __C = 4.8154e-34;
      v97 = "exists_block_invoke";
      v98 = 1024;
      v99 = 2661;
      v100 = 1024;
      v101 = v75;
      v102 = 1024;
      *(_DWORD *)v103 = v76;
      *(_WORD *)&v103[4] = 1024;
      *(_DWORD *)&v103[6] = v77;
      _os_log_error_impl(&dword_1B8270000, v37, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) > distsq(%u) is %d", (uint8_t *)&__C, 0x24u);
    }
    *__error() = v36;
    v38 = *__error();
    v39 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
    {
      v78 = *(_DWORD *)__p;
      v79 = *((_DWORD *)__p + 2);
      v80 = *((float *)__p + 1);
      v81 = *((float *)__p + 3);
      v82 = vabds_f32(v80, v81);
      v83 = (float)(v80 - v81) < 1.1755e-38;
      if (v80 == v81)
      {
        v84 = 1;
        v85 = 1;
      }
      else
      {
        v88 = fabsf(v80);
        v89 = fabsf(v81);
        v84 = v82 <= fmaxf(fminf(v89, v88) * 0.000015259, 0.000015259);
        v85 = v82 <= (float)(fmaxf(v88, v89) * 0.000015259);
      }
      __C = 4.8161e-34;
      v97 = "exists_block_invoke";
      v98 = 1024;
      v99 = 2662;
      v100 = 1024;
      v101 = v78;
      v102 = 1024;
      *(_DWORD *)v103 = v79;
      *(_WORD *)&v103[4] = 2048;
      *(double *)&v103[6] = v82;
      v104 = 2048;
      v105 = 1.17549435e-38;
      v106 = 2048;
      v107 = 0x3E80000000000000;
      v108 = 1024;
      v109 = v83;
      v110 = 1024;
      v111 = v82 < 0.00000011921;
      v112 = 1024;
      v113 = v84;
      v114 = 1024;
      v115 = v85;
      _os_log_error_impl(&dword_1B8270000, v39, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) - distsq(%u) = %e, FLT_MIN=%e, EPSILON=%e, %d, %d, %d, %d", (uint8_t *)&__C, 0x54u);
    }
    *__error() = v38;
    *(float *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *a3;
    *a4 = 1;
    if (__p)
    {
      v91 = __p;
      operator delete(__p);
    }
    if (v93)
    {
      v94 = v93;
      operator delete(v93);
    }
  }
}

void _ZNSt3__120__shared_ptr_emplaceIN22IVFVectorIndexTemplateIDF16_Li768EE11VectorStoreI32vi_onefixedsize_memory_allocator18vi_memory_postingsEENS_9allocatorIS6_EEED1Ev(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6E31D48;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void _ZNSt3__120__shared_ptr_emplaceIN22IVFVectorIndexTemplateIDF16_Li768EE11VectorStoreI32vi_onefixedsize_memory_allocator18vi_memory_postingsEENS_9allocatorIS6_EEED0Ev(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6E31D48;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BCCB06A4);
}

void _ZNSt3__120__shared_ptr_emplaceIN22IVFVectorIndexTemplateIDF16_Li768EE11VectorStoreI32vi_onefixedsize_memory_allocator18vi_memory_postingsEENS_9allocatorIS6_EEE16__on_zero_sharedEv(uint64_t a1)
{
  uint64_t v2;

  if (*(char *)(a1 + 87) < 0)
    operator delete(*(void **)(a1 + 64));
  v2 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 40) = 0;
  if (v2)
  {
    malloc_zone_free(*(malloc_zone_t **)v2, *(void **)(v2 + 8));
    JUMPOUT(0x1BCCB06A4);
  }
}

void _ZN22IVFVectorIndexTemplateIDF16_Li768EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsED0Ev(_QWORD *a1)
{
  _ZN22IVFVectorIndexTemplateIDF16_Li768EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsED2Ev(a1);
  JUMPOUT(0x1BCCB06A4);
}

void _ZNK22IVFVectorIndexTemplateIDF16_Li768EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE12getQuantizerEv(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  os_unfair_lock_s *v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;

  v4 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  v6 = *(_QWORD *)(a1 + 64);
  v5 = *(std::__shared_weak_count **)(a1 + 72);
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }
  v9 = *(std::__shared_weak_count **)(a1 + 88);
  if (v9)
  {
    v10 = (unint64_t *)&v9->__shared_owners_;
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }
  os_unfair_lock_unlock(v4);
  *a2 = v6;
  a2[1] = v5;
  if (v5)
  {
    v12 = (unint64_t *)&v5->__shared_owners_;
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  if (!v9)
    goto LABEL_14;
  v14 = (unint64_t *)&v9->__shared_owners_;
  do
    v15 = __ldaxr(v14);
  while (__stlxr(v15 - 1, v14));
  if (!v15)
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
    if (!v5)
      return;
  }
  else
  {
LABEL_14:
    if (!v5)
      return;
  }
  v16 = (unint64_t *)&v5->__shared_owners_;
  do
    v17 = __ldaxr(v16);
  while (__stlxr(v17 - 1, v16));
  if (!v17)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
}

void _ZNK22IVFVectorIndexTemplateIDF16_Li768EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE13getPartitionsEv(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  os_unfair_lock_s *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;

  v4 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  v5 = *(std::__shared_weak_count **)(a1 + 72);
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  v9 = *(_QWORD *)(a1 + 80);
  v8 = *(std::__shared_weak_count **)(a1 + 88);
  if (!v8)
  {
    os_unfair_lock_unlock(v4);
    *a2 = v9;
    a2[1] = 0;
    if (!v5)
      return;
    goto LABEL_15;
  }
  v10 = (unint64_t *)&v8->__shared_owners_;
  do
    v11 = __ldxr(v10);
  while (__stxr(v11 + 1, v10));
  os_unfair_lock_unlock(v4);
  *a2 = v9;
  a2[1] = v8;
  do
    v12 = __ldxr(v10);
  while (__stxr(v12 + 1, v10));
  do
    v13 = __ldaxr(v10);
  while (__stlxr(v13 - 1, v10));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
  if (v5)
  {
LABEL_15:
    v14 = (unint64_t *)&v5->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
}

unint64_t _ZNK22IVFVectorIndexTemplateIDF16_Li768EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE17getVectorAtOffsetEj(uint64_t a1, unsigned int a2)
{
  return vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(*(_QWORD *)(a1 + 32) + 16), a2, 1556);
}

void _ZNK22IVFVectorIndexTemplateIDF16_Li768EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE13newPartitionsENSt3__110shared_ptrI9QuantizerIDF16_Li768EEEE(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  os_unfair_lock_s *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  const char *v14;
  size_t v15;
  void *v16;
  void **v17;
  uint64_t v18;
  uint64_t v19;
  malloc_zone_t *v20;
  uint64_t v21;
  _DWORD *v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  unint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  unint64_t v29;
  void *v30;
  unint64_t Ptr;
  int v32;
  int v33;
  NSObject *v34;
  void **v35;
  int v36;
  int v37;
  char *v38;
  _QWORD *v39;
  int v40;
  unint64_t *v41;
  unint64_t v42;
  unint64_t *v43;
  unint64_t v44;
  char *v45;
  char *v46;
  const char *v47;
  void *v48[2];
  char v49;
  void *__dst[2];
  unint64_t v51;
  void *__p[3];
  __int16 v53;
  _QWORD *v54;
  __int16 v55;
  int v56;
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  v6 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  v7 = *(std::__shared_weak_count **)(a1 + 72);
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }
  v11 = *(_QWORD *)(a1 + 80);
  v10 = *(std::__shared_weak_count **)(a1 + 88);
  if (v10)
  {
    v12 = (unint64_t *)&v10->__shared_owners_;
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  os_unfair_lock_unlock(v6);
  v14 = ".partitions";
  if (v11 && (*(unsigned int (**)(uint64_t))(*(_QWORD *)v11 + 24))(v11))
    v14 = ".tmp.partitions";
  v15 = strlen(v14);
  if (v15 >= 0x7FFFFFFFFFFFFFF8)
LABEL_60:
    abort();
  v16 = (void *)v15;
  if (v15 >= 0x17)
  {
    v18 = (v15 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v15 | 7) != 0x17)
      v18 = v15 | 7;
    v19 = v18 + 1;
    v17 = (void **)operator new(v18 + 1);
    __dst[1] = v16;
    v51 = v19 | 0x8000000000000000;
    __dst[0] = v17;
    goto LABEL_17;
  }
  HIBYTE(v51) = v15;
  v17 = __dst;
  if (v15)
LABEL_17:
    memcpy(v17, v14, (size_t)v16);
  *((_BYTE *)v16 + (_QWORD)v17) = 0;
  v20 = malloc_default_zone();
  if (SHIBYTE(v51) < 0)
    operator delete(__dst[0]);
  v21 = operator new();
  v22 = (_DWORD *)v21;
  v23 = *(std::__shared_weak_count **)(a2 + 8);
  __p[0] = *(void **)a2;
  __p[1] = v23;
  if (v23)
  {
    v24 = (unint64_t *)&v23->__shared_owners_;
    do
      v25 = __ldxr(v24);
    while (__stxr(v25 + 1, v24));
    PartitionStore<vi_onefixedsize_memory_allocator,512>::PartitionStore<vi_onefixedsize_memory_allocator>(v21, v20, 0, __p);
    do
      v26 = __ldaxr(v24);
    while (__stlxr(v26 - 1, v24));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
  else
  {
    PartitionStore<vi_onefixedsize_memory_allocator,512>::PartitionStore<vi_onefixedsize_memory_allocator>(v21, v20, 0, __p);
  }
  *a3 = v22;
  v27 = (_QWORD *)operator new();
  *v27 = &off_1E6E31210;
  v27[1] = 0;
  v27[2] = 0;
  v27[3] = v22;
  a3[1] = v27;
  v28 = *(_QWORD *)(a1 + 32);
  if (*(_DWORD *)(v28 + 24))
  {
    v29 = 0;
    do
    {
      memset(__p, 0, sizeof(__p));
      v30 = *(void **)a2;
      Ptr = vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(v28 + 16), v29, 1556);
      (*(void (**)(void **__return_ptr, void *, unint64_t, uint64_t))(*(_QWORD *)v30 + 72))(__p, v30, Ptr, 1);
      (*(void (**)(_DWORD *, _QWORD, unint64_t, float))(*(_QWORD *)v22 + 56))(v22, *(unsigned int *)__p[0], v29, *((float *)__p[0] + 1));
      if (__p[0])
      {
        __p[1] = __p[0];
        operator delete(__p[0]);
      }
      ++v29;
      v28 = *(_QWORD *)(a1 + 32);
    }
    while (v29 < *(unsigned int *)(v28 + 24));
  }
  (*(void (**)(_DWORD *, _QWORD))(*(_QWORD *)v22 + 112))(v22, 0);
  v32 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 24);
  if (v32)
  {
    v33 = *__error();
    v34 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
    {
      (*(void (**)(void **__return_ptr, _DWORD *))(*(_QWORD *)v22 + 144))(v48, v22);
      if (v49 >= 0)
        v35 = v48;
      else
        v35 = (void **)v48[0];
      v36 = v22[17];
      v37 = v22[18];
      v38 = *(char **)a2;
      v39 = (_QWORD *)(*(_QWORD *)a2 + 8);
      if (v38[31] < 0)
        v39 = (_QWORD *)*v39;
      v40 = (*(uint64_t (**)(char *))(*(_QWORD *)v38 + 16))(v38);
      LODWORD(__p[0]) = 136316162;
      *(void **)((char *)__p + 4) = v35;
      WORD2(__p[1]) = 1024;
      *(_DWORD *)((char *)&__p[1] + 6) = v37;
      WORD1(__p[2]) = 1024;
      HIDWORD(__p[2]) = v36;
      v53 = 2080;
      v54 = v39;
      v55 = 1024;
      v56 = v40;
      _os_log_impl(&dword_1B8270000, v34, OS_LOG_TYPE_DEFAULT, "Create new partitions %s(%u/%u) for new quantizer %s(%u)", (uint8_t *)__p, 0x28u);
      if (v49 < 0)
        operator delete(v48[0]);
    }
    *__error() = v33;
    v32 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 24);
  }
  if (v22[18] != v32)
  {
    v45 = __si_assert_copy_extra_268();
    v46 = v45;
    v47 = "";
    if (v45)
      v47 = v45;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2363, "newPartitions->nVectors() == vectors->count()", v47);
    free(v46);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    goto LABEL_60;
  }
  if (v10)
  {
    v41 = (unint64_t *)&v10->__shared_owners_;
    do
      v42 = __ldaxr(v41);
    while (__stlxr(v42 - 1, v41));
    if (!v42)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  if (v7)
  {
    v43 = (unint64_t *)&v7->__shared_owners_;
    do
      v44 = __ldaxr(v43);
    while (__stlxr(v44 - 1, v43));
    if (!v44)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
}

void _ZN22IVFVectorIndexTemplateIDF16_Li768EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE16replaceQuantizerENSt3__110shared_ptrI9QuantizerIDF16_Li768EEEENS6_I17AnyPartitionStoreEE(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  os_unfair_lock_s *v6;
  os_unfair_lock_s *v7;
  std::__shared_weak_count *v8;
  __int128 *v9;
  char *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  std::__shared_weak_count *v13;
  _DWORD *v14;
  unint64_t *v15;
  unint64_t v16;
  int v17;
  _DWORD *v18;
  NSObject *v19;
  _QWORD *v20;
  int v21;
  _QWORD *v22;
  void **v23;
  int v24;
  void **v25;
  int v26;
  int v27;
  BOOL v28;
  uint64_t v29;
  unint64_t *v30;
  unint64_t v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  unint64_t v37;
  std::__shared_weak_count *v38;
  unint64_t *v39;
  unint64_t v40;
  unint64_t *v41;
  unint64_t v42;
  unint64_t *v43;
  unint64_t v44;
  char *v45;
  char *v46;
  const char *v47;
  char *v48;
  const char *v49;
  _QWORD *v50;
  _QWORD *v51;
  int v52;
  int v53;
  int v54;
  os_unfair_lock_s *v55;
  int v56;
  __int128 v57;
  uint64_t v58;
  std::__shared_weak_count *v59;
  void *__p[2];
  char v61;
  void *v62[2];
  char v63;
  uint8_t buf[4];
  _QWORD *v65;
  __int16 v66;
  int v67;
  __int16 v68;
  _QWORD *v69;
  __int16 v70;
  int v71;
  __int16 v72;
  void **v73;
  __int16 v74;
  int v75;
  __int16 v76;
  int v77;
  __int16 v78;
  void **v79;
  __int16 v80;
  int v81;
  __int16 v82;
  int v83;
  uint64_t v84;

  v84 = *MEMORY[0x1E0C80C00];
  v6 = (os_unfair_lock_s *)(a1 + 136);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 136));
  v7 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  v10 = *(char **)(a1 + 64);
  v8 = *(std::__shared_weak_count **)(a1 + 72);
  v9 = (__int128 *)(a1 + 64);
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }
  v14 = *(_DWORD **)(a1 + 80);
  v13 = *(std::__shared_weak_count **)(a1 + 88);
  if (v13)
  {
    v15 = (unint64_t *)&v13->__shared_owners_;
    do
      v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
  v17 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a2 + 24))(*a2);
  v18 = (_DWORD *)*a3;
  if (v17 != *(_DWORD *)(*a3 + 68))
  {
    v45 = __si_assert_copy_extra_268();
    v46 = v45;
    v47 = "";
    if (v45)
      v47 = v45;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2381, "newQuantizer->count() == newPartitions->nPartitions()", v47);
LABEL_64:
    free(v46);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  if (*(_DWORD *)(*(_QWORD *)(a1 + 32) + 24) != v18[18])
  {
    v48 = __si_assert_copy_extra_268();
    v46 = v48;
    v49 = "";
    if (v48)
      v49 = v48;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2382, "vectors->count() == newPartitions->nVectors()", v49);
    goto LABEL_64;
  }
  if (v10 && v14)
  {
    v56 = *__error();
    v19 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      v20 = v10 + 8;
      if (v10[31] < 0)
        v20 = (_QWORD *)*v20;
      v51 = v20;
      v21 = (*(uint64_t (**)(char *))(*(_QWORD *)v10 + 16))(v10);
      v22 = (_QWORD *)(*a2 + 8);
      v55 = v6;
      v54 = v21;
      if (*(char *)(*a2 + 31) < 0)
        v22 = (_QWORD *)*v22;
      v50 = v22;
      v53 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a2 + 16))(*a2);
      v23 = v62;
      (*(void (**)(void **__return_ptr, _DWORD *))(*(_QWORD *)v14 + 144))(v62, v14);
      if (v63 < 0)
        v23 = (void **)v62[0];
      v24 = v14[18];
      v52 = v14[17];
      (*(void (**)(void **__return_ptr))(*(_QWORD *)*a3 + 144))(__p);
      v25 = __p;
      if (v61 < 0)
        v25 = (void **)__p[0];
      v26 = *(_DWORD *)(*a3 + 68);
      v27 = *(_DWORD *)(*a3 + 72);
      *(_DWORD *)buf = 136317442;
      v65 = v51;
      v66 = 1024;
      v67 = v54;
      v68 = 2080;
      v69 = v50;
      v70 = 1024;
      v71 = v53;
      v72 = 2080;
      v73 = v23;
      v74 = 1024;
      v75 = v24;
      v76 = 1024;
      v77 = v52;
      v78 = 2080;
      v79 = v25;
      v80 = 1024;
      v81 = v27;
      v82 = 1024;
      v83 = v26;
      _os_log_impl(&dword_1B8270000, v19, OS_LOG_TYPE_DEFAULT, "Replace quantizer %s(%u) -> %s(%u), partitions %s(%u/%u) -> %s(%u/%u)", buf, 0x4Eu);
      if (v61 < 0)
        operator delete(__p[0]);
      v6 = v55;
      if (v63 < 0)
        operator delete(v62[0]);
    }
    *__error() = v56;
    v18 = (_DWORD *)*a3;
  }
  if ((*(unsigned int (**)(_DWORD *))(*(_QWORD *)v18 + 24))(v18))
    v28 = v14 == 0;
  else
    v28 = 1;
  if (!v28 && (*(unsigned int (**)(_DWORD *))(*(_QWORD *)v14 + 24))(v14))
    (*(void (**)(_QWORD, _DWORD *))(*(_QWORD *)*a3 + 168))(*a3, v14);
  v29 = a2[1];
  *(_QWORD *)&v57 = *a2;
  *((_QWORD *)&v57 + 1) = v29;
  if (v29)
  {
    v30 = (unint64_t *)(v29 + 8);
    do
      v31 = __ldxr(v30);
    while (__stxr(v31 + 1, v30));
  }
  v32 = (std::__shared_weak_count *)a3[1];
  v58 = *a3;
  v59 = v32;
  if (v32)
  {
    v33 = (unint64_t *)&v32->__shared_owners_;
    do
      v34 = __ldxr(v33);
    while (__stxr(v34 + 1, v33));
  }
  os_unfair_lock_lock(v7);
  std::swap[abi:nn180100]<IVFVectorIndexTemplate<float,768>::QuantizerPartitions>(v9, &v57);
  os_unfair_lock_unlock(v7);
  v35 = v59;
  if (v59)
  {
    v36 = (unint64_t *)&v59->__shared_owners_;
    do
      v37 = __ldaxr(v36);
    while (__stlxr(v37 - 1, v36));
    if (!v37)
    {
      ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
      std::__shared_weak_count::__release_weak(v35);
    }
  }
  v38 = (std::__shared_weak_count *)*((_QWORD *)&v57 + 1);
  if (*((_QWORD *)&v57 + 1))
  {
    v39 = (unint64_t *)(*((_QWORD *)&v57 + 1) + 8);
    do
      v40 = __ldaxr(v39);
    while (__stlxr(v40 - 1, v39));
    if (!v40)
    {
      ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
      std::__shared_weak_count::__release_weak(v38);
    }
  }
  os_unfair_lock_unlock(v6);
  if (v13)
  {
    v41 = (unint64_t *)&v13->__shared_owners_;
    do
      v42 = __ldaxr(v41);
    while (__stlxr(v42 - 1, v41));
    if (!v42)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  if (v8)
  {
    v43 = (unint64_t *)&v8->__shared_owners_;
    do
      v44 = __ldaxr(v43);
    while (__stlxr(v44 - 1, v43));
    if (!v44)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
}

_QWORD *_ZN22IVFVectorIndexTemplateIDF16_Li768EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsED2Ev(_QWORD *a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;

  *a1 = &off_1E6E31D00;
  v2 = (std::__shared_weak_count *)a1[11];
  if (!v2)
    goto LABEL_5;
  p_shared_owners = (unint64_t *)&v2->__shared_owners_;
  do
    v4 = __ldaxr(p_shared_owners);
  while (__stlxr(v4 - 1, p_shared_owners));
  if (!v4)
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    v5 = (std::__shared_weak_count *)a1[9];
    if (!v5)
      goto LABEL_11;
  }
  else
  {
LABEL_5:
    v5 = (std::__shared_weak_count *)a1[9];
    if (!v5)
      goto LABEL_11;
  }
  v6 = (unint64_t *)&v5->__shared_owners_;
  do
    v7 = __ldaxr(v6);
  while (__stlxr(v7 - 1, v6));
  if (!v7)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
LABEL_11:
  v8 = (std::__shared_weak_count *)a1[7];
  if (!v8)
    goto LABEL_15;
  v9 = (unint64_t *)&v8->__shared_owners_;
  do
    v10 = __ldaxr(v9);
  while (__stlxr(v10 - 1, v9));
  if (!v10)
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
    v11 = (std::__shared_weak_count *)a1[5];
    if (!v11)
      return a1;
  }
  else
  {
LABEL_15:
    v11 = (std::__shared_weak_count *)a1[5];
    if (!v11)
      return a1;
  }
  v12 = (unint64_t *)&v11->__shared_owners_;
  do
    v13 = __ldaxr(v12);
  while (__stlxr(v13 - 1, v12));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  return a1;
}

uint64_t _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li768EED1Ev(uint64_t a1)
{
  *(_QWORD *)a1 = off_1E6E31BA8;
  _ZN22IVFVectorIndexTemplateIDF16_Li768EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsED2Ev((_QWORD *)(a1 + 48));
  *(_QWORD *)a1 = off_1E6E30C80;
  if (*(char *)(a1 + 47) < 0)
    operator delete(*(void **)(a1 + 24));
  return a1;
}

void _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li768EED0Ev(uint64_t a1)
{
  *(_QWORD *)a1 = off_1E6E31BA8;
  _ZN22IVFVectorIndexTemplateIDF16_Li768EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsED2Ev((_QWORD *)(a1 + 48));
  *(_QWORD *)a1 = off_1E6E30C80;
  if (*(char *)(a1 + 47) < 0)
    operator delete(*(void **)(a1 + 24));
  JUMPOUT(0x1BCCB06A4);
}

uint64_t _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li768EE8nVectorsEv(uint64_t a1)
{
  return IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nVectors(a1 + 48);
}

uint64_t _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li768EE11nPartitionsEv(uint64_t a1)
{
  return IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nPartitions(a1 + 48);
}

uint64_t _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li768EE8allExistEPKvj(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  float v9;
  uint64_t v10;
  int v11;
  NSObject *v12;
  char *v14;
  char *v15;
  const char *v16;
  uint8_t buf[4];
  double v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if ((_DWORD)a3)
  {
    v5 = a1 + 48;
    v6 = a3;
    if (a3 <= 0x3E8)
    {
      while (_ZN22IVFVectorIndexTemplateIDF16_Li768EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE6existsERK10CIVector_sIDF16_Li768EE(v5, a2))
      {
        a2 += 1536;
        if (!--v6)
          return a3;
      }
    }
    else
    {
      v7 = 0;
      v8 = a3 / 0xA;
      v9 = 1.0 / (float)a3;
      while (1)
      {
        v10 = v7 + 1;
        if (!(((int)v7 + 1) % v8))
        {
          v11 = *__error();
          v12 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 134217984;
            v18 = (float)((float)((float)v7 * 100.0) * v9);
            _os_log_impl(&dword_1B8270000, v12, OS_LOG_TYPE_DEFAULT, "allExist: %.0f%%", buf, 0xCu);
          }
          *__error() = v11;
        }
        if (!_ZN22IVFVectorIndexTemplateIDF16_Li768EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE6existsERK10CIVector_sIDF16_Li768EE(v5, a2))break;
        a2 += 1536;
        ++v7;
        if (a3 == v10)
          return a3;
      }
    }
    v14 = __si_assert_copy_extra_268();
    v15 = v14;
    v16 = "";
    if (v14)
      v16 = v14;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3151, "false", v16);
    free(v15);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  return a3;
}

uint64_t _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li768EE12validAddressEPKv()
{
  return 1;
}

uint64_t _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li768EE6shadowEbPVi(uint64_t a1, uint64_t a2, uint64_t a3)
{
  os_unfair_lock_s *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t *v15;
  unint64_t v16;

  v6 = (os_unfair_lock_s *)(a1 + 144);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 144));
  v7 = *(std::__shared_weak_count **)(a1 + 120);
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }
  v11 = *(_QWORD *)(a1 + 128);
  v10 = *(std::__shared_weak_count **)(a1 + 136);
  if (v10)
  {
    v12 = (unint64_t *)&v10->__shared_owners_;
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
    os_unfair_lock_unlock(v6);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v11 + 160))(v11, a2, a3);
    do
      v14 = __ldaxr(v12);
    while (__stlxr(v14 - 1, v12));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  else
  {
    os_unfair_lock_unlock(v6);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v11 + 160))(v11, a2, a3);
  }
  if (v7)
  {
    v15 = (unint64_t *)&v7->__shared_owners_;
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  return 0;
}

_DWORD *_ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li768EE17bulkInsertForTestEPKvPKjjS8_(_DWORD *result, char *a2, int *a3, unsigned int a4, unsigned int *a5)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  float v12;
  int v13;
  uint64_t v14;
  int v15;
  NSObject *v16;
  unsigned int v17;
  int v18;
  int v19;
  unsigned int v20;
  unsigned int v21;
  int v22;
  int v23;
  uint8_t buf[4];
  double v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if (a4)
  {
    v8 = (uint64_t)(result + 12);
    v9 = a4;
    if (a4 <= 0x3E8)
    {
      do
      {
        v21 = *a5++;
        v20 = v21;
        v23 = *a3++;
        v22 = v23;
        result = _ZN22IVFVectorIndexTemplateIDF16_Li768EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE15lookupForInsertEjRK10CIVector_sIDF16_Li768EEjfb(v8, v20, a2, 0xFFFFFFFF, 3.4028e38);
        if (result[386])
        {
          v19 = result[385] + 1;
        }
        else
        {
          result[386] = v22;
          v19 = 1;
        }
        result[385] = v19;
        a2 += 1536;
        --v9;
      }
      while (v9);
    }
    else
    {
      v10 = 0;
      v11 = a4 / 0xA;
      v12 = 1.0 / (float)a4;
      do
      {
        v14 = v10 + 1;
        if (!(((int)v10 + 1) % v11))
        {
          v15 = *__error();
          v16 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 134217984;
            v25 = (float)((float)((float)v10 * 100.0) * v12);
            _os_log_impl(&dword_1B8270000, v16, OS_LOG_TYPE_DEFAULT, "bulkInsertForTest: %.0f%%", buf, 0xCu);
          }
          *__error() = v15;
        }
        v17 = a5[v10];
        v18 = a3[v10];
        result = _ZN22IVFVectorIndexTemplateIDF16_Li768EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE15lookupForInsertEjRK10CIVector_sIDF16_Li768EEjfb(v8, v17, a2, 0xFFFFFFFF, 3.4028e38);
        if (result[386])
        {
          v13 = result[385] + 1;
        }
        else
        {
          result[386] = v18;
          v13 = 1;
        }
        result[385] = v13;
        a2 += 1536;
        v10 = v14;
      }
      while (v9 != v14);
    }
  }
  return result;
}

char *_ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li768EE12insertVectorEjjPKv14vec_dimensions15vec_data_format14docInvertStateyP15PostingBaseInfo(_DWORD *a1, int a2, unsigned int a3, const void *a4, int a5, int a6, int a7, uint64_t a8, char *a9)
{
  unsigned int *v11;
  char *v13;
  char *v14;
  const char *v15;

  if (a1[2] != a2
    || a6 > 2
    || a1[3] != vector_dimension_vec_sizes_10743[a5]
    || vector_size_elem_sizes_10742[a6] != a1[4])
  {
    v13 = __si_assert_copy_extra_268();
    v14 = v13;
    v15 = "";
    if (v13)
      v15 = v13;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3070, "compatible", v15);
    free(v14);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v11 = _ZN22IVFVectorIndexTemplateIDF16_Li768EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE15lookupForInsertEjRK10CIVector_sIDF16_Li768EEjfb((uint64_t)(a1 + 12), a3, a4, 0xFFFFFFFF, 3.4028e38)+ 384;
  return vi_memory_postings::push_posting(a9, a7, v11, a8);
}

uint64_t _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li768EE14insertForMergeEjtjPKv14vec_dimensions15vec_data_formatyjf(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, int a6, int a7)
{
  char *v8;
  char *v9;
  const char *v10;

  if (*(_DWORD *)(a1 + 8) != a2
    || *(unsigned __int16 *)(a1 + 20) != a3
    || a7 > 2
    || *(_DWORD *)(a1 + 12) != vector_dimension_vec_sizes_10743[a6]
    || vector_size_elem_sizes_10742[a7] != *(_DWORD *)(a1 + 16))
  {
    v8 = __si_assert_copy_extra_268();
    v9 = v8;
    v10 = "";
    if (v8)
      v10 = v8;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3070, "compatible", v10);
    free(v9);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  return 1;
}

_DWORD *_ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li768EE13insertForTestEjjPKv14vec_dimensions15vec_data_formatj(_DWORD *a1, int a2, unsigned int a3, const void *a4, int a5, int a6, int a7)
{
  _DWORD *result;
  int v9;
  char *v10;
  char *v11;
  const char *v12;
  uint64_t v13;

  if (a1[2] != a2
    || a6 > 2
    || a1[3] != vector_dimension_vec_sizes_10743[a5]
    || vector_size_elem_sizes_10742[a6] != a1[4])
  {
    v10 = __si_assert_copy_extra_268();
    v11 = v10;
    v12 = "";
    if (v10)
      v12 = v10;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3070, "compatible", v12);
    free(v11);
    if (__valid_fs(-1))
      v13 = 2989;
    else
      v13 = 3072;
    *(_DWORD *)v13 = -559038737;
    abort();
  }
  result = _ZN22IVFVectorIndexTemplateIDF16_Li768EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE15lookupForInsertEjRK10CIVector_sIDF16_Li768EEjfb((uint64_t)(a1 + 12), a3, a4, 0xFFFFFFFF, 3.4028e38);
  if (result[386])
  {
    v9 = result[385] + 1;
  }
  else
  {
    result[386] = a7;
    v9 = 1;
  }
  result[385] = v9;
  return result;
}

void _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li768EE5trainERKNSt3__16vectorIP22AnyVectorIndexInstanceNS5_9allocatorIS8_EEEE(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v3;
  unint64_t v4;
  uint64_t v6;
  char *v7;
  char *v8;
  char *v9;
  unint64_t v10;
  char *v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  _BYTE *v18;
  char *v19;
  unint64_t v20;
  char *v21;
  uint64_t v22;
  _OWORD *v23;
  char *v24;
  uint64_t v25;
  __int128 v26;
  uint64_t v27;
  char *v28;
  char *v29;
  const char *v30;
  char *v31;
  char *v32;
  const char *v33;
  char *v34;
  const char *v35;
  uint64_t v36;
  uint64_t v37;

  v3 = *(_QWORD **)a2;
  v2 = *(_QWORD *)(a2 + 8);
  v4 = v2 - *(_QWORD *)a2;
  if (v2 == *(_QWORD *)a2)
  {
    v31 = __si_assert_copy_extra_268();
    v32 = v31;
    v33 = "";
    if (v31)
      v33 = v31;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3170, "vi.size() > 0", v33);
    goto LABEL_52;
  }
  if (*v3 != a1)
  {
    v34 = __si_assert_copy_extra_268();
    v32 = v34;
    v35 = "";
    if (v34)
      v35 = v34;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3171, "this == vi[0]", v35);
LABEL_52:
    free(v32);
    if (__valid_fs(-1))
      v36 = 2989;
    else
      v36 = 3072;
    *(_DWORD *)v36 = -559038737;
LABEL_56:
    abort();
  }
  v6 = a2;
  v7 = (char *)operator new(8uLL);
  v8 = v7;
  *(_QWORD *)v7 = a1 + 48;
  if (v4 < 9)
    goto LABEL_39;
  v9 = v7 + 8;
  v10 = 1;
  v11 = v7 + 8;
  v37 = v6;
  do
  {
    v13 = v3[v10];
    if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(v13 + 8)
      || *(unsigned __int16 *)(a1 + 20) != *(unsigned __int16 *)(v13 + 20)
      || *(_DWORD *)(a1 + 12) != *(_DWORD *)(v13 + 12)
      || *(_DWORD *)(a1 + 16) != *(_DWORD *)(v13 + 16))
    {
      v28 = __si_assert_copy_extra_268();
      v29 = v28;
      v30 = "";
      if (v28)
        v30 = v28;
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3075, "compatible", v30);
      free(v29);
      if (__valid_fs(-1))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
    v14 = v13 + 48;
    if (v9 < v11)
    {
      *(_QWORD *)v9 = v14;
      v12 = v9 + 8;
      goto LABEL_6;
    }
    v15 = (v9 - v8) >> 3;
    v16 = v15 + 1;
    if ((unint64_t)(v15 + 1) >> 61)
      goto LABEL_56;
    if ((v11 - v8) >> 2 > v16)
      v16 = (v11 - v8) >> 2;
    if ((unint64_t)(v11 - v8) >= 0x7FFFFFFFFFFFFFF8)
      v17 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v17 = v16;
    if (v17)
    {
      if (v17 >> 61)
        std::__throw_bad_array_new_length[abi:nn180100]();
      v18 = operator new(8 * v17);
    }
    else
    {
      v18 = 0;
    }
    v19 = &v18[8 * v15];
    v11 = &v18[8 * v17];
    *(_QWORD *)v19 = v14;
    v12 = v19 + 8;
    if (v9 == v8)
    {
LABEL_36:
      operator delete(v8);
      goto LABEL_37;
    }
    v20 = v9 - 8 - v8;
    if (v20 < 0x168)
    {
      v21 = v9;
      goto LABEL_34;
    }
    if (&v18[v9 - v8 - 8 - (v20 & 0xFFFFFFFFFFFFFFF8)] > &v18[v9 - v8 - 8])
    {
      v21 = v9;
      goto LABEL_34;
    }
    if (&v9[-(v20 & 0xFFFFFFFFFFFFFFF8) - 8] > v9 - 8)
    {
      v21 = v9;
      do
      {
LABEL_34:
        v27 = *((_QWORD *)v21 - 1);
        v21 -= 8;
        *((_QWORD *)v19 - 1) = v27;
        v19 -= 8;
      }
      while (v21 != v8);
      goto LABEL_35;
    }
    if ((unint64_t)(v8 - v18) < 0x20)
    {
      v21 = v9;
      goto LABEL_34;
    }
    v22 = (v20 >> 3) + 1;
    v21 = &v9[-8 * (v22 & 0x3FFFFFFFFFFFFFFCLL)];
    v23 = &v18[8 * v15 - 16];
    v24 = v9 - 16;
    v25 = v22 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v26 = *(_OWORD *)v24;
      *(v23 - 1) = *((_OWORD *)v24 - 1);
      *v23 = v26;
      v23 -= 2;
      v24 -= 32;
      v25 -= 4;
    }
    while (v25);
    v19 -= 8 * (v22 & 0x3FFFFFFFFFFFFFFCLL);
    if (v22 != (v22 & 0x3FFFFFFFFFFFFFFCLL))
      goto LABEL_34;
LABEL_35:
    if (v8)
      goto LABEL_36;
LABEL_37:
    v8 = v19;
    v6 = v37;
LABEL_6:
    ++v10;
    v3 = *(_QWORD **)v6;
    v9 = v12;
  }
  while (v10 < (uint64_t)(*(_QWORD *)(v6 + 8) - *(_QWORD *)v6) >> 3);
  if (v8)
LABEL_39:
    operator delete(v8);
}

uint64_t _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li768EE14mergeUpdateSetEPK22AnyVectorIndexInstanceP15PostingBaseInfoP17TermIdContainer_s(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v7;
  NSObject *v8;
  os_log_type_t v9;
  int v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  unsigned int v15;
  float v16;
  unsigned int v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  _QWORD *v22;
  uint64_t result;
  std::__shared_weak_count *v24;
  unint64_t *p_shared_owners;
  unint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  char *v30;
  char *v31;
  const char *v32;
  char *v33;
  const char *v34;
  _DWORD v35[4];
  void *__src;
  uint64_t v37;
  uint8_t buf[1544];
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)
    || *(unsigned __int16 *)(a1 + 20) != *(unsigned __int16 *)(a2 + 20)
    || *(_DWORD *)(a1 + 12) != *(_DWORD *)(a2 + 12)
    || *(_DWORD *)(a1 + 16) != *(_DWORD *)(a2 + 16))
  {
    v33 = __si_assert_copy_extra_268();
    v31 = v33;
    v34 = "";
    if (v33)
      v34 = v33;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3075, "compatible", v34);
LABEL_36:
    free(v31);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v7 = *__error();
  v8 = _SILogForLogForCategory(16);
  v9 = 2 * (dword_1EF19FCCC < 4);
  if (os_log_type_enabled(v8, v9))
  {
    v10 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
    v11 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
    v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
    v13 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 24))(a2);
    *(_DWORD *)buf = 67109888;
    *(_DWORD *)&buf[4] = v10;
    *(_WORD *)&buf[8] = 1024;
    *(_DWORD *)&buf[10] = v11;
    *(_WORD *)&buf[14] = 1024;
    *(_DWORD *)&buf[16] = v12;
    *(_WORD *)&buf[20] = 1024;
    *(_DWORD *)&buf[22] = v13;
    _os_log_impl(&dword_1B8270000, v8, v9, "mergeUpdateSet(termIds) %u vectors in %u partitions and %u vectors in %u partitions", buf, 0x1Au);
  }
  *__error() = v7;
  v14 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::enumerator(a2 + 48);
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::beginMerge(a1 + 48);
  while (1)
  {
    _ZN22IVFVectorIndexTemplateIDF16_Li768EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE12enumerator_s4nextEv((uint64_t)v35, v14);
    if (!__src)
      break;
    v15 = v35[0];
    v16 = *(float *)&v35[1];
    v17 = v35[2];
    v18 = v37;
    memcpy(buf, __src, 0x600uLL);
    v20 = *(_QWORD *)(a4 + 8);
    v19 = *(_QWORD *)(a4 + 16);
    v21 = v20 + 1;
    if (v20 + 1 < v19)
    {
      v22 = *(_QWORD **)a4;
      goto LABEL_16;
    }
    if (v19)
    {
      if (v21 >= v19)
        goto LABEL_13;
    }
    else
    {
      *(_QWORD *)(a4 + 16) = 1024;
      v19 = 1024;
      if (v21 >= 0x400)
      {
        do
LABEL_13:
          v19 *= 2;
        while (v21 >= v19);
        *(_QWORD *)(a4 + 16) = v19;
      }
    }
    v22 = malloc_type_realloc(*(void **)a4, 24 * v19, 0x10200409F4E64B8uLL);
    *(_QWORD *)a4 = v22;
    v20 = *(_QWORD *)(a4 + 8);
    v21 = v20 + 1;
LABEL_16:
    v22[3 * v20 + 1] = v18;
    *(_QWORD *)(a4 + 8) = v21;
    if (*(_DWORD *)(a1 + 188) == -1)
    {
      v30 = __si_assert_copy_extra_268();
      v31 = v30;
      v32 = "";
      if (v30)
        v32 = v30;
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2689, "mergeBeginVectorOffset < VECTOR_NOT_FOUND", v32);
      goto LABEL_36;
    }
    _ZN22IVFVectorIndexTemplateIDF16_Li768EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE15lookupForInsertEjRK10CIVector_sIDF16_Li768EEjfb(a1 + 48, v17, buf, v15, v16);
  }
  result = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::endMerge(a1 + 48);
  if (v14)
  {
    std::deque<std::shared_ptr<AnyPartitionStore::Enumerator>>::~deque[abi:nn180100](v14 + 32);
    v24 = *(std::__shared_weak_count **)(v14 + 24);
    if (v24)
    {
      p_shared_owners = (unint64_t *)&v24->__shared_owners_;
      do
        v26 = __ldaxr(p_shared_owners);
      while (__stlxr(v26 - 1, p_shared_owners));
      if (!v26)
      {
        ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
        std::__shared_weak_count::__release_weak(v24);
      }
    }
    v27 = *(std::__shared_weak_count **)(v14 + 8);
    if (v27)
    {
      v28 = (unint64_t *)&v27->__shared_owners_;
      do
        v29 = __ldaxr(v28);
      while (__stlxr(v29 - 1, v28));
      if (!v29)
      {
        ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
        std::__shared_weak_count::__release_weak(v27);
      }
    }
    return MEMORY[0x1BCCB06A4](v14, 0x10A0C40B50FE552);
  }
  return result;
}

_DWORD *_ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li768EE14mergeUpdateSetEPK22AnyVectorIndexInstanceP15PostingBaseInfojy(_DWORD *result, uint64_t a2, char *a3, unsigned int a4, uint64_t a5)
{
  _DWORD *v6;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  _DWORD *inserted;
  unsigned int v16;
  const void *v17;
  unint64_t v18;
  char *v19;
  char *v20;
  const char *v21;
  int v22;
  NSObject *v23;
  int v24;
  int v25;
  int v26;
  int v27;
  _DWORD __dst[384];
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  if (result[2] != *(_DWORD *)(a2 + 8)
    || (v6 = result, *((unsigned __int16 *)result + 10) != *(unsigned __int16 *)(a2 + 20))
    || result[3] != *(_DWORD *)(a2 + 12)
    || result[4] != *(_DWORD *)(a2 + 16))
  {
    v19 = __si_assert_copy_extra_268();
    v20 = v19;
    v21 = "";
    if (v19)
      v21 = v19;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3075, "compatible", v21);
    free(v20);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  if (dword_1EF19FCCC >= 5)
  {
    v22 = *__error();
    v23 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      v24 = (*(uint64_t (**)(_DWORD *))(*(_QWORD *)v6 + 16))(v6);
      v25 = (*(uint64_t (**)(_DWORD *))(*(_QWORD *)v6 + 24))(v6);
      v26 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
      v27 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 24))(a2);
      __dst[0] = 67109888;
      __dst[1] = v24;
      LOWORD(__dst[2]) = 1024;
      *(_DWORD *)((char *)&__dst[2] + 2) = v25;
      HIWORD(__dst[3]) = 1024;
      __dst[4] = v26;
      LOWORD(__dst[5]) = 1024;
      *(_DWORD *)((char *)&__dst[5] + 2) = v27;
      _os_log_impl(&dword_1B8270000, v23, OS_LOG_TYPE_DEFAULT, "mergeUpdateSet(DocID) %u vectors in %u partitions and %u vectors in %u partitions", (uint8_t *)__dst, 0x1Au);
    }
    result = __error();
    *result = v22;
  }
  v9 = 0;
  v10 = *(_QWORD *)(a2 + 80);
  v11 = (uint64_t)(v6 + 12);
  v12 = a4;
  while (v9 != *(_DWORD *)(v10 + 24))
  {
    v16 = *(_DWORD *)(_ZNK22IVFVectorIndexTemplateIDF16_Li768EE11VectorStoreI32vi_onefixedsize_memory_allocator18vi_memory_postingsE8IteratorptEv(v10, v9)+ 1552);
    v17 = (const void *)_ZNK22IVFVectorIndexTemplateIDF16_Li768EE11VectorStoreI32vi_onefixedsize_memory_allocator18vi_memory_postingsE8IteratorptEv(v10, v9);
    memcpy(__dst, v17, sizeof(__dst));
    v18 = _ZNK22IVFVectorIndexTemplateIDF16_Li768EE11VectorStoreI32vi_onefixedsize_memory_allocator18vi_memory_postingsE8IteratorptEv(v10, v9);
    if ((*(_BYTE *)(v18 + 1536) & 1) != 0)
    {
      if (*(_DWORD *)(v18 + 1540))
        v13 = 1;
      else
        v13 = 2;
      v14 = a5;
    }
    else
    {
      v13 = 0;
      v14 = v12;
    }
    inserted = _ZN22IVFVectorIndexTemplateIDF16_Li768EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE15lookupForInsertEjRK10CIVector_sIDF16_Li768EEjfb(v11, v16, __dst, 0xFFFFFFFF, 3.4028e38);
    result = vi_memory_postings::push_posting(a3, v13, inserted + 384, v14);
    ++v9;
  }
  return result;
}

uint64_t _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li768EE21mergeUpdateSetForTestEPK22AnyVectorIndexInstance(uint64_t a1, uint64_t a2)
{
  int v4;
  NSObject *v5;
  os_log_type_t v6;
  float v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  _DWORD *inserted;
  int v18;
  uint64_t result;
  std::__shared_weak_count *v20;
  unint64_t *p_shared_owners;
  unint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  char *v26;
  char *v27;
  const char *v28;
  char *v29;
  const char *v30;
  uint8_t buf[4];
  float v32;
  _BYTE v33[6];
  __int16 v34;
  __int128 v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)
    || *(unsigned __int16 *)(a1 + 20) != *(unsigned __int16 *)(a2 + 20)
    || *(_DWORD *)(a1 + 12) != *(_DWORD *)(a2 + 12)
    || *(_DWORD *)(a1 + 16) != *(_DWORD *)(a2 + 16))
  {
    v26 = __si_assert_copy_extra_268();
    v27 = v26;
    v28 = "";
    if (v26)
      v28 = v26;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3075, "compatible", v28);
LABEL_34:
    free(v27);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v4 = *__error();
  v5 = _SILogForLogForCategory(16);
  v6 = 2 * (dword_1EF19FCCC < 4);
  if (os_log_type_enabled(v5, v6))
  {
    LODWORD(v7) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
    v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
    v9 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
    v10 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 24))(a2);
    *(_DWORD *)buf = 67109888;
    v32 = v7;
    *(_WORD *)v33 = 1024;
    *(_DWORD *)&v33[2] = v8;
    v34 = 1024;
    LODWORD(v35) = v9;
    WORD2(v35) = 1024;
    *(_DWORD *)((char *)&v35 + 6) = v10;
    _os_log_impl(&dword_1B8270000, v5, v6, "mergeUpdateSetForTest %u vectors in %u partitions and %u vectors in %u partitions", buf, 0x1Au);
  }
  *__error() = v4;
  v11 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::enumerator(a2 + 48);
  v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  v13 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::beginMerge(a1 + 48);
  v14 = 0;
  while (1)
  {
    _ZN22IVFVectorIndexTemplateIDF16_Li768EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE12enumerator_s4nextEv((uint64_t)buf, v11);
    if (!(_QWORD)v35)
      break;
    v16 = *(_DWORD *)(*((_QWORD *)&v35 + 1) + 8);
    inserted = _ZN22IVFVectorIndexTemplateIDF16_Li768EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE15lookupForInsertEjRK10CIVector_sIDF16_Li768EEjfb(a1 + 48, *(unsigned int *)v33, (const void *)v35, *(unsigned int *)buf, v32);
    v18 = inserted[386];
    if (v18)
    {
      v15 = inserted[385] + 1;
    }
    else
    {
      inserted[386] = v16;
      v15 = 1;
    }
    inserted[385] = v15;
    if (v18)
      ++v14;
  }
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::endMerge(a1 + 48);
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  if ((_DWORD)result + v14 != v13 + v12)
  {
    v29 = __si_assert_copy_extra_268();
    v27 = v29;
    v30 = "";
    if (v29)
      v30 = v29;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3267, "nVectors() + dup == old + added", v30);
    goto LABEL_34;
  }
  if (v11)
  {
    std::deque<std::shared_ptr<AnyPartitionStore::Enumerator>>::~deque[abi:nn180100](v11 + 32);
    v20 = *(std::__shared_weak_count **)(v11 + 24);
    if (v20)
    {
      p_shared_owners = (unint64_t *)&v20->__shared_owners_;
      do
        v22 = __ldaxr(p_shared_owners);
      while (__stlxr(v22 - 1, p_shared_owners));
      if (!v22)
      {
        ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
        std::__shared_weak_count::__release_weak(v20);
      }
    }
    v23 = *(std::__shared_weak_count **)(v11 + 8);
    if (v23)
    {
      v24 = (unint64_t *)&v23->__shared_owners_;
      do
        v25 = __ldaxr(v24);
      while (__stlxr(v25 - 1, v24));
      if (!v25)
      {
        ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
        std::__shared_weak_count::__release_weak(v23);
      }
    }
    return MEMORY[0x1BCCB06A4](v11, 0x10A0C40B50FE552);
  }
  return result;
}

uint64_t _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li768EE17mergeIndexForTestEP22AnyVectorIndexInstance(uint64_t a1, uint64_t a2)
{
  int v4;
  NSObject *v5;
  os_log_type_t v6;
  float v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  _DWORD *inserted;
  int v18;
  uint64_t result;
  std::__shared_weak_count *v20;
  unint64_t *p_shared_owners;
  unint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  char *v26;
  char *v27;
  const char *v28;
  char *v29;
  const char *v30;
  uint8_t buf[4];
  float v32;
  _BYTE v33[6];
  __int16 v34;
  __int128 v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)
    || *(unsigned __int16 *)(a1 + 20) != *(unsigned __int16 *)(a2 + 20)
    || *(_DWORD *)(a1 + 12) != *(_DWORD *)(a2 + 12)
    || *(_DWORD *)(a1 + 16) != *(_DWORD *)(a2 + 16))
  {
    v26 = __si_assert_copy_extra_268();
    v27 = v26;
    v28 = "";
    if (v26)
      v28 = v26;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3075, "compatible", v28);
LABEL_34:
    free(v27);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v4 = *__error();
  v5 = _SILogForLogForCategory(16);
  v6 = 2 * (dword_1EF19FCCC < 4);
  if (os_log_type_enabled(v5, v6))
  {
    LODWORD(v7) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
    v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
    v9 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
    v10 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 24))(a2);
    *(_DWORD *)buf = 67109888;
    v32 = v7;
    *(_WORD *)v33 = 1024;
    *(_DWORD *)&v33[2] = v8;
    v34 = 1024;
    LODWORD(v35) = v9;
    WORD2(v35) = 1024;
    *(_DWORD *)((char *)&v35 + 6) = v10;
    _os_log_impl(&dword_1B8270000, v5, v6, "mergeIndexForTest %u vectors in %u partitions and %u vectors in %u partitions", buf, 0x1Au);
  }
  *__error() = v4;
  v11 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::enumerator(a2 + 48);
  v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  v13 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::beginMerge(a1 + 48);
  v14 = 0;
  while (1)
  {
    _ZN22IVFVectorIndexTemplateIDF16_Li768EE20IVFVectorIndexRoot_sI30vi_onefixedsize_disk_allocator16vi_disk_postingsE12enumerator_s4nextEv((uint64_t)buf, v11);
    if (!(_QWORD)v35)
      break;
    v16 = **((_QWORD **)&v35 + 1);
    inserted = _ZN22IVFVectorIndexTemplateIDF16_Li768EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE15lookupForInsertEjRK10CIVector_sIDF16_Li768EEjfb(a1 + 48, *(unsigned int *)v33, (const void *)v35, *(unsigned int *)buf, v32);
    v18 = inserted[386];
    if (v18)
    {
      v15 = inserted[385] + 1;
    }
    else
    {
      inserted[386] = v16;
      v15 = 1;
    }
    inserted[385] = v15;
    if (v18)
      ++v14;
  }
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::endMerge(a1 + 48);
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  if ((_DWORD)result + v14 != v13 + v12)
  {
    v29 = __si_assert_copy_extra_268();
    v27 = v29;
    v30 = "";
    if (v29)
      v30 = v29;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3281, "nVectors() + dup == old + added", v30);
    goto LABEL_34;
  }
  if (v11)
  {
    std::deque<std::shared_ptr<AnyPartitionStore::Enumerator>>::~deque[abi:nn180100](v11 + 32);
    v20 = *(std::__shared_weak_count **)(v11 + 24);
    if (v20)
    {
      p_shared_owners = (unint64_t *)&v20->__shared_owners_;
      do
        v22 = __ldaxr(p_shared_owners);
      while (__stlxr(v22 - 1, p_shared_owners));
      if (!v22)
      {
        ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
        std::__shared_weak_count::__release_weak(v20);
      }
    }
    v23 = *(std::__shared_weak_count **)(v11 + 8);
    if (v23)
    {
      v24 = (unint64_t *)&v23->__shared_owners_;
      do
        v25 = __ldaxr(v24);
      while (__stlxr(v25 - 1, v24));
      if (!v25)
      {
        ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
        std::__shared_weak_count::__release_weak(v23);
      }
    }
    return MEMORY[0x1BCCB06A4](v11, 0x10A0C40B50FE552);
  }
  return result;
}

void _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li768EE4dumpEbbPViPvU13block_pointerFbjPKvybjfE(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  os_unfair_lock_s *v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  std::__shared_weak_count *v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  uint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  unint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  unint64_t *v33;
  unint64_t v34;
  unint64_t *v35;
  unint64_t v36;
  _QWORD v37[2];
  void (*v38)();
  void *v39;
  uint64_t v40;
  uint64_t v41;
  _QWORD v42[2];
  uint64_t v43;
  std::__shared_weak_count *v44;
  __int128 v45;
  __int128 v46;
  _OWORD v47[3];
  __int128 v48;
  __int128 v49;
  char v50;
  __int128 v51;
  __int128 v52;

  v9 = (os_unfair_lock_s *)(a1 + 144);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 144));
  v10 = *(std::__shared_weak_count **)(a1 + 120);
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }
  v14 = *(_QWORD *)(a1 + 128);
  v13 = *(std::__shared_weak_count **)(a1 + 136);
  if (v13)
  {
    v15 = (unint64_t *)&v13->__shared_owners_;
    do
      v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
  }
  os_unfair_lock_unlock(v9);
  v46 = 0u;
  memset(v47, 0, sizeof(v47));
  v45 = 0u;
  v43 = v14;
  v44 = v13;
  if (v13)
  {
    v17 = (unint64_t *)&v13->__shared_owners_;
    do
      v18 = __ldxr(v17);
    while (__stxr(v18 + 1, v17));
  }
  v19 = *(_QWORD *)(a1 + 80);
  v20 = *(std::__shared_weak_count **)(a1 + 88);
  v42[0] = v19;
  v42[1] = v20;
  if (v20)
  {
    v21 = (unint64_t *)&v20->__shared_owners_;
    do
      v22 = __ldxr(v21);
    while (__stxr(v22 + 1, v21));
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::enumerator_s::enumerator_s((uint64_t)&v45, &v43, v42);
    do
      v23 = __ldaxr(v21);
    while (__stlxr(v23 - 1, v21));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
  else
  {
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::enumerator_s::enumerator_s((uint64_t)&v45, &v43, v42);
  }
  v24 = v44;
  if (v44)
  {
    v25 = (unint64_t *)&v44->__shared_owners_;
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }
  v37[0] = MEMORY[0x1E0C809B0];
  v37[1] = 0x40000000;
  v38 = ___ZNK22IVFVectorIndexTemplateIDF16_Li768EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE4dumpEbbPViPvU13block_pointerFbjPKvybjfE_block_invoke;
  v39 = &unk_1E6E31F58;
  v40 = a6;
  v41 = a4;
  v51 = 0u;
  v52 = 0u;
  v50 = 0;
  do
  {
    _ZN22IVFVectorIndexTemplateIDF16_Li768EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE12enumerator_s4nextEv((uint64_t)&v48, (uint64_t)&v45);
    v51 = v48;
    v52 = v49;
    if (!(_QWORD)v49)
      break;
    ((void (*)(_QWORD *, __int128 *, char *))v38)(v37, &v51, &v50);
  }
  while (!v50);
  std::deque<std::shared_ptr<AnyPartitionStore::Enumerator>>::~deque[abi:nn180100]((uint64_t)v47);
  v27 = (std::__shared_weak_count *)*((_QWORD *)&v46 + 1);
  if (!*((_QWORD *)&v46 + 1))
    goto LABEL_30;
  v28 = (unint64_t *)(*((_QWORD *)&v46 + 1) + 8);
  do
    v29 = __ldaxr(v28);
  while (__stlxr(v29 - 1, v28));
  if (!v29)
  {
    ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
    std::__shared_weak_count::__release_weak(v27);
    v30 = (std::__shared_weak_count *)*((_QWORD *)&v45 + 1);
    if (!*((_QWORD *)&v45 + 1))
      goto LABEL_36;
  }
  else
  {
LABEL_30:
    v30 = (std::__shared_weak_count *)*((_QWORD *)&v45 + 1);
    if (!*((_QWORD *)&v45 + 1))
      goto LABEL_36;
  }
  v31 = (unint64_t *)&v30->__shared_owners_;
  do
    v32 = __ldaxr(v31);
  while (__stlxr(v32 - 1, v31));
  if (!v32)
  {
    ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
    std::__shared_weak_count::__release_weak(v30);
  }
  if (!v13)
    goto LABEL_40;
LABEL_36:
  v33 = (unint64_t *)&v13->__shared_owners_;
  do
    v34 = __ldaxr(v33);
  while (__stlxr(v34 - 1, v33));
  if (!v34)
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
    if (!v10)
      return;
  }
  else
  {
LABEL_40:
    if (!v10)
      return;
  }
  v35 = (unint64_t *)&v10->__shared_owners_;
  do
    v36 = __ldaxr(v35);
  while (__stlxr(v36 - 1, v35));
  if (!v36)
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
}

void _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li768EE5flushEy(uint64_t a1, uint64_t a2)
{
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::flush(a1 + 48, a2);
}

int *_ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li768EE7compactEP22AnyVectorIndexInstanceP12uint32_map_tP11TermIdStore18CICompactCallbacksPVi(uint64_t a1, uint64_t a2)
{
  int v4;
  NSObject *v5;
  os_log_type_t v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int *result;
  char *v12;
  char *v13;
  const char *v14;
  uint8_t buf[4];
  int v16;
  __int16 v17;
  int v18;
  __int16 v19;
  int v20;
  __int16 v21;
  int v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v4 = *__error();
  v5 = _SILogForLogForCategory(16);
  v6 = 2 * (dword_1EF19FCCC < 4);
  if (os_log_type_enabled(v5, v6))
  {
    v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
    v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
    v9 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
    v10 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 24))(a2);
    *(_DWORD *)buf = 67109888;
    v16 = v7;
    v17 = 1024;
    v18 = v8;
    v19 = 1024;
    v20 = v9;
    v21 = 1024;
    v22 = v10;
    _os_log_impl(&dword_1B8270000, v5, v6, "compact %u vectors in %u partitions and %u vectors in %u partitions", buf, 0x1Au);
  }
  result = __error();
  *result = v4;
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)
    || *(unsigned __int16 *)(a1 + 20) != *(unsigned __int16 *)(a2 + 20)
    || *(_DWORD *)(a1 + 12) != *(_DWORD *)(a2 + 12)
    || *(_DWORD *)(a1 + 16) != *(_DWORD *)(a2 + 16))
  {
    v12 = __si_assert_copy_extra_268();
    v13 = v12;
    v14 = "";
    if (v12)
      v14 = v12;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3075, "compatible", v14);
    free(v13);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  return result;
}

void _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li768EE14compactForTestEP22AnyVectorIndexInstancePVi(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6;
  NSObject *v7;
  os_log_type_t v8;
  int v9;
  int v10;
  int v11;
  int v12;
  char *v13;
  char *v14;
  const char *v15;
  uint8_t buf[4];
  int v17;
  __int16 v18;
  int v19;
  __int16 v20;
  int v21;
  __int16 v22;
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)
    || *(unsigned __int16 *)(a1 + 20) != *(unsigned __int16 *)(a2 + 20)
    || *(_DWORD *)(a1 + 12) != *(_DWORD *)(a2 + 12)
    || *(_DWORD *)(a1 + 16) != *(_DWORD *)(a2 + 16))
  {
    v13 = __si_assert_copy_extra_268();
    v14 = v13;
    v15 = "";
    if (v13)
      v15 = v13;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3075, "compatible", v15);
    free(v14);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v6 = *__error();
  v7 = _SILogForLogForCategory(16);
  v8 = 2 * (dword_1EF19FCCC < 4);
  if (os_log_type_enabled(v7, v8))
  {
    v9 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
    v10 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
    v11 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
    v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 24))(a2);
    *(_DWORD *)buf = 67109888;
    v17 = v9;
    v18 = 1024;
    v19 = v10;
    v20 = 1024;
    v21 = v11;
    v22 = 1024;
    v23 = v12;
    _os_log_impl(&dword_1B8270000, v7, v8, "compactForTest %u vectors in %u partitions and %u vectors in %u partitions", buf, 0x1Au);
  }
  *__error() = v6;
  _ZN22IVFVectorIndexTemplateIDF16_Li768EE20IVFVectorIndexRoot_sI30vi_onefixedsize_disk_allocator16vi_disk_postingsE14compactForTestIS2_EENSt3__19enable_ifIXsr13is_persistentIT_EE5valueEbE4typeEPS4_PVi(a1 + 48, a2 + 48, a3);
}

void _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li768EE7subvertEPK22AnyVectorIndexInstance(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  os_unfair_lock_s *v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  uint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  unint64_t *v26;
  unint64_t v27;
  char *v28;
  char *v29;
  const char *v30;

  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)
    || *(unsigned __int16 *)(a1 + 20) != *(unsigned __int16 *)(a2 + 20)
    || *(_DWORD *)(a1 + 12) != *(_DWORD *)(a2 + 12)
    || *(_DWORD *)(a1 + 16) != *(_DWORD *)(a2 + 16))
  {
    v28 = __si_assert_copy_extra_268();
    v29 = v28;
    v30 = "";
    if (v28)
      v30 = v28;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3075, "compatible", v30);
    free(v29);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v4 = (os_unfair_lock_s *)(a1 + 144);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 144));
  v5 = *(std::__shared_weak_count **)(a1 + 120);
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  v9 = *(_QWORD *)(a1 + 128);
  v8 = *(std::__shared_weak_count **)(a1 + 136);
  if (v8)
  {
    v10 = (unint64_t *)&v8->__shared_owners_;
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }
  os_unfair_lock_unlock(v4);
  if (v5)
  {
    v12 = (unint64_t *)&v5->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  v14 = (os_unfair_lock_s *)(a2 + 144);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 144));
  v15 = *(std::__shared_weak_count **)(a2 + 120);
  if (v15)
  {
    v16 = (unint64_t *)&v15->__shared_owners_;
    do
      v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
  }
  v19 = *(_QWORD *)(a2 + 128);
  v18 = *(std::__shared_weak_count **)(a2 + 136);
  if (v18)
  {
    v20 = (unint64_t *)&v18->__shared_owners_;
    do
      v21 = __ldxr(v20);
    while (__stxr(v21 + 1, v20));
  }
  os_unfair_lock_unlock(v14);
  if (v15)
  {
    v22 = (unint64_t *)&v15->__shared_owners_;
    do
      v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v9 + 168))(v9, v19);
  if (!v18)
    goto LABEL_31;
  v24 = (unint64_t *)&v18->__shared_owners_;
  do
    v25 = __ldaxr(v24);
  while (__stlxr(v25 - 1, v24));
  if (!v25)
  {
    ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
    std::__shared_weak_count::__release_weak(v18);
    if (!v8)
      return;
  }
  else
  {
LABEL_31:
    if (!v8)
      return;
  }
  v26 = (unint64_t *)&v8->__shared_owners_;
  do
    v27 = __ldaxr(v26);
  while (__stlxr(v27 - 1, v26));
  if (!v27)
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
}

uint64_t _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li768EE6unlinkEv(uint64_t a1)
{
  os_unfair_lock_s *v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  uint64_t v10;
  int v11;
  NSObject *v12;
  _QWORD *v13;
  int v14;
  int v15;
  int v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  int v22;
  _QWORD *v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int v27;
  __int16 v28;
  int v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v2 = (os_unfair_lock_s *)(a1 + 144);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 144));
  v3 = *(std::__shared_weak_count **)(a1 + 120);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  v7 = *(_QWORD *)(a1 + 128);
  v6 = *(std::__shared_weak_count **)(a1 + 136);
  if (v6)
  {
    v8 = (unint64_t *)&v6->__shared_owners_;
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  os_unfair_lock_unlock(v2);
  (*(void (**)(uint64_t))(*(_QWORD *)v7 + 176))(v7);
  v10 = *(_QWORD *)(a1 + 80);
  v11 = *__error();
  v12 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    v13 = (_QWORD *)(v10 + 40);
    if (*(char *)(v10 + 63) < 0)
      v13 = (_QWORD *)*v13;
    v14 = *(_DWORD *)(v10 + 24);
    v15 = *(_DWORD *)(vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(v10 + 16), 0, 1556) + 1552);
    v16 = *(_DWORD *)(vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(v10 + 16), (*(_DWORD *)(v10 + 24) - 1), 1556)+ 1552);
    v22 = 136315906;
    v23 = v13;
    v24 = 1024;
    v25 = v14;
    v26 = 1024;
    v27 = v15;
    v28 = 1024;
    v29 = v16;
    _os_log_impl(&dword_1B8270000, v12, OS_LOG_TYPE_DEFAULT, "unlink VectorStore %s(%u)[%u,%u]", (uint8_t *)&v22, 0x1Eu);
  }
  *__error() = v11;
  if (v6)
  {
    v17 = (unint64_t *)&v6->__shared_owners_;
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  if (v3)
  {
    v19 = (unint64_t *)&v3->__shared_owners_;
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  return 1;
}

void _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li768EE8truncateEv(uint64_t a1)
{
  int v1;
  NSObject *v2;
  os_log_type_t v3;
  os_unfair_lock_s *v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  uint8_t v16[16];

  if (*(_BYTE *)(a1 + 192))
  {
    v1 = *__error();
    v2 = _SILogForLogForCategory(16);
    v3 = dword_1EF19FCCC < 3;
    if (os_log_type_enabled(v2, (os_log_type_t)(dword_1EF19FCCC < 3)))
    {
      *(_WORD *)v16 = 0;
      _os_log_impl(&dword_1B8270000, v2, v3, "*warn* call truncate on readOnly index.", v16, 2u);
    }
    *__error() = v1;
  }
  else
  {
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::flush(a1 + 48, 0);
    _ZN22IVFVectorIndexTemplateIDF16_Li768EE11VectorStoreI32vi_onefixedsize_memory_allocator18vi_memory_postingsE8truncateEv(*(_QWORD *)(a1 + 80));
    v5 = (os_unfair_lock_s *)(a1 + 144);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 144));
    v6 = *(std::__shared_weak_count **)(a1 + 120);
    if (v6)
    {
      p_shared_owners = (unint64_t *)&v6->__shared_owners_;
      do
        v8 = __ldxr(p_shared_owners);
      while (__stxr(v8 + 1, p_shared_owners));
    }
    v10 = *(_QWORD *)(a1 + 128);
    v9 = *(std::__shared_weak_count **)(a1 + 136);
    if (v9)
    {
      v11 = (unint64_t *)&v9->__shared_owners_;
      do
        v12 = __ldxr(v11);
      while (__stxr(v12 + 1, v11));
      os_unfair_lock_unlock(v5);
      (*(void (**)(uint64_t))(*(_QWORD *)v10 + 136))(v10);
      do
        v13 = __ldaxr(v11);
      while (__stlxr(v13 - 1, v11));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
    else
    {
      os_unfair_lock_unlock(v5);
      (*(void (**)(uint64_t))(*(_QWORD *)v10 + 136))(v10);
    }
    if (v6)
    {
      v14 = (unint64_t *)&v6->__shared_owners_;
      do
        v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }
}

void _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li768EE12makeReadOnlyEv(uint64_t a1)
{
  int v1;
  NSObject *v2;
  os_log_type_t v3;
  uint64_t v5;
  int v6;
  NSObject *v7;
  _QWORD *v8;
  int v9;
  int v10;
  int v11;
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  std::__shared_weak_count *v15;
  uint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  int v22;
  _QWORD *v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int v27;
  __int16 v28;
  int v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 192))
  {
    v1 = *__error();
    v2 = _SILogForLogForCategory(16);
    v3 = dword_1EF19FCCC < 3;
    if (os_log_type_enabled(v2, (os_log_type_t)(dword_1EF19FCCC < 3)))
    {
      LOWORD(v22) = 0;
      _os_log_impl(&dword_1B8270000, v2, v3, "*warn* call makeReadOnly on readOnly index.", (uint8_t *)&v22, 2u);
    }
    *__error() = v1;
  }
  else
  {
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::flush(a1 + 48, 0);
    v5 = *(_QWORD *)(a1 + 80);
    v6 = *__error();
    v7 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      v8 = (_QWORD *)(v5 + 40);
      if (*(char *)(v5 + 63) < 0)
        v8 = (_QWORD *)*v8;
      v9 = *(_DWORD *)(v5 + 24);
      v10 = *(_DWORD *)(vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(v5 + 16), 0, 1556) + 1552);
      v11 = *(_DWORD *)(vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(v5 + 16), (*(_DWORD *)(v5 + 24) - 1), 1556)+ 1552);
      v22 = 136315906;
      v23 = v8;
      v24 = 1024;
      v25 = v9;
      v26 = 1024;
      v27 = v10;
      v28 = 1024;
      v29 = v11;
      _os_log_impl(&dword_1B8270000, v7, OS_LOG_TYPE_DEFAULT, "makeReadOnly VectorStore %s(%u)[%u,%u]", (uint8_t *)&v22, 0x1Eu);
    }
    *__error() = v6;
    _ZN22IVFVectorIndexTemplateIDF16_Li768EE11VectorStoreI32vi_onefixedsize_memory_allocator18vi_memory_postingsE8truncateEv(v5);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 144));
    v12 = *(std::__shared_weak_count **)(a1 + 120);
    if (v12)
    {
      p_shared_owners = (unint64_t *)&v12->__shared_owners_;
      do
        v14 = __ldxr(p_shared_owners);
      while (__stxr(v14 + 1, p_shared_owners));
    }
    v16 = *(_QWORD *)(a1 + 128);
    v15 = *(std::__shared_weak_count **)(a1 + 136);
    if (v15)
    {
      v17 = (unint64_t *)&v15->__shared_owners_;
      do
        v18 = __ldxr(v17);
      while (__stxr(v18 + 1, v17));
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 144));
      (*(void (**)(uint64_t))(*(_QWORD *)v16 + 120))(v16);
      *(_BYTE *)(a1 + 192) = 1;
      do
        v19 = __ldaxr(v17);
      while (__stlxr(v19 - 1, v17));
      if (!v19)
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
    }
    else
    {
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 144));
      (*(void (**)(uint64_t))(*(_QWORD *)v16 + 120))(v16);
      *(_BYTE *)(a1 + 192) = 1;
    }
    if (v12)
    {
      v20 = (unint64_t *)&v12->__shared_owners_;
      do
        v21 = __ldaxr(v20);
      while (__stlxr(v21 - 1, v20));
      if (!v21)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
  }
}

void _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li768EE13makePurgeableEv(uint64_t a1)
{
  uint64_t v2;
  int v3;
  NSObject *v4;
  _QWORD *v5;
  int v6;
  int v7;
  int v8;
  os_unfair_lock_s *v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  std::__shared_weak_count *v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  int v20;
  _QWORD *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 80);
  v3 = *__error();
  v4 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v5 = (_QWORD *)(v2 + 40);
    if (*(char *)(v2 + 63) < 0)
      v5 = (_QWORD *)*v5;
    v6 = *(_DWORD *)(v2 + 24);
    v7 = *(_DWORD *)(vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(v2 + 16), 0, 1556) + 1552);
    v8 = *(_DWORD *)(vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(v2 + 16), (*(_DWORD *)(v2 + 24) - 1), 1556)+ 1552);
    v20 = 136315906;
    v21 = v5;
    v22 = 1024;
    v23 = v6;
    v24 = 1024;
    v25 = v7;
    v26 = 1024;
    v27 = v8;
    _os_log_impl(&dword_1B8270000, v4, OS_LOG_TYPE_DEFAULT, "makePurgeable VectorStore %s(%u)[%u,%u]", (uint8_t *)&v20, 0x1Eu);
  }
  *__error() = v3;
  v9 = (os_unfair_lock_s *)(a1 + 144);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 144));
  v10 = *(std::__shared_weak_count **)(a1 + 120);
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }
  v14 = *(_QWORD *)(a1 + 128);
  v13 = *(std::__shared_weak_count **)(a1 + 136);
  if (!v13)
  {
    os_unfair_lock_unlock(v9);
    (*(void (**)(uint64_t))(*(_QWORD *)v14 + 128))(v14);
    if (!v10)
      return;
    goto LABEL_18;
  }
  v15 = (unint64_t *)&v13->__shared_owners_;
  do
    v16 = __ldxr(v15);
  while (__stxr(v16 + 1, v15));
  os_unfair_lock_unlock(v9);
  (*(void (**)(uint64_t))(*(_QWORD *)v14 + 128))(v14);
  do
    v17 = __ldaxr(v15);
  while (__stlxr(v17 - 1, v15));
  if (!v17)
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  if (v10)
  {
LABEL_18:
    v18 = (unint64_t *)&v10->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
}

void _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li768EE6renameEPKc(uint64_t a1, const char *a2)
{
  int v4;
  NSObject *v5;
  size_t v6;
  std::string::size_type v7;
  std::string *p_buf;
  uint64_t v9;
  uint64_t v10;
  int v11;
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  std::__shared_weak_count *v15;
  uint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  std::string *v19;
  uint64_t v20;
  int v21;
  NSObject *v22;
  _QWORD *v23;
  int v24;
  int v25;
  int v26;
  unint64_t *v27;
  unint64_t v28;
  unint64_t *v29;
  unint64_t v30;
  std::string::value_type __s[23];
  char v32;
  std::string v33;
  std::string buf;
  int v35;
  __int16 v36;
  int v37;
  __int16 v38;
  int v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  v4 = *__error();
  v5 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
    _os_log_impl(&dword_1B8270000, v5, OS_LOG_TYPE_DEFAULT, "rename: %s", (uint8_t *)&buf, 0xCu);
  }
  *__error() = v4;
  v6 = strlen(a2);
  if (v6 >= 0x7FFFFFFFFFFFFFF8)
    abort();
  v7 = v6;
  if (v6 >= 0x17)
  {
    v9 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v6 | 7) != 0x17)
      v9 = v6 | 7;
    v10 = v9 + 1;
    p_buf = (std::string *)operator new(v9 + 1);
    buf.__r_.__value_.__l.__size_ = v7;
    buf.__r_.__value_.__r.__words[2] = v10 | 0x8000000000000000;
    buf.__r_.__value_.__r.__words[0] = (std::string::size_type)p_buf;
    goto LABEL_10;
  }
  *((_BYTE *)&buf.__r_.__value_.__s + 23) = v6;
  p_buf = &buf;
  if (v6)
LABEL_10:
    memcpy(p_buf, a2, v7);
  p_buf->__r_.__value_.__s.__data_[v7] = 0;
  v32 = 11;
  strcpy(__s, ".partitions");
  memset(&v33, 0, sizeof(v33));
  v11 = SHIBYTE(buf.__r_.__value_.__r.__words[2]);
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(&v33, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
  else
    v33 = buf;
  std::string::append(&v33, __s, 0xBuLL);
  if (v32 < 0)
  {
    operator delete(*(void **)__s);
    if ((v11 & 0x80000000) == 0)
      goto LABEL_16;
  }
  else if ((v11 & 0x80000000) == 0)
  {
    goto LABEL_16;
  }
  operator delete(buf.__r_.__value_.__l.__data_);
LABEL_16:
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 144));
  v12 = *(std::__shared_weak_count **)(a1 + 120);
  if (v12)
  {
    p_shared_owners = (unint64_t *)&v12->__shared_owners_;
    do
      v14 = __ldxr(p_shared_owners);
    while (__stxr(v14 + 1, p_shared_owners));
  }
  v16 = *(_QWORD *)(a1 + 128);
  v15 = *(std::__shared_weak_count **)(a1 + 136);
  if (v15)
  {
    v17 = (unint64_t *)&v15->__shared_owners_;
    do
      v18 = __ldxr(v17);
    while (__stxr(v18 + 1, v17));
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 144));
  if ((v33.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v19 = &v33;
  else
    v19 = (std::string *)v33.__r_.__value_.__r.__words[0];
  (*(void (**)(uint64_t, std::string *))(*(_QWORD *)v16 + 152))(v16, v19);
  v20 = *(_QWORD *)(a1 + 80);
  v21 = *__error();
  v22 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    v23 = (_QWORD *)(v20 + 40);
    if (*(char *)(v20 + 63) < 0)
      v23 = (_QWORD *)*v23;
    v24 = *(_DWORD *)(v20 + 24);
    v25 = *(_DWORD *)(vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(v20 + 16), 0, 1556) + 1552);
    v26 = *(_DWORD *)(vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(v20 + 16), (*(_DWORD *)(v20 + 24) - 1), 1556)+ 1552);
    LODWORD(buf.__r_.__value_.__l.__data_) = 136316162;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v23;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)a2;
    HIWORD(buf.__r_.__value_.__r.__words[2]) = 1024;
    v35 = v24;
    v36 = 1024;
    v37 = v25;
    v38 = 1024;
    v39 = v26;
    _os_log_impl(&dword_1B8270000, v22, OS_LOG_TYPE_DEFAULT, "rename VectorStore %s -> %s(%u)[%u,%u]", (uint8_t *)&buf, 0x28u);
  }
  *__error() = v21;
  MEMORY[0x1BCCB03B0](v20 + 40, a2);
  if (v15)
  {
    v27 = (unint64_t *)&v15->__shared_owners_;
    do
      v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  if (!v12)
    goto LABEL_38;
  v29 = (unint64_t *)&v12->__shared_owners_;
  do
    v30 = __ldaxr(v29);
  while (__stlxr(v30 - 1, v29));
  if (v30)
  {
LABEL_38:
    if ((SHIBYTE(v33.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      return;
    goto LABEL_39;
  }
  ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
  std::__shared_weak_count::__release_weak(v12);
  if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0)
LABEL_39:
    operator delete(v33.__r_.__value_.__l.__data_);
}

_QWORD *_ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li768EE14storeUpdateSetEP15RelativePostingP14store_stream_t(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  _QWORD *result;
  unsigned int v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  char *v12;
  size_t v13;
  uint64_t v14;
  char *v15;
  char *v16;
  const char *v17;
  uint64_t v18;

  result = store_stream_write_vint32_2186(a3, *(_DWORD *)(*(_QWORD *)(a1 + 80) + 24));
  v7 = 0;
  v8 = *(_QWORD *)(a1 + 80);
  while (v7 != *(_DWORD *)(v8 + 24))
  {
    v9 = _ZNK22IVFVectorIndexTemplateIDF16_Li768EE11VectorStoreI32vi_onefixedsize_memory_allocator18vi_memory_postingsE8IteratordeEv(v8, v7);
    CIWritePostings((uint64_t)a3, a2, 0, (unsigned int *)(v9 + 1536), 0, 0);
    v11 = *((_QWORD *)a3 + 4);
    v10 = *((_QWORD *)a3 + 5);
    if (v10 + 1536 >= v11)
    {
      v13 = 1536;
      v12 = (char *)v9;
      while (1)
      {
        v14 = v11 - v10;
        memcpy((void *)(*((_QWORD *)a3 + 6) + v10), v12, v11 - v10);
        *((_QWORD *)a3 + 5) += v14;
        if (store_stream_flush(a3, 0))
          break;
        v12 += v14;
        v13 -= v14;
        v11 = *((_QWORD *)a3 + 4);
        v10 = *((_QWORD *)a3 + 5);
        if (v10 + v13 < v11)
          goto LABEL_5;
      }
    }
    else
    {
      v12 = (char *)v9;
      v13 = 1536;
LABEL_5:
      memcpy((void *)(*((_QWORD *)a3 + 6) + v10), v12, v13);
      *((_QWORD *)a3 + 5) += v13;
    }
    result = store_stream_write_vint32_2186(a3, *(_DWORD *)(v9 + 1552));
    ++v7;
    if (v8 != *(_QWORD *)(a1 + 80))
    {
      v15 = __si_assert_copy_extra_268();
      v16 = v15;
      v17 = "";
      if (v15)
        v17 = v15;
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1814, "store == other.store", v17);
      free(v16);
      if (__valid_fs(-1))
        v18 = 2989;
      else
        v18 = 3072;
      *(_DWORD *)v18 = -559038737;
      abort();
    }
  }
  return result;
}

uint64_t _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li768EE16restoreUpdateSetEP15PostingBaseInfoP14store_stream_t(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  uint64_t result;
  int v6;
  _BYTE *v7;
  unint64_t v8;
  size_t v9;
  size_t v10;
  unsigned int vint32;
  uint64_t v12;
  uint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  _DWORD *inserted;
  unint64_t v21;
  _DWORD *v22;
  unint64_t *v23;
  unint64_t v24;
  __int16 v25;
  int v26;
  char *v27;
  unint64_t v28;
  uint64_t v29;
  void *v30;
  unint64_t v31;
  uint64_t v32;
  int *v33;
  off_t v34;
  size_t v35;
  void *v36;
  size_t v37;
  unint64_t v38;
  uint64_t v39;
  int *v40;
  char v41;
  off_t v42;
  off_t v43;
  off_t __offseta;
  unsigned int __offsetb;
  uint64_t v46;
  int v47;
  int v49;
  _BYTE __dst[1536];
  uint64_t v51;
  uint64_t v52;
  _BYTE v53[2];
  __int16 v54;

  result = store_stream_read_vint32((uint64_t)a3);
  v47 = result;
  if ((_DWORD)result)
  {
    v6 = 0;
    v46 = a1 + 48;
    do
    {
      v51 = 0;
      v52 = 0;
      v7 = __dst;
      bzero(__dst, 0x600uLL);
      v49 = 0;
      CIReadPostings(a3, a2, (uint64_t)&v51, &v49);
      v8 = *((_QWORD *)a3 + 4);
      v9 = *((_QWORD *)a3 + 5);
      if (v9 + 1536 > v8)
      {
        v27 = (char *)*((_QWORD *)a3 + 6);
        v28 = v8 - v9;
        if (v8 != v9)
        {
          memcpy(__dst, &v27[v9], v8 - v9);
          *((_QWORD *)a3 + 5) = v8;
          v9 = v8;
        }
        v29 = *a3;
        __offseta = *((_QWORD *)a3 + 3);
        v30 = v27;
        while (1)
        {
          v31 = pread(v29, v30, v9, __offseta);
          if (v31 != -1)
            break;
          v32 = g_prot_error_callback;
          if (!g_prot_error_callback)
            break;
          v33 = __error();
          if (((*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t))(v32 + 16))(v32, v29, *v33, 4) & 1) == 0)goto LABEL_47;
        }
        if (v31 != -1)
        {
          *((_QWORD *)a3 + 4) = v31;
          *((_QWORD *)a3 + 5) = 0;
          v34 = *((_QWORD *)a3 + 3) + v31;
          *((_QWORD *)a3 + 3) = v34;
          if (!v31)
            goto LABEL_7;
          v7 = &__dst[v28];
          v10 = 1536 - v28;
          if (1536 - v28 <= v31)
          {
            v9 = 0;
            goto LABEL_6;
          }
          v43 = v34;
          v35 = v31;
          while (1)
          {
            v36 = (void *)*((_QWORD *)a3 + 6);
            memcpy(v7, v36, v35);
            v37 = v35;
            *((_QWORD *)a3 + 5) = v35;
            __offsetb = *a3;
            while (1)
            {
              v38 = pread(__offsetb, v36, v37, v43);
              if (v38 != -1)
                break;
              v39 = g_prot_error_callback;
              if (!g_prot_error_callback)
                break;
              v40 = __error();
              v41 = (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, uint64_t))(v39 + 16))(v39, __offsetb, *v40, 4);
              v37 = v35;
              if ((v41 & 1) == 0)
                goto LABEL_47;
            }
            if (v38 == -1)
              break;
            *((_QWORD *)a3 + 4) = v38;
            *((_QWORD *)a3 + 5) = 0;
            v42 = *((_QWORD *)a3 + 3) + v38;
            *((_QWORD *)a3 + 3) = v42;
            if (!v38)
              goto LABEL_7;
            v43 = v42;
            v9 = 0;
            v7 += v35;
            v10 -= v35;
            v35 = v38;
            if (v10 <= v38)
              goto LABEL_6;
          }
        }
LABEL_47:
        a3[4] = *__error();
      }
      else
      {
        v10 = 1536;
LABEL_6:
        memcpy(v7, (const void *)(*((_QWORD *)a3 + 6) + v9), v10);
        *((_QWORD *)a3 + 5) = v9 + v10;
      }
LABEL_7:
      vint32 = store_stream_read_vint32((uint64_t)a3);
      v12 = v51;
      v13 = v52;
      os_unfair_lock_lock((os_unfair_lock_t)(a1 + 144));
      v14 = *(std::__shared_weak_count **)(a1 + 120);
      if (v14)
      {
        p_shared_owners = (unint64_t *)&v14->__shared_owners_;
        do
          v16 = __ldxr(p_shared_owners);
        while (__stxr(v16 + 1, p_shared_owners));
      }
      v17 = *(std::__shared_weak_count **)(a1 + 136);
      if (v17)
      {
        v18 = (unint64_t *)&v17->__shared_owners_;
        do
          v19 = __ldxr(v18);
        while (__stxr(v19 + 1, v18));
        os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 144));
        inserted = _ZN22IVFVectorIndexTemplateIDF16_Li768EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE15lookupForInsertEjRK10CIVector_sIDF16_Li768EEjfb(v46, vint32, __dst, 0xFFFFFFFF, 3.4028e38);
        *((_QWORD *)inserted + 192) = v12;
        *((_QWORD *)inserted + 193) = v13;
        do
          v21 = __ldaxr(v18);
        while (__stlxr(v21 - 1, v18));
        if (!v21)
        {
          ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
          std::__shared_weak_count::__release_weak(v17);
        }
      }
      else
      {
        os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 144));
        v22 = _ZN22IVFVectorIndexTemplateIDF16_Li768EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE15lookupForInsertEjRK10CIVector_sIDF16_Li768EEjfb(v46, vint32, __dst, 0xFFFFFFFF, 3.4028e38);
        *((_QWORD *)v22 + 192) = v12;
        *((_QWORD *)v22 + 193) = v13;
      }
      if (v14)
      {
        v23 = (unint64_t *)&v14->__shared_owners_;
        do
          v24 = __ldaxr(v23);
        while (__stlxr(v24 - 1, v23));
        if (!v24)
        {
          ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
          std::__shared_weak_count::__release_weak(v14);
        }
      }
      v25 = *(_WORD *)(a1 + 76);
      v26 = *(_DWORD *)(a1 + 156);
      v53[0] = *(_DWORD *)(a1 + 160);
      v53[1] = v26;
      v54 = v25;
      result = *(_QWORD *)(a1 + 176);
      if (result)
      {
        if (*(_DWORD *)(result + 216) == -270471200)
          result = data_map_ext_restore_data(result, vint32, __dst, 0x600uLL, v53);
      }
      ++v6;
    }
    while (v6 != v47);
  }
  return result;
}

uint64_t _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li768EE3aNNEjtPKv14vec_dimensions15vec_data_formatfjbU13block_pointerFvPvfE(uint64_t a1, int a2, int a3, uint64_t a4, int a5, int a6, int a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;
  int v10;
  uint64_t v11;
  char *v13;
  char *v14;
  const char *v15;
  _QWORD v16[5];

  if (*(_DWORD *)(a1 + 8) != a2
    || *(unsigned __int16 *)(a1 + 20) != a3
    || a6 > 2
    || *(_DWORD *)(a1 + 12) != vector_dimension_vec_sizes_10743[a5]
    || vector_size_elem_sizes_10742[a6] != *(_DWORD *)(a1 + 16))
  {
    v13 = __si_assert_copy_extra_268();
    v14 = v13;
    v15 = "";
    if (v13)
      v15 = v13;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3070, "compatible", v15);
    free(v14);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v9 = a1 + 48;
  v16[0] = MEMORY[0x1E0C809B0];
  v16[1] = 0x40000000;
  v16[2] = ___ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li768EE3aNNEjtPKv14vec_dimensions15vec_data_formatfjbU13block_pointerFvPvfE_block_invoke;
  v16[3] = &unk_1E6E32170;
  v16[4] = a9;
  if ((a7 - 10001) >= 0xFFFFD8F0)
    v10 = a7;
  else
    v10 = 10000;
  v11 = operator new();
  *(_DWORD *)v11 = v10;
  *(_QWORD *)(v11 + 16) = 0;
  *(_QWORD *)(v11 + 24) = 0;
  *(_QWORD *)(v11 + 8) = 0;
  _ZNK22IVFVectorIndexTemplateIDF16_Li768EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE3aNNERK10CIVector_sIDF16_Li768EEfbP20MaxSizePriorityQueueINS0_18candidate_result_sIS3_EENSt3__16vectorISB_NSC_9allocatorISB_EEEENSC_4lessISB_EEEj(v9);
  return IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::aNNProcessResult(v11, (uint64_t)v16);
}

uint64_t _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li768EE10aNNForTestEjtPKv14vec_dimensions15vec_data_formatfjbU13block_pointerFvjfEj(uint64_t a1, int a2, int a3, uint64_t a4, int a5, int a6, int a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;
  int v10;
  uint64_t v11;
  char *v13;
  char *v14;
  const char *v15;

  if (*(_DWORD *)(a1 + 8) != a2
    || *(unsigned __int16 *)(a1 + 20) != a3
    || a6 > 2
    || *(_DWORD *)(a1 + 12) != vector_dimension_vec_sizes_10743[a5]
    || vector_size_elem_sizes_10742[a6] != *(_DWORD *)(a1 + 16))
  {
    v13 = __si_assert_copy_extra_268();
    v14 = v13;
    v15 = "";
    if (v13)
      v15 = v13;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3070, "compatible", v15);
    free(v14);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v9 = a1 + 48;
  if ((a7 - 10001) >= 0xFFFFD8F0)
    v10 = a7;
  else
    v10 = 10000;
  v11 = operator new();
  *(_DWORD *)v11 = v10;
  *(_QWORD *)(v11 + 16) = 0;
  *(_QWORD *)(v11 + 24) = 0;
  *(_QWORD *)(v11 + 8) = 0;
  _ZNK22IVFVectorIndexTemplateIDF16_Li768EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE3aNNERK10CIVector_sIDF16_Li768EEfbP20MaxSizePriorityQueueINS0_18candidate_result_sIS3_EENSt3__16vectorISB_NSC_9allocatorISB_EEEENSC_4lessISB_EEEj(v9);
  return IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::aNNForTestProcessResult(v11, a9);
}

uint64_t _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li768EE20createCandidateQueueEj(uint64_t a1, int a2)
{
  int v2;
  uint64_t result;

  if ((a2 - 10001) >= 0xFFFFD8F0)
    v2 = a2;
  else
    v2 = 10000;
  result = operator new();
  *(_DWORD *)result = v2;
  *(_QWORD *)(result + 16) = 0;
  *(_QWORD *)(result + 24) = 0;
  *(_QWORD *)(result + 8) = 0;
  return result;
}

void _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li768EE3aNNEjtPKv14vec_dimensions15vec_data_formatfbPv(uint64_t a1, int a2, int a3, uint64_t a4, int a5, int a6)
{
  char *v6;
  char *v7;
  const char *v8;

  if (*(_DWORD *)(a1 + 8) != a2
    || *(unsigned __int16 *)(a1 + 20) != a3
    || a6 > 2
    || *(_DWORD *)(a1 + 12) != vector_dimension_vec_sizes_10743[a5]
    || vector_size_elem_sizes_10742[a6] != *(_DWORD *)(a1 + 16))
  {
    v6 = __si_assert_copy_extra_268();
    v7 = v6;
    v8 = "";
    if (v6)
      v8 = v6;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3070, "compatible", v8);
    free(v7);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  _ZNK22IVFVectorIndexTemplateIDF16_Li768EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE3aNNERK10CIVector_sIDF16_Li768EEfbP20MaxSizePriorityQueueINS0_18candidate_result_sIS3_EENSt3__16vectorISB_NSC_9allocatorISB_EEEENSC_4lessISB_EEEj(a1 + 48);
}

uint64_t _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li768EE16aNNProcessResultEPvU13block_pointerFvS5_fE(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD v4[5];

  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 0x40000000;
  v4[2] = ___ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li768EE16aNNProcessResultEPvU13block_pointerFvS5_fE_block_invoke;
  v4[3] = &unk_1E6E321D0;
  v4[4] = a3;
  return IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::aNNProcessResult(a2, (uint64_t)v4);
}

uint64_t _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li768EE23aNNForTestProcessResultEPvU13block_pointerFvjfE(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::aNNForTestProcessResult(a2, a3);
}

uint64_t _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li768EE24aNNForDebugProcessResultEPvU13block_pointerFvjjfE(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5;
  NSObject *v6;
  unint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  std::ios_base *v13;
  uint64_t v14;
  float *v15;
  BOOL v16;
  int v17;
  float *v18;
  _QWORD *v19;
  _QWORD *v20;
  char *v21;
  unint64_t v22;
  int v23;
  NSObject *v24;
  void **v25;
  float *v26;
  char *v27;
  uint64_t v28;
  int v29;
  NSObject *v30;
  void **v31;
  void *v32;
  uint64_t v33;
  int v35;
  float *v36;
  CFIndex AppIntegerValue;
  float *v38;
  float *v39;
  uint64_t v40;
  uint8_t v41[4];
  void **v42;
  void *__p[2];
  uint64_t v44;
  uint64_t v45;
  __int128 buf;
  uint64_t v47;
  _QWORD v48[8];
  __int128 v49;
  __int128 v50;
  uint64_t v51;
  uint64_t v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  uint64_t v62;

  v62 = *MEMORY[0x1E0C80C00];
  v5 = *__error();
  v6 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    v7 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a2 + 16) - *(_QWORD *)(a2 + 8)) >> 3);
    LODWORD(buf) = 134217984;
    *(_QWORD *)((char *)&buf + 4) = v7;
    _os_log_impl(&dword_1B8270000, v6, OS_LOG_TYPE_DEFAULT, "search return %zu results", (uint8_t *)&buf, 0xCu);
  }
  *__error() = v5;
  LOBYTE(buf) = 0;
  AppIntegerValue = CFPreferencesGetAppIntegerValue(CFSTR("IVFANNLogQueryResult"), CFSTR("com.apple.Spotlight"), (Boolean *)&buf);
  v35 = buf;
  v61 = 0u;
  v51 = 0;
  v60 = 0u;
  v59 = 0u;
  v58 = 0u;
  v57 = 0u;
  v56 = 0u;
  v55 = 0u;
  v54 = 0u;
  v53 = 0u;
  v50 = 0u;
  v49 = 0u;
  memset(v48, 0, sizeof(v48));
  v8 = MEMORY[0x1E0DE4FD0] + 104;
  v52 = MEMORY[0x1E0DE4FD0] + 104;
  v9 = (_QWORD *)MEMORY[0x1E0DE4F50];
  v10 = MEMORY[0x1E0DE4FD0] + 64;
  v11 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 16);
  v12 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 24);
  v47 = MEMORY[0x1E0DE4FD0] + 64;
  *(_QWORD *)&buf = v11;
  *(_QWORD *)((char *)&buf + *(_QWORD *)(v11 - 24)) = v12;
  *((_QWORD *)&buf + 1) = 0;
  v13 = (std::ios_base *)((char *)&buf + *(_QWORD *)(buf - 24));
  std::ios_base::init(v13, v48);
  v13[1].__vftable = 0;
  v13[1].__fmtflags_ = -1;
  v14 = v9[5];
  v47 = v9[4];
  *(_QWORD *)((char *)&v48[-1] + *(_QWORD *)(v47 - 24)) = v14;
  *(_QWORD *)&buf = v9[1];
  *(_QWORD *)((char *)&buf + *(_QWORD *)(buf - 24)) = v9[6];
  v52 = v8;
  *(_QWORD *)&buf = MEMORY[0x1E0DE4FD0] + 24;
  v47 = v10;
  std::streambuf::basic_streambuf();
  v48[0] = MEMORY[0x1E0DE4FB8] + 16;
  v49 = 0u;
  v50 = 0u;
  LODWORD(v51) = 24;
  v38 = 0;
  v39 = 0;
  v40 = 0;
  MaxSizePriorityQueue<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_memory_postings>,std::vector<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_memory_postings>,std::allocator<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_memory_postings>>>,std::less<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_memory_postings>>>::allItems(&v38, *(_BYTE **)(a2 + 8), *(_BYTE **)(a2 + 16));
  v15 = v39;
  v36 = v38;
  if (v38 != v39)
  {
    if (AppIntegerValue)
      v16 = v35 == 0;
    else
      v16 = 1;
    if (v16)
    {
      v26 = v38;
      do
      {
        (*(void (**)(uint64_t, _QWORD, _QWORD, float))(a3 + 16))(a3, *((unsigned int *)v26 + 2), *((unsigned int *)v26 + 4), v26[5]);
        v26 += 6;
      }
      while (v26 != v15);
    }
    else
    {
      v17 = 0;
      v18 = v38;
      do
      {
        (*(void (**)(uint64_t, _QWORD, _QWORD, float))(a3 + 16))(a3, *((unsigned int *)v18 + 2), *((unsigned int *)v18 + 4), v18[5]);
        v19 = (_QWORD *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v19, (uint64_t)",", 1);
        v20 = (_QWORD *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v20, (uint64_t)";", 1);
        v21 = (char *)&v48[-1] + *(_QWORD *)(v47 - 24);
        if ((v21[32] & 5) == 0
          && ((*(void (**)(void **__return_ptr, _QWORD, _QWORD, uint64_t, uint64_t))(**((_QWORD **)v21 + 5)
                                                                                            + 32))(__p, *((_QWORD *)v21 + 5), 0, 1, 16), v45 > 1000)|| (++v17, HIDWORD(v22) = -1030792151 * v17 + 85899344, LODWORD(v22) = HIDWORD(v22), (v22 >> 1) < 0x51EB851))
        {
          v23 = *__error();
          v24 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
          {
            std::stringbuf::str();
            v25 = __p;
            if (v44 < 0)
              v25 = (void **)__p[0];
            *(_DWORD *)v41 = 136315138;
            v42 = v25;
            _os_log_impl(&dword_1B8270000, v24, OS_LOG_TYPE_DEFAULT, "%s", v41, 0xCu);
            if (SHIBYTE(v44) < 0)
              operator delete(__p[0]);
          }
          *__error() = v23;
          __p[0] = 0;
          __p[1] = 0;
          v44 = 0;
          std::stringbuf::str();
          if (SHIBYTE(v44) < 0)
            operator delete(__p[0]);
        }
        v18 += 6;
      }
      while (v18 != v15);
    }
  }
  v27 = (char *)&v48[-1] + *(_QWORD *)(v47 - 24);
  if ((v27[32] & 5) != 0)
  {
    v28 = a2;
  }
  else
  {
    (*(void (**)(void **__return_ptr, _QWORD, _QWORD, uint64_t, uint64_t))(**((_QWORD **)v27 + 5) + 32))(__p, *((_QWORD *)v27 + 5), 0, 1, 16);
    v28 = a2;
    if (v45 > 0)
    {
      v29 = *__error();
      v30 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        std::stringbuf::str();
        v31 = v44 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)v41 = 136315138;
        v42 = v31;
        _os_log_impl(&dword_1B8270000, v30, OS_LOG_TYPE_DEFAULT, "%s", v41, 0xCu);
        if (SHIBYTE(v44) < 0)
          operator delete(__p[0]);
      }
      *__error() = v29;
    }
  }
  if (v28)
  {
    v32 = *(void **)(v28 + 8);
    if (v32)
    {
      *(_QWORD *)(v28 + 16) = v32;
      operator delete(v32);
    }
    MEMORY[0x1BCCB06A4](v28, 0x1020C403EC25235);
  }
  if (v36)
    operator delete(v36);
  *(_QWORD *)&buf = *MEMORY[0x1E0DE4F50];
  v33 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 72);
  *(_QWORD *)((char *)&buf + *(_QWORD *)(buf - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 64);
  v47 = v33;
  v48[0] = MEMORY[0x1E0DE4FB8] + 16;
  if (SBYTE7(v50) < 0)
    operator delete((void *)v49);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1BCCB0650](&v52);
}

uint64_t _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li768EE11storageSizeEv(uint64_t a1)
{
  os_unfair_lock_s *v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;

  v2 = (os_unfair_lock_s *)(a1 + 144);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 144));
  v3 = *(std::__shared_weak_count **)(a1 + 120);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  v7 = *(_QWORD *)(a1 + 128);
  v6 = *(std::__shared_weak_count **)(a1 + 136);
  if (v6)
  {
    v8 = (unint64_t *)&v6->__shared_owners_;
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  os_unfair_lock_unlock(v2);
  v10 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 16) + 24);
  v11 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 184))(v7);
  if (!v6)
    goto LABEL_11;
  v12 = (unint64_t *)&v6->__shared_owners_;
  do
    v13 = __ldaxr(v12);
  while (__stlxr(v13 - 1, v12));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
    if (!v3)
      return v11 + v10;
  }
  else
  {
LABEL_11:
    if (!v3)
      return v11 + v10;
  }
  v14 = (unint64_t *)&v3->__shared_owners_;
  do
    v15 = __ldaxr(v14);
  while (__stlxr(v15 - 1, v14));
  if (!v15)
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return v11 + v10;
}

uint64_t _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li768EE14setVectorStoreEP10data_map_s(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 176) = a2;
  return result;
}

uint64_t _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li768EE16getDataForOffsetEjPj(_QWORD *a1, uint64_t a2, int *a3)
{
  uint64_t result;
  int v7;
  int v8;
  NSObject *v9;
  int *v10;
  int v11;
  int v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  int v17;
  __int16 v18;
  int v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if ((*(unsigned int (**)(_QWORD *))(*a1 + 16))(a1) <= a2)
  {
    v8 = *__error();
    v9 = _SILogForLogForCategory(2);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v11 = (*(uint64_t (**)(_QWORD *))(*a1 + 16))(a1);
      v12 = 136315906;
      v13 = "getDataForOffset";
      v14 = 1024;
      v15 = 3455;
      v16 = 1024;
      v17 = a2;
      v18 = 1024;
      v19 = v11;
      _os_log_error_impl(&dword_1B8270000, v9, OS_LOG_TYPE_ERROR, "%s:%d: offset out of range: %u >= %u", (uint8_t *)&v12, 0x1Eu);
    }
    v10 = __error();
    v7 = 0;
    result = 0;
    *v10 = v8;
  }
  else
  {
    result = (*(uint64_t (**)(_QWORD *, uint64_t))(a1[6] + 32))(a1 + 6, a2);
    v7 = 1536;
  }
  *a3 = v7;
  return result;
}

uint64_t _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li768EE26updateVectorStorageOffsetsEP13__SIUINT64Set(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  uint64_t v4;
  unint64_t i;
  uint64_t result;
  unint64_t Ptr;
  unint64_t v8;
  int v9;
  uint64_t v10;
  int v11;

  v2 = a2;
  v4 = a1 + 48;
  if (a2)
  {
    for (i = 0; ; ++i)
    {
      result = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nVectors(v4);
      if (i >= result)
        break;
      Ptr = vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(*(_QWORD *)(a1 + 80) + 16), i, 1556);
      if (!*(_BYTE *)(v2 + 184))
      {
        v8 = *(unsigned int *)(Ptr + 1552);
        v9 = *(_DWORD *)(v2 + 24);
        if (!v9 || !((*(_QWORD *)(v2 + 16) ^ v8) >> (-4 * v9)))
        {
          v10 = *(_QWORD *)(v2 + 56 + 8 * ((v8 >> ((60 - 4 * v9) & 0xFC)) & 0xF));
          if ((v10 & 1) != 0)
          {
            v11 = v9 + 2;
            do
              v10 = *(_QWORD *)((v10 & 0xFFFFFFFFFFFFFFFELL) + 8 * ((v8 >> ((64 - 4 * v11++) & 0xFC)) & 0xF));
            while ((v10 & 1) != 0);
          }
          if (v10)
            (*(void (**)(uint64_t))(*(_QWORD *)v10 + 16))(v10);
        }
      }
    }
  }
  else
  {
    while (1)
    {
      result = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nVectors(v4);
      if (v2 >= result)
        break;
      vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(*(_QWORD *)(a1 + 80) + 16), v2++, 1556);
    }
  }
  return result;
}

uint64_t _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li768EE6statusERKNSt3__112basic_stringIcNS5_11char_traitsIcEENS5_9allocatorIcEEEE(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  std::ios_base *v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  _QWORD *v22;
  _QWORD *v23;
  std::__shared_weak_count *v24;
  unint64_t *p_shared_owners;
  unint64_t v26;
  _QWORD *v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  _QWORD *v31;
  uint64_t v32;
  uint64_t v34;
  std::__shared_weak_count *v35;
  uint64_t v36;
  std::__shared_weak_count *v37;
  _QWORD v38[2];
  uint64_t v39;
  _OWORD v40[4];
  void *__p[2];
  __int128 v42;
  uint64_t v43;
  uint64_t v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;

  v53 = 0u;
  v43 = 0;
  v52 = 0u;
  v51 = 0u;
  v50 = 0u;
  v49 = 0u;
  v48 = 0u;
  v47 = 0u;
  v46 = 0u;
  v45 = 0u;
  v42 = 0u;
  *(_OWORD *)__p = 0u;
  v4 = MEMORY[0x1E0DE4FD0];
  memset(v40, 0, sizeof(v40));
  v5 = MEMORY[0x1E0DE4FD0] + 104;
  v44 = MEMORY[0x1E0DE4FD0] + 104;
  v6 = (_QWORD *)MEMORY[0x1E0DE4F50];
  v7 = MEMORY[0x1E0DE4FD0] + 64;
  v8 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 16);
  v9 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 24);
  v39 = MEMORY[0x1E0DE4FD0] + 64;
  v38[0] = v8;
  *(_QWORD *)((char *)v38 + *(_QWORD *)(v8 - 24)) = v9;
  v38[1] = 0;
  v10 = (std::ios_base *)((char *)v38 + *(_QWORD *)(v38[0] - 24));
  std::ios_base::init(v10, v40);
  v10[1].__vftable = 0;
  v10[1].__fmtflags_ = -1;
  v11 = v6[5];
  v39 = v6[4];
  *(uint64_t *)((char *)&v39 + *(_QWORD *)(v39 - 24)) = v11;
  v38[0] = v6[1];
  *(_QWORD *)((char *)v38 + *(_QWORD *)(v38[0] - 24)) = v6[6];
  v44 = v5;
  v38[0] = v4 + 24;
  v39 = v7;
  std::streambuf::basic_streambuf();
  v12 = MEMORY[0x1E0DE4FB8];
  *(_QWORD *)&v40[0] = MEMORY[0x1E0DE4FB8] + 16;
  *(_OWORD *)__p = 0u;
  v42 = 0u;
  LODWORD(v43) = 24;
  v13 = *(char *)(a2 + 23);
  if (v13 >= 0)
    v14 = a2;
  else
    v14 = *(_QWORD *)a2;
  if (v13 >= 0)
    v15 = *(unsigned __int8 *)(a2 + 23);
  else
    v15 = *(_QWORD *)(a2 + 8);
  v16 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v39, v14, v15);
  v17 = *(char *)(a1 + 47);
  if (v17 >= 0)
    v18 = a1 + 24;
  else
    v18 = *(_QWORD *)(a1 + 24);
  if (v17 >= 0)
    v19 = *(unsigned __int8 *)(a1 + 47);
  else
    v19 = *(_QWORD *)(a1 + 32);
  v20 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v16, v18, v19);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v20, (uint64_t)"(", 1);
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  v21 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v21, (uint64_t)"/", 1);
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
  v22 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v22, (uint64_t)"v", 1);
  _ZNK22IVFVectorIndexTemplateIDF16_Li768EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE13getPartitionsEv(a1 + 48, &v36);
  if (v36)
  {
    _ZNK22IVFVectorIndexTemplateIDF16_Li768EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE13getPartitionsEv(a1 + 48, &v34);
    v23 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v23, (uint64_t)")", 1);
    v24 = v35;
    if (v35)
    {
      p_shared_owners = (unint64_t *)&v35->__shared_owners_;
      do
        v26 = __ldaxr(p_shared_owners);
      while (__stlxr(v26 - 1, p_shared_owners));
      if (!v26)
      {
        ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
        std::__shared_weak_count::__release_weak(v24);
      }
    }
  }
  else
  {
    v27 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v27, (uint64_t)")", 1);
  }
  v28 = v37;
  if (v37)
  {
    v29 = (unint64_t *)&v37->__shared_owners_;
    do
      v30 = __ldaxr(v29);
    while (__stlxr(v30 - 1, v29));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v39, (uint64_t)"[", 1);
  std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v39, (uint64_t)",", 1);
  v31 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v31, (uint64_t)"] indexId: ", 11);
  std::ostream::operator<<();
  std::stringbuf::str();
  v38[0] = *v6;
  v32 = v6[9];
  *(_QWORD *)((char *)v38 + *(_QWORD *)(v38[0] - 24)) = v6[8];
  v39 = v32;
  *(_QWORD *)&v40[0] = v12 + 16;
  if (SBYTE7(v42) < 0)
    operator delete(__p[0]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1BCCB0650](&v44);
}

uint64_t _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li768EE12diagnoseDumpERKNSt3__112basic_stringIcNS5_11char_traitsIcEENS5_9allocatorIcEEEERNS5_13basic_ostreamIcS8_EEi(uint64_t a1, uint64_t a2, _QWORD *a3, int a4)
{
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  _QWORD *v16;
  const char *v17;
  uint64_t v18;
  _QWORD *v19;
  const std::locale::facet *v20;
  uint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *p_shared_owners;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  unint64_t *v28;
  unint64_t v29;
  unint64_t *v30;
  unint64_t v31;
  uint64_t v32;
  unint64_t *v33;
  unint64_t v34;
  _QWORD *v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  _QWORD *v39;
  _QWORD *v40;
  _QWORD *v41;
  _QWORD *v42;
  const std::locale::facet *v43;
  uint64_t v44;
  std::locale *v45;
  uint64_t v46;
  const std::locale::facet *v47;
  uint64_t v48;
  _QWORD *v49;
  const char *v50;
  uint64_t v51;
  const std::locale::facet *v52;
  unint64_t v53;
  std::locale::id *v54;
  const std::locale::facet *v55;
  unint64_t Ptr;
  _QWORD *v57;
  _QWORD *v58;
  _QWORD *v59;
  void *locale;
  uint64_t v61;
  void *v62;
  uint64_t v63;
  _QWORD *v64;
  unint64_t v65;
  std::locale::id *v66;
  _QWORD *v67;
  _QWORD *v68;
  const std::locale::facet *v69;
  const std::locale::facet *v70;
  uint64_t v71;
  std::__shared_weak_count *v72;
  unint64_t *v73;
  unint64_t v74;
  unint64_t *v75;
  unint64_t v76;
  uint64_t v78;
  unsigned int v79;
  uint64_t v80;
  std::__shared_weak_count *v81;
  std::locale v82;
  std::locale v83;
  uint64_t v84;
  unsigned __int8 v85;

  v7 = *(_QWORD *)(a2 + 8);
  if (*(char *)(a2 + 23) >= 0)
  {
    v8 = *(unsigned __int8 *)(a2 + 23);
  }
  else
  {
    a2 = *(_QWORD *)a2;
    v8 = v7;
  }
  v9 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, a2, v8);
  v10 = *(char *)(a1 + 47);
  if (v10 >= 0)
    v11 = a1 + 24;
  else
    v11 = *(_QWORD *)(a1 + 24);
  if (v10 >= 0)
    v12 = *(unsigned __int8 *)(a1 + 47);
  else
    v12 = *(_QWORD *)(a1 + 32);
  v13 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v9, v11, v12);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v13, (uint64_t)": ", 2);
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  v14 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v14, (uint64_t)" vectors ", 9);
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
  v15 = (_QWORD *)std::ostream::operator<<();
  v16 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v15, (uint64_t)" partitions.", 12);
  if (*(_BYTE *)(a1 + 192))
    v17 = "(readOnly)";
  else
    v17 = "(readWrite)";
  if (*(_BYTE *)(a1 + 192))
    v18 = 10;
  else
    v18 = 11;
  v19 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v16, (uint64_t)v17, v18);
  std::ios_base::getloc((const std::ios_base *)((char *)v19 + *(_QWORD *)(*v19 - 24)));
  v20 = std::locale::use_facet(&v83, MEMORY[0x1E0DE4A90]);
  ((void (*)(const std::locale::facet *, uint64_t))v20->__vftable[2].~facet_0)(v20, 10);
  std::locale::~locale(&v83);
  std::ostream::put();
  std::ostream::flush();
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 144));
  v21 = *(_QWORD *)(a1 + 112);
  v22 = *(std::__shared_weak_count **)(a1 + 120);
  if (v22)
  {
    p_shared_owners = (unint64_t *)&v22->__shared_owners_;
    do
      v24 = __ldxr(p_shared_owners);
    while (__stxr(v24 + 1, p_shared_owners));
  }
  v25 = *(std::__shared_weak_count **)(a1 + 136);
  if (v25)
  {
    v26 = (unint64_t *)&v25->__shared_owners_;
    do
      v27 = __ldxr(v26);
    while (__stxr(v27 + 1, v26));
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 144));
  if (v22)
  {
    v28 = (unint64_t *)&v22->__shared_owners_;
    do
      v29 = __ldxr(v28);
    while (__stxr(v29 + 1, v28));
  }
  if (!v25)
    goto LABEL_29;
  v30 = (unint64_t *)&v25->__shared_owners_;
  do
    v31 = __ldaxr(v30);
  while (__stlxr(v31 - 1, v30));
  if (!v31)
  {
    ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
    std::__shared_weak_count::__release_weak(v25);
    v32 = a1 + 48;
    if (!v22)
      goto LABEL_35;
  }
  else
  {
LABEL_29:
    v32 = a1 + 48;
    if (!v22)
      goto LABEL_35;
  }
  v33 = (unint64_t *)&v22->__shared_owners_;
  do
    v34 = __ldaxr(v33);
  while (__stlxr(v34 - 1, v33));
  if (!v34)
  {
    ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
    std::__shared_weak_count::__release_weak(v22);
  }
LABEL_35:
  if (v21)
  {
    v35 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, (uint64_t)"Quantizer: ", 11);
    v36 = *(char *)(v21 + 31);
    if (v36 >= 0)
      v37 = v21 + 8;
    else
      v37 = *(_QWORD *)(v21 + 8);
    if (v36 >= 0)
      v38 = *(unsigned __int8 *)(v21 + 31);
    else
      v38 = *(_QWORD *)(v21 + 16);
    v39 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v35, v37, v38);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v39, (uint64_t)"(", 1);
    (*(void (**)(uint64_t))(*(_QWORD *)v21 + 16))(v21);
    v40 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v40, (uint64_t)") ", 2);
    (*(void (**)(uint64_t))(*(_QWORD *)v21 + 24))(v21);
    v41 = (_QWORD *)std::ostream::operator<<();
    v42 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v41, (uint64_t)" centroids.", 11);
    std::ios_base::getloc((const std::ios_base *)((char *)v42 + *(_QWORD *)(*v42 - 24)));
    v43 = std::locale::use_facet(&v83, MEMORY[0x1E0DE4A90]);
    ((void (*)(const std::locale::facet *, uint64_t))v43->__vftable[2].~facet_0)(v43, 10);
    std::locale::~locale(&v83);
    std::ostream::put();
    std::ostream::flush();
  }
  v80 = 0;
  v81 = 0;
  _ZNK22IVFVectorIndexTemplateIDF16_Li768EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE13getPartitionsEv(v32, &v80);
  v44 = v80;
  if (!v80)
    goto LABEL_51;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, (uint64_t)"Partition: ", 11);
  (*(void (**)(std::locale *__return_ptr, uint64_t))(*(_QWORD *)v44 + 144))(&v83, v44);
  v45 = (v85 & 0x80u) == 0 ? &v83 : (std::locale *)v83.__locale_;
  v46 = (v85 & 0x80u) == 0 ? v85 : v84;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, (uint64_t)v45, v46);
  std::ios_base::getloc((const std::ios_base *)((char *)a3 + *(_QWORD *)(*a3 - 24)));
  v47 = std::locale::use_facet(&v82, MEMORY[0x1E0DE4A90]);
  ((void (*)(const std::locale::facet *, uint64_t))v47->__vftable[2].~facet_0)(v47, 10);
  std::locale::~locale(&v82);
  std::ostream::put();
  std::ostream::flush();
  if ((char)v85 < 0)
  {
    operator delete(v83.__locale_);
    if (!a4)
      goto LABEL_84;
  }
  else
  {
LABEL_51:
    if (!a4)
      goto LABEL_84;
  }
  v78 = v44;
  v48 = *(_QWORD *)(a1 + 80);
  v49 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, (uint64_t)"offset,vid", 10);
  v79 = a4;
  if (a4 <= 1)
    v50 = ",";
  else
    v50 = ",vector";
  if (a4 <= 1)
    v51 = 1;
  else
    v51 = 7;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v49, (uint64_t)v50, v51);
  std::ios_base::getloc((const std::ios_base *)((char *)a3 + *(_QWORD *)(*a3 - 24)));
  v52 = std::locale::use_facet(&v83, MEMORY[0x1E0DE4A90]);
  ((void (*)(const std::locale::facet *, uint64_t))v52->__vftable[2].~facet_0)(v52, 10);
  std::locale::~locale(&v83);
  std::ostream::put();
  std::ostream::flush();
  if (*(_DWORD *)(v48 + 24))
  {
    if (a4 <= 1)
    {
      v65 = 0;
      v66 = (std::locale::id *)MEMORY[0x1E0DE4A90];
      do
      {
        vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(v48 + 16), v65, 1556);
        v67 = (_QWORD *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v67, (uint64_t)",", 1);
        v68 = (_QWORD *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v68, (uint64_t)",", 1);
        std::ios_base::getloc((const std::ios_base *)((char *)a3 + *(_QWORD *)(*a3 - 24)));
        v69 = std::locale::use_facet(&v83, v66);
        ((void (*)(const std::locale::facet *, uint64_t))v69->__vftable[2].~facet_0)(v69, 10);
        std::locale::~locale(&v83);
        std::ostream::put();
        std::ostream::flush();
        ++v65;
      }
      while (v65 < *(unsigned int *)(v48 + 24));
    }
    else
    {
      v53 = 0;
      v54 = (std::locale::id *)MEMORY[0x1E0DE4A90];
      do
      {
        Ptr = vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(v48 + 16), v53, 1556);
        v57 = (_QWORD *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v57, (uint64_t)",", 1);
        v58 = (_QWORD *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v58, (uint64_t)",", 1);
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, (uint64_t)"{length = ", 10);
        v59 = (_QWORD *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v59, (uint64_t)", bytes = 0x", 12);
        data2hexString((const unsigned __int8 *)&v83, Ptr, 16);
        if ((v85 & 0x80u) == 0)
          locale = &v83;
        else
          locale = v83.__locale_;
        if ((v85 & 0x80u) == 0)
          v61 = v85;
        else
          v61 = v84;
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v59, (uint64_t)locale, v61);
        if ((char)v85 < 0)
          operator delete(v83.__locale_);
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, (uint64_t)" ... ", 5);
        data2hexString((const unsigned __int8 *)&v83, Ptr + 1528, 8);
        if ((v85 & 0x80u) == 0)
          v62 = &v83;
        else
          v62 = v83.__locale_;
        if ((v85 & 0x80u) == 0)
          v63 = v85;
        else
          v63 = v84;
        v64 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, (uint64_t)v62, v63);
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v64, (uint64_t)" }", 2);
        if ((char)v85 < 0)
          operator delete(v83.__locale_);
        std::ios_base::getloc((const std::ios_base *)((char *)a3 + *(_QWORD *)(*a3 - 24)));
        v55 = std::locale::use_facet(&v83, v54);
        ((void (*)(const std::locale::facet *, uint64_t))v55->__vftable[2].~facet_0)(v55, 10);
        std::locale::~locale(&v83);
        std::ostream::put();
        std::ostream::flush();
        ++v53;
      }
      while (v53 < *(unsigned int *)(v48 + 24));
    }
  }
  std::ios_base::getloc((const std::ios_base *)((char *)a3 + *(_QWORD *)(*a3 - 24)));
  v70 = std::locale::use_facet(&v83, MEMORY[0x1E0DE4A90]);
  ((void (*)(const std::locale::facet *, uint64_t))v70->__vftable[2].~facet_0)(v70, 10);
  std::locale::~locale(&v83);
  std::ostream::put();
  std::ostream::flush();
  if (v78)
    (*(void (**)(uint64_t, _QWORD *, _QWORD))(*(_QWORD *)v78 + 104))(v78, a3, v79);
LABEL_84:
  v71 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  v72 = v81;
  if (!v81)
    goto LABEL_88;
  v73 = (unint64_t *)&v81->__shared_owners_;
  do
    v74 = __ldaxr(v73);
  while (__stlxr(v74 - 1, v73));
  if (!v74)
  {
    ((void (*)(std::__shared_weak_count *))v72->__on_zero_shared)(v72);
    std::__shared_weak_count::__release_weak(v72);
    if (!v22)
      return v71;
  }
  else
  {
LABEL_88:
    if (!v22)
      return v71;
  }
  v75 = (unint64_t *)&v22->__shared_owners_;
  do
    v76 = __ldaxr(v75);
  while (__stlxr(v76 - 1, v75));
  if (!v76)
  {
    ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
    std::__shared_weak_count::__release_weak(v22);
  }
  return v71;
}

uint64_t ___ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li768EE16aNNProcessResultEPvU13block_pointerFvS5_fE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void _ZNK22IVFVectorIndexTemplateIDF16_Li768EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE3aNNERK10CIVector_sIDF16_Li768EEfbP20MaxSizePriorityQueueINS0_18candidate_result_sIS3_EENSt3__16vectorISB_NSC_9allocatorISB_EEEENSC_4lessISB_EEEj(uint64_t a1)
{
  uint64_t v1;
  CFIndex v2;
  CFIndex AppIntegerValue;
  char v4;
  char v5;
  float v6;
  float v7;
  unsigned __int8 *v8;
  float16x4_t *v9;
  uint64_t v10;
  _DWORD *v11;
  int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  double Current;
  unsigned int v23;
  unsigned int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  unsigned int v31;
  int v32;
  char v33;
  char v34;
  unsigned int v35;
  char v36;
  unsigned int v37;
  int v38;
  int v39;
  int v40;
  unsigned int v41;
  unsigned int v42;
  int v43;
  NSObject *v44;
  int v45;
  int v46;
  os_unfair_lock_s *v47;
  std::__shared_weak_count *v48;
  uint64_t v49;
  unint64_t *p_shared_owners;
  unint64_t v51;
  std::__shared_weak_count *v52;
  uint64_t v53;
  unint64_t *v54;
  unint64_t v55;
  int *v56;
  int *v57;
  unint64_t v58;
  int v59;
  const void *v60;
  int64_t v61;
  char *v62;
  char *v63;
  int v64;
  NSObject *v65;
  int v66;
  int v67;
  double v68;
  unsigned int v69;
  uint64_t v70;
  unint64_t v71;
  unint64_t v72;
  uint64_t v73;
  float16x4_t *v74;
  float16x8_t v75;
  float32x4_t v76;
  float32x4_t v77;
  Boolean *v78;
  uint64_t v79;
  float16x4_t *v80;
  float16x8_t v81;
  float32x4_t v82;
  float32x4_t v83;
  float32x4_t *v84;
  float v85;
  uint8x8_t v86;
  unint64_t v87;
  uint64_t *v88;
  unint64_t v89;
  unint64_t v90;
  int v92;
  NSObject *v93;
  int v94;
  NSObject *v95;
  _QWORD *v96;
  _QWORD *v97;
  void *v98;
  unint64_t v99;
  unint64_t *v100;
  unint64_t v101;
  unint64_t *v102;
  unint64_t v103;
  int v104;
  NSObject *v105;
  int v106;
  int v107;
  int v108;
  int v109;
  unint64_t v110;
  CFAbsoluteTime v111;
  _QWORD *v112;
  _QWORD *v113;
  void *v114;
  char *v115;
  char *v116;
  const char *v117;
  int v118;
  int v119;
  uint64_t v120;
  _QWORD *v121;
  _QWORD v122[8];
  void *v123;
  void *v124;
  _QWORD *v125;
  float v126;
  void *__p;
  void *v128;
  char *v129;
  void *v130[2];
  void *v131[2];
  uint64_t v132;
  uint64_t v133;
  uint64_t *v134;
  uint64_t v135;
  int v136;
  uint64_t v137;
  uint64_t *v138;
  uint64_t v139;
  int v140;
  _BYTE *__B;
  _BYTE *v142;
  uint64_t v143;
  void **__C;
  char __str[16];
  __int128 v146;
  Boolean keyExistsAndHasValidFormat[46];
  __int16 v148;
  int v149;
  __int16 v150;
  int v151;
  __int16 v152;
  unint64_t v153;
  __int16 v154;
  CFAbsoluteTime v155;
  uint64_t v156;

  v1 = MEMORY[0x1E0C80A78](a1);
  AppIntegerValue = v2;
  v5 = v4;
  v7 = v6;
  v9 = (float16x4_t *)v8;
  v10 = v1;
  v156 = *MEMORY[0x1E0C80C00];
  v121 = v11;
  v12 = *v11;
  v146 = 0u;
  *(_OWORD *)__str = 0u;
  snprintf(__str, 0x20uLL, "%02x%02x%02x%02x...%02x%02x%02x%02x", *v8, v8[1], v8[2], v8[3], v8[1532], v8[1533], v8[1534], v8[1535]);
  if (!(_DWORD)AppIntegerValue)
    AppIntegerValue = CFPreferencesGetAppIntegerValue(CFSTR("IVFNumberOfParitionsProbe"), CFSTR("com.apple.Spotlight"), 0);
  v119 = v12;
  v13 = 10 * v12;
  keyExistsAndHasValidFormat[0] = 0;
  v14 = CFPreferencesGetAppIntegerValue(CFSTR("IVFPartitionProbeMin"), CFSTR("com.apple.Spotlight"), keyExistsAndHasValidFormat);
  if (keyExistsAndHasValidFormat[0])
    v15 = v14;
  else
    v15 = 10000;
  if (v13 <= v15)
    v16 = v15;
  else
    v16 = v13;
  v17 = v16
      * IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nPartitions(v10);
  v18 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nVectors(v10);
  keyExistsAndHasValidFormat[0] = 0;
  v19 = v17 / v18;
  v20 = CFPreferencesGetAppIntegerValue(CFSTR("IVFPartitionProbeMin"), CFSTR("com.apple.Spotlight"), keyExistsAndHasValidFormat);
  if (keyExistsAndHasValidFormat[0])
    v21 = v20;
  else
    v21 = 7;
  v137 = 0;
  v138 = &v137;
  if (v19 <= v21)
    v19 = v21;
  v140 = 0;
  v139 = 0x2000000000;
  v133 = 0;
  v134 = &v133;
  v136 = 0;
  v135 = 0x2000000000;
  v132 = 0;
  *(_OWORD *)v130 = 0u;
  *(_OWORD *)v131 = 0u;
  QuantizerManager<float,768>::aNNLogQueryVecIds((uint64_t)v130);
  Current = CFAbsoluteTimeGetCurrent();
  v120 = v10;
  if ((v5 & 1) != 0
    || IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nPartitions(v10) <= v19
    || IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nVectors(v10) <= v16)
  {
    v64 = *__error();
    v65 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
    {
      v66 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nVectors(v10);
      v67 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nPartitions(v10);
      v68 = v7;
      *(_DWORD *)keyExistsAndHasValidFormat = 136316162;
      *(_QWORD *)&keyExistsAndHasValidFormat[4] = __str;
      *(_WORD *)&keyExistsAndHasValidFormat[12] = 1024;
      *(_DWORD *)&keyExistsAndHasValidFormat[14] = v119;
      *(_WORD *)&keyExistsAndHasValidFormat[18] = 1024;
      *(_DWORD *)&keyExistsAndHasValidFormat[20] = v66;
      *(_WORD *)&keyExistsAndHasValidFormat[24] = 1024;
      *(_DWORD *)&keyExistsAndHasValidFormat[26] = v67;
      *(_WORD *)&keyExistsAndHasValidFormat[30] = 2048;
      *(double *)&keyExistsAndHasValidFormat[32] = v7;
      _os_log_impl(&dword_1B8270000, v65, OS_LOG_TYPE_DEFAULT, "brute force search %s top %u of %u vectors in %u partitions max_distance=%f", keyExistsAndHasValidFormat, 0x28u);
    }
    else
    {
      v68 = v7;
    }
    *__error() = v64;
    v118 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nPartitions(v10);
    v69 = 0;
    v70 = *(_QWORD *)(v10 + 32);
    do
    {
      if (v69 == *(_DWORD *)(v70 + 24))
        goto LABEL_121;
      ++*((_DWORD *)v138 + 6);
      v71 = _ZNK22IVFVectorIndexTemplateIDF16_Li768EE11VectorStoreI32vi_onefixedsize_memory_allocator18vi_memory_postingsE8IteratordeEv(v70, v69);
      v72 = *(unsigned int *)(v71 + 1552);
      bzero(keyExistsAndHasValidFormat, 0xC00uLL);
      v73 = 0;
      v74 = v9 + 2;
      do
      {
        v75 = *(float16x8_t *)v74[-2].i8;
        v76 = vcvtq_f32_f16(*v74);
        v77 = vcvt_hight_f32_f16(*(float16x8_t *)v74->i8);
        v78 = &keyExistsAndHasValidFormat[v73];
        *(float32x4_t *)v78 = vcvtq_f32_f16(*(float16x4_t *)v75.i8);
        *((float32x4_t *)v78 + 1) = vcvt_hight_f32_f16(v75);
        *((float32x4_t *)v78 + 2) = v76;
        *((float32x4_t *)v78 + 3) = v77;
        v73 += 64;
        v74 += 4;
      }
      while (v73 != 3072);
      bzero(&__B, 0xC00uLL);
      v79 = 0;
      v80 = (float16x4_t *)(v71 + 16);
      do
      {
        v81 = *(float16x8_t *)v80[-2].i8;
        v82 = vcvtq_f32_f16(*v80);
        v83 = vcvt_hight_f32_f16(*(float16x8_t *)v80->i8);
        v84 = (float32x4_t *)&(&__B)[v79];
        *v84 = vcvtq_f32_f16(*(float16x4_t *)v81.i8);
        v84[1] = vcvt_hight_f32_f16(v81);
        v84[2] = v82;
        v84[3] = v83;
        v79 += 8;
        v80 += 4;
      }
      while (v79 != 384);
      LODWORD(__C) = 2139095039;
      vDSP_distancesq((const float *)keyExistsAndHasValidFormat, 1, (const float *)&__B, 1, (float *)&__C, 0x300uLL);
      v85 = *(float *)&__C;
      if (v130[1])
      {
        v86 = (uint8x8_t)vcnt_s8((int8x8_t)v130[1]);
        v86.i16[0] = vaddlv_u8(v86);
        if (v86.u32[0] > 1uLL)
        {
          v87 = v72;
          if (v130[1] <= (void *)v72)
            v87 = v72 % (unint64_t)v130[1];
        }
        else
        {
          v87 = (LODWORD(v130[1]) - 1) & v72;
        }
        v88 = (uint64_t *)*((_QWORD *)v130[0] + v87);
        if (v88)
        {
          v88 = (uint64_t *)*v88;
          if (v88)
          {
            if (v86.u32[0] < 2uLL)
            {
              while (1)
              {
                v90 = v88[1];
                if (v90 == v72)
                {
                  if (*((_DWORD *)v88 + 4) == (_DWORD)v72)
                    goto LABEL_87;
                }
                else if ((v90 & ((unint64_t)v130[1] - 1)) != v87)
                {
                  goto LABEL_86;
                }
                v88 = (uint64_t *)*v88;
                if (!v88)
                  goto LABEL_87;
              }
            }
            do
            {
              v89 = v88[1];
              if (v89 == v72)
              {
                if (*((_DWORD *)v88 + 4) == (_DWORD)v72)
                  break;
              }
              else
              {
                if ((void *)v89 >= v130[1])
                  v89 %= (unint64_t)v130[1];
                if (v89 != v87)
                  goto LABEL_86;
              }
              v88 = (uint64_t *)*v88;
            }
            while (v88);
          }
        }
      }
      else
      {
LABEL_86:
        v88 = 0;
      }
LABEL_87:
      if (v7 == 0.0 || *(float *)&__C <= v7)
      {
        if (v88)
        {
          v92 = *__error();
          v93 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v93, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)keyExistsAndHasValidFormat = 67109376;
            *(_DWORD *)&keyExistsAndHasValidFormat[4] = v72;
            *(_WORD *)&keyExistsAndHasValidFormat[8] = 2048;
            *(double *)&keyExistsAndHasValidFormat[10] = v85;
            _os_log_impl(&dword_1B8270000, v93, OS_LOG_TYPE_DEFAULT, "Include vec_id: %u distance %f", keyExistsAndHasValidFormat, 0x12u);
          }
          *__error() = v92;
          v10 = v120;
        }
        *(_OWORD *)keyExistsAndHasValidFormat = *(_OWORD *)(v71 + 1536);
        *(_DWORD *)&keyExistsAndHasValidFormat[16] = v72;
        *(float *)&keyExistsAndHasValidFormat[20] = v85;
        MaxSizePriorityQueue<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_memory_postings>,std::vector<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_memory_postings>,std::allocator<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_memory_postings>>>,std::less<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_memory_postings>>>::push(v121, (__int128 *)keyExistsAndHasValidFormat);
      }
      else
      {
        if (v88)
        {
          v94 = *__error();
          v95 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v95, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)keyExistsAndHasValidFormat = 67109632;
            *(_DWORD *)&keyExistsAndHasValidFormat[4] = v72;
            *(_WORD *)&keyExistsAndHasValidFormat[8] = 2048;
            *(double *)&keyExistsAndHasValidFormat[10] = v85;
            *(_WORD *)&keyExistsAndHasValidFormat[18] = 2048;
            *(double *)&keyExistsAndHasValidFormat[20] = v68;
            _os_log_impl(&dword_1B8270000, v95, OS_LOG_TYPE_DEFAULT, "Skip vec_id: %u distance %f > %f", keyExistsAndHasValidFormat, 0x1Cu);
          }
          *__error() = v94;
        }
        ++*((_DWORD *)v134 + 6);
      }
      ++v69;
    }
    while (v70 == *(_QWORD *)(v10 + 32));
    v115 = __si_assert_copy_extra_268();
    v116 = v115;
    v117 = "";
    if (v115)
      v117 = v115;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1814, "store == other.store", v117);
    free(v116);
    if (!__valid_fs(-1))
    {
      MEMORY[0xC00] = -559038737;
      abort();
    }
    MEMORY[0xBAD] = -559038737;
    goto LABEL_132;
  }
  if (!(_DWORD)AppIntegerValue)
  {
    keyExistsAndHasValidFormat[0] = 0;
    v23 = CFPreferencesGetAppIntegerValue(CFSTR("IVFPartitionProbeMax"), CFSTR("com.apple.Spotlight"), keyExistsAndHasValidFormat);
    if (keyExistsAndHasValidFormat[0])
      v24 = v23;
    else
      v24 = 40;
    keyExistsAndHasValidFormat[0] = 0;
    v25 = CFPreferencesGetAppIntegerValue(CFSTR("IVFPartitionSizeFactor"), CFSTR("com.apple.Spotlight"), keyExistsAndHasValidFormat);
    if (keyExistsAndHasValidFormat[0])
      v26 = v25;
    else
      v26 = 45;
    keyExistsAndHasValidFormat[0] = 0;
    v27 = CFPreferencesGetAppIntegerValue(CFSTR("IVFPartitionProbeNumerator"), CFSTR("com.apple.Spotlight"), keyExistsAndHasValidFormat);
    v28 = keyExistsAndHasValidFormat[0];
    v29 = 8 * v27;
    v30 = v26 * v26;
    keyExistsAndHasValidFormat[0] = 0;
    v31 = CFPreferencesGetAppIntegerValue(CFSTR("IVFpartitionProbeDecayExponent"), CFSTR("com.apple.Spotlight"), keyExistsAndHasValidFormat);
    v32 = keyExistsAndHasValidFormat[0];
    if (v31 <= 0x12)
      v33 = 18;
    else
      v33 = v31;
    v34 = v33 - 3;
    v35 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nVectors(v120);
    if (v32)
      v36 = v34;
    else
      v36 = 17;
    v37 = v35 >> v36;
    if (v37 <= 8)
      v38 = 8;
    else
      v38 = v37;
    v39 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nPartitions(v120);
    if (v28)
      v40 = v29;
    else
      v40 = 800;
    v41 = v30 * v38;
    v10 = v120;
    v42 = v40 * v39 / v41;
    if (v24 < v42)
      v42 = v24;
    if (v42 <= v19)
      AppIntegerValue = v19;
    else
      AppIntegerValue = v42;
  }
  v43 = *__error();
  v44 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
  {
    v45 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nVectors(v10);
    v46 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nPartitions(v10);
    *(_DWORD *)keyExistsAndHasValidFormat = 136316418;
    *(_QWORD *)&keyExistsAndHasValidFormat[4] = __str;
    *(_WORD *)&keyExistsAndHasValidFormat[12] = 1024;
    *(_DWORD *)&keyExistsAndHasValidFormat[14] = v119;
    *(_WORD *)&keyExistsAndHasValidFormat[18] = 1024;
    *(_DWORD *)&keyExistsAndHasValidFormat[20] = v45;
    *(_WORD *)&keyExistsAndHasValidFormat[24] = 1024;
    *(_DWORD *)&keyExistsAndHasValidFormat[26] = AppIntegerValue;
    *(_WORD *)&keyExistsAndHasValidFormat[30] = 1024;
    *(_DWORD *)&keyExistsAndHasValidFormat[32] = v46;
    *(_WORD *)&keyExistsAndHasValidFormat[36] = 2048;
    *(double *)&keyExistsAndHasValidFormat[38] = v7;
    _os_log_impl(&dword_1B8270000, v44, OS_LOG_TYPE_DEFAULT, "aNN search %s top %u of %u vectors in %u of %u partitions max_distance=%f", keyExistsAndHasValidFormat, 0x2Eu);
  }
  *__error() = v43;
  v47 = (os_unfair_lock_s *)(v10 + 136);
  os_unfair_lock_lock((os_unfair_lock_t)(v10 + 136));
  os_unfair_lock_lock((os_unfair_lock_t)(v10 + 96));
  v49 = *(_QWORD *)(v10 + 64);
  v48 = *(std::__shared_weak_count **)(v10 + 72);
  if (v48)
  {
    p_shared_owners = (unint64_t *)&v48->__shared_owners_;
    do
      v51 = __ldxr(p_shared_owners);
    while (__stxr(v51 + 1, p_shared_owners));
  }
  v53 = *(_QWORD *)(v10 + 80);
  v52 = *(std::__shared_weak_count **)(v10 + 88);
  if (v52)
  {
    v54 = (unint64_t *)&v52->__shared_owners_;
    do
      v55 = __ldxr(v54);
    while (__stxr(v55 + 1, v54));
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(v10 + 96));
  memset(keyExistsAndHasValidFormat, 0, 24);
  (*(void (**)(Boolean *__return_ptr, uint64_t, float16x4_t *, CFIndex))(*(_QWORD *)v49 + 72))(keyExistsAndHasValidFormat, v49, v9, AppIntegerValue);
  v56 = *(int **)&keyExistsAndHasValidFormat[8];
  v57 = *(int **)keyExistsAndHasValidFormat;
  __B = 0;
  v142 = 0;
  v143 = 0;
  __C = (void **)&__B;
  v58 = *(_QWORD *)&keyExistsAndHasValidFormat[8] - *(_QWORD *)keyExistsAndHasValidFormat;
  if (*(_QWORD *)&keyExistsAndHasValidFormat[8] == *(_QWORD *)keyExistsAndHasValidFormat)
  {
    v128 = 0;
    v129 = 0;
    __p = 0;
    goto LABEL_101;
  }
  do
  {
    v59 = *v57;
    v57 += 2;
    std::back_insert_iterator<std::vector<unsigned int>>::operator=[abi:nn180100]((uint64_t *)&__C, v59);
  }
  while (v57 != v56);
  v60 = __B;
  v128 = 0;
  v129 = 0;
  __p = 0;
  v61 = v142 - __B;
  if (v142 == __B)
    goto LABEL_101;
  if (v61 < 0)
LABEL_132:
    abort();
  v62 = (char *)operator new(v142 - __B);
  v63 = &v62[4 * (v61 >> 2)];
  __p = v62;
  v129 = v63;
  memcpy(v62, v60, v61);
  v128 = v63;
LABEL_101:
  v122[0] = MEMORY[0x1E0C809B0];
  v122[1] = 1174405120;
  v122[2] = ___ZNK22IVFVectorIndexTemplateIDF16_Li768EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE3aNNERK10CIVector_sIDF16_Li768EEfbP20MaxSizePriorityQueueINS0_18candidate_result_sIS3_EENSt3__16vectorISB_NSC_9allocatorISB_EEEENSC_4lessISB_EEEj_block_invoke;
  v122[3] = &unk_1E6E32198;
  v122[6] = v120;
  v122[7] = v9;
  v122[4] = &v137;
  std::unordered_set<unsigned int>::unordered_set((uint64_t)&v123, (uint64_t)v130);
  v126 = v7;
  v122[5] = &v133;
  v125 = v121;
  (*(void (**)(uint64_t, void **, _QWORD *))(*(_QWORD *)v53 + 72))(v53, &__p, v122);
  if (__p)
  {
    v128 = __p;
    operator delete(__p);
  }
  os_unfair_lock_unlock(v47);
  v96 = v124;
  if (v124)
  {
    do
    {
      v97 = (_QWORD *)*v96;
      operator delete(v96);
      v96 = v97;
    }
    while (v97);
  }
  v98 = v123;
  v123 = 0;
  if (v98)
    operator delete(v98);
  if (__B)
  {
    v142 = __B;
    operator delete(__B);
  }
  if (*(_QWORD *)keyExistsAndHasValidFormat)
  {
    *(_QWORD *)&keyExistsAndHasValidFormat[8] = *(_QWORD *)keyExistsAndHasValidFormat;
    operator delete(*(void **)keyExistsAndHasValidFormat);
  }
  v99 = v58 >> 3;
  v10 = v120;
  if (v52)
  {
    v100 = (unint64_t *)&v52->__shared_owners_;
    do
      v101 = __ldaxr(v100);
    while (__stlxr(v101 - 1, v100));
    if (!v101)
    {
      ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
      std::__shared_weak_count::__release_weak(v52);
    }
  }
  v118 = v99;
  if (v48)
  {
    v102 = (unint64_t *)&v48->__shared_owners_;
    do
      v103 = __ldaxr(v102);
    while (__stlxr(v103 - 1, v102));
    if (!v103)
    {
      ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
      std::__shared_weak_count::__release_weak(v48);
    }
  }
LABEL_121:
  v104 = *__error();
  v105 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v105, OS_LOG_TYPE_DEFAULT))
  {
    v106 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nVectors(v10);
    v107 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nPartitions(v10);
    v108 = *((_DWORD *)v134 + 6);
    v109 = *((_DWORD *)v138 + 6);
    v110 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v121[2] - v121[1]) >> 3);
    v111 = CFAbsoluteTimeGetCurrent();
    *(_DWORD *)keyExistsAndHasValidFormat = 136317442;
    *(_QWORD *)&keyExistsAndHasValidFormat[4] = __str;
    *(_WORD *)&keyExistsAndHasValidFormat[12] = 1024;
    *(_DWORD *)&keyExistsAndHasValidFormat[14] = v119;
    *(_WORD *)&keyExistsAndHasValidFormat[18] = 1024;
    *(_DWORD *)&keyExistsAndHasValidFormat[20] = v106;
    *(_WORD *)&keyExistsAndHasValidFormat[24] = 2048;
    *(double *)&keyExistsAndHasValidFormat[26] = v7;
    *(_WORD *)&keyExistsAndHasValidFormat[34] = 1024;
    *(_DWORD *)&keyExistsAndHasValidFormat[36] = v118;
    *(_WORD *)&keyExistsAndHasValidFormat[40] = 1024;
    *(_DWORD *)&keyExistsAndHasValidFormat[42] = v107;
    v148 = 1024;
    v149 = v108;
    v150 = 1024;
    v151 = v109;
    v152 = 2048;
    v153 = v110;
    v154 = 2048;
    v155 = v111 - Current;
    _os_log_impl(&dword_1B8270000, v105, OS_LOG_TYPE_DEFAULT, "search %s top %u of %u vectors max_distance=%f in %u of %u partitions skip %u of %u populate %zu results in duration: %f", keyExistsAndHasValidFormat, 0x4Eu);
  }
  *__error() = v104;
  v112 = v131[0];
  if (v131[0])
  {
    do
    {
      v113 = (_QWORD *)*v112;
      operator delete(v112);
      v112 = v113;
    }
    while (v113);
  }
  v114 = v130[0];
  v130[0] = 0;
  if (v114)
    operator delete(v114);
  _Block_object_dispose(&v133, 8);
  _Block_object_dispose(&v137, 8);
}

unint64_t _ZNK22IVFVectorIndexTemplateIDF16_Li768EE11VectorStoreI32vi_onefixedsize_memory_allocator18vi_memory_postingsE8IteratordeEv(uint64_t a1, unsigned int a2)
{
  char *v3;
  char *v4;
  const char *v5;

  if (*(_DWORD *)(a1 + 24) <= a2)
  {
    v3 = __si_assert_copy_extra_268();
    v4 = v3;
    v5 = "";
    if (v3)
      v5 = v3;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1798, "offset < store->endOffset()", v5);
    free(v4);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  return vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(a1 + 16), a2, 1556);
}

void ___ZNK22IVFVectorIndexTemplateIDF16_Li768EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE3aNNERK10CIVector_sIDF16_Li768EEfbP20MaxSizePriorityQueueINS0_18candidate_result_sIS3_EENSt3__16vectorISB_NSC_9allocatorISB_EEEENSC_4lessISB_EEEj_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  unsigned int *v3;
  unint64_t Ptr;
  float16x4_t *v5;
  uint64_t v6;
  float16x4_t *v7;
  float16x8_t v8;
  float32x4_t v9;
  float32x4_t v10;
  float32x4_t *v11;
  uint64_t v12;
  float16x4_t *v13;
  float16x8_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float *v17;
  float v18;
  unint64_t v19;
  int8x8_t v20;
  uint8x8_t v21;
  unint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  float v27;
  int v29;
  NSObject *v30;
  int v31;
  NSObject *v32;
  double v33;
  float __B[768];
  float __C;
  _BYTE __A[20];
  double v37;
  uint64_t v38;

  v1 = MEMORY[0x1E0C80A78](a1);
  v38 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(v1 + 48);
  ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v1 + 32) + 8) + 24);
  Ptr = vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(*(_QWORD *)(v2 + 32) + 16), *v3, 1556);
  v5 = *(float16x4_t **)(v1 + 56);
  bzero(__A, 0xC00uLL);
  v6 = 0;
  v7 = v5 + 2;
  do
  {
    v8 = *(float16x8_t *)v7[-2].i8;
    v9 = vcvtq_f32_f16(*v7);
    v10 = vcvt_hight_f32_f16(*(float16x8_t *)v7->i8);
    v11 = (float32x4_t *)&__A[v6];
    *v11 = vcvtq_f32_f16(*(float16x4_t *)v8.i8);
    v11[1] = vcvt_hight_f32_f16(v8);
    v11[2] = v9;
    v11[3] = v10;
    v6 += 64;
    v7 += 4;
  }
  while (v6 != 3072);
  bzero(__B, 0xC00uLL);
  v12 = 0;
  v13 = (float16x4_t *)(Ptr + 16);
  do
  {
    v14 = *(float16x8_t *)v13[-2].i8;
    v15 = vcvtq_f32_f16(*v13);
    v16 = vcvt_hight_f32_f16(*(float16x8_t *)v13->i8);
    v17 = &__B[v12];
    *(float32x4_t *)v17 = vcvtq_f32_f16(*(float16x4_t *)v14.i8);
    *((float32x4_t *)v17 + 1) = vcvt_hight_f32_f16(v14);
    *((float32x4_t *)v17 + 2) = v15;
    *((float32x4_t *)v17 + 3) = v16;
    v12 += 16;
    v13 += 4;
  }
  while (v12 != 768);
  __C = 3.4028e38;
  vDSP_distancesq((const float *)__A, 1, __B, 1, &__C, 0x300uLL);
  v18 = __C;
  v19 = *(unsigned int *)(Ptr + 1552);
  v20 = *(int8x8_t *)(v1 + 72);
  if (v20)
  {
    v21 = (uint8x8_t)vcnt_s8(v20);
    v21.i16[0] = vaddlv_u8(v21);
    if (v21.u32[0] > 1uLL)
    {
      v22 = *(unsigned int *)(Ptr + 1552);
      if (*(_QWORD *)&v20 <= v19)
        v22 = v19 % *(_QWORD *)&v20;
    }
    else
    {
      v22 = (v20.i32[0] - 1) & v19;
    }
    v23 = *(uint64_t **)(*(_QWORD *)(v1 + 64) + 8 * v22);
    if (v23)
    {
      v23 = (uint64_t *)*v23;
      if (v23)
      {
        if (v21.u32[0] < 2uLL)
        {
          v24 = *(_QWORD *)&v20 - 1;
          while (1)
          {
            v26 = v23[1];
            if (v26 == v19)
            {
              if (*((_DWORD *)v23 + 4) == (_DWORD)v19)
                goto LABEL_26;
            }
            else if ((v26 & v24) != v22)
            {
              goto LABEL_25;
            }
            v23 = (uint64_t *)*v23;
            if (!v23)
              goto LABEL_26;
          }
        }
        do
        {
          v25 = v23[1];
          if (v25 == v19)
          {
            if (*((_DWORD *)v23 + 4) == (_DWORD)v19)
              break;
          }
          else
          {
            if (v25 >= *(_QWORD *)&v20)
              v25 %= *(_QWORD *)&v20;
            if (v25 != v22)
              goto LABEL_25;
          }
          v23 = (uint64_t *)*v23;
        }
        while (v23);
      }
    }
  }
  else
  {
LABEL_25:
    v23 = 0;
  }
LABEL_26:
  v27 = *(float *)(v1 + 112);
  if (v27 == 0.0 || __C <= v27)
  {
    if (v23)
    {
      v29 = *__error();
      v30 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__A = 67109376;
        *(_DWORD *)&__A[4] = v19;
        *(_WORD *)&__A[8] = 2048;
        *(double *)&__A[10] = v18;
        _os_log_impl(&dword_1B8270000, v30, OS_LOG_TYPE_DEFAULT, "Include vec_id: %u distance %f", __A, 0x12u);
      }
      *__error() = v29;
    }
    *(_OWORD *)__A = *(_OWORD *)(Ptr + 1536);
    *(_DWORD *)&__A[16] = v19;
    *(float *)&v37 = v18;
    MaxSizePriorityQueue<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_memory_postings>,std::vector<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_memory_postings>,std::allocator<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_memory_postings>>>,std::less<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_memory_postings>>>::push(*(_QWORD **)(v1 + 104), (__int128 *)__A);
  }
  else
  {
    if (v23)
    {
      v31 = *__error();
      v32 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
      {
        v33 = *(float *)(v1 + 112);
        *(_DWORD *)__A = 67109632;
        *(_DWORD *)&__A[4] = v19;
        *(_WORD *)&__A[8] = 2048;
        *(double *)&__A[10] = v18;
        *(_WORD *)&__A[18] = 2048;
        v37 = v33;
        _os_log_impl(&dword_1B8270000, v32, OS_LOG_TYPE_DEFAULT, "Skip vec_id: %u distance %f > %f", __A, 0x1Cu);
      }
      *__error() = v31;
    }
    ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v1 + 40) + 8) + 24);
  }
}

uint64_t ___ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li768EE3aNNEjtPKv14vec_dimensions15vec_data_formatfjbU13block_pointerFvPvfE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

_DWORD *_ZN22IVFVectorIndexTemplateIDF16_Li768EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE15lookupForInsertEjRK10CIVector_sIDF16_Li768EEjfb(uint64_t a1, unsigned int a2, const void *a3, unsigned int a4, float a5)
{
  unsigned int v8;
  uint64_t v9;
  _DWORD *Ptr;
  const UInt8 *data;
  int v12;
  NSObject *v13;
  int v14;
  NSObject *v15;
  int v16;
  NSObject *v17;
  _BYTE *v18;
  int v19;
  NSObject *v20;
  _BYTE *v21;
  const void *v22;
  std::__shared_weak_count *v23;
  unint64_t *p_shared_owners;
  unint64_t v25;
  std::__shared_weak_count *v26;
  _DWORD *v27;
  unint64_t *v28;
  unint64_t v29;
  uint64_t v30;
  size_t OffsetFromEnd;
  uint64_t v32;
  int v33;
  NSObject *v34;
  _OWORD *v35;
  uint64_t v36;
  unint64_t *v37;
  unint64_t v38;
  unint64_t *v39;
  unint64_t v40;
  NSObject *v41;
  const UInt8 *v42;
  int v43;
  NSObject *v44;
  size_t v45;
  int v46;
  NSObject *v47;
  int v48;
  NSObject *v49;
  _BYTE *v50;
  int v51;
  NSObject *v52;
  _BYTE *v53;
  NSObject *v54;
  int v55;
  NSObject *v56;
  int v58;
  int v59;
  int v60;
  char *v61;
  char *v62;
  const char *v63;
  char *v64;
  char *v65;
  const char *v66;
  char *v67;
  const char *v68;
  char *v69;
  const char *v70;
  char *v71;
  const char *v72;
  uint64_t v73;
  char *v74;
  const char *v75;
  char *v76;
  const char *v77;
  unsigned int v78;
  uint64_t v79;
  float v80;
  unsigned int v81;
  uint8_t buf[4];
  _BYTE *v83;
  _BYTE __p[12];
  __int16 v85;
  int v86;
  __int16 v87;
  _BYTE v88[14];
  __int16 v89;
  uint64_t v90;
  uint64_t v91;

  v91 = *MEMORY[0x1E0C80C00];
  v81 = a4;
  v80 = a5;
  if (*(_BYTE *)(a1 + 144))
  {
    v61 = __si_assert_copy_extra_268();
    v62 = v61;
    v63 = "";
    if (v61)
      v63 = v61;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2430, "!readOnly", v63);
    goto LABEL_104;
  }
  v8 = _ZN22IVFVectorIndexTemplateIDF16_Li768EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE10findVectorERK10CIVector_sIDF16_Li768EERjRfj(a1, (uint64_t)a3, (int *)&v81, &v80, a2);
  v9 = v81;
  if (v81 == -1)
  {
    v64 = __si_assert_copy_extra_268();
    v65 = v64;
    v66 = "";
    if (v64)
      v66 = v64;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2435, "partID != VECTOR_NOT_FOUND", v66);
    goto LABEL_94;
  }
  if (v8 != -1)
  {
    Ptr = (_DWORD *)vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(*(_QWORD *)(a1 + 32) + 16), v8, 1556);
    if (Ptr[388] == a2)
      return Ptr;
    v79 = 0;
    data = data_map_get_data(*(_QWORD *)(a1 + 128), a2, &v79);
    v12 = *__error();
    v13 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__p = 136316162;
      *(_QWORD *)&__p[4] = "lookupForInsert";
      v85 = 1024;
      v86 = 2463;
      v87 = 1024;
      *(_DWORD *)v88 = a2;
      *(_WORD *)&v88[4] = 2048;
      *(_QWORD *)&v88[6] = data;
      v89 = 2048;
      v90 = v79;
      _os_log_error_impl(&dword_1B8270000, v13, OS_LOG_TYPE_ERROR, "%s:%d: vectorId=%u in datamap: %p size=%zd", __p, 0x2Cu);
    }
    *__error() = v12;
    if (v79 < 1)
    {
      v19 = *__error();
      v41 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__p = 136315394;
        *(_QWORD *)&__p[4] = "lookupForInsert";
        v85 = 1024;
        v86 = 2472;
        _os_log_error_impl(&dword_1B8270000, v41, OS_LOG_TYPE_ERROR, "%s:%d: vectorId is invalid", __p, 0x12u);
      }
    }
    else
    {
      if (v79 != 1536)
      {
        v74 = __si_assert_copy_extra_268();
        v62 = v74;
        v75 = "";
        if (v74)
          v75 = v74;
        __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2465, "size == D * sizeof(ELEM_TYPE)", v75);
        goto LABEL_104;
      }
      if (!data || !memcmp(data, a3, 0x600uLL))
        goto LABEL_51;
      v14 = *__error();
      v15 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__p = 136315394;
        *(_QWORD *)&__p[4] = "lookupForInsert";
        v85 = 1024;
        v86 = 2467;
        _os_log_error_impl(&dword_1B8270000, v15, OS_LOG_TYPE_ERROR, "%s:%d: vector in datamap is not same as vector passed in", __p, 0x12u);
      }
      *__error() = v14;
      v16 = *__error();
      v17 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        data2hexString(__p, (uint64_t)data, v79);
        v18 = v88[3] >= 0 ? __p : *(_BYTE **)__p;
        *(_DWORD *)buf = 136315138;
        v83 = v18;
        _os_log_impl(&dword_1B8270000, v17, OS_LOG_TYPE_DEFAULT, "vector in datamap: %s", buf, 0xCu);
        if ((v88[3] & 0x80000000) != 0)
          operator delete(*(void **)__p);
      }
      *__error() = v16;
      v19 = *__error();
      v20 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        data2hexString(__p, (uint64_t)a3, v79);
        v21 = v88[3] >= 0 ? __p : *(_BYTE **)__p;
        *(_DWORD *)buf = 136315138;
        v83 = v21;
        _os_log_impl(&dword_1B8270000, v20, OS_LOG_TYPE_DEFAULT, "vector passed in: %s", buf, 0xCu);
        if ((v88[3] & 0x80000000) != 0)
          operator delete(*(void **)__p);
      }
    }
    *__error() = v19;
LABEL_51:
    v42 = data_map_get_data(*(_QWORD *)(a1 + 128), Ptr[388], &v79);
    v43 = *__error();
    v44 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
    {
      v58 = Ptr[388];
      *(_DWORD *)__p = 136316162;
      *(_QWORD *)&__p[4] = "lookupForInsert";
      v85 = 1024;
      v86 = 2475;
      v87 = 1024;
      *(_DWORD *)v88 = v58;
      *(_WORD *)&v88[4] = 2048;
      *(_QWORD *)&v88[6] = v42;
      v89 = 2048;
      v90 = v79;
      _os_log_error_impl(&dword_1B8270000, v44, OS_LOG_TYPE_ERROR, "%s:%d: old vectorId=%u in datamap: %p size=%zd", __p, 0x2Cu);
    }
    *__error() = v43;
    if (v79 < 1)
    {
      v51 = *__error();
      v54 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__p = 136315394;
        *(_QWORD *)&__p[4] = "lookupForInsert";
        v85 = 1024;
        v86 = 2484;
        _os_log_error_impl(&dword_1B8270000, v54, OS_LOG_TYPE_ERROR, "%s:%d: old vectorId is invalid", __p, 0x12u);
      }
      goto LABEL_73;
    }
    if (v79 == 1536)
    {
      v45 = 1536;
      if (!v42 || !memcmp(v42, Ptr, 0x600uLL))
        goto LABEL_74;
      v46 = *__error();
      v47 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__p = 136315394;
        *(_QWORD *)&__p[4] = "lookupForInsert";
        v85 = 1024;
        v86 = 2479;
        _os_log_error_impl(&dword_1B8270000, v47, OS_LOG_TYPE_ERROR, "%s:%d: vector in datamap is not same as vector passed in", __p, 0x12u);
      }
      *__error() = v46;
      v48 = *__error();
      v49 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
      {
        data2hexString(__p, (uint64_t)v42, v79);
        v50 = v88[3] >= 0 ? __p : *(_BYTE **)__p;
        *(_DWORD *)buf = 136315138;
        v83 = v50;
        _os_log_impl(&dword_1B8270000, v49, OS_LOG_TYPE_DEFAULT, "vector in datamap: %s", buf, 0xCu);
        if ((v88[3] & 0x80000000) != 0)
          operator delete(*(void **)__p);
      }
      *__error() = v48;
      v51 = *__error();
      v52 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
      {
        data2hexString(__p, (uint64_t)Ptr, v79);
        v53 = v88[3] >= 0 ? __p : *(_BYTE **)__p;
        *(_DWORD *)buf = 136315138;
        v83 = v53;
        _os_log_impl(&dword_1B8270000, v52, OS_LOG_TYPE_DEFAULT, "vector in vector store: %s", buf, 0xCu);
        if ((v88[3] & 0x80000000) != 0)
          operator delete(*(void **)__p);
      }
LABEL_73:
      *__error() = v51;
      v45 = v79;
LABEL_74:
      if (!memcmp(a3, Ptr, v45))
      {
        v55 = *__error();
        v56 = _SILogForLogForCategory(16);
        if (os_log_type_enabled(v56, OS_LOG_TYPE_FAULT))
        {
          v59 = Ptr[388];
          *(_DWORD *)__p = 136315906;
          *(_QWORD *)&__p[4] = "lookupForInsert";
          v85 = 1024;
          v86 = 2487;
          v87 = 1024;
          *(_DWORD *)v88 = a2;
          *(_WORD *)&v88[4] = 1024;
          *(_DWORD *)&v88[6] = v59;
          _os_log_fault_impl(&dword_1B8270000, v56, OS_LOG_TYPE_FAULT, "%s:%d: Dup vector with new vectorId=%u old=%u", __p, 0x1Eu);
        }
        *__error() = v55;
        return Ptr;
      }
      v71 = __si_assert_copy_extra_268();
      v65 = v71;
      v72 = "";
      if (v71)
        v72 = v71;
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2486, "memcmp(vec.vec, entry->vec.vec, size) == 0", v72);
LABEL_94:
      free(v65);
      if (__valid_fs(-1))
        v73 = 2989;
      else
        v73 = 3072;
      *(_DWORD *)v73 = -559038737;
      abort();
    }
    v76 = __si_assert_copy_extra_268();
    v62 = v76;
    v77 = "";
    if (v76)
      v77 = v76;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2477, "size == D * sizeof(ELEM_TYPE)", v77);
LABEL_104:
    free(v62);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v78 = a2;
  v22 = a3;
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  v23 = *(std::__shared_weak_count **)(a1 + 72);
  if (v23)
  {
    p_shared_owners = (unint64_t *)&v23->__shared_owners_;
    do
      v25 = __ldxr(p_shared_owners);
    while (__stxr(v25 + 1, p_shared_owners));
  }
  v27 = *(_DWORD **)(a1 + 80);
  v26 = *(std::__shared_weak_count **)(a1 + 88);
  if (v26)
  {
    v28 = (unint64_t *)&v26->__shared_owners_;
    do
      v29 = __ldxr(v28);
    while (__stxr(v29 + 1, v28));
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
  v30 = *(_QWORD *)(a1 + 32);
  OffsetFromEnd = vi_onefixedsize_memory_allocator::allocateOffsetFromEnd(*(_QWORD *)(v30 + 16), 0x614u);
  v32 = *(unsigned int *)(v30 + 24);
  if (OffsetFromEnd != v32)
  {
    v33 = *__error();
    v34 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
    {
      v60 = *(_DWORD *)(v30 + 24);
      *(_DWORD *)__p = 136315906;
      *(_QWORD *)&__p[4] = "newEntry";
      v85 = 1024;
      v86 = 1779;
      v87 = 2048;
      *(_QWORD *)v88 = OffsetFromEnd;
      *(_WORD *)&v88[8] = 1024;
      *(_DWORD *)&v88[10] = v60;
      _os_log_error_impl(&dword_1B8270000, v34, OS_LOG_TYPE_ERROR, "%s:%d: offset: %llu, nVectors: %u", __p, 0x22u);
    }
    *__error() = v33;
    v32 = *(unsigned int *)(v30 + 24);
    if (OffsetFromEnd != v32)
    {
      v69 = __si_assert_copy_extra_268();
      v62 = v69;
      v70 = "";
      if (v69)
        v70 = v69;
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1782, "offset == nVectors", v70);
      goto LABEL_104;
    }
  }
  *(_DWORD *)(v30 + 24) = v32 + 1;
  v35 = (_OWORD *)vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(v30 + 16), OffsetFromEnd, 1556);
  memcpy(v35, v22, 0x600uLL);
  v35[96] = 0u;
  (*(void (**)(_DWORD *, uint64_t, size_t, float))(*(_QWORD *)v27 + 56))(v27, v9, OffsetFromEnd, v80);
  v36 = *(_QWORD *)(a1 + 32);
  if (v27[18] != *(_DWORD *)(v36 + 24))
  {
    v67 = __si_assert_copy_extra_268();
    v62 = v67;
    v68 = "";
    if (v67)
      v68 = v67;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2440, "cur.partitions->nVectors() == vectors->count()", v68);
    goto LABEL_104;
  }
  Ptr = (_DWORD *)vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(v36 + 16), OffsetFromEnd, 1556);
  Ptr[388] = v78;
  if (*(_DWORD *)(*(_QWORD *)(a1 + 32) + 24) == 1)
    *(_DWORD *)(a1 + 148) = v78;
  *(_DWORD *)(a1 + 152) = v78;
  if (v26)
  {
    v37 = (unint64_t *)&v26->__shared_owners_;
    do
      v38 = __ldaxr(v37);
    while (__stlxr(v38 - 1, v37));
    if (!v38)
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
    }
  }
  if (v23)
  {
    v39 = (unint64_t *)&v23->__shared_owners_;
    do
      v40 = __ldaxr(v39);
    while (__stlxr(v40 - 1, v39));
    if (!v40)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
  return Ptr;
}

uint64_t _ZN22IVFVectorIndexTemplateIDF16_Li768EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE10findVectorERK10CIVector_sIDF16_Li768EERjRfj(uint64_t a1, uint64_t a2, int *a3, _DWORD *a4, int a5)
{
  os_unfair_lock_s *v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  std::__shared_weak_count *v15;
  _DWORD *v16;
  unint64_t *v17;
  unint64_t v18;
  uint64_t v19;
  _DWORD *v20;
  unsigned int v21;
  uint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  unint64_t *v25;
  unint64_t v26;
  char *v28;
  char *v29;
  const char *v30;
  char *v31;
  const char *v32;
  char *v33;
  char *v34;
  const char *v35;
  int v36;
  int v37;
  int v38;
  int v39;
  _QWORD v40[8];
  int v41;
  _DWORD *v42;
  char *v43;
  uint64_t v44;
  int v45;

  v10 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  v12 = *(_QWORD *)(a1 + 64);
  v11 = *(std::__shared_weak_count **)(a1 + 72);
  if (v11)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      v14 = __ldxr(p_shared_owners);
    while (__stxr(v14 + 1, p_shared_owners));
  }
  v16 = *(_DWORD **)(a1 + 80);
  v15 = *(std::__shared_weak_count **)(a1 + 88);
  if (v15)
  {
    v17 = (unint64_t *)&v15->__shared_owners_;
    do
      v18 = __ldxr(v17);
    while (__stxr(v18 + 1, v17));
  }
  os_unfair_lock_unlock(v10);
  v19 = *a3;
  if ((_DWORD)v19 == -1)
  {
    if (*(_DWORD *)(a1 + 140) == -1)
    {
      v42 = 0;
      v43 = 0;
      v44 = 0;
      (*(void (**)(_DWORD **__return_ptr, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v12 + 72))(&v42, v12, a2, 1);
      v20 = v42;
      if (v43 - (char *)v42 == 8)
      {
        v21 = *v42;
        *a3 = *v42;
        *a4 = v20[1];
        if (v21 >= IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nPartitions(a1))
        {
          v33 = __si_assert_copy_extra_268();
          v34 = v33;
          if (v33)
            v35 = v33;
          else
            v35 = "";
          v36 = *a3;
          v37 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nPartitions(a1);
          v38 = v16[19];
          v39 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v12 + 16))(v12);
          __message_assert("%s:%u: failed assertion '%s' %s Invalid partId %u >= %u (partitions: v%u quantizer v%u", "IVFVectorIndex.hh", 2403, "partID < nPartitions()", v35, v36, v37, v38, v39);
          free(v34);
          if (__valid_fs(-1))
          {
            MEMORY[0xBAD] = -559038737;
            abort();
          }
          MEMORY[0xC00] = -559038737;
          abort();
        }
        if (v42)
        {
          v43 = (char *)v42;
          operator delete(v42);
        }
        v19 = *a3;
        goto LABEL_14;
      }
      v31 = __si_assert_copy_extra_268();
      v29 = v31;
      v32 = "";
      if (v31)
        v32 = v31;
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2398, "topPartition.size() == 1", v32);
    }
    else
    {
      v28 = __si_assert_copy_extra_268();
      v29 = v28;
      v30 = "";
      if (v28)
        v30 = v28;
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2396, "mergeBeginVectorOffset == VECTOR_NOT_FOUND", v30);
    }
    free(v29);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
LABEL_14:
  v42 = 0;
  v43 = (char *)&v42;
  v45 = -1;
  v44 = 0x2000000000;
  v40[0] = MEMORY[0x1E0C809B0];
  v40[1] = 0x40000000;
  v40[2] = ___ZN22IVFVectorIndexTemplateIDF16_Li768EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE10findVectorERK10CIVector_sIDF16_Li768EERjRfj_block_invoke;
  v40[3] = &unk_1E6E31F30;
  v41 = a5;
  v40[6] = a4;
  v40[7] = a2;
  v40[4] = &v42;
  v40[5] = a1;
  (*(void (**)(_DWORD *, uint64_t, _QWORD *))(*(_QWORD *)v16 + 80))(v16, v19, v40);
  v22 = *((unsigned int *)v43 + 6);
  _Block_object_dispose(&v42, 8);
  if (v15)
  {
    v23 = (unint64_t *)&v15->__shared_owners_;
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  if (v11)
  {
    v25 = (unint64_t *)&v11->__shared_owners_;
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  return v22;
}

unint64_t ___ZN22IVFVectorIndexTemplateIDF16_Li768EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE10findVectorERK10CIVector_sIDF16_Li768EERjRfj_block_invoke(unint64_t result, uint64_t a2, float *a3, _BYTE *a4)
{
  uint64_t v5;
  uint64_t v6;
  unint64_t v8;
  float v9;
  float v10;
  BOOL v11;
  float v12;
  float v13;
  int v15;
  const void *v16;
  const void *Ptr;

  v5 = *(_QWORD *)(result + 40);
  v6 = *(unsigned int *)a3;
  if (v6 >= *(_DWORD *)(v5 + 140))
    goto LABEL_12;
  v8 = result;
  v9 = **(float **)(result + 48);
  v10 = a3[1];
  v11 = v9 == v10;
  v12 = vabds_f32(v9, v10);
  v13 = fmaxf(fminf(fabsf(v10), fabsf(v9)) * 0.000015259, 0.000015259);
  if (v11 || v12 <= v13)
  {
    v15 = *(_DWORD *)(result + 64);
    if (v15)
    {
      result = vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(*(_QWORD *)(v5 + 32) + 16), v6, 1556);
      if (v15 != *(_DWORD *)(result + 1552))
        return result;
      *(float *)&v6 = *a3;
    }
    v16 = *(const void **)(v8 + 56);
    Ptr = (const void *)vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(*(_QWORD *)(v5 + 32) + 16), v6, 1556);
    result = memcmp(v16, Ptr, 0x600uLL);
    if (!(_DWORD)result)
    {
      *(float *)(*(_QWORD *)(*(_QWORD *)(v8 + 32) + 8) + 24) = *a3;
LABEL_12:
      *a4 = 1;
    }
  }
  return result;
}

int *_ZN22IVFVectorIndexTemplateIDF16_Li768EE11VectorStoreI32vi_onefixedsize_memory_allocator18vi_memory_postingsE8truncateEv(uint64_t a1)
{
  int v2;
  NSObject *v3;
  _QWORD *v4;
  int v5;
  int v6;
  int v7;
  int *result;
  int v9;
  _QWORD *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  int v14;
  __int16 v15;
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v2 = *__error();
  v3 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = (_QWORD *)(a1 + 40);
    if (*(char *)(a1 + 63) < 0)
      v4 = (_QWORD *)*v4;
    v5 = *(_DWORD *)(a1 + 24);
    v6 = *(_DWORD *)(vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(a1 + 16), 0, 1556) + 1552);
    v7 = *(_DWORD *)(vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(a1 + 16), (*(_DWORD *)(a1 + 24) - 1), 1556)+ 1552);
    v9 = 136315906;
    v10 = v4;
    v11 = 1024;
    v12 = v5;
    v13 = 1024;
    v14 = v6;
    v15 = 1024;
    v16 = v7;
    _os_log_impl(&dword_1B8270000, v3, OS_LOG_TYPE_DEFAULT, "truncate VectorStore %s(%u)[%u,%u]", (uint8_t *)&v9, 0x1Eu);
  }
  result = __error();
  *result = v2;
  return result;
}

void ___ZNK22IVFVectorIndexTemplateIDF16_Li768EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE4dumpEbbPViPvU13block_pointerFbjPKvybjfE_block_invoke()
{
  char *v0;
  char *v1;
  const char *v2;

  v0 = __si_assert_copy_extra_268();
  v1 = v0;
  v2 = "";
  if (v0)
    v2 = v0;
  __message_assert("%s:%u: failed assertion '%s' %s ", "VectorIndexSupport.hh", 2544, "0", v2);
  free(v1);
  if (__valid_fs(-1))
  {
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  MEMORY[0xC00] = -559038737;
  abort();
}

BOOL _ZN22IVFVectorIndexTemplateIDF16_Li768EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE6existsERK10CIVector_sIDF16_Li768EE(uint64_t a1, uint64_t a2)
{
  int v4;
  int v6;
  NSObject *v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  std::__shared_weak_count *v12;
  uint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  unsigned int v16;
  uint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  _QWORD v32[8];
  std::__shared_weak_count *v33;
  uint64_t v34;
  std::__shared_weak_count *v35;
  unsigned int v36;
  _QWORD v37[7];
  unsigned int v38;
  float v39;
  float v40;
  unsigned int v41;
  _BYTE buf[24];
  _DWORD v43[4];
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  v40 = 3.4028e38;
  v41 = -1;
  v4 = _ZN22IVFVectorIndexTemplateIDF16_Li768EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE10findVectorERK10CIVector_sIDF16_Li768EERjRfj(a1, a2, (int *)&v41, &v40, 0);
  if (v4 == -1)
  {
    v6 = *__error();
    v7 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = "exists";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 2632;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v41;
      LOWORD(v43[0]) = 2048;
      *(double *)((char *)v43 + 2) = v40;
      _os_log_error_impl(&dword_1B8270000, v7, OS_LOG_TYPE_ERROR, "%s:%d: Vector not found partID=%u distsq=%e", buf, 0x22u);
    }
    *__error() = v6;
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
    v9 = *(_QWORD *)(a1 + 64);
    v8 = *(std::__shared_weak_count **)(a1 + 72);
    if (v8)
    {
      p_shared_owners = (unint64_t *)&v8->__shared_owners_;
      do
        v11 = __ldxr(p_shared_owners);
      while (__stxr(v11 + 1, p_shared_owners));
    }
    v13 = *(_QWORD *)(a1 + 80);
    v12 = *(std::__shared_weak_count **)(a1 + 88);
    if (v12)
    {
      v14 = (unint64_t *)&v12->__shared_owners_;
      do
        v15 = __ldxr(v14);
      while (__stxr(v15 + 1, v14));
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    v43[0] = -1;
    *(_QWORD *)&buf[16] = 0x2000000000;
    v16 = v41;
    v17 = MEMORY[0x1E0C809B0];
    v37[0] = MEMORY[0x1E0C809B0];
    v37[1] = 0x40000000;
    v37[2] = ___ZN22IVFVectorIndexTemplateIDF16_Li768EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE6existsERK10CIVector_sIDF16_Li768EE_block_invoke;
    v37[3] = &unk_1E6E31ED0;
    v37[5] = a1;
    v37[6] = a2;
    v38 = v41;
    v39 = v40;
    v37[4] = buf;
    (*(void (**)(uint64_t, _QWORD, _QWORD *))(*(_QWORD *)v13 + 80))(v13, v41, v37);
    if (*(_DWORD *)(*(_QWORD *)&buf[8] + 24) == -1)
    {
      v32[0] = v17;
      v32[1] = 1174405120;
      v32[2] = ___ZN22IVFVectorIndexTemplateIDF16_Li768EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE6existsERK10CIVector_sIDF16_Li768EE_block_invoke_412;
      v32[3] = &unk_1E6E31EF8;
      v32[5] = a1;
      v32[6] = a2;
      v32[7] = v9;
      v33 = v8;
      if (v8)
      {
        v22 = (unint64_t *)&v8->__shared_owners_;
        do
          v23 = __ldxr(v22);
        while (__stxr(v23 + 1, v22));
      }
      v34 = v13;
      v35 = v12;
      if (v12)
      {
        v24 = (unint64_t *)&v12->__shared_owners_;
        do
          v25 = __ldxr(v24);
        while (__stxr(v25 + 1, v24));
      }
      v36 = v16;
      v32[4] = buf;
      (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v13 + 64))(v13, v32);
      v26 = v35;
      if (v35)
      {
        v27 = (unint64_t *)&v35->__shared_owners_;
        do
          v28 = __ldaxr(v27);
        while (__stlxr(v28 - 1, v27));
        if (!v28)
        {
          ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
          std::__shared_weak_count::__release_weak(v26);
        }
      }
      v29 = v33;
      if (v33)
      {
        v30 = (unint64_t *)&v33->__shared_owners_;
        do
          v31 = __ldaxr(v30);
        while (__stlxr(v31 - 1, v30));
        if (!v31)
        {
          ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
          std::__shared_weak_count::__release_weak(v29);
        }
      }
    }
    _Block_object_dispose(buf, 8);
    if (v12)
    {
      v18 = (unint64_t *)&v12->__shared_owners_;
      do
        v19 = __ldaxr(v18);
      while (__stlxr(v19 - 1, v18));
      if (!v19)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
    if (v8)
    {
      v20 = (unint64_t *)&v8->__shared_owners_;
      do
        v21 = __ldaxr(v20);
      while (__stlxr(v21 - 1, v20));
      if (!v21)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }
  }
  return v4 != -1;
}

void ___ZN22IVFVectorIndexTemplateIDF16_Li768EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE6existsERK10CIVector_sIDF16_Li768EE_block_invoke_412(uint64_t a1)
{
  uint64_t v1;
  _BYTE *v2;
  _BYTE *v3;
  float *v4;
  float *v5;
  float v6;
  float v7;
  uint64_t v8;
  const void *v9;
  uint64_t v10;
  const void *Ptr;
  int v12;
  NSObject *v13;
  float16x4_t *v14;
  uint64_t v15;
  uint64_t v16;
  float16x4_t *v17;
  float16x8_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t *v21;
  uint64_t v22;
  float16x4_t *v23;
  float16x8_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t *v27;
  float v28;
  int v29;
  NSObject *v30;
  int v31;
  NSObject *v32;
  int v33;
  NSObject *v34;
  int v35;
  NSObject *v36;
  int v37;
  NSObject *v38;
  int v39;
  NSObject *v40;
  uint64_t v41;
  unint64_t v42;
  int v43;
  NSObject *v44;
  int v45;
  NSObject *v46;
  int v47;
  NSObject *v48;
  int v49;
  NSObject *v50;
  int v51;
  NSObject *v52;
  double v53;
  float v54;
  float v55;
  float v56;
  int v57;
  float v58;
  _BOOL4 v59;
  float v60;
  int v61;
  _BOOL4 v62;
  float v63;
  int v64;
  _BOOL4 v65;
  float v66;
  int v67;
  _BOOL4 v68;
  float v69;
  int v70;
  float v71;
  float v72;
  double v73;
  float v74;
  _BOOL4 v75;
  _BOOL4 v76;
  float v77;
  float v78;
  int v79;
  float v80;
  _BOOL4 v81;
  float v82;
  int v83;
  _BOOL4 v84;
  float v85;
  int v86;
  _BOOL4 v87;
  float v88;
  int v89;
  _BOOL4 v90;
  float v91;
  int v92;
  float v93;
  float v94;
  float v95;
  _BOOL4 v96;
  _BOOL4 v97;
  _BOOL4 v98;
  float v99;
  float v100;
  float v101;
  float v102;
  float *__C;
  float *v104;
  uint64_t v105;
  float *__B;
  float *v107;
  uint64_t v108;
  float __A;
  const char *v110;
  __int16 v111;
  int v112;
  __int16 v113;
  float v114;
  __int16 v115;
  _BYTE v116[14];
  __int16 v117;
  double v118;
  __int16 v119;
  uint64_t v120;
  __int16 v121;
  _BOOL4 v122;
  __int16 v123;
  _BOOL4 v124;
  __int16 v125;
  _BOOL4 v126;
  __int16 v127;
  _BOOL4 v128;
  uint64_t v129;

  v1 = MEMORY[0x1E0C80A78](a1);
  v3 = v2;
  v5 = v4;
  v7 = v6;
  v8 = v1;
  v129 = *MEMORY[0x1E0C80C00];
  v10 = *(_QWORD *)(v1 + 40);
  v9 = *(const void **)(v1 + 48);
  Ptr = (const void *)vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(*(_QWORD *)(v10 + 32) + 16), *(unsigned int *)v4, 1556);
  if (!memcmp(v9, Ptr, 0x600uLL))
  {
    v12 = *__error();
    v13 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      v53 = v5[1];
      __A = 4.8153e-34;
      v110 = "exists_block_invoke";
      v111 = 1024;
      v112 = 2647;
      v113 = 1024;
      v114 = v7;
      v115 = 2048;
      *(double *)v116 = v53;
      _os_log_error_impl(&dword_1B8270000, v13, OS_LOG_TYPE_ERROR, "%s:%d: Vector not found actually in partID=%u distsq=%e", (uint8_t *)&__A, 0x22u);
    }
    *__error() = v12;
    v14 = *(float16x4_t **)(v8 + 48);
    v15 = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(v8 + 56) + 64))(*(_QWORD *)(v8 + 56), *(unsigned int *)(v8 + 88));
    bzero(&__A, 0xC00uLL);
    v16 = 0;
    v17 = v14 + 2;
    do
    {
      v18 = *(float16x8_t *)v17[-2].i8;
      v19 = vcvtq_f32_f16(*v17);
      v20 = vcvt_hight_f32_f16(*(float16x8_t *)v17->i8);
      v21 = (float32x4_t *)((char *)&__A + v16);
      *v21 = vcvtq_f32_f16(*(float16x4_t *)v18.i8);
      v21[1] = vcvt_hight_f32_f16(v18);
      v21[2] = v19;
      v21[3] = v20;
      v16 += 64;
      v17 += 4;
    }
    while (v16 != 3072);
    bzero(&__B, 0xC00uLL);
    v22 = 0;
    v23 = (float16x4_t *)(v15 + 16);
    do
    {
      v24 = *(float16x8_t *)v23[-2].i8;
      v25 = vcvtq_f32_f16(*v23);
      v26 = vcvt_hight_f32_f16(*(float16x8_t *)v23->i8);
      v27 = (float32x4_t *)&(&__B)[v22];
      *v27 = vcvtq_f32_f16(*(float16x4_t *)v24.i8);
      v27[1] = vcvt_hight_f32_f16(v24);
      v27[2] = v25;
      v27[3] = v26;
      v22 += 8;
      v23 += 4;
    }
    while (v22 != 384);
    LODWORD(__C) = 2139095039;
    vDSP_distancesq(&__A, 1, (const float *)&__B, 1, (float *)&__C, 0x300uLL);
    v28 = *(float *)&__C;
    v29 = *__error();
    v30 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
    {
      v54 = *(float *)(v8 + 88);
      __A = 4.8153e-34;
      v110 = "exists_block_invoke";
      v111 = 1024;
      v112 = 2649;
      v113 = 1024;
      v114 = v54;
      v115 = 2048;
      *(double *)v116 = v28;
      _os_log_error_impl(&dword_1B8270000, v30, OS_LOG_TYPE_ERROR, "%s:%d: Vec distance to centroid %u distsq=%e", (uint8_t *)&__A, 0x22u);
    }
    *__error() = v29;
    __B = 0;
    v107 = 0;
    v108 = 0;
    (*(void (**)(float **__return_ptr, _QWORD, _QWORD, uint64_t))(**(_QWORD **)(v8 + 56) + 72))(&__B, *(_QWORD *)(v8 + 56), *(_QWORD *)(v8 + 48), 2);
    v31 = *__error();
    v32 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
    {
      v55 = *__B;
      v56 = __B[1];
      v57 = *((_DWORD *)__B + 2);
      v58 = __B[3];
      v59 = v56 == v58 || vabds_f32(v56, v58) <= fmaxf(fminf(fabsf(v58), fabsf(v56)) * 0.000015259, 0.000015259);
      __A = 4.8156e-34;
      v110 = "exists_block_invoke";
      v111 = 1024;
      v112 = 2651;
      v113 = 1024;
      v114 = v55;
      v115 = 2048;
      *(double *)v116 = v56;
      *(_WORD *)&v116[8] = 1024;
      *(_DWORD *)&v116[10] = v57;
      v117 = 2048;
      v118 = v58;
      v119 = 1024;
      LODWORD(v120) = v59;
      _os_log_error_impl(&dword_1B8270000, v32, OS_LOG_TYPE_ERROR, "%s:%d: topKPartition(vec, 2) <%u, %e>, <%u, %e>, %d", (uint8_t *)&__A, 0x38u);
    }
    *__error() = v31;
    v33 = *__error();
    v34 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
    {
      v60 = *__B;
      v61 = *((_DWORD *)__B + 2);
      v62 = __B[1] == __B[3];
      __A = 4.8154e-34;
      v110 = "exists_block_invoke";
      v111 = 1024;
      v112 = 2652;
      v113 = 1024;
      v114 = v60;
      v115 = 1024;
      *(_DWORD *)v116 = v61;
      *(_WORD *)&v116[4] = 1024;
      *(_DWORD *)&v116[6] = v62;
      _os_log_error_impl(&dword_1B8270000, v34, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) == distsq(%u) is %d", (uint8_t *)&__A, 0x24u);
    }
    *__error() = v33;
    v35 = *__error();
    v36 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
    {
      v63 = *__B;
      v64 = *((_DWORD *)__B + 2);
      v65 = __B[1] < __B[3];
      __A = 4.8154e-34;
      v110 = "exists_block_invoke";
      v111 = 1024;
      v112 = 2653;
      v113 = 1024;
      v114 = v63;
      v115 = 1024;
      *(_DWORD *)v116 = v64;
      *(_WORD *)&v116[4] = 1024;
      *(_DWORD *)&v116[6] = v65;
      _os_log_error_impl(&dword_1B8270000, v36, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) < distsq(%u) is %d", (uint8_t *)&__A, 0x24u);
    }
    *__error() = v35;
    v37 = *__error();
    v38 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
    {
      v66 = *__B;
      v67 = *((_DWORD *)__B + 2);
      v68 = __B[1] > __B[3];
      __A = 4.8154e-34;
      v110 = "exists_block_invoke";
      v111 = 1024;
      v112 = 2654;
      v113 = 1024;
      v114 = v66;
      v115 = 1024;
      *(_DWORD *)v116 = v67;
      *(_WORD *)&v116[4] = 1024;
      *(_DWORD *)&v116[6] = v68;
      _os_log_error_impl(&dword_1B8270000, v38, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) > distsq(%u) is %d", (uint8_t *)&__A, 0x24u);
    }
    *__error() = v37;
    v39 = *__error();
    v40 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
    {
      v69 = *__B;
      v70 = *((_DWORD *)__B + 2);
      v71 = __B[1];
      v72 = __B[3];
      v73 = (float)(v71 - v72);
      v74 = vabds_f32(v71, v72);
      if (v71 == v72)
      {
        v75 = 1;
        v76 = 1;
      }
      else
      {
        v99 = fabsf(v71);
        v100 = fabsf(v72);
        v75 = v74 <= fmaxf(fminf(v100, v99) * 0.000015259, 0.000015259);
        v76 = v74 <= (float)(fmaxf(v99, v100) * 0.000015259);
      }
      __A = 4.8161e-34;
      v110 = "exists_block_invoke";
      v111 = 1024;
      v112 = 2655;
      v113 = 1024;
      v114 = v69;
      v115 = 1024;
      *(_DWORD *)v116 = v70;
      *(_WORD *)&v116[4] = 2048;
      *(double *)&v116[6] = v73;
      v117 = 2048;
      v118 = 1.17549435e-38;
      v119 = 2048;
      v120 = 0x3E80000000000000;
      v121 = 1024;
      v122 = v74 < 1.1755e-38;
      v123 = 1024;
      v124 = v74 < 0.00000011921;
      v125 = 1024;
      v126 = v75;
      v127 = 1024;
      v128 = v76;
      _os_log_error_impl(&dword_1B8270000, v40, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) - distsq(%u) = %e, FLT_MIN=%e, EPSILON=%e, %d, %d, %d, %d", (uint8_t *)&__A, 0x54u);
    }
    *__error() = v39;
    v104 = 0;
    v105 = 0;
    __C = 0;
    v41 = *(_QWORD *)(v8 + 56);
    v42 = vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(*(_QWORD *)(v10 + 32) + 16), *(unsigned int *)v5, 1556);
    (*(void (**)(float **__return_ptr, uint64_t, unint64_t, uint64_t))(*(_QWORD *)v41 + 72))(&__C, v41, v42, 2);
    v43 = *__error();
    v44 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
    {
      v77 = *__C;
      v78 = __C[1];
      v79 = *((_DWORD *)__C + 2);
      v80 = __C[3];
      v81 = v78 == v80 || vabds_f32(v78, v80) <= fmaxf(fminf(fabsf(v80), fabsf(v78)) * 0.000015259, 0.000015259);
      __A = 4.8156e-34;
      v110 = "exists_block_invoke";
      v111 = 1024;
      v112 = 2658;
      v113 = 1024;
      v114 = v77;
      v115 = 2048;
      *(double *)v116 = v78;
      *(_WORD *)&v116[8] = 1024;
      *(_DWORD *)&v116[10] = v79;
      v117 = 2048;
      v118 = v80;
      v119 = 1024;
      LODWORD(v120) = v81;
      _os_log_error_impl(&dword_1B8270000, v44, OS_LOG_TYPE_ERROR, "%s:%d: topKPartition(entry->vec, 2) <%u, %e>, <%u, %e>, %d", (uint8_t *)&__A, 0x38u);
    }
    *__error() = v43;
    v45 = *__error();
    v46 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
    {
      v82 = *__C;
      v83 = *((_DWORD *)__C + 2);
      v84 = __C[1] == __C[3];
      __A = 4.8154e-34;
      v110 = "exists_block_invoke";
      v111 = 1024;
      v112 = 2659;
      v113 = 1024;
      v114 = v82;
      v115 = 1024;
      *(_DWORD *)v116 = v83;
      *(_WORD *)&v116[4] = 1024;
      *(_DWORD *)&v116[6] = v84;
      _os_log_error_impl(&dword_1B8270000, v46, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) == distsq(%u) is %d", (uint8_t *)&__A, 0x24u);
    }
    *__error() = v45;
    v47 = *__error();
    v48 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
    {
      v85 = *__C;
      v86 = *((_DWORD *)__C + 2);
      v87 = __C[1] < __C[3];
      __A = 4.8154e-34;
      v110 = "exists_block_invoke";
      v111 = 1024;
      v112 = 2660;
      v113 = 1024;
      v114 = v85;
      v115 = 1024;
      *(_DWORD *)v116 = v86;
      *(_WORD *)&v116[4] = 1024;
      *(_DWORD *)&v116[6] = v87;
      _os_log_error_impl(&dword_1B8270000, v48, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) < distsq(%u) is %d", (uint8_t *)&__A, 0x24u);
    }
    *__error() = v47;
    v49 = *__error();
    v50 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
    {
      v88 = *__C;
      v89 = *((_DWORD *)__C + 2);
      v90 = __C[1] > __C[3];
      __A = 4.8154e-34;
      v110 = "exists_block_invoke";
      v111 = 1024;
      v112 = 2661;
      v113 = 1024;
      v114 = v88;
      v115 = 1024;
      *(_DWORD *)v116 = v89;
      *(_WORD *)&v116[4] = 1024;
      *(_DWORD *)&v116[6] = v90;
      _os_log_error_impl(&dword_1B8270000, v50, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) > distsq(%u) is %d", (uint8_t *)&__A, 0x24u);
    }
    *__error() = v49;
    v51 = *__error();
    v52 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
    {
      v91 = *__C;
      v92 = *((_DWORD *)__C + 2);
      v93 = __C[1];
      v94 = __C[3];
      v95 = vabds_f32(v93, v94);
      v96 = (float)(v93 - v94) < 1.1755e-38;
      if (v93 == v94)
      {
        v97 = 1;
        v98 = 1;
      }
      else
      {
        v101 = fabsf(v93);
        v102 = fabsf(v94);
        v97 = v95 <= fmaxf(fminf(v102, v101) * 0.000015259, 0.000015259);
        v98 = v95 <= (float)(fmaxf(v101, v102) * 0.000015259);
      }
      __A = 4.8161e-34;
      v110 = "exists_block_invoke";
      v111 = 1024;
      v112 = 2662;
      v113 = 1024;
      v114 = v91;
      v115 = 1024;
      *(_DWORD *)v116 = v92;
      *(_WORD *)&v116[4] = 2048;
      *(double *)&v116[6] = v95;
      v117 = 2048;
      v118 = 1.17549435e-38;
      v119 = 2048;
      v120 = 0x3E80000000000000;
      v121 = 1024;
      v122 = v96;
      v123 = 1024;
      v124 = v95 < 0.00000011921;
      v125 = 1024;
      v126 = v97;
      v127 = 1024;
      v128 = v98;
      _os_log_error_impl(&dword_1B8270000, v52, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) - distsq(%u) = %e, FLT_MIN=%e, EPSILON=%e, %d, %d, %d, %d", (uint8_t *)&__A, 0x54u);
    }
    *__error() = v51;
    *(float *)(*(_QWORD *)(*(_QWORD *)(v8 + 32) + 8) + 24) = *v5;
    *v3 = 1;
    if (__C)
    {
      v104 = __C;
      operator delete(__C);
    }
    if (__B)
    {
      v107 = __B;
      operator delete(__B);
    }
  }
}

void _ZNSt3__120__shared_ptr_emplaceIN22IVFVectorIndexTemplateIDF16_Li512EE11VectorStoreI32vi_onefixedsize_memory_allocator18vi_memory_postingsEENS_9allocatorIS6_EEED1Ev(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6E31710;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void _ZNSt3__120__shared_ptr_emplaceIN22IVFVectorIndexTemplateIDF16_Li512EE11VectorStoreI32vi_onefixedsize_memory_allocator18vi_memory_postingsEENS_9allocatorIS6_EEED0Ev(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6E31710;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BCCB06A4);
}

void _ZNSt3__120__shared_ptr_emplaceIN22IVFVectorIndexTemplateIDF16_Li512EE11VectorStoreI32vi_onefixedsize_memory_allocator18vi_memory_postingsEENS_9allocatorIS6_EEE16__on_zero_sharedEv(uint64_t a1)
{
  uint64_t v2;

  if (*(char *)(a1 + 87) < 0)
    operator delete(*(void **)(a1 + 64));
  v2 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 40) = 0;
  if (v2)
  {
    malloc_zone_free(*(malloc_zone_t **)v2, *(void **)(v2 + 8));
    JUMPOUT(0x1BCCB06A4);
  }
}

void _ZN22IVFVectorIndexTemplateIDF16_Li512EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsED0Ev(_QWORD *a1)
{
  _ZN22IVFVectorIndexTemplateIDF16_Li512EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsED2Ev(a1);
  JUMPOUT(0x1BCCB06A4);
}

void _ZNK22IVFVectorIndexTemplateIDF16_Li512EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE12getQuantizerEv(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  os_unfair_lock_s *v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;

  v4 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  v6 = *(_QWORD *)(a1 + 64);
  v5 = *(std::__shared_weak_count **)(a1 + 72);
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }
  v9 = *(std::__shared_weak_count **)(a1 + 88);
  if (v9)
  {
    v10 = (unint64_t *)&v9->__shared_owners_;
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }
  os_unfair_lock_unlock(v4);
  *a2 = v6;
  a2[1] = v5;
  if (v5)
  {
    v12 = (unint64_t *)&v5->__shared_owners_;
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  if (!v9)
    goto LABEL_14;
  v14 = (unint64_t *)&v9->__shared_owners_;
  do
    v15 = __ldaxr(v14);
  while (__stlxr(v15 - 1, v14));
  if (!v15)
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
    if (!v5)
      return;
  }
  else
  {
LABEL_14:
    if (!v5)
      return;
  }
  v16 = (unint64_t *)&v5->__shared_owners_;
  do
    v17 = __ldaxr(v16);
  while (__stlxr(v17 - 1, v16));
  if (!v17)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
}

void _ZNK22IVFVectorIndexTemplateIDF16_Li512EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE13getPartitionsEv(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  os_unfair_lock_s *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;

  v4 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  v5 = *(std::__shared_weak_count **)(a1 + 72);
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  v9 = *(_QWORD *)(a1 + 80);
  v8 = *(std::__shared_weak_count **)(a1 + 88);
  if (!v8)
  {
    os_unfair_lock_unlock(v4);
    *a2 = v9;
    a2[1] = 0;
    if (!v5)
      return;
    goto LABEL_15;
  }
  v10 = (unint64_t *)&v8->__shared_owners_;
  do
    v11 = __ldxr(v10);
  while (__stxr(v11 + 1, v10));
  os_unfair_lock_unlock(v4);
  *a2 = v9;
  a2[1] = v8;
  do
    v12 = __ldxr(v10);
  while (__stxr(v12 + 1, v10));
  do
    v13 = __ldaxr(v10);
  while (__stlxr(v13 - 1, v10));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
  if (v5)
  {
LABEL_15:
    v14 = (unint64_t *)&v5->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
}

unint64_t _ZNK22IVFVectorIndexTemplateIDF16_Li512EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE17getVectorAtOffsetEj(uint64_t a1, unsigned int a2)
{
  return vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(*(_QWORD *)(a1 + 32) + 16), a2, 1044);
}

void _ZNK22IVFVectorIndexTemplateIDF16_Li512EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE13newPartitionsENSt3__110shared_ptrI9QuantizerIDF16_Li512EEEE(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  os_unfair_lock_s *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  const char *v14;
  size_t v15;
  void *v16;
  void **v17;
  uint64_t v18;
  uint64_t v19;
  malloc_zone_t *v20;
  uint64_t v21;
  _DWORD *v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  unint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  unint64_t v29;
  void *v30;
  unint64_t Ptr;
  int v32;
  int v33;
  NSObject *v34;
  void **v35;
  int v36;
  int v37;
  char *v38;
  _QWORD *v39;
  int v40;
  unint64_t *v41;
  unint64_t v42;
  unint64_t *v43;
  unint64_t v44;
  char *v45;
  char *v46;
  const char *v47;
  void *v48[2];
  char v49;
  void *__dst[2];
  unint64_t v51;
  void *__p[3];
  __int16 v53;
  _QWORD *v54;
  __int16 v55;
  int v56;
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  v6 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  v7 = *(std::__shared_weak_count **)(a1 + 72);
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }
  v11 = *(_QWORD *)(a1 + 80);
  v10 = *(std::__shared_weak_count **)(a1 + 88);
  if (v10)
  {
    v12 = (unint64_t *)&v10->__shared_owners_;
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  os_unfair_lock_unlock(v6);
  v14 = ".partitions";
  if (v11 && (*(unsigned int (**)(uint64_t))(*(_QWORD *)v11 + 24))(v11))
    v14 = ".tmp.partitions";
  v15 = strlen(v14);
  if (v15 >= 0x7FFFFFFFFFFFFFF8)
LABEL_60:
    abort();
  v16 = (void *)v15;
  if (v15 >= 0x17)
  {
    v18 = (v15 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v15 | 7) != 0x17)
      v18 = v15 | 7;
    v19 = v18 + 1;
    v17 = (void **)operator new(v18 + 1);
    __dst[1] = v16;
    v51 = v19 | 0x8000000000000000;
    __dst[0] = v17;
    goto LABEL_17;
  }
  HIBYTE(v51) = v15;
  v17 = __dst;
  if (v15)
LABEL_17:
    memcpy(v17, v14, (size_t)v16);
  *((_BYTE *)v16 + (_QWORD)v17) = 0;
  v20 = malloc_default_zone();
  if (SHIBYTE(v51) < 0)
    operator delete(__dst[0]);
  v21 = operator new();
  v22 = (_DWORD *)v21;
  v23 = *(std::__shared_weak_count **)(a2 + 8);
  __p[0] = *(void **)a2;
  __p[1] = v23;
  if (v23)
  {
    v24 = (unint64_t *)&v23->__shared_owners_;
    do
      v25 = __ldxr(v24);
    while (__stxr(v25 + 1, v24));
    PartitionStore<vi_onefixedsize_memory_allocator,512>::PartitionStore<vi_onefixedsize_memory_allocator>(v21, v20, 0, __p);
    do
      v26 = __ldaxr(v24);
    while (__stlxr(v26 - 1, v24));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
  else
  {
    PartitionStore<vi_onefixedsize_memory_allocator,512>::PartitionStore<vi_onefixedsize_memory_allocator>(v21, v20, 0, __p);
  }
  *a3 = v22;
  v27 = (_QWORD *)operator new();
  *v27 = &off_1E6E31210;
  v27[1] = 0;
  v27[2] = 0;
  v27[3] = v22;
  a3[1] = v27;
  v28 = *(_QWORD *)(a1 + 32);
  if (*(_DWORD *)(v28 + 24))
  {
    v29 = 0;
    do
    {
      memset(__p, 0, sizeof(__p));
      v30 = *(void **)a2;
      Ptr = vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(v28 + 16), v29, 1044);
      (*(void (**)(void **__return_ptr, void *, unint64_t, uint64_t))(*(_QWORD *)v30 + 72))(__p, v30, Ptr, 1);
      (*(void (**)(_DWORD *, _QWORD, unint64_t, float))(*(_QWORD *)v22 + 56))(v22, *(unsigned int *)__p[0], v29, *((float *)__p[0] + 1));
      if (__p[0])
      {
        __p[1] = __p[0];
        operator delete(__p[0]);
      }
      ++v29;
      v28 = *(_QWORD *)(a1 + 32);
    }
    while (v29 < *(unsigned int *)(v28 + 24));
  }
  (*(void (**)(_DWORD *, _QWORD))(*(_QWORD *)v22 + 112))(v22, 0);
  v32 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 24);
  if (v32)
  {
    v33 = *__error();
    v34 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
    {
      (*(void (**)(void **__return_ptr, _DWORD *))(*(_QWORD *)v22 + 144))(v48, v22);
      if (v49 >= 0)
        v35 = v48;
      else
        v35 = (void **)v48[0];
      v36 = v22[17];
      v37 = v22[18];
      v38 = *(char **)a2;
      v39 = (_QWORD *)(*(_QWORD *)a2 + 8);
      if (v38[31] < 0)
        v39 = (_QWORD *)*v39;
      v40 = (*(uint64_t (**)(char *))(*(_QWORD *)v38 + 16))(v38);
      LODWORD(__p[0]) = 136316162;
      *(void **)((char *)__p + 4) = v35;
      WORD2(__p[1]) = 1024;
      *(_DWORD *)((char *)&__p[1] + 6) = v37;
      WORD1(__p[2]) = 1024;
      HIDWORD(__p[2]) = v36;
      v53 = 2080;
      v54 = v39;
      v55 = 1024;
      v56 = v40;
      _os_log_impl(&dword_1B8270000, v34, OS_LOG_TYPE_DEFAULT, "Create new partitions %s(%u/%u) for new quantizer %s(%u)", (uint8_t *)__p, 0x28u);
      if (v49 < 0)
        operator delete(v48[0]);
    }
    *__error() = v33;
    v32 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 24);
  }
  if (v22[18] != v32)
  {
    v45 = __si_assert_copy_extra_268();
    v46 = v45;
    v47 = "";
    if (v45)
      v47 = v45;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2363, "newPartitions->nVectors() == vectors->count()", v47);
    free(v46);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    goto LABEL_60;
  }
  if (v10)
  {
    v41 = (unint64_t *)&v10->__shared_owners_;
    do
      v42 = __ldaxr(v41);
    while (__stlxr(v42 - 1, v41));
    if (!v42)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  if (v7)
  {
    v43 = (unint64_t *)&v7->__shared_owners_;
    do
      v44 = __ldaxr(v43);
    while (__stlxr(v44 - 1, v43));
    if (!v44)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
}

void _ZN22IVFVectorIndexTemplateIDF16_Li512EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE16replaceQuantizerENSt3__110shared_ptrI9QuantizerIDF16_Li512EEEENS6_I17AnyPartitionStoreEE(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  os_unfair_lock_s *v6;
  os_unfair_lock_s *v7;
  std::__shared_weak_count *v8;
  __int128 *v9;
  char *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  std::__shared_weak_count *v13;
  _DWORD *v14;
  unint64_t *v15;
  unint64_t v16;
  int v17;
  _DWORD *v18;
  NSObject *v19;
  _QWORD *v20;
  int v21;
  _QWORD *v22;
  void **v23;
  int v24;
  void **v25;
  int v26;
  int v27;
  BOOL v28;
  uint64_t v29;
  unint64_t *v30;
  unint64_t v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  unint64_t v37;
  std::__shared_weak_count *v38;
  unint64_t *v39;
  unint64_t v40;
  unint64_t *v41;
  unint64_t v42;
  unint64_t *v43;
  unint64_t v44;
  char *v45;
  char *v46;
  const char *v47;
  char *v48;
  const char *v49;
  _QWORD *v50;
  _QWORD *v51;
  int v52;
  int v53;
  int v54;
  os_unfair_lock_s *v55;
  int v56;
  __int128 v57;
  uint64_t v58;
  std::__shared_weak_count *v59;
  void *__p[2];
  char v61;
  void *v62[2];
  char v63;
  uint8_t buf[4];
  _QWORD *v65;
  __int16 v66;
  int v67;
  __int16 v68;
  _QWORD *v69;
  __int16 v70;
  int v71;
  __int16 v72;
  void **v73;
  __int16 v74;
  int v75;
  __int16 v76;
  int v77;
  __int16 v78;
  void **v79;
  __int16 v80;
  int v81;
  __int16 v82;
  int v83;
  uint64_t v84;

  v84 = *MEMORY[0x1E0C80C00];
  v6 = (os_unfair_lock_s *)(a1 + 136);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 136));
  v7 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  v10 = *(char **)(a1 + 64);
  v8 = *(std::__shared_weak_count **)(a1 + 72);
  v9 = (__int128 *)(a1 + 64);
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }
  v14 = *(_DWORD **)(a1 + 80);
  v13 = *(std::__shared_weak_count **)(a1 + 88);
  if (v13)
  {
    v15 = (unint64_t *)&v13->__shared_owners_;
    do
      v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
  v17 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a2 + 24))(*a2);
  v18 = (_DWORD *)*a3;
  if (v17 != *(_DWORD *)(*a3 + 68))
  {
    v45 = __si_assert_copy_extra_268();
    v46 = v45;
    v47 = "";
    if (v45)
      v47 = v45;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2381, "newQuantizer->count() == newPartitions->nPartitions()", v47);
LABEL_64:
    free(v46);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  if (*(_DWORD *)(*(_QWORD *)(a1 + 32) + 24) != v18[18])
  {
    v48 = __si_assert_copy_extra_268();
    v46 = v48;
    v49 = "";
    if (v48)
      v49 = v48;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2382, "vectors->count() == newPartitions->nVectors()", v49);
    goto LABEL_64;
  }
  if (v10 && v14)
  {
    v56 = *__error();
    v19 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      v20 = v10 + 8;
      if (v10[31] < 0)
        v20 = (_QWORD *)*v20;
      v51 = v20;
      v21 = (*(uint64_t (**)(char *))(*(_QWORD *)v10 + 16))(v10);
      v22 = (_QWORD *)(*a2 + 8);
      v55 = v6;
      v54 = v21;
      if (*(char *)(*a2 + 31) < 0)
        v22 = (_QWORD *)*v22;
      v50 = v22;
      v53 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a2 + 16))(*a2);
      v23 = v62;
      (*(void (**)(void **__return_ptr, _DWORD *))(*(_QWORD *)v14 + 144))(v62, v14);
      if (v63 < 0)
        v23 = (void **)v62[0];
      v24 = v14[18];
      v52 = v14[17];
      (*(void (**)(void **__return_ptr))(*(_QWORD *)*a3 + 144))(__p);
      v25 = __p;
      if (v61 < 0)
        v25 = (void **)__p[0];
      v26 = *(_DWORD *)(*a3 + 68);
      v27 = *(_DWORD *)(*a3 + 72);
      *(_DWORD *)buf = 136317442;
      v65 = v51;
      v66 = 1024;
      v67 = v54;
      v68 = 2080;
      v69 = v50;
      v70 = 1024;
      v71 = v53;
      v72 = 2080;
      v73 = v23;
      v74 = 1024;
      v75 = v24;
      v76 = 1024;
      v77 = v52;
      v78 = 2080;
      v79 = v25;
      v80 = 1024;
      v81 = v27;
      v82 = 1024;
      v83 = v26;
      _os_log_impl(&dword_1B8270000, v19, OS_LOG_TYPE_DEFAULT, "Replace quantizer %s(%u) -> %s(%u), partitions %s(%u/%u) -> %s(%u/%u)", buf, 0x4Eu);
      if (v61 < 0)
        operator delete(__p[0]);
      v6 = v55;
      if (v63 < 0)
        operator delete(v62[0]);
    }
    *__error() = v56;
    v18 = (_DWORD *)*a3;
  }
  if ((*(unsigned int (**)(_DWORD *))(*(_QWORD *)v18 + 24))(v18))
    v28 = v14 == 0;
  else
    v28 = 1;
  if (!v28 && (*(unsigned int (**)(_DWORD *))(*(_QWORD *)v14 + 24))(v14))
    (*(void (**)(_QWORD, _DWORD *))(*(_QWORD *)*a3 + 168))(*a3, v14);
  v29 = a2[1];
  *(_QWORD *)&v57 = *a2;
  *((_QWORD *)&v57 + 1) = v29;
  if (v29)
  {
    v30 = (unint64_t *)(v29 + 8);
    do
      v31 = __ldxr(v30);
    while (__stxr(v31 + 1, v30));
  }
  v32 = (std::__shared_weak_count *)a3[1];
  v58 = *a3;
  v59 = v32;
  if (v32)
  {
    v33 = (unint64_t *)&v32->__shared_owners_;
    do
      v34 = __ldxr(v33);
    while (__stxr(v34 + 1, v33));
  }
  os_unfair_lock_lock(v7);
  std::swap[abi:nn180100]<IVFVectorIndexTemplate<float,768>::QuantizerPartitions>(v9, &v57);
  os_unfair_lock_unlock(v7);
  v35 = v59;
  if (v59)
  {
    v36 = (unint64_t *)&v59->__shared_owners_;
    do
      v37 = __ldaxr(v36);
    while (__stlxr(v37 - 1, v36));
    if (!v37)
    {
      ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
      std::__shared_weak_count::__release_weak(v35);
    }
  }
  v38 = (std::__shared_weak_count *)*((_QWORD *)&v57 + 1);
  if (*((_QWORD *)&v57 + 1))
  {
    v39 = (unint64_t *)(*((_QWORD *)&v57 + 1) + 8);
    do
      v40 = __ldaxr(v39);
    while (__stlxr(v40 - 1, v39));
    if (!v40)
    {
      ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
      std::__shared_weak_count::__release_weak(v38);
    }
  }
  os_unfair_lock_unlock(v6);
  if (v13)
  {
    v41 = (unint64_t *)&v13->__shared_owners_;
    do
      v42 = __ldaxr(v41);
    while (__stlxr(v42 - 1, v41));
    if (!v42)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  if (v8)
  {
    v43 = (unint64_t *)&v8->__shared_owners_;
    do
      v44 = __ldaxr(v43);
    while (__stlxr(v44 - 1, v43));
    if (!v44)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
}

_QWORD *_ZN22IVFVectorIndexTemplateIDF16_Li512EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsED2Ev(_QWORD *a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;

  *a1 = &off_1E6E316C8;
  v2 = (std::__shared_weak_count *)a1[11];
  if (!v2)
    goto LABEL_5;
  p_shared_owners = (unint64_t *)&v2->__shared_owners_;
  do
    v4 = __ldaxr(p_shared_owners);
  while (__stlxr(v4 - 1, p_shared_owners));
  if (!v4)
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    v5 = (std::__shared_weak_count *)a1[9];
    if (!v5)
      goto LABEL_11;
  }
  else
  {
LABEL_5:
    v5 = (std::__shared_weak_count *)a1[9];
    if (!v5)
      goto LABEL_11;
  }
  v6 = (unint64_t *)&v5->__shared_owners_;
  do
    v7 = __ldaxr(v6);
  while (__stlxr(v7 - 1, v6));
  if (!v7)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
LABEL_11:
  v8 = (std::__shared_weak_count *)a1[7];
  if (!v8)
    goto LABEL_15;
  v9 = (unint64_t *)&v8->__shared_owners_;
  do
    v10 = __ldaxr(v9);
  while (__stlxr(v10 - 1, v9));
  if (!v10)
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
    v11 = (std::__shared_weak_count *)a1[5];
    if (!v11)
      return a1;
  }
  else
  {
LABEL_15:
    v11 = (std::__shared_weak_count *)a1[5];
    if (!v11)
      return a1;
  }
  v12 = (unint64_t *)&v11->__shared_owners_;
  do
    v13 = __ldaxr(v12);
  while (__stlxr(v13 - 1, v12));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  return a1;
}

uint64_t _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li512EED1Ev(uint64_t a1)
{
  *(_QWORD *)a1 = off_1E6E31570;
  _ZN22IVFVectorIndexTemplateIDF16_Li512EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsED2Ev((_QWORD *)(a1 + 48));
  *(_QWORD *)a1 = off_1E6E30C80;
  if (*(char *)(a1 + 47) < 0)
    operator delete(*(void **)(a1 + 24));
  return a1;
}

void _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li512EED0Ev(uint64_t a1)
{
  *(_QWORD *)a1 = off_1E6E31570;
  _ZN22IVFVectorIndexTemplateIDF16_Li512EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsED2Ev((_QWORD *)(a1 + 48));
  *(_QWORD *)a1 = off_1E6E30C80;
  if (*(char *)(a1 + 47) < 0)
    operator delete(*(void **)(a1 + 24));
  JUMPOUT(0x1BCCB06A4);
}

uint64_t _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li512EE8nVectorsEv(uint64_t a1)
{
  return IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nVectors(a1 + 48);
}

uint64_t _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li512EE11nPartitionsEv(uint64_t a1)
{
  return IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nPartitions(a1 + 48);
}

uint64_t _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li512EE8allExistEPKvj(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  float v9;
  uint64_t v10;
  int v11;
  NSObject *v12;
  char *v14;
  char *v15;
  const char *v16;
  uint8_t buf[4];
  double v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if ((_DWORD)a3)
  {
    v5 = a1 + 48;
    v6 = a3;
    if (a3 <= 0x3E8)
    {
      while (_ZN22IVFVectorIndexTemplateIDF16_Li512EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE6existsERK10CIVector_sIDF16_Li512EE(v5, a2))
      {
        a2 += 1024;
        if (!--v6)
          return a3;
      }
    }
    else
    {
      v7 = 0;
      v8 = a3 / 0xA;
      v9 = 1.0 / (float)a3;
      while (1)
      {
        v10 = v7 + 1;
        if (!(((int)v7 + 1) % v8))
        {
          v11 = *__error();
          v12 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 134217984;
            v18 = (float)((float)((float)v7 * 100.0) * v9);
            _os_log_impl(&dword_1B8270000, v12, OS_LOG_TYPE_DEFAULT, "allExist: %.0f%%", buf, 0xCu);
          }
          *__error() = v11;
        }
        if (!_ZN22IVFVectorIndexTemplateIDF16_Li512EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE6existsERK10CIVector_sIDF16_Li512EE(v5, a2))break;
        a2 += 1024;
        ++v7;
        if (a3 == v10)
          return a3;
      }
    }
    v14 = __si_assert_copy_extra_268();
    v15 = v14;
    v16 = "";
    if (v14)
      v16 = v14;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3151, "false", v16);
    free(v15);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  return a3;
}

uint64_t _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li512EE12validAddressEPKv()
{
  return 1;
}

uint64_t _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li512EE6shadowEbPVi(uint64_t a1, uint64_t a2, uint64_t a3)
{
  os_unfair_lock_s *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t *v15;
  unint64_t v16;

  v6 = (os_unfair_lock_s *)(a1 + 144);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 144));
  v7 = *(std::__shared_weak_count **)(a1 + 120);
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }
  v11 = *(_QWORD *)(a1 + 128);
  v10 = *(std::__shared_weak_count **)(a1 + 136);
  if (v10)
  {
    v12 = (unint64_t *)&v10->__shared_owners_;
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
    os_unfair_lock_unlock(v6);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v11 + 160))(v11, a2, a3);
    do
      v14 = __ldaxr(v12);
    while (__stlxr(v14 - 1, v12));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  else
  {
    os_unfair_lock_unlock(v6);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v11 + 160))(v11, a2, a3);
  }
  if (v7)
  {
    v15 = (unint64_t *)&v7->__shared_owners_;
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  return 0;
}

_DWORD *_ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li512EE17bulkInsertForTestEPKvPKjjS8_(_DWORD *result, char *a2, int *a3, unsigned int a4, unsigned int *a5)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  float v12;
  int v13;
  uint64_t v14;
  int v15;
  NSObject *v16;
  unsigned int v17;
  int v18;
  int v19;
  unsigned int v20;
  unsigned int v21;
  int v22;
  int v23;
  uint8_t buf[4];
  double v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if (a4)
  {
    v8 = (uint64_t)(result + 12);
    v9 = a4;
    if (a4 <= 0x3E8)
    {
      do
      {
        v21 = *a5++;
        v20 = v21;
        v23 = *a3++;
        v22 = v23;
        result = _ZN22IVFVectorIndexTemplateIDF16_Li512EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE15lookupForInsertEjRK10CIVector_sIDF16_Li512EEjfb(v8, v20, a2, 0xFFFFFFFF, 3.4028e38);
        if (result[258])
        {
          v19 = result[257] + 1;
        }
        else
        {
          result[258] = v22;
          v19 = 1;
        }
        result[257] = v19;
        a2 += 1024;
        --v9;
      }
      while (v9);
    }
    else
    {
      v10 = 0;
      v11 = a4 / 0xA;
      v12 = 1.0 / (float)a4;
      do
      {
        v14 = v10 + 1;
        if (!(((int)v10 + 1) % v11))
        {
          v15 = *__error();
          v16 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 134217984;
            v25 = (float)((float)((float)v10 * 100.0) * v12);
            _os_log_impl(&dword_1B8270000, v16, OS_LOG_TYPE_DEFAULT, "bulkInsertForTest: %.0f%%", buf, 0xCu);
          }
          *__error() = v15;
        }
        v17 = a5[v10];
        v18 = a3[v10];
        result = _ZN22IVFVectorIndexTemplateIDF16_Li512EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE15lookupForInsertEjRK10CIVector_sIDF16_Li512EEjfb(v8, v17, a2, 0xFFFFFFFF, 3.4028e38);
        if (result[258])
        {
          v13 = result[257] + 1;
        }
        else
        {
          result[258] = v18;
          v13 = 1;
        }
        result[257] = v13;
        a2 += 1024;
        v10 = v14;
      }
      while (v9 != v14);
    }
  }
  return result;
}

char *_ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li512EE12insertVectorEjjPKv14vec_dimensions15vec_data_format14docInvertStateyP15PostingBaseInfo(_DWORD *a1, int a2, unsigned int a3, const void *a4, int a5, int a6, int a7, uint64_t a8, char *a9)
{
  unsigned int *v11;
  char *v13;
  char *v14;
  const char *v15;

  if (a1[2] != a2
    || a6 > 2
    || a1[3] != vector_dimension_vec_sizes_10743[a5]
    || vector_size_elem_sizes_10742[a6] != a1[4])
  {
    v13 = __si_assert_copy_extra_268();
    v14 = v13;
    v15 = "";
    if (v13)
      v15 = v13;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3070, "compatible", v15);
    free(v14);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v11 = _ZN22IVFVectorIndexTemplateIDF16_Li512EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE15lookupForInsertEjRK10CIVector_sIDF16_Li512EEjfb((uint64_t)(a1 + 12), a3, a4, 0xFFFFFFFF, 3.4028e38)+ 256;
  return vi_memory_postings::push_posting(a9, a7, v11, a8);
}

uint64_t _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li512EE14insertForMergeEjtjPKv14vec_dimensions15vec_data_formatyjf(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, int a6, int a7)
{
  char *v8;
  char *v9;
  const char *v10;

  if (*(_DWORD *)(a1 + 8) != a2
    || *(unsigned __int16 *)(a1 + 20) != a3
    || a7 > 2
    || *(_DWORD *)(a1 + 12) != vector_dimension_vec_sizes_10743[a6]
    || vector_size_elem_sizes_10742[a7] != *(_DWORD *)(a1 + 16))
  {
    v8 = __si_assert_copy_extra_268();
    v9 = v8;
    v10 = "";
    if (v8)
      v10 = v8;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3070, "compatible", v10);
    free(v9);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  return 1;
}

_DWORD *_ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li512EE13insertForTestEjjPKv14vec_dimensions15vec_data_formatj(_DWORD *a1, int a2, unsigned int a3, const void *a4, int a5, int a6, int a7)
{
  _DWORD *result;
  int v9;
  char *v10;
  char *v11;
  const char *v12;
  uint64_t v13;

  if (a1[2] != a2
    || a6 > 2
    || a1[3] != vector_dimension_vec_sizes_10743[a5]
    || vector_size_elem_sizes_10742[a6] != a1[4])
  {
    v10 = __si_assert_copy_extra_268();
    v11 = v10;
    v12 = "";
    if (v10)
      v12 = v10;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3070, "compatible", v12);
    free(v11);
    if (__valid_fs(-1))
      v13 = 2989;
    else
      v13 = 3072;
    *(_DWORD *)v13 = -559038737;
    abort();
  }
  result = _ZN22IVFVectorIndexTemplateIDF16_Li512EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE15lookupForInsertEjRK10CIVector_sIDF16_Li512EEjfb((uint64_t)(a1 + 12), a3, a4, 0xFFFFFFFF, 3.4028e38);
  if (result[258])
  {
    v9 = result[257] + 1;
  }
  else
  {
    result[258] = a7;
    v9 = 1;
  }
  result[257] = v9;
  return result;
}

void _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li512EE5trainERKNSt3__16vectorIP22AnyVectorIndexInstanceNS5_9allocatorIS8_EEEE(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v3;
  unint64_t v4;
  uint64_t v6;
  char *v7;
  char *v8;
  char *v9;
  unint64_t v10;
  char *v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  _BYTE *v18;
  char *v19;
  unint64_t v20;
  char *v21;
  uint64_t v22;
  _OWORD *v23;
  char *v24;
  uint64_t v25;
  __int128 v26;
  uint64_t v27;
  char *v28;
  char *v29;
  const char *v30;
  char *v31;
  char *v32;
  const char *v33;
  char *v34;
  const char *v35;
  uint64_t v36;
  uint64_t v37;

  v3 = *(_QWORD **)a2;
  v2 = *(_QWORD *)(a2 + 8);
  v4 = v2 - *(_QWORD *)a2;
  if (v2 == *(_QWORD *)a2)
  {
    v31 = __si_assert_copy_extra_268();
    v32 = v31;
    v33 = "";
    if (v31)
      v33 = v31;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3170, "vi.size() > 0", v33);
    goto LABEL_52;
  }
  if (*v3 != a1)
  {
    v34 = __si_assert_copy_extra_268();
    v32 = v34;
    v35 = "";
    if (v34)
      v35 = v34;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3171, "this == vi[0]", v35);
LABEL_52:
    free(v32);
    if (__valid_fs(-1))
      v36 = 2989;
    else
      v36 = 3072;
    *(_DWORD *)v36 = -559038737;
LABEL_56:
    abort();
  }
  v6 = a2;
  v7 = (char *)operator new(8uLL);
  v8 = v7;
  *(_QWORD *)v7 = a1 + 48;
  if (v4 < 9)
    goto LABEL_39;
  v9 = v7 + 8;
  v10 = 1;
  v11 = v7 + 8;
  v37 = v6;
  do
  {
    v13 = v3[v10];
    if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(v13 + 8)
      || *(unsigned __int16 *)(a1 + 20) != *(unsigned __int16 *)(v13 + 20)
      || *(_DWORD *)(a1 + 12) != *(_DWORD *)(v13 + 12)
      || *(_DWORD *)(a1 + 16) != *(_DWORD *)(v13 + 16))
    {
      v28 = __si_assert_copy_extra_268();
      v29 = v28;
      v30 = "";
      if (v28)
        v30 = v28;
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3075, "compatible", v30);
      free(v29);
      if (__valid_fs(-1))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
    v14 = v13 + 48;
    if (v9 < v11)
    {
      *(_QWORD *)v9 = v14;
      v12 = v9 + 8;
      goto LABEL_6;
    }
    v15 = (v9 - v8) >> 3;
    v16 = v15 + 1;
    if ((unint64_t)(v15 + 1) >> 61)
      goto LABEL_56;
    if ((v11 - v8) >> 2 > v16)
      v16 = (v11 - v8) >> 2;
    if ((unint64_t)(v11 - v8) >= 0x7FFFFFFFFFFFFFF8)
      v17 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v17 = v16;
    if (v17)
    {
      if (v17 >> 61)
        std::__throw_bad_array_new_length[abi:nn180100]();
      v18 = operator new(8 * v17);
    }
    else
    {
      v18 = 0;
    }
    v19 = &v18[8 * v15];
    v11 = &v18[8 * v17];
    *(_QWORD *)v19 = v14;
    v12 = v19 + 8;
    if (v9 == v8)
    {
LABEL_36:
      operator delete(v8);
      goto LABEL_37;
    }
    v20 = v9 - 8 - v8;
    if (v20 < 0x168)
    {
      v21 = v9;
      goto LABEL_34;
    }
    if (&v18[v9 - v8 - 8 - (v20 & 0xFFFFFFFFFFFFFFF8)] > &v18[v9 - v8 - 8])
    {
      v21 = v9;
      goto LABEL_34;
    }
    if (&v9[-(v20 & 0xFFFFFFFFFFFFFFF8) - 8] > v9 - 8)
    {
      v21 = v9;
      do
      {
LABEL_34:
        v27 = *((_QWORD *)v21 - 1);
        v21 -= 8;
        *((_QWORD *)v19 - 1) = v27;
        v19 -= 8;
      }
      while (v21 != v8);
      goto LABEL_35;
    }
    if ((unint64_t)(v8 - v18) < 0x20)
    {
      v21 = v9;
      goto LABEL_34;
    }
    v22 = (v20 >> 3) + 1;
    v21 = &v9[-8 * (v22 & 0x3FFFFFFFFFFFFFFCLL)];
    v23 = &v18[8 * v15 - 16];
    v24 = v9 - 16;
    v25 = v22 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v26 = *(_OWORD *)v24;
      *(v23 - 1) = *((_OWORD *)v24 - 1);
      *v23 = v26;
      v23 -= 2;
      v24 -= 32;
      v25 -= 4;
    }
    while (v25);
    v19 -= 8 * (v22 & 0x3FFFFFFFFFFFFFFCLL);
    if (v22 != (v22 & 0x3FFFFFFFFFFFFFFCLL))
      goto LABEL_34;
LABEL_35:
    if (v8)
      goto LABEL_36;
LABEL_37:
    v8 = v19;
    v6 = v37;
LABEL_6:
    ++v10;
    v3 = *(_QWORD **)v6;
    v9 = v12;
  }
  while (v10 < (uint64_t)(*(_QWORD *)(v6 + 8) - *(_QWORD *)v6) >> 3);
  if (v8)
LABEL_39:
    operator delete(v8);
}

uint64_t _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li512EE14mergeUpdateSetEPK22AnyVectorIndexInstanceP15PostingBaseInfoP17TermIdContainer_s(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v7;
  NSObject *v8;
  os_log_type_t v9;
  int v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  unsigned int v15;
  float v16;
  unsigned int v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  _QWORD *v22;
  uint64_t result;
  std::__shared_weak_count *v24;
  unint64_t *p_shared_owners;
  unint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  char *v30;
  char *v31;
  const char *v32;
  char *v33;
  const char *v34;
  _DWORD v35[4];
  void *__src;
  uint64_t v37;
  uint8_t buf[1032];
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)
    || *(unsigned __int16 *)(a1 + 20) != *(unsigned __int16 *)(a2 + 20)
    || *(_DWORD *)(a1 + 12) != *(_DWORD *)(a2 + 12)
    || *(_DWORD *)(a1 + 16) != *(_DWORD *)(a2 + 16))
  {
    v33 = __si_assert_copy_extra_268();
    v31 = v33;
    v34 = "";
    if (v33)
      v34 = v33;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3075, "compatible", v34);
LABEL_36:
    free(v31);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v7 = *__error();
  v8 = _SILogForLogForCategory(16);
  v9 = 2 * (dword_1EF19FCCC < 4);
  if (os_log_type_enabled(v8, v9))
  {
    v10 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
    v11 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
    v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
    v13 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 24))(a2);
    *(_DWORD *)buf = 67109888;
    *(_DWORD *)&buf[4] = v10;
    *(_WORD *)&buf[8] = 1024;
    *(_DWORD *)&buf[10] = v11;
    *(_WORD *)&buf[14] = 1024;
    *(_DWORD *)&buf[16] = v12;
    *(_WORD *)&buf[20] = 1024;
    *(_DWORD *)&buf[22] = v13;
    _os_log_impl(&dword_1B8270000, v8, v9, "mergeUpdateSet(termIds) %u vectors in %u partitions and %u vectors in %u partitions", buf, 0x1Au);
  }
  *__error() = v7;
  v14 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::enumerator(a2 + 48);
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::beginMerge(a1 + 48);
  while (1)
  {
    IVFVectorIndexTemplate<float,256>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::enumerator_s::next((uint64_t)v35, v14);
    if (!__src)
      break;
    v15 = v35[0];
    v16 = *(float *)&v35[1];
    v17 = v35[2];
    v18 = v37;
    memcpy(buf, __src, 0x400uLL);
    v20 = *(_QWORD *)(a4 + 8);
    v19 = *(_QWORD *)(a4 + 16);
    v21 = v20 + 1;
    if (v20 + 1 < v19)
    {
      v22 = *(_QWORD **)a4;
      goto LABEL_16;
    }
    if (v19)
    {
      if (v21 >= v19)
        goto LABEL_13;
    }
    else
    {
      *(_QWORD *)(a4 + 16) = 1024;
      v19 = 1024;
      if (v21 >= 0x400)
      {
        do
LABEL_13:
          v19 *= 2;
        while (v21 >= v19);
        *(_QWORD *)(a4 + 16) = v19;
      }
    }
    v22 = malloc_type_realloc(*(void **)a4, 24 * v19, 0x10200409F4E64B8uLL);
    *(_QWORD *)a4 = v22;
    v20 = *(_QWORD *)(a4 + 8);
    v21 = v20 + 1;
LABEL_16:
    v22[3 * v20 + 1] = v18;
    *(_QWORD *)(a4 + 8) = v21;
    if (*(_DWORD *)(a1 + 188) == -1)
    {
      v30 = __si_assert_copy_extra_268();
      v31 = v30;
      v32 = "";
      if (v30)
        v32 = v30;
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2689, "mergeBeginVectorOffset < VECTOR_NOT_FOUND", v32);
      goto LABEL_36;
    }
    _ZN22IVFVectorIndexTemplateIDF16_Li512EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE15lookupForInsertEjRK10CIVector_sIDF16_Li512EEjfb(a1 + 48, v17, buf, v15, v16);
  }
  result = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::endMerge(a1 + 48);
  if (v14)
  {
    std::deque<std::shared_ptr<AnyPartitionStore::Enumerator>>::~deque[abi:nn180100](v14 + 32);
    v24 = *(std::__shared_weak_count **)(v14 + 24);
    if (v24)
    {
      p_shared_owners = (unint64_t *)&v24->__shared_owners_;
      do
        v26 = __ldaxr(p_shared_owners);
      while (__stlxr(v26 - 1, p_shared_owners));
      if (!v26)
      {
        ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
        std::__shared_weak_count::__release_weak(v24);
      }
    }
    v27 = *(std::__shared_weak_count **)(v14 + 8);
    if (v27)
    {
      v28 = (unint64_t *)&v27->__shared_owners_;
      do
        v29 = __ldaxr(v28);
      while (__stlxr(v29 - 1, v28));
      if (!v29)
      {
        ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
        std::__shared_weak_count::__release_weak(v27);
      }
    }
    return MEMORY[0x1BCCB06A4](v14, 0x10A0C40B50FE552);
  }
  return result;
}

_DWORD *_ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li512EE14mergeUpdateSetEPK22AnyVectorIndexInstanceP15PostingBaseInfojy(_DWORD *result, uint64_t a2, char *a3, unsigned int a4, uint64_t a5)
{
  _DWORD *v6;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  _DWORD *inserted;
  unsigned int v16;
  const void *v17;
  unint64_t v18;
  char *v19;
  char *v20;
  const char *v21;
  int v22;
  NSObject *v23;
  int v24;
  int v25;
  int v26;
  int v27;
  _DWORD __dst[256];
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  if (result[2] != *(_DWORD *)(a2 + 8)
    || (v6 = result, *((unsigned __int16 *)result + 10) != *(unsigned __int16 *)(a2 + 20))
    || result[3] != *(_DWORD *)(a2 + 12)
    || result[4] != *(_DWORD *)(a2 + 16))
  {
    v19 = __si_assert_copy_extra_268();
    v20 = v19;
    v21 = "";
    if (v19)
      v21 = v19;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3075, "compatible", v21);
    free(v20);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  if (dword_1EF19FCCC >= 5)
  {
    v22 = *__error();
    v23 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      v24 = (*(uint64_t (**)(_DWORD *))(*(_QWORD *)v6 + 16))(v6);
      v25 = (*(uint64_t (**)(_DWORD *))(*(_QWORD *)v6 + 24))(v6);
      v26 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
      v27 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 24))(a2);
      __dst[0] = 67109888;
      __dst[1] = v24;
      LOWORD(__dst[2]) = 1024;
      *(_DWORD *)((char *)&__dst[2] + 2) = v25;
      HIWORD(__dst[3]) = 1024;
      __dst[4] = v26;
      LOWORD(__dst[5]) = 1024;
      *(_DWORD *)((char *)&__dst[5] + 2) = v27;
      _os_log_impl(&dword_1B8270000, v23, OS_LOG_TYPE_DEFAULT, "mergeUpdateSet(DocID) %u vectors in %u partitions and %u vectors in %u partitions", (uint8_t *)__dst, 0x1Au);
    }
    result = __error();
    *result = v22;
  }
  v9 = 0;
  v10 = *(_QWORD *)(a2 + 80);
  v11 = (uint64_t)(v6 + 12);
  v12 = a4;
  while (v9 != *(_DWORD *)(v10 + 24))
  {
    v16 = *(_DWORD *)(IVFVectorIndexTemplate<float,256>::VectorStore<vi_onefixedsize_memory_allocator,vi_memory_postings>::Iterator::operator->(v10, v9)+ 1040);
    v17 = (const void *)IVFVectorIndexTemplate<float,256>::VectorStore<vi_onefixedsize_memory_allocator,vi_memory_postings>::Iterator::operator->(v10, v9);
    memcpy(__dst, v17, sizeof(__dst));
    v18 = IVFVectorIndexTemplate<float,256>::VectorStore<vi_onefixedsize_memory_allocator,vi_memory_postings>::Iterator::operator->(v10, v9);
    if ((*(_BYTE *)(v18 + 1024) & 1) != 0)
    {
      if (*(_DWORD *)(v18 + 1028))
        v13 = 1;
      else
        v13 = 2;
      v14 = a5;
    }
    else
    {
      v13 = 0;
      v14 = v12;
    }
    inserted = _ZN22IVFVectorIndexTemplateIDF16_Li512EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE15lookupForInsertEjRK10CIVector_sIDF16_Li512EEjfb(v11, v16, __dst, 0xFFFFFFFF, 3.4028e38);
    result = vi_memory_postings::push_posting(a3, v13, inserted + 256, v14);
    ++v9;
  }
  return result;
}

uint64_t _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li512EE21mergeUpdateSetForTestEPK22AnyVectorIndexInstance(uint64_t a1, uint64_t a2)
{
  int v4;
  NSObject *v5;
  os_log_type_t v6;
  float v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  _DWORD *inserted;
  int v18;
  uint64_t result;
  std::__shared_weak_count *v20;
  unint64_t *p_shared_owners;
  unint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  char *v26;
  char *v27;
  const char *v28;
  char *v29;
  const char *v30;
  uint8_t buf[4];
  float v32;
  _BYTE v33[6];
  __int16 v34;
  __int128 v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)
    || *(unsigned __int16 *)(a1 + 20) != *(unsigned __int16 *)(a2 + 20)
    || *(_DWORD *)(a1 + 12) != *(_DWORD *)(a2 + 12)
    || *(_DWORD *)(a1 + 16) != *(_DWORD *)(a2 + 16))
  {
    v26 = __si_assert_copy_extra_268();
    v27 = v26;
    v28 = "";
    if (v26)
      v28 = v26;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3075, "compatible", v28);
LABEL_34:
    free(v27);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v4 = *__error();
  v5 = _SILogForLogForCategory(16);
  v6 = 2 * (dword_1EF19FCCC < 4);
  if (os_log_type_enabled(v5, v6))
  {
    LODWORD(v7) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
    v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
    v9 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
    v10 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 24))(a2);
    *(_DWORD *)buf = 67109888;
    v32 = v7;
    *(_WORD *)v33 = 1024;
    *(_DWORD *)&v33[2] = v8;
    v34 = 1024;
    LODWORD(v35) = v9;
    WORD2(v35) = 1024;
    *(_DWORD *)((char *)&v35 + 6) = v10;
    _os_log_impl(&dword_1B8270000, v5, v6, "mergeUpdateSetForTest %u vectors in %u partitions and %u vectors in %u partitions", buf, 0x1Au);
  }
  *__error() = v4;
  v11 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::enumerator(a2 + 48);
  v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  v13 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::beginMerge(a1 + 48);
  v14 = 0;
  while (1)
  {
    IVFVectorIndexTemplate<float,256>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::enumerator_s::next((uint64_t)buf, v11);
    if (!(_QWORD)v35)
      break;
    v16 = *(_DWORD *)(*((_QWORD *)&v35 + 1) + 8);
    inserted = _ZN22IVFVectorIndexTemplateIDF16_Li512EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE15lookupForInsertEjRK10CIVector_sIDF16_Li512EEjfb(a1 + 48, *(unsigned int *)v33, (const void *)v35, *(unsigned int *)buf, v32);
    v18 = inserted[258];
    if (v18)
    {
      v15 = inserted[257] + 1;
    }
    else
    {
      inserted[258] = v16;
      v15 = 1;
    }
    inserted[257] = v15;
    if (v18)
      ++v14;
  }
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::endMerge(a1 + 48);
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  if ((_DWORD)result + v14 != v13 + v12)
  {
    v29 = __si_assert_copy_extra_268();
    v27 = v29;
    v30 = "";
    if (v29)
      v30 = v29;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3267, "nVectors() + dup == old + added", v30);
    goto LABEL_34;
  }
  if (v11)
  {
    std::deque<std::shared_ptr<AnyPartitionStore::Enumerator>>::~deque[abi:nn180100](v11 + 32);
    v20 = *(std::__shared_weak_count **)(v11 + 24);
    if (v20)
    {
      p_shared_owners = (unint64_t *)&v20->__shared_owners_;
      do
        v22 = __ldaxr(p_shared_owners);
      while (__stlxr(v22 - 1, p_shared_owners));
      if (!v22)
      {
        ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
        std::__shared_weak_count::__release_weak(v20);
      }
    }
    v23 = *(std::__shared_weak_count **)(v11 + 8);
    if (v23)
    {
      v24 = (unint64_t *)&v23->__shared_owners_;
      do
        v25 = __ldaxr(v24);
      while (__stlxr(v25 - 1, v24));
      if (!v25)
      {
        ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
        std::__shared_weak_count::__release_weak(v23);
      }
    }
    return MEMORY[0x1BCCB06A4](v11, 0x10A0C40B50FE552);
  }
  return result;
}

uint64_t _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li512EE17mergeIndexForTestEP22AnyVectorIndexInstance(uint64_t a1, uint64_t a2)
{
  int v4;
  NSObject *v5;
  os_log_type_t v6;
  float v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  _DWORD *inserted;
  int v18;
  uint64_t result;
  std::__shared_weak_count *v20;
  unint64_t *p_shared_owners;
  unint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  char *v26;
  char *v27;
  const char *v28;
  char *v29;
  const char *v30;
  uint8_t buf[4];
  float v32;
  _BYTE v33[6];
  __int16 v34;
  __int128 v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)
    || *(unsigned __int16 *)(a1 + 20) != *(unsigned __int16 *)(a2 + 20)
    || *(_DWORD *)(a1 + 12) != *(_DWORD *)(a2 + 12)
    || *(_DWORD *)(a1 + 16) != *(_DWORD *)(a2 + 16))
  {
    v26 = __si_assert_copy_extra_268();
    v27 = v26;
    v28 = "";
    if (v26)
      v28 = v26;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3075, "compatible", v28);
LABEL_34:
    free(v27);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v4 = *__error();
  v5 = _SILogForLogForCategory(16);
  v6 = 2 * (dword_1EF19FCCC < 4);
  if (os_log_type_enabled(v5, v6))
  {
    LODWORD(v7) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
    v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
    v9 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
    v10 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 24))(a2);
    *(_DWORD *)buf = 67109888;
    v32 = v7;
    *(_WORD *)v33 = 1024;
    *(_DWORD *)&v33[2] = v8;
    v34 = 1024;
    LODWORD(v35) = v9;
    WORD2(v35) = 1024;
    *(_DWORD *)((char *)&v35 + 6) = v10;
    _os_log_impl(&dword_1B8270000, v5, v6, "mergeIndexForTest %u vectors in %u partitions and %u vectors in %u partitions", buf, 0x1Au);
  }
  *__error() = v4;
  v11 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::enumerator(a2 + 48);
  v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  v13 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::beginMerge(a1 + 48);
  v14 = 0;
  while (1)
  {
    IVFVectorIndexTemplate<float,256>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::enumerator_s::next((uint64_t)buf, v11);
    if (!(_QWORD)v35)
      break;
    v16 = **((_QWORD **)&v35 + 1);
    inserted = _ZN22IVFVectorIndexTemplateIDF16_Li512EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE15lookupForInsertEjRK10CIVector_sIDF16_Li512EEjfb(a1 + 48, *(unsigned int *)v33, (const void *)v35, *(unsigned int *)buf, v32);
    v18 = inserted[258];
    if (v18)
    {
      v15 = inserted[257] + 1;
    }
    else
    {
      inserted[258] = v16;
      v15 = 1;
    }
    inserted[257] = v15;
    if (v18)
      ++v14;
  }
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::endMerge(a1 + 48);
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  if ((_DWORD)result + v14 != v13 + v12)
  {
    v29 = __si_assert_copy_extra_268();
    v27 = v29;
    v30 = "";
    if (v29)
      v30 = v29;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3281, "nVectors() + dup == old + added", v30);
    goto LABEL_34;
  }
  if (v11)
  {
    std::deque<std::shared_ptr<AnyPartitionStore::Enumerator>>::~deque[abi:nn180100](v11 + 32);
    v20 = *(std::__shared_weak_count **)(v11 + 24);
    if (v20)
    {
      p_shared_owners = (unint64_t *)&v20->__shared_owners_;
      do
        v22 = __ldaxr(p_shared_owners);
      while (__stlxr(v22 - 1, p_shared_owners));
      if (!v22)
      {
        ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
        std::__shared_weak_count::__release_weak(v20);
      }
    }
    v23 = *(std::__shared_weak_count **)(v11 + 8);
    if (v23)
    {
      v24 = (unint64_t *)&v23->__shared_owners_;
      do
        v25 = __ldaxr(v24);
      while (__stlxr(v25 - 1, v24));
      if (!v25)
      {
        ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
        std::__shared_weak_count::__release_weak(v23);
      }
    }
    return MEMORY[0x1BCCB06A4](v11, 0x10A0C40B50FE552);
  }
  return result;
}

void _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li512EE4dumpEbbPViPvU13block_pointerFbjPKvybjfE(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  os_unfair_lock_s *v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  std::__shared_weak_count *v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  uint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  unint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  unint64_t *v33;
  unint64_t v34;
  unint64_t *v35;
  unint64_t v36;
  _QWORD v37[2];
  void (*v38)();
  void *v39;
  uint64_t v40;
  uint64_t v41;
  _QWORD v42[2];
  uint64_t v43;
  std::__shared_weak_count *v44;
  __int128 v45;
  __int128 v46;
  _OWORD v47[3];
  __int128 v48;
  __int128 v49;
  char v50;
  __int128 v51;
  __int128 v52;

  v9 = (os_unfair_lock_s *)(a1 + 144);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 144));
  v10 = *(std::__shared_weak_count **)(a1 + 120);
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }
  v14 = *(_QWORD *)(a1 + 128);
  v13 = *(std::__shared_weak_count **)(a1 + 136);
  if (v13)
  {
    v15 = (unint64_t *)&v13->__shared_owners_;
    do
      v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
  }
  os_unfair_lock_unlock(v9);
  v46 = 0u;
  memset(v47, 0, sizeof(v47));
  v45 = 0u;
  v43 = v14;
  v44 = v13;
  if (v13)
  {
    v17 = (unint64_t *)&v13->__shared_owners_;
    do
      v18 = __ldxr(v17);
    while (__stxr(v18 + 1, v17));
  }
  v19 = *(_QWORD *)(a1 + 80);
  v20 = *(std::__shared_weak_count **)(a1 + 88);
  v42[0] = v19;
  v42[1] = v20;
  if (v20)
  {
    v21 = (unint64_t *)&v20->__shared_owners_;
    do
      v22 = __ldxr(v21);
    while (__stxr(v22 + 1, v21));
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::enumerator_s::enumerator_s((uint64_t)&v45, &v43, v42);
    do
      v23 = __ldaxr(v21);
    while (__stlxr(v23 - 1, v21));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
  else
  {
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::enumerator_s::enumerator_s((uint64_t)&v45, &v43, v42);
  }
  v24 = v44;
  if (v44)
  {
    v25 = (unint64_t *)&v44->__shared_owners_;
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }
  v37[0] = MEMORY[0x1E0C809B0];
  v37[1] = 0x40000000;
  v38 = ___ZNK22IVFVectorIndexTemplateIDF16_Li512EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE4dumpEbbPViPvU13block_pointerFbjPKvybjfE_block_invoke;
  v39 = &unk_1E6E31900;
  v40 = a6;
  v41 = a4;
  v51 = 0u;
  v52 = 0u;
  v50 = 0;
  do
  {
    IVFVectorIndexTemplate<float,256>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::enumerator_s::next((uint64_t)&v48, (uint64_t)&v45);
    v51 = v48;
    v52 = v49;
    if (!(_QWORD)v49)
      break;
    ((void (*)(_QWORD *, __int128 *, char *))v38)(v37, &v51, &v50);
  }
  while (!v50);
  std::deque<std::shared_ptr<AnyPartitionStore::Enumerator>>::~deque[abi:nn180100]((uint64_t)v47);
  v27 = (std::__shared_weak_count *)*((_QWORD *)&v46 + 1);
  if (!*((_QWORD *)&v46 + 1))
    goto LABEL_30;
  v28 = (unint64_t *)(*((_QWORD *)&v46 + 1) + 8);
  do
    v29 = __ldaxr(v28);
  while (__stlxr(v29 - 1, v28));
  if (!v29)
  {
    ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
    std::__shared_weak_count::__release_weak(v27);
    v30 = (std::__shared_weak_count *)*((_QWORD *)&v45 + 1);
    if (!*((_QWORD *)&v45 + 1))
      goto LABEL_36;
  }
  else
  {
LABEL_30:
    v30 = (std::__shared_weak_count *)*((_QWORD *)&v45 + 1);
    if (!*((_QWORD *)&v45 + 1))
      goto LABEL_36;
  }
  v31 = (unint64_t *)&v30->__shared_owners_;
  do
    v32 = __ldaxr(v31);
  while (__stlxr(v32 - 1, v31));
  if (!v32)
  {
    ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
    std::__shared_weak_count::__release_weak(v30);
  }
  if (!v13)
    goto LABEL_40;
LABEL_36:
  v33 = (unint64_t *)&v13->__shared_owners_;
  do
    v34 = __ldaxr(v33);
  while (__stlxr(v34 - 1, v33));
  if (!v34)
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
    if (!v10)
      return;
  }
  else
  {
LABEL_40:
    if (!v10)
      return;
  }
  v35 = (unint64_t *)&v10->__shared_owners_;
  do
    v36 = __ldaxr(v35);
  while (__stlxr(v36 - 1, v35));
  if (!v36)
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
}

void _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li512EE5flushEy(uint64_t a1, uint64_t a2)
{
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::flush(a1 + 48, a2);
}

int *_ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li512EE7compactEP22AnyVectorIndexInstanceP12uint32_map_tP11TermIdStore18CICompactCallbacksPVi(uint64_t a1, uint64_t a2)
{
  int v4;
  NSObject *v5;
  os_log_type_t v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int *result;
  char *v12;
  char *v13;
  const char *v14;
  uint8_t buf[4];
  int v16;
  __int16 v17;
  int v18;
  __int16 v19;
  int v20;
  __int16 v21;
  int v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v4 = *__error();
  v5 = _SILogForLogForCategory(16);
  v6 = 2 * (dword_1EF19FCCC < 4);
  if (os_log_type_enabled(v5, v6))
  {
    v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
    v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
    v9 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
    v10 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 24))(a2);
    *(_DWORD *)buf = 67109888;
    v16 = v7;
    v17 = 1024;
    v18 = v8;
    v19 = 1024;
    v20 = v9;
    v21 = 1024;
    v22 = v10;
    _os_log_impl(&dword_1B8270000, v5, v6, "compact %u vectors in %u partitions and %u vectors in %u partitions", buf, 0x1Au);
  }
  result = __error();
  *result = v4;
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)
    || *(unsigned __int16 *)(a1 + 20) != *(unsigned __int16 *)(a2 + 20)
    || *(_DWORD *)(a1 + 12) != *(_DWORD *)(a2 + 12)
    || *(_DWORD *)(a1 + 16) != *(_DWORD *)(a2 + 16))
  {
    v12 = __si_assert_copy_extra_268();
    v13 = v12;
    v14 = "";
    if (v12)
      v14 = v12;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3075, "compatible", v14);
    free(v13);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  return result;
}

void _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li512EE14compactForTestEP22AnyVectorIndexInstancePVi(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6;
  NSObject *v7;
  os_log_type_t v8;
  int v9;
  int v10;
  int v11;
  int v12;
  char *v13;
  char *v14;
  const char *v15;
  uint8_t buf[4];
  int v17;
  __int16 v18;
  int v19;
  __int16 v20;
  int v21;
  __int16 v22;
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)
    || *(unsigned __int16 *)(a1 + 20) != *(unsigned __int16 *)(a2 + 20)
    || *(_DWORD *)(a1 + 12) != *(_DWORD *)(a2 + 12)
    || *(_DWORD *)(a1 + 16) != *(_DWORD *)(a2 + 16))
  {
    v13 = __si_assert_copy_extra_268();
    v14 = v13;
    v15 = "";
    if (v13)
      v15 = v13;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3075, "compatible", v15);
    free(v14);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v6 = *__error();
  v7 = _SILogForLogForCategory(16);
  v8 = 2 * (dword_1EF19FCCC < 4);
  if (os_log_type_enabled(v7, v8))
  {
    v9 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
    v10 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
    v11 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
    v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 24))(a2);
    *(_DWORD *)buf = 67109888;
    v17 = v9;
    v18 = 1024;
    v19 = v10;
    v20 = 1024;
    v21 = v11;
    v22 = 1024;
    v23 = v12;
    _os_log_impl(&dword_1B8270000, v7, v8, "compactForTest %u vectors in %u partitions and %u vectors in %u partitions", buf, 0x1Au);
  }
  *__error() = v6;
  _ZN22IVFVectorIndexTemplateIDF16_Li512EE20IVFVectorIndexRoot_sI30vi_onefixedsize_disk_allocator16vi_disk_postingsE14compactForTestIS2_EENSt3__19enable_ifIXsr13is_persistentIT_EE5valueEbE4typeEPS4_PVi(a1 + 48, a2 + 48, a3);
}

void _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li512EE7subvertEPK22AnyVectorIndexInstance(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  os_unfair_lock_s *v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  uint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  unint64_t *v26;
  unint64_t v27;
  char *v28;
  char *v29;
  const char *v30;

  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)
    || *(unsigned __int16 *)(a1 + 20) != *(unsigned __int16 *)(a2 + 20)
    || *(_DWORD *)(a1 + 12) != *(_DWORD *)(a2 + 12)
    || *(_DWORD *)(a1 + 16) != *(_DWORD *)(a2 + 16))
  {
    v28 = __si_assert_copy_extra_268();
    v29 = v28;
    v30 = "";
    if (v28)
      v30 = v28;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3075, "compatible", v30);
    free(v29);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v4 = (os_unfair_lock_s *)(a1 + 144);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 144));
  v5 = *(std::__shared_weak_count **)(a1 + 120);
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  v9 = *(_QWORD *)(a1 + 128);
  v8 = *(std::__shared_weak_count **)(a1 + 136);
  if (v8)
  {
    v10 = (unint64_t *)&v8->__shared_owners_;
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }
  os_unfair_lock_unlock(v4);
  if (v5)
  {
    v12 = (unint64_t *)&v5->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  v14 = (os_unfair_lock_s *)(a2 + 144);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 144));
  v15 = *(std::__shared_weak_count **)(a2 + 120);
  if (v15)
  {
    v16 = (unint64_t *)&v15->__shared_owners_;
    do
      v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
  }
  v19 = *(_QWORD *)(a2 + 128);
  v18 = *(std::__shared_weak_count **)(a2 + 136);
  if (v18)
  {
    v20 = (unint64_t *)&v18->__shared_owners_;
    do
      v21 = __ldxr(v20);
    while (__stxr(v21 + 1, v20));
  }
  os_unfair_lock_unlock(v14);
  if (v15)
  {
    v22 = (unint64_t *)&v15->__shared_owners_;
    do
      v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v9 + 168))(v9, v19);
  if (!v18)
    goto LABEL_31;
  v24 = (unint64_t *)&v18->__shared_owners_;
  do
    v25 = __ldaxr(v24);
  while (__stlxr(v25 - 1, v24));
  if (!v25)
  {
    ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
    std::__shared_weak_count::__release_weak(v18);
    if (!v8)
      return;
  }
  else
  {
LABEL_31:
    if (!v8)
      return;
  }
  v26 = (unint64_t *)&v8->__shared_owners_;
  do
    v27 = __ldaxr(v26);
  while (__stlxr(v27 - 1, v26));
  if (!v27)
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
}

uint64_t _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li512EE6unlinkEv(uint64_t a1)
{
  os_unfair_lock_s *v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  uint64_t v10;
  int v11;
  NSObject *v12;
  _QWORD *v13;
  int v14;
  int v15;
  int v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  int v22;
  _QWORD *v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int v27;
  __int16 v28;
  int v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v2 = (os_unfair_lock_s *)(a1 + 144);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 144));
  v3 = *(std::__shared_weak_count **)(a1 + 120);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  v7 = *(_QWORD *)(a1 + 128);
  v6 = *(std::__shared_weak_count **)(a1 + 136);
  if (v6)
  {
    v8 = (unint64_t *)&v6->__shared_owners_;
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  os_unfair_lock_unlock(v2);
  (*(void (**)(uint64_t))(*(_QWORD *)v7 + 176))(v7);
  v10 = *(_QWORD *)(a1 + 80);
  v11 = *__error();
  v12 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    v13 = (_QWORD *)(v10 + 40);
    if (*(char *)(v10 + 63) < 0)
      v13 = (_QWORD *)*v13;
    v14 = *(_DWORD *)(v10 + 24);
    v15 = *(_DWORD *)(vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(v10 + 16), 0, 1044) + 1040);
    v16 = *(_DWORD *)(vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(v10 + 16), (*(_DWORD *)(v10 + 24) - 1), 1044)+ 1040);
    v22 = 136315906;
    v23 = v13;
    v24 = 1024;
    v25 = v14;
    v26 = 1024;
    v27 = v15;
    v28 = 1024;
    v29 = v16;
    _os_log_impl(&dword_1B8270000, v12, OS_LOG_TYPE_DEFAULT, "unlink VectorStore %s(%u)[%u,%u]", (uint8_t *)&v22, 0x1Eu);
  }
  *__error() = v11;
  if (v6)
  {
    v17 = (unint64_t *)&v6->__shared_owners_;
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  if (v3)
  {
    v19 = (unint64_t *)&v3->__shared_owners_;
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  return 1;
}

void _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li512EE8truncateEv(uint64_t a1)
{
  int v1;
  NSObject *v2;
  os_log_type_t v3;
  os_unfair_lock_s *v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  uint8_t v16[16];

  if (*(_BYTE *)(a1 + 192))
  {
    v1 = *__error();
    v2 = _SILogForLogForCategory(16);
    v3 = dword_1EF19FCCC < 3;
    if (os_log_type_enabled(v2, (os_log_type_t)(dword_1EF19FCCC < 3)))
    {
      *(_WORD *)v16 = 0;
      _os_log_impl(&dword_1B8270000, v2, v3, "*warn* call truncate on readOnly index.", v16, 2u);
    }
    *__error() = v1;
  }
  else
  {
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::flush(a1 + 48, 0);
    IVFVectorIndexTemplate<float,256>::VectorStore<vi_onefixedsize_memory_allocator,vi_memory_postings>::truncate(*(_QWORD *)(a1 + 80));
    v5 = (os_unfair_lock_s *)(a1 + 144);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 144));
    v6 = *(std::__shared_weak_count **)(a1 + 120);
    if (v6)
    {
      p_shared_owners = (unint64_t *)&v6->__shared_owners_;
      do
        v8 = __ldxr(p_shared_owners);
      while (__stxr(v8 + 1, p_shared_owners));
    }
    v10 = *(_QWORD *)(a1 + 128);
    v9 = *(std::__shared_weak_count **)(a1 + 136);
    if (v9)
    {
      v11 = (unint64_t *)&v9->__shared_owners_;
      do
        v12 = __ldxr(v11);
      while (__stxr(v12 + 1, v11));
      os_unfair_lock_unlock(v5);
      (*(void (**)(uint64_t))(*(_QWORD *)v10 + 136))(v10);
      do
        v13 = __ldaxr(v11);
      while (__stlxr(v13 - 1, v11));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
    else
    {
      os_unfair_lock_unlock(v5);
      (*(void (**)(uint64_t))(*(_QWORD *)v10 + 136))(v10);
    }
    if (v6)
    {
      v14 = (unint64_t *)&v6->__shared_owners_;
      do
        v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }
}

void _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li512EE12makeReadOnlyEv(uint64_t a1)
{
  int v1;
  NSObject *v2;
  os_log_type_t v3;
  uint64_t v5;
  int v6;
  NSObject *v7;
  _QWORD *v8;
  int v9;
  int v10;
  int v11;
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  std::__shared_weak_count *v15;
  uint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  int v22;
  _QWORD *v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int v27;
  __int16 v28;
  int v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 192))
  {
    v1 = *__error();
    v2 = _SILogForLogForCategory(16);
    v3 = dword_1EF19FCCC < 3;
    if (os_log_type_enabled(v2, (os_log_type_t)(dword_1EF19FCCC < 3)))
    {
      LOWORD(v22) = 0;
      _os_log_impl(&dword_1B8270000, v2, v3, "*warn* call makeReadOnly on readOnly index.", (uint8_t *)&v22, 2u);
    }
    *__error() = v1;
  }
  else
  {
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::flush(a1 + 48, 0);
    v5 = *(_QWORD *)(a1 + 80);
    v6 = *__error();
    v7 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      v8 = (_QWORD *)(v5 + 40);
      if (*(char *)(v5 + 63) < 0)
        v8 = (_QWORD *)*v8;
      v9 = *(_DWORD *)(v5 + 24);
      v10 = *(_DWORD *)(vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(v5 + 16), 0, 1044) + 1040);
      v11 = *(_DWORD *)(vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(v5 + 16), (*(_DWORD *)(v5 + 24) - 1), 1044)+ 1040);
      v22 = 136315906;
      v23 = v8;
      v24 = 1024;
      v25 = v9;
      v26 = 1024;
      v27 = v10;
      v28 = 1024;
      v29 = v11;
      _os_log_impl(&dword_1B8270000, v7, OS_LOG_TYPE_DEFAULT, "makeReadOnly VectorStore %s(%u)[%u,%u]", (uint8_t *)&v22, 0x1Eu);
    }
    *__error() = v6;
    IVFVectorIndexTemplate<float,256>::VectorStore<vi_onefixedsize_memory_allocator,vi_memory_postings>::truncate(v5);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 144));
    v12 = *(std::__shared_weak_count **)(a1 + 120);
    if (v12)
    {
      p_shared_owners = (unint64_t *)&v12->__shared_owners_;
      do
        v14 = __ldxr(p_shared_owners);
      while (__stxr(v14 + 1, p_shared_owners));
    }
    v16 = *(_QWORD *)(a1 + 128);
    v15 = *(std::__shared_weak_count **)(a1 + 136);
    if (v15)
    {
      v17 = (unint64_t *)&v15->__shared_owners_;
      do
        v18 = __ldxr(v17);
      while (__stxr(v18 + 1, v17));
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 144));
      (*(void (**)(uint64_t))(*(_QWORD *)v16 + 120))(v16);
      *(_BYTE *)(a1 + 192) = 1;
      do
        v19 = __ldaxr(v17);
      while (__stlxr(v19 - 1, v17));
      if (!v19)
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
    }
    else
    {
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 144));
      (*(void (**)(uint64_t))(*(_QWORD *)v16 + 120))(v16);
      *(_BYTE *)(a1 + 192) = 1;
    }
    if (v12)
    {
      v20 = (unint64_t *)&v12->__shared_owners_;
      do
        v21 = __ldaxr(v20);
      while (__stlxr(v21 - 1, v20));
      if (!v21)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
  }
}

void _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li512EE13makePurgeableEv(uint64_t a1)
{
  uint64_t v2;
  int v3;
  NSObject *v4;
  _QWORD *v5;
  int v6;
  int v7;
  int v8;
  os_unfair_lock_s *v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  std::__shared_weak_count *v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  int v20;
  _QWORD *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 80);
  v3 = *__error();
  v4 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v5 = (_QWORD *)(v2 + 40);
    if (*(char *)(v2 + 63) < 0)
      v5 = (_QWORD *)*v5;
    v6 = *(_DWORD *)(v2 + 24);
    v7 = *(_DWORD *)(vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(v2 + 16), 0, 1044) + 1040);
    v8 = *(_DWORD *)(vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(v2 + 16), (*(_DWORD *)(v2 + 24) - 1), 1044)+ 1040);
    v20 = 136315906;
    v21 = v5;
    v22 = 1024;
    v23 = v6;
    v24 = 1024;
    v25 = v7;
    v26 = 1024;
    v27 = v8;
    _os_log_impl(&dword_1B8270000, v4, OS_LOG_TYPE_DEFAULT, "makePurgeable VectorStore %s(%u)[%u,%u]", (uint8_t *)&v20, 0x1Eu);
  }
  *__error() = v3;
  v9 = (os_unfair_lock_s *)(a1 + 144);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 144));
  v10 = *(std::__shared_weak_count **)(a1 + 120);
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }
  v14 = *(_QWORD *)(a1 + 128);
  v13 = *(std::__shared_weak_count **)(a1 + 136);
  if (!v13)
  {
    os_unfair_lock_unlock(v9);
    (*(void (**)(uint64_t))(*(_QWORD *)v14 + 128))(v14);
    if (!v10)
      return;
    goto LABEL_18;
  }
  v15 = (unint64_t *)&v13->__shared_owners_;
  do
    v16 = __ldxr(v15);
  while (__stxr(v16 + 1, v15));
  os_unfair_lock_unlock(v9);
  (*(void (**)(uint64_t))(*(_QWORD *)v14 + 128))(v14);
  do
    v17 = __ldaxr(v15);
  while (__stlxr(v17 - 1, v15));
  if (!v17)
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  if (v10)
  {
LABEL_18:
    v18 = (unint64_t *)&v10->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
}

void _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li512EE6renameEPKc(uint64_t a1, const char *a2)
{
  int v4;
  NSObject *v5;
  size_t v6;
  std::string::size_type v7;
  std::string *p_buf;
  uint64_t v9;
  uint64_t v10;
  int v11;
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  std::__shared_weak_count *v15;
  uint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  std::string *v19;
  uint64_t v20;
  int v21;
  NSObject *v22;
  _QWORD *v23;
  int v24;
  int v25;
  int v26;
  unint64_t *v27;
  unint64_t v28;
  unint64_t *v29;
  unint64_t v30;
  std::string::value_type __s[23];
  char v32;
  std::string v33;
  std::string buf;
  int v35;
  __int16 v36;
  int v37;
  __int16 v38;
  int v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  v4 = *__error();
  v5 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
    _os_log_impl(&dword_1B8270000, v5, OS_LOG_TYPE_DEFAULT, "rename: %s", (uint8_t *)&buf, 0xCu);
  }
  *__error() = v4;
  v6 = strlen(a2);
  if (v6 >= 0x7FFFFFFFFFFFFFF8)
    abort();
  v7 = v6;
  if (v6 >= 0x17)
  {
    v9 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v6 | 7) != 0x17)
      v9 = v6 | 7;
    v10 = v9 + 1;
    p_buf = (std::string *)operator new(v9 + 1);
    buf.__r_.__value_.__l.__size_ = v7;
    buf.__r_.__value_.__r.__words[2] = v10 | 0x8000000000000000;
    buf.__r_.__value_.__r.__words[0] = (std::string::size_type)p_buf;
    goto LABEL_10;
  }
  *((_BYTE *)&buf.__r_.__value_.__s + 23) = v6;
  p_buf = &buf;
  if (v6)
LABEL_10:
    memcpy(p_buf, a2, v7);
  p_buf->__r_.__value_.__s.__data_[v7] = 0;
  v32 = 11;
  strcpy(__s, ".partitions");
  memset(&v33, 0, sizeof(v33));
  v11 = SHIBYTE(buf.__r_.__value_.__r.__words[2]);
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(&v33, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
  else
    v33 = buf;
  std::string::append(&v33, __s, 0xBuLL);
  if (v32 < 0)
  {
    operator delete(*(void **)__s);
    if ((v11 & 0x80000000) == 0)
      goto LABEL_16;
  }
  else if ((v11 & 0x80000000) == 0)
  {
    goto LABEL_16;
  }
  operator delete(buf.__r_.__value_.__l.__data_);
LABEL_16:
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 144));
  v12 = *(std::__shared_weak_count **)(a1 + 120);
  if (v12)
  {
    p_shared_owners = (unint64_t *)&v12->__shared_owners_;
    do
      v14 = __ldxr(p_shared_owners);
    while (__stxr(v14 + 1, p_shared_owners));
  }
  v16 = *(_QWORD *)(a1 + 128);
  v15 = *(std::__shared_weak_count **)(a1 + 136);
  if (v15)
  {
    v17 = (unint64_t *)&v15->__shared_owners_;
    do
      v18 = __ldxr(v17);
    while (__stxr(v18 + 1, v17));
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 144));
  if ((v33.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v19 = &v33;
  else
    v19 = (std::string *)v33.__r_.__value_.__r.__words[0];
  (*(void (**)(uint64_t, std::string *))(*(_QWORD *)v16 + 152))(v16, v19);
  v20 = *(_QWORD *)(a1 + 80);
  v21 = *__error();
  v22 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    v23 = (_QWORD *)(v20 + 40);
    if (*(char *)(v20 + 63) < 0)
      v23 = (_QWORD *)*v23;
    v24 = *(_DWORD *)(v20 + 24);
    v25 = *(_DWORD *)(vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(v20 + 16), 0, 1044) + 1040);
    v26 = *(_DWORD *)(vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(v20 + 16), (*(_DWORD *)(v20 + 24) - 1), 1044)+ 1040);
    LODWORD(buf.__r_.__value_.__l.__data_) = 136316162;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v23;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)a2;
    HIWORD(buf.__r_.__value_.__r.__words[2]) = 1024;
    v35 = v24;
    v36 = 1024;
    v37 = v25;
    v38 = 1024;
    v39 = v26;
    _os_log_impl(&dword_1B8270000, v22, OS_LOG_TYPE_DEFAULT, "rename VectorStore %s -> %s(%u)[%u,%u]", (uint8_t *)&buf, 0x28u);
  }
  *__error() = v21;
  MEMORY[0x1BCCB03B0](v20 + 40, a2);
  if (v15)
  {
    v27 = (unint64_t *)&v15->__shared_owners_;
    do
      v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  if (!v12)
    goto LABEL_38;
  v29 = (unint64_t *)&v12->__shared_owners_;
  do
    v30 = __ldaxr(v29);
  while (__stlxr(v30 - 1, v29));
  if (v30)
  {
LABEL_38:
    if ((SHIBYTE(v33.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      return;
    goto LABEL_39;
  }
  ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
  std::__shared_weak_count::__release_weak(v12);
  if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0)
LABEL_39:
    operator delete(v33.__r_.__value_.__l.__data_);
}

_QWORD *_ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li512EE14storeUpdateSetEP15RelativePostingP14store_stream_t(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  _QWORD *result;
  unsigned int v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  char *v12;
  size_t v13;
  uint64_t v14;
  char *v15;
  char *v16;
  const char *v17;
  uint64_t v18;

  result = store_stream_write_vint32_2186(a3, *(_DWORD *)(*(_QWORD *)(a1 + 80) + 24));
  v7 = 0;
  v8 = *(_QWORD *)(a1 + 80);
  while (v7 != *(_DWORD *)(v8 + 24))
  {
    v9 = IVFVectorIndexTemplate<float,256>::VectorStore<vi_onefixedsize_memory_allocator,vi_memory_postings>::Iterator::operator*(v8, v7);
    CIWritePostings((uint64_t)a3, a2, 0, (unsigned int *)(v9 + 1024), 0, 0);
    v11 = *((_QWORD *)a3 + 4);
    v10 = *((_QWORD *)a3 + 5);
    if (v10 + 1024 >= v11)
    {
      v13 = 1024;
      v12 = (char *)v9;
      while (1)
      {
        v14 = v11 - v10;
        memcpy((void *)(*((_QWORD *)a3 + 6) + v10), v12, v11 - v10);
        *((_QWORD *)a3 + 5) += v14;
        if (store_stream_flush(a3, 0))
          break;
        v12 += v14;
        v13 -= v14;
        v11 = *((_QWORD *)a3 + 4);
        v10 = *((_QWORD *)a3 + 5);
        if (v10 + v13 < v11)
          goto LABEL_5;
      }
    }
    else
    {
      v12 = (char *)v9;
      v13 = 1024;
LABEL_5:
      memcpy((void *)(*((_QWORD *)a3 + 6) + v10), v12, v13);
      *((_QWORD *)a3 + 5) += v13;
    }
    result = store_stream_write_vint32_2186(a3, *(_DWORD *)(v9 + 1040));
    ++v7;
    if (v8 != *(_QWORD *)(a1 + 80))
    {
      v15 = __si_assert_copy_extra_268();
      v16 = v15;
      v17 = "";
      if (v15)
        v17 = v15;
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1814, "store == other.store", v17);
      free(v16);
      if (__valid_fs(-1))
        v18 = 2989;
      else
        v18 = 3072;
      *(_DWORD *)v18 = -559038737;
      abort();
    }
  }
  return result;
}

uint64_t _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li512EE16restoreUpdateSetEP15PostingBaseInfoP14store_stream_t(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  uint64_t result;
  int v6;
  _BYTE *v7;
  unint64_t v8;
  size_t v9;
  size_t v10;
  unsigned int vint32;
  uint64_t v12;
  uint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  _DWORD *inserted;
  unint64_t v21;
  _DWORD *v22;
  unint64_t *v23;
  unint64_t v24;
  __int16 v25;
  int v26;
  char *v27;
  unint64_t v28;
  uint64_t v29;
  void *v30;
  unint64_t v31;
  uint64_t v32;
  int *v33;
  off_t v34;
  size_t v35;
  void *v36;
  size_t v37;
  unint64_t v38;
  uint64_t v39;
  int *v40;
  char v41;
  off_t v42;
  off_t v43;
  off_t __offseta;
  unsigned int __offsetb;
  uint64_t v46;
  int v47;
  int v49;
  _BYTE __dst[1024];
  uint64_t v51;
  uint64_t v52;
  _BYTE v53[2];
  __int16 v54;

  result = store_stream_read_vint32((uint64_t)a3);
  v47 = result;
  if ((_DWORD)result)
  {
    v6 = 0;
    v46 = a1 + 48;
    do
    {
      v51 = 0;
      v52 = 0;
      v7 = __dst;
      bzero(__dst, 0x400uLL);
      v49 = 0;
      CIReadPostings(a3, a2, (uint64_t)&v51, &v49);
      v8 = *((_QWORD *)a3 + 4);
      v9 = *((_QWORD *)a3 + 5);
      if (v9 + 1024 > v8)
      {
        v27 = (char *)*((_QWORD *)a3 + 6);
        v28 = v8 - v9;
        if (v8 != v9)
        {
          memcpy(__dst, &v27[v9], v8 - v9);
          *((_QWORD *)a3 + 5) = v8;
          v9 = v8;
        }
        v29 = *a3;
        __offseta = *((_QWORD *)a3 + 3);
        v30 = v27;
        while (1)
        {
          v31 = pread(v29, v30, v9, __offseta);
          if (v31 != -1)
            break;
          v32 = g_prot_error_callback;
          if (!g_prot_error_callback)
            break;
          v33 = __error();
          if (((*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t))(v32 + 16))(v32, v29, *v33, 4) & 1) == 0)goto LABEL_47;
        }
        if (v31 != -1)
        {
          *((_QWORD *)a3 + 4) = v31;
          *((_QWORD *)a3 + 5) = 0;
          v34 = *((_QWORD *)a3 + 3) + v31;
          *((_QWORD *)a3 + 3) = v34;
          if (!v31)
            goto LABEL_7;
          v7 = &__dst[v28];
          v10 = 1024 - v28;
          if (1024 - v28 <= v31)
          {
            v9 = 0;
            goto LABEL_6;
          }
          v43 = v34;
          v35 = v31;
          while (1)
          {
            v36 = (void *)*((_QWORD *)a3 + 6);
            memcpy(v7, v36, v35);
            v37 = v35;
            *((_QWORD *)a3 + 5) = v35;
            __offsetb = *a3;
            while (1)
            {
              v38 = pread(__offsetb, v36, v37, v43);
              if (v38 != -1)
                break;
              v39 = g_prot_error_callback;
              if (!g_prot_error_callback)
                break;
              v40 = __error();
              v41 = (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, uint64_t))(v39 + 16))(v39, __offsetb, *v40, 4);
              v37 = v35;
              if ((v41 & 1) == 0)
                goto LABEL_47;
            }
            if (v38 == -1)
              break;
            *((_QWORD *)a3 + 4) = v38;
            *((_QWORD *)a3 + 5) = 0;
            v42 = *((_QWORD *)a3 + 3) + v38;
            *((_QWORD *)a3 + 3) = v42;
            if (!v38)
              goto LABEL_7;
            v43 = v42;
            v9 = 0;
            v7 += v35;
            v10 -= v35;
            v35 = v38;
            if (v10 <= v38)
              goto LABEL_6;
          }
        }
LABEL_47:
        a3[4] = *__error();
      }
      else
      {
        v10 = 1024;
LABEL_6:
        memcpy(v7, (const void *)(*((_QWORD *)a3 + 6) + v9), v10);
        *((_QWORD *)a3 + 5) = v9 + v10;
      }
LABEL_7:
      vint32 = store_stream_read_vint32((uint64_t)a3);
      v12 = v51;
      v13 = v52;
      os_unfair_lock_lock((os_unfair_lock_t)(a1 + 144));
      v14 = *(std::__shared_weak_count **)(a1 + 120);
      if (v14)
      {
        p_shared_owners = (unint64_t *)&v14->__shared_owners_;
        do
          v16 = __ldxr(p_shared_owners);
        while (__stxr(v16 + 1, p_shared_owners));
      }
      v17 = *(std::__shared_weak_count **)(a1 + 136);
      if (v17)
      {
        v18 = (unint64_t *)&v17->__shared_owners_;
        do
          v19 = __ldxr(v18);
        while (__stxr(v19 + 1, v18));
        os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 144));
        inserted = _ZN22IVFVectorIndexTemplateIDF16_Li512EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE15lookupForInsertEjRK10CIVector_sIDF16_Li512EEjfb(v46, vint32, __dst, 0xFFFFFFFF, 3.4028e38);
        *((_QWORD *)inserted + 128) = v12;
        *((_QWORD *)inserted + 129) = v13;
        do
          v21 = __ldaxr(v18);
        while (__stlxr(v21 - 1, v18));
        if (!v21)
        {
          ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
          std::__shared_weak_count::__release_weak(v17);
        }
      }
      else
      {
        os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 144));
        v22 = _ZN22IVFVectorIndexTemplateIDF16_Li512EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE15lookupForInsertEjRK10CIVector_sIDF16_Li512EEjfb(v46, vint32, __dst, 0xFFFFFFFF, 3.4028e38);
        *((_QWORD *)v22 + 128) = v12;
        *((_QWORD *)v22 + 129) = v13;
      }
      if (v14)
      {
        v23 = (unint64_t *)&v14->__shared_owners_;
        do
          v24 = __ldaxr(v23);
        while (__stlxr(v24 - 1, v23));
        if (!v24)
        {
          ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
          std::__shared_weak_count::__release_weak(v14);
        }
      }
      v25 = *(_WORD *)(a1 + 76);
      v26 = *(_DWORD *)(a1 + 156);
      v53[0] = *(_DWORD *)(a1 + 160);
      v53[1] = v26;
      v54 = v25;
      result = *(_QWORD *)(a1 + 176);
      if (result)
      {
        if (*(_DWORD *)(result + 216) == -270471200)
          result = data_map_ext_restore_data(result, vint32, __dst, 0x400uLL, v53);
      }
      ++v6;
    }
    while (v6 != v47);
  }
  return result;
}

uint64_t _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li512EE3aNNEjtPKv14vec_dimensions15vec_data_formatfjbU13block_pointerFvPvfE(uint64_t a1, int a2, int a3, uint64_t a4, int a5, int a6, int a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;
  int v10;
  uint64_t v11;
  char *v13;
  char *v14;
  const char *v15;
  _QWORD v16[5];

  if (*(_DWORD *)(a1 + 8) != a2
    || *(unsigned __int16 *)(a1 + 20) != a3
    || a6 > 2
    || *(_DWORD *)(a1 + 12) != vector_dimension_vec_sizes_10743[a5]
    || vector_size_elem_sizes_10742[a6] != *(_DWORD *)(a1 + 16))
  {
    v13 = __si_assert_copy_extra_268();
    v14 = v13;
    v15 = "";
    if (v13)
      v15 = v13;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3070, "compatible", v15);
    free(v14);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v9 = a1 + 48;
  v16[0] = MEMORY[0x1E0C809B0];
  v16[1] = 0x40000000;
  v16[2] = ___ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li512EE3aNNEjtPKv14vec_dimensions15vec_data_formatfjbU13block_pointerFvPvfE_block_invoke;
  v16[3] = &unk_1E6E31B18;
  v16[4] = a9;
  if ((a7 - 10001) >= 0xFFFFD8F0)
    v10 = a7;
  else
    v10 = 10000;
  v11 = operator new();
  *(_DWORD *)v11 = v10;
  *(_QWORD *)(v11 + 16) = 0;
  *(_QWORD *)(v11 + 24) = 0;
  *(_QWORD *)(v11 + 8) = 0;
  _ZNK22IVFVectorIndexTemplateIDF16_Li512EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE3aNNERK10CIVector_sIDF16_Li512EEfbP20MaxSizePriorityQueueINS0_18candidate_result_sIS3_EENSt3__16vectorISB_NSC_9allocatorISB_EEEENSC_4lessISB_EEEj(v9);
  return IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::aNNProcessResult(v11, (uint64_t)v16);
}

uint64_t _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li512EE10aNNForTestEjtPKv14vec_dimensions15vec_data_formatfjbU13block_pointerFvjfEj(uint64_t a1, int a2, int a3, uint64_t a4, int a5, int a6, int a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;
  int v10;
  uint64_t v11;
  char *v13;
  char *v14;
  const char *v15;

  if (*(_DWORD *)(a1 + 8) != a2
    || *(unsigned __int16 *)(a1 + 20) != a3
    || a6 > 2
    || *(_DWORD *)(a1 + 12) != vector_dimension_vec_sizes_10743[a5]
    || vector_size_elem_sizes_10742[a6] != *(_DWORD *)(a1 + 16))
  {
    v13 = __si_assert_copy_extra_268();
    v14 = v13;
    v15 = "";
    if (v13)
      v15 = v13;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3070, "compatible", v15);
    free(v14);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v9 = a1 + 48;
  if ((a7 - 10001) >= 0xFFFFD8F0)
    v10 = a7;
  else
    v10 = 10000;
  v11 = operator new();
  *(_DWORD *)v11 = v10;
  *(_QWORD *)(v11 + 16) = 0;
  *(_QWORD *)(v11 + 24) = 0;
  *(_QWORD *)(v11 + 8) = 0;
  _ZNK22IVFVectorIndexTemplateIDF16_Li512EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE3aNNERK10CIVector_sIDF16_Li512EEfbP20MaxSizePriorityQueueINS0_18candidate_result_sIS3_EENSt3__16vectorISB_NSC_9allocatorISB_EEEENSC_4lessISB_EEEj(v9);
  return IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::aNNForTestProcessResult(v11, a9);
}

uint64_t _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li512EE20createCandidateQueueEj(uint64_t a1, int a2)
{
  int v2;
  uint64_t result;

  if ((a2 - 10001) >= 0xFFFFD8F0)
    v2 = a2;
  else
    v2 = 10000;
  result = operator new();
  *(_DWORD *)result = v2;
  *(_QWORD *)(result + 16) = 0;
  *(_QWORD *)(result + 24) = 0;
  *(_QWORD *)(result + 8) = 0;
  return result;
}

void _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li512EE3aNNEjtPKv14vec_dimensions15vec_data_formatfbPv(uint64_t a1, int a2, int a3, uint64_t a4, int a5, int a6)
{
  char *v6;
  char *v7;
  const char *v8;

  if (*(_DWORD *)(a1 + 8) != a2
    || *(unsigned __int16 *)(a1 + 20) != a3
    || a6 > 2
    || *(_DWORD *)(a1 + 12) != vector_dimension_vec_sizes_10743[a5]
    || vector_size_elem_sizes_10742[a6] != *(_DWORD *)(a1 + 16))
  {
    v6 = __si_assert_copy_extra_268();
    v7 = v6;
    v8 = "";
    if (v6)
      v8 = v6;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3070, "compatible", v8);
    free(v7);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  _ZNK22IVFVectorIndexTemplateIDF16_Li512EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE3aNNERK10CIVector_sIDF16_Li512EEfbP20MaxSizePriorityQueueINS0_18candidate_result_sIS3_EENSt3__16vectorISB_NSC_9allocatorISB_EEEENSC_4lessISB_EEEj(a1 + 48);
}

uint64_t _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li512EE16aNNProcessResultEPvU13block_pointerFvS5_fE(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD v4[5];

  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 0x40000000;
  v4[2] = ___ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li512EE16aNNProcessResultEPvU13block_pointerFvS5_fE_block_invoke;
  v4[3] = &unk_1E6E31B78;
  v4[4] = a3;
  return IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::aNNProcessResult(a2, (uint64_t)v4);
}

uint64_t _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li512EE23aNNForTestProcessResultEPvU13block_pointerFvjfE(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::aNNForTestProcessResult(a2, a3);
}

uint64_t _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li512EE24aNNForDebugProcessResultEPvU13block_pointerFvjjfE(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5;
  NSObject *v6;
  unint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  std::ios_base *v13;
  uint64_t v14;
  float *v15;
  BOOL v16;
  int v17;
  float *v18;
  _QWORD *v19;
  _QWORD *v20;
  char *v21;
  unint64_t v22;
  int v23;
  NSObject *v24;
  void **v25;
  float *v26;
  char *v27;
  uint64_t v28;
  int v29;
  NSObject *v30;
  void **v31;
  void *v32;
  uint64_t v33;
  int v35;
  float *v36;
  CFIndex AppIntegerValue;
  float *v38;
  float *v39;
  uint64_t v40;
  uint8_t v41[4];
  void **v42;
  void *__p[2];
  uint64_t v44;
  uint64_t v45;
  __int128 buf;
  uint64_t v47;
  _QWORD v48[8];
  __int128 v49;
  __int128 v50;
  uint64_t v51;
  uint64_t v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  uint64_t v62;

  v62 = *MEMORY[0x1E0C80C00];
  v5 = *__error();
  v6 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    v7 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a2 + 16) - *(_QWORD *)(a2 + 8)) >> 3);
    LODWORD(buf) = 134217984;
    *(_QWORD *)((char *)&buf + 4) = v7;
    _os_log_impl(&dword_1B8270000, v6, OS_LOG_TYPE_DEFAULT, "search return %zu results", (uint8_t *)&buf, 0xCu);
  }
  *__error() = v5;
  LOBYTE(buf) = 0;
  AppIntegerValue = CFPreferencesGetAppIntegerValue(CFSTR("IVFANNLogQueryResult"), CFSTR("com.apple.Spotlight"), (Boolean *)&buf);
  v35 = buf;
  v61 = 0u;
  v51 = 0;
  v60 = 0u;
  v59 = 0u;
  v58 = 0u;
  v57 = 0u;
  v56 = 0u;
  v55 = 0u;
  v54 = 0u;
  v53 = 0u;
  v50 = 0u;
  v49 = 0u;
  memset(v48, 0, sizeof(v48));
  v8 = MEMORY[0x1E0DE4FD0] + 104;
  v52 = MEMORY[0x1E0DE4FD0] + 104;
  v9 = (_QWORD *)MEMORY[0x1E0DE4F50];
  v10 = MEMORY[0x1E0DE4FD0] + 64;
  v11 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 16);
  v12 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 24);
  v47 = MEMORY[0x1E0DE4FD0] + 64;
  *(_QWORD *)&buf = v11;
  *(_QWORD *)((char *)&buf + *(_QWORD *)(v11 - 24)) = v12;
  *((_QWORD *)&buf + 1) = 0;
  v13 = (std::ios_base *)((char *)&buf + *(_QWORD *)(buf - 24));
  std::ios_base::init(v13, v48);
  v13[1].__vftable = 0;
  v13[1].__fmtflags_ = -1;
  v14 = v9[5];
  v47 = v9[4];
  *(_QWORD *)((char *)&v48[-1] + *(_QWORD *)(v47 - 24)) = v14;
  *(_QWORD *)&buf = v9[1];
  *(_QWORD *)((char *)&buf + *(_QWORD *)(buf - 24)) = v9[6];
  v52 = v8;
  *(_QWORD *)&buf = MEMORY[0x1E0DE4FD0] + 24;
  v47 = v10;
  std::streambuf::basic_streambuf();
  v48[0] = MEMORY[0x1E0DE4FB8] + 16;
  v49 = 0u;
  v50 = 0u;
  LODWORD(v51) = 24;
  v38 = 0;
  v39 = 0;
  v40 = 0;
  MaxSizePriorityQueue<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_memory_postings>,std::vector<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_memory_postings>,std::allocator<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_memory_postings>>>,std::less<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_memory_postings>>>::allItems(&v38, *(_BYTE **)(a2 + 8), *(_BYTE **)(a2 + 16));
  v15 = v39;
  v36 = v38;
  if (v38 != v39)
  {
    if (AppIntegerValue)
      v16 = v35 == 0;
    else
      v16 = 1;
    if (v16)
    {
      v26 = v38;
      do
      {
        (*(void (**)(uint64_t, _QWORD, _QWORD, float))(a3 + 16))(a3, *((unsigned int *)v26 + 2), *((unsigned int *)v26 + 4), v26[5]);
        v26 += 6;
      }
      while (v26 != v15);
    }
    else
    {
      v17 = 0;
      v18 = v38;
      do
      {
        (*(void (**)(uint64_t, _QWORD, _QWORD, float))(a3 + 16))(a3, *((unsigned int *)v18 + 2), *((unsigned int *)v18 + 4), v18[5]);
        v19 = (_QWORD *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v19, (uint64_t)",", 1);
        v20 = (_QWORD *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v20, (uint64_t)";", 1);
        v21 = (char *)&v48[-1] + *(_QWORD *)(v47 - 24);
        if ((v21[32] & 5) == 0
          && ((*(void (**)(void **__return_ptr, _QWORD, _QWORD, uint64_t, uint64_t))(**((_QWORD **)v21 + 5)
                                                                                            + 32))(__p, *((_QWORD *)v21 + 5), 0, 1, 16), v45 > 1000)|| (++v17, HIDWORD(v22) = -1030792151 * v17 + 85899344, LODWORD(v22) = HIDWORD(v22), (v22 >> 1) < 0x51EB851))
        {
          v23 = *__error();
          v24 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
          {
            std::stringbuf::str();
            v25 = __p;
            if (v44 < 0)
              v25 = (void **)__p[0];
            *(_DWORD *)v41 = 136315138;
            v42 = v25;
            _os_log_impl(&dword_1B8270000, v24, OS_LOG_TYPE_DEFAULT, "%s", v41, 0xCu);
            if (SHIBYTE(v44) < 0)
              operator delete(__p[0]);
          }
          *__error() = v23;
          __p[0] = 0;
          __p[1] = 0;
          v44 = 0;
          std::stringbuf::str();
          if (SHIBYTE(v44) < 0)
            operator delete(__p[0]);
        }
        v18 += 6;
      }
      while (v18 != v15);
    }
  }
  v27 = (char *)&v48[-1] + *(_QWORD *)(v47 - 24);
  if ((v27[32] & 5) != 0)
  {
    v28 = a2;
  }
  else
  {
    (*(void (**)(void **__return_ptr, _QWORD, _QWORD, uint64_t, uint64_t))(**((_QWORD **)v27 + 5) + 32))(__p, *((_QWORD *)v27 + 5), 0, 1, 16);
    v28 = a2;
    if (v45 > 0)
    {
      v29 = *__error();
      v30 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        std::stringbuf::str();
        v31 = v44 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)v41 = 136315138;
        v42 = v31;
        _os_log_impl(&dword_1B8270000, v30, OS_LOG_TYPE_DEFAULT, "%s", v41, 0xCu);
        if (SHIBYTE(v44) < 0)
          operator delete(__p[0]);
      }
      *__error() = v29;
    }
  }
  if (v28)
  {
    v32 = *(void **)(v28 + 8);
    if (v32)
    {
      *(_QWORD *)(v28 + 16) = v32;
      operator delete(v32);
    }
    MEMORY[0x1BCCB06A4](v28, 0x1020C403EC25235);
  }
  if (v36)
    operator delete(v36);
  *(_QWORD *)&buf = *MEMORY[0x1E0DE4F50];
  v33 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 72);
  *(_QWORD *)((char *)&buf + *(_QWORD *)(buf - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 64);
  v47 = v33;
  v48[0] = MEMORY[0x1E0DE4FB8] + 16;
  if (SBYTE7(v50) < 0)
    operator delete((void *)v49);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1BCCB0650](&v52);
}

uint64_t _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li512EE11storageSizeEv(uint64_t a1)
{
  os_unfair_lock_s *v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;

  v2 = (os_unfair_lock_s *)(a1 + 144);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 144));
  v3 = *(std::__shared_weak_count **)(a1 + 120);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  v7 = *(_QWORD *)(a1 + 128);
  v6 = *(std::__shared_weak_count **)(a1 + 136);
  if (v6)
  {
    v8 = (unint64_t *)&v6->__shared_owners_;
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  os_unfair_lock_unlock(v2);
  v10 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 16) + 24);
  v11 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 184))(v7);
  if (!v6)
    goto LABEL_11;
  v12 = (unint64_t *)&v6->__shared_owners_;
  do
    v13 = __ldaxr(v12);
  while (__stlxr(v13 - 1, v12));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
    if (!v3)
      return v11 + v10;
  }
  else
  {
LABEL_11:
    if (!v3)
      return v11 + v10;
  }
  v14 = (unint64_t *)&v3->__shared_owners_;
  do
    v15 = __ldaxr(v14);
  while (__stlxr(v15 - 1, v14));
  if (!v15)
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return v11 + v10;
}

uint64_t _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li512EE14setVectorStoreEP10data_map_s(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 176) = a2;
  return result;
}

uint64_t _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li512EE16getDataForOffsetEjPj(_QWORD *a1, uint64_t a2, int *a3)
{
  uint64_t result;
  int v7;
  int v8;
  NSObject *v9;
  int *v10;
  int v11;
  int v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  int v17;
  __int16 v18;
  int v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if ((*(unsigned int (**)(_QWORD *))(*a1 + 16))(a1) <= a2)
  {
    v8 = *__error();
    v9 = _SILogForLogForCategory(2);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v11 = (*(uint64_t (**)(_QWORD *))(*a1 + 16))(a1);
      v12 = 136315906;
      v13 = "getDataForOffset";
      v14 = 1024;
      v15 = 3455;
      v16 = 1024;
      v17 = a2;
      v18 = 1024;
      v19 = v11;
      _os_log_error_impl(&dword_1B8270000, v9, OS_LOG_TYPE_ERROR, "%s:%d: offset out of range: %u >= %u", (uint8_t *)&v12, 0x1Eu);
    }
    v10 = __error();
    v7 = 0;
    result = 0;
    *v10 = v8;
  }
  else
  {
    result = (*(uint64_t (**)(_QWORD *, uint64_t))(a1[6] + 32))(a1 + 6, a2);
    v7 = 1024;
  }
  *a3 = v7;
  return result;
}

uint64_t _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li512EE26updateVectorStorageOffsetsEP13__SIUINT64Set(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  uint64_t v4;
  unint64_t i;
  uint64_t result;
  unint64_t Ptr;
  unint64_t v8;
  int v9;
  uint64_t v10;
  int v11;

  v2 = a2;
  v4 = a1 + 48;
  if (a2)
  {
    for (i = 0; ; ++i)
    {
      result = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nVectors(v4);
      if (i >= result)
        break;
      Ptr = vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(*(_QWORD *)(a1 + 80) + 16), i, 1044);
      if (!*(_BYTE *)(v2 + 184))
      {
        v8 = *(unsigned int *)(Ptr + 1040);
        v9 = *(_DWORD *)(v2 + 24);
        if (!v9 || !((*(_QWORD *)(v2 + 16) ^ v8) >> (-4 * v9)))
        {
          v10 = *(_QWORD *)(v2 + 56 + 8 * ((v8 >> ((60 - 4 * v9) & 0xFC)) & 0xF));
          if ((v10 & 1) != 0)
          {
            v11 = v9 + 2;
            do
              v10 = *(_QWORD *)((v10 & 0xFFFFFFFFFFFFFFFELL) + 8 * ((v8 >> ((64 - 4 * v11++) & 0xFC)) & 0xF));
            while ((v10 & 1) != 0);
          }
          if (v10)
            (*(void (**)(uint64_t))(*(_QWORD *)v10 + 16))(v10);
        }
      }
    }
  }
  else
  {
    while (1)
    {
      result = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nVectors(v4);
      if (v2 >= result)
        break;
      vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(*(_QWORD *)(a1 + 80) + 16), v2++, 1044);
    }
  }
  return result;
}

uint64_t _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li512EE6statusERKNSt3__112basic_stringIcNS5_11char_traitsIcEENS5_9allocatorIcEEEE(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  std::ios_base *v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  _QWORD *v22;
  _QWORD *v23;
  std::__shared_weak_count *v24;
  unint64_t *p_shared_owners;
  unint64_t v26;
  _QWORD *v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  _QWORD *v31;
  uint64_t v32;
  uint64_t v34;
  std::__shared_weak_count *v35;
  uint64_t v36;
  std::__shared_weak_count *v37;
  _QWORD v38[2];
  uint64_t v39;
  _OWORD v40[4];
  void *__p[2];
  __int128 v42;
  uint64_t v43;
  uint64_t v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;

  v53 = 0u;
  v43 = 0;
  v52 = 0u;
  v51 = 0u;
  v50 = 0u;
  v49 = 0u;
  v48 = 0u;
  v47 = 0u;
  v46 = 0u;
  v45 = 0u;
  v42 = 0u;
  *(_OWORD *)__p = 0u;
  v4 = MEMORY[0x1E0DE4FD0];
  memset(v40, 0, sizeof(v40));
  v5 = MEMORY[0x1E0DE4FD0] + 104;
  v44 = MEMORY[0x1E0DE4FD0] + 104;
  v6 = (_QWORD *)MEMORY[0x1E0DE4F50];
  v7 = MEMORY[0x1E0DE4FD0] + 64;
  v8 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 16);
  v9 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 24);
  v39 = MEMORY[0x1E0DE4FD0] + 64;
  v38[0] = v8;
  *(_QWORD *)((char *)v38 + *(_QWORD *)(v8 - 24)) = v9;
  v38[1] = 0;
  v10 = (std::ios_base *)((char *)v38 + *(_QWORD *)(v38[0] - 24));
  std::ios_base::init(v10, v40);
  v10[1].__vftable = 0;
  v10[1].__fmtflags_ = -1;
  v11 = v6[5];
  v39 = v6[4];
  *(uint64_t *)((char *)&v39 + *(_QWORD *)(v39 - 24)) = v11;
  v38[0] = v6[1];
  *(_QWORD *)((char *)v38 + *(_QWORD *)(v38[0] - 24)) = v6[6];
  v44 = v5;
  v38[0] = v4 + 24;
  v39 = v7;
  std::streambuf::basic_streambuf();
  v12 = MEMORY[0x1E0DE4FB8];
  *(_QWORD *)&v40[0] = MEMORY[0x1E0DE4FB8] + 16;
  *(_OWORD *)__p = 0u;
  v42 = 0u;
  LODWORD(v43) = 24;
  v13 = *(char *)(a2 + 23);
  if (v13 >= 0)
    v14 = a2;
  else
    v14 = *(_QWORD *)a2;
  if (v13 >= 0)
    v15 = *(unsigned __int8 *)(a2 + 23);
  else
    v15 = *(_QWORD *)(a2 + 8);
  v16 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v39, v14, v15);
  v17 = *(char *)(a1 + 47);
  if (v17 >= 0)
    v18 = a1 + 24;
  else
    v18 = *(_QWORD *)(a1 + 24);
  if (v17 >= 0)
    v19 = *(unsigned __int8 *)(a1 + 47);
  else
    v19 = *(_QWORD *)(a1 + 32);
  v20 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v16, v18, v19);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v20, (uint64_t)"(", 1);
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  v21 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v21, (uint64_t)"/", 1);
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
  v22 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v22, (uint64_t)"v", 1);
  _ZNK22IVFVectorIndexTemplateIDF16_Li512EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE13getPartitionsEv(a1 + 48, &v36);
  if (v36)
  {
    _ZNK22IVFVectorIndexTemplateIDF16_Li512EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE13getPartitionsEv(a1 + 48, &v34);
    v23 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v23, (uint64_t)")", 1);
    v24 = v35;
    if (v35)
    {
      p_shared_owners = (unint64_t *)&v35->__shared_owners_;
      do
        v26 = __ldaxr(p_shared_owners);
      while (__stlxr(v26 - 1, p_shared_owners));
      if (!v26)
      {
        ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
        std::__shared_weak_count::__release_weak(v24);
      }
    }
  }
  else
  {
    v27 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v27, (uint64_t)")", 1);
  }
  v28 = v37;
  if (v37)
  {
    v29 = (unint64_t *)&v37->__shared_owners_;
    do
      v30 = __ldaxr(v29);
    while (__stlxr(v30 - 1, v29));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v39, (uint64_t)"[", 1);
  std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v39, (uint64_t)",", 1);
  v31 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v31, (uint64_t)"] indexId: ", 11);
  std::ostream::operator<<();
  std::stringbuf::str();
  v38[0] = *v6;
  v32 = v6[9];
  *(_QWORD *)((char *)v38 + *(_QWORD *)(v38[0] - 24)) = v6[8];
  v39 = v32;
  *(_QWORD *)&v40[0] = v12 + 16;
  if (SBYTE7(v42) < 0)
    operator delete(__p[0]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1BCCB0650](&v44);
}

uint64_t _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li512EE12diagnoseDumpERKNSt3__112basic_stringIcNS5_11char_traitsIcEENS5_9allocatorIcEEEERNS5_13basic_ostreamIcS8_EEi(uint64_t a1, uint64_t a2, _QWORD *a3, int a4)
{
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  _QWORD *v16;
  const char *v17;
  uint64_t v18;
  _QWORD *v19;
  const std::locale::facet *v20;
  uint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *p_shared_owners;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  unint64_t *v28;
  unint64_t v29;
  unint64_t *v30;
  unint64_t v31;
  uint64_t v32;
  unint64_t *v33;
  unint64_t v34;
  _QWORD *v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  _QWORD *v39;
  _QWORD *v40;
  _QWORD *v41;
  _QWORD *v42;
  const std::locale::facet *v43;
  uint64_t v44;
  std::locale *v45;
  uint64_t v46;
  const std::locale::facet *v47;
  uint64_t v48;
  _QWORD *v49;
  const char *v50;
  uint64_t v51;
  const std::locale::facet *v52;
  unint64_t v53;
  std::locale::id *v54;
  const std::locale::facet *v55;
  unint64_t Ptr;
  _QWORD *v57;
  _QWORD *v58;
  _QWORD *v59;
  void *locale;
  uint64_t v61;
  void *v62;
  uint64_t v63;
  _QWORD *v64;
  unint64_t v65;
  std::locale::id *v66;
  _QWORD *v67;
  _QWORD *v68;
  const std::locale::facet *v69;
  const std::locale::facet *v70;
  uint64_t v71;
  std::__shared_weak_count *v72;
  unint64_t *v73;
  unint64_t v74;
  unint64_t *v75;
  unint64_t v76;
  uint64_t v78;
  unsigned int v79;
  uint64_t v80;
  std::__shared_weak_count *v81;
  std::locale v82;
  std::locale v83;
  uint64_t v84;
  unsigned __int8 v85;

  v7 = *(_QWORD *)(a2 + 8);
  if (*(char *)(a2 + 23) >= 0)
  {
    v8 = *(unsigned __int8 *)(a2 + 23);
  }
  else
  {
    a2 = *(_QWORD *)a2;
    v8 = v7;
  }
  v9 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, a2, v8);
  v10 = *(char *)(a1 + 47);
  if (v10 >= 0)
    v11 = a1 + 24;
  else
    v11 = *(_QWORD *)(a1 + 24);
  if (v10 >= 0)
    v12 = *(unsigned __int8 *)(a1 + 47);
  else
    v12 = *(_QWORD *)(a1 + 32);
  v13 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v9, v11, v12);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v13, (uint64_t)": ", 2);
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  v14 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v14, (uint64_t)" vectors ", 9);
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
  v15 = (_QWORD *)std::ostream::operator<<();
  v16 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v15, (uint64_t)" partitions.", 12);
  if (*(_BYTE *)(a1 + 192))
    v17 = "(readOnly)";
  else
    v17 = "(readWrite)";
  if (*(_BYTE *)(a1 + 192))
    v18 = 10;
  else
    v18 = 11;
  v19 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v16, (uint64_t)v17, v18);
  std::ios_base::getloc((const std::ios_base *)((char *)v19 + *(_QWORD *)(*v19 - 24)));
  v20 = std::locale::use_facet(&v83, MEMORY[0x1E0DE4A90]);
  ((void (*)(const std::locale::facet *, uint64_t))v20->__vftable[2].~facet_0)(v20, 10);
  std::locale::~locale(&v83);
  std::ostream::put();
  std::ostream::flush();
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 144));
  v21 = *(_QWORD *)(a1 + 112);
  v22 = *(std::__shared_weak_count **)(a1 + 120);
  if (v22)
  {
    p_shared_owners = (unint64_t *)&v22->__shared_owners_;
    do
      v24 = __ldxr(p_shared_owners);
    while (__stxr(v24 + 1, p_shared_owners));
  }
  v25 = *(std::__shared_weak_count **)(a1 + 136);
  if (v25)
  {
    v26 = (unint64_t *)&v25->__shared_owners_;
    do
      v27 = __ldxr(v26);
    while (__stxr(v27 + 1, v26));
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 144));
  if (v22)
  {
    v28 = (unint64_t *)&v22->__shared_owners_;
    do
      v29 = __ldxr(v28);
    while (__stxr(v29 + 1, v28));
  }
  if (!v25)
    goto LABEL_29;
  v30 = (unint64_t *)&v25->__shared_owners_;
  do
    v31 = __ldaxr(v30);
  while (__stlxr(v31 - 1, v30));
  if (!v31)
  {
    ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
    std::__shared_weak_count::__release_weak(v25);
    v32 = a1 + 48;
    if (!v22)
      goto LABEL_35;
  }
  else
  {
LABEL_29:
    v32 = a1 + 48;
    if (!v22)
      goto LABEL_35;
  }
  v33 = (unint64_t *)&v22->__shared_owners_;
  do
    v34 = __ldaxr(v33);
  while (__stlxr(v34 - 1, v33));
  if (!v34)
  {
    ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
    std::__shared_weak_count::__release_weak(v22);
  }
LABEL_35:
  if (v21)
  {
    v35 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, (uint64_t)"Quantizer: ", 11);
    v36 = *(char *)(v21 + 31);
    if (v36 >= 0)
      v37 = v21 + 8;
    else
      v37 = *(_QWORD *)(v21 + 8);
    if (v36 >= 0)
      v38 = *(unsigned __int8 *)(v21 + 31);
    else
      v38 = *(_QWORD *)(v21 + 16);
    v39 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v35, v37, v38);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v39, (uint64_t)"(", 1);
    (*(void (**)(uint64_t))(*(_QWORD *)v21 + 16))(v21);
    v40 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v40, (uint64_t)") ", 2);
    (*(void (**)(uint64_t))(*(_QWORD *)v21 + 24))(v21);
    v41 = (_QWORD *)std::ostream::operator<<();
    v42 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v41, (uint64_t)" centroids.", 11);
    std::ios_base::getloc((const std::ios_base *)((char *)v42 + *(_QWORD *)(*v42 - 24)));
    v43 = std::locale::use_facet(&v83, MEMORY[0x1E0DE4A90]);
    ((void (*)(const std::locale::facet *, uint64_t))v43->__vftable[2].~facet_0)(v43, 10);
    std::locale::~locale(&v83);
    std::ostream::put();
    std::ostream::flush();
  }
  v80 = 0;
  v81 = 0;
  _ZNK22IVFVectorIndexTemplateIDF16_Li512EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE13getPartitionsEv(v32, &v80);
  v44 = v80;
  if (!v80)
    goto LABEL_51;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, (uint64_t)"Partition: ", 11);
  (*(void (**)(std::locale *__return_ptr, uint64_t))(*(_QWORD *)v44 + 144))(&v83, v44);
  v45 = (v85 & 0x80u) == 0 ? &v83 : (std::locale *)v83.__locale_;
  v46 = (v85 & 0x80u) == 0 ? v85 : v84;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, (uint64_t)v45, v46);
  std::ios_base::getloc((const std::ios_base *)((char *)a3 + *(_QWORD *)(*a3 - 24)));
  v47 = std::locale::use_facet(&v82, MEMORY[0x1E0DE4A90]);
  ((void (*)(const std::locale::facet *, uint64_t))v47->__vftable[2].~facet_0)(v47, 10);
  std::locale::~locale(&v82);
  std::ostream::put();
  std::ostream::flush();
  if ((char)v85 < 0)
  {
    operator delete(v83.__locale_);
    if (!a4)
      goto LABEL_84;
  }
  else
  {
LABEL_51:
    if (!a4)
      goto LABEL_84;
  }
  v78 = v44;
  v48 = *(_QWORD *)(a1 + 80);
  v49 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, (uint64_t)"offset,vid", 10);
  v79 = a4;
  if (a4 <= 1)
    v50 = ",";
  else
    v50 = ",vector";
  if (a4 <= 1)
    v51 = 1;
  else
    v51 = 7;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v49, (uint64_t)v50, v51);
  std::ios_base::getloc((const std::ios_base *)((char *)a3 + *(_QWORD *)(*a3 - 24)));
  v52 = std::locale::use_facet(&v83, MEMORY[0x1E0DE4A90]);
  ((void (*)(const std::locale::facet *, uint64_t))v52->__vftable[2].~facet_0)(v52, 10);
  std::locale::~locale(&v83);
  std::ostream::put();
  std::ostream::flush();
  if (*(_DWORD *)(v48 + 24))
  {
    if (a4 <= 1)
    {
      v65 = 0;
      v66 = (std::locale::id *)MEMORY[0x1E0DE4A90];
      do
      {
        vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(v48 + 16), v65, 1044);
        v67 = (_QWORD *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v67, (uint64_t)",", 1);
        v68 = (_QWORD *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v68, (uint64_t)",", 1);
        std::ios_base::getloc((const std::ios_base *)((char *)a3 + *(_QWORD *)(*a3 - 24)));
        v69 = std::locale::use_facet(&v83, v66);
        ((void (*)(const std::locale::facet *, uint64_t))v69->__vftable[2].~facet_0)(v69, 10);
        std::locale::~locale(&v83);
        std::ostream::put();
        std::ostream::flush();
        ++v65;
      }
      while (v65 < *(unsigned int *)(v48 + 24));
    }
    else
    {
      v53 = 0;
      v54 = (std::locale::id *)MEMORY[0x1E0DE4A90];
      do
      {
        Ptr = vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(v48 + 16), v53, 1044);
        v57 = (_QWORD *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v57, (uint64_t)",", 1);
        v58 = (_QWORD *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v58, (uint64_t)",", 1);
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, (uint64_t)"{length = ", 10);
        v59 = (_QWORD *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v59, (uint64_t)", bytes = 0x", 12);
        data2hexString((const unsigned __int8 *)&v83, Ptr, 16);
        if ((v85 & 0x80u) == 0)
          locale = &v83;
        else
          locale = v83.__locale_;
        if ((v85 & 0x80u) == 0)
          v61 = v85;
        else
          v61 = v84;
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v59, (uint64_t)locale, v61);
        if ((char)v85 < 0)
          operator delete(v83.__locale_);
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, (uint64_t)" ... ", 5);
        data2hexString((const unsigned __int8 *)&v83, Ptr + 1016, 8);
        if ((v85 & 0x80u) == 0)
          v62 = &v83;
        else
          v62 = v83.__locale_;
        if ((v85 & 0x80u) == 0)
          v63 = v85;
        else
          v63 = v84;
        v64 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, (uint64_t)v62, v63);
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v64, (uint64_t)" }", 2);
        if ((char)v85 < 0)
          operator delete(v83.__locale_);
        std::ios_base::getloc((const std::ios_base *)((char *)a3 + *(_QWORD *)(*a3 - 24)));
        v55 = std::locale::use_facet(&v83, v54);
        ((void (*)(const std::locale::facet *, uint64_t))v55->__vftable[2].~facet_0)(v55, 10);
        std::locale::~locale(&v83);
        std::ostream::put();
        std::ostream::flush();
        ++v53;
      }
      while (v53 < *(unsigned int *)(v48 + 24));
    }
  }
  std::ios_base::getloc((const std::ios_base *)((char *)a3 + *(_QWORD *)(*a3 - 24)));
  v70 = std::locale::use_facet(&v83, MEMORY[0x1E0DE4A90]);
  ((void (*)(const std::locale::facet *, uint64_t))v70->__vftable[2].~facet_0)(v70, 10);
  std::locale::~locale(&v83);
  std::ostream::put();
  std::ostream::flush();
  if (v78)
    (*(void (**)(uint64_t, _QWORD *, _QWORD))(*(_QWORD *)v78 + 104))(v78, a3, v79);
LABEL_84:
  v71 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  v72 = v81;
  if (!v81)
    goto LABEL_88;
  v73 = (unint64_t *)&v81->__shared_owners_;
  do
    v74 = __ldaxr(v73);
  while (__stlxr(v74 - 1, v73));
  if (!v74)
  {
    ((void (*)(std::__shared_weak_count *))v72->__on_zero_shared)(v72);
    std::__shared_weak_count::__release_weak(v72);
    if (!v22)
      return v71;
  }
  else
  {
LABEL_88:
    if (!v22)
      return v71;
  }
  v75 = (unint64_t *)&v22->__shared_owners_;
  do
    v76 = __ldaxr(v75);
  while (__stlxr(v76 - 1, v75));
  if (!v76)
  {
    ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
    std::__shared_weak_count::__release_weak(v22);
  }
  return v71;
}

uint64_t ___ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li512EE16aNNProcessResultEPvU13block_pointerFvS5_fE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void _ZNK22IVFVectorIndexTemplateIDF16_Li512EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE3aNNERK10CIVector_sIDF16_Li512EEfbP20MaxSizePriorityQueueINS0_18candidate_result_sIS3_EENSt3__16vectorISB_NSC_9allocatorISB_EEEENSC_4lessISB_EEEj(uint64_t a1)
{
  uint64_t v1;
  CFIndex v2;
  CFIndex AppIntegerValue;
  char v4;
  char v5;
  float v6;
  float v7;
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  uint64_t v10;
  _DWORD *v11;
  int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  double Current;
  unsigned int v23;
  unsigned int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  unsigned int v31;
  int v32;
  char v33;
  int v34;
  char v35;
  unsigned int v36;
  char v37;
  unsigned int v38;
  int v39;
  int v40;
  int v41;
  unsigned int v42;
  int v43;
  NSObject *v44;
  int v45;
  int v46;
  std::__shared_weak_count *v47;
  uint64_t v48;
  unint64_t *p_shared_owners;
  unint64_t v50;
  std::__shared_weak_count *v51;
  uint64_t v52;
  unint64_t *v53;
  unint64_t v54;
  int *v55;
  int *v56;
  unint64_t v57;
  int v58;
  const void *v59;
  int64_t v60;
  char *v61;
  char *v62;
  int v63;
  NSObject *v64;
  int v65;
  int v66;
  double v67;
  unsigned int v68;
  uint64_t v69;
  unint64_t v70;
  unint64_t v71;
  float16x8_t v72;
  float32x4_t v73;
  float16x8_t v74;
  float16x8_t v75;
  float16x8_t v76;
  float16x8_t v77;
  float16x8_t v78;
  float16x8_t v79;
  float16x8_t v80;
  float16x8_t v81;
  float16x8_t v82;
  float16x8_t v83;
  float16x8_t v84;
  float16x8_t v85;
  float16x8_t v86;
  float16x8_t v87;
  float16x8_t v88;
  float16x8_t v89;
  float16x8_t v90;
  float16x8_t v91;
  float16x8_t v92;
  float16x8_t v93;
  float16x8_t v94;
  float16x8_t v95;
  float16x8_t v96;
  float16x8_t v97;
  float16x8_t v98;
  float16x8_t v99;
  float16x8_t v100;
  float16x8_t v101;
  float16x8_t v102;
  float16x8_t v103;
  float16x8_t v104;
  float16x8_t v105;
  float16x8_t v106;
  float16x8_t v107;
  float16x8_t v108;
  float16x8_t v109;
  float16x8_t v110;
  float16x8_t v111;
  float16x8_t v112;
  float16x8_t v113;
  float16x8_t v114;
  float16x8_t v115;
  float16x8_t v116;
  float16x8_t v117;
  float16x8_t v118;
  float16x8_t v119;
  float16x8_t v120;
  float16x8_t v121;
  float16x8_t v122;
  float16x8_t v123;
  float16x8_t v124;
  float16x8_t v125;
  float16x8_t v126;
  float16x8_t v127;
  float16x8_t v128;
  float16x8_t v129;
  float16x8_t v130;
  float16x8_t v131;
  float16x8_t v132;
  float16x8_t v133;
  float16x8_t v134;
  float16x8_t v135;
  float16x8_t v136;
  float32x4_t v137;
  float16x8_t v138;
  float16x8_t v139;
  float16x8_t v140;
  float16x8_t v141;
  float16x8_t v142;
  float16x8_t v143;
  float16x8_t v144;
  float16x8_t v145;
  float16x8_t v146;
  float16x8_t v147;
  float16x8_t v148;
  float16x8_t v149;
  float16x8_t v150;
  float16x8_t v151;
  float16x8_t v152;
  float16x8_t v153;
  float16x8_t v154;
  float16x8_t v155;
  float16x8_t v156;
  float16x8_t v157;
  float16x8_t v158;
  float16x8_t v159;
  float16x8_t v160;
  float16x8_t v161;
  float16x8_t v162;
  float16x8_t v163;
  float16x8_t v164;
  float16x8_t v165;
  float16x8_t v166;
  float16x8_t v167;
  float16x8_t v168;
  float16x8_t v169;
  float16x8_t v170;
  float16x8_t v171;
  float16x8_t v172;
  float16x8_t v173;
  float16x8_t v174;
  float16x8_t v175;
  float16x8_t v176;
  float16x8_t v177;
  float16x8_t v178;
  float16x8_t v179;
  float16x8_t v180;
  float16x8_t v181;
  float16x8_t v182;
  float16x8_t v183;
  float16x8_t v184;
  float16x8_t v185;
  float16x8_t v186;
  float16x8_t v187;
  float16x8_t v188;
  float16x8_t v189;
  float16x8_t v190;
  float16x8_t v191;
  float16x8_t v192;
  float16x8_t v193;
  float16x8_t v194;
  float16x8_t v195;
  float16x8_t v196;
  float16x8_t v197;
  float16x8_t v198;
  float16x8_t v199;
  uint8x8_t v200;
  unint64_t v201;
  uint64_t *v202;
  unint64_t v203;
  unint64_t v204;
  float v205;
  int v206;
  NSObject *v207;
  int v208;
  NSObject *v209;
  int v210;
  NSObject *v211;
  int v212;
  int v213;
  int v214;
  int v215;
  unint64_t v216;
  CFAbsoluteTime v217;
  _QWORD *v218;
  _QWORD *v219;
  void *v220;
  _QWORD *v221;
  _QWORD *v222;
  void *v223;
  unint64_t *v224;
  unint64_t v225;
  unint64_t *v226;
  unint64_t v227;
  char *v228;
  char *v229;
  const char *v230;
  os_unfair_lock_t lock;
  int v232;
  _QWORD *v233;
  _QWORD v234[8];
  void *v235;
  void *v236;
  _QWORD *v237;
  float v238;
  void *v239;
  void *v240;
  char *v241;
  void *v242[2];
  void *__p[2];
  uint64_t v244;
  uint64_t v245;
  uint64_t *v246;
  uint64_t v247;
  int v248;
  uint64_t v249;
  uint64_t *v250;
  uint64_t v251;
  int v252;
  float32x4_t __B;
  float32x4_t v254;
  float32x4_t v255;
  float32x4_t v256;
  float32x4_t v257;
  float32x4_t v258;
  float32x4_t v259;
  float32x4_t v260;
  float32x4_t v261;
  float32x4_t v262;
  float32x4_t v263;
  float32x4_t v264;
  float32x4_t v265;
  float32x4_t v266;
  float32x4_t v267;
  float32x4_t v268;
  float32x4_t v269;
  float32x4_t v270;
  float32x4_t v271;
  float32x4_t v272;
  float32x4_t v273;
  float32x4_t v274;
  float32x4_t v275;
  float32x4_t v276;
  float32x4_t v277;
  float32x4_t v278;
  float32x4_t v279;
  float32x4_t v280;
  float32x4_t v281;
  float32x4_t v282;
  float32x4_t v283;
  float32x4_t v284;
  float32x4_t v285;
  float32x4_t v286;
  float32x4_t v287;
  float32x4_t v288;
  float32x4_t v289;
  float32x4_t v290;
  float32x4_t v291;
  float32x4_t v292;
  float32x4_t v293;
  float32x4_t v294;
  float32x4_t v295;
  float32x4_t v296;
  float32x4_t v297;
  float32x4_t v298;
  float32x4_t v299;
  float32x4_t v300;
  float32x4_t v301;
  float32x4_t v302;
  float32x4_t v303;
  float32x4_t v304;
  float32x4_t v305;
  float32x4_t v306;
  float32x4_t v307;
  float32x4_t v308;
  float32x4_t v309;
  float32x4_t v310;
  float32x4_t v311;
  float32x4_t v312;
  float32x4_t v313;
  float32x4_t v314;
  float32x4_t v315;
  float32x4_t v316;
  float32x4_t v317;
  float32x4_t v318;
  float32x4_t v319;
  float32x4_t v320;
  float32x4_t v321;
  float32x4_t v322;
  float32x4_t v323;
  float32x4_t v324;
  float32x4_t v325;
  float32x4_t v326;
  float32x4_t v327;
  float32x4_t v328;
  float32x4_t v329;
  float32x4_t v330;
  float32x4_t v331;
  float32x4_t v332;
  float32x4_t v333;
  float32x4_t v334;
  float32x4_t v335;
  float32x4_t v336;
  float32x4_t v337;
  float32x4_t v338;
  float32x4_t v339;
  float32x4_t v340;
  float32x4_t v341;
  float32x4_t v342;
  float32x4_t v343;
  float32x4_t v344;
  float32x4_t v345;
  float32x4_t v346;
  float32x4_t v347;
  float32x4_t v348;
  float32x4_t v349;
  float32x4_t v350;
  float32x4_t v351;
  float32x4_t v352;
  float32x4_t v353;
  float32x4_t v354;
  float32x4_t v355;
  float32x4_t v356;
  float32x4_t v357;
  float32x4_t v358;
  float32x4_t v359;
  float32x4_t v360;
  float32x4_t v361;
  float32x4_t v362;
  float32x4_t v363;
  float32x4_t v364;
  float32x4_t v365;
  float32x4_t v366;
  float32x4_t v367;
  float32x4_t v368;
  float32x4_t v369;
  float32x4_t v370;
  float32x4_t v371;
  float32x4_t v372;
  float32x4_t v373;
  float32x4_t v374;
  float32x4_t v375;
  float32x4_t v376;
  float32x4_t v377;
  float32x4_t v378;
  float32x4_t v379;
  float32x4_t v380;
  float32x4_t *__C;
  char __str[16];
  __int128 v383;
  _BYTE keyExistsAndHasValidFormat[48];
  _BYTE v385[32];
  float32x4_t v386;
  float32x4_t v387;
  float32x4_t v388;
  float32x4_t v389;
  float32x4_t v390;
  float32x4_t v391;
  float32x4_t v392;
  float32x4_t v393;
  float32x4_t v394;
  float32x4_t v395;
  float32x4_t v396;
  float32x4_t v397;
  float32x4_t v398;
  float32x4_t v399;
  float32x4_t v400;
  float32x4_t v401;
  float32x4_t v402;
  float32x4_t v403;
  float32x4_t v404;
  float32x4_t v405;
  float32x4_t v406;
  float32x4_t v407;
  float32x4_t v408;
  float32x4_t v409;
  float32x4_t v410;
  float32x4_t v411;
  float32x4_t v412;
  float32x4_t v413;
  float32x4_t v414;
  float32x4_t v415;
  float32x4_t v416;
  float32x4_t v417;
  float32x4_t v418;
  float32x4_t v419;
  float32x4_t v420;
  float32x4_t v421;
  float32x4_t v422;
  float32x4_t v423;
  float32x4_t v424;
  float32x4_t v425;
  float32x4_t v426;
  float32x4_t v427;
  float32x4_t v428;
  float32x4_t v429;
  float32x4_t v430;
  float32x4_t v431;
  float32x4_t v432;
  float32x4_t v433;
  float32x4_t v434;
  float32x4_t v435;
  float32x4_t v436;
  float32x4_t v437;
  float32x4_t v438;
  float32x4_t v439;
  float32x4_t v440;
  float32x4_t v441;
  float32x4_t v442;
  float32x4_t v443;
  float32x4_t v444;
  float32x4_t v445;
  float32x4_t v446;
  float32x4_t v447;
  float32x4_t v448;
  float32x4_t v449;
  float32x4_t v450;
  float32x4_t v451;
  float32x4_t v452;
  float32x4_t v453;
  float32x4_t v454;
  float32x4_t v455;
  float32x4_t v456;
  float32x4_t v457;
  float32x4_t v458;
  float32x4_t v459;
  float32x4_t v460;
  float32x4_t v461;
  float32x4_t v462;
  float32x4_t v463;
  float32x4_t v464;
  float32x4_t v465;
  float32x4_t v466;
  float32x4_t v467;
  float32x4_t v468;
  float32x4_t v469;
  float32x4_t v470;
  float32x4_t v471;
  float32x4_t v472;
  float32x4_t v473;
  float32x4_t v474;
  float32x4_t v475;
  float32x4_t v476;
  float32x4_t v477;
  float32x4_t v478;
  float32x4_t v479;
  float32x4_t v480;
  float32x4_t v481;
  float32x4_t v482;
  float32x4_t v483;
  float32x4_t v484;
  float32x4_t v485;
  float32x4_t v486;
  float32x4_t v487;
  float32x4_t v488;
  float32x4_t v489;
  float32x4_t v490;
  float32x4_t v491;
  float32x4_t v492;
  float32x4_t v493;
  float32x4_t v494;
  float32x4_t v495;
  float32x4_t v496;
  float32x4_t v497;
  float32x4_t v498;
  float32x4_t v499;
  float32x4_t v500;
  float32x4_t v501;
  float32x4_t v502;
  float32x4_t v503;
  float32x4_t v504;
  float32x4_t v505;
  float32x4_t v506;
  float32x4_t v507;
  float32x4_t v508;
  uint64_t v509;

  v1 = MEMORY[0x1E0C80A78](a1);
  AppIntegerValue = v2;
  v5 = v4;
  v7 = v6;
  v9 = v8;
  v10 = v1;
  v509 = *MEMORY[0x1E0C80C00];
  v233 = v11;
  v12 = *v11;
  v383 = 0u;
  *(_OWORD *)__str = 0u;
  snprintf(__str, 0x20uLL, "%02x%02x%02x%02x...%02x%02x%02x%02x", *v8, v8[1], v8[2], v8[3], v8[1020], v8[1021], v8[1022], v8[1023]);
  if (!(_DWORD)AppIntegerValue)
    AppIntegerValue = CFPreferencesGetAppIntegerValue(CFSTR("IVFNumberOfParitionsProbe"), CFSTR("com.apple.Spotlight"), 0);
  keyExistsAndHasValidFormat[0] = 0;
  v13 = CFPreferencesGetAppIntegerValue(CFSTR("IVFPartitionProbeMin"), CFSTR("com.apple.Spotlight"), keyExistsAndHasValidFormat);
  if (keyExistsAndHasValidFormat[0])
    v14 = v13;
  else
    v14 = 10000;
  if (10 * v12 <= v14)
    v15 = v14;
  else
    v15 = 10 * v12;
  v16 = v15
      * IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nPartitions(v10);
  v17 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nVectors(v10);
  keyExistsAndHasValidFormat[0] = 0;
  v18 = v16 / v17;
  v19 = CFPreferencesGetAppIntegerValue(CFSTR("IVFPartitionProbeMin"), CFSTR("com.apple.Spotlight"), keyExistsAndHasValidFormat);
  if (keyExistsAndHasValidFormat[0])
    v20 = v19;
  else
    v20 = 7;
  v249 = 0;
  v250 = &v249;
  if (v18 <= v20)
    v21 = v20;
  else
    v21 = v18;
  v252 = 0;
  v251 = 0x2000000000;
  v245 = 0;
  v246 = &v245;
  v248 = 0;
  v247 = 0x2000000000;
  v244 = 0;
  *(_OWORD *)v242 = 0u;
  *(_OWORD *)__p = 0u;
  QuantizerManager<float,768>::aNNLogQueryVecIds((uint64_t)v242);
  Current = CFAbsoluteTimeGetCurrent();
  v232 = v12;
  if ((v5 & 1) != 0
    || IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nPartitions(v10) <= v21
    || IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nVectors(v10) <= v15)
  {
    v63 = *__error();
    v64 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT))
    {
      v65 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nVectors(v10);
      v66 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nPartitions(v10);
      v67 = v7;
      *(_DWORD *)keyExistsAndHasValidFormat = 136316162;
      *(_QWORD *)&keyExistsAndHasValidFormat[4] = __str;
      *(_WORD *)&keyExistsAndHasValidFormat[12] = 1024;
      *(_DWORD *)&keyExistsAndHasValidFormat[14] = v12;
      *(_WORD *)&keyExistsAndHasValidFormat[18] = 1024;
      *(_DWORD *)&keyExistsAndHasValidFormat[20] = v65;
      *(_WORD *)&keyExistsAndHasValidFormat[24] = 1024;
      *(_DWORD *)&keyExistsAndHasValidFormat[26] = v66;
      *(_WORD *)&keyExistsAndHasValidFormat[30] = 2048;
      *(double *)&keyExistsAndHasValidFormat[32] = v7;
      _os_log_impl(&dword_1B8270000, v64, OS_LOG_TYPE_DEFAULT, "brute force search %s top %u of %u vectors in %u partitions max_distance=%f", keyExistsAndHasValidFormat, 0x28u);
    }
    else
    {
      v67 = v7;
    }
    *__error() = v63;
    LODWORD(lock) = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nPartitions(v10);
    v68 = 0;
    v69 = *(_QWORD *)(v10 + 32);
    do
    {
      if (v68 == *(_DWORD *)(v69 + 24))
        goto LABEL_94;
      ++*((_DWORD *)v250 + 6);
      v70 = IVFVectorIndexTemplate<float,256>::VectorStore<vi_onefixedsize_memory_allocator,vi_memory_postings>::Iterator::operator*(v69, v68);
      v71 = *(unsigned int *)(v70 + 1040);
      v72 = *((float16x8_t *)v9 + 1);
      v73 = vcvtq_f32_f16(*(float16x4_t *)v9);
      *(float32x4_t *)&keyExistsAndHasValidFormat[16] = vcvt_hight_f32_f16(*(float16x8_t *)v9);
      *(float32x4_t *)keyExistsAndHasValidFormat = v73;
      *(float32x4_t *)v385 = vcvt_hight_f32_f16(v72);
      *(float32x4_t *)&keyExistsAndHasValidFormat[32] = vcvtq_f32_f16(*(float16x4_t *)v72.i8);
      v74 = *((float16x8_t *)v9 + 2);
      v75 = *((float16x8_t *)v9 + 3);
      v386 = vcvt_hight_f32_f16(v74);
      *(float32x4_t *)&v385[16] = vcvtq_f32_f16(*(float16x4_t *)v74.i8);
      v388 = vcvt_hight_f32_f16(v75);
      v387 = vcvtq_f32_f16(*(float16x4_t *)v75.i8);
      v76 = *((float16x8_t *)v9 + 4);
      v77 = *((float16x8_t *)v9 + 5);
      v390 = vcvt_hight_f32_f16(v76);
      v389 = vcvtq_f32_f16(*(float16x4_t *)v76.i8);
      v392 = vcvt_hight_f32_f16(v77);
      v391 = vcvtq_f32_f16(*(float16x4_t *)v77.i8);
      v78 = *((float16x8_t *)v9 + 6);
      v79 = *((float16x8_t *)v9 + 7);
      v394 = vcvt_hight_f32_f16(v78);
      v393 = vcvtq_f32_f16(*(float16x4_t *)v78.i8);
      v396 = vcvt_hight_f32_f16(v79);
      v395 = vcvtq_f32_f16(*(float16x4_t *)v79.i8);
      v80 = *((float16x8_t *)v9 + 8);
      v81 = *((float16x8_t *)v9 + 9);
      v398 = vcvt_hight_f32_f16(v80);
      v397 = vcvtq_f32_f16(*(float16x4_t *)v80.i8);
      v400 = vcvt_hight_f32_f16(v81);
      v399 = vcvtq_f32_f16(*(float16x4_t *)v81.i8);
      v82 = *((float16x8_t *)v9 + 10);
      v83 = *((float16x8_t *)v9 + 11);
      v402 = vcvt_hight_f32_f16(v82);
      v401 = vcvtq_f32_f16(*(float16x4_t *)v82.i8);
      v404 = vcvt_hight_f32_f16(v83);
      v403 = vcvtq_f32_f16(*(float16x4_t *)v83.i8);
      v84 = *((float16x8_t *)v9 + 12);
      v85 = *((float16x8_t *)v9 + 13);
      v406 = vcvt_hight_f32_f16(v84);
      v405 = vcvtq_f32_f16(*(float16x4_t *)v84.i8);
      v408 = vcvt_hight_f32_f16(v85);
      v407 = vcvtq_f32_f16(*(float16x4_t *)v85.i8);
      v86 = *((float16x8_t *)v9 + 14);
      v87 = *((float16x8_t *)v9 + 15);
      v410 = vcvt_hight_f32_f16(v86);
      v409 = vcvtq_f32_f16(*(float16x4_t *)v86.i8);
      v412 = vcvt_hight_f32_f16(v87);
      v411 = vcvtq_f32_f16(*(float16x4_t *)v87.i8);
      v88 = *((float16x8_t *)v9 + 16);
      v89 = *((float16x8_t *)v9 + 17);
      v414 = vcvt_hight_f32_f16(v88);
      v413 = vcvtq_f32_f16(*(float16x4_t *)v88.i8);
      v416 = vcvt_hight_f32_f16(v89);
      v415 = vcvtq_f32_f16(*(float16x4_t *)v89.i8);
      v90 = *((float16x8_t *)v9 + 18);
      v91 = *((float16x8_t *)v9 + 19);
      v418 = vcvt_hight_f32_f16(v90);
      v417 = vcvtq_f32_f16(*(float16x4_t *)v90.i8);
      v420 = vcvt_hight_f32_f16(v91);
      v419 = vcvtq_f32_f16(*(float16x4_t *)v91.i8);
      v92 = *((float16x8_t *)v9 + 20);
      v93 = *((float16x8_t *)v9 + 21);
      v422 = vcvt_hight_f32_f16(v92);
      v421 = vcvtq_f32_f16(*(float16x4_t *)v92.i8);
      v424 = vcvt_hight_f32_f16(v93);
      v423 = vcvtq_f32_f16(*(float16x4_t *)v93.i8);
      v94 = *((float16x8_t *)v9 + 22);
      v95 = *((float16x8_t *)v9 + 23);
      v426 = vcvt_hight_f32_f16(v94);
      v425 = vcvtq_f32_f16(*(float16x4_t *)v94.i8);
      v428 = vcvt_hight_f32_f16(v95);
      v427 = vcvtq_f32_f16(*(float16x4_t *)v95.i8);
      v96 = *((float16x8_t *)v9 + 24);
      v97 = *((float16x8_t *)v9 + 25);
      v430 = vcvt_hight_f32_f16(v96);
      v429 = vcvtq_f32_f16(*(float16x4_t *)v96.i8);
      v432 = vcvt_hight_f32_f16(v97);
      v431 = vcvtq_f32_f16(*(float16x4_t *)v97.i8);
      v98 = *((float16x8_t *)v9 + 26);
      v99 = *((float16x8_t *)v9 + 27);
      v434 = vcvt_hight_f32_f16(v98);
      v433 = vcvtq_f32_f16(*(float16x4_t *)v98.i8);
      v436 = vcvt_hight_f32_f16(v99);
      v435 = vcvtq_f32_f16(*(float16x4_t *)v99.i8);
      v100 = *((float16x8_t *)v9 + 28);
      v101 = *((float16x8_t *)v9 + 29);
      v438 = vcvt_hight_f32_f16(v100);
      v437 = vcvtq_f32_f16(*(float16x4_t *)v100.i8);
      v440 = vcvt_hight_f32_f16(v101);
      v439 = vcvtq_f32_f16(*(float16x4_t *)v101.i8);
      v102 = *((float16x8_t *)v9 + 30);
      v103 = *((float16x8_t *)v9 + 31);
      v442 = vcvt_hight_f32_f16(v102);
      v441 = vcvtq_f32_f16(*(float16x4_t *)v102.i8);
      v444 = vcvt_hight_f32_f16(v103);
      v443 = vcvtq_f32_f16(*(float16x4_t *)v103.i8);
      v104 = *((float16x8_t *)v9 + 32);
      v105 = *((float16x8_t *)v9 + 33);
      v446 = vcvt_hight_f32_f16(v104);
      v445 = vcvtq_f32_f16(*(float16x4_t *)v104.i8);
      v448 = vcvt_hight_f32_f16(v105);
      v447 = vcvtq_f32_f16(*(float16x4_t *)v105.i8);
      v106 = *((float16x8_t *)v9 + 34);
      v107 = *((float16x8_t *)v9 + 35);
      v450 = vcvt_hight_f32_f16(v106);
      v449 = vcvtq_f32_f16(*(float16x4_t *)v106.i8);
      v452 = vcvt_hight_f32_f16(v107);
      v451 = vcvtq_f32_f16(*(float16x4_t *)v107.i8);
      v108 = *((float16x8_t *)v9 + 36);
      v109 = *((float16x8_t *)v9 + 37);
      v454 = vcvt_hight_f32_f16(v108);
      v453 = vcvtq_f32_f16(*(float16x4_t *)v108.i8);
      v456 = vcvt_hight_f32_f16(v109);
      v455 = vcvtq_f32_f16(*(float16x4_t *)v109.i8);
      v110 = *((float16x8_t *)v9 + 38);
      v111 = *((float16x8_t *)v9 + 39);
      v458 = vcvt_hight_f32_f16(v110);
      v457 = vcvtq_f32_f16(*(float16x4_t *)v110.i8);
      v460 = vcvt_hight_f32_f16(v111);
      v459 = vcvtq_f32_f16(*(float16x4_t *)v111.i8);
      v112 = *((float16x8_t *)v9 + 40);
      v113 = *((float16x8_t *)v9 + 41);
      v462 = vcvt_hight_f32_f16(v112);
      v461 = vcvtq_f32_f16(*(float16x4_t *)v112.i8);
      v464 = vcvt_hight_f32_f16(v113);
      v463 = vcvtq_f32_f16(*(float16x4_t *)v113.i8);
      v114 = *((float16x8_t *)v9 + 42);
      v115 = *((float16x8_t *)v9 + 43);
      v466 = vcvt_hight_f32_f16(v114);
      v465 = vcvtq_f32_f16(*(float16x4_t *)v114.i8);
      v468 = vcvt_hight_f32_f16(v115);
      v467 = vcvtq_f32_f16(*(float16x4_t *)v115.i8);
      v116 = *((float16x8_t *)v9 + 44);
      v117 = *((float16x8_t *)v9 + 45);
      v470 = vcvt_hight_f32_f16(v116);
      v469 = vcvtq_f32_f16(*(float16x4_t *)v116.i8);
      v472 = vcvt_hight_f32_f16(v117);
      v471 = vcvtq_f32_f16(*(float16x4_t *)v117.i8);
      v118 = *((float16x8_t *)v9 + 46);
      v119 = *((float16x8_t *)v9 + 47);
      v474 = vcvt_hight_f32_f16(v118);
      v473 = vcvtq_f32_f16(*(float16x4_t *)v118.i8);
      v476 = vcvt_hight_f32_f16(v119);
      v475 = vcvtq_f32_f16(*(float16x4_t *)v119.i8);
      v120 = *((float16x8_t *)v9 + 48);
      v121 = *((float16x8_t *)v9 + 49);
      v478 = vcvt_hight_f32_f16(v120);
      v477 = vcvtq_f32_f16(*(float16x4_t *)v120.i8);
      v480 = vcvt_hight_f32_f16(v121);
      v479 = vcvtq_f32_f16(*(float16x4_t *)v121.i8);
      v122 = *((float16x8_t *)v9 + 50);
      v123 = *((float16x8_t *)v9 + 51);
      v482 = vcvt_hight_f32_f16(v122);
      v481 = vcvtq_f32_f16(*(float16x4_t *)v122.i8);
      v484 = vcvt_hight_f32_f16(v123);
      v483 = vcvtq_f32_f16(*(float16x4_t *)v123.i8);
      v124 = *((float16x8_t *)v9 + 52);
      v125 = *((float16x8_t *)v9 + 53);
      v486 = vcvt_hight_f32_f16(v124);
      v485 = vcvtq_f32_f16(*(float16x4_t *)v124.i8);
      v488 = vcvt_hight_f32_f16(v125);
      v487 = vcvtq_f32_f16(*(float16x4_t *)v125.i8);
      v126 = *((float16x8_t *)v9 + 54);
      v127 = *((float16x8_t *)v9 + 55);
      v490 = vcvt_hight_f32_f16(v126);
      v489 = vcvtq_f32_f16(*(float16x4_t *)v126.i8);
      v492 = vcvt_hight_f32_f16(v127);
      v491 = vcvtq_f32_f16(*(float16x4_t *)v127.i8);
      v128 = *((float16x8_t *)v9 + 56);
      v129 = *((float16x8_t *)v9 + 57);
      v494 = vcvt_hight_f32_f16(v128);
      v493 = vcvtq_f32_f16(*(float16x4_t *)v128.i8);
      v496 = vcvt_hight_f32_f16(v129);
      v495 = vcvtq_f32_f16(*(float16x4_t *)v129.i8);
      v130 = *((float16x8_t *)v9 + 58);
      v131 = *((float16x8_t *)v9 + 59);
      v498 = vcvt_hight_f32_f16(v130);
      v497 = vcvtq_f32_f16(*(float16x4_t *)v130.i8);
      v500 = vcvt_hight_f32_f16(v131);
      v499 = vcvtq_f32_f16(*(float16x4_t *)v131.i8);
      v132 = *((float16x8_t *)v9 + 60);
      v133 = *((float16x8_t *)v9 + 61);
      v502 = vcvt_hight_f32_f16(v132);
      v501 = vcvtq_f32_f16(*(float16x4_t *)v132.i8);
      v504 = vcvt_hight_f32_f16(v133);
      v503 = vcvtq_f32_f16(*(float16x4_t *)v133.i8);
      v134 = *((float16x8_t *)v9 + 62);
      v135 = *((float16x8_t *)v9 + 63);
      v506 = vcvt_hight_f32_f16(v134);
      v505 = vcvtq_f32_f16(*(float16x4_t *)v134.i8);
      v508 = vcvt_hight_f32_f16(v135);
      v507 = vcvtq_f32_f16(*(float16x4_t *)v135.i8);
      bzero(&__B, 0x800uLL);
      v136 = *(float16x8_t *)(v70 + 16);
      v137 = vcvt_hight_f32_f16(*(float16x8_t *)v70);
      __B = vcvtq_f32_f16(*(float16x4_t *)v70);
      v254 = v137;
      v255 = vcvtq_f32_f16(*(float16x4_t *)v136.i8);
      v256 = vcvt_hight_f32_f16(v136);
      v138 = *(float16x8_t *)(v70 + 32);
      v139 = *(float16x8_t *)(v70 + 48);
      v257 = vcvtq_f32_f16(*(float16x4_t *)v138.i8);
      v258 = vcvt_hight_f32_f16(v138);
      v259 = vcvtq_f32_f16(*(float16x4_t *)v139.i8);
      v260 = vcvt_hight_f32_f16(v139);
      v140 = *(float16x8_t *)(v70 + 64);
      v141 = *(float16x8_t *)(v70 + 80);
      v261 = vcvtq_f32_f16(*(float16x4_t *)v140.i8);
      v262 = vcvt_hight_f32_f16(v140);
      v263 = vcvtq_f32_f16(*(float16x4_t *)v141.i8);
      v264 = vcvt_hight_f32_f16(v141);
      v142 = *(float16x8_t *)(v70 + 96);
      v143 = *(float16x8_t *)(v70 + 112);
      v265 = vcvtq_f32_f16(*(float16x4_t *)v142.i8);
      v266 = vcvt_hight_f32_f16(v142);
      v267 = vcvtq_f32_f16(*(float16x4_t *)v143.i8);
      v268 = vcvt_hight_f32_f16(v143);
      v144 = *(float16x8_t *)(v70 + 128);
      v145 = *(float16x8_t *)(v70 + 144);
      v269 = vcvtq_f32_f16(*(float16x4_t *)v144.i8);
      v270 = vcvt_hight_f32_f16(v144);
      v271 = vcvtq_f32_f16(*(float16x4_t *)v145.i8);
      v272 = vcvt_hight_f32_f16(v145);
      v146 = *(float16x8_t *)(v70 + 160);
      v147 = *(float16x8_t *)(v70 + 176);
      v273 = vcvtq_f32_f16(*(float16x4_t *)v146.i8);
      v274 = vcvt_hight_f32_f16(v146);
      v275 = vcvtq_f32_f16(*(float16x4_t *)v147.i8);
      v276 = vcvt_hight_f32_f16(v147);
      v148 = *(float16x8_t *)(v70 + 192);
      v149 = *(float16x8_t *)(v70 + 208);
      v277 = vcvtq_f32_f16(*(float16x4_t *)v148.i8);
      v278 = vcvt_hight_f32_f16(v148);
      v279 = vcvtq_f32_f16(*(float16x4_t *)v149.i8);
      v280 = vcvt_hight_f32_f16(v149);
      v150 = *(float16x8_t *)(v70 + 224);
      v151 = *(float16x8_t *)(v70 + 240);
      v281 = vcvtq_f32_f16(*(float16x4_t *)v150.i8);
      v282 = vcvt_hight_f32_f16(v150);
      v283 = vcvtq_f32_f16(*(float16x4_t *)v151.i8);
      v284 = vcvt_hight_f32_f16(v151);
      v152 = *(float16x8_t *)(v70 + 256);
      v153 = *(float16x8_t *)(v70 + 272);
      v285 = vcvtq_f32_f16(*(float16x4_t *)v152.i8);
      v286 = vcvt_hight_f32_f16(v152);
      v287 = vcvtq_f32_f16(*(float16x4_t *)v153.i8);
      v288 = vcvt_hight_f32_f16(v153);
      v154 = *(float16x8_t *)(v70 + 288);
      v155 = *(float16x8_t *)(v70 + 304);
      v289 = vcvtq_f32_f16(*(float16x4_t *)v154.i8);
      v290 = vcvt_hight_f32_f16(v154);
      v291 = vcvtq_f32_f16(*(float16x4_t *)v155.i8);
      v292 = vcvt_hight_f32_f16(v155);
      v156 = *(float16x8_t *)(v70 + 320);
      v157 = *(float16x8_t *)(v70 + 336);
      v293 = vcvtq_f32_f16(*(float16x4_t *)v156.i8);
      v294 = vcvt_hight_f32_f16(v156);
      v295 = vcvtq_f32_f16(*(float16x4_t *)v157.i8);
      v296 = vcvt_hight_f32_f16(v157);
      v158 = *(float16x8_t *)(v70 + 352);
      v159 = *(float16x8_t *)(v70 + 368);
      v297 = vcvtq_f32_f16(*(float16x4_t *)v158.i8);
      v298 = vcvt_hight_f32_f16(v158);
      v299 = vcvtq_f32_f16(*(float16x4_t *)v159.i8);
      v300 = vcvt_hight_f32_f16(v159);
      v160 = *(float16x8_t *)(v70 + 384);
      v161 = *(float16x8_t *)(v70 + 400);
      v301 = vcvtq_f32_f16(*(float16x4_t *)v160.i8);
      v302 = vcvt_hight_f32_f16(v160);
      v303 = vcvtq_f32_f16(*(float16x4_t *)v161.i8);
      v304 = vcvt_hight_f32_f16(v161);
      v162 = *(float16x8_t *)(v70 + 416);
      v163 = *(float16x8_t *)(v70 + 432);
      v305 = vcvtq_f32_f16(*(float16x4_t *)v162.i8);
      v306 = vcvt_hight_f32_f16(v162);
      v307 = vcvtq_f32_f16(*(float16x4_t *)v163.i8);
      v308 = vcvt_hight_f32_f16(v163);
      v164 = *(float16x8_t *)(v70 + 448);
      v165 = *(float16x8_t *)(v70 + 464);
      v309 = vcvtq_f32_f16(*(float16x4_t *)v164.i8);
      v310 = vcvt_hight_f32_f16(v164);
      v311 = vcvtq_f32_f16(*(float16x4_t *)v165.i8);
      v312 = vcvt_hight_f32_f16(v165);
      v166 = *(float16x8_t *)(v70 + 480);
      v167 = *(float16x8_t *)(v70 + 496);
      v313 = vcvtq_f32_f16(*(float16x4_t *)v166.i8);
      v314 = vcvt_hight_f32_f16(v166);
      v315 = vcvtq_f32_f16(*(float16x4_t *)v167.i8);
      v316 = vcvt_hight_f32_f16(v167);
      v168 = *(float16x8_t *)(v70 + 512);
      v169 = *(float16x8_t *)(v70 + 528);
      v318 = vcvt_hight_f32_f16(v168);
      v317 = vcvtq_f32_f16(*(float16x4_t *)v168.i8);
      v320 = vcvt_hight_f32_f16(v169);
      v319 = vcvtq_f32_f16(*(float16x4_t *)v169.i8);
      v170 = *(float16x8_t *)(v70 + 544);
      v171 = *(float16x8_t *)(v70 + 560);
      v322 = vcvt_hight_f32_f16(v170);
      v321 = vcvtq_f32_f16(*(float16x4_t *)v170.i8);
      v324 = vcvt_hight_f32_f16(v171);
      v323 = vcvtq_f32_f16(*(float16x4_t *)v171.i8);
      v172 = *(float16x8_t *)(v70 + 576);
      v173 = *(float16x8_t *)(v70 + 592);
      v326 = vcvt_hight_f32_f16(v172);
      v325 = vcvtq_f32_f16(*(float16x4_t *)v172.i8);
      v328 = vcvt_hight_f32_f16(v173);
      v327 = vcvtq_f32_f16(*(float16x4_t *)v173.i8);
      v174 = *(float16x8_t *)(v70 + 608);
      v175 = *(float16x8_t *)(v70 + 624);
      v330 = vcvt_hight_f32_f16(v174);
      v329 = vcvtq_f32_f16(*(float16x4_t *)v174.i8);
      v332 = vcvt_hight_f32_f16(v175);
      v331 = vcvtq_f32_f16(*(float16x4_t *)v175.i8);
      v176 = *(float16x8_t *)(v70 + 640);
      v177 = *(float16x8_t *)(v70 + 656);
      v334 = vcvt_hight_f32_f16(v176);
      v333 = vcvtq_f32_f16(*(float16x4_t *)v176.i8);
      v336 = vcvt_hight_f32_f16(v177);
      v335 = vcvtq_f32_f16(*(float16x4_t *)v177.i8);
      v178 = *(float16x8_t *)(v70 + 672);
      v179 = *(float16x8_t *)(v70 + 688);
      v338 = vcvt_hight_f32_f16(v178);
      v337 = vcvtq_f32_f16(*(float16x4_t *)v178.i8);
      v340 = vcvt_hight_f32_f16(v179);
      v339 = vcvtq_f32_f16(*(float16x4_t *)v179.i8);
      v180 = *(float16x8_t *)(v70 + 704);
      v181 = *(float16x8_t *)(v70 + 720);
      v342 = vcvt_hight_f32_f16(v180);
      v341 = vcvtq_f32_f16(*(float16x4_t *)v180.i8);
      v344 = vcvt_hight_f32_f16(v181);
      v343 = vcvtq_f32_f16(*(float16x4_t *)v181.i8);
      v182 = *(float16x8_t *)(v70 + 736);
      v183 = *(float16x8_t *)(v70 + 752);
      v346 = vcvt_hight_f32_f16(v182);
      v345 = vcvtq_f32_f16(*(float16x4_t *)v182.i8);
      v348 = vcvt_hight_f32_f16(v183);
      v347 = vcvtq_f32_f16(*(float16x4_t *)v183.i8);
      v184 = *(float16x8_t *)(v70 + 768);
      v185 = *(float16x8_t *)(v70 + 784);
      v350 = vcvt_hight_f32_f16(v184);
      v349 = vcvtq_f32_f16(*(float16x4_t *)v184.i8);
      v352 = vcvt_hight_f32_f16(v185);
      v351 = vcvtq_f32_f16(*(float16x4_t *)v185.i8);
      v186 = *(float16x8_t *)(v70 + 800);
      v187 = *(float16x8_t *)(v70 + 816);
      v354 = vcvt_hight_f32_f16(v186);
      v353 = vcvtq_f32_f16(*(float16x4_t *)v186.i8);
      v356 = vcvt_hight_f32_f16(v187);
      v355 = vcvtq_f32_f16(*(float16x4_t *)v187.i8);
      v188 = *(float16x8_t *)(v70 + 832);
      v189 = *(float16x8_t *)(v70 + 848);
      v358 = vcvt_hight_f32_f16(v188);
      v357 = vcvtq_f32_f16(*(float16x4_t *)v188.i8);
      v360 = vcvt_hight_f32_f16(v189);
      v359 = vcvtq_f32_f16(*(float16x4_t *)v189.i8);
      v190 = *(float16x8_t *)(v70 + 864);
      v191 = *(float16x8_t *)(v70 + 880);
      v362 = vcvt_hight_f32_f16(v190);
      v361 = vcvtq_f32_f16(*(float16x4_t *)v190.i8);
      v364 = vcvt_hight_f32_f16(v191);
      v363 = vcvtq_f32_f16(*(float16x4_t *)v191.i8);
      v192 = *(float16x8_t *)(v70 + 896);
      v193 = *(float16x8_t *)(v70 + 912);
      v366 = vcvt_hight_f32_f16(v192);
      v365 = vcvtq_f32_f16(*(float16x4_t *)v192.i8);
      v368 = vcvt_hight_f32_f16(v193);
      v367 = vcvtq_f32_f16(*(float16x4_t *)v193.i8);
      v194 = *(float16x8_t *)(v70 + 928);
      v195 = *(float16x8_t *)(v70 + 944);
      v370 = vcvt_hight_f32_f16(v194);
      v369 = vcvtq_f32_f16(*(float16x4_t *)v194.i8);
      v372 = vcvt_hight_f32_f16(v195);
      v371 = vcvtq_f32_f16(*(float16x4_t *)v195.i8);
      v196 = *(float16x8_t *)(v70 + 960);
      v197 = *(float16x8_t *)(v70 + 976);
      v374 = vcvt_hight_f32_f16(v196);
      v373 = vcvtq_f32_f16(*(float16x4_t *)v196.i8);
      v376 = vcvt_hight_f32_f16(v197);
      v375 = vcvtq_f32_f16(*(float16x4_t *)v197.i8);
      v198 = *(float16x8_t *)(v70 + 992);
      v199 = *(float16x8_t *)(v70 + 1008);
      v378 = vcvt_hight_f32_f16(v198);
      v377 = vcvtq_f32_f16(*(float16x4_t *)v198.i8);
      v380 = vcvt_hight_f32_f16(v199);
      v379 = vcvtq_f32_f16(*(float16x4_t *)v199.i8);
      LODWORD(__C) = 2139095039;
      vDSP_distancesq((const float *)keyExistsAndHasValidFormat, 1, __B.f32, 1, (float *)&__C, 0x200uLL);
      if (v242[1])
      {
        v200 = (uint8x8_t)vcnt_s8((int8x8_t)v242[1]);
        v200.i16[0] = vaddlv_u8(v200);
        if (v200.u32[0] > 1uLL)
        {
          v201 = v71;
          if (v242[1] <= (void *)v71)
            v201 = v71 % (unint64_t)v242[1];
        }
        else
        {
          v201 = (LODWORD(v242[1]) - 1) & v71;
        }
        v202 = (uint64_t *)*((_QWORD *)v242[0] + v201);
        if (v202)
        {
          v202 = (uint64_t *)*v202;
          if (v202)
          {
            if (v200.u32[0] < 2uLL)
            {
              while (1)
              {
                v204 = v202[1];
                if (v204 == v71)
                {
                  if (*((_DWORD *)v202 + 4) == (_DWORD)v71)
                    goto LABEL_84;
                }
                else if ((v204 & ((unint64_t)v242[1] - 1)) != v201)
                {
                  goto LABEL_83;
                }
                v202 = (uint64_t *)*v202;
                if (!v202)
                  goto LABEL_84;
              }
            }
            do
            {
              v203 = v202[1];
              if (v203 == v71)
              {
                if (*((_DWORD *)v202 + 4) == (_DWORD)v71)
                  break;
              }
              else
              {
                if ((void *)v203 >= v242[1])
                  v203 %= (unint64_t)v242[1];
                if (v203 != v201)
                  goto LABEL_83;
              }
              v202 = (uint64_t *)*v202;
            }
            while (v202);
          }
        }
      }
      else
      {
LABEL_83:
        v202 = 0;
      }
LABEL_84:
      v205 = *(float *)&__C;
      if (v7 == 0.0 || *(float *)&__C <= v7)
      {
        if (v202)
        {
          v208 = *__error();
          v209 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v209, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)keyExistsAndHasValidFormat = 67109376;
            *(_DWORD *)&keyExistsAndHasValidFormat[4] = v71;
            *(_WORD *)&keyExistsAndHasValidFormat[8] = 2048;
            *(double *)&keyExistsAndHasValidFormat[10] = v205;
            _os_log_impl(&dword_1B8270000, v209, OS_LOG_TYPE_DEFAULT, "Include vec_id: %u distance %f", keyExistsAndHasValidFormat, 0x12u);
          }
          *__error() = v208;
        }
        *(_OWORD *)keyExistsAndHasValidFormat = *(_OWORD *)(v70 + 1024);
        *(_DWORD *)&keyExistsAndHasValidFormat[16] = v71;
        *(float *)&keyExistsAndHasValidFormat[20] = v205;
        MaxSizePriorityQueue<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_memory_postings>,std::vector<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_memory_postings>,std::allocator<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_memory_postings>>>,std::less<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_memory_postings>>>::push(v233, (__int128 *)keyExistsAndHasValidFormat);
      }
      else
      {
        if (v202)
        {
          v206 = *__error();
          v207 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v207, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)keyExistsAndHasValidFormat = 67109632;
            *(_DWORD *)&keyExistsAndHasValidFormat[4] = v71;
            *(_WORD *)&keyExistsAndHasValidFormat[8] = 2048;
            *(double *)&keyExistsAndHasValidFormat[10] = v205;
            *(_WORD *)&keyExistsAndHasValidFormat[18] = 2048;
            *(double *)&keyExistsAndHasValidFormat[20] = v67;
            _os_log_impl(&dword_1B8270000, v207, OS_LOG_TYPE_DEFAULT, "Skip vec_id: %u distance %f > %f", keyExistsAndHasValidFormat, 0x1Cu);
          }
          *__error() = v206;
        }
        ++*((_DWORD *)v246 + 6);
      }
      ++v68;
    }
    while (v69 == *(_QWORD *)(v10 + 32));
    v228 = __si_assert_copy_extra_268();
    v229 = v228;
    v230 = "";
    if (v228)
      v230 = v228;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1814, "store == other.store", v230);
    free(v229);
    if (!__valid_fs(-1))
    {
      MEMORY[0xC00] = -559038737;
      abort();
    }
    MEMORY[0xBAD] = -559038737;
    goto LABEL_126;
  }
  if (!(_DWORD)AppIntegerValue)
  {
    keyExistsAndHasValidFormat[0] = 0;
    v23 = CFPreferencesGetAppIntegerValue(CFSTR("IVFPartitionProbeMax"), CFSTR("com.apple.Spotlight"), keyExistsAndHasValidFormat);
    if (keyExistsAndHasValidFormat[0])
      v24 = v23;
    else
      v24 = 40;
    keyExistsAndHasValidFormat[0] = 0;
    v25 = CFPreferencesGetAppIntegerValue(CFSTR("IVFPartitionSizeFactor"), CFSTR("com.apple.Spotlight"), keyExistsAndHasValidFormat);
    if (keyExistsAndHasValidFormat[0])
      v26 = v25;
    else
      v26 = 45;
    keyExistsAndHasValidFormat[0] = 0;
    v27 = CFPreferencesGetAppIntegerValue(CFSTR("IVFPartitionProbeNumerator"), CFSTR("com.apple.Spotlight"), keyExistsAndHasValidFormat);
    v28 = keyExistsAndHasValidFormat[0];
    v29 = 8 * v27;
    v30 = v26 * v26;
    keyExistsAndHasValidFormat[0] = 0;
    v31 = CFPreferencesGetAppIntegerValue(CFSTR("IVFpartitionProbeDecayExponent"), CFSTR("com.apple.Spotlight"), keyExistsAndHasValidFormat);
    v32 = keyExistsAndHasValidFormat[0];
    if (v31 <= 0x12)
      v33 = 18;
    else
      v33 = v31;
    v34 = v12;
    v35 = v33 - 3;
    v36 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nVectors(v10);
    if (v32)
      v37 = v35;
    else
      v37 = 17;
    v12 = v34;
    v38 = v36 >> v37;
    if (v38 <= 8)
      v39 = 8;
    else
      v39 = v38;
    v40 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nPartitions(v10);
    if (v28)
      v41 = v29;
    else
      v41 = 800;
    v42 = v41 * v40 / (v30 * v39);
    if (v24 < v42)
      v42 = v24;
    if (v42 <= v21)
      AppIntegerValue = v21;
    else
      AppIntegerValue = v42;
  }
  v43 = *__error();
  v44 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
  {
    v45 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nVectors(v10);
    v46 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nPartitions(v10);
    *(_DWORD *)keyExistsAndHasValidFormat = 136316418;
    *(_QWORD *)&keyExistsAndHasValidFormat[4] = __str;
    *(_WORD *)&keyExistsAndHasValidFormat[12] = 1024;
    *(_DWORD *)&keyExistsAndHasValidFormat[14] = v12;
    *(_WORD *)&keyExistsAndHasValidFormat[18] = 1024;
    *(_DWORD *)&keyExistsAndHasValidFormat[20] = v45;
    *(_WORD *)&keyExistsAndHasValidFormat[24] = 1024;
    *(_DWORD *)&keyExistsAndHasValidFormat[26] = AppIntegerValue;
    *(_WORD *)&keyExistsAndHasValidFormat[30] = 1024;
    *(_DWORD *)&keyExistsAndHasValidFormat[32] = v46;
    *(_WORD *)&keyExistsAndHasValidFormat[36] = 2048;
    *(double *)&keyExistsAndHasValidFormat[38] = v7;
    _os_log_impl(&dword_1B8270000, v44, OS_LOG_TYPE_DEFAULT, "aNN search %s top %u of %u vectors in %u of %u partitions max_distance=%f", keyExistsAndHasValidFormat, 0x2Eu);
  }
  *__error() = v43;
  os_unfair_lock_lock((os_unfair_lock_t)(v10 + 136));
  os_unfair_lock_lock((os_unfair_lock_t)(v10 + 96));
  v48 = *(_QWORD *)(v10 + 64);
  v47 = *(std::__shared_weak_count **)(v10 + 72);
  if (v47)
  {
    p_shared_owners = (unint64_t *)&v47->__shared_owners_;
    do
      v50 = __ldxr(p_shared_owners);
    while (__stxr(v50 + 1, p_shared_owners));
  }
  v52 = *(_QWORD *)(v10 + 80);
  v51 = *(std::__shared_weak_count **)(v10 + 88);
  if (v51)
  {
    v53 = (unint64_t *)&v51->__shared_owners_;
    do
      v54 = __ldxr(v53);
    while (__stxr(v54 + 1, v53));
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(v10 + 96));
  memset(keyExistsAndHasValidFormat, 0, 24);
  (*(void (**)(_BYTE *__return_ptr, uint64_t, unsigned __int8 *, CFIndex))(*(_QWORD *)v48 + 72))(keyExistsAndHasValidFormat, v48, v9, AppIntegerValue);
  v55 = *(int **)&keyExistsAndHasValidFormat[8];
  v56 = *(int **)keyExistsAndHasValidFormat;
  __B = 0uLL;
  v254.i64[0] = 0;
  __C = &__B;
  v57 = *(_QWORD *)&keyExistsAndHasValidFormat[8] - *(_QWORD *)keyExistsAndHasValidFormat;
  if (*(_QWORD *)&keyExistsAndHasValidFormat[8] == *(_QWORD *)keyExistsAndHasValidFormat)
  {
    v240 = 0;
    v241 = 0;
    v239 = 0;
    goto LABEL_102;
  }
  do
  {
    v58 = *v56;
    v56 += 2;
    std::back_insert_iterator<std::vector<unsigned int>>::operator=[abi:nn180100]((uint64_t *)&__C, v58);
  }
  while (v56 != v55);
  v59 = (const void *)__B.i64[0];
  v240 = 0;
  v241 = 0;
  v239 = 0;
  v60 = __B.i64[1] - __B.i64[0];
  if (__B.i64[1] == __B.i64[0])
    goto LABEL_102;
  if (v60 < 0)
LABEL_126:
    abort();
  v61 = (char *)operator new(__B.i64[1] - __B.i64[0]);
  v62 = &v61[4 * (v60 >> 2)];
  v239 = v61;
  v241 = v62;
  memcpy(v61, v59, v60);
  v240 = v62;
LABEL_102:
  v234[0] = MEMORY[0x1E0C809B0];
  v234[1] = 1174405120;
  v234[2] = ___ZNK22IVFVectorIndexTemplateIDF16_Li512EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE3aNNERK10CIVector_sIDF16_Li512EEfbP20MaxSizePriorityQueueINS0_18candidate_result_sIS3_EENSt3__16vectorISB_NSC_9allocatorISB_EEEENSC_4lessISB_EEEj_block_invoke;
  v234[3] = &unk_1E6E31B40;
  v234[6] = v10;
  v234[7] = v9;
  v234[4] = &v249;
  std::unordered_set<unsigned int>::unordered_set((uint64_t)&v235, (uint64_t)v242);
  v238 = v7;
  v234[5] = &v245;
  v237 = v233;
  (*(void (**)(uint64_t, void **, _QWORD *))(*(_QWORD *)v52 + 72))(v52, &v239, v234);
  if (v239)
  {
    v240 = v239;
    operator delete(v239);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(v10 + 136));
  v221 = v236;
  v12 = v232;
  if (v236)
  {
    do
    {
      v222 = (_QWORD *)*v221;
      operator delete(v221);
      v221 = v222;
    }
    while (v222);
  }
  v223 = v235;
  v235 = 0;
  if (v223)
    operator delete(v223);
  if (__B.i64[0])
  {
    __B.i64[1] = __B.i64[0];
    operator delete((void *)__B.i64[0]);
  }
  if (*(_QWORD *)keyExistsAndHasValidFormat)
  {
    *(_QWORD *)&keyExistsAndHasValidFormat[8] = *(_QWORD *)keyExistsAndHasValidFormat;
    operator delete(*(void **)keyExistsAndHasValidFormat);
  }
  if (v51)
  {
    v224 = (unint64_t *)&v51->__shared_owners_;
    do
      v225 = __ldaxr(v224);
    while (__stlxr(v225 - 1, v224));
    if (!v225)
    {
      ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
      std::__shared_weak_count::__release_weak(v51);
    }
  }
  lock = (os_unfair_lock_t)(v57 >> 3);
  if (v47)
  {
    v226 = (unint64_t *)&v47->__shared_owners_;
    do
      v227 = __ldaxr(v226);
    while (__stlxr(v227 - 1, v226));
    if (!v227)
    {
      ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
      std::__shared_weak_count::__release_weak(v47);
    }
  }
LABEL_94:
  v210 = *__error();
  v211 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v211, OS_LOG_TYPE_DEFAULT))
  {
    v212 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nVectors(v10);
    v213 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nPartitions(v10);
    v214 = *((_DWORD *)v246 + 6);
    v215 = *((_DWORD *)v250 + 6);
    v216 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v233[2] - v233[1]) >> 3);
    v217 = CFAbsoluteTimeGetCurrent();
    *(_DWORD *)keyExistsAndHasValidFormat = 136317442;
    *(_QWORD *)&keyExistsAndHasValidFormat[4] = __str;
    *(_WORD *)&keyExistsAndHasValidFormat[12] = 1024;
    *(_DWORD *)&keyExistsAndHasValidFormat[14] = v12;
    *(_WORD *)&keyExistsAndHasValidFormat[18] = 1024;
    *(_DWORD *)&keyExistsAndHasValidFormat[20] = v212;
    *(_WORD *)&keyExistsAndHasValidFormat[24] = 2048;
    *(double *)&keyExistsAndHasValidFormat[26] = v7;
    *(_WORD *)&keyExistsAndHasValidFormat[34] = 1024;
    *(_DWORD *)&keyExistsAndHasValidFormat[36] = (_DWORD)lock;
    *(_WORD *)&keyExistsAndHasValidFormat[40] = 1024;
    *(_DWORD *)&keyExistsAndHasValidFormat[42] = v213;
    *(_WORD *)&keyExistsAndHasValidFormat[46] = 1024;
    *(_DWORD *)v385 = v214;
    *(_WORD *)&v385[4] = 1024;
    *(_DWORD *)&v385[6] = v215;
    *(_WORD *)&v385[10] = 2048;
    *(_QWORD *)&v385[12] = v216;
    *(_WORD *)&v385[20] = 2048;
    *(double *)&v385[22] = v217 - Current;
    _os_log_impl(&dword_1B8270000, v211, OS_LOG_TYPE_DEFAULT, "search %s top %u of %u vectors max_distance=%f in %u of %u partitions skip %u of %u populate %zu results in duration: %f", keyExistsAndHasValidFormat, 0x4Eu);
  }
  *__error() = v210;
  v218 = __p[0];
  if (__p[0])
  {
    do
    {
      v219 = (_QWORD *)*v218;
      operator delete(v218);
      v218 = v219;
    }
    while (v219);
  }
  v220 = v242[0];
  v242[0] = 0;
  if (v220)
    operator delete(v220);
  _Block_object_dispose(&v245, 8);
  _Block_object_dispose(&v249, 8);
}

void ___ZNK22IVFVectorIndexTemplateIDF16_Li512EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE3aNNERK10CIVector_sIDF16_Li512EEfbP20MaxSizePriorityQueueINS0_18candidate_result_sIS3_EENSt3__16vectorISB_NSC_9allocatorISB_EEEENSC_4lessISB_EEEj_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  unsigned int *v3;
  unint64_t Ptr;
  float16x8_t *v5;
  float16x8_t v6;
  float32x4_t v7;
  float16x8_t v8;
  float16x8_t v9;
  float16x8_t v10;
  float16x8_t v11;
  float16x8_t v12;
  float16x8_t v13;
  float16x8_t v14;
  float16x8_t v15;
  float16x8_t v16;
  float16x8_t v17;
  float16x8_t v18;
  float16x8_t v19;
  float16x8_t v20;
  float16x8_t v21;
  float16x8_t v22;
  float16x8_t v23;
  float16x8_t v24;
  float16x8_t v25;
  float16x8_t v26;
  float16x8_t v27;
  float16x8_t v28;
  float16x8_t v29;
  float16x8_t v30;
  float16x8_t v31;
  float16x8_t v32;
  float16x8_t v33;
  float16x8_t v34;
  float16x8_t v35;
  float16x8_t v36;
  float16x8_t v37;
  float16x8_t v38;
  float16x8_t v39;
  float16x8_t v40;
  float16x8_t v41;
  float16x8_t v42;
  float16x8_t v43;
  float16x8_t v44;
  float16x8_t v45;
  float16x8_t v46;
  float16x8_t v47;
  float16x8_t v48;
  float16x8_t v49;
  float16x8_t v50;
  float16x8_t v51;
  float16x8_t v52;
  float16x8_t v53;
  float16x8_t v54;
  float16x8_t v55;
  float16x8_t v56;
  float16x8_t v57;
  float16x8_t v58;
  float16x8_t v59;
  float16x8_t v60;
  float16x8_t v61;
  float16x8_t v62;
  float16x8_t v63;
  float16x8_t v64;
  float16x8_t v65;
  float16x8_t v66;
  float16x8_t v67;
  float16x8_t v68;
  float16x8_t v69;
  float16x8_t v70;
  float32x4_t v71;
  float16x8_t v72;
  float16x8_t v73;
  float16x8_t v74;
  float16x8_t v75;
  float16x8_t v76;
  float16x8_t v77;
  float16x8_t v78;
  float16x8_t v79;
  float16x8_t v80;
  float16x8_t v81;
  float16x8_t v82;
  float16x8_t v83;
  float16x8_t v84;
  float16x8_t v85;
  float16x8_t v86;
  float16x8_t v87;
  float16x8_t v88;
  float16x8_t v89;
  float16x8_t v90;
  float16x8_t v91;
  float16x8_t v92;
  float16x8_t v93;
  float16x8_t v94;
  float16x8_t v95;
  float16x8_t v96;
  float16x8_t v97;
  float16x8_t v98;
  float16x8_t v99;
  float16x8_t v100;
  float16x8_t v101;
  float16x8_t v102;
  float16x8_t v103;
  float16x8_t v104;
  float16x8_t v105;
  float16x8_t v106;
  float16x8_t v107;
  float16x8_t v108;
  float16x8_t v109;
  float16x8_t v110;
  float16x8_t v111;
  float16x8_t v112;
  float16x8_t v113;
  float16x8_t v114;
  float16x8_t v115;
  float16x8_t v116;
  float16x8_t v117;
  float16x8_t v118;
  float16x8_t v119;
  float16x8_t v120;
  float16x8_t v121;
  float16x8_t v122;
  float16x8_t v123;
  float16x8_t v124;
  float16x8_t v125;
  float16x8_t v126;
  float16x8_t v127;
  float16x8_t v128;
  float16x8_t v129;
  float16x8_t v130;
  float16x8_t v131;
  float16x8_t v132;
  float16x8_t v133;
  unint64_t v134;
  int8x8_t v135;
  uint8x8_t v136;
  unint64_t v137;
  uint64_t *v138;
  uint64_t v139;
  unint64_t v140;
  uint64_t v141;
  float v142;
  float v143;
  int v144;
  NSObject *v145;
  double v146;
  int v147;
  NSObject *v148;
  _OWORD __B[128];
  float __C;
  _BYTE __A[32];
  float32x4_t v152;
  float32x4_t v153;
  float32x4_t v154;
  float32x4_t v155;
  float32x4_t v156;
  float32x4_t v157;
  float32x4_t v158;
  float32x4_t v159;
  float32x4_t v160;
  float32x4_t v161;
  float32x4_t v162;
  float32x4_t v163;
  float32x4_t v164;
  float32x4_t v165;
  float32x4_t v166;
  float32x4_t v167;
  float32x4_t v168;
  float32x4_t v169;
  float32x4_t v170;
  float32x4_t v171;
  float32x4_t v172;
  float32x4_t v173;
  float32x4_t v174;
  float32x4_t v175;
  float32x4_t v176;
  float32x4_t v177;
  float32x4_t v178;
  float32x4_t v179;
  float32x4_t v180;
  float32x4_t v181;
  float32x4_t v182;
  float32x4_t v183;
  float32x4_t v184;
  float32x4_t v185;
  float32x4_t v186;
  float32x4_t v187;
  float32x4_t v188;
  float32x4_t v189;
  float32x4_t v190;
  float32x4_t v191;
  float32x4_t v192;
  float32x4_t v193;
  float32x4_t v194;
  float32x4_t v195;
  float32x4_t v196;
  float32x4_t v197;
  float32x4_t v198;
  float32x4_t v199;
  float32x4_t v200;
  float32x4_t v201;
  float32x4_t v202;
  float32x4_t v203;
  float32x4_t v204;
  float32x4_t v205;
  float32x4_t v206;
  float32x4_t v207;
  float32x4_t v208;
  float32x4_t v209;
  float32x4_t v210;
  float32x4_t v211;
  float32x4_t v212;
  float32x4_t v213;
  float32x4_t v214;
  float32x4_t v215;
  float32x4_t v216;
  float32x4_t v217;
  float32x4_t v218;
  float32x4_t v219;
  float32x4_t v220;
  float32x4_t v221;
  float32x4_t v222;
  float32x4_t v223;
  float32x4_t v224;
  float32x4_t v225;
  float32x4_t v226;
  float32x4_t v227;
  float32x4_t v228;
  float32x4_t v229;
  float32x4_t v230;
  float32x4_t v231;
  float32x4_t v232;
  float32x4_t v233;
  float32x4_t v234;
  float32x4_t v235;
  float32x4_t v236;
  float32x4_t v237;
  float32x4_t v238;
  float32x4_t v239;
  float32x4_t v240;
  float32x4_t v241;
  float32x4_t v242;
  float32x4_t v243;
  float32x4_t v244;
  float32x4_t v245;
  float32x4_t v246;
  float32x4_t v247;
  float32x4_t v248;
  float32x4_t v249;
  float32x4_t v250;
  float32x4_t v251;
  float32x4_t v252;
  float32x4_t v253;
  float32x4_t v254;
  float32x4_t v255;
  float32x4_t v256;
  float32x4_t v257;
  float32x4_t v258;
  float32x4_t v259;
  float32x4_t v260;
  float32x4_t v261;
  float32x4_t v262;
  float32x4_t v263;
  float32x4_t v264;
  float32x4_t v265;
  float32x4_t v266;
  float32x4_t v267;
  float32x4_t v268;
  float32x4_t v269;
  float32x4_t v270;
  float32x4_t v271;
  float32x4_t v272;
  float32x4_t v273;
  float32x4_t v274;
  float32x4_t v275;
  float32x4_t v276;
  float32x4_t v277;
  uint64_t v278;

  v1 = MEMORY[0x1E0C80A78](a1);
  v278 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(v1 + 48);
  ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v1 + 32) + 8) + 24);
  Ptr = vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(*(_QWORD *)(v2 + 32) + 16), *v3, 1044);
  v5 = *(float16x8_t **)(v1 + 56);
  bzero(__A, 0x800uLL);
  v6 = v5[1];
  v7 = vcvt_hight_f32_f16(*v5);
  *(float32x4_t *)__A = vcvtq_f32_f16(*(float16x4_t *)v5->i8);
  *(float32x4_t *)&__A[16] = v7;
  v152 = vcvtq_f32_f16(*(float16x4_t *)v6.i8);
  v153 = vcvt_hight_f32_f16(v6);
  v8 = v5[2];
  v9 = v5[3];
  v154 = vcvtq_f32_f16(*(float16x4_t *)v8.i8);
  v155 = vcvt_hight_f32_f16(v8);
  v156 = vcvtq_f32_f16(*(float16x4_t *)v9.i8);
  v157 = vcvt_hight_f32_f16(v9);
  v10 = v5[4];
  v11 = v5[5];
  v158 = vcvtq_f32_f16(*(float16x4_t *)v10.i8);
  v159 = vcvt_hight_f32_f16(v10);
  v160 = vcvtq_f32_f16(*(float16x4_t *)v11.i8);
  v161 = vcvt_hight_f32_f16(v11);
  v12 = v5[6];
  v13 = v5[7];
  v162 = vcvtq_f32_f16(*(float16x4_t *)v12.i8);
  v163 = vcvt_hight_f32_f16(v12);
  v164 = vcvtq_f32_f16(*(float16x4_t *)v13.i8);
  v165 = vcvt_hight_f32_f16(v13);
  v14 = v5[8];
  v15 = v5[9];
  v166 = vcvtq_f32_f16(*(float16x4_t *)v14.i8);
  v167 = vcvt_hight_f32_f16(v14);
  v168 = vcvtq_f32_f16(*(float16x4_t *)v15.i8);
  v169 = vcvt_hight_f32_f16(v15);
  v16 = v5[10];
  v17 = v5[11];
  v170 = vcvtq_f32_f16(*(float16x4_t *)v16.i8);
  v171 = vcvt_hight_f32_f16(v16);
  v172 = vcvtq_f32_f16(*(float16x4_t *)v17.i8);
  v173 = vcvt_hight_f32_f16(v17);
  v18 = v5[12];
  v19 = v5[13];
  v174 = vcvtq_f32_f16(*(float16x4_t *)v18.i8);
  v175 = vcvt_hight_f32_f16(v18);
  v176 = vcvtq_f32_f16(*(float16x4_t *)v19.i8);
  v177 = vcvt_hight_f32_f16(v19);
  v20 = v5[14];
  v21 = v5[15];
  v178 = vcvtq_f32_f16(*(float16x4_t *)v20.i8);
  v179 = vcvt_hight_f32_f16(v20);
  v180 = vcvtq_f32_f16(*(float16x4_t *)v21.i8);
  v181 = vcvt_hight_f32_f16(v21);
  v22 = v5[16];
  v23 = v5[17];
  v182 = vcvtq_f32_f16(*(float16x4_t *)v22.i8);
  v183 = vcvt_hight_f32_f16(v22);
  v184 = vcvtq_f32_f16(*(float16x4_t *)v23.i8);
  v185 = vcvt_hight_f32_f16(v23);
  v24 = v5[18];
  v25 = v5[19];
  v186 = vcvtq_f32_f16(*(float16x4_t *)v24.i8);
  v187 = vcvt_hight_f32_f16(v24);
  v188 = vcvtq_f32_f16(*(float16x4_t *)v25.i8);
  v189 = vcvt_hight_f32_f16(v25);
  v26 = v5[20];
  v27 = v5[21];
  v190 = vcvtq_f32_f16(*(float16x4_t *)v26.i8);
  v191 = vcvt_hight_f32_f16(v26);
  v192 = vcvtq_f32_f16(*(float16x4_t *)v27.i8);
  v193 = vcvt_hight_f32_f16(v27);
  v28 = v5[22];
  v29 = v5[23];
  v194 = vcvtq_f32_f16(*(float16x4_t *)v28.i8);
  v195 = vcvt_hight_f32_f16(v28);
  v196 = vcvtq_f32_f16(*(float16x4_t *)v29.i8);
  v197 = vcvt_hight_f32_f16(v29);
  v30 = v5[24];
  v31 = v5[25];
  v198 = vcvtq_f32_f16(*(float16x4_t *)v30.i8);
  v199 = vcvt_hight_f32_f16(v30);
  v200 = vcvtq_f32_f16(*(float16x4_t *)v31.i8);
  v201 = vcvt_hight_f32_f16(v31);
  v32 = v5[26];
  v33 = v5[27];
  v202 = vcvtq_f32_f16(*(float16x4_t *)v32.i8);
  v203 = vcvt_hight_f32_f16(v32);
  v204 = vcvtq_f32_f16(*(float16x4_t *)v33.i8);
  v205 = vcvt_hight_f32_f16(v33);
  v34 = v5[28];
  v35 = v5[29];
  v206 = vcvtq_f32_f16(*(float16x4_t *)v34.i8);
  v207 = vcvt_hight_f32_f16(v34);
  v208 = vcvtq_f32_f16(*(float16x4_t *)v35.i8);
  v209 = vcvt_hight_f32_f16(v35);
  v36 = v5[30];
  v37 = v5[31];
  v210 = vcvtq_f32_f16(*(float16x4_t *)v36.i8);
  v211 = vcvt_hight_f32_f16(v36);
  v212 = vcvtq_f32_f16(*(float16x4_t *)v37.i8);
  v213 = vcvt_hight_f32_f16(v37);
  v38 = v5[32];
  v39 = v5[33];
  v215 = vcvt_hight_f32_f16(v38);
  v214 = vcvtq_f32_f16(*(float16x4_t *)v38.i8);
  v217 = vcvt_hight_f32_f16(v39);
  v216 = vcvtq_f32_f16(*(float16x4_t *)v39.i8);
  v40 = v5[34];
  v41 = v5[35];
  v219 = vcvt_hight_f32_f16(v40);
  v218 = vcvtq_f32_f16(*(float16x4_t *)v40.i8);
  v221 = vcvt_hight_f32_f16(v41);
  v220 = vcvtq_f32_f16(*(float16x4_t *)v41.i8);
  v42 = v5[36];
  v43 = v5[37];
  v223 = vcvt_hight_f32_f16(v42);
  v222 = vcvtq_f32_f16(*(float16x4_t *)v42.i8);
  v225 = vcvt_hight_f32_f16(v43);
  v224 = vcvtq_f32_f16(*(float16x4_t *)v43.i8);
  v44 = v5[38];
  v45 = v5[39];
  v227 = vcvt_hight_f32_f16(v44);
  v226 = vcvtq_f32_f16(*(float16x4_t *)v44.i8);
  v229 = vcvt_hight_f32_f16(v45);
  v228 = vcvtq_f32_f16(*(float16x4_t *)v45.i8);
  v46 = v5[40];
  v47 = v5[41];
  v231 = vcvt_hight_f32_f16(v46);
  v230 = vcvtq_f32_f16(*(float16x4_t *)v46.i8);
  v233 = vcvt_hight_f32_f16(v47);
  v232 = vcvtq_f32_f16(*(float16x4_t *)v47.i8);
  v48 = v5[42];
  v49 = v5[43];
  v235 = vcvt_hight_f32_f16(v48);
  v234 = vcvtq_f32_f16(*(float16x4_t *)v48.i8);
  v237 = vcvt_hight_f32_f16(v49);
  v236 = vcvtq_f32_f16(*(float16x4_t *)v49.i8);
  v50 = v5[44];
  v51 = v5[45];
  v239 = vcvt_hight_f32_f16(v50);
  v238 = vcvtq_f32_f16(*(float16x4_t *)v50.i8);
  v241 = vcvt_hight_f32_f16(v51);
  v240 = vcvtq_f32_f16(*(float16x4_t *)v51.i8);
  v52 = v5[46];
  v53 = v5[47];
  v243 = vcvt_hight_f32_f16(v52);
  v242 = vcvtq_f32_f16(*(float16x4_t *)v52.i8);
  v245 = vcvt_hight_f32_f16(v53);
  v244 = vcvtq_f32_f16(*(float16x4_t *)v53.i8);
  v54 = v5[48];
  v55 = v5[49];
  v247 = vcvt_hight_f32_f16(v54);
  v246 = vcvtq_f32_f16(*(float16x4_t *)v54.i8);
  v249 = vcvt_hight_f32_f16(v55);
  v248 = vcvtq_f32_f16(*(float16x4_t *)v55.i8);
  v56 = v5[50];
  v57 = v5[51];
  v251 = vcvt_hight_f32_f16(v56);
  v250 = vcvtq_f32_f16(*(float16x4_t *)v56.i8);
  v253 = vcvt_hight_f32_f16(v57);
  v252 = vcvtq_f32_f16(*(float16x4_t *)v57.i8);
  v58 = v5[52];
  v59 = v5[53];
  v255 = vcvt_hight_f32_f16(v58);
  v254 = vcvtq_f32_f16(*(float16x4_t *)v58.i8);
  v257 = vcvt_hight_f32_f16(v59);
  v256 = vcvtq_f32_f16(*(float16x4_t *)v59.i8);
  v60 = v5[54];
  v61 = v5[55];
  v259 = vcvt_hight_f32_f16(v60);
  v258 = vcvtq_f32_f16(*(float16x4_t *)v60.i8);
  v261 = vcvt_hight_f32_f16(v61);
  v260 = vcvtq_f32_f16(*(float16x4_t *)v61.i8);
  v62 = v5[56];
  v63 = v5[57];
  v263 = vcvt_hight_f32_f16(v62);
  v262 = vcvtq_f32_f16(*(float16x4_t *)v62.i8);
  v265 = vcvt_hight_f32_f16(v63);
  v264 = vcvtq_f32_f16(*(float16x4_t *)v63.i8);
  v64 = v5[58];
  v65 = v5[59];
  v267 = vcvt_hight_f32_f16(v64);
  v266 = vcvtq_f32_f16(*(float16x4_t *)v64.i8);
  v269 = vcvt_hight_f32_f16(v65);
  v268 = vcvtq_f32_f16(*(float16x4_t *)v65.i8);
  v66 = v5[60];
  v67 = v5[61];
  v271 = vcvt_hight_f32_f16(v66);
  v270 = vcvtq_f32_f16(*(float16x4_t *)v66.i8);
  v273 = vcvt_hight_f32_f16(v67);
  v272 = vcvtq_f32_f16(*(float16x4_t *)v67.i8);
  v68 = v5[62];
  v69 = v5[63];
  v275 = vcvt_hight_f32_f16(v68);
  v274 = vcvtq_f32_f16(*(float16x4_t *)v68.i8);
  v277 = vcvt_hight_f32_f16(v69);
  v276 = vcvtq_f32_f16(*(float16x4_t *)v69.i8);
  bzero(__B, 0x800uLL);
  v70 = *(float16x8_t *)(Ptr + 16);
  v71 = vcvtq_f32_f16(*(float16x4_t *)Ptr);
  __B[1] = vcvt_hight_f32_f16(*(float16x8_t *)Ptr);
  __B[0] = v71;
  __B[3] = vcvt_hight_f32_f16(v70);
  __B[2] = vcvtq_f32_f16(*(float16x4_t *)v70.i8);
  v72 = *(float16x8_t *)(Ptr + 32);
  v73 = *(float16x8_t *)(Ptr + 48);
  __B[5] = vcvt_hight_f32_f16(v72);
  __B[4] = vcvtq_f32_f16(*(float16x4_t *)v72.i8);
  __B[7] = vcvt_hight_f32_f16(v73);
  __B[6] = vcvtq_f32_f16(*(float16x4_t *)v73.i8);
  v74 = *(float16x8_t *)(Ptr + 64);
  v75 = *(float16x8_t *)(Ptr + 80);
  __B[9] = vcvt_hight_f32_f16(v74);
  __B[8] = vcvtq_f32_f16(*(float16x4_t *)v74.i8);
  __B[11] = vcvt_hight_f32_f16(v75);
  __B[10] = vcvtq_f32_f16(*(float16x4_t *)v75.i8);
  v76 = *(float16x8_t *)(Ptr + 96);
  v77 = *(float16x8_t *)(Ptr + 112);
  __B[13] = vcvt_hight_f32_f16(v76);
  __B[12] = vcvtq_f32_f16(*(float16x4_t *)v76.i8);
  __B[15] = vcvt_hight_f32_f16(v77);
  __B[14] = vcvtq_f32_f16(*(float16x4_t *)v77.i8);
  v78 = *(float16x8_t *)(Ptr + 128);
  v79 = *(float16x8_t *)(Ptr + 144);
  __B[17] = vcvt_hight_f32_f16(v78);
  __B[16] = vcvtq_f32_f16(*(float16x4_t *)v78.i8);
  __B[19] = vcvt_hight_f32_f16(v79);
  __B[18] = vcvtq_f32_f16(*(float16x4_t *)v79.i8);
  v80 = *(float16x8_t *)(Ptr + 160);
  v81 = *(float16x8_t *)(Ptr + 176);
  __B[21] = vcvt_hight_f32_f16(v80);
  __B[20] = vcvtq_f32_f16(*(float16x4_t *)v80.i8);
  __B[23] = vcvt_hight_f32_f16(v81);
  __B[22] = vcvtq_f32_f16(*(float16x4_t *)v81.i8);
  v82 = *(float16x8_t *)(Ptr + 192);
  v83 = *(float16x8_t *)(Ptr + 208);
  __B[25] = vcvt_hight_f32_f16(v82);
  __B[24] = vcvtq_f32_f16(*(float16x4_t *)v82.i8);
  __B[27] = vcvt_hight_f32_f16(v83);
  __B[26] = vcvtq_f32_f16(*(float16x4_t *)v83.i8);
  v84 = *(float16x8_t *)(Ptr + 224);
  v85 = *(float16x8_t *)(Ptr + 240);
  __B[29] = vcvt_hight_f32_f16(v84);
  __B[28] = vcvtq_f32_f16(*(float16x4_t *)v84.i8);
  __B[31] = vcvt_hight_f32_f16(v85);
  __B[30] = vcvtq_f32_f16(*(float16x4_t *)v85.i8);
  v86 = *(float16x8_t *)(Ptr + 256);
  v87 = *(float16x8_t *)(Ptr + 272);
  __B[33] = vcvt_hight_f32_f16(v86);
  __B[32] = vcvtq_f32_f16(*(float16x4_t *)v86.i8);
  __B[35] = vcvt_hight_f32_f16(v87);
  __B[34] = vcvtq_f32_f16(*(float16x4_t *)v87.i8);
  v88 = *(float16x8_t *)(Ptr + 288);
  v89 = *(float16x8_t *)(Ptr + 304);
  __B[37] = vcvt_hight_f32_f16(v88);
  __B[36] = vcvtq_f32_f16(*(float16x4_t *)v88.i8);
  __B[39] = vcvt_hight_f32_f16(v89);
  __B[38] = vcvtq_f32_f16(*(float16x4_t *)v89.i8);
  v90 = *(float16x8_t *)(Ptr + 320);
  v91 = *(float16x8_t *)(Ptr + 336);
  __B[41] = vcvt_hight_f32_f16(v90);
  __B[40] = vcvtq_f32_f16(*(float16x4_t *)v90.i8);
  __B[43] = vcvt_hight_f32_f16(v91);
  __B[42] = vcvtq_f32_f16(*(float16x4_t *)v91.i8);
  v92 = *(float16x8_t *)(Ptr + 352);
  v93 = *(float16x8_t *)(Ptr + 368);
  __B[45] = vcvt_hight_f32_f16(v92);
  __B[44] = vcvtq_f32_f16(*(float16x4_t *)v92.i8);
  __B[47] = vcvt_hight_f32_f16(v93);
  __B[46] = vcvtq_f32_f16(*(float16x4_t *)v93.i8);
  v94 = *(float16x8_t *)(Ptr + 384);
  v95 = *(float16x8_t *)(Ptr + 400);
  __B[49] = vcvt_hight_f32_f16(v94);
  __B[48] = vcvtq_f32_f16(*(float16x4_t *)v94.i8);
  __B[51] = vcvt_hight_f32_f16(v95);
  __B[50] = vcvtq_f32_f16(*(float16x4_t *)v95.i8);
  v96 = *(float16x8_t *)(Ptr + 416);
  v97 = *(float16x8_t *)(Ptr + 432);
  __B[53] = vcvt_hight_f32_f16(v96);
  __B[52] = vcvtq_f32_f16(*(float16x4_t *)v96.i8);
  __B[55] = vcvt_hight_f32_f16(v97);
  __B[54] = vcvtq_f32_f16(*(float16x4_t *)v97.i8);
  v98 = *(float16x8_t *)(Ptr + 448);
  v99 = *(float16x8_t *)(Ptr + 464);
  __B[57] = vcvt_hight_f32_f16(v98);
  __B[56] = vcvtq_f32_f16(*(float16x4_t *)v98.i8);
  __B[59] = vcvt_hight_f32_f16(v99);
  __B[58] = vcvtq_f32_f16(*(float16x4_t *)v99.i8);
  v100 = *(float16x8_t *)(Ptr + 480);
  v101 = *(float16x8_t *)(Ptr + 496);
  __B[61] = vcvt_hight_f32_f16(v100);
  __B[60] = vcvtq_f32_f16(*(float16x4_t *)v100.i8);
  __B[63] = vcvt_hight_f32_f16(v101);
  __B[62] = vcvtq_f32_f16(*(float16x4_t *)v101.i8);
  v102 = *(float16x8_t *)(Ptr + 512);
  v103 = *(float16x8_t *)(Ptr + 528);
  __B[65] = vcvt_hight_f32_f16(v102);
  __B[64] = vcvtq_f32_f16(*(float16x4_t *)v102.i8);
  __B[67] = vcvt_hight_f32_f16(v103);
  __B[66] = vcvtq_f32_f16(*(float16x4_t *)v103.i8);
  v104 = *(float16x8_t *)(Ptr + 544);
  v105 = *(float16x8_t *)(Ptr + 560);
  __B[69] = vcvt_hight_f32_f16(v104);
  __B[68] = vcvtq_f32_f16(*(float16x4_t *)v104.i8);
  __B[71] = vcvt_hight_f32_f16(v105);
  __B[70] = vcvtq_f32_f16(*(float16x4_t *)v105.i8);
  v106 = *(float16x8_t *)(Ptr + 576);
  v107 = *(float16x8_t *)(Ptr + 592);
  __B[73] = vcvt_hight_f32_f16(v106);
  __B[72] = vcvtq_f32_f16(*(float16x4_t *)v106.i8);
  __B[75] = vcvt_hight_f32_f16(v107);
  __B[74] = vcvtq_f32_f16(*(float16x4_t *)v107.i8);
  v108 = *(float16x8_t *)(Ptr + 608);
  v109 = *(float16x8_t *)(Ptr + 624);
  __B[77] = vcvt_hight_f32_f16(v108);
  __B[76] = vcvtq_f32_f16(*(float16x4_t *)v108.i8);
  __B[79] = vcvt_hight_f32_f16(v109);
  __B[78] = vcvtq_f32_f16(*(float16x4_t *)v109.i8);
  v110 = *(float16x8_t *)(Ptr + 640);
  v111 = *(float16x8_t *)(Ptr + 656);
  __B[81] = vcvt_hight_f32_f16(v110);
  __B[80] = vcvtq_f32_f16(*(float16x4_t *)v110.i8);
  __B[83] = vcvt_hight_f32_f16(v111);
  __B[82] = vcvtq_f32_f16(*(float16x4_t *)v111.i8);
  v112 = *(float16x8_t *)(Ptr + 672);
  v113 = *(float16x8_t *)(Ptr + 688);
  __B[85] = vcvt_hight_f32_f16(v112);
  __B[84] = vcvtq_f32_f16(*(float16x4_t *)v112.i8);
  __B[87] = vcvt_hight_f32_f16(v113);
  __B[86] = vcvtq_f32_f16(*(float16x4_t *)v113.i8);
  v114 = *(float16x8_t *)(Ptr + 704);
  v115 = *(float16x8_t *)(Ptr + 720);
  __B[89] = vcvt_hight_f32_f16(v114);
  __B[88] = vcvtq_f32_f16(*(float16x4_t *)v114.i8);
  __B[91] = vcvt_hight_f32_f16(v115);
  __B[90] = vcvtq_f32_f16(*(float16x4_t *)v115.i8);
  v116 = *(float16x8_t *)(Ptr + 736);
  v117 = *(float16x8_t *)(Ptr + 752);
  __B[93] = vcvt_hight_f32_f16(v116);
  __B[92] = vcvtq_f32_f16(*(float16x4_t *)v116.i8);
  __B[95] = vcvt_hight_f32_f16(v117);
  __B[94] = vcvtq_f32_f16(*(float16x4_t *)v117.i8);
  v118 = *(float16x8_t *)(Ptr + 768);
  v119 = *(float16x8_t *)(Ptr + 784);
  __B[97] = vcvt_hight_f32_f16(v118);
  __B[96] = vcvtq_f32_f16(*(float16x4_t *)v118.i8);
  __B[99] = vcvt_hight_f32_f16(v119);
  __B[98] = vcvtq_f32_f16(*(float16x4_t *)v119.i8);
  v120 = *(float16x8_t *)(Ptr + 800);
  v121 = *(float16x8_t *)(Ptr + 816);
  __B[101] = vcvt_hight_f32_f16(v120);
  __B[100] = vcvtq_f32_f16(*(float16x4_t *)v120.i8);
  __B[103] = vcvt_hight_f32_f16(v121);
  __B[102] = vcvtq_f32_f16(*(float16x4_t *)v121.i8);
  v122 = *(float16x8_t *)(Ptr + 832);
  v123 = *(float16x8_t *)(Ptr + 848);
  __B[105] = vcvt_hight_f32_f16(v122);
  __B[104] = vcvtq_f32_f16(*(float16x4_t *)v122.i8);
  __B[107] = vcvt_hight_f32_f16(v123);
  __B[106] = vcvtq_f32_f16(*(float16x4_t *)v123.i8);
  v124 = *(float16x8_t *)(Ptr + 864);
  v125 = *(float16x8_t *)(Ptr + 880);
  __B[109] = vcvt_hight_f32_f16(v124);
  __B[108] = vcvtq_f32_f16(*(float16x4_t *)v124.i8);
  __B[111] = vcvt_hight_f32_f16(v125);
  __B[110] = vcvtq_f32_f16(*(float16x4_t *)v125.i8);
  v126 = *(float16x8_t *)(Ptr + 896);
  v127 = *(float16x8_t *)(Ptr + 912);
  __B[113] = vcvt_hight_f32_f16(v126);
  __B[112] = vcvtq_f32_f16(*(float16x4_t *)v126.i8);
  __B[115] = vcvt_hight_f32_f16(v127);
  __B[114] = vcvtq_f32_f16(*(float16x4_t *)v127.i8);
  v128 = *(float16x8_t *)(Ptr + 928);
  v129 = *(float16x8_t *)(Ptr + 944);
  __B[117] = vcvt_hight_f32_f16(v128);
  __B[116] = vcvtq_f32_f16(*(float16x4_t *)v128.i8);
  __B[119] = vcvt_hight_f32_f16(v129);
  __B[118] = vcvtq_f32_f16(*(float16x4_t *)v129.i8);
  v130 = *(float16x8_t *)(Ptr + 960);
  v131 = *(float16x8_t *)(Ptr + 976);
  __B[121] = vcvt_hight_f32_f16(v130);
  __B[120] = vcvtq_f32_f16(*(float16x4_t *)v130.i8);
  __B[123] = vcvt_hight_f32_f16(v131);
  __B[122] = vcvtq_f32_f16(*(float16x4_t *)v131.i8);
  v132 = *(float16x8_t *)(Ptr + 992);
  v133 = *(float16x8_t *)(Ptr + 1008);
  __B[125] = vcvt_hight_f32_f16(v132);
  __B[124] = vcvtq_f32_f16(*(float16x4_t *)v132.i8);
  __B[127] = vcvt_hight_f32_f16(v133);
  __B[126] = vcvtq_f32_f16(*(float16x4_t *)v133.i8);
  __C = 3.4028e38;
  vDSP_distancesq((const float *)__A, 1, (const float *)__B, 1, &__C, 0x200uLL);
  v134 = *(unsigned int *)(Ptr + 1040);
  v135 = *(int8x8_t *)(v1 + 72);
  if (v135)
  {
    v136 = (uint8x8_t)vcnt_s8(v135);
    v136.i16[0] = vaddlv_u8(v136);
    if (v136.u32[0] > 1uLL)
    {
      v137 = *(unsigned int *)(Ptr + 1040);
      if (*(_QWORD *)&v135 <= v134)
        v137 = v134 % *(_QWORD *)&v135;
    }
    else
    {
      v137 = (v135.i32[0] - 1) & v134;
    }
    v138 = *(uint64_t **)(*(_QWORD *)(v1 + 64) + 8 * v137);
    if (v138)
    {
      v138 = (uint64_t *)*v138;
      if (v138)
      {
        if (v136.u32[0] < 2uLL)
        {
          v139 = *(_QWORD *)&v135 - 1;
          while (1)
          {
            v141 = v138[1];
            if (v141 == v134)
            {
              if (*((_DWORD *)v138 + 4) == (_DWORD)v134)
                goto LABEL_22;
            }
            else if ((v141 & v139) != v137)
            {
              goto LABEL_21;
            }
            v138 = (uint64_t *)*v138;
            if (!v138)
              goto LABEL_22;
          }
        }
        do
        {
          v140 = v138[1];
          if (v140 == v134)
          {
            if (*((_DWORD *)v138 + 4) == (_DWORD)v134)
              break;
          }
          else
          {
            if (v140 >= *(_QWORD *)&v135)
              v140 %= *(_QWORD *)&v135;
            if (v140 != v137)
              goto LABEL_21;
          }
          v138 = (uint64_t *)*v138;
        }
        while (v138);
      }
    }
  }
  else
  {
LABEL_21:
    v138 = 0;
  }
LABEL_22:
  v142 = __C;
  v143 = *(float *)(v1 + 112);
  if (v143 == 0.0 || __C <= v143)
  {
    if (v138)
    {
      v147 = *__error();
      v148 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v148, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__A = 67109376;
        *(_DWORD *)&__A[4] = v134;
        *(_WORD *)&__A[8] = 2048;
        *(double *)&__A[10] = v142;
        _os_log_impl(&dword_1B8270000, v148, OS_LOG_TYPE_DEFAULT, "Include vec_id: %u distance %f", __A, 0x12u);
      }
      *__error() = v147;
    }
    *(_OWORD *)__A = *(_OWORD *)(Ptr + 1024);
    *(_DWORD *)&__A[16] = v134;
    *(float *)&__A[20] = v142;
    MaxSizePriorityQueue<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_memory_postings>,std::vector<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_memory_postings>,std::allocator<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_memory_postings>>>,std::less<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_memory_postings>>>::push(*(_QWORD **)(v1 + 104), (__int128 *)__A);
  }
  else
  {
    if (v138)
    {
      v144 = *__error();
      v145 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v145, OS_LOG_TYPE_DEFAULT))
      {
        v146 = *(float *)(v1 + 112);
        *(_DWORD *)__A = 67109632;
        *(_DWORD *)&__A[4] = v134;
        *(_WORD *)&__A[8] = 2048;
        *(double *)&__A[10] = v142;
        *(_WORD *)&__A[18] = 2048;
        *(double *)&__A[20] = v146;
        _os_log_impl(&dword_1B8270000, v145, OS_LOG_TYPE_DEFAULT, "Skip vec_id: %u distance %f > %f", __A, 0x1Cu);
      }
      *__error() = v144;
    }
    ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v1 + 40) + 8) + 24);
  }
}

uint64_t ___ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li512EE3aNNEjtPKv14vec_dimensions15vec_data_formatfjbU13block_pointerFvPvfE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

_DWORD *_ZN22IVFVectorIndexTemplateIDF16_Li512EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE15lookupForInsertEjRK10CIVector_sIDF16_Li512EEjfb(uint64_t a1, unsigned int a2, const void *a3, unsigned int a4, float a5)
{
  unsigned int v8;
  uint64_t v9;
  _DWORD *Ptr;
  const UInt8 *data;
  int v12;
  NSObject *v13;
  int v14;
  NSObject *v15;
  int v16;
  NSObject *v17;
  _BYTE *v18;
  int v19;
  NSObject *v20;
  _BYTE *v21;
  const void *v22;
  std::__shared_weak_count *v23;
  unint64_t *p_shared_owners;
  unint64_t v25;
  std::__shared_weak_count *v26;
  _DWORD *v27;
  unint64_t *v28;
  unint64_t v29;
  uint64_t v30;
  size_t OffsetFromEnd;
  uint64_t v32;
  int v33;
  NSObject *v34;
  _OWORD *v35;
  uint64_t v36;
  unint64_t *v37;
  unint64_t v38;
  unint64_t *v39;
  unint64_t v40;
  NSObject *v41;
  const UInt8 *v42;
  int v43;
  NSObject *v44;
  size_t v45;
  int v46;
  NSObject *v47;
  int v48;
  NSObject *v49;
  _BYTE *v50;
  int v51;
  NSObject *v52;
  _BYTE *v53;
  NSObject *v54;
  int v55;
  NSObject *v56;
  int v58;
  int v59;
  int v60;
  char *v61;
  char *v62;
  const char *v63;
  char *v64;
  char *v65;
  const char *v66;
  char *v67;
  const char *v68;
  char *v69;
  const char *v70;
  char *v71;
  const char *v72;
  uint64_t v73;
  char *v74;
  const char *v75;
  char *v76;
  const char *v77;
  unsigned int v78;
  uint64_t v79;
  float v80;
  unsigned int v81;
  uint8_t buf[4];
  _BYTE *v83;
  _BYTE __p[12];
  __int16 v85;
  int v86;
  __int16 v87;
  _BYTE v88[14];
  __int16 v89;
  uint64_t v90;
  uint64_t v91;

  v91 = *MEMORY[0x1E0C80C00];
  v81 = a4;
  v80 = a5;
  if (*(_BYTE *)(a1 + 144))
  {
    v61 = __si_assert_copy_extra_268();
    v62 = v61;
    v63 = "";
    if (v61)
      v63 = v61;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2430, "!readOnly", v63);
    goto LABEL_104;
  }
  v8 = _ZN22IVFVectorIndexTemplateIDF16_Li512EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE10findVectorERK10CIVector_sIDF16_Li512EERjRfj(a1, (uint64_t)a3, (int *)&v81, &v80, a2);
  v9 = v81;
  if (v81 == -1)
  {
    v64 = __si_assert_copy_extra_268();
    v65 = v64;
    v66 = "";
    if (v64)
      v66 = v64;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2435, "partID != VECTOR_NOT_FOUND", v66);
    goto LABEL_94;
  }
  if (v8 != -1)
  {
    Ptr = (_DWORD *)vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(*(_QWORD *)(a1 + 32) + 16), v8, 1044);
    if (Ptr[260] == a2)
      return Ptr;
    v79 = 0;
    data = data_map_get_data(*(_QWORD *)(a1 + 128), a2, &v79);
    v12 = *__error();
    v13 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__p = 136316162;
      *(_QWORD *)&__p[4] = "lookupForInsert";
      v85 = 1024;
      v86 = 2463;
      v87 = 1024;
      *(_DWORD *)v88 = a2;
      *(_WORD *)&v88[4] = 2048;
      *(_QWORD *)&v88[6] = data;
      v89 = 2048;
      v90 = v79;
      _os_log_error_impl(&dword_1B8270000, v13, OS_LOG_TYPE_ERROR, "%s:%d: vectorId=%u in datamap: %p size=%zd", __p, 0x2Cu);
    }
    *__error() = v12;
    if (v79 < 1)
    {
      v19 = *__error();
      v41 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__p = 136315394;
        *(_QWORD *)&__p[4] = "lookupForInsert";
        v85 = 1024;
        v86 = 2472;
        _os_log_error_impl(&dword_1B8270000, v41, OS_LOG_TYPE_ERROR, "%s:%d: vectorId is invalid", __p, 0x12u);
      }
    }
    else
    {
      if (v79 != 1024)
      {
        v74 = __si_assert_copy_extra_268();
        v62 = v74;
        v75 = "";
        if (v74)
          v75 = v74;
        __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2465, "size == D * sizeof(ELEM_TYPE)", v75);
        goto LABEL_104;
      }
      if (!data || !memcmp(data, a3, 0x400uLL))
        goto LABEL_51;
      v14 = *__error();
      v15 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__p = 136315394;
        *(_QWORD *)&__p[4] = "lookupForInsert";
        v85 = 1024;
        v86 = 2467;
        _os_log_error_impl(&dword_1B8270000, v15, OS_LOG_TYPE_ERROR, "%s:%d: vector in datamap is not same as vector passed in", __p, 0x12u);
      }
      *__error() = v14;
      v16 = *__error();
      v17 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        data2hexString(__p, (uint64_t)data, v79);
        v18 = v88[3] >= 0 ? __p : *(_BYTE **)__p;
        *(_DWORD *)buf = 136315138;
        v83 = v18;
        _os_log_impl(&dword_1B8270000, v17, OS_LOG_TYPE_DEFAULT, "vector in datamap: %s", buf, 0xCu);
        if ((v88[3] & 0x80000000) != 0)
          operator delete(*(void **)__p);
      }
      *__error() = v16;
      v19 = *__error();
      v20 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        data2hexString(__p, (uint64_t)a3, v79);
        v21 = v88[3] >= 0 ? __p : *(_BYTE **)__p;
        *(_DWORD *)buf = 136315138;
        v83 = v21;
        _os_log_impl(&dword_1B8270000, v20, OS_LOG_TYPE_DEFAULT, "vector passed in: %s", buf, 0xCu);
        if ((v88[3] & 0x80000000) != 0)
          operator delete(*(void **)__p);
      }
    }
    *__error() = v19;
LABEL_51:
    v42 = data_map_get_data(*(_QWORD *)(a1 + 128), Ptr[260], &v79);
    v43 = *__error();
    v44 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
    {
      v58 = Ptr[260];
      *(_DWORD *)__p = 136316162;
      *(_QWORD *)&__p[4] = "lookupForInsert";
      v85 = 1024;
      v86 = 2475;
      v87 = 1024;
      *(_DWORD *)v88 = v58;
      *(_WORD *)&v88[4] = 2048;
      *(_QWORD *)&v88[6] = v42;
      v89 = 2048;
      v90 = v79;
      _os_log_error_impl(&dword_1B8270000, v44, OS_LOG_TYPE_ERROR, "%s:%d: old vectorId=%u in datamap: %p size=%zd", __p, 0x2Cu);
    }
    *__error() = v43;
    if (v79 < 1)
    {
      v51 = *__error();
      v54 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__p = 136315394;
        *(_QWORD *)&__p[4] = "lookupForInsert";
        v85 = 1024;
        v86 = 2484;
        _os_log_error_impl(&dword_1B8270000, v54, OS_LOG_TYPE_ERROR, "%s:%d: old vectorId is invalid", __p, 0x12u);
      }
      goto LABEL_73;
    }
    if (v79 == 1024)
    {
      v45 = 1024;
      if (!v42 || !memcmp(v42, Ptr, 0x400uLL))
        goto LABEL_74;
      v46 = *__error();
      v47 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__p = 136315394;
        *(_QWORD *)&__p[4] = "lookupForInsert";
        v85 = 1024;
        v86 = 2479;
        _os_log_error_impl(&dword_1B8270000, v47, OS_LOG_TYPE_ERROR, "%s:%d: vector in datamap is not same as vector passed in", __p, 0x12u);
      }
      *__error() = v46;
      v48 = *__error();
      v49 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
      {
        data2hexString(__p, (uint64_t)v42, v79);
        v50 = v88[3] >= 0 ? __p : *(_BYTE **)__p;
        *(_DWORD *)buf = 136315138;
        v83 = v50;
        _os_log_impl(&dword_1B8270000, v49, OS_LOG_TYPE_DEFAULT, "vector in datamap: %s", buf, 0xCu);
        if ((v88[3] & 0x80000000) != 0)
          operator delete(*(void **)__p);
      }
      *__error() = v48;
      v51 = *__error();
      v52 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
      {
        data2hexString(__p, (uint64_t)Ptr, v79);
        v53 = v88[3] >= 0 ? __p : *(_BYTE **)__p;
        *(_DWORD *)buf = 136315138;
        v83 = v53;
        _os_log_impl(&dword_1B8270000, v52, OS_LOG_TYPE_DEFAULT, "vector in vector store: %s", buf, 0xCu);
        if ((v88[3] & 0x80000000) != 0)
          operator delete(*(void **)__p);
      }
LABEL_73:
      *__error() = v51;
      v45 = v79;
LABEL_74:
      if (!memcmp(a3, Ptr, v45))
      {
        v55 = *__error();
        v56 = _SILogForLogForCategory(16);
        if (os_log_type_enabled(v56, OS_LOG_TYPE_FAULT))
        {
          v59 = Ptr[260];
          *(_DWORD *)__p = 136315906;
          *(_QWORD *)&__p[4] = "lookupForInsert";
          v85 = 1024;
          v86 = 2487;
          v87 = 1024;
          *(_DWORD *)v88 = a2;
          *(_WORD *)&v88[4] = 1024;
          *(_DWORD *)&v88[6] = v59;
          _os_log_fault_impl(&dword_1B8270000, v56, OS_LOG_TYPE_FAULT, "%s:%d: Dup vector with new vectorId=%u old=%u", __p, 0x1Eu);
        }
        *__error() = v55;
        return Ptr;
      }
      v71 = __si_assert_copy_extra_268();
      v65 = v71;
      v72 = "";
      if (v71)
        v72 = v71;
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2486, "memcmp(vec.vec, entry->vec.vec, size) == 0", v72);
LABEL_94:
      free(v65);
      if (__valid_fs(-1))
        v73 = 2989;
      else
        v73 = 3072;
      *(_DWORD *)v73 = -559038737;
      abort();
    }
    v76 = __si_assert_copy_extra_268();
    v62 = v76;
    v77 = "";
    if (v76)
      v77 = v76;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2477, "size == D * sizeof(ELEM_TYPE)", v77);
LABEL_104:
    free(v62);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v78 = a2;
  v22 = a3;
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  v23 = *(std::__shared_weak_count **)(a1 + 72);
  if (v23)
  {
    p_shared_owners = (unint64_t *)&v23->__shared_owners_;
    do
      v25 = __ldxr(p_shared_owners);
    while (__stxr(v25 + 1, p_shared_owners));
  }
  v27 = *(_DWORD **)(a1 + 80);
  v26 = *(std::__shared_weak_count **)(a1 + 88);
  if (v26)
  {
    v28 = (unint64_t *)&v26->__shared_owners_;
    do
      v29 = __ldxr(v28);
    while (__stxr(v29 + 1, v28));
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
  v30 = *(_QWORD *)(a1 + 32);
  OffsetFromEnd = vi_onefixedsize_memory_allocator::allocateOffsetFromEnd(*(_QWORD *)(v30 + 16), 0x414u);
  v32 = *(unsigned int *)(v30 + 24);
  if (OffsetFromEnd != v32)
  {
    v33 = *__error();
    v34 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
    {
      v60 = *(_DWORD *)(v30 + 24);
      *(_DWORD *)__p = 136315906;
      *(_QWORD *)&__p[4] = "newEntry";
      v85 = 1024;
      v86 = 1779;
      v87 = 2048;
      *(_QWORD *)v88 = OffsetFromEnd;
      *(_WORD *)&v88[8] = 1024;
      *(_DWORD *)&v88[10] = v60;
      _os_log_error_impl(&dword_1B8270000, v34, OS_LOG_TYPE_ERROR, "%s:%d: offset: %llu, nVectors: %u", __p, 0x22u);
    }
    *__error() = v33;
    v32 = *(unsigned int *)(v30 + 24);
    if (OffsetFromEnd != v32)
    {
      v69 = __si_assert_copy_extra_268();
      v62 = v69;
      v70 = "";
      if (v69)
        v70 = v69;
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1782, "offset == nVectors", v70);
      goto LABEL_104;
    }
  }
  *(_DWORD *)(v30 + 24) = v32 + 1;
  v35 = (_OWORD *)vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(v30 + 16), OffsetFromEnd, 1044);
  memcpy(v35, v22, 0x400uLL);
  v35[64] = 0u;
  (*(void (**)(_DWORD *, uint64_t, size_t, float))(*(_QWORD *)v27 + 56))(v27, v9, OffsetFromEnd, v80);
  v36 = *(_QWORD *)(a1 + 32);
  if (v27[18] != *(_DWORD *)(v36 + 24))
  {
    v67 = __si_assert_copy_extra_268();
    v62 = v67;
    v68 = "";
    if (v67)
      v68 = v67;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2440, "cur.partitions->nVectors() == vectors->count()", v68);
    goto LABEL_104;
  }
  Ptr = (_DWORD *)vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(v36 + 16), OffsetFromEnd, 1044);
  Ptr[260] = v78;
  if (*(_DWORD *)(*(_QWORD *)(a1 + 32) + 24) == 1)
    *(_DWORD *)(a1 + 148) = v78;
  *(_DWORD *)(a1 + 152) = v78;
  if (v26)
  {
    v37 = (unint64_t *)&v26->__shared_owners_;
    do
      v38 = __ldaxr(v37);
    while (__stlxr(v38 - 1, v37));
    if (!v38)
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
    }
  }
  if (v23)
  {
    v39 = (unint64_t *)&v23->__shared_owners_;
    do
      v40 = __ldaxr(v39);
    while (__stlxr(v40 - 1, v39));
    if (!v40)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
  return Ptr;
}

uint64_t _ZN22IVFVectorIndexTemplateIDF16_Li512EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE10findVectorERK10CIVector_sIDF16_Li512EERjRfj(uint64_t a1, uint64_t a2, int *a3, _DWORD *a4, int a5)
{
  os_unfair_lock_s *v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  std::__shared_weak_count *v15;
  _DWORD *v16;
  unint64_t *v17;
  unint64_t v18;
  uint64_t v19;
  _DWORD *v20;
  unsigned int v21;
  uint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  unint64_t *v25;
  unint64_t v26;
  char *v28;
  char *v29;
  const char *v30;
  char *v31;
  const char *v32;
  char *v33;
  char *v34;
  const char *v35;
  int v36;
  int v37;
  int v38;
  int v39;
  _QWORD v40[8];
  int v41;
  _DWORD *v42;
  char *v43;
  uint64_t v44;
  int v45;

  v10 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  v12 = *(_QWORD *)(a1 + 64);
  v11 = *(std::__shared_weak_count **)(a1 + 72);
  if (v11)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      v14 = __ldxr(p_shared_owners);
    while (__stxr(v14 + 1, p_shared_owners));
  }
  v16 = *(_DWORD **)(a1 + 80);
  v15 = *(std::__shared_weak_count **)(a1 + 88);
  if (v15)
  {
    v17 = (unint64_t *)&v15->__shared_owners_;
    do
      v18 = __ldxr(v17);
    while (__stxr(v18 + 1, v17));
  }
  os_unfair_lock_unlock(v10);
  v19 = *a3;
  if ((_DWORD)v19 == -1)
  {
    if (*(_DWORD *)(a1 + 140) == -1)
    {
      v42 = 0;
      v43 = 0;
      v44 = 0;
      (*(void (**)(_DWORD **__return_ptr, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v12 + 72))(&v42, v12, a2, 1);
      v20 = v42;
      if (v43 - (char *)v42 == 8)
      {
        v21 = *v42;
        *a3 = *v42;
        *a4 = v20[1];
        if (v21 >= IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nPartitions(a1))
        {
          v33 = __si_assert_copy_extra_268();
          v34 = v33;
          if (v33)
            v35 = v33;
          else
            v35 = "";
          v36 = *a3;
          v37 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nPartitions(a1);
          v38 = v16[19];
          v39 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v12 + 16))(v12);
          __message_assert("%s:%u: failed assertion '%s' %s Invalid partId %u >= %u (partitions: v%u quantizer v%u", "IVFVectorIndex.hh", 2403, "partID < nPartitions()", v35, v36, v37, v38, v39);
          free(v34);
          if (__valid_fs(-1))
          {
            MEMORY[0xBAD] = -559038737;
            abort();
          }
          MEMORY[0xC00] = -559038737;
          abort();
        }
        if (v42)
        {
          v43 = (char *)v42;
          operator delete(v42);
        }
        v19 = *a3;
        goto LABEL_14;
      }
      v31 = __si_assert_copy_extra_268();
      v29 = v31;
      v32 = "";
      if (v31)
        v32 = v31;
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2398, "topPartition.size() == 1", v32);
    }
    else
    {
      v28 = __si_assert_copy_extra_268();
      v29 = v28;
      v30 = "";
      if (v28)
        v30 = v28;
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2396, "mergeBeginVectorOffset == VECTOR_NOT_FOUND", v30);
    }
    free(v29);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
LABEL_14:
  v42 = 0;
  v43 = (char *)&v42;
  v45 = -1;
  v44 = 0x2000000000;
  v40[0] = MEMORY[0x1E0C809B0];
  v40[1] = 0x40000000;
  v40[2] = ___ZN22IVFVectorIndexTemplateIDF16_Li512EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE10findVectorERK10CIVector_sIDF16_Li512EERjRfj_block_invoke;
  v40[3] = &unk_1E6E318D8;
  v41 = a5;
  v40[6] = a4;
  v40[7] = a2;
  v40[4] = &v42;
  v40[5] = a1;
  (*(void (**)(_DWORD *, uint64_t, _QWORD *))(*(_QWORD *)v16 + 80))(v16, v19, v40);
  v22 = *((unsigned int *)v43 + 6);
  _Block_object_dispose(&v42, 8);
  if (v15)
  {
    v23 = (unint64_t *)&v15->__shared_owners_;
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  if (v11)
  {
    v25 = (unint64_t *)&v11->__shared_owners_;
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  return v22;
}

unint64_t ___ZN22IVFVectorIndexTemplateIDF16_Li512EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE10findVectorERK10CIVector_sIDF16_Li512EERjRfj_block_invoke(unint64_t result, uint64_t a2, float *a3, _BYTE *a4)
{
  uint64_t v5;
  uint64_t v6;
  unint64_t v8;
  float v9;
  float v10;
  BOOL v11;
  float v12;
  float v13;
  int v15;
  const void *v16;
  const void *Ptr;

  v5 = *(_QWORD *)(result + 40);
  v6 = *(unsigned int *)a3;
  if (v6 >= *(_DWORD *)(v5 + 140))
    goto LABEL_12;
  v8 = result;
  v9 = **(float **)(result + 48);
  v10 = a3[1];
  v11 = v9 == v10;
  v12 = vabds_f32(v9, v10);
  v13 = fmaxf(fminf(fabsf(v10), fabsf(v9)) * 0.000015259, 0.000015259);
  if (v11 || v12 <= v13)
  {
    v15 = *(_DWORD *)(result + 64);
    if (v15)
    {
      result = vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(*(_QWORD *)(v5 + 32) + 16), v6, 1044);
      if (v15 != *(_DWORD *)(result + 1040))
        return result;
      *(float *)&v6 = *a3;
    }
    v16 = *(const void **)(v8 + 56);
    Ptr = (const void *)vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(*(_QWORD *)(v5 + 32) + 16), v6, 1044);
    result = memcmp(v16, Ptr, 0x400uLL);
    if (!(_DWORD)result)
    {
      *(float *)(*(_QWORD *)(*(_QWORD *)(v8 + 32) + 8) + 24) = *a3;
LABEL_12:
      *a4 = 1;
    }
  }
  return result;
}

void ___ZNK22IVFVectorIndexTemplateIDF16_Li512EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE4dumpEbbPViPvU13block_pointerFbjPKvybjfE_block_invoke()
{
  char *v0;
  char *v1;
  const char *v2;

  v0 = __si_assert_copy_extra_268();
  v1 = v0;
  v2 = "";
  if (v0)
    v2 = v0;
  __message_assert("%s:%u: failed assertion '%s' %s ", "VectorIndexSupport.hh", 2544, "0", v2);
  free(v1);
  if (__valid_fs(-1))
  {
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  MEMORY[0xC00] = -559038737;
  abort();
}

BOOL _ZN22IVFVectorIndexTemplateIDF16_Li512EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE6existsERK10CIVector_sIDF16_Li512EE(uint64_t a1, uint64_t a2)
{
  int v4;
  int v6;
  NSObject *v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  std::__shared_weak_count *v12;
  uint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  unsigned int v16;
  uint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  _QWORD v32[8];
  std::__shared_weak_count *v33;
  uint64_t v34;
  std::__shared_weak_count *v35;
  unsigned int v36;
  _QWORD v37[7];
  unsigned int v38;
  float v39;
  float v40;
  unsigned int v41;
  _BYTE buf[24];
  _DWORD v43[4];
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  v40 = 3.4028e38;
  v41 = -1;
  v4 = _ZN22IVFVectorIndexTemplateIDF16_Li512EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE10findVectorERK10CIVector_sIDF16_Li512EERjRfj(a1, a2, (int *)&v41, &v40, 0);
  if (v4 == -1)
  {
    v6 = *__error();
    v7 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = "exists";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 2632;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v41;
      LOWORD(v43[0]) = 2048;
      *(double *)((char *)v43 + 2) = v40;
      _os_log_error_impl(&dword_1B8270000, v7, OS_LOG_TYPE_ERROR, "%s:%d: Vector not found partID=%u distsq=%e", buf, 0x22u);
    }
    *__error() = v6;
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
    v9 = *(_QWORD *)(a1 + 64);
    v8 = *(std::__shared_weak_count **)(a1 + 72);
    if (v8)
    {
      p_shared_owners = (unint64_t *)&v8->__shared_owners_;
      do
        v11 = __ldxr(p_shared_owners);
      while (__stxr(v11 + 1, p_shared_owners));
    }
    v13 = *(_QWORD *)(a1 + 80);
    v12 = *(std::__shared_weak_count **)(a1 + 88);
    if (v12)
    {
      v14 = (unint64_t *)&v12->__shared_owners_;
      do
        v15 = __ldxr(v14);
      while (__stxr(v15 + 1, v14));
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    v43[0] = -1;
    *(_QWORD *)&buf[16] = 0x2000000000;
    v16 = v41;
    v17 = MEMORY[0x1E0C809B0];
    v37[0] = MEMORY[0x1E0C809B0];
    v37[1] = 0x40000000;
    v37[2] = ___ZN22IVFVectorIndexTemplateIDF16_Li512EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE6existsERK10CIVector_sIDF16_Li512EE_block_invoke;
    v37[3] = &unk_1E6E31878;
    v37[5] = a1;
    v37[6] = a2;
    v38 = v41;
    v39 = v40;
    v37[4] = buf;
    (*(void (**)(uint64_t, _QWORD, _QWORD *))(*(_QWORD *)v13 + 80))(v13, v41, v37);
    if (*(_DWORD *)(*(_QWORD *)&buf[8] + 24) == -1)
    {
      v32[0] = v17;
      v32[1] = 1174405120;
      v32[2] = ___ZN22IVFVectorIndexTemplateIDF16_Li512EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE6existsERK10CIVector_sIDF16_Li512EE_block_invoke_302;
      v32[3] = &unk_1E6E318A0;
      v32[5] = a1;
      v32[6] = a2;
      v32[7] = v9;
      v33 = v8;
      if (v8)
      {
        v22 = (unint64_t *)&v8->__shared_owners_;
        do
          v23 = __ldxr(v22);
        while (__stxr(v23 + 1, v22));
      }
      v34 = v13;
      v35 = v12;
      if (v12)
      {
        v24 = (unint64_t *)&v12->__shared_owners_;
        do
          v25 = __ldxr(v24);
        while (__stxr(v25 + 1, v24));
      }
      v36 = v16;
      v32[4] = buf;
      (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v13 + 64))(v13, v32);
      v26 = v35;
      if (v35)
      {
        v27 = (unint64_t *)&v35->__shared_owners_;
        do
          v28 = __ldaxr(v27);
        while (__stlxr(v28 - 1, v27));
        if (!v28)
        {
          ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
          std::__shared_weak_count::__release_weak(v26);
        }
      }
      v29 = v33;
      if (v33)
      {
        v30 = (unint64_t *)&v33->__shared_owners_;
        do
          v31 = __ldaxr(v30);
        while (__stlxr(v31 - 1, v30));
        if (!v31)
        {
          ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
          std::__shared_weak_count::__release_weak(v29);
        }
      }
    }
    _Block_object_dispose(buf, 8);
    if (v12)
    {
      v18 = (unint64_t *)&v12->__shared_owners_;
      do
        v19 = __ldaxr(v18);
      while (__stlxr(v19 - 1, v18));
      if (!v19)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
    if (v8)
    {
      v20 = (unint64_t *)&v8->__shared_owners_;
      do
        v21 = __ldaxr(v20);
      while (__stlxr(v21 - 1, v20));
      if (!v21)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }
  }
  return v4 != -1;
}

void ___ZN22IVFVectorIndexTemplateIDF16_Li512EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE6existsERK10CIVector_sIDF16_Li512EE_block_invoke_302(uint64_t a1)
{
  uint64_t v1;
  _BYTE *v2;
  _BYTE *v3;
  float *v4;
  float *v5;
  int v6;
  int v7;
  uint64_t v8;
  const void *v9;
  uint64_t v10;
  const void *Ptr;
  int v12;
  NSObject *v13;
  float16x8_t *v14;
  uint64_t v15;
  float16x8_t v16;
  float32x4_t v17;
  float16x8_t v18;
  float16x8_t v19;
  float16x8_t v20;
  float16x8_t v21;
  float16x8_t v22;
  float16x8_t v23;
  float16x8_t v24;
  float16x8_t v25;
  float16x8_t v26;
  float16x8_t v27;
  float16x8_t v28;
  float16x8_t v29;
  float16x8_t v30;
  float16x8_t v31;
  float16x8_t v32;
  float16x8_t v33;
  float16x8_t v34;
  float16x8_t v35;
  float16x8_t v36;
  float16x8_t v37;
  float16x8_t v38;
  float16x8_t v39;
  float16x8_t v40;
  float16x8_t v41;
  float16x8_t v42;
  float16x8_t v43;
  float16x8_t v44;
  float16x8_t v45;
  float16x8_t v46;
  float16x8_t v47;
  float16x8_t v48;
  float16x8_t v49;
  float16x8_t v50;
  float16x8_t v51;
  float16x8_t v52;
  float16x8_t v53;
  float16x8_t v54;
  float16x8_t v55;
  float16x8_t v56;
  float16x8_t v57;
  float16x8_t v58;
  float16x8_t v59;
  float16x8_t v60;
  float16x8_t v61;
  float16x8_t v62;
  float16x8_t v63;
  float16x8_t v64;
  float16x8_t v65;
  float16x8_t v66;
  float16x8_t v67;
  float16x8_t v68;
  float16x8_t v69;
  float16x8_t v70;
  float16x8_t v71;
  float16x8_t v72;
  float16x8_t v73;
  float16x8_t v74;
  float16x8_t v75;
  float16x8_t v76;
  float16x8_t v77;
  float16x8_t v78;
  float16x8_t v79;
  float16x8_t v80;
  float32x4_t v81;
  float16x8_t v82;
  float16x8_t v83;
  float16x8_t v84;
  float16x8_t v85;
  float16x8_t v86;
  float16x8_t v87;
  float16x8_t v88;
  float16x8_t v89;
  float16x8_t v90;
  float16x8_t v91;
  float16x8_t v92;
  float16x8_t v93;
  float16x8_t v94;
  float16x8_t v95;
  float16x8_t v96;
  float16x8_t v97;
  float16x8_t v98;
  float16x8_t v99;
  float16x8_t v100;
  float16x8_t v101;
  float16x8_t v102;
  float16x8_t v103;
  float16x8_t v104;
  float16x8_t v105;
  float16x8_t v106;
  float16x8_t v107;
  float16x8_t v108;
  float16x8_t v109;
  float16x8_t v110;
  float16x8_t v111;
  float16x8_t v112;
  float16x8_t v113;
  float16x8_t v114;
  float16x8_t v115;
  float16x8_t v116;
  float16x8_t v117;
  float16x8_t v118;
  float16x8_t v119;
  float16x8_t v120;
  float16x8_t v121;
  float16x8_t v122;
  float16x8_t v123;
  float16x8_t v124;
  float16x8_t v125;
  float16x8_t v126;
  float16x8_t v127;
  float16x8_t v128;
  float16x8_t v129;
  float16x8_t v130;
  float16x8_t v131;
  float16x8_t v132;
  float16x8_t v133;
  float16x8_t v134;
  float16x8_t v135;
  float16x8_t v136;
  float16x8_t v137;
  float16x8_t v138;
  float16x8_t v139;
  float16x8_t v140;
  float16x8_t v141;
  float16x8_t v142;
  float16x8_t v143;
  float v144;
  int v145;
  NSObject *v146;
  int v147;
  NSObject *v148;
  int v149;
  NSObject *v150;
  int v151;
  NSObject *v152;
  int v153;
  NSObject *v154;
  int v155;
  NSObject *v156;
  uint64_t v157;
  unint64_t v158;
  int v159;
  NSObject *v160;
  int v161;
  NSObject *v162;
  int v163;
  NSObject *v164;
  int v165;
  NSObject *v166;
  int v167;
  NSObject *v168;
  double v169;
  int v170;
  int v171;
  float v172;
  int v173;
  float v174;
  _BOOL4 v175;
  int v176;
  int v177;
  _BOOL4 v178;
  int v179;
  int v180;
  _BOOL4 v181;
  int v182;
  int v183;
  _BOOL4 v184;
  int v185;
  int v186;
  float v187;
  float v188;
  double v189;
  float v190;
  _BOOL4 v191;
  _BOOL4 v192;
  float v193;
  float v194;
  int v195;
  float v196;
  _BOOL4 v197;
  float v198;
  int v199;
  _BOOL4 v200;
  float v201;
  int v202;
  _BOOL4 v203;
  float v204;
  int v205;
  _BOOL4 v206;
  float v207;
  int v208;
  float v209;
  float v210;
  float v211;
  _BOOL4 v212;
  _BOOL4 v213;
  _BOOL4 v214;
  float v215;
  float v216;
  float v217;
  float v218;
  float *__C;
  float *v220;
  uint64_t v221;
  float32x4_t __B;
  float32x4_t v223;
  float32x4_t v224;
  float32x4_t v225;
  float32x4_t v226;
  float32x4_t v227;
  float32x4_t v228;
  float32x4_t v229;
  float32x4_t v230;
  float32x4_t v231;
  float32x4_t v232;
  float32x4_t v233;
  float32x4_t v234;
  float32x4_t v235;
  float32x4_t v236;
  float32x4_t v237;
  float32x4_t v238;
  float32x4_t v239;
  float32x4_t v240;
  float32x4_t v241;
  float32x4_t v242;
  float32x4_t v243;
  float32x4_t v244;
  float32x4_t v245;
  float32x4_t v246;
  float32x4_t v247;
  float32x4_t v248;
  float32x4_t v249;
  float32x4_t v250;
  float32x4_t v251;
  float32x4_t v252;
  float32x4_t v253;
  float32x4_t v254;
  float32x4_t v255;
  float32x4_t v256;
  float32x4_t v257;
  float32x4_t v258;
  float32x4_t v259;
  float32x4_t v260;
  float32x4_t v261;
  float32x4_t v262;
  float32x4_t v263;
  float32x4_t v264;
  float32x4_t v265;
  float32x4_t v266;
  float32x4_t v267;
  float32x4_t v268;
  float32x4_t v269;
  float32x4_t v270;
  float32x4_t v271;
  float32x4_t v272;
  float32x4_t v273;
  float32x4_t v274;
  float32x4_t v275;
  float32x4_t v276;
  float32x4_t v277;
  float32x4_t v278;
  float32x4_t v279;
  float32x4_t v280;
  float32x4_t v281;
  float32x4_t v282;
  float32x4_t v283;
  float32x4_t v284;
  float32x4_t v285;
  float32x4_t v286;
  float32x4_t v287;
  float32x4_t v288;
  float32x4_t v289;
  float32x4_t v290;
  float32x4_t v291;
  float32x4_t v292;
  float32x4_t v293;
  float32x4_t v294;
  float32x4_t v295;
  float32x4_t v296;
  float32x4_t v297;
  float32x4_t v298;
  float32x4_t v299;
  float32x4_t v300;
  float32x4_t v301;
  float32x4_t v302;
  float32x4_t v303;
  float32x4_t v304;
  float32x4_t v305;
  float32x4_t v306;
  float32x4_t v307;
  float32x4_t v308;
  float32x4_t v309;
  float32x4_t v310;
  float32x4_t v311;
  float32x4_t v312;
  float32x4_t v313;
  float32x4_t v314;
  float32x4_t v315;
  float32x4_t v316;
  float32x4_t v317;
  float32x4_t v318;
  float32x4_t v319;
  float32x4_t v320;
  float32x4_t v321;
  float32x4_t v322;
  float32x4_t v323;
  float32x4_t v324;
  float32x4_t v325;
  float32x4_t v326;
  float32x4_t v327;
  float32x4_t v328;
  float32x4_t v329;
  float32x4_t v330;
  float32x4_t v331;
  float32x4_t v332;
  float32x4_t v333;
  float32x4_t v334;
  float32x4_t v335;
  float32x4_t v336;
  float32x4_t v337;
  float32x4_t v338;
  float32x4_t v339;
  float32x4_t v340;
  float32x4_t v341;
  float32x4_t v342;
  float32x4_t v343;
  float32x4_t v344;
  float32x4_t v345;
  float32x4_t v346;
  float32x4_t v347;
  float32x4_t v348;
  float32x4_t v349;
  _BYTE __A[80];
  float32x4_t v351;
  float32x4_t v352;
  float32x4_t v353;
  float32x4_t v354;
  float32x4_t v355;
  float32x4_t v356;
  float32x4_t v357;
  float32x4_t v358;
  float32x4_t v359;
  float32x4_t v360;
  float32x4_t v361;
  float32x4_t v362;
  float32x4_t v363;
  float32x4_t v364;
  float32x4_t v365;
  float32x4_t v366;
  float32x4_t v367;
  float32x4_t v368;
  float32x4_t v369;
  float32x4_t v370;
  float32x4_t v371;
  float32x4_t v372;
  float32x4_t v373;
  float32x4_t v374;
  float32x4_t v375;
  float32x4_t v376;
  float32x4_t v377;
  float32x4_t v378;
  float32x4_t v379;
  float32x4_t v380;
  float32x4_t v381;
  float32x4_t v382;
  float32x4_t v383;
  float32x4_t v384;
  float32x4_t v385;
  float32x4_t v386;
  float32x4_t v387;
  float32x4_t v388;
  float32x4_t v389;
  float32x4_t v390;
  float32x4_t v391;
  float32x4_t v392;
  float32x4_t v393;
  float32x4_t v394;
  float32x4_t v395;
  float32x4_t v396;
  float32x4_t v397;
  float32x4_t v398;
  float32x4_t v399;
  float32x4_t v400;
  float32x4_t v401;
  float32x4_t v402;
  float32x4_t v403;
  float32x4_t v404;
  float32x4_t v405;
  float32x4_t v406;
  float32x4_t v407;
  float32x4_t v408;
  float32x4_t v409;
  float32x4_t v410;
  float32x4_t v411;
  float32x4_t v412;
  float32x4_t v413;
  float32x4_t v414;
  float32x4_t v415;
  float32x4_t v416;
  float32x4_t v417;
  float32x4_t v418;
  float32x4_t v419;
  float32x4_t v420;
  float32x4_t v421;
  float32x4_t v422;
  float32x4_t v423;
  float32x4_t v424;
  float32x4_t v425;
  float32x4_t v426;
  float32x4_t v427;
  float32x4_t v428;
  float32x4_t v429;
  float32x4_t v430;
  float32x4_t v431;
  float32x4_t v432;
  float32x4_t v433;
  float32x4_t v434;
  float32x4_t v435;
  float32x4_t v436;
  float32x4_t v437;
  float32x4_t v438;
  float32x4_t v439;
  float32x4_t v440;
  float32x4_t v441;
  float32x4_t v442;
  float32x4_t v443;
  float32x4_t v444;
  float32x4_t v445;
  float32x4_t v446;
  float32x4_t v447;
  float32x4_t v448;
  float32x4_t v449;
  float32x4_t v450;
  float32x4_t v451;
  float32x4_t v452;
  float32x4_t v453;
  float32x4_t v454;
  float32x4_t v455;
  float32x4_t v456;
  float32x4_t v457;
  float32x4_t v458;
  float32x4_t v459;
  float32x4_t v460;
  float32x4_t v461;
  float32x4_t v462;
  float32x4_t v463;
  float32x4_t v464;
  float32x4_t v465;
  float32x4_t v466;
  float32x4_t v467;
  float32x4_t v468;
  float32x4_t v469;
  float32x4_t v470;
  float32x4_t v471;
  float32x4_t v472;
  float32x4_t v473;
  uint64_t v474;

  v1 = MEMORY[0x1E0C80A78](a1);
  v3 = v2;
  v5 = v4;
  v7 = v6;
  v8 = v1;
  v474 = *MEMORY[0x1E0C80C00];
  v10 = *(_QWORD *)(v1 + 40);
  v9 = *(const void **)(v1 + 48);
  Ptr = (const void *)vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(*(_QWORD *)(v10 + 32) + 16), *(unsigned int *)v4, 1044);
  if (!memcmp(v9, Ptr, 0x400uLL))
  {
    v12 = *__error();
    v13 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      v169 = v5[1];
      *(_DWORD *)__A = 136315906;
      *(_QWORD *)&__A[4] = "exists_block_invoke";
      *(_WORD *)&__A[12] = 1024;
      *(_DWORD *)&__A[14] = 2647;
      *(_WORD *)&__A[18] = 1024;
      *(_DWORD *)&__A[20] = v7;
      *(_WORD *)&__A[24] = 2048;
      *(double *)&__A[26] = v169;
      _os_log_error_impl(&dword_1B8270000, v13, OS_LOG_TYPE_ERROR, "%s:%d: Vector not found actually in partID=%u distsq=%e", __A, 0x22u);
    }
    *__error() = v12;
    v14 = *(float16x8_t **)(v8 + 48);
    v15 = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(v8 + 56) + 64))(*(_QWORD *)(v8 + 56), *(unsigned int *)(v8 + 88));
    bzero(__A, 0x800uLL);
    v16 = v14[1];
    v17 = vcvt_hight_f32_f16(*v14);
    *(float32x4_t *)__A = vcvtq_f32_f16(*(float16x4_t *)v14->i8);
    *(float32x4_t *)&__A[16] = v17;
    *(float32x4_t *)&__A[32] = vcvtq_f32_f16(*(float16x4_t *)v16.i8);
    *(float32x4_t *)&__A[48] = vcvt_hight_f32_f16(v16);
    v18 = v14[2];
    v19 = v14[3];
    *(float32x4_t *)&__A[64] = vcvtq_f32_f16(*(float16x4_t *)v18.i8);
    v351 = vcvt_hight_f32_f16(v18);
    v352 = vcvtq_f32_f16(*(float16x4_t *)v19.i8);
    v353 = vcvt_hight_f32_f16(v19);
    v20 = v14[4];
    v21 = v14[5];
    v354 = vcvtq_f32_f16(*(float16x4_t *)v20.i8);
    v355 = vcvt_hight_f32_f16(v20);
    v356 = vcvtq_f32_f16(*(float16x4_t *)v21.i8);
    v357 = vcvt_hight_f32_f16(v21);
    v22 = v14[6];
    v23 = v14[7];
    v358 = vcvtq_f32_f16(*(float16x4_t *)v22.i8);
    v359 = vcvt_hight_f32_f16(v22);
    v360 = vcvtq_f32_f16(*(float16x4_t *)v23.i8);
    v361 = vcvt_hight_f32_f16(v23);
    v24 = v14[8];
    v25 = v14[9];
    v362 = vcvtq_f32_f16(*(float16x4_t *)v24.i8);
    v363 = vcvt_hight_f32_f16(v24);
    v364 = vcvtq_f32_f16(*(float16x4_t *)v25.i8);
    v365 = vcvt_hight_f32_f16(v25);
    v26 = v14[10];
    v27 = v14[11];
    v366 = vcvtq_f32_f16(*(float16x4_t *)v26.i8);
    v367 = vcvt_hight_f32_f16(v26);
    v368 = vcvtq_f32_f16(*(float16x4_t *)v27.i8);
    v369 = vcvt_hight_f32_f16(v27);
    v28 = v14[12];
    v29 = v14[13];
    v370 = vcvtq_f32_f16(*(float16x4_t *)v28.i8);
    v371 = vcvt_hight_f32_f16(v28);
    v372 = vcvtq_f32_f16(*(float16x4_t *)v29.i8);
    v373 = vcvt_hight_f32_f16(v29);
    v30 = v14[14];
    v31 = v14[15];
    v374 = vcvtq_f32_f16(*(float16x4_t *)v30.i8);
    v375 = vcvt_hight_f32_f16(v30);
    v376 = vcvtq_f32_f16(*(float16x4_t *)v31.i8);
    v377 = vcvt_hight_f32_f16(v31);
    v32 = v14[16];
    v33 = v14[17];
    v378 = vcvtq_f32_f16(*(float16x4_t *)v32.i8);
    v379 = vcvt_hight_f32_f16(v32);
    v380 = vcvtq_f32_f16(*(float16x4_t *)v33.i8);
    v381 = vcvt_hight_f32_f16(v33);
    v34 = v14[18];
    v35 = v14[19];
    v382 = vcvtq_f32_f16(*(float16x4_t *)v34.i8);
    v383 = vcvt_hight_f32_f16(v34);
    v384 = vcvtq_f32_f16(*(float16x4_t *)v35.i8);
    v385 = vcvt_hight_f32_f16(v35);
    v36 = v14[20];
    v37 = v14[21];
    v386 = vcvtq_f32_f16(*(float16x4_t *)v36.i8);
    v387 = vcvt_hight_f32_f16(v36);
    v388 = vcvtq_f32_f16(*(float16x4_t *)v37.i8);
    v389 = vcvt_hight_f32_f16(v37);
    v38 = v14[22];
    v39 = v14[23];
    v390 = vcvtq_f32_f16(*(float16x4_t *)v38.i8);
    v391 = vcvt_hight_f32_f16(v38);
    v392 = vcvtq_f32_f16(*(float16x4_t *)v39.i8);
    v393 = vcvt_hight_f32_f16(v39);
    v40 = v14[24];
    v41 = v14[25];
    v394 = vcvtq_f32_f16(*(float16x4_t *)v40.i8);
    v395 = vcvt_hight_f32_f16(v40);
    v396 = vcvtq_f32_f16(*(float16x4_t *)v41.i8);
    v397 = vcvt_hight_f32_f16(v41);
    v42 = v14[26];
    v43 = v14[27];
    v398 = vcvtq_f32_f16(*(float16x4_t *)v42.i8);
    v399 = vcvt_hight_f32_f16(v42);
    v400 = vcvtq_f32_f16(*(float16x4_t *)v43.i8);
    v401 = vcvt_hight_f32_f16(v43);
    v44 = v14[28];
    v45 = v14[29];
    v402 = vcvtq_f32_f16(*(float16x4_t *)v44.i8);
    v403 = vcvt_hight_f32_f16(v44);
    v404 = vcvtq_f32_f16(*(float16x4_t *)v45.i8);
    v405 = vcvt_hight_f32_f16(v45);
    v46 = v14[30];
    v47 = v14[31];
    v406 = vcvtq_f32_f16(*(float16x4_t *)v46.i8);
    v407 = vcvt_hight_f32_f16(v46);
    v408 = vcvtq_f32_f16(*(float16x4_t *)v47.i8);
    v409 = vcvt_hight_f32_f16(v47);
    v48 = v14[32];
    v49 = v14[33];
    v411 = vcvt_hight_f32_f16(v48);
    v410 = vcvtq_f32_f16(*(float16x4_t *)v48.i8);
    v413 = vcvt_hight_f32_f16(v49);
    v412 = vcvtq_f32_f16(*(float16x4_t *)v49.i8);
    v50 = v14[34];
    v51 = v14[35];
    v415 = vcvt_hight_f32_f16(v50);
    v414 = vcvtq_f32_f16(*(float16x4_t *)v50.i8);
    v417 = vcvt_hight_f32_f16(v51);
    v416 = vcvtq_f32_f16(*(float16x4_t *)v51.i8);
    v52 = v14[36];
    v53 = v14[37];
    v419 = vcvt_hight_f32_f16(v52);
    v418 = vcvtq_f32_f16(*(float16x4_t *)v52.i8);
    v421 = vcvt_hight_f32_f16(v53);
    v420 = vcvtq_f32_f16(*(float16x4_t *)v53.i8);
    v54 = v14[38];
    v55 = v14[39];
    v423 = vcvt_hight_f32_f16(v54);
    v422 = vcvtq_f32_f16(*(float16x4_t *)v54.i8);
    v425 = vcvt_hight_f32_f16(v55);
    v424 = vcvtq_f32_f16(*(float16x4_t *)v55.i8);
    v56 = v14[40];
    v57 = v14[41];
    v427 = vcvt_hight_f32_f16(v56);
    v426 = vcvtq_f32_f16(*(float16x4_t *)v56.i8);
    v429 = vcvt_hight_f32_f16(v57);
    v428 = vcvtq_f32_f16(*(float16x4_t *)v57.i8);
    v58 = v14[42];
    v59 = v14[43];
    v431 = vcvt_hight_f32_f16(v58);
    v430 = vcvtq_f32_f16(*(float16x4_t *)v58.i8);
    v433 = vcvt_hight_f32_f16(v59);
    v432 = vcvtq_f32_f16(*(float16x4_t *)v59.i8);
    v60 = v14[44];
    v61 = v14[45];
    v435 = vcvt_hight_f32_f16(v60);
    v434 = vcvtq_f32_f16(*(float16x4_t *)v60.i8);
    v437 = vcvt_hight_f32_f16(v61);
    v436 = vcvtq_f32_f16(*(float16x4_t *)v61.i8);
    v62 = v14[46];
    v63 = v14[47];
    v439 = vcvt_hight_f32_f16(v62);
    v438 = vcvtq_f32_f16(*(float16x4_t *)v62.i8);
    v441 = vcvt_hight_f32_f16(v63);
    v440 = vcvtq_f32_f16(*(float16x4_t *)v63.i8);
    v64 = v14[48];
    v65 = v14[49];
    v443 = vcvt_hight_f32_f16(v64);
    v442 = vcvtq_f32_f16(*(float16x4_t *)v64.i8);
    v445 = vcvt_hight_f32_f16(v65);
    v444 = vcvtq_f32_f16(*(float16x4_t *)v65.i8);
    v66 = v14[50];
    v67 = v14[51];
    v447 = vcvt_hight_f32_f16(v66);
    v446 = vcvtq_f32_f16(*(float16x4_t *)v66.i8);
    v449 = vcvt_hight_f32_f16(v67);
    v448 = vcvtq_f32_f16(*(float16x4_t *)v67.i8);
    v68 = v14[52];
    v69 = v14[53];
    v451 = vcvt_hight_f32_f16(v68);
    v450 = vcvtq_f32_f16(*(float16x4_t *)v68.i8);
    v453 = vcvt_hight_f32_f16(v69);
    v452 = vcvtq_f32_f16(*(float16x4_t *)v69.i8);
    v70 = v14[54];
    v71 = v14[55];
    v455 = vcvt_hight_f32_f16(v70);
    v454 = vcvtq_f32_f16(*(float16x4_t *)v70.i8);
    v457 = vcvt_hight_f32_f16(v71);
    v456 = vcvtq_f32_f16(*(float16x4_t *)v71.i8);
    v72 = v14[56];
    v73 = v14[57];
    v459 = vcvt_hight_f32_f16(v72);
    v458 = vcvtq_f32_f16(*(float16x4_t *)v72.i8);
    v461 = vcvt_hight_f32_f16(v73);
    v460 = vcvtq_f32_f16(*(float16x4_t *)v73.i8);
    v74 = v14[58];
    v75 = v14[59];
    v463 = vcvt_hight_f32_f16(v74);
    v462 = vcvtq_f32_f16(*(float16x4_t *)v74.i8);
    v465 = vcvt_hight_f32_f16(v75);
    v464 = vcvtq_f32_f16(*(float16x4_t *)v75.i8);
    v76 = v14[60];
    v77 = v14[61];
    v467 = vcvt_hight_f32_f16(v76);
    v466 = vcvtq_f32_f16(*(float16x4_t *)v76.i8);
    v469 = vcvt_hight_f32_f16(v77);
    v468 = vcvtq_f32_f16(*(float16x4_t *)v77.i8);
    v78 = v14[62];
    v79 = v14[63];
    v471 = vcvt_hight_f32_f16(v78);
    v470 = vcvtq_f32_f16(*(float16x4_t *)v78.i8);
    v473 = vcvt_hight_f32_f16(v79);
    v472 = vcvtq_f32_f16(*(float16x4_t *)v79.i8);
    bzero(&__B, 0x800uLL);
    v80 = *(float16x8_t *)(v15 + 16);
    v81 = vcvt_hight_f32_f16(*(float16x8_t *)v15);
    __B = vcvtq_f32_f16(*(float16x4_t *)v15);
    v223 = v81;
    v224 = vcvtq_f32_f16(*(float16x4_t *)v80.i8);
    v225 = vcvt_hight_f32_f16(v80);
    v82 = *(float16x8_t *)(v15 + 32);
    v83 = *(float16x8_t *)(v15 + 48);
    v226 = vcvtq_f32_f16(*(float16x4_t *)v82.i8);
    v227 = vcvt_hight_f32_f16(v82);
    v229 = vcvt_hight_f32_f16(v83);
    v228 = vcvtq_f32_f16(*(float16x4_t *)v83.i8);
    v84 = *(float16x8_t *)(v15 + 64);
    v85 = *(float16x8_t *)(v15 + 80);
    v230 = vcvtq_f32_f16(*(float16x4_t *)v84.i8);
    v231 = vcvt_hight_f32_f16(v84);
    v232 = vcvtq_f32_f16(*(float16x4_t *)v85.i8);
    v233 = vcvt_hight_f32_f16(v85);
    v86 = *(float16x8_t *)(v15 + 96);
    v87 = *(float16x8_t *)(v15 + 112);
    v234 = vcvtq_f32_f16(*(float16x4_t *)v86.i8);
    v235 = vcvt_hight_f32_f16(v86);
    v236 = vcvtq_f32_f16(*(float16x4_t *)v87.i8);
    v237 = vcvt_hight_f32_f16(v87);
    v88 = *(float16x8_t *)(v15 + 128);
    v89 = *(float16x8_t *)(v15 + 144);
    v238 = vcvtq_f32_f16(*(float16x4_t *)v88.i8);
    v239 = vcvt_hight_f32_f16(v88);
    v240 = vcvtq_f32_f16(*(float16x4_t *)v89.i8);
    v241 = vcvt_hight_f32_f16(v89);
    v90 = *(float16x8_t *)(v15 + 160);
    v91 = *(float16x8_t *)(v15 + 176);
    v242 = vcvtq_f32_f16(*(float16x4_t *)v90.i8);
    v243 = vcvt_hight_f32_f16(v90);
    v244 = vcvtq_f32_f16(*(float16x4_t *)v91.i8);
    v245 = vcvt_hight_f32_f16(v91);
    v92 = *(float16x8_t *)(v15 + 192);
    v93 = *(float16x8_t *)(v15 + 208);
    v246 = vcvtq_f32_f16(*(float16x4_t *)v92.i8);
    v247 = vcvt_hight_f32_f16(v92);
    v248 = vcvtq_f32_f16(*(float16x4_t *)v93.i8);
    v249 = vcvt_hight_f32_f16(v93);
    v94 = *(float16x8_t *)(v15 + 224);
    v95 = *(float16x8_t *)(v15 + 240);
    v250 = vcvtq_f32_f16(*(float16x4_t *)v94.i8);
    v251 = vcvt_hight_f32_f16(v94);
    v252 = vcvtq_f32_f16(*(float16x4_t *)v95.i8);
    v253 = vcvt_hight_f32_f16(v95);
    v96 = *(float16x8_t *)(v15 + 256);
    v97 = *(float16x8_t *)(v15 + 272);
    v254 = vcvtq_f32_f16(*(float16x4_t *)v96.i8);
    v255 = vcvt_hight_f32_f16(v96);
    v256 = vcvtq_f32_f16(*(float16x4_t *)v97.i8);
    v257 = vcvt_hight_f32_f16(v97);
    v98 = *(float16x8_t *)(v15 + 288);
    v99 = *(float16x8_t *)(v15 + 304);
    v258 = vcvtq_f32_f16(*(float16x4_t *)v98.i8);
    v259 = vcvt_hight_f32_f16(v98);
    v260 = vcvtq_f32_f16(*(float16x4_t *)v99.i8);
    v261 = vcvt_hight_f32_f16(v99);
    v100 = *(float16x8_t *)(v15 + 320);
    v101 = *(float16x8_t *)(v15 + 336);
    v262 = vcvtq_f32_f16(*(float16x4_t *)v100.i8);
    v263 = vcvt_hight_f32_f16(v100);
    v264 = vcvtq_f32_f16(*(float16x4_t *)v101.i8);
    v265 = vcvt_hight_f32_f16(v101);
    v102 = *(float16x8_t *)(v15 + 352);
    v103 = *(float16x8_t *)(v15 + 368);
    v266 = vcvtq_f32_f16(*(float16x4_t *)v102.i8);
    v267 = vcvt_hight_f32_f16(v102);
    v268 = vcvtq_f32_f16(*(float16x4_t *)v103.i8);
    v269 = vcvt_hight_f32_f16(v103);
    v104 = *(float16x8_t *)(v15 + 384);
    v105 = *(float16x8_t *)(v15 + 400);
    v270 = vcvtq_f32_f16(*(float16x4_t *)v104.i8);
    v271 = vcvt_hight_f32_f16(v104);
    v272 = vcvtq_f32_f16(*(float16x4_t *)v105.i8);
    v273 = vcvt_hight_f32_f16(v105);
    v106 = *(float16x8_t *)(v15 + 416);
    v107 = *(float16x8_t *)(v15 + 432);
    v274 = vcvtq_f32_f16(*(float16x4_t *)v106.i8);
    v275 = vcvt_hight_f32_f16(v106);
    v276 = vcvtq_f32_f16(*(float16x4_t *)v107.i8);
    v277 = vcvt_hight_f32_f16(v107);
    v108 = *(float16x8_t *)(v15 + 448);
    v109 = *(float16x8_t *)(v15 + 464);
    v278 = vcvtq_f32_f16(*(float16x4_t *)v108.i8);
    v279 = vcvt_hight_f32_f16(v108);
    v280 = vcvtq_f32_f16(*(float16x4_t *)v109.i8);
    v281 = vcvt_hight_f32_f16(v109);
    v110 = *(float16x8_t *)(v15 + 480);
    v111 = *(float16x8_t *)(v15 + 496);
    v282 = vcvtq_f32_f16(*(float16x4_t *)v110.i8);
    v283 = vcvt_hight_f32_f16(v110);
    v284 = vcvtq_f32_f16(*(float16x4_t *)v111.i8);
    v285 = vcvt_hight_f32_f16(v111);
    v112 = *(float16x8_t *)(v15 + 512);
    v113 = *(float16x8_t *)(v15 + 528);
    v287 = vcvt_hight_f32_f16(v112);
    v286 = vcvtq_f32_f16(*(float16x4_t *)v112.i8);
    v289 = vcvt_hight_f32_f16(v113);
    v288 = vcvtq_f32_f16(*(float16x4_t *)v113.i8);
    v114 = *(float16x8_t *)(v15 + 544);
    v115 = *(float16x8_t *)(v15 + 560);
    v291 = vcvt_hight_f32_f16(v114);
    v290 = vcvtq_f32_f16(*(float16x4_t *)v114.i8);
    v293 = vcvt_hight_f32_f16(v115);
    v292 = vcvtq_f32_f16(*(float16x4_t *)v115.i8);
    v116 = *(float16x8_t *)(v15 + 576);
    v117 = *(float16x8_t *)(v15 + 592);
    v295 = vcvt_hight_f32_f16(v116);
    v294 = vcvtq_f32_f16(*(float16x4_t *)v116.i8);
    v297 = vcvt_hight_f32_f16(v117);
    v296 = vcvtq_f32_f16(*(float16x4_t *)v117.i8);
    v118 = *(float16x8_t *)(v15 + 608);
    v119 = *(float16x8_t *)(v15 + 624);
    v299 = vcvt_hight_f32_f16(v118);
    v298 = vcvtq_f32_f16(*(float16x4_t *)v118.i8);
    v301 = vcvt_hight_f32_f16(v119);
    v300 = vcvtq_f32_f16(*(float16x4_t *)v119.i8);
    v120 = *(float16x8_t *)(v15 + 640);
    v121 = *(float16x8_t *)(v15 + 656);
    v303 = vcvt_hight_f32_f16(v120);
    v302 = vcvtq_f32_f16(*(float16x4_t *)v120.i8);
    v305 = vcvt_hight_f32_f16(v121);
    v304 = vcvtq_f32_f16(*(float16x4_t *)v121.i8);
    v122 = *(float16x8_t *)(v15 + 672);
    v123 = *(float16x8_t *)(v15 + 688);
    v307 = vcvt_hight_f32_f16(v122);
    v306 = vcvtq_f32_f16(*(float16x4_t *)v122.i8);
    v309 = vcvt_hight_f32_f16(v123);
    v308 = vcvtq_f32_f16(*(float16x4_t *)v123.i8);
    v124 = *(float16x8_t *)(v15 + 704);
    v125 = *(float16x8_t *)(v15 + 720);
    v311 = vcvt_hight_f32_f16(v124);
    v310 = vcvtq_f32_f16(*(float16x4_t *)v124.i8);
    v313 = vcvt_hight_f32_f16(v125);
    v312 = vcvtq_f32_f16(*(float16x4_t *)v125.i8);
    v126 = *(float16x8_t *)(v15 + 736);
    v127 = *(float16x8_t *)(v15 + 752);
    v315 = vcvt_hight_f32_f16(v126);
    v314 = vcvtq_f32_f16(*(float16x4_t *)v126.i8);
    v317 = vcvt_hight_f32_f16(v127);
    v316 = vcvtq_f32_f16(*(float16x4_t *)v127.i8);
    v128 = *(float16x8_t *)(v15 + 768);
    v129 = *(float16x8_t *)(v15 + 784);
    v319 = vcvt_hight_f32_f16(v128);
    v318 = vcvtq_f32_f16(*(float16x4_t *)v128.i8);
    v321 = vcvt_hight_f32_f16(v129);
    v320 = vcvtq_f32_f16(*(float16x4_t *)v129.i8);
    v130 = *(float16x8_t *)(v15 + 800);
    v131 = *(float16x8_t *)(v15 + 816);
    v323 = vcvt_hight_f32_f16(v130);
    v322 = vcvtq_f32_f16(*(float16x4_t *)v130.i8);
    v325 = vcvt_hight_f32_f16(v131);
    v324 = vcvtq_f32_f16(*(float16x4_t *)v131.i8);
    v132 = *(float16x8_t *)(v15 + 832);
    v133 = *(float16x8_t *)(v15 + 848);
    v327 = vcvt_hight_f32_f16(v132);
    v326 = vcvtq_f32_f16(*(float16x4_t *)v132.i8);
    v329 = vcvt_hight_f32_f16(v133);
    v328 = vcvtq_f32_f16(*(float16x4_t *)v133.i8);
    v134 = *(float16x8_t *)(v15 + 864);
    v135 = *(float16x8_t *)(v15 + 880);
    v331 = vcvt_hight_f32_f16(v134);
    v330 = vcvtq_f32_f16(*(float16x4_t *)v134.i8);
    v333 = vcvt_hight_f32_f16(v135);
    v332 = vcvtq_f32_f16(*(float16x4_t *)v135.i8);
    v136 = *(float16x8_t *)(v15 + 896);
    v137 = *(float16x8_t *)(v15 + 912);
    v335 = vcvt_hight_f32_f16(v136);
    v334 = vcvtq_f32_f16(*(float16x4_t *)v136.i8);
    v337 = vcvt_hight_f32_f16(v137);
    v336 = vcvtq_f32_f16(*(float16x4_t *)v137.i8);
    v138 = *(float16x8_t *)(v15 + 928);
    v139 = *(float16x8_t *)(v15 + 944);
    v339 = vcvt_hight_f32_f16(v138);
    v338 = vcvtq_f32_f16(*(float16x4_t *)v138.i8);
    v341 = vcvt_hight_f32_f16(v139);
    v340 = vcvtq_f32_f16(*(float16x4_t *)v139.i8);
    v140 = *(float16x8_t *)(v15 + 960);
    v141 = *(float16x8_t *)(v15 + 976);
    v343 = vcvt_hight_f32_f16(v140);
    v342 = vcvtq_f32_f16(*(float16x4_t *)v140.i8);
    v345 = vcvt_hight_f32_f16(v141);
    v344 = vcvtq_f32_f16(*(float16x4_t *)v141.i8);
    v142 = *(float16x8_t *)(v15 + 992);
    v143 = *(float16x8_t *)(v15 + 1008);
    v347 = vcvt_hight_f32_f16(v142);
    v346 = vcvtq_f32_f16(*(float16x4_t *)v142.i8);
    v349 = vcvt_hight_f32_f16(v143);
    v348 = vcvtq_f32_f16(*(float16x4_t *)v143.i8);
    LODWORD(__C) = 2139095039;
    vDSP_distancesq((const float *)__A, 1, __B.f32, 1, (float *)&__C, 0x200uLL);
    v144 = *(float *)&__C;
    v145 = *__error();
    v146 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v146, OS_LOG_TYPE_ERROR))
    {
      v170 = *(_DWORD *)(v8 + 88);
      *(_DWORD *)__A = 136315906;
      *(_QWORD *)&__A[4] = "exists_block_invoke";
      *(_WORD *)&__A[12] = 1024;
      *(_DWORD *)&__A[14] = 2649;
      *(_WORD *)&__A[18] = 1024;
      *(_DWORD *)&__A[20] = v170;
      *(_WORD *)&__A[24] = 2048;
      *(double *)&__A[26] = v144;
      _os_log_error_impl(&dword_1B8270000, v146, OS_LOG_TYPE_ERROR, "%s:%d: Vec distance to centroid %u distsq=%e", __A, 0x22u);
    }
    *__error() = v145;
    __B = 0uLL;
    v223.i64[0] = 0;
    (*(void (**)(float32x4_t *__return_ptr, _QWORD, _QWORD, uint64_t))(**(_QWORD **)(v8 + 56) + 72))(&__B, *(_QWORD *)(v8 + 56), *(_QWORD *)(v8 + 48), 2);
    v147 = *__error();
    v148 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v148, OS_LOG_TYPE_ERROR))
    {
      v171 = *(_DWORD *)__B.i64[0];
      v172 = *(float *)(__B.i64[0] + 4);
      v173 = *(_DWORD *)(__B.i64[0] + 8);
      v174 = *(float *)(__B.i64[0] + 12);
      v175 = v172 == v174 || vabds_f32(v172, v174) <= fmaxf(fminf(fabsf(v174), fabsf(v172)) * 0.000015259, 0.000015259);
      *(_DWORD *)__A = 136316674;
      *(_QWORD *)&__A[4] = "exists_block_invoke";
      *(_WORD *)&__A[12] = 1024;
      *(_DWORD *)&__A[14] = 2651;
      *(_WORD *)&__A[18] = 1024;
      *(_DWORD *)&__A[20] = v171;
      *(_WORD *)&__A[24] = 2048;
      *(double *)&__A[26] = v172;
      *(_WORD *)&__A[34] = 1024;
      *(_DWORD *)&__A[36] = v173;
      *(_WORD *)&__A[40] = 2048;
      *(double *)&__A[42] = v174;
      *(_WORD *)&__A[50] = 1024;
      *(_DWORD *)&__A[52] = v175;
      _os_log_error_impl(&dword_1B8270000, v148, OS_LOG_TYPE_ERROR, "%s:%d: topKPartition(vec, 2) <%u, %e>, <%u, %e>, %d", __A, 0x38u);
    }
    *__error() = v147;
    v149 = *__error();
    v150 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v150, OS_LOG_TYPE_ERROR))
    {
      v176 = *(_DWORD *)__B.i64[0];
      v177 = *(_DWORD *)(__B.i64[0] + 8);
      v178 = *(float *)(__B.i64[0] + 4) == *(float *)(__B.i64[0] + 12);
      *(_DWORD *)__A = 136316162;
      *(_QWORD *)&__A[4] = "exists_block_invoke";
      *(_WORD *)&__A[12] = 1024;
      *(_DWORD *)&__A[14] = 2652;
      *(_WORD *)&__A[18] = 1024;
      *(_DWORD *)&__A[20] = v176;
      *(_WORD *)&__A[24] = 1024;
      *(_DWORD *)&__A[26] = v177;
      *(_WORD *)&__A[30] = 1024;
      *(_DWORD *)&__A[32] = v178;
      _os_log_error_impl(&dword_1B8270000, v150, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) == distsq(%u) is %d", __A, 0x24u);
    }
    *__error() = v149;
    v151 = *__error();
    v152 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v152, OS_LOG_TYPE_ERROR))
    {
      v179 = *(_DWORD *)__B.i64[0];
      v180 = *(_DWORD *)(__B.i64[0] + 8);
      v181 = *(float *)(__B.i64[0] + 4) < *(float *)(__B.i64[0] + 12);
      *(_DWORD *)__A = 136316162;
      *(_QWORD *)&__A[4] = "exists_block_invoke";
      *(_WORD *)&__A[12] = 1024;
      *(_DWORD *)&__A[14] = 2653;
      *(_WORD *)&__A[18] = 1024;
      *(_DWORD *)&__A[20] = v179;
      *(_WORD *)&__A[24] = 1024;
      *(_DWORD *)&__A[26] = v180;
      *(_WORD *)&__A[30] = 1024;
      *(_DWORD *)&__A[32] = v181;
      _os_log_error_impl(&dword_1B8270000, v152, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) < distsq(%u) is %d", __A, 0x24u);
    }
    *__error() = v151;
    v153 = *__error();
    v154 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v154, OS_LOG_TYPE_ERROR))
    {
      v182 = *(_DWORD *)__B.i64[0];
      v183 = *(_DWORD *)(__B.i64[0] + 8);
      v184 = *(float *)(__B.i64[0] + 4) > *(float *)(__B.i64[0] + 12);
      *(_DWORD *)__A = 136316162;
      *(_QWORD *)&__A[4] = "exists_block_invoke";
      *(_WORD *)&__A[12] = 1024;
      *(_DWORD *)&__A[14] = 2654;
      *(_WORD *)&__A[18] = 1024;
      *(_DWORD *)&__A[20] = v182;
      *(_WORD *)&__A[24] = 1024;
      *(_DWORD *)&__A[26] = v183;
      *(_WORD *)&__A[30] = 1024;
      *(_DWORD *)&__A[32] = v184;
      _os_log_error_impl(&dword_1B8270000, v154, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) > distsq(%u) is %d", __A, 0x24u);
    }
    *__error() = v153;
    v155 = *__error();
    v156 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v156, OS_LOG_TYPE_ERROR))
    {
      v185 = *(_DWORD *)__B.i64[0];
      v186 = *(_DWORD *)(__B.i64[0] + 8);
      v187 = *(float *)(__B.i64[0] + 4);
      v188 = *(float *)(__B.i64[0] + 12);
      v189 = (float)(v187 - v188);
      v190 = vabds_f32(v187, v188);
      if (v187 == v188)
      {
        v191 = 1;
        v192 = 1;
      }
      else
      {
        v215 = fabsf(v187);
        v216 = fabsf(v188);
        v191 = v190 <= fmaxf(fminf(v216, v215) * 0.000015259, 0.000015259);
        v192 = v190 <= (float)(fmaxf(v215, v216) * 0.000015259);
      }
      *(_DWORD *)__A = 136317698;
      *(_QWORD *)&__A[4] = "exists_block_invoke";
      *(_WORD *)&__A[12] = 1024;
      *(_DWORD *)&__A[14] = 2655;
      *(_WORD *)&__A[18] = 1024;
      *(_DWORD *)&__A[20] = v185;
      *(_WORD *)&__A[24] = 1024;
      *(_DWORD *)&__A[26] = v186;
      *(_WORD *)&__A[30] = 2048;
      *(double *)&__A[32] = v189;
      *(_WORD *)&__A[40] = 2048;
      *(_QWORD *)&__A[42] = 0x3810000000000000;
      *(_WORD *)&__A[50] = 2048;
      *(_QWORD *)&__A[52] = 0x3E80000000000000;
      *(_WORD *)&__A[60] = 1024;
      *(_DWORD *)&__A[62] = v190 < 1.1755e-38;
      *(_WORD *)&__A[66] = 1024;
      *(_DWORD *)&__A[68] = v190 < 0.00000011921;
      *(_WORD *)&__A[72] = 1024;
      *(_DWORD *)&__A[74] = v191;
      *(_WORD *)&__A[78] = 1024;
      v351.i32[0] = v192;
      _os_log_error_impl(&dword_1B8270000, v156, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) - distsq(%u) = %e, FLT_MIN=%e, EPSILON=%e, %d, %d, %d, %d", __A, 0x54u);
    }
    *__error() = v155;
    v220 = 0;
    v221 = 0;
    __C = 0;
    v157 = *(_QWORD *)(v8 + 56);
    v158 = vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(*(_QWORD *)(v10 + 32) + 16), *(unsigned int *)v5, 1044);
    (*(void (**)(float **__return_ptr, uint64_t, unint64_t, uint64_t))(*(_QWORD *)v157 + 72))(&__C, v157, v158, 2);
    v159 = *__error();
    v160 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v160, OS_LOG_TYPE_ERROR))
    {
      v193 = *__C;
      v194 = __C[1];
      v195 = *((_DWORD *)__C + 2);
      v196 = __C[3];
      v197 = v194 == v196 || vabds_f32(v194, v196) <= fmaxf(fminf(fabsf(v196), fabsf(v194)) * 0.000015259, 0.000015259);
      *(_DWORD *)__A = 136316674;
      *(_QWORD *)&__A[4] = "exists_block_invoke";
      *(_WORD *)&__A[12] = 1024;
      *(_DWORD *)&__A[14] = 2658;
      *(_WORD *)&__A[18] = 1024;
      *(float *)&__A[20] = v193;
      *(_WORD *)&__A[24] = 2048;
      *(double *)&__A[26] = v194;
      *(_WORD *)&__A[34] = 1024;
      *(_DWORD *)&__A[36] = v195;
      *(_WORD *)&__A[40] = 2048;
      *(double *)&__A[42] = v196;
      *(_WORD *)&__A[50] = 1024;
      *(_DWORD *)&__A[52] = v197;
      _os_log_error_impl(&dword_1B8270000, v160, OS_LOG_TYPE_ERROR, "%s:%d: topKPartition(entry->vec, 2) <%u, %e>, <%u, %e>, %d", __A, 0x38u);
    }
    *__error() = v159;
    v161 = *__error();
    v162 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v162, OS_LOG_TYPE_ERROR))
    {
      v198 = *__C;
      v199 = *((_DWORD *)__C + 2);
      v200 = __C[1] == __C[3];
      *(_DWORD *)__A = 136316162;
      *(_QWORD *)&__A[4] = "exists_block_invoke";
      *(_WORD *)&__A[12] = 1024;
      *(_DWORD *)&__A[14] = 2659;
      *(_WORD *)&__A[18] = 1024;
      *(float *)&__A[20] = v198;
      *(_WORD *)&__A[24] = 1024;
      *(_DWORD *)&__A[26] = v199;
      *(_WORD *)&__A[30] = 1024;
      *(_DWORD *)&__A[32] = v200;
      _os_log_error_impl(&dword_1B8270000, v162, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) == distsq(%u) is %d", __A, 0x24u);
    }
    *__error() = v161;
    v163 = *__error();
    v164 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v164, OS_LOG_TYPE_ERROR))
    {
      v201 = *__C;
      v202 = *((_DWORD *)__C + 2);
      v203 = __C[1] < __C[3];
      *(_DWORD *)__A = 136316162;
      *(_QWORD *)&__A[4] = "exists_block_invoke";
      *(_WORD *)&__A[12] = 1024;
      *(_DWORD *)&__A[14] = 2660;
      *(_WORD *)&__A[18] = 1024;
      *(float *)&__A[20] = v201;
      *(_WORD *)&__A[24] = 1024;
      *(_DWORD *)&__A[26] = v202;
      *(_WORD *)&__A[30] = 1024;
      *(_DWORD *)&__A[32] = v203;
      _os_log_error_impl(&dword_1B8270000, v164, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) < distsq(%u) is %d", __A, 0x24u);
    }
    *__error() = v163;
    v165 = *__error();
    v166 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v166, OS_LOG_TYPE_ERROR))
    {
      v204 = *__C;
      v205 = *((_DWORD *)__C + 2);
      v206 = __C[1] > __C[3];
      *(_DWORD *)__A = 136316162;
      *(_QWORD *)&__A[4] = "exists_block_invoke";
      *(_WORD *)&__A[12] = 1024;
      *(_DWORD *)&__A[14] = 2661;
      *(_WORD *)&__A[18] = 1024;
      *(float *)&__A[20] = v204;
      *(_WORD *)&__A[24] = 1024;
      *(_DWORD *)&__A[26] = v205;
      *(_WORD *)&__A[30] = 1024;
      *(_DWORD *)&__A[32] = v206;
      _os_log_error_impl(&dword_1B8270000, v166, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) > distsq(%u) is %d", __A, 0x24u);
    }
    *__error() = v165;
    v167 = *__error();
    v168 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v168, OS_LOG_TYPE_ERROR))
    {
      v207 = *__C;
      v208 = *((_DWORD *)__C + 2);
      v209 = __C[1];
      v210 = __C[3];
      v211 = vabds_f32(v209, v210);
      v212 = (float)(v209 - v210) < 1.1755e-38;
      if (v209 == v210)
      {
        v213 = 1;
        v214 = 1;
      }
      else
      {
        v217 = fabsf(v209);
        v218 = fabsf(v210);
        v213 = v211 <= fmaxf(fminf(v218, v217) * 0.000015259, 0.000015259);
        v214 = v211 <= (float)(fmaxf(v217, v218) * 0.000015259);
      }
      *(_DWORD *)__A = 136317698;
      *(_QWORD *)&__A[4] = "exists_block_invoke";
      *(_WORD *)&__A[12] = 1024;
      *(_DWORD *)&__A[14] = 2662;
      *(_WORD *)&__A[18] = 1024;
      *(float *)&__A[20] = v207;
      *(_WORD *)&__A[24] = 1024;
      *(_DWORD *)&__A[26] = v208;
      *(_WORD *)&__A[30] = 2048;
      *(double *)&__A[32] = v211;
      *(_WORD *)&__A[40] = 2048;
      *(_QWORD *)&__A[42] = 0x3810000000000000;
      *(_WORD *)&__A[50] = 2048;
      *(_QWORD *)&__A[52] = 0x3E80000000000000;
      *(_WORD *)&__A[60] = 1024;
      *(_DWORD *)&__A[62] = v212;
      *(_WORD *)&__A[66] = 1024;
      *(_DWORD *)&__A[68] = v211 < 0.00000011921;
      *(_WORD *)&__A[72] = 1024;
      *(_DWORD *)&__A[74] = v213;
      *(_WORD *)&__A[78] = 1024;
      v351.i32[0] = v214;
      _os_log_error_impl(&dword_1B8270000, v168, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) - distsq(%u) = %e, FLT_MIN=%e, EPSILON=%e, %d, %d, %d, %d", __A, 0x54u);
    }
    *__error() = v167;
    *(float *)(*(_QWORD *)(*(_QWORD *)(v8 + 32) + 8) + 24) = *v5;
    *v3 = 1;
    if (__C)
    {
      v220 = __C;
      operator delete(__C);
    }
    if (__B.i64[0])
    {
      __B.i64[1] = __B.i64[0];
      operator delete((void *)__B.i64[0]);
    }
  }
}

void _ZNSt3__120__shared_ptr_emplaceIN22IVFVectorIndexTemplateIDF16_Li256EE11VectorStoreI32vi_onefixedsize_memory_allocator18vi_memory_postingsEENS_9allocatorIS6_EEED1Ev(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6E30E20;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void _ZNSt3__120__shared_ptr_emplaceIN22IVFVectorIndexTemplateIDF16_Li256EE11VectorStoreI32vi_onefixedsize_memory_allocator18vi_memory_postingsEENS_9allocatorIS6_EEED0Ev(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6E30E20;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BCCB06A4);
}

void _ZNSt3__120__shared_ptr_emplaceIN22IVFVectorIndexTemplateIDF16_Li256EE11VectorStoreI32vi_onefixedsize_memory_allocator18vi_memory_postingsEENS_9allocatorIS6_EEE16__on_zero_sharedEv(uint64_t a1)
{
  uint64_t v2;

  if (*(char *)(a1 + 87) < 0)
    operator delete(*(void **)(a1 + 64));
  v2 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 40) = 0;
  if (v2)
  {
    malloc_zone_free(*(malloc_zone_t **)v2, *(void **)(v2 + 8));
    JUMPOUT(0x1BCCB06A4);
  }
}

void _ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsED0Ev(_QWORD *a1)
{
  _ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsED2Ev(a1);
  JUMPOUT(0x1BCCB06A4);
}

void _ZNK22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE12getQuantizerEv(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  os_unfair_lock_s *v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;

  v4 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  v6 = *(_QWORD *)(a1 + 64);
  v5 = *(std::__shared_weak_count **)(a1 + 72);
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }
  v9 = *(std::__shared_weak_count **)(a1 + 88);
  if (v9)
  {
    v10 = (unint64_t *)&v9->__shared_owners_;
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }
  os_unfair_lock_unlock(v4);
  *a2 = v6;
  a2[1] = v5;
  if (v5)
  {
    v12 = (unint64_t *)&v5->__shared_owners_;
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  if (!v9)
    goto LABEL_14;
  v14 = (unint64_t *)&v9->__shared_owners_;
  do
    v15 = __ldaxr(v14);
  while (__stlxr(v15 - 1, v14));
  if (!v15)
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
    if (!v5)
      return;
  }
  else
  {
LABEL_14:
    if (!v5)
      return;
  }
  v16 = (unint64_t *)&v5->__shared_owners_;
  do
    v17 = __ldaxr(v16);
  while (__stlxr(v17 - 1, v16));
  if (!v17)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
}

void _ZNK22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE13getPartitionsEv(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  os_unfair_lock_s *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;

  v4 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  v5 = *(std::__shared_weak_count **)(a1 + 72);
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  v9 = *(_QWORD *)(a1 + 80);
  v8 = *(std::__shared_weak_count **)(a1 + 88);
  if (!v8)
  {
    os_unfair_lock_unlock(v4);
    *a2 = v9;
    a2[1] = 0;
    if (!v5)
      return;
    goto LABEL_15;
  }
  v10 = (unint64_t *)&v8->__shared_owners_;
  do
    v11 = __ldxr(v10);
  while (__stxr(v11 + 1, v10));
  os_unfair_lock_unlock(v4);
  *a2 = v9;
  a2[1] = v8;
  do
    v12 = __ldxr(v10);
  while (__stxr(v12 + 1, v10));
  do
    v13 = __ldaxr(v10);
  while (__stlxr(v13 - 1, v10));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
  if (v5)
  {
LABEL_15:
    v14 = (unint64_t *)&v5->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
}

unint64_t _ZNK22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE17getVectorAtOffsetEj(uint64_t a1, unsigned int a2)
{
  return vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(*(_QWORD *)(a1 + 32) + 16), a2, 532);
}

void _ZNK22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE13newPartitionsENSt3__110shared_ptrI9QuantizerIDF16_Li256EEEE(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  os_unfair_lock_s *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  const char *v14;
  size_t v15;
  void *v16;
  void **v17;
  uint64_t v18;
  uint64_t v19;
  malloc_zone_t *v20;
  uint64_t v21;
  _DWORD *v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  unint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  unint64_t v29;
  void *v30;
  unint64_t Ptr;
  int v32;
  int v33;
  NSObject *v34;
  void **v35;
  int v36;
  int v37;
  char *v38;
  _QWORD *v39;
  int v40;
  unint64_t *v41;
  unint64_t v42;
  unint64_t *v43;
  unint64_t v44;
  char *v45;
  char *v46;
  const char *v47;
  void *v48[2];
  char v49;
  void *__dst[2];
  unint64_t v51;
  void *__p[3];
  __int16 v53;
  _QWORD *v54;
  __int16 v55;
  int v56;
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  v6 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  v7 = *(std::__shared_weak_count **)(a1 + 72);
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }
  v11 = *(_QWORD *)(a1 + 80);
  v10 = *(std::__shared_weak_count **)(a1 + 88);
  if (v10)
  {
    v12 = (unint64_t *)&v10->__shared_owners_;
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  os_unfair_lock_unlock(v6);
  v14 = ".partitions";
  if (v11 && (*(unsigned int (**)(uint64_t))(*(_QWORD *)v11 + 24))(v11))
    v14 = ".tmp.partitions";
  v15 = strlen(v14);
  if (v15 >= 0x7FFFFFFFFFFFFFF8)
LABEL_60:
    abort();
  v16 = (void *)v15;
  if (v15 >= 0x17)
  {
    v18 = (v15 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v15 | 7) != 0x17)
      v18 = v15 | 7;
    v19 = v18 + 1;
    v17 = (void **)operator new(v18 + 1);
    __dst[1] = v16;
    v51 = v19 | 0x8000000000000000;
    __dst[0] = v17;
    goto LABEL_17;
  }
  HIBYTE(v51) = v15;
  v17 = __dst;
  if (v15)
LABEL_17:
    memcpy(v17, v14, (size_t)v16);
  *((_BYTE *)v16 + (_QWORD)v17) = 0;
  v20 = malloc_default_zone();
  if (SHIBYTE(v51) < 0)
    operator delete(__dst[0]);
  v21 = operator new();
  v22 = (_DWORD *)v21;
  v23 = *(std::__shared_weak_count **)(a2 + 8);
  __p[0] = *(void **)a2;
  __p[1] = v23;
  if (v23)
  {
    v24 = (unint64_t *)&v23->__shared_owners_;
    do
      v25 = __ldxr(v24);
    while (__stxr(v25 + 1, v24));
    PartitionStore<vi_onefixedsize_memory_allocator,512>::PartitionStore<vi_onefixedsize_memory_allocator>(v21, v20, 0, __p);
    do
      v26 = __ldaxr(v24);
    while (__stlxr(v26 - 1, v24));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
  else
  {
    PartitionStore<vi_onefixedsize_memory_allocator,512>::PartitionStore<vi_onefixedsize_memory_allocator>(v21, v20, 0, __p);
  }
  *a3 = v22;
  v27 = (_QWORD *)operator new();
  *v27 = &off_1E6E31210;
  v27[1] = 0;
  v27[2] = 0;
  v27[3] = v22;
  a3[1] = v27;
  v28 = *(_QWORD *)(a1 + 32);
  if (*(_DWORD *)(v28 + 24))
  {
    v29 = 0;
    do
    {
      memset(__p, 0, sizeof(__p));
      v30 = *(void **)a2;
      Ptr = vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(v28 + 16), v29, 532);
      (*(void (**)(void **__return_ptr, void *, unint64_t, uint64_t))(*(_QWORD *)v30 + 72))(__p, v30, Ptr, 1);
      (*(void (**)(_DWORD *, _QWORD, unint64_t, float))(*(_QWORD *)v22 + 56))(v22, *(unsigned int *)__p[0], v29, *((float *)__p[0] + 1));
      if (__p[0])
      {
        __p[1] = __p[0];
        operator delete(__p[0]);
      }
      ++v29;
      v28 = *(_QWORD *)(a1 + 32);
    }
    while (v29 < *(unsigned int *)(v28 + 24));
  }
  (*(void (**)(_DWORD *, _QWORD))(*(_QWORD *)v22 + 112))(v22, 0);
  v32 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 24);
  if (v32)
  {
    v33 = *__error();
    v34 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
    {
      (*(void (**)(void **__return_ptr, _DWORD *))(*(_QWORD *)v22 + 144))(v48, v22);
      if (v49 >= 0)
        v35 = v48;
      else
        v35 = (void **)v48[0];
      v36 = v22[17];
      v37 = v22[18];
      v38 = *(char **)a2;
      v39 = (_QWORD *)(*(_QWORD *)a2 + 8);
      if (v38[31] < 0)
        v39 = (_QWORD *)*v39;
      v40 = (*(uint64_t (**)(char *))(*(_QWORD *)v38 + 16))(v38);
      LODWORD(__p[0]) = 136316162;
      *(void **)((char *)__p + 4) = v35;
      WORD2(__p[1]) = 1024;
      *(_DWORD *)((char *)&__p[1] + 6) = v37;
      WORD1(__p[2]) = 1024;
      HIDWORD(__p[2]) = v36;
      v53 = 2080;
      v54 = v39;
      v55 = 1024;
      v56 = v40;
      _os_log_impl(&dword_1B8270000, v34, OS_LOG_TYPE_DEFAULT, "Create new partitions %s(%u/%u) for new quantizer %s(%u)", (uint8_t *)__p, 0x28u);
      if (v49 < 0)
        operator delete(v48[0]);
    }
    *__error() = v33;
    v32 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 24);
  }
  if (v22[18] != v32)
  {
    v45 = __si_assert_copy_extra_268();
    v46 = v45;
    v47 = "";
    if (v45)
      v47 = v45;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2363, "newPartitions->nVectors() == vectors->count()", v47);
    free(v46);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    goto LABEL_60;
  }
  if (v10)
  {
    v41 = (unint64_t *)&v10->__shared_owners_;
    do
      v42 = __ldaxr(v41);
    while (__stlxr(v42 - 1, v41));
    if (!v42)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  if (v7)
  {
    v43 = (unint64_t *)&v7->__shared_owners_;
    do
      v44 = __ldaxr(v43);
    while (__stlxr(v44 - 1, v43));
    if (!v44)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
}

void _ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE16replaceQuantizerENSt3__110shared_ptrI9QuantizerIDF16_Li256EEEENS6_I17AnyPartitionStoreEE(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  os_unfair_lock_s *v6;
  os_unfair_lock_s *v7;
  std::__shared_weak_count *v8;
  __int128 *v9;
  char *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  std::__shared_weak_count *v13;
  _DWORD *v14;
  unint64_t *v15;
  unint64_t v16;
  int v17;
  _DWORD *v18;
  NSObject *v19;
  _QWORD *v20;
  int v21;
  _QWORD *v22;
  void **v23;
  int v24;
  void **v25;
  int v26;
  int v27;
  BOOL v28;
  uint64_t v29;
  unint64_t *v30;
  unint64_t v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  unint64_t v37;
  std::__shared_weak_count *v38;
  unint64_t *v39;
  unint64_t v40;
  unint64_t *v41;
  unint64_t v42;
  unint64_t *v43;
  unint64_t v44;
  char *v45;
  char *v46;
  const char *v47;
  char *v48;
  const char *v49;
  _QWORD *v50;
  _QWORD *v51;
  int v52;
  int v53;
  int v54;
  os_unfair_lock_s *v55;
  int v56;
  __int128 v57;
  uint64_t v58;
  std::__shared_weak_count *v59;
  void *__p[2];
  char v61;
  void *v62[2];
  char v63;
  uint8_t buf[4];
  _QWORD *v65;
  __int16 v66;
  int v67;
  __int16 v68;
  _QWORD *v69;
  __int16 v70;
  int v71;
  __int16 v72;
  void **v73;
  __int16 v74;
  int v75;
  __int16 v76;
  int v77;
  __int16 v78;
  void **v79;
  __int16 v80;
  int v81;
  __int16 v82;
  int v83;
  uint64_t v84;

  v84 = *MEMORY[0x1E0C80C00];
  v6 = (os_unfair_lock_s *)(a1 + 136);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 136));
  v7 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  v10 = *(char **)(a1 + 64);
  v8 = *(std::__shared_weak_count **)(a1 + 72);
  v9 = (__int128 *)(a1 + 64);
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }
  v14 = *(_DWORD **)(a1 + 80);
  v13 = *(std::__shared_weak_count **)(a1 + 88);
  if (v13)
  {
    v15 = (unint64_t *)&v13->__shared_owners_;
    do
      v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
  v17 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a2 + 24))(*a2);
  v18 = (_DWORD *)*a3;
  if (v17 != *(_DWORD *)(*a3 + 68))
  {
    v45 = __si_assert_copy_extra_268();
    v46 = v45;
    v47 = "";
    if (v45)
      v47 = v45;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2381, "newQuantizer->count() == newPartitions->nPartitions()", v47);
LABEL_64:
    free(v46);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  if (*(_DWORD *)(*(_QWORD *)(a1 + 32) + 24) != v18[18])
  {
    v48 = __si_assert_copy_extra_268();
    v46 = v48;
    v49 = "";
    if (v48)
      v49 = v48;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2382, "vectors->count() == newPartitions->nVectors()", v49);
    goto LABEL_64;
  }
  if (v10 && v14)
  {
    v56 = *__error();
    v19 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      v20 = v10 + 8;
      if (v10[31] < 0)
        v20 = (_QWORD *)*v20;
      v51 = v20;
      v21 = (*(uint64_t (**)(char *))(*(_QWORD *)v10 + 16))(v10);
      v22 = (_QWORD *)(*a2 + 8);
      v55 = v6;
      v54 = v21;
      if (*(char *)(*a2 + 31) < 0)
        v22 = (_QWORD *)*v22;
      v50 = v22;
      v53 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a2 + 16))(*a2);
      v23 = v62;
      (*(void (**)(void **__return_ptr, _DWORD *))(*(_QWORD *)v14 + 144))(v62, v14);
      if (v63 < 0)
        v23 = (void **)v62[0];
      v24 = v14[18];
      v52 = v14[17];
      (*(void (**)(void **__return_ptr))(*(_QWORD *)*a3 + 144))(__p);
      v25 = __p;
      if (v61 < 0)
        v25 = (void **)__p[0];
      v26 = *(_DWORD *)(*a3 + 68);
      v27 = *(_DWORD *)(*a3 + 72);
      *(_DWORD *)buf = 136317442;
      v65 = v51;
      v66 = 1024;
      v67 = v54;
      v68 = 2080;
      v69 = v50;
      v70 = 1024;
      v71 = v53;
      v72 = 2080;
      v73 = v23;
      v74 = 1024;
      v75 = v24;
      v76 = 1024;
      v77 = v52;
      v78 = 2080;
      v79 = v25;
      v80 = 1024;
      v81 = v27;
      v82 = 1024;
      v83 = v26;
      _os_log_impl(&dword_1B8270000, v19, OS_LOG_TYPE_DEFAULT, "Replace quantizer %s(%u) -> %s(%u), partitions %s(%u/%u) -> %s(%u/%u)", buf, 0x4Eu);
      if (v61 < 0)
        operator delete(__p[0]);
      v6 = v55;
      if (v63 < 0)
        operator delete(v62[0]);
    }
    *__error() = v56;
    v18 = (_DWORD *)*a3;
  }
  if ((*(unsigned int (**)(_DWORD *))(*(_QWORD *)v18 + 24))(v18))
    v28 = v14 == 0;
  else
    v28 = 1;
  if (!v28 && (*(unsigned int (**)(_DWORD *))(*(_QWORD *)v14 + 24))(v14))
    (*(void (**)(_QWORD, _DWORD *))(*(_QWORD *)*a3 + 168))(*a3, v14);
  v29 = a2[1];
  *(_QWORD *)&v57 = *a2;
  *((_QWORD *)&v57 + 1) = v29;
  if (v29)
  {
    v30 = (unint64_t *)(v29 + 8);
    do
      v31 = __ldxr(v30);
    while (__stxr(v31 + 1, v30));
  }
  v32 = (std::__shared_weak_count *)a3[1];
  v58 = *a3;
  v59 = v32;
  if (v32)
  {
    v33 = (unint64_t *)&v32->__shared_owners_;
    do
      v34 = __ldxr(v33);
    while (__stxr(v34 + 1, v33));
  }
  os_unfair_lock_lock(v7);
  std::swap[abi:nn180100]<IVFVectorIndexTemplate<float,768>::QuantizerPartitions>(v9, &v57);
  os_unfair_lock_unlock(v7);
  v35 = v59;
  if (v59)
  {
    v36 = (unint64_t *)&v59->__shared_owners_;
    do
      v37 = __ldaxr(v36);
    while (__stlxr(v37 - 1, v36));
    if (!v37)
    {
      ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
      std::__shared_weak_count::__release_weak(v35);
    }
  }
  v38 = (std::__shared_weak_count *)*((_QWORD *)&v57 + 1);
  if (*((_QWORD *)&v57 + 1))
  {
    v39 = (unint64_t *)(*((_QWORD *)&v57 + 1) + 8);
    do
      v40 = __ldaxr(v39);
    while (__stlxr(v40 - 1, v39));
    if (!v40)
    {
      ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
      std::__shared_weak_count::__release_weak(v38);
    }
  }
  os_unfair_lock_unlock(v6);
  if (v13)
  {
    v41 = (unint64_t *)&v13->__shared_owners_;
    do
      v42 = __ldaxr(v41);
    while (__stlxr(v42 - 1, v41));
    if (!v42)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  if (v8)
  {
    v43 = (unint64_t *)&v8->__shared_owners_;
    do
      v44 = __ldaxr(v43);
    while (__stlxr(v44 - 1, v43));
    if (!v44)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
}

_QWORD *_ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsED2Ev(_QWORD *a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;

  *a1 = &off_1E6E30DD8;
  v2 = (std::__shared_weak_count *)a1[11];
  if (!v2)
    goto LABEL_5;
  p_shared_owners = (unint64_t *)&v2->__shared_owners_;
  do
    v4 = __ldaxr(p_shared_owners);
  while (__stlxr(v4 - 1, p_shared_owners));
  if (!v4)
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    v5 = (std::__shared_weak_count *)a1[9];
    if (!v5)
      goto LABEL_11;
  }
  else
  {
LABEL_5:
    v5 = (std::__shared_weak_count *)a1[9];
    if (!v5)
      goto LABEL_11;
  }
  v6 = (unint64_t *)&v5->__shared_owners_;
  do
    v7 = __ldaxr(v6);
  while (__stlxr(v7 - 1, v6));
  if (!v7)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
LABEL_11:
  v8 = (std::__shared_weak_count *)a1[7];
  if (!v8)
    goto LABEL_15;
  v9 = (unint64_t *)&v8->__shared_owners_;
  do
    v10 = __ldaxr(v9);
  while (__stlxr(v10 - 1, v9));
  if (!v10)
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
    v11 = (std::__shared_weak_count *)a1[5];
    if (!v11)
      return a1;
  }
  else
  {
LABEL_15:
    v11 = (std::__shared_weak_count *)a1[5];
    if (!v11)
      return a1;
  }
  v12 = (unint64_t *)&v11->__shared_owners_;
  do
    v13 = __ldaxr(v12);
  while (__stlxr(v13 - 1, v12));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  return a1;
}

uint64_t _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EED1Ev(uint64_t a1)
{
  *(_QWORD *)a1 = off_1E6E30B28;
  _ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsED2Ev((_QWORD *)(a1 + 48));
  *(_QWORD *)a1 = off_1E6E30C80;
  if (*(char *)(a1 + 47) < 0)
    operator delete(*(void **)(a1 + 24));
  return a1;
}

void _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EED0Ev(uint64_t a1)
{
  *(_QWORD *)a1 = off_1E6E30B28;
  _ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsED2Ev((_QWORD *)(a1 + 48));
  *(_QWORD *)a1 = off_1E6E30C80;
  if (*(char *)(a1 + 47) < 0)
    operator delete(*(void **)(a1 + 24));
  JUMPOUT(0x1BCCB06A4);
}

uint64_t _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE8nVectorsEv(uint64_t a1)
{
  return IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nVectors(a1 + 48);
}

uint64_t _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE11nPartitionsEv(uint64_t a1)
{
  return IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nPartitions(a1 + 48);
}

uint64_t _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE8allExistEPKvj(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  float v9;
  uint64_t v10;
  int v11;
  NSObject *v12;
  char *v14;
  char *v15;
  const char *v16;
  uint8_t buf[4];
  double v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if ((_DWORD)a3)
  {
    v5 = a1 + 48;
    v6 = a3;
    if (a3 <= 0x3E8)
    {
      while (_ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE6existsERK10CIVector_sIDF16_Li256EE(v5, a2))
      {
        a2 += 512;
        if (!--v6)
          return a3;
      }
    }
    else
    {
      v7 = 0;
      v8 = a3 / 0xA;
      v9 = 1.0 / (float)a3;
      while (1)
      {
        v10 = v7 + 1;
        if (!(((int)v7 + 1) % v8))
        {
          v11 = *__error();
          v12 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 134217984;
            v18 = (float)((float)((float)v7 * 100.0) * v9);
            _os_log_impl(&dword_1B8270000, v12, OS_LOG_TYPE_DEFAULT, "allExist: %.0f%%", buf, 0xCu);
          }
          *__error() = v11;
        }
        if (!_ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE6existsERK10CIVector_sIDF16_Li256EE(v5, a2))break;
        a2 += 512;
        ++v7;
        if (a3 == v10)
          return a3;
      }
    }
    v14 = __si_assert_copy_extra_268();
    v15 = v14;
    v16 = "";
    if (v14)
      v16 = v14;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3151, "false", v16);
    free(v15);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  return a3;
}

uint64_t _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE12validAddressEPKv()
{
  return 1;
}

uint64_t _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE6shadowEbPVi(uint64_t a1, uint64_t a2, uint64_t a3)
{
  os_unfair_lock_s *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t *v15;
  unint64_t v16;

  v6 = (os_unfair_lock_s *)(a1 + 144);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 144));
  v7 = *(std::__shared_weak_count **)(a1 + 120);
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }
  v11 = *(_QWORD *)(a1 + 128);
  v10 = *(std::__shared_weak_count **)(a1 + 136);
  if (v10)
  {
    v12 = (unint64_t *)&v10->__shared_owners_;
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
    os_unfair_lock_unlock(v6);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v11 + 160))(v11, a2, a3);
    do
      v14 = __ldaxr(v12);
    while (__stlxr(v14 - 1, v12));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  else
  {
    os_unfair_lock_unlock(v6);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v11 + 160))(v11, a2, a3);
  }
  if (v7)
  {
    v15 = (unint64_t *)&v7->__shared_owners_;
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  return 0;
}

_DWORD *_ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE17bulkInsertForTestEPKvPKjjS8_(_DWORD *result, char *a2, int *a3, unsigned int a4, unsigned int *a5)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  float v12;
  int v13;
  uint64_t v14;
  int v15;
  NSObject *v16;
  unsigned int v17;
  int v18;
  int v19;
  unsigned int v20;
  unsigned int v21;
  int v22;
  int v23;
  uint8_t buf[4];
  double v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if (a4)
  {
    v8 = (uint64_t)(result + 12);
    v9 = a4;
    if (a4 <= 0x3E8)
    {
      do
      {
        v21 = *a5++;
        v20 = v21;
        v23 = *a3++;
        v22 = v23;
        result = _ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE15lookupForInsertEjRK10CIVector_sIDF16_Li256EEjfb(v8, v20, a2, 0xFFFFFFFF, 3.4028e38);
        if (result[130])
        {
          v19 = result[129] + 1;
        }
        else
        {
          result[130] = v22;
          v19 = 1;
        }
        result[129] = v19;
        a2 += 512;
        --v9;
      }
      while (v9);
    }
    else
    {
      v10 = 0;
      v11 = a4 / 0xA;
      v12 = 1.0 / (float)a4;
      do
      {
        v14 = v10 + 1;
        if (!(((int)v10 + 1) % v11))
        {
          v15 = *__error();
          v16 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 134217984;
            v25 = (float)((float)((float)v10 * 100.0) * v12);
            _os_log_impl(&dword_1B8270000, v16, OS_LOG_TYPE_DEFAULT, "bulkInsertForTest: %.0f%%", buf, 0xCu);
          }
          *__error() = v15;
        }
        v17 = a5[v10];
        v18 = a3[v10];
        result = _ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE15lookupForInsertEjRK10CIVector_sIDF16_Li256EEjfb(v8, v17, a2, 0xFFFFFFFF, 3.4028e38);
        if (result[130])
        {
          v13 = result[129] + 1;
        }
        else
        {
          result[130] = v18;
          v13 = 1;
        }
        result[129] = v13;
        a2 += 512;
        v10 = v14;
      }
      while (v9 != v14);
    }
  }
  return result;
}

char *_ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE12insertVectorEjjPKv14vec_dimensions15vec_data_format14docInvertStateyP15PostingBaseInfo(_DWORD *a1, int a2, unsigned int a3, const void *a4, int a5, int a6, int a7, uint64_t a8, char *a9)
{
  unsigned int *v11;
  char *v13;
  char *v14;
  const char *v15;

  if (a1[2] != a2
    || a6 > 2
    || a1[3] != vector_dimension_vec_sizes_10743[a5]
    || vector_size_elem_sizes_10742[a6] != a1[4])
  {
    v13 = __si_assert_copy_extra_268();
    v14 = v13;
    v15 = "";
    if (v13)
      v15 = v13;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3070, "compatible", v15);
    free(v14);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v11 = _ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE15lookupForInsertEjRK10CIVector_sIDF16_Li256EEjfb((uint64_t)(a1 + 12), a3, a4, 0xFFFFFFFF, 3.4028e38)+ 128;
  return vi_memory_postings::push_posting(a9, a7, v11, a8);
}

uint64_t _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE14insertForMergeEjtjPKv14vec_dimensions15vec_data_formatyjf(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, int a6, int a7)
{
  char *v8;
  char *v9;
  const char *v10;

  if (*(_DWORD *)(a1 + 8) != a2
    || *(unsigned __int16 *)(a1 + 20) != a3
    || a7 > 2
    || *(_DWORD *)(a1 + 12) != vector_dimension_vec_sizes_10743[a6]
    || vector_size_elem_sizes_10742[a7] != *(_DWORD *)(a1 + 16))
  {
    v8 = __si_assert_copy_extra_268();
    v9 = v8;
    v10 = "";
    if (v8)
      v10 = v8;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3070, "compatible", v10);
    free(v9);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  return 1;
}

_DWORD *_ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE13insertForTestEjjPKv14vec_dimensions15vec_data_formatj(_DWORD *a1, int a2, unsigned int a3, const void *a4, int a5, int a6, int a7)
{
  _DWORD *result;
  int v9;
  char *v10;
  char *v11;
  const char *v12;
  uint64_t v13;

  if (a1[2] != a2
    || a6 > 2
    || a1[3] != vector_dimension_vec_sizes_10743[a5]
    || vector_size_elem_sizes_10742[a6] != a1[4])
  {
    v10 = __si_assert_copy_extra_268();
    v11 = v10;
    v12 = "";
    if (v10)
      v12 = v10;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3070, "compatible", v12);
    free(v11);
    if (__valid_fs(-1))
      v13 = 2989;
    else
      v13 = 3072;
    *(_DWORD *)v13 = -559038737;
    abort();
  }
  result = _ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE15lookupForInsertEjRK10CIVector_sIDF16_Li256EEjfb((uint64_t)(a1 + 12), a3, a4, 0xFFFFFFFF, 3.4028e38);
  if (result[130])
  {
    v9 = result[129] + 1;
  }
  else
  {
    result[130] = a7;
    v9 = 1;
  }
  result[129] = v9;
  return result;
}

void _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE5trainERKNSt3__16vectorIP22AnyVectorIndexInstanceNS5_9allocatorIS8_EEEE(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v3;
  unint64_t v4;
  uint64_t v6;
  char *v7;
  char *v8;
  char *v9;
  unint64_t v10;
  char *v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  _BYTE *v18;
  char *v19;
  unint64_t v20;
  char *v21;
  uint64_t v22;
  _OWORD *v23;
  char *v24;
  uint64_t v25;
  __int128 v26;
  uint64_t v27;
  char *v28;
  char *v29;
  const char *v30;
  char *v31;
  char *v32;
  const char *v33;
  char *v34;
  const char *v35;
  uint64_t v36;
  uint64_t v37;

  v3 = *(_QWORD **)a2;
  v2 = *(_QWORD *)(a2 + 8);
  v4 = v2 - *(_QWORD *)a2;
  if (v2 == *(_QWORD *)a2)
  {
    v31 = __si_assert_copy_extra_268();
    v32 = v31;
    v33 = "";
    if (v31)
      v33 = v31;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3170, "vi.size() > 0", v33);
    goto LABEL_52;
  }
  if (*v3 != a1)
  {
    v34 = __si_assert_copy_extra_268();
    v32 = v34;
    v35 = "";
    if (v34)
      v35 = v34;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3171, "this == vi[0]", v35);
LABEL_52:
    free(v32);
    if (__valid_fs(-1))
      v36 = 2989;
    else
      v36 = 3072;
    *(_DWORD *)v36 = -559038737;
LABEL_56:
    abort();
  }
  v6 = a2;
  v7 = (char *)operator new(8uLL);
  v8 = v7;
  *(_QWORD *)v7 = a1 + 48;
  if (v4 < 9)
    goto LABEL_39;
  v9 = v7 + 8;
  v10 = 1;
  v11 = v7 + 8;
  v37 = v6;
  do
  {
    v13 = v3[v10];
    if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(v13 + 8)
      || *(unsigned __int16 *)(a1 + 20) != *(unsigned __int16 *)(v13 + 20)
      || *(_DWORD *)(a1 + 12) != *(_DWORD *)(v13 + 12)
      || *(_DWORD *)(a1 + 16) != *(_DWORD *)(v13 + 16))
    {
      v28 = __si_assert_copy_extra_268();
      v29 = v28;
      v30 = "";
      if (v28)
        v30 = v28;
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3075, "compatible", v30);
      free(v29);
      if (__valid_fs(-1))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
    v14 = v13 + 48;
    if (v9 < v11)
    {
      *(_QWORD *)v9 = v14;
      v12 = v9 + 8;
      goto LABEL_6;
    }
    v15 = (v9 - v8) >> 3;
    v16 = v15 + 1;
    if ((unint64_t)(v15 + 1) >> 61)
      goto LABEL_56;
    if ((v11 - v8) >> 2 > v16)
      v16 = (v11 - v8) >> 2;
    if ((unint64_t)(v11 - v8) >= 0x7FFFFFFFFFFFFFF8)
      v17 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v17 = v16;
    if (v17)
    {
      if (v17 >> 61)
        std::__throw_bad_array_new_length[abi:nn180100]();
      v18 = operator new(8 * v17);
    }
    else
    {
      v18 = 0;
    }
    v19 = &v18[8 * v15];
    v11 = &v18[8 * v17];
    *(_QWORD *)v19 = v14;
    v12 = v19 + 8;
    if (v9 == v8)
    {
LABEL_36:
      operator delete(v8);
      goto LABEL_37;
    }
    v20 = v9 - 8 - v8;
    if (v20 < 0x168)
    {
      v21 = v9;
      goto LABEL_34;
    }
    if (&v18[v9 - v8 - 8 - (v20 & 0xFFFFFFFFFFFFFFF8)] > &v18[v9 - v8 - 8])
    {
      v21 = v9;
      goto LABEL_34;
    }
    if (&v9[-(v20 & 0xFFFFFFFFFFFFFFF8) - 8] > v9 - 8)
    {
      v21 = v9;
      do
      {
LABEL_34:
        v27 = *((_QWORD *)v21 - 1);
        v21 -= 8;
        *((_QWORD *)v19 - 1) = v27;
        v19 -= 8;
      }
      while (v21 != v8);
      goto LABEL_35;
    }
    if ((unint64_t)(v8 - v18) < 0x20)
    {
      v21 = v9;
      goto LABEL_34;
    }
    v22 = (v20 >> 3) + 1;
    v21 = &v9[-8 * (v22 & 0x3FFFFFFFFFFFFFFCLL)];
    v23 = &v18[8 * v15 - 16];
    v24 = v9 - 16;
    v25 = v22 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v26 = *(_OWORD *)v24;
      *(v23 - 1) = *((_OWORD *)v24 - 1);
      *v23 = v26;
      v23 -= 2;
      v24 -= 32;
      v25 -= 4;
    }
    while (v25);
    v19 -= 8 * (v22 & 0x3FFFFFFFFFFFFFFCLL);
    if (v22 != (v22 & 0x3FFFFFFFFFFFFFFCLL))
      goto LABEL_34;
LABEL_35:
    if (v8)
      goto LABEL_36;
LABEL_37:
    v8 = v19;
    v6 = v37;
LABEL_6:
    ++v10;
    v3 = *(_QWORD **)v6;
    v9 = v12;
  }
  while (v10 < (uint64_t)(*(_QWORD *)(v6 + 8) - *(_QWORD *)v6) >> 3);
  if (v8)
LABEL_39:
    operator delete(v8);
}

uint64_t _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE14mergeUpdateSetEPK22AnyVectorIndexInstanceP15PostingBaseInfoP17TermIdContainer_s(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v7;
  NSObject *v8;
  os_log_type_t v9;
  int v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  unsigned int v15;
  float v16;
  unsigned int v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  _QWORD *v22;
  uint64_t result;
  std::__shared_weak_count *v24;
  unint64_t *p_shared_owners;
  unint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  char *v30;
  char *v31;
  const char *v32;
  char *v33;
  const char *v34;
  _DWORD v35[4];
  void *__src;
  uint64_t v37;
  uint8_t buf[520];
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)
    || *(unsigned __int16 *)(a1 + 20) != *(unsigned __int16 *)(a2 + 20)
    || *(_DWORD *)(a1 + 12) != *(_DWORD *)(a2 + 12)
    || *(_DWORD *)(a1 + 16) != *(_DWORD *)(a2 + 16))
  {
    v33 = __si_assert_copy_extra_268();
    v31 = v33;
    v34 = "";
    if (v33)
      v34 = v33;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3075, "compatible", v34);
LABEL_36:
    free(v31);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v7 = *__error();
  v8 = _SILogForLogForCategory(16);
  v9 = 2 * (dword_1EF19FCCC < 4);
  if (os_log_type_enabled(v8, v9))
  {
    v10 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
    v11 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
    v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
    v13 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 24))(a2);
    *(_DWORD *)buf = 67109888;
    *(_DWORD *)&buf[4] = v10;
    *(_WORD *)&buf[8] = 1024;
    *(_DWORD *)&buf[10] = v11;
    *(_WORD *)&buf[14] = 1024;
    *(_DWORD *)&buf[16] = v12;
    *(_WORD *)&buf[20] = 1024;
    *(_DWORD *)&buf[22] = v13;
    _os_log_impl(&dword_1B8270000, v8, v9, "mergeUpdateSet(termIds) %u vectors in %u partitions and %u vectors in %u partitions", buf, 0x1Au);
  }
  *__error() = v7;
  v14 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::enumerator(a2 + 48);
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::beginMerge(a1 + 48);
  while (1)
  {
    _ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE12enumerator_s4nextEv((uint64_t)v35, v14);
    if (!__src)
      break;
    v15 = v35[0];
    v16 = *(float *)&v35[1];
    v17 = v35[2];
    v18 = v37;
    memcpy(buf, __src, 0x200uLL);
    v20 = *(_QWORD *)(a4 + 8);
    v19 = *(_QWORD *)(a4 + 16);
    v21 = v20 + 1;
    if (v20 + 1 < v19)
    {
      v22 = *(_QWORD **)a4;
      goto LABEL_16;
    }
    if (v19)
    {
      if (v21 >= v19)
        goto LABEL_13;
    }
    else
    {
      *(_QWORD *)(a4 + 16) = 1024;
      v19 = 1024;
      if (v21 >= 0x400)
      {
        do
LABEL_13:
          v19 *= 2;
        while (v21 >= v19);
        *(_QWORD *)(a4 + 16) = v19;
      }
    }
    v22 = malloc_type_realloc(*(void **)a4, 24 * v19, 0x10200409F4E64B8uLL);
    *(_QWORD *)a4 = v22;
    v20 = *(_QWORD *)(a4 + 8);
    v21 = v20 + 1;
LABEL_16:
    v22[3 * v20 + 1] = v18;
    *(_QWORD *)(a4 + 8) = v21;
    if (*(_DWORD *)(a1 + 188) == -1)
    {
      v30 = __si_assert_copy_extra_268();
      v31 = v30;
      v32 = "";
      if (v30)
        v32 = v30;
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2689, "mergeBeginVectorOffset < VECTOR_NOT_FOUND", v32);
      goto LABEL_36;
    }
    _ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE15lookupForInsertEjRK10CIVector_sIDF16_Li256EEjfb(a1 + 48, v17, buf, v15, v16);
  }
  result = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::endMerge(a1 + 48);
  if (v14)
  {
    std::deque<std::shared_ptr<AnyPartitionStore::Enumerator>>::~deque[abi:nn180100](v14 + 32);
    v24 = *(std::__shared_weak_count **)(v14 + 24);
    if (v24)
    {
      p_shared_owners = (unint64_t *)&v24->__shared_owners_;
      do
        v26 = __ldaxr(p_shared_owners);
      while (__stlxr(v26 - 1, p_shared_owners));
      if (!v26)
      {
        ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
        std::__shared_weak_count::__release_weak(v24);
      }
    }
    v27 = *(std::__shared_weak_count **)(v14 + 8);
    if (v27)
    {
      v28 = (unint64_t *)&v27->__shared_owners_;
      do
        v29 = __ldaxr(v28);
      while (__stlxr(v29 - 1, v28));
      if (!v29)
      {
        ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
        std::__shared_weak_count::__release_weak(v27);
      }
    }
    return MEMORY[0x1BCCB06A4](v14, 0x10A0C40B50FE552);
  }
  return result;
}

_DWORD *_ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE14mergeUpdateSetEPK22AnyVectorIndexInstanceP15PostingBaseInfojy(_DWORD *result, uint64_t a2, char *a3, unsigned int a4, uint64_t a5)
{
  _DWORD *v6;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  _DWORD *inserted;
  unsigned int v16;
  const void *v17;
  unint64_t v18;
  char *v19;
  char *v20;
  const char *v21;
  int v22;
  NSObject *v23;
  int v24;
  int v25;
  int v26;
  int v27;
  _DWORD __dst[128];
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  if (result[2] != *(_DWORD *)(a2 + 8)
    || (v6 = result, *((unsigned __int16 *)result + 10) != *(unsigned __int16 *)(a2 + 20))
    || result[3] != *(_DWORD *)(a2 + 12)
    || result[4] != *(_DWORD *)(a2 + 16))
  {
    v19 = __si_assert_copy_extra_268();
    v20 = v19;
    v21 = "";
    if (v19)
      v21 = v19;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3075, "compatible", v21);
    free(v20);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  if (dword_1EF19FCCC >= 5)
  {
    v22 = *__error();
    v23 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      v24 = (*(uint64_t (**)(_DWORD *))(*(_QWORD *)v6 + 16))(v6);
      v25 = (*(uint64_t (**)(_DWORD *))(*(_QWORD *)v6 + 24))(v6);
      v26 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
      v27 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 24))(a2);
      __dst[0] = 67109888;
      __dst[1] = v24;
      LOWORD(__dst[2]) = 1024;
      *(_DWORD *)((char *)&__dst[2] + 2) = v25;
      HIWORD(__dst[3]) = 1024;
      __dst[4] = v26;
      LOWORD(__dst[5]) = 1024;
      *(_DWORD *)((char *)&__dst[5] + 2) = v27;
      _os_log_impl(&dword_1B8270000, v23, OS_LOG_TYPE_DEFAULT, "mergeUpdateSet(DocID) %u vectors in %u partitions and %u vectors in %u partitions", (uint8_t *)__dst, 0x1Au);
    }
    result = __error();
    *result = v22;
  }
  v9 = 0;
  v10 = *(_QWORD *)(a2 + 80);
  v11 = (uint64_t)(v6 + 12);
  v12 = a4;
  while (v9 != *(_DWORD *)(v10 + 24))
  {
    v16 = *(_DWORD *)(_ZNK22IVFVectorIndexTemplateIDF16_Li256EE11VectorStoreI32vi_onefixedsize_memory_allocator18vi_memory_postingsE8IteratorptEv(v10, v9)+ 528);
    v17 = (const void *)_ZNK22IVFVectorIndexTemplateIDF16_Li256EE11VectorStoreI32vi_onefixedsize_memory_allocator18vi_memory_postingsE8IteratorptEv(v10, v9);
    memcpy(__dst, v17, sizeof(__dst));
    v18 = _ZNK22IVFVectorIndexTemplateIDF16_Li256EE11VectorStoreI32vi_onefixedsize_memory_allocator18vi_memory_postingsE8IteratorptEv(v10, v9);
    if ((*(_BYTE *)(v18 + 512) & 1) != 0)
    {
      if (*(_DWORD *)(v18 + 516))
        v13 = 1;
      else
        v13 = 2;
      v14 = a5;
    }
    else
    {
      v13 = 0;
      v14 = v12;
    }
    inserted = _ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE15lookupForInsertEjRK10CIVector_sIDF16_Li256EEjfb(v11, v16, __dst, 0xFFFFFFFF, 3.4028e38);
    result = vi_memory_postings::push_posting(a3, v13, inserted + 128, v14);
    ++v9;
  }
  return result;
}

uint64_t _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE21mergeUpdateSetForTestEPK22AnyVectorIndexInstance(uint64_t a1, uint64_t a2)
{
  int v4;
  NSObject *v5;
  os_log_type_t v6;
  float v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  _DWORD *inserted;
  int v18;
  uint64_t result;
  std::__shared_weak_count *v20;
  unint64_t *p_shared_owners;
  unint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  char *v26;
  char *v27;
  const char *v28;
  char *v29;
  const char *v30;
  uint8_t buf[4];
  float v32;
  _BYTE v33[6];
  __int16 v34;
  __int128 v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)
    || *(unsigned __int16 *)(a1 + 20) != *(unsigned __int16 *)(a2 + 20)
    || *(_DWORD *)(a1 + 12) != *(_DWORD *)(a2 + 12)
    || *(_DWORD *)(a1 + 16) != *(_DWORD *)(a2 + 16))
  {
    v26 = __si_assert_copy_extra_268();
    v27 = v26;
    v28 = "";
    if (v26)
      v28 = v26;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3075, "compatible", v28);
LABEL_34:
    free(v27);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v4 = *__error();
  v5 = _SILogForLogForCategory(16);
  v6 = 2 * (dword_1EF19FCCC < 4);
  if (os_log_type_enabled(v5, v6))
  {
    LODWORD(v7) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
    v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
    v9 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
    v10 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 24))(a2);
    *(_DWORD *)buf = 67109888;
    v32 = v7;
    *(_WORD *)v33 = 1024;
    *(_DWORD *)&v33[2] = v8;
    v34 = 1024;
    LODWORD(v35) = v9;
    WORD2(v35) = 1024;
    *(_DWORD *)((char *)&v35 + 6) = v10;
    _os_log_impl(&dword_1B8270000, v5, v6, "mergeUpdateSetForTest %u vectors in %u partitions and %u vectors in %u partitions", buf, 0x1Au);
  }
  *__error() = v4;
  v11 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::enumerator(a2 + 48);
  v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  v13 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::beginMerge(a1 + 48);
  v14 = 0;
  while (1)
  {
    _ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE12enumerator_s4nextEv((uint64_t)buf, v11);
    if (!(_QWORD)v35)
      break;
    v16 = *(_DWORD *)(*((_QWORD *)&v35 + 1) + 8);
    inserted = _ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE15lookupForInsertEjRK10CIVector_sIDF16_Li256EEjfb(a1 + 48, *(unsigned int *)v33, (const void *)v35, *(unsigned int *)buf, v32);
    v18 = inserted[130];
    if (v18)
    {
      v15 = inserted[129] + 1;
    }
    else
    {
      inserted[130] = v16;
      v15 = 1;
    }
    inserted[129] = v15;
    if (v18)
      ++v14;
  }
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::endMerge(a1 + 48);
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  if ((_DWORD)result + v14 != v13 + v12)
  {
    v29 = __si_assert_copy_extra_268();
    v27 = v29;
    v30 = "";
    if (v29)
      v30 = v29;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3267, "nVectors() + dup == old + added", v30);
    goto LABEL_34;
  }
  if (v11)
  {
    std::deque<std::shared_ptr<AnyPartitionStore::Enumerator>>::~deque[abi:nn180100](v11 + 32);
    v20 = *(std::__shared_weak_count **)(v11 + 24);
    if (v20)
    {
      p_shared_owners = (unint64_t *)&v20->__shared_owners_;
      do
        v22 = __ldaxr(p_shared_owners);
      while (__stlxr(v22 - 1, p_shared_owners));
      if (!v22)
      {
        ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
        std::__shared_weak_count::__release_weak(v20);
      }
    }
    v23 = *(std::__shared_weak_count **)(v11 + 8);
    if (v23)
    {
      v24 = (unint64_t *)&v23->__shared_owners_;
      do
        v25 = __ldaxr(v24);
      while (__stlxr(v25 - 1, v24));
      if (!v25)
      {
        ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
        std::__shared_weak_count::__release_weak(v23);
      }
    }
    return MEMORY[0x1BCCB06A4](v11, 0x10A0C40B50FE552);
  }
  return result;
}

uint64_t _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE17mergeIndexForTestEP22AnyVectorIndexInstance(uint64_t a1, uint64_t a2)
{
  int v4;
  NSObject *v5;
  os_log_type_t v6;
  float v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  _DWORD *inserted;
  int v18;
  uint64_t result;
  std::__shared_weak_count *v20;
  unint64_t *p_shared_owners;
  unint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  char *v26;
  char *v27;
  const char *v28;
  char *v29;
  const char *v30;
  uint8_t buf[4];
  float v32;
  _BYTE v33[6];
  __int16 v34;
  __int128 v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)
    || *(unsigned __int16 *)(a1 + 20) != *(unsigned __int16 *)(a2 + 20)
    || *(_DWORD *)(a1 + 12) != *(_DWORD *)(a2 + 12)
    || *(_DWORD *)(a1 + 16) != *(_DWORD *)(a2 + 16))
  {
    v26 = __si_assert_copy_extra_268();
    v27 = v26;
    v28 = "";
    if (v26)
      v28 = v26;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3075, "compatible", v28);
LABEL_34:
    free(v27);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v4 = *__error();
  v5 = _SILogForLogForCategory(16);
  v6 = 2 * (dword_1EF19FCCC < 4);
  if (os_log_type_enabled(v5, v6))
  {
    LODWORD(v7) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
    v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
    v9 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
    v10 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 24))(a2);
    *(_DWORD *)buf = 67109888;
    v32 = v7;
    *(_WORD *)v33 = 1024;
    *(_DWORD *)&v33[2] = v8;
    v34 = 1024;
    LODWORD(v35) = v9;
    WORD2(v35) = 1024;
    *(_DWORD *)((char *)&v35 + 6) = v10;
    _os_log_impl(&dword_1B8270000, v5, v6, "mergeIndexForTest %u vectors in %u partitions and %u vectors in %u partitions", buf, 0x1Au);
  }
  *__error() = v4;
  v11 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::enumerator(a2 + 48);
  v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  v13 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::beginMerge(a1 + 48);
  v14 = 0;
  while (1)
  {
    _ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI30vi_onefixedsize_disk_allocator16vi_disk_postingsE12enumerator_s4nextEv((uint64_t)buf, v11);
    if (!(_QWORD)v35)
      break;
    v16 = **((_QWORD **)&v35 + 1);
    inserted = _ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE15lookupForInsertEjRK10CIVector_sIDF16_Li256EEjfb(a1 + 48, *(unsigned int *)v33, (const void *)v35, *(unsigned int *)buf, v32);
    v18 = inserted[130];
    if (v18)
    {
      v15 = inserted[129] + 1;
    }
    else
    {
      inserted[130] = v16;
      v15 = 1;
    }
    inserted[129] = v15;
    if (v18)
      ++v14;
  }
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::endMerge(a1 + 48);
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  if ((_DWORD)result + v14 != v13 + v12)
  {
    v29 = __si_assert_copy_extra_268();
    v27 = v29;
    v30 = "";
    if (v29)
      v30 = v29;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3281, "nVectors() + dup == old + added", v30);
    goto LABEL_34;
  }
  if (v11)
  {
    std::deque<std::shared_ptr<AnyPartitionStore::Enumerator>>::~deque[abi:nn180100](v11 + 32);
    v20 = *(std::__shared_weak_count **)(v11 + 24);
    if (v20)
    {
      p_shared_owners = (unint64_t *)&v20->__shared_owners_;
      do
        v22 = __ldaxr(p_shared_owners);
      while (__stlxr(v22 - 1, p_shared_owners));
      if (!v22)
      {
        ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
        std::__shared_weak_count::__release_weak(v20);
      }
    }
    v23 = *(std::__shared_weak_count **)(v11 + 8);
    if (v23)
    {
      v24 = (unint64_t *)&v23->__shared_owners_;
      do
        v25 = __ldaxr(v24);
      while (__stlxr(v25 - 1, v24));
      if (!v25)
      {
        ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
        std::__shared_weak_count::__release_weak(v23);
      }
    }
    return MEMORY[0x1BCCB06A4](v11, 0x10A0C40B50FE552);
  }
  return result;
}

void _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE4dumpEbbPViPvU13block_pointerFbjPKvybjfE(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  os_unfair_lock_s *v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  std::__shared_weak_count *v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  uint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  unint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  unint64_t *v33;
  unint64_t v34;
  unint64_t *v35;
  unint64_t v36;
  _QWORD v37[2];
  void (*v38)();
  void *v39;
  uint64_t v40;
  uint64_t v41;
  _QWORD v42[2];
  uint64_t v43;
  std::__shared_weak_count *v44;
  __int128 v45;
  __int128 v46;
  _OWORD v47[3];
  __int128 v48;
  __int128 v49;
  char v50;
  __int128 v51;
  __int128 v52;

  v9 = (os_unfair_lock_s *)(a1 + 144);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 144));
  v10 = *(std::__shared_weak_count **)(a1 + 120);
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }
  v14 = *(_QWORD *)(a1 + 128);
  v13 = *(std::__shared_weak_count **)(a1 + 136);
  if (v13)
  {
    v15 = (unint64_t *)&v13->__shared_owners_;
    do
      v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
  }
  os_unfair_lock_unlock(v9);
  v46 = 0u;
  memset(v47, 0, sizeof(v47));
  v45 = 0u;
  v43 = v14;
  v44 = v13;
  if (v13)
  {
    v17 = (unint64_t *)&v13->__shared_owners_;
    do
      v18 = __ldxr(v17);
    while (__stxr(v18 + 1, v17));
  }
  v19 = *(_QWORD *)(a1 + 80);
  v20 = *(std::__shared_weak_count **)(a1 + 88);
  v42[0] = v19;
  v42[1] = v20;
  if (v20)
  {
    v21 = (unint64_t *)&v20->__shared_owners_;
    do
      v22 = __ldxr(v21);
    while (__stxr(v22 + 1, v21));
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::enumerator_s::enumerator_s((uint64_t)&v45, &v43, v42);
    do
      v23 = __ldaxr(v21);
    while (__stlxr(v23 - 1, v21));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
  else
  {
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::enumerator_s::enumerator_s((uint64_t)&v45, &v43, v42);
  }
  v24 = v44;
  if (v44)
  {
    v25 = (unint64_t *)&v44->__shared_owners_;
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }
  v37[0] = MEMORY[0x1E0C809B0];
  v37[1] = 0x40000000;
  v38 = ___ZNK22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE4dumpEbbPViPvU13block_pointerFbjPKvybjfE_block_invoke;
  v39 = &unk_1E6E312C8;
  v40 = a6;
  v41 = a4;
  v51 = 0u;
  v52 = 0u;
  v50 = 0;
  do
  {
    _ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE12enumerator_s4nextEv((uint64_t)&v48, (uint64_t)&v45);
    v51 = v48;
    v52 = v49;
    if (!(_QWORD)v49)
      break;
    ((void (*)(_QWORD *, __int128 *, char *))v38)(v37, &v51, &v50);
  }
  while (!v50);
  std::deque<std::shared_ptr<AnyPartitionStore::Enumerator>>::~deque[abi:nn180100]((uint64_t)v47);
  v27 = (std::__shared_weak_count *)*((_QWORD *)&v46 + 1);
  if (!*((_QWORD *)&v46 + 1))
    goto LABEL_30;
  v28 = (unint64_t *)(*((_QWORD *)&v46 + 1) + 8);
  do
    v29 = __ldaxr(v28);
  while (__stlxr(v29 - 1, v28));
  if (!v29)
  {
    ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
    std::__shared_weak_count::__release_weak(v27);
    v30 = (std::__shared_weak_count *)*((_QWORD *)&v45 + 1);
    if (!*((_QWORD *)&v45 + 1))
      goto LABEL_36;
  }
  else
  {
LABEL_30:
    v30 = (std::__shared_weak_count *)*((_QWORD *)&v45 + 1);
    if (!*((_QWORD *)&v45 + 1))
      goto LABEL_36;
  }
  v31 = (unint64_t *)&v30->__shared_owners_;
  do
    v32 = __ldaxr(v31);
  while (__stlxr(v32 - 1, v31));
  if (!v32)
  {
    ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
    std::__shared_weak_count::__release_weak(v30);
  }
  if (!v13)
    goto LABEL_40;
LABEL_36:
  v33 = (unint64_t *)&v13->__shared_owners_;
  do
    v34 = __ldaxr(v33);
  while (__stlxr(v34 - 1, v33));
  if (!v34)
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
    if (!v10)
      return;
  }
  else
  {
LABEL_40:
    if (!v10)
      return;
  }
  v35 = (unint64_t *)&v10->__shared_owners_;
  do
    v36 = __ldaxr(v35);
  while (__stlxr(v36 - 1, v35));
  if (!v36)
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
}

void _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE5flushEy(uint64_t a1, uint64_t a2)
{
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::flush(a1 + 48, a2);
}

int *_ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE7compactEP22AnyVectorIndexInstanceP12uint32_map_tP11TermIdStore18CICompactCallbacksPVi(uint64_t a1, uint64_t a2)
{
  int v4;
  NSObject *v5;
  os_log_type_t v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int *result;
  char *v12;
  char *v13;
  const char *v14;
  uint8_t buf[4];
  int v16;
  __int16 v17;
  int v18;
  __int16 v19;
  int v20;
  __int16 v21;
  int v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v4 = *__error();
  v5 = _SILogForLogForCategory(16);
  v6 = 2 * (dword_1EF19FCCC < 4);
  if (os_log_type_enabled(v5, v6))
  {
    v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
    v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
    v9 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
    v10 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 24))(a2);
    *(_DWORD *)buf = 67109888;
    v16 = v7;
    v17 = 1024;
    v18 = v8;
    v19 = 1024;
    v20 = v9;
    v21 = 1024;
    v22 = v10;
    _os_log_impl(&dword_1B8270000, v5, v6, "compact %u vectors in %u partitions and %u vectors in %u partitions", buf, 0x1Au);
  }
  result = __error();
  *result = v4;
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)
    || *(unsigned __int16 *)(a1 + 20) != *(unsigned __int16 *)(a2 + 20)
    || *(_DWORD *)(a1 + 12) != *(_DWORD *)(a2 + 12)
    || *(_DWORD *)(a1 + 16) != *(_DWORD *)(a2 + 16))
  {
    v12 = __si_assert_copy_extra_268();
    v13 = v12;
    v14 = "";
    if (v12)
      v14 = v12;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3075, "compatible", v14);
    free(v13);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  return result;
}

void _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE14compactForTestEP22AnyVectorIndexInstancePVi(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6;
  NSObject *v7;
  os_log_type_t v8;
  int v9;
  int v10;
  int v11;
  int v12;
  char *v13;
  char *v14;
  const char *v15;
  uint8_t buf[4];
  int v17;
  __int16 v18;
  int v19;
  __int16 v20;
  int v21;
  __int16 v22;
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)
    || *(unsigned __int16 *)(a1 + 20) != *(unsigned __int16 *)(a2 + 20)
    || *(_DWORD *)(a1 + 12) != *(_DWORD *)(a2 + 12)
    || *(_DWORD *)(a1 + 16) != *(_DWORD *)(a2 + 16))
  {
    v13 = __si_assert_copy_extra_268();
    v14 = v13;
    v15 = "";
    if (v13)
      v15 = v13;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3075, "compatible", v15);
    free(v14);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v6 = *__error();
  v7 = _SILogForLogForCategory(16);
  v8 = 2 * (dword_1EF19FCCC < 4);
  if (os_log_type_enabled(v7, v8))
  {
    v9 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
    v10 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
    v11 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
    v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 24))(a2);
    *(_DWORD *)buf = 67109888;
    v17 = v9;
    v18 = 1024;
    v19 = v10;
    v20 = 1024;
    v21 = v11;
    v22 = 1024;
    v23 = v12;
    _os_log_impl(&dword_1B8270000, v7, v8, "compactForTest %u vectors in %u partitions and %u vectors in %u partitions", buf, 0x1Au);
  }
  *__error() = v6;
  _ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI30vi_onefixedsize_disk_allocator16vi_disk_postingsE14compactForTestIS2_EENSt3__19enable_ifIXsr13is_persistentIT_EE5valueEbE4typeEPS4_PVi(a1 + 48, a2 + 48, a3);
}

void _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE7subvertEPK22AnyVectorIndexInstance(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  os_unfair_lock_s *v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  uint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  unint64_t *v26;
  unint64_t v27;
  char *v28;
  char *v29;
  const char *v30;

  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)
    || *(unsigned __int16 *)(a1 + 20) != *(unsigned __int16 *)(a2 + 20)
    || *(_DWORD *)(a1 + 12) != *(_DWORD *)(a2 + 12)
    || *(_DWORD *)(a1 + 16) != *(_DWORD *)(a2 + 16))
  {
    v28 = __si_assert_copy_extra_268();
    v29 = v28;
    v30 = "";
    if (v28)
      v30 = v28;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3075, "compatible", v30);
    free(v29);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v4 = (os_unfair_lock_s *)(a1 + 144);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 144));
  v5 = *(std::__shared_weak_count **)(a1 + 120);
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  v9 = *(_QWORD *)(a1 + 128);
  v8 = *(std::__shared_weak_count **)(a1 + 136);
  if (v8)
  {
    v10 = (unint64_t *)&v8->__shared_owners_;
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }
  os_unfair_lock_unlock(v4);
  if (v5)
  {
    v12 = (unint64_t *)&v5->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  v14 = (os_unfair_lock_s *)(a2 + 144);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 144));
  v15 = *(std::__shared_weak_count **)(a2 + 120);
  if (v15)
  {
    v16 = (unint64_t *)&v15->__shared_owners_;
    do
      v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
  }
  v19 = *(_QWORD *)(a2 + 128);
  v18 = *(std::__shared_weak_count **)(a2 + 136);
  if (v18)
  {
    v20 = (unint64_t *)&v18->__shared_owners_;
    do
      v21 = __ldxr(v20);
    while (__stxr(v21 + 1, v20));
  }
  os_unfair_lock_unlock(v14);
  if (v15)
  {
    v22 = (unint64_t *)&v15->__shared_owners_;
    do
      v23 = __ldaxr(v22);
    while (__stlxr(v23 - 1, v22));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v9 + 168))(v9, v19);
  if (!v18)
    goto LABEL_31;
  v24 = (unint64_t *)&v18->__shared_owners_;
  do
    v25 = __ldaxr(v24);
  while (__stlxr(v25 - 1, v24));
  if (!v25)
  {
    ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
    std::__shared_weak_count::__release_weak(v18);
    if (!v8)
      return;
  }
  else
  {
LABEL_31:
    if (!v8)
      return;
  }
  v26 = (unint64_t *)&v8->__shared_owners_;
  do
    v27 = __ldaxr(v26);
  while (__stlxr(v27 - 1, v26));
  if (!v27)
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
}

uint64_t _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE6unlinkEv(uint64_t a1)
{
  os_unfair_lock_s *v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  uint64_t v10;
  int v11;
  NSObject *v12;
  _QWORD *v13;
  int v14;
  int v15;
  int v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  int v22;
  _QWORD *v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int v27;
  __int16 v28;
  int v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v2 = (os_unfair_lock_s *)(a1 + 144);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 144));
  v3 = *(std::__shared_weak_count **)(a1 + 120);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  v7 = *(_QWORD *)(a1 + 128);
  v6 = *(std::__shared_weak_count **)(a1 + 136);
  if (v6)
  {
    v8 = (unint64_t *)&v6->__shared_owners_;
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  os_unfair_lock_unlock(v2);
  (*(void (**)(uint64_t))(*(_QWORD *)v7 + 176))(v7);
  v10 = *(_QWORD *)(a1 + 80);
  v11 = *__error();
  v12 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    v13 = (_QWORD *)(v10 + 40);
    if (*(char *)(v10 + 63) < 0)
      v13 = (_QWORD *)*v13;
    v14 = *(_DWORD *)(v10 + 24);
    v15 = *(_DWORD *)(vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(v10 + 16), 0, 532) + 528);
    v16 = *(_DWORD *)(vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(v10 + 16), (*(_DWORD *)(v10 + 24) - 1), 532)+ 528);
    v22 = 136315906;
    v23 = v13;
    v24 = 1024;
    v25 = v14;
    v26 = 1024;
    v27 = v15;
    v28 = 1024;
    v29 = v16;
    _os_log_impl(&dword_1B8270000, v12, OS_LOG_TYPE_DEFAULT, "unlink VectorStore %s(%u)[%u,%u]", (uint8_t *)&v22, 0x1Eu);
  }
  *__error() = v11;
  if (v6)
  {
    v17 = (unint64_t *)&v6->__shared_owners_;
    do
      v18 = __ldaxr(v17);
    while (__stlxr(v18 - 1, v17));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  if (v3)
  {
    v19 = (unint64_t *)&v3->__shared_owners_;
    do
      v20 = __ldaxr(v19);
    while (__stlxr(v20 - 1, v19));
    if (!v20)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  return 1;
}

void _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE8truncateEv(uint64_t a1)
{
  int v1;
  NSObject *v2;
  os_log_type_t v3;
  os_unfair_lock_s *v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  uint8_t v16[16];

  if (*(_BYTE *)(a1 + 192))
  {
    v1 = *__error();
    v2 = _SILogForLogForCategory(16);
    v3 = dword_1EF19FCCC < 3;
    if (os_log_type_enabled(v2, (os_log_type_t)(dword_1EF19FCCC < 3)))
    {
      *(_WORD *)v16 = 0;
      _os_log_impl(&dword_1B8270000, v2, v3, "*warn* call truncate on readOnly index.", v16, 2u);
    }
    *__error() = v1;
  }
  else
  {
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::flush(a1 + 48, 0);
    _ZN22IVFVectorIndexTemplateIDF16_Li256EE11VectorStoreI32vi_onefixedsize_memory_allocator18vi_memory_postingsE8truncateEv(*(_QWORD *)(a1 + 80));
    v5 = (os_unfair_lock_s *)(a1 + 144);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 144));
    v6 = *(std::__shared_weak_count **)(a1 + 120);
    if (v6)
    {
      p_shared_owners = (unint64_t *)&v6->__shared_owners_;
      do
        v8 = __ldxr(p_shared_owners);
      while (__stxr(v8 + 1, p_shared_owners));
    }
    v10 = *(_QWORD *)(a1 + 128);
    v9 = *(std::__shared_weak_count **)(a1 + 136);
    if (v9)
    {
      v11 = (unint64_t *)&v9->__shared_owners_;
      do
        v12 = __ldxr(v11);
      while (__stxr(v12 + 1, v11));
      os_unfair_lock_unlock(v5);
      (*(void (**)(uint64_t))(*(_QWORD *)v10 + 136))(v10);
      do
        v13 = __ldaxr(v11);
      while (__stlxr(v13 - 1, v11));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
    else
    {
      os_unfair_lock_unlock(v5);
      (*(void (**)(uint64_t))(*(_QWORD *)v10 + 136))(v10);
    }
    if (v6)
    {
      v14 = (unint64_t *)&v6->__shared_owners_;
      do
        v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }
}

void _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE12makeReadOnlyEv(uint64_t a1)
{
  int v1;
  NSObject *v2;
  os_log_type_t v3;
  uint64_t v5;
  int v6;
  NSObject *v7;
  _QWORD *v8;
  int v9;
  int v10;
  int v11;
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  std::__shared_weak_count *v15;
  uint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  int v22;
  _QWORD *v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int v27;
  __int16 v28;
  int v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 192))
  {
    v1 = *__error();
    v2 = _SILogForLogForCategory(16);
    v3 = dword_1EF19FCCC < 3;
    if (os_log_type_enabled(v2, (os_log_type_t)(dword_1EF19FCCC < 3)))
    {
      LOWORD(v22) = 0;
      _os_log_impl(&dword_1B8270000, v2, v3, "*warn* call makeReadOnly on readOnly index.", (uint8_t *)&v22, 2u);
    }
    *__error() = v1;
  }
  else
  {
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::flush(a1 + 48, 0);
    v5 = *(_QWORD *)(a1 + 80);
    v6 = *__error();
    v7 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      v8 = (_QWORD *)(v5 + 40);
      if (*(char *)(v5 + 63) < 0)
        v8 = (_QWORD *)*v8;
      v9 = *(_DWORD *)(v5 + 24);
      v10 = *(_DWORD *)(vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(v5 + 16), 0, 532) + 528);
      v11 = *(_DWORD *)(vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(v5 + 16), (*(_DWORD *)(v5 + 24) - 1), 532)+ 528);
      v22 = 136315906;
      v23 = v8;
      v24 = 1024;
      v25 = v9;
      v26 = 1024;
      v27 = v10;
      v28 = 1024;
      v29 = v11;
      _os_log_impl(&dword_1B8270000, v7, OS_LOG_TYPE_DEFAULT, "makeReadOnly VectorStore %s(%u)[%u,%u]", (uint8_t *)&v22, 0x1Eu);
    }
    *__error() = v6;
    _ZN22IVFVectorIndexTemplateIDF16_Li256EE11VectorStoreI32vi_onefixedsize_memory_allocator18vi_memory_postingsE8truncateEv(v5);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 144));
    v12 = *(std::__shared_weak_count **)(a1 + 120);
    if (v12)
    {
      p_shared_owners = (unint64_t *)&v12->__shared_owners_;
      do
        v14 = __ldxr(p_shared_owners);
      while (__stxr(v14 + 1, p_shared_owners));
    }
    v16 = *(_QWORD *)(a1 + 128);
    v15 = *(std::__shared_weak_count **)(a1 + 136);
    if (v15)
    {
      v17 = (unint64_t *)&v15->__shared_owners_;
      do
        v18 = __ldxr(v17);
      while (__stxr(v18 + 1, v17));
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 144));
      (*(void (**)(uint64_t))(*(_QWORD *)v16 + 120))(v16);
      *(_BYTE *)(a1 + 192) = 1;
      do
        v19 = __ldaxr(v17);
      while (__stlxr(v19 - 1, v17));
      if (!v19)
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
    }
    else
    {
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 144));
      (*(void (**)(uint64_t))(*(_QWORD *)v16 + 120))(v16);
      *(_BYTE *)(a1 + 192) = 1;
    }
    if (v12)
    {
      v20 = (unint64_t *)&v12->__shared_owners_;
      do
        v21 = __ldaxr(v20);
      while (__stlxr(v21 - 1, v20));
      if (!v21)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
  }
}

void _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE13makePurgeableEv(uint64_t a1)
{
  uint64_t v2;
  int v3;
  NSObject *v4;
  _QWORD *v5;
  int v6;
  int v7;
  int v8;
  os_unfair_lock_s *v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  std::__shared_weak_count *v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  int v20;
  _QWORD *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 80);
  v3 = *__error();
  v4 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v5 = (_QWORD *)(v2 + 40);
    if (*(char *)(v2 + 63) < 0)
      v5 = (_QWORD *)*v5;
    v6 = *(_DWORD *)(v2 + 24);
    v7 = *(_DWORD *)(vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(v2 + 16), 0, 532) + 528);
    v8 = *(_DWORD *)(vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(v2 + 16), (*(_DWORD *)(v2 + 24) - 1), 532)+ 528);
    v20 = 136315906;
    v21 = v5;
    v22 = 1024;
    v23 = v6;
    v24 = 1024;
    v25 = v7;
    v26 = 1024;
    v27 = v8;
    _os_log_impl(&dword_1B8270000, v4, OS_LOG_TYPE_DEFAULT, "makePurgeable VectorStore %s(%u)[%u,%u]", (uint8_t *)&v20, 0x1Eu);
  }
  *__error() = v3;
  v9 = (os_unfair_lock_s *)(a1 + 144);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 144));
  v10 = *(std::__shared_weak_count **)(a1 + 120);
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }
  v14 = *(_QWORD *)(a1 + 128);
  v13 = *(std::__shared_weak_count **)(a1 + 136);
  if (!v13)
  {
    os_unfair_lock_unlock(v9);
    (*(void (**)(uint64_t))(*(_QWORD *)v14 + 128))(v14);
    if (!v10)
      return;
    goto LABEL_18;
  }
  v15 = (unint64_t *)&v13->__shared_owners_;
  do
    v16 = __ldxr(v15);
  while (__stxr(v16 + 1, v15));
  os_unfair_lock_unlock(v9);
  (*(void (**)(uint64_t))(*(_QWORD *)v14 + 128))(v14);
  do
    v17 = __ldaxr(v15);
  while (__stlxr(v17 - 1, v15));
  if (!v17)
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  if (v10)
  {
LABEL_18:
    v18 = (unint64_t *)&v10->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
}

void _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE6renameEPKc(uint64_t a1, const char *a2)
{
  int v4;
  NSObject *v5;
  size_t v6;
  std::string::size_type v7;
  std::string *p_buf;
  uint64_t v9;
  uint64_t v10;
  int v11;
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  std::__shared_weak_count *v15;
  uint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  std::string *v19;
  uint64_t v20;
  int v21;
  NSObject *v22;
  _QWORD *v23;
  int v24;
  int v25;
  int v26;
  unint64_t *v27;
  unint64_t v28;
  unint64_t *v29;
  unint64_t v30;
  std::string::value_type __s[23];
  char v32;
  std::string v33;
  std::string buf;
  int v35;
  __int16 v36;
  int v37;
  __int16 v38;
  int v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  v4 = *__error();
  v5 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
    _os_log_impl(&dword_1B8270000, v5, OS_LOG_TYPE_DEFAULT, "rename: %s", (uint8_t *)&buf, 0xCu);
  }
  *__error() = v4;
  v6 = strlen(a2);
  if (v6 >= 0x7FFFFFFFFFFFFFF8)
    abort();
  v7 = v6;
  if (v6 >= 0x17)
  {
    v9 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v6 | 7) != 0x17)
      v9 = v6 | 7;
    v10 = v9 + 1;
    p_buf = (std::string *)operator new(v9 + 1);
    buf.__r_.__value_.__l.__size_ = v7;
    buf.__r_.__value_.__r.__words[2] = v10 | 0x8000000000000000;
    buf.__r_.__value_.__r.__words[0] = (std::string::size_type)p_buf;
    goto LABEL_10;
  }
  *((_BYTE *)&buf.__r_.__value_.__s + 23) = v6;
  p_buf = &buf;
  if (v6)
LABEL_10:
    memcpy(p_buf, a2, v7);
  p_buf->__r_.__value_.__s.__data_[v7] = 0;
  v32 = 11;
  strcpy(__s, ".partitions");
  memset(&v33, 0, sizeof(v33));
  v11 = SHIBYTE(buf.__r_.__value_.__r.__words[2]);
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(&v33, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
  else
    v33 = buf;
  std::string::append(&v33, __s, 0xBuLL);
  if (v32 < 0)
  {
    operator delete(*(void **)__s);
    if ((v11 & 0x80000000) == 0)
      goto LABEL_16;
  }
  else if ((v11 & 0x80000000) == 0)
  {
    goto LABEL_16;
  }
  operator delete(buf.__r_.__value_.__l.__data_);
LABEL_16:
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 144));
  v12 = *(std::__shared_weak_count **)(a1 + 120);
  if (v12)
  {
    p_shared_owners = (unint64_t *)&v12->__shared_owners_;
    do
      v14 = __ldxr(p_shared_owners);
    while (__stxr(v14 + 1, p_shared_owners));
  }
  v16 = *(_QWORD *)(a1 + 128);
  v15 = *(std::__shared_weak_count **)(a1 + 136);
  if (v15)
  {
    v17 = (unint64_t *)&v15->__shared_owners_;
    do
      v18 = __ldxr(v17);
    while (__stxr(v18 + 1, v17));
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 144));
  if ((v33.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v19 = &v33;
  else
    v19 = (std::string *)v33.__r_.__value_.__r.__words[0];
  (*(void (**)(uint64_t, std::string *))(*(_QWORD *)v16 + 152))(v16, v19);
  v20 = *(_QWORD *)(a1 + 80);
  v21 = *__error();
  v22 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    v23 = (_QWORD *)(v20 + 40);
    if (*(char *)(v20 + 63) < 0)
      v23 = (_QWORD *)*v23;
    v24 = *(_DWORD *)(v20 + 24);
    v25 = *(_DWORD *)(vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(v20 + 16), 0, 532) + 528);
    v26 = *(_DWORD *)(vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(v20 + 16), (*(_DWORD *)(v20 + 24) - 1), 532)+ 528);
    LODWORD(buf.__r_.__value_.__l.__data_) = 136316162;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v23;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)a2;
    HIWORD(buf.__r_.__value_.__r.__words[2]) = 1024;
    v35 = v24;
    v36 = 1024;
    v37 = v25;
    v38 = 1024;
    v39 = v26;
    _os_log_impl(&dword_1B8270000, v22, OS_LOG_TYPE_DEFAULT, "rename VectorStore %s -> %s(%u)[%u,%u]", (uint8_t *)&buf, 0x28u);
  }
  *__error() = v21;
  MEMORY[0x1BCCB03B0](v20 + 40, a2);
  if (v15)
  {
    v27 = (unint64_t *)&v15->__shared_owners_;
    do
      v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  if (!v12)
    goto LABEL_38;
  v29 = (unint64_t *)&v12->__shared_owners_;
  do
    v30 = __ldaxr(v29);
  while (__stlxr(v30 - 1, v29));
  if (v30)
  {
LABEL_38:
    if ((SHIBYTE(v33.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      return;
    goto LABEL_39;
  }
  ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
  std::__shared_weak_count::__release_weak(v12);
  if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0)
LABEL_39:
    operator delete(v33.__r_.__value_.__l.__data_);
}

_QWORD *_ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE14storeUpdateSetEP15RelativePostingP14store_stream_t(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  _QWORD *result;
  unsigned int v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  char *v12;
  size_t v13;
  uint64_t v14;
  char *v15;
  char *v16;
  const char *v17;
  uint64_t v18;

  result = store_stream_write_vint32_2186(a3, *(_DWORD *)(*(_QWORD *)(a1 + 80) + 24));
  v7 = 0;
  v8 = *(_QWORD *)(a1 + 80);
  while (v7 != *(_DWORD *)(v8 + 24))
  {
    v9 = _ZNK22IVFVectorIndexTemplateIDF16_Li256EE11VectorStoreI32vi_onefixedsize_memory_allocator18vi_memory_postingsE8IteratordeEv(v8, v7);
    CIWritePostings((uint64_t)a3, a2, 0, (unsigned int *)(v9 + 512), 0, 0);
    v11 = *((_QWORD *)a3 + 4);
    v10 = *((_QWORD *)a3 + 5);
    if (v10 + 512 >= v11)
    {
      v13 = 512;
      v12 = (char *)v9;
      while (1)
      {
        v14 = v11 - v10;
        memcpy((void *)(*((_QWORD *)a3 + 6) + v10), v12, v11 - v10);
        *((_QWORD *)a3 + 5) += v14;
        if (store_stream_flush(a3, 0))
          break;
        v12 += v14;
        v13 -= v14;
        v11 = *((_QWORD *)a3 + 4);
        v10 = *((_QWORD *)a3 + 5);
        if (v10 + v13 < v11)
          goto LABEL_5;
      }
    }
    else
    {
      v12 = (char *)v9;
      v13 = 512;
LABEL_5:
      memcpy((void *)(*((_QWORD *)a3 + 6) + v10), v12, v13);
      *((_QWORD *)a3 + 5) += v13;
    }
    result = store_stream_write_vint32_2186(a3, *(_DWORD *)(v9 + 528));
    ++v7;
    if (v8 != *(_QWORD *)(a1 + 80))
    {
      v15 = __si_assert_copy_extra_268();
      v16 = v15;
      v17 = "";
      if (v15)
        v17 = v15;
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1814, "store == other.store", v17);
      free(v16);
      if (__valid_fs(-1))
        v18 = 2989;
      else
        v18 = 3072;
      *(_DWORD *)v18 = -559038737;
      abort();
    }
  }
  return result;
}

uint64_t _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE16restoreUpdateSetEP15PostingBaseInfoP14store_stream_t(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  uint64_t result;
  int v6;
  unint64_t v7;
  size_t v8;
  char *v9;
  size_t v10;
  unsigned int vint32;
  uint64_t v12;
  uint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  _DWORD *inserted;
  unint64_t v21;
  _DWORD *v22;
  unint64_t *v23;
  unint64_t v24;
  __int16 v25;
  int v26;
  char *v27;
  unint64_t v28;
  uint64_t v29;
  off_t v30;
  unint64_t v31;
  uint64_t v32;
  int *v33;
  off_t v34;
  size_t v35;
  void *v36;
  size_t v37;
  uint64_t v38;
  unint64_t v39;
  uint64_t v40;
  int *v41;
  char v42;
  off_t v43;
  off_t __offseta;
  uint64_t v45;
  int v46;
  os_unfair_lock_s *lock;
  int v49;
  _OWORD __dst[32];
  uint64_t v51;
  uint64_t v52;
  _BYTE v53[2];
  __int16 v54;

  result = store_stream_read_vint32((uint64_t)a3);
  v46 = result;
  if ((_DWORD)result)
  {
    v6 = 0;
    v45 = a1 + 48;
    lock = (os_unfair_lock_s *)(a1 + 144);
    do
    {
      v52 = 0;
      v51 = 0;
      memset(__dst, 0, sizeof(__dst));
      v49 = 0;
      CIReadPostings(a3, a2, (uint64_t)&v51, &v49);
      v7 = *((_QWORD *)a3 + 4);
      v8 = *((_QWORD *)a3 + 5);
      if (v8 + 512 > v7)
      {
        v27 = (char *)*((_QWORD *)a3 + 6);
        v28 = v7 - v8;
        if (v7 != v8)
        {
          memcpy(__dst, &v27[v8], v7 - v8);
          *((_QWORD *)a3 + 5) = v7;
          v8 = v7;
        }
        v29 = *a3;
        v30 = *((_QWORD *)a3 + 3);
        while (1)
        {
          v31 = pread(v29, v27, v8, v30);
          if (v31 != -1)
            break;
          v32 = g_prot_error_callback;
          if (!g_prot_error_callback)
            break;
          v33 = __error();
          if (((*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t))(v32 + 16))(v32, v29, *v33, 4) & 1) == 0)goto LABEL_47;
        }
        if (v31 != -1)
        {
          *((_QWORD *)a3 + 4) = v31;
          *((_QWORD *)a3 + 5) = 0;
          v34 = *((_QWORD *)a3 + 3) + v31;
          *((_QWORD *)a3 + 3) = v34;
          if (!v31)
            goto LABEL_7;
          v9 = (char *)__dst + v28;
          v10 = 512 - v28;
          if (512 - v28 <= v31)
          {
            v8 = 0;
            goto LABEL_6;
          }
          __offseta = v34;
          v35 = v31;
          while (1)
          {
            v36 = (void *)*((_QWORD *)a3 + 6);
            memcpy(v9, v36, v35);
            v37 = v35;
            *((_QWORD *)a3 + 5) = v35;
            v38 = *a3;
            while (1)
            {
              v39 = pread(v38, v36, v37, __offseta);
              if (v39 != -1)
                break;
              v40 = g_prot_error_callback;
              if (!g_prot_error_callback)
                break;
              v41 = __error();
              v42 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t))(v40 + 16))(v40, v38, *v41, 4);
              v37 = v35;
              if ((v42 & 1) == 0)
                goto LABEL_47;
            }
            if (v39 == -1)
              break;
            *((_QWORD *)a3 + 4) = v39;
            *((_QWORD *)a3 + 5) = 0;
            v43 = *((_QWORD *)a3 + 3) + v39;
            *((_QWORD *)a3 + 3) = v43;
            if (!v39)
              goto LABEL_7;
            __offseta = v43;
            v8 = 0;
            v9 += v35;
            v10 -= v35;
            v35 = v39;
            if (v10 <= v39)
              goto LABEL_6;
          }
        }
LABEL_47:
        a3[4] = *__error();
      }
      else
      {
        v9 = (char *)__dst;
        v10 = 512;
LABEL_6:
        memcpy(v9, (const void *)(*((_QWORD *)a3 + 6) + v8), v10);
        *((_QWORD *)a3 + 5) = v8 + v10;
      }
LABEL_7:
      vint32 = store_stream_read_vint32((uint64_t)a3);
      v12 = v51;
      v13 = v52;
      os_unfair_lock_lock(lock);
      v14 = *(std::__shared_weak_count **)(a1 + 120);
      if (v14)
      {
        p_shared_owners = (unint64_t *)&v14->__shared_owners_;
        do
          v16 = __ldxr(p_shared_owners);
        while (__stxr(v16 + 1, p_shared_owners));
      }
      v17 = *(std::__shared_weak_count **)(a1 + 136);
      if (v17)
      {
        v18 = (unint64_t *)&v17->__shared_owners_;
        do
          v19 = __ldxr(v18);
        while (__stxr(v19 + 1, v18));
        os_unfair_lock_unlock(lock);
        inserted = _ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE15lookupForInsertEjRK10CIVector_sIDF16_Li256EEjfb(v45, vint32, __dst, 0xFFFFFFFF, 3.4028e38);
        *((_QWORD *)inserted + 64) = v12;
        *((_QWORD *)inserted + 65) = v13;
        do
          v21 = __ldaxr(v18);
        while (__stlxr(v21 - 1, v18));
        if (!v21)
        {
          ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
          std::__shared_weak_count::__release_weak(v17);
        }
      }
      else
      {
        os_unfair_lock_unlock(lock);
        v22 = _ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE15lookupForInsertEjRK10CIVector_sIDF16_Li256EEjfb(v45, vint32, __dst, 0xFFFFFFFF, 3.4028e38);
        *((_QWORD *)v22 + 64) = v12;
        *((_QWORD *)v22 + 65) = v13;
      }
      if (v14)
      {
        v23 = (unint64_t *)&v14->__shared_owners_;
        do
          v24 = __ldaxr(v23);
        while (__stlxr(v24 - 1, v23));
        if (!v24)
        {
          ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
          std::__shared_weak_count::__release_weak(v14);
        }
      }
      v25 = *(_WORD *)(a1 + 76);
      v26 = *(_DWORD *)(a1 + 156);
      v53[0] = *(_DWORD *)(a1 + 160);
      v53[1] = v26;
      v54 = v25;
      result = *(_QWORD *)(a1 + 176);
      if (result)
      {
        if (*(_DWORD *)(result + 216) == -270471200)
          result = data_map_ext_restore_data(result, vint32, __dst, 0x200uLL, v53);
      }
      ++v6;
    }
    while (v6 != v46);
  }
  return result;
}

uint64_t _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE3aNNEjtPKv14vec_dimensions15vec_data_formatfjbU13block_pointerFvPvfE(uint64_t a1, int a2, int a3, float16x8_t *a4, int a5, int a6, int a7, char a8, float a9, uint64_t a10)
{
  uint64_t v13;
  int v14;
  _QWORD *v15;
  char *v17;
  char *v18;
  const char *v19;
  _QWORD v20[5];

  if (*(_DWORD *)(a1 + 8) != a2
    || *(unsigned __int16 *)(a1 + 20) != a3
    || a6 > 2
    || *(_DWORD *)(a1 + 12) != vector_dimension_vec_sizes_10743[a5]
    || vector_size_elem_sizes_10742[a6] != *(_DWORD *)(a1 + 16))
  {
    v17 = __si_assert_copy_extra_268();
    v18 = v17;
    v19 = "";
    if (v17)
      v19 = v17;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3070, "compatible", v19);
    free(v18);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v13 = a1 + 48;
  v20[0] = MEMORY[0x1E0C809B0];
  v20[1] = 0x40000000;
  v20[2] = ___ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE3aNNEjtPKv14vec_dimensions15vec_data_formatfjbU13block_pointerFvPvfE_block_invoke;
  v20[3] = &unk_1E6E314E0;
  v20[4] = a10;
  if ((a7 - 10001) >= 0xFFFFD8F0)
    v14 = a7;
  else
    v14 = 10000;
  v15 = (_QWORD *)operator new();
  *(_DWORD *)v15 = v14;
  v15[2] = 0;
  v15[3] = 0;
  v15[1] = 0;
  _ZNK22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE3aNNERK10CIVector_sIDF16_Li256EEfbP20MaxSizePriorityQueueINS0_18candidate_result_sIS3_EENSt3__16vectorISB_NSC_9allocatorISB_EEEENSC_4lessISB_EEEj(v13, a4, a8, v15, 0, a9);
  return IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::aNNProcessResult((uint64_t)v15, (uint64_t)v20);
}

uint64_t _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE10aNNForTestEjtPKv14vec_dimensions15vec_data_formatfjbU13block_pointerFvjfEj(uint64_t a1, int a2, int a3, float16x8_t *a4, int a5, int a6, int a7, char a8, float a9, uint64_t a10, unsigned int a11)
{
  uint64_t v14;
  int v15;
  _QWORD *v16;
  char *v18;
  char *v19;
  const char *v20;

  if (*(_DWORD *)(a1 + 8) != a2
    || *(unsigned __int16 *)(a1 + 20) != a3
    || a6 > 2
    || *(_DWORD *)(a1 + 12) != vector_dimension_vec_sizes_10743[a5]
    || vector_size_elem_sizes_10742[a6] != *(_DWORD *)(a1 + 16))
  {
    v18 = __si_assert_copy_extra_268();
    v19 = v18;
    v20 = "";
    if (v18)
      v20 = v18;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3070, "compatible", v20);
    free(v19);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v14 = a1 + 48;
  if ((a7 - 10001) >= 0xFFFFD8F0)
    v15 = a7;
  else
    v15 = 10000;
  v16 = (_QWORD *)operator new();
  *(_DWORD *)v16 = v15;
  v16[2] = 0;
  v16[3] = 0;
  v16[1] = 0;
  _ZNK22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE3aNNERK10CIVector_sIDF16_Li256EEfbP20MaxSizePriorityQueueINS0_18candidate_result_sIS3_EENSt3__16vectorISB_NSC_9allocatorISB_EEEENSC_4lessISB_EEEj(v14, a4, a8, v16, a11, a9);
  return IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::aNNForTestProcessResult((uint64_t)v16, a10);
}

uint64_t _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE20createCandidateQueueEj(uint64_t a1, int a2)
{
  int v2;
  uint64_t result;

  if ((a2 - 10001) >= 0xFFFFD8F0)
    v2 = a2;
  else
    v2 = 10000;
  result = operator new();
  *(_DWORD *)result = v2;
  *(_QWORD *)(result + 16) = 0;
  *(_QWORD *)(result + 24) = 0;
  *(_QWORD *)(result + 8) = 0;
  return result;
}

void _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE3aNNEjtPKv14vec_dimensions15vec_data_formatfbPv(uint64_t a1, int a2, int a3, float16x8_t *a4, int a5, int a6, char a7, _QWORD *a8, float a9)
{
  char *v9;
  char *v10;
  const char *v11;

  if (*(_DWORD *)(a1 + 8) != a2
    || *(unsigned __int16 *)(a1 + 20) != a3
    || a6 > 2
    || *(_DWORD *)(a1 + 12) != vector_dimension_vec_sizes_10743[a5]
    || vector_size_elem_sizes_10742[a6] != *(_DWORD *)(a1 + 16))
  {
    v9 = __si_assert_copy_extra_268();
    v10 = v9;
    v11 = "";
    if (v9)
      v11 = v9;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3070, "compatible", v11);
    free(v10);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  _ZNK22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE3aNNERK10CIVector_sIDF16_Li256EEfbP20MaxSizePriorityQueueINS0_18candidate_result_sIS3_EENSt3__16vectorISB_NSC_9allocatorISB_EEEENSC_4lessISB_EEEj(a1 + 48, a4, a7, a8, 0, a9);
}

uint64_t _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE16aNNProcessResultEPvU13block_pointerFvS5_fE(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD v4[5];

  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 0x40000000;
  v4[2] = ___ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE16aNNProcessResultEPvU13block_pointerFvS5_fE_block_invoke;
  v4[3] = &unk_1E6E31540;
  v4[4] = a3;
  return IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::aNNProcessResult(a2, (uint64_t)v4);
}

uint64_t _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE23aNNForTestProcessResultEPvU13block_pointerFvjfE(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::aNNForTestProcessResult(a2, a3);
}

uint64_t _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE24aNNForDebugProcessResultEPvU13block_pointerFvjjfE(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5;
  NSObject *v6;
  unint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  std::ios_base *v13;
  uint64_t v14;
  float *v15;
  BOOL v16;
  int v17;
  float *v18;
  _QWORD *v19;
  _QWORD *v20;
  char *v21;
  unint64_t v22;
  int v23;
  NSObject *v24;
  void **v25;
  float *v26;
  char *v27;
  uint64_t v28;
  int v29;
  NSObject *v30;
  void **v31;
  void *v32;
  uint64_t v33;
  int v35;
  float *v36;
  CFIndex AppIntegerValue;
  float *v38;
  float *v39;
  uint64_t v40;
  uint8_t v41[4];
  void **v42;
  void *__p[2];
  uint64_t v44;
  uint64_t v45;
  __int128 buf;
  uint64_t v47;
  _QWORD v48[8];
  __int128 v49;
  __int128 v50;
  uint64_t v51;
  uint64_t v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  uint64_t v62;

  v62 = *MEMORY[0x1E0C80C00];
  v5 = *__error();
  v6 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    v7 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a2 + 16) - *(_QWORD *)(a2 + 8)) >> 3);
    LODWORD(buf) = 134217984;
    *(_QWORD *)((char *)&buf + 4) = v7;
    _os_log_impl(&dword_1B8270000, v6, OS_LOG_TYPE_DEFAULT, "search return %zu results", (uint8_t *)&buf, 0xCu);
  }
  *__error() = v5;
  LOBYTE(buf) = 0;
  AppIntegerValue = CFPreferencesGetAppIntegerValue(CFSTR("IVFANNLogQueryResult"), CFSTR("com.apple.Spotlight"), (Boolean *)&buf);
  v35 = buf;
  v61 = 0u;
  v51 = 0;
  v60 = 0u;
  v59 = 0u;
  v58 = 0u;
  v57 = 0u;
  v56 = 0u;
  v55 = 0u;
  v54 = 0u;
  v53 = 0u;
  v50 = 0u;
  v49 = 0u;
  memset(v48, 0, sizeof(v48));
  v8 = MEMORY[0x1E0DE4FD0] + 104;
  v52 = MEMORY[0x1E0DE4FD0] + 104;
  v9 = (_QWORD *)MEMORY[0x1E0DE4F50];
  v10 = MEMORY[0x1E0DE4FD0] + 64;
  v11 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 16);
  v12 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 24);
  v47 = MEMORY[0x1E0DE4FD0] + 64;
  *(_QWORD *)&buf = v11;
  *(_QWORD *)((char *)&buf + *(_QWORD *)(v11 - 24)) = v12;
  *((_QWORD *)&buf + 1) = 0;
  v13 = (std::ios_base *)((char *)&buf + *(_QWORD *)(buf - 24));
  std::ios_base::init(v13, v48);
  v13[1].__vftable = 0;
  v13[1].__fmtflags_ = -1;
  v14 = v9[5];
  v47 = v9[4];
  *(_QWORD *)((char *)&v48[-1] + *(_QWORD *)(v47 - 24)) = v14;
  *(_QWORD *)&buf = v9[1];
  *(_QWORD *)((char *)&buf + *(_QWORD *)(buf - 24)) = v9[6];
  v52 = v8;
  *(_QWORD *)&buf = MEMORY[0x1E0DE4FD0] + 24;
  v47 = v10;
  std::streambuf::basic_streambuf();
  v48[0] = MEMORY[0x1E0DE4FB8] + 16;
  v49 = 0u;
  v50 = 0u;
  LODWORD(v51) = 24;
  v38 = 0;
  v39 = 0;
  v40 = 0;
  MaxSizePriorityQueue<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_memory_postings>,std::vector<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_memory_postings>,std::allocator<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_memory_postings>>>,std::less<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_memory_postings>>>::allItems(&v38, *(_BYTE **)(a2 + 8), *(_BYTE **)(a2 + 16));
  v15 = v39;
  v36 = v38;
  if (v38 != v39)
  {
    if (AppIntegerValue)
      v16 = v35 == 0;
    else
      v16 = 1;
    if (v16)
    {
      v26 = v38;
      do
      {
        (*(void (**)(uint64_t, _QWORD, _QWORD, float))(a3 + 16))(a3, *((unsigned int *)v26 + 2), *((unsigned int *)v26 + 4), v26[5]);
        v26 += 6;
      }
      while (v26 != v15);
    }
    else
    {
      v17 = 0;
      v18 = v38;
      do
      {
        (*(void (**)(uint64_t, _QWORD, _QWORD, float))(a3 + 16))(a3, *((unsigned int *)v18 + 2), *((unsigned int *)v18 + 4), v18[5]);
        v19 = (_QWORD *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v19, (uint64_t)",", 1);
        v20 = (_QWORD *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v20, (uint64_t)";", 1);
        v21 = (char *)&v48[-1] + *(_QWORD *)(v47 - 24);
        if ((v21[32] & 5) == 0
          && ((*(void (**)(void **__return_ptr, _QWORD, _QWORD, uint64_t, uint64_t))(**((_QWORD **)v21 + 5)
                                                                                            + 32))(__p, *((_QWORD *)v21 + 5), 0, 1, 16), v45 > 1000)|| (++v17, HIDWORD(v22) = -1030792151 * v17 + 85899344, LODWORD(v22) = HIDWORD(v22), (v22 >> 1) < 0x51EB851))
        {
          v23 = *__error();
          v24 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
          {
            std::stringbuf::str();
            v25 = __p;
            if (v44 < 0)
              v25 = (void **)__p[0];
            *(_DWORD *)v41 = 136315138;
            v42 = v25;
            _os_log_impl(&dword_1B8270000, v24, OS_LOG_TYPE_DEFAULT, "%s", v41, 0xCu);
            if (SHIBYTE(v44) < 0)
              operator delete(__p[0]);
          }
          *__error() = v23;
          __p[0] = 0;
          __p[1] = 0;
          v44 = 0;
          std::stringbuf::str();
          if (SHIBYTE(v44) < 0)
            operator delete(__p[0]);
        }
        v18 += 6;
      }
      while (v18 != v15);
    }
  }
  v27 = (char *)&v48[-1] + *(_QWORD *)(v47 - 24);
  if ((v27[32] & 5) != 0)
  {
    v28 = a2;
  }
  else
  {
    (*(void (**)(void **__return_ptr, _QWORD, _QWORD, uint64_t, uint64_t))(**((_QWORD **)v27 + 5) + 32))(__p, *((_QWORD *)v27 + 5), 0, 1, 16);
    v28 = a2;
    if (v45 > 0)
    {
      v29 = *__error();
      v30 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        std::stringbuf::str();
        v31 = v44 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)v41 = 136315138;
        v42 = v31;
        _os_log_impl(&dword_1B8270000, v30, OS_LOG_TYPE_DEFAULT, "%s", v41, 0xCu);
        if (SHIBYTE(v44) < 0)
          operator delete(__p[0]);
      }
      *__error() = v29;
    }
  }
  if (v28)
  {
    v32 = *(void **)(v28 + 8);
    if (v32)
    {
      *(_QWORD *)(v28 + 16) = v32;
      operator delete(v32);
    }
    MEMORY[0x1BCCB06A4](v28, 0x1020C403EC25235);
  }
  if (v36)
    operator delete(v36);
  *(_QWORD *)&buf = *MEMORY[0x1E0DE4F50];
  v33 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 72);
  *(_QWORD *)((char *)&buf + *(_QWORD *)(buf - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 64);
  v47 = v33;
  v48[0] = MEMORY[0x1E0DE4FB8] + 16;
  if (SBYTE7(v50) < 0)
    operator delete((void *)v49);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1BCCB0650](&v52);
}

uint64_t _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE11storageSizeEv(uint64_t a1)
{
  os_unfair_lock_s *v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;

  v2 = (os_unfair_lock_s *)(a1 + 144);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 144));
  v3 = *(std::__shared_weak_count **)(a1 + 120);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  v7 = *(_QWORD *)(a1 + 128);
  v6 = *(std::__shared_weak_count **)(a1 + 136);
  if (v6)
  {
    v8 = (unint64_t *)&v6->__shared_owners_;
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  os_unfair_lock_unlock(v2);
  v10 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 16) + 24);
  v11 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 184))(v7);
  if (!v6)
    goto LABEL_11;
  v12 = (unint64_t *)&v6->__shared_owners_;
  do
    v13 = __ldaxr(v12);
  while (__stlxr(v13 - 1, v12));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
    if (!v3)
      return v11 + v10;
  }
  else
  {
LABEL_11:
    if (!v3)
      return v11 + v10;
  }
  v14 = (unint64_t *)&v3->__shared_owners_;
  do
    v15 = __ldaxr(v14);
  while (__stlxr(v15 - 1, v14));
  if (!v15)
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return v11 + v10;
}

uint64_t _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE14setVectorStoreEP10data_map_s(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 176) = a2;
  return result;
}

uint64_t _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE16getDataForOffsetEjPj(_QWORD *a1, uint64_t a2, int *a3)
{
  uint64_t result;
  int v7;
  int v8;
  NSObject *v9;
  int *v10;
  int v11;
  int v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  int v17;
  __int16 v18;
  int v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if ((*(unsigned int (**)(_QWORD *))(*a1 + 16))(a1) <= a2)
  {
    v8 = *__error();
    v9 = _SILogForLogForCategory(2);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v11 = (*(uint64_t (**)(_QWORD *))(*a1 + 16))(a1);
      v12 = 136315906;
      v13 = "getDataForOffset";
      v14 = 1024;
      v15 = 3455;
      v16 = 1024;
      v17 = a2;
      v18 = 1024;
      v19 = v11;
      _os_log_error_impl(&dword_1B8270000, v9, OS_LOG_TYPE_ERROR, "%s:%d: offset out of range: %u >= %u", (uint8_t *)&v12, 0x1Eu);
    }
    v10 = __error();
    v7 = 0;
    result = 0;
    *v10 = v8;
  }
  else
  {
    result = (*(uint64_t (**)(_QWORD *, uint64_t))(a1[6] + 32))(a1 + 6, a2);
    v7 = 512;
  }
  *a3 = v7;
  return result;
}

uint64_t _ZN16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE26updateVectorStorageOffsetsEP13__SIUINT64Set(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  uint64_t v4;
  unint64_t i;
  uint64_t result;
  unint64_t Ptr;
  unint64_t v8;
  int v9;
  uint64_t v10;
  int v11;

  v2 = a2;
  v4 = a1 + 48;
  if (a2)
  {
    for (i = 0; ; ++i)
    {
      result = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nVectors(v4);
      if (i >= result)
        break;
      Ptr = vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(*(_QWORD *)(a1 + 80) + 16), i, 532);
      if (!*(_BYTE *)(v2 + 184))
      {
        v8 = *(unsigned int *)(Ptr + 528);
        v9 = *(_DWORD *)(v2 + 24);
        if (!v9 || !((*(_QWORD *)(v2 + 16) ^ v8) >> (-4 * v9)))
        {
          v10 = *(_QWORD *)(v2 + 56 + 8 * ((v8 >> ((60 - 4 * v9) & 0xFC)) & 0xF));
          if ((v10 & 1) != 0)
          {
            v11 = v9 + 2;
            do
              v10 = *(_QWORD *)((v10 & 0xFFFFFFFFFFFFFFFELL) + 8 * ((v8 >> ((64 - 4 * v11++) & 0xFC)) & 0xF));
            while ((v10 & 1) != 0);
          }
          if (v10)
            (*(void (**)(uint64_t))(*(_QWORD *)v10 + 16))(v10);
        }
      }
    }
  }
  else
  {
    while (1)
    {
      result = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nVectors(v4);
      if (v2 >= result)
        break;
      vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(*(_QWORD *)(a1 + 80) + 16), v2++, 532);
    }
  }
  return result;
}

uint64_t _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE6statusERKNSt3__112basic_stringIcNS5_11char_traitsIcEENS5_9allocatorIcEEEE(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  std::ios_base *v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  _QWORD *v22;
  _QWORD *v23;
  std::__shared_weak_count *v24;
  unint64_t *p_shared_owners;
  unint64_t v26;
  _QWORD *v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  _QWORD *v31;
  uint64_t v32;
  uint64_t v34;
  std::__shared_weak_count *v35;
  uint64_t v36;
  std::__shared_weak_count *v37;
  _QWORD v38[2];
  uint64_t v39;
  _OWORD v40[4];
  void *__p[2];
  __int128 v42;
  uint64_t v43;
  uint64_t v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;

  v53 = 0u;
  v43 = 0;
  v52 = 0u;
  v51 = 0u;
  v50 = 0u;
  v49 = 0u;
  v48 = 0u;
  v47 = 0u;
  v46 = 0u;
  v45 = 0u;
  v42 = 0u;
  *(_OWORD *)__p = 0u;
  v4 = MEMORY[0x1E0DE4FD0];
  memset(v40, 0, sizeof(v40));
  v5 = MEMORY[0x1E0DE4FD0] + 104;
  v44 = MEMORY[0x1E0DE4FD0] + 104;
  v6 = (_QWORD *)MEMORY[0x1E0DE4F50];
  v7 = MEMORY[0x1E0DE4FD0] + 64;
  v8 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 16);
  v9 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 24);
  v39 = MEMORY[0x1E0DE4FD0] + 64;
  v38[0] = v8;
  *(_QWORD *)((char *)v38 + *(_QWORD *)(v8 - 24)) = v9;
  v38[1] = 0;
  v10 = (std::ios_base *)((char *)v38 + *(_QWORD *)(v38[0] - 24));
  std::ios_base::init(v10, v40);
  v10[1].__vftable = 0;
  v10[1].__fmtflags_ = -1;
  v11 = v6[5];
  v39 = v6[4];
  *(uint64_t *)((char *)&v39 + *(_QWORD *)(v39 - 24)) = v11;
  v38[0] = v6[1];
  *(_QWORD *)((char *)v38 + *(_QWORD *)(v38[0] - 24)) = v6[6];
  v44 = v5;
  v38[0] = v4 + 24;
  v39 = v7;
  std::streambuf::basic_streambuf();
  v12 = MEMORY[0x1E0DE4FB8];
  *(_QWORD *)&v40[0] = MEMORY[0x1E0DE4FB8] + 16;
  *(_OWORD *)__p = 0u;
  v42 = 0u;
  LODWORD(v43) = 24;
  v13 = *(char *)(a2 + 23);
  if (v13 >= 0)
    v14 = a2;
  else
    v14 = *(_QWORD *)a2;
  if (v13 >= 0)
    v15 = *(unsigned __int8 *)(a2 + 23);
  else
    v15 = *(_QWORD *)(a2 + 8);
  v16 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v39, v14, v15);
  v17 = *(char *)(a1 + 47);
  if (v17 >= 0)
    v18 = a1 + 24;
  else
    v18 = *(_QWORD *)(a1 + 24);
  if (v17 >= 0)
    v19 = *(unsigned __int8 *)(a1 + 47);
  else
    v19 = *(_QWORD *)(a1 + 32);
  v20 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v16, v18, v19);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v20, (uint64_t)"(", 1);
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  v21 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v21, (uint64_t)"/", 1);
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
  v22 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v22, (uint64_t)"v", 1);
  _ZNK22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE13getPartitionsEv(a1 + 48, &v36);
  if (v36)
  {
    _ZNK22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE13getPartitionsEv(a1 + 48, &v34);
    v23 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v23, (uint64_t)")", 1);
    v24 = v35;
    if (v35)
    {
      p_shared_owners = (unint64_t *)&v35->__shared_owners_;
      do
        v26 = __ldaxr(p_shared_owners);
      while (__stlxr(v26 - 1, p_shared_owners));
      if (!v26)
      {
        ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
        std::__shared_weak_count::__release_weak(v24);
      }
    }
  }
  else
  {
    v27 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v27, (uint64_t)")", 1);
  }
  v28 = v37;
  if (v37)
  {
    v29 = (unint64_t *)&v37->__shared_owners_;
    do
      v30 = __ldaxr(v29);
    while (__stlxr(v30 - 1, v29));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v39, (uint64_t)"[", 1);
  std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v39, (uint64_t)",", 1);
  v31 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v31, (uint64_t)"] indexId: ", 11);
  std::ostream::operator<<();
  std::stringbuf::str();
  v38[0] = *v6;
  v32 = v6[9];
  *(_QWORD *)((char *)v38 + *(_QWORD *)(v38[0] - 24)) = v6[8];
  v39 = v32;
  *(_QWORD *)&v40[0] = v12 + 16;
  if (SBYTE7(v42) < 0)
    operator delete(__p[0]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1BCCB0650](&v44);
}

uint64_t _ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE12diagnoseDumpERKNSt3__112basic_stringIcNS5_11char_traitsIcEENS5_9allocatorIcEEEERNS5_13basic_ostreamIcS8_EEi(uint64_t a1, uint64_t a2, _QWORD *a3, int a4)
{
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  _QWORD *v16;
  const char *v17;
  uint64_t v18;
  _QWORD *v19;
  const std::locale::facet *v20;
  uint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *p_shared_owners;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  unint64_t *v28;
  unint64_t v29;
  unint64_t *v30;
  unint64_t v31;
  uint64_t v32;
  unint64_t *v33;
  unint64_t v34;
  _QWORD *v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  _QWORD *v39;
  _QWORD *v40;
  _QWORD *v41;
  _QWORD *v42;
  const std::locale::facet *v43;
  uint64_t v44;
  std::locale *v45;
  uint64_t v46;
  const std::locale::facet *v47;
  uint64_t v48;
  _QWORD *v49;
  const char *v50;
  uint64_t v51;
  const std::locale::facet *v52;
  unint64_t v53;
  std::locale::id *v54;
  const std::locale::facet *v55;
  unint64_t Ptr;
  _QWORD *v57;
  _QWORD *v58;
  _QWORD *v59;
  void *locale;
  uint64_t v61;
  void *v62;
  uint64_t v63;
  _QWORD *v64;
  unint64_t v65;
  std::locale::id *v66;
  _QWORD *v67;
  _QWORD *v68;
  const std::locale::facet *v69;
  const std::locale::facet *v70;
  uint64_t v71;
  std::__shared_weak_count *v72;
  unint64_t *v73;
  unint64_t v74;
  unint64_t *v75;
  unint64_t v76;
  uint64_t v78;
  unsigned int v79;
  uint64_t v80;
  std::__shared_weak_count *v81;
  std::locale v82;
  std::locale v83;
  uint64_t v84;
  unsigned __int8 v85;

  v7 = *(_QWORD *)(a2 + 8);
  if (*(char *)(a2 + 23) >= 0)
  {
    v8 = *(unsigned __int8 *)(a2 + 23);
  }
  else
  {
    a2 = *(_QWORD *)a2;
    v8 = v7;
  }
  v9 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, a2, v8);
  v10 = *(char *)(a1 + 47);
  if (v10 >= 0)
    v11 = a1 + 24;
  else
    v11 = *(_QWORD *)(a1 + 24);
  if (v10 >= 0)
    v12 = *(unsigned __int8 *)(a1 + 47);
  else
    v12 = *(_QWORD *)(a1 + 32);
  v13 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v9, v11, v12);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v13, (uint64_t)": ", 2);
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  v14 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v14, (uint64_t)" vectors ", 9);
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
  v15 = (_QWORD *)std::ostream::operator<<();
  v16 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v15, (uint64_t)" partitions.", 12);
  if (*(_BYTE *)(a1 + 192))
    v17 = "(readOnly)";
  else
    v17 = "(readWrite)";
  if (*(_BYTE *)(a1 + 192))
    v18 = 10;
  else
    v18 = 11;
  v19 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v16, (uint64_t)v17, v18);
  std::ios_base::getloc((const std::ios_base *)((char *)v19 + *(_QWORD *)(*v19 - 24)));
  v20 = std::locale::use_facet(&v83, MEMORY[0x1E0DE4A90]);
  ((void (*)(const std::locale::facet *, uint64_t))v20->__vftable[2].~facet_0)(v20, 10);
  std::locale::~locale(&v83);
  std::ostream::put();
  std::ostream::flush();
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 144));
  v21 = *(_QWORD *)(a1 + 112);
  v22 = *(std::__shared_weak_count **)(a1 + 120);
  if (v22)
  {
    p_shared_owners = (unint64_t *)&v22->__shared_owners_;
    do
      v24 = __ldxr(p_shared_owners);
    while (__stxr(v24 + 1, p_shared_owners));
  }
  v25 = *(std::__shared_weak_count **)(a1 + 136);
  if (v25)
  {
    v26 = (unint64_t *)&v25->__shared_owners_;
    do
      v27 = __ldxr(v26);
    while (__stxr(v27 + 1, v26));
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 144));
  if (v22)
  {
    v28 = (unint64_t *)&v22->__shared_owners_;
    do
      v29 = __ldxr(v28);
    while (__stxr(v29 + 1, v28));
  }
  if (!v25)
    goto LABEL_29;
  v30 = (unint64_t *)&v25->__shared_owners_;
  do
    v31 = __ldaxr(v30);
  while (__stlxr(v31 - 1, v30));
  if (!v31)
  {
    ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
    std::__shared_weak_count::__release_weak(v25);
    v32 = a1 + 48;
    if (!v22)
      goto LABEL_35;
  }
  else
  {
LABEL_29:
    v32 = a1 + 48;
    if (!v22)
      goto LABEL_35;
  }
  v33 = (unint64_t *)&v22->__shared_owners_;
  do
    v34 = __ldaxr(v33);
  while (__stlxr(v34 - 1, v33));
  if (!v34)
  {
    ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
    std::__shared_weak_count::__release_weak(v22);
  }
LABEL_35:
  if (v21)
  {
    v35 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, (uint64_t)"Quantizer: ", 11);
    v36 = *(char *)(v21 + 31);
    if (v36 >= 0)
      v37 = v21 + 8;
    else
      v37 = *(_QWORD *)(v21 + 8);
    if (v36 >= 0)
      v38 = *(unsigned __int8 *)(v21 + 31);
    else
      v38 = *(_QWORD *)(v21 + 16);
    v39 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v35, v37, v38);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v39, (uint64_t)"(", 1);
    (*(void (**)(uint64_t))(*(_QWORD *)v21 + 16))(v21);
    v40 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v40, (uint64_t)") ", 2);
    (*(void (**)(uint64_t))(*(_QWORD *)v21 + 24))(v21);
    v41 = (_QWORD *)std::ostream::operator<<();
    v42 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v41, (uint64_t)" centroids.", 11);
    std::ios_base::getloc((const std::ios_base *)((char *)v42 + *(_QWORD *)(*v42 - 24)));
    v43 = std::locale::use_facet(&v83, MEMORY[0x1E0DE4A90]);
    ((void (*)(const std::locale::facet *, uint64_t))v43->__vftable[2].~facet_0)(v43, 10);
    std::locale::~locale(&v83);
    std::ostream::put();
    std::ostream::flush();
  }
  v80 = 0;
  v81 = 0;
  _ZNK22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE13getPartitionsEv(v32, &v80);
  v44 = v80;
  if (!v80)
    goto LABEL_51;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, (uint64_t)"Partition: ", 11);
  (*(void (**)(std::locale *__return_ptr, uint64_t))(*(_QWORD *)v44 + 144))(&v83, v44);
  v45 = (v85 & 0x80u) == 0 ? &v83 : (std::locale *)v83.__locale_;
  v46 = (v85 & 0x80u) == 0 ? v85 : v84;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, (uint64_t)v45, v46);
  std::ios_base::getloc((const std::ios_base *)((char *)a3 + *(_QWORD *)(*a3 - 24)));
  v47 = std::locale::use_facet(&v82, MEMORY[0x1E0DE4A90]);
  ((void (*)(const std::locale::facet *, uint64_t))v47->__vftable[2].~facet_0)(v47, 10);
  std::locale::~locale(&v82);
  std::ostream::put();
  std::ostream::flush();
  if ((char)v85 < 0)
  {
    operator delete(v83.__locale_);
    if (!a4)
      goto LABEL_84;
  }
  else
  {
LABEL_51:
    if (!a4)
      goto LABEL_84;
  }
  v78 = v44;
  v48 = *(_QWORD *)(a1 + 80);
  v49 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, (uint64_t)"offset,vid", 10);
  v79 = a4;
  if (a4 <= 1)
    v50 = ",";
  else
    v50 = ",vector";
  if (a4 <= 1)
    v51 = 1;
  else
    v51 = 7;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v49, (uint64_t)v50, v51);
  std::ios_base::getloc((const std::ios_base *)((char *)a3 + *(_QWORD *)(*a3 - 24)));
  v52 = std::locale::use_facet(&v83, MEMORY[0x1E0DE4A90]);
  ((void (*)(const std::locale::facet *, uint64_t))v52->__vftable[2].~facet_0)(v52, 10);
  std::locale::~locale(&v83);
  std::ostream::put();
  std::ostream::flush();
  if (*(_DWORD *)(v48 + 24))
  {
    if (a4 <= 1)
    {
      v65 = 0;
      v66 = (std::locale::id *)MEMORY[0x1E0DE4A90];
      do
      {
        vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(v48 + 16), v65, 532);
        v67 = (_QWORD *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v67, (uint64_t)",", 1);
        v68 = (_QWORD *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v68, (uint64_t)",", 1);
        std::ios_base::getloc((const std::ios_base *)((char *)a3 + *(_QWORD *)(*a3 - 24)));
        v69 = std::locale::use_facet(&v83, v66);
        ((void (*)(const std::locale::facet *, uint64_t))v69->__vftable[2].~facet_0)(v69, 10);
        std::locale::~locale(&v83);
        std::ostream::put();
        std::ostream::flush();
        ++v65;
      }
      while (v65 < *(unsigned int *)(v48 + 24));
    }
    else
    {
      v53 = 0;
      v54 = (std::locale::id *)MEMORY[0x1E0DE4A90];
      do
      {
        Ptr = vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(v48 + 16), v53, 532);
        v57 = (_QWORD *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v57, (uint64_t)",", 1);
        v58 = (_QWORD *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v58, (uint64_t)",", 1);
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, (uint64_t)"{length = ", 10);
        v59 = (_QWORD *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v59, (uint64_t)", bytes = 0x", 12);
        data2hexString((const unsigned __int8 *)&v83, Ptr, 16);
        if ((v85 & 0x80u) == 0)
          locale = &v83;
        else
          locale = v83.__locale_;
        if ((v85 & 0x80u) == 0)
          v61 = v85;
        else
          v61 = v84;
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v59, (uint64_t)locale, v61);
        if ((char)v85 < 0)
          operator delete(v83.__locale_);
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, (uint64_t)" ... ", 5);
        data2hexString((const unsigned __int8 *)&v83, Ptr + 504, 8);
        if ((v85 & 0x80u) == 0)
          v62 = &v83;
        else
          v62 = v83.__locale_;
        if ((v85 & 0x80u) == 0)
          v63 = v85;
        else
          v63 = v84;
        v64 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, (uint64_t)v62, v63);
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v64, (uint64_t)" }", 2);
        if ((char)v85 < 0)
          operator delete(v83.__locale_);
        std::ios_base::getloc((const std::ios_base *)((char *)a3 + *(_QWORD *)(*a3 - 24)));
        v55 = std::locale::use_facet(&v83, v54);
        ((void (*)(const std::locale::facet *, uint64_t))v55->__vftable[2].~facet_0)(v55, 10);
        std::locale::~locale(&v83);
        std::ostream::put();
        std::ostream::flush();
        ++v53;
      }
      while (v53 < *(unsigned int *)(v48 + 24));
    }
  }
  std::ios_base::getloc((const std::ios_base *)((char *)a3 + *(_QWORD *)(*a3 - 24)));
  v70 = std::locale::use_facet(&v83, MEMORY[0x1E0DE4A90]);
  ((void (*)(const std::locale::facet *, uint64_t))v70->__vftable[2].~facet_0)(v70, 10);
  std::locale::~locale(&v83);
  std::ostream::put();
  std::ostream::flush();
  if (v78)
    (*(void (**)(uint64_t, _QWORD *, _QWORD))(*(_QWORD *)v78 + 104))(v78, a3, v79);
LABEL_84:
  v71 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  v72 = v81;
  if (!v81)
    goto LABEL_88;
  v73 = (unint64_t *)&v81->__shared_owners_;
  do
    v74 = __ldaxr(v73);
  while (__stlxr(v74 - 1, v73));
  if (!v74)
  {
    ((void (*)(std::__shared_weak_count *))v72->__on_zero_shared)(v72);
    std::__shared_weak_count::__release_weak(v72);
    if (!v22)
      return v71;
  }
  else
  {
LABEL_88:
    if (!v22)
      return v71;
  }
  v75 = (unint64_t *)&v22->__shared_owners_;
  do
    v76 = __ldaxr(v75);
  while (__stlxr(v76 - 1, v75));
  if (!v76)
  {
    ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
    std::__shared_weak_count::__release_weak(v22);
  }
  return v71;
}

uint64_t ___ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE16aNNProcessResultEPvU13block_pointerFvS5_fE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void _ZNK22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE3aNNERK10CIVector_sIDF16_Li256EEfbP20MaxSizePriorityQueueINS0_18candidate_result_sIS3_EENSt3__16vectorISB_NSC_9allocatorISB_EEEENSC_4lessISB_EEEj(uint64_t a1, float16x8_t *a2, char a3, _QWORD *a4, CFIndex AppIntegerValue, float a6)
{
  int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  double Current;
  unsigned int v22;
  unsigned int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  unsigned int v30;
  int v31;
  char v32;
  int v33;
  char v34;
  unsigned int v35;
  char v36;
  unsigned int v37;
  int v38;
  int v39;
  int v40;
  unsigned int v41;
  int v42;
  NSObject *v43;
  int v44;
  int v45;
  std::__shared_weak_count *v46;
  uint64_t v47;
  unint64_t *p_shared_owners;
  unint64_t v49;
  std::__shared_weak_count *v50;
  uint64_t v51;
  unint64_t *v52;
  unint64_t v53;
  int *v54;
  int *v55;
  unint64_t v56;
  int v57;
  const void *v58;
  int64_t v59;
  char *v60;
  char *v61;
  int v62;
  NSObject *v63;
  int v64;
  int v65;
  double v66;
  unsigned int v67;
  uint64_t v68;
  unint64_t v69;
  unint64_t v70;
  float16x8_t v71;
  float32x4_t v72;
  float16x8_t v73;
  float16x8_t v74;
  float16x8_t v75;
  float16x8_t v76;
  float16x8_t v77;
  float16x8_t v78;
  float16x8_t v79;
  float16x8_t v80;
  float16x8_t v81;
  float16x8_t v82;
  float16x8_t v83;
  float16x8_t v84;
  float16x8_t v85;
  float16x8_t v86;
  float16x8_t v87;
  float16x8_t v88;
  float16x8_t v89;
  float16x8_t v90;
  float16x8_t v91;
  float16x8_t v92;
  float16x8_t v93;
  float16x8_t v94;
  float16x8_t v95;
  float16x8_t v96;
  float16x8_t v97;
  float16x8_t v98;
  float16x8_t v99;
  float16x8_t v100;
  float16x8_t v101;
  float16x8_t v102;
  float16x8_t v103;
  float32x4_t v104;
  float16x8_t v105;
  float16x8_t v106;
  float16x8_t v107;
  float16x8_t v108;
  float16x8_t v109;
  float16x8_t v110;
  float16x8_t v111;
  float16x8_t v112;
  float16x8_t v113;
  float16x8_t v114;
  float16x8_t v115;
  float16x8_t v116;
  float16x8_t v117;
  float16x8_t v118;
  float16x8_t v119;
  float16x8_t v120;
  float16x8_t v121;
  float16x8_t v122;
  float16x8_t v123;
  float16x8_t v124;
  float16x8_t v125;
  float16x8_t v126;
  float16x8_t v127;
  float16x8_t v128;
  float16x8_t v129;
  float16x8_t v130;
  float16x8_t v131;
  float16x8_t v132;
  float16x8_t v133;
  float16x8_t v134;
  uint8x8_t v135;
  unint64_t v136;
  uint64_t *v137;
  unint64_t v138;
  unint64_t v139;
  float v140;
  int v141;
  NSObject *v142;
  int v143;
  NSObject *v144;
  int v145;
  NSObject *v146;
  int v147;
  int v148;
  int v149;
  int v150;
  unint64_t v151;
  CFAbsoluteTime v152;
  _QWORD *v153;
  _QWORD *v154;
  void *v155;
  _QWORD *v156;
  _QWORD *v157;
  void *v158;
  unint64_t *v159;
  unint64_t v160;
  unint64_t *v161;
  unint64_t v162;
  char *v163;
  char *v164;
  const char *v165;
  os_unfair_lock_t lock;
  int v167;
  _QWORD v169[8];
  void *v170;
  void *v171;
  _QWORD *v172;
  float v173;
  void *v174;
  void *v175;
  char *v176;
  void *v177[2];
  void *__p[2];
  uint64_t v179;
  uint64_t v180;
  uint64_t *v181;
  uint64_t v182;
  int v183;
  uint64_t v184;
  uint64_t *v185;
  uint64_t v186;
  int v187;
  float32x4_t __B;
  float32x4_t v189;
  float32x4_t v190;
  float32x4_t v191;
  float32x4_t v192;
  float32x4_t v193;
  float32x4_t v194;
  float32x4_t v195;
  float32x4_t v196;
  float32x4_t v197;
  float32x4_t v198;
  float32x4_t v199;
  float32x4_t v200;
  float32x4_t v201;
  float32x4_t v202;
  float32x4_t v203;
  float32x4_t v204;
  float32x4_t v205;
  float32x4_t v206;
  float32x4_t v207;
  float32x4_t v208;
  float32x4_t v209;
  float32x4_t v210;
  float32x4_t v211;
  float32x4_t v212;
  float32x4_t v213;
  float32x4_t v214;
  float32x4_t v215;
  float32x4_t v216;
  float32x4_t v217;
  float32x4_t v218;
  float32x4_t v219;
  float32x4_t v220;
  float32x4_t v221;
  float32x4_t v222;
  float32x4_t v223;
  float32x4_t v224;
  float32x4_t v225;
  float32x4_t v226;
  float32x4_t v227;
  float32x4_t v228;
  float32x4_t v229;
  float32x4_t v230;
  float32x4_t v231;
  float32x4_t v232;
  float32x4_t v233;
  float32x4_t v234;
  float32x4_t v235;
  float32x4_t v236;
  float32x4_t v237;
  float32x4_t v238;
  float32x4_t v239;
  float32x4_t v240;
  float32x4_t v241;
  float32x4_t v242;
  float32x4_t v243;
  float32x4_t v244;
  float32x4_t v245;
  float32x4_t v246;
  float32x4_t v247;
  float32x4_t v248;
  float32x4_t v249;
  float32x4_t v250;
  float32x4_t v251;
  float32x4_t *__C;
  char __str[16];
  __int128 v254;
  _BYTE keyExistsAndHasValidFormat[48];
  _BYTE v256[32];
  float32x4_t v257;
  float32x4_t v258;
  float32x4_t v259;
  float32x4_t v260;
  float32x4_t v261;
  float32x4_t v262;
  float32x4_t v263;
  float32x4_t v264;
  float32x4_t v265;
  float32x4_t v266;
  float32x4_t v267;
  float32x4_t v268;
  float32x4_t v269;
  float32x4_t v270;
  float32x4_t v271;
  float32x4_t v272;
  float32x4_t v273;
  float32x4_t v274;
  float32x4_t v275;
  float32x4_t v276;
  float32x4_t v277;
  float32x4_t v278;
  float32x4_t v279;
  float32x4_t v280;
  float32x4_t v281;
  float32x4_t v282;
  float32x4_t v283;
  float32x4_t v284;
  float32x4_t v285;
  float32x4_t v286;
  float32x4_t v287;
  float32x4_t v288;
  float32x4_t v289;
  float32x4_t v290;
  float32x4_t v291;
  float32x4_t v292;
  float32x4_t v293;
  float32x4_t v294;
  float32x4_t v295;
  float32x4_t v296;
  float32x4_t v297;
  float32x4_t v298;
  float32x4_t v299;
  float32x4_t v300;
  float32x4_t v301;
  float32x4_t v302;
  float32x4_t v303;
  float32x4_t v304;
  float32x4_t v305;
  float32x4_t v306;
  float32x4_t v307;
  float32x4_t v308;
  float32x4_t v309;
  float32x4_t v310;
  float32x4_t v311;
  float32x4_t v312;
  float32x4_t v313;
  float32x4_t v314;
  float32x4_t v315;
  uint64_t v316;

  v316 = *MEMORY[0x1E0C80C00];
  v11 = *(_DWORD *)a4;
  v254 = 0u;
  *(_OWORD *)__str = 0u;
  snprintf(__str, 0x20uLL, "%02x%02x%02x%02x...%02x%02x%02x%02x", a2->u8[0], a2->u8[1], a2->u8[2], a2->u8[3], a2[31].u8[12], a2[31].u8[13], a2[31].u8[14], a2[31].u8[15]);
  if (!(_DWORD)AppIntegerValue)
    AppIntegerValue = CFPreferencesGetAppIntegerValue(CFSTR("IVFNumberOfParitionsProbe"), CFSTR("com.apple.Spotlight"), 0);
  keyExistsAndHasValidFormat[0] = 0;
  v12 = CFPreferencesGetAppIntegerValue(CFSTR("IVFPartitionProbeMin"), CFSTR("com.apple.Spotlight"), keyExistsAndHasValidFormat);
  if (keyExistsAndHasValidFormat[0])
    v13 = v12;
  else
    v13 = 10000;
  if (10 * v11 <= v13)
    v14 = v13;
  else
    v14 = 10 * v11;
  v15 = v14
      * IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nPartitions(a1);
  v16 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nVectors(a1);
  keyExistsAndHasValidFormat[0] = 0;
  v17 = v15 / v16;
  v18 = CFPreferencesGetAppIntegerValue(CFSTR("IVFPartitionProbeMin"), CFSTR("com.apple.Spotlight"), keyExistsAndHasValidFormat);
  if (keyExistsAndHasValidFormat[0])
    v19 = v18;
  else
    v19 = 7;
  v184 = 0;
  v185 = &v184;
  if (v17 <= v19)
    v20 = v19;
  else
    v20 = v17;
  v187 = 0;
  v186 = 0x2000000000;
  v180 = 0;
  v181 = &v180;
  v183 = 0;
  v182 = 0x2000000000;
  v179 = 0;
  *(_OWORD *)v177 = 0u;
  *(_OWORD *)__p = 0u;
  QuantizerManager<float,768>::aNNLogQueryVecIds((uint64_t)v177);
  Current = CFAbsoluteTimeGetCurrent();
  v167 = v11;
  if ((a3 & 1) != 0
    || IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nPartitions(a1) <= v20
    || IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nVectors(a1) <= v14)
  {
    v62 = *__error();
    v63 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
    {
      v64 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nVectors(a1);
      v65 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nPartitions(a1);
      v66 = a6;
      *(_DWORD *)keyExistsAndHasValidFormat = 136316162;
      *(_QWORD *)&keyExistsAndHasValidFormat[4] = __str;
      *(_WORD *)&keyExistsAndHasValidFormat[12] = 1024;
      *(_DWORD *)&keyExistsAndHasValidFormat[14] = v11;
      *(_WORD *)&keyExistsAndHasValidFormat[18] = 1024;
      *(_DWORD *)&keyExistsAndHasValidFormat[20] = v64;
      *(_WORD *)&keyExistsAndHasValidFormat[24] = 1024;
      *(_DWORD *)&keyExistsAndHasValidFormat[26] = v65;
      *(_WORD *)&keyExistsAndHasValidFormat[30] = 2048;
      *(double *)&keyExistsAndHasValidFormat[32] = a6;
      _os_log_impl(&dword_1B8270000, v63, OS_LOG_TYPE_DEFAULT, "brute force search %s top %u of %u vectors in %u partitions max_distance=%f", keyExistsAndHasValidFormat, 0x28u);
    }
    else
    {
      v66 = a6;
    }
    *__error() = v62;
    LODWORD(lock) = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nPartitions(a1);
    v67 = 0;
    v68 = *(_QWORD *)(a1 + 32);
    do
    {
      if (v67 == *(_DWORD *)(v68 + 24))
        goto LABEL_94;
      ++*((_DWORD *)v185 + 6);
      v69 = _ZNK22IVFVectorIndexTemplateIDF16_Li256EE11VectorStoreI32vi_onefixedsize_memory_allocator18vi_memory_postingsE8IteratordeEv(v68, v67);
      v70 = *(unsigned int *)(v69 + 528);
      v71 = a2[1];
      v72 = vcvtq_f32_f16(*(float16x4_t *)a2->i8);
      *(float32x4_t *)&keyExistsAndHasValidFormat[16] = vcvt_hight_f32_f16(*a2);
      *(float32x4_t *)keyExistsAndHasValidFormat = v72;
      *(float32x4_t *)v256 = vcvt_hight_f32_f16(v71);
      *(float32x4_t *)&keyExistsAndHasValidFormat[32] = vcvtq_f32_f16(*(float16x4_t *)v71.i8);
      v73 = a2[2];
      v74 = a2[3];
      v257 = vcvt_hight_f32_f16(v73);
      *(float32x4_t *)&v256[16] = vcvtq_f32_f16(*(float16x4_t *)v73.i8);
      v259 = vcvt_hight_f32_f16(v74);
      v258 = vcvtq_f32_f16(*(float16x4_t *)v74.i8);
      v75 = a2[4];
      v76 = a2[5];
      v261 = vcvt_hight_f32_f16(v75);
      v260 = vcvtq_f32_f16(*(float16x4_t *)v75.i8);
      v263 = vcvt_hight_f32_f16(v76);
      v262 = vcvtq_f32_f16(*(float16x4_t *)v76.i8);
      v77 = a2[6];
      v78 = a2[7];
      v265 = vcvt_hight_f32_f16(v77);
      v264 = vcvtq_f32_f16(*(float16x4_t *)v77.i8);
      v267 = vcvt_hight_f32_f16(v78);
      v266 = vcvtq_f32_f16(*(float16x4_t *)v78.i8);
      v79 = a2[8];
      v80 = a2[9];
      v269 = vcvt_hight_f32_f16(v79);
      v268 = vcvtq_f32_f16(*(float16x4_t *)v79.i8);
      v271 = vcvt_hight_f32_f16(v80);
      v270 = vcvtq_f32_f16(*(float16x4_t *)v80.i8);
      v81 = a2[10];
      v82 = a2[11];
      v273 = vcvt_hight_f32_f16(v81);
      v272 = vcvtq_f32_f16(*(float16x4_t *)v81.i8);
      v275 = vcvt_hight_f32_f16(v82);
      v274 = vcvtq_f32_f16(*(float16x4_t *)v82.i8);
      v83 = a2[12];
      v84 = a2[13];
      v277 = vcvt_hight_f32_f16(v83);
      v276 = vcvtq_f32_f16(*(float16x4_t *)v83.i8);
      v279 = vcvt_hight_f32_f16(v84);
      v278 = vcvtq_f32_f16(*(float16x4_t *)v84.i8);
      v85 = a2[14];
      v86 = a2[15];
      v281 = vcvt_hight_f32_f16(v85);
      v280 = vcvtq_f32_f16(*(float16x4_t *)v85.i8);
      v283 = vcvt_hight_f32_f16(v86);
      v282 = vcvtq_f32_f16(*(float16x4_t *)v86.i8);
      v87 = a2[16];
      v88 = a2[17];
      v285 = vcvt_hight_f32_f16(v87);
      v284 = vcvtq_f32_f16(*(float16x4_t *)v87.i8);
      v287 = vcvt_hight_f32_f16(v88);
      v286 = vcvtq_f32_f16(*(float16x4_t *)v88.i8);
      v89 = a2[18];
      v90 = a2[19];
      v289 = vcvt_hight_f32_f16(v89);
      v288 = vcvtq_f32_f16(*(float16x4_t *)v89.i8);
      v291 = vcvt_hight_f32_f16(v90);
      v290 = vcvtq_f32_f16(*(float16x4_t *)v90.i8);
      v91 = a2[20];
      v92 = a2[21];
      v293 = vcvt_hight_f32_f16(v91);
      v292 = vcvtq_f32_f16(*(float16x4_t *)v91.i8);
      v295 = vcvt_hight_f32_f16(v92);
      v294 = vcvtq_f32_f16(*(float16x4_t *)v92.i8);
      v93 = a2[22];
      v94 = a2[23];
      v297 = vcvt_hight_f32_f16(v93);
      v296 = vcvtq_f32_f16(*(float16x4_t *)v93.i8);
      v299 = vcvt_hight_f32_f16(v94);
      v298 = vcvtq_f32_f16(*(float16x4_t *)v94.i8);
      v95 = a2[24];
      v96 = a2[25];
      v301 = vcvt_hight_f32_f16(v95);
      v300 = vcvtq_f32_f16(*(float16x4_t *)v95.i8);
      v303 = vcvt_hight_f32_f16(v96);
      v302 = vcvtq_f32_f16(*(float16x4_t *)v96.i8);
      v97 = a2[26];
      v98 = a2[27];
      v305 = vcvt_hight_f32_f16(v97);
      v304 = vcvtq_f32_f16(*(float16x4_t *)v97.i8);
      v307 = vcvt_hight_f32_f16(v98);
      v306 = vcvtq_f32_f16(*(float16x4_t *)v98.i8);
      v99 = a2[28];
      v100 = a2[29];
      v309 = vcvt_hight_f32_f16(v99);
      v308 = vcvtq_f32_f16(*(float16x4_t *)v99.i8);
      v311 = vcvt_hight_f32_f16(v100);
      v310 = vcvtq_f32_f16(*(float16x4_t *)v100.i8);
      v101 = a2[30];
      v102 = a2[31];
      v313 = vcvt_hight_f32_f16(v101);
      v312 = vcvtq_f32_f16(*(float16x4_t *)v101.i8);
      v315 = vcvt_hight_f32_f16(v102);
      v314 = vcvtq_f32_f16(*(float16x4_t *)v102.i8);
      bzero(&__B, 0x400uLL);
      v103 = *(float16x8_t *)(v69 + 16);
      v104 = vcvt_hight_f32_f16(*(float16x8_t *)v69);
      __B = vcvtq_f32_f16(*(float16x4_t *)v69);
      v189 = v104;
      v190 = vcvtq_f32_f16(*(float16x4_t *)v103.i8);
      v191 = vcvt_hight_f32_f16(v103);
      v105 = *(float16x8_t *)(v69 + 32);
      v106 = *(float16x8_t *)(v69 + 48);
      v192 = vcvtq_f32_f16(*(float16x4_t *)v105.i8);
      v193 = vcvt_hight_f32_f16(v105);
      v194 = vcvtq_f32_f16(*(float16x4_t *)v106.i8);
      v195 = vcvt_hight_f32_f16(v106);
      v107 = *(float16x8_t *)(v69 + 64);
      v108 = *(float16x8_t *)(v69 + 80);
      v196 = vcvtq_f32_f16(*(float16x4_t *)v107.i8);
      v197 = vcvt_hight_f32_f16(v107);
      v198 = vcvtq_f32_f16(*(float16x4_t *)v108.i8);
      v199 = vcvt_hight_f32_f16(v108);
      v109 = *(float16x8_t *)(v69 + 96);
      v110 = *(float16x8_t *)(v69 + 112);
      v200 = vcvtq_f32_f16(*(float16x4_t *)v109.i8);
      v201 = vcvt_hight_f32_f16(v109);
      v202 = vcvtq_f32_f16(*(float16x4_t *)v110.i8);
      v203 = vcvt_hight_f32_f16(v110);
      v111 = *(float16x8_t *)(v69 + 128);
      v112 = *(float16x8_t *)(v69 + 144);
      v204 = vcvtq_f32_f16(*(float16x4_t *)v111.i8);
      v205 = vcvt_hight_f32_f16(v111);
      v206 = vcvtq_f32_f16(*(float16x4_t *)v112.i8);
      v207 = vcvt_hight_f32_f16(v112);
      v113 = *(float16x8_t *)(v69 + 160);
      v114 = *(float16x8_t *)(v69 + 176);
      v208 = vcvtq_f32_f16(*(float16x4_t *)v113.i8);
      v209 = vcvt_hight_f32_f16(v113);
      v210 = vcvtq_f32_f16(*(float16x4_t *)v114.i8);
      v211 = vcvt_hight_f32_f16(v114);
      v115 = *(float16x8_t *)(v69 + 192);
      v116 = *(float16x8_t *)(v69 + 208);
      v212 = vcvtq_f32_f16(*(float16x4_t *)v115.i8);
      v213 = vcvt_hight_f32_f16(v115);
      v214 = vcvtq_f32_f16(*(float16x4_t *)v116.i8);
      v215 = vcvt_hight_f32_f16(v116);
      v117 = *(float16x8_t *)(v69 + 224);
      v118 = *(float16x8_t *)(v69 + 240);
      v216 = vcvtq_f32_f16(*(float16x4_t *)v117.i8);
      v217 = vcvt_hight_f32_f16(v117);
      v218 = vcvtq_f32_f16(*(float16x4_t *)v118.i8);
      v219 = vcvt_hight_f32_f16(v118);
      v119 = *(float16x8_t *)(v69 + 256);
      v120 = *(float16x8_t *)(v69 + 272);
      v220 = vcvtq_f32_f16(*(float16x4_t *)v119.i8);
      v221 = vcvt_hight_f32_f16(v119);
      v222 = vcvtq_f32_f16(*(float16x4_t *)v120.i8);
      v223 = vcvt_hight_f32_f16(v120);
      v121 = *(float16x8_t *)(v69 + 288);
      v122 = *(float16x8_t *)(v69 + 304);
      v224 = vcvtq_f32_f16(*(float16x4_t *)v121.i8);
      v225 = vcvt_hight_f32_f16(v121);
      v226 = vcvtq_f32_f16(*(float16x4_t *)v122.i8);
      v227 = vcvt_hight_f32_f16(v122);
      v123 = *(float16x8_t *)(v69 + 320);
      v124 = *(float16x8_t *)(v69 + 336);
      v228 = vcvtq_f32_f16(*(float16x4_t *)v123.i8);
      v229 = vcvt_hight_f32_f16(v123);
      v230 = vcvtq_f32_f16(*(float16x4_t *)v124.i8);
      v231 = vcvt_hight_f32_f16(v124);
      v125 = *(float16x8_t *)(v69 + 352);
      v126 = *(float16x8_t *)(v69 + 368);
      v232 = vcvtq_f32_f16(*(float16x4_t *)v125.i8);
      v233 = vcvt_hight_f32_f16(v125);
      v234 = vcvtq_f32_f16(*(float16x4_t *)v126.i8);
      v235 = vcvt_hight_f32_f16(v126);
      v127 = *(float16x8_t *)(v69 + 384);
      v128 = *(float16x8_t *)(v69 + 400);
      v236 = vcvtq_f32_f16(*(float16x4_t *)v127.i8);
      v237 = vcvt_hight_f32_f16(v127);
      v238 = vcvtq_f32_f16(*(float16x4_t *)v128.i8);
      v239 = vcvt_hight_f32_f16(v128);
      v129 = *(float16x8_t *)(v69 + 416);
      v130 = *(float16x8_t *)(v69 + 432);
      v240 = vcvtq_f32_f16(*(float16x4_t *)v129.i8);
      v241 = vcvt_hight_f32_f16(v129);
      v242 = vcvtq_f32_f16(*(float16x4_t *)v130.i8);
      v243 = vcvt_hight_f32_f16(v130);
      v131 = *(float16x8_t *)(v69 + 448);
      v132 = *(float16x8_t *)(v69 + 464);
      v244 = vcvtq_f32_f16(*(float16x4_t *)v131.i8);
      v245 = vcvt_hight_f32_f16(v131);
      v246 = vcvtq_f32_f16(*(float16x4_t *)v132.i8);
      v247 = vcvt_hight_f32_f16(v132);
      v133 = *(float16x8_t *)(v69 + 480);
      v134 = *(float16x8_t *)(v69 + 496);
      v248 = vcvtq_f32_f16(*(float16x4_t *)v133.i8);
      v249 = vcvt_hight_f32_f16(v133);
      v250 = vcvtq_f32_f16(*(float16x4_t *)v134.i8);
      v251 = vcvt_hight_f32_f16(v134);
      LODWORD(__C) = 2139095039;
      vDSP_distancesq((const float *)keyExistsAndHasValidFormat, 1, __B.f32, 1, (float *)&__C, 0x100uLL);
      if (v177[1])
      {
        v135 = (uint8x8_t)vcnt_s8((int8x8_t)v177[1]);
        v135.i16[0] = vaddlv_u8(v135);
        if (v135.u32[0] > 1uLL)
        {
          v136 = v70;
          if (v177[1] <= (void *)v70)
            v136 = v70 % (unint64_t)v177[1];
        }
        else
        {
          v136 = (LODWORD(v177[1]) - 1) & v70;
        }
        v137 = (uint64_t *)*((_QWORD *)v177[0] + v136);
        if (v137)
        {
          v137 = (uint64_t *)*v137;
          if (v137)
          {
            if (v135.u32[0] < 2uLL)
            {
              while (1)
              {
                v139 = v137[1];
                if (v139 == v70)
                {
                  if (*((_DWORD *)v137 + 4) == (_DWORD)v70)
                    goto LABEL_84;
                }
                else if ((v139 & ((unint64_t)v177[1] - 1)) != v136)
                {
                  goto LABEL_83;
                }
                v137 = (uint64_t *)*v137;
                if (!v137)
                  goto LABEL_84;
              }
            }
            do
            {
              v138 = v137[1];
              if (v138 == v70)
              {
                if (*((_DWORD *)v137 + 4) == (_DWORD)v70)
                  break;
              }
              else
              {
                if ((void *)v138 >= v177[1])
                  v138 %= (unint64_t)v177[1];
                if (v138 != v136)
                  goto LABEL_83;
              }
              v137 = (uint64_t *)*v137;
            }
            while (v137);
          }
        }
      }
      else
      {
LABEL_83:
        v137 = 0;
      }
LABEL_84:
      v140 = *(float *)&__C;
      if (a6 == 0.0 || *(float *)&__C <= a6)
      {
        if (v137)
        {
          v143 = *__error();
          v144 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v144, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)keyExistsAndHasValidFormat = 67109376;
            *(_DWORD *)&keyExistsAndHasValidFormat[4] = v70;
            *(_WORD *)&keyExistsAndHasValidFormat[8] = 2048;
            *(double *)&keyExistsAndHasValidFormat[10] = v140;
            _os_log_impl(&dword_1B8270000, v144, OS_LOG_TYPE_DEFAULT, "Include vec_id: %u distance %f", keyExistsAndHasValidFormat, 0x12u);
          }
          *__error() = v143;
        }
        *(_OWORD *)keyExistsAndHasValidFormat = *(_OWORD *)(v69 + 512);
        *(_DWORD *)&keyExistsAndHasValidFormat[16] = v70;
        *(float *)&keyExistsAndHasValidFormat[20] = v140;
        MaxSizePriorityQueue<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_memory_postings>,std::vector<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_memory_postings>,std::allocator<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_memory_postings>>>,std::less<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_memory_postings>>>::push(a4, (__int128 *)keyExistsAndHasValidFormat);
      }
      else
      {
        if (v137)
        {
          v141 = *__error();
          v142 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v142, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)keyExistsAndHasValidFormat = 67109632;
            *(_DWORD *)&keyExistsAndHasValidFormat[4] = v70;
            *(_WORD *)&keyExistsAndHasValidFormat[8] = 2048;
            *(double *)&keyExistsAndHasValidFormat[10] = v140;
            *(_WORD *)&keyExistsAndHasValidFormat[18] = 2048;
            *(double *)&keyExistsAndHasValidFormat[20] = v66;
            _os_log_impl(&dword_1B8270000, v142, OS_LOG_TYPE_DEFAULT, "Skip vec_id: %u distance %f > %f", keyExistsAndHasValidFormat, 0x1Cu);
          }
          *__error() = v141;
        }
        ++*((_DWORD *)v181 + 6);
      }
      ++v67;
    }
    while (v68 == *(_QWORD *)(a1 + 32));
    v163 = __si_assert_copy_extra_268();
    v164 = v163;
    v165 = "";
    if (v163)
      v165 = v163;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1814, "store == other.store", v165);
    free(v164);
    if (!__valid_fs(-1))
    {
      MEMORY[0xC00] = -559038737;
      abort();
    }
    MEMORY[0xBAD] = -559038737;
    goto LABEL_126;
  }
  if (!(_DWORD)AppIntegerValue)
  {
    keyExistsAndHasValidFormat[0] = 0;
    v22 = CFPreferencesGetAppIntegerValue(CFSTR("IVFPartitionProbeMax"), CFSTR("com.apple.Spotlight"), keyExistsAndHasValidFormat);
    if (keyExistsAndHasValidFormat[0])
      v23 = v22;
    else
      v23 = 40;
    keyExistsAndHasValidFormat[0] = 0;
    v24 = CFPreferencesGetAppIntegerValue(CFSTR("IVFPartitionSizeFactor"), CFSTR("com.apple.Spotlight"), keyExistsAndHasValidFormat);
    if (keyExistsAndHasValidFormat[0])
      v25 = v24;
    else
      v25 = 45;
    keyExistsAndHasValidFormat[0] = 0;
    v26 = CFPreferencesGetAppIntegerValue(CFSTR("IVFPartitionProbeNumerator"), CFSTR("com.apple.Spotlight"), keyExistsAndHasValidFormat);
    v27 = keyExistsAndHasValidFormat[0];
    v28 = 8 * v26;
    v29 = v25 * v25;
    keyExistsAndHasValidFormat[0] = 0;
    v30 = CFPreferencesGetAppIntegerValue(CFSTR("IVFpartitionProbeDecayExponent"), CFSTR("com.apple.Spotlight"), keyExistsAndHasValidFormat);
    v31 = keyExistsAndHasValidFormat[0];
    if (v30 <= 0x12)
      v32 = 18;
    else
      v32 = v30;
    v33 = v11;
    v34 = v32 - 3;
    v35 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nVectors(a1);
    if (v31)
      v36 = v34;
    else
      v36 = 17;
    v11 = v33;
    v37 = v35 >> v36;
    if (v37 <= 8)
      v38 = 8;
    else
      v38 = v37;
    v39 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nPartitions(a1);
    if (v27)
      v40 = v28;
    else
      v40 = 800;
    v41 = v40 * v39 / (v29 * v38);
    if (v23 < v41)
      v41 = v23;
    if (v41 <= v20)
      AppIntegerValue = v20;
    else
      AppIntegerValue = v41;
  }
  v42 = *__error();
  v43 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
  {
    v44 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nVectors(a1);
    v45 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nPartitions(a1);
    *(_DWORD *)keyExistsAndHasValidFormat = 136316418;
    *(_QWORD *)&keyExistsAndHasValidFormat[4] = __str;
    *(_WORD *)&keyExistsAndHasValidFormat[12] = 1024;
    *(_DWORD *)&keyExistsAndHasValidFormat[14] = v11;
    *(_WORD *)&keyExistsAndHasValidFormat[18] = 1024;
    *(_DWORD *)&keyExistsAndHasValidFormat[20] = v44;
    *(_WORD *)&keyExistsAndHasValidFormat[24] = 1024;
    *(_DWORD *)&keyExistsAndHasValidFormat[26] = AppIntegerValue;
    *(_WORD *)&keyExistsAndHasValidFormat[30] = 1024;
    *(_DWORD *)&keyExistsAndHasValidFormat[32] = v45;
    *(_WORD *)&keyExistsAndHasValidFormat[36] = 2048;
    *(double *)&keyExistsAndHasValidFormat[38] = a6;
    _os_log_impl(&dword_1B8270000, v43, OS_LOG_TYPE_DEFAULT, "aNN search %s top %u of %u vectors in %u of %u partitions max_distance=%f", keyExistsAndHasValidFormat, 0x2Eu);
  }
  *__error() = v42;
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 136));
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  v47 = *(_QWORD *)(a1 + 64);
  v46 = *(std::__shared_weak_count **)(a1 + 72);
  if (v46)
  {
    p_shared_owners = (unint64_t *)&v46->__shared_owners_;
    do
      v49 = __ldxr(p_shared_owners);
    while (__stxr(v49 + 1, p_shared_owners));
  }
  v51 = *(_QWORD *)(a1 + 80);
  v50 = *(std::__shared_weak_count **)(a1 + 88);
  if (v50)
  {
    v52 = (unint64_t *)&v50->__shared_owners_;
    do
      v53 = __ldxr(v52);
    while (__stxr(v53 + 1, v52));
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
  memset(keyExistsAndHasValidFormat, 0, 24);
  (*(void (**)(_BYTE *__return_ptr, uint64_t, float16x8_t *, CFIndex))(*(_QWORD *)v47 + 72))(keyExistsAndHasValidFormat, v47, a2, AppIntegerValue);
  v54 = *(int **)&keyExistsAndHasValidFormat[8];
  v55 = *(int **)keyExistsAndHasValidFormat;
  __B = 0uLL;
  v189.i64[0] = 0;
  __C = &__B;
  v56 = *(_QWORD *)&keyExistsAndHasValidFormat[8] - *(_QWORD *)keyExistsAndHasValidFormat;
  if (*(_QWORD *)&keyExistsAndHasValidFormat[8] == *(_QWORD *)keyExistsAndHasValidFormat)
  {
    v175 = 0;
    v176 = 0;
    v174 = 0;
    goto LABEL_102;
  }
  do
  {
    v57 = *v55;
    v55 += 2;
    std::back_insert_iterator<std::vector<unsigned int>>::operator=[abi:nn180100]((uint64_t *)&__C, v57);
  }
  while (v55 != v54);
  v58 = (const void *)__B.i64[0];
  v175 = 0;
  v176 = 0;
  v174 = 0;
  v59 = __B.i64[1] - __B.i64[0];
  if (__B.i64[1] == __B.i64[0])
    goto LABEL_102;
  if (v59 < 0)
LABEL_126:
    abort();
  v60 = (char *)operator new(__B.i64[1] - __B.i64[0]);
  v61 = &v60[4 * (v59 >> 2)];
  v174 = v60;
  v176 = v61;
  memcpy(v60, v58, v59);
  v175 = v61;
LABEL_102:
  v169[0] = MEMORY[0x1E0C809B0];
  v169[1] = 1174405120;
  v169[2] = ___ZNK22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE3aNNERK10CIVector_sIDF16_Li256EEfbP20MaxSizePriorityQueueINS0_18candidate_result_sIS3_EENSt3__16vectorISB_NSC_9allocatorISB_EEEENSC_4lessISB_EEEj_block_invoke;
  v169[3] = &unk_1E6E31508;
  v169[6] = a1;
  v169[7] = a2;
  v169[4] = &v184;
  std::unordered_set<unsigned int>::unordered_set((uint64_t)&v170, (uint64_t)v177);
  v173 = a6;
  v169[5] = &v180;
  v172 = a4;
  (*(void (**)(uint64_t, void **, _QWORD *))(*(_QWORD *)v51 + 72))(v51, &v174, v169);
  if (v174)
  {
    v175 = v174;
    operator delete(v174);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 136));
  v156 = v171;
  v11 = v167;
  if (v171)
  {
    do
    {
      v157 = (_QWORD *)*v156;
      operator delete(v156);
      v156 = v157;
    }
    while (v157);
  }
  v158 = v170;
  v170 = 0;
  if (v158)
    operator delete(v158);
  if (__B.i64[0])
  {
    __B.i64[1] = __B.i64[0];
    operator delete((void *)__B.i64[0]);
  }
  if (*(_QWORD *)keyExistsAndHasValidFormat)
  {
    *(_QWORD *)&keyExistsAndHasValidFormat[8] = *(_QWORD *)keyExistsAndHasValidFormat;
    operator delete(*(void **)keyExistsAndHasValidFormat);
  }
  if (v50)
  {
    v159 = (unint64_t *)&v50->__shared_owners_;
    do
      v160 = __ldaxr(v159);
    while (__stlxr(v160 - 1, v159));
    if (!v160)
    {
      ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
      std::__shared_weak_count::__release_weak(v50);
    }
  }
  lock = (os_unfair_lock_t)(v56 >> 3);
  if (v46)
  {
    v161 = (unint64_t *)&v46->__shared_owners_;
    do
      v162 = __ldaxr(v161);
    while (__stlxr(v162 - 1, v161));
    if (!v162)
    {
      ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
      std::__shared_weak_count::__release_weak(v46);
    }
  }
LABEL_94:
  v145 = *__error();
  v146 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v146, OS_LOG_TYPE_DEFAULT))
  {
    v147 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nVectors(a1);
    v148 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nPartitions(a1);
    v149 = *((_DWORD *)v181 + 6);
    v150 = *((_DWORD *)v185 + 6);
    v151 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a4[2] - a4[1]) >> 3);
    v152 = CFAbsoluteTimeGetCurrent();
    *(_DWORD *)keyExistsAndHasValidFormat = 136317442;
    *(_QWORD *)&keyExistsAndHasValidFormat[4] = __str;
    *(_WORD *)&keyExistsAndHasValidFormat[12] = 1024;
    *(_DWORD *)&keyExistsAndHasValidFormat[14] = v11;
    *(_WORD *)&keyExistsAndHasValidFormat[18] = 1024;
    *(_DWORD *)&keyExistsAndHasValidFormat[20] = v147;
    *(_WORD *)&keyExistsAndHasValidFormat[24] = 2048;
    *(double *)&keyExistsAndHasValidFormat[26] = a6;
    *(_WORD *)&keyExistsAndHasValidFormat[34] = 1024;
    *(_DWORD *)&keyExistsAndHasValidFormat[36] = (_DWORD)lock;
    *(_WORD *)&keyExistsAndHasValidFormat[40] = 1024;
    *(_DWORD *)&keyExistsAndHasValidFormat[42] = v148;
    *(_WORD *)&keyExistsAndHasValidFormat[46] = 1024;
    *(_DWORD *)v256 = v149;
    *(_WORD *)&v256[4] = 1024;
    *(_DWORD *)&v256[6] = v150;
    *(_WORD *)&v256[10] = 2048;
    *(_QWORD *)&v256[12] = v151;
    *(_WORD *)&v256[20] = 2048;
    *(double *)&v256[22] = v152 - Current;
    _os_log_impl(&dword_1B8270000, v146, OS_LOG_TYPE_DEFAULT, "search %s top %u of %u vectors max_distance=%f in %u of %u partitions skip %u of %u populate %zu results in duration: %f", keyExistsAndHasValidFormat, 0x4Eu);
  }
  *__error() = v145;
  v153 = __p[0];
  if (__p[0])
  {
    do
    {
      v154 = (_QWORD *)*v153;
      operator delete(v153);
      v153 = v154;
    }
    while (v154);
  }
  v155 = v177[0];
  v177[0] = 0;
  if (v155)
    operator delete(v155);
  _Block_object_dispose(&v180, 8);
  _Block_object_dispose(&v184, 8);
}

unint64_t _ZNK22IVFVectorIndexTemplateIDF16_Li256EE11VectorStoreI32vi_onefixedsize_memory_allocator18vi_memory_postingsE8IteratordeEv(uint64_t a1, unsigned int a2)
{
  char *v3;
  char *v4;
  const char *v5;

  if (*(_DWORD *)(a1 + 24) <= a2)
  {
    v3 = __si_assert_copy_extra_268();
    v4 = v3;
    v5 = "";
    if (v3)
      v5 = v3;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1798, "offset < store->endOffset()", v5);
    free(v4);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  return vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(a1 + 16), a2, 532);
}

void ___ZNK22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE3aNNERK10CIVector_sIDF16_Li256EEfbP20MaxSizePriorityQueueINS0_18candidate_result_sIS3_EENSt3__16vectorISB_NSC_9allocatorISB_EEEENSC_4lessISB_EEEj_block_invoke(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  uint64_t v4;
  unint64_t Ptr;
  float16x8_t *v6;
  float16x8_t v7;
  float32x4_t v8;
  float16x8_t v9;
  float16x8_t v10;
  float16x8_t v11;
  float16x8_t v12;
  float16x8_t v13;
  float16x8_t v14;
  float16x8_t v15;
  float16x8_t v16;
  float16x8_t v17;
  float16x8_t v18;
  float16x8_t v19;
  float16x8_t v20;
  float16x8_t v21;
  float16x8_t v22;
  float16x8_t v23;
  float16x8_t v24;
  float16x8_t v25;
  float16x8_t v26;
  float16x8_t v27;
  float16x8_t v28;
  float16x8_t v29;
  float16x8_t v30;
  float16x8_t v31;
  float16x8_t v32;
  float16x8_t v33;
  float16x8_t v34;
  float16x8_t v35;
  float16x8_t v36;
  float16x8_t v37;
  float16x8_t v38;
  float16x8_t v39;
  float32x4_t v40;
  float16x8_t v41;
  float16x8_t v42;
  float16x8_t v43;
  float16x8_t v44;
  float16x8_t v45;
  float16x8_t v46;
  float16x8_t v47;
  float16x8_t v48;
  float16x8_t v49;
  float16x8_t v50;
  float16x8_t v51;
  float16x8_t v52;
  float16x8_t v53;
  float16x8_t v54;
  float16x8_t v55;
  float16x8_t v56;
  float16x8_t v57;
  float16x8_t v58;
  float16x8_t v59;
  float16x8_t v60;
  float16x8_t v61;
  float16x8_t v62;
  float16x8_t v63;
  float16x8_t v64;
  float16x8_t v65;
  float16x8_t v66;
  float16x8_t v67;
  float16x8_t v68;
  float16x8_t v69;
  float16x8_t v70;
  unint64_t v71;
  int8x8_t v72;
  uint8x8_t v73;
  unint64_t v74;
  uint64_t *v75;
  uint64_t v76;
  unint64_t v77;
  uint64_t v78;
  float v79;
  float v80;
  int v81;
  NSObject *v82;
  double v83;
  int v84;
  NSObject *v85;
  _OWORD __B[64];
  float __C;
  _BYTE __A[32];
  float32x4_t v89;
  float32x4_t v90;
  float32x4_t v91;
  float32x4_t v92;
  float32x4_t v93;
  float32x4_t v94;
  float32x4_t v95;
  float32x4_t v96;
  float32x4_t v97;
  float32x4_t v98;
  float32x4_t v99;
  float32x4_t v100;
  float32x4_t v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  float32x4_t v107;
  float32x4_t v108;
  float32x4_t v109;
  float32x4_t v110;
  float32x4_t v111;
  float32x4_t v112;
  float32x4_t v113;
  float32x4_t v114;
  float32x4_t v115;
  float32x4_t v116;
  float32x4_t v117;
  float32x4_t v118;
  float32x4_t v119;
  float32x4_t v120;
  float32x4_t v121;
  float32x4_t v122;
  float32x4_t v123;
  float32x4_t v124;
  float32x4_t v125;
  float32x4_t v126;
  float32x4_t v127;
  float32x4_t v128;
  float32x4_t v129;
  float32x4_t v130;
  float32x4_t v131;
  float32x4_t v132;
  float32x4_t v133;
  float32x4_t v134;
  float32x4_t v135;
  float32x4_t v136;
  float32x4_t v137;
  float32x4_t v138;
  float32x4_t v139;
  float32x4_t v140;
  float32x4_t v141;
  float32x4_t v142;
  float32x4_t v143;
  float32x4_t v144;
  float32x4_t v145;
  float32x4_t v146;
  float32x4_t v147;
  float32x4_t v148;
  float32x4_t v149;
  float32x4_t v150;
  uint64_t v151;

  v151 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a1 + 48);
  ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  Ptr = vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(*(_QWORD *)(v4 + 32) + 16), *a3, 532);
  v6 = *(float16x8_t **)(a1 + 56);
  v7 = v6[1];
  v8 = vcvt_hight_f32_f16(*v6);
  *(float32x4_t *)__A = vcvtq_f32_f16(*(float16x4_t *)v6->i8);
  *(float32x4_t *)&__A[16] = v8;
  v89 = vcvtq_f32_f16(*(float16x4_t *)v7.i8);
  v90 = vcvt_hight_f32_f16(v7);
  v9 = v6[2];
  v10 = v6[3];
  v91 = vcvtq_f32_f16(*(float16x4_t *)v9.i8);
  v92 = vcvt_hight_f32_f16(v9);
  v93 = vcvtq_f32_f16(*(float16x4_t *)v10.i8);
  v94 = vcvt_hight_f32_f16(v10);
  v11 = v6[4];
  v12 = v6[5];
  v95 = vcvtq_f32_f16(*(float16x4_t *)v11.i8);
  v96 = vcvt_hight_f32_f16(v11);
  v97 = vcvtq_f32_f16(*(float16x4_t *)v12.i8);
  v98 = vcvt_hight_f32_f16(v12);
  v13 = v6[6];
  v14 = v6[7];
  v99 = vcvtq_f32_f16(*(float16x4_t *)v13.i8);
  v100 = vcvt_hight_f32_f16(v13);
  v101 = vcvtq_f32_f16(*(float16x4_t *)v14.i8);
  v102 = vcvt_hight_f32_f16(v14);
  v15 = v6[8];
  v16 = v6[9];
  v103 = vcvtq_f32_f16(*(float16x4_t *)v15.i8);
  v104 = vcvt_hight_f32_f16(v15);
  v105 = vcvtq_f32_f16(*(float16x4_t *)v16.i8);
  v106 = vcvt_hight_f32_f16(v16);
  v17 = v6[10];
  v18 = v6[11];
  v107 = vcvtq_f32_f16(*(float16x4_t *)v17.i8);
  v108 = vcvt_hight_f32_f16(v17);
  v109 = vcvtq_f32_f16(*(float16x4_t *)v18.i8);
  v110 = vcvt_hight_f32_f16(v18);
  v19 = v6[12];
  v20 = v6[13];
  v111 = vcvtq_f32_f16(*(float16x4_t *)v19.i8);
  v112 = vcvt_hight_f32_f16(v19);
  v113 = vcvtq_f32_f16(*(float16x4_t *)v20.i8);
  v114 = vcvt_hight_f32_f16(v20);
  v21 = v6[14];
  v22 = v6[15];
  v115 = vcvtq_f32_f16(*(float16x4_t *)v21.i8);
  v116 = vcvt_hight_f32_f16(v21);
  v117 = vcvtq_f32_f16(*(float16x4_t *)v22.i8);
  v118 = vcvt_hight_f32_f16(v22);
  v23 = v6[16];
  v24 = v6[17];
  v119 = vcvtq_f32_f16(*(float16x4_t *)v23.i8);
  v120 = vcvt_hight_f32_f16(v23);
  v121 = vcvtq_f32_f16(*(float16x4_t *)v24.i8);
  v122 = vcvt_hight_f32_f16(v24);
  v25 = v6[18];
  v26 = v6[19];
  v123 = vcvtq_f32_f16(*(float16x4_t *)v25.i8);
  v124 = vcvt_hight_f32_f16(v25);
  v125 = vcvtq_f32_f16(*(float16x4_t *)v26.i8);
  v126 = vcvt_hight_f32_f16(v26);
  v27 = v6[20];
  v28 = v6[21];
  v127 = vcvtq_f32_f16(*(float16x4_t *)v27.i8);
  v128 = vcvt_hight_f32_f16(v27);
  v129 = vcvtq_f32_f16(*(float16x4_t *)v28.i8);
  v130 = vcvt_hight_f32_f16(v28);
  v29 = v6[22];
  v30 = v6[23];
  v131 = vcvtq_f32_f16(*(float16x4_t *)v29.i8);
  v132 = vcvt_hight_f32_f16(v29);
  v133 = vcvtq_f32_f16(*(float16x4_t *)v30.i8);
  v134 = vcvt_hight_f32_f16(v30);
  v31 = v6[24];
  v32 = v6[25];
  v135 = vcvtq_f32_f16(*(float16x4_t *)v31.i8);
  v136 = vcvt_hight_f32_f16(v31);
  v137 = vcvtq_f32_f16(*(float16x4_t *)v32.i8);
  v138 = vcvt_hight_f32_f16(v32);
  v33 = v6[26];
  v34 = v6[27];
  v139 = vcvtq_f32_f16(*(float16x4_t *)v33.i8);
  v140 = vcvt_hight_f32_f16(v33);
  v141 = vcvtq_f32_f16(*(float16x4_t *)v34.i8);
  v142 = vcvt_hight_f32_f16(v34);
  v35 = v6[28];
  v36 = v6[29];
  v143 = vcvtq_f32_f16(*(float16x4_t *)v35.i8);
  v144 = vcvt_hight_f32_f16(v35);
  v145 = vcvtq_f32_f16(*(float16x4_t *)v36.i8);
  v146 = vcvt_hight_f32_f16(v36);
  v37 = v6[30];
  v38 = v6[31];
  v147 = vcvtq_f32_f16(*(float16x4_t *)v37.i8);
  v148 = vcvt_hight_f32_f16(v37);
  v149 = vcvtq_f32_f16(*(float16x4_t *)v38.i8);
  v150 = vcvt_hight_f32_f16(v38);
  v39 = *(float16x8_t *)(Ptr + 16);
  v40 = vcvtq_f32_f16(*(float16x4_t *)Ptr);
  __B[1] = vcvt_hight_f32_f16(*(float16x8_t *)Ptr);
  __B[0] = v40;
  __B[3] = vcvt_hight_f32_f16(v39);
  __B[2] = vcvtq_f32_f16(*(float16x4_t *)v39.i8);
  v41 = *(float16x8_t *)(Ptr + 32);
  v42 = *(float16x8_t *)(Ptr + 48);
  __B[5] = vcvt_hight_f32_f16(v41);
  __B[4] = vcvtq_f32_f16(*(float16x4_t *)v41.i8);
  __B[7] = vcvt_hight_f32_f16(v42);
  __B[6] = vcvtq_f32_f16(*(float16x4_t *)v42.i8);
  v43 = *(float16x8_t *)(Ptr + 64);
  v44 = *(float16x8_t *)(Ptr + 80);
  __B[9] = vcvt_hight_f32_f16(v43);
  __B[8] = vcvtq_f32_f16(*(float16x4_t *)v43.i8);
  __B[11] = vcvt_hight_f32_f16(v44);
  __B[10] = vcvtq_f32_f16(*(float16x4_t *)v44.i8);
  v45 = *(float16x8_t *)(Ptr + 96);
  v46 = *(float16x8_t *)(Ptr + 112);
  __B[13] = vcvt_hight_f32_f16(v45);
  __B[12] = vcvtq_f32_f16(*(float16x4_t *)v45.i8);
  __B[15] = vcvt_hight_f32_f16(v46);
  __B[14] = vcvtq_f32_f16(*(float16x4_t *)v46.i8);
  v47 = *(float16x8_t *)(Ptr + 128);
  v48 = *(float16x8_t *)(Ptr + 144);
  __B[17] = vcvt_hight_f32_f16(v47);
  __B[16] = vcvtq_f32_f16(*(float16x4_t *)v47.i8);
  __B[19] = vcvt_hight_f32_f16(v48);
  __B[18] = vcvtq_f32_f16(*(float16x4_t *)v48.i8);
  v49 = *(float16x8_t *)(Ptr + 160);
  v50 = *(float16x8_t *)(Ptr + 176);
  __B[21] = vcvt_hight_f32_f16(v49);
  __B[20] = vcvtq_f32_f16(*(float16x4_t *)v49.i8);
  __B[23] = vcvt_hight_f32_f16(v50);
  __B[22] = vcvtq_f32_f16(*(float16x4_t *)v50.i8);
  v51 = *(float16x8_t *)(Ptr + 192);
  v52 = *(float16x8_t *)(Ptr + 208);
  __B[25] = vcvt_hight_f32_f16(v51);
  __B[24] = vcvtq_f32_f16(*(float16x4_t *)v51.i8);
  __B[27] = vcvt_hight_f32_f16(v52);
  __B[26] = vcvtq_f32_f16(*(float16x4_t *)v52.i8);
  v53 = *(float16x8_t *)(Ptr + 224);
  v54 = *(float16x8_t *)(Ptr + 240);
  __B[29] = vcvt_hight_f32_f16(v53);
  __B[28] = vcvtq_f32_f16(*(float16x4_t *)v53.i8);
  __B[31] = vcvt_hight_f32_f16(v54);
  __B[30] = vcvtq_f32_f16(*(float16x4_t *)v54.i8);
  v55 = *(float16x8_t *)(Ptr + 256);
  v56 = *(float16x8_t *)(Ptr + 272);
  __B[33] = vcvt_hight_f32_f16(v55);
  __B[32] = vcvtq_f32_f16(*(float16x4_t *)v55.i8);
  __B[35] = vcvt_hight_f32_f16(v56);
  __B[34] = vcvtq_f32_f16(*(float16x4_t *)v56.i8);
  v57 = *(float16x8_t *)(Ptr + 288);
  v58 = *(float16x8_t *)(Ptr + 304);
  __B[37] = vcvt_hight_f32_f16(v57);
  __B[36] = vcvtq_f32_f16(*(float16x4_t *)v57.i8);
  __B[39] = vcvt_hight_f32_f16(v58);
  __B[38] = vcvtq_f32_f16(*(float16x4_t *)v58.i8);
  v59 = *(float16x8_t *)(Ptr + 320);
  v60 = *(float16x8_t *)(Ptr + 336);
  __B[41] = vcvt_hight_f32_f16(v59);
  __B[40] = vcvtq_f32_f16(*(float16x4_t *)v59.i8);
  __B[43] = vcvt_hight_f32_f16(v60);
  __B[42] = vcvtq_f32_f16(*(float16x4_t *)v60.i8);
  v61 = *(float16x8_t *)(Ptr + 352);
  v62 = *(float16x8_t *)(Ptr + 368);
  __B[45] = vcvt_hight_f32_f16(v61);
  __B[44] = vcvtq_f32_f16(*(float16x4_t *)v61.i8);
  __B[47] = vcvt_hight_f32_f16(v62);
  __B[46] = vcvtq_f32_f16(*(float16x4_t *)v62.i8);
  v63 = *(float16x8_t *)(Ptr + 384);
  v64 = *(float16x8_t *)(Ptr + 400);
  __B[49] = vcvt_hight_f32_f16(v63);
  __B[48] = vcvtq_f32_f16(*(float16x4_t *)v63.i8);
  __B[51] = vcvt_hight_f32_f16(v64);
  __B[50] = vcvtq_f32_f16(*(float16x4_t *)v64.i8);
  v65 = *(float16x8_t *)(Ptr + 416);
  v66 = *(float16x8_t *)(Ptr + 432);
  __B[53] = vcvt_hight_f32_f16(v65);
  __B[52] = vcvtq_f32_f16(*(float16x4_t *)v65.i8);
  __B[55] = vcvt_hight_f32_f16(v66);
  __B[54] = vcvtq_f32_f16(*(float16x4_t *)v66.i8);
  v67 = *(float16x8_t *)(Ptr + 448);
  v68 = *(float16x8_t *)(Ptr + 464);
  __B[57] = vcvt_hight_f32_f16(v67);
  __B[56] = vcvtq_f32_f16(*(float16x4_t *)v67.i8);
  __B[59] = vcvt_hight_f32_f16(v68);
  __B[58] = vcvtq_f32_f16(*(float16x4_t *)v68.i8);
  v69 = *(float16x8_t *)(Ptr + 480);
  v70 = *(float16x8_t *)(Ptr + 496);
  __B[61] = vcvt_hight_f32_f16(v69);
  __B[60] = vcvtq_f32_f16(*(float16x4_t *)v69.i8);
  __B[63] = vcvt_hight_f32_f16(v70);
  __B[62] = vcvtq_f32_f16(*(float16x4_t *)v70.i8);
  __C = 3.4028e38;
  vDSP_distancesq((const float *)__A, 1, (const float *)__B, 1, &__C, 0x100uLL);
  v71 = *(unsigned int *)(Ptr + 528);
  v72 = *(int8x8_t *)(a1 + 72);
  if (v72)
  {
    v73 = (uint8x8_t)vcnt_s8(v72);
    v73.i16[0] = vaddlv_u8(v73);
    if (v73.u32[0] > 1uLL)
    {
      v74 = *(unsigned int *)(Ptr + 528);
      if (*(_QWORD *)&v72 <= v71)
        v74 = v71 % *(_QWORD *)&v72;
    }
    else
    {
      v74 = (v72.i32[0] - 1) & v71;
    }
    v75 = *(uint64_t **)(*(_QWORD *)(a1 + 64) + 8 * v74);
    if (v75)
    {
      v75 = (uint64_t *)*v75;
      if (v75)
      {
        if (v73.u32[0] < 2uLL)
        {
          v76 = *(_QWORD *)&v72 - 1;
          while (1)
          {
            v78 = v75[1];
            if (v78 == v71)
            {
              if (*((_DWORD *)v75 + 4) == (_DWORD)v71)
                goto LABEL_22;
            }
            else if ((v78 & v76) != v74)
            {
              goto LABEL_21;
            }
            v75 = (uint64_t *)*v75;
            if (!v75)
              goto LABEL_22;
          }
        }
        do
        {
          v77 = v75[1];
          if (v77 == v71)
          {
            if (*((_DWORD *)v75 + 4) == (_DWORD)v71)
              break;
          }
          else
          {
            if (v77 >= *(_QWORD *)&v72)
              v77 %= *(_QWORD *)&v72;
            if (v77 != v74)
              goto LABEL_21;
          }
          v75 = (uint64_t *)*v75;
        }
        while (v75);
      }
    }
  }
  else
  {
LABEL_21:
    v75 = 0;
  }
LABEL_22:
  v79 = __C;
  v80 = *(float *)(a1 + 112);
  if (v80 == 0.0 || __C <= v80)
  {
    if (v75)
    {
      v84 = *__error();
      v85 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v85, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__A = 67109376;
        *(_DWORD *)&__A[4] = v71;
        *(_WORD *)&__A[8] = 2048;
        *(double *)&__A[10] = v79;
        _os_log_impl(&dword_1B8270000, v85, OS_LOG_TYPE_DEFAULT, "Include vec_id: %u distance %f", __A, 0x12u);
      }
      *__error() = v84;
    }
    *(_OWORD *)__A = *(_OWORD *)(Ptr + 512);
    *(_DWORD *)&__A[16] = v71;
    *(float *)&__A[20] = v79;
    MaxSizePriorityQueue<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_memory_postings>,std::vector<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_memory_postings>,std::allocator<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_memory_postings>>>,std::less<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_memory_postings>>>::push(*(_QWORD **)(a1 + 104), (__int128 *)__A);
  }
  else
  {
    if (v75)
    {
      v81 = *__error();
      v82 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
      {
        v83 = *(float *)(a1 + 112);
        *(_DWORD *)__A = 67109632;
        *(_DWORD *)&__A[4] = v71;
        *(_WORD *)&__A[8] = 2048;
        *(double *)&__A[10] = v79;
        *(_WORD *)&__A[18] = 2048;
        *(double *)&__A[20] = v83;
        _os_log_impl(&dword_1B8270000, v82, OS_LOG_TYPE_DEFAULT, "Skip vec_id: %u distance %f > %f", __A, 0x1Cu);
      }
      *__error() = v81;
    }
    ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  }
}

uint64_t ___ZNK16IVFVectorIndexenI32vi_onefixedsize_memory_allocator18vi_memory_postingsE22IVFVectorIndexInstanceIDF16_Li256EE3aNNEjtPKv14vec_dimensions15vec_data_formatfjbU13block_pointerFvPvfE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

_DWORD *_ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE15lookupForInsertEjRK10CIVector_sIDF16_Li256EEjfb(uint64_t a1, unsigned int a2, const void *a3, unsigned int a4, float a5)
{
  unsigned int v8;
  uint64_t v9;
  _DWORD *Ptr;
  const UInt8 *data;
  int v12;
  NSObject *v13;
  int v14;
  NSObject *v15;
  int v16;
  NSObject *v17;
  _BYTE *v18;
  int v19;
  NSObject *v20;
  _BYTE *v21;
  const void *v22;
  std::__shared_weak_count *v23;
  unint64_t *p_shared_owners;
  unint64_t v25;
  std::__shared_weak_count *v26;
  _DWORD *v27;
  unint64_t *v28;
  unint64_t v29;
  uint64_t v30;
  size_t OffsetFromEnd;
  uint64_t v32;
  int v33;
  NSObject *v34;
  _OWORD *v35;
  uint64_t v36;
  unint64_t *v37;
  unint64_t v38;
  unint64_t *v39;
  unint64_t v40;
  NSObject *v41;
  const UInt8 *v42;
  int v43;
  NSObject *v44;
  size_t v45;
  int v46;
  NSObject *v47;
  int v48;
  NSObject *v49;
  _BYTE *v50;
  int v51;
  NSObject *v52;
  _BYTE *v53;
  NSObject *v54;
  int v55;
  NSObject *v56;
  int v58;
  int v59;
  int v60;
  char *v61;
  char *v62;
  const char *v63;
  char *v64;
  char *v65;
  const char *v66;
  char *v67;
  const char *v68;
  char *v69;
  const char *v70;
  char *v71;
  const char *v72;
  uint64_t v73;
  char *v74;
  const char *v75;
  char *v76;
  const char *v77;
  unsigned int v78;
  uint64_t v79;
  float v80;
  unsigned int v81;
  uint8_t buf[4];
  _BYTE *v83;
  _BYTE __p[12];
  __int16 v85;
  int v86;
  __int16 v87;
  _BYTE v88[14];
  __int16 v89;
  uint64_t v90;
  uint64_t v91;

  v91 = *MEMORY[0x1E0C80C00];
  v81 = a4;
  v80 = a5;
  if (*(_BYTE *)(a1 + 144))
  {
    v61 = __si_assert_copy_extra_268();
    v62 = v61;
    v63 = "";
    if (v61)
      v63 = v61;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2430, "!readOnly", v63);
    goto LABEL_104;
  }
  v8 = _ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE10findVectorERK10CIVector_sIDF16_Li256EERjRfj(a1, (uint64_t)a3, (int *)&v81, &v80, a2);
  v9 = v81;
  if (v81 == -1)
  {
    v64 = __si_assert_copy_extra_268();
    v65 = v64;
    v66 = "";
    if (v64)
      v66 = v64;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2435, "partID != VECTOR_NOT_FOUND", v66);
    goto LABEL_94;
  }
  if (v8 != -1)
  {
    Ptr = (_DWORD *)vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(*(_QWORD *)(a1 + 32) + 16), v8, 532);
    if (Ptr[132] == a2)
      return Ptr;
    v79 = 0;
    data = data_map_get_data(*(_QWORD *)(a1 + 128), a2, &v79);
    v12 = *__error();
    v13 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__p = 136316162;
      *(_QWORD *)&__p[4] = "lookupForInsert";
      v85 = 1024;
      v86 = 2463;
      v87 = 1024;
      *(_DWORD *)v88 = a2;
      *(_WORD *)&v88[4] = 2048;
      *(_QWORD *)&v88[6] = data;
      v89 = 2048;
      v90 = v79;
      _os_log_error_impl(&dword_1B8270000, v13, OS_LOG_TYPE_ERROR, "%s:%d: vectorId=%u in datamap: %p size=%zd", __p, 0x2Cu);
    }
    *__error() = v12;
    if (v79 < 1)
    {
      v19 = *__error();
      v41 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__p = 136315394;
        *(_QWORD *)&__p[4] = "lookupForInsert";
        v85 = 1024;
        v86 = 2472;
        _os_log_error_impl(&dword_1B8270000, v41, OS_LOG_TYPE_ERROR, "%s:%d: vectorId is invalid", __p, 0x12u);
      }
    }
    else
    {
      if (v79 != 512)
      {
        v74 = __si_assert_copy_extra_268();
        v62 = v74;
        v75 = "";
        if (v74)
          v75 = v74;
        __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2465, "size == D * sizeof(ELEM_TYPE)", v75);
        goto LABEL_104;
      }
      if (!data || !memcmp(data, a3, 0x200uLL))
        goto LABEL_51;
      v14 = *__error();
      v15 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__p = 136315394;
        *(_QWORD *)&__p[4] = "lookupForInsert";
        v85 = 1024;
        v86 = 2467;
        _os_log_error_impl(&dword_1B8270000, v15, OS_LOG_TYPE_ERROR, "%s:%d: vector in datamap is not same as vector passed in", __p, 0x12u);
      }
      *__error() = v14;
      v16 = *__error();
      v17 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        data2hexString(__p, (uint64_t)data, v79);
        v18 = v88[3] >= 0 ? __p : *(_BYTE **)__p;
        *(_DWORD *)buf = 136315138;
        v83 = v18;
        _os_log_impl(&dword_1B8270000, v17, OS_LOG_TYPE_DEFAULT, "vector in datamap: %s", buf, 0xCu);
        if ((v88[3] & 0x80000000) != 0)
          operator delete(*(void **)__p);
      }
      *__error() = v16;
      v19 = *__error();
      v20 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        data2hexString(__p, (uint64_t)a3, v79);
        v21 = v88[3] >= 0 ? __p : *(_BYTE **)__p;
        *(_DWORD *)buf = 136315138;
        v83 = v21;
        _os_log_impl(&dword_1B8270000, v20, OS_LOG_TYPE_DEFAULT, "vector passed in: %s", buf, 0xCu);
        if ((v88[3] & 0x80000000) != 0)
          operator delete(*(void **)__p);
      }
    }
    *__error() = v19;
LABEL_51:
    v42 = data_map_get_data(*(_QWORD *)(a1 + 128), Ptr[132], &v79);
    v43 = *__error();
    v44 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
    {
      v58 = Ptr[132];
      *(_DWORD *)__p = 136316162;
      *(_QWORD *)&__p[4] = "lookupForInsert";
      v85 = 1024;
      v86 = 2475;
      v87 = 1024;
      *(_DWORD *)v88 = v58;
      *(_WORD *)&v88[4] = 2048;
      *(_QWORD *)&v88[6] = v42;
      v89 = 2048;
      v90 = v79;
      _os_log_error_impl(&dword_1B8270000, v44, OS_LOG_TYPE_ERROR, "%s:%d: old vectorId=%u in datamap: %p size=%zd", __p, 0x2Cu);
    }
    *__error() = v43;
    if (v79 < 1)
    {
      v51 = *__error();
      v54 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__p = 136315394;
        *(_QWORD *)&__p[4] = "lookupForInsert";
        v85 = 1024;
        v86 = 2484;
        _os_log_error_impl(&dword_1B8270000, v54, OS_LOG_TYPE_ERROR, "%s:%d: old vectorId is invalid", __p, 0x12u);
      }
      goto LABEL_73;
    }
    if (v79 == 512)
    {
      v45 = 512;
      if (!v42 || !memcmp(v42, Ptr, 0x200uLL))
        goto LABEL_74;
      v46 = *__error();
      v47 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__p = 136315394;
        *(_QWORD *)&__p[4] = "lookupForInsert";
        v85 = 1024;
        v86 = 2479;
        _os_log_error_impl(&dword_1B8270000, v47, OS_LOG_TYPE_ERROR, "%s:%d: vector in datamap is not same as vector passed in", __p, 0x12u);
      }
      *__error() = v46;
      v48 = *__error();
      v49 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
      {
        data2hexString(__p, (uint64_t)v42, v79);
        v50 = v88[3] >= 0 ? __p : *(_BYTE **)__p;
        *(_DWORD *)buf = 136315138;
        v83 = v50;
        _os_log_impl(&dword_1B8270000, v49, OS_LOG_TYPE_DEFAULT, "vector in datamap: %s", buf, 0xCu);
        if ((v88[3] & 0x80000000) != 0)
          operator delete(*(void **)__p);
      }
      *__error() = v48;
      v51 = *__error();
      v52 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
      {
        data2hexString(__p, (uint64_t)Ptr, v79);
        v53 = v88[3] >= 0 ? __p : *(_BYTE **)__p;
        *(_DWORD *)buf = 136315138;
        v83 = v53;
        _os_log_impl(&dword_1B8270000, v52, OS_LOG_TYPE_DEFAULT, "vector in vector store: %s", buf, 0xCu);
        if ((v88[3] & 0x80000000) != 0)
          operator delete(*(void **)__p);
      }
LABEL_73:
      *__error() = v51;
      v45 = v79;
LABEL_74:
      if (!memcmp(a3, Ptr, v45))
      {
        v55 = *__error();
        v56 = _SILogForLogForCategory(16);
        if (os_log_type_enabled(v56, OS_LOG_TYPE_FAULT))
        {
          v59 = Ptr[132];
          *(_DWORD *)__p = 136315906;
          *(_QWORD *)&__p[4] = "lookupForInsert";
          v85 = 1024;
          v86 = 2487;
          v87 = 1024;
          *(_DWORD *)v88 = a2;
          *(_WORD *)&v88[4] = 1024;
          *(_DWORD *)&v88[6] = v59;
          _os_log_fault_impl(&dword_1B8270000, v56, OS_LOG_TYPE_FAULT, "%s:%d: Dup vector with new vectorId=%u old=%u", __p, 0x1Eu);
        }
        *__error() = v55;
        return Ptr;
      }
      v71 = __si_assert_copy_extra_268();
      v65 = v71;
      v72 = "";
      if (v71)
        v72 = v71;
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2486, "memcmp(vec.vec, entry->vec.vec, size) == 0", v72);
LABEL_94:
      free(v65);
      if (__valid_fs(-1))
        v73 = 2989;
      else
        v73 = 3072;
      *(_DWORD *)v73 = -559038737;
      abort();
    }
    v76 = __si_assert_copy_extra_268();
    v62 = v76;
    v77 = "";
    if (v76)
      v77 = v76;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2477, "size == D * sizeof(ELEM_TYPE)", v77);
LABEL_104:
    free(v62);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v78 = a2;
  v22 = a3;
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  v23 = *(std::__shared_weak_count **)(a1 + 72);
  if (v23)
  {
    p_shared_owners = (unint64_t *)&v23->__shared_owners_;
    do
      v25 = __ldxr(p_shared_owners);
    while (__stxr(v25 + 1, p_shared_owners));
  }
  v27 = *(_DWORD **)(a1 + 80);
  v26 = *(std::__shared_weak_count **)(a1 + 88);
  if (v26)
  {
    v28 = (unint64_t *)&v26->__shared_owners_;
    do
      v29 = __ldxr(v28);
    while (__stxr(v29 + 1, v28));
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
  v30 = *(_QWORD *)(a1 + 32);
  OffsetFromEnd = vi_onefixedsize_memory_allocator::allocateOffsetFromEnd(*(_QWORD *)(v30 + 16), 0x214u);
  v32 = *(unsigned int *)(v30 + 24);
  if (OffsetFromEnd != v32)
  {
    v33 = *__error();
    v34 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
    {
      v60 = *(_DWORD *)(v30 + 24);
      *(_DWORD *)__p = 136315906;
      *(_QWORD *)&__p[4] = "newEntry";
      v85 = 1024;
      v86 = 1779;
      v87 = 2048;
      *(_QWORD *)v88 = OffsetFromEnd;
      *(_WORD *)&v88[8] = 1024;
      *(_DWORD *)&v88[10] = v60;
      _os_log_error_impl(&dword_1B8270000, v34, OS_LOG_TYPE_ERROR, "%s:%d: offset: %llu, nVectors: %u", __p, 0x22u);
    }
    *__error() = v33;
    v32 = *(unsigned int *)(v30 + 24);
    if (OffsetFromEnd != v32)
    {
      v69 = __si_assert_copy_extra_268();
      v62 = v69;
      v70 = "";
      if (v69)
        v70 = v69;
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1782, "offset == nVectors", v70);
      goto LABEL_104;
    }
  }
  *(_DWORD *)(v30 + 24) = v32 + 1;
  v35 = (_OWORD *)vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(v30 + 16), OffsetFromEnd, 532);
  memcpy(v35, v22, 0x200uLL);
  v35[32] = 0u;
  (*(void (**)(_DWORD *, uint64_t, size_t, float))(*(_QWORD *)v27 + 56))(v27, v9, OffsetFromEnd, v80);
  v36 = *(_QWORD *)(a1 + 32);
  if (v27[18] != *(_DWORD *)(v36 + 24))
  {
    v67 = __si_assert_copy_extra_268();
    v62 = v67;
    v68 = "";
    if (v67)
      v68 = v67;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2440, "cur.partitions->nVectors() == vectors->count()", v68);
    goto LABEL_104;
  }
  Ptr = (_DWORD *)vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(v36 + 16), OffsetFromEnd, 532);
  Ptr[132] = v78;
  if (*(_DWORD *)(*(_QWORD *)(a1 + 32) + 24) == 1)
    *(_DWORD *)(a1 + 148) = v78;
  *(_DWORD *)(a1 + 152) = v78;
  if (v26)
  {
    v37 = (unint64_t *)&v26->__shared_owners_;
    do
      v38 = __ldaxr(v37);
    while (__stlxr(v38 - 1, v37));
    if (!v38)
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
    }
  }
  if (v23)
  {
    v39 = (unint64_t *)&v23->__shared_owners_;
    do
      v40 = __ldaxr(v39);
    while (__stlxr(v40 - 1, v39));
    if (!v40)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
  return Ptr;
}

uint64_t _ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE10findVectorERK10CIVector_sIDF16_Li256EERjRfj(uint64_t a1, uint64_t a2, int *a3, _DWORD *a4, int a5)
{
  os_unfair_lock_s *v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  std::__shared_weak_count *v15;
  _DWORD *v16;
  unint64_t *v17;
  unint64_t v18;
  uint64_t v19;
  _DWORD *v20;
  unsigned int v21;
  uint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  unint64_t *v25;
  unint64_t v26;
  char *v28;
  char *v29;
  const char *v30;
  char *v31;
  const char *v32;
  char *v33;
  char *v34;
  const char *v35;
  int v36;
  int v37;
  int v38;
  int v39;
  _QWORD v40[8];
  int v41;
  _DWORD *v42;
  char *v43;
  uint64_t v44;
  int v45;

  v10 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  v12 = *(_QWORD *)(a1 + 64);
  v11 = *(std::__shared_weak_count **)(a1 + 72);
  if (v11)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      v14 = __ldxr(p_shared_owners);
    while (__stxr(v14 + 1, p_shared_owners));
  }
  v16 = *(_DWORD **)(a1 + 80);
  v15 = *(std::__shared_weak_count **)(a1 + 88);
  if (v15)
  {
    v17 = (unint64_t *)&v15->__shared_owners_;
    do
      v18 = __ldxr(v17);
    while (__stxr(v18 + 1, v17));
  }
  os_unfair_lock_unlock(v10);
  v19 = *a3;
  if ((_DWORD)v19 == -1)
  {
    if (*(_DWORD *)(a1 + 140) == -1)
    {
      v42 = 0;
      v43 = 0;
      v44 = 0;
      (*(void (**)(_DWORD **__return_ptr, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v12 + 72))(&v42, v12, a2, 1);
      v20 = v42;
      if (v43 - (char *)v42 == 8)
      {
        v21 = *v42;
        *a3 = *v42;
        *a4 = v20[1];
        if (v21 >= IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nPartitions(a1))
        {
          v33 = __si_assert_copy_extra_268();
          v34 = v33;
          if (v33)
            v35 = v33;
          else
            v35 = "";
          v36 = *a3;
          v37 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::nPartitions(a1);
          v38 = v16[19];
          v39 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v12 + 16))(v12);
          __message_assert("%s:%u: failed assertion '%s' %s Invalid partId %u >= %u (partitions: v%u quantizer v%u", "IVFVectorIndex.hh", 2403, "partID < nPartitions()", v35, v36, v37, v38, v39);
          free(v34);
          if (__valid_fs(-1))
          {
            MEMORY[0xBAD] = -559038737;
            abort();
          }
          MEMORY[0xC00] = -559038737;
          abort();
        }
        if (v42)
        {
          v43 = (char *)v42;
          operator delete(v42);
        }
        v19 = *a3;
        goto LABEL_14;
      }
      v31 = __si_assert_copy_extra_268();
      v29 = v31;
      v32 = "";
      if (v31)
        v32 = v31;
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2398, "topPartition.size() == 1", v32);
    }
    else
    {
      v28 = __si_assert_copy_extra_268();
      v29 = v28;
      v30 = "";
      if (v28)
        v30 = v28;
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2396, "mergeBeginVectorOffset == VECTOR_NOT_FOUND", v30);
    }
    free(v29);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
LABEL_14:
  v42 = 0;
  v43 = (char *)&v42;
  v45 = -1;
  v44 = 0x2000000000;
  v40[0] = MEMORY[0x1E0C809B0];
  v40[1] = 0x40000000;
  v40[2] = ___ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE10findVectorERK10CIVector_sIDF16_Li256EERjRfj_block_invoke;
  v40[3] = &unk_1E6E312A0;
  v41 = a5;
  v40[6] = a4;
  v40[7] = a2;
  v40[4] = &v42;
  v40[5] = a1;
  (*(void (**)(_DWORD *, uint64_t, _QWORD *))(*(_QWORD *)v16 + 80))(v16, v19, v40);
  v22 = *((unsigned int *)v43 + 6);
  _Block_object_dispose(&v42, 8);
  if (v15)
  {
    v23 = (unint64_t *)&v15->__shared_owners_;
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  if (v11)
  {
    v25 = (unint64_t *)&v11->__shared_owners_;
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  return v22;
}

unint64_t ___ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE10findVectorERK10CIVector_sIDF16_Li256EERjRfj_block_invoke(unint64_t result, uint64_t a2, float *a3, _BYTE *a4)
{
  uint64_t v5;
  uint64_t v6;
  unint64_t v8;
  float v9;
  float v10;
  BOOL v11;
  float v12;
  float v13;
  int v15;
  const void *v16;
  const void *Ptr;

  v5 = *(_QWORD *)(result + 40);
  v6 = *(unsigned int *)a3;
  if (v6 >= *(_DWORD *)(v5 + 140))
    goto LABEL_12;
  v8 = result;
  v9 = **(float **)(result + 48);
  v10 = a3[1];
  v11 = v9 == v10;
  v12 = vabds_f32(v9, v10);
  v13 = fmaxf(fminf(fabsf(v10), fabsf(v9)) * 0.000015259, 0.000015259);
  if (v11 || v12 <= v13)
  {
    v15 = *(_DWORD *)(result + 64);
    if (v15)
    {
      result = vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(*(_QWORD *)(v5 + 32) + 16), v6, 532);
      if (v15 != *(_DWORD *)(result + 528))
        return result;
      *(float *)&v6 = *a3;
    }
    v16 = *(const void **)(v8 + 56);
    Ptr = (const void *)vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(*(_QWORD *)(v5 + 32) + 16), v6, 532);
    result = memcmp(v16, Ptr, 0x200uLL);
    if (!(_DWORD)result)
    {
      *(float *)(*(_QWORD *)(*(_QWORD *)(v8 + 32) + 8) + 24) = *a3;
LABEL_12:
      *a4 = 1;
    }
  }
  return result;
}

int *_ZN22IVFVectorIndexTemplateIDF16_Li256EE11VectorStoreI32vi_onefixedsize_memory_allocator18vi_memory_postingsE8truncateEv(uint64_t a1)
{
  int v2;
  NSObject *v3;
  _QWORD *v4;
  int v5;
  int v6;
  int v7;
  int *result;
  int v9;
  _QWORD *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  int v14;
  __int16 v15;
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v2 = *__error();
  v3 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = (_QWORD *)(a1 + 40);
    if (*(char *)(a1 + 63) < 0)
      v4 = (_QWORD *)*v4;
    v5 = *(_DWORD *)(a1 + 24);
    v6 = *(_DWORD *)(vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(a1 + 16), 0, 532) + 528);
    v7 = *(_DWORD *)(vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(a1 + 16), (*(_DWORD *)(a1 + 24) - 1), 532)+ 528);
    v9 = 136315906;
    v10 = v4;
    v11 = 1024;
    v12 = v5;
    v13 = 1024;
    v14 = v6;
    v15 = 1024;
    v16 = v7;
    _os_log_impl(&dword_1B8270000, v3, OS_LOG_TYPE_DEFAULT, "truncate VectorStore %s(%u)[%u,%u]", (uint8_t *)&v9, 0x1Eu);
  }
  result = __error();
  *result = v2;
  return result;
}

void ___ZNK22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE4dumpEbbPViPvU13block_pointerFbjPKvybjfE_block_invoke()
{
  char *v0;
  char *v1;
  const char *v2;

  v0 = __si_assert_copy_extra_268();
  v1 = v0;
  v2 = "";
  if (v0)
    v2 = v0;
  __message_assert("%s:%u: failed assertion '%s' %s ", "VectorIndexSupport.hh", 2544, "0", v2);
  free(v1);
  if (__valid_fs(-1))
  {
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  MEMORY[0xC00] = -559038737;
  abort();
}

BOOL _ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE6existsERK10CIVector_sIDF16_Li256EE(uint64_t a1, uint64_t a2)
{
  int v4;
  int v6;
  NSObject *v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  std::__shared_weak_count *v12;
  uint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  unsigned int v16;
  uint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  _QWORD v32[8];
  std::__shared_weak_count *v33;
  uint64_t v34;
  std::__shared_weak_count *v35;
  unsigned int v36;
  _QWORD v37[7];
  unsigned int v38;
  float v39;
  float v40;
  unsigned int v41;
  _BYTE buf[24];
  _DWORD v43[4];
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  v40 = 3.4028e38;
  v41 = -1;
  v4 = _ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE10findVectorERK10CIVector_sIDF16_Li256EERjRfj(a1, a2, (int *)&v41, &v40, 0);
  if (v4 == -1)
  {
    v6 = *__error();
    v7 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = "exists";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 2632;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v41;
      LOWORD(v43[0]) = 2048;
      *(double *)((char *)v43 + 2) = v40;
      _os_log_error_impl(&dword_1B8270000, v7, OS_LOG_TYPE_ERROR, "%s:%d: Vector not found partID=%u distsq=%e", buf, 0x22u);
    }
    *__error() = v6;
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
    v9 = *(_QWORD *)(a1 + 64);
    v8 = *(std::__shared_weak_count **)(a1 + 72);
    if (v8)
    {
      p_shared_owners = (unint64_t *)&v8->__shared_owners_;
      do
        v11 = __ldxr(p_shared_owners);
      while (__stxr(v11 + 1, p_shared_owners));
    }
    v13 = *(_QWORD *)(a1 + 80);
    v12 = *(std::__shared_weak_count **)(a1 + 88);
    if (v12)
    {
      v14 = (unint64_t *)&v12->__shared_owners_;
      do
        v15 = __ldxr(v14);
      while (__stxr(v15 + 1, v14));
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 96));
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    v43[0] = -1;
    *(_QWORD *)&buf[16] = 0x2000000000;
    v16 = v41;
    v17 = MEMORY[0x1E0C809B0];
    v37[0] = MEMORY[0x1E0C809B0];
    v37[1] = 0x40000000;
    v37[2] = ___ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE6existsERK10CIVector_sIDF16_Li256EE_block_invoke;
    v37[3] = &unk_1E6E31240;
    v37[5] = a1;
    v37[6] = a2;
    v38 = v41;
    v39 = v40;
    v37[4] = buf;
    (*(void (**)(uint64_t, _QWORD, _QWORD *))(*(_QWORD *)v13 + 80))(v13, v41, v37);
    if (*(_DWORD *)(*(_QWORD *)&buf[8] + 24) == -1)
    {
      v32[0] = v17;
      v32[1] = 1174405120;
      v32[2] = ___ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE6existsERK10CIVector_sIDF16_Li256EE_block_invoke_166;
      v32[3] = &unk_1E6E31268;
      v32[5] = a1;
      v32[6] = a2;
      v32[7] = v9;
      v33 = v8;
      if (v8)
      {
        v22 = (unint64_t *)&v8->__shared_owners_;
        do
          v23 = __ldxr(v22);
        while (__stxr(v23 + 1, v22));
      }
      v34 = v13;
      v35 = v12;
      if (v12)
      {
        v24 = (unint64_t *)&v12->__shared_owners_;
        do
          v25 = __ldxr(v24);
        while (__stxr(v25 + 1, v24));
      }
      v36 = v16;
      v32[4] = buf;
      (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v13 + 64))(v13, v32);
      v26 = v35;
      if (v35)
      {
        v27 = (unint64_t *)&v35->__shared_owners_;
        do
          v28 = __ldaxr(v27);
        while (__stlxr(v28 - 1, v27));
        if (!v28)
        {
          ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
          std::__shared_weak_count::__release_weak(v26);
        }
      }
      v29 = v33;
      if (v33)
      {
        v30 = (unint64_t *)&v33->__shared_owners_;
        do
          v31 = __ldaxr(v30);
        while (__stlxr(v31 - 1, v30));
        if (!v31)
        {
          ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
          std::__shared_weak_count::__release_weak(v29);
        }
      }
    }
    _Block_object_dispose(buf, 8);
    if (v12)
    {
      v18 = (unint64_t *)&v12->__shared_owners_;
      do
        v19 = __ldaxr(v18);
      while (__stlxr(v19 - 1, v18));
      if (!v19)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
    if (v8)
    {
      v20 = (unint64_t *)&v8->__shared_owners_;
      do
        v21 = __ldaxr(v20);
      while (__stlxr(v21 - 1, v20));
      if (!v21)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }
  }
  return v4 != -1;
}

void ___ZN22IVFVectorIndexTemplateIDF16_Li256EE20IVFVectorIndexRoot_sI32vi_onefixedsize_memory_allocator18vi_memory_postingsE6existsERK10CIVector_sIDF16_Li256EE_block_invoke_166(uint64_t a1, int a2, float *a3, _BYTE *a4)
{
  const void *v8;
  uint64_t v9;
  const void *Ptr;
  int v11;
  NSObject *v12;
  float16x8_t *v13;
  uint64_t v14;
  float16x8_t v15;
  float32x4_t v16;
  float16x8_t v17;
  float16x8_t v18;
  float16x8_t v19;
  float16x8_t v20;
  float16x8_t v21;
  float16x8_t v22;
  float16x8_t v23;
  float16x8_t v24;
  float16x8_t v25;
  float16x8_t v26;
  float16x8_t v27;
  float16x8_t v28;
  float16x8_t v29;
  float16x8_t v30;
  float16x8_t v31;
  float16x8_t v32;
  float16x8_t v33;
  float16x8_t v34;
  float16x8_t v35;
  float16x8_t v36;
  float16x8_t v37;
  float16x8_t v38;
  float16x8_t v39;
  float16x8_t v40;
  float16x8_t v41;
  float16x8_t v42;
  float16x8_t v43;
  float16x8_t v44;
  float16x8_t v45;
  float16x8_t v46;
  float16x8_t v47;
  float32x4_t v48;
  float16x8_t v49;
  float16x8_t v50;
  float16x8_t v51;
  float16x8_t v52;
  float16x8_t v53;
  float16x8_t v54;
  float16x8_t v55;
  float16x8_t v56;
  float16x8_t v57;
  float16x8_t v58;
  float16x8_t v59;
  float16x8_t v60;
  float16x8_t v61;
  float16x8_t v62;
  float16x8_t v63;
  float16x8_t v64;
  float16x8_t v65;
  float16x8_t v66;
  float16x8_t v67;
  float16x8_t v68;
  float16x8_t v69;
  float16x8_t v70;
  float16x8_t v71;
  float16x8_t v72;
  float16x8_t v73;
  float16x8_t v74;
  float16x8_t v75;
  float16x8_t v76;
  float16x8_t v77;
  float16x8_t v78;
  float v79;
  int v80;
  NSObject *v81;
  int v82;
  NSObject *v83;
  int v84;
  NSObject *v85;
  int v86;
  NSObject *v87;
  int v88;
  NSObject *v89;
  int v90;
  NSObject *v91;
  uint64_t v92;
  unint64_t v93;
  int v94;
  NSObject *v95;
  int v96;
  NSObject *v97;
  int v98;
  NSObject *v99;
  int v100;
  NSObject *v101;
  int v102;
  NSObject *v103;
  double v104;
  int v105;
  int v106;
  float v107;
  int v108;
  float v109;
  _BOOL4 v110;
  int v111;
  int v112;
  _BOOL4 v113;
  int v114;
  int v115;
  _BOOL4 v116;
  int v117;
  int v118;
  _BOOL4 v119;
  int v120;
  int v121;
  float v122;
  float v123;
  double v124;
  float v125;
  _BOOL4 v126;
  _BOOL4 v127;
  float v128;
  float v129;
  int v130;
  float v131;
  _BOOL4 v132;
  float v133;
  int v134;
  _BOOL4 v135;
  float v136;
  int v137;
  _BOOL4 v138;
  float v139;
  int v140;
  _BOOL4 v141;
  float v142;
  int v143;
  float v144;
  float v145;
  float v146;
  _BOOL4 v147;
  _BOOL4 v148;
  _BOOL4 v149;
  float v150;
  float v151;
  float v152;
  float v153;
  float *__C;
  float *v155;
  uint64_t v156;
  float32x4_t __B;
  float32x4_t v158;
  float32x4_t v159;
  float32x4_t v160;
  float32x4_t v161;
  float32x4_t v162;
  float32x4_t v163;
  float32x4_t v164;
  float32x4_t v165;
  float32x4_t v166;
  float32x4_t v167;
  float32x4_t v168;
  float32x4_t v169;
  float32x4_t v170;
  float32x4_t v171;
  float32x4_t v172;
  float32x4_t v173;
  float32x4_t v174;
  float32x4_t v175;
  float32x4_t v176;
  float32x4_t v177;
  float32x4_t v178;
  float32x4_t v179;
  float32x4_t v180;
  float32x4_t v181;
  float32x4_t v182;
  float32x4_t v183;
  float32x4_t v184;
  float32x4_t v185;
  float32x4_t v186;
  float32x4_t v187;
  float32x4_t v188;
  float32x4_t v189;
  float32x4_t v190;
  float32x4_t v191;
  float32x4_t v192;
  float32x4_t v193;
  float32x4_t v194;
  float32x4_t v195;
  float32x4_t v196;
  float32x4_t v197;
  float32x4_t v198;
  float32x4_t v199;
  float32x4_t v200;
  float32x4_t v201;
  float32x4_t v202;
  float32x4_t v203;
  float32x4_t v204;
  float32x4_t v205;
  float32x4_t v206;
  float32x4_t v207;
  float32x4_t v208;
  float32x4_t v209;
  float32x4_t v210;
  float32x4_t v211;
  float32x4_t v212;
  float32x4_t v213;
  float32x4_t v214;
  float32x4_t v215;
  float32x4_t v216;
  float32x4_t v217;
  float32x4_t v218;
  float32x4_t v219;
  float32x4_t v220;
  _BYTE __A[80];
  float32x4_t v222;
  float32x4_t v223;
  float32x4_t v224;
  float32x4_t v225;
  float32x4_t v226;
  float32x4_t v227;
  float32x4_t v228;
  float32x4_t v229;
  float32x4_t v230;
  float32x4_t v231;
  float32x4_t v232;
  float32x4_t v233;
  float32x4_t v234;
  float32x4_t v235;
  float32x4_t v236;
  float32x4_t v237;
  float32x4_t v238;
  float32x4_t v239;
  float32x4_t v240;
  float32x4_t v241;
  float32x4_t v242;
  float32x4_t v243;
  float32x4_t v244;
  float32x4_t v245;
  float32x4_t v246;
  float32x4_t v247;
  float32x4_t v248;
  float32x4_t v249;
  float32x4_t v250;
  float32x4_t v251;
  float32x4_t v252;
  float32x4_t v253;
  float32x4_t v254;
  float32x4_t v255;
  float32x4_t v256;
  float32x4_t v257;
  float32x4_t v258;
  float32x4_t v259;
  float32x4_t v260;
  float32x4_t v261;
  float32x4_t v262;
  float32x4_t v263;
  float32x4_t v264;
  float32x4_t v265;
  float32x4_t v266;
  float32x4_t v267;
  float32x4_t v268;
  float32x4_t v269;
  float32x4_t v270;
  float32x4_t v271;
  float32x4_t v272;
  float32x4_t v273;
  float32x4_t v274;
  float32x4_t v275;
  float32x4_t v276;
  float32x4_t v277;
  float32x4_t v278;
  float32x4_t v279;
  float32x4_t v280;
  uint64_t v281;

  v281 = *MEMORY[0x1E0C80C00];
  v9 = *(_QWORD *)(a1 + 40);
  v8 = *(const void **)(a1 + 48);
  Ptr = (const void *)vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(*(_QWORD *)(v9 + 32) + 16), *(unsigned int *)a3, 532);
  if (!memcmp(v8, Ptr, 0x200uLL))
  {
    v11 = *__error();
    v12 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      v104 = a3[1];
      *(_DWORD *)__A = 136315906;
      *(_QWORD *)&__A[4] = "exists_block_invoke";
      *(_WORD *)&__A[12] = 1024;
      *(_DWORD *)&__A[14] = 2647;
      *(_WORD *)&__A[18] = 1024;
      *(_DWORD *)&__A[20] = a2;
      *(_WORD *)&__A[24] = 2048;
      *(double *)&__A[26] = v104;
      _os_log_error_impl(&dword_1B8270000, v12, OS_LOG_TYPE_ERROR, "%s:%d: Vector not found actually in partID=%u distsq=%e", __A, 0x22u);
    }
    *__error() = v11;
    v13 = *(float16x8_t **)(a1 + 48);
    v14 = (*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 56) + 64))(*(_QWORD *)(a1 + 56), *(unsigned int *)(a1 + 88));
    bzero(__A, 0x400uLL);
    v15 = v13[1];
    v16 = vcvt_hight_f32_f16(*v13);
    *(float32x4_t *)__A = vcvtq_f32_f16(*(float16x4_t *)v13->i8);
    *(float32x4_t *)&__A[16] = v16;
    *(float32x4_t *)&__A[32] = vcvtq_f32_f16(*(float16x4_t *)v15.i8);
    *(float32x4_t *)&__A[48] = vcvt_hight_f32_f16(v15);
    v17 = v13[2];
    v18 = v13[3];
    *(float32x4_t *)&__A[64] = vcvtq_f32_f16(*(float16x4_t *)v17.i8);
    v222 = vcvt_hight_f32_f16(v17);
    v223 = vcvtq_f32_f16(*(float16x4_t *)v18.i8);
    v224 = vcvt_hight_f32_f16(v18);
    v19 = v13[4];
    v20 = v13[5];
    v225 = vcvtq_f32_f16(*(float16x4_t *)v19.i8);
    v226 = vcvt_hight_f32_f16(v19);
    v227 = vcvtq_f32_f16(*(float16x4_t *)v20.i8);
    v228 = vcvt_hight_f32_f16(v20);
    v21 = v13[6];
    v22 = v13[7];
    v229 = vcvtq_f32_f16(*(float16x4_t *)v21.i8);
    v230 = vcvt_hight_f32_f16(v21);
    v231 = vcvtq_f32_f16(*(float16x4_t *)v22.i8);
    v232 = vcvt_hight_f32_f16(v22);
    v23 = v13[8];
    v24 = v13[9];
    v233 = vcvtq_f32_f16(*(float16x4_t *)v23.i8);
    v234 = vcvt_hight_f32_f16(v23);
    v235 = vcvtq_f32_f16(*(float16x4_t *)v24.i8);
    v236 = vcvt_hight_f32_f16(v24);
    v25 = v13[10];
    v26 = v13[11];
    v237 = vcvtq_f32_f16(*(float16x4_t *)v25.i8);
    v238 = vcvt_hight_f32_f16(v25);
    v239 = vcvtq_f32_f16(*(float16x4_t *)v26.i8);
    v240 = vcvt_hight_f32_f16(v26);
    v27 = v13[12];
    v28 = v13[13];
    v241 = vcvtq_f32_f16(*(float16x4_t *)v27.i8);
    v242 = vcvt_hight_f32_f16(v27);
    v243 = vcvtq_f32_f16(*(float16x4_t *)v28.i8);
    v244 = vcvt_hight_f32_f16(v28);
    v29 = v13[14];
    v30 = v13[15];
    v245 = vcvtq_f32_f16(*(float16x4_t *)v29.i8);
    v246 = vcvt_hight_f32_f16(v29);
    v247 = vcvtq_f32_f16(*(float16x4_t *)v30.i8);
    v248 = vcvt_hight_f32_f16(v30);
    v31 = v13[16];
    v32 = v13[17];
    v249 = vcvtq_f32_f16(*(float16x4_t *)v31.i8);
    v250 = vcvt_hight_f32_f16(v31);
    v251 = vcvtq_f32_f16(*(float16x4_t *)v32.i8);
    v252 = vcvt_hight_f32_f16(v32);
    v33 = v13[18];
    v34 = v13[19];
    v253 = vcvtq_f32_f16(*(float16x4_t *)v33.i8);
    v254 = vcvt_hight_f32_f16(v33);
    v255 = vcvtq_f32_f16(*(float16x4_t *)v34.i8);
    v256 = vcvt_hight_f32_f16(v34);
    v35 = v13[20];
    v36 = v13[21];
    v257 = vcvtq_f32_f16(*(float16x4_t *)v35.i8);
    v258 = vcvt_hight_f32_f16(v35);
    v259 = vcvtq_f32_f16(*(float16x4_t *)v36.i8);
    v260 = vcvt_hight_f32_f16(v36);
    v37 = v13[22];
    v38 = v13[23];
    v261 = vcvtq_f32_f16(*(float16x4_t *)v37.i8);
    v262 = vcvt_hight_f32_f16(v37);
    v263 = vcvtq_f32_f16(*(float16x4_t *)v38.i8);
    v264 = vcvt_hight_f32_f16(v38);
    v39 = v13[24];
    v40 = v13[25];
    v265 = vcvtq_f32_f16(*(float16x4_t *)v39.i8);
    v266 = vcvt_hight_f32_f16(v39);
    v267 = vcvtq_f32_f16(*(float16x4_t *)v40.i8);
    v268 = vcvt_hight_f32_f16(v40);
    v41 = v13[26];
    v42 = v13[27];
    v269 = vcvtq_f32_f16(*(float16x4_t *)v41.i8);
    v270 = vcvt_hight_f32_f16(v41);
    v271 = vcvtq_f32_f16(*(float16x4_t *)v42.i8);
    v272 = vcvt_hight_f32_f16(v42);
    v43 = v13[28];
    v44 = v13[29];
    v273 = vcvtq_f32_f16(*(float16x4_t *)v43.i8);
    v274 = vcvt_hight_f32_f16(v43);
    v275 = vcvtq_f32_f16(*(float16x4_t *)v44.i8);
    v276 = vcvt_hight_f32_f16(v44);
    v45 = v13[30];
    v46 = v13[31];
    v277 = vcvtq_f32_f16(*(float16x4_t *)v45.i8);
    v278 = vcvt_hight_f32_f16(v45);
    v279 = vcvtq_f32_f16(*(float16x4_t *)v46.i8);
    v280 = vcvt_hight_f32_f16(v46);
    bzero(&__B, 0x400uLL);
    v47 = *(float16x8_t *)(v14 + 16);
    v48 = vcvt_hight_f32_f16(*(float16x8_t *)v14);
    __B = vcvtq_f32_f16(*(float16x4_t *)v14);
    v158 = v48;
    v159 = vcvtq_f32_f16(*(float16x4_t *)v47.i8);
    v160 = vcvt_hight_f32_f16(v47);
    v49 = *(float16x8_t *)(v14 + 32);
    v50 = *(float16x8_t *)(v14 + 48);
    v161 = vcvtq_f32_f16(*(float16x4_t *)v49.i8);
    v162 = vcvt_hight_f32_f16(v49);
    v164 = vcvt_hight_f32_f16(v50);
    v163 = vcvtq_f32_f16(*(float16x4_t *)v50.i8);
    v51 = *(float16x8_t *)(v14 + 64);
    v52 = *(float16x8_t *)(v14 + 80);
    v165 = vcvtq_f32_f16(*(float16x4_t *)v51.i8);
    v166 = vcvt_hight_f32_f16(v51);
    v167 = vcvtq_f32_f16(*(float16x4_t *)v52.i8);
    v168 = vcvt_hight_f32_f16(v52);
    v53 = *(float16x8_t *)(v14 + 96);
    v54 = *(float16x8_t *)(v14 + 112);
    v169 = vcvtq_f32_f16(*(float16x4_t *)v53.i8);
    v170 = vcvt_hight_f32_f16(v53);
    v171 = vcvtq_f32_f16(*(float16x4_t *)v54.i8);
    v172 = vcvt_hight_f32_f16(v54);
    v55 = *(float16x8_t *)(v14 + 128);
    v56 = *(float16x8_t *)(v14 + 144);
    v173 = vcvtq_f32_f16(*(float16x4_t *)v55.i8);
    v174 = vcvt_hight_f32_f16(v55);
    v175 = vcvtq_f32_f16(*(float16x4_t *)v56.i8);
    v176 = vcvt_hight_f32_f16(v56);
    v57 = *(float16x8_t *)(v14 + 160);
    v58 = *(float16x8_t *)(v14 + 176);
    v177 = vcvtq_f32_f16(*(float16x4_t *)v57.i8);
    v178 = vcvt_hight_f32_f16(v57);
    v179 = vcvtq_f32_f16(*(float16x4_t *)v58.i8);
    v180 = vcvt_hight_f32_f16(v58);
    v59 = *(float16x8_t *)(v14 + 192);
    v60 = *(float16x8_t *)(v14 + 208);
    v181 = vcvtq_f32_f16(*(float16x4_t *)v59.i8);
    v182 = vcvt_hight_f32_f16(v59);
    v183 = vcvtq_f32_f16(*(float16x4_t *)v60.i8);
    v184 = vcvt_hight_f32_f16(v60);
    v61 = *(float16x8_t *)(v14 + 224);
    v62 = *(float16x8_t *)(v14 + 240);
    v185 = vcvtq_f32_f16(*(float16x4_t *)v61.i8);
    v186 = vcvt_hight_f32_f16(v61);
    v187 = vcvtq_f32_f16(*(float16x4_t *)v62.i8);
    v188 = vcvt_hight_f32_f16(v62);
    v63 = *(float16x8_t *)(v14 + 256);
    v64 = *(float16x8_t *)(v14 + 272);
    v189 = vcvtq_f32_f16(*(float16x4_t *)v63.i8);
    v190 = vcvt_hight_f32_f16(v63);
    v191 = vcvtq_f32_f16(*(float16x4_t *)v64.i8);
    v192 = vcvt_hight_f32_f16(v64);
    v65 = *(float16x8_t *)(v14 + 288);
    v66 = *(float16x8_t *)(v14 + 304);
    v193 = vcvtq_f32_f16(*(float16x4_t *)v65.i8);
    v194 = vcvt_hight_f32_f16(v65);
    v195 = vcvtq_f32_f16(*(float16x4_t *)v66.i8);
    v196 = vcvt_hight_f32_f16(v66);
    v67 = *(float16x8_t *)(v14 + 320);
    v68 = *(float16x8_t *)(v14 + 336);
    v197 = vcvtq_f32_f16(*(float16x4_t *)v67.i8);
    v198 = vcvt_hight_f32_f16(v67);
    v199 = vcvtq_f32_f16(*(float16x4_t *)v68.i8);
    v200 = vcvt_hight_f32_f16(v68);
    v69 = *(float16x8_t *)(v14 + 352);
    v70 = *(float16x8_t *)(v14 + 368);
    v201 = vcvtq_f32_f16(*(float16x4_t *)v69.i8);
    v202 = vcvt_hight_f32_f16(v69);
    v203 = vcvtq_f32_f16(*(float16x4_t *)v70.i8);
    v204 = vcvt_hight_f32_f16(v70);
    v71 = *(float16x8_t *)(v14 + 384);
    v72 = *(float16x8_t *)(v14 + 400);
    v205 = vcvtq_f32_f16(*(float16x4_t *)v71.i8);
    v206 = vcvt_hight_f32_f16(v71);
    v207 = vcvtq_f32_f16(*(float16x4_t *)v72.i8);
    v208 = vcvt_hight_f32_f16(v72);
    v73 = *(float16x8_t *)(v14 + 416);
    v74 = *(float16x8_t *)(v14 + 432);
    v209 = vcvtq_f32_f16(*(float16x4_t *)v73.i8);
    v210 = vcvt_hight_f32_f16(v73);
    v211 = vcvtq_f32_f16(*(float16x4_t *)v74.i8);
    v212 = vcvt_hight_f32_f16(v74);
    v75 = *(float16x8_t *)(v14 + 448);
    v76 = *(float16x8_t *)(v14 + 464);
    v213 = vcvtq_f32_f16(*(float16x4_t *)v75.i8);
    v214 = vcvt_hight_f32_f16(v75);
    v215 = vcvtq_f32_f16(*(float16x4_t *)v76.i8);
    v216 = vcvt_hight_f32_f16(v76);
    v77 = *(float16x8_t *)(v14 + 480);
    v78 = *(float16x8_t *)(v14 + 496);
    v217 = vcvtq_f32_f16(*(float16x4_t *)v77.i8);
    v218 = vcvt_hight_f32_f16(v77);
    v219 = vcvtq_f32_f16(*(float16x4_t *)v78.i8);
    v220 = vcvt_hight_f32_f16(v78);
    LODWORD(__C) = 2139095039;
    vDSP_distancesq((const float *)__A, 1, __B.f32, 1, (float *)&__C, 0x100uLL);
    v79 = *(float *)&__C;
    v80 = *__error();
    v81 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v81, OS_LOG_TYPE_ERROR))
    {
      v105 = *(_DWORD *)(a1 + 88);
      *(_DWORD *)__A = 136315906;
      *(_QWORD *)&__A[4] = "exists_block_invoke";
      *(_WORD *)&__A[12] = 1024;
      *(_DWORD *)&__A[14] = 2649;
      *(_WORD *)&__A[18] = 1024;
      *(_DWORD *)&__A[20] = v105;
      *(_WORD *)&__A[24] = 2048;
      *(double *)&__A[26] = v79;
      _os_log_error_impl(&dword_1B8270000, v81, OS_LOG_TYPE_ERROR, "%s:%d: Vec distance to centroid %u distsq=%e", __A, 0x22u);
    }
    *__error() = v80;
    __B = 0uLL;
    v158.i64[0] = 0;
    (*(void (**)(float32x4_t *__return_ptr, _QWORD, _QWORD, uint64_t))(**(_QWORD **)(a1 + 56) + 72))(&__B, *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 48), 2);
    v82 = *__error();
    v83 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v83, OS_LOG_TYPE_ERROR))
    {
      v106 = *(_DWORD *)__B.i64[0];
      v107 = *(float *)(__B.i64[0] + 4);
      v108 = *(_DWORD *)(__B.i64[0] + 8);
      v109 = *(float *)(__B.i64[0] + 12);
      v110 = v107 == v109 || vabds_f32(v107, v109) <= fmaxf(fminf(fabsf(v109), fabsf(v107)) * 0.000015259, 0.000015259);
      *(_DWORD *)__A = 136316674;
      *(_QWORD *)&__A[4] = "exists_block_invoke";
      *(_WORD *)&__A[12] = 1024;
      *(_DWORD *)&__A[14] = 2651;
      *(_WORD *)&__A[18] = 1024;
      *(_DWORD *)&__A[20] = v106;
      *(_WORD *)&__A[24] = 2048;
      *(double *)&__A[26] = v107;
      *(_WORD *)&__A[34] = 1024;
      *(_DWORD *)&__A[36] = v108;
      *(_WORD *)&__A[40] = 2048;
      *(double *)&__A[42] = v109;
      *(_WORD *)&__A[50] = 1024;
      *(_DWORD *)&__A[52] = v110;
      _os_log_error_impl(&dword_1B8270000, v83, OS_LOG_TYPE_ERROR, "%s:%d: topKPartition(vec, 2) <%u, %e>, <%u, %e>, %d", __A, 0x38u);
    }
    *__error() = v82;
    v84 = *__error();
    v85 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v85, OS_LOG_TYPE_ERROR))
    {
      v111 = *(_DWORD *)__B.i64[0];
      v112 = *(_DWORD *)(__B.i64[0] + 8);
      v113 = *(float *)(__B.i64[0] + 4) == *(float *)(__B.i64[0] + 12);
      *(_DWORD *)__A = 136316162;
      *(_QWORD *)&__A[4] = "exists_block_invoke";
      *(_WORD *)&__A[12] = 1024;
      *(_DWORD *)&__A[14] = 2652;
      *(_WORD *)&__A[18] = 1024;
      *(_DWORD *)&__A[20] = v111;
      *(_WORD *)&__A[24] = 1024;
      *(_DWORD *)&__A[26] = v112;
      *(_WORD *)&__A[30] = 1024;
      *(_DWORD *)&__A[32] = v113;
      _os_log_error_impl(&dword_1B8270000, v85, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) == distsq(%u) is %d", __A, 0x24u);
    }
    *__error() = v84;
    v86 = *__error();
    v87 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v87, OS_LOG_TYPE_ERROR))
    {
      v114 = *(_DWORD *)__B.i64[0];
      v115 = *(_DWORD *)(__B.i64[0] + 8);
      v116 = *(float *)(__B.i64[0] + 4) < *(float *)(__B.i64[0] + 12);
      *(_DWORD *)__A = 136316162;
      *(_QWORD *)&__A[4] = "exists_block_invoke";
      *(_WORD *)&__A[12] = 1024;
      *(_DWORD *)&__A[14] = 2653;
      *(_WORD *)&__A[18] = 1024;
      *(_DWORD *)&__A[20] = v114;
      *(_WORD *)&__A[24] = 1024;
      *(_DWORD *)&__A[26] = v115;
      *(_WORD *)&__A[30] = 1024;
      *(_DWORD *)&__A[32] = v116;
      _os_log_error_impl(&dword_1B8270000, v87, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) < distsq(%u) is %d", __A, 0x24u);
    }
    *__error() = v86;
    v88 = *__error();
    v89 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v89, OS_LOG_TYPE_ERROR))
    {
      v117 = *(_DWORD *)__B.i64[0];
      v118 = *(_DWORD *)(__B.i64[0] + 8);
      v119 = *(float *)(__B.i64[0] + 4) > *(float *)(__B.i64[0] + 12);
      *(_DWORD *)__A = 136316162;
      *(_QWORD *)&__A[4] = "exists_block_invoke";
      *(_WORD *)&__A[12] = 1024;
      *(_DWORD *)&__A[14] = 2654;
      *(_WORD *)&__A[18] = 1024;
      *(_DWORD *)&__A[20] = v117;
      *(_WORD *)&__A[24] = 1024;
      *(_DWORD *)&__A[26] = v118;
      *(_WORD *)&__A[30] = 1024;
      *(_DWORD *)&__A[32] = v119;
      _os_log_error_impl(&dword_1B8270000, v89, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) > distsq(%u) is %d", __A, 0x24u);
    }
    *__error() = v88;
    v90 = *__error();
    v91 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v91, OS_LOG_TYPE_ERROR))
    {
      v120 = *(_DWORD *)__B.i64[0];
      v121 = *(_DWORD *)(__B.i64[0] + 8);
      v122 = *(float *)(__B.i64[0] + 4);
      v123 = *(float *)(__B.i64[0] + 12);
      v124 = (float)(v122 - v123);
      v125 = vabds_f32(v122, v123);
      if (v122 == v123)
      {
        v126 = 1;
        v127 = 1;
      }
      else
      {
        v150 = fabsf(v122);
        v151 = fabsf(v123);
        v126 = v125 <= fmaxf(fminf(v151, v150) * 0.000015259, 0.000015259);
        v127 = v125 <= (float)(fmaxf(v150, v151) * 0.000015259);
      }
      *(_DWORD *)__A = 136317698;
      *(_QWORD *)&__A[4] = "exists_block_invoke";
      *(_WORD *)&__A[12] = 1024;
      *(_DWORD *)&__A[14] = 2655;
      *(_WORD *)&__A[18] = 1024;
      *(_DWORD *)&__A[20] = v120;
      *(_WORD *)&__A[24] = 1024;
      *(_DWORD *)&__A[26] = v121;
      *(_WORD *)&__A[30] = 2048;
      *(double *)&__A[32] = v124;
      *(_WORD *)&__A[40] = 2048;
      *(_QWORD *)&__A[42] = 0x3810000000000000;
      *(_WORD *)&__A[50] = 2048;
      *(_QWORD *)&__A[52] = 0x3E80000000000000;
      *(_WORD *)&__A[60] = 1024;
      *(_DWORD *)&__A[62] = v125 < 1.1755e-38;
      *(_WORD *)&__A[66] = 1024;
      *(_DWORD *)&__A[68] = v125 < 0.00000011921;
      *(_WORD *)&__A[72] = 1024;
      *(_DWORD *)&__A[74] = v126;
      *(_WORD *)&__A[78] = 1024;
      v222.i32[0] = v127;
      _os_log_error_impl(&dword_1B8270000, v91, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) - distsq(%u) = %e, FLT_MIN=%e, EPSILON=%e, %d, %d, %d, %d", __A, 0x54u);
    }
    *__error() = v90;
    v155 = 0;
    v156 = 0;
    __C = 0;
    v92 = *(_QWORD *)(a1 + 56);
    v93 = vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(*(_QWORD *)(v9 + 32) + 16), *(unsigned int *)a3, 532);
    (*(void (**)(float **__return_ptr, uint64_t, unint64_t, uint64_t))(*(_QWORD *)v92 + 72))(&__C, v92, v93, 2);
    v94 = *__error();
    v95 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v95, OS_LOG_TYPE_ERROR))
    {
      v128 = *__C;
      v129 = __C[1];
      v130 = *((_DWORD *)__C + 2);
      v131 = __C[3];
      v132 = v129 == v131 || vabds_f32(v129, v131) <= fmaxf(fminf(fabsf(v131), fabsf(v129)) * 0.000015259, 0.000015259);
      *(_DWORD *)__A = 136316674;
      *(_QWORD *)&__A[4] = "exists_block_invoke";
      *(_WORD *)&__A[12] = 1024;
      *(_DWORD *)&__A[14] = 2658;
      *(_WORD *)&__A[18] = 1024;
      *(float *)&__A[20] = v128;
      *(_WORD *)&__A[24] = 2048;
      *(double *)&__A[26] = v129;
      *(_WORD *)&__A[34] = 1024;
      *(_DWORD *)&__A[36] = v130;
      *(_WORD *)&__A[40] = 2048;
      *(double *)&__A[42] = v131;
      *(_WORD *)&__A[50] = 1024;
      *(_DWORD *)&__A[52] = v132;
      _os_log_error_impl(&dword_1B8270000, v95, OS_LOG_TYPE_ERROR, "%s:%d: topKPartition(entry->vec, 2) <%u, %e>, <%u, %e>, %d", __A, 0x38u);
    }
    *__error() = v94;
    v96 = *__error();
    v97 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v97, OS_LOG_TYPE_ERROR))
    {
      v133 = *__C;
      v134 = *((_DWORD *)__C + 2);
      v135 = __C[1] == __C[3];
      *(_DWORD *)__A = 136316162;
      *(_QWORD *)&__A[4] = "exists_block_invoke";
      *(_WORD *)&__A[12] = 1024;
      *(_DWORD *)&__A[14] = 2659;
      *(_WORD *)&__A[18] = 1024;
      *(float *)&__A[20] = v133;
      *(_WORD *)&__A[24] = 1024;
      *(_DWORD *)&__A[26] = v134;
      *(_WORD *)&__A[30] = 1024;
      *(_DWORD *)&__A[32] = v135;
      _os_log_error_impl(&dword_1B8270000, v97, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) == distsq(%u) is %d", __A, 0x24u);
    }
    *__error() = v96;
    v98 = *__error();
    v99 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v99, OS_LOG_TYPE_ERROR))
    {
      v136 = *__C;
      v137 = *((_DWORD *)__C + 2);
      v138 = __C[1] < __C[3];
      *(_DWORD *)__A = 136316162;
      *(_QWORD *)&__A[4] = "exists_block_invoke";
      *(_WORD *)&__A[12] = 1024;
      *(_DWORD *)&__A[14] = 2660;
      *(_WORD *)&__A[18] = 1024;
      *(float *)&__A[20] = v136;
      *(_WORD *)&__A[24] = 1024;
      *(_DWORD *)&__A[26] = v137;
      *(_WORD *)&__A[30] = 1024;
      *(_DWORD *)&__A[32] = v138;
      _os_log_error_impl(&dword_1B8270000, v99, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) < distsq(%u) is %d", __A, 0x24u);
    }
    *__error() = v98;
    v100 = *__error();
    v101 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v101, OS_LOG_TYPE_ERROR))
    {
      v139 = *__C;
      v140 = *((_DWORD *)__C + 2);
      v141 = __C[1] > __C[3];
      *(_DWORD *)__A = 136316162;
      *(_QWORD *)&__A[4] = "exists_block_invoke";
      *(_WORD *)&__A[12] = 1024;
      *(_DWORD *)&__A[14] = 2661;
      *(_WORD *)&__A[18] = 1024;
      *(float *)&__A[20] = v139;
      *(_WORD *)&__A[24] = 1024;
      *(_DWORD *)&__A[26] = v140;
      *(_WORD *)&__A[30] = 1024;
      *(_DWORD *)&__A[32] = v141;
      _os_log_error_impl(&dword_1B8270000, v101, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) > distsq(%u) is %d", __A, 0x24u);
    }
    *__error() = v100;
    v102 = *__error();
    v103 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v103, OS_LOG_TYPE_ERROR))
    {
      v142 = *__C;
      v143 = *((_DWORD *)__C + 2);
      v144 = __C[1];
      v145 = __C[3];
      v146 = vabds_f32(v144, v145);
      v147 = (float)(v144 - v145) < 1.1755e-38;
      if (v144 == v145)
      {
        v148 = 1;
        v149 = 1;
      }
      else
      {
        v152 = fabsf(v144);
        v153 = fabsf(v145);
        v148 = v146 <= fmaxf(fminf(v153, v152) * 0.000015259, 0.000015259);
        v149 = v146 <= (float)(fmaxf(v152, v153) * 0.000015259);
      }
      *(_DWORD *)__A = 136317698;
      *(_QWORD *)&__A[4] = "exists_block_invoke";
      *(_WORD *)&__A[12] = 1024;
      *(_DWORD *)&__A[14] = 2662;
      *(_WORD *)&__A[18] = 1024;
      *(float *)&__A[20] = v142;
      *(_WORD *)&__A[24] = 1024;
      *(_DWORD *)&__A[26] = v143;
      *(_WORD *)&__A[30] = 2048;
      *(double *)&__A[32] = v146;
      *(_WORD *)&__A[40] = 2048;
      *(_QWORD *)&__A[42] = 0x3810000000000000;
      *(_WORD *)&__A[50] = 2048;
      *(_QWORD *)&__A[52] = 0x3E80000000000000;
      *(_WORD *)&__A[60] = 1024;
      *(_DWORD *)&__A[62] = v147;
      *(_WORD *)&__A[66] = 1024;
      *(_DWORD *)&__A[68] = v146 < 0.00000011921;
      *(_WORD *)&__A[72] = 1024;
      *(_DWORD *)&__A[74] = v148;
      *(_WORD *)&__A[78] = 1024;
      v222.i32[0] = v149;
      _os_log_error_impl(&dword_1B8270000, v103, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) - distsq(%u) = %e, FLT_MIN=%e, EPSILON=%e, %d, %d, %d, %d", __A, 0x54u);
    }
    *__error() = v102;
    *(float *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *a3;
    *a4 = 1;
    if (__C)
    {
      v155 = __C;
      operator delete(__C);
    }
    if (__B.i64[0])
    {
      __B.i64[1] = __B.i64[0];
      operator delete((void *)__B.i64[0]);
    }
  }
}

uint64_t ___ZNK23IVFVectorIndexUpdateSet3aNNEjtPKv14vec_dimensions15vec_data_formatfjbU13block_pointerFvPN18vi_memory_postings12storage_formEfE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void __vectorIndexANN_block_invoke(uint64_t a1, uint64_t *a2, size_t size, float a4)
{
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  char *v9;
  const char *v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  size_t v15;
  void *v16;
  uint64_t v17;
  _QWORD *v18;
  char *v19;
  const char *v20;
  char *v21;
  uint8_t buf[16];

  v4 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)v4)
  {
    v19 = __si_assert_copy_extra_268();
    v9 = v19;
    v20 = "";
    if (v19)
      v20 = v19;
    __message_assert("%s:%u: failed assertion '%s' %s ", "OQueue.h", 333, "oqueue->has_meta", v20);
LABEL_26:
    free(v9);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v6 = *a2;
  if (!*(_DWORD *)(v4 + 56))
  {
    v12 = *(_QWORD *)(v4 + 24);
    v7 = *(_QWORD *)(v4 + 32);
    if (v7 < v12)
      goto LABEL_18;
    v13 = 2 * v12;
    if (!v12)
      v13 = 4;
    *(_QWORD *)(v4 + 24) = v13;
    v14 = *(void **)(v4 + 16);
    v15 = 16 * v13;
    if (v14)
    {
      v16 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, v14, v15, 0xECA6AA46uLL);
      if (!v16)
      {
LABEL_15:
        if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_fault_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "allocation function returned null", buf, 2u);
        }
      }
    }
    else
    {
      v16 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v15, 0x8DDAA030uLL);
      if (!v16)
        goto LABEL_15;
    }
    *(_QWORD *)(v4 + 16) = v16;
    v7 = *(_QWORD *)(v4 + 32);
    goto LABEL_18;
  }
  if (*(_QWORD *)(v4 + 64) < (v6 & 0x3FFFFFFFFFFFFFFFuLL))
  {
    v21 = __si_assert_copy_extra_268();
    v9 = v21;
    v10 = "";
    if (v21)
      v10 = v21;
    v11 = "!queue->split || queue->splitPoint >= offset_with_meta_t_GET_VALUE(value)";
    goto LABEL_25;
  }
  v7 = *(_QWORD *)(v4 + 32);
  if (v7 >= *(_QWORD *)(v4 + 24))
  {
    v8 = __si_assert_copy_extra_268();
    v9 = v8;
    v10 = "";
    if (v8)
      v10 = v8;
    v11 = "!queue->split";
LABEL_25:
    __message_assert("%s:%u: failed assertion '%s' %s ", "OQueue.h", 245, v11, v10);
    goto LABEL_26;
  }
LABEL_18:
  v17 = *(_QWORD *)(v4 + 16);
  *(_QWORD *)(v4 + 32) = v7 + 1;
  v18 = (_QWORD *)(v17 + 16 * v7);
  *v18 = v6;
  v18[1] = LODWORD(a4);
}

uint64_t ___ZNK16IVFVectorIndex_s3aNNEjtPKv14vec_dimensions15vec_data_formatfjbP12__CIIndexSetU13block_pointerFvPyfE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t dumpVectorIndex(uint64_t result, unsigned int a2, _DWORD *a3, uint64_t a4, uint64_t a5)
{
  _QWORD *v5;
  uint64_t v6;
  _DWORD *v7;
  const char *v8;
  uint64_t v9;
  int v10;
  int v11;
  int v12;
  __int16 v13;
  int v14;
  int v15;
  int v16;
  char v17;
  int v18;
  NSObject *v19;
  _QWORD *v20;
  void **v21;
  _QWORD *v22;
  _QWORD *v23;
  BOOL v24;
  const char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v29;
  _QWORD *v30;
  _QWORD *v32;
  _QWORD v35[5];
  int v36;
  int v37;
  int v38;
  __int16 v39;
  char v40;
  void *__p[2];
  char v42;
  uint8_t buf[4];
  _QWORD *v44;
  __int16 v45;
  uint64_t v46;
  __int16 v47;
  void **v48;
  __int16 v49;
  const char *v50;
  __int16 v51;
  const char *v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v5 = *(_QWORD **)(result + 88);
  v29 = result;
  v32 = (_QWORD *)(result + 96);
  if (v5 != (_QWORD *)(result + 96))
  {
    v6 = a5;
    v7 = a3;
    v30 = (_QWORD *)(result + 64);
    v26 = result + 40;
    v27 = result + 8;
    v8 = "centroids";
    if (!a2)
      v8 = "";
    v25 = v8;
    do
    {
      if (*v7)
        break;
      v9 = v5[5];
      v10 = *(_DWORD *)(v9 + 12);
      switch(v10)
      {
        case 256:
          v11 = 0;
          break;
        case 768:
          v11 = 2;
          break;
        case 512:
          v11 = 1;
          break;
        default:
          v11 = 3;
          break;
      }
      v12 = *(_DWORD *)(v9 + 8);
      v13 = *(_WORD *)(v9 + 20);
      v14 = *(_DWORD *)(v9 + 16);
      if (v14 == 2)
        v15 = 1;
      else
        v15 = 3;
      if (v14 == 4)
        v16 = 0;
      else
        v16 = v15;
      v17 = *(_BYTE *)(v9 + 22);
      v18 = *__error();
      v19 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        v20 = v30;
        if (*(char *)(v29 + 87) < 0)
          v20 = (_QWORD *)*v30;
        (*(void (**)(void **__return_ptr, uint64_t, uint64_t))(*(_QWORD *)v9 + 312))(__p, v9, v26);
        v21 = __p;
        if (v42 < 0)
          v21 = (void **)__p[0];
        *(_DWORD *)buf = 136316162;
        v44 = v20;
        v45 = 2048;
        v46 = v27;
        v47 = 2080;
        v48 = v21;
        v49 = 2080;
        v50 = "";
        v51 = 2080;
        v52 = v25;
        _os_log_impl(&dword_1B8270000, v19, OS_LOG_TYPE_DEFAULT, "[%s] dump %p %s %s %s", buf, 0x34u);
        if (v42 < 0)
          operator delete(__p[0]);
        v6 = a5;
      }
      *__error() = v18;
      v35[0] = MEMORY[0x1E0C809B0];
      v35[1] = 0x40000000;
      v35[2] = ___ZN16IVFVectorIndex_s4dumpEbbPViPvU13block_pointerFbjtjPKv14vec_dimensions15vec_data_formatybjfbE_block_invoke;
      v35[3] = &unk_1E6E30AA8;
      v35[4] = v6;
      v39 = v13;
      v36 = v12;
      v37 = v11;
      v38 = v16;
      v40 = v17;
      v7 = a3;
      result = (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, _DWORD *, uint64_t, _QWORD *))(*(_QWORD *)v9 + 128))(v9, 0, a2, a3, a4, v35);
      v22 = (_QWORD *)v5[1];
      if (v22)
      {
        do
        {
          v23 = v22;
          v22 = (_QWORD *)*v22;
        }
        while (v22);
      }
      else
      {
        do
        {
          v23 = (_QWORD *)v5[2];
          v24 = *v23 == (_QWORD)v5;
          v5 = v23;
        }
        while (!v24);
      }
      v5 = v23;
    }
    while (v23 != v32);
  }
  return result;
}

uint64_t ___ZN16IVFVectorIndex_s4dumpEbbPViPvU13block_pointerFbjtjPKv14vec_dimensions15vec_data_formatybjfbE_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, int a6)
{
  uint64_t v7;
  char v8;

  v8 = *(_BYTE *)(a1 + 54);
  HIDWORD(v7) = a6;
  LOBYTE(v7) = a5;
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, uint64_t, char))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), *(unsigned int *)(a1 + 40), *(unsigned __int16 *)(a1 + 52), a2, a3, *(unsigned int *)(a1 + 44), *(unsigned int *)(a1 + 48), a4, v7, v8);
}

void IVFVectorIndex_s::unlink(IVFVectorIndex_s *this, const char *a2, const char *a3)
{
  int v3;
  char *v6;
  char *v7;
  size_t v10;
  std::string::size_type v11;
  void *p_dst;
  uint64_t v13;
  uint64_t v14;
  size_t v15;
  std::string::size_type v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  std::string *v20;
  std::string::size_type v21;
  char v22;
  std::string v23;
  std::__fs::filesystem::path v24;
  std::string v25;
  _QWORD v26[4];
  std::string __p;
  char v28;
  std::__fs::filesystem::path __dst;
  std::string v30;
  _QWORD v31[3];

  v3 = (int)a3;
  v31[2] = *MEMORY[0x1E0C80C00];
  memset(&v30, 0, sizeof(v30));
  v6 = (char *)this - 1;
  v7 = (char *)this - 1;
  while (*++v7)
    ;
  std::string::append[abi:nn180100]<char const*,0>(&v30, (char *)this, v7);
  memset(&__dst, 0, sizeof(__dst));
  while (*++v6)
    ;
  std::string::append[abi:nn180100]<char const*,0>(&__dst.__pn_, (char *)this, v6);
  std::__fs::filesystem::__status(&__dst, 0);
  if (SHIBYTE(__dst.__pn_.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__dst.__pn_.__r_.__value_.__l.__data_);
    if (v25.__r_.__value_.__s.__data_[0] != 2)
      goto LABEL_40;
  }
  else if (v25.__r_.__value_.__s.__data_[0] != 2)
  {
LABEL_40:
    if ((SHIBYTE(v30.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      return;
    goto LABEL_41;
  }
  v10 = strlen(a2);
  if (v10 > 0x7FFFFFFFFFFFFFF7)
    goto LABEL_49;
  v11 = v10;
  if (v10 >= 0x17)
  {
    v13 = (v10 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v10 | 7) != 0x17)
      v13 = v10 | 7;
    v14 = v13 + 1;
    p_dst = operator new(v13 + 1);
    __dst.__pn_.__r_.__value_.__l.__size_ = v11;
    __dst.__pn_.__r_.__value_.__r.__words[2] = v14 | 0x8000000000000000;
    __dst.__pn_.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    goto LABEL_16;
  }
  *((_BYTE *)&__dst.__pn_.__r_.__value_.__s + 23) = v10;
  p_dst = &__dst;
  if (v10)
LABEL_16:
    memcpy(p_dst, a2, v11);
  *((_BYTE *)p_dst + v11) = 0;
  v26[0] = MEMORY[0x1E0C809B0];
  v26[1] = 1174405120;
  v26[2] = ___ZN16IVFVectorIndex_s6unlinkEPKcS1_b_block_invoke;
  v26[3] = &__block_descriptor_tmp_117;
  if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(&__p, v30.__r_.__value_.__l.__data_, v30.__r_.__value_.__l.__size_);
  else
    __p = v30;
  v28 = v3;
  IVFVectorIndex_s::enumerateIndexes((const std::__fs::filesystem::path *)&v30, (const void **)&__dst.__pn_.__r_.__value_.__l.__data_, v3, 0, (uint64_t)v26);
  if (SHIBYTE(__dst.__pn_.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__dst.__pn_.__r_.__value_.__l.__data_);
    if ((v3 & 1) != 0)
      goto LABEL_39;
  }
  else if ((v3 & 1) != 0)
  {
LABEL_39:
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_40;
    goto LABEL_44;
  }
  memset(&__dst, 0, sizeof(__dst));
  v15 = strlen(a2);
  if (v15 > 0x7FFFFFFFFFFFFFF7)
LABEL_49:
    abort();
  v16 = v15;
  if (v15 >= 0x17)
  {
    v18 = (v15 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v15 | 7) != 0x17)
      v18 = v15 | 7;
    v19 = v18 + 1;
    v17 = operator new(v18 + 1);
    v23.__r_.__value_.__l.__size_ = v16;
    v23.__r_.__value_.__r.__words[2] = v19 | 0x8000000000000000;
    v23.__r_.__value_.__r.__words[0] = (std::string::size_type)v17;
    goto LABEL_31;
  }
  *((_BYTE *)&v23.__r_.__value_.__s + 23) = v15;
  v17 = &v23;
  if (v15)
LABEL_31:
    memcpy(v17, a2, v16);
  *((_BYTE *)v17 + v16) = 0;
  v20 = std::string::append(&v23, "ivf-vector-indexes");
  v21 = v20->__r_.__value_.__r.__words[0];
  v31[0] = v20->__r_.__value_.__l.__size_;
  *(_QWORD *)((char *)v31 + 7) = *(std::string::size_type *)((char *)&v20->__r_.__value_.__r.__words[1] + 7);
  v22 = HIBYTE(v20->__r_.__value_.__r.__words[2]);
  v20->__r_.__value_.__l.__size_ = 0;
  v20->__r_.__value_.__r.__words[2] = 0;
  v20->__r_.__value_.__r.__words[0] = 0;
  v24.__pn_.__r_.__value_.__r.__words[0] = v21;
  v24.__pn_.__r_.__value_.__l.__size_ = v31[0];
  *(std::string::size_type *)((char *)&v24.__pn_.__r_.__value_.__r.__words[1] + 7) = *(_QWORD *)((char *)v31 + 7);
  *((_BYTE *)&v24.__pn_.__r_.__value_.__s + 23) = v22;
  std::__fs::filesystem::operator/[abi:nn180100](&v25, (uint64_t)&v30, &v24);
  if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0)
  {
    std::string::__init_copy_ctor_external(&__dst.__pn_, v25.__r_.__value_.__l.__data_, v25.__r_.__value_.__l.__size_);
    if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v25.__r_.__value_.__l.__data_);
      if (SHIBYTE(v24.__pn_.__r_.__value_.__r.__words[2]) < 0)
        goto LABEL_47;
    }
    else if (SHIBYTE(v24.__pn_.__r_.__value_.__r.__words[2]) < 0)
    {
      goto LABEL_47;
    }
  }
  else
  {
    __dst.__pn_ = v25;
    if (SHIBYTE(v24.__pn_.__r_.__value_.__r.__words[2]) < 0)
    {
LABEL_47:
      operator delete(v24.__pn_.__r_.__value_.__l.__data_);
      if ((SHIBYTE(v23.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_38;
      goto LABEL_48;
    }
  }
  if ((SHIBYTE(v23.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    goto LABEL_38;
LABEL_48:
  operator delete(v23.__r_.__value_.__l.__data_);
LABEL_38:
  IVFVectorIndex_s::unlink((char *)&__dst);
  if ((SHIBYTE(__dst.__pn_.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    goto LABEL_39;
  operator delete(__dst.__pn_.__r_.__value_.__l.__data_);
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    goto LABEL_40;
LABEL_44:
  operator delete(__p.__r_.__value_.__l.__data_);
  if (SHIBYTE(v30.__r_.__value_.__r.__words[2]) < 0)
LABEL_41:
    operator delete(v30.__r_.__value_.__l.__data_);
}

void ___ZN16IVFVectorIndex_s12changePrefixEPKc_block_invoke(uint64_t a1, unsigned int a2, unsigned int a3, int a4, int a5, uint64_t a6, const void **a7, uint64_t a8, char a9)
{
  int v9;
  size_t v10;
  unint64_t v11;
  int v13;
  unsigned int *v15;
  void **p_dst;
  uint64_t v17;
  unsigned int *v19;
  uint64_t v20;
  unint64_t v21;
  const void *v22;
  const char *v23;
  size_t v24;
  size_t v25;
  void *p_p;
  uint64_t v27;
  uint64_t v28;
  const std::string::value_type *v29;
  std::string::size_type v30;
  std::string *v31;
  std::string::size_type v32;
  const std::string::value_type *v33;
  std::string *v34;
  std::string::size_type v35;
  int v36;
  NSObject *v37;
  _QWORD *v38;
  void **v39;
  void **v40;
  const char *v41;
  const char *v42;
  void **v43;
  void *__p;
  std::string::size_type v48;
  int64_t v49;
  std::string v50;
  void *v51[2];
  uint64_t v52;
  void **__dst;
  size_t v54;
  int64_t v55;
  std::string v56;
  void **v57;
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  v9 = *((char *)a7 + 23);
  if (v9 >= 0)
    v10 = *((unsigned __int8 *)a7 + 23);
  else
    v10 = (size_t)a7[1];
  v11 = v10 + 7;
  if (v10 + 7 > 0x7FFFFFFFFFFFFFF7)
LABEL_57:
    abort();
  v13 = a5;
  v15 = *(unsigned int **)(a1 + 32);
  if (v11 >= 0x17)
  {
    v17 = (v11 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v11 | 7) != 0x17)
      v17 = v11 | 7;
    v19 = *(unsigned int **)(a1 + 32);
    v20 = v17 + 1;
    p_dst = (void **)operator new(v17 + 1);
    v21 = v20 | 0x8000000000000000;
    v15 = v19;
    v13 = a5;
    v54 = v10 + 7;
    v55 = v21;
    __dst = p_dst;
  }
  else
  {
    v54 = 0;
    v55 = 0;
    __dst = 0;
    p_dst = (void **)&__dst;
    HIBYTE(v55) = v10 + 7;
    if (!v10)
      goto LABEL_15;
  }
  if (v9 >= 0)
    v22 = a7;
  else
    v22 = *a7;
  memmove(p_dst, v22, v10);
LABEL_15:
  strcpy((char *)p_dst + v10, ".shadow");
  v51[0] = 0;
  v51[1] = 0;
  v52 = 0;
  v23 = *(const char **)(a1 + 40);
  v24 = strlen(v23);
  if (v24 > 0x7FFFFFFFFFFFFFF7)
    goto LABEL_57;
  v25 = v24;
  if (v24 >= 0x17)
  {
    v27 = (v24 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v24 | 7) != 0x17)
      v27 = v24 | 7;
    v28 = v27 + 1;
    p_p = operator new(v27 + 1);
    v48 = v25;
    v49 = v28 | 0x8000000000000000;
    __p = p_p;
    goto LABEL_22;
  }
  HIBYTE(v49) = v24;
  p_p = &__p;
  if (v24)
LABEL_22:
    memmove(p_p, v23, v25);
  *((_BYTE *)p_p + v25) = 0;
  IVFIndexName((uint64_t)&v56, a2, a3, a4, v13);
  if (v49 >= 0)
    v29 = (const std::string::value_type *)&__p;
  else
    v29 = (const std::string::value_type *)__p;
  if (v49 >= 0)
    v30 = HIBYTE(v49);
  else
    v30 = v48;
  v31 = std::string::insert(&v56, 0, v29, v30);
  v32 = v31->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v50.__r_.__value_.__l.__data_ = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
  v50.__r_.__value_.__r.__words[2] = v32;
  v31->__r_.__value_.__l.__size_ = 0;
  v31->__r_.__value_.__r.__words[2] = 0;
  v31->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v56.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v56.__r_.__value_.__l.__data_);
  if (a9)
    v33 = ".partitions.shadow";
  else
    v33 = ".shadow";
  v34 = std::string::append(&v50, v33);
  v35 = v34->__r_.__value_.__r.__words[2];
  *(_OWORD *)v51 = *(_OWORD *)&v34->__r_.__value_.__l.__data_;
  v52 = v35;
  v34->__r_.__value_.__l.__size_ = 0;
  v34->__r_.__value_.__r.__words[2] = 0;
  v34->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v50.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v50.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v49) & 0x80000000) == 0)
      goto LABEL_36;
  }
  else if ((SHIBYTE(v49) & 0x80000000) == 0)
  {
    goto LABEL_36;
  }
  operator delete(__p);
LABEL_36:
  v36 = *__error();
  v37 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
  {
    v38 = v15 + 14;
    if (*((char *)v15 + 79) < 0)
      v38 = (_QWORD *)*v38;
    v39 = (void **)&__dst;
    if (v55 < 0)
      v39 = __dst;
    v40 = v51;
    if (v52 < 0)
      v40 = (void **)v51[0];
    LODWORD(v56.__r_.__value_.__l.__data_) = 136315650;
    *(std::string::size_type *)((char *)v56.__r_.__value_.__r.__words + 4) = (std::string::size_type)v38;
    WORD2(v56.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&v56.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v39;
    HIWORD(v56.__r_.__value_.__r.__words[2]) = 2080;
    v57 = v40;
    _os_log_impl(&dword_1B8270000, v37, OS_LOG_TYPE_DEFAULT, "[%s] rename file: %s to %s", (uint8_t *)&v56, 0x20u);
  }
  *__error() = v36;
  if (v55 >= 0)
    v42 = (const char *)&__dst;
  else
    v42 = (const char *)__dst;
  if (v52 >= 0)
    v43 = v51;
  else
    v43 = (void **)v51[0];
  IVFVectorIndex_s::rename((IVFVectorIndex_s *)*v15, v42, (const char *)v43, v41);
  if ((SHIBYTE(v52) & 0x80000000) == 0)
  {
    if ((SHIBYTE(v55) & 0x80000000) == 0)
      return;
LABEL_56:
    operator delete(__dst);
    return;
  }
  operator delete(v51[0]);
  if (SHIBYTE(v55) < 0)
    goto LABEL_56;
}

void ___ZN16IVFVectorIndex_s6unlinkEPKcS1_b_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, const void **a7)
{
  int v7;
  int v8;
  size_t v9;
  uint64_t v10;
  unint64_t v11;
  std::__fs::filesystem::path *p_dst;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const void *v18;
  _DWORD *v19;
  std::__fs::filesystem::path __dst;
  std::__fs::filesystem::path __p;
  std::string v22;
  std::string v23;

  v7 = *(unsigned __int8 *)(a1 + 56);
  v8 = *((char *)a7 + 23);
  if (v8 >= 0)
    v9 = *((unsigned __int8 *)a7 + 23);
  else
    v9 = (size_t)a7[1];
  if (*(_BYTE *)(a1 + 56))
    v10 = 7;
  else
    v10 = 0;
  v11 = v9 + v10;
  if (v9 + v10 >= 0x7FFFFFFFFFFFFFF8)
    abort();
  if (v11 > 0x16)
  {
    v15 = (v11 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v11 | 7) != 0x17)
      v15 = v11 | 7;
    v16 = v15 + 1;
    p_dst = (std::__fs::filesystem::path *)operator new(v15 + 1);
    __dst.__pn_.__r_.__value_.__l.__size_ = v9 + v10;
    __dst.__pn_.__r_.__value_.__r.__words[2] = v16 | 0x8000000000000000;
    __dst.__pn_.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
  }
  else
  {
    memset(&__dst, 0, sizeof(__dst));
    p_dst = &__dst;
    *((_BYTE *)&__dst.__pn_.__r_.__value_.__s + 23) = v9 + v10;
  }
  v17 = a1 + 32;
  memset(&v23, 0, sizeof(v23));
  if (v9)
  {
    if (v8 >= 0)
      v18 = a7;
    else
      v18 = *a7;
    memmove(p_dst, v18, v9);
  }
  v19 = (_DWORD *)((char *)p_dst + v9);
  if (v7)
  {
    *(_DWORD *)((char *)v19 + 3) = 2003788897;
    *v19 = 1634235182;
  }
  *((_BYTE *)v19 + v10) = 0;
  __p = __dst;
  std::__fs::filesystem::operator/[abi:nn180100](&v22, v17, &__p);
  if ((SHIBYTE(v22.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    v23 = v22;
    if ((SHIBYTE(__p.__pn_.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_26;
    goto LABEL_25;
  }
  std::string::__init_copy_ctor_external(&v23, v22.__r_.__value_.__l.__data_, v22.__r_.__value_.__l.__size_);
  if ((SHIBYTE(v22.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((SHIBYTE(__p.__pn_.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_26;
    goto LABEL_25;
  }
  operator delete(v22.__r_.__value_.__l.__data_);
  if (SHIBYTE(__p.__pn_.__r_.__value_.__r.__words[2]) < 0)
LABEL_25:
    operator delete(__p.__pn_.__r_.__value_.__l.__data_);
LABEL_26:
  IVFVectorIndex_s::unlink((char *)&v23);
  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v23.__r_.__value_.__l.__data_);
}

uint64_t truncateVectorIndex(uint64_t result)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  NSObject *v8;
  _QWORD *v9;
  void **v10;
  _QWORD *v11;
  _QWORD *v12;
  BOOL v13;
  void *__p[2];
  char v15;
  uint8_t buf[4];
  _QWORD *v17;
  __int16 v18;
  void **v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = *(_QWORD **)(result + 88);
  v2 = (_QWORD *)(result + 96);
  if (v1 != (_QWORD *)(result + 96))
  {
    v3 = result;
    v4 = (_QWORD *)(result + 64);
    v5 = result + 40;
    do
    {
      v6 = v1[5];
      v7 = *__error();
      v8 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        v9 = v4;
        if (*(char *)(v3 + 87) < 0)
          v9 = (_QWORD *)*v4;
        (*(void (**)(void **__return_ptr, uint64_t, uint64_t))(*(_QWORD *)v6 + 312))(__p, v6, v5);
        v10 = __p;
        if (v15 < 0)
          v10 = (void **)__p[0];
        *(_DWORD *)buf = 136315394;
        v17 = v9;
        v18 = 2080;
        v19 = v10;
        _os_log_impl(&dword_1B8270000, v8, OS_LOG_TYPE_DEFAULT, "[%s] truncate %s", buf, 0x16u);
        if (v15 < 0)
          operator delete(__p[0]);
      }
      *__error() = v7;
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 176))(v6);
      v11 = (_QWORD *)v1[1];
      if (v11)
      {
        do
        {
          v12 = v11;
          v11 = (_QWORD *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          v12 = (_QWORD *)v1[2];
          v13 = *v12 == (_QWORD)v1;
          v1 = v12;
        }
        while (!v13);
      }
      v1 = v12;
    }
    while (v12 != v2);
  }
  return result;
}

void freeVectorUpdates(uint64_t a1)
{
  int v2;
  NSObject *v3;
  int v4;
  uint64_t v5;
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  if (dword_1EF19FCCC >= 5)
  {
    v2 = *__error();
    v3 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4 = 134217984;
      v5 = a1;
      _os_log_impl(&dword_1B8270000, v3, OS_LOG_TYPE_DEFAULT, "Delete <UpdateSet> %p", (uint8_t *)&v4, 0xCu);
    }
    *__error() = v2;
  }
  std::__tree<std::__value_type<unsigned long long,std::shared_ptr<AnyVectorIndexInstance>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<AnyVectorIndexInstance>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<AnyVectorIndexInstance>>>>::destroy(*(_QWORD **)(a1 + 8));
  JUMPOUT(0x1BCCB06A4);
}

uint64_t vectorIndexValidAddress(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t result;
  _QWORD *v6;
  _QWORD *v7;
  BOOL v8;

  v2 = *(_QWORD **)(a1 + 88);
  v3 = (_QWORD *)(a1 + 96);
  if (v2 == (_QWORD *)(a1 + 96))
    return 0;
  do
  {
    result = (*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)v2[5] + 40))(v2[5], a2);
    if ((result & 1) != 0)
      break;
    v6 = (_QWORD *)v2[1];
    if (v6)
    {
      do
      {
        v7 = v6;
        v6 = (_QWORD *)*v6;
      }
      while (v6);
    }
    else
    {
      do
      {
        v7 = (_QWORD *)v2[2];
        v8 = *v7 == (_QWORD)v2;
        v2 = v7;
      }
      while (!v8);
    }
    v2 = v7;
  }
  while (v7 != v3);
  return result;
}

uint64_t processVectorIndexDumpContexts(uint64_t result, uint64_t a2, uint64_t a3, uint64_t *a4, int a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  std::ios_base *v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  NSObject *v29;
  _QWORD *v30;
  _QWORD *v31;
  void *p_p;
  uint64_t v33;
  uint64_t v34;
  _QWORD *v35;
  _QWORD *v36;
  unint64_t v37;
  uint64_t *v38;
  uint64_t **v39;
  uint64_t **v40;
  unint64_t v41;
  uint64_t *v42;
  uint64_t *v43;
  uint64_t *v44;
  uint64_t v45;
  uint64_t *v46;
  uint64_t v47;
  _BYTE *v48;
  int v49;
  uint64_t v50;
  int v51;
  uint64_t *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t *v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v58;
  char *v59;
  uint64_t *v60;
  char *v61;
  uint64_t v62;
  unint64_t v63;
  uint64_t v64;
  unint64_t v65;
  char *v66;
  char *v67;
  unint64_t v68;
  uint64_t v69;
  char *v70;
  __int128 *v71;
  uint64_t v72;
  __int128 v73;
  uint64_t v74;
  _QWORD *v75;
  _QWORD *v76;
  BOOL v77;
  _QWORD *v78;
  uint64_t v79;
  _QWORD *v80;
  _QWORD *v81;
  _BYTE *v82;
  uint64_t v83;
  uint64_t v85;
  _QWORD *v87;
  void *__p;
  char v89;
  _QWORD v90[2];
  uint64_t v91;
  _OWORD v92[4];
  void *v93[2];
  __int128 v94;
  uint64_t v95;
  uint64_t v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  __int128 v103;
  __int128 v104;
  __int128 v105;
  _BYTE buf[24];
  _QWORD *v107;
  __int16 v108;
  uint64_t v109;
  __int16 v110;
  void *v111;
  uint64_t v112;

  v112 = *MEMORY[0x1E0C80C00];
  if (a5)
  {
    v5 = result;
    v105 = 0u;
    v95 = 0;
    v104 = 0u;
    v103 = 0u;
    v102 = 0u;
    v101 = 0u;
    v100 = 0u;
    v99 = 0u;
    v98 = 0u;
    v97 = 0u;
    v94 = 0u;
    *(_OWORD *)v93 = 0u;
    v6 = MEMORY[0x1E0DE4FD0];
    memset(v92, 0, sizeof(v92));
    v8 = MEMORY[0x1E0DE4FD0] + 104;
    v96 = MEMORY[0x1E0DE4FD0] + 104;
    v9 = (_QWORD *)MEMORY[0x1E0DE4F50];
    v10 = MEMORY[0x1E0DE4FD0] + 64;
    v11 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 16);
    v12 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 24);
    v91 = MEMORY[0x1E0DE4FD0] + 64;
    v90[0] = v11;
    *(_QWORD *)((char *)v90 + *(_QWORD *)(v11 - 24)) = v12;
    v90[1] = 0;
    v13 = (std::ios_base *)((char *)v90 + *(_QWORD *)(v90[0] - 24));
    std::ios_base::init(v13, v92);
    v13[1].__vftable = 0;
    v13[1].__fmtflags_ = -1;
    v14 = v9[5];
    v91 = v9[4];
    *(uint64_t *)((char *)&v91 + *(_QWORD *)(v91 - 24)) = v14;
    v90[0] = v9[1];
    *(_QWORD *)((char *)v90 + *(_QWORD *)(v90[0] - 24)) = v9[6];
    v96 = v8;
    v90[0] = v6 + 24;
    v91 = v10;
    std::streambuf::basic_streambuf();
    *(_QWORD *)&v92[0] = MEMORY[0x1E0DE4FB8] + 16;
    *(_OWORD *)v93 = 0u;
    v94 = 0u;
    LODWORD(v95) = 24;
    v83 = a3;
    if (a3 >= 1)
    {
      v15 = *(char *)(*a4 + 55);
      v16 = v15 >= 0 ? *a4 + 32 : *(_QWORD *)(*a4 + 32);
      v17 = v15 >= 0 ? *(unsigned __int8 *)(*a4 + 55) : *(_QWORD *)(*a4 + 40);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v91, v16, v17);
      v18 = a3 - 1;
      if (a3 != 1)
      {
        v19 = a4 + 1;
        do
        {
          v20 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v91, (uint64_t)", ", 2);
          v21 = *v19++;
          v22 = v21 + 32;
          v23 = *(_QWORD *)(v21 + 32);
          v24 = *(unsigned __int8 *)(v21 + 55);
          v25 = *(_QWORD *)(v21 + 40);
          if ((v24 & 0x80u) == 0)
            v26 = v22;
          else
            v26 = v23;
          if ((v24 & 0x80u) == 0)
            v27 = v24;
          else
            v27 = v25;
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v20, v26, v27);
          --v18;
        }
        while (v18);
      }
    }
    v28 = *__error();
    v29 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      v30 = (_QWORD *)(v5 + 64);
      if (*(char *)(v5 + 87) < 0)
        v30 = (_QWORD *)*v30;
      v31 = (_QWORD *)(v5 + 40);
      if (*(char *)(v5 + 63) < 0)
        v31 = (_QWORD *)*v31;
      std::stringbuf::str();
      if (v89 >= 0)
        p_p = &__p;
      else
        p_p = __p;
      *(_DWORD *)buf = 136316162;
      *(_QWORD *)&buf[4] = v30;
      *(_WORD *)&buf[12] = 2048;
      *(_QWORD *)&buf[14] = v5 + 8;
      *(_WORD *)&buf[22] = 2080;
      v107 = v31;
      v108 = 2048;
      v109 = a2;
      v110 = 2080;
      v111 = p_p;
      _os_log_impl(&dword_1B8270000, v29, OS_LOG_TYPE_DEFAULT, "[%s] processVectorIndexDumpContexts: %p %s %lu [%s]", buf, 0x34u);
      if (v89 < 0)
        operator delete(__p);
    }
    *__error() = v28;
    *(_QWORD *)&buf[8] = 0;
    *(_QWORD *)&buf[16] = 0;
    *(_QWORD *)buf = &buf[8];
    if (a3 >= 1)
    {
      v33 = 0;
      do
      {
        v34 = a4[v33];
        v35 = *(_QWORD **)(v34 + 80);
        v36 = (_QWORD *)(v34 + 88);
        v85 = v33;
        v87 = (_QWORD *)(v34 + 88);
        if (v35 != (_QWORD *)(v34 + 88))
        {
          do
          {
            v37 = v35[4] & 0xFFFFFFFFFFFFFFFELL;
            v38 = *(uint64_t **)&buf[8];
            v39 = (uint64_t **)&buf[8];
            v40 = (uint64_t **)&buf[8];
            if (*(_QWORD *)&buf[8])
            {
              while (1)
              {
                while (1)
                {
                  v40 = (uint64_t **)v38;
                  v41 = v38[4];
                  if (v37 >= v41)
                    break;
                  v38 = *v40;
                  v39 = v40;
                  if (!*v40)
                    goto LABEL_41;
                }
                if (v41 >= v37)
                  break;
                v38 = v40[1];
                if (!v38)
                {
                  v39 = v40 + 1;
                  goto LABEL_41;
                }
              }
            }
            else
            {
LABEL_41:
              v42 = (uint64_t *)v40;
              v40 = (uint64_t **)operator new(0x40uLL);
              v40[4] = (uint64_t *)v37;
              v40[5] = 0;
              v40[6] = 0;
              v40[7] = 0;
              *v40 = 0;
              v40[1] = 0;
              v40[2] = v42;
              *v39 = (uint64_t *)v40;
              v43 = (uint64_t *)v40;
              if (**(_QWORD **)buf)
              {
                *(_QWORD *)buf = **(_QWORD **)buf;
                v43 = *v39;
              }
              v44 = *(uint64_t **)&buf[8];
              *((_BYTE *)v43 + 24) = v43 == *(uint64_t **)&buf[8];
              if (v43 != v44)
              {
                do
                {
                  v45 = v43[2];
                  if (*(_BYTE *)(v45 + 24))
                    break;
                  v46 = *(uint64_t **)(v45 + 16);
                  v47 = *v46;
                  if (*v46 == v45)
                  {
                    v50 = v46[1];
                    if (!v50 || (v51 = *(unsigned __int8 *)(v50 + 24), v48 = (_BYTE *)(v50 + 24), v51))
                    {
                      if (*(uint64_t **)v45 == v43)
                      {
                        v52 = (uint64_t *)v43[2];
                      }
                      else
                      {
                        v52 = *(uint64_t **)(v45 + 8);
                        v53 = *v52;
                        *(_QWORD *)(v45 + 8) = *v52;
                        if (v53)
                        {
                          *(_QWORD *)(v53 + 16) = v45;
                          v46 = *(uint64_t **)(v45 + 16);
                        }
                        v52[2] = (uint64_t)v46;
                        *(_QWORD *)(*(_QWORD *)(v45 + 16) + 8 * (**(_QWORD **)(v45 + 16) != v45)) = v52;
                        *v52 = v45;
                        *(_QWORD *)(v45 + 16) = v52;
                        v46 = (uint64_t *)v52[2];
                        v45 = *v46;
                      }
                      *((_BYTE *)v52 + 24) = 1;
                      *((_BYTE *)v46 + 24) = 0;
                      v56 = *(_QWORD *)(v45 + 8);
                      *v46 = v56;
                      if (v56)
                        *(_QWORD *)(v56 + 16) = v46;
                      *(_QWORD *)(v45 + 16) = v46[2];
                      *(_QWORD *)(v46[2] + 8 * (*(_QWORD *)v46[2] != (_QWORD)v46)) = v45;
                      *(_QWORD *)(v45 + 8) = v46;
                      goto LABEL_69;
                    }
                  }
                  else if (!v47 || (v49 = *(unsigned __int8 *)(v47 + 24), v48 = (_BYTE *)(v47 + 24), v49))
                  {
                    if (*(uint64_t **)v45 == v43)
                    {
                      v54 = v43[1];
                      *(_QWORD *)v45 = v54;
                      if (v54)
                      {
                        *(_QWORD *)(v54 + 16) = v45;
                        v46 = *(uint64_t **)(v45 + 16);
                      }
                      v43[2] = (uint64_t)v46;
                      *(_QWORD *)(*(_QWORD *)(v45 + 16) + 8 * (**(_QWORD **)(v45 + 16) != v45)) = v43;
                      v43[1] = v45;
                      *(_QWORD *)(v45 + 16) = v43;
                      v46 = (uint64_t *)v43[2];
                    }
                    else
                    {
                      v43 = (uint64_t *)v43[2];
                    }
                    *((_BYTE *)v43 + 24) = 1;
                    *((_BYTE *)v46 + 24) = 0;
                    v45 = v46[1];
                    v55 = *(uint64_t **)v45;
                    v46[1] = *(_QWORD *)v45;
                    if (v55)
                      v55[2] = (uint64_t)v46;
                    *(_QWORD *)(v45 + 16) = v46[2];
                    *(_QWORD *)(v46[2] + 8 * (*(_QWORD *)v46[2] != (_QWORD)v46)) = v45;
                    *(_QWORD *)v45 = v46;
LABEL_69:
                    v46[2] = v45;
                    break;
                  }
                  *(_BYTE *)(v45 + 24) = 1;
                  v43 = v46;
                  *((_BYTE *)v46 + 24) = v46 == v44;
                  *v48 = 1;
                }
                while (v46 != v44);
              }
              ++*(_QWORD *)&buf[16];
            }
            v57 = v35[5];
            v59 = (char *)v40[6];
            v58 = (unint64_t)v40[7];
            if ((unint64_t)v59 >= v58)
            {
              v61 = (char *)v40[5];
              v62 = (v59 - v61) >> 3;
              v63 = v62 + 1;
              if ((unint64_t)(v62 + 1) >> 61)
                abort();
              v64 = v58 - (_QWORD)v61;
              if (v64 >> 2 > v63)
                v63 = v64 >> 2;
              if ((unint64_t)v64 >= 0x7FFFFFFFFFFFFFF8)
                v65 = 0x1FFFFFFFFFFFFFFFLL;
              else
                v65 = v63;
              if (v65)
              {
                if (v65 >> 61)
                  std::__throw_bad_array_new_length[abi:nn180100]();
                v66 = (char *)operator new(8 * v65);
              }
              else
              {
                v66 = 0;
              }
              v67 = &v66[8 * v62];
              *(_QWORD *)v67 = v57;
              v60 = (uint64_t *)(v67 + 8);
              if (v59 != v61)
              {
                v68 = v59 - 8 - v61;
                if (v68 < 0x58)
                  goto LABEL_119;
                if ((unint64_t)(v61 - v66) < 0x20)
                  goto LABEL_119;
                v69 = (v68 >> 3) + 1;
                v70 = &v66[8 * v62 - 16];
                v71 = (__int128 *)(v59 - 16);
                v72 = v69 & 0x3FFFFFFFFFFFFFFCLL;
                do
                {
                  v73 = *v71;
                  *((_OWORD *)v70 - 1) = *(v71 - 1);
                  *(_OWORD *)v70 = v73;
                  v70 -= 32;
                  v71 -= 2;
                  v72 -= 4;
                }
                while (v72);
                v67 -= 8 * (v69 & 0x3FFFFFFFFFFFFFFCLL);
                v59 -= 8 * (v69 & 0x3FFFFFFFFFFFFFFCLL);
                if (v69 != (v69 & 0x3FFFFFFFFFFFFFFCLL))
                {
LABEL_119:
                  do
                  {
                    v74 = *((_QWORD *)v59 - 1);
                    v59 -= 8;
                    *((_QWORD *)v67 - 1) = v74;
                    v67 -= 8;
                  }
                  while (v59 != v61);
                }
                v59 = (char *)v40[5];
              }
              v40[5] = (uint64_t *)v67;
              v40[6] = v60;
              v40[7] = (uint64_t *)&v66[8 * v65];
              v36 = v87;
              if (v59)
                operator delete(v59);
            }
            else
            {
              *(_QWORD *)v59 = v57;
              v60 = (uint64_t *)(v59 + 8);
            }
            v40[6] = v60;
            v75 = (_QWORD *)v35[1];
            if (v75)
            {
              do
              {
                v76 = v75;
                v75 = (_QWORD *)*v75;
              }
              while (v75);
            }
            else
            {
              do
              {
                v76 = (_QWORD *)v35[2];
                v77 = *v76 == (_QWORD)v35;
                v35 = v76;
              }
              while (!v77);
            }
            v35 = v76;
          }
          while (v76 != v36);
        }
        v33 = v85 + 1;
      }
      while (v85 + 1 != v83);
      v78 = *(_QWORD **)buf;
      v9 = (_QWORD *)MEMORY[0x1E0DE4F50];
      if (*(_BYTE **)buf != &buf[8])
      {
        do
        {
          v80 = (_QWORD *)v78[5];
          if ((_QWORD *)v78[6] != v80)
            (*(void (**)(_QWORD, _QWORD *))(*(_QWORD *)*v80 + 88))(*v80, v78 + 5);
          v81 = (_QWORD *)v78[1];
          if (v81)
          {
            do
            {
              v82 = v81;
              v81 = (_QWORD *)*v81;
            }
            while (v81);
          }
          else
          {
            do
            {
              v82 = (_BYTE *)v78[2];
              v77 = *(_QWORD *)v82 == (_QWORD)v78;
              v78 = v82;
            }
            while (!v77);
          }
          v78 = v82;
        }
        while (v82 != &buf[8]);
      }
    }
    std::__tree<std::__value_type<unsigned long long,std::vector<AnyVectorIndexInstance *>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::vector<AnyVectorIndexInstance *>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::vector<AnyVectorIndexInstance *>>>>::destroy(*(_QWORD **)&buf[8]);
    v90[0] = *v9;
    v79 = v9[9];
    *(_QWORD *)((char *)v90 + *(_QWORD *)(v90[0] - 24)) = v9[8];
    v91 = v79;
    *(_QWORD *)&v92[0] = MEMORY[0x1E0DE4FB8] + 16;
    if (SBYTE7(v94) < 0)
      operator delete(v93[0]);
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    return MEMORY[0x1BCCB0650](&v96);
  }
  return result;
}

void std::__tree<std::__value_type<unsigned long long,std::vector<AnyVectorIndexInstance *>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::vector<AnyVectorIndexInstance *>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::vector<AnyVectorIndexInstance *>>>>::destroy(_QWORD *a1)
{
  void *v2;

  if (a1)
  {
    std::__tree<std::__value_type<unsigned long long,std::vector<AnyVectorIndexInstance *>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::vector<AnyVectorIndexInstance *>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::vector<AnyVectorIndexInstance *>>>>::destroy(*a1);
    std::__tree<std::__value_type<unsigned long long,std::vector<AnyVectorIndexInstance *>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::vector<AnyVectorIndexInstance *>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::vector<AnyVectorIndexInstance *>>>>::destroy(a1[1]);
    v2 = (void *)a1[5];
    if (v2)
    {
      a1[6] = v2;
      operator delete(v2);
    }
    operator delete(a1);
  }
}

uint64_t __vectorIndexDiagnoseDump_block_invoke(uint64_t a1, int a2)
{
  return db_get_field_name_for_id(*(int **)(a1 + 32), a2);
}

void __clang_call_terminate(void *a1)
{
  __cxa_begin_catch(a1);
  std::terminate();
}

_QWORD *pommesCustomTrees(_QWORD *a1, __CFString *a2, const __CFAttributedString *a3, const __CFDictionary *a4, uint64_t a5)
{
  _QWORD *Tree;
  const void *v10;
  const void *v11;
  const __CFArray *Value;
  void *v13;
  int v14;
  int v15;
  NSObject *v16;
  int v17;
  int v18;
  NSObject *v19;
  uint64_t v20;
  uint64_t v21;
  const char *v22;
  int v23;
  int v24;
  NSObject *v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  const char *QueryNodeForPhotosMediaType;
  int v34;
  int v35;
  NSObject *v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  _QWORD *v40;
  const char *v41;
  int v42;
  int v43;
  NSObject *v44;
  int v45;
  NSObject *v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  int v50;
  const char *v51;
  NSObject *v52;
  uint32_t v53;
  uint64_t v55;
  uint64_t v56;
  int v57;
  _QWORD *v58;
  uint8_t buf[4];
  uint64_t v60;
  __int16 v61;
  uint64_t v62;
  __int16 v63;
  _BYTE v64[10];
  __int16 v65;
  int v66;
  uint64_t v67;

  v67 = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)(a5 + 19))
  {
    Tree = 0;
    if (!a1)
      goto LABEL_15;
LABEL_6:
    if (!db_count_query_tree(a1))
      goto LABEL_15;
    if (!a2)
    {
      db_free_query_node(Tree);
      v23 = *(unsigned __int8 *)(a5 + 12);
      v18 = *__error();
      if (v23)
      {
        v19 = _SILogForLogForCategory(18);
        if (!os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
          goto LABEL_32;
      }
      else
      {
        v19 = _SILogForLogForCategory(17);
        if (!os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
          goto LABEL_32;
      }
      v27 = *(_QWORD *)a5;
      v28 = *(_QWORD *)(a5 + 24);
      *(_DWORD *)buf = 134218242;
      v60 = v27;
      v61 = 2080;
      v62 = v28;
      v22 = "[POMMES][qid=%lld][%s] Return no results (missing userQuery)";
      goto LABEL_31;
    }
    if (!a4 || !CFDictionaryGetCount(a4))
      goto LABEL_27;
    v10 = (const void *)getkQPQUOutputTokenInfoKey();
    if (CFDictionaryContainsKey(a4, v10) && CFDictionaryContainsKey(a4, CFSTR("attributedParse")))
    {
      v11 = (const void *)getkQPQUOutputTokenInfoKey();
      Value = (const __CFArray *)CFDictionaryGetValue(a4, v11);
      v13 = (void *)CFDictionaryGetValue(a4, CFSTR("attributedParse"));
      v14 = *(unsigned __int8 *)(a5 + 12);
      v15 = *__error();
      if (v14)
      {
        v16 = _SILogForLogForCategory(18);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          goto LABEL_34;
      }
      else
      {
        v16 = _SILogForLogForCategory(17);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
LABEL_34:
          v29 = *(_QWORD *)a5;
          v30 = *(_QWORD *)(a5 + 24);
          *(_DWORD *)buf = 134218498;
          v60 = v29;
          v61 = 2080;
          v62 = v30;
          v63 = 2112;
          *(_QWORD *)v64 = v13;
          _os_log_impl(&dword_1B8270000, v16, OS_LOG_TYPE_DEFAULT, "[POMMES][qid=%lld][%s] Use U2 for query with QPParse:'%@'", buf, 0x20u);
        }
      }
      v26 = 1;
      goto LABEL_39;
    }
    if (!CFDictionaryContainsKey(a4, CFSTR("attributedParses")))
    {
LABEL_27:
      v13 = 0;
      Value = 0;
      v26 = 0;
      if (!Tree)
        goto LABEL_42;
      goto LABEL_40;
    }
    v13 = (void *)objc_msgSend((id)CFDictionaryGetValue(a4, CFSTR("attributedParses")), "objectAtIndexedSubscript:", 0);
    v24 = *(unsigned __int8 *)(a5 + 12);
    v15 = *__error();
    if (v24)
    {
      v25 = _SILogForLogForCategory(18);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
        goto LABEL_37;
    }
    else
    {
      v25 = _SILogForLogForCategory(17);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
LABEL_37:
        v31 = *(_QWORD *)a5;
        v32 = *(_QWORD *)(a5 + 24);
        *(_DWORD *)buf = 134218498;
        v60 = v31;
        v61 = 2080;
        v62 = v32;
        v63 = 2112;
        *(_QWORD *)v64 = v13;
        _os_log_impl(&dword_1B8270000, v25, OS_LOG_TYPE_DEFAULT, "[POMMES][qid=%lld][%s] Not using U2 but rule based QP for query with QPParse:'%@'.", buf, 0x20u);
      }
    }
    Value = 0;
    v26 = 0;
LABEL_39:
    *__error() = v15;
    if (!Tree)
      goto LABEL_42;
LABEL_40:
    if (*(_BYTE *)(a5 + 21))
    {
      QueryNodeForPhotosMediaType = createQueryNodeForPhotosMediaType(1, *(unsigned __int8 *)(a5 + 12));
      Tree = makeAndNode((uint64_t)Tree, (uint64_t)QueryNodeForPhotosMediaType);
    }
LABEL_42:
    v34 = *(unsigned __int8 *)(a5 + 12);
    v35 = *__error();
    if (v34)
    {
      v36 = _SILogForLogForCategory(18);
      if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
        goto LABEL_46;
    }
    else
    {
      v36 = _SILogForLogForCategory(17);
      if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
      {
LABEL_46:
        v37 = *(_QWORD *)a5;
        v38 = *(_QWORD *)(a5 + 24);
        v39 = *(unsigned __int8 *)(a5 + 21);
        *(_DWORD *)buf = 134218754;
        v60 = v37;
        v61 = 2080;
        v62 = v38;
        v63 = 1024;
        *(_DWORD *)v64 = Tree == 0;
        *(_WORD *)&v64[4] = 1024;
        *(_DWORD *)&v64[6] = v39;
        _os_log_impl(&dword_1B8270000, v36, OS_LOG_TYPE_DEFAULT, "[POMMES][qid=%lld][%s] Added Photos query node to custom tree (invalid: %d) (filter: %d)", buf, 0x22u);
      }
    }
    *__error() = v35;
    if (v26 && *(_BYTE *)(a5 + 21) && *(_BYTE *)(a5 + 22))
    {
      v58 = pommesQUQueryTree(a4, Value, v13, a5);
      if (v58)
      {
        db_optimize_query_tree(&v58);
        v40 = v58;
        if (*(_BYTE *)(a5 + 19))
        {
          v41 = createQueryNodeForPhotosMediaType(0, *(unsigned __int8 *)(a5 + 12));
          v40 = makeAndNode((uint64_t)v40, (uint64_t)v41);
          v58 = v40;
        }
        if (*(_BYTE *)(a5 + 12))
          normalizeQueryNode((uint64_t)v40);
        Tree = makeOrNode((uint64_t)Tree, (uint64_t)v40);
      }
      v42 = *(unsigned __int8 *)(a5 + 12);
      v43 = *__error();
      if (!v42)
      {
        v44 = _SILogForLogForCategory(17);
        if (!os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
          goto LABEL_65;
        goto LABEL_68;
      }
      v44 = _SILogForLogForCategory(18);
      if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
      {
LABEL_68:
        v55 = *(_QWORD *)a5;
        v56 = *(_QWORD *)(a5 + 24);
        v57 = *(unsigned __int8 *)(a5 + 19);
        *(_DWORD *)buf = 134218754;
        v60 = v55;
        v61 = 2080;
        v62 = v56;
        v63 = 1024;
        *(_DWORD *)v64 = v58 == 0;
        *(_WORD *)&v64[4] = 1024;
        *(_DWORD *)&v64[6] = v57;
        v51 = "[POMMES][qid=%lld][%s] Added QU query node to custom tree (invalid: %d) (filter: %d)";
        v52 = v44;
        v53 = 34;
        goto LABEL_64;
      }
LABEL_65:
      *__error() = v43;
      return Tree;
    }
    v45 = *(unsigned __int8 *)(a5 + 12);
    v43 = *__error();
    if (v45)
    {
      v46 = _SILogForLogForCategory(18);
      if (!os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
        goto LABEL_65;
    }
    else
    {
      v46 = _SILogForLogForCategory(17);
      if (!os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
        goto LABEL_65;
    }
    v47 = *(_QWORD *)a5;
    v48 = *(_QWORD *)(a5 + 24);
    v49 = *(unsigned __int8 *)(a5 + 21);
    v50 = *(unsigned __int8 *)(a5 + 22);
    *(_DWORD *)buf = 134219010;
    v60 = v47;
    v61 = 2080;
    v62 = v48;
    v63 = 1024;
    *(_DWORD *)v64 = v26;
    *(_WORD *)&v64[4] = 1024;
    *(_DWORD *)&v64[6] = v49;
    v65 = 1024;
    v66 = v50;
    v51 = "[POMMES][qid=%lld][%s] Skip adding QU query node to custom tree (useU2: %d) (nonPhotos: %d) (useQU: %d)";
    v52 = v46;
    v53 = 40;
LABEL_64:
    _os_log_impl(&dword_1B8270000, v52, OS_LOG_TYPE_DEFAULT, v51, buf, v53);
    goto LABEL_65;
  }
  Tree = PhotosQueryTree(a2, a3, a4, *(CFDictionaryRef *)(a5 + 32), *(unsigned __int8 *)(a5 + 12), *(_QWORD *)a5);
  if (*(_BYTE *)(a5 + 21))
  {
    if (!a1)
    {
LABEL_15:
      db_free_query_node(Tree);
      v17 = *(unsigned __int8 *)(a5 + 12);
      v18 = *__error();
      if (v17)
      {
        v19 = _SILogForLogForCategory(18);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
LABEL_17:
          v20 = *(_QWORD *)a5;
          v21 = *(_QWORD *)(a5 + 24);
          *(_DWORD *)buf = 134218242;
          v60 = v20;
          v61 = 2080;
          v62 = v21;
          v22 = "[POMMES][qid=%lld][%s] Return no results (missing all nodes)";
LABEL_31:
          _os_log_impl(&dword_1B8270000, v19, OS_LOG_TYPE_DEFAULT, v22, buf, 0x16u);
        }
      }
      else
      {
        v19 = _SILogForLogForCategory(17);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
          goto LABEL_17;
      }
LABEL_32:
      *__error() = v18;
      Tree = malloc_type_calloc(1uLL, 0x48uLL, 0x10E0040D742DA1DuLL);
      *((_WORD *)Tree + 20) = 16;
      return Tree;
    }
    goto LABEL_6;
  }
  return Tree;
}

uint64_t getkQPQUOutputTokenInfoKey()
{
  uint64_t v0;
  uint64_t result;
  void *v2;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v0 = getkQPQUOutputTokenInfoKeySymbolLoc(void)::ptr;
  v7 = getkQPQUOutputTokenInfoKeySymbolLoc(void)::ptr;
  if (!getkQPQUOutputTokenInfoKeySymbolLoc(void)::ptr)
  {
    v3[0] = MEMORY[0x1E0C809B0];
    v3[1] = 3221225472;
    v3[2] = ___ZL35getkQPQUOutputTokenInfoKeySymbolLocv_block_invoke;
    v3[3] = &unk_1E6E34A48;
    v3[4] = &v4;
    ___ZL35getkQPQUOutputTokenInfoKeySymbolLocv_block_invoke(v3);
    v0 = v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0)
    return *(_QWORD *)v0;
  v2 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  result = objc_msgSend(v2, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPQUOutputTokenInfoKey()"), CFSTR("PRQueryProcessor.mm"), 30, CFSTR("%s"), dlerror());
  __break(1u);
  return result;
}

{
  void *v0;
  void *ParserLibrary;
  uint64_t result;
  void *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v0 = (void *)getkQPQUOutputTokenInfoKeySymbolLoc(void)::ptr;
  v7 = getkQPQUOutputTokenInfoKeySymbolLoc(void)::ptr;
  if (!getkQPQUOutputTokenInfoKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    v0 = dlsym(ParserLibrary, "kQPQUOutputTokenInfoKey");
    v5[3] = (uint64_t)v0;
    getkQPQUOutputTokenInfoKeySymbolLoc(void)::ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v4, 8);
  if (v0)
    return *(_QWORD *)v0;
  v3 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPQUOutputTokenInfoKey()"), CFSTR("PRQueryPhotosProcessor.mm"), 28, CFSTR("%s"), dlerror());
  __break(1u);
  return result;
}

void sub_1B85723D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZL17pommesRankingTreeP10query_nodePK10__CFStringPK20__CFAttributedStringPK14__CFDictionaryP9PRContext_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  unsigned int v5;
  unint64_t v6;
  int v7;
  BOOL v8;
  char v10;
  __int16 v11;
  uint64_t v13;
  _BYTE *v14;
  size_t v15;
  uint64_t v16;
  float v17;
  unsigned __int8 *v18;
  const __CFAllocator *v19;
  CFMutableStringRef Mutable;
  const __CFLocale *v21;
  CFTypeRef *QueryTokens;
  const __CFArray *v23;
  CFIndex Count;
  CFIndex v25;
  uint64_t v26;
  size_t v27;
  char *v28;
  CFIndex v29;
  CFIndex Length;
  uint64_t v31;
  _BOOL4 v32;
  _BOOL4 v33;
  _BOOL4 v34;
  float v35;
  _QWORD *v36;
  char *v37;
  const char *v38;
  uint64_t v39;
  uint8_t *v40;
  uint64_t v41;
  signed __int8 v42;
  char *v43;
  const char *v44;
  _QWORD *v45;
  char *v46;
  const char *v47;
  CFIndex v48;
  CFIndex v49;
  CFIndex v50;
  _QWORD *v51;
  _BOOL4 v52;
  uint64_t v53;
  float v54;
  _BOOL4 v55;
  CFIndex v56;
  uint64_t v57;
  CFIndex v58;
  uint64_t v59;
  float v60;
  char *v61;
  void *v62;
  uint64_t v63;
  char *v64;
  const char *v65;
  uint64_t v66;
  uint8_t *v67;
  uint64_t v68;
  signed __int8 v69;
  char *v70;
  const char *v71;
  _QWORD *v72;
  char *v73;
  const char *v74;
  _QWORD *v75;
  uint64_t v76;
  const __CFArray *v77;
  uint64_t v78;
  const __CFString *ValueAtIndex;
  _BOOL4 v80;
  __int128 v81;
  CFIndex v82;
  uint64_t v83;
  float v84;
  const __CFString *v85;
  CFIndex v86;
  _BOOL4 v87;
  float v88;
  _BOOL4 v89;
  float v90;
  void **v91;
  _QWORD *v92;
  char *v93;
  uint64_t v94;
  void **v95;
  void *v96;
  char v97;
  char *v98;
  const char *v99;
  char *v100;
  const char *v101;
  _QWORD *v102;
  uint64_t v103;
  CFIndex v104;
  UniChar CharacterAtIndex;
  const __CFString *v106;
  char *v107;
  const char *v108;
  uint64_t v109;
  const __CFCharacterSet *Predefined;
  const __CFDictionary *v111;
  const __CFArray *Value;
  const __CFArray *v113;
  CFIndex v114;
  CFIndex i;
  void *v116;
  const __CFString *v117;
  uint64_t v118;
  float v119;
  float v120;
  BOOL v121;
  uint64_t v122;
  _BOOL4 v123;
  float v124;
  char *v125;
  const char *v126;
  uint64_t v127;
  _BYTE *v128;
  BOOL v129;
  const char *v130;
  char *v131;
  char *v132;
  char *v133;
  int v134;
  NSObject *v135;
  uint64_t *v136;
  uint64_t v137;
  uint64_t v138;
  void **v139;
  _BYTE *v140;
  const char *v141;
  char *v142;
  const char *v143;
  uint64_t v144;
  _WORD *v145;
  __int128 v146;
  uint64_t v147;
  CFMutableStringRef v148;
  _QWORD *v149;
  unint64_t v150;
  unint64_t v151;
  CFAllocatorRef v152;
  uint64_t v153;
  void **v154;
  unint64_t v155;
  unint64_t v156;
  CFTypeRef *v157;
  unsigned int v158;
  unint64_t v159;
  uint64_t v160;
  CFArrayRef v161;
  const __CFString *v162;
  uint64_t NodeForToken;
  unint64_t v164;
  CFStringRef v165;
  const __CFString *v166;
  __int128 v167;
  __int128 v168;
  uint64_t v169;
  __int128 v170;
  uint64_t (*v171)(uint64_t);
  unint64_t v172;
  void *v173;
  uint64_t v174;
  __int128 v175;
  uint64_t (*v176)(uint64_t);
  uint8_t buf[24];
  char *v178;
  __int16 v179;
  void **v180;
  __int16 v181;
  int v182;
  void *values[2];
  uint64_t v184;
  uint64_t v185;
  CFRange v186;
  CFRange v187;
  CFRange v188;
  CFRange v189;
  CFRange v190;

  v2 = a2;
  v185 = *MEMORY[0x1E0C80C00];
  if (!a2)
    return v2;
  v3 = *(_QWORD *)(a2 + 16);
  if (*(_WORD *)(a2 + 40) != 4)
  {
    if (!v3)
      return v2;
    v4 = *(_DWORD *)(v3 + 24);
LABEL_17:
    if (v4 != 15)
      return v2;
    goto LABEL_18;
  }
  if (!v3)
    return v2;
  v4 = *(_DWORD *)(v3 + 24);
  HIDWORD(v6) = v4 - 1;
  LODWORD(v6) = v4 - 1;
  v5 = v6 >> 1;
  v129 = v5 > 6;
  v7 = (1 << v5) & 0x65;
  v8 = v129 || v7 == 0;
  if (v8)
    goto LABEL_17;
  if (v4 == 15)
  {
LABEL_18:
    v11 = 16;
LABEL_19:
    *(_WORD *)(a2 + 40) = v11;
    return v2;
  }
  if ((*(_BYTE *)(v3 + 36) & 2) != 0)
  {
    *(_DWORD *)(v3 + 52) = 0;
    v11 = 32;
    goto LABEL_19;
  }
  v175 = 0uLL;
  v176 = 0;
  if ((isQueryNodeMatchingAnyField(a2) & 1) != 0 || (query_node_is_double_star(v2) & 1) != 0)
  {
    v10 = 1;
  }
  else if (*(_QWORD *)v3)
  {
    std::string::basic_string[abi:nn180100]<0>(&v170, *(char **)v3);
    if (SHIBYTE(v176) < 0)
      operator delete((void *)v175);
    v10 = 0;
    v175 = v170;
    v176 = v171;
  }
  else
  {
    v10 = 0;
  }
  if (isPhotosAttribute((uint64_t)&v175))
  {
    *(_WORD *)(v2 + 40) = 16;
    goto LABEL_50;
  }
  v13 = *(_QWORD *)(v2 + 16);
  v14 = *(_BYTE **)(v13 + 72);
  if (v14)
    v15 = strlen(*(const char **)(v13 + 72));
  else
    v15 = 0;
  v16 = HIBYTE(v176);
  if (SHIBYTE(v176) < 0)
    v16 = *((_QWORD *)&v175 + 1);
  v17 = 1.0;
  if (v16)
  {
    v18 = std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::find<std::string>(*(_QWORD **)(a1 + 40), (uint64_t)&v175);
    if (v18)
      v17 = *((float *)v18 + 10);
  }
  *(float *)(v13 + 52) = v17;
  *(_DWORD *)(v13 + 56) = 0;
  if ((v10 & 1) == 0 && *(_QWORD *)v13 && !is_tokenizable_searchable_string_field(*(const char **)v13))
    goto LABEL_50;
  if (!v15 || v15 == 1 && *v14 == 42)
    goto LABEL_50;
  v164 = *(_QWORD *)(*(_QWORD *)(v2 + 16) + 32);
  v19 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v15);
  CFStringAppendCString(Mutable, *(const char **)(*(_QWORD *)(v2 + 16) + 72), 0x8000100u);
  if (!Mutable)
    goto LABEL_50;
  v21 = CFLocaleCopyCurrent();
  CFStringLowercase(Mutable, v21);
  if (v21)
    CFRelease(v21);
  QueryTokens = (CFTypeRef *)CreateQueryTokens(Mutable, (v164 >> 2) & 1);
  v157 = QueryTokens;
  v23 = (const __CFArray *)*QueryTokens;
  if (!*QueryTokens || (Count = CFArrayGetCount((CFArrayRef)*QueryTokens), (v25 = Count) == 0))
  {
    CFRelease(Mutable);
    goto LABEL_49;
  }
  v26 = *(_QWORD *)(v2 + 16);
  v158 = *(_DWORD *)(v26 + 24);
  if (v158 != 5)
  {
    v159 = v164 & 0xFFFFFFFEFFFFFFFBLL;
    v151 = v164 & 0xFFFFFFFEFFFFFFBBLL;
    v161 = v23;
    if (Count <= 2)
    {
      v149 = 0;
      goto LABEL_89;
    }
    MEMORY[0x1E0C80A78](Count);
    v28 = (char *)&v146 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v28, v27);
    v186.location = 0;
    v186.length = v25;
    CFArrayGetValues(v23, v186, (const void **)v28);
    v29 = 0;
    do
    {
      Length = CFStringGetLength(*(CFStringRef *)&v28[8 * v29]);
      if (hasTrailingAsterisk(*(_QWORD *)&v28[8 * v29]))
        v31 = 3;
      else
        v31 = 2;
      ++v29;
    }
    while (v25 > v29 && Length >= v31);
    if (Length < v31)
    {
      v149 = 0;
LABEL_89:
      v148 = Mutable;
      v48 = v25;
      v129 = v25 <= 1;
      v49 = v25 - 1;
      v153 = v48;
      v152 = v19;
      if (v129)
        goto LABEL_142;
      v50 = 0;
      v51 = 0;
      v156 = (v164 & 0x40) >> 6;
      v52 = (v164 & 0x100000000) == 0;
      v8 = v48 == 2;
      v53 = v48 == 2;
      NodeForToken = v159 | (v53 << 30) | 0x20000000;
      if (!v8)
        v52 = 0;
      LODWORD(v162) = v52;
      v160 = v151 | (v53 << 30) | 0x20000000;
      v54 = flt_1B862B578[(v164 & 0x40) == 0];
      while (1)
      {
        values[0] = 0;
        values[1] = 0;
        v187.location = v50;
        v187.length = 2;
        CFArrayGetValues(v161, v187, (const void **)values);
        v55 = hasTrailingAsterisk((_BOOL8)values[1]);
        v56 = CFStringGetLength((CFStringRef)values[0]);
        v57 = hasTrailingAsterisk((_BOOL8)values[0]) ? 3 : 2;
        if (v56 >= v57)
        {
          v58 = CFStringGetLength((CFStringRef)values[1]);
          v59 = v55 ? 3 : 2;
          if (v58 >= v59)
            break;
        }
LABEL_140:
        if (v49 == ++v50)
        {
          v149 = makeAndNode((uint64_t)v149, (uint64_t)v51);
LABEL_142:
          v76 = v153;
          v77 = v161;
          if (v153 < 1)
          {
            v160 = 0;
LABEL_259:
            v145 = makeAndNode((uint64_t)v149, v160);
            CFRelease(v148);
            freeQueryTokensContext(v157);
            if (!v145)
            {
              v145 = malloc_type_calloc(1uLL, 0x48uLL, 0x10E0040D742DA1DuLL);
              v145[20] = 32;
            }
            if (v145 != (_WORD *)v2)
            {
              *(_QWORD *)&v170 = MEMORY[0x1E0C809B0];
              *((_QWORD *)&v170 + 1) = 0x40000000;
              v171 = __db_query_tree_apply_block_block_invoke;
              v172 = (unint64_t)&unk_1E6E377F8;
              v173 = &__block_literal_global_143;
              db_query_tree_apply_block_with_meta((_QWORD *)v2, (uint64_t)&v170, 0);
              v2 = (uint64_t)v145;
            }
            goto LABEL_50;
          }
          v78 = 1;
          do
          {
            ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v77, v78 - 1);
            v80 = hasOnlyOptionalSpecialChar(ValueAtIndex);
            if (!v80)
              break;
            v129 = v78++ < v76;
          }
          while (v129);
          v82 = 0;
          v160 = 0;
          v83 = v76 == 1;
          v150 = (v164 & 0x40) >> 6;
          LODWORD(v156) = v80 | BYTE4(v164) & 1;
          v84 = flt_1B862B580[(v164 & 0x40) == 0];
          v155 = v159 | (v83 << 30);
          v154 = (void **)&v172;
          v151 |= v83 << 30;
          v147 = v159 | 0x80000000;
          *(_QWORD *)&v81 = 134219010;
          v146 = v81;
          while (2)
          {
            v169 = 1065353216;
            v168 = 0u;
            v167 = 0u;
            v85 = (const __CFString *)CFArrayGetValueAtIndex(v77, v82);
            v166 = v85;
            v86 = CFStringGetLength(v85);
            if (!v86)
              goto LABEL_247;
            v87 = hasTrailingAsterisk((_BOOL8)v85);
            values[0] = 0;
            values[1] = 0;
            v184 = 0;
            utf8QueryString((const __CFString **)values, (uint64_t)&v166, 1, 0);
            v162 = 0;
            if (v87)
            {
              if (--v86)
              {
                v188.location = 0;
                v188.length = v86;
                v85 = CFStringCreateWithSubstring(v152, v85, v188);
                v166 = v85;
                v162 = v85;
                break;
              }
LABEL_245:
              if (SHIBYTE(v184) < 0)
                operator delete(values[0]);
LABEL_247:
              std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)&v167);
              if (++v82 == v76)
                goto LABEL_259;
              continue;
            }
            break;
          }
          v88 = 0.0;
          if ((v156 & 1) == 0)
          {
            v89 = hasOnlyOptionalSpecialChar(v85);
            v88 = 1.1755e-38;
            if (!v89)
              v88 = 0.0;
          }
          if (v87)
            v90 = 1.0;
          else
            v90 = v84;
          v91 = v154;
          *v154 = 0;
          v91[1] = 0;
          v91[2] = 0;
          *(_QWORD *)&v170 = v155;
          *((_QWORD *)&v170 + 1) = __PAIR64__(LODWORD(v88), LODWORD(v90));
          v171 = (uint64_t (*)(uint64_t))&v175;
          LODWORD(v172) = v158;
          v92 = *(_QWORD **)(a1 + 40);
          v173 = *(void **)(a1 + 48);
          BYTE5(v174) = v87;
          if (v184 >= 0)
            v93 = (char *)values;
          else
            v93 = (char *)values[0];
          NodeForToken = (uint64_t)queryNodeForToken(v93, v92, (uint64_t)&v170, *(_BYTE **)(a1 + 32));
          if (NodeForToken)
            std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t)&v167, (uint64_t)values, (uint64_t)values);
          if (v87)
          {
            if (SHIBYTE(v184) < 0)
            {
              v95 = (void **)values[0];
              v94 = (uint64_t)--values[1];
            }
            else
            {
              v94 = HIBYTE(v184) - 1;
              HIBYTE(v184) = v94 & 0x7F;
              v95 = values;
            }
            *((_BYTE *)v95 + v94) = 0;
          }
          v96 = (void *)HIBYTE(v184);
          v97 = HIBYTE(v184);
          if (v184 < 0)
            v96 = values[1];
          if (!v96)
            goto LABEL_183;
          if (v87 && (v164 & 0x40) != 0)
          {
            DWORD2(v170) = 1067534254;
            if (v184 >= 0)
              v98 = (char *)values;
            else
              v98 = (char *)values[0];
            v99 = queryNodeForToken(v98, *(_QWORD **)(a1 + 40), (uint64_t)&v170, *(_BYTE **)(a1 + 32));
            v97 = HIBYTE(v184);
            goto LABEL_178;
          }
          if (((v150 | v87) & 1) != 0)
          {
            v99 = 0;
LABEL_178:
            *(_QWORD *)&v170 = v151;
            DWORD2(v170) = 1068792545;
            BYTE6(v174) = 1;
            if (v97 >= 0)
              v100 = (char *)values;
            else
              v100 = (char *)values[0];
            v101 = queryNodeForToken(v100, *(_QWORD **)(a1 + 40), (uint64_t)&v170, *(_BYTE **)(a1 + 32));
            v102 = makeOrNode((uint64_t)v99, (uint64_t)v101);
            BYTE6(v174) = 0;
            if (v102)
            {
              v103 = (uint64_t)v102;
              std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t)&v167, (uint64_t)values, (uint64_t)values);
              NodeForToken = (uint64_t)makeOrNode(NodeForToken, v103);
            }
          }
          else
          {
LABEL_183:
            BYTE6(v174) = 0;
          }
          if ((v164 & 0x100000000) == 0)
          {
            if (hasTrailingOptionalSpecialChar(v85))
            {
              v104 = v86;
              while (1)
              {
                v129 = v104-- < 1;
                if (v129)
                  break;
                CharacterAtIndex = CFStringGetCharacterAtIndex(v85, v104);
                if (!isOptionalSpecialChar(CharacterAtIndex))
                {
                  v189.length = v104 + 1;
                  v189.location = 0;
                  v106 = CFStringCreateWithSubstring(v152, v85, v189);
                  v165 = v106;
                  memset(buf, 0, sizeof(buf));
                  utf8QueryString((const __CFString **)buf, (uint64_t)&v165, 1, 0);
                  CFRelease(v106);
                  if (!std::__hash_table<std::__hash_value_type<std::string,int>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,int>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,int>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,int>>>::find<std::string>(v167, *((unint64_t *)&v167 + 1), (uint64_t)buf))
                  {
                    *(_QWORD *)&v170 = v147;
                    DWORD2(v170) = 1061997773;
                    v107 = (buf[23] & 0x80u) == 0 ? (char *)buf : *(char **)buf;
                    v108 = queryNodeForToken(v107, *(_QWORD **)(a1 + 40), (uint64_t)&v170, *(_BYTE **)(a1 + 32));
                    if (v108)
                    {
                      v109 = (uint64_t)v108;
                      std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t)&v167, (uint64_t)buf, (uint64_t)buf);
                      NodeForToken = (uint64_t)makeOrNode(NodeForToken, v109);
                    }
                  }
                  if ((char)buf[23] < 0)
                    operator delete(*(void **)buf);
                  break;
                }
              }
            }
            if (*(_BYTE *)(*(_QWORD *)(a1 + 32) + 18))
            {
              if (CFStringGetLength(v85) >= 2)
              {
                Predefined = CFCharacterSetGetPredefined(kCFCharacterSetLetter);
                v190.length = CFStringGetLength(v85) - v87;
                v190.location = 0;
                if (!CFStringFindCharacterFromSet(v85, Predefined, v190, 0, 0))
                {
                  v165 = convertCommaSeparatedNumberTokenWithNumberFormatter(v85);
                  if (CFStringGetLength(v165) >= 1)
                  {
                    memset(buf, 0, sizeof(buf));
                    utf8QueryString((const __CFString **)buf, (uint64_t)&v165, 1, 0);
                    if (!std::__hash_table<std::__hash_value_type<std::string,int>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,int>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,int>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,int>>>::find<std::string>(v167, *((unint64_t *)&v167 + 1), (uint64_t)buf))
                    {
                      *(_QWORD *)&v170 = v147;
                      DWORD2(v170) = 1065353216;
                      v142 = (buf[23] & 0x80u) == 0 ? (char *)buf : *(char **)buf;
                      v143 = queryNodeForToken(v142, *(_QWORD **)(a1 + 40), (uint64_t)&v170, *(_BYTE **)(a1 + 32));
                      if (v143)
                      {
                        v144 = (uint64_t)v143;
                        std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t)&v167, (uint64_t)buf, (uint64_t)buf);
                        NodeForToken = (uint64_t)makeOrNode(NodeForToken, v144);
                      }
                    }
                    if ((char)buf[23] < 0)
                      operator delete(*(void **)buf);
                  }
                }
              }
            }
            v111 = *(const __CFDictionary **)(*(_QWORD *)(a1 + 32) + 40);
            if (v111)
            {
              Value = (const __CFArray *)CFDictionaryGetValue(v111, v166);
              v113 = Value;
              if (Value)
              {
                v114 = CFArrayGetCount(Value);
                if (v114 >= 1)
                {
                  for (i = 0; i != v114; ++i)
                  {
                    v116 = (void *)CFArrayGetValueAtIndex(v113, i);
                    v117 = (const __CFString *)objc_msgSend(v116, "variation");
                    v165 = v117;
                    if (CFStringGetLength(v117))
                    {
                      memset(buf, 0, sizeof(buf));
                      utf8QueryString((const __CFString **)buf, (uint64_t)&v165, 1, 0);
                      if (!std::__hash_table<std::__hash_value_type<std::string,int>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,int>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,int>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,int>>>::find<std::string>(v167, *((unint64_t *)&v167 + 1), (uint64_t)buf)|| objc_msgSend(v116, "type") == 1)
                      {
                        v118 = objc_msgSend(v116, "type", (_QWORD)v146, *((_QWORD *)&v146 + 1));
                        objc_msgSend(v116, "confidence");
                        v120 = v119;
                        v121 = (v164 & 0x40) == 0;
                        v122 = v118 == 1 ? 2155872256 : 0x80000000;
                        v123 = hasTrailingAsterisk((_BOOL8)v117);
                        v124 = v123 ? 1.0 : v84;
                        *(_QWORD *)&v170 = v122 | v159;
                        *((float *)&v170 + 2) = v120 * v124;
                        BYTE6(v174) = v121 & ~v123;
                        v125 = (buf[23] & 0x80u) == 0 ? (char *)buf : *(char **)buf;
                        v126 = queryNodeForToken(v125, *(_QWORD **)(a1 + 40), (uint64_t)&v170, *(_BYTE **)(a1 + 32));
                        if (v126)
                        {
                          v127 = (uint64_t)v126;
                          std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t)&v167, (uint64_t)buf, (uint64_t)buf);
                          NodeForToken = (uint64_t)makeOrNode(NodeForToken, v127);
                        }
                      }
                      if ((char)buf[23] < 0)
                        operator delete(*(void **)buf);
                    }
                  }
                }
              }
            }
            v128 = *(_BYTE **)(a1 + 32);
            if (v128[21])
            {
              v77 = v161;
              v76 = v153;
              if (!v128[17])
              {
                v129 = v128[13] || v86 < 7;
                if (!v129)
                {
                  v130 = v184 >= 0 ? (const char *)values : (const char *)values[0];
                  v131 = PRPommesStemWordWithCString(v130, 100, 0);
                  if (v131)
                  {
                    v132 = v131;
                    if (v184 >= 0)
                      v133 = (char *)HIBYTE(v184);
                    else
                      v133 = (char *)values[1];
                    if (&v133[-strlen(v131)] == (char *)1)
                    {
                      v134 = *__error();
                      v135 = _SILogForLogForCategory(18);
                      if (os_log_type_enabled(v135, OS_LOG_TYPE_DEFAULT))
                      {
                        v136 = *(uint64_t **)(a1 + 32);
                        v137 = *v136;
                        v138 = v136[3];
                        v139 = values;
                        if (v184 < 0)
                          v139 = (void **)values[0];
                        *(_DWORD *)buf = v146;
                        *(_QWORD *)&buf[4] = v137;
                        *(_WORD *)&buf[12] = 2080;
                        *(_QWORD *)&buf[14] = v138;
                        *(_WORD *)&buf[22] = 2080;
                        v178 = v132;
                        v179 = 2080;
                        v180 = v139;
                        v181 = 1024;
                        v182 = 0;
                        _os_log_impl(&dword_1B8270000, v135, OS_LOG_TYPE_DEFAULT, "[POMMES][rewrite][qid=%lld][%s] First Pass Stemming (Top Hits) added stemmedToken = [%s] to Query Tree for token = [%s] with wildcard_limit = %u", buf, 0x30u);
                      }
                      *__error() = v134;
                      *(_QWORD *)&v170 = v147;
                      v140 = *(_BYTE **)(a1 + 32);
                      DWORD2(v170) = 1065353216;
                      LODWORD(v174) = 0;
                      v141 = queryNodeForToken(v132, *(_QWORD **)(a1 + 64), (uint64_t)&v170, v140);
                      NodeForToken = (uint64_t)makeOrNode(NodeForToken, (uint64_t)v141);
                    }
                    free(v132);
                  }
                }
              }
            }
            else
            {
              v77 = v161;
              v76 = v153;
            }
          }
          if (v162)
            CFRelease(v162);
          v160 = (uint64_t)makeAndNode(v160, NodeForToken);
          goto LABEL_245;
        }
      }
      if (v55)
        v60 = 3.3;
      else
        v60 = v54;
      v173 = 0;
      v174 = 0;
      *(_QWORD *)&v170 = NodeForToken;
      *((_QWORD *)&v170 + 1) = LODWORD(v60) | 0x80000000000000;
      v171 = (uint64_t (*)(uint64_t))&v175;
      v172 = v158;
      v173 = *(void **)(a1 + 48);
      BYTE5(v174) = v55;
      memset(buf, 0, sizeof(buf));
      utf8QueryString((const __CFString **)buf, (uint64_t)values, 2, 0);
      if ((buf[23] & 0x80u) == 0)
        v61 = (char *)buf;
      else
        v61 = *(char **)buf;
      v62 = (void *)queryNodeForToken(v61, *(_QWORD **)(a1 + 40), (uint64_t)&v170, *(_BYTE **)(a1 + 32));
      if ((_DWORD)v162 && *(_WORD *)(*(_QWORD *)(a1 + 32) + 8) == 2)
      {
        v63 = HIBYTE(v176);
        if (SHIBYTE(v176) < 0)
          v63 = *((_QWORD *)&v175 + 1);
        if (!v63
          || std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::find<std::string>(*(_QWORD **)(a1 + 56), (uint64_t)&v175))
        {
          *(int8x16_t *)values = vextq_s8(*(int8x16_t *)values, *(int8x16_t *)values, 8uLL);
          v167 = 0uLL;
          *(_QWORD *)&v168 = 0;
          utf8QueryString((const __CFString **)&v167, (uint64_t)values, 2, 1);
          v64 = (SBYTE7(v168) & 0x80u) == 0 ? (char *)&v167 : (char *)v167;
          v65 = queryNodeForToken(v64, *(_QWORD **)(a1 + 56), (uint64_t)&v170, *(_BYTE **)(a1 + 32));
          v62 = makeOrNode((uint64_t)v62, (uint64_t)v65);
          if (SBYTE7(v168) < 0)
            operator delete((void *)v167);
        }
      }
      if (v55)
      {
        if ((char)buf[23] < 0)
        {
          v67 = *(uint8_t **)buf;
          v66 = --*(_QWORD *)&buf[8];
        }
        else
        {
          v66 = buf[23] - 1;
          buf[23] = v66 & 0x7F;
          v67 = buf;
        }
        v67[v66] = 0;
      }
      v68 = buf[23];
      v69 = buf[23];
      if ((buf[23] & 0x80u) != 0)
        v68 = *(_QWORD *)&buf[8];
      if (!v68)
      {
        v72 = 0;
        goto LABEL_138;
      }
      if (v55 && (v164 & 0x40) != 0)
      {
        DWORD2(v170) = 1082461782;
        if ((buf[23] & 0x80u) == 0)
          v70 = (char *)buf;
        else
          v70 = *(char **)buf;
        v71 = queryNodeForToken(v70, *(_QWORD **)(a1 + 40), (uint64_t)&v170, *(_BYTE **)(a1 + 32));
        v69 = buf[23];
      }
      else
      {
        v71 = 0;
        v72 = 0;
        if (((v156 | v55) & 1) == 0)
          goto LABEL_138;
      }
      *(_QWORD *)&v170 = v160;
      DWORD2(v170) = 1083499872;
      BYTE6(v174) = 1;
      if (v69 >= 0)
        v73 = (char *)buf;
      else
        v73 = *(char **)buf;
      v74 = queryNodeForToken(v73, *(_QWORD **)(a1 + 40), (uint64_t)&v170, *(_BYTE **)(a1 + 32));
      v72 = makeOrNode((uint64_t)v71, (uint64_t)v74);
LABEL_138:
      v75 = makeOrNode((uint64_t)v62, (uint64_t)v72);
      v51 = makeAndNode((uint64_t)v51, (uint64_t)v75);
      if ((char)buf[23] < 0)
        operator delete(*(void **)buf);
      goto LABEL_140;
    }
    v32 = (v164 & 0x40) == 0;
    memset(buf, 0, sizeof(buf));
    utf8QueryString((const __CFString **)buf, (uint64_t)v28, v25, 0);
    v33 = hasTrailingAsterisk(*(_QWORD *)&v28[8 * v25 - 8]);
    v34 = v33;
    v35 = flt_1B862B570[v32];
    *(_QWORD *)&v170 = v159 | 0x40000000;
    if (v33)
      v35 = 7.8;
    *((_QWORD *)&v170 + 1) = LODWORD(v35) | 0x80000000000000;
    v171 = (uint64_t (*)(uint64_t))&v175;
    v172 = v158;
    v36 = *(_QWORD **)(a1 + 40);
    v173 = *(void **)(a1 + 48);
    v174 = 0;
    BYTE5(v174) = v33;
    if ((buf[23] & 0x80u) == 0)
      v37 = (char *)buf;
    else
      v37 = *(char **)buf;
    v38 = queryNodeForToken(v37, v36, (uint64_t)&v170, *(_BYTE **)(a1 + 32));
    if (v34)
    {
      if ((char)buf[23] < 0)
      {
        v40 = *(uint8_t **)buf;
        v39 = --*(_QWORD *)&buf[8];
      }
      else
      {
        v39 = buf[23] - 1;
        buf[23] = v39 & 0x7F;
        v40 = buf;
      }
      v40[v39] = 0;
    }
    v41 = buf[23];
    v42 = buf[23];
    if ((buf[23] & 0x80u) != 0)
      v41 = *(_QWORD *)&buf[8];
    if (!v41)
    {
      v45 = 0;
      goto LABEL_87;
    }
    if (v34 && (v164 & 0x40) != 0)
    {
      DWORD2(v170) = 1092435837;
      if ((buf[23] & 0x80u) == 0)
        v43 = (char *)buf;
      else
        v43 = *(char **)buf;
      v44 = queryNodeForToken(v43, *(_QWORD **)(a1 + 40), (uint64_t)&v170, *(_BYTE **)(a1 + 32));
      v42 = buf[23];
    }
    else
    {
      v44 = 0;
      v45 = 0;
      if (((v164 >> 6) & 1 | v34) != 1)
        goto LABEL_87;
    }
    *(_QWORD *)&v170 = v151 | 0x40000000;
    DWORD2(v170) = 1093662671;
    BYTE6(v174) = 1;
    if (v42 >= 0)
      v46 = (char *)buf;
    else
      v46 = *(char **)buf;
    v47 = queryNodeForToken(v46, *(_QWORD **)(a1 + 40), (uint64_t)&v170, *(_BYTE **)(a1 + 32));
    v45 = makeOrNode((uint64_t)v44, (uint64_t)v47);
LABEL_87:
    v149 = makeOrNode((uint64_t)v38, (uint64_t)v45);
    if ((char)buf[23] < 0)
      operator delete(*(void **)buf);
    goto LABEL_89;
  }
  *(_DWORD *)(v26 + 52) = 0;
  *(_WORD *)(v2 + 40) = 32;
  CFRelease(Mutable);
LABEL_49:
  freeQueryTokensContext(v157);
LABEL_50:
  if (SHIBYTE(v176) < 0)
    operator delete((void *)v175);
  return v2;
}

void sub_1B85738DC(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 137) < 0)
    operator delete(*(void **)(v1 - 160));
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(v1 - 336);
  if (*(char *)(v1 - 217) < 0)
    operator delete(*(void **)(v1 - 240));
  _Unwind_Resume(a1);
}

uint64_t ___ZL19pommesRetrievalTreeP10query_nodePK10__CFStringPK20__CFAttributedStringPK14__CFDictionaryP9PRContext_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  unsigned int v5;
  unint64_t v6;
  int v7;
  BOOL v8;
  char is_double_star;
  char NodeMatchingAnyField;
  const char **v13;
  const char *v14;
  size_t v15;
  unint64_t v16;
  CFMutableStringRef Mutable;
  const __CFLocale *v18;
  CFArrayRef *QueryTokens;
  CFTypeRef *v20;
  const __CFArray *v21;
  CFIndex Count;
  CFIndex v23;
  uint64_t v24;
  const __CFString *ValueAtIndex;
  _BOOL4 v26;
  __int128 v27;
  CFIndex v28;
  char v29;
  __CFString *v30;
  uint64_t Length;
  _BOOL4 v32;
  BOOL v33;
  _BYTE *v34;
  std::string *p_str;
  CFIndex v36;
  UniChar CharacterAtIndex;
  CFStringRef v38;
  char *v39;
  const char *v40;
  uint64_t v41;
  const __CFCharacterSet *Predefined;
  const __CFDictionary *v43;
  const __CFArray *Value;
  const __CFArray *v45;
  CFIndex v46;
  CFIndex i;
  void *v48;
  uint64_t v49;
  uint64_t v50;
  char *v51;
  const char *v52;
  uint64_t v53;
  uint64_t v54;
  int v55;
  BOOL v56;
  std::string::size_type size;
  char *v58;
  const char *v59;
  std::string *v60;
  char *v61;
  char *v62;
  unsigned __int8 *v63;
  std::string::size_type v64;
  int v65;
  NSObject *v66;
  uint64_t *v67;
  uint64_t v68;
  uint64_t v69;
  std::string *v70;
  _BYTE *v71;
  const char *v72;
  uint64_t v73;
  void *v74;
  std::string::size_type v75;
  std::string *v76;
  char *v77;
  char *v78;
  unsigned __int8 *v79;
  std::string::size_type v80;
  int v81;
  NSObject *v82;
  uint64_t *v83;
  uint64_t v84;
  uint64_t v85;
  std::string *v86;
  _BYTE *v87;
  const char *v88;
  uint64_t v89;
  char v90;
  _WORD *v91;
  __int128 v93;
  CFTypeRef *v94;
  CFMutableStringRef v95;
  char v96;
  unint64_t v97;
  unint64_t v98;
  int v99;
  const __CFAllocator *alloc;
  unint64_t v101;
  _BYTE v102[12];
  __CFString *cf;
  void *NodeForToken;
  CFIndex v105;
  std::string v106;
  __int128 v107;
  uint64_t (*v108)(uint64_t);
  __int128 v109;
  uint64_t v110;
  std::string __str;
  void *key;
  void *__p[2];
  void *v114[2];
  uint64_t v115;
  _OWORD v116[2];
  uint64_t v117;
  __int128 v118;
  uint64_t (*v119)(uint64_t);
  uint8_t buf[24];
  char *v121;
  __int16 v122;
  std::string *v123;
  __int16 v124;
  int v125;
  uint64_t v126;
  CFRange v127;
  CFRange v128;
  CFRange v129;

  v2 = a2;
  v126 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    if (*(_WORD *)(a2 + 40) == 4)
    {
      v3 = *(_QWORD *)(a2 + 16);
      if (v3)
      {
        v4 = *(_DWORD *)(v3 + 24);
        HIDWORD(v6) = v4 - 1;
        LODWORD(v6) = v4 - 1;
        v5 = v6 >> 1;
        v56 = v5 > 6;
        v7 = (1 << v5) & 0x65;
        v8 = v56 || v7 == 0;
        if (!v8 && v4 != 15)
        {
          v118 = 0uLL;
          v119 = 0;
          is_double_star = query_node_is_double_star(a2);
          NodeMatchingAnyField = isQueryNodeMatchingAnyField(v2);
          if ((is_double_star & 1) == 0 && *(_QWORD *)v3)
          {
            std::string::basic_string[abi:nn180100]<0>(&v107, *(char **)v3);
            if (SHIBYTE(v119) < 0)
              operator delete((void *)v118);
            v118 = v107;
            v119 = v108;
          }
          if (isPhotosAttribute((uint64_t)&v118))
          {
            *(_WORD *)(v2 + 40) = 16;
            goto LABEL_187;
          }
          v13 = *(const char ***)(v2 + 16);
          v14 = v13[9];
          if (v14)
          {
            v15 = strlen(v13[9]);
            if ((is_double_star & 1) != 0)
              goto LABEL_24;
          }
          else
          {
            v15 = 0;
            if ((is_double_star & 1) != 0)
              goto LABEL_24;
          }
          if (*v13 && (is_tokenizable_searchable_string_field(*v13) & 1) == 0)
          {
            if (v15)
              v90 = NodeMatchingAnyField;
            else
              v90 = 0;
            if ((v90 & 1) == 0)
              goto LABEL_187;
LABEL_25:
            if (v15 == 1 && *v14 == 42)
              goto LABEL_187;
            v16 = *(_QWORD *)(*(_QWORD *)(v2 + 16) + 32);
            alloc = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
            Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v15);
            CFStringAppendCString(Mutable, *(const char **)(*(_QWORD *)(v2 + 16) + 72), 0x8000100u);
            if (!Mutable)
              goto LABEL_187;
            v18 = CFLocaleCopyCurrent();
            CFStringLowercase(Mutable, v18);
            if (v18)
              CFRelease(v18);
            QueryTokens = (CFArrayRef *)CreateQueryTokens(Mutable, (v16 >> 2) & 1);
            v20 = (CFTypeRef *)QueryTokens;
            v21 = *QueryTokens;
            if (*QueryTokens)
            {
              Count = CFArrayGetCount(*QueryTokens);
              v23 = Count;
              if (Count)
              {
                v99 = *(_DWORD *)(*(_QWORD *)(v2 + 16) + 24);
                v117 = 1065353216;
                memset(v116, 0, sizeof(v116));
                v94 = v20;
                v95 = Mutable;
                if (Count < 1)
                {
                  *(_QWORD *)&v102[4] = 0;
LABEL_182:
                  CFRelease(v95);
                  v91 = *(_WORD **)&v102[4];
                  freeQueryTokensContext(v94);
                  if (!*(_QWORD *)&v102[4])
                  {
                    v91 = malloc_type_calloc(1uLL, 0x48uLL, 0x10E0040D742DA1DuLL);
                    v91[20] = 32;
                  }
                  if (v91 != (_WORD *)v2)
                  {
                    *(_QWORD *)&v107 = MEMORY[0x1E0C809B0];
                    *((_QWORD *)&v107 + 1) = 0x40000000;
                    v108 = __db_query_tree_apply_block_block_invoke;
                    *(_QWORD *)&v109 = &unk_1E6E377F8;
                    *((_QWORD *)&v109 + 1) = &__block_literal_global_143;
                    db_query_tree_apply_block_with_meta((_QWORD *)v2, (uint64_t)&v107, 0);
                    v2 = (uint64_t)v91;
                  }
                  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)v116);
                  goto LABEL_187;
                }
                v98 = v16;
                v101 = v16 & 0xFFFFFFFEFFFFFFFBLL;
                v24 = 1;
                do
                {
                  ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v21, v24 - 1);
                  v26 = hasOnlyOptionalSpecialChar(ValueAtIndex);
                  if (!v26)
                    break;
                  v56 = v24++ < v23;
                }
                while (v56);
                v28 = 0;
                *(_DWORD *)&v102[8] = 0;
                v105 = v23;
                *(_QWORD *)v102 = BYTE4(v16) & 1 | v26;
                v97 = v101 | ((unint64_t)(v23 == 1) << 30);
                if (v99 == 5)
                  v29 = 1;
                else
                  v29 = BYTE4(v16) & 1;
                v96 = v29;
                *(_QWORD *)&v27 = 134219010;
                v93 = v27;
                while (1)
                {
                  *(_OWORD *)__p = 0u;
                  *(_OWORD *)v114 = 0u;
                  v115 = 1065353216;
                  v30 = (__CFString *)CFArrayGetValueAtIndex(v21, v28);
                  key = v30;
                  Length = CFStringGetLength(v30);
                  if (Length)
                    break;
LABEL_141:
                  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__deallocate_node((void **)v114[0]);
                  v74 = __p[0];
                  __p[0] = 0;
                  if (v74)
                    operator delete(v74);
                  if (++v28 == v105)
                    goto LABEL_182;
                }
                v32 = hasTrailingAsterisk((_BOOL8)v30);
                memset(&__str, 0, sizeof(__str));
                utf8QueryString((const __CFString **)&__str, (uint64_t)&key, 1, 0);
                if (v32)
                {
                  if (!--Length)
                  {
LABEL_139:
                    if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
                      operator delete(__str.__r_.__value_.__l.__data_);
                    goto LABEL_141;
                  }
                  v127.location = 0;
                  v127.length = Length;
                  v30 = (__CFString *)CFStringCreateWithSubstring(alloc, v30, v127);
                  key = v30;
                  cf = v30;
                }
                else
                {
                  cf = 0;
                }
                v33 = (v102[0] & 1) == 0 && hasOnlyOptionalSpecialChar(v30);
                if (std::__hash_table<std::__hash_value_type<std::string,int>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,int>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,int>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,int>>>::find<std::string>(*(uint64_t *)&v116[0], *((unint64_t *)&v116[0] + 1), (uint64_t)&__str)|| v33)
                {
LABEL_137:
                  if (cf)
                    CFRelease(cf);
                  goto LABEL_139;
                }
                HIDWORD(v109) = 0;
                v110 = 0;
                v107 = v97;
                v108 = (uint64_t (*)(uint64_t))&v118;
                LODWORD(v109) = v99;
                *(_QWORD *)((char *)&v109 + 4) = v99 == 5;
                v34 = *(_BYTE **)(a1 + 40);
                *((_QWORD *)&v109 + 1) = *(_QWORD *)(a1 + 32);
                BYTE5(v110) = v32;
                if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                  p_str = &__str;
                else
                  p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
                NodeForToken = (void *)queryNodeForToken((char *)p_str, *(_QWORD **)(a1 + 48), (uint64_t)&v107, v34);
                if (NodeForToken)
                {
                  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t)v116, (uint64_t)&__str, (uint64_t)&__str);
                  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t)__p, (uint64_t)&__str, (uint64_t)&__str);
                }
                if ((v98 & 0x100000000) == 0)
                {
                  if (hasTrailingOptionalSpecialChar(v30))
                  {
                    v36 = Length - v32;
                    while (1)
                    {
                      v56 = v36-- < 1;
                      if (v56)
                        break;
                      CharacterAtIndex = CFStringGetCharacterAtIndex(v30, v36);
                      if (!isOptionalSpecialChar(CharacterAtIndex))
                      {
                        v128.length = v36 + 1;
                        v128.location = 0;
                        v38 = CFStringCreateWithSubstring(alloc, v30, v128);
                        v106.__r_.__value_.__r.__words[0] = (std::string::size_type)v38;
                        memset(buf, 0, sizeof(buf));
                        utf8QueryString((const __CFString **)buf, (uint64_t)&v106, 1, 0);
                        CFRelease(v38);
                        if (!std::__hash_table<std::__hash_value_type<std::string,int>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,int>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,int>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,int>>>::find<std::string>((uint64_t)__p[0], (unint64_t)__p[1], (uint64_t)buf))
                        {
                          *(_QWORD *)&v107 = v101 | 0x80000000;
                          v39 = (buf[23] & 0x80u) == 0 ? (char *)buf : *(char **)buf;
                          v40 = queryNodeForToken(v39, *(_QWORD **)(a1 + 48), (uint64_t)&v107, *(_BYTE **)(a1 + 40));
                          if (v40)
                          {
                            v41 = (uint64_t)v40;
                            std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t)__p, (uint64_t)buf, (uint64_t)buf);
                            NodeForToken = makeOrNode((uint64_t)NodeForToken, v41);
                          }
                        }
                        if ((char)buf[23] < 0)
                          operator delete(*(void **)buf);
                        break;
                      }
                    }
                  }
                  if (*(_BYTE *)(*(_QWORD *)(a1 + 40) + 18))
                  {
                    if (CFStringGetLength(v30) >= 2)
                    {
                      Predefined = CFCharacterSetGetPredefined(kCFCharacterSetLetter);
                      v129.length = CFStringGetLength(v30) - v32;
                      v129.location = 0;
                      if (!CFStringFindCharacterFromSet(v30, Predefined, v129, 0, 0))
                      {
                        v106.__r_.__value_.__r.__words[0] = (std::string::size_type)convertCommaSeparatedNumberTokenWithNumberFormatter(v30);
                        if (CFStringGetLength((CFStringRef)v106.__r_.__value_.__l.__data_) >= 1)
                        {
                          memset(buf, 0, sizeof(buf));
                          utf8QueryString((const __CFString **)buf, (uint64_t)&v106, 1, 0);
                          if (!std::__hash_table<std::__hash_value_type<std::string,int>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,int>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,int>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,int>>>::find<std::string>((uint64_t)__p[0], (unint64_t)__p[1], (uint64_t)buf))
                          {
                            std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t)__p, (uint64_t)buf, (uint64_t)buf);
                            *(_QWORD *)&v107 = v101 | 0x80000000;
                            if ((buf[23] & 0x80u) == 0)
                              v58 = (char *)buf;
                            else
                              v58 = *(char **)buf;
                            v59 = queryNodeForToken(v58, *(_QWORD **)(a1 + 48), (uint64_t)&v107, *(_BYTE **)(a1 + 40));
                            NodeForToken = makeOrNode((uint64_t)NodeForToken, (uint64_t)v59);
                          }
                          if ((char)buf[23] < 0)
                            operator delete(*(void **)buf);
                        }
                      }
                    }
                  }
                  v43 = *(const __CFDictionary **)(*(_QWORD *)(a1 + 40) + 40);
                  if (v43)
                  {
                    Value = (const __CFArray *)CFDictionaryGetValue(v43, key);
                    v45 = Value;
                    if (Value)
                    {
                      v46 = CFArrayGetCount(Value);
                      if (v46 >= 1)
                      {
                        for (i = 0; i != v46; ++i)
                        {
                          v48 = (void *)CFArrayGetValueAtIndex(v45, i);
                          v106.__r_.__value_.__r.__words[0] = objc_msgSend(v48, "variation");
                          if (CFStringGetLength((CFStringRef)v106.__r_.__value_.__l.__data_))
                          {
                            memset(buf, 0, sizeof(buf));
                            utf8QueryString((const __CFString **)buf, (uint64_t)&v106, 1, 0);
                            if (!std::__hash_table<std::__hash_value_type<std::string,int>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,int>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,int>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,int>>>::find<std::string>((uint64_t)__p[0], (unint64_t)__p[1], (uint64_t)buf)|| objc_msgSend(v48, "type") == 1)
                            {
                              v49 = objc_msgSend(v48, "type", v93);
                              v50 = 0x80000000;
                              if (v49 == 1)
                                v50 = 2155872256;
                              *(_QWORD *)&v107 = v50 | v101;
                              if ((buf[23] & 0x80u) == 0)
                                v51 = (char *)buf;
                              else
                                v51 = *(char **)buf;
                              v52 = queryNodeForToken(v51, *(_QWORD **)(a1 + 48), (uint64_t)&v107, *(_BYTE **)(a1 + 40));
                              if (v52)
                              {
                                v53 = (uint64_t)v52;
                                std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>((uint64_t)__p, (uint64_t)buf, (uint64_t)buf);
                                NodeForToken = makeOrNode((uint64_t)NodeForToken, v53);
                              }
                            }
                            if ((char)buf[23] < 0)
                              operator delete(*(void **)buf);
                          }
                        }
                      }
                    }
                  }
                }
                if ((v96 & 1) == 0)
                {
                  v54 = *(_QWORD *)(a1 + 40);
                  v55 = *(unsigned __int8 *)(v54 + 17);
                  if (!*(_BYTE *)(v54 + 17))
                  {
                    v56 = *(_BYTE *)(v54 + 13) || Length < 7;
                    if (!v56)
                    {
                      memset(&v106, 0, sizeof(v106));
                      size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
                      if (v32)
                      {
                        if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
                          size = __str.__r_.__value_.__l.__size_;
                        std::string::basic_string(&v106, &__str, 0, size - 1, (std::allocator<char> *)buf);
                      }
                      else if ((*((_BYTE *)&__str.__r_.__value_.__s + 23) & 0x80) != 0)
                      {
                        std::string::__init_copy_ctor_external(&v106, __str.__r_.__value_.__l.__data_, __str.__r_.__value_.__l.__size_);
                      }
                      else
                      {
                        v106 = __str;
                      }
                      if ((v106.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                        v60 = &v106;
                      else
                        v60 = (std::string *)v106.__r_.__value_.__r.__words[0];
                      v61 = PRPommesStemWordWithCString((const char *)v60, 100, 0);
                      if (v61)
                      {
                        v62 = v61;
                        std::string::basic_string[abi:nn180100]<0>(buf, v61);
                        v63 = std::__hash_table<std::__hash_value_type<std::string,int>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,int>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,int>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,int>>>::find<std::string>((uint64_t)__p[0], (unint64_t)__p[1], (uint64_t)buf);
                        if ((char)buf[23] < 0)
                          operator delete(*(void **)buf);
                        if (!v63)
                        {
                          if ((v106.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                            v64 = HIBYTE(v106.__r_.__value_.__r.__words[2]);
                          else
                            v64 = v106.__r_.__value_.__l.__size_;
                          if (v64 - strlen(v62) == 1)
                          {
                            v65 = *__error();
                            v66 = _SILogForLogForCategory(17);
                            if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
                            {
                              v67 = *(uint64_t **)(a1 + 40);
                              v68 = *v67;
                              v69 = v67[3];
                              v70 = &v106;
                              if ((v106.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
                                v70 = (std::string *)v106.__r_.__value_.__r.__words[0];
                              *(_DWORD *)buf = v93;
                              *(_QWORD *)&buf[4] = v68;
                              *(_WORD *)&buf[12] = 2080;
                              *(_QWORD *)&buf[14] = v69;
                              *(_WORD *)&buf[22] = 2080;
                              v121 = v62;
                              v122 = 2080;
                              v123 = v70;
                              v124 = 1024;
                              v125 = 0;
                              _os_log_impl(&dword_1B8270000, v66, OS_LOG_TYPE_DEFAULT, "[POMMES][rewrite][qid=%lld][%s] First Pass Stemming (Top Hits) added stemmedToken = [%s] to Query Tree for token = [%s] with wildcard_limit = %u", buf, 0x30u);
                            }
                            *__error() = v65;
                            *(_QWORD *)&v107 = v101 | 0x80000000;
                            v71 = *(_BYTE **)(a1 + 40);
                            LODWORD(v110) = 0;
                            v72 = queryNodeForToken(v62, *(_QWORD **)(a1 + 56), (uint64_t)&v107, v71);
                            if (v72)
                            {
                              v73 = (uint64_t)v72;
                              std::string::basic_string[abi:nn180100]<0>(buf, v62);
                              std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string>((uint64_t)__p, (uint64_t)buf, (uint64_t)buf);
                              if ((char)buf[23] < 0)
                                operator delete(*(void **)buf);
                              NodeForToken = makeOrNode((uint64_t)NodeForToken, v73);
                            }
                          }
                          free(v62);
                        }
                      }
                      if (SHIBYTE(v106.__r_.__value_.__r.__words[2]) < 0)
                        operator delete(v106.__r_.__value_.__l.__data_);
                      v54 = *(_QWORD *)(a1 + 40);
                      v55 = *(unsigned __int8 *)(v54 + 17);
                      goto LABEL_135;
                    }
                  }
                  if (Length >= 5)
                  {
LABEL_135:
                    if (!v55 && *(_BYTE *)(v54 + 13))
                    {
                      memset(&v106, 0, sizeof(v106));
                      v75 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
                      if (v32)
                      {
                        if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
                          v75 = __str.__r_.__value_.__l.__size_;
                        std::string::basic_string(&v106, &__str, 0, v75 - 1, (std::allocator<char> *)buf);
                      }
                      else if ((*((_BYTE *)&__str.__r_.__value_.__s + 23) & 0x80) != 0)
                      {
                        std::string::__init_copy_ctor_external(&v106, __str.__r_.__value_.__l.__data_, __str.__r_.__value_.__l.__size_);
                      }
                      else
                      {
                        v106 = __str;
                      }
                      if ((v106.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                        v76 = &v106;
                      else
                        v76 = (std::string *)v106.__r_.__value_.__r.__words[0];
                      v77 = PRPommesStemWordWithCString((const char *)v76, 100, 0);
                      if (v77)
                      {
                        v78 = v77;
                        std::string::basic_string[abi:nn180100]<0>(buf, v77);
                        v79 = std::__hash_table<std::__hash_value_type<std::string,int>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,int>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,int>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,int>>>::find<std::string>((uint64_t)__p[0], (unint64_t)__p[1], (uint64_t)buf);
                        if ((char)buf[23] < 0)
                          operator delete(*(void **)buf);
                        if (!v79)
                        {
                          if ((v106.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                            v80 = HIBYTE(v106.__r_.__value_.__r.__words[2]);
                          else
                            v80 = v106.__r_.__value_.__l.__size_;
                          if (v80 != strlen(v78))
                          {
                            v81 = *__error();
                            v82 = _SILogForLogForCategory(17);
                            if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
                            {
                              v83 = *(uint64_t **)(a1 + 40);
                              v84 = *v83;
                              v85 = v83[3];
                              v86 = &v106;
                              if ((v106.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
                                v86 = (std::string *)v106.__r_.__value_.__r.__words[0];
                              *(_DWORD *)buf = v93;
                              *(_QWORD *)&buf[4] = v84;
                              *(_WORD *)&buf[12] = 2080;
                              *(_QWORD *)&buf[14] = v85;
                              *(_WORD *)&buf[22] = 2080;
                              v121 = v78;
                              v122 = 2080;
                              v123 = v86;
                              v124 = 1024;
                              v125 = 3;
                              _os_log_impl(&dword_1B8270000, v82, OS_LOG_TYPE_DEFAULT, "[POMMES][rewrite][qid=%lld][%s] First Pass Stemming (Committed Search) added stemmedToken = [%s] to Query Tree for token = [%s] with wildcard_limit = %u", buf, 0x30u);
                            }
                            *__error() = v81;
                            *(_QWORD *)&v107 = v101 | 0x80000000;
                            v87 = *(_BYTE **)(a1 + 40);
                            LODWORD(v110) = 3;
                            v88 = queryNodeForToken(v78, *(_QWORD **)(a1 + 56), (uint64_t)&v107, v87);
                            if (v88)
                            {
                              v89 = (uint64_t)v88;
                              std::string::basic_string[abi:nn180100]<0>(buf, v78);
                              std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string>((uint64_t)__p, (uint64_t)buf, (uint64_t)buf);
                              if ((char)buf[23] < 0)
                                operator delete(*(void **)buf);
                              NodeForToken = makeOrNode((uint64_t)NodeForToken, v89);
                            }
                          }
                          free(v78);
                        }
                      }
                      if (SHIBYTE(v106.__r_.__value_.__r.__words[2]) < 0)
                        operator delete(v106.__r_.__value_.__l.__data_);
                    }
                  }
                }
                *(_QWORD *)&v102[4] = makeAndNode(*(uint64_t *)&v102[4], (uint64_t)NodeForToken);
                goto LABEL_137;
              }
            }
            CFRelease(Mutable);
            freeQueryTokensContext(v20);
LABEL_187:
            if (SHIBYTE(v119) < 0)
              operator delete((void *)v118);
            return v2;
          }
LABEL_24:
          if (!v15)
            goto LABEL_187;
          goto LABEL_25;
        }
      }
    }
  }
  return v2;
}

void sub_1B857461C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *a40,uint64_t a41,int a42,__int16 a43,char a44,char a45,uint64_t a46,char a47)
{
  uint64_t v47;

  if (a32 < 0)
    operator delete(__p);
  if (a45 < 0)
    operator delete(a40);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table((uint64_t)&a47);
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::~__hash_table(v47 - 240);
  if (*(char *)(v47 - 169) < 0)
    operator delete(*(void **)(v47 - 192));
  _Unwind_Resume(a1);
}

BOOL __valid_fs(int a1)
{
  int v2;
  statfs v4;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  if (a1 == -1)
    return __valid_cwd();
  bzero(&v4, 0x878uLL);
  v2 = fstatfs(a1, &v4);
  if (!v2)
  {
    usleep(0x32u);
    v2 = fstatfs(a1, &v4);
  }
  return v2 == 0;
}

BOOL __valid_cwd()
{
  int v0;
  statfs v2;
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  bzero(&v2, 0x878uLL);
  v0 = statfs(".", &v2);
  if (!v0)
  {
    usleep(0x32u);
    v0 = statfs(".", &v2);
  }
  return v0 == 0;
}

BOOL __valid_fsp(_DWORD *a1)
{
  int v2;
  int v3;
  int v4;
  uint64_t v6;
  statfs v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return __valid_cwd();
  bzero(&v7, 0x878uLL);
  v6 = 0;
  v2 = _fd_acquire_fd((uint64_t)a1, &v6);
  if (v2 == -1)
  {
    v4 = 9;
  }
  else
  {
    v3 = v2;
    v4 = fstatfs(v2, &v7);
    if (!v4)
    {
      usleep(0x32u);
      v4 = fstatfs(v3, &v7);
    }
    _fd_release_fd(a1, v3, 0, v6);
  }
  return v4 == 0;
}

BOOL __native_fsp(_DWORD *a1)
{
  int v2;
  int v3;
  uint64_t v5;
  statfs v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return __valid_cwd();
  bzero(&v6, 0x878uLL);
  v5 = 0;
  v2 = _fd_acquire_fd((uint64_t)a1, &v5);
  if (v2 != -1)
  {
    v3 = v2;
    if (!fstatfs(v2, &v6))
    {
      usleep(0x32u);
      fstatfs(v3, &v6);
    }
    _fd_release_fd(a1, v3, 0, v5);
  }
  return !(*(_DWORD *)v6.f_fstypename ^ 0x73667061 | v6.f_fstypename[4])
      || (*(_DWORD *)v6.f_fstypename ^ 0x2B736668 | v6.f_fstypename[4]) == 0;
}

uint64_t recodeVector(uint64_t a1, unsigned int a2, unsigned int a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  _MDPlistBytesBeginDictionary();
  if (a2 <= 2)
  {
    _MDPlistBytesAddCString();
    _MDPlistBytesAddInteger();
  }
  if (a3 <= 2)
  {
    _MDPlistBytesAddCString();
    _MDPlistBytesAddInteger();
  }
  if (a4)
  {
    _MDPlistBytesAddCString();
    _MDPlistBytesAddInteger();
  }
  if (a5)
  {
    _MDPlistBytesAddCString();
    _MDPlistBytesAddInteger();
  }
  if (a6 && a7)
  {
    _MDPlistBytesAddCString();
    _MDPlistBytesAddData();
  }
  return _MDPlistBytesEndDictionary();
}

_QWORD *CITokenizerCreate(int a1)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  char *v6;
  char *v7;
  const char *v8;
  int *v9;
  uint64_t v10;

  v2 = malloc_type_calloc(1uLL, 0x70uLL, 0x10F0040AEFF90DEuLL);
  v3 = v2;
  if (v2)
  {
    v2[3] = 0;
    v2[4] = 0;
    *((_DWORD *)v2 + 10) = a1;
    v4 = NLStringTokenizerCreate();
    v3[1] = v4;
    v3[2] = 0;
    if (!v4)
    {
      v6 = __si_assert_copy_extra_268();
      v7 = v6;
      if (v6)
        v8 = v6;
      else
        v8 = "";
      v9 = __error();
      __message_assert("%s:%u: failed assertion '%s' %s NLStringTokenizerCreate err:%d", "CITokenizer.c", 173, "false", v8, *v9);
      free(v7);
      if (__valid_fs(-1))
        v10 = 2989;
      else
        v10 = 3072;
      *(_DWORD *)v10 = -559038737;
      abort();
    }
    v3[7] = 0;
    v3[8] = 0;
  }
  return v3;
}

void CITokenizerDispose(_QWORD *a1)
{
  const void *v2;
  const void *v3;
  void *v4;
  const void *v5;

  if (a1)
  {
    v2 = (const void *)a1[1];
    if (v2)
      CFRelease(v2);
    v3 = (const void *)a1[2];
    if (v3)
      CFRelease(v3);
    v4 = (void *)a1[8];
    if (v4)
      free(v4);
    v5 = (const void *)a1[7];
    if (v5)
      CFRelease(v5);
    free(a1);
  }
}

BOOL CIStringTokenizerResolveTranscriptions(uint64_t a1)
{
  const char *v1;
  char *v2;
  char *v3;
  const char *v4;
  const char *v5;
  const UInt8 *v6;
  size_t v7;
  CFStringRef v8;
  const __CFString *v9;
  _QWORD *v10;
  uint64_t v11;
  const __CFString *v12;
  CFMutableStringRef Mutable;
  uint64_t v14;
  char v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  CFIndex *v21;
  uint64_t v22;
  CFIndex v23;
  unint64_t v24;
  const UniChar *v25;
  CFIndex v26;
  __CFString *v27;
  uint64_t v28;
  CFIndex v29;
  unint64_t v30;
  unint64_t v31;
  int v32;
  _BOOL8 v33;
  char *v35;
  const __CFString *v36;
  uint64_t v37;
  uint64_t v38;
  _QWORD *v39;
  const __CFAllocator *alloc;
  const UniChar *v41;
  UniChar chars;
  _OWORD v43[6];
  void *v44[2];
  CFTypeRef cf[2];
  uint64_t v46;
  _QWORD v47[256];
  _BYTE v48[2048];
  uint64_t v49;
  _OWORD v50[256];
  uint64_t v51;

  v1 = (const char *)MEMORY[0x1E0C80A78](a1);
  v3 = v2;
  v5 = v4;
  v6 = (const UInt8 *)v1;
  v51 = *MEMORY[0x1E0C80C00];
  v7 = strlen(v1);
  alloc = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v8 = CFStringCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v6, v7, 0x8000100u, 0, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
  if (!v8)
    return 0;
  v9 = v8;
  v10 = CIRetainIndexingTokenizer(3u);
  if (!v10)
  {
    v33 = 0;
    goto LABEL_55;
  }
  v11 = (uint64_t)v10;
  v35 = v3;
  bzero(v50, 0x1000uLL);
  bzero(&v49, 0x800uLL);
  bzero(v48, 0x800uLL);
  bzero(v47, 0x800uLL);
  v46 = 0;
  *(_OWORD *)v44 = 0u;
  *(_OWORD *)cf = 0u;
  memset(v43, 0, sizeof(v43));
  CITokenizerSetLocale(v11, 0, v5);
  CITokenizerStateInit((uint64_t)v43, v9, (*(unsigned int *)(v11 + 72) < 0x37uLL) & (0x40000000300030uLL >> *(_DWORD *)(v11 + 72)), 0);
  v36 = v9;
  if (cf[0])
    v12 = (const __CFString *)cf[0];
  else
    v12 = v9;
  CFStringGetLength(v12);
  _NLStringTokenizerSetStringWithOptionsAndLanguageID();
  Mutable = 0;
  v14 = 0;
  v15 = 0;
  chars = 32;
  v41 = (const UniChar *)v44[0];
  v37 = v11;
  do
  {
    v16 = _NLStringTokenizerTokenizeWithTranscriptions();
    v17 = v16;
    v18 = v16 - 1;
    if (v16 >= 1)
    {
      v19 = 0;
      v20 = (uint64_t *)v50;
      v39 = &v50[v18];
      v38 = v16 - 1;
      v21 = (CFIndex *)v48;
      while (1)
      {
        if (!*v21)
        {
          if (v18 != v19)
            goto LABEL_26;
          if (!v14)
            goto LABEL_26;
          v22 = v39[1] + *v39;
          v23 = v22 - v14;
          if (v22 == v14)
            goto LABEL_26;
          v24 = v41[v14];
          if (v24 > 0x7F)
          {
            if (!__maskrune(v24, 0x4000uLL))
              goto LABEL_34;
          }
          else if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v24 + 60) & 0x4000) == 0)
          {
LABEL_34:
            CFStringAppendCharacters(Mutable, &chars, 1);
          }
          v27 = Mutable;
          v25 = &v41[v14];
          v26 = v23;
          goto LABEL_25;
        }
        if (*(unsigned __int16 *)v47[v19] >= 0x80u)
          v15 = 1;
        if (Mutable)
          break;
        Mutable = CFStringCreateMutable(alloc, 0);
        if (v19)
          goto LABEL_22;
LABEL_24:
        v14 = v20[1] + *v20;
        v25 = (const UniChar *)v47[v19];
        v26 = *v21;
        v27 = Mutable;
LABEL_25:
        CFStringAppendCharacters(v27, v25, v26);
LABEL_26:
        ++v19;
        ++v21;
        v20 += 2;
        if (v17 == v19)
          goto LABEL_43;
      }
      if (!v19)
        goto LABEL_24;
LABEL_22:
      if (*(v21 - 1))
      {
LABEL_23:
        CFStringAppendCharacters(Mutable, &chars, 1);
        goto LABEL_24;
      }
      v28 = *v20;
      v29 = *v20 - v14;
      if (v29 < 1)
        goto LABEL_24;
      if (v14)
      {
        v30 = v41[v14];
        if (v30 > 0x7F)
        {
          if (__maskrune(v30, 0x4000uLL))
            goto LABEL_38;
        }
        else if ((*(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v30 + 60) & 0x4000) != 0)
        {
          goto LABEL_38;
        }
        CFStringAppendCharacters(Mutable, &chars, 1);
      }
LABEL_38:
      CFStringAppendCharacters(Mutable, &v41[v14], v29);
      v31 = v41[v28 - 1];
      if (v31 > 0x7F)
        v32 = __maskrune(v31, 0x4000uLL);
      else
        v32 = *(_DWORD *)(MEMORY[0x1E0C80978] + 4 * v31 + 60) & 0x4000;
      v18 = v38;
      if (v32)
        goto LABEL_24;
      goto LABEL_23;
    }
LABEL_43:
    ;
  }
  while (v17);
  if (v15)
    CFStringNormalize(Mutable, kCFStringNormalizationFormD);
  v9 = v36;
  if (Mutable)
  {
    v33 = CFStringGetCString(Mutable, v35, 4096, 0x8000100u) != 0;
    CFRelease(Mutable);
  }
  else
  {
    v33 = 0;
  }
  CIReleaseIndexingTokenizer(v37);
  if (cf[0])
    CFRelease(cf[0]);
  if (v44[1])
    free(v44[1]);
LABEL_55:
  CFRelease(v9);
  return v33;
}

void CITokenizerGetQueryTokensWithOptions(uint64_t a1)
{
  uint64_t v1;
  const __CFString *v2;
  const __CFString *v3;
  int v4;
  void (*v5)(_QWORD, _QWORD, uint64_t);
  uint64_t v6;
  uint64_t v7;
  int v8;
  const __CFString *v9;
  uint64_t v10;
  uint64_t v11;
  void (*v12)(_QWORD, _QWORD, uint64_t);
  CFTypeRef cf;
  void *v14;
  _QWORD v15[2];
  __int128 v16;
  __int128 v17;
  uint64_t v18;

  v1 = MEMORY[0x1E0C80A78](a1);
  v7 = v6;
  if (v2)
  {
    v8 = v4;
    v9 = v3;
    v10 = (uint64_t)v2;
    v11 = v1;
    v12 = v5;
    if (CFStringGetLength(v2))
    {
      v15[0] = v12;
      v15[1] = v7;
      v16 = 0u;
      v17 = 0u;
      v18 = 0;
      bzero(&cf, 0x1810uLL);
      CITokenizerSetLocale(v11, v9, 0);
      _CITokenizerGetTokens(v11, *(_QWORD *)(v11 + 8), v10, (uint64_t)&cf, v8 | 0x46u, (uint64_t)_CITokenizerGetQueryTokensStart, (uint64_t)_CITokenizerGetQueryTokens, 0, 0, (void (*)(_QWORD, uint64_t, uint64_t))_CITokenizerGetQueryTokensEnd, (uint64_t)v15);
      if (cf)
        CFRelease(cf);
      if (v14)
        free(v14);
    }
    else
    {
      v12(0, 0, v7);
    }
  }
  else
  {
    v5(0, 0, v6);
  }
}

uint64_t _CITokenizerGetQueryTokensStart(uint64_t result, uint64_t a2, _QWORD *a3)
{
  a3[5] = result;
  a3[2] = result;
  a3[3] = result + 2 * a2;
  return result;
}

uint64_t _CITokenizerGetQueryTokens(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _WORD *v5;
  uint64_t v6;
  unint64_t v7;
  _WORD *v9;
  unint64_t v10;
  _WORD *v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  _WORD *i;
  _WORD *v16;
  uint64_t v17;
  _WORD *v18;
  _WORD *v19;
  uint64_t v20;

  if (a2)
  {
    v5 = (_WORD *)a1;
    if (*(_QWORD *)(a4 + 16) <= a1)
    {
      v6 = a2;
      v7 = *(_QWORD *)(a4 + 24);
      if (v7 > a1 && a1 + 2 * a2 <= v7)
      {
        v9 = (_WORD *)(a1 - 2);
        v10 = *(_QWORD *)(a4 + 40);
        if (a1 - 2 >= v10)
        {
          v11 = (_WORD *)(a1 - 2);
          while (1)
          {
            v12 = (unsigned __int16)*v11--;
            if (v12 != 42)
              break;
            if ((unint64_t)v11 > v10 && *v11 == 92)
              goto LABEL_15;
            --v5;
            ++v6;
            v9 = v11;
            if ((unint64_t)v11 < v10)
            {
              v5 = v11 + 1;
              goto LABEL_15;
            }
          }
          v5 = v9 + 1;
        }
LABEL_15:
        v13 = *(_QWORD *)(a4 + 48);
        if (v13)
        {
          v14 = *(_QWORD *)(a4 + 32);
          for (i = (_WORD *)(v14 + 2 * v13); i < v5 && *i == 42; ++i)
            *(_QWORD *)(a4 + 48) = ++v13;
          v16 = (_WORD *)(v14 + 2 * v13);
          if (v16 == v5)
          {
            if (*(v16 - 1) == 42 && (v13 < 2 || *(_WORD *)(v14 + 2 * v13 - 4) != 92))
            {
              *(_QWORD *)(a4 + 48) = v13 + v6;
              return 0;
            }
          }
          else
          {
            (*(void (**)(void))a4)();
            v13 = 0;
            v17 = *(_QWORD *)(a4 + 32) + 2 * *(_QWORD *)(a4 + 48);
            *(_QWORD *)(a4 + 32) = 0;
            *(_QWORD *)(a4 + 40) = v17;
            *(_QWORD *)(a4 + 48) = 0;
          }
        }
        v18 = &v5[v6];
        if (*(v18 - 1) == 42 && (v6 < 2 || v5[v6 - 2] != 92)
          || (unint64_t)v18 < *(_QWORD *)(a4 + 24) && *v18 == 42)
        {
          v19 = *(_WORD **)(a4 + 32);
          if (!v19)
          {
            *(_QWORD *)(a4 + 32) = v5;
            v19 = v5;
          }
          *(_QWORD *)(a4 + 40) = &v19[v13 + v6];
          *(_QWORD *)(a4 + 48) = v13 + v6;
        }
        else
        {
          if (v13)
          {
            (*(void (**)(_QWORD, uint64_t, _QWORD))a4)(*(_QWORD *)(a4 + 32), v13, *(_QWORD *)(a4 + 8));
            v20 = *(_QWORD *)(a4 + 32) + 2 * *(_QWORD *)(a4 + 48);
            *(_QWORD *)(a4 + 32) = 0;
            *(_QWORD *)(a4 + 40) = v20;
            *(_QWORD *)(a4 + 48) = 0;
          }
          (*(void (**)(_WORD *, uint64_t, _QWORD))a4)(v5, v6, *(_QWORD *)(a4 + 8));
          *(_QWORD *)(a4 + 40) = v18;
        }
      }
    }
  }
  return 0;
}

uint64_t _CITokenizerGetQueryTokensEnd(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t result;

  v3 = *(_QWORD *)(a3 + 48);
  if (v3)
    return (*(uint64_t (**)(_QWORD, uint64_t, _QWORD))a3)(*(_QWORD *)(a3 + 32), v3, *(_QWORD *)(a3 + 8));
  return result;
}

uint64_t sentenceTokenizerMissingPunctuation(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  if (a2)
  {
    v4 = a4[387];
    if (v4 == -1)
      v5 = 0;
    else
      v5 = a4[388] + v4;
    a4[387] = v5;
    a4[388] = a2;
    if ((a3 & 0x800) == 0)
    {
      v6 = a4[389];
      if (v6 <= 127)
      {
        *(_OWORD *)&a4[2 * v6] = *(_OWORD *)(a4 + 387);
        a4[a4[389]++ + 258] = a3;
      }
    }
  }
  return 0;
}

void CITokenizerGetTokensNew(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;
  void (*v10)(_QWORD, _QWORD *, uint64_t *);
  void (*v11)(_QWORD, _QWORD *, uint64_t *);
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const __CFString *v20;
  const __CFString *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  CFTypeRef cf;
  void *v26;

  v9 = MEMORY[0x1E0C80A78](a1);
  v11 = v10;
  v13 = v12;
  v15 = v14;
  v17 = v16;
  v19 = v18;
  v21 = v20;
  v23 = v22;
  v24 = v9;
  bzero(&cf, 0x1810uLL);
  CITokenizerSetLocale(v24, v21, 0);
  _CITokenizerGetTokens(v24, *(_QWORD *)(v24 + 8), v23, (uint64_t)&cf, v19, v17, v15, v13, v11, 0, a9);
  if (cf)
    CFRelease(cf);
  if (v26)
    free(v26);
}

uint64_t getTokensWrapper(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD))a4)(a1, a2, 0, *(_QWORD *)(a4 + 16));
}

uint64_t getSubTokensWrapper(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD))a4)(a1, a2, 1, *(_QWORD *)(a4 + 16));
}

uint64_t getPreTokenizerCallback(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t (*v3)(uint64_t, uint64_t, _QWORD);

  v3 = *(uint64_t (**)(uint64_t, uint64_t, _QWORD))(a3 + 8);
  if (v3)
    return v3(result, a2, *(_QWORD *)(a3 + 16));
  return result;
}

void CITokenizerGatherSegments(uint64_t a1)
{
  unsigned __int8 *v1;
  unsigned int v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unsigned int v7;
  const UInt8 *v8;
  unint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  char v15;
  const char *v16;
  unint64_t v17;
  const UInt8 *v18;
  unint64_t v19;
  int v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  char v26;
  uint64_t v27;
  unint64_t v28;
  const UInt8 *v29;
  int v30;
  unsigned int v31;
  const __CFAllocator *v33;
  const __CFString *v34;
  const __CFString *v35;
  uint64_t v36;
  _QWORD *v37;
  uint64_t v38;
  uint64_t NextCandidate;
  uint64_t v40;
  uint64_t v41;
  CFIndex v42;
  const __CFString *AnalysisString;
  const __CFString *Surface;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  size_t v49;
  _WORD *v50;
  unint64_t v51;
  char *v52;
  uint64_t v53;
  _BYTE *v54;
  unint64_t v55;
  int v56;
  uint64_t v57;
  int v58;
  uint64_t v59;
  uint64_t v60;
  char *v61;
  char v62;
  size_t v63;
  char v64;
  BOOL v65;
  char v66;
  CFStringRef v67;
  CFStringRef v68;
  const __CFSet *Mutable;
  int v70;
  _BYTE v71[4];
  unsigned int v72;
  const __CFString *v73;
  CFAllocatorRef v74;
  const __CFSet *v75;
  uint64_t v76;
  uint64_t v77;
  const UInt8 *v78;
  const char *v79;
  _BYTE *v80;
  uint64_t v81;
  CFIndex Length;
  uint64_t v83;
  unint64_t v84;
  unint64_t v85;
  _QWORD v86[256];
  _QWORD v87[256];
  uint64_t v88;
  _QWORD v89[514];

  v1 = (unsigned __int8 *)MEMORY[0x1E0C80A78](a1);
  v89[512] = *MEMORY[0x1E0C80C00];
  v5 = v4 - v2;
  if (v5 < 2)
    return;
  v6 = v3;
  v7 = v2;
  v8 = v1;
  v9 = *v1;
  if ((char)*v1 < 0)
  {
    v10 = utf8_byte_length(unsigned char)::utf8_len_table[v9 >> 4];
    v11 = utf8_to_code_point(unsigned char const*)::utf8_first_char_mask[v10] & v9;
    if ((~(v9 >> 4) & 0xC) != 0)
    {
      LODWORD(v9) = utf8_to_code_point(unsigned char const*)::utf8_first_char_mask[v10] & v9;
    }
    else
    {
      if (v10 <= 2)
        v12 = 2;
      else
        v12 = utf8_byte_length(unsigned char)::utf8_len_table[v9 >> 4];
      v13 = v12 - 1;
      v14 = (char *)(v1 + 1);
      do
      {
        v15 = *v14++;
        LODWORD(v9) = v15 & 0x3F | (v11 << 6);
        v11 = v9;
        --v13;
      }
      while (v13);
    }
  }
  if (v9 >= 0x7F)
  {
    if ((v9 - 12352) > 0x5F)
      return;
    v16 = "ja";
  }
  else
  {
    v16 = "zh-Hans";
  }
  if (!strcmp(v16, "zh-Hans"))
  {
    v27 = 2;
LABEL_33:
    if (v5 < 3)
      return;
    v28 = v5;
    v29 = v8;
    do
    {
      v30 = *(char *)v29++;
      v31 = v30 - 97;
      if (v30 != 65 && v31 >= 0x1A)
        return;
      --v28;
    }
    while (v28);
    goto LABEL_40;
  }
  if (!strcmp(v16, "zh-Hant") || !strcmp(v16, "zh-HK"))
  {
    v27 = 4;
    goto LABEL_33;
  }
  if (strcmp(v16, "ja"))
    return;
  v17 = 0;
  v18 = v8;
  while (v18 < &v8[v5])
  {
    v19 = *v18;
    v20 = v19;
    if (*(char *)v18 < 0)
    {
      v21 = v19 >> 4;
      v22 = utf8_byte_length(unsigned char)::utf8_len_table[v19 >> 4];
      v20 = v19 & utf8_to_code_point(unsigned char const*)::utf8_first_char_mask[v22];
      if ((~(v19 >> 4) & 0xC) == 0)
      {
        if (v22 <= 2)
          v23 = 2;
        else
          v23 = utf8_byte_length(unsigned char)::utf8_len_table[v19 >> 4];
        v24 = v23 - 1;
        v25 = (char *)(v18 + 1);
        do
        {
          v26 = *v25++;
          v20 = v26 & 0x3F | (v20 << 6);
          --v24;
        }
        while (v24);
      }
    }
    else
    {
      v21 = v19 >> 4;
    }
    v18 += utf8_byte_length_noerror(unsigned char)::utf8_len_table[v21];
    ++v17;
    if ((v20 - 12352) >= 0x60)
      return;
  }
  if (v17 < 3)
    return;
  v27 = 1;
LABEL_40:
  v33 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v34 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v8, v5, 0x8000100u, 0);
  if (!v34)
    return;
  v35 = v34;
  Length = CFStringGetLength(v34);
  pthread_mutex_lock(&gMecabraLock);
  if (MecabraAnalysisForString_once != -1)
    dispatch_once(&MecabraAnalysisForString_once, &__block_literal_global_6329);
  if (MecabraAnalysisForString_valid != 1)
    goto LABEL_115;
  if (gMecabra && gMecabraType != (_DWORD)v27)
  {
    weak_MecabraCancelAnalysis();
    weak_MecabraRelease(gMecabra);
    gMecabra = 0;
    gMecabraType = 0;
LABEL_50:
    if (((1 << v27) & 0x16) == 0)
      goto LABEL_115;
    v36 = weak_MecabraCreateWithOptions(v27, 0, 4);
    gMecabra = v36;
    gMecabraType = v27;
    if (!v36)
      goto LABEL_115;
    goto LABEL_52;
  }
  v36 = gMecabra;
  if (!gMecabra)
    goto LABEL_50;
LABEL_52:
  if (!weak_MecabraAnalyzeString(v36, v35, 0))
    goto LABEL_115;
  v37 = CIRetainIndexingTokenizer(3u);
  if (!v37)
    goto LABEL_115;
  v38 = (uint64_t)v37;
  v74 = v33;
  CITokenizerSetLocale((uint64_t)v37, 0, v16);
  v83 = v36;
  NextCandidate = weak_MecabraGetNextCandidate(v36);
  if (!NextCandidate)
    goto LABEL_114;
  v40 = NextCandidate;
  v81 = v38;
  v73 = v35;
  v75 = 0;
  v76 = v6;
  v72 = v7;
  v41 = 1280;
  if (v7)
    v41 = 1281;
  v77 = v41;
  v78 = v8;
  v42 = Length;
  do
  {
    AnalysisString = (const __CFString *)weak_MecabraCandidateGetAnalysisString(v40);
    if (AnalysisString)
      AnalysisString = (const __CFString *)CFStringGetLength(AnalysisString);
    if ((uint64_t)AnalysisString < v42)
      goto LABEL_63;
    bzero(v89, 0x1000uLL);
    bzero(&v88, 0x800uLL);
    bzero(v87, 0x800uLL);
    bzero(v86, 0x800uLL);
    Surface = (const __CFString *)weak_MecabraCandidateGetSurface(v40);
    if (!v6
      || (CFStringGetLength(Surface),
          _NLStringTokenizerSetStringWithOptionsAndLanguageID(),
          v45 = _NLStringTokenizerTokenizeWithTranscriptions(),
          v45 < 2))
    {
LABEL_63:
      v46 = v83;
      goto LABEL_64;
    }
    v47 = v45;
    v48 = 0;
    v46 = v83;
    while (v87[v48])
    {
      if (v47 == ++v48)
        goto LABEL_71;
    }
    if (v48 != v47)
      goto LABEL_64;
LABEL_71:
    v80 = v71;
    MEMORY[0x1E0C80A78](v83);
    v50 = &v71[-((v49 + 15) & 0xFFFFFFFFFFFFFFF0)];
    bzero(v50, v49);
    v51 = 0;
    v84 = v47 - 1;
    v85 = v47;
    v79 = (const char *)v50;
    v52 = (char *)v78;
    do
    {
      if ((uint64_t)v87[v51] < 1)
      {
        v64 = 1;
        v54 = v50;
      }
      else
      {
        v53 = 0;
        v54 = v50;
        while (1)
        {
          v55 = *v52;
          v56 = v55;
          if (*v52 < 0)
          {
            v57 = utf8_byte_length(unsigned char)::utf8_len_table[v55 >> 4];
            v58 = v55 & utf8_to_code_point(unsigned char const*)::utf8_first_char_mask[v57];
            if ((~(v55 >> 4) & 0xC) != 0)
            {
              v56 = v55 & utf8_to_code_point(unsigned char const*)::utf8_first_char_mask[v57];
            }
            else
            {
              if (v57 <= 2)
                v59 = 2;
              else
                v59 = utf8_byte_length(unsigned char)::utf8_len_table[v55 >> 4];
              v60 = v59 - 1;
              v61 = v52 + 1;
              do
              {
                v62 = *v61++;
                v56 = v62 & 0x3F | (v58 << 6);
                v58 = v56;
                --v60;
              }
              while (v60);
            }
          }
          if (v56 != *(unsigned __int16 *)(v86[v51] + 2 * v53))
            break;
          v63 = utf8_byte_length_noerror(unsigned char)::utf8_len_table[v55 >> 4];
          memcpy(v54, v52, v63);
          v54 += v63;
          v52 += v63;
          if (++v53 >= v87[v51])
          {
            v64 = 1;
            goto LABEL_93;
          }
        }
        if (v53)
          v65 = v51 == v84;
        else
          v65 = 0;
        v64 = v65;
LABEL_93:
        v47 = v85;
      }
      v87[v51++] = v54 - (_BYTE *)v50;
      if (v51 != v47)
        *v54++ = 32;
      v50 = v54;
      if (v51 < v47)
        v66 = v64;
      else
        v66 = 0;
    }
    while ((v66 & 1) != 0);
    *v54 = 0;
    if ((v64 & 1) != 0)
    {
      v67 = CFStringCreateWithCString(v74, v79, 0x8000100u);
      v42 = Length;
      if (v67)
      {
        v68 = v67;
        Mutable = v75;
        if (!v75)
          Mutable = CFSetCreateMutable(v74, 0, MEMORY[0x1E0C9B3B0]);
        v70 = CFSetContainsValue(Mutable, v68);
        v75 = Mutable;
        if (!v70)
        {
          CFSetAddValue(Mutable, v68);
          CFRelease(v68);
          if (v72)
            *v50 = 42;
          v6 = v76;
          (*(void (**)(uint64_t, const char *, unint64_t, _QWORD *))(v76 + 16))(v76, v79, v47, v87);
          goto LABEL_108;
        }
        CFRelease(v68);
      }
      v6 = v76;
    }
    else
    {
      v6 = v76;
      v42 = Length;
    }
LABEL_108:
    v46 = v83;
LABEL_64:
    v40 = weak_MecabraGetNextCandidate(v46);
  }
  while (v40);
  v35 = v73;
  v38 = v81;
  if (v75)
    CFRelease(v75);
LABEL_114:
  CIReleaseIndexingTokenizer(v38);
LABEL_115:
  pthread_mutex_unlock(&gMecabraLock);
  CFRelease(v35);
}

CFComparisonResult ___safe_open_at_block_invoke(uint64_t a1, const __CFString **a2, const __CFString **a3)
{
  const __CFString *v4;
  const __CFString *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = *a2;
  v5 = *a3;
  v6 = MEMORY[0x1BCCAF3F0](*(_QWORD *)(a1 + 32), *a2);
  v7 = MEMORY[0x1BCCAF3F0](*(_QWORD *)(a1 + 32), v5);
  if (v6 < v7)
    return 0xFFFFFFFFLL;
  if (v6 <= v7)
    return CFStringCompare(v4, v5, 0);
  return 1;
}

int *__fd_create_protected_block_invoke()
{
  int rlim_cur;
  _DWORD *v1;
  int v2;
  int v3;
  NSObject *v4;
  os_log_type_t v5;
  int *result;
  rlimit v7;
  uint8_t buf[4];
  int v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v7.rlim_cur = 0;
  v7.rlim_max = 0;
  if (getrlimit(8, &v7))
    rlim_cur = 1024;
  else
    rlim_cur = v7.rlim_cur;
  gOpenLimit = rlim_cur;
  v1 = malloc_type_calloc(1uLL, 0x18uLL, 0x10200406E52F545uLL);
  g_fd_list = (uint64_t)v1;
  v2 = rlim_cur / 4;
  if (rlim_cur >= 512)
    v2 = 128;
  v1[2] = v2;
  v3 = *__error();
  v4 = _SILogForLogForCategory(0);
  v5 = 2 * (gSILogLevels[0] < 4);
  if (os_log_type_enabled(v4, v5))
  {
    *(_DWORD *)buf = 67109120;
    v9 = gOpenLimit;
    _os_log_impl(&dword_1B8270000, v4, v5, "fd limit %d", buf, 8u);
  }
  result = __error();
  *result = v3;
  return result;
}

_DWORD *fd_dup(uint64_t a1)
{
  _DWORD *v2;
  unsigned int *v3;
  unsigned int v4;
  char *v5;
  int v6;
  const char *v7;
  int v8;
  __int16 v9;
  uint64_t v10;
  unsigned int *v11;
  unsigned int v12;
  unsigned int *v14;
  unsigned int v15;
  char v16[1024];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0;
  pthread_mutex_lock(&g_fd_lock);
  v2 = *(_DWORD **)(a1 + 80);
  if (v2)
  {
    v3 = v2 + 8;
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
LABEL_5:
    pthread_mutex_unlock(&g_fd_lock);
    return v2;
  }
  pthread_mutex_unlock(&g_fd_lock);
  bzero(v16, 0x400uLL);
  v5 = fd_name(a1, v16, 0x400uLL);
  if (!v5 || (v6 = *(_DWORD *)(a1 + 44), v6 == -1))
  {
    v2 = 0;
  }
  else
  {
    v7 = v5;
    v8 = *(_DWORD *)(a1 + 48);
    v2 = malloc_type_calloc(1uLL, 0x68uLL, 0x10300409CE040BCuLL);
    *v2 = -50529037;
    v2[8] = 1;
    v9 = v2[14] & 0xFFFB | (4 * ((*(_WORD *)(a1 + 56) >> 2) & 1));
    *((_WORD *)v2 + 28) = v9;
    v2[11] = v6;
    v2[12] = v8;
    *((_QWORD *)v2 + 9) = strdup(v7);
    *((_WORD *)v2 + 28) = *(_WORD *)(a1 + 56) & 0xFF0 | v9 & 0xF00F;
    v2[10] = -1;
  }
  pthread_mutex_lock(&g_fd_lock);
  v10 = *(_QWORD *)(a1 + 80);
  if (!v10)
  {
    if (v2)
    {
      v14 = v2 + 8;
      do
        v15 = __ldxr(v14);
      while (__stxr(v15 + 1, v14));
    }
    *(_QWORD *)(a1 + 80) = v2;
    goto LABEL_5;
  }
  v11 = (unsigned int *)(v10 + 32);
  do
    v12 = __ldxr(v11);
  while (__stxr(v12 + 1, v11));
  pthread_mutex_unlock(&g_fd_lock);
  fd_release((char *)v2);
  return (_DWORD *)v10;
}

_QWORD *fd_create_sibling_protected(uint64_t a1, const char *a2, int a3, unsigned __int8 a4)
{
  _QWORD *v8;
  char *v9;
  int v10;
  int v11;
  NSObject *v12;
  uint64_t v14;
  int v15;
  int v16;
  uint64_t v17;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0;
  v8 = malloc_type_malloc(0x68uLL, 0x10300409CE040BCuLL);
  *(_DWORD *)v8 = -50529037;
  v8[2] = 0;
  v8[3] = 0;
  v8[4] = 1;
  *((_DWORD *)v8 + 10) = -1;
  *((_DWORD *)v8 + 11) = *(_DWORD *)(a1 + 44);
  *((_DWORD *)v8 + 12) = a3 | (((a3 & 3) != 0) << 29);
  LOWORD(a3) = *((_WORD *)v8 + 28);
  *((_WORD *)v8 + 30) &= 0xFC00u;
  *((_WORD *)v8 + 28) = a3 & 0xFFF0;
  v9 = strdup(a2);
  *((_BYTE *)v8 + 52) = 0;
  v8[9] = v9;
  v8[10] = 0;
  v8[11] = 0;
  v8[12] = 0;
  *((_WORD *)v8 + 28) = a3 & 0xF000 | (16 * a4);
  v17 = 0;
  v10 = _fd_acquire_fd((uint64_t)v8, &v17);
  if (v10 == -1)
  {
    v11 = *__error();
    v12 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      v14 = v8[9];
      v15 = *((_DWORD *)v8 + 11);
      v16 = *__error();
      *(_DWORD *)buf = 136316162;
      v19 = "fd_create_sibling_protected";
      v20 = 1024;
      v21 = 380;
      v22 = 2080;
      v23 = v14;
      v24 = 1024;
      v25 = v15;
      v26 = 1024;
      v27 = v16;
      _os_log_error_impl(&dword_1B8270000, v12, OS_LOG_TYPE_ERROR, "%s:%d: Open failed on %s child of %d with error %d", buf, 0x28u);
    }
    *__error() = v11;
    fd_release((char *)v8);
    return 0;
  }
  *((_DWORD *)v8 + 12) &= 0xFFFFF9FF;
  _fd_release_fd(v8, v10, 0, v17);
  return v8;
}

_QWORD *fd_create_sibling_with_suffix_protected(uint64_t a1, const char *a2, int a3)
{
  _QWORD *sibling_protected;
  char *v7;

  if (!a1)
    return 0;
  v7 = 0;
  asprintf(&v7, "%s%s", *(const char **)(a1 + 72), a2);
  sibling_protected = fd_create_sibling_protected(a1, v7, a3, 3u);
  free(v7);
  return sibling_protected;
}

uint64_t fd_truncate_and_make_readonly(uint64_t a1, off_t a2)
{
  uint64_t result;
  uint64_t v4;
  uint64_t v6;
  int *v7;

  result = fd_truncate(a1, a2);
  if (!(_DWORD)result)
  {
    result = fd_make_readonly(a1);
    if (a1)
    {
      do
      {
        result = fchmodat(*(_DWORD *)(a1 + 44), *(const char **)(a1 + 72), 0x100u, 2048);
        v4 = g_prot_error_callback;
        if ((_DWORD)result != -1 || g_prot_error_callback == 0)
          break;
        v6 = *(unsigned int *)(a1 + 40);
        v7 = __error();
        result = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t))(v4 + 16))(v4, v6, *v7, 19);
      }
      while ((result & 1) != 0);
    }
  }
  return result;
}

uint64_t fd_make_readonly(uint64_t result)
{
  uint64_t v1;
  int v2;
  char *v3;
  char *v4;
  const char *v5;
  uint64_t v6;
  uint64_t v7;

  if (result)
  {
    v1 = result;
    v7 = 0;
    if (*(_DWORD *)result != -50529037)
    {
      v3 = __si_assert_copy_extra_521(-1);
      v4 = v3;
      v5 = "";
      if (v3)
        v5 = v3;
      __message_assert("%s:%u: failed assertion '%s' %s ", "fd_obj.c", 1202, "obj->_magic==(0xFCFCFCF3)", v5);
      free(v4);
      if (__valid_fs(-1))
        v6 = 2989;
      else
        v6 = 3072;
      *(_DWORD *)v6 = -559038737;
      abort();
    }
    *(_DWORD *)(result + 48) = 0;
    pthread_mutex_lock(&g_fd_lock);
    if (*(_DWORD *)(v1 + 36) || *(_DWORD *)(v1 + 40) == -1)
    {
      return pthread_mutex_unlock(&g_fd_lock);
    }
    else
    {
      v2 = _fd_remove_locked(v1, &v7);
      result = pthread_mutex_unlock(&g_fd_lock);
      if (v2 != -1)
        return guarded_close_np();
    }
  }
  return result;
}

uint64_t fd_zero_truncate(uint64_t a1)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  int v5;
  uint64_t v7;

  v7 = 0;
  v2 = _fd_acquire_fd(a1, &v7);
  if ((_DWORD)v2 == -1)
    return 0xFFFFFFFFLL;
  v3 = v2;
  if ((*(_BYTE *)(a1 + 48) & 3) == 0)
  {
    _fd_release_fd((_DWORD *)a1, v2, 0, v7);
    v5 = 1;
LABEL_6:
    *__error() = v5;
    return 0xFFFFFFFFLL;
  }
  v4 = _fd_ftruncate_guarded(v2, (uint64_t)&v7, 0);
  v5 = *__error();
  *(_WORD *)(a1 + 56) &= ~2u;
  _fd_release_fd((_DWORD *)a1, v3, 0, v7);
  if ((_DWORD)v4 == -1)
    goto LABEL_6;
  return v4;
}

BOOL fd_validfs(_DWORD *a1)
{
  int v2;
  int v3;
  int v4;
  uint64_t v6;
  statfs v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v6 = 0;
  v2 = _fd_acquire_fd((uint64_t)a1, &v6);
  if (v2 == -1)
    return 0;
  v3 = v2;
  bzero(&v7, 0x878uLL);
  v4 = fstatfs(v3, &v7);
  _fd_release_fd(a1, v3, 0, v6);
  return v4 == 0;
}

uint64_t fd_stat(uint64_t a1, stat *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v7;
  int *v8;

  if (!a1)
    return 0xFFFFFFFFLL;
  while (1)
  {
    result = fstatat(*(_DWORD *)(a1 + 44), *(const char **)(a1 + 72), a2, 2048);
    v5 = g_prot_error_callback;
    if ((_DWORD)result != -1 || g_prot_error_callback == 0)
      break;
    v7 = *(unsigned int *)(a1 + 40);
    v8 = __error();
    if (((*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t))(v5 + 16))(v5, v7, *v8, 8) & 1) == 0)
      return 0xFFFFFFFFLL;
  }
  return result;
}

_BYTE *fd_realpath(_DWORD *a1, _BYTE *a2)
{
  int v4;
  int v5;
  uint64_t v7;

  v7 = 0;
  v4 = _fd_acquire_fd((uint64_t)a1, &v7);
  if (v4 == -1)
    return 0;
  v5 = v4;
  if (fcntl(v4, 50, a2) < 0 || !*a2)
    a2 = 0;
  _fd_release_fd(a1, v5, 0, v7);
  return a2;
}

uint64_t fd_sync(uint64_t a1, int a2)
{
  uint64_t result;
  int v5;
  _BOOL4 v6;
  uint64_t v7;
  uint64_t v8;

  v8 = 0;
  result = _fd_acquire_fd(a1, &v8);
  if ((_DWORD)result != -1)
  {
    v5 = result;
    if (a2)
      v6 = (*(_WORD *)(a1 + 56) & 8) == 0;
    else
      v6 = 0;
    v7 = prot_fsync(result, v6);
    _fd_release_fd((_DWORD *)a1, v5, 0, v8);
    return v7;
  }
  return result;
}

uint64_t _fd_unlink_with_origin(uint64_t a1, int a2)
{
  char *v4;
  const char *v5;
  int v6;
  NSObject *v7;
  __int16 v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  unsigned int v14;
  _BYTE buf[24];
  char v16[1024];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0xFFFFFFFFLL;
  v14 = 0;
  if (!fd_setDir(*(unsigned int *)(a1 + 44), (int *)&v14))
    return 0xFFFFFFFFLL;
  bzero(v16, 0x400uLL);
  v4 = fd_name(a1, v16, 0x400uLL);
  if (v4)
  {
    v5 = v4;
    v6 = *__error();
    v7 = _SILogForLogForCategory(6);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = v5;
      _os_log_impl(&dword_1B8270000, v7, OS_LOG_TYPE_DEFAULT, "Unlink %s", buf, 0xCu);
    }
    *__error() = v6;
    os_unfair_lock_lock((os_unfair_lock_t)&map_guard_lock);
    v8 = *(_WORD *)(a1 + 60);
    if (!(_BYTE)v8)
    {
      *(_WORD *)(a1 + 60) = v8 & 0xFCFF | 0x200;
      *(_DWORD *)(a1 + 64) = a2;
      os_unfair_lock_unlock((os_unfair_lock_t)&map_guard_lock);
      if ((*(_BYTE *)(a1 + 48) & 3) != 0)
      {
        *(_QWORD *)buf = 0;
        v10 = _fd_acquire_fd(a1, buf);
        if ((_DWORD)v10 != -1)
        {
          v11 = v10;
          _fd_ftruncate_guarded(v10, (uint64_t)buf, 0);
          _fd_release_fd((_DWORD *)a1, v11, 0, *(uint64_t *)buf);
        }
      }
      v9 = unlink(v5);
      goto LABEL_14;
    }
    *(_WORD *)(a1 + 60) = v8 | 0x100;
    *(_DWORD *)(a1 + 64) = a2;
    os_unfair_lock_unlock((os_unfair_lock_t)&map_guard_lock);
  }
  v9 = 0xFFFFFFFFLL;
LABEL_14:
  v12 = v14;
  MEMORY[0x1BCCB1484](v14);
  if ((v12 & 0x80000000) == 0)
    close(v12);
  return v9;
}

void fd_guarded_munmap(uint64_t a1, void *a2, size_t a3)
{
  __int16 v6;
  BOOL v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  int *v19;
  char v20;

  os_unfair_lock_lock((os_unfair_lock_t)&map_guard_lock);
  v6 = *(_WORD *)(a1 + 60);
  if ((_BYTE)v6)
  {
    *(_WORD *)(a1 + 60) = v6 & 0xFF00 | (v6 - 1);
    if ((_BYTE)v6 == 1)
    {
      *(_WORD *)(a1 + 60) = v6 & 0xFF00;
      v7 = (v6 & 0x100) == 0;
    }
    else
    {
      v7 = 1;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&map_guard_lock);
    v16 = 0;
    do
    {
      if (a2 != (void *)-1)
        v16 = munmap(a2, a3);
      if (v16 != -1)
        break;
      v17 = g_prot_error_callback;
      if (!g_prot_error_callback)
        break;
      v18 = *(unsigned int *)(a1 + 40);
      v19 = __error();
      v20 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t))(v17 + 16))(v17, v18, *v19, 11);
      v16 = -1;
    }
    while ((v20 & 1) != 0);
    if (!v7)
      _fd_unlink_with_origin(a1, 871);
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&map_guard_lock);
    si_analytics_log_6463(v8, v9, v10, v11, v12, v13, v14, v15, a1);
  }
}

void si_analytics_log_6463(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  xpc_object_t v9;
  xpc_object_t v10;
  char *string[2];
  xpc_object_t values;
  _BYTE keys[24];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  string[0] = 0;
  string[1] = &a9;
  vasprintf(string, "Overrelease of fd_obj %p", &a9);
  SISetCrashCStr(string[0]);
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)keys = 136315138;
    *(char **)&keys[4] = string[0];
    _os_log_fault_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "%s", keys, 0xCu);
  }
  *(_QWORD *)keys = "crash_string";
  v9 = xpc_string_create(string[0]);
  values = v9;
  v10 = xpc_dictionary_create((const char *const *)keys, &values, 1uLL);
  analytics_send_event();
  xpc_release(v10);
  xpc_release(v9);
  free(string[0]);
}

_DWORD *fd_read_advise(_DWORD *a1, uint64_t a2)
{
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v8;
  int *v9;
  uint64_t v11;

  v11 = 0;
  v4 = _fd_acquire_fd((uint64_t)a1, &v11);
  do
  {
    v5 = fcntl(v4, 44, a2);
    v6 = g_prot_error_callback;
    if (v5 != -1 || g_prot_error_callback == 0)
      break;
    v8 = a1[10];
    v9 = __error();
  }
  while (((*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t))(v6 + 16))(v6, v8, *v9, 12) & 1) != 0);
  return _fd_release_fd(a1, v4, 0, v11);
}

uint64_t fd_hold_assertion(uint64_t a1, uint64_t a2, double a3)
{
  int v6;
  uint64_t v7;
  size_t v8;
  uint64_t v9;
  int v10;
  NSObject *v11;
  int v12;
  NSObject *v13;
  int v15;
  int *v16;
  char *v17;
  int *v18;
  char *v19;
  int v20;
  _QWORD v21[2];
  uint64_t v22;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  int v26;
  __int16 v27;
  char *v28;
  __int16 v29;
  int v30;
  char __s[4];
  const char *v32;
  __int16 v33;
  int v34;
  __int16 v35;
  char *v36;
  __int16 v37;
  int v38;
  __int16 v39;
  char *v40;
  char v41[1024];
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  v22 = 0;
  v6 = _fd_acquire_fd(a1, &v22);
  v21[0] = 0;
  v21[1] = (unint64_t)(a3 * 1000000000.0);
  v7 = fcntl(v6, 108, v21);
  bzero(v41, 0x400uLL);
  fd_name(a1, v41, 0x400uLL);
  if ((v7 & 0x80000000) != 0)
  {
    v12 = *__error();
    v13 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      v15 = *__error();
      v16 = __error();
      v17 = strerror(*v16);
      *(_DWORD *)__s = 136316162;
      v32 = "fd_hold_assertion";
      v33 = 1024;
      v34 = 903;
      v35 = 2080;
      v36 = v41;
      v37 = 1024;
      v38 = v15;
      v39 = 2080;
      v40 = v17;
      _os_log_error_impl(&dword_1B8270000, v13, OS_LOG_TYPE_ERROR, "%s:%d: Unable to take assertion on %s: %d(%s)", (uint8_t *)__s, 0x2Cu);
    }
    *__error() = v12;
  }
  else if (a2)
  {
    bzero(__s, 0x402uLL);
    __sprintf_chk(__s, 0, 0x402uLL, "%s$", v41);
    v8 = strlen(__s);
    v9 = fd_write(a2, (uint64_t)__s, v8);
    if (v9 != strlen(__s))
    {
      v10 = *__error();
      v11 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        v18 = __error();
        v19 = strerror(*v18);
        v20 = *__error();
        *(_DWORD *)buf = 136315906;
        v24 = "fd_hold_assertion";
        v25 = 1024;
        v26 = 908;
        v27 = 2080;
        v28 = v19;
        v29 = 1024;
        v30 = v20;
        _os_log_error_impl(&dword_1B8270000, v11, OS_LOG_TYPE_ERROR, "%s:%d: bg assertion touch file write error: %s(%d)", buf, 0x22u);
      }
      *__error() = v10;
      v7 = 0xFFFFFFFFLL;
    }
  }
  if (a1)
  {
    *(CFAbsoluteTime *)(a1 + 88) = CFAbsoluteTimeGetCurrent() + a3;
    _fd_release_fd((_DWORD *)a1, v6, 0, v22);
  }
  return v7;
}

uint64_t fd_drop_assertion(uint64_t a1)
{
  int v2;
  int v3;
  uint64_t v4;
  int v5;
  NSObject *v6;
  char *v8;
  int v9;
  int *v10;
  char *v11;
  int v12;
  NSObject *v13;
  uint64_t v14;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  char *v20;
  __int16 v21;
  int v22;
  __int16 v23;
  char *v24;
  uint8_t v25[1032];
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  pthread_mutex_lock(&g_fd_lock);
  if (a1)
  {
    v2 = *(_DWORD *)(a1 + 40);
    pthread_mutex_unlock(&g_fd_lock);
    if (v2 != -1)
    {
      v14 = 0;
      v3 = _fd_acquire_fd(a1, &v14);
      v4 = fcntl(v3, 109, 0);
      if ((v4 & 0x80000000) != 0)
      {
        bzero(v25, 0x400uLL);
        v5 = *__error();
        v6 = _SILogForLogForCategory(10);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        {
          v8 = fd_name(a1, (char *)v25, 0x400uLL);
          v9 = *__error();
          v10 = __error();
          v11 = strerror(*v10);
          *(_DWORD *)buf = 136316162;
          v16 = "fd_drop_assertion";
          v17 = 1024;
          v18 = 933;
          v19 = 2080;
          v20 = v8;
          v21 = 1024;
          v22 = v9;
          v23 = 2080;
          v24 = v11;
          _os_log_error_impl(&dword_1B8270000, v6, OS_LOG_TYPE_ERROR, "%s:%d: Unable to drop assertion on %s: %d(%s)", buf, 0x2Cu);
        }
        *__error() = v5;
      }
      *(_QWORD *)(a1 + 88) = 0;
      _fd_release_fd((_DWORD *)a1, v3, 0, v14);
      return v4;
    }
  }
  else
  {
    pthread_mutex_unlock(&g_fd_lock);
  }
  if (dword_1EF19FCB4 < 5)
    return 0;
  v12 = *__error();
  v13 = _SILogForLogForCategory(10);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v25 = 0;
    _os_log_impl(&dword_1B8270000, v13, OS_LOG_TYPE_DEFAULT, "Unable to drop assertion as obj is invalid", v25, 2u);
  }
  v4 = 0;
  *__error() = v12;
  return v4;
}

void fd_update_assertion(uint64_t a1, int a2)
{
  double v4;
  double v5;
  _QWORD v6[2];

  v4 = *(double *)(a1 + 88);
  v5 = v4 - CFAbsoluteTimeGetCurrent();
  if (v5 > 0.0)
  {
    v6[0] = 0;
    v6[1] = (unint64_t)(v5 * 1000000000.0);
    if (fcntl(a2, 108, v6))
      *(_QWORD *)(a1 + 88) = 0;
  }
}

_DWORD *fd_no_cache(uint64_t a1)
{
  _DWORD *result;
  int v3;
  uint64_t v4;

  v4 = 0;
  result = (_DWORD *)_fd_acquire_fd(a1, &v4);
  if ((_DWORD)result != -1)
  {
    v3 = (int)result;
    *(_WORD *)(a1 + 56) |= 1u;
    fcntl((int)result, 48, 1);
    fcntl(v3, 76, *(_WORD *)(a1 + 56) & 1);
    return _fd_release_fd((_DWORD *)a1, v3, 0, v4);
  }
  return result;
}

uint64_t fd_rename(uint64_t a1, const char *a2)
{
  int v4;
  int v5;
  char *v6;
  char *v7;
  void *v8;
  char *v9;
  int v10;
  int v11;
  NSObject *v12;
  const char *v14;
  const char *v15;
  _BYTE v16[12];
  __int16 v17;
  int v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  int v24;
  char v25[1024];
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    *(_QWORD *)v16 = 0;
    v4 = _fd_acquire_fd(a1, v16);
    if (v4 != -1)
    {
      v5 = v4;
      bzero(v25, 0x400uLL);
      v6 = fd_name(a1, v25, 0x400uLL);
      if (v6 && renameat(*(_DWORD *)(a1 + 44), v6, *(_DWORD *)(a1 + 44), a2) != -1)
      {
        v7 = strdup(a2);
        os_unfair_lock_lock((os_unfair_lock_t)&g_name_lock);
        v8 = *(void **)(a1 + 72);
        *(_QWORD *)(a1 + 72) = v7;
        os_unfair_lock_unlock((os_unfair_lock_t)&g_name_lock);
        free(v8);
        _fd_release_fd((_DWORD *)a1, v5, 0, *(uint64_t *)v16);
        pthread_mutex_lock(&g_fd_lock);
        v9 = *(char **)(a1 + 80);
        if (v9)
        {
          *(_QWORD *)(a1 + 80) = 0;
          pthread_mutex_unlock(&g_fd_lock);
          fd_release(v9);
        }
        else
        {
          pthread_mutex_unlock(&g_fd_lock);
        }
        return 0;
      }
      _fd_release_fd((_DWORD *)a1, v5, 0, *(uint64_t *)v16);
    }
  }
  else
  {
    *__error() = 22;
  }
  bzero(v25, 0x400uLL);
  v10 = *__error();
  v11 = *__error();
  v12 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    v14 = fd_realpath((_DWORD *)a1, v25);
    *(_DWORD *)v16 = 136316162;
    *(_QWORD *)&v16[4] = "fd_rename";
    v15 = "";
    v17 = 1024;
    if (v14)
      v15 = v14;
    v18 = 1079;
    v19 = 2080;
    v20 = v15;
    v21 = 2080;
    v22 = a2;
    v23 = 1024;
    v24 = v10;
    _os_log_error_impl(&dword_1B8270000, v12, OS_LOG_TYPE_ERROR, "%s:%d: rename(%s, %s) err:%d", v16, 0x2Cu);
  }
  *__error() = v11;
  *__error() = v10;
  return 0xFFFFFFFFLL;
}

uint64_t fd_name_ptr(uint64_t a1)
{
  uint64_t v2;
  char *v4;
  char *v5;
  const char *v6;
  uint64_t v7;

  if (*(_DWORD *)a1 != -50529037)
  {
    v4 = __si_assert_copy_extra_521(-1);
    v5 = v4;
    v6 = "";
    if (v4)
      v6 = v4;
    __message_assert("%s:%u: failed assertion '%s' %s ", "fd_obj.c", 1188, "obj->_magic==(0xFCFCFCF3)", v6);
    free(v5);
    if (__valid_fs(-1))
      v7 = 2989;
    else
      v7 = 3072;
    *(_DWORD *)v7 = -559038737;
    abort();
  }
  os_unfair_lock_lock((os_unfair_lock_t)&g_name_lock);
  v2 = *(_QWORD *)(a1 + 72);
  os_unfair_lock_unlock((os_unfair_lock_t)&g_name_lock);
  return v2;
}

_DWORD *fd_mark_purgable(_DWORD *a1)
{
  _DWORD *result;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  NSObject *v8;
  BOOL v9;
  _BYTE *v10;
  uint64_t v11;
  uint64_t v12;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  _BYTE *v18;
  __int16 v19;
  uint64_t v20;
  __int16 v21;
  int v22;
  _BYTE v23[1024];
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v11 = 0;
  v12 = 67589;
  result = (_DWORD *)_fd_acquire_fd((uint64_t)a1, &v11);
  if ((_DWORD)result != -1)
  {
    v3 = (int)result;
    if (ffsctl((int)result, 0xC0084A44uLL, &v12, 0) == -1)
    {
      v4 = *__error();
      bzero(v23, 0x400uLL);
      v5 = fcntl(a1[11], 50, v23);
      v6 = v23[0];
      v7 = *__error();
      v8 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        if (v6)
          v9 = v5 < 0;
        else
          v9 = 1;
        if (v9)
          v10 = 0;
        else
          v10 = v23;
        *(_DWORD *)buf = 136316162;
        v14 = "fd_mark_purgable";
        v15 = 1024;
        v16 = 1683;
        v17 = 2080;
        v18 = v10;
        v19 = 2048;
        v20 = v12;
        v21 = 1024;
        v22 = v4;
        _os_log_error_impl(&dword_1B8270000, v8, OS_LOG_TYPE_ERROR, "%s:%d: mark purgable failed, path:%s flags:0x%ld errno:%d", buf, 0x2Cu);
      }
      *__error() = v7;
      _fd_release_fd(a1, v3, 0, v11);
      result = __error();
      *result = v4;
    }
    else
    {
      return _fd_release_fd(a1, v3, 0, v11);
    }
  }
  return result;
}

_DWORD *fd_invalidate(_DWORD *result)
{
  uint64_t v1;
  char *v2;
  char *v3;
  const char *v4;
  uint64_t v5;
  uint64_t v6;

  if (result)
  {
    v1 = (uint64_t)result;
    if (*result != -50529037)
    {
      v2 = __si_assert_copy_extra_521(-1);
      v3 = v2;
      v4 = "";
      if (v2)
        v4 = v2;
      __message_assert("%s:%u: failed assertion '%s' %s ", "fd_obj.c", 1700, "obj->_magic==(0xFCFCFCF3)", v4);
      free(v3);
      if (__valid_fs(-1))
        v5 = 2989;
      else
        v5 = 3072;
      *(_DWORD *)v5 = -559038737;
      abort();
    }
    pthread_mutex_lock(&g_fd_lock);
    *(_BYTE *)(v1 + 52) = 1;
    if (!*(_DWORD *)(v1 + 36))
      return (_DWORD *)pthread_mutex_unlock(&g_fd_lock);
    v6 = 0;
    if (_fd_remove_locked(v1, &v6) == -1)
    {
      return (_DWORD *)pthread_mutex_unlock(&g_fd_lock);
    }
    else
    {
      *(_WORD *)(v1 + 56) &= ~8u;
      pthread_mutex_unlock(&g_fd_lock);
      return (_DWORD *)guarded_close_np();
    }
  }
  return result;
}

_DWORD *fd_warmup(_DWORD *a1)
{
  _DWORD *result;
  uint64_t v3;

  v3 = 0;
  result = (_DWORD *)_fd_acquire_fd((uint64_t)a1, &v3);
  if ((_DWORD)result != -1)
  {
    a1[17] = 1;
    return _fd_release_fd(a1, (int)result, 0, v3);
  }
  return result;
}

uint64_t fd_copyfile(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6;
  const char *v7;
  int v8;
  const char *v9;
  int v10;
  uint64_t v11;
  int *v12;
  int v13;
  int v15;
  int v16;
  int v17;
  int v18;
  __n128 v19;
  int v20;
  int v21;
  int v22;
  NSObject *v23;
  uint8_t v24[12];
  int v25;
  uint64_t __buf;
  int v27;

  v27 = 0;
  if (!a1)
  {
    v12 = __error();
    v13 = 2;
LABEL_8:
    *v12 = v13;
    return 0xFFFFFFFFLL;
  }
  if (!a2)
  {
    v12 = __error();
    v13 = 22;
    goto LABEL_8;
  }
  v6 = *(unsigned int *)(a1 + 44);
  v7 = *(const char **)(a1 + 72);
  v8 = *(_DWORD *)(a2 + 44);
  v9 = *(const char **)(a2 + 72);
  if (a3)
  {
    v10 = copyFileFallback(v6, v7, v8, v9, &v27, 1, 1);
    v11 = v10 ^ 1u;
    if ((v10 & 1) == 0)
      return v11;
  }
  else
  {
    v11 = copyFileFallback(v6, v7, v8, v9, &v27, 0, 0) ^ 1;
    if ((v11 & 1) != 0)
      return v11;
  }
  if (*(_DWORD *)(a2 + 40) != -1)
  {
    __buf = 0;
    pthread_mutex_lock(&g_fd_lock);
    v15 = _fd_remove_locked(a2, &__buf);
    pthread_mutex_unlock(&g_fd_lock);
    if (v15 != -1)
    {
      guarded_close_np();
      v20 = _fd_open(*(unsigned int *)(a2 + 44), *(char **)(a2 + 72), *(_DWORD *)(a2 + 48), *(_WORD *)(a2 + 56) & 1, (*(unsigned __int16 *)(a2 + 56) >> 4), v16, v17, v18, v19);
      arc4random_buf(&__buf, 8uLL);
      v25 = *(_DWORD *)(a2 + 48);
      v21 = change_fdguard_np();
      __error();
      if (v21 && gSILogLevels[0] >= 5)
      {
        v22 = *__error();
        v23 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)v24 = 0;
          _os_log_impl(&dword_1B8270000, v23, OS_LOG_TYPE_DEFAULT, "copy file failed to change fdguard", v24, 2u);
        }
        *__error() = v22;
      }
      if (v20 != -1)
      {
        pthread_mutex_lock(&g_fd_lock);
        if (*(_DWORD *)(a2 + 40) == -1)
        {
          *(_DWORD *)(a2 + 40) = v20;
          *(_QWORD *)(a2 + 8) = __buf;
          fd_update_assertion(a2, v20);
          _fd_update_locked(a2, 1, &__buf);
        }
        pthread_mutex_unlock(&g_fd_lock);
        guarded_close_np();
      }
    }
  }
  return v11;
}

uint64_t RLEOIDArrayCloseOid_locked(uint64_t a1, unint64_t a2)
{
  uint64_t result;
  int v4;

  if (*(_BYTE *)(a1 + 384))
    return 0;
  v4 = *(_DWORD *)(a1 + 224);
  if (v4)
    a2 = *(_QWORD *)(a1 + 216) | a2 & ~(-1 << ((60 - 4 * v4) & 0xFC));
  result = SIValueSet<unsigned long long>::_SIValueSetInnerClose(a1 + 256, a2, v4);
  if (result)
    return *(_QWORD *)(a1 + 216) | result;
  return result;
}

uint64_t SIValueSet<unsigned long long>::_SIValueSetInnerClose(uint64_t a1, unint64_t a2, int a3)
{
  uint64_t v5;
  char v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t result;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unsigned __int8 v19;
  unint64_t v20;
  uint64_t v22;

  v5 = (a3 + 1);
  v6 = (64 - 4 * (a3 + 1)) & 0xFC;
  v7 = a2 >> v6;
  v8 = (a2 >> v6) & 0xF;
  v9 = *(_QWORD *)(a1 + 8 * v8);
  if ((v9 & 1) != 0)
  {
    result = SIValueSet<unsigned long long>::_SIValueSetInnerClose(v9 & 0xFFFFFFFFFFFFFFFELL, a2, (a3 + 1));
    if (result)
      return result;
  }
  else if (v9)
  {
    v10 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(_QWORD *)v9 + 24))(v9, a2, ~(-1 << v6));
    if (v10)
    {
      v11 = (-1 << v6) & a2;
      return v10 | v11;
    }
  }
  v13 = v7 & 0xF;
  v14 = 1 << v6;
  v15 = (1 << v6) - 1;
  if (v13 != 15)
  {
    v16 = v8 + 1;
    v17 = v14 + a2;
    do
    {
      v18 = *(_QWORD *)(a1 + 8 * v16);
      if ((v18 & 1) != 0)
      {
        result = SIValueSet<unsigned long long>::_SIValueSetInnerClose(v18 & 0xFFFFFFFFFFFFFFFELL, v17, v5);
        if (result)
          return result;
      }
      else if (v18)
      {
        v10 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(_QWORD *)v18 + 24))(v18, v17, v15);
        if (v10)
        {
          v11 = v17 & -v14;
          return v10 | v11;
        }
      }
      ++v16;
      v17 += v14;
    }
    while (v16 != 16);
    if (v13 <= 1)
      return 0;
  }
  v19 = v8 - 1;
  v20 = a2 - v14;
  while (1)
  {
    v22 = *(_QWORD *)(a1 + 8 * v19);
    if ((v22 & 1) != 0)
    {
      result = SIValueSet<unsigned long long>::_SIValueSetInnerClose(v22 & 0xFFFFFFFFFFFFFFFELL, v20, v5);
      if (result)
        return result;
      goto LABEL_17;
    }
    if (v22)
    {
      v10 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(_QWORD *)v22 + 24))(v22, v20, v15);
      if (v10)
        break;
    }
LABEL_17:
    v20 -= v14;
    if (!(unint64_t)(v19-- & 0xFE))
      return 0;
  }
  v11 = v20 & -v14;
  return v10 | v11;
}

uint64_t RLEOIDArrayAddOid(uint64_t a1, unint64_t a2)
{
  pthread_rwlock_t *v4;

  v4 = (pthread_rwlock_t *)(a1 + 16);
  pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 16));
  SIValueSet<unsigned long long>::SIValueSetInsert((unint64_t *)(a1 + 216), a2);
  return pthread_rwlock_unlock(v4);
}

uint64_t RLEOIDArrayAddOid_locked(uint64_t a1, unint64_t a2)
{
  return SIValueSet<unsigned long long>::SIValueSetInsert((unint64_t *)(a1 + 216), a2);
}

uint64_t RLEOIDArrayCreate(const __CFAllocator *a1, unint64_t *a2, uint64_t a3)
{
  uint64_t Instance;
  void *v7;
  unint64_t v8;

  if (!__kRLEOIDArrayTypeID)
    __kRLEOIDArrayTypeID = _CFRuntimeRegisterClass();
  Instance = _CFRuntimeCreateInstance();
  *(_QWORD *)(Instance + 216) = 0;
  *(_DWORD *)(Instance + 224) = 0;
  *(_QWORD *)(Instance + 240) = 0;
  *(_QWORD *)(Instance + 248) = a1;
  v7 = CFAllocatorAllocate(a1, 8072, 0);
  bzero(v7, 0x1F88uLL);
  *(_QWORD *)(Instance + 232) = v7;
  *(_OWORD *)(Instance + 256) = 0u;
  *(_OWORD *)(Instance + 272) = 0u;
  *(_OWORD *)(Instance + 288) = 0u;
  *(_OWORD *)(Instance + 304) = 0u;
  *(_OWORD *)(Instance + 320) = 0u;
  *(_OWORD *)(Instance + 336) = 0u;
  *(_OWORD *)(Instance + 352) = 0u;
  *(_OWORD *)(Instance + 368) = 0u;
  for (*(_BYTE *)(Instance + 384) = 1; a3; --a3)
  {
    v8 = *a2++;
    SIValueSet<unsigned long long>::SIValueSetInsert((unint64_t *)(Instance + 216), v8);
  }
  return Instance;
}

uint64_t RLEOIDArrayCreateMutableCopy(const __CFAllocator *a1, uint64_t a2, uint64_t a3)
{
  uint64_t Instance;
  void *v6;

  if (!__kRLEOIDArrayTypeID)
    __kRLEOIDArrayTypeID = _CFRuntimeRegisterClass();
  Instance = _CFRuntimeCreateInstance();
  pthread_rwlock_rdlock((pthread_rwlock_t *)(a3 + 16));
  *(_QWORD *)(Instance + 216) = *(_QWORD *)(a3 + 216);
  *(_DWORD *)(Instance + 224) = *(_DWORD *)(a3 + 224);
  *(_QWORD *)(Instance + 240) = 0;
  *(_QWORD *)(Instance + 248) = a1;
  v6 = CFAllocatorAllocate(a1, 8072, 0);
  bzero(v6, 0x1F88uLL);
  *(_QWORD *)(Instance + 232) = v6;
  SIValueSet<unsigned long long>::CombLevel_s::CombLevel_s(Instance + 256, a3 + 256, *(_DWORD *)(Instance + 224), Instance + 232);
  *(_BYTE *)(Instance + 384) = *(_BYTE *)(a3 + 384);
  pthread_rwlock_unlock((pthread_rwlock_t *)(a3 + 16));
  return Instance;
}

uint64_t SIValueSet<unsigned long long>::CombLevel_s::CombLevel_s(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v7;
  int v8;
  uint64_t m;
  _QWORD *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t i;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t k;
  uint64_t v22;
  uint64_t v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  uint64_t v36;
  _QWORD *v37;
  uint64_t j;
  uint64_t v39;
  uint64_t v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  uint64_t v47;
  _QWORD *v48;

  v7 = (a3 + 1);
  v8 = 60 - 4 * a3;
  if (v8 <= 12)
  {
    for (i = 0; i != 128; i += 8)
    {
      v18 = *(_QWORD *)(a2 + i);
      if (v18)
      {
        if ((v18 & 1) != 0)
        {
          v19 = *(_QWORD *)(a4 + 8);
          if (v19 == 63 || (v20 = *(_QWORD **)a4) == 0)
          {
            v20 = CFAllocatorAllocate(*(CFAllocatorRef *)(a4 + 16), 8072, 0);
            *v20 = *(_QWORD *)a4;
            bzero(v20 + 1, 0x1F80uLL);
            v19 = 0;
            *(_QWORD *)a4 = v20;
          }
          *(_QWORD *)(a4 + 8) = v19 + 1;
          v17 = (_QWORD *)(SIValueSet<unsigned long long>::CombLevel_s::CombLevel_s(&v20[16 * v19 + 1], v18 & 0xFFFFFFFFFFFFFFFELL, v7, a4) | 1);
        }
        else
        {
          v17 = CFAllocatorAllocate(*(CFAllocatorRef *)(a4 + 16), 520, 0);
          *v17 = off_1E6E2A608;
          memcpy(v17 + 1, (const void *)((v18 & 0xFFFFFFFFFFFFFFFELL) + 8), 0x200uLL);
        }
      }
      else
      {
        v17 = 0;
      }
      *(_QWORD *)(a1 + i) = v17;
    }
  }
  else if (v8 < 0x20)
  {
    if (v8 <= 0xF)
    {
      for (j = 0; j != 128; j += 8)
      {
        v40 = *(_QWORD *)(a2 + j);
        if (v40)
        {
          if ((v40 & 1) != 0)
          {
            v47 = *(_QWORD *)(a4 + 8);
            if (v47 == 63 || (v48 = *(_QWORD **)a4) == 0)
            {
              v48 = CFAllocatorAllocate(*(CFAllocatorRef *)(a4 + 16), 8072, 0);
              *v48 = *(_QWORD *)a4;
              bzero(v48 + 1, 0x1F80uLL);
              v47 = 0;
              *(_QWORD *)a4 = v48;
            }
            *(_QWORD *)(a4 + 8) = v47 + 1;
            v39 = SIValueSet<unsigned long long>::CombLevel_s::CombLevel_s(&v48[16 * v47 + 1], v40 & 0xFFFFFFFFFFFFFFFELL, v7, a4) | 1;
          }
          else
          {
            v39 = (uint64_t)CFAllocatorAllocate(*(CFAllocatorRef *)(a4 + 16), 136, 0);
            *(_QWORD *)v39 = off_1E6E2A780;
            *(_WORD *)(v39 + 8) = *(_WORD *)((v40 & 0xFFFFFFFFFFFFFFFELL) + 8);
            v41 = *(_OWORD *)((v40 & 0xFFFFFFFFFFFFFFFELL) + 26);
            v42 = *(_OWORD *)((v40 & 0xFFFFFFFFFFFFFFFELL) + 42);
            v43 = *(_OWORD *)((v40 & 0xFFFFFFFFFFFFFFFELL) + 58);
            *(_OWORD *)(v39 + 10) = *(_OWORD *)((v40 & 0xFFFFFFFFFFFFFFFELL) + 10);
            *(_OWORD *)(v39 + 58) = v43;
            *(_OWORD *)(v39 + 42) = v42;
            *(_OWORD *)(v39 + 26) = v41;
            v44 = *(_OWORD *)((v40 & 0xFFFFFFFFFFFFFFFELL) + 90);
            v45 = *(_OWORD *)((v40 & 0xFFFFFFFFFFFFFFFELL) + 106);
            v46 = *(_OWORD *)((v40 & 0xFFFFFFFFFFFFFFFELL) + 120);
            *(_OWORD *)(v39 + 74) = *(_OWORD *)((v40 & 0xFFFFFFFFFFFFFFFELL) + 74);
            *(_OWORD *)(v39 + 120) = v46;
            *(_OWORD *)(v39 + 106) = v45;
            *(_OWORD *)(v39 + 90) = v44;
          }
        }
        else
        {
          v39 = 0;
        }
        *(_QWORD *)(a1 + j) = v39;
      }
    }
    else
    {
      for (k = 0; k != 128; k += 8)
      {
        v23 = *(_QWORD *)(a2 + k);
        if (v23)
        {
          if ((v23 & 1) != 0)
          {
            v36 = *(_QWORD *)(a4 + 8);
            if (v36 == 63 || (v37 = *(_QWORD **)a4) == 0)
            {
              v37 = CFAllocatorAllocate(*(CFAllocatorRef *)(a4 + 16), 8072, 0);
              *v37 = *(_QWORD *)a4;
              bzero(v37 + 1, 0x1F80uLL);
              v36 = 0;
              *(_QWORD *)a4 = v37;
            }
            *(_QWORD *)(a4 + 8) = v36 + 1;
            v22 = SIValueSet<unsigned long long>::CombLevel_s::CombLevel_s(&v37[16 * v36 + 1], v23 & 0xFFFFFFFFFFFFFFFELL, v7, a4) | 1;
          }
          else
          {
            v22 = (uint64_t)CFAllocatorAllocate(*(CFAllocatorRef *)(a4 + 16), 264, 0);
            *(_QWORD *)v22 = off_1E6E2A6E0;
            *(_DWORD *)(v22 + 8) = *(_DWORD *)((v23 & 0xFFFFFFFFFFFFFFFELL) + 8);
            v24 = *(_OWORD *)((v23 & 0xFFFFFFFFFFFFFFFELL) + 28);
            v25 = *(_OWORD *)((v23 & 0xFFFFFFFFFFFFFFFELL) + 44);
            v26 = *(_OWORD *)((v23 & 0xFFFFFFFFFFFFFFFELL) + 60);
            *(_OWORD *)(v22 + 12) = *(_OWORD *)((v23 & 0xFFFFFFFFFFFFFFFELL) + 12);
            *(_OWORD *)(v22 + 60) = v26;
            *(_OWORD *)(v22 + 44) = v25;
            *(_OWORD *)(v22 + 28) = v24;
            v27 = *(_OWORD *)((v23 & 0xFFFFFFFFFFFFFFFELL) + 92);
            v28 = *(_OWORD *)((v23 & 0xFFFFFFFFFFFFFFFELL) + 108);
            v29 = *(_OWORD *)((v23 & 0xFFFFFFFFFFFFFFFELL) + 124);
            *(_OWORD *)(v22 + 76) = *(_OWORD *)((v23 & 0xFFFFFFFFFFFFFFFELL) + 76);
            *(_OWORD *)(v22 + 124) = v29;
            *(_OWORD *)(v22 + 108) = v28;
            *(_OWORD *)(v22 + 92) = v27;
            v30 = *(_OWORD *)((v23 & 0xFFFFFFFFFFFFFFFELL) + 156);
            v31 = *(_OWORD *)((v23 & 0xFFFFFFFFFFFFFFFELL) + 172);
            v32 = *(_OWORD *)((v23 & 0xFFFFFFFFFFFFFFFELL) + 188);
            *(_OWORD *)(v22 + 140) = *(_OWORD *)((v23 & 0xFFFFFFFFFFFFFFFELL) + 140);
            *(_OWORD *)(v22 + 188) = v32;
            *(_OWORD *)(v22 + 172) = v31;
            *(_OWORD *)(v22 + 156) = v30;
            v33 = *(_OWORD *)((v23 & 0xFFFFFFFFFFFFFFFELL) + 220);
            v34 = *(_OWORD *)((v23 & 0xFFFFFFFFFFFFFFFELL) + 236);
            v35 = *(_OWORD *)((v23 & 0xFFFFFFFFFFFFFFFELL) + 248);
            *(_OWORD *)(v22 + 204) = *(_OWORD *)((v23 & 0xFFFFFFFFFFFFFFFELL) + 204);
            *(_OWORD *)(v22 + 248) = v35;
            *(_OWORD *)(v22 + 236) = v34;
            *(_OWORD *)(v22 + 220) = v33;
          }
        }
        else
        {
          v22 = 0;
        }
        *(_QWORD *)(a1 + k) = v22;
      }
    }
  }
  else
  {
    for (m = 0; m != 128; m += 8)
    {
      v11 = *(_QWORD *)(a2 + m);
      if (v11)
      {
        if ((v11 & 1) != 0)
        {
          v14 = *(_QWORD *)(a4 + 8);
          if (v14 == 63 || (v15 = *(_QWORD **)a4) == 0)
          {
            v15 = CFAllocatorAllocate(*(CFAllocatorRef *)(a4 + 16), 8072, 0);
            *v15 = *(_QWORD *)a4;
            bzero(v15 + 1, 0x1F80uLL);
            v14 = 0;
            *(_QWORD *)a4 = v15;
          }
          *(_QWORD *)(a4 + 8) = v14 + 1;
          v10 = (_QWORD *)(SIValueSet<unsigned long long>::CombLevel_s::CombLevel_s(&v15[16 * v14 + 1], v11 & 0xFFFFFFFFFFFFFFFELL, v7, a4) | 1);
        }
        else
        {
          v12 = v11 & 0xFFFFFFFFFFFFFFFELL;
          v10 = CFAllocatorAllocate(*(CFAllocatorRef *)(a4 + 16), 520, 0);
          v13 = *(_QWORD *)(v12 + 8);
          *v10 = off_1E6E2A820;
          v10[1] = v13;
          memcpy(v10 + 2, (const void *)(v12 + 16), 0x1F8uLL);
        }
      }
      else
      {
        v10 = 0;
      }
      *(_QWORD *)(a1 + m) = v10;
    }
  }
  return a1;
}

uint64_t RLEOIDArraySerialize(uint64_t a1, uint64_t a2, uint64_t *a3, off_t *a4)
{
  pthread_rwlock_t *v8;
  off_t v9;
  uint64_t v10;
  int v11;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  void *v16[2];
  _QWORD v17[2];

  v8 = (pthread_rwlock_t *)(a1 + 16);
  pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 16));
  if (a4)
    v9 = *a4;
  else
    v9 = 0;
  v15 = 0u;
  *(_OWORD *)v16 = 0u;
  v13 = 0u;
  v14 = 0u;
  if (a3)
    v10 = *a3;
  else
    v10 = 0;
  if (store_stream_init_fd((uint64_t)&v13, a2, v10, v9, 1))
  {
    v17[0] = off_1E6E2A8C8;
    v17[1] = &v13;
    SIValueSet<unsigned long long>::StoreStreamCtx::write_vint32((uint64_t)v17, *(unsigned __int8 *)(a1 + 384));
    SIValueSet<unsigned long long>::StoreStreamCtx::write_vint32((uint64_t)v17, *(_DWORD *)(a1 + 224));
    if (*(_DWORD *)(a1 + 224))
    {
      (*(void (**)(_QWORD *, _QWORD))v17[0])(v17, *(_QWORD *)(a1 + 216));
      v11 = *(_DWORD *)(a1 + 224);
    }
    else
    {
      v11 = 0;
    }
    SIValueSet<unsigned long long>::_SIValueSetInnerSerialize(a1 + 256, *(_QWORD *)(a1 + 216), v11, (uint64_t)v17);
    (*(void (**)(_QWORD *, _QWORD))v17[0])(v17, 0);
    store_stream_flush((unsigned int *)&v13, 0);
    if (a4)
      *a4 = *((_QWORD *)&v14 + 1);
    if (v16[0])
    {
      free(v16[0]);
      v16[0] = 0;
      *(_QWORD *)&v15 = 0;
      if ((_DWORD)v13 != -1 && v16[1])
      {
        _fd_release_fd((_DWORD *)v16[1], v13, 0, *((uint64_t *)&v13 + 1));
        LODWORD(v13) = -1;
      }
      v16[1] = 0;
    }
  }
  return pthread_rwlock_unlock(v8);
}

uint64_t SIValueSet<unsigned long long>::StoreStreamCtx::write_vint32(uint64_t result, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  size_t v4;
  uint64_t v5;
  _BYTE *v6;
  size_t v7;
  _BYTE *v8;
  uint64_t v9;
  size_t v10;
  _OWORD *v11;
  size_t v12;
  _OWORD *v13;
  _OWORD __src[2];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(result + 8);
  v4 = *(_QWORD *)(v2 + 32);
  v3 = *(_QWORD *)(v2 + 40);
  if (v4 - v3 >= 6)
  {
    v5 = *(_QWORD *)(v2 + 48);
    if (a2 <= 0x7F)
    {
      *(_BYTE *)(v5 + v3) = a2;
      *(_QWORD *)(v2 + 40) = v3 + 1;
      return result;
    }
    if (a2 >> 14)
    {
      if (a2 >> 21)
      {
        v9 = v5 + v3;
        if (a2 >> 28)
        {
          *(_BYTE *)v9 = -16;
          *(_DWORD *)(v9 + 1) = a2;
          v7 = v3 + 5;
        }
        else
        {
          *(_BYTE *)v9 = HIBYTE(a2) | 0xE0;
          *(_BYTE *)(v9 + 1) = BYTE2(a2);
          *(_BYTE *)(v9 + 2) = BYTE1(a2);
          v7 = v3 + 4;
          *(_BYTE *)(v9 + 3) = a2;
        }
      }
      else
      {
        v8 = (_BYTE *)(v5 + v3);
        *v8 = BYTE2(a2) | 0xC0;
        v8[1] = BYTE1(a2);
        v7 = v3 + 3;
        v8[2] = a2;
      }
    }
    else
    {
      v6 = (_BYTE *)(v5 + v3);
      *v6 = BYTE1(a2) | 0x80;
      v7 = v3 + 2;
      v6[1] = a2;
    }
    goto LABEL_11;
  }
  memset(__src, 0, sizeof(__src));
  if (a2 > 0x7F)
  {
    if (a2 >> 14)
    {
      if (a2 >> 21)
      {
        if (a2 >> 28)
        {
          LOBYTE(__src[0]) = -16;
          *(_DWORD *)((char *)__src + 1) = a2;
          v10 = 5;
        }
        else
        {
          LOBYTE(__src[0]) = HIBYTE(a2) | 0xE0;
          BYTE1(__src[0]) = BYTE2(a2);
          BYTE2(__src[0]) = BYTE1(a2);
          BYTE3(__src[0]) = a2;
          v10 = 4;
        }
      }
      else
      {
        LOBYTE(__src[0]) = BYTE2(a2) | 0xC0;
        BYTE1(__src[0]) = BYTE1(a2);
        BYTE2(__src[0]) = a2;
        v10 = 3;
      }
    }
    else
    {
      LOBYTE(__src[0]) = BYTE1(a2) | 0x80;
      BYTE1(__src[0]) = a2;
      v10 = 2;
    }
  }
  else
  {
    LOBYTE(__src[0]) = a2;
    v10 = 1;
  }
  v11 = __src;
  if (v10 + v3 < v4)
  {
LABEL_23:
    result = (uint64_t)memcpy((void *)(*(_QWORD *)(v2 + 48) + v3), v11, v10);
    v7 = *(_QWORD *)(v2 + 40) + v10;
LABEL_11:
    *(_QWORD *)(v2 + 40) = v7;
    return result;
  }
  while (1)
  {
    v12 = v4 - v3;
    v13 = v11;
    memcpy((void *)(*(_QWORD *)(v2 + 48) + v3), v11, v4 - v3);
    *(_QWORD *)(v2 + 40) += v12;
    result = store_stream_flush((unsigned int *)v2, 0);
    if ((_DWORD)result)
      return result;
    v11 = (_OWORD *)((char *)v13 + v12);
    v10 -= v12;
    v4 = *(_QWORD *)(v2 + 32);
    v3 = *(_QWORD *)(v2 + 40);
    if (v3 + v10 < v4)
      goto LABEL_23;
  }
}

uint64_t SIValueSet<unsigned long long>::_SIValueSetInnerSerialize(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  char v9;
  uint64_t v10;

  v7 = 0;
  v8 = (a3 + 1);
  v9 = (64 - 4 * (a3 + 1)) & 0xFC;
  do
  {
    v10 = *(_QWORD *)(a1 + 8 * v7);
    if (v10)
    {
      if ((v10 & 1) != 0)
      {
        SIValueSet<unsigned long long>::_SIValueSetInnerSerialize(v10 & 0xFFFFFFFFFFFFFFFELL, (v7 << v9) | a2, v8, a4);
      }
      else
      {
        (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a4 + 8))(a4, v8);
        (**(void (***)(uint64_t, uint64_t))a4)(a4, (v7 << v9) | a2);
        (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v10 + 64))(v10, a4);
      }
    }
    ++v7;
  }
  while (v7 != 16);
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a4 + 8))(a4, 0);
}

uint64_t SIValueSet<unsigned long long>::StoreStreamCtx::write_vint(uint64_t a1, unint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  size_t v5;
  uint64_t result;
  size_t v7;
  _OWORD *v8;
  size_t v9;
  _OWORD *v10;
  _OWORD __src[2];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(a1 + 8);
  v5 = *(_QWORD *)(v3 + 32);
  v4 = *(_QWORD *)(v3 + 40);
  if (v5 - v4 < 0xA)
  {
    memset(__src, 0, sizeof(__src));
    if (a2 > 0x7F)
    {
      if (a2 >> 14)
      {
        if (a2 >> 21)
        {
          if (a2 >> 28)
          {
            if (a2 >> 35)
            {
              if (a2 >> 42)
              {
                if (a2 >> 49)
                {
                  if (HIBYTE(a2))
                  {
                    LOBYTE(__src[0]) = -1;
                    *(_QWORD *)((char *)__src + 1) = a2;
                    v7 = 9;
                  }
                  else
                  {
                    LOBYTE(__src[0]) = -2;
                    BYTE1(__src[0]) = BYTE6(a2);
                    BYTE2(__src[0]) = BYTE5(a2);
                    BYTE3(__src[0]) = BYTE4(a2);
                    BYTE4(__src[0]) = BYTE3(a2);
                    BYTE5(__src[0]) = BYTE2(a2);
                    BYTE6(__src[0]) = BYTE1(a2);
                    v7 = 8;
                    BYTE7(__src[0]) = a2;
                  }
                }
                else
                {
                  LOBYTE(__src[0]) = BYTE6(a2) | 0xFC;
                  BYTE1(__src[0]) = BYTE5(a2);
                  BYTE2(__src[0]) = BYTE4(a2);
                  BYTE3(__src[0]) = BYTE3(a2);
                  BYTE4(__src[0]) = BYTE2(a2);
                  BYTE5(__src[0]) = BYTE1(a2);
                  v7 = 7;
                  BYTE6(__src[0]) = a2;
                }
              }
              else
              {
                LOBYTE(__src[0]) = BYTE5(a2) | 0xF8;
                BYTE1(__src[0]) = BYTE4(a2);
                BYTE2(__src[0]) = BYTE3(a2);
                BYTE3(__src[0]) = BYTE2(a2);
                BYTE4(__src[0]) = BYTE1(a2);
                BYTE5(__src[0]) = a2;
                v7 = 6;
              }
            }
            else
            {
              LOBYTE(__src[0]) = BYTE4(a2) | 0xF0;
              BYTE1(__src[0]) = BYTE3(a2);
              BYTE2(__src[0]) = BYTE2(a2);
              BYTE3(__src[0]) = BYTE1(a2);
              BYTE4(__src[0]) = a2;
              v7 = 5;
            }
          }
          else
          {
            LOBYTE(__src[0]) = BYTE3(a2) | 0xE0;
            BYTE1(__src[0]) = BYTE2(a2);
            BYTE2(__src[0]) = BYTE1(a2);
            BYTE3(__src[0]) = a2;
            v7 = 4;
          }
        }
        else
        {
          LOBYTE(__src[0]) = BYTE2(a2) | 0xC0;
          BYTE1(__src[0]) = BYTE1(a2);
          BYTE2(__src[0]) = a2;
          v7 = 3;
        }
      }
      else
      {
        LOBYTE(__src[0]) = BYTE1(a2) | 0x80;
        BYTE1(__src[0]) = a2;
        v7 = 2;
      }
    }
    else
    {
      LOBYTE(__src[0]) = a2;
      v7 = 1;
    }
    if (v7 + v4 >= v5)
    {
      v8 = __src;
      while (1)
      {
        v9 = v5 - v4;
        v10 = v8;
        memcpy((void *)(*(_QWORD *)(v3 + 48) + v4), v8, v5 - v4);
        *(_QWORD *)(v3 + 40) += v9;
        result = store_stream_flush((unsigned int *)v3, 0);
        if ((_DWORD)result)
          break;
        v8 = (_OWORD *)((char *)v10 + v9);
        v7 -= v9;
        v5 = *(_QWORD *)(v3 + 32);
        v4 = *(_QWORD *)(v3 + 40);
        if (v4 + v7 < v5)
          goto LABEL_23;
      }
    }
    else
    {
      v8 = __src;
LABEL_23:
      result = (uint64_t)memcpy((void *)(*(_QWORD *)(v3 + 48) + v4), v8, v7);
      *(_QWORD *)(v3 + 40) += v7;
    }
  }
  else
  {
    result = v2_writeVInt64(*(_QWORD *)(v3 + 48), v4, a2);
    *(_QWORD *)(v3 + 40) = result;
  }
  return result;
}

uint64_t SIValueSet<unsigned long long>::StoreStreamCtx::write_bytes(uint64_t a1, char *__src, size_t __n)
{
  size_t v3;
  uint64_t v5;
  uint64_t v6;
  size_t v7;
  uint64_t result;
  size_t v9;

  v3 = __n;
  v5 = *(_QWORD *)(a1 + 8);
  v7 = *(_QWORD *)(v5 + 32);
  v6 = *(_QWORD *)(v5 + 40);
  if (v6 + __n >= v7)
  {
    while (1)
    {
      v9 = v7 - v6;
      memcpy((void *)(*(_QWORD *)(v5 + 48) + v6), __src, v7 - v6);
      *(_QWORD *)(v5 + 40) += v9;
      result = store_stream_flush((unsigned int *)v5, 0);
      if ((_DWORD)result)
        break;
      __src += v9;
      v3 -= v9;
      v7 = *(_QWORD *)(v5 + 32);
      v6 = *(_QWORD *)(v5 + 40);
      if (v6 + v3 < v7)
        goto LABEL_2;
    }
  }
  else
  {
LABEL_2:
    result = (uint64_t)memcpy((void *)(*(_QWORD *)(v5 + 48) + v6), __src, v3);
    *(_QWORD *)(v5 + 40) += v3;
  }
  return result;
}

void SIValueSet<unsigned long long>::StoreStreamCtx::~StoreStreamCtx()
{
  JUMPOUT(0x1BCCB06A4);
}

const void *RLEOIDArrayDeserialize(const __CFAllocator *a1, uint64_t a2, off_t *a3)
{
  int v4;
  off_t v6;
  const void *Instance;
  int v8;
  stat v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  int v15;

  v4 = a2;
  if (a3)
    v6 = *a3;
  else
    v6 = 0;
  v13 = 0u;
  v14 = 0u;
  v11 = 0u;
  v12 = 0u;
  Instance = 0;
  if (store_stream_init_fd((uint64_t)&v11, a2, 0, v6, 0))
  {
    if (!__kRLEOIDArrayTypeID)
      __kRLEOIDArrayTypeID = _CFRuntimeRegisterClass();
    Instance = (const void *)_CFRuntimeCreateInstance();
    *(_QWORD *)&v10.st_dev = off_1E6E2A890;
    v10.st_ino = (__darwin_ino64_t)&v11;
    v15 = 0;
    SIValueSet<unsigned long long>::SIValueSet((uint64_t)Instance + 216, (uint64_t)&v10, a1, &v15);
    if (v15)
    {
      CFRelease(Instance);
      memset(&v10, 0, sizeof(v10));
      v8 = fstat(v4, &v10);
      if (a3 && !v8)
        *a3 = v10.st_size;
      Instance = 0;
    }
    else if (a3)
    {
      *a3 = *((_QWORD *)&v12 + 1) - v13 + *((_QWORD *)&v13 + 1);
    }
    if ((_QWORD)v14)
    {
      free((void *)v14);
      *(_QWORD *)&v14 = 0;
      *(_QWORD *)&v13 = 0;
      if ((_DWORD)v11 != -1)
      {
        if (*((_QWORD *)&v14 + 1))
          _fd_release_fd(*((_DWORD **)&v14 + 1), v11, 0, *((uint64_t *)&v11 + 1));
      }
    }
  }
  return Instance;
}

uint64_t SIValueSet<unsigned long long>::SIValueSet(uint64_t a1, uint64_t a2, CFAllocatorRef allocator, int *a4)
{
  void *v7;
  _QWORD **v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  int v12;
  NSObject *v13;
  const char *v14;
  int v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  int v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  _QWORD *v24;
  uint32_t v25;
  int v26;
  uint8_t buf[4];
  int v30;
  __int16 v31;
  int v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = allocator;
  v7 = CFAllocatorAllocate(allocator, 8072, 0);
  bzero(v7, 0x1F88uLL);
  *(_QWORD *)(a1 + 16) = v7;
  v8 = (_QWORD **)(a1 + 16);
  *(_OWORD *)(a1 + 40) = 0u;
  v9 = a1 + 40;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_BYTE *)(a1 + 168) = (**(unsigned int (***)(uint64_t))a2)(a2) != 0;
  v10 = (**(uint64_t (***)(uint64_t))a2)(a2);
  *(_DWORD *)(a1 + 8) = v10;
  if (v10)
  {
    v11 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 8))(a2);
    v12 = *(_DWORD *)(a1 + 8);
    *(_QWORD *)a1 = v11;
    if ((4 * v12 - 61) < 0xFFFFFFBF)
    {
      if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        goto LABEL_24;
      *(_DWORD *)buf = 67109120;
      v30 = v12;
      v13 = MEMORY[0x1E0C81028];
      v14 = "Read depth %d in serialized value set";
      goto LABEL_22;
    }
  }
  else
  {
    *(_QWORD *)a1 = 0;
  }
  v15 = (**(uint64_t (***)(uint64_t))a2)(a2);
  if (v15)
  {
    while (1)
    {
      *(_BYTE *)(a1 + 168) = 0;
      v17 = (v15 - 1);
      if (v15 >= 16)
        break;
      v18 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 8))(a2);
      v19 = *(_DWORD *)(a1 + 8);
      v20 = v18 >> (60 - 4 * v19);
      v21 = v20 & 0xF;
      if (*(_QWORD *)(v9 + 8 * v21))
      {
        if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67109376;
          v30 = v17;
          v31 = 1024;
          v32 = v20 & 0xF;
          _os_log_error_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Read duplicate child entry at %d(%d) in serialized value set", buf, 0xEu);
        }
        v26 = 12;
        goto LABEL_25;
      }
      if ((int)v17 <= v19)
      {
        v16 = (unint64_t)SIValueSet<unsigned long long>::HolderFromStream(a2, allocator, a4);
      }
      else
      {
        v22 = v18;
        v23 = *(_QWORD *)(a1 + 24);
        if (v23 == 63 || (v24 = *v8) == 0)
        {
          v24 = CFAllocatorAllocate(*(CFAllocatorRef *)(a1 + 32), 8072, 0);
          *v24 = *(_QWORD *)(a1 + 16);
          bzero(v24 + 1, 0x1F80uLL);
          v23 = 0;
          *(_QWORD *)(a1 + 16) = v24;
          v19 = *(_DWORD *)(a1 + 8);
        }
        *(_QWORD *)(a1 + 24) = v23 + 1;
        v16 = (unint64_t)SIValueSet<unsigned long long>::CombLevel_s::CombLevel_s(&v24[16 * v23 + 1], a2, v19 + 1, v22, v17, a1 + 16, a4) | 1;
      }
      *(_QWORD *)(v9 + 8 * v21) = v16;
      v15 = (**(uint64_t (***)(uint64_t))a2)(a2);
      if (!v15)
        goto LABEL_17;
    }
    if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      goto LABEL_24;
    *(_DWORD *)buf = 67109120;
    v30 = v17;
    v13 = MEMORY[0x1E0C81028];
    v14 = "Read depth %d in serialized value set";
LABEL_22:
    v25 = 8;
    goto LABEL_23;
  }
LABEL_17:
  if (!(*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 8))(a2))
    return a1;
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    v13 = MEMORY[0x1E0C81028];
    v14 = "missing end marker";
    v25 = 2;
LABEL_23:
    _os_log_error_impl(&dword_1B8270000, v13, OS_LOG_TYPE_ERROR, v14, buf, v25);
  }
LABEL_24:
  v26 = 13;
LABEL_25:
  *a4 = v26;
  return a1;
}

_OWORD *SIValueSet<unsigned long long>::CombLevel_s::CombLevel_s(_OWORD *a1, uint64_t a2, int a3, unint64_t a4, uint64_t a5, uint64_t a6, int *a7)
{
  uint64_t v13;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  char v18;
  int v19;
  int v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  int v27;
  unsigned int v29;
  uint8_t buf[4];
  int v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  v13 = (a3 + 1);
  if ((int)a5 <= a3)
  {
    if ((_DWORD)a5 != a3)
    {
LABEL_22:
      v27 = 13;
LABEL_23:
      *a7 = v27;
      return a1;
    }
    v17 = (uint64_t)SIValueSet<unsigned long long>::HolderFromStream(a2, *(const __CFAllocator **)(a6 + 16), a7);
  }
  else
  {
    v15 = *(_QWORD *)(a6 + 8);
    if (v15 == 63 || (v16 = *(_QWORD **)a6) == 0)
    {
      v16 = CFAllocatorAllocate(*(CFAllocatorRef *)(a6 + 16), 8072, 0);
      *v16 = *(_QWORD *)a6;
      bzero(v16 + 1, 0x1F80uLL);
      v15 = 0;
      *(_QWORD *)a6 = v16;
    }
    *(_QWORD *)(a6 + 8) = v15 + 1;
    v17 = SIValueSet<unsigned long long>::CombLevel_s::CombLevel_s(&v16[16 * v15 + 1], a2, v13, a4, a5, a6, a7) | 1;
  }
  v29 = v13;
  v18 = (64 - 4 * v13) & 0xFC;
  *((_QWORD *)a1 + ((a4 >> v18) & 0xF)) = v17;
  if (!*a7)
  {
    while (1)
    {
      v19 = (**(uint64_t (***)(uint64_t))a2)(a2);
      if (!v19)
        break;
      v20 = v19;
      if (v19 >= 16)
      {
        if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67109120;
          v31 = a3;
          _os_log_error_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Read depth %d in serialized value set", buf, 8u);
        }
        goto LABEL_22;
      }
      v21 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 8))(a2);
      v22 = (v21 >> v18) & 0xF;
      if (*((_QWORD *)a1 + v22))
      {
        v27 = 12;
        goto LABEL_23;
      }
      v23 = (v20 - 1);
      if ((int)v23 <= a3)
      {
        *((_QWORD *)a1 + v22) = SIValueSet<unsigned long long>::HolderFromStream(a2, *(const __CFAllocator **)(a6 + 16), a7);
        if (*a7)
          return a1;
      }
      else
      {
        v24 = v21;
        v25 = *(_QWORD *)(a6 + 8);
        if (v25 == 63 || (v26 = *(_QWORD **)a6) == 0)
        {
          v26 = CFAllocatorAllocate(*(CFAllocatorRef *)(a6 + 16), 8072, 0);
          *v26 = *(_QWORD *)a6;
          bzero(v26 + 1, 0x1F80uLL);
          v25 = 0;
          *(_QWORD *)a6 = v26;
        }
        *(_QWORD *)(a6 + 8) = v25 + 1;
        *((_QWORD *)a1 + v22) = SIValueSet<unsigned long long>::CombLevel_s::CombLevel_s(&v26[16 * v25 + 1], a2, v29, v24, v23, a6, a7) | 1;
        if (*a7)
          return a1;
      }
    }
  }
  return a1;
}

_WORD *SIValueSet<unsigned long long>::HolderFromStream(uint64_t a1, const __CFAllocator *a2, _DWORD *a3)
{
  _WORD *v6;
  unsigned __int16 v7;
  unsigned int v8;
  unsigned int v9;

  switch((**(unsigned int (***)(uint64_t))a1)(a1))
  {
    case 0u:
      v6 = CFAllocatorAllocate(a2, 520, 0);
      *(_QWORD *)v6 = off_1E6E2A608;
      if ((*(uint64_t (**)(uint64_t, _WORD *, uint64_t))(*(_QWORD *)a1 + 16))(a1, v6 + 4, 512) != 512)
        goto LABEL_18;
      goto LABEL_3;
    case 2u:
      v6 = CFAllocatorAllocate(a2, 136, 0);
      *(_QWORD *)v6 = off_1E6E2A780;
      v7 = (**(uint64_t (***)(uint64_t))a1)(a1);
      v6[4] = v7;
      if ((v7 & 0xFFC0) != 0)
      {
        *a3 = 1;
        v6[4] = 0;
        goto LABEL_19;
      }
      if ((*(uint64_t (**)(uint64_t, _WORD *, _QWORD))(*(_QWORD *)a1 + 16))(a1, v6 + 5, 2 * v7) != 2 * (unsigned __int16)v6[4])goto LABEL_18;
      goto LABEL_3;
    case 4u:
      v6 = CFAllocatorAllocate(a2, 264, 0);
      *(_QWORD *)v6 = off_1E6E2A6E0;
      v8 = (**(uint64_t (***)(uint64_t))a1)(a1);
      *((_DWORD *)v6 + 2) = v8;
      if (v8 >= 0x40)
      {
        *a3 = 1;
        *((_DWORD *)v6 + 2) = 0;
        if (*a3)
          goto LABEL_19;
        return v6;
      }
      if ((*(uint64_t (**)(uint64_t, _WORD *, uint64_t))(*(_QWORD *)a1 + 16))(a1, v6 + 6, 4 * v8) == 4 * *((unsigned int *)v6 + 2))
        goto LABEL_3;
      goto LABEL_18;
    case 8u:
      v6 = CFAllocatorAllocate(a2, 520, 0);
      *(_QWORD *)v6 = off_1E6E2A820;
      v9 = (**(uint64_t (***)(uint64_t))a1)(a1);
      *((_QWORD *)v6 + 1) = v9;
      if (v9 < 0x40)
      {
        if ((*(uint64_t (**)(uint64_t, _WORD *, uint64_t))(*(_QWORD *)a1 + 16))(a1, v6 + 8, 8 * v9) == 8 * *((_QWORD *)v6 + 1))
        {
LABEL_3:
          if (!*a3)
            return v6;
        }
        else
        {
LABEL_18:
          *a3 = 1;
        }
      }
      else
      {
        *a3 = 1;
        *((_QWORD *)v6 + 1) = 0;
      }
LABEL_19:
      (*(void (**)(_WORD *))(*(_QWORD *)v6 + 80))(v6);
      return 0;
    default:
      v6 = 0;
      *a3 = 14;
      return v6;
  }
}

uint64_t SIValueSet<unsigned long long>::ReadStreamCtx::read_vint32(uint64_t a1)
{
  off_t *v1;
  size_t v2;
  off_t v3;
  size_t v4;
  size_t v5;
  off_t v6;
  uint64_t result;
  uint64_t v8;
  char *p_dst;
  size_t v10;
  size_t v11;
  size_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  size_t v16;
  off_t v17;
  off_t *v18;
  size_t v19;
  size_t v20;
  void *v21;
  size_t v22;
  size_t v23;
  off_t *v24;
  char *v25;
  ssize_t v26;
  size_t v27;
  off_t v28;
  char *v29;
  unint64_t v30;
  size_t v31;
  off_t v32;
  off_t *v33;
  void *v34;
  ssize_t v35;
  unint64_t v36;
  void *v37;
  unint64_t v38;
  char *v39;
  size_t v40;
  uint64_t __dst;
  __int16 v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  v1 = *(off_t **)(a1 + 8);
  v2 = v1[4];
  v3 = v1[5];
  v4 = v2 - v3;
  v5 = v3 + 1;
  if (v2 - v3 >= 6)
  {
    v6 = v1[6];
    result = *(unsigned __int8 *)(v6 + v3);
    if (*(char *)(v6 + v3) < 0)
    {
      if (result > 0xBF)
      {
        if (result > 0xDF)
        {
          if (result > 0xEF)
          {
            result = *(unsigned int *)(v6 + v5);
            v5 = v3 + 5;
          }
          else
          {
            result = ((result & 0xF) << 24) | (*(unsigned __int8 *)(v6 + v5) << 16) | (*(unsigned __int8 *)(v3 + v6 + 2) << 8) | *(unsigned __int8 *)(v3 + v6 + 3);
            v5 = v3 + 4;
          }
        }
        else
        {
          result = ((result & 0x1F) << 16) | (*(unsigned __int8 *)(v6 + v5) << 8) | *(unsigned __int8 *)(v3 + v6 + 2);
          v5 = v3 + 3;
        }
      }
      else
      {
        v8 = *(unsigned __int8 *)(v6 + v5) | ((result & 0x3F) << 8);
        v5 = v3 + 2;
        result = v8;
      }
    }
    v1[5] = v5;
    return result;
  }
  v42 = 0;
  __dst = 0;
  if (v5 <= v2)
  {
    v4 = 0;
    p_dst = (char *)&__dst;
    v10 = 1;
LABEL_14:
    memcpy(p_dst, (const void *)(v1[6] + v3), v10);
    v1[5] = v3 + v10;
    v11 = v4;
    v4 = v10;
    goto LABEL_15;
  }
  v24 = v1;
  v25 = (char *)v1[6];
  if (v4)
  {
    memcpy(&__dst, &v25[v3], v2 - v3);
    v1[5] = v2;
  }
  v26 = prot_pread(*(unsigned int *)v1, v25, v2, v1[3]);
  if (v26 == -1)
  {
    v4 = 0;
LABEL_43:
    v1 = v24;
    *((_DWORD *)v24 + 4) = *__error();
    v11 = v4;
    v4 = 0;
    goto LABEL_15;
  }
  v27 = v26;
  v1[4] = v26;
  v1[5] = 0;
  v28 = v1[3] + v26;
  v1[3] = v28;
  if (v26)
  {
    p_dst = (char *)&__dst + v4;
    v10 = 1 - v4;
    if (1 - v4 <= v27)
    {
      v3 = 0;
      goto LABEL_14;
    }
    while (1)
    {
      v33 = v1;
      v34 = (void *)v1[6];
      v39 = p_dst;
      memcpy(p_dst, v34, v27);
      v33[5] = v27;
      v35 = prot_pread(*(unsigned int *)v33, v34, v27, v28);
      if (v35 == -1)
        goto LABEL_43;
      v36 = v35;
      v24[4] = v35;
      v24[5] = 0;
      v28 = v24[3] + v35;
      v24[3] = v28;
      if (!v35)
      {
        v11 = v4;
        v4 = v27;
        goto LABEL_45;
      }
      v3 = 0;
      p_dst = &v39[v27];
      v10 -= v27;
      v4 += v27;
      v27 = v36;
      v1 = v24;
      if (v10 <= v36)
        goto LABEL_14;
    }
  }
  v11 = 0;
LABEL_45:
  v1 = v24;
LABEL_15:
  if (v4 + v11 != 1)
    return 0;
  result = __dst;
  if (((char)__dst & 0x80000000) == 0)
    return result;
  v12 = 1;
  v13 = 2;
  v14 = 3;
  if (__dst >= 0xF0u)
    v14 = 4;
  if (__dst >= 0xE0u)
    v13 = v14;
  if (__dst >= 0xC0u)
    v12 = v13;
  v15 = (char *)&__dst + 1;
  v16 = v1[4];
  v17 = v1[5];
  v18 = v1;
  if (v17 + v12 <= v16)
  {
    v19 = 0;
    v20 = v12;
LABEL_25:
    v21 = v15;
    v22 = v12;
    memcpy(v21, (const void *)(v18[6] + v17), v12);
    v18[5] = v17 + v22;
    v23 = v19;
    v19 = v22;
    goto LABEL_26;
  }
  v20 = v12;
  v29 = (char *)v18[6];
  v19 = v16 - v17;
  if (v16 != v17)
  {
    memcpy((char *)&__dst + 1, &v29[v17], v16 - v17);
    v18[5] = v16;
  }
  v30 = prot_pread(*(unsigned int *)v18, v29, v16, v18[3]);
  if (v30 == -1)
  {
    v19 = 0;
LABEL_53:
    *((_DWORD *)v18 + 4) = *__error();
    v23 = v19;
    v19 = 0;
    goto LABEL_26;
  }
  v31 = v30;
  v18[4] = v30;
  v18[5] = 0;
  v32 = v18[3] + v30;
  v18[3] = v32;
  if (v30)
  {
    v15 = (char *)&__dst + v19 + 1;
    v12 = v20 - v19;
    if (v20 - v19 <= v30)
    {
      v17 = 0;
      goto LABEL_25;
    }
    while (1)
    {
      v40 = v12;
      v37 = (void *)v18[6];
      memcpy(v15, v37, v31);
      v18[5] = v31;
      v38 = prot_pread(*(unsigned int *)v18, v37, v31, v32);
      if (v38 == -1)
        goto LABEL_53;
      v18[4] = v38;
      v18[5] = 0;
      v32 = v18[3] + v38;
      v18[3] = v32;
      if (!v38)
      {
        v23 = v19;
        v19 = v31;
        goto LABEL_26;
      }
      v17 = 0;
      v15 += v31;
      v12 = v40 - v31;
      v19 += v31;
      v31 = v38;
      if (v12 <= v38)
        goto LABEL_25;
    }
  }
  v23 = 0;
LABEL_26:
  if (v19 + v23 != v20)
    return 0;
  result = __dst;
  if ((char)__dst < 0)
  {
    if (__dst > 0xBFu)
    {
      if (__dst > 0xDFu)
      {
        if (__dst > 0xEFu)
          return *(unsigned int *)((char *)&__dst + 1);
        else
          return ((__dst & 0xF) << 24) | (BYTE1(__dst) << 16) | (BYTE2(__dst) << 8) | BYTE3(__dst);
      }
      else
      {
        return ((__dst & 0x1F) << 16) | (BYTE1(__dst) << 8) | BYTE2(__dst);
      }
    }
    else
    {
      return BYTE1(__dst) | ((__dst & 0x3F) << 8);
    }
  }
  return result;
}

unint64_t SIValueSet<unsigned long long>::ReadStreamCtx::read_vint(uint64_t a1)
{
  unsigned int *v1;
  size_t v2;
  uint64_t *v3;
  uint64_t v4;
  size_t v5;
  char *p_dst;
  size_t v8;
  size_t v9;
  uint64_t v10;
  char *v11;
  size_t v12;
  uint64_t v13;
  size_t v14;
  uint64_t v15;
  size_t v16;
  size_t v17;
  char *v18;
  ssize_t v19;
  size_t v20;
  off_t v21;
  char *v22;
  unint64_t v23;
  size_t v24;
  off_t v25;
  void *v26;
  char *v27;
  ssize_t v28;
  unint64_t v29;
  void *v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t __dst;
  __int16 v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v1 = *(unsigned int **)(a1 + 8);
  v2 = *((_QWORD *)v1 + 4);
  v3 = (uint64_t *)(v1 + 10);
  v4 = *((_QWORD *)v1 + 5);
  v5 = v2 - v4;
  if (v2 - v4 >= 0xA)
    return v2_readVInt64_1804(*((_QWORD *)v1 + 6), v3);
  v34 = 0;
  __dst = 0;
  if (v4 + 1 <= v2)
  {
    v5 = 0;
    p_dst = (char *)&__dst;
    v8 = 1;
LABEL_5:
    memcpy(p_dst, (const void *)(*((_QWORD *)v1 + 6) + v4), v8);
    *((_QWORD *)v1 + 5) = v4 + v8;
    v9 = v5;
    v5 = v8;
    goto LABEL_6;
  }
  v18 = (char *)*((_QWORD *)v1 + 6);
  if (v5)
  {
    memcpy(&__dst, &v18[v4], v5);
    *v3 = v2;
  }
  v19 = prot_pread(*v1, v18, v2, *((_QWORD *)v1 + 3));
  if (v19 == -1)
  {
    v5 = 0;
LABEL_36:
    v1[4] = *__error();
    v9 = v5;
    v5 = 0;
    goto LABEL_6;
  }
  v20 = v19;
  *((_QWORD *)v1 + 4) = v19;
  *((_QWORD *)v1 + 5) = 0;
  v21 = *((_QWORD *)v1 + 3) + v19;
  *((_QWORD *)v1 + 3) = v21;
  if (v19)
  {
    p_dst = (char *)&__dst + v5;
    v8 = 1 - v5;
    if (1 - v5 <= v20)
    {
      v4 = 0;
      goto LABEL_5;
    }
    while (1)
    {
      v26 = (void *)*((_QWORD *)v1 + 6);
      v27 = p_dst;
      memcpy(p_dst, v26, v20);
      *((_QWORD *)v1 + 5) = v20;
      v28 = prot_pread(*v1, v26, v20, v21);
      if (v28 == -1)
        goto LABEL_36;
      v29 = v28;
      *((_QWORD *)v1 + 4) = v28;
      *((_QWORD *)v1 + 5) = 0;
      v21 = *((_QWORD *)v1 + 3) + v28;
      *((_QWORD *)v1 + 3) = v21;
      if (!v28)
      {
        v9 = v5;
        v5 = v20;
        goto LABEL_6;
      }
      v4 = 0;
      p_dst = &v27[v20];
      v8 -= v20;
      v5 += v20;
      v20 = v29;
      if (v8 <= v29)
        goto LABEL_5;
    }
  }
  v9 = 0;
LABEL_6:
  if (v5 + v9 != 1)
    return 0;
  if (((char)__dst & 0x80000000) == 0)
  {
LABEL_26:
    v32 = 0;
    return v2_readVInt64_1804((uint64_t)&__dst, &v32);
  }
  if (__dst >= 0xC0u)
  {
    if (__dst >= 0xE0u)
    {
      if (__dst >= 0xF0u)
      {
        if (__dst >= 0xF8u)
        {
          if (__dst >= 0xFCu)
          {
            if (__dst >= 0xFEu)
            {
              v10 = 7;
              if (__dst == 255)
                v10 = 8;
            }
            else
            {
              v10 = 6;
            }
          }
          else
          {
            v10 = 5;
          }
        }
        else
        {
          v10 = 4;
        }
      }
      else
      {
        v10 = 3;
      }
    }
    else
    {
      v10 = 2;
    }
  }
  else
  {
    v10 = 1;
  }
  v11 = (char *)&__dst + 1;
  v12 = *((_QWORD *)v1 + 4);
  v13 = *((_QWORD *)v1 + 5);
  if (v13 + v10 <= v12)
  {
    v14 = 0;
    v15 = v10;
    v16 = v10;
LABEL_24:
    memcpy(v11, (const void *)(*((_QWORD *)v1 + 6) + v13), v16);
    *((_QWORD *)v1 + 5) = v13 + v16;
    v17 = v14;
    v14 = v16;
    goto LABEL_25;
  }
  v15 = v10;
  v22 = (char *)*((_QWORD *)v1 + 6);
  v14 = v12 - v13;
  if (v12 != v13)
  {
    memcpy((char *)&__dst + 1, &v22[v13], v12 - v13);
    *v3 = v12;
  }
  v23 = prot_pread(*v1, v22, v12, *((_QWORD *)v1 + 3));
  if (v23 == -1)
  {
    v14 = 0;
LABEL_45:
    v1[4] = *__error();
    v17 = v14;
    v14 = 0;
    goto LABEL_25;
  }
  v24 = v23;
  *((_QWORD *)v1 + 4) = v23;
  *((_QWORD *)v1 + 5) = 0;
  v25 = *((_QWORD *)v1 + 3) + v23;
  *((_QWORD *)v1 + 3) = v25;
  if (v23)
  {
    v11 = (char *)&__dst + v14 + 1;
    v16 = v15 - v14;
    if (v15 - v14 <= v23)
    {
      v13 = 0;
      goto LABEL_24;
    }
    while (1)
    {
      v30 = (void *)*((_QWORD *)v1 + 6);
      memcpy(v11, v30, v24);
      *((_QWORD *)v1 + 5) = v24;
      v31 = prot_pread(*v1, v30, v24, v25);
      if (v31 == -1)
        goto LABEL_45;
      *((_QWORD *)v1 + 4) = v31;
      *((_QWORD *)v1 + 5) = 0;
      v25 = *((_QWORD *)v1 + 3) + v31;
      *((_QWORD *)v1 + 3) = v25;
      if (!v31)
      {
        v17 = v14;
        v14 = v24;
        goto LABEL_25;
      }
      v13 = 0;
      v11 += v24;
      v16 -= v24;
      v14 += v24;
      v24 = v31;
      if (v16 <= v31)
        goto LABEL_24;
    }
  }
  v17 = 0;
LABEL_25:
  if (v14 + v17 == v15)
    goto LABEL_26;
  return 0;
}

size_t SIValueSet<unsigned long long>::ReadStreamCtx::read_bytes(uint64_t a1, char *__dst, size_t __n)
{
  char *v4;
  unsigned int *v5;
  size_t v6;
  uint64_t v7;
  size_t v8;
  size_t v9;
  unint64_t v11;
  void *v12;
  unint64_t v13;
  size_t __na;

  v4 = __dst;
  v5 = *(unsigned int **)(a1 + 8);
  v6 = *((_QWORD *)v5 + 4);
  v7 = *((_QWORD *)v5 + 5);
  if (v7 + __n > v6)
  {
    v8 = v6 - v7;
    if (v6 != v7)
    {
      memcpy(__dst, (const void *)(*((_QWORD *)v5 + 6) + v7), v6 - v7);
      v6 = *((_QWORD *)v5 + 4);
      *((_QWORD *)v5 + 5) += v8;
    }
    v11 = prot_pread(*v5, *((void **)v5 + 6), v6, *((_QWORD *)v5 + 3));
    if (v11 == -1)
    {
      v8 = 0;
    }
    else
    {
      *((_QWORD *)v5 + 4) = v11;
      *((_QWORD *)v5 + 5) = 0;
      *((_QWORD *)v5 + 3) += v11;
      if (!v11)
      {
        v9 = 0;
        return v8 + v9;
      }
      v4 += v8;
      __n -= v8;
      if (__n <= v11)
      {
        v7 = 0;
        goto LABEL_3;
      }
      __na = v11;
      while (1)
      {
        memcpy(v4, *((const void **)v5 + 6), __na);
        v12 = (void *)*((_QWORD *)v5 + 6);
        *((_QWORD *)v5 + 5) += __na;
        v13 = prot_pread(*v5, v12, *((_QWORD *)v5 + 4), *((_QWORD *)v5 + 3));
        if (v13 == -1)
          break;
        *((_QWORD *)v5 + 4) = v13;
        *((_QWORD *)v5 + 5) = 0;
        *((_QWORD *)v5 + 3) += v13;
        if (!v13)
        {
          v9 = v8;
          v8 = __na;
          return v8 + v9;
        }
        v7 = 0;
        v4 += __na;
        __n -= __na;
        v8 += __na;
        __na = v13;
        if (__n <= v13)
          goto LABEL_3;
      }
    }
    v5[4] = *__error();
    v9 = v8;
    v8 = 0;
    return v8 + v9;
  }
  v8 = 0;
LABEL_3:
  memcpy(v4, (const void *)(*((_QWORD *)v5 + 6) + v7), __n);
  *((_QWORD *)v5 + 5) += __n;
  v9 = v8;
  v8 = __n;
  return v8 + v9;
}

void SIValueSet<unsigned long long>::ReadStreamCtx::~ReadStreamCtx()
{
  JUMPOUT(0x1BCCB06A4);
}

uint64_t RLEOIDArrayAddSortedOids(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  pthread_rwlock_t *v6;

  v6 = (pthread_rwlock_t *)(a1 + 16);
  pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 16));
  SIValueSet<unsigned long long>::_SIValueSetAddSortedValues((unint64_t *)(a1 + 216), a2, a3, 0);
  return pthread_rwlock_unlock(v6);
}

void RLEOIDArrayAddOids(uint64_t a1, const void *a2, uint64_t a3)
{
  size_t v6;
  _QWORD *v7;

  if (a3)
  {
    v6 = 8 * a3;
    v7 = malloc_type_malloc(8 * a3, 0x100004000313F17uLL);
    memcpy(v7, a2, v6);
    qsort_oids((uint64_t)v7, a3);
    pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 16));
    SIValueSet<unsigned long long>::_SIValueSetAddSortedValues((unint64_t *)(a1 + 216), v7, a3, 0);
    pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 16));
    free(v7);
  }
}

uint64_t RLEOIDArrayRemoveOid(uint64_t a1, unint64_t a2)
{
  pthread_rwlock_t *v4;
  int v5;

  v4 = (pthread_rwlock_t *)(a1 + 16);
  pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 16));
  if (!*(_BYTE *)(a1 + 384))
  {
    v5 = *(_DWORD *)(a1 + 224);
    if (!v5 || *(_QWORD *)(a1 + 216) == ((-1 << (-4 * v5)) & a2))
      SIValueSet<unsigned long long>::_SIValueSetInnerRemove(a1 + 256, a2, v5, a1 + 232);
  }
  return pthread_rwlock_unlock(v4);
}

uint64_t RLEOIDArrayRemoveOids(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  pthread_rwlock_t *v6;
  int v8;
  uint64_t i;
  unint64_t v10;
  unint64_t v11;

  v6 = (pthread_rwlock_t *)(a1 + 16);
  pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 16));
  if (!*(_BYTE *)(a1 + 384))
  {
    v8 = *(_DWORD *)(a1 + 224);
    for (i = v8 ? -1 << (-4 * v8) : 0; a3; --a3)
    {
      v11 = *a2++;
      v10 = v11;
      if (((*(_QWORD *)(a1 + 216) ^ v11) & i) == 0)
        SIValueSet<unsigned long long>::_SIValueSetInnerRemove(a1 + 256, v10, *(_DWORD *)(a1 + 224), a1 + 232);
    }
  }
  return pthread_rwlock_unlock(v6);
}

uint64_t RLEOIDArrayRemoveOidsWithExistence(uint64_t a1, unint64_t *a2, uint64_t a3, _BYTE *a4)
{
  pthread_rwlock_t *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t v15;
  int v16;

  v8 = (pthread_rwlock_t *)(a1 + 16);
  pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 16));
  v9 = a3 - 1;
  if (a3 < 1 || *(_BYTE *)(a1 + 384))
  {
    v10 = 0;
    goto LABEL_4;
  }
  v10 = 0;
  v14 = *a2;
  v13 = a2 + 1;
  v12 = v14;
LABEL_8:
  v16 = *(_DWORD *)(a1 + 224);
  if (!v16)
  {
    if ((SIValueSet<unsigned long long>::_SIValueSetInnerRemove(a1 + 256, v12, 0, a1 + 232) & 1) == 0)
      goto LABEL_6;
    goto LABEL_13;
  }
  if (*(_QWORD *)(a1 + 216) == ((-1 << (-4 * v16)) & v12)
    && SIValueSet<unsigned long long>::_SIValueSetInnerRemove(a1 + 256, v12, v16, a1 + 232))
  {
LABEL_13:
    *a4 = 1;
    ++v10;
  }
LABEL_6:
  while (v9)
  {
    --v9;
    ++a4;
    v15 = *v13++;
    v12 = v15;
    if (!*(_BYTE *)(a1 + 384))
      goto LABEL_8;
  }
LABEL_4:
  pthread_rwlock_unlock(v8);
  return v10;
}

uint64_t RLEOIDArrayRemoveSortedOids(uint64_t a1, unint64_t *a2, uint64_t a3, uint64_t a4)
{
  pthread_rwlock_t *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  int v13;
  unint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t v17;
  int v18;

  v8 = (pthread_rwlock_t *)(a1 + 16);
  pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 16));
  v9 = a3 - 1;
  if (a3 >= 1)
  {
    if (a4)
    {
      do
      {
        v12 = *a2++;
        v11 = v12;
        if (*(_BYTE *)(a1 + 384)
          || (v13 = *(_DWORD *)(a1 + 224)) != 0
          && *(_QWORD *)(a1 + 216) != ((-1 << (-4 * v13)) & v11))
        {
          v10 = 0;
        }
        else
        {
          v10 = SIValueSet<unsigned long long>::_SIValueSetInnerRemove(a1 + 256, v11, v13, a1 + 232);
        }
        (*(void (**)(uint64_t, unint64_t, uint64_t))(a4 + 16))(a4, v11, v10);
        --a3;
      }
      while (a3);
    }
    else if (!*(_BYTE *)(a1 + 384))
    {
      v16 = *a2;
      v15 = a2 + 1;
      v14 = v16;
LABEL_13:
      v18 = *(_DWORD *)(a1 + 224);
      if (!v18 || *(_QWORD *)(a1 + 216) == ((-1 << (-4 * v18)) & v14))
        SIValueSet<unsigned long long>::_SIValueSetInnerRemove(a1 + 256, v14, v18, a1 + 232);
      while (v9)
      {
        --v9;
        v17 = *v15++;
        v14 = v17;
        if (!*(_BYTE *)(a1 + 384))
          goto LABEL_13;
      }
    }
  }
  return pthread_rwlock_unlock(v8);
}

BOOL countOids(unint64_t *a1, uint64_t a2, unint64_t *a3)
{
  unint64_t v3;
  unint64_t v4;

  v3 = *a3;
  v4 = a3[1] + a2;
  a3[1] = v4;
  return v4 >= v3;
}

uint64_t RLEOIDArrayGetAllOids(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  pthread_rwlock_t *v6;
  uint64_t v7;
  void *v8;
  _QWORD v10[2];
  __int128 v11;

  *a3 = 0;
  v6 = (pthread_rwlock_t *)(a1 + 16);
  pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 16));
  v11 = xmmword_1B8631BE0;
  SIValueSet<unsigned long long>::_SIValueSetInnerIterate(a1 + 256, *(_QWORD *)(a1 + 216), *(_DWORD *)(a1 + 224), (uint64_t)countOids, (uint64_t)&v11, 1024);
  v7 = *((_QWORD *)&v11 + 1);
  *a3 = *((_QWORD *)&v11 + 1);
  if (a2)
  {
    v8 = malloc_type_malloc(8 * v7, 0x100004000313F17uLL);
    *a2 = v8;
    v10[0] = v8;
    v10[1] = 0;
    SIValueSet<unsigned long long>::_SIValueSetInnerIterate(a1 + 256, *(_QWORD *)(a1 + 216), *(_DWORD *)(a1 + 224), (uint64_t)addOids, (uint64_t)v10, 1024);
  }
  return pthread_rwlock_unlock(v6);
}

uint64_t addOids(unint64_t *a1, unint64_t a2, uint64_t *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t *v12;
  _OWORD *v13;
  unint64_t v14;
  __int128 v15;

  if (a2)
  {
    v3 = *a3;
    v4 = a3[1];
    if (a2 > 5 && (v5 = 8 * v4 + v3, (unint64_t)(v5 - (_QWORD)a1) >= 0x20))
    {
      v6 = a2 & 0xFFFFFFFFFFFFFFFCLL;
      v12 = a1 + 2;
      v13 = (_OWORD *)(v5 + 16);
      v14 = a2 & 0xFFFFFFFFFFFFFFFCLL;
      do
      {
        v15 = *(_OWORD *)v12;
        *(v13 - 1) = *((_OWORD *)v12 - 1);
        *v13 = v15;
        v12 += 4;
        v13 += 2;
        v14 -= 4;
      }
      while (v14);
      v4 += v6;
      v10 = v4;
      if (v6 == a2)
        goto LABEL_7;
    }
    else
    {
      v6 = 0;
    }
    v7 = a2 - v6;
    v8 = &a1[v6];
    do
    {
      v9 = *v8++;
      v10 = v4 + 1;
      *(_QWORD *)(v3 + 8 * v4++) = v9;
      --v7;
    }
    while (v7);
LABEL_7:
    a3[1] = v10;
  }
  return 0;
}

uint64_t SIValueSet<unsigned long long>::_SIValueSetInnerEmpty(uint64_t a1, int a2)
{
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t result;

  v3 = 0;
  v4 = (a2 + 1);
  do
  {
    v5 = *(_QWORD *)(a1 + 8 * v3);
    if (v5)
    {
      if ((v5 & 1) != 0)
      {
        result = SIValueSet<unsigned long long>::_SIValueSetInnerEmpty(v5 & 0xFFFFFFFFFFFFFFFELL, v4);
        if (v3 > 0xE)
          return result;
      }
      else
      {
        result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 48))(v5);
        if (v3 > 0xE)
          return result;
      }
    }
    else
    {
      result = 1;
      if (v3 > 0xE)
        return result;
    }
    ++v3;
  }
  while ((result & 1) != 0);
  return result;
}

void *RLEOIDArrayFlatten(uint64_t a1, uint64_t *a2)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  size_t v8;
  size_t v9;
  size_t v10;
  char *v11;
  void *result;
  uint64_t (**v13)();
  void *v14;
  __int128 v15;

  v13 = off_1E6E2A678;
  v15 = xmmword_1B8631F70;
  v14 = mmap(0, 0x1000uLL, 3, 4098, -268435456, 0);
  SIValueSet<unsigned long long>::MemoryStream::write_vint32(&v13, *(unsigned __int8 *)(a1 + 384));
  ((void (*)(_QWORD *, unsigned int))v13[1])(&v13, *(_DWORD *)(a1 + 224));
  if (*(_DWORD *)(a1 + 224))
  {
    ((void (*)(uint64_t, unint64_t))*v13)((uint64_t)&v13, *(_QWORD *)(a1 + 216));
    v4 = *(_DWORD *)(a1 + 224);
  }
  else
  {
    v4 = 0;
  }
  SIValueSet<unsigned long long>::_SIValueSetInnerSerialize(a1 + 256, *(_QWORD *)(a1 + 216), v4, (uint64_t)&v13);
  ((void (*)(uint64_t, unint64_t))*v13)((uint64_t)&v13, 0);
  v5 = v15;
  v6 = v15 + 7;
  v7 = (v15 + 7) & 0xFFFFFFFFFFFFFFF8;
  v8 = v7 - v15;
  if (v7 != (_QWORD)v15)
  {
    v9 = *((_QWORD *)&v15 + 1);
    if (*((_QWORD *)&v15 + 1) >= v7)
    {
      v11 = (char *)v14;
    }
    else
    {
      v10 = *((_QWORD *)&v15 + 1);
      do
        v10 *= 2;
      while (v10 < v7);
      *((_QWORD *)&v15 + 1) = v10;
      v11 = (char *)mmap(0, v10, 3, 4098, -268435456, 0);
      memcpy(v11, v14, v15);
      munmap(v14, v9);
      v14 = v11;
      v5 = v15;
    }
    bzero(&v11[v5], v8);
    v6 = v15 + v8 + 7;
  }
  result = v14;
  *a2 = v6 / 8;
  return result;
}

_QWORD *SIValueSet<unsigned long long>::MemoryStream::write_vint32(_QWORD *result, unsigned int a2)
{
  _QWORD *v3;
  uint64_t v4;
  size_t v5;
  size_t v6;
  char *v7;
  char *v8;
  uint64_t v9;
  char *v10;
  char *v11;
  char *v12;

  v3 = result;
  v4 = result[2];
  v5 = result[3];
  if (v5 < v4 + 5)
  {
    v6 = result[3];
    do
      v6 *= 2;
    while (v6 < v4 + 5);
    result[3] = v6;
    v7 = (char *)mmap(0, v6, 3, 4098, -268435456, 0);
    memcpy(v7, (const void *)v3[1], v3[2]);
    result = (_QWORD *)munmap((void *)v3[1], v5);
    v3[1] = v7;
    v4 = v3[2];
    if (a2 > 0x7F)
      goto LABEL_5;
LABEL_8:
    v9 = v4 + 1;
    v7[v4] = a2;
    goto LABEL_14;
  }
  v7 = (char *)result[1];
  if (a2 <= 0x7F)
    goto LABEL_8;
LABEL_5:
  if (a2 >> 14)
  {
    if (a2 >> 21)
    {
      if (a2 >> 28)
      {
        v12 = &v7[v4];
        *v12 = -16;
        *(_DWORD *)(v12 + 1) = a2;
        v9 = v4 + 5;
      }
      else
      {
        v11 = &v7[v4];
        *v11 = HIBYTE(a2) | 0xE0;
        v11[1] = BYTE2(a2);
        v11[2] = BYTE1(a2);
        v9 = v4 + 4;
        v11[3] = a2;
      }
    }
    else
    {
      v10 = &v7[v4];
      *v10 = BYTE2(a2) | 0xC0;
      v10[1] = BYTE1(a2);
      v9 = v4 + 3;
      v10[2] = a2;
    }
  }
  else
  {
    v8 = &v7[v4];
    *v8 = BYTE1(a2) | 0x80;
    v9 = v4 + 2;
    v8[1] = a2;
  }
LABEL_14:
  v3[2] = v9;
  return result;
}

uint64_t SIValueSet<unsigned long long>::MemoryStream::write_vint(uint64_t a1, unint64_t a2)
{
  uint64_t v4;
  size_t v5;
  size_t v6;
  size_t v7;
  void *v8;
  uint64_t result;

  v4 = *(_QWORD *)(a1 + 16);
  v5 = *(_QWORD *)(a1 + 24);
  v6 = v4 + 9;
  if (v5 >= v4 + 9)
  {
    v8 = *(void **)(a1 + 8);
  }
  else
  {
    v7 = *(_QWORD *)(a1 + 24);
    do
      v7 *= 2;
    while (v7 < v6);
    *(_QWORD *)(a1 + 24) = v7;
    v8 = mmap(0, v7, 3, 4098, -268435456, 0);
    memcpy(v8, *(const void **)(a1 + 8), *(_QWORD *)(a1 + 16));
    munmap(*(void **)(a1 + 8), v5);
    *(_QWORD *)(a1 + 8) = v8;
    v4 = *(_QWORD *)(a1 + 16);
  }
  result = v2_writeVInt64((uint64_t)v8, v4, a2);
  *(_QWORD *)(a1 + 16) = result;
  return result;
}

void *SIValueSet<unsigned long long>::MemoryStream::write_bytes(uint64_t a1, const void *a2, size_t a3)
{
  uint64_t v6;
  size_t v7;
  size_t v8;
  char *v9;
  void *result;

  v6 = *(_QWORD *)(a1 + 16);
  v7 = *(_QWORD *)(a1 + 24);
  if (v7 >= v6 + a3)
  {
    v9 = *(char **)(a1 + 8);
  }
  else
  {
    v8 = *(_QWORD *)(a1 + 24);
    do
      v8 *= 2;
    while (v8 < v6 + a3);
    *(_QWORD *)(a1 + 24) = v8;
    v9 = (char *)mmap(0, v8, 3, 4098, -268435456, 0);
    memcpy(v9, *(const void **)(a1 + 8), *(_QWORD *)(a1 + 16));
    munmap(*(void **)(a1 + 8), v7);
    *(_QWORD *)(a1 + 8) = v9;
    v6 = *(_QWORD *)(a1 + 16);
  }
  result = memcpy(&v9[v6], a2, a3);
  *(_QWORD *)(a1 + 16) += a3;
  return result;
}

_QWORD *SIValueSet<unsigned long long>::MemoryStream::~MemoryStream(_QWORD *a1)
{
  void *v2;

  *a1 = off_1E6E2A678;
  v2 = (void *)a1[1];
  if (v2)
    munmap(v2, a1[3]);
  return a1;
}

void SIValueSet<unsigned long long>::MemoryStream::~MemoryStream(_QWORD *a1)
{
  void *v2;

  *a1 = off_1E6E2A678;
  v2 = (void *)a1[1];
  if (v2)
    munmap(v2, a1[3]);
  JUMPOUT(0x1BCCB06A4);
}

const void *RLEOIDArrayUnflatten(const __CFAllocator *a1, uint64_t a2, uint64_t a3)
{
  const void *Instance;
  int v8;
  _QWORD v9[4];

  if (!__kRLEOIDArrayTypeID)
    __kRLEOIDArrayTypeID = _CFRuntimeRegisterClass();
  Instance = (const void *)_CFRuntimeCreateInstance();
  v9[0] = off_1E6E2A900;
  v9[1] = a2;
  v9[2] = 8 * a3;
  v9[3] = 0;
  v8 = 0;
  SIValueSet<unsigned long long>::SIValueSet((uint64_t)Instance + 216, (uint64_t)v9, a1, &v8);
  if (v8)
  {
    CFRelease(Instance);
    return 0;
  }
  return Instance;
}

uint64_t SIValueSet<unsigned long long>::ReadMemoryStream::read_vint32(_QWORD *a1)
{
  unint64_t v1;
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v1 = a1[3];
  if (v1 >= a1[2])
    return 0;
  v2 = a1[1];
  v3 = v1 + 1;
  v4 = *(unsigned __int8 *)(v2 + v1);
  if (*(char *)(v2 + v1) < 0)
  {
    if (v4 > 0xBF)
    {
      if (v4 > 0xDF)
      {
        if (v4 > 0xEF)
        {
          v4 = *(unsigned int *)(v2 + v3);
          v3 = v1 + 5;
        }
        else
        {
          v4 = ((v4 & 0xF) << 24) | (*(unsigned __int8 *)(v2 + v3) << 16) | (*(unsigned __int8 *)(v1 + v2 + 2) << 8) | *(unsigned __int8 *)(v1 + v2 + 3);
          v3 = v1 + 4;
        }
      }
      else
      {
        v4 = ((v4 & 0x1F) << 16) | (*(unsigned __int8 *)(v2 + v3) << 8) | *(unsigned __int8 *)(v1 + v2 + 2);
        v3 = v1 + 3;
      }
    }
    else
    {
      v5 = *(unsigned __int8 *)(v2 + v3) | ((v4 & 0x3F) << 8);
      v3 = v1 + 2;
      v4 = v5;
    }
  }
  a1[3] = v3;
  return v4;
}

unint64_t SIValueSet<unsigned long long>::ReadMemoryStream::read_vint(uint64_t *a1)
{
  if (a1[3] >= (unint64_t)a1[2])
    return 0;
  else
    return v2_readVInt64_1804(a1[1], a1 + 3);
}

size_t SIValueSet<unsigned long long>::ReadMemoryStream::read_bytes(_QWORD *a1, void *__dst, size_t a3)
{
  uint64_t v4;
  size_t v5;
  size_t v6;

  v5 = a1[2];
  v4 = a1[3];
  if (v4 + a3 <= v5)
  {
    v6 = a3;
    memcpy(__dst, (const void *)(a1[1] + v4), a3);
    a1[3] += v6;
  }
  else
  {
    v6 = v5 - v4;
    a1[3] = v5;
    memcpy(__dst, (const void *)(a1[1] + v5), v5 - v4);
  }
  return v6;
}

void SIValueSet<unsigned long long>::ReadMemoryStream::~ReadMemoryStream()
{
  JUMPOUT(0x1BCCB06A4);
}

uint64_t runBlock(unint64_t *a1, uint64_t a2, void (**a3)(_QWORD, _QWORD, _QWORD))
{
  ((void (**)(_QWORD, unint64_t *, uint64_t))a3)[2](a3, a1, a2);
  return 0;
}

_QWORD *RLEOIDIteratorCreate(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;

  v2 = malloc_type_calloc(1uLL, 0x10uLL, 0x60040FAFB2B2FuLL);
  pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 16));
  v3 = operator new();
  v4 = v3;
  *(_BYTE *)v3 = 0;
  v5 = *(_DWORD *)(a1 + 224);
  v6 = -1 << (-4 * v5);
  if (!v5)
    v6 = 0;
  v7 = v6 & *(_QWORD *)(a1 + 216);
  *(_QWORD *)(v3 + 8) = a1 + 216;
  *(_QWORD *)(v3 + 16) = v7;
  *(_DWORD *)(v3 + 24) = v5;
  *(_QWORD *)(v3 + 160) = 0;
  *(_QWORD *)(v3 + 168) = malloc_type_malloc(0x30uLL, 0x82607F9uLL);
  *v2 = v4;
  v2[1] = CFRetain((CFTypeRef)a1);
  return v2;
}

void RLEOIDIteratorDestroy(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *a1;
  if (*a1)
  {
    free(*(void **)(v2 + 168));
    MEMORY[0x1BCCB06A4](v2, 0x1030C40B1D16A70);
  }
  v3 = a1[1];
  if (v3)
  {
    pthread_rwlock_unlock((pthread_rwlock_t *)(v3 + 16));
    CFRelease((CFTypeRef)a1[1]);
  }
  free(a1);
}

uint64_t RLEOIDIteratorNext(_BYTE **a1, uint64_t a2, uint64_t a3)
{
  _BYTE **v3;
  _BYTE *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  int v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  BOOL v12;
  uint64_t v13;
  unint64_t v14;
  char v15;
  int v16;
  unint64_t v17;
  char v18;
  char v19;
  int v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  _BYTE *v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  _BYTE *v35;
  char v36;
  uint64_t (*v37)(void);
  uint64_t v38;
  int v39;
  uint64_t v40;
  unint64_t v41;
  int v42;
  uint64_t v43;
  _BYTE *v44;
  uint64_t v45;
  int v46;
  _BYTE *v47;
  char v48;

  v3 = a1;
  v4 = *a1;
  if (!**a1)
  {
    v6 = a3;
    v5 = 0;
    v7 = *((_QWORD *)v4 + 2);
    v8 = *((_DWORD *)v4 + 6);
    while (1)
    {
      while (1)
      {
LABEL_5:
        v9 = *((_QWORD *)v4 + 20);
        if (v9)
        {
          v10 = 0;
          v11 = v6 - v5;
          while (1)
          {
            v12 = !(*(unsigned int (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9) || v10 >= v11;
            if (v12)
              break;
            v13 = (***((uint64_t (****)(_QWORD))v4 + 20))(*((_QWORD *)v4 + 20));
            v14 = v10 + 1;
            *(_QWORD *)(a2 + 8 * v5 + 8 * v10) = v13;
            v9 = *((_QWORD *)v4 + 20);
            ++v10;
            if (!v9)
              goto LABEL_15;
          }
          v14 = v10;
        }
        else
        {
          v14 = 0;
        }
LABEL_15:
        v5 += v14;
        v6 = a3;
        if (v5 == a3)
        {
          v5 = a3;
LABEL_73:
          v3 = a1;
          if (!v5)
            goto LABEL_2;
          return v5;
        }
        if (*((_QWORD *)v4 + 20))
        {
          *((_QWORD *)v4 + 20) = 0;
          v15 = (60 - 4 * v8) & 0xFC;
          if ((~(v7 >> v15) & 0xF) != 0)
          {
            v17 = (1 << v15) + v7;
            *((_QWORD *)v4 + 2) = v17;
          }
          else
          {
            v16 = *(_DWORD *)(*((_QWORD *)v4 + 1) + 8);
            if (v8 == v16)
            {
              *v4 = 1;
              v3 = a1;
              if (v5)
                return v5;
              goto LABEL_2;
            }
            v17 = (1 << v15) + v7;
            *((_QWORD *)v4 + 2) = v17;
            v8 = *((_DWORD *)v4 + 6);
            while (v16 + 1 != v8)
            {
              v18 = (64 - 4 * v8--) & 0xFC;
              if (((v17 >> v18) & 0xF) != 0)
                goto LABEL_26;
            }
            v8 = v16;
LABEL_26:
            *((_DWORD *)v4 + 6) = v8;
          }
        }
        else
        {
          v17 = v7;
        }
        v19 = 60 - 4 * v8;
        v20 = *(_DWORD *)(*((_QWORD *)v4 + 1) + 8);
        if (v8 != v20)
          break;
        if (*v4)
          goto LABEL_73;
        v21 = v17 >> (v19 & 0xFC);
        v22 = 1 << ((60 - 4 * *((_WORD *)v4 + 12)) & 0xFC);
        v23 = v21 & 0xF;
        v24 = *((_QWORD *)v4 + 2);
        v25 = *((_QWORD *)v4 + 1) + 40;
        v26 = 8 * v23;
        if (v26 == 128)
        {
LABEL_4:
          *v4 = 1;
          v7 = v17;
        }
        else
        {
          while (1)
          {
            v27 = *(_QWORD *)(v25 + v26);
            if (v27)
              break;
            v24 += v22;
            *((_QWORD *)v4 + 2) = v24;
            v26 += 8;
            if (v26 == 128)
              goto LABEL_4;
          }
          if ((v27 & 1) != 0)
          {
            v38 = *((int *)v4 + 6);
            v39 = v38 + 1;
            *((_DWORD *)v4 + 6) = v38 + 1;
            *(_QWORD *)&v4[8 * v38 + 32] = v27 & 0xFFFFFFFFFFFFFFFELL;
            if ((int)v38 < *(_DWORD *)(*((_QWORD *)v4 + 1) + 8))
              goto LABEL_69;
            LODWORD(v40) = 0;
            v41 = *((_QWORD *)v4 + 2);
LABEL_55:
            v43 = v39--;
            while (2)
            {
              v44 = &v4[8 * v39];
              v39 = v43;
              v45 = *((_QWORD *)v44 + 4);
              v46 = v40 - 16;
              while (1)
              {
                v27 = *(_QWORD *)(v45 + 8 * ((v41 >> ((60 - 4 * v43) & 0xFC)) & 0xF));
                if (v27)
                  break;
                v41 += 1 << ((60 - 4 * v43) & 0xFC);
                *((_QWORD *)v4 + 2) = v41;
                v12 = __CFADD__(v46++, 1);
                if (v12)
                {
                  do
                  {
                    v48 = 64 - 4 * v39--;
                    v40 = (v41 >> (v48 & 0xFC)) & 0xF;
                    if ((_DWORD)v40)
                    {
                      *((_DWORD *)v4 + 6) = v39;
                      v42 = *(_DWORD *)(*((_QWORD *)v4 + 1) + 8);
                      goto LABEL_54;
                    }
                    v42 = *(_DWORD *)(*((_QWORD *)v4 + 1) + 8);
                  }
                  while (v39 > v42);
                  *((_DWORD *)v4 + 6) = v39;
                  if (v39 == v42)
                  {
                    *v4 = 1;
                    goto LABEL_69;
                  }
                  LODWORD(v40) = 0;
LABEL_54:
                  if (v39 <= v42)
                    goto LABEL_69;
                  goto LABEL_55;
                }
              }
              if ((v27 & 1) != 0)
              {
                LODWORD(v40) = 0;
                v47 = &v4[8 * v43++];
                *((_DWORD *)v4 + 6) = v43;
                *((_QWORD *)v47 + 4) = v27 & 0xFFFFFFFFFFFFFFFELL;
                continue;
              }
              break;
            }
          }
          v37 = *(uint64_t (**)(void))(*(_QWORD *)v27 + 88);
LABEL_68:
          *((_QWORD *)v4 + 20) = v37();
LABEL_69:
          v8 = *((_DWORD *)v4 + 6);
          v7 = *((_QWORD *)v4 + 2);
        }
      }
      v8 = *((_DWORD *)v4 + 6);
      v7 = *((_QWORD *)v4 + 2);
      if (v8 > v20)
      {
        v28 = (v17 >> (v19 & 0xFC)) & 0xF;
LABEL_37:
        v30 = v8--;
        while (2)
        {
          v31 = &v4[8 * v8];
          v8 = v30;
          v32 = *((_QWORD *)v31 + 4);
          v33 = v28 - 16;
          while (1)
          {
            v34 = *(_QWORD *)(v32 + 8 * ((v7 >> ((60 - 4 * v30) & 0xFC)) & 0xF));
            if (v34)
              break;
            v7 += 1 << ((60 - 4 * v30) & 0xFC);
            *((_QWORD *)v4 + 2) = v7;
            v12 = __CFADD__(v33++, 1);
            if (v12)
            {
              do
              {
                v36 = 64 - 4 * v8--;
                v28 = (v7 >> (v36 & 0xFC)) & 0xF;
                if (((v7 >> (v36 & 0xFC)) & 0xF) != 0)
                {
                  *((_DWORD *)v4 + 6) = v8;
                  v29 = *(_DWORD *)(*((_QWORD *)v4 + 1) + 8);
                  goto LABEL_36;
                }
                v29 = *(_DWORD *)(*((_QWORD *)v4 + 1) + 8);
              }
              while (v8 > v29);
              *((_DWORD *)v4 + 6) = v8;
              if (v8 == v29)
              {
                *v4 = 1;
                goto LABEL_5;
              }
              LODWORD(v28) = 0;
LABEL_36:
              if (v8 <= v29)
                goto LABEL_5;
              goto LABEL_37;
            }
          }
          if ((v34 & 1) != 0)
          {
            LODWORD(v28) = 0;
            v35 = &v4[8 * v30++];
            *((_DWORD *)v4 + 6) = v30;
            *((_QWORD *)v35 + 4) = v34 & 0xFFFFFFFFFFFFFFFELL;
            continue;
          }
          break;
        }
        v37 = *(uint64_t (**)(void))(*(_QWORD *)v34 + 88);
        goto LABEL_68;
      }
    }
  }
LABEL_2:
  pthread_rwlock_unlock((pthread_rwlock_t *)(v3[1] + 16));
  CFRelease(v3[1]);
  v5 = 0;
  v3[1] = 0;
  return v5;
}

uint64_t RLEOIDArrayValidate()
{
  return 1;
}

uint64_t data_map_init_with_ctx(uint64_t a1)
{
  int v1;
  char *v3;
  char *v4;
  const char *v5;
  uint64_t v6;

  if (*(_DWORD *)(a1 + 16) >= 5u)
  {
    v3 = __si_assert_copy_extra_268();
    v4 = v3;
    v5 = "";
    if (v3)
      v5 = v3;
    __message_assert("%s:%u: failed assertion '%s' %s ", "data_map.c", 148, "ctx->extra_size <= sizeof(uint32_t)", v5);
    free(v4);
    if (__valid_fs(-1))
      v6 = 2989;
    else
      v6 = 3072;
    *(_DWORD *)v6 = -559038737;
    abort();
  }
  v1 = *(_DWORD *)(a1 + 20);
  if ((v1 & 0x20) != 0)
    return data_map64_init_with_ctx(a1);
  if ((v1 & 0x40) != 0)
    return data_map_ext_init_with_ctx(a1);
  return data_map32_init_with_ctx(a1);
}

void data_map_destroy(uint64_t a1)
{
  int v1;
  char *v2;
  char *v3;
  const char *v4;

  v1 = *(_DWORD *)(a1 + 216);
  switch(v1)
  {
    case -270471200:
      data_map_ext_destroy(a1);
      break;
    case 1684300900:
      data_map64_destroy(a1);
      break;
    case 842150450:
      data_map32_destroy(a1);
      break;
    default:
      v2 = __si_assert_copy_extra_268();
      v3 = v2;
      if (v2)
        v4 = v2;
      else
        v4 = "";
      __message_assert("%s:%u: Unexpected code path %s ", "data_map.c", 172, v4);
      free(v3);
      MEMORY[0xBAD] = -559038737;
      abort();
  }
}

uint64_t data_map_valid(_DWORD *a1)
{
  int v1;
  _DWORD *v2;

  if (!a1)
    return 1;
  v1 = a1[54];
  if (v1 == -270471200)
  {
    v2 = a1 + 116;
    return *v2 == 0;
  }
  if (v1 == 1684300900)
  {
    v2 = a1 + 1142;
    return *v2 == 0;
  }
  if (v1 != 842150450)
    return 1;
  v2 = a1 + 110;
  return *v2 == 0;
}

void data_map_commit_sync(uint64_t a1)
{
  int v2;
  int v3;
  os_unfair_lock_s *v4;
  int v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  int v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  NSObject *v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return;
  v2 = *(_DWORD *)(a1 + 216);
  if (v2 == -270471200)
  {
    if (*(_DWORD *)(a1 + 464) || (v15 = *(_QWORD *)(a1 + 264), *(_DWORD *)(v15 + 16) == 1))
    {
      v12 = *__error();
      v13 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        v16 = *(_QWORD *)(a1 + 376);
        v21 = 134217984;
        v22 = v16;
        goto LABEL_25;
      }
LABEL_26:
      *__error() = v12;
      return;
    }
    *(_DWORD *)(v15 + 16) = 2;
    fd_pwrite(*(_QWORD *)(a1 + 240), v15, 0x54uLL, 0);
    v17 = *__error();
    v18 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      v20 = *(_QWORD *)(a1 + 376);
      v21 = 134217984;
      v22 = v20;
      goto LABEL_32;
    }
LABEL_33:
    *__error() = v17;
    fd_sync(*(_QWORD *)(a1 + 240), 0);
    return;
  }
  if (v2 == 1684300900)
  {
    if (*(_DWORD *)(a1 + 4568) || (v11 = *(_QWORD *)(a1 + 264), *(_DWORD *)(v11 + 16) == 1))
    {
      v12 = *__error();
      v13 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        v14 = *(_QWORD *)(a1 + 4496);
        v21 = 134217984;
        v22 = v14;
LABEL_25:
        _os_log_impl(&dword_1B8270000, v13, OS_LOG_TYPE_DEFAULT, "Already clean cs; don't update next_id = %lld",
          (uint8_t *)&v21,
          0xCu);
        goto LABEL_26;
      }
      goto LABEL_26;
    }
    *(_DWORD *)(v11 + 16) = 2;
    fd_pwrite(*(_QWORD *)(a1 + 240), v11, 0x5CuLL, 0);
    v17 = *__error();
    v18 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      v19 = *(_QWORD *)(a1 + 4496);
      v21 = 134217984;
      v22 = v19;
LABEL_32:
      _os_log_impl(&dword_1B8270000, v18, OS_LOG_TYPE_DEFAULT, "cs update next_id = %lld", (uint8_t *)&v21, 0xCu);
      goto LABEL_33;
    }
    goto LABEL_33;
  }
  if (v2 == 842150450 && !*(_DWORD *)(a1 + 440))
  {
    v3 = *(_DWORD *)(*(_QWORD *)(a1 + 264) + 16);
    if (v3 != 1)
    {
      v4 = *(os_unfair_lock_s **)(a1 + 408);
      if (v3 == 2)
        v5 = 3;
      else
        v5 = 0;
      if (v3)
        v6 = v5;
      else
        v6 = 1;
      SIActivityJournalEvent(v4, *(_DWORD *)(a1 + 416), 8u, v6, *(_DWORD *)(a1 + 364));
      v7 = *(_QWORD *)(a1 + 264);
      *(_DWORD *)(v7 + 16) = 2;
      fd_pwrite(*(_QWORD *)(a1 + 240), v7, 0x38uLL, 0);
      fd_sync(*(_QWORD *)(a1 + 240), 0);
      v8 = *(_QWORD *)(a1 + 264);
      if (v8)
      {
        v9 = *(_DWORD *)(v8 + 16);
        if (v9 < 3)
          v10 = v9 + 1;
        else
          v10 = 0;
      }
      else
      {
        v10 = 0;
      }
      SIActivityJournalEvent(*(os_unfair_lock_s **)(a1 + 408), *(_DWORD *)(a1 + 416), 9u, v10, *(_DWORD *)(a1 + 364));
    }
  }
}

uint64_t data_map_count(uint64_t result)
{
  int v1;
  uint64_t v2;

  if (result)
  {
    v1 = *(_DWORD *)(result + 216);
    switch(v1)
    {
      case -270471200:
        v2 = *(_QWORD *)(result + 376);
        break;
      case 1684300900:
        v2 = *(_QWORD *)(result + 4496);
        break;
      case 842150450:
        return (*(_DWORD *)(result + 364) - 1);
      default:
        return 0;
    }
    return v2 - 1;
  }
  return result;
}

uint64_t _data_map_unlock(uint64_t a1)
{
  int v1;

  if (a1)
  {
    v1 = *(_DWORD *)(a1 + 216);
    switch(v1)
    {
      case -270471200:
        return _data_map_ext_unlock(a1);
      case 1684300900:
        return _data_map64_unlock(a1);
      case 842150450:
        return _data_map32_unlock(a1);
    }
  }
  return a1;
}

uint64_t data_map_get_data_locked(uint64_t result, unint64_t key, _QWORD *a3)
{
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  size_t v11;
  int v12;
  NSObject *v13;
  char *v14;
  uint64_t v15;
  const char *v16;
  char *v17;
  NSObject *v18;
  uint32_t v19;
  uint64_t v20;
  int v21;
  NSObject *v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  const char *v26;
  NSObject *v27;
  uint32_t v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;
  NSObject *v32;
  char *v33;
  uint64_t v34;
  NSObject *v35;
  uint64_t v36;
  char *v37;
  NSObject *v38;
  int *v39;
  uint64_t v40;
  char *v41;
  int *v42;
  uint64_t v43;
  unint64_t v44;
  unsigned int v45;
  int v46;
  uint64_t v47;
  uint64_t contentindex_for_id;
  unsigned int v49;
  uint64_t v50;
  const __CFDictionary *v51;
  const __CFData *Value;
  const __CFData *v53;
  NSObject *v54;
  int v55;
  char *v56;
  int v57;
  NSObject *v58;
  uint64_t v59;
  char *v60;
  int v61;
  NSObject *v62;
  char *v63;
  char *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  char v70;
  _BYTE v71[18];
  __int16 v72;
  char *v73;
  __int16 v74;
  uint64_t v75;
  __int16 v76;
  uint64_t v77;
  __int16 v78;
  uint64_t v79;
  __int16 v80;
  char *v81;
  char __s[80];
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  uint64_t v90;
  _DWORD v91[16];
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  __int128 v103;
  uint64_t v104;

  v104 = *MEMORY[0x1E0C80C00];
  if (result)
  {
    v5 = result;
    v6 = *(_DWORD *)(result + 216);
    if (v6 != -270471200)
    {
      if (v6 == 1684300900)
      {
        if (*(_QWORD *)(result + 4496) > key)
        {
          v29 = *(_QWORD *)(result + 4440);
          if (v29)
          {
            v30 = *(_QWORD *)(v29 + 16 * key);
            if (v30 != 1)
            {
              *(_QWORD *)v71 = 0;
              *(_QWORD *)&v71[8] = 0;
              LOBYTE(v68) = 0;
              v31 = *(_QWORD *)(result + 288);
              if (v31 <= v30)
              {
                v102 = 0u;
                v103 = 0u;
                v100 = 0u;
                v101 = 0u;
                v98 = 0u;
                v99 = 0u;
                v96 = 0u;
                v97 = 0u;
                v94 = 0u;
                v95 = 0u;
                v92 = 0u;
                v93 = 0u;
                memset(v91, 0, sizeof(v91));
                v12 = *__error();
                v32 = _SILogForLogForCategory(0);
                if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
                {
                  v59 = *(_QWORD *)(v5 + 288);
                  v60 = fd_name(*(_QWORD *)(v5 + 240), (char *)v91, 0x100uLL);
                  *(_DWORD *)__s = 136316418;
                  *(_QWORD *)&__s[4] = "_data_map64_get_data_entry";
                  *(_WORD *)&__s[12] = 1024;
                  *(_DWORD *)&__s[14] = 379;
                  *(_WORD *)&__s[18] = 2048;
                  *(_QWORD *)&__s[20] = v30;
                  *(_WORD *)&__s[28] = 2048;
                  *(_QWORD *)&__s[30] = v59;
                  *(_WORD *)&__s[38] = 2048;
                  *(_QWORD *)&__s[40] = v5;
                  *(_WORD *)&__s[48] = 2080;
                  *(_QWORD *)&__s[50] = v60;
                  v16 = "%s:%d: invalid data offset 0x%lx 0x%lx %p %s";
                  goto LABEL_62;
                }
              }
              else
              {
                data_entry_restore(result + 272, v30, v31, (unsigned int *)v71, &v68);
                if (!(_BYTE)v68)
                {
                  if (a3)
                    *a3 = (*(_DWORD *)v71 - *(_DWORD *)(v5 + 220));
                  if (*(_QWORD *)(v5 + 4552))
                  {
                    os_unfair_lock_lock((os_unfair_lock_t)(v5 + 4544));
                    v66 = *(_QWORD *)(v5 + 4552);
                    if (v66)
                      bit_vector_set_5272(v66, key);
                    os_unfair_lock_unlock((os_unfair_lock_t)(v5 + 4544));
                  }
                  v50 = *(_QWORD *)&v71[8];
                  return v50 + *(unsigned int *)(v5 + 220);
                }
                v102 = 0u;
                v103 = 0u;
                v100 = 0u;
                v101 = 0u;
                v98 = 0u;
                v99 = 0u;
                v96 = 0u;
                v97 = 0u;
                v94 = 0u;
                v95 = 0u;
                v92 = 0u;
                v93 = 0u;
                memset(v91, 0, sizeof(v91));
                v12 = *__error();
                v32 = _SILogForLogForCategory(0);
                if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
                {
                  v33 = fd_name(*(_QWORD *)(v5 + 240), (char *)v91, 0x100uLL);
                  v34 = *(_QWORD *)(v5 + 288);
                  *(_DWORD *)__s = 136316418;
                  *(_QWORD *)&__s[4] = "_data_map64_get_data_entry";
                  *(_WORD *)&__s[12] = 1024;
                  *(_DWORD *)&__s[14] = 375;
                  *(_WORD *)&__s[18] = 2080;
                  *(_QWORD *)&__s[20] = v33;
                  *(_WORD *)&__s[28] = 2048;
                  *(_QWORD *)&__s[30] = v30;
                  *(_WORD *)&__s[38] = 2048;
                  *(_QWORD *)&__s[40] = v34;
                  *(_WORD *)&__s[48] = 2048;
                  *(_QWORD *)&__s[50] = *(unsigned int *)v71;
                  v16 = "%s:%d: data_entry_restore failure: %s off: 0x%lx end: 0x%lx sz: 0x%lx";
LABEL_62:
                  v17 = __s;
                  v18 = v32;
                  v19 = 58;
                  goto LABEL_63;
                }
              }
LABEL_33:
              v42 = __error();
              result = 0;
              *v42 = v12;
              return result;
            }
          }
          return 0;
        }
        v102 = 0u;
        v103 = 0u;
        v100 = 0u;
        v101 = 0u;
        v98 = 0u;
        v99 = 0u;
        v96 = 0u;
        v97 = 0u;
        v94 = 0u;
        v95 = 0u;
        v92 = 0u;
        v93 = 0u;
        memset(v91, 0, sizeof(v91));
        v21 = *__error();
        v35 = _SILogForLogForCategory(0);
        if (!os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
          goto LABEL_29;
        v36 = *(_QWORD *)(v5 + 4496);
        v37 = fd_name(*(_QWORD *)(v5 + 240), (char *)v91, 0x100uLL);
        *(_DWORD *)__s = 136316418;
        *(_QWORD *)&__s[4] = "_data_map64_get_offset_entry";
        *(_WORD *)&__s[12] = 1024;
        *(_DWORD *)&__s[14] = 362;
        *(_WORD *)&__s[18] = 2048;
        *(_QWORD *)&__s[20] = key;
        *(_WORD *)&__s[28] = 2048;
        *(_QWORD *)&__s[30] = v36;
        *(_WORD *)&__s[38] = 2048;
        *(_QWORD *)&__s[40] = v5;
        *(_WORD *)&__s[48] = 2080;
        *(_QWORD *)&__s[50] = v37;
        v26 = "%s:%d: invalid data id %lld max %lld %p %s";
        v27 = v35;
        v28 = 58;
        goto LABEL_57;
      }
      if (v6 == 842150450)
      {
        if (*(_DWORD *)(result + 364) > key)
        {
          v7 = *(_QWORD *)(result + 320);
          if (v7)
          {
            v8 = *(unsigned int *)(v7 + 4 * key);
            if ((_DWORD)v8 != 1)
            {
              v68 = 0;
              v69 = 0;
              v70 = 0;
              v9 = *(_DWORD *)(result + 296);
              if (v9 > v8)
              {
                data_entry_restore_12001(*(_QWORD *)(result + 288), v8, v9, (uint64_t)&v68, &v70);
                if (v70)
                {
                  v10 = 0;
                  v90 = 0;
                  v88 = 0u;
                  v89 = 0u;
                  v86 = 0u;
                  v87 = 0u;
                  v84 = 0u;
                  v85 = 0u;
                  v83 = 0u;
                  memset(__s, 0, sizeof(__s));
                  do
                  {
                    if (v8 + v10 >= (unint64_t)*(unsigned int *)(v5 + 296))
                      break;
                    v11 = strlen(__s);
                    sprintf(&__s[v11], "%d ", *(unsigned __int8 *)(*(_QWORD *)(v5 + 288) + v8 + v10++));
                  }
                  while (v10 != 5);
                  v102 = 0u;
                  v103 = 0u;
                  v100 = 0u;
                  v101 = 0u;
                  v98 = 0u;
                  v99 = 0u;
                  v96 = 0u;
                  v97 = 0u;
                  v94 = 0u;
                  v95 = 0u;
                  v92 = 0u;
                  v93 = 0u;
                  memset(v91, 0, sizeof(v91));
                  v12 = *__error();
                  v13 = _SILogForLogForCategory(0);
                  if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
                    goto LABEL_33;
                  v14 = fd_name(*(_QWORD *)(v5 + 240), (char *)v91, 0x100uLL);
                  v15 = *(unsigned int *)(v5 + 296);
                  *(_DWORD *)v71 = 136316674;
                  *(_QWORD *)&v71[4] = "_data_map32_get_data_entry";
                  *(_WORD *)&v71[12] = 1024;
                  *(_DWORD *)&v71[14] = 441;
                  v72 = 2080;
                  v73 = v14;
                  v74 = 2048;
                  v75 = v8;
                  v76 = 2048;
                  v77 = v15;
                  v78 = 2048;
                  v79 = v68;
                  v80 = 2080;
                  v81 = __s;
                  v16 = "%s:%d: data_entry_restore failure: %s off: 0x%lx end: 0x%lx sz: 0x%lx sz bytes: %s";
                  v17 = v71;
                  v18 = v13;
                  v19 = 68;
                  goto LABEL_63;
                }
                if (a3)
                  *a3 = (v68 - *(_DWORD *)(v5 + 220));
                if (*(_QWORD *)(v5 + 424))
                {
                  os_unfair_lock_lock((os_unfair_lock_t)(v5 + 420));
                  v65 = *(_QWORD *)(v5 + 424);
                  if (v65)
                    bit_vector_set_9027(v65, key);
                  os_unfair_lock_unlock((os_unfair_lock_t)(v5 + 420));
                }
                v50 = v69;
                return v50 + *(unsigned int *)(v5 + 220);
              }
              v102 = 0u;
              v103 = 0u;
              v100 = 0u;
              v101 = 0u;
              v98 = 0u;
              v99 = 0u;
              v96 = 0u;
              v97 = 0u;
              v94 = 0u;
              v95 = 0u;
              v92 = 0u;
              v93 = 0u;
              memset(v91, 0, sizeof(v91));
              v12 = *__error();
              v32 = _SILogForLogForCategory(0);
              if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
              {
                v40 = *(unsigned int *)(v5 + 296);
                v41 = fd_name(*(_QWORD *)(v5 + 240), (char *)v91, 0x100uLL);
                *(_DWORD *)__s = 136316418;
                *(_QWORD *)&__s[4] = "_data_map32_get_data_entry";
                *(_WORD *)&__s[12] = 1024;
                *(_DWORD *)&__s[14] = 445;
                *(_WORD *)&__s[18] = 2048;
                *(_QWORD *)&__s[20] = v8;
                *(_WORD *)&__s[28] = 2048;
                *(_QWORD *)&__s[30] = v40;
                *(_WORD *)&__s[38] = 2048;
                *(_QWORD *)&__s[40] = v5;
                *(_WORD *)&__s[48] = 2080;
                *(_QWORD *)&__s[50] = v41;
                v16 = "%s:%d: invalid data offset 0x%lx 0x%lx %p %s";
                goto LABEL_62;
              }
              goto LABEL_33;
            }
          }
          return 0;
        }
        v102 = 0u;
        v103 = 0u;
        v100 = 0u;
        v101 = 0u;
        v98 = 0u;
        v99 = 0u;
        v96 = 0u;
        v97 = 0u;
        v94 = 0u;
        v95 = 0u;
        v92 = 0u;
        v93 = 0u;
        memset(v91, 0, sizeof(v91));
        v21 = *__error();
        v38 = _SILogForLogForCategory(0);
        if (!os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
        {
LABEL_29:
          v39 = __error();
          result = 0;
          *v39 = v21;
          return result;
        }
        v55 = *(_DWORD *)(v5 + 364);
        v56 = fd_name(*(_QWORD *)(v5 + 240), (char *)v91, 0x100uLL);
        *(_DWORD *)__s = 136316418;
        *(_QWORD *)&__s[4] = "_data_map32_get_offset_entry";
        *(_WORD *)&__s[12] = 1024;
        *(_DWORD *)&__s[14] = 421;
        *(_WORD *)&__s[18] = 1024;
        *(_DWORD *)&__s[20] = key;
        *(_WORD *)&__s[24] = 1024;
        *(_DWORD *)&__s[26] = v55;
        *(_WORD *)&__s[30] = 2048;
        *(_QWORD *)&__s[32] = v5;
        *(_WORD *)&__s[40] = 2080;
        *(_QWORD *)&__s[42] = v56;
        v26 = "%s:%d: invalid data id %d max %d %p %s";
        v27 = v38;
        v28 = 50;
LABEL_57:
        _os_log_error_impl(&dword_1B8270000, v27, OS_LOG_TYPE_ERROR, v26, (uint8_t *)__s, v28);
        goto LABEL_29;
      }
      return 0;
    }
    if (*(_QWORD *)(result + 376) <= key || (v20 = *(_QWORD *)(result + 288), (unint64_t)(v20 + 1) <= 1))
    {
      v102 = 0u;
      v103 = 0u;
      v100 = 0u;
      v101 = 0u;
      v98 = 0u;
      v99 = 0u;
      v96 = 0u;
      v97 = 0u;
      v94 = 0u;
      v95 = 0u;
      v92 = 0u;
      v93 = 0u;
      memset(v91, 0, sizeof(v91));
      v21 = *__error();
      v22 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        goto LABEL_29;
      v23 = *(_QWORD *)(v5 + 376);
      v24 = *(_QWORD *)(v5 + 288);
      v25 = fd_name(*(_QWORD *)(v5 + 240), (char *)v91, 0x100uLL);
      *(_DWORD *)__s = 136316674;
      *(_QWORD *)&__s[4] = "_data_map_ext_get_offset_entry";
      *(_WORD *)&__s[12] = 1024;
      *(_DWORD *)&__s[14] = 409;
      *(_WORD *)&__s[18] = 2048;
      *(_QWORD *)&__s[20] = key;
      *(_WORD *)&__s[28] = 2048;
      *(_QWORD *)&__s[30] = v23;
      *(_WORD *)&__s[38] = 2048;
      *(_QWORD *)&__s[40] = v5;
      *(_WORD *)&__s[48] = 2048;
      *(_QWORD *)&__s[50] = v24;
      *(_WORD *)&__s[58] = 2080;
      *(_QWORD *)&__s[60] = v25;
      v26 = "%s:%d: invalid data id %lld max %lld %p map: %p %s";
      v27 = v22;
      v28 = 68;
      goto LABEL_57;
    }
    v43 = v20 + 24 * key;
    v44 = *(_QWORD *)v43;
    if (*(_QWORD *)v43 == -2)
      return 0;
    *(_QWORD *)v71 = 0;
    *(_QWORD *)&v71[8] = 0;
    if (v44 == -1)
    {
      v51 = *(const __CFDictionary **)(result + 480);
      if (!v51)
      {
        v102 = 0u;
        v103 = 0u;
        v100 = 0u;
        v101 = 0u;
        v98 = 0u;
        v99 = 0u;
        v96 = 0u;
        v97 = 0u;
        v94 = 0u;
        v95 = 0u;
        v92 = 0u;
        v93 = 0u;
        memset(v91, 0, sizeof(v91));
        v57 = *__error();
        v58 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
        {
          v63 = fd_name(*(_QWORD *)(v5 + 240), (char *)v91, 0x100uLL);
          *(_DWORD *)__s = 136316162;
          *(_QWORD *)&__s[4] = "_data_map_ext_get_data_entry";
          *(_WORD *)&__s[12] = 1024;
          *(_DWORD *)&__s[14] = 449;
          *(_WORD *)&__s[18] = 2048;
          *(_QWORD *)&__s[20] = -1;
          *(_WORD *)&__s[28] = 2048;
          *(_QWORD *)&__s[30] = v5;
          *(_WORD *)&__s[38] = 2080;
          *(_QWORD *)&__s[40] = v63;
          _os_log_error_impl(&dword_1B8270000, v58, OS_LOG_TYPE_ERROR, "%s:%d: invalid data offset 0x%lx %p %s", (uint8_t *)__s, 0x30u);
        }
        *__error() = v57;
        fd_name(*(_QWORD *)(v5 + 240), (char *)v91, 0x100uLL);
        si_analytics_log_2064("(2)invalid data offset 0x%lx %p %s");
        return 0;
      }
      Value = (const __CFData *)CFDictionaryGetValue(v51, (const void *)key);
      if (!Value)
      {
        v102 = 0u;
        v103 = 0u;
        v100 = 0u;
        v101 = 0u;
        v98 = 0u;
        v99 = 0u;
        v96 = 0u;
        v97 = 0u;
        v94 = 0u;
        v95 = 0u;
        v92 = 0u;
        v93 = 0u;
        memset(v91, 0, sizeof(v91));
        v61 = *__error();
        v62 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
        {
          v64 = fd_name(*(_QWORD *)(v5 + 240), (char *)v91, 0x100uLL);
          *(_DWORD *)__s = 136316162;
          *(_QWORD *)&__s[4] = "_data_map_ext_get_data_entry";
          *(_WORD *)&__s[12] = 1024;
          *(_DWORD *)&__s[14] = 443;
          *(_WORD *)&__s[18] = 2048;
          *(_QWORD *)&__s[20] = -1;
          *(_WORD *)&__s[28] = 2048;
          *(_QWORD *)&__s[30] = v5;
          *(_WORD *)&__s[38] = 2080;
          *(_QWORD *)&__s[40] = v64;
          _os_log_error_impl(&dword_1B8270000, v62, OS_LOG_TYPE_ERROR, "%s:%d: invalid data offset 0x%lx %p %s", (uint8_t *)__s, 0x30u);
        }
        *__error() = v61;
        fd_name(*(_QWORD *)(v5 + 240), (char *)v91, 0x100uLL);
        si_analytics_log_2064("(1)invalid data offset 0x%lx %p %s");
        return 0;
      }
      v53 = Value;
      v49 = CFDataGetLength(Value) - *(_DWORD *)(v5 + 220);
      *(_DWORD *)v71 = v49;
      *(_QWORD *)&v71[8] = &CFDataGetBytePtr(v53)[*(unsigned int *)(v5 + 220)];
      CFDataGetBytePtr(v53);
      __memcpy_chk();
    }
    else
    {
      v46 = *(_DWORD *)(v43 + 8);
      v45 = *(_DWORD *)(v43 + 12);
      v47 = *(_QWORD *)(result + 472);
      *(_DWORD *)__s = 0;
      contentindex_for_id = si_get_contentindex_for_id(v47, v46);
      LODWORD(v68) = 0;
      if (!contentindex_for_id)
      {
        v12 = *__error();
        v54 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
        {
          v91[0] = 136316418;
          *(_QWORD *)&v91[1] = "data_entry_restore";
          LOWORD(v91[3]) = 1024;
          *(_DWORD *)((char *)&v91[3] + 2) = 389;
          HIWORD(v91[4]) = 2048;
          *(_QWORD *)&v91[5] = key;
          LOWORD(v91[7]) = 1024;
          *(_DWORD *)((char *)&v91[7] + 2) = v46;
          HIWORD(v91[8]) = 2048;
          *(_QWORD *)&v91[9] = v44;
          LOWORD(v91[11]) = 1024;
          *(_DWORD *)((char *)&v91[11] + 2) = v45;
          v16 = "%s:%d: data id %lld invalid index_id %u offset 0x%llx meta 0x%x";
          v17 = (char *)v91;
          v18 = v54;
          v19 = 50;
LABEL_63:
          _os_log_error_impl(&dword_1B8270000, v18, OS_LOG_TYPE_ERROR, v16, (uint8_t *)v17, v19);
          goto LABEL_33;
        }
        goto LABEL_33;
      }
      *(_QWORD *)&v71[8] = ContentIndexGetDataForId(*(_QWORD *)(contentindex_for_id + 4896), v44, v45, (uint64_t)&v68, (uint64_t)__s);
      v49 = *(_DWORD *)__s;
      *(_DWORD *)v71 = *(_DWORD *)__s;
      *(_DWORD *)&v71[4] = v68;
    }
    if (a3)
      *a3 = v49;
    if (*(_QWORD *)(v5 + 448))
    {
      os_unfair_lock_lock((os_unfair_lock_t)(v5 + 440));
      v67 = *(_QWORD *)(v5 + 448);
      if (v67)
        bit_vector_set_5272(v67, key);
      os_unfair_lock_unlock((os_unfair_lock_t)(v5 + 440));
    }
    return *(_QWORD *)&v71[8];
  }
  return result;
}

uint64_t data_map_set_offset_for_id(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t *v5;
  uint64_t v10;
  int v11;
  NSObject *v12;
  _BOOL4 v13;
  __CFDictionary *v14;
  uint64_t v15;
  _QWORD *v16;
  int v17;
  NSObject *v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  int v26;
  const char *v27;
  __int16 v28;
  int v29;
  __int16 v30;
  unint64_t v31;
  __int16 v32;
  uint64_t v33;
  __int16 v34;
  uint64_t *v35;
  __int16 v36;
  char *v37;
  __int16 v38;
  char *v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  if (result)
  {
    v5 = (uint64_t *)result;
    if (*(_DWORD *)(result + 216) == -270471200)
    {
      _data_map_ext_wrlock(result);
      if (!a5)
      {
        if (v5[47] > a2 && (v10 = v5[36], (unint64_t)(v10 + 1) > 1))
        {
          v19 = (uint64_t *)(v10 + 24 * a2);
          v20 = *v19;
          *v19 = a3;
          v19[1] = a4;
          v13 = v20 == -1;
        }
        else
        {
          v54 = 0u;
          v55 = 0u;
          v52 = 0u;
          v53 = 0u;
          v50 = 0u;
          v51 = 0u;
          v48 = 0u;
          v49 = 0u;
          v46 = 0u;
          v47 = 0u;
          v44 = 0u;
          v45 = 0u;
          v42 = 0u;
          v43 = 0u;
          v40 = 0u;
          v41 = 0u;
          v11 = *__error();
          v12 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
          {
            v23 = v5[47];
            v24 = v5[36];
            v25 = fd_name(v5[30], (char *)&v40, 0x100uLL);
            v26 = 136316674;
            v27 = "_data_map_ext_get_offset_entry";
            v28 = 1024;
            v29 = 409;
            v30 = 2048;
            v31 = a2;
            v32 = 2048;
            v33 = v23;
            v34 = 2048;
            v35 = v5;
            v36 = 2048;
            v37 = (char *)v24;
            v38 = 2080;
            v39 = v25;
            _os_log_error_impl(&dword_1B8270000, v12, OS_LOG_TYPE_ERROR, "%s:%d: invalid data id %lld max %lld %p map: %p %s", (uint8_t *)&v26, 0x44u);
          }
          *__error() = v11;
          v13 = 1;
        }
        v14 = (__CFDictionary *)v5[60];
        if (v14 && v13)
          CFDictionaryRemoveValue(v14, (const void *)a2);
      }
      if (v5[37])
      {
        if (v5[47] <= a2
          || (v15 = v5[39], (unint64_t)(v15 + 1) < 2)
          || a2 >= v5[40] / 0x18uLL
          || a2 >= v5[38] / 0x18uLL)
        {
          v54 = 0u;
          v55 = 0u;
          v52 = 0u;
          v53 = 0u;
          v50 = 0u;
          v51 = 0u;
          v48 = 0u;
          v49 = 0u;
          v46 = 0u;
          v47 = 0u;
          v44 = 0u;
          v45 = 0u;
          v42 = 0u;
          v43 = 0u;
          v40 = 0u;
          v41 = 0u;
          v17 = *__error();
          v18 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          {
            v21 = v5[47];
            v22 = fd_name(v5[30], (char *)&v40, 0x100uLL);
            v26 = 136316418;
            v27 = "_data_map_ext_get_clone_offset_entry";
            v28 = 1024;
            v29 = 424;
            v30 = 2048;
            v31 = a2;
            v32 = 2048;
            v33 = v21;
            v34 = 2048;
            v35 = v5;
            v36 = 2080;
            v37 = v22;
            _os_log_error_impl(&dword_1B8270000, v18, OS_LOG_TYPE_ERROR, "%s:%d: invalid data id %lld max %lld %p %s", (uint8_t *)&v26, 0x3Au);
          }
          *__error() = v17;
        }
        else if (v15)
        {
          v16 = (_QWORD *)(v15 + 24 * a2);
          *v16 = a3;
          v16[1] = a4;
        }
      }
      return _data_map_ext_unlock((uint64_t)v5);
    }
  }
  return result;
}

uint64_t data_map_id_insert(uint64_t result, char *a2, unint64_t a3)
{
  int v3;

  if (result)
  {
    v3 = *(_DWORD *)(result + 216);
    switch(v3)
    {
      case -270471200:
        return _data_map_ext_get_data_id(result, *(_DWORD *)(result + 220), a2, a3, 1);
      case 1684300900:
        return _data_map64_get_data_id(result, *(_DWORD *)(result + 220), a2, a3, 1);
      case 842150450:
        return _data_map32_get_data_id(result, *(_DWORD *)(result + 220), a2, a3, 1);
      default:
        return 0;
    }
  }
  return result;
}

uint64_t data_map_get_extra_with_key(uint64_t a1, uint64_t a2, size_t a3, _BYTE *a4)
{
  int v4;

  v4 = *(_DWORD *)(a1 + 216);
  if (v4 == 1684300900)
    return data_map64_get_extra_with_key(a1, (const void *)a2, a3, a4);
  if (v4 == -270471200)
    return data_map_ext_get_extra_with_key(a1, a2, a3, a4);
  return data_map32_get_extra_with_key(a1, (unsigned __int16 *)a2, a3, a4);
}

uint64_t data_map_get_data_entry(uint64_t result, uint64_t a2, unint64_t a3, _BYTE *a4, int a5)
{
  uint64_t v5;
  unsigned int v7;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  size_t v16;
  int v17;
  NSObject *v18;
  int *v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  NSObject *v23;
  int v24;
  NSObject *v25;
  int *v26;
  unsigned int v27;
  int v28;
  char *v29;
  uint64_t v30;
  char *v31;
  char *v32;
  uint64_t v33;
  char *v34;
  char *v35;
  const char *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  char v42;
  uint8_t buf[4];
  const char *v44;
  __int16 v45;
  int v46;
  __int16 v47;
  char *v48;
  __int16 v49;
  uint64_t v50;
  __int16 v51;
  uint64_t v52;
  __int16 v53;
  uint64_t v54;
  __int16 v55;
  char *v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  char __s[64];
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  uint64_t v82;
  uint64_t v83;

  v5 = result;
  v83 = *MEMORY[0x1E0C80C00];
  if (!a2)
  {
    *(_QWORD *)result = 0;
    *(_QWORD *)(result + 8) = 0;
    *(_QWORD *)(result + 16) = 0;
    return result;
  }
  v7 = a3;
  v9 = *(_DWORD *)(a2 + 216);
  if (v9 == -270471200)
    return data_map_ext_get_data_entry(result, a2, a3, a4, a5);
  if (v9 == 1684300900)
  {
    *(_QWORD *)(result + 16) = 0;
    *a4 = 0;
    *(_QWORD *)result = 0;
    *(_QWORD *)(result + 8) = 0;
    *(_DWORD *)(result + 20) = *(_DWORD *)(a2 + 220);
    *(_QWORD *)&v57 = 0;
    result = data_map64_get_data(a2, a3, &v57);
    if (!result)
      return result;
    *a4 = 1;
    v10 = *(_DWORD *)(a2 + 220);
    *(_DWORD *)(v5 + 20) = v10;
    v11 = v57;
    *(_QWORD *)v5 = result;
    *(_QWORD *)(v5 + 8) = v11;
    if (!v10)
      return result;
    return __memcpy_chk();
  }
  if (v9 != 842150450)
  {
    v34 = __si_assert_copy_extra_268();
    v35 = v34;
    v36 = "";
    if (v34)
      v36 = v34;
    __message_assert("%s:%u: failed assertion '%s' %s ", "data_map.c", 345, "data_map_is_32(data_map)", v36);
    free(v35);
    if (__valid_fs(-1))
      v37 = 2989;
    else
      v37 = 3072;
    *(_DWORD *)v37 = -559038737;
    abort();
  }
  *(_QWORD *)(result + 16) = 0;
  *a4 = 0;
  *(_QWORD *)result = 0;
  *(_QWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 20) = *(_DWORD *)(a2 + 220);
  v39 = 0;
  if (a5)
  {
    if (*(_DWORD *)(a2 + 364) <= a3)
    {
      v71 = 0u;
      v72 = 0u;
      v69 = 0u;
      v70 = 0u;
      v67 = 0u;
      v68 = 0u;
      v65 = 0u;
      v66 = 0u;
      v63 = 0u;
      v64 = 0u;
      v61 = 0u;
      v62 = 0u;
      v59 = 0u;
      v60 = 0u;
      v57 = 0u;
      v58 = 0u;
      v22 = *__error();
      v23 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        v28 = *(_DWORD *)(a2 + 364);
        v29 = fd_name(*(_QWORD *)(a2 + 240), (char *)&v57, 0x100uLL);
        *(_DWORD *)__s = 136316418;
        *(_QWORD *)&__s[4] = "_data_map32_get_offset_entry";
        *(_WORD *)&__s[12] = 1024;
        *(_DWORD *)&__s[14] = 421;
        *(_WORD *)&__s[18] = 1024;
        *(_DWORD *)&__s[20] = v7;
        *(_WORD *)&__s[24] = 1024;
        *(_DWORD *)&__s[26] = v28;
        *(_WORD *)&__s[30] = 2048;
        *(_QWORD *)&__s[32] = a2;
        *(_WORD *)&__s[40] = 2080;
        *(_QWORD *)&__s[42] = v29;
        _os_log_error_impl(&dword_1B8270000, v23, OS_LOG_TYPE_ERROR, "%s:%d: invalid data id %d max %d %p %s", (uint8_t *)__s, 0x32u);
      }
      result = (uint64_t)__error();
      *(_DWORD *)result = v22;
      return result;
    }
    v12 = *(_QWORD *)(a2 + 320);
    if (!v12)
      return result;
    v13 = *(unsigned int *)(v12 + 4 * a3);
    if ((_DWORD)v13 == 1)
      return result;
    v40 = 0;
    v41 = 0;
    v42 = 0;
    v14 = *(_DWORD *)(a2 + 296);
    if (v14 <= v13)
    {
      v71 = 0u;
      v72 = 0u;
      v69 = 0u;
      v70 = 0u;
      v67 = 0u;
      v68 = 0u;
      v65 = 0u;
      v66 = 0u;
      v63 = 0u;
      v64 = 0u;
      v61 = 0u;
      v62 = 0u;
      v59 = 0u;
      v60 = 0u;
      v57 = 0u;
      v58 = 0u;
      v24 = *__error();
      v25 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      {
        v30 = *(unsigned int *)(a2 + 296);
        v31 = fd_name(*(_QWORD *)(a2 + 240), (char *)&v57, 0x100uLL);
        *(_DWORD *)__s = 136316418;
        *(_QWORD *)&__s[4] = "_data_map32_get_data_entry";
        *(_WORD *)&__s[12] = 1024;
        *(_DWORD *)&__s[14] = 445;
        *(_WORD *)&__s[18] = 2048;
        *(_QWORD *)&__s[20] = v13;
        *(_WORD *)&__s[28] = 2048;
        *(_QWORD *)&__s[30] = v30;
        *(_WORD *)&__s[38] = 2048;
        *(_QWORD *)&__s[40] = a2;
        *(_WORD *)&__s[48] = 2080;
        *(_QWORD *)&__s[50] = v31;
        _os_log_error_impl(&dword_1B8270000, v25, OS_LOG_TYPE_ERROR, "%s:%d: invalid data offset 0x%lx 0x%lx %p %s", (uint8_t *)__s, 0x3Au);
      }
      v26 = __error();
      result = 0;
      *v26 = v24;
    }
    else
    {
      data_entry_restore_12001(*(_QWORD *)(a2 + 288), v13, v14, (uint64_t)&v40, &v42);
      if (v42)
      {
        v15 = 0;
        v82 = 0;
        v80 = 0u;
        v81 = 0u;
        v78 = 0u;
        v79 = 0u;
        v76 = 0u;
        v77 = 0u;
        v74 = 0u;
        v75 = 0u;
        memset(__s, 0, sizeof(__s));
        do
        {
          if (v13 + v15 >= (unint64_t)*(unsigned int *)(a2 + 296))
            break;
          v16 = strlen(__s);
          sprintf(&__s[v16], "%d ", *(unsigned __int8 *)(*(_QWORD *)(a2 + 288) + v13 + v15++));
        }
        while (v15 != 5);
        v71 = 0u;
        v72 = 0u;
        v69 = 0u;
        v70 = 0u;
        v67 = 0u;
        v68 = 0u;
        v65 = 0u;
        v66 = 0u;
        v63 = 0u;
        v64 = 0u;
        v61 = 0u;
        v62 = 0u;
        v59 = 0u;
        v60 = 0u;
        v57 = 0u;
        v58 = 0u;
        v17 = *__error();
        v18 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          v32 = fd_name(*(_QWORD *)(a2 + 240), (char *)&v57, 0x100uLL);
          v33 = *(unsigned int *)(a2 + 296);
          *(_DWORD *)buf = 136316674;
          v44 = "_data_map32_get_data_entry";
          v45 = 1024;
          v46 = 441;
          v47 = 2080;
          v48 = v32;
          v49 = 2048;
          v50 = v13;
          v51 = 2048;
          v52 = v33;
          v53 = 2048;
          v54 = v40;
          v55 = 2080;
          v56 = __s;
          _os_log_error_impl(&dword_1B8270000, v18, OS_LOG_TYPE_ERROR, "%s:%d: data_entry_restore failure: %s off: 0x%lx end: 0x%lx sz: 0x%lx sz bytes: %s", buf, 0x44u);
        }
        v19 = __error();
        result = 0;
        *v19 = v17;
      }
      else
      {
        v27 = *(_DWORD *)(a2 + 220);
        v39 = v40 - v27;
        if (*(_QWORD *)(a2 + 424))
        {
          os_unfair_lock_lock((os_unfair_lock_t)(a2 + 420));
          v38 = *(_QWORD *)(a2 + 424);
          if (v38)
            bit_vector_set_9027(v38, v7);
          os_unfair_lock_unlock((os_unfair_lock_t)(a2 + 420));
          v27 = *(_DWORD *)(a2 + 220);
        }
        result = v41 + v27;
      }
    }
  }
  else
  {
    result = data_map32_get_data(a2, a3, &v39);
  }
  if (result)
  {
    *a4 = 1;
    v20 = *(unsigned int *)(a2 + 220);
    v21 = v39 - v20;
    *(_QWORD *)v5 = result;
    *(_QWORD *)(v5 + 8) = v21;
    *(_DWORD *)(v5 + 20) = v20;
    if ((_DWORD)v20)
      return __memcpy_chk();
  }
  return result;
}

uint64_t _data_map_sync_header(uint64_t result)
{
  int v1;

  if (result)
  {
    v1 = *(_DWORD *)(result + 216);
    switch(v1)
    {
      case -270471200:
        return _data_map_ext_sync_header(result);
      case 1684300900:
        return _data_map64_sync_header(result);
      case 842150450:
        return _data_map32_sync_header(result, 1);
    }
  }
  return result;
}

uint64_t _data_map_version(uint64_t result)
{
  int v1;

  if (result)
  {
    v1 = *(_DWORD *)(result + 216);
    if (v1 == -270471200 || v1 == 1684300900 || v1 == 842150450)
      return *(unsigned int *)(*(_QWORD *)(result + 264) + 8);
    else
      return 0;
  }
  return result;
}

BOOL _data_map_version_is_current(_BOOL8 result)
{
  int v1;

  if (result)
  {
    v1 = *(_DWORD *)(result + 216);
    if (v1 == -270471200 || v1 == 1684300900)
      return *(_DWORD *)(*(_QWORD *)(result + 264) + 8) == 14;
    else
      return v1 == 842150450 && *(_DWORD *)(*(_QWORD *)(result + 264) + 8) > 0xAu;
  }
  return result;
}

uint64_t _data_map_version_update(uint64_t result)
{
  uint64_t v1;
  int v2;
  uint64_t v4;
  char *v5;
  char *v6;
  const char *v7;

  if (result)
  {
    v1 = result;
    v2 = *(_DWORD *)(result + 216);
    if (v2 != -270471200 && v2 != 1684300900)
    {
      if (v2 != 842150450)
      {
        v5 = __si_assert_copy_extra_268();
        v6 = v5;
        if (v5)
          v7 = v5;
        else
          v7 = "";
        __message_assert("%s:%u: Unexpected code path %s ", "data_map.c", 363, v7);
        free(v6);
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      v4 = *(_QWORD *)(result + 264);
      if (*(_DWORD *)(v4 + 8) <= 0xAu)
      {
        *(_DWORD *)(v4 + 8) = 12;
        fd_pwrite(*(_QWORD *)(result + 240), v4, 0x38uLL, 0);
        return msync(*(void **)(v1 + 288), *(unsigned int *)(v1 + 296), 16);
      }
    }
  }
  return result;
}

uint64_t __data_maps_garbage_collect_setup_block_invoke(uint64_t a1, uint64_t a2)
{
  int v4;
  CFIndex v5;
  os_unfair_lock_s *v6;
  uint64_t result;
  CFIndex v8;
  CFIndex v9;

  if (!a2)
    return 0xFFFFFFFFLL;
  v4 = *(_DWORD *)(a2 + 216);
  switch(v4)
  {
    case -270471200:
      _data_map_ext_wrlock(a2);
      v8 = *(_QWORD *)(a2 + 376);
      v6 = (os_unfair_lock_s *)(a2 + 440);
      os_unfair_lock_lock((os_unfair_lock_t)(a2 + 440));
      if (*(_QWORD *)(a2 + 448))
      {
        os_unfair_lock_unlock((os_unfair_lock_t)(a2 + 440));
        _data_map_ext_unlock(a2);
        return 22;
      }
      *(_QWORD *)(a2 + 448) = bit_vector_create(v8);
      break;
    case 1684300900:
      _data_map64_wrlock(a2);
      v9 = *(_QWORD *)(a2 + 4496);
      v6 = (os_unfair_lock_s *)(a2 + 4544);
      os_unfair_lock_lock((os_unfair_lock_t)(a2 + 4544));
      if (*(_QWORD *)(a2 + 4552))
      {
        os_unfair_lock_unlock((os_unfair_lock_t)(a2 + 4544));
        _data_map64_unlock(a2);
        return 22;
      }
      *(_QWORD *)(a2 + 4552) = bit_vector_create(v9);
      break;
    case 842150450:
      _data_map32_wrlock(a2);
      v5 = *(unsigned int *)(a2 + 364);
      v6 = (os_unfair_lock_s *)(a2 + 420);
      os_unfair_lock_lock((os_unfair_lock_t)(a2 + 420));
      if (*(_QWORD *)(a2 + 424))
      {
        os_unfair_lock_unlock((os_unfair_lock_t)(a2 + 420));
        _data_map32_unlock(a2);
        return 22;
      }
      *(_QWORD *)(a2 + 424) = bit_vector_create(v5);
      break;
    default:
      return 0xFFFFFFFFLL;
  }
  os_unfair_lock_unlock(v6);
  result = 0;
  ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t __data_maps_garbage_collect_setup_block_invoke_2(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 32))
    _data_map_clear_seen(a2);
  _data_map_unlock(a2);
  return 0;
}

void _data_map_clear_seen(uint64_t a1)
{
  int v2;
  os_unfair_lock_s *v3;
  _QWORD *v4;
  _QWORD *v5;
  const void *v6;
  char *v7;
  char *v8;
  const char *v9;

  if (a1)
  {
    v2 = *(_DWORD *)(a1 + 216);
    switch(v2)
    {
      case -270471200:
        v3 = (os_unfair_lock_s *)(a1 + 440);
        os_unfair_lock_lock((os_unfair_lock_t)(a1 + 440));
        v4 = *(_QWORD **)(a1 + 448);
        if (v4)
        {
          v5 = (_QWORD *)(a1 + 448);
LABEL_12:
          v6 = (const void *)v4[2];
          if (v6)
            CFRelease(v6);
          free(v4);
          *v5 = 0;
        }
        break;
      case 1684300900:
        v3 = (os_unfair_lock_s *)(a1 + 4544);
        os_unfair_lock_lock((os_unfair_lock_t)(a1 + 4544));
        v4 = *(_QWORD **)(a1 + 4552);
        if (v4)
        {
          v5 = (_QWORD *)(a1 + 4552);
          goto LABEL_12;
        }
        break;
      case 842150450:
        v3 = (os_unfair_lock_s *)(a1 + 420);
        os_unfair_lock_lock((os_unfair_lock_t)(a1 + 420));
        v4 = *(_QWORD **)(a1 + 424);
        if (!v4)
          break;
        v5 = (_QWORD *)(a1 + 424);
        goto LABEL_12;
      default:
        v7 = __si_assert_copy_extra_268();
        v8 = v7;
        if (v7)
          v9 = v7;
        else
          v9 = "";
        __message_assert("%s:%u: Unexpected code path %s ", "data_map.c", 399, v9);
        free(v8);
        MEMORY[0xBAD] = -559038737;
        abort();
    }
    os_unfair_lock_unlock(v3);
  }
}

void data_maps_garbage_compact_collect_commit(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  uint64_t v9;
  BOOL v10;
  int v11;
  NSObject *v12;
  os_log_type_t v13;
  uint64_t i;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  int v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  char **v22;
  uint64_t v23;
  void *v24;
  uint64_t v25;
  uint64_t v26;
  char **v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t *v35;
  char *v36;
  void *v37;
  uint64_t v38;
  uint8_t v39[8];
  _QWORD v40[2];
  uint64_t (*v41)(uint64_t, uint64_t, int);
  void *v42;
  uint64_t v43;
  _QWORD v44[2];
  uint64_t (*v45)(uint64_t, uint64_t, int);
  void *v46;
  uint64_t *v47;
  uint64_t v48;
  char v49;
  uint64_t v50;
  uint64_t *v51;
  uint64_t v52;
  char v53;

  v6 = 0;
  v50 = 0;
  v51 = &v50;
  v52 = 0x2000000000;
  v45 = __data_maps_garbage_compact_collect_commit_block_invoke;
  v46 = &unk_1E6E34C10;
  v7 = MEMORY[0x1E0C809B0];
  v53 = 0;
  v44[0] = MEMORY[0x1E0C809B0];
  v44[1] = 0x40000000;
  v47 = &v50;
  v48 = a2;
  v49 = a3;
  do
  {
    if (v45((uint64_t)v44, *(_QWORD *)(a1 + 8 * v6), v6))
      v8 = 1;
    else
      v8 = v6 == 3;
    ++v6;
  }
  while (!v8);
  if (*((_BYTE *)v51 + 24) || (a3 & 1) != 0)
  {
    v11 = *__error();
    v12 = _SILogForLogForCategory(0);
    v13 = gSILogLevels[0] < 3;
    if (os_log_type_enabled(v12, (os_log_type_t)(gSILogLevels[0] < 3)))
    {
      *(_WORD *)v39 = 0;
      _os_log_impl(&dword_1B8270000, v12, v13, "*warn* Delete strings canceled", v39, 2u);
    }
    *__error() = v11;
  }
  else
  {
    v9 = 0;
    v40[0] = v7;
    v40[1] = 0x40000000;
    v41 = __data_maps_garbage_compact_collect_commit_block_invoke_2;
    v42 = &__block_descriptor_tmp_13_6617;
    v43 = a2;
    do
    {
      if (v41((uint64_t)v40, *(_QWORD *)(a1 + 8 * v9), v9))
        v10 = 1;
      else
        v10 = v9 == 3;
      ++v9;
    }
    while (!v10);
  }
  for (i = 0; i != 32; i += 8)
  {
    v15 = *(_QWORD *)(a1 + i);
    _data_map_clear_seen(v15);
    _data_map_unlock(v15);
  }
  v16 = 0;
  v17 = (uint64_t *)(a2 + 80);
  do
  {
    if (!*(_QWORD *)(a2 + 4208 * v16 + 8))
      goto LABEL_48;
    v18 = *(_DWORD *)(a2 + 4208 * v16);
    if (v18 == -270471200)
    {
      v33 = a2 + 4208 * v16;
      v30 = v33 + 32;
      if (*(int *)(v33 + 56) >= 1)
      {
        v34 = 0;
        v35 = v17;
        do
        {
          storageWindowReleaseImmediate(v35);
          ++v34;
          ++v35;
        }
        while (v34 < *(int *)(v30 + 24));
      }
    }
    else
    {
      if (v18 != 1684300900)
      {
        if (v18 == 842150450)
        {
          v19 = a2 + 4208 * v16;
          v20 = *(void **)(v19 + 40);
          if (v20 != (void *)-1)
            munmap(v20, *(_QWORD *)(a2 + 4208 * v16 + 80));
          v23 = *(_QWORD *)(v19 + 32);
          v22 = (char **)(v19 + 32);
          v21 = v23;
          if (v23)
          {
            _fd_unlink_with_origin(v21, 0);
            fd_release(*v22);
          }
          v24 = *(void **)(a2 + 4208 * v16 + 56);
          if (v24 != (void *)-1)
            munmap(v24, *(_QWORD *)(a2 + 4208 * v16 + 64));
          v25 = a2 + 4208 * v16;
          v28 = *(_QWORD *)(v25 + 48);
          v27 = (char **)(v25 + 48);
          v26 = v28;
          if (v28)
            goto LABEL_47;
        }
        goto LABEL_48;
      }
      v29 = a2 + 4208 * v16;
      v30 = v29 + 32;
      if (*(int *)(v29 + 56) >= 1)
      {
        v31 = 0;
        v32 = v17;
        do
        {
          storageWindowReleaseImmediate(v32);
          ++v31;
          ++v32;
        }
        while (v31 < *(int *)(v30 + 24));
      }
    }
    v36 = *(char **)v30;
    if (*(_QWORD *)v30)
    {
      _fd_unlink_with_origin(*(_QWORD *)v30, 0);
      fd_release(v36);
    }
    v37 = *(void **)(a2 + 4208 * v16 + 4184);
    if (v37 != (void *)-1)
      munmap(v37, *(_QWORD *)(a2 + 4208 * v16 + 4192));
    v38 = a2 + 4208 * v16;
    v26 = *(_QWORD *)(v38 + 4176);
    if (v26)
    {
      v27 = (char **)(v38 + 4176);
LABEL_47:
      _fd_unlink_with_origin(v26, 0);
      fd_release(*v27);
    }
LABEL_48:
    ++v16;
    v17 += 526;
  }
  while (v16 != 4);
  _Block_object_dispose(&v50, 8);
}

uint64_t __data_maps_garbage_compact_collect_commit_block_invoke(uint64_t a1, uint64_t a2, int a3)
{
  int v4;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  CFRange v14;
  CFRange v15;

  if (!a2)
    return 0xFFFFFFFFLL;
  v4 = *(_DWORD *)(a2 + 216);
  if (v4 == -270471200)
    return 0;
  v6 = *(_QWORD *)(a1 + 40);
  v7 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v8 = *(unsigned __int8 *)(a1 + 48);
  if (v4 == 1684300900)
  {
    _data_map64_wrlock(a2);
    if (!v8 && !*(_BYTE *)(v7 + 24))
    {
      if (*(_QWORD *)(v6 + 4208 * a3 + 8))
      {
        v12 = *(_QWORD *)(v6 + 4208 * a3 + 16);
        if (v12 != *(_QWORD *)(a2 + 4496))
          goto LABEL_19;
        v13 = *(_QWORD *)(v6 + 4208 * a3 + 24);
        v15.length = v12 - 1;
        v15.location = 0;
        if (v13 != CFBitVectorGetCountOfBit(*(CFBitVectorRef *)(*(_QWORD *)(a2 + 4552) + 16), v15, 1u))
          goto LABEL_19;
      }
    }
    return 0;
  }
  if (v4 != 842150450)
    return 0xFFFFFFFFLL;
  _data_map32_wrlock(a2);
  if (v8)
    return 0;
  if (*(_BYTE *)(v7 + 24))
    return 0;
  if (!*(_QWORD *)(v6 + 4208 * a3 + 8))
    return 0;
  v9 = *(unsigned int *)(a2 + 364);
  if (*(_QWORD *)(v6 + 4208 * a3 + 16) == v9)
  {
    v10 = *(_QWORD *)(v6 + 4208 * a3 + 24);
    v14.length = (v9 - 1);
    v14.location = 0;
    if (v10 == CFBitVectorGetCountOfBit(*(CFBitVectorRef *)(*(_QWORD *)(a2 + 424) + 16), v14, 1u))
      return 0;
  }
LABEL_19:
  result = 0;
  *(_BYTE *)(v7 + 24) = 1;
  return result;
}

uint64_t __data_maps_garbage_compact_collect_commit_block_invoke_2(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v5;
  int v7;
  uint64_t v8;
  const float *v9;
  uint64_t v10;
  uint64_t *v11;
  int64x2_t *v12;
  char *v13;
  int v14;
  NSObject *v15;
  os_log_type_t v16;
  _BYTE *v17;
  char *v18;
  char *v19;
  int v20;
  NSObject *v21;
  os_log_type_t v22;
  _BYTE *v23;
  uint64_t v24;
  char *v25;
  int32x2_t v26;
  uint64_t result;
  uint64_t v28;
  const double *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t *v32;
  uint64_t *v33;
  uint64_t v34;
  char *v35;
  int v36;
  NSObject *v37;
  os_log_type_t v38;
  _BYTE *v39;
  char *v40;
  int v41;
  NSObject *v42;
  os_log_type_t v43;
  _BYTE *v44;
  uint64_t v45;
  char *v46;
  int64x2_t v47;
  int v48;
  NSObject *v49;
  os_log_type_t v50;
  uint64_t v51;
  int *v52;
  uint8_t buf[4];
  uint64_t v54;
  __int16 v55;
  _BYTE *v56;
  __int16 v57;
  char *v58;
  uint8_t v59[779];
  uint8_t v60[4];
  int v61;
  __int16 v62;
  uint64_t v63;
  __int16 v64;
  int v65;
  uint64_t v66;

  v66 = *MEMORY[0x1E0C80C00];
  if (!a2)
    return 0xFFFFFFFFLL;
  v5 = *(_QWORD *)(a1 + 32);
  v7 = *(_DWORD *)(a2 + 216);
  if (v7 != -270471200)
  {
    if (v7 == 1684300900)
    {
      v28 = v5 + 4208 * a3;
      v30 = *(_QWORD *)(v28 + 8);
      v29 = (const double *)(v28 + 8);
      if (v30)
      {
        bzero(v60, 0x400uLL);
        bzero(v59, 0x400uLL);
        if (*(int *)(a2 + 296) >= 1)
        {
          v31 = 0;
          v32 = (uint64_t *)(a2 + 320);
          do
          {
            storageWindowReleaseImmediate(v32);
            ++v31;
            ++v32;
          }
          while (v31 < *(int *)(a2 + 296));
        }
        v33 = (uint64_t *)(v5 + 4208 * a3 + 32);
        munmap(*(void **)(a2 + 4440), *(_QWORD *)(a2 + 4424));
        v34 = v5 + 4208 * a3;
        *(_QWORD *)(a2 + 4440) = *(_QWORD *)(v34 + 4184);
        *(_QWORD *)(a2 + 4432) = *(_QWORD *)(v34 + 4200);
        *(_QWORD *)(v34 + 4184) = -1;
        v35 = fd_name(*(_QWORD *)(a2 + 272), (char *)v60, 0x400uLL);
        v36 = *__error();
        v37 = _SILogForLogForCategory(0);
        v38 = 2 * (gSILogLevels[0] < 4);
        if (os_log_type_enabled(v37, v38))
        {
          v39 = fd_realpath((_DWORD *)*v33, v59);
          *(_DWORD *)buf = 134218498;
          v54 = a2;
          v55 = 2080;
          v56 = v39;
          v57 = 2080;
          v58 = v35;
          _os_log_impl(&dword_1B8270000, v37, v38, "rename %p %s to %s", buf, 0x20u);
        }
        *__error() = v36;
        fd_rename(*v33, v35);
        memcpy((void *)(a2 + 272), (const void *)(v5 + 4208 * a3 + 32), 0x1030uLL);
        bzero((void *)(v5 + 4208 * a3 + 32), 0x1030uLL);
        v40 = fd_name(*(_QWORD *)(a2 + 4416), (char *)v60, 0x400uLL);
        v41 = *__error();
        v42 = _SILogForLogForCategory(0);
        v43 = 2 * (gSILogLevels[0] < 4);
        if (os_log_type_enabled(v42, v43))
        {
          v44 = fd_realpath(*(_DWORD **)(v5 + 4208 * a3 + 4176), v59);
          *(_DWORD *)buf = 134218498;
          v54 = a2;
          v55 = 2080;
          v56 = v44;
          v57 = 2080;
          v58 = v40;
          _os_log_impl(&dword_1B8270000, v42, v43, "rename %p %s to %s", buf, 0x20u);
        }
        *__error() = v41;
        v45 = v5 + 4208 * a3;
        fd_rename(*(_QWORD *)(v45 + 4176), v40);
        v46 = *(char **)(a2 + 4416);
        *(_QWORD *)(a2 + 4416) = *(_QWORD *)(v45 + 4176);
        fd_release(v46);
        *(_QWORD *)(v45 + 4176) = 0;
        v47 = (int64x2_t)vld1q_dup_f64(v29);
        *(int64x2_t *)(a2 + 4504) = vaddq_s64(*(int64x2_t *)(a2 + 4504), v47);
        *(_QWORD *)(a2 + 4520) = 0;
        _data_map64_dirty(a2);
        _data_map64_sync_data(a2);
        _data_map64_sync_header(a2);
        if (!*(_BYTE *)(a2 + 4562))
        {
          _data_map64_dirty(a2);
          *(_BYTE *)(a2 + 4562) = 1;
        }
        _data_map64_rehash(a2);
        _data_map64_sync_data(a2);
        _data_map64_sync_header(a2);
      }
      goto LABEL_25;
    }
    if (v7 == 842150450)
    {
      v8 = v5 + 4208 * a3;
      v10 = *(_QWORD *)(v8 + 8);
      v9 = (const float *)(v8 + 8);
      if (v10)
      {
        v11 = (uint64_t *)(v9 + 6);
        bzero(v60, 0x400uLL);
        bzero(v59, 0x400uLL);
        munmap(*(void **)(a2 + 288), *(unsigned int *)(a2 + 280));
        v12 = (int64x2_t *)(v5 + 4208 * a3);
        *(_QWORD *)(a2 + 288) = v12[2].i64[1];
        *(int32x2_t *)(a2 + 280) = vmovn_s64(v12[5]);
        *(_DWORD *)(a2 + 296) = v12[6].i64[0];
        v12[2].i64[1] = -1;
        munmap(*(void **)(a2 + 320), *(unsigned int *)(a2 + 312));
        *(_QWORD *)(a2 + 320) = v12[3].i64[1];
        *(_DWORD *)(a2 + 316) = v12[4].i64[1];
        v12[3].i64[1] = -1;
        v13 = fd_name(*(_QWORD *)(a2 + 272), (char *)v60, 0x400uLL);
        v14 = *__error();
        v15 = _SILogForLogForCategory(0);
        v16 = 2 * (gSILogLevels[0] < 4);
        if (os_log_type_enabled(v15, v16))
        {
          v17 = fd_realpath((_DWORD *)*v11, v59);
          *(_DWORD *)buf = 134218498;
          v54 = a2;
          v55 = 2080;
          v56 = v17;
          v57 = 2080;
          v58 = v13;
          _os_log_impl(&dword_1B8270000, v15, v16, "rename %p %s to %s", buf, 0x20u);
        }
        *__error() = v14;
        fd_rename(*v11, v13);
        v18 = *(char **)(a2 + 272);
        *(_QWORD *)(a2 + 272) = *v11;
        fd_release(v18);
        *v11 = 0;
        v19 = fd_name(*(_QWORD *)(a2 + 304), (char *)v60, 0x400uLL);
        v20 = *__error();
        v21 = _SILogForLogForCategory(0);
        v22 = 2 * (gSILogLevels[0] < 4);
        if (os_log_type_enabled(v21, v22))
        {
          v23 = fd_realpath(*(_DWORD **)(v5 + 4208 * a3 + 48), v59);
          *(_DWORD *)buf = 134218498;
          v54 = a2;
          v55 = 2080;
          v56 = v23;
          v57 = 2080;
          v58 = v19;
          _os_log_impl(&dword_1B8270000, v21, v22, "rename %p %s to %s", buf, 0x20u);
        }
        *__error() = v20;
        v24 = v5 + 4208 * a3;
        fd_rename(*(_QWORD *)(v24 + 48), v19);
        v25 = *(char **)(a2 + 304);
        *(_QWORD *)(a2 + 304) = *(_QWORD *)(v24 + 48);
        fd_release(v25);
        *(_QWORD *)(v24 + 48) = 0;
        v26 = (int32x2_t)vld1_dup_f32(v9);
        *(int32x2_t *)(a2 + 368) = vadd_s32(*(int32x2_t *)(a2 + 368), v26);
        *(_DWORD *)(a2 + 376) = 0;
        _data_map32_dirty(a2);
        _data_map32_sync_data(a2, 1);
        _data_map32_sync_header(a2, 1);
        if (!*(_BYTE *)(a2 + 434))
        {
          _data_map32_dirty(a2);
          *(_BYTE *)(a2 + 434) = 1;
        }
        _data_map32_rehash(a2);
        _data_map32_sync_data(a2, 1);
        _data_map32_sync_header(a2, 1);
      }
      goto LABEL_25;
    }
    return 0xFFFFFFFFLL;
  }
LABEL_25:
  v48 = *__error();
  v49 = _SILogForLogForCategory(0);
  v50 = 2 * (gSILogLevels[0] < 4);
  if (os_log_type_enabled(v49, v50))
  {
    v51 = *(_QWORD *)(v5 + 4208 * a3 + 8);
    *(_DWORD *)v60 = 67109632;
    v61 = v51;
    v62 = 2048;
    v63 = a2;
    v64 = 1024;
    v65 = a3;
    _os_log_impl(&dword_1B8270000, v49, v50, "Deleted %d items from %p[%d]", v60, 0x18u);
  }
  v52 = __error();
  result = 0;
  *v52 = v48;
  return result;
}

void data_map_delete_files(int a1, const char *a2, int a3)
{
  int v5;
  unsigned __int8 v6;
  char *v7;
  char *v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  char *v19;
  char *v20;
  char *v21;
  char *v22;
  char *v23;
  char *v24;
  char *v25;
  char *v26;
  char *v27;
  char *v28;
  char *v29[129];

  v29[128] = *(char **)MEMORY[0x1E0C80C00];
  v29[0] = 0;
  v5 = a3 << 23 >> 31;
  asprintf(v29, "%s%s", a2, ".buckets");
  v6 = v5 & 3;
  v7 = (char *)fd_create_protected(a1, v29[0], 2, v6);
  if (v7)
  {
    v8 = v7;
    _fd_unlink_with_origin((uint64_t)v7, 0);
    fd_release(v8);
  }
  free(v29[0]);
  asprintf(v29, "%s%s", a2, ".header");
  v9 = (char *)fd_create_protected(a1, v29[0], 514, v6);
  if (v9)
  {
    v10 = v9;
    _fd_unlink_with_origin((uint64_t)v9, 0);
    fd_release(v10);
  }
  free(v29[0]);
  asprintf(v29, "%s%s", a2, ".offsets");
  v11 = (char *)fd_create_protected(a1, v29[0], 514, v6);
  if (v11)
  {
    v12 = v11;
    _fd_unlink_with_origin((uint64_t)v11, 0);
    fd_release(v12);
  }
  free(v29[0]);
  asprintf(v29, "%s%s", a2, ".data");
  v13 = (char *)fd_create_protected(a1, v29[0], 514, v6);
  if (v13)
  {
    v14 = v13;
    _fd_unlink_with_origin((uint64_t)v13, 0);
    fd_release(v14);
  }
  free(v29[0]);
  bzero(v29, 0x400uLL);
  snprintf((char *)v29, 0x400uLL, "%s%s", a2, ".buckets");
  v15 = (char *)fd_create_protected(a1, (const char *)v29, 2, v6);
  if (v15)
  {
    v16 = v15;
    _fd_unlink_with_origin((uint64_t)v15, 0);
    fd_release(v16);
  }
  snprintf((char *)v29, 0x400uLL, "%s%s", a2, ".header");
  v17 = (char *)fd_create_protected(a1, (const char *)v29, 514, v6);
  if (v17)
  {
    v18 = v17;
    _fd_unlink_with_origin((uint64_t)v17, 0);
    fd_release(v18);
  }
  snprintf((char *)v29, 0x400uLL, "%s%s", a2, ".offsets");
  v19 = (char *)fd_create_protected(a1, (const char *)v29, 514, v6);
  if (v19)
  {
    v20 = v19;
    _fd_unlink_with_origin((uint64_t)v19, 0);
    fd_release(v20);
  }
  snprintf((char *)v29, 0x400uLL, "%s%s", a2, ".data");
  v21 = (char *)fd_create_protected(a1, (const char *)v29, 514, v6);
  if (v21)
  {
    v22 = v21;
    _fd_unlink_with_origin((uint64_t)v21, 0);
    fd_release(v22);
  }
  v29[0] = 0;
  asprintf(v29, "%s%s", a2, ".buckets");
  v23 = (char *)fd_create_protected(a1, v29[0], 2, v6);
  if (v23)
  {
    v24 = v23;
    _fd_unlink_with_origin((uint64_t)v23, 0);
    fd_release(v24);
  }
  free(v29[0]);
  asprintf(v29, "%s%s", a2, ".header");
  v25 = (char *)fd_create_protected(a1, v29[0], 514, v6);
  if (v25)
  {
    v26 = v25;
    _fd_unlink_with_origin((uint64_t)v25, 0);
    fd_release(v26);
  }
  free(v29[0]);
  asprintf(v29, "%s%s", a2, ".offsets");
  v27 = (char *)fd_create_protected(a1, v29[0], 514, v6);
  if (v27)
  {
    v28 = v27;
    _fd_unlink_with_origin((uint64_t)v27, 0);
    fd_release(v28);
  }
  free(v29[0]);
}

uint64_t _floatCompare(float *a1, float *a2)
{
  unsigned int v2;

  if (*a2 <= *a1)
    v2 = 0;
  else
    v2 = -1;
  if (*a1 > *a2)
    return 1;
  else
    return v2;
}

uint64_t flatPageSearchFuzzyBucketCompare(float **a1, float **a2)
{
  unint64_t v2;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  char *v10;
  const char *v11;
  uint64_t v12;

  v2 = *(unsigned int *)*a1;
  if ((v2 & 3) != 0 && (*a1)[2] < 0.0)
  {
    if ((*(_BYTE *)*a2 & 3) != 0)
      return (*a2)[2] >= 0.0;
    return 1;
  }
  v4 = *(unsigned int *)*a2;
  if ((v4 & 3) == 0 || (*a2)[2] >= 0.0)
  {
    v5 = v2 >> 3;
    v6 = v4 >> 3;
    if (v5 > v6)
      return 1;
    if (v5 >= v6)
    {
      v7 = v5;
      v8 = v6;
      v9 = __si_assert_copy_extra(0);
      v10 = v9;
      v11 = "";
      if (v9)
        v11 = v9;
      __message_assert("%s:%u: failed assertion '%s' %s duplicate pages %ld %ld", "FindTermIDs.c", 617, "false", v11, v7, v8);
      free(v10);
      if (__valid_fs(-1))
        v12 = 2989;
      else
        v12 = 3072;
      *(_DWORD *)v12 = -559038737;
      abort();
    }
  }
  return 0xFFFFFFFFLL;
}

void si_remove_text_content_cache_for_oid(uint64_t a1, uint64_t a2)
{
  _QWORD block[7];
  _QWORD v5[3];
  int v6;

  if (*(_QWORD *)(a1 + 6624) && (*(_DWORD *)(a1 + 6584) & 0xC010) == 0xC000)
  {
    if (get_compressor_queue_onceToken != -1)
      dispatch_once(&get_compressor_queue_onceToken, &__block_literal_global_111);
    v5[0] = 0;
    v5[1] = v5;
    v5[2] = 0x2000000000;
    v6 = 0;
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __si_remove_text_content_cache_for_oid_block_invoke;
    block[3] = &unk_1E6E34C58;
    block[5] = a2;
    block[6] = a1;
    block[4] = v5;
    dispatch_barrier_sync((dispatch_queue_t)get_compressor_queue_compressor_queue, block);
    _Block_object_dispose(v5, 8);
  }
}

uint64_t __si_remove_text_content_cache_for_oid_block_invoke(_QWORD *a1)
{
  char *v2;
  uint64_t result;
  unsigned int v4;
  char __str[1024];
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  bzero(__str, 0x400uLL);
  v2 = si_cache_relative_path_for_oid(a1[5], "txt", __str, *(unsigned __int8 *)(a1[6] + 2072));
  if (v2)
  {
    result = x_unlinkat(*(_DWORD *)(a1[6] + 32), v2, 2048);
  }
  else
  {
    v4 = *__error();
    if (v4)
      result = v4;
    else
      result = 0xFFFFFFFFLL;
  }
  *(_DWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = result;
  return result;
}

void __get_compressor_queue_block_invoke()
{
  NSObject *initially_inactive;
  NSObject *v1;

  initially_inactive = dispatch_queue_attr_make_initially_inactive(MEMORY[0x1E0C80D50]);
  v1 = dispatch_queue_attr_make_with_qos_class(initially_inactive, (dispatch_qos_class_t)5u, 0);
  get_compressor_queue_compressor_queue = (uint64_t)dispatch_queue_create("compressor queue", v1);
  dispatch_queue_set_width();
  dispatch_activate((dispatch_object_t)get_compressor_queue_compressor_queue);
}

void si_update_text_content_cache_for_oid(uint64_t a1, uint64_t a2, const __CFString *a3, NSObject *a4)
{
  BOOL v6;
  CFTypeID TypeID;
  CFTypeID v11;
  NSObject *v12;
  CFIndex Length;
  CFIndex v14;
  dispatch_block_t v15;
  _QWORD v16[8];

  if (*(_QWORD *)(a1 + 6624))
  {
    v6 = (~*(_DWORD *)(a1 + 6584) & 0xC000) != 0 || a3 == 0;
    if (!v6 && (*(_DWORD *)(a1 + 6584) & 0x10) == 0)
    {
      TypeID = CFStringGetTypeID();
      v11 = CFGetTypeID(a3);
      if (a4)
      {
        if (TypeID == v11)
        {
          if (get_compressor_queue_onceToken != -1)
            dispatch_once(&get_compressor_queue_onceToken, &__block_literal_global_111);
          v12 = get_compressor_queue_compressor_queue;
          Length = CFStringGetLength(a3);
          if (Length)
          {
            v14 = Length;
            CFRetain(a3);
            v16[0] = MEMORY[0x1E0C809B0];
            v16[1] = 0x40000000;
            v16[2] = __si_update_text_content_cache_for_oid_block_invoke;
            v16[3] = &__block_descriptor_tmp_13_6690;
            v16[4] = a3;
            v16[5] = v14;
            v16[6] = a2;
            v16[7] = a1;
            v15 = dispatch_block_create(DISPATCH_BLOCK_ENFORCE_QOS_CLASS|DISPATCH_BLOCK_ASSIGN_CURRENT, v16);
            dispatch_group_async(a4, v12, v15);
            _Block_release(v15);
          }
        }
      }
    }
  }
}

void __si_update_text_content_cache_for_oid_block_invoke(uint64_t a1)
{
  uint64_t v1;
  const char *CStringPtr;
  UInt8 *v3;
  _BOOL4 v4;
  char *v5;
  int v6;
  int v7;
  int v8;
  BOOL v9;
  int *v10;
  char *v11;
  const char *v12;
  int v13;
  int v14;
  CFRange v15;
  CFIndex v16;
  UInt8 *v17;
  CFIndex usedBufLen;
  char v19[1024];
  int v20[256];
  char __str[1024];
  _BYTE v22[65536];
  uint64_t v23;

  v1 = MEMORY[0x1E0C80A78](a1);
  v23 = *MEMORY[0x1E0C80C00];
  usedBufLen = 0;
  bzero(v22, 0x10000uLL);
  CStringPtr = CFStringGetCStringPtr(*(CFStringRef *)(v1 + 32), 0x8000100u);
  if (CStringPtr || (CStringPtr = CFStringGetCStringPtr(*(CFStringRef *)(v1 + 32), 0x600u)) != 0)
  {
    v3 = (UInt8 *)CStringPtr;
    v4 = 0;
    usedBufLen = strlen(CStringPtr);
  }
  else
  {
    v15.length = *(_QWORD *)(v1 + 40);
    v16 = 3 * v15.length;
    v4 = ((3 * v15.length) & 0xFFFFFFFFFFFF0000) != 0;
    if ((unint64_t)(3 * v15.length) < 0x10000)
    {
      v3 = v22;
    }
    else
    {
      v17 = (UInt8 *)malloc_type_zone_malloc((malloc_zone_t *)indexingZone, 3 * v15.length, 0x882D8436uLL);
      if (!v17)
        goto LABEL_16;
      v3 = v17;
      v15.length = *(_QWORD *)(v1 + 40);
    }
    v15.location = 0;
    CFStringGetBytes(*(CFStringRef *)(v1 + 32), v15, 0x8000100u, 0, 0, v3, v16, &usedBufLen);
  }
  bzero(__str, 0x400uLL);
  *(_QWORD *)v20 = 0x4400000001;
  *(_DWORD *)v19 = 2;
  sysctl(v20, 2u, 0, 0, v19, 4uLL);
  v5 = si_cache_relative_path_for_oid(*(_QWORD *)(v1 + 48), "tmp", __str, *(unsigned __int8 *)(*(_QWORD *)(v1 + 56) + 2072));
  v6 = si_cache_open_for_relative_path(*(_QWORD *)(v1 + 56), v5, *(_QWORD *)(v1 + 48));
  if (v6 != -1)
  {
    v7 = v6;
    bzero(v20, 0x400uLL);
    v8 = fcntl(v7, 50, v20);
    if (LOBYTE(v20[0]))
      v9 = v8 < 0;
    else
      v9 = 1;
    if (v9)
      v10 = 0;
    else
      v10 = v20;
    if (compress_data_to_file((uint64_t)v3, usedBufLen, (char *)v10, v7, 0))
      goto LABEL_12;
    bzero(v19, 0x400uLL);
    v11 = si_cache_relative_path_for_oid(*(_QWORD *)(v1 + 48), "txt", v19, *(unsigned __int8 *)(*(_QWORD *)(v1 + 56) + 2072));
    if (!v11)
      goto LABEL_12;
    v12 = v11;
    v13 = *(_DWORD *)(*(_QWORD *)(v1 + 56) + 32);
    if (!renameatx_np(v13, v5, v13, v11, 0x10u))
    {
      close(v7);
      goto LABEL_14;
    }
    if (*__error() == 22)
    {
      v14 = renameatx_np(v13, v5, v13, v12, 0);
      close(v7);
      if (!v14)
        goto LABEL_14;
    }
    else
    {
LABEL_12:
      close(v7);
    }
    x_unlinkat(*(_DWORD *)(*(_QWORD *)(v1 + 56) + 32), v5, 2048);
  }
LABEL_14:
  *(_QWORD *)v20 = 0x4400000001;
  *(_DWORD *)v19 = 4;
  sysctl(v20, 2u, 0, 0, v19, 4uLL);
  if (v4)
    free(v3);
LABEL_16:
  CFRelease(*(CFTypeRef *)(v1 + 32));
}

uint64_t si_cache_open_for_relative_path(uint64_t a1, const char *a2, unint64_t a3)
{
  uint64_t result;
  int v7;
  int v8;
  int v9;
  unsigned int v10;
  char __str[1024];
  char v12[1024];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  result = 0xFFFFFFFFLL;
  if (a1)
  {
    if (a2)
    {
      x_unlinkat(*(_DWORD *)(a1 + 32), a2, 0x20000000);
      result = openat(*(_DWORD *)(a1 + 32), a2, 536872449, 384);
      if ((_DWORD)result == -1)
      {
        bzero(&v12[6], 0x3FAuLL);
        v10 = 0;
        if ((fd_setDir(*(unsigned int *)(a1 + 32), (int *)&v10) & 1) != 0)
        {
          bzero(__str, 0x400uLL);
          strcpy(v12, "Cache");
          if (mkdir(v12, 0x1C0u) == -1 && *__error() != 17)
            goto LABEL_18;
          if (*(_BYTE *)(a1 + 2072))
          {
            snprintf(__str, 0x400uLL, "/%x", HIDWORD(a3));
            __strlcat_chk();
            if (mkdir(v12, 0x1C0u) != -1 || *__error() == 17)
            {
              v7 = v10;
              MEMORY[0x1BCCB1484](v10);
              if ((v7 & 0x80000000) == 0)
                close(v7);
              return openat(*(_DWORD *)(a1 + 32), a2, 536872449, 384);
            }
            goto LABEL_18;
          }
          if ((snprintf(__str, 0x400uLL, "/%4.4x", HIWORD(a3)), __strlcat_chk(), mkdir(v12, 0x1C0u) == -1)
            && *__error() != 17
            || (snprintf(__str, 0x400uLL, "/%4.4x", WORD2(a3)), __strlcat_chk(), mkdir(v12, 0x1C0u) == -1)
            && *__error() != 17)
          {
LABEL_18:
            v9 = v10;
            MEMORY[0x1BCCB1484](v10);
            if ((v9 & 0x80000000) == 0)
              close(v9);
LABEL_20:
            if (*__error() != 17)
              return 0xFFFFFFFFLL;
            return openat(*(_DWORD *)(a1 + 32), a2, 536872449, 384);
          }
          snprintf(__str, 0x400uLL, "/%4.4x", WORD1(a3));
          __strlcat_chk();
          v8 = mkdir(v12, 0x1C0u);
          fd_resetDir(v10);
          if (v8 == -1)
            goto LABEL_20;
        }
        return openat(*(_DWORD *)(a1 + 32), a2, 536872449, 384);
      }
    }
  }
  return result;
}

CFTypeID si_update_icon_cache_for_oid(CFTypeID result, unint64_t a2, const void *a3)
{
  uint64_t v5;
  CFTypeID TypeID;
  size_t v7;
  char *v8;
  uint64_t v9;
  char *BytePtr;
  char __str[1024];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (a3)
  {
    v5 = result;
    TypeID = CFDataGetTypeID();
    result = CFGetTypeID(a3);
    if (TypeID == result)
    {
      result = CFDataGetLength((CFDataRef)a3);
      if (result)
      {
        v7 = result;
        bzero(__str, 0x400uLL);
        v8 = si_cache_relative_path_for_oid(a2, "img", __str, *(unsigned __int8 *)(v5 + 2072));
        result = si_cache_open_for_relative_path(v5, v8, a2);
        if ((_DWORD)result != -1)
        {
          v9 = result;
          BytePtr = (char *)CFDataGetBytePtr((CFDataRef)a3);
          prot_write(v9, BytePtr, v7);
          return close(v9);
        }
      }
    }
  }
  return result;
}

void si_analytics_log_6700(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  xpc_object_t v9;
  xpc_object_t v10;
  char *string[2];
  xpc_object_t values;
  _BYTE keys[24];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  string[0] = 0;
  string[1] = &a9;
  vasprintf(string, "no field name for id %d of localize id %d", &a9);
  SISetCrashCStr(string[0]);
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)keys = 136315138;
    *(char **)&keys[4] = string[0];
    _os_log_fault_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "%s", keys, 0xCu);
  }
  *(_QWORD *)keys = "crash_string";
  v9 = xpc_string_create(string[0]);
  values = v9;
  v10 = xpc_dictionary_create((const char *const *)keys, &values, 1uLL);
  analytics_send_event();
  xpc_release(v10);
  xpc_release(v9);
  free(string[0]);
}

BOOL si_getGroupFromDBO(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  int v6;
  int v7;
  int v8;
  int v9;
  unsigned int v10;
  int *v11;
  int field_by_id;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  unsigned int v18;
  uint64_t v20;
  uint64_t v21;
  const __CFDictionary *v22;
  const void *v23;
  unint64_t v25;
  unint64_t v26;
  void *value;
  _OWORD v28[2];
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v6 = *(_DWORD *)(a1 + 6584);
  if ((v6 & 0x800) != 0)
    v7 = 139;
  else
    v7 = 137;
  if ((v6 & 0x200) != 0)
    v8 = v7;
  else
    v8 = 136;
  if ((v6 & 0x80) != 0)
    v9 = v8;
  else
    v9 = 131;
  if ((v6 & 0x20) != 0)
    v10 = v9;
  else
    v10 = 120;
  v25 = 0;
  v26 = 0;
  memset(v28, 0, sizeof(v28));
  v11 = (int *)db_copy_field_ids_with_buffer(*(int **)(a1 + 1184), "kMDItemContentTypeTree", (uint64_t)v28, 8uLL);
  field_by_id = db_get_field_by_id(*(int **)(a1 + 1184), a2, v11, &v26, &v25);
  if (!field_by_id && (*(_WORD *)(v26 + 2) & 0x10) != 0)
  {
    v13 = *(_DWORD *)(v26 + 8);
    if (v13 >= 4)
    {
      v15 = 0;
      LODWORD(v14) = v13 >> 2;
      if (v14 <= 1)
        v14 = 1;
      else
        v14 = v14;
      while (1)
      {
        v16 = *(_DWORD *)(v25 + 4 * v15) & 0x7FFFFFFF;
        if (v16 < v10)
          break;
        if (v14 == ++v15)
          goto LABEL_22;
      }
      v17 = si_getGroupFromDBO_memberShipList[v16];
      *a3 = v17;
      LODWORD(v14) = v15;
    }
    else
    {
      LODWORD(v14) = 0;
LABEL_22:
      v17 = 0;
    }
    v18 = ((v17 >> 1) | ((_BYTE)v17 << 7));
    if (v18 <= 9 && ((1 << v18) & 0x2A1) != 0 && (_DWORD)v14 != 0)
    {
      v20 = 0;
      v21 = 4 * v14;
      while (1)
      {
        v22 = *(const __CFDictionary **)(a1 + 6608);
        if (v22)
        {
          v23 = (const void *)(*(_DWORD *)(v25 + v20) & 0x7FFFFFFF);
          value = 0;
          if (CFDictionaryGetValueIfPresent(v22, v23, (const void **)&value))
          {
            if (value <= 0x8A)
              break;
          }
        }
        v20 += 4;
        if (v21 == v20)
          goto LABEL_36;
      }
      *a3 = si_getGroupFromDBO_memberShipList[value];
    }
  }
LABEL_36:
  if (v11 != (int *)v28)
    free(v11);
  return field_by_id == 0;
}

void __si_addRecoveryAttributes_block_invoke(uint64_t a1, char *a2, unsigned __int16 *a3)
{
  __n128 v6;
  unsigned int v7;
  int v8;
  const __CFArray *v9;
  const __CFArray *v10;
  size_t v11;
  char *v12;
  __n128 v13;
  int *v14;
  int *v15;
  _DWORD *v16;
  char *string_for_id;
  _QWORD v18[2];

  v18[1] = *MEMORY[0x1E0C80C00];
  if (strcmp("_kMDItemGroupId", a2))
  {
    v7 = a3[1];
    if ((v7 & 0x10) == 0)
    {
      v8 = db_add_field(*(int **)(*(_QWORD *)(a1 + 40) + 1184), *(_DWORD ***)(a1 + 48), 5u, a2, 0, v7, *a3, (unsigned __int8 *)a3 + 13, v6, *((_DWORD *)a3 + 2));
      goto LABEL_15;
    }
    if ((v7 & 0x80) != 0)
    {
      v11 = *((unsigned int *)a3 + 2);
      v12 = (char *)v18 - ((v11 + 15) & 0x1FFFFFFF0);
      bzero(v12, v11);
      if ((_DWORD)v11)
      {
        v14 = (int *)((char *)a3 + 13);
        v15 = (int *)((char *)a3 + v11 + 13);
        v16 = v12;
        while (1)
        {
          string_for_id = (char *)db_get_string_for_id(*(int **)(*(_QWORD *)(a1 + 40) + 6880), *v14);
          if (!string_for_id)
            break;
          *v16++ = db_create_id_for_value(*(int **)(*(_QWORD *)(a1 + 40) + 1184), string_for_id);
          if (++v14 >= v15)
            goto LABEL_13;
        }
        *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
      }
LABEL_13:
      if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
      {
        v8 = db_add_field(*(int **)(*(_QWORD *)(a1 + 40) + 1184), *(_DWORD ***)(a1 + 48), 5u, a2, 0, a3[1], *a3, (unsigned __int8 *)v12, v13, *((_DWORD *)a3 + 2));
LABEL_15:
        if (v8)
          *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
      }
    }
    else
    {
      v9 = _decodeSDBField(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 6880), a3, (unsigned __int8 *)a3 + 13, 0, 0, 0, 0, (CFAllocatorRef)*MEMORY[0x1E0C9AE00]);
      if (v9)
      {
        v10 = v9;
        setOneFieldLocked(0, a2, v9, *(int **)(*(_QWORD *)(a1 + 40) + 1184), *(uint64_t **)(a1 + 48), a3[1], 0, 0);
        CFRelease(v10);
      }
    }
  }
}

void _SIRecomputeSizesWithCallback(uint64_t a1, uint64_t a2, const void *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  int v11;
  NSObject *v12;
  os_log_type_t v13;
  void *v14;
  uint64_t v15;
  uint64_t (*v16)(_QWORD, const char *, uint64_t, const char *);
  char *v17;
  char *v18;
  const char *v19;
  uint64_t v20;
  uint8_t buf[4];
  _QWORD *v22;
  __int16 v23;
  uint64_t v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)(a1 + 1184) && *(_QWORD *)(a1 + 1056))
  {
    if (!a2)
      goto LABEL_11;
    v5 = 0;
    v6 = 256;
    if (!*(_BYTE *)(a1 + 2072))
      v6 = 22;
    v7 = (uint64_t *)(a1 + 7040);
    do
    {
      v9 = *v7++;
      v8 = v9;
      if (v9 < 0)
        v5 = a2 + 1;
      v5 += v8;
      --v6;
    }
    while (v6);
    if (v5 > a2)
    {
LABEL_11:
      v10 = malloc_type_calloc(1uLL, 0x38uLL, 0x10B0040EF6A6668uLL);
      v11 = *__error();
      v12 = _SILogForLogForCategory(0);
      v13 = 2 * (gSILogLevels[0] < 4);
      if (os_log_type_enabled(v12, v13))
      {
        *(_DWORD *)buf = 134218240;
        v22 = v10;
        v23 = 2048;
        v24 = a1;
        _os_log_impl(&dword_1B8270000, v12, v13, "ctx:%p idx:%p", buf, 0x16u);
      }
      *__error() = v11;
      *v10 = 0xBEEFC0DEBEEFC0DELL;
      v10[1] = a1;
      v14 = _Block_copy(a3);
      *((_DWORD *)v10 + 4) = 0;
      v10[5] = 0;
      v10[6] = v14;
      v10[3] = 0;
      v10[4] = 0;
      v15 = *(_QWORD *)(a1 + 2360);
      if (v15)
      {
        v16 = *(uint64_t (**)(_QWORD, const char *, uint64_t, const char *))(v15 + 64);
        if (v16)
          *((_DWORD *)v10 + 4) = v16(*(_QWORD *)(v15 + 136), "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SIStoring.c", 848, "void _SIRecomputeSizesWithCallback(SIRef, off_t, dispatch_block_t)");
      }
      if (*v10 != 0xBEEFC0DEBEEFC0DELL)
      {
        v17 = __si_assert_copy_extra_521(-1);
        v18 = v17;
        v19 = "";
        if (v17)
          v19 = v17;
        __message_assert("%s:%u: failed assertion '%s' %s magic:%llx", "SIStoring.c", 850, "ctx->magic==RECOMPUTE_SIZE_MAGIC", v19, *v10);
        free(v18);
        if (__valid_fs(-1))
          v20 = 2989;
        else
          v20 = 3072;
        *(_DWORD *)v20 = -559038737;
        abort();
      }
      si_enqueue_work_with_qos(*(_QWORD *)(a1 + 1056), 9, (uint64_t)si_recompute_sizes, (uint64_t)v10);
    }
  }
}

void si_recompute_sizes(const void **a1, int a2)
{
  int v4;
  NSObject *v5;
  os_log_type_t v6;
  const char *v7;
  uint64_t v8;
  int32x2_t *v9;
  unsigned int *v10;
  unsigned int v11;
  unsigned int v12;
  char *v13;
  char *v14;
  const char *v15;
  uint64_t v16;
  char *v17;
  char *v18;
  const char *v19;
  uint64_t v20;
  uint8_t buf[4];
  const void **v22;
  __int16 v23;
  const char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v4 = *__error();
  v5 = _SILogForLogForCategory(0);
  v6 = 2 * (gSILogLevels[0] < 4);
  if (os_log_type_enabled(v5, v6))
  {
    v7 = "canceled";
    if (!a2)
      v7 = "";
    *(_DWORD *)buf = 134218242;
    v22 = a1;
    v23 = 2080;
    v24 = v7;
    _os_log_impl(&dword_1B8270000, v5, v6, "ctx:%p %s", buf, 0x16u);
  }
  *__error() = v4;
  if (*a1 != (const void *)0xBEEFC0DEBEEFC0DELL)
  {
    v13 = __si_assert_copy_extra_521(-1);
    v14 = v13;
    v15 = "";
    if (v13)
      v15 = v13;
    __message_assert("%s:%u: failed assertion '%s' %s magic:%llx ctx:%p ref:%p", "SIStoring.c", 802, "ctx->magic==RECOMPUTE_SIZE_MAGIC", v15, *a1, a1, a1[1]);
    free(v14);
    if (__valid_fs(-1))
      v16 = 2989;
    else
      v16 = 3072;
    *(_DWORD *)v16 = -559038737;
    abort();
  }
  v8 = (uint64_t)a1[1];
  if (!a2 && *(_QWORD *)(v8 + 1184) && *(_QWORD *)(v8 + 872))
  {
    if (*(_QWORD *)v8 != 0xC0DE10DE10DEC0DELL)
    {
      v17 = __si_assert_copy_extra_521(-1);
      v18 = v17;
      v19 = "";
      if (v17)
        v19 = v17;
      __message_assert("%s:%u: failed assertion '%s' %s ", "SIStoring.c", 805, "ref->magic == (0xc0de10de10dec0de)", v19);
      free(v18);
      if (__valid_fs(-1))
        v20 = 2989;
      else
        v20 = 3072;
      *(_DWORD *)v20 = -559038737;
      abort();
    }
    v9 = (int32x2_t *)malloc_type_calloc(1uLL, 0xC08uLL, 0x1000040DB61F97BuLL);
    *v9 = vrev64_s32(*(int32x2_t *)(v8 + 2008));
    v10 = (unsigned int *)(v8 + 1452);
    do
      v11 = __ldaxr(v10);
    while (__stlxr(v11 + 1, v10));
    si_scheduler_suspend(*(_QWORD *)(v8 + 872));
    do
      v12 = __ldaxr(v10);
    while (__stlxr(v12 - 1, v10));
    db_apply(*(int **)(v8 + 1184), (uint64_t (*)(uint64_t, _QWORD, uint64_t))recompute_sizes_callback, (uint64_t)v9);
    pthread_mutex_lock((pthread_mutex_t *)(v8 + 6976));
    memcpy((void *)(v8 + 7040), &v9[1], 0x800uLL);
    memcpy((void *)(v8 + 9088), &v9[257], 0x400uLL);
    pthread_mutex_unlock((pthread_mutex_t *)(v8 + 6976));
    db_dirty_datastore(*(int **)(v8 + 1184));
    si_scheduler_resume(*(_QWORD *)(v8 + 872), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SIStoring.c", 820);
    free(v9);
    (*((void (**)(void))a1[6] + 2))();
    v8 = (uint64_t)a1[1];
  }
  si_power_info_cleanup((uint64_t)(a1 + 2), v8, a2 != 0);
  _Block_release(a1[6]);
  free(a1);
}

uint64_t recompute_sizes_callback(int *a1, uint64_t a2, _DWORD *a3)
{
  unsigned int v6;
  int field_by_id;
  unsigned __int8 *v8;
  _QWORD *v10;
  unsigned __int8 *v11;
  unint64_t v12;
  _QWORD v13[2];

  v13[1] = *MEMORY[0x1E0C80C00];
  v12 = 0;
  v13[0] = 0;
  LODWORD(v13[0]) = a3[1];
  v11 = 0;
  if (!db_get_field_by_id(a1, a2, (int *)v13, &v12, (unint64_t *)&v11))
  {
    v6 = *v11;
    if ((db_corespotlight_store((uint64_t)a1) & 1) != 0 || v6 <= 0x15)
    {
      v10 = 0;
      LODWORD(v13[0]) = *a3;
      field_by_id = db_get_field_by_id(a1, a2, (int *)v13, &v12, (unint64_t *)&v10);
      v8 = v11;
      if (!field_by_id)
        *(_QWORD *)&a3[2 * *v11 + 2] += *v10;
      ++a3[*v8 + 514];
    }
  }
  return 1;
}

void SIRecomputeSizes(uint64_t a1, uint64_t a2)
{
  _SIRecomputeSizesWithCallback(a1, a2, &__block_literal_global_6728);
}

void fixupOrphanItems(void *a1, int a2)
{
  const void *v3;

  if (!a2)
    fixupOrphanArray(*(_QWORD *)a1, *((_QWORD *)a1 + 1), 0);
  v3 = (const void *)*((_QWORD *)a1 + 1);
  if (v3)
    CFRelease(v3);
  free(a1);
}

unint64_t fixupOrphanArray(unint64_t a1, uint64_t a2, char a3)
{
  unint64_t result;
  _QWORD v7[5];
  char v8;

  result = si_get_cs_orphan_oid(a1);
  if (result)
  {
    v7[0] = MEMORY[0x1E0C809B0];
    v7[1] = 0x40000000;
    v7[2] = __fixupOrphanArray_block_invoke;
    v7[3] = &__block_descriptor_tmp_121;
    v7[4] = a1;
    v8 = a3;
    return SIValueSet<unsigned long long>::_SIValueSetInnerIterate(a2 + 256, *(_QWORD *)(a2 + 216), *(_DWORD *)(a2 + 224), (uint64_t)runBlock, (uint64_t)v7, 1024);
  }
  return result;
}

void __fixupOrphanArray_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int *v8;
  unint64_t v9;
  unint64_t v10;
  int v11;
  unint64_t cs_orphan_oid;
  int v13;
  NSObject *v14;
  uint64_t v15;
  int v16;
  NSObject *v17;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  _BOOL4 v22;
  BOOL v24;
  int v25;
  unsigned int *v26;
  unsigned int v27;
  unsigned int v28;
  uint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  int v32;
  CFStringRef v34;
  CFDictionaryRef v35;
  CFDictionaryRef v36;
  CFTypeID v37;
  CFTypeRef v38;
  int field_by_id;
  CFStringRef v40;
  const void *v41;
  uint64_t (*v42)(void);
  uint64_t v43;
  unint64_t v44;
  int v45;
  int v46;
  NSObject *v47;
  const char *v48;
  int Path;
  int v50;
  uint64_t v51;
  int v52;
  NSObject *v53;
  int *v54;
  int v55;
  uint64_t v56;
  uint64_t v57;
  int v58;
  char *v59;
  char *v60;
  const char *v61;
  uint64_t v62;
  CFTypeRef cf;
  int v64;
  const __CFString *v65;
  CFStringRef v66;
  const __CFAllocator *alloc;
  uint64_t *v68;
  int v69;
  char *v70;
  _WORD *v71;
  unint64_t v72;
  int v73[2];
  char *cStr;
  void *v75;
  uint64_t v76;
  _QWORD v77[511];
  uint64_t v78;
  int v79[2];
  int v80[2];
  _BYTE buf[12];
  __int16 v82;
  _BYTE v83[10];
  _BYTE v84[10];
  __int16 v85;
  uint64_t v86;
  uint64_t v87;

  v1 = MEMORY[0x1E0C80A78](a1);
  v87 = *MEMORY[0x1E0C80C00];
  if (v3)
  {
    v4 = v3;
    v5 = v2;
    v6 = v1;
    v7 = 0;
    alloc = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v8 = (int *)&unk_1EF19F000;
    while (1)
    {
      v9 = *(_QWORD *)(v6 + 32);
      if (*(_BYTE *)(v9 + 2432))
        return;
      v10 = *(_QWORD *)(v5 + 8 * v7);
      v11 = *(unsigned __int8 *)(v6 + 40);
      v80[0] = *(_DWORD *)(v9 + 2060);
      v80[1] = 0;
      v79[0] = *(_DWORD *)(v9 + 2064);
      v79[1] = 0;
      v78 = *(unsigned int *)(v9 + 2068);
      v75 = 0;
      bzero(&v76, 0x1000uLL);
      cs_orphan_oid = si_get_cs_orphan_oid(v9);
      if (v8[803] >= 5)
      {
        v46 = *__error();
        v47 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315650;
          v48 = " inflight";
          if (!v11)
            v48 = " ";
          *(_QWORD *)&buf[4] = v48;
          v82 = 2048;
          *(_QWORD *)v83 = v10;
          *(_WORD *)&v83[8] = 2048;
          *(_QWORD *)v84 = cs_orphan_oid;
          _os_log_impl(&dword_1B8270000, v47, OS_LOG_TYPE_DEFAULT, "repair%s oid: %lld orphan parent: %lld", buf, 0x20u);
        }
        *__error() = v46;
        v8 = (_DWORD *)&unk_1EF19F000;
      }
      if (db_get_obj(*(_DWORD **)(v9 + 1184), v10, &v75, 0))
      {
        if (v8[803] >= 5)
        {
          v13 = *__error();
          v14 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 134217984;
            *(_QWORD *)&buf[4] = v10;
            _os_log_impl(&dword_1B8270000, v14, OS_LOG_TYPE_DEFAULT, "repair oid: %lld skipped", buf, 0xCu);
          }
          *__error() = v13;
          v8 = (_DWORD *)&unk_1EF19F000;
        }
        goto LABEL_47;
      }
      v15 = *((_QWORD *)v75 + 3);
      if (!v15 || v15 == cs_orphan_oid)
        break;
      if (v8[803] >= 5)
      {
        v16 = *__error();
        v17 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          v18 = *((_QWORD *)v75 + 3);
          *(_DWORD *)buf = 134218240;
          *(_QWORD *)&buf[4] = v10;
          v82 = 2048;
          *(_QWORD *)v83 = v18;
          _os_log_impl(&dword_1B8270000, v17, OS_LOG_TYPE_DEFAULT, "repair oid: %lld parent oid: %lld skipped", buf, 0x16u);
        }
        *__error() = v16;
LABEL_38:
        v8 = (_DWORD *)&unk_1EF19F000;
      }
LABEL_46:
      free(v75);
LABEL_47:
      if (++v7 == v4)
        return;
    }
    if (*(_QWORD *)v75 == cs_orphan_oid)
    {
      v19 = 0;
      v20 = 0;
      v76 = 2;
      v21 = 1;
      v22 = 1;
LABEL_18:
      v24 = v76 != cs_orphan_oid && v21 != 0 && v20 == 0;
      v8 = (_DWORD *)&unk_1EF19F000;
      if (!v24 && !v22)
        goto LABEL_46;
      v25 = v19;
      si_scheduler_suspend(*(_QWORD *)(v9 + 864));
      v26 = (unsigned int *)(v9 + 1452);
      do
        v27 = __ldaxr(v26);
      while (__stlxr(v27 + 1, v26));
      si_scheduler_suspend(*(_QWORD *)(v9 + 872));
      do
        v28 = __ldaxr(v26);
      while (__stlxr(v28 - 1, v26));
      if (v25)
      {
        v29 = (v21 - 2);
        if (v21 >= 2)
        {
          v30 = v29 + 1;
          v31 = &v77[v29];
          v32 = 1;
          do
          {
            *(_QWORD *)buf = 0;
            if (!db_get_obj(*(_DWORD **)(v9 + 1184), *(v31 - 1), (void **)buf, 0))
            {
              updateWithNewPath(v9);
              free(*(void **)buf);
            }
            --v31;
            ++v32;
          }
          while (v30-- > 1);
        }
      }
      updateWithNewPath(v9);
      si_scheduler_resume(*(_QWORD *)(v9 + 872), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SIStoring.c", 1214);
      si_scheduler_resume(*(_QWORD *)(v9 + 864), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SIStoring.c", 1215);
      goto LABEL_38;
    }
    *(_QWORD *)buf = 0;
    cStr = 0;
    if (db_get_field_by_id(*(int **)(v9 + 1184), (uint64_t)v75, v80, (unint64_t *)buf, (unint64_t *)&cStr))goto LABEL_46;
    if (**(_WORD **)buf != 11)
      goto LABEL_46;
    v72 = 0;
    *(_QWORD *)v73 = 0;
    if (db_get_field_by_id(*(int **)(v9 + 1184), (uint64_t)v75, v79, (unint64_t *)v73, &v72)
      || **(_WORD **)v73 != 11)
    {
      goto LABEL_46;
    }
    v34 = CFStringCreateWithCString(alloc, cStr, 0x8000100u);
    v35 = _decodeSDBField(*(_QWORD *)(v9 + 1184), *(unsigned __int16 **)v73, (unsigned __int8 *)(*(_QWORD *)v73 + 13), 0, 0, 0, 0, alloc);
    if (v35)
    {
      v36 = v35;
      v37 = CFGetTypeID(v35);
      if (v37 == CFStringGetTypeID())
        v38 = CFRetain(v36);
      else
        v38 = 0;
      CFRelease(v36);
    }
    else
    {
      v38 = 0;
    }
    v70 = 0;
    v71 = 0;
    field_by_id = db_get_field_by_id(*(int **)(v9 + 1184), (uint64_t)v75, (int *)&v78, (unint64_t *)&v71, (unint64_t *)&v70);
    v40 = 0;
    if (!field_by_id)
    {
      if (*v71 == 11)
        v40 = CFStringCreateWithCString(alloc, v70, 0x8000100u);
      else
        v40 = 0;
    }
    v66 = v40;
    if (!v38 || !v34)
    {
      v64 = 0;
      v20 = 0;
      v41 = v38;
      v22 = 0;
      v69 = -1;
      if (!v41)
        goto LABEL_89;
      goto LABEL_88;
    }
    v68 = (uint64_t *)v75;
    if (*(_QWORD *)v75 == 2)
    {
      v64 = 0;
      v41 = v38;
      v22 = 0;
      v76 = 0;
      v20 = 1;
      v69 = -1;
LABEL_88:
      CFRelease(v41);
LABEL_89:
      if (v34)
        CFRelease(v34);
      if (v66)
        CFRelease(v66);
      v21 = v69;
      v19 = v64;
      goto LABEL_18;
    }
    dispatch_time(0, 10000000000);
    v42 = *(uint64_t (**)(void))(*(_QWORD *)(v9 + 1416) + 128);
    cf = v38;
    if (v42)
    {
      v43 = v42();
      v44 = v43;
      if (v43 > 0)
      {
        v76 = v43;
        if (v43 == 2)
        {
          v45 = 1;
          goto LABEL_77;
        }
LABEL_74:
        Path = directoryStoreWriterGetPath(*(_QWORD *)(v9 + 6624), v44, (uint64_t)v77);
        LODWORD(cStr) = Path;
        if (!Path || (v45 = Path + 1, LODWORD(cStr) = Path + 1, Path == -1))
        {
          v20 = psid_lookupPath(v9, v68, (uint64_t)v38, (uint64_t)v66, (uint64_t)v34, (unsigned int *)&cStr, (uint64_t)&v76);
          v50 = 1;
          v45 = (int)cStr;
LABEL_84:
          v22 = 0;
          v69 = v45;
          v64 = v50;
          if (!v20 && v45)
          {
            v20 = 0;
            v22 = *((_QWORD *)v75 + 3) != v76;
          }
          v41 = cf;
          goto LABEL_88;
        }
LABEL_77:
        v51 = 0;
        do
        {
          if (v77[v51 - 1] <= 0)
          {
            v58 = v45;
            v59 = __si_assert_copy_extra_521(-1);
            v60 = v59;
            v61 = "";
            if (v59)
              v61 = v59;
            __message_assert("%s:%u: failed assertion '%s' %s Got parent[%d] with id %lld depth: %d", "SIStoring.c", 1110, "newpath[i] > 0", v61, v51, v77[v51 - 1], v58);
            free(v60);
            if (__valid_fs(-1))
              v62 = 2989;
            else
              v62 = 3072;
            *(_DWORD *)v62 = -559038737;
            abort();
          }
          ++v51;
        }
        while (v45 != v51);
        v50 = 0;
        v20 = 0;
        goto LABEL_84;
      }
    }
    else
    {
      v44 = -1;
    }
    if (*v68 != 2)
    {
      v65 = v34;
      v20 = *__error();
      v52 = *__error();
      v53 = _SILogForLogForCategory(4);
      if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
      {
        v55 = *__error();
        v56 = *v68;
        v57 = v68[3];
        *(_DWORD *)buf = 136316162;
        *(_QWORD *)&buf[4] = "repair_lookupPath";
        v82 = 1024;
        *(_DWORD *)v83 = 1097;
        *(_WORD *)&v83[4] = 1024;
        *(_DWORD *)&v83[6] = v55;
        *(_WORD *)v84 = 2048;
        *(_QWORD *)&v84[2] = v56;
        v85 = 2048;
        v86 = v57;
        _os_log_error_impl(&dword_1B8270000, v53, OS_LOG_TYPE_ERROR, "%s:%d: error: %d oid: %lld parent: %lld", buf, 0x2Cu);
      }
      v54 = __error();
      v50 = 0;
      *v54 = v52;
      v45 = -1;
      v34 = v65;
      goto LABEL_84;
    }
    v76 = v44;
    goto LABEL_74;
  }
}

uint64_t psid_lookupPath(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int *a6, uint64_t a7)
{
  int v11;
  int v12;
  NSObject *v13;
  uint64_t result;
  uint64_t v15;
  uint64_t i;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  char *v20;
  const char *v21;
  uint64_t v22;
  unsigned int v23;
  uint8_t buf[4];
  const char *v25;
  __int16 v26;
  int v27;
  __int16 v28;
  int v29;
  __int16 v30;
  int v31;
  __int16 v32;
  uint64_t v33;
  __int16 v34;
  uint64_t v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v23 = 0;
  if (SIPersistentIDStoreGetOidPathForOid(*(_QWORD *)(a1 + 1416), *a2, a7, 0, &v23))
  {
    v11 = *__error();
    if (v11 != 22 && v11 != 60)
    {
      v12 = *__error();
      v13 = _SILogForLogForCategory(4);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        v17 = *a2;
        v18 = a2[3];
        *(_DWORD *)buf = 136316418;
        v25 = "psid_lookupPath";
        v26 = 1024;
        v27 = 930;
        v28 = 1024;
        v29 = v11;
        v30 = 1024;
        v31 = 930;
        v32 = 2048;
        v33 = v17;
        v34 = 2048;
        v35 = v18;
        _os_log_error_impl(&dword_1B8270000, v13, OS_LOG_TYPE_ERROR, "%s:%d: SIPersistentIDStoreGetOidPathForOid error:%d at:%d oid:%lld parent:%lld", buf, 0x32u);
      }
      *__error() = v12;
    }
    if (v11 == 60)
      return 60;
    else
      return 22;
  }
  else if (*(_BYTE *)(a1 + 2072))
  {
    result = 0;
    *a6 = v23;
  }
  else if (v23 < 2)
  {
    result = 0;
    *a6 = 0;
  }
  else
  {
    v15 = si_directoryStoreEnsurePath(a1) + 1;
    *a6 = v15;
    if ((_DWORD)v15)
    {
      for (i = 0; i != v15; ++i)
      {
        if (*(uint64_t *)(a7 + 8 * i) <= 0)
        {
          v19 = __si_assert_copy_extra_521(-1);
          v20 = v19;
          v21 = "";
          if (v19)
            v21 = v19;
          __message_assert("%s:%u: failed assertion '%s' %s Got parent[%d] with id %lld depth: %d", "SIStoring.c", 947, "newpath[i] > 0", v21, i, *(_QWORD *)(a7 + 8 * i), *a6);
          free(v20);
          if (__valid_fs(-1))
            v22 = 2989;
          else
            v22 = 3072;
          *(_DWORD *)v22 = -559038737;
          abort();
        }
      }
    }
    return 0;
  }
  return result;
}

void updateWithNewPath(uint64_t a1)
{
  uint64_t v1;
  pthread_mutex_t *v2;
  pthread_mutex_t *v3;
  unsigned int *v4;
  unsigned int *v5;
  pthread_mutex_t *v6;
  pthread_mutex_t *v7;
  void **v8;
  void **v9;
  int v10;
  int v11;
  uint64_t v12;
  void *v13;
  void *v14;
  _BOOL4 v16;
  pthread_mutex_t *v17;
  char v18;
  unint64_t v19;
  pthread_mutex_t *v20;
  uint64_t v23;
  unsigned int v24;
  unsigned int v25;
  int inserted;
  int v27;
  NSObject *v28;
  pthread_key_t v29;
  unsigned int v30;
  unint64_t v31;
  int v32;
  int v33;
  unsigned int v34;
  int v35;
  pthread_mutex_t *v36;
  _QWORD *v37;
  unint64_t v38;
  int8x8_t v39;
  uint8x8_t v40;
  unint64_t v41;
  uint64_t **v42;
  uint64_t *i;
  unint64_t v44;
  uint64_t v45;
  uint64_t *v46;
  uint64_t v47;
  _QWORD *v48;
  uint64_t v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  unsigned int v53;
  uint64_t v54;
  int v55;
  int v56;
  int v57;
  unsigned int v58;
  uint64_t v59;
  _BOOL4 v60;
  _BOOL4 v61;
  int v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  unsigned int v67;
  uint64_t v68;
  int v69;
  int v70;
  uint64_t v71;
  int v72;
  int64_t v73;
  uint64_t v74;
  _BOOL4 v75;
  _BOOL4 v76;
  int v77;
  pthread_override_s *v78;
  char v79;
  _DWORD *v80;
  _DWORD *v81;
  int v82;
  int v83;
  uint64_t v84;
  uint64_t *v85;
  int v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  unint64_t v91;
  const __CFSet *v92;
  unint64_t v93;
  const __CFSet *v94;
  const __CFAllocator *allocator;
  _QWORD *obj;
  __CFDictionary *v97;
  _DWORD *LiveIndex;
  pthread_mutex_t **v99;
  pthread_mutex_t *v100;
  _BOOL4 v101;
  int v102;
  int v103;
  NSObject *v104;
  const char *v105;
  char *v106;
  char *v107;
  const char *v108;
  uint64_t v109;
  char *v110;
  char *v111;
  const char *v112;
  int v113;
  NSObject *v114;
  unint64_t v115;
  uint64_t v116;
  void *v117;
  pthread_mutex_t *v118;
  int v119;
  pthread_mutex_t *v120;
  _BYTE buf[12];
  __int16 v122;
  int v123;
  __int16 v124;
  int v125;
  __int16 v126;
  pthread_mutex_t *v127;
  pthread_mutex_t *v128;
  pthread_mutex_t *v129;
  _QWORD v130[4];

  v1 = MEMORY[0x1E0C80A78](a1);
  v3 = v2;
  v5 = v4;
  v7 = v6;
  v9 = v8;
  v11 = v10;
  v12 = v1;
  v130[1] = *MEMORY[0x1E0C80C00];
  v13 = malloc_type_malloc(v4[3], 0x1142DA9BuLL);
  v14 = v13;
  if (v13)
  {
    memcpy(v13, v5, v5[3]);
    *((_DWORD *)v14 + 2) = v5[3];
  }
  v16 = v7 != (pthread_mutex_t *)2 && v7 != v3;
  if (v11)
  {
    v17 = (pthread_mutex_t *)*v9;
    if (*v9 != v7)
    {
LABEL_13:
      *((_QWORD *)v14 + 3) = v17;
      goto LABEL_14;
    }
    ++v9;
    if (--v11)
    {
      v17 = (pthread_mutex_t *)*v9;
      goto LABEL_13;
    }
  }
LABEL_14:
  if (*v9 != v3)
  {
    v18 = !v16;
    if (v11 < 2)
      v18 = 1;
    if ((v18 & 1) == 0)
    {
      v19 = 1;
      do
      {
        v20 = (pthread_mutex_t *)v9[v19];
        v16 = v20 != v7 && *v9 != v20;
        ++v19;
      }
      while (v16 && v19 < v11);
    }
    if ((v11 & 0x80000000) == 0 && v16)
    {
      v23 = *(_QWORD *)(v12 + 1184);
      if (*(_DWORD *)v23 != 1685287992)
      {
        v110 = __si_assert_copy_extra_268();
        v111 = v110;
        if (v110)
          v112 = v110;
        else
          v112 = "";
        __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 321, v112);
        free(v111);
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      if ((*(_BYTE *)(v23 + 804) & 8) != 0)
      {
        inserted = 13;
        goto LABEL_38;
      }
      v24 = *((_DWORD *)v14 + 3);
      if (v24 < 0x30 || (v25 = *((_DWORD *)v14 + 2), v25 < 0x30))
      {
        inserted = 22;
        goto LABEL_38;
      }
      inserted = 7;
      if (v24 > 0xFFEB || v25 > 0x10000)
        goto LABEL_38;
      *((_DWORD *)v14 + 10) &= ~8u;
      v29 = __THREAD_SLOT_KEY;
      if (!__THREAD_SLOT_KEY)
      {
        makeThreadId();
        v29 = __THREAD_SLOT_KEY;
      }
      v117 = pthread_getspecific(v29);
      v118 = (pthread_mutex_t *)(v23 + 584);
      HIDWORD(v31) = qos_class_self() - 9;
      LODWORD(v31) = HIDWORD(v31);
      v30 = v31 >> 2;
      if (v30 > 6)
        v32 = 0;
      else
        v32 = dword_1B8630ED0[v30];
      v33 = pthread_mutex_lock(v118);
      v34 = v32;
      if (*(_QWORD *)(v23 + 768) || *(_DWORD *)(v23 + 780) || *(_BYTE *)(v23 + 796))
        goto LABEL_52;
      if (v32 > 5)
        goto LABEL_83;
      if (*(_QWORD *)(v23 + 16 * v32 + 648))
        goto LABEL_52;
      v45 = v32 - 1;
      v46 = (uint64_t *)(v23 + 16 * v32 + 664);
      do
      {
        if (v45 == 4)
          goto LABEL_83;
        v47 = *v46;
        v46 += 2;
        ++v45;
      }
      while (!v47);
      if (v45 <= 4)
      {
LABEL_52:
        v35 = v33;
        v36 = (pthread_mutex_t *)(v23 + 584);
        db_rwlock_wait((uint64_t)v118, v34, 2);
      }
      else
      {
LABEL_83:
        v35 = v33;
        *(_QWORD *)(v23 + 768) = pthread_self();
        v36 = (pthread_mutex_t *)(v23 + 584);
      }
      pthread_mutex_unlock(v36);
      if (v35)
      {
        v113 = *__error();
        v114 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v114, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          *(_QWORD *)&buf[4] = "db2_cas_obj";
          v122 = 1024;
          v123 = 11543;
          v124 = 1024;
          v125 = v35;
          _os_log_error_impl(&dword_1B8270000, v114, OS_LOG_TYPE_ERROR, "%s:%d: Lock failed with error %d", buf, 0x18u);
        }
        *__error() = v113;
        sdb2_die(v23, "Multiple threads entering in sdb!", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 11543);
      }
      if (v117)
        v115 = CIOnThreadCleanUpPush((uint64_t)v117 - 1, (uint64_t)db_write_unlock, (uint64_t)v36);
      else
        v115 = -1;
      v116 = (uint64_t)v117 - 1;
      if ((*(_BYTE *)(v23 + 4) & 2) != 0)
      {
        inserted = 22;
        goto LABEL_138;
      }
      if (*((_DWORD *)v14 + 3) <= 0x2Fu)
      {
        v106 = __si_assert_copy_extra_2151(0, -1);
        v107 = v106;
        v108 = "";
        if (v106)
          v108 = v106;
        __message_assert("%s:%u: failed assertion '%s' %s ", "sdb2.c", 13332, "dbo->used_bytes >= sizeof(external_db_obj)", v108);
        free(v107);
        if (__valid_fs(-1))
          v109 = 2989;
        else
          v109 = 3072;
        *(_DWORD *)v109 = -559038737;
        abort();
      }
      v37 = *(_QWORD **)(v23 + 992);
      v38 = *(_QWORD *)v14;
      v39 = (int8x8_t)v37[1];
      if (v39)
      {
        v40 = (uint8x8_t)vcnt_s8(v39);
        v40.i16[0] = vaddlv_u8(v40);
        if (v40.u32[0] > 1uLL)
        {
          v41 = *(_QWORD *)v14;
          if (v38 >= *(_QWORD *)&v39)
            v41 = v38 % *(_QWORD *)&v39;
        }
        else
        {
          v41 = (*(_QWORD *)&v39 - 1) & v38;
        }
        v42 = *(uint64_t ***)(*v37 + 8 * v41);
        if (v42)
        {
          for (i = *v42; i; i = (uint64_t *)*i)
          {
            v44 = i[1];
            if (v44 == v38)
            {
              if (i[2] == v38)
              {
                if (*((_DWORD *)i + 6) != 3)
                  break;
LABEL_137:
                inserted = 2;
LABEL_138:
                v119 = pthread_mutex_lock(v36);
                *(_DWORD *)(v23 + 788) = 0;
                v78 = *(pthread_override_s **)(v23 + 760);
                *(_QWORD *)(v23 + 768) = 0;
                *(_QWORD *)(v23 + 760) = 0;
                v79 = *(_DWORD *)(v23 + 780) != 0;
                *(_BYTE *)(v23 + 796) = 0;
                db_rwlock_wakeup((uint64_t)v36, v79, 0);
                pthread_mutex_unlock(v36);
                if (v78)
                  pthread_override_qos_class_end_np(v78);
                if (v119)
                  sdb2_die(v23, "Multiple threads in sdb! (leaving)", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 11551);
                if (v117)
                {
                  CIOnThreadCleanUpClearItem(v116, v115);
                  v80 = &threadData[18 * v116];
                  v83 = v80[14];
                  v81 = v80 + 14;
                  v82 = v83;
                  if (v115 + 1 == v83)
                    *v81 = v82 - 1;
                }
                if (!inserted)
                {
                  v128 = *(pthread_mutex_t **)v14;
                  v129 = v3;
                  v130[0] = 2;
                  v84 = *((_QWORD *)v14 + 3);
                  v120 = v128;
                  if (v128 == v3)
                    v85 = (uint64_t *)&v129;
                  else
                    v85 = (uint64_t *)&v128;
                  if (v128 == v3)
                    v86 = 2;
                  else
                    v86 = 3;
                  if (v84 == 2)
                    v87 = 1;
                  else
                    v87 = v11;
                  directoryStoreSetParentForMove(*(_QWORD *)(v12 + 6624), (unint64_t)v128, v84);
                  v88 = *(_QWORD *)(v12 + 6632);
                  if (v88)
                    directoryOverlayMoveDirectory(v88, v86, v85, v87, v9);
                  v89 = *(_QWORD *)(v12 + 1384);
                  v90 = *(_QWORD *)(v12 + 1392);
                  if (*(_DWORD *)(v90 + 8))
                  {
                    v91 = 0;
                    do
                    {
                      v92 = *(const __CFSet **)(v12 + 6640);
                      if (!v92
                        || !CFSetContainsValue(v92, (const void *)*(int *)(*(_QWORD *)(*(_QWORD *)v90 + 8 * v91) + 48)))
                      {
                        _CIMoveDirectory(*(_QWORD *)(*(_QWORD *)v90 + 8 * v91), v86, v85, v87, (uint64_t)v9);
                      }
                      ++v91;
                    }
                    while (v91 < *(unsigned int *)(v90 + 8));
                  }
                  if (*(_DWORD *)(v89 + 8))
                  {
                    v93 = 0;
                    do
                    {
                      v94 = *(const __CFSet **)(v12 + 6640);
                      if (!v94
                        || !CFSetContainsValue(v94, (const void *)*(int *)(*(_QWORD *)(*(_QWORD *)v89 + 8 * v93) + 48)))
                      {
                        _CIMoveDirectory(*(_QWORD *)(*(_QWORD *)v89 + 8 * v93), v86, v85, v87, (uint64_t)v9);
                      }
                      ++v93;
                    }
                    while (v93 < *(unsigned int *)(v89 + 8));
                  }
                  if (*((_QWORD *)v14 + 4))
                  {
                    bzero(buf, 0x8001uLL);
                    allocator = _SIStackAllocatorCreate((unint64_t *)buf, 0x8000, indexingZone);
                    obj = db_create_obj(*(_QWORD *)(v12 + 1184), 256, 0);
                    obj[2] = 0;
                    v97 = decodeDBOToDictionary(*(int **)(v12 + 1184), (uint64_t)obj, 0, 0x2000, 2, *(_DWORD *)(v12 + 2028), *(_DWORD *)(v12 + 2060), 0, 1, allocator);
                    LiveIndex = si_getLiveIndex(*(_QWORD *)(v12 + 1384));
                    if (v120 == v3)
                      v99 = (pthread_mutex_t **)v130;
                    else
                      v99 = &v129;
                    _CIUpdateContent((uint64_t)LiveIndex, v87, v9, v86 - 1, v99, *(_QWORD *)v14, 0, v97, 0.0, 0, *((_QWORD *)v14 + 4), (uint64_t *)v14 + 4, 0, 0, 0, 0, 0, 0, 0,
                      0,
                      0,
                      0);
                    free(obj);
                    CFRelease(v97);
                  }
                  goto LABEL_41;
                }
LABEL_38:
                v27 = *__error();
                v28 = _SILogForLogForCategory(4);
                if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 136315906;
                  *(_QWORD *)&buf[4] = "updateWithNewPath";
                  v122 = 1024;
                  v123 = 980;
                  v124 = 1024;
                  v125 = inserted;
                  v126 = 2048;
                  v127 = v7;
                  _os_log_error_impl(&dword_1B8270000, v28, OS_LOG_TYPE_ERROR, "%s:%d: db_cas_obj error: %d oid: %lld", buf, 0x22u);
                }
                *__error() = v27;
                goto LABEL_41;
              }
            }
            else
            {
              if (v40.u32[0] > 1uLL)
              {
                if (v44 >= *(_QWORD *)&v39)
                  v44 %= *(_QWORD *)&v39;
              }
              else
              {
                v44 &= *(_QWORD *)&v39 - 1;
              }
              if (v44 != v41)
                break;
            }
          }
        }
      }
      v128 = 0;
      *(_QWORD *)buf = 0;
      v48 = std::__hash_table<std::__hash_value_type<unsigned long long,value_t>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,value_t>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,value_t>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,value_t>>>::find<unsigned long long>(v37, v38);
      if (v48)
      {
        if (*((_DWORD *)v48 + 6) == 3)
          goto LABEL_137;
        *(_QWORD *)buf = v48[4];
        goto LABEL_136;
      }
      v49 = *(_QWORD *)(v23 + 856);
      v50 = *(_DWORD *)(v49 + 8);
      if (!v50)
        goto LABEL_137;
      v51 = *(int *)(v49 + 16);
      if ((int)v51 >= v50
        || (v52 = v49 + 16 * v51, *(_QWORD *)(v52 + 20) != v38)
        || (v53 = *(_DWORD *)(v52 + 32), v53 >> 28))
      {
        v54 = v50;
        if (v50 >= 1)
        {
          v55 = 0;
          while (1)
          {
            if (v50 + v55 < 0 != __OFADD__(v50, v55))
              v56 = v50 + v55 + 1;
            else
              v56 = v50 + v55;
            v57 = v56 >> 1;
            v58 = *(_DWORD *)(v49 + 16 * (v56 >> 1) + 32);
            if (v58 >> 28)
            {
              v59 = -(v58 >> 28);
            }
            else
            {
              v59 = v38 - *(_QWORD *)(v49 + 16 * ((uint64_t)v56 >> 1) + 20);
              if (v59 >= 0)
              {
                if (!v59)
                  goto LABEL_106;
                v55 = v57 + 1;
                goto LABEL_103;
              }
            }
            v50 = v57;
LABEL_103:
            if (v55 >= v50)
            {
              v60 = v59 > 0;
              goto LABEL_107;
            }
          }
        }
        v57 = 0;
LABEL_106:
        v60 = 0;
LABEL_107:
        v61 = v54 - 1 > v57 && v60;
        v62 = v57 + v61;
        v51 = v57 + v61;
        *(_DWORD *)(v49 + 16) = v62;
        v53 = *(_DWORD *)(v49 + 16 * v62 + 32);
      }
      if (page_find_oid_with_flags(v23, *(_DWORD *)(v49 + 16 * v51 + 28), v53 & 0xFFFFFFF, v38, 0, buf, 0, 0))
      {
        v63 = *(_QWORD *)(v23 + 856);
        v64 = *(unsigned int *)(v63 + 8);
        if (!(_DWORD)v64)
          goto LABEL_137;
        v65 = *(int *)(v63 + 16);
        if ((int)v65 >= (int)v64
          || (v66 = v63 + 16 * v65, *(_QWORD *)(v66 + 20) != v38)
          || (v67 = *(_DWORD *)(v66 + 32), v67 >> 28 != 1))
        {
          v68 = (int)v64;
          if ((int)v64 < 1)
          {
            LODWORD(v71) = 0;
LABEL_130:
            v75 = 0;
          }
          else
          {
            v69 = 0;
            do
            {
              if ((int)v64 + v69 < 0 != __OFADD__((_DWORD)v64, v69))
                v70 = v64 + v69 + 1;
              else
                v70 = v64 + v69;
              v71 = (v70 >> 1);
              v72 = *(_DWORD *)(v63 + 16 * (int)v71 + 32) >> 28;
              if (v72 == 1)
                v73 = v38 - *(_QWORD *)(v63 + 16 * ((uint64_t)v70 >> 1) + 20);
              else
                v73 = 1 - v72;
              v74 = v71;
              if ((v73 & 0x8000000000000000) == 0)
              {
                if (!v73)
                  goto LABEL_130;
                v69 = v71 + 1;
                v74 = v64;
              }
              v64 = v74;
            }
            while (v69 < (int)v74);
            v75 = v73 > 0;
          }
          v76 = v68 - 1 > (int)v71 && v75;
          v77 = v71 + v76;
          v65 = (int)v71 + v76;
          *(_DWORD *)(v63 + 16) = v77;
          v67 = *(_DWORD *)(v63 + 16 * v77 + 32);
        }
        if (page_find_oid_with_flags(v23, *(_DWORD *)(v63 + 16 * v65 + 28), v67 & 0xFFFFFFF, v38, 1u, buf, 0, 0))goto LABEL_137;
      }
LABEL_136:
      if (_inflateDBO(v23, *(unsigned int **)buf, (void **)&v128, 0, 0x10000, 0))
        goto LABEL_137;
      v100 = v128;
      v101 = equalDBO((uint64_t)v128);
      free(v100);
      if (!v101)
      {
        inserted = 2;
        goto LABEL_181;
      }
      serializeDBO(v23);
      if ((MEMORY[0] - 16360) <= 0xFFFFC013)
      {
        v102 = test_compress_obj(v23, 0x4000, 0);
        if (v102)
        {
          inserted = v102;
          free(0);
          goto LABEL_181;
        }
      }
      inserted = db_updateset_insert_object(*(float **)(v23 + 992), 0, 1, 0);
      free(0);
      if (inserted)
      {
        v103 = *__error();
        v104 = _SILogForLogForCategory(7);
        if (!os_log_type_enabled(v104, OS_LOG_TYPE_ERROR))
          goto LABEL_179;
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = "cas_obj";
        v122 = 1024;
        v123 = 5335;
        v124 = 1024;
        v125 = inserted;
        v105 = "%s:%d: Error %d from db_updateset_insert_object";
      }
      else
      {
        if ((unint64_t)(*(_QWORD *)(*(_QWORD *)(v23 + 992) + 56)
                              + 16 * *(_QWORD *)(*(_QWORD *)(v23 + 992) + 48)) < 0x80000)
        {
          inserted = 0;
          goto LABEL_181;
        }
        inserted = flush_updateset_locked(v23);
        if (!inserted)
        {
LABEL_181:
          v36 = (pthread_mutex_t *)(v23 + 584);
          goto LABEL_138;
        }
        v103 = *__error();
        v104 = _SILogForLogForCategory(7);
        if (!os_log_type_enabled(v104, OS_LOG_TYPE_ERROR))
        {
LABEL_179:
          *__error() = v103;
          goto LABEL_181;
        }
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = "cas_obj";
        v122 = 1024;
        v123 = 5339;
        v124 = 1024;
        v125 = inserted;
        v105 = "%s:%d: Error %d from flush_updateset_locked";
      }
      _os_log_error_impl(&dword_1B8270000, v104, OS_LOG_TYPE_ERROR, v105, buf, 0x18u);
      goto LABEL_179;
    }
  }
LABEL_41:
  free(v14);
}

void __decodeDBOToDictionary_block_invoke(uint64_t a1, const __CFArray *a2)
{
  CFTypeID TypeID;
  CFIndex i;
  __CFArray *v6;
  const void *ValueAtIndex;
  CFTypeID v8;

  TypeID = CFArrayGetTypeID();
  if (TypeID == CFGetTypeID(a2))
  {
    for (i = 0; CFArrayGetCount(a2) > i; ++i)
    {
      v6 = *(__CFArray **)(a1 + 32);
      ValueAtIndex = CFArrayGetValueAtIndex(a2, i);
      CFArrayAppendValue(v6, ValueAtIndex);
    }
  }
  else
  {
    v8 = CFStringGetTypeID();
    if (v8 == CFGetTypeID(a2))
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), a2);
  }
}

void *stack_reallocate(void *ptr, size_t size, uint64_t a3, uint64_t a4)
{
  void *v7;
  void *v8;
  size_t v9;

  if (*(_QWORD *)a4 > (unint64_t)ptr || *(_QWORD *)(a4 + 16) <= (unint64_t)ptr)
    return malloc_type_zone_realloc(*(malloc_zone_t **)(a4 + 32), ptr, size, 0xB8CCCAE5uLL);
  v7 = malloc_type_zone_malloc(*(malloc_zone_t **)(a4 + 32), size, 0x12D985A7uLL);
  v8 = v7;
  if (v7)
  {
    if (*(_QWORD *)(a4 + 16) - (_QWORD)ptr >= size)
      v9 = size;
    else
      v9 = *(_QWORD *)(a4 + 16) - (_QWORD)ptr;
    memcpy(v7, ptr, v9);
    ++*(_QWORD *)(a4 + 24);
  }
  return v8;
}

uint64_t computePathFS(uint64_t a1, unint64_t *a2, int64_t *a3, unsigned int *a4)
{
  unsigned int Path;
  uint64_t v9;
  unint64_t v11;
  int v12;
  unint64_t v13;
  uint64_t (*v14)(void);
  int64_t v15;
  unint64_t v16;
  uint64_t v17;
  int v18;
  NSObject *v19;
  uint64_t i;
  int v21;
  unint64_t v22;
  unint64_t v23;
  char *v24;
  char *v25;
  const char *v26;
  uint64_t v27;
  char *v28;
  char *v29;
  const char *v30;
  uint64_t v31;
  uint8_t buf[4];
  const char *v33;
  __int16 v34;
  int v35;
  __int16 v36;
  int v37;
  __int16 v38;
  int v39;
  __int16 v40;
  unint64_t v41;
  __int16 v42;
  unint64_t v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  Path = directoryStoreWriterGetPath(*(_QWORD *)(a1 + 6624), *a2, (uint64_t)a3);
  if (Path)
  {
LABEL_2:
    v9 = 0;
    *a4 = Path;
    return v9;
  }
  v11 = a2[3];
  if (!v11)
  {
    v14 = *(uint64_t (**)(void))(*(_QWORD *)(a1 + 1416) + 128);
    if (v14)
    {
      v15 = v14();
      v16 = *a2;
      if (v15 > 0)
      {
        if (v16 != 2)
        {
          *a3 = v15;
          if (v15 == 2)
          {
            Path = 1;
          }
          else
          {
            Path = directoryStoreWriterGetPath(*(_QWORD *)(a1 + 6624), v15, (uint64_t)(a3 + 1)) + 1;
            if (Path < 2)
              goto LABEL_26;
          }
          for (i = 0; i != Path; ++i)
          {
            if (a3[i] <= 0)
            {
              v28 = __si_assert_copy_extra_521(-1);
              v29 = v28;
              v30 = "";
              if (v28)
                v30 = v28;
              __message_assert("%s:%u: failed assertion '%s' %s Got parent[%d] with id %lld depth: %d", "SIStoring.c", 1530, "newpath[i] > 0", v30, i, a3[i], Path);
              free(v29);
              if (__valid_fs(-1))
                v31 = 2989;
              else
                v31 = 3072;
              *(_DWORD *)v31 = -559038737;
              abort();
            }
          }
          goto LABEL_2;
        }
LABEL_27:
        v9 = 0;
        *a3 = 0;
        return v9;
      }
      if (v16 == 2)
        goto LABEL_27;
    }
    else if (*a2 == 2)
    {
      goto LABEL_27;
    }
    v9 = *__error();
    v18 = *__error();
    v19 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      v21 = *__error();
      v22 = *a2;
      v23 = a2[3];
      *(_DWORD *)buf = 136316418;
      v33 = "computePathFS";
      v34 = 1024;
      v35 = 1515;
      v36 = 1024;
      v37 = v21;
      v38 = 1024;
      v39 = 1515;
      v40 = 2048;
      v41 = v22;
      v42 = 2048;
      v43 = v23;
      _os_log_error_impl(&dword_1B8270000, v19, OS_LOG_TYPE_ERROR, "%s:%d: SIPersistentIDStoreGetParentForOid error:%d at:%d oid:%lld parent:%lld", buf, 0x32u);
    }
    *__error() = v18;
    return v9;
  }
  v12 = directoryStoreWriterGetPath(*(_QWORD *)(a1 + 6624), v11, (uint64_t)(a3 + 1));
  v13 = a2[3];
  if (!v12)
  {
    if (v13 != 2)
      goto LABEL_26;
    *a3 = 2;
    Path = 1;
LABEL_15:
    v17 = 0;
    do
    {
      if (a3[v17] <= 0)
      {
        v24 = __si_assert_copy_extra_521(-1);
        v25 = v24;
        v26 = "";
        if (v24)
          v26 = v24;
        __message_assert("%s:%u: failed assertion '%s' %s Got parent[%d] with id %lld depth: %d", "SIStoring.c", 1508, "newpath[i] > 0", v26, v17, a3[v17], Path);
        free(v25);
        if (__valid_fs(-1))
          v27 = 2989;
        else
          v27 = 3072;
        *(_DWORD *)v27 = -559038737;
        abort();
      }
      ++v17;
    }
    while (Path != v17);
    goto LABEL_2;
  }
  *a3 = v13;
  Path = v12 + 1;
  if (v12 != -1)
    goto LABEL_15;
LABEL_26:
  if (*a2 == 2)
    goto LABEL_27;
  return psid_lookupPath(a1, (uint64_t *)a2, 0, 0, 0, a4, (uint64_t)a3);
}

uint64_t computePath(uint64_t a1)
{
  uint64_t v1;
  const __CFString *v2;
  const __CFString *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const __CFString *v8;
  const __CFString *v9;
  _QWORD *v10;
  _QWORD *v11;
  int64_t *v12;
  int64_t *v13;
  unint64_t **v14;
  unint64_t **v15;
  unint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  int Path;
  uint64_t v20;
  int v21;
  int64_t v22;
  unint64_t *v23;
  unint64_t v24;
  int v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int64_t v29;
  unint64_t cs_orphan_oid;
  int64_t v31;
  uint64_t v34;
  _QWORD *v35;
  int64_t v36;
  uint64_t v37;
  int v39;
  uint64_t v40;
  int v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  int v45;
  unsigned int v46;
  unint64_t *v47;
  uint64_t v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  unint64_t v53;
  const __CFSet *v54;
  unint64_t v55;
  const __CFSet *v56;
  int v57;
  NSObject *v58;
  int v60;
  unint64_t v61;
  unint64_t v62;
  char *v63;
  char *v64;
  const char *v65;
  uint64_t v66;
  char *v67;
  char *v68;
  const char *v69;
  char *v70;
  uint64_t v71;
  char *v72;
  char *v73;
  const char *v74;
  int v75;
  NSObject *v76;
  int v77;
  NSObject *v78;
  NSObject *log;
  uint64_t v80;
  unint64_t *v81;
  int v82;
  _QWORD *v83;
  int64_t v84;
  void *v85;
  unint64_t v86;
  uint64_t v87[512];
  uint8_t buf[4];
  _BYTE v89[30];
  __int16 v90;
  unint64_t v91;
  uint64_t v92;

  v1 = MEMORY[0x1E0C80A78](a1);
  v3 = v2;
  v5 = v4;
  v7 = v6;
  v9 = v8;
  v11 = v10;
  v13 = v12;
  v15 = v14;
  v16 = v1;
  v92 = *MEMORY[0x1E0C80C00];
  bzero(&v86, 0x1008uLL);
  v82 = 0;
  v17 = *v15;
  if (!v9 || !v7 || !v5)
  {
    v20 = computePathFS(v16, *v15, v13, (unsigned int *)&v82);
    Path = 0;
    if ((_DWORD)v20)
      return v20;
LABEL_86:
    v46 = v82;
    *v11 = v82;
    v47 = *v15;
    if (v46)
    {
      v48 = *v13;
      v47[3] = *v13;
      if (!v48 && *v47 != 2)
      {
        v72 = __si_assert_copy_extra_521(-1);
        v73 = v72;
        v74 = "";
        if (v72)
          v74 = v72;
        __message_assert("%s:%u: failed assertion '%s' %s ", "SIStoring.c", 869, "dbo->parent_oid||dbo->oid==2", v74);
        v70 = v73;
        goto LABEL_127;
      }
      if (Path && v87[0] != *v13)
      {
        v86 = *v47;
        v49 = Path + 1;
        directoryStoreSetParentForMove(*(_QWORD *)(v16 + 6624), *v47, v48);
        v50 = *(_QWORD *)(v16 + 6632);
        if (v50)
          directoryOverlayMoveDirectory(v50, Path + 1, (uint64_t *)&v86, v46, v13);
        v51 = *(_QWORD *)(v16 + 1384);
        v52 = *(_QWORD *)(v16 + 1392);
        if (*(_DWORD *)(v52 + 8))
        {
          v53 = 0;
          do
          {
            v54 = *(const __CFSet **)(v16 + 6640);
            if (!v54 || !CFSetContainsValue(v54, (const void *)*(int *)(*(_QWORD *)(*(_QWORD *)v52 + 8 * v53) + 48)))
              _CIMoveDirectory(*(_QWORD *)(*(_QWORD *)v52 + 8 * v53), v49, (uint64_t *)&v86, v46, (uint64_t)v13);
            ++v53;
          }
          while (v53 < *(unsigned int *)(v52 + 8));
        }
        if (*(_DWORD *)(v51 + 8))
        {
          v55 = 0;
          do
          {
            v56 = *(const __CFSet **)(v16 + 6640);
            if (!v56 || !CFSetContainsValue(v56, (const void *)*(int *)(*(_QWORD *)(*(_QWORD *)v51 + 8 * v55) + 48)))
              _CIMoveDirectory(*(_QWORD *)(*(_QWORD *)v51 + 8 * v55), v49, (uint64_t *)&v86, v46, (uint64_t)v13);
            ++v55;
          }
          while (v55 < *(unsigned int *)(v51 + 8));
        }
      }
    }
    if (v47[3] || !**(_DWORD **)(v16 + 6592))
    {
      v20 = 0;
      *v11 = v46;
      return v20;
    }
    return 89;
  }
  v18 = *v17;
  if (v3 && CFStringHasSuffix(v3, CFSTR("NSFileProviderRootContainerItemIdentifier")))
  {
    *v13 = 2;
    Path = directoryStoreWriterGetPath(*(_QWORD *)(v16 + 6624), v18, (uint64_t)v87);
    LODWORD(v18) = 1;
  }
  else
  {
    v21 = directoryStoreWriterGetPath(*(_QWORD *)(v16 + 6624), v18, (uint64_t)v13);
    if (!v21)
    {
      Path = 0;
      v23 = v17 + 3;
      v24 = v17[3];
      if (!v24)
      {
        LODWORD(v18) = 0;
        v20 = 0;
        goto LABEL_74;
      }
      goto LABEL_15;
    }
    LODWORD(v18) = v21;
    Path = 0;
  }
  v23 = v17 + 3;
  v22 = v17[3];
  if (v22 == *v13)
  {
LABEL_79:
    if (v22 == 2)
    {
      v20 = 0;
      goto LABEL_84;
    }
    LODWORD(v85) = 0;
    v44 = si_directoryStoreEnsurePath(v16);
    v45 = (int)v85;
    if ((_DWORD)v85 != 22)
    {
      if (!(_DWORD)v85)
      {
        v20 = 0;
        LODWORD(v18) = v44 + 1;
        goto LABEL_84;
      }
      v57 = *__error();
      v58 = _SILogForLogForCategory(4);
      if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
      {
        v60 = *__error();
        v61 = *v17;
        v62 = v17[3];
        *(_DWORD *)buf = 136316162;
        *(_QWORD *)v89 = "computePathFP";
        *(_WORD *)&v89[8] = 1024;
        *(_DWORD *)&v89[10] = 1464;
        *(_WORD *)&v89[14] = 1024;
        *(_DWORD *)&v89[16] = v60;
        *(_WORD *)&v89[20] = 2048;
        *(_QWORD *)&v89[22] = v61;
        v90 = 2048;
        v91 = v62;
        _os_log_error_impl(&dword_1B8270000, v58, OS_LOG_TYPE_ERROR, "%s:%d: error: %d oid: %lld parent: %lld", buf, 0x2Cu);
      }
      *__error() = v57;
    }
    if (v45 == 60)
      return 60;
    else
      return 22;
  }
  if (!v22)
    goto LABEL_78;
  __memcpy_chk();
  v24 = *v23;
  Path = v18;
LABEL_15:
  v25 = directoryStoreWriterGetPath(*(_QWORD *)(v16 + 6624), v24, (uint64_t)(v13 + 1));
  v26 = *v23;
  if (v25)
  {
    *v13 = v26;
    LODWORD(v18) = v25 + 1;
    if (v25 == -1)
      goto LABEL_25;
LABEL_21:
    v27 = 0;
    do
    {
      if (v13[v27] <= 0)
      {
        v63 = __si_assert_copy_extra_521(-1);
        v64 = v63;
        v65 = "";
        if (v63)
          v65 = v63;
        __message_assert("%s:%u: failed assertion '%s' %s Got parent[%d] with id %lld depth: %d", "SIStoring.c", 1448, "newpath[i] > 0", v65, v27, v13[v27], v18);
        free(v64);
        if (__valid_fs(-1))
          v66 = 2989;
        else
          v66 = 3072;
        *(_DWORD *)v66 = -559038737;
        abort();
      }
      ++v27;
    }
    while (v18 != v27);
    goto LABEL_26;
  }
  if (!v26)
  {
LABEL_25:
    LODWORD(v18) = 0;
LABEL_26:
    v20 = 0;
    goto LABEL_74;
  }
  if (v26 == 2)
  {
    *v13 = 2;
    LODWORD(v18) = 1;
    goto LABEL_21;
  }
  v28 = **v15;
  v81 = *v15;
  v29 = (*v15)[3];
  v84 = v29;
  v85 = v81;
  if (dword_1EF19FC9C >= 5)
  {
    v75 = *__error();
    v76 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v76, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134218240;
      *(_QWORD *)v89 = v28;
      *(_WORD *)&v89[8] = 2048;
      *(_QWORD *)&v89[10] = v29;
      _os_log_impl(&dword_1B8270000, v76, OS_LOG_TYPE_DEFAULT, "lookupPathByDBO enter oid: %lld  parent: %lld", buf, 0x16u);
    }
    *__error() = v75;
  }
  if (v28 < 3)
  {
    LODWORD(v18) = 0;
    v20 = 0;
    goto LABEL_68;
  }
  v80 = v28;
  cs_orphan_oid = si_get_cs_orphan_oid(v16);
  v18 = 0;
  while (1)
  {
    v31 = v84;
    if (v84 == 2)
    {
      v20 = 0;
      v13[(int)v18] = 2;
      LODWORD(v18) = v18 + 1;
      goto LABEL_67;
    }
    if (v84 >= 1 && v84 != cs_orphan_oid)
      break;
    v13[(int)v18] = cs_orphan_oid;
    v84 = 2;
    v18 = (v18 + 1);
LABEL_59:
    if ((int)v18 > 511)
    {
      v20 = 22;
      goto LABEL_67;
    }
  }
  v83 = 0;
  if (db_get_obj(*(_DWORD **)(v16 + 1184), v84, (void **)&v83, 0))
  {
    v34 = forceToOrphanParent(v16, (uint64_t *)&v85, (unint64_t *)&v84, v9, v85 == v81);
    if ((_DWORD)v34)
    {
      v20 = v34;
      LODWORD(v43) = v18;
LABEL_66:
      LODWORD(v18) = v43;
      goto LABEL_67;
    }
    goto LABEL_52;
  }
  if (dword_1EF19FC9C >= 5)
  {
    v41 = *__error();
    log = _SILogForLogForCategory(4);
    if (os_log_type_enabled(log, OS_LOG_TYPE_DEFAULT))
    {
      v42 = v83[3];
      *(_DWORD *)buf = 134218496;
      *(_QWORD *)v89 = v80;
      *(_WORD *)&v89[8] = 2048;
      *(_QWORD *)&v89[10] = v31;
      *(_WORD *)&v89[18] = 2048;
      *(_QWORD *)&v89[20] = v42;
      _os_log_impl(&dword_1B8270000, log, OS_LOG_TYPE_DEFAULT, "lookupPathByDBO oid: %lld p1: %lld p2: %lld", buf, 0x20u);
    }
    *__error() = v41;
  }
  if (v85 != v81)
    free(v85);
  v35 = v83;
  v43 = (int)v18 + 1;
  v13[(int)v18] = v31;
  v36 = v35[3];
  v84 = v36;
  v85 = v35;
  if (v36 <= 0)
  {
    v37 = forceToOrphanParent(v16, (uint64_t *)&v85, (unint64_t *)&v84, v9, 0);
    if ((_DWORD)v37)
    {
      v20 = v37;
      goto LABEL_66;
    }
    v36 = v84;
  }
  if (v36 == 2 || v36 == cs_orphan_oid)
    goto LABEL_58;
  v39 = directoryStoreWriterGetPath(*(_QWORD *)(v16 + 6624), v36, (uint64_t)&v13[v43]);
  v18 = (v39 + v43);
  if (!v39)
  {
LABEL_52:
    if ((_DWORD)v18)
    {
      v40 = 0;
      while (v13[v40] > 0)
      {
        if (v18 == ++v40)
        {
          v43 = v18;
          goto LABEL_58;
        }
      }
      v67 = __si_assert_copy_extra_521(-1);
      v68 = v67;
      v69 = "";
      if (v67)
        v69 = v67;
      __message_assert("%s:%u: failed assertion '%s' %s Got parent[%d] with id %lld depth: %d", "SIStoring.c", 1393, "newpath[i] > 0", v69, v40, v13[v40], v18);
      v70 = v68;
LABEL_127:
      free(v70);
      if (__valid_fs(-1))
        v71 = 2989;
      else
        v71 = 3072;
      *(_DWORD *)v71 = -559038737;
      abort();
    }
    v43 = 0;
LABEL_58:
    v18 = v43;
    goto LABEL_59;
  }
  v20 = 0;
LABEL_67:
  v28 = v80;
LABEL_68:
  if (v85 != v81)
    free(v85);
  if ((_DWORD)v20)
  {
    if (dword_1EF19FC9C >= 5)
    {
      v77 = *__error();
      v78 = _SILogForLogForCategory(4);
      if (os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109632;
        *(_DWORD *)v89 = v20;
        *(_WORD *)&v89[4] = 2048;
        *(_QWORD *)&v89[6] = v28;
        *(_WORD *)&v89[14] = 2048;
        *(_QWORD *)&v89[16] = v84;
        _os_log_impl(&dword_1B8270000, v78, OS_LOG_TYPE_DEFAULT, "lookupPathByDBO error: %d oid: %lld  parent: %lld", buf, 0x1Cu);
      }
      LODWORD(v18) = 0;
      *__error() = v77;
    }
    else
    {
      LODWORD(v18) = 0;
    }
  }
  v17 = *v15;
LABEL_74:
  if (v20 | v18)
  {
    if ((_DWORD)v20)
      goto LABEL_84;
    goto LABEL_78;
  }
  LODWORD(v18) = 0;
  if (v17[3] == 2)
  {
LABEL_78:
    v22 = *v13;
    goto LABEL_79;
  }
  v20 = 2;
LABEL_84:
  if (!v17[3] && **(_DWORD **)(v16 + 6592))
    return 89;
  v82 = v18;
  if (!(_DWORD)v20)
    goto LABEL_86;
  return v20;
}

uint64_t si_text_store_put(uint64_t a1)
{
  uint64_t v1;
  const __CFString *v2;
  const __CFString *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  CFIndex Length;
  CFIndex v8;
  const char *CStringPtr;
  UInt8 *v10;
  _BOOL4 v11;
  const void *v12;
  unint64_t v13;
  int v14;
  NSObject *v15;
  os_log_type_t v16;
  uint64_t v17;
  int v18;
  NSObject *v19;
  os_log_type_t v20;
  int v21;
  NSObject *v22;
  os_log_type_t v23;
  const char *v24;
  uint8_t *v25;
  int v27;
  NSObject *v28;
  CFIndex usedBufLen;
  _QWORD v30[2];
  uint8_t buf[2];
  int v32;
  const char *v33;
  __int16 v34;
  uint64_t v35;
  _OWORD v36[32];
  uint64_t v37;
  CFRange v38;

  v1 = MEMORY[0x1E0C80A78](a1);
  v3 = v2;
  v5 = v4;
  v6 = v1;
  v37 = *MEMORY[0x1E0C80C00];
  Length = CFStringGetLength(v2);
  if (!Length)
  {
    v21 = *__error();
    v22 = _SILogForLogForCategory(8);
    v23 = 2 * (dword_1EF19FCAC < 4);
    if (!os_log_type_enabled(v22, v23))
    {
LABEL_17:
      *__error() = v21;
      return 4294967274;
    }
    *(_WORD *)buf = 0;
    v24 = "Could not get string length";
    v25 = buf;
LABEL_16:
    _os_log_impl(&dword_1B8270000, v22, v23, v24, v25, 2u);
    goto LABEL_17;
  }
  v8 = Length;
  usedBufLen = 0;
  bzero(buf, 0x10000uLL);
  CStringPtr = CFStringGetCStringPtr(v3, 0x8000100u);
  if (!CStringPtr)
  {
    CStringPtr = CFStringGetCStringPtr(v3, 0x600u);
    if (!CStringPtr)
    {
      v11 = ((3 * v8) & 0xFFFFFFFFFFFF0000) != 0;
      if ((unint64_t)(3 * v8) < 0x10000)
      {
        v10 = buf;
      }
      else
      {
        v10 = (UInt8 *)malloc_type_zone_malloc((malloc_zone_t *)indexingZone, 3 * v8, 0x1064BE16uLL);
        if (!v10)
        {
          v21 = *__error();
          v22 = _SILogForLogForCategory(8);
          v23 = 2 * (dword_1EF19FCAC < 4);
          if (!os_log_type_enabled(v22, v23))
            goto LABEL_17;
          LOWORD(v36[0]) = 0;
          v24 = "Could not get string bytes";
          v25 = (uint8_t *)v36;
          goto LABEL_16;
        }
      }
      v38.location = 0;
      v38.length = v8;
      CFStringGetBytes(v3, v38, 0x8000100u, 0, 0, v10, 3 * v8, &usedBufLen);
      goto LABEL_5;
    }
  }
  v10 = (UInt8 *)CStringPtr;
  v11 = 0;
  usedBufLen = strlen(CStringPtr);
LABEL_5:
  if (dword_1EF19FCAC >= 5)
  {
    v27 = *__error();
    v28 = _SILogForLogForCategory(8);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v36[0]) = 68157954;
      DWORD1(v36[0]) = usedBufLen;
      WORD4(v36[0]) = 2080;
      *(_QWORD *)((char *)v36 + 10) = v10;
      _os_log_impl(&dword_1B8270000, v28, OS_LOG_TYPE_DEFAULT, "Put document: %.*s", (uint8_t *)v36, 0x12u);
    }
    *__error() = v27;
  }
  v12 = *(const void **)(v6 + 1296);
  v13 = usedBufLen;
  memset(v36, 0, sizeof(v36));
  snprintf((char *)v36, 0x200uLL, "doc_store_put_document(%p, %lld)", v12, v5);
  v30[0] = 0;
  v30[1] = 0;
  ScopeLogger::ScopeLogger((ScopeLogger *)v30, (const char *)v36);
  if (v12)
  {
    if (v13 >= 0x3E9)
    {
      v14 = *__error();
      v15 = _SILogForLogForCategory(8);
      v16 = 2 * (dword_1EF19FCAC < 4);
      if (os_log_type_enabled(v15, v16))
      {
        v32 = 134218240;
        v33 = (const char *)v13;
        v34 = 2048;
        v35 = 1000;
        _os_log_impl(&dword_1B8270000, v15, v16, "Input doc store string length is %zu, trim down to %zu limit", (uint8_t *)&v32, 0x16u);
      }
      *__error() = v14;
      v13 = 1000;
    }
    v17 = DocStore::PutDocument((uint64_t)v12, v5, (uint64_t)v10, (char *)v13);
    v18 = *__error();
    v19 = _SILogForLogForCategory(8);
    v20 = 2 * (dword_1EF19FCAC < 4);
    if (os_log_type_enabled(v19, v20))
    {
      v32 = 136315394;
      v33 = "doc_store_put_document";
      v34 = 1024;
      LODWORD(v35) = v17;
      _os_log_impl(&dword_1B8270000, v19, v20, "%s returns %d\n", (uint8_t *)&v32, 0x12u);
    }
    *__error() = v18;
  }
  else
  {
    v17 = 4294967282;
  }
  ScopeLogger::~ScopeLogger((ScopeLogger *)v30);
  if (v11)
    free(v10);
  return v17;
}

void si_setCacheEntry(CFDictionaryRef *a1, int a2)
{
  CFDictionaryRef v3;
  const void *Value;
  CFDictionaryRef v5;
  int v6;
  NSObject *v7;
  int v8;
  NSObject *v9;
  int v10;
  const void *v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (!a2)
  {
    if (dword_1EF19FCC0 >= 5)
    {
      v6 = *__error();
      v7 = _SILogForLogForCategory(13);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        v10 = 67109120;
        LODWORD(v11) = qos_class_self();
        _os_log_impl(&dword_1B8270000, v7, OS_LOG_TYPE_DEFAULT, "si_setCacheEntry at qos 0x%x", (uint8_t *)&v10, 8u);
      }
      *__error() = v6;
    }
    if (_os_feature_enabled_impl())
    {
      v3 = *a1;
      Value = CFDictionaryGetValue(a1[1], CFSTR("_kMDItemBundleID"));
      if (SpotlightCacheBundleID())
      {
        if (!*((_QWORD *)v3 + 161))
          *((_QWORD *)v3 + 161) = MDTrieCreate();
        SpotlightCacheInsertEntry();
      }
      else if (dword_1EF19FCB0 >= 5)
      {
        v8 = *__error();
        v9 = _SILogForLogForCategory(9);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          v10 = 138412290;
          v11 = Value;
          _os_log_impl(&dword_1B8270000, v9, OS_LOG_TYPE_DEFAULT, "SpotlightCache insert do not support bundleID %@", (uint8_t *)&v10, 0xCu);
        }
        *__error() = v8;
      }
    }
  }
  v5 = a1[1];
  if (v5)
    CFRelease(v5);
  free(a1);
}

void __si_writeBackAndIndexWithLiveQueryToggle_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  if (*(_BYTE *)(a1 + 80) && (*(_BYTE *)(a1 + 73) & 0x20) != 0)
  {
    v4 = **(_QWORD **)(a1 + 40);
    if (!(*(unsigned __int8 *)(a1 + 81) | *(unsigned __int8 *)(a1 + 82)))
      objectHasContent(*(int **)(*(_QWORD *)(a1 + 64) + 1184), v4);
    *(_QWORD *)(v4 + 32) = a2;
    si_perform_livequeries_updates(*(_QWORD *)(a1 + 64));
  }
}

BOOL shrinkLocalizedField(uint64_t a1, uint64_t *a2, char *a3)
{
  uint64_t v6;
  const __CFAllocator *v7;
  CFDictionaryRef v8;
  CFStringRef v9;
  int v11[2];
  int v12[2];

  *(_QWORD *)v11 = 0;
  *(_QWORD *)v12 = 0;
  if (db_get_field(*(int **)(a1 + 1184), *a2, a3, (unint64_t *)v12, v11))
    return 0;
  if (*(_DWORD *)(*(_QWORD *)v12 + 8) <= 0x1000u
    || **(_WORD **)v12 != 11
    || (*(_WORD *)(*(_QWORD *)v12 + 2) & 0x90) != 0x80)
  {
    return db_delete_field(*(int **)(a1 + 1184), a2, a3) == 0;
  }
  v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v8 = _decodeSDBField(*(_QWORD *)(a1 + 1184), *(unsigned __int16 **)v12, *(unsigned __int8 **)v11, 0, 0, 0, 0, (CFAllocatorRef)*MEMORY[0x1E0C9AE00]);
  v9 = CFStringCreateWithCString(v7, a3, 0x8000100u);
  v6 = 1;
  setOneLocalizedFieldWithFlags(*(_QWORD *)(a1 + 1184));
  CFRelease(v8);
  CFRelease(v9);
  return v6;
}

uint64_t forceToOrphanParent(unint64_t a1, uint64_t *a2, unint64_t *a3, const __CFString *a4, int a5)
{
  unint64_t v5;
  unint64_t v11;
  uint64_t v12;
  unint64_t cs_orphan_oid;
  NSObject *v15;
  os_log_type_t v16;
  uint64_t *v17;
  __CFDictionary *v18;
  _DWORD *LiveIndex;
  uint64_t v20;
  uint64_t Mutable;
  int v22;
  char v23;
  char v24;
  char v25;
  _BYTE buf[22];
  __int16 v27;
  unint64_t v28;
  __int16 v29;
  int v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v5 = *a3;
  if (*a3 - 1 < 2)
    return 22;
  v11 = *(_QWORD *)*a2;
  v12 = *(_QWORD *)(*a2 + 24);
  cs_orphan_oid = si_get_cs_orphan_oid(a1);
  if (!cs_orphan_oid)
    return 2;
  if (v11 == cs_orphan_oid)
    return 22;
  *a3 = cs_orphan_oid;
  if (v12 != cs_orphan_oid)
  {
    *(_QWORD *)(*a2 + 24) = cs_orphan_oid;
    v22 = *__error();
    v15 = _SILogForLogForCategory(4);
    v16 = dword_1EF19FC9C < 3;
    if (os_log_type_enabled(v15, (os_log_type_t)(dword_1EF19FC9C < 3)))
    {
      *(_DWORD *)buf = 134218752;
      *(_QWORD *)&buf[4] = v11;
      *(_WORD *)&buf[12] = 2048;
      *(_QWORD *)&buf[14] = v12;
      v27 = 2048;
      v28 = v5;
      v29 = 1024;
      v30 = a5;
      _os_log_impl(&dword_1B8270000, v15, v16, "*warn* forceToOrphanParent oid: %lld dbo parent oid: %lld parent: %lld original: %d", buf, 0x26u);
    }
    *__error() = v22;
    if ((a5 & 1) == 0)
    {
      v17 = (uint64_t *)*a2;
      v23 = 0;
      si_populategroup(a1, a2, a4, 0, 1, &v24, &v23, &v25);
      v18 = decodeDBOToDictionary(*(int **)(a1 + 1184), (uint64_t)v17, 0, 0x2000, 2, *(_DWORD *)(a1 + 2028), *(_DWORD *)(a1 + 2060), 1, 1, (CFAllocatorRef)*MEMORY[0x1E0C9AE00]);
      *(_QWORD *)buf = *a3;
      *(_QWORD *)&buf[8] = 2;
      LiveIndex = si_getLiveIndex(*(_QWORD *)(a1 + 1384));
      _CIUpdateContent((uint64_t)LiveIndex, 2, buf, 0, 0, *v17, v23, 0, 0.0, v18, 0, v17 + 4, 0, 0, 0, 0, 0, 0, 0,
        0,
        1u,
        0);
      CFRelease(v18);
    }
    db_update_obj(*(int **)(a1 + 1184), *a2, 0);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 304));
    v20 = *(_QWORD *)(a1 + 312);
    if (v20)
    {
      pthread_rwlock_wrlock((pthread_rwlock_t *)(v20 + 16));
      SIValueSet<unsigned long long>::SIValueSetInsert((unint64_t *)(v20 + 216), v11);
      pthread_rwlock_unlock((pthread_rwlock_t *)(v20 + 16));
    }
    else
    {
      Mutable = RLEOIDArrayCreateMutable((const __CFAllocator *)*MEMORY[0x1E0C9AE00]);
      *(_QWORD *)(a1 + 312) = Mutable;
      pthread_rwlock_wrlock((pthread_rwlock_t *)(Mutable + 16));
      SIValueSet<unsigned long long>::SIValueSetInsert((unint64_t *)(Mutable + 216), v11);
      pthread_rwlock_unlock((pthread_rwlock_t *)(Mutable + 16));
      si_enqueue_work(*(_QWORD *)(a1 + 1056), (uint64_t)fixupInflightOrphanItems, a1);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 304));
  }
  return 0;
}

void fixupInflightOrphanItems(unint64_t a1, int a2)
{
  os_unfair_lock_s *v3;
  const void *v4;

  if (!a2)
  {
    v3 = (os_unfair_lock_s *)(a1 + 304);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 304));
    v4 = *(const void **)(a1 + 312);
    if (v4)
    {
      *(_QWORD *)(a1 + 312) = 0;
      os_unfair_lock_unlock(v3);
      fixupOrphanArray(a1, (uint64_t)v4, 1);
      CFRelease(v4);
    }
    else
    {
      os_unfair_lock_unlock(v3);
    }
  }
}

int *si_updateIndexForPathRepair(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  int *result;
  char v11;

  if (si_updateIndexForPathRepair_onceToken != -1)
    dispatch_once(&si_updateIndexForPathRepair_onceToken, &__block_literal_global_56);
  result = ContentIndexUpdatePath(a2, *(_QWORD *)(a3 + 32), a5, a4, 0, 0);
  v11 = atomic_load((unsigned int *)(a2 + 28));
  if ((v11 & 2) == 0 && !*(_BYTE *)(a2 + 15163))
  {
    if (*(_BYTE *)(a2 + 16392))
      return (int *)_CIFlushCache(a2, 0, (uint64_t)lowDiskSpaceCallback, a1, (uint64_t)&__block_literal_global_58_6847);
  }
  return result;
}

CFDictionaryRef __si_updateIndexForPathRepair_block_invoke()
{
  CFDictionaryRef result;

  result = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  si_updateIndexForPathRepair_emptyDict = (uint64_t)result;
  return result;
}

void si_flush_index_ctx_free(uint64_t a1, char a2)
{
  NSObject *v4;
  unsigned int *v5;

  if (a1)
  {
    v4 = *(NSObject **)(a1 + 40);
    if (v4)
    {
      dispatch_resume(v4);
      dispatch_release(*(dispatch_object_t *)(a1 + 40));
      *(_QWORD *)(a1 + 40) = 0;
    }
    si_power_info_cleanup(a1 + 48, *(_QWORD *)a1, a2);
    v5 = *(unsigned int **)(a1 + 88);
    if (v5)
      si_scheduler_resume_with_token(v5);
    free((void *)a1);
  }
}

uint64_t _si_next_index_id(os_unfair_lock_s *a1, uint64_t a2, int a3, char a4)
{
  uint64_t os_unfair_lock_opaque;
  int v9;
  int v10;
  NSObject *v11;
  uint32_t v12;
  const char *v13;
  CFNumberRef v14;
  int valuePtr;
  uint8_t buf[4];
  uint32_t v18;
  __int16 v19;
  int v20;
  __int16 v21;
  int v22;
  __int16 v23;
  const char *v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  valuePtr = 0;
  if ((a4 & 1) == 0)
    os_unfair_lock_lock(a1 + 365);
  os_unfair_lock_opaque = a1[364]._os_unfair_lock_opaque;
  if (!(_DWORD)a2)
  {
    a1[364]._os_unfair_lock_opaque = os_unfair_lock_opaque + 1;
    v9 = 1;
    if (!a3)
      goto LABEL_10;
    valuePtr = 1;
LABEL_9:
    v9 = 0;
LABEL_10:
    if ((a4 & 1) != 0)
      goto LABEL_12;
    goto LABEL_11;
  }
  if (os_unfair_lock_opaque < a2)
  {
    a1[364]._os_unfair_lock_opaque = a2 + 1;
    v9 = 1;
    os_unfair_lock_opaque = a2;
    if (!a3)
      goto LABEL_10;
    valuePtr = 1;
    os_unfair_lock_opaque = a2;
    goto LABEL_9;
  }
  v9 = 1;
  os_unfair_lock_opaque = 1;
  if ((a4 & 1) == 0)
LABEL_11:
    os_unfair_lock_unlock(a1 + 365);
LABEL_12:
  v10 = *__error();
  v11 = _SILogForLogForCategory(10);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    v12 = a1[15]._os_unfair_lock_opaque;
    v13 = "yes";
    *(_DWORD *)buf = 67109890;
    if (v9)
      v13 = "no";
    v18 = v12;
    v19 = 1024;
    v20 = os_unfair_lock_opaque;
    v21 = 1024;
    v22 = a2;
    v23 = 2080;
    v24 = v13;
    _os_log_impl(&dword_1B8270000, v11, OS_LOG_TYPE_DEFAULT, "index[%u] indexID: %u for %u update: %s", buf, 0x1Eu);
  }
  *__error() = v10;
  if ((v9 & 1) == 0)
  {
    v14 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, &valuePtr);
    SISetProperty((uint64_t)a1, CFSTR("kSINextIndexId"), v14);
    CFRelease(v14);
  }
  return os_unfair_lock_opaque;
}

void _swapIndex(uint64_t *a1, int a2)
{
  int v4;
  NSObject *v5;
  os_log_type_t v6;
  uint64_t v7;
  int v8;
  NSObject *v9;
  os_log_type_t v10;
  int v11;
  char v12;
  uint64_t v13;
  uint64_t v14;
  int **v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char v19;
  uint64_t v20;
  uint64_t v21;
  char v22;
  const char *v23;
  unint64_t *v24;
  _BOOL4 v25;
  int v26;
  const __CFAllocator *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  int v35;
  int v36;
  int *v37;
  int v38;
  uint64_t vector_store;
  uint64_t v40;
  uint64_t New;
  _DWORD *v42;
  _DWORD *v43;
  unsigned int v44;
  int *v45;
  int *v46;
  unsigned int v47;
  unsigned int v48;
  char v49;
  uint64_t v50;
  uint64_t v51;
  char v52;
  uint64_t v53;
  const char *v54;
  uint64_t v55;
  uint64_t v56;
  const char *v57;
  const char *v58;
  unsigned int v59;
  unint64_t v60;
  unsigned int *v61;
  unsigned int v62;
  unsigned int *v63;
  char *v64;
  char *v65;
  const char *v66;
  int v67;
  uint64_t v68;
  char *v69;
  const char *v70;
  char *v71;
  char *v72;
  const char *v73;
  uint64_t v74;
  char *v75;
  char *v76;
  const char *v77;
  int v78;
  _BOOL4 v79;
  uint64_t v80;
  uint64_t v81;
  unint64_t *v82;
  const char *v83;
  const __CFString *v84;
  char v85;
  int v86;
  uint64_t v87;
  _QWORD aBlock[6];
  _QWORD v89[5];
  _QWORD v90[5];
  int v91;
  uint8_t buf[4];
  uint64_t *v93;
  uint64_t v94;

  v94 = *MEMORY[0x1E0C80C00];
  v4 = *__error();
  v5 = _SILogForLogForCategory(10);
  v6 = 2 * (dword_1EF19FCB4 < 4);
  if (os_log_type_enabled(v5, v6))
  {
    *(_DWORD *)buf = 134217984;
    v93 = a1;
    _os_log_impl(&dword_1B8270000, v5, v6, "_swapIndex %p\n", buf, 0xCu);
  }
  *__error() = v4;
  if (a2 || (v7 = *a1, *(_BYTE *)(*a1 + 6944)) || *(int *)(v7 + 6960) > 0)
  {
    v8 = *__error();
    v9 = _SILogForLogForCategory(10);
    v10 = 2 * (dword_1EF19FCB4 < 4);
    if (os_log_type_enabled(v9, v10))
    {
      v11 = *(unsigned __int8 *)(*a1 + 6944);
      *(_DWORD *)buf = 67109120;
      LODWORD(v93) = v11;
      _os_log_impl(&dword_1B8270000, v9, v10, "Skipped swapindex %d\n", buf, 8u);
    }
    *__error() = v8;
    goto LABEL_9;
  }
  v14 = *(_QWORD *)(v7 + 1392);
  v15 = (int **)(v7 + 1384);
  _checkIndexSetValidity(*(int **)(v7 + 1384));
  _checkIndexSetValidity(*(int **)(v7 + 1392));
  *((_BYTE *)a1 + 80) = 0;
  v16 = *(unsigned int *)(v14 + 8);
  if (!(_DWORD)v16)
    goto LABEL_19;
  v17 = 0;
  v18 = a1[1];
  while (v18 != *(_QWORD *)(*(_QWORD *)v14 + 8 * v17))
  {
    if (v16 == ++v17)
      goto LABEL_19;
  }
  if (*(_DWORD *)(v18 + 48) == *((_DWORD *)a1 + 5)
    && (v19 = atomic_load((unsigned int *)(v18 + 28)), (v19 & 3) == 0)
    && !*(_BYTE *)(v18 + 15163))
  {
    v23 = "%d.";
    v85 = 1;
    v24 = (unint64_t *)(v7 + 1392);
  }
  else
  {
LABEL_19:
    v14 = (uint64_t)*v15;
    v20 = (*v15)[2];
    if (!(_DWORD)v20)
      goto LABEL_27;
    v17 = 0;
    v21 = a1[1];
    while (v21 != *(_QWORD *)(*(_QWORD *)v14 + 8 * v17))
    {
      if (v20 == ++v17)
        goto LABEL_27;
    }
    if (*(_DWORD *)(v21 + 48) != *((_DWORD *)a1 + 5)
      || (v22 = atomic_load((unsigned int *)(v21 + 28)), (v22 & 3) != 0)
      || *(_BYTE *)(v21 + 15163))
    {
LABEL_27:
      v13 = (uint64_t)a1;
      v12 = 0;
      goto LABEL_10;
    }
    v85 = 0;
    *((_BYTE *)a1 + 80) = 1;
    v23 = "live.%d.";
    v24 = (unint64_t *)(v7 + 1384);
  }
  v91 = 0;
  v25 = 0;
  if (!fd_setDir(*(unsigned int *)(*a1 + 32), &v91))
    goto LABEL_69;
  v82 = v24;
  v83 = v23;
  v26 = ((*(_DWORD *)(v7 + 828) & 1) << 6) ^ 0x50;
  if (*(_BYTE *)(v7 + 2072))
    v26 |= 0x100u;
  if (*(_BYTE *)(v7 + 2073))
    v26 |= 0x400u;
  v86 = v26 | (*(_DWORD *)(v7 + 6584) >> 7) & 0x800;
  v27 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v28 = *(_QWORD *)(v7 + 2400);
  *(_QWORD *)(v7 + 2400) = v28 + 1;
  v84 = CFStringCreateWithFormat(v27, 0, CFSTR("tmp.%ld."), v28);
  v90[0] = MEMORY[0x1E0C809B0];
  v90[1] = 0x40000000;
  v90[2] = ___swapIndex_block_invoke;
  v90[3] = &__block_descriptor_tmp_68;
  v90[4] = v7;
  v29 = *(unsigned int *)(v7 + 32);
  v30 = *(_QWORD *)(*(_QWORD *)v14 + 8 * v17);
  LODWORD(v31) = *(_DWORD *)(v30 + 60);
  if (v31 >= 2)
    v31 = v31;
  else
    v31 = 0;
  v32 = *(_QWORD *)(v30 + 72);
  v33 = v32 + v31;
  v34 = *(_DWORD *)(v30 + 32);
  v35 = *((unsigned __int8 *)a1 + 80);
  v36 = *(_DWORD *)(v7 + 1276);
  v37 = *(int **)(v7 + 1184);
  if (v37)
  {
    v80 = v32 + v31;
    v38 = v34;
    v78 = *((unsigned __int8 *)a1 + 80);
    vector_store = db_get_vector_store(v37);
    v35 = v78;
    v34 = v38;
    v33 = v80;
    v40 = vector_store;
  }
  else
  {
    v40 = 0;
  }
  v89[0] = MEMORY[0x1E0C809B0];
  v89[1] = 0x40000000;
  v89[2] = ___swapIndex_block_invoke_2;
  v89[3] = &__block_descriptor_tmp_70;
  v89[4] = a1;
  New = ContentIndexCreateNew(v29, v84, v33, v34, v86, v35 != 0, v36, v40, (uint64_t)v89, v90);
  CFRelease(v84);
  v42 = (_DWORD *)a1[1];
  *((_BYTE *)a1 + 82) = v42 != si_getLiveIndex(*(_QWORD *)(*a1 + 1384));
  v25 = New != 0;
  if (!New)
  {
    _checkIndexSetValidity(*v15);
    _checkIndexSetValidity(*(int **)(v7 + 1392));
    goto LABEL_68;
  }
  SIActivityJournalNewLiveIndex((os_unfair_lock_s *)(v7 + 2192), *(_DWORD *)(New + 48), *(_QWORD *)(New + 72));
  v43 = *(_DWORD **)(*(_QWORD *)v14 + 8 * v17);
  v44 = v43[15];
  if (v44 < 2)
    v44 = 0;
  _ContentIndexSetPayloadMaxCount(v43, v43[18] + v44, 2952);
  aBlock[0] = MEMORY[0x1E0C809B0];
  aBlock[1] = 0x40000000;
  aBlock[2] = ___swapIndex_block_invoke_3;
  aBlock[3] = &__block_descriptor_tmp_72_6863;
  aBlock[4] = v7;
  aBlock[5] = New;
  ContentIndexSetDirtyCallback(New, aBlock);
  *(_BYTE *)(New + 15161) = 4;
  ContentIndexSetEmergency((int *)New, *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)v14 + 8 * v17) + 36));
  v45 = (int *)ContentIndexListClone((__int128 *)v14);
  v46 = v45;
  v47 = v45[3];
  if (v47 <= v45[2])
  {
    v48 = 2 * v47;
    v45[3] = v48;
    *(_QWORD *)v45 = malloc_type_realloc(*(void **)v45, 8 * v48, 0x2004093837F09uLL);
  }
  v49 = v85 ^ 1;
  if (!(_DWORD)v17)
    v49 = 1;
  if ((v49 & 1) == 0)
  {
    v50 = 0;
    while (1)
    {
      v51 = *(_QWORD *)(*(_QWORD *)v46 + v50);
      v52 = atomic_load((unsigned int *)(v51 + 28));
      if ((v52 & 3) == 0 && !*(_BYTE *)(v51 + 15163))
        break;
      v50 += 8;
      if (8 * v17 == v50)
        goto LABEL_53;
    }
    v64 = __si_assert_copy_extra_521(-1);
    v65 = v64;
    v66 = "";
    if (v64)
      v66 = v64;
    __message_assert("%s:%u: failed assertion '%s' %s ", "SIStoring.c", 2966, "!ContentIndexWritable(indexSet->index[i])", v66);
    goto LABEL_76;
  }
LABEL_53:
  v81 = New;
  v79 = New != 0;
  v53 = v46[2];
  v87 = (v17 + 1);
  v54 = v83;
  if (v87 < v53)
  {
    if ((v85 & 1) != 0)
    {
      v71 = __si_assert_copy_extra_521(-1);
      v72 = v71;
      v73 = "";
      if (v71)
        v73 = v71;
      __message_assert("%s:%u: failed assertion '%s' %s ", "SIStoring.c", 2971, "!found", v73);
      free(v72);
      if (__valid_fs(-1))
        v74 = 2989;
      else
        v74 = 3072;
      *(_DWORD *)v74 = -559038737;
      abort();
    }
    v55 = 8 * v53;
    v56 = 8 * (v53 - 1);
    v54 = v83;
    do
    {
      *(_QWORD *)(*(_QWORD *)v46 + v55) = *(_QWORD *)(*(_QWORD *)v46 + v56);
      bzero(buf, 0x400uLL);
      v57 = fmtcheck(v83, "%i");
      snprintf((char *)buf, 0x400uLL, v57, v53);
      ContentIndexChangePrefix(*(_QWORD *)(*(_QWORD *)v46 + v56));
      v53 = (v53 - 1);
      v55 -= 8;
      v56 -= 8;
    }
    while (v87 < v53);
  }
  bzero(buf, 0x400uLL);
  v58 = fmtcheck(v54, "%i");
  snprintf((char *)buf, 0x400uLL, v58, v87);
  ContentIndexChangePrefix(v81);
  if (*(_QWORD *)(*(_QWORD *)v46 + 8 * v17) != a1[1])
  {
    v69 = __si_assert_copy_extra_521(-1);
    v65 = v69;
    v70 = "";
    if (v69)
      v70 = v69;
    __message_assert("%s:%u: failed assertion '%s' %s ", "SIStoring.c", 2994, "indexSet->index[spot-1]==ctx->idx", v70);
LABEL_76:
    free(v65);
    v67 = -1;
    goto LABEL_77;
  }
  *(_QWORD *)(*(_QWORD *)v46 + 8 * v87) = v81;
  v59 = v46[4];
  if (v59 != -1 && v59 >= v17)
    v46[4] = v59 + 1;
  ++v46[2];
  _checkIndexSetValidity(v46);
  v25 = v79;
  do
  {
    v60 = __ldaxr(v82);
    if (v60 != v14)
    {
      __clrex();
      v75 = __si_assert_copy_extra_521(*(_DWORD *)(v7 + 32));
      v76 = v75;
      v77 = "";
      if (v75)
        v77 = v75;
      __message_assert("%s:%u: failed assertion '%s' %s This should be impossible; this thread is supposed to be  suspended when the oth"
        "er thread changes index sets.",
        "SIStoring.c",
        3000,
        "OSAtomicCompareAndSwapPtrBarrier(oldIndexSet,indexSet,(void* volatile*)indexSetPtr)",
        v77);
      free(v76);
      v67 = *(_DWORD *)(v7 + 32);
LABEL_77:
      if (__valid_fs(v67))
        v68 = 2989;
      else
        v68 = 3072;
      *(_DWORD *)v68 = -559038737;
      abort();
    }
  }
  while (__stlxr((unint64_t)v46, v82));
  si_cleanup(v7, v14);
  v61 = (unsigned int *)(v7 + 1400);
  do
    v62 = __ldxr(v61);
  while (__stxr(v62 + 1, v61));
  _CIDisableUpdates(a1[1]);
  _checkIndexSetValidity(*(int **)(v7 + 1384));
  _checkIndexSetValidity(*(int **)(v7 + 1392));
  si_write_index_state(v7, 1, 0);
LABEL_68:
  fd_resetDir(v91);
LABEL_69:
  si_indexDeleteDeferredItems(v7);
  v63 = (unsigned int *)a1[11];
  if (v63)
    si_scheduler_resume_with_token(v63);
  a1[11] = 0;
  if (v25)
  {
    _swapIndex1(a1);
    a1 = 0;
  }
LABEL_9:
  v12 = a2 != 0;
  v13 = (uint64_t)a1;
LABEL_10:
  si_flush_index_ctx_free(v13, v12);
}

void ___swapIndex_block_invoke(uint64_t a1, const void *a2)
{
  si_collect_block(*(_QWORD *)(a1 + 32), a2);
}

uint64_t ___swapIndex_block_invoke_2(uint64_t a1, uint64_t a2)
{
  return _si_next_index_id(**(os_unfair_lock_s ***)(a1 + 32), a2, 1, 0);
}

uint64_t ___swapIndex_block_invoke_3(uint64_t a1)
{
  return si_set_obj_state(*(os_unfair_lock_s **)(a1 + 32), *(_QWORD *)(a1 + 40));
}

void _swapIndex1(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  int8x16_t *v3;
  uint64_t v4;
  int8x16_t *v5;
  uint64_t v6;
  void (*v7)(uint64_t, _QWORD, const __CFString *, _QWORD *);
  char v8;
  uint64_t v9;
  int v10;
  NSObject *v11;
  uint8_t v12[16];
  _QWORD v13[4];
  __int128 v14;
  int32x2_t v15;
  char v16;

  v1 = (uint64_t)a1;
  v2 = *a1;
  if (*(_BYTE *)(*a1 + 6944) || *(int *)(v2 + 6960) > 0)
  {
    if (dword_1EF19FCB4 >= 5)
    {
      v10 = *__error();
      v11 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)v12 = 0;
        _os_log_impl(&dword_1B8270000, v11, OS_LOG_TYPE_DEFAULT, "Skipped flushing\n", v12, 2u);
      }
      *__error() = v10;
    }
  }
  else
  {
    v3 = (int8x16_t *)malloc_type_calloc(1uLL, 0x90uLL, 0x10B00402663C8FFuLL);
    v4 = (uint64_t)v3;
    v5 = *(int8x16_t **)(v2 + 2360);
    if (v5)
    {
      v3[2].i64[0] = v5[8].i64[1];
      v3[1] = vextq_s8(*v5, *v5, 8uLL);
    }
    si_indexDeleteDeferredItems(v2);
    *(_QWORD *)v4 = v2;
    *(_BYTE *)(v4 + 96) = 1;
    syncIndex(v4, 0);
    if (*(_BYTE *)(v1 + 82))
      si_perform_livequeries_bulk_updates(*(_QWORD *)v1);
    if (!*(_BYTE *)(v2 + 2440) || !*(_BYTE *)(v1 + 80))
    {
      if (gSISystemOnBattery
        && (v6 = *(_QWORD *)(v2 + 2360),
            (v7 = *(void (**)(uint64_t, _QWORD, const __CFString *, _QWORD *))(v6 + 80)) != 0)
        && !*(_BYTE *)(v1 + 83))
      {
        v8 = *(_BYTE *)(v1 + 80);
        v9 = *(_QWORD *)(v6 + 136);
        v13[0] = MEMORY[0x1E0C809B0];
        v13[1] = 0x40000000;
        v13[2] = ___swapIndex1_block_invoke;
        v13[3] = &__block_descriptor_tmp_142_6871;
        v16 = v8;
        v15 = vrev64_s32(*(int32x2_t *)(v1 + 16));
        v14 = *(_OWORD *)(v1 + 24);
        v7(v9, 0, CFSTR("swapIndex"), v13);
      }
      else
      {
        si_enqueue_work_with_qos(*(_QWORD *)(v2 + 1056), 9, (uint64_t)_swapIndex2, v1);
        v1 = 0;
      }
    }
  }
  si_flush_index_ctx_free(v1, 0);
}

void ___swapIndex1_block_invoke(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, NSObject *a5)
{
  _DWORD *v10;

  if (a2)
  {
    v10 = malloc_type_calloc(1uLL, 0x60uLL, 0x10B0040E0DE4348uLL);
    v10[5] = *(_DWORD *)(a1 + 48);
    *((_BYTE *)v10 + 80) = *(_BYTE *)(a1 + 56);
    v10[4] = *(_DWORD *)(a1 + 52);
    *(_QWORD *)v10 = a2;
    *((_QWORD *)v10 + 3) = *(_QWORD *)(a1 + 32);
    *((_QWORD *)v10 + 4) = *(_QWORD *)(a1 + 40);
    *((_BYTE *)v10 + 81) = 0;
    si_power_info_init((uint64_t)(v10 + 12), a3, a4, a5);
    si_enqueue_work_with_qos(*(_QWORD *)(a2 + 1056), 9, (uint64_t)_swapIndex2, (uint64_t)v10);
  }
}

void _swapIndex2(_DWORD *a1, int a2)
{
  uint64_t v4;
  time_t v5;
  int v6;
  time_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  CFSetRef v16;
  uint64_t v17;
  int v18;
  int v19;
  _BOOL4 v20;
  _BOOL4 v21;
  int v22;
  unsigned int v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  NSObject *v27;
  uint64_t v28;
  unint64_t v29;
  __int128 v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  char v37;
  int v38;
  NSObject *v39;
  uint64_t v40;
  unsigned int v41;
  uint64_t v42;
  uint64_t v43;
  char v44;
  void *values;
  int v46;
  __int128 buf;
  BOOL (*v48)(uint64_t);
  uint64_t v49;

  if (a2 || (v4 = *(_QWORD *)a1, *(_BYTE *)(*(_QWORD *)a1 + 6944)) || *(int *)(v4 + 6960) > 0)
  {
    if (dword_1EF19FCB4 >= 5)
    {
      v38 = *__error();
      v39 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf) = 0;
        _os_log_impl(&dword_1B8270000, v39, OS_LOG_TYPE_DEFAULT, "Skipped compacting\n", (uint8_t *)&buf, 2u);
      }
      *__error() = v38;
    }
    goto LABEL_5;
  }
  v5 = time(0);
  v6 = a1[5];
  if (v6)
  {
    v7 = v5;
    v8 = *(_QWORD *)a1;
    v9 = *(_QWORD *)(*(_QWORD *)a1 + 1392);
    v10 = *(unsigned int *)(v9 + 8);
    if ((_DWORD)v10)
    {
      v11 = 0;
      v12 = *(_QWORD *)v9;
      while (*(_DWORD *)(*(_QWORD *)(v12 + 8 * v11) + 48) != v6)
      {
        if (v10 == ++v11)
          goto LABEL_11;
      }
      v14 = 0;
    }
    else
    {
LABEL_11:
      v9 = *(_QWORD *)(v8 + 1384);
      v13 = *(unsigned int *)(v9 + 8);
      if (!(_DWORD)v13)
        goto LABEL_26;
      v11 = 0;
      v12 = *(_QWORD *)v9;
      while (*(_DWORD *)(*(_QWORD *)(v12 + 8 * v11) + 48) != v6)
      {
        if (v13 == ++v11)
          goto LABEL_26;
      }
      v14 = 1;
    }
    v15 = *((_QWORD *)a1 + 1);
    if (v15 == *(_QWORD *)(v12 + 8 * (int)v11) && *(_DWORD *)(v15 + 48) == v6)
    {
      v46 = 0;
      if (!fd_setDir(*(unsigned int *)(v8 + 32), &v46))
      {
LABEL_5:
        si_flush_index_ctx_free((uint64_t)a1, a2 != 0);
        return;
      }
      values = (void *)*(int *)(*((_QWORD *)a1 + 1) + 48);
      v16 = CFSetCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)&values, 1, 0);
      setUpOverlay(*(_QWORD *)a1, v16);
      CFRelease(v16);
      v44 = 0;
      if (gSISystemOnBattery && (*(_BYTE *)(v4 + 6586) & 4) != 0)
      {
        v20 = 1;
      }
      else
      {
        disableProcMon();
        v17 = *((_QWORD *)a1 + 1);
        v18 = (*(_DWORD *)(*(_QWORD *)a1 + 6584) >> 4) & 1;
        *(_QWORD *)&buf = si_compact_lock;
        *((_QWORD *)&buf + 1) = si_compact_unlock;
        v48 = si_compact_cancel;
        v49 = v4;
        v19 = _CICompact(v17, &buf, v18, &v44);
        enableProcMon();
        v20 = v19 == 0;
        if (v19 && v44)
        {
          si_recycleForBadIndex(*(_QWORD *)a1, *((_QWORD *)a1 + 1), (uint64_t)"compact err");
LABEL_48:
          fd_resetDir(v46);
          goto LABEL_5;
        }
      }
      v21 = v20;
      disableProcMon();
      mergeOverlay(*(uint64_t **)a1, 0);
      enableProcMon();
      v22 = count_IndexSet(v9, v11, *(_DWORD *)(*((_QWORD *)a1 + 1) + 44));
      v23 = v22;
      if (v22 <= 5 && (v22 < 3 || gSISystemOnBattery))
      {
        if ((v14 & v21) == 1)
        {
          v40 = *((_QWORD *)a1 + 1);
          v41 = atomic_load((unsigned int *)(v40 + 12));
          if (*(_DWORD *)(v40 + 60) / 0xAu < v41)
          {
            v42 = si_mergeOneIndex(*(_QWORD *)a1, *((_QWORD *)a1 + 1));
            *((_QWORD *)a1 + 1) = v42;
            if (v42)
              a1[5] = *(_DWORD *)(v42 + 48);
          }
        }
      }
      else
      {
        v43 = (int)v11;
        v24 = (char *)malloc_type_calloc(1uLL, 0x460uLL, 0x1070040C187FD8AuLL);
        v25 = *(_QWORD *)a1;
        *(_QWORD *)v24 = *(_QWORD *)a1;
        v26 = (int)(v11 - v23 + 1);
        *((_DWORD *)v24 + 2) = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v9 + 8 * v26) + 48);
        *((_DWORD *)v24 + 3) = v23;
        v24[1042] = 0;
        *((_DWORD *)v24 + 274) = 3;
        v24[1100] = *((_BYTE *)a1 + 81);
        *((_QWORD *)v24 + 138) = v7;
        *((_QWORD *)v24 + 131) = "void _swapIndex2(struct flush_index_ctx *, Boolean)";
        if (v23 > 0xA || *(_DWORD *)(v9 + 8) > 0x14u || *((_QWORD *)a1 + 5))
        {
          v27 = *((_QWORD *)a1 + 5);
          if (!v27)
            v27 = copyHoldQueue(v25);
          *((_QWORD *)v24 + 132) = v27;
          *((_QWORD *)a1 + 5) = 0;
        }
        v28 = 0;
        v29 = 0;
        v30 = *((_OWORD *)a1 + 4);
        *(_OWORD *)(v24 + 1064) = *((_OWORD *)a1 + 3);
        *(_OWORD *)(v24 + 1080) = v30;
        a1[12] = 0;
        *((_QWORD *)a1 + 8) = 0;
        *((_QWORD *)a1 + 9) = 0;
        *((_QWORD *)a1 + 7) = 0;
        v31 = *(_QWORD *)v9;
        v32 = v43;
        if (v43 <= v26)
          v32 = v26;
        v33 = v32 + 1;
        do
        {
          v34 = *(_QWORD *)(v31 + 8 * v26);
          v35 = atomic_load((unsigned int *)(v34 + 12));
          v28 += v35;
          LODWORD(v35) = *(_DWORD *)(v34 + 60);
          v36 = *(_QWORD *)(v34 + 72);
          if (v35 >= 2)
            v35 = v35;
          else
            v35 = 0;
          v31 = *(_QWORD *)v9;
          v29 = v36 + v29 + v35 - *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v9 + 8 * v26++) + 72);
        }
        while (v33 != v26);
        v24[16] = v14;
        if (v29 < 4 * v28)
          v37 = v14;
        else
          v37 = 0;
        v24[1041] = v37;
        __strlcpy_chk();
        si_power_info_assert_power((uint64_t)(v24 + 1064), v4);
        si_enqueue_work_with_qos(*(_QWORD *)(*(_QWORD *)a1 + 1056), 9, (uint64_t)si_mergeIndex, (uint64_t)v24);
      }
      goto LABEL_48;
    }
  }
LABEL_26:
  si_flush_index_ctx_free((uint64_t)a1, 0);
}

uint64_t count_IndexSet(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  char v7;
  char *v8;
  char *v9;
  const char *v10;
  uint64_t v11;
  char *v12;
  char *v13;
  const char *v14;
  uint64_t v15;

  if (*(_DWORD *)(a1 + 8) <= a2)
  {
    v12 = __si_assert_copy_extra_521(-1);
    v13 = v12;
    v14 = "";
    if (v12)
      v14 = v12;
    __message_assert("%s:%u: failed assertion '%s' %s ", "SIStoring.c", 3258, "startIndex < indexSet->indexCount", v14);
    free(v13);
    if (__valid_fs(-1))
      v15 = 2989;
    else
      v15 = 3072;
    *(_DWORD *)v15 = -559038737;
    abort();
  }
  if ((a2 & 0x80000000) != 0)
    return 0;
  result = 0;
  v5 = a2;
  while (v5 != *(_DWORD *)(a1 + 16))
  {
    v6 = *(_QWORD *)(*(_QWORD *)a1 + 8 * v5);
    if (*(_DWORD *)(v6 + 44) > a3)
      break;
    v7 = atomic_load((unsigned int *)(v6 + 28));
    if ((v7 & 3) == 0 && !*(_BYTE *)(v6 + 15163))
      break;
    result = (result + 1);
    --v5;
    if (a2 + 1 == (_DWORD)result)
    {
      result = a2 + 1;
      break;
    }
  }
  if (*(_DWORD *)(a1 + 8) < result)
  {
    v8 = __si_assert_copy_extra_521(-1);
    v9 = v8;
    v10 = "";
    if (v8)
      v10 = v8;
    __message_assert("%s:%u: failed assertion '%s' %s ", "SIStoring.c", 3264, "indexSet->indexCount >= j", v10);
    free(v9);
    if (__valid_fs(-1))
      v11 = 2989;
    else
      v11 = 3072;
    *(_DWORD *)v11 = -559038737;
    abort();
  }
  return result;
}

void si_forceSplitIndex(uint64_t a1)
{
  uint64_t *v2;
  uint64_t v3;
  unsigned int v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned int v7;
  unsigned int v8;
  char v9;
  int v10;
  unsigned int v11;
  _QWORD *v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t (*v16)(_QWORD, const char *, uint64_t, const char *);
  char *v17;
  char *v18;
  const char *v19;
  uint64_t v20;

  v2 = *(uint64_t **)a1;
  v3 = *(_QWORD *)(*(_QWORD *)a1 + 1384);
  v4 = *(_DWORD *)(v3 + 8);
  if (v4 < 0x1F)
  {
    if (v4 >= 0xB)
    {
      v5 = *(_QWORD **)v3;
      v6 = *(unsigned int *)(v3 + 8);
      while (*(_QWORD *)(a1 + 8) != *v5)
      {
        ++v5;
        if (!--v6)
          goto LABEL_29;
      }
      v7 = 0;
      v8 = v4 - 1;
      while (1)
      {
        v9 = atomic_load((unsigned int *)(*(_QWORD *)(*(_QWORD *)v3 + 8 * v8) + 28));
        if ((v9 & 4) != 0)
          break;
        ++v7;
        --v8;
        if (v4 == v7)
        {
          v7 = *(_DWORD *)(v3 + 8);
          break;
        }
      }
      v10 = *(_DWORD *)(v3 + 8);
      if (v10 < 1)
      {
        v11 = 0;
      }
      else
      {
        v11 = 0;
        v12 = *(_QWORD **)v3;
        v13 = v10 - 1;
        while (*(int *)(v12[v13] + 44) <= 2)
        {
          ++v11;
          --v13;
          if (v10 == v11)
          {
            v11 = v10;
            break;
          }
        }
      }
      if ((v7 > 0xA || v11 >= 0xB) && !*(_BYTE *)(*(_QWORD *)a1 + 2440))
        *(_BYTE *)(a1 + 83) = 1;
      if ((v7 > 9 || v11 >= 0xB)
        && (v14 = *(_QWORD *)a1, !(*(unsigned __int8 *)(*(_QWORD *)a1 + 2440) | gSISystemOnBattery))
        || (v7 > 0x13 || v11 >= 0x15) && (v14 = *(_QWORD *)a1, !*(_BYTE *)(*(_QWORD *)a1 + 2440)))
      {
        *(_QWORD *)(a1 + 40) = copyHoldQueue(v14);
      }
    }
LABEL_29:
    *(_BYTE *)(*(_QWORD *)(a1 + 8) + 15160) |= 4u;
    if (!*(_QWORD *)(a1 + 72) && !*(_DWORD *)(a1 + 48))
    {
      v15 = v2[295];
      if (v15)
      {
        v16 = *(uint64_t (**)(_QWORD, const char *, uint64_t, const char *))(v15 + 64);
        if (v16)
          *(_DWORD *)(a1 + 48) = v16(*(_QWORD *)(v15 + 136), "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SIStoring.c", 3099, "void si_forceSplitIndex(struct flush_index_ctx *)");
      }
    }
    if (*(_QWORD *)(a1 + 88))
    {
      v17 = __si_assert_copy_extra_521(-1);
      v18 = v17;
      v19 = "";
      if (v17)
        v19 = v17;
      __message_assert("%s:%u: failed assertion '%s' %s ", "SIStoring.c", 3101, "ctx->suspend_token == 0", v19);
      free(v18);
      if (__valid_fs(-1))
        v20 = 2989;
      else
        v20 = 3072;
      *(_DWORD *)v20 = -559038737;
      abort();
    }
    si_scheduler_async_suspend_and_enqueue(v2[109], v2[130], (uint64_t)_swapIndex, a1, (unsigned int **)(a1 + 88));
  }
  else
  {
    si_flush_index_ctx_free(a1, 0);
  }
}

uint64_t count_IndexSetForWriting(uint64_t a1, unsigned int a2)
{
  unsigned int v2;
  uint64_t result;
  uint64_t v5;
  char *v6;
  char *v7;
  const char *v8;
  uint64_t v9;
  char *v10;
  char *v11;
  const char *v12;
  uint64_t v13;

  v2 = *(_DWORD *)(a1 + 8);
  if (v2 <= a2)
  {
    v10 = __si_assert_copy_extra_521(-1);
    v11 = v10;
    v12 = "";
    if (v10)
      v12 = v10;
    __message_assert("%s:%u: failed assertion '%s' %s ", "SIStoring.c", 3246, "startIndex < indexSet->indexCount", v12);
    free(v11);
    if (__valid_fs(-1))
      v13 = 2989;
    else
      v13 = 3072;
    *(_DWORD *)v13 = -559038737;
    abort();
  }
  if ((a2 & 0x80000000) != 0)
    return 0;
  result = 0;
  v5 = *(_QWORD *)a1 + 8 * a2;
  while (!*(_DWORD *)(*(_QWORD *)v5 + 44))
  {
    result = (result + 1);
    v5 -= 8;
    if (a2 + 1 == (_DWORD)result)
    {
      result = a2 + 1;
      break;
    }
  }
  if (v2 < result)
  {
    v6 = __si_assert_copy_extra_521(-1);
    v7 = v6;
    v8 = "";
    if (v6)
      v8 = v6;
    __message_assert("%s:%u: failed assertion '%s' %s ", "SIStoring.c", 3251, "indexSet->indexCount >= j", v8);
    free(v7);
    if (__valid_fs(-1))
      v9 = 2989;
    else
      v9 = 3072;
    *(_DWORD *)v9 = -559038737;
    abort();
  }
  return result;
}

void transferAttributes(uint64_t *a1, int a2)
{
  double Current;
  uint64_t v5;
  unint64_t v6;
  int *v7;
  const char *v8;
  int v9;
  NSObject *v10;
  os_log_type_t v11;
  uint64_t v12;
  void (*v13)(void);
  int v14;
  NSObject *v15;
  int obj_callback;
  CFAllocatorRef *v17;
  void *v18;
  __CFDictionary *v19;
  uint64_t v20;
  const void *v21;
  const char *v22;
  unint64_t v23;
  void *v24;
  _QWORD *v25;
  int field;
  const __CFAllocator *allocator;
  __CFDictionary *v28;
  CFIndex Count;
  __CFDictionary *v30;
  char v31;
  char v32;
  void *v33;
  void (*v34)(uint64_t, __CFDictionary *, __CFDictionary *, _QWORD);
  uint64_t v35;
  const __CFAllocator *v36;
  CFDictionaryRef v37;
  const __CFArray *v38;
  CFIndex i;
  int *v40;
  const void *ValueAtIndex;
  _QWORD *v42;
  int v43;
  int v44;
  int v45;
  NSObject *v46;
  os_log_type_t v47;
  void (*v48)(uint64_t, _QWORD, _QWORD, BOOL);
  int v49;
  NSObject *v50;
  int v51;
  NSObject *v52;
  int v53;
  NSObject *v54;
  int v55;
  NSObject *v56;
  int v57;
  NSObject *v58;
  int v59;
  NSObject *v60;
  int v61;
  NSObject *v62;
  int v64;
  NSObject *v65;
  CFDictionaryRef v67;
  const __CFAllocator *v68;
  int v69;
  CFDictionaryRef v70;
  unint64_t v71;
  _QWORD *v72;
  unsigned __int8 *v73;
  unsigned __int16 *v74;
  void *v75;
  void *v76;
  void *v77;
  _BYTE buf[24];
  _QWORD v79[3];

  v79[1] = *MEMORY[0x1E0C80C00];
  if (!a2)
  {
    Current = CFAbsoluteTimeGetCurrent();
    v5 = *a1;
    v6 = a1[1];
    v7 = *(int **)(*a1 + 1184);
    v76 = 0;
    v77 = 0;
    v8 = (const char *)a1[2];
    v9 = *__error();
    v10 = _SILogForLogForCategory(4);
    v11 = 2 * (dword_1EF19FC9C < 4);
    if (os_log_type_enabled(v10, v11))
    {
      *(_DWORD *)buf = 134218240;
      *(_QWORD *)&buf[4] = v6;
      *(_WORD *)&buf[12] = 2048;
      *(_QWORD *)&buf[14] = v8;
      _os_log_impl(&dword_1B8270000, v10, v11, "Transfer from %lld to %lld", buf, 0x16u);
    }
    *__error() = v9;
    v12 = *(_QWORD *)(v5 + 1416);
    v13 = *(void (**)(void))(v12 + 104);
    if (v13 && !*(_BYTE *)(v12 + 240))
      v13();
    if (db_get_obj_callback(v7, v6, &v77, 0, *(_QWORD *)(v5 + 2368), 0))
    {
      if (dword_1EF19FC9C >= 5)
      {
        v49 = *__error();
        v50 = _SILogForLogForCategory(4);
        if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 134218240;
          *(_QWORD *)&buf[4] = v6;
          *(_WORD *)&buf[12] = 2048;
          *(_QWORD *)&buf[14] = v8;
          _os_log_impl(&dword_1B8270000, v50, OS_LOG_TYPE_DEFAULT, "No origin dbo exists for %lld to %lld", buf, 0x16u);
        }
        *__error() = v49;
      }
      v75 = 0;
      if (db_get_obj_callback(v7, (unint64_t)v8, &v75, 0, *(_QWORD *)(v5 + 2368), 0) == 2)
      {
        if (dword_1EF19FC9C >= 5)
        {
          v14 = *__error();
          v15 = _SILogForLogForCategory(4);
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 134218240;
            *(_QWORD *)&buf[4] = v6;
            *(_WORD *)&buf[12] = 2048;
            *(_QWORD *)&buf[14] = v8;
            _os_log_impl(&dword_1B8270000, v15, OS_LOG_TYPE_DEFAULT, "No target dbo exists for %lld to %lld", buf, 0x16u);
          }
          *__error() = v14;
        }
      }
      else
      {
        if (dword_1EF19FC9C >= 5)
        {
          v53 = *__error();
          v54 = _SILogForLogForCategory(4);
          if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 134218240;
            *(_QWORD *)&buf[4] = v6;
            *(_WORD *)&buf[12] = 2048;
            *(_QWORD *)&buf[14] = v8;
            _os_log_impl(&dword_1B8270000, v54, OS_LOG_TYPE_DEFAULT, "Target dbo exists for %lld to %lld", buf, 0x16u);
          }
          *__error() = v53;
        }
        si_perform_livequeries_reassignments(v5);
      }
      if (v75)
        free(v75);
      goto LABEL_86;
    }
    db_validate_obj(v7);
    if (dword_1EF19FC9C >= 5)
    {
      v51 = *__error();
      v52 = _SILogForLogForCategory(4);
      if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134218240;
        *(_QWORD *)&buf[4] = v6;
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = v8;
        _os_log_impl(&dword_1B8270000, v52, OS_LOG_TYPE_DEFAULT, "Origin exists for %lld to %lld", buf, 0x16u);
      }
      *__error() = v51;
    }
    v71 = v6;
    obj_callback = db_get_obj_callback(v7, (unint64_t)v8, &v76, 0, *(_QWORD *)(v5 + 2368), 0);
    v17 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
    if (obj_callback == 2)
    {
      if (dword_1EF19FC9C >= 5)
      {
        v55 = *__error();
        v56 = _SILogForLogForCategory(4);
        if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 134218240;
          *(_QWORD *)&buf[4] = v71;
          *(_WORD *)&buf[12] = 2048;
          *(_QWORD *)&buf[14] = v8;
          _os_log_impl(&dword_1B8270000, v56, OS_LOG_TYPE_DEFAULT, "Target does not exists for %lld to %lld", buf, 0x16u);
        }
        *__error() = v55;
      }
      db_delete_obj(v7, (uint64_t)v77);
      reassignIndexDocument(v5, *((_QWORD *)v77 + 4), *(const char **)v77, v8);
      v18 = v77;
      *(_QWORD *)v77 = v8;
      if (db_store_obj((uint64_t)v7, (uint64_t)v18, 0))
        deleteIndexDocument(v5, *((_QWORD *)v77 + 4), *(_QWORD *)v77);
      v19 = decodeDBOToDictionary(v7, (uint64_t)v77, 2048, 4, 0, 0, 0, 0, 0, *v17);
      if (dword_1EF19FC9C >= 5)
      {
        v57 = *__error();
        v58 = _SILogForLogForCategory(4);
        if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 134218240;
          *(_QWORD *)&buf[4] = v71;
          *(_WORD *)&buf[12] = 2048;
          *(_QWORD *)&buf[14] = v8;
          _os_log_impl(&dword_1B8270000, v58, OS_LOG_TYPE_DEFAULT, "Reassigning %lld to %lld", buf, 0x16u);
        }
        *__error() = v57;
      }
      si_perform_livequeries_reassignments(v5);
      if (CFDictionaryGetCount(v19))
      {
        v20 = a1[4];
        if (v20)
        {
          ((void (*)(uint64_t, __CFDictionary *, __CFDictionary *, _QWORD))a1[3])(v20, v19, v19, 0);
          a1[3] = 0;
        }
      }
      v21 = v19;
LABEL_85:
      CFRelease(v21);
LABEL_86:
      free(v77);
      bumpWorkTime(v5, Current);
      goto LABEL_87;
    }
    if (dword_1EF19FC9C >= 5)
    {
      v59 = *__error();
      v60 = _SILogForLogForCategory(4);
      if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134218240;
        *(_QWORD *)&buf[4] = v71;
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = v8;
        _os_log_impl(&dword_1B8270000, v60, OS_LOG_TYPE_DEFAULT, "Target exists for %lld to %lld", buf, 0x16u);
      }
      *__error() = v59;
    }
    v22 = *(const char **)v77;
    v23 = *((_QWORD *)v77 + 4);
    v69 = candidateForReimport(v5, (uint64_t *)&v76);
    if (v69)
    {
      if (dword_1EF19FC9C >= 5)
      {
        v61 = *__error();
        v62 = _SILogForLogForCategory(4);
        if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 134218240;
          *(_QWORD *)&buf[4] = v71;
          *(_WORD *)&buf[12] = 2048;
          *(_QWORD *)&buf[14] = v8;
          _os_log_impl(&dword_1B8270000, v62, OS_LOG_TYPE_DEFAULT, "Target needs reimport for %lld to %lld", buf, 0x16u);
        }
        *__error() = v61;
      }
      v23 = *((_QWORD *)v76 + 4);
      v22 = *(const char **)v76;
      reassignIndexDocument(v5, *((_QWORD *)v77 + 4), *(const char **)v77, v8);
      v24 = v77;
      *(_QWORD *)v77 = v8;
      v25 = v76;
      v76 = v24;
      v77 = v25;
      *v25 = v71;
      db_delete_obj(v7, (uint64_t)v24);
    }
    else if (dword_1EF19FC9C >= 5)
    {
      v64 = *__error();
      v65 = _SILogForLogForCategory(4);
      if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134218240;
        *(_QWORD *)&buf[4] = v71;
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = v8;
        _os_log_impl(&dword_1B8270000, v65, OS_LOG_TYPE_DEFAULT, "Target good for %lld to %lld", buf, 0x16u);
      }
      *__error() = v64;
    }
    v74 = 0;
    v75 = 0;
    field = db_get_field(*(int **)(v5 + 1184), (uint64_t)v77, "kMDItemLastUsedDate", (unint64_t *)&v74, &v75);
    v70 = 0;
    allocator = *v17;
    if (!field)
      v70 = _decodeSDBField(*(_QWORD *)(v5 + 1184), v74, (unsigned __int8 *)v75, 0, 0, 0, 0, *v17);
    v28 = decodeDBOToDictionary(v7, (uint64_t)v77, 2048, 4, 0, 0, 0, 0, 0, allocator);
    Count = CFDictionaryGetCount(v28);
    if (!*((_BYTE *)a1 + 40))
    {
      deleteIndexDocument(v5, v23, (uint64_t)v22);
      if (!db_delete_obj(v7, (uint64_t)v77))
      {
        *(_QWORD *)buf = 0;
        v73 = 0;
        v79[0] = *(unsigned int *)(v5 + 2008);
        if (!db_get_field_by_id(*(int **)(v5 + 1184), (uint64_t)v77, (int *)v79, (unint64_t *)buf, (unint64_t *)&v73)&& (*(_BYTE *)(v5 + 2072) || *v73 <= 0x15u))
        {
          v72 = 0;
          LODWORD(v79[0]) = *(_DWORD *)(v5 + 2012);
          if (!db_get_field_by_id(*(int **)(v5 + 1184), (uint64_t)v77, (int *)v79, (unint64_t *)buf, (unint64_t *)&v72))
          {
            pthread_mutex_lock((pthread_mutex_t *)(v5 + 6976));
            *(_QWORD *)(v5 + 6976 + 8 * *v73 + 64) -= *v72;
            pthread_mutex_unlock((pthread_mutex_t *)(v5 + 6976));
          }
        }
      }
    }
    v68 = allocator;
    if (Count || v70)
    {
      v30 = decodeDBOToDictionary(v7, (uint64_t)v76, 2048, 4, 0, 0, 0, 0, 0, allocator);
      v31 = v69;
      if (!*((_BYTE *)a1 + 40))
      {
        v33 = v76;
        v76 = db_copy_obj((unsigned int *)v76, 1024);
        free(v33);
      }
      *(_QWORD *)buf = v76;
      *(_QWORD *)&buf[8] = v30;
      *(_QWORD *)&buf[16] = v7;
      v32 = v69;
      if (!CFEqual(v30, v28))
      {
        CFDictionaryApplyFunction(v28, (CFDictionaryApplierFunction)attr_tfr_callback, buf);
        v34 = (void (*)(uint64_t, __CFDictionary *, __CFDictionary *, _QWORD))a1[3];
        if (v34)
        {
          v34(a1[4], v30, v28, 0);
          a1[3] = 0;
        }
        v32 = 1;
      }
      v76 = *(void **)buf;
    }
    else
    {
      v30 = 0;
      v31 = v69;
      v32 = v69;
    }
    if (v28)
      CFRelease(v28);
    if (v30)
      CFRelease(v30);
    v35 = (uint64_t)v70;
    if (v70)
    {
      if (db_get_field(*(int **)(v5 + 1184), (uint64_t)v76, "kMDItemLastUsedDate", (unint64_t *)&v74, &v75))
      {
        v67 = 0;
        v36 = v68;
      }
      else
      {
        v36 = v68;
        v67 = _decodeSDBField(*(_QWORD *)(v5 + 1184), v74, (unsigned __int8 *)v75, 0, 0, 0, 0, v68);
      }
      if (!db_get_field(*(int **)(v5 + 1184), (uint64_t)v77, "kMDItemUsedDates", (unint64_t *)&v74, &v75))
      {
        v37 = _decodeSDBField(*(_QWORD *)(v5 + 1184), v74, (unsigned __int8 *)v75, 0, 0, 0, 0, v36);
        if (v37)
        {
          v38 = v37;
          for (i = 0; CFArrayGetCount(v38) > i; ++i)
          {
            v40 = *(int **)(v5 + 1184);
            ValueAtIndex = CFArrayGetValueAtIndex(v38, i);
            markItemAsUsedForField(v40, (uint64_t *)&v76, "kMDItemLastUsedDate", "kMDItemUsedDates", (uint64_t)ValueAtIndex, 1, 1, 0, 0.0);
          }
          CFRelease(v38);
          v35 = (uint64_t)v70;
          v31 = v69;
        }
      }
      markItemAsUsedForField(*(int **)(v5 + 1184), (uint64_t *)&v76, "kMDItemLastUsedDate", "kMDItemUsedDates", v35, 1, 1, 0, 0.0);
      if (v67)
      {
        markItemAsUsedForField(*(int **)(v5 + 1184), (uint64_t *)&v76, "kMDItemLastUsedDate", "kMDItemUsedDates", (uint64_t)v67, 1, 1, 0, 0.0);
        CFRelease(v67);
      }
      si_perform_livequeries_reassignments(v5);
    }
    else
    {
      si_perform_livequeries_reassignments(v5);
      if ((v32 & 1) == 0)
      {
LABEL_81:
        if (v76)
          free(v76);
        if (!v35)
          goto LABEL_86;
        v21 = (const void *)v35;
        goto LABEL_85;
      }
    }
    v42 = v76;
    if ((v31 & 1) == 0)
    {
      if ((unint64_t)(*((_QWORD *)v76 + 4) + 1) >= 2)
      {
        deleteIndexDocument(v5, *((_QWORD *)v76 + 4), *(_QWORD *)v76);
        v42 = v76;
      }
      v42[4] = -1;
    }
    v43 = db_store_obj((uint64_t)v7, (uint64_t)v42, 8);
    if (v43)
    {
      v44 = v43;
      v45 = *__error();
      v46 = _SILogForLogForCategory(7);
      v47 = 2 * (dword_1EF19FCA8 < 4);
      if (os_log_type_enabled(v46, v47))
      {
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = v44;
        _os_log_impl(&dword_1B8270000, v46, v47, "Store failed during attribute transfer on safe-save (%d)", buf, 8u);
      }
      *__error() = v45;
    }
    goto LABEL_81;
  }
LABEL_87:
  v48 = (void (*)(uint64_t, _QWORD, _QWORD, BOOL))a1[3];
  if (v48)
    v48(a1[4], 0, 0, a2 != 0);
  free(a1);
}

uint64_t reassignIndexDocument(uint64_t a1, unint64_t a2, const char *a3, const char *a4)
{
  uint64_t result;
  uint64_t v9;
  int v10;
  unsigned int v11;

  result = si_indexForDocId(a1, a2);
  if (result)
  {
    v9 = result;
    db_fast_dirty_datastore_if_necessary(*(_QWORD *)(a1 + 1184));
    v11 = 0;
    result = fd_setDir(*(unsigned int *)(a1 + 32), (int *)&v11);
    if ((_DWORD)result)
    {
      _CIReassign(v9, a2, a3, a4);
      v10 = v11;
      result = MEMORY[0x1BCCB1484](v11);
      if ((v10 & 0x80000000) == 0)
        return close(v10);
    }
  }
  return result;
}

uint64_t deleteIndexDocument(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v7;
  int v8;
  unsigned int v9;

  result = si_indexForDocId(a1, a2);
  if (result)
  {
    v7 = result;
    db_fast_dirty_datastore_if_necessary(*(_QWORD *)(a1 + 1184));
    v9 = 0;
    result = fd_setDir(*(unsigned int *)(a1 + 32), (int *)&v9);
    if ((_DWORD)result)
    {
      _CIDelete(v7, a2, a3, 0);
      v8 = v9;
      result = MEMORY[0x1BCCB1484](v9);
      if ((v8 & 0x80000000) == 0)
        return close(v8);
    }
  }
  return result;
}

void attr_tfr_callback(const __CFString *key, const __CFArray *a2, uint64_t a3)
{
  if (!CFDictionaryContainsKey(*(CFDictionaryRef *)(a3 + 8), key))
  {
    setOneFieldLocked(key, 0, a2, *(int **)(a3 + 16), (uint64_t *)a3, 0x800u, 0, 0);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a3 + 8), key, a2);
  }
}

double markItemAsUsedForField(int *a1, uint64_t *a2, char *a3, char *a4, uint64_t a5, int a6, int a7, unsigned int a8, CFAbsoluteTime a9)
{
  _DWORD *v18;
  double v19;
  CFCalendarRef *v20;
  __n128 v21;
  __n128 v22;
  const __CFArray *v23;
  int v24;
  NSObject *v25;
  os_log_type_t v26;
  int v27;
  NSObject *v28;
  os_log_type_t v29;
  size_t v30;
  size_t v31;
  uint8_t *v32;
  __n128 v33;
  int v34;
  NSObject *v35;
  os_log_type_t v36;
  __n128 v37;
  int v38;
  const __CFAllocator *v39;
  CFDictionaryRef v40;
  CFTypeID TypeID;
  CFIndex Count;
  const void *ValueAtIndex;
  CFTypeID v44;
  double v45;
  int v46;
  NSObject *v47;
  os_log_type_t v48;
  int v49;
  NSObject *v50;
  os_log_type_t v51;
  CFTypeID v53;
  CFDateRef v54;
  __n128 v55;
  int v56;
  NSObject *v57;
  os_log_type_t v58;
  __n128 v59;
  int v60;
  NSObject *v61;
  int v62;
  NSObject *v63;
  uint8_t v64[16];
  CFAbsoluteTime at;
  unsigned int v66;
  uint64_t v67;
  double v68;
  unsigned __int16 *v69;
  unsigned __int8 *v70;
  _BYTE buf[12];
  __int16 v72;
  double v73;
  uint64_t v74;
  CFRange v75;

  v74 = *MEMORY[0x1E0C80C00];
  db_validate_obj(a1);
  v18 = (_DWORD *)*a2;
  if (!*(_QWORD *)*a2)
  {
    v19 = 0.0;
    goto LABEL_57;
  }
  v69 = 0;
  v70 = 0;
  if (db_get_field(a1, (uint64_t)v18, a3, (unint64_t *)&v69, &v70))
  {
    v19 = -INFINITY;
    if (a5)
      goto LABEL_8;
  }
  else
  {
    v19 = *(double *)v70;
    if (a5)
    {
LABEL_8:
      if (a5 || v19 < a9)
      {
        if (a5)
          a9 = MEMORY[0x1BCCAF690](a5);
        v68 = a9;
        v67 = 0;
        v66 = 0;
        v20 = (CFCalendarRef *)si_retain_calendar();
        CFCalendarDecomposeAbsoluteTime(v20[1], a9, "yMd", &v66, &v67, (char *)&v67 + 4);
        at = 0.0;
        CFCalendarComposeAbsoluteTime(v20[1], &at, "yMd", v66, v67, HIDWORD(v67));
        OSAtomicEnqueue(&sCalenderQueueHead, v20, 0);
        if (a4)
        {
          if (db_get_field(a1, *a2, a4, (unint64_t *)&v69, &v70))
          {
            v23 = 0;
            if (a9 > v19)
              goto LABEL_15;
            if (a9 != v19)
            {
LABEL_46:
              if (db_add_field(a1, (_DWORD **)a2, 1u, a4, 0, a8 | 0x20, 12, (unsigned __int8 *)&at, v22, 8))
              {
                v46 = *__error();
                v47 = _SILogForLogForCategory(7);
                v48 = 2 * (dword_1EF19FCA8 < 4);
                if (os_log_type_enabled(v47, v48))
                {
                  *(_WORD *)buf = 0;
                  _os_log_impl(&dword_1B8270000, v47, v48, "Failed adding used dates", buf, 2u);
                }
                *__error() = v46;
              }
            }
          }
          else
          {
            v39 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
            v40 = _decodeSDBField((unint64_t)a1, v69, v70, 0, 0, 0, 0, (CFAllocatorRef)*MEMORY[0x1E0C9AE00]);
            v23 = v40;
            if (a9 > v19)
            {
              if (v40)
              {
                TypeID = CFArrayGetTypeID();
                if (TypeID == CFGetTypeID(v23))
                {
                  Count = CFArrayGetCount(v23);
                  if (Count)
                  {
                    ValueAtIndex = CFArrayGetValueAtIndex(v23, Count - 1);
                    v44 = CFGetTypeID(ValueAtIndex);
                    if (v44 == CFDateGetTypeID())
                    {
                      v45 = MEMORY[0x1BCCAF690](ValueAtIndex);
                      v21.n128_f64[0] = at;
                      if (v45 == at)
                        goto LABEL_21;
                      if (dword_1EF19FC9C >= 5)
                      {
                        v62 = *__error();
                        v63 = _SILogForLogForCategory(4);
                        if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
                        {
                          *(_DWORD *)buf = 134218240;
                          *(CFAbsoluteTime *)&buf[4] = at;
                          v72 = 2048;
                          v73 = v45;
                          _os_log_impl(&dword_1B8270000, v63, OS_LOG_TYPE_DEFAULT, "New last used date was not in the previous array: %f != %f", buf, 0x16u);
                        }
                        *__error() = v62;
                      }
                      if (!db_add_field(a1, (_DWORD **)a2, 2u, a4, 0, a8, 12, (unsigned __int8 *)&at, v21, 8))goto LABEL_21;
                      v24 = *__error();
                      v25 = _SILogForLogForCategory(7);
                      v26 = 2 * (dword_1EF19FCA8 < 4);
                      if (!os_log_type_enabled(v25, v26))
                        goto LABEL_19;
                      *(_WORD *)buf = 0;
                    }
                    else
                    {
                      db_delete_field(a1, a2, a4);
                      if (!db_add_field(a1, (_DWORD **)a2, 1u, a4, 0, a8 | 0x20, 12, (unsigned __int8 *)&at, v59, 8))goto LABEL_21;
                      v24 = *__error();
                      v25 = _SILogForLogForCategory(7);
                      v26 = 2 * (dword_1EF19FCA8 < 4);
                      if (!os_log_type_enabled(v25, v26))
                        goto LABEL_19;
                      *(_WORD *)buf = 0;
                    }
                    goto LABEL_18;
                  }
                }
              }
LABEL_15:
              if (!db_add_field(a1, (_DWORD **)a2, 1u, a4, 0, a8 | 0x20, 12, (unsigned __int8 *)&at, v22, 8))
              {
LABEL_21:
                if (db_add_field(a1, (_DWORD **)a2, 1u, a3, 0, a8, 12, (unsigned __int8 *)&v68, v21, 8))
                {
                  v27 = *__error();
                  v28 = _SILogForLogForCategory(7);
                  v29 = 2 * (dword_1EF19FCA8 < 4);
                  if (os_log_type_enabled(v28, v29))
                  {
                    *(_WORD *)buf = 0;
                    _os_log_impl(&dword_1B8270000, v28, v29, "Failed adding used date", buf, 2u);
                  }
                  *__error() = v27;
                }
                if (v68 != 0.0)
                {
                  if (a6)
                  {
                    *(double *)buf = (double)(86400 * ((unint64_t)v68 / 0x15180));
                    v30 = strlen(a3);
                    v31 = v30 + 10;
                    v32 = &v64[-((MEMORY[0x1E0C80A78](v30) + 25) & 0xFFFFFFFFFFFFFFF0)];
                    bzero(v32, v31);
                    strlcpy((char *)v32, a3, v31);
                    strlcat((char *)v32, "_Ranking", v31);
                    if (db_add_field(a1, (_DWORD **)a2, 1u, (char *)v32, 0, a8, 12, buf, v33, 8))
                    {
                      v34 = *__error();
                      v35 = _SILogForLogForCategory(7);
                      v36 = 2 * (dword_1EF19FCA8 < 4);
                      if (os_log_type_enabled(v35, v36))
                      {
                        *(_WORD *)v64 = 0;
                        _os_log_impl(&dword_1B8270000, v35, v36, "Failed adding ranking used date", v64, 2u);
                      }
                      *__error() = v34;
                    }
                  }
                }
                v19 = a9;
                goto LABEL_32;
              }
              v24 = *__error();
              v25 = _SILogForLogForCategory(7);
              v26 = 2 * (dword_1EF19FCA8 < 4);
              if (!os_log_type_enabled(v25, v26))
              {
LABEL_19:
                *__error() = v24;
                goto LABEL_21;
              }
              *(_WORD *)buf = 0;
LABEL_18:
              _os_log_impl(&dword_1B8270000, v25, v26, "Failed adding used dates", buf, 2u);
              goto LABEL_19;
            }
            if (a9 != v19)
            {
              if (v40)
              {
                v53 = CFArrayGetTypeID();
                if (v53 == CFGetTypeID(v23))
                {
                  v54 = CFDateCreate(v39, at);
                  v75.length = CFArrayGetCount(v23);
                  v75.location = 0;
                  if (!CFArrayContainsValue(v23, v75, v54))
                  {
                    if (dword_1EF19FC9C >= 5)
                    {
                      v60 = *__error();
                      v61 = _SILogForLogForCategory(4);
                      if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_DWORD *)buf = 134217984;
                        *(CFAbsoluteTime *)&buf[4] = at;
                        _os_log_impl(&dword_1B8270000, v61, OS_LOG_TYPE_DEFAULT, "New last used date was not in the previous array: %f", buf, 0xCu);
                      }
                      *__error() = v60;
                    }
                    if (db_add_field(a1, (_DWORD **)a2, 2u, a4, 0, a8, 12, (unsigned __int8 *)&at, v55, 8))
                    {
                      v56 = *__error();
                      v57 = _SILogForLogForCategory(7);
                      v58 = 2 * (dword_1EF19FCA8 < 4);
                      if (os_log_type_enabled(v57, v58))
                      {
                        *(_WORD *)buf = 0;
                        _os_log_impl(&dword_1B8270000, v57, v58, "Failed adding used dates", buf, 2u);
                      }
                      *__error() = v56;
                    }
                  }
                  if (v54)
                    CFRelease(v54);
                  goto LABEL_32;
                }
              }
              goto LABEL_46;
            }
          }
        }
        else
        {
          v23 = 0;
          if (a9 > v19)
            goto LABEL_21;
        }
LABEL_32:
        if (a7)
        {
          v38 = db_get_field(a1, *a2, "kMDItemUseCount", (unint64_t *)&v69, &v70)
              ? 1
              : *(_DWORD *)v70 + 1;
          *(_DWORD *)buf = v38;
          if (db_add_field(a1, (_DWORD **)a2, 1u, "kMDItemUseCount", 0, a8 | 0x100, 6, buf, v37, 4))
          {
            v49 = *__error();
            v50 = _SILogForLogForCategory(7);
            v51 = 2 * (dword_1EF19FCA8 < 4);
            if (os_log_type_enabled(v50, v51))
            {
              *(_WORD *)v64 = 0;
              _os_log_impl(&dword_1B8270000, v50, v51, "Failed adding use count", v64, 2u);
            }
            *__error() = v49;
          }
        }
        if (v23)
          CFRelease(v23);
      }
LABEL_57:
      db_validate_obj(a1);
      return v19;
    }
  }
  if (a9 != -INFINITY)
    goto LABEL_8;
  return v19;
}

_QWORD *si_retain_calendar()
{
  _QWORD *v0;

  v0 = OSAtomicDequeue(&sCalenderQueueHead, 0);
  if (!v0)
  {
    v0 = malloc_type_malloc(0x10uLL, 0xA0040BD48D6D6uLL);
    v0[1] = CFCalendarCreateWithIdentifier((CFAllocatorRef)*MEMORY[0x1E0C9AE30], (CFCalendarIdentifier)*MEMORY[0x1E0C9B008]);
  }
  return v0;
}

uint64_t si_text_store_delete_by_predicate(uint64_t a1, uint64_t a2)
{
  int v4;
  NSObject *v5;
  os_log_type_t v6;
  _DWORD *v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  CachingHotShard *v14;
  int v15;
  unsigned int v16;
  int v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  const char *v23;
  uint64_t v24;
  int v25;
  unsigned int v26;
  unsigned int v27;
  uint64_t *v28;
  char *v29;
  int64x2_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unsigned int v34;
  int v35;
  int v36;
  NSObject *v37;
  os_log_type_t v38;
  char *v39;
  int v40;
  NSObject *v41;
  BOOL v42;
  char *v43;
  NSObject *v44;
  os_log_type_t v45;
  const char *v46;
  NSObject *v47;
  BOOL v48;
  char *v49;
  int v50;
  NSObject *v51;
  os_log_type_t v52;
  char *v53;
  uint64_t v54;
  int v55;
  NSObject *v56;
  os_log_type_t v57;
  int v58;
  NSObject *v59;
  os_log_type_t v60;
  char *v61;
  uint64_t v63;
  int64x2_t v64;
  _QWORD v65[2];
  _OWORD v66[2];
  uint64_t *v67;
  void *__p[2];
  uint64_t v69;
  void *v70[2];
  uint64_t v71;
  uint8_t buf[16];
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  __int128 v103;
  uint8_t v104[24];
  void *v105;
  uint64_t v106;
  void **v107;
  int v108;
  uint64_t v109;

  v109 = *MEMORY[0x1E0C80C00];
  v4 = *__error();
  v5 = _SILogForLogForCategory(8);
  v6 = 2 * (dword_1EF19FCAC < 4);
  if (os_log_type_enabled(v5, v6))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1B8270000, v5, v6, "Deleting by predicate", buf, 2u);
  }
  *__error() = v4;
  v7 = *(_DWORD **)(a1 + 1296);
  v102 = 0u;
  v103 = 0u;
  v100 = 0u;
  v101 = 0u;
  v98 = 0u;
  v99 = 0u;
  v96 = 0u;
  v97 = 0u;
  v94 = 0u;
  v95 = 0u;
  v92 = 0u;
  v93 = 0u;
  v90 = 0u;
  v91 = 0u;
  v88 = 0u;
  v89 = 0u;
  v86 = 0u;
  v87 = 0u;
  v84 = 0u;
  v85 = 0u;
  v82 = 0u;
  v83 = 0u;
  v80 = 0u;
  v81 = 0u;
  v78 = 0u;
  v79 = 0u;
  v76 = 0u;
  v77 = 0u;
  v74 = 0u;
  v75 = 0u;
  *(_OWORD *)buf = 0u;
  v73 = 0u;
  snprintf((char *)buf, 0x200uLL, "doc_store_delete_documents_by_predicate(%p)", v7);
  v65[0] = 0;
  v65[1] = 0;
  ScopeLogger::ScopeLogger((ScopeLogger *)v65, (const char *)buf);
  if (!v7)
  {
    ScopeLogger::~ScopeLogger((ScopeLogger *)v65);
    v12 = 4294967282;
LABEL_85:
    v58 = *__error();
    v59 = _SILogForLogForCategory(8);
    v60 = dword_1EF19FCAC < 3;
    if (os_log_type_enabled(v59, (os_log_type_t)(dword_1EF19FCAC < 3)))
    {
      v61 = strerror(-(int)v12);
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = v61;
      _os_log_impl(&dword_1B8270000, v59, v60, "*warn* doc_store_delete_documents_by_predicate(): %s", buf, 0xCu);
    }
    *__error() = v58;
    return v12;
  }
  std::mutex::lock((std::mutex *)(v7 + 10));
  memset(v66, 0, sizeof(v66));
  v8 = (std::__shared_weak_count *)*((_QWORD *)v7 + 21);
  *(_QWORD *)v104 = *((_QWORD *)v7 + 20);
  *(_QWORD *)&v104[8] = v8;
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
    analytics::ScopedLogger<analytics::DeleteEvent>::ScopedLogger((std::chrono::steady_clock::time_point *)v66, (std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep *)v104);
    do
      v11 = __ldaxr(p_shared_owners);
    while (__stlxr(v11 - 1, p_shared_owners));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  else
  {
    analytics::ScopedLogger<analytics::DeleteEvent>::ScopedLogger((std::chrono::steady_clock::time_point *)v66, (std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep *)v104);
  }
  v13 = *(_QWORD *)&v66[0];
  if (!*(_BYTE *)(*(_QWORD *)&v66[0] + 24))
    *(_BYTE *)(*(_QWORD *)&v66[0] + 24) = 1;
  *(_QWORD *)(v13 + 16) = -1;
  if (!*(_BYTE *)(v13 + 40))
    *(_BYTE *)(v13 + 40) = 1;
  *(_QWORD *)(v13 + 32) = 0;
  if (!*(_BYTE *)(v13 + 56))
    *(_BYTE *)(v13 + 56) = 1;
  *(_QWORD *)(v13 + 48) = 0;
  v14 = (CachingHotShard *)*((_QWORD *)v7 + 1);
  if (v14)
  {
    v15 = *(_DWORD *)v14;
    v70[0] = 0;
    *(_QWORD *)v104 = MEMORY[0x1E0C809B0];
    *(_QWORD *)&v104[8] = 0x40000000;
    *(_QWORD *)&v104[16] = __hot_shard_delete_docs_by_predicate_block_invoke;
    v105 = &unk_1E6E34F08;
    v108 = v15;
    v106 = a2;
    v107 = v70;
    v16 = hot_shard_for_each_region(v15, (uint64_t)v104);
    v17 = *(_DWORD *)v14;
    *((_QWORD *)v14 + 2) = *((_QWORD *)v14 + 1);
    *((_QWORD *)v14 + 5) = *((_QWORD *)v14 + 4);
    *((_QWORD *)v14 + 8) = *((_QWORD *)v14 + 7);
    *(_DWORD *)v14 = -1;
    v18 = CachingHotShard::Bind(v14, v17);
    if (v16)
      v12 = v16;
    else
      v12 = v18;
  }
  else
  {
    v12 = 4294967282;
  }
  v19 = *((_QWORD *)v7 + 3) - *((_QWORD *)v7 + 2);
  if (v19 >= 1)
  {
    v63 = a2;
    v20 = (unint64_t)v19 >> 5;
    while (1)
    {
      v21 = v20--;
      v22 = *((_QWORD *)v7 + 2) + 32 * v20;
      if (!*(_BYTE *)(v22 + 25))
        break;
LABEL_69:
      if (v21 <= 1)
        goto LABEL_73;
    }
    v23 = (const char *)(*((_QWORD *)v7 + 2) + 32 * v20);
    if (*(char *)(v22 + 23) < 0)
      v23 = *(const char **)v22;
    v24 = openat(*v7, v23, 2);
    if ((v24 & 0x80000000) != 0)
    {
      v35 = *__error();
      v36 = *__error();
      v37 = _SILogForLogForCategory(8);
      v38 = dword_1EF19FCAC < 3;
      if (os_log_type_enabled(v37, (os_log_type_t)(dword_1EF19FCAC < 3)))
      {
        if (*(char *)(v22 + 23) < 0)
          v22 = *(_QWORD *)v22;
        v39 = strerror(v35);
        *(_DWORD *)v104 = 136315394;
        *(_QWORD *)&v104[4] = v22;
        *(_WORD *)&v104[12] = 2080;
        *(_QWORD *)&v104[14] = v39;
        _os_log_impl(&dword_1B8270000, v37, v38, "*warn* open(%s, RDWR): %s\n", v104, 0x16u);
      }
      *__error() = v36;
      goto LABEL_69;
    }
    v25 = v24;
    v67 = 0;
    cold_shard_create_search_context_for_fd(v24, (uint64_t *)&v67);
    v27 = v26;
    if (v26 == -2)
    {
LABEL_64:
      if (v67)
        MEMORY[0x1BCCB06A4](v67, 0x1000C4034A301B9);
      close(v25);
      if (v27)
        v12 = v27;
      else
        v12 = v12;
      goto LABEL_69;
    }
    if (v26)
    {
      v40 = *__error();
      v41 = _SILogForLogForCategory(8);
      v42 = dword_1EF19FCAC < 3;
      if (!os_log_type_enabled(v41, (os_log_type_t)(dword_1EF19FCAC < 3)))
      {
LABEL_63:
        *__error() = v40;
        goto LABEL_64;
      }
      v43 = strerror(-v27);
      *(_DWORD *)v104 = 136315138;
      *(_QWORD *)&v104[4] = v43;
      v44 = v41;
      v45 = v42;
      v46 = "*warn* cold_shard_create_search_context_for_fd: %s\n";
    }
    else
    {
      v28 = v67;
      memset(v104, 0, sizeof(v104));
      v71 = 0;
      *(_OWORD *)v70 = 0u;
      v69 = 0;
      v64 = 0u;
      *(_OWORD *)__p = 0u;
      v27 = do_unpack_coldshard_docidx((uint64_t)v67, (uint64_t)v104, (uint64_t)v70, (uint64_t)__p);
      if (!v27)
      {
        v29 = (char *)__p[0];
        v30 = 0uLL;
        if (__p[0] != __p[1])
        {
          v31 = 1;
          do
          {
            v30.i64[1] = v31;
            v29 += 8;
            ++v31;
          }
          while (v29 != __p[1]);
        }
        v64 = v30;
        v32 = *(_QWORD *)v104;
        if ((int)((*(_QWORD *)&v104[8] - *(_QWORD *)v104) >> 3) >= 1)
        {
          v33 = 0;
          do
          {
            if ((*(unsigned int (**)(uint64_t, _QWORD))(v63 + 16))(v63, *(_QWORD *)(v32 + 8 * v33)))
            {
              v64 = vaddq_s64(v64, (int64x2_t)xmmword_1B8631EE0);
              v34 = do_erase_doc((uint64_t)v28, *((_QWORD *)v70[0] + v33), *((_QWORD *)__p[0] + v33));
              if (v34)
                goto LABEL_44;
              *((_QWORD *)v70[0] + v33) = -1;
            }
            ++v33;
            v32 = *(_QWORD *)v104;
          }
          while (v33 < (int)((*(_QWORD *)&v104[8] - *(_QWORD *)v104) >> 3));
        }
        if (v64.i64[0] && (v34 = do_rebuild_coldshard_docidx(v28, (uint64_t *)v104, v70, __p)) != 0)
LABEL_44:
          v27 = v34;
        else
          v27 = 0;
      }
      if (__p[0])
      {
        __p[1] = __p[0];
        operator delete(__p[0]);
      }
      if (v70[0])
      {
        v70[1] = v70[0];
        operator delete(v70[0]);
      }
      if (*(_QWORD *)v104)
      {
        *(_QWORD *)&v104[8] = *(_QWORD *)v104;
        operator delete(*(void **)v104);
      }
      if (!v27)
      {
        if (!*(_BYTE *)(v13 + 56))
          goto LABEL_89;
        *(_QWORD *)(v13 + 48) += v64.i64[0];
        DocStore::doColdShardCompaction(v7, v20, v64.i64[1]);
        v27 = 0;
        goto LABEL_64;
      }
      v40 = *__error();
      v47 = _SILogForLogForCategory(8);
      v48 = dword_1EF19FCAC < 3;
      if (!os_log_type_enabled(v47, (os_log_type_t)(dword_1EF19FCAC < 3)))
        goto LABEL_63;
      v49 = strerror(-v27);
      *(_DWORD *)v104 = 136315138;
      *(_QWORD *)&v104[4] = v49;
      v44 = v47;
      v45 = v48;
      v46 = "*warn* cold_shard_delete_docs: %s\n";
    }
    _os_log_impl(&dword_1B8270000, v44, v45, v46, v104, 0xCu);
    goto LABEL_63;
  }
LABEL_73:
  if (!*(_BYTE *)(v13 + 24))
    goto LABEL_89;
  if (*(_DWORD *)(v13 + 16) != -1)
    goto LABEL_78;
  if (!*(_BYTE *)(v13 + 40) || !*(_BYTE *)(v13 + 56))
LABEL_89:
    std::__throw_bad_optional_access[abi:nn180100]();
  *(_QWORD *)(v13 + 16) = *(_QWORD *)(v13 + 48) + *(_QWORD *)(v13 + 32);
LABEL_78:
  if ((_DWORD)v12)
  {
    v50 = *__error();
    v51 = _SILogForLogForCategory(8);
    v52 = dword_1EF19FCAC < 3;
    if (os_log_type_enabled(v51, (os_log_type_t)(dword_1EF19FCAC < 3)))
    {
      v53 = strerror(-(int)v12);
      *(_DWORD *)v104 = 136315138;
      *(_QWORD *)&v104[4] = v53;
      _os_log_impl(&dword_1B8270000, v51, v52, "*warn* DeleteDocumentsByPredicate: %s", v104, 0xCu);
    }
    *__error() = v50;
  }
  DocStore::MarkDocPurgeableTillN((uint64_t)v7);
  v54 = *(_QWORD *)&v66[0];
  *(_DWORD *)(*(_QWORD *)&v66[0] + 4) = v12;
  *(_BYTE *)(v54 + 8) = 1;
  **(_WORD **)&v66[0] = ((_DWORD)v12 == 0) | 0x100;
  analytics::ScopedLogger<analytics::DeleteEvent>::~ScopedLogger(v66);
  std::mutex::unlock((std::mutex *)(v7 + 10));
  v55 = *__error();
  v56 = _SILogForLogForCategory(8);
  v57 = 2 * (dword_1EF19FCAC < 4);
  if (os_log_type_enabled(v56, v57))
  {
    *(_DWORD *)v104 = 136315394;
    *(_QWORD *)&v104[4] = "doc_store_delete_documents_by_predicate";
    *(_WORD *)&v104[12] = 1024;
    *(_DWORD *)&v104[14] = v12;
    _os_log_impl(&dword_1B8270000, v56, v57, "%s returns %d\n", v104, 0x12u);
  }
  *__error() = v55;
  ScopeLogger::~ScopeLogger((ScopeLogger *)v65);
  if ((_DWORD)v12)
    goto LABEL_85;
  return v12;
}

void si_text_store_bulk_delete(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  int v6;
  NSObject *v7;
  os_log_type_t v8;
  DocStore *v9;
  int v10;
  int v11;
  NSObject *v12;
  os_log_type_t v13;
  int v14;
  NSObject *v15;
  os_log_type_t v16;
  char *v17;
  _QWORD v18[2];
  uint8_t v19[4];
  const char *v20;
  __int16 v21;
  int v22;
  uint8_t buf[32];
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  uint64_t v54;

  v54 = *MEMORY[0x1E0C80C00];
  v6 = *__error();
  v7 = _SILogForLogForCategory(8);
  v8 = 2 * (dword_1EF19FCAC < 4);
  if (os_log_type_enabled(v7, v8))
  {
    *(_DWORD *)buf = 134217984;
    *(_QWORD *)&buf[4] = a3;
    _os_log_impl(&dword_1B8270000, v7, v8, "Deleted %zd documents", buf, 0xCu);
  }
  *__error() = v6;
  v9 = *(DocStore **)(a1 + 1296);
  v52 = 0u;
  v53 = 0u;
  v50 = 0u;
  v51 = 0u;
  v48 = 0u;
  v49 = 0u;
  v46 = 0u;
  v47 = 0u;
  v44 = 0u;
  v45 = 0u;
  v42 = 0u;
  v43 = 0u;
  v40 = 0u;
  v41 = 0u;
  v38 = 0u;
  v39 = 0u;
  v36 = 0u;
  v37 = 0u;
  v34 = 0u;
  v35 = 0u;
  v32 = 0u;
  v33 = 0u;
  v30 = 0u;
  v31 = 0u;
  v28 = 0u;
  v29 = 0u;
  v26 = 0u;
  v27 = 0u;
  v24 = 0u;
  v25 = 0u;
  memset(buf, 0, sizeof(buf));
  snprintf((char *)buf, 0x200uLL, "doc_store_delete_documents_bulk(%p, %d, ...)", v9, a3);
  v18[0] = 0;
  v18[1] = 0;
  ScopeLogger::ScopeLogger((ScopeLogger *)v18, (const char *)buf);
  if (!v9)
  {
    ScopeLogger::~ScopeLogger((ScopeLogger *)v18);
    v10 = -14;
LABEL_9:
    v14 = *__error();
    v15 = _SILogForLogForCategory(8);
    v16 = dword_1EF19FCAC < 3;
    if (os_log_type_enabled(v15, (os_log_type_t)(dword_1EF19FCAC < 3)))
    {
      v17 = strerror(-v10);
      *(_DWORD *)buf = 134218242;
      *(_QWORD *)&buf[4] = a3;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = v17;
      _os_log_impl(&dword_1B8270000, v15, v16, "*warn* doc_store_delete_documents_bulk(%zd): %s", buf, 0x16u);
    }
    *__error() = v14;
    return;
  }
  v10 = DocStore::DeleteDocumentsBulk(v9, a3, a2);
  v11 = *__error();
  v12 = _SILogForLogForCategory(8);
  v13 = 2 * (dword_1EF19FCAC < 4);
  if (os_log_type_enabled(v12, v13))
  {
    *(_DWORD *)v19 = 136315394;
    v20 = "doc_store_delete_documents_bulk";
    v21 = 1024;
    v22 = v10;
    _os_log_impl(&dword_1B8270000, v12, v13, "%s returns %d\n", v19, 0x12u);
  }
  *__error() = v11;
  ScopeLogger::~ScopeLogger((ScopeLogger *)v18);
  if (v10)
    goto LABEL_9;
}

void si_deleteCacheEntry(CFDictionaryRef *a1, int a2)
{
  CFDictionaryRef v3;
  const void *Value;
  uint64_t v5;
  int v6;
  CFDictionaryRef v7;
  CFIndex Count;
  CFIndex v9;
  CFIndex i;
  const __CFString *ValueAtIndex;
  char *CStringPtr;
  __int16 v13;
  CFStringRef v14;
  CFStringRef v15;
  uint64_t v16;
  unint64_t v17;
  CFStringRef String;
  CFStringRef v19;
  int v20;
  NSObject *v21;
  int v22;
  NSObject *v23;
  const __CFArray *theArray;
  unint64_t v25;
  const char *v26;
  unint64_t v27;
  _BYTE buf[24];
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  if (!a2)
  {
    if (dword_1EF19FCC0 >= 5)
    {
      v20 = *__error();
      v21 = _SILogForLogForCategory(13);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = qos_class_self();
        _os_log_impl(&dword_1B8270000, v21, OS_LOG_TYPE_DEFAULT, "si_deleteCacheEntry at qos 0x%x", buf, 8u);
      }
      *__error() = v20;
    }
    if (_os_feature_enabled_impl())
    {
      v3 = *a1;
      if (a1[2])
      {
        Value = CFDictionaryGetValue(a1[2], CFSTR("_kMDItemBundleID"));
        if (SpotlightCacheBundleID())
        {
          SpotlightCacheDeleteEntry();
          goto LABEL_13;
        }
      }
      else
      {
        v5 = (uint64_t)a1[1];
        if (v5)
        {
          v25 = 0;
          v26 = 0;
          if (!db_get_field(*((int **)v3 + 148), v5, "_kMDItemBundleID", &v25, &v26))
          {
            Value = createString(*((int **)v3 + 148), *(_WORD *)(v25 + 2), &v26);
            v6 = SpotlightCacheBundleID();
            if (v6)
            {
              theArray = (const __CFArray *)SpotlightCacheAttributes();
              Count = CFArrayGetCount(theArray);
              if (Count >= 1)
              {
                v9 = Count;
                for (i = 0; i != v9; ++i)
                {
                  ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, i);
                  v27 = 0;
                  *(_QWORD *)buf = 0;
                  CStringPtr = (char *)CFStringGetCStringPtr(ValueAtIndex, 0x8000100u);
                  if (CStringPtr && !db_get_field(*((int **)v3 + 148), v5, CStringPtr, &v27, buf))
                  {
                    SpotlightCachePayload();
                    v13 = *(_WORD *)(v27 + 2);
                    if ((v13 & 0x20) != 0)
                    {
                      v16 = *(unsigned int *)(v27 + 8);
                      if ((_DWORD)v16)
                      {
                        v17 = *(_QWORD *)buf + v16;
                        do
                        {
                          String = createString(*((int **)v3 + 148), *(_WORD *)(v27 + 2), (const char **)buf);
                          if (String)
                          {
                            v19 = String;
                            SpotlightCacheDelete();
                            CFRelease(v19);
                          }
                        }
                        while (*(_QWORD *)buf < v17);
                      }
                    }
                    else
                    {
                      v14 = createString(*((int **)v3 + 148), v13, (const char **)buf);
                      if (v14)
                      {
                        v15 = v14;
                        SpotlightCacheDelete();
                        CFRelease(v15);
                      }
                    }
                  }
                }
              }
            }
            if (Value)
              CFRelease(Value);
            goto LABEL_11;
          }
        }
        Value = 0;
      }
      v6 = 0;
LABEL_11:
      if (!v6 && dword_1EF19FCB0 >= 5)
      {
        v22 = *__error();
        v23 = _SILogForLogForCategory(9);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138412290;
          *(_QWORD *)&buf[4] = Value;
          _os_log_impl(&dword_1B8270000, v23, OS_LOG_TYPE_DEFAULT, "SpotlightCache delete do not support bundleID %@", buf, 0xCu);
        }
        *__error() = v22;
      }
    }
  }
LABEL_13:
  v7 = a1[2];
  if (v7)
    CFRelease(v7);
  free(a1);
}

void si_closeCache(uint64_t *a1, int a2)
{
  uint64_t v3;
  int v4;
  NSObject *v5;
  _DWORD v6[2];
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if (!a2)
  {
    if (dword_1EF19FCC0 >= 5)
    {
      v4 = *__error();
      v5 = _SILogForLogForCategory(13);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        v6[0] = 67109120;
        v6[1] = qos_class_self();
        _os_log_impl(&dword_1B8270000, v5, OS_LOG_TYPE_DEFAULT, "si_closeCache at qos 0x%x", (uint8_t *)v6, 8u);
      }
      *__error() = v4;
    }
    if (_os_feature_enabled_impl())
    {
      v3 = *a1;
      MDTrieClose();
      *(_QWORD *)(v3 + 1288) = 0;
    }
  }
  free(a1);
}

int *hot_shard_update_logical_size(uint64_t a1)
{
  off_t v2;
  _QWORD v4[2];
  off_t v5;

  v2 = lseek(a1, 0, 2);
  if (v2 < 0)
    return __error();
  v4[0] = &v5;
  v4[1] = 8;
  v5 = v2;
  return (int *)pwritevall(a1, v4, 1, 0);
}

uint64_t hot_shard_for_each_region(int a1, uint64_t a2)
{
  _BYTE *v4;
  int v5;
  uint64_t v6;
  uint64_t i;
  ssize_t v8;
  unint64_t v9;
  unint64_t v10;
  unsigned __int8 *v11;
  int v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unsigned __int8 *v19;

  if (lseek(a1, 8, 0) < 0)
    return -*__error();
  v4 = (_BYTE *)operator new[]();
  v5 = 0;
  v6 = 0;
  for (i = 8; ; i += v9)
  {
    while (1)
    {
      v8 = read(a1, &v4[v6], 0x20000 - v6);
      if ((v8 & 0x8000000000000000) == 0)
        break;
      if (*__error() != 4)
      {
        v6 = -*__error();
        goto LABEL_24;
      }
    }
    if (!v8)
      break;
    v9 = 0;
    v10 = v8 + v6;
    do
    {
      if (v10 <= v9)
      {
        v5 = 0;
        goto LABEL_23;
      }
      v19 = &v4[v9];
      if (v4[v9])
      {
        v17 = 0;
        v18 = v10 - v9;
        v16 = 0;
        if (v2_readVInt64((const unsigned __int8 **)&v19, &v18, &v17)
          || (v11 = v19, v2_readVInt64((const unsigned __int8 **)&v19, &v18, &v16))
          || !v18
          || v11 - (v19 + 1) + v17 > v18 - 1)
        {
          v6 = 0;
          v5 = 1;
          v12 = 1;
        }
        else
        {
          v13 = &v11[v17] - &v4[v9];
          v14 = (*(uint64_t (**)(uint64_t, unint64_t, _QWORD))(a2 + 16))(a2, v16, (char)*v19);
          if ((_DWORD)v14)
          {
            v12 = 1;
            v6 = v14;
          }
          else
          {
            v12 = 0;
            v9 += v13;
          }
        }
      }
      else
      {
        ++v9;
        v12 = 2;
      }
    }
    while (v12 != 1);
    if ((_DWORD)v6)
      goto LABEL_24;
LABEL_23:
    v6 = v10 - v9;
    memmove(v4, &v4[v9], v10 - v9);
  }
  if (v5)
    v6 = 4294967274;
  else
    v6 = 0;
LABEL_24:
  MEMORY[0x1BCCB068C](v4, 0x1000C8077774924);
  return v6;
}

uint64_t __hot_shard_iterate_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t hot_shard_trim(uint64_t a1, off_t *a2, _QWORD *a3)
{
  uint64_t result;
  off_t v7;
  off_t st_size;
  _QWORD v9[5];
  off_t v10;
  stat v11;
  off_t *v12;
  uint64_t v13;
  off_t v14;
  _QWORD v15[5];

  v12 = &v14;
  v13 = 8;
  v14 = 0;
  result = preadvall(a1, (uint64_t)&v12, 0);
  if ((result & 0x80000000) == 0)
  {
    memset(&v11, 0, sizeof(v11));
    if (fstat(a1, &v11))
      return -*__error();
    v7 = v14;
    if (v14 >= v11.st_size)
      st_size = v11.st_size;
    else
      st_size = v14;
    v10 = st_size;
    if (v11.st_size > v14)
    {
      if (ftruncate(a1, st_size))
        return -*__error();
      v7 = v14;
    }
    if (v7 > st_size)
    {
      v12 = &v10;
      v13 = 8;
      if (pwritevall(a1, &v12, 1, 0))
        return -*__error();
      st_size = v10;
    }
    *a2 = st_size;
    *a3 = 0;
    v9[0] = MEMORY[0x1E0C809B0];
    v9[1] = 0x40000000;
    v9[2] = __hot_shard_trim_block_invoke;
    v9[3] = &__block_descriptor_tmp_2_6977;
    v9[4] = a3;
    v15[0] = MEMORY[0x1E0C809B0];
    v15[1] = 0x40000000;
    v15[2] = __hot_shard_iterate_block_invoke;
    v15[3] = &unk_1E6E34E90;
    v15[4] = v9;
    return hot_shard_for_each_region(a1, (uint64_t)v15);
  }
  return result;
}

uint64_t __hot_shard_trim_block_invoke(uint64_t a1)
{
  ++**(_QWORD **)(a1 + 32);
  return 0;
}

uint64_t __hot_shard_delete_docs_block_invoke(uint64_t a1, unint64_t a2, int a3, int a4, int a5, off_t a6, unint64_t a7)
{
  int8x8_t v7;
  uint8x8_t v9;
  unint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  unint64_t v13;
  uint64_t result;

  v7 = *(int8x8_t *)(a1 + 40);
  if (!*(_QWORD *)&v7)
    return 0;
  v9 = (uint8x8_t)vcnt_s8(v7);
  v9.i16[0] = vaddlv_u8(v9);
  if (v9.u32[0] > 1uLL)
  {
    v10 = a2;
    if (*(_QWORD *)&v7 <= a2)
      v10 = a2 % *(_QWORD *)&v7;
  }
  else
  {
    v10 = (*(_QWORD *)&v7 - 1) & a2;
  }
  v11 = *(_QWORD **)(*(_QWORD *)(a1 + 32) + 8 * v10);
  if (!v11)
    return 0;
  v12 = (_QWORD *)*v11;
  if (!v12)
    return 0;
  while (1)
  {
    v13 = v12[1];
    if (v13 == a2)
      break;
    if (v9.u32[0] > 1uLL)
    {
      if (v13 >= *(_QWORD *)&v7)
        v13 %= *(_QWORD *)&v7;
    }
    else
    {
      v13 &= *(_QWORD *)&v7 - 1;
    }
    if (v13 != v10)
      return 0;
LABEL_16:
    v12 = (_QWORD *)*v12;
    if (!v12)
      return 0;
  }
  if (v12[2] != a2)
    goto LABEL_16;
  result = wipe_region(*(unsigned int *)(a1 + 80), a6, a7);
  if (!(_DWORD)result)
    ++**(_QWORD **)(a1 + 72);
  return result;
}

uint64_t std::unordered_set<long long>::unordered_set(uint64_t a1, uint64_t a2)
{
  _QWORD *i;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  std::__hash_table<std::__hash_value_type<std::string,int>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,int>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,int>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,int>>>::__rehash<true>(a1, *(_QWORD *)(a2 + 8));
  for (i = *(_QWORD **)(a2 + 16); i; i = (_QWORD *)*i)
    std::__hash_table<long long,std::hash<long long>,std::equal_to<long long>,std::allocator<long long>>::__emplace_unique_key_args<long long,long long const&>(a1, i[2], i[2]);
  return a1;
}

void std::__hash_table<long long,std::hash<long long>,std::equal_to<long long>,std::allocator<long long>>::__emplace_unique_key_args<long long,long long const&>(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v6;
  uint8x8_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *i;
  unint64_t v11;
  _QWORD *v12;
  float v13;
  float v14;
  _BOOL8 v15;
  unint64_t v16;
  unint64_t v17;
  size_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  unint64_t v22;

  v6 = *(_QWORD *)(a1 + 8);
  if (v6)
  {
    v7 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      v8 = a2;
      if (v6 <= a2)
        v8 = a2 % v6;
    }
    else
    {
      v8 = (v6 - 1) & a2;
    }
    v9 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v8);
    if (v9)
    {
      for (i = (_QWORD *)*v9; i; i = (_QWORD *)*i)
      {
        v11 = i[1];
        if (v11 == a2)
        {
          if (i[2] == a2)
            return;
        }
        else
        {
          if (v7.u32[0] > 1uLL)
          {
            if (v11 >= v6)
              v11 %= v6;
          }
          else
          {
            v11 &= v6 - 1;
          }
          if (v11 != v8)
            break;
        }
      }
    }
  }
  else
  {
    v8 = 0;
  }
  v12 = operator new(0x18uLL);
  v12[1] = a2;
  v12[2] = a3;
  v13 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v14 = *(float *)(a1 + 32);
  if (!v6 || (float)(v14 * (float)v6) < v13)
  {
    v15 = 1;
    if (v6 >= 3)
      v15 = (v6 & (v6 - 1)) != 0;
    v16 = v15 | (2 * v6);
    v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17)
      v18 = v17;
    else
      v18 = v16;
    std::__hash_table<std::__hash_value_type<std::string,int>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,int>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,int>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,int>>>::__rehash<true>(a1, v18);
    v6 = *(_QWORD *)(a1 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v6 <= a2)
        v8 = a2 % v6;
      else
        v8 = a2;
    }
    else
    {
      v8 = (v6 - 1) & a2;
    }
  }
  v19 = *(_QWORD *)a1;
  v20 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v8);
  if (v20)
  {
    *v12 = *v20;
LABEL_38:
    *v20 = v12;
    goto LABEL_39;
  }
  v21 = *(_QWORD *)(a1 + 16);
  *v12 = v21;
  *(_QWORD *)(a1 + 16) = v12;
  *(_QWORD *)(v19 + 8 * v8) = a1 + 16;
  if (v21)
  {
    v22 = *(_QWORD *)(v21 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v22 >= v6)
        v22 %= v6;
    }
    else
    {
      v22 &= v6 - 1;
    }
    v20 = (_QWORD *)(*(_QWORD *)a1 + 8 * v22);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
}

uint64_t __copy_helper_block_8_32c75_ZTSNSt3__113unordered_setIxNS_4hashIxEENS_8equal_toIxEENS_9allocatorIxEEEE(uint64_t a1, uint64_t a2)
{
  return std::unordered_set<long long>::unordered_set(a1 + 32, a2 + 32);
}

uint64_t __destroy_helper_block_8_32c75_ZTSNSt3__113unordered_setIxNS_4hashIxEENS_8equal_toIxEENS_9allocatorIxEEEE(uint64_t a1)
{
  return std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::~__hash_table(a1 + 32);
}

uint64_t wipe_region(uint64_t __fd, off_t a2, unint64_t a3)
{
  unint64_t v6;
  int v7;
  uint64_t *v8;
  uint64_t v9;
  int v10;
  uint64_t result;
  _OWORD v13[16];
  _OWORD v14[16];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  memset(v14, 0, sizeof(v14));
  while (a3)
  {
    v6 = 0;
    v7 = 0;
    v8 = (uint64_t *)v13 + 1;
    memset(v13, 0, sizeof(v13));
    do
    {
      if (a3 >= 0x100)
        v9 = 256;
      else
        v9 = a3;
      *(v8 - 1) = (uint64_t)v14;
      *v8 = v9;
      v7 += v9;
      v10 = v6 + 1;
      a3 -= v9;
      if (!a3)
        break;
      v8 += 2;
    }
    while (v6++ < 0xF);
    result = pwritevall(__fd, v13, v10, a2);
    a2 += v7;
    if ((_DWORD)result)
      return result;
  }
  return 0;
}

uint64_t __hot_shard_delete_docs_by_predicate_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, off_t a6, unint64_t a7)
{
  uint64_t result;

  result = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  if ((_DWORD)result)
  {
    result = wipe_region(*(unsigned int *)(a1 + 48), a6, a7);
    if (!(_DWORD)result)
      ++**(_QWORD **)(a1 + 40);
  }
  return result;
}

CFTypeID __fastFieldFromCFType_block_invoke()
{
  CFTypeID result;

  fastFieldFromCFType_sStringTypeID = CFStringGetTypeID();
  fastFieldFromCFType_sNumberTypeID = CFNumberGetTypeID();
  fastFieldFromCFType_sDateTypeID = CFDateGetTypeID();
  fastFieldFromCFType_sBoolTypeID = CFBooleanGetTypeID();
  fastFieldFromCFType_sDataTypeID = CFDataGetTypeID();
  fastFieldFromCFType_sNullTypeID = CFNullGetTypeID();
  result = CFDictionaryGetTypeID();
  fastFieldFromCFType_sDictionaryTypeID = result;
  return result;
}

void si_getCSAttr(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  int v3;
  CFTypeID v4;
  const __CFArray *v5;
  CFIndex Count;
  CFIndex v7;
  size_t v8;
  _QWORD *BytePtr;
  _BYTE *v10;
  CFIndex v11;
  const __CFString *v12;
  const __CFString *ValueAtIndex;
  _BOOL4 v14;
  const __CFData *v15;
  unint64_t Length;
  const void *v17;
  const void *v18;
  const void *v19;
  const void *v20;
  const void *v21;
  unint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  int *v25;
  char *v26;
  const __CFAllocator *v27;
  __CFSet *v28;
  unint64_t *v29;
  double v30;
  double v31;
  __n128 v32;
  unint64_t v33;
  unint64_t v34;
  void *v35;
  uint64_t i;
  unsigned int *v37;
  const void **v38;
  const void *v39;
  const __CFString *v40;
  int v41;
  uint64_t v42;
  CFIndex *v43;
  CFIndex v44;
  const __CFString *v45;
  uint64_t v46;
  CFIndex v47;
  CFIndex v48;
  const void **v49;
  uint64_t j;
  const void *v51;
  size_t v52;
  _BYTE *v53;
  int Path;
  int v55;
  uint64_t v56;
  CFIndex v57;
  size_t v58;
  size_t v59;
  void *v60;
  int v61;
  NSObject *v62;
  os_log_type_t v63;
  CFAbsoluteTime v64;
  const void *Mutable;
  char *v66;
  int v67;
  NSObject *v68;
  int v69;
  int id_for_string;
  uint64_t v71;
  _BOOL4 v72;
  _QWORD *v73;
  int *v74;
  int *v75;
  int *v76;
  __CFSet *theSet;
  char *v78;
  void *v79;
  void *v80;
  const __CFArray *theArray;
  uint64_t v82;
  uint64_t v83;
  char v84;
  unint64_t v85;
  unint64_t v86;
  CFIndex idx;
  uint8_t buf[16];
  __int128 v89;
  size_t v90[4];
  char *v91[8];

  v1 = MEMORY[0x1E0C80A78](a1);
  v2 = v1;
  v91[5] = *(char **)MEMORY[0x1E0C80C00];
  if (v3 && *(_QWORD *)(v1 + 16))
  {
    (*(void (**)(void))(*(_QWORD *)(v1 + 56) + 16))();
    goto LABEL_15;
  }
  if (dword_1EF19FCC0 >= 5)
  {
    v67 = *__error();
    v68 = _SILogForLogForCategory(13);
    if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = qos_class_self();
      _os_log_impl(&dword_1B8270000, v68, OS_LOG_TYPE_DEFAULT, "si_getCSAttr at qos 0x%x", buf, 8u);
    }
    *__error() = v67;
  }
  v4 = CFGetTypeID(*(CFTypeRef *)(v2 + 16));
  if (v4 != CFArrayGetTypeID())
  {
    if (v4 == CFDataGetTypeID())
    {
      v15 = *(const __CFData **)(v2 + 16);
      Length = CFDataGetLength(v15);
      if (Length >= 8)
      {
        v22 = Length;
        v8 = Length >> 3;
        BytePtr = CFDataGetBytePtr(v15);
        v14 = *BytePtr != 0;
        if (*BytePtr)
        {
          ++v8;
          v23 = malloc_type_malloc(8 * v8, 0x100004000313F17uLL);
          *v23 = 0;
          memcpy(v23 + 1, BytePtr, v22 & 0xFFFFFFFFFFFFFFF8);
          BytePtr = v23;
        }
        v10 = malloc_type_calloc(v8, 1uLL, 0x16B891D2uLL);
        v5 = 0;
        goto LABEL_29;
      }
    }
LABEL_13:
    (*(void (**)(void))(*(_QWORD *)(v2 + 56) + 16))();
    v10 = 0;
    goto LABEL_14;
  }
  if (!*(_QWORD *)(v2 + 8))
    goto LABEL_13;
  v5 = *(const __CFArray **)(v2 + 16);
  Count = CFArrayGetCount(v5);
  if (!Count)
    goto LABEL_13;
  v7 = Count;
  v8 = Count + 1;
  BytePtr = malloc_type_malloc(8 * (Count + 1), 0x100004000313F17uLL);
  v10 = malloc_type_calloc(v8, 1uLL, 0x976A85BCuLL);
  v11 = 0;
  *BytePtr = 0;
  do
  {
    v12 = *(const __CFString **)(v2 + 8);
    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(*(CFArrayRef *)(v2 + 16), v11);
    BytePtr[++v11] = si_compute_oid_for_identifier(v12, ValueAtIndex);
  }
  while (v7 != v11);
  v14 = 1;
LABEL_29:
  if (v8 < 2 || (*(_DWORD *)(v2 + 48) & 1) == 0)
    goto LABEL_91;
  v24 = *(_QWORD *)v2;
  v82 = *(_QWORD *)(*(_QWORD *)v2 + 6624);
  if (!v82)
  {
LABEL_92:
    v91[0] = 0;
    v90[0] = 0;
    idx = 0;
    SIFlattenArrayToCStringVector(*(const __CFArray **)(v2 + 24), v91, v90, &idx);
    v61 = *__error();
    v62 = _SILogForLogForCategory(5);
    v63 = 2 * (dword_1EF19FCA0 < 4);
    if (os_log_type_enabled(v62, v63))
    {
      v64 = CFAbsoluteTimeGetCurrent() - *(double *)(v2 + 32);
      *(_DWORD *)buf = 134217984;
      *(CFAbsoluteTime *)&buf[4] = v64;
      _os_log_impl(&dword_1B8270000, v62, v63, "Waited %f seconds on scheduler", buf, 0xCu);
    }
    *__error() = v61;
    Mutable = (const void *)_MDPlistBytesCreateMutable();
    _MDPlistBytesBeginPlist();
    _MDPlistBytesBeginArray();
    v66 = v91[0];
    _fillPlistBytes(*(_QWORD *)v2, (uint64_t)Mutable, (uint64_t)v91[0], idx, (uint64_t)BytePtr, v8, (uint64_t)v10, 0, *(_QWORD *)(v2 + 40), 0, v5, *(const __CFString **)(v2 + 8));
    _MDPlistBytesEndArray();
    _MDPlistBytesEndPlist();
    (*(void (**)(void))(*(_QWORD *)(v2 + 56) + 16))();
    if (Mutable)
      CFRelease(Mutable);
    free(v66);
    if (v14)
      goto LABEL_99;
    goto LABEL_14;
  }
  v25 = *(int **)(v24 + 1184);
  memset(v91, 0, 32);
  memset(v90, 0, sizeof(v90));
  theArray = v5;
  v73 = BytePtr;
  v72 = v14;
  v75 = v25;
  v71 = v24;
  if (v5)
  {
    v74 = (int *)db_copy_field_ids_with_buffer(v25, "_kMDItemExternalID", (uint64_t)v91, 8uLL);
    v76 = (int *)db_copy_field_ids_with_buffer(v25, "_kMDItemBundleID", (uint64_t)v90, 8uLL);
    *(_OWORD *)buf = 0u;
    v89 = 0u;
    LOBYTE(v86) = 0;
    v26 = fasterUTF8String(*(const __CFString **)(v2 + 8), &idx, (char *)buf, 32, &v86);
    id_for_string = db_get_id_for_string(v25, v26);
    if ((_BYTE)v86)
      free(v26);
  }
  else
  {
    v74 = 0;
    v76 = 0;
    id_for_string = 0;
  }
  v27 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  theSet = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0);
  v28 = CFSetCreateMutable(v27, 0, 0);
  v29 = db_obj_iter_create_with_filter(*(int **)(*(_QWORD *)v2 + 1184), v8 - 1, (uint64_t)(BytePtr + 1), 0, 0, 0, 0, 0, 0);
  v33 = 0;
  v34 = 0;
  v35 = 0;
  for (i = 1; i != v8; ++i)
  {
    idx = 0;
    v37 = db_obj_iter_next((uint64_t)v29, (unint64_t *)&idx, 1, v30, v31, v32);
    if (!v37)
      continue;
    v38 = (const void **)v37;
    v39 = *(const void **)v37;
    if (*(uint64_t *)v37 < 3 || v10[i])
      continue;
    if (theArray)
    {
      v85 = 0;
      v86 = 0;
      if (db_get_field_by_id(v75, (uint64_t)v37, v76, &v86, &v85)
        || *(_DWORD *)(v86 + 13) != id_for_string
        || db_get_field_by_id(v75, (uint64_t)v38, v74, &v86, &v85))
      {
        goto LABEL_48;
      }
      v40 = (const __CFString *)CFArrayGetValueAtIndex(theArray, idx);
      *(_OWORD *)buf = 0u;
      v89 = 0u;
      v84 = 0;
      v78 = fasterUTF8String(v40, &v83, (char *)buf, 32, &v84);
      v41 = strcmp((const char *)(v86 + 13), v78);
      if (v84)
      {
        v69 = v41;
        free(v78);
        v41 = v69;
      }
      if (v41)
      {
LABEL_48:
        if (v33 >= v34)
        {
          if (v34)
            v34 *= 2;
          else
            v34 = 4;
          v35 = malloc_type_realloc(v35, 8 * v34, 0x100004000313F17uLL);
        }
        *((_QWORD *)v35 + v33++) = idx;
        continue;
      }
      v79 = v35;
      v39 = *v38;
    }
    else
    {
      v79 = v35;
    }
    CFSetAddValue(theSet, v39);
    CFSetRemoveValue(v28, *v38);
    v42 = (uint64_t)v38[3];
    if (v42 >= 3 && !CFSetGetValue(theSet, (const void *)v42))
      CFSetAddValue(v28, v38[3]);
    v35 = v79;
  }
  v80 = v35;
  db_obj_iter_release((uint64_t)v29);
  v5 = theArray;
  if (v33)
  {
    v43 = (CFIndex *)v35;
    do
    {
      v44 = *v43++;
      v45 = (const __CFString *)CFArrayGetValueAtIndex(theArray, v44);
      *(_QWORD *)buf = 0;
      if (!si_get_object_for_identifier_createParentDBO(v71, *(const __CFString **)(v2 + 8), v45, 0, 0, 0, buf, 0))
      {
        CFSetAddValue(theSet, **(const void ***)buf);
        CFSetRemoveValue(v28, **(const void ***)buf);
        v46 = *(_QWORD *)(*(_QWORD *)buf + 24);
        if (v46 >= 3 && !CFSetGetValue(theSet, (const void *)v46))
          CFSetAddValue(v28, *(const void **)(*(_QWORD *)buf + 24));
      }
      --v33;
    }
    while (v33);
  }
  v47 = CFSetGetCount(v28);
  if (v47)
  {
    v48 = v47;
    v49 = (const void **)malloc_type_malloc(8 * v47, 0x100004000313F17uLL);
    CFSetGetValues(v28, v49);
    CFSetRemoveAllValues(v28);
    for (j = 0; j != v48; ++j)
    {
      v51 = v49[j];
      if (!CFSetGetValue(v28, v51))
      {
        v52 = v8;
        v53 = v10;
        CFSetAddValue(v28, v51);
        bzero(buf, 0x1000uLL);
        Path = directoryStoreGetPath(v82, (unint64_t)v51, (uint64_t)buf);
        if (Path >= 2)
        {
          v55 = Path - 1;
          do
          {
            v56 = *(_QWORD *)&buf[8 * --v55];
            if (v56 < 3)
              break;
            if (CFSetGetValue(v28, *(const void **)&buf[8 * v55]))
              break;
            CFSetAddValue(v28, (const void *)v56);
          }
          while (v55 > 0);
        }
        v10 = v53;
        v8 = v52;
      }
    }
    free(v49);
    v5 = theArray;
  }
  CFRelease(theSet);
  if (v74 != (int *)v91)
    free(v74);
  BytePtr = v73;
  v14 = v72;
  if (v76 != (int *)v90)
    free(v76);
  free(v80);
  if (v28)
  {
    v57 = CFSetGetCount(v28);
    if (v57)
    {
      v58 = v57;
      v59 = v57 + v8;
      if (v72)
      {
        BytePtr = malloc_type_realloc(v73, 8 * (v57 + v8), 0x100004000313F17uLL);
      }
      else
      {
        v60 = malloc_type_malloc(8 * (v57 + v8), 0x100004000313F17uLL);
        memcpy(v60, v73, 8 * v8);
        BytePtr = v60;
        v5 = theArray;
      }
      CFSetGetValues(v28, (const void **)&BytePtr[v8]);
      v10 = malloc_type_realloc(v10, v59, 0xED7C1FC7uLL);
      bzero(&v10[v59], v58);
      v14 = 1;
      v8 = v59;
    }
    CFRelease(v28);
  }
LABEL_91:
  if (v8)
    goto LABEL_92;
  (*(void (**)(void))(*(_QWORD *)(v2 + 56) + 16))();
  if (v14)
LABEL_99:
    free(BytePtr);
LABEL_14:
  free(v10);
LABEL_15:
  v17 = *(const void **)(v2 + 8);
  if (v17)
    CFRelease(v17);
  *(_QWORD *)(v2 + 8) = 0;
  v18 = *(const void **)(v2 + 16);
  if (v18)
    CFRelease(v18);
  *(_QWORD *)(v2 + 16) = 0;
  v19 = *(const void **)(v2 + 56);
  if (v19)
    CFRelease(v19);
  *(_QWORD *)(v2 + 56) = 0;
  v20 = *(const void **)(v2 + 24);
  if (v20)
    CFRelease(v20);
  *(_QWORD *)(v2 + 24) = 0;
  v21 = *(const void **)(v2 + 40);
  if (v21)
    CFRelease(v21);
  free((void *)v2);
}

uint64_t _fillPlistBytes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int64_t a6, uint64_t a7, char **a8, uint64_t a9, unsigned __int8 a10, const __CFArray *a11, const __CFString *a12)
{
  uint64_t v14;
  int *v15;
  uint64_t v16;
  unsigned int v17;
  int v18;
  unint64_t v19;
  unsigned int v20;
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(_QWORD);
  CFTypeID Value;
  int v26;
  NSObject *v27;
  const __CFNumber *v29;
  CFTypeID v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  _DWORD *v37;
  int v38;
  char *v39;
  uint64_t v40;
  unsigned int v41;
  uint64_t v42;
  uint64_t v43;
  _BOOL8 v44;
  const char *v45;
  int v46;
  BOOL v47;
  char *v48;
  char *v49;
  void *v50;
  const char *v51;
  const char **v52;
  const char **v53;
  const char *v54;
  const char **v55;
  uint64_t v56;
  int v57;
  int v59;
  int v60;
  uint64_t v61;
  void **v62;
  size_t v63;
  uint64_t v64;
  int v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  _DWORD *v69;
  int *v70;
  int v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t (*v74)(uint64_t, uint64_t);
  char **v75;
  char **v76;
  char *v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  int *v82;
  int *v83;
  int v84;
  uint64_t v85;
  char *v86;
  int v87;
  int *v88;
  char *v89;
  int *v90;
  int v91;
  int v92;
  int *v93;
  int *v94;
  int v95;
  int v96;
  size_t *v97;
  char *v98;
  char *v99;
  uint64_t v100;
  char *v101;
  char *v102;
  size_t v103;
  uint64_t v104;
  uint64_t v105;
  void *v106;
  size_t v107;
  char *v108;
  int *v109;
  int v110;
  uint64_t v111;
  uint64_t v112;
  int v113;
  uint64_t v114;
  int v115;
  uint64_t v116;
  char *v117;
  int *v118;
  uint64_t v119;
  void *v120;
  uint64_t v121;
  int v122;
  void *v123;
  uint64_t v124;
  void *v125;
  int v126;
  uint64_t v127;
  char *v128;
  uint64_t v129;
  char *v130;
  uint64_t v131;
  uint64_t v132;
  int v133;
  uint64_t v134;
  int v135;
  uint64_t v136;
  char *v137;
  uint64_t v138;
  int v139;
  int *v140;
  int v141;
  uint64_t v142;
  uint64_t v143;
  int v144;
  uint64_t v145;
  int v146;
  uint64_t v147;
  char *v148;
  int *v149;
  char *v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  char *v154;
  uint64_t v155;
  int v156;
  uint64_t v157;
  uint64_t v158;
  char *v159;
  int v160;
  int v161;
  int v162;
  int *v163;
  int v164;
  uint64_t v165;
  uint64_t v166;
  int v167;
  uint64_t v168;
  char *v169;
  int *v170;
  int v171;
  int v172;
  int v173;
  int *v174;
  int v175;
  uint64_t v176;
  int v177;
  uint64_t v178;
  char *v179;
  int *v180;
  int v181;
  int v182;
  int v183;
  size_t v184;
  uint64_t v185;
  size_t v186;
  _QWORD *v187;
  const __CFString *v188;
  uint64_t v189;
  _QWORD *v190;
  unsigned __int8 *v191;
  uint64_t v192;
  uint64_t v194;
  void **v195;
  int *v196;
  int *v197;
  char *v198;
  int id_for_string;
  int *v200;
  uint64_t v201;
  uint64_t v202;
  unint64_t v203;
  unint64_t *v204;
  double v205;
  double v206;
  __n128 v207;
  uint64_t v208;
  unint64_t v209;
  unint64_t v210;
  void *v211;
  unsigned int *v212;
  unsigned int *v213;
  const __CFString *ValueAtIndex;
  char *v215;
  int v216;
  _DWORD *v217;
  _DWORD *v218;
  unint64_t v219;
  CFIndex *v220;
  CFIndex *v221;
  unint64_t v222;
  char *v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  char *v231;
  const char *v232;
  const char *v233;
  CFIndex *v234;
  CFIndex *v235;
  CFIndex v236;
  CFIndex *v237;
  const __CFString *v238;
  uint64_t v239;
  __int128 v240;
  __int128 v241;
  uint64_t v242;
  uint64_t v243;
  int v244;
  uint64_t v245;
  uint64_t v246;
  uint64_t v247;
  char *v248;
  uint64_t i;
  uint64_t v250;
  uint64_t v251;
  const char *v252;
  uint64_t (*v253)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, void *, uint64_t);
  uint64_t v254;
  uint64_t (*v255)(void);
  uint64_t v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  NSObject *v260;
  uint64_t v261;
  BOOL v262;
  uint64_t j;
  uint64_t v264;
  const char *v265;
  uint64_t (*v266)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, void *, uint64_t);
  uint64_t v267;
  uint64_t v268;
  uint64_t v269;
  uint64_t v270;
  uint64_t v271;
  int v272;
  NSObject *v273;
  uint64_t v274;
  int v275;
  void **v276;
  uint64_t v277;
  uint64_t v278;
  void **v279;
  uint64_t v280;
  uint64_t v281;
  void *v282;
  void **v283;
  uint64_t v284;
  uint64_t v285;
  void **v286;
  uint64_t v287;
  unsigned int v288;
  uint64_t v289;
  void (*v290)(_QWORD);
  int v291;
  char *v292;
  uint64_t v293;
  uint64_t v294;
  uint64_t v295;
  uint64_t v296;
  uint64_t v297;
  uint64_t v298;
  uint64_t v299;
  char *v300;
  const char *v301;
  uint64_t v302;
  const char *v303;
  uint64_t v304;
  const char *v305;
  const char *v306;
  const char *v307;
  const char *v308;
  const char *v309;
  int v310;
  int v311;
  size_t v312;
  uint64_t v313;
  CFIndex v314;
  int *v315;
  malloc_type_id_t v316;
  uint64_t v317;
  int v318;
  int *v319;
  int *v320;
  uint64_t v321;
  int v322;
  __int128 v323;
  __int128 v324;
  void **v325;
  size_t v326;
  size_t v327;
  size_t v328;
  char *v329;
  char *v330;
  CFIndex *v331;
  char *v332;
  char *v333;
  uint64_t v334;
  void **v335;
  int v336;
  void *v337;
  char *v338;
  char *v339;
  size_t v340;
  int v341;
  CFArrayRef v342;
  const __CFString *v343;
  int v344;
  char *v345;
  char *v346;
  char *v347;
  int *v348;
  int v349;
  uint64_t v350;
  uint64_t v351;
  uint64_t v352;
  uint64_t v353;
  uint64_t v354;
  char **v355;
  uint64_t v356;
  int64_t v357;
  int v358;
  int v359;
  uint64_t v360;
  char v361;
  unint64_t v362;
  unint64_t v363;
  int v364;
  unsigned int v365;
  unsigned int v366;
  unsigned int v367;
  unsigned int v368;
  unsigned int v369;
  unsigned int v370;
  unsigned int v371;
  unsigned int v372;
  _BYTE v373[12];
  __int16 v374;
  uint64_t v375;
  void *v376[128];
  _BYTE v377[32];
  _BYTE v378[32];
  _DWORD v379[2];
  uint64_t v380;

  v354 = a7;
  v355 = a8;
  v352 = a2;
  v353 = a5;
  v321 = a3;
  v342 = a11;
  v343 = a12;
  v350 = a9;
  v380 = *MEMORY[0x1E0C80C00];
  v349 = a10;
  v341 = a10;
  v14 = *(_QWORD *)(a1 + 1184);
  v15 = (int *)v14;
  v356 = a4;
  v16 = a4 + 1;
  v334 = a4 + 1;
  do
  {
    v17 = __ldxr(exceptionSequenceNum);
    v18 = v17 + 1;
  }
  while (__stxr(v17 + 1, exceptionSequenceNum));
  v19 = setThreadIdAndInfo(-1, (__int128 *)sSDBExceptionCallbacks, v14, 0x40000000, v18);
  v371 = HIDWORD(v19);
  v372 = v19;
  v370 = v20;
  v369 = v21;
  v22 = *(_QWORD *)&threadData[18 * v19 + 2];
  v23 = v22 + 320 * HIDWORD(v19);
  *(_BYTE *)(v23 + 216) = 0;
  v358 = *(_DWORD *)(v23 + 312);
  v24 = *(void (**)(_QWORD))(v23 + 224);
  if (v24)
    v24(*(_QWORD *)(v22 + 320 * HIDWORD(v19) + 288));
  v368 = v372;
  v367 = v371;
  v366 = v370;
  v365 = v369;
  Value = _setjmp((int *)v23);
  if ((_DWORD)Value)
  {
    v26 = *__error();
    v27 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      LODWORD(v376[0]) = 136315394;
      *(void **)((char *)v376 + 4) = "_fillPlistBytes";
      WORD2(v376[1]) = 1024;
      *(_DWORD *)((char *)&v376[1] + 6) = 1219;
      _os_log_error_impl(&dword_1B8270000, v27, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", (uint8_t *)v376, 0x12u);
    }
    *__error() = v26;
    *(_DWORD *)(v23 + 312) = v358;
    CIOnThreadCleanUpReset(v365);
    dropThreadId(v368, 1, v18);
    return CICleanUpReset(v368, v366);
  }
  v357 = a6;
  v351 = a1;
  v359 = v18;
  if (v350)
  {
    Value = *(_QWORD *)(v350 + 168);
    v364 = 0;
    if (Value)
    {
      Value = (CFTypeID)CFDictionaryGetValue((CFDictionaryRef)Value, CFSTR("_showAllExtensions"));
      if (Value)
      {
        v29 = (const __CFNumber *)Value;
        v30 = CFGetTypeID((CFTypeRef)Value);
        Value = CFNumberGetTypeID();
        if (v30 == Value)
          Value = CFNumberGetValue(v29, kCFNumberIntType, &v364);
      }
    }
  }
  else
  {
    v364 = 0;
  }
  v348 = &v310;
  MEMORY[0x1E0C80A78](Value);
  v31 = (8 * v16 + 15) & 0xFFFFFFFFFFFFFFF0;
  v312 = 8 * v16;
  bzero((char *)&v310 - v31, 8 * v16);
  MEMORY[0x1E0C80A78](v32);
  bzero((char *)&v310 - v31, 8 * v16);
  MEMORY[0x1E0C80A78](v33);
  v34 = (4 * v16 + 15) & 0xFFFFFFFFFFFFFFF0;
  bzero((char *)&v310 - v34, 4 * v16);
  MEMORY[0x1E0C80A78](v35);
  v330 = (char *)&v310 - v34;
  bzero((char *)&v310 - v34, 4 * v16);
  v37 = 0;
  v379[0] = *(_DWORD *)(v351 + 2020);
  v379[1] = 0;
  if (v14)
    v37 = v379;
  v347 = (char *)&v310 - v31;
  *(_QWORD *)((char *)&v310 - v31) = v37;
  *(_QWORD *)((char *)&v310 - v31) = "kMDItemLangugeStrId";
  if (v350)
    v38 = *(_DWORD *)(v350 + 176);
  else
    v38 = 0;
  v39 = v347;
  v346 = (char *)&v310 - v31;
  v333 = (char *)&v310 - v34;
  MEMORY[0x1E0C80A78](v36);
  v345 = (char *)&v310 - v31;
  bzero((char *)&v310 - v31, v312);
  *(_QWORD *)((char *)&v310 - v31) = 0;
  v40 = v356;
  if (v356 < 1)
  {
    v52 = 0;
    v60 = 1;
    v59 = 0;
  }
  else
  {
    v41 = 0;
    v42 = 1;
    v43 = 1;
    do
    {
      v44 = v43;
      v45 = *(const char **)(v321 + 8 * v42 - 8);
      v46 = strcmp(v45, "kMDItemDisplayName");
      if (v364)
        v47 = v46 == 0;
      else
        v47 = 0;
      if (v47)
        v48 = "_kMDItemDisplayNameWithExtensionsSynth";
      else
        v48 = (char *)v45;
      v49 = v48;
      *(_QWORD *)&v346[8 * v42] = v48;
      if ((isEntitledForAttribute(v38, v48) & 1) == 0)
      {
        *(_QWORD *)&v346[8 * v42] = "__DENIED__";
        v49 = "__DENIED__";
      }
      if (v15)
        v50 = db_copy_field_ids_with_buffer(v15, v49, 0, 0);
      else
        v50 = 0;
      *(_QWORD *)&v39[8 * v42] = v50;
      v51 = (const char *)strlen(v49);
      v52 = CannedFieldTable::in_word_set((CannedFieldTable *)v49, v51);
      v53 = v52;
      *(_QWORD *)&v345[8 * v42] = v52;
      *(_DWORD *)&v333[4 * v42] = 0;
      if (v44 && v52 != 0)
      {
        v52 = (const char **)strcmp(v49, "_kMDItemSDBInfo");
        v44 = (_DWORD)v52 != 0;
      }
      v43 = v44;
      if (v15)
      {
        v40 = v356;
        if (v53)
        {
          v54 = v53[4];
          if (v54)
          {
            v52 = (const char **)((uint64_t (*)(uint64_t))v54)(v351);
            if (v52)
            {
              if (*v52)
              {
                v55 = v52 + 1;
                v52 = (const char **)v41;
                v56 = 0;
                do
                  v57 = v56 + 1;
                while (v55[v56++]);
                v41 += v57;
                *(_DWORD *)&v333[4 * v42] = v57;
              }
            }
          }
        }
      }
      else
      {
        v40 = v356;
      }
      v59 = v41;
      ++v42;
      v60 = v43;
    }
    while (v42 <= v40);
  }
  v336 = v60;
  v344 = v59;
  MEMORY[0x1E0C80A78](v52);
  v62 = (void **)((char *)&v310 - v61);
  bzero((char *)&v310 - v61, v63);
  if ((v40 & 0x8000000000000000) == 0)
  {
    v64 = 0;
    v65 = 0;
    v66 = 0;
    v67 = 0;
    v68 = v351;
    while (1)
    {
      v69 = *(_DWORD **)&v39[8 * v66];
      if (v69 && *v69)
      {
        v70 = v69 + 1;
        do
        {
          v71 = *v70++;
          v72 = (v67 + 1);
          LODWORD(v67) = v67 + 1;
        }
        while (v71);
        if (v15)
        {
LABEL_56:
          v73 = *(_QWORD *)&v345[8 * v66];
          if (v73)
          {
            v74 = *(uint64_t (**)(uint64_t, uint64_t))(v73 + 32);
            if (v74)
            {
              v75 = (char **)v74(v68, v64);
              if (v75)
              {
                if (*v75)
                {
                  v76 = v75;
                  v77 = *v75;
                  v78 = v65;
                  v79 = 0;
                  v80 = v72;
                  do
                  {
                    v81 = v78;
                    v82 = (int *)db_copy_field_ids_with_buffer(v15, v77, 0, 0);
                    v62[v81] = v82;
                    if (v82 && *v82)
                    {
                      v83 = v82 + 1;
                      do
                      {
                        v84 = *v83++;
                        v85 = (v80 + 1);
                        LODWORD(v80) = v80 + 1;
                      }
                      while (v84);
                    }
                    else
                    {
                      v85 = v80;
                    }
                    v86 = v76[++v79];
                    v77 = v86;
                    v78 = v81 + 1;
                    v80 = v85;
                  }
                  while (v86);
                  v65 = v81 + 1;
                  v72 = v85;
                }
              }
            }
          }
        }
      }
      else
      {
        v72 = v67;
        if (v15)
          goto LABEL_56;
      }
      v64 = v72;
      ++v66;
      v67 = v72;
      if (v66 > v356)
        goto LABEL_72;
    }
  }
  LODWORD(v64) = 0;
LABEL_72:
  v87 = v64;
  if (v342)
  {
    v88 = (int *)db_copy_field_ids_with_buffer(v15, "kMDItemBundleID", 0, 0);
    v89 = v330;
    if (v88 && *v88)
    {
      v90 = v88 + 1;
      v91 = v87;
      do
      {
        ++v91;
        v92 = *v90++;
        v87 = v91;
      }
      while (v92);
    }
    free(v88);
    v93 = (int *)db_copy_field_ids_with_buffer(v15, "_kMDItemExternalID", 0, 0);
    if (v93 && *v93)
    {
      v94 = v93 + 1;
      v95 = v87;
      do
      {
        ++v95;
        v96 = *v94++;
        v87 = v95;
      }
      while (v96);
    }
    free(v93);
  }
  else
  {
    v89 = v330;
  }
  v97 = (size_t *)MEMORY[0x1E0C85AD8];
  if ((((unint64_t)v87 >> 14) & 0x7FFFFFFFFFFFLL) == 0 && (unint64_t)(8 * v87) > *MEMORY[0x1E0C85AD8])
    ++sTotal_7039;
  v98 = (char *)malloc_type_zone_calloc((malloc_zone_t *)queryZone, v87, 8uLL, 0x31F9A007uLL);
  v99 = v98;
  if (!v98)
    _log_fault_for_malloc_failure();
  v339 = v89;
  v340 = v87;
  MEMORY[0x1E0C80A78](v98);
  v101 = (char *)&v310 - v100;
  v102 = (char *)&v310 - v100;
  bzero((char *)&v310 - v100, v103);
  if (v356 < 0)
  {
    v329 = v99;
    v332 = v101;
    v160 = v334;
    v161 = 0;
    LODWORD(v99) = 0;
    v162 = 0;
    v107 = v340;
    goto LABEL_131;
  }
  v104 = 0;
  v105 = 0;
  v106 = 0;
  v108 = v339;
  v107 = v340;
  do
  {
    v109 = *(int **)&v39[8 * v104];
    if (v109 && *v109)
    {
      v110 = *v109;
      v111 = (int)v106;
      v112 = (int)v105;
      if ((int)v106 <= (int)v107)
        v113 = v107;
      else
        v113 = (int)v106;
      v114 = (v113 - (_DWORD)v106);
      if ((int)v105 <= (int)v107)
        v115 = v107;
      else
        v115 = v105;
      v116 = (v115 - v105);
      v117 = &v99[8 * (int)v105 + 4];
      v118 = v109 + 1;
      v119 = v116;
      while (v114)
      {
        *(_DWORD *)&v102[4 * v111] = v110;
        if (!v119)
        {
          v223 = __si_assert_copy_extra_268();
          v231 = v223;
          v303 = "";
          if (v223)
            v303 = v223;
          v309 = v303;
          goto LABEL_306;
        }
        v120 = (void *)(v111 + 1);
        *((_DWORD *)v117 - 1) = *(v118 - 1);
        *(_DWORD *)v117 = v104;
        v121 = v112 + 1;
        v122 = *v118++;
        v110 = v122;
        --v114;
        v117 += 8;
        --v119;
        ++v112;
        ++v111;
        if (!v122)
        {
          v123 = v120;
          v124 = v121;
          v125 = v123;
          goto LABEL_104;
        }
      }
      v292 = __si_assert_copy_extra_268();
      v300 = v292;
      v301 = "";
      if (v292)
        v301 = v292;
      v309 = v301;
LABEL_301:
      __message_assert_272((uint64_t)v292, v293, v294, v295, v296, v297, v298, v299, (char)"SIFetching.c");
      free(v300);
      if (__valid_fs(-1))
        v302 = 2989;
      else
        v302 = 3072;
      *(_DWORD *)v302 = -559038737;
      abort();
    }
    v124 = v105;
    v125 = v106;
LABEL_104:
    ++v104;
    v106 = v125;
    v105 = v124;
  }
  while (v104 <= v356);
  v332 = v101;
  v126 = 0;
  v127 = v334;
  v329 = v99;
  v128 = v99 + 4;
  v129 = 0;
  v130 = (char *)v125;
  v131 = v124;
  do
  {
    v99 = v130;
    *(_DWORD *)&v108[4 * v129] = 0;
    v132 = *(_QWORD *)&v345[8 * v129];
    if (v132)
    {
      if (*(_QWORD *)(v132 + 32))
      {
        v133 = *(_DWORD *)&v333[4 * v129];
        *(_DWORD *)&v108[4 * v129] = v127;
        if (v133 >= 1)
        {
          v134 = v126;
          v135 = 0;
          v136 = v127;
          v137 = v130;
          v138 = v131;
          while (1)
          {
            v139 = v135;
            v140 = (int *)v62[v134];
            if (!v140)
            {
              v158 = v138;
              v159 = v137;
              v157 = v136;
              goto LABEL_125;
            }
            if (!*v140)
              goto LABEL_123;
            v141 = *v140;
            v142 = (int)v137;
            v143 = (int)v138;
            if ((int)v137 <= (int)v107)
              v144 = v107;
            else
              v144 = (int)v137;
            v145 = (v144 - (_DWORD)v137);
            if ((int)v138 <= (int)v107)
              v146 = v107;
            else
              v146 = v138;
            v147 = (v146 - v138);
            v148 = &v128[8 * (int)v138];
            v149 = v140 + 1;
            v150 = v148;
            v151 = v145;
            v152 = v143;
            v153 = v142;
            do
            {
              if (!v151)
              {
                v223 = __si_assert_copy_extra_268();
                v231 = v223;
                v232 = "";
                if (v223)
                  v232 = v223;
                v309 = v232;
                goto LABEL_306;
              }
              *(_DWORD *)&v102[4 * v153] = v141;
              if (!v147)
              {
                v223 = __si_assert_copy_extra_268();
                v231 = v223;
                v233 = "";
                if (v223)
                  v233 = v223;
                v309 = v233;
                goto LABEL_306;
              }
              v154 = (char *)(v153 + 1);
              *((_DWORD *)v150 - 1) = *(v149 - 1);
              *(_DWORD *)v150 = v136;
              v155 = v152 + 1;
              v156 = *v149++;
              v141 = v156;
              --v151;
              v150 += 8;
              --v147;
              ++v152;
              ++v153;
            }
            while (v156);
            v138 = v155;
            v137 = v154;
LABEL_123:
            v157 = (v136 + 1);
            v158 = v138;
            v159 = v137;
LABEL_125:
            v126 = v134 + 1;
            v135 = v139 + 1;
            ++v134;
            v136 = v157;
            v137 = v159;
            v138 = v158;
            if (v139 + 1 == v133)
            {
              v99 = v159;
              v127 = v157;
              goto LABEL_128;
            }
          }
        }
      }
    }
    v158 = v131;
LABEL_128:
    v160 = v127;
    v161 = v158;
    v162 = v126;
    ++v129;
    v131 = v158;
    v130 = v99;
  }
  while (v129 <= v356);
LABEL_131:
  if (v342)
  {
    v163 = (int *)db_copy_field_ids_with_buffer(v15, "kMDItemBundleID", 0, 0);
    if (v163 && *v163)
    {
      v164 = *v163;
      v165 = (int)v99;
      v166 = v161;
      if ((int)v340 <= v161)
        v167 = v161;
      else
        v167 = v340;
      v168 = (v167 - v161);
      v169 = &v329[8 * v161 + 4];
      v170 = v163 + 1;
      while (1)
      {
        *(_DWORD *)&v102[4 * v165] = v164;
        if (!v168)
          break;
        v171 = v165 + 1;
        *((_DWORD *)v169 - 1) = *(v170 - 1);
        *(_DWORD *)v169 = v160;
        v172 = v166 + 1;
        v173 = *v170++;
        v164 = v173;
        --v168;
        v169 += 8;
        ++v166;
        ++v165;
        if (!v173)
        {
          v161 = v172;
          LODWORD(v99) = v171;
          goto LABEL_141;
        }
      }
      v223 = __si_assert_copy_extra_268();
      v231 = v223;
      v305 = "";
      if (v223)
        v305 = v223;
      v309 = v305;
LABEL_306:
      __message_assert_272((uint64_t)v223, v224, v225, v226, v227, v228, v229, v230, (char)"SIFetching.c");
      free(v231);
      if (__valid_fs(-1))
        v304 = 2989;
      else
        v304 = 3072;
      *(_DWORD *)v304 = -559038737;
      abort();
    }
LABEL_141:
    free(v163);
    v174 = (int *)db_copy_field_ids_with_buffer(v15, "_kMDItemExternalID", 0, 0);
    if (v174 && *v174)
    {
      v175 = *v174;
      v176 = (int)v99;
      if (v161 <= (int)v340)
        v177 = v340;
      else
        v177 = v161;
      v178 = (v177 - v161);
      v179 = &v329[8 * v161 + 4];
      v180 = v174 + 1;
      while (1)
      {
        *(_DWORD *)&v102[4 * v176] = v175;
        if (!v178)
          break;
        v181 = v176 + 1;
        *((_DWORD *)v179 - 1) = *(v180 - 1);
        *(_DWORD *)v179 = v160;
        v182 = *v180++;
        v175 = v182;
        --v178;
        v179 += 8;
        ++v176;
        if (!v182)
        {
          LODWORD(v99) = v181;
          goto LABEL_150;
        }
      }
      v292 = __si_assert_copy_extra_268();
      v300 = v292;
      v306 = "";
      if (v292)
        v306 = v292;
      v309 = v306;
      goto LABEL_301;
    }
LABEL_150:
    free(v174);
    v183 = v344;
    v107 = v340;
  }
  else
  {
    v183 = v344;
  }
  *(_DWORD *)&v102[4 * (int)v99] = 0;
  if (v183 != v162)
  {
    v292 = __si_assert_copy_extra_268();
    v300 = v292;
    v307 = "";
    if (v292)
      v307 = v292;
    v309 = v307;
    goto LABEL_301;
  }
  v338 = v329;
  v184 = v107;
  qsort_b(v329, v107, 8uLL, &__block_literal_global_46);
  qsort_b(v102, v184, 4uLL, &__block_literal_global_48);
  v185 = v357;
  v186 = 8 * v357;
  v187 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 8 * v357, 0x6085D6BuLL);
  v188 = v343;
  if (!v187)
    _log_fault_for_malloc_failure();
  if (v185 < 2)
  {
    LODWORD(v194) = 0;
  }
  else
  {
    v189 = v185 - 1;
    v190 = (_QWORD *)(v353 + 8);
    v191 = (unsigned __int8 *)(v354 + 1);
    v192 = 0;
    do
    {
      if (*v191++)
      {
        v194 = v192;
      }
      else
      {
        v194 = (v192 + 1);
        v187[(int)v192] = *v190;
      }
      ++v190;
      v192 = v194;
      --v189;
    }
    while (v189);
  }
  v337 = v187;
  if (!(v186 >> 17) && v186 > *v97)
    ++sTotal_7039;
  v195 = (void **)malloc_type_zone_calloc((malloc_zone_t *)queryZone, 8uLL, v357, 0x31F9A007uLL);
  if (!v195)
    _log_fault_for_malloc_failure();
  memset(v378, 0, sizeof(v378));
  memset(v377, 0, sizeof(v377));
  if (v342)
  {
    v196 = (int *)db_copy_field_ids_with_buffer(v15, "_kMDItemExternalID", (uint64_t)v378, 8uLL);
    v197 = (int *)db_copy_field_ids_with_buffer(v15, "_kMDItemBundleID", (uint64_t)v377, 8uLL);
    memset(v376, 0, 32);
    LOBYTE(v363) = 0;
    v198 = fasterUTF8String(v188, v373, (char *)v376, 32, &v363);
    id_for_string = db_get_id_for_string(v15, v198);
    if ((_BYTE)v363)
      free(v198);
    v200 = v197;
  }
  else
  {
    id_for_string = 0;
    v196 = 0;
    v200 = 0;
  }
  v318 = id_for_string;
  v335 = v195;
  v201 = v356;
  v202 = v354;
  if (v15)
  {
    v319 = v200;
    v203 = (unint64_t)v332;
    if ((v336 & 1) == 0)
      v203 = 0;
    v204 = db_obj_iter_create_with_filter(v15, (int)v194, (uint64_t)v337, 0, 0, 0, 0, 0, v203);
    if (!v204)
    {
      v223 = __si_assert_copy_extra_268();
      v231 = v223;
      v308 = "";
      if (v223)
        v308 = v223;
      v309 = v308;
      goto LABEL_306;
    }
    v320 = v196;
    v208 = (uint64_t)v204;
    if ((int)v194 < 1)
    {
      v220 = 0;
      v219 = 0;
    }
    else
    {
      v209 = 0;
      v316 = 289594011;
      v314 = 32;
      v313 = 4;
      v210 = 0;
      v211 = 0;
      do
      {
        *(_QWORD *)v373 = 0;
        v212 = db_obj_iter_next(v208, (unint64_t *)v373, 1, v205, v206, v207);
        if (v212)
        {
          v213 = v212;
          if (!v342)
            goto LABEL_198;
          v362 = 0;
          v363 = 0;
          if (db_get_field_by_id(v15, (uint64_t)v212, v319, &v363, &v362)
            || *(_DWORD *)(v363 + 13) != v318
            || db_get_field_by_id(v15, (uint64_t)v213, v320, &v363, &v362))
          {
            goto LABEL_187;
          }
          ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v342, *(CFIndex *)v373);
          memset(v376, 0, 32);
          v361 = 0;
          v215 = fasterUTF8String(ValueAtIndex, &v360, (char *)v376, v314, &v361);
          v216 = strcmp((const char *)(v363 + 13), v215);
          if (v361)
          {
            v310 = v216;
            free(v215);
            v216 = v310;
          }
          v202 = v354;
          if (v216)
          {
LABEL_187:
            if (v209 >= v210)
            {
              if (v210)
                v210 *= 2;
              else
                v210 = v313;
              v211 = malloc_type_realloc(v211, 8 * v210, 0x100004000313F17uLL);
            }
            *((_QWORD *)v211 + v209++) = *(_QWORD *)v373;
          }
          else
          {
LABEL_198:
            if (((v341 & 4) == 0 || (isContact(v15, (uint64_t)v213, *(_DWORD *)(v351 + 2008)) & 1) == 0)
              && ((v341 & 2) == 0 || !isReminder(v15, (uint64_t)v213, *(_DWORD *)(v351 + 2008)))
              && ((v341 & 1) == 0 || !isCalendar(v15, (uint64_t)v213, *(_DWORD *)(v351 + 2008))))
            {
              v217 = malloc_type_malloc(v213[3], v316);
              v218 = v217;
              if (v217)
              {
                memcpy(v217, v213, v213[3]);
                v218[2] = v213[3];
              }
              v335[*(_QWORD *)v373] = v218;
              v202 = v354;
            }
          }
        }
        v219 = v209;
        v220 = (CFIndex *)v211;
        LODWORD(v194) = v194 - 1;
      }
      while ((_DWORD)v194);
    }
    v222 = v219;
    v234 = v220;
    db_obj_iter_release(v208);
    v221 = v234;
    v201 = v356;
    v188 = v343;
    v200 = v319;
    v196 = v320;
  }
  else
  {
    v221 = 0;
    v222 = 0;
  }
  v331 = v221;
  if (v377 != (_BYTE *)v200)
    free(v200);
  if (v378 != (_BYTE *)v196)
    free(v196);
  if (v222)
  {
    v235 = v331;
    do
    {
      v237 = v235 + 1;
      v236 = *v235;
      v238 = (const __CFString *)CFArrayGetValueAtIndex(v342, *v235);
      v376[0] = 0;
      if (!si_get_object_for_identifier_createParentDBO(v351, v188, v238, 0, 0, 0, v376, 0))
      {
        if ((v341 & 4) != 0 && (isContact(v15, (uint64_t)v376[0], *(_DWORD *)(v351 + 2008)) & 1) != 0
          || (v341 & 2) != 0 && isReminder(v15, (uint64_t)v376[0], *(_DWORD *)(v351 + 2008))
          || (v341 & 1) != 0 && isCalendar(v15, (uint64_t)v376[0], *(_DWORD *)(v351 + 2008)))
        {
          free(v376[0]);
        }
        else
        {
          v335[v236] = v376[0];
        }
      }
      v235 = v237;
      --v222;
    }
    while (v222);
  }
  v239 = v352;
  _MDPlistBytesAddNull();
  if (v15)
    db_string_table_rdlock(v15);
  v242 = v357;
  if (v357 >= 2)
  {
    v327 = 8 * (v201 + v344 + 3);
    v328 = v327;
    v243 = 1;
    v326 = 1024;
    *(_QWORD *)&v240 = 136315394;
    *(_QWORD *)&v241 = 136315394;
    v323 = v240;
    v324 = v241;
    v244 = 0;
    v325 = v62;
    do
    {
      if (*(_BYTE *)(v202 + v243))
      {
        _MDPlistBytesAddNull();
      }
      else
      {
        v245 = (uint64_t)v335[v244];
        v322 = v244 + 1;
        if (v245)
        {
          v246 = _MDPlistBytesBeginArray();
          v315 = &v310;
          MEMORY[0x1E0C80A78](v246);
          v248 = (char *)&v310 - ((v247 + 15) & 0xFFFFFFFFFFFFFFF0);
          bzero(v248, v327);
          v317 = v245;
          db_get_offsets_for_fields((char *)v15, v245, v338, v340, (uint64_t)v248);
          if (v201 >= 1)
          {
            for (i = 1; i <= v201; ++i)
            {
              v250 = *(_QWORD *)&v248[8 * i];
              if (v250)
              {
                MDPlistBytesAddSDBFieldLocalized(v239, v15, *(unsigned int **)&v248[8 * i], (const char *)(v250 + 13), v355, 0, 1);
              }
              else
              {
                v251 = *(_QWORD *)&v345[8 * i];
                v252 = *(const char **)&v346[8 * i];
                if (!strcmp("kMDItemPath", v252))
                {
                  bzero(v376, 0x400uLL);
                  v254 = *(_QWORD *)(v351 + 1416);
                  v255 = *(uint64_t (**)(void))(v254 + 192);
                  if (!v255)
                    v255 = *(uint64_t (**)(void))(v254 + 40);
                  v256 = v255();
                  if (v256)
                  {
                    v257 = v256;
                    v239 = v352;
                    v62 = v325;
                    if (dword_1EF19FCA0 >= 5)
                    {
                      v311 = *__error();
                      v260 = _SILogForLogForCategory(5);
                      if (os_log_type_enabled(v260, OS_LOG_TYPE_DEFAULT))
                      {
                        v261 = *(_QWORD *)(v353 + 8 * v243);
                        *(_DWORD *)v373 = v324;
                        *(_QWORD *)&v373[4] = v257;
                        v374 = 2048;
                        v375 = v261;
                        _os_log_impl(&dword_1B8270000, v260, OS_LOG_TYPE_DEFAULT, "found %s for %llx\n", v373, 0x16u);
                      }
                      *__error() = v311;
                    }
                    _MDPlistBytesAddCString();
                  }
                  else
                  {
                    v258 = v352;
                    _MDPlistBytesAddNull();
                    v239 = v258;
                    v259 = (*(uint64_t (**)(void))(*(_QWORD *)(v351 + 1416) + 40))();
                    v62 = v325;
                    if (!v259)
                      _SIDeleteAttributes(v351, *(_QWORD *)(v353 + 8 * v243));
                  }
                }
                else if (!strcmp("kMDItemAttributeChangeDate", v252))
                {
                  v239 = v352;
                  _MDPlistBytesAddDate();
                }
                else if (v251)
                {
                  v253 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, void *, uint64_t))(v251 + 8);
                  v239 = v352;
                  runCannedHelper(v253, v351, v350, *(_QWORD *)(v353 + 8 * v243), v317, (uint64_t)v252, *(unsigned int *)&v339[4 * i], (uint64_t)v248, v352);
                }
                else
                {
                  v239 = v352;
                  _MDPlistBytesAddNull();
                }
                v201 = v356;
              }
            }
          }
          v242 = v357;
        }
        else
        {
          v262 = *(_DWORD *)(v351 + 48) != -1 || (v349 & 8) == 0;
          v242 = v357;
          if (!v262)
          {
            _MDPlistBytesAddNull();
            v244 = v322;
            goto LABEL_261;
          }
          _MDPlistBytesBeginArray();
          if (v201 >= 1)
          {
            for (j = 1; j <= v201; ++j)
            {
              v264 = *(_QWORD *)&v345[8 * j];
              v265 = *(const char **)&v346[8 * j];
              if (!strcmp("kMDItemPath", v265))
              {
                v267 = v242;
                bzero(v376, v326);
                v268 = v351;
                v269 = (*(uint64_t (**)(void))(*(_QWORD *)(v351 + 1416) + 40))();
                if (v269)
                {
                  v270 = v269;
                  v239 = v352;
                  v242 = v267;
                  v62 = v325;
                  if (dword_1EF19FCA0 >= 5)
                  {
                    v272 = *__error();
                    v273 = _SILogForLogForCategory(5);
                    if (os_log_type_enabled(v273, OS_LOG_TYPE_DEFAULT))
                    {
                      v274 = *(_QWORD *)(v353 + 8 * v243);
                      *(_DWORD *)v373 = v323;
                      *(_QWORD *)&v373[4] = v270;
                      v374 = 2048;
                      v375 = v274;
                      _os_log_impl(&dword_1B8270000, v273, OS_LOG_TYPE_DEFAULT, "found %s for %llx\n", v373, 0x16u);
                    }
                    *__error() = v272;
                    v201 = v356;
                    v242 = v357;
                  }
                  _MDPlistBytesAddCString();
                }
                else
                {
                  v239 = v352;
                  _MDPlistBytesAddNull();
                  v271 = (*(uint64_t (**)(void))(*(_QWORD *)(v268 + 1416) + 40))();
                  v242 = v267;
                  v62 = v325;
                  if (!v271)
                    _SIDeleteAttributes(v351, *(_QWORD *)(v353 + 8 * v243));
                }
              }
              else if (v264)
              {
                v266 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, void *, uint64_t))(v264 + 8);
                v239 = v352;
                runCannedHelper(v266, v351, v350, *(_QWORD *)(v353 + 8 * v243), 0, (uint64_t)v265, 0, 0, v352);
              }
              else
              {
                v239 = v352;
                _MDPlistBytesAddNull();
              }
            }
          }
        }
        _MDPlistBytesEndArray();
        v244 = v322;
        v202 = v354;
      }
LABEL_261:
      ++v243;
    }
    while (v243 != v242);
  }
  if (v15)
    db_string_table_unlock(v15);
  free(v331);
  free(v338);
  free(v337);
  v275 = v344;
  if (v201 >= 1)
  {
    v276 = (void **)(v347 + 8);
    v277 = v201;
    do
    {
      v278 = v277;
      v279 = v276 + 1;
      free(*v276);
      v276 = v279;
      v277 = v278 - 1;
    }
    while (v278 != 1);
  }
  if (v275 >= 1)
  {
    v280 = v275;
    do
    {
      v281 = v280;
      v282 = *v62++;
      free(v282);
      v280 = v281 - 1;
    }
    while (v281 != 1);
  }
  if (v242 >= 1)
  {
    v283 = v335;
    v284 = v242;
    do
    {
      v285 = v284;
      v286 = v283 + 1;
      free(*v283);
      v283 = v286;
      v284 = v285 - 1;
    }
    while (v285 != 1);
  }
  free(v335);
  v287 = *(_QWORD *)&threadData[18 * v368 + 2];
  v288 = v367;
  v289 = v287 + 320 * v367;
  *(_DWORD *)(v289 + 312) = v358;
  v290 = *(void (**)(_QWORD))(v289 + 232);
  v291 = v359;
  if (v290)
    v290(*(_QWORD *)(v287 + 320 * v288 + 288));
  return dropThreadId(v368, 0, v291);
}

uint64_t isContact(int *a1, uint64_t a2, int a3)
{
  int field_by_id;
  uint64_t result;
  int v7;
  int v8;
  unsigned __int8 *v9;
  _WORD *v10;
  int v11[2];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v9 = 0;
  v10 = 0;
  v11[0] = a3;
  v11[1] = 0;
  field_by_id = db_get_field_by_id(a1, a2, v11, (unint64_t *)&v10, (unint64_t *)&v9);
  result = 0;
  if (!field_by_id)
  {
    switch(*v10)
    {
      case 1:
      case 2:
        v7 = *v9;
        goto LABEL_6;
      case 3:
      case 4:
        v7 = *(unsigned __int16 *)v9;
        goto LABEL_6;
      case 5:
      case 6:
      case 7:
      case 8:
        v7 = *(_DWORD *)v9;
LABEL_6:
        if (v7 != 2)
          goto LABEL_8;
        v11[0] = db_get_id_for_field_locked(a1, "_kMDItemFinderExcluded");
        if (db_get_field_by_id(a1, a2, v11, (unint64_t *)&v10, (unint64_t *)&v9))
          goto LABEL_8;
        switch(*v10)
        {
          case 1:
          case 2:
            v8 = *v9;
            break;
          case 3:
          case 4:
            v8 = *(unsigned __int16 *)v9;
            break;
          case 5:
          case 6:
          case 7:
          case 8:
            v8 = *(_DWORD *)v9;
            break;
          default:
            goto LABEL_8;
        }
        if (!v8)
          goto LABEL_8;
        result = 1;
        break;
      default:
LABEL_8:
        result = 0;
        break;
    }
  }
  return result;
}

BOOL isReminder(int *a1, uint64_t a2, int a3)
{
  int field_by_id;
  _BOOL8 result;
  int v7;
  int v8;
  const char *string_for_id_locked;
  int *v10;
  _WORD *v11;
  int v12[2];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v10 = 0;
  v11 = 0;
  v12[0] = a3;
  v12[1] = 0;
  field_by_id = db_get_field_by_id(a1, a2, v12, (unint64_t *)&v11, (unint64_t *)&v10);
  result = 0;
  if (!field_by_id)
  {
    switch(*v11)
    {
      case 1:
      case 2:
        v7 = *(unsigned __int8 *)v10;
        goto LABEL_6;
      case 3:
      case 4:
        v7 = *(unsigned __int16 *)v10;
        goto LABEL_6;
      case 5:
      case 6:
      case 7:
      case 8:
        v7 = *v10;
LABEL_6:
        if (v7 != 6)
          goto LABEL_8;
        v12[0] = db_get_id_for_field_locked(a1, "_kMDItemFinderExcluded");
        if (db_get_field_by_id(a1, a2, v12, (unint64_t *)&v11, (unint64_t *)&v10))
          goto LABEL_8;
        switch(*v11)
        {
          case 1:
          case 2:
            v8 = *(unsigned __int8 *)v10;
            break;
          case 3:
          case 4:
            v8 = *(unsigned __int16 *)v10;
            break;
          case 5:
          case 6:
          case 7:
          case 8:
            v8 = *v10;
            break;
          default:
            goto LABEL_8;
        }
        if (!v8)
          goto LABEL_8;
        v12[0] = db_get_id_for_field_locked(a1, "kMDItemContentType");
        if (db_get_field_by_id(a1, a2, v12, (unint64_t *)&v11, (unint64_t *)&v10)
          || *v11 != 11)
        {
          goto LABEL_8;
        }
        string_for_id_locked = (const char *)v10;
        if ((v11[1] & 0x10) != 0)
          string_for_id_locked = (const char *)db_get_string_for_id_locked(a1, *v10);
        result = strcmp("com.apple.ical.ics.todo", string_for_id_locked) == 0;
        break;
      default:
LABEL_8:
        result = 0;
        break;
    }
  }
  return result;
}

BOOL isCalendar(int *a1, uint64_t a2, int a3)
{
  int field_by_id;
  _BOOL8 result;
  int v7;
  int v8;
  const char *string_for_id_locked;
  int *v10;
  _WORD *v11;
  int v12[2];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v10 = 0;
  v11 = 0;
  v12[0] = a3;
  v12[1] = 0;
  field_by_id = db_get_field_by_id(a1, a2, v12, (unint64_t *)&v11, (unint64_t *)&v10);
  result = 0;
  if (!field_by_id)
  {
    switch(*v11)
    {
      case 1:
      case 2:
        v7 = *(unsigned __int8 *)v10;
        goto LABEL_6;
      case 3:
      case 4:
        v7 = *(unsigned __int16 *)v10;
        goto LABEL_6;
      case 5:
      case 6:
      case 7:
      case 8:
        v7 = *v10;
LABEL_6:
        if (v7 != 6)
          goto LABEL_8;
        v12[0] = db_get_id_for_field_locked(a1, "_kMDItemFinderExcluded");
        if (db_get_field_by_id(a1, a2, v12, (unint64_t *)&v11, (unint64_t *)&v10))
          goto LABEL_8;
        switch(*v11)
        {
          case 1:
          case 2:
            v8 = *(unsigned __int8 *)v10;
            goto LABEL_14;
          case 3:
          case 4:
            v8 = *(unsigned __int16 *)v10;
            goto LABEL_14;
          case 5:
          case 6:
          case 7:
          case 8:
            v8 = *v10;
LABEL_14:
            if (!v8)
              goto LABEL_20;
            v12[0] = db_get_id_for_field_locked(a1, "kMDItemContentType");
            if (db_get_field_by_id(a1, a2, v12, (unint64_t *)&v11, (unint64_t *)&v10)
              || *v11 != 11)
            {
              goto LABEL_20;
            }
            string_for_id_locked = (const char *)v10;
            if ((v11[1] & 0x10) != 0)
              string_for_id_locked = (const char *)db_get_string_for_id_locked(a1, *v10);
            result = strcmp("com.apple.ical.ics.todo", string_for_id_locked) != 0;
            break;
          default:
LABEL_20:
            result = 1;
            break;
        }
        break;
      default:
LABEL_8:
        result = 0;
        break;
    }
  }
  return result;
}

unint64_t ___fillPlistBytes_block_invoke_2(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  return (__PAIR64__(*a2 > *a3, *a2) - *a3) >> 32;
}

uint64_t ___fillPlistBytes_block_invoke(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  return (*a2 > *a3) - (*a3 > *a2);
}

void si_getAttrNamesBulk(uint64_t *a1, int a2)
{
  char *v3;
  const __CFAllocator *v4;
  uint64_t Mutable;
  size_t v6;
  unsigned __int8 *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char v11;
  int *v12;
  __CFSet *v13;
  void *v14;
  unint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  unsigned __int8 *v18;
  unint64_t *v20;
  double v21;
  double v22;
  __n128 v23;
  uint64_t i;
  unsigned int *v25;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  _OWORD *v29;
  uint64_t v30;
  unsigned int *v31;
  unsigned int v32;
  const void *v33;
  void *v34;
  char *v35;
  void **v36;
  unint64_t v37;
  uint64_t v38;
  const void *v39;
  int v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  v3 = (char *)a1[3];
  if (a2)
  {
    SIResultQueueRelease((char *)a1[3]);
  }
  else
  {
    v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    Mutable = _MDPlistBytesCreateMutable();
    v36 = &v34;
    MEMORY[0x1E0C80A78](Mutable);
    v7 = (unsigned __int8 *)&v34 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v7, v6);
    bzero(v7, a1[2]);
    _MDPlistBytesBeginPlist();
    _MDPlistBytesBeginArray();
    v9 = *a1;
    v8 = a1[1];
    v10 = a1[2];
    v11 = *((_BYTE *)a1 + 48);
    v12 = *(int **)(*a1 + 1184);
    v13 = CFSetCreateMutable(v4, 0, 0);
    if (v12)
    {
      v14 = malloc_type_malloc(8 * v10, 0x100004000313F17uLL);
      if (v10 < 2)
      {
        v27 = v14;
        v20 = db_obj_iter_create_with_filter(v12, 0, (uint64_t)v14, 0, 0, 0, 0, 0, 0);
      }
      else
      {
        v35 = v3;
        v15 = 0;
        v16 = v10 - 1;
        v17 = (_QWORD *)(v8 + 8);
        v18 = v7 + 1;
        do
        {
          if (!*v18++)
            *((_QWORD *)v14 + v15++) = *v17;
          ++v17;
          --v16;
        }
        while (v16);
        v34 = v14;
        v20 = db_obj_iter_create_with_filter(v12, v15, (uint64_t)v14, 0, 0, 0, 0, 0, 0);
        if (v15)
        {
          for (i = 0; i != v15; ++i)
          {
            v40 = 0;
            v38 = 0;
            v39 = 0;
            v25 = db_obj_iter_next((uint64_t)v20, &v37, 1, v21, v22, v23);
            if (v25)
            {
              v26 = (uint64_t)v25;
              if (((v11 & 4) == 0 || (isContact(v12, (uint64_t)v25, *(_DWORD *)(v9 + 2008)) & 1) == 0)
                && ((v11 & 2) == 0 || !isReminder(v12, v26, *(_DWORD *)(v9 + 2008)))
                && ((v11 & 1) == 0 || !isCalendar(v12, v26, *(_DWORD *)(v9 + 2008))))
              {
                while (db_next_field(v12, v26, 1, &v40, (uint64_t *)&v39, &v38) == 35)
                {
                  if ((*(_WORD *)(v38 + 2) & 8) == 0 && !CFSetContainsValue(v13, v39))
                  {
                    _MDPlistBytesAddInternedCString();
                    CFSetAddValue(v13, v39);
                  }
                }
              }
            }
          }
        }
        v27 = v34;
        v3 = v35;
      }
      db_obj_iter_release((uint64_t)v20);
      free(v27);
    }
    v28 = 8u;
    do
    {
      _MDPlistBytesAddInternedCString();
      v28 += 8;
    }
    while (v28 != 128);
    if (v13)
      CFRelease(v13);
    _MDPlistBytesEndArray();
    _MDPlistBytesEndPlist();
    v29 = malloc_type_calloc(1uLL, 0x40uLL, 0x10720403C4CCC75uLL);
    v30 = *a1;
    if (!*(_QWORD *)(*a1 + 1440))
      si_storecookieRef(*a1);
    v29[1] = *(_OWORD *)(v30 + 1424);
    v31 = (unsigned int *)a1[4];
    *((_QWORD *)v29 + 1) = v31;
    do
      v32 = __ldaxr(v31);
    while (__stlxr(v32 + 1, v31));
    *(_DWORD *)v29 = 3;
    *((_QWORD *)v29 + 4) = Mutable;
    if (!si_resultqueue_enqueue((uint64_t)v3, (int *)v29))
      SIResultBatchFree((void **)v29);
    SIResultQueueRelease(v3);
  }
  v33 = (const void *)a1[5];
  if (v33)
    CFRelease(v33);
  a1[5] = 0;
  si_release_qid(a1[4]);
  free(a1);
}

void si_getAttrBulk(uint64_t a1, int a2)
{
  const void *v3;
  uint64_t v4;
  char **v5;
  char *v6;
  uint64_t Mutable;
  const void *v8;
  int v9;
  NSObject *v10;
  os_log_type_t v11;
  CFAbsoluteTime v12;
  int *v13;
  size_t v14;
  char *v15;
  _OWORD *v16;
  uint64_t v17;
  unsigned int *v18;
  unsigned int v19;
  const void *v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  CFIndex v31;
  size_t v32;
  char *v33;
  uint8_t buf[4];
  CFAbsoluteTime v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    si_resultqueue_enqueue(*(_QWORD *)(a1 + 32), (int *)0xFFFFFFFFFFFFFFFFLL);
    SIResultQueueRelease(*(char **)(a1 + 32));
    v3 = *(const void **)(a1 + 8);
    if (v3)
      CFRelease(v3);
    *(_QWORD *)(a1 + 8) = 0;
  }
  else
  {
    v32 = 0;
    v33 = 0;
    v31 = 0;
    v4 = *(_QWORD *)(a1 + 48);
    if (v4)
      v5 = *(char ***)(v4 + 120);
    else
      v5 = 0;
    v6 = *(char **)(a1 + 32);
    Mutable = _MDPlistBytesCreateMutable();
    SIFlattenArrayToCStringVector(*(const __CFArray **)(a1 + 8), &v33, &v32, &v31);
    v8 = *(const void **)(a1 + 8);
    if (v8)
      CFRelease(v8);
    *(_QWORD *)(a1 + 8) = 0;
    v9 = *__error();
    v10 = _SILogForLogForCategory(5);
    v11 = 2 * (dword_1EF19FCA0 < 4);
    if (os_log_type_enabled(v10, v11))
    {
      v12 = CFAbsoluteTimeGetCurrent() - *(double *)(a1 + 56);
      *(_DWORD *)buf = 134217984;
      v35 = v12;
      _os_log_impl(&dword_1B8270000, v10, v11, "Waited %f seconds on scheduler", buf, 0xCu);
    }
    v13 = __error();
    *v13 = v9;
    MEMORY[0x1E0C80A78](v13);
    v15 = (char *)&v30 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v15, v14);
    if (*(_QWORD *)(a1 + 48) && geteuid())
      goto LABEL_26;
    bzero(v15, *(_QWORD *)(a1 + 24));
    _MDPlistBytesBeginPlist();
    _MDPlistBytesBeginArray();
    _fillPlistBytes(*(_QWORD *)a1, Mutable, (uint64_t)v33, v31, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), (uint64_t)v15, v5, *(_QWORD *)(a1 + 48), *(_DWORD *)(a1 + 64), 0, 0);
    _MDPlistBytesEndArray();
    _MDPlistBytesEndPlist();
    v16 = malloc_type_calloc(1uLL, 0x40uLL, 0x10720403C4CCC75uLL);
    v17 = *(_QWORD *)a1;
    if (!*(_QWORD *)(*(_QWORD *)a1 + 1440))
      si_storecookieRef(*(_QWORD *)a1);
    v16[1] = *(_OWORD *)(v17 + 1424);
    v18 = *(unsigned int **)(a1 + 40);
    *((_QWORD *)v16 + 1) = v18;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 + 1, v18));
    *(_DWORD *)v16 = 2;
    *((_QWORD *)v16 + 4) = Mutable;
    if (!si_resultqueue_enqueue((uint64_t)v6, (int *)v16))
      SIResultBatchFree((void **)v16);
    SIResultQueueRelease(v6);
    free(v33);
  }
  if (!*(_QWORD *)(a1 + 48))
    goto LABEL_25;
  if (geteuid())
  {
LABEL_26:
    v21 = __si_assert_copy_extra_268();
    __message_assert_272((uint64_t)v21, v22, v23, v24, v25, v26, v27, v28, (char)"SIFetching.c");
    free(v21);
    if (__valid_fs(-1))
      v29 = 2989;
    else
      v29 = 3072;
    *(_DWORD *)v29 = -559038737;
    abort();
  }
  v20 = *(const void **)(a1 + 48);
  if (v20)
  {
    CFRelease(v20);
    *(_QWORD *)(a1 + 48) = 0;
  }
LABEL_25:
  si_release_qid(*(_QWORD *)(a1 + 40));
  free((void *)a1);
}

void si_getCacheEntry(uint64_t a1, int a2)
{
  const void *Mutable;
  const void *v4;
  const void *v5;
  const void *v6;
  int v7;
  NSObject *v8;
  _QWORD v9[4];

  v9[3] = *MEMORY[0x1E0C80C00];
  if (a2)
    goto LABEL_8;
  if (dword_1EF19FCC0 >= 5)
  {
    v7 = *__error();
    v8 = _SILogForLogForCategory(13);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v9[0]) = 67109120;
      HIDWORD(v9[0]) = qos_class_self();
      _os_log_impl(&dword_1B8270000, v8, OS_LOG_TYPE_DEFAULT, "si_getCacheEntry at qos 0x%x", (uint8_t *)v9, 8u);
    }
    *__error() = v7;
  }
  if (_os_feature_enabled_impl()
    && (memset(v9, 0, 24), CFArrayGetCount(*(CFArrayRef *)(a1 + 16)))
    && (CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 16), 0),
        SpotlightCacheBundleID(),
        SpotlightCacheLookup()))
  {
    Mutable = (const void *)_MDPlistBytesCreateMutable();
    _MDPlistBytesBeginPlist();
    _MDPlistBytesBeginArray();
    _MDPlistBytesAddInteger();
    _MDPlistBytesEndArray();
    _MDPlistBytesEndPlist();
    (*(void (**)(void))(*(_QWORD *)(a1 + 24) + 16))();
    if (Mutable)
      CFRelease(Mutable);
  }
  else
  {
LABEL_8:
    (*(void (**)(void))(*(_QWORD *)(a1 + 24) + 16))();
  }
  v4 = *(const void **)(a1 + 8);
  if (v4)
    CFRelease(v4);
  *(_QWORD *)(a1 + 8) = 0;
  v5 = *(const void **)(a1 + 16);
  if (v5)
    CFRelease(v5);
  *(_QWORD *)(a1 + 16) = 0;
  v6 = *(const void **)(a1 + 24);
  if (v6)
    CFRelease(v6);
  free((void *)a1);
}

void si_getCacheFd(_QWORD *a1, int a2)
{
  void (*v3)(void);
  const void *v4;
  int v5;
  NSObject *v6;
  __int128 v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v3 = *(void (**)(void))(a1[1] + 16);
LABEL_6:
    v3();
    goto LABEL_7;
  }
  if (dword_1EF19FCC0 >= 5)
  {
    v5 = *__error();
    v6 = _SILogForLogForCategory(13);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v7) = 67109120;
      DWORD1(v7) = qos_class_self();
      _os_log_impl(&dword_1B8270000, v6, OS_LOG_TYPE_DEFAULT, "si_getCacheFd at qos 0x%x", (uint8_t *)&v7, 8u);
    }
    *__error() = v5;
  }
  if (_os_feature_enabled_impl())
  {
    v7 = xmmword_1B8632240;
    MDTrieGetFd();
    v3 = *(void (**)(void))(a1[1] + 16);
    goto LABEL_6;
  }
LABEL_7:
  v4 = (const void *)a1[1];
  if (v4)
    CFRelease(v4);
  free(a1);
}

_QWORD *optimizeLiftingQuery(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3;
  uint64_t v4;
  _QWORD *result;
  int v6;
  _QWORD v7[7];
  _QWORD *v8;
  _QWORD v9[5];

  v8 = (_QWORD *)a2;
  if (a2)
    v3 = *(_WORD *)(a2 + 48) & 1;
  else
    v3 = 0;
  v4 = 16 * *(unsigned __int8 *)(a1 + 2073);
  v7[0] = MEMORY[0x1E0C809B0];
  v7[1] = 0x40000000;
  v7[2] = __optimizeLiftingQuery_block_invoke;
  v7[3] = &__block_descriptor_tmp_147;
  v7[4] = a1;
  v7[5] = a3;
  v7[6] = v4;
  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 0x40000000;
  v9[2] = __db_query_tree_apply_block_block_invoke;
  v9[3] = &unk_1E6E377F8;
  v9[4] = v7;
  db_query_tree_apply_block_with_meta((_QWORD *)a2, (uint64_t)v9, 0);
  db_optimize_query_tree(&v8);
  result = v8;
  if (v3)
  {
    if (v8)
    {
      v6 = *((unsigned __int16 *)v8 + 20);
      if (v6 != 16 && v6 != 32)
        *((_WORD *)v8 + 24) |= 1u;
    }
  }
  return result;
}

uint64_t __queryIsUnpalatable_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  const char *v5;
  CFStringRef v7;
  uint64_t v8;
  void *v9;
  int v10;
  char v11;
  _BYTE **v12;
  uint64_t v13;
  _BYTE *v14;
  int v15;
  BOOL v16;
  BOOL v17;
  int v18;
  NSObject *v19;
  int v21;
  uint8_t buf[4];
  CFStringRef v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    v4 = *(_QWORD *)(a2 + 16);
    if (v4)
    {
      if ((*(_BYTE *)(v4 + 33) & 4) != 0)
      {
        v5 = *(const char **)(v4 + 72);
        if (v5)
        {
          v7 = CFStringCreateWithCString((CFAllocatorRef)kCIQueryZoneAllocator, v5, 0x8000100u);
          v21 = 0;
          v8 = ContentIndexCopyQueryTerms((uint64_t)v7, *(_DWORD *)(a1 + 48), 0, 16 * *(unsigned __int8 *)(*(_QWORD *)(a1 + 40) + 2073), &v21);
          v9 = (void *)v8;
          v10 = v21;
          if (v21 >= 1)
          {
            v11 = 0;
            v12 = (_BYTE **)v8;
            v13 = v21;
            while (1)
            {
              v14 = *v12;
              if ((v11 & 1) != 0 || v10 < 2)
                goto LABEL_17;
              if (!*v14)
                goto LABEL_15;
              if (v14[1] != 42)
              {
                if (*v14 != 42)
                  goto LABEL_15;
                if (!v14[1])
                  goto LABEL_16;
              }
              if (!v14[2])
              {
LABEL_16:
                v11 = 1;
                goto LABEL_17;
              }
LABEL_15:
              v11 = 0;
LABEL_17:
              free(v14);
              ++v12;
              if (!--v13)
                goto LABEL_20;
            }
          }
          v11 = 0;
LABEL_20:
          free(v9);
          v15 = *(_DWORD *)(*(_QWORD *)(a1 + 40) + 6584);
          if ((v15 & 0x40000) == 0 || v10 > 1)
          {
            if ((v15 & 0x40000) != 0)
              v16 = v11;
            else
              v16 = v10 > 1;
            *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) |= v16;
          }
          if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
            v17 = dword_1EF19FC90 < 5;
          else
            v17 = 1;
          if (!v17)
          {
            v18 = *__error();
            v19 = _SILogForLogForCategory(1);
            if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 138412290;
              v23 = v7;
              _os_log_impl(&dword_1B8270000, v19, OS_LOG_TYPE_DEFAULT, "Unpalatable ranking query: %@", buf, 0xCu);
            }
            *__error() = v18;
          }
          CFRelease(v7);
        }
      }
    }
  }
  return a2;
}

uint64_t __optimizeLiftingQuery_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v5;
  const char *v6;
  int v7;
  const __CFAllocator *v8;
  CFStringRef v9;
  void **v10;
  uint64_t v11;
  __CFBitVector *Mutable;
  CFIndex v13;
  __int128 v14;
  char *v15;
  size_t v16;
  size_t v17;
  char *v18;
  size_t v19;
  int v20;
  int v21;
  NSObject *v22;
  void *v23;
  NSObject *v24;
  const char *v25;
  int v26;
  NSObject *v27;
  void *v28;
  NSObject *v29;
  const char *v30;
  BOOL v31;
  CFBit v32;
  NSObject *v33;
  void *v34;
  NSObject *v35;
  void *v36;
  NSObject *v37;
  void *v38;
  __int16 v39;
  CFRange v40;
  size_t v41;
  size_t v42;
  CFIndex v43;
  int v44;
  int v45;
  int v46;
  int v47;
  _BYTE *v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  unsigned int v53;
  size_t v54;
  void *v55;
  uint64_t v56;
  void **v57;
  void *v58;
  int v60;
  NSObject *v61;
  void *v62;
  int v63;
  NSObject *v64;
  void *v65;
  int v66;
  NSObject *v67;
  void *v68;
  int v69;
  NSObject *v70;
  void *v71;
  _QWORD v72[2];
  __int128 v73;
  const __CFString *v74;
  char *v75;
  _BYTE *v76;
  uint64_t v77;
  int v78;
  uint8_t buf[4];
  void *v80;
  __int16 v81;
  void *v82;
  uint64_t v83;

  v83 = *MEMORY[0x1E0C80C00];
  if ((*(_WORD *)(a2 + 40) & 0xFFF7) != 4)
    return a2;
  v3 = *(_QWORD *)(a2 + 16);
  if (!v3)
    return a2;
  v5 = *(_QWORD *)(v3 + 72);
  if (v5 && *(_BYTE *)v5)
  {
    if (*(_BYTE *)(v5 + 1) != 42)
    {
      if (*(_BYTE *)v5 != 42)
        goto LABEL_9;
      if (!*(_BYTE *)(v5 + 1))
        goto LABEL_67;
    }
    if (!*(_BYTE *)(v5 + 2))
    {
LABEL_67:
      if ((*(_BYTE *)(v3 + 33) & 4) == 0)
        return a2;
LABEL_68:
      if (*(_DWORD *)(v3 + 24) == 5)
        v39 = 32;
      else
        v39 = 16;
      free_qp(v3);
      *(_QWORD *)(a2 + 16) = 0;
      *(_WORD *)(a2 + 40) = v39;
      return a2;
    }
  }
LABEL_9:
  if (!*(_BYTE *)(*(_QWORD *)(a1 + 32) + 2072))
  {
    if (strcmp(*(const char **)v3, "_kMDItemBundleID"))
      return a2;
    goto LABEL_68;
  }
  if ((*(_BYTE *)(v3 + 33) & 4) != 0)
    goto LABEL_16;
  v6 = *(const char **)v3;
  if (!v6)
    return a2;
  if (!strcmp(v6, "kMDItemTextContent"))
  {
LABEL_16:
    if (!v5)
      return a2;
  }
  else
  {
    v7 = strncmp(v6, "_kMDItemOCRContent", 0x12uLL);
    if (!v5 || v7)
      return a2;
  }
  v78 = 0;
  v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v9 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const char *)v5, 0x8000100u);
  v10 = (void **)ContentIndexCopyQueryTerms((uint64_t)v9, 3u, *(_QWORD *)(*(_QWORD *)(a1 + 40) + 32), *(_QWORD *)(a1 + 48), &v78);
  LODWORD(v11) = v78;
  if (v78 < 2)
    goto LABEL_101;
  v74 = v9;
  if (dword_1EF19FC90 >= 5)
  {
    v60 = *__error();
    v61 = _SILogForLogForCategory(1);
    if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
    {
      v62 = *(void **)(*(_QWORD *)(a2 + 16) + 72);
      *(_DWORD *)buf = 136315138;
      v80 = v62;
      _os_log_impl(&dword_1B8270000, v61, OS_LOG_TYPE_DEFAULT, "stop word check %s", buf, 0xCu);
    }
    *__error() = v60;
  }
  Mutable = CFBitVectorCreateMutable(v8, (int)v11);
  CFBitVectorSetCount(Mutable, (int)v11);
  v13 = 0;
  *(_QWORD *)&v14 = 136315138;
  v73 = v14;
  do
  {
    v15 = (char *)v10[v13];
    v16 = strlen(v15);
    v17 = v16;
    if (*v15)
    {
      if (v15[1] != 42)
      {
        if (*v15 != 42)
          goto LABEL_25;
        if (!v15[1])
          goto LABEL_33;
      }
      if (!v15[2])
      {
LABEL_33:
        if (dword_1EF19FC90 < 5)
          goto LABEL_47;
        v26 = *__error();
        v27 = _SILogForLogForCategory(1);
        if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
        {
          v28 = v10[v13];
          *(_DWORD *)buf = v73;
          v80 = v28;
          v29 = v27;
          v30 = "short word found: %s";
LABEL_59:
          _os_log_impl(&dword_1B8270000, v29, OS_LOG_TYPE_DEFAULT, v30, buf, 0xCu);
        }
LABEL_60:
        *__error() = v26;
        goto LABEL_47;
      }
    }
LABEL_25:
    MEMORY[0x1E0C80A78](v16);
    v18 = (char *)v72 - ((v17 + 16) & 0xFFFFFFFFFFFFFFF0);
    bzero(v18, v19);
    if (v17)
    {
      if (v15[v17 - 1] == 42)
      {
        strlcpy((char *)v72 - ((v17 + 16) & 0xFFFFFFFFFFFFFFF0), v15, v17);
        --v17;
        v15 = v18;
      }
      if (v17 == 1)
      {
        v20 = *v15;
        if ((v20 - 36) < 0x1D
          || ((v20 - 94) <= 0x20
            ? (v31 = ((1 << (v20 - 94)) & 0x1E0000007) == 0)
            : (v31 = 1),
              !v31 || (v20 - 33) < 2))
        {
          if (dword_1EF19FC90 < 5)
            goto LABEL_47;
          v21 = *__error();
          v22 = _SILogForLogForCategory(1);
          if (!os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
            goto LABEL_64;
          v23 = v10[v13];
          *(_DWORD *)buf = v73;
          v80 = v23;
          v24 = v22;
          v25 = "stop character found: %s";
LABEL_63:
          _os_log_impl(&dword_1B8270000, v24, OS_LOG_TYPE_DEFAULT, v25, buf, 0xCu);
          goto LABEL_64;
        }
      }
    }
    if (isStopWord(v15))
    {
      if (dword_1EF19FC90 < 5)
        goto LABEL_47;
      v21 = *__error();
      v37 = _SILogForLogForCategory(1);
      if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
      {
        v38 = v10[v13];
        *(_DWORD *)buf = v73;
        v80 = v38;
        v24 = v37;
        v25 = "stop word found: %s";
        goto LABEL_63;
      }
LABEL_64:
      *__error() = v21;
LABEL_46:
      if (dword_1EF19FC90 <= 4)
      {
LABEL_47:
        v32 = 1;
        goto LABEL_48;
      }
      v26 = *__error();
      v35 = _SILogForLogForCategory(1);
      if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
      {
        v36 = v10[v13];
        *(_DWORD *)buf = v73;
        v80 = v36;
        v29 = v35;
        v30 = "stop word found: %s";
        goto LABEL_59;
      }
      goto LABEL_60;
    }
    if (CFSetContainsValue(**(CFSetRef **)(a1 + 40), v15))
      goto LABEL_46;
    if (!CFSetContainsValue(*(CFSetRef *)(*(_QWORD *)(a1 + 40) + 8), v15))
    {
      if (isTopKTermAtLevel(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 664)))
      {
        if (dword_1EF19FC90 < 5)
          goto LABEL_47;
        v21 = *__error();
        v33 = _SILogForLogForCategory(1);
        if (!os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
          goto LABEL_64;
        v34 = v10[v13];
        *(_DWORD *)buf = v73;
        v80 = v34;
        v24 = v33;
        v25 = "high freq word found: %s";
        goto LABEL_63;
      }
      CFSetAddValue(*(CFMutableSetRef *)(*(_QWORD *)(a1 + 40) + 8), v15);
    }
    v32 = 0;
LABEL_48:
    CFBitVectorSetBitAtIndex(Mutable, v13++, v32);
    v11 = v78;
  }
  while (v13 < v78);
  v40.length = v78;
  v40.location = 0;
  if (!CFBitVectorGetCountOfBit(Mutable, v40, 1u))
  {
    v9 = v74;
    goto LABEL_100;
  }
  v41 = (2 * strlen(*(const char **)(*(_QWORD *)(a2 + 16) + 72))) | 1;
  v76 = malloc_type_calloc(1uLL, v41, 0x732AF047uLL);
  MEMORY[0x1E0C80A78](v76);
  v75 = (char *)v72 - ((v42 + 15) & 0x7FFFFFFF0);
  bzero(v75, v42);
  if (!(_DWORD)v11)
  {
    v50 = *(_QWORD *)(a2 + 16);
    v51 = *(_QWORD *)(v50 + 32);
    if ((v51 & 0x6000000000) == 0)
    {
      v9 = v74;
      goto LABEL_98;
    }
    v77 = 0;
    v9 = v74;
    goto LABEL_93;
  }
  v72[1] = v72;
  v43 = 0;
  v44 = 0;
  v45 = 0;
  v46 = 0;
  v77 = 0;
  v47 = 0;
  do
  {
    if (CFBitVectorGetBitAtIndex(Mutable, v43))
    {
      ++v47;
      v45 |= v46 != 0;
    }
    else
    {
      if (v46)
      {
        v48 = v76;
        v49 = v77;
        if (!*(_QWORD *)(*(_QWORD *)(a2 + 16) + 88))
          *(_DWORD *)&v75[4 * v77] = v47 + 1;
        v44 |= v45;
        v77 = (v49 + 1);
        v48[v46++] = 32;
      }
      else
      {
        v44 |= v45;
        v48 = v76;
      }
      v47 = 0;
      v46 += strlcat(&v48[v46], (const char *)v10[v43], v41 - v46);
    }
    ++v43;
  }
  while (v11 != v43);
  v50 = *(_QWORD *)(a2 + 16);
  v51 = *(_QWORD *)(v50 + 32);
  if ((v45 & v44 & 1) != 0)
  {
    v9 = v74;
    goto LABEL_93;
  }
  v9 = v74;
  if ((v51 & 0x6000000000) != 0)
  {
LABEL_93:
    if ((v51 & 0x6000000000) == 0)
      *(_QWORD *)(v50 + 32) = v51 | 0x6000000000;
    if (dword_1EF19FC90 >= 5)
    {
      v63 = *__error();
      v64 = _SILogForLogForCategory(1);
      if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT))
      {
        v65 = *(void **)(*(_QWORD *)(a2 + 16) + 72);
        *(_DWORD *)buf = 136315394;
        v80 = v65;
        v81 = 2080;
        v82 = v76;
        _os_log_impl(&dword_1B8270000, v64, OS_LOG_TYPE_DEFAULT, "1) Replace %s with %s", buf, 0x16u);
      }
      *__error() = v63;
      v50 = *(_QWORD *)(a2 + 16);
      v9 = v74;
    }
    free(*(void **)(v50 + 72));
    v52 = *(_QWORD *)(a2 + 16);
    v53 = v77;
    *(_QWORD *)(v52 + 72) = v76;
    *(_DWORD *)(v52 + 96) = v53;
    free(*(void **)(v52 + 88));
    v54 = 4 * v53;
    v55 = malloc_type_malloc(v54, 0x100004052888210uLL);
    *(_QWORD *)(*(_QWORD *)(a2 + 16) + 88) = v55;
    memcpy(v55, v75, v54);
    goto LABEL_100;
  }
  if (v46)
  {
    if (dword_1EF19FC90 >= 5)
    {
      v69 = *__error();
      v70 = _SILogForLogForCategory(1);
      if (os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT))
      {
        v71 = *(void **)(*(_QWORD *)(a2 + 16) + 72);
        *(_DWORD *)buf = 136315394;
        v80 = v71;
        v81 = 2080;
        v82 = v76;
        _os_log_impl(&dword_1B8270000, v70, OS_LOG_TYPE_DEFAULT, "2) Replace %s with %s", buf, 0x16u);
      }
      *__error() = v69;
      v50 = *(_QWORD *)(a2 + 16);
      v9 = v74;
    }
    free(*(void **)(v50 + 72));
    *(_QWORD *)(*(_QWORD *)(a2 + 16) + 72) = v76;
    goto LABEL_100;
  }
LABEL_98:
  if (dword_1EF19FC90 >= 5)
  {
    v66 = *__error();
    v67 = _SILogForLogForCategory(1);
    if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
    {
      v68 = *(void **)(*(_QWORD *)(a2 + 16) + 72);
      *(_DWORD *)buf = v73;
      v80 = v68;
      _os_log_impl(&dword_1B8270000, v67, OS_LOG_TYPE_DEFAULT, "Replace %s with false", buf, 0xCu);
    }
    *__error() = v66;
    v50 = *(_QWORD *)(a2 + 16);
    v9 = v74;
  }
  free_qp(v50);
  *(_QWORD *)(a2 + 16) = 0;
  *(_WORD *)(a2 + 40) = 16;
  free(v76);
  LODWORD(v11) = v78;
LABEL_100:
  CFRelease(Mutable);
LABEL_101:
  if ((_DWORD)v11)
  {
    v56 = v11;
    v57 = v10;
    do
    {
      v58 = *v57++;
      free(v58);
      --v56;
    }
    while (v56);
  }
  free(v10);
  CFRelease(v9);
  return a2;
}

BOOL isTopKTermAtLevel(uint64_t a1)
{
  unsigned int v1;
  int v2;
  unint64_t v3;
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  void (*v9)(_QWORD);
  int v10;
  NSObject *v11;
  _BOOL8 v12;
  uint64_t v13;
  uint64_t v14;
  void (*v15)(_QWORD);
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  _QWORD v21[2];
  _QWORD v22[3];
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  int v26;
  uint8_t buf[24];
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v23 = 0;
  v24 = &v23;
  v25 = 0x2000000000;
  v26 = 0;
  if (a1)
  {
    v22[0] = _MDPlistContainerGetBytes();
    v22[1] = _MDPlistContainerGetLength();
    v22[2] = 0;
    v21[0] = 1;
    v21[1] = v22;
    do
    {
      v1 = __ldxr(exceptionSequenceNum);
      v2 = v1 + 1;
    }
    while (__stxr(v1 + 1, exceptionSequenceNum));
    v3 = setThreadIdAndInfo(-1, (__int128 *)sMappingExceptionCallbacks, (uint64_t)v21, 0, v2);
    v19 = HIDWORD(v3);
    v20 = v3;
    v17 = v5;
    v18 = v4;
    v6 = *(_QWORD *)&threadData[18 * v3 + 2];
    v7 = v6 + 320 * HIDWORD(v3);
    *(_BYTE *)(v7 + 216) = 0;
    v8 = *(_DWORD *)(v7 + 312);
    v9 = *(void (**)(_QWORD))(v7 + 224);
    if (v9)
      v9(*(_QWORD *)(v6 + 320 * HIDWORD(v3) + 288));
    if (_setjmp((int *)v7))
    {
      v10 = *__error();
      v11 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)&buf[4] = "isTopKTermAtLevel";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 296;
        _os_log_error_impl(&dword_1B8270000, v11, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
      }
      *__error() = v10;
      *(_DWORD *)(v7 + 312) = v8;
      CIOnThreadCleanUpReset(v17);
      dropThreadId(v20, 1, v2);
      CICleanUpReset(v20, v18);
    }
    else
    {
      memset(buf, 0, sizeof(buf));
      _MDPlistGetRootPlistObjectFromPlist();
      if (_MDPlistGetPlistObjectType() == 241)
        _MDPlistDictionaryIterate();
      v13 = *(_QWORD *)&threadData[18 * v20 + 2];
      v14 = v13 + 320 * v19;
      *(_DWORD *)(v14 + 312) = v8;
      v15 = *(void (**)(_QWORD))(v14 + 232);
      if (v15)
        v15(*(_QWORD *)(v13 + 320 * v19 + 288));
      dropThreadId(v20, 0, v2);
    }
    v12 = *((_DWORD *)v24 + 6) > 0x3E8u;
  }
  else
  {
    v12 = 0;
  }
  _Block_object_dispose(&v23, 8);
  return v12;
}

uint64_t __isTopKTermAtLevel_block_invoke(uint64_t a1)
{
  uint64_t result;

  result = _MDPlistGetPlistObjectType();
  if ((_DWORD)result == 241)
  {
    result = _MDPlistDictionaryGetPlistObjectForKey();
    if ((_DWORD)result)
    {
      result = _MDPlistNumberGetIntValue();
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += result;
    }
  }
  return result;
}

unsigned __int8 *remove_escaped_chars(unsigned __int8 *result)
{
  int v1;
  _BYTE *v3;
  int v4;
  int v5;

  while (1)
  {
    v1 = *result;
    if (v1 == 92 || v1 == 0)
      break;
    ++result;
  }
  v3 = result;
  while (v1 != 92)
  {
    if (!v1)
      goto LABEL_12;
LABEL_11:
    *v3++ = v1;
    v5 = *++result;
    v1 = v5;
  }
  v4 = *++result;
  LOBYTE(v1) = v4;
  if (v4)
    goto LABEL_11;
LABEL_12:
  *v3 = 0;
  return result;
}

uint64_t addNodeForCPath(uint64_t a1)
{
  uint64_t v1;
  const char *v2;
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;
  uint64_t (*v10)(uint64_t, const char *, _QWORD, _QWORD *, uint64_t, _QWORD, uint64_t);
  int v11;
  int v12;
  int v13;
  const char *v14;
  uint64_t v15;
  int v16;
  uint64_t v18;
  uint64_t OidScopeNode;
  _QWORD v20[513];

  v1 = MEMORY[0x1E0C80A78](a1);
  v7 = v6;
  v20[512] = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)(v1 + 240))
  {
    v9 = v1;
    v10 = *(uint64_t (**)(uint64_t, const char *, _QWORD, _QWORD *, uint64_t, _QWORD, uint64_t))(v1 + 64);
    if (v10)
    {
      v11 = v5;
      v12 = v4;
      v13 = v3;
      v14 = v2;
      bzero(v20, 0x1000uLL);
      v15 = v12 ? 17 : 1;
      v16 = v10(v9, v14, 0, v20, 1, 0, v15);
      if (v16 && v20[0] != 0)
      {
        v18 = v16;
        if (v20[v16 - 1] != 2)
        {
          v20[v16] = 2;
          v18 = v16 + 1;
        }
        OidScopeNode = makeOidScopeNode(v20, v18, v13, v11);
        *(_QWORD *)(*(_QWORD *)(OidScopeNode + 16) + 72) = strdup(v14);
        if (v7)
          return makeORNode(v7, OidScopeNode, 1);
        else
          return OidScopeNode;
      }
    }
  }
  return v7;
}

uint64_t makeOidScopeNode(const void *a1, uint64_t a2, int a3, int a4)
{
  uint64_t v8;
  _QWORD *v9;
  uint64_t (*v10)(uint64_t);
  void *i;
  uint64_t (*v12)(uint64_t);
  void *v13;
  uint64_t v14;
  _QWORD *query_node_with_ann;
  uint64_t tree_apply_block_with_meta;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v22;
  uint64_t v23;
  uint64_t (*v24)(uint64_t);
  void *v25;
  void *v26;

  v8 = MEMORY[0x1E0C809B0];
  v9 = (_QWORD *)makeOidScopeNode_prototypeNode;
  v10 = __db_query_tree_apply_block_block_invoke;
  for (i = &unk_1E6E377F8; !makeOidScopeNode_prototypeNode; v9 = (_QWORD *)makeOidScopeNode_prototypeNode)
  {
    v12 = v10;
    v13 = i;
    v14 = v8;
    query_node_with_ann = db_make_query_node_with_ann("_kMDItemQueryPath = \"stuff\"", 0);
    v8 = v14;
    i = v13;
    *(_QWORD *)(query_node_with_ann[2] + 32) |= 0x40000uLL;
    v10 = v12;
    while (!__ldaxr((unint64_t *)&makeOidScopeNode_prototypeNode))
    {
      if (!__stlxr((unint64_t)query_node_with_ann, (unint64_t *)&makeOidScopeNode_prototypeNode))
      {
        v9 = (_QWORD *)makeOidScopeNode_prototypeNode;
        goto LABEL_7;
      }
    }
    __clrex();
    v22 = v14;
    v23 = 0x40000000;
    v24 = v12;
    v25 = v13;
    v26 = &__block_literal_global_143;
    db_query_tree_apply_block_with_meta(query_node_with_ann, (uint64_t)&v22, 0);
    v8 = v14;
    i = v13;
    v10 = v12;
  }
LABEL_7:
  v22 = v8;
  v23 = 0x40000000;
  v24 = v10;
  v25 = i;
  v26 = &__block_literal_global_17_10736;
  tree_apply_block_with_meta = db_query_tree_apply_block_with_meta(v9, (uint64_t)&v22, (uint64_t)&__block_literal_global_20_10737);
  v18 = *(_QWORD *)(tree_apply_block_with_meta + 16);
  *(_DWORD *)(v18 + 24) = a4;
  free(*(void **)(v18 + 72));
  *(_QWORD *)(*(_QWORD *)(tree_apply_block_with_meta + 16) + 288) = malloc_type_realloc(*(void **)(*(_QWORD *)(tree_apply_block_with_meta+ 16)+ 288), 8 * a2, 0x100004000313F17uLL);
  memcpy(*(void **)(*(_QWORD *)(tree_apply_block_with_meta + 16) + 288), a1, 8 * a2);
  v19 = *(_QWORD *)(tree_apply_block_with_meta + 16);
  *(_DWORD *)(v19 + 160) |= 0x8000u;
  *(_DWORD *)(v19 + 40) = a2;
  *(_QWORD *)(v19 + 8) = _qpPathMatch;
  v20 = 128;
  if (a3)
    v20 = 524416;
  *(_QWORD *)(v19 + 32) |= v20;
  return tree_apply_block_with_meta;
}

uint64_t makeORNode(uint64_t a1, uint64_t a2, int a3)
{
  char v3;
  _QWORD *tree_apply_block_with_meta;
  int v6;
  _QWORD *v7;
  int v8;
  uint64_t v9;
  uint64_t v11;
  uint64_t v12;
  uint64_t (*v13)(uint64_t);
  void *v14;
  void *v15;

  v3 = a3;
  tree_apply_block_with_meta = (_QWORD *)a1;
  v6 = *(unsigned __int16 *)(a1 + 40);
  if (v6 == 16)
    goto LABEL_2;
  v8 = *(unsigned __int16 *)(a2 + 40);
  if (v8 == 16 || v6 == 32)
  {
    v9 = MEMORY[0x1E0C809B0];
    v11 = MEMORY[0x1E0C809B0];
    v12 = 0x40000000;
    v13 = __db_query_tree_apply_block_block_invoke;
    v14 = &unk_1E6E377F8;
    v15 = &__block_literal_global_143;
    db_query_tree_apply_block_with_meta((_QWORD *)a2, (uint64_t)&v11, 0);
    if ((v3 & 1) != 0)
      return (uint64_t)tree_apply_block_with_meta;
    v11 = v9;
    v12 = 0x40000000;
    v13 = __db_query_tree_apply_block_block_invoke;
    v14 = &unk_1E6E377F8;
    v15 = &__block_literal_global_17_10736;
    return db_query_tree_apply_block_with_meta(tree_apply_block_with_meta, (uint64_t)&v11, (uint64_t)&__block_literal_global_20_10737);
  }
  if (v8 == 32)
  {
LABEL_2:
    if (a3)
    {
      v11 = MEMORY[0x1E0C809B0];
      v12 = 0x40000000;
      v13 = __db_query_tree_apply_block_block_invoke;
      v14 = &unk_1E6E377F8;
      v15 = &__block_literal_global_143;
      db_query_tree_apply_block_with_meta((_QWORD *)a1, (uint64_t)&v11, 0);
    }
    return a2;
  }
  else
  {
    v7 = malloc_type_calloc(1uLL, 0x48uLL, 0x10E0040D742DA1DuLL);
    if ((v3 & 1) == 0)
    {
      v11 = MEMORY[0x1E0C809B0];
      v12 = 0x40000000;
      v13 = __db_query_tree_apply_block_block_invoke;
      v14 = &unk_1E6E377F8;
      v15 = &__block_literal_global_17_10736;
      tree_apply_block_with_meta = (_QWORD *)db_query_tree_apply_block_with_meta(tree_apply_block_with_meta, (uint64_t)&v11, (uint64_t)&__block_literal_global_20_10737);
    }
    *v7 = tree_apply_block_with_meta;
    v7[1] = a2;
    *((_WORD *)v7 + 20) = 1;
  }
  return (uint64_t)v7;
}

void destroy_lifting_rule(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  _QWORD v6[5];

  v2 = *(_QWORD *)(a1 + 8);
  if (v2 >= 1)
  {
    v3 = 0;
    v4 = MEMORY[0x1E0C809B0];
    do
    {
      v5 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
      if (v5)
      {
        v6[0] = v4;
        v6[1] = 0x40000000;
        v6[2] = __db_query_tree_apply_block_block_invoke;
        v6[3] = &unk_1E6E377F8;
        v6[4] = &__block_literal_global_143;
        db_query_tree_apply_block_with_meta(v5, (uint64_t)v6, 0);
        v2 = *(_QWORD *)(a1 + 8);
      }
      ++v3;
    }
    while (v2 > v3);
  }
  free(*(void **)a1);
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
}

void clear_lifting_rules(uint64_t a1)
{
  _QWORD *v1;
  uint64_t v2;
  _QWORD *v3;
  __int128 v4;
  uint64_t v5;

  v1 = *(_QWORD **)(a1 + 264);
  v2 = *(_QWORD *)(a1 + 288);
  *(_QWORD *)(a1 + 264) = 0;
  *(_QWORD *)(a1 + 288) = 0;
  if (v1)
  {
    if (v2 >= 1)
    {
      v3 = v1;
      do
      {
        v4 = *(_OWORD *)v3;
        v5 = v3[2];
        destroy_lifting_rule((uint64_t)&v4);
        v3 += 3;
        --v2;
      }
      while (v2);
    }
    free(v1);
  }
}

BOOL SIQueryAddResultGenerator(uint64_t a1, uint64_t a2)
{
  uint64_t ORNode;
  _BOOL8 v5;
  uint64_t v6;
  int v7;
  NSObject *v8;
  int v11;
  NSObject *v12;
  uint64_t v13;
  int buf;
  const char *buf_4;
  __int16 v16;
  _BYTE v17[14];
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  ORNode = (uint64_t)queryFromCFString(a2);
  if (dword_1EF19FC90 >= 5)
  {
    v11 = *__error();
    v12 = _SILogForLogForCategory(1);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      v13 = *(_QWORD *)(a1 + 8);
      buf = 138412546;
      buf_4 = (const char *)a2;
      v16 = 2112;
      *(_QWORD *)v17 = v13;
      _os_log_impl(&dword_1B8270000, v12, OS_LOG_TYPE_DEFAULT, "Adding generator %@ to query %@", (uint8_t *)&buf, 0x16u);
    }
    *__error() = v11;
  }
  v5 = ORNode != 0;
  if (ORNode)
  {
    v6 = *(_QWORD *)(a1 + 88);
    if (v6)
      ORNode = makeORNode(v6, ORNode, 1);
    *(_QWORD *)(a1 + 88) = ORNode;
  }
  else
  {
    v7 = *__error();
    v8 = _SILogForLogForCategory(1);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      buf = 136315650;
      buf_4 = "SIQueryAddResultGenerator";
      v16 = 1024;
      *(_DWORD *)v17 = 1014;
      *(_WORD *)&v17[4] = 2112;
      *(_QWORD *)&v17[6] = a2;
      _os_log_error_impl(&dword_1B8270000, v8, OS_LOG_TYPE_ERROR, "%s:%d: Failed adding generator: %@", (uint8_t *)&buf, 0x1Cu);
    }
    *__error() = v7;
  }
  return v5;
}

BOOL __initQuery_block_invoke_3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return *(_WORD *)(a2 + 40) == 2 && (a3 | a4) != 0;
}

uint64_t __initQuery_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  int v3;
  uint64_t v4;
  char *v5;
  const char *v6;

  result = a2;
  v3 = *(unsigned __int16 *)(a2 + 40);
  if ((v3 - 1) >= 2)
  {
    if (v3 != 4)
      return 0;
    v4 = *(_QWORD *)(a2 + 16);
    if (!v4)
      return 0;
    if (*(_DWORD *)(v4 + 24) != 1)
      return 0;
    v5 = *(char **)(v4 + 72);
    if (strchr(v5, 42))
      return 0;
    v6 = *(const char **)v4;
    if (!strcmp(v6, "kMDItemContentTypeTree"))
    {
      if (CFSetContainsValue((CFSetRef)initQuery_treeTypeSet, v5))
        return 1;
    }
    else if (!strcmp(v6, "kMDItemContentType") || !strcmp(v6, "_kMDItemGroupId"))
    {
      return 1;
    }
    return 0;
  }
  return result;
}

CFSetRef __initQuery_block_invoke()
{
  CFSetRef result;
  CFSetCallBacks v1;
  const void *__dst[139];

  __dst[138] = *(const void **)MEMORY[0x1E0C80C00];
  memcpy(__dst, off_1E6E35668, 0x450uLL);
  *(_OWORD *)&v1.version = (unint64_t)kCStringSetCallBacks;
  v1.copyDescription = *(CFSetCopyDescriptionCallBack *)algn_1EF19F9E8;
  *(_OWORD *)&v1.equal = xmmword_1EF19F9F0;
  v1.release = 0;
  result = CFSetCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], __dst, 138, &v1);
  initQuery_treeTypeSet = (uint64_t)result;
  return result;
}

CFSetRef __query_needsWhatFieldsMatched_block_invoke()
{
  CFSetRef result;
  _OWORD v1[3];
  uint64_t v2;

  v2 = *MEMORY[0x1E0C80C00];
  v1[0] = xmmword_1E6E35638;
  v1[1] = *(_OWORD *)&off_1E6E35648;
  v1[2] = xmmword_1E6E35658;
  result = CFSetCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)v1, 6, MEMORY[0x1E0C9B3B0]);
  query_needsWhatFieldsMatched_dict = (uint64_t)result;
  return result;
}

uint64_t SIQueryCreateWithItemsAndCompletionString(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, unsigned int a10, __int128 a11, __int128 a12, uint64_t a13)
{
  unint64_t v13;
  uint64_t v15[6];
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  _OWORD v26[4];
  __int128 v27;
  __int128 v28;
  _OWORD v29[5];

  v28 = 0u;
  memset(v29, 0, sizeof(v29));
  v27 = 0u;
  v25 = 0u;
  memset(v26, 0, sizeof(v26));
  v23 = 0u;
  v24 = 0u;
  v22 = 0u;
  v15[0] = 1;
  v15[1] = a1;
  v15[2] = 0;
  v15[3] = 0;
  v15[4] = a2;
  v15[5] = a3;
  v16 = a4;
  v17 = a5;
  v18 = a6;
  v19 = a7;
  v20 = a8;
  v21 = a9;
  do
    v13 = __ldaxr(&gInternalQueryID);
  while (__stlxr(v13 + 1, &gInternalQueryID));
  *((_QWORD *)&v22 + 1) = v13;
  v23 = a10;
  v24 = a11;
  v25 = a12;
  *(_QWORD *)&v26[0] = a13;
  memset((char *)v26 + 8, 0, 48);
  v27 = 0u;
  v28 = 0u;
  LOBYTE(v29[0]) = 0;
  memset((char *)v29 + 8, 0, 48);
  *(_OWORD *)((char *)&v29[3] + 2) = 0u;
  return SIQueryCreateWithParameters(v15);
}

uint64_t SIQueryCreateWithItemsAndCompletionStringWithWeights(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __int128 a9, unsigned int a10, __int128 a11, __int128 a12, uint64_t a13)
{
  unint64_t v13;
  uint64_t v15[6];
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  _OWORD v26[4];
  __int128 v27;
  __int128 v28;
  _OWORD v29[5];

  v28 = 0u;
  memset(v29, 0, sizeof(v29));
  v27 = 0u;
  v25 = 0u;
  memset(v26, 0, sizeof(v26));
  v23 = 0u;
  v24 = 0u;
  v22 = 0u;
  v15[0] = 1;
  v15[1] = a1;
  v15[2] = 0;
  v15[3] = 0;
  v15[4] = a2;
  v15[5] = a3;
  v16 = a4;
  v17 = a5;
  v18 = a6;
  v19 = a7;
  v20 = a8;
  v21 = a9;
  do
    v13 = __ldaxr(&gInternalQueryID);
  while (__stlxr(v13 + 1, &gInternalQueryID));
  *((_QWORD *)&v22 + 1) = v13;
  v23 = a10;
  v24 = a11;
  v25 = a12;
  *(_QWORD *)&v26[0] = a13;
  memset((char *)v26 + 8, 0, 48);
  v27 = 0u;
  v28 = 0u;
  LOBYTE(v29[0]) = 0;
  memset((char *)v29 + 8, 0, 48);
  *(_OWORD *)((char *)&v29[3] + 2) = 0u;
  return SIQueryCreateWithParameters(v15);
}

uint64_t SIQueryCreateWithItemsAndCompletionStringWithCurrentTime(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, uint64_t a10, unsigned int a11, __int128 a12, __int128 a13, uint64_t a14)
{
  unint64_t v14;
  uint64_t v16[6];
  __int128 v17;
  __int128 v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  _OWORD v33[5];

  v32 = 0u;
  memset(v33, 0, sizeof(v33));
  v30 = 0u;
  v31 = 0u;
  v28 = 0u;
  v29 = 0u;
  v26 = 0u;
  v27 = 0u;
  v24 = 0u;
  v25 = 0u;
  v23 = 0u;
  v16[0] = 1;
  v16[1] = a1;
  v16[2] = 0;
  v16[3] = 0;
  v16[4] = a2;
  v16[5] = a3;
  v17 = a4;
  v18 = a5;
  v19 = a6;
  v20 = a7;
  v21 = a8;
  v22 = a10;
  do
    v14 = __ldaxr(&gInternalQueryID);
  while (__stlxr(v14 + 1, &gInternalQueryID));
  *((_QWORD *)&v23 + 1) = v14;
  v24 = a11;
  v25 = a12;
  v26 = a13;
  *(_QWORD *)&v27 = a14;
  *((double *)&v27 + 1) = a9;
  v28 = 0u;
  v29 = 0u;
  *(_QWORD *)&v30 = 0;
  v31 = 0u;
  v32 = 0u;
  LOBYTE(v33[0]) = 0;
  memset((char *)v33 + 8, 0, 48);
  *(_OWORD *)((char *)&v33[3] + 2) = 0u;
  return SIQueryCreateWithParameters(v16);
}

uint64_t SIQueryCreateWithItemsAndCompletionStringWithWeightsForCurrentTime(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, __int128 a10, unsigned int a11, __int128 a12, __int128 a13, uint64_t a14)
{
  unint64_t v14;
  uint64_t v16[6];
  __int128 v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  _OWORD v33[5];

  v32 = 0u;
  memset(v33, 0, sizeof(v33));
  v30 = 0u;
  v31 = 0u;
  v28 = 0u;
  v29 = 0u;
  v26 = 0u;
  v27 = 0u;
  v24 = 0u;
  v25 = 0u;
  v23 = 0u;
  v16[0] = 1;
  v16[1] = a1;
  v16[2] = 0;
  v16[3] = 0;
  v16[4] = a2;
  v16[5] = a3;
  v17 = a4;
  v18 = a5;
  v19 = a6;
  v20 = a7;
  v21 = a8;
  v22 = a10;
  do
    v14 = __ldaxr(&gInternalQueryID);
  while (__stlxr(v14 + 1, &gInternalQueryID));
  *((_QWORD *)&v23 + 1) = v14;
  v24 = a11;
  v25 = a12;
  v26 = a13;
  *(_QWORD *)&v27 = a14;
  *((double *)&v27 + 1) = a9;
  v28 = 0u;
  v29 = 0u;
  *(_QWORD *)&v30 = 0;
  v31 = 0u;
  v32 = 0u;
  LOBYTE(v33[0]) = 0;
  memset((char *)v33 + 8, 0, 48);
  *(_OWORD *)((char *)&v33[3] + 2) = 0u;
  return SIQueryCreateWithParameters(v16);
}

uint64_t SIQueryCreate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, uint64_t a7, uint64_t a8, unint64_t a9, uint64_t a10)
{
  unint64_t v10;
  uint64_t v12[2];
  __int128 v13;
  _BYTE v14[28];
  int v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  _OWORD v31[5];

  v30 = 0u;
  memset(v31, 0, sizeof(v31));
  v28 = 0u;
  v29 = 0u;
  v26 = 0u;
  v27 = 0u;
  v24 = 0u;
  v25 = 0u;
  v22 = 0u;
  v23 = 0u;
  v21 = 0u;
  memset(v14, 0, sizeof(v14));
  v15 = 0;
  v12[0] = 1;
  v12[1] = a1;
  v13 = 0u;
  v16 = 0uLL;
  v17 = a2;
  v18 = a3;
  v19 = a4;
  v20 = a5;
  do
    v10 = __ldaxr(&gInternalQueryID);
  while (__stlxr(v10 + 1, &gInternalQueryID));
  *((_QWORD *)&v21 + 1) = v10;
  v22 = a6;
  *(_QWORD *)&v23 = a7;
  *((_QWORD *)&v23 + 1) = a8;
  v24 = a9;
  *(_QWORD *)&v25 = a10;
  *((_QWORD *)&v25 + 1) = CFAbsoluteTimeGetCurrent();
  v26 = 0u;
  v27 = 0u;
  *(_QWORD *)&v28 = 0;
  v29 = 0u;
  v30 = 0u;
  LOBYTE(v31[0]) = 0;
  memset((char *)v31 + 8, 0, 48);
  *(_OWORD *)((char *)&v31[3] + 2) = 0u;
  return SIQueryCreateWithParameters(v12);
}

uint64_t SIQuerySetStrongRankingQueryCount(uint64_t result, int a2)
{
  *(_DWORD *)(result + 324) = a2;
  return result;
}

uint64_t SIQuerySetDominantRankingQueryCount(uint64_t result, int a2, int a3)
{
  *(_DWORD *)(result + 328) = a2;
  *(_DWORD *)(result + 332) = a3;
  return result;
}

uint64_t SIQuerySetShortcutBit(uint64_t result, int a2)
{
  *(_DWORD *)(result + 336) = a2;
  return result;
}

uint64_t SIQuerySetHighMatchBit(uint64_t result, int a2)
{
  *(_DWORD *)(result + 340) = a2;
  return result;
}

uint64_t SIQuerySetLowMatchBit(uint64_t result, int a2)
{
  *(_DWORD *)(result + 344) = a2;
  return result;
}

uint64_t SIQuerySetHighRecencyBit(uint64_t result, int a2)
{
  *(_DWORD *)(result + 348) = a2;
  return result;
}

uint64_t SIQuerySetLowRecencyBit(uint64_t result, int a2)
{
  *(_DWORD *)(result + 352) = a2;
  return result;
}

_QWORD *SIQuerySetFuzzyQueryInfo(_QWORD *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  result[79] = a3;
  result[78] = a2;
  result[81] = a5;
  result[80] = a4;
  return result;
}

uint64_t SIQuerySetUniqueId(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 608) = a2;
  return result;
}

uint64_t SIQueryGetUniqueId(uint64_t a1)
{
  return *(_QWORD *)(a1 + 608);
}

__CFArray *si_attrs_remapping_copy(const __CFArray *a1, int a2)
{
  uint64_t v3;
  const __CFDictionary *v4;
  uint64_t Count;
  uint64_t v6;
  __CFArray *Mutable;
  CFIndex i;
  const void *ValueAtIndex;
  const void *Value;
  const void *v11;
  CFRange v13;

  if (!a1)
    return 0;
  v3 = a2 ? si_cab_attr_rewriteDict() : si_attr_rewriteDict();
  v4 = (const __CFDictionary *)v3;
  Count = CFArrayGetCount(a1);
  if (Count < 1)
    return 0;
  v6 = Count;
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], Count, MEMORY[0x1E0C9B378]);
  v13.location = 0;
  v13.length = 0;
  CFArrayAppendArray(Mutable, a1, v13);
  for (i = 0; i != v6; ++i)
  {
    ValueAtIndex = CFArrayGetValueAtIndex(a1, i);
    Value = CFDictionaryGetValue(v4, ValueAtIndex);
    if (Value)
      v11 = Value;
    else
      v11 = ValueAtIndex;
    CFArrayAppendValue(Mutable, v11);
  }
  return Mutable;
}

uint64_t si_cab_attr_rewriteDict()
{
  uint64_t result;
  CFDictionaryRef v1;
  void *values[26];
  void *keys[27];

  keys[26] = *(void **)MEMORY[0x1E0C80C00];
  result = si_cab_attr_rewriteDict_sDict;
  if (!si_cab_attr_rewriteDict_sDict)
  {
    keys[0] = CFSTR("kMDItemFSSize");
    keys[1] = CFSTR("kMDItemFSCreationDate");
    keys[2] = CFSTR("kMDItemFSContentChangeDate");
    keys[3] = CFSTR("kMDItemFSOwnerGroupID");
    keys[4] = CFSTR("kMDItemFSOwnerUserID");
    keys[5] = CFSTR("kMDItemFSName");
    keys[6] = CFSTR("kMDItemFSLabel");
    keys[7] = CFSTR("kMDItemFSHasCustomIcon");
    keys[8] = CFSTR("kMDItemFSIsExtensionHidden");
    keys[9] = CFSTR("kMDItemFSNodeCount");
    keys[10] = CFSTR("kMDItemFSIsStationery");
    keys[11] = CFSTR("kMDItemFSTypeCode");
    keys[12] = CFSTR("kMDItemFSCreatorCode");
    keys[13] = CFSTR("kMDItemFSFinderFlags");
    keys[14] = CFSTR("kMDItemFSFileId");
    keys[15] = CFSTR("_kMDItemFSContentType");
    keys[16] = CFSTR("_kMDItemFSContentTypeTree");
    keys[17] = CFSTR("_kMDItemFSDisplayName");
    keys[18] = CFSTR("_kMDItemFSDisplayKind");
    keys[19] = CFSTR("_kMDItemSharedProjectID");
    keys[20] = CFSTR("_kMDItemExternalID");
    keys[21] = CFSTR("FPParentFileItemID");
    keys[22] = CFSTR("FPFilename");
    keys[23] = CFSTR("_kMDItemBundleID");
    keys[24] = CFSTR("kMDItemFileProviderID");
    keys[25] = CFSTR("kMDItemIsTrashed");
    values[0] = CFSTR("kMDItemLogicalSize");
    values[1] = CFSTR("_kMDItemCreationDate");
    values[2] = CFSTR("_kMDItemContentChangeDate");
    values[3] = CFSTR("_kMDItemOwnerGroupID");
    values[4] = CFSTR("_kMDItemOwnerUserID");
    values[5] = CFSTR("_kMDItemFileName");
    values[6] = CFSTR("_kMDItemFinderLabel");
    values[7] = CFSTR("_kMDItemHasCustomIcon");
    values[8] = CFSTR("_kMDItemIsExtensionHidden");
    values[9] = CFSTR("_kMDItemNodeCount");
    values[10] = CFSTR("_kMDItemIsStationery");
    values[11] = CFSTR("_kMDItemTypeCode");
    values[12] = CFSTR("_kMDItemCreatorCode");
    values[13] = CFSTR("_kMDItemFinderFlags");
    values[14] = CFSTR("_kMDItemFileId");
    values[15] = CFSTR("kMDItemContentType");
    values[16] = CFSTR("kMDItemContentTypeTree");
    values[17] = CFSTR("kMDItemDisplayName");
    values[18] = CFSTR("kMDItemKind");
    values[19] = &stru_1E6E3A6D8;
    values[20] = CFSTR("_FPItemIdentifier");
    values[21] = CFSTR("_FPParentFileItemID");
    values[22] = CFSTR("_kMDItemFileName");
    values[23] = CFSTR("_FPUserFSUSBFileProviderID");
    values[24] = CFSTR("_FPUserFSUSBFileProviderID");
    values[25] = CFSTR("_FPIsTrashed");
    v1 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)keys, (const void **)values, 26, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    while (!__ldaxr((unint64_t *)&si_cab_attr_rewriteDict_sDict))
    {
      if (!__stlxr((unint64_t)v1, (unint64_t *)&si_cab_attr_rewriteDict_sDict))
        return si_cab_attr_rewriteDict_sDict;
    }
    __clrex();
    CFRelease(v1);
    return si_cab_attr_rewriteDict_sDict;
  }
  return result;
}

uint64_t si_attr_rewriteDict()
{
  uint64_t result;
  CFDictionaryRef v1;
  void *values;
  void *keys[2];

  keys[1] = *(void **)MEMORY[0x1E0C80C00];
  result = si_attr_rewriteDict_sDict;
  if (!si_attr_rewriteDict_sDict)
  {
    values = CFSTR("kMDItemLogicalSize");
    keys[0] = CFSTR("kMDItemFSSize");
    v1 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)keys, (const void **)&values, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    while (!__ldaxr((unint64_t *)&si_attr_rewriteDict_sDict))
    {
      if (!__stlxr((unint64_t)v1, (unint64_t *)&si_attr_rewriteDict_sDict))
        return si_attr_rewriteDict_sDict;
    }
    __clrex();
    CFRelease(v1);
    return si_attr_rewriteDict_sDict;
  }
  return result;
}

unsigned __int16 **__queryRemapFieldsForStore_block_invoke_5(uint64_t a1, uint64_t a2)
{
  unsigned __int16 **v2;
  uint64_t v3;
  char *v4;
  const char *v6;
  int v7;
  const char *v8;
  uint64_t v9;
  const __CFDictionary *v10;
  const __CFNumber *Value;
  const __CFNumber *v12;
  CFTypeID v13;
  unsigned __int16 **query_node_with_ann;
  unsigned __int16 **v15;
  int v16;
  unsigned __int16 *v17;
  unsigned __int16 **v18;
  unsigned __int16 *v19;
  int v20;
  unsigned int v21;
  int v22;
  uint64_t v23;
  uint64_t tree_apply_block_with_meta;
  uint64_t *v25;
  uint64_t v26;
  unsigned __int16 *v27;
  _QWORD *v28;
  CFStringRef v29;
  const __CFString *v30;
  unsigned __int16 *v31;
  int v32;
  char **v33;
  int64_t v34;
  const char *v35;
  const char *v36;
  size_t v37;
  const char *v38;
  const char *v39;
  size_t v40;
  _QWORD *PathNodeForPath;
  _QWORD *v42;
  __int16 v43;
  __int16 v44;
  const char *v45;
  char *v46;
  unsigned __int16 *v47;
  _QWORD *PathNodeForOid;
  __int16 v49;
  unsigned __int16 **v50;
  unsigned __int16 **v51;
  char *v53;
  char *v54;
  const char *v55;
  uint64_t v56;
  char *__endptr;
  int valuePtr;
  char buffer[16];
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  uint64_t v64;

  v2 = (unsigned __int16 **)a2;
  v64 = *MEMORY[0x1E0C80C00];
  if (*(_WORD *)(a2 + 40) != 4)
    return v2;
  v3 = *(_QWORD *)(a2 + 16);
  if (!v3)
    return v2;
  v4 = *(char **)v3;
  if (!*(_QWORD *)v3)
    return v2;
  if (!strcmp(*(const char **)v3, "kMDItemDisplayName"))
  {
    v9 = **(_QWORD **)(a1 + 32);
    if (v9)
    {
      v10 = *(const __CFDictionary **)(v9 + 168);
      valuePtr = 0;
      if (v10)
      {
        Value = (const __CFNumber *)CFDictionaryGetValue(v10, CFSTR("_showAllExtensions"));
        if (Value)
        {
          v12 = Value;
          v13 = CFGetTypeID(Value);
          if (v13 == CFNumberGetTypeID())
          {
            CFNumberGetValue(v12, kCFNumberIntType, &valuePtr);
            if (valuePtr)
            {
              __endptr = 0;
              asprintf(&__endptr, "_kMDItemDisplayNameWithExtensions == \"X\" || (_kMDItemDisplayNameWithExtensions != * && kMDItemDisplayName == \"X\")");
              if (__endptr)
              {
                query_node_with_ann = (unsigned __int16 **)db_make_query_node_with_ann(__endptr, 0);
                if (query_node_with_ann && (v15 = query_node_with_ann, *query_node_with_ann) && query_node_with_ann[1])
                {
                  v16 = (*query_node_with_ann)[20];
                  if (v16 == 4)
                    v17 = query_node_with_ann[1];
                  else
                    v17 = *query_node_with_ann;
                  if (v16 == 4)
                    v18 = query_node_with_ann;
                  else
                    v18 = query_node_with_ann + 1;
                  if (v17[20] != 2)
                  {
                    v53 = __si_assert_copy_extra_521(*(_DWORD *)(*(_QWORD *)(a1 + 40) + 32));
                    v54 = v53;
                    v55 = "";
                    if (v53)
                      v55 = v53;
                    __message_assert("%s:%u: failed assertion '%s' %s Bad generated query mid-node; unexpected type %d",
                      "SIQueryC.c",
                      3272,
                      "midNode->type == AND_NODE",
                      v55,
                      v17[20]);
                    free(v54);
                    if (__valid_fs(*(_DWORD *)(*(_QWORD *)(a1 + 40) + 32)))
                      v56 = 2989;
                    else
                      v56 = 3072;
                    *(_DWORD *)v56 = -559038737;
                    abort();
                  }
                  if (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)v17 + 16) + 24) != 1)
                    v17 += 4;
                  v19 = v2[2];
                  v20 = *((_DWORD *)v19 + 6);
                  v21 = v20 - 5;
                  if ((v20 - 5) <= 1)
                  {
                    if (v20 == 5)
                      v22 = 1;
                    else
                      v22 = 2;
                    *((_DWORD *)v19 + 6) = v22;
                  }
                  v23 = MEMORY[0x1E0C809B0];
                  *(_QWORD *)buffer = MEMORY[0x1E0C809B0];
                  *(_QWORD *)&buffer[8] = 0x40000000;
                  *(_QWORD *)&v60 = __db_query_tree_apply_block_block_invoke;
                  *((_QWORD *)&v60 + 1) = &unk_1E6E377F8;
                  *(_QWORD *)&v61 = &__block_literal_global_17_10736;
                  tree_apply_block_with_meta = db_query_tree_apply_block_with_meta(v2, (uint64_t)buffer, (uint64_t)&__block_literal_global_20_10737);
                  v25 = *(uint64_t **)(tree_apply_block_with_meta + 16);
                  v26 = *v25;
                  *v25 = **((_QWORD **)*v18 + 2);
                  **((_QWORD **)*v18 + 2) = v26;
                  v27 = *v18;
                  *v18 = (unsigned __int16 *)tree_apply_block_with_meta;
                  db_free_query_node(v27);
                  v28 = *(_QWORD **)v17;
                  *(_QWORD *)v17 = v2;
                  db_free_query_node(v28);
                  if (v21 <= 1)
                  {
                    *(_QWORD *)buffer = v23;
                    *(_QWORD *)&buffer[8] = 0x40000000;
                    *(_QWORD *)&v60 = __db_query_tree_apply_block_block_invoke;
                    *((_QWORD *)&v60 + 1) = &unk_1E6E377F8;
                    *(_QWORD *)&v61 = &__block_literal_global_10697;
                    db_query_tree_apply_block_with_meta(v15, (uint64_t)buffer, 0);
                  }
                }
                else
                {
                  v15 = v2;
                }
                free(__endptr);
                return v15;
              }
            }
          }
        }
      }
    }
    return v2;
  }
  if (!strncmp(v4, "kMDItemFS", 9uLL) && strcmp(v4, "kMDItemFSLabel"))
  {
    v29 = CFStringCreateWithCStringNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v4, 0x8000100u, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
    v30 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 48), v29);
    CFRelease(v29);
    if (v30)
    {
      v31 = v2[2];
      *((_QWORD *)v31 + 1) = 0;
      v2[4] = 0;
      *((_DWORD *)v31 + 12) = 100;
      *((_QWORD *)v31 + 4) &= 0xFFFFFFFFFFFFF77FLL;
      free(*(void **)v31);
      v62 = 0u;
      v63 = 0u;
      v60 = 0u;
      v61 = 0u;
      *(_OWORD *)buffer = 0u;
      CFStringGetCString(v30, buffer, 80, 0x8000100u);
      *(_QWORD *)v2[2] = strdup(buffer);
    }
    return v2;
  }
  v6 = *(const char **)(v3 + 72);
  if (!v6)
    return v2;
  v7 = *(_DWORD *)(v3 + 24);
  if ((v7 | 4) != 5)
    return v2;
  if (!strcmp(v4, "kMDItemFSLabel"))
  {
    v32 = atoi(v6);
    v33 = str_label_gray;
    switch(v32)
    {
      case 0:
        if (!strcmp("*", v6))
        {
          if (v7 == 1)
            goto LABEL_51;
          if (v7 == 5)
            goto LABEL_97;
        }
        else if (!strcmp("0", v6))
        {
          goto LABEL_49;
        }
        return v2;
      case 1:
        goto LABEL_82;
      case 2:
        v33 = str_label_green;
        goto LABEL_82;
      case 3:
        v33 = str_label_purple;
        goto LABEL_82;
      case 4:
        v33 = str_label_blue;
        goto LABEL_82;
      case 5:
        v33 = str_label_yellow;
        goto LABEL_82;
      case 6:
        v33 = str_label_red;
        goto LABEL_82;
      case 7:
        v33 = &str_label_orange;
LABEL_82:
        v45 = *v33;
        if (*v33)
        {
          *(_QWORD *)(v3 + 8) = 0;
          v2[4] = 0;
          *(_DWORD *)(v3 + 48) = 100;
          *(_QWORD *)(v3 + 32) &= 0xFFFFFFFFFFFFF77FLL;
          free(v4);
          v46 = strdup(v45);
          v47 = v2[2];
          *(_QWORD *)v47 = v46;
          **((_BYTE **)v47 + 9) = 42;
          *(_BYTE *)(*((_QWORD *)v2[2] + 9) + 1) = 0;
        }
        break;
      default:
        return v2;
    }
    return v2;
  }
  if (!strcmp(v4, "kMDLabel_zya2exypzrhulknkk5enqbj33y") && !strcmp("*", v6))
  {
LABEL_49:
    if (v7 == 1)
    {
LABEL_97:
      __endptr = 0;
      asprintf(&__endptr, "!(%s=*||%s=*||%s=*||%s=*||%s=*||%s=*||%s=*)", "kMDLabel_yekauorssrbpta3hdteqgbglma");
    }
    else
    {
      if (v7 != 5)
        return v2;
LABEL_51:
      __endptr = 0;
      asprintf(&__endptr, "%s=*||%s=*||%s=*||%s=*||%s=*||%s=*||%s=*", "kMDLabel_yekauorssrbpta3hdteqgbglma");
    }
    if (__endptr)
    {
      v50 = (unsigned __int16 **)db_make_query_node_with_ann(__endptr, 0);
      if (v50)
      {
        v51 = v50;
        *(_QWORD *)buffer = MEMORY[0x1E0C809B0];
        *(_QWORD *)&buffer[8] = 0x40000000;
        *(_QWORD *)&v60 = __db_query_tree_apply_block_block_invoke;
        *((_QWORD *)&v60 + 1) = &unk_1E6E377F8;
        *(_QWORD *)&v61 = &__block_literal_global_143;
        db_query_tree_apply_block_with_meta(v2, (uint64_t)buffer, 0);
        v2 = v51;
      }
      free(__endptr);
    }
    return v2;
  }
  if (v7 != 1)
  {
    if (v7 != 5)
      return v2;
LABEL_53:
    v34 = strlen(v4);
    if (v34 > 20)
    {
      if (v34 == 21)
      {
        v38 = "kMDItemFileProviderID";
        v39 = v4;
        v40 = 21;
      }
      else
      {
        if (v34 != 26)
          return v2;
        v38 = "_FPUserFSUSBFileProviderID";
        v39 = v4;
        v40 = 26;
      }
      if (strncmp(v39, v38, v40))
        return v2;
    }
    else
    {
      if (v34 == 12)
      {
        v35 = "_FPIsTrashed";
        v36 = v4;
        v37 = 12;
        goto LABEL_64;
      }
      if (v34 != 16)
        return v2;
      if (strncmp(v4, "_kMDItemBundleID", 0x10uLL))
      {
        v35 = "kMDItemIsTrashed";
        v36 = v4;
        v37 = 16;
LABEL_64:
        if (strncmp(v36, v35, v37) || (v7 | 4) != 5)
          return v2;
        if (atoi(v6))
        {
          if (v7 == 1)
          {
LABEL_68:
            PathNodeForPath = createPathNodeForPath(*(_QWORD *)(a1 + 40));
            if (!PathNodeForPath)
              return v2;
            v42 = PathNodeForPath;
LABEL_94:
            *(_QWORD *)buffer = MEMORY[0x1E0C809B0];
            *(_QWORD *)&buffer[8] = 0x40000000;
            *(_QWORD *)&v60 = __db_query_tree_apply_block_block_invoke;
            *((_QWORD *)&v60 + 1) = &unk_1E6E377F8;
            *(_QWORD *)&v61 = &__block_literal_global_143;
            db_query_tree_apply_block_with_meta(v2, (uint64_t)buffer, 0);
            return (unsigned __int16 **)v42;
          }
        }
        else if (v7 == 5)
        {
          goto LABEL_68;
        }
        free_qp(v3);
        v2[2] = 0;
        *((_WORD *)v2 + 20) = 32;
        return v2;
      }
    }
    if ((v7 | 4) == 5 && (!strcmp(v6, "*") || !strcmp(v6, "com.apple.filesystems.UserFS.FileProvider")))
    {
      v43 = 32;
      v44 = 16;
    }
    else
    {
      v43 = 16;
      v44 = 32;
    }
    if (v7 == 5)
      v49 = v44;
    else
      v49 = v43;
    free_qp(v3);
    v2[2] = 0;
    *((_WORD *)v2 + 20) = v49;
    return v2;
  }
  if (strncmp(v4, "_kMDItemQueryPath", 0x11uLL))
    goto LABEL_53;
  if (v4[17])
  {
    if (!strncmp(v4 + 17, "OID", 3uLL))
      v8 = v4 + 20;
    else
      v8 = v4 + 17;
    strncmp(v8, "Flat", 4uLL);
  }
  __endptr = 0;
  strtoll(v6, &__endptr, 0);
  if (__endptr == v6 || *__endptr)
    PathNodeForOid = createPathNodeForPath(*(_QWORD *)(a1 + 40));
  else
    PathNodeForOid = createPathNodeForOid(*(_QWORD *)(a1 + 40));
  v42 = PathNodeForOid;
  if (PathNodeForOid)
    goto LABEL_94;
  return v2;
}

void enqueueQuery(_QWORD *a1, int a2)
{
  uint64_t v3;
  const void *v4;
  uint64_t v5;
  unsigned int *v6;
  unsigned int v7;
  BOOL v8;
  int priority;
  uint64_t v10;
  const void *v11;
  unsigned int *v12;
  unsigned int v13;

  v3 = a1[1];
  if (a2)
  {
    if ((*(_BYTE *)(v3 + 202) & 4) == 0)
      si_querypipe_remove_process(a1[2], v3, 0, 1);
    v4 = (const void *)a1[4];
    if (v4)
      CFRelease(v4);
    a1[4] = 0;
    v5 = a1[1];
    v6 = (unsigned int *)(v5 + 584);
    do
    {
      v7 = __ldaxr(v6);
      v8 = --v7 == 0;
    }
    while (__stlxr(v7, v6));
  }
  else
  {
    priority = query_priority((_QWORD *)a1[1]);
    if (*(_QWORD *)(*a1 + 8 * (priority + 13) + 1008))
    {
      si_enqueue_work_with_qos(*(_QWORD *)(*a1 + 8 * (priority + 13) + 1008), 8 * priority + 9, (uint64_t)queryGo, (uint64_t)a1);
      return;
    }
    v10 = a1[1];
    if ((*(_BYTE *)(v10 + 202) & 4) == 0)
      si_querypipe_remove_process(a1[2], v10, 0, 1);
    v11 = (const void *)a1[4];
    if (v11)
      CFRelease(v11);
    a1[4] = 0;
    v5 = a1[1];
    v12 = (unsigned int *)(v5 + 584);
    do
    {
      v13 = __ldaxr(v12);
      v8 = --v13 == 0;
    }
    while (__stlxr(v13, v12));
  }
  if (v8)
    si_query_free(v5);
  si_querypipe_release(a1[2]);
  free(a1);
}

_QWORD *___queryGoCracked_block_invoke(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  const char *v5;
  int v7;
  int v8;
  BOOL v9;
  _BOOL4 v10;
  int v11;
  NSObject *v12;
  os_log_type_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  _WORD *node_from_token_data;
  _QWORD v29[2];
  uint64_t (*v30)(uint64_t, uint64_t);
  void *v31;
  _BYTE *v32;
  uint64_t *v33;
  unsigned int *v34;
  void ***v35;
  uint64_t v36;
  BOOL v37;
  uint64_t v38;
  void **v39;
  unsigned int v40;
  _BYTE buf[24];
  char v42;
  uint64_t v43;

  v2 = (_QWORD *)a2;
  v43 = *MEMORY[0x1E0C80C00];
  if (*(_WORD *)(a2 + 40) == 4)
  {
    v3 = *(_QWORD *)(a2 + 16);
    if (v3)
    {
      v4 = *(_QWORD *)(v3 + 32);
      if ((v4 & 0x1008000) == 0x1000000)
      {
        v5 = *(const char **)v3;
        if (*(_QWORD *)v3)
        {
          v7 = strcmp(*(const char **)v3, "*");
          v8 = v7;
          if ((v4 & 0x400) != 0 || !v7 || !strcmp(v5, "kMDItemTextContent"))
          {
            v10 = 0;
            v9 = v8 != 0;
          }
          else if (!strncmp(v5, "_kMDItemOCRContent", 0x12uLL))
          {
            v10 = 0;
            v9 = 1;
          }
          else if (!strcmp(v5, "kMDItemDisplayName") || !strcmp(v5, "kMDItemSubject"))
          {
            v9 = 0;
            v10 = 1;
          }
          else
          {
            v9 = 0;
            v10 = strcmp(v5, "kMDItemTitle") == 0;
          }
          v40 = (v4 >> 26) & 2;
          v39 = 0;
          if (!v8 || v9 || v10)
          {
            v11 = *__error();
            v12 = _SILogForLogForCategory(1);
            v13 = 2 * (dword_1EF19FC90 < 4);
            if (os_log_type_enabled(v12, v13))
            {
              v14 = (uint64_t *)v2[2];
              v15 = *v14;
              v16 = v14[9];
              *(_DWORD *)buf = 136315394;
              *(_QWORD *)&buf[4] = v15;
              *(_WORD *)&buf[12] = 2080;
              *(_QWORD *)&buf[14] = v16;
              _os_log_impl(&dword_1B8270000, v12, v13, "Segmenting %s %s", buf, 0x16u);
            }
            *__error() = v11;
            v38 = *(_QWORD *)(v2[2] + 72);
            *(_QWORD *)buf = 0;
            *(_QWORD *)&buf[8] = buf;
            *(_QWORD *)&buf[16] = 0x2000000000;
            v42 = 0;
            if (!v9)
            {
              v17 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 6648);
              if (v17)
                _CITermUpdateSetFindTokens(v17);
            }
            v18 = *(_QWORD *)(a1 + 40);
            v19 = *(_QWORD *)(v18 + 1392);
            v20 = *(_QWORD *)(v18 + 1384);
            v29[0] = MEMORY[0x1E0C809B0];
            v29[1] = 0x40000000;
            v30 = ___queryGoCracked_block_invoke_328;
            v31 = &unk_1E6E354F0;
            v37 = v9;
            v34 = &v40;
            v35 = &v39;
            v36 = v18;
            v32 = buf;
            v33 = &v38;
            if (v20)
            {
              v21 = *(unsigned int *)(v20 + 8);
              while ((int)v21 >= 1)
              {
                v22 = v21 - 1;
                v23 = ((uint64_t (*)(_QWORD *, _QWORD, uint64_t))v30)(v29, *(_QWORD *)(*(_QWORD *)v20 + 8 * v21 - 8), 1);
                v21 = v22;
                if (!v23)
                  goto LABEL_30;
              }
            }
            if (v19)
            {
              v24 = *(unsigned int *)(v19 + 8);
              do
              {
                if ((int)v24 < 1)
                  break;
                v25 = v24 - 1;
                v26 = ((uint64_t (*)(_QWORD *, _QWORD, _QWORD))v30)(v29, *(_QWORD *)(*(_QWORD *)v19 + 8 * v24 - 8), 0);
                v24 = v25;
              }
              while (v26);
            }
LABEL_30:
            _Block_object_dispose(buf, 8);
            if (v39)
            {
              if (*((_DWORD *)v39 + 6))
              {
                node_from_token_data = query_node_from_token_data((uint64_t)v39, v2);
                if (node_from_token_data != (_WORD *)v2)
                {
                  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
                  v2 = node_from_token_data;
                }
              }
            }
          }
          TokenDataDispose(v39);
        }
      }
    }
  }
  return v2;
}

_QWORD *___queryGoCracked_block_invoke_2(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4)
{
  _QWORD *result;

  result = a2;
  if (a2)
  {
    *a2 = a3;
    a2[1] = a4;
  }
  return result;
}

uint64_t ___queryGoCracked_block_invoke_328(uint64_t a1, uint64_t a2)
{
  _CIFindTokens(a2);
  return 1;
}

_WORD *query_node_from_token_data(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  uint64_t v4;
  _QWORD *tree_apply_block_with_meta;
  uint64_t v6;
  CFMutableDictionaryRef Mutable;
  const __CFSet *v8;
  uint64_t Tokens;
  uint64_t v10;
  char *v11;
  size_t v12;
  uint64_t v13;
  _WORD *v14;
  _QWORD context[3];
  char *v17;
  uint64_t v18;
  _QWORD v19[6];
  uint64_t v20;
  uint64_t v21;
  uint64_t (*v22)(uint64_t);
  void *v23;
  void *v24;
  uint64_t v25;

  v2 = a2;
  v25 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 24))
  {
    v4 = MEMORY[0x1E0C809B0];
    v20 = MEMORY[0x1E0C809B0];
    v21 = 0x40000000;
    v22 = __db_query_tree_apply_block_block_invoke;
    v23 = &unk_1E6E377F8;
    v24 = &__block_literal_global_17_10736;
    tree_apply_block_with_meta = (_QWORD *)db_query_tree_apply_block_with_meta(a2, (uint64_t)&v20, (uint64_t)&__block_literal_global_20_10737);
    free(*(void **)(tree_apply_block_with_meta[2] + 72));
    v6 = tree_apply_block_with_meta[2];
    *(_QWORD *)(v6 + 72) = 0;
    *(_QWORD *)(v6 + 32) = *(_QWORD *)(v6 + 32) & 0xFFFFFFFFFEFF7FCFLL | 0x8000;
    Mutable = CFDictionaryCreateMutable(0, 0, 0, MEMORY[0x1E0C9B3A0]);
    v8 = CFSetCreateMutable(0, 0, 0);
    v19[0] = v4;
    v19[1] = 0x40000000;
    v19[2] = __query_node_from_token_data_block_invoke;
    v19[3] = &__block_descriptor_tmp_335;
    v19[4] = v8;
    v19[5] = Mutable;
    Tokens = TokenDataGetTokens(a1, (uint64_t)v19);
    MEMORY[0x1E0C80A78](Tokens);
    v11 = (char *)context - v10;
    bzero((char *)context - v10, v12);
    bzero(v11, 8 * *(int *)(a1 + 20));
    v17 = v11;
    v18 = 0;
    context[0] = Mutable;
    context[1] = tree_apply_block_with_meta;
    context[2] = a1;
    if (v8)
    {
      CFSetApplyFunction(v8, (CFSetApplierFunction)child_node_applier, context);
      v13 = *(_QWORD *)&v17[8 * (int)v18];
      *(_QWORD *)&v17[8 * (int)v18] = 0;
    }
    else
    {
      v13 = 0;
    }
    v20 = v4;
    v21 = 0x40000000;
    v22 = __db_query_tree_apply_block_block_invoke;
    v23 = &unk_1E6E377F8;
    v24 = &__block_literal_global_143;
    db_query_tree_apply_block_with_meta(tree_apply_block_with_meta, (uint64_t)&v20, 0);
    CFRelease(Mutable);
    CFRelease(v8);
    if (v13)
    {
      v14 = malloc_type_calloc(1uLL, 0x48uLL, 0x10E0040D742DA1DuLL);
      v14[20] = 1;
      *(_QWORD *)v14 = v2;
      *((_QWORD *)v14 + 1) = v13;
      return v14;
    }
  }
  return v2;
}

void __query_node_from_token_data_block_invoke(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  uint64_t v8;
  uint64_t v9;
  __int16 *v10;
  int v11;
  int v12;
  int v13;
  const void *v14;
  void *Value;

  if (a5 >= 1)
  {
    v8 = 0;
    v9 = (unsigned __int16)a5;
    do
    {
      v10 = (__int16 *)(a4 + 4 * v8);
      v11 = *v10;
      v12 = v10[1];
      v13 = v12 | (v11 << 16);
      v14 = (const void *)v13;
      if (!v11)
        CFSetAddValue(*(CFMutableSetRef *)(a1 + 32), (const void *)v13);
      if (v12 + v11 >= a3)
      {
        ++v8;
      }
      else
      {
        Value = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), v14);
        if (!Value)
        {
          Value = CFSetCreateMutable(0, 0, 0);
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 40), v14, Value);
          CFRelease(Value);
        }
        ++v8;
        CFSetAddValue((CFMutableSetRef)Value, (const void *)(*(__int16 *)(a4 + 4 * v8 + 2) | (unint64_t)((uint64_t)*(__int16 *)(a4 + 4 * v8) << 16)));
      }
    }
    while (v8 != v9);
  }
}

_WORD *child_node_applier(unint64_t key, uint64_t a2)
{
  int v3;
  unint64_t v4;
  const __CFSet *Value;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  _QWORD *tree_apply_block_with_meta;
  void *v14;
  _WORD *result;
  uint64_t v16;
  uint64_t v17;
  _QWORD v18[5];

  v3 = key;
  v4 = key >> 16;
  ++*(_DWORD *)(a2 + 32);
  Value = (const __CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)a2, (const void *)key);
  if (Value)
  {
    CFSetApplyFunction(Value, (CFSetApplierFunction)child_node_applier, (void *)a2);
    v6 = *(_QWORD *)(a2 + 24);
    v7 = *(int *)(a2 + 32);
    v8 = *(_QWORD *)(v6 + 8 * v7);
    *(_QWORD *)(v6 + 8 * v7) = 0;
  }
  else
  {
    v8 = 0;
    LODWORD(v7) = *(_DWORD *)(a2 + 32);
  }
  *(_DWORD *)(a2 + 32) = v7 - 1;
  v9 = *(_QWORD **)(a2 + 8);
  v10 = *(_QWORD *)(a2 + 16);
  v11 = *(_QWORD *)(v10 + 8);
  v12 = *(_DWORD *)(v10 + 20);
  v18[0] = MEMORY[0x1E0C809B0];
  v18[1] = 0x40000000;
  v18[2] = __db_query_tree_apply_block_block_invoke;
  v18[3] = &unk_1E6E377F8;
  v18[4] = &__block_literal_global_17_10736;
  tree_apply_block_with_meta = (_QWORD *)db_query_tree_apply_block_with_meta(v9, (uint64_t)v18, (uint64_t)&__block_literal_global_20_10737);
  if ((*(_BYTE *)(*(_QWORD *)(a2 + 16) + 16) & 1) == 0 || (v3 >> 16) + (__int16)v3 != v12)
  {
    result = strndup((const char *)(v11 + (__int16)v4), (__int16)v3);
    *(_QWORD *)(tree_apply_block_with_meta[2] + 72) = result;
    if (!v8)
      goto LABEL_10;
    goto LABEL_9;
  }
  v14 = malloc_type_malloc((__int16)v3 + 2, 0xDE1AB85DuLL);
  *(_QWORD *)(tree_apply_block_with_meta[2] + 72) = v14;
  result = memcpy(v14, (const void *)(v11 + (__int16)v4), (__int16)v3);
  *(_BYTE *)(*(_QWORD *)(tree_apply_block_with_meta[2] + 72) + (__int16)v3) = 42;
  *(_BYTE *)(*(_QWORD *)(tree_apply_block_with_meta[2] + 72) + (__int16)v3 + 1) = 0;
  if (v8)
  {
LABEL_9:
    result = malloc_type_calloc(1uLL, 0x48uLL, 0x10E0040D742DA1DuLL);
    result[20] = 2;
    *(_QWORD *)result = v8;
    *((_QWORD *)result + 1) = tree_apply_block_with_meta;
    tree_apply_block_with_meta = result;
  }
LABEL_10:
  v16 = *(_QWORD *)(a2 + 24);
  v17 = *(int *)(a2 + 32);
  if (*(_QWORD *)(v16 + 8 * v17))
  {
    result = malloc_type_calloc(1uLL, 0x48uLL, 0x10E0040D742DA1DuLL);
    result[20] = 1;
    v16 = *(_QWORD *)(a2 + 24);
    v17 = *(int *)(a2 + 32);
    *(_QWORD *)result = *(_QWORD *)(v16 + 8 * v17);
    *((_QWORD *)result + 1) = tree_apply_block_with_meta;
    tree_apply_block_with_meta = result;
  }
  *(_QWORD *)(v16 + 8 * v17) = tree_apply_block_with_meta;
  return result;
}

CFSetRef __tag_is_excepted_block_invoke()
{
  CFSetRef result;
  __int128 v1;
  const __CFString *v2;
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  v1 = xmmword_1E6E353F0;
  v2 = CFSTR("com.apple.searchd");
  result = CFSetCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)&v1, 3, MEMORY[0x1E0C9B3B0]);
  tag_is_excepted_exceptedIds = (uint64_t)result;
  return result;
}

void *__queryRemapFieldsForStore_block_invoke_6(int a1, _QWORD *a2, _QWORD *a3, _QWORD *a4)
{
  void *v5;
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t (*v10)(uint64_t);
  void *v11;
  void *v12;

  v5 = a2;
  if (a2 && a3 && a4)
  {
    *a2 = a3;
    a2[1] = a4;
  }
  else
  {
    v6 = MEMORY[0x1E0C809B0];
    if (a3)
    {
      v8 = MEMORY[0x1E0C809B0];
      v9 = 0x40000000;
      v10 = __db_query_tree_apply_block_block_invoke;
      v11 = &unk_1E6E377F8;
      v12 = &__block_literal_global_143;
      db_query_tree_apply_block_with_meta(a3, (uint64_t)&v8, 0);
    }
    if (a4)
    {
      v8 = v6;
      v9 = 0x40000000;
      v10 = __db_query_tree_apply_block_block_invoke;
      v11 = &unk_1E6E377F8;
      v12 = &__block_literal_global_143;
      db_query_tree_apply_block_with_meta(a4, (uint64_t)&v8, 0);
    }
    free(v5);
    return 0;
  }
  return v5;
}

_QWORD *createPathNodeForOid(uint64_t a1)
{
  uint64_t v1;
  int v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unsigned int v11;
  unint64_t v12;
  uint64_t v13;
  int Path;
  uint64_t OidScopeNode;
  uint64_t v16;
  int v18;
  unint64_t v19[512];
  unint64_t v20[512];

  v1 = MEMORY[0x1E0C80A78](a1);
  v3 = v2;
  v5 = v4;
  v7 = v6;
  v9 = v8;
  v10 = v1;
  v20[511] = *MEMORY[0x1E0C80C00];
  bzero(v19, 0x1000uLL);
  v18 = 0;
  if (v7)
  {
    SIPersistentIDStoreGetOidPathForOid(*(_QWORD *)(v10 + 1416), v9, (uint64_t)v19, 1, &v18);
    v11 = v18;
    v12 = v19[0];
    if (!v18)
      return db_make_query_node_with_ann("false", 0);
  }
  else
  {
    v13 = *(_QWORD *)(v10 + 6624);
    if (!v13)
      return db_make_query_node_with_ann("false", 0);
    Path = directoryStoreGetPath(v13, v9, (uint64_t)v20);
    v18 = Path;
    if (!Path)
      return db_make_query_node_with_ann("false", 0);
    v19[0] = v9;
    v11 = Path + 1;
    v18 = Path + 1;
    v12 = v9;
    if (Path == -1)
      return db_make_query_node_with_ann("false", 0);
  }
  if (!v12)
    return db_make_query_node_with_ann("false", 0);
  if (v19[v11 - 1] != 2)
  {
    v19[v11++] = 2;
    v18 = v11;
  }
  OidScopeNode = makeOidScopeNode(v19, v11, v5, v3);
  v16 = *(_QWORD *)(OidScopeNode + 16);
  *(_QWORD *)(v16 + 32) |= 0x200000uLL;
  asprintf((char **)(v16 + 72), "%llx", v9);
  return (_QWORD *)OidScopeNode;
}

_QWORD *createPathNodeForPath(uint64_t a1)
{
  uint64_t v1;
  int v2;
  int v3;
  int v4;
  int v5;
  char v6;
  char v7;
  const char *v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  int (*v12)(void);
  _BYTE *v13;
  uint64_t v14;
  uint64_t *v15;
  char *v16;
  char *v17;
  uint64_t OidScopeNode;
  _BYTE v20[4088];
  _QWORD v21[2];

  v1 = MEMORY[0x1E0C80A78](a1);
  v3 = v2;
  v5 = v4;
  v7 = v6;
  v9 = v8;
  v10 = v1;
  v21[1] = *MEMORY[0x1E0C80C00];
  bzero(v20, 0x1000uLL);
  if ((v7 & 1) != 0)
  {
    v11 = *(_QWORD *)(v10 + 1416);
    if (*(_BYTE *)(v11 + 240))
      return db_make_query_node_with_ann("false", 0);
    v12 = *(int (**)(void))(v11 + 64);
    if (!v12)
      return db_make_query_node_with_ann("false", 0);
    v13 = v20;
    v14 = v12();
  }
  else
  {
    v14 = 0;
    if (v9)
    {
      v15 = v21;
      v16 = (char *)v9;
      do
      {
        v17 = strchr(v16, 47);
        if (!v17)
          break;
        v16 = v17 + 1;
        ++v14;
        *v15-- = atoll(v17 + 1);
      }
      while (v14 != 512);
    }
    v13 = &v20[-8 * v14 + 4096];
  }
  if (!v14 || !*(_QWORD *)v13)
    return db_make_query_node_with_ann("false", 0);
  if (*(_QWORD *)&v13[8 * v14 - 8] != 2)
    *(_QWORD *)&v13[8 * v14++] = 2;
  OidScopeNode = makeOidScopeNode(v13, v14, v5, v3);
  *(_QWORD *)(*(_QWORD *)(OidScopeNode + 16) + 72) = strdup(v9);
  return (_QWORD *)OidScopeNode;
}

void print_full_query_tree(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  const char *v7;
  uint64_t v8;
  size_t tree;
  int v10;
  NSObject *v11;
  os_log_type_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  unint64_t v16;
  const __CFAllocator *v17;
  CFIndex v18;
  CFStringRef v19;
  CFStringRef v20;
  int v21;
  NSObject *v22;
  os_log_type_t v23;
  uint64_t v24;
  uint64_t v25;
  const char *v26;
  UInt8 *v29;
  uint8_t buf[4];
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  __int16 v34;
  const char *v35;
  __int16 v36;
  uint64_t v37;
  __int16 v38;
  _DWORD v39[9];

  *(_QWORD *)&v39[7] = *MEMORY[0x1E0C80C00];
  v7 = "Retrieval";
  if (a2)
    v7 = "Ranking";
  v26 = v7;
  if (a2)
    v8 = 18;
  else
    v8 = 17;
  v29 = (UInt8 *)malloc_type_malloc(0x1000uLL, 0x285DF895uLL);
  tree = _db_render_query_tree(a1);
  v10 = *__error();
  v11 = _SILogForLogForCategory(v8);
  v12 = 2 * (gSILogLevels[v8] < 4);
  if (os_log_type_enabled(v11, v12))
  {
    v13 = *(_QWORD *)(a3 + 608);
    v14 = *(_QWORD *)(a3 + 32);
    *(_DWORD *)buf = 134219010;
    v31 = v13;
    v32 = 2080;
    v33 = a5;
    v34 = 2080;
    v35 = v26;
    v36 = 2112;
    v37 = v14;
    v38 = 2112;
    *(_QWORD *)v39 = a4;
    _os_log_impl(&dword_1B8270000, v11, v12, "[POMMES][qid=%llu][%s] <Full %s Tree for query=\"%@\"> clients=%@", buf, 0x34u);
  }
  *__error() = v10;
  if (tree)
  {
    v15 = 0;
    v16 = 0;
    v17 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    do
    {
      if (tree - v16 >= 0x200)
        v18 = 512;
      else
        v18 = tree - v16;
      v19 = CFStringCreateWithBytes(v17, &v29[v16], v18, 0x8000100u, 0);
      if (v19)
      {
        v20 = v19;
        v21 = *__error();
        v22 = _SILogForLogForCategory(v8);
        v23 = 2 * (gSILogLevels[v8] < 4);
        if (os_log_type_enabled(v22, v23))
        {
          v24 = *(_QWORD *)(a3 + 608);
          v25 = *(_QWORD *)(a3 + 32);
          *(_DWORD *)buf = 134219266;
          v31 = v24;
          v32 = 2080;
          v33 = a5;
          v34 = 2080;
          v35 = v26;
          v36 = 2112;
          v37 = v25;
          v38 = 1024;
          v39[0] = v15;
          LOWORD(v39[1]) = 2112;
          *(_QWORD *)((char *)&v39[1] + 2) = v20;
          _os_log_impl(&dword_1B8270000, v22, v23, "[POMMES][qid=%llu][%s] <Full %s Tree for query=\"%@\" seg=%i> %@", buf, 0x3Au);
        }
        *__error() = v21;
        CFRelease(v20);
      }
      v16 += v18;
      ++v15;
    }
    while (tree > v16);
  }
  free(v29);
}

_QWORD *si_query_get_scope_node(uint64_t a1, dispatch_once_t *predicate, const __CFArray *a3)
{
  dispatch_once_t v5;
  _QWORD v6[6];

  if (a3 && (const __CFArray *)predicate[22] != a3)
    return createNodeFromScopes(a1, (uint64_t)predicate, a3);
  v5 = predicate[29];
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 0x40000000;
  v6[2] = __si_query_get_scope_node_block_invoke;
  v6[3] = &__block_descriptor_tmp_144_7584;
  v6[4] = predicate;
  v6[5] = a1;
  if (v5 != -1)
    dispatch_once(predicate + 29, v6);
  return (_QWORD *)predicate[28];
}

uint64_t __si_query_evaluate_move_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t (*v6)(void);
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t (*v13)(void);
  int v14;
  int v15;
  uint64_t v16;
  _BYTE __src[4096];
  uint64_t v18;

  v1 = MEMORY[0x1E0C80A78](a1);
  v3 = v2;
  v18 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(v2 + 16);
  if (!v4)
    return v3;
  v5 = v1;
  LODWORD(v6) = 0;
  v7 = *(_QWORD *)(v4 + 32);
  if ((v7 & 0xC0000) != 0 && (v7 & 0x300000) == 0x100000)
  {
    bzero(__src, 0x1000uLL);
    v8 = *(_QWORD *)(*(_QWORD *)(v5 + 48) + 1416);
    if (!*(_BYTE *)(v8 + 240))
    {
      v6 = *(uint64_t (**)(void))(v8 + 64);
      if (!v6)
        goto LABEL_6;
      v9 = v6();
      v4 = *(_QWORD *)(v3 + 16);
      if (v9)
      {
        v10 = v9;
        *(_DWORD *)(v4 + 160) |= 0x8000u;
        *(_QWORD *)(*(_QWORD *)(v3 + 16) + 288) = malloc_type_realloc(*(void **)(v4 + 288), 8 * v9, 0x100004000313F17uLL);
        memcpy(*(void **)(*(_QWORD *)(v3 + 16) + 72), __src, 8 * v10);
        v4 = *(_QWORD *)(v3 + 16);
        *(_DWORD *)(v4 + 40) = v10;
        *(_QWORD *)(v4 + 32) &= ~0x100000uLL;
        LODWORD(v6) = 1;
        goto LABEL_6;
      }
    }
    LODWORD(v6) = 0;
LABEL_6:
    v7 = *(_QWORD *)(v4 + 32);
  }
  if ((v7 & 0x300000) == 0x200000 && **(_QWORD **)(v4 + 288) == **(_QWORD **)(v5 + 56))
  {
    if ((_DWORD)v6)
    {
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v5 + 32) + 8) + 24) = 1;
    }
    else
    {
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v5 + 40) + 8) + 24) = 1;
      bzero(__src, 0x1000uLL);
      v11 = *(_QWORD *)(*(_QWORD *)(v5 + 48) + 1416);
      if (!*(_BYTE *)(v11 + 240)
        && (v13 = *(uint64_t (**)(void))(v11 + 64)) != 0
        && (v14 = v13(), v4 = *(_QWORD *)(v3 + 16), v14))
      {
        v15 = v14;
        *(_DWORD *)(v4 + 160) |= 0x8000u;
        *(_QWORD *)(*(_QWORD *)(v3 + 16) + 288) = malloc_type_realloc(*(void **)(v4 + 288), 8 * v14, 0x100004000313F17uLL);
        memcpy(*(void **)(*(_QWORD *)(v3 + 16) + 288), __src, 8 * v15);
        v16 = *(_QWORD *)(v3 + 16);
        *(_DWORD *)(v16 + 40) = v15;
        *(_QWORD *)(v16 + 32) &= ~0x100000uLL;
        if (**(_QWORD **)(v16 + 288) == **(_QWORD **)(v5 + 56))
        {
          *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v5 + 32) + 8) + 24) = 1;
          *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v5 + 40) + 8) + 24) = 0;
        }
      }
      else
      {
        *(_QWORD *)(v4 + 32) |= 0x100000uLL;
      }
    }
  }
  return v3;
}

void ProcessPathForScope(__CFArray *a1, const __CFString *a2, const __CFString *cf1)
{
  const __CFString *v3;
  CFIndex Length;
  int CharacterAtIndex;
  CFIndex v8;

  v3 = cf1;
  if (CFEqual(cf1, a2))
    goto LABEL_7;
  if (CFStringHasPrefix(v3, a2))
  {
    Length = CFStringGetLength(a2);
    CharacterAtIndex = CFStringGetCharacterAtIndex(v3, Length);
  }
  else
  {
    if (!CFStringHasPrefix(a2, v3))
      return;
    v8 = CFStringGetLength(v3);
    CharacterAtIndex = CFStringGetCharacterAtIndex(a2, v8);
    v3 = a2;
  }
  if (CharacterAtIndex == 47)
LABEL_7:
    CFArrayAppendValue(a1, v3);
}

_QWORD *__si_query_get_scope_node_block_invoke(uint64_t a1)
{
  _QWORD *result;

  result = createNodeFromScopes(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 32), *(CFArrayRef *)(*(_QWORD *)(a1 + 32) + 176));
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 224) = result;
  return result;
}

_QWORD *createNodeFromScopes(uint64_t a1, uint64_t a2, CFArrayRef theArray)
{
  unint64_t v6;
  CFIndex Count;
  CFIndex v8;
  CFIndex v9;
  uint64_t v10;
  const __CFString *ValueAtIndex;
  CFTypeID v12;
  uint64_t query_node_with_ann;
  CFIndex v14;
  const __CFString *v15;
  uint64_t ORNode;
  uint64_t v17;
  CFIndex i;
  const __CFString *v19;
  _QWORD *v20;
  char buffer[1024];
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (!theArray)
    return 0;
  v6 = *(_QWORD *)(a2 + 200);
  if ((*(_BYTE *)(a1 + 6584) & 0x10) != 0)
  {
    if (CFArrayGetCount(theArray))
    {
      v20 = processScopes((uint64_t *)a1, theArray, 0, 1, (v6 >> 9) & 1, *(_DWORD *)(a2 + 592), *(uint64_t **)(a2 + 600), *(double *)(a2 + 360));
      v10 = (uint64_t)v20;
      if (v20)
        _rewriteQuery(v20, *(double *)(a2 + 360));
      return (_QWORD *)v10;
    }
    return 0;
  }
  if (!*(_QWORD *)(a1 + 6624))
    return 0;
  Count = CFArrayGetCount(theArray);
  if (Count < 1)
    return db_make_query_node_with_ann("false", 0);
  v8 = Count;
  v9 = 0;
  v10 = 0;
  do
  {
    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, v9);
    v12 = CFGetTypeID(ValueAtIndex);
    if (v12 == CFStringGetTypeID())
    {
      bzero(buffer, 0x400uLL);
      if ((CFStringGetCharacterAtIndex(ValueAtIndex, 0) == 47
         || !CFStringGetCString(ValueAtIndex, buffer, 1024, 0x8000100u))
        && GetCPathForUser(ValueAtIndex, buffer))
      {
        if (v10)
          goto LABEL_26;
        query_node_with_ann = (uint64_t)db_make_query_node_with_ann("false", 0);
      }
      else
      {
        query_node_with_ann = addNodeForCPath(*(_QWORD *)(a1 + 1416));
      }
      v10 = query_node_with_ann;
    }
    else
    {
      v14 = CFArrayGetCount((CFArrayRef)ValueAtIndex);
      bzero(buffer, 0x400uLL);
      v15 = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)ValueAtIndex, 0);
      if (GetCPathForUser(v15, buffer))
      {
        ORNode = (uint64_t)db_make_query_node_with_ann("false", 0);
      }
      else
      {
        ORNode = addNodeForCPath(*(_QWORD *)(a1 + 1416));
        if (v14 >= 2)
        {
          v17 = 0;
          for (i = 1; i != v14; ++i)
          {
            v19 = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)ValueAtIndex, i);
            if (!GetCPathForUser(v19, buffer))
              v17 = addNodeForCPath(*(_QWORD *)(a1 + 1416));
          }
          if (v17)
          {
            *(_WORD *)(v17 + 40) ^= 8u;
            ORNode = makeAndNode(ORNode, v17, 1, 1);
          }
        }
      }
      if (v10)
        ORNode = makeORNode(v10, ORNode, 1);
      v10 = ORNode;
    }
LABEL_26:
    ++v9;
  }
  while (v9 != v8);
  if (!v10)
    return db_make_query_node_with_ann("false", 0);
  return (_QWORD *)v10;
}

_QWORD *processScopes(uint64_t *a1, const __CFArray *a2, CFIndex a3, int a4, uint64_t a5, int a6, uint64_t *a7, double a8)
{
  CFIndex Count;
  CFMutableSetRef Mutable;
  CFIndex v12;
  size_t v13;
  size_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  __int128 v19;
  BOOL v20;
  uint64_t *v21;
  CFIndex v22;
  const __CFString *ValueAtIndex;
  CFTypeID v24;
  const __CFString *v25;
  uint64_t v26;
  CFIndex v27;
  __int128 *v28;
  uint64_t v29;
  char *v30;
  int v31;
  NSObject *v32;
  CFIndex v33;
  CFIndex v34;
  CFIndex i;
  const void *v36;
  uint64_t v37;
  CFIndex v38;
  size_t v39;
  uint64_t *v40;
  uint64_t v41;
  uint64_t ScopeNode;
  _QWORD *ORNode;
  _QWORD **v44;
  CFIndex v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  CFIndex v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t *v61;
  CFIndex v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t *v67;
  CFArrayRef v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  CFIndex v74;
  uint64_t v75;
  _QWORD **v76;
  uint64_t v77;
  _QWORD *v78;
  __int128 v80;
  uint64_t v81;
  int v82;
  __int128 *v83;
  CFMutableSetRef v84;
  CFArrayRef v85;
  uint64_t *v86;
  int v87;
  _QWORD **v88;
  CFIndex v89;
  uint64_t *v90;
  CFIndex v91;
  CFArrayRef v92;
  int v93;
  const char *v94;
  __int16 v95;
  int v96;
  __int16 v97;
  const __CFString *v98;
  __int16 v99;
  __int128 *v100;
  __int16 v101;
  uint64_t v102;
  _QWORD v103[130];

  v90 = a7;
  v91 = a3;
  v87 = a6;
  v82 = a4;
  v86 = a1;
  v103[128] = *MEMORY[0x1E0C80C00];
  v85 = a2;
  if (a2)
    Count = CFArrayGetCount(a2);
  else
    Count = 0;
  Mutable = CFSetCreateMutable((CFAllocatorRef)kCIQueryZoneAllocator, 0, 0);
  v12 = v91;
  v13 = Count - v91;
  MEMORY[0x1E0C80A78](Mutable);
  v83 = &v80 - 64 * (Count - v91);
  bzero(v83, v14);
  v13 *= 8;
  MEMORY[0x1E0C80A78](v15);
  v16 = (char *)&v80 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v16, v13);
  MEMORY[0x1E0C80A78](v17);
  bzero(v16, v13);
  MEMORY[0x1E0C80A78](v18);
  v88 = (_QWORD **)v16;
  bzero(v16, v13);
  v20 = Count <= v12;
  v81 = Count - v12;
  v84 = Mutable;
  v89 = Count;
  v21 = v86;
  if (v20)
  {
LABEL_20:
    v38 = CFSetGetCount(Mutable);
    v83 = &v80;
    MEMORY[0x1E0C80A78](v38);
    v40 = (uint64_t *)((char *)&v80 - ((v39 + 15) & 0xFFFFFFFFFFFFFFF0));
    bzero(v40, v39);
    if (v38)
      CFSetGetValues(Mutable, (const void **)v40);
    v41 = *(uint64_t *)&v16[8 * v91];
    if (*(double *)&v41 == 0.0)
      ScopeNode = _makeScopeNode(v41, a5, 0);
    else
      ScopeNode = makeScopeNode(*(double *)&v41, v41, a5, 0);
    ORNode = (_QWORD *)ScopeNode;
    v44 = v88;
    v86 = v40;
    if (v38 >= 1)
    {
      v45 = v38;
      do
      {
        v46 = *(uint64_t *)&v16[8 * v91];
        v48 = *v40++;
        v47 = v48;
        if (*(double *)&v46 == 0.0)
          v49 = _makeScopeNode(v46, a5, v47);
        else
          v49 = makeScopeNode(*(double *)&v46, v46, a5, v47);
        ORNode = (_QWORD *)makeORNode((uint64_t)ORNode, v49, 1);
        --v45;
      }
      while (v45);
    }
    v50 = v87;
    v85 = (CFArrayRef)v87;
    if (v87 >= 1)
    {
      v51 = v90;
      do
      {
        v52 = *(uint64_t *)&v16[8 * v91];
        v54 = *v51++;
        v53 = v54;
        if (*(double *)&v52 == 0.0)
          v55 = _makeScopeNode(v52, a5, v53);
        else
          v55 = makeScopeNode(*(double *)&v52, v52, a5, v53);
        ORNode = (_QWORD *)makeORNode((uint64_t)ORNode, v55, 1);
        --v50;
      }
      while (v50);
    }
    v56 = (uint64_t)v44[v91];
    if (v56)
      ORNode = (_QWORD *)makeAndNode((uint64_t)ORNode, v56, 1, 1);
    v57 = v91 + 1;
    if (v91 + 1 < Count)
    {
      do
      {
        v58 = *(uint64_t *)&v16[8 * v57];
        if (*(double *)&v58 == 0.0)
          v59 = _makeScopeNode(v58, a5, 0);
        else
          v59 = makeScopeNode(*(double *)&v58, v58, a5, 0);
        v60 = v59;
        v61 = v86;
        v62 = v38;
        if (v38 >= 1)
        {
          do
          {
            v63 = *(uint64_t *)&v16[8 * v57];
            v65 = *v61++;
            v64 = v65;
            if (*(double *)&v63 == 0.0)
              v66 = _makeScopeNode(v63, a5, v64);
            else
              v66 = makeScopeNode(*(double *)&v63, v63, a5, v64);
            v60 = makeORNode(v60, v66, 1);
            --v62;
          }
          while (v62);
        }
        v67 = v90;
        v68 = v85;
        if (v87 >= 1)
        {
          do
          {
            v69 = *(uint64_t *)&v16[8 * v57];
            v71 = *v67++;
            v70 = v71;
            if (*(double *)&v69 == 0.0)
              v72 = _makeScopeNode(v69, a5, v70);
            else
              v72 = makeScopeNode(*(double *)&v69, v69, a5, v70);
            v60 = makeORNode(v60, v72, 1);
            v68 = (CFArrayRef)((char *)v68 - 1);
          }
          while (v68);
        }
        v73 = (uint64_t)v88[v57];
        if (v73)
          v60 = makeAndNode(v60, v73, 1, 1);
        v74 = v89;
        ORNode = (_QWORD *)makeORNode((uint64_t)ORNode, v60, 1);
        ++v57;
      }
      while (v57 != v74);
    }
    _rewriteQuery(ORNode, a8);
    CFRelease(v84);
  }
  else
  {
    *(_QWORD *)&v19 = 136316162;
    v80 = v19;
    v22 = v91;
    while (1)
    {
      bzero(v103, 0x400uLL);
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v85, v22);
      v24 = CFGetTypeID(ValueAtIndex);
      if (v24 == CFArrayGetTypeID())
      {
        if ((v82 & 1) == 0)
          goto LABEL_58;
        v25 = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)ValueAtIndex, 0);
        v26 = processScopes(v21, ValueAtIndex, 1, 0, a5, v87, v90, a8);
        v27 = v22 - v91;
        v88[v22 - v91] = (_QWORD *)v26;
        ValueAtIndex = v25;
      }
      else
      {
        v27 = v22 - v91;
      }
      LOBYTE(v103[0]) = 0;
      CFStringGetFileSystemRepresentation(ValueAtIndex, (char *)v103, 1024);
      v28 = &v83[64 * v27];
      *(_QWORD *)&v16[8 * v27] = v28;
      *(_BYTE *)v28 = 0;
      v92 = 0;
      v29 = v21[177];
      v30 = &v16[8 * v27];
      if (!(*(unsigned int (**)(void))(v29 + 144))())
        break;
      v31 = *__error();
      v32 = _SILogForLogForCategory(6);
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      {
        v37 = *(_QWORD *)v30;
        v93 = v80;
        v94 = "processScopes";
        v95 = 1024;
        v96 = 6377;
        v97 = 2112;
        v98 = ValueAtIndex;
        v99 = 2080;
        v100 = v28;
        v101 = 2048;
        v102 = v37;
        _os_log_error_impl(&dword_1B8270000, v32, OS_LOG_TYPE_ERROR, "%s:%d: scopePath: %@ / %s %f", (uint8_t *)&v93, 0x30u);
      }
      *__error() = v31;
      Mutable = v84;
      Count = v89;
      v21 = v86;
      if (v90 && v92)
      {
        v33 = CFArrayGetCount(v92);
        if (v33 >= 1)
        {
          v34 = v33;
          for (i = 0; i != v34; ++i)
          {
            v36 = CFArrayGetValueAtIndex(v92, i);
            CFSetAddValue(Mutable, v36);
          }
        }
        CFRelease(v92);
      }
      if (++v22 == Count)
        goto LABEL_20;
    }
    Mutable = v84;
LABEL_58:
    v75 = v81;
    v76 = v88;
    if (v81 >= 1)
    {
      v77 = MEMORY[0x1E0C809B0];
      do
      {
        v78 = *v76;
        if (*v76)
        {
          v103[0] = v77;
          v103[1] = 0x40000000;
          v103[2] = __db_query_tree_apply_block_block_invoke;
          v103[3] = &unk_1E6E377F8;
          v103[4] = &__block_literal_global_143;
          db_query_tree_apply_block_with_meta(v78, (uint64_t)v103, 0);
        }
        ++v76;
        --v75;
      }
      while (v75);
    }
    CFRelease(Mutable);
    return 0;
  }
  return ORNode;
}

uint64_t GetCPathForUser(const __CFString *a1, char *a2)
{
  stat v4;

  if (!CFStringGetFileSystemRepresentation(a1, a2, 1024))
    return 0xFFFFFFFFLL;
  memset(&v4, 0, sizeof(v4));
  if (stat(a2, &v4) == -1)
    return *__error();
  else
    return 0;
}

uint64_t makeScopeNode(double a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v7;
  _QWORD *i;
  _QWORD *query_node_with_ann;
  _QWORD *v10;
  uint64_t tree_apply_block_with_meta;
  char **v13;
  _QWORD v15[5];
  uint64_t v16;
  uint64_t v17;
  uint64_t (*v18)(uint64_t);
  void *v19;
  _QWORD *v20;

  v7 = MEMORY[0x1E0C809B0];
  for (i = (_QWORD *)makeScopeNode_prototypeNode; !makeScopeNode_prototypeNode; i = (_QWORD *)makeScopeNode_prototypeNode)
  {
    query_node_with_ann = db_make_query_node_with_ann("_kMDItemTimeMachinePath = \"stuff\" && _kTimeMachineOldestSnapshot<=0 && _kTimeMachineNewestSnapshot>=0))", 0);
    *(_QWORD *)(*(_QWORD *)(*query_node_with_ann + 16) + 32) |= 0x40200uLL;
    v10 = (_QWORD *)query_node_with_ann[1];
    *(_QWORD *)(*(_QWORD *)(*v10 + 16) + 32) |= 0x10000uLL;
    *(_QWORD *)(*(_QWORD *)(v10[1] + 16) + 32) |= 0x10000uLL;
    while (!__ldaxr((unint64_t *)&makeScopeNode_prototypeNode))
    {
      if (!__stlxr((unint64_t)query_node_with_ann, (unint64_t *)&makeScopeNode_prototypeNode))
      {
        i = (_QWORD *)makeScopeNode_prototypeNode;
        goto LABEL_7;
      }
    }
    __clrex();
    v16 = v7;
    v17 = 0x40000000;
    v18 = __db_query_tree_apply_block_block_invoke;
    v19 = &unk_1E6E377F8;
    v20 = &__block_literal_global_143;
    db_query_tree_apply_block_with_meta(query_node_with_ann, (uint64_t)&v16, 0);
  }
LABEL_7:
  v16 = v7;
  v17 = 0x40000000;
  v18 = __db_query_tree_apply_block_block_invoke;
  v19 = &unk_1E6E377F8;
  v20 = &__block_literal_global_17_10736;
  tree_apply_block_with_meta = db_query_tree_apply_block_with_meta(i, (uint64_t)&v16, (uint64_t)&__block_literal_global_20_10737);
  free(*(void **)(*(_QWORD *)(*(_QWORD *)tree_apply_block_with_meta + 16) + 72));
  v13 = (char **)(*(_QWORD *)(*(_QWORD *)tree_apply_block_with_meta + 16) + 72);
  if (a3)
    asprintf(v13, "%s");
  else
    asprintf(v13, "%s*");
  if (a4)
  {
    v15[0] = v7;
    v15[1] = 0x40000000;
    v15[2] = __makeScopeNode_block_invoke;
    v15[3] = &__block_descriptor_tmp_518;
    v15[4] = a4;
    v16 = v7;
    v17 = 0x40000000;
    v18 = __db_query_tree_apply_block_block_invoke;
    v19 = &unk_1E6E377F8;
    v20 = v15;
    db_query_tree_apply_block_with_meta((_QWORD *)tree_apply_block_with_meta, (uint64_t)&v16, 0);
  }
  free(*(void **)(*(_QWORD *)(**(_QWORD **)(tree_apply_block_with_meta + 8) + 16) + 72));
  asprintf((char **)(*(_QWORD *)(**(_QWORD **)(tree_apply_block_with_meta + 8) + 16) + 72), "%f", a1);
  free(*(void **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(tree_apply_block_with_meta + 8) + 8) + 16) + 72));
  asprintf((char **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(tree_apply_block_with_meta + 8) + 8) + 16) + 72), "%f", a1);
  return tree_apply_block_with_meta;
}

uint64_t _makeScopeNode(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v6;
  _QWORD *v7;
  uint64_t (*v8)(uint64_t);
  void *i;
  uint64_t v10;
  uint64_t (*v11)(uint64_t);
  void *v12;
  uint64_t v13;
  _QWORD *query_node_with_ann;
  uint64_t tree_apply_block_with_meta;
  uint64_t v17;
  char **v18;
  uint64_t v20;
  uint64_t v21;
  uint64_t (*v22)(uint64_t);
  void *v23;
  void *v24;

  v6 = MEMORY[0x1E0C809B0];
  v7 = (_QWORD *)_makeScopeNode_prototypeNode;
  v8 = __db_query_tree_apply_block_block_invoke;
  for (i = &unk_1E6E377F8; !_makeScopeNode_prototypeNode; a1 = v10)
  {
    v10 = a1;
    v11 = v8;
    v12 = i;
    v13 = v6;
    query_node_with_ann = db_make_query_node_with_ann("_kMDItemTimeMachinePath = \"stuff\"", 0);
    v6 = v13;
    i = v12;
    *(_QWORD *)(query_node_with_ann[2] + 32) |= 0x40200uLL;
    v8 = v11;
    while (!__ldaxr(&_makeScopeNode_prototypeNode))
    {
      if (!__stlxr((unint64_t)query_node_with_ann, &_makeScopeNode_prototypeNode))
      {
        v7 = (_QWORD *)_makeScopeNode_prototypeNode;
        goto LABEL_7;
      }
    }
    __clrex();
    v20 = v13;
    v21 = 0x40000000;
    v22 = v11;
    v23 = v12;
    v24 = &__block_literal_global_143;
    db_query_tree_apply_block_with_meta(query_node_with_ann, (uint64_t)&v20, 0);
    v6 = v13;
    i = v12;
    v8 = v11;
    v7 = (_QWORD *)_makeScopeNode_prototypeNode;
  }
LABEL_7:
  v20 = v6;
  v21 = 0x40000000;
  v22 = v8;
  v23 = i;
  v24 = &__block_literal_global_17_10736;
  tree_apply_block_with_meta = db_query_tree_apply_block_with_meta(v7, (uint64_t)&v20, (uint64_t)&__block_literal_global_20_10737);
  v17 = tree_apply_block_with_meta;
  if (a3)
  {
    free(**(void ***)(tree_apply_block_with_meta + 16));
    asprintf(*(char ***)(v17 + 16), "_kMDItemTimeMachinePath%lld", a3);
  }
  free(*(void **)(*(_QWORD *)(v17 + 16) + 72));
  v18 = (char **)(*(_QWORD *)(v17 + 16) + 72);
  if (a2)
    asprintf(v18, "%s");
  else
    asprintf(v18, "%s*");
  return v17;
}

uint64_t __makeScopeNode_block_invoke(uint64_t a1, uint64_t a2)
{
  char **v4;
  char *v5;

  v4 = *(char ***)(a2 + 16);
  if (v4)
  {
    v5 = *v4;
    if (*v4)
    {
      asprintf(v4, "%s%lld", *v4, *(_QWORD *)(a1 + 32));
      free(v5);
    }
  }
  return a2;
}

uint64_t __preIterateQueryForIndex_block_invoke_124(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  unsigned int v11;
  uint64_t v12;
  unint64_t v13;
  size_t v14;
  const char **v15;
  malloc_zone_t **v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const char *v23;
  size_t v24;
  _BYTE *v25;
  char v26;
  uint64_t v27;
  char v28;
  uint64_t v29;
  char v30;
  char v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  char *v37;
  int id_for_field_locked;
  int v39;
  char *v40;
  int v41;
  int v42;
  uint64_t v43;
  uint64_t *v44;
  uint64_t v45;
  int v46;
  NSObject *v47;
  os_log_type_t v48;
  char *v49;
  uint64_t v50;
  int v51;
  uint64_t v52;
  unint64_t v53;
  const void *v54;
  const __CFString *v55;
  CFAbsoluteTime *v56;
  double v57;
  uint64_t v58;
  double v59;
  uint64_t v60;
  const __CFString *v61;
  uint64_t *v62;
  uint64_t v63;
  const __CFString *v64;
  _QWORD *NodeForOidPath;
  _QWORD *v66;
  uint64_t v67;
  uint64_t v68;
  CFStringRef String;
  const __CFString *v70;
  CFAbsoluteTime Current;
  uint64_t v72;
  double v73;
  uint64_t v74;
  unsigned int v75;
  int v76;
  uint64_t v77;
  const __CFString *v78;
  const __CFString *v79;
  int v80;
  int v81;
  unsigned int v82;
  __int16 v83;
  unsigned int v84;
  uint64_t v85;
  uint64_t v86;
  int v87;
  uint64_t v88;
  char *v89;
  int v90;
  char *v91;
  _QWORD *v92;
  uint64_t v93;
  uint64_t v94;
  int v95;
  CFNumberRef v96;
  CFNumberRef v97;
  char *NodeForRange;
  _QWORD *v99;
  uint64_t v100;
  uint64_t v101;
  char *v102;
  uint64_t v103;
  uint64_t v104;
  int *v105;
  _QWORD *v106;
  uint64_t v107;
  uint64_t v108;
  void *matched;
  size_t v110;
  _QWORD *tree_apply_block_with_meta;
  unsigned int *v112;
  unint64_t v113;
  unsigned int v114;
  int v115;
  size_t v116;
  _DWORD *RawLocalizedUniquedField;
  _DWORD *v118;
  char *field_name_for_id_locked;
  char *NodeForLocalizedFields;
  uint64_t v121;
  _QWORD *v122;
  uint64_t v123;
  uint64_t v124;
  int v125;
  NSObject *v126;
  const char *v127;
  unsigned int v128;
  __int16 v129;
  int v130;
  NSObject *v131;
  int v132;
  NSObject *v133;
  int v134;
  NSObject *v135;
  uint64_t v136;
  int v137;
  NSObject *v138;
  int v139;
  NSObject *v140;
  uint64_t v141;
  CFAbsoluteTime v142;
  int v143;
  NSObject *v144;
  uint64_t *v145;
  uint64_t v146;
  uint64_t v147;
  char *v148;
  char *v149;
  const char *v150;
  uint64_t v151;
  int v152;
  NSObject *v153;
  uint64_t v154;
  char *v155;
  char *v156;
  const char *v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  unsigned int *v163;
  uint64_t v164;
  _QWORD *v165;
  unsigned int __nel;
  _QWORD __nel_4[6];
  char v168;
  uint64_t v169;
  uint64_t *v170;
  uint64_t v171;
  char v172;
  _BYTE buf[24];
  double v174;
  void *v175;
  uint64_t v176;

  v2 = a2;
  v3 = a1;
  v176 = *MEMORY[0x1E0C80C00];
  v4 = *(_WORD *)(a2 + 40) & 0xFFF7;
  if (v4 > 0x20)
    goto LABEL_200;
  if (((1 << (*(_WORD *)(a2 + 40) & 0xF7)) & 0x100010006) != 0)
    return v2;
  if (v4 != 4)
  {
LABEL_200:
    v148 = __si_assert_copy_extra_521(*(_DWORD *)(*(_QWORD *)(a1 + 64) + 32));
    v149 = v148;
    v150 = "";
    if (v148)
      v150 = v148;
    __message_assert("%s:%u: failed assertion '%s' %s Bad query node; unexpected type %d",
      "SIQueryC.c",
      5652,
      "0",
      v150,
      *(unsigned __int16 *)(v2 + 40));
    free(v149);
    if (__valid_fs(*(_DWORD *)(*(_QWORD *)(v3 + 64) + 32)))
      v151 = 2989;
    else
      v151 = 3072;
    *(_DWORD *)v151 = -559038737;
    abort();
  }
  if (dword_1EF19FC90 >= 5)
  {
    v125 = *__error();
    v126 = _SILogForLogForCategory(1);
    if (os_log_type_enabled(v126, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1B8270000, v126, OS_LOG_TYPE_DEFAULT, "Factor.", buf, 2u);
    }
    *__error() = v125;
  }
  v6 = *(uint64_t **)(v3 + 48);
  v7 = *v6;
  if (**(_QWORD **)(v3 + 40) + 1 >= (unint64_t)*v6)
  {
    *v6 = 2 * v7;
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 32) + 8) + 24) = malloc_type_realloc(*(void **)(*(_QWORD *)(*(_QWORD *)(v3 + 32) + 8)+ 24), 16 * v7, 0x2004093837F09uLL);
  }
  v8 = *(_QWORD *)(v2 + 16);
  if ((*(_BYTE *)(v8 + 33) & 8) != 0)
    goto LABEL_12;
  if (dword_1EF19FC90 >= 5)
  {
    v130 = *__error();
    v131 = _SILogForLogForCategory(1);
    if (os_log_type_enabled(v131, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1B8270000, v131, OS_LOG_TYPE_DEFAULT, "Metadata or Content.", buf, 2u);
    }
    *__error() = v130;
    v8 = *(_QWORD *)(v2 + 16);
  }
  if (!*(_BYTE *)(v3 + 88) && expensiveNodeCheck(v8))
  {
LABEL_12:
    **(_BYTE **)(v3 + 56) = 1;
    return v2;
  }
  v9 = *(_QWORD *)(v8 + 32);
  if ((v9 & 0x6000000) != 0)
    **(_BYTE **)(v3 + 56) = 1;
  v10 = *(_DWORD *)(v8 + 24);
  if ((v10 - 11) < 2)
  {
    v37 = *(char **)v8;
    if (dword_1EF19FC90 >= 5)
    {
      v132 = *__error();
      v133 = _SILogForLogForCategory(1);
      if (os_log_type_enabled(v133, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1B8270000, v133, OS_LOG_TYPE_DEFAULT, "Range query.", buf, 2u);
      }
      *__error() = v132;
      v8 = *(_QWORD *)(v2 + 16);
    }
    if (*(_DWORD *)(v8 + 40) != 2)
      return v2;
    if (**(_BYTE **)v8 == 42 && !*(_BYTE *)(*(_QWORD *)v8 + 1))
    {
      v39 = 1;
    }
    else
    {
      id_for_field_locked = db_get_id_for_field_locked(*(int **)(*(_QWORD *)(v3 + 64) + 1184), v37);
      v8 = *(_QWORD *)(v2 + 16);
      if (id_for_field_locked == -2)
      {
        if (*(float *)(v8 + 52) == 0.0 && *(float *)(v8 + 56) == 0.0)
        {
LABEL_67:
          v42 = *(_DWORD *)(v8 + 24);
LABEL_105:
          v82 = v42 - 5;
          if (v82 > 7)
            v83 = 16;
          else
            v83 = word_1B8632250[v82];
          *(_WORD *)(v2 + 40) = v83;
          return v2;
        }
        v39 = -2;
      }
      else
      {
        v39 = id_for_field_locked;
      }
    }
    if ((*(_BYTE *)(v8 + 34) & 1) != 0)
    {
      v56 = *(CFAbsoluteTime **)(v8 + 272);
      if (!v56)
      {
        *(_QWORD *)(*(_QWORD *)(v2 + 16) + 272) = malloc_type_calloc(1uLL, 8 * *(int *)(v8 + 40), 0x100004000313F17uLL);
        *(_QWORD *)buf = 0;
        v57 = strtod(**(const char ***)(*(_QWORD *)(v2 + 16) + 168), (char **)buf);
        v58 = *(_QWORD *)(v2 + 16);
        **(double **)(v58 + 272) = v57;
        v59 = strtod(*(const char **)(*(_QWORD *)(v58 + 168) + 8), (char **)buf);
        v60 = *(_QWORD *)(v2 + 16);
        *(double *)(*(_QWORD *)(v60 + 272) + 8) = v59;
        v56 = *(CFAbsoluteTime **)(v60 + 272);
      }
      v54 = CFDateCreate((CFAllocatorRef)kCIQueryZoneAllocator, *v56);
      v55 = (const __CFString *)CFDateCreate((CFAllocatorRef)kCIQueryZoneAllocator, *(CFAbsoluteTime *)(*(_QWORD *)(*(_QWORD *)(v2 + 16) + 272) + 8));
    }
    else
    {
      v54 = copyName(**(const char ***)(v8 + 168));
      v55 = copyName(*(const char **)(*(_QWORD *)(*(_QWORD *)(v2 + 16) + 168) + 8));
    }
    v61 = v55;
    if (dword_1EF19FC90 >= 5)
    {
      v136 = v3;
      v137 = *__error();
      v138 = _SILogForLogForCategory(1);
      if (os_log_type_enabled(v138, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412802;
        *(_QWORD *)&buf[4] = v54;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = v37;
        *(_WORD *)&buf[22] = 2112;
        v174 = *(double *)&v61;
        _os_log_impl(&dword_1B8270000, v138, OS_LOG_TYPE_DEFAULT, "Range query: %@ < %s < %@", buf, 0x20u);
      }
      *__error() = v137;
      v3 = v136;
    }
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 32) + 8) + 24) + 8 * **(_QWORD **)(v3 + 40)) = ContentIndexQueryNodeForRange(v54, v61, v39, 1, 1);
    v62 = *(uint64_t **)(v3 + 40);
    v63 = *v62;
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 32) + 8) + 24) + 8 * *v62) + 12) = *(_QWORD *)(*(_QWORD *)(v2 + 16) + 52);
    *v62 = v63 + 1;
    CFRelease(v54);
    v64 = v61;
LABEL_175:
    CFRelease(v64);
    return v2;
  }
  if ((v10 - 13) < 2)
  {
    v11 = db_get_id_for_field_locked(*(int **)(*(_QWORD *)(v3 + 64) + 1184), *(char **)v8);
    v12 = *(_QWORD *)(v2 + 16);
    v13 = *(unsigned int *)(v12 + 40);
    v14 = (v13 << 6) | 0x28;
    if (((v13 >> 11) & 0x7FFFFFFFFFFFLL) == 0 && v14 > *MEMORY[0x1E0C85AD8])
      ++sTotal_9538;
    v159 = v3;
    v160 = v2;
    v15 = *(const char ***)(v12 + 168);
    v16 = (malloc_zone_t **)&unk_1EDBEA000;
    v17 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, v14, 0x31F9A007uLL);
    if (!v17)
      _log_fault_for_malloc_failure();
    *(_QWORD *)((char *)v17 + 4) = 0x400000;
    if ((_DWORD)v13)
    {
      v18 = 0;
      v19 = 1;
      *(_DWORD *)v17 = 1;
      v17[4] = v17 + 5;
      if ((v11 & 0x3F80) != 0)
        v19 = 2;
      v20 = 4;
      if (v11 >> 28)
        v20 = 5;
      if ((v11 & 0x1FC000) != 0)
        v19 = 3;
      if (v11 >= 0x200000)
        v19 = v20;
      v164 = v19;
      v21 = v13 << 6;
      while (1)
      {
        v22 = v17[4];
        v23 = *v15;
        v24 = strlen(*v15);
        v25 = malloc_type_zone_malloc(v16[114], v24 + v164 + 4, 0x6085D6BuLL);
        if (!v25)
          _log_fault_for_malloc_failure();
        if ((int)v11 >= 2)
          break;
        memcpy(v25, v23, v24);
        v35 = v11;
LABEL_44:
        v25[v24] = 0;
        v36 = v22 + v18;
        *(_QWORD *)v36 = v25;
        *(_QWORD *)(v36 + 8) = 0;
        *(_DWORD *)(v36 + 16) = 256;
        *(_DWORD *)(v36 + 20) = v35;
        *(_QWORD *)(v36 + 24) = 8;
        *(_OWORD *)(v36 + 32) = 0u;
        *(_OWORD *)(v36 + 48) = 0u;
        ++*((_DWORD *)v17 + 6);
        v18 += 64;
        ++v15;
        if (v21 == v18)
          goto LABEL_68;
      }
      *(_WORD *)v25 = 513;
      v26 = v11 >> 28;
      if (v11 >> 28)
      {
        v27 = 3;
        v28 = (v11 >> 7) | 0x80;
        v25[2] = v11 | 0x80;
        v29 = 4;
        v30 = (v11 >> 21) | 0x80;
        v31 = (v11 >> 14) | 0x80;
        v32 = 5;
        v33 = 6;
        v34 = 7;
      }
      else
      {
        if ((v11 & 0xFE00000) == 0)
        {
          if ((v11 & 0x1FC000) == 0)
          {
            if ((v11 & 0x3F80) == 0)
            {
              v33 = 2;
              v26 = v11;
              v34 = 3;
              goto LABEL_43;
            }
            v32 = 2;
            v30 = v11 | 0x80;
            v33 = 3;
            v26 = (unsigned __int16)(v11 & 0x3F80) >> 7;
            v34 = 4;
LABEL_42:
            v25[v32] = v30;
LABEL_43:
            v25[v33] = v26;
            memcpy(&v25[v34], v23, v24);
            v24 += v34;
            v35 = -1;
            v16 = (malloc_zone_t **)&unk_1EDBEA000;
            goto LABEL_44;
          }
          v29 = 2;
          v30 = (v11 >> 7) | 0x80;
          v31 = v11 | 0x80;
          v32 = 3;
          v33 = 4;
          v26 = (v11 & 0x1FC000) >> 14;
          v34 = 5;
LABEL_41:
          v25[v29] = v31;
          goto LABEL_42;
        }
        v27 = 2;
        v31 = (v11 >> 7) | 0x80;
        v28 = v11 | 0x80;
        v29 = 3;
        v32 = 4;
        v30 = (v11 >> 14) | 0x80;
        v33 = 5;
        v26 = (v11 >> 21) & 0x7F;
        v34 = 6;
      }
      v25[v27] = v28;
      goto LABEL_41;
    }
LABEL_68:
    v2 = v160;
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v159 + 32) + 8) + 24) + 8 * **(_QWORD **)(v159 + 40)) = v17;
    v43 = *(_QWORD *)(v159 + 32);
    v44 = *(uint64_t **)(v159 + 40);
LABEL_69:
    v45 = *v44;
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v43 + 8) + 24) + 8 * *v44) + 12) = *(_QWORD *)(*(_QWORD *)(v2 + 16) + 52);
    *v44 = v45 + 1;
    return v2;
  }
  if (v10 != 15)
  {
    if (everythingQuery(v8))
    {
      v46 = *__error();
      v47 = _SILogForLogForCategory(1);
      v48 = 2 * (dword_1EF19FC90 < 4);
      if (os_log_type_enabled(v47, v48))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1B8270000, v47, v48, "Found *=* query", buf, 2u);
      }
      *__error() = v46;
      return v2;
    }
    v49 = *(char **)v8;
    if (**(_BYTE **)v8 == 42 && !v49[1])
    {
      v50 = 1;
    }
    else if ((v9 & 0x400) != 0)
    {
      v50 = 0;
    }
    else
    {
      if ((v9 & 0x40000) != 0)
      {
        NodeForOidPath = ContentIndexQueryNodeForOidPath(*(const void **)(v8 + 288), *(int *)(v8 + 40), (v9 & 0x80000) == 0);
        v66 = *(_QWORD **)(v3 + 40);
        v67 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 32) + 8) + 24);
        v68 = (*v66)++;
        *(_QWORD *)(v67 + 8 * v68) = NodeForOidPath;
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 32) + 8) + 24)
                              + 8 * **(_QWORD **)(v3 + 40)
                              - 8)
                  + 12) = *(_QWORD *)(*(_QWORD *)(v2 + 16) + 52);
        return v2;
      }
      v50 = db_get_id_for_field_locked(*(int **)(*(_QWORD *)(v3 + 64) + 1184), v49);
      if ((_DWORD)v50 == -2)
        goto LABEL_104;
    }
    String = copyQueryString(v2);
    if (!String)
    {
      if (dword_1EF19FC90 >= 5)
      {
        v143 = *__error();
        v144 = _SILogForLogForCategory(1);
        if (os_log_type_enabled(v144, OS_LOG_TYPE_DEFAULT))
        {
          v145 = *(uint64_t **)(v2 + 16);
          v146 = *v145;
          v147 = v145[9];
          *(_DWORD *)buf = 136315394;
          *(_QWORD *)&buf[4] = v146;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = v147;
          _os_log_impl(&dword_1B8270000, v144, OS_LOG_TYPE_DEFAULT, "No string for %s = %s", buf, 0x16u);
        }
        *__error() = v143;
      }
LABEL_104:
      v42 = *(_DWORD *)(*(_QWORD *)(v2 + 16) + 24);
      goto LABEL_105;
    }
    v70 = String;
    Current = CFAbsoluteTimeGetCurrent();
    v72 = *(_QWORD *)(v2 + 16);
    v73 = Current;
    switch(*(_DWORD *)(v72 + 24))
    {
      case 1:
      case 5:
        goto LABEL_96;
      case 2:
      case 6:
        **(_BYTE **)(v3 + 56) = 1;
LABEL_96:
        v74 = *(_QWORD *)(v72 + 32);
        v75 = (v74 >> 4) & 1;
        if ((v74 & 0x800000) != 0)
          v75 = (v74 >> 4) & 1 | ((*(_BYTE *)(v72 + 28) & 0x7F) << 18) | 0x10000;
        if (v50 <= 1)
        {
          if (CFEqual(v70, CFSTR("*")))
          {
            v76 = db_get_id_for_field_locked(*(int **)(*(_QWORD *)(v3 + 64) + 1184), "_kMDItemTextContentIndexExists");
            if (v76 != -2)
            {
              v95 = v76;
              *(_DWORD *)buf = 1;
              v96 = CFNumberCreate((CFAllocatorRef)kCIQueryZoneAllocator, kCFNumberSInt32Type, buf);
              if (v96)
              {
                v97 = v96;
                NodeForRange = ContentIndexQueryNodeForRange(v96, v96, v95, 1, 1);
                v99 = *(_QWORD **)(v3 + 40);
                v100 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 32) + 8) + 24);
                v101 = (*v99)++;
                *(_QWORD *)(v100 + 8 * v101) = NodeForRange;
                *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 32) + 8) + 24)
                                      + 8 * **(_QWORD **)(v3 + 40)
                                      - 8)
                          + 12) = *(_QWORD *)(*(_QWORD *)(v2 + 16) + 52);
                CFRelease(v97);
              }
LABEL_173:
              if (dword_1EF19FC90 >= 5)
              {
                v139 = *__error();
                v140 = _SILogForLogForCategory(1);
                if (os_log_type_enabled(v140, OS_LOG_TYPE_DEFAULT))
                {
                  v141 = **(_QWORD **)(v2 + 16);
                  v142 = CFAbsoluteTimeGetCurrent();
                  *(_DWORD *)buf = 136315650;
                  *(_QWORD *)&buf[4] = v141;
                  *(_WORD *)&buf[12] = 2112;
                  *(_QWORD *)&buf[14] = v70;
                  *(_WORD *)&buf[22] = 2048;
                  v174 = v142 - v73;
                  _os_log_impl(&dword_1B8270000, v140, OS_LOG_TYPE_DEFAULT, "Matched factor %s = %@ in %f seconds", buf, 0x20u);
                }
                *__error() = v139;
              }
              v64 = v70;
              goto LABEL_175;
            }
          }
        }
        v77 = *(_QWORD *)(v3 + 64);
        if ((_DWORD)v50 == *(_DWORD *)(v77 + 2008))
        {
          v78 = v70;
          v79 = v70;
          v80 = v50;
          v81 = 1;
LABEL_121:
          v90 = 1;
LABEL_127:
          v91 = ContentIndexQueryNodeForRange(v78, v79, v80, v81, v90);
          v92 = *(_QWORD **)(v3 + 40);
          v93 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 32) + 8) + 24);
          v94 = (*v92)++;
          *(_QWORD *)(v93 + 8 * v94) = v91;
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 32) + 8) + 24)
                                + 8 * **(_QWORD **)(v3 + 40)
                                - 8)
                    + 12) = *(_QWORD *)(*(_QWORD *)(v2 + 16) + 52);
          goto LABEL_173;
        }
        v84 = (v74 >> 1) & 0x20 | (v74 >> 4) & 2 | (((v74 >> 1) & 1) << 15) & 0xFDFFFFFF | (((v74 >> 15) & 1) << 25) | (v74 >> 1) & 0x4000000 | (v74 >> 11) & 8 | v75;
        v85 = *(_QWORD *)(v2 + 16);
        if (v85 && !(_DWORD)v50 && (v86 = *(_QWORD *)(v85 + 32) & 0x6000000000) != 0)
        {
          if (v86 == 0x4000000000)
            v87 = 4096;
          else
            v87 = 0x2000;
          v169 = 0;
          v170 = &v169;
          if (v86 == 0x6000000000)
            v87 = 12288;
          v84 |= v87;
          v171 = 0x2000000000;
          v172 = 0;
        }
        else
        {
          v169 = 0;
          v170 = &v169;
          v171 = 0x2000000000;
          v172 = 0;
          if ((int)v50 >= 6)
          {
            v88 = *(_QWORD *)(v77 + 1184);
            v89 = *(char **)v85;
            __nel_4[0] = MEMORY[0x1E0C809B0];
            __nel_4[1] = 0x40000000;
            __nel_4[2] = __preIterateQueryForIndex_block_invoke_125;
            __nel_4[3] = &unk_1E6E35290;
            __nel_4[4] = &v169;
            __nel_4[5] = v77;
            v168 = *(_BYTE *)(v3 + 89);
            db_apply_for_field_ids_matching_name_locked(v88, v89, (uint64_t)__nel_4);
            goto LABEL_132;
          }
          if ((_DWORD)v50)
          {
LABEL_132:
            v103 = *(_QWORD *)(v3 + 80);
            if (v103)
              v104 = *(_QWORD *)(v103 + 144);
            else
              v104 = 0;
            v105 = _CIQueryNodeForString(*(_QWORD *)(v3 + 72), v70, v50, v84, v104, (*(_DWORD *)(*(_QWORD *)(v3 + 64) + 6584) >> 19) & 3, *((unsigned __int8 *)v170 + 24), *(_DWORD *)(*(_QWORD *)(v2 + 16) + 60));
            *(_QWORD *)(v105 + 3) = *(_QWORD *)(*(_QWORD *)(v2 + 16) + 52);
            v106 = *(_QWORD **)(v3 + 40);
            v107 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 32) + 8) + 24);
            v108 = (*v106)++;
            *(_QWORD *)(v107 + 8 * v108) = v105;
            if (!(_DWORD)v50 || !v105 || *(int *)(*(_QWORD *)(v3 + 72) + 4) < 84)
              goto LABEL_172;
            if ((*(_BYTE *)(*(_QWORD *)(v2 + 16) + 35) & 6) != 0)
              v105[2] = 3;
            __nel = 0;
            v162 = (uint64_t)v105;
            matched = (void *)ContentIndexMatchLocalizedFields(v105, *(_QWORD *)(*(_QWORD *)(v3 + 64) + 6648), &__nel);
            v110 = __nel;
            qsort_b(matched, __nel, 4uLL, &__block_literal_global_131);
            if ((_DWORD)v110)
            {
              *(_QWORD *)buf = MEMORY[0x1E0C809B0];
              *(_QWORD *)&buf[8] = 0x40000000;
              *(_QWORD *)&buf[16] = __db_query_tree_apply_block_block_invoke;
              v174 = COERCE_DOUBLE(&unk_1E6E377F8);
              v175 = &__block_literal_global_17_10736;
              tree_apply_block_with_meta = (_QWORD *)db_query_tree_apply_block_with_meta((_QWORD *)v2, (uint64_t)buf, (uint64_t)&__block_literal_global_20_10737);
              v112 = (unsigned int *)malloc_type_calloc(4uLL, v110, 0xBCDEAE99uLL);
              v165 = tree_apply_block_with_meta;
              if (!convert_value_to_type(0xBu, tree_apply_block_with_meta[2]))
              {
                v163 = v112;
                v161 = v2;
                v113 = 0;
                v114 = 0;
                do
                {
                  v115 = *((_DWORD *)matched + v113);
                  if (v113 >= (v110 - 1) || (v116 = v113 + 1, v115 != *((_DWORD *)matched + v113 + 1)))
                  {
                    bzero(buf, 0x400uLL);
                    RawLocalizedUniquedField = getRawLocalizedUniquedField(*(_QWORD *)(*(_QWORD *)(v3 + 64) + 1184), v115, buf, 1);
                    if (RawLocalizedUniquedField)
                    {
                      v118 = RawLocalizedUniquedField;
                      if (do_compare(*(_QWORD *)(*(_QWORD *)(v3 + 64) + 1184)))
                      {
                        field_name_for_id_locked = (char *)db_get_field_name_for_id_locked(*(int **)(*(_QWORD *)(v3 + 64) + 1184), v118[1]);
                        if (field_name_for_id_locked)
                        {
                          v163[v114] = db_get_id_for_field_locked(*(int **)(*(_QWORD *)(v3 + 64) + 1184), field_name_for_id_locked) | ((*((_WORD *)v118 + 1) & 0x100) << 23);
                          *((_DWORD *)matched + v114++) = *((_DWORD *)matched + v113);
                        }
                      }
                      if (v118 != (_DWORD *)buf)
                        free(v118);
                    }
                    v116 = v113 + 1;
                  }
                  v113 = v116;
                }
                while (v116 < v110);
                db_free_query_node(tree_apply_block_with_meta);
                if (v114)
                {
                  NodeForLocalizedFields = ContentIndexQueryNodeForLocalizedFields(v162, v163, (char *)matched, v114);
                  if (NodeForLocalizedFields)
                  {
                    v121 = *(_QWORD *)(v161 + 16);
                    if (*(_DWORD *)(v121 + 24) == 5)
                      *((_DWORD *)NodeForLocalizedFields + 2) = 3;
                    *(_QWORD *)(v121 + 32) |= 0x400000uLL;
                    v122 = *(_QWORD **)(v3 + 40);
                    v123 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 32) + 8) + 24);
                    v124 = (*v122)++;
                    *(_QWORD *)(v123 + 8 * v124) = NodeForLocalizedFields;
                  }
                }
                v2 = v161;
                v112 = v163;
                goto LABEL_171;
              }
            }
            else
            {
              v112 = 0;
              v165 = 0;
            }
            db_free_query_node(v165);
LABEL_171:
            free(v112);
            free(matched);
LABEL_172:
            _Block_object_dispose(&v169, 8);
            goto LABEL_173;
          }
        }
        v102 = *(char **)v85;
        if (!strncmp(*(const char **)v85, "_kMDItemOCRContent", 0x12uLL))
        {
          v127 = v102 + 18;
          if (!strncmp(v127, "Title", 5uLL))
          {
            v84 |= 0x8000000u;
          }
          else if (!strncmp(v127, "Level1", 6uLL))
          {
            v84 |= 0x10000000u;
          }
          else if (!strncmp(v127, "Level2", 6uLL))
          {
            v84 |= 0x20000000u;
          }
          else
          {
            if (strncmp(v127, "Level3", 6uLL))
            {
              if (dword_1EF19FC90 >= 5)
              {
                v152 = *__error();
                v153 = _SILogForLogForCategory(1);
                if (os_log_type_enabled(v153, OS_LOG_TYPE_DEFAULT))
                {
                  v154 = **(_QWORD **)(v2 + 16);
                  *(_DWORD *)buf = 136315138;
                  *(_QWORD *)&buf[4] = v154;
                  _os_log_impl(&dword_1B8270000, v153, OS_LOG_TYPE_DEFAULT, "Invalid property name %s", buf, 0xCu);
                }
                *__error() = v152;
                v85 = *(_QWORD *)(v2 + 16);
              }
              v128 = *(_DWORD *)(v85 + 24) - 5;
              if (v128 > 7)
                v129 = 16;
              else
                v129 = word_1B8632250[v128];
              *(_WORD *)(v2 + 40) = v129;
              goto LABEL_172;
            }
            v84 |= 0x40000000u;
          }
        }
        goto LABEL_132;
      case 3:
        v78 = 0;
        v79 = v70;
        v80 = v50;
        v81 = 0;
        goto LABEL_121;
      case 4:
        v78 = v70;
        v79 = 0;
        v80 = v50;
        v81 = 1;
        goto LABEL_126;
      case 7:
        v78 = 0;
        v79 = v70;
        goto LABEL_125;
      case 8:
        v78 = v70;
        v79 = 0;
LABEL_125:
        v80 = v50;
        v81 = 0;
LABEL_126:
        v90 = 0;
        goto LABEL_127;
      case 0xF:
        goto LABEL_173;
      default:
        v155 = __si_assert_copy_extra_521(*(_DWORD *)(*(_QWORD *)(v3 + 64) + 32));
        v156 = v155;
        v157 = "";
        if (v155)
          v157 = v155;
        __message_assert("%s:%u: failed assertion '%s' %s Bad query node; unexpected op %d",
          "SIQueryC.c",
          5632,
          "0",
          v157,
          *(_DWORD *)(*(_QWORD *)(v2 + 16) + 24));
        free(v156);
        if (__valid_fs(*(_DWORD *)(*(_QWORD *)(v3 + 64) + 32)))
          v158 = 2989;
        else
          v158 = 3072;
        *(_DWORD *)v158 = -559038737;
        abort();
    }
  }
  v40 = *(char **)v8;
  if (dword_1EF19FC90 >= 5)
  {
    v134 = *__error();
    v135 = _SILogForLogForCategory(1);
    if (os_log_type_enabled(v135, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1B8270000, v135, OS_LOG_TYPE_DEFAULT, "ANN query.", buf, 2u);
    }
    *__error() = v134;
    v8 = *(_QWORD *)(v2 + 16);
  }
  if (*(_DWORD *)(v8 + 40) == 5)
  {
    if (**(_BYTE **)v8 == 42 && !*(_BYTE *)(*(_QWORD *)v8 + 1)
      || (v41 = db_get_id_for_field_locked(*(int **)(*(_QWORD *)(v3 + 64) + 1184), v40),
          v8 = *(_QWORD *)(v2 + 16),
          v41 != -2)
      || *(float *)(v8 + 52) != 0.0
      || *(float *)(v8 + 56) != 0.0)
    {
      v51 = db_get_id_for_field_locked(*(int **)(*(_QWORD *)(v3 + 64) + 1184), *(char **)v8);
      v52 = *(_QWORD *)(v2 + 16);
      v53 = *(unsigned int *)(v52 + 60);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 32) + 8) + 24) + 8 * **(_QWORD **)(v3 + 40)) = ContentIndexQueryNodeForVector(v51, *(_QWORD *)(v52 + 296), v53 & 3, (v53 >> 2) & 3, v53 >> 25, (v53 >> 4) & 0xFFFFF, BYTE3(v53) & 1, *(float *)(v52 + 64));
      v43 = *(_QWORD *)(v3 + 32);
      v44 = *(uint64_t **)(v3 + 40);
      goto LABEL_69;
    }
    goto LABEL_67;
  }
  return v2;
}

BOOL expensiveNodeCheck(uint64_t a1)
{
  _BYTE *v1;
  const char *v3;

  v1 = *(_BYTE **)(a1 + 72);
  if (!v1 || !*v1)
    return 0;
  if (v1[1] == 42)
    goto LABEL_15;
  if (*v1 != 42)
    return 0;
  if (v1[1])
  {
LABEL_15:
    if (v1[2])
      return 0;
  }
  v3 = *(const char **)a1;
  return !strcmp(*(const char **)a1, "*")
      || !strcmp(v3, "kMDItemAuthors")
      || !strcmp(v3, "kMDItemRecipients")
      || strcmp(v3, "kMDItemSubject") == 0;
}

uint64_t __preIterateQueryForIndex_block_invoke_125(uint64_t a1, int a2)
{
  uint64_t result;

  result = db_get_field_name_for_id_locked(*(int **)(*(_QWORD *)(a1 + 40) + 1184), a2);
  if (result)
  {
    if ((*(unsigned __int8 *)(result - 2) | 4) == 0xF)
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) |= *(_BYTE *)(a1 + 48) & *(_BYTE *)(result - 1);
  }
  return result;
}

uint64_t __preIterateQueryForIndex_block_invoke_128(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  return (*a2 - *a3);
}

unsigned int *__evaluateFuzzyQueryForIndex_block_invoke_136(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  unsigned int v14;
  int v15;
  unsigned int v16;
  uint64_t v17;
  unsigned int *v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  unsigned int *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int v27;
  uint64_t v28;
  int v29;
  unsigned int *v30;
  float v31;
  uint64_t v32;
  unsigned int *v33;
  unsigned int *v34;
  unsigned int *v35;
  uint64_t v36;
  int v37;
  NSObject *v38;
  int v39;
  NSObject *v40;
  char *v42;
  char *v43;
  const char *v44;
  uint64_t v45;
  char *v46;
  char *v47;
  const char *v48;
  uint8_t buf[8];
  uint64_t v50;
  uint64_t v51;

  v51 = *MEMORY[0x1E0C80C00];
  v7 = *(_WORD *)(a2 + 40) & 0xFFF7;
  if (v7 == 2)
  {
    if (dword_1EF19FC90 >= 5)
    {
      v39 = *__error();
      v40 = _SILogForLogForCategory(1);
      if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1B8270000, v40, OS_LOG_TYPE_DEFAULT, "And.", buf, 2u);
      }
      *__error() = v39;
      if (!a3)
        goto LABEL_77;
    }
    else if (!a3)
    {
      goto LABEL_77;
    }
    if (a4)
    {
      v11 = *(_QWORD *)(a2 + 8);
      v12 = *(unsigned __int16 *)(v11 + 40);
      if (v12 == 4 && (v13 = *(_QWORD *)(v11 + 16)) != 0)
        v14 = (*(_DWORD *)(v13 + 24) < 0xFu) & (0x5060u >> *(_DWORD *)(v13 + 24));
      else
        v14 = 0;
      v15 = (v12 >> 3) & 1;
      if (v14 != v15)
      {
        v16 = *(unsigned __int16 *)(*(_QWORD *)a2 + 40);
        if (v16 == 4)
        {
          v17 = *(_QWORD *)(*(_QWORD *)a2 + 16);
          if (v17)
            LODWORD(v17) = (*(_DWORD *)(v17 + 24) < 0xFu) & (0x5060u >> *(_DWORD *)(v17 + 24));
        }
        else
        {
          LODWORD(v17) = 0;
        }
        if ((_DWORD)v17 != ((v16 >> 3) & 1))
        {
          v34 = ContentIndexDocSetNotLazy(a3, *(float *)(a2 + 64));
          v35 = ContentIndexDocSetNotLazy(a4, *(float *)(a2 + 64));
          *(_QWORD *)buf = v34;
          v50 = (uint64_t)v35;
          v18 = ContentIndexDocSetIntersectionLazy(2, (unsigned int **)buf, *(float *)(a2 + 64));
          ContentIndexDocSetDispose(a3);
          ContentIndexDocSetDispose(a4);
          ContentIndexDocSetDispose((uint64_t)v34);
          v36 = (uint64_t)v35;
          goto LABEL_66;
        }
      }
      if (v12 == 4)
      {
        v26 = *(_QWORD *)(v11 + 16);
        if (v26)
          LODWORD(v26) = (*(_DWORD *)(v26 + 24) < 0xFu) & (0x5060u >> *(_DWORD *)(v26 + 24));
      }
      else
      {
        LODWORD(v26) = 0;
      }
      v27 = *(unsigned __int16 *)(*(_QWORD *)a2 + 40);
      if (v27 == 4)
      {
        v28 = *(_QWORD *)(*(_QWORD *)a2 + 16);
        if (v28)
          LODWORD(v28) = (*(_DWORD *)(v28 + 24) < 0xFu) & (0x5060u >> *(_DWORD *)(v28 + 24));
      }
      else
      {
        LODWORD(v28) = 0;
      }
      v29 = (v27 >> 3) & 1;
      if ((_DWORD)v26 == v15)
      {
        if ((_DWORD)v28 == v29)
        {
          *(_QWORD *)buf = a3;
          v50 = a4;
          v30 = ContentIndexDocSetIntersectionLazy(2, (unsigned int **)buf, *(float *)(a2 + 64));
LABEL_65:
          v18 = v30;
          ContentIndexDocSetDispose(a3);
          v36 = a4;
          goto LABEL_66;
        }
        v31 = *(float *)(a2 + 64);
        v32 = a4;
        v33 = (unsigned int *)a3;
      }
      else
      {
        if ((_DWORD)v28 != v29)
        {
          v42 = __si_assert_copy_extra_521(-1);
          v43 = v42;
          v44 = "";
          if (v42)
            v44 = v42;
          __message_assert("%s:%u: failed assertion '%s' %s ", "SIQueryC.c", 5967, "!isNegativeQuery(node->lchild)", v44);
          free(v43);
          if (__valid_fs(-1))
            v45 = 2989;
          else
            v45 = 3072;
          *(_DWORD *)v45 = -559038737;
          abort();
        }
        v31 = *(float *)(a2 + 64);
        v32 = a3;
        v33 = (unsigned int *)a4;
      }
      v30 = ContentIndexDocSetExceptLazy(v32, v33, v31);
      goto LABEL_65;
    }
LABEL_77:
    ContentIndexDocSetDispose(a3);
    ContentIndexDocSetDispose(a4);
    if ((*(_WORD *)(a2 + 40) & 8) != 0)
      return ContentIndexDocSetCreateAllWithPrototype(*(_QWORD *)(a1 + 32), a2);
    else
      return 0;
  }
  if (v7 != 1)
  {
    v46 = __si_assert_copy_extra_521(-1);
    v47 = v46;
    if (v46)
      v48 = v46;
    else
      v48 = "";
    __message_assert("%s:%u: Unexpected code path %s ", "SIQueryC.c", 5992, v48);
    free(v47);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  if (dword_1EF19FC90 >= 5)
  {
    v37 = *__error();
    v38 = _SILogForLogForCategory(1);
    if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1B8270000, v38, OS_LOG_TYPE_DEFAULT, "OR.", buf, 2u);
    }
    *__error() = v37;
    if (!a3)
      goto LABEL_71;
  }
  else if (!a3)
  {
    goto LABEL_71;
  }
  if (!a4)
  {
LABEL_71:
    if (a4)
      return (unsigned int *)a4;
    else
      return (unsigned int *)a3;
  }
  v8 = *(unsigned __int16 *)(*(_QWORD *)a2 + 40);
  if (v8 == 4)
  {
    v9 = *(_QWORD *)(*(_QWORD *)a2 + 16);
    if (v9)
      LODWORD(v9) = (*(_DWORD *)(v9 + 24) < 0xFu) & (0x5060u >> *(_DWORD *)(v9 + 24));
  }
  else
  {
    LODWORD(v9) = 0;
  }
  v18 = (unsigned int *)a3;
  if ((_DWORD)v9 != ((v8 >> 3) & 1))
    v18 = ContentIndexDocSetNotLazy(a3, *(float *)(a2 + 64));
  v19 = *(_QWORD *)(a2 + 8);
  v20 = *(unsigned __int16 *)(v19 + 40);
  if (v20 == 4)
  {
    v21 = *(_QWORD *)(v19 + 16);
    if (v21)
      LODWORD(v21) = (*(_DWORD *)(v21 + 24) < 0xFu) & (0x5060u >> *(_DWORD *)(v21 + 24));
  }
  else
  {
    LODWORD(v21) = 0;
  }
  v22 = (unsigned int *)a4;
  if ((_DWORD)v21 != ((v20 >> 3) & 1))
    v22 = ContentIndexDocSetNotLazy(a4, *(float *)(a2 + 64));
  if (v18 != (unsigned int *)a3)
    ContentIndexDocSetDispose(a3);
  if (v22 != (unsigned int *)a4)
    ContentIndexDocSetDispose(a4);
  if (v18)
  {
    if (v18[12] == 1 && (*(_WORD *)(a2 + 40) & 8) != 0)
    {
      v23 = *(_QWORD *)(*(_QWORD *)a2 + 16);
      if (v23)
      {
        if ((*(_BYTE *)(v23 + 33) & 8) != 0)
        {
          ContentIndexDocSetDispose((uint64_t)v18);
          v18 = 0;
        }
      }
    }
  }
  if (v22)
  {
    if (v22[12] != 1
      || (*(_WORD *)(a2 + 40) & 8) == 0
      || (v24 = *(_QWORD *)(*(_QWORD *)(a2 + 8) + 16)) == 0
      || (*(_BYTE *)(v24 + 33) & 8) == 0)
    {
      if (!v18)
        return v22;
      *(_QWORD *)buf = v18;
      v50 = (uint64_t)v22;
      v25 = ContentIndexDocSetUnionLazy(2, (uint64_t *)buf, *(float *)(a2 + 64));
      ContentIndexDocSetDispose((uint64_t)v18);
      ContentIndexDocSetDispose((uint64_t)v22);
      return (unsigned int *)v25;
    }
    v36 = (uint64_t)v22;
LABEL_66:
    ContentIndexDocSetDispose(v36);
  }
  return v18;
}

uint64_t fsi_create_walk(uint64_t a1)
{
  uint64_t v1;
  unsigned int v2;
  unsigned int v3;
  size_t v4;
  size_t v5;
  __int128 *v6;
  __int128 *v7;
  const char *v8;
  char *v9;
  uint64_t v10;
  char *v11;
  unsigned int v12;
  unsigned int v13;
  int v14;
  char v15;
  unsigned int v16;
  __int128 *v17;
  _QWORD *v18;
  _DWORD *v19;
  _DWORD *v20;
  __int128 v21;
  uint64_t f_bavail;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  __int128 *v27;
  const char *v28;
  int v29;
  char *v30;
  _BYTE *v31;
  uint64_t v32;
  int *v33;
  int v34;
  unsigned int *v35;
  int v36;
  uint64_t v37;
  unint64_t v38;
  char *v39;
  char *v40;
  uint64_t v41;
  unsigned int v42;
  unsigned int v43;
  unsigned int v44;
  size_t v46;
  const void *v47;
  uint64_t v48;
  int v49;
  int v50;
  __int128 v51;
  int v52;
  int v53;
  __int128 v54;
  int v55;
  __int128 v56;
  uint64_t v57;
  char v58[16];
  uint64_t v59;
  __int128 v60;
  __int128 v61;
  int v62;
  statfs v63;
  uint64_t v64;

  v1 = MEMORY[0x1E0C80A78](a1);
  v3 = v2;
  v5 = v4;
  v7 = v6;
  v8 = (const char *)v1;
  v64 = *MEMORY[0x1E0C80C00];
  v9 = (char *)malloc_type_calloc(1uLL, 0x4620uLL, 0x10F0040DF486990uLL);
  v10 = (uint64_t)v9;
  v11 = v9 + 8616;
  do
    v12 = __ldxr(gIteratorCount);
  while (__stxr(v12 + 1, gIteratorCount));
  bzero(v9, 0x4620uLL);
  __strlcpy_chk();
  bzero(&v63, 0x878uLL);
  if (!statfs((const char *)(v10 + 4), &v63))
  {
    v59 = 0;
    *(_OWORD *)v58 = xmmword_1B863127C;
    v62 = 0;
    v61 = 0u;
    v60 = 0u;
    if (!getattrlist(v63.f_mntonname, v58, &v60, 0x24uLL, 0x200u))
    {
      v13 = DWORD1(v61);
      v14 = DWORD1(v60);
      v15 = BYTE8(v60) & BYTE8(v61);
      *(_BYTE *)(v10 + 3408) = BYTE8(v60) & BYTE8(v61) & 1;
      *(_BYTE *)(v10 + 3409) = (v15 & 8) != 0;
      v16 = ((v14 & v13) >> 14) & 1;
      if (!(*(_DWORD *)v63.f_fstypename ^ 0x73666361 | v63.f_fstypename[4]))
        LOBYTE(v16) = 1;
      *(_BYTE *)(v10 + 3410) = v16;
    }
  }
  *(_DWORD *)v10 = 0;
  v56 = xmmword_1B8631264;
  v57 = 0;
  if (v7)
    v17 = v7;
  else
    v17 = &v56;
  if (!v5)
    v5 = fsi_attr_size((uint64_t)v17);
  *(_QWORD *)(v10 + 9688) = malloc_type_malloc(0x1000uLL, 0x2004093837F09uLL);
  v18 = malloc_type_calloc(1uLL, 8uLL, 0x2004093837F09uLL);
  v19 = malloc_type_calloc(1uLL, 0x38uLL, 0x1030040023F4036uLL);
  *v19 = ((((_DWORD)v5 << 8) + 4135) & 0xFFFFF000) - 32;
  *v18 = v19;
  *(_QWORD *)(v10 + 9680) = v18;
  v20 = malloc_type_calloc(1uLL, 0x38uLL, 0x1030040023F4036uLL);
  *v20 = ((((_DWORD)v5 << 8) + 4127) & 0xFFFFF000) - 32;
  *(_QWORD *)(v10 + 9640) = v20;
  *(_DWORD *)(v10 + 9696) = 0;
  *(_DWORD *)(v10 + 9704) = -1;
  v21 = *v17;
  *(_QWORD *)(v10 + 1048) = *((_QWORD *)v17 + 2);
  *(_OWORD *)(v10 + 1032) = v21;
  *(_QWORD *)(v10 + 1056) = v5;
  v53 = 5;
  v54 = xmmword_1B8631F80;
  v55 = 0;
  fsi_attr_mapping_descriptor((uint64_t)v17, (uint64_t)&v53, (char *)(v10 + 1128));
  bzero(&v63, 0x8A8uLL);
  v50 = 5;
  v51 = xmmword_1B8631F90;
  v52 = 0;
  fsi_attr_mapping_descriptor((uint64_t)v17, (uint64_t)&v50, (char *)&v63);
  f_bavail = v63.f_bavail;
  v23 = *(_QWORD *)&v63.f_mntonname[208];
  *(_QWORD *)(v10 + 1096) = v63.f_bavail;
  *(_QWORD *)(v10 + 1080) = v23;
  v24 = *(_QWORD *)&v63.f_mntonname[216];
  v25 = *(_QWORD *)&v63.f_mntonname[224];
  *(_QWORD *)(v10 + 1088) = *(_QWORD *)&v63.f_mntonname[216];
  *(_QWORD *)(v10 + 1112) = v25;
  v26 = *(_QWORD *)&v63.f_mntonname[232];
  *(_QWORD *)(v10 + 1120) = *(_QWORD *)&v63.f_mntonname[232];
  *(_DWORD *)(v10 + 1028) = v3 & 0xFFFFFFF9 | 4;
  *(_DWORD *)(v10 + 9708) = 0;
  *(_DWORD *)(v10 + 9712) = (~v3 & 0x18) == 0;
  if (v7)
    v27 = v7;
  else
    v27 = &v56;
  if ((*((_DWORD *)v27 + 1) & 0x80000000) == 0)
    __assert_rtn("initWalk", "fsi.c", 894, "attrList->commonattr & ATTR_CMN_RETURNED_ATTRS");
  if (!v23)
    __assert_rtn("initWalk", "fsi.c", 895, "iterator->offsetAttrName");
  if (!f_bavail)
    __assert_rtn("initWalk", "fsi.c", 896, "iterator->offsetAttrObjType");
  if (!v24)
    __assert_rtn("initWalk", "fsi.c", 897, "iterator->offsetAttrDevId");
  if (!v25)
    __assert_rtn("initWalk", "fsi.c", 898, "iterator->offsetAttrFileId");
  if (!v26)
    __assert_rtn("initWalk", "fsi.c", 899, "iterator->offsetAttrMountStatus");
  *(_DWORD *)(v10 + 9716) = ((v3 >> 5) & 1) == 0;
  *(_DWORD *)(v10 + 9720) = 0;
  *(_BYTE *)(v10 + 1064) = v3 & 1;
  *v11 = 0;
  *(_QWORD *)(v10 + 3360) = v11;
  *(_QWORD *)(v10 + 3376) = v11;
  bzero(&v60, 0x400uLL);
  if (*v8 == 46)
  {
    v28 = v8;
    do
    {
      if (v28[1] != 47)
        break;
      v29 = *((unsigned __int8 *)v28 + 2);
      v28 += 2;
    }
    while (v29 == 46);
  }
  if ((unint64_t)__strlcpy_chk() > 0x3FF)
  {
    v33 = __error();
    v34 = 63;
LABEL_38:
    *v33 = v34;
LABEL_60:
    fsi_close((char *)v10);
    return 0;
  }
  v30 = strrchr(v11, 47);
  if (!v30 || (v31 = v30, !strcmp(v11, "/")))
  {
    __strlcpy_chk();
    v32 = 0;
    *v11 = 0;
  }
  else
  {
    v32 = v31 - v11;
    __strlcpy_chk();
    if (v31 == v11)
    {
      v11[1] = 0;
      v32 = 1;
    }
    else
    {
      *v31 = 0;
    }
  }
  *(_QWORD *)(v10 + 3352) = v32;
  *(_QWORD *)(v10 + 9736) = 0;
  if (!(*(_QWORD *)(v10 + 1096) | *(_QWORD *)(v10 + 1088) | *(_QWORD *)(v10 + 1112)))
  {
    v33 = __error();
    v34 = 22;
    goto LABEL_38;
  }
  v35 = (unsigned int *)malloc_type_malloc(*(_QWORD *)(v10 + 1056) + 4, 0x7E0B752EuLL);
  if (getattrlist(v8, (void *)(v10 + 1032), v35, v5, 0x208u))
  {
LABEL_35:
    v36 = *__error();
LABEL_36:
    *__error() = v36;
LABEL_59:
    free(v35);
    goto LABEL_60;
  }
  *(_DWORD *)(v10 + 9724) = *(unsigned int *)((char *)v35 + *(_QWORD *)(v10 + 1088));
  *(_DWORD *)(v10 + 9728) = *(unsigned int *)((char *)v35 + *(_QWORD *)(v10 + 1096));
  v37 = *(_QWORD *)(v10 + 1080);
  if (v37)
  {
    v38 = *v35;
    if (v37 + 8 <= v38)
    {
      v39 = (char *)v35 + v37;
      v40 = (char *)v35 + v37 + *(int *)((char *)v35 + v37);
      if (&v40[*(unsigned int *)((char *)v35 + v37 + 4)] <= (char *)v35 + v38 && (!strcmp(v8, "/") || !strcmp(v8, ".")))
      {
        strncpy(v40, v8, 2uLL);
        *((_DWORD *)v39 + 1) = 2;
      }
    }
  }
  if (*(_DWORD *)(v10 + 9708))
  {
    v41 = *(_QWORD *)((char *)v35 + *(_QWORD *)(v10 + 1112));
  }
  else
  {
    bzero(v58, 0x400uLL);
    __strlcpy_chk();
    if (strcmp(v8, ".") && (unint64_t)__strlcat_chk() > 0x3FF)
    {
      v36 = 63;
      goto LABEL_36;
    }
    do
      v42 = __ldxr(&gFDCount);
    while (__stxr(v42 + 1, &gFDCount));
    v43 = open(v58, 32772);
    if (v43 > 0x7FF)
    {
      if ((v43 & 0x80000000) != 0)
      {
        do
          v44 = __ldxr(&gFDCount);
        while (__stxr(v44 - 1, &gFDCount));
        if (v43 == -1)
          goto LABEL_35;
      }
    }
    else
    {
      *(_DWORD *)(v10 + 4 * v43 + 9756) = 957;
      ++*(_DWORD *)(v10 + 9752);
    }
    v41 = (int)v43;
  }
  if (pushStackEntry(v10, v41))
    goto LABEL_59;
  v46 = *(_QWORD *)(v10 + 3368);
  v47 = *(const void **)(v10 + 3376);
  if (*(_QWORD *)(v10 + 9664))
  {
    v48 = *(_QWORD *)(v10 + 9672);
    if (v48)
      v49 = (*(uint64_t (**)(uint64_t, uint64_t))(v48 + 16))(v48, v10);
    else
      v49 = 1;
  }
  else
  {
    v49 = 0;
  }
  addIntoChildList(v10, v35, v46, v47, v49);
  free(v35);
  return v10;
}

void fsi_close(char *a1)
{
  uint64_t v2;
  unsigned int v3;
  int v4;
  char *v5;
  int v6;
  uint64_t *v7;
  uint64_t v8;
  const void *v9;
  unsigned int v10;
  const void *v11;
  const void *v12;
  int i;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  int v17;
  char *v18;
  int v19;

  if (!*(_DWORD *)a1)
  {
    if (!*((_DWORD *)a1 + 2427))
    {
      for (i = *((_DWORD *)a1 + 2424); i; *((_DWORD *)a1 + 2424) = i)
      {
        v14 = *(_QWORD *)(*((_QWORD *)a1 + 1211) + 8 * --i);
        if (!v14)
          break;
        v15 = *(_QWORD *)(v14 + 48);
        if (v15 != -1)
        {
          if ((v15 & 0x80000000) == 0)
          {
            do
              v16 = __ldxr(&gFDCount);
            while (__stxr(v16 - 1, &gFDCount));
            if ((int)v15 <= 2047)
            {
              v17 = *((_DWORD *)a1 + 2438);
              *((_DWORD *)a1 + 2438) = v17 - 1;
              v18 = &a1[4 * (int)v15];
              v19 = *((_DWORD *)v18 + 2439);
              if (v19 < 0 || v17 <= 0)
                __assert_rtn("internalClose", "fsi.c", 1216, "iterator->fdArray[(int)tos->fileReference] >= 0 && iterator->fdCount >= 0");
              if (v19)
                *((_DWORD *)v18 + 2439) = -v19;
            }
          }
          close(v15);
          i = *((_DWORD *)a1 + 2424) - 1;
        }
      }
    }
    free(*((void **)a1 + 1211));
    free(*((void **)a1 + 1206));
    *((_QWORD *)a1 + 1206) = 0;
    v2 = *((unsigned int *)a1 + 2426);
    if ((v2 & 0x80000000) == 0)
    {
      do
        v3 = __ldxr(&gFDCount);
      while (__stxr(v3 - 1, &gFDCount));
      if (v2 <= 0x7FF)
      {
        v4 = *((_DWORD *)a1 + 2438);
        *((_DWORD *)a1 + 2438) = v4 - 1;
        v5 = &a1[4 * v2];
        v6 = *((_DWORD *)v5 + 2439);
        if (v6 < 0 || v4 <= 0)
          __assert_rtn("internalClose", "fsi.c", 1227, "iterator->fdArray[iterator->resumeFd] >= 0 && iterator->fdCount >= 0");
        if (v6)
          *((_DWORD *)v5 + 2439) = -v6;
      }
      close(v2);
    }
    v7 = (uint64_t *)*((_QWORD *)a1 + 1210);
    if (v7)
    {
      SQueueDestroy(*v7);
      free(v7);
    }
    v8 = *((_QWORD *)a1 + 1205);
    if (v8)
      SQueueDestroy(v8);
  }
  free(*((void **)a1 + 430));
  free(*((void **)a1 + 434));
  free(*((void **)a1 + 435));
  if (*((_QWORD *)a1 + 1076))
    fsi_close();
  v9 = (const void *)*((_QWORD *)a1 + 134);
  if (v9)
  {
    CFRelease(v9);
    *((_QWORD *)a1 + 134) = 0;
  }
  do
    v10 = __ldxr(gIteratorCount);
  while (__stxr(v10 - 1, gIteratorCount));
  v11 = (const void *)*((_QWORD *)a1 + 1208);
  if (v11)
    _Block_release(v11);
  v12 = (const void *)*((_QWORD *)a1 + 1209);
  if (v12)
    _Block_release(v12);
  free(a1);
}

unint64_t fsi_attr_size(uint64_t a1)
{
  unint64_t v1;
  unint64_t v2;
  char ***v3;
  char **v4;
  _DWORD *v5;
  unint64_t v6;
  unint64_t v7;
  int v8;
  _DWORD *v9;
  int v10;
  char **v11;

  v1 = 0;
  v2 = 0;
  v3 = attrTable_table;
  v4 = &attrTable_commonattr;
  v5 = (_DWORD *)(a1 + 4);
  v6 = 4;
  do
  {
    if (v4 == &attrTable_dirattr)
      v7 = v6;
    else
      v7 = v2;
    if (v4 == &attrTable_fileattr)
    {
      v1 = v6;
      v6 = v2;
    }
    v8 = *((_DWORD *)v4 + 2);
    if (v8)
    {
      v9 = v4 + 6;
      do
      {
        if ((*v5 & v8) != 0)
          v6 += *((_QWORD *)v9 - 3);
        v10 = *v9;
        v9 += 10;
        v8 = v10;
      }
      while (v10);
    }
    v11 = v3[1];
    ++v3;
    v4 = v11;
    ++v5;
    v2 = v7;
  }
  while (v11);
  if (v6 <= v1)
    return v1;
  else
    return v6;
}

BOOL fsi_attr_mapping_descriptor(uint64_t a1, uint64_t a2, char *a3)
{
  uint64_t v5;
  BOOL *v6;
  char *v7;
  char *v8;
  unint64_t *v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t v12;
  unint64_t v13;
  int v14;
  _DWORD *v15;
  _DWORD *v16;
  unint64_t v17;
  char ***v18;
  char **v19;
  unint64_t v20;
  _BOOL8 result;
  char *v22;
  int v23;
  char **v24;
  int v25;
  BOOL v26;
  unint64_t v27;
  char **v28;
  _QWORD v29[3];
  _QWORD v30[3];

  if (a1)
    v5 = a1;
  else
    v5 = a2;
  bzero(a3, 0x8A8uLL);
  v6 = (BOOL *)(a3 + 56);
  v7 = a3 + 136;
  v8 = a3 + 216;
  v9 = (unint64_t *)(a3 + 296);
  v10 = a3 + 936;
  v11 = a3 + 1576;
  v30[1] = 0;
  v30[2] = 0;
  v30[0] = 0x800000005;
  *((_QWORD *)a3 + 3) = fsi_attr_offset(v5, (uint64_t)v30);
  v29[1] = 0;
  v29[2] = 0;
  v29[0] = 0x2000000000005;
  v12 = fsi_attr_offset(v5, (uint64_t)v29);
  v13 = 0;
  v14 = 0;
  *((_QWORD *)a3 + 4) = v12;
  v15 = (_DWORD *)(v5 + 4);
  v16 = (_DWORD *)(a2 + 4);
  v17 = 4;
  *(int64x2_t *)(a3 + 40) = vdupq_n_s64(4uLL);
  v18 = attrTable_table;
  v19 = &attrTable_commonattr;
  v20 = 4;
  do
  {
    result = v19 != &attrTable_dirattr;
    if (v19 == &attrTable_dirattr)
    {
      v22 = a3 + 4;
      v13 = v20;
    }
    else
    {
      if (v19 != &attrTable_fileattr)
      {
        result = 0;
        goto LABEL_11;
      }
      v22 = a3 + 12;
      v20 = v13;
    }
    *(_DWORD *)v22 = v14;
LABEL_11:
    v23 = *((_DWORD *)v19 + 2);
    if (v23)
    {
      v24 = v19 + 3;
      do
      {
        v25 = *v15 & v23;
        if ((*v16 & v23) != 0)
        {
          v26 = *(v24 - 1) != *v24;
          if (v25)
            v27 = v20;
          else
            v27 = 0;
          *v9++ = v27;
          *v10++ = *((_QWORD *)a3 + 5);
          *v11++ = *(v24 - 1);
          *v6++ = v26;
          *v7++ = *((_DWORD *)v24 + 3);
          *v8++ = *((_DWORD *)v24 + 2);
          *((_QWORD *)a3 + 5) += *(v24 - 1);
          if (v19 == &attrTable_dirattr)
            ++*((_DWORD *)a3 + 2);
          ++v14;
          if (result)
            ++*((_DWORD *)a3 + 4);
        }
        if (v25)
          v20 += (unint64_t)*(v24 - 1);
        v23 = *((_DWORD *)v24 + 6);
        v24 += 5;
      }
      while (v23);
      v17 = *((_QWORD *)a3 + 6);
    }
    if (v20 > v17)
      v17 = v20;
    *((_QWORD *)a3 + 6) = v17;
    v28 = v18[1];
    ++v18;
    v19 = v28;
    ++v15;
    ++v16;
  }
  while (v28);
  *(_DWORD *)a3 = v14;
  return result;
}

uint64_t pushStackEntry(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;

  if (*(int *)(a1 + 9696) < 512)
  {
    v5 = *(uint64_t **)(a1 + 9680);
    v6 = SQueueOpenPushData(*v5, 0x448uLL);
    *(_DWORD *)v6 = 1092;
    bzero((char *)v6 + 4, 0x444uLL);
    v7 = (_QWORD *)*v5;
    v7[6] = *(_QWORD *)(*v5 + 48) + 1092;
    *(_QWORD *)(v7[4] + 24) += 1092;
    v7[1] += 1092;
    *(_QWORD *)((char *)v6 + 52) = a2;
    strcpy((char *)v6 + 68, (const char *)(a1 + 8616));
    *(_QWORD *)((char *)v6 + 12) = (char *)v6 + 4;
    v8 = *(int *)(a1 + 9696);
    *(_QWORD *)(*(_QWORD *)(a1 + 9688) + 8 * v8) = (char *)v6 + 4;
    *(_DWORD *)(a1 + 9696) = v8 + 1;
    result = 0;
    if (*(_QWORD *)(a1 + 1080))
    {
      v9 = *(_QWORD *)(a1 + 3352);
      *(_QWORD *)(a1 + 9736) = v9;
      *(_QWORD *)((char *)v6 + 60) = v9;
    }
  }
  else
  {
    *__error() = 22;
    return 0xFFFFFFFFLL;
  }
  return result;
}

_QWORD *addIntoChildList(uint64_t a1, unsigned int *a2, size_t a3, const void *a4, int a5)
{
  int v9;
  _QWORD *v10;
  _QWORD *result;
  _QWORD *v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  v9 = *(_DWORD *)(a1 + 9696);
  if (v9)
    v10 = *(_QWORD **)(*(_QWORD *)(a1 + 9688) + 8 * (v9 - 1));
  else
    v10 = 0;
  result = SStackPushData(*(uint64_t **)(a1 + 9680), *a2, a2);
  v12 = result;
  if (*(_DWORD *)(a1 + 9712) && !*(_QWORD *)(a1 + 1080))
    result = SStackPushData(*(uint64_t **)(a1 + 9680), a3, a4);
  v10[1] = result;
  if (a5)
  {
    v13 = v10[3];
    v14 = *(_QWORD *)(a1 + 9656);
    if (v13 >= v14)
    {
      v15 = 2 * v14;
      if (!v14)
        v15 = 8;
      *(_QWORD *)(a1 + 9656) = v15;
      result = malloc_type_realloc(*(void **)(a1 + 9648), 8 * v15, 0x80040B8603338uLL);
      *(_QWORD *)(a1 + 9648) = result;
      v13 = v10[3];
    }
    else
    {
      result = *(_QWORD **)(a1 + 9648);
    }
    result[v13] = v12;
    v10[3] = v13 + 1;
  }
  else if (!*v10)
  {
    *v10 = v12;
  }
  return result;
}

uint64_t fsi_attr_offset(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _DWORD *v3;
  char ***v4;
  char **v5;
  _DWORD *v6;
  uint64_t result;
  uint64_t v8;
  int v9;
  _DWORD *v10;
  int v11;
  char **v12;

  v2 = 0;
  v3 = (_DWORD *)(a1 + 4);
  v4 = attrTable_table;
  v5 = &attrTable_commonattr;
  v6 = (_DWORD *)(a2 + 4);
  result = 4;
  do
  {
    if (v5 == &attrTable_dirattr)
      v8 = result;
    else
      v8 = v2;
    if (v5 == &attrTable_fileattr)
      result = v2;
    v9 = *((_DWORD *)v5 + 2);
    if (v9)
    {
      v10 = v5 + 6;
      do
      {
        if ((*v3 & v9) != 0)
        {
          if (v9 == *v6)
            return result;
          result += *((_QWORD *)v10 - 4);
        }
        v11 = *v10;
        v10 += 10;
        v9 = v11;
      }
      while (v11);
    }
    v12 = v4[1];
    ++v4;
    v5 = v12;
    ++v3;
    ++v6;
    v2 = v8;
  }
  while (v12);
  return 0;
}

uint64_t callBlock(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

uint64_t fsi_iterate_f(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  double Current;
  uint64_t v4;
  int v5;
  int v6;
  uint64_t *v7;
  CFAbsoluteTime v8;
  uint64_t v9;
  double v10;
  int v11;
  BOOL v12;
  unsigned int *v14;
  unsigned int v15;
  uint64_t v16;
  unint64_t v17;
  char v18;
  uint64_t v19;
  int v20;
  int v21;
  double v22;
  CFAbsoluteTime v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  char v28;
  int v29;
  uint64_t v30;
  int v31;
  int v32;
  uint64_t *v33;
  const char *v34;
  uint64_t v36;
  unsigned int v37;
  int v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  _QWORD *v43;
  unint64_t Data;
  char *v45;
  _QWORD *v46;
  _QWORD *i;
  uint64_t v48;
  _QWORD *v49;
  int64_t v50;
  int v51;
  const char *v52;
  uint64_t *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t v57;
  uint64_t v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t *v61;
  BOOL v62;
  uint64_t v63;
  uint64_t v64;
  unint64_t v65;
  const char *v66;
  uint64_t v67;
  const char *v68;
  unsigned int v69;
  uint64_t v70;
  int v71;
  unsigned int v72;
  int v73;
  uint64_t v74;
  int v75;
  unsigned int v76;
  int v77;
  int v78;
  int v79;
  char *d_name;
  DIR *v81;
  DIR *v82;
  uint64_t v83;
  int v84;
  unsigned int v85;
  unsigned int v86;
  int v87;
  unsigned int *v88;
  int v89;
  int v90;
  uint64_t v91;
  int v92;
  uint64_t v93;
  int v94;
  const char *v95;
  int v96;
  uint64_t v97;
  uint64_t v98;
  unsigned int *v99;
  int v100;
  _QWORD *v101;
  unint64_t v102;
  _QWORD *v103;
  _BOOL4 v104;
  unsigned int v105;
  uint64_t v106;
  unsigned int v107;
  int v108;
  uint64_t v109;
  int v110;
  dirent *v111;
  int d_type;
  int v113;
  dirent *v114;
  uint64_t v115;
  unsigned int *v116;
  size_t d_namlen;
  char *v118;
  int v119;
  int v120;
  _QWORD *v121;
  unint64_t v122;
  _QWORD *v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  unint64_t v128;
  const char *v129;
  unint64_t v130;
  int v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  unint64_t v135;
  const char *v136;
  unint64_t v137;
  int v138;
  int v139;
  const char *v140;
  uint64_t updated;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  unsigned int v145;
  unsigned int v146;
  int v147;
  int v148;
  unsigned int v149;
  int v150;
  uint64_t v151;
  int v152;
  int v153;
  unsigned int v154;
  int j;
  uint64_t v156;
  uint64_t v157;
  unsigned int v158;
  int v159;
  uint64_t v160;
  int v161;
  __n128 v162;
  uint64_t v163;
  unsigned int v164;
  unsigned int v165;
  unsigned int v166;
  int v167;
  uint64_t v168;
  int v169;
  unsigned int v170;
  int v171;
  uint64_t v172;
  int v173;
  uint64_t v174;
  unsigned int v176;
  uint64_t v177;
  unsigned int v178;
  int v179;
  uint64_t v180;
  int v181;
  unsigned int v182;
  uint64_t *v183;
  unsigned int *v184;
  unsigned int v185;
  void *v186;
  size_t v187;
  uint64_t v188;
  char *v189;
  __int128 v190;
  __int128 v191;
  __int128 v192;
  stat v193;
  dirent *v194;
  dirent v195;
  char v196[1024];
  uint64_t v197;

  *(_QWORD *)&v190 = a2;
  v197 = *MEMORY[0x1E0C80C00];
  v191 = 0u;
  v192 = 0u;
  *(_DWORD *)(a1 + 3404) = 0;
  *((_QWORD *)&v190 + 1) = a1;
  v2 = *(_QWORD *)(a1 + 8608);
  if (v2)
    *(_DWORD *)(v2 + 3404) = 0;
  Current = CFAbsoluteTimeGetCurrent();
  v4 = *((_QWORD *)&v190 + 1);
  v5 = **((_DWORD **)&v190 + 1);
  v189 = (char *)callBlock;
  if (!**((_DWORD **)&v190 + 1))
    goto LABEL_7;
  if (v5 == 1)
  {
    if (*(_BYTE *)(*((_QWORD *)&v190 + 1) + 1064) && !*(_QWORD *)(*((_QWORD *)&v190 + 1) + 1072))
      *(_QWORD *)(*((_QWORD *)&v190 + 1) + 1072) = SIUINT64SetCreate();
    v8 = CFAbsoluteTimeGetCurrent();
    v9 = *((_QWORD *)&v190 + 1);
    v10 = v8;
    while (1)
    {
      v195.d_ino = 0;
      if (searchfs((const char *)(*((_QWORD *)&v190 + 1) + 4), (fssearchblock *)(*((_QWORD *)&v190 + 1) + 3488), &v195.d_ino, 0x8000103u, *(_DWORD *)(v9 + 3424), (searchstate *)(*((_QWORD *)&v190 + 1) + 3592)))
      {
        v11 = *__error();
        v12 = v11 == 35;
        if (v11 != 35 && v11 != 0)
        {
          v9 = *((_QWORD *)&v190 + 1);
          *(_DWORD *)(*((_QWORD *)&v190 + 1) + 3424) &= ~1u;
          if (v11 != 35)
            goto LABEL_397;
          goto LABEL_35;
        }
      }
      else
      {
        v12 = 0;
        v11 = 0;
      }
      v9 = *((_QWORD *)&v190 + 1);
      if (v195.d_ino)
        break;
LABEL_34:
      *(_DWORD *)(v9 + 3424) &= ~1u;
      if (!v12)
      {
LABEL_397:
        LODWORD(v26) = 0;
        v25 = *(_DWORD *)(v9 + 3400);
LABEL_41:
        *(_DWORD *)(v9 + 3404) = v25;
        *(_DWORD *)(v9 + 3400) = 0;
        v4 = *((_QWORD *)&v190 + 1);
        *__error() = v11;
        if (v11)
          v26 = 1;
        else
          v26 = v26;
        goto LABEL_384;
      }
LABEL_35:
      v22 = *(double *)(v9 + 3416);
      v23 = CFAbsoluteTimeGetCurrent();
      v9 = *((_QWORD *)&v190 + 1);
      v24 = *((_QWORD *)&v190 + 1);
      if (v22 < v23 - v10)
      {
        do
        {
          *(_DWORD *)(v24 + 3400) = 1;
          v24 = *(_QWORD *)(v24 + 8608);
        }
        while (v24);
      }
      v25 = *(_DWORD *)(*((_QWORD *)&v190 + 1) + 3400);
      if (v25)
      {
        LODWORD(v26) = 0;
        goto LABEL_41;
      }
    }
    v14 = *(unsigned int **)(*((_QWORD *)&v190 + 1) + 3440);
    v15 = 1;
    while (1)
    {
      v16 = *(_QWORD *)(v9 + 1072);
      *(_BYTE *)(v9 + 1065) = v16 != 0;
      if (v16)
      {
        v17 = *(_QWORD *)((char *)v14 + *(_QWORD *)(v9 + 1112));
        v18 = SIUINT64SetContainsValue(v16, v17);
        v9 = *((_QWORD *)&v190 + 1);
        if ((v18 & 1) != 0)
          goto LABEL_33;
        v19 = *(_QWORD *)(*((_QWORD *)&v190 + 1) + 1072);
      }
      else
      {
        v19 = 0;
        v17 = 0;
      }
      *(_BYTE *)(v9 + 1065) = v19 != 0;
      v20 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, _QWORD, unsigned int *))(v190 + 16))(v190, v9, *((_QWORD *)&v190 + 1) + 3344, *(unsigned int *)(v9 + 3384), v14);
      v9 = *((_QWORD *)&v190 + 1);
      v21 = v20;
      if (*(_BYTE *)(*((_QWORD *)&v190 + 1) + 1065))
      {
        SIValueSet<unsigned long long>::SIValueSetInsert((unint64_t *)(*(_QWORD *)(*((_QWORD *)&v190 + 1) + 1072) + 16), v17);
        v9 = *((_QWORD *)&v190 + 1);
      }
      if (v21 == 1)
      {
        v25 = 0;
        LODWORD(v26) = -1;
        goto LABEL_41;
      }
LABEL_33:
      v14 = (unsigned int *)((char *)v14 + *v14);
      v62 = v195.d_ino > v15++;
      if (!v62)
        goto LABEL_34;
    }
  }
  if (v5 != 2)
  {
    v26 = 0xFFFFFFFFLL;
    goto LABEL_384;
  }
  *(double *)&v191 = Current;
  *((_QWORD *)&v191 + 1) = callBlock;
  v192 = v190;
  *(_QWORD *)&v190 = &v191;
  v189 = (char *)hybridSearch;
  v4 = *(_QWORD *)(*((_QWORD *)&v190 + 1) + 8608);
LABEL_7:
  if (*(_BYTE *)(v4 + 1064) && !*(_QWORD *)(v4 + 1072))
    *(_QWORD *)(v4 + 1072) = SIUINT64SetCreate();
  v6 = *(_DWORD *)(v4 + 9696);
  if (v6)
    v7 = *(uint64_t **)(*(_QWORD *)(v4 + 9688) + 8 * (v6 - 1));
  else
    v7 = 0;
  if (!*(_DWORD *)(v4 + 9708))
  {
    do
      v145 = __ldxr(&gFDCount);
    while (__stxr(v145 + 1, &gFDCount));
    v146 = open(".", 32772, Current);
    v147 = v146;
    if (v146 > 0x7FF)
    {
      if ((v146 & 0x80000000) != 0)
      {
        do
          v154 = __ldxr(&gFDCount);
        while (__stxr(v154 - 1, &gFDCount));
        goto LABEL_374;
      }
    }
    else
    {
      *(_DWORD *)(v4 + 4 * v146 + 9756) = 1607;
      ++*(_DWORD *)(v4 + 9752);
    }
    if ((*(_DWORD *)(v4 + 9704) & 0x80000000) != 0 && (!v7 || (v7[6] & 0x80000000) != 0))
    {
      v182 = v146;
      goto LABEL_47;
    }
    if (!MEMORY[0x1BCCB1484]())
    {
      v182 = v147;
      v177 = *(unsigned int *)(v4 + 9704);
      if ((v177 & 0x80000000) == 0)
      {
        do
          v178 = __ldxr(&gFDCount);
        while (__stxr(v178 - 1, &gFDCount));
        if (v177 <= 0x7FF)
        {
          v179 = *(_DWORD *)(v4 + 9752);
          *(_DWORD *)(v4 + 9752) = v179 - 1;
          v180 = v4 + 4 * v177;
          v181 = *(_DWORD *)(v180 + 9756);
          if (v181 < 0 || v179 <= 0)
            __assert_rtn("internalIterateWalk", "fsi.c", 1619, "iterator->fdArray[iterator->resumeFd] >= 0 && iterator->fdCount >= 0");
          if (v181)
            *(_DWORD *)(v180 + 9756) = -v181;
        }
      }
      close(v177);
      *(_DWORD *)(v4 + 9704) = -1;
      goto LABEL_47;
    }
    v148 = *__error();
    do
      v149 = __ldxr(&gFDCount);
    while (__stxr(v149 - 1, &gFDCount));
    if (v147 <= 2047)
    {
      v150 = *(_DWORD *)(v4 + 9752);
      *(_DWORD *)(v4 + 9752) = v150 - 1;
      v151 = v4 + 4 * v147;
      v152 = *(_DWORD *)(v151 + 9756);
      if (v152 < 0 || v150 <= 0)
        __assert_rtn("internalIterateWalk", "fsi.c", 1615, "iterator->fdArray[savedFd] >= 0 && iterator->fdCount >= 0");
      if (v152)
        *(_DWORD *)(v151 + 9756) = -v152;
    }
    v153 = v147;
LABEL_373:
    close(v153);
    *__error() = v148;
LABEL_374:
    v26 = 1;
    goto LABEL_383;
  }
  v182 = -1;
LABEL_47:
  v27 = *(_QWORD *)(v4 + 1056);
  v28 = 10;
  if (*(_DWORD *)(v4 + 9712))
    v28 = 0;
  v187 = v27 << v28;
  v184 = (unsigned int *)malloc_type_malloc(v27 << v28, 0x80A0E6F6uLL);
  v29 = 0;
  v188 = v4 + 3344;
  v186 = (void *)(v4 + 1032);
  do
  {
    if (*(_DWORD *)(v4 + 9700) != 2)
    {
      v29 = 0;
      *(_DWORD *)(v4 + 9700) = 0;
      if (*(_DWORD *)(v4 + 3400))
      {
LABEL_52:
        *(_DWORD *)(v4 + 9700) = 1;
        goto LABEL_162;
      }
      LODWORD(v30) = 0;
      v29 = 0;
      while (2)
      {
        v31 = *(_DWORD *)(v4 + 9696);
        if (!v31)
          goto LABEL_321;
        while (1)
        {
          v32 = v31 - 1;
          v33 = *(uint64_t **)(*(_QWORD *)(v4 + 9688) + 8 * (v31 - 1));
          if (!v33)
          {
LABEL_160:
            v7 = 0;
            goto LABEL_161;
          }
          v34 = (const char *)*v33;
          if (*v33 && (_DWORD)v30 == 0)
            break;
          if (!*(_DWORD *)(v4 + 9708))
          {
            v36 = v33[6];
            if (v36 != -1)
            {
              if ((v36 & 0x80000000) == 0)
              {
                do
                  v37 = __ldxr(&gFDCount);
                while (__stxr(v37 - 1, &gFDCount));
                if (v36 <= 0x7FF)
                {
                  v38 = *(_DWORD *)(v4 + 9752);
                  *(_DWORD *)(v4 + 9752) = v38 - 1;
                  v39 = v4 + 4 * v36;
                  v40 = *(_DWORD *)(v39 + 9756);
                  if (v40 < 0 || v38 <= 0)
                    __assert_rtn("pop", "fsi.c", 708, "iterator->fdArray[(int)previousFileReference] >= 0 && iterator->fdCount >= 0");
                  if (v40)
                    *(_DWORD *)(v39 + 9756) = -v40;
                }
              }
              close(v36);
              v31 = *(_DWORD *)(v4 + 9696);
              v32 = v31 - 1;
            }
          }
          *(_DWORD *)(v4 + 9696) = v32;
          if (!v32)
            goto LABEL_160;
          v41 = *(_QWORD *)(v4 + 9688);
          v42 = *(_QWORD *)(v41 + 8 * (v31 - 2));
          if (v42)
          {
            if (*(_QWORD *)(v4 + 1080))
              *(_QWORD *)(v4 + 9736) = *(_QWORD *)(v42 + 56);
            if (*(_DWORD *)(v4 + 9708) || !MEMORY[0x1BCCB1484](*(unsigned int *)(v42 + 48)))
              v30 = 0;
            else
              v30 = *__error();
            v43 = *(_QWORD **)(v4 + 9680);
            Data = SStackNextData((uint64_t)v43, *(_QWORD *)(v42 + 8));
            if (Data)
            {
              v45 = (char *)(Data + ((*(unsigned int *)(Data - 4) - 1) & 0xFFFFFFFFFFFFFFFCLL));
              v46 = (_QWORD *)*v43;
              for (i = (_QWORD *)v46[4]; ; i = v49)
              {
                if (i + 4 <= (_QWORD *)v45)
                {
                  v48 = v46[1];
                  if ((char *)i + *((unsigned int *)i + 4) + 32 >= v45)
                  {
                    i[1] = 0;
                    v46[4] = i;
                    v46[1] = v48 - i[3];
                    v50 = v45 - (char *)(i + 4);
                    i[3] = v50;
                    if (i == (_QWORD *)v46[3])
                    {
                      v50 = (int64_t)&v45[-v46[5]];
                      i[3] = v50;
                    }
                    v46[1] += v50;
                    v46[6] = v45;
                    *(_DWORD *)v45 = 0;
                    break;
                  }
                }
                else
                {
                  v48 = v46[1];
                }
                v49 = (_QWORD *)*i;
                v46[1] = v48 - i[3];
                if (v46[2])
                {
                  free(i);
                  --gSlabs;
                }
                else
                {
                  v46[2] = i;
                }
              }
            }
            v32 = *(_DWORD *)(v4 + 9696);
            if (!v32)
              goto LABEL_160;
            v41 = *(_QWORD *)(v4 + 9688);
          }
          else
          {
            v30 = 0;
          }
          v7 = *(uint64_t **)(v41 + 8 * (v32 - 1));
          if (v7)
          {
            LODWORD(v30) = updateStackEntry(v4, v30, (const char *)v7[2]);
            *(_DWORD *)(v4 + 3348) = 2;
            v51 = ((uint64_t (*)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD))v189)(v4, v188, v190, *(unsigned int *)(v4 + 3384), *(_QWORD *)(v4 + 3392));
            if (v51 == 2)
              v29 = 0;
            else
              v29 = v51;
            if (v51 == 1)
              goto LABEL_161;
            v32 = *(_DWORD *)(v4 + 9696);
          }
          v31 = v32;
          if (!v32)
            goto LABEL_160;
        }
        if (*(_DWORD *)(v4 + 9712) && !*(_QWORD *)(v4 + 1080))
        {
          v53 = *(uint64_t **)(*(_QWORD *)(v4 + 9688) + 8 * (v31 - 1));
          v52 = (const char *)SStackNextData(*(_QWORD *)(v4 + 9680), *v33);
          v33 = v53;
        }
        else
        {
          v52 = 0;
        }
        v7 = v33;
        v33[2] = (uint64_t)v34;
        LODWORD(v30) = updateStackEntry(v4, 0, v34);
        if (!*(_QWORD *)(v4 + 9664)
          || (v54 = *(_QWORD *)(v4 + 9672)) != 0
          && !(*(unsigned int (**)(uint64_t, uint64_t))(v54 + 16))(v54, v4))
        {
          if (v34 != (const char *)v7[1])
          {
            v57 = SStackNextData(*(_QWORD *)(v4 + 9680), (uint64_t)v34);
            goto LABEL_113;
          }
LABEL_112:
          v57 = 0;
          goto LABEL_113;
        }
        v55 = v7[5];
        if (v55 == v7[3])
          goto LABEL_112;
        v56 = v7[4];
        v7[5] = v55 + 1;
        v57 = *(_QWORD *)(v56 + 8 * v55);
LABEL_113:
        *v7 = v57;
        if (*(_DWORD *)&v34[*(_QWORD *)(v4 + 1096)] == 1 && *(_QWORD *)(v4 + 9664))
        {
          v58 = *(_QWORD *)(v4 + 9672);
          if (v58)
          {
            if (!(*(unsigned int (**)(uint64_t, uint64_t))(v58 + 16))(v58, v4))
              goto LABEL_117;
            if (!*(_QWORD *)(v4 + 9664))
              __assert_rtn("handleRunOfFiles", "fsi.c", 1412, "iterator->comparator");
          }
          *(_DWORD *)(v4 + 3348) = 0;
          v29 = ((uint64_t (*)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD))v189)(v4, v188, v190, *(unsigned int *)(v4 + 3384), *(_QWORD *)(v4 + 3392));
          if ((v29 & 0xFFFFFFFD) == 0)
          {
            v140 = (const char *)*v7;
            if (*v7)
            {
              if (*(_DWORD *)&v140[*(_QWORD *)(v4 + 1096)] == 1)
              {
                updated = 0;
                do
                {
                  v7[2] = (uint64_t)v140;
                  v142 = v7[5];
                  if (v142 == v7[3])
                  {
                    v143 = 0;
                  }
                  else
                  {
                    v144 = v7[4];
                    v7[5] = v142 + 1;
                    v143 = *(_QWORD *)(v144 + 8 * v142);
                  }
                  *v7 = v143;
                  updated = updateStackEntry(v4, updated, v140);
                  *(_DWORD *)(v4 + 3348) = 0;
                  v29 = ((uint64_t (*)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD))v189)(v4, v188, v190, *(unsigned int *)(v4 + 3384), *(_QWORD *)(v4 + 3392));
                  if ((v29 & 0xFFFFFFFD) != 0)
                    break;
                  v140 = (const char *)*v7;
                  if (!*v7)
                    break;
                }
                while (*(_DWORD *)&v140[*(_QWORD *)(v4 + 1096)] == 1);
              }
            }
          }
          if (v29 == 2)
          {
            v29 = 0;
            goto LABEL_162;
          }
LABEL_161:
          if (v29 == 1)
            goto LABEL_277;
          goto LABEL_162;
        }
LABEL_117:
        if (*(_DWORD *)(v4 + 9708))
        {
          v59 = *(_QWORD *)(v4 + 1112);
          v60 = v59 + 8;
          v61 = (uint64_t *)&v34[v59];
          if (v61)
            v62 = v60 > *(unsigned int *)v34;
          else
            v62 = 1;
          if (!v62)
          {
            v63 = *v61;
LABEL_145:
            v77 = 1;
            goto LABEL_146;
          }
        }
        else
        {
          v64 = *(_QWORD *)(v4 + 1080);
          if (v64)
          {
            v65 = *(unsigned int *)v34;
            if (v64 + 8 <= v65)
            {
              v66 = &v34[v64];
              v67 = *((unsigned int *)v66 + 1);
              v68 = &v66[*(int *)v66];
              if (&v68[v67] <= &v34[v65])
                v52 = v68;
              else
                v52 = 0;
            }
            else
            {
              v52 = 0;
            }
          }
          do
            v69 = __ldxr(&gFDCount);
          while (__stxr(v69 + 1, &gFDCount));
          v70 = open(v52, 32772);
          LODWORD(v63) = v70;
          if (v70 > 0x7FF)
          {
            if ((v70 & 0x80000000) != 0)
            {
              do
                v76 = __ldxr(&gFDCount);
              while (__stxr(v76 - 1, &gFDCount));
              goto LABEL_143;
            }
          }
          else
          {
            *(_DWORD *)(v4 + 4 * v70 + 9756) = 749;
            ++*(_DWORD *)(v4 + 9752);
          }
          if (!MEMORY[0x1BCCB1484](v70))
          {
            v63 = v63;
            goto LABEL_145;
          }
          v71 = *__error();
          do
            v72 = __ldxr(&gFDCount);
          while (__stxr(v72 - 1, &gFDCount));
          if ((int)v63 <= 2047)
          {
            v73 = *(_DWORD *)(v4 + 9752);
            *(_DWORD *)(v4 + 9752) = v73 - 1;
            v74 = v4 + 4 * v63;
            v75 = *(_DWORD *)(v74 + 9756);
            if (v75 < 0 || v73 <= 0)
              __assert_rtn("prepareForPush", "fsi.c", 756, "iterator->fdArray[fd] >= 0 && iterator->fdCount >= 0");
            if (v75)
              *(_DWORD *)(v74 + 9756) = -v75;
          }
          close(v63);
          *__error() = v71;
        }
LABEL_143:
        __error();
        v77 = 0;
        v63 = -1;
LABEL_146:
        *(_DWORD *)(v4 + 3348) = 1;
        if (*(_DWORD *)(v4 + 9720))
        {
          *(_DWORD *)(v4 + 3388) = 0;
          v78 = ((uint64_t (*)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD))v189)(v4, v188, v190, *(unsigned int *)(v4 + 3384), *(_QWORD *)(v4 + 3392));
          *(_DWORD *)(v4 + 3388) = 0;
        }
        else
        {
          v78 = ((uint64_t (*)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD))v189)(v4, v188, v190, *(unsigned int *)(v4 + 3384), *(_QWORD *)(v4 + 3392));
        }
        if (v78)
          v79 = 0;
        else
          v79 = v77;
        if (v79 != 1)
        {
          cleanupAfterNoPush(v4, v63);
          if (v78 == 1)
            goto LABEL_277;
          *(_DWORD *)(v4 + 3348) = 2;
          if (v78 != 3
            && ((unsigned int (*)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD))v189)(v4, v188, v190, *(unsigned int *)(v4 + 3384), *(_QWORD *)(v4 + 3392)) == 1)
          {
            goto LABEL_277;
          }
LABEL_158:
          v29 = 2;
          if (!*(_DWORD *)(v4 + 3400))
            continue;
          goto LABEL_52;
        }
        break;
      }
      if (pushStackEntry(v4, v63))
      {
        cleanupAfterNoPush(v4, v63);
        goto LABEL_158;
      }
      v139 = *(_DWORD *)(v4 + 9696);
      if (v139)
      {
        v29 = 0;
        v7 = *(uint64_t **)(*(_QWORD *)(v4 + 9688) + 8 * (v139 - 1));
        goto LABEL_162;
      }
      v29 = 0;
LABEL_321:
      v7 = 0;
LABEL_162:
      if (*(_DWORD *)(v4 + 3400))
        goto LABEL_276;
    }
    if (!v7)
      goto LABEL_276;
    if (*(_DWORD *)(v4 + 3400) && !*(_DWORD *)(v4 + 9700))
    {
      *(_DWORD *)(v4 + 9700) = 2;
      goto LABEL_276;
    }
    v183 = v7;
    *(_DWORD *)(v4 + 9700) = 0;
    bzero(v196, 0x400uLL);
    if (*(_DWORD *)(v4 + 9708))
    {
      d_name = v196;
      sprintf(v196, "/.vol/%llu/%llu", *(int *)(v4 + 9724), v7[6]);
    }
    else
    {
      d_name = ".";
    }
    if (*(_DWORD *)(v4 + 9712))
    {
      v81 = opendir(d_name);
      if (!v81)
        goto LABEL_275;
      v82 = v81;
      bzero(&v195, 0x418uLL);
      v194 = 0;
      if (*(_QWORD *)(v4 + 9664))
      {
        v83 = *(_QWORD *)(v4 + 9672);
        if (v83)
          v84 = (*(uint64_t (**)(uint64_t, uint64_t))(v83 + 16))(v83, v4);
        else
          v84 = 1;
      }
      else
      {
        v84 = 0;
      }
      while (1)
      {
        do
        {
          if (v29 != 1 && !readdir_r(v82, &v195, &v194))
          {
            v111 = v194;
            if (v194)
              continue;
          }
          closedir(v82);
          if (*(_DWORD *)(v4 + 9716)
            && (!*(_QWORD *)(v4 + 9664)
             || (v124 = *(_QWORD *)(v4 + 9672)) != 0
             && ((*(uint64_t (**)(uint64_t, uint64_t))(v124 + 16))(v124, v4) & 1) == 0))
          {
            if (v29 != 1)
            {
              v125 = 0;
              do
              {
                v126 = *(_QWORD *)(v4 + 9640);
                v127 = *(_QWORD *)(v126 + 24);
                if (!v127)
                  break;
                v128 = *(_QWORD *)(v127 + 24);
                if (v128 < 4)
                  break;
                v129 = *(const char **)(v126 + 40);
                v130 = *(unsigned int *)v129;
                if (v128 < v130)
                  break;
                v125 = updateStackEntry(v4, v125, v129);
                *(_DWORD *)(v4 + 3348) = 0;
                v131 = ((uint64_t (*)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD))v189)(v4, v188, v190, *(unsigned int *)(v4 + 3384), *(_QWORD *)(v4 + 3392));
                SQueueDropData(*(_QWORD **)(v4 + 9640), v130);
                v29 = v131 == 2 ? 0 : v131;
              }
              while (v29 != 1);
            }
            SQueueEmpty(*(_QWORD **)(v4 + 9640));
          }
          else
          {
            finishChildList((_DWORD *)v4);
          }
          goto LABEL_275;
        }
        while (!strcmp(v194->d_name, ".") || !strcmp(v111->d_name, ".."));
        if (*(_DWORD *)(v4 + 9708))
        {
          sprintf(v196, "/.vol/%llu/%llu", *(int *)(v4 + 9724), v111->d_ino);
          v111 = v194;
        }
        else
        {
          d_name = v111->d_name;
        }
        d_type = v111->d_type;
        if (v111->d_type)
          goto LABEL_250;
        memset(&v193, 0, sizeof(v193));
        if (!fstatat(-2, d_name, &v193, 544))
          break;
        if (*__error() != 22)
        {
          v114 = v194;
          goto LABEL_249;
        }
        v113 = fstatat(-2, d_name, &v193, 32);
        v114 = v194;
        if (!v113)
          goto LABEL_247;
LABEL_249:
        d_type = v114->d_type;
LABEL_250:
        if ((d_type == 8 || d_type == 4) && (!getattrlist(d_name, v186, v184, v187, 0x208u) || !*__error()))
        {
          if (v194->d_type == 8)
          {
            if (*(_DWORD *)(v4 + 9724) == *(unsigned int *)((char *)v184 + *(_QWORD *)(v4 + 1088)))
            {
              if (*(_DWORD *)(v4 + 9716))
              {
                if (v84)
                {
                  v115 = v4;
                  v116 = v184;
                  d_namlen = 0;
                  v118 = 0;
                  v119 = 1;
                  goto LABEL_262;
                }
                v121 = *(_QWORD **)(v4 + 9640);
                v122 = *v184;
                v123 = SQueueOpenPushData((uint64_t)v121, v122);
                memcpy(v123, v184, v122);
                v121[6] += v122;
                *(_QWORD *)(v121[4] + 24) += v122;
                v121[1] += v122;
              }
              else
              {
                updateStackEntry(v4, 0, (const char *)v184);
                *(_DWORD *)(v4 + 3348) = 0;
                v120 = ((uint64_t (*)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD))v189)(v4, v188, v190, *(unsigned int *)(v4 + 3384), *(_QWORD *)(v4 + 3392));
                if (v120 == 2)
                  v29 = 0;
                else
                  v29 = v120;
              }
            }
          }
          else if ((*((_BYTE *)v184 + *(_QWORD *)(v4 + 1120)) & 3) == 0
                 && *(_DWORD *)(v4 + 9724) == *(unsigned int *)((char *)v184 + *(_QWORD *)(v4 + 1088)))
          {
            d_namlen = v194->d_namlen;
            v118 = v194->d_name;
            v115 = v4;
            v116 = v184;
            v119 = v84;
LABEL_262:
            addIntoChildList(v115, v116, d_namlen, v118, v119);
          }
        }
      }
      v114 = v194;
LABEL_247:
      v114->d_type = v193.st_mode >> 12;
      goto LABEL_249;
    }
    do
      v85 = __ldxr(&gFDCount);
    while (__stxr(v85 + 1, &gFDCount));
    v86 = open(d_name, 32772);
    v87 = v86;
    v185 = v86;
    if (v86 > 0x7FF)
    {
      if ((v86 & 0x80000000) != 0)
      {
        do
          v105 = __ldxr(&gFDCount);
        while (__stxr(v105 - 1, &gFDCount));
        goto LABEL_275;
      }
    }
    else
    {
      *(_DWORD *)(v4 + 4 * v86 + 9756) = 1654;
      ++*(_DWORD *)(v4 + 9752);
    }
    v88 = v184;
    while (1)
    {
      v89 = getattrlistbulk(v87, v186, v88, v187, 0x208uLL);
      if ((v89 & 0x80000000) == 0)
      {
        v90 = v89;
        if (!v89)
        {
          v104 = v29 != 1;
          goto LABEL_216;
        }
        if (*(_QWORD *)(v4 + 9664))
        {
          v91 = *(_QWORD *)(v4 + 9672);
          if (v91)
            v92 = (*(uint64_t (**)(uint64_t, uint64_t))(v91 + 16))(v91, v4);
          else
            v92 = 1;
        }
        else
        {
          v92 = 0;
        }
        v93 = 0;
        v29 = 0;
        v94 = 1;
        v95 = (const char *)v88;
        while (1)
        {
          if (*(_DWORD *)(v4 + 9724) != *(_DWORD *)&v95[*(_QWORD *)(v4 + 1088)])
            goto LABEL_206;
          v96 = *(_DWORD *)&v95[*(_QWORD *)(v4 + 1096)];
          if ((v96 - 1) > 1)
            goto LABEL_206;
          v97 = *(_QWORD *)(v4 + 1072);
          if (v97)
          {
            if ((SIUINT64SetContainsValue(v97, *(_QWORD *)&v95[*(_QWORD *)(v4 + 1112)]) & 1) != 0)
              goto LABEL_206;
          }
          if (v96 != 1)
            break;
          if (!*(_DWORD *)(v4 + 9716))
          {
            v93 = updateStackEntry(v4, v93, v95);
            *(_DWORD *)(v4 + 3348) = 0;
            *(_BYTE *)(v4 + 1065) = *(_QWORD *)(v4 + 1072) != 0;
            v29 = ((uint64_t (*)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD))v189)(v4, v188, v190, *(unsigned int *)(v4 + 3384), *(_QWORD *)(v4 + 3392));
            if (*(_BYTE *)(v4 + 1065))
              SIValueSet<unsigned long long>::SIValueSetInsert((unint64_t *)(*(_QWORD *)(v4 + 1072) + 16), *(_QWORD *)(*(_QWORD *)(v4 + 3392) + *(_QWORD *)(v4 + 1112)));
            if (v29 == 2)
              v29 = 0;
            goto LABEL_206;
          }
          if (v92)
          {
            v98 = v4;
            v99 = (unsigned int *)v95;
            v100 = 1;
LABEL_199:
            addIntoChildList(v98, v99, 0, 0, v100);
            goto LABEL_206;
          }
          v101 = *(_QWORD **)(v4 + 9640);
          v102 = *(unsigned int *)v95;
          v103 = SQueueOpenPushData((uint64_t)v101, v102);
          memcpy(v103, v95, v102);
          v101[6] += v102;
          *(_QWORD *)(v101[4] + 24) += v102;
          v101[1] += v102;
          v88 = v184;
LABEL_206:
          if (v94 < v90)
          {
            v95 += *(unsigned int *)v95;
            ++v94;
            if (v29 != 1)
              continue;
          }
          goto LABEL_208;
        }
        if ((v95[*(_QWORD *)(v4 + 1120)] & 3) != 0)
          goto LABEL_206;
        v98 = v4;
        v99 = (unsigned int *)v95;
        v100 = v92;
        goto LABEL_199;
      }
      LODWORD(v93) = *__error();
LABEL_208:
      v104 = v29 != 1;
      if ((_DWORD)v93)
        break;
      v87 = v185;
      if (v29 == 1)
        goto LABEL_216;
    }
    v87 = v185;
LABEL_216:
    if (*(_DWORD *)(v4 + 9716)
      && (!*(_QWORD *)(v4 + 9664)
       || (v106 = *(_QWORD *)(v4 + 9672)) != 0
       && ((*(uint64_t (**)(uint64_t, uint64_t))(v106 + 16))(v106, v4) & 1) == 0))
    {
      if (v29 != 1)
      {
        v132 = 0;
        do
        {
          v133 = *(_QWORD *)(v4 + 9640);
          v134 = *(_QWORD *)(v133 + 24);
          if (!v134)
            break;
          v135 = *(_QWORD *)(v134 + 24);
          if (v135 < 4)
            break;
          v136 = *(const char **)(v133 + 40);
          v137 = *(unsigned int *)v136;
          if (v135 < v137)
            break;
          v132 = updateStackEntry(v4, v132, v136);
          *(_DWORD *)(v4 + 3348) = 0;
          *(_BYTE *)(v4 + 1065) = *(_QWORD *)(v4 + 1072) != 0;
          v138 = ((uint64_t (*)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD))v189)(v4, v188, v190, *(unsigned int *)(v4 + 3384), *(_QWORD *)(v4 + 3392));
          if (*(_BYTE *)(v4 + 1065))
            SIValueSet<unsigned long long>::SIValueSetInsert((unint64_t *)(*(_QWORD *)(v4 + 1072) + 16), *(_QWORD *)(*(_QWORD *)(v4 + 3392) + *(_QWORD *)(v4 + 1112)));
          SQueueDropData(*(_QWORD **)(v4 + 9640), v137);
          v29 = v138 == 2 ? 0 : v138;
        }
        while (v29 != 1);
      }
      SQueueEmpty(*(_QWORD **)(v4 + 9640));
    }
    else if (v104)
    {
      finishChildList((_DWORD *)v4);
    }
    else
    {
      v29 = 1;
    }
    do
      v107 = __ldxr(&gFDCount);
    while (__stxr(v107 - 1, &gFDCount));
    if (v87 <= 2047)
    {
      v108 = *(_DWORD *)(v4 + 9752);
      *(_DWORD *)(v4 + 9752) = v108 - 1;
      v109 = v4 + 4 * v87;
      v110 = *(_DWORD *)(v109 + 9756);
      if (v110 < 0 || v108 <= 0)
        __assert_rtn("internalIterateWalk", "fsi.c", 1767, "iterator->fdArray[fd] >= 0 && iterator->fdCount >= 0");
      if (v110)
        *(_DWORD *)(v109 + 9756) = -v110;
    }
    close(v87);
LABEL_275:
    v7 = v183;
LABEL_276:
    if (v29 != 1)
    {
      v26 = 0;
      if (!v7)
        break;
      continue;
    }
LABEL_277:
    if (!*(_DWORD *)(v4 + 9708))
    {
      for (j = *(_DWORD *)(v4 + 9696); j; *(_DWORD *)(v4 + 9696) = j)
      {
        v156 = *(_QWORD *)(*(_QWORD *)(v4 + 9688) + 8 * --j);
        if (!v156)
          break;
        v157 = *(_QWORD *)(v156 + 48);
        if (v157 != -1)
        {
          if ((v157 & 0x80000000) == 0)
          {
            do
              v158 = __ldxr(&gFDCount);
            while (__stxr(v158 - 1, &gFDCount));
            if ((int)v157 <= 2047)
            {
              v159 = *(_DWORD *)(v4 + 9752);
              *(_DWORD *)(v4 + 9752) = v159 - 1;
              v160 = v4 + 4 * (int)v157;
              v161 = *(_DWORD *)(v160 + 9756);
              if (v161 < 0 || v159 <= 0)
                __assert_rtn("internalIterateWalk", "fsi.c", 1856, "iterator->fdArray[(int)tos->fileReference] >= 0 && iterator->fdCount >= 0");
              if (v161)
                *(_DWORD *)(v160 + 9756) = -v161;
            }
          }
          close(v157);
          j = *(_DWORD *)(v4 + 9696) - 1;
        }
      }
      v26 = 0xFFFFFFFFLL;
      break;
    }
    v29 = 1;
    v26 = 0xFFFFFFFFLL;
    if (!v7)
      break;
  }
  while (v29 != 1 && !*(_DWORD *)(v4 + 3400));
  v162.n128_f64[0] = SQueueEmpty(*(_QWORD **)(v4 + 9640));
  if (*(_DWORD *)(v4 + 3400))
  {
    *(_DWORD *)(v4 + 3404) = 1;
    v163 = v182;
    if (!*(_DWORD *)(v4 + 9708))
    {
      do
        v164 = __ldxr(&gFDCount);
      while (__stxr(v164 + 1, &gFDCount));
      v165 = open(".", 32772, v162.n128_f64[0]);
      if (v165 <= 0x7FF)
      {
        *(_DWORD *)(v4 + 4 * v165 + 9756) = 1868;
        ++*(_DWORD *)(v4 + 9752);
        goto LABEL_362;
      }
      if ((v165 & 0x80000000) != 0)
      {
        do
          v176 = __ldxr(&gFDCount);
        while (__stxr(v176 - 1, &gFDCount));
        *(_DWORD *)(v4 + 9704) = v165;
        *(_DWORD *)(v4 + 3404) = 0;
        v26 = 1;
      }
      else
      {
LABEL_362:
        *(_DWORD *)(v4 + 9704) = v165;
      }
    }
    *(_DWORD *)(v4 + 3400) = 0;
    if ((v182 & 0x80000000) == 0)
    {
LABEL_364:
      if (MEMORY[0x1BCCB1484](v163, v162))
      {
        *(_DWORD *)(v4 + 3404) = 0;
        v148 = *__error();
        do
          v166 = __ldxr(&gFDCount);
        while (__stxr(v166 - 1, &gFDCount));
        if (v163 <= 0x7FF)
        {
          v167 = *(_DWORD *)(v4 + 9752);
          *(_DWORD *)(v4 + 9752) = v167 - 1;
          v168 = v4 + 4 * v163;
          v169 = *(_DWORD *)(v168 + 9756);
          if (v169 < 0 || v167 <= 0)
            __assert_rtn("internalIterateWalk", "fsi.c", 1880, "iterator->fdArray[savedFd] >= 0 && iterator->fdCount >= 0");
          if (v169)
            *(_DWORD *)(v168 + 9756) = -v169;
        }
        v153 = v163;
        goto LABEL_373;
      }
      do
        v170 = __ldxr(&gFDCount);
      while (__stxr(v170 - 1, &gFDCount));
      if (v163 <= 0x7FF)
      {
        v171 = *(_DWORD *)(v4 + 9752);
        *(_DWORD *)(v4 + 9752) = v171 - 1;
        v172 = v4 + 4 * v163;
        v173 = *(_DWORD *)(v172 + 9756);
        if (v173 < 0 || v171 <= 0)
          __assert_rtn("internalIterateWalk", "fsi.c", 1884, "iterator->fdArray[savedFd] >= 0 && iterator->fdCount >= 0");
        if (v173)
          *(_DWORD *)(v172 + 9756) = -v173;
      }
      close(v163);
    }
  }
  else
  {
    v163 = v182;
    if ((v182 & 0x80000000) == 0)
      goto LABEL_364;
  }
  free(v184);
LABEL_383:
  v4 = *((_QWORD *)&v190 + 1);
LABEL_384:
  v174 = *(_QWORD *)(v4 + 8608);
  if (v174)
  {
    *(_DWORD *)(v4 + 3404) = *(_DWORD *)(v174 + 3404);
    *(_DWORD *)(v4 + 3400) = 0;
  }
  return v26;
}

uint64_t hybridSearch(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5)
{
  uint64_t v6;
  int v7;
  int v12;
  int v14;
  int v15;
  uint64_t v16;
  int v17;
  _BYTE *v18;
  int v19;
  int v20;
  int v21;
  uint64_t v22;
  unsigned int *v23;
  unsigned int *v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unsigned int *v28;
  unint64_t v29;
  unsigned int *v30;
  unsigned int *v31;
  unsigned int v32;
  _BOOL4 v33;
  unint64_t v34;
  unint64_t *v35;
  unint64_t *v36;
  unint64_t v37;
  const char *v38;
  const char *v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  int v43;
  int v44;
  int v45;
  _DWORD *v46;
  _DWORD *v47;
  char *v48;
  uint64_t v49;
  int *v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  size_t v55;
  uint64_t v56;
  int *v57;
  unsigned int v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  size_t v63;
  uint64_t v64;
  int *v65;
  unsigned int v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  size_t v70;
  uint64_t v71;
  int *v72;
  unsigned int v73;
  unsigned int v74;
  unsigned int v75;
  uint64_t v76;
  unsigned int v77;
  int v78;
  uint64_t v79;
  uint64_t v80;
  int v81;
  _DWORD *v82;
  int v83;

  v6 = *(_QWORD *)(a3 + 24);
  v7 = *(_DWORD *)(a2 + 4);
  if (v7 != 2)
  {
    v12 = *(_DWORD *)a2;
    if (v7 != 1 || v12 < 1)
    {
      v14 = 0;
    }
    else
    {
      v15 = *(_DWORD *)(v6 + 3424);
      if ((v15 & 0x40) == 0)
      {
        v14 = 0;
        if ((v15 & 0x20) != 0)
          goto LABEL_20;
        goto LABEL_19;
      }
      v16 = *(_QWORD *)(a2 + 16);
      if (path_bundle_index_predicate != -1)
        dispatch_once(&path_bundle_index_predicate, &__block_literal_global_7789);
      v14 = fcntl(path_bundle_index_sDummyFD_7790, 52, v16) >= 0;
      v12 = *(_DWORD *)a2;
    }
    if (v12 >= 1 && (*(_DWORD *)(v6 + 3424) & 0x20) != 0)
    {
LABEL_20:
      if ((*(_WORD *)(a5 + *(_QWORD *)(v6 + 1104) + 8) & 0x40) == 0)
      {
        v18 = *(_BYTE **)(a2 + 32);
        if (!v18)
        {
          v17 = 0;
          goto LABEL_26;
        }
        if (*v18 != 46)
        {
          v17 = 0;
          LODWORD(v18) = 0;
          goto LABEL_26;
        }
      }
      LODWORD(v18) = *(_DWORD *)(a2 + 4) == 1;
      v17 = 1;
LABEL_26:
      v14 |= v18;
LABEL_27:
      v19 = *(_DWORD *)(a2 + 4);
      if (v19)
      {
        if (v19 != 1)
        {
          v20 = *(_DWORD *)(v6 + 3424);
          goto LABEL_34;
        }
        v20 = *(_DWORD *)(v6 + 3424);
        if ((v20 & 4) != 0)
        {
LABEL_34:
          v81 = v17;
          v83 = v14;
          v79 = a2;
          v80 = a3;
          v21 = *(_DWORD *)(v6 + 4176);
          if (v21 >= 1)
          {
            v22 = 0;
            v23 = (unsigned int *)(*(_QWORD *)(v6 + 3480) + 4);
            v24 = (unsigned int *)(*(_QWORD *)(v6 + 3472) + 4);
            while (1)
            {
              v25 = v6 + 8 * v22;
              v26 = *(_QWORD *)(v25 + 5752);
              v27 = *(_QWORD *)(v25 + 4472);
              if (v27)
              {
                if (!*(_BYTE *)(v6 + v22 + 4312))
                {
                  v33 = 1;
                  goto LABEL_61;
                }
                v28 = (unsigned int *)(a5 + v27);
                switch(*(_BYTE *)(v6 + v22 + 4392))
                {
                  case 1:
                    if (v26 < 4)
                      goto LABEL_59;
                    v29 = v26 >> 2;
                    v30 = v23;
                    v31 = v24;
                    while (2)
                    {
                      v32 = *v28;
                      if (*v28 > *v31 && v32 < *v30)
                        goto LABEL_59;
                      if (v32 >= *v31 && v32 <= *v30)
                      {
                        ++v28;
                        ++v31;
                        ++v30;
                        v33 = 1;
                        if (!--v29)
                          goto LABEL_60;
                        continue;
                      }
                      goto LABEL_73;
                    }
                  case 2:
                    if (v26 < 8)
                      goto LABEL_59;
                    v34 = v26 >> 3;
                    v35 = (unint64_t *)v23;
                    v36 = (unint64_t *)v24;
                    while (2)
                    {
                      v37 = *(_QWORD *)v28;
                      if (*(_QWORD *)v28 > *v36 && v37 < *v35)
                        goto LABEL_59;
                      if (v37 >= *v36 && v37 <= *v35)
                      {
                        v28 += 2;
                        ++v36;
                        ++v35;
                        v33 = 1;
                        if (!--v34)
                          goto LABEL_60;
                        continue;
                      }
                      break;
                    }
LABEL_73:
                    v33 = 0;
                    goto LABEL_60;
                  case 3:
                    v38 = (char *)v28 + (int)*v28;
                    v39 = (char *)v24 + (int)*v24;
                    if ((v20 & 2) != 0)
                    {
                      v33 = strcasestr(v38, v39) != 0;
                      v21 = *(_DWORD *)(v6 + 4176);
                    }
                    else
                    {
                      v33 = strcasecmp(v38, v39) == 0;
                    }
                    goto LABEL_60;
                  case 4:
                    if (v26 < 4)
                      goto LABEL_59;
                    if (v26 >> 2 <= 1)
                      v40 = 1;
                    else
                      v40 = v26 >> 2;
                    if ((*v23 & *v28) != *v24)
                      goto LABEL_73;
                    v41 = 0;
                    v42 = a5 + 4 + v27;
                    break;
                  default:
                    goto LABEL_59;
                }
                while (v40 - 1 != v41)
                {
                  v43 = v23[v41 + 1] & *(_DWORD *)(v42 + 4 * v41);
                  v44 = v24[++v41];
                  if (v43 != v44)
                    goto LABEL_75;
                }
                v41 = v40;
LABEL_75:
                v33 = v41 >= v26 >> 2;
              }
              else
              {
LABEL_59:
                v33 = 1;
              }
LABEL_60:
              v24 = (unsigned int *)((char *)v24 + v26);
              v23 = (unsigned int *)((char *)v23 + v26);
LABEL_61:
              if (++v22 >= v21 || !v33)
                goto LABEL_77;
            }
          }
          v33 = 1;
LABEL_77:
          if (v20 < 0)
            v33 = !v33;
          if (!v33)
            return (2 * v83);
          v45 = v83;
          if (v81)
            return (2 * v83);
          if ((*(_BYTE *)(v6 + 1028) & 0x80) != 0)
          {
LABEL_116:
            v74 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, uint64_t))(v80 + 8))(v6, v79, *(_QWORD *)(v80 + 16), a4, a5);
            if (v45)
              v75 = 2;
            else
              v75 = v74;
            if (v74 == 1)
              return 1;
            else
              return v75;
          }
          v46 = *(_DWORD **)(v6 + 3440);
          v47 = v46 + 1;
          v82 = v46;
          v48 = (char *)v46 + *(_QWORD *)(v6 + 6432);
          v49 = *(_QWORD *)(v6 + 6416);
          if (v49)
          {
            v50 = (int *)(a5 + v49);
LABEL_86:
            v51 = *v50;
            goto LABEL_87;
          }
          v76 = *(_QWORD *)(v6 + 6424);
          if (v76)
          {
            v77 = (*(_DWORD *)(a5 + v76) & 0xF000) - 4096;
            if (v77 >> 14 <= 2)
            {
              v50 = (int *)((char *)&unk_1B8631294 + 4 * (v77 >> 12));
              goto LABEL_86;
            }
            v51 = 0;
          }
          else
          {
            v51 = -1;
          }
          if (*(int *)(v6 + 6396) < 1)
            goto LABEL_107;
LABEL_87:
          v78 = v51;
          v52 = 0;
          v53 = v6 + 6448;
          do
          {
            v54 = v53 + 8 * v52;
            v55 = *(_QWORD *)(v54 + 1520);
            v56 = *(_QWORD *)(v54 + 240);
            if (v56)
            {
              v57 = (int *)(a5 + v56);
              if (*(_BYTE *)(v53 + v52))
              {
                v58 = v57[1];
                memcpy(v48, (char *)v57 + *v57, v58);
                *v47 = (_DWORD)v48 - (_DWORD)v47;
                v47[1] = v58;
                v48 += (v57[1] + 3) & 0xFFFFFFFC;
              }
              else
              {
                memcpy(v47, (const void *)(a5 + v56), v55);
              }
            }
            else
            {
              bzero(v47, v55);
            }
            v47 = (_DWORD *)((char *)v47 + v55);
            ++v52;
            v59 = *(int *)(v6 + 6396);
          }
          while (v52 < v59);
          v51 = v78;
          if (v78 == 2 && (v60 = *(unsigned int *)(v6 + 6396), (int)v59 >= 1))
          {
            if (*(int *)(v6 + 6400) >= 1)
            {
              v61 = v6 + 6448;
              do
              {
                v62 = v61 + 8 * v60;
                v63 = *(_QWORD *)(v62 + 1520);
                v64 = *(_QWORD *)(v62 + 240);
                if (v64)
                {
                  v65 = (int *)(a5 + v64);
                  if (*(_BYTE *)(v61 + v60))
                  {
                    v66 = v65[1];
                    memcpy(v48, (char *)v65 + *v65, v66);
                    *v47 = (_DWORD)v48 - (_DWORD)v47;
                    v47[1] = v66;
                    v48 += (v65[1] + 3) & 0xFFFFFFFC;
                  }
                  else
                  {
                    memcpy(v47, (const void *)(a5 + v64), v63);
                  }
                }
                else
                {
                  bzero(v47, v63);
                }
                v47 = (_DWORD *)((char *)v47 + v63);
                ++v60;
              }
              while (v60 < *(int *)(v6 + 6400) + (uint64_t)*(int *)(v6 + 6396));
            }
          }
          else
          {
LABEL_107:
            if (v51 == 1 && *(int *)(v6 + 6408) >= 1)
            {
              v67 = *(int *)(v6 + 6404);
              v68 = v6 + 6448;
              do
              {
                v69 = v68 + 8 * v67;
                v70 = *(_QWORD *)(v69 + 1520);
                v71 = *(_QWORD *)(v69 + 240);
                if (v71)
                {
                  v72 = (int *)(a5 + v71);
                  if (*(_BYTE *)(v68 + v67))
                  {
                    v73 = v72[1];
                    memcpy(v48, (char *)v72 + *v72, v73);
                    *v47 = (_DWORD)v48 - (_DWORD)v47;
                    v47[1] = v73;
                    v48 += (v72[1] + 3) & 0xFFFFFFFC;
                  }
                  else
                  {
                    memcpy(v47, (const void *)(a5 + v71), v70);
                  }
                }
                else
                {
                  bzero(v47, v70);
                }
                v47 = (_DWORD *)((char *)v47 + v70);
                ++v67;
              }
              while (v67 < *(int *)(v6 + 6408) + (uint64_t)*(int *)(v6 + 6404));
            }
          }
          *v82 = (_DWORD)v48 - (_DWORD)v82;
          a5 = *(_QWORD *)(v6 + 3440);
          v45 = v83;
          goto LABEL_116;
        }
      }
      else
      {
        v20 = *(_DWORD *)(v6 + 3424);
        if ((v20 & 8) != 0)
          goto LABEL_34;
      }
      return (2 * v14);
    }
LABEL_19:
    v17 = 0;
    goto LABEL_27;
  }
  if (*(double *)(v6 + 3416) < CFAbsoluteTimeGetCurrent() - *(double *)a3)
  {
    do
    {
      *(_DWORD *)(v6 + 3400) = 1;
      v6 = *(_QWORD *)(v6 + 8608);
    }
    while (v6);
  }
  return 0;
}

uint64_t updateStackEntry(uint64_t a1, uint64_t a2, const char *a3)
{
  uint64_t v6;
  unint64_t v7;
  const char *v8;
  uint64_t v9;
  const char *v10;
  uint64_t v11;
  uint64_t v13;

  v6 = *(_QWORD *)(a1 + 1080);
  if (v6)
  {
    v7 = *(unsigned int *)a3;
    if (v6 + 8 > v7 || (v8 = &a3[v6], v9 = *((unsigned int *)v8 + 1), v10 = &v8[*(int *)v8], &v10[v9] > &a3[v7]))
    {
      a2 = 2;
      v11 = -1;
LABEL_5:
      *(_QWORD *)(a1 + 3376) = a1 + *(_QWORD *)(a1 + 3352) - v11 + 8616;
      *(_QWORD *)(a1 + 3368) = v11;
      goto LABEL_6;
    }
    v11 = v9 - 1;
    v13 = *(_QWORD *)(a1 + 9736);
    if (v13 == 1)
    {
      if (*(_BYTE *)(a1 + 8616) == 47)
      {
        strlcpy((char *)(a1 + 8617), v10, 0x3FFuLL);
        goto LABEL_12;
      }
    }
    else if (!v13)
    {
      __strlcpy_chk();
LABEL_12:
      --v9;
LABEL_15:
      *(_QWORD *)(a1 + 3352) = *(_QWORD *)(a1 + 9736) + v9;
      goto LABEL_5;
    }
    if ((unint64_t)(v13 + v9) > 0x3FF)
    {
      a2 = 63;
      goto LABEL_5;
    }
    *(_BYTE *)(a1 + 8616 + v13) = 47;
    strlcpy((char *)(a1 + 8616 + *(_QWORD *)(a1 + 9736) + 1), v10, 1023 - *(_QWORD *)(a1 + 9736));
    goto LABEL_15;
  }
LABEL_6:
  *(_DWORD *)(a1 + 3384) = a2;
  *(_QWORD *)(a1 + 3392) = a3;
  *(_DWORD *)(a1 + 3344) = *(_DWORD *)(a1 + 9696) - 1;
  return a2;
}

uint64_t cleanupAfterNoPush(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unsigned int v3;
  int v4;
  uint64_t v5;
  unsigned int v6;
  int v7;
  uint64_t v8;
  int v9;

  if (a2 != -1)
  {
    v2 = result;
    if (!*(_DWORD *)(result + 9708))
    {
      v3 = a2;
      v4 = *(_DWORD *)(result + 9696);
      if (v4)
      {
        v5 = *(_QWORD *)(*(_QWORD *)(result + 9688) + 8 * (v4 - 1));
        if (v5)
          MEMORY[0x1BCCB1484](*(unsigned int *)(v5 + 48));
      }
      if ((v3 & 0x80000000) == 0)
      {
        do
          v6 = __ldxr(&gFDCount);
        while (__stxr(v6 - 1, &gFDCount));
        if (v3 <= 0x7FF)
        {
          v7 = *(_DWORD *)(v2 + 9752);
          *(_DWORD *)(v2 + 9752) = v7 - 1;
          v8 = v2 + 4 * v3;
          v9 = *(_DWORD *)(v8 + 9756);
          if (v9 < 0 || v7 <= 0)
            __assert_rtn("cleanupAfterNoPush", "fsi.c", 776, "iterator->fdArray[(int)fileReference] >= 0 && iterator->fdCount >= 0");
          if (v9)
            *(_DWORD *)(v8 + 9756) = -v9;
        }
      }
      return close(v3);
    }
  }
  return result;
}

_DWORD *finishChildList(_DWORD *result)
{
  _DWORD *v1;
  int v2;
  _QWORD *v3;
  size_t v4;
  size_t v5;
  void *v6;
  _QWORD __compar[5];

  if (*((_QWORD *)result + 1208))
  {
    v1 = result;
    result = (_DWORD *)*((_QWORD *)result + 1209);
    if (!result
      || (result = (_DWORD *)(*((uint64_t (**)(_DWORD *, _DWORD *))result + 2))(result, v1), (_DWORD)result))
    {
      v2 = v1[2424];
      if (v2)
        v3 = *(_QWORD **)(*((_QWORD *)v1 + 1211) + 8 * (v2 - 1));
      else
        v3 = 0;
      v4 = v3[5];
      v5 = v3[3];
      if (v4)
      {
        if (v4 < v5)
        {
          if (!*v3)
            __assert_rtn("finishChildList", "fsi.c", 574, "tos->currentItem!=0");
          if (*v3 != *(_QWORD *)(v3[4] + 8 * v4 - 8))
            __assert_rtn("finishChildList", "fsi.c", 575, "tos->currentItem == tos->children[tos->currentChild-1]");
        }
      }
      else if (v5)
      {
        v6 = (void *)*((_QWORD *)v1 + 1206);
        __compar[0] = MEMORY[0x1E0C809B0];
        __compar[1] = 0x40000000;
        __compar[2] = __finishChildList_block_invoke;
        __compar[3] = &__block_descriptor_tmp_28_7782;
        __compar[4] = v1;
        qsort_b(v6, v5, 8uLL, __compar);
        result = SStackPushData(*((uint64_t **)v1 + 1210), 8 * v3[3], *((const void **)v1 + 1206));
        v3[4] = result;
        if (*v3)
          __assert_rtn("finishChildList", "fsi.c", 564, "tos->currentItem==0");
        if (v3[5])
          __assert_rtn("finishChildList", "fsi.c", 565, "tos->currentChild==0");
        v3[5] = 1;
        *v3 = *(_QWORD *)result;
      }
      else if (*v3)
      {
        __assert_rtn("finishChildList", "fsi.c", 568, "tos->currentItem==0");
      }
      v3[1] = v3[4];
    }
  }
  return result;
}

uint64_t __finishChildList_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 9664) + 16))();
}

uint64_t __path_bundle_index_block_invoke_7791()
{
  uint64_t result;

  result = open("/System/Library", 4);
  path_bundle_index_sDummyFD_7790 = result;
  return result;
}

CFMutableDictionaryRef __initBestLanguageDict_block_invoke()
{
  CFMutableDictionaryRef result;
  CFDictionaryKeyCallBacks v1;

  memset(&v1, 0, 32);
  *(_OWORD *)&v1.equal = xmmword_1E6E35C20;
  result = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, &v1, 0);
  sBestLanguageDictionary = (uint64_t)result;
  return result;
}

BOOL BestLanguageDictionaryEqualCallBack(unsigned __int16 *a1, unsigned __int16 *a2)
{
  uint64_t v2;
  unint64_t v5;
  const char **v6;
  const char **v7;
  uint64_t v8;
  BOOL v9;
  uint64_t v10;
  uint64_t v11;

  v2 = *a1;
  if ((_DWORD)v2 != *a2)
    return 0;
  v5 = a1[1];
  if ((_DWORD)v5 != a2[1])
    return 0;
  if (*a1)
  {
    v6 = (const char **)*((_QWORD *)a1 + 1);
    v7 = (const char **)*((_QWORD *)a2 + 1);
    while (!strcmp(*v6, *v7))
    {
      ++v7;
      ++v6;
      if (!--v2)
        goto LABEL_7;
    }
    return 0;
  }
LABEL_7:
  if ((_DWORD)v5)
  {
    v8 = 0;
    v9 = 0;
    v10 = *((_QWORD *)a1 + 2);
    v11 = *((_QWORD *)a2 + 2);
    do
    {
      if (strcmp(*(const char **)(v10 + 8 * v8), *(const char **)(v11 + 8 * v8)))
        break;
      v9 = ++v8 >= v5;
    }
    while (v5 != v8);
  }
  else
  {
    return 1;
  }
  return v9;
}

uint64_t BestLanguageDictionaryHashCallBack(int *a1)
{
  return *a1;
}

uint64_t fd_resetDir(int a1)
{
  uint64_t result;

  result = MEMORY[0x1BCCB1484]();
  if ((a1 & 0x80000000) == 0)
    return close(a1);
  return result;
}

uint64_t prot_pwrite_guarded(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  int *v12;
  BOOL v13;

  v9 = 0;
  do
  {
    while (1)
    {
      v10 = guarded_pwrite_np();
      if ((v10 & 0x8000000000000000) != 0)
        break;
      v9 += v10;
      v13 = a4 > v10;
      a4 -= v10;
      if (!v13)
        return v9;
      a3 += v10;
      a5 += v10;
    }
    v11 = g_prot_error_callback;
    if (!g_prot_error_callback)
      break;
    v12 = __error();
  }
  while (((*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t))(v11 + 16))(v11, a1, *v12, 5) & 1) != 0);
  return -1;
}

uint64_t _fd_ftruncate_guarded(uint64_t a1, uint64_t a2, off_t a3)
{
  off_t v6;
  uint64_t v7;
  uint64_t result;
  int v9;
  uint64_t v10;
  int *v11;
  int v12;
  const char *v13;
  BOOL v14;
  uint8_t buf[4];
  int v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  off_t v20;
  __int16 v21;
  int v22;
  _BYTE v23[1024];
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if ((gDisablePreallocate & 1) == 0)
  {
    v6 = lseek(a1, 0, 2);
    v7 = a3 - v6;
    if (a3 > v6 && v7 > *MEMORY[0x1E0C85AD8])
    {
      ci_preallocate(a1, v7);
      if (prot_pwrite_guarded(a1, a2, (uint64_t)"", 1uLL, a3 - 1) == 1)
        return 0;
    }
  }
  while (1)
  {
    result = ftruncate(a1, a3);
    if ((_DWORD)result != -1)
      break;
    if (*__error() == 22)
    {
      result = ftruncate(a1, a3);
      if ((_DWORD)result != -1)
        break;
    }
    v9 = *__error();
    v10 = g_prot_error_callback;
    if (g_prot_error_callback)
    {
      v11 = __error();
      if (((*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t))(v10 + 16))(v10, a1, *v11, 7) & 1) != 0)
        continue;
    }
    bzero(v23, 0x400uLL);
    v12 = fcntl(a1, 50, v23);
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      v13 = "";
      if (v23[0])
        v14 = v12 < 0;
      else
        v14 = 1;
      *(_DWORD *)buf = 67109890;
      if (!v14)
        v13 = v23;
      v16 = a1;
      v17 = 2080;
      v18 = v13;
      v19 = 2048;
      v20 = a3;
      v21 = 1024;
      v22 = v9;
      _os_log_error_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "ftruncate(%d %s, %lld) error:%d", buf, 0x22u);
    }
    *__error() = v9;
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t __isQUEnabled_block_invoke()
{
  uint64_t result;

  result = _os_feature_enabled_impl();
  if ((_DWORD)result)
    isQUEnabled_quSupportedBundles = 1;
  return result;
}

uint64_t __isLLMEnabled_block_invoke()
{
  uint64_t result;

  result = _os_feature_enabled_impl();
  if ((_DWORD)result)
    isLLMEnabled_llmSupportedBundles = 1;
  return result;
}

_DWORD *SStackPushData(uint64_t *a1, size_t a2, const void *a3)
{
  uint64_t v6;
  _DWORD *v7;
  _DWORD *v8;
  _QWORD *v9;

  v6 = ((_DWORD)a2 + 3) & 0xFFFFFFFC;
  v7 = SQueueOpenPushData(*a1, v6 + 8);
  *v7 = a2 + 4;
  v8 = v7 + 1;
  if (a3)
    memcpy(v7 + 1, a3, a2);
  *(_DWORD *)((char *)v8 + v6) = 0;
  v9 = (_QWORD *)*a1;
  v9[6] = *(_QWORD *)(*a1 + 48) + v6 + 4;
  *(_QWORD *)(v9[4] + 24) += v6 + 4;
  v9[1] += v6 + 4;
  return v8;
}

unint64_t SStackNextData(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v2 = a2 + (((*(_DWORD *)(a2 - 4) - 4) + 3) & 0x1FFFFFFFCLL);
  if (*(_DWORD *)v2)
    return v2 + 4;
  v4 = *(_QWORD *)(*(_QWORD *)a1 + 24);
  if (v4)
  {
    v5 = *(_QWORD *)(*(_QWORD *)a1 + 24);
    while (1)
    {
      v6 = v5 + 32;
      if (v5 + 32 <= v2 && v5 + (unint64_t)*(unsigned int *)(v5 + 16) + 32 >= v2)
        break;
      v5 = *(_QWORD *)(v5 + 8);
      if (!v5)
        goto LABEL_8;
    }
    if (v5 == v4)
    {
      v6 = *(_QWORD *)(*(_QWORD *)a1 + 40);
      v5 = *(_QWORD *)(*(_QWORD *)a1 + 24);
    }
    if (v6 + *(_QWORD *)(v5 + 24) <= v2)
    {
      v2 = *(_QWORD *)(v5 + 8);
      if (v2)
      {
        v7 = *(_QWORD *)(v2 + 24);
        v2 += 32;
        if (!v7)
          v2 = 0;
      }
    }
  }
  else
  {
LABEL_8:
    v2 = 0;
  }
  if (v2)
    return v2 + 4;
  else
    return 0;
}

void registerForCloning(int a1, int a2)
{
  const __CFAllocator *v3;
  CFNumberRef v4;
  __CFSet *Mutable;
  int valuePtr;

  valuePtr = a1;
  if (registerForCloning_once != -1)
    dispatch_once(&registerForCloning_once, &__block_literal_global_7905);
  v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v4 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, &valuePtr);
  pthread_mutex_lock(&registeredFdsLock);
  if (a2)
  {
    Mutable = (__CFSet *)registeredCloneFds;
    if (!registeredCloneFds)
    {
      Mutable = CFSetCreateMutable(v3, 0, 0);
      registeredCloneFds = (uint64_t)Mutable;
    }
    CFSetAddValue(Mutable, v4);
  }
  pthread_mutex_unlock(&registeredFdsLock);
  CFRelease(v4);
}

void unregisterForCloning(int a1)
{
  CFNumberRef v1;
  int valuePtr;

  valuePtr = a1;
  v1 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, &valuePtr);
  pthread_mutex_lock(&registeredFdsLock);
  if (registeredCloneFds && CFSetContainsValue((CFSetRef)registeredCloneFds, v1))
    CFSetRemoveValue((CFMutableSetRef)registeredCloneFds, v1);
  pthread_mutex_unlock(&registeredFdsLock);
  CFRelease(v1);
}

BOOL isRegisteredForCloning(int a1)
{
  CFNumberRef v1;
  _BOOL8 v2;
  int valuePtr;

  valuePtr = a1;
  v1 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, &valuePtr);
  pthread_mutex_lock(&registeredFdsLock);
  if (registeredCloneFds)
    v2 = CFSetContainsValue((CFSetRef)registeredCloneFds, v1) != 0;
  else
    v2 = 0;
  pthread_mutex_unlock(&registeredFdsLock);
  CFRelease(v1);
  return v2;
}

uint64_t _copyFile(int a1, const char *a2, int a3, const char *a4, _DWORD *a5, off_t a6)
{
  int v6;
  NSObject *v7;
  os_log_type_t v8;
  char *v9;
  void *v10;
  char *v11;
  uint64_t v12;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  off_t st_size;
  uint64_t v22;
  off_t v23;
  ssize_t v24;
  int64_t v25;
  char v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int64_t v30;
  int v31;
  NSObject *v32;
  NSObject *v33;
  int v34;
  const char *v35;
  NSObject *v36;
  uint32_t v37;
  NSObject *v38;
  uint64_t v39;
  int v40;
  NSObject *v42;
  int v43;
  const char *v44;
  NSObject *v45;
  uint32_t v46;
  NSObject *v47;
  int v48;
  NSObject *v49;
  NSObject *v50;
  int v51;
  int v52;
  NSObject *v53;
  os_log_type_t v54;
  NSObject *v55;
  int v56;
  int v57;
  char *v58;
  char *v59;
  const char *v60;
  uint64_t v61;
  unsigned int v62;
  char *v63;
  off_t v64;
  char *v65;
  void *__buf;
  uint64_t v67;
  uint64_t v68;
  stat v69;
  uint8_t buf[4];
  const char *v71;
  __int16 v72;
  int v73;
  __int16 v74;
  _BYTE v75[18];
  uint64_t v76;

  v76 = *MEMORY[0x1E0C80C00];
  memset(&v69, 0, sizeof(v69));
  v67 = 0;
  v68 = 0;
  if (*a5)
  {
    v6 = *__error();
    v7 = _SILogForLogForCategory(10);
    v8 = 2 * (dword_1EF19FCB4 < 4);
    if (os_log_type_enabled(v7, v8))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1B8270000, v7, v8, "canceled", buf, 2u);
    }
    v9 = 0;
    v10 = 0;
    v11 = 0;
    LODWORD(v12) = -1;
    goto LABEL_32;
  }
  v11 = (char *)fd_create_protected(a1, a2, 0, 0);
  v18 = _fd_acquire_fd((uint64_t)v11, &v68);
  v12 = v18;
  if (!v11 || (_DWORD)v18 == -1)
  {
    v6 = *__error();
    v33 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
    {
LABEL_31:
      v9 = 0;
      v10 = 0;
LABEL_32:
      v20 = 0xFFFFFFFFLL;
LABEL_33:
      v39 = 0;
      *__error() = v6;
      goto LABEL_34;
    }
    v34 = *__error();
    *(_DWORD *)buf = 136315906;
    v71 = "_copyFile";
    v72 = 1024;
    v73 = 126;
    v74 = 1024;
    *(_DWORD *)v75 = v34;
    *(_WORD *)&v75[4] = 2080;
    *(_QWORD *)&v75[6] = a2;
    v35 = "%s:%d: error (%d) opening %s\n";
    v36 = v33;
    v37 = 34;
LABEL_58:
    _os_log_error_impl(&dword_1B8270000, v36, OS_LOG_TYPE_ERROR, v35, buf, v37);
    goto LABEL_31;
  }
  if (fstat(v18, &v69) == -1)
  {
    v6 = *__error();
    v38 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
      goto LABEL_31;
    v51 = *__error();
    *(_DWORD *)buf = 136315650;
    v71 = "_copyFile";
    v72 = 1024;
    v73 = 130;
    v74 = 1024;
    *(_DWORD *)v75 = v51;
    v35 = "%s:%d: fstat error (%d)\n";
    v36 = v38;
    v37 = 24;
    goto LABEL_58;
  }
  v9 = (char *)fd_create_protected(a3, a4, 536872450, 0);
  v19 = _fd_acquire_fd((uint64_t)v9, &v67);
  v20 = v19;
  if (!v9 || (_DWORD)v19 == -1)
  {
    v6 = *__error();
    v42 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
    {
LABEL_44:
      v10 = 0;
      goto LABEL_33;
    }
    v43 = *__error();
    *(_DWORD *)buf = 136315906;
    v71 = "_copyFile";
    v72 = 1024;
    v73 = 137;
    v74 = 1024;
    *(_DWORD *)v75 = v43;
    *(_WORD *)&v75[4] = 2080;
    *(_QWORD *)&v75[6] = a4;
    v44 = "%s:%d: error (%d) opening %s\n";
    v45 = v42;
    v46 = 34;
LABEL_60:
    _os_log_error_impl(&dword_1B8270000, v45, OS_LOG_TYPE_ERROR, v44, buf, v46);
    goto LABEL_44;
  }
  if (_fd_ftruncate_guarded(v19, (uint64_t)&v67, v69.st_size) == -1)
  {
    v6 = *__error();
    v47 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
      goto LABEL_44;
    v52 = *__error();
    *(_DWORD *)buf = 136315650;
    v71 = "_copyFile";
    v72 = 1024;
    v73 = 146;
    v74 = 1024;
    *(_DWORD *)v75 = v52;
    v44 = "%s:%d: ftruncate error (%d)\n";
    v45 = v47;
    v46 = 24;
    goto LABEL_60;
  }
  v65 = v9;
  fcntl(v12, 48, 1);
  fcntl(v12, 76, 1);
  fcntl(v20, 48, 1);
  fcntl(v20, 76, 1);
  __buf = malloc_type_malloc(0x10000uLL, 0xE2BF8B06uLL);
  st_size = v69.st_size;
  if (v69.st_size <= a6)
  {
    v22 = 0;
    goto LABEL_50;
  }
  v22 = 0;
  v23 = a6;
  v63 = v11;
  v64 = a6;
  v62 = v12;
  while (2)
  {
    if (*a5)
    {
      v48 = *__error();
      v53 = _SILogForLogForCategory(10);
      v54 = 2 * (dword_1EF19FCB4 < 4);
      if (os_log_type_enabled(v53, v54))
      {
        *(_WORD *)buf = 0;
LABEL_67:
        _os_log_impl(&dword_1B8270000, v53, v54, "canceled", buf, 2u);
      }
LABEL_49:
      a6 = v64;
      *__error() = v48;
      st_size = v69.st_size;
      break;
    }
    v24 = prot_pread(v12, __buf, 0x10000uLL, v23);
    if (v24 == -1)
    {
      v48 = *__error();
      v55 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
      {
        v56 = *__error();
        *(_DWORD *)buf = 136315650;
        v71 = "_copyFile";
        v72 = 1024;
        v73 = 169;
        v74 = 1024;
        *(_DWORD *)v75 = v56;
        _os_log_error_impl(&dword_1B8270000, v55, OS_LOG_TYPE_ERROR, "%s:%d: read error (%d)\n", buf, 0x18u);
      }
      goto LABEL_49;
    }
    if (*a5)
    {
      v48 = *__error();
      v53 = _SILogForLogForCategory(10);
      v54 = 2 * (dword_1EF19FCB4 < 4);
      if (os_log_type_enabled(v53, v54))
      {
        *(_WORD *)buf = 0;
        goto LABEL_67;
      }
      goto LABEL_49;
    }
    v25 = v24;
    v26 = 1;
    v27 = (uint64_t)__buf;
    while (1)
    {
      v28 = prot_pwrite_guarded(v20, (uint64_t)&v67, v27, v25, v23);
      if (v28 == -1)
      {
        v48 = *__error();
        v49 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
        {
          v57 = *__error();
          *(_DWORD *)buf = 136315650;
          v71 = "_copyFile";
          v72 = 1024;
          v73 = 185;
          v74 = 1024;
          *(_DWORD *)v75 = v57;
          _os_log_error_impl(&dword_1B8270000, v49, OS_LOG_TYPE_ERROR, "%s:%d: write error (%d)\n", buf, 0x18u);
        }
        v11 = v63;
        LODWORD(v12) = v62;
        goto LABEL_49;
      }
      v29 = v28;
      v30 = v25 - v28;
      if (v25 < v28)
      {
        v58 = __si_assert_copy_extra_268();
        v59 = v58;
        v60 = "";
        if (v58)
          v60 = v58;
        __message_assert(v58, "copyFile.c", 188, "wLen <= actual", v60);
        free(v59);
        if (__valid_fs(-1))
          v61 = 2989;
        else
          v61 = 3072;
        *(_DWORD *)v61 = -559038737;
        abort();
      }
      v22 += v28;
      if (v25 <= v28)
        break;
      if ((v28 != 0) | v26 & 1)
      {
        v26 &= v28 != 0;
      }
      else
      {
        v31 = *__error();
        v32 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315394;
          v71 = "_copyFile";
          v72 = 1024;
          v73 = 194;
          _os_log_error_impl(&dword_1B8270000, v32, OS_LOG_TYPE_ERROR, "%s:%d: write failed", buf, 0x12u);
        }
        v26 = 0;
        *__error() = v31;
      }
      v23 += v29;
      v27 += v29;
      v25 = v30;
    }
    v23 += v25;
    st_size = v69.st_size;
    v11 = v63;
    a6 = v64;
    v12 = v62;
    if (v23 < v69.st_size)
      continue;
    break;
  }
LABEL_50:
  v9 = v65;
  if (v22 + a6 == st_size)
  {
    v39 = 1;
  }
  else
  {
    if (!*a5)
    {
      v6 = *__error();
      v50 = _SILogForLogForCategory(0);
      v10 = __buf;
      if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315906;
        v71 = "_copyFile";
        v72 = 1024;
        v73 = 208;
        v74 = 2048;
        *(_QWORD *)v75 = v69.st_size;
        *(_WORD *)&v75[8] = 2048;
        *(_QWORD *)&v75[10] = v22;
        _os_log_error_impl(&dword_1B8270000, v50, OS_LOG_TYPE_ERROR, "%s:%d: write failed - expected:%lld, actual: %lld", buf, 0x26u);
      }
      goto LABEL_33;
    }
    v39 = 0;
  }
  v10 = __buf;
LABEL_34:
  v40 = *__error();
  free(v10);
  prot_fsync(v20, 0);
  if ((v12 & 0x80000000) == 0)
    _fd_release_fd(v11, v12, 0, v68);
  fd_release(v11);
  if ((v20 & 0x80000000) == 0)
    _fd_release_fd(v9, v20, 0, v67);
  fd_release(v9);
  if (v40)
    *__error() = v40;
  return v39;
}

uint64_t copyFileFallback(uint64_t a1, const char *a2, int a3, const char *a4, _DWORD *a5, char a6, int a7)
{
  size_t v14;
  size_t v15;
  int v16;
  NSObject *v17;
  int v18;
  int v19;
  std::error_code *v20;
  uint64_t v21;
  int v22;
  int v23;
  int v24;
  int v25;
  NSObject *v26;
  int v27;
  const char *v28;
  NSObject *v29;
  NSObject *v30;
  int *v31;
  uint64_t result;
  int v33;
  int v34;
  NSObject *v35;
  int v36;
  int v37;
  char v38;
  char *to;
  uint8_t buf[4];
  char *v41;
  __int16 v42;
  _BYTE v43[10];
  __int16 v44;
  _BYTE v45[18];
  std::__fs::filesystem::path __to;
  char __s[1024];
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  if ((_DWORD)a1 != a3 || !isRegisteredForCloning(a1) || !a7)
    return _copyFile(a1, a2, a3, a4, a5, 0);
  bzero(__s, 0x400uLL);
  bzero(&__to, 0x400uLL);
  if (fcntl(a1, 50, __s) < 0 || !__s[0])
  {
    v24 = *__error();
    v25 = *__error();
    v26 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
LABEL_29:
      *__error() = v25;
      v31 = __error();
      result = 0;
      *v31 = v24;
      return result;
    }
    v27 = *__error();
    *(_DWORD *)buf = 136316162;
    v41 = "copyFileFallback";
    v42 = 1024;
    *(_DWORD *)v43 = 348;
    *(_WORD *)&v43[4] = 1024;
    *(_DWORD *)&v43[6] = v27;
    v44 = 1024;
    *(_DWORD *)v45 = a1;
    *(_WORD *)&v45[4] = 2080;
    *(_QWORD *)&v45[6] = a2;
    v28 = "%s:%d: copy file error(%d) resolving source fd %d for %s";
    v29 = v26;
LABEL_39:
    _os_log_error_impl(&dword_1B8270000, v29, OS_LOG_TYPE_ERROR, v28, buf, 0x28u);
    goto LABEL_29;
  }
  v14 = strlen(__s);
  snprintf(&__s[v14], 1024 - v14, "/%s", a2);
  if (fcntl(a1, 50, &__to) < 0 || !__to.__pn_.__r_.__value_.__s.__data_[0])
  {
    v24 = *__error();
    v25 = *__error();
    v30 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
      goto LABEL_29;
    v36 = *__error();
    *(_DWORD *)buf = 136316162;
    v41 = "copyFileFallback";
    v42 = 1024;
    *(_DWORD *)v43 = 343;
    *(_WORD *)&v43[4] = 1024;
    *(_DWORD *)&v43[6] = v36;
    v44 = 1024;
    *(_DWORD *)v45 = a1;
    *(_WORD *)&v45[4] = 2080;
    *(_QWORD *)&v45[6] = a4;
    v28 = "%s:%d: copy file error(%d) resolving dest fd %d for %s";
    v29 = v30;
    goto LABEL_39;
  }
  v38 = a6;
  v15 = strlen((const char *)&__to);
  snprintf((char *)&__to + v15, 1024 - v15, "/%s", a4);
  v16 = *__error();
  v17 = _SILogForLogForCategory(7);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315394;
    v41 = __s;
    v42 = 2080;
    *(_QWORD *)v43 = &__to;
    _os_log_impl(&dword_1B8270000, v17, OS_LOG_TYPE_DEFAULT, "copy file %s to %s", buf, 0x16u);
  }
  *__error() = v16;
  while (1)
  {
    v18 = open((const char *)&__to, 0);
    to = 0;
    asprintf(&to, "%s.tmp", (const char *)&__to);
    unlink(to);
    v19 = copyfile(__s, to, 0, 0x20C0000u);
    v21 = *__error();
    if ((_DWORD)v21 != 45)
      goto LABEL_14;
    v22 = open(__s, 0);
    if (v22 != -1)
    {
      close(v22);
      v21 = 45;
LABEL_14:
      if (v19)
        goto LABEL_16;
LABEL_15:
      rename((const std::__fs::filesystem::path *)to, &__to, v20);
      v19 = v23;
      v21 = *__error();
      goto LABEL_16;
    }
    v21 = *__error();
    if (!v19)
      goto LABEL_15;
LABEL_16:
    free(to);
    if (v18 != -1)
      close(v18);
    if (v19 != -1)
      break;
    if (!g_prot_error_callback
      || ((*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(g_prot_error_callback + 16))(g_prot_error_callback, a1, v21, 1) & 1) == 0)
    {
      *__error() = v21;
      *__error() = v21;
      if (!g_prot_error_callback
        || ((*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(g_prot_error_callback + 16))(g_prot_error_callback, a1, v21, 1) & 1) == 0)
      {
        *__error() = v21;
        goto LABEL_32;
      }
    }
  }
  *__error() = v21;
  if (!v19)
    return 1;
LABEL_32:
  v33 = *__error();
  v34 = *__error();
  v35 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
  {
    v37 = *__error();
    *(_DWORD *)buf = 136316162;
    v41 = "copyFileFallback";
    v42 = 1024;
    *(_DWORD *)v43 = 337;
    *(_WORD *)&v43[4] = 1024;
    *(_DWORD *)&v43[6] = v37;
    v44 = 2080;
    *(_QWORD *)v45 = __s;
    *(_WORD *)&v45[8] = 2080;
    *(_QWORD *)&v45[10] = &__to;
    _os_log_error_impl(&dword_1B8270000, v35, OS_LOG_TYPE_ERROR, "%s:%d: copy file error(%d) (%s) (%s)", buf, 0x2Cu);
  }
  *__error() = v34;
  *__error() = v33;
  if ((v38 & 1) == 0)
    return 0;
  return _copyFile(a1, a2, a3, a4, a5, 0);
}

void si_activity_journal_init(uint64_t a1, _DWORD *a2)
{
  uint64_t v4;
  unint64_t v5;
  double Current;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _OWORD v10[2];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_QWORD *)a1 = a2;
  if (a2)
  {
    v4 = fd_lseek(a2, 0, 2);
    if (v4 >= 1073741825)
    {
      v5 = v4;
      fprintf((FILE *)*MEMORY[0x1E0C80C10], "kSIActivityJournalReset: Journal size %lld is > %lld\n", v4, 0x40000000);
      fd_zero_truncate((uint64_t)a2);
      memset(v10, 0, sizeof(v10));
      Current = CFAbsoluteTimeGetCurrent();
      v7 = (unint64_t)Current;
      if ((unint64_t)Current > 0x7F)
      {
        if (v7 >> 14)
        {
          if (v7 >> 21)
          {
            if (v7 >> 28)
            {
              if (v7 >> 35)
              {
                if (v7 >> 42)
                {
                  if (v7 >> 49)
                  {
                    if (HIBYTE(v7))
                    {
                      LOBYTE(v10[0]) = -1;
                      *(_QWORD *)((char *)v10 + 1) = (unint64_t)Current;
                      v8 = 9;
                    }
                    else
                    {
                      LOBYTE(v10[0]) = -2;
                      BYTE1(v10[0]) = (unint64_t)Current >> 48;
                      BYTE2(v10[0]) = (unsigned __int16)((unint64_t)Current >> 32) >> 8;
                      BYTE3(v10[0]) = (unint64_t)Current >> 32;
                      BYTE4(v10[0]) = (unint64_t)Current >> 24;
                      BYTE5(v10[0]) = (unint64_t)Current >> 16;
                      BYTE6(v10[0]) = (unsigned __int16)(unint64_t)Current >> 8;
                      v8 = 8;
                      BYTE7(v10[0]) = (unint64_t)Current;
                    }
                  }
                  else
                  {
                    LOBYTE(v10[0]) = BYTE6(v7) | 0xFC;
                    BYTE1(v10[0]) = (unsigned __int16)((unint64_t)Current >> 32) >> 8;
                    BYTE2(v10[0]) = (unint64_t)Current >> 32;
                    BYTE3(v10[0]) = (unint64_t)Current >> 24;
                    BYTE4(v10[0]) = (unint64_t)Current >> 16;
                    BYTE5(v10[0]) = (unsigned __int16)(unint64_t)Current >> 8;
                    v8 = 7;
                    BYTE6(v10[0]) = (unint64_t)Current;
                  }
                }
                else
                {
                  LOBYTE(v10[0]) = BYTE5(v7) | 0xF8;
                  BYTE1(v10[0]) = (unint64_t)Current >> 32;
                  BYTE2(v10[0]) = (unint64_t)Current >> 24;
                  BYTE3(v10[0]) = (unint64_t)Current >> 16;
                  BYTE4(v10[0]) = (unsigned __int16)(unint64_t)Current >> 8;
                  BYTE5(v10[0]) = (unint64_t)Current;
                  v8 = 6;
                }
              }
              else
              {
                LOBYTE(v10[0]) = BYTE4(v7) | 0xF0;
                BYTE1(v10[0]) = (unint64_t)Current >> 24;
                BYTE2(v10[0]) = (unint64_t)Current >> 16;
                BYTE3(v10[0]) = (unsigned __int16)(unint64_t)Current >> 8;
                BYTE4(v10[0]) = (unint64_t)Current;
                v8 = 5;
              }
            }
            else
            {
              LOBYTE(v10[0]) = BYTE3(v7) | 0xE0;
              BYTE1(v10[0]) = (unint64_t)Current >> 16;
              BYTE2(v10[0]) = (unsigned __int16)(unint64_t)Current >> 8;
              BYTE3(v10[0]) = (unint64_t)Current;
              v8 = 4;
            }
          }
          else
          {
            LOBYTE(v10[0]) = BYTE2(v7) | 0xC0;
            BYTE1(v10[0]) = (unsigned __int16)(unint64_t)Current >> 8;
            BYTE2(v10[0]) = (unint64_t)Current;
            v8 = 3;
          }
        }
        else
        {
          LOBYTE(v10[0]) = BYTE1(v7) | 0x80;
          BYTE1(v10[0]) = (unint64_t)Current;
          v8 = 2;
        }
      }
      else
      {
        LOBYTE(v10[0]) = (unint64_t)Current;
        v8 = 1;
      }
      v9 = v2_writeVInt64_7950((uint64_t)v10, v8, v5);
      *((_BYTE *)v10 + v9) = 0;
      activityJournalWrite(a1, 55, v10, v9 + 1);
    }
  }
}

uint64_t v2_writeVInt64_7950(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v3;
  _BYTE *v4;
  _BYTE *v5;
  _BYTE *v6;
  _BYTE *v7;
  uint64_t v8;
  uint64x2_t v9;
  int16x8_t v10;
  uint64_t v11;
  uint64x2_t v12;
  int16x8_t v13;
  uint64_t v14;
  _BYTE *v15;
  uint64x2_t v16;
  int16x8_t v17;

  if (a3 > 0x7F)
  {
    if (a3 >> 14)
    {
      if (a3 >> 21)
      {
        if (a3 >> 28)
        {
          if (a3 >> 35)
          {
            if (a3 >> 42)
            {
              if (a3 >> 49)
              {
                v14 = a2 + 1;
                if (HIBYTE(a3))
                {
                  *(_BYTE *)(a1 + a2) = -1;
                  *(_QWORD *)(a1 + v14) = a3;
                  return a2 + 9;
                }
                else
                {
                  v15 = (_BYTE *)(a1 + a2);
                  *v15 = -2;
                  v16 = (uint64x2_t)vdupq_n_s64(a3);
                  v17 = (int16x8_t)vshlq_u64(v16, (uint64x2_t)xmmword_1B8631C40);
                  *(int32x2_t *)v16.i8 = vmovn_s64((int64x2_t)vshlq_u64(v16, (uint64x2_t)xmmword_1B8631C50));
                  *(int32x2_t *)v17.i8 = vmovn_s64((int64x2_t)v17);
                  v17.i16[1] = v17.i16[2];
                  v17.i16[2] = v16.i16[0];
                  v17.i16[3] = v16.i16[2];
                  *(_DWORD *)(a1 + v14) = vmovn_s16(v17).u32[0];
                  v15[5] = BYTE2(a3);
                  v15[6] = BYTE1(a3);
                  v3 = a2 + 8;
                  v15[7] = a3;
                }
              }
              else
              {
                v11 = a1 + a2;
                *(_BYTE *)v11 = BYTE6(a3) | 0xFC;
                v12 = (uint64x2_t)vdupq_n_s64(a3);
                v13 = (int16x8_t)vshlq_u64(v12, (uint64x2_t)xmmword_1B8631C60);
                *(int32x2_t *)v12.i8 = vmovn_s64((int64x2_t)vshlq_u64(v12, (uint64x2_t)xmmword_1B8631C70));
                *(int32x2_t *)v13.i8 = vmovn_s64((int64x2_t)v13);
                v13.i16[1] = v13.i16[2];
                v13.i16[2] = v12.i16[0];
                v13.i16[3] = v12.i16[2];
                *(_DWORD *)(v11 + 1) = vmovn_s16(v13).u32[0];
                *(_BYTE *)(v11 + 5) = BYTE1(a3);
                v3 = a2 + 7;
                *(_BYTE *)(v11 + 6) = a3;
              }
            }
            else
            {
              v8 = a1 + a2;
              v9 = (uint64x2_t)vdupq_n_s64(a3);
              *(_BYTE *)v8 = BYTE5(a3) | 0xF8;
              v10 = (int16x8_t)vshlq_u64(v9, (uint64x2_t)xmmword_1B8631C50);
              *(int32x2_t *)v9.i8 = vmovn_s64((int64x2_t)vshlq_u64(v9, (uint64x2_t)xmmword_1B8631C80));
              *(int32x2_t *)v10.i8 = vmovn_s64((int64x2_t)v10);
              v10.i16[1] = v10.i16[2];
              v10.i16[2] = v9.i16[0];
              v10.i16[3] = v9.i16[2];
              *(_DWORD *)(v8 + 1) = vmovn_s16(v10).u32[0];
              v3 = a2 + 6;
              *(_BYTE *)(v8 + 5) = a3;
            }
          }
          else
          {
            v7 = (_BYTE *)(a1 + a2);
            *v7 = BYTE4(a3) | 0xF0;
            v7[1] = BYTE3(a3);
            v7[2] = BYTE2(a3);
            v7[3] = BYTE1(a3);
            v3 = a2 + 5;
            v7[4] = a3;
          }
        }
        else
        {
          v6 = (_BYTE *)(a1 + a2);
          *v6 = BYTE3(a3) | 0xE0;
          v6[1] = BYTE2(a3);
          v6[2] = BYTE1(a3);
          v3 = a2 + 4;
          v6[3] = a3;
        }
      }
      else
      {
        v5 = (_BYTE *)(a1 + a2);
        *v5 = BYTE2(a3) | 0xC0;
        v5[1] = BYTE1(a3);
        v3 = a2 + 3;
        v5[2] = a3;
      }
    }
    else
    {
      v4 = (_BYTE *)(a1 + a2);
      *v4 = BYTE1(a3) | 0x80;
      v3 = a2 + 2;
      v4[1] = a3;
    }
  }
  else
  {
    v3 = a2 + 1;
    *(_BYTE *)(a1 + a2) = a3;
  }
  return v3;
}

void SIActivityJournalOpen(uint64_t a1, int a2, unsigned int a3, unsigned int a4, unsigned int a5, unint64_t a6, unint64_t a7, unint64_t a8)
{
  os_unfair_lock_s *v15;
  unint64_t Current;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  char *v22;
  char *v23;
  char *v24;
  uint64_t v25;
  char *v26;
  char *v27;
  char *v28;
  char *v29;
  uint64_t v30;
  char *v31;
  char *v32;
  char *v33;
  char *v34;
  uint64_t v35;
  unsigned int v36;
  _OWORD v38[16];
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)a1)
  {
    v15 = (os_unfair_lock_s *)(a1 + 32);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 32));
    memset(v38, 0, sizeof(v38));
    Current = (unint64_t)CFAbsoluteTimeGetCurrent();
    v17 = getpid();
    if (v17 > 0x7F)
    {
      if (v17 >> 14)
      {
        if (v17 >> 21)
        {
          if (v17 >> 28)
          {
            LOBYTE(v38[0]) = -16;
            *(_DWORD *)((char *)v38 + 1) = v17;
            v18 = 5;
          }
          else
          {
            LOBYTE(v38[0]) = HIBYTE(v17) | 0xE0;
            BYTE1(v38[0]) = BYTE2(v17);
            BYTE2(v38[0]) = BYTE1(v17);
            BYTE3(v38[0]) = v17;
            v18 = 4;
          }
        }
        else
        {
          LOBYTE(v38[0]) = BYTE2(v17) | 0xC0;
          BYTE1(v38[0]) = BYTE1(v17);
          BYTE2(v38[0]) = v17;
          v18 = 3;
        }
      }
      else
      {
        LOBYTE(v38[0]) = BYTE1(v17) | 0x80;
        BYTE1(v38[0]) = v17;
        v18 = 2;
      }
    }
    else
    {
      LOBYTE(v38[0]) = v17;
      v18 = 1;
    }
    v19 = v2_writeVInt64_7950((uint64_t)v38, v18, Current);
    if (a3 > 0x7F)
    {
      if (a3 >> 14)
      {
        if (a3 >> 21)
        {
          if (a3 >> 28)
          {
            v24 = (char *)v38 + v19;
            *v24 = -16;
            *(_DWORD *)(v24 + 1) = a3;
            v20 = v19 + 5;
          }
          else
          {
            v23 = (char *)v38 + v19;
            *v23 = HIBYTE(a3) | 0xE0;
            v23[1] = BYTE2(a3);
            v23[2] = BYTE1(a3);
            v20 = v19 + 4;
            v23[3] = a3;
          }
        }
        else
        {
          v22 = (char *)v38 + v19;
          *v22 = BYTE2(a3) | 0xC0;
          v22[1] = BYTE1(a3);
          v20 = v19 + 3;
          v22[2] = a3;
        }
      }
      else
      {
        v21 = (char *)v38 + v19;
        *v21 = BYTE1(a3) | 0x80;
        v20 = v19 + 2;
        v21[1] = a3;
      }
    }
    else
    {
      v20 = v19 + 1;
      *((_BYTE *)v38 + v19) = a3;
    }
    if (a4 > 0x7F)
    {
      if (a4 >> 14)
      {
        if (a4 >> 21)
        {
          if (a4 >> 28)
          {
            v29 = (char *)v38 + v20;
            *v29 = -16;
            *(_DWORD *)(v29 + 1) = a4;
            v25 = v20 + 5;
          }
          else
          {
            v28 = (char *)v38 + v20;
            *v28 = HIBYTE(a4) | 0xE0;
            v28[1] = BYTE2(a4);
            v28[2] = BYTE1(a4);
            v25 = v20 + 4;
            v28[3] = a4;
          }
        }
        else
        {
          v27 = (char *)v38 + v20;
          *v27 = BYTE2(a4) | 0xC0;
          v27[1] = BYTE1(a4);
          v25 = v20 + 3;
          v27[2] = a4;
        }
      }
      else
      {
        v26 = (char *)v38 + v20;
        *v26 = BYTE1(a4) | 0x80;
        v25 = v20 + 2;
        v26[1] = a4;
      }
    }
    else
    {
      v25 = v20 + 1;
      *((_BYTE *)v38 + v20) = a4;
    }
    if (a5 > 0x7F)
    {
      if (a5 >> 14)
      {
        if (a5 >> 21)
        {
          if (a5 >> 28)
          {
            v34 = (char *)v38 + v25;
            *v34 = -16;
            *(_DWORD *)(v34 + 1) = a5;
            v30 = v25 + 5;
          }
          else
          {
            v33 = (char *)v38 + v25;
            *v33 = HIBYTE(a5) | 0xE0;
            v33[1] = BYTE2(a5);
            v33[2] = BYTE1(a5);
            v30 = v25 + 4;
            v33[3] = a5;
          }
        }
        else
        {
          v32 = (char *)v38 + v25;
          *v32 = BYTE2(a5) | 0xC0;
          v32[1] = BYTE1(a5);
          v30 = v25 + 3;
          v32[2] = a5;
        }
      }
      else
      {
        v31 = (char *)v38 + v25;
        *v31 = BYTE1(a5) | 0x80;
        v30 = v25 + 2;
        v31[1] = a5;
      }
    }
    else
    {
      v30 = v25 + 1;
      *((_BYTE *)v38 + v25) = a5;
    }
    if (a2 != 37)
    {
      v35 = v2_writeVInt64_7950((uint64_t)v38, v30, a6);
      v30 = v2_writeVInt64_7950((uint64_t)v38, v35, a7);
    }
    v36 = v2_writeVInt64_7950((uint64_t)v38, v30, a8);
    activityJournalWrite(a1, a2, v38, v36);
    os_unfair_lock_unlock(v15);
  }
}

void SIActivityJournalClose(os_unfair_lock_s *a1)
{
  os_unfair_lock_s *v2;
  CFAbsoluteTime Current;

  v2 = a1 + 8;
  os_unfair_lock_lock(a1 + 8);
  Current = CFAbsoluteTimeGetCurrent();
  activityJournalWriteVInt64((uint64_t)a1, 4, (unint64_t)Current);
  os_unfair_lock_unlock(v2);
}

void SIActivityJournalUnlinkJournal(os_unfair_lock_s *a1, uint64_t a2)
{
  char *v3;
  const char *v4;
  unsigned int v5;
  os_unfair_lock_s *v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  char v10;
  _OWORD v11[16];
  __int128 v12;
  __int128 v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  memset(v11, 0, sizeof(v11));
  v3 = fd_name(a2, (char *)v11, 0x100uLL);
  if (v3)
  {
    v4 = v3;
    if (!strncmp(v3, "journalAttr.", 0xCuLL))
    {
      v8 = atoi(v4 + 12);
      v6 = a1 + 8;
      os_unfair_lock_lock(a1 + 8);
      v12 = 0u;
      v13 = 0u;
      if (v8 > 0x7F)
      {
        if (v8 >> 14)
        {
          if (v8 >> 21)
          {
            if (v8 >> 28)
            {
              LOBYTE(v12) = -16;
              *(_DWORD *)((char *)&v12 + 1) = v8;
              v7 = 5;
            }
            else
            {
              LOBYTE(v12) = HIBYTE(v8) | 0xE0;
              BYTE1(v12) = BYTE2(v8);
              BYTE2(v12) = BYTE1(v8);
              BYTE3(v12) = v8;
              v7 = 4;
            }
          }
          else
          {
            LOBYTE(v12) = BYTE2(v8) | 0xC0;
            BYTE1(v12) = BYTE1(v8);
            BYTE2(v12) = v8;
            v7 = 3;
          }
        }
        else
        {
          LOBYTE(v12) = BYTE1(v8) | 0x80;
          BYTE1(v12) = v8;
          v7 = 2;
        }
      }
      else
      {
        LOBYTE(v12) = v8;
        v7 = 1;
      }
      v9 = (uint64_t)a1;
      v10 = 25;
    }
    else
    {
      if (strncmp(v4, "deferAttr.", 0xAuLL))
        return;
      v5 = atoi(v4 + 10);
      v6 = a1 + 8;
      os_unfair_lock_lock(a1 + 8);
      v12 = 0u;
      v13 = 0u;
      if (v5 > 0x7F)
      {
        if (v5 >> 14)
        {
          if (v5 >> 21)
          {
            if (v5 >> 28)
            {
              LOBYTE(v12) = -16;
              *(_DWORD *)((char *)&v12 + 1) = v5;
              v7 = 5;
            }
            else
            {
              LOBYTE(v12) = HIBYTE(v5) | 0xE0;
              BYTE1(v12) = BYTE2(v5);
              BYTE2(v12) = BYTE1(v5);
              BYTE3(v12) = v5;
              v7 = 4;
            }
          }
          else
          {
            LOBYTE(v12) = BYTE2(v5) | 0xC0;
            BYTE1(v12) = BYTE1(v5);
            BYTE2(v12) = v5;
            v7 = 3;
          }
        }
        else
        {
          LOBYTE(v12) = BYTE1(v5) | 0x80;
          BYTE1(v12) = v5;
          v7 = 2;
        }
      }
      else
      {
        LOBYTE(v12) = v5;
        v7 = 1;
      }
      v9 = (uint64_t)a1;
      v10 = 53;
    }
    activityJournalWrite(v9, v10, &v12, v7);
    os_unfair_lock_unlock(v6);
  }
}

void SIActivityJournalNewLiveIndex(os_unfair_lock_s *a1, unsigned int a2, unint64_t a3)
{
  os_unfair_lock_s *v6;
  uint64_t v7;
  unsigned int v8;
  _OWORD v9[16];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v6 = a1 + 8;
  memset(v9, 0, sizeof(v9));
  os_unfair_lock_lock(a1 + 8);
  if (a2 > 0x7F)
  {
    if (a2 >> 14)
    {
      if (a2 >> 21)
      {
        if (a2 >> 28)
        {
          LOBYTE(v9[0]) = -16;
          *(_DWORD *)((char *)v9 + 1) = a2;
          v7 = 5;
        }
        else
        {
          LOBYTE(v9[0]) = HIBYTE(a2) | 0xE0;
          BYTE1(v9[0]) = BYTE2(a2);
          BYTE2(v9[0]) = BYTE1(a2);
          BYTE3(v9[0]) = a2;
          v7 = 4;
        }
      }
      else
      {
        LOBYTE(v9[0]) = BYTE2(a2) | 0xC0;
        BYTE1(v9[0]) = BYTE1(a2);
        BYTE2(v9[0]) = a2;
        v7 = 3;
      }
    }
    else
    {
      LOBYTE(v9[0]) = BYTE1(a2) | 0x80;
      BYTE1(v9[0]) = a2;
      v7 = 2;
    }
  }
  else
  {
    LOBYTE(v9[0]) = a2;
    v7 = 1;
  }
  v8 = v2_writeVInt64_7950((uint64_t)v9, v7, a3);
  activityJournalWrite((uint64_t)a1, 20, v9, v8);
  os_unfair_lock_unlock(v6);
}

void SIActivityJournalMergeIndices(os_unfair_lock_s *a1, unsigned int a2, unsigned int a3, int a4)
{
  os_unfair_lock_s *v8;
  uint64_t v9;
  unsigned int v10;
  _BYTE *v11;
  _BYTE *v12;
  _BYTE *v13;
  unint64_t v14;
  char v15;
  _OWORD v16[16];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v8 = a1 + 8;
  memset(v16, 0, sizeof(v16));
  os_unfair_lock_lock(a1 + 8);
  if (a2 > 0x7F)
  {
    if (a2 >> 14)
    {
      if (a2 >> 21)
      {
        if (a2 >> 28)
        {
          LOBYTE(v16[0]) = -16;
          *(_DWORD *)((char *)v16 + 1) = a2;
          v9 = 5;
        }
        else
        {
          LOBYTE(v16[0]) = HIBYTE(a2) | 0xE0;
          BYTE1(v16[0]) = BYTE2(a2);
          BYTE2(v16[0]) = BYTE1(a2);
          BYTE3(v16[0]) = a2;
          v9 = 4;
        }
      }
      else
      {
        LOBYTE(v16[0]) = BYTE2(a2) | 0xC0;
        BYTE1(v16[0]) = BYTE1(a2);
        BYTE2(v16[0]) = a2;
        v9 = 3;
      }
    }
    else
    {
      LOBYTE(v16[0]) = BYTE1(a2) | 0x80;
      BYTE1(v16[0]) = a2;
      v9 = 2;
    }
  }
  else
  {
    LOBYTE(v16[0]) = a2;
    v9 = 1;
  }
  if (a3 > 0x7F)
  {
    if (a3 >> 14)
    {
      if (a3 >> 21)
      {
        if (a3 >> 28)
        {
          v14 = v9 | (unint64_t)v16;
          *(_BYTE *)v14 = -16;
          *(_DWORD *)(v14 + 1) = a3;
          v10 = v9 + 5;
        }
        else
        {
          v13 = (_BYTE *)(v9 | (unint64_t)v16);
          *v13 = HIBYTE(a3) | 0xE0;
          v13[1] = BYTE2(a3);
          v13[2] = BYTE1(a3);
          v10 = v9 + 4;
          v13[3] = a3;
        }
      }
      else
      {
        v12 = (_BYTE *)(v9 | (unint64_t)v16);
        *v12 = BYTE2(a3) | 0xC0;
        v12[1] = BYTE1(a3);
        v10 = v9 + 3;
        v12[2] = a3;
      }
    }
    else
    {
      v11 = (_BYTE *)(v9 | (unint64_t)v16);
      *v11 = BYTE1(a3) | 0x80;
      v10 = v9 + 2;
      v11[1] = a3;
    }
  }
  else
  {
    v10 = v9 + 1;
    *(_BYTE *)((unint64_t)v16 | v9) = a3;
  }
  if (a4)
    v15 = 21;
  else
    v15 = 22;
  activityJournalWrite((uint64_t)a1, v15, v16, v10);
  os_unfair_lock_unlock(v8);
}

void _SIActivityJournalAdd(uint64_t a1, char a2, uint64_t a3, unsigned int a4, unint64_t a5, int a6)
{
  os_unfair_lock_s *v12;
  char v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  __int128 v17;
  __int128 v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v12 = (os_unfair_lock_s *)(a1 + 32);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 32));
  if (*(unsigned __int8 *)(a1 + 37) != a6)
  {
    *(_BYTE *)(a1 + 37) = a6;
    if (a6)
      v13 = 26;
    else
      v13 = 27;
    activityJournalWrite(a1, v13, 0, 0);
  }
  if (*(_DWORD *)(a1 + 8) != a4)
  {
    *(_DWORD *)(a1 + 8) = a4;
    v17 = 0u;
    v18 = 0u;
    if (a4 > 0x7F)
    {
      if (a4 >> 14)
      {
        if (a4 >> 21)
        {
          if (a4 >> 28)
          {
            LOBYTE(v17) = -16;
            *(_DWORD *)((char *)&v17 + 1) = a4;
            v14 = 5;
          }
          else
          {
            LOBYTE(v17) = HIBYTE(a4) | 0xE0;
            BYTE1(v17) = BYTE2(a4);
            BYTE2(v17) = BYTE1(a4);
            BYTE3(v17) = a4;
            v14 = 4;
          }
        }
        else
        {
          LOBYTE(v17) = BYTE2(a4) | 0xC0;
          BYTE1(v17) = BYTE1(a4);
          BYTE2(v17) = a4;
          v14 = 3;
        }
      }
      else
      {
        LOBYTE(v17) = BYTE1(a4) | 0x80;
        BYTE1(v17) = a4;
        v14 = 2;
      }
    }
    else
    {
      LOBYTE(v17) = a4;
      v14 = 1;
    }
    activityJournalWrite(a1, 9, &v17, v14);
  }
  if (*(_QWORD *)(a1 + 24) != a5)
  {
    *(_QWORD *)(a1 + 24) = a5;
    activityJournalWriteVInt64(a1, 32, a5);
  }
  if (*(_DWORD *)(a1 + 12) != HIDWORD(a3))
  {
    *(_DWORD *)(a1 + 12) = HIDWORD(a3);
    v17 = 0u;
    v18 = 0u;
    if (HIDWORD(a3) > 0x7F)
    {
      if (HIDWORD(a3) >> 14)
      {
        if (HIDWORD(a3) >> 21)
        {
          if (HIDWORD(a3) >> 28)
          {
            LOBYTE(v17) = -16;
            *(_DWORD *)((char *)&v17 + 1) = HIDWORD(a3);
            v15 = 5;
          }
          else
          {
            LOBYTE(v17) = HIBYTE(a3) | 0xE0;
            BYTE1(v17) = BYTE6(a3);
            BYTE2(v17) = BYTE5(a3);
            BYTE3(v17) = BYTE4(a3);
            v15 = 4;
          }
        }
        else
        {
          LOBYTE(v17) = BYTE6(a3) | 0xC0;
          BYTE1(v17) = BYTE5(a3);
          BYTE2(v17) = BYTE4(a3);
          v15 = 3;
        }
      }
      else
      {
        LOBYTE(v17) = BYTE5(a3) | 0x80;
        BYTE1(v17) = BYTE4(a3);
        v15 = 2;
      }
    }
    else
    {
      LOBYTE(v17) = BYTE4(a3);
      v15 = 1;
    }
    activityJournalWrite(a1, 10, &v17, v15);
  }
  v17 = 0u;
  v18 = 0u;
  if (a3 > 0x7F)
  {
    if (a3 >> 14)
    {
      if (a3 >> 21)
      {
        if (a3 >> 28)
        {
          LOBYTE(v17) = -16;
          *(_DWORD *)((char *)&v17 + 1) = a3;
          v16 = 5;
        }
        else
        {
          LOBYTE(v17) = BYTE3(a3) | 0xE0;
          BYTE1(v17) = BYTE2(a3);
          BYTE2(v17) = BYTE1(a3);
          BYTE3(v17) = a3;
          v16 = 4;
        }
      }
      else
      {
        LOBYTE(v17) = BYTE2(a3) | 0xC0;
        BYTE1(v17) = BYTE1(a3);
        BYTE2(v17) = a3;
        v16 = 3;
      }
    }
    else
    {
      LOBYTE(v17) = BYTE1(a3) | 0x80;
      BYTE1(v17) = a3;
      v16 = 2;
    }
  }
  else
  {
    LOBYTE(v17) = a3;
    v16 = 1;
  }
  activityJournalWrite(a1, a2, &v17, v16);
  os_unfair_lock_unlock(v12);
}

void SIActivityJournalMailCSItem(uint64_t a1, CFStringRef theString, uint64_t a3, unsigned int a4, unint64_t a5, int a6, int a7, uint64_t a8, uint64_t a9, const void *a10)
{
  BOOL v15;
  CFIndex Length;
  uint64_t v21;
  char *v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  char v26;
  unsigned int v27;
  unsigned int v28;
  uint64_t v29;
  CFTypeID v30;
  int v31;
  char v32;
  unint64_t v33;
  char buffer[16];
  __int128 v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  if (a10)
    v15 = 0;
  else
    v15 = theString == 0;
  if (v15 && a8 == 0 && a9 == 0)
  {
    SIActivityJournalCSItem(a1, 0, a3, a4, a5, a6, a7);
    return;
  }
  Length = CFStringGetLength(theString);
  if (!Length)
    goto LABEL_29;
  v21 = Length;
  if (Length > 31)
    goto LABEL_29;
  *(_OWORD *)buffer = 0u;
  v36 = 0u;
  if (!CFStringGetCString(theString, buffer, 32, 0x8000100u))
    goto LABEL_29;
  if (v21 >= 1)
  {
    v22 = buffer;
    do
    {
      v23 = *v22++;
      if (v23 >= 0x3A)
        goto LABEL_29;
    }
    while (--v21);
  }
  v24 = atol(buffer);
  if (v24 <= 0)
  {
LABEL_29:
    SIActivityJournalCSItem(a1, theString, a3, a4, a5, a6, a7);
    return;
  }
  v25 = v24;
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 32));
  if (*(unsigned __int8 *)(a1 + 37) != a6)
  {
    *(_BYTE *)(a1 + 37) = a6;
    if (a6)
      v26 = 26;
    else
      v26 = 27;
    activityJournalWrite(a1, v26, 0, 0);
  }
  if (*(_DWORD *)(a1 + 12) != HIDWORD(a3))
  {
    *(_DWORD *)(a1 + 12) = HIDWORD(a3);
    *(_OWORD *)buffer = 0u;
    v36 = 0u;
    if (HIDWORD(a3) > 0x7F)
    {
      if (HIDWORD(a3) >> 14)
      {
        if (HIDWORD(a3) >> 21)
        {
          if (HIDWORD(a3) >> 28)
          {
            buffer[0] = -16;
            *(_DWORD *)&buffer[1] = HIDWORD(a3);
            v27 = 5;
          }
          else
          {
            buffer[0] = HIBYTE(a3) | 0xE0;
            buffer[1] = BYTE6(a3);
            buffer[2] = BYTE5(a3);
            buffer[3] = BYTE4(a3);
            v27 = 4;
          }
        }
        else
        {
          buffer[0] = BYTE6(a3) | 0xC0;
          buffer[1] = BYTE5(a3);
          buffer[2] = BYTE4(a3);
          v27 = 3;
        }
      }
      else
      {
        buffer[0] = BYTE5(a3) | 0x80;
        buffer[1] = BYTE4(a3);
        v27 = 2;
      }
    }
    else
    {
      buffer[0] = BYTE4(a3);
      v27 = 1;
    }
    activityJournalWrite(a1, 10, buffer, v27);
  }
  if (*(_DWORD *)(a1 + 8) != a4)
  {
    *(_DWORD *)(a1 + 8) = a4;
    *(_OWORD *)buffer = 0u;
    v36 = 0u;
    if (a4 > 0x7F)
    {
      if (a4 >> 14)
      {
        if (a4 >> 21)
        {
          if (a4 >> 28)
          {
            buffer[0] = -16;
            *(_DWORD *)&buffer[1] = a4;
            v28 = 5;
          }
          else
          {
            buffer[0] = HIBYTE(a4) | 0xE0;
            buffer[1] = BYTE2(a4);
            buffer[2] = BYTE1(a4);
            buffer[3] = a4;
            v28 = 4;
          }
        }
        else
        {
          buffer[0] = BYTE2(a4) | 0xC0;
          buffer[1] = BYTE1(a4);
          buffer[2] = a4;
          v28 = 3;
        }
      }
      else
      {
        buffer[0] = BYTE1(a4) | 0x80;
        buffer[1] = a4;
        v28 = 2;
      }
    }
    else
    {
      buffer[0] = a4;
      v28 = 1;
    }
    activityJournalWrite(a1, 9, buffer, v28);
  }
  v29 = 4 * v25;
  if (*(_QWORD *)(a1 + 24) != a5)
  {
    *(_QWORD *)(a1 + 24) = a5;
    activityJournalWriteVInt64(a1, 32, a5);
  }
  if (a10
    && (v30 = CFGetTypeID(a10), v30 == CFNumberGetTypeID())
    && (*(_DWORD *)buffer = 0, CFNumberGetValue((CFNumberRef)a10, kCFNumberSInt32Type, buffer)))
  {
    if (*(_DWORD *)buffer > 7u)
    {
      v31 = 255;
    }
    else
    {
      v29 = (4 * buffer[0]) | (32 * v25);
      v31 = buffer[0];
    }
  }
  else
  {
    v31 = 255;
  }
  if ((a7 & 1) != 0)
  {
    if (v31 == 255)
    {
      if ((const void *)*MEMORY[0x1E0C9B0D0] == a10)
        v32 = 49;
      else
        v32 = 48;
    }
    else
    {
      v32 = 51;
    }
  }
  else if (v31 == 255)
  {
    v32 = 47;
  }
  else
  {
    v32 = 50;
  }
  if (*MEMORY[0x1E0C9AE50] == a9)
    v33 = v29 | (*MEMORY[0x1E0C9AE50] == a8) | 2;
  else
    v33 = v29 | (*MEMORY[0x1E0C9AE50] == a8);
  activityJournalWriteVInt64(a1, v32, v33);
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 32));
}

void SIActivityJournalDMAdd(os_unfair_lock_s *a1, unsigned int a2, unsigned int a3, unint64_t a4, unint64_t a5, unint64_t a6)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char v20;
  char v21;
  char v22;
  char v23;
  char v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    bzero(&v20, 0x220uLL);
    if (a2 > 0x7F)
    {
      if (a2 >> 14)
      {
        if (a2 >> 21)
        {
          if (a2 >> 28)
          {
            v20 = -16;
            v21 = HIBYTE(a2);
            v22 = BYTE2(a2);
            v23 = BYTE1(a2);
            v12 = 5;
            v24 = a2;
          }
          else
          {
            v20 = HIBYTE(a2) | 0xE0;
            v21 = BYTE2(a2);
            v22 = BYTE1(a2);
            v23 = a2;
            v12 = 4;
          }
        }
        else
        {
          v20 = BYTE2(a2) | 0xC0;
          v21 = BYTE1(a2);
          v22 = a2;
          v12 = 3;
        }
      }
      else
      {
        v20 = BYTE1(a2) | 0x80;
        v21 = a2;
        v12 = 2;
      }
    }
    else
    {
      v20 = a2;
      v12 = 1;
    }
    v13 = v2_writeVInt64_7950((uint64_t)&v20, v12, a3);
    v14 = v2_writeVInt64_7950((uint64_t)&v20, v13, a4);
    v15 = v2_writeVInt64_7950((uint64_t)&v20, v14, a5);
    v16 = v2_writeVInt64_7950((uint64_t)&v20, v15, a6);
    if ((unint64_t)(v16 - 511) >= 2)
      v17 = 0;
    else
      v17 = 511 - v16;
    v18 = v2_writeVInt64_7950((uint64_t)&v20, v16, v17);
    v19 = v18;
    if (v17)
    {
      memcpy(&v20 + v18, 0, 0xFFFFFFFFFFFFFFFFLL);
      *(&v20 + v19 - 1) = 0;
    }
    os_unfair_lock_lock(a1 + 8);
    activityJournalWrite((uint64_t)a1, 58, &v20, v19);
    os_unfair_lock_unlock(a1 + 8);
  }
}

void SIActivityJournalEvent(os_unfair_lock_s *a1, unsigned int a2, unsigned int a3, unsigned int a4, unsigned int a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  char v14;
  char v15;
  char v16;
  char v17;
  char v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    bzero(&v14, 0x220uLL);
    if (a2 > 0x7F)
    {
      if (a2 >> 14)
      {
        if (a2 >> 21)
        {
          if (a2 >> 28)
          {
            v14 = -16;
            v15 = HIBYTE(a2);
            v16 = BYTE2(a2);
            v17 = BYTE1(a2);
            v10 = 5;
            v18 = a2;
          }
          else
          {
            v14 = HIBYTE(a2) | 0xE0;
            v15 = BYTE2(a2);
            v16 = BYTE1(a2);
            v17 = a2;
            v10 = 4;
          }
        }
        else
        {
          v14 = BYTE2(a2) | 0xC0;
          v15 = BYTE1(a2);
          v16 = a2;
          v10 = 3;
        }
      }
      else
      {
        v14 = BYTE1(a2) | 0x80;
        v15 = a2;
        v10 = 2;
      }
    }
    else
    {
      v14 = a2;
      v10 = 1;
    }
    v11 = v2_writeVInt64_7950((uint64_t)&v14, v10, a3);
    v12 = v2_writeVInt64_7950((uint64_t)&v14, v11, a4);
    v13 = v2_writeVInt64_7950((uint64_t)&v14, v12, a5);
    os_unfair_lock_lock(a1 + 8);
    activityJournalWrite((uint64_t)a1, 59, &v14, v13);
    os_unfair_lock_unlock(a1 + 8);
  }
}

void _SIActivityJournalGetOIDs(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  char v5;
  char v6;
  const char *v7;
  const __CFAllocator *v8;
  const CFDictionaryValueCallBacks *v9;
  const __CFDictionary *Mutable;
  const __CFDictionary *v11;
  CFIndex Count;
  const void **v13;
  uint64_t v14;
  const void **v15;
  const void *v16;
  const void *v17;
  const void *v18;
  const void *Value;
  const void *v20;
  uint64_t v21;
  _QWORD *v22;
  const __CFDictionary *v23;
  uint64_t v24;
  _QWORD v25[2];
  uint64_t v26;
  uint64_t v27;
  _QWORD *v28;
  _QWORD v29[6];
  char v30;
  _QWORD v31[1026];

  v1 = MEMORY[0x1E0C80A78](a1);
  v24 = v2;
  v4 = v3;
  v6 = v5;
  v7 = (const char *)v1;
  v31[1024] = *MEMORY[0x1E0C80C00];
  v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v9 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, MEMORY[0x1E0C9B3A0]);
  v11 = CFDictionaryCreateMutable(v8, 0, 0, v9);
  v29[0] = MEMORY[0x1E0C809B0];
  v29[1] = 0x40000000;
  v29[2] = ___SIActivityJournalGetOIDs_block_invoke;
  v29[3] = &__block_descriptor_tmp_7987;
  v29[4] = v11;
  v29[5] = Mutable;
  v30 = v6;
  si_activity_journal_playback(v7, (uint64_t)v29);
  Count = CFDictionaryGetCount(v11);
  MEMORY[0x1E0C80A78](Count);
  v13 = (const void **)((char *)&v23 - ((8 * Count + 15) & 0xFFFFFFFFFFFFFFF0));
  bzero(v13, 8 * Count);
  MEMORY[0x1E0C80A78](v14);
  v15 = v13;
  bzero(v13, 8 * Count);
  v23 = v11;
  CFDictionaryGetKeysAndValues(v11, v13, v13);
  if (Count >= 1)
  {
    do
    {
      v17 = *v13++;
      v16 = v17;
      v18 = *v15;
      Value = CFDictionaryGetValue(Mutable, v17);
      if (Value)
      {
        v20 = Value;
        v21 = 0x20000;
        if (v4 < 0x20000)
          v21 = v4;
        if (v4)
          v4 = v21;
        else
          v4 = 1024;
        v25[0] = v18;
        v25[1] = v4;
        v26 = v24;
        v27 = 0;
        v28 = 0;
        v22 = v31;
        bzero(v31, 0x2000uLL);
        if (v4 >= 0x401)
          v22 = malloc_type_malloc(8 * v4, 0x100004000313F17uLL);
        v28 = v22;
        SIValueSet<unsigned long long>::_SIValueSetInnerIterate((uint64_t)v20 + 56, *((_QWORD *)v20 + 2), *((_DWORD *)v20 + 6), (uint64_t)oids_for_bundle_callback, (uint64_t)v25, 512);
        if (v27)
        {
          (*(void (**)(uint64_t, _QWORD, _QWORD *))(v26 + 16))(v26, v25[0], v28);
          v27 = 0;
        }
        if (v28 != v31)
          free(v28);
        CFDictionaryRemoveValue(Mutable, v16);
      }
      ++v15;
      --Count;
    }
    while (Count);
  }
  CFRelease(v23);
  CFRelease(Mutable);
}

uint64_t si_activity_journal_playback(const char *a1, uint64_t a2)
{
  uint64_t result;
  int v4;
  off_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  BOOL v9;
  FILE **v10;
  uint64_t v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  unsigned int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  unsigned int v23;
  int v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unsigned int v28;
  int v29;
  int v30;
  char *v31;
  unint64_t v32;
  unint64_t v33;
  unsigned int v34;
  uint64_t v35;
  uint64_t v36;
  unsigned int v37;
  int v38;
  uint64_t v39;
  unsigned int v40;
  int v41;
  uint64_t v42;
  unsigned int v43;
  int v44;
  uint64_t v45;
  unsigned int v46;
  int v47;
  uint64_t v48;
  unsigned int v49;
  int v50;
  size_t v51;
  int v52;
  uint64_t v53;
  off_t v54;
  unsigned int v55;
  int v56;
  off_t v57;
  unsigned int v58;
  int v59;
  uint64_t v60;
  unsigned int v61;
  int v62;
  unint64_t v63;
  uint64_t v64;
  uint64_t v65;
  unsigned int v66;
  int v67;
  int v68;
  unint64_t v69;
  off_t v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  char __str[16];
  __int128 v77;
  __int128 v78;
  __int128 v79;
  char v80;
  uint64_t v81;

  v81 = *MEMORY[0x1E0C80C00];
  v74 = 0u;
  v75 = 0u;
  v72 = 0u;
  v73 = 0u;
  v71 = 0u;
  result = open(a1, 0);
  if ((_DWORD)result != -1)
  {
    v4 = result;
    v5 = lseek(result, 0, 2);
    v6 = (char *)mmap(0, v5, 1, 1, v4, 0);
    if (v6 != (char *)-1)
    {
      v7 = v6;
      v80 = 0;
      v78 = 0u;
      v79 = 0u;
      *(_OWORD *)__str = 0u;
      v77 = 0u;
      if (v5 >= 1)
      {
        v8 = 0;
        v9 = 0;
        v10 = (FILE **)MEMORY[0x1E0C80C10];
        do
        {
          while (2)
          {
            v11 = v8 + 1;
            v12 = v7[v8];
            if (v7[v8] < 0)
            {
              if (v12 > 0xBF)
              {
                if (v12 > 0xDF)
                {
                  if (v12 > 0xEF)
                  {
                    v12 = *(_DWORD *)&v7[v11];
                    v8 += 5;
                  }
                  else
                  {
                    v12 = ((v12 & 0xF) << 24) | (v7[v11] << 16) | (v7[v8 + 2] << 8) | v7[v8 + 3];
                    v8 += 4;
                  }
                }
                else
                {
                  v12 = ((v12 & 0x1F) << 16) | (v7[v11] << 8) | v7[v8 + 2];
                  v8 += 3;
                }
              }
              else
              {
                v8 += 2;
                v12 = v7[v11] | ((v12 & 0x3F) << 8);
              }
            }
            else
            {
              ++v8;
            }
            LODWORD(v71) = v12;
            if ((v12 & 1) != 0)
            {
              v70 = v8;
              v13 = v12 >> 1;
              LODWORD(v71) = v12 >> 1;
              v9 = 0;
              switch(v12 >> 1)
              {
                case 1u:
                case 2u:
                case 3u:
                case 0x21u:
                case 0x22u:
                case 0x25u:
                case 0x26u:
                case 0x27u:
                  HIDWORD(v71) = 0;
                  v14 = v8 + 1;
                  v15 = v7[v8];
                  if (v7[v8] < 0)
                  {
                    if (v15 > 0xBF)
                    {
                      if (v15 > 0xDF)
                      {
                        if (v15 > 0xEF)
                        {
                          v15 = *(_DWORD *)&v7[v14];
                          v14 = v8 + 5;
                        }
                        else
                        {
                          v15 = ((v15 & 0xF) << 24) | (v7[v14] << 16) | (v7[v8 + 2] << 8) | v7[v8 + 3];
                          v14 = v8 + 4;
                        }
                      }
                      else
                      {
                        v15 = ((v15 & 0x1F) << 16) | (v7[v14] << 8) | v7[v8 + 2];
                        v14 = v8 + 3;
                      }
                    }
                    else
                    {
                      v16 = v7[v14] | ((v15 & 0x3F) << 8);
                      v14 = v8 + 2;
                      v15 = v16;
                    }
                  }
                  v70 = v14;
                  DWORD2(v72) = v15;
                  *(double *)&v73 = (double)v2_readVInt64((uint64_t)v7, &v70);
                  v54 = v70 + 1;
                  v55 = v7[v70];
                  if (v7[v70] < 0)
                  {
                    if (v55 > 0xBF)
                    {
                      if (v55 > 0xDF)
                      {
                        if (v55 > 0xEF)
                        {
                          v55 = *(_DWORD *)&v7[v54];
                          v54 = v70 + 5;
                        }
                        else
                        {
                          v55 = ((v55 & 0xF) << 24) | (v7[v54] << 16) | (v7[v70 + 2] << 8) | v7[v70 + 3];
                          v54 = v70 + 4;
                        }
                      }
                      else
                      {
                        v55 = ((v55 & 0x1F) << 16) | (v7[v54] << 8) | v7[v70 + 2];
                        v54 = v70 + 3;
                      }
                    }
                    else
                    {
                      v56 = v7[v54] | ((v55 & 0x3F) << 8);
                      v54 = v70 + 2;
                      v55 = v56;
                    }
                  }
                  DWORD2(v73) = v55;
                  v57 = v54 + 1;
                  v58 = v7[v54];
                  if (v7[v54] < 0)
                  {
                    if (v58 > 0xBF)
                    {
                      if (v58 > 0xDF)
                      {
                        if (v58 > 0xEF)
                        {
                          v58 = *(_DWORD *)&v7[v57];
                          v57 = v54 + 5;
                        }
                        else
                        {
                          v58 = ((v58 & 0xF) << 24) | (v7[v57] << 16) | (v7[v54 + 2] << 8) | v7[v54 + 3];
                          v57 = v54 + 4;
                        }
                      }
                      else
                      {
                        v58 = ((v58 & 0x1F) << 16) | (v7[v57] << 8) | v7[v54 + 2];
                        v57 = v54 + 3;
                      }
                    }
                    else
                    {
                      v59 = v7[v57] | ((v58 & 0x3F) << 8);
                      v57 = v54 + 2;
                      v58 = v59;
                    }
                  }
                  HIDWORD(v73) = v58;
                  v60 = v57 + 1;
                  v61 = v7[v57];
                  if (v7[v57] < 0)
                  {
                    if (v61 > 0xBF)
                    {
                      if (v61 > 0xDF)
                      {
                        if (v61 > 0xEF)
                        {
                          v61 = *(_DWORD *)&v7[v60];
                          v60 = v57 + 5;
                        }
                        else
                        {
                          v61 = ((v61 & 0xF) << 24) | (v7[v60] << 16) | (v7[v57 + 2] << 8) | v7[v57 + 3];
                          v60 = v57 + 4;
                        }
                      }
                      else
                      {
                        v61 = ((v61 & 0x1F) << 16) | (v7[v60] << 8) | v7[v57 + 2];
                        v60 = v57 + 3;
                      }
                    }
                    else
                    {
                      v62 = v7[v60] | ((v61 & 0x3F) << 8);
                      v60 = v57 + 2;
                      v61 = v62;
                    }
                  }
                  v70 = v60;
                  LODWORD(v74) = v61;
                  if (v13 <= 0x27 && ((1 << v13) & 0xC600000000) != 0)
                  {
                    *((_QWORD *)&v74 + 1) = v2_readVInt64((uint64_t)v7, &v70);
                    v63 = v2_readVInt64((uint64_t)v7, &v70);
                  }
                  else
                  {
                    v63 = 0;
                    *((_QWORD *)&v74 + 1) = 0;
                  }
                  *(_QWORD *)&v75 = v63;
                  v9 = 0;
                  if (v13 - 37 > 2)
                    *((_QWORD *)&v75 + 1) = 0;
                  else
                    *((_QWORD *)&v75 + 1) = v2_readVInt64((uint64_t)v7, &v70);
                  goto LABEL_133;
                case 4u:
                case 5u:
                case 7u:
                case 8u:
                case 0x23u:
                case 0x24u:
                  v9 = 0;
                  *((double *)&v72 + 1) = (double)v2_readVInt64((uint64_t)v7, &v70);
                  goto LABEL_133;
                case 6u:
                case 0x28u:
                  *((double *)&v72 + 1) = (double)v2_readVInt64((uint64_t)v7, &v70);
                  *(_QWORD *)&v73 = v2_readVInt64((uint64_t)v7, &v70);
                  v9 = v13 == 6;
                  goto LABEL_133;
                case 9u:
                  v9 = 0;
                  HIDWORD(v71) = v2_readVInt64((uint64_t)v7, &v70);
                  goto LABEL_133;
                case 0xAu:
                  v36 = v8 + 1;
                  v37 = v7[v8];
                  if (v7[v8] < 0)
                  {
                    if (v37 > 0xBF)
                    {
                      if (v37 > 0xDF)
                      {
                        if (v37 > 0xEF)
                        {
                          v37 = *(_DWORD *)&v7[v36];
                          v36 = v8 + 5;
                        }
                        else
                        {
                          v37 = ((v37 & 0xF) << 24) | (v7[v36] << 16) | (v7[v8 + 2] << 8) | v7[v8 + 3];
                          v36 = v8 + 4;
                        }
                      }
                      else
                      {
                        v37 = ((v37 & 0x1F) << 16) | (v7[v36] << 8) | v7[v8 + 2];
                        v36 = v8 + 3;
                      }
                    }
                    else
                    {
                      v38 = v7[v36] | ((v37 & 0x3F) << 8);
                      v36 = v8 + 2;
                      v37 = v38;
                    }
                  }
                  v9 = 0;
                  v70 = v36;
                  DWORD1(v71) = v37;
                  goto LABEL_133;
                case 0xBu:
                case 0xCu:
                case 0xDu:
                case 0xEu:
                case 0xFu:
                  v17 = v8 + 1;
                  LODWORD(v18) = v7[v8];
                  if (v7[v8] < 0)
                  {
                    if (v18 > 0xBF)
                    {
                      if (v18 > 0xDF)
                      {
                        if (v18 > 0xEF)
                        {
                          LODWORD(v18) = *(_DWORD *)&v7[v17];
                          v17 = v8 + 5;
                        }
                        else
                        {
                          LODWORD(v18) = ((v18 & 0xF) << 24) | (v7[v17] << 16) | (v7[v8 + 2] << 8) | v7[v8 + 3];
                          v17 = v8 + 4;
                        }
                      }
                      else
                      {
                        LODWORD(v18) = ((v18 & 0x1F) << 16) | (v7[v17] << 8) | v7[v8 + 2];
                        v17 = v8 + 3;
                      }
                    }
                    else
                    {
                      v19 = v7[v17] | ((v18 & 0x3F) << 8);
                      v17 = v8 + 2;
                      LODWORD(v18) = v19;
                    }
                  }
                  v9 = 0;
                  v70 = v17;
                  v18 = v18;
                  v64 = DWORD1(v71);
                  goto LABEL_131;
                case 0x10u:
                  v39 = v8 + 1;
                  v40 = v7[v8];
                  if (v7[v8] < 0)
                  {
                    if (v40 > 0xBF)
                    {
                      if (v40 > 0xDF)
                      {
                        if (v40 > 0xEF)
                        {
                          v40 = *(_DWORD *)&v7[v39];
                          v39 = v8 + 5;
                        }
                        else
                        {
                          v40 = ((v40 & 0xF) << 24) | (v7[v39] << 16) | (v7[v8 + 2] << 8) | v7[v8 + 3];
                          v39 = v8 + 4;
                        }
                      }
                      else
                      {
                        v40 = ((v40 & 0x1F) << 16) | (v7[v39] << 8) | v7[v8 + 2];
                        v39 = v8 + 3;
                      }
                    }
                    else
                    {
                      v41 = v7[v39] | ((v40 & 0x3F) << 8);
                      v39 = v8 + 2;
                      v40 = v41;
                    }
                  }
                  v9 = 0;
                  v70 = v39;
                  DWORD2(v71) = v40;
                  goto LABEL_133;
                case 0x11u:
                case 0x12u:
                case 0x13u:
                case 0x36u:
                  v20 = v8 + 1;
                  LODWORD(v18) = v7[v8];
                  if (v7[v8] < 0)
                  {
                    if (v18 > 0xBF)
                    {
                      if (v18 > 0xDF)
                      {
                        if (v18 > 0xEF)
                        {
                          LODWORD(v18) = *(_DWORD *)&v7[v20];
                          v20 = v8 + 5;
                        }
                        else
                        {
                          LODWORD(v18) = ((v18 & 0xF) << 24) | (v7[v20] << 16) | (v7[v8 + 2] << 8) | v7[v8 + 3];
                          v20 = v8 + 4;
                        }
                      }
                      else
                      {
                        LODWORD(v18) = ((v18 & 0x1F) << 16) | (v7[v20] << 8) | v7[v8 + 2];
                        v20 = v8 + 3;
                      }
                    }
                    else
                    {
                      v21 = v7[v20] | ((v18 & 0x3F) << 8);
                      v20 = v8 + 2;
                      LODWORD(v18) = v21;
                    }
                  }
                  v9 = 0;
                  v70 = v20;
                  v18 = v18;
                  v64 = DWORD2(v71);
LABEL_131:
                  v35 = v18 | (v64 << 32);
                  goto LABEL_132;
                case 0x14u:
                  v42 = v8 + 1;
                  v43 = v7[v8];
                  if (v7[v8] < 0)
                  {
                    if (v43 > 0xBF)
                    {
                      if (v43 > 0xDF)
                      {
                        if (v43 > 0xEF)
                        {
                          v43 = *(_DWORD *)&v7[v42];
                          v42 = v8 + 5;
                        }
                        else
                        {
                          v43 = ((v43 & 0xF) << 24) | (v7[v42] << 16) | (v7[v8 + 2] << 8) | v7[v8 + 3];
                          v42 = v8 + 4;
                        }
                      }
                      else
                      {
                        v43 = ((v43 & 0x1F) << 16) | (v7[v42] << 8) | v7[v8 + 2];
                        v42 = v8 + 3;
                      }
                    }
                    else
                    {
                      v44 = v7[v42] | ((v43 & 0x3F) << 8);
                      v42 = v8 + 2;
                      v43 = v44;
                    }
                  }
                  v70 = v42;
                  DWORD2(v72) = v43;
                  v9 = 0;
                  *(_QWORD *)&v73 = v2_readVInt64((uint64_t)v7, &v70);
                  goto LABEL_133;
                case 0x15u:
                case 0x16u:
                  v27 = v8 + 1;
                  v28 = v7[v8];
                  if (v7[v8] < 0)
                  {
                    if (v28 > 0xBF)
                    {
                      if (v28 > 0xDF)
                      {
                        if (v28 > 0xEF)
                        {
                          v28 = *(_DWORD *)&v7[v27];
                          v27 = v8 + 5;
                        }
                        else
                        {
                          v28 = ((v28 & 0xF) << 24) | (v7[v27] << 16) | (v7[v8 + 2] << 8) | v7[v8 + 3];
                          v27 = v8 + 4;
                        }
                      }
                      else
                      {
                        v28 = ((v28 & 0x1F) << 16) | (v7[v27] << 8) | v7[v8 + 2];
                        v27 = v8 + 3;
                      }
                    }
                    else
                    {
                      v29 = v7[v27] | ((v28 & 0x3F) << 8);
                      v27 = v8 + 2;
                      v28 = v29;
                    }
                  }
                  DWORD2(v72) = v28;
                  v65 = v27 + 1;
                  v66 = v7[v27];
                  if (v7[v27] < 0)
                  {
                    if (v66 > 0xBF)
                    {
                      if (v66 > 0xDF)
                      {
                        if (v66 > 0xEF)
                        {
                          v66 = *(_DWORD *)&v7[v65];
                          v65 = v27 + 5;
                        }
                        else
                        {
                          v66 = ((v66 & 0xF) << 24) | (v7[v65] << 16) | (v7[v27 + 2] << 8) | v7[v27 + 3];
                          v65 = v27 + 4;
                        }
                      }
                      else
                      {
                        v66 = ((v66 & 0x1F) << 16) | (v7[v65] << 8) | v7[v27 + 2];
                        v65 = v27 + 3;
                      }
                    }
                    else
                    {
                      v67 = v7[v65] | ((v66 & 0x3F) << 8);
                      v65 = v27 + 2;
                      v66 = v67;
                    }
                  }
                  v9 = 0;
                  v70 = v65;
                  HIDWORD(v72) = v66;
                  goto LABEL_133;
                case 0x17u:
                  v45 = v8 + 1;
                  v46 = v7[v8];
                  if (v7[v8] < 0)
                  {
                    if (v46 > 0xBF)
                    {
                      if (v46 > 0xDF)
                      {
                        if (v46 > 0xEF)
                        {
                          v46 = *(_DWORD *)&v7[v45];
                          v45 = v8 + 5;
                        }
                        else
                        {
                          v46 = ((v46 & 0xF) << 24) | (v7[v45] << 16) | (v7[v8 + 2] << 8) | v7[v8 + 3];
                          v45 = v8 + 4;
                        }
                      }
                      else
                      {
                        v46 = ((v46 & 0x1F) << 16) | (v7[v45] << 8) | v7[v8 + 2];
                        v45 = v8 + 3;
                      }
                    }
                    else
                    {
                      v47 = v7[v45] | ((v46 & 0x3F) << 8);
                      v45 = v8 + 2;
                      v46 = v47;
                    }
                  }
                  DWORD2(v73) = v46;
                  *(_QWORD *)&v73 = &v7[v45];
                  DWORD2(v72) = strlen(&v7[v45]);
                  v70 = v45 + DWORD2(v72) + 1;
                  v68 = MurmurHash3_x86_32((uint64_t)&v7[v45], DWORD2(v72) + 1);
                  v9 = 0;
                  HIDWORD(v72) = v68 & 0x7FFFFFFF;
                  goto LABEL_133;
                case 0x18u:
                case 0x19u:
                case 0x34u:
                case 0x35u:
                  v22 = v8 + 1;
                  v23 = v7[v8];
                  if (v7[v8] < 0)
                  {
                    if (v23 > 0xBF)
                    {
                      if (v23 > 0xDF)
                      {
                        if (v23 > 0xEF)
                        {
                          v23 = *(_DWORD *)&v7[v22];
                          v22 = v8 + 5;
                        }
                        else
                        {
                          v23 = ((v23 & 0xF) << 24) | (v7[v22] << 16) | (v7[v8 + 2] << 8) | v7[v8 + 3];
                          v22 = v8 + 4;
                        }
                      }
                      else
                      {
                        v23 = ((v23 & 0x1F) << 16) | (v7[v22] << 8) | v7[v8 + 2];
                        v22 = v8 + 3;
                      }
                    }
                    else
                    {
                      v24 = v7[v22] | ((v23 & 0x3F) << 8);
                      v22 = v8 + 2;
                      v23 = v24;
                    }
                  }
                  v9 = 0;
                  v70 = v22;
                  DWORD2(v72) = v23;
                  goto LABEL_133;
                case 0x1Au:
                case 0x1Bu:
                  goto LABEL_133;
                case 0x1Cu:
                case 0x1Eu:
                  *(_QWORD *)&v73 = &v7[v8];
                  DWORD2(v73) = strlen(&v7[v8]);
                  v30 = DWORD2(v73) + 1;
                  v70 = v8 + DWORD2(v73) + 1;
                  *((_QWORD *)&v72 + 1) = (unint64_t)DWORD1(v71) << 32;
                  v31 = &v7[v8];
                  goto LABEL_42;
                case 0x1Du:
                case 0x1Fu:
                  v69 = v2_readVInt64((uint64_t)v7, &v70);
                  snprintf(__str, 0x41uLL, "%lld", v69);
                  goto LABEL_41;
                case 0x20u:
                  v9 = 0;
                  *(_QWORD *)&v72 = v2_readVInt64((uint64_t)v7, &v70);
                  goto LABEL_133;
                case 0x2Du:
                case 0x2Eu:
                  v32 = v2_readVInt64((uint64_t)v7, &v70);
                  BYTE12(v73) = v32 & 1;
                  v26 = v32 >> 1;
                  goto LABEL_40;
                case 0x2Fu:
                case 0x30u:
                case 0x31u:
                  v25 = v2_readVInt64((uint64_t)v7, &v70);
                  BYTE12(v73) = v25 & 1;
                  BYTE13(v73) = (v25 & 2) != 0;
                  BYTE14(v73) = -1;
                  v26 = v25 >> 2;
                  goto LABEL_40;
                case 0x32u:
                case 0x33u:
                  v33 = v2_readVInt64((uint64_t)v7, &v70);
                  BYTE12(v73) = v33 & 1;
                  BYTE13(v73) = (v33 & 2) != 0;
                  BYTE14(v73) = (v33 >> 2) & 7;
                  v26 = v33 >> 5;
LABEL_40:
                  snprintf(__str, 0x41uLL, "%lld", v26);
LABEL_41:
                  *(_QWORD *)&v73 = __str;
                  DWORD2(v73) = strlen(__str);
                  *((_QWORD *)&v72 + 1) = (unint64_t)DWORD1(v71) << 32;
                  v30 = DWORD2(v73) + 1;
                  v31 = __str;
LABEL_42:
                  v34 = identifierHash(v31, v30);
                  v9 = 0;
                  v35 = *((_QWORD *)&v72 + 1) | v34;
LABEL_132:
                  *((_QWORD *)&v72 + 1) = v35;
                  goto LABEL_133;
                case 0x37u:
                  *((double *)&v72 + 1) = (double)v2_readVInt64((uint64_t)v7, &v70);
                  *(_QWORD *)&v73 = v2_readVInt64((uint64_t)v7, &v70);
                  v9 = 0;
                  *((_QWORD *)&v73 + 1) = v2_readVInt64((uint64_t)v7, &v70);
                  goto LABEL_133;
                case 0x38u:
                  v48 = v8 + 1;
                  v49 = v7[v8];
                  if (v7[v8] < 0)
                  {
                    if (v49 > 0xBF)
                    {
                      if (v49 > 0xDF)
                      {
                        if (v49 > 0xEF)
                        {
                          v49 = *(_DWORD *)&v7[v48];
                          v48 = v8 + 5;
                        }
                        else
                        {
                          v49 = ((v49 & 0xF) << 24) | (v7[v48] << 16) | (v7[v8 + 2] << 8) | v7[v8 + 3];
                          v48 = v8 + 4;
                        }
                      }
                      else
                      {
                        v49 = ((v49 & 0x1F) << 16) | (v7[v48] << 8) | v7[v8 + 2];
                        v48 = v8 + 3;
                      }
                    }
                    else
                    {
                      v50 = v7[v48] | ((v49 & 0x3F) << 8);
                      v48 = v8 + 2;
                      v49 = v50;
                    }
                  }
                  v70 = v48;
                  DWORD2(v72) = v49;
                  *(double *)&v73 = (double)v2_readVInt64((uint64_t)v7, &v70);
                  *((_QWORD *)&v73 + 1) = &v7[v70];
                  v9 = 0;
                  v51 = v70 + strlen(&v7[v70]);
                  goto LABEL_167;
                case 0x39u:
                  *((_QWORD *)&v72 + 1) = &v7[v8];
                  v9 = 0;
                  v51 = v8 + strlen(&v7[v8]);
LABEL_167:
                  v53 = v51 + 1;
                  goto LABEL_168;
                case 0x3Au:
                  BYTE8(v72) = v2_readVInt64((uint64_t)v7, &v70);
                  WORD5(v72) = (char)v2_readVInt64((uint64_t)v7, &v70);
                  *(_QWORD *)&v73 = v2_readVInt64((uint64_t)v7, &v70);
                  *((_QWORD *)&v73 + 1) = v2_readVInt64((uint64_t)v7, &v70);
                  LODWORD(v74) = v2_readVInt64((uint64_t)v7, &v70);
                  v52 = v2_readVInt64((uint64_t)v7, &v70);
                  DWORD1(v74) = v52;
                  v9 = 0;
                  if (!v52)
                    goto LABEL_133;
                  *((_QWORD *)&v74 + 1) = &v7[v70];
                  v53 = v70 + (v52 + 1);
LABEL_168:
                  v70 = v53;
LABEL_133:
                  (*(void (**)(uint64_t, __int128 *))(a2 + 16))(a2, &v71);
                  v8 = v70;
                  if (v70 >= v5)
                    goto LABEL_170;
                  continue;
                case 0x3Bu:
                  DWORD2(v72) = v2_readVInt64((uint64_t)v7, &v70);
                  HIDWORD(v72) = v2_readVInt64((uint64_t)v7, &v70);
                  LODWORD(v73) = v2_readVInt64((uint64_t)v7, &v70);
                  v9 = 0;
                  DWORD1(v73) = v2_readVInt64((uint64_t)v7, &v70);
                  goto LABEL_133;
                default:
                  fprintf(*v10, "### unknown type %d at offset %ld\n", v13, v8);
                  goto LABEL_170;
              }
            }
            break;
          }
          fprintf(*v10, "### invalid type %d at offset %ld (during activity journal reset, was previous entry kSIActivitySyncError? %d)\n", v12, v8, v9);
        }
        while (v8 < v5);
      }
LABEL_170:
      munmap(v7, v5);
    }
    return close(v4);
  }
  return result;
}

uint64_t oids_for_bundle_callback(void *__src, uint64_t a2, _QWORD *a3)
{
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v6 = a3[3];
  do
  {
    v7 = v6 + a2;
    v8 = a3[1];
    v9 = v8 - v6;
    if (v6 + a2 > v8)
      v10 = v8 - v6;
    else
      v10 = a2;
    memcpy((void *)(a3[4] + 8 * v6), __src, 8 * v10);
    v6 = a3[3] + v10;
    a3[3] = v6;
    if (v6 == a3[1])
    {
      (*(void (**)(void))(a3[2] + 16))();
      v6 = 0;
      a3[3] = 0;
    }
    a2 -= v9;
  }
  while (v7 > v8 && a2 != 0);
  return 0;
}

uint64_t identifierHash(char *__str, int a2)
{
  uint64_t result;
  char *__endptr;

  if (a2 > 8)
    return MurmurHash3_x86_32((uint64_t)__str, a2);
  __endptr = 0;
  result = strtol(__str, &__endptr, 10);
  if (*__endptr || (_DWORD)result == 0)
    return MurmurHash3_x86_32((uint64_t)__str, a2);
  return result;
}

void _SIActivityDump(const char *a1, FILE *a2)
{
  __CFCalendar *v4;
  const __CFTimeZone *v5;
  _QWORD v6[6];

  v4 = CFCalendarCreateWithIdentifier((CFAllocatorRef)*MEMORY[0x1E0C9AE30], (CFCalendarIdentifier)*MEMORY[0x1E0C9B008]);
  v5 = CFTimeZoneCopySystem();
  CFCalendarSetTimeZone(v4, v5);
  CFRelease(v5);
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 0x40000000;
  v6[2] = ___SIActivityDump_block_invoke;
  v6[3] = &__block_descriptor_tmp_55_7993;
  v6[4] = a2;
  v6[5] = v4;
  si_activity_journal_playback(a1, (uint64_t)v6);
  fflush(a2);
  CFRelease(v4);
}

const char *get_date_string(__CFCalendar *a1, char *a2, CFAbsoluteTime a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v6 = 0;
  v7 = 0;
  v5 = 0;
  if (!CFCalendarDecomposeAbsoluteTime(a1, a3, "yMdHms", (char *)&v7 + 4, &v7, (char *)&v6 + 4, &v6, (char *)&v5 + 4, &v5))return "";
  snprintf(a2, 0x100uLL, "%04d-%02d-%02d %02d:%02d:%02d", HIDWORD(v7), v7, HIDWORD(v6), v6, HIDWORD(v5), v5);
  return a2;
}

BOOL CIDocCountsNonEmpty(_QWORD *a1)
{
  return a1[3]
      || a1[6]
      || *a1
      || a1[4]
      || a1[7]
      || a1[1]
      || a1[5]
      || a1[8]
      || a1[2]
      || a1[9]
      || a1[10]
      || a1[11]
      || a1[12] != 0;
}

uint64_t _CIMetaInfoSync(uint64_t a1, int a2)
{
  uint64_t v4;
  unsigned int v5;
  int v6;
  NSObject *v7;
  const char *v8;
  int v10;
  __int128 v11;
  uint64_t v12;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  int v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v10 = 5;
  v11 = *(_OWORD *)(a1 + 32);
  v12 = *(_QWORD *)(a1 + 48);
  if (fd_pwrite(*(_QWORD *)(a1 + 8), (uint64_t)&v10, 0x1CuLL, 0) != 28)
  {
    v5 = *__error();
    if (v5)
      v4 = v5;
    else
      v4 = 0xFFFFFFFFLL;
    v6 = *__error();
    v7 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      goto LABEL_10;
    *(_DWORD *)buf = 136315650;
    v14 = "_CIMetaInfoSync";
    v15 = 1024;
    v16 = 172;
    v17 = 1024;
    v18 = v4;
    v8 = "%s:%d: write err: %d";
    goto LABEL_13;
  }
  if (fd_sync(*(_QWORD *)(a1 + 8), a2) == -1)
  {
    v4 = *__error();
    v6 = *__error();
    v7 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
LABEL_10:
      *__error() = v6;
      return v4;
    }
    *(_DWORD *)buf = 136315650;
    v14 = "_CIMetaInfoSync";
    v15 = 1024;
    v16 = 176;
    v17 = 1024;
    v18 = v4;
    v8 = "%s:%d: sync err: %d";
LABEL_13:
    _os_log_error_impl(&dword_1B8270000, v7, OS_LOG_TYPE_ERROR, v8, buf, 0x18u);
    goto LABEL_10;
  }
  return 0;
}

uint64_t CIMetaInfoCreate(int a1, uint64_t a2, unsigned int a3)
{
  char *v6;
  char *v7;
  int v8;
  int v9;
  int v10;
  NSObject *v11;
  uint64_t v12;
  _QWORD *v13;
  int v14;
  int v16;
  NSObject *v17;
  const char *v18;
  const char *v19;
  int v20;
  NSObject *v21;
  int v22;
  const char *v23;
  const char *v24;
  int v25;
  const char *v26;
  const char *v27;
  uint64_t v28;
  uint8_t buf[4];
  const char *v30;
  __int16 v31;
  int v32;
  __int16 v33;
  _QWORD v34[2];
  _BYTE v35[1024];
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  bzero(v35, 0x400uLL);
  *(_DWORD *)a2 = a1;
  *(_DWORD *)(a2 + 16) = -1;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 32) = 0;
  *(_DWORD *)(a2 + 84) = versionTable[a3];
  pthread_once(&sContentIndexInitOnce, _ContentIndexInit);
  v6 = (char *)fd_create_protected(a1, "indexState", 0, 3u);
  if (v6)
  {
    v7 = v6;
    v28 = 0;
    v8 = _fd_acquire_fd((uint64_t)v6, &v28);
    if (v8 != -1)
    {
      v9 = v8;
      v10 = *__error();
      v11 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        v18 = fd_realpath(*(_DWORD **)(a2 + 8), v35);
        v30 = "CIMetaInfoCreate";
        v19 = "";
        *(_DWORD *)buf = 136315650;
        if (v18)
          v19 = v18;
        v31 = 1024;
        v32 = 227;
        v33 = 2080;
        v34[0] = v19;
        _os_log_error_impl(&dword_1B8270000, v11, OS_LOG_TYPE_ERROR, "%s:%d: Tried to create index when index already existed %s", buf, 0x1Cu);
      }
      *__error() = v10;
      _fd_release_fd(v7, v9, 0, v28);
      fd_release(v7);
      v12 = 0xFFFFFFFFLL;
      goto LABEL_9;
    }
    fd_release(v7);
  }
  v13 = fd_create_protected(a1, "indexState", 536872450, 3u);
  *(_QWORD *)(a2 + 8) = v13;
  v14 = _fd_acquire_fd((uint64_t)v13, (_QWORD *)(a2 + 24));
  *(_DWORD *)(a2 + 16) = v14;
  v12 = 0xFFFFFFFFLL;
  if (!*(_QWORD *)(a2 + 8) || v14 == -1 || (v12 = _CIMetaInfoSync(a2, 0), (_DWORD)v12))
  {
LABEL_9:
    CIMetaInfoClose(a2);
    return v12;
  }
  if (flock(*(_DWORD *)(a2 + 16), 6) != -1)
    return 0;
  v16 = *__error();
  v17 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
  {
    v22 = *__error();
    v23 = fd_realpath(*(_DWORD **)(a2 + 8), v35);
    *(_DWORD *)buf = 136315906;
    v24 = "";
    v30 = "CIMetaInfoCreate";
    v32 = 249;
    v31 = 1024;
    if (v23)
      v24 = v23;
    v33 = 1024;
    LODWORD(v34[0]) = v22;
    WORD2(v34[0]) = 2080;
    *(_QWORD *)((char *)v34 + 6) = v24;
    _os_log_error_impl(&dword_1B8270000, v17, OS_LOG_TYPE_ERROR, "%s:%d: flock err: %d,  %s", buf, 0x22u);
  }
  *__error() = v16;
  if (flock(*(_DWORD *)(a2 + 16), 2) != -1)
    return 0;
  v20 = *__error();
  v21 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
  {
    v25 = *__error();
    v26 = fd_realpath(*(_DWORD **)(a2 + 8), v35);
    *(_DWORD *)buf = 136315906;
    v27 = "";
    v30 = "CIMetaInfoCreate";
    v32 = 251;
    v31 = 1024;
    if (v26)
      v27 = v26;
    v33 = 1024;
    LODWORD(v34[0]) = v25;
    WORD2(v34[0]) = 2080;
    *(_QWORD *)((char *)v34 + 6) = v27;
    _os_log_error_impl(&dword_1B8270000, v21, OS_LOG_TYPE_ERROR, "%s:%d: flock err: %d,  %s", buf, 0x22u);
  }
  v12 = 0;
  *__error() = v20;
  return v12;
}

void _ContentIndexInit()
{
  const __CFDictionary *v0;
  const __CFDictionary *v1;
  const __CFString *Value;
  CFStringRef Copy;
  const __CFString *v4;
  const __CFAllocator *v5;
  CFMutableArrayRef Mutable;
  __CFArray *v7;
  CFMutableDictionaryRef v8;
  __CFDictionary *v9;
  __CFDictionary *v10;
  __CFDictionary *v11;
  io_iterator_t v12;
  io_object_t v13;
  io_registry_entry_t v14;
  const __CFData *CFProperty;
  const __CFData *v16;
  const UInt8 *BytePtr;
  CFIndex i;
  CFStringRef v19;
  __CFDictionary *v20;
  const __CFString *v21;
  __CFDictionary *v22;
  io_registry_entry_t parent;
  io_iterator_t existing;
  mach_port_t mainPort;
  char buffer[16];
  __int128 v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v0 = (const __CFDictionary *)_CFCopySystemVersionDictionary();
  if (v0)
  {
    v1 = v0;
    Value = (const __CFString *)CFDictionaryGetValue(v0, (const void *)*MEMORY[0x1E0C9AB90]);
    if (Value)
      Copy = CFStringCreateCopy(0, Value);
    else
      Copy = 0;
    CFRelease(v1);
  }
  else
  {
    Copy = 0;
  }
  *(_OWORD *)buffer = 0u;
  v27 = 0u;
  if (Copy)
    v4 = Copy;
  else
    v4 = &stru_1E6E3A6D8;
  if (!CFStringGetCString(&stru_1E6E3A6D8, buffer, 32, 0x8000100u))
    buffer[0] = 0;
  buildVersionCStr = (uint64_t)strdup(buffer);
  if (!CFStringGetCString(v4, buffer, 32, 0x8000100u))
    buffer[0] = 0;
  sysVersionCStr = (uint64_t)strdup(buffer);
  v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  if (Mutable)
  {
    v7 = Mutable;
    mainPort = 0;
    if (!IOMasterPort(0, &mainPort))
    {
      v8 = IOBSDNameMatching(mainPort, 0, "en0");
      if (v8)
      {
        v9 = v8;
        v10 = CFDictionaryCreateMutable(v5, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        if (v10)
        {
          v11 = v10;
          CFDictionarySetValue(v10, CFSTR("IOPrimaryInterface"), (const void *)*MEMORY[0x1E0C9AE50]);
          v22 = v11;
          CFDictionarySetValue(v9, CFSTR("IOPropertyMatch"), v11);
          existing = 0;
          if (!IOServiceGetMatchingServices(mainPort, v9, &existing))
          {
            v12 = existing;
            if (existing)
            {
              while (1)
              {
                v13 = IOIteratorNext(v12);
                if (!v13)
                  break;
                v14 = v13;
                CFArrayRemoveAllValues(v7);
                parent = 0;
                if (!IORegistryEntryGetParentEntry(v14, "IOService", &parent))
                {
                  CFProperty = (const __CFData *)IORegistryEntryCreateCFProperty(parent, CFSTR("IOMACAddress"), v5, 0);
                  if (CFProperty)
                  {
                    v16 = CFProperty;
                    BytePtr = CFDataGetBytePtr(CFProperty);
                    for (i = 0; CFDataGetLength(v16) > i; ++i)
                    {
                      v19 = CFStringCreateWithFormat(v5, 0, CFSTR("%02x"), BytePtr[i]);
                      CFArrayAppendValue(v7, v19);
                      CFRelease(v19);
                    }
                    CFRelease(v16);
                  }
                  IOObjectRelease(parent);
                }
                IOObjectRelease(v14);
                v12 = existing;
              }
            }
          }
          v20 = v22;
        }
        else
        {
          v20 = v9;
        }
        CFRelease(v20);
      }
    }
    v21 = CFStringCreateByCombiningStrings(v5, v7, CFSTR(":"));
    CFRelease(v7);
    if (v21)
    {
      if (!CFStringGetCString(v21, buffer, 32, 0x8000100u))
        buffer[0] = 0;
      CFRelease(v21);
    }
  }
  CFRelease(&stru_1E6E3A6D8);
  CFRelease(v4);
}

void CIMetaInfoClose(uint64_t a1)
{
  int v2;

  v2 = *(_DWORD *)(a1 + 16);
  if (v2 != -1)
  {
    flock(v2, 8);
    _fd_release_fd(*(_DWORD **)(a1 + 8), *(_DWORD *)(a1 + 16), 0, *(_QWORD *)(a1 + 24));
    *(_DWORD *)(a1 + 16) = -1;
  }
  fd_release(*(char **)(a1 + 8));
  *(_QWORD *)(a1 + 8) = 0;
}

uint64_t CIMetaInfoOpenAndLock(int a1, int a2, uint64_t a3)
{
  char *v6;
  int v7;
  _QWORD *v8;
  int v9;
  uint64_t v10;
  int v11;
  NSObject *v12;
  os_log_type_t v13;
  int32_t v14;
  int v15;
  BOOL v16;
  const char *v17;
  const char *v18;
  int32_t v19;
  int v20;
  BOOL v21;
  const char *v22;
  int v24;
  NSObject *v25;
  os_log_type_t v26;
  int32_t v27;
  const char *v28;
  const char *v29;
  int v30;
  NSObject *v31;
  os_log_type_t v32;
  int v33;
  BOOL v34;
  BOOL v35;
  int v36;
  NSObject *v37;
  os_log_type_t v38;
  int v39;
  NSObject *v40;
  os_log_type_t v41;
  int v42;
  NSObject *v43;
  os_log_type_t v44;
  uint8_t v45[4];
  int v46;
  statfs buf;
  _BYTE v48[1024];
  uint64_t v49;

  v49 = *MEMORY[0x1E0C80C00];
  *(_DWORD *)a3 = a1;
  v6 = *(char **)(a3 + 8);
  if (v6)
  {
    fd_release(v6);
    *(_QWORD *)(a3 + 8) = 0;
  }
  bzero(v48, 0x400uLL);
  *(_DWORD *)(a3 + 16) = -1;
  *(_BYTE *)(a3 + 88) = a2;
  pthread_once(&sContentIndexInitOnce, _ContentIndexInit);
  if (a2)
    v7 = 0;
  else
    v7 = 536870914;
  v8 = fd_create_protected(a1, "indexState", v7, 3u);
  *(_QWORD *)(a3 + 8) = v8;
  if (!v8)
  {
    v11 = *__error();
    v12 = _SILogForLogForCategory(10);
    v13 = dword_1EF19FCB4 < 3;
    if (os_log_type_enabled(v12, (os_log_type_t)(dword_1EF19FCB4 < 3)))
    {
      v14 = *__error();
      v15 = fcntl(a1, 50, v48);
      if (v48[0])
        v16 = v15 < 0;
      else
        v16 = 1;
      v17 = "";
      if (!v16)
        v17 = v48;
      buf.f_bsize = 67109378;
      buf.f_iosize = v14;
      LOWORD(buf.f_blocks) = 2080;
      *(uint64_t *)((char *)&buf.f_blocks + 2) = (uint64_t)v17;
      v18 = "*warn* failed to create fd_ref err: %d,  %s";
      goto LABEL_25;
    }
LABEL_26:
    *__error() = v11;
    v10 = 0xFFFFFFFFLL;
    goto LABEL_27;
  }
  v9 = _fd_acquire_fd((uint64_t)v8, (_QWORD *)(a3 + 24));
  *(_DWORD *)(a3 + 16) = v9;
  if (v9 == -1)
  {
    v11 = *__error();
    v12 = _SILogForLogForCategory(10);
    v13 = dword_1EF19FCB4 < 3;
    if (os_log_type_enabled(v12, (os_log_type_t)(dword_1EF19FCB4 < 3)))
    {
      v19 = *__error();
      v20 = fcntl(a1, 50, v48);
      if (v48[0])
        v21 = v20 < 0;
      else
        v21 = 1;
      v22 = "";
      if (!v21)
        v22 = v48;
      buf.f_bsize = 67109378;
      buf.f_iosize = v19;
      LOWORD(buf.f_blocks) = 2080;
      *(uint64_t *)((char *)&buf.f_blocks + 2) = (uint64_t)v22;
      v18 = "*warn* failed to open fd_ref err: %d,  %s";
LABEL_25:
      _os_log_impl(&dword_1B8270000, v12, v13, v18, (uint8_t *)&buf, 0x12u);
      goto LABEL_26;
    }
    goto LABEL_26;
  }
  if ((a2 & 1) == 0 && flock(v9, 6) == -1)
  {
    accurate_realpath((int *)".", (uint64_t)v48);
    v24 = *__error();
    v25 = _SILogForLogForCategory(10);
    v26 = dword_1EF19FCB4 < 3;
    if (os_log_type_enabled(v25, (os_log_type_t)(dword_1EF19FCB4 < 3)))
    {
      v27 = *__error();
      v28 = fd_realpath(*(_DWORD **)(a3 + 8), v48);
      v29 = "";
      if (v28)
        v29 = v28;
      buf.f_bsize = 67109378;
      buf.f_iosize = v27;
      LOWORD(buf.f_blocks) = 2080;
      *(uint64_t *)((char *)&buf.f_blocks + 2) = (uint64_t)v29;
      _os_log_impl(&dword_1B8270000, v25, v26, "*warn* flock err: %d,  %s", (uint8_t *)&buf, 0x12u);
    }
    *__error() = v24;
    bzero(&buf, 0x878uLL);
    if (fstatfs(*(_DWORD *)(a3 + 16), &buf))
    {
      v30 = *__error();
      v31 = _SILogForLogForCategory(10);
      v32 = dword_1EF19FCB4 < 3;
      if (os_log_type_enabled(v31, (os_log_type_t)(dword_1EF19FCB4 < 3)))
      {
        v33 = *__error();
        *(_DWORD *)v45 = 67109120;
        v46 = v33;
        _os_log_impl(&dword_1B8270000, v31, v32, "*warn* Couldn't statfs the CIMetaInfo. errno:%d", v45, 8u);
      }
      v10 = 4294967294;
    }
    else
    {
      v34 = *(_DWORD *)buf.f_fstypename == 1717726579 && *(unsigned __int16 *)&buf.f_fstypename[4] == 115;
      if (v34
        || (*(_DWORD *)buf.f_fstypename == 1718642273
          ? (v35 = *(unsigned __int16 *)&buf.f_fstypename[4] == 115)
          : (v35 = 0),
            v35 || *(_DWORD *)buf.f_fstypename == 7562862))
      {
        v30 = *__error();
        v43 = _SILogForLogForCategory(10);
        v44 = dword_1EF19FCB4 < 3;
        if (os_log_type_enabled(v43, (os_log_type_t)(dword_1EF19FCB4 < 3)))
        {
          *(_WORD *)v45 = 0;
          _os_log_impl(&dword_1B8270000, v43, v44, "*warn* Failed to acquire lock on SMB CIMetaInfo; it might already be open by another machine's mds_stores.",
            v45,
            2u);
        }
        v10 = 4294967293;
      }
      else
      {
        v36 = *__error();
        v37 = _SILogForLogForCategory(10);
        v38 = dword_1EF19FCB4 < 3;
        if (os_log_type_enabled(v37, (os_log_type_t)(dword_1EF19FCB4 < 3)))
        {
          v39 = *(_DWORD *)(a3 + 16);
          *(_DWORD *)v45 = 67109120;
          v46 = v39;
          _os_log_impl(&dword_1B8270000, v37, v38, "*warn* Trying to acquire lock on CIMetaInfo again fd:%d", v45, 8u);
        }
        *__error() = v36;
        if (!flock(*(_DWORD *)(a3 + 16), 2))
          return 0;
        v30 = *__error();
        v40 = _SILogForLogForCategory(10);
        v41 = dword_1EF19FCB4 < 3;
        if (os_log_type_enabled(v40, (os_log_type_t)(dword_1EF19FCB4 < 3)))
        {
          v42 = *__error();
          *(_DWORD *)v45 = 67109120;
          v46 = v42;
          _os_log_impl(&dword_1B8270000, v40, v41, "*warn* Failed to acquire lock on CIMetaInfo object: errno=%d", v45, 8u);
        }
        v10 = 4294967292;
      }
    }
    *__error() = v30;
LABEL_27:
    CIMetaInfoClose(a3);
    return v10;
  }
  return 0;
}

uint64_t CIMetaInfoRead(uint64_t a1, int a2)
{
  _DWORD *v2;
  unsigned int v5;
  unsigned int v6;
  uint64_t result;
  int v8;
  int v9;
  NSObject *v10;
  const char *v11;
  const char *v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD v22[4];
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  int v26;
  __int16 v27;
  const char *v28;
  _BYTE v29[1024];
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v2 = *(_DWORD **)(a1 + 8);
  if (!v2 || *(_DWORD *)(a1 + 16) == -1)
    return 0xFFFFFFFFLL;
  bzero(v29, 0x400uLL);
  memset(v22, 0, 28);
  if (fd_pread(v2, v22, 0x1CuLL, 0) != 28)
  {
    v9 = *__error();
    v10 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      v11 = fd_realpath(*(_DWORD **)(a1 + 8), v29);
      v24 = "CIMetaInfoRead";
      v12 = "";
      *(_DWORD *)buf = 136315650;
      if (v11)
        v12 = v11;
      v25 = 1024;
      v26 = 345;
      v27 = 2080;
      v28 = v12;
      _os_log_error_impl(&dword_1B8270000, v10, OS_LOG_TYPE_ERROR, "%s:%d: invalid generation file, resetting %s", buf, 0x1Cu);
    }
    *__error() = v9;
    return 0xFFFFFFFFLL;
  }
  if ((LODWORD(v22[0]) - 3) > 2)
    return 0xFFFFFFFFLL;
  v5 = HIDWORD(v22[0]);
  v6 = v22[1];
  *(_DWORD *)(a1 + 32) = HIDWORD(v22[0]);
  *(_DWORD *)(a1 + 36) = v6;
  if (v6 > v5)
  {
    v13 = __si_assert_copy_extra_268();
    __message_assert_272((uint64_t)v13, v14, v15, v16, v17, v18, v19, v20, (char)"ContentIndexCommon.c");
    free(v13);
    if (__valid_fs(-1))
      v21 = 2989;
    else
      v21 = 3072;
    *(_DWORD *)v21 = -559038737;
    abort();
  }
  result = 0;
  *(_OWORD *)(a1 + 40) = *(_OWORD *)((char *)&v22[1] + 4);
  if (a2)
    v8 = 114;
  else
    v8 = 102;
  *(_DWORD *)(a1 + 84) = v8;
  return result;
}

_QWORD *ContentIndexListClone(__int128 *a1)
{
  _QWORD *v2;
  _QWORD *v3;
  __int128 v4;
  unsigned int v5;
  size_t v6;
  void *v7;

  v2 = malloc_type_calloc(1uLL, 0x18uLL, 0x1080040A085CBA5uLL);
  v3 = v2;
  if (a1)
  {
    v4 = *a1;
    v2[2] = *((_QWORD *)a1 + 2);
    *(_OWORD *)v2 = v4;
  }
  v5 = *((_DWORD *)v2 + 3);
  if (v5)
    v6 = v5;
  else
    v6 = 2;
  *((_DWORD *)v3 + 3) = v6;
  v7 = malloc_type_calloc(v6, 8uLL, 0x2004093837F09uLL);
  *v3 = v7;
  if (a1)
    memcpy(v7, *(const void **)a1, 8 * *((unsigned int *)v3 + 3));
  return v3;
}

void ContentIndexListFree(void **a1)
{
  if (a1)
  {
    free(*a1);
    free(a1);
  }
}

void ContentIndexListAppend(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  unsigned int v6;
  char *v7;
  _QWORD *v8;
  char v9;

  v4 = *(unsigned int *)(a1 + 8);
  v5 = v4;
  if ((_DWORD)v4 == *(_DWORD *)(a1 + 12))
  {
    v6 = 2 * v4;
    if (!(_DWORD)v4)
      v6 = 2;
    *(_DWORD *)(a1 + 12) = v6;
    v7 = (char *)malloc_type_realloc(*(void **)a1, 8 * v6, 0x2004093837F09uLL);
    *(_QWORD *)a1 = v7;
    bzero(&v7[8 * v4], 8 * *(unsigned int *)(a1 + 12) - 8 * v4);
    v5 = *(_DWORD *)(a1 + 8);
  }
  v8 = *(_QWORD **)a1;
  *(_DWORD *)(a1 + 8) = v5 + 1;
  v8[v5] = a2;
  if (*(_DWORD *)(a1 + 16) == -1)
  {
    v9 = atomic_load((unsigned int *)(a2 + 28));
    if ((v9 & 3) == 0 && !*(_BYTE *)(a2 + 15163))
      *(_DWORD *)(a1 + 16) = v4;
  }
}

int *ContentIndexListDump(uint64_t a1)
{
  int v2;
  NSObject *v3;
  os_log_type_t v4;
  int v5;
  unsigned int v6;
  int *result;
  unint64_t v8;
  uint64_t v9;
  int v10;
  NSObject *v11;
  os_log_type_t v12;
  int v13;
  unsigned int v14;
  uint8_t buf[4];
  uint64_t v16;
  __int16 v17;
  int v18;
  __int16 v19;
  unsigned int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v2 = *__error();
  v3 = _SILogForLogForCategory(0);
  v4 = gSILogLevels[0] < 3;
  if (os_log_type_enabled(v3, (os_log_type_t)(gSILogLevels[0] < 3)))
  {
    v5 = *(_DWORD *)(a1 + 8);
    v6 = *(_DWORD *)(a1 + 16);
    *(_DWORD *)buf = 134218496;
    v16 = a1;
    v17 = 1024;
    v18 = v5;
    v19 = 1024;
    v20 = v6;
    _os_log_impl(&dword_1B8270000, v3, v4, "*warn* indexSet:%p count:%d current:%d", buf, 0x18u);
  }
  result = __error();
  *result = v2;
  if (*(_DWORD *)(a1 + 8))
  {
    v8 = 0;
    do
    {
      v9 = *(_QWORD *)(*(_QWORD *)a1 + 8 * v8);
      v10 = *__error();
      v11 = _SILogForLogForCategory(0);
      v12 = gSILogLevels[0] < 3;
      if (os_log_type_enabled(v11, (os_log_type_t)(gSILogLevels[0] < 3)))
      {
        v13 = *(_DWORD *)(v9 + 48);
        v14 = atomic_load((unsigned int *)(v9 + 28));
        *(_DWORD *)buf = 136315650;
        v16 = v9 + 15168;
        v17 = 1024;
        v18 = v13;
        v19 = 1024;
        v20 = v14;
        _os_log_impl(&dword_1B8270000, v11, v12, "*warn* \t%s id:%d flags:%x", buf, 0x18u);
      }
      result = __error();
      *result = v10;
      ++v8;
    }
    while (v8 < *(unsigned int *)(a1 + 8));
  }
  return result;
}

uint64_t ContentIndexCreateNew(uint64_t a1, const __CFString *a2, uint64_t a3, int a4, __int16 a5, int a6, int a7, uint64_t a8, uint64_t a9, const void *a10)
{
  uint64_t v18;
  NSObject *v19;
  uint64_t v20;
  int v22;
  int v23;
  uint8_t buf[16];
  __int128 v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;
  _QWORD v29[3];
  uint64_t v30;

  pthread_once(&sContentIndexInitOnce, _ContentIndexInit);
  if (a8)
  {
    v18 = _CICreateNew(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
  }
  else
  {
    v22 = *__error();
    v19 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1B8270000, v19, OS_LOG_TYPE_DEFAULT, "Creating index without vector store", buf, 2u);
    }
    *__error() = v22;
    v18 = _CICreateNew(a1, a2, a3, a4, a5, a6, a7, 0, a9, a10);
  }
  v20 = v18;
  if (v18)
  {
    v23 = 0;
    v28 = 0;
    v26 = 0u;
    v27 = 0u;
    *(_OWORD *)buf = 0u;
    v25 = 0u;
    v30 = v18;
    v29[2] = 0;
    v29[0] = &v30;
    v29[1] = 0x100000001;
    _ContentIndexSyncIndexBulk(0, (uint64_t)v29, 0, 0, (uint64_t)buf, (uint64_t)&v23, 0, 0);
  }
  return v20;
}

uint64_t ContentIndexGetVersionForDirectory(int a1)
{
  uint64_t v2;
  uint64_t v3;
  ssize_t v4;
  uint64_t v5;
  int *v7;
  uint64_t v8;
  unsigned int __buf;
  char __str[1024];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  bzero(__str, 0x400uLL);
  snprintf(__str, 0x400uLL, "%s%s", "0.", "indexHead");
  v2 = openat(a1, __str, 0, 0);
  if ((_DWORD)v2 == -1)
  {
    __error();
    return 0xFFFFFFFFLL;
  }
  else
  {
    v3 = v2;
    __buf = -1;
    while (1)
    {
      v4 = pread(v3, &__buf, 4uLL, 0);
      v5 = g_prot_error_callback;
      if (v4 != -1 || g_prot_error_callback == 0)
        break;
      v7 = __error();
      if (((*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t))(v5 + 16))(v5, v3, *v7, 4) & 1) == 0)
      {
        v8 = 0xFFFFFFFFLL;
        goto LABEL_13;
      }
    }
    if (v4 == 4)
      v8 = __buf;
    else
      v8 = 0xFFFFFFFFLL;
LABEL_13:
    close(v3);
  }
  return v8;
}

uint64_t ContentIndexUpdateState(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, _BYTE *a9)
{
  uint64_t v9;
  int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  int v22;
  int v23;
  uint64_t v24;
  const char *v25;
  uint64_t updated;
  uint64_t v27;
  ssize_t v28;
  uint64_t v29;
  int *v31;
  char v32;
  int v33;
  NSObject *v34;
  const char *v35;
  int v36;
  NSObject *v37;
  unsigned int *v39;
  int v40;
  char v41[1024];
  char __str[1024];
  uint8_t v43[4];
  const char *v44;
  __int16 v45;
  int v46;
  __int16 v47;
  char *v48;
  uint8_t buf[4];
  const char *v50;
  __int16 v51;
  int v52;
  __int16 v53;
  int v54;
  __int16 v55;
  int v56;
  _BYTE v57[4096];
  char v58[1024];
  char v59[1024];
  uint64_t v60;

  v9 = MEMORY[0x1E0C80A78](a1);
  v11 = v10;
  v13 = v12;
  v15 = v14;
  v17 = v16;
  v19 = v18;
  v21 = v20;
  v23 = v22;
  v24 = v9;
  v60 = *MEMORY[0x1E0C80C00];
  bzero(__str, 0x400uLL);
  if (v15)
  {
    v25 = "live.%d.";
    snprintf(__str, 0x400uLL, "live.%d.");
  }
  else
  {
    v25 = "%d.";
    snprintf(__str, 0x400uLL, "%d.");
  }
  snprintf(v41, 0x400uLL, v25, v13);
  *a9 = 0;
  switch(v11)
  {
    case 1:
      updated = indexUpdateHeader(v24);
      if ((_DWORD)updated)
        goto LABEL_43;
      if (!recoverIndex(v24))
        goto LABEL_42;
      goto LABEL_7;
    case 2:
      updated = indexUpdateHeader(v24);
      if ((_DWORD)updated)
        goto LABEL_43;
      *a9 = 2;
      return updated;
    case 3:
      updated = indexUpdateHeader(v24);
      if ((_DWORD)updated)
        goto LABEL_43;
      bzero(v59, 0x400uLL);
      bzero(v58, 0x400uLL);
      v40 = 0;
      bzero(v57, 0x1000uLL);
      v39 = (unsigned int *)v57;
      snprintf(v59, 0x400uLL, "%s%s", __str, "indexHead");
      v27 = openat(v24, v59, 536870914, 0);
      if ((_DWORD)v27 == -1)
      {
        if (*__error() != 22)
          goto LABEL_42;
        v27 = openat(v24, v59, 2, 0);
        if ((_DWORD)v27 == -1)
          goto LABEL_42;
      }
      break;
    case 4:
      goto LABEL_7;
    default:
      return 0;
  }
  while (1)
  {
    v28 = pread(v27, v57, 0x1000uLL, 0);
    v29 = g_prot_error_callback;
    if (v28 != -1 || g_prot_error_callback == 0)
      break;
    v31 = __error();
    if (((*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t))(v29 + 16))(v29, v27, *v31, 4) & 1) == 0)
      goto LABEL_34;
  }
  if (v28 != 4096)
  {
LABEL_34:
    close(v27);
    updated = 0xFFFFFFFFLL;
    goto LABEL_43;
  }
  close(v27);
  bzero(buf, 0x4040uLL);
  if ((indexRestoreHeaderFromBuffer(buf, &v39, v23, v21, v19, 0) & 1) == 0)
  {
    v33 = *__error();
    v34 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
      goto LABEL_41;
    *(_DWORD *)v43 = 136315650;
    v44 = "fullShadowIndex";
    v45 = 1024;
    v46 = 3304;
    v47 = 2080;
    v48 = __str;
    v35 = "%s:%d: Unrecoverable error: Malformed index head file (%s)";
    goto LABEL_55;
  }
  v32 = atomic_load((unsigned int *)((char *)&v56 + 2));
  snprintf(v59, 0x400uLL, "%s%s", __str, "indexGroups");
  snprintf(v58, 0x400uLL, "%s%s", __str, "shadowIndexGroups");
  if ((copyFileFallback(v24, v59, v24, v58, &v40, 1, 1) & 1) == 0)
  {
    v33 = *__error();
    v34 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
      goto LABEL_41;
    *(_DWORD *)v43 = 136315650;
    v44 = "fullShadowIndex";
    v45 = 1024;
    v46 = 3312;
    v47 = 2080;
    v48 = v59;
    v35 = "%s:%d: error copying (%s)";
    goto LABEL_55;
  }
  if (v17)
  {
    snprintf(v59, 0x400uLL, "%s%s", __str, "directoryStoreFile");
    snprintf(v58, 0x400uLL, "%s%s", __str, "directoryStoreFile.shadow");
    if ((copyFileFallback(v24, v59, v24, v58, &v40, 1, 1) & 1) == 0)
    {
      v33 = *__error();
      v34 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
        goto LABEL_41;
      *(_DWORD *)v43 = 136315650;
      v44 = "fullShadowIndex";
      v45 = 1024;
      v46 = 3320;
      v47 = 2080;
      v48 = v59;
      v35 = "%s:%d: error copying (%s)";
      goto LABEL_55;
    }
  }
  if ((v32 & 2) == 0)
  {
    snprintf(v59, 0x400uLL, "%s%s", __str, "indexTermIds");
    snprintf(v58, 0x400uLL, "%s%s", __str, "shadowIndexTermIds");
    if ((copyFileFallback(v24, v59, v24, v58, &v40, 1, 1) & 1) == 0)
    {
      v33 = *__error();
      v34 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
        goto LABEL_41;
      *(_DWORD *)v43 = 136315650;
      v44 = "fullShadowIndex";
      v45 = 1024;
      v46 = 3330;
      v47 = 2080;
      v48 = v59;
      v35 = "%s:%d: error copying (%s)";
      goto LABEL_55;
    }
    snprintf(v59, 0x400uLL, "%s%s", __str, "indexPositionTable");
    snprintf(v58, 0x400uLL, "%s%s", __str, "shadowIndexPositionTable");
    if ((copyFileFallback(v24, v59, v24, v58, &v40, 1, 1) & 1) == 0)
    {
      v33 = *__error();
      v34 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
        goto LABEL_41;
      *(_DWORD *)v43 = 136315650;
      v44 = "fullShadowIndex";
      v45 = 1024;
      v46 = 3338;
      v47 = 2080;
      v48 = v59;
      v35 = "%s:%d: error copying (%s)";
      goto LABEL_55;
    }
    snprintf(v59, 0x400uLL, "%s%s", __str, "indexDirectory");
    snprintf(v58, 0x400uLL, "%s%s", __str, "shadowIndexDirectory");
    if ((copyFileFallback(v24, v59, v24, v58, &v40, 1, 1) & 1) != 0)
    {
      snprintf(v59, 0x400uLL, "%s%s", __str, "indexCompactDirectory");
      snprintf(v58, 0x400uLL, "%s%s", __str, "shadowIndexCompactDirectory");
      if ((copyFileFallback(v24, v59, v24, v58, &v40, 1, 1) & 1) != 0)
      {
        snprintf(v59, 0x400uLL, "%s%s", __str, "indexArrays");
        snprintf(v58, 0x400uLL, "%s%s", __str, "shadowIndexArrays");
        if ((copyFileFallback(v24, v59, v24, v58, &v40, 1, 1) & 1) != 0)
          goto LABEL_31;
        v33 = *__error();
        v34 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)v43 = 136315650;
          v44 = "fullShadowIndex";
          v45 = 1024;
          v46 = 3360;
          v47 = 2080;
          v48 = v59;
          v35 = "%s:%d: error copying (%s)";
          goto LABEL_55;
        }
LABEL_41:
        *__error() = v33;
LABEL_42:
        updated = 0xFFFFFFFFLL;
        goto LABEL_43;
      }
      v33 = *__error();
      v34 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
        goto LABEL_41;
      *(_DWORD *)v43 = 136315650;
      v44 = "fullShadowIndex";
      v45 = 1024;
      v46 = 3353;
      v47 = 2080;
      v48 = v59;
      v35 = "%s:%d: error copying (%s)";
    }
    else
    {
      v33 = *__error();
      v34 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
        goto LABEL_41;
      *(_DWORD *)v43 = 136315650;
      v44 = "fullShadowIndex";
      v45 = 1024;
      v46 = 3346;
      v47 = 2080;
      v48 = v59;
      v35 = "%s:%d: error copying (%s)";
    }
LABEL_55:
    _os_log_error_impl(&dword_1B8270000, v34, OS_LOG_TYPE_ERROR, v35, v43, 0x1Cu);
    goto LABEL_41;
  }
LABEL_31:
  snprintf(v59, 0x400uLL, "%s%s", __str, "indexHead");
  snprintf(v58, 0x400uLL, "%s%s", __str, "shadowIndexHead");
  if ((copyFileFallback(v24, v59, v24, v58, &v40, 1, 1) & 1) == 0)
  {
    v33 = *__error();
    v34 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
      goto LABEL_41;
    *(_DWORD *)v43 = 136315650;
    v44 = "fullShadowIndex";
    v45 = 1024;
    v46 = 3369;
    v47 = 2080;
    v48 = v59;
    v35 = "%s:%d: error copying (%s)";
    goto LABEL_55;
  }
LABEL_7:
  updated = indexUpdateHeader(v24);
  if (!(_DWORD)updated)
  {
    *a9 = 4;
    return updated;
  }
LABEL_43:
  v36 = *__error();
  v37 = _SILogForLogForCategory(10);
  if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136315906;
    v50 = "_CIUpdateState";
    v51 = 1024;
    v52 = 309;
    v53 = 1024;
    v54 = v11;
    v55 = 1024;
    v56 = updated;
    _os_log_error_impl(&dword_1B8270000, v37, OS_LOG_TYPE_ERROR, "%s:%d: update state (%d) failed err:%d", buf, 0x1Eu);
  }
  *__error() = v36;
  return updated;
}

uint64_t ContentIndexOpenBulk(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, const void *a11)
{
  uint64_t v11;
  char **v12;
  char **v13;
  time_t *v14;
  time_t *v15;
  _DWORD *v16;
  _DWORD *v17;
  unsigned int v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int *v26;
  int v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  _DWORD *v31;
  int v32;
  NSObject *v33;
  uint64_t v34;
  uint64_t v35;
  const char *v36;
  NSObject *v37;
  os_log_type_t v38;
  uint32_t v39;
  NSObject *v40;
  os_log_type_t v41;
  int *v42;
  char *v43;
  int v44;
  NSObject *v45;
  os_log_type_t v46;
  uint64_t v48;
  int v49;
  BOOL v50;
  _BYTE *v51;
  int v52;
  uint64_t v53;
  _BOOL4 v54;
  int v55;
  NSObject *v56;
  os_log_type_t v57;
  const char *v58;
  NSObject *v59;
  const char *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  int v65;
  const char *v66;
  int *v67;
  int v68;
  int v69;
  int v70;
  char *v71;
  char *v72;
  uint64_t v73;
  char v74;
  int v75;
  NSObject *v76;
  os_log_type_t v77;
  unsigned int v78;
  int v79;
  int v80;
  NSObject *v81;
  _BOOL4 v82;
  int v83;
  BOOL v84;
  NSObject *v85;
  NSObject *v86;
  uint32_t v87;
  NSObject *v88;
  unsigned int v89;
  NSObject *v90;
  int v91;
  int v92;
  unsigned int *v93;
  unsigned int *v94;
  char v95;
  char v96;
  BOOL v97;
  const char *v98;
  uint64_t v99;
  unsigned int *v100;
  unsigned int v101;
  uint64_t v102;
  uint64_t v103;
  int v104;
  int v105;
  NSObject *v106;
  os_log_type_t v107;
  char *v108;
  char *v109;
  BOOL *v110;
  _QWORD *v111;
  uint64_t v112;
  int v113;
  unsigned int v114;
  char v115;
  unsigned int v116;
  unsigned int v117;
  uint64_t v118;
  uint64_t v119;
  off_t v120;
  off_t v121;
  int v122;
  NSObject *v123;
  _BOOL4 v124;
  _QWORD *v125;
  uint64_t v126;
  off_t v127;
  uint64_t v128;
  off_t v129;
  unsigned int v130;
  unsigned int v131;
  _QWORD *v132;
  const char *v133;
  const char *v134;
  _QWORD *v135;
  int v136;
  NSObject *v137;
  int v138;
  int v139;
  uint64_t v140;
  __int32 v141;
  time_t v142;
  int64x2_t v143;
  int64x2_t v144;
  int64x2_t v145;
  int64x2_t v146;
  int64x2_t v147;
  int64x2_t v148;
  unint64_t v149;
  int v150;
  NSObject *v151;
  os_log_type_t v152;
  int *v153;
  int v154;
  const char *v155;
  uint64_t v156;
  int *v157;
  int v158;
  uint64_t v159;
  uint64_t v160;
  char *v161;
  uint64_t v162;
  int v163;
  NSObject *v164;
  os_log_type_t v165;
  char *v166;
  int v167;
  unint64_t v168;
  int v169;
  NSObject *v170;
  int *v171;
  int v172;
  NSObject *v173;
  os_log_type_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  char v182;
  int v183;
  NSObject *v184;
  const char *v185;
  int v186;
  uint64_t v187;
  tm *v188;
  int v189;
  NSObject *v190;
  char *v191;
  unsigned int v192;
  uint64_t v193;
  int v194;
  NSObject *v195;
  os_log_type_t v196;
  unsigned int v197;
  unsigned int *v198;
  int v199;
  int v200;
  char v201;
  char **v202;
  uint64_t v203;
  uint64_t v204;
  unsigned int *v205;
  int v206;
  uint64_t v207;
  uint64_t v208;
  char v209;
  unsigned int *v210;
  unsigned int *v211;
  uint64_t v212;
  uint64_t v213;
  time_t *v214;
  _DWORD *v215;
  int v216;
  unsigned int v217;
  unsigned int v218;
  unsigned int v219;
  int64x2_t v220;
  int64x2_t v221;
  int64x2_t v222;
  int64x2_t v223;
  int64x2_t v224;
  int64x2_t v225;
  unsigned int __format;
  const char *__formata;
  unsigned int *v228;
  time_t v229[13];
  unsigned __int8 v230;
  int v231;
  uint8_t buf[4];
  uint64_t v233;
  __int16 v234;
  uint64_t v235;
  unsigned int v236[12];
  uint64_t v237;
  _BYTE v238[1024];
  char v239[1024];
  _DWORD v240[4];
  _BYTE v241[12];
  int64x2_t v242[256];
  int v243;
  int64x2_t *v244;
  __int16 v245;
  char *v246;
  __int16 v247;
  uint64_t v248;
  uint64_t v249;

  v11 = MEMORY[0x1E0C80A78](a1);
  v13 = v12;
  v15 = v14;
  v17 = v16;
  v19 = v18;
  v21 = v20;
  v23 = v22;
  v25 = v24;
  v26 = (unsigned int *)v11;
  v249 = *MEMORY[0x1E0C80C00];
  pthread_once(&sContentIndexInitOnce, _ContentIndexInit);
  if ((v19 & 0x100) != 0)
    v27 = 111;
  else
    v27 = 95;
  if ((v19 & 0x100) != 0)
    v28 = 114;
  else
    v28 = 102;
  v29 = *v26;
  if (*v17)
  {
    _si_set_error_str("open canceled");
    return 0xFFFFFFFFLL;
  }
  *v15 = 0;
  *v13 = 0;
  v31 = &unk_1EF19F000;
  if (!*((_QWORD *)v26 + 1))
  {
    _si_set_error_str("No meta info");
    v32 = *__error();
    v40 = _SILogForLogForCategory(10);
    v41 = 2 * (dword_1EF19FCB4 < 4);
    if (os_log_type_enabled(v40, v41))
    {
      *(_WORD *)buf = 0;
      v36 = "No meta info";
      v37 = v40;
      v38 = v41;
      v39 = 2;
      goto LABEL_15;
    }
LABEL_16:
    v42 = __error();
    v43 = 0;
LABEL_17:
    *v42 = v32;
    v30 = 0xFFFFFFFFLL;
    goto LABEL_18;
  }
  if (v26[8] < v26[9])
  {
    _si_set_error_str("invalid meta info");
    v32 = *__error();
    v33 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
    {
      v34 = v26[8];
      v35 = v26[9];
      *(_DWORD *)buf = 134218240;
      v233 = v34;
      v234 = 2048;
      v235 = v35;
      v36 = "invalid meta info, cleanGeneration:%ld, shadowedGeneraton:%ld";
      v37 = v33;
      v38 = OS_LOG_TYPE_DEFAULT;
      v39 = 22;
LABEL_15:
      _os_log_impl(&dword_1B8270000, v37, v38, v36, buf, v39);
      goto LABEL_16;
    }
    goto LABEL_16;
  }
  v218 = v28;
  v219 = v27;
  v217 = v19;
  v214 = v15;
  v215 = v17;
  v202 = v13;
  if (v25)
  {
    *(_QWORD *)(v25 + 96) = 0;
    *(_OWORD *)(v25 + 64) = 0u;
    *(_OWORD *)(v25 + 80) = 0u;
    *(_OWORD *)(v25 + 32) = 0u;
    *(_OWORD *)(v25 + 48) = 0u;
    *(_OWORD *)v25 = 0u;
    *(_OWORD *)(v25 + 16) = 0u;
  }
  v203 = v25;
  v48 = a10;
  bzero(v239, 0x400uLL);
  bzero(v238, 0x400uLL);
  bzero(buf, 0x4040uLL);
  v231 = 0;
  v43 = copyVolumeInfoStr(v29);
  v49 = fcntl(v29, 50, v238);
  if (v238[0])
    v50 = v49 < 0;
  else
    v50 = 1;
  if (v50)
    v51 = 0;
  else
    v51 = v238;
  v204 = (uint64_t)v51;
  if (!v26[8])
  {
    if ((v217 & 0x1001) == 1)
    {
      snprintf(v239, 0x400uLL, "%d.", 0);
      v61 = createIndex(v29, v239, 0, (uint64_t)v43, v217, 0, 0, &v231, v26[21], a9, a10, a11);
      if (v61)
      {
        v62 = v61;
        ContentIndexListAppend(v23, v61);
        *(_DWORD *)(v62 + 32) = 1;
        snprintf(v239, 0x400uLL, "live.%d.", 0);
        v63 = createIndex(v29, v239, 0, (uint64_t)v43, v217, 0, 1, &v231, v26[21], a9, a10, a11);
        if (v63)
        {
          v64 = v63;
          ContentIndexListAppend(v21, v63);
          *(_DWORD *)(v64 + 32) = 2;
          v30 = 1;
          goto LABEL_18;
        }
        _si_set_error_str("create index error");
        v32 = *__error();
        v90 = _SILogForLogForCategory(10);
        if (!os_log_type_enabled(v90, OS_LOG_TYPE_ERROR))
          goto LABEL_224;
        v242[0].i32[0] = 136316162;
        *(uint64_t *)((char *)v242[0].i64 + 4) = (uint64_t)"_CIOpenBulk";
        v242[0].i16[6] = 1024;
        *(__int32 *)((char *)&v242[0].i32[3] + 2) = 399;
        v242[1].i16[1] = 2080;
        *(uint64_t *)((char *)v242[1].i64 + 4) = v204;
        v242[1].i16[6] = 2080;
        *(uint64_t *)((char *)&v242[1].i64[1] + 6) = (uint64_t)v239;
        v242[2].i16[3] = 1024;
        v242[2].i32[2] = -1;
      }
      else
      {
        _si_set_error_str("create index error");
        v32 = *__error();
        v90 = _SILogForLogForCategory(10);
        if (!os_log_type_enabled(v90, OS_LOG_TYPE_ERROR))
          goto LABEL_224;
        v242[0].i32[0] = 136316162;
        *(uint64_t *)((char *)v242[0].i64 + 4) = (uint64_t)"_CIOpenBulk";
        v242[0].i16[6] = 1024;
        *(__int32 *)((char *)&v242[0].i32[3] + 2) = 403;
        v242[1].i16[1] = 2080;
        *(uint64_t *)((char *)v242[1].i64 + 4) = v204;
        v242[1].i16[6] = 2080;
        *(uint64_t *)((char *)&v242[1].i64[1] + 6) = (uint64_t)v239;
        v242[2].i16[3] = 1024;
        v242[2].i32[2] = 0;
      }
      _os_log_error_impl(&dword_1B8270000, v90, OS_LOG_TYPE_ERROR, "%s:%d: Failed creating %s/%s, result:%d", (uint8_t *)v242, 0x2Cu);
      goto LABEL_224;
    }
    _si_set_error_str("success: no data in index, rebuilding");
    _si_set_rebuild_reason("no data in index", 1);
    v32 = *__error();
    v85 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v85, OS_LOG_TYPE_DEFAULT))
    {
      v242[0].i64[0] = -4227858176;
      v60 = "no data in index - rebuilding, result:%d";
      v86 = v85;
      v87 = 8;
LABEL_99:
      _os_log_impl(&dword_1B8270000, v86, OS_LOG_TYPE_DEFAULT, v60, (uint8_t *)v242, v87);
      goto LABEL_224;
    }
    goto LABEL_224;
  }
  v230 = 0;
  v216 = (v217 >> 8) & 1;
  v228 = v26;
  v207 = v21;
  v208 = v23;
  v212 = (uint64_t)v43;
  if ((v217 & 2) != 0)
  {
    __format = v29;
    v209 = 0;
    v65 = 0;
    v211 = v26 + 10;
    v210 = v26 + 11;
    while (1)
    {
      if (v65)
        v66 = "live.%d.";
      else
        v66 = "%d.";
      v67 = (int *)v211;
      if (v65)
        v67 = (int *)v210;
      v68 = *v67;
      if (v68 >= 1)
        break;
LABEL_80:
      if (v230)
        v84 = 0;
      else
        v84 = v65 == 0;
      ++v65;
      if (!v84)
      {
        if (v230)
        {
          v30 = 4294967294;
          v31 = (_DWORD *)&unk_1EF19F000;
          v29 = v29;
          goto LABEL_90;
        }
        v150 = *__error();
        v151 = _SILogForLogForCategory(10);
        v152 = 2 * (dword_1EF19FCB4 < 4);
        v29 = v29;
        if (os_log_type_enabled(v151, v152))
        {
          v242[0].i16[0] = 0;
          _os_log_impl(&dword_1B8270000, v151, v152, "Open index - no recovery path", (uint8_t *)v242, 2u);
        }
        v153 = __error();
        v154 = 0;
        v53 = 0;
        *v153 = v150;
        v224 = 0u;
        v225 = 0u;
        v222 = 0u;
        v223 = 0u;
        v220 = 0u;
        v221 = 0u;
        v23 = v208;
        do
        {
          v52 = 0;
          if (v154)
            v155 = "live.%d.";
          else
            v155 = "%d.";
          if (v154)
            v156 = v21;
          else
            v156 = v23;
          v157 = (int *)v211;
          if (v154)
            v157 = (int *)v210;
          if (((v154 == 0) & (v217 >> 12)) != 0)
          {
            v54 = 0;
          }
          else
          {
            v158 = *v157;
            if (*v157 < 1)
            {
              v54 = 0;
              v23 = v208;
            }
            else
            {
              v206 = v154;
              v159 = 0;
              v160 = a9;
              while (1)
              {
                memset(v242, 0, 104);
                snprintf(v239, 0x400uLL, v155, v159);
                v161 = openIndex(v29, (uint64_t)v239, v237, (uint64_t)v43, (v217 >> 3) & 1, v217, (uint64_t)v242, (uint64_t)&v231, v215, v26[21], v160, a10, a11);
                if (!v161)
                  break;
                v162 = (uint64_t)v161;
                v163 = *__error();
                v164 = _SILogForLogForCategory(10);
                v165 = 2 * (dword_1EF19FCB4 < 4);
                if (os_log_type_enabled(v164, v165))
                {
                  v166 = *(char **)(v162 + 72);
                  v167 = *(_DWORD *)(v162 + 60);
                  v243 = 136315650;
                  v244 = (int64x2_t *)v239;
                  v245 = 2048;
                  v246 = v166;
                  v247 = 1024;
                  LODWORD(v248) = v167;
                  _os_log_impl(&dword_1B8270000, v164, v165, "index %s base:%ld count:%d", (uint8_t *)&v243, 0x1Cu);
                }
                *__error() = v163;
                v168 = *(_QWORD *)(v162 + 16288);
                if (v168 >= *(_QWORD *)(v162 + 16296))
                  v168 = *(_QWORD *)(v162 + 16296);
                if (v168 > *v214)
                  *v214 = v168;
                ContentIndexListAppend(v156, v162);
                v53 += v242[0].i64[0];
                v220 = vaddq_s64(*(int64x2_t *)((char *)&v242[1] + 8), v220);
                v221 = vaddq_s64(*(int64x2_t *)((char *)v242 + 8), v221);
                v223 = vaddq_s64(*(int64x2_t *)((char *)&v242[4] + 8), v223);
                v224 = vaddq_s64(*(int64x2_t *)((char *)&v242[3] + 8), v224);
                v225 = vaddq_s64(*(int64x2_t *)((char *)&v242[2] + 8), v225);
                v222 = vaddq_s64(*(int64x2_t *)((char *)&v242[5] + 8), v222);
                v159 = (v159 + 1);
                v29 = __format;
                v43 = (char *)v212;
                v26 = v228;
                v160 = a9;
                if (v158 == (_DWORD)v159)
                {
                  v52 = 0;
                  v54 = 0;
LABEL_212:
                  v21 = v207;
                  goto LABEL_213;
                }
              }
              v54 = *v215 == 0;
              if (*v215)
              {
                v52 = -1;
                v26 = v228;
                goto LABEL_212;
              }
              v169 = *__error();
              v170 = _SILogForLogForCategory(10);
              v26 = v228;
              v21 = v207;
              if (os_log_type_enabled(v170, OS_LOG_TYPE_DEFAULT))
              {
                v243 = 136315394;
                v244 = (int64x2_t *)v204;
                v245 = 2080;
                v246 = v239;
                _os_log_impl(&dword_1B8270000, v170, OS_LOG_TYPE_DEFAULT, "Could not open %s/%s; needs recovery",
                  (uint8_t *)&v243,
                  0x16u);
              }
              v171 = __error();
              v52 = 0;
              *v171 = v169;
              *v214 = 0;
LABEL_213:
              v23 = v208;
              v154 = v206;
            }
          }
          if (v52 | v154)
            break;
          ++v154;
        }
        while (!v54);
        v31 = (_DWORD *)&unk_1EF19F000;
        v48 = a10;
        goto LABEL_35;
      }
    }
    v69 = v68 + 1;
    while (1)
    {
      snprintf(v239, 0x400uLL, v66, (v69 - 2));
      v70 = v26[21];
      bzero(v242, 0x1000uLL);
      bzero(&v243, 0x400uLL);
      bzero(buf, 0x4040uLL);
      snprintf((char *)&v243, 0x400uLL, "%s%s", v239, "indexHead");
      v71 = (char *)fd_create_protected(v29, (const char *)&v243, 0, 3u);
      v72 = v71;
      if (!v71)
        break;
      v73 = fd_pread(v71, v242, 0x1000uLL, 0);
      if (v73 != 4096)
      {
        if (v73 != -1)
          *__error() = 22;
        break;
      }
      v229[0] = (time_t)v242;
      v74 = indexRestoreFromBuffer((uint64_t)buf, (unsigned int **)v229, v70, v219, v218, &v230, v216);
      fd_release(v72);
      if ((v74 & 1) == 0)
        goto LABEL_76;
      v75 = *__error();
      v76 = _SILogForLogForCategory(10);
      v77 = 2 * (dword_1EF19FCB4 < 4);
      if (os_log_type_enabled(v76, v77))
      {
        v242[0].i32[0] = 136315650;
        *(uint64_t *)((char *)v242[0].i64 + 4) = (uint64_t)v239;
        v242[0].i16[6] = 2048;
        *(uint64_t *)((char *)&v242[0].i64[1] + 6) = v237;
        v242[1].i16[3] = 1024;
        v242[1].i32[2] = v236[9];
        _os_log_impl(&dword_1B8270000, v76, v77, "preflight index %s base:%ld count:%d", (uint8_t *)v242, 0x1Cu);
      }
      *__error() = v75;
      v78 = atomic_load(v236);
      if (v78 - 1 < 2)
      {
        v26 = v228;
      }
      else
      {
        v26 = v228;
        v48 = a10;
        if (v78 != -1073623027)
        {
          if (v78 != -804450864)
          {
            v80 = *__error();
            v88 = _SILogForLogForCategory(10);
            if (os_log_type_enabled(v88, OS_LOG_TYPE_DEFAULT))
            {
              v242[0].i32[0] = 136315394;
              *(uint64_t *)((char *)v242[0].i64 + 4) = v204;
              v242[0].i16[6] = 2080;
              *(uint64_t *)((char *)&v242[0].i64[1] + 6) = (uint64_t)v239;
              _os_log_impl(&dword_1B8270000, v88, OS_LOG_TYPE_DEFAULT, "Unclean shutdown of %s/%s; needs recovery",
                (uint8_t *)v242,
                0x16u);
            }
            v31 = (_DWORD *)&unk_1EF19F000;
            v29 = v29;
            goto LABEL_108;
          }
          v209 = 1;
        }
      }
      if (--v69 <= 1)
        goto LABEL_80;
    }
    fd_release(v72);
LABEL_76:
    v79 = v230;
    v80 = *__error();
    v81 = _SILogForLogForCategory(10);
    v82 = os_log_type_enabled(v81, OS_LOG_TYPE_DEFAULT);
    if (v79)
    {
      if (v82)
      {
        v83 = *__error();
        v242[0].i32[0] = 136315394;
        *(uint64_t *)((char *)v242[0].i64 + 4) = (uint64_t)v239;
        v242[0].i16[6] = 1024;
        *(__int32 *)((char *)&v242[0].i32[3] + 2) = v83;
        _os_log_impl(&dword_1B8270000, v81, OS_LOG_TYPE_DEFAULT, "%s invalid head (%d), will rebuild", (uint8_t *)v242, 0x12u);
      }
      *__error() = v80;
      v26 = v228;
      goto LABEL_80;
    }
    v48 = a10;
    if (v82)
    {
      v91 = *__error();
      v242[0].i32[0] = 136315394;
      *(uint64_t *)((char *)v242[0].i64 + 4) = (uint64_t)v239;
      v242[0].i16[6] = 1024;
      *(__int32 *)((char *)&v242[0].i32[3] + 2) = v91;
      _os_log_impl(&dword_1B8270000, v81, OS_LOG_TYPE_DEFAULT, "%s invalid head (%d), will try to recover", (uint8_t *)v242, 0x12u);
    }
    v31 = (_DWORD *)&unk_1EF19F000;
    v29 = v29;
    v26 = v228;
LABEL_108:
    *__error() = v80;
    v52 = v230;
    if (v230)
    {
      v30 = 4294967294;
      goto LABEL_18;
    }
    v53 = 0;
    v224 = 0u;
    v225 = 0u;
    v54 = 1;
    v222 = 0u;
    v223 = 0u;
    v220 = 0u;
    v221 = 0u;
    v23 = v208;
  }
  else
  {
    v209 = 0;
    v52 = 0;
    v53 = 0;
    v224 = 0u;
    v225 = 0u;
    v54 = 1;
    v222 = 0u;
    v223 = 0u;
    v220 = 0u;
    v221 = 0u;
  }
LABEL_35:
  if (v52 || !v54)
  {
    if (v52 || !(*(_DWORD *)(v23 + 8) | v217 & 0x1000))
      goto LABEL_87;
    if ((v217 & 0x1000) == 0)
      goto LABEL_102;
    v89 = -1;
LABEL_226:
    v43 = (char *)v212;
    if ((v209 & 1) != 0)
      v30 = v89;
    else
      v30 = 0;
LABEL_229:
    if (v203)
    {
      *(_QWORD *)v203 = v53;
      *(int64x2_t *)(v203 + 8) = v221;
      *(int64x2_t *)(v203 + 24) = v220;
      *(int64x2_t *)(v203 + 40) = v225;
      *(int64x2_t *)(v203 + 56) = v224;
      *(int64x2_t *)(v203 + 72) = v223;
      *(int64x2_t *)(v203 + 88) = v222;
      v172 = *__error();
      v173 = _SILogForLogForCategory(10);
      v174 = 2 * (v31[813] < 4);
      if (os_log_type_enabled(v173, v174))
      {
        v175 = *(int *)(v203 + 24) + *(_QWORD *)(v203 + 48);
        v176 = *(int *)(v203 + 32) + *(_QWORD *)(v203 + 56);
        v177 = *(_QWORD *)(v203 + 40) + (int)*(_QWORD *)(v203 + 40);
        v178 = *(_QWORD *)(v203 + 72);
        v179 = *(_QWORD *)(v203 + 80);
        v180 = *(_QWORD *)(v203 + 88);
        v181 = *(_QWORD *)(v203 + 96);
        v242[0].i32[0] = 134219520;
        *(uint64_t *)((char *)v242[0].i64 + 4) = v175;
        v242[0].i16[6] = 2048;
        *(uint64_t *)((char *)&v242[0].i64[1] + 6) = v176;
        v242[1].i16[3] = 2048;
        v242[1].i64[1] = v177;
        v242[2].i16[0] = 1024;
        *(__int32 *)((char *)v242[2].i32 + 2) = v178;
        v242[2].i16[3] = 1024;
        v242[2].i32[2] = v179;
        v242[2].i16[6] = 1024;
        *(__int32 *)((char *)&v242[2].i32[3] + 2) = v180;
        v242[3].i16[1] = 1024;
        v242[3].i32[1] = v181;
        _os_log_impl(&dword_1B8270000, v173, v174, "limbo counts live:%ld scan:%ld recover:%ld internal:%d priority:%d setAttr:%d migrate:%d", (uint8_t *)v242, 0x38u);
      }
      *__error() = v172;
    }
    goto LABEL_18;
  }
  v55 = *__error();
  v56 = _SILogForLogForCategory(10);
  v57 = 2 * (v31[813] < 4);
  if (os_log_type_enabled(v56, v57))
  {
    v242[0].i16[0] = 0;
    _os_log_impl(&dword_1B8270000, v56, v57, "Open index - recovery path", (uint8_t *)v242, 2u);
  }
  *__error() = v55;
  _CIIndexSetRemoveAllValues(v23);
  _CIIndexSetRemoveAllValues(v21);
  if ((v217 & 0x1000) != 0)
  {
    v32 = *__error();
    v59 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
    {
      v242[0].i32[0] = 136315394;
      *(uint64_t *)((char *)v242[0].i64 + 4) = v204;
      v242[0].i16[6] = 2080;
      *(uint64_t *)((char *)&v242[0].i64[1] + 6) = (uint64_t)v239;
      v60 = "recovery not allowed for %s/%s due to locked indexing";
LABEL_98:
      v86 = v59;
      v87 = 22;
      goto LABEL_99;
    }
LABEL_224:
    v42 = __error();
    goto LABEL_17;
  }
  if ((v217 & 4) == 0)
  {
    v58 = (const char *)__si_error_str_key;
    if (__si_error_str_key)
      v58 = (const char *)pthread_getspecific(__si_error_str_key);
    if (!v58)
      v58 = "";
    if (strcmp(v58, "invalid term update set"))
      _si_set_error_str("needs recovery");
    v32 = *__error();
    v59 = _SILogForLogForCategory(10);
    if (!os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
      goto LABEL_224;
    v242[0].i32[0] = 136315394;
    *(uint64_t *)((char *)v242[0].i64 + 4) = v204;
    v242[0].i16[6] = 2080;
    *(uint64_t *)((char *)&v242[0].i64[1] + 6) = (uint64_t)v239;
    v60 = "recovery not allowed for %s/%s";
    goto LABEL_98;
  }
  v92 = 0;
  v53 = 0;
  v93 = v26 + 13;
  v94 = v26 + 12;
  v224 = 0uLL;
  v225 = 0uLL;
  v222 = 0uLL;
  v223 = 0uLL;
  v220 = 0uLL;
  v221 = 0uLL;
  v95 = 1;
  v205 = v26 + 13;
  v198 = v26 + 12;
  while (1)
  {
    v96 = v95;
    v97 = (v95 & 1) == 0;
    if ((v95 & 1) != 0)
      v98 = "%d.";
    else
      v98 = "live.%d.";
    __formata = v98;
    v99 = v207;
    if (!v97)
      v99 = v23;
    v213 = v99;
    v100 = v97 ? v93 : v94;
    v101 = *v100;
    if (*v100)
      break;
LABEL_183:
    v95 = 0;
    if ((v96 & 1) == 0)
    {
      if (!*(_DWORD *)(v23 + 8))
        goto LABEL_87;
      if (v92)
      {
        *((_QWORD *)v228 + 5) = *((_QWORD *)v228 + 6);
        goto LABEL_262;
      }
LABEL_102:
      v89 = 3;
      goto LABEL_226;
    }
  }
  v200 = v92;
  v201 = v96;
  v102 = 0;
  v199 = v92 + v101;
  while (1)
  {
    memset(v229, 0, sizeof(v229));
    snprintf(v239, 0x400uLL, __formata, v102);
    if ((v217 & 8) == 0)
    {
      if ((recoverIndex(v29) & 1) != 0)
      {
        v109 = openIndex(v29, (uint64_t)v239, v237, v212, 0, v217, (uint64_t)v229, (uint64_t)&v231, v215, v26[21], a9, v48, a11);
        v122 = *__error();
        v123 = _SILogForLogForCategory(10);
        v124 = os_log_type_enabled(v123, OS_LOG_TYPE_DEFAULT);
        if (v109)
        {
          if (v124)
            goto LABEL_176;
          goto LABEL_177;
        }
        v183 = v200 + v102;
        if (v124)
        {
          v242[0].i32[0] = 136315394;
          *(uint64_t *)((char *)v242[0].i64 + 4) = v204;
          v242[0].i16[6] = 2080;
          *(uint64_t *)((char *)&v242[0].i64[1] + 6) = (uint64_t)v239;
          _os_log_impl(&dword_1B8270000, v123, OS_LOG_TYPE_DEFAULT, "could not open %s/%s", (uint8_t *)v242, 0x16u);
        }
        v185 = "open recovered index error";
      }
      else
      {
        v183 = v200 + v102;
        v122 = *__error();
        v184 = _SILogForLogForCategory(10);
        if (os_log_type_enabled(v184, OS_LOG_TYPE_DEFAULT))
        {
          v242[0].i32[0] = 136315394;
          *(uint64_t *)((char *)v242[0].i64 + 4) = v204;
          v242[0].i16[6] = 2080;
          *(uint64_t *)((char *)&v242[0].i64[1] + 6) = (uint64_t)v239;
          _os_log_impl(&dword_1B8270000, v184, OS_LOG_TYPE_DEFAULT, "could not recover %s/%s", (uint8_t *)v242, 0x16u);
        }
        v185 = "recover index error";
      }
      v31 = (_DWORD *)&unk_1EF19F000;
      *__error() = v122;
      _si_set_error_str(v185);
      if ((v201 & 1) == 0)
        goto LABEL_247;
      goto LABEL_246;
    }
    v103 = v237;
    v104 = v26[21];
    bzero(&v243, 0x400uLL);
    bzero(v242, 0x1000uLL);
    v231 = -1;
    v105 = *__error();
    v106 = _SILogForLogForCategory(10);
    v107 = 2 * (dword_1EF19FCB4 < 4);
    if (os_log_type_enabled(v106, v107))
    {
      *(_DWORD *)v241 = 136315138;
      *(_QWORD *)&v241[4] = v239;
      _os_log_impl(&dword_1B8270000, v106, v107, "open index at %s", v241, 0xCu);
    }
    *__error() = v105;
    v108 = (char *)malloc_type_calloc(1uLL, 0x4040uLL, 0x10F0040CEEE6884uLL);
    v109 = v108;
    if (!v108)
      break;
    v110 = (BOOL *)(v108 + 15162);
    initIndex((uint64_t)v108, a11);
    __strlcpy_chk();
    *((_QWORD *)v109 + 9) = v103;
    *((_DWORD *)v109 + 20) = 1611;
    *((_DWORD *)v109 + 14) = v29;
    *v110 = (v217 & 0x10) != 0;
    snprintf((char *)&v243, 0x400uLL, "%s%s", v239, "shadowIndexHead");
    v111 = open_index_file(v29, (const char *)&v243, 0, 4096, 4096, 0, 0, 0, &v231);
    *((_QWORD *)v109 + 1805) = v111;
    v26 = v228;
    if (v111)
    {
      v112 = fd_pread(v111, v242, 0x1000uLL, 0);
      v23 = v208;
      if (v112 != 4096)
      {
        if (v112 != -1)
          goto LABEL_234;
        v113 = *__error();
        if (v113)
        {
          v182 = v201;
          v183 = v200 + v102;
          goto LABEL_235;
        }
      }
      *(_QWORD *)v241 = v242;
      if (indexRestoreFromBuffer((uint64_t)v109, (unsigned int **)v241, v104, v219, v218, 0, v216))
      {
        v109[15163] = 1;
        v114 = atomic_load((unsigned int *)v109 + 7);
        v115 = atomic_load((unsigned int *)v109 + 7);
        v116 = atomic_load((unsigned int *)v109 + 6);
        if (v116 == -804450864 || (v117 = atomic_load((unsigned int *)v109 + 6), v117 == -1073623027))
        {
          snprintf((char *)&v243, 0x400uLL, "%s%s", v239, "indexIds");
          v118 = *((unsigned int *)v109 + 15);
          v119 = *((unsigned int *)v109 + 16);
          v120 = 8 * v118;
          v121 = v118 >= 2 ? 8 * v118 : 0;
          if (v118 <= v119)
            v120 = 8 * v119;
          else
            *((_DWORD *)v109 + 16) = v118;
          v125 = open_index_file(v29, (const char *)&v243, 0, v120, v121, 0, (uint64_t *)v109 + 1796, 1, &v231);
          *((_QWORD *)v109 + 1801) = v125;
          if (v125)
          {
            snprintf((char *)&v243, 0x400uLL, "%s%s", v239, "indexBigDates");
            v126 = *((unsigned int *)v109 + 15);
            if (v126 >= 2)
              v127 = 4 * v126;
            else
              v127 = 0;
            *((_QWORD *)v109 + 1802) = open_index_file(v29, (const char *)&v243, 0, 4 * *((unsigned int *)v109 + 16), v127, 0, (uint64_t *)v109 + 1797, 1, &v231);
            if ((v217 & 0x100) != 0)
            {
              snprintf((char *)&v243, 0x400uLL, "%s%s", v239, "indexScores");
              v128 = *((unsigned int *)v109 + 15);
              if (v128 >= 2)
                v129 = 8 * v128;
              else
                v129 = 0;
              *((_QWORD *)v109 + 1803) = open_index_file(v29, (const char *)&v243, 0, 8 * *((unsigned int *)v109 + 16), v129, 0, (uint64_t *)v109 + 1798, 1, &v231);
            }
            snprintf((char *)&v243, 0x400uLL, "%s%s", v239, "shadowIndexGroups");
            v130 = *((_DWORD *)v109 + 16);
            if (v109[37])
            {
              v131 = *((_DWORD *)v109 + 15);
            }
            else
            {
              v130 = (4 * v130 + 4) / 5;
              v131 = (4 * *((_DWORD *)v109 + 15) + 4) / 5u;
            }
            v132 = open_index_file(v29, (const char *)&v243, 0, v130, v131, 0, (uint64_t *)v109 + 1799, 1, &v231);
            *((_QWORD *)v109 + 1804) = v132;
            if (v132)
            {
              v133 = (v115 & 2) != 0 ? "indexTermIds" : "shadowIndexTermIds";
              if (openPayload((uint64_t)(v109 + 4920), *((_DWORD *)v109 + 14), v239, "indexPostings", v133, (char *)&v243, 1, (v114 & 4) != 0, 1u, *((_DWORD *)v109 + 1), *((void **)v109 + 614)))
              {
                v134 = (v115 & 2) != 0 ? "indexPositionTable" : "shadowIndexPositionTable";
                if (openPayload((uint64_t)(v109 + 9632), *((_DWORD *)v109 + 14), v239, "indexPositions", v134, (char *)&v243, 1, (v114 & 4) != 0, 1u, *((_DWORD *)v109 + 1), *((void **)v109 + 614)))
                {
                  if (bt_openTrie((uint64_t)(v109 + 88), *((_DWORD *)v109 + 14), v239, (v114 >> 2) & 1, 1, (v115 & 2) == 0, *((_DWORD *)v109 + 1), *((void **)v109 + 614)))
                  {
                    if ((v217 & 0x40) == 0
                      || (v135 = openForwardStore(v29, v239, 0, 1, 1, *((void **)v109 + 614)),
                          (*((_QWORD *)v109 + 613) = v135) != 0))
                    {
                      if (_os_feature_enabled_impl())
                      {
                        v136 = *__error();
                        v137 = _SILogForLogForCategory(10);
                        if (os_log_type_enabled(v137, OS_LOG_TYPE_DEFAULT))
                        {
                          v138 = *((_DWORD *)v109 + 12);
                          v240[0] = 67109120;
                          v240[1] = v138;
                          _os_log_impl(&dword_1B8270000, v137, OS_LOG_TYPE_DEFAULT, "open vector index shadow for indexid %d", (uint8_t *)v240, 8u);
                        }
                        *__error() = v136;
                        v139 = *((_DWORD *)v109 + 12);
                        if (v139)
                        {
                          *((_QWORD *)v109 + 612) = openVectorIndex(v29, v239, 1, a9, v139);
                          *((_QWORD *)v109 + 1793) = a9;
                        }
                      }
                      v109[15164] = 1;
                      v109[8] = 1;
                      v231 = 0;
                    }
                  }
                }
              }
            }
          }
        }
      }
      v26 = v228;
    }
    v23 = v208;
    if (v231)
    {
      v182 = v201;
      v183 = v200 + v102;
      goto LABEL_245;
    }
    v122 = *__error();
    v123 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v123, OS_LOG_TYPE_DEFAULT))
    {
LABEL_176:
      v140 = *((_QWORD *)v109 + 9);
      v141 = *((_DWORD *)v109 + 15);
      v242[0].i32[0] = 136315650;
      *(uint64_t *)((char *)v242[0].i64 + 4) = (uint64_t)v239;
      v242[0].i16[6] = 2048;
      *(uint64_t *)((char *)&v242[0].i64[1] + 6) = v140;
      v242[1].i16[3] = 1024;
      v242[1].i32[2] = v141;
      _os_log_impl(&dword_1B8270000, v123, OS_LOG_TYPE_DEFAULT, "index %s base:%ld count:%d", (uint8_t *)v242, 0x1Cu);
    }
LABEL_177:
    *__error() = v122;
    ContentIndexListAppend(v213, (uint64_t)v109);
    v142 = v229[0];
    v143 = *(int64x2_t *)&v229[1];
    v144 = *(int64x2_t *)&v229[3];
    v145 = *(int64x2_t *)&v229[5];
    v146 = *(int64x2_t *)&v229[7];
    v147 = *(int64x2_t *)&v229[9];
    v148 = *(int64x2_t *)&v229[11];
    v149 = *((_QWORD *)v109 + 2036);
    if (v149 >= *((_QWORD *)v109 + 2037))
      v149 = *((_QWORD *)v109 + 2037);
    if (v149 > *v214)
      *v214 = v149;
    v53 += v142;
    v220 = vaddq_s64(v144, v220);
    v221 = vaddq_s64(v143, v221);
    v222 = vaddq_s64(v148, v222);
    v223 = vaddq_s64(v147, v223);
    v224 = vaddq_s64(v146, v224);
    v225 = vaddq_s64(v145, v225);
    v102 = (v102 + 1);
    v48 = a10;
    if (v101 == (_DWORD)v102)
    {
      v92 = v199;
      v31 = (_DWORD *)&unk_1EF19F000;
      v93 = v205;
      v96 = v201;
      v94 = v198;
      goto LABEL_183;
    }
  }
  v23 = v208;
LABEL_234:
  v182 = v201;
  v183 = v200 + v102;
  v113 = -1;
LABEL_235:
  v231 = v113;
LABEL_245:
  v31 = &unk_1EF19F000;
  freeIndex((uint64_t)v109);
  _si_set_error_str("open index shadow error");
  if ((v182 & 1) == 0)
    goto LABEL_247;
LABEL_246:
  if (*(_DWORD *)(v23 + 8) != v101)
    goto LABEL_87;
LABEL_247:
  v186 = *(_DWORD *)(v207 + 8);
  if (!v186)
  {
    v186 = *(_DWORD *)(v23 + 8);
    if (!v186 || !v183 || *v215)
      goto LABEL_87;
LABEL_254:
    v187 = *(_QWORD *)(*(_QWORD *)v23 + 8 * (v186 - 1));
    *v202 = (char *)(*(_QWORD *)(v187 + 72) + *(unsigned int *)(v187 + 60));
    v229[0] = *v214;
    memset(v242, 0, 256);
    v188 = localtime(v229);
    strftime(v242[0].i8, 0x100uLL, "%F %T", v188);
    v189 = *__error();
    v190 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v190, OS_LOG_TYPE_DEFAULT))
    {
      v191 = *v202;
      v243 = 136315650;
      v244 = v242;
      v245 = 2048;
      v246 = v191;
      v247 = 2080;
      v248 = v187 + 15168;
      _os_log_impl(&dword_1B8270000, v190, OS_LOG_TYPE_DEFAULT, "recover needed, scan date: %s, last valid doc id:%ld, %s", (uint8_t *)&v243, 0x20u);
    }
    *__error() = v189;
    v192 = *(_DWORD *)(v207 + 8);
    if (v192 < *v205)
    {
      do
      {
        v193 = v29;
        v194 = *__error();
        v195 = _SILogForLogForCategory(10);
        v196 = 2 * (v31[813] < 4);
        if (os_log_type_enabled(v195, v196))
        {
          v242[0].i32[0] = 136315394;
          *(uint64_t *)((char *)v242[0].i64 + 4) = v204;
          v242[0].i16[6] = 2080;
          *(uint64_t *)((char *)&v242[0].i64[1] + 6) = (uint64_t)v239;
          _os_log_impl(&dword_1B8270000, v195, v196, "deleting index %s/%s", (uint8_t *)v242, 0x16u);
        }
        *__error() = v194;
        snprintf(v239, 0x400uLL, "live.%d.", v192);
        v29 = v193;
        index_DeleteIndex(0, v193, v239, 1);
        ++v192;
        v31 = (_DWORD *)&unk_1EF19F000;
      }
      while (v192 < *v205);
      v192 = *(_DWORD *)(v207 + 8);
    }
    v197 = *(_DWORD *)(v208 + 8);
    v228[12] = v197;
    v228[13] = v192;
    v228[10] = v197;
    v228[11] = v192;
LABEL_262:
    v30 = 2;
    v43 = (char *)v212;
    goto LABEL_229;
  }
  if (v183 && !*v215)
  {
    v23 = v207;
    goto LABEL_254;
  }
LABEL_87:
  _CIIndexSetRemoveAllValues(v23);
  _CIIndexSetRemoveAllValues(v207);
  if (*v215)
    _si_set_error_str("open canceled");
  v30 = 0xFFFFFFFFLL;
LABEL_90:
  v43 = (char *)v212;
LABEL_18:
  free(v43);
  if (g_fd_list)
    _fd_close_inactive(v29, 0, 0, v29 == -1);
  v44 = *__error();
  v45 = _SILogForLogForCategory(10);
  v46 = 2 * (v31[813] < 4);
  if (os_log_type_enabled(v45, v46))
  {
    *(_DWORD *)buf = 67109120;
    LODWORD(v233) = v30;
    _os_log_impl(&dword_1B8270000, v45, v46, "Open index bulk: %d", buf, 8u);
  }
  *__error() = v44;
  return v30;
}

uint64_t ContentIndexCloseIndexBulk_Step1(uint64_t result, uint64_t a2, uint64_t a3, __int128 *a4, uint64_t a5)
{
  uint64_t v8;
  unint64_t v9;
  unint64_t v11;
  uint64_t v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;

  v8 = result;
  v16 = a4[2];
  v17 = a4[3];
  v18 = *((_QWORD *)a4 + 8);
  v14 = *a4;
  v15 = a4[1];
  if (a2 && *(_DWORD *)(a2 + 8))
  {
    v9 = 0;
    do
    {
      result = *(_QWORD *)(*(_QWORD *)a2 + 8 * v9);
      if (!atomic_load((unsigned int *)(result + 15152)))
        result = indexClosing(result);
      ++v9;
    }
    while (v9 < *(unsigned int *)(a2 + 8));
  }
  if (a3 && *(_DWORD *)(a3 + 8))
  {
    v11 = 0;
    do
    {
      result = *(_QWORD *)(*(_QWORD *)a3 + 8 * v11);
      if (!atomic_load((unsigned int *)(result + 15152)))
        result = indexClosing(result);
      ++v11;
    }
    while (v11 < *(unsigned int *)(a3 + 8));
  }
  if (v8)
  {
    if (*(_BYTE *)(v8 + 88))
      return result;
    v21 = v16;
    v22 = v17;
    v23 = v18;
    v19 = v14;
    v20 = v15;
    v13 = v8;
  }
  else
  {
    v21 = v16;
    v22 = v17;
    v23 = v18;
    v19 = v14;
    v20 = v15;
    v13 = 0;
  }
  return _ContentIndexSyncIndexBulk(v13, a2, a3, 2, (uint64_t)&v19, a5, 0, 0);
}

int *ContentIndexUpdateTimeStamp(int *result, uint64_t a2, int a3, int a4)
{
  char v4;
  int *v6;
  int v8;
  NSObject *v9;
  os_log_type_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  __int16 v14;
  uint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v4 = atomic_load((unsigned int *)result + 7);
  if ((v4 & 3) == 0 && !*((_BYTE *)result + 15163))
  {
    v6 = &result[2 * a3 + 4072];
    if (*(_QWORD *)v6 >= a2)
    {
      if (*(_QWORD *)v6 > a2 && a4 != 0)
      {
        v8 = *__error();
        v9 = _SILogForLogForCategory(0);
        v10 = gSILogLevels[0] < 3;
        if (os_log_type_enabled(v9, (os_log_type_t)(gSILogLevels[0] < 3)))
        {
          v11 = *(_QWORD *)v6;
          v12 = 134218240;
          v13 = a2;
          v14 = 2048;
          v15 = v11;
          _os_log_impl(&dword_1B8270000, v9, v10, "*warn* time stamp should be more recent new:%ld, old:%ld", (uint8_t *)&v12, 0x16u);
        }
        result = __error();
        *result = v8;
      }
    }
    else
    {
      *(_QWORD *)v6 = a2;
    }
  }
  return result;
}

_DWORD *ContentIndexMergeComplete(_DWORD *result)
{
  _DWORD *v1;

  if (*((_QWORD *)result + 612))
  {
    v1 = result;
    result = (_DWORD *)_os_feature_enabled_impl();
    if ((_DWORD)result)
      return IVFVectorIndex_s::endMerge((IVFVectorIndex_s *)(*((_QWORD *)v1 + 612) + 8));
  }
  return result;
}

uint64_t ContentIndexResetVectorIndex(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  BOOL v5;
  IVFVectorIndex_s *v6;
  int v7;
  uint64_t v8;
  int v9;
  _DWORD *v10;
  _BYTE v12[1024];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v2 = a1 + 14680;
  _db_write_lock(a1 + 14680);
  v3 = *(_QWORD *)(a1 + 4896);
  if (v3)
  {
    IVFVectorIndex_s::~IVFVectorIndex_s((void **)(v3 + 8));
    MEMORY[0x1BCCB06A4](v3, 0x1032C4065068D8BLL);
    *(_QWORD *)(a1 + 4896) = 0;
  }
  bzero(v12, 0x400uLL);
  v4 = fcntl(*(_DWORD *)(a1 + 56), 50, v12);
  if (v12[0])
    v5 = v4 < 0;
  else
    v5 = 1;
  if (v5)
    v6 = 0;
  else
    v6 = (IVFVectorIndex_s *)v12;
  IVFVectorIndex_s::unlink(v6, (const char *)(a1 + 15168), 0);
  if (!*(_BYTE *)(a1 + 15163))
  {
    v7 = *(_DWORD *)(a1 + 56);
    v8 = *(_QWORD *)(a1 + 14344);
    v9 = *(_DWORD *)(a1 + 48);
    v10 = (_DWORD *)operator new();
    *v10 = v7;
    IVFVectorIndex_s::IVFVectorIndex_s((uint64_t)(v10 + 2), v7, (const char *)(a1 + 15168), v8, v9);
    *(_QWORD *)(a1 + 4896) = v10;
  }
  return db_write_unlock(v2);
}

int *ContentIndexUpdatePath(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5, uint64_t a6)
{
  uint64_t v11;
  uint64_t v13;
  pthread_mutex_t *v14;
  unsigned int v15;
  unint64_t v16;
  signed int v17;
  char *v18;
  char *v19;
  pthread_override_s *v20;
  char v21;
  unsigned int v22;
  unint64_t v23;
  signed int v24;
  pthread_override_s *v25;
  char v26;
  int *result;
  int v28;
  NSObject *v29;
  uint64_t v30;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t *v34;
  uint64_t v35;
  int v36;
  const char *v37;
  __int16 v38;
  int v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  v11 = *(_QWORD *)(a1 + 14352);
  if (v11)
    goto LABEL_17;
  v13 = a1 + 14856;
  v14 = (pthread_mutex_t *)(a1 + 14680);
  HIDWORD(v16) = qos_class_self() - 9;
  LODWORD(v16) = HIDWORD(v16);
  v15 = v16 >> 2;
  if (v15 > 6)
    v17 = 0;
  else
    v17 = dword_1B8630ED0[v15];
  pthread_mutex_lock(v14);
  if (*(_QWORD *)(a1 + 14864) || *(_DWORD *)(a1 + 14876) || *(_BYTE *)(v13 + 36))
    goto LABEL_8;
  if (v17 <= 5)
  {
    if (*(_QWORD *)(a1 + 16 * v17 + 14744))
    {
LABEL_8:
      db_rwlock_wait((uint64_t)v14, v17, 2);
      goto LABEL_9;
    }
    v33 = v17 - 1;
    v34 = (uint64_t *)(a1 + 16 * v17 + 14760);
    while (v33 != 4)
    {
      v35 = *v34;
      v34 += 2;
      ++v33;
      if (v35)
      {
        if (v33 <= 4)
          goto LABEL_8;
        break;
      }
    }
  }
  *(_QWORD *)(a1 + 14864) = pthread_self();
LABEL_9:
  pthread_mutex_unlock(v14);
  if (*(_QWORD *)(a1 + 14352))
  {
LABEL_14:
    pthread_mutex_lock(v14);
    *(_DWORD *)(a1 + 14884) = 0;
    v20 = *(pthread_override_s **)(a1 + 14856);
    *(_QWORD *)v13 = 0;
    *(_QWORD *)(v13 + 8) = 0;
    v21 = *(_DWORD *)(a1 + 14876) != 0;
    *(_BYTE *)(v13 + 36) = 0;
    db_rwlock_wakeup((uint64_t)v14, v21, 0);
    pthread_mutex_unlock(v14);
    if (v20)
      pthread_override_qos_class_end_np(v20);
    v11 = *(_QWORD *)(a1 + 14352);
LABEL_17:
    HIDWORD(v23) = qos_class_self() - 9;
    LODWORD(v23) = HIDWORD(v23);
    v22 = v23 >> 2;
    if (v22 > 6)
      v24 = 0;
    else
      v24 = dword_1B8630ED0[v22];
    pthread_mutex_lock((pthread_mutex_t *)(v11 + 304));
    if (*(_QWORD *)(v11 + 488) || *(_DWORD *)(v11 + 500) || *(_BYTE *)(v11 + 516))
      goto LABEL_23;
    if (v24 <= 5)
    {
      if (*(_QWORD *)(v11 + 16 * v24 + 368))
      {
LABEL_23:
        db_rwlock_wait(v11 + 304, v24, 2);
LABEL_24:
        pthread_mutex_unlock((pthread_mutex_t *)(v11 + 304));
        ++*(_DWORD *)(v11 + 112);
        if (a3)
          doChildFile(v11 + 88, (_QWORD *)(v11 + 48), a3, a4, a2, 1);
        if (a5)
          doChildFile(v11 + 88, (_QWORD *)(v11 + 48), a5, a6, a2, 2);
        pthread_mutex_lock((pthread_mutex_t *)(v11 + 304));
        *(_DWORD *)(v11 + 508) = 0;
        v25 = *(pthread_override_s **)(v11 + 480);
        *(_QWORD *)(v11 + 480) = 0;
        *(_QWORD *)(v11 + 488) = 0;
        v26 = *(_DWORD *)(v11 + 500) != 0;
        *(_BYTE *)(v11 + 516) = 0;
        db_rwlock_wakeup(v11 + 304, v26, 0);
        result = (int *)pthread_mutex_unlock((pthread_mutex_t *)(v11 + 304));
        if (v25)
          return (int *)pthread_override_qos_class_end_np(v25);
        return result;
      }
      v30 = v24 - 1;
      v31 = (uint64_t *)(v11 + 16 * v24 + 384);
      while (v30 != 4)
      {
        v32 = *v31;
        v31 += 2;
        ++v30;
        if (v32)
        {
          if (v30 <= 4)
            goto LABEL_23;
          break;
        }
      }
    }
    *(_QWORD *)(v11 + 488) = pthread_self();
    goto LABEL_24;
  }
  v18 = TermUpdateSetCreate((uint64_t (*)())_indexProgress, a1, *(_QWORD *)(a1 + 72), *(_DWORD *)(a1 + 60), 32 * *(unsigned __int8 *)(a1 + 38), *(_QWORD *)(a1 + 14344), *(_DWORD *)(a1 + 48), *(const void **)(a1 + 4912));
  if (v18)
  {
    v19 = v18;
    if (*(_BYTE *)(v13 + 306))
      *((_QWORD *)v18 + 76) = getPropertyStringCallback;
    *((_QWORD *)v18 + 35) = a1 + 14144;
    OSMemoryBarrier();
    *(_QWORD *)(a1 + 14352) = v19;
    goto LABEL_14;
  }
  v28 = *__error();
  v29 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
  {
    v36 = 136315394;
    v37 = "_CIUpdatePath";
    v38 = 1024;
    v39 = 4240;
    _os_log_error_impl(&dword_1B8270000, v29, OS_LOG_TYPE_ERROR, "%s:%d: TermUpdateSetCreate failed", (uint8_t *)&v36, 0x12u);
  }
  result = __error();
  *result = v28;
  return result;
}

void ContentIndexResetDirStore(uint64_t a1)
{
  _BYTE *v2;
  void *v3;
  _DWORD *v4;
  unsigned int *v5;
  unsigned int v6;
  const void *v7;
  int v8;
  NSObject *v9;
  os_log_type_t v10;
  uint8_t v11[16];

  indexMarkDirty(a1);
  v2 = *(_BYTE **)(a1 + 4904);
  if (v2)
  {
    v3 = _Block_copy(*((const void **)v2 + 32));
    v4 = (_DWORD *)*((_QWORD *)v2 + 28);
    if (v4)
    {
      v5 = v4 + 8;
      do
        v6 = __ldxr(v5);
      while (__stxr(v6 + 1, v5));
    }
    fd_zero_truncate((uint64_t)v4);
    storageClose((uint64_t)(v2 + 8));
    v7 = (const void *)*((_QWORD *)v2 + 549);
    if (v7)
      CFRelease(v7);
    bzero(v2, 0x1160uLL);
    if (dirStoreInit((uint64_t)v2, v4, 1, 0, v3))
    {
      v8 = *__error();
      v9 = _SILogForLogForCategory(0);
      v10 = 2 * (gSILogLevels[0] < 4);
      if (os_log_type_enabled(v9, v10))
      {
        *(_WORD *)v11 = 0;
        _os_log_impl(&dword_1B8270000, v9, v10, "forwardStoreReset", v11, 2u);
      }
      *__error() = v8;
      *((_OWORD *)v2 + 276) = xmmword_1B8631D00;
      flushForwardStore(v2, 0);
      *v2 = 1;
      _Block_release(v3);
    }
    else
    {
      _Block_release(v3);
      freeForwardDirectoryStore(v2);
      *(_QWORD *)(a1 + 4904) = 0;
    }
  }
}

uint64_t ContentIndexMergeIndexes(uint64_t **a1, signed int a2, const char *a3, uint64_t *a4, __int128 *a5)
{
  int v8;
  uint64_t v9;
  signed int v10;
  unsigned int v11;
  unsigned int v12;
  signed int v13;
  uint64_t v14;
  uint64_t **v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t *v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  char *v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v24 = *a5;
  v25 = a5[1];
  v26 = a5[2];
  v27 = a5[3];
  if (a2 < 9)
  {
    v16 = a5[1];
    v33 = *a5;
    v34 = v16;
    v17 = a5[3];
    v35 = a5[2];
    v36 = v17;
    return _ContentIndexMergeIndexes(a1, a2, (uint64_t)a3, a4, &v33);
  }
  else
  {
    v35 = 0u;
    v36 = 0u;
    v33 = 0u;
    v34 = 0u;
    if (a2 < 1)
    {
      LODWORD(v9) = 0;
    }
    else
    {
      v23 = a4;
      v8 = 0;
      v9 = 0;
      v10 = 0;
      v11 = (a2 + 7) >> 3;
      v12 = v11;
      do
      {
        if (a2 >= v12)
          v13 = v12;
        else
          v13 = a2;
        v14 = (v13 + v8);
        v32 = 0;
        asprintf(&v32, "%s_%d.", a3, v9);
        v15 = &a1[v10];
        v10 += v11;
        v28 = v24;
        v29 = v25;
        v30 = v26;
        v31 = v27;
        *((_QWORD *)&v33 + v9) = ContentIndexMergeIndexes(v15, v14, v32, 0, &v28);
        free(v32);
        ++v9;
        v12 += v11;
        v8 -= v11;
      }
      while (v10 < a2);
      a4 = v23;
    }
    v28 = v24;
    v29 = v25;
    v30 = v26;
    v31 = v27;
    v18 = _ContentIndexMergeIndexes((uint64_t **)&v33, v9, (uint64_t)a3, a4, &v28);
    if ((_DWORD)v9)
    {
      v19 = v9;
      v20 = (uint64_t *)&v33;
      do
      {
        v21 = *v20++;
        _CIDeleteIndex(v21, 1);
        --v19;
      }
      while (v19);
    }
  }
  return v18;
}

uint64_t ContentIndexChangePrefix(uint64_t a1)
{
  uint64_t v1;
  const char *v2;
  const char *v3;
  uint64_t v4;
  const char *v5;
  uint64_t result;
  int v7;
  NSObject *v8;
  int v9;
  int v10;
  char v11;
  uint64_t v12;
  uint64_t v13;
  std::error_code *v14;
  std::error_code *v15;
  uint64_t v16;
  char *v17;
  const char *v18;
  char *sibling_protected;
  uint64_t v20;
  int v21;
  NSObject *v22;
  _QWORD *v23;
  _QWORD *v24;
  IVFVectorIndex_s **v25;
  IVFVectorIndex_s *v26;
  IVFVectorIndex_s *v27;
  _QWORD *v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  size_t v38;
  std::string::size_type v39;
  std::string *p_dst;
  uint64_t v41;
  uint64_t v42;
  std::string *v43;
  std::string::size_type size;
  std::string *v45;
  std::string::size_type v46;
  std::string *v47;
  _QWORD *v48;
  _QWORD *v49;
  BOOL v50;
  const char **v51;
  const char *v52;
  size_t v53;
  std::string::size_type v54;
  uint64_t v55;
  std::string *v56;
  uint64_t v57;
  uint64_t v58;
  const char *v59;
  std::string *v60;
  std::string *v61;
  std::error_code *v62;
  std::error_code *v63;
  char v64;
  char v65;
  std::error_code *v66;
  std::error_code *v67;
  char *v68;
  char *v69;
  const char *v70;
  int v71;
  uint64_t v72;
  char *v73;
  char *v74;
  const char *v75;
  char *v76;
  char *v77;
  const char *v78;
  const std::__fs::filesystem::path *v79;
  unsigned int v80;
  uint64_t v81;
  const char *v82;
  unsigned int *v83;
  const char *__src;
  std::string __dst;
  std::__fs::filesystem::path __str[42];
  std::__fs::filesystem::path __from;
  std::string __p[42];
  stat buf[7];
  uint64_t v90;

  v1 = MEMORY[0x1E0C80A78](a1);
  v3 = v2;
  v4 = v1;
  v90 = *MEMORY[0x1E0C80C00];
  v5 = (const char *)(v1 + 15168);
  result = strcmp((const char *)(v1 + 15168), v2);
  if ((_DWORD)result)
  {
    if (*(unsigned __int8 *)v5 - 48 <= 9 && *v3 == 108)
    {
      v68 = __si_assert_copy_extra_2151(0, *(_DWORD *)(v4 + 56));
      v69 = v68;
      v70 = "";
      if (v68)
        v70 = v68;
      __message_assert("%s:%u: failed assertion '%s' %s invalid rename %s %s", "JHContentIndex.c", 6203, "newPrefix[0]!='l'", v70, v5, v3);
      free(v69);
      v71 = *(_DWORD *)(v4 + 56);
      goto LABEL_117;
    }
    v7 = *__error();
    v8 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      v9 = *(_DWORD *)(v4 + 56);
      v10 = *(_DWORD *)(v4 + 48);
      buf[0].st_dev = 67109890;
      *(_DWORD *)&buf[0].st_mode = v9;
      LOWORD(buf[0].st_ino) = 1024;
      *(_DWORD *)((char *)&buf[0].st_ino + 2) = v10;
      HIWORD(buf[0].st_ino) = 2080;
      *(_QWORD *)&buf[0].st_uid = v5;
      LOWORD(buf[0].st_rdev) = 2080;
      *(_QWORD *)((char *)&buf[0].st_rdev + 2) = v3;
      _os_log_impl(&dword_1B8270000, v8, OS_LOG_TYPE_DEFAULT, "### change index prefix [%d] %d %s to %s", (uint8_t *)buf, 0x22u);
    }
    *__error() = v7;
    v11 = atomic_load((unsigned int *)(v4 + 28));
    bt_changePrefix(v4 + 88, v5, v3, (v11 & 2) == 0);
    v12 = *(unsigned int *)(v4 + 56);
    memset(buf, 0, 144);
    result = fstat(v12, buf);
    if (!(_DWORD)result)
    {
      v13 = open(".", 4);
      result = MEMORY[0x1BCCB1484](v12);
      if ((_DWORD)result)
      {
LABEL_111:
        if ((v13 & 0x80000000) == 0)
          return close(v13);
        return result;
      }
      bzero(&__from, 0x400uLL);
      bzero(__str, 0x400uLL);
      snprintf((char *)__str, 0x400uLL, "%s%s", v3, "indexHead");
      fd_rename(*(_QWORD *)(v4 + 14440), (const char *)__str);
      snprintf((char *)&__from, 0x400uLL, "%s%s", v5, "shadowIndexHead");
      snprintf((char *)__str, 0x400uLL, "%s%s", v3, "shadowIndexHead");
      rename(&__from, __str, v14);
      snprintf((char *)&__from, 0x400uLL, "%s%s", v5, "indexId");
      snprintf((char *)__str, 0x400uLL, "%s%s", v3, "indexId");
      rename(&__from, __str, v15);
      if (*(_QWORD *)(v4 + 14408))
      {
        snprintf((char *)__str, 0x400uLL, "%s%s", v3, "indexIds");
        fd_rename(*(_QWORD *)(v4 + 14408), (const char *)__str);
      }
      if (*(_QWORD *)(v4 + 14416))
      {
        snprintf((char *)__str, 0x400uLL, "%s%s", v3, "indexBigDates");
        fd_rename(*(_QWORD *)(v4 + 14416), (const char *)__str);
        snprintf((char *)&__from, 0x400uLL, "%s%s", v5, "indexDates");
        unlink((const char *)&__from);
      }
      if (*(_QWORD *)(v4 + 14424))
      {
        snprintf((char *)__str, 0x400uLL, "%s%s", v3, "indexScores");
        fd_rename(*(_QWORD *)(v4 + 14424), (const char *)__str);
      }
      if (*(_QWORD *)(v4 + 14432))
      {
        snprintf((char *)__str, 0x400uLL, "%s%s", v3, "indexGroups");
        fd_rename(*(_QWORD *)(v4 + 14432), (const char *)__str);
      }
      if (*(_QWORD *)(v4 + 14448))
      {
        snprintf((char *)__str, 0x400uLL, "%s%s", v3, "topK.v2.mdplistc");
        fd_rename(*(_QWORD *)(v4 + 14448), (const char *)__str);
      }
      v16 = *(_QWORD *)(v4 + 4904);
      if (!v16)
        goto LABEL_24;
      bzero(buf, 0x400uLL);
      snprintf((char *)buf, 0x400uLL, "%s%s", v3, "directoryStoreFile");
      bzero(__p, 0x400uLL);
      v17 = fd_name(*(_QWORD *)(v16 + 224), (char *)__p, 0x400uLL);
      if (!v17
        || (v18 = v17,
            strlcat(v17, ".shadow", 0x400uLL),
            sibling_protected = (char *)fd_create_sibling_protected(*(_QWORD *)(v16 + 224), v18, 0, 0),
            fd_rename(*(_QWORD *)(v16 + 224), (const char *)buf),
            !sibling_protected))
      {
LABEL_24:
        v20 = *(_QWORD *)(v4 + 4896);
        if (!v20)
        {
LABEL_102:
          snprintf((char *)&__from, 0x400uLL, "%s%s", v5, "shadowIndexGroups");
          snprintf((char *)__str, 0x400uLL, "%s%s", v3, "shadowIndexGroups");
          rename(&__from, __str, v62);
          snprintf((char *)&__from, 0x400uLL, "%s%s", v5, "indexUpdates");
          snprintf((char *)__str, 0x400uLL, "%s%s", v3, "indexUpdates");
          rename(&__from, __str, v63);
          if (*(_QWORD *)(v4 + 9400))
          {
            snprintf((char *)__str, 0x400uLL, "%s%s", v3, "indexPostings");
            fd_rename(*(_QWORD *)(v4 + 9400), (const char *)__str);
          }
          if (*(_QWORD *)(v4 + 14112))
          {
            snprintf((char *)__str, 0x400uLL, "%s%s", v3, "indexPositions");
            fd_rename(*(_QWORD *)(v4 + 14112), (const char *)__str);
          }
          v64 = atomic_load((unsigned int *)(v4 + 28));
          if ((v64 & 4) == 0)
          {
            snprintf((char *)__str, 0x400uLL, "%s%s", v3, "indexTermIds");
            fd_rename(*(_QWORD *)(v4 + 5176), (const char *)__str);
            snprintf((char *)__str, 0x400uLL, "%s%s", v3, "indexPositionTable");
            fd_rename(*(_QWORD *)(v4 + 9888), (const char *)__str);
          }
          v65 = atomic_load((unsigned int *)(v4 + 28));
          if ((v65 & 2) == 0)
          {
            snprintf((char *)&__from, 0x400uLL, "%s%s", v5, "shadowIndexTermIds");
            snprintf((char *)__str, 0x400uLL, "%s%s", v3, "shadowIndexTermIds");
            rename(&__from, __str, v66);
            snprintf((char *)&__from, 0x400uLL, "%s%s", v5, "shadowIndexPositionTable");
            snprintf((char *)__str, 0x400uLL, "%s%s", v3, "shadowIndexPositionTable");
            rename(&__from, __str, v67);
          }
          __strlcpy_chk();
          result = MEMORY[0x1BCCB1484](v13);
          goto LABEL_111;
        }
        v81 = v4;
        v82 = v5;
        v83 = (unsigned int *)(v20 + 8);
        v21 = *__error();
        v22 = _SILogForLogForCategory(16);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
        {
          v23 = (_QWORD *)(v20 + 64);
          if (*(char *)(v20 + 87) < 0)
            v23 = (_QWORD *)*v23;
          v24 = (_QWORD *)(v20 + 40);
          if (*(char *)(v20 + 63) < 0)
            v24 = (_QWORD *)*v24;
          buf[0].st_dev = 136315906;
          *(_QWORD *)&buf[0].st_mode = v23;
          WORD2(buf[0].st_ino) = 2048;
          *(__darwin_ino64_t *)((char *)&buf[0].st_ino + 6) = v20 + 8;
          HIWORD(buf[0].st_gid) = 2080;
          *(_QWORD *)&buf[0].st_rdev = v24;
          LOWORD(buf[0].st_atimespec.tv_sec) = 2080;
          *(__darwin_time_t *)((char *)&buf[0].st_atimespec.tv_sec + 2) = (__darwin_time_t)v3;
          _os_log_impl(&dword_1B8270000, v22, OS_LOG_TYPE_DEFAULT, "[%s] changePrefix %p %s -> %s", (uint8_t *)buf, 0x2Au);
        }
        *__error() = v21;
        v25 = (IVFVectorIndex_s **)(v20 + 16);
        v26 = (IVFVectorIndex_s *)(v20 + 16);
        if (*(char *)(v20 + 39) < 0)
          v26 = *v25;
        IVFVectorIndex_s::unlink(v26, v3, 0);
        v27 = (IVFVectorIndex_s *)(v20 + 16);
        if (*(char *)(v20 + 39) < 0)
          v27 = *v25;
        v79 = (const std::__fs::filesystem::path *)(v20 + 16);
        v80 = v13;
        IVFVectorIndex_s::unlink(v27, v3, (const char *)1);
        v28 = *(_QWORD **)(v20 + 88);
        if (v28 != (_QWORD *)(v20 + 96))
        {
          __src = v3;
          do
          {
            v29 = v28[5];
            v30 = *(unsigned __int16 *)(v29 + 20);
            v32 = *(unsigned int *)(v29 + 8);
            v31 = *(_DWORD *)(v29 + 12);
            if (v31 == 512)
              v33 = 1;
            else
              v33 = 3;
            if (v31 == 768)
              v33 = 2;
            if (v31 == 256)
              v34 = 0;
            else
              v34 = v33;
            v35 = *(_DWORD *)(v29 + 16);
            if (v35 == 2)
              v36 = 1;
            else
              v36 = 3;
            if (v35 == 4)
              v37 = 0;
            else
              v37 = v36;
            memset(__p, 0, 24);
            v38 = strlen(v3);
            if (v38 > 0x7FFFFFFFFFFFFFF7)
              goto LABEL_125;
            v39 = v38;
            if (v38 >= 0x17)
            {
              v41 = (v38 & 0xFFFFFFFFFFFFFFF8) + 8;
              if ((v38 | 7) != 0x17)
                v41 = v38 | 7;
              v42 = v41 + 1;
              p_dst = (std::string *)operator new(v41 + 1);
              __dst.__r_.__value_.__l.__size_ = v39;
              __dst.__r_.__value_.__r.__words[2] = v42 | 0x8000000000000000;
              __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
            }
            else
            {
              *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v38;
              p_dst = &__dst;
              if (!v38)
                goto LABEL_59;
            }
            memcpy(p_dst, __src, v39);
LABEL_59:
            p_dst->__r_.__value_.__s.__data_[v39] = 0;
            IVFIndexName((uint64_t)buf, v32, v30, v34, v37);
            if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v43 = &__dst;
            else
              v43 = (std::string *)__dst.__r_.__value_.__r.__words[0];
            if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              size = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
            else
              size = __dst.__r_.__value_.__l.__size_;
            v45 = std::string::insert((std::string *)buf, 0, (const std::string::value_type *)v43, size);
            v46 = v45->__r_.__value_.__r.__words[2];
            *(_OWORD *)&__p[0].__r_.__value_.__l.__data_ = *(_OWORD *)&v45->__r_.__value_.__l.__data_;
            __p[0].__r_.__value_.__r.__words[2] = v46;
            v45->__r_.__value_.__l.__size_ = 0;
            v45->__r_.__value_.__r.__words[2] = 0;
            v45->__r_.__value_.__r.__words[0] = 0;
            if (SHIBYTE(buf[0].st_gid) < 0)
              operator delete(*(void **)&buf[0].st_dev);
            v3 = __src;
            if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
              operator delete(__dst.__r_.__value_.__l.__data_);
            if ((__p[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v47 = __p;
            else
              v47 = (std::string *)__p[0].__r_.__value_.__r.__words[0];
            (*(void (**)(uint64_t, std::string *))(*(_QWORD *)v29 + 200))(v29, v47);
            if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0)
              operator delete(__p[0].__r_.__value_.__l.__data_);
            v48 = (_QWORD *)v28[1];
            if (v48)
            {
              do
              {
                v49 = v48;
                v48 = (_QWORD *)*v48;
              }
              while (v48);
            }
            else
            {
              do
              {
                v49 = (_QWORD *)v28[2];
                v50 = *v49 == (_QWORD)v28;
                v28 = v49;
              }
              while (!v50);
            }
            v28 = v49;
          }
          while (v49 != (_QWORD *)(v20 + 96));
        }
        v51 = (const char **)(v20 + 40);
        v52 = (const char *)(v20 + 40);
        if (*(char *)(v20 + 63) < 0)
          v52 = *v51;
        v53 = strlen(v52);
        if (v53 <= 0x7FFFFFFFFFFFFFF7)
        {
          v54 = v53;
          v55 = (uint64_t)v3;
          if (v53 >= 0x17)
          {
            v57 = (v53 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v53 | 7) != 0x17)
              v57 = v53 | 7;
            v58 = v57 + 1;
            v56 = (std::string *)operator new(v57 + 1);
            __p[0].__r_.__value_.__r.__words[2] = v58 | 0x8000000000000000;
            __p[0].__r_.__value_.__r.__words[0] = (std::string::size_type)v56;
            __p[0].__r_.__value_.__l.__size_ = v54;
          }
          else
          {
            *((_BYTE *)&__p[0].__r_.__value_.__s + 23) = v53;
            v56 = __p;
            if (!v53)
              goto LABEL_90;
          }
          memmove(v56, v52, v54);
LABEL_90:
          v4 = v81;
          v5 = v82;
          v56->__r_.__value_.__s.__data_[v54] = 0;
          *(_QWORD *)&buf[0].st_dev = MEMORY[0x1E0C809B0];
          buf[0].st_ino = 0x40000000;
          *(_QWORD *)&buf[0].st_uid = ___ZN16IVFVectorIndex_s12changePrefixEPKc_block_invoke;
          *(_QWORD *)&buf[0].st_rdev = &__block_descriptor_tmp_116;
          buf[0].st_atimespec.tv_sec = (__darwin_time_t)v83;
          v3 = (const char *)v55;
          buf[0].st_atimespec.tv_nsec = v55;
          IVFVectorIndex_s::enumerateIndexes(v79, (const void **)&__p[0].__r_.__value_.__l.__data_, 1, 0, (uint64_t)buf);
          if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0)
            operator delete(__p[0].__r_.__value_.__l.__data_);
          memset(__p, 0, 24);
          IVFVectorIndex_s::metaFilename(__p, (uint64_t)v83);
          MEMORY[0x1BCCB03B0](v51, v55);
          memset(&__dst, 0, sizeof(__dst));
          IVFVectorIndex_s::metaFilename(&__dst, (uint64_t)v83);
          if ((__p[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v60 = __p;
          else
            v60 = (std::string *)__p[0].__r_.__value_.__r.__words[0];
          if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v61 = &__dst;
          else
            v61 = (std::string *)__dst.__r_.__value_.__r.__words[0];
          IVFVectorIndex_s::rename((IVFVectorIndex_s *)*v83, (const char *)v60, (const char *)v61, v59);
          if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
            operator delete(__dst.__r_.__value_.__l.__data_);
          v13 = v80;
          if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0)
            operator delete(__p[0].__r_.__value_.__l.__data_);
          goto LABEL_102;
        }
LABEL_125:
        abort();
      }
      if (strstr((char *)buf, ".shadow.shadow"))
      {
        v73 = __si_assert_copy_extra(0);
        v74 = v73;
        v75 = "";
        if (v73)
          v75 = v73;
        __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 3258, "0==strstr(path, \".shadow.shadow\")", v75);
        free(v74);
        if (!__valid_fs(-1))
        {
          MEMORY[0xC00] = -559038737;
          abort();
        }
        MEMORY[0xBAD] = -559038737;
        goto LABEL_125;
      }
      snprintf((char *)buf, 0x400uLL, "%s%s", v3, "directoryStoreFile.shadow");
      fd_rename((uint64_t)sibling_protected, (const char *)buf);
      if (!strstr((char *)buf, ".shadow.shadow"))
      {
        fd_release(sibling_protected);
        goto LABEL_24;
      }
      v76 = __si_assert_copy_extra(0);
      v77 = v76;
      v78 = "";
      if (v76)
        v78 = v76;
      __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 3264, "0==strstr(path, \".shadow.shadow\")", v78);
      free(v77);
      v71 = -1;
LABEL_117:
      if (__valid_fs(v71))
        v72 = 2989;
      else
        v72 = 3072;
      *(_DWORD *)v72 = -559038737;
      abort();
    }
  }
  return result;
}

int *ContentIndexSetEmergency(int *result, int a2)
{
  char v2;
  int *v3;
  int v4;
  int v5;
  NSObject *v6;
  _BOOL4 v7;
  const char *v8;
  int v9;
  const char *v10;
  __int16 v11;
  int v12;
  uint64_t v13;

  v2 = a2;
  v3 = result;
  v13 = *MEMORY[0x1E0C80C00];
  v4 = *((unsigned __int8 *)result + 36);
  if (a2)
  {
    v5 = *__error();
    v6 = _SILogForLogForCategory(10);
    v7 = os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
    if (v4)
    {
      if (v7)
      {
        v9 = 136315394;
        v10 = "_CISetEmergency";
        v11 = 1024;
        v12 = 83;
        v8 = "%s:%d: Reaffirming index emergency state to true";
LABEL_10:
        _os_log_error_impl(&dword_1B8270000, v6, OS_LOG_TYPE_ERROR, v8, (uint8_t *)&v9, 0x12u);
        goto LABEL_11;
      }
    }
    else if (v7)
    {
      v9 = 136315394;
      v10 = "_CISetEmergency";
      v11 = 1024;
      v12 = 81;
      v8 = "%s:%d: Setting index emergency state";
      goto LABEL_10;
    }
    goto LABEL_11;
  }
  if (*((_BYTE *)result + 36))
  {
    v5 = *__error();
    v6 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v9 = 136315394;
      v10 = "_CISetEmergency";
      v11 = 1024;
      v12 = 82;
      v8 = "%s:%d: Clearing index emergency state";
      goto LABEL_10;
    }
LABEL_11:
    result = __error();
    *result = v5;
  }
  *((_BYTE *)v3 + 36) = v2;
  return result;
}

uint64_t ContentIndexRecoverVectorIds(uint64_t result, int a2, int a3)
{
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  _DWORD *v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  NSObject *v15;
  uint64_t v16;
  int v17;
  _QWORD *v18;
  void **v19;
  _QWORD *v20;
  _QWORD *v21;
  BOOL v22;
  _DWORD *v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  NSObject *v30;
  int v31;
  _QWORD *v32;
  void **v33;
  _QWORD *v34;
  _QWORD *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  _QWORD *v39;
  _QWORD *v40;
  void *__p[2];
  char v42;
  uint8_t buf[4];
  _QWORD *v44;
  __int16 v45;
  void **v46;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  if (result)
  {
    v5 = result;
    v6 = *(_QWORD **)(result + 88);
    v7 = (_QWORD *)(result + 96);
    if (v6 != (_QWORD *)(result + 96))
    {
      v37 = result + 40;
      v39 = (_QWORD *)(result + 64);
      do
      {
        v8 = (_DWORD *)v6[5];
        v9 = v8[3];
        switch(v9)
        {
          case 256:
            v10 = 0;
            break;
          case 768:
            v10 = 2;
            break;
          case 512:
            v10 = 1;
            break;
          default:
            v10 = 3;
            break;
        }
        if (v10 == a3)
        {
          v11 = v8[4];
          v12 = v11 == 2 ? 1 : 3;
          v13 = v11 == 4 ? 0 : v12;
          if (v13 == a2 && *((_BYTE *)v8 + 22))
          {
            v14 = *__error();
            v15 = _SILogForLogForCategory(16);
            if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
            {
              v16 = v5;
              v17 = *(char *)(v5 + 87);
              v18 = v39;
              if (v17 < 0)
                v18 = (_QWORD *)*v39;
              (*(void (**)(void **__return_ptr, _DWORD *, uint64_t))(*(_QWORD *)v8 + 312))(__p, v8, v37);
              v19 = __p;
              if (v42 < 0)
                v19 = (void **)__p[0];
              *(_DWORD *)buf = 136315394;
              v44 = v18;
              v45 = 2080;
              v46 = v19;
              _os_log_impl(&dword_1B8270000, v15, OS_LOG_TYPE_DEFAULT, "[%s] updateVectorStorageOffsets %s", buf, 0x16u);
              if (v42 < 0)
                operator delete(__p[0]);
              v5 = v16;
            }
            *__error() = v14;
            result = (*(uint64_t (**)(_DWORD *, _QWORD))(*(_QWORD *)v8 + 304))(v8, 0);
          }
        }
        v20 = (_QWORD *)v6[1];
        if (v20)
        {
          do
          {
            v21 = v20;
            v20 = (_QWORD *)*v20;
          }
          while (v20);
        }
        else
        {
          do
          {
            v21 = (_QWORD *)v6[2];
            v22 = *v21 == (_QWORD)v6;
            v6 = v21;
          }
          while (!v22);
        }
        v6 = v21;
      }
      while (v21 != v7);
      v6 = *(_QWORD **)(v5 + 88);
    }
    if (v6 != v7)
    {
      v38 = v5 + 40;
      v40 = (_QWORD *)(v5 + 64);
      v36 = v5;
      do
      {
        v23 = (_DWORD *)v6[5];
        v24 = v23[3];
        switch(v24)
        {
          case 256:
            v25 = 0;
            break;
          case 768:
            v25 = 2;
            break;
          case 512:
            v25 = 1;
            break;
          default:
            v25 = 3;
            break;
        }
        if (v25 == a3)
        {
          v26 = v23[4];
          v27 = v26 == 2 ? 1 : 3;
          v28 = v26 == 4 ? 0 : v27;
          if (v28 == a2 && !*((_BYTE *)v23 + 22))
          {
            v29 = *__error();
            v30 = _SILogForLogForCategory(16);
            if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
            {
              v31 = *(char *)(v5 + 87);
              v32 = v40;
              if (v31 < 0)
                v32 = (_QWORD *)*v40;
              (*(void (**)(void **__return_ptr, _DWORD *, uint64_t))(*(_QWORD *)v23 + 312))(__p, v23, v38);
              v33 = __p;
              if (v42 < 0)
                v33 = (void **)__p[0];
              *(_DWORD *)buf = 136315394;
              v44 = v32;
              v45 = 2080;
              v46 = v33;
              _os_log_impl(&dword_1B8270000, v30, OS_LOG_TYPE_DEFAULT, "[%s] updateVectorStorageOffsets %s", buf, 0x16u);
              if (v42 < 0)
                operator delete(__p[0]);
              v5 = v36;
            }
            *__error() = v29;
            result = (*(uint64_t (**)(_DWORD *, _QWORD))(*(_QWORD *)v23 + 304))(v23, 0);
          }
        }
        v34 = (_QWORD *)v6[1];
        if (v34)
        {
          do
          {
            v35 = v34;
            v34 = (_QWORD *)*v34;
          }
          while (v34);
        }
        else
        {
          do
          {
            v35 = (_QWORD *)v6[2];
            v22 = *v35 == (_QWORD)v6;
            v6 = v35;
          }
          while (!v22);
        }
        v6 = v35;
      }
      while (v35 != v7);
    }
  }
  return result;
}

uint64_t ContentIndexGetDataForId(uint64_t a1, unint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5)
{
  unsigned int v8;
  int v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  NSObject *v14;
  _QWORD *v15;
  const std::string::value_type *v16;
  uint64_t v17;
  const std::string::value_type *v18;
  int v19;
  const std::string::value_type *v20;
  std::string::size_type v21;
  std::string *v22;
  std::string::size_type v23;
  void **v24;
  int v25;
  NSObject *v26;
  NSObject *v27;
  std::__shared_weak_count *v28;
  unint64_t *p_shared_owners;
  unint64_t v30;
  _QWORD *v32;
  int v33;
  const std::string::value_type *v34;
  std::string::size_type v35;
  std::string *v36;
  std::string::size_type v37;
  void **v38;
  _QWORD *v39;
  const std::string::value_type *v40;
  uint64_t v41;
  const std::string::value_type *v42;
  int v43;
  const std::string::value_type *v44;
  std::string::size_type v45;
  std::string *v46;
  std::string::size_type v47;
  void **v48;
  void *__p[2];
  uint64_t v50;
  uint64_t v51;
  std::__shared_weak_count *v52;
  _BYTE v53[28];
  __int16 v54;
  _BYTE v55[14];
  __int16 v56;
  _WORD v57[17];

  *(_QWORD *)&v57[13] = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0;
  v8 = (a2 >> 2) & 3;
  *(_BYTE *)a4 = (a2 >> 2) & 3;
  v9 = a2 & 3;
  *(_BYTE *)(a4 + 1) = a2 & 3;
  v10 = a2 >> 4;
  *(_WORD *)(a4 + 2) = a3;
  v11 = a2 >> 36;
  v51 = 0;
  v52 = 0;
  IVFVectorIndex_s::getVectorIndex(&v51, a1 + 8, a2 >> 36, (unsigned __int16)a3, v9, v8, a3 >> 31);
  if (!v51)
  {
    v25 = *__error();
    v26 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      v32 = (_QWORD *)(a1 + 64);
      if (*(char *)(a1 + 87) < 0)
        v32 = (_QWORD *)*v32;
      IVFIndexName((uint64_t)v53, v11, (unsigned __int16)a3, v9, v8);
      v33 = *(char *)(a1 + 63);
      if (v33 >= 0)
        v34 = (const std::string::value_type *)(a1 + 40);
      else
        v34 = *(const std::string::value_type **)(a1 + 40);
      if (v33 >= 0)
        v35 = *(unsigned __int8 *)(a1 + 63);
      else
        v35 = *(_QWORD *)(a1 + 48);
      v36 = std::string::insert((std::string *)v53, 0, v34, v35);
      v37 = v36->__r_.__value_.__r.__words[2];
      *(_OWORD *)__p = *(_OWORD *)&v36->__r_.__value_.__l.__data_;
      v50 = v37;
      v36->__r_.__value_.__l.__size_ = 0;
      v36->__r_.__value_.__r.__words[2] = 0;
      v36->__r_.__value_.__r.__words[0] = 0;
      if ((v53[23] & 0x80000000) != 0)
        operator delete(*(void **)v53);
      v38 = __p;
      if (v50 < 0)
        v38 = (void **)__p[0];
      *(_DWORD *)v53 = 136316418;
      *(_QWORD *)&v53[4] = "getDataForId";
      *(_WORD *)&v53[12] = 1024;
      *(_DWORD *)&v53[14] = 4209;
      *(_WORD *)&v53[18] = 2080;
      *(_QWORD *)&v53[20] = v32;
      v54 = 2048;
      *(_QWORD *)v55 = v10;
      *(_WORD *)&v55[8] = 1024;
      *(_DWORD *)&v55[10] = a3;
      v56 = 2080;
      *(_QWORD *)v57 = v38;
      _os_log_error_impl(&dword_1B8270000, v26, OS_LOG_TYPE_ERROR, "%s:%d: [%s] vector index for data_id=%llx meta=%x not exist. %s", v53, 0x36u);
      if (SHIBYTE(v50) < 0)
        operator delete(__p[0]);
    }
    *__error() = v25;
    if ((a3 & 0x80000000) != 0)
    {
      v12 = 0;
      goto LABEL_24;
    }
    v13 = *__error();
    v27 = _SILogForLogForCategory(16);
    if (!os_log_type_enabled(v27, OS_LOG_TYPE_FAULT))
      goto LABEL_22;
    v39 = (_QWORD *)(a1 + 64);
    if (*(char *)(a1 + 87) < 0)
      v39 = (_QWORD *)*v39;
    IVFIndexName((uint64_t)v53, v11, (unsigned __int16)a3, v9, v8);
    v42 = *(const std::string::value_type **)(a1 + 40);
    v41 = a1 + 40;
    v40 = v42;
    v43 = *(char *)(v41 + 23);
    if (v43 >= 0)
      v44 = (const std::string::value_type *)v41;
    else
      v44 = v40;
    if (v43 >= 0)
      v45 = *(unsigned __int8 *)(v41 + 23);
    else
      v45 = *(_QWORD *)(v41 + 8);
    v46 = std::string::insert((std::string *)v53, 0, v44, v45);
    v47 = v46->__r_.__value_.__r.__words[2];
    *(_OWORD *)__p = *(_OWORD *)&v46->__r_.__value_.__l.__data_;
    v50 = v47;
    v46->__r_.__value_.__l.__size_ = 0;
    v46->__r_.__value_.__r.__words[2] = 0;
    v46->__r_.__value_.__r.__words[0] = 0;
    if ((v53[23] & 0x80000000) != 0)
      operator delete(*(void **)v53);
    v48 = __p;
    if (v50 < 0)
      v48 = (void **)__p[0];
    *(_DWORD *)v53 = 136315906;
    *(_QWORD *)&v53[4] = "getDataForId";
    *(_WORD *)&v53[12] = 1024;
    *(_DWORD *)&v53[14] = 4211;
    *(_WORD *)&v53[18] = 2080;
    *(_QWORD *)&v53[20] = v39;
    v54 = 2080;
    *(_QWORD *)v55 = v48;
    _os_log_fault_impl(&dword_1B8270000, v27, OS_LOG_TYPE_FAULT, "%s:%d: [%s] Missing %s is not purgeable", v53, 0x26u);
    goto LABEL_57;
  }
  v12 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(_QWORD *)v51 + 296))(v51, v10, a5);
  if (!v12)
  {
    v13 = *__error();
    v14 = _SILogForLogForCategory(16);
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
LABEL_22:
      v12 = 0;
      *__error() = v13;
      goto LABEL_24;
    }
    v15 = (_QWORD *)(a1 + 64);
    if (*(char *)(a1 + 87) < 0)
      v15 = (_QWORD *)*v15;
    IVFIndexName((uint64_t)v53, v11, (unsigned __int16)a3, v9, v8);
    v18 = *(const std::string::value_type **)(a1 + 40);
    v17 = a1 + 40;
    v16 = v18;
    v19 = *(char *)(v17 + 23);
    if (v19 >= 0)
      v20 = (const std::string::value_type *)v17;
    else
      v20 = v16;
    if (v19 >= 0)
      v21 = *(unsigned __int8 *)(v17 + 23);
    else
      v21 = *(_QWORD *)(v17 + 8);
    v22 = std::string::insert((std::string *)v53, 0, v20, v21);
    v23 = v22->__r_.__value_.__r.__words[2];
    *(_OWORD *)__p = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
    v50 = v23;
    v22->__r_.__value_.__l.__size_ = 0;
    v22->__r_.__value_.__r.__words[2] = 0;
    v22->__r_.__value_.__r.__words[0] = 0;
    if ((v53[23] & 0x80000000) != 0)
      operator delete(*(void **)v53);
    v24 = __p;
    if (v50 < 0)
      v24 = (void **)__p[0];
    *(_DWORD *)v53 = 136316674;
    *(_QWORD *)&v53[4] = "getDataForId";
    *(_WORD *)&v53[12] = 1024;
    *(_DWORD *)&v53[14] = 4221;
    *(_WORD *)&v53[18] = 2080;
    *(_QWORD *)&v53[20] = v15;
    v54 = 1024;
    *(_DWORD *)v55 = v10;
    *(_WORD *)&v55[4] = 2048;
    *(_QWORD *)&v55[6] = v10;
    v56 = 1024;
    *(_DWORD *)v57 = a3;
    v57[2] = 2080;
    *(_QWORD *)&v57[3] = v24;
    _os_log_error_impl(&dword_1B8270000, v14, OS_LOG_TYPE_ERROR, "%s:%d: [%s] vector for offset=%u data_id=%llx meta=%x not exist. %s", v53, 0x3Cu);
LABEL_57:
    if (SHIBYTE(v50) < 0)
      operator delete(__p[0]);
    goto LABEL_22;
  }
LABEL_24:
  v28 = v52;
  if (v52)
  {
    p_shared_owners = (unint64_t *)&v52->__shared_owners_;
    do
      v30 = __ldaxr(p_shared_owners);
    while (__stlxr(v30 - 1, p_shared_owners));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }
  return v12;
}

void ContentIndexSetDirtyCallback(uint64_t a1, void *aBlock)
{
  void *v3;
  const void *v4;

  if (aBlock)
    v3 = _Block_copy(aBlock);
  else
    v3 = 0;
  v4 = *(const void **)(a1 + 15144);
  if (v4)
    _Block_release(v4);
  *(_QWORD *)(a1 + 15144) = v3;
}

_DWORD *_ContentIndexSetPayloadMaxCount(_DWORD *result, int a2, int a3)
{
  unsigned int v3;
  unsigned int v4;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v3 = a2 - result[18];
  result[4102] = v3;
  result[4103] = a3;
  v4 = result[15];
  if (v4 > v3 && v4 >= 2)
  {
    v6 = __si_assert_copy_extra_268();
    __message_assert_272((uint64_t)v6, v7, v8, v9, v10, v11, v12, v13, (char)"ContentIndex.c");
    free(v6);
    if (__valid_fs(-1))
      v14 = 2989;
    else
      v14 = 3072;
    *(_DWORD *)v14 = -559038737;
    abort();
  }
  return result;
}

char *ContentIndexQueryNodeForLocalizedFields(uint64_t a1, unsigned int *a2, char *a3, unsigned int a4)
{
  uint64_t v7;
  size_t v8;
  char *v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  unsigned int v14;
  CFNumberRef v15;
  unsigned int v16;
  char *v17;
  uint64_t v18;

  v7 = a4;
  v8 = ((unint64_t)a4 << 6) | 0x28;
  if ((((unint64_t)a4 >> 11) & 0x7FFFFFFFFFFFLL) == 0 && v8 > *MEMORY[0x1E0C85AD8])
    ++sTotal_9538;
  v10 = (char *)malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, v8, 0x31F9A007uLL);
  if (!v10)
    _log_fault_for_malloc_failure();
  v11 = 0;
  *((_DWORD *)v10 + 2) = 0;
  v12 = *(_DWORD *)(a1 + 4) | 0x400000;
  *(_QWORD *)(v10 + 12) = *(_QWORD *)(a1 + 12);
  *(_DWORD *)v10 = 1;
  *((_DWORD *)v10 + 1) = v12;
  *((_QWORD *)v10 + 4) = v10 + 40;
  do
  {
    v13 = *((_QWORD *)v10 + 4) + v11;
    v14 = *a2;
    *(_QWORD *)v13 = 0;
    *(_QWORD *)(v13 + 8) = 0;
    *(_DWORD *)(v13 + 16) = 100;
    *(_DWORD *)(v13 + 20) = v14;
    *(_DWORD *)(v13 + 24) = 8;
    *(_OWORD *)(v13 + 28) = 0u;
    *(_OWORD *)(v13 + 44) = 0u;
    *(_DWORD *)(v13 + 60) = 0;
    v15 = CFNumberCreate((CFAllocatorRef)kCIQueryZoneAllocator, kCFNumberSInt32Type, a3);
    *(_QWORD *)(*((_QWORD *)v10 + 4) + v11) = copyLocTermFromNumber(v15, *a2);
    v16 = *a2++;
    v17 = copyLocTermFromNumber(v15, v16);
    v18 = *((_QWORD *)v10 + 4) + v11;
    *(_QWORD *)(v18 + 8) = v17;
    *(_DWORD *)(v18 + 20) = -1;
    ++*((_DWORD *)v10 + 6);
    CFRelease(v15);
    v11 += 64;
    a3 += 4;
    --v7;
  }
  while (v7);
  return v10;
}

_QWORD *ContentIndexQueryNodeForVector(int a1, uint64_t a2, char a3, char a4, int a5, int a6, int a7, float a8)
{
  _QWORD *v16;
  int v17;

  if (*MEMORY[0x1E0C85AD8] <= 0x67uLL)
    ++sTotal_9538;
  v16 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x68uLL, 0x31F9A007uLL);
  if (v16)
  {
    if (!a1)
      return v16;
  }
  else
  {
    _log_fault_for_malloc_failure();
    if (!a1)
      return v16;
  }
  *(_DWORD *)v16 = 1;
  v16[5] = a2;
  v16[4] = v16 + 5;
  v16[10] = 0;
  v16[11] = 0;
  if (a7)
    v17 = 0x1000000;
  else
    v17 = 0;
  v16[6] = 0;
  *((_DWORD *)v16 + 14) = 16;
  *((_DWORD *)v16 + 15) = a1;
  v16[8] = 0;
  v16[9] = 0;
  *((float *)v16 + 24) = a8;
  *((_DWORD *)v16 + 25) = a3 & 3 | (4 * (a4 & 3)) & 0xF | (a5 << 25) | (16 * (a6 & 0xFFFFF)) | v17;
  return v16;
}

uint64_t ContentIndexContainsContentByDocId(uint64_t a1, unint64_t a2, const __CFString *a3, int a4, uint64_t a5, unsigned int a6, char a7)
{
  int *v10;
  uint64_t v11;

  v10 = _CIQueryNodeForString(a1, a3, 0, a4, a5, a6, 0, 0);
  v11 = _CIMatchesNodeByDocId(a1, (uint64_t)v10, a2, a7);
  ContentIndexQueryNodeDispose((char *)v10);
  return v11;
}

uint64_t CIRemappingCreateWithContext(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  if (!__kCIRemappingTypeID)
    __kCIRemappingTypeID = _CFRuntimeRegisterClass();
  result = _CFRuntimeCreateInstance();
  *(_QWORD *)(result + 16) = a3;
  *(_QWORD *)(result + 32) = a2;
  return result;
}

double __CIRemappingInit(uint64_t a1)
{
  double result;

  result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

void __CIRemappingFinalize(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = *(_QWORD *)(a1 + 16);
  if (*(uint64_t *)v2 >= 1)
  {
    v3 = 0;
    v4 = 16;
    do
    {
      free(*(void **)(*(_QWORD *)(v2 + 8) + v4));
      ++v3;
      v2 = *(_QWORD *)(a1 + 16);
      v4 += 24;
    }
    while (v3 < *(_QWORD *)v2);
  }
  free(*(void **)(v2 + 8));
  free(*(void **)(a1 + 16));
}

uint64_t CIDecodeRemappingMetadataWithIndex(int a1, unsigned int a2, uint64_t a3)
{
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  off_t v10;
  off_t v11;
  uint64_t v12;
  off_t v13;
  _QWORD *v14;
  void *v15;
  unsigned int v16;
  uint64_t v17;
  unint64_t v18;
  unsigned int *v19;
  off_t v20;
  unsigned int *v21;
  ssize_t v22;
  off_t v23;
  void *v25;
  ssize_t v26;
  uint64_t v27;
  void *v29;
  unsigned int v30;
  uint64_t v31;
  uint64_t v32;
  off_t v33;
  unsigned int *v34;
  off_t v35;
  unsigned int v36;
  void *v37;
  uint64_t v38;
  uint64_t *v39;
  ssize_t v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v52;
  uint64_t v53;
  stat v54;
  unint64_t v55;
  int __buf;
  unsigned int size;
  char size_4[1024];
  uint64_t v59;

  v59 = *MEMORY[0x1E0C80C00];
  bzero(size_4, 0x400uLL);
  snprintf(size_4, 0x400uLL, "remapping%d", a3);
  memset(&v54, 0, sizeof(v54));
  if (!fstatat(a1, size_4, &v54, 0))
  {
    v7 = (char *)fd_create_protected(a1, size_4, 536872962, 3u);
    v53 = 0;
    v8 = _fd_acquire_fd((uint64_t)v7, &v53);
    if ((_DWORD)v8 == -1)
    {
      v6 = 0;
LABEL_59:
      fd_release(v7);
      return v6;
    }
    v9 = v8;
    __buf = 0;
    v55 = 0;
    if (prot_pread(v8, &__buf, 4uLL, 0) == 4)
      v10 = 4;
    else
      v10 = -1;
    if (prot_pread(v9, &v55, 8uLL, v10) != 8)
      goto LABEL_57;
    v11 = v10 + 8;
    if (__buf == -16777457)
    {
      v12 = bswap64(v55);
      size = 0;
      if (prot_pread(v9, &size, 4uLL, v11) == 4)
      {
        v13 = v10 + 12;
        size = bswap32(size);
        v14 = malloc_type_calloc(1uLL, 0x10uLL, 0x10200405730B0C9uLL);
        v29 = malloc_type_calloc(0x18uLL, size, 0xC00FFE35uLL);
        v30 = size;
        *v14 = size;
        v14[1] = v29;
        if (!v30)
          goto LABEL_54;
        v52 = v12;
        v31 = 0;
        while (1)
        {
          v32 = v14[1];
          if (prot_pread(v9, (void *)(v32 + 24 * v31), 8uLL, v13) == 8)
          {
            v33 = v13 + 8;
            *(_QWORD *)(v32 + 24 * v31) = bswap64(*(_QWORD *)(v32 + 24 * v31));
          }
          else
          {
            v33 = -1;
          }
          v34 = (unsigned int *)(v32 + 24 * v31 + 8);
          if (prot_pread(v9, v34, 4uLL, v33) != 4)
            break;
          v35 = v33 + 4;
          v36 = bswap32(*v34);
          *v34 = v36;
          if (v35 == -1)
            break;
          v37 = malloc_type_malloc(4 * v36, 0x100004052888210uLL);
          v38 = v32 + 24 * v31;
          *(_QWORD *)(v38 + 16) = v37;
          v39 = (uint64_t *)(v38 + 16);
          v40 = prot_pread(v9, v37, 4 * *v34, v35);
          v41 = *v34;
          if (v40 != 4 * v41)
            break;
          if ((_DWORD)v41)
          {
            v42 = 0;
            v43 = *v39;
            do
            {
              *(_DWORD *)(v43 + 4 * v42) = bswap32(*(_DWORD *)(v43 + 4 * v42));
              ++v42;
              v44 = *v34;
            }
            while (v42 < v44);
            v45 = 4 * v44;
          }
          else
          {
            v45 = 0;
          }
          v13 = v45 + v35;
          if (v45 + v35 == -1)
            break;
          if (++v31 >= (unint64_t)size)
            goto LABEL_53;
        }
        if ((_DWORD)v31)
        {
          v46 = v14[1];
          v47 = 16;
          do
          {
            free(*(void **)(v46 + v47));
            v46 = v14[1];
            *(_QWORD *)(v46 + v47) = 0;
            v47 += 24;
            --v31;
          }
          while (v31);
        }
        goto LABEL_52;
      }
    }
    else
    {
      if (__buf != 268435454)
        goto LABEL_57;
      v12 = v55;
      size = 0;
      if (prot_pread(v9, &size, 4uLL, v11) == 4)
      {
        v13 = v10 + 12;
        v14 = malloc_type_calloc(1uLL, 0x10uLL, 0x10200405730B0C9uLL);
        v15 = malloc_type_calloc(0x18uLL, size, 0xDFB9D458uLL);
        v16 = size;
        *v14 = size;
        v14[1] = v15;
        if (!v16)
          goto LABEL_54;
        v52 = v12;
        v17 = 0;
        v18 = 0;
        while (1)
        {
          v19 = (unsigned int *)(v14[1] + v17);
          v20 = prot_pread(v9, v19, 8uLL, v13) == 8 ? v13 + 8 : -1;
          v21 = v19 + 2;
          v22 = prot_pread(v9, v19 + 2, 4uLL, v20);
          v23 = v20 + 4;
          if (v22 != 4 || v23 == -1)
            break;
          v25 = malloc_type_malloc(4 * *v21, 0x100004052888210uLL);
          *((_QWORD *)v19 + 2) = v25;
          v26 = prot_pread(v9, v25, 4 * *v21, v23);
          v27 = *v21;
          v13 = v23 + 4 * v27;
          if (v26 != 4 * v27 || v13 == -1)
            break;
          ++v18;
          v17 += 24;
          if (v18 >= size)
            goto LABEL_53;
        }
        if ((_DWORD)v18)
        {
          v48 = v14[1];
          v49 = 16;
          do
          {
            free(*(void **)(v48 + v49));
            v48 = v14[1];
            *(_QWORD *)(v48 + v49) = 0;
            v49 += 24;
            --v18;
          }
          while (v18);
        }
LABEL_52:
        free(v14);
        v14 = 0;
        v13 = -1;
LABEL_53:
        v12 = v52;
LABEL_54:
        if (v13 != -1)
        {
          v50 = CIRemappingCreateWithContext(*MEMORY[0x1E0C9AE00], v12, (uint64_t)v14);
          v6 = v50;
          if (v50)
          {
            *(_QWORD *)(v50 + 40) = a3;
            *(_QWORD *)(v50 + 24) = a2;
          }
          goto LABEL_58;
        }
LABEL_57:
        v6 = 0;
LABEL_58:
        _fd_release_fd(v7, v9, 0, v53);
        goto LABEL_59;
      }
    }
    v14 = 0;
    v13 = -1;
    goto LABEL_54;
  }
  return 0;
}

unint64_t ContentIndexRemappingNextDocId(_QWORD *a1, unint64_t *a2)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;

  v2 = (uint64_t *)a1[2];
  v3 = *v2;
  if (*v2 < 1)
    return 0;
  v4 = 0;
  v5 = 0;
  v6 = a1[3];
  v7 = v2[1];
  while (1)
  {
    v8 = v7 + 24 * v4;
    v9 = *(unsigned int *)(v8 + 8);
    v5 += v9;
    v10 = *(_QWORD *)v8;
    v11 = *(_QWORD *)v8 >= v6 ? v10 + 1 : v6;
    if (v10 < v11 && v10 + v9 > v11)
      break;
    v6 = v11;
LABEL_17:
    if (++v4 == v3)
      return 0;
  }
  v13 = *(_QWORD *)(v7 + 24 * v4 + 16);
  while (1)
  {
    *a2 = v11;
    v14 = *(_QWORD *)v8;
    v15 = *(unsigned int *)(v13 - 4 * *(_QWORD *)v8 + 4 * v11);
    if ((_DWORD)v15)
      break;
    v6 = v11 + 1;
    if (v14 > v11++ || v14 + v9 <= v6)
      goto LABEL_17;
  }
  if (v5 <= v15)
  {
    v18 = __si_assert_copy_extra_268();
    __message_assert_272((uint64_t)v18, v19, v20, v21, v22, v23, v24, v25, (char)"ContentIndexCommon.c");
    free(v18);
    if (__valid_fs(-1))
      v26 = 2989;
    else
      v26 = 3072;
    *(_DWORD *)v26 = -559038737;
    abort();
  }
  return a1[4] + v15;
}

void _qsort_big_oid_t(void *a1)
{
  uint64_t v1;
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  signed int v6;
  unint64_t i;
  uint64_t v8;
  uint64_t v10;
  host_t v11;
  mach_error_t v12;
  unint64_t v13;
  unint64_t v14;
  NSObject *v15;
  qos_class_t v16;
  NSObject *global_queue;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _DWORD *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  int v26;
  int v27;
  qos_class_t v28;
  NSObject *v29;
  qos_class_t v30;
  NSObject *v31;
  char *v32;
  char *v33;
  const char *v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  _QWORD block[5];
  mach_msg_type_number_t host_info_outCnt;
  integer_t host_info_out[4];
  __int128 v42;
  __int128 v43;

  v1 = *((_QWORD *)a1 + 1);
  v2 = *((_QWORD *)a1 + 2);
  v3 = *((_QWORD *)a1 + 3);
  v4 = *((_QWORD *)a1 + 4);
  v5 = *((_QWORD *)a1 + 5);
  v37 = *((_QWORD *)a1 + 6);
  v38 = *(_QWORD *)a1;
  v6 = *((_DWORD *)a1 + 14);
  v36 = *((_DWORD *)a1 + 15);
  OSAtomicEnqueue(&qsort_cached_allocations_8426, a1, 0);
  if (v2 > v1)
  {
    for (i = v4 + 1; ; ++i)
    {
      v8 = v2 - v1;
      if (v2 - v1 <= v5 || i > 9)
        break;
      if (v6 <= 1)
        v6 = 1;
      v10 = getSize_memSize_8428;
      if (!getSize_memSize_8428)
      {
        v42 = 0u;
        v43 = 0u;
        *(_OWORD *)host_info_out = 0u;
        v11 = MEMORY[0x1BCCB1010]();
        host_info_outCnt = 12;
        v12 = host_info(v11, 1, host_info_out, &host_info_outCnt);
        if (v12)
        {
          mach_error("flushsize", v12);
          exit(1);
        }
        v10 = *((_QWORD *)&v43 + 1);
        getSize_memSize_8428 = *((_QWORD *)&v43 + 1);
      }
      v13 = 3 * v10;
      v14 = (v13 * (unsigned __int128)0xCCCCCCCCCCCCCCCDLL) >> 64;
      v15 = v3;
      if (8 * v8 > v13 / 5)
        v15 = dispatch_group_create();
      if (v8 <= v37 || 8 * v8 >= v14 >> 2)
      {
        v18 = _partition_oid_t(v38, v1, v2);
      }
      else
      {
        v16 = qos_class_self();
        global_queue = dispatch_get_global_queue(v16, 2uLL);
        v18 = _big_partition_oid_t(v38, v1, v2, global_queue, v6);
      }
      v19 = v18;
      v20 = v18 - v1;
      if (v18 < v1)
      {
        v32 = __si_assert_copy_extra_268();
        v33 = v32;
        v34 = "";
        if (v32)
          v34 = v32;
        __message_assert(v32, "qsort_oids.c", 24, "q>=left", v34);
        free(v33);
        if (__valid_fs(-1))
          v35 = 2989;
        else
          v35 = 3072;
        *(_DWORD *)v35 = -559038737;
        abort();
      }
      v21 = OSAtomicDequeue(&qsort_cached_allocations_8426, 0);
      if (!v21)
        v21 = malloc_type_malloc(0x40uLL, 0x10300409C00947AuLL);
      *((_QWORD *)v21 + 4) = i;
      *((_QWORD *)v21 + 5) = v5;
      *((_QWORD *)v21 + 6) = v37;
      v22 = v2 - v19;
      if (v20 <= v2 - v19)
      {
        v23 = v19 - 1;
      }
      else
      {
        v22 = v19 - 1 - v1;
        v23 = v2;
      }
      if (v20 > v2 - v19)
        v24 = v19;
      else
        v24 = v1;
      if (v20 > v2 - v19)
        v2 = v19 - 1;
      else
        v1 = v19;
      *(_QWORD *)v21 = v38;
      *((_QWORD *)v21 + 1) = v24;
      v25 = (int)(float)((float)((float)(v22 + 1) / (float)(v23 - v24 + 1)) * (float)v6);
      if (v25 <= 1)
        v26 = 1;
      else
        v26 = v25;
      if (v6 >= v25)
        v27 = v26;
      else
        v27 = 0;
      v21[14] = v6 - v27;
      v21[15] = v36;
      *((_QWORD *)v21 + 2) = v23;
      *((_QWORD *)v21 + 3) = v15;
      if (v15 == v3)
      {
        if (v6 >= v25)
          v6 = v26;
        v30 = qos_class_self();
        v31 = dispatch_get_global_queue(v30, 2uLL);
        dispatch_group_async_f(v3, v31, v21, (dispatch_function_t)_qsort_big_oid_t);
      }
      else
      {
        v21[14] = v6;
        _qsort_big_oid_t(v21);
        dispatch_group_wait(v15, 0xFFFFFFFFFFFFFFFFLL);
        dispatch_release(v15);
        v28 = qos_class_self();
        v29 = dispatch_get_global_queue(v28, 2uLL);
        block[0] = MEMORY[0x1E0C809B0];
        block[1] = 0x40000000;
        block[2] = ___qsort_big_oid_t_block_invoke;
        block[3] = &__block_descriptor_tmp_8_8435;
        block[4] = v21;
        dispatch_async(v29, block);
      }
      if (v2 <= v1)
        return;
    }
    _qsort_oid_t(v38, v1, v2);
  }
}

uint64_t _big_partition_oid_t(uint64_t a1, uint64_t a2, uint64_t a3, NSObject *a4, unsigned int a5)
{
  uint64_t v7;
  BOOL v8;
  unint64_t v9;
  uint64_t *v10;
  unint64_t v11;
  uint64_t *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t *v21;
  uint64_t v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  uint64_t *v31;
  _QWORD *v32;
  _QWORD *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  _QWORD *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;

  v7 = a3 - a2;
  v8 = __OFADD__(a3 - a2, 1);
  v9 = a3 - a2 + 1;
  v10 = (uint64_t *)(a1 + 8 * a2);
  v11 = v7 + 2;
  if (((v9 & 0x8000000000000000) != 0) == v8)
    v11 = v7 + 1;
  v12 = &v10[v11 >> 1];
  v13 = (_QWORD *)(a1 + 8 * a3);
  if (v7 < 64)
  {
    v28 = &v10[v11 >> 1];
    v18 = v10;
  }
  else
  {
    v14 = v9 >> 3;
    v15 = &v10[v9 >> 3];
    v16 = *v10;
    v17 = *v15;
    v18 = v10;
    if (*v10 != *v15)
    {
      v18 = &v10[2 * v14];
      v19 = *v18;
      if (v16 >= *v18)
        v20 = &v10[2 * v14];
      else
        v20 = v10;
      if (v17 > v19)
        v20 = &v10[v9 >> 3];
      if (v16 >= v19)
        v21 = v10;
      else
        v21 = &v10[2 * v14];
      if (v17 >= v19)
        v15 = v21;
      if (v16 >= v17)
        v15 = v20;
      if (v19 != v16 && v19 != v17)
        v18 = v15;
    }
    v23 = 2 * v14;
    v24 = -(uint64_t)v14;
    v25 = &v12[-v14];
    v26 = *v25;
    v27 = *v12;
    if (*v25 == *v12)
    {
      v28 = &v12[-v14];
    }
    else
    {
      v28 = &v12[v14];
      v29 = *v28;
      if (*v28 != v26 && v29 != v27)
      {
        if (v26 >= v29)
          v31 = v28;
        else
          v31 = v25;
        if (v27 > v29)
          v31 = v12;
        if (v26 >= v29)
          v28 = v25;
        if (v27 < v29)
          v28 = v12;
        if (v26 >= v27)
          v28 = v31;
      }
    }
    v32 = &v13[-v23];
    v33 = &v13[v24];
    v34 = *v32;
    v35 = *v33;
    if (*v32 == *v33)
    {
      v13 = v32;
    }
    else
    {
      v36 = *v13;
      if (v34 >= *v13)
        v37 = v13;
      else
        v37 = v32;
      if (v35 > v36)
        v37 = v33;
      if (v34 < v36)
        v32 = v13;
      if (v35 < v36)
        v32 = v33;
      if (v34 >= v35)
        v32 = v37;
      if (v36 == v35)
        v32 = v13;
      if (v36 != v34)
        v13 = v32;
    }
  }
  v38 = *v18;
  v39 = *v28;
  if (*v18 == *v28)
  {
    v28 = v18;
  }
  else
  {
    v40 = *v13;
    if (*v13 == v38 || v40 == v39)
    {
      v28 = v13;
    }
    else if (v38 >= v39)
    {
      if (v39 <= v40)
      {
        if (v38 >= v40)
          v28 = v13;
        else
          v28 = v18;
      }
    }
    else if (v39 >= v40)
    {
      if (v38 >= v40)
        v28 = v18;
      else
        v28 = v13;
    }
  }
  return parallel_partition_oid_t(v10, v9, *v28, a4, a5) + a2;
}

void ___qsort_big_oid_t_block_invoke(uint64_t a1)
{
  madvise((void *)(**(_QWORD **)(a1 + 32) + 8 * *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8)), 8 * (*(_QWORD *)(*(_QWORD *)(a1 + 32) + 16) - *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8)), 4);
  OSAtomicEnqueue(&qsort_cached_allocations_8426, *(void **)(a1 + 32), 0);
}

uint64_t parallel_partition_oid_t(void *a1, uint64_t a2, uint64_t a3, NSObject *a4, unsigned int a5)
{
  int v5;
  size_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD v17[2];
  _QWORD context[10];

  v5 = a5;
  v17[1] = v17;
  context[9] = *MEMORY[0x1E0C80C00];
  context[6] = a1;
  v10 = 8 * a5;
  MEMORY[0x1E0C80A78](a1);
  v12 = (char *)v17 - v11;
  bzero((char *)v17 - v11, v10);
  v13 = (a2 / 0x4000) << 13;
  context[1] = v13;
  context[2] = a2;
  context[4] = 0;
  context[5] = 0;
  v14 = a2 - v13;
  context[7] = a3;
  context[8] = v12;
  if (v5 >= 1)
    memset(v12, 255, v10);
  v15 = v13 + 0x2000;
  if (v14 > v13 + 0x2000)
    v15 = a2 - ((a2 / 0x4000) << 13);
  context[3] = v14 + ((v15 - v14 + 0x1FFF) & 0xFFFFFFFFFFFFE000);
  context[0] = 0;
  if (8 * a2 >= (unint64_t)(4 * *MEMORY[0x1E0C85AD8]))
    madvise(a1, 8 * a2, 3);
  if (a2 / 0x4000 < v5)
    v5 = a2 / 0x4000;
  dispatch_apply_f(v5, a4, context, (void (__cdecl *)(void *, size_t))partition_phase_oid_t);
  return sequential_fixup_oid_t((uint64_t)context, a2, v5);
}

unint64_t *partition_phase_oid_t(unint64_t *result, uint64_t a2)
{
  unint64_t *v3;
  unint64_t v4;
  int64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  BOOL v15;
  int64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;

  v3 = result;
  v4 = result[6];
  v5 = result[1];
  if ((uint64_t)*result >= v5)
    goto LABEL_5;
  do
    v6 = __ldxr(result);
  while (__stxr(v6 + 0x2000, result));
  if ((uint64_t)(v6 + 0x2000) > v5)
  {
    do
      v7 = __ldxr(result);
    while (__stxr(v7 - 0x2000, result));
LABEL_5:
    v6 = -1;
  }
  v8 = result[3];
  v9 = result + 2;
  if ((uint64_t)result[2] <= v8)
  {
LABEL_10:
    v13 = 0;
    if (v6 != -1)
    {
      v14 = 0;
      goto LABEL_36;
    }
    v11 = -1;
    v14 = 0;
LABEL_35:
    v6 = v11;
    goto LABEL_36;
  }
  do
  {
    v10 = __ldxr(v9);
    v11 = v10 - 0x2000;
  }
  while (__stxr(v10 - 0x2000, v9));
  if (v11 < v8)
  {
    do
      v12 = __ldxr(v9);
    while (__stxr(v12 + 0x2000, v9));
    goto LABEL_10;
  }
  v26 = 0;
  v27 = 0;
  v15 = v6 != -1;
  if (v10 != 0x1FFF && v6 != -1)
  {
    v13 = 0;
    v14 = 0;
    while (1)
    {
      result = (unint64_t *)neutralize_oid_t(v4 + 8 * v6, v4 + 8 * v11, v3[7], &v27, &v26);
      if ((result & 1) != 0)
        goto LABEL_26;
      v17 = v3[1];
      if ((uint64_t)*v3 >= v17)
        goto LABEL_24;
      do
        v6 = __ldxr(v3);
      while (__stxr(v6 + 0x2000, v3));
      if ((uint64_t)(v6 + 0x2000) > v17)
        break;
LABEL_25:
      v27 = 0;
      ++v14;
      if (((_DWORD)result - 1) > 1)
        goto LABEL_32;
LABEL_26:
      v19 = v3[3];
      if ((uint64_t)v3[2] > v19)
      {
        do
        {
          v20 = __ldxr(v9);
          v11 = v20 - 0x2000;
        }
        while (__stxr(v20 - 0x2000, v9));
        if (v11 >= v19)
          goto LABEL_31;
        do
          v21 = __ldxr(v9);
        while (__stxr(v21 + 0x2000, v9));
      }
      v11 = -1;
LABEL_31:
      v26 = 0;
      ++v13;
LABEL_32:
      v15 = v6 != -1;
      if (v11 == -1 || v6 == -1)
        goto LABEL_34;
    }
    do
      v18 = __ldxr(v3);
    while (__stxr(v18 - 0x2000, v3));
LABEL_24:
    v6 = -1;
    goto LABEL_25;
  }
  v14 = 0;
  v13 = 0;
LABEL_34:
  if (!v15)
    goto LABEL_35;
LABEL_36:
  *(_QWORD *)(v3[8] + 8 * a2) = v6;
  v22 = v3 + 4;
  do
    v23 = __ldxr(v22);
  while (__stxr(v23 + (v14 << 13), v22));
  v24 = v3 + 5;
  do
    v25 = __ldxr(v24);
  while (__stxr(v25 + (v13 << 13), v24));
  return result;
}

uint64_t sequential_fixup_oid_t(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  BOOL v13;
  uint64_t v14;
  unint64_t v15;
  void *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  char *v43;
  char *v44;
  const char *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;

  v6 = a3;
  qsort(*(void **)(a1 + 64), a3, 8uLL, (int (__cdecl *)(const void *, const void *))index_comp_8440);
  v47 = 0;
  v48 = 0;
  v7 = *(_QWORD *)(a1 + 64);
  v8 = a3 - 1;
  v9 = 0;
  if (a3 < 1)
    goto LABEL_90;
  while (*(_QWORD *)(v7 + 8 * v9) == -1)
  {
    if (v6 == ++v9)
    {
      v9 = v6;
      break;
    }
  }
  if (a3 == 1)
  {
    v8 = 0;
  }
  else
  {
LABEL_90:
    do
    {
      if (*(_QWORD *)(v7 + 8 * v8) != -1)
        break;
      --v8;
    }
    while (v8);
  }
  while (v9 < v8)
  {
    v10 = neutralize_oid_t(*(_QWORD *)(a1 + 48) + 8 * *(_QWORD *)(v7 + 8 * v9), *(_QWORD *)(a1 + 48) + 8 * *(_QWORD *)(v7 + 8 * v8), *(_QWORD *)(a1 + 56), &v47, &v48);
    v7 = *(_QWORD *)(a1 + 64);
    if ((v10 & 1) == 0)
    {
      v11 = *(_QWORD *)(v7 + 8 * v9);
      if ((v11 & 0x8000000000000000) == 0 && v11 < *(_QWORD *)(a1 + 32))
      {
        *(_QWORD *)(v7 + 8 * v9) = -1;
        *(_QWORD *)(a1 + 32) += 0x2000;
      }
      ++v9;
      v47 = 0;
      if ((v10 - 1) > 1)
        continue;
    }
    v12 = *(_QWORD *)(v7 + 8 * v8);
    v13 = v12 >= a2 || v12 < a2 - *(_QWORD *)(a1 + 40);
    if (!v13)
    {
      *(_QWORD *)(v7 + 8 * v8) = -1;
      *(_QWORD *)(a1 + 40) += 0x2000;
    }
    --v8;
    v48 = 0;
  }
  v15 = *(_QWORD *)(a1 + 32);
  v14 = *(_QWORD *)(a1 + 40);
  v16 = malloc_type_malloc(0x10000uLL, 0xA0D83538uLL);
  if (a3 < 1)
  {
    v31 = *(_QWORD *)a1;
    v32 = *(_QWORD *)(a1 + 16) - 1;
  }
  else
  {
    v17 = 0;
    v18 = ~v14 + a2;
    v19 = a3;
    v20 = *(uint64_t **)(a1 + 64);
    v21 = 8 * a3;
    do
    {
      v22 = v20[v17];
      if (v22 != -1 && v18 <= v22)
        break;
      if (v22 != -1)
      {
        if (v15 <= v22)
          break;
        v24 = *(_QWORD *)(a1 + 32);
        if (v24 > v22)
        {
          v25 = 0;
          do
          {
            if (v20[v25 / 8] == v24)
            {
              v24 += 0x2000;
              *(_QWORD *)(a1 + 32) = v24;
            }
            v25 += 8;
          }
          while (v21 != v25);
          if ((int64_t)v24 >= *(_QWORD *)a1)
            break;
          memcpy(v16, (const void *)(*(_QWORD *)(a1 + 48) + 8 * v20[v17]), 0x10000uLL);
          memcpy((void *)(*(_QWORD *)(a1 + 48) + 8 * *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8 * v17)), (const void *)(*(_QWORD *)(a1 + 48) + 8 * *(_QWORD *)(a1 + 32)), 0x10000uLL);
          memcpy((void *)(*(_QWORD *)(a1 + 48) + 8 * *(_QWORD *)(a1 + 32)), v16, 0x10000uLL);
          v20 = *(uint64_t **)(a1 + 64);
          v20[v17] = *(_QWORD *)(a1 + 32);
          *(_QWORD *)(a1 + 32) += 0x2000;
        }
      }
      ++v17;
    }
    while (v17 != v19);
    v26 = v19;
    do
    {
      v27 = v20[(v26 - 1)];
      if (v15 > v27)
        break;
      if (v27 != -1)
      {
        if (v18 > v27)
          break;
        v28 = (v26 - 1);
        v29 = *(_QWORD *)(a1 + 40) + 0x2000;
        *(_QWORD *)(a1 + 40) = v29;
        v30 = v19 + 1;
        do
        {
          if (v20[(v30 - 2)] == a2 - v29)
          {
            v29 += 0x2000;
            *(_QWORD *)(a1 + 40) = v29;
          }
          --v30;
        }
        while (v30 > 1);
        if ((unint64_t)(a2 - v29) < *(_QWORD *)(a1 + 16))
          break;
        memcpy(v16, (const void *)(*(_QWORD *)(a1 + 48) + 8 * v20[v28]), 0x10000uLL);
        memcpy((void *)(*(_QWORD *)(a1 + 48) + 8 * *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8 * v28)), (const void *)(*(_QWORD *)(a1 + 48) + 8 * (a2 - *(_QWORD *)(a1 + 40))), 0x10000uLL);
        memcpy((void *)(*(_QWORD *)(a1 + 48) + 8 * (a2 - *(_QWORD *)(a1 + 40))), v16, 0x10000uLL);
        v20 = *(uint64_t **)(a1 + 64);
        v20[v28] = a2 - *(_QWORD *)(a1 + 40);
      }
      v13 = v26-- <= 1;
    }
    while (!v13);
    v31 = *(_QWORD *)a1;
    v32 = *(_QWORD *)(a1 + 16) - 1;
    do
    {
      v34 = *v20++;
      v33 = v34;
      if (v34 != -1)
      {
        if (v33 < v31)
          v31 = v33;
        v35 = v33 + 0x2000;
        v36 = v33 + 0x1FFF;
        if (v35 > v32)
          v32 = v36;
        if (v32 >= a2)
        {
          v43 = __si_assert_copy_extra_268();
          v44 = v43;
          v45 = "";
          if (v43)
            v45 = v43;
          __message_assert(v43, "qsort_oids.c", 24, "right < count", v45, v47, v48);
          free(v44);
          if (__valid_fs(-1))
            v46 = 2989;
          else
            v46 = 3072;
          *(_DWORD *)v46 = -559038737;
          abort();
        }
      }
      --v19;
    }
    while (v19);
  }
  free(v16);
  v37 = *(_QWORD *)(a1 + 48);
  if (v31 >= v32)
  {
    v38 = v31;
  }
  else
  {
    v38 = v31;
    do
    {
      v39 = *(_QWORD *)(a1 + 56);
      while (1)
      {
        v40 = *(_QWORD *)(v37 + 8 * v38);
        if (v40 >= v39)
          break;
        if (++v38 >= v32)
        {
          if (v32 <= v31 + 1)
            v38 = v31 + 1;
          else
            v38 = v32;
          goto LABEL_79;
        }
      }
      if (v38 < v32)
      {
        while (1)
        {
          v41 = *(_QWORD *)(v37 + 8 * v32);
          if (v41 <= v39)
            break;
          if (v38 >= --v32)
            goto LABEL_79;
        }
        *(_QWORD *)(v37 + 8 * v32) = v40;
        *(_QWORD *)(v37 + 8 * v38++) = v41;
        --v32;
      }
      v31 = v38;
    }
    while (v38 < v32);
  }
LABEL_79:
  if (*(_QWORD *)(v37 + 8 * v38) >= *(_QWORD *)(a1 + 56))
    return v38;
  else
    return v38 + 1;
}

uint64_t index_comp_8440(_QWORD *a1, _QWORD *a2)
{
  unsigned int v2;

  if (*a1 >= *a2)
    v2 = 0;
  else
    v2 = -1;
  if (*a1 > *a2)
    return 1;
  else
    return v2;
}

uint64_t neutralize_oid_t(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v5 = *a4;
  v6 = *a5;
  while (1)
  {
    if (v5 < 0x2000)
    {
      while (*(_QWORD *)(a1 + 8 * v5) <= a3)
      {
        if (++v5 == 0x2000)
        {
          v7 = 0x2000;
          goto LABEL_7;
        }
      }
    }
    v7 = v5;
LABEL_7:
    if (v6 < 0x2000)
    {
      while (*(_QWORD *)(a2 + 8 * v6) >= a3)
      {
        if (++v6 == 0x2000)
        {
          v5 = v7;
          goto LABEL_15;
        }
      }
    }
    v8 = v6;
    if (v7 == 0x2000 || v6 == 0x2000)
      break;
    v9 = *(_QWORD *)(a2 + 8 * v6);
    *(_QWORD *)(a2 + 8 * v8) = *(_QWORD *)(a1 + 8 * v7);
    *(_QWORD *)(a1 + 8 * v7) = v9;
    v5 = v7 + 1;
    v6 = v8 + 1;
    if (v7 > 8190 || v8 >= 0x1FFF)
      goto LABEL_15;
  }
  v5 = v7;
LABEL_15:
  *a4 = v5;
  *a5 = v6;
  if (v6 == 0x2000 && v5 == 0x2000)
    return 2;
  else
    return v5 != 0x2000;
}

uint64_t ___qsort_oid_t_block_invoke(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  unsigned int v3;

  if (*a2 == *a3)
    v3 = 0;
  else
    v3 = -1;
  if (*a2 > *a3)
    return 1;
  else
    return v3;
}

uint64_t termIDStoreInit(int8x16_t *a1, uint64_t a2, int a3, char a4, int a5, void *a6)
{
  unint64_t v12;
  CFIndex v13;
  __CFBitVector *Mutable;
  _BOOL4 v15;
  uint64_t result;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  char *v20;
  char *v21;
  const char *v22;
  int8x16_t v23;
  _BOOL4 v24;
  char *v25;
  const char *v26;
  uint64_t v27;
  char *v28;
  char *v29;
  const char *v30;
  uint64_t v31;

  if (!a1[276].i64[1])
  {
    v12 = *MEMORY[0x1E0C85AD8];
    v13 = 0x40000000uLL / *MEMORY[0x1E0C85AD8];
    a1[276].i64[1] = v13;
    a1[276].i64[0] = 0;
    if (v12 <= 0x40000000)
    {
      Mutable = CFBitVectorCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v13);
      a1[277].i64[0] = (uint64_t)Mutable;
      CFBitVectorSetCount(Mutable, v13);
      if (!a1[277].i64[0])
      {
        v28 = __si_assert_copy_extra(0);
        v29 = v28;
        v30 = "";
        if (v28)
          v30 = v28;
        __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 47, "bv->_cfbv", v30);
        free(v29);
        if (__valid_fs(-1))
          v31 = 2989;
        else
          v31 = 3072;
        *(_DWORD *)v31 = -559038737;
        abort();
      }
    }
    else
    {
      a1[277].i64[0] = 0;
    }
  }
  bzero(a1, 0x1138uLL);
  if (a3)
  {
    v15 = storageInit((uint64_t)a1, 0x2000, 8uLL, a2, 1, 0, a4, a5, a6);
    result = 0;
    if (!v15)
      return result;
    v17 = a1[14].u64[1];
    v18 = (unint64_t)a1[14].i64[0] >> 3;
    a1[275].i32[3] = v18;
    v19 = v17 >> 3;
    a1[275].i32[2] = v19;
    if (!(_DWORD)v19)
    {
      v25 = __si_assert_copy_extra(0);
      v21 = v25;
      v26 = "";
      if (v25)
        v26 = v25;
      __message_assert("%s:%u: failed assertion '%s' %s ", "TermIdStore.c", 37, "getNum(ts->termIdCount)", v26);
LABEL_18:
      free(v21);
      if (__valid_fs(-1))
        v27 = 2989;
      else
        v27 = 3072;
      *(_DWORD *)v27 = -559038737;
      abort();
    }
    if (v18 < v19)
    {
      v20 = __si_assert_copy_extra(0);
      v21 = v20;
      v22 = "";
      if (v20)
        v22 = v20;
      __message_assert("%s:%u: failed assertion '%s' %s ", "TermIdStore.c", 38, "getNum(ts->termIdSize) >= getNum(ts->termIdCount)", v22);
      goto LABEL_18;
    }
  }
  else
  {
    v23 = (int8x16_t)vshll_n_u32((uint32x2_t)a1[275].u64[1], 3uLL);
    a1[14] = vextq_s8(v23, v23, 8uLL);
    v24 = storageInit((uint64_t)a1, 0x2000, 8uLL, a2, 0, 0, a4, a5, a6);
    result = 0;
    if (!v24)
      return result;
  }
  return 1;
}

double termIdStoreDestroy(uint64_t a1)
{
  const void *v2;
  double result;

  storageClose(a1);
  v2 = *(const void **)(a1 + 4432);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 4432) = 0;
  }
  result = 0.0;
  *(_OWORD *)(a1 + 4416) = 0u;
  return result;
}

uint64_t termIdStoreHeaderStore(uint64_t result, _BYTE **a2)
{
  uint64_t v2;
  uint64_t v3;
  _BYTE *v4;
  uint64_t v5;
  _BYTE *v6;
  unsigned int v7;
  uint64_t v8;
  char *v9;
  char *v10;
  const char *v11;
  char *v12;
  const char *v13;
  uint64_t v14;

  v2 = *(unsigned int *)(result + 4408);
  if (*(_QWORD *)(result + 232) != 8 * v2)
  {
    v9 = __si_assert_copy_extra(0);
    v10 = v9;
    v11 = "";
    if (v9)
      v11 = v9;
    __message_assert("%s:%u: failed assertion '%s' %s ", "TermIdStore.c", 81, "ts->store._windows._freeRegion == ((offset_t)getNum(ts->termIdCount)) * sizeof(disk_TermData)", v11);
LABEL_28:
    free(v10);
    if (__valid_fs(-1))
      v14 = 2989;
    else
      v14 = 3072;
    *(_DWORD *)v14 = -559038737;
    abort();
  }
  v3 = *(_QWORD *)(result + 224) >> 3;
  *(_DWORD *)(result + 4412) = v3;
  if (v2 > v3)
  {
    v12 = __si_assert_copy_extra(0);
    v10 = v12;
    v13 = "";
    if (v12)
      v13 = v12;
    __message_assert("%s:%u: failed assertion '%s' %s ", "TermIdStore.c", 83, "getNum(ts->termIdSize) >= getNum(ts->termIdCount)", v13);
    goto LABEL_28;
  }
  v4 = *a2;
  if (v2 >> 28)
  {
    *v4 = v2 | 0x80;
    v4[1] = (v2 >> 7) | 0x80;
    v4[2] = (v2 >> 14) | 0x80;
    v4[3] = (v2 >> 21) | 0x80;
    v4[4] = v2 >> 28;
    v5 = 5;
  }
  else if ((v2 & 0xFE00000) != 0)
  {
    *v4 = v2 | 0x80;
    v4[1] = (v2 >> 7) | 0x80;
    v4[2] = (v2 >> 14) | 0x80;
    v4[3] = (v2 & 0xFE00000) >> 21;
    v5 = 4;
  }
  else if ((v2 & 0x1FC000) != 0)
  {
    *v4 = v2 | 0x80;
    v4[1] = (v2 >> 7) | 0x80;
    v4[2] = (v2 & 0x1FC000) >> 14;
    v5 = 3;
  }
  else if ((v2 & 0x3F80) != 0)
  {
    *v4 = v2 | 0x80;
    v4[1] = (unsigned __int16)(v2 & 0x3F80) >> 7;
    v5 = 2;
  }
  else
  {
    *v4 = v2;
    v5 = 1;
  }
  v6 = &(*a2)[v5];
  *a2 = v6;
  v7 = *(_DWORD *)(result + 4412);
  if (v7 >> 28)
  {
    *v6 = v7 | 0x80;
    v6[1] = (v7 >> 7) | 0x80;
    v6[2] = (v7 >> 14) | 0x80;
    v6[3] = (v7 >> 21) | 0x80;
    v6[4] = v7 >> 28;
    v8 = 5;
  }
  else if ((v7 & 0xFE00000) != 0)
  {
    *v6 = v7 | 0x80;
    v6[1] = (v7 >> 7) | 0x80;
    v6[2] = (v7 >> 14) | 0x80;
    v6[3] = (v7 & 0xFE00000) >> 21;
    v8 = 4;
  }
  else if ((v7 & 0x1FC000) != 0)
  {
    *v6 = v7 | 0x80;
    v6[1] = (v7 >> 7) | 0x80;
    v6[2] = (v7 & 0x1FC000) >> 14;
    v8 = 3;
  }
  else if ((v7 & 0x3F80) != 0)
  {
    *v6 = v7 | 0x80;
    v6[1] = (unsigned __int16)(v7 & 0x3F80) >> 7;
    v8 = 2;
  }
  else
  {
    *v6 = v7;
    v8 = 1;
  }
  *a2 += v8;
  return result;
}

uint64_t restoreVInt32_8478(char **a1)
{
  char *v1;
  uint64_t v2;
  uint64_t v3;
  int v4;
  int v5;
  uint64_t v6;
  int v7;
  int v9;
  uint64_t v10;
  char *v11;
  char *v12;
  const char *v13;
  uint64_t v14;

  v1 = *a1;
  v2 = **a1;
  if ((**a1 & 0x80000000) == 0)
  {
    v3 = 1;
    goto LABEL_10;
  }
  v4 = v1[1];
  if ((v1[1] & 0x80000000) == 0)
  {
    v2 = v2 & 0x7F | (v4 << 7);
    v3 = 2;
    goto LABEL_10;
  }
  v5 = v1[2];
  if ((v1[2] & 0x80000000) == 0)
  {
    v6 = ((v4 & 0x7F) << 7) | (v5 << 14) | (v2 & 0x7F);
    v3 = 3;
LABEL_9:
    v2 = v6;
    goto LABEL_10;
  }
  v7 = v1[3];
  if ((v1[3] & 0x80000000) == 0)
  {
    v6 = ((v5 & 0x7F) << 14) | (v7 << 21) | ((v4 & 0x7F) << 7) | (v2 & 0x7F);
    v3 = 4;
    goto LABEL_9;
  }
  v9 = v1[4];
  if (v9 < 0)
  {
    v11 = __si_assert_copy_extra(0);
    v12 = v11;
    v13 = "";
    if (v11)
      v13 = v11;
    __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t", "VIntUtils.h", 341, "(b4 & 0x80) == 0", v13);
    free(v12);
    if (__valid_fs(-1))
      v14 = 2989;
    else
      v14 = 3072;
    *(_DWORD *)v14 = -559038737;
    abort();
  }
  v10 = ((v7 & 0x7F) << 21) | (v9 << 28) | ((v5 & 0x7F) << 14) | ((v4 & 0x7F) << 7) | (v2 & 0x7F);
  v3 = 5;
  v2 = v10;
LABEL_10:
  *a1 = &v1[v3];
  return v2;
}

uint64_t termIdStoreShadow(uint64_t a1, uint64_t a2, char a3, _DWORD *a4)
{
  int v8;
  unint64_t v9;
  void *v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unsigned int v19;
  CFIndex v20;
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;
  size_t v24;
  CFIndex v25;
  CFIndex v26;
  const __CFBitVector *v27;
  __CFBitVector *MutableCopy;
  __CFBitVector *v29;
  const void *v30;
  int v31;
  NSObject *v32;
  int v33;
  const char *v34;
  int v36;
  char *v37;
  char *v38;
  const char *v39;
  uint64_t v40;
  char *v41;
  char *v42;
  const char *v43;
  uint64_t v44;
  char *v45;
  const char *v46;
  const __CFAllocator *allocator;
  unint64_t v48;
  _DWORD *v49;
  _DWORD *v50;
  unsigned int __fd;
  uint64_t v52;
  uint64_t v53;
  uint8_t buf[4];
  const char *v55;
  __int16 v56;
  int v57;
  __int16 v58;
  int v59;
  uint64_t v60;

  v60 = *MEMORY[0x1E0C80C00];
  v8 = *(_DWORD *)(a1 + 4408);
  v9 = *MEMORY[0x1E0C85AD8];
  v10 = malloc_type_malloc(*MEMORY[0x1E0C85AD8], 0xFC00555DuLL);
  if (!v10)
  {
    v37 = __si_assert_copy_extra(0);
    v38 = v37;
    v39 = "";
    if (v37)
      v39 = v37;
    __message_assert("%s:%u: failed assertion '%s' %s ", "TermIdStore.c", 109, "readBuffer", v39);
    free(v38);
    if (__valid_fs(-1))
      v40 = 2989;
    else
      v40 = 3072;
    *(_DWORD *)v40 = -559038737;
    abort();
  }
  v11 = v10;
  v12 = *(unsigned int *)(a1 + 4408);
  v13 = *(_QWORD *)(a1 + 216);
  v53 = 0;
  v49 = (_DWORD *)v13;
  v14 = _fd_acquire_fd(v13, &v53);
  v52 = 0;
  v50 = (_DWORD *)a2;
  v15 = _fd_acquire_fd(a2, &v52);
  v16 = v15;
  __fd = v14;
  if (v14 == -1 || (_DWORD)v15 == -1)
  {
    v19 = *__error();
    if (v19)
      v18 = v19;
    else
      v18 = 0xFFFFFFFFLL;
    goto LABEL_50;
  }
  v17 = v9 + (8 * v8) - 1;
  if (v9 > v17)
  {
LABEL_5:
    if (prot_fsync(v16, 0))
      v18 = *__error();
    else
      v18 = 0;
    goto LABEL_50;
  }
  v20 = 0;
  v21 = 0;
  v22 = 8 * v12;
  allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v48 = v17 / v9;
  while ((a3 & 1) == 0
       && (*(_QWORD *)(a1 + 4416) <= v20 || !CFBitVectorGetBitAtIndex(*(CFBitVectorRef *)(a1 + 4432), v20)))
  {
LABEL_29:
    v20 = ++v21;
    if (v48 <= v21)
      goto LABEL_5;
  }
  v23 = *MEMORY[0x1E0C85AD8] * v20;
  if (v23 + *MEMORY[0x1E0C85AD8] <= v22)
    v24 = *MEMORY[0x1E0C85AD8];
  else
    v24 = v22 - v23;
  if (*a4 == 1 || *a4 == -1 && (a3 & 1) != 0)
  {
LABEL_44:
    v18 = 89;
    goto LABEL_50;
  }
  if (prot_pread(__fd, v11, v24, *MEMORY[0x1E0C85AD8] * v20) == -1)
  {
    v31 = *__error();
    v32 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      goto LABEL_49;
    v33 = *__error();
    *(_DWORD *)buf = 136315650;
    v55 = "termIdStoreShadow";
    v56 = 1024;
    v57 = 137;
    v58 = 1024;
    v59 = v33;
    v34 = "%s:%d: pread err: %d";
    goto LABEL_52;
  }
  if (*a4 == 1 || *a4 == -1 && (a3 & 1) != 0)
    goto LABEL_44;
  if (prot_pwrite_guarded(v16, (uint64_t)&v52, (uint64_t)v11, v24, v23) != -1)
  {
    v25 = *(_QWORD *)(a1 + 4424);
    if (v25 <= v20)
    {
      if (v25)
        v26 = *(_QWORD *)(a1 + 4424);
      else
        v26 = 32;
      while (1)
      {
        v26 *= 2;
        if (v26 > v20)
          break;
        if (v26 <= v25)
        {
          v41 = __si_assert_copy_extra(0);
          v42 = v41;
          v43 = "";
          if (v41)
            v43 = v41;
          __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 111, "newCapacity > bv->capacity", v43);
          goto LABEL_62;
        }
      }
      v27 = *(const __CFBitVector **)(a1 + 4432);
      if (v27)
        MutableCopy = CFBitVectorCreateMutableCopy(allocator, v26, v27);
      else
        MutableCopy = CFBitVectorCreateMutable(allocator, v26);
      v29 = MutableCopy;
      if (!MutableCopy)
      {
        v45 = __si_assert_copy_extra(0);
        v42 = v45;
        v46 = "";
        if (v45)
          v46 = v45;
        __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 115, "newBV", v46);
LABEL_62:
        free(v42);
        if (__valid_fs(-1))
          v44 = 2989;
        else
          v44 = 3072;
        *(_DWORD *)v44 = -559038737;
        abort();
      }
      CFBitVectorSetCount(MutableCopy, v26);
      v30 = *(const void **)(a1 + 4432);
      if (v30)
        CFRelease(v30);
      *(_QWORD *)(a1 + 4432) = v29;
      *(_QWORD *)(a1 + 4424) = v26;
    }
    if (*(_QWORD *)(a1 + 4416) <= v20)
      *(_QWORD *)(a1 + 4416) = v20 + 1;
    CFBitVectorSetBitAtIndex(*(CFMutableBitVectorRef *)(a1 + 4432), v20, 0);
    goto LABEL_29;
  }
  v31 = *__error();
  v32 = _SILogForLogForCategory(0);
  if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
    goto LABEL_49;
  v36 = *__error();
  *(_DWORD *)buf = 136315650;
  v55 = "termIdStoreShadow";
  v56 = 1024;
  v57 = 166;
  v58 = 1024;
  v59 = v36;
  v34 = "%s:%d: pwrite err: %d";
LABEL_52:
  _os_log_error_impl(&dword_1B8270000, v32, OS_LOG_TYPE_ERROR, v34, buf, 0x18u);
LABEL_49:
  *__error() = v31;
  v18 = *__error();
  if (!(_DWORD)v18)
    goto LABEL_5;
LABEL_50:
  _fd_release_fd(v50, v16, 0, v52);
  _fd_release_fd(v49, __fd, 0, v53);
  free(v11);
  return v18;
}

uint64_t posreadunlock(pthread_rwlock_t *a1)
{
  uint64_t result;
  char *v2;
  char *v3;
  const char *v4;
  uint64_t v5;

  result = pthread_rwlock_unlock(a1);
  if ((_DWORD)result)
  {
    v2 = __si_assert_copy_extra_268();
    v3 = v2;
    v4 = "";
    if (v2)
      v4 = v2;
    __message_assert(v2, "poslock.c", 21, "result==0", v4);
    free(v3);
    if (__valid_fs(-1))
      v5 = 2989;
    else
      v5 = 3072;
    *(_DWORD *)v5 = -559038737;
    abort();
  }
  return result;
}

void si_init_indexing_zone()
{
  if (si_init_indexing_zone_indexOnce != -1)
    dispatch_once(&si_init_indexing_zone_indexOnce, &__block_literal_global_8580);
}

void __si_init_indexing_zone_block_invoke()
{
  indexingZone = (uint64_t)malloc_create_zone(0x10000uLL, 0);
  malloc_set_zone_name((malloc_zone_t *)indexingZone, "SIIndexingMallocZone");
}

int *updateItemRecentSpotlightEngagementData(int *a1, uint64_t *a2, const char *a3, int a4, double a5)
{
  updateItemRecentEngagementData(a1, a2, a3, a4, "_kMDItemRecentSpotlightEngagementQueries", "_kMDItemRecentSpotlightEngagementDates", "_kMDItemRecentSpotlightEngagementRenderPositions", 1, a5);
  return updateItemRecentEngagementData(a1, a2, a3, a4, "_kMDItemRecentSpotlightEngagementQueriesNonUnique", "_kMDItemRecentSpotlightEngagementDatesNonUnique", "_kMDItemRecentSpotlightEngagementRenderPositionsNonUnique", 0, a5);
}

int *updateItemRecentEngagementData(int *a1, uint64_t *a2, const char *a3, int a4, char *a5, char *a6, char *a7, int a8, double a9)
{
  int v12;
  int *v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v20;
  char *v21;
  size_t v22;
  char *v23;
  size_t v24;
  uint64_t v25;
  __n128 v26;
  uint64_t i;
  uint64_t *v28;
  unsigned int v29;
  __n128 v30;
  char *v31;
  int v32;
  NSObject *v33;
  uint64_t v34;
  size_t v35;
  uint64_t v36;
  char *v37;
  uint64_t v38;
  const void *v39;
  unsigned int v40;
  uint64_t v41;
  char *v42;
  int v43;
  __n128 v44;
  int v45;
  int v46;
  NSObject *v47;
  _BOOL4 v48;
  __n128 v49;
  NSObject *v50;
  int *v51;
  uint64_t *v52;
  char *v53;
  int v54;
  int v55;
  NSObject *v56;
  int v57;
  NSObject *v58;
  __n128 v59;
  int v60;
  NSObject *v61;
  uint64_t v62;
  const char *v63;
  const char *v64;
  unint64_t v65;
  int v66;
  int v67;
  uint64_t v69;
  int *v70;
  int v71;
  int v72;
  NSObject *v73;
  NSObject *v74;
  char *v75;
  int v76;
  _QWORD v77[2];
  int *v78;
  char *v79;
  uint64_t *v80;
  char *v81;
  char *v82;
  size_t v83;
  char *v84;
  char *v85;
  unint64_t v86;
  const void *v87;
  unint64_t v88;
  const void *v89;
  unint64_t v90;
  const char *v91;
  int v92;
  double v93;
  int v94;
  const char *v95;
  __int16 v96;
  int v97;
  __int16 v98;
  double v99;
  __int16 v100;
  int v101;
  __int16 v102;
  uint64_t v103;
  __int16 v104;
  char *v105;
  __int16 v106;
  uint64_t v107;
  _DWORD v108[8];
  uint64_t v109;
  _QWORD v110[10];
  _DWORD v111[8];
  uint64_t v112;
  _QWORD v113[14];

  v84 = a6;
  v12 = a4;
  v16 = a1;
  v113[11] = *MEMORY[0x1E0C80C00];
  v93 = a9;
  v92 = a4;
  db_validate_obj(a1);
  v17 = (_QWORD *)*a2;
  if (!*(_QWORD *)*a2)
    return db_validate_obj(v16);
  if (!a3)
  {
    db_delete_field(v16, a2, a5);
    db_delete_field(v16, a2, v84);
    db_delete_field(v16, a2, a7);
    return db_validate_obj(v16);
  }
  v81 = a7;
  v83 = strlen(a3);
  v90 = 0;
  v91 = 0;
  memset(v113, 0, 80);
  v112 = 0;
  memset(v111, 0, sizeof(v111));
  v80 = a2;
  v82 = (char *)a3;
  if (db_get_field(v16, (uint64_t)v17, a5, &v90, &v91))
    goto LABEL_4;
  if (*(_WORD *)v90 != 11 || (*(_WORD *)(v90 + 2) & 0x20) == 0)
  {
    db_delete_field(v16, a2, a5);
    v18 = 0;
    v90 = 0;
    v91 = 0;
    goto LABEL_9;
  }
  v62 = *(unsigned int *)(v90 + 8);
  if (!(_DWORD)v62)
  {
LABEL_4:
    v18 = 0;
LABEL_9:
    v20 = -1;
    v21 = v84;
    goto LABEL_10;
  }
  v78 = v16;
  v79 = a5;
  v18 = 0;
  v63 = v91;
  v64 = &v91[v62];
  v20 = -1;
  do
  {
    v65 = v18;
    v113[v18] = v63;
    v66 = strlen(v63);
    v67 = v66;
    if (a8 && v66 == (_DWORD)v83 && !strcmp(v63, v82))
      v20 = v18;
    v111[v18] = v67;
    v63 += (v67 + 1);
    ++v18;
  }
  while (v63 < v64 && v65 < 9);
  v21 = v84;
  if (v63 >= v64)
  {
    v16 = v78;
    a5 = v79;
    a2 = v80;
  }
  else
  {
    v16 = v78;
    a5 = v79;
    a2 = v80;
    db_delete_field(v78, v80, v79);
    v18 = 0;
    v90 = 0;
    v91 = 0;
  }
LABEL_10:
  v88 = 0;
  v89 = 0;
  memset(v110, 0, sizeof(v110));
  if (!db_get_field(v16, *a2, v21, &v88, &v89))
  {
    if (*(_WORD *)v88 == 12 && (*(_WORD *)(v88 + 2) & 0x20) != 0 && (v22 = *(unsigned int *)(v88 + 8), v18 == v22 >> 3))
    {
      memcpy(v110, v89, v22);
    }
    else
    {
      db_delete_field(v16, a2, v21);
      v88 = 0;
      v89 = 0;
      if (v90)
      {
        db_delete_field(v16, a2, a5);
        v18 = 0;
        v90 = 0;
        v91 = 0;
      }
    }
  }
  v86 = 0;
  v87 = 0;
  v109 = 0;
  memset(v108, 0, sizeof(v108));
  v23 = v81;
  if (!db_get_field(v16, *a2, v81, &v86, &v87))
  {
    if (*(_WORD *)v86 == 6 && (*(_WORD *)(v86 + 2) & 0x20) != 0 && (v24 = *(unsigned int *)(v86 + 8), v18 == v24 >> 2))
    {
      memcpy(v108, v87, v24);
    }
    else
    {
      db_delete_field(v16, a2, v81);
      v86 = 0;
      v87 = 0;
      if (v90)
      {
        db_delete_field(v16, a2, a5);
        v18 = 0;
        v90 = 0;
        v91 = 0;
      }
      if (v88)
      {
        db_delete_field(v16, a2, v21);
        v88 = 0;
        v89 = 0;
      }
    }
  }
  v85 = 0;
  if (v83 > 2)
    v25 = asprintf(&v85, "%c..%c");
  else
    v25 = asprintf(&v85, "%s");
  if (v20 == -1 && (unint64_t)v18 >= 0xA)
  {
    if (v18 < 2)
    {
      v20 = 0;
    }
    else
    {
      v20 = 0;
      for (i = 1; i != v18; ++i)
      {
        v26.n128_u64[0] = v110[i];
        if (v26.n128_f64[0] < *(double *)&v110[v20])
          v20 = i;
      }
      if (v20 == -1)
        goto LABEL_39;
    }
    LODWORD(v78) = v12;
    v79 = a5;
    v77[1] = v77;
    v34 = v111[v20];
    v35 = (*(_DWORD *)(v90 + 8) - v34 + v83);
    MEMORY[0x1E0C80A78](v25);
    v37 = (char *)v77 - v36;
    bzero((char *)v77 - v36, v35);
    v38 = v113[v20];
    v39 = (const void *)(v38 + v34 + 1);
    v40 = (_DWORD)v91 + *(_DWORD *)(v90 + 8) - (_DWORD)v39;
    v41 = (v38 - (_DWORD)v91);
    if ((_DWORD)v41)
      memcpy(v37, v91, (v38 - (_DWORD)v91));
    v42 = &v37[v41];
    v43 = v83;
    memcpy(v42, v82, (v83 + 1));
    if (v40)
      memcpy(&v42[v43 + 1], v39, v40);
    v76 = v35;
    a5 = v79;
    a2 = v80;
    v45 = db_add_field(v16, (_DWORD **)v80, 5u, v79, 0, 0x20u, 11, (unsigned __int8 *)v37, v44, v76);
    v12 = (int)v78;
    if (v45)
    {
      v46 = *__error();
      v47 = _SILogForLogForCategory(7);
      v48 = os_log_type_enabled(v47, OS_LOG_TYPE_ERROR);
      v21 = v84;
      v23 = v81;
      if (v48)
      {
        v94 = 136315650;
        v95 = "updateItemRecentEngagementData";
        v96 = 1024;
        v97 = 206;
        v98 = 2080;
        v99 = *(double *)&a5;
        _os_log_error_impl(&dword_1B8270000, v47, OS_LOG_TYPE_ERROR, "%s:%d: Failed adding recent engagement queries to %s", (uint8_t *)&v94, 0x1Cu);
      }
      goto LABEL_59;
    }
    v21 = v84;
    v23 = v81;
LABEL_56:
    *(double *)&v110[v20] = a9;
    if (!db_add_field(v16, (_DWORD **)a2, 5u, v21, 0, 0x20u, 12, (unsigned __int8 *)v110, v26, 8 * (int)v18))
    {
      v108[v20] = v12;
      v54 = db_add_field(v16, (_DWORD **)a2, 5u, v23, 0, 0x20u, 6, (unsigned __int8 *)v108, v49, 4 * (int)v18);
      v55 = *__error();
      v56 = _SILogForLogForCategory(7);
      v57 = v12;
      v58 = v56;
      if (!v54)
      {
        if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
        {
          v69 = *(_QWORD *)*a2;
          v94 = 136316674;
          v95 = v85;
          v96 = 1024;
          v97 = v83;
          v98 = 2048;
          v99 = a9;
          v100 = 1024;
          v101 = v57;
          v102 = 2048;
          v103 = v20;
          v104 = 2080;
          v105 = a5;
          v106 = 2048;
          v107 = v69;
          _os_log_impl(&dword_1B8270000, v58, OS_LOG_TYPE_DEFAULT, "[Engagement Data] Inserted query \"%s\" (%d chars), engagement time: %f, render pos: %u into position %ld of %s/Dates/Positions for oid: %lld", (uint8_t *)&v94, 0x40u);
        }
        *__error() = v55;
        goto LABEL_62;
      }
      if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
      {
        v94 = 136315650;
        v95 = "updateItemRecentEngagementData";
        v96 = 1024;
        v97 = 231;
        v98 = 2080;
        v99 = *(double *)&v81;
        _os_log_error_impl(&dword_1B8270000, v58, OS_LOG_TYPE_ERROR, "%s:%d: Failed replace recent engagement render positions to %s", (uint8_t *)&v94, 0x1Cu);
      }
      *__error() = v55;
      v23 = v81;
      goto LABEL_60;
    }
    v46 = *__error();
    v50 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
    {
      v94 = 136315650;
      v95 = "updateItemRecentEngagementData";
      v96 = 1024;
      v97 = 219;
      v98 = 2080;
      v99 = *(double *)&v21;
      _os_log_error_impl(&dword_1B8270000, v50, OS_LOG_TYPE_ERROR, "%s:%d: Failed replace recent engagement dates to %s", (uint8_t *)&v94, 0x1Cu);
    }
LABEL_59:
    *__error() = v46;
    a2 = v80;
LABEL_60:
    db_delete_field(v16, a2, a5);
    db_delete_field(v16, a2, v21);
    v51 = v16;
    v52 = a2;
    v53 = v23;
    goto LABEL_61;
  }
  if (v20 != -1)
    goto LABEL_56;
LABEL_39:
  v28 = a2;
  if (v18)
    v29 = 2;
  else
    v29 = 1;
  if (db_add_field(v16, (_DWORD **)v28, v29, a5, 0, 0x20u, 11, (unsigned __int8 *)v82, v26, (int)v83 + 1))
  {
    v31 = a5;
    v32 = *__error();
    v33 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
    {
      v94 = 136315650;
      v95 = "updateItemRecentEngagementData";
      v96 = 1024;
      v97 = 156;
      v98 = 2080;
      v99 = *(double *)&v31;
      _os_log_error_impl(&dword_1B8270000, v33, OS_LOG_TYPE_ERROR, "%s:%d: Failed adding recent engagement queries to %s", (uint8_t *)&v94, 0x1Cu);
    }
    *__error() = v32;
    goto LABEL_62;
  }
  if (db_add_field(v16, (_DWORD **)v28, v29, v21, 0, 0x20u, 12, (unsigned __int8 *)&v93, v30, 8))
  {
    v60 = *__error();
    v61 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
    {
      v94 = 136315650;
      v95 = "updateItemRecentEngagementData";
      v96 = 1024;
      v97 = 166;
      v98 = 2080;
      v99 = *(double *)&v21;
      _os_log_error_impl(&dword_1B8270000, v61, OS_LOG_TYPE_ERROR, "%s:%d: Failed adding recent engagement dates to %s", (uint8_t *)&v94, 0x1Cu);
    }
    *__error() = v60;
    v51 = v16;
    v52 = v80;
    v53 = a5;
  }
  else
  {
    v70 = v16;
    v71 = db_add_field(v16, (_DWORD **)v28, v29, v81, 0, 0x20u, 6, (unsigned __int8 *)&v92, v59, 4);
    v72 = *__error();
    v73 = _SILogForLogForCategory(7);
    v74 = v73;
    if (!v71)
    {
      if (os_log_type_enabled(v73, OS_LOG_TYPE_DEFAULT))
      {
        v75 = *(char **)*v80;
        v94 = 136316418;
        v95 = v85;
        v96 = 1024;
        v97 = v83;
        v98 = 2048;
        v99 = v93;
        v100 = 1024;
        v101 = v92;
        v102 = 2080;
        v103 = (uint64_t)a5;
        v104 = 2048;
        v105 = v75;
        _os_log_impl(&dword_1B8270000, v74, OS_LOG_TYPE_DEFAULT, "[Engagement Data] Added query \"%s\" (%d chars), engagement time: %f, render pos: %u to %s/Dates/Positions for oid: %lld", (uint8_t *)&v94, 0x36u);
      }
      *__error() = v72;
      v16 = v70;
      goto LABEL_62;
    }
    if (os_log_type_enabled(v73, OS_LOG_TYPE_ERROR))
    {
      v94 = 136315650;
      v95 = "updateItemRecentEngagementData";
      v96 = 1024;
      v97 = 177;
      v98 = 2080;
      v99 = *(double *)&v81;
      _os_log_error_impl(&dword_1B8270000, v74, OS_LOG_TYPE_ERROR, "%s:%d: Failed adding recent engagement render positions to %s", (uint8_t *)&v94, 0x1Cu);
    }
    *__error() = v72;
    v16 = v70;
    db_delete_field(v70, v80, a5);
    v51 = v70;
    v52 = v80;
    v53 = v21;
  }
LABEL_61:
  db_delete_field(v51, v52, v53);
LABEL_62:
  free(v85);
  return db_validate_obj(v16);
}

int *updateItemRecentOutOfSpotlightEngagementData(int *a1, uint64_t *a2, double a3)
{
  _QWORD *v6;
  __n128 v7;
  unsigned int v8;
  int v9;
  int v10;
  NSObject *v11;
  NSObject *v12;
  uint64_t v14;
  const char *v15;
  NSObject *v16;
  uint32_t v17;
  size_t v18;
  size_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  NSObject *v23;
  NSObject *v24;
  uint64_t v25;
  unint64_t v26;
  void *__src;
  double v28;
  uint8_t buf[4];
  double v30;
  __int16 v31;
  _BYTE v32[18];
  __int16 v33;
  uint64_t v34;
  _OWORD __dst[10];
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v28 = a3;
  db_validate_obj(a1);
  v6 = (_QWORD *)*a2;
  if (!*(_QWORD *)*a2)
    return db_validate_obj(a1);
  if (a3 == 0.0)
  {
    db_delete_field(a1, a2, "_kMDItemRecentOutOfSpotlightEngagementDates");
    return db_validate_obj(a1);
  }
  v26 = 0;
  __src = 0;
  memset(__dst, 0, sizeof(__dst));
  if (db_get_field(a1, (uint64_t)v6, "_kMDItemRecentOutOfSpotlightEngagementDates", &v26, &__src))
    goto LABEL_7;
  if (*(_WORD *)v26 != 12 || (*(_WORD *)(v26 + 2) & 0x20) == 0)
  {
    db_delete_field(a1, a2, "_kMDItemRecentOutOfSpotlightEngagementDates");
    v26 = 0;
    __src = 0;
LABEL_7:
    v8 = 1;
    goto LABEL_8;
  }
  v18 = *(unsigned int *)(v26 + 8);
  memcpy(__dst, __src, v18);
  if (!(_DWORD)v18)
    goto LABEL_7;
  v19 = v18 - 1;
  if (v18 - 1 >= 0x98)
  {
    v20 = 0;
    v21 = 1;
    do
    {
      v7.n128_u64[0] = *((_QWORD *)__dst + v21);
      if (v7.n128_f64[0] < *((double *)__dst + v20))
        v20 = v21;
      ++v21;
    }
    while (v21 - (v19 >> 3) != 1);
    if (v20 != -1)
    {
      *((double *)__dst + v20) = a3;
      v22 = db_add_field(a1, (_DWORD **)a2, 5u, "_kMDItemRecentOutOfSpotlightEngagementDates", 0, 0x20u, 12, (unsigned __int8 *)__dst, v7, (v19 & 0xFFFFFFF8) + 8);
      v10 = *__error();
      v23 = _SILogForLogForCategory(7);
      v24 = v23;
      if (v22)
      {
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          v30 = COERCE_DOUBLE("updateRecentEngagementDates");
          v31 = 1024;
          *(_DWORD *)v32 = 315;
          *(_WORD *)&v32[4] = 2080;
          *(_QWORD *)&v32[6] = "_kMDItemRecentOutOfSpotlightEngagementDates";
          _os_log_error_impl(&dword_1B8270000, v24, OS_LOG_TYPE_ERROR, "%s:%d: Failed to replace Out-of-Spotlight engagement date to %s", buf, 0x1Cu);
        }
        *__error() = v10;
        db_delete_field(a1, a2, "_kMDItemRecentOutOfSpotlightEngagementDates");
        return db_validate_obj(a1);
      }
      if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
        goto LABEL_15;
      v25 = *(_QWORD *)*a2;
      *(_DWORD *)buf = 134218754;
      v30 = a3;
      v31 = 2048;
      *(_QWORD *)v32 = v20;
      *(_WORD *)&v32[8] = 2080;
      *(_QWORD *)&v32[10] = "_kMDItemRecentOutOfSpotlightEngagementDates";
      v33 = 2048;
      v34 = v25;
      v15 = "[Engagement Data] Inserted Out-of-Spotlight engagement date: %f into position %ld of %s for oid: %lld";
      v16 = v24;
      v17 = 42;
      goto LABEL_14;
    }
  }
  v8 = 2;
LABEL_8:
  v9 = db_add_field(a1, (_DWORD **)a2, v8, "_kMDItemRecentOutOfSpotlightEngagementDates", 0, 0x20u, 12, (unsigned __int8 *)&v28, v7, 8);
  v10 = *__error();
  v11 = _SILogForLogForCategory(7);
  v12 = v11;
  if (v9)
  {
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315650;
      v30 = COERCE_DOUBLE("updateRecentEngagementDates");
      v31 = 1024;
      *(_DWORD *)v32 = 300;
      *(_WORD *)&v32[4] = 2080;
      *(_QWORD *)&v32[6] = "_kMDItemRecentOutOfSpotlightEngagementDates";
      _os_log_error_impl(&dword_1B8270000, v12, OS_LOG_TYPE_ERROR, "%s:%d: Failed adding Out-of-Spotlight engagement date to %s", buf, 0x1Cu);
    }
    goto LABEL_15;
  }
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    v14 = *(_QWORD *)*a2;
    *(_DWORD *)buf = 134218498;
    v30 = v28;
    v31 = 2080;
    *(_QWORD *)v32 = "_kMDItemRecentOutOfSpotlightEngagementDates";
    *(_WORD *)&v32[8] = 2048;
    *(_QWORD *)&v32[10] = v14;
    v15 = "[Engagement Data] Adding Out-of-Spotlight engagement date: %f to %s for oid: %lld";
    v16 = v12;
    v17 = 32;
LABEL_14:
    _os_log_impl(&dword_1B8270000, v16, OS_LOG_TYPE_DEFAULT, v15, buf, v17);
  }
LABEL_15:
  *__error() = v10;
  return db_validate_obj(a1);
}

uint64_t populateU2LabelsAndDescriptions(int *a1, float *a2, const __CFDictionary *a3, void *a4)
{
  const void *v7;
  void *Value;
  const void **v9;
  void *ParserLibrary;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  float v14;
  float v15;
  int v16;
  int v17;
  const void *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t result;
  void *v25;
  _QWORD v27[5];
  _QWORD v28[5];
  _QWORD v29[5];
  _QWORD v30[5];
  _QWORD v31[5];
  _QWORD v32[5];
  _QWORD v33[5];
  _QWORD v34[5];
  _QWORD v35[5];
  _QWORD v36[5];
  _QWORD v37[5];
  _QWORD v38[5];
  _QWORD v39[5];
  _QWORD v40[5];
  _QWORD v41[5];
  _QWORD v42[5];
  _QWORD v43[5];
  _QWORD v44[5];
  _QWORD v45[5];
  _QWORD v46[5];
  _QWORD v47[5];
  _QWORD v48[5];
  _QWORD v49[5];
  _QWORD v50[5];
  _QWORD v51[5];
  _QWORD v52[5];
  _QWORD v53[5];
  _QWORD v54[5];
  _QWORD v55[5];
  _QWORD v56[5];
  _QWORD v57[5];
  _QWORD v58[5];
  _QWORD v59[5];
  _QWORD v60[5];
  _QWORD v61[5];
  _QWORD v62[5];
  _QWORD v63[5];
  _QWORD v64[5];
  _QWORD v65[5];
  _QWORD v66[5];
  _QWORD v67[5];
  _QWORD v68[5];
  _QWORD v69[5];
  _QWORD v70[5];
  _QWORD v71[5];
  _QWORD v72[5];
  _QWORD v73[5];
  uint64_t v74;
  uint64_t *v75;
  uint64_t v76;
  void (*v77)(uint64_t, uint64_t);
  void (*v78)(uint64_t);
  uint64_t v79;
  uint64_t v80;
  uint64_t *v81;
  uint64_t v82;
  uint64_t v83;

  v74 = 0;
  v75 = &v74;
  v76 = 0x3052000000;
  v77 = __Block_byref_object_copy__8636;
  v78 = __Block_byref_object_dispose__8637;
  v79 = 0;
  v7 = (const void *)getkQPQUOutputTokenArgIdsKey();
  Value = (void *)CFDictionaryGetValue(a3, v7);
  v80 = 0;
  v81 = &v80;
  v82 = 0x2020000000;
  v9 = (const void **)getkQPQUOutputTokenArgScoresKeySymbolLoc(void)::ptr;
  v83 = getkQPQUOutputTokenArgScoresKeySymbolLoc(void)::ptr;
  if (!getkQPQUOutputTokenArgScoresKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    v9 = (const void **)dlsym(ParserLibrary, "kQPQUOutputTokenArgScoresKey");
    v81[3] = (uint64_t)v9;
    getkQPQUOutputTokenArgScoresKeySymbolLoc(void)::ptr = (uint64_t)v9;
  }
  _Block_object_dispose(&v80, 8);
  if (v9)
  {
    v11 = (void *)CFDictionaryGetValue(a3, *v9);
    v12 = objc_msgSend(Value, "count");
    if (v12)
    {
      v13 = 0;
      while (1)
      {
        objc_msgSend((id)objc_msgSend(v11, "objectAtIndexedSubscript:", v13), "floatValue");
        v15 = v14;
        v16 = objc_msgSend((id)objc_msgSend(Value, "objectAtIndexedSubscript:", v13), "intValue");
        v17 = v16;
        LODWORD(v80) = v16;
        if (!v13)
        {
          *a1 = v16;
          if (!v16)
            break;
        }
        if (v15 >= 0.2 && (v16 || !v13 && v15 >= 0.5))
        {
          *((float *)std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(a2, v16, &v80)+ 5) = v15;
          if (v75[5])
            goto LABEL_67;
          v18 = (const void *)getkQPQUOutputTokenRangeKey();
          v20 = objc_msgSend((id)CFDictionaryGetValue(a3, v18), "rangeValue");
          if (v20 != 0x7FFFFFFFFFFFFFFFLL)
          {
            v21 = v19;
            if (v20 + v19 <= (unint64_t)objc_msgSend(a4, "length"))
            {
              switch(v17)
              {
                case 1:
                  v69[0] = MEMORY[0x1E0C809B0];
                  v69[1] = 3221225472;
                  v69[2] = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_5;
                  v22 = v69;
                  goto LABEL_63;
                case 2:
                  v72[0] = MEMORY[0x1E0C809B0];
                  v72[1] = 3221225472;
                  v72[2] = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_2;
                  v22 = v72;
                  goto LABEL_63;
                case 3:
                  v71[0] = MEMORY[0x1E0C809B0];
                  v71[1] = 3221225472;
                  v71[2] = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_3;
                  v22 = v71;
                  goto LABEL_63;
                case 4:
                  v70[0] = MEMORY[0x1E0C809B0];
                  v70[1] = 3221225472;
                  v70[2] = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_4;
                  v22 = v70;
                  goto LABEL_63;
                case 8:
                  v73[0] = MEMORY[0x1E0C809B0];
                  v73[1] = 3221225472;
                  v73[2] = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke;
                  v22 = v73;
                  goto LABEL_63;
                case 9:
                  v68[0] = MEMORY[0x1E0C809B0];
                  v68[1] = 3221225472;
                  v68[2] = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_6;
                  v22 = v68;
                  goto LABEL_63;
                case 16:
                  v60[0] = MEMORY[0x1E0C809B0];
                  v60[1] = 3221225472;
                  v60[2] = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_14;
                  v22 = v60;
                  goto LABEL_63;
                case 17:
                  v59[0] = MEMORY[0x1E0C809B0];
                  v59[1] = 3221225472;
                  v59[2] = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_15;
                  v22 = v59;
                  goto LABEL_63;
                case 18:
                  v66[0] = MEMORY[0x1E0C809B0];
                  v66[1] = 3221225472;
                  v66[2] = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_8;
                  v22 = v66;
                  goto LABEL_63;
                case 19:
                  v65[0] = MEMORY[0x1E0C809B0];
                  v65[1] = 3221225472;
                  v65[2] = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_9;
                  v22 = v65;
                  goto LABEL_63;
                case 20:
                  v64[0] = MEMORY[0x1E0C809B0];
                  v64[1] = 3221225472;
                  v64[2] = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_10;
                  v22 = v64;
                  goto LABEL_63;
                case 21:
                  v67[0] = MEMORY[0x1E0C809B0];
                  v67[1] = 3221225472;
                  v67[2] = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_7;
                  v22 = v67;
                  goto LABEL_63;
                case 22:
                  v56[0] = MEMORY[0x1E0C809B0];
                  v56[1] = 3221225472;
                  v56[2] = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_18;
                  v22 = v56;
                  goto LABEL_63;
                case 23:
                  v57[0] = MEMORY[0x1E0C809B0];
                  v57[1] = 3221225472;
                  v57[2] = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_17;
                  v22 = v57;
                  goto LABEL_63;
                case 24:
                  v61[0] = MEMORY[0x1E0C809B0];
                  v61[1] = 3221225472;
                  v61[2] = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_13;
                  v22 = v61;
                  goto LABEL_63;
                case 26:
                  v27[0] = MEMORY[0x1E0C809B0];
                  v27[1] = 3221225472;
                  v27[2] = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_47;
                  v22 = v27;
                  goto LABEL_63;
                case 27:
                  v29[0] = MEMORY[0x1E0C809B0];
                  v29[1] = 3221225472;
                  v29[2] = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_45;
                  v22 = v29;
                  goto LABEL_63;
                case 28:
                  v63[0] = MEMORY[0x1E0C809B0];
                  v63[1] = 3221225472;
                  v63[2] = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_11;
                  v22 = v63;
                  goto LABEL_63;
                case 29:
                  v62[0] = MEMORY[0x1E0C809B0];
                  v62[1] = 3221225472;
                  v62[2] = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_12;
                  v22 = v62;
                  goto LABEL_63;
                case 31:
                  v28[0] = MEMORY[0x1E0C809B0];
                  v28[1] = 3221225472;
                  v28[2] = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_46;
                  v22 = v28;
                  goto LABEL_63;
                case 32:
                  v55[0] = MEMORY[0x1E0C809B0];
                  v55[1] = 3221225472;
                  v55[2] = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_19;
                  v22 = v55;
                  goto LABEL_63;
                case 33:
                  v30[0] = MEMORY[0x1E0C809B0];
                  v30[1] = 3221225472;
                  v30[2] = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_44;
                  v22 = v30;
                  goto LABEL_63;
                case 34:
                  v31[0] = MEMORY[0x1E0C809B0];
                  v31[1] = 3221225472;
                  v31[2] = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_43;
                  v22 = v31;
                  goto LABEL_63;
                case 35:
                  v54[0] = MEMORY[0x1E0C809B0];
                  v54[1] = 3221225472;
                  v54[2] = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_20;
                  v22 = v54;
                  goto LABEL_63;
                case 36:
                  v53[0] = MEMORY[0x1E0C809B0];
                  v53[1] = 3221225472;
                  v53[2] = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_21;
                  v22 = v53;
                  goto LABEL_63;
                case 37:
                  v52[0] = MEMORY[0x1E0C809B0];
                  v52[1] = 3221225472;
                  v52[2] = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_22;
                  v22 = v52;
                  goto LABEL_63;
                case 38:
                  v51[0] = MEMORY[0x1E0C809B0];
                  v51[1] = 3221225472;
                  v51[2] = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_23;
                  v22 = v51;
                  goto LABEL_63;
                case 43:
                  v50[0] = MEMORY[0x1E0C809B0];
                  v50[1] = 3221225472;
                  v50[2] = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_24;
                  v22 = v50;
                  goto LABEL_63;
                case 44:
                  v58[0] = MEMORY[0x1E0C809B0];
                  v58[1] = 3221225472;
                  v58[2] = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_16;
                  v22 = v58;
                  goto LABEL_63;
                case 49:
                  v34[0] = MEMORY[0x1E0C809B0];
                  v34[1] = 3221225472;
                  v34[2] = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_40;
                  v22 = v34;
                  goto LABEL_63;
                case 51:
                  v33[0] = MEMORY[0x1E0C809B0];
                  v33[1] = 3221225472;
                  v33[2] = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_41;
                  v22 = v33;
                  goto LABEL_63;
                case 52:
                  v32[0] = MEMORY[0x1E0C809B0];
                  v32[1] = 3221225472;
                  v32[2] = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_42;
                  v22 = v32;
                  goto LABEL_63;
                case 53:
                  v49[0] = MEMORY[0x1E0C809B0];
                  v49[1] = 3221225472;
                  v49[2] = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_25;
                  v22 = v49;
                  goto LABEL_63;
                case 54:
                  v48[0] = MEMORY[0x1E0C809B0];
                  v48[1] = 3221225472;
                  v48[2] = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_26;
                  v22 = v48;
                  goto LABEL_63;
                case 55:
                  v47[0] = MEMORY[0x1E0C809B0];
                  v47[1] = 3221225472;
                  v47[2] = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_27;
                  v22 = v47;
                  goto LABEL_63;
                case 56:
                  v46[0] = MEMORY[0x1E0C809B0];
                  v46[1] = 3221225472;
                  v46[2] = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_28;
                  v22 = v46;
                  goto LABEL_63;
                case 57:
                  v45[0] = MEMORY[0x1E0C809B0];
                  v45[1] = 3221225472;
                  v45[2] = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_29;
                  v22 = v45;
                  goto LABEL_63;
                case 58:
                  v44[0] = MEMORY[0x1E0C809B0];
                  v44[1] = 3221225472;
                  v44[2] = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_30;
                  v22 = v44;
                  goto LABEL_63;
                case 59:
                  v43[0] = MEMORY[0x1E0C809B0];
                  v43[1] = 3221225472;
                  v43[2] = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_31;
                  v22 = v43;
                  goto LABEL_63;
                case 60:
                  v42[0] = MEMORY[0x1E0C809B0];
                  v42[1] = 3221225472;
                  v42[2] = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_32;
                  v22 = v42;
                  goto LABEL_63;
                case 61:
                  v41[0] = MEMORY[0x1E0C809B0];
                  v41[1] = 3221225472;
                  v41[2] = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_33;
                  v22 = v41;
                  goto LABEL_63;
                case 62:
                  v40[0] = MEMORY[0x1E0C809B0];
                  v40[1] = 3221225472;
                  v40[2] = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_34;
                  v22 = v40;
                  goto LABEL_63;
                case 64:
                  v39[0] = MEMORY[0x1E0C809B0];
                  v39[1] = 3221225472;
                  v39[2] = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_35;
                  v22 = v39;
                  goto LABEL_63;
                case 65:
                  v38[0] = MEMORY[0x1E0C809B0];
                  v38[1] = 3221225472;
                  v38[2] = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_36;
                  v22 = v38;
                  goto LABEL_63;
                case 66:
                  v37[0] = MEMORY[0x1E0C809B0];
                  v37[1] = 3221225472;
                  v37[2] = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_37;
                  v22 = v37;
                  goto LABEL_63;
                case 67:
                  v36[0] = MEMORY[0x1E0C809B0];
                  v36[1] = 3221225472;
                  v36[2] = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_38;
                  v22 = v36;
                  goto LABEL_63;
                case 68:
                  v35[0] = MEMORY[0x1E0C809B0];
                  v35[1] = 3221225472;
                  v35[2] = ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_39;
                  v22 = v35;
LABEL_63:
                  v22[3] = &unk_1E6E35EB0;
                  v22[4] = &v74;
                  objc_msgSend(a4, "enumerateAttributesInRange:options:usingBlock:", v20, v21, 0);
                  break;
                default:
                  break;
              }
            }
          }
        }
        if (v12 == ++v13)
          goto LABEL_67;
      }
      *((float *)std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(a2, 0, &ARG_UNSPECIFIED_ID)+ 5) = v15;
    }
LABEL_67:
    v23 = v75[5];
    _Block_object_dispose(&v74, 8);
    return v23;
  }
  else
  {
    v25 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
    result = objc_msgSend(v25, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPQUOutputTokenArgScoresKey()"), CFSTR("PRQUUtils.mm"), 20, CFSTR("%s"), dlerror());
    __break(1u);
  }
  return result;
}

void sub_1B85A3BF0(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 200), 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__8636(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__8637(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

uint64_t getkQPQUOutputTokenArgIdsKey()
{
  void *v0;
  void *ParserLibrary;
  uint64_t result;
  void *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v0 = (void *)getkQPQUOutputTokenArgIdsKeySymbolLoc(void)::ptr;
  v7 = getkQPQUOutputTokenArgIdsKeySymbolLoc(void)::ptr;
  if (!getkQPQUOutputTokenArgIdsKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    v0 = dlsym(ParserLibrary, "kQPQUOutputTokenArgIdsKey");
    v5[3] = (uint64_t)v0;
    getkQPQUOutputTokenArgIdsKeySymbolLoc(void)::ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v4, 8);
  if (v0)
    return *(_QWORD *)v0;
  v3 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPQUOutputTokenArgIdsKey()"), CFSTR("PRQUUtils.mm"), 17, CFSTR("%s"), dlerror());
  __break(1u);
  return result;
}

{
  void *v0;
  void *ParserLibrary;
  uint64_t result;
  void *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v0 = (void *)getkQPQUOutputTokenArgIdsKeySymbolLoc(void)::ptr;
  v7 = getkQPQUOutputTokenArgIdsKeySymbolLoc(void)::ptr;
  if (!getkQPQUOutputTokenArgIdsKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    v0 = dlsym(ParserLibrary, "kQPQUOutputTokenArgIdsKey");
    v5[3] = (uint64_t)v0;
    getkQPQUOutputTokenArgIdsKeySymbolLoc(void)::ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v4, 8);
  if (v0)
    return *(_QWORD *)v0;
  v3 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPQUOutputTokenArgIdsKey()"), CFSTR("PRQueryPhotosProcessor.mm"), 25, CFSTR("%s"), dlerror());
  __break(1u);
  return result;
}

void sub_1B85A3D24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *QueryParserLibrary()
{
  void *v0;
  void *v2;

  if (!QueryParserLibraryCore(char **)::frameworkLibrary)
    QueryParserLibraryCore(char **)::frameworkLibrary = _sl_dlopen();
  v0 = (void *)QueryParserLibraryCore(char **)::frameworkLibrary;
  if (!QueryParserLibraryCore(char **)::frameworkLibrary)
  {
    v0 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
    v2 = (void *)objc_msgSend(v0, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "void *QueryParserLibrary()"), CFSTR("PRQUUtils.mm"), 12, CFSTR("%s"), 0);
    __break(1u);
    free(v2);
  }
  return v0;
}

{
  void *v0;
  void *v2;

  if (!QueryParserLibraryCore(char **)::frameworkLibrary)
    QueryParserLibraryCore(char **)::frameworkLibrary = _sl_dlopen();
  v0 = (void *)QueryParserLibraryCore(char **)::frameworkLibrary;
  if (!QueryParserLibraryCore(char **)::frameworkLibrary)
  {
    v0 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
    v2 = (void *)objc_msgSend(v0, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "void *QueryParserLibrary()"), CFSTR("PRQueryPhotosProcessor.mm"), 23, CFSTR("%s"), 0);
    __break(1u);
    free(v2);
  }
  return v0;
}

_QWORD *std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(float *a1, int a2, _DWORD *a3)
{
  unint64_t v5;
  unint64_t v6;
  uint8x8_t v7;
  unint64_t v8;
  void **v9;
  _QWORD *v10;
  unint64_t v11;
  float v12;
  float v13;
  _BOOL8 v14;
  unint64_t v15;
  unint64_t v16;
  int8x8_t prime;
  void *v18;
  _QWORD *v19;
  uint64_t v20;
  _QWORD *v21;
  unint64_t v22;
  uint8x8_t v23;
  unint64_t v24;
  uint8x8_t v25;
  uint64_t v26;
  _QWORD *v27;
  unint64_t v28;
  _QWORD *v29;
  _QWORD *v30;
  unint64_t v31;
  _QWORD *v33;

  v5 = a2;
  v6 = *((_QWORD *)a1 + 1);
  if (v6)
  {
    v7 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      v8 = a2;
      if (v6 <= a2)
        v8 = a2 % v6;
    }
    else
    {
      v8 = (v6 - 1) & a2;
    }
    v9 = *(void ***)(*(_QWORD *)a1 + 8 * v8);
    if (v9)
    {
      v10 = *v9;
      if (*v9)
      {
        do
        {
          v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2)
              return v10;
          }
          else
          {
            if (v7.u32[0] > 1uLL)
            {
              if (v11 >= v6)
                v11 %= v6;
            }
            else
            {
              v11 &= v6 - 1;
            }
            if (v11 != v8)
              break;
          }
          v10 = (_QWORD *)*v10;
        }
        while (v10);
      }
    }
  }
  else
  {
    v8 = 0;
  }
  v10 = operator new(0x18uLL);
  *v10 = 0;
  v10[1] = v5;
  *((_DWORD *)v10 + 4) = *a3;
  *((_DWORD *)v10 + 5) = 0;
  v12 = (float)(unint64_t)(*((_QWORD *)a1 + 3) + 1);
  v13 = a1[8];
  if (!v6 || (float)(v13 * (float)v6) < v12)
  {
    v14 = 1;
    if (v6 >= 3)
      v14 = (v6 & (v6 - 1)) != 0;
    v15 = v14 | (2 * v6);
    v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16)
      prime = (int8x8_t)v16;
    else
      prime = (int8x8_t)v15;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
      v6 = *((_QWORD *)a1 + 1);
    }
    if (*(_QWORD *)&prime > v6)
      goto LABEL_30;
    if (*(_QWORD *)&prime < v6)
    {
      v24 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v6 < 3 || (v25 = (uint8x8_t)vcnt_s8((int8x8_t)v6), v25.i16[0] = vaddlv_u8(v25), v25.u32[0] > 1uLL))
      {
        v24 = std::__next_prime(v24);
      }
      else
      {
        v26 = 1 << -(char)__clz(v24 - 1);
        if (v24 >= 2)
          v24 = v26;
      }
      if (*(_QWORD *)&prime <= v24)
        prime = (int8x8_t)v24;
      if (*(_QWORD *)&prime >= v6)
      {
        v6 = *((_QWORD *)a1 + 1);
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(_QWORD *)&prime >> 61)
            std::__throw_bad_array_new_length[abi:nn180100]();
          v18 = operator new(8 * *(_QWORD *)&prime);
          v19 = *(_QWORD **)a1;
          *(_QWORD *)a1 = v18;
          if (v19)
            operator delete(v19);
          v20 = 0;
          *((int8x8_t *)a1 + 1) = prime;
          do
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v20++) = 0;
          while (*(_QWORD *)&prime != v20);
          v21 = (_QWORD *)*((_QWORD *)a1 + 2);
          if (v21)
          {
            v22 = v21[1];
            v23 = (uint8x8_t)vcnt_s8(prime);
            v23.i16[0] = vaddlv_u8(v23);
            if (v23.u32[0] > 1uLL)
            {
              if (v22 >= *(_QWORD *)&prime)
                v22 %= *(_QWORD *)&prime;
            }
            else
            {
              v22 &= *(_QWORD *)&prime - 1;
            }
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v22) = a1 + 4;
            v27 = (_QWORD *)*v21;
            if (*v21)
            {
              do
              {
                v28 = v27[1];
                if (v23.u32[0] > 1uLL)
                {
                  if (v28 >= *(_QWORD *)&prime)
                    v28 %= *(_QWORD *)&prime;
                }
                else
                {
                  v28 &= *(_QWORD *)&prime - 1;
                }
                if (v28 != v22)
                {
                  if (!*(_QWORD *)(*(_QWORD *)a1 + 8 * v28))
                  {
                    *(_QWORD *)(*(_QWORD *)a1 + 8 * v28) = v21;
                    goto LABEL_55;
                  }
                  *v21 = *v27;
                  *v27 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v28);
                  **(_QWORD **)(*(_QWORD *)a1 + 8 * v28) = v27;
                  v27 = v21;
                }
                v28 = v22;
LABEL_55:
                v21 = v27;
                v27 = (_QWORD *)*v27;
                v22 = v28;
              }
              while (v27);
            }
          }
          v6 = (unint64_t)prime;
          goto LABEL_59;
        }
        v33 = *(_QWORD **)a1;
        *(_QWORD *)a1 = 0;
        if (v33)
          operator delete(v33);
        v6 = 0;
        *((_QWORD *)a1 + 1) = 0;
      }
    }
LABEL_59:
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v6 <= v5)
        v8 = v5 % v6;
      else
        v8 = v5;
    }
    else
    {
      v8 = (v6 - 1) & v5;
    }
  }
  v29 = *(_QWORD **)a1;
  v30 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v8);
  if (v30)
  {
    *v10 = *v30;
LABEL_72:
    *v30 = v10;
    goto LABEL_73;
  }
  *v10 = *((_QWORD *)a1 + 2);
  *((_QWORD *)a1 + 2) = v10;
  v29[v8] = a1 + 4;
  if (*v10)
  {
    v31 = *(_QWORD *)(*v10 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v31 >= v6)
        v31 %= v6;
    }
    else
    {
      v31 &= v6 - 1;
    }
    v30 = (_QWORD *)(*(_QWORD *)a1 + 8 * v31);
    goto LABEL_72;
  }
LABEL_73:
  ++*((_QWORD *)a1 + 3);
  return v10;
}

void sub_1B85A4200(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t getkQPQUOutputTokenRangeKey()
{
  void *v0;
  void *ParserLibrary;
  uint64_t result;
  void *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v0 = (void *)getkQPQUOutputTokenRangeKeySymbolLoc(void)::ptr;
  v7 = getkQPQUOutputTokenRangeKeySymbolLoc(void)::ptr;
  if (!getkQPQUOutputTokenRangeKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    v0 = dlsym(ParserLibrary, "kQPQUOutputTokenRangeKey");
    v5[3] = (uint64_t)v0;
    getkQPQUOutputTokenRangeKeySymbolLoc(void)::ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v4, 8);
  if (v0)
    return *(_QWORD *)v0;
  v3 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPQUOutputTokenRangeKey()"), CFSTR("PRQUUtils.mm"), 19, CFSTR("%s"), dlerror());
  __break(1u);
  return result;
}

{
  void *v0;
  void *ParserLibrary;
  uint64_t result;
  void *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v0 = (void *)getkQPQUOutputTokenRangeKeySymbolLoc(void)::ptr;
  v7 = getkQPQUOutputTokenRangeKeySymbolLoc(void)::ptr;
  if (!getkQPQUOutputTokenRangeKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    v0 = dlsym(ParserLibrary, "kQPQUOutputTokenRangeKey");
    v5[3] = (uint64_t)v0;
    getkQPQUOutputTokenRangeKeySymbolLoc(void)::ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v4, 8);
  if (v0)
    return *(_QWORD *)v0;
  v3 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPQUOutputTokenRangeKey()"), CFSTR("PRQueryPhotosProcessor.mm"), 29, CFSTR("%s"), dlerror());
  __break(1u);
  return result;
}

void sub_1B85A42E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void *v9;
  const void *v10;
  const void *v11;
  id v12;

  result = objc_msgSend(a2, "count");
  if (a2)
  {
    if (result)
    {
      v9 = (const void *)getkQPParseAttributeDateKey();
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, v9);
      if ((_DWORD)result)
      {
        v10 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v10);
        if ((_DWORD)result)
        {
          v11 = (const void *)getkQPParseAttributeDescriptionKey();
          v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v12;
          result = (uint64_t)v12;
          *a5 = 1;
        }
      }
    }
  }
  return result;
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_2(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  id result;
  const void *v9;
  const void **v10;
  void *ParserLibrary;
  const void *v12;
  const void *v13;
  id v14;
  void *v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;

  result = (id)objc_msgSend(a2, "count");
  if (result)
  {
    v9 = (const void *)getkQPParseAttributeGroundedPersonKey();
    if (CFDictionaryGetValue((CFDictionaryRef)a2, v9))
      goto LABEL_8;
    v16 = 0;
    v17 = &v16;
    v18 = 0x2020000000;
    v10 = (const void **)getkQPParseAttributePersonKeySymbolLoc(void)::ptr;
    v19 = getkQPParseAttributePersonKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributePersonKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v10 = (const void **)dlsym(ParserLibrary, "kQPParseAttributePersonKey");
      v17[3] = (uint64_t)v10;
      getkQPParseAttributePersonKeySymbolLoc(void)::ptr = (uint64_t)v10;
    }
    _Block_object_dispose(&v16, 8);
    if (!v10)
    {
      v15 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = (id)objc_msgSend(v15, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributePersonKey()"), CFSTR("PRQUUtils.mm"), 25, CFSTR("%s"), dlerror());
      __break(1u);
      return result;
    }
    if (CFDictionaryGetValue((CFDictionaryRef)a2, *v10)
      || (v12 = (const void *)getkQPParseAttributeTaggedPersonKey(),
          (result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v12)) != 0))
    {
LABEL_8:
      v13 = (const void *)getkQPParseAttributeDescriptionKey();
      v14 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v13);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v14;
      result = v14;
      *a5 = 1;
    }
  }
  return result;
}

void sub_1B85A44E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_3(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  id result;
  const void *v9;
  const void *v10;
  id v11;

  result = (id)objc_msgSend(a2, "count");
  if (result)
  {
    v9 = (const void *)getkQPParseAttributeSenderKey();
    result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v9);
    if (result)
    {
      v10 = (const void *)getkQPParseAttributeDescriptionKey();
      v11 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v10);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v11;
      result = v11;
      *a5 = 1;
    }
  }
  return result;
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_4(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  id result;
  const void *v9;
  const void *v10;
  id v11;

  result = (id)objc_msgSend(a2, "count");
  if (result)
  {
    v9 = (const void *)getkQPParseAttributeRecipientKey();
    result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v9);
    if (result)
    {
      v10 = (const void *)getkQPParseAttributeDescriptionKey();
      v11 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v10);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v11;
      result = v11;
      *a5 = 1;
    }
  }
  return result;
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_5(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  id result;
  const void *v9;
  const void *v10;
  const void *v11;
  id v12;

  result = (id)objc_msgSend(a2, "count");
  if (result)
  {
    v9 = (const void *)getkQPParseAttributeMediaKey();
    if (CFDictionaryGetValue((CFDictionaryRef)a2, v9)
      || (v10 = (const void *)getkQPParseAttributeKindKey(),
          (result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v10)) != 0))
    {
      v11 = (const void *)getkQPParseAttributeDescriptionKey();
      v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v12;
      result = v12;
      *a5 = 1;
    }
  }
  return result;
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_6(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  id result;
  const void *v9;
  const void *v10;
  id v11;

  result = (id)objc_msgSend(a2, "count");
  if (result)
  {
    v9 = (const void *)getkQPParseAttributeKindKey();
    result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v9);
    if (result)
    {
      v10 = (const void *)getkQPParseAttributeDescriptionKey();
      v11 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v10);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v11;
      result = v11;
      *a5 = 1;
    }
  }
  return result;
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_7(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  id result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  id v12;
  void *v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;

  result = (id)objc_msgSend(a2, "count");
  if (result)
  {
    v14 = 0;
    v15 = &v14;
    v16 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeFavoritedKeySymbolLoc(void)::ptr;
    v17 = getkQPParseAttributeFavoritedKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeFavoritedKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeFavoritedKey");
      v15[3] = (uint64_t)v9;
      getkQPParseAttributeFavoritedKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v14, 8);
    if (v9)
    {
      result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, *v9);
      if (result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v12;
        result = v12;
        *a5 = 1;
      }
    }
    else
    {
      v13 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = (id)objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeFavoritedKey()"), CFSTR("PRQUUtils.mm"), 39, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85A4820(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_8(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  id result;
  const void *v9;
  const void *v10;
  id v11;

  result = (id)objc_msgSend(a2, "count");
  if (result)
  {
    v9 = (const void *)getkQPParseAttributeAttachmentKey();
    result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v9);
    if (result)
    {
      v10 = (const void *)getkQPParseAttributeDescriptionKey();
      v11 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v10);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v11;
      result = v11;
      *a5 = 1;
    }
  }
  return result;
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_9(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  id result;
  const void *v9;
  const void *v10;
  id v11;

  result = (id)objc_msgSend(a2, "count");
  if (result)
  {
    v9 = (const void *)getkQPParseAttributeAttachmentKindKey();
    result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v9);
    if (result)
    {
      v10 = (const void *)getkQPParseAttributeDescriptionKey();
      v11 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v10);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v11;
      result = v11;
      *a5 = 1;
    }
  }
  return result;
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_10(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  id result;
  const void *v9;
  const void *v10;
  id v11;

  result = (id)objc_msgSend(a2, "count");
  if (result)
  {
    v9 = (const void *)getkQPParseAttributeAttachmentKindKey();
    result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v9);
    if (result)
    {
      v10 = (const void *)getkQPParseAttributeDescriptionKey();
      v11 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v10);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v11;
      result = v11;
      *a5 = 1;
    }
  }
  return result;
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_11(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  id result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  id v12;
  void *v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;

  result = (id)objc_msgSend(a2, "count");
  if (result)
  {
    v14 = 0;
    v15 = &v14;
    v16 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeReadKeySymbolLoc(void)::ptr;
    v17 = getkQPParseAttributeReadKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeReadKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeReadKey");
      v15[3] = (uint64_t)v9;
      getkQPParseAttributeReadKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v14, 8);
    if (v9)
    {
      result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, *v9);
      if (result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v12;
        result = v12;
        *a5 = 1;
      }
    }
    else
    {
      v13 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = (id)objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeReadKey()"), CFSTR("PRQUUtils.mm"), 30, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85A4AD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_12(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  id result;
  const void *v9;
  const void *v10;
  id v11;

  result = (id)objc_msgSend(a2, "count");
  if (result)
  {
    v9 = (const void *)getkQPParseAttributeUnreadKey();
    result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v9);
    if (result)
    {
      v10 = (const void *)getkQPParseAttributeDescriptionKey();
      v11 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v10);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v11;
      result = v11;
      *a5 = 1;
    }
  }
  return result;
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_13(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  id result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  id v12;
  void *v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;

  result = (id)objc_msgSend(a2, "count");
  if (result)
  {
    v14 = 0;
    v15 = &v14;
    v16 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeRepliedKeySymbolLoc(void)::ptr;
    v17 = getkQPParseAttributeRepliedKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeRepliedKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeRepliedKey");
      v15[3] = (uint64_t)v9;
      getkQPParseAttributeRepliedKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v14, 8);
    if (v9)
    {
      result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, *v9);
      if (result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v12;
        result = v12;
        *a5 = 1;
      }
    }
    else
    {
      v13 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = (id)objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeRepliedKey()"), CFSTR("PRQUUtils.mm"), 29, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85A4C90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_14(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  id result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  id v12;
  void *v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;

  result = (id)objc_msgSend(a2, "count");
  if (result)
  {
    v14 = 0;
    v15 = &v14;
    v16 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeFlaggedKeySymbolLoc(void)::ptr;
    v17 = getkQPParseAttributeFlaggedKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeFlaggedKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeFlaggedKey");
      v15[3] = (uint64_t)v9;
      getkQPParseAttributeFlaggedKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v14, 8);
    if (v9)
    {
      result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, *v9);
      if (result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v12;
        result = v12;
        *a5 = 1;
      }
    }
    else
    {
      v13 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = (id)objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeFlaggedKey()"), CFSTR("PRQUUtils.mm"), 27, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85A4DD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_15(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  id result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  id v12;
  void *v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;

  result = (id)objc_msgSend(a2, "count");
  if (result)
  {
    v14 = 0;
    v15 = &v14;
    v16 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeTaggedKeySymbolLoc(void)::ptr;
    v17 = getkQPParseAttributeTaggedKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeTaggedKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeTaggedKey");
      v15[3] = (uint64_t)v9;
      getkQPParseAttributeTaggedKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v14, 8);
    if (v9)
    {
      result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, *v9);
      if (result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v12;
        result = v12;
        *a5 = 1;
      }
    }
    else
    {
      v13 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = (id)objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeTaggedKey()"), CFSTR("PRQUUtils.mm"), 42, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85A4F20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_16(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  id result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  id v12;
  void *v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;

  result = (id)objc_msgSend(a2, "count");
  if (result)
  {
    v14 = 0;
    v15 = &v14;
    v16 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeFlagColorKeySymbolLoc(void)::ptr;
    v17 = getkQPParseAttributeFlagColorKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeFlagColorKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeFlagColorKey");
      v15[3] = (uint64_t)v9;
      getkQPParseAttributeFlagColorKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v14, 8);
    if (v9)
    {
      result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, *v9);
      if (result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v12;
        result = v12;
        *a5 = 1;
      }
    }
    else
    {
      v13 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = (id)objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeFlagColorKey()"), CFSTR("PRQUUtils.mm"), 28, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85A5068(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_17(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  id result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  id v12;
  void *v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;

  result = (id)objc_msgSend(a2, "count");
  if (result)
  {
    v14 = 0;
    v15 = &v14;
    v16 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeReceivedKeySymbolLoc(void)::ptr;
    v17 = getkQPParseAttributeReceivedKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeReceivedKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeReceivedKey");
      v15[3] = (uint64_t)v9;
      getkQPParseAttributeReceivedKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v14, 8);
    if (v9)
    {
      result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, *v9);
      if (result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v12;
        result = v12;
        *a5 = 1;
      }
    }
    else
    {
      v13 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = (id)objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeReceivedKey()"), CFSTR("PRQUUtils.mm"), 32, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85A51B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_18(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  id result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  id v12;
  void *v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;

  result = (id)objc_msgSend(a2, "count");
  if (result)
  {
    v14 = 0;
    v15 = &v14;
    v16 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeSentKeySymbolLoc(void)::ptr;
    v17 = getkQPParseAttributeSentKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeSentKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeSentKey");
      v15[3] = (uint64_t)v9;
      getkQPParseAttributeSentKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v14, 8);
    if (v9)
    {
      result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, *v9);
      if (result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v12;
        result = v12;
        *a5 = 1;
      }
    }
    else
    {
      v13 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = (id)objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeSentKey()"), CFSTR("PRQUUtils.mm"), 33, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85A52F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_19(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  id result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  id v12;
  void *v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;

  result = (id)objc_msgSend(a2, "count");
  if (result)
  {
    v14 = 0;
    v15 = &v14;
    v16 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeCreatedActionKeySymbolLoc(void)::ptr;
    v17 = getkQPParseAttributeCreatedActionKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeCreatedActionKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeCreatedActionKey");
      v15[3] = (uint64_t)v9;
      getkQPParseAttributeCreatedActionKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v14, 8);
    if (v9)
    {
      result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, *v9);
      if (result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v12;
        result = v12;
        *a5 = 1;
      }
    }
    else
    {
      v13 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = (id)objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeCreatedActionKey()"), CFSTR("PRQUUtils.mm"), 48, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85A5440(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_20(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  id result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  id v12;
  void *v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;

  result = (id)objc_msgSend(a2, "count");
  if (result)
  {
    v14 = 0;
    v15 = &v14;
    v16 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeModifiedActionKeySymbolLoc(void)::ptr;
    v17 = getkQPParseAttributeModifiedActionKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeModifiedActionKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeModifiedActionKey");
      v15[3] = (uint64_t)v9;
      getkQPParseAttributeModifiedActionKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v14, 8);
    if (v9)
    {
      result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, *v9);
      if (result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v12;
        result = v12;
        *a5 = 1;
      }
    }
    else
    {
      v13 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = (id)objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeModifiedActionKey()"), CFSTR("PRQUUtils.mm"), 47, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85A5588(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_21(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  id result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  id v12;
  void *v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;

  result = (id)objc_msgSend(a2, "count");
  if (result)
  {
    v14 = 0;
    v15 = &v14;
    v16 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeSharedKeySymbolLoc(void)::ptr;
    v17 = getkQPParseAttributeSharedKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeSharedKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeSharedKey");
      v15[3] = (uint64_t)v9;
      getkQPParseAttributeSharedKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v14, 8);
    if (v9)
    {
      result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, *v9);
      if (result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v12;
        result = v12;
        *a5 = 1;
      }
    }
    else
    {
      v13 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = (id)objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeSharedKey()"), CFSTR("PRQUUtils.mm"), 44, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85A56D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_22(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  id result;
  const void **v9;
  void *ParserLibrary;
  const void **v11;
  void *v12;
  const void **v13;
  void *v14;
  const void **v15;
  void *v16;
  const void *v17;
  const void *v18;
  id v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  uint64_t v27;

  result = (id)objc_msgSend(a2, "count");
  if (!result)
    return result;
  v24 = 0;
  v25 = &v24;
  v26 = 0x2020000000;
  v9 = (const void **)getkQPParseAttributeTransportActionKeySymbolLoc(void)::ptr;
  v27 = getkQPParseAttributeTransportActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeTransportActionKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeTransportActionKey");
    v25[3] = (uint64_t)v9;
    getkQPParseAttributeTransportActionKeySymbolLoc(void)::ptr = (uint64_t)v9;
  }
  _Block_object_dispose(&v24, 8);
  if (!v9)
  {
    v20 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
    result = (id)objc_msgSend(v20, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeTransportActionKey()"), CFSTR("PRQUUtils.mm"), 45, CFSTR("%s"), dlerror());
LABEL_25:
    __break(1u);
    return result;
  }
  if (CFDictionaryGetValue((CFDictionaryRef)a2, *v9))
  {
LABEL_19:
    v18 = (const void *)getkQPParseAttributeDescriptionKey();
    v19 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v18);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v19;
    result = v19;
    *a5 = 1;
    return result;
  }
  v24 = 0;
  v25 = &v24;
  v26 = 0x2020000000;
  v11 = (const void **)getkQPParseAttributeAirdropActionKeySymbolLoc(void)::ptr;
  v27 = getkQPParseAttributeAirdropActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeAirdropActionKeySymbolLoc(void)::ptr)
  {
    v12 = QueryParserLibrary();
    v11 = (const void **)dlsym(v12, "kQPParseAttributeAirdropActionKey");
    v25[3] = (uint64_t)v11;
    getkQPParseAttributeAirdropActionKeySymbolLoc(void)::ptr = (uint64_t)v11;
  }
  _Block_object_dispose(&v24, 8);
  if (!v11)
  {
    v21 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
    result = (id)objc_msgSend(v21, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeAirdropActionKey()"), CFSTR("PRQUUtils.mm"), 64, CFSTR("%s"), dlerror());
    goto LABEL_25;
  }
  if (CFDictionaryGetValue((CFDictionaryRef)a2, *v11))
    goto LABEL_19;
  v24 = 0;
  v25 = &v24;
  v26 = 0x2020000000;
  v13 = (const void **)getkQPParseAttributeFacebookActionKeySymbolLoc(void)::ptr;
  v27 = getkQPParseAttributeFacebookActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeFacebookActionKeySymbolLoc(void)::ptr)
  {
    v14 = QueryParserLibrary();
    v13 = (const void **)dlsym(v14, "kQPParseAttributeFacebookActionKey");
    v25[3] = (uint64_t)v13;
    getkQPParseAttributeFacebookActionKeySymbolLoc(void)::ptr = (uint64_t)v13;
  }
  _Block_object_dispose(&v24, 8);
  if (!v13)
  {
    v22 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
    result = (id)objc_msgSend(v22, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeFacebookActionKey()"), CFSTR("PRQUUtils.mm"), 65, CFSTR("%s"), dlerror());
    goto LABEL_25;
  }
  if (CFDictionaryGetValue((CFDictionaryRef)a2, *v13))
    goto LABEL_19;
  v24 = 0;
  v25 = &v24;
  v26 = 0x2020000000;
  v15 = (const void **)getkQPParseAttributeTwitterActionKeySymbolLoc(void)::ptr;
  v27 = getkQPParseAttributeTwitterActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeTwitterActionKeySymbolLoc(void)::ptr)
  {
    v16 = QueryParserLibrary();
    v15 = (const void **)dlsym(v16, "kQPParseAttributeTwitterActionKey");
    v25[3] = (uint64_t)v15;
    getkQPParseAttributeTwitterActionKeySymbolLoc(void)::ptr = (uint64_t)v15;
  }
  _Block_object_dispose(&v24, 8);
  if (!v15)
  {
    v23 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
    result = (id)objc_msgSend(v23, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeTwitterActionKey()"), CFSTR("PRQUUtils.mm"), 66, CFSTR("%s"), dlerror());
    goto LABEL_25;
  }
  if (CFDictionaryGetValue((CFDictionaryRef)a2, *v15))
    goto LABEL_19;
  v17 = (const void *)getkQPParseAttributeDownloadedActionKey();
  result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v17);
  if (result)
    goto LABEL_19;
  return result;
}

void sub_1B85A5A44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_23(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  id result;
  const void *v9;
  const void *v10;
  id v11;

  result = (id)objc_msgSend(a2, "count");
  if (result)
  {
    v9 = (const void *)getkQPParseAttributePrintedActionKey();
    result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v9);
    if (result)
    {
      v10 = (const void *)getkQPParseAttributeDescriptionKey();
      v11 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v10);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v11;
      result = v11;
      *a5 = 1;
    }
  }
  return result;
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_24(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  id result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  id v12;
  void *v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;

  result = (id)objc_msgSend(a2, "count");
  if (result)
  {
    v14 = 0;
    v15 = &v14;
    v16 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeTagColorKeySymbolLoc(void)::ptr;
    v17 = getkQPParseAttributeTagColorKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeTagColorKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeTagColorKey");
      v15[3] = (uint64_t)v9;
      getkQPParseAttributeTagColorKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v14, 8);
    if (v9)
    {
      result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, *v9);
      if (result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v12;
        result = v12;
        *a5 = 1;
      }
    }
    else
    {
      v13 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = (id)objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeTagColorKey()"), CFSTR("PRQUUtils.mm"), 43, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85A5C10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_25(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  id result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  id v12;
  void *v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;

  result = (id)objc_msgSend(a2, "count");
  if (result)
  {
    v14 = 0;
    v15 = &v14;
    v16 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeFlightLocationKeySymbolLoc(void)::ptr;
    v17 = getkQPParseAttributeFlightLocationKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeFlightLocationKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeFlightLocationKey");
      v15[3] = (uint64_t)v9;
      getkQPParseAttributeFlightLocationKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v14, 8);
    if (v9)
    {
      result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, *v9);
      if (result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v12;
        result = v12;
        *a5 = 1;
      }
    }
    else
    {
      v13 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = (id)objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeFlightLocationKey()"), CFSTR("PRQUUtils.mm"), 54, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85A5D58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_26(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  id result;
  const void *v9;
  const void *v10;
  id v11;

  result = (id)objc_msgSend(a2, "count");
  if (result)
  {
    v9 = (const void *)getkQPParseAttributeFlightArrivalLocationKey();
    result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v9);
    if (result)
    {
      v10 = (const void *)getkQPParseAttributeDescriptionKey();
      v11 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v10);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v11;
      result = v11;
      *a5 = 1;
    }
  }
  return result;
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_27(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  id result;
  const void *v9;
  const void *v10;
  id v11;

  result = (id)objc_msgSend(a2, "count");
  if (result)
  {
    v9 = (const void *)getkQPParseAttributeFlightArrivalLocationKey();
    result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v9);
    if (result)
    {
      v10 = (const void *)getkQPParseAttributeDescriptionKey();
      v11 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v10);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v11;
      result = v11;
      *a5 = 1;
    }
  }
  return result;
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_28(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  id result;
  const void *v9;
  const void *v10;
  id v11;

  result = (id)objc_msgSend(a2, "count");
  if (result)
  {
    v9 = (const void *)getkQPParseAttributeFlightDepartureLocationKey();
    result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v9);
    if (result)
    {
      v10 = (const void *)getkQPParseAttributeDescriptionKey();
      v11 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v10);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v11;
      result = v11;
      *a5 = 1;
    }
  }
  return result;
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_29(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  id result;
  const void *v9;
  const void *v10;
  id v11;

  result = (id)objc_msgSend(a2, "count");
  if (result)
  {
    v9 = (const void *)getkQPParseAttributeFlightDepartureLocationKey();
    result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v9);
    if (result)
    {
      v10 = (const void *)getkQPParseAttributeDescriptionKey();
      v11 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v10);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v11;
      result = v11;
      *a5 = 1;
    }
  }
  return result;
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_30(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  id result;
  const void *v9;
  const void *v10;
  id v11;

  result = (id)objc_msgSend(a2, "count");
  if (result)
  {
    v9 = (const void *)getkQPParseAttributeFlightActionKey();
    result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v9);
    if (result)
    {
      v10 = (const void *)getkQPParseAttributeDescriptionKey();
      v11 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v10);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v11;
      result = v11;
      *a5 = 1;
    }
  }
  return result;
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_31(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  id result;
  const void *v9;
  const void *v10;
  id v11;

  result = (id)objc_msgSend(a2, "count");
  if (result)
  {
    v9 = (const void *)getkQPParseAttributeFlightCarrierKey();
    result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v9);
    if (result)
    {
      v10 = (const void *)getkQPParseAttributeDescriptionKey();
      v11 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v10);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v11;
      result = v11;
      *a5 = 1;
    }
  }
  return result;
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_32(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  id result;
  const void *v9;
  const void *v10;
  id v11;

  result = (id)objc_msgSend(a2, "count");
  if (result)
  {
    v9 = (const void *)getkQPParseAttributeFlightCarrierKey();
    result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v9);
    if (result)
    {
      v10 = (const void *)getkQPParseAttributeDescriptionKey();
      v11 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v10);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v11;
      result = v11;
      *a5 = 1;
    }
  }
  return result;
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_33(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  id result;
  const void *v9;
  const void *v10;
  id v11;

  result = (id)objc_msgSend(a2, "count");
  if (result)
  {
    v9 = (const void *)getkQPParseAttributeFlightDepartureLocationKey();
    result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v9);
    if (result)
    {
      v10 = (const void *)getkQPParseAttributeDescriptionKey();
      v11 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v10);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v11;
      result = v11;
      *a5 = 1;
    }
  }
  return result;
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_34(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  id result;
  const void *v9;
  const void *v10;
  id v11;

  result = (id)objc_msgSend(a2, "count");
  if (result)
  {
    v9 = (const void *)getkQPParseAttributeFlightArrivalLocationKey();
    result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v9);
    if (result)
    {
      v10 = (const void *)getkQPParseAttributeDescriptionKey();
      v11 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v10);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v11;
      result = v11;
      *a5 = 1;
    }
  }
  return result;
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_35(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  id result;
  const void *v9;
  const void *v10;
  id v11;

  result = (id)objc_msgSend(a2, "count");
  if (result)
  {
    v9 = (const void *)getkQPParseAttributeHotelActionKey();
    result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v9);
    if (result)
    {
      v10 = (const void *)getkQPParseAttributeDescriptionKey();
      v11 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v10);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v11;
      result = v11;
      *a5 = 1;
    }
  }
  return result;
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_36(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  id result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  id v12;
  void *v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;

  result = (id)objc_msgSend(a2, "count");
  if (result)
  {
    v14 = 0;
    v15 = &v14;
    v16 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeHotelProviderKeySymbolLoc(void)::ptr;
    v17 = getkQPParseAttributeHotelProviderKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeHotelProviderKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeHotelProviderKey");
      v15[3] = (uint64_t)v9;
      getkQPParseAttributeHotelProviderKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v14, 8);
    if (v9)
    {
      result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, *v9);
      if (result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v12;
        result = v12;
        *a5 = 1;
      }
    }
    else
    {
      v13 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = (id)objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeHotelProviderKey()"), CFSTR("PRQUUtils.mm"), 57, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85A6350(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_37(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  id result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  id v12;
  void *v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;

  result = (id)objc_msgSend(a2, "count");
  if (result)
  {
    v14 = 0;
    v15 = &v14;
    v16 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeHotelNameKeySymbolLoc(void)::ptr;
    v17 = getkQPParseAttributeHotelNameKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeHotelNameKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeHotelNameKey");
      v15[3] = (uint64_t)v9;
      getkQPParseAttributeHotelNameKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v14, 8);
    if (v9)
    {
      result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, *v9);
      if (result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v12;
        result = v12;
        *a5 = 1;
      }
    }
    else
    {
      v13 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = (id)objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeHotelNameKey()"), CFSTR("PRQUUtils.mm"), 56, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85A6498(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_38(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  id result;
  const void *v9;
  const void *v10;
  id v11;

  result = (id)objc_msgSend(a2, "count");
  if (result)
  {
    v9 = (const void *)getkQPParseAttributeRestaurantActionKey();
    result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v9);
    if (result)
    {
      v10 = (const void *)getkQPParseAttributeDescriptionKey();
      v11 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v10);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v11;
      result = v11;
      *a5 = 1;
    }
  }
  return result;
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_39(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  id result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  id v12;
  void *v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;

  result = (id)objc_msgSend(a2, "count");
  if (result)
  {
    v14 = 0;
    v15 = &v14;
    v16 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeRestaurantNameKeySymbolLoc(void)::ptr;
    v17 = getkQPParseAttributeRestaurantNameKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeRestaurantNameKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeRestaurantNameKey");
      v15[3] = (uint64_t)v9;
      getkQPParseAttributeRestaurantNameKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v14, 8);
    if (v9)
    {
      result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, *v9);
      if (result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v12;
        result = v12;
        *a5 = 1;
      }
    }
    else
    {
      v13 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = (id)objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeRestaurantNameKey()"), CFSTR("PRQUUtils.mm"), 60, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85A6658(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_40(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  id result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  id v12;
  void *v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;

  result = (id)objc_msgSend(a2, "count");
  if (result)
  {
    v14 = 0;
    v15 = &v14;
    v16 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeReadingListActionKeySymbolLoc(void)::ptr;
    v17 = getkQPParseAttributeReadingListActionKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeReadingListActionKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeReadingListActionKey");
      v15[3] = (uint64_t)v9;
      getkQPParseAttributeReadingListActionKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v14, 8);
    if (v9)
    {
      result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, *v9);
      if (result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v12;
        result = v12;
        *a5 = 1;
      }
    }
    else
    {
      v13 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = (id)objc_msgSend(v13, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeReadingListActionKey()"), CFSTR("PRQUUtils.mm"), 63, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85A67A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_41(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  id result;
  const void *v9;
  const void *v10;
  id v11;

  result = (id)objc_msgSend(a2, "count");
  if (result)
  {
    v9 = (const void *)getkQPParseAttributeEarliestActionKey();
    result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v9);
    if (result)
    {
      v10 = (const void *)getkQPParseAttributeDescriptionKey();
      v11 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v10);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v11;
      result = v11;
      *a5 = 1;
    }
  }
  return result;
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_42(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  id result;
  const void *v9;
  const void *v10;
  id v11;

  result = (id)objc_msgSend(a2, "count");
  if (result)
  {
    v9 = (const void *)getkQPParseAttributeLatestActionKey();
    result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v9);
    if (result)
    {
      v10 = (const void *)getkQPParseAttributeDescriptionKey();
      v11 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v10);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v11;
      result = v11;
      *a5 = 1;
    }
  }
  return result;
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_43(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  id result;
  const void *v9;
  const void *v10;
  id v11;

  result = (id)objc_msgSend(a2, "count");
  if (result)
  {
    v9 = (const void *)getkQPParseAttributeCompletedActionKey();
    result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v9);
    if (result)
    {
      v10 = (const void *)getkQPParseAttributeDescriptionKey();
      v11 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v10);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v11;
      result = v11;
      *a5 = 1;
    }
  }
  return result;
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_44(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  id result;
  const void *v9;
  const void *v10;
  id v11;

  result = (id)objc_msgSend(a2, "count");
  if (result)
  {
    v9 = (const void *)getkQPParseAttributeDueActionKey();
    result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v9);
    if (result)
    {
      v10 = (const void *)getkQPParseAttributeDescriptionKey();
      v11 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v10);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v11;
      result = v11;
      *a5 = 1;
    }
  }
  return result;
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_45(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  id result;
  const void *v9;
  const void *v10;
  id v11;

  result = (id)objc_msgSend(a2, "count");
  if (result)
  {
    v9 = (const void *)getkQPParseAttributeDraftActionKey();
    result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v9);
    if (result)
    {
      v10 = (const void *)getkQPParseAttributeDescriptionKey();
      v11 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v10);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v11;
      result = v11;
      *a5 = 1;
    }
  }
  return result;
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_46(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  id result;
  const void *v9;
  const void *v10;
  id v11;

  result = (id)objc_msgSend(a2, "count");
  if (result)
  {
    v9 = (const void *)getkQPParseAttributeJunkActionKey();
    result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v9);
    if (result)
    {
      v10 = (const void *)getkQPParseAttributeDescriptionKey();
      v11 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v10);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v11;
      result = v11;
      *a5 = 1;
    }
  }
  return result;
}

id ___Z31populateU2LabelsAndDescriptionsPiRNSt3__113unordered_mapIifNS0_4hashIiEENS0_8equal_toIiEENS0_9allocatorINS0_4pairIKifEEEEEEPK14__CFDictionaryP18NSAttributedString_block_invoke_47(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  id result;
  const void *v9;
  const void *v10;
  id v11;

  result = (id)objc_msgSend(a2, "count");
  if (result)
  {
    v9 = (const void *)getkQPParseAttributeArchiveActionKey();
    result = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v9);
    if (result)
    {
      v10 = (const void *)getkQPParseAttributeDescriptionKey();
      v11 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v10);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v11;
      result = v11;
      *a5 = 1;
    }
  }
  return result;
}

uint64_t getkQPParseAttributeArchiveActionKey(void)
{
  void *v0;
  void *ParserLibrary;
  uint64_t result;
  void *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v0 = (void *)getkQPParseAttributeArchiveActionKeySymbolLoc(void)::ptr;
  v7 = getkQPParseAttributeArchiveActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeArchiveActionKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    v0 = dlsym(ParserLibrary, "kQPParseAttributeArchiveActionKey");
    v5[3] = (uint64_t)v0;
    getkQPParseAttributeArchiveActionKeySymbolLoc(void)::ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v4, 8);
  if (v0)
    return *(_QWORD *)v0;
  v3 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeArchiveActionKey()"), CFSTR("PRQUUtils.mm"), 76, CFSTR("%s"), dlerror());
  __break(1u);
  return result;
}

void sub_1B85A6BD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeDescriptionKey(void)
{
  void *v0;
  void *ParserLibrary;
  uint64_t result;
  void *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v0 = (void *)getkQPParseAttributeDescriptionKeySymbolLoc(void)::ptr;
  v7 = getkQPParseAttributeDescriptionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeDescriptionKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    v0 = dlsym(ParserLibrary, "kQPParseAttributeDescriptionKey");
    v5[3] = (uint64_t)v0;
    getkQPParseAttributeDescriptionKeySymbolLoc(void)::ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v4, 8);
  if (v0)
    return *(_QWORD *)v0;
  v3 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeDescriptionKey()"), CFSTR("PRQUUtils.mm"), 21, CFSTR("%s"), dlerror());
  __break(1u);
  return result;
}

void sub_1B85A6CB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeJunkActionKey(void)
{
  void *v0;
  void *ParserLibrary;
  uint64_t result;
  void *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v0 = (void *)getkQPParseAttributeJunkActionKeySymbolLoc(void)::ptr;
  v7 = getkQPParseAttributeJunkActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeJunkActionKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    v0 = dlsym(ParserLibrary, "kQPParseAttributeJunkActionKey");
    v5[3] = (uint64_t)v0;
    getkQPParseAttributeJunkActionKeySymbolLoc(void)::ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v4, 8);
  if (v0)
    return *(_QWORD *)v0;
  v3 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeJunkActionKey()"), CFSTR("PRQUUtils.mm"), 75, CFSTR("%s"), dlerror());
  __break(1u);
  return result;
}

void sub_1B85A6DA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeDraftActionKey(void)
{
  void *v0;
  void *ParserLibrary;
  uint64_t result;
  void *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v0 = (void *)getkQPParseAttributeDraftActionKeySymbolLoc(void)::ptr;
  v7 = getkQPParseAttributeDraftActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeDraftActionKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    v0 = dlsym(ParserLibrary, "kQPParseAttributeDraftActionKey");
    v5[3] = (uint64_t)v0;
    getkQPParseAttributeDraftActionKeySymbolLoc(void)::ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v4, 8);
  if (v0)
    return *(_QWORD *)v0;
  v3 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeDraftActionKey()"), CFSTR("PRQUUtils.mm"), 74, CFSTR("%s"), dlerror());
  __break(1u);
  return result;
}

void sub_1B85A6E88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeDueActionKey(void)
{
  void *v0;
  void *ParserLibrary;
  uint64_t result;
  void *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v0 = (void *)getkQPParseAttributeDueActionKeySymbolLoc(void)::ptr;
  v7 = getkQPParseAttributeDueActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeDueActionKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    v0 = dlsym(ParserLibrary, "kQPParseAttributeDueActionKey");
    v5[3] = (uint64_t)v0;
    getkQPParseAttributeDueActionKeySymbolLoc(void)::ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v4, 8);
  if (v0)
    return *(_QWORD *)v0;
  v3 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeDueActionKey()"), CFSTR("PRQUUtils.mm"), 73, CFSTR("%s"), dlerror());
  __break(1u);
  return result;
}

void sub_1B85A6F70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeCompletedActionKey(void)
{
  void *v0;
  void *ParserLibrary;
  uint64_t result;
  void *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v0 = (void *)getkQPParseAttributeCompletedActionKeySymbolLoc(void)::ptr;
  v7 = getkQPParseAttributeCompletedActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeCompletedActionKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    v0 = dlsym(ParserLibrary, "kQPParseAttributeCompletedActionKey");
    v5[3] = (uint64_t)v0;
    getkQPParseAttributeCompletedActionKeySymbolLoc(void)::ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v4, 8);
  if (v0)
    return *(_QWORD *)v0;
  v3 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeCompletedActionKey()"), CFSTR("PRQUUtils.mm"), 72, CFSTR("%s"), dlerror());
  __break(1u);
  return result;
}

void sub_1B85A7058(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeLatestActionKey(void)
{
  void *v0;
  void *ParserLibrary;
  uint64_t result;
  void *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v0 = (void *)getkQPParseAttributeLatestActionKeySymbolLoc(void)::ptr;
  v7 = getkQPParseAttributeLatestActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeLatestActionKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    v0 = dlsym(ParserLibrary, "kQPParseAttributeLatestActionKey");
    v5[3] = (uint64_t)v0;
    getkQPParseAttributeLatestActionKeySymbolLoc(void)::ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v4, 8);
  if (v0)
    return *(_QWORD *)v0;
  v3 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeLatestActionKey()"), CFSTR("PRQUUtils.mm"), 71, CFSTR("%s"), dlerror());
  __break(1u);
  return result;
}

void sub_1B85A7140(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeEarliestActionKey(void)
{
  void *v0;
  void *ParserLibrary;
  uint64_t result;
  void *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v0 = (void *)getkQPParseAttributeEarliestActionKeySymbolLoc(void)::ptr;
  v7 = getkQPParseAttributeEarliestActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeEarliestActionKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    v0 = dlsym(ParserLibrary, "kQPParseAttributeEarliestActionKey");
    v5[3] = (uint64_t)v0;
    getkQPParseAttributeEarliestActionKeySymbolLoc(void)::ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v4, 8);
  if (v0)
    return *(_QWORD *)v0;
  v3 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeEarliestActionKey()"), CFSTR("PRQUUtils.mm"), 70, CFSTR("%s"), dlerror());
  __break(1u);
  return result;
}

void sub_1B85A7228(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeRestaurantActionKey(void)
{
  void *v0;
  void *ParserLibrary;
  uint64_t result;
  void *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v0 = (void *)getkQPParseAttributeRestaurantActionKeySymbolLoc(void)::ptr;
  v7 = getkQPParseAttributeRestaurantActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeRestaurantActionKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    v0 = dlsym(ParserLibrary, "kQPParseAttributeRestaurantActionKey");
    v5[3] = (uint64_t)v0;
    getkQPParseAttributeRestaurantActionKeySymbolLoc(void)::ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v4, 8);
  if (v0)
    return *(_QWORD *)v0;
  v3 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeRestaurantActionKey()"), CFSTR("PRQUUtils.mm"), 59, CFSTR("%s"), dlerror());
  __break(1u);
  return result;
}

void sub_1B85A7310(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeHotelActionKey(void)
{
  void *v0;
  void *ParserLibrary;
  uint64_t result;
  void *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v0 = (void *)getkQPParseAttributeHotelActionKeySymbolLoc(void)::ptr;
  v7 = getkQPParseAttributeHotelActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeHotelActionKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    v0 = dlsym(ParserLibrary, "kQPParseAttributeHotelActionKey");
    v5[3] = (uint64_t)v0;
    getkQPParseAttributeHotelActionKeySymbolLoc(void)::ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v4, 8);
  if (v0)
    return *(_QWORD *)v0;
  v3 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeHotelActionKey()"), CFSTR("PRQUUtils.mm"), 55, CFSTR("%s"), dlerror());
  __break(1u);
  return result;
}

void sub_1B85A73F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeFlightArrivalLocationKey(void)
{
  void *v0;
  void *ParserLibrary;
  uint64_t result;
  void *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v0 = (void *)getkQPParseAttributeFlightArrivalLocationKeySymbolLoc(void)::ptr;
  v7 = getkQPParseAttributeFlightArrivalLocationKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeFlightArrivalLocationKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    v0 = dlsym(ParserLibrary, "kQPParseAttributeFlightArrivalLocationKey");
    v5[3] = (uint64_t)v0;
    getkQPParseAttributeFlightArrivalLocationKeySymbolLoc(void)::ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v4, 8);
  if (v0)
    return *(_QWORD *)v0;
  v3 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeFlightArrivalLocationKey()"), CFSTR("PRQUUtils.mm"), 51, CFSTR("%s"), dlerror());
  __break(1u);
  return result;
}

void sub_1B85A74E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeFlightDepartureLocationKey(void)
{
  void *v0;
  void *ParserLibrary;
  uint64_t result;
  void *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v0 = (void *)getkQPParseAttributeFlightDepartureLocationKeySymbolLoc(void)::ptr;
  v7 = getkQPParseAttributeFlightDepartureLocationKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeFlightDepartureLocationKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    v0 = dlsym(ParserLibrary, "kQPParseAttributeFlightDepartureLocationKey");
    v5[3] = (uint64_t)v0;
    getkQPParseAttributeFlightDepartureLocationKeySymbolLoc(void)::ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v4, 8);
  if (v0)
    return *(_QWORD *)v0;
  v3 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeFlightDepartureLocationKey()"), CFSTR("PRQUUtils.mm"), 52, CFSTR("%s"), dlerror());
  __break(1u);
  return result;
}

void sub_1B85A75C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeFlightCarrierKey(void)
{
  void *v0;
  void *ParserLibrary;
  uint64_t result;
  void *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v0 = (void *)getkQPParseAttributeFlightCarrierKeySymbolLoc(void)::ptr;
  v7 = getkQPParseAttributeFlightCarrierKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeFlightCarrierKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    v0 = dlsym(ParserLibrary, "kQPParseAttributeFlightCarrierKey");
    v5[3] = (uint64_t)v0;
    getkQPParseAttributeFlightCarrierKeySymbolLoc(void)::ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v4, 8);
  if (v0)
    return *(_QWORD *)v0;
  v3 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeFlightCarrierKey()"), CFSTR("PRQUUtils.mm"), 53, CFSTR("%s"), dlerror());
  __break(1u);
  return result;
}

void sub_1B85A76B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeFlightActionKey(void)
{
  void *v0;
  void *ParserLibrary;
  uint64_t result;
  void *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v0 = (void *)getkQPParseAttributeFlightActionKeySymbolLoc(void)::ptr;
  v7 = getkQPParseAttributeFlightActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeFlightActionKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    v0 = dlsym(ParserLibrary, "kQPParseAttributeFlightActionKey");
    v5[3] = (uint64_t)v0;
    getkQPParseAttributeFlightActionKeySymbolLoc(void)::ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v4, 8);
  if (v0)
    return *(_QWORD *)v0;
  v3 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeFlightActionKey()"), CFSTR("PRQUUtils.mm"), 50, CFSTR("%s"), dlerror());
  __break(1u);
  return result;
}

void sub_1B85A7798(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributePrintedActionKey(void)
{
  void *v0;
  void *ParserLibrary;
  uint64_t result;
  void *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v0 = (void *)getkQPParseAttributePrintedActionKeySymbolLoc(void)::ptr;
  v7 = getkQPParseAttributePrintedActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributePrintedActionKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    v0 = dlsym(ParserLibrary, "kQPParseAttributePrintedActionKey");
    v5[3] = (uint64_t)v0;
    getkQPParseAttributePrintedActionKeySymbolLoc(void)::ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v4, 8);
  if (v0)
    return *(_QWORD *)v0;
  v3 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributePrintedActionKey()"), CFSTR("PRQUUtils.mm"), 46, CFSTR("%s"), dlerror());
  __break(1u);
  return result;
}

void sub_1B85A7880(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeDownloadedActionKey(void)
{
  void *v0;
  void *ParserLibrary;
  uint64_t result;
  void *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v0 = (void *)getkQPParseAttributeDownloadedActionKeySymbolLoc(void)::ptr;
  v7 = getkQPParseAttributeDownloadedActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeDownloadedActionKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    v0 = dlsym(ParserLibrary, "kQPParseAttributeDownloadedActionKey");
    v5[3] = (uint64_t)v0;
    getkQPParseAttributeDownloadedActionKeySymbolLoc(void)::ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v4, 8);
  if (v0)
    return *(_QWORD *)v0;
  v3 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeDownloadedActionKey()"), CFSTR("PRQUUtils.mm"), 67, CFSTR("%s"), dlerror());
  __break(1u);
  return result;
}

void sub_1B85A7968(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeUnreadKey(void)
{
  void *v0;
  void *ParserLibrary;
  uint64_t result;
  void *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v0 = (void *)getkQPParseAttributeUnreadKeySymbolLoc(void)::ptr;
  v7 = getkQPParseAttributeUnreadKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeUnreadKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    v0 = dlsym(ParserLibrary, "kQPParseAttributeUnreadKey");
    v5[3] = (uint64_t)v0;
    getkQPParseAttributeUnreadKeySymbolLoc(void)::ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v4, 8);
  if (v0)
    return *(_QWORD *)v0;
  v3 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeUnreadKey()"), CFSTR("PRQUUtils.mm"), 31, CFSTR("%s"), dlerror());
  __break(1u);
  return result;
}

void sub_1B85A7A50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeAttachmentKindKey(void)
{
  void *v0;
  void *ParserLibrary;
  uint64_t result;
  void *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v0 = (void *)getkQPParseAttributeAttachmentKindKeySymbolLoc(void)::ptr;
  v7 = getkQPParseAttributeAttachmentKindKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeAttachmentKindKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    v0 = dlsym(ParserLibrary, "kQPParseAttributeAttachmentKindKey");
    v5[3] = (uint64_t)v0;
    getkQPParseAttributeAttachmentKindKeySymbolLoc(void)::ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v4, 8);
  if (v0)
    return *(_QWORD *)v0;
  v3 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeAttachmentKindKey()"), CFSTR("PRQUUtils.mm"), 35, CFSTR("%s"), dlerror());
  __break(1u);
  return result;
}

void sub_1B85A7B38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeAttachmentKey(void)
{
  void *v0;
  void *ParserLibrary;
  uint64_t result;
  void *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v0 = (void *)getkQPParseAttributeAttachmentKeySymbolLoc(void)::ptr;
  v7 = getkQPParseAttributeAttachmentKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeAttachmentKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    v0 = dlsym(ParserLibrary, "kQPParseAttributeAttachmentKey");
    v5[3] = (uint64_t)v0;
    getkQPParseAttributeAttachmentKeySymbolLoc(void)::ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v4, 8);
  if (v0)
    return *(_QWORD *)v0;
  v3 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeAttachmentKey()"), CFSTR("PRQUUtils.mm"), 34, CFSTR("%s"), dlerror());
  __break(1u);
  return result;
}

void sub_1B85A7C20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeKindKey(void)
{
  void *v0;
  void *ParserLibrary;
  uint64_t result;
  void *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v0 = (void *)getkQPParseAttributeKindKeySymbolLoc(void)::ptr;
  v7 = getkQPParseAttributeKindKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeKindKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    v0 = dlsym(ParserLibrary, "kQPParseAttributeKindKey");
    v5[3] = (uint64_t)v0;
    getkQPParseAttributeKindKeySymbolLoc(void)::ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v4, 8);
  if (v0)
    return *(_QWORD *)v0;
  v3 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindKey()"), CFSTR("PRQUUtils.mm"), 41, CFSTR("%s"), dlerror());
  __break(1u);
  return result;
}

void sub_1B85A7D08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeMediaKey(void)
{
  void *v0;
  void *ParserLibrary;
  uint64_t result;
  void *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v0 = (void *)getkQPParseAttributeMediaKeySymbolLoc(void)::ptr;
  v7 = getkQPParseAttributeMediaKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeMediaKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    v0 = dlsym(ParserLibrary, "kQPParseAttributeMediaKey");
    v5[3] = (uint64_t)v0;
    getkQPParseAttributeMediaKeySymbolLoc(void)::ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v4, 8);
  if (v0)
    return *(_QWORD *)v0;
  v3 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeMediaKey()"), CFSTR("PRQUUtils.mm"), 40, CFSTR("%s"), dlerror());
  __break(1u);
  return result;
}

void sub_1B85A7DF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeRecipientKey(void)
{
  void *v0;
  void *ParserLibrary;
  uint64_t result;
  void *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v0 = (void *)getkQPParseAttributeRecipientKeySymbolLoc(void)::ptr;
  v7 = getkQPParseAttributeRecipientKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeRecipientKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    v0 = dlsym(ParserLibrary, "kQPParseAttributeRecipientKey");
    v5[3] = (uint64_t)v0;
    getkQPParseAttributeRecipientKeySymbolLoc(void)::ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v4, 8);
  if (v0)
    return *(_QWORD *)v0;
  v3 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeRecipientKey()"), CFSTR("PRQUUtils.mm"), 24, CFSTR("%s"), dlerror());
  __break(1u);
  return result;
}

void sub_1B85A7ED8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeSenderKey(void)
{
  void *v0;
  void *ParserLibrary;
  uint64_t result;
  void *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v0 = (void *)getkQPParseAttributeSenderKeySymbolLoc(void)::ptr;
  v7 = getkQPParseAttributeSenderKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeSenderKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    v0 = dlsym(ParserLibrary, "kQPParseAttributeSenderKey");
    v5[3] = (uint64_t)v0;
    getkQPParseAttributeSenderKeySymbolLoc(void)::ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v4, 8);
  if (v0)
    return *(_QWORD *)v0;
  v3 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeSenderKey()"), CFSTR("PRQUUtils.mm"), 23, CFSTR("%s"), dlerror());
  __break(1u);
  return result;
}

void sub_1B85A7FC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeGroundedPersonKey(void)
{
  void *v0;
  void *ParserLibrary;
  uint64_t result;
  void *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v0 = (void *)getkQPParseAttributeGroundedPersonKeySymbolLoc(void)::ptr;
  v7 = getkQPParseAttributeGroundedPersonKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeGroundedPersonKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    v0 = dlsym(ParserLibrary, "kQPParseAttributeGroundedPersonKey");
    v5[3] = (uint64_t)v0;
    getkQPParseAttributeGroundedPersonKeySymbolLoc(void)::ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v4, 8);
  if (v0)
    return *(_QWORD *)v0;
  v3 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeGroundedPersonKey()"), CFSTR("PRQUUtils.mm"), 22, CFSTR("%s"), dlerror());
  __break(1u);
  return result;
}

void sub_1B85A80A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeTaggedPersonKey(void)
{
  void *v0;
  void *ParserLibrary;
  uint64_t result;
  void *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v0 = (void *)getkQPParseAttributeTaggedPersonKeySymbolLoc(void)::ptr;
  v7 = getkQPParseAttributeTaggedPersonKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeTaggedPersonKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    v0 = dlsym(ParserLibrary, "kQPParseAttributeTaggedPersonKey");
    v5[3] = (uint64_t)v0;
    getkQPParseAttributeTaggedPersonKeySymbolLoc(void)::ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v4, 8);
  if (v0)
    return *(_QWORD *)v0;
  v3 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeTaggedPersonKey()"), CFSTR("PRQUUtils.mm"), 26, CFSTR("%s"), dlerror());
  __break(1u);
  return result;
}

void sub_1B85A8190(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeDateKey(void)
{
  void *v0;
  void *ParserLibrary;
  uint64_t result;
  void *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v0 = (void *)getkQPParseAttributeDateKeySymbolLoc(void)::ptr;
  v7 = getkQPParseAttributeDateKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeDateKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    v0 = dlsym(ParserLibrary, "kQPParseAttributeDateKey");
    v5[3] = (uint64_t)v0;
    getkQPParseAttributeDateKeySymbolLoc(void)::ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v4, 8);
  if (v0)
    return *(_QWORD *)v0;
  v3 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeDateKey()"), CFSTR("PRQUUtils.mm"), 36, CFSTR("%s"), dlerror());
  __break(1u);
  return result;
}

void sub_1B85A8278(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL isKeywordArgId(int a1)
{
  unsigned __int8 v2;

  {
    KeywordArgs(void)::_keywordArgs = 0u;
    unk_1EF1AD028 = 0u;
    dword_1EF1AD038 = 1065353216;
    __cxa_atexit((void (*)(void *))std::unordered_set<int>::~unordered_set[abi:nn180100], &KeywordArgs(void)::_keywordArgs, &dword_1B8270000);
  }
  if (KeywordArgs(void)::onceToken != -1)
    dispatch_once(&KeywordArgs(void)::onceToken, &__block_literal_global_58_8709);
  return std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::find<int>(&KeywordArgs(void)::_keywordArgs, a1) != 0;
}

void ___ZL11KeywordArgsv_block_invoke()
{
  _OWORD v0[7];
  int v1;
  uint64_t v2;

  v2 = *MEMORY[0x1E0C80C00];
  v0[4] = xmmword_1B8631438;
  v0[5] = unk_1B8631448;
  v0[6] = xmmword_1B8631458;
  v0[0] = xmmword_1B86313F8;
  v0[1] = unk_1B8631408;
  v0[2] = xmmword_1B8631418;
  v0[3] = unk_1B8631428;
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__assign_unique<int const*>((uint64_t)&KeywordArgs(void)::_keywordArgs, (int *)v0, &v1);
}

void std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__assign_unique<int const*>(uint64_t a1, int *a2, int *a3)
{
  int *v4;
  uint64_t v6;
  uint64_t i;
  _QWORD *v8;
  BOOL v9;
  _QWORD *v10;
  unint64_t v11;
  unint64_t v12;
  uint8x8_t v13;
  unint64_t v14;
  uint64_t **v15;
  uint64_t *j;
  unint64_t v17;
  float v18;
  float v19;
  uint64_t v20;
  _BOOL8 v21;
  size_t v22;
  unint64_t v23;
  size_t v24;
  uint8x8_t v25;
  _QWORD *v26;
  unint64_t v27;
  _QWORD *v28;
  int v29;

  v4 = a2;
  v6 = *(_QWORD *)(a1 + 8);
  if (v6)
  {
    for (i = 0; i != v6; ++i)
      *(_QWORD *)(*(_QWORD *)a1 + 8 * i) = 0;
    v8 = *(_QWORD **)(a1 + 16);
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)(a1 + 24) = 0;
    if (v8)
      v9 = a2 == a3;
    else
      v9 = 1;
    if (!v9)
    {
      while (1)
      {
        v11 = *v4;
        *((_DWORD *)v8 + 4) = v11;
        v10 = (_QWORD *)*v8;
        v8[1] = v11;
        v12 = *(_QWORD *)(a1 + 8);
        if (v12)
        {
          v13 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
          v13.i16[0] = vaddlv_u8(v13);
          if (v13.u32[0] > 1uLL)
          {
            v14 = v11;
            if (v12 <= v11)
              v14 = v11 % v12;
          }
          else
          {
            v14 = (v12 - 1) & v11;
          }
          v15 = *(uint64_t ***)(*(_QWORD *)a1 + 8 * v14);
          if (v15)
          {
            for (j = *v15; j; j = (uint64_t *)*j)
            {
              v17 = j[1];
              if (v17 == v11)
              {
                if (*((_DWORD *)j + 4) == (_DWORD)v11)
                  goto LABEL_49;
              }
              else
              {
                if (v13.u32[0] > 1uLL)
                {
                  if (v17 >= v12)
                    v17 %= v12;
                }
                else
                {
                  v17 &= v12 - 1;
                }
                if (v17 != v14)
                  break;
              }
            }
          }
        }
        v18 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
        v19 = *(float *)(a1 + 32);
        if (!v12 || (float)(v19 * (float)v12) < v18)
        {
          v20 = 2 * v12;
          v21 = v12 < 3 || (v12 & (v12 - 1)) != 0;
          v22 = v21 | v20;
          v23 = vcvtps_u32_f32(v18 / v19);
          if (v22 <= v23)
            v24 = v23;
          else
            v24 = v22;
          std::__hash_table<std::__hash_value_type<std::string,int>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,int>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,int>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,int>>>::__rehash<true>(a1, v24);
          v12 = *(_QWORD *)(a1 + 8);
          v11 = v8[1];
        }
        v25 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
        v25.i16[0] = vaddlv_u8(v25);
        if (v25.u32[0] > 1uLL)
        {
          if (v11 >= v12)
            v11 %= v12;
        }
        else
        {
          v11 &= v12 - 1;
        }
        v26 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v11);
        if (v26)
        {
          *v8 = *v26;
        }
        else
        {
          *v8 = *(_QWORD *)(a1 + 16);
          *(_QWORD *)(a1 + 16) = v8;
          *(_QWORD *)(*(_QWORD *)a1 + 8 * v11) = a1 + 16;
          if (!*v8)
            goto LABEL_48;
          v27 = *(_QWORD *)(*v8 + 8);
          if (v25.u32[0] > 1uLL)
          {
            if (v27 >= v12)
              v27 %= v12;
          }
          else
          {
            v27 &= v12 - 1;
          }
          v26 = (_QWORD *)(*(_QWORD *)a1 + 8 * v27);
        }
        *v26 = v8;
LABEL_48:
        ++*(_QWORD *)(a1 + 24);
LABEL_49:
        ++v4;
        if (v10)
        {
          v8 = v10;
          if (v4 != a3)
            continue;
        }
        goto LABEL_51;
      }
    }
    v10 = v8;
LABEL_51:
    if (v10)
    {
      do
      {
        v28 = (_QWORD *)*v10;
        operator delete(v10);
        v10 = v28;
      }
      while (v28);
    }
  }
  while (v4 != a3)
  {
    v29 = *v4++;
    std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__emplace_unique_key_args<int,int const&>(a1, v29, v29);
  }
}

void std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__emplace_unique_key_args<int,int const&>(uint64_t a1, int a2, int a3)
{
  unint64_t v5;
  unint64_t v6;
  uint8x8_t v7;
  unint64_t v8;
  uint64_t **v9;
  uint64_t *i;
  unint64_t v11;
  _QWORD *v12;
  float v13;
  float v14;
  _BOOL8 v15;
  unint64_t v16;
  unint64_t v17;
  size_t v18;
  uint64_t v19;
  _QWORD *v20;
  unint64_t v21;

  v5 = a2;
  v6 = *(_QWORD *)(a1 + 8);
  if (v6)
  {
    v7 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      v8 = a2;
      if (v6 <= a2)
        v8 = a2 % v6;
    }
    else
    {
      v8 = (v6 - 1) & a2;
    }
    v9 = *(uint64_t ***)(*(_QWORD *)a1 + 8 * v8);
    if (v9)
    {
      for (i = *v9; i; i = (uint64_t *)*i)
      {
        v11 = i[1];
        if (v11 == a2)
        {
          if (*((_DWORD *)i + 4) == a2)
            return;
        }
        else
        {
          if (v7.u32[0] > 1uLL)
          {
            if (v11 >= v6)
              v11 %= v6;
          }
          else
          {
            v11 &= v6 - 1;
          }
          if (v11 != v8)
            break;
        }
      }
    }
  }
  else
  {
    v8 = 0;
  }
  v12 = operator new(0x18uLL);
  *v12 = 0;
  v12[1] = v5;
  *((_DWORD *)v12 + 4) = a3;
  v13 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v14 = *(float *)(a1 + 32);
  if (!v6 || (float)(v14 * (float)v6) < v13)
  {
    v15 = 1;
    if (v6 >= 3)
      v15 = (v6 & (v6 - 1)) != 0;
    v16 = v15 | (2 * v6);
    v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17)
      v18 = v17;
    else
      v18 = v16;
    std::__hash_table<std::__hash_value_type<std::string,int>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,int>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,int>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,int>>>::__rehash<true>(a1, v18);
    v6 = *(_QWORD *)(a1 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v6 <= v5)
        v8 = v5 % v6;
      else
        v8 = v5;
    }
    else
    {
      v8 = (v6 - 1) & v5;
    }
  }
  v19 = *(_QWORD *)a1;
  v20 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v8);
  if (v20)
  {
    *v12 = *v20;
LABEL_38:
    *v20 = v12;
    goto LABEL_39;
  }
  *v12 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v12;
  *(_QWORD *)(v19 + 8 * v8) = a1 + 16;
  if (*v12)
  {
    v21 = *(_QWORD *)(*v12 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v21 >= v6)
        v21 %= v6;
    }
    else
    {
      v21 &= v6 - 1;
    }
    v20 = (_QWORD *)(*(_QWORD *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
}

void sub_1B85A8848(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::unordered_map<std::string,std::vector<int>>::~unordered_map[abi:nn180100](uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;

  v2 = *(_QWORD **)(a1 + 16);
  if (v2)
  {
    do
    {
      v3 = (_QWORD *)*v2;
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::vector<int>>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v4)
    operator delete(v4);
  return a1;
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::find<std::string>(uint64_t a1)
{
  unsigned __int8 *v1;
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint8x8_t v7;
  unint64_t v8;
  unint64_t v9;
  unsigned __int8 **v10;
  unsigned __int8 *i;
  unint64_t v12;

  v1 = (unsigned __int8 *)a1;
  v2 = *(_QWORD *)(a1 + 8);
  if (*(char *)(a1 + 23) >= 0)
  {
    v3 = *(unsigned __int8 *)(a1 + 23);
  }
  else
  {
    a1 = *(_QWORD *)a1;
    v3 = v2;
  }
  v4 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t *)a1, v3);
  v5 = *((_QWORD *)&SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 1);
  if (!*((_QWORD *)&SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 1))
    return 0;
  v6 = v4;
  v7 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 8));
  v7.i16[0] = vaddlv_u8(v7);
  v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    v9 = v4;
    if (v4 >= *((_QWORD *)&SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 1))
      v9 = v4 % *((_QWORD *)&SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 1);
  }
  else
  {
    v9 = (*((_QWORD *)&SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 1) - 1) & v4;
  }
  v10 = *(unsigned __int8 ***)(SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 8 * v9);
  if (!v10)
    return 0;
  for (i = *v10; i; i = *(unsigned __int8 **)i)
  {
    v12 = *((_QWORD *)i + 1);
    if (v6 == v12)
    {
      if (std::equal_to<std::string>::operator()[abi:nn180100](i + 16, v1))
        return i;
    }
    else
    {
      if (v8 > 1)
      {
        if (v12 >= v5)
          v12 %= v5;
      }
      else
      {
        v12 &= v5 - 1;
      }
      if (v12 != v9)
        return 0;
    }
  }
  return i;
}

void ___ZL29SpotlightU2AttributesToArgIDsv_block_invoke()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  void *__p[2];
  char v59;
  __int128 __src;
  int v61;
  _BYTE v62[12];

  *(_QWORD *)&v62[4] = *MEMORY[0x1E0C80C00];
  std::string::basic_string[abi:nn180100]<0>(__p, "default");
  v0 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v0 + 40), 0, 0, 0);
  if (v59 < 0)
    operator delete(__p[0]);
  LODWORD(__src) = 2;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemContactKeywords");
  v1 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v1 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  LODWORD(__src) = 2;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemPhotosPeopleNames");
  v2 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v2 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  LODWORD(__src) = 2;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemAuthorAddresses");
  v3 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v3 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  *(_QWORD *)&__src = 0x200000004;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemRecipientAddresses");
  v4 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v4 + 40), (char *)&__src, (uint64_t)&__src + 8, 2uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  *(_QWORD *)&__src = 0x200000003;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemAuthors");
  v5 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v5 + 40), (char *)&__src, (uint64_t)&__src + 8, 2uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  LODWORD(__src) = 3;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemUserSharedReceivedSender");
  v6 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v6 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  *(_QWORD *)&__src = 0x200000003;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemAuthorEmailAddresses");
  v7 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v7 + 40), (char *)&__src, (uint64_t)&__src + 8, 2uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  LODWORD(__src) = 3;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemUserSharedReceivedSenderHandle");
  v8 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v8 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  *(_QWORD *)&__src = 0x200000004;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemRecipients");
  v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v9 + 40), (char *)&__src, (uint64_t)&__src + 8, 2uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  *(_QWORD *)&__src = 0x200000004;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemPrimaryRecipients");
  v10 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v10 + 40), (char *)&__src, (uint64_t)&__src + 8, 2uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  LODWORD(__src) = 4;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemUserSharedReceivedRecipient");
  v11 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v11 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  LODWORD(__src) = 4;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemUserSharedSentRecipient");
  v12 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v12 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  *(_QWORD *)&__src = 0x200000004;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemRecipientEmailAddresses");
  v13 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v13 + 40), (char *)&__src, (uint64_t)&__src + 8, 2uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  *(_QWORD *)&__src = 0x200000004;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemPrimaryRecipientEmailAddresses");
  v14 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v14 + 40), (char *)&__src, (uint64_t)&__src + 8, 2uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  LODWORD(__src) = 4;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemUserSharedReceivedRecipientHandle");
  v15 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v15 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  __src = xmmword_1B8631468;
  v61 = 9;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemContentTypeTree");
  v16 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v16 + 40), (char *)&__src, (uint64_t)v62, 5uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  LODWORD(__src) = 16;
  std::string::basic_string[abi:nn180100]<0>(__p, "com_apple_mail_flagged");
  v17 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v17 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  *(_QWORD *)&__src = 0x2B00000010;
  DWORD2(__src) = 17;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemUserTags");
  v18 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v18 + 40), (char *)&__src, (uint64_t)&__src + 12, 3uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  LODWORD(__src) = 36;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemIsShared");
  v19 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v19 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  LODWORD(__src) = 36;
  std::string::basic_string[abi:nn180100]<0>(__p, "_ICItemIsShared");
  v20 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v20 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  LODWORD(__src) = 36;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemSharedItemCurrentUserRole");
  v21 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v21 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  *(_QWORD *)&__src = 0x2500000024;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemUserSharedSentTransport");
  v22 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v22 + 40), (char *)&__src, (uint64_t)&__src + 8, 2uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  LODWORD(__src) = 36;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemUserSharedReceivedTransport");
  v23 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v23 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  LODWORD(__src) = 44;
  std::string::basic_string[abi:nn180100]<0>(__p, "com_apple_mail_flagColor");
  v24 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v24 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  LODWORD(__src) = 24;
  std::string::basic_string[abi:nn180100]<0>(__p, "com_apple_mail_repliedTo");
  v25 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v25 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  *(_QWORD *)&__src = 0x1D0000001CLL;
  std::string::basic_string[abi:nn180100]<0>(__p, "com_apple_mail_read");
  v26 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v26 + 40), (char *)&__src, (uint64_t)&__src + 8, 2uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  __src = xmmword_1B8631490;
  v61 = 26;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemMailboxes");
  v27 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v27 + 40), (char *)&__src, (uint64_t)v62, 5uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  LODWORD(__src) = 8;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemContentCreationDate");
  v28 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v28 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  LODWORD(__src) = 8;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemContentModificationDate");
  v29 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v29 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  LODWORD(__src) = 8;
  std::string::basic_string[abi:nn180100]<0>(__p, "com_apple_mail_dateReceived");
  v30 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v30 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  LODWORD(__src) = 8;
  std::string::basic_string[abi:nn180100]<0>(__p, "com_apple_mail_dateSent");
  v31 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v31 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  LODWORD(__src) = 8;
  std::string::basic_string[abi:nn180100]<0>(__p, "com_apple_mail_dateLastViewed");
  v32 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v32 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  LODWORD(__src) = 8;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemEndDate");
  v33 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v33 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  *(_QWORD *)&__src = 0x3300000008;
  DWORD2(__src) = 52;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemStartDate");
  v34 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v34 + 40), (char *)&__src, (uint64_t)&__src + 12, 3uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  LODWORD(__src) = 8;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemLastUsedDate");
  v35 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v35 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  LODWORD(__src) = 8;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemUsedDates");
  v36 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v36 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  LODWORD(__src) = 8;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemDownloadDate");
  v37 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v37 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  LODWORD(__src) = 8;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemUserPrintedDate");
  v38 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v38 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  LODWORD(__src) = 8;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemUserSharedReceivedDate");
  v39 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v39 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  LODWORD(__src) = 8;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemUserSharedSentDate");
  v40 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v40 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  *(_QWORD *)&__src = 0x400000003ALL;
  DWORD2(__src) = 67;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemEventType");
  v41 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v41 + 40), (char *)&__src, (uint64_t)&__src + 12, 3uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  __src = xmmword_1B8631FA0;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemEventFlightArrivalAirportName");
  v42 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v42 + 40), (char *)&__src, (uint64_t)&v61, 4uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  __src = xmmword_1B8631FA0;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemEventFlightArrivalAirportCode");
  v43 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v43 + 40), (char *)&__src, (uint64_t)&v61, 4uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  __src = xmmword_1B8631FA0;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemEventFlightArrivalAirportLocality");
  v44 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v44 + 40), (char *)&__src, (uint64_t)&v61, 4uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  __src = xmmword_1B8631FB0;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemEventFlightDepartureAirportName");
  v45 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v45 + 40), (char *)&__src, (uint64_t)&v61, 4uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  __src = xmmword_1B8631FB0;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemEventFlightDepartureAirportCode");
  v46 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v46 + 40), (char *)&__src, (uint64_t)&v61, 4uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  __src = xmmword_1B8631FB0;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemEventFlightDepartureAirportLocality");
  v47 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v47 + 40), (char *)&__src, (uint64_t)&v61, 4uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  *(_QWORD *)&__src = 0x3C0000003BLL;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemEventFlightCarrier");
  v48 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v48 + 40), (char *)&__src, (uint64_t)&__src + 8, 2uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  LODWORD(__src) = 66;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemEventHotelReservationForName");
  v49 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v49 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  LODWORD(__src) = 65;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemEventHotelProvider");
  v50 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v50 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  LODWORD(__src) = 68;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemEventRestaurantReservationForName");
  v51 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v51 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  *(_QWORD *)&__src = 0x800000021;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemDueDate");
  v52 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v52 + 40), (char *)&__src, (uint64_t)&__src + 8, 2uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  *(_QWORD *)&__src = 0x800000022;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemCompletionDate");
  v53 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v53 + 40), (char *)&__src, (uint64_t)&__src + 8, 2uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  LODWORD(__src) = 31;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemIsLikelyJunk");
  v54 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v54 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  LODWORD(__src) = 17;
  std::string::basic_string[abi:nn180100]<0>(__p, "_ICItemHasICItemHasTags");
  v55 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v55 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  LODWORD(__src) = 17;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemHashtags");
  v56 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v56 + 40), (char *)&__src, (uint64_t)&__src + 4, 1uLL);
  if (v59 < 0)
    operator delete(__p[0]);
  *(_QWORD *)&__src = 0x1400000012;
  DWORD2(__src) = 19;
  std::string::basic_string[abi:nn180100]<0>(__p, "kMDItemAttachmentTypes");
  v57 = std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t)__p, (uint64_t)__p);
  std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>((char *)(v57 + 40), (char *)&__src, (uint64_t)&__src + 12, 3uLL);
  if (v59 < 0)
    operator delete(__p[0]);
}

void sub_1B85A9BA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, _Unwind_Exception *exception_object, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<std::__hash_value_type<std::string,std::vector<int>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<int>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<int>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(uint64_t a1, uint64_t a2)
{
  unsigned __int8 *v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint8x8_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t *v12;
  uint64_t i;
  unint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  float v17;
  _BOOL8 v18;
  unint64_t v19;
  unint64_t v20;
  int8x8_t prime;
  void *v22;
  void *v23;
  uint64_t v24;
  _QWORD **v25;
  unint64_t v26;
  uint8x8_t v27;
  unint64_t v28;
  uint8x8_t v29;
  uint64_t v30;
  _QWORD *j;
  unint64_t v32;
  uint64_t *v33;
  unint64_t v34;
  void *v36;
  _QWORD v37[3];

  v3 = (unsigned __int8 *)a1;
  v4 = *(_QWORD *)(a1 + 8);
  if (*(char *)(a1 + 23) >= 0)
  {
    v5 = *(unsigned __int8 *)(a1 + 23);
  }
  else
  {
    a1 = *(_QWORD *)a1;
    v5 = v4;
  }
  v6 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t *)a1, v5);
  v7 = v6;
  v8 = *((_QWORD *)&SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 1);
  if (*((_QWORD *)&SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 1))
  {
    v9 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs
                                        + 8));
    v9.i16[0] = vaddlv_u8(v9);
    v10 = v9.u32[0];
    if (v9.u32[0] > 1uLL)
    {
      v11 = v6;
      if (v6 >= *((_QWORD *)&SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 1))
        v11 = v6 % *((_QWORD *)&SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 1);
    }
    else
    {
      v11 = (*((_QWORD *)&SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 1) - 1) & v6;
    }
    v12 = *(uint64_t **)(SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 8 * v11);
    if (v12)
    {
      for (i = *v12; i; i = *(_QWORD *)i)
      {
        v14 = *(_QWORD *)(i + 8);
        if (v14 == v7)
        {
          if (std::equal_to<std::string>::operator()[abi:nn180100]((unsigned __int8 *)(i + 16), v3))
            return i;
        }
        else
        {
          if (v10 > 1)
          {
            if (v14 >= v8)
              v14 %= v8;
          }
          else
          {
            v14 &= v8 - 1;
          }
          if (v14 != v11)
            break;
        }
      }
    }
  }
  else
  {
    v11 = 0;
  }
  v37[2] = 1;
  v15 = operator new(0x40uLL);
  v37[0] = v15;
  v37[1] = &qword_1EF1AD1E0;
  *v15 = 0;
  v15[1] = v7;
  *((_OWORD *)v15 + 1) = *(_OWORD *)a2;
  v16 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  v15[4] = v16;
  v15[5] = 0;
  v15[6] = 0;
  v15[7] = 0;
  v17 = (float)(unint64_t)(qword_1EF1AD1E8 + 1);
  if (!v8 || (float)(*(float *)&dword_1EF1AD1F0 * (float)v8) < v17)
  {
    v18 = 1;
    if (v8 >= 3)
      v18 = (v8 & (v8 - 1)) != 0;
    v19 = v18 | (2 * v8);
    v20 = vcvtps_u32_f32(v17 / *(float *)&dword_1EF1AD1F0);
    if (v19 <= v20)
      prime = (int8x8_t)v20;
    else
      prime = (int8x8_t)v19;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
    }
    v8 = *((_QWORD *)&SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 1);
    if (*(_QWORD *)&prime > *((_QWORD *)&SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 1))
      goto LABEL_33;
    if (*(_QWORD *)&prime < *((_QWORD *)&SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 1))
    {
      v28 = vcvtps_u32_f32((float)(unint64_t)qword_1EF1AD1E8 / *(float *)&dword_1EF1AD1F0);
      if (*((_QWORD *)&SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 1) < 3uLL
        || (v29 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs
                                                 + 8)),
            v29.i16[0] = vaddlv_u8(v29),
            v29.u32[0] > 1uLL))
      {
        v28 = std::__next_prime(v28);
      }
      else
      {
        v30 = 1 << -(char)__clz(v28 - 1);
        if (v28 >= 2)
          v28 = v30;
      }
      if (*(_QWORD *)&prime <= v28)
        prime = (int8x8_t)v28;
      if (*(_QWORD *)&prime >= v8)
      {
        v8 = *((_QWORD *)&SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 1);
      }
      else
      {
        if (prime)
        {
LABEL_33:
          if (*(_QWORD *)&prime >> 61)
            std::__throw_bad_array_new_length[abi:nn180100]();
          v22 = operator new(8 * *(_QWORD *)&prime);
          v23 = (void *)SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs;
          *(_QWORD *)&SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs = v22;
          if (v23)
            operator delete(v23);
          v24 = 0;
          *((int8x8_t *)&SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 1) = prime;
          do
            *(_QWORD *)(SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 8 * v24++) = 0;
          while (*(_QWORD *)&prime != v24);
          v25 = (_QWORD **)qword_1EF1AD1E0;
          if (qword_1EF1AD1E0)
          {
            v26 = *(_QWORD *)(qword_1EF1AD1E0 + 8);
            v27 = (uint8x8_t)vcnt_s8(prime);
            v27.i16[0] = vaddlv_u8(v27);
            if (v27.u32[0] > 1uLL)
            {
              if (v26 >= *(_QWORD *)&prime)
                v26 %= *(_QWORD *)&prime;
            }
            else
            {
              v26 &= *(_QWORD *)&prime - 1;
            }
            *(_QWORD *)(SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 8 * v26) = &qword_1EF1AD1E0;
            for (j = *v25; j; v26 = v32)
            {
              v32 = j[1];
              if (v27.u32[0] > 1uLL)
              {
                if (v32 >= *(_QWORD *)&prime)
                  v32 %= *(_QWORD *)&prime;
              }
              else
              {
                v32 &= *(_QWORD *)&prime - 1;
              }
              if (v32 != v26)
              {
                if (!*(_QWORD *)(SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 8 * v32))
                {
                  *(_QWORD *)(SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 8 * v32) = v25;
                  goto LABEL_58;
                }
                *v25 = (_QWORD *)*j;
                *j = **(_QWORD **)(SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 8 * v32);
                **(_QWORD **)(SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 8 * v32) = j;
                j = v25;
              }
              v32 = v26;
LABEL_58:
              v25 = (_QWORD **)j;
              j = (_QWORD *)*j;
            }
          }
          v8 = (unint64_t)prime;
          goto LABEL_62;
        }
        v36 = (void *)SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs;
        *(_QWORD *)&SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs = 0;
        if (v36)
          operator delete(v36);
        v8 = 0;
        *((_QWORD *)&SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 1) = 0;
      }
    }
LABEL_62:
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8)
        v11 = v7 % v8;
      else
        v11 = v7;
    }
    else
    {
      v11 = (v8 - 1) & v7;
    }
  }
  v33 = *(uint64_t **)(SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 8 * v11);
  i = v37[0];
  if (v33)
  {
    *(_QWORD *)v37[0] = *v33;
LABEL_75:
    *v33 = i;
    goto LABEL_76;
  }
  *(_QWORD *)v37[0] = qword_1EF1AD1E0;
  qword_1EF1AD1E0 = i;
  *(_QWORD *)(SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 8 * v11) = &qword_1EF1AD1E0;
  if (*(_QWORD *)i)
  {
    v34 = *(_QWORD *)(*(_QWORD *)i + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v34 >= v8)
        v34 %= v8;
    }
    else
    {
      v34 &= v8 - 1;
    }
    v33 = (uint64_t *)(SpotlightU2AttributesToArgIDs(void)::_spotlightU2AttributesToArgIDs + 8 * v34);
    goto LABEL_75;
  }
LABEL_76:
  v37[0] = 0;
  ++qword_1EF1AD1E8;
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<int>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<int>>,void *>>>>::reset[abi:nn180100]((uint64_t)v37);
  return i;
}

void sub_1B85AA110(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<int>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<int>>,void *>>>>::reset[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

char *std::vector<int>::__assign_with_size[abi:nn180100]<int const*,int const*>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  void **v12;
  char *v13;
  _BYTE *v14;
  unint64_t v15;
  char *v16;
  size_t v17;
  void *v18;
  char *v19;

  v7 = result;
  v8 = *((_QWORD *)result + 2);
  v9 = *(char **)result;
  if (a4 > (v8 - *(_QWORD *)result) >> 2)
  {
    if (v9)
    {
      *((_QWORD *)result + 1) = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    v10 = v8 >> 1;
    if (v8 >> 1 <= a4)
      v10 = a4;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFFCLL)
      v11 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    result = std::vector<int>::__vallocate[abi:nn180100](v7, v11);
    v13 = (char *)v7[1];
    v12 = (void **)(v7 + 1);
    v9 = v13;
LABEL_15:
    v17 = a3 - (_QWORD)__src;
    if (v17)
    {
      v18 = v9;
      v19 = __src;
      goto LABEL_17;
    }
    goto LABEL_18;
  }
  v12 = (void **)(result + 8);
  v14 = (_BYTE *)*((_QWORD *)result + 1);
  v15 = (v14 - v9) >> 2;
  if (v15 >= a4)
    goto LABEL_15;
  v16 = &__src[4 * v15];
  if (v14 != v9)
  {
    result = (char *)memmove(*(void **)result, __src, v14 - v9);
    v9 = (char *)*v12;
  }
  v17 = a3 - (_QWORD)v16;
  if (v17)
  {
    v18 = v9;
    v19 = v16;
LABEL_17:
    result = (char *)memmove(v18, v19, v17);
  }
LABEL_18:
  *v12 = &v9[v17];
  return result;
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,std::vector<int>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,std::vector<int>>,void *>>>>::reset[abi:nn180100](uint64_t a1)
{
  void *v1;

  v1 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v1)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::vector<int>>,0>((uint64_t)v1 + 16);
    operator delete(v1);
  }
}

void std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::vector<int>>,0>(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(_QWORD *)(a1 + 32) = v2;
    operator delete(v2);
  }
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

uint64_t fetchLLMTokenDescription(int *a1, const __CFDictionary *a2, NSAttributedString *a3)
{
  const void *v6;
  void *Value;
  uint64_t v8;
  uint64_t i;
  int v10;
  int v11;
  const void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v19;
  uint64_t v20;
  uint64_t (*v21)(uint64_t, void *, uint64_t, uint64_t, _BYTE *);
  _QWORD v22[5];
  _QWORD v23[5];
  _QWORD v24[5];
  _QWORD v25[5];
  _QWORD v26[5];
  _QWORD v27[5];
  _QWORD v28[5];
  _QWORD v29[5];
  _QWORD v30[5];
  _QWORD v31[5];
  _QWORD v32[5];
  _QWORD v33[5];
  _QWORD v34[5];
  _QWORD v35[5];
  _QWORD v36[5];
  _QWORD v37[5];
  _QWORD v38[5];
  _QWORD v39[5];
  _QWORD v40[5];
  _QWORD v41[5];
  _QWORD v42[5];
  _QWORD v43[5];
  _QWORD v44[5];
  _QWORD v45[5];
  _QWORD v46[5];
  _QWORD v47[5];
  _QWORD v48[5];
  _QWORD v49[5];
  _QWORD v50[5];
  _QWORD v51[5];
  _QWORD v52[5];
  _QWORD v53[5];
  _QWORD v54[5];
  _QWORD v55[5];
  _QWORD v56[5];
  _QWORD v57[5];
  _QWORD v58[5];
  _QWORD v59[5];
  _QWORD v60[5];
  _QWORD v61[5];
  _QWORD v62[5];
  _QWORD v63[5];
  _QWORD v64[5];
  _QWORD v65[5];
  _QWORD v66[5];
  _QWORD v67[5];
  _QWORD v68[5];
  _QWORD v69[5];
  _QWORD v70[5];
  _QWORD v71[5];
  _QWORD v72[5];
  _QWORD v73[5];
  _QWORD v74[5];
  _QWORD v75[5];
  _QWORD v76[5];
  _QWORD v77[5];
  _QWORD v78[5];
  _QWORD v79[5];
  _QWORD v80[5];
  _QWORD v81[5];
  _QWORD v82[5];
  _QWORD v83[5];
  _QWORD v84[5];
  _QWORD v85[5];
  uint64_t v86;
  uint64_t *v87;
  uint64_t v88;
  void (*v89)(uint64_t, uint64_t);
  void (*v90)(uint64_t);
  uint64_t v91;

  v86 = 0;
  v87 = &v86;
  v88 = 0x3052000000;
  v89 = __Block_byref_object_copy__8636;
  v90 = __Block_byref_object_dispose__8637;
  v91 = 0;
  v6 = (const void *)getkQPQUOutputTokenArgIdsKey();
  Value = (void *)CFDictionaryGetValue(a2, v6);
  v8 = objc_msgSend(Value, "count");
  if (v8)
  {
    for (i = 0; v8 != i; ++i)
    {
      v10 = objc_msgSend((id)objc_msgSend(Value, "objectAtIndexedSubscript:", i), "intValue");
      v11 = v10;
      if (i)
      {
        if (v10)
          goto LABEL_7;
      }
      else
      {
        *a1 = v10;
        if (v10)
        {
LABEL_7:
          if (v87[5])
            break;
          v12 = (const void *)getkQPQUOutputTokenRangeKey();
          v14 = objc_msgSend((id)CFDictionaryGetValue(a2, v12), "rangeValue");
          if (v14 != 0x7FFFFFFFFFFFFFFFLL)
          {
            v15 = v13;
            if (v14 + v13 <= -[NSAttributedString length](a3, "length"))
            {
              switch(v11)
              {
                case 1:
                  v80[0] = MEMORY[0x1E0C809B0];
                  v80[1] = 3221225472;
                  v80[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_6;
                  v16 = v80;
                  goto LABEL_77;
                case 5:
                  v81[0] = MEMORY[0x1E0C809B0];
                  v81[1] = 3221225472;
                  v81[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_5;
                  v16 = v81;
                  goto LABEL_77;
                case 6:
                  v27[0] = MEMORY[0x1E0C809B0];
                  v27[1] = 3221225472;
                  v27[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_59;
                  v16 = v27;
                  goto LABEL_77;
                case 7:
                  v26[0] = MEMORY[0x1E0C809B0];
                  v26[1] = 3221225472;
                  v26[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_60;
                  v16 = v26;
                  goto LABEL_77;
                case 8:
                  v85[0] = MEMORY[0x1E0C809B0];
                  v85[1] = 3221225472;
                  v85[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke;
                  v16 = v85;
                  goto LABEL_77;
                case 9:
                  v68[0] = MEMORY[0x1E0C809B0];
                  v68[1] = 3221225472;
                  v68[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_18;
                  v16 = v68;
                  goto LABEL_77;
                case 10:
                  v67[0] = MEMORY[0x1E0C809B0];
                  v67[1] = 3221225472;
                  v67[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_19;
                  v16 = v67;
                  goto LABEL_77;
                case 11:
                  v66[0] = MEMORY[0x1E0C809B0];
                  v66[1] = 3221225472;
                  v66[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_20;
                  v16 = v66;
                  goto LABEL_77;
                case 12:
                  v65[0] = MEMORY[0x1E0C809B0];
                  v65[1] = 3221225472;
                  v65[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_21;
                  v16 = v65;
                  goto LABEL_77;
                case 13:
                  v64[0] = MEMORY[0x1E0C809B0];
                  v64[1] = 3221225472;
                  v64[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_22;
                  v16 = v64;
                  goto LABEL_77;
                case 14:
                  v63[0] = MEMORY[0x1E0C809B0];
                  v63[1] = 3221225472;
                  v63[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_23;
                  v16 = v63;
                  goto LABEL_77;
                case 15:
                  v84[0] = MEMORY[0x1E0C809B0];
                  v84[1] = 3221225472;
                  v84[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_2;
                  v16 = v84;
                  goto LABEL_77;
                case 16:
                  v83[0] = MEMORY[0x1E0C809B0];
                  v83[1] = 3221225472;
                  v83[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_3;
                  v16 = v83;
                  goto LABEL_77;
                case 17:
                  v82[0] = MEMORY[0x1E0C809B0];
                  v82[1] = 3221225472;
                  v82[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_4;
                  v16 = v82;
                  goto LABEL_77;
                case 18:
                  v62[0] = MEMORY[0x1E0C809B0];
                  v62[1] = 3221225472;
                  v62[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_24;
                  v16 = v62;
                  goto LABEL_77;
                case 19:
                  v79[0] = MEMORY[0x1E0C809B0];
                  v79[1] = 3221225472;
                  v79[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_7;
                  v16 = v79;
                  goto LABEL_77;
                case 20:
                  v61[0] = MEMORY[0x1E0C809B0];
                  v61[1] = 3221225472;
                  v61[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_25;
                  v16 = v61;
                  goto LABEL_77;
                case 21:
                  v78[0] = MEMORY[0x1E0C809B0];
                  v78[1] = 3221225472;
                  v78[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_8;
                  v16 = v78;
                  goto LABEL_77;
                case 22:
                  v60[0] = MEMORY[0x1E0C809B0];
                  v60[1] = 3221225472;
                  v60[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_26;
                  v16 = v60;
                  goto LABEL_77;
                case 23:
                  v59[0] = MEMORY[0x1E0C809B0];
                  v59[1] = 3221225472;
                  v59[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_27;
                  v16 = v59;
                  goto LABEL_77;
                case 24:
                  v58[0] = MEMORY[0x1E0C809B0];
                  v58[1] = 3221225472;
                  v58[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_28;
                  v16 = v58;
                  goto LABEL_77;
                case 25:
                  v25[0] = MEMORY[0x1E0C809B0];
                  v25[1] = 3221225472;
                  v25[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_61;
                  v16 = v25;
                  goto LABEL_77;
                case 26:
                  v57[0] = MEMORY[0x1E0C809B0];
                  v57[1] = 3221225472;
                  v57[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_29;
                  v16 = v57;
                  goto LABEL_77;
                case 27:
                  v56[0] = MEMORY[0x1E0C809B0];
                  v56[1] = 3221225472;
                  v56[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_30;
                  v16 = v56;
                  goto LABEL_77;
                case 28:
                  v55[0] = MEMORY[0x1E0C809B0];
                  v55[1] = 3221225472;
                  v55[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_31;
                  v16 = v55;
                  goto LABEL_77;
                case 29:
                  v24[0] = MEMORY[0x1E0C809B0];
                  v24[1] = 3221225472;
                  v24[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_62;
                  v16 = v24;
                  goto LABEL_77;
                case 30:
                  v54[0] = MEMORY[0x1E0C809B0];
                  v54[1] = 3221225472;
                  v54[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_32;
                  v16 = v54;
                  goto LABEL_77;
                case 31:
                  v53[0] = MEMORY[0x1E0C809B0];
                  v53[1] = 3221225472;
                  v53[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_33;
                  v16 = v53;
                  goto LABEL_77;
                case 32:
                  v52[0] = MEMORY[0x1E0C809B0];
                  v52[1] = 3221225472;
                  v52[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_34;
                  v16 = v52;
                  goto LABEL_77;
                case 33:
                  v51[0] = MEMORY[0x1E0C809B0];
                  v51[1] = 3221225472;
                  v51[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_35;
                  v16 = v51;
                  goto LABEL_77;
                case 34:
                  v50[0] = MEMORY[0x1E0C809B0];
                  v50[1] = 3221225472;
                  v50[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_36;
                  v16 = v50;
                  goto LABEL_77;
                case 35:
                  v23[0] = MEMORY[0x1E0C809B0];
                  v23[1] = 3221225472;
                  v23[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_63;
                  v16 = v23;
                  goto LABEL_77;
                case 36:
                  v49[0] = MEMORY[0x1E0C809B0];
                  v49[1] = 3221225472;
                  v49[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_37;
                  v16 = v49;
                  goto LABEL_77;
                case 37:
                  v48[0] = MEMORY[0x1E0C809B0];
                  v48[1] = 3221225472;
                  v48[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_38;
                  v16 = v48;
                  goto LABEL_77;
                case 38:
                  v47[0] = MEMORY[0x1E0C809B0];
                  v47[1] = 3221225472;
                  v47[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_39;
                  v16 = v47;
                  goto LABEL_77;
                case 39:
                  v46[0] = MEMORY[0x1E0C809B0];
                  v46[1] = 3221225472;
                  v46[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_40;
                  v16 = v46;
                  goto LABEL_77;
                case 40:
                  v45[0] = MEMORY[0x1E0C809B0];
                  v45[1] = 3221225472;
                  v45[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_41;
                  v16 = v45;
                  goto LABEL_77;
                case 41:
                  v77[0] = MEMORY[0x1E0C809B0];
                  v77[1] = 3221225472;
                  v77[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_9;
                  v16 = v77;
                  goto LABEL_77;
                case 42:
                  v76[0] = MEMORY[0x1E0C809B0];
                  v76[1] = 3221225472;
                  v76[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_10;
                  v16 = v76;
                  goto LABEL_77;
                case 43:
                  v44[0] = MEMORY[0x1E0C809B0];
                  v44[1] = 3221225472;
                  v44[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_42;
                  v16 = v44;
                  goto LABEL_77;
                case 44:
                  v75[0] = MEMORY[0x1E0C809B0];
                  v75[1] = 3221225472;
                  v75[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_11;
                  v16 = v75;
                  goto LABEL_77;
                case 45:
                  v43[0] = MEMORY[0x1E0C809B0];
                  v43[1] = 3221225472;
                  v43[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_43;
                  v16 = v43;
                  goto LABEL_77;
                case 46:
                  v42[0] = MEMORY[0x1E0C809B0];
                  v42[1] = 3221225472;
                  v42[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_44;
                  v16 = v42;
                  goto LABEL_77;
                case 47:
                  v41[0] = MEMORY[0x1E0C809B0];
                  v41[1] = 3221225472;
                  v41[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_45;
                  v16 = v41;
                  goto LABEL_77;
                case 48:
                  v40[0] = MEMORY[0x1E0C809B0];
                  v40[1] = 3221225472;
                  v40[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_46;
                  v16 = v40;
                  goto LABEL_77;
                case 49:
                  v39[0] = MEMORY[0x1E0C809B0];
                  v39[1] = 3221225472;
                  v39[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_47;
                  v16 = v39;
                  goto LABEL_77;
                case 51:
                  v38[0] = MEMORY[0x1E0C809B0];
                  v38[1] = 3221225472;
                  v38[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_48;
                  v16 = v38;
                  goto LABEL_77;
                case 52:
                  v74[0] = MEMORY[0x1E0C809B0];
                  v74[1] = 3221225472;
                  v74[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_12;
                  v16 = v74;
                  goto LABEL_77;
                case 53:
                  v37[0] = MEMORY[0x1E0C809B0];
                  v37[1] = 3221225472;
                  v37[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_49;
                  v16 = v37;
                  goto LABEL_77;
                case 54:
                  v73[0] = MEMORY[0x1E0C809B0];
                  v73[1] = 3221225472;
                  v73[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_13;
                  v16 = v73;
                  goto LABEL_77;
                case 55:
                  v72[0] = MEMORY[0x1E0C809B0];
                  v72[1] = 3221225472;
                  v72[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_14;
                  v16 = v72;
                  goto LABEL_77;
                case 56:
                  v71[0] = MEMORY[0x1E0C809B0];
                  v71[1] = 3221225472;
                  v71[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_15;
                  v16 = v71;
                  goto LABEL_77;
                case 57:
                  v70[0] = MEMORY[0x1E0C809B0];
                  v70[1] = 3221225472;
                  v70[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_16;
                  v16 = v70;
                  goto LABEL_77;
                case 58:
                  v69[0] = MEMORY[0x1E0C809B0];
                  v69[1] = 3221225472;
                  v69[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_17;
                  v16 = v69;
                  goto LABEL_77;
                case 59:
                  v36[0] = MEMORY[0x1E0C809B0];
                  v36[1] = 3221225472;
                  v36[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_50;
                  v16 = v36;
                  goto LABEL_77;
                case 60:
                  v35[0] = MEMORY[0x1E0C809B0];
                  v35[1] = 3221225472;
                  v35[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_51;
                  v16 = v35;
                  goto LABEL_77;
                case 61:
                  v22[0] = MEMORY[0x1E0C809B0];
                  v22[1] = 3221225472;
                  v22[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_64;
                  v16 = v22;
                  goto LABEL_77;
                case 63:
                  v34[0] = MEMORY[0x1E0C809B0];
                  v34[1] = 3221225472;
                  v34[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_52;
                  v16 = v34;
                  goto LABEL_77;
                case 64:
                  v33[0] = MEMORY[0x1E0C809B0];
                  v33[1] = 3221225472;
                  v33[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_53;
                  v16 = v33;
                  goto LABEL_77;
                case 65:
                  v32[0] = MEMORY[0x1E0C809B0];
                  v32[1] = 3221225472;
                  v32[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_54;
                  v16 = v32;
                  goto LABEL_77;
                case 66:
                  v31[0] = MEMORY[0x1E0C809B0];
                  v31[1] = 3221225472;
                  v31[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_55;
                  v16 = v31;
                  goto LABEL_77;
                case 67:
                  v30[0] = MEMORY[0x1E0C809B0];
                  v30[1] = 3221225472;
                  v30[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_56;
                  v16 = v30;
                  goto LABEL_77;
                case 68:
                  v29[0] = MEMORY[0x1E0C809B0];
                  v29[1] = 3221225472;
                  v29[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_57;
                  v16 = v29;
                  goto LABEL_77;
                case 69:
                  v28[0] = MEMORY[0x1E0C809B0];
                  v28[1] = 3221225472;
                  v28[2] = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_58;
                  v16 = v28;
                  goto LABEL_77;
                default:
                  if (v11 != 62)
                    break;
                  v19 = MEMORY[0x1E0C809B0];
                  v20 = 3221225472;
                  v16 = &v19;
                  v21 = ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_65;
LABEL_77:
                  v16[3] = (uint64_t)&unk_1E6E35EB0;
                  v16[4] = (uint64_t)&v86;
                  -[NSAttributedString enumerateAttributesInRange:options:usingBlock:](a3, "enumerateAttributesInRange:options:usingBlock:", v14, v15, 0, v19, v20, v21);
                  break;
              }
            }
          }
        }
      }
    }
  }
  v17 = v87[5];
  _Block_object_dispose(&v86, 8);
  return v17;
}

void sub_1B85AAD54(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 152), 8);
  _Unwind_Resume(a1);
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void *v9;
  const void *v10;
  const void *v11;
  id v12;

  result = objc_msgSend(a2, "count");
  if (a2)
  {
    if (result)
    {
      v9 = (const void *)getkQPParseAttributeDateKey();
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, v9);
      if ((_DWORD)result)
      {
        v10 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v10);
        if ((_DWORD)result)
        {
          v11 = (const void *)getkQPParseAttributeDescriptionKey();
          v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v12;
          result = (uint64_t)v12;
          *a5 = 1;
        }
      }
    }
  }
  return result;
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_2(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void *v9;
  const void *v10;
  const void *v11;
  id v12;

  result = objc_msgSend(a2, "count");
  if (a2)
  {
    if (result)
    {
      v9 = (const void *)getkQPParseAttributeFlightActionKey();
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, v9);
      if ((_DWORD)result)
      {
        v10 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v10);
        if ((_DWORD)result)
        {
          v11 = (const void *)getkQPParseAttributeDescriptionKey();
          v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v12;
          result = (uint64_t)v12;
          *a5 = 1;
        }
      }
    }
  }
  return result;
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_3(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void *v9;
  const void *v10;
  const void *v11;
  id v12;

  result = objc_msgSend(a2, "count");
  if (a2)
  {
    if (result)
    {
      v9 = (const void *)getkQPParseAttributeHotelActionKey();
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, v9);
      if ((_DWORD)result)
      {
        v10 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v10);
        if ((_DWORD)result)
        {
          v11 = (const void *)getkQPParseAttributeDescriptionKey();
          v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v12;
          result = (uint64_t)v12;
          *a5 = 1;
        }
      }
    }
  }
  return result;
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_4(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void *v9;
  const void *v10;
  const void *v11;
  id v12;

  result = objc_msgSend(a2, "count");
  if (a2)
  {
    if (result)
    {
      v9 = (const void *)getkQPParseAttributeRestaurantActionKey();
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, v9);
      if ((_DWORD)result)
      {
        v10 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v10);
        if ((_DWORD)result)
        {
          v11 = (const void *)getkQPParseAttributeDescriptionKey();
          v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v12;
          result = (uint64_t)v12;
          *a5 = 1;
        }
      }
    }
  }
  return result;
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_5(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  const void *v12;
  id v13;
  void *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  result = objc_msgSend(a2, "count");
  if (a2 && result)
  {
    v15 = 0;
    v16 = &v15;
    v17 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeLocationKeySymbolLoc(void)::ptr;
    v18 = getkQPParseAttributeLocationKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeLocationKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeLocationKey");
      v16[3] = (uint64_t)v9;
      getkQPParseAttributeLocationKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v15, 8);
    if (v9)
    {
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, *v9);
      if ((_DWORD)result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v11);
        if ((_DWORD)result)
        {
          v12 = (const void *)getkQPParseAttributeDescriptionKey();
          v13 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v12);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v13;
          result = (uint64_t)v13;
          *a5 = 1;
        }
      }
    }
    else
    {
      v14 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeLocationKey()"), CFSTR("PRQUUtils.mm"), 38, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85AB104(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_6(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  const void *v12;
  id v13;
  void *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  result = objc_msgSend(a2, "count");
  if (a2 && result)
  {
    v15 = 0;
    v16 = &v15;
    v17 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeKeywordKeySymbolLoc(void)::ptr;
    v18 = getkQPParseAttributeKeywordKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeKeywordKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeKeywordKey");
      v16[3] = (uint64_t)v9;
      getkQPParseAttributeKeywordKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v15, 8);
    if (v9)
    {
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, *v9);
      if ((_DWORD)result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v11);
        if ((_DWORD)result)
        {
          v12 = (const void *)getkQPParseAttributeDescriptionKey();
          v13 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v12);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v13;
          result = (uint64_t)v13;
          *a5 = 1;
        }
      }
    }
    else
    {
      v14 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKeywordKey()"), CFSTR("PRQUUtils.mm"), 37, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85AB264(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_7(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  const void *v12;
  id v13;
  void *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  result = objc_msgSend(a2, "count");
  if (a2 && result)
  {
    v15 = 0;
    v16 = &v15;
    v17 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeKindMessageKeySymbolLoc(void)::ptr;
    v18 = getkQPParseAttributeKindMessageKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeKindMessageKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeKindMessageKey");
      v16[3] = (uint64_t)v9;
      getkQPParseAttributeKindMessageKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v15, 8);
    if (v9)
    {
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, *v9);
      if ((_DWORD)result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v11);
        if ((_DWORD)result)
        {
          v12 = (const void *)getkQPParseAttributeDescriptionKey();
          v13 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v12);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v13;
          result = (uint64_t)v13;
          *a5 = 1;
        }
      }
    }
    else
    {
      v14 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindMessageKey()"), CFSTR("PRQUUtils.mm"), 77, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85AB3C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_8(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  const void *v12;
  id v13;
  void *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  result = objc_msgSend(a2, "count");
  if (a2 && result)
  {
    v15 = 0;
    v16 = &v15;
    v17 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeKindPhotoKeySymbolLoc(void)::ptr;
    v18 = getkQPParseAttributeKindPhotoKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeKindPhotoKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeKindPhotoKey");
      v16[3] = (uint64_t)v9;
      getkQPParseAttributeKindPhotoKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v15, 8);
    if (v9)
    {
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, *v9);
      if ((_DWORD)result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v11);
        if ((_DWORD)result)
        {
          v12 = (const void *)getkQPParseAttributeDescriptionKey();
          v13 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v12);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v13;
          result = (uint64_t)v13;
          *a5 = 1;
        }
      }
    }
    else
    {
      v14 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindPhotoKey()"), CFSTR("PRQUUtils.mm"), 78, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85AB524(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_9(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  const void *v12;
  id v13;
  void *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  result = objc_msgSend(a2, "count");
  if (a2 && result)
  {
    v15 = 0;
    v16 = &v15;
    v17 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeFavoritedActionKeySymbolLoc(void)::ptr;
    v18 = getkQPParseAttributeFavoritedActionKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeFavoritedActionKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeFavoritedActionKey");
      v16[3] = (uint64_t)v9;
      getkQPParseAttributeFavoritedActionKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v15, 8);
    if (v9)
    {
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, *v9);
      if ((_DWORD)result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v11);
        if ((_DWORD)result)
        {
          v12 = (const void *)getkQPParseAttributeDescriptionKey();
          v13 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v12);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v13;
          result = (uint64_t)v13;
          *a5 = 1;
        }
      }
    }
    else
    {
      v14 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeFavoritedActionKey()"), CFSTR("PRQUUtils.mm"), 82, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85AB684(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_10(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  const void *v12;
  id v13;
  void *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  result = objc_msgSend(a2, "count");
  if (a2 && result)
  {
    v15 = 0;
    v16 = &v15;
    v17 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeHiddenActionKeySymbolLoc(void)::ptr;
    v18 = getkQPParseAttributeHiddenActionKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeHiddenActionKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeHiddenActionKey");
      v16[3] = (uint64_t)v9;
      getkQPParseAttributeHiddenActionKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v15, 8);
    if (v9)
    {
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, *v9);
      if ((_DWORD)result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v11);
        if ((_DWORD)result)
        {
          v12 = (const void *)getkQPParseAttributeDescriptionKey();
          v13 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v12);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v13;
          result = (uint64_t)v13;
          *a5 = 1;
        }
      }
    }
    else
    {
      v14 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeHiddenActionKey()"), CFSTR("PRQUUtils.mm"), 83, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85AB7E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_11(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  const void *v12;
  id v13;
  void *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  result = objc_msgSend(a2, "count");
  if (a2 && result)
  {
    v15 = 0;
    v16 = &v15;
    v17 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeForwardedActionKeySymbolLoc(void)::ptr;
    v18 = getkQPParseAttributeForwardedActionKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeForwardedActionKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeForwardedActionKey");
      v16[3] = (uint64_t)v9;
      getkQPParseAttributeForwardedActionKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v15, 8);
    if (v9)
    {
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, *v9);
      if ((_DWORD)result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v11);
        if ((_DWORD)result)
        {
          v12 = (const void *)getkQPParseAttributeDescriptionKey();
          v13 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v12);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v13;
          result = (uint64_t)v13;
          *a5 = 1;
        }
      }
    }
    else
    {
      v14 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeForwardedActionKey()"), CFSTR("PRQUUtils.mm"), 84, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85AB944(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_12(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  const void *v12;
  id v13;
  void *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  result = objc_msgSend(a2, "count");
  if (a2 && result)
  {
    v15 = 0;
    v16 = &v15;
    v17 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeSharedActionKeySymbolLoc(void)::ptr;
    v18 = getkQPParseAttributeSharedActionKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeSharedActionKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeSharedActionKey");
      v16[3] = (uint64_t)v9;
      getkQPParseAttributeSharedActionKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v15, 8);
    if (v9)
    {
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, *v9);
      if ((_DWORD)result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v11);
        if ((_DWORD)result)
        {
          v12 = (const void *)getkQPParseAttributeDescriptionKey();
          v13 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v12);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v13;
          result = (uint64_t)v13;
          *a5 = 1;
        }
      }
    }
    else
    {
      v14 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeSharedActionKey()"), CFSTR("PRQUUtils.mm"), 85, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85ABAA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_13(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  const void *v12;
  id v13;
  void *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  result = objc_msgSend(a2, "count");
  if (a2 && result)
  {
    v15 = 0;
    v16 = &v15;
    v17 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeDeletedActionKeySymbolLoc(void)::ptr;
    v18 = getkQPParseAttributeDeletedActionKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeDeletedActionKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeDeletedActionKey");
      v16[3] = (uint64_t)v9;
      getkQPParseAttributeDeletedActionKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v15, 8);
    if (v9)
    {
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, *v9);
      if ((_DWORD)result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v11);
        if ((_DWORD)result)
        {
          v12 = (const void *)getkQPParseAttributeDescriptionKey();
          v13 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v12);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v13;
          result = (uint64_t)v13;
          *a5 = 1;
        }
      }
    }
    else
    {
      v14 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeDeletedActionKey()"), CFSTR("PRQUUtils.mm"), 86, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85ABC04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_14(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void *v9;
  const void *v10;
  const void *v11;
  id v12;

  result = objc_msgSend(a2, "count");
  if (a2)
  {
    if (result)
    {
      v9 = (const void *)getkQPParseAttributeUnreadKey();
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, v9);
      if ((_DWORD)result)
      {
        v10 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v10);
        if ((_DWORD)result)
        {
          v11 = (const void *)getkQPParseAttributeDescriptionKey();
          v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v12;
          result = (uint64_t)v12;
          *a5 = 1;
        }
      }
    }
  }
  return result;
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_15(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  const void *v12;
  id v13;
  void *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  result = objc_msgSend(a2, "count");
  if (a2 && result)
  {
    v15 = 0;
    v16 = &v15;
    v17 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeAcceptedActionKeySymbolLoc(void)::ptr;
    v18 = getkQPParseAttributeAcceptedActionKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeAcceptedActionKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeAcceptedActionKey");
      v16[3] = (uint64_t)v9;
      getkQPParseAttributeAcceptedActionKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v15, 8);
    if (v9)
    {
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, *v9);
      if ((_DWORD)result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v11);
        if ((_DWORD)result)
        {
          v12 = (const void *)getkQPParseAttributeDescriptionKey();
          v13 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v12);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v13;
          result = (uint64_t)v13;
          *a5 = 1;
        }
      }
    }
    else
    {
      v14 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeAcceptedActionKey()"), CFSTR("PRQUUtils.mm"), 87, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85ABDF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_16(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  const void *v12;
  id v13;
  void *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  result = objc_msgSend(a2, "count");
  if (a2 && result)
  {
    v15 = 0;
    v16 = &v15;
    v17 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeDeclinedActionKeySymbolLoc(void)::ptr;
    v18 = getkQPParseAttributeDeclinedActionKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeDeclinedActionKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeDeclinedActionKey");
      v16[3] = (uint64_t)v9;
      getkQPParseAttributeDeclinedActionKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v15, 8);
    if (v9)
    {
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, *v9);
      if ((_DWORD)result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v11);
        if ((_DWORD)result)
        {
          v12 = (const void *)getkQPParseAttributeDescriptionKey();
          v13 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v12);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v13;
          result = (uint64_t)v13;
          *a5 = 1;
        }
      }
    }
    else
    {
      v14 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeDeclinedActionKey()"), CFSTR("PRQUUtils.mm"), 88, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85ABF54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_17(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  const void *v12;
  id v13;
  void *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  result = objc_msgSend(a2, "count");
  if (a2 && result)
  {
    v15 = 0;
    v16 = &v15;
    v17 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeMaybeActionKeySymbolLoc(void)::ptr;
    v18 = getkQPParseAttributeMaybeActionKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeMaybeActionKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeMaybeActionKey");
      v16[3] = (uint64_t)v9;
      getkQPParseAttributeMaybeActionKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v15, 8);
    if (v9)
    {
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, *v9);
      if ((_DWORD)result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v11);
        if ((_DWORD)result)
        {
          v12 = (const void *)getkQPParseAttributeDescriptionKey();
          v13 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v12);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v13;
          result = (uint64_t)v13;
          *a5 = 1;
        }
      }
    }
    else
    {
      v14 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeMaybeActionKey()"), CFSTR("PRQUUtils.mm"), 89, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85AC0B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_18(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  const void *v12;
  id v13;
  void *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  result = objc_msgSend(a2, "count");
  if (a2 && result)
  {
    v15 = 0;
    v16 = &v15;
    v17 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeTimeStartKeySymbolLoc(void)::ptr;
    v18 = getkQPParseAttributeTimeStartKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeTimeStartKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeTimeStartKey");
      v16[3] = (uint64_t)v9;
      getkQPParseAttributeTimeStartKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v15, 8);
    if (v9)
    {
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, *v9);
      if ((_DWORD)result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v11);
        if ((_DWORD)result)
        {
          v12 = (const void *)getkQPParseAttributeDescriptionKey();
          v13 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v12);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v13;
          result = (uint64_t)v13;
          *a5 = 1;
        }
      }
    }
    else
    {
      v14 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeTimeStartKey()"), CFSTR("PRQUUtils.mm"), 90, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85AC214(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_19(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  const void *v12;
  id v13;
  void *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  result = objc_msgSend(a2, "count");
  if (a2 && result)
  {
    v15 = 0;
    v16 = &v15;
    v17 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeTimeEndKeySymbolLoc(void)::ptr;
    v18 = getkQPParseAttributeTimeEndKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeTimeEndKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeTimeEndKey");
      v16[3] = (uint64_t)v9;
      getkQPParseAttributeTimeEndKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v15, 8);
    if (v9)
    {
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, *v9);
      if ((_DWORD)result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v11);
        if ((_DWORD)result)
        {
          v12 = (const void *)getkQPParseAttributeDescriptionKey();
          v13 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v12);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v13;
          result = (uint64_t)v13;
          *a5 = 1;
        }
      }
    }
    else
    {
      v14 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeTimeEndKey()"), CFSTR("PRQUUtils.mm"), 91, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85AC374(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_20(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  const void *v12;
  id v13;
  void *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  result = objc_msgSend(a2, "count");
  if (a2 && result)
  {
    v15 = 0;
    v16 = &v15;
    v17 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeTimeCreatedKeySymbolLoc(void)::ptr;
    v18 = getkQPParseAttributeTimeCreatedKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeTimeCreatedKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeTimeCreatedKey");
      v16[3] = (uint64_t)v9;
      getkQPParseAttributeTimeCreatedKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v15, 8);
    if (v9)
    {
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, *v9);
      if ((_DWORD)result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v11);
        if ((_DWORD)result)
        {
          v12 = (const void *)getkQPParseAttributeDescriptionKey();
          v13 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v12);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v13;
          result = (uint64_t)v13;
          *a5 = 1;
        }
      }
    }
    else
    {
      v14 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeTimeCreatedKey()"), CFSTR("PRQUUtils.mm"), 92, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85AC4D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_21(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  const void *v12;
  id v13;
  void *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  result = objc_msgSend(a2, "count");
  if (a2 && result)
  {
    v15 = 0;
    v16 = &v15;
    v17 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeTimeModifiedKeySymbolLoc(void)::ptr;
    v18 = getkQPParseAttributeTimeModifiedKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeTimeModifiedKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeTimeModifiedKey");
      v16[3] = (uint64_t)v9;
      getkQPParseAttributeTimeModifiedKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v15, 8);
    if (v9)
    {
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, *v9);
      if ((_DWORD)result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v11);
        if ((_DWORD)result)
        {
          v12 = (const void *)getkQPParseAttributeDescriptionKey();
          v13 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v12);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v13;
          result = (uint64_t)v13;
          *a5 = 1;
        }
      }
    }
    else
    {
      v14 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeTimeModifiedKey()"), CFSTR("PRQUUtils.mm"), 93, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85AC634(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_22(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  const void *v12;
  id v13;
  void *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  result = objc_msgSend(a2, "count");
  if (a2 && result)
  {
    v15 = 0;
    v16 = &v15;
    v17 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeTimeLastOpenedKeySymbolLoc(void)::ptr;
    v18 = getkQPParseAttributeTimeLastOpenedKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeTimeLastOpenedKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeTimeLastOpenedKey");
      v16[3] = (uint64_t)v9;
      getkQPParseAttributeTimeLastOpenedKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v15, 8);
    if (v9)
    {
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, *v9);
      if ((_DWORD)result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v11);
        if ((_DWORD)result)
        {
          v12 = (const void *)getkQPParseAttributeDescriptionKey();
          v13 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v12);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v13;
          result = (uint64_t)v13;
          *a5 = 1;
        }
      }
    }
    else
    {
      v14 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeTimeLastOpenedKey()"), CFSTR("PRQUUtils.mm"), 94, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85AC794(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_23(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  const void *v12;
  id v13;
  void *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  result = objc_msgSend(a2, "count");
  if (a2 && result)
  {
    v15 = 0;
    v16 = &v15;
    v17 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeEventKindKeySymbolLoc(void)::ptr;
    v18 = getkQPParseAttributeEventKindKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeEventKindKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeEventKindKey");
      v16[3] = (uint64_t)v9;
      getkQPParseAttributeEventKindKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v15, 8);
    if (v9)
    {
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, *v9);
      if ((_DWORD)result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v11);
        if ((_DWORD)result)
        {
          v12 = (const void *)getkQPParseAttributeDescriptionKey();
          v13 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v12);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v13;
          result = (uint64_t)v13;
          *a5 = 1;
        }
      }
    }
    else
    {
      v14 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeEventKindKey()"), CFSTR("PRQUUtils.mm"), 69, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85AC8F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_24(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  const void *v12;
  id v13;
  void *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  result = objc_msgSend(a2, "count");
  if (a2 && result)
  {
    v15 = 0;
    v16 = &v15;
    v17 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeKindDocumentKeySymbolLoc(void)::ptr;
    v18 = getkQPParseAttributeKindDocumentKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeKindDocumentKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeKindDocumentKey");
      v16[3] = (uint64_t)v9;
      getkQPParseAttributeKindDocumentKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v15, 8);
    if (v9)
    {
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, *v9);
      if ((_DWORD)result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v11);
        if ((_DWORD)result)
        {
          v12 = (const void *)getkQPParseAttributeDescriptionKey();
          v13 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v12);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v13;
          result = (uint64_t)v13;
          *a5 = 1;
        }
      }
    }
    else
    {
      v14 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindDocumentKey()"), CFSTR("PRQUUtils.mm"), 95, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85ACA54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_25(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  const void *v12;
  id v13;
  void *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  result = objc_msgSend(a2, "count");
  if (a2 && result)
  {
    v15 = 0;
    v16 = &v15;
    v17 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeKindNotesKeySymbolLoc(void)::ptr;
    v18 = getkQPParseAttributeKindNotesKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeKindNotesKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeKindNotesKey");
      v16[3] = (uint64_t)v9;
      getkQPParseAttributeKindNotesKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v15, 8);
    if (v9)
    {
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, *v9);
      if ((_DWORD)result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v11);
        if ((_DWORD)result)
        {
          v12 = (const void *)getkQPParseAttributeDescriptionKey();
          v13 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v12);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v13;
          result = (uint64_t)v13;
          *a5 = 1;
        }
      }
    }
    else
    {
      v14 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindNotesKey()"), CFSTR("PRQUUtils.mm"), 96, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85ACBB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_26(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  const void *v12;
  id v13;
  void *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  result = objc_msgSend(a2, "count");
  if (a2 && result)
  {
    v15 = 0;
    v16 = &v15;
    v17 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeKindReminderKeySymbolLoc(void)::ptr;
    v18 = getkQPParseAttributeKindReminderKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeKindReminderKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeKindReminderKey");
      v16[3] = (uint64_t)v9;
      getkQPParseAttributeKindReminderKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v15, 8);
    if (v9)
    {
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, *v9);
      if ((_DWORD)result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v11);
        if ((_DWORD)result)
        {
          v12 = (const void *)getkQPParseAttributeDescriptionKey();
          v13 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v12);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v13;
          result = (uint64_t)v13;
          *a5 = 1;
        }
      }
    }
    else
    {
      v14 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindReminderKey()"), CFSTR("PRQUUtils.mm"), 106, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85ACD14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_27(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  const void *v12;
  id v13;
  void *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  result = objc_msgSend(a2, "count");
  if (a2 && result)
  {
    v15 = 0;
    v16 = &v15;
    v17 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeKindVideoKeySymbolLoc(void)::ptr;
    v18 = getkQPParseAttributeKindVideoKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeKindVideoKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeKindVideoKey");
      v16[3] = (uint64_t)v9;
      getkQPParseAttributeKindVideoKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v15, 8);
    if (v9)
    {
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, *v9);
      if ((_DWORD)result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v11);
        if ((_DWORD)result)
        {
          v12 = (const void *)getkQPParseAttributeDescriptionKey();
          v13 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v12);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v13;
          result = (uint64_t)v13;
          *a5 = 1;
        }
      }
    }
    else
    {
      v14 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindVideoKey()"), CFSTR("PRQUUtils.mm"), 97, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85ACE74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_28(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  const void *v12;
  id v13;
  void *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  result = objc_msgSend(a2, "count");
  if (a2 && result)
  {
    v15 = 0;
    v16 = &v15;
    v17 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeKindWebsiteKeySymbolLoc(void)::ptr;
    v18 = getkQPParseAttributeKindWebsiteKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeKindWebsiteKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeKindWebsiteKey");
      v16[3] = (uint64_t)v9;
      getkQPParseAttributeKindWebsiteKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v15, 8);
    if (v9)
    {
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, *v9);
      if ((_DWORD)result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v11);
        if ((_DWORD)result)
        {
          v12 = (const void *)getkQPParseAttributeDescriptionKey();
          v13 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v12);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v13;
          result = (uint64_t)v13;
          *a5 = 1;
        }
      }
    }
    else
    {
      v14 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindWebsiteKey()"), CFSTR("PRQUUtils.mm"), 98, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85ACFD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_29(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  const void *v12;
  id v13;
  void *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  result = objc_msgSend(a2, "count");
  if (a2 && result)
  {
    v15 = 0;
    v16 = &v15;
    v17 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeKindKeynoteKeySymbolLoc(void)::ptr;
    v18 = getkQPParseAttributeKindKeynoteKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeKindKeynoteKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeKindKeynoteKey");
      v16[3] = (uint64_t)v9;
      getkQPParseAttributeKindKeynoteKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v15, 8);
    if (v9)
    {
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, *v9);
      if ((_DWORD)result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v11);
        if ((_DWORD)result)
        {
          v12 = (const void *)getkQPParseAttributeDescriptionKey();
          v13 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v12);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v13;
          result = (uint64_t)v13;
          *a5 = 1;
        }
      }
    }
    else
    {
      v14 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindKeynoteKey()"), CFSTR("PRQUUtils.mm"), 99, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85AD134(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_30(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  const void *v12;
  id v13;
  void *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  result = objc_msgSend(a2, "count");
  if (a2 && result)
  {
    v15 = 0;
    v16 = &v15;
    v17 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeKindPagesKeySymbolLoc(void)::ptr;
    v18 = getkQPParseAttributeKindPagesKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeKindPagesKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeKindPagesKey");
      v16[3] = (uint64_t)v9;
      getkQPParseAttributeKindPagesKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v15, 8);
    if (v9)
    {
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, *v9);
      if ((_DWORD)result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v11);
        if ((_DWORD)result)
        {
          v12 = (const void *)getkQPParseAttributeDescriptionKey();
          v13 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v12);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v13;
          result = (uint64_t)v13;
          *a5 = 1;
        }
      }
    }
    else
    {
      v14 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindPagesKey()"), CFSTR("PRQUUtils.mm"), 100, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85AD294(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_31(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  const void *v12;
  id v13;
  void *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  result = objc_msgSend(a2, "count");
  if (a2 && result)
  {
    v15 = 0;
    v16 = &v15;
    v17 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeKindNumbersKeySymbolLoc(void)::ptr;
    v18 = getkQPParseAttributeKindNumbersKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeKindNumbersKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeKindNumbersKey");
      v16[3] = (uint64_t)v9;
      getkQPParseAttributeKindNumbersKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v15, 8);
    if (v9)
    {
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, *v9);
      if ((_DWORD)result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v11);
        if ((_DWORD)result)
        {
          v12 = (const void *)getkQPParseAttributeDescriptionKey();
          v13 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v12);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v13;
          result = (uint64_t)v13;
          *a5 = 1;
        }
      }
    }
    else
    {
      v14 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindNumbersKey()"), CFSTR("PRQUUtils.mm"), 101, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85AD3F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_32(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  const void *v12;
  id v13;
  void *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  result = objc_msgSend(a2, "count");
  if (a2 && result)
  {
    v15 = 0;
    v16 = &v15;
    v17 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeKindPhotoAlbumKeySymbolLoc(void)::ptr;
    v18 = getkQPParseAttributeKindPhotoAlbumKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeKindPhotoAlbumKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeKindPhotoAlbumKey");
      v16[3] = (uint64_t)v9;
      getkQPParseAttributeKindPhotoAlbumKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v15, 8);
    if (v9)
    {
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, *v9);
      if ((_DWORD)result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v11);
        if ((_DWORD)result)
        {
          v12 = (const void *)getkQPParseAttributeDescriptionKey();
          v13 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v12);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v13;
          result = (uint64_t)v13;
          *a5 = 1;
        }
      }
    }
    else
    {
      v14 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindPhotoAlbumKey()"), CFSTR("PRQUUtils.mm"), 102, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85AD554(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_33(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  const void *v12;
  id v13;
  void *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  result = objc_msgSend(a2, "count");
  if (a2 && result)
  {
    v15 = 0;
    v16 = &v15;
    v17 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeKindMemoryKeySymbolLoc(void)::ptr;
    v18 = getkQPParseAttributeKindMemoryKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeKindMemoryKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeKindMemoryKey");
      v16[3] = (uint64_t)v9;
      getkQPParseAttributeKindMemoryKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v15, 8);
    if (v9)
    {
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, *v9);
      if ((_DWORD)result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v11);
        if ((_DWORD)result)
        {
          v12 = (const void *)getkQPParseAttributeDescriptionKey();
          v13 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v12);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v13;
          result = (uint64_t)v13;
          *a5 = 1;
        }
      }
    }
    else
    {
      v14 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindMemoryKey()"), CFSTR("PRQUUtils.mm"), 103, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85AD6B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_34(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  const void *v12;
  id v13;
  void *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  result = objc_msgSend(a2, "count");
  if (a2 && result)
  {
    v15 = 0;
    v16 = &v15;
    v17 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeKindConversationKeySymbolLoc(void)::ptr;
    v18 = getkQPParseAttributeKindConversationKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeKindConversationKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeKindConversationKey");
      v16[3] = (uint64_t)v9;
      getkQPParseAttributeKindConversationKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v15, 8);
    if (v9)
    {
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, *v9);
      if ((_DWORD)result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v11);
        if ((_DWORD)result)
        {
          v12 = (const void *)getkQPParseAttributeDescriptionKey();
          v13 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v12);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v13;
          result = (uint64_t)v13;
          *a5 = 1;
        }
      }
    }
    else
    {
      v14 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindConversationKey()"), CFSTR("PRQUUtils.mm"), 104, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85AD814(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_35(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  const void *v12;
  id v13;
  void *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  result = objc_msgSend(a2, "count");
  if (a2 && result)
  {
    v15 = 0;
    v16 = &v15;
    v17 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeKindNotesFolderKeySymbolLoc(void)::ptr;
    v18 = getkQPParseAttributeKindNotesFolderKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeKindNotesFolderKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeKindNotesFolderKey");
      v16[3] = (uint64_t)v9;
      getkQPParseAttributeKindNotesFolderKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v15, 8);
    if (v9)
    {
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, *v9);
      if ((_DWORD)result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v11);
        if ((_DWORD)result)
        {
          v12 = (const void *)getkQPParseAttributeDescriptionKey();
          v13 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v12);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v13;
          result = (uint64_t)v13;
          *a5 = 1;
        }
      }
    }
    else
    {
      v14 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindNotesFolderKey()"), CFSTR("PRQUUtils.mm"), 105, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85AD974(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_36(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  const void *v12;
  id v13;
  void *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  result = objc_msgSend(a2, "count");
  if (a2 && result)
  {
    v15 = 0;
    v16 = &v15;
    v17 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeKindReminderListKeySymbolLoc(void)::ptr;
    v18 = getkQPParseAttributeKindReminderListKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeKindReminderListKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeKindReminderListKey");
      v16[3] = (uint64_t)v9;
      getkQPParseAttributeKindReminderListKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v15, 8);
    if (v9)
    {
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, *v9);
      if ((_DWORD)result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v11);
        if ((_DWORD)result)
        {
          v12 = (const void *)getkQPParseAttributeDescriptionKey();
          v13 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v12);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v13;
          result = (uint64_t)v13;
          *a5 = 1;
        }
      }
    }
    else
    {
      v14 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindReminderListKey()"), CFSTR("PRQUUtils.mm"), 107, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85ADAD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_37(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void *v9;
  const void *v10;
  const void *v11;
  id v12;

  result = objc_msgSend(a2, "count");
  if (a2)
  {
    if (result)
    {
      v9 = (const void *)getkQPParseAttributeArchiveActionKey();
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, v9);
      if ((_DWORD)result)
      {
        v10 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v10);
        if ((_DWORD)result)
        {
          v11 = (const void *)getkQPParseAttributeDescriptionKey();
          v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v12;
          result = (uint64_t)v12;
          *a5 = 1;
        }
      }
    }
  }
  return result;
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_38(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  const void *v12;
  id v13;
  void *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  result = objc_msgSend(a2, "count");
  if (a2 && result)
  {
    v15 = 0;
    v16 = &v15;
    v17 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeBookmarkedActionKeySymbolLoc(void)::ptr;
    v18 = getkQPParseAttributeBookmarkedActionKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeBookmarkedActionKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeBookmarkedActionKey");
      v16[3] = (uint64_t)v9;
      getkQPParseAttributeBookmarkedActionKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v15, 8);
    if (v9)
    {
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, *v9);
      if ((_DWORD)result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v11);
        if ((_DWORD)result)
        {
          v12 = (const void *)getkQPParseAttributeDescriptionKey();
          v13 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v12);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v13;
          result = (uint64_t)v13;
          *a5 = 1;
        }
      }
    }
    else
    {
      v14 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeBookmarkedActionKey()"), CFSTR("PRQUUtils.mm"), 61, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85ADCC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_39(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  const void *v12;
  id v13;
  void *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  result = objc_msgSend(a2, "count");
  if (a2 && result)
  {
    v15 = 0;
    v16 = &v15;
    v17 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeUserCreatedActionKeySymbolLoc(void)::ptr;
    v18 = getkQPParseAttributeUserCreatedActionKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeUserCreatedActionKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeUserCreatedActionKey");
      v16[3] = (uint64_t)v9;
      getkQPParseAttributeUserCreatedActionKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v15, 8);
    if (v9)
    {
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, *v9);
      if ((_DWORD)result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v11);
        if ((_DWORD)result)
        {
          v12 = (const void *)getkQPParseAttributeDescriptionKey();
          v13 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v12);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v13;
          result = (uint64_t)v13;
          *a5 = 1;
        }
      }
    }
    else
    {
      v14 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeUserCreatedActionKey()"), CFSTR("PRQUUtils.mm"), 108, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85ADE24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_40(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void *v9;
  const void *v10;
  const void *v11;
  id v12;

  result = objc_msgSend(a2, "count");
  if (a2)
  {
    if (result)
    {
      v9 = (const void *)getkQPParseAttributeDraftActionKey();
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, v9);
      if ((_DWORD)result)
      {
        v10 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v10);
        if ((_DWORD)result)
        {
          v11 = (const void *)getkQPParseAttributeDescriptionKey();
          v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v12;
          result = (uint64_t)v12;
          *a5 = 1;
        }
      }
    }
  }
  return result;
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_41(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  const void *v12;
  id v13;
  void *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  result = objc_msgSend(a2, "count");
  if (a2 && result)
  {
    v15 = 0;
    v16 = &v15;
    v17 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeUserModifiedActionKeySymbolLoc(void)::ptr;
    v18 = getkQPParseAttributeUserModifiedActionKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeUserModifiedActionKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeUserModifiedActionKey");
      v16[3] = (uint64_t)v9;
      getkQPParseAttributeUserModifiedActionKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v15, 8);
    if (v9)
    {
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, *v9);
      if ((_DWORD)result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v11);
        if ((_DWORD)result)
        {
          v12 = (const void *)getkQPParseAttributeDescriptionKey();
          v13 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v12);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v13;
          result = (uint64_t)v13;
          *a5 = 1;
        }
      }
    }
    else
    {
      v14 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeUserModifiedActionKey()"), CFSTR("PRQUUtils.mm"), 109, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85AE014(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_42(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void *v9;
  const void *v10;
  const void *v11;
  id v12;

  result = objc_msgSend(a2, "count");
  if (a2)
  {
    if (result)
    {
      v9 = (const void *)getkQPParseAttributeFlaggedActionKey();
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, v9);
      if ((_DWORD)result)
      {
        v10 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v10);
        if ((_DWORD)result)
        {
          v11 = (const void *)getkQPParseAttributeDescriptionKey();
          v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v12;
          result = (uint64_t)v12;
          *a5 = 1;
        }
      }
    }
  }
  return result;
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_43(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void *v9;
  const void *v10;
  const void *v11;
  id v12;

  result = objc_msgSend(a2, "count");
  if (a2)
  {
    if (result)
    {
      v9 = (const void *)getkQPParseAttributeJunkActionKey();
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, v9);
      if ((_DWORD)result)
      {
        v10 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v10);
        if ((_DWORD)result)
        {
          v11 = (const void *)getkQPParseAttributeDescriptionKey();
          v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v12;
          result = (uint64_t)v12;
          *a5 = 1;
        }
      }
    }
  }
  return result;
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_44(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void *v9;
  const void *v10;
  const void *v11;
  id v12;

  result = objc_msgSend(a2, "count");
  if (a2)
  {
    if (result)
    {
      v9 = (const void *)getkQPParseAttributePrintedActionKey();
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, v9);
      if ((_DWORD)result)
      {
        v10 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v10);
        if ((_DWORD)result)
        {
          v11 = (const void *)getkQPParseAttributeDescriptionKey();
          v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v12;
          result = (uint64_t)v12;
          *a5 = 1;
        }
      }
    }
  }
  return result;
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_45(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  const void *v12;
  id v13;
  void *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  result = objc_msgSend(a2, "count");
  if (a2 && result)
  {
    v15 = 0;
    v16 = &v15;
    v17 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeReadActionKeySymbolLoc(void)::ptr;
    v18 = getkQPParseAttributeReadActionKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeReadActionKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeReadActionKey");
      v16[3] = (uint64_t)v9;
      getkQPParseAttributeReadActionKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v15, 8);
    if (v9)
    {
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, *v9);
      if ((_DWORD)result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v11);
        if ((_DWORD)result)
        {
          v12 = (const void *)getkQPParseAttributeDescriptionKey();
          v13 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v12);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v13;
          result = (uint64_t)v13;
          *a5 = 1;
        }
      }
    }
    else
    {
      v14 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeReadActionKey()"), CFSTR("PRQUUtils.mm"), 111, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85AE324(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_46(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  const void *v12;
  id v13;
  void *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  result = objc_msgSend(a2, "count");
  if (a2 && result)
  {
    v15 = 0;
    v16 = &v15;
    v17 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeReceivedActionKeySymbolLoc(void)::ptr;
    v18 = getkQPParseAttributeReceivedActionKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeReceivedActionKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeReceivedActionKey");
      v16[3] = (uint64_t)v9;
      getkQPParseAttributeReceivedActionKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v15, 8);
    if (v9)
    {
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, *v9);
      if ((_DWORD)result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v11);
        if ((_DWORD)result)
        {
          v12 = (const void *)getkQPParseAttributeDescriptionKey();
          v13 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v12);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v13;
          result = (uint64_t)v13;
          *a5 = 1;
        }
      }
    }
    else
    {
      v14 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeReceivedActionKey()"), CFSTR("PRQUUtils.mm"), 112, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85AE484(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_47(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  const void *v12;
  id v13;
  void *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  result = objc_msgSend(a2, "count");
  if (a2 && result)
  {
    v15 = 0;
    v16 = &v15;
    v17 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeRepliedActionKeySymbolLoc(void)::ptr;
    v18 = getkQPParseAttributeRepliedActionKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeRepliedActionKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeRepliedActionKey");
      v16[3] = (uint64_t)v9;
      getkQPParseAttributeRepliedActionKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v15, 8);
    if (v9)
    {
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, *v9);
      if ((_DWORD)result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v11);
        if ((_DWORD)result)
        {
          v12 = (const void *)getkQPParseAttributeDescriptionKey();
          v13 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v12);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v13;
          result = (uint64_t)v13;
          *a5 = 1;
        }
      }
    }
    else
    {
      v14 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeRepliedActionKey()"), CFSTR("PRQUUtils.mm"), 113, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85AE5E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_48(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  const void *v12;
  id v13;
  void *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  result = objc_msgSend(a2, "count");
  if (a2 && result)
  {
    v15 = 0;
    v16 = &v15;
    v17 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeSentActionKeySymbolLoc(void)::ptr;
    v18 = getkQPParseAttributeSentActionKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeSentActionKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeSentActionKey");
      v16[3] = (uint64_t)v9;
      getkQPParseAttributeSentActionKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v15, 8);
    if (v9)
    {
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, *v9);
      if ((_DWORD)result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v11);
        if ((_DWORD)result)
        {
          v12 = (const void *)getkQPParseAttributeDescriptionKey();
          v13 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v12);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v13;
          result = (uint64_t)v13;
          *a5 = 1;
        }
      }
    }
    else
    {
      v14 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeSentActionKey()"), CFSTR("PRQUUtils.mm"), 114, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85AE744(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_49(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void *v9;
  const void *v10;
  const void *v11;
  id v12;

  result = objc_msgSend(a2, "count");
  if (a2)
  {
    if (result)
    {
      v9 = (const void *)getkQPParseAttributeFlaggedActionKey();
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, v9);
      if ((_DWORD)result)
      {
        v10 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v10);
        if ((_DWORD)result)
        {
          v11 = (const void *)getkQPParseAttributeDescriptionKey();
          v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v12;
          result = (uint64_t)v12;
          *a5 = 1;
        }
      }
    }
  }
  return result;
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_50(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void *v9;
  const void *v10;
  const void *v11;
  id v12;

  result = objc_msgSend(a2, "count");
  if (a2)
  {
    if (result)
    {
      v9 = (const void *)getkQPParseAttributeDueActionKey();
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, v9);
      if ((_DWORD)result)
      {
        v10 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v10);
        if ((_DWORD)result)
        {
          v11 = (const void *)getkQPParseAttributeDescriptionKey();
          v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v12;
          result = (uint64_t)v12;
          *a5 = 1;
        }
      }
    }
  }
  return result;
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_51(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void *v9;
  const void *v10;
  const void *v11;
  id v12;

  result = objc_msgSend(a2, "count");
  if (a2)
  {
    if (result)
    {
      v9 = (const void *)getkQPParseAttributeCompletedActionKey();
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, v9);
      if ((_DWORD)result)
      {
        v10 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v10);
        if ((_DWORD)result)
        {
          v11 = (const void *)getkQPParseAttributeDescriptionKey();
          v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v12;
          result = (uint64_t)v12;
          *a5 = 1;
        }
      }
    }
  }
  return result;
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_52(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  const void *v13;
  const void *v14;
  const void *v15;
  const void *v16;
  id v17;

  result = objc_msgSend(a2, "count");
  if (a2)
  {
    if (result)
    {
      v9 = (const void *)getkQPParseAttributeGroundedPersonKey();
      if (CFDictionaryContainsKey((CFDictionaryRef)a2, v9)
        || (v10 = (const void *)getkQPParseAttributeTaggedPersonKey(), CFDictionaryContainsKey((CFDictionaryRef)a2, v10))
        || (v11 = (const void *)getkQPParseAttributeSenderKey(), CFDictionaryContainsKey((CFDictionaryRef)a2, v11))
        || (v12 = (const void *)getkQPParseAttributeSenderHandleKey(), CFDictionaryContainsKey((CFDictionaryRef)a2, v12))
        || (v13 = (const void *)getkQPParseAttributeRecipientKey(), CFDictionaryContainsKey((CFDictionaryRef)a2, v13))
        || (v14 = (const void *)getkQPParseAttributeRecipientHandleKey(),
            result = CFDictionaryContainsKey((CFDictionaryRef)a2, v14),
            (_DWORD)result))
      {
        v15 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v15);
        if ((_DWORD)result)
        {
          v16 = (const void *)getkQPParseAttributeDescriptionKey();
          v17 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v16);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v17;
          result = (uint64_t)v17;
          *a5 = 1;
        }
      }
    }
  }
  return result;
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_53(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  id v13;

  result = objc_msgSend(a2, "count");
  if (a2)
  {
    if (result)
    {
      v9 = (const void *)getkQPParseAttributeSenderKey();
      if (CFDictionaryContainsKey((CFDictionaryRef)a2, v9)
        || (v10 = (const void *)getkQPParseAttributeSenderHandleKey(),
            result = CFDictionaryContainsKey((CFDictionaryRef)a2, v10),
            (_DWORD)result))
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v11);
        if ((_DWORD)result)
        {
          v12 = (const void *)getkQPParseAttributeDescriptionKey();
          v13 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v12);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v13;
          result = (uint64_t)v13;
          *a5 = 1;
        }
      }
    }
  }
  return result;
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_54(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  id v13;

  result = objc_msgSend(a2, "count");
  if (a2)
  {
    if (result)
    {
      v9 = (const void *)getkQPParseAttributeRecipientKey();
      if (CFDictionaryContainsKey((CFDictionaryRef)a2, v9)
        || (v10 = (const void *)getkQPParseAttributeRecipientHandleKey(),
            result = CFDictionaryContainsKey((CFDictionaryRef)a2, v10),
            (_DWORD)result))
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v11);
        if ((_DWORD)result)
        {
          v12 = (const void *)getkQPParseAttributeDescriptionKey();
          v13 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v12);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v13;
          result = (uint64_t)v13;
          *a5 = 1;
        }
      }
    }
  }
  return result;
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_55(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  const void *v12;
  const void *v13;
  id v14;
  void *v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;

  result = objc_msgSend(a2, "count");
  if (a2 && result)
  {
    v16 = 0;
    v17 = &v16;
    v18 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeAttachedKindKeySymbolLoc(void)::ptr;
    v19 = getkQPParseAttributeAttachedKindKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeAttachedKindKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeAttachedKindKey");
      v17[3] = (uint64_t)v9;
      getkQPParseAttributeAttachedKindKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v16, 8);
    if (v9)
    {
      if (CFDictionaryContainsKey((CFDictionaryRef)a2, *v9)
        || (v11 = (const void *)getkQPParseAttributeAttachmentKey(),
            result = CFDictionaryContainsKey((CFDictionaryRef)a2, v11),
            (_DWORD)result))
      {
        v12 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v12);
        if ((_DWORD)result)
        {
          v13 = (const void *)getkQPParseAttributeDescriptionKey();
          v14 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v13);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v14;
          result = (uint64_t)v14;
          *a5 = 1;
        }
      }
    }
    else
    {
      v15 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = objc_msgSend(v15, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeAttachedKindKey()"), CFSTR("PRQUUtils.mm"), 117, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85AECA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_56(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  const void *v12;
  id v13;
  void *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  result = objc_msgSend(a2, "count");
  if (a2 && result)
  {
    v15 = 0;
    v16 = &v15;
    v17 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeTagColorActionKeySymbolLoc(void)::ptr;
    v18 = getkQPParseAttributeTagColorActionKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeTagColorActionKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeTagColorActionKey");
      v16[3] = (uint64_t)v9;
      getkQPParseAttributeTagColorActionKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v15, 8);
    if (v9)
    {
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, *v9);
      if ((_DWORD)result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v11);
        if ((_DWORD)result)
        {
          v12 = (const void *)getkQPParseAttributeDescriptionKey();
          v13 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v12);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v13;
          result = (uint64_t)v13;
          *a5 = 1;
        }
      }
    }
    else
    {
      v14 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeTagColorActionKey()"), CFSTR("PRQUUtils.mm"), 118, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85AEE04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_57(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  const void *v12;
  id v13;
  void *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  result = objc_msgSend(a2, "count");
  if (a2 && result)
  {
    v15 = 0;
    v16 = &v15;
    v17 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeFlagColorActionKeySymbolLoc(void)::ptr;
    v18 = getkQPParseAttributeFlagColorActionKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeFlagColorActionKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeFlagColorActionKey");
      v16[3] = (uint64_t)v9;
      getkQPParseAttributeFlagColorActionKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v15, 8);
    if (v9)
    {
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, *v9);
      if ((_DWORD)result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v11);
        if ((_DWORD)result)
        {
          v12 = (const void *)getkQPParseAttributeDescriptionKey();
          v13 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v12);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v13;
          result = (uint64_t)v13;
          *a5 = 1;
        }
      }
    }
    else
    {
      v14 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeFlagColorActionKey()"), CFSTR("PRQUUtils.mm"), 119, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85AEF64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_58(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void *v9;
  const void *v10;
  const void *v11;
  id v12;

  result = objc_msgSend(a2, "count");
  if (a2)
  {
    if (result)
    {
      v9 = (const void *)getkQPParseAttributeMediaKey();
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, v9);
      if ((_DWORD)result)
      {
        v10 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v10);
        if ((_DWORD)result)
        {
          v11 = (const void *)getkQPParseAttributeDescriptionKey();
          v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v12;
          result = (uint64_t)v12;
          *a5 = 1;
        }
      }
    }
  }
  return result;
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_59(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void *v9;
  const void *v10;
  const void *v11;
  id v12;

  result = objc_msgSend(a2, "count");
  if (a2)
  {
    if (result)
    {
      v9 = (const void *)getkQPParseAttributeFlightDepartureLocationKey();
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, v9);
      if ((_DWORD)result)
      {
        v10 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v10);
        if ((_DWORD)result)
        {
          v11 = (const void *)getkQPParseAttributeDescriptionKey();
          v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v12;
          result = (uint64_t)v12;
          *a5 = 1;
        }
      }
    }
  }
  return result;
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_60(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void *v9;
  const void *v10;
  const void *v11;
  id v12;

  result = objc_msgSend(a2, "count");
  if (a2)
  {
    if (result)
    {
      v9 = (const void *)getkQPParseAttributeFlightArrivalLocationKey();
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, v9);
      if ((_DWORD)result)
      {
        v10 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v10);
        if ((_DWORD)result)
        {
          v11 = (const void *)getkQPParseAttributeDescriptionKey();
          v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v12;
          result = (uint64_t)v12;
          *a5 = 1;
        }
      }
    }
  }
  return result;
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_61(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  const void *v12;
  id v13;
  void *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  result = objc_msgSend(a2, "count");
  if (a2 && result)
  {
    v15 = 0;
    v16 = &v15;
    v17 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeKindEmailKeySymbolLoc(void)::ptr;
    v18 = getkQPParseAttributeKindEmailKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeKindEmailKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeKindEmailKey");
      v16[3] = (uint64_t)v9;
      getkQPParseAttributeKindEmailKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v15, 8);
    if (v9)
    {
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, *v9);
      if ((_DWORD)result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v11);
        if ((_DWORD)result)
        {
          v12 = (const void *)getkQPParseAttributeDescriptionKey();
          v13 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v12);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v13;
          result = (uint64_t)v13;
          *a5 = 1;
        }
      }
    }
    else
    {
      v14 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindEmailKey()"), CFSTR("PRQUUtils.mm"), 79, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85AF274(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_62(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  const void *v12;
  id v13;
  void *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  result = objc_msgSend(a2, "count");
  if (a2 && result)
  {
    v15 = 0;
    v16 = &v15;
    v17 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeKindCalendarEventKeySymbolLoc(void)::ptr;
    v18 = getkQPParseAttributeKindCalendarEventKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeKindCalendarEventKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeKindCalendarEventKey");
      v16[3] = (uint64_t)v9;
      getkQPParseAttributeKindCalendarEventKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v15, 8);
    if (v9)
    {
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, *v9);
      if ((_DWORD)result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v11);
        if ((_DWORD)result)
        {
          v12 = (const void *)getkQPParseAttributeDescriptionKey();
          v13 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v12);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v13;
          result = (uint64_t)v13;
          *a5 = 1;
        }
      }
    }
    else
    {
      v14 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindCalendarEventKey()"), CFSTR("PRQUUtils.mm"), 81, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85AF3D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_63(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void **v9;
  void *ParserLibrary;
  const void *v11;
  const void *v12;
  id v13;
  void *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  result = objc_msgSend(a2, "count");
  if (a2 && result)
  {
    v15 = 0;
    v16 = &v15;
    v17 = 0x2020000000;
    v9 = (const void **)getkQPParseAttributeKindContactKeySymbolLoc(void)::ptr;
    v18 = getkQPParseAttributeKindContactKeySymbolLoc(void)::ptr;
    if (!getkQPParseAttributeKindContactKeySymbolLoc(void)::ptr)
    {
      ParserLibrary = QueryParserLibrary();
      v9 = (const void **)dlsym(ParserLibrary, "kQPParseAttributeKindContactKey");
      v16[3] = (uint64_t)v9;
      getkQPParseAttributeKindContactKeySymbolLoc(void)::ptr = (uint64_t)v9;
    }
    _Block_object_dispose(&v15, 8);
    if (v9)
    {
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, *v9);
      if ((_DWORD)result)
      {
        v11 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v11);
        if ((_DWORD)result)
        {
          v12 = (const void *)getkQPParseAttributeDescriptionKey();
          v13 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v12);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v13;
          result = (uint64_t)v13;
          *a5 = 1;
        }
      }
    }
    else
    {
      v14 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
      result = objc_msgSend(v14, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeKindContactKey()"), CFSTR("PRQUUtils.mm"), 80, CFSTR("%s"), dlerror());
      __break(1u);
    }
  }
  return result;
}

void sub_1B85AF534(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_64(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void *v9;
  const void *v10;
  const void *v11;
  id v12;

  result = objc_msgSend(a2, "count");
  if (a2)
  {
    if (result)
    {
      v9 = (const void *)getkQPParseAttributeEarliestActionKey();
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, v9);
      if ((_DWORD)result)
      {
        v10 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v10);
        if ((_DWORD)result)
        {
          v11 = (const void *)getkQPParseAttributeDescriptionKey();
          v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v12;
          result = (uint64_t)v12;
          *a5 = 1;
        }
      }
    }
  }
  return result;
}

uint64_t ___Z24fetchLLMTokenDescriptionPiPK14__CFDictionaryP18NSAttributedString_block_invoke_65(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t result;
  const void *v9;
  const void *v10;
  const void *v11;
  id v12;

  result = objc_msgSend(a2, "count");
  if (a2)
  {
    if (result)
    {
      v9 = (const void *)getkQPParseAttributeLatestActionKey();
      result = CFDictionaryContainsKey((CFDictionaryRef)a2, v9);
      if ((_DWORD)result)
      {
        v10 = (const void *)getkQPParseAttributeDescriptionKey();
        result = CFDictionaryContainsKey((CFDictionaryRef)a2, v10);
        if ((_DWORD)result)
        {
          v11 = (const void *)getkQPParseAttributeDescriptionKey();
          v12 = (id)CFDictionaryGetValue((CFDictionaryRef)a2, v11);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = v12;
          result = (uint64_t)v12;
          *a5 = 1;
        }
      }
    }
  }
  return result;
}

uint64_t getkQPParseAttributeRecipientHandleKey(void)
{
  void *v0;
  void *ParserLibrary;
  uint64_t result;
  void *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v0 = (void *)getkQPParseAttributeRecipientHandleKeySymbolLoc(void)::ptr;
  v7 = getkQPParseAttributeRecipientHandleKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeRecipientHandleKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    v0 = dlsym(ParserLibrary, "kQPParseAttributeRecipientHandleKey");
    v5[3] = (uint64_t)v0;
    getkQPParseAttributeRecipientHandleKeySymbolLoc(void)::ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v4, 8);
  if (v0)
    return *(_QWORD *)v0;
  v3 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeRecipientHandleKey()"), CFSTR("PRQUUtils.mm"), 116, CFSTR("%s"), dlerror());
  __break(1u);
  return result;
}

void sub_1B85AF73C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeSenderHandleKey(void)
{
  void *v0;
  void *ParserLibrary;
  uint64_t result;
  void *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v0 = (void *)getkQPParseAttributeSenderHandleKeySymbolLoc(void)::ptr;
  v7 = getkQPParseAttributeSenderHandleKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeSenderHandleKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    v0 = dlsym(ParserLibrary, "kQPParseAttributeSenderHandleKey");
    v5[3] = (uint64_t)v0;
    getkQPParseAttributeSenderHandleKeySymbolLoc(void)::ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v4, 8);
  if (v0)
    return *(_QWORD *)v0;
  v3 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeSenderHandleKey()"), CFSTR("PRQUUtils.mm"), 115, CFSTR("%s"), dlerror());
  __break(1u);
  return result;
}

void sub_1B85AF824(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t getkQPParseAttributeFlaggedActionKey(void)
{
  void *v0;
  void *ParserLibrary;
  uint64_t result;
  void *v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v0 = (void *)getkQPParseAttributeFlaggedActionKeySymbolLoc(void)::ptr;
  v7 = getkQPParseAttributeFlaggedActionKeySymbolLoc(void)::ptr;
  if (!getkQPParseAttributeFlaggedActionKeySymbolLoc(void)::ptr)
  {
    ParserLibrary = QueryParserLibrary();
    v0 = dlsym(ParserLibrary, "kQPParseAttributeFlaggedActionKey");
    v5[3] = (uint64_t)v0;
    getkQPParseAttributeFlaggedActionKeySymbolLoc(void)::ptr = (uint64_t)v0;
  }
  _Block_object_dispose(&v4, 8);
  if (v0)
    return *(_QWORD *)v0;
  v3 = (void *)objc_msgSend(MEMORY[0x1E0CB3488], "currentHandler");
  result = objc_msgSend(v3, "handleFailureInFunction:file:lineNumber:description:", objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", "CFStringRef  _Nullable getkQPParseAttributeFlaggedActionKey()"), CFSTR("PRQUUtils.mm"), 110, CFSTR("%s"), dlerror());
  __break(1u);
  return result;
}

void sub_1B85AF90C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL isLLMOptionalArgId(int a1)
{
  unsigned __int8 v2;

  {
    llmOptionalArgIds(void)::_optionalArgs = 0u;
    unk_1EF1B0C80 = 0u;
    dword_1EF1B0C90 = 1065353216;
    __cxa_atexit((void (*)(void *))std::unordered_set<int>::~unordered_set[abi:nn180100], &llmOptionalArgIds(void)::_optionalArgs, &dword_1B8270000);
  }
  if (llmOptionalArgIds(void)::onceToken != -1)
    dispatch_once(&llmOptionalArgIds(void)::onceToken, &__block_literal_global_167);
  return std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::find<int>(&llmOptionalArgIds(void)::_optionalArgs, a1) != 0;
}

void ___ZL17llmOptionalArgIdsv_block_invoke()
{
  __int128 v0;
  int v1;
  uint64_t v2;

  v2 = *MEMORY[0x1E0C80C00];
  v0 = xmmword_1B8631FC0;
  std::__hash_table<int,std::hash<int>,std::equal_to<int>,std::allocator<int>>::__assign_unique<int const*>((uint64_t)&llmOptionalArgIds(void)::_optionalArgs, (int *)&v0, &v1);
}

void *_SISetGetLockStateCallback(void *aBlock)
{
  void *result;

  if (sGetLockStateCallback)
    _Block_release((const void *)sGetLockStateCallback);
  result = _Block_copy(aBlock);
  sGetLockStateCallback = (uint64_t)result;
  return result;
}

thread_read_t *SIForceResume()
{
  sForceResume = 1;
  return SIResumeForUnlock();
}

uint64_t _SISuspendThreadIfLocked(thread_read_t *a1, void (**a2)(_QWORD, _QWORD))
{
  uint64_t result;
  int v5;
  int v6;
  NSObject *v7;
  int *v8;
  mach_port_name_t v9;
  NSObject *v10;
  qos_class_t v11;
  NSObject *global_queue;
  _QWORD v13[5];
  int v14;
  uint8_t buf[4];
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if ((sForceResume & 1) != 0)
    return 0;
  result = sGetLockStateCallback;
  if (sGetLockStateCallback)
  {
    result = (*(uint64_t (**)(void))(sGetLockStateCallback + 16))();
    if ((_DWORD)result)
    {
      if (gTerminating)
      {
        if (dword_1EF19FCB4 < 5)
          return 0;
        v5 = result;
        v6 = *__error();
        v7 = _SILogForLogForCategory(10);
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 67109120;
          v16 = v5;
          _os_log_impl(&dword_1B8270000, v7, OS_LOG_TYPE_DEFAULT, "process terminating, skip suspend for lock state %d", buf, 8u);
        }
        v8 = __error();
        result = 0;
        *v8 = v6;
      }
      else
      {
        v9 = MEMORY[0x1BCCB104C]();
        if (v9 == (_DWORD)a1)
        {
          v10 = dispatch_group_create();
          v11 = qos_class_self();
          global_queue = dispatch_get_global_queue(v11, 0);
          v13[0] = MEMORY[0x1E0C809B0];
          v13[1] = 0x40000000;
          v13[2] = ___SISuspendThreadIfLocked_block_invoke;
          v13[3] = &unk_1E6E35F10;
          v14 = (int)a1;
          v13[4] = a2;
          dispatch_group_async(v10, global_queue, v13);
          dispatch_group_wait(v10, 0xFFFFFFFFFFFFFFFFLL);
          dispatch_release(v10);
        }
        else
        {
          _SISuspendThread(a1, a2);
        }
        mach_port_deallocate(*MEMORY[0x1E0C83DA0], v9);
        return 1;
      }
    }
  }
  return result;
}

thread_read_t *_SISuspendThread(thread_read_t *result, void (**a2)(_QWORD, _QWORD))
{
  int v3;
  _DWORD *v4;
  void *v5;

  if ((sForceResume & 1) == 0)
  {
    v3 = (int)result;
    thread_suspend((thread_read_t)result);
    if (a2)
      a2[2](a2, 1);
    v4 = OSAtomicDequeue(&threadResumeFreeQueue, 0);
    if (!v4)
      v4 = malloc_type_malloc(0x18uLL, 0x1080040216EE090uLL);
    v4[2] = v3;
    if (a2)
      v5 = _Block_copy(a2);
    else
      v5 = 0;
    *((_QWORD *)v4 + 2) = v5;
    OSAtomicEnqueue(&threadResumeQueue, v4, 0);
    return SIResumeForUnlock();
  }
  return result;
}

uint64_t SIOpenIndexAtPathWithCallbacks(const __CFString *a1, CFDictionaryRef theDict, const void *a3, const void *a4, const void *a5, int a6, _DWORD *a7, _QWORD *a8)
{
  const void **v14;
  const void *Value;
  const void *v16;
  const __CFNumber *v17;
  const __CFNumber *v18;
  int v19;
  CFTypeID v20;
  _BOOL4 v21;
  uint64_t Instance;
  _DWORD *v23;
  int v24;
  int v25;
  const void *v26;
  const void *v27;
  _BOOL4 v28;
  BOOL v29;
  char *v30;
  void *v31;
  uint64_t (*v32)(uint64_t);
  unsigned int *v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  int v37;
  unsigned int v38;
  int v39;
  unsigned int v40;
  uint64_t v41;
  int v42;
  uint64_t v43;
  int v44;
  unsigned int v45;
  unsigned int v46;
  _QWORD *v47;
  int v48;
  NSObject *v49;
  _DWORD *v51;
  _BOOL4 v52;
  _BOOL4 v54;
  __int128 v56;
  uint64_t v57;
  int *v58;
  int valuePtr;
  uint8_t buf[32];
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  char buffer[1024];
  uint64_t v66;

  v66 = *MEMORY[0x1E0C80C00];
  valuePtr = 0;
  v14 = (const void **)MEMORY[0x1E0C9AE50];
  if (theDict)
  {
    Value = CFDictionaryGetValue(theDict, CFSTR("kIndexLockedIndexing"));
    v16 = *v14;
    v54 = Value == *v14;
    v17 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("kIndexOptionPriorityPC"));
    if (v17)
    {
      v18 = v17;
      v19 = a6;
      v20 = CFGetTypeID(v17);
      v29 = v20 == CFNumberGetTypeID();
      a6 = v19;
      if (v29)
        CFNumberGetValue(v18, kCFNumberSInt32Type, &valuePtr);
    }
    v21 = CFDictionaryGetValue(theDict, CFSTR("kIndexOptionResetForLargePostings")) == v16;
  }
  else
  {
    v21 = 0;
    v54 = 0;
  }
  v52 = v21;
  if (SIOpenIndexAtPathWithCallbacks_onceToken != -1)
    dispatch_once(&SIOpenIndexAtPathWithCallbacks_onceToken, &__block_literal_global_8837);
  v58 = 0;
  if (!__kSI_PersistentIDStoreTypeID)
    __kSI_PersistentIDStoreTypeID = _CFRuntimeRegisterClass();
  v51 = a7;
  Instance = _CFRuntimeCreateInstance();
  *(_QWORD *)(Instance + 24) = malloc_type_malloc(4uLL, 0x100004052888210uLL);
  *(_OWORD *)(Instance + 192) = xmmword_1E6E29910;
  *(_OWORD *)(Instance + 208) = unk_1E6E29920;
  *(_OWORD *)(Instance + 224) = xmmword_1E6E29930;
  *(_OWORD *)(Instance + 128) = xmmword_1E6E298D0;
  *(_OWORD *)(Instance + 144) = unk_1E6E298E0;
  *(_OWORD *)(Instance + 160) = xmmword_1E6E298F0;
  *(_OWORD *)(Instance + 176) = unk_1E6E29900;
  *(_OWORD *)(Instance + 64) = xmmword_1E6E29890;
  *(_OWORD *)(Instance + 80) = unk_1E6E298A0;
  *(_OWORD *)(Instance + 96) = xmmword_1E6E298B0;
  *(_OWORD *)(Instance + 112) = *(_OWORD *)&off_1E6E298C0;
  *(_OWORD *)(Instance + 32) = SI_PersistentIDStore_FileProviders_TEMPLATE;
  *(_OWORD *)(Instance + 48) = unk_1E6E29880;
  v23 = malloc_type_malloc(0x10uLL, 0x10200403A5D3213uLL);
  *(_QWORD *)(Instance + 16) = v23;
  v23[2] = -1;
  *(_BYTE *)(Instance + 120) = 1;
  v24 = 320;
  if (theDict)
  {
    v25 = a6;
    v26 = CFDictionaryGetValue(theDict, CFSTR("kIndexOptionReadOnly"));
    v27 = *v14;
    v28 = CFDictionaryGetValue(theDict, CFSTR("kIndexOptionPrivate")) == v27;
    v29 = v26 == v27;
    if (v26 == v27)
      a6 = 0;
    else
      a6 = v25;
    if (v29)
      v24 = 324;
    else
      v24 = 320;
  }
  else
  {
    v28 = 0;
  }
  v30 = (char *)malloc_type_malloc(0xB0uLL, 0x1080040C460E3ABuLL);
  *((_OWORD *)v30 + 6) = xmmword_1E6E29840;
  *((_OWORD *)v30 + 7) = *(_OWORD *)&off_1E6E29850;
  *((_OWORD *)v30 + 8) = xmmword_1E6E29860;
  *((_OWORD *)v30 + 2) = xmmword_1E6E29800;
  *((_OWORD *)v30 + 3) = *(_OWORD *)&off_1E6E29810;
  *((_OWORD *)v30 + 4) = xmmword_1E6E29820;
  *((_OWORD *)v30 + 5) = unk_1E6E29830;
  *(_OWORD *)v30 = SIOpenIndexAtPathWithCallbacks_si_callbacks;
  *((_OWORD *)v30 + 1) = *(_OWORD *)&off_1E6E297F0;
  if (a4)
  {
    v31 = _Block_copy(a4);
    v32 = _SIScheduleWake;
  }
  else
  {
    v31 = 0;
    v32 = 0;
  }
  *((_QWORD *)v30 + 18) = v31;
  *((_QWORD *)v30 + 10) = v32;
  *((_QWORD *)v30 + 15) = _SIBudgetCallback;
  *((_QWORD *)v30 + 19) = _Block_copy(a3);
  *((_QWORD *)v30 + 20) = _Block_copy(a5);
  *((_DWORD *)v30 + 42) = 1;
  v33 = (unsigned int *)(v30 + 168);
  *((_QWORD *)v30 + 17) = v30;
  bzero(buffer, 0x400uLL);
  if (!CFStringGetFileSystemRepresentation(a1, buffer, 1024) || (v34 = open(buffer, 0x8000), (v34 & 0x80000000) != 0))
  {
    v43 = 0xFFFFFFFFLL;
  }
  else
  {
    v35 = v34;
    v36 = v24 | 0x1000;
    if (!v28)
      v36 = v24;
    if (v54)
      v36 |= 0x40000u;
    v37 = v36 | (valuePtr << 24);
    if (v52)
      v38 = v37 | 0x80000;
    else
      v38 = v37;
    if (SIBullseyeNoForceUnigramsDefault_onceToken != -1)
      dispatch_once(&SIBullseyeNoForceUnigramsDefault_onceToken, &__block_literal_global_10);
    v39 = SIBullseyeNoForceUnigramsDefault_sUnigrams;
    if (!SIBullseyeNoForceUnigramsDefault_sUnigrams)
    {
      if (SIOpenIndexAtPathWithCallbacks_onceToken_22 != -1)
        dispatch_once(&SIOpenIndexAtPathWithCallbacks_onceToken_22, &__block_literal_global_25_8838);
      if (SIOpenIndexAtPathWithCallbacks_isCJPrimary)
        v38 |= 0x200u;
    }
    v63 = 0u;
    v64 = 0u;
    v61 = 0u;
    v62 = 0u;
    memset(buf, 0, sizeof(buf));
    do
      v40 = __ldxr(v33);
    while (__stxr(v40 + 1, v33));
    v56 = 0uLL;
    v57 = 0;
    v41 = SIOpenIndex((uint64_t)&v58, v35, 0, 0, v38, buf, &v56, (uint64_t)v30, Instance, v51);
    v42 = a6 ^ 1;
    if ((int)v41 >= 0)
      v42 = 1;
    if (((v42 | v54) & 1) != 0)
    {
      v43 = v41;
      if ((v41 & 0x80000000) == 0)
        SISetScanCount((uint64_t)v58, 0, 0);
    }
    else
    {
      if (v39)
        v44 = 2;
      else
        v44 = 514;
      v45 = v38 | v44;
      do
        v46 = __ldxr(v33);
      while (__stxr(v46 + 1, v33));
      v56 = 0uLL;
      v57 = 0;
      v43 = SICreateNewIndex((uint64_t *)&v58, v35, 0, 0, v45, &v56, (uint64_t)v30, Instance, v51);
      if (!(_DWORD)v43)
      {
        v43 = 1;
        SISetScanCount((uint64_t)v58, 0, 1);
        SIInitialIndexingEnded(v58, 0);
      }
    }
    close(v35);
  }
  si_index_ctx_release((unsigned int *)v30);
  if (Instance && v58)
  {
    v47 = *(_QWORD **)(Instance + 16);
    if (v47)
    {
      *v47 = v58;
    }
    else
    {
      v48 = *__error();
      v49 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)&buf[4] = "SIOpenIndexAtPathWithCallbacks";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 509;
        _os_log_error_impl(&dword_1B8270000, v49, OS_LOG_TYPE_ERROR, "%s:%d: Cannot setIndexRef for psid store.", buf, 0x12u);
      }
      *__error() = v48;
    }
  }
  CFRelease((CFTypeRef)Instance);
  if ((v43 & 0x80000000) == 0)
    *a8 = v58;
  return v43;
}

uint64_t _SIScheduleWake(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 144) + 16))();
}

void si_index_ctx_release(unsigned int *a1)
{
  unsigned int *v2;
  unsigned int v3;
  unsigned int v4;
  const void *v5;
  const void *v6;
  const void *v7;

  v2 = a1 + 42;
  do
  {
    v3 = __ldxr(v2);
    v4 = v3 - 1;
  }
  while (__stxr(v4, v2));
  if (!v4)
  {
    v5 = (const void *)*((_QWORD *)a1 + 18);
    if (v5)
      _Block_release(v5);
    v6 = (const void *)*((_QWORD *)a1 + 19);
    if (v6)
      _Block_release(v6);
    v7 = (const void *)*((_QWORD *)a1 + 20);
    if (v7)
      _Block_release(v7);
    free(a1);
  }
}

void _SIReopenCallback()
{
  exit(0);
}

uint64_t _SIRepairOidCallback()
{
  return 1;
}

uint64_t _SIAccountingStartCallback(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 160);
  if (v1)
    (*(void (**)(uint64_t, uint64_t))(v1 + 16))(v1, 1);
  return 0;
}

uint64_t _SIAccountingEndCallback(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 160);
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t))(result + 16))(result, 0xFFFFFFFFLL);
  return result;
}

uint64_t _SIDeleteCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;

  if (sCSRelatedItemCallback)
    return sCSRelatedItemCallback(0, a3, a4, 0, 2);
  return result;
}

uint64_t SISetFileProvidersCallbacks(uint64_t result, uint64_t a2, uint64_t a3)
{
  copyFPItemBlock = result;
  copyFPItemParentBlock = a2;
  copyFPItemAllParentsBlock = a3;
  return result;
}

uint64_t SIOpenIndexAtPath(const __CFString *a1, const __CFDictionary *a2, int a3, _DWORD *a4, _QWORD *a5)
{
  return SIOpenIndexAtPathWithCallbacks(a1, a2, 0, 0, 0, a3, a4, a5);
}

uint64_t SISetAttributesForIndex(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(uint64_t, _QWORD), uint64_t a6, uint64_t a7)
{
  uint64_t v7;

  if (a5)
    v7 = 5;
  else
    v7 = 4;
  return SIBulkSetAttributes(a1, a3, 0, a2, a4, 0, 0, v7, 5, a5, a6, a7, 0);
}

BOOL SIIndexIsInPlayback(_BOOL8 result)
{
  unsigned int v1;

  if (result)
  {
    v1 = atomic_load((unsigned int *)(result + 6888));
    return v1 != 0;
  }
  return result;
}

uint64_t SIFlushAndSuspendIndex(uint64_t a1, char a2)
{
  NSObject *v4;
  dispatch_time_t v5;
  int v6;
  NSObject *v7;
  int v8;
  _QWORD block[6];
  char v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  int v15;
  uint8_t buf[4];
  int v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (gFlushSuspendOnceToken != -1)
  {
    dispatch_once(&gFlushSuspendOnceToken, &__block_literal_global_31_8861);
    if (a1)
      goto LABEL_3;
    return 0;
  }
  if (!a1)
    return 0;
LABEL_3:
  if (!*(_QWORD *)(a1 + 1184) || !*(_QWORD *)(a1 + 1040) || !*(_QWORD *)(a1 + 1048))
    return 0;
  pthread_mutex_lock(&gSuspensionMutex);
  ++*(_DWORD *)(a1 + 676);
  pthread_mutex_unlock(&gSuspensionMutex);
  v4 = dispatch_group_create();
  v12 = 0;
  v13 = &v12;
  v14 = 0x2000000000;
  v15 = 0;
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __SIFlushAndSuspendIndex_block_invoke_2;
  block[3] = &unk_1E6E360A8;
  block[4] = &v12;
  block[5] = a1;
  v11 = a2;
  dispatch_group_async(v4, (dispatch_queue_t)gFlushSuspendQueue, block);
  v5 = dispatch_time(0, 15000000000);
  dispatch_group_wait(v4, v5);
  v6 = *__error();
  v7 = _SILogForLogForCategory(3);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    v8 = *((_DWORD *)v13 + 6);
    *(_DWORD *)buf = 67109120;
    v17 = v8;
    _os_log_impl(&dword_1B8270000, v7, OS_LOG_TYPE_DEFAULT, "Flush and suspend index last waited on scheduler %d", buf, 8u);
  }
  *__error() = v6;
  dispatch_release(v4);
  _Block_object_dispose(&v12, 8);
  return 1;
}

void SIResumeIndex(uint64_t a1)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD block[5];

  if (gFlushSuspendOnceToken == -1)
  {
    if (!a1)
      return;
  }
  else
  {
    dispatch_once(&gFlushSuspendOnceToken, &__block_literal_global_35_8866);
    if (!a1)
      return;
  }
  if (*(_QWORD *)(a1 + 1184) && *(_QWORD *)(a1 + 1040) && *(_QWORD *)(a1 + 1048))
  {
    pthread_mutex_lock(&gSuspensionMutex);
    v2 = *(_DWORD *)(a1 + 676);
    if (v2)
    {
      v3 = 0;
      *(_DWORD *)(a1 + 676) = v2 - 1;
      do
      {
        v4 = a1 + v3;
        if (*(_QWORD *)(a1 + v3 + 864))
          si_scheduler_resume_with_token(*(unsigned int **)(v4 + 680));
        *(_QWORD *)(v4 + 680) = 0;
        v3 += 8;
      }
      while (v3 != 144);
    }
    pthread_mutex_unlock(&gSuspensionMutex);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __SIResumeIndex_block_invoke_2;
    block[3] = &__block_descriptor_tmp_36_8867;
    block[4] = a1;
    dispatch_async((dispatch_queue_t)gFlushSuspendQueue, block);
  }
}

const __CFNumber *SIGetAccumulatedStorageSizeForBundleId(uint64_t a1, const void *a2, uint64_t *a3)
{
  const __CFNumber *result;
  BOOL v6;
  unsigned int v7;
  pthread_mutex_t *v8;
  uint64_t v9;
  unsigned int valuePtr;

  valuePtr = 0;
  result = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 2088), a2);
  if (result)
  {
    if (CFNumberGetValue(result, kCFNumberSInt32Type, &valuePtr))
      v6 = valuePtr == 0;
    else
      v6 = 1;
    if (v6)
      return 0;
    v7 = *(_BYTE *)(a1 + 2072) ? 256 : 22;
    if (v7 <= valuePtr)
    {
      return 0;
    }
    else
    {
      v8 = (pthread_mutex_t *)(a1 + 6976);
      pthread_mutex_lock(v8);
      v9 = *(&v8[1].__sig + valuePtr);
      pthread_mutex_unlock(v8);
      *a3 = v9 & ~(v9 >> 63);
      return (const __CFNumber *)1;
    }
  }
  return result;
}

uint64_t SITransferDeletionJournals(uint64_t a1, int a2, uint64_t a3)
{
  pthread_mutex_t *v6;
  uint64_t v7;
  int v8;
  int v9;
  uint64_t walk;
  char *v11;
  size_t v12;
  _BOOL8 v13;
  _QWORD v15[5];
  int v16;
  int v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  int v21;
  _QWORD v22[6];
  char v23;
  char __s[1024];
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if (a2 < 0)
  {
    v13 = 1;
  }
  else
  {
    v6 = (pthread_mutex_t *)(a1 + 1632);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 1632));
    v18 = 0;
    v19 = &v18;
    v20 = 0x3000000000;
    v21 = 0;
    v7 = getDeleteJournalFd(a1);
    if (!v7 || (v8 = *(_DWORD *)(v7 + 44), v8 < 0))
    {
      v9 = -1;
    }
    else
    {
      bzero(__s, 0x400uLL);
      v9 = -1;
      if ((fcntl(v8, 50, __s) & 0x80000000) == 0 && __s[0])
      {
        v15[0] = MEMORY[0x1E0C809B0];
        v15[1] = 0x40000000;
        v15[2] = __mobile_journal_transfer_paths_block_invoke;
        v15[3] = &unk_1E6E2E0F0;
        v16 = v8;
        v17 = a2;
        v15[4] = &v18;
        v22[0] = MEMORY[0x1E0C809B0];
        v22[1] = 0x40000000;
        v22[2] = __get_files_for_directory_block_invoke;
        v22[3] = &unk_1E6E2E118;
        v22[4] = v15;
        v22[5] = v19 + 5;
        v23 = 0;
        walk = fsi_create_walk((uint64_t)__s);
        if (walk)
        {
          v11 = (char *)walk;
          fsi_iterate_f(walk, (uint64_t)v22);
          fsi_close(v11);
        }
        if (!*((_DWORD *)v19 + 10))
        {
          v12 = strlen(__s);
          snprintf(&__s[v12], 1024 - v12, "/%s", "skg_");
          unlink(__s);
          v9 = 0;
        }
      }
    }
    pthread_mutex_unlock(v6);
    v13 = v9 != 0;
    _Block_object_dispose(&v18, 8);
  }
  return (*(uint64_t (**)(uint64_t, _BOOL8))(a3 + 16))(a3, v13);
}

const __CFNumber *SIGetAccumulatedCountForBundleId(uint64_t a1, const void *a2, _DWORD *a3)
{
  const __CFNumber *result;
  BOOL v6;
  unsigned int v7;
  pthread_mutex_t *v8;
  int v9;
  unsigned int valuePtr;

  valuePtr = 0;
  result = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 2088), a2);
  if (result)
  {
    if (CFNumberGetValue(result, kCFNumberSInt32Type, &valuePtr))
      v6 = valuePtr == 0;
    else
      v6 = 1;
    if (v6)
      return 0;
    v7 = *(_BYTE *)(a1 + 2072) ? 256 : 22;
    if (v7 <= valuePtr)
    {
      return 0;
    }
    else
    {
      v8 = (pthread_mutex_t *)(a1 + 6976);
      pthread_mutex_lock(v8);
      v9 = *((_DWORD *)&v8[33].__sig + valuePtr);
      pthread_mutex_unlock(v8);
      *a3 = v9;
      return (const __CFNumber *)1;
    }
  }
  return result;
}

const void *SICopyCachedCSClientState(uint64_t a1, const void *a2, const void *a3)
{
  pthread_rwlock_t *v6;
  const __CFDictionary *Value;
  const __CFDictionary *v8;
  const void *v9;
  const void *v10;

  v6 = (pthread_rwlock_t *)(a1 + 80);
  pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 80));
  Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 72), CFSTR("clientStates"));
  if (Value && (v8 = (const __CFDictionary *)CFDictionaryGetValue(Value, a2)) != 0)
  {
    v9 = CFDictionaryGetValue(v8, a3);
    v10 = v9;
    if (v9)
      CFRetain(v9);
  }
  else
  {
    v10 = 0;
  }
  pthread_rwlock_unlock(v6);
  return v10;
}

void si_fetchClientState(uint64_t a1, int a2)
{
  void (*v4)(void);
  char *v5;
  NSObject *v6;
  int v7;
  CFDataRef v8;
  int v9;
  uint64_t v10;
  int v11;
  UInt8 *bytes;
  unsigned __int16 *v13;
  uint64_t v14;
  char v15;
  void *v16;
  uint8_t v17[4];
  _OWORD *v18;
  __int16 v19;
  uint64_t v20;
  uint8_t buf[16];
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  _OWORD buffer[8];
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  buffer[0] = *(_OWORD *)"no bundleid";
  memset(&buffer[1], 0, 112);
  CFStringGetCString(*(CFStringRef *)(a1 + 16), (char *)buffer, 128, 0x8000100u);
  if (a2)
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = buffer;
      _os_log_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "Client state fetch for %s cancelled", buf, 0xCu);
    }
    v4 = *(void (**)(void))(*(_QWORD *)(a1 + 8) + 16);
    goto LABEL_6;
  }
  v16 = 0;
  if (si_get_object_for_identifier_createParentDBO(*(_QWORD *)a1, CFSTR("com.apple.searchd"), *(const __CFString **)(a1 + 16), 0, 0, 0, &v16, 0))
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = buffer;
      _os_log_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "Client state fetch for %s failed; no corresponding entry in bundle com.apple.searchd",
        buf,
        0xCu);
    }
    v4 = *(void (**)(void))(*(_QWORD *)(a1 + 8) + 16);
LABEL_6:
    v4();
    deallocFetchClientStateCtx((const void **)a1);
    return;
  }
  v35 = 0u;
  v36 = 0u;
  v33 = 0u;
  v34 = 0u;
  v31 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v24 = 0u;
  v22 = 0u;
  v23 = 0u;
  *(_OWORD *)buf = 0u;
  v15 = 0;
  v5 = fasterUTF8String(*(const __CFString **)(a1 + 24), &v14, (char *)buf, 256, &v15);
  bytes = 0;
  v13 = 0;
  if (db_get_field(*(int **)(*(_QWORD *)a1 + 1184), (uint64_t)v16, v5, (unint64_t *)&v13, &bytes))
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)v17 = 136315394;
      v18 = buffer;
      v19 = 2080;
      v20 = (uint64_t)v5;
      _os_log_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "Client state fetch for %s failed; no field %s in db entry",
        v17,
        0x16u);
    }
    v11 = 0;
    v6 = MEMORY[0x1E0C81028];
    v10 = 0;
    while (db_next_field(*(_DWORD **)(*(_QWORD *)a1 + 1184), (uint64_t)v16, 0, &v11, &v10, 0) == 35)
    {
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)v17 = 136315394;
        v18 = buffer;
        v19 = 2080;
        v20 = v10;
        _os_log_impl(&dword_1B8270000, v6, OS_LOG_TYPE_DEFAULT, "Client state fetch for %s failed; field present: %s",
          v17,
          0x16u);
      }
    }
  }
  else
  {
    v7 = *v13;
    if (v7 == 14)
    {
      v8 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], bytes, *((unsigned int *)v13 + 2));
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      {
        v9 = *((_DWORD *)v13 + 2);
        *(_DWORD *)v17 = 136315394;
        v18 = buffer;
        v19 = 1024;
        LODWORD(v20) = v9;
        _os_log_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "Client state fetch for %s succeeded; state has length %d",
          v17,
          0x12u);
      }
      (*(void (**)(void))(*(_QWORD *)(a1 + 8) + 16))();
      CFRelease(v8);
      goto LABEL_21;
    }
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)v17 = 136315394;
      v18 = buffer;
      v19 = 1024;
      LODWORD(v20) = v7;
      _os_log_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "Client state fetch for %s succeeded; state has incorrect type %d",
        v17,
        0x12u);
    }
  }
  (*(void (**)(void))(*(_QWORD *)(a1 + 8) + 16))();
LABEL_21:
  free(v16);
  deallocFetchClientStateCtx((const void **)a1);
  if (v15)
    free(v5);
}

void deallocFetchClientStateCtx(const void **a1)
{
  _Block_release(a1[1]);
  CFRelease(a1[2]);
  CFRelease(a1[3]);
  free(a1);
}

uint64_t SIDeleteCSClientStateCache(uint64_t a1, const void *a2)
{
  pthread_rwlock_t *v4;
  __CFDictionary *Value;

  v4 = (pthread_rwlock_t *)(a1 + 80);
  pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 80));
  Value = (__CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 72), CFSTR("clientStates"));
  if (Value)
  {
    CFDictionaryRemoveValue(Value, a2);
    SIPersistClientStateAndMeta(a1, 0);
  }
  return pthread_rwlock_unlock(v4);
}

CFDictionaryRef *SICopyCSClientStateCache(uint64_t a1)
{
  CFDictionaryRef *Copy;
  pthread_rwlock_t *v2;
  const __CFDictionary *v3;
  const __CFDictionary *Value;

  Copy = (CFDictionaryRef *)a1;
  if (a1)
  {
    v2 = (pthread_rwlock_t *)(a1 + 80);
    pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 80));
    v3 = Copy[9];
    if (v3 && CFDictionaryGetCount(v3))
    {
      Value = (const __CFDictionary *)CFDictionaryGetValue(Copy[9], CFSTR("clientStates"));
      Copy = (CFDictionaryRef *)Value;
      if (!Value)
      {
LABEL_8:
        pthread_rwlock_unlock(v2);
        return Copy;
      }
      if (CFDictionaryGetCount(Value))
      {
        Copy = (CFDictionaryRef *)CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (CFDictionaryRef)Copy);
        goto LABEL_8;
      }
    }
    Copy = 0;
    goto LABEL_8;
  }
  return Copy;
}

uint64_t _SISetFileOptions(uint64_t result)
{
  gSIFileOptions = result;
  gDisablePreallocate = result & 1;
  return result;
}

uint64_t _SIGetFileOptions()
{
  return gSIFileOptions;
}

const __CFDictionary *_SIFilterValidatedCSImports(uint64_t a1, CFDictionaryRef theDict)
{
  const __CFDictionary *v2;
  CFMutableDictionaryRef Mutable;
  uint64_t v5;
  os_unfair_lock_s *v6;
  _QWORD v8[2];

  v2 = theDict;
  if (CFDictionaryGetCount(theDict) >= 1)
  {
    Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    v5 = *(_QWORD *)(a1 + 1704);
    v8[0] = Mutable;
    v8[1] = v5;
    v6 = (os_unfair_lock_s *)(a1 + 1696);
    os_unfair_lock_lock(v6);
    CFDictionaryApplyFunction(v2, (CFDictionaryApplierFunction)_validateImportsApplier, v8);
    os_unfair_lock_unlock(v6);
    return Mutable;
  }
  return v2;
}

void _validateImportsApplier(void *value, const void *a2, CFMutableDictionaryRef *a3)
{
  __CFBag *v4;
  uint64_t v7;
  uint64_t v8;

  v4 = a3[1];
  if ((const void *)*MEMORY[0x1E0C9B0D0] == a2)
  {
    CFBagRemoveValue(v4, value);
  }
  else
  {
    v7 = MEMORY[0x1BCCAF3F0](v4, value);
    if (v7)
    {
      v8 = v7;
      if (v7 >= 1)
      {
        do
        {
          CFBagRemoveValue(a3[1], value);
          --v8;
        }
        while (v8);
      }
      CFDictionaryAddValue(*a3, value, a2);
    }
  }
}

void SILogActivity(os_unfair_lock_s *a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  int v10;
  char *v11;
  uint64_t v12;
  os_unfair_lock_s *v13;
  int v14;
  void *v15[2];

  v15[0] = 0;
  v15[1] = &a9;
  v10 = vasprintf((char **)v15, a2, &a9);
  v11 = (char *)v15[0];
  if (v10 && v15[0])
  {
    v12 = (uint64_t)&a1[548];
    v13 = a1 + 556;
    os_unfair_lock_lock(v13);
    v14 = strlen(v11);
    activityJournalWrite(v12, 57, v11, v14 + 1);
    os_unfair_lock_unlock(v13);
    v11 = (char *)v15[0];
  }
  free(v11);
}

void *ci_position_run_init(uint64_t a1)
{
  void *result;
  char *v3;
  char *v4;
  const char *v5;
  uint64_t v6;

  *(_DWORD *)a1 = 0;
  *(_OWORD *)(a1 + 8) = xmmword_1B8631FD0;
  result = malloc_type_malloc(0x8000uLL, 0xA0127CDCuLL);
  *(_QWORD *)(a1 + 24) = result;
  if (!result)
  {
    v3 = __si_assert_copy_extra_268();
    v4 = v3;
    v5 = "";
    if (v3)
      v5 = v3;
    __message_assert(v3, "CIPositionRun.c", 11, "run->buffer", v5);
    free(v4);
    if (__valid_fs(-1))
      v6 = 2989;
    else
      v6 = 3072;
    *(_DWORD *)v6 = -559038737;
    abort();
  }
  return result;
}

void zstd_compress_init(void)
{
  uint64_t v0;
  FILE *v1;
  const char *v2;

  cctx = ZSTD_createCCtx();
  if (!cctx)
  {
    v1 = (FILE *)*MEMORY[0x1E0C80C10];
    v2 = "ZSTD_createCStream failed\n";
    goto LABEL_6;
  }
  ZSTD_createDStream();
  dctx = v0;
  if (!v0)
  {
    v1 = (FILE *)*MEMORY[0x1E0C80C10];
    v2 = "ZSTD_createDStream failed\n";
LABEL_6:
    fwrite(v2, 0x1AuLL, 1uLL, v1);
    exit(-1);
  }
}

uint64_t SI_PersistentIDStoreGetTypeID()
{
  uint64_t result;

  result = __kSI_PersistentIDStoreTypeID;
  if (!__kSI_PersistentIDStoreTypeID)
  {
    result = _CFRuntimeRegisterClass();
    __kSI_PersistentIDStoreTypeID = result;
  }
  return result;
}

double __SIPSIDStoreInit(uint64_t a1)
{
  double result;

  *(_QWORD *)(a1 + 240) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  return result;
}

void __SIPSIDStoreFinalize(uint64_t a1)
{
  void *v2;

  if (*(_QWORD *)(a1 + 16))
    (*(void (**)(uint64_t))(a1 + 32))(a1);
  v2 = *(void **)(a1 + 24);
  if (v2)
    free(v2);
}

uint64_t _oidParentForOid(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  int i;
  const char *v11;
  int v12;
  const char *v13;
  int v14;
  NSObject *v15;
  uint64_t v16;
  int v18;
  NSObject *v19;
  int v20;
  int v21;
  NSObject *v22;
  int v24;
  __int128 v25;
  uint64_t v26;
  uint8_t v27[4];
  const char *v28;
  __int16 v29;
  int v30;
  __int16 v31;
  int v32;
  __int16 v33;
  uint64_t v34;
  __int16 v35;
  const char *v36;
  __int16 v37;
  const char *v38;
  uint8_t buf[4];
  const char *v40;
  __int16 v41;
  int v42;
  __int16 v43;
  _BYTE v44[18];
  __int16 v45;
  const char *v46;
  _BYTE v47[1024];
  _OWORD v48[2];
  uint64_t v49;

  v49 = *MEMORY[0x1E0C80C00];
  for (i = 5; ; --i)
  {
    memset(v48, 0, sizeof(v48));
    bzero(v47, 0x400uLL);
    v11 = 0;
    v25 = xmmword_1B863153C;
    v26 = 0;
    if (!*(_BYTE *)(a1 + 240))
      v11 = (const char *)(*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, _QWORD))(a1 + 48))(a1, a2, v47, 0);
    if (!getattrlist(v11, &v25, v48, 0x20uLL, 0x200u))
      break;
    v12 = *__error();
    if (v12 != 2)
    {
      if (v12)
      {
        v14 = *__error();
        v15 = _SILogForLogForCategory(6);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        {
          v24 = *__error();
          *(_DWORD *)buf = 136315906;
          v40 = "_oidParentForOid";
          v41 = 1024;
          v42 = 750;
          v43 = 1024;
          *(_DWORD *)v44 = v24;
          *(_WORD *)&v44[4] = 2048;
          *(_QWORD *)&v44[6] = a2;
          _os_log_error_impl(&dword_1B8270000, v15, OS_LOG_TYPE_ERROR, "%s:%d: Error (%d) for 0x%llx", buf, 0x22u);
        }
        *__error() = v14;
        *__error() = v12;
      }
      return -1;
    }
    bzero(buf, 0x400uLL);
    if (*(_BYTE *)(a1 + 240))
      v13 = 0;
    else
      v13 = (const char *)(*(uint64_t (**)(uint64_t, uint64_t, uint8_t *, _QWORD, _QWORD, _QWORD, _QWORD, uint64_t))(a1 + 40))(a1, a2, buf, 0, 0, 0, 0, a7);
    if (*__error() != 35 && (!v13 || !strncmp(v13, "/Network/", 9uLL)))
      return -1;
    if (!i)
    {
      v20 = *__error();
      if (v13)
      {
        v21 = *__error();
        v22 = _SILogForLogForCategory(6);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)v27 = 136316418;
          v28 = "_oidParentForOid";
          v29 = 1024;
          v30 = 743;
          v31 = 1024;
          v32 = v20;
          v33 = 2048;
          v34 = a2;
          v35 = 2080;
          v36 = v11;
          v37 = 2080;
          v38 = v13;
          _os_log_error_impl(&dword_1B8270000, v22, OS_LOG_TYPE_ERROR, "%s:%d: stat succeeded, getattrlist returned error  %d for %lld (%s = %s)", v27, 0x36u);
        }
        *__error() = v21;
      }
      *__error() = v20;
      return -1;
    }
  }
  v16 = *(_QWORD *)((char *)v48 + 4);
  if (*(_QWORD *)((char *)v48 + 4) == a2 || *(_QWORD *)((char *)v48 + 4) <= 1)
  {
    if ((unint64_t)(*(_QWORD *)((char *)v48 + 4) - 3) <= 0xFFFFFFFFFFFFFFFDLL)
    {
      v18 = *__error();
      v19 = _SILogForLogForCategory(6);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136316162;
        v40 = "_oidParentForOid";
        v41 = 1024;
        v42 = 716;
        v43 = 2048;
        *(_QWORD *)v44 = v16;
        *(_WORD *)&v44[8] = 2048;
        *(_QWORD *)&v44[10] = a2;
        v45 = 2080;
        v46 = v11;
        _os_log_error_impl(&dword_1B8270000, v19, OS_LOG_TYPE_ERROR, "%s:%d: getattrlist returned parent id %lld for %lld (%s)", buf, 0x30u);
      }
      *__error() = v18;
    }
    return -1;
  }
  return v16;
}

uint64_t _oidPathForOid(uint64_t a1)
{
  uint64_t v1;
  unsigned int *v2;
  int v3;
  int v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  int v13;
  const char *v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v19;
  unsigned int v20;
  char v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unsigned int *v36;
  uint64_t v37;
  __int128 v38;
  uint64_t v39;
  _QWORD v40[513];
  _OWORD v41[2];
  _QWORD v42[130];

  v1 = MEMORY[0x1E0C80A78](a1);
  v36 = v2;
  v4 = v3;
  v6 = v5;
  v8 = v7;
  v9 = v1;
  v42[128] = *MEMORY[0x1E0C80C00];
  bzero(v42, 0x400uLL);
  memset(v41, 0, sizeof(v41));
  v37 = v8;
  if (v4)
    goto LABEL_3;
LABEL_2:
  v10 = 0;
  while (v8 != 2)
  {
    v11 = 0;
    v39 = 0;
    v38 = xmmword_1B8631524;
    v12 = v10;
    v13 = -1;
    while (1)
    {
      v14 = *(_BYTE *)(v9 + 240)
          ? 0
          : (const char *)(*(uint64_t (**)(uint64_t, uint64_t, _QWORD *, _QWORD))(v9 + 48))(v9, v8, v42, 0);
      if (getattrlist(v14, &v38, v41, 0x20uLL, 0x200u))
        break;
      v15 = 0;
      v16 = *((_QWORD *)&v41[0] + 1);
      v19 = DWORD1(v41[0]) != v13 && v13 != -1
         || (unint64_t)(*((_QWORD *)&v41[0] + 1) - 1) < 2
         || *((_QWORD *)&v41[0] + 1) == v8;
      if (v19 || v11 > 0x200)
        goto LABEL_27;
      ++v11;
      if (v13 == -1)
        v13 = DWORD1(v41[0]);
      v6[v12++] = *((_QWORD *)&v41[0] + 1);
      v8 = v16;
    }
    v20 = *__error();
    if (v20)
      v15 = v20;
    else
      v15 = 0xFFFFFFFFLL;
LABEL_27:
    if ((_DWORD)v12)
      v21 = v4;
    else
      v21 = 1;
    if (v12 <= 1 && (v21 & 1) != 0)
      goto LABEL_42;
    bzero(v40, 0x1008uLL);
    if (v12 >= 0x202)
    {
      v27 = __si_assert_copy_extra_268();
      __message_assert_272((uint64_t)v27, v28, v29, v30, v31, v32, v33, v34, (char)"SIVirtualPSIDSupport.c");
      free(v27);
      if (__valid_fs(-1))
        v35 = 2989;
      else
        v35 = 3072;
      *(_DWORD *)v35 = -559038737;
      abort();
    }
    __memcpy_chk();
    if ((v4 & 1) == 0)
      v40[v12] = v37;
    v22 = v12 + (v4 ^ 1);
    qsort_oids((uint64_t)v40, v22);
    if (v22 < 2)
    {
LABEL_42:
      if ((_DWORD)v15)
        return v15;
      v10 = v12 + 1;
      v6[v12] = 2;
      break;
    }
    v23 = v40[0];
    v24 = 1;
    while (1)
    {
      v25 = v40[v24];
      if (v25 == v23)
        break;
      ++v24;
      v23 = v25;
      if (v22 == v24)
        goto LABEL_42;
    }
    v8 = v37;
    if (!v4)
      goto LABEL_2;
LABEL_3:
    *v6 = v8;
    v10 = 1;
  }
  v15 = 0;
  *v36 = v10;
  return v15;
}

uint64_t _oidPathForPath(uint64_t a1)
{
  uint64_t v1;
  char v2;
  char v3;
  int v4;
  int v5;
  _QWORD *v6;
  _QWORD *v7;
  const char *v8;
  const char *v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  char v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  const char *v29;
  char v30;
  int v31;
  _QWORD v32[513];
  _BYTE v33[4096];
  char v34[1024];
  uint64_t v35;

  v1 = MEMORY[0x1E0C80A78](a1);
  v3 = v2;
  v5 = v4;
  v7 = v6;
  v9 = v8;
  v10 = v1;
  v35 = *MEMORY[0x1E0C80C00];
  bzero(v34, 0x400uLL);
  bzero(v33, 0x1000uLL);
  v11 = 0;
  v12 = 0;
  v31 = 0;
  v30 = v3;
  v29 = v9;
  if ((v3 & 0x10) != 0)
    goto LABEL_3;
LABEL_2:
  __strlcpy_chk();
  while (1)
  {
    if ((v5 & 1) == 0)
    {
      if (*(_BYTE *)(v10 + 240))
        return 0;
      v18 = (*(uint64_t (**)(uint64_t, char *, _QWORD, _QWORD, uint64_t))(v10 + 56))(v10, v34, 0, 0, 1);
      if (!v18)
        return 0;
      v12 = v18;
      v19 = strrchr(v34, 47);
      if (v19)
      {
        if (v19 == v34)
        {
          v17 = 0;
          *v7 = 2;
          return v17;
        }
        *v19 = 0;
      }
    }
    v17 = 0;
    do
    {
      if (*(_BYTE *)(v10 + 240))
      {
        v20 = 0;
      }
      else
      {
        v21 = (*(uint64_t (**)(uint64_t, char *, _QWORD, _QWORD, uint64_t))(v10 + 56))(v10, v34, 0, 0, 1);
        v20 = v21;
        if (v21)
        {
          v7[(int)v17] = v21;
          v17 = (v17 + 1);
        }
      }
      v22 = strrchr(v34, 47);
      if (!v22)
        break;
      if (v22 == v34)
        break;
      *v22 = 0;
    }
    while (v20 > 2);
    v23 = (_DWORD)v17 ? v5 : 1;
    if ((int)v17 <= 1 && (v23 & 1) != 0)
      break;
    bzero(v32, 0x1008uLL);
    __memcpy_chk();
    if ((v5 & 1) == 0)
      v32[(int)v17] = v12;
    v24 = v17 + (v5 ^ 1);
    qsort_oids((uint64_t)v32, (int)v24);
    if ((int)v24 < 2)
      break;
    v25 = v32[0];
    v26 = 1;
    while (1)
    {
      v27 = v32[v26];
      if (v27 == v25)
        break;
      ++v26;
      v25 = v27;
      if (v24 == v26)
        goto LABEL_39;
    }
    if (v11 && v11 == (_DWORD)v17 && !memcmp(v33, v7, 8 * (int)v17))
      return 0;
    __memcpy_chk();
    if (v31 == 101)
      return 0;
    ++v31;
    v11 = v17;
    v9 = v29;
    if ((v30 & 0x10) == 0)
      goto LABEL_2;
LABEL_3:
    if (!v9)
      return 0;
    v13 = open(v9, 32772);
    if (v13 < 0)
      return 0;
    v14 = v13;
    v15 = fcntl(v13, 50, v34);
    v16 = v34[0];
    close(v14);
    v17 = 0;
    if (v15 < 0 || !v16)
      return v17;
  }
LABEL_39:
  if (!(_DWORD)v17 || v7[(int)v17 - 1] != 2)
  {
    v7[(int)v17] = 2;
    return (v17 + 1);
  }
  return v17;
}

uint64_t _oidPathForOidFallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _DWORD *a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t result;
  uint64_t v16;
  int v17;
  int v18;
  _BYTE v19[1024];
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 240))
    return 0xFFFFFFFFLL;
  bzero(v19, 0x400uLL);
  v16 = (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, _QWORD, _QWORD, _QWORD, _QWORD, uint64_t))(a1 + 40))(a1, a2, v19, 0, 0, 0, 0, a10);
  if (!v16)
    return 0xFFFFFFFFLL;
  v17 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, _QWORD, _QWORD))(a1 + 64))(a1, v16, 0, a3, a4, 0, 0);
  if (v17 < 0)
    return 0xFFFFFFFFLL;
  v18 = v17;
  result = 0;
  *a6 = v18;
  return result;
}

uint64_t _oidParentForOidFallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  char *v12;
  char *v13;
  char *v14;
  _BYTE v15[1024];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (a2 == 2)
    return 0;
  bzero(v15, 0x400uLL);
  if (*(_BYTE *)(a1 + 240))
    return -1;
  v12 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, _QWORD, _QWORD, _QWORD, _QWORD, uint64_t))(a1 + 40))(a1, a2, v15, 0, 0, 0, 0, a7);
  if (!v12)
    return -1;
  v13 = v12;
  if (!*v12)
    return -1;
  v14 = strrchr(v12, 47);
  if (!v14)
    return -1;
  *v14 = 0;
  if (*(_BYTE *)(a1 + 240))
    return 0;
  return (*(uint64_t (**)(uint64_t, char *, _QWORD, uint64_t, _QWORD))(a1 + 56))(a1, v13, 0, a3, 0);
}

_OWORD *SIPersistentIDStoreCreate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  _OWORD *Instance;
  _OWORD *v9;
  char *v10;
  int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  __int16 v15;
  int v16;
  NSObject *v17;
  os_log_type_t v18;
  int v19;
  BOOL v20;
  _OWORD *v21;
  _OWORD v23[64];
  uint8_t buf[16];
  uint64_t v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if (!__kSI_PersistentIDStoreTypeID)
    __kSI_PersistentIDStoreTypeID = _CFRuntimeRegisterClass();
  Instance = (_OWORD *)_CFRuntimeCreateInstance();
  v9 = Instance;
  if (a3 && (*(_DWORD *)(a3 + 4) & 0x80000000) == 0)
  {
    if ((*(_WORD *)(a3 + 28) & 0x220) != 0)
    {
      Instance[12] = xmmword_1E6E299E0;
      Instance[13] = unk_1E6E299F0;
      Instance[14] = xmmword_1E6E29A00;
      Instance[8] = xmmword_1E6E299A0;
      Instance[9] = unk_1E6E299B0;
      Instance[10] = xmmword_1E6E299C0;
      Instance[11] = unk_1E6E299D0;
      Instance[4] = xmmword_1E6E29960;
      Instance[5] = unk_1E6E29970;
      Instance[6] = xmmword_1E6E29980;
      Instance[7] = *(_OWORD *)&off_1E6E29990;
      Instance[2] = SI_PersistentIDStore_OID64_TEMPLATE;
      Instance[3] = *(_OWORD *)&off_1E6E29950;
      v10 = (char *)malloc_type_malloc(0x1CuLL, 0x100004054FF68E2uLL);
      *((_QWORD *)v9 + 2) = v10;
      *(_WORD *)v10 = *(_WORD *)(a3 + 16);
      *(_QWORD *)(v10 + 12) = *(_QWORD *)(a3 + 8);
      v11 = *((_WORD *)v10 + 10) & 0xFFEF | (16 * ((*(unsigned __int16 *)(a3 + 28) >> 5) & 1));
      *((_WORD *)v10 + 10) = v11;
      v12 = v11 & 0xFFFFFFFE | *(_WORD *)(a3 + 28) & 1;
      *((_WORD *)v10 + 10) = v12;
      v13 = v12 & 0xFFFFFFFD | (2 * ((*(unsigned __int16 *)(a3 + 28) >> 1) & 1));
      *((_WORD *)v10 + 10) = v13;
      v14 = v13 & 0xFFFFFFFB | (4 * ((*(unsigned __int16 *)(a3 + 28) >> 2) & 1));
      *((_WORD *)v10 + 10) = v14;
      *(_QWORD *)(v10 + 4) = *(_QWORD *)(a3 + 20);
      *((_WORD *)v10 + 10) = v14 & 0xFFDF;
      LOWORD(v14) = v14 & 0xFF9F | (((*(_WORD *)(a3 + 28) >> 4) & 1) << 6);
      *((_WORD *)v10 + 10) = v14;
      v15 = v14 & 0xFF7F | (*(_WORD *)(a3 + 28) >> 3) & 0x80;
      *((_WORD *)v10 + 10) = v15;
      *((_WORD *)v10 + 10) = v15 & 0xFEFF | (*(_WORD *)(a3 + 28) >> 3) & 0x100;
      v25 = 0;
      *(_OWORD *)buf = xmmword_1B862C180;
      memset(v23, 0, 44);
      if (!fgetattrlist(*(_DWORD *)(a3 + 4), buf, v23, 0x2CuLL, 0))
        *((_WORD *)v10 + 10) = BYTE6(v23[0]) & 0x20 | *((_WORD *)v10 + 10) & 0xFFDF;
      if ((*(_DWORD *)(a3 + 28) & 0x220) == 0x200)
      {
        *((_QWORD *)v9 + 7) = si_oid64psid_transient_path_to_oid;
        *((_QWORD *)v9 + 5) = si_transient_oid64psid_oid_to_path;
        *((_QWORD *)v9 + 22) = SIPersistentIDStoreSandboxPostCheck;
      }
      *((_DWORD *)v10 + 6) = -1;
    }
    else if ((_DWORD)a2 == -1 || si_init_posix_psid((uint64_t)Instance, a3, a2, a5, 0))
    {
      CFRelease(v9);
      bzero(v23, 0x400uLL);
      v16 = *__error();
      v17 = _SILogForLogForCategory(0);
      v18 = 2 * (gSILogLevels[0] < 4);
      if (os_log_type_enabled(v17, v18))
      {
        v19 = fcntl(a2, 50, v23);
        if (LOBYTE(v23[0]))
          v20 = v19 < 0;
        else
          v20 = 1;
        if (v20)
          v21 = 0;
        else
          v21 = v23;
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)&buf[4] = v21;
        _os_log_impl(&dword_1B8270000, v17, v18, "Couldn't make psid store at %s", buf, 0xCu);
      }
      v9 = 0;
      *__error() = v16;
      return v9;
    }
  }
  if ((a5 & 1) != 0 && v9)
  {
    *((_BYTE *)v9 + 120) = 0;
  }
  else if (!v9)
  {
    return v9;
  }
  if ((*(_BYTE *)(a3 + 28) & 0x20) != 0)
  {
    if (!*((_QWORD *)v9 + 16))
      *((_QWORD *)v9 + 16) = _oidParentForOid;
    if (!*((_QWORD *)v9 + 17))
      *((_QWORD *)v9 + 17) = _oidPathForOid;
    if (!*((_QWORD *)v9 + 8))
      *((_QWORD *)v9 + 8) = _oidPathForPath;
  }
  else
  {
    if (!*((_QWORD *)v9 + 17))
      *((_QWORD *)v9 + 17) = _oidPathForOidFallback;
    if (!*((_QWORD *)v9 + 16))
      *((_QWORD *)v9 + 16) = _oidParentForOidFallback;
  }
  return v9;
}

uint64_t SIPersistentIDStoreClose(uint64_t result)
{
  int v1;
  BOOL v2;
  uint64_t (*v3)(void);

  v1 = *(unsigned __int8 *)(result + 240);
  *(_BYTE *)(result + 240) = 1;
  if (*(_QWORD *)(result + 16))
    v2 = v1 == 0;
  else
    v2 = 0;
  if (v2)
  {
    v3 = *(uint64_t (**)(void))(result + 112);
    if (v3)
      return v3();
  }
  return result;
}

uint64_t SIPersistentIDStoreGetOIDForCPath(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 240))
    return 0;
  else
    return (*(uint64_t (**)(void))(a1 + 56))();
}

uint64_t SIPersistentIDStoreGetRealPathForOid(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 240))
    return 0;
  else
    return (*(uint64_t (**)(void))(a1 + 40))();
}

uint64_t SIPersistentIDStoreGetFastPathForOid(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 240))
    return 0;
  else
    return (*(uint64_t (**)(void))(a1 + 48))();
}

uint64_t SIPersistentIDStoreRename(uint64_t result)
{
  uint64_t (*v1)(void);

  v1 = *(uint64_t (**)(void))(result + 96);
  if (v1)
  {
    if (!*(_BYTE *)(result + 240))
      return v1();
  }
  return result;
}

uint64_t SIPersistentIDStoreDelete(uint64_t result)
{
  uint64_t (*v1)(void);

  v1 = *(uint64_t (**)(void))(result + 104);
  if (v1)
  {
    if (!*(_BYTE *)(result + 240))
      return v1();
  }
  return result;
}

uint64_t SIPersistentIDStoreSetRootPath(uint64_t a1)
{
  return SIPersistentIDStoreSetRootPath2(a1);
}

uint64_t SIPersistentIDStoreSetRootPath2(uint64_t a1)
{
  uint64_t (*v2)(void);
  uint64_t (*v3)(void);

  if (!a1 || *(_BYTE *)(a1 + 240))
    return 0;
  v2 = *(uint64_t (**)(void))(a1 + 200);
  if (v2)
    return v2();
  v3 = *(uint64_t (**)(void))(a1 + 72);
  if (!v3)
    return 0;
  return v3();
}

uint64_t SIPersistentIDStoreSync(uint64_t a1)
{
  uint64_t (*v1)(void);

  v1 = *(uint64_t (**)(void))(a1 + 88);
  if (v1 && !*(_BYTE *)(a1 + 240))
    return v1();
  else
    return 0;
}

uint64_t SIPersistentIDStoreSupportsDirMap(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 120);
}

uint64_t SIPersistentIDStoreCheckAccessAndScopesForOIDs(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 80))();
}

uint64_t SIPersistentIDStoreGetParentForOid(uint64_t a1)
{
  uint64_t (*v1)(void);

  v1 = *(uint64_t (**)(void))(a1 + 128);
  if (v1)
    return v1();
  else
    return -1;
}

uint64_t SIPersistentIDStoreGetOidPathForPath(uint64_t a1)
{
  uint64_t (*v2)(void);

  if (*(_BYTE *)(a1 + 240))
    return 0;
  v2 = *(uint64_t (**)(void))(a1 + 64);
  if (!v2)
    return 0;
  else
    return v2();
}

uint64_t SIPersistentIDStoreGetOidPathForOid(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  uint64_t result;
  uint64_t (*v6)(uint64_t, uint64_t);
  uint64_t v9;

  *a5 = 0;
  if (!a1)
    return 0xFFFFFFFFLL;
  if (*(_BYTE *)(a1 + 240))
    return 0xFFFFFFFFLL;
  v6 = *(uint64_t (**)(uint64_t, uint64_t))(a1 + 136);
  if (!v6)
    return 0xFFFFFFFFLL;
  result = v6(a1, a2);
  if (!(_DWORD)result)
  {
    v9 = *a5;
    if ((_DWORD)v9 && (v9 > 0x1FF || *(_QWORD *)(a3 + 8 * (v9 - 1)) == 2))
    {
      return 0;
    }
    else
    {
      result = 0;
      *a5 = v9 + 1;
      *(_QWORD *)(a3 + 8 * v9) = 2;
    }
  }
  return result;
}

uint64_t SIPersistentIDStoreVetPath(uint64_t a1, char *a2, int a3)
{
  uint64_t (*v5)(void);
  stat v7;

  if (*(_BYTE *)(a1 + 240))
    return 0;
  v5 = *(uint64_t (**)(void))(a1 + 152);
  if (v5)
    return v5();
  memset(&v7, 0, sizeof(v7));
  return !stat(a2, &v7) && v7.st_dev == a3;
}

uint64_t SIPersistentIDStoreSandboxPostCheck()
{
  return 1;
}

BOOL SIPersistentIDStoreIsLocal(_BOOL8 result)
{
  if (result)
    return *(_BYTE *)(result + 160) == 0;
  return result;
}

uint64_t SIPersistentIDStoreItemIdentifier(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t (*v6)(void);

  if (a1)
  {
    if (!*(_BYTE *)(a1 + 160))
    {
      v6 = *(uint64_t (**)(void))(a1 + 184);
      if (v6)
        return v6();
    }
  }
  *a5 = 0;
  return 45;
}

void storage_array_Init(_DWORD *a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7, char a8, char a9, int a10, void *aBlock, uint64_t a12)
{
  uint64_t v20;
  void *v21;
  int v22;
  NSObject *v23;
  unint64_t st_size;
  char *v25;
  char *v26;
  const char *v27;
  int v28;
  void *v29;
  _OWORD *v30;
  char *v31;
  const char *v32;
  uint64_t v33;
  stat buf;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  bzero(a1, 0x1080uLL);
  if (a12)
    (*(void (**)(uint64_t))(a12 + 16))(a12);
  if (a5)
  {
    *a1 = a10;
    if ((a6 & 1) != 0)
    {
      *((_QWORD *)a1 + 4) = a5;
      v20 = (uint64_t)(a1 + 8);
      *((_QWORD *)a1 + 1) = a4;
      *((_QWORD *)a1 + 2) = a2;
      *((_BYTE *)a1 + 60) = a8;
      *((_QWORD *)a1 + 5) = a3 + a2;
      a1[14] = 1;
      *((_BYTE *)a1 + 61) = 0;
      if (aBlock)
        v21 = _Block_copy(aBlock);
      else
        v21 = 0;
      *((_QWORD *)a1 + 8) = v21;
      *((_BYTE *)a1 + 72) = 26;
      bzero(a1 + 20, 0x1000uLL);
      *((_QWORD *)a1 + 6) = a2;
      goto LABEL_24;
    }
    st_size = *((_QWORD *)a1 + 5);
    if (st_size)
    {
      if (st_size < *((_QWORD *)a1 + 6))
      {
        v25 = __si_assert_copy_extra_268();
        v26 = v25;
        v27 = "";
        if (v25)
          v27 = v25;
        __message_assert(v25, "storage_array.c", 395, "inStartSize >= inStorage->_windows._freeRegion", v27);
        goto LABEL_32;
      }
    }
    else
    {
      memset(&buf, 0, sizeof(buf));
      v28 = fd_stat(a5, &buf);
      st_size = buf.st_size;
      if (v28)
        st_size = a3;
      *((_QWORD *)a1 + 1) = a4;
      *((_QWORD *)a1 + 2) = a2;
      if (st_size < *((_QWORD *)a1 + 6))
      {
        v31 = __si_assert_copy_extra_268();
        v26 = v31;
        v32 = "";
        if (v31)
          v32 = v31;
        __message_assert(v31, "storage_array.c", 391, "inStartSize >= inStorage->_windows._freeRegion", v32);
LABEL_32:
        free(v26);
        if (__valid_fs(-1))
          v33 = 2989;
        else
          v33 = 3072;
        *(_DWORD *)v33 = -559038737;
        abort();
      }
    }
    *((_QWORD *)a1 + 4) = a5;
    v20 = (uint64_t)(a1 + 8);
    *((_BYTE *)a1 + 60) = a8;
    *((_QWORD *)a1 + 5) = st_size;
    a1[14] = 1;
    *((_BYTE *)a1 + 61) = 0;
    if (aBlock)
      v29 = _Block_copy(aBlock);
    else
      v29 = 0;
    *((_QWORD *)a1 + 8) = v29;
    *((_BYTE *)a1 + 72) = 26;
    bzero(a1 + 20, 0x1000uLL);
LABEL_24:
    a1[6] = a7;
    *((_QWORD *)a1 + 4) = a5;
    v30 = malloc_type_malloc(0xD0uLL, 0x1020040167D79A3uLL);
    *((_QWORD *)a1 + 527) = v30;
    *v30 = 0u;
    v30[1] = 0u;
    v30[2] = 0u;
    v30[3] = 0u;
    v30[4] = 0u;
    v30[5] = 0u;
    v30[6] = 0u;
    v30[7] = 0u;
    v30[8] = 0u;
    v30[9] = 0u;
    v30[10] = 0u;
    v30[11] = 0u;
    v30[12] = 0u;
    pthread_rwlock_init(*((pthread_rwlock_t **)a1 + 527), 0);
    *((_BYTE *)a1 + 4180) = a8;
    *((_BYTE *)a1 + 4182) = a9 & ~a8;
    a1[1052] = 0;
    _windowsMapInit(v20, 0);
    if ((a8 & 1) == 0)
    {
      if (a6)
        fd_truncate(a5, 0);
      fd_truncate(a5, *((_QWORD *)a1 + 5));
    }
    return;
  }
  v22 = *__error();
  v23 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
  {
    buf.st_dev = 136315394;
    *(_QWORD *)&buf.st_mode = "storage_array_Init";
    WORD2(buf.st_ino) = 1024;
    *(_DWORD *)((char *)&buf.st_ino + 6) = 372;
    _os_log_error_impl(&dword_1B8270000, v23, OS_LOG_TYPE_ERROR, "%s:%d: storage_array_Init - inFdPtr == NULL", (uint8_t *)&buf, 0x12u);
  }
  *__error() = v22;
}

void storage_array_Close(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t *v4;
  pthread_rwlock_t *v5;

  v2 = a1 + 32;
  if (*(int *)(a1 + 56) >= 1)
  {
    v3 = 0;
    v4 = (uint64_t *)(a1 + 80);
    do
    {
      storageWindowReleaseImmediate(v4);
      ++v3;
      ++v4;
    }
    while (v3 < *(int *)(a1 + 56));
  }
  storageWindowsClose(v2);
  v5 = *(pthread_rwlock_t **)(a1 + 4216);
  if (v5)
  {
    pthread_rwlock_wrlock(v5);
    _release_read_window(&availableArrayReaders, *(unsigned int **)(*(_QWORD *)(a1 + 4216) + 200));
    pthread_rwlock_unlock(*(pthread_rwlock_t **)(a1 + 4216));
    pthread_rwlock_destroy(*(pthread_rwlock_t **)(a1 + 4216));
    free(*(void **)(a1 + 4216));
    *(_QWORD *)(a1 + 4216) = 0;
  }
  *(_BYTE *)(a1 + 4181) = 1;
}

int *storage_array_SyncPages(uint64_t a1, uint64_t a2)
{
  _BYTE *v4;
  unint64_t v5;
  unint64_t v6;
  double Current;
  uint64_t v8;
  CFIndex v9;
  int v10;
  unint64_t v11;
  void *v12;
  void *v13;
  int v14;
  uint64_t v15;
  int v16;
  const char *v17;
  int v18;
  NSObject *v19;
  int v20;
  NSObject *v21;
  os_log_type_t v22;
  float v23;
  int *result;
  const char *v25;
  int v26;
  const char *v27;
  __int16 v28;
  int v29;
  __int16 v30;
  int v31;
  __int16 v32;
  uint64_t v33;
  __int16 v34;
  int v35;
  __int16 v36;
  const char *v37;
  uint8_t buf[4];
  int v39;
  __int16 v40;
  int v41;
  __int16 v42;
  double v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  v4 = (_BYTE *)(a1 + 4180);
  v5 = *(_QWORD *)(a1 + 48) + 0xFFFFFLL;
  v6 = v5 >> 20;
  Current = CFAbsoluteTimeGetCurrent();
  if (!*v4 && v4[2] && *(int *)(a1 + 56) >= 1)
  {
    v15 = 0;
    do
      storageWindowSync(*(_QWORD **)(a1 + 80 + 8 * v15++), 0);
    while (v15 < *(int *)(a1 + 56));
  }
  if (!(_DWORD)v6)
  {
    v10 = 0;
    goto LABEL_26;
  }
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = (v5 >> 20);
  while (1)
  {
    if (*(_QWORD *)a2 <= v9 || !CFBitVectorGetBitAtIndex(*(CFBitVectorRef *)(a2 + 16), v9))
      goto LABEL_14;
    v12 = (void *)fd_mmap(*(_QWORD *)(a1 + 32));
    if (v12 == (void *)-1)
      break;
    v13 = v12;
    if (msync(v12, 0x100000uLL, 16))
      v14 = *__error();
    else
      v14 = 0;
    if (munmap(v13, 0x100000uLL))
      v14 = *__error();
    ++v10;
    if (v14)
      goto LABEL_26;
LABEL_14:
    ++v9;
    v8 += 0x100000;
    if (v9 >= v11)
      goto LABEL_26;
  }
  v16 = *__error();
  bzero(buf, 0x400uLL);
  v17 = fd_realpath(*(_DWORD **)(a1 + 32), buf);
  if (!v17)
    v17 = fd_name(*(_QWORD *)(a1 + 32), (char *)buf, 0x400uLL);
  v18 = *__error();
  v19 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    v25 = "";
    v26 = 136316418;
    v27 = "storage_array_SyncPages";
    v28 = 1024;
    if (v17)
      v25 = v17;
    v29 = 510;
    v30 = 1024;
    v31 = 0x100000;
    v32 = 2048;
    v33 = v8;
    v34 = 1024;
    v35 = v16;
    v36 = 2080;
    v37 = v25;
    _os_log_error_impl(&dword_1B8270000, v19, OS_LOG_TYPE_ERROR, "%s:%d: mmap(%d, %lld) err:%d, %s", (uint8_t *)&v26, 0x32u);
  }
  *__error() = v18;
LABEL_26:
  v20 = *__error();
  v21 = _SILogForLogForCategory(10);
  v22 = 2 * (dword_1EF19FCB4 < 4);
  if (os_log_type_enabled(v21, v22))
  {
    v23 = CFAbsoluteTimeGetCurrent() - Current;
    *(_DWORD *)buf = 67109632;
    v39 = v6;
    v40 = 1024;
    v41 = v10;
    v42 = 2048;
    v43 = v23;
    _os_log_impl(&dword_1B8270000, v21, v22, "sync pages (%d, %d) took %f seconds", buf, 0x18u);
  }
  result = __error();
  *result = v20;
  return result;
}

uint64_t _storage_array_Expand(uint64_t a1)
{
  uint64_t v2;
  pthread_rwlock_t *v3;
  unsigned int *sig;

  v2 = _storageWindowsExpandBacking((_DWORD **)(a1 + 32), *(_QWORD *)(a1 + 8));
  if ((_DWORD)v2)
  {
    pthread_rwlock_wrlock(*(pthread_rwlock_t **)(a1 + 4216));
    v3 = *(pthread_rwlock_t **)(a1 + 4216);
    sig = (unsigned int *)v3[1].__sig;
    v3[1].__sig = 0;
    pthread_rwlock_unlock(v3);
    _release_read_window(&availableArrayReaders, sig);
  }
  return v2;
}

_DWORD *storage_array_Truncate(uint64_t *a1)
{
  _DWORD *result;
  int v3;
  int v4;
  NSObject *v5;
  int v6;
  const char *v7;
  __int16 v8;
  int v9;
  __int16 v10;
  int v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  result = (_DWORD *)fd_truncate(a1[4], a1[6]);
  if ((_DWORD)result == -1)
  {
    v3 = *__error();
    v4 = *__error();
    v5 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v6 = 136315650;
      v7 = "storage_array_Truncate";
      v8 = 1024;
      v9 = 610;
      v10 = 1024;
      v11 = v3;
      _os_log_error_impl(&dword_1B8270000, v5, OS_LOG_TYPE_ERROR, "%s:%d: ftruncate error %d", (uint8_t *)&v6, 0x18u);
    }
    result = __error();
    *result = v4;
  }
  else
  {
    a1[5] = a1[6];
  }
  return result;
}

void bit_vector_set_9027(uint64_t a1, CFIndex idx)
{
  CFIndex v4;
  CFIndex v5;
  char *v6;
  char *v7;
  const char *v8;
  uint64_t v9;
  const __CFBitVector *v10;
  const __CFAllocator *v11;
  __CFBitVector *MutableCopy;
  __CFBitVector *v13;
  const void *v14;
  char *v15;
  const char *v16;

  v4 = *(_QWORD *)(a1 + 8);
  if (v4 <= idx)
  {
    if (v4)
      v5 = *(_QWORD *)(a1 + 8);
    else
      v5 = 32;
    while (1)
    {
      v5 *= 2;
      if (v5 > idx)
        break;
      if (v5 <= v4)
      {
        v6 = __si_assert_copy_extra_268();
        v7 = v6;
        v8 = "";
        if (v6)
          v8 = v6;
        __message_assert(v6, "bit_vector.h", 111, "newCapacity > bv->capacity", v8);
        goto LABEL_13;
      }
    }
    v10 = *(const __CFBitVector **)(a1 + 16);
    v11 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    if (v10)
      MutableCopy = CFBitVectorCreateMutableCopy(v11, v5, v10);
    else
      MutableCopy = CFBitVectorCreateMutable(v11, v5);
    v13 = MutableCopy;
    if (!MutableCopy)
    {
      v15 = __si_assert_copy_extra_268();
      v7 = v15;
      v16 = "";
      if (v15)
        v16 = v15;
      __message_assert(v15, "bit_vector.h", 115, "newBV", v16);
LABEL_13:
      free(v7);
      if (__valid_fs(-1))
        v9 = 2989;
      else
        v9 = 3072;
      *(_DWORD *)v9 = -559038737;
      abort();
    }
    CFBitVectorSetCount(MutableCopy, v5);
    v14 = *(const void **)(a1 + 16);
    if (v14)
      CFRelease(v14);
    *(_QWORD *)(a1 + 8) = v5;
    *(_QWORD *)(a1 + 16) = v13;
  }
  if (*(_QWORD *)a1 <= idx)
    *(_QWORD *)a1 = idx + 1;
  CFBitVectorSetBitAtIndex(*(CFMutableBitVectorRef *)(a1 + 16), idx, 1u);
}

uint64_t CIPositionNodeFinalizeDocument(uint64_t a1)
{
  uint64_t v1;
  int v2;
  int v3;
  int v4;
  int v5;
  unsigned int *v6;
  unsigned int *v7;
  uint64_t v8;
  unsigned int v9;
  size_t v10;
  _BYTE *v11;
  _BYTE *v12;
  __n128 v13;
  unsigned int *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  size_t v18;
  _DWORD *v19;
  char *v20;
  unsigned int v21;
  char *v23;
  char *v24;
  const char *v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int v28;
  _BYTE v29[65536];
  uint64_t v30;

  v1 = MEMORY[0x1E0C80A78](a1);
  v3 = v2;
  v5 = v4;
  v7 = v6;
  v8 = v1;
  v30 = *MEMORY[0x1E0C80C00];
  v9 = v6[2];
  if (v2)
    v10 = 5 * v9 + 6;
  else
    v10 = 5 * v9 + 1;
  if (v10 <= 0x10000)
  {
    v11 = 0;
    v12 = v29;
  }
  else
  {
    v11 = malloc_type_malloc(v10, 0x7863C65CuLL);
    v12 = v11;
  }
  bzero(v29, 0x10000uLL);
  v28 = 0;
  v27 = 0;
  v14 = CompactPositionsList((uint64_t)v12, v7[6], v9, v5, v3, &v28, *v7, v7[1], v13, &v27, v8);
  v15 = v27;
  v12[v27] = 0;
  v16 = positionInfoAlloc_ts(v8, v15 + 9);
  if (!(_DWORD)v16)
  {
    v23 = __si_assert_copy_extra(0);
    v24 = v23;
    v25 = "";
    if (v23)
      v25 = v23;
    __message_assert("%s:%u: failed assertion '%s' %s ", "CIPayloadData.c", 251, "posPtrStart!=0", v25);
    free(v24);
    if (__valid_fs(-1))
      v26 = 2989;
    else
      v26 = 3072;
    *(_DWORD *)v26 = -559038737;
    abort();
  }
  v17 = v16;
  v18 = v15 + 1;
  v19 = (_DWORD *)(*(_QWORD *)(v8 + 16) + 8 * v16);
  *v19 = v18;
  v20 = (char *)(v19 + 1);
  memcpy(v20, v12, v18);
  v21 = v28;
  if (!v28)
  {
    if (v14)
      v21 = v14[1];
    else
      v21 = 0;
  }
  *(_DWORD *)&v20[v18] = v21;
  if (v5)
  {
    *v7 = 0;
    v7[1] = v17;
    v7[2] = 0;
  }
  if (v11)
    free(v11);
  return v17;
}

unsigned int *CompactPositionsList(uint64_t a1, unsigned int a2, unsigned int a3, int a4, int a5, _DWORD *a6, unsigned int a7, unsigned int a8, __n128 a9, uint64_t *a10, uint64_t a11)
{
  unsigned int v11;
  uint64_t v16;
  uint64_t v17;
  _BYTE *v18;
  _BYTE *v19;
  _BYTE *v20;
  uint64_t v21;
  uint64_t v22;
  int *v23;
  unsigned int *v24;
  int v25;
  int *v26;
  unsigned int v27;
  unsigned int v28;
  uint64_t v29;
  uint64_t v35;
  uint64_t v36;
  _BYTE *v37;
  _BYTE *v38;
  _BYTE *v39;
  uint64_t v40;
  uint64_t v41;
  unsigned int v42;
  unsigned int *v43;
  unsigned int v44;
  int *v45;
  uint64_t v46;
  int v47;
  unsigned int v48;
  unsigned int v49;
  unsigned int v51;
  uint64_t v52;
  uint64_t v53;
  _BYTE *v54;
  _BYTE *v55;
  _BYTE *v56;
  uint64_t v57;
  int v59;
  NSObject *v60;
  int v61;
  NSObject *v62;
  NSObject *log;
  NSObject *loga;
  int v65;
  int v66;
  NSObject *v67;
  NSObject *v68;
  unsigned int v69;
  int v70;
  int v71;
  unsigned int v72;
  __n128 v73;
  __n128 v74;
  _DWORD *v75;
  _DWORD *v76;
  _DWORD *v77;
  uint8_t buf[4];
  unsigned int v79;
  uint64_t v80;

  v11 = a7;
  v80 = *MEMORY[0x1E0C80C00];
  *a6 = 0;
  if (!a8)
  {
    _X22 = 0;
    if (a5)
      goto LABEL_3;
LABEL_6:
    v16 = 0;
    goto LABEL_15;
  }
  _X22 = (unsigned int *)(*(_QWORD *)(a11 + 16) + 8 * a8);
  if (!a5)
    goto LABEL_6;
LABEL_3:
  if (a2 > 0x7F)
  {
    if (a2 >> 14)
    {
      if (a2 >> 21)
      {
        if (a2 >> 28)
        {
          *(_BYTE *)a1 = -16;
          *(_DWORD *)(a1 + 1) = a2;
          v16 = 5;
        }
        else
        {
          *(_BYTE *)a1 = HIBYTE(a2) | 0xE0;
          *(_BYTE *)(a1 + 1) = BYTE2(a2);
          *(_BYTE *)(a1 + 2) = BYTE1(a2);
          *(_BYTE *)(a1 + 3) = a2;
          v16 = 4;
        }
      }
      else
      {
        *(_BYTE *)a1 = BYTE2(a2) | 0xC0;
        *(_BYTE *)(a1 + 1) = BYTE1(a2);
        *(_BYTE *)(a1 + 2) = a2;
        v16 = 3;
      }
    }
    else
    {
      *(_BYTE *)a1 = BYTE1(a2) | 0x80;
      *(_BYTE *)(a1 + 1) = a2;
      v16 = 2;
    }
  }
  else
  {
    *(_BYTE *)a1 = a2;
    v16 = 1;
  }
  *a10 = v16;
LABEL_15:
  if (a7 > 0x7F)
  {
    if (a7 >> 14)
    {
      if (a7 >> 21)
      {
        if (a7 >> 28)
        {
          v21 = a1 + v16;
          *(_BYTE *)v21 = -16;
          *(_DWORD *)(v21 + 1) = a7;
          v17 = v16 + 5;
        }
        else
        {
          v20 = (_BYTE *)(a1 + v16);
          *v20 = HIBYTE(a7) | 0xE0;
          v20[1] = BYTE2(a7);
          v20[2] = BYTE1(a7);
          v17 = v16 + 4;
          v20[3] = a7;
        }
      }
      else
      {
        v19 = (_BYTE *)(a1 + v16);
        *v19 = BYTE2(a7) | 0xC0;
        v19[1] = BYTE1(a7);
        v17 = v16 + 3;
        v19[2] = a7;
      }
    }
    else
    {
      v18 = (_BYTE *)(a1 + v16);
      *v18 = BYTE1(a7) | 0x80;
      v17 = v16 + 2;
      v18[1] = a7;
    }
  }
  else
  {
    v17 = v16 + 1;
    *(_BYTE *)(a1 + v16) = a7;
  }
  v22 = a8;
  *a10 = v17;
  v23 = (int *)&unk_1EF19F000;
  if (dword_1EF19FCB4 >= 5)
  {
    v72 = a3;
    v77 = a6;
    v59 = *__error();
    v60 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      v79 = a2;
      _os_log_impl(&dword_1B8270000, v60, OS_LOG_TYPE_DEFAULT, "DocID: %d", buf, 8u);
    }
    *__error() = v59;
    v23 = (int *)&unk_1EF19F000;
    a6 = v77;
    a3 = v72;
    if (dword_1EF19FCB4 >= 5)
    {
      v61 = *__error();
      v62 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109120;
        v79 = v11;
        _os_log_impl(&dword_1B8270000, v62, OS_LOG_TYPE_DEFAULT, "Start pos: %d", buf, 8u);
      }
      *__error() = v61;
      a6 = v77;
      v23 = (_DWORD *)&unk_1EF19F000;
      a3 = v72;
    }
  }
  if (a4)
  {
    if (a3 >= 2)
    {
      v24 = (unsigned int *)(a11 + 24);
      v25 = 1;
      v26 = &dword_1B8270000;
      a9.n128_u64[0] = 67109120;
      do
      {
        v27 = v11;
        v11 = *_X22;
        v28 = v27 - *_X22;
        if (v23[813] >= 5)
        {
          v73 = a9;
          v45 = v26;
          v69 = a3;
          v75 = a6;
          v65 = *__error();
          log = _SILogForLogForCategory(10);
          if (os_log_type_enabled(log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = v73.n128_u32[0];
            v79 = v11;
            _os_log_impl(v45, log, OS_LOG_TYPE_DEFAULT, "Next: %d", buf, 8u);
          }
          *__error() = v65;
          v23 = (int *)&unk_1EF19F000;
          a6 = v75;
          a3 = v69;
          v26 = v45;
          a9 = v73;
          if (dword_1EF19FCB4 >= 5)
          {
            v66 = *__error();
            loga = _SILogForLogForCategory(10);
            if (os_log_type_enabled(loga, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = v73.n128_u32[0];
              v79 = v28;
              _os_log_impl(v45, loga, OS_LOG_TYPE_DEFAULT, "Delta: %d", buf, 8u);
            }
            *__error() = v66;
            a6 = v75;
            v23 = (_DWORD *)&unk_1EF19F000;
            a3 = v69;
            v26 = v45;
            a9 = v73;
          }
        }
        v29 = _X22[1];
        if ((_DWORD)v29)
          _X22 = (unsigned int *)(*(_QWORD *)(a11 + 16) + 8 * v29);
        else
          _X22 = 0;
        __asm { PRFM            #0, [X22] }
        v35 = *a10;
        if (v28 > 0x7F)
        {
          if (v28 >> 14)
          {
            if (v28 >> 21)
            {
              if (v28 >> 28)
              {
                v40 = a1 + v35;
                *(_BYTE *)v40 = -16;
                *(_DWORD *)(v40 + 1) = v28;
                v36 = v35 + 5;
              }
              else
              {
                v39 = (_BYTE *)(a1 + v35);
                *v39 = HIBYTE(v28) | 0xE0;
                v39[1] = BYTE2(v28);
                v39[2] = BYTE1(v28);
                v36 = v35 + 4;
                v39[3] = v28;
              }
            }
            else
            {
              v38 = (_BYTE *)(a1 + v35);
              *v38 = BYTE2(v28) | 0xC0;
              v38[1] = BYTE1(v28);
              v36 = v35 + 3;
              v38[2] = v28;
            }
          }
          else
          {
            v37 = (_BYTE *)(a1 + v35);
            *v37 = BYTE1(v28) | 0x80;
            v36 = v35 + 2;
            v37[1] = v28;
          }
        }
        else
        {
          v36 = v35 + 1;
          *(_BYTE *)(a1 + v35) = v28;
        }
        *a10 = v36;
        if (v22)
        {
          v41 = *(_QWORD *)(a11 + 16);
          v42 = atomic_load((unsigned int *)(a11 + 24));
          v43 = (unsigned int *)(v41 + 8 * v22 + 4);
          do
          {
            while (1)
            {
              v44 = v42;
              *v43 = v42;
              v42 = __ldaxr(v24);
              if (v42 == v44)
                break;
              __clrex();
            }
          }
          while (__stlxr(v22, v24));
        }
        ++v25;
        v22 = v29;
      }
      while (v25 != a3);
      goto LABEL_81;
    }
LABEL_80:
    LODWORD(v29) = v22;
    goto LABEL_81;
  }
  if (a3 < 2)
    goto LABEL_80;
  v46 = *(_QWORD *)(a11 + 16);
  v47 = v23[813];
  v48 = a3 - 1;
  a9.n128_u64[0] = 67109120;
  do
  {
    v49 = v11;
    v11 = *_X22;
    v29 = _X22[1];
    if ((_DWORD)v29)
      _X22 = (unsigned int *)(v46 + 8 * v29);
    else
      _X22 = 0;
    __asm { PRFM            #0, [X22] }
    v51 = v49 - v11;
    if (v47 >= 5)
    {
      v74 = a9;
      v76 = a6;
      v70 = *__error();
      v67 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = v74.n128_u32[0];
        v79 = v11;
        _os_log_impl(&dword_1B8270000, v67, OS_LOG_TYPE_DEFAULT, "Next: %d", buf, 8u);
      }
      *__error() = v70;
      v47 = dword_1EF19FCB4;
      if (dword_1EF19FCB4 >= 5)
      {
        v71 = *__error();
        v68 = _SILogForLogForCategory(10);
        if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = v74.n128_u32[0];
          v79 = v51;
          _os_log_impl(&dword_1B8270000, v68, OS_LOG_TYPE_DEFAULT, "Delta: %d", buf, 8u);
        }
        *__error() = v71;
        v47 = dword_1EF19FCB4;
      }
      a6 = v76;
      a9 = v74;
    }
    v52 = *a10;
    if (v51 > 0x7F)
    {
      if (v51 >> 14)
      {
        if (v51 >> 21)
        {
          if (v51 >> 28)
          {
            v57 = a1 + v52;
            *(_BYTE *)v57 = -16;
            *(_DWORD *)(v57 + 1) = v51;
            v53 = v52 + 5;
          }
          else
          {
            v56 = (_BYTE *)(a1 + v52);
            *v56 = HIBYTE(v51) | 0xE0;
            v56[1] = BYTE2(v51);
            v56[2] = BYTE1(v51);
            v53 = v52 + 4;
            v56[3] = v51;
          }
        }
        else
        {
          v55 = (_BYTE *)(a1 + v52);
          *v55 = BYTE2(v51) | 0xC0;
          v55[1] = BYTE1(v51);
          v53 = v52 + 3;
          v55[2] = v51;
        }
      }
      else
      {
        v54 = (_BYTE *)(a1 + v52);
        *v54 = BYTE1(v51) | 0x80;
        v53 = v52 + 2;
        v54[1] = v51;
      }
    }
    else
    {
      v53 = v52 + 1;
      *(_BYTE *)(a1 + v52) = v51;
    }
    *a10 = v53;
    --v48;
  }
  while (v48);
LABEL_81:
  *a6 = v29;
  return _X22;
}

uint64_t positionInfoAlloc_ts(uint64_t a1, unint64_t a2)
{
  unint64_t v3;
  unsigned int *v4;
  uint64_t v5;
  unint64_t v6;
  unsigned int v7;
  uint64_t v8;
  unsigned int v9;
  char *v10;
  char *v11;
  const char *v12;
  uint64_t v13;

  v3 = a2 >> 3;
  if ((a2 & 7) != 0)
    LODWORD(v3) = v3 + 1;
  v4 = (unsigned int *)(a1 + 28);
  do
    v5 = __ldaxr(v4);
  while (__stlxr(v5 + v3, v4));
  v6 = a2 + v5;
  if (v6 > *(_QWORD *)(a1 + 48) + 0x8000)
  {
    *(_QWORD *)(a1 + 48) = (v6 & 0xFFFFFFFFFFFC0000) + 0x40000;
    madvise((void *)((*(_QWORD *)(a1 + 16) + 8 * v5 + 8 * a2) & 0xFFFFFFFFFFFC0000), 0x40000uLL, 3);
  }
  while (1)
  {
    v7 = atomic_load((unsigned int *)(a1 + 28));
    v8 = *(unsigned int *)(a1 + 32);
    if (v7 < v8)
      break;
    v9 = 2 * v8;
    if (!(_DWORD)v8)
      v9 = 0x20000;
    *(_DWORD *)(a1 + 32) = v9;
    if (my_vm_reallocate((void **)(a1 + 16), 8 * v8, 8 * v9, 247, *(_QWORD *)(a1 + 56)))
    {
      v10 = __si_assert_copy_extra(0);
      v11 = v10;
      v12 = "";
      if (v10)
        v12 = v10;
      __message_assert("%s:%u: failed assertion '%s' %s ", "CIPositions.h", 163, "0 == kr", v12);
      free(v11);
      if (__valid_fs(-1))
        v13 = 2989;
      else
        v13 = 3072;
      *(_DWORD *)v13 = -559038737;
      abort();
    }
  }
  return v5;
}

void CIPositionNodeTransferDocuments(uint64_t a1)
{
  uint64_t v1;
  int v2;
  int v3;
  unsigned int v4;
  unsigned int v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  __int128 *v14;
  size_t v15;
  char *v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  _DWORD *v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  _BYTE *v26;
  __int128 *v27;
  unint64_t v28;
  char *v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  size_t v34;
  char *v35;
  int8x16_t v36;
  int64x2_t v37;
  unint64_t v38;
  size_t v39;
  uint64x2_t v40;
  uint64_t v41;
  __int128 *v42;
  unint64_t v43;
  _DWORD *v44;
  int64x2_t v45;
  int64x2_t v46;
  char *v47;
  int64x2_t v48;
  unint64_t v49;
  _DWORD *v50;
  int32x4_t v51;
  int32x2_t v52;
  _DWORD *v53;
  _DWORD *v54;
  int64x2_t v55;
  _DWORD *v56;
  _DWORD *v57;
  int64x2_t v58;
  int64x2_t v59;
  __int128 *v60;
  int32x4_t v61;
  unint64_t v62;
  int32x4_t v63;
  int32x2_t v64;
  int64x2_t v65;
  int32x4_t v66;
  int64x2_t v67;
  int64x2_t v68;
  __int128 *v69;
  int32x4_t v70;
  __int8 v71;
  __int8 v72;
  int32x2_t v73;
  __int8 v74;
  __int8 v75;
  int32x4_t v76;
  int16x4_t v77;
  int8x16_t v78;
  int8x16_t v79;
  int8x16_t v80;
  int8x16_t v81;
  int *v82;
  unsigned int v83;
  unsigned int v84;
  unsigned int v85;
  unsigned int v86;
  unsigned int v87;
  char v88;
  uint64_t *v89;
  unsigned int v90;
  unsigned int v91;
  int v92;
  unsigned int *v93;
  unint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  _BYTE *v98;
  _BYTE *v99;
  uint64_t v100;
  unsigned int v101;
  uint64_t v102;
  _BYTE *v103;
  _BYTE *v104;
  uint64_t v105;
  unint64_t v106;
  _DWORD *v107;
  __int128 *v108;
  _DWORD *v109;
  __int128 *v110;
  unint64_t v111;
  unint64_t i;
  _DWORD *v113;
  __int128 *v114;
  uint64_t *v115;
  __int128 *v116;
  __int128 v117;
  __int128 v118;
  __int128 v119;
  __int128 v120;
  __int128 v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  __int128 *v125;
  _DWORD *v126;
  unint64_t j;
  unsigned int v128;
  unsigned int v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  _BYTE *v135;
  _BYTE *v136;
  uint64_t v137;
  NSObject *v138;
  uint64_t v139;
  BOOL v140;
  unsigned int v141;
  __int128 *v142;
  uint64_t v143;
  __int128 *v144;
  __int128 v145;
  __int128 v146;
  __int128 v147;
  __int128 v148;
  __int128 v149;
  uint64_t v150;
  unint64_t v151;
  char *v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  __int128 *v157;
  unsigned int v158;
  const void **v159;
  size_t v160;
  uint64_t v161;
  unint64_t v162;
  int v163;
  unsigned int v164;
  _DWORD *v165;
  uint64_t v166;
  size_t v167;
  char *v168;
  char *v169;
  const char *v170;
  int v171;
  uint64_t v172;
  _DWORD *v173;
  int v174;
  NSObject *v175;
  char *v176;
  const char *v177;
  const char *v178;
  const char *v179;
  os_log_t v180;
  os_log_t v181;
  int v182;
  __int128 *v183;
  _DWORD *v184;
  __int128 *v185;
  _DWORD *v186;
  _DWORD *v187;
  uint64x2_t v188;
  os_log_t *v189;
  void *v190;
  os_log_t *v191;
  uint64_t v192;
  __int128 *v193;
  unsigned int v194;
  uint64_t v195;
  uint64_t v196;
  unint64_t v197;
  uint64_t v198;
  int v199;
  _DWORD v200[1024];
  _BYTE v201[65536];
  _OWORD buf[2];
  __int128 v203;
  uint64_t v204;

  v1 = MEMORY[0x1E0C80A78](a1);
  v3 = v2;
  v5 = v4;
  v7 = v6;
  v9 = v8;
  v192 = v10;
  v195 = v11;
  v196 = v1;
  v204 = *MEMORY[0x1E0C80C00];
  bzero(v201, 0x10000uLL);
  bzero(v200, 0x1000uLL);
  v191 = &v180;
  MEMORY[0x1E0C80A78](v12);
  v14 = (__int128 *)((char *)&v180 - ((v13 + 207) & 0xFFFFFFFFFFFFFFF0));
  bzero(v14, v15);
  v17 = v7;
  v197 = v7;
  v193 = v14;
  if (!v7)
    goto LABEL_20;
  v18 = 0;
  v16 = 0;
  v19 = 0;
  v20 = v3 ? 6 : 1;
  v21 = (_DWORD *)v14 + 10;
  do
  {
    v22 = *(_QWORD *)(v9 + 8 * v19);
    v23 = *(_DWORD *)(v22 + 8);
    *(v21 - 1) = v23;
    *v21 = v19;
    v200[v19] = 8;
    v24 = (v20 + 5 * v23);
    if (0x10000 - v18 >= v24)
      v25 = 0;
    else
      v25 = (v20 + 5 * v23);
    v16 += v25;
    v26 = &v201[v18];
    if (0x10000 - v18 < v24)
      v26 = 0;
    *((_QWORD *)v21 - 3) = 0;
    *((_QWORD *)v21 - 2) = 0;
    if (0x10000 - v18 < v24)
      v24 = 0;
    v18 += v24;
    *(v21 - 2) = 0;
    *((_QWORD *)v21 - 5) = v26;
    *((_QWORD *)v21 - 4) = v22;
    ++v19;
    v21 += 12;
  }
  while (v17 != v19);
  if (v16)
  {
    v16 = (char *)malloc_type_malloc((size_t)v16, 0xE14F2A97uLL);
    v14 = v193;
    v17 = v197;
    v27 = v193;
    v28 = v197;
    v190 = v16;
    v29 = v16;
    do
    {
      if (!*(_QWORD *)v27)
      {
        v30 = (v20 + 5 * *((_DWORD *)v27 + 9));
        *(_QWORD *)v27 = v29;
        v29 += v30;
      }
      v27 += 3;
      --v28;
    }
    while (v28);
  }
  else
  {
LABEL_20:
    v190 = 0;
  }
  if (gCPUCount >= v17)
  {
    MEMORY[0x1E0C80A78](v16);
    v35 = (char *)&v180 - ((v39 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v35, v39);
    v38 = v197;
    if (!v197)
    {
      v41 = v192;
      v42 = v193;
      v50 = v35;
      goto LABEL_76;
    }
    v31 = v197 - 1;
  }
  else
  {
    v31 = v17 - 1;
    v32 = _partition_positionlistitem(v14, v17 - 1);
    if (v32 >= 9)
      v32 = _partition_positionlistitem(v193, v32 - 1);
    v33 = v197;
    MEMORY[0x1E0C80A78](v32);
    v35 = (char *)&v180 - ((v34 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v35, v34);
    v38 = v33;
  }
  v41 = v192;
  v42 = v193;
  v40 = (uint64x2_t)vdupq_n_s64(v31);
  v43 = (v38 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  v44 = v35 + 24;
  v45 = (int64x2_t)xmmword_1B8631D90;
  v46 = (int64x2_t)xmmword_1B8631BB0;
  v47 = (char *)v193 + 104;
  v48 = vdupq_n_s64(4uLL);
  v49 = v43;
  v50 = v35;
  do
  {
    v51 = (int32x4_t)vcgeq_u64(v40, (uint64x2_t)v46);
    *(int32x2_t *)v51.i8 = vmovn_s64((int64x2_t)v51);
    v52 = (int32x2_t)vmovn_s32(v51);
    if ((v52.i8[0] & 1) != 0)
    {
      v53 = (_DWORD *)*((_QWORD *)v47 - 12);
      *((_QWORD *)v47 - 11) = v53;
      *(v44 - 6) = *v53;
      *(v44 - 4) = 1;
    }
    if ((vmovn_s32(v51).i8[2] & 1) != 0)
    {
      v54 = (_DWORD *)*((_QWORD *)v47 - 6);
      *((_QWORD *)v47 - 5) = v54;
      *(v44 - 3) = *v54;
      *(v44 - 1) = 1;
    }
    v55 = (int64x2_t)vcgeq_u64(v40, (uint64x2_t)v45);
    if ((vmovn_s32(vmovn_hight_s64(v52, v55)).i32[1] & 1) != 0)
    {
      v56 = *(_DWORD **)v47;
      *((_QWORD *)v47 + 1) = *(_QWORD *)v47;
      *v44 = *v56;
      v44[2] = 1;
    }
    if ((vmovn_s32(vmovn_hight_s64(*(int32x2_t *)&v55, v55)).i8[6] & 1) != 0)
    {
      v57 = (_DWORD *)*((_QWORD *)v47 + 6);
      *((_QWORD *)v47 + 7) = v57;
      v44[3] = *v57;
      v44[5] = 1;
    }
    v45 = vaddq_s64(v45, v48);
    v46 = vaddq_s64(v46, v48);
    v44 += 12;
    v47 += 192;
    v49 -= 4;
  }
  while (v49);
  if (v38)
  {
    v58 = (int64x2_t)xmmword_1B8631D90;
    v59 = (int64x2_t)xmmword_1B8631BB0;
    v60 = v42 + 7;
    v61 = (int32x4_t)vdupq_n_s64(4uLL);
    v62 = (v38 + 3) & 0xFFFFFFFFFFFFFFFCLL;
    do
    {
      v63 = (int32x4_t)vcgeq_u64(v40, (uint64x2_t)v59);
      *(int32x2_t *)v63.i8 = vmovn_s64((int64x2_t)v63);
      v64 = (int32x2_t)vmovn_s32(v63);
      if ((v64.i8[0] & 1) != 0)
        *((_DWORD *)v60 - 20) = *(_DWORD *)(*((_QWORD *)v60 - 12) + 4);
      if ((vmovn_s32(v63).i8[2] & 1) != 0)
        *((_DWORD *)v60 - 8) = *(_DWORD *)(*((_QWORD *)v60 - 6) + 4);
      v65 = (int64x2_t)vcgeq_u64(v40, (uint64x2_t)v58);
      v66 = vmovn_hight_s64(v64, v65);
      if ((vmovn_s32(v66).i32[1] & 1) != 0)
        *((_DWORD *)v60 + 4) = *(_DWORD *)(*(_QWORD *)v60 + 4);
      if ((vmovn_s32(vmovn_hight_s64(*(int32x2_t *)&v65, v65)).i8[6] & 1) != 0)
        *((_DWORD *)v60 + 16) = *(_DWORD *)(*((_QWORD *)v60 + 6) + 4);
      v58 = vaddq_s64(v58, (int64x2_t)v61);
      v59 = vaddq_s64(v59, (int64x2_t)v61);
      v60 += 12;
      v62 -= 4;
    }
    while (v62);
    v67 = (int64x2_t)xmmword_1B8631D90;
    v68 = (int64x2_t)xmmword_1B8631BB0;
    v69 = v42 + 7;
    do
    {
      v70 = (int32x4_t)vcgeq_u64(v40, (uint64x2_t)v68);
      *(int32x2_t *)v66.i8 = vmovn_s64((int64x2_t)v70);
      *(int16x4_t *)v61.i8 = vmovn_s32(v66);
      v71 = v61.i8[0];
      if ((v61.i8[0] & 1) != 0)
        v61.i32[0] = *((_DWORD *)v69 - 20);
      v72 = vmovn_s32(v66).i8[2];
      if ((v72 & 1) != 0)
        v61.i32[1] = *((_DWORD *)v69 - 8);
      v66 = (int32x4_t)vcgeq_u64(v40, (uint64x2_t)v67);
      v73 = (int32x2_t)vmovn_s32(vmovn_hight_s64(*(int32x2_t *)v36.i8, (int64x2_t)v66));
      v74 = v73.i8[4];
      if ((v73.i8[4] & 1) != 0)
        v61.i32[2] = *((_DWORD *)v69 + 4);
      v75 = vmovn_s32(vmovn_hight_s64(v73, *(int64x2_t *)&v66)).i8[6];
      if ((v75 & 1) != 0)
        v61.i32[3] = *((_DWORD *)v69 + 16);
      v36 = (int8x16_t)vceqzq_s32(v61);
      v76 = (int32x4_t)vbicq_s8((int8x16_t)vuzp1q_s32(v70, v66), v36);
      v77 = vmovn_s32(v76);
      if ((v77.i8[0] & 1) != 0)
        v76.i64[0] = *(_QWORD *)(v41 + 16);
      if ((v77.i8[2] & 1) != 0)
        v76.i64[1] = *(_QWORD *)(v41 + 16);
      if ((v77.i8[4] & 1) != 0)
        v37.i64[0] = *(_QWORD *)(v41 + 16);
      if ((v77.i8[6] & 1) != 0)
        v37.i64[1] = *(_QWORD *)(v41 + 16);
      v78.i64[0] = v36.i32[0];
      v78.i64[1] = v36.i32[1];
      v79 = vbicq_s8((int8x16_t)vaddq_s64((int64x2_t)v76, (int64x2_t)vshll_n_u32(*(uint32x2_t *)v61.i8, 3uLL)), vandq_s8((int8x16_t)v70, v78));
      if ((v71 & 1) != 0)
        *((_QWORD *)v69 - 12) = v79.i64[0];
      if ((v72 & 1) != 0)
        *((_QWORD *)v69 - 6) = v79.i64[1];
      v80.i64[0] = v36.i32[2];
      v80.i64[1] = v36.i32[3];
      v81 = vbicq_s8((int8x16_t)vaddq_s64(v37, (int64x2_t)vshll_high_n_u32((uint32x4_t)v61, 3uLL)), vandq_s8((int8x16_t)v66, v80));
      if ((v74 & 1) != 0)
        *(_QWORD *)v69 = v81.i64[0];
      if ((v75 & 1) != 0)
        *((_QWORD *)v69 + 6) = v81.i64[1];
      v61 = (int32x4_t)vdupq_n_s64(4uLL);
      v67 = vaddq_s64(v67, (int64x2_t)v61);
      v68 = vaddq_s64(v68, (int64x2_t)v61);
      v69 += 12;
      v43 -= 4;
    }
    while (v43);
  }
LABEL_76:
  v82 = (int *)&unk_1EF19F000;
  if (dword_1EF19FCB4 >= 5)
  {
    v173 = v50;
    v174 = *__error();
    v175 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v175, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf[0]) = 67109120;
      DWORD1(buf[0]) = v5;
      _os_log_impl(&dword_1B8270000, v175, OS_LOG_TYPE_DEFAULT, "DocID: %d", (uint8_t *)buf, 8u);
    }
    *__error() = v174;
    v38 = v197;
    v41 = v192;
    v42 = v193;
    v50 = v173;
    v82 = (int *)&unk_1EF19F000;
    if (v197)
      goto LABEL_78;
  }
  else if (v38)
  {
LABEL_78:
    v189 = &v180;
    v83 = HIBYTE(v5) | 0xFFFFFFE0;
    v84 = HIWORD(v5);
    v85 = v5 >> 8;
    v86 = HIWORD(v5) | 0xFFFFFFC0;
    v87 = v5;
    v88 = BYTE1(v5) | 0x80;
    v89 = (uint64_t *)v42 + 3;
    v90 = v5 >> 14;
    v91 = v5 >> 21;
    v194 = v87;
    v92 = v87 >> 28;
    v40.i64[0] = 67109120;
    v188 = v40;
    v93 = v50;
    v94 = v38;
    do
    {
      if ((v3 & 1) != 0)
      {
        v95 = *(v89 - 3);
        v96 = *v89;
        v97 = *v89 + 1;
        if (v194 > 0x7F)
        {
          if (v90)
          {
            if (v91)
            {
              if (v92)
              {
                *(_BYTE *)(v95 + v96) = -16;
                *(_DWORD *)(v95 + v97) = v194;
                v97 = v96 + 5;
              }
              else
              {
                v99 = (_BYTE *)(v95 + v96);
                *v99 = v83;
                *(_BYTE *)(v95 + v97) = v84;
                v99[2] = v85;
                v97 = v96 + 4;
                v99[3] = v194;
              }
            }
            else
            {
              v98 = (_BYTE *)(v95 + v96);
              *v98 = v86;
              *(_BYTE *)(v95 + v97) = v85;
              v97 = v96 + 3;
              v98[2] = v194;
            }
          }
          else
          {
            *(_BYTE *)(v95 + v96) = v88;
            *(_BYTE *)(v95 + v97) = v194;
            v97 = v96 + 2;
          }
        }
        else
        {
          *(_BYTE *)(v95 + v96) = v194;
        }
        *v89 = v97;
      }
      else
      {
        v97 = *v89;
      }
      v100 = *(v89 - 3);
      v101 = *v93;
      if (*v93 > 0x7F)
      {
        if (v101 >> 14)
        {
          if (v101 >> 21)
          {
            v105 = v100 + v97;
            if (v101 >> 28)
            {
              *(_BYTE *)v105 = -16;
              *(_DWORD *)(v105 + 1) = v101;
              v102 = v97 + 5;
            }
            else
            {
              *(_BYTE *)v105 = HIBYTE(v101) | 0xE0;
              *(_BYTE *)(v105 + 1) = BYTE2(v101);
              *(_BYTE *)(v105 + 2) = BYTE1(v101);
              v102 = v97 + 4;
              *(_BYTE *)(v105 + 3) = v101;
            }
          }
          else
          {
            v104 = (_BYTE *)(v100 + v97);
            *v104 = BYTE2(v101) | 0xC0;
            v104[1] = BYTE1(v101);
            v102 = v97 + 3;
            v104[2] = v101;
          }
        }
        else
        {
          v103 = (_BYTE *)(v100 + v97);
          *v103 = BYTE1(v101) | 0x80;
          v102 = v97 + 2;
          v103[1] = v101;
        }
      }
      else
      {
        v102 = v97 + 1;
        *(_BYTE *)(v100 + v97) = v101;
      }
      *v89 = v102;
      if (v82[813] >= 5)
      {
        v182 = v92;
        LODWORD(v183) = v86;
        LODWORD(v184) = v85;
        LODWORD(v185) = v84;
        LODWORD(v186) = v83;
        v187 = v50;
        LODWORD(v181) = *__error();
        v180 = (os_log_t)_SILogForLogForCategory(10);
        if (os_log_type_enabled(v180, OS_LOG_TYPE_DEFAULT))
        {
          *(_QWORD *)&buf[0] = __PAIR64__(v101, v188.u32[0]);
          _os_log_impl(&dword_1B8270000, v180, OS_LOG_TYPE_DEFAULT, "Start pos: %d", (uint8_t *)buf, 8u);
        }
        *__error() = (int)v181;
        v38 = v197;
        v41 = v192;
        v42 = v193;
        v50 = v187;
        v82 = (_DWORD *)&unk_1EF19F000;
        v83 = v186;
        v84 = v185;
        v85 = v184;
        v92 = v182;
        v86 = v183;
      }
      v93 += 3;
      v89 += 6;
      --v94;
    }
    while (v94);
    if (v38 >= 0x18)
      v106 = 24;
    else
      v106 = v38;
    v107 = v50 - 3;
    v108 = v42 - 3;
    v109 = v50 + 2;
    v110 = v42 + 1;
    v111 = v38;
    while (1)
    {
      if (v106)
      {
        for (i = 0; i < v106; ++i)
        {
          v113 = &v50[3 * i];
          v114 = &v42[3 * i];
          if (v113[2] < *((_DWORD *)v114 + 9))
          {
LABEL_116:
            v50[3 * i + 1] = **(_DWORD **)&v42[3 * i + 1];
          }
          else
          {
            v115 = (uint64_t *)&v107[3 * v111];
            v116 = &v108[3 * v111];
            while (i < v111)
            {
              --v111;
              v118 = v116[1];
              buf[0] = *v116;
              v117 = buf[0];
              buf[1] = v118;
              v203 = v116[2];
              v119 = v203;
              v121 = v114[1];
              v120 = v114[2];
              *v116 = *v114;
              v116[1] = v121;
              v116[2] = v120;
              v114[1] = v118;
              v114[2] = v119;
              *v114 = v117;
              v122 = *(_QWORD *)v113;
              v199 = v113[2];
              v198 = v122;
              v123 = *v115;
              v113[2] = *((_DWORD *)v115 + 2);
              *(_QWORD *)v113 = v123;
              v124 = v198;
              *((_DWORD *)v115 + 2) = v199;
              *v115 = v124;
              v115 = (uint64_t *)((char *)v115 - 12);
              v116 -= 3;
              if (v113[2] < *((_DWORD *)v114 + 9))
                goto LABEL_116;
            }
            if (v111 >= 0x18)
              v106 = 24;
            else
              v106 = v111;
          }
        }
      }
      if (v111 >= 0x18)
        v106 = 24;
      else
        v106 = v111;
      v125 = v110;
      v126 = v109;
      for (j = v106; j; --j)
      {
        v128 = *(v126 - 1);
        v129 = *(v126 - 2) - v128;
        *(v126 - 2) = v128;
        if (v82[813] >= 5)
        {
          v183 = v110;
          v184 = v109;
          v185 = v108;
          v186 = v107;
          v187 = v50;
          v182 = *__error();
          v181 = (os_log_t)_SILogForLogForCategory(10);
          if (os_log_type_enabled(v181, OS_LOG_TYPE_DEFAULT))
          {
            *(_QWORD *)&buf[0] = __PAIR64__(v128, v188.u32[0]);
            _os_log_impl(&dword_1B8270000, v181, OS_LOG_TYPE_DEFAULT, "Next: %d", (uint8_t *)buf, 8u);
          }
          *__error() = v182;
          v82 = (int *)&unk_1EF19F000;
          v38 = v197;
          v41 = v192;
          v42 = v193;
          v107 = v186;
          v50 = v187;
          v109 = v184;
          v108 = v185;
          v110 = v183;
          if (dword_1EF19FCB4 >= 5)
          {
            v182 = *__error();
            v138 = _SILogForLogForCategory(10);
            if (os_log_type_enabled(v138, OS_LOG_TYPE_DEFAULT))
            {
              *(_QWORD *)&buf[0] = __PAIR64__(v129, v188.u32[0]);
              _os_log_impl(&dword_1B8270000, v138, OS_LOG_TYPE_DEFAULT, "Delta: %d", (uint8_t *)buf, 8u);
            }
            *__error() = v182;
            v38 = v197;
            v41 = v192;
            v42 = v193;
            v107 = v186;
            v50 = v187;
            v82 = (_DWORD *)&unk_1EF19F000;
            v109 = v184;
            v108 = v185;
            v110 = v183;
          }
        }
        v130 = *(unsigned int *)(*(_QWORD *)v125 + 4);
        *((_DWORD *)v125 + 4) = v130;
        if ((_DWORD)v130)
          v131 = *(_QWORD *)(v41 + 16) + 8 * v130;
        else
          v131 = 0;
        *(_QWORD *)v125 = v131;
        v132 = *((_QWORD *)v125 - 2);
        v133 = *((_QWORD *)v125 + 1);
        if (v129 > 0x7F)
        {
          if (v129 >> 14)
          {
            if (v129 >> 21)
            {
              v137 = v132 + v133;
              if (v129 >> 28)
              {
                *(_BYTE *)v137 = -16;
                *(_DWORD *)(v137 + 1) = v129;
                v134 = v133 + 5;
              }
              else
              {
                *(_BYTE *)v137 = HIBYTE(v129) | 0xE0;
                *(_BYTE *)(v137 + 1) = BYTE2(v129);
                *(_BYTE *)(v137 + 2) = BYTE1(v129);
                v134 = v133 + 4;
                *(_BYTE *)(v137 + 3) = v129;
              }
            }
            else
            {
              v136 = (_BYTE *)(v132 + v133);
              *v136 = BYTE2(v129) | 0xC0;
              v136[1] = BYTE1(v129);
              v134 = v133 + 3;
              v136[2] = v129;
            }
          }
          else
          {
            v135 = (_BYTE *)(v132 + v133);
            *v135 = BYTE1(v129) | 0x80;
            v134 = v133 + 2;
            v135[1] = v129;
          }
        }
        else
        {
          v134 = v133 + 1;
          *(_BYTE *)(v132 + v133) = v129;
        }
        ++*v126;
        v126 += 3;
        *((_QWORD *)v125 + 1) = v134;
        v125 += 3;
      }
      if (!v111)
      {
        v139 = 0;
        v140 = 1;
        v141 = v194;
        while (1)
        {
          v142 = &v42[3 * v139];
          while (1)
          {
            v143 = *((unsigned int *)v142 + 10);
            if (v139 == v143)
              break;
            v144 = &v42[3 * v143];
            v145 = *v144;
            v146 = v144[1];
            v147 = v144[2];
            v149 = v142[1];
            v148 = v142[2];
            *v144 = *v142;
            v144[1] = v149;
            v144[2] = v148;
            v142[1] = v146;
            v142[2] = v147;
            *v142 = v145;
            if (!v140)
              goto LABEL_153;
          }
          v140 = ++v139 < v38;
          if (v139 == v38)
          {
LABEL_153:
            v150 = 0;
            v151 = 0;
            v152 = (char *)v42 + 24;
            while (v150 == *((_DWORD *)v152 + 4))
            {
              v153 = *((_QWORD *)v152 - 3);
              v154 = (*(_QWORD *)v152)++;
              *(_BYTE *)(v153 + v154) = 0;
              v155 = *(_QWORD *)v152;
              v152 += 48;
              v156 = v155 + v200[v150];
              v151 += (v156 + 8 * ((v156 & 7) != 0)) & 0xFFFFFFFFFFFFFFF8;
              if (v38 == ++v150)
              {
                v157 = v42;
                v158 = positionInfoAlloc_ts(v196, v151);
                v159 = (const void **)v157 + 3;
                while (v158)
                {
                  v160 = (size_t)*v159;
                  v161 = *((unsigned int *)v159 + 4);
                  v162 = (unint64_t)*v159 + v200[v161];
                  if ((v162 & 7) != 0)
                    v163 = (v162 >> 3) + 1;
                  else
                    v163 = v162 >> 3;
                  v164 = v158 + v163;
                  v165 = (_DWORD *)(*(_QWORD *)(v196 + 16) + 8 * v158);
                  *v165++ = v160;
                  memcpy(v165, *(v159 - 3), v160);
                  v166 = *(_QWORD *)(v195 + 8 * v161);
                  v167 = (size_t)*v159;
                  v159 += 6;
                  *(_DWORD *)((char *)v165 + v167) = *(_DWORD *)(v166 + 4);
                  *(_DWORD *)(v166 + 24) = v141;
                  *(_QWORD *)(v166 + 16) = 0;
                  *(_DWORD *)v166 = 0;
                  *(_DWORD *)(v166 + 4) = v158;
                  *(_DWORD *)(v166 + 8) = 0;
                  v158 = v164;
                  if (!--v197)
                    goto LABEL_174;
                }
                v176 = __si_assert_copy_extra(0);
                v169 = v176;
                v177 = "";
                if (v176)
                  v177 = v176;
                v178 = "posPtrStart!=0";
                v179 = v177;
                v171 = 381;
LABEL_166:
                __message_assert("%s:%u: failed assertion '%s' %s ", "CIPayloadData.c", v171, v178, v179);
                free(v169);
                if (__valid_fs(-1))
                  v172 = 2989;
                else
                  v172 = 3072;
                *(_DWORD *)v172 = -559038737;
                abort();
              }
            }
            v168 = __si_assert_copy_extra(0);
            v169 = v168;
            v170 = "";
            if (v168)
              v170 = v168;
            v178 = "oi == i";
            v179 = v170;
            v171 = 356;
            goto LABEL_166;
          }
        }
      }
    }
  }
  positionInfoAlloc_ts(v196, 0);
LABEL_174:
  free(v190);
}

uint64_t _partition_positionlistitem(__int128 *a1, uint64_t a2)
{
  unint64_t v2;
  uint64_t v3;
  __int128 *v4;
  __int128 *v5;
  unint64_t v6;
  __int128 *v7;
  int v8;
  int v9;
  __int128 *v10;
  int v11;
  BOOL v12;
  int v13;
  int v14;
  int v15;
  __int128 *v16;
  __int128 *v17;
  int v18;
  int v19;
  int v20;
  int v22;
  int v23;
  int v24;
  int v25;
  uint64_t v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  int v32;
  _QWORD *v33;
  int v34;
  uint64_t v35;
  __int128 *v36;
  __int128 v37;
  __int128 v38;
  __int128 *v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  uint64_t v46;
  uint64_t v47;
  __int128 *v48;
  int v49;
  int v50;
  __int128 *v51;
  int v52;
  BOOL v53;
  int v54;
  int v55;
  int v56;
  __int128 *v57;
  int v58;
  int v59;
  int v60;
  int v62;
  int v63;
  int v64;
  __int128 v65;
  __int128 v66;
  int v67;
  __int128 v68;
  __int128 v69;
  int v70;
  __int128 v71;
  __int128 v72;
  int v73;

  v2 = a2 + 1;
  v3 = a2 + 2;
  if (a2 >= -1)
    v3 = a2 + 1;
  v4 = &a1[3 * (v3 >> 1)];
  v5 = &a1[3 * a2];
  if (a2 < 1024)
  {
    v10 = a1;
    v16 = v4;
    goto LABEL_15;
  }
  v6 = v2 >> 3;
  v7 = &a1[3 * (v2 >> 3)];
  v8 = *((_DWORD *)a1 + 9);
  v9 = *((_DWORD *)v7 + 9);
  v10 = a1;
  if (v9 != v8)
  {
    v11 = DWORD1(a1[6 * v6 + 2]);
    v12 = v8 == v11 || v9 == v11;
    v10 = &a1[6 * v6];
    if (!v12)
    {
      v13 = -v8;
      v14 = -v9;
      v15 = -v11;
      v10 = v7;
      if (v13 >= v14)
      {
        if (v14 <= v15)
        {
          if (v13 >= v15)
            v10 = &a1[6 * v6];
          else
            v10 = a1;
        }
      }
      else if (v14 >= v15)
      {
        if (v13 >= v15)
          v10 = a1;
        else
          v10 = &a1[6 * v6];
      }
    }
  }
  v46 = 2 * v6;
  v47 = -(uint64_t)v6;
  v48 = &v4[-3 * v6];
  v49 = *((_DWORD *)v48 + 9);
  v50 = *((_DWORD *)v4 + 9);
  if (v50 == v49)
  {
    v16 = &v4[-3 * v6];
  }
  else
  {
    v51 = &v4[3 * v6];
    v52 = *((_DWORD *)v51 + 9);
    v53 = v49 == v52 || v50 == v52;
    v16 = &v4[3 * v6];
    if (!v53)
    {
      v54 = -v49;
      v55 = -v50;
      v56 = -v52;
      v16 = v4;
      if (v54 >= v55)
      {
        if (v55 <= v56)
        {
          if (v54 >= v56)
            v16 = v51;
          else
            v16 = v48;
        }
      }
      else if (v55 >= v56)
      {
        if (v54 >= v56)
          v16 = v48;
        else
          v16 = v51;
      }
    }
  }
  v57 = &v5[-3 * v46];
  v17 = &v5[3 * v47];
  v58 = *((_DWORD *)v57 + 9);
  v59 = *((_DWORD *)v17 + 9);
  if (v59 == v58)
  {
    v17 = v57;
    goto LABEL_16;
  }
  v60 = *((_DWORD *)v5 + 9);
  if (v58 == v60 || v59 == v60)
  {
LABEL_15:
    v17 = &a1[3 * a2];
    goto LABEL_16;
  }
  v62 = -v58;
  v63 = -v59;
  v64 = -v60;
  if (v62 >= v63)
  {
    if (v63 <= v64)
    {
      if (v62 >= v64)
        v17 = &a1[3 * a2];
      else
        v17 = v57;
    }
  }
  else if (v63 >= v64)
  {
    if (v62 >= v64)
      v17 = v57;
    else
      v17 = &a1[3 * a2];
  }
LABEL_16:
  v18 = *((_DWORD *)v10 + 9);
  v19 = *((_DWORD *)v16 + 9);
  if (v19 == v18)
  {
    v16 = v10;
  }
  else
  {
    v20 = *((_DWORD *)v17 + 9);
    if (v18 == v20 || v19 == v20)
    {
      v16 = v17;
    }
    else
    {
      v22 = -v18;
      v23 = -v19;
      v24 = -v20;
      if (v22 >= v23)
      {
        if (v23 <= v24)
        {
          if (v22 >= v24)
            v16 = v17;
          else
            v16 = v10;
        }
      }
      else if (v23 >= v24)
      {
        if (v22 >= v24)
          v16 = v10;
        else
          v16 = v17;
      }
    }
  }
  v25 = *((_DWORD *)v16 + 9);
  v73 = *((_DWORD *)v16 + 8);
  v71 = *v16;
  v72 = v16[1];
  v26 = *((_QWORD *)v16 + 5);
  v28 = v5[1];
  v27 = v5[2];
  *v16 = *v5;
  v16[1] = v28;
  v16[2] = v27;
  *v5 = v71;
  v5[1] = v72;
  *((_DWORD *)v5 + 8) = v73;
  *((_DWORD *)v5 + 9) = v25;
  *((_QWORD *)v5 + 5) = v26;
  v68 = *a1;
  v69 = a1[1];
  v70 = *((_DWORD *)a1 + 8);
  if (a2 < 1)
  {
    v29 = 0;
  }
  else
  {
    v29 = 0;
    v30 = *((_QWORD *)a1 + 5);
    v31 = *((_DWORD *)a1 + 9);
    v32 = -v25;
    v33 = (_QWORD *)a1 + 11;
    do
    {
      v65 = v68;
      v66 = v69;
      v67 = v70;
      v68 = *(_OWORD *)(v33 - 5);
      v69 = *(_OWORD *)(v33 - 3);
      v34 = *((_DWORD *)v33 - 1);
      v70 = *((_DWORD *)v33 - 2);
      v35 = *v33;
      if (-v31 <= v32)
      {
        v36 = &a1[3 * v29];
        v37 = *v36;
        v38 = v36[1];
        *(_OWORD *)(v33 - 7) = v36[2];
        *(_OWORD *)(v33 - 9) = v38;
        *(_OWORD *)(v33 - 11) = v37;
        *v36 = v65;
        v36[1] = v66;
        *((_DWORD *)v36 + 8) = v67;
        *((_DWORD *)v36 + 9) = v31;
        *((_QWORD *)v36 + 5) = v30;
        ++v29;
      }
      v33 += 6;
      v31 = v34;
      v30 = v35;
      --a2;
    }
    while (a2);
  }
  v39 = &a1[3 * v29];
  v40 = *v39;
  v41 = v39[1];
  v42 = v39[2];
  v44 = v5[1];
  v43 = v5[2];
  *v39 = *v5;
  v39[1] = v44;
  v39[2] = v43;
  v5[1] = v41;
  v5[2] = v42;
  *v5 = v40;
  return v29;
}

void CIPositionNodeTransferDocument(uint64_t a1)
{
  uint64_t v1;
  int v2;
  int v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int *v6;
  unsigned int *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  size_t v14;
  _BYTE *v15;
  _BYTE *v16;
  __n128 v17;
  uint64_t v18;
  unsigned int v19;
  unsigned int v20;
  size_t v21;
  _DWORD *v22;
  char *v23;
  char *v24;
  const char *v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  _BYTE v29[65536];
  uint64_t v30;

  v1 = MEMORY[0x1E0C80A78](a1);
  v3 = v2;
  v5 = v4;
  v7 = v6;
  v9 = v8;
  v11 = v10;
  v12 = v1;
  v30 = *MEMORY[0x1E0C80C00];
  v13 = v6[2];
  if (v2)
    v14 = 5 * v13 + 6;
  else
    v14 = 5 * v13 + 1;
  if (v14 <= 0x10000)
  {
    v15 = 0;
    v16 = v29;
  }
  else
  {
    v15 = malloc_type_malloc(v14, 0x70BE431FuLL);
    v16 = v15;
  }
  bzero(v29, 0x10000uLL);
  v27 = 0;
  CompactPositionsList((uint64_t)v16, v5, v13, 0, v3, &v28, *v7, v7[1], v17, &v27, v9);
  v18 = v27;
  v16[v27] = 0;
  v19 = positionInfoAlloc_ts(v12, v18 + 9);
  if (!v19)
  {
    v23 = __si_assert_copy_extra(0);
    v24 = v23;
    v25 = "";
    if (v23)
      v25 = v23;
    __message_assert("%s:%u: failed assertion '%s' %s ", "CIPayloadData.c", 447, "posPtrStart!=0", v25);
    free(v24);
    if (__valid_fs(-1))
      v26 = 2989;
    else
      v26 = 3072;
    *(_DWORD *)v26 = -559038737;
    abort();
  }
  v20 = v19;
  v21 = v18 + 1;
  v22 = (_DWORD *)(*(_QWORD *)(v12 + 16) + 8 * v19);
  *v22++ = v21;
  memcpy(v22, v16, v21);
  *(_DWORD *)((char *)v22 + v21) = *(_DWORD *)(v11 + 4);
  if (v15)
    free(v15);
  *(_DWORD *)(v11 + 24) = v5;
  *(_QWORD *)(v11 + 16) = 0;
  *(_DWORD *)v11 = 0;
  *(_DWORD *)(v11 + 4) = v20;
  *(_DWORD *)(v11 + 8) = 0;
}

uint64_t CIBuildPositionRun(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  int *v11;
  size_t v12;
  _BYTE *v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  unint64_t v20;
  _BYTE *v21;
  uint64_t v22;
  _BYTE *v23;
  _BYTE *v24;
  _BYTE *v25;
  char *v26;
  size_t v27;
  uint64_t *v28;
  unsigned int *v29;
  uint64_t v30;
  unsigned int *v31;
  unsigned int v32;
  unsigned int v33;
  unsigned int v34;
  unsigned int v35;
  char *v36;
  char *v37;
  const char *v38;
  const void *v39;
  unsigned int v40;
  unsigned int v41;
  char *v42;
  const char *v43;
  const void *v44;
  unsigned int v45;
  unsigned int v46;
  uint64_t v47;
  char *v48;
  char *v49;
  const char *v50;
  char *v51;
  char *v52;
  const char *v53;
  uint64_t v54;
  char *v55;
  const char *v56;
  uint64_t v57;
  char *v58;
  const char *v59;
  uint64_t v60;
  __int16 v61;
  uint64_t v62;

  v8 = result;
  v62 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a3 + 8))
  {
    result = CIPositionNodeFinalizeDocument(result);
    v9 = result;
  }
  else
  {
    v9 = *(_DWORD *)(a3 + 4);
  }
  v10 = 0;
  while (v9)
  {
    v11 = (int *)(*(_QWORD *)(v8 + 16) + 8 * v9);
    v13 = v11 + 1;
    v12 = *v11;
    if (a5)
    {
      v14 = *v13;
      if ((char)*v13 < 0)
      {
        if (v14 > 0xBF)
        {
          if (v14 > 0xDF)
          {
            if (v14 > 0xEF)
            {
              v14 = *(unsigned int *)((char *)v11 + 5);
              v15 = 5;
            }
            else
            {
              v14 = ((v14 & 0xF) << 24) | (*((unsigned __int8 *)v11 + 5) << 16) | (*((unsigned __int8 *)v11 + 6) << 8) | *((unsigned __int8 *)v11 + 7);
              v15 = 4;
            }
          }
          else
          {
            v14 = ((v14 & 0x1F) << 16) | (*((unsigned __int8 *)v11 + 5) << 8) | *((unsigned __int8 *)v11
                                                                                              + 6);
            v15 = 3;
          }
        }
        else
        {
          v14 = *((unsigned __int8 *)v11 + 5) | ((v14 & 0x3F) << 8);
          v15 = 2;
        }
      }
      else
      {
        v15 = 1;
      }
      if ((int)v10 - 1 < v14)
      {
        v51 = __si_assert_copy_extra(0);
        v52 = v51;
        v53 = "";
        if (v51)
          v53 = v51;
        __message_assert("%s:%u: failed assertion '%s' %s ", "CIPayloadData.c", 587, "docId == 0 || newDocID < docId", v53);
        free(v52);
        if (__valid_fs(-1))
          v54 = 2989;
        else
          v54 = 3072;
        *(_DWORD *)v54 = -559038737;
        abort();
      }
      if (!(_DWORD)v14)
      {
        v55 = __si_assert_copy_extra(0);
        v49 = v55;
        v56 = "";
        if (v55)
          v56 = v55;
        __message_assert("%s:%u: failed assertion '%s' %s ", "CIPayloadData.c", 588, "newDocID", v56);
LABEL_77:
        free(v49);
        if (__valid_fs(-1))
          v57 = 2989;
        else
          v57 = 3072;
        *(_DWORD *)v57 = -559038737;
        abort();
      }
      if (a2
        && *(_QWORD *)a2 > (uint64_t)v14
        && CFBitVectorGetBitAtIndex(*(CFBitVectorRef *)(a2 + 16), v14))
      {
        v61 = 0;
        v60 = 0;
        v16 = v10 - v14;
        if (!(_DWORD)v10)
          v16 = v14;
        if (v16 > 0x7F)
        {
          if (v16 >> 14)
          {
            if (v16 >> 21)
            {
              if (v16 >> 28)
              {
                LOBYTE(v60) = -16;
                *(_DWORD *)((char *)&v60 + 1) = v16;
                v17 = 5;
              }
              else
              {
                LOBYTE(v60) = HIBYTE(v16) | 0xE0;
                BYTE1(v60) = BYTE2(v16);
                BYTE2(v60) = BYTE1(v16);
                BYTE3(v60) = v16;
                v17 = 4;
              }
            }
            else
            {
              LOBYTE(v60) = BYTE2(v16) | 0xC0;
              BYTE1(v60) = BYTE1(v16);
              BYTE2(v60) = v16;
              v17 = 3;
            }
          }
          else
          {
            LOBYTE(v60) = BYTE1(v16) | 0x80;
            BYTE1(v60) = v16;
            v17 = 2;
          }
        }
        else
        {
          LOBYTE(v60) = v16;
          v17 = 1;
        }
        *(_WORD *)((unint64_t)&v60 | v17) = 1;
        v27 = (v17 + 2);
        v28 = &v60;
      }
      else
      {
        if ((_DWORD)v10)
          v18 = v10 - v14;
        else
          v18 = v14;
        v20 = *(_QWORD *)(a4 + 8);
        v19 = *(_QWORD *)(a4 + 16);
        if (v19 + 5 >= v20)
        {
          *(_QWORD *)(a4 + 8) = 2 * v20;
          v21 = malloc_type_realloc(*(void **)(a4 + 24), 2 * v20, 0x2D8F901EuLL);
          *(_QWORD *)(a4 + 24) = v21;
          if (!v21)
          {
            v58 = __si_assert_copy_extra(0);
            v49 = v58;
            v59 = "";
            if (v58)
              v59 = v58;
            __message_assert("%s:%u: failed assertion '%s' %s ", "CIPositionRun.h", 63, "run->buffer", v59);
            goto LABEL_77;
          }
          v19 = *(_QWORD *)(a4 + 16);
        }
        else
        {
          v21 = *(_BYTE **)(a4 + 24);
        }
        if (v18 > 0x7F)
        {
          if (v18 >> 14)
          {
            if (v18 >> 21)
            {
              if (v18 >> 28)
              {
                v26 = &v21[v19];
                *v26 = -16;
                *(_DWORD *)(v26 + 1) = v18;
                v22 = v19 + 5;
              }
              else
              {
                v25 = &v21[v19];
                *v25 = HIBYTE(v18) | 0xE0;
                v25[1] = BYTE2(v18);
                v25[2] = BYTE1(v18);
                v22 = v19 + 4;
                v25[3] = v18;
              }
            }
            else
            {
              v24 = &v21[v19];
              *v24 = BYTE2(v18) | 0xC0;
              v24[1] = BYTE1(v18);
              v22 = v19 + 3;
              v24[2] = v18;
            }
          }
          else
          {
            v23 = &v21[v19];
            *v23 = BYTE1(v18) | 0x80;
            v22 = v19 + 2;
            v23[1] = v18;
          }
        }
        else
        {
          v22 = v19 + 1;
          v21[v19] = v18;
        }
        *(_QWORD *)(a4 + 16) = v22;
        v27 = (v12 - v15);
        v28 = (uint64_t *)&v13[v15];
      }
      result = (uint64_t)ci_position_run_add_bytes(a4, v27, v28);
    }
    else
    {
      result = (uint64_t)ci_position_run_add_bytes(a4, v12, v13);
      v14 = v10;
    }
    v29 = (unsigned int *)&v13[v12];
    v30 = *(_QWORD *)(v8 + 16);
    v31 = (unsigned int *)(v8 + 28);
    v32 = atomic_load((unsigned int *)(v8 + 28));
    if ((unint64_t)v29 >= v30 + 8 * (unint64_t)v32)
    {
      v36 = __si_assert_copy_extra(0);
      v37 = v36;
      v38 = "";
      if (v36)
        v38 = v36;
      v39 = *(const void **)(v8 + 16);
      v40 = *v29;
      v41 = atomic_load(v31);
      __message_assert("%s:%u: failed assertion '%s' %s base:%p ptr:%p value:%d info next:%d size:%d next:%d len:%d docId(%d):%d ", "CIPayloadData.c", 615, "posStart < (uint8_t*)(positions->info_store+positions->_info_next.infoptr)", v38, v39, v29, v40, v41, *(_DWORD *)(v8 + 32), v9, v12, a5, v14);
LABEL_63:
      free(v37);
      if (__valid_fs(-1))
        v47 = 2989;
      else
        v47 = 3072;
      *(_DWORD *)v47 = -559038737;
      abort();
    }
    v33 = *v29;
    v34 = atomic_load(v31);
    if (v33 >= v34)
    {
      v42 = __si_assert_copy_extra(0);
      v37 = v42;
      v43 = "";
      if (v42)
        v43 = v42;
      v44 = *(const void **)(v8 + 16);
      v45 = *v29;
      v46 = atomic_load((unsigned int *)(v8 + 28));
      __message_assert("%s:%u: failed assertion '%s' %s base:%p ptr:%p value:%d info next:%d size:%d next:%d len:%d docId(%d):%d ", "CIPayloadData.c", 617, "*(PositionInfoRef*)posStart < positions->_info_next.infoptr", v43, v44, v29, v45, v46, *(_DWORD *)(v8 + 32), v9, v12, a5, v14);
      goto LABEL_63;
    }
    v9 = *v29;
    v35 = atomic_load((unsigned int *)(v8 + 28));
    v10 = v14;
    if (v9 >= v35)
    {
      v48 = __si_assert_copy_extra(0);
      v49 = v48;
      v50 = "";
      if (v48)
        v50 = v48;
      __message_assert("%s:%u: failed assertion '%s' %s ", "CIPayloadData.c", 621, "next < positions->_info_next.infoptr", v50);
      goto LABEL_77;
    }
  }
  return result;
}

void *ci_position_run_add_bytes(uint64_t a1, size_t __n, _BYTE *__src)
{
  int v4;
  size_t v6;
  uint64_t v7;
  size_t v8;
  void *v9;
  char *v10;
  char *v11;
  const char *v12;
  void *result;
  char *v14;
  char *v15;
  const char *v16;
  uint64_t v17;
  char *v18;
  const char *v19;
  uint64_t v20;

  v4 = __n;
  v6 = __n;
  while (1)
  {
    v8 = *(_QWORD *)(a1 + 8);
    v7 = *(_QWORD *)(a1 + 16);
    if (v7 + v6 < v8)
      break;
    *(_QWORD *)(a1 + 8) = 2 * v8;
    v9 = malloc_type_realloc(*(void **)(a1 + 24), 2 * v8, 0x485463EBuLL);
    *(_QWORD *)(a1 + 24) = v9;
    if (!v9)
    {
      v10 = __si_assert_copy_extra(0);
      v11 = v10;
      v12 = "";
      if (v10)
        v12 = v10;
      __message_assert("%s:%u: failed assertion '%s' %s ", "CIPositionRun.h", 75, "run->buffer", v12);
      goto LABEL_18;
    }
  }
  if (!*__src)
  {
    v14 = __si_assert_copy_extra(0);
    v15 = v14;
    v16 = "";
    if (v14)
      v16 = v14;
    __message_assert("%s:%u: failed assertion '%s' %s ", "CIPositionRun.h", 77, "bytes[0]!=0", v16);
    free(v15);
    if (__valid_fs(-1))
      v17 = 2989;
    else
      v17 = 3072;
    *(_DWORD *)v17 = -559038737;
    abort();
  }
  if (v4 && __src[v4 - 1])
  {
    v18 = __si_assert_copy_extra(0);
    v11 = v18;
    v19 = "";
    if (v18)
      v19 = v18;
    __message_assert("%s:%u: failed assertion '%s' %s ", "CIPositionRun.h", 78, "len == 0 || bytes[len-1]==0", v19);
LABEL_18:
    free(v11);
    if (__valid_fs(-1))
      v20 = 2989;
    else
      v20 = 3072;
    *(_DWORD *)v20 = -559038737;
    abort();
  }
  result = memcpy((void *)(*(_QWORD *)(a1 + 24) + v7), __src, v6);
  *(_QWORD *)(a1 + 16) += v6;
  return result;
}

uint64_t CIReadPostings(unsigned int *a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  uint64_t result;
  int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  unsigned int *v13;
  void **v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char v18;
  BOOL v19;
  unint64_t v20;
  uint64_t v21;
  int vint32;
  int v23;
  int v24;
  unsigned int v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  int v31;
  size_t v32;
  uint64_t v33;
  size_t v34;
  char *p_dst;
  size_t v36;
  uint64_t v37;
  char *v38;
  char *v39;
  size_t v40;
  ssize_t v41;
  unsigned int v42;
  int v43;
  char *v44;
  char *v45;
  const char *v46;
  uint64_t v47;
  char *v48;
  const char *v49;
  size_t v50;
  char *v51;
  size_t v52;
  unsigned int v53;
  int v54;
  int v55[2];
  int v56;
  char __dst;

  result = store_stream_read_vint32((uint64_t)a1);
  *a4 = result;
  if ((_DWORD)result)
  {
    v9 = result;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v13 = (unsigned int *)(a2 + 12);
    v14 = (void **)a2;
    *(_QWORD *)v55 = a2;
    v56 = result;
    while (1)
    {
      v15 = *((_QWORD *)a1 + 5);
      if ((unint64_t)(*((_QWORD *)a1 + 4) - v15) < 0xB)
      {
        v31 = 0;
        v17 = 0;
        __dst = 0;
        v53 = v12;
        while (1)
        {
          v32 = *((_QWORD *)a1 + 4);
          v33 = *((_QWORD *)a1 + 5);
          if (v33 + 1 > v32)
          {
            v34 = 0;
            p_dst = &__dst;
            v37 = *((_QWORD *)a1 + 5);
            v36 = 1;
            while (1)
            {
              v50 = v34;
              v51 = p_dst;
              v38 = (char *)*((_QWORD *)a1 + 6);
              v52 = v32 - v37;
              if (v32 != v37)
              {
                v39 = (char *)*((_QWORD *)a1 + 6);
                v40 = v32;
                memcpy(p_dst, &v38[v37], v52);
                v38 = v39;
                v32 = v40;
                *((_QWORD *)a1 + 5) = v40;
              }
              v41 = prot_pread(*a1, v38, v32, *((_QWORD *)a1 + 3));
              if (v41 == -1)
              {
                v36 = 0;
                a1[4] = *__error();
                goto LABEL_49;
              }
              v32 = v41;
              *((_QWORD *)a1 + 4) = v41;
              *((_QWORD *)a1 + 5) = 0;
              *((_QWORD *)a1 + 3) += v41;
              if (!v41)
                break;
              v33 = 0;
              v37 = 0;
              p_dst = &v51[v52];
              v36 -= v52;
              v34 = v50 + v52;
              if (v36 <= v32)
                goto LABEL_36;
            }
            v36 = v52;
LABEL_49:
            v34 = v50;
          }
          else
          {
            v34 = 0;
            p_dst = &__dst;
            v36 = 1;
LABEL_36:
            memcpy(p_dst, (const void *)(*((_QWORD *)a1 + 6) + v33), v36);
            *((_QWORD *)a1 + 5) = v33 + v36;
          }
          v9 = v56;
          v12 = v53;
          if (v36 + v34 != 1)
            break;
          v17 |= (unint64_t)(__dst & 0x7F) << v31;
          v31 += 7;
          if ((__dst & 0x80) == 0)
            goto LABEL_57;
        }
        v17 = 0;
LABEL_57:
        v14 = *(void ***)v55;
      }
      else
      {
        v16 = 0;
        v17 = 0;
        do
        {
          v18 = *(_BYTE *)(*((_QWORD *)a1 + 6) + v15++);
          v17 |= (unint64_t)(v18 & 0x7F) << v16;
          if ((v18 & 0x80) == 0)
            break;
          v19 = v16 == 63;
          v16 += 7;
        }
        while (!v19);
        *((_QWORD *)a1 + 5) = v15;
      }
      if (v10)
        v20 = v10 - (v17 >> 2);
      else
        v20 = v17 >> 2;
      if ((v17 & 2) == 0)
        v10 = v20;
      if ((v17 & 1) != 0)
      {
        v23 = 1;
        if (v11)
        {
LABEL_18:
          if ((v17 & 2) != 0)
            v24 = 2;
          else
            v24 = 1;
          v25 = atomic_load((unsigned int *)v14 + 3);
          v26 = v25 + v24;
          v27 = *((unsigned int *)v14 + 2);
          if (v26 >= v27)
          {
            v42 = 2 * v27;
            if (!(_DWORD)v27)
              v42 = 0x4000;
            *((_DWORD *)v14 + 2) = v42;
            v54 = v12;
            v43 = my_vm_reallocate(*(void ***)v55, 12 * v27, 12 * v42, 243, *(_QWORD *)(*(_QWORD *)v55 + 16));
            LODWORD(v12) = v54;
            v9 = v56;
            v14 = *(void ***)v55;
            if (v43)
            {
              v48 = __si_assert_copy_extra(0);
              v45 = v48;
              v49 = "";
              if (v48)
                v49 = v48;
              __message_assert("%s:%u: failed assertion '%s' %s ", "DocPosting.h", 250, "0 == kr", v49);
LABEL_62:
              free(v45);
              if (__valid_fs(-1))
                v47 = 2989;
              else
                v47 = 3072;
              *(_DWORD *)v47 = -559038737;
              abort();
            }
          }
          do
            v28 = __ldaxr(v13);
          while (__stlxr(v28 + v24, v13));
          if ((_DWORD)v12)
            a3 = (uint64_t)*v14 + 12 * v12;
          if ((_DWORD)v28)
            v29 = (uint64_t)*v14 + 12 * v28;
          else
            v29 = 0;
          *(_DWORD *)a3 = *(_DWORD *)a3 & 1 | (2 * v28);
          v12 = v28;
          a3 = v29;
        }
      }
      else
      {
        v21 = v12;
        vint32 = store_stream_read_vint32((uint64_t)a1);
        v12 = v21;
        v9 = v56;
        v14 = *(void ***)v55;
        v23 = vint32;
        if (v11)
          goto LABEL_18;
      }
      if (!a3)
      {
        v44 = __si_assert_copy_extra(0);
        v45 = v44;
        v46 = "";
        if (v44)
          v46 = v44;
        __message_assert("%s:%u: failed assertion '%s' %s ", "CIPayloadData.c", 713, "lastPosting", v46);
        goto LABEL_62;
      }
      if ((v17 & 2) != 0)
      {
        *(_QWORD *)(a3 + 8) = v17 >> 2;
        v30 = 1;
      }
      else
      {
        v30 = 0;
        *(_DWORD *)(a3 + 8) = v20;
      }
      *(_DWORD *)a3 = v30;
      *(_DWORD *)(a3 + 4) = v23;
      if (++v11 == v9)
        return store_stream_read_vint32((uint64_t)a1);
    }
  }
  return result;
}

uint64_t CIWritePostings(uint64_t a1, uint64_t a2, uint64_t *a3, unsigned int *a4, unsigned int a5, int a6)
{
  unsigned int *v7;
  unsigned int v11;
  uint64_t v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t result;
  uint64_t v16;
  unsigned int v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unsigned int v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  size_t v25;
  size_t v26;
  uint64_t v27;
  uint64_t v28;
  _QWORD *v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  _DWORD *v34;
  size_t v35;
  char *v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  _BYTE *v41;
  _BYTE *v42;
  _BYTE *v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  char *v47;
  size_t v48;
  uint64_t v49;
  char *v50;
  char *v51;
  const char *v52;
  char *v53;
  const char *v54;
  uint64_t v55;
  size_t v56;
  char *v57;
  char *v58;
  const char *v59;
  uint64_t v60;
  unsigned int v62;
  uint64_t v63;
  _OWORD __src[2];
  uint64_t v65;

  v7 = a4;
  v65 = *MEMORY[0x1E0C80C00];
  v11 = *a4;
  if (*a4 < 2)
  {
    v12 = *(_QWORD *)(a1 + 40);
    if ((unint64_t)(*(_QWORD *)(a1 + 32) - v12) < 6)
    {
      *(_QWORD *)((char *)__src + 9) = 0;
      *(_QWORD *)((char *)__src + 1) = 0;
      *((_QWORD *)&__src[1] + 1) = 0;
      *(_QWORD *)((char *)&__src[1] + 1) = 0;
      v13 = 1;
      LOBYTE(__src[0]) = 1;
      store_stream_write_bytes(a1, (char *)__src, 1uLL);
    }
    else
    {
      v13 = 1;
      *(_BYTE *)(*(_QWORD *)(a1 + 48) + v12) = 1;
      *(_QWORD *)(a1 + 40) = v12 + 1;
    }
    goto LABEL_7;
  }
  v13 = 1;
  v14 = *a4;
  do
  {
    ++v13;
    v14 = *(_DWORD *)(a2 + 12 * (v14 >> 1));
  }
  while (v14 > 1);
  result = (uint64_t)store_stream_write_vint32((_QWORD *)a1, v13);
  if (v13)
  {
LABEL_7:
    v62 = a5;
    v16 = 0;
    v17 = v13;
    while (v7)
    {
      v18 = *v7;
      if ((v18 & 1) != 0)
      {
        v20 = (4 * *((_QWORD *)v7 + 1)) | 2;
      }
      else
      {
        v19 = v16 - v7[2];
        if (!v16)
          v19 = v7[2];
        v20 = 4 * v19;
        v16 = v7[2];
      }
      v21 = v7[1];
      if (v21 == 1)
      {
        v22 = v20 | 1;
        v23 = *(_QWORD *)(a1 + 40);
        if ((unint64_t)(*(_QWORD *)(a1 + 32) - v23) < 0xB)
        {
          memset(__src, 0, sizeof(__src));
          v25 = writeVInt64((uint64_t)__src, 0, v22);
          result = store_stream_write_bytes(a1, (char *)__src, v25);
        }
        else
        {
          result = writeVInt64(*(_QWORD *)(a1 + 48), v23, v22);
          *(_QWORD *)(a1 + 40) = result;
        }
      }
      else
      {
        v24 = *(_QWORD *)(a1 + 40);
        if ((unint64_t)(*(_QWORD *)(a1 + 32) - v24) < 0xB)
        {
          memset(__src, 0, sizeof(__src));
          v26 = writeVInt64((uint64_t)__src, 0, v20);
          store_stream_write_bytes(a1, (char *)__src, v26);
        }
        else
        {
          *(_QWORD *)(a1 + 40) = writeVInt64(*(_QWORD *)(a1 + 48), v24, v20);
        }
        result = (uint64_t)store_stream_write_vint32((_QWORD *)a1, v21);
      }
      if (v18 >= 2)
        v7 = (unsigned int *)(a2 + 12 * (v18 >> 1));
      else
        v7 = 0;
      if (!--v17)
      {
        a5 = v62;
        goto LABEL_27;
      }
    }
    v50 = __si_assert_copy_extra(0);
    v51 = v50;
    v52 = "";
    if (v50)
      v52 = v50;
    __message_assert("%s:%u: failed assertion '%s' %s ", "CIPayloadData.c", 768, "p", v52);
LABEL_80:
    free(v51);
    if (__valid_fs(-1))
      v55 = 2989;
    else
      v55 = 3072;
    *(_DWORD *)v55 = -559038737;
    abort();
  }
LABEL_27:
  if (!a5 || (v11 & 1) != 0)
  {
    v32 = *(_QWORD *)(a1 + 40);
    if ((unint64_t)(*(_QWORD *)(a1 + 32) - v32) < 0xA)
    {
      memset(__src, 0, sizeof(__src));
      return store_stream_write_bytes(a1, (char *)__src, 1uLL);
    }
    else
    {
      *(_BYTE *)(*(_QWORD *)(a1 + 48) + v32) = 0;
      *(_QWORD *)(a1 + 40) = v32 + 1;
    }
  }
  else
  {
    v27 = *a3;
    v28 = *a3 + 32 * a5;
    v29 = (_QWORD *)(v28 + 16);
    v30 = (2 * *(_QWORD *)(v28 + 16)) | 1;
    v31 = *(_QWORD *)(a1 + 40);
    if ((unint64_t)(*(_QWORD *)(a1 + 32) - v31) < 0xA)
    {
      memset(__src, 0, sizeof(__src));
      v56 = v2_writeVInt64_7950((uint64_t)__src, 0, v30);
      store_stream_write_bytes(a1, (char *)__src, v56);
    }
    else
    {
      *(_QWORD *)(a1 + 40) = v2_writeVInt64_7950(*(_QWORD *)(a1 + 48), v31, v30);
    }
    if (*(_DWORD *)(v27 + 32 * a5 + 8))
    {
      LODWORD(result) = CIPositionNodeFinalizeDocument((uint64_t)a3);
      goto LABEL_36;
    }
    result = *(unsigned int *)(v28 + 4);
    if ((_DWORD)result)
    {
LABEL_36:
      v33 = 0;
      while (1)
      {
        v34 = (_DWORD *)(a3[2] + 8 * result);
        v37 = *v34;
        v36 = (char *)(v34 + 1);
        LODWORD(v35) = v37;
        v38 = *(_QWORD *)(a1 + 40);
        if ((unint64_t)(*(_QWORD *)(a1 + 32) - v38) < 6)
        {
          memset(__src, 0, sizeof(__src));
          if (v35 > 0x7F)
          {
            if (v35 >> 14)
            {
              if (v35 >> 21)
              {
                if (v35 >> 28)
                {
                  LOBYTE(__src[0]) = -16;
                  *(_DWORD *)((char *)__src + 1) = v35;
                  v48 = 5;
                }
                else
                {
                  LOBYTE(__src[0]) = BYTE3(v35) | 0xE0;
                  BYTE1(__src[0]) = BYTE2(v35);
                  BYTE2(__src[0]) = BYTE1(v35);
                  BYTE3(__src[0]) = v35;
                  v48 = 4;
                }
              }
              else
              {
                LOBYTE(__src[0]) = BYTE2(v35) | 0xC0;
                BYTE1(__src[0]) = BYTE1(v35);
                BYTE2(__src[0]) = v35;
                v48 = 3;
              }
            }
            else
            {
              LOBYTE(__src[0]) = BYTE1(v35) | 0x80;
              BYTE1(__src[0]) = v35;
              v48 = 2;
            }
          }
          else
          {
            LOBYTE(__src[0]) = v35;
            v48 = 1;
          }
          store_stream_write_bytes(a1, (char *)__src, v48);
          v40 = *(_QWORD *)(a1 + 40);
        }
        else
        {
          v39 = *(_QWORD *)(a1 + 48);
          if (v35 > 0x7F)
          {
            if (v35 >> 14)
            {
              if (v35 >> 21)
              {
                if (v35 >> 28)
                {
                  v44 = v39 + v38;
                  *(_BYTE *)v44 = -16;
                  *(_DWORD *)(v44 + 1) = v35;
                  v40 = v38 + 5;
                }
                else
                {
                  v43 = (_BYTE *)(v39 + v38);
                  *v43 = BYTE3(v35) | 0xE0;
                  v43[1] = BYTE2(v35);
                  v43[2] = BYTE1(v35);
                  v40 = v38 + 4;
                  v43[3] = v35;
                }
              }
              else
              {
                v42 = (_BYTE *)(v39 + v38);
                *v42 = BYTE2(v35) | 0xC0;
                v42[1] = BYTE1(v35);
                v40 = v38 + 3;
                v42[2] = v35;
              }
            }
            else
            {
              v41 = (_BYTE *)(v39 + v38);
              *v41 = BYTE1(v35) | 0x80;
              v40 = v38 + 2;
              v41[1] = v35;
            }
          }
          else
          {
            v40 = v38 + 1;
            *(_BYTE *)(v39 + v38) = v35;
          }
          *(_QWORD *)(a1 + 40) = v40;
        }
        v45 = (int)v35;
        v46 = *(_QWORD *)(a1 + 32);
        if (v40 + (int)v35 >= v46)
        {
          v35 = (int)v35;
          v47 = v36;
          while (1)
          {
            v63 = v46 - v40;
            memcpy((void *)(*(_QWORD *)(a1 + 48) + v40), v47, v46 - v40);
            *(_QWORD *)(a1 + 40) += v63;
            if (store_stream_flush((unsigned int *)a1, 0))
              break;
            v47 += v63;
            v35 -= v63;
            v46 = *(_QWORD *)(a1 + 32);
            v40 = *(_QWORD *)(a1 + 40);
            if (v40 + v35 < v46)
              goto LABEL_50;
          }
        }
        else
        {
          v47 = v36;
          v35 = (int)v35;
LABEL_50:
          memcpy((void *)(*(_QWORD *)(a1 + 48) + v40), v47, v35);
          *(_QWORD *)(a1 + 40) += v35;
        }
        if (v36[v45 - 1])
          break;
        ++v33;
        result = *(unsigned int *)&v36[v45];
        if (!(_DWORD)result)
          goto LABEL_69;
      }
      v53 = __si_assert_copy_extra(0);
      v51 = v53;
      v54 = "";
      if (v53)
        v54 = v53;
      __message_assert("%s:%u: failed assertion '%s' %s ", "CIPayloadData.c", 829, "posStart[len-1]==0", v54);
      goto LABEL_80;
    }
    v33 = 0;
LABEL_69:
    v49 = *(_QWORD *)(a1 + 40);
    if ((unint64_t)(*(_QWORD *)(a1 + 32) - v49) < 0xA)
    {
      memset(__src, 0, sizeof(__src));
      result = store_stream_write_bytes(a1, (char *)__src, 1uLL);
    }
    else
    {
      *(_BYTE *)(*(_QWORD *)(a1 + 48) + v49) = 0;
      *(_QWORD *)(a1 + 40) = v49 + 1;
    }
    if (!*v29 && v13 != v33)
    {
      v57 = __si_assert_copy_extra(*(_DWORD **)(a1 + 56));
      v58 = v57;
      v59 = "";
      if (v57)
        v59 = v57;
      __message_assert("%s:%u: failed assertion '%s' %s o:%lld, pc:%d dc:%d flags:%d", "CIPayloadData.c", 836, "node->offset || postingCount==docCount", v59, *v29, v13, v33, a6);
      free(v58);
      if (__valid_fsp(*(_DWORD **)(a1 + 56)))
        v60 = 2989;
      else
        v60 = 3072;
      *(_DWORD *)v60 = -559038737;
      abort();
    }
  }
  return result;
}

void oqdispose_AnnotatedPositionOffset_t(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  if (*(uint64_t *)(a1 + 24) >= 1)
  {
    v2 = 0;
    v3 = 8;
    do
    {
      CFRelease(*(CFTypeRef *)(*(_QWORD *)(a1 + 8) + v3));
      ++v2;
      v3 += 56;
    }
    while (v2 < *(_QWORD *)(a1 + 24));
  }
  if (*(_DWORD *)(a1 + 48))
  {
    v4 = *(_QWORD *)(a1 + 32);
    if (v4 < *(_QWORD *)(a1 + 40))
    {
      v5 = 56 * v4 + 8;
      do
      {
        CFRelease(*(CFTypeRef *)(*(_QWORD *)(a1 + 8) + v5));
        ++v4;
        v5 += 56;
      }
      while (v4 < *(_QWORD *)(a1 + 40));
    }
  }
  free(*(void **)(a1 + 8));
}

void parallel_qsort_AnnotatedPositionOffset_t(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  NSObject *v5;
  int v6;
  uint64_t v7;
  size_t v8;
  int v9[2];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (a2 > 2047)
  {
    v4 = OSAtomicDequeue(&qsort_cached_allocations_9112, 0);
    if (!v4)
      v4 = malloc_type_malloc(0x40uLL, 0x102004053A8A26AuLL);
    v5 = dispatch_group_create();
    v4[3] = v5;
    v4[4] = 0;
    v4[1] = 0;
    v4[2] = a2 - 1;
    *v4 = a1;
    v6 = thread_count_9113;
    if (!thread_count_9113)
    {
      *(_QWORD *)v9 = 0x1900000006;
      v8 = 4;
      sysctl(v9, 2u, &thread_count_9113, &v8, 0, 0);
      v6 = thread_count_9113;
    }
    *((_DWORD *)v4 + 14) = v6;
    v4[5] = (uint64_t)sqrt((double)a2) / 2;
    if (!v6)
    {
      *(_QWORD *)v9 = 0x1900000006;
      v8 = 4;
      sysctl(v9, 2u, &thread_count_9113, &v8, 0, 0);
      v6 = thread_count_9113;
    }
    v7 = a2 / (2 * v6);
    if (v7 <= 0x8000)
    {
      v7 = 0x8000;
    }
    else if (!v6)
    {
      *(_QWORD *)v9 = 0x1900000006;
      v8 = 4;
      sysctl(v9, 2u, &thread_count_9113, &v8, 0, 0);
      v7 = a2 / (2 * thread_count_9113);
    }
    v4[6] = v7;
    if ((uint64_t)v4[5] <= 2047)
      v4[5] = 2048;
    _qsort_big_AnnotatedPositionOffset_t(v4);
    dispatch_group_wait(v5, 0xFFFFFFFFFFFFFFFFLL);
    dispatch_release(v5);
  }
  else
  {
    _qsort_AnnotatedPositionOffset_t(a1, 0, a2 - 1);
  }
}

void _qsort_AnnotatedPositionOffset_t(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  BOOL v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  _OWORD *v22;
  uint64_t v23;
  uint64_t *v24;
  char *v25;
  char *v26;
  const char *v27;
  uint64_t v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;

  v6 = malloc_type_malloc(0x800uLL, 0x1000040451B5BE8uLL);
  *v6 = 0;
  v6[1] = 0;
  v7 = 1;
  do
  {
    if (a3 > a2)
    {
      if (v7 <= 128)
        v8 = 128;
      else
        v8 = v7;
      v9 = &v6[2 * v7 + 1];
      while (a3 - a2 > 16)
      {
        v10 = _partition_AnnotatedPositionOffset_t(a1, a2, a3);
        v11 = v10 - a2;
        if (v10 < a2)
        {
          v25 = __si_assert_copy_extra(0);
          v26 = v25;
          v27 = "";
          if (v25)
            v27 = v25;
          __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 49, "q>=left", v27);
          free(v26);
          if (__valid_fs(-1))
            v28 = 2989;
          else
            v28 = 3072;
          *(_DWORD *)v28 = -559038737;
          abort();
        }
        if (v8 == v7)
        {
          heapsort_b((void *)(a1 + 56 * a2), a3 - a2 + 1, 0x38uLL, &__block_literal_global_9109);
          v7 = v8;
          goto LABEL_27;
        }
        v12 = v11 <= a3 - v10;
        if (v11 <= a3 - v10)
          v13 = v10 - 1;
        else
          v13 = a3;
        if (v12)
          v14 = a2;
        else
          v14 = v10;
        if (v12)
          a2 = v10;
        else
          a3 = v10 - 1;
        *(v9 - 1) = v14;
        *v9 = v13;
        ++v7;
        v9 += 2;
        if (a3 <= a2)
          goto LABEL_27;
      }
      v15 = a1 + 64 + 56 * a2;
      v16 = a2;
      do
      {
        v17 = v16;
        v18 = a1 + 56 * v16;
        v19 = *(_QWORD *)(v18 + 56);
        ++v16;
        v32 = *(_OWORD *)(v18 + 64);
        v33 = *(_OWORD *)(v18 + 80);
        v34 = *(_OWORD *)(v18 + 96);
        v20 = *(_QWORD *)v18;
        v29 = *(_OWORD *)(v18 + 8);
        v30 = *(_OWORD *)(v18 + 24);
        v31 = *(_OWORD *)(v18 + 40);
        v21 = v16;
        if (v20 > v19)
        {
          v22 = (_OWORD *)v15;
          do
          {
            v21 = v17;
            *((_QWORD *)v22 - 1) = v20;
            *v22 = v29;
            v22[1] = v30;
            v22[2] = v31;
            if (v17 <= a2)
              break;
            v20 = *((_QWORD *)v22 - 15);
            v29 = *(v22 - 7);
            v30 = *(v22 - 6);
            v31 = *(v22 - 5);
            v22 = (_OWORD *)((char *)v22 - 56);
            --v17;
          }
          while (v20 > v19);
        }
        v23 = a1 + 56 * v21;
        *(_QWORD *)v23 = v19;
        *(_OWORD *)(v23 + 8) = v32;
        *(_OWORD *)(v23 + 24) = v33;
        *(_OWORD *)(v23 + 40) = v34;
        v15 += 56;
      }
      while (v16 != a3);
    }
LABEL_27:
    --v7;
    v24 = &v6[2 * v7];
    a2 = *v24;
    a3 = v24[1];
  }
  while (v7);
  free(v6);
}

uint64_t _partition_AnnotatedPositionOffset_t(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t *v7;
  unint64_t *v8;
  unint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  BOOL v15;
  uint64_t *v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  unint64_t v26;
  uint64_t v27;
  _OWORD *v28;
  unint64_t v29;
  __int128 *v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 *v34;
  unint64_t v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  uint64_t v43;
  uint64_t v44;
  unint64_t *v45;
  unint64_t v46;
  unint64_t v47;
  unint64_t *v48;
  unint64_t v49;
  BOOL v50;
  unint64_t *v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;

  v3 = a3 - a2;
  v4 = a3 - a2 + 1;
  v5 = (uint64_t *)(a1 + 56 * a2);
  v6 = a3 - a2 + 2;
  if (a3 - a2 >= -1)
    v6 = v3 + 1;
  v7 = &v5[7 * (v6 >> 1)];
  v8 = (unint64_t *)(a1 + 56 * a3);
  if (v3 < 1024)
  {
    v13 = (unint64_t *)(a1 + 56 * a2);
    v16 = v7;
    goto LABEL_15;
  }
  v9 = v4 >> 3;
  v10 = (unint64_t *)&v5[7 * (v4 >> 3)];
  v11 = *v5;
  v12 = *v10;
  v13 = (unint64_t *)(a1 + 56 * a2);
  if (*v5 != *v10)
  {
    v14 = v5[14 * v9];
    v15 = v14 == v11 || v14 == v12;
    v13 = (unint64_t *)&v5[14 * v9];
    if (!v15)
    {
      v13 = v10;
      if (v11 >= v12)
      {
        if (v12 <= v14)
        {
          if (v11 >= v14)
            v13 = (unint64_t *)&v5[14 * v9];
          else
            v13 = (unint64_t *)(a1 + 56 * a2);
        }
      }
      else if (v12 >= v14)
      {
        if (v11 >= v14)
          v13 = (unint64_t *)(a1 + 56 * a2);
        else
          v13 = (unint64_t *)&v5[14 * v9];
      }
    }
  }
  v43 = 2 * v9;
  v44 = -(uint64_t)v9;
  v45 = (unint64_t *)&v7[-7 * v9];
  v46 = *v45;
  v47 = *v7;
  if (*v45 == *v7)
  {
    v16 = &v7[-7 * v9];
  }
  else
  {
    v48 = (unint64_t *)&v7[7 * v9];
    v49 = *v48;
    v50 = *v48 == v46 || v49 == v47;
    v16 = &v7[7 * v9];
    if (!v50)
    {
      v16 = v7;
      if (v46 >= v47)
      {
        if (v47 <= v49)
        {
          if (v46 >= v49)
            v16 = (uint64_t *)v48;
          else
            v16 = (uint64_t *)v45;
        }
      }
      else if (v47 >= v49)
      {
        if (v46 >= v49)
          v16 = (uint64_t *)v45;
        else
          v16 = (uint64_t *)v48;
      }
    }
  }
  v51 = &v8[-7 * v43];
  v17 = &v8[7 * v44];
  v52 = *v51;
  v53 = *v17;
  if (*v51 == *v17)
  {
    v17 = v51;
    goto LABEL_16;
  }
  v54 = *v8;
  if (*v8 == v52 || v54 == v53)
  {
LABEL_15:
    v17 = (unint64_t *)(a1 + 56 * a3);
    goto LABEL_16;
  }
  if (v52 >= v53)
  {
    if (v53 <= v54)
    {
      if (v52 >= v54)
        v17 = (unint64_t *)(a1 + 56 * a3);
      else
        v17 = v51;
    }
  }
  else if (v53 >= v54)
  {
    if (v52 >= v54)
      v17 = v51;
    else
      v17 = (unint64_t *)(a1 + 56 * a3);
  }
LABEL_16:
  v18 = *v13;
  v19 = *v16;
  if (*v13 == *v16)
  {
    v16 = (uint64_t *)v13;
  }
  else
  {
    v20 = *v17;
    if (*v17 == v18 || v20 == v19)
    {
      v16 = (uint64_t *)v17;
    }
    else if (v18 >= v19)
    {
      if (v19 <= v20)
      {
        if (v18 >= v20)
          v16 = (uint64_t *)v17;
        else
          v16 = (uint64_t *)v13;
      }
    }
    else if (v19 >= v20)
    {
      if (v18 >= v20)
        v16 = (uint64_t *)v13;
      else
        v16 = (uint64_t *)v17;
    }
  }
  v22 = *v16;
  v63 = *(_OWORD *)(v16 + 3);
  v64 = *(_OWORD *)(v16 + 5);
  v62 = *(_OWORD *)(v16 + 1);
  v23 = *(_OWORD *)v8;
  v24 = *((_OWORD *)v8 + 1);
  v25 = *((_OWORD *)v8 + 2);
  v16[6] = v8[6];
  *((_OWORD *)v16 + 1) = v24;
  *((_OWORD *)v16 + 2) = v25;
  *(_OWORD *)v16 = v23;
  *v8 = v22;
  *(_OWORD *)(v8 + 1) = v62;
  *(_OWORD *)(v8 + 3) = v63;
  *(_OWORD *)(v8 + 5) = v64;
  v26 = *v5;
  v59 = *(_OWORD *)(v5 + 1);
  v60 = *(_OWORD *)(v5 + 3);
  v61 = *(_OWORD *)(v5 + 5);
  v27 = a3 - a2;
  if (a3 > a2)
  {
    v28 = (_OWORD *)(a1 + 56 * a2 + 64);
    do
    {
      v56 = v59;
      v57 = v60;
      v29 = *((_QWORD *)v28 - 1);
      v58 = v61;
      v59 = *v28;
      v60 = v28[1];
      v61 = v28[2];
      if (v26 <= v22)
      {
        v30 = (__int128 *)(a1 + 56 * a2);
        v31 = *v30;
        v32 = v30[1];
        v33 = v30[2];
        *((_QWORD *)v28 - 2) = *((_QWORD *)v30 + 6);
        *(v28 - 3) = v32;
        *(v28 - 2) = v33;
        *(v28 - 4) = v31;
        *(_QWORD *)v30 = v26;
        *(__int128 *)((char *)v30 + 8) = v56;
        *(__int128 *)((char *)v30 + 24) = v57;
        *(__int128 *)((char *)v30 + 40) = v58;
        ++a2;
      }
      v28 = (_OWORD *)((char *)v28 + 56);
      v26 = v29;
      --v27;
    }
    while (v27);
  }
  v34 = (__int128 *)(a1 + 56 * a2);
  v35 = *((_QWORD *)v34 + 6);
  v37 = v34[1];
  v36 = v34[2];
  v38 = *v34;
  v40 = *((_OWORD *)v8 + 1);
  v39 = *((_OWORD *)v8 + 2);
  v41 = *(_OWORD *)v8;
  *((_QWORD *)v34 + 6) = v8[6];
  v34[1] = v40;
  v34[2] = v39;
  *v34 = v41;
  *(_OWORD *)v8 = v38;
  *((_OWORD *)v8 + 1) = v37;
  *((_OWORD *)v8 + 2) = v36;
  v8[6] = v35;
  return a2;
}

void _qsort_big_AnnotatedPositionOffset_t(void *a1)
{
  uint64_t v1;
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  signed int v6;
  unint64_t i;
  uint64_t v8;
  uint64_t v10;
  host_t v11;
  mach_error_t v12;
  unint64_t v13;
  unint64_t v14;
  NSObject *v15;
  qos_class_t v16;
  NSObject *global_queue;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _DWORD *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  int v26;
  int v27;
  qos_class_t v28;
  NSObject *v29;
  qos_class_t v30;
  NSObject *v31;
  char *v32;
  char *v33;
  const char *v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  _QWORD block[5];
  mach_msg_type_number_t host_info_outCnt;
  integer_t host_info_out[4];
  __int128 v42;
  __int128 v43;

  v1 = *((_QWORD *)a1 + 1);
  v2 = *((_QWORD *)a1 + 2);
  v3 = *((_QWORD *)a1 + 3);
  v4 = *((_QWORD *)a1 + 4);
  v5 = *((_QWORD *)a1 + 5);
  v37 = *((_QWORD *)a1 + 6);
  v38 = *(_QWORD *)a1;
  v6 = *((_DWORD *)a1 + 14);
  v36 = *((_DWORD *)a1 + 15);
  OSAtomicEnqueue(&qsort_cached_allocations_9112, a1, 0);
  if (v2 > v1)
  {
    for (i = v4 + 1; ; ++i)
    {
      v8 = v2 - v1;
      if (v2 - v1 <= v5 || i > 9)
        break;
      if (v6 <= 1)
        v6 = 1;
      v10 = getSize_memSize_9114;
      if (!getSize_memSize_9114)
      {
        v42 = 0u;
        v43 = 0u;
        *(_OWORD *)host_info_out = 0u;
        v11 = MEMORY[0x1BCCB1010]();
        host_info_outCnt = 12;
        v12 = host_info(v11, 1, host_info_out, &host_info_outCnt);
        if (v12)
        {
          mach_error("flushsize", v12);
          exit(1);
        }
        v10 = *((_QWORD *)&v43 + 1);
        getSize_memSize_9114 = *((_QWORD *)&v43 + 1);
      }
      v13 = 3 * v10;
      v14 = (v13 * (unsigned __int128)0xCCCCCCCCCCCCCCCDLL) >> 64;
      v15 = v3;
      if (56 * v8 > v13 / 5)
        v15 = dispatch_group_create();
      if (v8 <= v37 || 56 * v8 >= v14 >> 2)
      {
        v18 = _partition_AnnotatedPositionOffset_t(v38, v1, v2);
      }
      else
      {
        v16 = qos_class_self();
        global_queue = dispatch_get_global_queue(v16, 2uLL);
        v18 = _big_partition_AnnotatedPositionOffset_t(v38, v1, v2, global_queue, v6);
      }
      v19 = v18;
      v20 = v18 - v1;
      if (v18 < v1)
      {
        v32 = __si_assert_copy_extra(0);
        v33 = v32;
        v34 = "";
        if (v32)
          v34 = v32;
        __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 49, "q>=left", v34);
        free(v33);
        if (__valid_fs(-1))
          v35 = 2989;
        else
          v35 = 3072;
        *(_DWORD *)v35 = -559038737;
        abort();
      }
      v21 = OSAtomicDequeue(&qsort_cached_allocations_9112, 0);
      if (!v21)
        v21 = malloc_type_malloc(0x40uLL, 0x102004053A8A26AuLL);
      *((_QWORD *)v21 + 4) = i;
      *((_QWORD *)v21 + 5) = v5;
      *((_QWORD *)v21 + 6) = v37;
      v22 = v2 - v19;
      if (v20 <= v2 - v19)
      {
        v23 = v19 - 1;
      }
      else
      {
        v22 = v19 - 1 - v1;
        v23 = v2;
      }
      if (v20 > v2 - v19)
        v24 = v19;
      else
        v24 = v1;
      if (v20 > v2 - v19)
        v2 = v19 - 1;
      else
        v1 = v19;
      *(_QWORD *)v21 = v38;
      *((_QWORD *)v21 + 1) = v24;
      v25 = (int)(float)((float)((float)(v22 + 1) / (float)(v23 - v24 + 1)) * (float)v6);
      if (v25 <= 1)
        v26 = 1;
      else
        v26 = v25;
      if (v6 >= v25)
        v27 = v26;
      else
        v27 = 0;
      v21[14] = v6 - v27;
      v21[15] = v36;
      *((_QWORD *)v21 + 2) = v23;
      *((_QWORD *)v21 + 3) = v15;
      if (v15 == v3)
      {
        if (v6 >= v25)
          v6 = v26;
        v30 = qos_class_self();
        v31 = dispatch_get_global_queue(v30, 2uLL);
        dispatch_group_async_f(v3, v31, v21, (dispatch_function_t)_qsort_big_AnnotatedPositionOffset_t);
      }
      else
      {
        v21[14] = v6;
        _qsort_big_AnnotatedPositionOffset_t(v21);
        dispatch_group_wait(v15, 0xFFFFFFFFFFFFFFFFLL);
        dispatch_release(v15);
        v28 = qos_class_self();
        v29 = dispatch_get_global_queue(v28, 2uLL);
        block[0] = MEMORY[0x1E0C809B0];
        block[1] = 0x40000000;
        block[2] = ___qsort_big_AnnotatedPositionOffset_t_block_invoke;
        block[3] = &__block_descriptor_tmp_9116;
        block[4] = v21;
        dispatch_async(v29, block);
      }
      if (v2 <= v1)
        return;
    }
    _qsort_AnnotatedPositionOffset_t(v38, v1, v2);
  }
}

uint64_t _big_partition_AnnotatedPositionOffset_t(uint64_t a1, uint64_t a2, uint64_t a3, NSObject *a4, unsigned int a5)
{
  uint64_t v7;
  BOOL v8;
  unint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t *v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t *v18;
  unint64_t v19;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t *v27;
  unint64_t v28;
  BOOL v29;
  uint64_t *v30;
  unint64_t *v31;
  unint64_t *v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t *v36;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;

  v7 = a3 - a2;
  v8 = __OFADD__(a3 - a2, 1);
  v9 = a3 - a2 + 1;
  v10 = (uint64_t *)(a1 + 56 * a2);
  v11 = v7 + 2;
  if (((v9 & 0x8000000000000000) != 0) == v8)
    v11 = v7 + 1;
  v12 = &v10[7 * (v11 >> 1)];
  v13 = (unint64_t *)(a1 + 56 * a3);
  if (v7 < 64)
  {
    v30 = v12;
    v18 = v10;
  }
  else
  {
    v14 = v9 >> 3;
    v15 = (unint64_t *)&v10[7 * (v9 >> 3)];
    v16 = *v10;
    v17 = *v15;
    v18 = v10;
    if (*v10 != *v15)
    {
      v18 = &v10[14 * v14];
      v19 = *v18;
      if (*v18 != v16 && v19 != v17)
      {
        if (v16 >= v19)
          v21 = &v10[14 * v14];
        else
          v21 = v10;
        if (v17 > v19)
          v21 = &v10[7 * (v9 >> 3)];
        if (v16 >= v19)
          v18 = v10;
        if (v17 < v19)
          v18 = &v10[7 * (v9 >> 3)];
        if (v16 >= v17)
          v18 = v21;
      }
    }
    v22 = 2 * v14;
    v23 = -(uint64_t)v14;
    v24 = &v12[-7 * v14];
    v25 = *v24;
    v26 = *v12;
    if (*v24 == *v12)
    {
      v30 = &v12[-7 * v14];
    }
    else
    {
      v27 = &v12[7 * v14];
      v28 = *v27;
      v29 = *v27 == v25 || v28 == v26;
      v30 = &v12[7 * v14];
      if (!v29)
      {
        v30 = v12;
        if (v25 >= v26)
        {
          if (v26 <= v28)
          {
            if (v25 >= v28)
              v30 = v27;
            else
              v30 = v24;
          }
        }
        else if (v26 >= v28)
        {
          if (v25 >= v28)
            v30 = v24;
          else
            v30 = v27;
        }
      }
    }
    v31 = &v13[-7 * v22];
    v32 = &v13[7 * v23];
    v33 = *v31;
    v34 = *v32;
    if (*v31 == *v32)
    {
      v13 = v31;
    }
    else
    {
      v35 = *v13;
      if (v33 >= *v13)
        v36 = v13;
      else
        v36 = v31;
      if (v34 > v35)
        v36 = v32;
      if (v33 < v35)
        v31 = v13;
      if (v34 < v35)
        v31 = v32;
      if (v33 >= v34)
        v31 = v36;
      if (v35 != v33 && v35 != v34)
        v13 = v31;
    }
  }
  v38 = *v18;
  v39 = *v30;
  if (*v18 == *v30)
  {
    v30 = v18;
  }
  else
  {
    v40 = *v13;
    if (*v13 == v38 || v40 == v39)
    {
      v30 = (uint64_t *)v13;
    }
    else if (v38 >= v39)
    {
      if (v39 <= v40)
      {
        if (v38 >= v40)
          v30 = (uint64_t *)v13;
        else
          v30 = v18;
      }
    }
    else if (v39 >= v40)
    {
      if (v38 >= v40)
        v30 = v18;
      else
        v30 = (uint64_t *)v13;
    }
  }
  return parallel_partition_AnnotatedPositionOffset_t(v10, v9, *v30, a4, a5) + a2;
}

uint64_t parallel_partition_AnnotatedPositionOffset_t(void *a1, uint64_t a2, uint64_t a3, NSObject *a4, unsigned int a5)
{
  int v5;
  size_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD v17[2];
  _QWORD context[10];

  v5 = a5;
  v17[1] = v17;
  context[9] = *MEMORY[0x1E0C80C00];
  context[6] = a1;
  v10 = 8 * a5;
  MEMORY[0x1E0C80A78](a1);
  v12 = (char *)v17 - v11;
  bzero((char *)v17 - v11, v10);
  v13 = (a2 / 0x4000) << 13;
  context[1] = v13;
  context[2] = a2;
  context[4] = 0;
  context[5] = 0;
  v14 = a2 - v13;
  context[7] = a3;
  context[8] = v12;
  if (v5 >= 1)
    memset(v12, 255, v10);
  v15 = v13 + 0x2000;
  if (v14 > v13 + 0x2000)
    v15 = a2 - ((a2 / 0x4000) << 13);
  context[3] = v14 + ((v15 - v14 + 0x1FFF) & 0xFFFFFFFFFFFFE000);
  context[0] = 0;
  if (56 * a2 >= (unint64_t)(4 * *MEMORY[0x1E0C85AD8]))
    madvise(a1, 56 * a2, 3);
  if (a2 / 0x4000 < v5)
    v5 = a2 / 0x4000;
  dispatch_apply_f(v5, a4, context, (void (__cdecl *)(void *, size_t))partition_phase_AnnotatedPositionOffset_t);
  return sequential_fixup_AnnotatedPositionOffset_t((uint64_t)context, a2, v5);
}

unint64_t *partition_phase_AnnotatedPositionOffset_t(unint64_t *result, uint64_t a2)
{
  unint64_t *v3;
  unint64_t v4;
  int64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  BOOL v15;
  int64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;

  v3 = result;
  v4 = result[6];
  v5 = result[1];
  if ((uint64_t)*result >= v5)
    goto LABEL_5;
  do
    v6 = __ldxr(result);
  while (__stxr(v6 + 0x2000, result));
  if ((uint64_t)(v6 + 0x2000) > v5)
  {
    do
      v7 = __ldxr(result);
    while (__stxr(v7 - 0x2000, result));
LABEL_5:
    v6 = -1;
  }
  v8 = result[3];
  v9 = result + 2;
  if ((uint64_t)result[2] <= v8)
  {
LABEL_10:
    v13 = 0;
    if (v6 != -1)
    {
      v14 = 0;
      goto LABEL_36;
    }
    v11 = -1;
    v14 = 0;
LABEL_35:
    v6 = v11;
    goto LABEL_36;
  }
  do
  {
    v10 = __ldxr(v9);
    v11 = v10 - 0x2000;
  }
  while (__stxr(v10 - 0x2000, v9));
  if (v11 < v8)
  {
    do
      v12 = __ldxr(v9);
    while (__stxr(v12 + 0x2000, v9));
    goto LABEL_10;
  }
  v26 = 0;
  v27 = 0;
  v15 = v6 != -1;
  if (v10 != 0x1FFF && v6 != -1)
  {
    v13 = 0;
    v14 = 0;
    while (1)
    {
      result = (unint64_t *)neutralize_AnnotatedPositionOffset_t(v4 + 56 * v6, v4 + 56 * v11, v3[7], &v27, &v26);
      if ((result & 1) != 0)
        goto LABEL_26;
      v17 = v3[1];
      if ((uint64_t)*v3 >= v17)
        goto LABEL_24;
      do
        v6 = __ldxr(v3);
      while (__stxr(v6 + 0x2000, v3));
      if ((uint64_t)(v6 + 0x2000) > v17)
        break;
LABEL_25:
      v27 = 0;
      ++v14;
      if (((_DWORD)result - 1) > 1)
        goto LABEL_32;
LABEL_26:
      v19 = v3[3];
      if ((uint64_t)v3[2] > v19)
      {
        do
        {
          v20 = __ldxr(v9);
          v11 = v20 - 0x2000;
        }
        while (__stxr(v20 - 0x2000, v9));
        if (v11 >= v19)
          goto LABEL_31;
        do
          v21 = __ldxr(v9);
        while (__stxr(v21 + 0x2000, v9));
      }
      v11 = -1;
LABEL_31:
      v26 = 0;
      ++v13;
LABEL_32:
      v15 = v6 != -1;
      if (v11 == -1 || v6 == -1)
        goto LABEL_34;
    }
    do
      v18 = __ldxr(v3);
    while (__stxr(v18 - 0x2000, v3));
LABEL_24:
    v6 = -1;
    goto LABEL_25;
  }
  v14 = 0;
  v13 = 0;
LABEL_34:
  if (!v15)
    goto LABEL_35;
LABEL_36:
  *(_QWORD *)(v3[8] + 8 * a2) = v6;
  v22 = v3 + 4;
  do
    v23 = __ldxr(v22);
  while (__stxr(v23 + (v14 << 13), v22));
  v24 = v3 + 5;
  do
    v25 = __ldxr(v24);
  while (__stxr(v25 + (v13 << 13), v24));
  return result;
}

uint64_t sequential_fixup_AnnotatedPositionOffset_t(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  BOOL v13;
  uint64_t v14;
  unint64_t v15;
  void *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  __int128 *v40;
  __int128 *v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  uint64_t v45;
  char *v47;
  char *v48;
  const char *v49;
  uint64_t v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;

  v6 = a3;
  qsort(*(void **)(a1 + 64), a3, 8uLL, (int (__cdecl *)(const void *, const void *))index_comp_9118);
  v55 = 0;
  v56 = 0;
  v7 = *(_QWORD *)(a1 + 64);
  v8 = a3 - 1;
  v9 = 0;
  if (a3 < 1)
    goto LABEL_91;
  while (*(_QWORD *)(v7 + 8 * v9) == -1)
  {
    if (v6 == ++v9)
    {
      v9 = v6;
      break;
    }
  }
  if (a3 == 1)
  {
    v8 = 0;
  }
  else
  {
LABEL_91:
    do
    {
      if (*(_QWORD *)(v7 + 8 * v8) != -1)
        break;
      --v8;
    }
    while (v8);
  }
  while (v9 < v8)
  {
    v10 = neutralize_AnnotatedPositionOffset_t(*(_QWORD *)(a1 + 48) + 56 * *(_QWORD *)(v7 + 8 * v9), *(_QWORD *)(a1 + 48) + 56 * *(_QWORD *)(v7 + 8 * v8), *(_QWORD *)(a1 + 56), &v55, &v56);
    v7 = *(_QWORD *)(a1 + 64);
    if ((v10 & 1) == 0)
    {
      v11 = *(_QWORD *)(v7 + 8 * v9);
      if ((v11 & 0x8000000000000000) == 0 && v11 < *(_QWORD *)(a1 + 32))
      {
        *(_QWORD *)(v7 + 8 * v9) = -1;
        *(_QWORD *)(a1 + 32) += 0x2000;
      }
      ++v9;
      v55 = 0;
      if ((v10 - 1) > 1)
        continue;
    }
    v12 = *(_QWORD *)(v7 + 8 * v8);
    v13 = v12 >= a2 || v12 < a2 - *(_QWORD *)(a1 + 40);
    if (!v13)
    {
      *(_QWORD *)(v7 + 8 * v8) = -1;
      *(_QWORD *)(a1 + 40) += 0x2000;
    }
    --v8;
    v56 = 0;
  }
  v15 = *(_QWORD *)(a1 + 32);
  v14 = *(_QWORD *)(a1 + 40);
  v16 = malloc_type_malloc(0x70000uLL, 0x838088E8uLL);
  if (a3 < 1)
  {
    v31 = *(_QWORD *)a1;
    v32 = *(_QWORD *)(a1 + 16) - 1;
  }
  else
  {
    v17 = 0;
    v18 = ~v14 + a2;
    v19 = a3;
    v20 = *(uint64_t **)(a1 + 64);
    v21 = 8 * a3;
    do
    {
      v22 = v20[v17];
      if (v22 != -1 && v18 <= v22)
        break;
      if (v22 != -1)
      {
        if (v15 <= v22)
          break;
        v24 = *(_QWORD *)(a1 + 32);
        if (v24 > v22)
        {
          v25 = 0;
          do
          {
            if (v20[v25 / 8] == v24)
            {
              v24 += 0x2000;
              *(_QWORD *)(a1 + 32) = v24;
            }
            v25 += 8;
          }
          while (v21 != v25);
          if ((int64_t)v24 >= *(_QWORD *)a1)
            break;
          memcpy(v16, (const void *)(*(_QWORD *)(a1 + 48) + 56 * v20[v17]), 0x70000uLL);
          memcpy((void *)(*(_QWORD *)(a1 + 48) + 56 * *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8 * v17)), (const void *)(*(_QWORD *)(a1 + 48) + 56 * *(_QWORD *)(a1 + 32)), 0x70000uLL);
          memcpy((void *)(*(_QWORD *)(a1 + 48) + 56 * *(_QWORD *)(a1 + 32)), v16, 0x70000uLL);
          v20 = *(uint64_t **)(a1 + 64);
          v20[v17] = *(_QWORD *)(a1 + 32);
          *(_QWORD *)(a1 + 32) += 0x2000;
        }
      }
      ++v17;
    }
    while (v17 != v19);
    v26 = v19;
    do
    {
      v27 = v20[(v26 - 1)];
      if (v15 > v27)
        break;
      if (v27 != -1)
      {
        if (v18 > v27)
          break;
        v28 = (v26 - 1);
        v29 = *(_QWORD *)(a1 + 40) + 0x2000;
        *(_QWORD *)(a1 + 40) = v29;
        v30 = v19 + 1;
        do
        {
          if (v20[(v30 - 2)] == a2 - v29)
          {
            v29 += 0x2000;
            *(_QWORD *)(a1 + 40) = v29;
          }
          --v30;
        }
        while (v30 > 1);
        if ((unint64_t)(a2 - v29) < *(_QWORD *)(a1 + 16))
          break;
        memcpy(v16, (const void *)(*(_QWORD *)(a1 + 48) + 56 * v20[v28]), 0x70000uLL);
        memcpy((void *)(*(_QWORD *)(a1 + 48) + 56 * *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8 * v28)), (const void *)(*(_QWORD *)(a1 + 48) + 56 * (a2 - *(_QWORD *)(a1 + 40))), 0x70000uLL);
        memcpy((void *)(*(_QWORD *)(a1 + 48) + 56 * (a2 - *(_QWORD *)(a1 + 40))), v16, 0x70000uLL);
        v20 = *(uint64_t **)(a1 + 64);
        v20[v28] = a2 - *(_QWORD *)(a1 + 40);
      }
      v13 = v26-- <= 1;
    }
    while (!v13);
    v31 = *(_QWORD *)a1;
    v32 = *(_QWORD *)(a1 + 16) - 1;
    do
    {
      v34 = *v20++;
      v33 = v34;
      if (v34 != -1)
      {
        if (v33 < v31)
          v31 = v33;
        v35 = v33 + 0x2000;
        v36 = v33 + 0x1FFF;
        if (v35 > v32)
          v32 = v36;
        if (v32 >= a2)
        {
          v47 = __si_assert_copy_extra(0);
          v48 = v47;
          v49 = "";
          if (v47)
            v49 = v47;
          __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 49, "right < count", v49);
          free(v48);
          if (__valid_fs(-1))
            v50 = 2989;
          else
            v50 = 3072;
          *(_DWORD *)v50 = -559038737;
          abort();
        }
      }
      --v19;
    }
    while (v19);
  }
  free(v16);
  if (v31 >= v32)
  {
    v37 = v31;
  }
  else
  {
    v37 = v31;
    do
    {
      v39 = *(_QWORD *)(a1 + 48);
      v38 = *(_QWORD *)(a1 + 56);
      v40 = (__int128 *)(v39 + 56 * v31);
      while (*(_QWORD *)v40 < v38)
      {
        ++v37;
        v40 = (__int128 *)((char *)v40 + 56);
        if (v37 >= v32)
        {
          if (v32 <= v31 + 1)
            v37 = v31 + 1;
          else
            v37 = v32;
          goto LABEL_80;
        }
      }
      if (v37 < v32)
      {
        v41 = (__int128 *)(v39 + 56 * v32);
        while (*(_QWORD *)v41 > v38)
        {
          --v32;
          v41 = (__int128 *)((char *)v41 - 56);
          if (v37 >= v32)
            goto LABEL_80;
        }
        v51 = *v41;
        v52 = v41[1];
        v53 = v41[2];
        v54 = *((_QWORD *)v41 + 6);
        v43 = v40[1];
        v42 = v40[2];
        v44 = *v40;
        *((_QWORD *)v41 + 6) = *((_QWORD *)v40 + 6);
        v41[1] = v43;
        v41[2] = v42;
        *v41 = v44;
        v45 = *(_QWORD *)(a1 + 48) + 56 * v37;
        *(_OWORD *)v45 = v51;
        *(_OWORD *)(v45 + 16) = v52;
        *(_OWORD *)(v45 + 32) = v53;
        *(_QWORD *)(v45 + 48) = v54;
        ++v37;
        --v32;
      }
      v31 = v37;
    }
    while (v37 < v32);
  }
LABEL_80:
  if (*(_QWORD *)(*(_QWORD *)(a1 + 48) + 56 * v37) >= *(_QWORD *)(a1 + 56))
    return v37;
  else
    return v37 + 1;
}

uint64_t index_comp_9118(_QWORD *a1, _QWORD *a2)
{
  unsigned int v2;

  if (*a1 >= *a2)
    v2 = 0;
  else
    v2 = -1;
  if (*a1 > *a2)
    return 1;
  else
    return v2;
}

uint64_t neutralize_AnnotatedPositionOffset_t(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  uint64_t v12;
  __int128 *v13;
  uint64_t v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 *v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;

  v5 = *a4;
  v6 = *a5;
  while (1)
  {
    if (v5 < 0x2000)
    {
      v7 = (unint64_t *)(a1 + 56 * v5);
      while (1)
      {
        v8 = *v7;
        v7 += 7;
        if (v8 > a3)
          break;
        if (++v5 == 0x2000)
        {
          v9 = 0x2000;
          goto LABEL_8;
        }
      }
    }
    v9 = v5;
LABEL_8:
    if (v6 < 0x2000)
    {
      v10 = (unint64_t *)(a2 + 56 * v6);
      while (1)
      {
        v11 = *v10;
        v10 += 7;
        if (v11 < a3)
          break;
        if (++v6 == 0x2000)
        {
          v5 = v9;
          goto LABEL_17;
        }
      }
    }
    v12 = v6;
    if (v9 == 0x2000 || v6 == 0x2000)
      break;
    v13 = (__int128 *)(a2 + 56 * v6);
    v14 = *((_QWORD *)v13 + 6);
    v16 = v13[1];
    v15 = v13[2];
    v17 = *v13;
    v18 = (__int128 *)(a1 + 56 * v9);
    v20 = v18[1];
    v19 = v18[2];
    v21 = *v18;
    *((_QWORD *)v13 + 6) = *((_QWORD *)v18 + 6);
    v13[1] = v20;
    v13[2] = v19;
    *v13 = v21;
    *v18 = v17;
    v18[1] = v16;
    v18[2] = v15;
    *((_QWORD *)v18 + 6) = v14;
    v5 = v9 + 1;
    v6 = v12 + 1;
    if (v9 > 8190 || v12 >= 0x1FFF)
      goto LABEL_17;
  }
  v5 = v9;
LABEL_17:
  *a4 = v5;
  *a5 = v6;
  if (v6 == 0x2000 && v5 == 0x2000)
    return 2;
  else
    return v5 != 0x2000;
}

void oqsplit_AnnotatedPositionOffset_t(uint64_t a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __int128 *v7;
  uint64_t v8;
  __int128 *v9;
  uint64_t v10;
  unint64_t v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  qos_class_t v22;
  NSObject *global_queue;
  signed int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  char *v30;
  char *v31;
  const char *v32;
  const char *v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t *v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  unint64_t *v42;
  unint64_t v43;
  char *v44;
  char *v45;
  const char *v46;
  const char *v47;
  char *v48;
  char *v49;
  char *v50;
  uint64_t v51;
  char *v52;
  char *v53;
  size_t v54;
  int v55[4];
  __int128 v56;
  __int128 v57;
  uint64_t v58;
  uint64_t v59;

  v59 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v4 = *(_QWORD *)(a1 + 24);
    *(_QWORD *)(a1 + 40) = v4;
    if (v4 > 99999)
    {
      v20 = v4 - 1;
      v21 = *(void **)(a1 + 8);
      v22 = qos_class_self();
      global_queue = dispatch_get_global_queue(v22, 0);
      v24 = thread_count_9113;
      if (!thread_count_9113)
      {
        *(_QWORD *)v55 = 0x1900000006;
        v54 = 4;
        sysctl(v55, 2u, &thread_count_9113, &v54, 0, 0);
        v24 = thread_count_9113;
      }
      v4 = _big_split_AnnotatedPositionOffset_t(v21, v20, a2, global_queue, v24);
    }
    else if (v4 >= 1)
    {
      v5 = 0;
      v6 = *(_QWORD *)(a1 + 8);
      while (1)
      {
        v7 = (__int128 *)(v6 + 56 * v5);
        if (*(_QWORD *)v7 >= a2)
        {
          v8 = v4 >= v5 ? v5 : v4;
          v9 = (__int128 *)(v6 + 56 * v4);
          while (v4 > v5)
          {
            v10 = v4--;
            v11 = *((_QWORD *)v9 - 7);
            v9 = (__int128 *)((char *)v9 - 56);
            if (v11 < a2)
            {
              v58 = 0;
              v56 = 0uLL;
              v57 = 0uLL;
              *(_OWORD *)v55 = 0uLL;
              v12 = *v7;
              v13 = v7[1];
              v14 = v7[2];
              v58 = *((_QWORD *)v7 + 6);
              v56 = v13;
              v57 = v14;
              *(_OWORD *)v55 = v12;
              v15 = *v9;
              v16 = v9[1];
              v17 = v9[2];
              *((_QWORD *)v7 + 6) = *((_QWORD *)v9 + 6);
              v7[1] = v16;
              v7[2] = v17;
              *v7 = v15;
              v18 = *(_QWORD *)(a1 + 8) + 56 * v4;
              *(_OWORD *)v18 = *(_OWORD *)v55;
              *(_OWORD *)(v18 + 16) = v56;
              *(_OWORD *)(v18 + 32) = v57;
              *(_QWORD *)(v18 + 48) = v58;
              v6 = *(_QWORD *)(a1 + 8);
              v8 = v10;
              break;
            }
          }
          v4 = v8;
          if (*(_QWORD *)(v6 + 56 * v5) >= 2 * a2)
            break;
        }
        if (++v5 >= v4)
          goto LABEL_20;
      }
      v50 = __si_assert_copy_extra(0);
      v45 = v50;
      v46 = "";
      if (v50)
        v46 = v50;
      v47 = "!offset || AnnotatedPositionOffset_t_GET_VALUE(queue->offsets[i]) < offset * 2";
LABEL_57:
      __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 49, v47, v46);
      free(v45);
      if (__valid_fs(-1))
        v51 = 2989;
      else
        v51 = 3072;
      *(_DWORD *)v51 = -559038737;
      abort();
    }
LABEL_20:
    *(_QWORD *)(a1 + 24) = v4;
    *(_QWORD *)(a1 + 32) = v4;
    v25 = *(_QWORD *)(a1 + 40);
    v26 = v25 - v4;
    if (v25 < v4)
    {
      v52 = __si_assert_copy_extra(0);
      v45 = v52;
      v46 = "";
      if (v52)
        v46 = v52;
      v47 = "queue->top <= queue->end";
      goto LABEL_57;
    }
    if (v25 > v4)
    {
      v27 = 56 * v4 + 56;
      v28 = v26;
      do
      {
        if (!--v28)
          goto LABEL_30;
        v29 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + v27);
        v27 += 56;
      }
      while (v29 >= a2);
      v30 = __si_assert_copy_extra(0);
      v31 = v30;
      v32 = "";
      if (v30)
        v32 = v30;
      v33 = "current >= offset";
LABEL_28:
      __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 49, v33, v32);
      free(v31);
      if (__valid_fs(-1))
        v34 = 2989;
      else
        v34 = 3072;
      *(_DWORD *)v34 = -559038737;
      abort();
    }
LABEL_30:
    if (v4 >= 1)
    {
      v35 = v4;
      v36 = *(unint64_t **)(a1 + 8);
      while (1)
      {
        v37 = *v36;
        v36 += 7;
        if (v37 > a2)
          break;
        if (!--v35)
          goto LABEL_34;
      }
      v48 = __si_assert_copy_extra(0);
      v45 = v48;
      v46 = "";
      if (v48)
        v46 = v48;
      v47 = "current <= offset";
      goto LABEL_57;
    }
LABEL_34:
    parallel_qsort_AnnotatedPositionOffset_t(*(_QWORD *)(a1 + 8) + 56 * v4, v26);
    v38 = *(_QWORD *)(a1 + 40);
    if (v4 < v38)
    {
      v39 = *(_QWORD *)(a1 + 8);
      v40 = *(_QWORD *)(a1 + 32);
      v41 = *(_QWORD *)(v39 + 56 * v40);
      if (v41 < a2)
      {
LABEL_40:
        v44 = __si_assert_copy_extra(0);
        v45 = v44;
        v46 = "";
        if (v44)
          v46 = v44;
        v47 = "last >= offset";
      }
      else
      {
        v42 = (unint64_t *)(v39 + 56 * v40 + 56);
        while (1)
        {
          if (++v40 >= v38)
            goto LABEL_43;
          v43 = *v42;
          if (*v42 < v41)
            break;
          v42 += 7;
          v41 = v43;
          if (v43 < a2)
            goto LABEL_40;
        }
        v49 = __si_assert_copy_extra(0);
        v45 = v49;
        v46 = "";
        if (v49)
          v46 = v49;
        v47 = "current >= last";
      }
      goto LABEL_57;
    }
LABEL_43:
    if (*(_QWORD *)(a1 + 24) && **(_QWORD **)(a1 + 8) >= a2)
    {
      v53 = __si_assert_copy_extra(0);
      v31 = v53;
      v32 = "";
      if (v53)
        v32 = v53;
      v33 = "last < offset";
      goto LABEL_28;
    }
    ++*(_DWORD *)(a1 + 48);
    *(_QWORD *)(a1 + 56) = a2;
  }
  else
  {
    *(_QWORD *)(a1 + 56) = 0;
    ++*(_DWORD *)(a1 + 48);
    v19 = *(_QWORD *)(a1 + 24);
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 40) = v19;
    *(_QWORD *)(a1 + 24) = 0;
    parallel_qsort_AnnotatedPositionOffset_t(*(_QWORD *)(a1 + 8), v19);
  }
}

uint64_t _big_split_AnnotatedPositionOffset_t(void *a1, uint64_t a2, uint64_t a3, NSObject *a4, signed int a5)
{
  uint64_t v5;

  v5 = a2 + 1;
  if (a5 >= 3)
  {
    while (v5 < (uint64_t)((unint64_t)a5 << 13))
    {
      if (a5-- <= 3)
      {
        a5 = 2;
        return parallel_partition_AnnotatedPositionOffset_t(a1, v5, a3, a4, a5);
      }
    }
  }
  return parallel_partition_AnnotatedPositionOffset_t(a1, v5, a3, a4, a5);
}

void pqinit_ItemIteratorRef(_QWORD *a1, uint64_t a2)
{
  _QWORD *v3;

  a1[1] = a2;
  a1[2] = 1;
  if (a2)
  {
    v3 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 8 * a2 + 16, 0x6085D6BuLL);
    if (!v3)
      _log_fault_for_malloc_failure();
    *a1 = v3;
  }
  else
  {
    v3 = a1;
  }
  *v3 = 0;
}

void oqsplit(uint64_t a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _OWORD *v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  qos_class_t v24;
  NSObject *global_queue;
  signed int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  char *v33;
  const char *v34;
  const char *v35;
  uint64_t *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  _QWORD *v43;
  unint64_t v44;
  char *v45;
  char *v46;
  const char *v47;
  const char *v48;
  uint64_t v49;
  uint64_t v50;
  void *v51;
  qos_class_t v52;
  NSObject *v53;
  signed int v54;
  uint64_t v55;
  unint64_t v56;
  char *v57;
  const char *v58;
  const char *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  unint64_t v65;
  uint64_t v66;
  unint64_t v67;
  char *v68;
  const char *v69;
  const char *v70;
  uint64_t v71;
  uint64_t v72;
  size_t v73;
  int v74[6];
  uint64_t v75;

  v75 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)a1)
  {
    if (!a2)
    {
      *(_QWORD *)(a1 + 64) = 0;
      ++*(_DWORD *)(a1 + 56);
      v21 = *(_QWORD *)(a1 + 32);
      *(_QWORD *)(a1 + 40) = 0;
      *(_QWORD *)(a1 + 48) = v21;
      *(_QWORD *)(a1 + 32) = 0;
      parallel_qsort_offset_with_meta_t(*(_QWORD *)(a1 + 16), v21);
      return;
    }
    v4 = *(_QWORD *)(a1 + 32);
    *(_QWORD *)(a1 + 48) = v4;
    if (v4 >= 100000)
    {
      v22 = v4 - 1;
      v23 = *(void **)(a1 + 16);
      v24 = qos_class_self();
      global_queue = dispatch_get_global_queue(v24, 0);
      v26 = thread_count;
      if (!thread_count)
      {
        *(_QWORD *)v74 = 0x1900000006;
        v73 = 4;
        sysctl(v74, 2u, &thread_count, &v73, 0, 0);
        v26 = thread_count;
      }
      v4 = _big_split_offset_with_meta_t(v23, v22, a2, global_queue, v26);
    }
    else if (v4 >= 1)
    {
      v5 = 0;
      v6 = *(_QWORD *)(a1 + 16);
      while (1)
      {
        v7 = (_OWORD *)(v6 + 16 * v5);
        if ((*(_QWORD *)v7 & 0x3FFFFFFFFFFFFFFFuLL) >= a2)
        {
          v8 = v4 >= v5 ? v5 : v4;
          v9 = (uint64_t *)(v6 + 16 * v4 - 16);
          while (v4 > v5)
          {
            v10 = v4--;
            v11 = *v9;
            v9 -= 2;
            if ((v11 & 0x3FFFFFFFFFFFFFFFuLL) < a2)
            {
              memset(v74, 0, 16);
              *(_OWORD *)v74 = *v7;
              *v7 = *(_OWORD *)(v6 + 16 * v4);
              *(_OWORD *)(*(_QWORD *)(a1 + 16) + 16 * v4) = *(_OWORD *)v74;
              v6 = *(_QWORD *)(a1 + 16);
              v8 = v10;
              break;
            }
          }
          v4 = v8;
          if ((*(_QWORD *)(v6 + 16 * v5) & 0x3FFFFFFFFFFFFFFFuLL) >= 2 * a2)
            break;
        }
        if (++v5 >= v4)
          goto LABEL_35;
      }
      v32 = __si_assert_copy_extra_268();
      v33 = v32;
      v34 = "";
      if (v32)
        v34 = v32;
      v35 = "!offset || offset_with_meta_t_GET_VALUE(queue->offsets[i]) < offset * 2";
      goto LABEL_113;
    }
LABEL_35:
    *(_QWORD *)(a1 + 32) = v4;
    *(_QWORD *)(a1 + 40) = v4;
    v27 = *(_QWORD *)(a1 + 48);
    v28 = v27 - v4;
    if (v27 < v4)
    {
      v45 = __si_assert_copy_extra_268();
      v46 = v45;
      v47 = "";
      if (v45)
        v47 = v45;
      v48 = "queue->top <= queue->end";
      goto LABEL_98;
    }
    if (v27 > v4)
    {
      v29 = 16 * v4 + 16;
      v30 = v27 - v4;
      do
      {
        if (!--v30)
          goto LABEL_43;
        v31 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + v29);
        v29 += 16;
      }
      while ((v31 & 0x3FFFFFFFFFFFFFFFuLL) >= a2);
      v32 = __si_assert_copy_extra_268();
      v33 = v32;
      v34 = "";
      if (v32)
        v34 = v32;
      v35 = "current >= offset";
      goto LABEL_113;
    }
LABEL_43:
    if (v4 >= 1)
    {
      v36 = *(uint64_t **)(a1 + 16);
      v37 = v4;
      while (1)
      {
        v38 = *v36;
        v36 += 2;
        if ((v38 & 0x3FFFFFFFFFFFFFFFuLL) > a2)
          break;
        if (!--v37)
          goto LABEL_47;
      }
      v32 = __si_assert_copy_extra_268();
      v33 = v32;
      v34 = "";
      if (v32)
        v34 = v32;
      v35 = "current <= offset";
LABEL_113:
      __message_assert(v32, "OQueue.c", 13, v35, v34);
      goto LABEL_118;
    }
LABEL_47:
    parallel_qsort_offset_with_meta_t(*(_QWORD *)(a1 + 16) + 16 * v4, v28);
    v39 = *(_QWORD *)(a1 + 48);
    if (v4 < v39)
    {
      v40 = *(_QWORD *)(a1 + 16);
      v41 = *(_QWORD *)(a1 + 40);
      v42 = *(_QWORD *)(v40 + 16 * v41) & 0x3FFFFFFFFFFFFFFFLL;
      if (v42 < a2)
      {
LABEL_53:
        v45 = __si_assert_copy_extra_268();
        v46 = v45;
        v47 = "";
        if (v45)
          v47 = v45;
        v48 = "last >= offset";
      }
      else
      {
        v43 = (_QWORD *)(v40 + 16 * v41 + 16);
        while (1)
        {
          if (++v41 >= v39)
            goto LABEL_56;
          v44 = *v43 & 0x3FFFFFFFFFFFFFFFLL;
          if (v44 < v42)
            break;
          v43 += 2;
          v42 = v44;
          if (v44 < a2)
            goto LABEL_53;
        }
        v45 = __si_assert_copy_extra_268();
        v46 = v45;
        v47 = "";
        if (v45)
          v47 = v45;
        v48 = "current >= last";
      }
      goto LABEL_98;
    }
LABEL_56:
    if (*(_QWORD *)(a1 + 32) && (**(_QWORD **)(a1 + 16) & 0x3FFFFFFFFFFFFFFFuLL) >= a2)
    {
      v45 = __si_assert_copy_extra_268();
      v46 = v45;
      v47 = "";
      if (v45)
        v47 = v45;
      v48 = "last < offset";
LABEL_98:
      __message_assert(v45, "OQueue.c", 13, v48, v47);
      goto LABEL_106;
    }
    goto LABEL_91;
  }
  if (!a2)
  {
    *(_QWORD *)(a1 + 64) = 0;
    ++*(_DWORD *)(a1 + 56);
    v49 = *(_QWORD *)(a1 + 32);
    *(_QWORD *)(a1 + 40) = 0;
    *(_QWORD *)(a1 + 48) = v49;
    *(_QWORD *)(a1 + 32) = 0;
    parallel_qsort_offset_t(*(_QWORD *)(a1 + 16), v49);
    return;
  }
  v12 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 48) = v12;
  if (v12 >= 100000)
  {
    v50 = v12 - 1;
    v51 = *(void **)(a1 + 16);
    v52 = qos_class_self();
    v53 = dispatch_get_global_queue(v52, 0);
    v54 = thread_count;
    if (!thread_count)
    {
      *(_QWORD *)v74 = 0x1900000006;
      v73 = 4;
      sysctl(v74, 2u, &thread_count, &v73, 0, 0);
      v54 = thread_count;
    }
    v15 = _big_split_offset_t(v51, v50, a2, v53, v54);
    v12 = *(_QWORD *)(a1 + 48);
LABEL_65:
    *(_QWORD *)(a1 + 32) = v15;
    *(_QWORD *)(a1 + 40) = v15;
    if (v15 > v12)
    {
      v68 = __si_assert_copy_extra_268();
      v33 = v68;
      v69 = "";
      if (v68)
        v69 = v68;
      v70 = "queue->top <= queue->end";
      goto LABEL_117;
    }
    if (v15 < v12)
    {
      v55 = v15 + 1;
      do
      {
        if (v12 == v55)
          goto LABEL_73;
        v56 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8 * v55++) & 0x3FFFFFFFFFFFFFFFLL;
      }
      while (v56 >= a2);
      v57 = __si_assert_copy_extra_268();
      v46 = v57;
      v58 = "";
      if (v57)
        v58 = v57;
      v59 = "current >= offset";
      goto LABEL_105;
    }
LABEL_73:
    if (v15 > 0)
    {
      v60 = 0;
      v61 = *(_QWORD *)(a1 + 16);
      while ((*(_QWORD *)(v61 + 8 * v60) & 0x3FFFFFFFFFFFFFFFuLL) <= a2)
      {
        if (v15 == ++v60)
          goto LABEL_80;
      }
      v68 = __si_assert_copy_extra_268();
      v33 = v68;
      v69 = "";
      if (v68)
        v69 = v68;
      v70 = "current <= offset";
      goto LABEL_117;
    }
  }
  else
  {
    if (v12 > 0)
    {
      v13 = 0;
      v14 = *(_QWORD *)(a1 + 16);
      v15 = v12;
      while (1)
      {
        v16 = *(_QWORD *)(v14 + 8 * v13);
        v17 = v16 & 0x3FFFFFFFFFFFFFFFLL;
        if ((v16 & 0x3FFFFFFFFFFFFFFFuLL) >= a2)
        {
          v18 = v15 >= v13 ? v13 : v15;
          while (v15 > v13)
          {
            v19 = v15--;
            v20 = *(_QWORD *)(v14 - 8 + 8 * v19);
            if ((v20 & 0x3FFFFFFFFFFFFFFFuLL) < a2)
            {
              *(_QWORD *)(v14 + 8 * v13) = v20;
              *(_QWORD *)(v14 + 8 * v15) = v16;
              v17 = *(_QWORD *)(v14 + 8 * v13) & 0x3FFFFFFFFFFFFFFFLL;
              v18 = v19;
              break;
            }
          }
          v15 = v18;
          if (v17 >= 2 * a2)
            break;
        }
        if (++v13 >= v15)
          goto LABEL_65;
      }
      v68 = __si_assert_copy_extra_268();
      v33 = v68;
      v69 = "";
      if (v68)
        v69 = v68;
      v70 = "!offset || offset_t_GET_VALUE(queue->offsets[i]) < offset * 2";
      goto LABEL_117;
    }
    *(_QWORD *)(a1 + 40) = v12;
    v15 = v12;
  }
  v61 = *(_QWORD *)(a1 + 16);
LABEL_80:
  parallel_qsort_offset_t(v61 + 8 * v15, v12 - v15);
  v62 = *(_QWORD *)(a1 + 48);
  if (v15 < v62)
  {
    v63 = *(_QWORD *)(a1 + 16);
    v64 = *(_QWORD *)(a1 + 40);
    v65 = *(_QWORD *)(v63 + 8 * v64) & 0x3FFFFFFFFFFFFFFFLL;
    if (v65 < a2)
    {
LABEL_86:
      v57 = __si_assert_copy_extra_268();
      v46 = v57;
      v58 = "";
      if (v57)
        v58 = v57;
      v59 = "last >= offset";
    }
    else
    {
      v66 = v64 + 1;
      while (1)
      {
        if (v66 >= v62)
          goto LABEL_89;
        v67 = *(_QWORD *)(v63 + 8 * v66) & 0x3FFFFFFFFFFFFFFFLL;
        if (v67 < v65)
          break;
        ++v66;
        v65 = v67;
        if (v67 < a2)
          goto LABEL_86;
      }
      v57 = __si_assert_copy_extra_268();
      v46 = v57;
      v58 = "";
      if (v57)
        v58 = v57;
      v59 = "current >= last";
    }
LABEL_105:
    __message_assert(v57, "OQueue.c", 14, v59, v58);
LABEL_106:
    free(v46);
    if (__valid_fs(-1))
      v71 = 2989;
    else
      v71 = 3072;
    *(_DWORD *)v71 = -559038737;
    abort();
  }
LABEL_89:
  if (*(_QWORD *)(a1 + 32) && (**(_QWORD **)(a1 + 16) & 0x3FFFFFFFFFFFFFFFuLL) >= a2)
  {
    v68 = __si_assert_copy_extra_268();
    v33 = v68;
    v69 = "";
    if (v68)
      v69 = v68;
    v70 = "last < offset";
LABEL_117:
    __message_assert(v68, "OQueue.c", 14, v70, v69);
LABEL_118:
    free(v33);
    if (__valid_fs(-1))
      v72 = 2989;
    else
      v72 = 3072;
    *(_DWORD *)v72 = -559038737;
    abort();
  }
LABEL_91:
  ++*(_DWORD *)(a1 + 56);
  *(_QWORD *)(a1 + 64) = a2;
}

double pq_force_meta(uint64_t a1)
{
  double result;
  char *v3;
  char *v4;
  const char *v5;
  uint64_t v6;

  if (!*(_BYTE *)a1)
  {
    if (*(_QWORD *)(a1 + 24) != 1)
    {
      v3 = __si_assert_copy_extra(0);
      v4 = v3;
      v5 = "";
      if (v3)
        v5 = v3;
      __message_assert("%s:%u: failed assertion '%s' %s ", "PQueue.h", 250, "pqcount(pqueue) == 0", v5);
      free(v4);
      if (__valid_fs(-1))
        v6 = 2989;
      else
        v6 = 3072;
      *(_DWORD *)v6 = -559038737;
      abort();
    }
    free(*(void **)(a1 + 8));
    *(_BYTE *)a1 = 1;
    result = 0.0;
    *(_OWORD *)(a1 + 16) = xmmword_1B8631BB0;
    *(_QWORD *)(a1 + 8) = 0;
  }
  return result;
}

__n128 pqpush_with_meta(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  void *v10;
  size_t v11;
  _QWORD *v12;
  __n128 result;
  _QWORD *v14;
  _QWORD *v15;
  uint64_t v16;
  __n128 *v17;
  __n128 *v18;
  BOOL v19;
  char *v20;
  char *v21;
  const char *v22;
  uint64_t v23;
  char *v24;
  char *v25;
  const char *v26;

  if (!*(_BYTE *)a1)
  {
    v20 = __si_assert_copy_extra(0);
    v21 = v20;
    v22 = "";
    if (v20)
      v22 = v20;
    __message_assert("%s:%u: failed assertion '%s' %s ", "PQueue.h", 265, "pqueue->has_meta", v22);
    free(v21);
    if (__valid_fs(-1))
    {
      v23 = 2989;
      goto LABEL_25;
    }
    goto LABEL_24;
  }
  if (!a2)
  {
    v24 = __si_assert_copy_extra(0);
    v25 = v24;
    v26 = "";
    if (v24)
      v26 = v24;
    __message_assert("%s:%u: failed assertion '%s' %s ", "PQueue.h", 266, "owm.offset", v26);
    free(v25);
    if (__valid_fs(-1))
    {
      v23 = 2986;
      goto LABEL_25;
    }
LABEL_24:
    v23 = 3072;
LABEL_25:
    *(_DWORD *)v23 = -559038737;
    abort();
  }
  v6 = *(_QWORD *)(a1 + 16);
  v7 = *(_QWORD *)(a1 + 24);
  v8 = v7;
  if ((uint64_t)(v7 + 2) >= v6)
  {
    v9 = 2 * v6;
    if (v6 < 4)
      v9 = 4;
    *(_QWORD *)(a1 + 16) = v9;
    v10 = *(void **)(a1 + 8);
    v11 = 16 * v9 + 32;
    if (v10)
      v12 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, v10, v11, 0xECA6AA46uLL);
    else
      v12 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v11, 0x8DDAA030uLL);
    v14 = v12;
    if (!v12)
      _log_fault_for_malloc_failure();
    *(_QWORD *)(a1 + 8) = v14;
    *v14 = 0;
    v14[1] = 0;
    v8 = *(_QWORD *)(a1 + 24);
  }
  *(_QWORD *)(a1 + 24) = v8 + 1;
  v15 = (_QWORD *)(*(_QWORD *)(a1 + 8) + 16 * v7);
  *v15 = a2;
  v15[1] = a3;
  if ((uint64_t)v7 >= 2)
  {
    do
    {
      v16 = *(_QWORD *)(a1 + 8);
      v17 = (__n128 *)(v16 + 16 * v7);
      v18 = (__n128 *)(v16 + 16 * (v7 >> 1));
      if ((v17->n128_u64[0] & 0x3FFFFFFFFFFFFFFFLL) > (v18->n128_u64[0] & 0x3FFFFFFFFFFFFFFFLL))
        break;
      result = *v17;
      *v17 = *v18;
      *(__n128 *)(*(_QWORD *)(a1 + 8) + 16 * (v7 >> 1)) = result;
      v19 = v7 > 3;
      v7 >>= 1;
    }
    while (v19);
  }
  return result;
}

void pqpush(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  BOOL v9;
  uint64_t v10;
  size_t v11;
  _QWORD *v12;
  uint64_t v13;
  char *v14;
  char *v15;
  const char *v16;
  uint64_t v17;

  if (*(_BYTE *)a1)
  {
    v14 = __si_assert_copy_extra(0);
    v15 = v14;
    v16 = "";
    if (v14)
      v16 = v14;
    __message_assert("%s:%u: failed assertion '%s' %s ", "PQueue.h", 259, "!pqueue->has_meta", v16);
    free(v15);
    if (__valid_fs(-1))
      v17 = 2989;
    else
      v17 = 3072;
    *(_DWORD *)v17 = -559038737;
    abort();
  }
  v4 = *(_QWORD *)(a1 + 16);
  v5 = *(_QWORD *)(a1 + 24);
  v6 = *(_QWORD **)(a1 + 8);
  if ((uint64_t)(v5 + 2) >= v4)
  {
    v8 = 2 * v4;
    v9 = v4 < 4;
    v10 = 4;
    if (!v9)
      v10 = v8;
    *(_QWORD *)(a1 + 16) = v10;
    v11 = 8 * v10 + 16;
    if (v6)
      v12 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, v6, v11, 0xECA6AA46uLL);
    else
      v12 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v11, 0x8DDAA030uLL);
    v6 = v12;
    if (!v12)
      _log_fault_for_malloc_failure();
    *(_QWORD *)(a1 + 8) = v6;
    *v6 = 0;
    v7 = *(_QWORD *)(a1 + 24);
  }
  else
  {
    v7 = *(_QWORD *)(a1 + 24);
  }
  *(_QWORD *)(a1 + 24) = v7 + 1;
  v6[v5] = a2;
  if ((uint64_t)v5 >= 2)
  {
    do
    {
      v13 = v6[v5 >> 1];
      if ((a2 & 0x3FFFFFFFFFFFFFFFuLL) > (v13 & 0x3FFFFFFFFFFFFFFFuLL))
        break;
      v6[v5] = v13;
      v6[v5 >> 1] = a2;
      v9 = v5 > 3;
      v5 >>= 1;
    }
    while (v9);
  }
}

void oqpush_with_meta(uint64_t a1, uint64_t a2, size_t size)
{
  uint64_t v6;
  char *v7;
  char *v8;
  const char *v9;
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  size_t v14;
  void *v15;
  void *v16;
  uint64_t v17;
  _QWORD *v18;
  char *v19;
  const char *v20;
  char *v21;
  uint64_t v22;

  if (!*(_BYTE *)a1)
  {
    v19 = __si_assert_copy_extra(0);
    v8 = v19;
    v20 = "";
    if (v19)
      v20 = v19;
    __message_assert("%s:%u: failed assertion '%s' %s ", "OQueue.h", 333, "oqueue->has_meta", v20);
LABEL_25:
    free(v8);
    if (__valid_fs(-1))
      v22 = 2989;
    else
      v22 = 3072;
    *(_DWORD *)v22 = -559038737;
    abort();
  }
  if (*(_DWORD *)(a1 + 56))
  {
    if (*(_QWORD *)(a1 + 64) < (a2 & 0x3FFFFFFFFFFFFFFFuLL))
    {
      v21 = __si_assert_copy_extra(0);
      v8 = v21;
      v9 = "";
      if (v21)
        v9 = v21;
      v10 = "!queue->split || queue->splitPoint >= offset_with_meta_t_GET_VALUE(value)";
      goto LABEL_24;
    }
    v6 = *(_QWORD *)(a1 + 32);
    if (v6 >= *(_QWORD *)(a1 + 24))
    {
      v7 = __si_assert_copy_extra(0);
      v8 = v7;
      v9 = "";
      if (v7)
        v9 = v7;
      v10 = "!queue->split";
LABEL_24:
      __message_assert("%s:%u: failed assertion '%s' %s ", "OQueue.h", 245, v10, v9);
      goto LABEL_25;
    }
  }
  else
  {
    v11 = *(_QWORD *)(a1 + 24);
    v6 = *(_QWORD *)(a1 + 32);
    if (v6 >= v11)
    {
      v12 = 2 * v11;
      if (!v11)
        v12 = 4;
      *(_QWORD *)(a1 + 24) = v12;
      v13 = *(void **)(a1 + 16);
      v14 = 16 * v12;
      if (v13)
        v15 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, v13, v14, 0xECA6AA46uLL);
      else
        v15 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v14, 0x8DDAA030uLL);
      v16 = v15;
      if (!v15)
        _log_fault_for_malloc_failure();
      *(_QWORD *)(a1 + 16) = v16;
      v6 = *(_QWORD *)(a1 + 32);
    }
  }
  v17 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 32) = v6 + 1;
  v18 = (_QWORD *)(v17 + 16 * v6);
  *v18 = a2;
  v18[1] = size;
}

void oqpush_9141(_BYTE *a1, uint64_t a2, size_t a3)
{
  char *v3;
  char *v4;
  const char *v5;
  uint64_t v6;

  if (*a1)
  {
    v3 = __si_assert_copy_extra(0);
    v4 = v3;
    v5 = "";
    if (v3)
      v5 = v3;
    __message_assert("%s:%u: failed assertion '%s' %s ", "OQueue.h", 327, "!oqueue->has_meta", v5);
    free(v4);
    if (__valid_fs(-1))
      v6 = 2989;
    else
      v6 = 3072;
    *(_DWORD *)v6 = -559038737;
    abort();
  }
  oqpush_offset_t((uint64_t)(a1 + 8), a2, a3);
}

uint64_t pqpop(uint64_t a1, _BYTE *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t result;
  __int128 v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int8x16_t v15;
  int8x16_t v16;
  unint64_t v17;
  unint64_t v18;
  int32x2_t v19;
  int64x2_t v20;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t v44;

  *a2 = *(_BYTE *)a1;
  if (*(_BYTE *)a1)
  {
    v3 = *(_QWORD *)(a1 + 24);
    if (v3 != 1)
    {
      v4 = *(_QWORD *)(a1 + 8);
      result = *(_QWORD *)(v4 + 16);
      v6 = *(_OWORD *)(v4 + 16 * v3 - 16);
      *(_OWORD *)(v4 + 16) = v6;
      v8 = *(_QWORD *)(a1 + 16);
      v7 = *(_QWORD *)(a1 + 24);
      *(_QWORD *)(a1 + 24) = v7 - 1;
      v9 = v8 >> 1;
      v10 = v6 & 0x3FFFFFFFFFFFFFFFLL;
      v11 = 3;
      v12 = 2;
      v13 = 1;
      while (1)
      {
        v14 = *(_QWORD *)(a1 + 8);
        v15 = *(int8x16_t *)(v14 + 16 * v12);
        if (v11 >= v7)
        {
          v16 = (int8x16_t)xmmword_1B8631FE0;
          if (v12 >= v7)
            return result;
        }
        else
        {
          v16 = *(int8x16_t *)(v14 + 16 * v11);
        }
        v17 = v15.i64[0] & 0x3FFFFFFFFFFFFFFFLL;
        v18 = v16.i64[0] & 0x3FFFFFFFFFFFFFFFLL;
        if ((v15.i64[0] & 0x3FFFFFFFFFFFFFFFuLL) >= v10)
        {
          if (v18 >= v10)
          {
            _X8 = v14 + 32 * v13;
            __asm { PRFM            #1, [X8] }
            return result;
          }
        }
        else
        {
          v19 = vdup_n_s32(v18 < v17);
          v20.i64[0] = v19.u32[0];
          v20.i64[1] = v19.u32[1];
          v16 = vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v20, 0x3FuLL)), v16, v15);
          if (v18 >= v17)
            v11 = v12;
        }
        _X15 = v14 + 32 * v11;
        __asm { PRFM            #1, [X15] }
        if (v11 != v13)
        {
          v12 = 2 * v11;
          *(_OWORD *)(v14 + 16 * v11) = v6;
          *(int8x16_t *)(*(_QWORD *)(a1 + 8) + 16 * v13) = v16;
          v13 = v11;
          _VF = __OFSUB__(v11, v9);
          _NF = v11 - v9 < 0;
          v11 = (2 * v11) | 1;
          if (_NF != _VF)
            continue;
        }
        return result;
      }
    }
    return 0;
  }
  v29 = *(_QWORD *)(a1 + 24);
  v30 = v29 - 1;
  if (v29 == 1)
    return 0;
  v31 = *(_QWORD *)(a1 + 8);
  result = *(_QWORD *)(v31 + 8);
  v32 = *(_QWORD *)(v31 + 8 * v30);
  v33 = *(uint64_t *)(a1 + 16) >> 1;
  *(_QWORD *)(v31 + 8) = v32;
  *(_QWORD *)(a1 + 24) = v30;
  v34 = v32 & 0x3FFFFFFFFFFFFFFFLL;
  v35 = 3;
  v36 = 2;
  v37 = 1;
  do
  {
    v38 = *(_QWORD *)(v31 + 8 * v36);
    if (v35 >= v29)
    {
      if (v36 >= v29)
        return result;
      v39 = 0xBFFFFFFFFFFFFFFFLL;
    }
    else
    {
      v39 = *(_QWORD *)(v31 + 8 * v35);
    }
    v40 = v38 & 0x3FFFFFFFFFFFFFFFLL;
    if ((v39 & 0x3FFFFFFFFFFFFFFFLL) >= v34)
      v41 = v32;
    else
      v41 = v39;
    if ((v39 & 0x3FFFFFFFFFFFFFFFLL) >= v34)
      v42 = v37;
    else
      v42 = v35;
    if ((v39 & 0x3FFFFFFFFFFFFFFFLL) < v40)
    {
      v38 = v39;
      v36 = v35;
    }
    if (v40 < v34)
      v43 = v38;
    else
      v43 = v41;
    if (v40 < v34)
      v44 = v36;
    else
      v44 = v42;
    _X14 = v31 + 16 * v44;
    __asm { PRFM            #1, [X14] }
    if (v44 == v37)
      break;
    v36 = 2 * v44;
    v35 = (2 * v44) | 1;
    *(_QWORD *)(v31 + 8 * v44) = v32;
    *(_QWORD *)(v31 + 8 * v37) = v43;
    v37 = v44;
  }
  while (v44 < v33);
  return result;
}

uint64_t oqpop(uint64_t a1, _BYTE *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;

  *a2 = *(_BYTE *)a1;
  v2 = *(_QWORD *)(a1 + 40);
  v3 = *(_QWORD *)(a1 + 48);
  if (*(_BYTE *)a1)
  {
    if (v2 < v3)
    {
      v4 = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 40) = v2 + 1;
      return *(_QWORD *)(v4 + 16 * v2);
    }
  }
  else if (v2 < v3)
  {
    v6 = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 40) = v2 + 1;
    return *(_QWORD *)(v6 + 8 * v2);
  }
  return 0;
}

uint64_t checkAgainstUpdatesBulkReversed(uint64_t result, uint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  int v11;
  char *v12;
  char *v13;
  const char *v14;
  uint64_t v15;

  if (!a2)
  {
    v12 = __si_assert_copy_extra(0);
    v13 = v12;
    v14 = "";
    if (v12)
      v14 = v12;
    __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 209, "range.location > 0", v14);
    free(v13);
    if (__valid_fs(-1))
      v15 = 2989;
    else
      v15 = 3072;
    *(_DWORD *)v15 = -559038737;
    abort();
  }
  v4 = a3;
  if (a3)
  {
    v6 = result;
    v7 = 0;
    v8 = result + 128;
    v9 = a2 + a3 - 1;
    do
    {
      v10 = v7 >> 3;
      v11 = 1 << (v7 & 7);
      if ((v11 & *(_BYTE *)(a4 + v10)) != 0)
      {
        result = checkAgainstChangeHolder(v8, *(_QWORD *)(v6 + 112) + v9);
        if ((_DWORD)result)
          *(_BYTE *)(a4 + v10) &= ~(_BYTE)v11;
      }
      ++v7;
      --v9;
    }
    while (v4 != v7);
  }
  return result;
}

BOOL PayloadIterate__Positions(unsigned __int8 *a1, char **a2)
{
  char *v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  size_t v14;
  unint64_t v15;
  BOOL v16;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  BOOL v24;
  int8x8_t v25;
  unint64_t v26;
  unsigned int *v27;
  int8x8_t v28;
  uint64_t v29;
  int v30;
  unsigned int v31;
  uint64_t v32;
  int v33;
  int v34;
  unsigned int *v35;
  char *v36;
  char *v37;
  const char *v38;
  uint64_t v39;
  int v40;
  char v41;
  unsigned int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  char *v51;
  BOOL v52;
  const void *v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  unint64_t v58;
  uint64_t v59;
  uint64_t v60;
  const void *v61;
  uint64_t v62;
  unint64_t v63;
  unint64_t v64;
  unint64_t v65;
  unint64_t *v66;
  unint64_t *v67;
  unint64_t v68;
  unint64_t v69;
  uint64_t v70;
  unint64_t v71;
  unint64_t v72;
  uint64_t v73;
  void *v74;
  size_t v75;
  _QWORD *v76;
  char *v77;
  const char *v78;
  unint64_t v79;
  char *v80;
  unint64_t v81;
  BOOL v83;
  uint64_t v84;
  char *v85;
  const char *v86;
  unint64_t v88;
  unint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  unint64_t v93;
  unint64_t v94;
  uint64_t v95;
  void *v96;
  size_t v97;
  _QWORD *v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  void *v102;
  size_t v103;
  void *v104;
  uint64_t v105;
  uint64_t v106;
  void *v107;
  size_t v108;
  void *v109;
  _QWORD *v110;
  uint64_t v111;
  uint64_t v112;
  _QWORD *v113;
  _QWORD *v114;
  uint64_t v115;
  __int128 v116;
  uint64_t v117;
  uint64_t v118;
  _QWORD *v119;
  unint64_t *v120;
  uint64_t v121;
  _QWORD *v122;
  _QWORD *v123;
  __int128 v124;
  unint64_t v125;
  void *v126;
  uint64_t v127;
  uint64_t v128;
  void *v129;
  uint64_t v130;
  unint64_t *v131;
  unint64_t v132;
  char *v133;
  char *v134;
  const char *v135;
  char *v136;
  const char *v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  char *v141;
  uint64_t v142;
  int v143;
  NSObject *v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  char *v148;
  const char *v149;
  char *v150;
  const char *v151;
  char *v152;
  char *v153;
  const char *v154;
  char *v155;
  const char *v156;
  char *v157;
  const char *v158;
  char *v159;
  const char *v160;
  char *v161;
  unint64_t v162;
  uint64_t v163;
  unint64_t v164[2];
  uint64_t v165[7];
  uint8_t buf[24];
  uint64_t v167;
  uint64_t v168;

  v168 = *MEMORY[0x1E0C80C00];
  v4 = a2[6];
  v5 = *a1;
  if (*a1)
    v6 = *((unsigned int *)a1 + 4);
  else
    v6 = 0;
  v7 = *a2;
  if (!a1[81])
  {
    if (*((_QWORD *)v4 + 3) >> 1 >= *((_QWORD *)v4 + 4))
      v8 = *((_QWORD *)v4 + 3) >> 1;
    else
      v8 = 0;
    *((_QWORD *)a1 + 3) = v8;
    a1[81] = 1;
    if (v8)
    {
      v9 = (uint64_t)(a1 + 120);
LABEL_10:
      oqsplit_PositionOffset_t(v9, v8);
      goto LABEL_13;
    }
    if (!a1[80])
    {
      v9 = (uint64_t)(a1 + 120);
      v8 = 0;
      goto LABEL_10;
    }
    *((_QWORD *)a1 + 23) = 0;
    ++*((_DWORD *)a1 + 44);
    v10 = *((_QWORD *)a1 + 19);
    *((_QWORD *)a1 + 20) = 0;
    *((_QWORD *)a1 + 21) = v10;
    *((_QWORD *)a1 + 19) = 0;
  }
LABEL_13:
  v11 = *((_QWORD *)a1 + 1);
  v12 = v11 & 0x3FFFFFFFFFFFFFFFLL;
  if ((v11 & 0x3FFFFFFFFFFFFFFFLL) != 0)
  {
    if (!*((_QWORD *)a1 + 12))
    {
      v133 = __si_assert_copy_extra(0);
LABEL_239:
      __message_assert("%s:%u: failed assertion '%s' %s ");
      goto LABEL_240;
    }
    v13 = (unint64_t)a2[2];
    v14 = (size_t)a2[7];
    v15 = v14 + v13;
    v16 = v12 >= v13 && v15 > v12;
    if (!v16 || v12 + 30 > v15)
    {
      a2[2] = (char *)(v11 & 0x3FFFFFFFFFFFF000);
      v18 = fd_pread(*((_DWORD **)v4 + 560), v7, v14, v11 & 0x3FFFFFFFFFFFF000);
      *((_DWORD *)a2 + 16) = 0;
      if (v18 == -1)
        return 0;
      v13 = (unint64_t)a2[2];
    }
    else
    {
      ++*((_DWORD *)a2 + 16);
    }
    v20 = 0;
    v21 = 0;
    v22 = v12 - v13;
    do
    {
      v23 = v22++;
      v21 |= (unint64_t)(v7[v23] & 0x7F) << v20;
      if ((v7[v23] & 0x80) == 0)
        break;
      v24 = v20 == 63;
      v20 += 7;
    }
    while (!v24);
    v165[0] = v22;
    if ((v21 & 1) == 0)
    {
      memset(v164, 0, 12);
      unpackPosting((uint64_t)v7, v165, (uint64_t)v164);
      v26 = *(unint64_t *)((char *)v164 + 4);
      if (*(unint64_t *)((char *)v164 + 4))
      {
        v27 = (unsigned int *)*((_QWORD *)a1 + 11);
        *(_DWORD *)buf = -1;
        if (_CIIndexSetAddIndex(v27, HIDWORD(v164[0]), 0, buf, v25))
        {
          if (v26 <= *((unsigned int *)a2 + 10))
          {
            if (v26 < *((unsigned int *)a2 + 11))
              *((_DWORD *)a2 + 11) = v26;
          }
          else
          {
            *((_DWORD *)a2 + 10) = v26;
          }
        }
        if (dword_1EF19FCB4 >= 5)
        {
          v143 = *__error();
          v144 = _SILogForLogForCategory(10);
          if (os_log_type_enabled(v144, OS_LOG_TYPE_DEFAULT))
          {
            v145 = *((_QWORD *)a1 + 12);
            *(_DWORD *)buf = 134218240;
            *(_QWORD *)&buf[4] = v26;
            *(_WORD *)&buf[12] = 2048;
            *(_QWORD *)&buf[14] = v145;
            _os_log_impl(&dword_1B8270000, v144, OS_LOG_TYPE_DEFAULT, "Adding %llu to %p", buf, 0x16u);
          }
          *__error() = v143;
        }
        v35 = (unsigned int *)*((_QWORD *)a1 + 12);
        *(_DWORD *)buf = -1;
        _CIIndexSetAddIndex(v35, v26, 0, buf, v28);
      }
      v19 = *((_QWORD *)a1 + 1);
      if ((v19 & 0x3FFFFFFFFFFFFFFFLL) != v12)
      {
        v36 = __si_assert_copy_extra(0);
        v37 = v36;
        v38 = "";
        if (v36)
          v38 = v36;
        __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 1234, "((((iter->ptr.has_meta?iter->ptr.with_meta.offset:iter->ptr.just_offset) & 0x3FFFFFFFFFFFFFFF)))==next", v38);
        goto LABEL_231;
      }
LABEL_67:
      *(_QWORD *)a1 = 0;
      *((_QWORD *)a1 + 1) = 0;
      *((_QWORD *)a1 + 2) = 0;
      if (v21 < 2)
      {
        v53 = (const void *)*((_QWORD *)a1 + 12);
LABEL_73:
        CFRelease(v53);
LABEL_74:
        *((_QWORD *)a1 + 12) = 0;
        v11 = *((_QWORD *)a1 + 1);
        goto LABEL_75;
      }
      v54 = v21 >> 1;
      if (a1[80])
      {
        v141 = __si_assert_copy_extra(*((_DWORD **)a2[6] + 560));
        __message_assert("%s:%u: failed assertion '%s' %s nxtLink: %lld. compact");
      }
      else
      {
        v55 = *((_QWORD *)a1 + 12);
        if (v55)
        {
          v56 = (v21 >> 1) & 0x3FFFFFFFFFFFFFFFLL;
          if (v56 == v12)
          {
            v53 = (const void *)*((_QWORD *)a1 + 12);
            goto LABEL_73;
          }
          if (v56 > v12)
          {
            if ((_DWORD)v5)
            {
              if (!a1[192])
              {
                v148 = __si_assert_copy_extra(0);
                v37 = v148;
                v149 = "";
                if (v148)
                  v149 = v148;
                __message_assert("%s:%u: failed assertion '%s' %s ", "PQueue.h", 449, "pqueue->has_meta", v149);
                goto LABEL_231;
              }
              v70 = *((_QWORD *)a1 + 26);
              v71 = *((_QWORD *)a1 + 27);
              v72 = v71;
              if ((uint64_t)(v71 + 2) >= v70)
              {
                v73 = 2 * v70;
                if (v70 < 4)
                  v73 = 4;
                *((_QWORD *)a1 + 26) = v73;
                v74 = (void *)*((_QWORD *)a1 + 25);
                v75 = 24 * v73 + 48;
                if (v74)
                  v76 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, v74, v75, 0xECA6AA46uLL);
                else
                  v76 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v75, 0x8DDAA030uLL);
                v110 = v76;
                if (!v76)
                  _log_fault_for_malloc_failure();
                *((_QWORD *)a1 + 25) = v110;
                *v110 = 0;
                v110[1] = 0;
                v110[2] = 0;
                v72 = *((_QWORD *)a1 + 27);
              }
              *((_QWORD *)a1 + 27) = v72 + 1;
              v111 = *((_QWORD *)a1 + 25) + 24 * v71;
              *(_QWORD *)v111 = v54;
              *(_QWORD *)(v111 + 8) = v55;
              *(_DWORD *)(v111 + 20) = 0;
              if ((uint64_t)v71 >= 2)
              {
                do
                {
                  v112 = *((_QWORD *)a1 + 25);
                  v113 = (_QWORD *)(v112 + 24 * v71);
                  v114 = (_QWORD *)(v112 + 24 * (v71 >> 1));
                  if (*v113 > *v114)
                    break;
                  v115 = v113[2];
                  v116 = *(_OWORD *)v113;
                  v117 = v114[2];
                  *(_OWORD *)v113 = *(_OWORD *)v114;
                  v113[2] = v117;
                  v118 = *((_QWORD *)a1 + 25) + 24 * (v71 >> 1);
                  *(_OWORD *)v118 = v116;
                  *(_QWORD *)(v118 + 16) = v115;
                  v16 = v71 > 3;
                  v71 >>= 1;
                }
                while (v16);
              }
            }
            else
            {
              if (a1[192])
                goto LABEL_238;
              v92 = *((_QWORD *)a1 + 26);
              v93 = *((_QWORD *)a1 + 27);
              v94 = v93;
              if ((uint64_t)(v93 + 2) >= v92)
              {
                v95 = 2 * v92;
                if (v92 < 4)
                  v95 = 4;
                *((_QWORD *)a1 + 26) = v95;
                v96 = (void *)*((_QWORD *)a1 + 25);
                v97 = 16 * v95 + 32;
                if (v96)
                  v98 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, v96, v97, 0xECA6AA46uLL);
                else
                  v98 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v97, 0x8DDAA030uLL);
                v119 = v98;
                if (!v98)
                  _log_fault_for_malloc_failure();
                *((_QWORD *)a1 + 25) = v119;
                *v119 = 0;
                v119[1] = 0;
                v94 = *((_QWORD *)a1 + 27);
              }
              *((_QWORD *)a1 + 27) = v94 + 1;
              v120 = (unint64_t *)(*((_QWORD *)a1 + 25) + 16 * v93);
              *v120 = v54;
              v120[1] = v55;
              if ((uint64_t)v93 >= 2)
              {
                do
                {
                  v121 = *((_QWORD *)a1 + 25);
                  v122 = (_QWORD *)(v121 + 16 * v93);
                  v123 = (_QWORD *)(v121 + 16 * (v93 >> 1));
                  if (*v122 > *v123)
                    break;
                  v124 = *(_OWORD *)v122;
                  *(_OWORD *)v122 = *(_OWORD *)v123;
                  *(_OWORD *)(*((_QWORD *)a1 + 25) + 16 * (v93 >> 1)) = v124;
                  v16 = v93 > 3;
                  v93 >>= 1;
                }
                while (v16);
              }
            }
            v125 = (unint64_t)a2[3];
            if (v125 >= v54)
              v125 = v54;
            a2[3] = (char *)v125;
            goto LABEL_74;
          }
          v79 = *((_QWORD *)a1 + 3);
          v80 = a2[6];
          if (v79 >= *((_QWORD *)v80 + 4))
            v81 = 2 * v79;
          else
            v81 = *((_QWORD *)v80 + 4);
          v83 = v56 <= v81 && v12 > v81;
          if (v56 < v79 || v83)
          {
            if ((_DWORD)v5)
            {
              if (!a1[120])
              {
                v150 = __si_assert_copy_extra(0);
                v37 = v150;
                v151 = "";
                if (v150)
                  v151 = v150;
                __message_assert("%s:%u: failed assertion '%s' %s ", "OQueue.h", 584, "oqueue->has_meta", v151);
                goto LABEL_231;
              }
              if (*((_DWORD *)a1 + 44))
              {
                if (*((_QWORD *)a1 + 23) < v54)
                  goto LABEL_238;
                v84 = *((_QWORD *)a1 + 19);
                if (v84 >= *((_QWORD *)a1 + 18))
                {
                  v85 = __si_assert_copy_extra(0);
                  v37 = v85;
                  v86 = "";
                  if (v85)
                    v86 = v85;
                  __message_assert("%s:%u: failed assertion '%s' %s ", "OQueue.h", 504, "!queue->split", v86);
                  goto LABEL_231;
                }
              }
              else
              {
                v100 = *((_QWORD *)a1 + 18);
                v84 = *((_QWORD *)a1 + 19);
                if (v84 >= v100)
                {
                  v101 = 2 * v100;
                  if (!v100)
                    v101 = 4;
                  *((_QWORD *)a1 + 18) = v101;
                  v102 = (void *)*((_QWORD *)a1 + 17);
                  v103 = 24 * v101;
                  if (v102)
                    v104 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, v102, v103, 0xECA6AA46uLL);
                  else
                    v104 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v103, 0x8DDAA030uLL);
                  v126 = v104;
                  if (!v104)
                    _log_fault_for_malloc_failure();
                  *((_QWORD *)a1 + 17) = v126;
                  v84 = *((_QWORD *)a1 + 19);
                }
              }
              v127 = *((_QWORD *)a1 + 17);
              *((_QWORD *)a1 + 19) = v84 + 1;
              v128 = v127 + 24 * v84;
              *(_QWORD *)v128 = v54;
              *(_QWORD *)(v128 + 8) = v55;
              *(_DWORD *)(v128 + 16) = v6;
              *(_DWORD *)(v128 + 20) = 0;
            }
            else
            {
              if (a1[120])
              {
                v157 = __si_assert_copy_extra(0);
                v37 = v157;
                v158 = "";
                if (v157)
                  v158 = v157;
                __message_assert("%s:%u: failed assertion '%s' %s ", "OQueue.h", 578, "!oqueue->has_meta", v158);
                goto LABEL_231;
              }
              if (*((_DWORD *)a1 + 44))
              {
                if (*((_QWORD *)a1 + 23) < v54)
                {
                  v159 = __si_assert_copy_extra(0);
                  v37 = v159;
                  v160 = "";
                  if (v159)
                    v160 = v159;
                  __message_assert("%s:%u: failed assertion '%s' %s ", "OQueue.h", 495, "!queue->split || queue->splitPoint >= JustPositionOffset_t_GET_VALUE(value)", v160);
                  goto LABEL_231;
                }
                v99 = *((_QWORD *)a1 + 19);
                if (v99 >= *((_QWORD *)a1 + 18))
                  goto LABEL_238;
              }
              else
              {
                v105 = *((_QWORD *)a1 + 18);
                v99 = *((_QWORD *)a1 + 19);
                if (v99 >= v105)
                {
                  v106 = 2 * v105;
                  if (!v105)
                    v106 = 4;
                  *((_QWORD *)a1 + 18) = v106;
                  v107 = (void *)*((_QWORD *)a1 + 17);
                  v108 = 16 * v106;
                  if (v107)
                    v109 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, v107, v108, 0xECA6AA46uLL);
                  else
                    v109 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v108, 0x8DDAA030uLL);
                  v129 = v109;
                  if (!v109)
                    _log_fault_for_malloc_failure();
                  *((_QWORD *)a1 + 17) = v129;
                  v99 = *((_QWORD *)a1 + 19);
                }
              }
              v130 = *((_QWORD *)a1 + 17);
              *((_QWORD *)a1 + 19) = v99 + 1;
              v131 = (unint64_t *)(v130 + 16 * v99);
              *v131 = v54;
              v131[1] = v55;
            }
            if ((unint64_t)a2[4] > v54)
            {
              v132 = *((_QWORD *)a1 + 3);
              if (v56 < v132 && v56 > v132 >> 1)
                a2[4] = (char *)v56;
            }
            goto LABEL_74;
          }
          v152 = __si_assert_copy_extra(*((_DWORD **)v80 + 560));
          v153 = v152;
          v154 = "";
          if (v152)
            v154 = v152;
          __message_assert("%s:%u: failed assertion '%s' %s Unexpected value for nextLink: %lld. next=%lld barrier=%lld split=%lld", "PayloadIterator.c", 1319, "(OFFSET_GET_VALUE(nxtLink) <= barrier && next>barrier)|| (OFFSET_GET_VALUE(nxtLink)<iter->split)", v154, v54, v12, v81, *((_QWORD *)a1 + 3));
          free(v153);
          if (!__valid_fsp(*((_DWORD **)a2[6] + 560)))
            goto LABEL_277;
          goto LABEL_241;
        }
        v141 = __si_assert_copy_extra(*((_DWORD **)a2[6] + 560));
        __message_assert("%s:%u: failed assertion '%s' %s ");
      }
      free(v141);
      if (__valid_fsp(*((_DWORD **)a2[6] + 560)))
        v142 = 2989;
      else
        v142 = 3072;
      *(_DWORD *)v142 = -559038737;
      abort();
    }
    v29 = v23 + 2;
    v30 = v7[v22];
    v31 = v7[v22];
    v163 = v5;
    if (v30 < 0)
    {
      v32 = v23 + 3;
      v33 = v7[v29];
      v34 = v7[v29];
      if (v33 < 0)
      {
        v39 = v23 + 4;
        v40 = v7[v32];
        v41 = v40;
        if (v40 < 0)
        {
          v32 = v23 + 5;
          v43 = v7[v39];
          v44 = v7[v39];
          if (v43 < 0)
          {
            v46 = v7[v32];
            if (v46 < 0)
            {
              v133 = __si_assert_copy_extra(0);
              __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t");
LABEL_240:
              free(v133);
              if (!__valid_fs(-1))
              {
LABEL_277:
                v140 = 3072;
LABEL_278:
                *(_DWORD *)v140 = -559038737;
                abort();
              }
LABEL_241:
              v140 = 2989;
              goto LABEL_278;
            }
            v47 = v46;
            v32 = v23 + 6;
            v45 = ((v44 & 0x7F) << 21) | (v47 << 28) | ((v41 & 0x7F) << 14);
          }
          else
          {
            v45 = ((v41 & 0x7F) << 14) | (v44 << 21);
          }
          v42 = v45 & 0xFFFFC000 | ((v34 & 0x7F) << 7) | v31 & 0x7F;
        }
        else
        {
          v42 = ((v34 & 0x7F) << 7) | (v40 << 14) | v31 & 0x7F;
          v32 = v39;
        }
        v31 = v42;
      }
      else
      {
        v31 = v31 & 0x7F | (v34 << 7);
      }
    }
    else
    {
      v32 = v23 + 2;
    }
    v165[0] = v32;
    v164[0] = 0;
    v48 = v31;
    v49 = *((unsigned int *)a2 + 14);
    v162 = v32 + v31;
    if (v162 <= v49)
    {
      v161 = 0;
      v50 = 0;
      v51 = &v7[v32];
LABEL_58:
      *(_QWORD *)buf = a1;
      *(_QWORD *)&buf[8] = a2;
      *(_QWORD *)&buf[16] = *((_QWORD *)a1 + 12);
      v167 = -1;
      if ((_DWORD)v48)
      {
        do
        {
          if (unpackPostingChunk((uint64_t)v51, v164, v48, *((_DWORD *)a2 + 17), v163 | (v6 << 32), (void (*)(uint64_t, _QWORD, uint64_t, _QWORD, _QWORD, uint64_t))PayloadProcessDocIDRangeBitsReversed__Positions, (uint64_t)buf))v52 = v164[0] >= v48;
          else
            v52 = 1;
        }
        while (!v52);
      }
      if (v162 > v49)
      {
        free(v51);
        CICleanUpClearItem((uint64_t)v161, v50);
        CICleanUpPop((uint64_t)v161);
      }
      v19 = *((_QWORD *)a1 + 1);
      LODWORD(v5) = v163;
      if ((v19 & 0x3FFFFFFFFFFFFFFFLL) == v12)
        goto LABEL_67;
LABEL_238:
      v133 = __si_assert_copy_extra(0);
      goto LABEL_239;
    }
    v51 = (char *)malloc_type_malloc(v31 + 4, 0x54D9E43AuLL);
    if (v48 >> 28)
    {
      v139 = 5;
    }
    else if ((v48 & 0xFE00000) != 0)
    {
      v139 = 4;
    }
    else
    {
      v139 = 1;
      if ((v48 & 0x3F80) != 0)
        v139 = 2;
      if ((v48 & 0x1FC000) != 0)
        v139 = 3;
    }
    v146 = 5;
    v147 = 1;
    if ((v21 & 0x3F80) != 0)
      v147 = 2;
    if ((v21 & 0x1FC000) != 0)
      v147 = 3;
    if ((v21 & 0xFE00000) != 0)
      v147 = 4;
    if (!(v21 >> 28))
      v146 = v147;
    if (fd_pread(*((_DWORD **)v4 + 560), v51, v48, v139 + v12 + v146) != -1)
    {
      v161 = CICleanUpThreadLoc();
      v50 = CICleanUpPush((uint64_t)v161, (uint64_t)MEMORY[0x1E0C834A8], (uint64_t)v51);
      goto LABEL_58;
    }
    free(v51);
    return 0;
  }
  v19 = 0xBFFFFFFFFFFFFFFFLL;
LABEL_75:
  v57 = v11 & 0x3FFFFFFFFFFFFFFFLL;
  if (v57)
    return v57 != 0;
  v58 = v19 & 0x3FFFFFFFFFFFFFFFLL;
  while (1)
  {
    v59 = *((_QWORD *)a1 + 20);
    v60 = *((_QWORD *)a1 + 21);
    if (*((_QWORD *)a1 + 27) == 1)
    {
      if (v60 == v59)
      {
        v62 = *((_QWORD *)a1 + 1);
        goto LABEL_157;
      }
      memset(buf, 0, sizeof(buf));
      oqpop_PositionOffset_t(buf, (uint64_t)(a1 + 120), a1);
      if (*a1)
        *((_DWORD *)a1 + 4) = *(_DWORD *)&buf[16];
      v62 = *(_QWORD *)buf;
      v61 = *(const void **)&buf[8];
      *((_QWORD *)a1 + 1) = *(_QWORD *)buf;
      *((_QWORD *)a1 + 12) = v61;
      v63 = v62 & 0x3FFFFFFFFFFFFFFFLL;
      if ((v62 & 0x3FFFFFFFFFFFFFFFLL) != 0 && !v61)
        goto LABEL_238;
      if (v63 != v58)
      {
        if (v19 == 0xBFFFFFFFFFFFFFFFLL || v63 >= v58)
          goto LABEL_157;
        v77 = __si_assert_copy_extra(0);
        v37 = v77;
        v78 = "";
        if (v77)
          v78 = v77;
        __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 1433, "((((iter->ptr.has_meta?iter->ptr.with_meta.offset:iter->ptr.just_offset) & 0x3FFFFFFFFFFFFFFF))) >= (((oldPtr.has_meta?oldPtr.with_meta.offset:oldPtr.just_offset) & 0x3FFFFFFFFFFFFFFF)) || (oldPtr.has_meta?oldPtr.with_meta.offset:oldPtr.just_offset)==offset_MAX_VALUE", v78);
LABEL_231:
        free(v37);
        if (__valid_fs(-1))
          v138 = 2989;
        else
          v138 = 3072;
        *(_DWORD *)v138 = -559038737;
        abort();
      }
      goto LABEL_117;
    }
    if (v60 == v59)
    {
      memset(buf, 0, sizeof(buf));
      pqpop_PositionOffset_t((uint64_t)buf, (uint64_t)(a1 + 192), a1);
      if (*a1)
        *((_DWORD *)a1 + 4) = *(_DWORD *)&buf[16];
      v62 = *(_QWORD *)buf;
      v61 = *(const void **)&buf[8];
      *((_QWORD *)a1 + 1) = *(_QWORD *)buf;
      *((_QWORD *)a1 + 12) = v61;
      v64 = v62 & 0x3FFFFFFFFFFFFFFFLL;
      if ((v62 & 0x3FFFFFFFFFFFFFFFLL) != 0 && !v61)
        goto LABEL_238;
      if (v64 != v58)
      {
        if (v19 != 0xBFFFFFFFFFFFFFFFLL && v64 < v58)
          goto LABEL_238;
        goto LABEL_157;
      }
      goto LABEL_117;
    }
    v65 = *((_QWORD *)a1 + 25);
    if (a1[192])
    {
      if (!v65)
        goto LABEL_98;
      v66 = (unint64_t *)(v65 + 24);
    }
    else
    {
      if (!v65)
        goto LABEL_98;
      v66 = (unint64_t *)(v65 + 16);
    }
    v65 = *v66;
LABEL_98:
    if (a1[120])
    {
      if (v59 < v60)
      {
        v67 = (unint64_t *)(*((_QWORD *)a1 + 17) + 24 * v59);
LABEL_103:
        v68 = *v67;
        goto LABEL_105;
      }
    }
    else if (v59 < v60)
    {
      v67 = (unint64_t *)(*((_QWORD *)a1 + 17) + 16 * v59);
      goto LABEL_103;
    }
    v68 = 0;
LABEL_105:
    if (v65 < v68)
    {
      memset(buf, 0, sizeof(buf));
      pqpop_PositionOffset_t((uint64_t)buf, (uint64_t)(a1 + 192), a1);
      if (*a1)
        *((_DWORD *)a1 + 4) = *(_DWORD *)&buf[16];
      v62 = *(_QWORD *)buf;
      v61 = *(const void **)&buf[8];
      *((_QWORD *)a1 + 1) = *(_QWORD *)buf;
      *((_QWORD *)a1 + 12) = v61;
      if ((v62 & 0x3FFFFFFFFFFFFFFFLL) != 0 && !v61)
      {
        v134 = __si_assert_copy_extra(0);
        v37 = v134;
        v135 = "";
        if (v134)
          v135 = v134;
        __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 1371, "iter->ptr_documentsContainingTerm", v135);
        goto LABEL_231;
      }
      if (((v62 ^ v19) & 0x3FFFFFFFFFFFFFFFLL) != 0)
        goto LABEL_157;
      goto LABEL_117;
    }
    memset(buf, 0, sizeof(buf));
    oqpop_PositionOffset_t(buf, (uint64_t)(a1 + 120), a1);
    if (*a1)
      *((_DWORD *)a1 + 4) = *(_DWORD *)&buf[16];
    v62 = *(_QWORD *)buf;
    v61 = *(const void **)&buf[8];
    *((_QWORD *)a1 + 1) = *(_QWORD *)buf;
    *((_QWORD *)a1 + 12) = v61;
    v69 = v62 & 0x3FFFFFFFFFFFFFFFLL;
    if ((v62 & 0x3FFFFFFFFFFFFFFFLL) != 0 && !v61)
    {
      v136 = __si_assert_copy_extra(0);
      v37 = v136;
      v137 = "";
      if (v136)
        v137 = v136;
      __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 1396, "iter->ptr_documentsContainingTerm", v137);
      goto LABEL_231;
    }
    if (v69 != v58)
      break;
LABEL_117:
    if (v61)
    {
      instr_release(v61);
      *((_QWORD *)a1 + 12) = 0;
    }
  }
  if (v69 < v58)
  {
    v155 = __si_assert_copy_extra(0);
    v37 = v155;
    v156 = "";
    if (v155)
      v156 = v155;
    __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 1406, "((((iter->ptr.has_meta?iter->ptr.with_meta.offset:iter->ptr.just_offset) & 0x3FFFFFFFFFFFFFFF))) >= (((oldPtr.has_meta?oldPtr.with_meta.offset:oldPtr.just_offset) & 0x3FFFFFFFFFFFFFFF)) || (((oldPtr.has_meta?oldPtr.with_meta.offset:oldPtr.just_offset) & 0x3FFFFFFFFFFFFFFF))==offset_MAX_VALUE", v156);
    goto LABEL_231;
  }
LABEL_157:
  v57 = v62 & 0x3FFFFFFFFFFFFFFFLL;
  if (!v57)
  {
    v57 = *((_QWORD *)a1 + 19);
    if (v57)
    {
      v57 = *((_QWORD *)a1 + 3);
      do
      {
        v88 = v57 >> 1;
        if (v88 >= *((_QWORD *)a2[6] + 4))
          v89 = v88;
        else
          v89 = 0;
        *((_QWORD *)a1 + 3) = v89;
        oqsplit_PositionOffset_t((uint64_t)(a1 + 120), v89);
        memset(buf, 0, sizeof(buf));
        oqpop_PositionOffset_t(buf, (uint64_t)(a1 + 120), a1);
        if (*a1)
          *((_DWORD *)a1 + 4) = *(_DWORD *)&buf[16];
        v90 = *(_QWORD *)buf;
        v91 = *(_QWORD *)&buf[8];
        *((_QWORD *)a1 + 1) = *(_QWORD *)buf;
        *((_QWORD *)a1 + 12) = v91;
        v57 = v90 & 0x3FFFFFFFFFFFFFFFLL;
        if (v57)
          break;
        v57 = *((_QWORD *)a1 + 3);
      }
      while (v57);
    }
  }
  return v57 != 0;
}

uint64_t PayloadIterator__Positions_UpdateSet(uint64_t result, unsigned int *a2, size_t size, uint64_t a4, uint64_t a5, unsigned int a6, int a7, int a8, float a9)
{
  uint64_t *v16;
  uint64_t v17;
  uint64_t *v18;
  _QWORD *v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  size_t v26;
  void *v27;
  uint64_t v28;
  _OWORD *v29;
  __int128 v30;
  int8x8_t v31;
  uint64_t v32;
  unsigned int *v33;
  unsigned int v34;
  unsigned int *v35;
  unsigned int v36;
  int8x8_t v37;
  unsigned int v38;
  BOOL v39;
  char *v40;
  char *v41;
  const char *v42;
  uint64_t v43;
  char *v44;
  const char *v45;
  int v46;
  int v47;

  v16 = (uint64_t *)result;
  v17 = result + 8 * a7;
  v20 = *(uint64_t **)(v17 + 224);
  v19 = (_QWORD *)(v17 + 224);
  v18 = v20;
  if (!v20)
  {
    if (*MEMORY[0x1E0C85AD8] <= 0x1FuLL)
      ++sTotal_9165;
    result = (uint64_t)malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x20uLL, 0x31F9A007uLL);
    if (!result)
    {
      _log_fault_for_malloc_failure();
      *v19 = 0;
      v44 = __si_assert_copy_extra(0);
      v41 = v44;
      v45 = "";
      if (v44)
        v45 = v44;
      __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 961, "updateSetInfo", v45);
LABEL_34:
      free(v41);
      if (__valid_fs(-1))
        v43 = 2989;
      else
        v43 = 3072;
      *(_DWORD *)v43 = -559038737;
      abort();
    }
    v18 = (uint64_t *)result;
    *v19 = result;
  }
  v18[3] = a5;
  v21 = a4 + 32 * a6;
  if (!*(_QWORD *)(v21 + 16) && !*(_DWORD *)v21 && !*(_DWORD *)(v21 + 4))
    return result;
  v22 = v18[1];
  if (*v18 >= v22)
  {
    v23 = 2 * v22;
    v39 = v22 == 0;
    v24 = 4;
    if (!v39)
      v24 = v23;
    v18[1] = v24;
    v25 = (void *)v18[2];
    v26 = 40 * v24;
    if (v25)
      v27 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, v25, v26, 0xECA6AA46uLL);
    else
      v27 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v26, 0x8DDAA030uLL);
    v28 = (uint64_t)v27;
    if (!v27)
      _log_fault_for_malloc_failure();
    v18[2] = v28;
  }
  if (!a5 && *(_DWORD *)(v21 + 4))
  {
    v40 = __si_assert_copy_extra(0);
    v41 = v40;
    v42 = "";
    if (v40)
      v42 = v40;
    __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 973, "infoBase", v42);
    goto LABEL_34;
  }
  v29 = (_OWORD *)(v18[2] + 40 * *v18);
  v30 = *(_OWORD *)(v21 + 16);
  *v29 = *(_OWORD *)v21;
  v29[1] = v30;
  result = (uint64_t)CIIndexSetCreateWithRange(*(_DWORD *)(v16[11] + 20), *(_DWORD *)(v16[11] + 24), 1);
  v32 = *v18;
  *(_QWORD *)(v18[2] + 40 * *v18 + 32) = result;
  if (a2)
  {
    do
    {
      v33 = (unsigned int *)v16[11];
      v34 = a2[2];
      v46 = -1;
      _CIIndexSetAddIndex(v33, v34, 0, &v46, v31);
      v35 = *(unsigned int **)(v18[2] + 40 * *v18 + 32);
      v36 = a2[2];
      v47 = -1;
      result = _CIIndexSetAddIndex(v35, v36, 0, &v47, v37);
      if (a8)
        result = distanceHolderSetMinDistance(v16[9], v16[13] + a2[2], a9);
      v38 = *a2;
      a2 = (unsigned int *)(size + 12 * (*a2 >> 1));
      v39 = v38 < 2 || size == 0;
    }
    while (!v39);
    v32 = *v18;
  }
  *v18 = v32 + 1;
  return result;
}

void oqsplit_PositionOffset_t(uint64_t a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __int128 *v7;
  uint64_t v8;
  __int128 *v9;
  uint64_t v10;
  unint64_t v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _OWORD *v18;
  uint64_t v19;
  unint64_t *v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  qos_class_t v26;
  NSObject *global_queue;
  signed int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  char *v34;
  char *v35;
  const char *v36;
  const char *v37;
  unint64_t *v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  unint64_t *v45;
  unint64_t v46;
  char *v47;
  char *v48;
  const char *v49;
  const char *v50;
  uint64_t v51;
  uint64_t v52;
  void *v53;
  qos_class_t v54;
  NSObject *v55;
  signed int v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  unint64_t v61;
  char *v62;
  const char *v63;
  const char *v64;
  unint64_t *v65;
  uint64_t v66;
  unint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  unint64_t *v72;
  unint64_t v73;
  char *v74;
  const char *v75;
  const char *v76;
  uint64_t v77;
  uint64_t v78;
  size_t v79;
  int v80[4];
  uint64_t v81;
  uint64_t v82;

  v82 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)a1)
  {
    if (!a2)
    {
      *(_QWORD *)(a1 + 64) = 0;
      ++*(_DWORD *)(a1 + 56);
      v23 = *(_QWORD *)(a1 + 32);
      *(_QWORD *)(a1 + 40) = 0;
      *(_QWORD *)(a1 + 48) = v23;
      *(_QWORD *)(a1 + 32) = 0;
      parallel_qsort_PositionOffsetWithMeta_t(*(_QWORD *)(a1 + 16), v23);
      return;
    }
    v4 = *(_QWORD *)(a1 + 32);
    *(_QWORD *)(a1 + 48) = v4;
    if (v4 >= 100000)
    {
      v24 = v4 - 1;
      v25 = *(void **)(a1 + 16);
      v26 = qos_class_self();
      global_queue = dispatch_get_global_queue(v26, 0);
      v28 = thread_count;
      if (!thread_count)
      {
        *(_QWORD *)v80 = 0x1900000006;
        v79 = 4;
        sysctl(v80, 2u, &thread_count, &v79, 0, 0);
        v28 = thread_count;
      }
      v4 = _big_split_PositionOffsetWithMeta_t(v25, v24, a2, global_queue, v28);
    }
    else if (v4 >= 1)
    {
      v5 = 0;
      v6 = *(_QWORD *)(a1 + 16);
      while (1)
      {
        v7 = (__int128 *)(v6 + 24 * v5);
        if (*(_QWORD *)v7 >= a2)
        {
          v8 = v4 >= v5 ? v5 : v4;
          v9 = (__int128 *)(v6 + 24 * v4);
          while (v4 > v5)
          {
            v10 = v4--;
            v11 = *((_QWORD *)v9 - 3);
            v9 = (__int128 *)((char *)v9 - 24);
            if (v11 < a2)
            {
              memset(v80, 0, sizeof(v80));
              v81 = 0;
              v12 = *v7;
              v81 = *((_QWORD *)v7 + 2);
              *(_OWORD *)v80 = v12;
              v13 = *v9;
              *((_QWORD *)v7 + 2) = *((_QWORD *)v9 + 2);
              *v7 = v13;
              v14 = *(_QWORD *)(a1 + 16) + 24 * v4;
              *(_OWORD *)v14 = *(_OWORD *)v80;
              *(_QWORD *)(v14 + 16) = v81;
              v6 = *(_QWORD *)(a1 + 16);
              v8 = v10;
              break;
            }
          }
          v4 = v8;
          if (*(_QWORD *)(v6 + 24 * v5) >= 2 * a2)
            break;
        }
        if (++v5 >= v4)
          goto LABEL_36;
      }
      v34 = __si_assert_copy_extra_268();
      v35 = v34;
      v36 = "";
      if (v34)
        v36 = v34;
      v37 = "!offset || PositionOffsetWithMeta_t_GET_VALUE(queue->offsets[i]) < offset * 2";
      goto LABEL_111;
    }
LABEL_36:
    *(_QWORD *)(a1 + 32) = v4;
    *(_QWORD *)(a1 + 40) = v4;
    v29 = *(_QWORD *)(a1 + 48);
    v30 = v29 - v4;
    if (v29 < v4)
    {
      v34 = __si_assert_copy_extra_268();
      v35 = v34;
      v36 = "";
      if (v34)
        v36 = v34;
      v37 = "queue->top <= queue->end";
      goto LABEL_111;
    }
    if (v29 > v4)
    {
      v31 = 24 * v4 + 24;
      v32 = v30;
      do
      {
        if (!--v32)
          goto LABEL_44;
        v33 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + v31);
        v31 += 24;
      }
      while (v33 >= a2);
      v34 = __si_assert_copy_extra_268();
      v35 = v34;
      v36 = "";
      if (v34)
        v36 = v34;
      v37 = "current >= offset";
      goto LABEL_111;
    }
LABEL_44:
    if (v4 >= 1)
    {
      v38 = *(unint64_t **)(a1 + 16);
      v39 = v4;
      while (1)
      {
        v40 = *v38;
        v38 += 3;
        if (v40 > a2)
          break;
        if (!--v39)
          goto LABEL_48;
      }
      v34 = __si_assert_copy_extra_268();
      v35 = v34;
      v36 = "";
      if (v34)
        v36 = v34;
      v37 = "current <= offset";
      goto LABEL_111;
    }
LABEL_48:
    parallel_qsort_PositionOffsetWithMeta_t(*(_QWORD *)(a1 + 16) + 24 * v4, v30);
    v41 = *(_QWORD *)(a1 + 48);
    if (v4 < v41)
    {
      v42 = *(_QWORD *)(a1 + 16);
      v43 = *(_QWORD *)(a1 + 40);
      v44 = *(_QWORD *)(v42 + 24 * v43);
      if (v44 >= a2)
      {
        v45 = (unint64_t *)(v42 + 24 * v43 + 24);
        while (1)
        {
          if (++v43 >= v41)
            goto LABEL_57;
          v46 = *v45;
          if (*v45 < v44)
            break;
          v45 += 3;
          v44 = v46;
          if (v46 < a2)
          {
            v47 = __si_assert_copy_extra_268();
            v48 = v47;
            v49 = "";
            if (v47)
              v49 = v47;
            v50 = "last >= offset";
            goto LABEL_97;
          }
        }
        v47 = __si_assert_copy_extra_268();
        v48 = v47;
        v49 = "";
        if (v47)
          v49 = v47;
        v50 = "current >= last";
LABEL_97:
        __message_assert(v47, "OQueue.c", 17, v50, v49);
LABEL_98:
        free(v48);
        if (__valid_fs(-1))
          v77 = 2989;
        else
          v77 = 3072;
        *(_DWORD *)v77 = -559038737;
        abort();
      }
      v34 = __si_assert_copy_extra_268();
      v35 = v34;
      v36 = "";
      if (v34)
        v36 = v34;
      v37 = "last >= offset";
LABEL_111:
      __message_assert(v34, "OQueue.c", 17, v37, v36);
      goto LABEL_116;
    }
LABEL_57:
    if (*(_QWORD *)(a1 + 32) && **(_QWORD **)(a1 + 16) >= a2)
    {
      v34 = __si_assert_copy_extra_268();
      v35 = v34;
      v36 = "";
      if (v34)
        v36 = v34;
      v37 = "last < offset";
      goto LABEL_111;
    }
    goto LABEL_90;
  }
  if (!a2)
  {
    *(_QWORD *)(a1 + 64) = 0;
    ++*(_DWORD *)(a1 + 56);
    v51 = *(_QWORD *)(a1 + 32);
    *(_QWORD *)(a1 + 40) = 0;
    *(_QWORD *)(a1 + 48) = v51;
    *(_QWORD *)(a1 + 32) = 0;
    parallel_qsort_JustPositionOffset_t(*(_QWORD *)(a1 + 16), v51);
    return;
  }
  v15 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 48) = v15;
  if (v15 >= 100000)
  {
    v52 = v15 - 1;
    v53 = *(void **)(a1 + 16);
    v54 = qos_class_self();
    v55 = dispatch_get_global_queue(v54, 0);
    v56 = thread_count;
    if (!thread_count)
    {
      *(_QWORD *)v80 = 0x1900000006;
      v79 = 4;
      sysctl(v80, 2u, &thread_count, &v79, 0, 0);
      v56 = thread_count;
    }
    v15 = _big_split_JustPositionOffset_t(v53, v52, a2, v55, v56);
  }
  else if (v15 >= 1)
  {
    v16 = 0;
    v17 = *(_QWORD *)(a1 + 16);
    while (1)
    {
      v18 = (_OWORD *)(v17 + 16 * v16);
      if (*(_QWORD *)v18 >= a2)
      {
        v19 = v15 >= v16 ? v16 : v15;
        v20 = (unint64_t *)(v17 + 16 * v15 - 16);
        while (v15 > v16)
        {
          v21 = v15--;
          v22 = *v20;
          v20 -= 2;
          if (v22 < a2)
          {
            memset(v80, 0, sizeof(v80));
            *(_OWORD *)v80 = *v18;
            *v18 = *(_OWORD *)(v17 + 16 * v15);
            *(_OWORD *)(*(_QWORD *)(a1 + 16) + 16 * v15) = *(_OWORD *)v80;
            v17 = *(_QWORD *)(a1 + 16);
            v19 = v21;
            break;
          }
        }
        v15 = v19;
        if (*(_QWORD *)(v17 + 16 * v16) >= 2 * a2)
          break;
      }
      if (++v16 >= v15)
        goto LABEL_66;
    }
    v74 = __si_assert_copy_extra_268();
    v35 = v74;
    v75 = "";
    if (v74)
      v75 = v74;
    v76 = "!offset || JustPositionOffset_t_GET_VALUE(queue->offsets[i]) < offset * 2";
    goto LABEL_115;
  }
LABEL_66:
  *(_QWORD *)(a1 + 32) = v15;
  *(_QWORD *)(a1 + 40) = v15;
  v57 = *(_QWORD *)(a1 + 48);
  v58 = v57 - v15;
  if (v57 < v15)
  {
    v74 = __si_assert_copy_extra_268();
    v35 = v74;
    v75 = "";
    if (v74)
      v75 = v74;
    v76 = "queue->top <= queue->end";
LABEL_115:
    __message_assert(v74, "OQueue.c", 16, v76, v75);
LABEL_116:
    free(v35);
    if (__valid_fs(-1))
      v78 = 2989;
    else
      v78 = 3072;
    *(_DWORD *)v78 = -559038737;
    abort();
  }
  if (v57 > v15)
  {
    v59 = 16 * v15 + 16;
    v60 = v58;
    do
    {
      if (!--v60)
        goto LABEL_75;
      v61 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + v59);
      v59 += 16;
    }
    while (v61 >= a2);
    v62 = __si_assert_copy_extra_268();
    v48 = v62;
    v63 = "";
    if (v62)
      v63 = v62;
    v64 = "current >= offset";
    goto LABEL_74;
  }
LABEL_75:
  if (v15 >= 1)
  {
    v65 = *(unint64_t **)(a1 + 16);
    v66 = v15;
    while (1)
    {
      v67 = *v65;
      v65 += 2;
      if (v67 > a2)
        break;
      if (!--v66)
        goto LABEL_79;
    }
    v74 = __si_assert_copy_extra_268();
    v35 = v74;
    v75 = "";
    if (v74)
      v75 = v74;
    v76 = "current <= offset";
    goto LABEL_115;
  }
LABEL_79:
  parallel_qsort_JustPositionOffset_t(*(_QWORD *)(a1 + 16) + 16 * v15, v58);
  v68 = *(_QWORD *)(a1 + 48);
  if (v15 < v68)
  {
    v69 = *(_QWORD *)(a1 + 16);
    v70 = *(_QWORD *)(a1 + 40);
    v71 = *(_QWORD *)(v69 + 16 * v70);
    if (v71 < a2)
    {
LABEL_85:
      v74 = __si_assert_copy_extra_268();
      v35 = v74;
      v75 = "";
      if (v74)
        v75 = v74;
      v76 = "last >= offset";
    }
    else
    {
      v72 = (unint64_t *)(v69 + 16 * v70 + 16);
      while (1)
      {
        if (++v70 >= v68)
          goto LABEL_88;
        v73 = *v72;
        if (*v72 < v71)
          break;
        v72 += 2;
        v71 = v73;
        if (v73 < a2)
          goto LABEL_85;
      }
      v74 = __si_assert_copy_extra_268();
      v35 = v74;
      v75 = "";
      if (v74)
        v75 = v74;
      v76 = "current >= last";
    }
    goto LABEL_115;
  }
LABEL_88:
  if (*(_QWORD *)(a1 + 32) && **(_QWORD **)(a1 + 16) >= a2)
  {
    v62 = __si_assert_copy_extra_268();
    v48 = v62;
    v63 = "";
    if (v62)
      v63 = v62;
    v64 = "last < offset";
LABEL_74:
    __message_assert(v62, "OQueue.c", 16, v64, v63);
    goto LABEL_98;
  }
LABEL_90:
  ++*(_DWORD *)(a1 + 56);
  *(_QWORD *)(a1 + 64) = a2;
}

uint64_t PayloadProcessDocIDRangeBitsReversed__Positions(int *a1, unint64_t a2, unsigned int a3, uint64_t a4, int8x8_t a5)
{
  uint64_t v9;
  uint64_t v10;
  unsigned int *v11;
  unint64_t v12;
  int8x8_t v13;
  int v15;
  NSObject *v16;
  int v17;
  unint64_t v18;
  __int16 v19;
  unint64_t v20;
  __int16 v21;
  unsigned int *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v9 = *(_QWORD *)a1;
  v10 = *((_QWORD *)a1 + 1);
  v11 = (unsigned int *)*((_QWORD *)a1 + 2);
  v12 = a2 + a3;
  if (v12 - 1 <= *(unsigned int *)(v10 + 40))
  {
    if (a2 < *(unsigned int *)(v10 + 44))
      *(_DWORD *)(v10 + 44) = a2;
  }
  else
  {
    *(_DWORD *)(v10 + 40) = a3 + a2 - 1;
  }
  CIIndexSetAddRangeFromBitVectorWithHint(*(unsigned int **)(v9 + 88), a2, a3, a4, a1 + 6, a5);
  if (dword_1EF19FCB4 >= 5)
  {
    v15 = *__error();
    v16 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      v17 = 134218496;
      v18 = a2;
      v19 = 2048;
      v20 = v12;
      v21 = 2048;
      v22 = v11;
      _os_log_impl(&dword_1B8270000, v16, OS_LOG_TYPE_DEFAULT, "Adding from %llu to  %llu to %p", (uint8_t *)&v17, 0x20u);
    }
    *__error() = v15;
  }
  CIIndexSetAddRangeFromBitVectorWithHint(v11, a2, a3, a4, a1 + 7, v13);
  return 1;
}

uint64_t pqpop_PositionOffset_t(uint64_t result, uint64_t a2, _BYTE *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  __int128 v20;
  uint64_t v21;
  unint64_t v22;
  __int128 *v24;
  uint64_t v29;
  uint64_t v30;
  BOOL v31;
  uint64_t v32;
  __int128 v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t *v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t *v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t *v47;
  __int128 v52;
  __int128 v53;

  *a3 = *(_BYTE *)a2;
  if (*(_BYTE *)a2)
  {
    v3 = *(_QWORD *)(a2 + 24);
    if (v3 == 1)
    {
      *(_QWORD *)result = 0;
      *(_QWORD *)(result + 8) = 0;
      *(_QWORD *)(result + 16) = 0;
      return result;
    }
    v8 = *(_QWORD *)(a2 + 8);
    *(_OWORD *)result = *(_OWORD *)(v8 + 24);
    v9 = *(_QWORD *)(v8 + 40);
    v10 = v8 + 24 * v3;
    v11 = *(_QWORD *)(v10 - 24);
    v12 = *(_OWORD *)(v10 - 16);
    *(_QWORD *)(v8 + 24) = v11;
    *(_OWORD *)(v8 + 32) = v12;
    v13 = *(_QWORD *)(a2 + 24);
    v14 = *(uint64_t *)(a2 + 16) >> 1;
    *(_QWORD *)(result + 16) = v9;
    *(_QWORD *)(a2 + 24) = v13 - 1;
    v15 = 3;
    result = 2;
    v16 = 1;
    while (1)
    {
      v17 = *(_QWORD *)(a2 + 8);
      v18 = v17 + 24 * result;
      v19 = *(_QWORD *)v18;
      v20 = *(_OWORD *)(v18 + 8);
      v21 = v17 + 24 * v15;
      v22 = *(_QWORD *)v21;
      v52 = *(_OWORD *)(v21 + 8);
      v53 = v20;
      if (v15 >= v13)
      {
        v52 = xmmword_1B8631560;
        if (result >= v13)
          return result;
        v22 = 0xBFFFFFFFFFFFFFFFLL;
      }
      if (v19 >= v11)
      {
        if (v22 >= v11)
        {
          _X8 = v17 + 48 * v16;
          __asm { PRFM            #1, [X8] }
          return result;
        }
        v24 = &v52;
      }
      else
      {
        _CF = v22 >= v19;
        if (v22 < v19)
        {
          v24 = &v52;
        }
        else
        {
          v22 = v19;
          v24 = &v53;
        }
        if (_CF)
          v15 = result;
      }
      result = v17 + 48 * v15;
      __asm { PRFM            #1, [X0] }
      if (v15 != v16)
      {
        result = 2 * v15;
        v29 = v17 + 24 * v15;
        *(_QWORD *)v29 = v11;
        *(_OWORD *)(v29 + 8) = v12;
        v30 = *(_QWORD *)(a2 + 8) + 24 * v16;
        v16 = v15;
        *(_QWORD *)v30 = v22;
        *(_OWORD *)(v30 + 8) = *v24;
        v31 = v15 < v14;
        v15 = (2 * v15) | 1;
        if (v31)
          continue;
      }
      return result;
    }
  }
  v4 = 0;
  v5 = 0;
  *(_QWORD *)(result + 16) = 0;
  v6 = *(_QWORD *)(a2 + 24);
  v7 = v6 - 1;
  if (v6 != 1)
  {
    v32 = *(_QWORD *)(a2 + 8);
    v5 = *(_QWORD *)(v32 + 16);
    v4 = *(_QWORD *)(v32 + 24);
    v33 = *(_OWORD *)(v32 + 16 * v7);
    *(_OWORD *)(v32 + 16) = v33;
    v34 = *(uint64_t *)(a2 + 16) >> 1;
    *(_QWORD *)(a2 + 24) = v7;
    v35 = 3;
    v36 = 2;
    v37 = 1;
    while (1)
    {
      v38 = *(_QWORD *)(a2 + 8);
      v39 = (unint64_t *)(v38 + 16 * v36);
      v40 = *v39;
      v41 = v39[1];
      if (v35 >= v6)
      {
        if (v36 >= v6)
          break;
        v44 = 0;
        v43 = 0xBFFFFFFFFFFFFFFFLL;
      }
      else
      {
        v42 = (unint64_t *)(v38 + 16 * v35);
        v43 = *v42;
        v44 = v42[1];
      }
      if (v40 >= (unint64_t)v33)
      {
        if (v43 >= (unint64_t)v33)
        {
          _X10 = v38 + 32 * v37;
          __asm { PRFM            #1, [X10] }
          break;
        }
      }
      else if (v43 >= v40)
      {
        v44 = v41;
        v43 = v40;
        v35 = v36;
      }
      _X16 = v38 + 32 * v35;
      __asm { PRFM            #1, [X16] }
      if (v35 != v37)
      {
        v36 = 2 * v35;
        *(_OWORD *)(v38 + 16 * v35) = v33;
        v47 = (unint64_t *)(*(_QWORD *)(a2 + 8) + 16 * v37);
        v37 = v35;
        *v47 = v43;
        v47[1] = v44;
        v31 = v35 < v34;
        v35 = (2 * v35) | 1;
        if (v31)
          continue;
      }
      break;
    }
  }
  *(_QWORD *)result = v5;
  *(_QWORD *)(result + 8) = v4;
  *(_DWORD *)(result + 16) = 0;
  return result;
}

_QWORD *oqpop_PositionOffset_t(_QWORD *result, uint64_t a2, _BYTE *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;

  *a3 = *(_BYTE *)a2;
  if (*(_BYTE *)a2)
  {
    v3 = *(_QWORD *)(a2 + 40);
    if (v3 >= *(_QWORD *)(a2 + 48))
    {
      *result = 0;
      result[1] = 0;
      result[2] = 0;
    }
    else
    {
      v4 = *(_QWORD *)(a2 + 16);
      *(_QWORD *)(a2 + 40) = v3 + 1;
      v5 = v4 + 24 * v3;
      *(_OWORD *)result = *(_OWORD *)v5;
      result[2] = *(_QWORD *)(v5 + 16);
    }
  }
  else
  {
    v6 = *(_QWORD *)(a2 + 40);
    if (v6 >= *(_QWORD *)(a2 + 48))
    {
      v9 = 0;
      v10 = 0;
    }
    else
    {
      v7 = *(_QWORD *)(a2 + 16);
      *(_QWORD *)(a2 + 40) = v6 + 1;
      v8 = (uint64_t *)(v7 + 16 * v6);
      v9 = *v8;
      v10 = v8[1];
    }
    result[1] = v10;
    result[2] = 0;
    *result = v9;
  }
  return result;
}

BOOL _iterator_match_address(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  if (*(_BYTE *)(a1 + 40) && (v2 = *(_QWORD *)(a1 + 32), v2 <= a2))
    return *(_QWORD *)(a1 + 88) + v2 > a2;
  else
    return 0;
}

void *initFileState(uint64_t a1, uint64_t a2, int a3)
{
  void *result;
  unint64_t v7;
  uint64_t v8;

  *(_QWORD *)(a1 + 8) = -1;
  result = malloc_type_malloc(0x10004uLL, 0xCB95AF59uLL);
  *(_QWORD *)a1 = result;
  *(_DWORD *)(a1 + 16) = a3;
  *(_DWORD *)(a1 + 20) = a3;
  *(_DWORD *)(a1 + 32) = 1;
  *(_QWORD *)(a1 + 384) = a2;
  *(_QWORD *)(a1 + 176) = 0;
  *(_QWORD *)(a1 + 184) = 0;
  if (*(_DWORD *)(a2 + 20))
  {
    v7 = 0;
    v8 = a1 + 320;
    do
    {
      *(_DWORD *)(v8 + 4 * v7) = 0;
      *(_QWORD *)(v8 + 8 * v7++ - 128) = 0;
    }
    while (v7 < *(unsigned int *)(a2 + 20));
  }
  return result;
}

void PositionIterator_Split(uint64_t a1, unint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  char v11;
  uint64_t v12;
  char *v13;
  char *v14;
  const char *v15;
  uint64_t v16;

  if (!*(_QWORD *)a1)
  {
    if (*(_QWORD *)(a1 + 136) != 1)
    {
      v13 = __si_assert_copy_extra(0);
      v14 = v13;
      v15 = "";
      if (v13)
        v15 = v13;
      __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 4796, "pqcount_AnnotatedPositionOffset_t(&iter->futureOffsets)==0", v15);
      free(v14);
      if (__valid_fs(-1))
        v16 = 2989;
      else
        v16 = 3072;
      *(_DWORD *)v16 = -559038737;
      abort();
    }
    if (*(_QWORD *)(a1 + 8) != a2 && *(_QWORD *)(a1 + 80))
    {
      *(_QWORD *)(a1 + 8) = a2;
      oqsplit_AnnotatedPositionOffset_t(a1 + 56, a2);
      v3 = *(_QWORD *)(a1 + 88);
      if (v3 >= *(_QWORD *)(a1 + 96))
      {
        v7 = 0;
        v6 = 0;
        v8 = 0;
        v9 = 0;
        v11 = 0;
        v12 = 0;
        v10 = 0;
      }
      else
      {
        v4 = *(_QWORD *)(a1 + 64);
        *(_QWORD *)(a1 + 88) = v3 + 1;
        v5 = (uint64_t *)(v4 + 56 * v3);
        v7 = *v5;
        v6 = v5[1];
        v8 = *((_DWORD *)v5 + 4);
        v9 = v5[3];
        v10 = v5[4];
        v11 = *((_BYTE *)v5 + 40);
        v12 = v5[6];
      }
      *(_QWORD *)a1 = v7;
      *(_DWORD *)(a1 + 48) = v8;
      *(_QWORD *)(a1 + 40) = v9;
      *(_BYTE *)(a1 + 156) = v11;
      *(_QWORD *)(a1 + 148) = v10;
      *(_QWORD *)(a1 + 16) = v12;
      *(_QWORD *)(a1 + 24) = v6;
    }
  }
}

void syncFileState1(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  char v12;
  _QWORD v13[7];
  int v14;
  char v15;

  v2 = *(_QWORD *)(a1 + 384);
  if (*(_DWORD *)(v2 + 20))
  {
    v5 = 0;
    v6 = a1 + 320;
    v7 = MEMORY[0x1E0C809B0];
    do
    {
      v8 = *(_DWORD *)(v6 + 4 * v5);
      if (v8)
      {
        v9 = *(NSObject **)(v2 + 8 * v5 + 32);
        v10 = v6 + 8 * v5;
        v11 = *(_QWORD *)(v10 - 128);
        v12 = *(_BYTE *)(v2 + 19);
        v13[0] = v7;
        v13[1] = 0x40000000;
        v13[2] = ___innerIssueBuffer_block_invoke;
        v13[3] = &__block_descriptor_tmp_63;
        v14 = v8;
        v13[4] = a2;
        v13[5] = v11;
        v15 = v12 ^ 1;
        v13[6] = 0;
        dispatch_async(v9, v13);
        *(_DWORD *)(v6 + 4 * v5) = 0;
        *(_QWORD *)(v10 - 128) = 0;
        v2 = *(_QWORD *)(a1 + 384);
      }
      ++v5;
    }
    while (v5 < *(unsigned int *)(v2 + 20));
  }
}

void ___innerIssueBuffer_block_invoke(uint64_t a1)
{
  int8x8_t v2;
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  int v8;
  unsigned int v9;
  unsigned int v10;
  int v11;
  unsigned int v12;
  NSObject *v13;
  char *v14;
  char *v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  __int128 v19;
  __int128 v20;
  uint64_t v21;

  v18 = *(_QWORD *)(a1 + 32);
  v2 = 0;
  v19 = 0u;
  v20 = 0u;
  v21 = 0;
  if (*(_DWORD *)(a1 + 56))
  {
    v3 = 0;
    do
    {
      v4 = *(_QWORD *)(a1 + 40);
      v5 = *(_QWORD *)(v4 + 4 * v3);
      if (!v5)
      {
        v14 = __si_assert_copy_extra(0);
        v15 = v14;
        v16 = "";
        if (v14)
          v16 = v14;
        __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 2582, "pSet", v16);
        free(v15);
        if (__valid_fs(-1))
          v17 = 2989;
        else
          v17 = 3072;
        *(_DWORD *)v17 = -559038737;
        abort();
      }
      v6 = v3 + 3;
      v7 = *(_DWORD *)(v4 + 4 * (v3 + 2));
      v8 = *(unsigned __int8 *)(a1 + 60);
      v3 += v7 + 3;
      v9 = v3 - 1;
      if (*(_BYTE *)(a1 + 60))
        v9 = v6;
      v10 = *(_DWORD *)(v4 + 4 * v9);
      if (v10 > *(_DWORD *)(v5 + 24))
      {
        v11 = 1 << -(char)__clz(v10);
        do
        {
          v12 = v11;
          v11 *= 2;
        }
        while (v12 < v10);
        _CIIndexSetSetIndexRangeWithCache((const void **)v5, *(_DWORD *)(v5 + 20), v12, v7, &v18);
        v4 = *(_QWORD *)(a1 + 40);
        v8 = *(unsigned __int8 *)(a1 + 60);
      }
      _CIIndexSetAddSortedIndexes((int *)v5, (unsigned int *)(v4 + 4 * v6), v7, v8 != 0, &v18, 0, v2);
    }
    while (v3 < *(_DWORD *)(a1 + 56));
  }
  free(*(void **)(a1 + 40));
  v13 = *(NSObject **)(a1 + 48);
  if (v13)
    dispatch_semaphore_signal(v13);
  CIIndexSetDisposePerThreadCache(&v18);
}

BOOL BulkPositionIterator_Step(uint64_t a1, uint64_t a2, unint64_t a3, unsigned int *a4, _DWORD *a5, int a6, _DWORD *a7, unsigned int a8, int a9, _BYTE *a10)
{
  char *v11;
  char *v12;
  const char *v13;
  uint64_t v14;

  if (*(_BYTE *)(a2 + 3176))
    return BulkPositionIterator_Step_Compressed(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
  if (a8 != 1)
  {
    v11 = __si_assert_copy_extra(0);
    v12 = v11;
    v13 = "";
    if (v11)
      v13 = v11;
    __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 5420, "limit == 1", v13);
    free(v12);
    if (__valid_fs(-1))
      v14 = 2989;
    else
      v14 = 3072;
    *(_DWORD *)v14 = -559038737;
    abort();
  }
  return BulkPositionIterator_Step_Live(a2, a3, a4, a5, a6, a7, a10);
}

BOOL BulkPositionIterator_Step_Compressed(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int *a4, _DWORD *a5, int a6, _DWORD *a7, unsigned int a8, int a9, _BYTE *a10)
{
  int v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  void *v18;
  uint64_t v19;
  size_t v20;
  size_t v21;
  char v22;
  uint64_t v23;
  int v24;
  size_t v25;
  char v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int v30;
  uint64_t v31;
  uint64_t v32;
  unsigned int *v33;
  int *v34;
  uint64_t v35;
  uint64_t *v36;
  uint64_t v37;
  uint64_t v39;
  uint64_t v40;
  int v41;
  NSObject *v42;
  uint64_t v43;
  char *v44;
  char *v45;
  const char *v46;
  uint64_t v47;
  int v48;
  NSObject *v49;
  unsigned int v50;
  int v51;
  int v52;
  NSObject *v53;
  unsigned int v54;
  int v55;
  _QWORD v56[2];
  uint64_t v57;
  uint64_t v58;
  _QWORD v59[7];
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  uint64_t v64;
  _DWORD *v65;
  _BYTE *v66;
  char *v67;
  char *v68;
  unsigned int v69;
  unsigned int v70;
  int v71;
  char v72;
  _DWORD v73[2];
  __int16 v74;
  int v75;
  uint64_t v76;
  __int128 v77;
  __int128 v78;
  uint64_t v79;
  uint8_t buf[16];
  __int128 v81;
  __int128 v82;
  __int128 v83;
  uint64_t v84;

  v84 = *MEMORY[0x1E0C80C00];
  v14 = *(_DWORD *)(a2 + 3348);
  if (v14)
  {
    v15 = a2 + 40;
    v16 = *(unsigned int *)(a2 + 3348);
    do
    {
      *(_QWORD *)(v15 + 24) = -1;
      *(_QWORD *)(v15 + 32) = -1;
      *(_DWORD *)(v15 + 40) = *a5;
      *(_DWORD *)v15 = *a4;
      *(_DWORD *)(v15 + 4) = *a5;
      *(_DWORD *)(v15 + 8) = a6;
      v15 += 392;
      --v16;
    }
    while (v16);
  }
  else
  {
    *(_QWORD *)(a2 + 64) = -1;
    *(_QWORD *)(a2 + 72) = -1;
    *(_DWORD *)(a2 + 80) = *a5;
    *(_DWORD *)(a2 + 40) = *a4;
    *(_DWORD *)(a2 + 44) = *a5;
    *(_DWORD *)(a2 + 48) = a6;
  }
  if (dword_1EF19FCB4 >= 5)
  {
    v39 = a1;
    v40 = a3;
    v41 = *__error();
    v42 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
    {
      v43 = *(_QWORD *)(a2 + 3328);
      *(_DWORD *)buf = 134217984;
      *(_QWORD *)&buf[4] = v43;
      _os_log_impl(&dword_1B8270000, v42, OS_LOG_TYPE_DEFAULT, "Split point: %llx", buf, 0xCu);
    }
    *__error() = v41;
    v14 = *(_DWORD *)(a2 + 3348);
    a3 = v40;
    a1 = v39;
  }
  if (v14)
  {
    v57 = a1;
    v58 = a3;
    v82 = 0u;
    v83 = 0u;
    *(_OWORD *)buf = 0u;
    v81 = 0u;
    v17 = *(_QWORD *)(a2 + 16) - 1;
    v18 = oqinit_offset_t((uint64_t)buf, v17);
    while (*(_QWORD *)(a2 + 16) != 1 && !*a10)
    {
      v19 = ipqpop((_QWORD *)a2);
      oqpush_offset_t((uint64_t)buf, v19, v20);
    }
    v56[1] = v56;
    MEMORY[0x1E0C80A78](v18);
    bzero((char *)v56 - ((v17 + 15) & 0x1FFFFFFF0), v17);
    v59[1] = 0x40000000;
    v60 = *(_OWORD *)buf;
    v61 = v81;
    v62 = v82;
    v73[0] = 0;
    v72 = 0;
    v21 = *(unsigned int *)(a2 + 3348);
    v59[0] = MEMORY[0x1E0C809B0];
    v59[2] = __BulkPositionIterator_Step_Compressed_block_invoke;
    v59[3] = &__block_descriptor_tmp_69;
    v59[4] = v58;
    v59[5] = v57;
    v59[6] = v73;
    v63 = v83;
    v64 = a2;
    v65 = a7;
    v69 = v17;
    v70 = a8;
    v71 = a9;
    v66 = a10;
    v67 = (char *)v56 - ((v17 + 15) & 0x1FFFFFFF0);
    v68 = &v72;
    dispatch_apply(v21, 0, v59);
    if ((v72 & 1) != 0)
    {
      v44 = __si_assert_copy_extra(0);
      v45 = v44;
      v46 = "";
      if (v44)
        v46 = v44;
      __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 5080, "__c11_atomic_load(didAssertPtr, memory_order_relaxed)==0", v46);
      free(v45);
      if (__valid_fs(-1))
        v47 = 2989;
      else
        v47 = 3072;
      *(_DWORD *)v47 = -559038737;
      abort();
    }
    if (*a10 || (v27 = *((_QWORD *)&v81 + 1), *((uint64_t *)&v81 + 1) < 1))
    {
      v22 = 0;
    }
    else
    {
      v28 = 0;
      v22 = 0;
      v29 = *(_QWORD *)&buf[8];
      do
      {
        if (*((_BYTE *)v56 + v28 - ((v17 + 15) & 0x1FFFFFFF0)))
        {
          ipqpush(a2, *(_QWORD *)(v29 + 8 * v28));
          v22 = 1;
        }
        ++v28;
      }
      while (v28 < v27);
    }
    free(*(void **)&buf[8]);
    v30 = *(_DWORD *)(a2 + 80);
    LODWORD(v31) = gCPUCount;
    if (gCPUCount >= v17)
      LODWORD(v31) = v17;
    if (v31 >= 8)
      v31 = 8;
    else
      v31 = v31;
    if (v31 < 2)
    {
      v34 = (int *)&unk_1EF19F000;
    }
    else
    {
      v32 = v31 - 1;
      v33 = (unsigned int *)(a2 + 472);
      v34 = (_DWORD *)&unk_1EF19F000;
      do
      {
        if (v30 >= *v33)
          v30 = *v33;
        v33 += 98;
        --v32;
      }
      while (v32);
    }
    if (v34[813] > 4)
    {
      v48 = *__error();
      v49 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
      {
        v50 = *a4;
        v51 = *(_DWORD *)(a2 + 80);
        LODWORD(v76) = 67109376;
        HIDWORD(v76) = v50;
        LOWORD(v77) = 1024;
        *(_DWORD *)((char *)&v77 + 2) = v51;
        _os_log_impl(&dword_1B8270000, v49, OS_LOG_TYPE_DEFAULT, "Expected start: %d Actual start: %d", (uint8_t *)&v76, 0xEu);
      }
      *__error() = v48;
    }
    *a4 = v30;
    if ((v22 & 1) != 0)
      return 0;
  }
  else
  {
    v81 = 0u;
    v82 = 0u;
    *(_OWORD *)buf = 0u;
    *(_QWORD *)&v83 = 0;
    *((_QWORD *)&v83 + 1) = 0xFFFFFFFFLL;
    v77 = 0u;
    v78 = 0u;
    v76 = a3;
    v79 = 0;
    while (*(_QWORD *)(a2 + 16) != 1)
    {
      if (*a10)
        break;
      v23 = ipqpop((_QWORD *)a2);
      v24 = PositionIterate_Compressed(v23, (uint64_t)&v76, a2 + 24, a7, a8, a9, a10);
      if (v24 == 2)
      {
        oqpush_offset_t((uint64_t)buf, v23, v25);
      }
      else if (v24 == 1)
      {
        ipqpush(a2, v23);
      }
    }
    CIIndexSetDisposePerThreadCache(&v76);
    if (*a10 || (v35 = *((_QWORD *)&v81 + 1)) == 0)
    {
      v26 = 0;
    }
    else
    {
      if (*((uint64_t *)&v81 + 1) >= 1)
      {
        v36 = *(uint64_t **)&buf[8];
        do
        {
          v37 = *v36++;
          ipqpush(a2, v37);
          --v35;
        }
        while (v35);
      }
      v26 = 1;
    }
    free(*(void **)&buf[8]);
    if (dword_1EF19FCB4 >= 5)
    {
      v52 = *__error();
      v53 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
      {
        v54 = *a4;
        v55 = *(_DWORD *)(a2 + 80);
        v73[0] = 67109376;
        v73[1] = v54;
        v74 = 1024;
        v75 = v55;
        _os_log_impl(&dword_1B8270000, v53, OS_LOG_TYPE_DEFAULT, "Expected start: %d Actual start: %d", (uint8_t *)v73, 0xEu);
      }
      *__error() = v52;
    }
    *a4 = *(_DWORD *)(a2 + 80);
    if ((v26 & 1) != 0)
      return 0;
  }
  if (*(_QWORD *)(a2 + 16) == 1)
    return 0;
  return *a10 == 0;
}

BOOL BulkPositionIterator_Step_Live(uint64_t a1, unint64_t a2, _DWORD *a3, _DWORD *a4, int a5, _DWORD *a6, _BYTE *a7)
{
  unint64_t v9;
  _QWORD *v10;
  void *v11;
  int *v12;
  void *v13;
  uint64_t v14;
  unint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t i;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  BOOL v27;
  uint64_t v28;
  uint64_t j;
  uint64_t v30;
  uint64_t *v31;
  uint64_t v32;
  unint64_t v33;
  unint64_t v34;
  BOOL v35;
  uint64_t v36;
  int v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t *v41;
  unint64_t v42;
  uint64_t v43;
  unint64_t v44;
  unint64_t *v45;
  unint64_t v46;
  unint64_t v47;
  int v48;
  uint64_t v49;
  uint64_t v50;
  BOOL v52;
  BOOL v53;
  uint64_t *v54;
  unsigned __int8 *v55;
  uint64_t v56;
  unint64_t v57;
  size_t v58;
  int v59;
  unint64_t v60;
  size_t v61;
  int v62;
  uint64_t v63;
  unint64_t v64;
  unint64_t v65;
  uint64_t v66;
  size_t v67;
  int v68;
  void *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  signed __int8 v73;
  uint64_t v74;
  int v75;
  int v76;
  uint64_t v77;
  int v78;
  int v79;
  int v80;
  int v81;
  int v82;
  int v83;
  int v84;
  size_t v85;
  void *v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  int v90;
  int v91;
  int v92;
  uint64_t v93;
  int v94;
  char v95;
  unsigned int v96;
  int v97;
  int v98;
  int v99;
  int v100;
  int v101;
  unint64_t v102;
  unint64_t v103;
  unint64_t v104;
  unint64_t v105;
  BOOL v106;
  BOOL v108;
  BOOL v110;
  unint64_t v112;
  int v113;
  uint64_t v114;
  int v115;
  int v116;
  char v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  unint64_t v122;
  unint64_t v123;
  uint64_t v124;
  size_t v125;
  int v126;
  void *v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  unsigned int v131;
  int v132;
  size_t v133;
  void *v134;
  uint64_t v135;
  uint64_t v136;
  unsigned int v137;
  int v138;
  unint64_t v139;
  unint64_t v140;
  unint64_t v141;
  unint64_t v142;
  BOOL v143;
  BOOL v145;
  BOOL v147;
  unint64_t v149;
  int v150;
  uint64_t v151;
  int v152;
  int v153;
  char v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  int v158;
  uint64_t v159;
  int v160;
  int v161;
  char v162;
  uint64_t v163;
  uint64_t v164;
  unint64_t v165;
  int v166;
  NSObject *v167;
  os_log_type_t v168;
  int v169;
  uint64_t v170;
  int v171;
  int v172;
  char v173;
  uint64_t v174;
  uint64_t v175;
  unint64_t v176;
  int v177;
  NSObject *v178;
  os_log_type_t v179;
  int v180;
  int v181;
  void *v182;
  void *v183;
  uint64_t v184;
  int v185;
  NSObject *v186;
  os_log_type_t v187;
  uint64_t v188;
  int v189;
  void *v190;
  int v191;
  NSObject *v192;
  uint64_t v193;
  unint64_t v194;
  unint64_t v195;
  int v196;
  NSObject *v197;
  uint64_t v198;
  int v199;
  NSObject *v200;
  uint64_t v201;
  char *v202;
  uint64_t v203;
  char *v204;
  uint64_t v205;
  unint64_t v206;
  uint64_t v207;
  _BOOL8 v208;
  uint64_t v210;
  uint64_t v211;
  int v212;
  NSObject *v213;
  uint64_t v214;
  int v215;
  NSObject *v216;
  uint64_t v217;
  uint64_t v218;
  int v219;
  NSObject *v220;
  uint64_t v221;
  uint64_t v222;
  int v223;
  NSObject *v224;
  int v225;
  int v226;
  int v227;
  int v228;
  NSObject *v229;
  uint64_t v230;
  int v231;
  int v232;
  NSObject *v233;
  char *v234;
  char *v235;
  const char *v236;
  char *v237;
  const char *v238;
  uint64_t v239;
  uint64_t v240;
  unint64_t v242;
  unint64_t v243;
  unint64_t v244;
  unint64_t v245;
  unint64_t v246;
  unint64_t v247;
  uint64_t v248;
  uint64_t v249;
  int v251;
  unint64_t *v252;
  unint64_t v253;
  __int128 v254;
  __int128 v255;
  uint64_t v256;
  unint64_t v257;
  _BYTE buf[24];
  uint64_t v259;
  int v260;
  int v261;
  char v262;
  _DWORD v263[5];
  uint64_t v264;

  v264 = *MEMORY[0x1E0C80C00];
  v253 = a2;
  v254 = 0u;
  v255 = 0u;
  v256 = 0;
  *(_QWORD *)(a1 + 64) = -1;
  *(_QWORD *)(a1 + 72) = -1;
  *(_DWORD *)(a1 + 80) = *a4;
  *(_DWORD *)(a1 + 40) = *a3;
  *(_DWORD *)(a1 + 44) = *a4;
  *(_DWORD *)(a1 + 48) = a5;
  ++*(_DWORD *)(a1 + 56);
  v251 = *a3;
  v252 = (unint64_t *)(a1 + 64);
  v9 = *(_QWORD *)(a1 + 3328);
  v10 = malloc_type_malloc(0x18uLL, 0x10A0040319E9F20uLL);
  v10[1] = 4;
  v11 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 0x20uLL, 0x6085D6BuLL);
  if (!v11)
    _log_fault_for_malloc_failure();
  v242 = v9;
  *v10 = v11;
  v10[2] = a1;
  v12 = (int *)malloc_type_malloc(0x18uLL, 0x10A0040319E9F20uLL);
  *((_QWORD *)v12 + 1) = 4;
  *((_QWORD *)v12 + 2) = a1;
  v13 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 0x20uLL, 0x6085D6BuLL);
  if (!v13)
    _log_fault_for_malloc_failure();
  *(_QWORD *)v12 = v13;
  v14 = (uint64_t)CICleanUpThreadLoc();
  v246 = threadData[18 * v14 + 8];
  v247 = CICleanUpPush(v14, (uint64_t)CIIndexSetDisposePerThreadCache, (uint64_t)&v253);
  v249 = (uint64_t)v10;
  v245 = CICleanUpPush(v14, (uint64_t)_deferredArrayExceptionCleanup, (uint64_t)v10);
  v244 = CICleanUpPush(v14, (uint64_t)_deferredArrayExceptionCleanup, (uint64_t)v12);
  v15 = (unint64_t *)malloc_type_malloc(0x20uLL, 0x10A004064A2AE3FuLL);
  pqinit_ItemIteratorRef(v15, 16);
  v15[3] = a1;
  v248 = v14;
  v243 = CICleanUpPush(v14, (uint64_t)_deferredExceptionCleanup, (uint64_t)v15);
  if (dword_1EF19FCB4 >= 5)
  {
    v212 = *__error();
    v213 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v213, OS_LOG_TYPE_DEFAULT))
    {
      v214 = *(_QWORD *)(a1 + 3328);
      *(_DWORD *)buf = 134217984;
      *(_QWORD *)&buf[4] = v214;
      _os_log_impl(&dword_1B8270000, v213, OS_LOG_TYPE_DEFAULT, "Split point: %llx", buf, 0xCu);
    }
    *__error() = v212;
  }
  if (!*(_QWORD *)(a1 + 3328) && *(uint64_t *)(a1 + 3336) >= 1)
    printf("renedebug");
  v16 = *(_QWORD *)(a1 + 16);
  while (1)
  {
    while (1)
    {
      if (v16 != 1)
      {
        v37 = 0;
        goto LABEL_52;
      }
      if (v15[2] != 1)
        break;
      v17 = *(_QWORD *)(a1 + 3336);
      if (!v17 && !v12[3])
        break;
      v18 = *(_QWORD *)(a1 + 3328);
      if (!v18)
        break;
      if (*a7)
        goto LABEL_406;
      if (dword_1EF19FCB4 >= 5)
      {
        v191 = *__error();
        v192 = _SILogForLogForCategory(10);
        if (os_log_type_enabled(v192, OS_LOG_TYPE_DEFAULT))
        {
          v193 = *(_QWORD *)(a1 + 3328);
          *(_DWORD *)buf = 134217984;
          *(_QWORD *)&buf[4] = v193;
          _os_log_impl(&dword_1B8270000, v192, OS_LOG_TYPE_DEFAULT, "Splitting at: %llx", buf, 0xCu);
        }
        *__error() = v191;
        v17 = *(_QWORD *)(a1 + 3336);
        v18 = *(_QWORD *)(a1 + 3328);
      }
      v19 = v12[3];
      *(_QWORD *)(a1 + 3336) = 0;
      v20 = v18 >> 1;
      *(_QWORD *)(a1 + 3328) = v20;
      v12[3] = 0;
      *(_QWORD *)(a1 + 64) = *(_QWORD *)(a1 + 72);
      *(_QWORD *)(a1 + 72) = -1;
      if (v20 < *(_QWORD *)(*(_QWORD *)(a1 + 3160) + 32))
        *(_QWORD *)(a1 + 3328) = 0;
      if (v17 >= 1)
      {
        for (i = 0; v17 != i; ++i)
        {
          v22 = a1 + 8 * i;
          v23 = *(uint64_t **)(v22 + 3352);
          v24 = *v23;
          v25 = *(_QWORD *)(a1 + 3328);
          if (!*v23)
          {
            PositionIterator_Split(*(_QWORD *)(v22 + 3352), v25);
            v23 = *(uint64_t **)(v22 + 3352);
            v24 = *v23;
            v25 = *(_QWORD *)(a1 + 3328);
          }
          v26 = v24 & 0x3FFFFFFFFFFFFFFFLL;
          if (v26 <= v25)
          {
            if (v25)
            {
              v28 = *(_QWORD *)(a1 + 3336);
              *(_QWORD *)(a1 + 3336) = v28 + 1;
              *(_QWORD *)(a1 + 8 * v28 + 3352) = v23;
            }
          }
          else
          {
            if (v25)
              v27 = v26 > 2 * v25;
            else
              v27 = 0;
            if (v27)
              goto LABEL_386;
            if (v25 != v23[1])
            {
              PositionIterator_Resplit(v23, v25);
              v23 = *(uint64_t **)(v22 + 3352);
            }
            ipqpush(a1, (uint64_t)v23);
          }
        }
      }
      if ((int)v19 >= 1)
      {
        for (j = 0; v19 != j; ++j)
        {
          v30 = *(_QWORD *)v12;
          v31 = *(uint64_t **)(*(_QWORD *)v12 + 8 * j);
          v32 = *v31;
          v33 = *(_QWORD *)(a1 + 3328);
          if (!*v31)
          {
            PositionIterator_Split(*(_QWORD *)(*(_QWORD *)v12 + 8 * j), v33);
            v30 = *(_QWORD *)v12;
            v31 = *(uint64_t **)(*(_QWORD *)v12 + 8 * j);
            v32 = *v31;
            v33 = *(_QWORD *)(a1 + 3328);
          }
          v34 = v32 & 0x3FFFFFFFFFFFFFFFLL;
          if (v34 <= v33)
          {
            if (v33)
            {
              v36 = v12[3];
              v12[3] = v36 + 1;
              *(_QWORD *)(v30 + 8 * v36) = v31;
            }
          }
          else
          {
            if (v33)
              v35 = v34 > 2 * v33;
            else
              v35 = 0;
            if (v35)
              goto LABEL_389;
            if (v33 != v31[1])
            {
              PositionIterator_Resplit(v31, v33);
              v31 = *(uint64_t **)(*(_QWORD *)v12 + 8 * j);
            }
            ipqpush((uint64_t)v15, (uint64_t)v31);
          }
        }
      }
      v16 = *(_QWORD *)(a1 + 16);
    }
    v16 = 1;
    v37 = 1;
LABEL_52:
    if (*a7)
      goto LABEL_406;
    if (!*(_QWORD *)(a1 + 3328) && *(_QWORD *)(a1 + 3336))
      goto LABEL_386;
    v38 = v15[2];
    if (v37)
    {
      if (v38 == 1)
        goto LABEL_359;
    }
    else if (v38 == 1)
    {
      v39 = -1;
      goto LABEL_62;
    }
    v39 = *v15;
    if (*v15)
      v39 = *(_QWORD *)(v39 + 8);
LABEL_62:
    if (v16 == 1)
    {
      v40 = -1;
    }
    else
    {
      v40 = *(_QWORD *)a1;
      if (*(_QWORD *)a1)
        v40 = *(_QWORD *)(v40 + 8);
    }
    if (v39 >= v40)
      break;
    v41 = (unint64_t *)ipqpop(v15);
    v42 = v41[1];
    if (v42 != *(_QWORD *)(a1 + 3328))
      goto LABEL_389;
    v43 = (uint64_t)v41;
    v44 = *v41;
    if (v42)
    {
      if (v44 <= v42 || v44 > 2 * v42)
        goto LABEL_389;
    }
    if (v44 == *v252)
    {
      if (!v42 || (v44 & 0x3FFFFFFFFFFFFFFFLL) <= 2 * v42)
      {
        if (dword_1EF19FCB4 >= 5)
        {
          v215 = *__error();
          v216 = _SILogForLogForCategory(10);
          if (os_log_type_enabled(v216, OS_LOG_TYPE_DEFAULT))
          {
            v217 = *(_QWORD *)(v43 + 24);
            v218 = *(_QWORD *)v43;
            *(_DWORD *)buf = 134218496;
            *(_QWORD *)&buf[4] = v43;
            *(_WORD *)&buf[12] = 2048;
            *(_QWORD *)&buf[14] = v217;
            *(_WORD *)&buf[22] = 2048;
            v259 = v218;
            _os_log_impl(&dword_1B8270000, v216, OS_LOG_TYPE_DEFAULT, "Pushback; def we are done with a generation %p %p %llu",
              buf,
              0x20u);
          }
          *__error() = v215;
        }
        ipqpush((uint64_t)v15, v43);
        goto LABEL_397;
      }
LABEL_389:
      v204 = __si_assert_copy_extra(0);
      __message_assert("%s:%u: failed assertion '%s' %s ");
LABEL_390:
      free(v204);
      if (__valid_fs(-1))
        v205 = 2989;
      else
        v205 = 3072;
      *(_DWORD *)v205 = -559038737;
      abort();
    }
LABEL_78:
    if (v42 && (v44 <= v42 || v44 > 2 * v42))
      goto LABEL_389;
    v46 = *(_QWORD *)(*(_QWORD *)(a1 + 3160) + 8);
    v47 = *(_QWORD *)(v43 + 192);
    if (v46 == v47)
    {
LABEL_82:
      v48 = PositionIterate(v43, &v253, (uint64_t)(v252 - 5), a6, v251 == 1);
      if (v48 < 1)
      {
        switch(v48)
        {
          case -4:
            goto LABEL_338;
          case -3:
            goto LABEL_328;
          case -2:
            goto LABEL_341;
          case -1:
            goto LABEL_304;
          default:
            goto LABEL_359;
        }
      }
      v49 = *(_QWORD *)v43;
LABEL_84:
      if ((v49 & 0x3FFFFFFFFFFFFFFFuLL) > *(_QWORD *)(a1 + 3328))
      {
        v50 = a1;
LABEL_310:
        ipqpush(v50, v43);
        goto LABEL_359;
      }
      v234 = __si_assert_copy_extra(0);
      v235 = v234;
      v236 = "";
      if (v234)
        v236 = v234;
      __message_assert("%s:%u: Unexpected code path %s ", "PayloadIterator.c", 5328, v236);
      goto LABEL_479;
    }
    if (v46 >= v47)
    {
      if (v42 >= v47)
        goto LABEL_103;
    }
    else
    {
      v52 = v44 < v46 || v44 >= v47;
      if (v42 >= v47 || !v52)
        goto LABEL_103;
    }
    v53 = 2 * v42 >= v47 || v42 == 0;
    if (!v53 || v44 >= v47)
      goto LABEL_82;
LABEL_103:
    v54 = *(uint64_t **)(a1 + 408);
    v55 = *(unsigned __int8 **)(a1 + 24);
    v56 = *v54;
    if (!*((_BYTE *)v54 + 18))
    {
      if (!v44)
      {
        PositionIterator_GetNext(v43);
        *(_QWORD *)(v43 + 32) = 0;
        goto LABEL_325;
      }
      if (v42 && (v44 <= v42 || v44 > 2 * v42))
        goto LABEL_389;
      if (dword_1EF19FCB4 >= 5)
      {
        v199 = *__error();
        v200 = _SILogForLogForCategory(10);
        if (os_log_type_enabled(v200, OS_LOG_TYPE_DEFAULT))
        {
          v201 = *(_QWORD *)(v43 + 24);
          *(_DWORD *)buf = 134218496;
          *(_QWORD *)&buf[4] = v43;
          *(_WORD *)&buf[12] = 2048;
          *(_QWORD *)&buf[14] = v44;
          *(_WORD *)&buf[22] = 2048;
          v259 = v201;
          _os_log_impl(&dword_1B8270000, v200, OS_LOG_TYPE_DEFAULT, "%p %llu %p", buf, 0x20u);
        }
        *__error() = v199;
        v54 = *(uint64_t **)(a1 + 408);
      }
      v60 = *(_QWORD *)(a1 + 32);
      v61 = v54[1];
      if (v44 < v60 || v61 + v60 <= v44 || v44 + 30 > v61 + v60)
      {
        *(_QWORD *)(a1 + 32) = v44 & 0x3FFFFFFFFFFFF000;
        if (fd_pread(*(_DWORD **)(v56 + 4480), v55, v61, v44 & 0x3FFFFFFFFFFFF000) == -1)
          goto LABEL_359;
        v62 = 0;
        *(_DWORD *)(a1 + 52) = 0;
        v60 = *(_QWORD *)(a1 + 32);
        v61 = *(_QWORD *)(*(_QWORD *)(a1 + 408) + 8);
      }
      else
      {
        v62 = *(_DWORD *)(a1 + 52) + 1;
        *(_DWORD *)(a1 + 52) = v62;
      }
      v257 = v44 - v60;
      if ((int)v44 - (int)v60 + 20 >= v61)
      {
        *(_QWORD *)(a1 + 32) = v44 & 0x3FFFFFFFFFFFF000;
        v121 = fd_pread(*(_DWORD **)(v56 + 4480), *(void **)(a1 + 24), v61, v44 & 0x3FFFFFFFFFFFF000);
        *(_DWORD *)(a1 + 52) = 0;
        v257 = v44 - *(_QWORD *)(a1 + 32);
        if (v121 == -1)
          goto LABEL_323;
      }
      else
      {
        *(_DWORD *)(a1 + 52) = v62 + 1;
      }
      v240 = CIReadPositionHeader((uint64_t)v55, (uint64_t *)&v257);
      v123 = v122;
      v124 = v257;
      while (1)
      {
LABEL_217:
        v125 = *(_QWORD *)(*(_QWORD *)(a1 + 408) + 8);
        if ((int)v124 + 5 >= v125)
        {
          v127 = *(void **)(a1 + 24);
          v128 = *(_QWORD *)(a1 + 32) + v124;
          *(_QWORD *)(a1 + 32) = v128 & 0x3FFFFFFFFFFFF000;
          v129 = fd_pread(*(_DWORD **)(v56 + 4480), v127, v125, v128 & 0x3FFFFFFFFFFFF000);
          v126 = 0;
          *(_DWORD *)(a1 + 52) = 0;
          v124 = v128 - *(_QWORD *)(a1 + 32);
          if (v129 == -1)
            goto LABEL_243;
        }
        else
        {
          v126 = *(_DWORD *)(a1 + 52) + 1;
          *(_DWORD *)(a1 + 52) = v126;
        }
        v130 = v124 + 1;
        v131 = v55[v124];
        if ((char)v55[v124] < 0)
        {
          if (v131 > 0xBF)
          {
            if (v131 > 0xDF)
            {
              if (v131 > 0xEF)
              {
                v131 = *(_DWORD *)&v55[v130];
                v130 = v124 + 5;
              }
              else
              {
                v131 = ((v131 & 0xF) << 24) | (v55[v130] << 16) | (v55[v124 + 2] << 8) | v55[v124 + 3];
                v130 = v124 + 4;
              }
            }
            else
            {
              v131 = ((v131 & 0x1F) << 16) | (v55[v130] << 8) | v55[v124 + 2];
              v130 = v124 + 3;
            }
          }
          else
          {
            v132 = v55[v130] | ((v131 & 0x3F) << 8);
            v130 = v124 + 2;
            v131 = v132;
          }
        }
        if (!v131)
          break;
        do
        {
          v133 = *(_QWORD *)(*(_QWORD *)(a1 + 408) + 8);
          if ((int)v130 + 5 >= v133)
          {
            v134 = *(void **)(a1 + 24);
            v135 = *(_QWORD *)(a1 + 32) + v130;
            *(_QWORD *)(a1 + 32) = v135 & 0x3FFFFFFFFFFFF000;
            v136 = fd_pread(*(_DWORD **)(v56 + 4480), v134, v133, v135 & 0x3FFFFFFFFFFFF000);
            v126 = 0;
            *(_DWORD *)(a1 + 52) = 0;
            v124 = v135 - *(_QWORD *)(a1 + 32);
            v130 = v124;
            if (v136 == -1)
              goto LABEL_217;
          }
          else
          {
            *(_DWORD *)(a1 + 52) = ++v126;
          }
          v124 = v130 + 1;
          v137 = v55[v130];
          if ((char)v55[v130] < 0)
          {
            if (v137 > 0xBF)
            {
              if (v137 > 0xDF)
              {
                if (v137 > 0xEF)
                {
                  v137 = *(_DWORD *)&v55[v124];
                  v124 = v130 + 5;
                }
                else
                {
                  v137 = ((v137 & 0xF) << 24) | (v55[v124] << 16) | (v55[v130 + 2] << 8) | v55[v130 + 3];
                  v124 = v130 + 4;
                }
              }
              else
              {
                v137 = ((v137 & 0x1F) << 16) | (v55[v124] << 8) | v55[v130 + 2];
                v124 = v130 + 3;
              }
            }
            else
            {
              v138 = v55[v124] | ((v137 & 0x3F) << 8);
              v124 = v130 + 2;
              v137 = v138;
            }
          }
          v130 = v124;
        }
        while (v137);
      }
      v124 = v130;
LABEL_243:
      v257 = v124;
      v139 = v240;
      if (!(v123 | v240))
      {
        v139 = *(_QWORD *)(v43 + 16);
        *(_QWORD *)(v43 + 16) = 0;
      }
      v140 = *(_QWORD *)(v43 + 8);
      v141 = *(_QWORD *)(**(_QWORD **)(a1 + 408) + 32);
      v142 = 2 * v140;
      if (v140 >= v141)
        v141 = 2 * v140;
      if (v123 <= v44 && v123)
      {
        v143 = v44 <= v141 || v123 > v141;
        if (v143 && v123 >= v140)
          goto LABEL_386;
      }
      if (v139 - 1 < v44)
      {
        v145 = v44 <= v141 || v139 > v141;
        if (v145 && v139 >= v140)
          goto LABEL_386;
      }
      if (v139 - 1 < v123)
      {
        v147 = v123 <= v141 || v139 > v141;
        if (v147 && v139 >= v140)
          goto LABEL_386;
      }
      if (v123)
        v149 = 0;
      else
        v149 = v139;
      if (v123 && v139)
      {
        v149 = 0;
        *(_QWORD *)(v43 + 16) = v139;
      }
      if (v149 | v123)
      {
        if (v123)
        {
          if (v149)
            goto LABEL_386;
          if (v123 != v44)
          {
            v150 = *(_DWORD *)(v43 + 48);
            v151 = *(_QWORD *)(v43 + 40);
            v153 = *(_DWORD *)(v43 + 148);
            v152 = *(_DWORD *)(v43 + 152);
            v154 = *(_BYTE *)(v43 + 156);
            v155 = *(_QWORD *)(v43 + 16);
            v156 = *(_QWORD *)(v43 + 24);
            if (v123 > v44 || v123 > *(_QWORD *)(v43 + 112))
            {
              if (v140 && (v123 <= v140 || v123 > v142))
                goto LABEL_389;
              v157 = v43 + 120;
              *(_QWORD *)buf = v123;
              *(_QWORD *)&buf[8] = v156;
              *(_DWORD *)&buf[16] = v150;
              *(_DWORD *)&buf[20] = 0;
              v259 = v151;
              v260 = v153;
              v261 = v152;
              v262 = v154;
              v263[0] = 0;
              *(_DWORD *)((char *)v263 + 3) = 0;
              *(_QWORD *)((char *)&v263[1] + 3) = v155;
LABEL_322:
              check_pqpush_AnnotatedPositionOffset_t(v157, (__int128 *)buf);
              goto LABEL_324;
            }
            *(_QWORD *)buf = v123;
            *(_QWORD *)&buf[8] = v156;
            *(_DWORD *)&buf[16] = v150;
            *(_DWORD *)&buf[20] = 0;
            v259 = v151;
            v260 = v153;
            v261 = v152;
            v262 = v154;
            v263[0] = 0;
            *(_DWORD *)((char *)v263 + 3) = 0;
            *(_QWORD *)((char *)&v263[1] + 3) = v155;
            check_oqpush_AnnotatedPositionOffset_t(v43 + 56, (uint64_t *)buf);
          }
          goto LABEL_324;
        }
        if (v149)
        {
          if (v149 == v44)
            goto LABEL_324;
          v169 = *(_DWORD *)(v43 + 48);
          v170 = *(_QWORD *)(v43 + 40);
          v172 = *(_DWORD *)(v43 + 148);
          v171 = *(_DWORD *)(v43 + 152);
          v173 = *(_BYTE *)(v43 + 156);
          v175 = *(_QWORD *)(v43 + 16);
          v174 = *(_QWORD *)(v43 + 24);
          if (v149 > v44 || v149 > *(_QWORD *)(v43 + 112))
          {
            if (v175)
              goto LABEL_386;
            if (v140 && (v149 <= v140 || v149 > v142))
              goto LABEL_389;
            v176 = *v252;
            if (*v252 >= v149)
              v176 = v149;
            *v252 = v176;
            v157 = v43 + 120;
            *(_QWORD *)buf = v149;
            *(_QWORD *)&buf[8] = v174;
            *(_DWORD *)&buf[16] = v169;
            *(_DWORD *)&buf[20] = 0;
            v259 = v170;
            v260 = v172;
            v261 = v171;
            v262 = v173;
            memset(v263, 0, 15);
            goto LABEL_322;
          }
          if (v175)
            goto LABEL_386;
          *(_QWORD *)buf = v149;
          *(_QWORD *)&buf[8] = v174;
          *(_DWORD *)&buf[16] = v169;
          *(_DWORD *)&buf[20] = 0;
          v259 = v170;
          v260 = v172;
          v261 = v171;
          v262 = v173;
          memset(v263, 0, 15);
          check_oqpush_AnnotatedPositionOffset_t(v43 + 56, (uint64_t *)buf);
          if (*(_QWORD *)(a1 + 72) > v149)
          {
            v195 = *(_QWORD *)(v43 + 8);
            if (v149 < v195 && v149 > v195 >> 1)
              *(_QWORD *)(a1 + 72) = v149;
          }
LABEL_324:
          *(_DWORD *)(v43 + 148) = 0;
          *(_QWORD *)v43 = 0;
          *(_QWORD *)(v43 + 16) = 0;
          *(_QWORD *)(v43 + 24) = 0;
          PositionIterator_GetNext(v43);
          if ((iterationIsLooping((uint64_t *)v43, v44) & 1) != 0)
            goto LABEL_359;
LABEL_325:
          v49 = *(_QWORD *)v43;
          if (*(_DWORD *)(v43 + 188))
          {
            if (!v49)
            {
LABEL_327:
              if (*(_QWORD *)(v43 + 80))
              {
LABEL_328:
                if (v251 == 1)
                {
                  v177 = *__error();
                  v178 = _SILogForLogForCategory(10);
                  v179 = 2 * (dword_1EF19FCB4 < 4);
                  if (os_log_type_enabled(v178, v179))
                  {
                    *(_WORD *)buf = 0;
                    _os_log_impl(&dword_1B8270000, v178, v179, "Out of postings, but we have more positions data (3); readers out of synch.",
                      buf,
                      2u);
                  }
                  *__error() = v177;
                }
                if (!*(_QWORD *)(v43 + 8))
                  goto LABEL_389;
                v181 = v12[2];
                v180 = v12[3];
                v182 = *(void **)v12;
                if (v180 >= v181)
                {
                  v12[2] = 2 * v181;
                  if (v182)
                    v183 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, v182, 16 * v181, 0xECA6AA46uLL);
                  else
                    v183 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 16 * v181, 0x8DDAA030uLL);
                  v182 = v183;
                  if (!v183)
                    _log_fault_for_malloc_failure();
                  *(_QWORD *)v12 = v182;
                  v180 = v12[3];
                }
                v12[3] = v180 + 1;
              }
              else
              {
LABEL_341:
                if (v251 == 1)
                {
                  v185 = *__error();
                  v186 = _SILogForLogForCategory(10);
                  v187 = 2 * (dword_1EF19FCB4 < 4);
                  if (os_log_type_enabled(v186, v187))
                  {
                    *(_WORD *)buf = 0;
                    _os_log_impl(&dword_1B8270000, v186, v187, "Out of postings, but we have more positions data(2); readers out of synch.",
                      buf,
                      2u);
                  }
                  *__error() = v185;
                }
                v188 = v249;
                v189 = *(_DWORD *)(v249 + 8);
                v180 = *(_DWORD *)(v249 + 12);
                v182 = *(void **)v249;
                if (v180 >= v189)
                {
                  *(_DWORD *)(v249 + 8) = 2 * v189;
                  if (v182)
                    v190 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, v182, 16 * v189, 0xECA6AA46uLL);
                  else
                    v190 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 16 * v189, 0x8DDAA030uLL);
                  v182 = v190;
                  if (!v190)
                    _log_fault_for_malloc_failure();
                  v188 = v249;
                  *(_QWORD *)v249 = v182;
                  v180 = *(_DWORD *)(v249 + 12);
                }
                *(_DWORD *)(v188 + 12) = v180 + 1;
              }
              *((_QWORD *)v182 + v180) = v43;
              goto LABEL_359;
            }
            goto LABEL_304;
          }
LABEL_336:
          if (!v49)
          {
            if (*(_QWORD *)(v43 + 80))
            {
LABEL_338:
              if (!*(_QWORD *)(v43 + 8))
                goto LABEL_389;
              if (*(_QWORD *)(v43 + 136) != 1)
                goto LABEL_386;
              v184 = *(_QWORD *)(a1 + 3336);
              *(_QWORD *)(a1 + 3336) = v184 + 1;
              *(_QWORD *)(a1 + 8 * v184 + 3352) = v43;
            }
            goto LABEL_359;
          }
          goto LABEL_84;
        }
      }
LABEL_323:
      instr_release(*(CFTypeRef *)(v43 + 24));
      goto LABEL_324;
    }
    if (!v44)
    {
      PositionIterator_GetNext(v43);
      *(_QWORD *)(v43 + 32) = 0;
LABEL_302:
      v49 = *(_QWORD *)v43;
      if (*(_DWORD *)(v43 + 188))
      {
        if (!v49)
          goto LABEL_327;
LABEL_304:
        if (v251 == 1)
        {
          v166 = *__error();
          v167 = _SILogForLogForCategory(10);
          v168 = 2 * (dword_1EF19FCB4 < 4);
          if (os_log_type_enabled(v167, v168))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_1B8270000, v167, v168, "Out of postings, but we have more positions data(1); readers out of synch.",
              buf,
              2u);
          }
          *__error() = v166;
        }
        if ((*(_QWORD *)v43 & 0x3FFFFFFFFFFFFFFFuLL) > *(_QWORD *)(a1 + 3328))
        {
          v50 = (uint64_t)v15;
          goto LABEL_310;
        }
        v237 = __si_assert_copy_extra(0);
        v235 = v237;
        v238 = "";
        if (v237)
          v238 = v237;
        __message_assert("%s:%u: Unexpected code path %s ", "PayloadIterator.c", 5339, v238);
LABEL_479:
        free(v235);
        goto LABEL_388;
      }
      goto LABEL_336;
    }
    if (v42 && (v44 <= v42 || v44 > 2 * v42))
      goto LABEL_386;
    if (dword_1EF19FCB4 >= 5)
    {
      v196 = *__error();
      v197 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v197, OS_LOG_TYPE_DEFAULT))
      {
        v198 = *(_QWORD *)(v43 + 24);
        *(_DWORD *)buf = 134218496;
        *(_QWORD *)&buf[4] = v43;
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = v44;
        *(_WORD *)&buf[22] = 2048;
        v259 = v198;
        _os_log_impl(&dword_1B8270000, v197, OS_LOG_TYPE_DEFAULT, "%p %llu %p", buf, 0x20u);
      }
      *__error() = v196;
      v54 = *(uint64_t **)(a1 + 408);
    }
    v57 = *(_QWORD *)(a1 + 32);
    v58 = v54[1];
    if (v44 < v57 || v58 + v57 <= v44 || v44 + 30 > v58 + v57)
    {
      *(_QWORD *)(a1 + 32) = v44 & 0x3FFFFFFFFFFFF000;
      if (fd_pread(*(_DWORD **)(v56 + 4480), v55, v58, v44 & 0x3FFFFFFFFFFFF000) == -1)
        goto LABEL_359;
      v59 = 0;
      *(_DWORD *)(a1 + 52) = 0;
      v57 = *(_QWORD *)(a1 + 32);
      v58 = *(_QWORD *)(*(_QWORD *)(a1 + 408) + 8);
    }
    else
    {
      v59 = *(_DWORD *)(a1 + 52) + 1;
      *(_DWORD *)(a1 + 52) = v59;
    }
    v257 = v44 - v57;
    if ((int)v44 - (int)v57 + 20 >= v58)
    {
      *(_QWORD *)(a1 + 32) = v44 & 0x3FFFFFFFFFFFF000;
      v63 = fd_pread(*(_DWORD **)(v56 + 4480), *(void **)(a1 + 24), v58, v44 & 0x3FFFFFFFFFFFF000);
      *(_DWORD *)(a1 + 52) = 0;
      v257 = v44 - *(_QWORD *)(a1 + 32);
      if (v63 == -1)
        goto LABEL_300;
    }
    else
    {
      *(_DWORD *)(a1 + 52) = v59 + 1;
    }
    v239 = SLReadPositionHeader((uint64_t)v55, (uint64_t *)&v257);
    v65 = v64;
    v66 = v257;
LABEL_135:
    v67 = *(_QWORD *)(*(_QWORD *)(a1 + 408) + 8);
    if ((int)v66 + 5 >= v67)
    {
      v69 = *(void **)(a1 + 24);
      v70 = *(_QWORD *)(a1 + 32) + v66;
      *(_QWORD *)(a1 + 32) = v70 & 0x3FFFFFFFFFFFF000;
      v71 = fd_pread(*(_DWORD **)(v56 + 4480), v69, v67, v70 & 0x3FFFFFFFFFFFF000);
      v68 = 0;
      *(_DWORD *)(a1 + 52) = 0;
      v66 = v70 - *(_QWORD *)(a1 + 32);
      if (v71 == -1)
        goto LABEL_170;
    }
    else
    {
      v68 = *(_DWORD *)(a1 + 52) + 1;
      *(_DWORD *)(a1 + 52) = v68;
    }
    v72 = v66 + 1;
    v73 = v55[v66];
    if (v73 < 0)
    {
      v74 = v66 + 2;
      v75 = (char)v55[v72];
      v76 = v55[v72];
      if (v75 < 0)
      {
        v77 = v66 + 3;
        v78 = (char)v55[v74];
        v79 = v78;
        if (v78 < 0)
        {
          v74 = v66 + 4;
          v80 = (char)v55[v77];
          v81 = v55[v77];
          if (v80 < 0)
          {
            v83 = (char)v55[v74];
            if (v83 < 0)
            {
              v204 = __si_assert_copy_extra(0);
              __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t");
              goto LABEL_390;
            }
            v84 = v83;
            v74 = v66 + 5;
            v82 = ((v81 & 0x7F) << 21) | (v84 << 28) | ((v79 & 0x7F) << 14);
          }
          else
          {
            v82 = ((v79 & 0x7F) << 14) | (v81 << 21);
          }
          if (v82 & 0xFFFFC000 | ((v76 & 0x7F) << 7) | v73 & 0x7F)
          {
            while (1)
            {
LABEL_152:
              v85 = *(_QWORD *)(*(_QWORD *)(a1 + 408) + 8);
              if ((int)v74 + 5 >= v85)
              {
                v86 = *(void **)(a1 + 24);
                v87 = *(_QWORD *)(a1 + 32) + v74;
                *(_QWORD *)(a1 + 32) = v87 & 0x3FFFFFFFFFFFF000;
                v88 = fd_pread(*(_DWORD **)(v56 + 4480), v86, v85, v87 & 0x3FFFFFFFFFFFF000);
                v68 = 0;
                *(_DWORD *)(a1 + 52) = 0;
                v66 = v87 - *(_QWORD *)(a1 + 32);
                v74 = v66;
                if (v88 == -1)
                  goto LABEL_135;
              }
              else
              {
                *(_DWORD *)(a1 + 52) = ++v68;
              }
              v89 = v74 + 1;
              v90 = v55[v74];
              if ((char)v55[v74] < 0)
              {
                v66 = v74 + 2;
                v91 = (char)v55[v89];
                v92 = v55[v89];
                if (v91 < 0)
                {
                  v93 = v74 + 3;
                  v94 = (char)v55[v66];
                  v95 = v94;
                  if (v94 < 0)
                  {
                    v66 = v74 + 4;
                    v97 = (char)v55[v93];
                    v98 = v55[v93];
                    if (v97 < 0)
                    {
                      v100 = (char)v55[v66];
                      if (v100 < 0)
                      {
                        v202 = __si_assert_copy_extra(0);
                        __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t");
LABEL_387:
                        free(v202);
                        if (__valid_fs(-1))
LABEL_388:
                          v203 = 2989;
                        else
                          v203 = 3072;
                        *(_DWORD *)v203 = -559038737;
                        abort();
                      }
                      v101 = v100;
                      v66 = v74 + 5;
                      v99 = ((v98 & 0x7F) << 21) | (v101 << 28) | ((v95 & 0x7F) << 14);
                    }
                    else
                    {
                      v99 = ((v95 & 0x7F) << 14) | (v98 << 21);
                    }
                    v96 = v99 & 0xFFFFC000 | ((v92 & 0x7F) << 7) | v90 & 0x7F;
                  }
                  else
                  {
                    v96 = ((v92 & 0x7F) << 7) | (v94 << 14) | v90 & 0x7F;
                    v66 = v93;
                  }
                  v90 = v96;
                }
                else
                {
                  v90 = v90 & 0x7F | (v92 << 7);
                }
              }
              else
              {
                v66 = v74 + 1;
              }
              v74 = v66;
              if (!v90)
                goto LABEL_135;
            }
          }
        }
        else
        {
          v74 = v66 + 3;
          if (((v76 & 0x7F) << 7) | (v79 << 14) | v73 & 0x7F)
            goto LABEL_152;
        }
      }
      else if (v73 & 0x7F | (v76 << 7))
      {
        goto LABEL_152;
      }
    }
    else
    {
      v74 = v66 + 1;
      if (v55[v66])
        goto LABEL_152;
    }
    v66 = v74;
LABEL_170:
    v257 = v66;
    v102 = v239;
    if (!(v65 | v239))
    {
      v102 = *(_QWORD *)(v43 + 16);
      *(_QWORD *)(v43 + 16) = 0;
    }
    v103 = *(_QWORD *)(v43 + 8);
    v104 = *(_QWORD *)(**(_QWORD **)(a1 + 408) + 32);
    v105 = 2 * v103;
    if (v103 >= v104)
      v104 = 2 * v103;
    if (v65 <= v44 && v65)
    {
      v106 = v44 <= v104 || v65 > v104;
      if (v106 && v65 >= v103)
        goto LABEL_389;
    }
    if (v102 - 1 < v44)
    {
      v108 = v44 <= v104 || v102 > v104;
      if (v108 && v102 >= v103)
        goto LABEL_389;
    }
    if (v102 - 1 < v65)
    {
      v110 = v65 <= v104 || v102 > v104;
      if (v110 && v102 >= v103)
        goto LABEL_389;
    }
    if (v65)
      v112 = 0;
    else
      v112 = v102;
    if (v65 && v102)
    {
      v112 = 0;
      *(_QWORD *)(v43 + 16) = v102;
    }
    if (!(v112 | v65))
    {
LABEL_300:
      instr_release(*(CFTypeRef *)(v43 + 24));
      goto LABEL_301;
    }
    if (v65)
    {
      if (v112)
        goto LABEL_386;
      if (v65 != v44)
      {
        v113 = *(_DWORD *)(v43 + 48);
        v114 = *(_QWORD *)(v43 + 40);
        v116 = *(_DWORD *)(v43 + 148);
        v115 = *(_DWORD *)(v43 + 152);
        v117 = *(_BYTE *)(v43 + 156);
        v118 = *(_QWORD *)(v43 + 16);
        v119 = *(_QWORD *)(v43 + 24);
        if (v65 > v44 || v65 > *(_QWORD *)(v43 + 112))
        {
          if (v103 && (v65 <= v103 || v65 > v105))
            goto LABEL_389;
          v120 = v43 + 120;
          *(_QWORD *)buf = v65;
          *(_QWORD *)&buf[8] = v119;
          *(_DWORD *)&buf[16] = v113;
          *(_DWORD *)&buf[20] = 0;
          v259 = v114;
          v260 = v116;
          v261 = v115;
          v262 = v117;
          v263[0] = 0;
          *(_DWORD *)((char *)v263 + 3) = 0;
          *(_QWORD *)((char *)&v263[1] + 3) = v118;
LABEL_299:
          check_pqpush_AnnotatedPositionOffset_t(v120, (__int128 *)buf);
          goto LABEL_301;
        }
        *(_QWORD *)buf = v65;
        *(_QWORD *)&buf[8] = v119;
        *(_DWORD *)&buf[16] = v113;
        *(_DWORD *)&buf[20] = 0;
        v259 = v114;
        v260 = v116;
        v261 = v115;
        v262 = v117;
        v263[0] = 0;
        *(_DWORD *)((char *)v263 + 3) = 0;
        *(_QWORD *)((char *)&v263[1] + 3) = v118;
        check_oqpush_AnnotatedPositionOffset_t(v43 + 56, (uint64_t *)buf);
      }
    }
    else
    {
      if (!v112)
        goto LABEL_300;
      if (v112 == v44)
        goto LABEL_301;
      v158 = *(_DWORD *)(v43 + 48);
      v159 = *(_QWORD *)(v43 + 40);
      v161 = *(_DWORD *)(v43 + 148);
      v160 = *(_DWORD *)(v43 + 152);
      v162 = *(_BYTE *)(v43 + 156);
      v164 = *(_QWORD *)(v43 + 16);
      v163 = *(_QWORD *)(v43 + 24);
      if (v112 > v44 || v112 > *(_QWORD *)(v43 + 112))
      {
        if (v164)
          goto LABEL_386;
        if (v103 && (v112 <= v103 || v112 > v105))
          goto LABEL_389;
        v165 = *v252;
        if (*v252 >= v112)
          v165 = v112;
        *v252 = v165;
        v120 = v43 + 120;
        *(_QWORD *)buf = v112;
        *(_QWORD *)&buf[8] = v163;
        *(_DWORD *)&buf[16] = v158;
        *(_DWORD *)&buf[20] = 0;
        v259 = v159;
        v260 = v161;
        v261 = v160;
        v262 = v162;
        memset(v263, 0, 15);
        goto LABEL_299;
      }
      if (v164)
        goto LABEL_389;
      *(_QWORD *)buf = v112;
      *(_QWORD *)&buf[8] = v163;
      *(_DWORD *)&buf[16] = v158;
      *(_DWORD *)&buf[20] = 0;
      v259 = v159;
      v260 = v161;
      v261 = v160;
      v262 = v162;
      memset(v263, 0, 15);
      check_oqpush_AnnotatedPositionOffset_t(v43 + 56, (uint64_t *)buf);
      if (*(_QWORD *)(a1 + 72) > v112)
      {
        v194 = *(_QWORD *)(v43 + 8);
        if (v112 < v194 && v112 > v194 >> 1)
          *(_QWORD *)(a1 + 72) = v112;
      }
    }
LABEL_301:
    *(_DWORD *)(v43 + 148) = 0;
    *(_QWORD *)v43 = 0;
    *(_QWORD *)(v43 + 16) = 0;
    *(_QWORD *)(v43 + 24) = 0;
    PositionIterator_GetNext(v43);
    if ((iterationIsLooping((uint64_t *)v43, v44) & 1) == 0)
      goto LABEL_302;
LABEL_359:
    if (*a7)
      goto LABEL_406;
    v16 = *(_QWORD *)(a1 + 16);
    if (v16 == 1 && v15[2] == 1 && !*(_QWORD *)(a1 + 3336) && !v12[3])
      goto LABEL_397;
  }
  v45 = (unint64_t *)ipqpop((_QWORD *)a1);
  v42 = v45[1];
  if (v42 != *(_QWORD *)(a1 + 3328))
    goto LABEL_389;
  v43 = (uint64_t)v45;
  v44 = *v45;
  if (v42)
  {
    if (v44 <= v42 || v44 > 2 * v42)
      goto LABEL_389;
  }
  if (v44 != *v252)
    goto LABEL_78;
  ipqpush(a1, (uint64_t)v45);
  if (dword_1EF19FCB4 >= 5)
  {
    v219 = *__error();
    v220 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v220, OS_LOG_TYPE_DEFAULT))
    {
      v221 = *(_QWORD *)(v43 + 24);
      v222 = *(_QWORD *)v43;
      *(_DWORD *)buf = 134218496;
      *(_QWORD *)&buf[4] = v43;
      *(_WORD *)&buf[12] = 2048;
      *(_QWORD *)&buf[14] = v221;
      *(_WORD *)&buf[22] = 2048;
      v259 = v222;
      _os_log_impl(&dword_1B8270000, v220, OS_LOG_TYPE_DEFAULT, "Pushback; pq we are done with a generation %p %p %llu",
        buf,
        0x20u);
    }
    *__error() = v219;
  }
LABEL_397:
  if (!*a7)
  {
    if (dword_1EF19FCB4 <= 4)
    {
      *a3 = *(_DWORD *)(a1 + 80);
      goto LABEL_400;
    }
    v223 = *__error();
    v224 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v224, OS_LOG_TYPE_DEFAULT))
    {
      v225 = *a3;
      v226 = *(_DWORD *)(a1 + 80);
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)&buf[4] = v225;
      *(_WORD *)&buf[8] = 1024;
      *(_DWORD *)&buf[10] = v226;
      _os_log_impl(&dword_1B8270000, v224, OS_LOG_TYPE_DEFAULT, "Expected start: %d Actual start: %d", buf, 0xEu);
    }
    *__error() = v223;
    v227 = dword_1EF19FCB4;
    v206 = v242;
    *a3 = *(_DWORD *)(a1 + 80);
    if (v227 >= 5)
    {
      v228 = *__error();
      v229 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v229, OS_LOG_TYPE_DEFAULT))
      {
        v230 = v15[2] - 1;
        v231 = *(_DWORD *)(v249 + 12);
        *(_DWORD *)buf = 134218240;
        *(_QWORD *)&buf[4] = v230;
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v231;
        _os_log_impl(&dword_1B8270000, v229, OS_LOG_TYPE_DEFAULT, "Pullback! %ld + %d", buf, 0x12u);
      }
      *__error() = v228;
LABEL_400:
      v206 = v242;
    }
    if (v206 != *(_QWORD *)(a1 + 3328) && (v15[2] != 1 || *(_DWORD *)(v249 + 12) || v12[3]))
    {
      if (dword_1EF19FCB4 >= 5)
      {
        v232 = *__error();
        v233 = _SILogForLogForCategory(10);
        if (os_log_type_enabled(v233, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_1B8270000, v233, OS_LOG_TYPE_DEFAULT, "Un-split", buf, 2u);
        }
        *__error() = v232;
        v206 = v242;
      }
      *(_QWORD *)(a1 + 3328) = v206;
      while (*(_QWORD *)(a1 + 16) != 1
           && (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)a1 + 8) + 8) & 0x3FFFFFFFFFFFFFFFuLL) < v206)
      {
        v210 = ipqpop((_QWORD *)a1);
        v211 = *(_QWORD *)(a1 + 3336);
        *(_QWORD *)(a1 + 3336) = v211 + 1;
        *(_QWORD *)(a1 + 8 * v211 + 3352) = v210;
      }
    }
    if (v251 == 1 && (v15[2] != 1 || *(_DWORD *)(v249 + 12) || v12[3]))
    {
LABEL_386:
      v202 = __si_assert_copy_extra(0);
      __message_assert("%s:%u: failed assertion '%s' %s ");
      goto LABEL_387;
    }
  }
LABEL_406:
  CICleanUpClearItem(v248, v243);
  while (v15[2] != 1)
  {
    v207 = ipqpop(v15);
    BulkPullback(v15[3], v207);
  }
  free((void *)*v15);
  free(v15);
  CICleanUpClearItem(v248, v244);
  _deferredArrayCleanup((uint64_t)v12);
  CICleanUpClearItem(v248, v245);
  _deferredArrayCleanup(v249);
  CICleanUpReset(v248, v246);
  v208 = (*(_QWORD *)(a1 + 16) != 1 || *(_QWORD *)(a1 + 3336)) && *a7 == 0;
  CICleanUpClearItem(v248, v247);
  CIIndexSetDisposePerThreadCache(&v253);
  return v208;
}

void _deferredArrayExceptionCleanup(void **a1)
{
  free(*a1);
  free(a1);
}

void _deferredExceptionCleanup(void **a1)
{
  free(*a1);
  free(a1);
}

void PositionIterator_Resplit(_QWORD *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  __int128 v10;
  uint64_t v11;
  unint64_t v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  __int128 v25;
  uint64_t v26;
  unint64_t v27;
  __int128 v28;
  __int128 *v30;
  uint64_t v36;
  __int128 v37;
  uint64_t v38;
  __int128 v39;
  BOOL v40;
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  unint64_t *v46;
  uint64_t v47;
  unint64_t v48;
  char *v49;
  char *v50;
  const char *v51;
  uint64_t v52;
  _OWORD v53[3];
  uint64_t v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  _OWORD v61[3];

  if (!a2 || a1[14] == a2)
    return;
  a1[1] = a2;
  v4 = a1[8];
  if (v4)
  {
    memmove((void *)(v4 + 56 * a1[10]), (const void *)(v4 + 56 * a1[11]), 56 * (a1[12] - a1[11]));
    a1[10] += a1[12] - a1[11];
    oqsplit_AnnotatedPositionOffset_t((uint64_t)(a1 + 7), a2);
    memmove((void *)(a1[8] + 56 * (a1[9] - a1[12] + a1[11])), (const void *)(a1[8] + 56 * a1[10]), 56 * (a1[12] - a1[11]));
    v5 = a1[9];
    a1[11] += v5 - a1[12];
    a1[12] = v5;
  }
  v6 = a1[17];
  v7 = v6 - 1;
  if (v6 == 1)
    goto LABEL_28;
  do
  {
    v8 = a1[15];
    if (v8)
      v9 = *(_QWORD *)(v8 + 56);
    else
      v9 = 0;
    if (v9 >= a2)
      break;
    v10 = *(_OWORD *)(v8 + 72);
    v53[0] = *(_OWORD *)(v8 + 56);
    v53[1] = v10;
    v53[2] = *(_OWORD *)(v8 + 88);
    v54 = *(_QWORD *)(v8 + 104);
    v11 = v8 + 56 * v7;
    v12 = *(_QWORD *)v11;
    v14 = *(_OWORD *)(v11 + 24);
    v55 = *(_OWORD *)(v11 + 8);
    v13 = v55;
    v56 = v14;
    v15 = *(_OWORD *)(v11 + 40);
    *(_QWORD *)(v8 + 56) = v12;
    *(_OWORD *)(v8 + 80) = v14;
    *(_OWORD *)(v8 + 96) = v15;
    *(_OWORD *)(v8 + 64) = v13;
    v17 = a1[16];
    v16 = a1[17];
    v57 = v15;
    a1[17] = v16 - 1;
    v18 = v17 >> 1;
    v19 = 1;
    v20 = 2;
    v21 = 3;
    while (1)
    {
      v22 = a1[15];
      v23 = v22 + 56 * v20;
      v24 = *(_QWORD *)v23;
      v25 = *(_OWORD *)(v23 + 24);
      v61[0] = *(_OWORD *)(v23 + 8);
      v61[1] = v25;
      v61[2] = *(_OWORD *)(v23 + 40);
      v26 = v22 + 56 * v21;
      v27 = *(_QWORD *)v26;
      v28 = *(_OWORD *)(v26 + 24);
      v58 = *(_OWORD *)(v26 + 8);
      v59 = v28;
      v60 = *(_OWORD *)(v26 + 40);
      if (v21 >= v16)
      {
        v58 = xmmword_1B8631588;
        v59 = unk_1B8631598;
        v60 = xmmword_1B86315A8;
        if (v20 >= v16)
          goto LABEL_27;
        v27 = 0xBFFFFFFFFFFFFFFFLL;
      }
      if (v24 < v12)
      {
        _CF = v27 >= v24;
        if (v27 < v24)
        {
          v30 = &v58;
        }
        else
        {
          v27 = v24;
          v30 = v61;
        }
        if (_CF)
          v21 = v20;
        goto LABEL_19;
      }
      if (v27 >= v12)
        break;
      v30 = &v58;
LABEL_19:
      _X15 = v22 + 112 * v21;
      __asm { PRFM            #1, [X15] }
      if (v21 != v19)
      {
        v36 = v22 + 56 * v21;
        *(_QWORD *)v36 = v12;
        v37 = v56;
        *(_OWORD *)(v36 + 8) = v55;
        *(_OWORD *)(v36 + 24) = v37;
        *(_OWORD *)(v36 + 40) = v57;
        v38 = a1[15] + 56 * v19;
        v39 = v30[1];
        *(_OWORD *)(v38 + 8) = *v30;
        v20 = 2 * v21;
        v19 = v21;
        *(_QWORD *)v38 = v27;
        *(_OWORD *)(v38 + 24) = v39;
        *(_OWORD *)(v38 + 40) = v30[2];
        v40 = v21 < v18;
        v21 = (2 * v21) | 1;
        if (v40)
          continue;
      }
      goto LABEL_27;
    }
    _X8 = v22 + 112 * v19;
    __asm { PRFM            #1, [X8] }
LABEL_27:
    check_oqpush_AnnotatedPositionOffset_t((uint64_t)(a1 + 7), (uint64_t *)v53);
    v6 = a1[17];
    v7 = v6 - 1;
  }
  while (v6 != 1);
LABEL_28:
  v43 = a1[1];
  if (v43)
  {
    v44 = v6 <= 1 ? 1 : v6;
    if (v6 >= 2)
    {
      v45 = 2 * v43;
      v46 = (unint64_t *)(a1[15] + 56);
      v47 = v44 - 1;
      do
      {
        v48 = *v46;
        v46 += 7;
        if (v48 > v45)
        {
          v49 = __si_assert_copy_extra(0);
          v50 = v49;
          v51 = "";
          if (v49)
            v51 = v49;
          __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 2194, "iter->futureOffsets._offsets[i].offset<=iter->split*2", v51);
          free(v50);
          if (__valid_fs(-1))
            v52 = 2989;
          else
            v52 = 3072;
          *(_DWORD *)v52 = -559038737;
          abort();
        }
        --v47;
      }
      while (v47);
    }
  }
}

uint64_t CIReadPositionHeader(uint64_t a1, uint64_t *a2)
{
  int64_t VInt64;
  uint64_t v5;
  char *v7;
  char *v8;
  const char *v9;
  uint64_t v10;

  VInt64 = v2_readVInt64(a1, a2);
  if ((VInt64 & 1) != 0)
  {
    v5 = VInt64 >> 1;
    LOBYTE(VInt64) = v2_readVInt64(a1, a2);
  }
  else
  {
    v5 = 0;
  }
  if ((VInt64 & 1) != 0)
  {
    v7 = __si_assert_copy_extra(0);
    v8 = v7;
    v9 = "";
    if (v7)
      v9 = v7;
    __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.h", 279, "(value & 1) == 0", v9);
    free(v8);
    if (__valid_fs(-1))
      v10 = 2989;
    else
      v10 = 3072;
    *(_DWORD *)v10 = -559038737;
    abort();
  }
  return v5;
}

__n128 check_pqpush_AnnotatedPositionOffset_t(uint64_t a1, __int128 *a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  size_t v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  __n128 result;
  uint64_t v12;
  uint64_t v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;
  BOOL v18;
  char *v19;
  char *v20;
  const char *v21;
  uint64_t v22;
  __int128 v23;
  __int128 v24;
  __n128 v25;
  uint64_t v26;
  __int128 v27;
  __int128 v28;
  __n128 v29;
  uint64_t v30;

  if (!*(_QWORD *)a2)
  {
    v19 = __si_assert_copy_extra(0);
    v20 = v19;
    v21 = "";
    if (v19)
      v21 = v19;
    __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 2159, "value.offset!=0", v21);
    free(v20);
    if (__valid_fs(-1))
      v22 = 2989;
    else
      v22 = 3072;
    *(_DWORD *)v22 = -559038737;
    abort();
  }
  v23 = *a2;
  v24 = a2[1];
  v25 = (__n128)a2[2];
  v26 = *((_QWORD *)a2 + 6);
  v3 = *(_QWORD *)(a1 + 8);
  v4 = *(_QWORD *)(a1 + 16);
  v5 = v4;
  if ((uint64_t)(v4 + 2) >= v3)
  {
    v6 = 2 * v3;
    if (v3 < 4)
      v6 = 4;
    *(_QWORD *)(a1 + 8) = v6;
    v7 = 56 * v6 + 112;
    if (*(_QWORD *)a1)
      v8 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, *(void **)a1, v7, 0xECA6AA46uLL);
    else
      v8 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v7, 0x8DDAA030uLL);
    v9 = v8;
    if (!v8)
      _log_fault_for_malloc_failure();
    *(_QWORD *)a1 = v9;
    v9[6] = 0;
    *((_OWORD *)v9 + 1) = 0u;
    *((_OWORD *)v9 + 2) = 0u;
    *(_OWORD *)v9 = 0u;
    v5 = *(_QWORD *)(a1 + 16);
  }
  *(_QWORD *)(a1 + 16) = v5 + 1;
  v10 = *(_QWORD *)a1 + 56 * v4;
  *(_OWORD *)v10 = v23;
  *(_OWORD *)(v10 + 16) = v24;
  result = v25;
  *(__n128 *)(v10 + 32) = v25;
  *(_QWORD *)(v10 + 48) = v26;
  if ((uint64_t)v4 >= 2)
  {
    do
    {
      v12 = *(_QWORD *)a1 + 56 * v4;
      v13 = *(_QWORD *)a1 + 56 * (v4 >> 1);
      if (*(_QWORD *)v12 > *(_QWORD *)v13)
        break;
      v27 = *(_OWORD *)v12;
      v28 = *(_OWORD *)(v12 + 16);
      v29 = *(__n128 *)(v12 + 32);
      v30 = *(_QWORD *)(v12 + 48);
      v15 = *(_OWORD *)(v13 + 16);
      v14 = *(_OWORD *)(v13 + 32);
      v16 = *(_OWORD *)v13;
      *(_QWORD *)(v12 + 48) = *(_QWORD *)(v13 + 48);
      *(_OWORD *)(v12 + 16) = v15;
      *(_OWORD *)(v12 + 32) = v14;
      *(_OWORD *)v12 = v16;
      v17 = *(_QWORD *)a1 + 56 * (v4 >> 1);
      *(_OWORD *)v17 = v27;
      *(_OWORD *)(v17 + 16) = v28;
      result = v29;
      *(__n128 *)(v17 + 32) = v29;
      *(_QWORD *)(v17 + 48) = v30;
      v18 = v4 > 3;
      v4 >>= 1;
    }
    while (v18);
  }
  return result;
}

__n128 check_oqpush_AnnotatedPositionOffset_t(uint64_t a1, uint64_t *a2)
{
  unint64_t v2;
  uint64_t v4;
  char *v5;
  char *v6;
  const char *v7;
  const char *v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  size_t v12;
  void *v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  __n128 result;
  char *v18;
  const char *v19;
  char *v20;
  uint64_t v21;
  __int128 v22;
  __int128 v23;
  __n128 v24;

  v2 = *a2;
  if (!*a2)
  {
    v18 = __si_assert_copy_extra(0);
    v6 = v18;
    v19 = "";
    if (v18)
      v19 = v18;
    __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 2165, "value.offset!=0", v19);
LABEL_25:
    free(v6);
    if (__valid_fs(-1))
      v21 = 2989;
    else
      v21 = 3072;
    *(_DWORD *)v21 = -559038737;
    abort();
  }
  v22 = *(_OWORD *)(a2 + 1);
  v23 = *(_OWORD *)(a2 + 3);
  v24 = *(__n128 *)(a2 + 5);
  if (*(_DWORD *)(a1 + 48))
  {
    if (*(_QWORD *)(a1 + 56) < v2)
    {
      v20 = __si_assert_copy_extra(0);
      v6 = v20;
      v7 = "";
      if (v20)
        v7 = v20;
      v8 = "!queue->split || queue->splitPoint >= AnnotatedPositionOffset_t_GET_VALUE(value)";
      goto LABEL_24;
    }
    v4 = *(_QWORD *)(a1 + 24);
    if (v4 >= *(_QWORD *)(a1 + 16))
    {
      v5 = __si_assert_copy_extra(0);
      v6 = v5;
      v7 = "";
      if (v5)
        v7 = v5;
      v8 = "!queue->split";
LABEL_24:
      __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.h", 25, v8, v7);
      goto LABEL_25;
    }
  }
  else
  {
    v9 = *(_QWORD *)(a1 + 16);
    v4 = *(_QWORD *)(a1 + 24);
    if (v4 >= v9)
    {
      v10 = 2 * v9;
      if (!v9)
        v10 = 4;
      *(_QWORD *)(a1 + 16) = v10;
      v11 = *(void **)(a1 + 8);
      v12 = 56 * v10;
      if (v11)
        v13 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, v11, v12, 0xECA6AA46uLL);
      else
        v13 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v12, 0x8DDAA030uLL);
      v14 = v13;
      if (!v13)
        _log_fault_for_malloc_failure();
      *(_QWORD *)(a1 + 8) = v14;
      v4 = *(_QWORD *)(a1 + 24);
    }
  }
  v15 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 24) = v4 + 1;
  v16 = v15 + 56 * v4;
  *(_QWORD *)v16 = v2;
  *(_OWORD *)(v16 + 8) = v22;
  *(_OWORD *)(v16 + 24) = v23;
  result = v24;
  *(__n128 *)(v16 + 40) = v24;
  return result;
}

uint64_t PositionIterator_GetNext(uint64_t result)
{
  unint64_t v1;
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  char v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  __int128 v28;
  uint64_t v29;
  unint64_t v30;
  __int128 v31;
  __int128 *v33;
  uint64_t v39;
  uint64_t v40;
  __int128 v41;
  uint64_t v42;
  uint64_t v43;
  char *v44;
  char *v45;
  const char *v46;
  unint64_t v47;
  uint64_t v48;
  unint64_t v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  unint64_t v60;
  __int128 v61;
  uint64_t v62;
  unint64_t v63;
  __int128 v64;
  BOOL v65;
  __int128 *v66;
  uint64_t v69;
  uint64_t v70;
  __int128 v71;
  char *v74;
  char *v75;
  const char *v76;
  BOOL v79;
  char *v81;
  const char *v82;
  char *v83;
  const char *v84;
  uint64_t v85;
  char *v86;
  const char *v87;
  uint64_t v88;
  char *v89;
  const char *v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;

  v1 = *(_QWORD *)result;
  if (*(_QWORD *)result)
  {
    v2 = *(_QWORD *)(result + 8);
    if (v2)
    {
      v3 = 2 * v2;
      goto LABEL_63;
    }
    return result;
  }
  v4 = *(_QWORD *)(result + 136);
  v6 = *(_QWORD *)(result + 88);
  v5 = *(_QWORD *)(result + 96);
  v7 = v4 - 1;
  if (v4 == 1)
  {
    if (v5 == v6)
      return result;
    if (v6 >= v5
      || (v42 = *(_QWORD *)(result + 64),
          *(_QWORD *)(result + 88) = v6 + 1,
          v43 = v42 + 56 * v6,
          (v1 = *(_QWORD *)v43) == 0))
    {
      v44 = __si_assert_copy_extra(0);
      v45 = v44;
      v46 = "";
      if (v44)
        v46 = v44;
      __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 2291, "tmp.offset", v46);
      goto LABEL_74;
    }
LABEL_50:
    v14 = *(_QWORD *)(v43 + 48);
    v13 = *(_BYTE *)(v43 + 40);
    v12 = *(_QWORD *)(v43 + 32);
    v11 = *(_QWORD *)(v43 + 24);
    v10 = *(_DWORD *)(v43 + 16);
    v9 = *(_QWORD *)(v43 + 8);
    goto LABEL_58;
  }
  v8 = *(_QWORD *)(result + 120);
  if (v5 == v6)
  {
    v1 = *(_QWORD *)(v8 + 56);
    v9 = *(_QWORD *)(v8 + 64);
    v10 = *(_DWORD *)(v8 + 72);
    v11 = *(_QWORD *)(v8 + 80);
    v12 = *(_QWORD *)(v8 + 88);
    v13 = *(_BYTE *)(v8 + 96);
    v14 = *(_QWORD *)(v8 + 104);
    v15 = v8 + 56 * v7;
    v16 = *(_QWORD *)v15;
    v17 = *(_OWORD *)(v15 + 8);
    v18 = *(_OWORD *)(v15 + 24);
    v19 = *(_OWORD *)(v15 + 40);
    *(_QWORD *)(v8 + 56) = *(_QWORD *)v15;
    *(_OWORD *)(v8 + 64) = v17;
    *(_OWORD *)(v8 + 80) = v18;
    *(_OWORD *)(v8 + 96) = v19;
    v20 = *(_QWORD *)(result + 136);
    v21 = *(uint64_t *)(result + 128) >> 1;
    v91 = v18;
    *(_QWORD *)(result + 136) = v20 - 1;
    v22 = 3;
    v23 = 2;
    v24 = 1;
    while (1)
    {
      v25 = *(_QWORD *)(result + 120);
      v26 = v25 + 56 * v23;
      v27 = *(_QWORD *)v26;
      v28 = *(_OWORD *)(v26 + 24);
      v96 = *(_OWORD *)(v26 + 8);
      v97 = v28;
      v98 = *(_OWORD *)(v26 + 40);
      v29 = v25 + 56 * v22;
      v30 = *(_QWORD *)v29;
      v31 = *(_OWORD *)(v29 + 24);
      v93 = *(_OWORD *)(v29 + 8);
      v94 = v31;
      v95 = *(_OWORD *)(v29 + 40);
      if (v22 >= v20)
      {
        v93 = xmmword_1B8631588;
        v94 = unk_1B8631598;
        v95 = xmmword_1B86315A8;
        if (v23 >= v20)
          goto LABEL_52;
        v30 = 0xBFFFFFFFFFFFFFFFLL;
      }
      if (v27 >= v16)
      {
        if (v30 >= v16)
        {
          _X14 = v25 + 112 * v24;
          __asm { PRFM            #1, [X14] }
LABEL_52:
          if (!v1)
          {
            v74 = __si_assert_copy_extra(0);
            v75 = v74;
            v76 = "";
            if (v74)
              v76 = v74;
            __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 2299, "tmp.offset", v76);
            goto LABEL_81;
          }
          goto LABEL_58;
        }
        v33 = &v93;
      }
      else
      {
        _CF = v30 >= v27;
        if (v30 < v27)
        {
          v33 = &v93;
        }
        else
        {
          v30 = v27;
          v33 = &v96;
        }
        if (_CF)
          v22 = v23;
      }
      _X20 = v25 + 112 * v22;
      __asm { PRFM            #1, [X20] }
      if (v22 != v24)
      {
        v39 = v25 + 56 * v22;
        *(_QWORD *)v39 = v16;
        *(_OWORD *)(v39 + 8) = v17;
        *(_OWORD *)(v39 + 24) = v91;
        *(_OWORD *)(v39 + 40) = v19;
        v40 = *(_QWORD *)(result + 120) + 56 * v24;
        v41 = v33[1];
        *(_OWORD *)(v40 + 8) = *v33;
        v23 = 2 * v22;
        v24 = v22;
        *(_QWORD *)v40 = v30;
        *(_OWORD *)(v40 + 24) = v41;
        *(_OWORD *)(v40 + 40) = v33[2];
        v79 = v22 < v21;
        v22 = (2 * v22) | 1;
        if (v79)
          continue;
      }
      goto LABEL_52;
    }
  }
  if (v8)
    v47 = *(_QWORD *)(v8 + 56);
  else
    v47 = 0;
  if (v6 >= v5)
  {
LABEL_85:
    v89 = __si_assert_copy_extra(0);
    v45 = v89;
    v90 = "";
    if (v89)
      v90 = v89;
    __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 2284, "tmp.offset", v90);
    goto LABEL_74;
  }
  v43 = *(_QWORD *)(result + 64) + 56 * v6;
  v1 = *(_QWORD *)v43;
  if (v47 >= *(_QWORD *)v43)
  {
    *(_QWORD *)(result + 88) = v6 + 1;
    if (v1)
      goto LABEL_50;
    goto LABEL_85;
  }
  v1 = *(_QWORD *)(v8 + 56);
  v9 = *(_QWORD *)(v8 + 64);
  v10 = *(_DWORD *)(v8 + 72);
  v11 = *(_QWORD *)(v8 + 80);
  v12 = *(_QWORD *)(v8 + 88);
  v13 = *(_BYTE *)(v8 + 96);
  v14 = *(_QWORD *)(v8 + 104);
  v48 = v8 + 56 * v7;
  v49 = *(_QWORD *)v48;
  v50 = *(_OWORD *)(v48 + 8);
  v51 = *(_OWORD *)(v48 + 24);
  v52 = *(_OWORD *)(v48 + 40);
  *(_QWORD *)(v8 + 56) = *(_QWORD *)v48;
  *(_OWORD *)(v8 + 64) = v50;
  *(_OWORD *)(v8 + 80) = v51;
  *(_OWORD *)(v8 + 96) = v52;
  v53 = *(_QWORD *)(result + 136);
  v54 = *(uint64_t *)(result + 128) >> 1;
  v92 = v51;
  *(_QWORD *)(result + 136) = v53 - 1;
  v55 = 3;
  v56 = 2;
  v57 = 1;
  while (1)
  {
    v58 = *(_QWORD *)(result + 120);
    v59 = v58 + 56 * v56;
    v60 = *(_QWORD *)v59;
    v61 = *(_OWORD *)(v59 + 24);
    v96 = *(_OWORD *)(v59 + 8);
    v97 = v61;
    v98 = *(_OWORD *)(v59 + 40);
    v62 = v58 + 56 * v55;
    v63 = *(_QWORD *)v62;
    v64 = *(_OWORD *)(v62 + 24);
    v93 = *(_OWORD *)(v62 + 8);
    v94 = v64;
    v95 = *(_OWORD *)(v62 + 40);
    if (v55 >= v53)
    {
      v93 = xmmword_1B8631588;
      v94 = unk_1B8631598;
      v95 = xmmword_1B86315A8;
      if (v56 >= v53)
        goto LABEL_57;
      v63 = 0xBFFFFFFFFFFFFFFFLL;
    }
    if (v60 < v49)
    {
      v65 = v63 >= v60;
      if (v63 < v60)
      {
        v66 = &v93;
      }
      else
      {
        v63 = v60;
        v66 = &v96;
      }
      if (v65)
        v55 = v56;
      goto LABEL_42;
    }
    if (v63 >= v49)
      break;
    v66 = &v93;
LABEL_42:
    _X20 = v58 + 112 * v55;
    __asm { PRFM            #1, [X20] }
    if (v55 != v57)
    {
      v69 = v58 + 56 * v55;
      *(_QWORD *)v69 = v49;
      *(_OWORD *)(v69 + 8) = v50;
      *(_OWORD *)(v69 + 24) = v92;
      *(_OWORD *)(v69 + 40) = v52;
      v70 = *(_QWORD *)(result + 120) + 56 * v57;
      v71 = v66[1];
      *(_OWORD *)(v70 + 8) = *v66;
      v56 = 2 * v55;
      v57 = v55;
      *(_QWORD *)v70 = v63;
      *(_OWORD *)(v70 + 24) = v71;
      *(_OWORD *)(v70 + 40) = v66[2];
      v79 = v55 < v54;
      v55 = (2 * v55) | 1;
      if (v79)
        continue;
    }
    goto LABEL_57;
  }
  _X14 = v58 + 112 * v57;
  __asm { PRFM            #1, [X14] }
LABEL_57:
  if (!v1)
  {
    v86 = __si_assert_copy_extra(0);
    v75 = v86;
    v87 = "";
    if (v86)
      v87 = v86;
    __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 2278, "tmp.offset", v87);
LABEL_81:
    free(v75);
    if (__valid_fs(-1))
      v88 = 2989;
    else
      v88 = 3072;
    *(_DWORD *)v88 = -559038737;
    abort();
  }
LABEL_58:
  *(_QWORD *)result = v1;
  *(_DWORD *)(result + 48) = v10;
  *(_QWORD *)(result + 40) = v11;
  *(_BYTE *)(result + 156) = v13;
  *(_QWORD *)(result + 148) = v12;
  *(_QWORD *)(result + 16) = v14;
  *(_QWORD *)(result + 24) = v9;
  v2 = *(_QWORD *)(result + 8);
  if (v2)
  {
    v3 = 2 * v2;
    v79 = v1 <= v2 || v1 > v3;
    if (v79)
    {
      v83 = __si_assert_copy_extra(0);
      v45 = v83;
      v84 = "";
      if (v83)
        v84 = v83;
      __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 2306, "iter->ptr > iter->split && iter->ptr <= iter->split*2", v84);
    }
    else
    {
LABEL_63:
      if (v1 > v2 && v1 <= v3)
        return result;
      v81 = __si_assert_copy_extra(0);
      v45 = v81;
      v82 = "";
      if (v81)
        v82 = v81;
      __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.c", 2310, "iter->ptr > iter->split && iter->ptr <= iter->split*2", v82);
    }
LABEL_74:
    free(v45);
    if (__valid_fs(-1))
      v85 = 2989;
    else
      v85 = 3072;
    *(_DWORD *)v85 = -559038737;
    abort();
  }
  return result;
}

uint64_t iterationIsLooping(uint64_t *a1, uint64_t a2)
{
  unint64_t v4;
  int v5;
  NSObject *v6;
  uint64_t result;
  uint64_t v8;
  int v9;
  const char *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  uint64_t v14;
  __int16 v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (a2 && *a1 == a2)
  {
    v4 = a1[4] + 1;
    a1[4] = v4;
    if (v4 < 0x3E9)
    {
      return 0;
    }
    else
    {
      v5 = *__error();
      v6 = _SILogForLogForCategory(1);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        v8 = *a1;
        v9 = 136315906;
        v10 = "iterationIsLooping";
        v11 = 1024;
        v12 = 2624;
        v13 = 2048;
        v14 = v8;
        v15 = 2048;
        v16 = a2;
        _os_log_error_impl(&dword_1B8270000, v6, OS_LOG_TYPE_ERROR, "%s:%d: %llx==%llx", (uint8_t *)&v9, 0x26u);
      }
      *__error() = v5;
      return 1;
    }
  }
  else
  {
    result = 0;
    a1[4] = 0;
  }
  return result;
}

uint64_t SLReadPositionHeader(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  char v5;
  BOOL v6;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  char v10;
  char *v11;
  char *v12;
  const char *v13;
  uint64_t v14;

  v2 = 0;
  v3 = 0;
  v4 = *a2;
  do
  {
    v5 = *(_BYTE *)(a1 + v4++);
    v3 |= (unint64_t)(v5 & 0x7F) << v2;
    if ((v5 & 0x80) == 0)
      break;
    v6 = v2 == 63;
    v2 += 7;
  }
  while (!v6);
  *a2 = v4;
  if ((v3 & 1) != 0)
  {
    v9 = 0;
    v8 = 0;
    do
    {
      v10 = *(_BYTE *)(a1 + v4++);
      v8 |= (unint64_t)(v10 & 0x7F) << v9;
      if ((v10 & 0x80) == 0)
        break;
      v6 = v9 == 63;
      v9 += 7;
    }
    while (!v6);
    result = v3 >> 1;
    *a2 = v4;
  }
  else
  {
    result = 0;
    LOBYTE(v8) = v3;
  }
  if ((v8 & 1) != 0)
  {
    v11 = __si_assert_copy_extra(0);
    v12 = v11;
    v13 = "";
    if (v11)
      v13 = v11;
    __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.h", 294, "(value & 1) == 0", v13);
    free(v12);
    if (__valid_fs(-1))
      v14 = 2989;
    else
      v14 = 3072;
    *(_DWORD *)v14 = -559038737;
    abort();
  }
  return result;
}

uint64_t PositionIterate(uint64_t a1, unint64_t *a2, uint64_t a3, _DWORD *a4, int a5)
{
  uint64_t v7;
  uint64_t *v8;
  unsigned __int8 *v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  BOOL v13;
  unint64_t v14;
  size_t v15;
  BOOL v16;
  unint64_t v17;
  int *v19;
  unint64_t v20;
  size_t v21;
  BOOL v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  uint64_t v27;
  _DWORD *v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  uint64_t v32;
  unsigned int v33;
  uint64_t v34;
  unsigned int v35;
  unsigned int v37;
  uint64_t v38;
  unsigned int v39;
  size_t v40;
  int v41;
  void *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  uint64_t v47;
  int v48;
  int v49;
  void *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  signed int v54;
  uint64_t v55;
  int v56;
  int v57;
  uint64_t v58;
  int v59;
  int v60;
  uint64_t v61;
  int v62;
  unsigned int v63;
  int v64;
  int v65;
  int v66;
  int v67;
  int v68;
  int v69;
  size_t v70;
  void *v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  int v75;
  int v76;
  uint64_t v77;
  int v78;
  int v79;
  int v80;
  int v81;
  int v82;
  uint64_t v83;
  char HasIndex;
  int8x8_t v85;
  uint64_t v86;
  uint64_t v87;
  unsigned int locked;
  int8x8_t v89;
  size_t v90;
  void *v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  int v95;
  uint64_t v96;
  int v97;
  int v98;
  uint64_t v99;
  int v100;
  int v101;
  int v102;
  int v103;
  int v104;
  uint64_t v105;
  unsigned int v106;
  void *v107;
  size_t v108;
  char *v109;
  char *v110;
  char *v111;
  int v112;
  BOOL v113;
  size_t v114;
  void *v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  int v120;
  int v121;
  uint64_t v122;
  int v123;
  int v124;
  int v125;
  int v126;
  int v127;
  unsigned int v128;
  int v129;
  int v130;
  NSObject *v131;
  int *v132;
  os_log_type_t v133;
  int *v134;
  int v135;
  int v136;
  uint64_t v137;
  uint64_t v138;
  unsigned int v139;
  _DWORD *v140;
  unsigned int v141;
  unsigned int v142;
  unsigned int v143;
  uint64_t v144;
  unsigned int v145;
  unsigned int v147;
  uint64_t v148;
  unsigned int v149;
  size_t v150;
  int v151;
  void *v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  unsigned int v156;
  int v157;
  void *v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  unsigned int v162;
  int v163;
  size_t v164;
  void *v165;
  uint64_t v166;
  uint64_t v167;
  int v168;
  uint64_t v169;
  char v170;
  int8x8_t v171;
  uint64_t v172;
  int v173;
  unsigned int v174;
  size_t v175;
  void *v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  unsigned int v180;
  int v181;
  int v182;
  uint64_t v183;
  unsigned int v184;
  int v185;
  uint64_t v186;
  unsigned int v187;
  void *v188;
  size_t v189;
  char *v190;
  char *v191;
  char *v192;
  _DWORD *v193;
  unsigned int v194;
  uint64_t Buffer;
  unsigned int v196;
  unsigned int v197;
  uint64_t v198;
  NSObject *v199;
  NSObject *v200;
  unsigned int v201;
  unint64_t v202;
  int v203;
  size_t v204;
  void *v205;
  uint64_t v206;
  uint64_t v207;
  int v208;
  BOOL v209;
  int v210;
  unint64_t v211;
  uint64_t v212;
  int v213;
  NSObject *v214;
  unsigned int v215;
  unint64_t v216;
  unint64_t v217;
  unint64_t v218;
  unint64_t v219;
  BOOL v220;
  BOOL v221;
  BOOL v222;
  BOOL v224;
  unint64_t v226;
  unsigned int v227;
  uint64_t v228;
  unsigned int v229;
  unsigned int v230;
  char v231;
  uint64_t v232;
  uint64_t v233;
  unint64_t v234;
  uint64_t v235;
  unsigned int v236;
  uint64_t v237;
  unsigned int v238;
  unsigned int v239;
  char v240;
  uint64_t v241;
  uint64_t v242;
  unint64_t v243;
  unint64_t v244;
  char IsLooping;
  uint64_t result;
  uint64_t v247;
  int v248;
  NSObject *v249;
  os_log_type_t v250;
  int *v251;
  int v252;
  unsigned int v253;
  unsigned int v254;
  char v255;
  uint64_t v256;
  uint64_t v257;
  unint64_t v258;
  unint64_t v259;
  unint64_t v260;
  unint64_t v261;
  BOOL v262;
  BOOL v263;
  BOOL v264;
  BOOL v265;
  BOOL v266;
  BOOL v267;
  unint64_t v268;
  unsigned int v269;
  uint64_t v270;
  unsigned int v271;
  unsigned int v272;
  char v273;
  uint64_t v274;
  uint64_t v275;
  unint64_t v276;
  uint64_t v277;
  unsigned int v278;
  uint64_t v279;
  unsigned int v280;
  unsigned int v281;
  char v282;
  uint64_t v283;
  uint64_t v284;
  unint64_t v285;
  unint64_t v286;
  unsigned int v287;
  unsigned int v288;
  char v289;
  uint64_t v290;
  uint64_t v291;
  char *v292;
  unint64_t v293;
  uint64_t v294;
  char *v295;
  uint64_t v296;
  unint64_t v297;
  int v298;
  NSObject *v299;
  uint64_t v300;
  int v301;
  NSObject *v302;
  uint64_t v303;
  int v304;
  NSObject *v305;
  int8x8_t v306;
  unsigned int v307;
  unsigned int v308;
  int v309;
  uint64_t v310;
  unint64_t v311;
  int v312;
  NSObject *v313;
  uint64_t v314;
  int v315;
  int v316;
  NSObject *v317;
  int8x8_t v318;
  unsigned int v319;
  unsigned int v320;
  int v321;
  uint64_t v322;
  int v323;
  NSObject *v324;
  uint64_t v325;
  int v326;
  int v327;
  unint64_t v328;
  int v329;
  NSObject *v330;
  uint64_t v331;
  int v332;
  int v333;
  NSObject *v334;
  uint64_t v335;
  int v336;
  int v337;
  __int128 v338;
  int v339;
  int v340;
  unsigned int v341;
  unint64_t v342;
  unint64_t v343;
  uint64_t v344;
  unsigned int v345;
  __int128 v348;
  uint64_t v349;
  int v350;
  uint64_t v352;
  unsigned int v353;
  uint64_t v354;
  uint64_t v355;
  uint64_t v356;
  unint64_t v357;
  _BYTE buf[32];
  unint64_t v359;
  __int128 v360;
  int v361;
  char v362;
  uint64_t v363;

  v7 = a1;
  v363 = *MEMORY[0x1E0C80C00];
  v8 = *(uint64_t **)(a3 + 384);
  v9 = *(unsigned __int8 **)a3;
  v10 = *v8;
  v11 = *(_QWORD *)a1;
  v350 = *((unsigned __int8 *)v8 + 17);
  v352 = *v8;
  if (*((_BYTE *)v8 + 18))
  {
    if (!v11)
    {
      PositionIterator_GetNext(a1);
      *(_QWORD *)(v7 + 32) = 0;
      goto LABEL_367;
    }
    v12 = *(_QWORD *)(a1 + 8);
    if (!v12 || (v11 > v12 ? (v13 = v11 > 2 * v12) : (v13 = 1), !v13))
    {
      if (dword_1EF19FCB4 >= 5)
      {
        v298 = *__error();
        v299 = _SILogForLogForCategory(10);
        if (os_log_type_enabled(v299, OS_LOG_TYPE_DEFAULT))
        {
          v300 = *(_QWORD *)(a1 + 24);
          *(_DWORD *)buf = 134218496;
          *(_QWORD *)&buf[4] = a1;
          *(_WORD *)&buf[12] = 2048;
          *(_QWORD *)&buf[14] = v11;
          *(_WORD *)&buf[22] = 2048;
          *(_QWORD *)&buf[24] = v300;
          _os_log_impl(&dword_1B8270000, v299, OS_LOG_TYPE_DEFAULT, "%p %llu %p", buf, 0x20u);
        }
        *__error() = v298;
        v8 = *(uint64_t **)(a3 + 384);
        v7 = a1;
      }
      v14 = *(_QWORD *)(a3 + 8);
      v15 = v8[1];
      if (v11 < v14 || (v15 + v14 > v11 ? (v16 = v11 + 30 > v15 + v14) : (v16 = 1), v16))
      {
        *(_QWORD *)(a3 + 8) = v11 & 0x3FFFFFFFFFFFF000;
        if (fd_pread(*(_DWORD **)(v10 + 4480), v9, v15, v11 & 0x3FFFFFFFFFFFF000) == -1)
          return 0;
        v23 = 0;
        *(_DWORD *)(a3 + 28) = 0;
        v14 = *(_QWORD *)(a3 + 8);
        v15 = *(_QWORD *)(*(_QWORD *)(a3 + 384) + 8);
      }
      else
      {
        v23 = *(_DWORD *)(a3 + 28) + 1;
        *(_DWORD *)(a3 + 28) = v23;
      }
      v357 = v11 - v14;
      if ((int)v11 - (int)v14 + 20 >= v15)
      {
        *(_QWORD *)(a3 + 8) = v11 & 0x3FFFFFFFFFFFF000;
        v24 = fd_pread(*(_DWORD **)(v10 + 4480), *(void **)a3, v15, v11 & 0x3FFFFFFFFFFFF000);
        *(_DWORD *)(a3 + 28) = 0;
        v357 = v11 - *(_QWORD *)(a3 + 8);
        if (v24 == -1)
          goto LABEL_365;
      }
      else
      {
        *(_DWORD *)(a3 + 28) = v23 + 1;
      }
      v25 = SLReadPositionHeader((uint64_t)v9, (uint64_t *)&v357);
      v354 = 0;
      v355 = 0;
      v356 = 0;
      v26 = *(_DWORD *)(v7 + 48);
      v342 = v11;
      v339 = a5;
      *(_QWORD *)&v348 = v25;
      *((_QWORD *)&v348 + 1) = v27;
      if (v26 + 1 >= 2)
      {
        v28 = *(_DWORD **)(v7 + 24);
        v29 = *(_DWORD *)(a3 + 16);
        if (v26 >= *(_DWORD *)(a3 + 24))
          v30 = *(_DWORD *)(a3 + 24);
        else
          v30 = *(_DWORD *)(v7 + 48);
      }
      else
      {
        v28 = *(_DWORD **)(v7 + 24);
        v29 = *(_DWORD *)(a3 + 16);
        v30 = *(_DWORD *)(a3 + 24);
      }
      _CIIndexSetInitializeEnumeratorForRange(v28, (uint64_t)&v354, v29, v30);
      v31 = 0;
      LODWORD(v32) = 0;
      v33 = 0;
      v34 = 0;
      v35 = *(_DWORD *)(v7 + 48);
      if (v35 >= *(_DWORD *)(a3 + 20) || v35 == 0)
        v37 = *(_DWORD *)(a3 + 20);
      else
        v37 = *(_DWORD *)(v7 + 48);
      v38 = v357;
      while (1)
      {
        if (!*(_QWORD *)(a1 + 40))
          v31 = _CIIndexSetEnumeratorNext((unsigned int *)&v354);
        v39 = v38 + 5;
        v40 = *(_QWORD *)(*(_QWORD *)(a3 + 384) + 8);
        if (v350)
          break;
        if (v39 >= v40)
        {
          v50 = *(void **)a3;
          v51 = *(_QWORD *)(a3 + 8) + v38;
          *(_QWORD *)(a3 + 8) = v51 & 0x3FFFFFFFFFFFF000;
          v52 = fd_pread(*(_DWORD **)(v10 + 4480), v50, v40, v51 & 0x3FFFFFFFFFFFF000);
          *(_DWORD *)(a3 + 28) = 0;
          v38 = v51 - *(_QWORD *)(a3 + 8);
          if (v52 == -1)
            goto LABEL_169;
        }
        else
        {
          ++*(_DWORD *)(a3 + 28);
        }
        v53 = v38 + 1;
        v54 = v9[v38];
        if (((char)v9[v38] & 0x80000000) == 0)
        {
          v55 = v38 + 1;
          goto LABEL_91;
        }
        v55 = v38 + 2;
        v56 = (char)v9[v53];
        v57 = v9[v53];
        if ((v56 & 0x80000000) == 0)
        {
          v54 = v54 & 0x7F | (v57 << 7);
          goto LABEL_91;
        }
        v61 = v38 + 3;
        v62 = v9[v55];
        if (((char)v9[v55] & 0x80000000) == 0)
        {
          v63 = ((v57 & 0x7F) << 7) | (v62 << 14) | v54 & 0x7F;
          v55 = v38 + 3;
LABEL_90:
          v54 = v63;
          goto LABEL_91;
        }
        v55 = v38 + 4;
        v66 = (char)v9[v61];
        v67 = v9[v61];
        if (v66 < 0)
        {
          v129 = (char)v9[v55];
          if (v129 < 0)
          {
LABEL_487:
            v295 = __si_assert_copy_extra(0);
            __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t");
            goto LABEL_478;
          }
          v55 = v38 + 5;
          v54 = ((v67 & 0x7F) << 21) | (v129 << 28) | ((v62 & 0x7F) << 14) | ((v57 & 0x7F) << 7) | v54 & 0x7F;
        }
        else
        {
          v54 = ((v62 & 0x7F) << 14) | (v67 << 21) | ((v57 & 0x7F) << 7) | v54 & 0x7F;
        }
LABEL_91:
        v83 = *(_QWORD *)(a1 + 40);
        if (!v54)
        {
          v47 = v55;
          goto LABEL_299;
        }
        if (!v83 && !v31)
        {
          v357 = v55;
          if (v339)
          {
            v130 = *__error();
            v131 = _SILogForLogForCategory(10);
            v132 = (int *)&unk_1EF19F000;
            v133 = 2 * (dword_1EF19FCB4 < 4);
            if (os_log_type_enabled(v131, v133))
            {
              *(_DWORD *)buf = 67109120;
              *(_DWORD *)&buf[4] = v54;
              _os_log_impl(&dword_1B8270000, v131, v133, "Out of postings while we still have more position data (%u)", buf, 8u);
            }
            v134 = __error();
            v135 = 0;
            *v134 = v130;
            v7 = a1;
            v11 = v342;
            goto LABEL_305;
          }
          v253 = *(_DWORD *)(a3 + 32);
          *(_DWORD *)(a1 + 148) = v253;
          *(_DWORD *)(a1 + 48) = v37;
          DWORD1(v360) = 0;
          *(_DWORD *)((char *)&v360 + 1) = 0;
          v254 = *(_DWORD *)(a1 + 152);
          v255 = *(_BYTE *)(a1 + 156);
          v257 = *(_QWORD *)(a1 + 16);
          v256 = *(_QWORD *)(a1 + 24);
          *(_QWORD *)buf = *(_QWORD *)a1;
          *(_QWORD *)&buf[8] = v256;
          *(_QWORD *)&buf[16] = v37;
          v7 = a1;
          *(_QWORD *)&buf[24] = v34;
          v359 = __PAIR64__(v254, v253);
          LOBYTE(v360) = v255;
          *((_QWORD *)&v360 + 1) = v257;
          deferPosition(a1, (uint64_t)buf);
          v11 = v342;
LABEL_366:
          *(_DWORD *)(v7 + 148) = 0;
          *(_QWORD *)v7 = 0;
          *(_QWORD *)(v7 + 16) = 0;
          *(_QWORD *)(v7 + 24) = 0;
          PositionIterator_GetNext(v7);
          IsLooping = iterationIsLooping((uint64_t *)v7, v11);
          result = 0;
          if ((IsLooping & 1) != 0)
            return result;
LABEL_367:
          v247 = *(_QWORD *)v7;
          if (*(_DWORD *)(v7 + 188))
          {
            if (v247)
              return 0xFFFFFFFFLL;
LABEL_451:
            if (*(_QWORD *)(v7 + 80))
              return 4294967293;
            else
              return 4294967294;
          }
LABEL_454:
          if (v247)
            return 1;
          if (*(_QWORD *)(v7 + 80))
            return 4294967292;
          return 0;
        }
        if (v83)
        {
          *(_QWORD *)(a1 + 40) = v83 - 1;
        }
        else
        {
          HasIndex = CIIndexSetHasIndex((uint64_t)a4, v31);
          v86 = a1;
          v87 = *(_QWORD *)(a1 + 40);
          if (v87)
            *(_QWORD *)(a1 + 40) = v87 - 1;
          if ((HasIndex & 1) != 0)
          {
            if (v33)
              locked = lockedCountItemsInRange(a4, v31, v33, v85) + v32;
            else
              locked = lockedCountItemsInRange(a4, v31, *(_DWORD *)(a3 + 24), v85);
            v32 = locked - 1;
            v105 = *(unsigned int *)(a1 + 168);
            if (v32 >= v105)
            {
              v106 = *(_DWORD *)(a1 + 168);
              if (!(_DWORD)v105)
              {
                v106 = 1 << -(char)__clz(v32);
                *(_DWORD *)(a1 + 168) = v106;
              }
              if (locked >= v106)
              {
                do
                {
                  v221 = locked >= 2 * v106;
                  v106 *= 2;
                }
                while (v221);
                *(_DWORD *)(a1 + 168) = v106;
              }
              v107 = *(void **)(a1 + 160);
              v108 = 8 * v106;
              if (v107)
                v109 = (char *)malloc_type_zone_realloc((malloc_zone_t *)queryZone, v107, v108, 0xECA6AA46uLL);
              else
                v109 = (char *)malloc_type_zone_malloc((malloc_zone_t *)queryZone, v108, 0x8DDAA030uLL);
              v110 = v109;
              if (!v109)
                _log_fault_for_malloc_failure();
              *(_QWORD *)(a1 + 160) = v110;
              v111 = &v110[8 * v105];
              v86 = a1;
              bzero(v111, 8 * (*(unsigned int *)(a1 + 168) - v105));
            }
            if (!*(_QWORD *)(*(_QWORD *)(v86 + 160) + 8 * v32))
              *(_QWORD *)(*(_QWORD *)(v86 + 160) + 8 * v32) = CIIndexSetCreateWithRange(0, 0x400u, 1);
            v112 = 0;
            while (1)
            {
              while (1)
              {
                while (1)
                {
                  while (1)
                  {
                    while (1)
                    {
                      v113 = __OFSUB__(v54, v112);
                      v54 -= v112;
                      if ((v54 < 0) ^ v113 | (v54 == 0))
                        goto LABEL_507;
                      if (v54 <= 0)
                        goto LABEL_464;
                      CIIndexSetAddIndexExpandingRange(*(const void ***)(*(_QWORD *)(v86 + 160) + 8 * v32), v54, v89);
                      v114 = *(_QWORD *)(*(_QWORD *)(a3 + 384) + 8);
                      if ((int)v55 + 5 >= v114)
                      {
                        v115 = *(void **)a3;
                        v116 = *(_QWORD *)(a3 + 8) + v55;
                        *(_QWORD *)(a3 + 8) = v116 & 0x3FFFFFFFFFFFF000;
                        v117 = fd_pread(*(_DWORD **)(v352 + 4480), v115, v114, v116 & 0x3FFFFFFFFFFFF000);
                        *(_DWORD *)(a3 + 28) = 0;
                        v55 = v116 - *(_QWORD *)(a3 + 8);
                        if (v117 == -1)
                          goto LABEL_152;
                      }
                      else
                      {
                        ++*(_DWORD *)(a3 + 28);
                      }
                      v118 = v55 + 1;
                      v112 = v9[v55];
                      if ((char)v9[v55] < 0)
                        break;
                      ++v55;
                      if (!v112)
                        goto LABEL_152;
                    }
                    v119 = v55 + 2;
                    v120 = (char)v9[v118];
                    v121 = v9[v118];
                    if (v120 < 0)
                      break;
                    v112 = v112 & 0x7F | (v121 << 7);
                    v55 += 2;
                    if (!v112)
                      goto LABEL_152;
                  }
                  v122 = v55 + 3;
                  v123 = (char)v9[v119];
                  v124 = v9[v119];
                  if (v123 < 0)
                    break;
                  v55 += 3;
                  v112 = ((v121 & 0x7F) << 7) | (v124 << 14) | v112 & 0x7F;
                  if (!v112)
                    goto LABEL_152;
                }
                v125 = (char)v9[v122];
                v126 = v9[v122];
                if (v125 < 0)
                  break;
                v55 += 4;
                v112 = ((v124 & 0x7F) << 14) | (v126 << 21) | ((v121 & 0x7F) << 7) | v112 & 0x7F;
                if (!v112)
                  goto LABEL_152;
              }
              v127 = (char)v9[v55 + 4];
              if (v127 < 0)
                break;
              v55 += 5;
              v112 = ((v126 & 0x7F) << 21) | (v127 << 28) | ((v124 & 0x7F) << 14) | ((v121 & 0x7F) << 7) | v112 & 0x7F;
              if (!v112)
              {
LABEL_152:
                v33 = v31;
                v10 = v352;
                goto LABEL_153;
              }
            }
            v292 = __si_assert_copy_extra(0);
            __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t");
            goto LABEL_472;
          }
        }
        v10 = v352;
        do
        {
          v90 = *(_QWORD *)(*(_QWORD *)(a3 + 384) + 8);
          if ((int)v55 + 5 >= v90)
          {
            v91 = *(void **)a3;
            v92 = *(_QWORD *)(a3 + 8) + v55;
            *(_QWORD *)(a3 + 8) = v92 & 0x3FFFFFFFFFFFF000;
            v93 = fd_pread(*(_DWORD **)(v352 + 4480), v91, v90, v92 & 0x3FFFFFFFFFFFF000);
            *(_DWORD *)(a3 + 28) = 0;
            v55 = v92 - *(_QWORD *)(a3 + 8);
            if (v93 == -1)
              break;
          }
          else
          {
            ++*(_DWORD *)(a3 + 28);
          }
          v94 = v55 + 1;
          v95 = v9[v55];
          if ((char)v9[v55] < 0)
          {
            v96 = v55 + 2;
            v97 = (char)v9[v94];
            v98 = v9[v94];
            if (v97 < 0)
            {
              v99 = v55 + 3;
              v100 = (char)v9[v96];
              v101 = v9[v96];
              if (v100 < 0)
              {
                v102 = (char)v9[v99];
                v103 = v9[v99];
                if (v102 < 0)
                {
                  v104 = (char)v9[v55 + 4];
                  if (v104 < 0)
                    goto LABEL_487;
                  v55 += 5;
                  v95 = ((v103 & 0x7F) << 21) | (v104 << 28) | ((v101 & 0x7F) << 14) | ((v98 & 0x7F) << 7) | v95 & 0x7F;
                }
                else
                {
                  v55 += 4;
                  v95 = ((v101 & 0x7F) << 14) | (v103 << 21) | ((v98 & 0x7F) << 7) | v95 & 0x7F;
                }
              }
              else
              {
                v55 += 3;
                v95 = ((v98 & 0x7F) << 7) | (v101 << 14) | v95 & 0x7F;
              }
            }
            else
            {
              v95 = v95 & 0x7F | (v98 << 7);
              v55 += 2;
            }
          }
          else
          {
            ++v55;
          }
        }
        while (v95);
LABEL_153:
        v128 = *(_DWORD *)(a3 + 56);
        if (v128 >= v31)
          v128 = v31;
        *(_DWORD *)(a3 + 56) = v128;
        ++v34;
        v38 = v55;
        v37 = v31;
      }
      if (v39 >= v40)
      {
        v42 = *(void **)a3;
        v43 = *(_QWORD *)(a3 + 8) + v38;
        *(_QWORD *)(a3 + 8) = v43 & 0x3FFFFFFFFFFFF000;
        v44 = fd_pread(*(_DWORD **)(v10 + 4480), v42, v40, v43 & 0x3FFFFFFFFFFFF000);
        v41 = 0;
        *(_DWORD *)(a3 + 28) = 0;
        v38 = v43 - *(_QWORD *)(a3 + 8);
        if (v44 == -1)
          goto LABEL_169;
      }
      else
      {
        v41 = *(_DWORD *)(a3 + 28) + 1;
        *(_DWORD *)(a3 + 28) = v41;
      }
      v45 = v38 + 1;
      v46 = v9[v38];
      if ((char)v9[v38] < 0)
      {
        v47 = v38 + 2;
        v48 = (char)v9[v45];
        v49 = v9[v45];
        if (v48 < 0)
        {
          v58 = v38 + 3;
          v59 = (char)v9[v47];
          v60 = v59;
          if (v59 < 0)
          {
            v47 = v38 + 4;
            v64 = (char)v9[v58];
            v65 = v9[v58];
            if (v64 < 0)
            {
              v68 = (char)v9[v47];
              if (v68 < 0)
                goto LABEL_487;
              v69 = v68;
              v47 = v38 + 5;
              v46 = ((v65 & 0x7F) << 21) | (v69 << 28) | ((v60 & 0x7F) << 14) | ((v49 & 0x7F) << 7) | v46 & 0x7F;
            }
            else
            {
              v46 = ((v60 & 0x7F) << 14) | (v65 << 21) | ((v49 & 0x7F) << 7) | v46 & 0x7F;
            }
          }
          else
          {
            v47 = v38 + 3;
            v46 = ((v49 & 0x7F) << 7) | (v60 << 14) | v46 & 0x7F;
          }
        }
        else
        {
          v46 = v46 & 0x7F | (v49 << 7);
        }
      }
      else
      {
        v47 = v38 + 1;
      }
      if (!v46)
      {
        v83 = *(_QWORD *)(a1 + 40);
LABEL_299:
        v357 = v47;
        v11 = v342;
        if (v83)
          goto LABEL_507;
        if (v31)
        {
          v135 = 0;
          v7 = a1;
          *(_DWORD *)(a1 + 48) = v31;
          goto LABEL_302;
        }
        v215 = v37 - 1;
        v7 = a1;
        *(_DWORD *)(a1 + 48) = v215;
        v132 = (int *)&unk_1EF19F000;
        if (dword_1EF19FCB4 >= 5)
        {
          v323 = *__error();
          v324 = _SILogForLogForCategory(10);
          if (os_log_type_enabled(v324, OS_LOG_TYPE_DEFAULT))
          {
            v325 = *(_QWORD *)(a1 + 24);
            v326 = *(_DWORD *)(a1 + 148);
            v327 = *(_DWORD *)(a1 + 48);
            *(_DWORD *)buf = 134218496;
            *(_QWORD *)&buf[4] = v325;
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v326;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v327;
            _os_log_impl(&dword_1B8270000, v324, OS_LOG_TYPE_DEFAULT, "Iterator for %p might be done with generation %d. Read docs: %x", buf, 0x18u);
          }
          *__error() = v323;
          v135 = 1;
          v7 = a1;
        }
        else
        {
          v135 = 1;
        }
LABEL_305:
        v217 = *((_QWORD *)&v348 + 1);
        v216 = v348;
        if (v348 == 0)
        {
          v216 = *(_QWORD *)(v7 + 16);
          *(_QWORD *)(v7 + 16) = 0;
        }
        v218 = *(_QWORD *)(v7 + 8);
        v219 = *(_QWORD *)(**(_QWORD **)(a3 + 384) + 32);
        if (v218 >= v219)
          v219 = 2 * v218;
        if (*((_QWORD *)&v348 + 1) <= v11 && *((_QWORD *)&v348 + 1))
        {
          v220 = v11 <= v219 || *((_QWORD *)&v348 + 1) > v219;
          v221 = v220 && *((_QWORD *)&v348 + 1) >= v218;
          if (v221)
            goto LABEL_507;
        }
        if (v216 - 1 < v11)
        {
          v222 = v11 <= v219 || v216 > v219;
          if (v222 && v216 >= v218)
            goto LABEL_507;
        }
        if (v216 - 1 < *((_QWORD *)&v348 + 1))
        {
          v224 = *((_QWORD *)&v348 + 1) <= v219 || v216 > v219;
          if (v224 && v216 >= v218)
            goto LABEL_507;
        }
        if (*((_QWORD *)&v348 + 1))
          v226 = 0;
        else
          v226 = v216;
        if (*((_QWORD *)&v348 + 1) && v216)
        {
          v226 = 0;
          *(_QWORD *)(v7 + 16) = v216;
        }
        if (v226 | *((_QWORD *)&v348 + 1))
        {
          if (v135)
          {
            if (v132[813] >= 5)
            {
              v311 = v11;
              v312 = *__error();
              v313 = _SILogForLogForCategory(10);
              if (os_log_type_enabled(v313, OS_LOG_TYPE_DEFAULT))
              {
                v314 = *(_QWORD *)(a1 + 24);
                v315 = *(_DWORD *)(a1 + 148);
                *(_DWORD *)buf = 134218240;
                *(_QWORD *)&buf[4] = v314;
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v315;
                _os_log_impl(&dword_1B8270000, v313, OS_LOG_TYPE_DEFAULT, "Iterator for %p done with generation %d", buf, 0x12u);
              }
              *__error() = v312;
              v7 = a1;
              v11 = v311;
              v217 = *((_QWORD *)&v348 + 1);
            }
            *(_DWORD *)(v7 + 148) = *(_DWORD *)(a3 + 32);
          }
          if (v217)
          {
            if (!v226)
            {
              if (v217 == v11)
                goto LABEL_366;
              v227 = *(_DWORD *)(v7 + 48);
              v228 = *(_QWORD *)(v7 + 40);
              v230 = *(_DWORD *)(v7 + 148);
              v229 = *(_DWORD *)(v7 + 152);
              v231 = *(_BYTE *)(v7 + 156);
              v232 = *(_QWORD *)(v7 + 16);
              v233 = *(_QWORD *)(v7 + 24);
              if (v217 <= v11 && v217 <= *(_QWORD *)(v7 + 112))
              {
                *(_QWORD *)buf = v217;
                *(_QWORD *)&buf[8] = v233;
                *(_QWORD *)&buf[16] = v227;
                *(_QWORD *)&buf[24] = v228;
                v359 = __PAIR64__(v229, v230);
                LOBYTE(v360) = v231;
                *(_DWORD *)((char *)&v360 + 1) = 0;
                DWORD1(v360) = 0;
                *((_QWORD *)&v360 + 1) = v232;
                check_oqpush_AnnotatedPositionOffset_t(v7 + 56, (uint64_t *)buf);
                goto LABEL_366;
              }
              v234 = *(_QWORD *)(v7 + 8);
              if (!v234 || v217 > v234 && v217 <= 2 * v234)
              {
                v235 = v7 + 120;
                *(_QWORD *)buf = v217;
                *(_QWORD *)&buf[8] = v233;
                *(_QWORD *)&buf[16] = v227;
                *(_QWORD *)&buf[24] = v228;
                v359 = __PAIR64__(v229, v230);
                LOBYTE(v360) = v231;
                *(_DWORD *)((char *)&v360 + 1) = 0;
                DWORD1(v360) = 0;
                *((_QWORD *)&v360 + 1) = v232;
LABEL_364:
                check_pqpush_AnnotatedPositionOffset_t(v235, (__int128 *)buf);
                goto LABEL_366;
              }
LABEL_507:
              v295 = __si_assert_copy_extra(0);
LABEL_477:
              __message_assert("%s:%u: failed assertion '%s' %s ");
LABEL_478:
              free(v295);
              if (__valid_fs(-1))
                v296 = 2989;
              else
                v296 = 3072;
              *(_DWORD *)v296 = -559038737;
              abort();
            }
LABEL_464:
            v292 = __si_assert_copy_extra(0);
LABEL_471:
            __message_assert("%s:%u: failed assertion '%s' %s ");
LABEL_472:
            free(v292);
            if (__valid_fs(-1))
              v294 = 2989;
            else
              v294 = 3072;
            *(_DWORD *)v294 = -559038737;
            abort();
          }
          if (v226)
          {
            if (v226 == v11)
              goto LABEL_366;
            v236 = *(_DWORD *)(v7 + 48);
            v237 = *(_QWORD *)(v7 + 40);
            v239 = *(_DWORD *)(v7 + 148);
            v238 = *(_DWORD *)(v7 + 152);
            v240 = *(_BYTE *)(v7 + 156);
            v242 = *(_QWORD *)(v7 + 16);
            v241 = *(_QWORD *)(v7 + 24);
            if (v226 <= v11 && v226 <= *(_QWORD *)(v7 + 112))
            {
              if (!v242)
              {
                *(_QWORD *)buf = v226;
                *(_QWORD *)&buf[8] = v241;
                *(_QWORD *)&buf[16] = v236;
                *(_QWORD *)&buf[24] = v237;
                v359 = __PAIR64__(v238, v239);
                LOBYTE(v360) = v240;
                *(_QWORD *)((char *)&v360 + 1) = 0;
                *((_QWORD *)&v360 + 1) = 0;
                check_oqpush_AnnotatedPositionOffset_t(v7 + 56, (uint64_t *)buf);
                if (*(_QWORD *)(a3 + 48) > v226)
                {
                  v293 = *(_QWORD *)(v7 + 8);
                  if (v226 < v293 && v226 > v293 >> 1)
                    *(_QWORD *)(a3 + 48) = v226;
                }
                goto LABEL_366;
              }
              goto LABEL_507;
            }
            if (v242)
              goto LABEL_507;
            v243 = *(_QWORD *)(v7 + 8);
            if (!v243 || v226 > v243 && v226 <= 2 * v243)
            {
              v244 = *(_QWORD *)(a3 + 40);
              if (v244 >= v226)
                v244 = v226;
              *(_QWORD *)(a3 + 40) = v244;
              v235 = v7 + 120;
              *(_QWORD *)buf = v226;
              *(_QWORD *)&buf[8] = v241;
              *(_QWORD *)&buf[16] = v236;
              *(_QWORD *)&buf[24] = v237;
              v359 = __PAIR64__(v238, v239);
              LOBYTE(v360) = v240;
              *(_QWORD *)((char *)&v360 + 1) = 0;
              *((_QWORD *)&v360 + 1) = 0;
              goto LABEL_364;
            }
            goto LABEL_464;
          }
        }
LABEL_365:
        instr_release(*(CFTypeRef *)(v7 + 24));
        goto LABEL_366;
      }
      v70 = *(_QWORD *)(*(_QWORD *)(a3 + 384) + 8);
      if ((int)v47 + 5 >= v70)
      {
        v71 = *(void **)a3;
        v72 = *(_QWORD *)(a3 + 8) + v47;
        *(_QWORD *)(a3 + 8) = v72 & 0x3FFFFFFFFFFFF000;
        v73 = fd_pread(*(_DWORD **)(v10 + 4480), v71, v70, v72 & 0x3FFFFFFFFFFFF000);
        *(_DWORD *)(a3 + 28) = 0;
        v47 = v72 - *(_QWORD *)(a3 + 8);
        v38 = v47;
        if (v73 == -1)
        {
LABEL_169:
          v135 = 0;
          v357 = v38;
          v7 = a1;
          v11 = v342;
LABEL_302:
          v132 = (_DWORD *)&unk_1EF19F000;
          goto LABEL_305;
        }
      }
      else
      {
        *(_DWORD *)(a3 + 28) = v41 + 1;
      }
      v74 = v47 + 1;
      v54 = v9[v47];
      if (((char)v9[v47] & 0x80000000) == 0)
      {
        v55 = v47 + 1;
        goto LABEL_91;
      }
      v55 = v47 + 2;
      v75 = (char)v9[v74];
      v76 = v9[v74];
      if ((v75 & 0x80000000) == 0)
      {
        v54 = v54 & 0x7F | (v76 << 7);
        goto LABEL_91;
      }
      v77 = v47 + 3;
      v78 = v9[v55];
      if ((char)v9[v55] < 0)
      {
        v55 = v47 + 4;
        v79 = (char)v9[v77];
        v80 = v9[v77];
        if (v79 < 0)
        {
          v82 = (char)v9[v55];
          if (v82 < 0)
            goto LABEL_487;
          v55 = v47 + 5;
          v81 = ((v80 & 0x7F) << 21) | (v82 << 28) | ((v78 & 0x7F) << 14);
        }
        else
        {
          v81 = ((v78 & 0x7F) << 14) | (v80 << 21);
        }
        v63 = v81 & 0xFFFFC000 | ((v76 & 0x7F) << 7) | v54 & 0x7F;
      }
      else
      {
        v63 = ((v76 & 0x7F) << 7) | (v78 << 14) | v54 & 0x7F;
        v55 = v77;
      }
      goto LABEL_90;
    }
LABEL_491:
    v292 = __si_assert_copy_extra(0);
    goto LABEL_471;
  }
  if (!v11)
    goto LABEL_446;
  v17 = *(_QWORD *)(a1 + 8);
  if (v17)
  {
    if (v11 <= v17 || v11 > 2 * v17)
      goto LABEL_491;
  }
  v19 = (int *)&unk_1EF19F000;
  if (dword_1EF19FCB4 >= 5)
  {
    v301 = *__error();
    v302 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v302, OS_LOG_TYPE_DEFAULT))
    {
      v303 = *(_QWORD *)(a1 + 24);
      *(_DWORD *)buf = 134218496;
      *(_QWORD *)&buf[4] = a1;
      *(_WORD *)&buf[12] = 2048;
      *(_QWORD *)&buf[14] = v11;
      *(_WORD *)&buf[22] = 2048;
      *(_QWORD *)&buf[24] = v303;
      _os_log_impl(&dword_1B8270000, v302, OS_LOG_TYPE_DEFAULT, "%p %llu %p", buf, 0x20u);
    }
    *__error() = v301;
    v8 = *(uint64_t **)(a3 + 384);
    v7 = a1;
  }
  v20 = *(_QWORD *)(a3 + 8);
  v21 = v8[1];
  if (v11 < v20 || (v21 + v20 > v11 ? (v22 = v11 + 30 > v21 + v20) : (v22 = 1), v22))
  {
    *(_QWORD *)(a3 + 8) = v11 & 0x3FFFFFFFFFFFF000;
    if (fd_pread(*(_DWORD **)(v10 + 4480), v9, v21, v11 & 0x3FFFFFFFFFFFF000) == -1)
      return 0;
    v136 = 0;
    *(_DWORD *)(a3 + 28) = 0;
    v20 = *(_QWORD *)(a3 + 8);
    v21 = *(_QWORD *)(*(_QWORD *)(a3 + 384) + 8);
  }
  else
  {
    v136 = *(_DWORD *)(a3 + 28) + 1;
    *(_DWORD *)(a3 + 28) = v136;
  }
  v357 = v11 - v20;
  if ((int)v11 - (int)v20 + 20 >= v21)
  {
    *(_QWORD *)(a3 + 8) = v11 & 0x3FFFFFFFFFFFF000;
    v137 = fd_pread(*(_DWORD **)(v10 + 4480), *(void **)a3, v21, v11 & 0x3FFFFFFFFFFFF000);
    *(_DWORD *)(a3 + 28) = 0;
    v357 = v11 - *(_QWORD *)(a3 + 8);
    if (v137 == -1)
      goto LABEL_444;
  }
  else
  {
    *(_DWORD *)(a3 + 28) = v136 + 1;
  }
  *(_QWORD *)&v338 = CIReadPositionHeader((uint64_t)v9, (uint64_t *)&v357);
  *((_QWORD *)&v338 + 1) = v138;
  v354 = 0;
  v355 = 0;
  v356 = 0;
  v139 = *(_DWORD *)(v7 + 48);
  v343 = v11;
  v340 = a5;
  if (v139 + 1 >= 2)
  {
    if (dword_1EF19FCB4 >= 5)
    {
      v316 = *__error();
      v317 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v317, OS_LOG_TYPE_DEFAULT))
      {
        v319 = *(_DWORD *)(a3 + 16);
        v320 = *(_DWORD *)(a3 + 24);
        v321 = lockedCountItemsInRange(*(_DWORD **)(a1 + 24), v319, v320, v318);
        v322 = *(_QWORD *)(a1 + 24);
        *(_DWORD *)buf = 67109888;
        *(_DWORD *)&buf[4] = v319;
        *(_WORD *)&buf[8] = 1024;
        *(_DWORD *)&buf[10] = v320;
        *(_WORD *)&buf[14] = 1024;
        *(_DWORD *)&buf[16] = v321;
        *(_WORD *)&buf[20] = 2048;
        *(_QWORD *)&buf[22] = v322;
        _os_log_impl(&dword_1B8270000, v317, OS_LOG_TYPE_DEFAULT, "(1)Range: %d %d Count: %d for %p", buf, 0x1Eu);
      }
      *__error() = v316;
      v7 = a1;
      v10 = v352;
      v139 = *(_DWORD *)(a1 + 48);
    }
    v140 = *(_DWORD **)(v7 + 24);
    v141 = *(_DWORD *)(a3 + 16);
    if (v139 >= *(_DWORD *)(a3 + 24))
      v142 = *(_DWORD *)(a3 + 24);
    else
      v142 = v139;
  }
  else
  {
    if (dword_1EF19FCB4 >= 5)
    {
      v304 = *__error();
      v305 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v305, OS_LOG_TYPE_DEFAULT))
      {
        v307 = *(_DWORD *)(a3 + 16);
        v308 = *(_DWORD *)(a3 + 24);
        v309 = lockedCountItemsInRange(*(_DWORD **)(a1 + 24), v307, v308, v306);
        v310 = *(_QWORD *)(a1 + 24);
        *(_DWORD *)buf = 67109888;
        *(_DWORD *)&buf[4] = v307;
        *(_WORD *)&buf[8] = 1024;
        *(_DWORD *)&buf[10] = v308;
        *(_WORD *)&buf[14] = 1024;
        *(_DWORD *)&buf[16] = v309;
        *(_WORD *)&buf[20] = 2048;
        *(_QWORD *)&buf[22] = v310;
        _os_log_impl(&dword_1B8270000, v305, OS_LOG_TYPE_DEFAULT, "(2)Range: %d %d Count: %d for %p", buf, 0x1Eu);
      }
      *__error() = v304;
      v7 = a1;
      v10 = v352;
    }
    v140 = *(_DWORD **)(v7 + 24);
    v141 = *(_DWORD *)(a3 + 16);
    v142 = *(_DWORD *)(a3 + 24);
  }
  _CIIndexSetInitializeEnumeratorForRange(v140, (uint64_t)&v354, v141, v142);
  v345 = 0;
  v341 = 0;
  v143 = 0;
  v144 = 0;
  v145 = *(_DWORD *)(v7 + 48);
  if (v145 >= *(_DWORD *)(a3 + 20) || v145 == 0)
    v147 = *(_DWORD *)(a3 + 20);
  else
    v147 = *(_DWORD *)(v7 + 48);
  v148 = v357;
  while (1)
  {
    if (!*(_QWORD *)(v7 + 40))
    {
      v345 = _CIIndexSetEnumeratorNext((unsigned int *)&v354);
      if (v19[813] >= 5)
      {
        v213 = *__error();
        v214 = _SILogForLogForCategory(10);
        if (os_log_type_enabled(v214, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&buf[4] = v345;
          _os_log_impl(&dword_1B8270000, v214, OS_LOG_TYPE_DEFAULT, "nD: %d", buf, 8u);
        }
        *__error() = v213;
        v7 = a1;
      }
    }
    v149 = v148 + 5;
    v150 = *(_QWORD *)(*(_QWORD *)(a3 + 384) + 8);
    v344 = v144;
    if (!v350)
    {
      if (v149 >= v150)
      {
        v158 = *(void **)a3;
        v159 = *(_QWORD *)(a3 + 8) + v148;
        *(_QWORD *)(a3 + 8) = v159 & 0x3FFFFFFFFFFFF000;
        v160 = fd_pread(*(_DWORD **)(v10 + 4480), v158, v150, v159 & 0x3FFFFFFFFFFFF000);
        *(_DWORD *)(a3 + 28) = 0;
        v148 = v159 - *(_QWORD *)(a3 + 8);
        if (v160 == -1)
          goto LABEL_375;
      }
      else
      {
        ++*(_DWORD *)(a3 + 28);
      }
      v161 = v148 + 1;
      v162 = v9[v148];
      if ((char)v9[v148] < 0)
      {
        if (v162 > 0xBF)
        {
          if (v162 > 0xDF)
          {
            if (v162 > 0xEF)
            {
              v162 = *(_DWORD *)&v9[v161];
              v161 = v148 + 5;
            }
            else
            {
              v162 = ((v162 & 0xF) << 24) | (v9[v161] << 16) | (v9[v148 + 2] << 8) | v9[v148 + 3];
              v161 = v148 + 4;
            }
          }
          else
          {
            v162 = ((v162 & 0x1F) << 16) | (v9[v161] << 8) | v9[v148 + 2];
            v161 = v148 + 3;
          }
        }
        else
        {
          v163 = v9[v161] | ((v162 & 0x3F) << 8);
          v161 = v148 + 2;
          v162 = v163;
        }
      }
      goto LABEL_218;
    }
    if (v149 >= v150)
    {
      v152 = *(void **)a3;
      v153 = *(_QWORD *)(a3 + 8) + v148;
      *(_QWORD *)(a3 + 8) = v153 & 0x3FFFFFFFFFFFF000;
      v154 = fd_pread(*(_DWORD **)(v10 + 4480), v152, v150, v153 & 0x3FFFFFFFFFFFF000);
      v151 = 0;
      *(_DWORD *)(a3 + 28) = 0;
      v148 = v153 - *(_QWORD *)(a3 + 8);
      if (v154 == -1)
        goto LABEL_375;
    }
    else
    {
      v151 = *(_DWORD *)(a3 + 28) + 1;
      *(_DWORD *)(a3 + 28) = v151;
    }
    v155 = v148 + 1;
    v156 = v9[v148];
    if ((char)v9[v148] < 0)
    {
      if (v156 > 0xBF)
      {
        if (v156 > 0xDF)
        {
          if (v156 > 0xEF)
          {
            v156 = *(_DWORD *)&v9[v155];
            v155 = v148 + 5;
          }
          else
          {
            v156 = ((v156 & 0xF) << 24) | (v9[v155] << 16) | (v9[v148 + 2] << 8) | v9[v148 + 3];
            v155 = v148 + 4;
          }
        }
        else
        {
          v156 = ((v156 & 0x1F) << 16) | (v9[v155] << 8) | v9[v148 + 2];
          v155 = v148 + 3;
        }
      }
      else
      {
        v157 = v9[v155] | ((v156 & 0x3F) << 8);
        v155 = v148 + 2;
        v156 = v157;
      }
    }
    if (!v156)
    {
      v357 = v155;
      v169 = *(_QWORD *)(v7 + 40);
LABEL_378:
      if (v169)
        goto LABEL_476;
      if (v345)
      {
        v252 = 0;
        *(_DWORD *)(v7 + 48) = v345;
        goto LABEL_383;
      }
      *(_DWORD *)(v7 + 48) = v147 - 1;
      if (v19[813] < 5)
      {
        v252 = 1;
        goto LABEL_383;
      }
      v333 = *__error();
      v334 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v334, OS_LOG_TYPE_DEFAULT))
      {
        v335 = *(_QWORD *)(a1 + 24);
        v336 = *(_DWORD *)(a1 + 148);
        v337 = *(_DWORD *)(a1 + 48);
        *(_DWORD *)buf = 134218496;
        *(_QWORD *)&buf[4] = v335;
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v336;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v337;
        _os_log_impl(&dword_1B8270000, v334, OS_LOG_TYPE_DEFAULT, "Iterator for %p might be done with generation %d. Read docs: %x", buf, 0x18u);
      }
      *__error() = v333;
      v252 = 1;
      v7 = a1;
      v11 = v343;
      v19 = (_DWORD *)&unk_1EF19F000;
LABEL_384:
      v259 = *((_QWORD *)&v338 + 1);
      v258 = v338;
      if (v338 == 0)
      {
        v258 = *(_QWORD *)(v7 + 16);
        *(_QWORD *)(v7 + 16) = 0;
      }
      v260 = *(_QWORD *)(v7 + 8);
      v261 = *(_QWORD *)(**(_QWORD **)(a3 + 384) + 32);
      if (v260 >= v261)
        v261 = 2 * v260;
      if (*((_QWORD *)&v338 + 1) <= v11
        && *((_QWORD *)&v338 + 1)
        && (v11 > v261 ? (v262 = *((_QWORD *)&v338 + 1) > v261) : (v262 = 1),
            v262 ? (v263 = *((_QWORD *)&v338 + 1) >= v260) : (v263 = 0),
            v263)
        || v258 - 1 < v11
        && (v11 > v261 ? (v264 = v258 > v261) : (v264 = 1), v264 ? (v265 = v258 >= v260) : (v265 = 0), v265)
        || v258 - 1 < *((_QWORD *)&v338 + 1)
        && (*((_QWORD *)&v338 + 1) > v261 ? (v266 = v258 > v261) : (v266 = 1),
            v266 ? (v267 = v258 >= v260) : (v267 = 0),
            v267))
      {
LABEL_470:
        v292 = __si_assert_copy_extra(0);
        goto LABEL_471;
      }
      if (*((_QWORD *)&v338 + 1))
        v268 = 0;
      else
        v268 = v258;
      if (*((_QWORD *)&v338 + 1) && v258)
      {
        v268 = 0;
        *(_QWORD *)(v7 + 16) = v258;
      }
      if (v268 | *((_QWORD *)&v338 + 1))
      {
        if (v252)
        {
          if (v19[813] >= 5)
          {
            v328 = v11;
            v329 = *__error();
            v330 = _SILogForLogForCategory(10);
            if (os_log_type_enabled(v330, OS_LOG_TYPE_DEFAULT))
            {
              v331 = *(_QWORD *)(a1 + 24);
              v332 = *(_DWORD *)(a1 + 148);
              *(_DWORD *)buf = 134218240;
              *(_QWORD *)&buf[4] = v331;
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v332;
              _os_log_impl(&dword_1B8270000, v330, OS_LOG_TYPE_DEFAULT, "Iterator for %p done with generation %d", buf, 0x12u);
            }
            *__error() = v329;
            v7 = a1;
            v11 = v328;
            v259 = *((_QWORD *)&v338 + 1);
          }
          *(_DWORD *)(v7 + 148) = *(_DWORD *)(a3 + 32);
        }
        if (v259)
        {
          if (!v268)
          {
            if (v259 == v11)
              goto LABEL_445;
            v269 = *(_DWORD *)(v7 + 48);
            v270 = *(_QWORD *)(v7 + 40);
            v272 = *(_DWORD *)(v7 + 148);
            v271 = *(_DWORD *)(v7 + 152);
            v273 = *(_BYTE *)(v7 + 156);
            v274 = *(_QWORD *)(v7 + 16);
            v275 = *(_QWORD *)(v7 + 24);
            if (v259 <= v11 && v259 <= *(_QWORD *)(v7 + 112))
            {
              *(_QWORD *)buf = v259;
              *(_QWORD *)&buf[8] = v275;
              *(_QWORD *)&buf[16] = v269;
              *(_QWORD *)&buf[24] = v270;
              v359 = __PAIR64__(v271, v272);
              LOBYTE(v360) = v273;
              *(_DWORD *)((char *)&v360 + 1) = 0;
              DWORD1(v360) = 0;
              *((_QWORD *)&v360 + 1) = v274;
              check_oqpush_AnnotatedPositionOffset_t(v7 + 56, (uint64_t *)buf);
              goto LABEL_445;
            }
            v276 = *(_QWORD *)(v7 + 8);
            if (!v276 || v259 > v276 && v259 <= 2 * v276)
            {
              v277 = v7 + 120;
              *(_QWORD *)buf = v259;
              *(_QWORD *)&buf[8] = v275;
              *(_QWORD *)&buf[16] = v269;
              *(_QWORD *)&buf[24] = v270;
              v359 = __PAIR64__(v271, v272);
              LOBYTE(v360) = v273;
              *(_DWORD *)((char *)&v360 + 1) = 0;
              DWORD1(v360) = 0;
              *((_QWORD *)&v360 + 1) = v274;
LABEL_443:
              check_pqpush_AnnotatedPositionOffset_t(v277, (__int128 *)buf);
              goto LABEL_445;
            }
          }
          goto LABEL_476;
        }
        if (v268)
        {
          if (v268 == v11)
            goto LABEL_445;
          v278 = *(_DWORD *)(v7 + 48);
          v279 = *(_QWORD *)(v7 + 40);
          v281 = *(_DWORD *)(v7 + 148);
          v280 = *(_DWORD *)(v7 + 152);
          v282 = *(_BYTE *)(v7 + 156);
          v284 = *(_QWORD *)(v7 + 16);
          v283 = *(_QWORD *)(v7 + 24);
          if (v268 <= v11 && v268 <= *(_QWORD *)(v7 + 112))
          {
            if (!v284)
            {
              *(_QWORD *)buf = v268;
              *(_QWORD *)&buf[8] = v283;
              *(_QWORD *)&buf[16] = v278;
              *(_QWORD *)&buf[24] = v279;
              v359 = __PAIR64__(v280, v281);
              LOBYTE(v360) = v282;
              *(_QWORD *)((char *)&v360 + 1) = 0;
              *((_QWORD *)&v360 + 1) = 0;
              check_oqpush_AnnotatedPositionOffset_t(v7 + 56, (uint64_t *)buf);
              if (*(_QWORD *)(a3 + 48) > v268)
              {
                v297 = *(_QWORD *)(v7 + 8);
                if (v268 < v297 && v268 > v297 >> 1)
                  *(_QWORD *)(a3 + 48) = v268;
              }
              goto LABEL_445;
            }
          }
          else if (!v284)
          {
            v285 = *(_QWORD *)(v7 + 8);
            if (!v285 || v268 > v285 && v268 <= 2 * v285)
            {
              v286 = *(_QWORD *)(a3 + 40);
              if (v286 >= v268)
                v286 = v268;
              *(_QWORD *)(a3 + 40) = v286;
              v277 = v7 + 120;
              *(_QWORD *)buf = v268;
              *(_QWORD *)&buf[8] = v283;
              *(_QWORD *)&buf[16] = v278;
              *(_QWORD *)&buf[24] = v279;
              v359 = __PAIR64__(v280, v281);
              LOBYTE(v360) = v282;
              *(_QWORD *)((char *)&v360 + 1) = 0;
              *((_QWORD *)&v360 + 1) = 0;
              goto LABEL_443;
            }
          }
LABEL_476:
          v295 = __si_assert_copy_extra(0);
          goto LABEL_477;
        }
      }
LABEL_444:
      instr_release(*(CFTypeRef *)(v7 + 24));
      goto LABEL_445;
    }
    v164 = *(_QWORD *)(*(_QWORD *)(a3 + 384) + 8);
    if ((int)v155 + 5 >= v164)
    {
      v165 = *(void **)a3;
      v166 = *(_QWORD *)(a3 + 8) + v155;
      *(_QWORD *)(a3 + 8) = v166 & 0x3FFFFFFFFFFFF000;
      v167 = fd_pread(*(_DWORD **)(v10 + 4480), v165, v164, v166 & 0x3FFFFFFFFFFFF000);
      *(_DWORD *)(a3 + 28) = 0;
      v155 = v166 - *(_QWORD *)(a3 + 8);
      v148 = v155;
      if (v167 == -1)
      {
LABEL_375:
        v252 = 0;
        v357 = v148;
        goto LABEL_383;
      }
    }
    else
    {
      *(_DWORD *)(a3 + 28) = v151 + 1;
    }
    v161 = v155 + 1;
    v162 = v9[v155];
    if ((char)v9[v155] < 0)
    {
      if (v162 > 0xBF)
      {
        if (v162 > 0xDF)
        {
          if (v162 > 0xEF)
          {
            v162 = *(_DWORD *)&v9[v161];
            v161 = v155 + 5;
          }
          else
          {
            v162 = ((v162 & 0xF) << 24) | (v9[v161] << 16) | (v9[v155 + 2] << 8) | v9[v155 + 3];
            v161 = v155 + 4;
          }
        }
        else
        {
          v162 = ((v162 & 0x1F) << 16) | (v9[v161] << 8) | v9[v155 + 2];
          v161 = v155 + 3;
        }
      }
      else
      {
        v168 = v9[v161] | ((v162 & 0x3F) << 8);
        v161 = v155 + 2;
        v162 = v168;
      }
    }
LABEL_218:
    v169 = *(_QWORD *)(v7 + 40);
    if (!v162)
    {
      v357 = v161;
      goto LABEL_378;
    }
    if (!v169 && !v345)
      break;
    if (v169)
    {
      *(_QWORD *)(v7 + 40) = v169 - 1;
      v147 = v345;
LABEL_230:
      v10 = v352;
      do
      {
        while (1)
        {
          while (1)
          {
            while (1)
            {
              while (1)
              {
                v175 = *(_QWORD *)(*(_QWORD *)(a3 + 384) + 8);
                if ((int)v161 + 5 >= v175)
                {
                  v176 = *(void **)a3;
                  v177 = *(_QWORD *)(a3 + 8) + v161;
                  *(_QWORD *)(a3 + 8) = v177 & 0x3FFFFFFFFFFFF000;
                  v178 = fd_pread(*(_DWORD **)(v352 + 4480), v176, v175, v177 & 0x3FFFFFFFFFFFF000);
                  *(_DWORD *)(a3 + 28) = 0;
                  v161 = v177 - *(_QWORD *)(a3 + 8);
                  if (v178 == -1)
                    goto LABEL_247;
                }
                else
                {
                  ++*(_DWORD *)(a3 + 28);
                }
                v179 = v161 + 1;
                v180 = v9[v161];
                if ((char)v9[v161] < 0)
                  break;
                ++v161;
                if (!v180)
                  goto LABEL_247;
              }
              if (v180 > 0xBF)
                break;
              v161 += 2;
              if (!(v9[v179] | ((v180 & 0x3F) << 8)))
                goto LABEL_247;
            }
            if (v180 > 0xDF)
              break;
            v181 = ((v180 & 0x1F) << 16) | (v9[v179] << 8) | v9[v161 + 2];
            v161 += 3;
            if (!v181)
              goto LABEL_247;
          }
          if (v180 > 0xEF)
            break;
          v182 = ((v180 & 0xF) << 24) | (v9[v179] << 16) | (v9[v161 + 2] << 8) | v9[v161 + 3];
          v161 += 4;
          if (!v182)
            goto LABEL_247;
        }
        v161 += 5;
      }
      while (*(_DWORD *)&v9[v179]);
LABEL_247:
      v148 = v161;
      v183 = v344;
      goto LABEL_248;
    }
    v147 = v345;
    v170 = CIIndexSetHasIndex((uint64_t)a4, v345);
    v172 = *(_QWORD *)(v7 + 40);
    if (v172)
      *(_QWORD *)(v7 + 40) = v172 - 1;
    if ((v170 & 1) == 0)
      goto LABEL_230;
    if (v143)
    {
      v173 = lockedCountItemsInRange(a4, v345, v143, v171);
      if (!(v173 + v341))
        goto LABEL_470;
      v174 = v173 + v341 - 1;
      if (!v173)
        goto LABEL_268;
    }
    else
    {
      v185 = lockedCountItemsInRange(a4, v345, *(_DWORD *)(a3 + 24), v171);
      if (!v185)
      {
        v174 = 0;
        goto LABEL_268;
      }
      v174 = v185 - 1;
    }
    v186 = *(unsigned int *)(v7 + 168);
    if (v174 >= v186)
    {
      v187 = *(_DWORD *)(v7 + 168);
      if (!(_DWORD)v186)
      {
        v187 = 1 << -(char)__clz(v174);
        if (v174 <= 4)
          v187 = 4;
        *(_DWORD *)(v7 + 168) = v187;
      }
      if (v174 + 1 >= v187)
      {
        do
        {
          v221 = v174 + 1 >= 2 * v187;
          v187 *= 2;
        }
        while (v221);
        *(_DWORD *)(v7 + 168) = v187;
      }
      v188 = *(void **)(v7 + 160);
      v189 = 8 * v187;
      if (v188)
        v190 = (char *)malloc_type_zone_realloc((malloc_zone_t *)queryZone, v188, v189, 0xECA6AA46uLL);
      else
        v190 = (char *)malloc_type_zone_malloc((malloc_zone_t *)queryZone, v189, 0x8DDAA030uLL);
      v191 = v190;
      if (!v190)
        _log_fault_for_malloc_failure();
      *(_QWORD *)(a1 + 160) = v191;
      v192 = &v191[8 * v186];
      v7 = a1;
      bzero(v192, 8 * (*(unsigned int *)(a1 + 168) - v186));
    }
LABEL_268:
    v193 = *(_DWORD **)(*(_QWORD *)(v7 + 160) + 8 * v174);
    if (!v193)
    {
      v193 = CIIndexSetCreateWithRangeWithCache(0, 0x400u, (uint64_t)a2);
      *(_QWORD *)(*(_QWORD *)(v7 + 160) + 8 * v174) = v193;
    }
    v341 = v174;
    v353 = 0;
    v194 = pointerHash((uint64_t)v193, *(_DWORD *)(*(_QWORD *)(a3 + 384) + 20));
    Buffer = SharedStateGetBuffer(a3, (uint64_t)v193, v194, (int *)&v353);
    v196 = 0;
    v197 = v353++;
    v198 = *(_QWORD *)(a3 + 384);
    v199 = *(NSObject **)(v198 + 160);
    v349 = v194;
    v200 = *(NSObject **)(v198 + 8 * v194 + 32);
    do
    {
      v113 = __OFSUB__(v162, v196);
      v162 -= v196;
      if (((v162 & 0x80000000) != 0) ^ v113 | (v162 == 0))
        goto LABEL_470;
      if ((int)v162 <= 0)
        goto LABEL_476;
      v201 = v353;
      if (v353 == 4096)
      {
        *(_DWORD *)(Buffer + 4 * v197) = 4095 - v197;
        v202 = *a2;
        v203 = v353;
        dispatch_semaphore_wait(v199, 0xFFFFFFFFFFFFFFFFLL);
        *(_QWORD *)buf = MEMORY[0x1E0C809B0];
        *(_QWORD *)&buf[8] = 0x40000000;
        *(_QWORD *)&buf[16] = ___innerIssueBuffer_block_invoke;
        *(_QWORD *)&buf[24] = &__block_descriptor_tmp_63;
        v361 = v203;
        v359 = v202;
        *(_QWORD *)&v360 = Buffer;
        v362 = 1;
        *((_QWORD *)&v360 + 1) = v199;
        dispatch_async(v200, buf);
        Buffer = SharedStateResetBuffer(a3, (uint64_t)v193, v349, (int *)&v353);
        v197 = v353;
        v201 = v353 + 1;
      }
      v353 = v201 + 1;
      *(_DWORD *)(Buffer + 4 * v201) = v162;
      v204 = *(_QWORD *)(*(_QWORD *)(a3 + 384) + 8);
      if ((int)v161 + 5 >= v204)
      {
        v205 = *(void **)a3;
        v206 = *(_QWORD *)(a3 + 8) + v161;
        *(_QWORD *)(a3 + 8) = v206 & 0x3FFFFFFFFFFFF000;
        v207 = fd_pread(*(_DWORD **)(v352 + 4480), v205, v204, v206 & 0x3FFFFFFFFFFFF000);
        *(_DWORD *)(a3 + 28) = 0;
        v161 = v206 - *(_QWORD *)(a3 + 8);
        v148 = v161;
        if (v207 == -1)
          break;
      }
      else
      {
        ++*(_DWORD *)(a3 + 28);
      }
      v148 = v161 + 1;
      v196 = v9[v161];
      if ((char)v9[v161] < 0)
      {
        if (v196 > 0xBF)
        {
          if (v196 > 0xDF)
          {
            if (v196 > 0xEF)
            {
              v196 = *(_DWORD *)&v9[v148];
              v148 = v161 + 5;
            }
            else
            {
              v196 = ((v196 & 0xF) << 24) | (v9[v148] << 16) | (v9[v161 + 2] << 8) | v9[v161 + 3];
              v148 = v161 + 4;
            }
          }
          else
          {
            v196 = ((v196 & 0x1F) << 16) | (v9[v148] << 8) | v9[v161 + 2];
            v148 = v161 + 3;
          }
        }
        else
        {
          v208 = v9[v148] | ((v196 & 0x3F) << 8);
          v148 = v161 + 2;
          v196 = v208;
        }
      }
      if (v196)
        v209 = (int)v162 <= (int)v196;
      else
        v209 = 1;
      v161 = v148;
    }
    while (!v209);
    *(_DWORD *)(Buffer + 4 * v197) = v353 + ~v197;
    v210 = v353;
    if (v353 - 4092 > 0xFFFFEFFF)
    {
      v7 = a1;
      v10 = v352;
      v19 = (_DWORD *)&unk_1EF19F000;
      v183 = v344;
      v212 = v349;
    }
    else
    {
      v211 = *a2;
      dispatch_semaphore_wait(v199, 0xFFFFFFFFFFFFFFFFLL);
      *(_QWORD *)buf = MEMORY[0x1E0C809B0];
      *(_QWORD *)&buf[8] = 0x40000000;
      *(_QWORD *)&buf[16] = ___innerIssueBuffer_block_invoke;
      *(_QWORD *)&buf[24] = &__block_descriptor_tmp_63;
      v361 = v210;
      v359 = v211;
      *(_QWORD *)&v360 = Buffer;
      v362 = 1;
      *((_QWORD *)&v360 + 1) = v199;
      dispatch_async(v200, buf);
      v210 = 0;
      v212 = v349;
      *(_QWORD *)(a3 + 8 * v349 + 192) = 0;
      v7 = a1;
      v10 = v352;
      v19 = (_DWORD *)&unk_1EF19F000;
      v183 = v344;
    }
    *(_DWORD *)(a3 + 4 * v212 + 320) = v210;
    v147 = v345;
    v143 = v345;
LABEL_248:
    v184 = *(_DWORD *)(a3 + 56);
    if (v184 >= v147)
      v184 = v147;
    *(_DWORD *)(a3 + 56) = v184;
    v144 = v183 + 1;
  }
  v357 = v161;
  if (v340)
  {
    v248 = *__error();
    v249 = _SILogForLogForCategory(10);
    v250 = 2 * (v19[813] < 4);
    if (os_log_type_enabled(v249, v250))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = v162;
      _os_log_impl(&dword_1B8270000, v249, v250, "Out of postings while we still have more position data (%u)", buf, 8u);
    }
    v251 = __error();
    v252 = 0;
    *v251 = v248;
    v7 = a1;
LABEL_383:
    v11 = v343;
    goto LABEL_384;
  }
  v287 = *(_DWORD *)(a3 + 32);
  *(_DWORD *)(v7 + 148) = v287;
  *(_DWORD *)(v7 + 48) = v147;
  DWORD1(v360) = 0;
  *(_DWORD *)((char *)&v360 + 1) = 0;
  v288 = *(_DWORD *)(v7 + 152);
  v289 = *(_BYTE *)(v7 + 156);
  v291 = *(_QWORD *)(v7 + 16);
  v290 = *(_QWORD *)(v7 + 24);
  *(_QWORD *)buf = *(_QWORD *)v7;
  *(_QWORD *)&buf[8] = v290;
  *(_QWORD *)&buf[16] = v147;
  *(_QWORD *)&buf[24] = v344;
  v359 = __PAIR64__(v288, v287);
  LOBYTE(v360) = v289;
  *((_QWORD *)&v360 + 1) = v291;
  deferPosition(v7, (uint64_t)buf);
  v11 = v343;
LABEL_445:
  *(_DWORD *)(v7 + 148) = 0;
  *(_QWORD *)v7 = 0;
  *(_QWORD *)(v7 + 16) = 0;
  *(_QWORD *)(v7 + 24) = 0;
LABEL_446:
  PositionIterator_GetNext(v7);
  v247 = *(_QWORD *)v7;
  if (v11 && v11 == v247)
    return 0;
  if (!*(_DWORD *)(v7 + 188))
    goto LABEL_454;
  if (!v247)
    goto LABEL_451;
  return 0xFFFFFFFFLL;
}

