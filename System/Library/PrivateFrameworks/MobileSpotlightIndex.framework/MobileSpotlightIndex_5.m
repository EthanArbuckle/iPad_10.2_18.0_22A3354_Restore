const __CFString *convertCommaSeparatedNumberTokenWithNumberFormatter(const __CFString *a1)
{
  const __CFString *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  id *v7;
  void *v8;
  char v9;
  void *v10;
  PRQueryNumberFormatters *v11;
  id *v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;

  if (!a1)
    return &stru_1E6E3A6D8;
  v2 = &stru_1E6E3A6D8;
  if ((unint64_t)(CFStringGetLength(a1) - 4) <= 0x13)
  {
    v3 = (void *)objc_msgSend(MEMORY[0x1E0C99DC8], "currentLocale");
    v4 = objc_msgSend(v3, "localeIdentifier");
    if (v4)
    {
      v5 = v4;
      os_unfair_lock_lock(&copyNumberFormatters_sUnfairLock);
      if (copyNumberFormatters_sFormatters)
        v6 = *(void **)(copyNumberFormatters_sFormatters + 8);
      else
        v6 = 0;
      if ((objc_msgSend((id)objc_msgSend(v6, "localeIdentifier"), "isEqualToString:", v5) & 1) != 0)
      {
        v7 = (id *)(id)copyNumberFormatters_sFormatters;
        os_unfair_lock_unlock(&copyNumberFormatters_sUnfairLock);
        if (v7)
          goto LABEL_17;
      }
      else
      {
        os_unfair_lock_unlock(&copyNumberFormatters_sUnfairLock);
      }
      os_unfair_lock_lock(&copyNumberFormatters_sUnfairLock);
      if (copyNumberFormatters_sFormatters)
        v8 = *(void **)(copyNumberFormatters_sFormatters + 8);
      else
        v8 = 0;
      v9 = objc_msgSend((id)objc_msgSend(v8, "localeIdentifier"), "isEqualToString:", objc_msgSend(v3, "localeIdentifier"));
      v10 = (void *)copyNumberFormatters_sFormatters;
      if ((v9 & 1) != 0)
      {
        v11 = (PRQueryNumberFormatters *)copyNumberFormatters_sFormatters;
        v10 = 0;
      }
      else
      {
        v11 = -[PRQueryNumberFormatters initWithLocale:]([PRQueryNumberFormatters alloc], "initWithLocale:", v3);
        copyNumberFormatters_sFormatters = (uint64_t)v11;
      }
      v7 = v11;
      os_unfair_lock_unlock(&copyNumberFormatters_sUnfairLock);

      if (v7)
      {
LABEL_17:
        v12 = v7 + 5;
        v13 = objc_msgSend(v7[5], "numberFromString:", a1);
        if (v13)
        {
          v14 = v13;
          v15 = (void *)objc_msgSend(v7[4], "stringFromNumber:", v13);
          if ((objc_msgSend(v15, "isEqualToString:", a1) & 1) == 0)
            goto LABEL_25;
        }
        else
        {
          v12 = v7 + 3;
          v16 = objc_msgSend(v7[3], "numberFromString:", a1);
          if (!v16)
          {
            v15 = 0;
            goto LABEL_25;
          }
          v14 = v16;
          v15 = (void *)objc_msgSend(v7[2], "stringFromNumber:", v16);
          if (!objc_msgSend(v15, "isEqualToString:", a1))
          {
LABEL_25:

LABEL_26:
            if (v15)
              return (const __CFString *)v15;
            return v2;
          }
        }
        v15 = (void *)objc_msgSend(*v12, "stringFromNumber:", v14);
        goto LABEL_25;
      }
    }
    v15 = 0;
    goto LABEL_26;
  }
  return v2;
}

_BYTE *packPostingChunkUpdatesWithType(_BYTE *result, unint64_t *a2, unsigned int a3)
{
  unint64_t v3;
  unint64_t *v4;
  uint64_t v5;
  char v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  size_t v10;
  void *v11;
  uint64_t v12;
  size_t v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  size_t v17;
  uint64_t v18;
  void *v19;
  size_t v20;
  uint64_t v21;

  v3 = *a2;
  if (*a2)
  {
    v4 = a2;
    v5 = (uint64_t)result;
    v6 = 0;
    v7 = a3;
    do
    {
      if ((v6 & 1) != 0)
      {
        packRelativeVDocID(v5, v3);
      }
      else
      {
        v10 = *(_QWORD *)(v5 + 8);
        v9 = *(_QWORD *)(v5 + 16);
        if (v9 + 10 > v10)
        {
          do
            v10 *= 2;
          while (v10 < v9 + 10);
          *(_QWORD *)(v5 + 8) = v10;
          v11 = malloc_type_realloc(*(void **)v5, v10, 0xBCA72133uLL);
          *(_QWORD *)v5 = v11;
          v9 = *(_QWORD *)(v5 + 16);
        }
        else
        {
          v11 = *(void **)v5;
        }
        v12 = writeVInt64((uint64_t)v11, v9, v3);
        *(_QWORD *)(v5 + 16) = v12;
        *(_QWORD *)(v5 + 24) = v3;
        v13 = *(_QWORD *)(v5 + 8);
        if (v12 + 10 > v13)
        {
          do
            v13 *= 2;
          while (v13 < v12 + 10);
          *(_QWORD *)(v5 + 8) = v13;
          v15 = malloc_type_realloc(*(void **)v5, v13, 0xBCA72133uLL);
          *(_QWORD *)v5 = v15;
          v14 = *(_QWORD *)(v5 + 16);
        }
        else
        {
          v14 = v12;
          v15 = *(void **)v5;
        }
        v16 = writeVInt64((uint64_t)v15, v14, v3);
        *(_QWORD *)(v5 + 16) = v16;
        *(_QWORD *)(v5 + 24) = v3;
        v17 = *(_QWORD *)(v5 + 8);
        if (v16 + 10 > v17)
        {
          do
            v17 *= 2;
          while (v17 < v16 + 10);
          *(_QWORD *)(v5 + 8) = v17;
          v19 = malloc_type_realloc(*(void **)v5, v17, 0xBCA72133uLL);
          *(_QWORD *)v5 = v19;
          v18 = *(_QWORD *)(v5 + 16);
        }
        else
        {
          v18 = v16;
          v19 = *(void **)v5;
        }
        *(_QWORD *)(v5 + 16) = writeVInt64((uint64_t)v19, v18, v7);
      }
      v8 = v4[1];
      ++v4;
      v3 = v8;
      v6 = 1;
    }
    while (v8);
    v20 = *(_QWORD *)(v5 + 8);
    v21 = *(_QWORD *)(v5 + 16);
    if (v21 + 10 > v20)
    {
      do
        v20 *= 2;
      while (v20 < v21 + 10);
      *(_QWORD *)(v5 + 8) = v20;
      result = malloc_type_realloc(*(void **)v5, v20, 0xBCA72133uLL);
      *(_QWORD *)v5 = result;
      v21 = *(_QWORD *)(v5 + 16);
    }
    else
    {
      result = *(_BYTE **)v5;
    }
    result[v21] = 0;
    *(_QWORD *)(v5 + 16) = v21 + 1;
    *(_QWORD *)(v5 + 24) = 0;
  }
  return result;
}

unint64_t PostingChunkEnumeratorNextDocID(unint64_t *a1, int *a2)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  char v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char v15;
  int v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unsigned int v25;
  unint64_t v26;
  unint64_t v27;
  unsigned int v28;
  uint64_t v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unsigned int v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v46;
  int v47;
  unint64_t v48;
  unint64_t v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  char *v56;
  int v57;
  char *v58;
  uint64_t v59;
  unint64_t v60;
  int v61;
  int v62;
  unint64_t v63;
  int v64;
  int v65;
  int v66;
  int v67;
  unint64_t v68;
  unint64_t v69;
  unint64_t v70;
  unint64_t v71;

  v71 = 0;
  LODWORD(v4) = *((_DWORD *)a1 + 9);
  while (2)
  {
    switch((int)v4)
    {
      case 0:
        v10 = a1[3];
        if (v71 >= v10)
          goto LABEL_114;
        v11 = 0;
        v12 = 0;
        v13 = a1[2];
        v14 = v71;
        while (1)
        {
          v15 = *(_BYTE *)(v13 + v14++);
          v12 |= (unint64_t)(v15 & 0x7F) << v11;
          if ((v15 & 0x80) == 0 || v11 == 63)
            break;
          v11 += 7;
          if (v10 == v14)
          {
LABEL_16:
            v58 = __si_assert_copy_extra_268();
            __message_assert("%s:%u: failed assertion '%s' %s Offset past bounds; incoming %ld, current %ld, buffer length %ld, val %llu from %d",
              "PostingChunk.c",
              90);
            goto LABEL_97;
          }
        }
        v71 = v14;
        *a1 = v12;
        if (v14 >= v10 || !v12)
          goto LABEL_114;
        v21 = 0;
        v22 = 0;
        v23 = v14;
        while (1)
        {
          v24 = v23 + 1;
          v22 |= (unint64_t)(*(_BYTE *)(v13 + v23) & 0x7F) << v21;
          if ((*(_BYTE *)(v13 + v23) & 0x80) == 0 || v21 == 63)
            break;
          v21 += 7;
          ++v23;
          if (v10 == v24)
            goto LABEL_16;
        }
        v71 = v23 + 1;
        a1[1] = v22;
        if (v12 > v22)
        {
          v36 = 0;
          *((_DWORD *)a1 + 9) = 2;
          goto LABEL_67;
        }
        if (v12 < v22)
        {
          if (*(_BYTE *)(v13 + v24))
          {
            v36 = 0;
            v12 = v22 - 1;
            *((_DWORD *)a1 + 9) = 3;
            v71 = v23 + 2;
            *((_DWORD *)a1 + 8) = *(_BYTE *)(v13 + v24) & 0xFE;
            goto LABEL_67;
          }
          v71 = v23 + 2;
          a1[4] = 0x400000000;
          LODWORD(v4) = 4;
          continue;
        }
        if (v12 != v22)
        {
          v12 = 0;
          v36 = 0;
          goto LABEL_67;
        }
        if (v24 >= v10)
          goto LABEL_114;
        v46 = v23 + 6;
        if (v23 + 6 <= v10)
        {
          v49 = v23 + 2;
          v50 = *(char *)(v13 + v24);
          v47 = v50;
          if (v50 < 0)
          {
            v53 = *(char *)(v13 + v49);
            v54 = *(unsigned __int8 *)(v13 + v49);
            if (v53 < 0)
            {
              v57 = *(unsigned __int8 *)(v13 + v23 + 3);
              if (*(char *)(v13 + v23 + 3) < 0)
              {
                v63 = v23 + 5;
                v64 = *(char *)(v13 + v23 + 4);
                v65 = *(unsigned __int8 *)(v13 + v23 + 4);
                if (v64 < 0)
                {
                  v67 = *(char *)(v13 + v63);
                  if (v67 < 0)
                  {
LABEL_123:
                    v56 = __si_assert_copy_extra_268();
                    __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t");
LABEL_92:
                    free(v56);
                    if (__valid_fs(-1))
                    {
                      MEMORY[0xBAD] = -559038737;
                      abort();
                    }
                    MEMORY[0xC00] = -559038737;
                    abort();
                  }
                  v47 = ((v65 & 0x7F) << 21) | (v67 << 28) | ((v57 & 0x7F) << 14) | ((v54 & 0x7F) << 7) | v47 & 0x7F;
                  v71 = v46;
                }
                else
                {
                  v47 = ((v57 & 0x7F) << 14) | (v65 << 21) | ((v54 & 0x7F) << 7) | v47 & 0x7F;
                  v71 = v63;
                }
              }
              else
              {
                v47 = ((v54 & 0x7F) << 7) | (v57 << 14) | v50 & 0x7F;
                v71 = v23 + 4;
              }
            }
            else
            {
              v47 = v50 & 0x7F | (v54 << 7);
              v71 = v23 + 3;
            }
          }
          else
          {
            v71 = v23 + 2;
          }
        }
        else
        {
          v47 = _protectedReadVInt32(v13, &v71, v10);
        }
        switch(v47)
        {
          case 2:
            *((_DWORD *)a1 + 9) = 6;
            v36 = 2;
            break;
          case 1:
            *((_DWORD *)a1 + 9) = 5;
            v36 = 1;
            break;
          case 0:
            *((_DWORD *)a1 + 9) = 0;
            v36 = 1;
            *a1 = 0;
            a1[1] = 0;
            break;
          default:
LABEL_114:
            v12 = 0;
            *((_DWORD *)a1 + 9) = 1;
            v68 = a1[3];
            if (v71 >= v68)
              v69 = a1[3];
            else
              v69 = v71;
            v70 = v68 - v71;
            if (v68 < v71)
              v70 = 0;
            a1[2] += v69;
            a1[3] = v70;
            if (a2)
            {
              v36 = 0;
              goto LABEL_73;
            }
            return v12;
        }
LABEL_67:
        v42 = a1[3];
        if (v71 >= v42)
          v43 = a1[3];
        else
          v43 = v71;
        v44 = v42 - v71;
        if (v42 < v71)
          v44 = 0;
        a1[2] += v43;
        a1[3] = v44;
        if (a2)
LABEL_73:
          *a2 = v36;
        return v12;
      case 2:
        v4 = a1[1];
        if (v4)
        {
          v37 = v71;
          v38 = a1[3];
          if (v71 >= v38)
            goto LABEL_114;
          v12 = *a1 - v4;
          *a1 = v12;
          v39 = a1[2];
          v40 = v37 + 5;
          if (v37 + 5 <= v38)
          {
            v48 = v37 + 1;
            v41 = *(unsigned __int8 *)(v39 + v37);
            if (*(char *)(v39 + v37) < 0)
            {
              v51 = *(char *)(v39 + v48);
              v52 = *(unsigned __int8 *)(v39 + v48);
              if (v51 < 0)
              {
                v55 = *(unsigned __int8 *)(v39 + v37 + 2);
                if (*(char *)(v39 + v37 + 2) < 0)
                {
                  v60 = v37 + 4;
                  v61 = *(char *)(v39 + v37 + 3);
                  v62 = *(unsigned __int8 *)(v39 + v37 + 3);
                  if (v61 < 0)
                  {
                    v66 = *(char *)(v39 + v60);
                    if (v66 < 0)
                    {
                      v58 = __si_assert_copy_extra_268();
                      __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t");
LABEL_97:
                      free(v58);
                      if (__valid_fs(-1))
                        v59 = 2989;
                      else
                        v59 = 3072;
                      *(_DWORD *)v59 = -559038737;
                      abort();
                    }
                    v41 = ((v62 & 0x7F) << 21) | (v66 << 28) | ((v55 & 0x7F) << 14) | ((v52 & 0x7F) << 7) | v41 & 0x7F;
                    v71 = v40;
                  }
                  else
                  {
                    v41 = ((v55 & 0x7F) << 14) | (v62 << 21) | ((v52 & 0x7F) << 7) | v41 & 0x7F;
                    v71 = v60;
                  }
                }
                else
                {
                  v41 = ((v52 & 0x7F) << 7) | (v55 << 14) | v41 & 0x7F;
                  v71 = v37 + 3;
                }
              }
              else
              {
                v41 = v41 & 0x7F | (v52 << 7);
                v71 = v37 + 2;
              }
            }
            else
            {
              v71 = v37 + 1;
            }
          }
          else
          {
            v41 = _protectedReadVInt32(a1[2], &v71, v38);
            v12 = *a1;
          }
          v36 = 0;
          a1[1] = v41;
          goto LABEL_67;
        }
        *((_DWORD *)a1 + 9) = 0;
        continue;
      case 3:
        v16 = *((_DWORD *)a1 + 8);
        v17 = v71;
        if (v16)
        {
          v18 = a1[1];
          v20 = v71;
LABEL_66:
          v36 = 0;
          v71 = v20;
          v12 = v18
              - PostingChunkEnumeratorNextDocID_sBitToIndex1[(((v16 - 1) & v16 ^ v16)
                                                                             - 11
                                                                             * ((((117
                                                                                 * ((v16 - 1) & v16 ^ v16)) >> 8)
                                                                               + (((((v16 - 1) & v16 ^ v16) - ((unsigned __int16)(117 * ((v16 - 1) & v16 ^ v16)) >> 8)) & 0xFE) >> 1)) >> 3))];
          *((_DWORD *)a1 + 8) = (v16 - 1) & v16;
          goto LABEL_67;
        }
        v18 = a1[1];
        v19 = -(uint64_t)*a1;
        while (v19 + v18 >= 9 && v17 < a1[3])
        {
          v18 -= 8;
          a1[1] = v18;
          v20 = v17 + 1;
          v16 = *(unsigned __int8 *)(a1[2] + v17);
          *((_DWORD *)a1 + 8) = v16;
          ++v17;
          if (v16)
            goto LABEL_66;
        }
        LODWORD(v4) = 0;
        v71 = v17;
        *((_DWORD *)a1 + 9) = 0;
        continue;
      case 4:
        v12 = a1[1];
        if (v12 < *a1)
          goto LABEL_26;
        v25 = *((_DWORD *)a1 + 8);
        if (v25)
          goto LABEL_58;
        do
        {
          v26 = a1[3];
          if (v71 >= v26)
            goto LABEL_114;
          v27 = a1[2];
          if (v71 + 5 <= v26)
          {
            v29 = v71 + 1;
            v28 = *(unsigned __int8 *)(v27 + v71);
            if (*(char *)(v27 + v71) < 0)
            {
              v30 = *(char *)(v27 + v29);
              v31 = *(unsigned __int8 *)(v27 + v29);
              if (v30 < 0)
              {
                v32 = *(unsigned __int8 *)(v27 + v71 + 2);
                if (*(char *)(v27 + v71 + 2) < 0)
                {
                  v33 = *(unsigned __int8 *)(v27 + v71 + 3);
                  if (*(char *)(v27 + v71 + 3) < 0)
                  {
                    v34 = *(char *)(v27 + v71 + 4);
                    if (v34 < 0)
                      goto LABEL_123;
                    v28 = ((v33 & 0x7F) << 21) | (v34 << 28) | ((v32 & 0x7F) << 14) | ((v31 & 0x7F) << 7) | v28 & 0x7F;
                    v71 += 5;
                  }
                  else
                  {
                    v28 = ((v32 & 0x7F) << 14) | (v33 << 21) | ((v31 & 0x7F) << 7) | v28 & 0x7F;
                    v71 += 4;
                  }
                }
                else
                {
                  v28 = ((v31 & 0x7F) << 7) | (v32 << 14) | v28 & 0x7F;
                  v71 += 3;
                }
              }
              else
              {
                v28 = v28 & 0x7F | (v31 << 7);
                v71 += 2;
              }
            }
            else
            {
              ++v71;
            }
          }
          else
          {
            v28 = _protectedReadVInt32(a1[2], &v71, v26);
            v12 = a1[1];
          }
          a1[1] = --v12;
          if (v28 >= 2)
          {
            v25 = v28 - 1;
            goto LABEL_58;
          }
        }
        while (v28);
        v35 = v12 - *(_DWORD *)a1;
        v25 = v35 + 1;
        *((_DWORD *)a1 + 8) = v35 + 1;
        if (v35 == -1)
          goto LABEL_26;
LABEL_58:
        v36 = 0;
        *((_DWORD *)a1 + 8) = v25 - 1;
        a1[1] = v12 - 1;
        goto LABEL_67;
      case 5:
      case 6:
        v5 = a1[3];
        if (v71 >= v5)
          goto LABEL_114;
        v6 = 0;
        v7 = 0;
        v8 = v71;
        while (1)
        {
          v9 = *(_BYTE *)(a1[2] + v8++);
          v7 |= (unint64_t)(v9 & 0x7F) << v6;
          if ((v9 & 0x80) == 0 || v6 == 63)
            break;
          v6 += 7;
          if (v5 == v8)
          {
            v56 = __si_assert_copy_extra_268();
            __message_assert("%s:%u: failed assertion '%s' %s Offset past bounds; incoming %ld, current %ld, buffer length %ld, val %llu from %d",
              "PostingChunk.c",
              90);
            goto LABEL_92;
          }
        }
        v71 = v8;
        if (v7)
        {
          v12 = *a1 - v7;
          *a1 = v12;
          if ((_DWORD)v4 == 5)
            v36 = 1;
          else
            v36 = 2;
          goto LABEL_67;
        }
LABEL_26:
        LODWORD(v4) = 0;
        *((_DWORD *)a1 + 9) = 0;
        continue;
      default:
        goto LABEL_114;
    }
  }
}

void FlattenPostingsContextDestroy(void **a1)
{
  if (a1)
  {
    free(*a1);
    free(a1[2]);
    free(a1[4]);
  }
}

__n128 std::__introsort<std::_ClassicAlgPolicy,SIWordTrieFragmentGetBundleIDs::$_0 &,std::pair<unsigned int,ci_rankingbits_wrapped_s> *,false>(int *a1, int *a2, uint64_t a3, char a4, __n128 result)
{
  int *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  __n128 *v14;
  __n128 v15;
  __n128 *v16;
  __n128 v17;
  __n128 v18;
  unsigned __int32 v19;
  __n128 v20;
  __n128 v21;
  __n128 v22;
  float v23;
  float v24;
  unint64_t v25;
  unint64_t v26;
  float v28;
  float v29;
  uint64_t v30;
  unint64_t v31;
  int v32;
  unint64_t v33;
  unsigned int v34;
  float v35;
  int v36;
  float v37;
  int *v38;
  float v39;
  unint64_t v40;
  unint64_t v41;
  int *v42;
  float v44;
  int *v45;
  unint64_t v46;
  int *v47;
  float v48;
  float v50;
  float v51;
  float v53;
  int *v54;
  int v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  float v59;
  float v61;
  float v62;
  float v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  BOOL v68;
  __n128 v69;
  int v70;
  unint64_t v71;
  unint64_t v72;
  unsigned int v73;
  int v74;
  float v75;
  int v76;
  float v77;
  float v78;
  unint64_t v79;
  float v80;
  int *j;
  uint64_t v82;
  uint64_t v83;
  int *v84;
  float v85;
  BOOL v86;
  float v87;
  float v88;
  float v89;
  float v91;
  BOOL v92;
  float v94;
  float v95;
  float v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  int v100;
  __int128 v101;
  __int128 v102;
  __int128 v103;
  float v104;
  unint64_t v105;
  float v106;
  uint64_t v107;
  uint64_t v108;
  float v110;
  float v111;
  float v112;
  float v114;
  float v116;
  float v117;
  int *v118;
  BOOL v120;
  uint64_t v121;
  int *v122;
  unint64_t *v123;
  _OWORD *v124;
  int v125;
  float v126;
  unint64_t v127;
  unint64_t v128;
  float v130;
  int v131;
  unint64_t v132;
  unint64_t v133;
  unsigned int v134;
  int v135;
  float v136;
  __int128 v137;
  __int128 v138;
  uint64_t v139;
  __int128 v140;
  __int128 v141;
  uint64_t v142;
  float v143;
  float v144;
  __int128 v145;
  __int128 v146;
  uint64_t v147;
  float v149;
  int64_t v150;
  int64_t v151;
  unint64_t v152;
  int64_t v153;
  uint64_t v154;
  float v155;
  float v156;
  unint64_t v157;
  unint64_t v158;
  float v160;
  float v161;
  float v162;
  float v163;
  unint64_t v164;
  unint64_t v165;
  float v167;
  float v168;
  int *v169;
  int v170;
  unint64_t v171;
  unint64_t v172;
  unsigned int v173;
  float v174;
  int v175;
  float v176;
  __int128 v177;
  __int128 v178;
  __int128 v179;
  __int128 v180;
  __int128 v181;
  __int128 v182;
  unint64_t v183;
  uint64_t v184;
  uint64_t v185;
  float v186;
  float v187;
  unint64_t v188;
  unint64_t v189;
  float v191;
  float v192;
  float v193;
  float v195;
  int64_t v196;
  uint64_t v198;
  int v199;
  unint64_t v200;
  __int128 v201;
  __int128 v202;
  __int128 v203;
  unint64_t v204;
  uint64_t v205;
  uint64_t v206;
  int64_t v207;
  float v208;
  float v209;
  unint64_t v210;
  unint64_t v211;
  float v213;
  float v214;
  _OWORD *v215;
  __int128 v216;
  __int128 v217;
  __int128 v218;
  uint64_t v219;
  unint64_t v220;
  unint64_t v221;
  _OWORD *v222;
  float v223;
  unint64_t v224;
  unint64_t v225;
  float v227;
  int v228;
  unint64_t v229;
  unint64_t v230;
  unsigned int v231;
  float v232;
  int v233;
  float v234;
  _OWORD *v235;
  unint64_t *v236;
  __int128 v237;
  __int128 v238;
  __int128 v239;
  _OWORD *v240;
  _OWORD *v241;
  __int128 v242;
  __int128 v243;
  __int128 v244;
  unint64_t v245;
  float v246;
  float v248;
  _OWORD *i;
  unint64_t *v250;
  int *v251;
  int *v252;
  char v253;
  float v254;
  unint64_t v255;
  unint64_t v256;
  float v258;
  int v259;
  unint64_t v260;
  unint64_t v261;
  unsigned int v262;
  int v263;
  _OWORD *v264;
  float v265;
  __int128 v266;
  __int128 v267;
  float v269;
  __int128 v270;
  __int128 v271;
  float v272;
  float v273;
  float v275;
  int v276;
  __int128 v277;
  __int128 v278;
  __int128 v279;
  int *v280;
  int v281;
  char v282;
  __n128 v283;
  __int128 v284;
  __int128 v285;
  __n128 v286;
  __int128 v287;
  __n128 v288;
  __int128 v289;
  __int128 v290;
  __n128 v291;
  __int128 v292;
  __int128 v293;
  __int128 v294;
  __int128 v295;
  __int128 v296;
  __n128 v297;
  __n128 v298;
  __n128 v299;
  __int128 v300;
  __int128 v301;
  __int128 v302;
  __int128 v303;
  __n128 v304;
  __int128 v305;
  __int128 v306;
  __int128 v307;
  __int128 v308;
  __n128 v309;
  __int128 v310;
  __int128 v311;
  __int128 v312;
  __int128 v313;
  __n128 v314;
  uint64_t v315;
  int v316;
  __int128 v317;
  int v318;
  char v319;
  char v320;
  __int16 v321;
  __int128 v322;
  __n128 v323;
  uint64_t v324;
  __int128 v325;
  __int128 v326;
  uint64_t v327;
  __int16 v328;
  __int16 v329;
  __int128 v330;
  __int128 v331;
  __int128 v332;

  while (1)
  {
    v9 = a2 - 24;
    v280 = a2 - 20;
    v10 = (unint64_t)a1;
    while (2)
    {
      a1 = (int *)v10;
      v11 = (uint64_t)a2 - v10;
      v12 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)((uint64_t)a2 - v10) >> 5);
      switch(v12)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          if (!*((_BYTE *)a2 - 11))
          {
            if (*(_OWORD *)v280 >= *(_OWORD *)(v10 + 16))
            {
              if (*((_QWORD *)a2 - 9) != *(_QWORD *)(v10 + 24) || *(_QWORD *)v280 != *(_QWORD *)(v10 + 16))
                return result;
              goto LABEL_458;
            }
LABEL_461:
            v276 = *(_DWORD *)v10;
            *(_DWORD *)v10 = *v9;
            *v9 = v276;
            v307 = *(_OWORD *)(v10 + 64);
            v312 = *(_OWORD *)(v10 + 80);
            v297 = *(__n128 *)(v10 + 32);
            v302 = *(_OWORD *)(v10 + 48);
            v289 = *(_OWORD *)(v10 + 16);
            *(_OWORD *)(v10 + 16) = *(_OWORD *)v280;
            v277 = *((_OWORD *)a2 - 3);
            v279 = *((_OWORD *)a2 - 2);
            v278 = *((_OWORD *)a2 - 1);
            *(_OWORD *)(v10 + 32) = *((_OWORD *)a2 - 4);
            *(_OWORD *)(v10 + 48) = v277;
            *(_OWORD *)(v10 + 64) = v279;
            *(_OWORD *)(v10 + 80) = v278;
            *(_OWORD *)v280 = v289;
            result = v297;
            *((_OWORD *)a2 - 2) = v307;
            *((_OWORD *)a2 - 1) = v312;
            *((__n128 *)a2 - 4) = v297;
            *((_OWORD *)a2 - 3) = v302;
            return result;
          }
          result.n128_u32[0] = *(a2 - 5);
          v117 = *(float *)(v10 + 76);
          if (result.n128_f32[0] < v117)
            goto LABEL_461;
          if (result.n128_f32[0] != v117)
            return result;
LABEL_458:
          result.n128_u32[0] = *(a2 - 7);
          v275 = *(float *)(v10 + 68);
          if (result.n128_f32[0] < v275
            || result.n128_f32[0] == v275 && *(a2 - 8) > *(_DWORD *)(v10 + 64))
          {
            goto LABEL_461;
          }
          return result;
        case 3uLL:
          result.n128_u64[0] = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,SIWordTrieFragmentGetBundleIDs::$_0 &,std::pair<unsigned int,ci_rankingbits_wrapped_s> *>((__n128 *)v10, (__n128 *)(v10 + 96), (__n128 *)a2 - 6, result).n128_u64[0];
          return result;
        case 4uLL:
          result.n128_u64[0] = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,SIWordTrieFragmentGetBundleIDs::$_0 &,std::pair<unsigned int,ci_rankingbits_wrapped_s> *>((__n128 *)v10, (__n128 *)(v10 + 96), (__n128 *)(v10 + 192), (__n128 *)a2 - 6, result).n128_u64[0];
          return result;
        case 5uLL:
          result.n128_u64[0] = std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,SIWordTrieFragmentGetBundleIDs::$_0 &,std::pair<unsigned int,ci_rankingbits_wrapped_s> *,0>((__n128 *)v10, (__n128 *)(v10 + 96), (__n128 *)(v10 + 192), (__n128 *)(v10 + 288), (__n128 *)a2 - 6, result).n128_u64[0];
          return result;
        default:
          if (v11 <= 2303)
          {
            v118 = (int *)(v10 + 96);
            v120 = (int *)v10 == a2 || v118 == a2;
            if ((a4 & 1) != 0)
            {
              if (v120)
                return result;
              v121 = 0;
              v122 = (int *)v10;
LABEL_261:
              v124 = v122;
              v122 = v118;
              v125 = *((unsigned __int8 *)v124 + 181);
              if (*((_BYTE *)v124 + 181))
              {
                result.n128_u32[0] = *((_DWORD *)v124 + 43);
                v126 = *((float *)v124 + 19);
                if (result.n128_f32[0] >= v126)
                {
                  if (result.n128_f32[0] != v126)
                    goto LABEL_260;
LABEL_271:
                  result.n128_u32[0] = *((_DWORD *)v124 + 41);
                  v130 = *((float *)v124 + 17);
                  if (result.n128_f32[0] >= v130
                    && (result.n128_f32[0] != v130 || *((_DWORD *)v124 + 40) <= *((_DWORD *)v124 + 16)))
                  {
                    goto LABEL_260;
                  }
                }
              }
              else
              {
                v128 = *((_QWORD *)v124 + 14);
                v127 = *((_QWORD *)v124 + 15);
                if (__PAIR128__(v127, v128) >= v124[1])
                {
                  if (v127 != *((_QWORD *)v124 + 3) || v128 != *((_QWORD *)v124 + 2))
                    goto LABEL_260;
                  goto LABEL_271;
                }
              }
              v131 = *((_DWORD *)v124 + 24);
              v133 = *((_QWORD *)v124 + 14);
              v132 = *((_QWORD *)v124 + 15);
              result = *((__n128 *)v124 + 8);
              v286 = result;
              v294 = v124[9];
              v134 = *((_DWORD *)v124 + 40);
              result.n128_u32[0] = *((_DWORD *)v124 + 41);
              v135 = *((_DWORD *)v124 + 42);
              v136 = *((float *)v124 + 43);
              v316 = *((_DWORD *)v124 + 44);
              v319 = *((_BYTE *)v124 + 180);
              v328 = *((_WORD *)v124 + 95);
              v324 = *(_QWORD *)((char *)v124 + 182);
              *((_DWORD *)v124 + 24) = *(_DWORD *)v124;
              v123 = (unint64_t *)(v124 + 1);
              v137 = v124[4];
              *((_OWORD *)v122 + 3) = v124[3];
              *((_OWORD *)v122 + 4) = v137;
              *((_OWORD *)v122 + 5) = v124[5];
              v138 = v124[2];
              *((_OWORD *)v122 + 1) = v124[1];
              *((_OWORD *)v122 + 2) = v138;
              if (v124 == (_OWORD *)v10)
              {
LABEL_258:
                v124 = (_OWORD *)v10;
                goto LABEL_259;
              }
              v139 = v121;
              if (!v125)
              {
                while (1)
                {
                  v147 = v10 + v139;
                  if (__PAIR128__(v132, v133) >= *(_OWORD *)(v10 + v139 - 80))
                  {
                    if (v132 != *(_QWORD *)(v10 + v139 - 72) || v133 != *(_QWORD *)(v10 + v139 - 80))
                      goto LABEL_295;
                    v149 = *(float *)(v10 + v139 - 28);
                    if (result.n128_f32[0] >= v149
                      && (result.n128_f32[0] != v149 || v134 <= *(_DWORD *)(v10 + v139 - 32)))
                    {
                      goto LABEL_259;
                    }
                  }
                  v123 = (unint64_t *)(v124 - 5);
                  v124 -= 6;
                  *(_DWORD *)v147 = *(_DWORD *)(v147 - 96);
                  v145 = *(_OWORD *)(v10 + v139 - 32);
                  *(_OWORD *)(v147 + 48) = *(_OWORD *)(v10 + v139 - 48);
                  *(_OWORD *)(v147 + 64) = v145;
                  *(_OWORD *)(v147 + 80) = *(_OWORD *)(v10 + v139 - 16);
                  v146 = *(_OWORD *)(v10 + v139 - 64);
                  *(_OWORD *)(v147 + 16) = *(_OWORD *)(v10 + v139 - 80);
                  *(_OWORD *)(v147 + 32) = v146;
                  v139 -= 96;
                  if (!v139)
                    goto LABEL_257;
                }
              }
              while (1)
              {
                v142 = v10 + v139;
                v143 = *(float *)(v10 + v139 - 20);
                if (v136 >= v143)
                {
                  if (v136 != v143)
                    goto LABEL_259;
                  v144 = *(float *)(v10 + v139 - 28);
                  if (result.n128_f32[0] >= v144)
                  {
                    if (result.n128_f32[0] != v144)
                    {
LABEL_295:
                      v124 = (_OWORD *)(v10 + v139);
                      v123 = (unint64_t *)(v10 + v139 + 16);
LABEL_259:
                      *(_DWORD *)v124 = v131;
                      *v123 = v133;
                      v123[1] = v132;
                      v124[2] = v286;
                      v124[3] = v294;
                      *((_DWORD *)v124 + 16) = v134;
                      *((_DWORD *)v124 + 17) = result.n128_u32[0];
                      *((_DWORD *)v124 + 18) = v135;
                      *((float *)v124 + 19) = v136;
                      *((_BYTE *)v124 + 84) = v319;
                      *((_DWORD *)v124 + 20) = v316;
                      *((_BYTE *)v124 + 85) = v125;
                      *(_QWORD *)((char *)v124 + 86) = v324;
                      *((_WORD *)v124 + 47) = v328;
LABEL_260:
                      v118 = v122 + 24;
                      v121 += 96;
                      if (v122 + 24 == a2)
                        return result;
                      goto LABEL_261;
                    }
                    if (v134 <= *(_DWORD *)(v10 + v139 - 32))
                      goto LABEL_259;
                  }
                }
                v123 = (unint64_t *)(v124 - 5);
                v124 -= 6;
                *(_DWORD *)v142 = *(_DWORD *)(v142 - 96);
                v140 = *(_OWORD *)(v142 - 32);
                *(_OWORD *)(v142 + 48) = *(_OWORD *)(v142 - 48);
                *(_OWORD *)(v142 + 64) = v140;
                *(_OWORD *)(v142 + 80) = *(_OWORD *)(v142 - 16);
                v141 = *(_OWORD *)(v142 - 64);
                *(_OWORD *)(v142 + 16) = *(_OWORD *)(v142 - 80);
                *(_OWORD *)(v142 + 32) = v141;
                v139 -= 96;
                if (!v139)
                {
LABEL_257:
                  v123 = (unint64_t *)(v10 + v139 + 16);
                  goto LABEL_258;
                }
              }
            }
            if (v120)
              return result;
            for (i = (_OWORD *)(v10 + 112); ; i += 6)
            {
              v252 = a1;
              a1 = v118;
              v253 = *((_BYTE *)v252 + 181);
              if (v253)
                break;
              v256 = *((_QWORD *)v252 + 14);
              v255 = *((_QWORD *)v252 + 15);
              if (__PAIR128__(v255, v256) < *((_OWORD *)v252 + 1))
                goto LABEL_434;
              if (v255 == *((_QWORD *)v252 + 3) && v256 == *((_QWORD *)v252 + 2))
                goto LABEL_431;
LABEL_420:
              v118 = a1 + 24;
              if (a1 + 24 == a2)
                return result;
            }
            result.n128_u32[0] = v252[43];
            v254 = *((float *)v252 + 19);
            if (result.n128_f32[0] < v254)
              goto LABEL_434;
            if (result.n128_f32[0] != v254)
              goto LABEL_420;
LABEL_431:
            result.n128_u32[0] = v252[41];
            v258 = *((float *)v252 + 17);
            if (result.n128_f32[0] < v258 || result.n128_f32[0] == v258 && v252[40] > v252[16])
            {
LABEL_434:
              v259 = *a1;
              v261 = *((_QWORD *)v252 + 14);
              v260 = *((_QWORD *)v252 + 15);
              result = *((__n128 *)v252 + 8);
              v288 = result;
              v296 = *((_OWORD *)v252 + 9);
              v262 = v252[40];
              result.n128_u32[0] = v252[41];
              v263 = v252[42];
              v318 = v252[44];
              v320 = *((_BYTE *)v252 + 180);
              v327 = *(_QWORD *)((char *)v252 + 182);
              v329 = *((_WORD *)v252 + 95);
              v264 = i;
              v265 = *((float *)v252 + 43);
              if (*((_BYTE *)v252 + 181))
              {
                while (1)
                {
                  *((_DWORD *)v264 - 4) = *((_DWORD *)v264 - 28);
                  v270 = *(v264 - 3);
                  v264[2] = *(v264 - 4);
                  v264[3] = v270;
                  v264[4] = *(v264 - 2);
                  v271 = *(v264 - 5);
                  v272 = *((float *)v264 - 33);
                  *v264 = *(v264 - 6);
                  v264[1] = v271;
                  if (v265 >= v272)
                  {
                    if (v265 != v272)
                      break;
                    v273 = *((float *)v264 - 35);
                    if (result.n128_f32[0] >= v273 && (result.n128_f32[0] != v273 || v262 <= *((_DWORD *)v264 - 36)))
                      break;
                  }
                  v264 -= 6;
                }
                v250 = (unint64_t *)(v264 - 6);
                v251 = (int *)(v264 - 7);
              }
              else
              {
                do
                {
                  do
                  {
                    v251 = v252;
                    v252[24] = *v252;
                    v266 = *((_OWORD *)v252 + 4);
                    *((_OWORD *)v252 + 9) = *((_OWORD *)v252 + 3);
                    *((_OWORD *)v252 + 10) = v266;
                    *((_OWORD *)v252 + 11) = *((_OWORD *)v252 + 5);
                    v267 = *((_OWORD *)v252 + 2);
                    *((_OWORD *)v252 + 7) = *((_OWORD *)v252 + 1);
                    *((_OWORD *)v252 + 8) = v267;
                    v252 -= 24;
                  }
                  while (__PAIR128__(v260, v261) < *((_OWORD *)v251 - 5));
                  if (v260 != *((_QWORD *)v251 - 9) || v261 != *((_QWORD *)v251 - 10))
                    break;
                  v269 = *((float *)v251 - 7);
                }
                while (result.n128_f32[0] < v269 || result.n128_f32[0] == v269 && v262 > *(v251 - 8));
                v250 = (unint64_t *)(v251 + 4);
              }
              *v251 = v259;
              *v250 = v261;
              v250[1] = v260;
              *((__n128 *)v251 + 2) = v288;
              *((_OWORD *)v251 + 3) = v296;
              v251[16] = v262;
              v251[17] = result.n128_u32[0];
              v251[18] = v263;
              *((float *)v251 + 19) = v265;
              *((_BYTE *)v251 + 84) = v320;
              v251[20] = v318;
              *((_BYTE *)v251 + 85) = v253;
              *(_QWORD *)((char *)v251 + 86) = v327;
              *((_WORD *)v251 + 47) = v329;
              goto LABEL_420;
            }
            goto LABEL_420;
          }
          if (!a3)
          {
            if ((int *)v10 == a2)
              return result;
            v150 = (v12 - 2) >> 1;
            v151 = v150;
LABEL_301:
            v153 = v151;
            if (v150 < v151)
              goto LABEL_300;
            v154 = (2 * v151) | 1;
            v152 = v10 + 96 * v154;
            if (2 * v153 + 2 >= (uint64_t)v12)
              goto LABEL_317;
            if (*(_BYTE *)(v10 + 96 * v154 + 85))
            {
              v155 = *(float *)(v10 + 96 * v154 + 76);
              v156 = *(float *)(v152 + 172);
              if (v155 >= v156)
              {
                if (v155 != v156)
                  goto LABEL_317;
LABEL_313:
                v160 = *(float *)(v10 + 96 * v154 + 68);
                v161 = *(float *)(v152 + 164);
                if (v160 < v161 || v160 == v161 && *(_DWORD *)(v10 + 96 * v154 + 64) > *(_DWORD *)(v152 + 160))
                  goto LABEL_316;
LABEL_317:
                if (*(_BYTE *)(v152 + 85))
                {
                  v162 = *(float *)(v152 + 76);
                  v163 = *(float *)(v10 + 96 * v153 + 76);
                  if (v162 < v163)
                    goto LABEL_300;
                  if (v162 != v163)
                  {
LABEL_330:
                    v169 = (int *)(v10 + 96 * v153);
                    v170 = *v169;
                    v171 = *((_QWORD *)v169 + 2);
                    v172 = *((_QWORD *)v169 + 3);
                    v287 = *((_OWORD *)v169 + 2);
                    v295 = *((_OWORD *)v169 + 3);
                    v173 = v169[16];
                    v174 = *((float *)v169 + 17);
                    v175 = v169[18];
                    v176 = *((float *)v169 + 19);
                    v325 = *((_OWORD *)v169 + 5);
                    *v169 = *(_DWORD *)v152;
                    *((_OWORD *)v169 + 1) = *(_OWORD *)(v152 + 16);
                    v177 = *(_OWORD *)(v152 + 32);
                    v178 = *(_OWORD *)(v152 + 48);
                    v179 = *(_OWORD *)(v152 + 80);
                    *((_OWORD *)v169 + 4) = *(_OWORD *)(v152 + 64);
                    *((_OWORD *)v169 + 5) = v179;
                    *((_OWORD *)v169 + 2) = v177;
                    *((_OWORD *)v169 + 3) = v178;
                    while (1)
                    {
                      if (v150 < v154)
                        goto LABEL_299;
                      v183 = v152;
                      v184 = 2 * v154;
                      v154 = (2 * v154) | 1;
                      v152 = v10 + 96 * v154;
                      v185 = v184 + 2;
                      if (v185 >= (uint64_t)v12)
                        goto LABEL_348;
                      if (*(_BYTE *)(v10 + 96 * v154 + 85))
                        break;
                      v189 = *(_QWORD *)(v10 + 96 * v154 + 16);
                      v188 = *(_QWORD *)(v10 + 96 * v154 + 24);
                      if (__PAIR128__(v188, v189) < *(_OWORD *)(v152 + 112))
                        goto LABEL_347;
                      if (v188 == *(_QWORD *)(v152 + 120) && v189 == *(_QWORD *)(v152 + 112))
                        goto LABEL_344;
LABEL_348:
                      if (*(_BYTE *)(v152 + 85))
                      {
                        v193 = *(float *)(v152 + 76);
                        if (v193 < v176)
                          goto LABEL_298;
                        if (v193 != v176)
                          goto LABEL_331;
                      }
                      else
                      {
                        if (*(_OWORD *)(v152 + 16) < __PAIR128__(v172, v171))
                          goto LABEL_298;
                        if (*(_QWORD *)(v152 + 24) != v172 || *(_QWORD *)(v152 + 16) != v171)
                          goto LABEL_331;
                      }
                      v195 = *(float *)(v152 + 68);
                      if (v195 < v174 || v195 == v174 && *(_DWORD *)(v152 + 64) > v173)
                      {
LABEL_298:
                        v152 = v183;
LABEL_299:
                        *(_DWORD *)v152 = v170;
                        *(_QWORD *)(v152 + 16) = v171;
                        *(_QWORD *)(v152 + 24) = v172;
                        *(_OWORD *)(v152 + 32) = v287;
                        *(_OWORD *)(v152 + 48) = v295;
                        *(_DWORD *)(v152 + 64) = v173;
                        *(float *)(v152 + 68) = v174;
                        *(_DWORD *)(v152 + 72) = v175;
                        *(float *)(v152 + 76) = v176;
                        *(_OWORD *)(v152 + 80) = v325;
LABEL_300:
                        v151 = v153 - 1;
                        if (v153)
                          goto LABEL_301;
                        v196 = v11 / 0x60uLL;
                        while (2)
                        {
                          v198 = 0;
                          v199 = *(_DWORD *)v10;
                          v290 = *(_OWORD *)(v10 + 16);
                          v308 = *(_OWORD *)(v10 + 64);
                          v313 = *(_OWORD *)(v10 + 80);
                          v298 = *(__n128 *)(v10 + 32);
                          v303 = *(_OWORD *)(v10 + 48);
                          v200 = v10;
LABEL_368:
                          v204 = v200;
                          v205 = v198 + 1;
                          v200 += 96 * (v198 + 1);
                          v206 = 2 * v198;
                          v198 = (2 * v198) | 1;
                          v207 = v206 + 2;
                          if (v207 >= v196)
                            goto LABEL_367;
                          if (*(_BYTE *)(v204 + 96 * v205 + 85))
                          {
                            v208 = *(float *)(v204 + 96 * v205 + 76);
                            v209 = *(float *)(v200 + 172);
                            if (v208 >= v209)
                            {
                              if (v208 != v209)
                                goto LABEL_367;
LABEL_379:
                              v213 = *(float *)(v204 + 96 * v205 + 68);
                              v214 = *(float *)(v200 + 164);
                              if (v213 >= v214
                                && (v213 != v214 || *(_DWORD *)(v204 + 96 * v205 + 64) <= *(_DWORD *)(v200 + 160)))
                              {
LABEL_367:
                                *(_DWORD *)v204 = *(_DWORD *)v200;
                                *(_OWORD *)(v204 + 16) = *(_OWORD *)(v200 + 16);
                                v201 = *(_OWORD *)(v200 + 32);
                                v202 = *(_OWORD *)(v200 + 48);
                                v203 = *(_OWORD *)(v200 + 80);
                                *(_OWORD *)(v204 + 64) = *(_OWORD *)(v200 + 64);
                                *(_OWORD *)(v204 + 80) = v203;
                                *(_OWORD *)(v204 + 32) = v201;
                                *(_OWORD *)(v204 + 48) = v202;
                                if (v198 > (uint64_t)((unint64_t)(v196 - 2) >> 1))
                                {
                                  v215 = (_OWORD *)(v200 + 16);
                                  if ((int *)v200 == a2 - 24)
                                  {
                                    *(_DWORD *)v200 = v199;
                                    *v215 = v290;
                                    result = v298;
                                    *(_OWORD *)(v200 + 64) = v308;
                                    *(_OWORD *)(v200 + 80) = v313;
                                    *(__n128 *)(v200 + 32) = v298;
                                    *(_OWORD *)(v200 + 48) = v303;
                                    goto LABEL_364;
                                  }
                                  *(_DWORD *)v200 = *(a2 - 24);
                                  *v215 = *((_OWORD *)a2 - 5);
                                  v216 = *((_OWORD *)a2 - 4);
                                  v217 = *((_OWORD *)a2 - 3);
                                  v218 = *((_OWORD *)a2 - 1);
                                  *(_OWORD *)(v200 + 64) = *((_OWORD *)a2 - 2);
                                  *(_OWORD *)(v200 + 80) = v218;
                                  *(_OWORD *)(v200 + 32) = v216;
                                  *(_OWORD *)(v200 + 48) = v217;
                                  *(a2 - 24) = v199;
                                  *((_OWORD *)a2 - 5) = v290;
                                  result = v298;
                                  *((_OWORD *)a2 - 2) = v308;
                                  *((_OWORD *)a2 - 1) = v313;
                                  *((__n128 *)a2 - 4) = v298;
                                  *((_OWORD *)a2 - 3) = v303;
                                  v219 = v200 - v10 + 96;
                                  if (v219 >= 97)
                                  {
                                    v220 = v219 / 0x60uLL - 2;
                                    v221 = v220 >> 1;
                                    v222 = (_OWORD *)(v10 + 96 * (v220 >> 1));
                                    if (*((_BYTE *)v222 + 85))
                                    {
                                      result.n128_u32[0] = *(_DWORD *)(v10 + 96 * v221 + 76);
                                      v223 = *(float *)(v200 + 76);
                                      if (result.n128_f32[0] < v223)
                                        goto LABEL_398;
                                      if (result.n128_f32[0] != v223)
                                        goto LABEL_364;
LABEL_395:
                                      result.n128_u32[0] = *(_DWORD *)(v10 + 96 * v221 + 68);
                                      v227 = *(float *)(v200 + 68);
                                      if (result.n128_f32[0] < v227
                                        || result.n128_f32[0] == v227
                                        && *(_DWORD *)(v10 + 96 * v221 + 64) > *(_DWORD *)(v200 + 64))
                                      {
LABEL_398:
                                        v228 = *(_DWORD *)v200;
                                        v229 = *(_QWORD *)(v200 + 16);
                                        v230 = *(_QWORD *)(v200 + 24);
                                        v326 = *(_OWORD *)(v200 + 32);
                                        v332 = *(_OWORD *)(v200 + 48);
                                        v231 = *(_DWORD *)(v200 + 64);
                                        v232 = *(float *)(v200 + 68);
                                        v233 = *(_DWORD *)(v200 + 72);
                                        v234 = *(float *)(v200 + 76);
                                        v317 = *(_OWORD *)(v200 + 80);
                                        *(_DWORD *)v200 = *(_DWORD *)v222;
                                        v235 = (_OWORD *)(v10 + 96 * v221);
                                        v236 = (unint64_t *)(v235 + 1);
                                        *v215 = v235[1];
                                        v237 = v235[2];
                                        v238 = v235[3];
                                        v239 = v235[5];
                                        v215[3] = v235[4];
                                        v215[4] = v239;
                                        v215[1] = v237;
                                        v215[2] = v238;
                                        if (v220 < 2)
                                        {
LABEL_399:
                                          v240 = v222;
LABEL_400:
                                          *(_DWORD *)v240 = v228;
                                          *v236 = v229;
                                          v236[1] = v230;
                                          v240[2] = v326;
                                          v240[3] = v332;
                                          *((_DWORD *)v240 + 16) = v231;
                                          *((float *)v240 + 17) = v232;
                                          *((_DWORD *)v240 + 18) = v233;
                                          *((float *)v240 + 19) = v234;
                                          result.n128_u64[0] = v317;
                                          v240[5] = v317;
                                          goto LABEL_364;
                                        }
                                        while (2)
                                        {
                                          v245 = v221 - 1;
                                          v221 = (v221 - 1) >> 1;
                                          v240 = (_OWORD *)(v10 + 96 * v221);
                                          if (*((_BYTE *)v240 + 85))
                                          {
                                            v246 = *(float *)(v10 + 96 * v221 + 76);
                                            if (v246 >= v234)
                                            {
                                              if (v246 != v234)
                                                goto LABEL_399;
                                              goto LABEL_412;
                                            }
                                          }
                                          else if (*(_OWORD *)(v10 + 96 * v221 + 16) >= __PAIR128__(v230, v229))
                                          {
                                            if (*(_QWORD *)(v10 + 96 * v221 + 24) != v230
                                              || *(_QWORD *)(v10 + 96 * v221 + 16) != v229)
                                            {
                                              goto LABEL_399;
                                            }
LABEL_412:
                                            v248 = *(float *)(v10 + 96 * v221 + 68);
                                            if (v248 >= v232
                                              && (v248 != v232 || *(_DWORD *)(v10 + 96 * v221 + 64) <= v231))
                                            {
                                              goto LABEL_399;
                                            }
                                          }
                                          *(_DWORD *)v222 = *(_DWORD *)v240;
                                          v241 = (_OWORD *)(v10 + 96 * v221);
                                          v236 = (unint64_t *)(v241 + 1);
                                          v222[1] = v241[1];
                                          v242 = v241[2];
                                          v243 = v241[3];
                                          v244 = v241[5];
                                          v222[4] = v241[4];
                                          v222[5] = v244;
                                          v222[2] = v242;
                                          v222[3] = v243;
                                          v222 = v241;
                                          if (v245 <= 1)
                                            goto LABEL_400;
                                          continue;
                                        }
                                      }
                                    }
                                    else
                                    {
                                      v224 = *(_QWORD *)(v10 + 96 * v221 + 16);
                                      v225 = *(_QWORD *)(v10 + 96 * v221 + 24);
                                      if (__PAIR128__(v225, v224) < *v215)
                                        goto LABEL_398;
                                      if (v225 == *(_QWORD *)(v200 + 24) && v224 == *(_QWORD *)v215)
                                        goto LABEL_395;
                                    }
                                  }
LABEL_364:
                                  a2 -= 24;
                                  if (v196-- <= 2)
                                    return result;
                                  continue;
                                }
                                goto LABEL_368;
                              }
                            }
                          }
                          else
                          {
                            v211 = *(_QWORD *)(v204 + 96 * v205 + 16);
                            v210 = *(_QWORD *)(v204 + 96 * v205 + 24);
                            if (__PAIR128__(v210, v211) >= *(_OWORD *)(v200 + 112))
                            {
                              if (v210 == *(_QWORD *)(v200 + 120) && v211 == *(_QWORD *)(v200 + 112))
                                goto LABEL_379;
                              goto LABEL_367;
                            }
                          }
                          break;
                        }
                        v200 += 96;
                        v198 = v207;
                        goto LABEL_367;
                      }
LABEL_331:
                      *(_DWORD *)v183 = *(_DWORD *)v152;
                      *(_OWORD *)(v183 + 16) = *(_OWORD *)(v152 + 16);
                      v180 = *(_OWORD *)(v152 + 32);
                      v181 = *(_OWORD *)(v152 + 48);
                      v182 = *(_OWORD *)(v152 + 80);
                      *(_OWORD *)(v183 + 64) = *(_OWORD *)(v152 + 64);
                      *(_OWORD *)(v183 + 80) = v182;
                      *(_OWORD *)(v183 + 32) = v180;
                      *(_OWORD *)(v183 + 48) = v181;
                    }
                    v186 = *(float *)(v10 + 96 * v154 + 76);
                    v187 = *(float *)(v152 + 172);
                    if (v186 < v187)
                      goto LABEL_347;
                    if (v186 != v187)
                      goto LABEL_348;
LABEL_344:
                    v191 = *(float *)(v10 + 96 * v154 + 68);
                    v192 = *(float *)(v152 + 164);
                    if (v191 < v192 || v191 == v192 && *(_DWORD *)(v10 + 96 * v154 + 64) > *(_DWORD *)(v152 + 160))
                    {
LABEL_347:
                      v152 += 96;
                      v154 = v185;
                      goto LABEL_348;
                    }
                    goto LABEL_348;
                  }
                }
                else
                {
                  v165 = *(_QWORD *)(v152 + 16);
                  v164 = *(_QWORD *)(v152 + 24);
                  if (__PAIR128__(v164, v165) < *(_OWORD *)(v10 + 96 * v153 + 16))
                    goto LABEL_300;
                  if (v164 != *(_QWORD *)(v10 + 96 * v153 + 24) || v165 != *(_QWORD *)(v10 + 96 * v153 + 16))
                    goto LABEL_330;
                }
                v167 = *(float *)(v152 + 68);
                v168 = *(float *)(v10 + 96 * v153 + 68);
                if (v167 < v168 || v167 == v168 && *(_DWORD *)(v152 + 64) > *(_DWORD *)(v10 + 96 * v153 + 64))
                  goto LABEL_300;
                goto LABEL_330;
              }
            }
            else
            {
              v158 = *(_QWORD *)(v10 + 96 * v154 + 16);
              v157 = *(_QWORD *)(v10 + 96 * v154 + 24);
              if (__PAIR128__(v157, v158) >= *(_OWORD *)(v152 + 112))
              {
                if (v157 != *(_QWORD *)(v152 + 120) || v158 != *(_QWORD *)(v152 + 112))
                  goto LABEL_317;
                goto LABEL_313;
              }
            }
LABEL_316:
            v152 += 96;
            v154 = 2 * v153 + 2;
            goto LABEL_317;
          }
          v13 = v12 >> 1;
          v14 = (__n128 *)(v10 + 96 * (v12 >> 1));
          if ((unint64_t)v11 <= 0x3000)
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,SIWordTrieFragmentGetBundleIDs::$_0 &,std::pair<unsigned int,ci_rankingbits_wrapped_s> *>((__n128 *)&a1[24 * (v12 >> 1)], (__n128 *)a1, (__n128 *)a2 - 6, result);
            --a3;
            if ((a4 & 1) != 0)
              goto LABEL_22;
          }
          else
          {
            v15 = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,SIWordTrieFragmentGetBundleIDs::$_0 &,std::pair<unsigned int,ci_rankingbits_wrapped_s> *>((__n128 *)a1, (__n128 *)&a1[24 * (v12 >> 1)], (__n128 *)a2 - 6, result);
            v16 = (__n128 *)&a1[24 * v13];
            v17 = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,SIWordTrieFragmentGetBundleIDs::$_0 &,std::pair<unsigned int,ci_rankingbits_wrapped_s> *>((__n128 *)a1 + 6, v16 - 6, (__n128 *)a2 - 12, v15);
            v18 = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,SIWordTrieFragmentGetBundleIDs::$_0 &,std::pair<unsigned int,ci_rankingbits_wrapped_s> *>((__n128 *)a1 + 12, (__n128 *)&a1[24 * v13 + 24], (__n128 *)a2 - 18, v17);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,SIWordTrieFragmentGetBundleIDs::$_0 &,std::pair<unsigned int,ci_rankingbits_wrapped_s> *>(v16 - 6, v14, (__n128 *)&a1[24 * v13 + 24], v18);
            v19 = *a1;
            *a1 = v14->n128_u32[0];
            v14->n128_u32[0] = v19;
            v304 = *((__n128 *)a1 + 4);
            v309 = *((__n128 *)a1 + 5);
            v291 = *((__n128 *)a1 + 2);
            v299 = *((__n128 *)a1 + 3);
            v283 = *((__n128 *)a1 + 1);
            *((__n128 *)a1 + 1) = v16[1];
            v20 = v16[3];
            v22 = v16[4];
            v21 = v16[5];
            *((__n128 *)a1 + 2) = v16[2];
            *((__n128 *)a1 + 3) = v20;
            *((__n128 *)a1 + 4) = v22;
            *((__n128 *)a1 + 5) = v21;
            v16[1] = v283;
            v16[4] = v304;
            v16[5] = v309;
            v16[2] = v291;
            v16[3] = v299;
            --a3;
            if ((a4 & 1) != 0)
              goto LABEL_22;
          }
          if (*((_BYTE *)a1 - 11))
          {
            v23 = *((float *)a1 - 5);
            v24 = *((float *)a1 + 19);
            if (v23 < v24)
              goto LABEL_22;
            if (v23 == v24)
              goto LABEL_19;
LABEL_108:
            v70 = *a1;
            v71 = *((_QWORD *)a1 + 2);
            v72 = *((_QWORD *)a1 + 3);
            result = *((__n128 *)a1 + 2);
            v323 = result;
            v331 = *((_OWORD *)a1 + 3);
            v73 = a1[16];
            result.n128_u32[0] = a1[17];
            v74 = a1[18];
            v75 = *((float *)a1 + 19);
            v281 = a1[20];
            v282 = *((_BYTE *)a1 + 84);
            v76 = *((unsigned __int8 *)a1 + 85);
            v321 = *((_WORD *)a1 + 47);
            v315 = *(_QWORD *)((char *)a1 + 86);
            if (*((_BYTE *)a1 + 85))
            {
              v77 = *((float *)a2 - 5);
              if (v75 < v77
                || v75 == v77
                && ((v78 = *((float *)a2 - 7), result.n128_f32[0] < v78) || result.n128_f32[0] == v78 && v73 > *(a2 - 8)))
              {
                v79 = (unint64_t)(a1 + 24);
                v80 = *((float *)a1 + 43);
                if (v75 < v80)
                {
                  j = a2;
                  if (v79 >= (unint64_t)a2)
                    goto LABEL_180;
LABEL_171:
                  for (j = a2 - 24; ; j -= 24)
                  {
                    v95 = *((float *)j + 19);
                    if (v75 >= v95)
                    {
                      if (v75 != v95)
                        break;
                      v96 = *((float *)j + 17);
                      if (result.n128_f32[0] >= v96 && (result.n128_f32[0] != v96 || v73 <= j[16]))
                        break;
                    }
                  }
                  goto LABEL_180;
                }
                v84 = a1 + 40;
                do
                {
                  if (v75 == v80)
                  {
                    v85 = *((float *)v84 + 1);
                    if (result.n128_f32[0] < v85)
                      goto LABEL_169;
                    if (result.n128_f32[0] == v85 && v73 > *v84)
                      break;
                  }
                  v79 += 96;
                  v80 = *((float *)v84 + 27);
                  v84 += 24;
                }
                while (v75 >= v80);
LABEL_168:
                v79 = (unint64_t)(v84 - 16);
                goto LABEL_169;
              }
            }
            else if (__PAIR128__(v72, v71) < *(_OWORD *)v280
                   || (v72 == *((_QWORD *)a2 - 9) ? (v86 = v71 == *(_QWORD *)v280) : (v86 = 0),
                       v86
                    && ((v87 = *((float *)a2 - 7), result.n128_f32[0] < v87)
                     || result.n128_f32[0] == v87 && v73 > *(a2 - 8))))
            {
              v79 = (unint64_t)(a1 + 24);
              v82 = *((_QWORD *)a1 + 14);
              v83 = *((_QWORD *)a1 + 15);
              if (__PAIR128__(v72, v71) < *((_OWORD *)a1 + 7))
              {
                j = a2;
                if (v79 >= (unint64_t)a2)
                  goto LABEL_180;
                goto LABEL_226;
              }
              v84 = a1 + 40;
              while (1)
              {
                if (v72 == v83 && v71 == v82)
                {
                  v94 = *((float *)v84 + 1);
                  if (result.n128_f32[0] < v94)
                    goto LABEL_169;
                  if (result.n128_f32[0] == v94 && v73 > *v84)
                    goto LABEL_168;
                }
                v79 += 96;
                v82 = *((_QWORD *)v84 + 6);
                v83 = *((_QWORD *)v84 + 7);
                v92 = __PAIR128__(v72, v71) >= *((_OWORD *)v84 + 3);
                v84 += 24;
                if (!v92)
                  goto LABEL_168;
              }
            }
            v79 = (unint64_t)(a1 + 24);
            if (a1 + 24 < a2)
            {
              if (*((_BYTE *)a1 + 85))
              {
                do
                {
                  v88 = *(float *)(v79 + 76);
                  if (v75 < v88)
                    break;
                  if (v75 == v88)
                  {
                    v89 = *(float *)(v79 + 68);
                    if (result.n128_f32[0] < v89 || result.n128_f32[0] == v89 && v73 > *(_DWORD *)(v79 + 64))
                      break;
                  }
                  v79 += 96;
                }
                while (v79 < (unint64_t)a2);
              }
              else
              {
                do
                {
                  if (__PAIR128__(v72, v71) < *(_OWORD *)(v79 + 16))
                    break;
                  if (v72 == *(_QWORD *)(v79 + 24) && v71 == *(_QWORD *)(v79 + 16))
                  {
                    v91 = *(float *)(v79 + 68);
                    if (result.n128_f32[0] < v91 || result.n128_f32[0] == v91 && v73 > *(_DWORD *)(v79 + 64))
                      break;
                  }
                  v79 += 96;
                }
                while (v79 < (unint64_t)a2);
              }
            }
LABEL_169:
            if (v79 >= (unint64_t)a2)
            {
              j = a2;
              goto LABEL_180;
            }
            if (*((_BYTE *)a1 + 85))
              goto LABEL_171;
LABEL_226:
            for (j = a2 - 24; ; j -= 24)
            {
              if (__PAIR128__(v72, v71) >= *((_OWORD *)j + 1))
              {
                if (v72 != *((_QWORD *)j + 3) || v71 != *((_QWORD *)j + 2))
                  break;
                v116 = *((float *)j + 17);
                if (result.n128_f32[0] >= v116 && (result.n128_f32[0] != v116 || v73 <= j[16]))
                  break;
              }
            }
LABEL_180:
            if (v79 < (unint64_t)j)
            {
              while (1)
              {
                v100 = *(_DWORD *)v79;
                *(_DWORD *)v79 = *j;
                *j = v100;
                v306 = *(_OWORD *)(v79 + 64);
                v311 = *(_OWORD *)(v79 + 80);
                v293 = *(_OWORD *)(v79 + 32);
                v301 = *(_OWORD *)(v79 + 48);
                v285 = *(_OWORD *)(v79 + 16);
                *(_OWORD *)(v79 + 16) = *((_OWORD *)j + 1);
                v101 = *((_OWORD *)j + 3);
                v103 = *((_OWORD *)j + 4);
                v102 = *((_OWORD *)j + 5);
                *(_OWORD *)(v79 + 32) = *((_OWORD *)j + 2);
                *(_OWORD *)(v79 + 48) = v101;
                *(_OWORD *)(v79 + 64) = v103;
                *(_OWORD *)(v79 + 80) = v102;
                *((_OWORD *)j + 3) = v301;
                *((_OWORD *)j + 4) = v306;
                *((_OWORD *)j + 5) = v311;
                *((_OWORD *)j + 1) = v285;
                *((_OWORD *)j + 2) = v293;
                v10 = v79 + 96;
                if (!v76)
                  break;
                v104 = *(float *)(v79 + 172);
                if (v75 >= v104)
                {
                  v105 = v79 + 160;
                  while (1)
                  {
                    if (v75 == v104)
                    {
                      v106 = *(float *)(v105 + 4);
                      if (result.n128_f32[0] < v106)
                        goto LABEL_208;
                      if (result.n128_f32[0] == v106 && v73 > *(_DWORD *)v105)
                        break;
                    }
                    v10 += 96;
                    v104 = *(float *)(v105 + 108);
                    v105 += 96;
                    if (v75 < v104)
                      goto LABEL_208;
                  }
LABEL_209:
                  if (!v76)
                    goto LABEL_216;
                }
                do
                {
                  do
                  {
                    j -= 24;
                    v111 = *((float *)j + 19);
                  }
                  while (v75 < v111);
                  if (v75 != v111)
                    break;
                  v112 = *((float *)j + 17);
                }
                while (result.n128_f32[0] < v112 || result.n128_f32[0] == v112 && v73 > j[16]);
LABEL_185:
                v79 = v10;
                if (v10 >= (unint64_t)j)
                  goto LABEL_182;
              }
              v107 = *(_QWORD *)(v79 + 112);
              v108 = *(_QWORD *)(v79 + 120);
              if (__PAIR128__(v72, v71) >= *(_OWORD *)(v79 + 112))
              {
                v105 = v79 + 160;
                while (1)
                {
                  if (v72 == v108 && v71 == v107)
                  {
                    v110 = *(float *)(v105 + 4);
                    if (result.n128_f32[0] < v110)
                    {
LABEL_208:
                      v10 = v105 - 64;
                      goto LABEL_209;
                    }
                    if (result.n128_f32[0] == v110 && v73 > *(_DWORD *)v105)
                      goto LABEL_209;
                  }
                  v10 += 96;
                  v107 = *(_QWORD *)(v105 + 48);
                  v108 = *(_QWORD *)(v105 + 56);
                  v92 = __PAIR128__(v72, v71) >= *(_OWORD *)(v105 + 48);
                  v105 += 96;
                  if (!v92)
                    goto LABEL_208;
                }
              }
              do
              {
                do
LABEL_216:
                  j -= 24;
                while (__PAIR128__(v72, v71) < *((_OWORD *)j + 1));
                if (v72 != *((_QWORD *)j + 3) || v71 != *((_QWORD *)j + 2))
                  break;
                v114 = *((float *)j + 17);
              }
              while (result.n128_f32[0] < v114 || result.n128_f32[0] == v114 && v73 > j[16]);
              goto LABEL_185;
            }
            v10 = v79;
LABEL_182:
            if ((int *)(v10 - 96) != a1)
            {
              *a1 = *(_DWORD *)(v10 - 96);
              *((_OWORD *)a1 + 1) = *(_OWORD *)(v10 - 80);
              v97 = *(_OWORD *)(v10 - 64);
              v98 = *(_OWORD *)(v10 - 48);
              v99 = *(_OWORD *)(v10 - 16);
              *((_OWORD *)a1 + 4) = *(_OWORD *)(v10 - 32);
              *((_OWORD *)a1 + 5) = v99;
              *((_OWORD *)a1 + 2) = v97;
              *((_OWORD *)a1 + 3) = v98;
            }
            a4 = 0;
            *(_DWORD *)(v10 - 96) = v70;
            *(_QWORD *)(v10 - 80) = v71;
            *(_QWORD *)(v10 - 72) = v72;
            *(__n128 *)(v10 - 64) = v323;
            *(_OWORD *)(v10 - 48) = v331;
            *(_DWORD *)(v10 - 32) = v73;
            *(_DWORD *)(v10 - 28) = result.n128_u32[0];
            *(_DWORD *)(v10 - 24) = v74;
            *(float *)(v10 - 20) = v75;
            *(_DWORD *)(v10 - 16) = v281;
            *(_BYTE *)(v10 - 12) = v282;
            *(_BYTE *)(v10 - 11) = v76;
            *(_QWORD *)(v10 - 10) = v315;
            *(_WORD *)(v10 - 2) = v321;
            continue;
          }
          v26 = *((_QWORD *)a1 - 10);
          v25 = *((_QWORD *)a1 - 9);
          if (__PAIR128__(v25, v26) < *((_OWORD *)a1 + 1))
            goto LABEL_22;
          if (v25 != *((_QWORD *)a1 + 3) || v26 != *((_QWORD *)a1 + 2))
            goto LABEL_108;
LABEL_19:
          v28 = *((float *)a1 - 7);
          v29 = *((float *)a1 + 17);
          if (v28 >= v29 && (v28 != v29 || *(a1 - 8) <= a1[16]))
            goto LABEL_108;
LABEL_22:
          v30 = 0;
          v31 = *((_QWORD *)a1 + 2);
          v32 = *a1;
          v33 = *((_QWORD *)a1 + 3);
          v322 = *((_OWORD *)a1 + 2);
          v330 = *((_OWORD *)a1 + 3);
          v34 = a1[16];
          v35 = *((float *)a1 + 17);
          v36 = a1[18];
          v37 = *((float *)a1 + 19);
          v314 = *((__n128 *)a1 + 5);
          while (2)
          {
            v38 = &a1[v30];
            if (BYTE1(a1[v30 + 45]))
            {
              v39 = *((float *)v38 + 43);
              if (v39 >= v37)
              {
                if (v39 != v37)
                  goto LABEL_38;
                goto LABEL_34;
              }
LABEL_23:
              v30 += 24;
              continue;
            }
            break;
          }
          v42 = v38 + 28;
          v40 = *((_QWORD *)v38 + 14);
          v41 = *((_QWORD *)v42 + 1);
          if (__PAIR128__(v41, v40) < __PAIR128__(v33, v31))
            goto LABEL_23;
          if (v41 == v33 && v40 == v31)
          {
LABEL_34:
            v44 = *(float *)&a1[v30 + 41];
            if (v44 >= v35)
            {
              if (v44 != v35)
                goto LABEL_38;
              v45 = &a1[v30];
              if (a1[v30 + 40] <= v34)
                goto LABEL_39;
            }
            goto LABEL_23;
          }
LABEL_38:
          v45 = &a1[v30];
LABEL_39:
          v46 = (unint64_t)(v45 + 24);
          v47 = a2 - 24;
          if (v45 != a1)
          {
            while (1)
            {
              if (*((_BYTE *)v47 + 85))
              {
                v51 = *((float *)v47 + 19);
                if (v51 < v37)
                  goto LABEL_71;
                if (v51 != v37)
                  goto LABEL_57;
              }
              else
              {
                if (*((_OWORD *)v47 + 1) < __PAIR128__(v33, v31))
                  goto LABEL_71;
                if (*((_QWORD *)v47 + 3) != v33 || *((_QWORD *)v47 + 2) != v31)
                  goto LABEL_57;
              }
              v53 = *((float *)v47 + 17);
              if (v53 < v35 || v53 == v35 && v47[16] > v34)
                goto LABEL_71;
LABEL_57:
              v47 -= 24;
            }
          }
          v47 = a2;
          if (v46 < (unint64_t)a2)
          {
            v47 = a2 - 24;
            if (*((_BYTE *)a2 - 11))
              goto LABEL_42;
            while (*((_OWORD *)v47 + 1) >= __PAIR128__(v33, v31))
            {
              if (*((_QWORD *)v47 + 3) == v33 && *((_QWORD *)v47 + 2) == v31)
              {
LABEL_51:
                v50 = *((float *)v47 + 17);
                if (v50 < v35 || v50 == v35 && v47[16] > v34)
                  break;
              }
              while (1)
              {
                if (v46 >= (unint64_t)v47)
                  goto LABEL_71;
                v47 -= 24;
                if (!*((_BYTE *)v47 + 85))
                  break;
LABEL_42:
                v48 = *((float *)v47 + 19);
                if (v48 < v37)
                  goto LABEL_71;
                if (v48 == v37)
                  goto LABEL_51;
              }
            }
          }
LABEL_71:
          v10 = (unint64_t)(v45 + 24);
          if (v46 < (unint64_t)v47)
          {
            v54 = v47;
            v10 = v46;
LABEL_74:
            v55 = *(_DWORD *)v10;
            *(_DWORD *)v10 = *v54;
            *v54 = v55;
            v305 = *(_OWORD *)(v10 + 64);
            v310 = *(_OWORD *)(v10 + 80);
            v292 = *(_OWORD *)(v10 + 32);
            v300 = *(_OWORD *)(v10 + 48);
            v284 = *(_OWORD *)(v10 + 16);
            *(_OWORD *)(v10 + 16) = *((_OWORD *)v54 + 1);
            v56 = *((_OWORD *)v54 + 3);
            v58 = *((_OWORD *)v54 + 4);
            v57 = *((_OWORD *)v54 + 5);
            *(_OWORD *)(v10 + 32) = *((_OWORD *)v54 + 2);
            *(_OWORD *)(v10 + 48) = v56;
            *(_OWORD *)(v10 + 64) = v58;
            *(_OWORD *)(v10 + 80) = v57;
            *((_OWORD *)v54 + 3) = v300;
            *((_OWORD *)v54 + 4) = v305;
            *((_OWORD *)v54 + 5) = v310;
            *((_OWORD *)v54 + 1) = v284;
            *((_OWORD *)v54 + 2) = v292;
            while (1)
            {
              do
              {
                while (1)
                {
                  v10 += 96;
                  if (!*(_BYTE *)(v10 + 85))
                    break;
                  v59 = *(float *)(v10 + 76);
                  if (v59 >= v37)
                  {
                    if (v59 != v37)
                      goto LABEL_88;
                    goto LABEL_85;
                  }
                }
              }
              while (*(_OWORD *)(v10 + 16) < __PAIR128__(v33, v31));
              if (*(_QWORD *)(v10 + 24) != v33 || *(_QWORD *)(v10 + 16) != v31)
                break;
LABEL_85:
              v61 = *(float *)(v10 + 68);
              if (v61 >= v35 && (v61 != v35 || *(_DWORD *)(v10 + 64) <= v34))
                goto LABEL_88;
            }
            while (1)
            {
LABEL_88:
              v54 -= 24;
              if (*((_BYTE *)v54 + 85))
              {
                v62 = *((float *)v54 + 19);
                if (v62 < v37)
                  goto LABEL_73;
                if (v62 != v37)
                  continue;
              }
              else
              {
                if (*((_OWORD *)v54 + 1) < __PAIR128__(v33, v31))
                  goto LABEL_73;
                if (*((_QWORD *)v54 + 3) != v33 || *((_QWORD *)v54 + 2) != v31)
                  continue;
              }
              v64 = *((float *)v54 + 17);
              if (v64 < v35 || v64 == v35 && v54[16] > v34)
              {
LABEL_73:
                if (v10 >= (unint64_t)v54)
                  break;
                goto LABEL_74;
              }
            }
          }
          if ((int *)(v10 - 96) != a1)
          {
            *a1 = *(_DWORD *)(v10 - 96);
            *((_OWORD *)a1 + 1) = *(_OWORD *)(v10 - 80);
            v65 = *(_OWORD *)(v10 - 64);
            v66 = *(_OWORD *)(v10 - 48);
            v67 = *(_OWORD *)(v10 - 16);
            *((_OWORD *)a1 + 4) = *(_OWORD *)(v10 - 32);
            *((_OWORD *)a1 + 5) = v67;
            *((_OWORD *)a1 + 2) = v65;
            *((_OWORD *)a1 + 3) = v66;
          }
          *(_DWORD *)(v10 - 96) = v32;
          *(_QWORD *)(v10 - 80) = v31;
          *(_QWORD *)(v10 - 72) = v33;
          *(_OWORD *)(v10 - 64) = v322;
          *(_OWORD *)(v10 - 48) = v330;
          *(_DWORD *)(v10 - 32) = v34;
          *(float *)(v10 - 28) = v35;
          *(_DWORD *)(v10 - 24) = v36;
          *(float *)(v10 - 20) = v37;
          *(__n128 *)(v10 - 16) = v314;
          if (v46 < (unint64_t)v47)
            goto LABEL_107;
          v68 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,SIWordTrieFragmentGetBundleIDs::$_0 &,std::pair<unsigned int,ci_rankingbits_wrapped_s> *>((__n128 *)a1, (int *)(v10 - 96), v314);
          if (!std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,SIWordTrieFragmentGetBundleIDs::$_0 &,std::pair<unsigned int,ci_rankingbits_wrapped_s> *>((__n128 *)v10, a2, v69))
          {
            if (v68)
              continue;
LABEL_107:
            std::__introsort<std::_ClassicAlgPolicy,SIWordTrieFragmentGetBundleIDs::$_0 &,std::pair<unsigned int,ci_rankingbits_wrapped_s> *,false>(a1, v10 - 96, a3, a4 & 1);
            a4 = 0;
            continue;
          }
          a2 = (int *)(v10 - 96);
          if (v68)
            return result;
          break;
      }
      break;
    }
  }
}

__n128 std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,SIWordTrieFragmentGetBundleIDs::$_0 &,std::pair<unsigned int,ci_rankingbits_wrapped_s> *>(__n128 *a1, __n128 *a2, __n128 *a3, __n128 result)
{
  float v4;
  unint64_t v5;
  unint64_t v6;
  float v8;
  float v9;
  float v10;
  float v11;
  unint64_t v12;
  unint64_t v13;
  float v15;
  float v16;
  unsigned __int32 v17;
  __n128 v18;
  __n128 v19;
  __n128 v20;
  float v21;
  __n128 *v22;
  __n128 v23;
  __n128 v24;
  __n128 v25;
  float v26;
  unint64_t v27;
  unint64_t v28;
  float v30;
  unsigned __int32 v31;
  __n128 *v32;
  __n128 v33;
  __n128 v34;
  __n128 v35;
  float v36;
  unint64_t v37;
  unint64_t v38;
  float v40;
  unsigned __int32 v41;
  __n128 v42;
  __n128 v43;
  __n128 v44;
  float v46;
  unsigned __int32 v47;
  __n128 v48;
  __n128 v49;
  __n128 v50;
  __n128 v51;
  __n128 v52;
  __n128 v53;
  __n128 v54;
  __n128 v55;
  __n128 v56;
  __n128 v57;
  __n128 v58;
  __n128 v59;
  __n128 v60;
  __n128 v61;
  __n128 v62;
  __n128 v63;
  __n128 v64;
  __n128 v65;
  __n128 v66;
  __n128 v67;
  __n128 v68;
  __n128 v69;
  __n128 v70;

  if (a2[5].n128_u8[5])
  {
    result.n128_u32[0] = a2[4].n128_u32[3];
    v4 = a1[4].n128_f32[3];
    if (result.n128_f32[0] < v4)
      goto LABEL_14;
    if (result.n128_f32[0] != v4)
      goto LABEL_18;
LABEL_11:
    result.n128_u32[0] = a2[4].n128_u32[1];
    v8 = a1[4].n128_f32[1];
    if (result.n128_f32[0] < v8 || result.n128_f32[0] == v8 && a2[4].n128_u32[0] > a1[4].n128_u32[0])
    {
LABEL_14:
      if (a3[5].n128_u8[5])
      {
        v9 = a3[4].n128_f32[3];
        v10 = a2[4].n128_f32[3];
        if (v9 >= v10)
        {
          if (v9 != v10)
            goto LABEL_32;
LABEL_28:
          v15 = a3[4].n128_f32[1];
          v16 = a2[4].n128_f32[1];
          if (v15 < v16 || v15 == v16 && a3[4].n128_u32[0] > a2[4].n128_u32[0])
            goto LABEL_31;
LABEL_32:
          v21 = a1->n128_f32[0];
          a1->n128_u32[0] = a2->n128_u32[0];
          a2->n128_f32[0] = v21;
          v22 = a2 + 1;
          v60 = a1[3];
          v64 = a1[4];
          v68 = a1[5];
          v52 = a1[1];
          v56 = a1[2];
          a1[1] = a2[1];
          v23 = a2[5];
          v25 = a2[2];
          v24 = a2[3];
          a1[4] = a2[4];
          a1[5] = v23;
          a1[2] = v25;
          a1[3] = v24;
          a2[4] = v64;
          a2[5] = v68;
          result = v52;
          a2[1] = v52;
          a2[2] = v56;
          a2[3] = v60;
          if (a3[5].n128_u8[5])
          {
            result.n128_u32[0] = a3[4].n128_u32[3];
            v26 = a2[4].n128_f32[3];
            if (result.n128_f32[0] >= v26)
            {
              if (result.n128_f32[0] != v26)
                return result;
LABEL_55:
              result.n128_u32[0] = a3[4].n128_u32[1];
              v40 = a2[4].n128_f32[1];
              if (result.n128_f32[0] >= v40 && (result.n128_f32[0] != v40 || a3[4].n128_u32[0] <= a2[4].n128_u32[0]))
                return result;
            }
          }
          else
          {
            v38 = a3[1].n128_u64[0];
            v37 = a3[1].n128_u64[1];
            if (__PAIR128__(v37, v38) >= *(_OWORD *)v22)
            {
              if (v37 != a2[1].n128_u64[1] || v38 != v22->n128_u64[0])
                return result;
              goto LABEL_55;
            }
          }
          v41 = a2->n128_u32[0];
          a2->n128_u32[0] = a3->n128_u32[0];
          a3->n128_u32[0] = v41;
          v59 = a2[3];
          v63 = a2[4];
          v67 = a2[5];
          v51 = *v22;
          v55 = a2[2];
          *v22 = a3[1];
          v42 = a3[5];
          v44 = a3[2];
          v43 = a3[3];
          a2[4] = a3[4];
          a2[5] = v42;
          a2[2] = v44;
          a2[3] = v43;
          goto LABEL_59;
        }
      }
      else
      {
        v13 = a3[1].n128_u64[0];
        v12 = a3[1].n128_u64[1];
        if (__PAIR128__(v12, v13) >= *(_OWORD *)&a2[1])
        {
          if (v12 != a2[1].n128_u64[1] || v13 != a2[1].n128_u64[0])
            goto LABEL_32;
          goto LABEL_28;
        }
      }
LABEL_31:
      v17 = a1->n128_u32[0];
      a1->n128_u32[0] = a3->n128_u32[0];
      a3->n128_u32[0] = v17;
      v59 = a1[3];
      v63 = a1[4];
      v67 = a1[5];
      v51 = a1[1];
      v55 = a1[2];
      a1[1] = a3[1];
      v18 = a3[5];
      v20 = a3[2];
      v19 = a3[3];
      a1[4] = a3[4];
      a1[5] = v18;
      a1[2] = v20;
      a1[3] = v19;
LABEL_59:
      a3[4] = v63;
      a3[5] = v67;
      result = v51;
      a3[1] = v51;
      a3[2] = v55;
      a3[3] = v59;
      return result;
    }
    goto LABEL_18;
  }
  v6 = a2[1].n128_u64[0];
  v5 = a2[1].n128_u64[1];
  if (__PAIR128__(v5, v6) < *(_OWORD *)&a1[1])
    goto LABEL_14;
  if (v5 == a1[1].n128_u64[1] && v6 == a1[1].n128_u64[0])
    goto LABEL_11;
LABEL_18:
  if (a3[5].n128_u8[5])
  {
    result.n128_u32[0] = a3[4].n128_u32[3];
    v11 = a2[4].n128_f32[3];
    if (result.n128_f32[0] < v11)
      goto LABEL_45;
    if (result.n128_f32[0] != v11)
      return result;
  }
  else
  {
    v28 = a3[1].n128_u64[0];
    v27 = a3[1].n128_u64[1];
    if (__PAIR128__(v27, v28) < *(_OWORD *)&a2[1])
      goto LABEL_45;
    if (v27 != a2[1].n128_u64[1] || v28 != a2[1].n128_u64[0])
      return result;
  }
  result.n128_u32[0] = a3[4].n128_u32[1];
  v30 = a2[4].n128_f32[1];
  if (result.n128_f32[0] >= v30 && (result.n128_f32[0] != v30 || a3[4].n128_u32[0] <= a2[4].n128_u32[0]))
    return result;
LABEL_45:
  v31 = a2->n128_u32[0];
  a2->n128_u32[0] = a3->n128_u32[0];
  a3->n128_u32[0] = v31;
  v32 = a2 + 1;
  v61 = a2[3];
  v65 = a2[4];
  v69 = a2[5];
  v53 = a2[1];
  v57 = a2[2];
  a2[1] = a3[1];
  v33 = a3[5];
  v35 = a3[2];
  v34 = a3[3];
  a2[4] = a3[4];
  a2[5] = v33;
  a2[2] = v35;
  a2[3] = v34;
  a3[4] = v65;
  a3[5] = v69;
  result = v53;
  a3[1] = v53;
  a3[2] = v57;
  a3[3] = v61;
  if (!a2[5].n128_u8[5])
  {
    if (*(_OWORD *)v32 >= *(_OWORD *)&a1[1])
    {
      if (a2[1].n128_u64[1] != a1[1].n128_u64[1] || v32->n128_u64[0] != a1[1].n128_u64[0])
        return result;
      goto LABEL_66;
    }
LABEL_69:
    v47 = a1->n128_u32[0];
    a1->n128_u32[0] = a2->n128_u32[0];
    a2->n128_u32[0] = v47;
    v62 = a1[3];
    v66 = a1[4];
    v70 = a1[5];
    v54 = a1[1];
    v58 = a1[2];
    a1[1] = *v32;
    v48 = a2[5];
    v50 = a2[2];
    v49 = a2[3];
    a1[4] = a2[4];
    a1[5] = v48;
    a1[2] = v50;
    a1[3] = v49;
    a2[4] = v66;
    a2[5] = v70;
    result = v54;
    *v32 = v54;
    a2[2] = v58;
    a2[3] = v62;
    return result;
  }
  result.n128_u32[0] = a2[4].n128_u32[3];
  v36 = a1[4].n128_f32[3];
  if (result.n128_f32[0] < v36)
    goto LABEL_69;
  if (result.n128_f32[0] != v36)
    return result;
LABEL_66:
  result.n128_u32[0] = a2[4].n128_u32[1];
  v46 = a1[4].n128_f32[1];
  if (result.n128_f32[0] < v46 || result.n128_f32[0] == v46 && a2[4].n128_u32[0] > a1[4].n128_u32[0])
    goto LABEL_69;
  return result;
}

__n128 std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,SIWordTrieFragmentGetBundleIDs::$_0 &,std::pair<unsigned int,ci_rankingbits_wrapped_s> *>(__n128 *a1, __n128 *a2, __n128 *a3, __n128 *a4, __n128 a5)
{
  __n128 result;
  float v10;
  unint64_t v11;
  unint64_t v12;
  float v14;
  unsigned __int32 v15;
  __n128 *v16;
  __n128 v17;
  __n128 v18;
  __n128 v19;
  float v20;
  float v22;
  unsigned __int32 v23;
  __n128 *v24;
  __n128 v25;
  __n128 v26;
  __n128 v27;
  float v28;
  float v30;
  unsigned __int32 v31;
  __n128 v32;
  __n128 v33;
  __n128 v34;
  __n128 v35;
  __n128 v36;
  __n128 v37;
  __n128 v38;
  __n128 v39;
  __n128 v40;
  __n128 v41;
  __n128 v42;
  __n128 v43;
  __n128 v44;
  __n128 v45;
  __n128 v46;
  __n128 v47;
  __n128 v48;
  __n128 v49;

  result.n128_u64[0] = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,SIWordTrieFragmentGetBundleIDs::$_0 &,std::pair<unsigned int,ci_rankingbits_wrapped_s> *>(a1, a2, a3, a5).n128_u64[0];
  if (a4[5].n128_u8[5])
  {
    result.n128_u32[0] = a4[4].n128_u32[3];
    v10 = a3[4].n128_f32[3];
    if (result.n128_f32[0] < v10)
      goto LABEL_14;
    if (result.n128_f32[0] != v10)
      return result;
  }
  else
  {
    v12 = a4[1].n128_u64[0];
    v11 = a4[1].n128_u64[1];
    if (__PAIR128__(v11, v12) < *(_OWORD *)&a3[1])
      goto LABEL_14;
    if (v11 != a3[1].n128_u64[1] || v12 != a3[1].n128_u64[0])
      return result;
  }
  result.n128_u32[0] = a4[4].n128_u32[1];
  v14 = a3[4].n128_f32[1];
  if (result.n128_f32[0] >= v14 && (result.n128_f32[0] != v14 || a4[4].n128_u32[0] <= a3[4].n128_u32[0]))
    return result;
LABEL_14:
  v15 = a3->n128_u32[0];
  a3->n128_u32[0] = a4->n128_u32[0];
  a4->n128_u32[0] = v15;
  v16 = a3 + 1;
  v41 = a3[3];
  v44 = a3[4];
  v47 = a3[5];
  v35 = a3[1];
  v38 = a3[2];
  a3[1] = a4[1];
  v17 = a4[5];
  v19 = a4[2];
  v18 = a4[3];
  a3[4] = a4[4];
  a3[5] = v17;
  a3[2] = v19;
  a3[3] = v18;
  a4[4] = v44;
  a4[5] = v47;
  result = v35;
  a4[1] = v35;
  a4[2] = v38;
  a4[3] = v41;
  if (a3[5].n128_u8[5])
  {
    result.n128_u32[0] = a3[4].n128_u32[3];
    v20 = a2[4].n128_f32[3];
    if (result.n128_f32[0] < v20)
      goto LABEL_27;
    if (result.n128_f32[0] != v20)
      return result;
  }
  else
  {
    if (*(_OWORD *)v16 < *(_OWORD *)&a2[1])
      goto LABEL_27;
    if (a3[1].n128_u64[1] != a2[1].n128_u64[1] || v16->n128_u64[0] != a2[1].n128_u64[0])
      return result;
  }
  result.n128_u32[0] = a3[4].n128_u32[1];
  v22 = a2[4].n128_f32[1];
  if (result.n128_f32[0] >= v22 && (result.n128_f32[0] != v22 || a3[4].n128_u32[0] <= a2[4].n128_u32[0]))
    return result;
LABEL_27:
  v23 = a2->n128_u32[0];
  a2->n128_u32[0] = a3->n128_u32[0];
  a3->n128_u32[0] = v23;
  v24 = a2 + 1;
  v42 = a2[3];
  v45 = a2[4];
  v48 = a2[5];
  v36 = a2[1];
  v39 = a2[2];
  a2[1] = *v16;
  v25 = a3[5];
  v27 = a3[2];
  v26 = a3[3];
  a2[4] = a3[4];
  a2[5] = v25;
  a2[2] = v27;
  a2[3] = v26;
  a3[4] = v45;
  a3[5] = v48;
  result = v36;
  *v16 = v36;
  a3[2] = v39;
  a3[3] = v42;
  if (!a2[5].n128_u8[5])
  {
    if (*(_OWORD *)v24 >= *(_OWORD *)&a1[1])
    {
      if (a2[1].n128_u64[1] != a1[1].n128_u64[1] || v24->n128_u64[0] != a1[1].n128_u64[0])
        return result;
      goto LABEL_37;
    }
LABEL_40:
    v31 = a1->n128_u32[0];
    a1->n128_u32[0] = a2->n128_u32[0];
    a2->n128_u32[0] = v31;
    v43 = a1[3];
    v46 = a1[4];
    v49 = a1[5];
    v37 = a1[1];
    v40 = a1[2];
    a1[1] = *v24;
    v32 = a2[5];
    v34 = a2[2];
    v33 = a2[3];
    a1[4] = a2[4];
    a1[5] = v32;
    a1[2] = v34;
    a1[3] = v33;
    a2[4] = v46;
    a2[5] = v49;
    result = v37;
    *v24 = v37;
    a2[2] = v40;
    a2[3] = v43;
    return result;
  }
  result.n128_u32[0] = a2[4].n128_u32[3];
  v28 = a1[4].n128_f32[3];
  if (result.n128_f32[0] < v28)
    goto LABEL_40;
  if (result.n128_f32[0] != v28)
    return result;
LABEL_37:
  result.n128_u32[0] = a2[4].n128_u32[1];
  v30 = a1[4].n128_f32[1];
  if (result.n128_f32[0] < v30 || result.n128_f32[0] == v30 && a2[4].n128_u32[0] > a1[4].n128_u32[0])
    goto LABEL_40;
  return result;
}

__n128 std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,SIWordTrieFragmentGetBundleIDs::$_0 &,std::pair<unsigned int,ci_rankingbits_wrapped_s> *,0>(__n128 *a1, __n128 *a2, __n128 *a3, __n128 *a4, __n128 *a5, __n128 a6)
{
  __n128 result;
  float v12;
  unint64_t v13;
  unint64_t v14;
  float v16;
  unsigned __int32 v17;
  __n128 *v18;
  __n128 v19;
  __n128 v20;
  __n128 v21;
  float v22;
  float v24;
  unsigned __int32 v25;
  __n128 *v26;
  __n128 v27;
  __n128 v28;
  __n128 v29;
  float v30;
  float v32;
  unsigned __int32 v33;
  __n128 *v34;
  __n128 v35;
  __n128 v36;
  __n128 v37;
  float v38;
  float v40;
  unsigned __int32 v41;
  __n128 v42;
  __n128 v43;
  __n128 v44;
  __n128 v45;
  __n128 v46;
  __n128 v47;
  __n128 v48;
  __n128 v49;
  __n128 v50;
  __n128 v51;
  __n128 v52;
  __n128 v53;
  __n128 v54;
  __n128 v55;
  __n128 v56;
  __n128 v57;
  __n128 v58;
  __n128 v59;
  __n128 v60;
  __n128 v61;
  __n128 v62;
  __n128 v63;
  __n128 v64;

  result.n128_u64[0] = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,SIWordTrieFragmentGetBundleIDs::$_0 &,std::pair<unsigned int,ci_rankingbits_wrapped_s> *>(a1, a2, a3, a4, a6).n128_u64[0];
  if (a5[5].n128_u8[5])
  {
    result.n128_u32[0] = a5[4].n128_u32[3];
    v12 = a4[4].n128_f32[3];
    if (result.n128_f32[0] < v12)
      goto LABEL_14;
    if (result.n128_f32[0] != v12)
      return result;
  }
  else
  {
    v14 = a5[1].n128_u64[0];
    v13 = a5[1].n128_u64[1];
    if (__PAIR128__(v13, v14) < *(_OWORD *)&a4[1])
      goto LABEL_14;
    if (v13 != a4[1].n128_u64[1] || v14 != a4[1].n128_u64[0])
      return result;
  }
  result.n128_u32[0] = a5[4].n128_u32[1];
  v16 = a4[4].n128_f32[1];
  if (result.n128_f32[0] >= v16 && (result.n128_f32[0] != v16 || a5[4].n128_u32[0] <= a4[4].n128_u32[0]))
    return result;
LABEL_14:
  v17 = a4->n128_u32[0];
  a4->n128_u32[0] = a5->n128_u32[0];
  a5->n128_u32[0] = v17;
  v18 = a4 + 1;
  v53 = a4[3];
  v57 = a4[4];
  v61 = a4[5];
  v45 = a4[1];
  v49 = a4[2];
  a4[1] = a5[1];
  v19 = a5[5];
  v21 = a5[2];
  v20 = a5[3];
  a4[4] = a5[4];
  a4[5] = v19;
  a4[2] = v21;
  a4[3] = v20;
  a5[4] = v57;
  a5[5] = v61;
  result = v45;
  a5[1] = v45;
  a5[2] = v49;
  a5[3] = v53;
  if (a4[5].n128_u8[5])
  {
    result.n128_u32[0] = a4[4].n128_u32[3];
    v22 = a3[4].n128_f32[3];
    if (result.n128_f32[0] < v22)
      goto LABEL_27;
    if (result.n128_f32[0] != v22)
      return result;
  }
  else
  {
    if (*(_OWORD *)v18 < *(_OWORD *)&a3[1])
      goto LABEL_27;
    if (a4[1].n128_u64[1] != a3[1].n128_u64[1] || v18->n128_u64[0] != a3[1].n128_u64[0])
      return result;
  }
  result.n128_u32[0] = a4[4].n128_u32[1];
  v24 = a3[4].n128_f32[1];
  if (result.n128_f32[0] >= v24 && (result.n128_f32[0] != v24 || a4[4].n128_u32[0] <= a3[4].n128_u32[0]))
    return result;
LABEL_27:
  v25 = a3->n128_u32[0];
  a3->n128_u32[0] = a4->n128_u32[0];
  a4->n128_u32[0] = v25;
  v26 = a3 + 1;
  v54 = a3[3];
  v58 = a3[4];
  v62 = a3[5];
  v46 = a3[1];
  v50 = a3[2];
  a3[1] = *v18;
  v27 = a4[5];
  v29 = a4[2];
  v28 = a4[3];
  a3[4] = a4[4];
  a3[5] = v27;
  a3[2] = v29;
  a3[3] = v28;
  a4[4] = v58;
  a4[5] = v62;
  result = v46;
  *v18 = v46;
  a4[2] = v50;
  a4[3] = v54;
  if (a3[5].n128_u8[5])
  {
    result.n128_u32[0] = a3[4].n128_u32[3];
    v30 = a2[4].n128_f32[3];
    if (result.n128_f32[0] < v30)
      goto LABEL_40;
    if (result.n128_f32[0] != v30)
      return result;
  }
  else
  {
    if (*(_OWORD *)v26 < *(_OWORD *)&a2[1])
      goto LABEL_40;
    if (a3[1].n128_u64[1] != a2[1].n128_u64[1] || v26->n128_u64[0] != a2[1].n128_u64[0])
      return result;
  }
  result.n128_u32[0] = a3[4].n128_u32[1];
  v32 = a2[4].n128_f32[1];
  if (result.n128_f32[0] >= v32 && (result.n128_f32[0] != v32 || a3[4].n128_u32[0] <= a2[4].n128_u32[0]))
    return result;
LABEL_40:
  v33 = a2->n128_u32[0];
  a2->n128_u32[0] = a3->n128_u32[0];
  a3->n128_u32[0] = v33;
  v34 = a2 + 1;
  v55 = a2[3];
  v59 = a2[4];
  v63 = a2[5];
  v47 = a2[1];
  v51 = a2[2];
  a2[1] = *v26;
  v35 = a3[5];
  v37 = a3[2];
  v36 = a3[3];
  a2[4] = a3[4];
  a2[5] = v35;
  a2[2] = v37;
  a2[3] = v36;
  a3[4] = v59;
  a3[5] = v63;
  result = v47;
  *v26 = v47;
  a3[2] = v51;
  a3[3] = v55;
  if (!a2[5].n128_u8[5])
  {
    if (*(_OWORD *)v34 >= *(_OWORD *)&a1[1])
    {
      if (a2[1].n128_u64[1] != a1[1].n128_u64[1] || v34->n128_u64[0] != a1[1].n128_u64[0])
        return result;
      goto LABEL_50;
    }
LABEL_53:
    v41 = a1->n128_u32[0];
    a1->n128_u32[0] = a2->n128_u32[0];
    a2->n128_u32[0] = v41;
    v56 = a1[3];
    v60 = a1[4];
    v64 = a1[5];
    v48 = a1[1];
    v52 = a1[2];
    a1[1] = *v34;
    v42 = a2[5];
    v44 = a2[2];
    v43 = a2[3];
    a1[4] = a2[4];
    a1[5] = v42;
    a1[2] = v44;
    a1[3] = v43;
    a2[4] = v60;
    a2[5] = v64;
    result = v48;
    *v34 = v48;
    a2[2] = v52;
    a2[3] = v56;
    return result;
  }
  result.n128_u32[0] = a2[4].n128_u32[3];
  v38 = a1[4].n128_f32[3];
  if (result.n128_f32[0] < v38)
    goto LABEL_53;
  if (result.n128_f32[0] != v38)
    return result;
LABEL_50:
  result.n128_u32[0] = a2[4].n128_u32[1];
  v40 = a1[4].n128_f32[1];
  if (result.n128_f32[0] < v40 || result.n128_f32[0] == v40 && a2[4].n128_u32[0] > a1[4].n128_u32[0])
    goto LABEL_53;
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,SIWordTrieFragmentGetBundleIDs::$_0 &,std::pair<unsigned int,ci_rankingbits_wrapped_s> *>(__n128 *a1, int *a2, __n128 a3)
{
  unint64_t v5;
  _BOOL8 result;
  float v7;
  float v8;
  __n128 *v9;
  int *v10;
  uint64_t v11;
  int v12;
  unint64_t *n128_u64;
  int v14;
  float v15;
  float v16;
  unint64_t v17;
  unint64_t v18;
  float v20;
  float v21;
  float v22;
  unint64_t v23;
  unint64_t v24;
  unsigned int v25;
  float v26;
  int v27;
  float v28;
  __n128 v29;
  __n128 v30;
  __n128 v31;
  uint64_t v32;
  __int128 v33;
  __int128 v34;
  uint64_t v35;
  float v36;
  float v37;
  __n128 *v38;
  __int128 v39;
  __int128 v40;
  uint64_t v41;
  _OWORD *v42;
  float v44;
  __n128 *v45;
  unint64_t v46;
  unint64_t v47;
  float v49;
  float v50;
  int v51;
  __n128 v52;
  __n128 v53;
  __n128 v54;
  int v55;
  unsigned __int8 v56;
  __n128 v57;
  __n128 v58;
  __n128 v59;
  __n128 v60;
  __n128 v61;
  __n128 v62;
  __n128 v63;
  unint64_t v64;
  unsigned __int16 v65;

  v5 = 0xAAAAAAAAAAAAAAABLL * (((char *)a2 - (char *)a1) >> 5);
  result = 1;
  switch(v5)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      if (!*((_BYTE *)a2 - 11))
      {
        v47 = *((_QWORD *)a2 - 10);
        v46 = *((_QWORD *)a2 - 9);
        if (__PAIR128__(v46, v47) >= *(_OWORD *)&a1[1])
        {
          if (v46 != a1[1].n128_u64[1] || v47 != a1[1].n128_u64[0])
            return result;
          goto LABEL_56;
        }
LABEL_59:
        v51 = a1->n128_u32[0];
        a1->n128_u32[0] = *(a2 - 24);
        *(a2 - 24) = v51;
        v61 = a1[3];
        v62 = a1[4];
        v63 = a1[5];
        v58 = a1[1];
        v60 = a1[2];
        a1[1] = *((__n128 *)a2 - 5);
        v52 = *((__n128 *)a2 - 1);
        v54 = *((__n128 *)a2 - 4);
        v53 = *((__n128 *)a2 - 3);
        a1[4] = *((__n128 *)a2 - 2);
        a1[5] = v52;
        a1[2] = v54;
        a1[3] = v53;
        *((__n128 *)a2 - 2) = v62;
        *((__n128 *)a2 - 1) = v63;
        *((__n128 *)a2 - 5) = v58;
        *((__n128 *)a2 - 4) = v60;
        *((__n128 *)a2 - 3) = v61;
        return result;
      }
      v7 = *((float *)a2 - 5);
      v8 = a1[4].n128_f32[3];
      if (v7 < v8)
        goto LABEL_59;
      if (v7 != v8)
        return result;
LABEL_56:
      v49 = *((float *)a2 - 7);
      v50 = a1[4].n128_f32[1];
      if (v49 < v50 || v49 == v50 && *(a2 - 8) > a1[4].n128_u32[0])
        goto LABEL_59;
      return result;
    case 3uLL:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,SIWordTrieFragmentGetBundleIDs::$_0 &,std::pair<unsigned int,ci_rankingbits_wrapped_s> *>(a1, a1 + 6, (__n128 *)a2 - 6, a3);
      return 1;
    case 4uLL:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,SIWordTrieFragmentGetBundleIDs::$_0 &,std::pair<unsigned int,ci_rankingbits_wrapped_s> *>(a1, a1 + 6, a1 + 12, (__n128 *)a2 - 6, a3);
      return 1;
    case 5uLL:
      std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,SIWordTrieFragmentGetBundleIDs::$_0 &,std::pair<unsigned int,ci_rankingbits_wrapped_s> *,0>(a1, a1 + 6, a1 + 12, a1 + 18, (__n128 *)a2 - 6, a3);
      return 1;
    default:
      v9 = a1 + 12;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,SIWordTrieFragmentGetBundleIDs::$_0 &,std::pair<unsigned int,ci_rankingbits_wrapped_s> *>(a1, a1 + 6, a1 + 12, a3);
      v10 = (int *)&a1[18];
      if (&a1[18] == (__n128 *)a2)
        return 1;
      v11 = 0;
      v12 = 0;
      while (2)
      {
        v14 = *((unsigned __int8 *)v10 + 85);
        if (*((_BYTE *)v10 + 85))
        {
          v15 = *((float *)v10 + 19);
          v16 = v9[4].n128_f32[3];
          if (v15 >= v16)
          {
            if (v15 != v16)
              goto LABEL_11;
LABEL_22:
            v20 = *((float *)v10 + 17);
            v21 = v9[4].n128_f32[1];
            if (v20 >= v21 && (v20 != v21 || v10[16] <= v9[4].n128_u32[0]))
              goto LABEL_11;
          }
        }
        else
        {
          v18 = *((_QWORD *)v10 + 2);
          v17 = *((_QWORD *)v10 + 3);
          if (__PAIR128__(v17, v18) >= *(_OWORD *)&v9[1])
          {
            if (v17 != v9[1].n128_u64[1] || v18 != v9[1].n128_u64[0])
              goto LABEL_11;
            goto LABEL_22;
          }
        }
        v22 = *(float *)v10;
        v24 = *((_QWORD *)v10 + 2);
        v23 = *((_QWORD *)v10 + 3);
        v57 = *((__n128 *)v10 + 2);
        v59 = *((__n128 *)v10 + 3);
        v25 = v10[16];
        v26 = *((float *)v10 + 17);
        v27 = v10[18];
        v28 = *((float *)v10 + 19);
        v55 = v10[20];
        v56 = *((_BYTE *)v10 + 84);
        v65 = *((_WORD *)v10 + 47);
        v64 = *(_QWORD *)((char *)v10 + 86);
        *v10 = v9->n128_u32[0];
        n128_u64 = v9[1].n128_u64;
        v29 = v9[5];
        v30 = v9[3];
        *((__n128 *)v10 + 4) = v9[4];
        *((__n128 *)v10 + 5) = v29;
        v31 = v9[1];
        *((__n128 *)v10 + 2) = v9[2];
        *((__n128 *)v10 + 3) = v30;
        *((__n128 *)v10 + 1) = v31;
        if (v9 == a1)
        {
LABEL_9:
          v9 = a1;
        }
        else
        {
          v32 = v11;
          if (v14)
          {
            while (1)
            {
              v35 = (uint64_t)a1 + v32;
              v36 = *(float *)((char *)&a1[10].n128_f32[3] + v32);
              if (v28 >= v36)
              {
                if (v28 != v36)
                  goto LABEL_10;
                v37 = *(float *)((char *)&a1[10].n128_f32[1] + v32);
                if (v26 >= v37)
                {
                  if (v26 != v37)
                    goto LABEL_10;
                  v38 = (__n128 *)((char *)a1 + v32);
                  if (v25 <= *(unsigned __int32 *)((char *)a1[10].n128_u32 + v32))
                    break;
                }
              }
              n128_u64 = v9[-5].n128_u64;
              v9 -= 6;
              *(_DWORD *)(v35 + 192) = *(_DWORD *)(v35 + 96);
              v33 = *(_OWORD *)(v35 + 160);
              *(_OWORD *)(v35 + 240) = *(_OWORD *)(v35 + 144);
              *(_OWORD *)(v35 + 256) = v33;
              *(_OWORD *)(v35 + 272) = *(_OWORD *)(v35 + 176);
              v34 = *(_OWORD *)(v35 + 128);
              v32 -= 96;
              *(_OWORD *)(v35 + 208) = *(_OWORD *)(v35 + 112);
              *(_OWORD *)(v35 + 224) = v34;
              if (v32 == -192)
              {
LABEL_8:
                n128_u64 = (unint64_t *)((char *)a1[13].n128_u64 + v32);
                goto LABEL_9;
              }
            }
            n128_u64 = v38[13].n128_u64;
            v9 = v38 + 12;
          }
          else
          {
            while (1)
            {
              v41 = (uint64_t)a1 + v32;
              v42 = (_OWORD *)((char *)a1[7].n128_u64 + v32);
              if (__PAIR128__(v23, v24) >= *v42)
              {
                if (v23 != *(unint64_t *)((char *)&a1[7].n128_u64[1] + v32)
                  || v24 != *(unint64_t *)((char *)a1[7].n128_u64 + v32))
                {
                  goto LABEL_10;
                }
                v44 = *(float *)((char *)&a1[10].n128_f32[1] + v32);
                if (v26 >= v44)
                {
                  if (v26 != v44)
                    goto LABEL_10;
                  v45 = (__n128 *)((char *)a1 + v32);
                  if (v25 <= *(unsigned __int32 *)((char *)a1[10].n128_u32 + v32))
                    break;
                }
              }
              n128_u64 = v9[-5].n128_u64;
              v9 -= 6;
              *(_DWORD *)(v41 + 192) = *(_DWORD *)(v41 + 96);
              v39 = *(__int128 *)((char *)&a1[10] + v32);
              *(__n128 *)(v41 + 240) = *(__n128 *)((char *)a1 + v32 + 144);
              *(_OWORD *)(v41 + 256) = v39;
              *(__n128 *)(v41 + 272) = *(__n128 *)((char *)a1 + v32 + 176);
              v40 = *(__int128 *)((char *)&a1[8] + v32);
              v32 -= 96;
              *(_OWORD *)(v41 + 208) = *v42;
              *(_OWORD *)(v41 + 224) = v40;
              if (v32 == -192)
                goto LABEL_8;
            }
            n128_u64 = v45[13].n128_u64;
            v9 = v45 + 12;
          }
        }
LABEL_10:
        v9->n128_f32[0] = v22;
        *n128_u64 = v24;
        n128_u64[1] = v23;
        v9[2] = v57;
        v9[3] = v59;
        v9[4].n128_u32[0] = v25;
        v9[4].n128_f32[1] = v26;
        v9[4].n128_u32[2] = v27;
        v9[4].n128_f32[3] = v28;
        v9[5].n128_u8[4] = v56;
        v9[5].n128_u32[0] = v55;
        v9[5].n128_u8[5] = v14;
        *(unint64_t *)((char *)v9[5].n128_u64 + 6) = v64;
        ++v12;
        v9[5].n128_u16[7] = v65;
        if (v12 == 8)
          return v10 + 24 == a2;
LABEL_11:
        v9 = (__n128 *)v10;
        v11 += 96;
        v10 += 24;
        if (v10 == a2)
          return 1;
        continue;
      }
  }
}

void word_trie_s::~word_trie_s(word_trie_s *this)
{
  _QWORD *v2;
  void *v3;
  _QWORD *v4;
  _QWORD *v5;
  word_trie_s *v6;
  _QWORD *v7;
  _QWORD *v8;
  void *v9;
  void *v10;

  v2 = (_QWORD *)*((_QWORD *)this + 2);
  if (v2)
  {
    do
    {
      v4 = (_QWORD *)*v2;
      v5 = (_QWORD *)v2[4];
      v2[4] = 0;
      if (v5)
      {
        v6 = (word_trie_s *)v5[13];
        if (v6)
        {
          word_trie_s::~word_trie_s(v6);
          MEMORY[0x1BCCB06A4]();
        }
        v7 = (_QWORD *)v5[17];
        if (v7)
        {
          do
          {
            v8 = (_QWORD *)*v7;
            operator delete(v7);
            v7 = v8;
          }
          while (v8);
        }
        v9 = (void *)v5[15];
        v5[15] = 0;
        if (v9)
          operator delete(v9);
        MEMORY[0x1BCCB06A4](v5, 0x10A0C4077AE0019);
      }
      v10 = (void *)v2[2];
      if (v10)
        free(v10);
      operator delete(v2);
      v2 = v4;
    }
    while (v4);
  }
  v3 = *(void **)this;
  *(_QWORD *)this = 0;
  if (v3)
    operator delete(v3);
}

void _SIWordTrieDestroy(char *a1)
{
  word_trie_s::~word_trie_s((word_trie_s *)(a1 + 16));
}

void word_trie_s::insert(uint64_t *a1, uint64_t a2, unint64_t a3, __int128 *a4, uint64_t a5, UErrorCode a6, int a7, int a8, __n128 a9, __n128 a10, int a11, unsigned __int8 a12, unsigned __int8 a13, int a14, unsigned __int8 a15, unsigned __int8 a16, unint64_t a17)
{
  uint64_t v20;
  const UChar *v21;
  uint64_t v22;
  size_t v23;
  UChar *v24;
  uint64_t i;
  unsigned int v26;
  size_t v27;
  _BYTE *v28;
  unint64_t v29;
  UChar *v30;
  UChar *v31;
  UChar *v32;
  unsigned int v33;
  unsigned int v34;
  int v35;
  unsigned int v36;
  UChar *v37;
  UChar *v38;
  UChar *v39;
  unsigned int v40;
  unsigned int v41;
  int v42;
  unsigned int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  unsigned __int16 *v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  uint64_t v54;
  unint64_t v55;
  int v56;
  BOOL v57;
  unint64_t v58;
  int v59;
  unsigned __int8 v60;
  unint64_t v61;
  unsigned int v62;
  unint64_t v63;
  uint8x8_t v64;
  unint64_t v65;
  uint64_t **v66;
  uint64_t *v67;
  uint64_t v68;
  int v69;
  int v70;
  int v71;
  unint64_t v72;
  int v73;
  unsigned __int8 v74;
  uint64_t v75;
  uint64_t v76;
  __int128 *v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  unint64_t v82;
  int v83;
  unint64_t v84;
  int v85;
  int v86;
  int v87;
  unint64_t v88;
  uint64_t v89;
  __int128 v90;
  __int128 v91;
  unsigned int v92;
  int v93;
  int v94;
  int v95;
  int v96;
  uint64_t v97;
  unint64_t v98;
  int v99;
  unint64_t v100;
  int v101;
  unsigned int v102;
  unint64_t v103;
  uint64_t v104;
  unint64_t v105;
  uint8x8_t v106;
  unint64_t v107;
  uint64_t **v108;
  uint64_t *v109;
  unint64_t v110;
  uint64_t v111;
  word_trie_s *v112;
  _QWORD *v113;
  _QWORD *v114;
  void *v115;
  _QWORD *v116;
  size_t v117;
  void *v118;
  float v119;
  float v120;
  _BOOL8 v121;
  unint64_t v122;
  unint64_t v123;
  size_t v124;
  int8x8_t v125;
  unint64_t v126;
  uint8x8_t v127;
  uint64_t v128;
  uint64_t v129;
  _QWORD *v130;
  uint64_t v131;
  unint64_t v132;
  int v133;
  int v134;
  uint64_t v135;
  unint64_t v136;
  int v137;
  unint64_t v138;
  int v139;
  uint64_t v140;
  unsigned int v141;
  unint64_t v142;
  unint64_t v143;
  void **v144;
  void *v145;
  uint64_t v146;
  int v147;
  UErrorCode v148;
  unint64_t v149;
  size_t v150;
  void *v151;
  float v152;
  float v153;
  _BOOL8 v155;
  unint64_t v156;
  unint64_t v157;
  size_t prime;
  int8x8_t v159;
  unint64_t v160;
  uint8x8_t v161;
  uint64_t v162;
  uint64_t v163;
  _QWORD *v164;
  unint64_t v165;
  uint64_t v166;
  __int128 *v167;
  uint64_t v168;
  int v169;
  float v170;
  float v171;
  BOOL v172;
  unint64_t v173;
  float64x2_t *v174;
  float v175;
  float v176;
  float64x2_t v177;
  float64x2_t v178;
  float64x2_t v179;
  __int128 v180;
  __int128 v181;
  int v182;
  int v183;
  __int16 v184;
  int v185;
  int v186;
  unint64_t v187;
  unsigned int v188;
  int v189;
  int v190;
  unsigned int v191;
  uint64_t v192;
  uint64_t v193;
  unint64_t v194;
  __n128 v195;
  __n128 v196;
  uint64_t v197;
  __int128 v198;
  __int128 v199;
  uint64_t v200;
  uint64_t v201;
  unint64_t v202;
  int v203;
  unint64_t v204;
  uint64_t *v205;
  unsigned int v206;
  unint64_t v207;
  unint64_t v208;
  UErrorCode v209;
  __int128 *v210;
  uint64_t v211;
  int v212;
  int v213;
  uint64_t v214;
  int v215;
  int v216;
  int v217;
  unint64_t v218;
  int v219;
  __n128 v220;
  __n128 v221;
  int v222;
  uint64_t *v223;
  size_t v224;
  __int128 v225;
  __int128 v226;
  __int128 v227;
  __int128 v228;
  __int128 v229;
  __int128 v230;
  __int128 v231;
  __int128 v232;
  __int128 v233;
  __int128 v234;
  UErrorCode pErrorCode[4];
  __int128 v236;
  __int128 v237;
  __int128 v238;
  __int128 v239;
  __int128 v240;
  uint64_t v241;

  v219 = a8;
  v209 = a6;
  v210 = a4;
  v218 = a3;
  v220 = a9;
  v221 = a10;
  v241 = *MEMORY[0x1E0C80C00];
  v211 = a2;
  v208 = a17;
  v20 = a2 + 16 * a17;
  v21 = *(const UChar **)v20;
  v22 = *(unsigned int *)(v20 + 8);
  v23 = malloc_good_size(2 * v22);
  v24 = (UChar *)malloc_type_malloc(v23, 0x68EC0231uLL);
  pErrorCode[0] = U_ZERO_ERROR;
  for (i = u_strToLower(v24, (unint64_t)(int)v23 >> 1, v21, v22, 0, pErrorCode);
        pErrorCode[0] == U_BUFFER_OVERFLOW_ERROR;
        v23 *= 2)
  {
    v24 = (UChar *)malloc_type_realloc(v24, 2 * v23, 0xA66EE534uLL);
    i = u_strToLower(v24, (unint64_t)(2 * (int)v23) >> 1, v21, v22, 0, pErrorCode);
  }
  v26 = i;
  v205 = &v200;
  v27 = (3 * i + 1);
  MEMORY[0x1E0C80A78](i);
  v28 = (char *)&v200 - ((v27 + 15) & 0x1FFFFFFF0);
  bzero(v28, v27);
  if (v27 >= 4 * (unint64_t)v26)
  {
    if (v26)
    {
      v37 = &v24[v26];
      v38 = v24;
      v39 = v24;
      do
      {
        v41 = *v39++;
        v40 = v41;
        if (v41 <= 0x7F)
        {
          *v28++ = v40;
        }
        else if (v40 > 0x7FF)
        {
          if ((v40 & 0xF800) == 0xD800)
          {
            if ((v40 & 0x400) == 0 && v39 < v37)
            {
              v42 = *v39;
              if ((v42 & 0xFC00) == 0xDC00)
              {
                v39 = v38 + 2;
                v43 = v42 + (v40 << 10) - 56613888;
                *v28 = (v43 >> 18) | 0xF0;
                v28[1] = (v43 >> 12) & 0x3F | 0x80;
                v28[2] = (v43 >> 6) & 0x3F | 0x80;
                v28[3] = v42 & 0x3F | 0x80;
                v28 += 4;
              }
            }
          }
          else
          {
            *v28 = (v40 >> 12) | 0xE0;
            v28[1] = (v40 >> 6) & 0x3F | 0x80;
            v28[2] = v40 & 0x3F | 0x80;
            v28 += 3;
          }
        }
        else
        {
          *v28 = (v40 >> 6) | 0xC0;
          v28[1] = v40 & 0x3F | 0x80;
          v28 += 2;
        }
        v38 = v39;
      }
      while (v39 < v37);
    }
  }
  else if (v26)
  {
    v29 = (unint64_t)&v28[v27];
    v30 = &v24[v26];
    v31 = v24;
    v32 = v24;
    do
    {
      v34 = *v32++;
      v33 = v34;
      if (v34 > 0x7F)
      {
        if (v33 <= 0x7FF)
        {
          if ((unint64_t)(v28 + 1) >= v29)
            break;
          *v28 = (v33 >> 6) | 0xC0;
          v28[1] = v33 & 0x3F | 0x80;
          v28 += 2;
        }
        else if ((v33 & 0xF800) == 0xD800)
        {
          if ((v33 & 0x400) == 0 && v32 < v30)
          {
            v35 = *v32;
            if ((v35 & 0xFC00) == 0xDC00)
            {
              if ((unint64_t)(v28 + 3) >= v29)
                break;
              v32 = v31 + 2;
              v36 = v35 + (v33 << 10) - 56613888;
              *v28 = (v36 >> 18) | 0xF0;
              v28[1] = (v36 >> 12) & 0x3F | 0x80;
              v28[2] = (v36 >> 6) & 0x3F | 0x80;
              v28[3] = v35 & 0x3F | 0x80;
              v28 += 4;
            }
          }
        }
        else
        {
          if ((unint64_t)(v28 + 2) >= v29)
            break;
          *v28 = (v33 >> 12) | 0xE0;
          v28[1] = (v33 >> 6) & 0x3F | 0x80;
          v28[2] = v33 & 0x3F | 0x80;
          v28 += 3;
        }
      }
      else
      {
        if ((unint64_t)v28 >= v29)
          break;
        *v28++ = v33;
      }
      v31 = v32;
    }
    while (v32 < v30);
  }
  v214 = a5;
  v212 = a7;
  v223 = a1;
  v44 = -1759636613;
  *v28 = 0;
  v45 = 2 * v26;
  if ((v26 & 0x40000000) != 0)
    v46 = 2 * v26 + 3;
  else
    v46 = 2 * v26;
  v47 = v46 >> 2;
  v48 = (UChar *)((char *)v24 + (int)(v46 & 0xFFFFFFFC));
  v49 = 1713515327;
  v50 = 1107688271;
  v51 = -1759636613;
  v206 = 2 * v26 + 3;
  if (v206 >= 7)
  {
    v52 = -1789642873;
    v53 = 718793509;
    v54 = -v47;
    v51 = -1759636613;
    do
    {
      v52 = 5 * v52 + 2071795100;
      v53 = 5 * v53 + 1808688022;
      HIDWORD(v55) = v52 * *(_DWORD *)&v48[2 * v54];
      LODWORD(v55) = HIDWORD(v55);
      v56 = (v55 >> 21) * v53;
      HIDWORD(v55) = v51;
      LODWORD(v55) = v51;
      v51 = v56 ^ (5 * (v55 >> 19) + 1390208809);
      v57 = __CFADD__(v54++, 1);
    }
    while (!v57);
    v49 = 5 * v52 + 2071795100;
    v50 = 5 * v53 + 1808688022;
  }
  v217 = a13;
  v216 = a12;
  v215 = a11;
  v213 = a14;
  v207 = a16;
  v203 = v47;
  if ((v26 & 1) != 0)
  {
    HIDWORD(v58) = *v48 * v49;
    LODWORD(v58) = HIDWORD(v58);
    v59 = (v58 >> 21) * v50;
    HIDWORD(v58) = v51;
    LODWORD(v58) = v51;
    v51 = v59 ^ (5 * (v58 >> 19) + 1390208809);
  }
  v60 = a15;
  v61 = v223[1];
  v224 = 2 * v26;
  v222 = a15;
  if (v61)
  {
    v62 = (-2048144789 * (v51 ^ v45)) ^ ((-2048144789 * (v51 ^ v45)) >> 13);
    v63 = (-1028477387 * v62) ^ ((-1028477387 * v62) >> 16);
    v64 = (uint8x8_t)vcnt_s8((int8x8_t)v61);
    v64.i16[0] = vaddlv_u8(v64);
    v202 = v64.u32[0];
    if (v64.u32[0] > 1uLL)
    {
      v65 = (-1028477387 * v62) ^ ((-1028477387 * v62) >> 16);
      if (v61 <= v63)
        v65 = v63 % v61;
    }
    else
    {
      v65 = ((_DWORD)v61 - 1) & v63;
    }
    v201 = *v223;
    v66 = *(uint64_t ***)(v201 + 8 * v65);
    if (v66)
    {
      v67 = *v66;
      if (*v66)
      {
        v204 = v61 - 1;
        if (v202 < 2)
        {
          while (1)
          {
            v68 = v67[1];
            if (v68 == v63)
            {
              if (*((_DWORD *)v67 + 6) == v26)
              {
                v69 = memcmp((const void *)v67[2], v24, v224);
                v60 = v222;
                if (!v69)
                  goto LABEL_58;
              }
            }
            else if ((v68 & v204) != v65)
            {
              goto LABEL_68;
            }
            v67 = (uint64_t *)*v67;
            if (!v67)
              goto LABEL_68;
          }
        }
        do
        {
          v72 = v67[1];
          if (v72 == v63)
          {
            if (*((_DWORD *)v67 + 6) == v26)
            {
              v73 = memcmp((const void *)v67[2], v24, v224);
              v60 = v222;
              if (!v73)
              {
LABEL_58:
                if (v206 >= 7)
                {
                  v133 = -1789642873;
                  v134 = 718793509;
                  v135 = -v203;
                  do
                  {
                    v133 = 5 * v133 + 2071795100;
                    v134 = 5 * v134 + 1808688022;
                    HIDWORD(v136) = v133 * *(_DWORD *)&v48[2 * v135];
                    LODWORD(v136) = HIDWORD(v136);
                    v137 = (v136 >> 21) * v134;
                    HIDWORD(v136) = v44;
                    LODWORD(v136) = v44;
                    v44 = v137 ^ (5 * (v136 >> 19) + 1390208809);
                    v57 = __CFADD__(v135++, 1);
                  }
                  while (!v57);
                  v70 = 5 * v133 + 2071795100;
                  v71 = 5 * v134 + 1808688022;
                }
                else
                {
                  v70 = 1713515327;
                  v71 = 1107688271;
                }
                if ((v26 & 1) != 0)
                {
                  HIDWORD(v138) = *v48 * v70;
                  LODWORD(v138) = HIDWORD(v138);
                  v139 = (v138 >> 21) * v71;
                  HIDWORD(v138) = v44;
                  LODWORD(v138) = v44;
                  v44 = v139 ^ (5 * (v138 >> 19) + 1390208809);
                }
                v140 = (uint64_t)v223;
                v141 = -1028477387 * ((-2048144789 * (v44 ^ v45)) ^ ((-2048144789 * (v44 ^ v45)) >> 13));
                v142 = v141 ^ HIWORD(v141);
                if (v202 > 1)
                {
                  v143 = v141 ^ HIWORD(v141);
                  if (v61 <= v142)
                    v143 = v142 % v61;
                }
                else
                {
                  v143 = ((_DWORD)v61 - 1) & v142;
                }
                v144 = *(void ***)(v201 + 8 * v143);
                if (v144)
                {
                  v145 = *v144;
                  if (*v144)
                  {
                    if (v202 < 2)
                    {
                      while (1)
                      {
                        v146 = *((_QWORD *)v145 + 1);
                        if (v146 == v142)
                        {
                          if (*((_DWORD *)v145 + 6) == v26 && !memcmp(*((const void **)v145 + 2), v24, v224))
                            goto LABEL_174;
                        }
                        else if ((v146 & v204) != v143)
                        {
                          goto LABEL_183;
                        }
                        v145 = *(void **)v145;
                        if (!v145)
                          goto LABEL_183;
                      }
                    }
                    do
                    {
                      v149 = *((_QWORD *)v145 + 1);
                      if (v149 == v142)
                      {
                        if (*((_DWORD *)v145 + 6) == v26 && !memcmp(*((const void **)v145 + 2), v24, v224))
                        {
LABEL_174:
                          v147 = v212;
                          v148 = v209;
                          goto LABEL_224;
                        }
                      }
                      else
                      {
                        if (v149 >= v61)
                          v149 %= v61;
                        if (v149 != v143)
                          break;
                      }
                      v145 = *(void **)v145;
                    }
                    while (v145);
                  }
                }
LABEL_183:
                v145 = operator new(0x28uLL);
                *(_QWORD *)v145 = 0;
                *((_QWORD *)v145 + 1) = v142;
                *((_QWORD *)v145 + 2) = 0;
                *((_DWORD *)v145 + 6) = v26;
                v150 = v224;
                v151 = malloc_type_malloc(v224, 0x1000040BDFB0063uLL);
                *((_QWORD *)v145 + 2) = v151;
                memcpy(v151, v24, v150);
                v152 = (float)(unint64_t)(*(_QWORD *)(v140 + 24) + 1);
                *((_QWORD *)v145 + 4) = 0;
                v153 = *(float *)(v140 + 32);
                if ((float)(v153 * (float)v61) < v152)
                {
                  v155 = v61 < 3 || v202 > 1;
                  v156 = v155 | (2 * v61);
                  v157 = vcvtps_u32_f32(v152 / v153);
                  if (v156 <= v157)
                    prime = v157;
                  else
                    prime = v156;
                  if (prime == 1)
                  {
                    prime = 2;
                  }
                  else if ((prime & (prime - 1)) != 0)
                  {
                    prime = std::__next_prime(prime);
                  }
                  v159 = *(int8x8_t *)(v140 + 8);
                  if (prime > *(_QWORD *)&v159)
                    goto LABEL_198;
                  if (prime < *(_QWORD *)&v159)
                  {
                    v160 = vcvtps_u32_f32((float)*(unint64_t *)(v140 + 24) / *(float *)(v140 + 32));
                    if (*(_QWORD *)&v159 < 3uLL
                      || (v161 = (uint8x8_t)vcnt_s8(v159), v161.i16[0] = vaddlv_u8(v161), v161.u32[0] > 1uLL))
                    {
                      v160 = std::__next_prime(v160);
                    }
                    else
                    {
                      v162 = 1 << -(char)__clz(v160 - 1);
                      if (v160 >= 2)
                        v160 = v162;
                    }
                    if (prime <= v160)
                      prime = v160;
                    if (prime < *(_QWORD *)&v159)
LABEL_198:
                      std::__hash_table<std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,std::__unordered_map_hasher<SIUnicodeString,std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,HashFunction,HashEqual,true>,std::__unordered_map_equal<SIUnicodeString,std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,HashEqual,HashFunction,true>,std::allocator<std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>>>::__do_rehash<true>(v140, prime);
                  }
                  v61 = *(_QWORD *)(v140 + 8);
                  if ((v61 & (v61 - 1)) != 0)
                  {
                    if (v61 <= v142)
                      v143 = v142 % v61;
                    else
                      v143 = v142;
                  }
                  else
                  {
                    v143 = ((_DWORD)v61 - 1) & v142;
                  }
                }
                v163 = *(_QWORD *)v140;
                v164 = *(_QWORD **)(*(_QWORD *)v140 + 8 * v143);
                v148 = v209;
                if (v164)
                {
                  *(_QWORD *)v145 = *v164;
                  v147 = v212;
                  goto LABEL_222;
                }
                *(_QWORD *)v145 = *(_QWORD *)(v140 + 16);
                *(_QWORD *)(v140 + 16) = v145;
                *(_QWORD *)(v163 + 8 * v143) = v140 + 16;
                v147 = v212;
                if (*(_QWORD *)v145)
                {
                  v165 = *(_QWORD *)(*(_QWORD *)v145 + 8);
                  if ((v61 & (v61 - 1)) != 0)
                  {
                    if (v165 >= v61)
                      v165 %= v61;
                  }
                  else
                  {
                    v165 &= v61 - 1;
                  }
                  v164 = (_QWORD *)(*(_QWORD *)v140 + 8 * v165);
LABEL_222:
                  *v164 = v145;
                }
                ++*(_QWORD *)(v140 + 24);
LABEL_224:
                v166 = *((_QWORD *)v145 + 4);
                *(_DWORD *)(v166 + 116) = *(_DWORD *)(v166 + 116) & 0xFF800000 | (*(_DWORD *)(v166 + 116) + 1) & 0x7FFFFF;
                v167 = v210;
                v168 = v214;
                v169 = v216;
                if (*((_BYTE *)v210 + 69))
                {
                  v170 = *((float *)v210 + 15);
                  v171 = *(float *)(v166 + 60);
                  v172 = v170 == v171;
                  v173 = v207;
                  if (v170 < v171)
                    goto LABEL_236;
                }
                else
                {
                  v173 = v207;
                  if ((unsigned __int128)*v210 < *(_OWORD *)v166)
                    goto LABEL_236;
                  v172 = *((_QWORD *)v210 + 1) == *(_QWORD *)(v166 + 8) && *(_QWORD *)v210 == *(_QWORD *)v166;
                }
                v174 = (float64x2_t *)v210;
                if (v172)
                {
                  v175 = *((float *)v210 + 13);
                  v176 = *(float *)(v166 + 52);
                  if (v175 < v176
                    || (v174 = (float64x2_t *)v210, v175 == v176)
                    && (v174 = (float64x2_t *)v210, *((_DWORD *)v210 + 12) > *(_DWORD *)(v166 + 48)))
                  {
LABEL_236:
                    v174 = (float64x2_t *)v166;
                  }
                }
                *(float64x2_t *)v166 = *v174;
                v177 = v174[1];
                v178 = v174[2];
                v179 = v174[4];
                *(float64x2_t *)(v166 + 48) = v174[3];
                *(float64x2_t *)(v166 + 64) = v179;
                *(float64x2_t *)(v166 + 16) = v177;
                *(float64x2_t *)(v166 + 32) = v178;
                *(_QWORD *)&v178.f64[0] = v220.n128_u64[0];
                *(_QWORD *)&v178.f64[1] = v221.n128_u64[0];
                *(float64x2_t *)(v166 + 80) = vminnmq_f64(*(float64x2_t *)(v166 + 80), v178);
                pErrorCode[0] = v148;
                v180 = v167[3];
                v238 = v167[2];
                v239 = v180;
                v240 = v167[4];
                v181 = v167[1];
                v236 = *v167;
                v237 = v181;
                std::__hash_table<std::__hash_value_type<unsigned int,ci_rankingbits_wrapped_s>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,ci_rankingbits_wrapped_s>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,ci_rankingbits_wrapped_s>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,ci_rankingbits_wrapped_s>>>::__emplace_unique_key_args<unsigned int,std::pair<unsigned int,ci_rankingbits_wrapped_s>>(v166 + 120, v148, (uint64_t)pErrorCode);
                v182 = *(unsigned __int16 *)(v166 + 112);
                v183 = v182 << 27 >> 27;
                if (v183 >= v147)
                  LOBYTE(v183) = v147;
                v184 = v182 & 0xFC00 | v183 & 0x1F;
                v185 = v182 << 22 >> 27;
                if (v185 <= v219)
                  LOBYTE(v185) = v219;
                *(_WORD *)(v166 + 112) = v184 & 0xFC1F | (32 * (v185 & 0x1F));
                *(_BYTE *)(v166 + 169) = v173;
                v186 = *(_DWORD *)(v166 + 164);
                if (v186 >= v213)
                  v186 = v213;
                *(_DWORD *)(v166 + 164) = v186;
                v187 = v208;
                v188 = *(_DWORD *)(v166 + 116);
                v189 = (v188 >> 26) & 1;
                if (v173 <= v208)
                  v189 = 1;
                if (v189)
                  v190 = 0x4000000;
                else
                  v190 = 0;
                v191 = v190 | v188 & 0xFBFFFFFF;
                *(_DWORD *)(v166 + 116) = v191;
                v192 = *(_QWORD *)(v166 + 96);
                v193 = v168;
                v194 = v218;
                if (v192)
                {
                  if (v192 != v168)
                  {
                    v193 = -1;
                    goto LABEL_251;
                  }
                }
                else
                {
LABEL_251:
                  *(_QWORD *)(v166 + 96) = v193;
                }
                if ((v217 & 1) != 0 || v169)
                {
                  if (v217)
                    v191 |= 0x1000000u;
                  if (v169)
                    v191 |= 0x800000u;
                  *(_DWORD *)(v166 + 116) = v191;
                }
                v195 = v220;
                v196 = v221;
                if (*(_DWORD *)(v166 + 160) != v215)
                  *(_DWORD *)(v166 + 160) = 0;
                if (v187 + 1 < v194)
                {
                  if (!*(_QWORD *)(v166 + 104))
                  {
                    v197 = operator new();
                    v195 = v220;
                    v196 = v221;
                    *(_OWORD *)v197 = 0u;
                    *(_OWORD *)(v197 + 16) = 0u;
                    *(_DWORD *)(v197 + 32) = 1065353216;
                    *(_QWORD *)(v166 + 104) = v197;
                  }
                  v198 = v210[3];
                  v227 = v210[2];
                  v228 = v198;
                  v229 = v210[4];
                  v199 = v210[1];
                  v225 = *v210;
                  v226 = v199;
                  word_trie_s::insert(v195, v196);
                }
                goto LABEL_152;
              }
            }
          }
          else
          {
            if (v72 >= v61)
              v72 %= v61;
            if (v72 != v65)
              break;
          }
          v67 = (uint64_t *)*v67;
        }
        while (v67);
      }
    }
  }
LABEL_68:
  LODWORD(v204) = 2 * v26;
  v74 = v60;
  v75 = operator new();
  v76 = v75;
  v77 = v210;
  v78 = v210[3];
  v238 = v210[2];
  v239 = v78;
  v240 = v210[4];
  v79 = v240;
  v80 = v210[1];
  v236 = *v210;
  v81 = v236;
  v237 = v80;
  v82 = v208;
  v83 = *(unsigned __int8 *)(v211 + 16 * v208 + 12);
  *(_OWORD *)(v75 + 32) = v238;
  *(_OWORD *)(v75 + 48) = v78;
  *(_OWORD *)(v75 + 64) = v79;
  *(_OWORD *)v75 = v81;
  *(_OWORD *)(v75 + 16) = v80;
  v84 = v221.n128_u64[0];
  *(_QWORD *)(v75 + 80) = v220.n128_u64[0];
  *(_QWORD *)(v75 + 88) = v84;
  *(_QWORD *)(v75 + 96) = v214;
  *(_QWORD *)(v75 + 104) = 0;
  *(_WORD *)(v75 + 112) = v212 & 0x1F | (32 * (v219 & 0x1F)) | *(_WORD *)(v75 + 112) & 0xFC00;
  if (v217)
    v85 = 0x1000000;
  else
    v85 = 0;
  if (v216)
    v86 = 8388609;
  else
    v86 = 1;
  *(_DWORD *)(v75 + 116) = v85 | v86 | (v83 << 25) | *(_DWORD *)(v75 + 116) & 0xF4000000;
  *(_OWORD *)(v75 + 136) = 0u;
  *(_OWORD *)(v75 + 120) = 0u;
  *(_DWORD *)(v75 + 152) = 1065353216;
  v87 = v213;
  *(_DWORD *)(v75 + 160) = v215;
  *(_DWORD *)(v75 + 164) = v87;
  *(_BYTE *)(v75 + 168) = v74;
  v88 = v207;
  *(_BYTE *)(v75 + 169) = v207;
  pErrorCode[0] = v209;
  std::__hash_table<std::__hash_value_type<unsigned int,ci_rankingbits_wrapped_s>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,ci_rankingbits_wrapped_s>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,ci_rankingbits_wrapped_s>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,ci_rankingbits_wrapped_s>>>::__emplace_unique_key_args<unsigned int,std::pair<unsigned int,ci_rankingbits_wrapped_s>>(v75 + 120, v209, (uint64_t)pErrorCode);
  *(_DWORD *)(v76 + 116) = *(_DWORD *)(v76 + 116) & 0xFBFFFFFF | ((v88 <= v82) << 26);
  if (v82 + 1 < v218)
  {
    v89 = operator new();
    *(_OWORD *)v89 = 0u;
    *(_OWORD *)(v89 + 16) = 0u;
    *(_DWORD *)(v89 + 32) = 1065353216;
    *(_QWORD *)(v76 + 104) = v89;
    v90 = v77[3];
    v232 = v77[2];
    v233 = v90;
    v234 = v77[4];
    v91 = v77[1];
    v230 = *v77;
    v231 = v91;
    word_trie_s::insert(v220, v221);
  }
  if (v206 < 7)
  {
    v92 = v204;
    v93 = 1713515327;
    v94 = 1107688271;
    if ((v26 & 1) == 0)
      goto LABEL_84;
LABEL_83:
    HIDWORD(v100) = *v48 * v93;
    LODWORD(v100) = HIDWORD(v100);
    v101 = (v100 >> 21) * v94;
    HIDWORD(v100) = v44;
    LODWORD(v100) = v44;
    v44 = v101 ^ (5 * (v100 >> 19) + 1390208809);
    goto LABEL_84;
  }
  v95 = -1789642873;
  v96 = 718793509;
  v92 = v204;
  v97 = -v203;
  do
  {
    v95 = 5 * v95 + 2071795100;
    v96 = 5 * v96 + 1808688022;
    HIDWORD(v98) = v95 * *(_DWORD *)&v48[2 * v97];
    LODWORD(v98) = HIDWORD(v98);
    v99 = (v98 >> 21) * v96;
    HIDWORD(v98) = v44;
    LODWORD(v98) = v44;
    v44 = v99 ^ (5 * (v98 >> 19) + 1390208809);
    v57 = __CFADD__(v97++, 1);
  }
  while (!v57);
  v93 = 5 * v95 + 2071795100;
  v94 = 5 * v96 + 1808688022;
  if ((v26 & 1) != 0)
    goto LABEL_83;
LABEL_84:
  v102 = -1028477387 * ((-2048144789 * (v44 ^ v92)) ^ ((-2048144789 * (v44 ^ v92)) >> 13));
  v103 = v102 ^ HIWORD(v102);
  v104 = (uint64_t)v223;
  v105 = v223[1];
  if (!v105)
  {
    v107 = 0;
    goto LABEL_114;
  }
  v106 = (uint8x8_t)vcnt_s8((int8x8_t)v105);
  v106.i16[0] = vaddlv_u8(v106);
  if (v106.u32[0] > 1uLL)
  {
    v107 = v102 ^ HIWORD(v102);
    if (v105 <= v103)
      v107 = v103 % v105;
  }
  else
  {
    v107 = ((_DWORD)v105 - 1) & v103;
  }
  v108 = *(uint64_t ***)(*v223 + 8 * v107);
  if (!v108 || (v109 = *v108) == 0)
  {
LABEL_114:
    v116 = operator new(0x28uLL);
    v116[1] = v103;
    *((_DWORD *)v116 + 6) = v26;
    v117 = v224;
    v118 = malloc_type_malloc(v224, 0x1000040BDFB0063uLL);
    v116[2] = v118;
    memcpy(v118, v24, v117);
    v116[4] = v76;
    v119 = (float)(unint64_t)(*(_QWORD *)(v104 + 24) + 1);
    v120 = *(float *)(v104 + 32);
    if (!v105 || (float)(v120 * (float)v105) < v119)
    {
      v121 = 1;
      if (v105 >= 3)
        v121 = (v105 & (v105 - 1)) != 0;
      v122 = v121 | (2 * v105);
      v123 = vcvtps_u32_f32(v119 / v120);
      if (v122 <= v123)
        v124 = v123;
      else
        v124 = v122;
      if (v124 == 1)
      {
        v124 = 2;
      }
      else if ((v124 & (v124 - 1)) != 0)
      {
        v124 = std::__next_prime(v124);
      }
      v125 = *(int8x8_t *)(v104 + 8);
      if (v124 > *(_QWORD *)&v125)
        goto LABEL_126;
      if (v124 < *(_QWORD *)&v125)
      {
        v126 = vcvtps_u32_f32((float)*(unint64_t *)(v104 + 24) / *(float *)(v104 + 32));
        if (*(_QWORD *)&v125 < 3uLL
          || (v127 = (uint8x8_t)vcnt_s8(v125), v127.i16[0] = vaddlv_u8(v127), v127.u32[0] > 1uLL))
        {
          v126 = std::__next_prime(v126);
        }
        else
        {
          v128 = 1 << -(char)__clz(v126 - 1);
          if (v126 >= 2)
            v126 = v128;
        }
        if (v124 <= v126)
          v124 = v126;
        if (v124 < *(_QWORD *)&v125)
LABEL_126:
          std::__hash_table<std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,std::__unordered_map_hasher<SIUnicodeString,std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,HashFunction,HashEqual,true>,std::__unordered_map_equal<SIUnicodeString,std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,HashEqual,HashFunction,true>,std::allocator<std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>>>::__do_rehash<true>(v104, v124);
      }
      v105 = *(_QWORD *)(v104 + 8);
      if ((v105 & (v105 - 1)) != 0)
      {
        if (v105 <= v103)
          v107 = v103 % v105;
        else
          v107 = v103;
      }
      else
      {
        v107 = ((_DWORD)v105 - 1) & v103;
      }
    }
    v129 = *(_QWORD *)v104;
    v130 = *(_QWORD **)(*(_QWORD *)v104 + 8 * v107);
    if (v130)
    {
      *v116 = *v130;
    }
    else
    {
      v131 = *(_QWORD *)(v104 + 16);
      *v116 = v131;
      *(_QWORD *)(v104 + 16) = v116;
      *(_QWORD *)(v129 + 8 * v107) = v104 + 16;
      if (!v131)
      {
LABEL_151:
        ++*(_QWORD *)(v104 + 24);
        goto LABEL_152;
      }
      v132 = *(_QWORD *)(v131 + 8);
      if ((v105 & (v105 - 1)) != 0)
      {
        if (v132 >= v105)
          v132 %= v105;
      }
      else
      {
        v132 &= v105 - 1;
      }
      v130 = (_QWORD *)(*(_QWORD *)v104 + 8 * v132);
    }
    *v130 = v116;
    goto LABEL_151;
  }
  if (v106.u32[0] < 2uLL)
  {
    while (1)
    {
      v111 = v109[1];
      if (v111 == v103)
      {
        if (*((_DWORD *)v109 + 6) == v26 && !memcmp((const void *)v109[2], v24, v224))
          goto LABEL_107;
      }
      else if ((v111 & (v105 - 1)) != v107)
      {
        goto LABEL_114;
      }
      v109 = (uint64_t *)*v109;
      if (!v109)
        goto LABEL_114;
    }
  }
  while (1)
  {
    v110 = v109[1];
    if (v110 == v103)
      break;
    if (v110 >= v105)
      v110 %= v105;
    if (v110 != v107)
      goto LABEL_114;
LABEL_95:
    v109 = (uint64_t *)*v109;
    if (!v109)
      goto LABEL_114;
  }
  if (*((_DWORD *)v109 + 6) != v26 || memcmp((const void *)v109[2], v24, v224))
    goto LABEL_95;
LABEL_107:
  v112 = *(word_trie_s **)(v76 + 104);
  if (v112)
  {
    word_trie_s::~word_trie_s(v112);
    MEMORY[0x1BCCB06A4]();
  }
  v113 = *(_QWORD **)(v76 + 136);
  if (v113)
  {
    do
    {
      v114 = (_QWORD *)*v113;
      operator delete(v113);
      v113 = v114;
    }
    while (v114);
  }
  v115 = *(void **)(v76 + 120);
  *(_QWORD *)(v76 + 120) = 0;
  if (v115)
    operator delete(v115);
  MEMORY[0x1BCCB06A4](v76, 0x10A0C4077AE0019);
LABEL_152:
  if (v24)
    free(v24);
}

void std::__hash_table<std::__hash_value_type<unsigned int,ci_rankingbits_wrapped_s>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,ci_rankingbits_wrapped_s>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,ci_rankingbits_wrapped_s>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,ci_rankingbits_wrapped_s>>>::__emplace_unique_key_args<unsigned int,std::pair<unsigned int,ci_rankingbits_wrapped_s>>(uint64_t a1, unsigned int a2, uint64_t a3)
{
  unint64_t v5;
  unint64_t v6;
  uint8x8_t v7;
  unint64_t v8;
  uint64_t **v9;
  uint64_t *v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  __int128 v14;
  __int128 v15;
  float v16;
  float v17;
  _BOOL8 v18;
  unint64_t v19;
  unint64_t v20;
  size_t prime;
  unint64_t v22;
  uint8x8_t v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  unint64_t v28;

  v5 = a2;
  v6 = *(_QWORD *)(a1 + 8);
  if (v6)
  {
    v7 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      v8 = a2;
      if (v6 <= a2)
        v8 = a2 % v6;
    }
    else
    {
      v8 = ((_DWORD)v6 - 1) & a2;
    }
    v9 = *(uint64_t ***)(*(_QWORD *)a1 + 8 * v8);
    if (v9)
    {
      v10 = *v9;
      if (v10)
      {
        if (v7.u32[0] < 2uLL)
        {
          while (1)
          {
            v12 = v10[1];
            if (v12 == a2)
            {
              if (*((_DWORD *)v10 + 4) == a2)
                return;
            }
            else if ((v12 & (v6 - 1)) != v8)
            {
              goto LABEL_22;
            }
            v10 = (uint64_t *)*v10;
            if (!v10)
              goto LABEL_22;
          }
        }
        do
        {
          v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2)
              return;
          }
          else
          {
            if (v11 >= v6)
              v11 %= v6;
            if (v11 != v8)
              break;
          }
          v10 = (uint64_t *)*v10;
        }
        while (v10);
      }
    }
  }
  else
  {
    v8 = 0;
  }
LABEL_22:
  v13 = operator new(0x70uLL);
  v13[1] = v5;
  *((_DWORD *)v13 + 4) = *(_DWORD *)a3;
  v14 = *(_OWORD *)(a3 + 64);
  *((_OWORD *)v13 + 4) = *(_OWORD *)(a3 + 48);
  *((_OWORD *)v13 + 5) = v14;
  *((_OWORD *)v13 + 6) = *(_OWORD *)(a3 + 80);
  v15 = *(_OWORD *)(a3 + 32);
  *((_OWORD *)v13 + 2) = *(_OWORD *)(a3 + 16);
  *((_OWORD *)v13 + 3) = v15;
  v16 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v17 = *(float *)(a1 + 32);
  if (!v6 || (float)(v17 * (float)v6) < v16)
  {
    v18 = 1;
    if (v6 >= 3)
      v18 = (v6 & (v6 - 1)) != 0;
    v19 = v18 | (2 * v6);
    v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20)
      prime = v20;
    else
      prime = v19;
    if (prime == 1)
    {
      prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      prime = std::__next_prime(prime);
      v6 = *(_QWORD *)(a1 + 8);
    }
    if (prime > v6)
      goto LABEL_44;
    if (prime < v6)
    {
      v22 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v6 < 3 || (v23 = (uint8x8_t)vcnt_s8((int8x8_t)v6), v23.i16[0] = vaddlv_u8(v23), v23.u32[0] > 1uLL))
      {
        v22 = std::__next_prime(v22);
      }
      else
      {
        v24 = 1 << -(char)__clz(v22 - 1);
        if (v22 >= 2)
          v22 = v24;
      }
      if (prime <= v22)
        prime = v22;
      if (prime < v6)
LABEL_44:
        std::__hash_table<std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,std::__unordered_map_hasher<SIUnicodeString,std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,HashFunction,HashEqual,true>,std::__unordered_map_equal<SIUnicodeString,std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,HashEqual,HashFunction,true>,std::allocator<std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>>>::__do_rehash<true>(a1, prime);
    }
    v6 = *(_QWORD *)(a1 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v6 <= v5)
        v8 = v5 % v6;
      else
        v8 = v5;
    }
    else
    {
      v8 = ((_DWORD)v6 - 1) & v5;
    }
  }
  v25 = *(_QWORD *)a1;
  v26 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v8);
  if (v26)
  {
    *v13 = *v26;
LABEL_58:
    *v26 = v13;
    goto LABEL_59;
  }
  v27 = *(_QWORD *)(a1 + 16);
  *v13 = v27;
  *(_QWORD *)(a1 + 16) = v13;
  *(_QWORD *)(v25 + 8 * v8) = a1 + 16;
  if (v27)
  {
    v28 = *(_QWORD *)(v27 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v28 >= v6)
        v28 %= v6;
    }
    else
    {
      v28 &= v6 - 1;
    }
    v26 = (_QWORD *)(*(_QWORD *)a1 + 8 * v28);
    goto LABEL_58;
  }
LABEL_59:
  ++*(_QWORD *)(a1 + 24);
}

void std::__hash_table<std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,std::__unordered_map_hasher<SIUnicodeString,std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,HashFunction,HashEqual,true>,std::__unordered_map_equal<SIUnicodeString,std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,HashEqual,HashFunction,true>,std::allocator<std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>>>::__do_rehash<true>(uint64_t a1, unint64_t a2)
{
  void *v4;
  void *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  _QWORD *v16;
  uint64_t v17;
  unint64_t v18;

  if (!a2)
  {
    v15 = *(void **)a1;
    *(_QWORD *)a1 = 0;
    if (v15)
      operator delete(v15);
    *(_QWORD *)(a1 + 8) = 0;
    return;
  }
  if (a2 >> 61)
    std::__throw_bad_array_new_length[abi:nn180100]();
  v4 = operator new(8 * a2);
  v5 = *(void **)a1;
  *(_QWORD *)a1 = v4;
  if (v5)
    operator delete(v5);
  v6 = 0;
  *(_QWORD *)(a1 + 8) = a2;
  do
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v6++) = 0;
  while (a2 != v6);
  v8 = a1 + 16;
  v7 = *(_QWORD **)(a1 + 16);
  if (v7)
  {
    v9 = v7[1];
    v10 = a2 - 1;
    if ((a2 & (a2 - 1)) == 0)
    {
      v11 = v9 & v10;
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v11) = v8;
      while (1)
      {
        v12 = (_QWORD *)*v7;
        if (!*v7)
          break;
        v13 = v12[1] & v10;
        if (v13 == v11)
        {
          v7 = (_QWORD *)*v7;
        }
        else if (*(_QWORD *)(*(_QWORD *)a1 + 8 * v13))
        {
          *v7 = *v12;
          v14 = 8 * v13;
          *v12 = **(_QWORD **)(*(_QWORD *)a1 + v14);
          **(_QWORD **)(*(_QWORD *)a1 + v14) = v12;
        }
        else
        {
          *(_QWORD *)(*(_QWORD *)a1 + 8 * v13) = v7;
          v7 = v12;
          v11 = v13;
        }
      }
      return;
    }
    if (v9 >= a2)
      v9 %= a2;
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v9) = v8;
    v16 = (_QWORD *)*v7;
    if (*v7)
    {
      do
      {
        v18 = v16[1];
        if (v18 >= a2)
          v18 %= a2;
        if (v18 != v9)
        {
          if (!*(_QWORD *)(*(_QWORD *)a1 + 8 * v18))
          {
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v18) = v7;
            goto LABEL_26;
          }
          *v7 = *v16;
          v17 = 8 * v18;
          *v16 = **(_QWORD **)(*(_QWORD *)a1 + v17);
          **(_QWORD **)(*(_QWORD *)a1 + v17) = v16;
          v16 = v7;
        }
        v18 = v9;
LABEL_26:
        v7 = v16;
        v16 = (_QWORD *)*v16;
        v9 = v18;
      }
      while (v16);
    }
  }
}

double word_trie_s::iterateFragments(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, __int128 *a5, uint64_t a6, unsigned int a7, unsigned int a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;
  uint64_t **v12;
  __int128 *v13;
  double v14;
  __int128 *v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  double v19;
  double v20;
  int v21;
  int v22;
  int v23;
  int v24;
  size_t prime;
  int8x8_t v26;
  BOOL v27;
  unint64_t v28;
  uint8x8_t v29;
  uint64_t v30;
  uint64_t *v31;
  unint64_t v32;
  unint64_t v33;
  uint8x8_t v34;
  unint64_t v35;
  uint64_t **v36;
  uint64_t *v37;
  unint64_t v38;
  uint64_t v39;
  _QWORD *v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  float v44;
  _BOOL8 v45;
  unint64_t v46;
  unint64_t v47;
  size_t v48;
  unint64_t v49;
  uint8x8_t v50;
  uint64_t v51;
  uint64_t v52;
  _QWORD *v53;
  unint64_t v54;
  unsigned int v55;
  uint64_t v56;
  __int128 v57;
  uint64_t v58;
  unint64_t v59;
  int v60;
  NSObject *v61;
  uint64_t v62;
  uint64_t v63;
  unint64_t v64;
  uint64_t v65;
  uint64_t v66;
  __int128 v67;
  _QWORD *v68;
  int v69;
  char v70;
  int v71;
  unint64_t v72;
  int v73;
  unsigned int v74;
  unsigned int v75;
  uint64_t v76;
  double (*v77)(uint64_t, uint64_t, unint64_t, uint64_t, _OWORD *, uint64_t, uint64_t, double, double, double);
  uint64_t v78;
  uint64_t v79;
  int v80;
  uint64_t v81;
  unsigned int v82;
  unsigned int v83;
  double (*v84)(uint64_t, uint64_t, unint64_t, uint64_t, _OWORD *, uint64_t, uint64_t, double, double, double);
  uint64_t v85;
  int v86;
  NSObject *v87;
  _QWORD *v88;
  void *v89;
  uint64_t v91;
  uint64_t v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  uint64_t v96;
  unsigned int v97;
  __int128 v98;
  __int128 *v99;
  unsigned int v100;
  unsigned int v101;
  int v102;
  uint64_t v103;
  unsigned int v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  __int128 *v108;
  int v109;
  _QWORD *v110;
  _QWORD *v111;
  unsigned int v112;
  unint64_t v113;
  uint64_t v114;
  int v115;
  unint64_t v116;
  int v117;
  int v118;
  int v119;
  int v120;
  int v121;
  _OWORD v122[5];
  _OWORD v123[5];
  _OWORD v124[5];
  _OWORD v125[5];
  __int128 v126;
  __int128 v127;
  uint64_t v128;
  __int128 v129;
  __int128 v130;
  __int128 v131;
  __int128 v132;
  __int128 v133;
  uint8_t buf[4];
  unint64_t v135;
  uint64_t v136;

  v112 = a8;
  v104 = a7;
  v108 = a5;
  v103 = a4;
  v136 = *MEMORY[0x1E0C80C00];
  v113 = a3;
  if (a3 <= 0x13)
  {
    v8 = MEMORY[0x1E0C80A78](a1);
    v96 = 0;
    *((_QWORD *)&v11 + 1) = 0;
    v94 = 0u;
    v95 = 0u;
    v93 = 0u;
    v12 = *(uint64_t ***)(v8 + 16);
    if (v12)
    {
      v106 = v9;
      v107 = v10;
      v111 = (_QWORD *)(v9 + 16 * v113);
      v110 = v111 + 1;
      v116 = v113 + 1;
      v105 = v103 + 1;
      v13 = &v127;
      v14 = -1.79769313e308;
      *(_QWORD *)&v11 = 134217984;
      v98 = v11;
      v99 = &v127;
      while (1)
      {
        v15 = (__int128 *)v12[4];
        v121 = *((_DWORD *)v15 + 29);
        v16 = v15[3];
        v131 = v15[2];
        v132 = v16;
        v133 = v15[4];
        v17 = v15[1];
        v129 = *v15;
        v130 = v17;
        v18 = *((_QWORD *)v15 + 12);
        v19 = *((double *)v15 + 10);
        v20 = *((double *)v15 + 11);
        v115 = *((unsigned __int16 *)v15 + 56);
        v21 = *((unsigned __int8 *)v15 + 168);
        v22 = *((unsigned __int8 *)v15 + 169);
        v24 = *((_DWORD *)v15 + 40);
        v23 = *((_DWORD *)v15 + 41);
        v128 = 0;
        v126 = 0u;
        v127 = 0u;
        LODWORD(v128) = *((_DWORD *)v15 + 38);
        prime = *((_QWORD *)v15 + 16);
        v114 = v18;
        v119 = v23;
        v120 = v21;
        v117 = v24;
        v118 = v22;
        if (prime == 1)
          break;
        if ((prime & (prime - 1)) != 0)
        {
          prime = std::__next_prime(prime);
          v26 = *(int8x8_t *)((char *)&v126 + 8);
          v27 = prime >= *((_QWORD *)&v126 + 1);
          if (prime > *((_QWORD *)&v126 + 1))
            goto LABEL_21;
        }
        else
        {
          v26 = 0;
          v27 = 1;
          if (prime)
            goto LABEL_21;
        }
        if (!v27)
        {
          v28 = vcvtps_u32_f32((float)*((unint64_t *)&v127 + 1) / *(float *)&v128);
          if (*(_QWORD *)&v26 < 3uLL || (v29 = (uint8x8_t)vcnt_s8(v26), v29.i16[0] = vaddlv_u8(v29), v29.u32[0] > 1uLL))
          {
            v28 = std::__next_prime(v28);
          }
          else
          {
            v30 = 1 << -(char)__clz(v28 - 1);
            if (v28 >= 2)
              v28 = v30;
          }
          if (prime <= v28)
            prime = v28;
          if (prime < *(_QWORD *)&v26)
            goto LABEL_21;
        }
LABEL_22:
        v31 = (uint64_t *)*((_QWORD *)v15 + 17);
        if (v31)
        {
          v32 = *((_QWORD *)&v126 + 1);
          do
          {
            v33 = *((unsigned int *)v31 + 4);
            if (v32)
            {
              v34 = (uint8x8_t)vcnt_s8((int8x8_t)v32);
              v34.i16[0] = vaddlv_u8(v34);
              if (v34.u32[0] > 1uLL)
              {
                v35 = *((unsigned int *)v31 + 4);
                if (v32 <= v33)
                  v35 = v33 % v32;
              }
              else
              {
                v35 = ((_DWORD)v32 - 1) & v33;
              }
              v36 = *(uint64_t ***)(v126 + 8 * v35);
              if (v36)
              {
                v37 = *v36;
                if (v37)
                {
                  if (v34.u32[0] < 2uLL)
                  {
                    while (1)
                    {
                      v39 = v37[1];
                      if (v39 == v33)
                      {
                        if (*((_DWORD *)v37 + 4) == (_DWORD)v33)
                          goto LABEL_83;
                      }
                      else if ((v39 & (v32 - 1)) != v35)
                      {
                        goto LABEL_45;
                      }
                      v37 = (uint64_t *)*v37;
                      if (!v37)
                        goto LABEL_45;
                    }
                  }
                  do
                  {
                    v38 = v37[1];
                    if (v38 == v33)
                    {
                      if (*((_DWORD *)v37 + 4) == (_DWORD)v33)
                        goto LABEL_83;
                    }
                    else
                    {
                      if (v38 >= v32)
                        v38 %= v32;
                      if (v38 != v35)
                        break;
                    }
                    v37 = (uint64_t *)*v37;
                  }
                  while (v37);
                }
              }
            }
            else
            {
              v35 = 0;
            }
LABEL_45:
            v40 = operator new(0x70uLL);
            *v40 = 0;
            v40[1] = v33;
            *((_DWORD *)v40 + 4) = *((_DWORD *)v31 + 4);
            *((_OWORD *)v40 + 2) = *((_OWORD *)v31 + 2);
            v41 = *((_OWORD *)v31 + 6);
            v43 = *((_OWORD *)v31 + 3);
            v42 = *((_OWORD *)v31 + 4);
            *((_OWORD *)v40 + 5) = *((_OWORD *)v31 + 5);
            *((_OWORD *)v40 + 6) = v41;
            *((_OWORD *)v40 + 3) = v43;
            *((_OWORD *)v40 + 4) = v42;
            v44 = (float)(unint64_t)(*((_QWORD *)&v127 + 1) + 1);
            if (!v32 || (float)(*(float *)&v128 * (float)v32) < v44)
            {
              v45 = (v32 & (v32 - 1)) != 0;
              if (v32 < 3)
                v45 = 1;
              v46 = v45 | (2 * v32);
              v47 = vcvtps_u32_f32(v44 / *(float *)&v128);
              if (v46 <= v47)
                v48 = v47;
              else
                v48 = v46;
              if (v48 == 1)
              {
                v48 = 2;
              }
              else if ((v48 & (v48 - 1)) != 0)
              {
                v48 = std::__next_prime(v48);
                v32 = *((_QWORD *)&v126 + 1);
              }
              if (v48 > v32)
                goto LABEL_57;
              if (v48 < v32)
              {
                v49 = vcvtps_u32_f32((float)*((unint64_t *)&v127 + 1) / *(float *)&v128);
                if (v32 < 3
                  || (v50 = (uint8x8_t)vcnt_s8((int8x8_t)v32), v50.i16[0] = vaddlv_u8(v50), v50.u32[0] > 1uLL))
                {
                  v49 = std::__next_prime(v49);
                }
                else
                {
                  v51 = 1 << -(char)__clz(v49 - 1);
                  if (v49 >= 2)
                    v49 = v51;
                }
                if (v48 <= v49)
                  v48 = v49;
                if (v48 < v32)
LABEL_57:
                  std::__hash_table<std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,std::__unordered_map_hasher<SIUnicodeString,std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,HashFunction,HashEqual,true>,std::__unordered_map_equal<SIUnicodeString,std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,HashEqual,HashFunction,true>,std::allocator<std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>>>::__do_rehash<true>((uint64_t)&v126, v48);
              }
              v32 = *((_QWORD *)&v126 + 1);
              if ((v32 & (v32 - 1)) != 0)
              {
                if (*((_QWORD *)&v126 + 1) <= v33)
                  v35 = v33 % *((_QWORD *)&v126 + 1);
                else
                  v35 = v33;
              }
              else
              {
                v35 = (DWORD2(v126) - 1) & v33;
              }
            }
            v52 = v126;
            v53 = *(_QWORD **)(v126 + 8 * v35);
            if (v53)
            {
              *v40 = *v53;
            }
            else
            {
              *v40 = v127;
              *(_QWORD *)&v127 = v40;
              *(_QWORD *)(v52 + 8 * v35) = v13;
              if (!*v40)
                goto LABEL_82;
              v54 = *(_QWORD *)(*v40 + 8);
              if ((v32 & (v32 - 1)) != 0)
              {
                if (v54 >= v32)
                  v54 %= v32;
              }
              else
              {
                v54 &= v32 - 1;
              }
              v53 = (_QWORD *)(v126 + 8 * v54);
            }
            *v53 = v40;
LABEL_82:
            ++*((_QWORD *)&v127 + 1);
LABEL_83:
            v31 = (uint64_t *)*v31;
          }
          while (v31);
        }
        v55 = v121;
        v56 = (v121 << 9 >> 9);
        *v111 = v12[2];
        *v110 = *((unsigned int *)v12 + 6);
        if ((*((_BYTE *)v15 + 119) & 2) != 0)
        {
          v66 = *((_QWORD *)v15 + 13);
          if (v66)
          {
            v67 = v108[1];
            v93 = *v108;
            v94 = v67;
            v95 = v108[2];
            v96 = *((_QWORD *)v108 + 6);
            v14 = fmax(v14, word_trie_s::iterateFragments(v66, v106, v116, v103, &v93, v107, ((int)(v55 << 9) >> 9)));
            v68 = (_QWORD *)v127;
            if ((_QWORD)v127)
              goto LABEL_117;
            goto LABEL_118;
          }
        }
        else
        {
          v57 = v108[1];
          v93 = *v108;
          v94 = v57;
          v95 = v108[2];
          v96 = *((_QWORD *)v108 + 6);
          v58 = *((_QWORD *)v15 + 13);
          v59 = v116;
          v109 = v115 << 27 >> 27;
          v115 = v115 << 22 >> 27;
          if (v58)
          {
            if ((v55 & 0x4000000) != 0)
            {
              v125[2] = v131;
              v125[3] = v132;
              v125[4] = v133;
              v125[0] = v129;
              v125[1] = v130;
              if (v113)
                v82 = v104;
              else
                v82 = v56;
              if (v113)
                v83 = v112;
              else
                v83 = v56;
              v62 = v107;
              v84 = *(double (**)(uint64_t, uint64_t, unint64_t, uint64_t, _OWORD *, uint64_t, uint64_t, double, double, double))(v107 + 16);
              v102 = HIBYTE(v55) & 1;
              v101 = (v55 >> 23) & 1;
              v97 = v83;
              v65 = v105;
              v63 = v106;
              v64 = v116;
              v100 = v82;
              if (v84(v107, v106, v116, v105, v125, v114, v56, v19, v20, 1.79769313e308) > v14)
              {
                v124[2] = v131;
                v124[3] = v132;
                v124[4] = v133;
                v124[0] = v129;
                v124[1] = v130;
                BYTE5(v92) = v118;
                BYTE4(v92) = v120;
                LODWORD(v92) = v119;
                BYTE6(v91) = v102;
                BYTE5(v91) = v101;
                BYTE4(v91) = v117 != 0;
                LODWORD(v91) = v115;
                v14 = (*(double (**)(uint64_t, uint64_t, unint64_t, uint64_t, _OWORD *, uint64_t, uint64_t, _QWORD, double, double, double, unint64_t, uint64_t, uint64_t, __int128 *, __int128 *))(v62 + 16))(v62, v63, v64, v65, v124, v114, v56, v100, v19, v20, 1.79769313e308, __PAIR64__(v109, v97), v91, v92, &v126, &v93);
              }
            }
            else
            {
              v60 = *__error();
              v61 = _SILogForLogForCategory(1);
              if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = v98;
                v135 = v116;
                _os_log_impl(&dword_1B8270000, v61, OS_LOG_TYPE_DEFAULT, "Skip at %ld", buf, 0xCu);
              }
              *__error() = v60;
              v63 = v106;
              v62 = v107;
              v64 = v116;
              v65 = v105;
            }
            v85 = v63;
            v55 = v121;
            v14 = fmax(v14, word_trie_s::iterateFragments(*((_QWORD *)v15 + 13), v85, v64, v65, &v93, v62, v56));
            v59 = v64;
            v69 = v117;
            v70 = v118;
            if ((v55 & 0x4000000) != 0)
            {
LABEL_94:
              v71 = HIBYTE(v55) & 1;
              v72 = v59;
              v73 = (v55 >> 23) & 1;
              v123[2] = v131;
              v123[3] = v132;
              v123[4] = v133;
              v123[0] = v129;
              v123[1] = v130;
              if (v113)
                v74 = v104;
              else
                v74 = v56;
              if (v113)
                v75 = v112;
              else
                v75 = v56;
              v76 = v107;
              v77 = *(double (**)(uint64_t, uint64_t, unint64_t, uint64_t, _OWORD *, uint64_t, uint64_t, double, double, double))(v107 + 16);
              v121 = v71;
              v102 = v73;
              v100 = v75;
              v79 = v105;
              v78 = v106;
              v80 = v69;
              v81 = v114;
              v101 = v74;
              if (v77(v107, v106, v72, v105, v123, v114, v56, v19, v20, v14) > v14)
              {
                v122[2] = v131;
                v122[3] = v132;
                v122[4] = v133;
                v122[0] = v129;
                v122[1] = v130;
                BYTE5(v92) = v70;
                BYTE4(v92) = v120;
                LODWORD(v92) = v119;
                BYTE6(v91) = v121;
                BYTE5(v91) = v102;
                BYTE4(v91) = v80 != 0;
                LODWORD(v91) = v115;
                v14 = (*(double (**)(uint64_t, uint64_t, unint64_t, uint64_t, _OWORD *, uint64_t, uint64_t, _QWORD, double, double, double, unint64_t, uint64_t, uint64_t, __int128 *, __int128 *))(v76 + 16))(v76, v78, v116, v79, v122, v81, v56, v101, v19, v20, v14, __PAIR64__(v109, v100), v91, v92, &v126, &v93);
              }
              v13 = v99;
              v68 = (_QWORD *)v127;
              if (!(_QWORD)v127)
                goto LABEL_118;
              do
              {
LABEL_117:
                v88 = (_QWORD *)*v68;
                operator delete(v68);
                v68 = v88;
              }
              while (v88);
              goto LABEL_118;
            }
          }
          else
          {
            v69 = v117;
            v70 = v118;
            if ((v55 & 0x4000000) != 0)
              goto LABEL_94;
          }
          v86 = *__error();
          v87 = _SILogForLogForCategory(1);
          if (os_log_type_enabled(v87, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = v98;
            v135 = v59;
            _os_log_impl(&dword_1B8270000, v87, OS_LOG_TYPE_DEFAULT, "Skip at %ld", buf, 0xCu);
          }
          *__error() = v86;
        }
        v68 = (_QWORD *)v127;
        if ((_QWORD)v127)
          goto LABEL_117;
LABEL_118:
        v89 = (void *)v126;
        *(_QWORD *)&v126 = 0;
        if (v89)
          operator delete(v89);
        v12 = (uint64_t **)*v12;
        if (!v12)
          return v14;
      }
      prime = 2;
LABEL_21:
      std::__hash_table<std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,std::__unordered_map_hasher<SIUnicodeString,std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,HashFunction,HashEqual,true>,std::__unordered_map_equal<SIUnicodeString,std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,HashEqual,HashFunction,true>,std::allocator<std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>>>::__do_rehash<true>((uint64_t)&v126, prime);
      goto LABEL_22;
    }
  }
  return -1.79769313e308;
}

_QWORD *ContentIndexQueryNodeForOidPath(const void *a1, uint64_t a2, int a3)
{
  int v4;
  size_t v6;
  size_t v7;
  BOOL v8;
  _QWORD *v9;
  int v10;
  uint8_t v12[16];

  v4 = a2;
  v6 = 8 * a2;
  v7 = 8 * a2 + 104;
  if (v7 >> 17)
    v8 = 1;
  else
    v8 = *MEMORY[0x1E0C85AD8] >= v7;
  if (!v8)
    ++sTotal_4476;
  v9 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, v7, 0x31F9A007uLL);
  if (!v9 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)v12 = 0;
    _os_log_fault_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "allocation function returned null", v12, 2u);
  }
  *(_DWORD *)v9 = 1;
  memcpy(v9 + 13, a1, v6);
  v9[5] = v9 + 13;
  v9[4] = v9 + 5;
  v9[6] = 0;
  if (a3)
    v10 = 512;
  else
    v10 = 1024;
  *((_DWORD *)v9 + 14) = v10;
  *((_DWORD *)v9 + 15) = v4;
  *((_OWORD *)v9 + 4) = 0u;
  *((_OWORD *)v9 + 5) = 0u;
  v9[12] = 0;
  *((_DWORD *)v9 + 6) = 1;
  return v9;
}

void assert_invalid_doc_type(_DWORD *a1)
{
  int v2;
  NSObject *v3;
  int v4;
  char *v5;
  char *v6;
  const char *v7;
  uint8_t buf[4];
  const char *v9;
  __int16 v10;
  int v11;
  __int16 v12;
  _DWORD *v13;
  __int16 v14;
  int v15;

  v2 = *__error();
  v3 = _SILogForLogForCategory(1);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
  {
    v4 = a1[12];
    *(_DWORD *)buf = 136315906;
    v9 = "assert_invalid_doc_type";
    v10 = 1024;
    v11 = 115;
    v12 = 2048;
    v13 = a1;
    v14 = 1024;
    v15 = v4;
    _os_log_error_impl(&dword_1B8270000, v3, OS_LOG_TYPE_ERROR, "%s:%d: Expected valid doc set type for %p. Got %d", buf, 0x22u);
  }
  *__error() = v2;
  v5 = __si_assert_copy_extra_268();
  v6 = v5;
  v7 = "";
  if (v5)
    v7 = v5;
  __message_assert("%s:%u: failed assertion '%s' %s Expected valid doc set type for %p. Got %d", "ContentIndexQuery.c", 116, "0", v7, a1, a1[12]);
  free(v6);
  if (__valid_fs(-1))
  {
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  MEMORY[0xC00] = -559038737;
  abort();
}

uint64_t ContentIndexDocSetContainsDocId(uint64_t a1, int a2)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t result;

  if (a1)
  {
    v2 = 0;
    switch(*(_DWORD *)(a1 + 48))
    {
      case 0:
      case 2:
        return v2;
      case 1:
        return 1;
      case 3:
      case 8:
        v4 = *(_QWORD *)(a1 + 64);
        if (!v4)
          goto LABEL_5;
        v3 = (uint64_t *)(v4 + 88);
LABEL_4:
        v4 = *v3;
LABEL_5:
        result = CIIndexSetHasIndex(v4, a2 - *(_DWORD *)(*(_QWORD *)(a1 + 56) + 72));
        break;
      case 4:
      case 5:
      case 6:
      case 7:
      case 9:
        v3 = (uint64_t *)(a1 + 80);
        goto LABEL_4;
      default:
        assert_invalid_doc_type((_DWORD *)a1);
    }
  }
  else
  {
    return 0;
  }
  return result;
}

uint64_t ContentIndexDocSetNeedsPostcheckForDocId(uint64_t a1, int a2)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t result;

  if (!a1)
    return 0;
  v2 = *(_DWORD *)(a1 + 52);
  if (v2 == 3)
    return 1;
  if (!v2)
    return 0;
  v4 = 0;
  v3 = 0;
  switch(*(_DWORD *)(a1 + 48))
  {
    case 0:
    case 1:
    case 2:
      return v3;
    case 3:
      v4 = *(_QWORD *)(a1 + 64);
      if (!v4)
        goto LABEL_9;
      v5 = (uint64_t *)(v4 + 96);
LABEL_8:
      v4 = *v5;
LABEL_9:
      result = CIIndexSetHasIndex(v4, a2 - *(_DWORD *)(*(_QWORD *)(a1 + 56) + 72));
      break;
    case 4:
    case 5:
    case 6:
    case 7:
      v5 = (uint64_t *)(a1 + 88);
      goto LABEL_8;
    case 8:
    case 9:
      goto LABEL_9;
    default:
      assert_invalid_doc_type((_DWORD *)a1);
  }
  return result;
}

unsigned int *ContentIndexDocSetCreateEmpty(uint64_t a1)
{
  unsigned int *v2;
  uint8_t v4[16];

  if (*MEMORY[0x1E0C85AD8] <= 0x97uLL)
    ++sTotal_4476;
  v2 = (unsigned int *)malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x98uLL, 0x31F9A007uLL);
  if (!v2 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)v4 = 0;
    _os_log_fault_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "allocation function returned null", v4, 2u);
  }
  atomic_store(1u, v2);
  v2[1] = -1073627135;
  *((_QWORD *)v2 + 7) = a1;
  v2[12] = 0;
  *((_QWORD *)v2 + 5) = -1;
  v2[5] = 0;
  return v2;
}

unsigned int *ContentIndexDocSetNotLazy(uint64_t a1, float a2)
{
  int v3;
  float v4;
  uint64_t v5;
  float v6;
  unsigned int *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  void *v11;
  unsigned int v12;
  uint8_t v14[16];
  uint8_t buf[16];
  uint8_t v16[16];
  uint8_t v17[16];

  if (a2 == 0.0)
    a2 = 1.0;
  if (!a1)
    goto LABEL_6;
  v3 = *(_DWORD *)(a1 + 48);
  if (v3 == 1)
  {
    if (*MEMORY[0x1E0C85AD8] <= 0x97uLL)
      ++sTotal_4476;
    v8 = *(_QWORD *)(a1 + 56);
    v6 = *(float *)(a1 + 16);
    v7 = (unsigned int *)malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x98uLL, 0x31F9A007uLL);
    if (!v7 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_fault_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "allocation function returned null", buf, 2u);
    }
    atomic_store(1u, v7);
    v7[1] = -1073627135;
    *((_QWORD *)v7 + 7) = v8;
    v7[12] = 0;
    goto LABEL_18;
  }
  if (!v3)
  {
LABEL_6:
    v4 = *(float *)(a1 + 20) * *(float *)(a1 + 12);
    if (*MEMORY[0x1E0C85AD8] <= 0x97uLL)
      ++sTotal_4476;
    v5 = *(_QWORD *)(a1 + 56);
    v6 = v4 * a2;
    v7 = (unsigned int *)malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x98uLL, 0x31F9A007uLL);
    if (!v7 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)v14 = 0;
      _os_log_fault_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "allocation function returned null", v14, 2u);
    }
    atomic_store(1u, v7);
    v7[1] = -1073627135;
    *((_QWORD *)v7 + 7) = v5;
    v7[12] = 1;
LABEL_18:
    *((_QWORD *)v7 + 5) = -1;
    *((float *)v7 + 5) = v6;
    return v7;
  }
  v9 = (_QWORD *)MEMORY[0x1E0C85AD8];
  if (*MEMORY[0x1E0C85AD8] <= 0x97uLL)
    ++sTotal_4476;
  v10 = *(_QWORD *)(a1 + 56);
  v7 = (unsigned int *)malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x98uLL, 0x31F9A007uLL);
  if (!v7 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)v16 = 0;
    _os_log_fault_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "allocation function returned null", v16, 2u);
  }
  atomic_store(1u, v7);
  v7[1] = -1073627135;
  *((_QWORD *)v7 + 7) = v10;
  v7[12] = 6;
  *((_QWORD *)v7 + 5) = -1;
  v7[13] = *(_DWORD *)(a1 + 52);
  v7[24] = 1;
  if (*v9 <= 7uLL)
    ++sTotal_4476;
  v11 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 8uLL, 0x31F9A007uLL);
  if (!v11 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)v17 = 0;
    _os_log_fault_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "allocation function returned null", v17, 2u);
  }
  *((_QWORD *)v7 + 9) = v11;
  do
    v12 = __ldaxr((unsigned int *)a1);
  while (__stlxr(v12 + 1, (unsigned int *)a1));
  **((_QWORD **)v7 + 9) = a1;
  return v7;
}

uint64_t setShared(uint64_t result)
{
  ++*(_DWORD *)(result + 8);
  return result;
}

uint64_t *extractConstrainingDocSets(int a1, uint64_t *a2, const __CFSet *a3, unsigned int *a4, _BYTE *a5)
{
  uint64_t *v5;
  uint64_t *v6;
  unsigned int v7;
  const __CFAllocator *v8;
  int v9;
  const __CFAllocator *v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  unsigned int v14;
  _OWORD *v15;
  uint64_t *v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  float v24;
  void *v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;
  unsigned int *v29;
  unsigned int v30;
  unint64_t v31;
  unsigned int v32;
  unsigned int *v33;
  unsigned int v34;
  unsigned int *v35;
  const __CFArray *Mutable;
  unsigned int *v37;
  const __CFArray *v38;
  uint64_t v39;
  uint64_t v40;
  unsigned int v41;
  unsigned int *v42;
  uint64_t v43;
  uint64_t *v44;
  uint64_t v45;
  unint64_t v46;
  unsigned int v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t *v51;
  uint64_t *v52;
  unsigned int v53;
  uint64_t v54;
  unsigned int v55;
  uint64_t v56;
  unint64_t v57;
  unsigned int v58;
  unsigned int *v59;
  unsigned int v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t *v63;
  uint64_t v64;
  unsigned int v65;
  unsigned int *v66;
  const __CFArray *v67;
  unsigned int *v68;
  uint64_t v69;
  uint64_t *v70;
  uint64_t v71;
  const __CFArray *v72;
  unsigned int v75;
  unsigned int *v76;
  uint8_t v78[16];
  uint8_t buf[16];
  uint8_t v80[16];

  *a5 = 0;
  if (a2)
  {
    v5 = a2;
    v76 = a4;
    v6 = (uint64_t *)malloc_type_zone_malloc((malloc_zone_t *)queryZone, 8 * a1, 0x6085D6BuLL);
    if (!v6 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)v78 = 0;
      _os_log_fault_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "allocation function returned null", v78, 2u);
    }
    v7 = 0;
    v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v9 = 1;
    do
    {
      v10 = v8;
      v11 = v7;
      v12 = v9;
      v13 = *v5;
      v14 = *((_DWORD *)v5 + 2);
      v15 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 0x98uLL, 0x6085D6BuLL);
      if (!v15 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_fault_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "allocation function returned null", buf, 2u);
      }
      v16 = v6;
      v17 = *(_OWORD *)(v13 + 16);
      *v15 = *(_OWORD *)v13;
      v15[1] = v17;
      v18 = *(_OWORD *)(v13 + 32);
      v19 = *(_OWORD *)(v13 + 48);
      v20 = *(_OWORD *)(v13 + 80);
      v15[4] = *(_OWORD *)(v13 + 64);
      v15[5] = v20;
      v15[2] = v18;
      v15[3] = v19;
      v21 = *(_OWORD *)(v13 + 96);
      v22 = *(_OWORD *)(v13 + 112);
      v23 = *(_OWORD *)(v13 + 128);
      *((_QWORD *)v15 + 18) = *(_QWORD *)(v13 + 144);
      v15[7] = v22;
      v15[8] = v23;
      v15[6] = v21;
      atomic_store(1u, (unsigned int *)v15);
      *((_DWORD *)v15 + 2) = 0;
      *((_QWORD *)v15 + 18) = 0;
      *((_QWORD *)v15 + 13) = 0;
      *((_QWORD *)v15 + 10) = 0;
      *((_QWORD *)v15 + 11) = 0;
      v24 = *(float *)(v13 + 20);
      if (v24 != 0.0)
        *((float *)v15 + 5) = v24;
      *((_QWORD *)v15 + 14) = 0;
      *((_QWORD *)v15 + 15) = 0;
      *((_DWORD *)v15 + 32) &= 0x80000000;
      *((_DWORD *)v15 + 33) = 0;
      *((_QWORD *)v15 + 17) = 0;
      v25 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 8 * *(unsigned int *)(v13 + 96), 0x6085D6BuLL);
      if (!v25 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)v80 = 0;
        _os_log_fault_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "allocation function returned null", v80, 2u);
      }
      *((_QWORD *)v15 + 9) = v25;
      v26 = *(_DWORD *)(v13 + 96);
      if (v26 >= v14)
        v27 = v14;
      else
        v27 = v26;
      if ((_DWORD)v27)
      {
        v28 = 0;
        v8 = v10;
        do
        {
          v29 = *(unsigned int **)(*(_QWORD *)(v13 + 72) + 8 * v28);
          if (v29)
          {
            do
              v30 = __ldaxr(v29);
            while (__stlxr(v30 + 1, v29));
          }
          *(_QWORD *)(*((_QWORD *)v15 + 9) + 8 * v28++) = v29;
        }
        while (v28 != v27);
        v26 = *(_DWORD *)(v13 + 96);
      }
      else
      {
        v8 = v10;
      }
      v31 = (v27 + 1);
      if (v31 < v26)
      {
        v32 = v27;
        do
        {
          v33 = *(unsigned int **)(*(_QWORD *)(v13 + 72) + 8 * v31);
          if (v33)
          {
            do
              v34 = __ldaxr(v33);
            while (__stlxr(v34 + 1, v33));
          }
          *(_QWORD *)(*((_QWORD *)v15 + 9) + 8 * v32) = v33;
          v32 = v31++;
        }
        while (v31 < *(unsigned int *)(v13 + 96));
      }
      --*((_DWORD *)v15 + 24);
      *((_BYTE *)v15 + 64) = 1;
      if (!(_DWORD)v27 && *((_DWORD *)v15 + 12) == 7)
      {
        *((_DWORD *)v15 + 12) = 4;
        v35 = ContentIndexDocSetNotLazy((uint64_t)v15, 0.0);
        ContentIndexDocSetDispose((uint64_t)v15);
        v15 = v35;
      }
      Mutable = CFArrayCreateMutable(v8, 2, 0);
      v37 = _ContentIndexMemoizeDocSet((uint64_t)v15, a3, Mutable);
      CFRelease(Mutable);
      if (!v37[2])
      {
        ContentIndexFlattenDocSet((uint64_t)v37, a3);
        v38 = CFArrayCreateMutable(v8, 2, 0);
        v37 = _ContentIndexMemoizeDocSet((uint64_t)v37, a3, v38);
        CFRelease(v38);
      }
      v7 = v11 + 1;
      v16[v11] = (uint64_t)v37;
      v6 = v16;
      v5 = (uint64_t *)v5[2];
      v9 = v12 + 1;
    }
    while (v5);
    if (v11 == -1)
    {
LABEL_41:
      a4 = v76;
    }
    else
    {
      v39 = 0;
      while (*(_DWORD *)(v16[v39] + 48) != 6)
      {
        if (v12 == ++v39)
          goto LABEL_41;
      }
      qsort_b(v16, v11 + 1, 8uLL, &__block_literal_global_4515);
      v40 = 0;
      v41 = -1;
      while (*(_DWORD *)(v16[v40] + 48) != 6)
      {
        ++v40;
        ++v41;
        if (v11 + 1 == v40)
          goto LABEL_52;
      }
      if ((_DWORD)v40)
      {
        if ((_DWORD)v40 == 1)
        {
          v42 = ContentIndexDocSetExceptLazy_Array(*v16, v11, (uint64_t)(v16 + 1));
          v43 = v12;
          v44 = v16;
          do
          {
            v45 = *v44++;
            ContentIndexDocSetDispose(v45);
            --v43;
          }
          while (v43);
        }
        else
        {
          v75 = v40 - 1;
          v65 = v7 - v41;
          v66 = ContentIndexDocSetIntersectionLazy(v40, (unsigned int **)v16, 0.0);
          ContentIndexFlattenDocSet((uint64_t)v66, a3);
          v67 = CFArrayCreateMutable(v10, 2, 0);
          v68 = _ContentIndexMemoizeDocSet((uint64_t)v66, a3, v67);
          CFRelease(v67);
          v69 = 0;
          do
            ContentIndexDocSetDispose(v16[v69++]);
          while (v40 != v69);
          v16[v75] = (uint64_t)v68;
          v42 = ContentIndexDocSetExceptLazy_Array((uint64_t)v68, v7 - v40, (uint64_t)&v16[v40]);
          if (v75 >= v7)
          {
            v6 = v16;
          }
          else
          {
            v70 = &v16[v41];
            do
            {
              v71 = *v70++;
              ContentIndexDocSetDispose(v71);
              --v65;
            }
            while (v65);
            v6 = v16;
          }
        }
        ContentIndexFlattenDocSet((uint64_t)v42, a3);
        v72 = CFArrayCreateMutable(v10, 2, 0);
        v62 = (uint64_t)_ContentIndexMemoizeDocSet((uint64_t)v42, a3, v72);
        CFRelease(v72);
        goto LABEL_86;
      }
LABEL_52:
      v46 = 0;
      v47 = 0;
      *a5 = 1;
      if (v7 <= 1)
        v48 = 1;
      else
        v48 = v7;
      v49 = v12;
      if (v12 <= 1uLL)
        v49 = 1;
      v50 = 8 * v49;
      v51 = v16;
      do
      {
        v52 = v51;
        v53 = *(_DWORD *)(v6[v46 / 8] + 96);
        v47 += v53;
        if (v53 <= 1)
          v51 = v52;
        else
          v51 = 0;
        v46 += 8;
      }
      while (v50 != v46);
      if (!v51)
      {
        v52 = (uint64_t *)malloc_type_zone_malloc((malloc_zone_t *)queryZone, 8 * v47, 0x6085D6BuLL);
        if (!v52)
          _log_fault_for_malloc_failure();
      }
      v54 = 0;
      v55 = 0;
      do
      {
        v56 = v6[v54];
        if (*(_DWORD *)(v56 + 96))
        {
          v57 = 0;
          v58 = v55;
          do
          {
            v59 = *(unsigned int **)(*(_QWORD *)(v56 + 72) + 8 * v57);
            if (v59)
            {
              do
                v60 = __ldaxr(v59);
              while (__stlxr(v60 + 1, v59));
            }
            v55 = v58 + 1;
            v52[v58] = (uint64_t)v59;
            ++v57;
            ++v58;
          }
          while (v57 < *(unsigned int *)(v56 + 96));
        }
        ContentIndexDocSetDispose(v56);
        ++v54;
      }
      while (v54 != v48);
      v61 = v55;
      v62 = ContentIndexDocSetUnionLazy(v55, v52, 0.0);
      if (v55)
      {
        v63 = v52;
        do
        {
          v64 = *v63++;
          ContentIndexDocSetDispose(v64);
          --v61;
        }
        while (v61);
      }
      if (v52 != v6)
        free(v52);
LABEL_86:
      a4 = v76;
      *v6 = v62;
      v7 = 1;
    }
  }
  else
  {
    v6 = 0;
    v7 = 0;
  }
  *a4 = v7;
  return v6;
}

void recomputeConstraints(unsigned int **a1, unsigned int a2, uint64_t *a3, int a4, int a5, int a6, char a7, int a8)
{
  uint64_t v15;
  int v16;
  uint64_t v17;
  unsigned int **v18;
  unsigned int *v19;
  unsigned int *v20;
  unsigned int v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unsigned int *v25;
  uint64_t v26;
  unsigned int *v27;
  uint64_t v28;
  unsigned int v29;
  char *v30;
  char *v31;
  const char *v32;
  unsigned int *v33;
  uint64_t v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v33 = 0;
  v34 = 0;
  v15 = *a3;
  v16 = *(_DWORD *)(*a3 + 128);
  v17 = v16 & 0x7FFFFFFF;
  if ((v16 & 0x7FFFFFFFu) < 2)
  {
    v20 = **(unsigned int ***)(v15 + 120);
    if (v20)
    {
      do
        v21 = __ldaxr(v20);
      while (__stlxr(v21 + 1, v20));
    }
    v33 = v20;
  }
  else
  {
    v18 = *(unsigned int ***)(v15 + 120);
    if (a4 == 5)
      v19 = ContentIndexDocSetIntersectionLazy(v17, v18, 0.0);
    else
      v19 = (unsigned int *)ContentIndexDocSetUnionLazy(v17, (uint64_t *)v18, 0.0);
    v20 = v19;
    v33 = v19;
  }
  v22 = *a3;
  if ((*(_DWORD *)(*a3 + 128) & 0x7FFFFFFF) != 0)
  {
    v23 = 0;
    do
    {
      ContentIndexDocSetDispose(*(_QWORD *)(*(_QWORD *)(v22 + 120) + 8 * v23++));
      v22 = *a3;
    }
    while (v23 < (*(_DWORD *)(*a3 + 128) & 0x7FFFFFFFu));
  }
  if (a5 == 5)
    v24 = (uint64_t)ContentIndexDocSetIntersectionLazy(a2, a1, 0.0);
  else
    v24 = ContentIndexDocSetUnionLazy(a2, (uint64_t *)a1, 0.0);
  v25 = (unsigned int *)v24;
  v26 = 0;
  v34 = v24;
  do
    ContentIndexDocSetDispose((uint64_t)a1[v26++]);
  while (a2 != v26);
  free(a1);
  if ((a7 & 1) != 0)
  {
    v33 = v25;
    v34 = (uint64_t)v20;
    v27 = v20;
    if (a6 != 4)
      goto LABEL_19;
LABEL_23:
    v28 = ContentIndexDocSetUnionLazy(2, (uint64_t *)&v33, 0.0);
    goto LABEL_25;
  }
  v27 = v25;
  v25 = v20;
  if (a6 == 4)
    goto LABEL_23;
LABEL_19:
  if (a6 == 7)
  {
    v28 = (uint64_t)ContentIndexDocSetExceptLazy((uint64_t)v25, v27, 0.0);
  }
  else
  {
    if (a6 != 5)
    {
      v30 = __si_assert_copy_extra_268();
      v31 = v30;
      v32 = "";
      if (v30)
        v32 = v30;
      __message_assert("%s:%u: failed assertion '%s' %s ", "ContentIndexQuery.c", 1080, "0", v32);
      free(v31);
      if (__valid_fs(-1))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
    v28 = (uint64_t)ContentIndexDocSetIntersectionLazy(2, &v33, 0.0);
  }
LABEL_25:
  **(_QWORD **)(*a3 + 120) = v28;
  ContentIndexDocSetDispose((uint64_t)v25);
  ContentIndexDocSetDispose((uint64_t)v27);
  *(_DWORD *)(*a3 + 128) = *(_DWORD *)(*a3 + 128) & 0x80000000 | 1;
  if (a8)
    v29 = 0x80000000;
  else
    v29 = 0;
  *(_DWORD *)(*a3 + 128) = v29 & 0x80000000 | *(_DWORD *)(*a3 + 128) & 0x7FFFFFFF;
}

unsigned int *ContentIndexDocSetExceptLazy_Array(uint64_t a1, int a2, uint64_t a3)
{
  unsigned int v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t v20;
  unsigned int *v21;
  size_t v22;
  void *v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  unsigned int *v30;
  unsigned int v31;
  __int16 v33[8];
  uint8_t buf[16];

  v6 = *(_DWORD *)(a1 + 52);
  if (a2)
  {
    v7 = 0;
    v8 = 0;
    while (1)
    {
      v9 = *(_QWORD *)(a3 + 8 * v7);
      v10 = *(unsigned int *)(v9 + 96);
      if ((_DWORD)v10)
      {
        v11 = *(_QWORD *)(v9 + 72);
        if ((_DWORD)v10 == 1)
        {
          v12 = 0;
        }
        else
        {
          v13 = 0;
          v12 = v10 & 0xFFFFFFFE;
          v14 = v11 + 8;
          v15 = v12;
          do
          {
            v6 |= *(_DWORD *)(*(_QWORD *)(v14 - 8) + 52);
            v13 |= *(_DWORD *)(*(_QWORD *)v14 + 52);
            v14 += 16;
            v15 -= 2;
          }
          while (v15);
          v6 |= v13;
          if (v12 == v10)
            goto LABEL_3;
        }
        v16 = v10 - v12;
        v17 = (uint64_t *)(v11 + 8 * v12);
        do
        {
          v18 = *v17++;
          v6 |= *(_DWORD *)(v18 + 52);
          --v16;
        }
        while (v16);
      }
LABEL_3:
      v8 += v10;
      if (++v7 == a2)
      {
        v19 = v8 + 1;
        goto LABEL_15;
      }
    }
  }
  v19 = 1;
LABEL_15:
  if (*MEMORY[0x1E0C85AD8] <= 0x97uLL)
    ++sTotal_4476;
  v20 = *(_QWORD *)(a1 + 56);
  v21 = (unsigned int *)malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x98uLL, 0x31F9A007uLL);
  if (!v21 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    v33[0] = 0;
    _os_log_fault_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "allocation function returned null", (uint8_t *)v33, 2u);
  }
  atomic_store(1u, v21);
  v21[1] = -1073627135;
  *((_QWORD *)v21 + 7) = v20;
  *((_QWORD *)v21 + 5) = -1;
  v21[12] = 7;
  v21[13] = v6;
  v22 = 8 * v19;
  v21[24] = v19;
  if (!(v19 >> 14) && *MEMORY[0x1E0C85AD8] < v22)
    ++sTotal_4476;
  v23 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, v22, 0x31F9A007uLL);
  if (!v23 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_fault_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "allocation function returned null", buf, 2u);
  }
  *((_QWORD *)v21 + 9) = v23;
  do
    v24 = __ldaxr((unsigned int *)a1);
  while (__stlxr(v24 + 1, (unsigned int *)a1));
  **((_QWORD **)v21 + 9) = a1;
  if (a2)
  {
    v25 = 0;
    v26 = 1;
    do
    {
      v28 = *(_QWORD *)(a3 + 8 * v25);
      if (*(_DWORD *)(v28 + 96))
      {
        v29 = 0;
        do
        {
          v30 = *(unsigned int **)(*(_QWORD *)(v28 + 72) + 8 * v29);
          if (v30)
          {
            do
              v31 = __ldaxr(v30);
            while (__stlxr(v31 + 1, v30));
          }
          v27 = (v26 + 1);
          *(_QWORD *)(*((_QWORD *)v21 + 9) + 8 * v26) = v30;
          ++v29;
          v28 = *(_QWORD *)(a3 + 8 * v25);
          LODWORD(v26) = v26 + 1;
        }
        while (v29 < *(unsigned int *)(v28 + 96));
      }
      else
      {
        v27 = v26;
      }
      ++v25;
      v26 = v27;
    }
    while (v25 != a2);
  }
  return v21;
}

uint64_t __extractConstrainingDocSets_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3;
  int v4;

  v3 = *(_DWORD *)(*(_QWORD *)a2 + 48);
  v4 = *(_DWORD *)(*(_QWORD *)a3 + 48);
  if (v3 == v4)
    return 0;
  if (v3 == 6)
    return 1;
  if (v4 == 6)
    return 0xFFFFFFFFLL;
  return 0;
}

uint64_t flattenChildrenAtIndex(void *value, unsigned int a2, CFSetRef theSet)
{
  uint64_t v3;
  unsigned int v4;
  void *v8;
  BOOL v9;
  unsigned int v10;
  char *v11;
  unint64_t v12;
  unint64_t v13;
  unsigned int *v14;
  unsigned int v15;
  uint64_t v16;

  v3 = *(_QWORD *)(*((_QWORD *)value + 9) + 8 * a2);
  v4 = *(_DWORD *)(v3 + 96);
  if (!v4)
    return 0;
  if (theSet)
  {
    v8 = (void *)CFSetGetValue(theSet, value);
    v9 = v8 == value;
    if (v8 == value)
    {
      do
        v10 = __ldaxr((unsigned int *)value);
      while (__stlxr(v10 + 1, (unsigned int *)value));
      CFSetRemoveValue(theSet, value);
    }
    v4 = *(_DWORD *)(v3 + 96);
    if (v4 < 2)
      goto LABEL_8;
  }
  else
  {
    v9 = 0;
    if (v4 < 2)
      goto LABEL_8;
  }
  v11 = (char *)malloc_type_realloc(*((void **)value + 9), 8 * (v4 + *((_DWORD *)value + 24) - 1), 0x2004093837F09uLL);
  *((_QWORD *)value + 9) = v11;
  memmove(&v11[8 * *(_DWORD *)(v3 + 96) + 8 * a2], &v11[8 * a2 + 8], 8 * (*((_DWORD *)value + 24) + ~a2));
  v4 = *(_DWORD *)(v3 + 96);
LABEL_8:
  if (v4)
  {
    v12 = 0;
    do
    {
      v14 = *(unsigned int **)(*(_QWORD *)(v3 + 72) + 8 * v12);
      if (v14)
      {
        do
          v15 = __ldaxr(v14);
        while (__stlxr(v15 + 1, v14));
      }
      *(_QWORD *)(*((_QWORD *)value + 9) + 8 * (v12++ + a2)) = v14;
      v13 = *(unsigned int *)(v3 + 96);
    }
    while (v12 < v13);
    v16 = (v13 - 1);
  }
  else
  {
    v16 = 0xFFFFFFFFLL;
  }
  *((_DWORD *)value + 24) += v16;
  if (v9)
  {
    CFSetSetValue(theSet, value);
    ContentIndexDocSetDispose((uint64_t)value);
  }
  ContentIndexDocSetDispose(v3);
  return v16;
}

void ContentIndexOrganizeWeightedTree(uint64_t a1)
{
  float v2;
  float v3;
  int v5;
  _QWORD *v6;
  size_t v7;
  size_t v8;
  size_t v9;
  _QWORD *v10;
  size_t v11;
  uint64_t v12;
  float v13;
  unint64_t v14;
  unint64_t v15;
  size_t v16;

  v3 = *(float *)(a1 + 12);
  v2 = *(float *)(a1 + 16);
  if (v2 == 0.0 && v3 == 0.0)
  {
    switch(*(_DWORD *)(a1 + 48))
    {
      case 0:
      case 2:
        goto LABEL_6;
      case 1:
        v2 = *(float *)(a1 + 12);
        goto LABEL_6;
      case 4:
      case 6:
        v5 = *(_DWORD *)(a1 + 96);
        v6 = *(_QWORD **)(a1 + 72);
        if (v5)
        {
          v7 = 0;
          do
          {
            ContentIndexOrganizeWeightedTree(v6[v7]);
            v6 = *(_QWORD **)(a1 + 72);
            v3 = fmaxf(v3, *(float *)(v6[v7++] + 24));
            v8 = *(unsigned int *)(a1 + 96);
          }
          while (v7 < v8);
        }
        else
        {
          v8 = 0;
        }
        qsort_b(v6, v8, 8uLL, &__block_literal_global_11);
        v2 = *(float *)(a1 + 20);
        goto LABEL_5;
      case 5:
        v9 = 0;
        v10 = *(_QWORD **)(a1 + 72);
        break;
      case 7:
        if (*(_DWORD *)(a1 + 96))
        {
          v14 = 0;
          do
          {
            ContentIndexOrganizeWeightedTree(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8 * v14++));
            v15 = *(unsigned int *)(a1 + 96);
          }
          while (v14 < v15);
          v16 = (v15 - 1);
        }
        else
        {
          v16 = 0xFFFFFFFFLL;
        }
        qsort_b((void *)(*(_QWORD *)(a1 + 72) + 8), v16, 8uLL, &__block_literal_global_11);
        v2 = *(float *)(**(_QWORD **)(a1 + 72) + 24);
        goto LABEL_6;
      default:
        return;
    }
    while (1)
    {
      v11 = *(unsigned int *)(a1 + 96);
      if (v9 >= v11)
        break;
      ContentIndexOrganizeWeightedTree(v10[v9]);
      v10 = *(_QWORD **)(a1 + 72);
      v12 = v10[v9];
      v13 = *(float *)(v12 + 24);
      if (v13 == 0.0)
        v3 = *(float *)(v12 + 24);
      else
        v3 = v13 + v3;
      ++v9;
      if (v3 == 0.0)
      {
        v11 = *(unsigned int *)(a1 + 96);
        break;
      }
    }
    qsort_b(v10, v11, 8uLL, &__block_literal_global_13_4520);
    v2 = *(float *)(a1 + 20) + v3;
  }
  else
  {
LABEL_5:
    v2 = fmaxf(v3, v2);
  }
LABEL_6:
  *(float *)(a1 + 24) = v2;
}

uint64_t __sort_children_prefer_false_zero_block_invoke(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3;
  uint64_t v4;
  float v5;
  float v6;
  float v8;
  float v9;
  float v10;
  float v11;

  v3 = *a2;
  v4 = *a3;
  v5 = *(float *)(*a2 + 16);
  v6 = *(float *)(*a3 + 16);
  if (v5 != v6)
  {
    if (v5 == 0.0)
      return 0xFFFFFFFFLL;
    if (v6 == 0.0)
      return 1;
  }
  v8 = *(float *)(v3 + 12);
  v9 = *(float *)(v4 + 12);
  if (v8 == v9)
    goto LABEL_11;
  if (v8 == 0.0)
    return 0xFFFFFFFFLL;
  if (v9 == 0.0)
    return 1;
LABEL_11:
  v10 = *(float *)(v3 + 24);
  v11 = *(float *)(v4 + 24);
  if (v10 <= v11)
    return v10 < v11;
  else
    return 0xFFFFFFFFLL;
}

uint64_t __sort_children_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  float v3;
  float v4;

  v3 = *(float *)(*(_QWORD *)a2 + 24);
  v4 = *(float *)(*(_QWORD *)a3 + 24);
  if (v3 > v4)
    return 0xFFFFFFFFLL;
  else
    return v3 < v4;
}

uint64_t ContentIndexAnnotateWeightedTreeInner(uint64_t result, float a2)
{
  float v3;
  uint64_t v4;
  float v5;
  int v6;
  float v7;
  float v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  float v14;
  float v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  float v20;

  v3 = *(float *)(result + 12);
  if (v3 == 0.0)
  {
    v4 = result;
    v5 = *(float *)(result + 16);
    if (v5 == 0.0)
    {
      switch(*(_DWORD *)(result + 48))
      {
        case 4:
        case 6:
          v6 = *(_DWORD *)(result + 96);
          if (v6)
          {
            v7 = fmaxf(v3, v5);
            v8 = v7 + a2;
            v9 = v6 - 1;
            do
            {
              v10 = v9;
              v11 = 8 * v9;
              result = ContentIndexAnnotateWeightedTreeInner(*(_QWORD *)(*(_QWORD *)(v4 + 72) + v11), v8);
              v12 = *(_QWORD *)(*(_QWORD *)(v4 + 72) + v11);
              v7 = fmaxf(v7, *(float *)(v12 + 24));
              v8 = v7 + a2;
              *(float *)(v12 + 28) = v7 + a2;
              --v9;
            }
            while (v10);
          }
          break;
        case 5:
          v13 = *(_DWORD *)(result + 96);
          if (v13)
          {
            v14 = fmaxf(v3, v5);
            v15 = v14 + a2;
            v16 = v13 - 1;
            do
            {
              v17 = v16;
              v18 = 8 * v16;
              result = ContentIndexAnnotateWeightedTreeInner(*(_QWORD *)(*(_QWORD *)(v4 + 72) + v18), v15);
              v19 = *(_QWORD *)(*(_QWORD *)(v4 + 72) + v18);
              v14 = *(float *)(v19 + 24) + v14;
              v15 = v14 + a2;
              *(float *)(v19 + 28) = v14 + a2;
              --v16;
            }
            while (v17);
          }
          break;
        case 7:
          v20 = fmaxf(v3, v5) + a2;
          result = ContentIndexAnnotateWeightedTreeInner(**(_QWORD **)(result + 72), v20);
          *(float *)(v4 + 28) = *(float *)(**(_QWORD **)(v4 + 72) + 24) + v20;
          break;
        default:
          return result;
      }
    }
  }
  return result;
}

uint64_t ContentIndexDocSetSetProximities(uint64_t a1, unsigned int a2, const void *a3)
{
  unsigned int v5;
  size_t v6;
  uint64_t result;

  if (*(_DWORD *)(a1 + 48) != 9 || !*(_DWORD *)(a1 + 36))
    return 0;
  if (*(_DWORD *)(a1 + 96) >= a2)
    v5 = a2;
  else
    v5 = *(_DWORD *)(a1 + 96);
  if (v5 <= *(_DWORD *)(a1 + 132))
  {
    if (v5)
    {
      result = *(_QWORD *)(a1 + 136);
      v6 = 4 * v5;
      goto LABEL_11;
    }
    return 0;
  }
  v6 = 4 * v5;
  result = (uint64_t)reallocf(*(void **)(a1 + 136), v6);
  *(_QWORD *)(a1 + 136) = result;
  if (result)
  {
LABEL_11:
    memcpy((void *)result, a3, v6);
    *(_DWORD *)(a1 + 132) = v5;
    return 1;
  }
  return result;
}

uint64_t ContentIndexDocSetGrabConstrainingVector(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  char *v4;
  char *v5;
  const char *v6;

  v1 = 0;
  switch(*(_DWORD *)(a1 + 48))
  {
    case 0:
    case 1:
    case 2:
      return v1;
    case 3:
    case 8:
      v1 = *(_QWORD *)(a1 + 64);
      if (!v1)
        return v1;
      v2 = v1 + 88;
      return *(_QWORD *)v2;
    case 4:
    case 5:
    case 6:
    case 7:
    case 9:
      if (!*(_BYTE *)(a1 + 32))
      {
        v4 = __si_assert_copy_extra_268();
        v5 = v4;
        v6 = "";
        if (v4)
          v6 = v4;
        __message_assert("%s:%u: failed assertion '%s' %s ", "ContentIndexQuery.c", 1920, "docs->processed", v6);
        free(v5);
        if (__valid_fs(-1))
        {
          MEMORY[0xBAA] = -559038737;
          abort();
        }
        MEMORY[0xC00] = -559038737;
        abort();
      }
      v2 = a1 + 104;
      return *(_QWORD *)v2;
    default:
      assert_invalid_doc_type((_DWORD *)a1);
  }
}

uint64_t ContentIndexDocSet_PositionRead(uint64_t *a1, _QWORD *a2, int a3, _BYTE *a4, int8x8_t a5)
{
  uint64_t v8;
  uint64_t *v9;
  _DWORD *v10;
  uint64_t v11;
  int v12;
  int v13;
  uint64_t locked;
  _DWORD *v15;
  uint64_t v16;
  const __CFAllocator *v18;
  __CFSet *Mutable;
  __CFSet *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v24;
  int v25;
  unint64_t v26;
  unsigned int v27;
  unsigned int v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  void (*v32)(_QWORD);
  int v33;
  NSObject *v34;
  pthread_key_t v35;
  void *v36;
  void *v37;
  uint64_t v38;
  _DWORD *v39;
  _DWORD *v40;
  unsigned int v41;
  const __CFSet *v42;
  int v43;
  unsigned int v44;
  int v45;
  unint64_t v46;
  unsigned int v47;
  int v48;
  uint64_t v49;
  uint64_t v50;
  void (*v51)(_QWORD);
  int v52;
  NSObject *v53;
  void *v54;
  void *v55;
  uint64_t v56;
  _DWORD *v57;
  _DWORD *v58;
  unsigned int v59;
  const __CFSet *v60;
  uint64_t v61;
  int v62;
  NSObject *v63;
  os_log_type_t v64;
  uint64_t *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t *v68;
  uint64_t v69;
  int v70;
  uint64_t v71;
  uint64_t *v72;
  uint64_t v73;
  uint64_t v74;
  int v75;
  uint64_t *v76;
  int8x8_t v77;
  unsigned int *v78;
  char v79;
  char v80;
  unsigned int v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t i;
  uint64_t v88;
  uint64_t v89;
  int v90;
  int v91;
  uint64_t v92;
  uint64_t v93;
  int v94;
  int v95;
  _DWORD *v96;
  int v97;
  uint64_t v98;
  uint64_t v99;
  pthread_rwlock_t *v100;
  unsigned int v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  int v105;
  int v106;
  int v107;
  uint64_t v108;
  uint64_t v109;
  unsigned int v110;
  uint64_t v111;
  void (*v112)(_QWORD);
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  int v117;
  NSObject *v118;
  int v119;
  int v120;
  int v121;
  NSObject *v122;
  os_log_type_t v123;
  int v124;
  uint64_t v125;
  unsigned int v126;
  uint64_t v127;
  void (*v128)(_QWORD);
  int v129;
  NSObject *v130;
  int v131;
  NSObject *v132;
  int v133;
  int v134;
  char *v135;
  char *v136;
  const char *v137;
  uint64_t v138;
  int v139;
  uint64_t v140;
  unsigned int v141;
  unsigned int v142;
  int v143;
  uint64_t v144;
  uint64_t v145;
  int v146;
  uint64_t v148;
  int v149;
  _QWORD *v150;
  const __CFSet *v151;
  unsigned int v152;
  unsigned int j;
  unint64_t v154;
  unsigned int v155;
  unsigned int v156;
  unint64_t v157;
  unsigned int v158;
  unsigned int v159;
  int v160;
  int v161;
  char v162;
  uint8_t v163[4];
  _BYTE v164[10];
  int v165;
  _BYTE buf[24];
  __int128 v167;
  uint64_t v168;
  uint64_t v169;

  v169 = *MEMORY[0x1E0C80C00];
  v162 = 1;
  v9 = a1 + 10;
  v8 = a1[10];
  v10 = (_DWORD *)v8;
  v11 = a1[9];
  v12 = *((_DWORD *)a1 + 7);
  v13 = *((_DWORD *)a1 + 6) + 1;
  v160 = v12;
  v161 = v13;
  if (*((_BYTE *)a1 + 53))
  {
    locked = 0;
    switch(*(_DWORD *)(v8 + 48))
    {
      case 0:
      case 1:
      case 2:
        goto LABEL_40;
      case 3:
      case 8:
        locked = *(_QWORD *)(v8 + 64);
        if (locked)
        {
          v15 = *(_DWORD **)(locked + 88);
          if (v15)
          {
LABEL_4:
            locked = lockedCountItemsInRange(v15, *((_DWORD *)a1 + 11), *((_DWORD *)a1 + 10) - 1, a5);
            if (a3)
              goto LABEL_41;
          }
          else
          {
LABEL_39:
            locked = 0;
LABEL_40:
            if (a3)
            {
LABEL_41:
              v61 = (*((_DWORD *)a1 + 10) - *((_DWORD *)a1 + 11)) - locked;
              v16 = v61 & ~(v61 >> 63);
LABEL_42:
              v62 = *__error();
              v63 = _SILogForLogForCategory(10);
              v64 = 2 * (dword_1EF19FCB4 < 4);
              if (os_log_type_enabled(v63, v64))
              {
                *(_DWORD *)buf = 134217984;
                *(_QWORD *)&buf[4] = v16;
                _os_log_impl(&dword_1B8270000, v63, v64, "Found: %ld", buf, 0xCu);
              }
              *__error() = v62;
              *a2 += v16;
              return 0;
            }
          }
        }
        else if (a3)
        {
          goto LABEL_41;
        }
        v16 = locked;
        goto LABEL_42;
      case 4:
      case 5:
      case 6:
      case 7:
      case 9:
        v15 = *(_DWORD **)(v8 + 80);
        if (v15)
          goto LABEL_4;
        goto LABEL_39;
      default:
        goto LABEL_140;
    }
  }
  v144 = v8;
  v145 = v8;
  v18 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0);
  v20 = CFSetCreateMutable(v18, 0, 0);
  if (*((_DWORD *)a1 + 18))
  {
    v21 = 0;
    do
    {
      v22 = v21;
      ContentIndexDocSetIteratorFlatten(v9[v21], Mutable, v20, 0);
      v21 = v22 + 1;
    }
    while (v22 + 1 < (unint64_t)*((unsigned int *)a1 + 18));
  }
  v151 = v20;
  v148 = v11;
  v23 = v11;
  if (*((_BYTE *)a1 + 52))
  {
    v150 = a2;
    *(_QWORD *)buf = a1[1];
    *(_OWORD *)&buf[8] = 0u;
    v167 = 0u;
    v168 = 0;
    do
    {
      v24 = __ldxr(exceptionSequenceNum);
      v25 = v24 + 1;
    }
    while (__stxr(v24 + 1, exceptionSequenceNum));
    v26 = setThreadIdAndInfo(-1, sAssertExceptionCallbacks, 0, 0, v25);
    v158 = HIDWORD(v26);
    v159 = v26;
    v157 = __PAIR64__(v27, v28);
    v29 = *(_QWORD *)&threadData[18 * v26 + 2];
    v30 = v29 + 320 * HIDWORD(v26);
    v31 = *(_DWORD *)(v30 + 312);
    v32 = *(void (**)(_QWORD))(v30 + 224);
    if (v32)
      v32(*(_QWORD *)(v29 + 320 * HIDWORD(v26) + 288));
    v156 = v159;
    v155 = v158;
    v154 = v157;
    if (_setjmp((int *)v30))
    {
      v33 = *__error();
      v34 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v163 = 136315394;
        *(_QWORD *)v164 = "ContentIndexDocSet_PositionRead";
        *(_WORD *)&v164[8] = 1024;
        v165 = 4157;
        _os_log_error_impl(&dword_1B8270000, v34, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", v163, 0x12u);
      }
      *__error() = v33;
      *(_DWORD *)(v30 + 312) = v31;
      v35 = __THREAD_SLOT_KEY;
      if (!__THREAD_SLOT_KEY)
      {
        makeThreadId();
        v35 = __THREAD_SLOT_KEY;
      }
      v36 = pthread_getspecific(v35);
      if (!v36 || (v37 = v36, (unint64_t)v36 >= 0x801))
      {
        makeThreadId();
        v37 = pthread_getspecific(__THREAD_SLOT_KEY);
      }
      v38 = (uint64_t)v37 - 1;
      v39 = &threadData[18 * ((uint64_t)v37 - 1)];
      v41 = v39[14];
      v40 = v39 + 14;
      if (v41 > v154)
      {
        do
          CIOnThreadCleanUpPop(v38);
        while (*v40 > v154);
      }
      dropThreadId(v156, 1, v25);
      CICleanUpReset(v156, HIDWORD(v154));
      v42 = v151;
LABEL_124:
      CIIndexSetDisposePerThreadCache(buf);
      if (v162)
        *((_BYTE *)a1 + 58) = 1;
      CFRelease(Mutable);
      CFRelease(v42);
      return 0;
    }
    v146 = v31;
    v149 = v25;
    *((_BYTE *)a1 + 53) = 1;
    if (v11 >= 1)
    {
      v65 = v9;
      v66 = v11;
      do
      {
        v67 = v66;
        v68 = v65 + 1;
        ContentIndexDocSetSquashUpdatesForPulse(*v65, 1, *((unsigned int *)a1 + 6));
        v65 = v68;
        v66 = v67 - 1;
      }
      while (v67 != 1);
    }
    BulkPayloadIterator_Step(a1[2], &v161, &v160);
    v69 = *((unsigned int *)a1 + 6);
    *((_DWORD *)a1 + 11) = 1;
    v70 = v69;
    v71 = v11;
    if (v11 >= 1)
    {
      v72 = v9;
      v73 = v11;
      do
      {
        v74 = v73;
        v75 = *((_DWORD *)a1 + 6);
        v76 = v72 + 1;
        ContentIndexDocSetSquashUpdate(*v72, 0);
        v72 = v76;
        v73 = v74 - 1;
      }
      while (v74 != 1);
      v70 = v75;
      v71 = v148;
    }
    v152 = v70;
    j = 1;
    ContentIndexDocSetIteratorPreProcess(v9, v23, 0, 1, v70, *((_DWORD *)a1 + 7));
    v78 = (unsigned int *)(*(_QWORD *)(a1[10] + 56) + 28);
    v79 = atomic_load(v78);
    v80 = atomic_load(v78);
    if ((v79 & 4) != 0 && (v80 & 0x40) != 0 && (v81 = *((_DWORD *)a1 + 6), LODWORD(v82) = v81 - 0x4000, v81 > 0x4000))
    {
      v83 = 0;
      v84 = *((unsigned int *)a1 + 6);
      if (v81 == 16385)
        v82 = 0;
      else
        v82 = v82;
      v142 = v161;
      v141 = v161 + 0x4000;
      do
      {
        v86 = v82;
        if (v148 >= 1)
        {
          for (i = 0; i != v148; ++i)
          {
            v152 = v84;
            for (j = v86;
                  ContentIndexDocSetIteratorReadPositions(v9[i], a1[1], &j, &v152, v84, *((unsigned int *)a1 + 7), v86, v83, a4);
                  j = v86)
            {
              v152 = j;
            }
            ContentIndexDocSetIteratorProcessPositions(v9[i], buf, v86, v84, *((unsigned int *)a1 + 7));
          }
        }
        v139 = *((_DWORD *)a1 + 7);
        v140 = a1[1];
        processLeaves(v151, v139, 0, v86, v84, v140);
        processNodes(Mutable, v139, 0, v86, v84, v140);
        if (v86 <= v141)
          v85 = v142;
        else
          v85 = (v86 - 0x4000);
        v82 = v85;
        v83 = (v83 + 1);
        v84 = (v86 - 1);
      }
      while (v86 > v85);
    }
    else
    {
      if (v71 >= 1)
      {
        v88 = 0;
        do
        {
          while (ContentIndexDocSetIteratorReadPositions(v9[v88], a1[1], &j, &v152, v69, *((unsigned int *)a1 + 7), 1, 0, a4))
          {
            v152 = j;
            j = 1;
          }
          v89 = *((unsigned int *)a1 + 6);
          if ((_DWORD)v89)
            ContentIndexDocSetIteratorProcessPositions(v9[v88], buf, 1, v89, *((unsigned int *)a1 + 7));
          ++v88;
        }
        while (v88 != v148);
      }
      v90 = *((_DWORD *)a1 + 6);
      if (v90)
      {
        v91 = *((_DWORD *)a1 + 7);
        v92 = a1[1];
        processLeaves(v151, v91, 0, 1, *((_DWORD *)a1 + 6), v92);
        processNodes(Mutable, v91, 0, 1, v90, v92);
      }
    }
    v10 = (_DWORD *)v145;
    v93 = 0;
    v94 = v149;
    v95 = v146;
    switch(*(_DWORD *)(v145 + 48))
    {
      case 0:
      case 1:
      case 2:
        goto LABEL_109;
      case 3:
      case 8:
        v114 = *(_QWORD *)(v145 + 64);
        if (v114)
        {
          v96 = *(_DWORD **)(v114 + 88);
          if (v96)
            goto LABEL_107;
        }
        goto LABEL_108;
      case 4:
      case 5:
      case 6:
      case 7:
      case 9:
        v96 = *(_DWORD **)(v144 + 80);
        if (v96)
LABEL_107:
          v93 = lockedCountItemsInRange(v96, *((_DWORD *)a1 + 11), *((_DWORD *)a1 + 10) - 1, v77);
        else
LABEL_108:
          v93 = 0;
LABEL_109:
        if (dword_1EF19FCB4 >= 5)
        {
          v117 = *__error();
          v118 = _SILogForLogForCategory(10);
          if (os_log_type_enabled(v118, OS_LOG_TYPE_DEFAULT))
          {
            v119 = *((_DWORD *)a1 + 11);
            v120 = *((_DWORD *)a1 + 10) - 1;
            *(_DWORD *)v163 = 67109376;
            *(_DWORD *)v164 = v119;
            *(_WORD *)&v164[4] = 1024;
            *(_DWORD *)&v164[6] = v120;
            _os_log_impl(&dword_1B8270000, v118, OS_LOG_TYPE_DEFAULT, "OID Range %d to %d", v163, 0xEu);
          }
          *__error() = v117;
          v94 = v149;
          v95 = v146;
          if (a3)
            goto LABEL_111;
        }
        else if (a3)
        {
LABEL_111:
          v115 = (*((_DWORD *)a1 + 10) - *((_DWORD *)a1 + 11)) - v93;
          v116 = v115 & ~(v115 >> 63);
          goto LABEL_119;
        }
        v116 = v93;
LABEL_119:
        v121 = *__error();
        v122 = _SILogForLogForCategory(10);
        v123 = 2 * (dword_1EF19FCB4 < 4);
        if (os_log_type_enabled(v122, v123))
        {
          *(_DWORD *)v163 = 134217984;
          *(_QWORD *)v164 = v116;
          _os_log_impl(&dword_1B8270000, v122, v123, "Found: %ld", v163, 0xCu);
        }
        *__error() = v121;
        v124 = *((_DWORD *)a1 + 7);
        *((_DWORD *)a1 + 8) = 1;
        *((_DWORD *)a1 + 9) = v124;
        *v150 += v116;
        v162 = 0;
        v125 = *(_QWORD *)&threadData[18 * v156 + 2];
        v126 = v155;
        v127 = v125 + 320 * v155;
        *(_DWORD *)(v127 + 312) = v95;
        v128 = *(void (**)(_QWORD))(v127 + 232);
        v42 = v151;
        if (v128)
          v128(*(_QWORD *)(v125 + 320 * v126 + 288));
        dropThreadId(v156, 0, v94);
        goto LABEL_124;
      default:
LABEL_140:
        assert_invalid_doc_type(v10);
    }
  }
  v43 = v13;
  do
  {
    v44 = __ldxr(exceptionSequenceNum);
    v45 = v44 + 1;
  }
  while (__stxr(v44 + 1, exceptionSequenceNum));
  v46 = setThreadIdAndInfo(-1, sAssertExceptionCallbacks, 0, 0, v45);
  v159 = HIDWORD(v46);
  *(_DWORD *)v163 = v46;
  v158 = v47;
  HIDWORD(v157) = v48;
  v49 = *(_QWORD *)&threadData[18 * v46 + 2];
  v50 = v49 + 320 * HIDWORD(v46);
  v143 = *(_DWORD *)(v50 + 312);
  v51 = *(void (**)(_QWORD))(v50 + 224);
  if (v51)
    v51(*(_QWORD *)(v49 + 320 * HIDWORD(v46) + 288));
  LODWORD(v157) = *(_DWORD *)v163;
  v156 = v159;
  v155 = v158;
  HIDWORD(v154) = HIDWORD(v157);
  if (!_setjmp((int *)v50))
  {
    if (v13 != v12)
    {
      ContentIndexDocSetIteratorPreProcess(v9, v23, 1, v13, v12, *((_DWORD *)a1 + 7));
      _CIDocSetIteratorProcessPositionsUpdates(v9, v23, v13, v12, *((_DWORD *)a1 + 7), *(_BYTE *)(*a1 + 40));
      v97 = *((_DWORD *)a1 + 7);
      v98 = a1[1];
      processLeaves(v151, v97, 1, v43, v12, v98);
      processNodes(Mutable, v97, 1, v43, v12, v98);
    }
    if (dword_1EF19FCB4 >= 5)
    {
      v129 = *__error();
      v130 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v130, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109376;
        *(_DWORD *)&buf[4] = v43;
        *(_WORD *)&buf[8] = 1024;
        *(_DWORD *)&buf[10] = v12;
        _os_log_impl(&dword_1B8270000, v130, OS_LOG_TYPE_DEFAULT, "Updates from %d to %d", buf, 0xEu);
      }
      *__error() = v129;
    }
    v99 = *a1;
    v100 = *(pthread_rwlock_t **)(*a1 + 24);
    if (v100)
    {
      if (v100 != (pthread_rwlock_t *)(*(_QWORD *)(*v9 + 56) + 14144))
      {
        v135 = __si_assert_copy_extra_268();
        v136 = v135;
        v137 = "";
        if (v135)
          v137 = v135;
        __message_assert("%s:%u: failed assertion '%s' %s ", "ContentIndexQuery.c", 3996, "iterator->context->positionLock == ContentIndexGetPositionsLock(iterator->docSets[0]->ref)", v137);
        free(v136);
        if (__valid_fs(-1))
          v138 = 2989;
        else
          v138 = 3072;
        *(_DWORD *)v138 = -559038737;
        abort();
      }
      posreadunlock(v100);
      *(_QWORD *)(*a1 + 24) = 0;
      v99 = *a1;
    }
    *((_BYTE *)a1 + 52) = 1;
    *((_BYTE *)a1 + 54) = 1;
    *((_DWORD *)a1 + 8) = v43;
    *((_DWORD *)a1 + 9) = v12;
    v101 = *(_DWORD *)(v99 + 36);
    if (v12 + 1 < v101)
      v101 = v12 + 1;
    *((_DWORD *)a1 + 10) = v101;
    *((_DWORD *)a1 + 11) = v43;
    BulkPayloadIterator_Step(a1[2], &v161, &v160);
    if (v148 < 1)
    {
      v105 = *((_DWORD *)a1 + 9);
    }
    else
    {
      v102 = *((unsigned int *)a1 + 9);
      do
      {
        v103 = *v9++;
        v104 = ContentIndexDocSetSquashUpdatesForPulse(v103, *((unsigned int *)a1 + 8), v102);
        v105 = v104;
        *((_DWORD *)a1 + 9) = v104;
        v102 = v104;
        --v23;
      }
      while (v23);
    }
    v107 = *((_DWORD *)a1 + 7);
    v106 = *((_DWORD *)a1 + 8);
    v108 = a1[1];
    v60 = v151;
    processLeaves(v151, v107, 0, v106, v105, v108);
    processNodes(Mutable, v107, 0, v106, v105, v108);
    if (dword_1EF19FCB4 > 4)
    {
      v131 = *__error();
      v132 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v132, OS_LOG_TYPE_DEFAULT))
      {
        v133 = *((_DWORD *)a1 + 8);
        v134 = *((_DWORD *)a1 + 9);
        *(_DWORD *)buf = 67109376;
        *(_DWORD *)&buf[4] = v133;
        *(_WORD *)&buf[8] = 1024;
        *(_DWORD *)&buf[10] = v134;
        _os_log_impl(&dword_1B8270000, v132, OS_LOG_TYPE_DEFAULT, "1 Disk from %d to %d", buf, 0xEu);
      }
      *__error() = v131;
      v60 = v151;
    }
    v162 = 0;
    v109 = *(_QWORD *)&threadData[18 * v157 + 2];
    v110 = v156;
    v111 = v109 + 320 * v156;
    *(_DWORD *)(v111 + 312) = v143;
    v112 = *(void (**)(_QWORD))(v111 + 232);
    if (v112)
      v112(*(_QWORD *)(v109 + 320 * v110 + 288));
    dropThreadId(v157, 0, v45);
    goto LABEL_100;
  }
  v52 = *__error();
  v53 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = "ContentIndexDocSet_PositionRead";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 4039;
    _os_log_error_impl(&dword_1B8270000, v53, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
  }
  *__error() = v52;
  *(_DWORD *)(v50 + 312) = v143;
  if (__THREAD_SLOT_KEY)
  {
    v54 = pthread_getspecific(__THREAD_SLOT_KEY);
    if (!v54)
    {
LABEL_114:
      makeThreadId();
      v55 = pthread_getspecific(__THREAD_SLOT_KEY);
      goto LABEL_34;
    }
  }
  else
  {
    makeThreadId();
    v54 = pthread_getspecific(__THREAD_SLOT_KEY);
    if (!v54)
      goto LABEL_114;
  }
  v55 = v54;
  if ((unint64_t)v54 >= 0x801)
    goto LABEL_114;
LABEL_34:
  v56 = (uint64_t)v55 - 1;
  v57 = &threadData[18 * ((uint64_t)v55 - 1)];
  v59 = v57[14];
  v58 = v57 + 14;
  if (v59 > HIDWORD(v154))
  {
    do
      CIOnThreadCleanUpPop(v56);
    while (*v58 > HIDWORD(v154));
  }
  dropThreadId(v157, 1, v45);
  CICleanUpReset(v157, v155);
  v60 = v151;
LABEL_100:
  CFRelease(Mutable);
  CFRelease(v60);
  if (v162)
    *((_BYTE *)a1 + 58) = 1;
  if (v162)
    return 0;
  else
    return 35;
}

void ContentIndexDocSetIteratorPreProcess(uint64_t *a1, int a2, char a3, int a4, int a5, int a6)
{
  uint64_t v10;
  __CFSet *Mutable;
  uint64_t v13;
  CFIndex Count;
  const void **v15;
  char v16;
  unsigned int v17;
  unsigned int v18;
  CFIndex v19;
  unsigned int *v20;
  uint64_t v21;
  unsigned int v22;
  BOOL v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  const void *v27;
  char *v28;
  char *v29;
  const char *v30;
  char *v31;
  const char *v32;
  char *v33;
  const char *v34;
  _QWORD block[6];
  int v36;
  int v37;
  int v38;
  char v39;
  char v40;

  LODWORD(v10) = a2;
  Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0);
  if ((_DWORD)v10)
  {
    v10 = v10;
    do
    {
      v13 = *a1++;
      ContentIndexDocSetIteratorFlatten(v13, Mutable, 0, 1);
      --v10;
    }
    while (v10);
  }
  Count = CFSetGetCount(Mutable);
  v15 = (const void **)malloc_type_malloc(8 * Count, 0x2004093837F09uLL);
  CFSetGetValues(Mutable, v15);
  do
  {
    if ((_DWORD)Count)
    {
      v16 = 0;
      v17 = 0;
      v18 = 0;
      v19 = Count;
      do
      {
        v20 = (unsigned int *)v15[v18];
        if (*((_BYTE *)v20 + 32))
        {
          v19 = (v19 - 1);
          if (v18 < v19)
          {
            v21 = v19;
            v15[v18] = v15[v21];
            v15[v21] = v20;
          }
        }
        else
        {
          v22 = v20[12];
          v23 = v22 - 4 < 4 || v22 == 9;
          if (v23 && (v24 = v20[24], (_DWORD)v24))
          {
            v25 = *((_QWORD *)v20 + 9);
            while (*(_BYTE *)(*(_QWORD *)v25 + 32))
            {
              v25 += 8;
              if (!--v24)
                goto LABEL_22;
            }
            v16 = 1;
          }
          else
          {
LABEL_22:
            if (v17 < v18)
            {
              v26 = v17;
              v27 = v15[v26];
              v15[v26] = v20;
              v15[v18] = v27;
            }
            ++v17;
          }
          ++v18;
        }
      }
      while (v18 < v19);
    }
    else
    {
      v19 = 0;
      v17 = 0;
      v16 = 0;
    }
    if (Count < v19)
    {
      v28 = __si_assert_copy_extra_268();
      v29 = v28;
      v30 = "";
      if (v28)
        v30 = v28;
      __message_assert("%s:%u: failed assertion '%s' %s ", "ContentIndexQuery.c", 3434, "oldNodeCount >= nodeCount", v30);
LABEL_41:
      free(v29);
      if (__valid_fs(-1))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
    if ((_DWORD)v19 && !v17)
    {
      v31 = __si_assert_copy_extra_268();
      v29 = v31;
      v32 = "";
      if (v31)
        v32 = v31;
      __message_assert("%s:%u: failed assertion '%s' %s ", "ContentIndexQuery.c", 3444, "processCount || nodeCount == 0", v32);
      goto LABEL_41;
    }
    v40 = 0;
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __ContentIndexDocSetIteratorPreProcess_block_invoke;
    block[3] = &__block_descriptor_tmp_26_4592;
    v39 = a3;
    v36 = a4;
    v37 = a5;
    v38 = a6;
    block[4] = v15;
    block[5] = &v40;
    dispatch_apply(v17, 0, block);
    if ((v40 & 1) != 0)
    {
      v33 = __si_assert_copy_extra_268();
      v29 = v33;
      v34 = "";
      if (v33)
        v34 = v33;
      __message_assert("%s:%u: failed assertion '%s' %s ", "ContentIndexQuery.c", 3464, "__c11_atomic_load(didAssertPtr, memory_order_relaxed)==0", v34);
      goto LABEL_41;
    }
    Count = v19;
  }
  while ((((_DWORD)v19 != 0) & v16) != 0);
  CFRelease(Mutable);
  free(v15);
}

uint64_t ContentIndexDocSetIteratorReadPositions(uint64_t a1, unint64_t a2, unsigned int *a3, unsigned int *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, _BYTE *a9)
{
  _BYTE *v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int *v13;
  unsigned int *v14;
  uint64_t v16;
  int *v17;
  unsigned int v18;
  int v19;
  char v20;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unsigned int v32;
  unsigned int v33;
  _BYTE *v34;
  char v35;
  int v36;
  int v37;
  _BYTE *v38;
  _DWORD *v39;
  _BYTE *v40;
  int v41;
  uint64_t v42;
  unsigned int v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unsigned int *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  int v52;
  NSObject *v53;
  uint64_t v54;
  int v55;
  NSObject *v56;
  unsigned int v57;
  int v58;
  unsigned int v59;
  unsigned int *v60;
  unsigned int *v61;
  unint64_t v63;
  unsigned int v64;
  unsigned int v65;
  unsigned int v66;
  uint8_t buf[4];
  unsigned int v68;
  __int16 v69;
  unsigned int v70;
  __int16 v71;
  int v72;
  uint64_t v73;

  v9 = a9;
  v73 = *MEMORY[0x1E0C80C00];
  v10 = *a3;
  v11 = *a4;
  v65 = *a4;
  v66 = v10;
  if (*a9)
    goto LABEL_7;
  v13 = a4;
  v14 = a3;
  v16 = a1;
  if (v11 < v10)
  {
    v65 = v10;
    v11 = v10;
  }
  v17 = (int *)&unk_1EF19F000;
  if (dword_1EF19FCB4 >= 5)
  {
    v57 = a6;
    v59 = a7;
    v54 = a8;
    v55 = *__error();
    v56 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109632;
      v68 = v10;
      v69 = 1024;
      v70 = v11;
      v71 = 1024;
      v72 = a5;
      _os_log_impl(&dword_1B8270000, v56, OS_LOG_TYPE_DEFAULT, "from %d to %d, with old end at %d", buf, 0x14u);
    }
    *__error() = v55;
    a6 = v57;
    a7 = v59;
    a8 = v54;
    v16 = a1;
    v9 = a9;
    v17 = (_DWORD *)&unk_1EF19F000;
  }
  v18 = *(_DWORD *)(v16 + 48);
  if (v18 > 9)
    assert_invalid_doc_type((_DWORD *)v16);
  v19 = 1 << v18;
  if ((v19 & 0x10F) != 0)
  {
LABEL_7:
    v20 = 0;
    return v20 & 1;
  }
  if ((v19 & 0xF0) == 0)
  {
    if (!*(_QWORD *)(v16 + 104))
    {
      v36 = a7;
      v37 = a8;
      v38 = v9;
      v39 = NormalResolvedDocSet(a6);
      v9 = v38;
      v16 = a1;
      LODWORD(a8) = v37;
      LODWORD(a7) = v36;
      *(_QWORD *)(a1 + 104) = v39;
    }
    if (v10 <= v11)
    {
      v40 = v9;
      v58 = a8;
      v63 = a2;
      v41 = *(_DWORD *)(v16 + 128);
      v42 = v41 & 0x7FFFFFFF;
      v43 = a7;
      if (v41 < 0)
      {
        if ((_DWORD)v42)
        {
          v48 = 0;
          v49 = 8 * v42;
          do
          {
            v50 = v16;
            v51 = ContentIndexDocSetGrabConstrainingVector(*(_QWORD *)(*(_QWORD *)(v16 + 120) + v48));
            if (v51)
              CIIndexSetRemoveRange(*(unsigned int **)(v50 + 104), v51, v10, v11);
            v48 += 8;
            v16 = v50;
          }
          while (v49 != v48);
        }
      }
      else if ((_DWORD)v42)
      {
        v44 = 0;
        v45 = 8 * (v41 & 0x7FFFFFFF);
        do
        {
          v46 = v16;
          v47 = (unsigned int *)ContentIndexDocSetGrabConstrainingVector(*(_QWORD *)(*(_QWORD *)(v16 + 120) + v44));
          if (v47)
            CIIndexSetIntersectRanges(*(_DWORD **)(v46 + 104), v47, v10, v11);
          v44 += 8;
          v16 = v46;
        }
        while (v45 != v44);
      }
      v20 = BulkPositionIterator_Step(*(_QWORD *)(v16 + 56), *(_QWORD *)(v16 + 112), v63, &v66, &v65, a5, *(_DWORD **)(v16 + 104), v43, v58, v40);
      v10 = v66;
      v17 = (int *)&unk_1EF19F000;
    }
    else
    {
      v20 = 0;
    }
    *v14 = v10;
    *v13 = v11;
    if (v17[813] >= 5)
    {
      v52 = *__error();
      v53 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109376;
        v68 = v10;
        v69 = 1024;
        v70 = v11;
        _os_log_impl(&dword_1B8270000, v53, OS_LOG_TYPE_DEFAULT, "actually from %d to %d", buf, 0xEu);
      }
      *__error() = v52;
    }
    return v20 & 1;
  }
  v22 = *(unsigned int *)(v16 + 96);
  if (!(_DWORD)v22)
  {
    v20 = 0;
    goto LABEL_27;
  }
  v23 = 0;
  v20 = 0;
  v60 = v14;
  v61 = v13;
  while (1)
  {
    *(_DWORD *)buf = *v14;
    v64 = *v13;
    v24 = *(_QWORD *)(*(_QWORD *)(v16 + 72) + 8 * v23);
    if (v24 != v16)
      break;
LABEL_12:
    if (++v23 >= v22)
      goto LABEL_27;
  }
  v25 = a2;
  v26 = a2;
  v27 = a5;
  v28 = a5;
  v29 = a6;
  v30 = a7;
  v31 = a8;
  v32 = v10;
  v33 = v11;
  v34 = v9;
  v35 = ContentIndexDocSetIteratorReadPositions(v24, v26, buf, &v64, v28);
  v9 = v34;
  v11 = v33;
  v20 |= v35;
  if (v32 <= *(_DWORD *)buf)
    v10 = *(_DWORD *)buf;
  else
    v10 = v32;
  if (v11 >= v64)
    v11 = v64;
  if (!*v9)
  {
    v16 = a1;
    v22 = *(unsigned int *)(a1 + 96);
    a7 = v30;
    a5 = v27;
    a2 = v25;
    v14 = v60;
    v13 = v61;
    a8 = v31;
    a6 = v29;
    goto LABEL_12;
  }
  v14 = v60;
  v13 = v61;
LABEL_27:
  *v14 = v10;
  *v13 = v11;
  return v20 & 1;
}

void ContentIndexDocSetIteratorProcessPositions(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  unsigned int v10;
  int v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t *v21;
  unint64_t v22;
  int v23;
  NSObject *v24;
  unint64_t v25;
  uint64_t v26;
  char v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;
  int v32;
  NSObject *v33;
  unint64_t v34;
  uint64_t v35;
  char v36;
  unint64_t v37;
  uint64_t v38;
  unsigned int v39;
  unsigned int v40;
  int *v41;
  int8x8_t v42;
  unsigned int locked;
  __int128 v44;
  int v45;
  int v46;
  int v48;
  NSObject *v49;
  int v50;
  NSObject *v51;
  unsigned int v52;
  int v53;
  NSObject *v54;
  unint64_t v55;
  unint64_t v56;
  uint64_t v57;
  BOOL v58;
  unsigned int v59;
  uint64_t v60;
  size_t v61;
  _DWORD **v62;
  size_t v63;
  uint64_t v64;
  uint64_t v65;
  _DWORD *v66;
  uint64_t v67;
  uint64_t v68;
  int v69;
  int v70;
  int v71;
  int *v72;
  size_t v73;
  _DWORD *v74;
  int v75;
  uint64_t v76;
  uint64_t v77;
  size_t v78;
  unint64_t v79;
  _DWORD *v80;
  _DWORD *v81;
  uint64_t v82;
  int v83;
  uint64_t v84;
  unint64_t v85;
  uint64_t v86;
  char *v87;
  uint64_t v88;
  int v89;
  unsigned int v90;
  unsigned int v91;
  unsigned int v92;
  unsigned int v93;
  unsigned int v94;
  _DWORD **v95;
  unsigned int v96;
  unsigned int v97;
  _DWORD *v98;
  unsigned int v99;
  _DWORD **v100;
  unsigned int v101;
  int v102;
  unsigned int v103;
  unsigned int v104;
  int *v105;
  unsigned int v106;
  unsigned int v107;
  int v108;
  uint64_t v109;
  _DWORD **v110;
  unsigned int v111;
  unsigned int v112;
  unsigned int v113;
  int *v114;
  unsigned int v115;
  unsigned int v116;
  int v117;
  unsigned int v118;
  unsigned int *v119;
  _DWORD *v120;
  unsigned int v121;
  unsigned int v122;
  unsigned int v123;
  unsigned int v124;
  int v125;
  unsigned int *v126;
  int8x8_t v127;
  unsigned int v128;
  unsigned int v129;
  uint64_t v130;
  unsigned int v131;
  int v132;
  unsigned int *v133;
  uint64_t v134;
  int v135;
  uint64_t v136;
  uint64_t v137;
  _DWORD *v138;
  unint64_t v139;
  int v140;
  uint64_t v141;
  _DWORD *v142;
  _DWORD **v143;
  int v144;
  int8x8_t v145;
  int v146;
  uint64_t v147;
  _DWORD **v148;
  _DWORD **v149;
  char HasIndex;
  unsigned int *v151;
  int v152;
  NSObject *v153;
  int v154;
  int v155;
  NSObject *v156;
  int v157;
  NSObject *v158;
  int v159;
  NSObject *v160;
  BOOL v161;
  unint64_t v162;
  uint64_t v163;
  uint64_t v164;
  unint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  unint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  int v173;
  NSObject *v174;
  uint64_t v175;
  unint64_t v176;
  uint64_t v177;
  uint64_t v178;
  unint64_t v179;
  uint64_t v180;
  os_log_t v181;
  __int128 v182;
  __int128 v183;
  int v184;
  _DWORD **v185;
  unint64_t v186;
  unsigned int v187;
  uint64_t *v188;
  _DWORD **v189;
  unsigned int v190;
  unint64_t v191;
  uint64_t v192;
  _QWORD *v193;
  unsigned int v194;
  uint64_t v195[128];
  uint8_t v196[4];
  unsigned int v197;
  __int16 v198;
  int v199;
  unint64_t buf;
  uint64_t v201;
  uint64_t v202;
  uint64_t block;
  uint64_t v204;
  void (*v205)(uint64_t);
  void *v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  int v210;
  char v211;
  uint64_t v212;

  v5 = a5;
  v212 = *MEMORY[0x1E0C80C00];
  if (dword_1EF19FCB4 >= 5)
  {
    v48 = *__error();
    v49 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(block) = 67109376;
      HIDWORD(block) = a3;
      LOWORD(v204) = 1024;
      *(_DWORD *)((char *)&v204 + 2) = a4;
      _os_log_impl(&dword_1B8270000, v49, OS_LOG_TYPE_DEFAULT, "from %d to %d", (uint8_t *)&block, 0xEu);
    }
    *__error() = v48;
    v5 = a5;
  }
  v10 = *(_DWORD *)(a1 + 48);
  if (v10 > 9)
    assert_invalid_doc_type((_DWORD *)a1);
  v11 = 1 << v10;
  if ((v11 & 0x10F) == 0)
  {
    if ((v11 & 0xF0) != 0)
    {
      if (*(_DWORD *)(a1 + 96))
      {
        v12 = 0;
        do
          ContentIndexDocSetIteratorProcessPositions(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8 * v12++), a2, a3, a4, v5);
        while (v12 < *(unsigned int *)(a1 + 96));
      }
      return;
    }
    LODWORD(v188) = v5;
    LODWORD(v189) = a3;
    v190 = a4;
    v192 = a1;
    v193 = a2;
    v13 = *(_QWORD *)(a1 + 112);
    v14 = *a2;
    v15 = *(unsigned int *)(v13 + 3348);
    if ((_DWORD)v15)
    {
      v16 = 0;
      v17 = *(_QWORD *)(a1 + 112);
      v191 = v17;
      do
      {
        v18 = v13 + 392 * v16;
        v19 = *(_QWORD *)(v18 + 408);
        if (*(_DWORD *)(v19 + 20))
        {
          v20 = 0;
          v21 = (uint64_t *)(v18 + 408);
          do
          {
            v22 = v17 + 4 * v20;
            v23 = *(_DWORD *)(v22 + 344);
            if (v23)
            {
              v24 = *(NSObject **)(v19 + 8 * v20 + 32);
              v25 = v17 + 8 * v20;
              v26 = *(_QWORD *)(v25 + 216);
              v27 = *(_BYTE *)(v19 + 19) ^ 1;
              block = MEMORY[0x1E0C809B0];
              v204 = 0x40000000;
              v205 = ___innerIssueBuffer_block_invoke;
              v206 = &__block_descriptor_tmp_63;
              v210 = v23;
              v207 = v14;
              v208 = v26;
              v211 = v27;
              v209 = 0;
              dispatch_async(v24, &block);
              *(_DWORD *)(v22 + 344) = 0;
              *(_QWORD *)(v25 + 216) = 0;
              v19 = *v21;
            }
            ++v20;
          }
          while (v20 < *(unsigned int *)(v19 + 20));
          v13 = v191;
          v15 = *(unsigned int *)(v191 + 3348);
        }
        ++v16;
        v17 += 392;
      }
      while (v16 < v15);
    }
    else
    {
      v28 = *(_QWORD *)(v13 + 408);
      if (*(_DWORD *)(v28 + 20))
      {
        v29 = 0;
        v30 = v13 + 344;
        v31 = MEMORY[0x1E0C809B0];
        do
        {
          v32 = *(_DWORD *)(v30 + 4 * v29);
          if (v32)
          {
            v33 = *(NSObject **)(v28 + 8 * v29 + 32);
            v34 = v30 + 8 * v29;
            v35 = *(_QWORD *)(v34 - 128);
            v36 = *(_BYTE *)(v28 + 19) ^ 1;
            block = v31;
            v204 = 0x40000000;
            v205 = ___innerIssueBuffer_block_invoke;
            v206 = &__block_descriptor_tmp_63;
            v210 = v32;
            v207 = v14;
            v208 = v35;
            v211 = v36;
            v209 = 0;
            dispatch_async(v33, &block);
            *(_DWORD *)(v30 + 4 * v29) = 0;
            *(_QWORD *)(v34 - 128) = 0;
            v28 = *(_QWORD *)(v13 + 408);
          }
          ++v29;
        }
        while (v29 < *(unsigned int *)(v28 + 20));
      }
    }
    if (*(_DWORD *)(v13 + 3180))
    {
      v37 = 0;
      do
        dispatch_barrier_sync(*(dispatch_queue_t *)(v13 + 3192 + 8 * v37++), &__block_literal_global_65);
      while (v37 < *(unsigned int *)(v13 + 3180));
    }
    dispatch_barrier_sync(*(dispatch_queue_t *)(v13 + 3184), &__block_literal_global_67);
    v38 = v192;
    v39 = v190;
    v40 = v189;
    if (!*(_QWORD *)(v192 + 80))
      *(_QWORD *)(v192 + 80) = CIIndexSetCreateWithRange(0, v188, 1);
    v41 = (int *)&unk_1EF19F000;
    if (v40 <= v39)
    {
      block = 0;
      v204 = 0;
      v205 = 0;
      _CIIndexSetInitializeEnumeratorForRange(*(_DWORD **)(v38 + 104), (uint64_t)&block, v40, v39);
      if (dword_1EF19FCB4 >= 5)
      {
        v50 = *__error();
        v51 = _SILogForLogForCategory(10);
        if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf) = 67109376;
          HIDWORD(buf) = (_DWORD)v189;
          LOWORD(v201) = 1024;
          *(_DWORD *)((char *)&v201 + 2) = v190;
          _os_log_impl(&dword_1B8270000, v51, OS_LOG_TYPE_DEFAULT, "Read range: %d %d", (uint8_t *)&buf, 0xEu);
        }
        *__error() = v50;
        v38 = v192;
        v41 = (_DWORD *)&unk_1EF19F000;
        v39 = v190;
        v40 = v189;
      }
      locked = lockedCountItemsInRange(*(_DWORD **)(v38 + 104), v40, v39, v42);
      if (v41[813] >= 5)
      {
        v52 = locked;
        v53 = *__error();
        v54 = _SILogForLogForCategory(10);
        if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf) = 67109120;
          HIDWORD(buf) = v52;
          _os_log_impl(&dword_1B8270000, v54, OS_LOG_TYPE_DEFAULT, "%d items", (uint8_t *)&buf, 8u);
        }
        *__error() = v53;
        v38 = v192;
        v41 = (_DWORD *)&unk_1EF19F000;
        locked = v52;
        v45 = *(_DWORD *)(v192 + 132);
        if (v45)
          goto LABEL_32;
      }
      else
      {
        v45 = *(_DWORD *)(v38 + 132);
        if (v45)
        {
LABEL_32:
          v46 = *(_DWORD *)(*(_QWORD *)(v38 + 136) + 4 * (v45 - 1));
LABEL_43:
          v184 = v46;
          v55 = 0;
          v190 = locked;
          v56 = locked;
          *(_QWORD *)&v44 = 67109120;
          v182 = v44;
          *(_QWORD *)&v44 = 67109376;
          v183 = v44;
          while (1)
          {
            while (1)
            {
              v57 = _CIIndexSetEnumeratorNext((unsigned int *)&block);
              v58 = (v57 - 1) > 0xFFFFFFFD || v55 >= v56;
              if (v58)
                goto LABEL_157;
              v59 = v57;
              buf = 0;
              v201 = 0;
              v202 = 0;
              v60 = *(_QWORD *)(**(_QWORD **)(v38 + 72) + 72);
              if (v55 < *(unsigned int *)(v60 + 168))
              {
                if (*(_QWORD *)(*(_QWORD *)(v60 + 160) + 8 * v55))
                  break;
              }
              if (v41[813] >= 5)
              {
                v152 = *__error();
                v153 = _SILogForLogForCategory(10);
                if (os_log_type_enabled(v153, OS_LOG_TYPE_DEFAULT))
                {
                  v154 = *(_DWORD *)(*(_QWORD *)(**(_QWORD **)(v38 + 72) + 72) + 168);
                  *(_DWORD *)v196 = v183;
                  v197 = v59;
                  v198 = 1024;
                  v199 = v154;
                  _os_log_impl(&dword_1B8270000, v153, OS_LOG_TYPE_DEFAULT, "!!! No: %d (size %d)", v196, 0xEu);
                }
                *__error() = v152;
                v41 = (_DWORD *)&unk_1EF19F000;
              }
              ++v55;
            }
            v188 = &v180;
            MEMORY[0x1E0C80A78](v57);
            v62 = (_DWORD **)((char *)&v180 - ((v61 + 15) & 0x7FFFFFFFF0));
            bzero(v62, v61);
            v63 = *(unsigned int *)(v38 + 96);
            bzero(v62, 40 * v63);
            if ((_DWORD)v63)
            {
              v64 = 0;
              v65 = *(_QWORD *)(v38 + 72);
              v66 = v62 + 1;
              while (1)
              {
                v67 = *(_QWORD *)(*(_QWORD *)(v65 + 8 * v64) + 72);
                if (*(_DWORD *)(v67 + 168) <= v55)
                  break;
                v68 = *(_QWORD *)(*(_QWORD *)(v67 + 160) + 8 * v55);
                *((_QWORD *)v66 - 1) = v68;
                *v66 = v64;
                if (!v68)
                  goto LABEL_45;
                ++v64;
                v66 += 10;
                if (v63 == v64)
                  goto LABEL_57;
              }
LABEL_157:
              bzero(v195, 0x400uLL);
              if (*(_DWORD *)(v38 + 96))
                v161 = v190 == 0;
              else
                v161 = 1;
              if (!v161)
              {
                v162 = 0;
                v163 = 0;
                v164 = *(_QWORD *)(v38 + 72);
                do
                {
                  v165 = 0;
                  v191 = v162;
                  v166 = *(_QWORD *)(*(_QWORD *)(v164 + 8 * v162) + 72);
                  v167 = *(_QWORD *)(v166 + 160);
                  do
                  {
                    if (v165 >= *(unsigned int *)(v166 + 168))
                      break;
                    v168 = *(_QWORD *)(v167 + 8 * v165);
                    if (v168)
                    {
                      if (v163 == 127)
                      {
                        v169 = v56;
                        v170 = 0;
                        v171 = 0;
                        do
                        {
                          v172 = v195[v170];
                          if (*(_DWORD *)(v172 + 16) <= 0xFFFFFFF6)
                          {
                            blob_free(*(_QWORD **)(v172 + 40), *(_DWORD *)(v172 + 32), v193);
                            *(_DWORD *)(v172 + 32) = 0;
                          }
                          *(_QWORD *)(v172 + 40) = v171;
                          ++v170;
                          v171 = v172;
                        }
                        while (v170 != 127);
                        cicachelistenqueue(*v193 + 8, v172, 20);
                        v163 = 0;
                        v41 = (int *)&unk_1EF19F000;
                        v56 = v169;
                      }
                      v195[v163++] = v168;
                    }
                    *(_QWORD *)(v167 + 8 * v165) = 0;
                    if (v41[813] >= 5)
                    {
                      v173 = *__error();
                      v174 = _SILogForLogForCategory(10);
                      if (os_log_type_enabled(v174, OS_LOG_TYPE_DEFAULT))
                      {
                        buf = __PAIR64__(v165, v183);
                        LOWORD(v201) = 1024;
                        *(_DWORD *)((char *)&v201 + 2) = v191;
                        _os_log_impl(&dword_1B8270000, v174, OS_LOG_TYPE_DEFAULT, "Cleaning up %d for child %d", (uint8_t *)&buf, 0xEu);
                      }
                      *__error() = v173;
                      v41 = (_DWORD *)&unk_1EF19F000;
                    }
                    ++v165;
                  }
                  while (v165 != v56);
                  v176 = v191;
                  v175 = v192;
                  v164 = *(_QWORD *)(v192 + 72);
                  v177 = *(_QWORD *)(*(_QWORD *)(v164 + 8 * v191) + 72);
                  if (v190 < *(_DWORD *)(v177 + 168))
                  {
                    v178 = 0;
                    v179 = v56;
                    do
                    {
                      *(_QWORD *)(*(_QWORD *)(v177 + 160) + v178) = *(_QWORD *)(*(_QWORD *)(v177 + 160) + 8 * v179);
                      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v175 + 72) + 8 * v176) + 72) + 160)
                                + 8 * v179++) = 0;
                      v164 = *(_QWORD *)(v175 + 72);
                      v177 = *(_QWORD *)(*(_QWORD *)(v164 + 8 * v176) + 72);
                      v178 += 8;
                    }
                    while (v179 < *(unsigned int *)(v177 + 168));
                  }
                  v162 = v176 + 1;
                }
                while (v162 < *(unsigned int *)(v175 + 96));
                if (v163)
                  CIIndexSetReleaseToCache(v195, v163, v193);
              }
              return;
            }
LABEL_57:
            v69 = *(_DWORD *)(v38 + 36);
            v187 = v59;
            v70 = v69;
            if (!v69)
              goto LABEL_66;
            if (v69 != 3)
              goto LABEL_75;
            if (*(_DWORD *)(v38 + 132))
            {
              *((_DWORD *)v62 + 4) = 0;
              if (v63 <= 1)
              {
                qsort(v62, v63, 0x28uLL, (int (__cdecl *)(const void *, const void *))compare_indexSetByCount);
                goto LABEL_126;
              }
              v71 = 0;
              v72 = *(int **)(v38 + 136);
              v73 = v63 - 1;
              v74 = v62 + 7;
              do
              {
                v75 = *v72++;
                v71 += v75;
                *v74 = v71;
                v74 += 10;
                --v73;
              }
              while (v73);
            }
            else
            {
LABEL_66:
              *((_DWORD *)v62 + 3) = 0;
              if (v63 < 2)
                goto LABEL_75;
              if ((_DWORD)v63 == 2)
              {
                v76 = 1;
                goto LABEL_73;
              }
              v77 = 0;
              v78 = v63 - 1;
              v79 = (v63 - 1) & 0xFFFFFFFFFFFFFFFELL;
              v80 = v62 + 12;
              do
              {
                *(v80 - 10) = v77 + 1;
                *v80 = v77 + 2;
                v80 += 20;
                v77 += 2;
              }
              while (v79 != v77);
              if (v78 != v79)
              {
                v76 = v78 | 1;
LABEL_73:
                v81 = &v62[5 * v76 + 2];
                do
                {
                  *v81 = v76;
                  v81 += 10;
                  ++v76;
                }
                while (v63 != v76);
              }
            }
LABEL_75:
            qsort(v62, v63, 0x28uLL, (int (__cdecl *)(const void *, const void *))compare_indexSetByCount);
            if (v70 && v70 != 3)
            {
              v82 = *(unsigned int *)(v38 + 96);
              v83 = v184;
              if (v82 >= 2)
              {
                v84 = 0;
                v85 = *(unsigned int *)(v38 + 132);
                v86 = v82 - 1;
                v87 = (char *)v62 + 52;
                do
                {
                  v88 = v84 + 1;
                  v89 = v83;
                  if (v84 + 1 <= v85)
                    v89 = *(_DWORD *)(*(_QWORD *)(v38 + 136) + 4 * v84);
                  *((_DWORD *)v87 + 3) = v89;
                  *(_QWORD *)v87 = 0;
                  v87[8] = 0;
                  v87 += 40;
                  ++v84;
                }
                while (v86 != v88);
              }
              *((_BYTE *)v62 + 20) = 0;
              *(_DWORD **)((char *)v62 + 12) = 0;
              _CIIndexSetInitializeEnumeratorForRange(*v62, (uint64_t)&buf, 0, 0x7FFFFFFFu);
              LODWORD(v191) = 0;
              v189 = v62 + 4;
              v90 = -1;
              v185 = v62 + 3;
              v186 = v59;
              while (1)
              {
                do
                {
                  v91 = _CIIndexSetEnumeratorNext((unsigned int *)&buf);
                  if (v91 - 1 > 0xFFFFFFFD)
                    goto LABEL_45;
                  v194 = v90;
                  v92 = *((_DWORD *)v62 + 2);
                  v93 = v92;
                  LODWORD(v62[5 * v92 + 2]) = v91;
                  v94 = *(_DWORD *)(v38 + 96);
                  v95 = &v62[5 * (int)v92];
                  v96 = *((_DWORD *)v95 + 4);
                  *(_DWORD **)((char *)v95 + 28) = (_DWORD *)vdup_n_s32(v96);
                  *((_BYTE *)v95 + 20) = 1;
                  if (v70 == 2)
                  {
                    if (v92 + 1 < v94)
                    {
                      v113 = v94 - 1;
                      v114 = (int *)&v189[5 * v92 + 5];
                      v115 = v96 + 1;
                      v116 = v92;
                      do
                      {
                        *((_BYTE *)v114 - 12) = 0;
                        v117 = *(v114 - 2) + LODWORD(v62[5 * v116 + 4]);
                        *(v114 - 1) = v115;
                        *v114 = v117;
                        ++v116;
                        v114 += 10;
                        ++v115;
                      }
                      while (v113 != v116);
                    }
                    if (v92)
                    {
                      v118 = 0;
                      v119 = (unsigned int *)&v185[5 * v92];
                      v120 = &v189[5 * v92 - 5];
                      do
                      {
                        *((_BYTE *)v120 - 12) = 0;
                        v121 = *(v120 - 1);
                        v122 = *v119;
                        v119 -= 10;
                        v58 = v121 >= v122;
                        v123 = v121 - v122;
                        if (v58)
                          v124 = v123;
                        else
                          v124 = 0;
                        ++v118;
                        v125 = v96 - v118;
                        if (v96 < v118)
                          v125 = 0;
                        *(v120 - 1) = v124;
                        *v120 = v125;
                        v120 -= 10;
                      }
                      while (v92 != v118);
                    }
                  }
                  else if (v70 == 1)
                  {
                    if (v92 + 1 < v94)
                    {
                      v97 = v94 - 1;
                      v98 = &v189[5 * v92 + 5];
                      v99 = v92;
                      do
                      {
                        *((_BYTE *)v98 - 12) = 0;
                        v100 = &v62[5 * v99];
                        v101 = *(v98 - 2);
                        v103 = *((_DWORD *)v100 + 7);
                        v102 = *((_DWORD *)v100 + 8);
                        v58 = v103 >= v101;
                        v104 = v103 - v101;
                        if (!v58)
                          v104 = 0;
                        *(v98 - 1) = v104;
                        *v98 = v102 + v101;
                        ++v99;
                        v98 += 10;
                      }
                      while (v97 != v99);
                    }
                    if (v92)
                    {
                      v105 = (int *)&v189[5 * v92];
                      v106 = v93 - 1;
                      do
                      {
                        v107 = *(v105 - 1);
                        v108 = *v105;
                        v105 -= 10;
                        v109 = v106;
                        v110 = &v62[5 * v106];
                        *((_BYTE *)v110 + 20) = 0;
                        v111 = *((_DWORD *)v110 + 6);
                        v58 = v107 >= v111;
                        v112 = v107 - v111;
                        if (!v58)
                          v112 = 0;
                        *((_DWORD *)v110 + 7) = v112;
                        *((_DWORD *)v110 + 8) = v108 + v111;
                        --v106;
                      }
                      while (v109);
                    }
                  }
                  if (*(_QWORD *)(v38 + 144))
                    v126 = &v194;
                  else
                    v126 = 0;
                }
                while (!checkNearness(1u, v38, v91, (uint64_t)v62, v91, v91, v126, v70));
                v128 = v194;
                v129 = ++v194;
                v130 = *(_QWORD *)(v38 + 144);
                if (v130 && v129 < v90)
                {
                  changesSetMinCount(v130, v186, v128 + 1);
                  v90 = v129;
                }
                v131 = v187;
                if (v41[813] >= 5)
                {
                  v132 = *__error();
                  v181 = (os_log_t)_SILogForLogForCategory(10);
                  if (os_log_type_enabled(v181, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)v196 = v182;
                    v197 = v131;
                    _os_log_impl(&dword_1B8270000, v181, OS_LOG_TYPE_DEFAULT, "Yes: %d", v196, 8u);
                  }
                  *__error() = v132;
                  v41 = (_DWORD *)&unk_1EF19F000;
                  if ((v191 & 1) != 0)
                  {
LABEL_117:
                    if (!*(_QWORD *)(v38 + 144))
                      goto LABEL_45;
                    goto LABEL_123;
                  }
                }
                else if ((v191 & 1) != 0)
                {
                  goto LABEL_117;
                }
                v133 = *(unsigned int **)(v38 + 80);
                *(_DWORD *)v196 = -1;
                _CIIndexSetAddIndex(v133, v131, 0, v196, v127);
                if (!*(_QWORD *)(v38 + 144))
                  goto LABEL_45;
LABEL_123:
                if (v90 == *(_DWORD *)(v38 + 96))
                  goto LABEL_45;
                LODWORD(v191) = 1;
              }
            }
LABEL_126:
            v134 = *(unsigned int *)(v38 + 96);
            if (v134 < 2)
              goto LABEL_135;
            v135 = *((_DWORD *)v62 + 4);
            if ((_DWORD)v134 == 2)
            {
              v136 = 1;
              goto LABEL_133;
            }
            v137 = v134 - 1;
            v138 = v62 + 12;
            v139 = (v134 - 1) & 0xFFFFFFFFFFFFFFFELL;
            do
            {
              v140 = *v138 - v135;
              *(v138 - 11) = *(v138 - 10) - v135;
              *(v138 - 1) = v140;
              v138 += 20;
              v139 -= 2;
            }
            while (v139);
            if (v137 != ((v134 - 1) & 0xFFFFFFFFFFFFFFFELL))
            {
              v136 = v137 | 1;
LABEL_133:
              v141 = v134 - v136;
              v142 = &v62[5 * v136 + 2];
              do
              {
                *(v142 - 1) = *v142 - v135;
                v142 += 10;
                --v141;
              }
              while (v141);
            }
LABEL_135:
            *((_DWORD *)v62 + 3) = 0;
            _CIIndexSetInitializeEnumeratorForRange(*v62, (uint64_t)&buf, 0, 0x7FFFFFFFu);
            if (v41[813] > 4)
            {
              v155 = *__error();
              v156 = _SILogForLogForCategory(10);
              if (os_log_type_enabled(v156, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)v196 = v183;
                v197 = buf;
                v198 = 1024;
                v199 = HIDWORD(buf);
                _os_log_impl(&dword_1B8270000, v156, OS_LOG_TYPE_DEFAULT, "Enumerator for range: %d %d", v196, 0xEu);
              }
              *__error() = v155;
              v59 = v187;
            }
            v143 = v62 + 5;
LABEL_137:
            v144 = _CIIndexSetEnumeratorNext((unsigned int *)&buf);
            if ((v144 + 1) < 2)
            {
              buf = 0xFFFFFFFF00000000;
              v41 = (int *)&unk_1EF19F000;
              v38 = v192;
              if (dword_1EF19FCB4 >= 5)
              {
                v159 = *__error();
                v160 = _SILogForLogForCategory(10);
                if (os_log_type_enabled(v160, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)v196 = v182;
                  v197 = v187;
                  _os_log_impl(&dword_1B8270000, v160, OS_LOG_TYPE_DEFAULT, "No: %d", v196, 8u);
                }
                *__error() = v159;
                v38 = v192;
                v41 = (_DWORD *)&unk_1EF19F000;
              }
            }
            else
            {
              v146 = v144;
              v147 = 0;
              v148 = v143;
              while (1)
              {
                v38 = v192;
                if (++v147 >= (unint64_t)*(unsigned int *)(v192 + 96))
                  break;
                v149 = v148 + 5;
                if (*v148)
                {
                  HasIndex = CIIndexSetHasIndex((uint64_t)*v148, *((_DWORD *)v148 + 3) + v146);
                  v148 = v149;
                  if ((HasIndex & 1) != 0)
                    continue;
                }
                goto LABEL_137;
              }
              v41 = (int *)&unk_1EF19F000;
              if (dword_1EF19FCB4 >= 5)
              {
                v157 = *__error();
                v158 = _SILogForLogForCategory(10);
                if (os_log_type_enabled(v158, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)v196 = v182;
                  v197 = v187;
                  _os_log_impl(&dword_1B8270000, v158, OS_LOG_TYPE_DEFAULT, "Yes: %d", v196, 8u);
                }
                *__error() = v157;
                v38 = v192;
                v41 = (_DWORD *)&unk_1EF19F000;
                v59 = v187;
              }
              v151 = *(unsigned int **)(v38 + 80);
              *(_DWORD *)v196 = -1;
              _CIIndexSetAddIndex(v151, v59, 0, v196, v145);
              buf = 0xFFFFFFFF00000000;
            }
LABEL_45:
            ++v55;
          }
        }
      }
      v46 = 5;
      goto LABEL_43;
    }
  }
}

uint64_t compare_indexSetByCount(_DWORD **a1, uint64_t a2, int8x8_t a3)
{
  _DWORD *v3;
  _DWORD *v4;
  int v5;
  int v6;
  unsigned int v7;
  int locked;
  int8x8_t v10;

  v3 = *a1;
  v4 = *(_DWORD **)a2;
  v5 = v3[4];
  v6 = *(_DWORD *)(*(_QWORD *)a2 + 16);
  if (v5 == -1)
  {
    if (v6 == -1)
    {
      locked = lockedCountItemsInRange(v3, v3[5], v3[6], a3);
      return locked - lockedCountItemsInRange(v4, v4[5], v4[6], v10);
    }
    else
    {
      return 1;
    }
  }
  else
  {
    v7 = v5 - v6;
    if (v6 == -1)
      return 0xFFFFFFFFLL;
    else
      return v7;
  }
}

uint64_t checkNearness(unsigned int a1, uint64_t a2, int a3, uint64_t a4, unsigned int a5, unsigned int a6, unsigned int *a7, int a8)
{
  _DWORD *v9;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int *v19;
  unsigned int v20;
  int v21;
  char v22;
  _DWORD *v23;
  uint64_t v24;
  int v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int *v30;
  uint64_t v31;
  unsigned int v32;
  unsigned int v33;
  int v34;
  unsigned int *v35;
  unsigned int v36;
  uint64_t v37;
  unsigned int v38;
  uint64_t v39;
  _DWORD *v40;
  unsigned int v41;
  uint64_t v42;
  unsigned int v43;
  int v44;
  unsigned int v45;
  unsigned int v46;
  unsigned __int8 *v47;
  unsigned __int8 *v48;
  uint64_t v49;
  int v50;
  unsigned int v51;
  unsigned int v52;
  int v53;
  unsigned int v54;
  uint64_t v55;
  uint64_t v56;
  _DWORD *v57;
  unsigned int v58;
  unsigned int *v59;
  unsigned int v60;
  unsigned int v61;
  uint64_t v62;
  unsigned int v63;
  unsigned int v64;
  unsigned int v65;
  int v66;
  uint64_t v67;
  unsigned int v68;
  uint64_t v69;
  unsigned int v70;
  unsigned int v71;
  unsigned int v72;
  unsigned int v73;
  BOOL v74;
  unsigned int v75;
  unsigned int v76;
  unsigned int v77;
  unsigned int v78;
  unsigned int v79;
  _DWORD *v80;
  uint64_t v81;
  unsigned int v82;
  unsigned int v83;
  unsigned int v84;
  unsigned int v85;
  unsigned int v86;
  _DWORD *v88;
  uint64_t v89;
  unsigned int v90;
  unsigned int v91;
  unsigned int *v94;
  char v95;
  uint64_t v96;
  uint64_t v97;
  unsigned int v98;
  unsigned int v99;
  _QWORD v100[4];

  v9 = *(_DWORD **)(a4 + 40 * a1);
  if (!v9)
  {
    v22 = 0;
    return v22 & 1;
  }
  v99 = a1;
  v16 = a1;
  v17 = *(unsigned int *)(a2 + 96);
  memset(v100, 0, 24);
  v18 = a4 + 40 * a1;
  v20 = *(_DWORD *)(v18 + 8);
  v19 = (unsigned int *)(v18 + 8);
  _CIIndexSetInitializeEnumeratorForRange(v9, (uint64_t)v100, *(_DWORD *)(a4 + 40 * v20 + 28), *(_DWORD *)(a4 + 40 * v20 + 32));
  v94 = a7;
  if (a7)
    v21 = *a7;
  else
    v21 = -1;
  v98 = v21;
  v95 = 0;
  v23 = (_DWORD *)(a4 + 40 * v16 + 12);
  v24 = v99 + 1;
  v97 = (_DWORD)v17 - 2 - v99 + 1;
  v96 = a4 + 32;
  while (1)
  {
LABEL_14:
    v27 = _CIIndexSetEnumeratorNext((unsigned int *)v100);
    if ((v27 - 1) > 0xFFFFFFFD)
      goto LABEL_103;
    if ((_DWORD)v27 == a3)
      continue;
    *v23 = v27;
    v28 = *v19;
    *(_DWORD *)(a4 + 40 * v28 + 16) = v27;
    if (v24 < v17)
    {
      v29 = v99 + 1;
      if ((_DWORD)v17 - 2 == v99)
        goto LABEL_21;
      v30 = (unsigned int *)(a4 + 40 * v24 + 48);
      v31 = v97 & 0x1FFFFFFFELL;
      do
      {
        v32 = *(v30 - 10);
        v33 = *v30;
        v30 += 20;
        *(_BYTE *)(a4 + 40 * v32 + 20) = 0;
        *(_BYTE *)(a4 + 40 * v33 + 20) = 0;
        v31 -= 2;
      }
      while (v31);
      v29 = (v97 & 0x1FFFFFFFELL) + v24;
      if (v97 != (v97 & 0x1FFFFFFFELL))
      {
LABEL_21:
        v34 = v17 - v29;
        v35 = (unsigned int *)(a4 + 8 + 40 * v29);
        do
        {
          v36 = *v35;
          v35 += 10;
          *(_BYTE *)(a4 + 40 * v36 + 20) = 0;
          --v34;
        }
        while (v34);
      }
    }
    v37 = a4 + 40 * (int)v28;
    v38 = *(_DWORD *)(v37 + 16);
    *(int32x2_t *)(v37 + 28) = vdup_n_s32(v38);
    *(_BYTE *)(v37 + 20) = 1;
    switch(a8)
    {
      case 0:
      case 3:
        continue;
      case 1:
        v39 = (v28 + 1);
        if (v39 >= v17)
          goto LABEL_30;
        v40 = (_DWORD *)(v96 + 40 * v39);
        v41 = v28;
        do
        {
          if (*((_BYTE *)v40 - 12))
          {
            v67 = a4 + 40 * v39;
            v68 = *(_DWORD *)(v67 + 16);
            goto LABEL_55;
          }
          v42 = a4 + 40 * v41;
          v43 = *(v40 - 2);
          v45 = *(_DWORD *)(v42 + 28);
          v44 = *(_DWORD *)(v42 + 32);
          v74 = v45 >= v43;
          v46 = v45 - v43;
          if (!v74)
            v46 = 0;
          *(v40 - 1) = v46;
          *v40 = v44 + v43;
          ++v39;
          ++v41;
          v40 += 10;
        }
        while (v17 != v39);
LABEL_30:
        if (!(_DWORD)v28)
          goto LABEL_7;
        v47 = (unsigned __int8 *)(a4 - 20 + 40 * v28);
        v48 = v47;
        while (1)
        {
          v49 = v28 - 1;
          v50 = *v48;
          v48 -= 40;
          if (v50)
            break;
          v51 = *((_DWORD *)v47 + 1);
          v52 = *((_DWORD *)v47 + 12);
          v53 = *((_DWORD *)v47 + 13);
          v74 = v52 >= v51;
          v54 = v52 - v51;
          if (!v74)
            v54 = 0;
          *((_DWORD *)v47 + 2) = v54;
          *((_DWORD *)v47 + 3) = v53 + v51;
          v47 = v48;
          v28 = v49;
          if (!v49)
            goto LABEL_7;
        }
        v68 = *(_DWORD *)(a4 + 40 * v49 + 16);
        v67 = a4 + 40 * v28;
LABEL_55:
        v71 = *(_DWORD *)(v67 + 24);
        v72 = v38 - v71;
        if (v38 < v71)
          v72 = 0;
        v73 = v71 + v38;
        v74 = v68 <= v72 || v68 >= v73;
        if (!v74)
          goto LABEL_7;
        continue;
      case 2:
        v55 = (v28 + 1);
        if (v55 >= v17)
          goto LABEL_41;
        v56 = 0;
        v57 = (_DWORD *)(v96 + 40 * v55);
        break;
      default:
        goto LABEL_7;
    }
    do
    {
      if (*((_BYTE *)v57 - 12))
      {
        v69 = v55 + v56;
        v70 = *(_DWORD *)(a4 + 40 * (v55 + v56) + 16);
        if (v70 > v38 && v70 < *(_DWORD *)(a4 + 40 * v69 + 24) + v38)
          goto LABEL_7;
        goto LABEL_14;
      }
      *v57 = *(v57 - 2) + *(_DWORD *)(a4 + 40 * (v28 + v56) + 32);
      *(v57 - 1) = v38 + v56++ + 1;
      v57 += 10;
    }
    while (v55 - v17 + v56);
LABEL_41:
    if (!(_DWORD)v28)
      break;
    v58 = 0;
    v59 = (unsigned int *)(a4 + 24 + 40 * v28);
    v60 = v28;
    while (1)
    {
      v61 = v60 - 1;
      if (*(_BYTE *)(a4 + 40 * (v60 - 1) + 20))
        break;
      v62 = a4 + 40 * v61;
      v63 = *(_DWORD *)(v62 + 28);
      v64 = *v59;
      v59 -= 10;
      v74 = v63 >= v64;
      v65 = v63 - v64;
      if (!v74)
        v65 = 0;
      ++v58;
      v66 = v38 - v58;
      if (v38 < v58)
        v66 = 0;
      *(_DWORD *)(v62 + 28) = v65;
      *(_DWORD *)(v62 + 32) = v66;
      --v60;
      if ((_DWORD)v28 == v58)
        goto LABEL_7;
    }
    v75 = *(_DWORD *)(a4 + 40 * v61 + 16);
    if (v75 < v38)
    {
      v76 = *(_DWORD *)(a4 + 40 * v60 + 24);
      v74 = v38 >= v76;
      v77 = v38 - v76;
      if (!v74)
        v77 = 0;
      if (v75 > v77)
        break;
    }
  }
LABEL_7:
  if (v27 >= a5)
    v25 = a5;
  else
    v25 = v27;
  if (v27 <= a6)
    v26 = a6;
  else
    v26 = v27;
  if (v26 - v25 > v98)
    goto LABEL_14;
  if (v24 >= v17)
  {
    v79 = *(_DWORD *)(a4 + 16);
    switch(a8)
    {
      case 0:
      case 3:
        goto LABEL_14;
      case 1:
        v80 = (_DWORD *)(a4 + 64);
        v81 = v17 - 1;
        v82 = *(_DWORD *)(a4 + 16);
        v83 = v82;
        if (v17 < 2)
          goto LABEL_96;
        while (1)
        {
          v84 = *(v80 - 2);
          v85 = v83 - *v80;
          if (v83 < *v80)
            v85 = 0;
          v86 = *v80 + v83;
          if (v84 <= v85 || v84 >= v86)
            goto LABEL_14;
          v80 += 10;
          if (v82 >= v84)
            v82 = v84;
          if (v79 <= v84)
            v79 = v84;
          v83 = v84;
          if (!--v81)
            goto LABEL_96;
        }
      case 2:
        if (v17 < 2)
          goto LABEL_95;
        v88 = (_DWORD *)(a4 + 64);
        v89 = v17 - 1;
        v82 = *(_DWORD *)(a4 + 16);
        v90 = v82;
        break;
      default:
LABEL_95:
        v82 = *(_DWORD *)(a4 + 16);
        goto LABEL_96;
    }
    do
    {
      v91 = *(v88 - 2);
      if (v91 <= v90 || v91 >= *v88 + v90)
        goto LABEL_14;
      if (v82 >= v91)
        v82 = *(v88 - 2);
      if (v79 <= v91)
        v79 = *(v88 - 2);
      v88 += 10;
      v90 = v91;
      --v89;
    }
    while (v89);
LABEL_96:
    if (v94)
    {
      v78 = v79 - v82;
      if (*v94 < v78)
        v78 = *v94;
      *v94 = v78;
      goto LABEL_100;
    }
LABEL_102:
    v95 = 1;
    goto LABEL_103;
  }
  if (!checkNearness(v24, a2, v27, a4))
    goto LABEL_14;
  if (!v94)
    goto LABEL_102;
  v78 = *v94;
LABEL_100:
  v95 = 1;
  if (v78 + 1 != (_DWORD)v17)
    goto LABEL_14;
LABEL_103:
  v22 = v95;
  return v22 & 1;
}

_DWORD *ContentIndexDocSetIteratorPreProcessNode(uint64_t a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  uint64_t v8;
  unsigned int v9;
  int v10;
  unint64_t v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  void (*v17)(_QWORD);
  _DWORD *v18;
  int v19;
  NSObject *v20;
  void *v21;
  void *v22;
  uint64_t v23;
  _DWORD *v24;
  _DWORD *v25;
  unsigned int v26;
  _DWORD *result;
  unsigned int v28;
  uint64_t v29;
  unint64_t v30;
  unsigned int v31;
  unsigned int v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  void (*v36)(_QWORD);
  int8x8_t v37;
  int v38;
  NSObject *v39;
  void *v40;
  void *v41;
  uint64_t v42;
  _DWORD *v43;
  _DWORD *v44;
  unsigned int v45;
  int v46;
  NSObject *v47;
  os_log_type_t v48;
  int v49;
  _DWORD *v50;
  int8x8_t v51;
  uint64_t v52;
  unsigned int v53;
  uint64_t v54;
  void (*v55)(_QWORD);
  uint64_t v56;
  unsigned int v57;
  uint64_t v58;
  void (*v59)(_QWORD);
  uint64_t v60;
  size_t v61;
  char *v62;
  uint64_t v63;
  uint64_t v64;
  unint64_t v65;
  _DWORD *v66;
  _DWORD *v67;
  int8x8_t v68;
  _DWORD *v69;
  _DWORD *v70;
  unsigned int v71;
  unsigned int v72;
  uint64_t v73;
  unsigned int v74;
  _DWORD *v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  _QWORD v80[2];
  uint64_t v81;
  unsigned int v82;
  unint64_t v83;
  unint64_t v84;
  unint64_t v85;
  unint64_t v86;
  unint64_t v87;
  unint64_t v88;
  unint64_t v89;
  unint64_t v90;
  uint8_t buf[4];
  const char *v92;
  __int16 v93;
  int v94;
  uint64_t v95;

  v95 = *MEMORY[0x1E0C80C00];
  makeThreadId();
  v8 = *(_QWORD *)(a1 + 56);
  if (*(_BYTE *)(v8 + 8))
  {
    do
    {
      v9 = __ldxr(exceptionSequenceNum);
      v10 = v9 + 1;
    }
    while (__stxr(v9 + 1, exceptionSequenceNum));
    v11 = setThreadIdAndInfo(-1, (__int128 *)sIndexExceptionCallbacks, v8, 0, v10);
    v90 = __PAIR64__(v11, HIDWORD(v11));
    v89 = __PAIR64__(v12, v13);
    v14 = *(_QWORD *)&threadData[18 * v11 + 2];
    v15 = v14 + 320 * HIDWORD(v11);
    *(_BYTE *)(v15 + 216) = 0;
    v16 = *(_DWORD *)(v15 + 312);
    v17 = *(void (**)(_QWORD))(v15 + 224);
    if (v17)
      v17(*(_QWORD *)(v14 + 320 * HIDWORD(v11) + 288));
    v88 = v90;
    v87 = v89;
    if (_setjmp((int *)v15))
    {
      v18 = (_DWORD *)(v15 + 312);
      v19 = *__error();
      v20 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        v92 = "ContentIndexDocSetIteratorPreProcessNode";
        v93 = 1024;
        v94 = 3392;
        _os_log_error_impl(&dword_1B8270000, v20, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
      }
      *__error() = v19;
      *v18 = v16;
      if (__THREAD_SLOT_KEY)
      {
        v21 = pthread_getspecific(__THREAD_SLOT_KEY);
        if (!v21)
          goto LABEL_88;
      }
      else
      {
        makeThreadId();
        v21 = pthread_getspecific(__THREAD_SLOT_KEY);
        if (!v21)
          goto LABEL_88;
      }
      v22 = v21;
      if ((unint64_t)v21 < 0x801)
      {
LABEL_11:
        v23 = (uint64_t)v22 - 1;
        v24 = &threadData[18 * ((uint64_t)v22 - 1)];
        v26 = v24[14];
        v25 = v24 + 14;
        if (v26 > v87)
        {
          do
            CIOnThreadCleanUpPop(v23);
          while (*v25 > v87);
        }
        dropThreadId(HIDWORD(v88), 1, v10);
        result = (_DWORD *)CICleanUpReset(HIDWORD(v88), HIDWORD(v87));
        goto LABEL_43;
      }
LABEL_88:
      makeThreadId();
      v22 = pthread_getspecific(__THREAD_SLOT_KEY);
      goto LABEL_11;
    }
    do
    {
      v28 = __ldxr(exceptionSequenceNum);
      v29 = v28 + 1;
    }
    while (__stxr(v29, exceptionSequenceNum));
    v30 = setThreadIdAndInfo(-1, sAssertExceptionCallbacks, 0, 0, v29);
    v86 = __PAIR64__(v30, HIDWORD(v30));
    v85 = __PAIR64__(v31, v32);
    v33 = *(_QWORD *)&threadData[18 * v30 + 2];
    v34 = v33 + 320 * HIDWORD(v30);
    v35 = *(_DWORD *)(v34 + 312);
    v36 = *(void (**)(_QWORD))(v34 + 224);
    if (v36)
      v36(*(_QWORD *)(v33 + 320 * HIDWORD(v30) + 288));
    v84 = v86;
    v83 = v85;
    if (!_setjmp((int *)v34))
    {
      switch(*(_DWORD *)(a1 + 48))
      {
        case 0:
        case 1:
        case 2:
        case 3:
        case 8:
          goto LABEL_30;
        case 4:
          if (!*(_QWORD *)(a1 + 104))
            *(_QWORD *)(a1 + 104) = NormalResolvedDocSet(a4);
          if (*(_DWORD *)(a1 + 96))
          {
            v65 = 0;
            do
            {
              v66 = (_DWORD *)ContentIndexDocSetGrabConstrainingVector(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8 * v65));
              if (v66)
                CIIndexSetAddRange(*(unsigned int **)(a1 + 104), v66, a2, a3, v37);
              ++v65;
            }
            while (v65 < *(unsigned int *)(a1 + 96));
          }
          goto LABEL_30;
        case 5:
        case 9:
          v60 = *(unsigned int *)(a1 + 96);
          if (!*(_QWORD *)(a1 + 104))
            *(_QWORD *)(a1 + 104) = NormalResolvedDocSet(a4);
          if (!(_DWORD)v60)
            goto LABEL_30;
          v80[1] = v80;
          v81 = v60;
          v61 = 8 * v60;
          MEMORY[0x1E0C80A78](v80);
          v62 = (char *)v80 - ((8 * v60 + 15) & 0xFFFFFFFF0);
          bzero((char *)v80 - ((v61 + 15) & 0xFFFFFFFF0), v61);
          v63 = 0;
          break;
        case 6:
          if (*(_DWORD *)(a1 + 96))
          {
            if (!*(_QWORD *)(a1 + 104))
              *(_QWORD *)(a1 + 104) = NormalResolvedDocSet(a4);
            v67 = (_DWORD *)ContentIndexDocSetGrabConstrainingVector(**(_QWORD **)(a1 + 72));
            _CIIndexSetClearRange(*(int **)(a1 + 104), a2, a3);
            if (v67)
              CIIndexSetAddRange(*(unsigned int **)(a1 + 104), v67, a2, a3, v68);
            CIIndexSetInvertRange(*(_QWORD *)(a1 + 104), a2, a3);
          }
          goto LABEL_30;
        case 7:
          if (*(_DWORD *)(a1 + 96))
          {
            if (!*(_QWORD *)(a1 + 104))
              *(_QWORD *)(a1 + 104) = NormalResolvedDocSet(a4);
            v69 = (_DWORD *)ContentIndexDocSetGrabConstrainingVector(**(_QWORD **)(a1 + 72));
            if (v69)
            {
              v70 = v69;
              if (v69[4] != -1 && lockedCountItemsInRange(v69, a2, a3, v37) >> 13)
              {
                CIIndexSetAddRange(*(unsigned int **)(a1 + 104), v70, a2, a3, v37);
                if (*(_DWORD *)(a1 + 96) >= 2u)
                {
                  v78 = 1;
                  do
                  {
                    v79 = ContentIndexDocSetGrabConstrainingVector(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8 * v78));
                    if (v79)
                      CIIndexSetRemoveRange(*(unsigned int **)(a1 + 104), v79, a2, a3);
                    ++v78;
                  }
                  while (v78 < *(unsigned int *)(a1 + 96));
                }
              }
              else
              {
                v71 = a3 - 0x2000;
                v82 = a2 + 0x2000;
                if (a2 + 0x2000 >= a3)
                  v71 = a2;
                v72 = a3;
                do
                {
                  v73 = v29;
                  v74 = v71;
                  v75 = v70;
                  CIIndexSetAddRange(*(unsigned int **)(a1 + 104), v70, v71, v72, v37);
                  if (*(_DWORD *)(a1 + 96) >= 2u)
                  {
                    v76 = 1;
                    do
                    {
                      v77 = ContentIndexDocSetGrabConstrainingVector(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8 * v76));
                      if (v77)
                        CIIndexSetRemoveRange(*(unsigned int **)(a1 + 104), v77, v74, v72);
                      ++v76;
                    }
                    while (v76 < *(unsigned int *)(a1 + 96));
                  }
                  v71 = v74 - 0x2000;
                  if (v74 <= v82)
                    v71 = a2;
                  v72 = v74;
                  v70 = v75;
                  v29 = v73;
                }
                while (v74 > a2);
              }
            }
          }
          goto LABEL_30;
        default:
          assert_invalid_doc_type((_DWORD *)a1);
      }
      while (1)
      {
        v64 = ContentIndexDocSetGrabConstrainingVector(*(_QWORD *)(*(_QWORD *)(a1 + 72) + v63));
        if (!v64)
          break;
        *(_QWORD *)&v62[v63] = v64;
        v63 += 8;
        if (v61 == v63)
        {
          CIIndexSetAddIntersectionInRange(*(unsigned int **)(a1 + 104), (_QWORD *)((char *)v80 - ((v61 + 15) & 0xFFFFFFFF0)), v81, a2, a3);
          break;
        }
      }
LABEL_30:
      if (a2 == 1)
      {
        v49 = *(_DWORD *)(a1 + 48);
        if (v49 == 9 || (v49 & 0xFFFFFFFC) == 4)
        {
          v50 = *(_DWORD **)(a1 + 104);
          if (v50)
          {
            if ((int)v50[4] <= -10)
            {
              _CIIndexSetConvertIfArrayIsMuchMoreEfficient(*(int **)(a1 + 104), v50[5], v50[6], 0, 0, v37);
              if ((int)v50[4] <= -10)
                _CIIndexSetConvertIfInvertedArrayIsMoreEfficient(v50, 0, v51);
            }
          }
        }
      }
      v52 = *(_QWORD *)&threadData[18 * HIDWORD(v84) + 2];
      v53 = v84;
      v54 = v52 + 320 * v84;
      *(_DWORD *)(v54 + 312) = v35;
      v55 = *(void (**)(_QWORD))(v54 + 232);
      if (v55)
        v55(*(_QWORD *)(v52 + 320 * v53 + 288));
      dropThreadId(HIDWORD(v84), 0, v29);
      goto LABEL_40;
    }
    v38 = *__error();
    v39 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v92 = "ContentIndexDocSetIteratorPreProcessNode";
      v93 = 1024;
      v94 = 3391;
      _os_log_error_impl(&dword_1B8270000, v39, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
    }
    *__error() = v38;
    *(_DWORD *)(v34 + 312) = v35;
    if (__THREAD_SLOT_KEY)
    {
      v40 = pthread_getspecific(__THREAD_SLOT_KEY);
      if (!v40)
        goto LABEL_90;
    }
    else
    {
      makeThreadId();
      v40 = pthread_getspecific(__THREAD_SLOT_KEY);
      if (!v40)
        goto LABEL_90;
    }
    v41 = v40;
    if ((unint64_t)v40 < 0x801)
    {
LABEL_23:
      v42 = (uint64_t)v41 - 1;
      v43 = &threadData[18 * ((uint64_t)v41 - 1)];
      v45 = v43[14];
      v44 = v43 + 14;
      if (v45 > v83)
      {
        do
          CIOnThreadCleanUpPop(v42);
        while (*v44 > v83);
      }
      dropThreadId(HIDWORD(v84), 1, v29);
      CICleanUpReset(HIDWORD(v84), HIDWORD(v83));
LABEL_40:
      v56 = *(_QWORD *)&threadData[18 * HIDWORD(v88) + 2];
      v57 = v88;
      v58 = v56 + 320 * v88;
      *(_DWORD *)(v58 + 312) = v16;
      v59 = *(void (**)(_QWORD))(v58 + 232);
      if (v59)
        v59(*(_QWORD *)(v56 + 320 * v57 + 288));
      result = (_DWORD *)dropThreadId(HIDWORD(v88), 0, v10);
      goto LABEL_43;
    }
LABEL_90:
    makeThreadId();
    v41 = pthread_getspecific(__THREAD_SLOT_KEY);
    goto LABEL_23;
  }
  v46 = *__error();
  v47 = _SILogForLogForCategory(0);
  v48 = 2 * (gSILogLevels[0] < 4);
  if (os_log_type_enabled(v47, v48))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1B8270000, v47, v48, "Skipping because index is shut down", buf, 2u);
  }
  result = __error();
  *result = v46;
LABEL_43:
  *(_BYTE *)(a1 + 32) = 1;
  return result;
}

void hybridScoringL1(uint64_t a1, _QWORD *a2, uint64_t a3, int a4, uint64_t a5, unsigned int a6, float *a7, uint8_t *a8, float a9, int *a10)
{
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  float v22;
  int v23;
  unsigned __int8 v25;

  v25 = 0;
  v18 = a2[13];
  if (v18)
  {
    distanceHolderGetMinDistance(v18, *(_QWORD *)(a3 + 72) + a1, &v25);
    v19 = v25;
    v20 = a2[14];
    if (!v20)
      goto LABEL_4;
    goto LABEL_3;
  }
  v19 = 0;
  v20 = a2[14];
  if (v20)
  {
LABEL_3:
    v25 = 0;
    distanceHolderGetMinDistance(v20, *(_QWORD *)(a3 + 72) + a1, &v25);
    v19 = v25;
  }
LABEL_4:
  v21 = a2[15];
  if (v21)
  {
    v25 = 0;
    distanceHolderGetMinDistance(v21, *(_QWORD *)(a3 + 72) + a1, &v25);
    v19 = v25;
  }
  v22 = 0.0;
  if (a5 && a4 && a7 && a8)
  {
    if (!v19)
      v22 = a9;
    v22 = ContentIndexDocSetComputeScore(a5, a1, a6, a8, v22);
    *a7 = v22;
  }
  *a10 = v22 != 0.0;
  if (v19)
  {
    if (v22 == 0.0)
      v23 = 2;
    else
      v23 = 3;
    goto LABEL_17;
  }
  if (v22 == 0.0)
  {
    v23 = 1;
LABEL_17:
    *a10 = v23;
  }
}

BOOL ci_lt_l1_score(uint64_t a1, unint64_t a2, unint64_t a3, unsigned int a4, float a5, float a6)
{
  float v6;
  float v8;

  if (*(_BYTE *)(a1 + 69))
  {
    v6 = *(float *)(a1 + 60);
    if (v6 < a5)
      return 1;
    if (v6 != a5)
      return 0;
  }
  else
  {
    if (*(_OWORD *)a1 < __PAIR128__(a3, a2))
      return 1;
    if (*(_QWORD *)(a1 + 8) != a3 || *(_QWORD *)a1 != a2)
      return 0;
  }
  v8 = *(float *)(a1 + 52);
  return v8 < a6 || v8 == a6 && *(_DWORD *)(a1 + 48) >= a4;
}

float ContentIndexDocSetComputeScore(uint64_t a1, uint64_t a2, uint64_t a3, uint8_t *a4, float a5)
{
  float v10;
  float *v11;
  float v12;
  _BOOL4 v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  unsigned int v17;
  int v18;
  uint64_t v19;
  uint64_t v21;
  unint64_t v22;
  BOOL v23;
  float v24;
  uint64_t v25;
  float v26;
  uint8_t v27;
  unint64_t v28;
  float v29;
  unint64_t v30;
  BOOL v31;
  uint64_t v32;
  float v33;
  float v34;
  int v35;
  uint64_t v36;
  float v37;
  unint64_t v38;
  float v39;
  BOOL v40;
  int v41;
  NSObject *v42;
  double v43;
  double v44;
  uint8_t v45;
  uint8_t buf[4];
  double v47;
  __int16 v48;
  double v49;
  uint64_t v50;

  v50 = *MEMORY[0x1E0C80C00];
  if (dword_1EF19FC90 >= 5)
  {
    v41 = *__error();
    v42 = _SILogForLogForCategory(1);
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
    {
      v43 = *(float *)(a1 + 12);
      v44 = *(float *)(a1 + 16);
      *(_DWORD *)buf = 134218240;
      v47 = v43;
      v48 = 2048;
      v49 = v44;
      _os_log_impl(&dword_1B8270000, v42, OS_LOG_TYPE_DEFAULT, "ContentIndexDocSetComputeScore: (%f, %f)", buf, 0x16u);
    }
    *__error() = v41;
  }
  v10 = 0.0;
  if (*(float *)(a1 + 28) >= a5)
  {
    v11 = (float *)(a1 + 12);
    if (*(float *)(a1 + 12) != 0.0 || *(float *)(a1 + 16) != 0.0)
    {
      v12 = *(float *)(a1 + 20);
      v13 = 1;
      switch(*(_DWORD *)(a1 + 48))
      {
        case 0:
        case 1:
        case 2:
          goto LABEL_13;
        case 3:
        case 8:
          v15 = *(_QWORD *)(a1 + 64);
          if (v15)
          {
            v14 = *(_QWORD *)(v15 + 88);
            if (v14)
            {
LABEL_7:
              v13 = !CIIndexSetHasIndexWithHint(v14, a2, (_DWORD *)(a1 + 40));
              if ((_DWORD)a3)
                goto LABEL_14;
            }
            else
            {
LABEL_12:
              v13 = 1;
LABEL_13:
              if ((_DWORD)a3)
              {
LABEL_14:
                if (v13)
                {
LABEL_15:
                  v16 = *(_DWORD *)(a1 + 52);
                  if (v16 == 3)
                  {
                    LOBYTE(v19) = 1;
                    goto LABEL_26;
                  }
                  if (v16 != 1)
                    goto LABEL_19;
                  v17 = *(_DWORD *)(a1 + 48);
                  if (v17 > 9)
LABEL_81:
                    assert_invalid_doc_type((_DWORD *)a1);
                  v18 = 1 << v17;
                  if ((v18 & 0x307) != 0)
                    goto LABEL_19;
                  if ((v18 & 0xF0) != 0)
                  {
                    v19 = *(_QWORD *)(a1 + 88);
                    if (!v19)
                      goto LABEL_26;
                  }
                  else
                  {
                    v21 = *(_QWORD *)(a1 + 64);
                    if (!v21)
                    {
LABEL_19:
                      LOBYTE(v19) = 0;
                      goto LABEL_26;
                    }
                    v19 = *(_QWORD *)(v21 + 96);
                    if (!v19)
                    {
LABEL_26:
                      *a4 = v19;
                      return *v11 + v12;
                    }
                  }
                  LOBYTE(v19) = CIIndexSetHasIndexWithHint(v19, a2, (_DWORD *)(a1 + 44));
                  goto LABEL_26;
                }
LABEL_9:
                v11 = (float *)(a1 + 16);
                return *v11 + v12;
              }
            }
          }
          else
          {
            v13 = 1;
            if ((_DWORD)a3)
              goto LABEL_14;
          }
          if (!v13)
            goto LABEL_15;
          goto LABEL_9;
        case 4:
        case 5:
        case 6:
        case 7:
        case 9:
          v14 = *(_QWORD *)(a1 + 80);
          if (v14)
            goto LABEL_7;
          goto LABEL_12;
        default:
          goto LABEL_81;
      }
    }
    switch(*(_DWORD *)(a1 + 48))
    {
      case 0:
      case 1:
      case 2:
        return (float)a3;
      case 3:
      case 8:
      case 9:
        return v10;
      case 4:
        if (*(_DWORD *)(a1 + 96))
        {
          v22 = 0;
          v23 = 0;
          v24 = -3.4028e38;
          do
          {
            buf[0] = 0;
            v25 = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 8 * v22);
            if (v24 > *(float *)(v25 + 24))
              break;
            v26 = ContentIndexDocSetComputeScore(v25, a2, a3, buf, a5);
            if (v26 >= v24)
            {
              if (v26 <= v24)
              {
                v23 = v23 && buf[0] != 0;
              }
              else
              {
                v23 = buf[0] != 0;
                v24 = v26;
              }
            }
            ++v22;
          }
          while (v22 < *(unsigned int *)(a1 + 96));
        }
        else
        {
          v23 = 0;
          v24 = -3.4028e38;
        }
        v40 = v23;
        goto LABEL_76;
      case 5:
        buf[0] = 0;
        v10 = ContentIndexDocSetComputeScore(**(_QWORD **)(a1 + 72), a2, a3, buf, a5);
        v27 = buf[0];
        if (v10 == 0.0)
          goto LABEL_49;
        v28 = 1;
        break;
      case 6:
        if (*(_DWORD *)(a1 + 96))
        {
          v30 = 0;
          v31 = 0;
          v32 = a3 ^ 1;
          v24 = -3.4028e38;
          do
          {
            buf[0] = 0;
            v33 = ContentIndexDocSetComputeScore(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8 * v30), a2, v32, buf, a5);
            if (v33 >= v24)
            {
              if (v33 <= v24)
              {
                v31 = v31 && buf[0] != 0;
              }
              else
              {
                v31 = buf[0] != 0;
                v24 = v33;
              }
            }
            ++v30;
          }
          while (v30 < *(unsigned int *)(a1 + 96));
          v40 = v31;
        }
        else
        {
          v24 = -3.4028e38;
          v40 = 0;
        }
LABEL_76:
        *a4 = v40;
        return fmaxf(*(float *)(a1 + 20), v24);
      case 7:
        buf[0] = 0;
        v34 = ContentIndexDocSetComputeScore(**(_QWORD **)(a1 + 72), a2, a3, buf, a5);
        v35 = buf[0];
        if (*(_DWORD *)(a1 + 96) < 2u)
        {
          v37 = 3.4028e38;
        }
        else
        {
          v36 = a3 ^ 1;
          v37 = 3.4028e38;
          v38 = 1;
          do
          {
            v45 = 0;
            v39 = ContentIndexDocSetComputeScore(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8 * v38), a2, v36, &v45, 0.0);
            if (v39 <= v37)
            {
              if (v39 >= v37)
              {
                if (v35)
                  v35 = v45;
                else
                  v35 = 0;
              }
              else
              {
                v37 = v39;
              }
            }
            ++v38;
          }
          while (v38 < *(unsigned int *)(a1 + 96));
        }
        *a4 = v35;
        v10 = v37 + v34;
        if ((float)(v37 + v34) != 0.0)
          return *(float *)(a1 + 20) + (float)(v34 + v37);
        return v10;
      default:
        goto LABEL_81;
    }
    do
    {
      if (v28 >= *(unsigned int *)(a1 + 96))
        break;
      v45 = 0;
      v29 = ContentIndexDocSetComputeScore(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8 * v28), a2, a3, &v45, a5 - v10);
      if (v29 == 0.0)
      {
        *a4 = v45;
        return 0.0;
      }
      v10 = v29 + v10;
      v27 |= v45;
      ++v28;
    }
    while (v10 != 0.0);
LABEL_49:
    *a4 = v27;
    if (v10 != 0.0)
      return *(float *)(a1 + 20) + v10;
  }
  return v10;
}

_BYTE *do_shifted_and(_BYTE *result, const unsigned __int8 *a2, int a3, char a4)
{
  uint64_t v4;
  const unsigned __int8 *v5;
  int v6;
  char v7;

  if (a3 >= 1)
  {
    v4 = a3;
    v5 = a2 + 1;
    do
    {
      v6 = *(v5 - 1) >> a4;
      v7 = *v5++;
      *result++ &= (v7 << (8 - a4)) | v6;
      --v4;
    }
    while (v4);
  }
  return result;
}

_BYTE *_lt_trie_make_node()
{
  _BYTE *v0;

  v0 = malloc_type_malloc(0x18uLL, 0x1090040201C2EDAuLL);
  v0[17] = 4;
  *(_QWORD *)v0 = malloc_type_malloc(4uLL, 0x100004077774924uLL);
  *((_QWORD *)v0 + 1) = malloc_type_malloc(0x20uLL, 0x2004093837F09uLL);
  v0[18] = 0;
  v0[16] = -1;
  return v0;
}

_BYTE *lt_trie_make_with_unicode(unsigned __int8 *a1, int a2, char a3)
{
  uint64_t v4;
  _BYTE *node;
  _BYTE *v7;
  _BYTE *v8;
  unsigned int v9;
  uint64_t v10;

  LODWORD(v4) = a2;
  node = _lt_trie_make_node();
  v7 = node;
  if ((_DWORD)v4)
  {
    v4 = v4;
    do
    {
      v8 = node;
      v9 = *a1++;
      *(_BYTE *)(*(_QWORD *)node + node[18]) = *((_BYTE *)&tcm + v9);
      node = _lt_trie_make_node();
      v10 = v8[18];
      *(_QWORD *)(*((_QWORD *)v8 + 1) + 8 * v10) = node;
      v8[18] = v10 + 1;
      if (v4 == 1)
        node[16] = a3;
      --v4;
    }
    while (v4);
  }
  return v7;
}

_BYTE *lt_trie_union(uint64_t a1, uint64_t a2)
{
  _BYTE *node;
  _BYTE *v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  unsigned int v9;
  _BYTE *v10;
  unsigned int v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  if (!a1)
    return (_BYTE *)a2;
  if (!a2)
    return (_BYTE *)a1;
  node = _lt_trie_make_node();
  v5 = node;
  v6 = *(unsigned __int8 *)(a1 + 16);
  if (v6 != 255 || (v6 = *(unsigned __int8 *)(a2 + 16), v6 != 255))
    node[16] = v6;
  v7 = 0;
  v8 = 0;
  while (v7 < *(unsigned __int8 *)(a1 + 18) || v8 < *(unsigned __int8 *)(a2 + 18))
  {
    v9 = v5[17];
    if (v5[18] >= v9)
    {
      v5[17] = 2 * v9;
      *(_QWORD *)v5 = malloc_type_realloc(*(void **)v5, 2 * (v9 & 0x7F), 0x100004077774924uLL);
      *((_QWORD *)v5 + 1) = malloc_type_realloc(*((void **)v5 + 1), 8 * v5[17], 0x2004093837F09uLL);
    }
    if (v8 == *(unsigned __int8 *)(a2 + 18))
    {
      LOBYTE(v13) = *(_BYTE *)(*(_QWORD *)a1 + v7);
      v12 = v5[18];
LABEL_19:
      *(_BYTE *)(*(_QWORD *)v5 + v12) = v13;
      v15 = v5[18];
      *(_QWORD *)(*((_QWORD *)v5 + 1) + 8 * v15) = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * v7);
      v5[18] = v15 + 1;
LABEL_20:
      ++v7;
    }
    else
    {
      v10 = *(_BYTE **)a2;
      if (v7 == *(unsigned __int8 *)(a1 + 18))
      {
        LOBYTE(v11) = v10[v8];
        v12 = v5[18];
        goto LABEL_17;
      }
      v13 = *(unsigned __int8 *)(*(_QWORD *)a1 + v7);
      v11 = v10[v8];
      v12 = v5[18];
      if (v13 < v11)
        goto LABEL_19;
      if (v13 <= v11)
      {
        *(_BYTE *)(*(_QWORD *)v5 + v12) = v13;
        v16 = lt_trie_union(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * v7), *(_QWORD *)(*(_QWORD *)(a2 + 8) + 8 * v8));
        v17 = v5[18];
        *(_QWORD *)(*((_QWORD *)v5 + 1) + 8 * v17) = v16;
        v5[18] = v17 + 1;
        ++v8;
        goto LABEL_20;
      }
LABEL_17:
      *(_BYTE *)(*(_QWORD *)v5 + v12) = v11;
      v14 = v5[18];
      *(_QWORD *)(*((_QWORD *)v5 + 1) + 8 * v14) = *(_QWORD *)(*(_QWORD *)(a2 + 8) + 8 * v8);
      v5[18] = v14 + 1;
      ++v8;
    }
  }
  _lt_trie_free_node((void **)a1);
  _lt_trie_free_node((void **)a2);
  return v5;
}

void _lt_trie_free_node(void **a1)
{
  free(*a1);
  free(a1[1]);
  free(a1);
}

void lt_trie_free(uint64_t a1)
{
  unint64_t v2;

  if (*(_BYTE *)(a1 + 18))
  {
    v2 = 0;
    do
      lt_trie_free(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * v2++));
    while (v2 < *(unsigned __int8 *)(a1 + 18));
  }
  _lt_trie_free_node((void **)a1);
}

void SISimulateCrashForPid(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  __int16 v7;
  uint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    v4 = 3134249728;
    if (a1)
      v4 = a1;
    v5 = 134218242;
    v6 = v4;
    v7 = 2112;
    v8 = a2;
    _os_log_fault_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "%lld %@", (uint8_t *)&v5, 0x16u);
  }
}

uint64_t versionNineResetSentinelData(uint64_t a1, unsigned __int8 *a2, double *a3, unsigned int *a4, double a5, double a6)
{
  uint64_t result;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  unsigned __int8 *v18;
  int v19;
  unsigned int v20;
  int v21;
  unsigned int v22;
  int v23;
  size_t v24;
  uint8_t *v25;
  int v26;
  unsigned int v27;
  size_t v28;
  size_t v29;
  int v30;
  uint64_t v31;
  unsigned __int8 *v32;
  int v33;
  double v34;
  int v35;
  NSObject *v36;
  int *v37;
  uint8_t buf[4];
  const char *v39;
  __int16 v40;
  int v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  if ((a1 - 366) < 0xFFFFFE93 || a2 == 0)
    return 0;
  if (*a3 == 0.0)
    return 0;
  v12 = *a4;
  if (!*a4)
    return 0;
  v13 = a1;
  v14 = 0;
  v15 = 0;
  v16 = llround(vabdd_f64(a5, *a3) / 86400.0);
  LODWORD(v17) = *a2;
  v18 = a2;
  while (v12 > 2 * v14 && v16 > v17)
  {
    v19 = v15 + 1;
    v20 = v14 + 1;
    if (v14 + 1 < a1)
    {
      v18 = &a2[2 * v20];
      v21 = *v18;
      LODWORD(v17) = v17 + v21;
      if (2 * v20 < v12 && v21 == 255)
      {
        v22 = v14 + 2;
        v18 = &a2[2 * v22];
        if (!v18[1])
        {
          v17 = v17 + *v18;
          v23 = v15 + 2;
          if (v16 > v17)
            v19 = v23;
          v20 = v22;
        }
      }
    }
    v14 = v20;
    v15 = v19;
    if (v20 >= a1)
      goto LABEL_21;
  }
  v19 = v15;
LABEL_21:
  MEMORY[0x1E0C80A78](a1);
  v25 = &buf[-((v24 + 15) & 0x1FFFFFFF0)];
  bzero(v25, v24);
  v26 = *a4;
  bzero(v25, *a4);
  if (v13 == v19)
  {
    LOBYTE(v27) = 0;
    LODWORD(v28) = 0;
    *a3 = a6;
LABEL_23:
    *(_WORD *)&v25[v28] = v27 | 0x100;
    v29 = (v26 + 2);
    *a4 = v29;
    memcpy(a2, v25, v29);
    return 1;
  }
  v30 = 0;
  v31 = v13;
  v32 = a2;
  do
  {
    v33 = *v32;
    v32 += 2;
    v30 += v33;
    --v31;
  }
  while (v31);
  v34 = (double)v17 * 86400.0 + *a3;
  *a3 = v34;
  *v18 = 0;
  v27 = v17 - v30 + ((a6 - v34) / 86400.0);
  if (v27 < 0x16E)
  {
    v28 = 2 * (v13 - v19);
    *a4 = v28;
    memcpy(v25, &a2[2 * v19], v28);
    *(_WORD *)v25 = *(_WORD *)v18;
    if (v27 < 0x100)
    {
      v26 = v28;
    }
    else
    {
      *(_WORD *)&v25[v28 + 2] = (v27 + 1);
      v26 = v28 + 2;
      LOBYTE(v27) = -1;
    }
    goto LABEL_23;
  }
  v35 = *__error();
  v36 = _SILogForLogForCategory(7);
  if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136315394;
    v39 = "versionNineResetSentinelData";
    v40 = 1024;
    v41 = 176;
    _os_log_error_impl(&dword_1B8270000, v36, OS_LOG_TYPE_ERROR, "%s:%d: Date too distant while restting sentinel", buf, 0x12u);
  }
  v37 = __error();
  result = 0;
  *v37 = v35;
  return result;
}

uint64_t markItemAsRenderedOrEngaged(uint64_t a1, uint64_t a2, unsigned int a3, _DWORD *a4, int a5, double a6)
{
  unsigned int v9;
  double Current;
  uint64_t result;
  char v14;
  unint64_t v15;
  unint64_t v16;
  double v17;
  double v18;
  int v19;
  NSObject *v20;
  const char *v21;
  _WORD *v22;
  uint64_t v23;
  unint64_t v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  unsigned __int8 *v28;
  int v29;
  int v30;
  NSObject *v31;
  int *v32;
  char v33;
  int *v34;
  int v35;
  const char *v36;
  double v37;
  unsigned int v38;
  _WORD *v39;
  unsigned int v40;
  double v41;
  unsigned int v42;
  uint8_t buf[4];
  const char *v44;
  __int16 v45;
  int v46;
  uint64_t v47;

  v9 = a3;
  v47 = *MEMORY[0x1E0C80C00];
  v42 = a3;
  Current = CFAbsoluteTimeGetCurrent();
  result = 0;
  if (v9)
    v14 = 0;
  else
    v14 = a5;
  if ((v14 & 1) == 0)
  {
    v15 = (unint64_t)a6;
    v16 = 86400 * ((unint64_t)a6 / 0x15180);
    v17 = (double)v16;
    if (((int)(((double)(86400 * ((unint64_t)Current / 0x15180)) - (double)v16) / 86400.0) - 366) >= 0xFFFFFE91)
    {
      v41 = 0.0;
      v18 = 0.0;
      if (a5)
      {
        if (v9 >= 0x2E4)
        {
          v19 = *__error();
          v20 = _SILogForLogForCategory(7);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315394;
            v44 = "markItemAsRenderedOrEngaged";
            v45 = 1024;
            v46 = 312;
            v21 = "%s:%d: Incorrect data size in counts code";
LABEL_36:
            _os_log_error_impl(&dword_1B8270000, v20, OS_LOG_TYPE_ERROR, v21, buf, 0x12u);
            goto LABEL_37;
          }
          goto LABEL_37;
        }
        if (a2 && v9 >= 9 && *(_BYTE *)a2 == 9)
        {
          v41 = *(double *)(a2 + 1);
          memcpy((void *)(a1 + 9), (const void *)(a2 + 9), v9 - 9);
          v42 = v9 - 9;
          v18 = v41;
          v9 -= 9;
        }
      }
      v22 = (_WORD *)(a1 + 9);
      if (v15 == v15 - v16)
        v17 = (double)(86400 * ((unint64_t)CFAbsoluteTimeGetCurrent() / 0x15180));
      if (v18 != 0.0)
      {
        v23 = llround((double)(v9 >> 1));
        if (!(_DWORD)v23)
          goto LABEL_28;
        v24 = (unint64_t)v22 + v9 - 2;
        if (!*(_BYTE *)(v24 + 1))
          v24 = v24 & 0xFFFFFFFFFFFF0000 | *(unsigned __int16 *)((char *)v22 + v9 - 4);
        v25 = 0;
        v26 = llround((v17 - v18) / 86400.0);
        v27 = v23;
        v28 = (unsigned __int8 *)(a1 + 9);
        do
        {
          v29 = *v28;
          v28 += 2;
          v25 += v29;
          --v27;
        }
        while (v27);
        if (v26 >= 365)
        {
          if ((versionNineResetSentinelData(v23, (unsigned __int8 *)(a1 + 9), &v41, &v42, fabs(v17 + -31449600.0), v17) & 1) == 0)
          {
            v30 = *__error();
            v31 = _SILogForLogForCategory(7);
            if (!os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
            {
LABEL_25:
              v32 = __error();
              v33 = 0;
              *v32 = v30;
              goto LABEL_29;
            }
            *(_DWORD *)buf = 136315394;
            v44 = "versionNineUpdateDataAndLength";
            v45 = 1024;
            v46 = 233;
            v36 = "%s:%d: Failed reseting sentinel date";
LABEL_54:
            _os_log_error_impl(&dword_1B8270000, v31, OS_LOG_TYPE_ERROR, v36, buf, 0x12u);
            goto LABEL_25;
          }
          goto LABEL_28;
        }
        if (v26 > -2)
        {
          if (v26 == v25)
          {
            v35 = *(unsigned __int8 *)(v24 + 1);
            if (v35 != 255)
              *(_BYTE *)(v24 + 1) = v35 + 1;
          }
          else
          {
            if (v23 >= 0x16D)
            {
              v30 = *__error();
              v31 = _SILogForLogForCategory(7);
              if (!os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
                goto LABEL_25;
              *(_DWORD *)buf = 136315394;
              v44 = "versionNineUpdateDataAndLength";
              v45 = 1024;
              v46 = 241;
              v36 = "%s:%d: Beyond max entries in counts or tried adding out of order";
              goto LABEL_54;
            }
            v37 = v18 + (double)v25 * 86400.0;
            if (v17 < v37 || (v38 = ((v17 - v37) / 86400.0), v38 >= 0x16E))
            {
              v30 = *__error();
              v31 = _SILogForLogForCategory(7);
              if (!os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
                goto LABEL_25;
              *(_DWORD *)buf = 136315394;
              v44 = "versionNineUpdateDataAndLength";
              v45 = 1024;
              v46 = 251;
              v36 = "%s:%d: Beyond max entries in counts or tried adding out of order in adding new";
              goto LABEL_54;
            }
            if (v38 < 0x100)
            {
              *(_WORD *)((char *)v22 + v9) = ((v17 - v37) / 86400.0) | 0x100;
              v40 = v9 + 2;
            }
            else
            {
              v39 = (_WORD *)((char *)v22 + v9);
              *v39 = 511;
              v39[1] = (v38 + 1);
              v40 = v9 + 4;
            }
            v42 = v40;
          }
LABEL_28:
          v33 = 1;
LABEL_29:
          if (v42 - 731 > 0xFFFFFD1B)
          {
            if ((v33 & 1) != 0)
            {
              *a4 = v42 + 9;
              *(_BYTE *)a1 = 9;
              *(double *)(a1 + 1) = v41;
              return 1;
            }
            v19 = *__error();
            v20 = _SILogForLogForCategory(7);
            if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
              goto LABEL_37;
            *(_DWORD *)buf = 136315394;
            v44 = "markItemAsRenderedOrEngaged";
            v45 = 1024;
            v46 = 339;
            v21 = "%s:%d: Failed updating render/engagement data";
            goto LABEL_36;
          }
          v19 = *__error();
          v20 = _SILogForLogForCategory(7);
          if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315394;
            v44 = "markItemAsRenderedOrEngaged";
            v45 = 1024;
            v46 = 331;
            v21 = "%s:%d: Incorrect data size in counts code";
            goto LABEL_36;
          }
LABEL_37:
          v34 = __error();
          result = 0;
          *v34 = v19;
          return result;
        }
      }
      *v22 = 256;
      v42 = 2;
      v41 = v17;
      goto LABEL_28;
    }
  }
  return result;
}

uint64_t _sdbMatchAddress(uint64_t result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v4;
  int v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  NSObject *v16;
  int v17;
  char *v18;
  char *v19;
  const char *v20;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  int v24;
  __int16 v25;
  int v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  if (result)
  {
    v2 = result;
    if (*(_DWORD *)result != 1685287992)
    {
      v15 = *__error();
      v16 = _SILogForLogForCategory(4);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        v17 = *(_DWORD *)v2;
        *(_DWORD *)buf = 136315650;
        v22 = "db_match_address";
        v23 = 1024;
        v24 = 438;
        v25 = 1024;
        v26 = v17;
        _os_log_error_impl(&dword_1B8270000, v16, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
      }
      *__error() = v15;
      v18 = __si_assert_copy_extra_268();
      v19 = v18;
      if (v18)
        v20 = v18;
      else
        v20 = "";
      __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 438, v20);
      free(v19);
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    if ((*(_BYTE *)(result + 804) & 0x14) == 0)
      return 0;
    v4 = *(_QWORD *)(result + 880);
    if (v4)
    {
      v5 = *(_DWORD *)(v4 + 216);
      if (v5 == 1684300900)
      {
        if ((_data_map64_match_address(v4, a2) & 1) != 0)
          return 1;
      }
      else if (v5 == 842150450)
      {
        if ((_data_map32_match_address(v4, a2) & 1) != 0)
          return 1;
      }
      else if (v5 == -270471200 && (_data_map_ext_match_address(v4, a2) & 1) != 0)
      {
        return 1;
      }
    }
    v6 = *(_QWORD *)(v2 + 888);
    if (v6)
    {
      v7 = *(_DWORD *)(v6 + 216);
      if (v7 == 1684300900)
      {
        if ((_data_map64_match_address(v6, a2) & 1) != 0)
          return 1;
      }
      else if (v7 == 842150450)
      {
        if ((_data_map32_match_address(v6, a2) & 1) != 0)
          return 1;
      }
      else if (v7 == -270471200 && (_data_map_ext_match_address(v6, a2) & 1) != 0)
      {
        return 1;
      }
    }
    v8 = *(_QWORD *)(v2 + 896);
    if (v8)
    {
      v9 = *(_DWORD *)(v8 + 216);
      if (v9 == 1684300900)
      {
        if ((_data_map64_match_address(v8, a2) & 1) != 0)
          return 1;
      }
      else if (v9 == 842150450)
      {
        if ((_data_map32_match_address(v8, a2) & 1) != 0)
          return 1;
      }
      else if (v9 == -270471200 && (_data_map_ext_match_address(v8, a2) & 1) != 0)
      {
        return 1;
      }
    }
    v10 = *(_QWORD *)(v2 + 904);
    if (v10)
    {
      v11 = *(_DWORD *)(v10 + 216);
      if (v11 == 1684300900)
      {
        if ((_data_map64_match_address(v10, a2) & 1) != 0)
          return 1;
      }
      else if (v11 == 842150450)
      {
        if ((_data_map32_match_address(v10, a2) & 1) != 0)
          return 1;
      }
      else if (v11 == -270471200 && (_data_map_ext_match_address(v10, a2) & 1) != 0)
      {
        return 1;
      }
    }
    v12 = *(_QWORD *)(v2 + 912);
    if (!v12)
      goto LABEL_47;
    v13 = *(_DWORD *)(v12 + 216);
    if (v13 == 1684300900)
    {
      if ((_data_map64_match_address(v12, a2) & 1) == 0)
        goto LABEL_47;
    }
    else
    {
      if (v13 != 842150450)
      {
        if (v13 == -270471200 && (_data_map_ext_match_address(v12, a2) & 1) != 0)
          return 1;
        goto LABEL_47;
      }
      if ((_data_map32_match_address(v12, a2) & 1) == 0)
      {
LABEL_47:
        result = *(_QWORD *)(v2 + 920);
        if (!result)
          return result;
        v14 = *(_DWORD *)(result + 216);
        switch(v14)
        {
          case -270471200:
            return _data_map_ext_match_address(result, a2);
          case 1684300900:
            return _data_map64_match_address(result, a2);
          case 842150450:
            return _data_map32_match_address(result, a2);
        }
        return 0;
      }
    }
    return 1;
  }
  return result;
}

uint64_t _sdbGetProtectionClass(int *a1)
{
  uint64_t v1;
  int v2;
  int v5;
  NSObject *v6;
  int v7;
  char *v8;
  char *v9;
  const char *v10;
  uint8_t buf[4];
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0;
  if (*a1 != 1685287992)
  {
    v5 = *__error();
    v6 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v7 = *a1;
      *(_DWORD *)buf = 136315650;
      v12 = "db_get_protection_class";
      v13 = 1024;
      v14 = 259;
      v15 = 1024;
      v16 = v7;
      _os_log_error_impl(&dword_1B8270000, v6, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v5;
    v8 = __si_assert_copy_extra_268();
    v9 = v8;
    if (v8)
      v10 = v8;
    else
      v10 = "";
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 259, v10);
    free(v9);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  v1 = *((_QWORD *)a1 + 106);
  if (v1 && (v2 = *(_DWORD *)(v1 + 44), v2 != -1))
    return fcntl(v2, 63);
  else
    return 0;
}

_DWORD *db_create_datastore(unsigned int a1, uint64_t a2, int a3, unsigned __int8 a4)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD v7[2];
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if ((a3 & 0xF000) != 0x2000)
    return 0;
  v10 = v4;
  v11 = v5;
  v8 = 0u;
  v7[0] = a1;
  v7[1] = a2;
  LODWORD(v8) = a3 & 0xFFFF0FFF;
  v9 = a4;
  return db2_create_datastore_with_ctx((uint64_t)v7);
}

uint64_t db_get_datastore(unsigned int a1, uint64_t a2, int a3)
{
  _QWORD v4[2];
  __int128 v5;
  uint64_t v6;

  if ((a3 & 0x1000) != 0)
    return 0;
  v5 = 0u;
  v6 = 0;
  v4[0] = a1;
  v4[1] = a2;
  LODWORD(v5) = a3;
  return db2_get_datastore_with_ctx((unsigned int *)v4);
}

uint64_t db_check_datastore(int a1, __int16 a2)
{
  char *v3;
  int8x16_t *v4;
  int8x16_t *v5;
  unsigned __int8 v6;
  char *v7;
  char *v8;
  int v9;
  char *v10;
  char *v11;
  int v12;
  uint64_t v13;
  int8x16_t v14;
  int v15;
  uint64_t v16;
  int v18;
  int v19;
  NSObject *v20;
  int *v21;
  int v22;
  NSObject *v23;
  NSObject *v24;
  int v25;
  NSObject *v26;
  uint64_t v27;
  int v28;
  int v29;
  int v30;
  NSObject *v31;
  int8x16_t v32;
  int v33;
  int v34;
  int v35;
  NSObject *v36;
  const char *v37;
  NSObject *v38;
  uint32_t v39;
  NSObject *v40;
  int v41;
  int v42;
  int v43;
  int v44;
  NSObject *v45;
  os_log_type_t v46;
  const char *v47;
  const char *v48;
  int v49;
  int v50;
  uint64_t v51;
  _BYTE buf[12];
  __int16 v53;
  int v54;
  __int16 v55;
  _BYTE v56[10];
  int v57;
  __int16 v58;
  uint64_t v59;
  char __dst[1024];
  _BYTE v61[1024];
  uint64_t v62;

  v62 = *MEMORY[0x1E0C80C00];
  if ((a2 & 0xF000) != 0x2000)
    return 0;
  bzero(v61, 0x400uLL);
  bzero(__dst, 0x400uLL);
  v3 = (char *)malloc_type_calloc(1uLL, 0x1000uLL, 0xB4B95A6DuLL);
  v4 = (int8x16_t *)malloc_type_calloc(1uLL, 0x1000uLL, 0x8338A77EuLL);
  v5 = v4;
  if (!v3 || !v4)
  {
    v11 = 0;
    v8 = 0;
    v16 = 0xFFFFFFFFLL;
    if (!v3)
    {
      if (!v4)
        goto LABEL_17;
      goto LABEL_16;
    }
    goto LABEL_34;
  }
  v6 = ((int)(*((_DWORD *)v3 + 1) << 13) >> 31) & 3;
  v7 = (char *)fd_create_protected(a1, "store.db", 0, v6);
  if (!v7)
  {
    v18 = *__error();
    v19 = *__error();
    v20 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "db2_check_datastore";
      v53 = 1024;
      v54 = 6922;
      v55 = 1024;
      *(_DWORD *)v56 = v18;
      _os_log_error_impl(&dword_1B8270000, v20, OS_LOG_TYPE_ERROR, "%s:%d: db2_check_datastore: ERR: could not get parent fdp %d\n", buf, 0x18u);
    }
    *__error() = v19;
    v21 = __error();
    v11 = 0;
    v8 = 0;
    goto LABEL_32;
  }
  v8 = v7;
  v51 = 0;
  v9 = _fd_acquire_fd((uint64_t)v7, &v51);
  if (v9 < 0)
  {
    v18 = *__error();
    v22 = *__error();
    v23 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "db2_check_datastore";
      v53 = 1024;
      v54 = 6932;
      v55 = 1024;
      *(_DWORD *)v56 = v18;
      _os_log_error_impl(&dword_1B8270000, v23, OS_LOG_TYPE_ERROR, "%s:%d: db2_check_datastore: ERR: could not open parent %d\n", buf, 0x18u);
    }
    *__error() = v22;
    goto LABEL_31;
  }
  _fd_release_fd(v8, v9, 0, v51);
  strcpy(__dst, ".");
  strlcat(__dst, "store.db", 0x400uLL);
  *__error() = 0;
  v10 = (char *)fd_create_protected(a1, __dst, 0, v6);
  if (!v10)
  {
    v18 = *__error();
    v24 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      v41 = *__error();
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "db2_check_datastore";
      v53 = 1024;
      v54 = 6943;
      v55 = 1024;
      *(_DWORD *)v56 = v41;
      _os_log_error_impl(&dword_1B8270000, v24, OS_LOG_TYPE_ERROR, "%s:%d: db2_check_datastore: ERR:%d could not get shadow fdp\n", buf, 0x18u);
    }
LABEL_31:
    v21 = __error();
    v11 = 0;
LABEL_32:
    *v21 = v18;
LABEL_33:
    v16 = 0xFFFFFFFFLL;
    goto LABEL_34;
  }
  v11 = v10;
  v51 = 0;
  v12 = _fd_acquire_fd((uint64_t)v10, &v51);
  if (v12 < 0)
  {
    if (*__error() == 2)
      v16 = 2;
    else
      v16 = 0xFFFFFFFFLL;
    v25 = *__error();
    v26 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      v42 = *__error();
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "db2_check_datastore";
      v53 = 1024;
      v54 = 6951;
      v55 = 1024;
      *(_DWORD *)v56 = v42;
      _os_log_error_impl(&dword_1B8270000, v26, OS_LOG_TYPE_ERROR, "%s:%d: db2_check_datastore: ERR:%d could not open shadow\n", buf, 0x18u);
    }
    *__error() = v25;
  }
  else
  {
    _fd_release_fd(v11, v12, 0, v51);
    v13 = fd_pread(v8, v3, 0x1000uLL, 0);
    if (v13 != 4096)
    {
      v27 = v13;
      *(_QWORD *)buf = 0;
      v28 = _fd_acquire_fd((uint64_t)v8, buf);
      if (v28 != -1)
      {
        v29 = v28;
        fcntl(v28, 50, v61);
        _fd_release_fd(v8, v29, 0, *(uint64_t *)buf);
      }
      v30 = *__error();
      v31 = _SILogForLogForCategory(7);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136316162;
        *(_QWORD *)&buf[4] = "db2_check_datastore";
        v53 = 1024;
        v54 = 6960;
        v55 = 2080;
        *(_QWORD *)v56 = v61;
        *(_WORD *)&v56[8] = 1024;
        v57 = 4096;
        v58 = 2048;
        v59 = v27;
        _os_log_error_impl(&dword_1B8270000, v31, OS_LOG_TYPE_ERROR, "%s:%d: %s : db2_check_datastore: ERR: could not read %d bytes (read %zd bytes)\n", buf, 0x2Cu);
      }
      *__error() = v30;
      goto LABEL_33;
    }
    if (fd_pread(v11, v5, 0x1000uLL, 0) != 4096)
      bzero(v5, 0x1000uLL);
    *((_QWORD *)v3 + 105) = v8;
    *((_QWORD *)v3 + 106) = v11;
    if (*(_DWORD *)v3 == 947155812)
    {
      v14 = vrev32q_s8(*(int8x16_t *)v3);
      *(int8x16_t *)v3 = v14;
      *((_DWORD *)v3 + 4) = bswap32(*((_DWORD *)v3 + 4));
      *(int8x16_t *)(v3 + 20) = vrev64q_s8(*(int8x16_t *)(v3 + 20));
      *(int8x16_t *)(v3 + 36) = vrev32q_s8(*(int8x16_t *)(v3 + 36));
      *(int8x16_t *)(v3 + 52) = vrev32q_s8(*(int8x16_t *)(v3 + 52));
      v15 = v14.i32[1] & 0x7FFFFF7F | 0x80;
    }
    else
    {
      v15 = *((_DWORD *)v3 + 1) & 0x7FFFFF7F;
    }
    *((_DWORD *)v3 + 1) = v15;
    if (v5->i32[0] == 947155812)
    {
      v32 = vrev32q_s8(*v5);
      *v5 = v32;
      v5[1].i32[0] = bswap32(v5[1].u32[0]);
      *(int8x16_t *)((char *)v5 + 20) = vrev64q_s8(*(int8x16_t *)((char *)v5 + 20));
      *(int8x16_t *)((char *)v5 + 36) = vrev32q_s8(*(int8x16_t *)((char *)v5 + 36));
      *(int8x16_t *)((char *)v5 + 52) = vrev32q_s8(*(int8x16_t *)((char *)v5 + 52));
      v33 = v32.i32[1] & 0x7FFFFF7F | 0x80;
    }
    else
    {
      v33 = v5->i32[1] & 0x7FFFFF7F;
    }
    v5->i32[1] = v33;
    if (*(_DWORD *)v3 != 1685287992)
    {
      fd_realpath(v8, v61);
      v35 = *__error();
      v40 = _SILogForLogForCategory(7);
      if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
      {
        v43 = *(_DWORD *)v3;
        *(_DWORD *)buf = 136316162;
        *(_QWORD *)&buf[4] = "db2_check_datastore";
        v53 = 1024;
        v54 = 7006;
        v55 = 2080;
        *(_QWORD *)v56 = v61;
        *(_WORD *)&v56[8] = 1024;
        v57 = v43;
        v58 = 1024;
        LODWORD(v59) = 1685287992;
        v37 = "%s:%d: %s : db2_check_datastore: ERR: signature 0x%x != 0x%x. bailing out.\n";
        v38 = v40;
        v39 = 40;
        goto LABEL_67;
      }
LABEL_59:
      *__error() = v35;
      goto LABEL_33;
    }
    if (v5->i32[0] != 1685287992)
    {
      bzero(v5, 0x1000uLL);
      LOWORD(v33) = 0;
    }
    v34 = *((_DWORD *)v3 + 1);
    if ((v34 & 0x30) != 0 || (v33 & 0x30) != 0)
    {
      v35 = *__error();
      v36 = _SILogForLogForCategory(7);
      if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = "db2_check_datastore";
        v53 = 1024;
        v54 = 7017;
        v55 = 2080;
        *(_QWORD *)v56 = v61;
        v37 = "%s:%d: %s : db2_check_datastore: ERR: DST_BUSY\n";
        v38 = v36;
        v39 = 28;
LABEL_67:
        _os_log_error_impl(&dword_1B8270000, v38, OS_LOG_TYPE_ERROR, v37, buf, v39);
        goto LABEL_59;
      }
      goto LABEL_59;
    }
    if ((v33 & 0x200) != 0)
    {
      v16 = 1;
    }
    else if ((v33 & 1) != 0)
    {
      v16 = 0;
    }
    else if ((v34 & 0x201) != 0)
    {
      v16 = 2;
    }
    else
    {
      v16 = 0xFFFFFFFFLL;
    }
    v44 = *__error();
    v45 = _SILogForLogForCategory(7);
    v46 = 2 * (dword_1EF19FCA8 < 4);
    if (os_log_type_enabled(v45, v46))
    {
      v47 = fd_realpath(v8, v61);
      v48 = "";
      v49 = v5->i32[1];
      v50 = *((_DWORD *)v3 + 1);
      if (v47)
        v48 = v47;
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = v48;
      v53 = 1024;
      v54 = v16;
      v55 = 1024;
      *(_DWORD *)v56 = v49;
      *(_WORD *)&v56[4] = 1024;
      *(_DWORD *)&v56[6] = v50;
      _os_log_impl(&dword_1B8270000, v45, v46, "%s : db2_check_datastore:%d (s_flags:%x m_flags:%x)\n", buf, 0x1Eu);
    }
    *__error() = v44;
  }
LABEL_34:
  free(v3);
  if (v5)
LABEL_16:
    free(v5);
LABEL_17:
  if (v11 && v11 != v8)
    fd_release(v11);
  if (v8)
    fd_release(v8);
  return v16;
}

uint64_t db_delete_datastore(int a1, char *a2, int a3)
{
  unsigned int v6;
  char *v7;
  char *v8;
  const char *v9;
  unsigned __int8 v11;
  char *v12;
  unsigned int v13;
  char *v14;
  unsigned int v15;
  char *v16;
  char __dst[1024];
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if ((a3 & 0xF000) != 0x2000)
    return 0;
  bzero(__dst, 0x400uLL);
  v6 = (a3 & 0x40000u) >> 10;
  v7 = strrchr(a2, 47);
  if (v7)
  {
    v8 = v7;
    strlcpy(__dst, a2, v7 - a2 + 2);
    strlcat(__dst, ".", 0x400uLL);
    v9 = v8 + 1;
  }
  else
  {
    strcpy(__dst, ".");
    v9 = a2;
  }
  strlcat(__dst, v9, 0x400uLL);
  if ((a3 & 0x40000) != 0)
    v11 = 3;
  else
    v11 = 0;
  v12 = (char *)fd_create_protected(a1, a2, 2, v11);
  v13 = _fd_unlink_with_origin((uint64_t)v12, 0);
  fd_release(v12);
  v14 = (char *)fd_create_protected(a1, __dst, 2, v11);
  v15 = _fd_unlink_with_origin((uint64_t)v14, 0);
  fd_release(v14);
  if ((a3 & 0x20000) != 0)
  {
    v16 = 0;
    if ((asprintf(&v16, "%sStr-%d.map", a2, 1) & 0x80000000) == 0)
    {
      data_map_delete_files(a1, v16, v6);
      free(v16);
    }
    v16 = 0;
    if ((asprintf(&v16, "%sStr-%d.map", a2, 2) & 0x80000000) == 0)
    {
      data_map_delete_files(a1, v16, v6);
      free(v16);
    }
    v16 = 0;
    if ((asprintf(&v16, "%sStr-%d.map", a2, 3) & 0x80000000) == 0)
    {
      data_map_delete_files(a1, v16, v6);
      free(v16);
    }
    v16 = 0;
    if ((asprintf(&v16, "%sStr-%d.map", a2, 4) & 0x80000000) == 0)
    {
      data_map_delete_files(a1, v16, v6);
      free(v16);
    }
    v16 = 0;
    if ((asprintf(&v16, "%sStr-%d.map", a2, 5) & 0x80000000) == 0)
    {
      data_map_delete_files(a1, v16, v6);
      free(v16);
    }
  }
  v16 = 0;
  if ((asprintf(&v16, "%sStr-%d.map", a2, 6) & 0x80000000) == 0)
  {
    data_map_delete_files(a1, v16, v6);
    free(v16);
  }
  if (v13)
    return v13;
  else
    return v15;
}

uint64_t db_datastore_largest_oid(uint64_t a1)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int *v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  int v14;
  unsigned int *v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  int64_t v19;
  unsigned int v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  int v26;
  int v28;
  NSObject *v29;
  int v30;
  char *v31;
  char *v32;
  const char *v33;
  int v34;
  _BYTE buf[12];
  __int16 v36;
  int v37;
  __int16 v38;
  int v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)a1 != 1685287992)
  {
    v28 = *__error();
    v29 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
    {
      v30 = *(_DWORD *)a1;
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "db_datastore_largest_oid";
      v36 = 1024;
      v37 = 237;
      v38 = 1024;
      v39 = v30;
      _os_log_error_impl(&dword_1B8270000, v29, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v28;
    v31 = __si_assert_copy_extra_268();
    v32 = v31;
    if (v31)
      v33 = v31;
    else
      v33 = "";
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 237, v33);
    free(v32);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  if (db_read_lock(a1 + 584))
    sdb2_die(a1, "Multiple threads entering in sdb!", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 14893);
  v2 = *(_QWORD *)(a1 + 856);
  v3 = *(_DWORD *)(v2 + 8);
  v4 = (v3 - 1);
  if (v3 < 1)
  {
    v6 = -1;
  }
  else
  {
    v5 = v2 + 16 * v4;
    v6 = *(_QWORD *)(v5 + 20);
    if (!(*(_DWORD *)(v5 + 32) >> 28))
      goto LABEL_40;
    v7 = v2 + 20;
    v8 = (unsigned int *)(v2 + 16 * v4 + 16);
    do
    {
      if (v4 <= 0)
      {
        v9 = 0;
        goto LABEL_13;
      }
      v9 = v4--;
      v10 = *v8;
      v8 -= 4;
    }
    while (v10 >> 28);
    v11 = *(_QWORD *)(v7 + 16 * v4);
    if (v6 <= v11)
      v6 = v11;
LABEL_13:
    *(_QWORD *)buf = 0;
    v12 = v7 + 16 * v9;
    v13 = *(_DWORD *)(v12 + 8);
    v14 = *(_DWORD *)(v12 + 12);
    v15 = (unsigned int *)(v12 + 8);
    if (!_page_fetch_with_fd(a1, (void **)buf, v13, v14 & 0xFFFFFFF, 9, &v34, 0xFFFFFFFFLL, 0))
    {
      v16 = *(int *)(*(_QWORD *)buf + 8);
      if ((int)v16 >= 21)
      {
        v17 = *(_QWORD *)buf + v16;
        v18 = *(_QWORD *)buf + 20;
        do
        {
          v19 = *(unsigned __int8 *)(v18 + 4);
          if (*(char *)(v18 + 4) < 0)
          {
            v20 = *(unsigned __int8 *)(v18 + 4);
            if (v20 > 0xBF)
            {
              if (v20 <= 0xDF)
              {
                v21 = ((unint64_t)(v19 & 0x1F) << 16) | ((unint64_t)*(unsigned __int8 *)(v18 + 5) << 8);
                v22 = *(unsigned __int8 *)(v18 + 6);
LABEL_32:
                v19 = v21 | v22;
                goto LABEL_33;
              }
              if (v20 <= 0xEF)
              {
                v21 = ((unint64_t)(v19 & 0xF) << 24) | ((unint64_t)*(unsigned __int8 *)(v18 + 5) << 16) | ((unint64_t)*(unsigned __int8 *)(v18 + 6) << 8);
                v22 = *(unsigned __int8 *)(v18 + 7);
                goto LABEL_32;
              }
              if (v20 <= 0xF7)
              {
                v21 = ((unint64_t)(v19 & 7) << 32) | ((unint64_t)*(unsigned __int8 *)(v18 + 5) << 24) | ((unint64_t)*(unsigned __int8 *)(v18 + 6) << 16) | ((unint64_t)*(unsigned __int8 *)(v18 + 7) << 8);
                v22 = *(unsigned __int8 *)(v18 + 8);
                goto LABEL_32;
              }
              if (v20 <= 0xFB)
              {
                v21 = ((unint64_t)(v19 & 3) << 40) | ((unint64_t)*(unsigned __int8 *)(v18 + 5) << 32) | ((unint64_t)*(unsigned __int8 *)(v18 + 6) << 24) | ((unint64_t)*(unsigned __int8 *)(v18 + 7) << 16) | ((unint64_t)*(unsigned __int8 *)(v18 + 8) << 8);
                v22 = *(unsigned __int8 *)(v18 + 9);
                goto LABEL_32;
              }
              if (v20 <= 0xFD)
              {
                v21 = ((unint64_t)(v19 & 1) << 48) | ((unint64_t)*(unsigned __int8 *)(v18 + 5) << 40) | ((unint64_t)*(unsigned __int8 *)(v18 + 6) << 32) | ((unint64_t)*(unsigned __int8 *)(v18 + 7) << 24) | ((unint64_t)*(unsigned __int8 *)(v18 + 8) << 16) | ((unint64_t)*(unsigned __int8 *)(v18 + 9) << 8);
                v22 = *(unsigned __int8 *)(v18 + 10);
                goto LABEL_32;
              }
              if (v20 != 255)
              {
                v21 = ((unint64_t)*(unsigned __int8 *)(v18 + 5) << 48) | ((unint64_t)*(unsigned __int8 *)(v18 + 6) << 40) | ((unint64_t)*(unsigned __int8 *)(v18 + 7) << 32) | ((unint64_t)*(unsigned __int8 *)(v18 + 8) << 24) | ((unint64_t)*(unsigned __int8 *)(v18 + 9) << 16) | ((unint64_t)*(unsigned __int8 *)(v18 + 10) << 8);
                v22 = *(unsigned __int8 *)(v18 + 11);
                goto LABEL_32;
              }
              v19 = *(_QWORD *)(v18 + 5);
            }
            else
            {
              v19 = *(unsigned __int8 *)(v18 + 5) | ((unint64_t)(v19 & 0x3F) << 8);
            }
          }
LABEL_33:
          if (v6 <= v19)
            v6 = v19;
          v18 += (*(_DWORD *)v18 + 4);
        }
        while (v18 < v17);
      }
      page_release(a1, *(_DWORD **)buf, *v15, 0x10u, 0);
    }
  }
  v23 = *(_QWORD *)(a1 + 992);
  if (v23)
  {
    v24 = *(_QWORD *)(v23 + 64);
    if (v6 <= v24)
      v6 = v24;
  }
LABEL_40:
  v25 = pthread_mutex_lock((pthread_mutex_t *)(a1 + 584));
  v26 = *(_DWORD *)(a1 + 780) - 1;
  *(_DWORD *)(a1 + 780) = v26;
  if (!v26)
    db_rwlock_wakeup(a1 + 584, 0, 0);
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 584));
  if (v25)
    sdb2_die(a1, "Multiple threads in sdb! (leaving)", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 14930);
  return v6;
}

uint64_t db_datastore_set_bg_assertion_flag(uint64_t result, char a2)
{
  int *v2;
  int v3;
  NSObject *v4;
  int v5;
  char *v6;
  char *v7;
  const char *v8;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  int v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)result != 1685287992)
  {
    v2 = (int *)result;
    v3 = *__error();
    v4 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = *v2;
      *(_DWORD *)buf = 136315650;
      v10 = "db_datastore_set_bg_assertion_flag";
      v11 = 1024;
      v12 = 241;
      v13 = 1024;
      v14 = v5;
      _os_log_error_impl(&dword_1B8270000, v4, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v3;
    v6 = __si_assert_copy_extra_268();
    v7 = v6;
    if (v6)
      v8 = v6;
    else
      v8 = "";
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 241, v8);
    free(v7);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  *(_BYTE *)(result + 988) = a2;
  return result;
}

uint64_t db_get_object_count(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  int v5;
  int v7;
  NSObject *v8;
  int v9;
  char *v10;
  char *v11;
  const char *v12;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  int v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)a1 != 1685287992)
  {
    v7 = *__error();
    v8 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      v9 = *(_DWORD *)a1;
      *(_DWORD *)buf = 136315650;
      v14 = "db_get_object_count";
      v15 = 1024;
      v16 = 242;
      v17 = 1024;
      v18 = v9;
      _os_log_error_impl(&dword_1B8270000, v8, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v7;
    v10 = __si_assert_copy_extra_268();
    v11 = v10;
    if (v10)
      v12 = v10;
    else
      v12 = "";
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 242, v12);
    free(v11);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  if (db_read_lock(a1 + 584))
    sdb2_die(a1, "Multiple threads entering in sdb!", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 14950);
  v2 = *(_QWORD *)(a1 + 20);
  v3 = *(_QWORD *)(*(_QWORD *)(a1 + 992) + 40);
  v4 = pthread_mutex_lock((pthread_mutex_t *)(a1 + 584));
  v5 = *(_DWORD *)(a1 + 780) - 1;
  *(_DWORD *)(a1 + 780) = v5;
  if (!v5)
    db_rwlock_wakeup(a1 + 584, 0, 0);
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 584));
  if (v4)
    sdb2_die(a1, "Multiple threads in sdb! (leaving)", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 14952);
  return v3 + v2;
}

void db_scan_lost_ids(int *a1)
{
  uint64_t v2;
  int v3;
  uint64_t v5;
  uint64_t Instance;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  _OWORD *v25;
  uint64_t i;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _OWORD *v31;
  uint64_t j;
  uint64_t v33;
  _OWORD *v34;
  uint64_t k;
  const void *v36;
  int v37;
  NSObject *v38;
  int v39;
  char *v40;
  char *v41;
  const char *v42;
  char *v43;
  const char *v44;
  NSObject *v45;
  uint64_t v46;
  uint64_t v47;
  char *v48;
  _OWORD v49[4];
  uint64_t v50;
  uint8_t v51[4];
  const char *v52;
  __int16 v53;
  int v54;
  __int16 v55;
  unint64_t v56;
  __int16 v57;
  uint64_t v58;
  __int16 v59;
  uint64_t v60;
  __int16 v61;
  uint64_t v62;
  __int16 v63;
  char *v64;
  uint8_t buf[32];
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  uint64_t v80;

  v80 = *MEMORY[0x1E0C80C00];
  if (*a1 != 1685287992)
  {
    v37 = *__error();
    v38 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
    {
      v39 = *a1;
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "db_scan_lost_ids";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 248;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v39;
      _os_log_error_impl(&dword_1B8270000, v38, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v37;
    v40 = __si_assert_copy_extra_268();
    v41 = v40;
    if (v40)
      v42 = v40;
    else
      v42 = "";
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 248, v42);
LABEL_70:
    free(v41);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  if (!_os_feature_enabled_impl())
    return;
  v2 = *((_QWORD *)a1 + 115);
  if (!v2)
    return;
  v3 = *(_DWORD *)(v2 + 216);
  if (v3 == 1684300900 || v3 == 842150450)
    return;
  if (v3 != -270471200)
  {
    v43 = __si_assert_copy_extra_268();
    v41 = v43;
    if (v43)
      v44 = v43;
    else
      v44 = "";
    __message_assert("%s:%u: Unexpected code path %s ", "data_map.c", 265, v44);
    goto LABEL_70;
  }
  v50 = 0;
  memset(v49, 0, sizeof(v49));
  v5 = *(_QWORD *)(v2 + 472);
  if (!__kSIUINT32SetTypeID)
    __kSIUINT32SetTypeID = _CFRuntimeRegisterClass();
  Instance = _CFRuntimeCreateInstance();
  v7 = *(_QWORD *)(v5 + 1384);
  if (*(_DWORD *)(v7 + 8))
  {
    v8 = 0;
    do
    {
      SIValueSet<unsigned int>::SIValueSetInsert((unsigned int *)(Instance + 16), *(unsigned int *)(*(_QWORD *)(*(_QWORD *)v7 + 8 * v8++) + 48));
      v7 = *(_QWORD *)(v5 + 1384);
    }
    while (v8 < *(unsigned int *)(v7 + 8));
  }
  v9 = *(_QWORD *)(v5 + 1392);
  if (*(_DWORD *)(v9 + 8))
  {
    v10 = 0;
    do
    {
      SIValueSet<unsigned int>::SIValueSetInsert((unsigned int *)(Instance + 16), *(unsigned int *)(*(_QWORD *)(*(_QWORD *)v9 + 8 * v10++) + 48));
      v9 = *(_QWORD *)(v5 + 1392);
    }
    while (v10 < *(unsigned int *)(v9 + 8));
  }
  _data_map_ext_rdlock(v2);
  if (!Instance)
    goto LABEL_39;
  if (*(_QWORD *)(v2 + 376) < 2uLL)
  {
LABEL_38:
    CFRelease((CFTypeRef)Instance);
LABEL_39:
    _data_map_ext_unlock(v2);
    v20 = *(_QWORD *)(v2 + 472);
    v21 = *(_QWORD *)(v20 + 1384);
    if (*(_DWORD *)(v21 + 8))
    {
      v22 = 0;
      do
      {
        v23 = 0;
        v24 = *(_QWORD *)(*(_QWORD *)v21 + 8 * v22);
        v25 = v49;
        do
        {
          for (i = 0; i != 3; ++i)
          {
            if (*((_QWORD *)v25 + i))
              ContentIndexRecoverVectorIds(*(_QWORD *)(v24 + 4896), v23, i);
          }
          ++v23;
          v25 = (_OWORD *)((char *)v25 + 24);
        }
        while (v23 != 3);
        ++v22;
        v21 = *(_QWORD *)(v20 + 1384);
      }
      while (v22 < *(unsigned int *)(v21 + 8));
    }
    v27 = *(_QWORD *)(v20 + 1392);
    if (*(_DWORD *)(v27 + 8))
    {
      v28 = 0;
      do
      {
        v29 = 0;
        v30 = *(_QWORD *)(*(_QWORD *)v27 + 8 * v28);
        v31 = v49;
        do
        {
          for (j = 0; j != 3; ++j)
          {
            if (*((_QWORD *)v31 + j))
              ContentIndexRecoverVectorIds(*(_QWORD *)(v30 + 4896), v29, j);
          }
          ++v29;
          v31 = (_OWORD *)((char *)v31 + 24);
        }
        while (v29 != 3);
        ++v28;
        v27 = *(_QWORD *)(v20 + 1392);
      }
      while (v28 < *(unsigned int *)(v27 + 8));
    }
    v33 = 0;
    v34 = v49;
    do
    {
      for (k = 0; k != 24; k += 8)
      {
        v36 = *(const void **)((char *)v34 + k);
        if (v36)
          CFRelease(v36);
      }
      ++v33;
      v34 = (_OWORD *)((char *)v34 + 24);
    }
    while (v33 != 3);
    return;
  }
  v11 = 1;
  while (1)
  {
    v12 = *(_QWORD *)(v2 + 288);
    if ((unint64_t)(v12 + 1) < 2)
      break;
    v13 = v12 + 24 * v11;
    if (*(_BYTE *)(Instance + 176))
      goto LABEL_22;
    v16 = *(_DWORD *)(v13 + 8);
    v17 = *(_DWORD *)(Instance + 20);
    if (v17)
    {
      if ((*(_DWORD *)(Instance + 16) ^ v16) >> (-4 * v17))
        goto LABEL_22;
    }
    v18 = *(_QWORD *)(Instance + 48 + 8 * ((v16 >> (28 - 4 * v17)) & 0xF));
    if ((v18 & 1) != 0)
    {
      v19 = v17 + 2;
      do
        v18 = *(_QWORD *)((v18 & 0xFFFFFFFFFFFFFFFELL) + 8 * ((v16 >> (32 - 4 * v19++)) & 0xF));
      while ((v18 & 1) != 0);
    }
    if (!v18 || ((*(uint64_t (**)(uint64_t))(*(_QWORD *)v18 + 16))(v18) & 1) == 0)
    {
LABEL_22:
      if (*(_QWORD *)v13 != -1)
      {
        v14 = (uint64_t *)v49 + 3 * (*(_QWORD *)v13 & 3) + ((*(_QWORD *)v13 >> 2) & 3);
        v15 = *v14;
        if (!*v14)
        {
          if (!__kSIUINT64SetTypeID)
            __kSIUINT64SetTypeID = _CFRuntimeRegisterClass();
          v15 = _CFRuntimeCreateInstance();
          *v14 = v15;
        }
        SIValueSet<unsigned long long>::SIValueSetInsert((unint64_t *)(v15 + 16), v11);
      }
    }
    if (++v11 >= *(_QWORD *)(v2 + 376))
      goto LABEL_38;
  }
  v78 = 0u;
  v79 = 0u;
  v76 = 0u;
  v77 = 0u;
  v74 = 0u;
  v75 = 0u;
  v72 = 0u;
  v73 = 0u;
  v70 = 0u;
  v71 = 0u;
  v68 = 0u;
  v69 = 0u;
  v66 = 0u;
  v67 = 0u;
  memset(buf, 0, sizeof(buf));
  __error();
  v45 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
  {
    v46 = *(_QWORD *)(v2 + 376);
    v47 = *(_QWORD *)(v2 + 288);
    v48 = fd_name(*(_QWORD *)(v2 + 240), (char *)buf, 0x100uLL);
    *(_DWORD *)v51 = 136316674;
    v52 = "_data_map_ext_get_offset_entry";
    v53 = 1024;
    v54 = 409;
    v55 = 2048;
    v56 = v11;
    v57 = 2048;
    v58 = v46;
    v59 = 2048;
    v60 = v2;
    v61 = 2048;
    v62 = v47;
    v63 = 2080;
    v64 = v48;
    _os_log_error_impl(&dword_1B8270000, v45, OS_LOG_TYPE_ERROR, "%s:%d: invalid data id %lld max %lld %p map: %p %s", v51, 0x44u);
  }
  __error();
  __break(1u);
}

uint64_t db_dirty_datastore(int *a1)
{
  int v3;
  NSObject *v4;
  int v5;
  char *v6;
  char *v7;
  const char *v8;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  int v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (*a1 != 1685287992)
  {
    v3 = *__error();
    v4 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = *a1;
      *(_DWORD *)buf = 136315650;
      v10 = "db_dirty_datastore";
      v11 = 1024;
      v12 = 252;
      v13 = 1024;
      v14 = v5;
      _os_log_error_impl(&dword_1B8270000, v4, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v3;
    v6 = __si_assert_copy_extra_268();
    v7 = v6;
    if (v6)
      v8 = v6;
    else
      v8 = "";
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 252, v8);
    free(v7);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  return db2_dirty_datastore((uint64_t)a1);
}

void db_release_datastore(int *a1)
{
  int v2;
  NSObject *v3;
  int v4;
  char *v5;
  char *v6;
  const char *v7;
  uint8_t buf[4];
  const char *v9;
  __int16 v10;
  int v11;
  __int16 v12;
  int v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (*a1 != 1685287992)
  {
    v2 = *__error();
    v3 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      v4 = *a1;
      *(_DWORD *)buf = 136315650;
      v9 = "db_release_datastore";
      v10 = 1024;
      v11 = 256;
      v12 = 1024;
      v13 = v4;
      _os_log_error_impl(&dword_1B8270000, v3, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v2;
    v5 = __si_assert_copy_extra_268();
    v6 = v5;
    if (v5)
      v7 = v5;
    else
      v7 = "";
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 256, v7);
    free(v6);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  db2_sync_datastore((uint64_t)a1, 1);
  db2_release_datastore_no_sync((uint64_t)a1);
}

uint64_t db_lock_datastore(int *a1)
{
  unsigned int v2;
  unint64_t v3;
  signed int v4;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  int v9;
  NSObject *v10;
  int v11;
  char *v12;
  char *v13;
  const char *v14;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (*a1 != 1685287992)
  {
    v9 = *__error();
    v10 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      v11 = *a1;
      *(_DWORD *)buf = 136315650;
      v16 = "db_lock_datastore";
      v17 = 1024;
      v18 = 264;
      v19 = 1024;
      v20 = v11;
      _os_log_error_impl(&dword_1B8270000, v10, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v9;
    v12 = __si_assert_copy_extra_268();
    v13 = v12;
    if (v12)
      v14 = v12;
    else
      v14 = "";
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 264, v14);
    free(v13);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  HIDWORD(v3) = qos_class_self() - 9;
  LODWORD(v3) = HIDWORD(v3);
  v2 = v3 >> 2;
  if (v2 > 6)
    v4 = 0;
  else
    v4 = dword_1B8630ED0[v2];
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 146));
  if (*((_QWORD *)a1 + 96) || a1[195] || *((_BYTE *)a1 + 796))
    goto LABEL_8;
  if (v4 > 5)
  {
LABEL_16:
    *((_QWORD *)a1 + 96) = pthread_self();
    return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 146));
  }
  if (!*(_QWORD *)&a1[4 * v4 + 162])
  {
    v6 = v4 - 1;
    v7 = (uint64_t *)&a1[4 * v4 + 166];
    while (v6 != 4)
    {
      v8 = *v7;
      v7 += 2;
      ++v6;
      if (v8)
      {
        if (v6 <= 4)
          goto LABEL_8;
        goto LABEL_16;
      }
    }
    goto LABEL_16;
  }
LABEL_8:
  db_rwlock_wait((uint64_t)(a1 + 146), v4, 2);
  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 146));
}

uint64_t db_unlock_datastore(int *a1)
{
  pthread_override_s *v2;
  char v3;
  uint64_t result;
  int v5;
  NSObject *v6;
  int v7;
  char *v8;
  char *v9;
  const char *v10;
  uint8_t buf[4];
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (*a1 != 1685287992)
  {
    v5 = *__error();
    v6 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v7 = *a1;
      *(_DWORD *)buf = 136315650;
      v12 = "db_unlock_datastore";
      v13 = 1024;
      v14 = 265;
      v15 = 1024;
      v16 = v7;
      _os_log_error_impl(&dword_1B8270000, v6, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v5;
    v8 = __si_assert_copy_extra_268();
    v9 = v8;
    if (v8)
      v10 = v8;
    else
      v10 = "";
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 265, v10);
    free(v9);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 146));
  a1[197] = 0;
  v2 = (pthread_override_s *)*((_QWORD *)a1 + 95);
  *((_QWORD *)a1 + 96) = 0;
  *((_QWORD *)a1 + 95) = 0;
  v3 = a1[195] != 0;
  *((_BYTE *)a1 + 796) = 0;
  db_rwlock_wakeup((uint64_t)(a1 + 146), v3, 0);
  result = pthread_mutex_unlock((pthread_mutex_t *)(a1 + 146));
  if (v2)
    return pthread_override_qos_class_end_np(v2);
  return result;
}

uint64_t db_downgrade_datastore(int *a1)
{
  int v3;
  NSObject *v4;
  int v5;
  char *v6;
  char *v7;
  const char *v8;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  int v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (*a1 != 1685287992)
  {
    v3 = *__error();
    v4 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = *a1;
      *(_DWORD *)buf = 136315650;
      v10 = "db_downgrade_datastore";
      v11 = 1024;
      v12 = 266;
      v13 = 1024;
      v14 = v5;
      _os_log_error_impl(&dword_1B8270000, v4, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v3;
    v6 = __si_assert_copy_extra_268();
    v7 = v6;
    if (v6)
      v8 = v6;
    else
      v8 = "";
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 266, v8);
    free(v7);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 146));
  *((_BYTE *)a1 + 796) = 1;
  db_rwlock_wakeup((uint64_t)(a1 + 146), 1, 1);
  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 146));
}

uint64_t db_flush_datastore(uint64_t a1, _DWORD *a2)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  NSObject *v11;
  const char *v12;
  NSObject *v13;
  int v15;
  uint64_t v16;
  uint64_t i;
  uint64_t v18;
  uint64_t v19;
  _DWORD *v20;
  int v21;
  int v22;
  int *v23;
  int v24;
  NSObject *v25;
  CFAbsoluteTime Current;
  int v27;
  NSObject *v28;
  int v29;
  NSObject *v30;
  int v31;
  NSObject *v32;
  int v33;
  char *v34;
  char *v35;
  const char *v36;
  NSObject *log;
  NSObject *loga;
  int v39;
  int v40;
  uint8_t buf[4];
  _BYTE v42[10];
  _BYTE v43[6];
  uint64_t v44;
  __int16 v45;
  int v46;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)a1 != 1685287992)
  {
    v31 = *__error();
    v32 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
    {
      v33 = *(_DWORD *)a1;
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)v42 = "db_flush_datastore";
      *(_WORD *)&v42[8] = 1024;
      *(_DWORD *)v43 = 268;
      *(_WORD *)&v43[4] = 1024;
      LODWORD(v44) = v33;
      _os_log_error_impl(&dword_1B8270000, v32, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v31;
    v34 = __si_assert_copy_extra_268();
    v35 = v34;
    if (v34)
      v36 = v34;
    else
      v36 = "";
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 268, v36);
    free(v35);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  if (dword_1EF19FCA8 >= 5)
  {
    v27 = *__error();
    v28 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134217984;
      *(_QWORD *)v42 = CFAbsoluteTimeGetCurrent();
      _os_log_impl(&dword_1B8270000, v28, OS_LOG_TYPE_DEFAULT, "Flush starting at %f", buf, 0xCu);
    }
    *__error() = v27;
  }
  v4 = *(_QWORD *)(a1 + 920);
  if (!v4)
  {
LABEL_8:
    v6 = 0;
    goto LABEL_12;
  }
  v5 = *(_DWORD *)(v4 + 216);
  switch(v5)
  {
    case -270471200:
      v7 = *(_QWORD *)(v4 + 376);
      break;
    case 1684300900:
      v7 = *(_QWORD *)(v4 + 4496);
      break;
    case 842150450:
      v6 = (*(_DWORD *)(v4 + 364) - 1);
      goto LABEL_12;
    default:
      goto LABEL_8;
  }
  v6 = v7 - 1;
LABEL_12:
  if (dword_1EF19FCA8 >= 5)
  {
    v29 = *__error();
    v30 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134217984;
      *(_QWORD *)v42 = v6;
      _os_log_impl(&dword_1B8270000, v30, OS_LOG_TYPE_DEFAULT, "Flush at vector count %zu", buf, 0xCu);
    }
    *__error() = v29;
  }
  *a2 = 0;
  if ((*(_BYTE *)(a1 + 804) & 8) == 0)
  {
    if ((*(_BYTE *)(a1 + 4) & 2) != 0)
    {
      v10 = *__error();
      v13 = _SILogForLogForCategory(7);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)v42 = "db2_flush_datastore";
        *(_WORD *)&v42[8] = 1024;
        *(_DWORD *)v43 = 8494;
        *(_WORD *)&v43[4] = 2080;
        v44 = a1 + 324;
        _os_log_error_impl(&dword_1B8270000, v13, OS_LOG_TYPE_ERROR, "%s:%d: %s : db2_sync_datastore: !WARNING! prior write-errors invalidate sync.\n", buf, 0x1Cu);
      }
      v9 = 22;
      goto LABEL_22;
    }
    v8 = _db2_flush_all_cache(a1, 1);
    if ((_DWORD)v8)
    {
      v9 = v8;
      v10 = *__error();
      v11 = _SILogForLogForCategory(7);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315906;
        *(_QWORD *)v42 = "db2_flush_datastore";
        *(_WORD *)&v42[8] = 1024;
        *(_DWORD *)v43 = 8509;
        *(_WORD *)&v43[4] = 2080;
        v44 = a1 + 324;
        v45 = 1024;
        v46 = v9;
        v12 = "%s:%d: %s : db2_sync_datastore: !WARNING! write-errors flushing cache. %d\n";
LABEL_27:
        _os_log_error_impl(&dword_1B8270000, v11, OS_LOG_TYPE_ERROR, v12, buf, 0x22u);
      }
    }
    else
    {
      v15 = *(_DWORD *)(*(_QWORD *)(a1 + 856) + 12);
      v16 = map_write(a1);
      if (!(_DWORD)v16)
      {
        for (i = 0; i != 6; ++i)
        {
          v18 = a1 + 8 * i;
          v19 = *(_QWORD *)(v18 + 880);
          if (i == 5 || (*(_DWORD *)(a1 + 804) & 0x14) != 0)
          {
            if (v19)
            {
              v21 = *(_DWORD *)(v19 + 216);
              switch(v21)
              {
                case -270471200:
                  data_map_ext_flush(v19);
                  break;
                case 1684300900:
                  data_map64_flush(v19);
                  break;
                case 842150450:
                  data_map32_flush(v19);
                  break;
              }
            }
          }
          else
          {
            v20 = *(_DWORD **)(v19 + 8);
            if (v20)
            {
              page_release(a1, v20, *(_DWORD *)v19, 5u, 0);
              if (dword_1EF19FCA8 >= 5)
              {
                v40 = *__error();
                loga = _SILogForLogForCategory(7);
                if (os_log_type_enabled(loga, OS_LOG_TYPE_DEFAULT))
                {
                  v23 = *(int **)(v18 + 880);
                  v24 = *v23;
                  LODWORD(v23) = v23[14];
                  *(_DWORD *)buf = 67109632;
                  *(_DWORD *)v42 = v24;
                  *(_WORD *)&v42[4] = 1024;
                  *(_DWORD *)&v42[6] = i;
                  *(_WORD *)v43 = 1024;
                  *(_DWORD *)&v43[2] = (_DWORD)v23;
                  _os_log_impl(&dword_1B8270000, loga, OS_LOG_TYPE_DEFAULT, "Push dirty string page %d to disk (%d). %d strings", buf, 0x14u);
                }
                *__error() = v40;
              }
              *(_QWORD *)(*(_QWORD *)(v18 + 880) + 8) = 0;
              **(_DWORD **)(v18 + 880) = -1;
            }
            else if (dword_1EF19FCA8 >= 5)
            {
              v39 = *__error();
              log = _SILogForLogForCategory(7);
              if (os_log_type_enabled(log, OS_LOG_TYPE_DEFAULT))
              {
                v22 = *(_DWORD *)(*(_QWORD *)(v18 + 880) + 56);
                *(_DWORD *)buf = 67109376;
                *(_DWORD *)v42 = i;
                *(_WORD *)&v42[4] = 1024;
                *(_DWORD *)&v42[6] = v22;
                _os_log_impl(&dword_1B8270000, log, OS_LOG_TYPE_DEFAULT, "No dirty string page for %d. %d strings", buf, 0xEu);
              }
              *__error() = v39;
            }
          }
        }
        if ((*(_BYTE *)(a1 + 4) & 1) != 0 && (v15 & 1) == 0)
          return 0;
        *a2 = 1;
        fd_sync(*(_QWORD *)(a1 + 848), 0);
        v9 = 0;
        if (dword_1EF19FCA8 < 5)
          return v9;
        v10 = *__error();
        v25 = _SILogForLogForCategory(7);
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
        {
          Current = CFAbsoluteTimeGetCurrent();
          *(_DWORD *)buf = 134217984;
          *(CFAbsoluteTime *)v42 = Current;
          _os_log_impl(&dword_1B8270000, v25, OS_LOG_TYPE_DEFAULT, "Flush ending at %f", buf, 0xCu);
        }
        v9 = 0;
        goto LABEL_22;
      }
      v9 = v16;
      v10 = *__error();
      v11 = _SILogForLogForCategory(7);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315906;
        *(_QWORD *)v42 = "db2_flush_datastore";
        *(_WORD *)&v42[8] = 1024;
        *(_DWORD *)v43 = 8520;
        *(_WORD *)&v43[4] = 2080;
        v44 = a1 + 324;
        v45 = 1024;
        v46 = v9;
        v12 = "%s:%d: %s : db2_sync_datastore: !WARNING! write-errors writing map. %d\n";
        goto LABEL_27;
      }
    }
LABEL_22:
    *__error() = v10;
    return v9;
  }
  return 13;
}

uint64_t db_commit_sync_datastore(uint64_t a1, int a2)
{
  unsigned int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  _DWORD *v8;
  uint64_t v9;
  int v10;
  int v11;
  NSObject *v12;
  int *v14;
  char *v15;
  int v16;
  NSObject *v17;
  uint64_t v18;
  int v19;
  NSObject *v20;
  unsigned int v21;
  char *v22;
  char *v23;
  const char *v24;
  _BYTE buf[12];
  __int16 v26;
  int v27;
  __int16 v28;
  uint64_t v29;
  __int16 v30;
  char *v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)a1 != 1685287992)
  {
    v19 = *__error();
    v20 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      v21 = *(_DWORD *)a1;
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "db_commit_sync_datastore";
      v26 = 1024;
      v27 = 269;
      v28 = 1024;
      LODWORD(v29) = v21;
      _os_log_error_impl(&dword_1B8270000, v20, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v19;
    v22 = __si_assert_copy_extra_268();
    v23 = v22;
    if (v22)
      v24 = v22;
    else
      v24 = "";
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 269, v24);
    free(v23);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  if (dword_1EF19FCA8 >= 5)
  {
    v16 = *__error();
    v17 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      v18 = data_map_count(*(_QWORD *)(a1 + 920));
      *(_DWORD *)buf = 134217984;
      *(_QWORD *)&buf[4] = v18;
      _os_log_impl(&dword_1B8270000, v17, OS_LOG_TYPE_DEFAULT, "Commit sync at vector count %lld", buf, 0xCu);
    }
    *__error() = v16;
  }
  v4 = *(_DWORD *)(a1 + 4);
  if ((v4 & 2) == 0)
  {
    v5 = v4 | 0x401;
    v4 = v4 & 0xFFFFF9FE | 0x201;
    if (a2)
      v4 = v5;
    *(_DWORD *)(a1 + 4) = v4;
  }
  if ((v4 & 0x80) != 0)
  {
    *(_DWORD *)a1 = bswap32(*(_DWORD *)a1);
    *(_DWORD *)(a1 + 4) = bswap32(v4);
    *(int8x8_t *)(a1 + 8) = vrev32_s8(*(int8x8_t *)(a1 + 8));
    *(_DWORD *)(a1 + 16) = bswap32(*(_DWORD *)(a1 + 16));
    *(int8x16_t *)(a1 + 20) = vrev64q_s8(*(int8x16_t *)(a1 + 20));
    *(int8x16_t *)(a1 + 36) = vrev32q_s8(*(int8x16_t *)(a1 + 36));
    *(int8x16_t *)(a1 + 52) = vrev32q_s8(*(int8x16_t *)(a1 + 52));
  }
  v6 = fd_pwrite(*(_QWORD *)(a1 + 848), a1, 0x1000uLL, 0);
  v7 = *__error();
  if ((*(_DWORD *)(a1 + 4) & 0x80000000) != 0)
  {
    *(int8x16_t *)a1 = vrev32q_s8(*(int8x16_t *)a1);
    *(_DWORD *)(a1 + 16) = bswap32(*(_DWORD *)(a1 + 16));
    *(int8x16_t *)(a1 + 20) = vrev64q_s8(*(int8x16_t *)(a1 + 20));
    *(int8x16_t *)(a1 + 36) = vrev32q_s8(*(int8x16_t *)(a1 + 36));
    *(int8x16_t *)(a1 + 52) = vrev32q_s8(*(int8x16_t *)(a1 + 52));
  }
  if (v6 == 4096)
  {
    v8 = *(_DWORD **)(a1 + 848);
    *(_QWORD *)buf = 0;
    v9 = _fd_acquire_fd((uint64_t)v8, buf);
    if ((_DWORD)v9 != -1)
    {
      v10 = v9;
      prot_fsync(v9, 0);
      _fd_release_fd(v8, v10, 0, *(uint64_t *)buf);
    }
    if ((*(_BYTE *)(a1 + 804) & 0x14) != 0)
    {
      data_map_commit_sync(*(_QWORD *)(a1 + 880));
      if ((*(_BYTE *)(a1 + 804) & 0x14) != 0)
      {
        data_map_commit_sync(*(_QWORD *)(a1 + 888));
        if ((*(_BYTE *)(a1 + 804) & 0x14) != 0)
        {
          data_map_commit_sync(*(_QWORD *)(a1 + 896));
          if ((*(_BYTE *)(a1 + 804) & 0x14) != 0)
          {
            data_map_commit_sync(*(_QWORD *)(a1 + 904));
            if ((*(_BYTE *)(a1 + 804) & 0x14) != 0)
              data_map_commit_sync(*(_QWORD *)(a1 + 912));
          }
        }
      }
    }
    data_map_commit_sync(*(_QWORD *)(a1 + 920));
    return 0;
  }
  else
  {
    *(_DWORD *)(a1 + 800) = v7;
    v11 = *__error();
    v12 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      v14 = __error();
      v15 = strerror(*v14);
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = "db2_commit_sync_datastore";
      v26 = 1024;
      v27 = 8607;
      v28 = 2080;
      v29 = a1 + 324;
      v30 = 2080;
      v31 = v15;
      _os_log_error_impl(&dword_1B8270000, v12, OS_LOG_TYPE_ERROR, "%s:%d: %s : db2_sync_datastore: ERR: Can't write DST header (%s)\n", buf, 0x26u);
    }
    *__error() = v11;
    *(_DWORD *)(a1 + 4) |= 2u;
  }
  return v7;
}

uint64_t db_shadow_datastore(uint64_t a1, int a2)
{
  uint64_t v4;
  int v5;
  CFNumberRef v6;
  int v7;
  char v8;
  uint64_t v9;
  int v10;
  NSObject *v11;
  uint64_t v12;
  double *v13;
  double v14;
  uint64_t v15;
  int v16;
  NSObject *v17;
  __int32 v18;
  int8x16_t v19;
  int8x16_t v20;
  _DWORD *v21;
  uint64_t v22;
  int v23;
  double v24;
  int v25;
  int v26;
  NSObject *v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  int v39;
  int v40;
  NSObject *v41;
  uint64_t v42;
  int v43;
  uint64_t v44;
  int v46;
  NSObject *v47;
  uint64_t v48;
  int v49;
  NSObject *v50;
  int v51;
  char *v52;
  char *v53;
  const char *v54;
  uint64_t v55;
  _BYTE valuePtr[18];
  __int16 v57;
  int v58;
  __int16 v59;
  uint64_t v60;
  uint64_t v61;

  v61 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)a1 != 1685287992)
  {
    v49 = *__error();
    v50 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
    {
      v51 = *(_DWORD *)a1;
      *(_DWORD *)valuePtr = 136315650;
      *(_QWORD *)&valuePtr[4] = "db_shadow_datastore";
      *(_WORD *)&valuePtr[12] = 1024;
      *(_DWORD *)&valuePtr[14] = 270;
      v57 = 1024;
      v58 = v51;
      _os_log_error_impl(&dword_1B8270000, v50, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", valuePtr, 0x18u);
    }
    *__error() = v49;
    v52 = __si_assert_copy_extra_268();
    v53 = v52;
    if (v52)
      v54 = v52;
    else
      v54 = "";
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 270, v54);
    free(v53);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  if (dword_1EF19FCA8 >= 5)
  {
    v46 = *__error();
    v47 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
    {
      v48 = data_map_count(*(_QWORD *)(a1 + 920));
      *(_DWORD *)valuePtr = 134217984;
      *(_QWORD *)&valuePtr[4] = v48;
      _os_log_impl(&dword_1B8270000, v47, OS_LOG_TYPE_DEFAULT, "Shadow at vector count %lld", valuePtr, 0xCu);
    }
    *__error() = v46;
  }
  v4 = *(_QWORD *)(a1 + 848);
  if (v4)
    v5 = *(_DWORD *)(v4 + 44);
  else
    v5 = -1;
  *(_DWORD *)valuePtr = v5;
  v6 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, valuePtr);
  pthread_mutex_lock(&registeredFdsLock);
  if (registeredCloneFds)
  {
    v7 = CFSetContainsValue((CFSetRef)registeredCloneFds, v6);
    pthread_mutex_unlock(&registeredFdsLock);
    CFRelease(v6);
    if (v7 && !*(_BYTE *)(a1 + 988))
    {
      v8 = a2 ^ 1;
      v9 = fd_copyfile(*(_QWORD *)(a1 + 848), *(_QWORD *)(a1 + 840), a2 ^ 1u);
      if ((v8 & 1) == 0)
      {
        if (db_upgrade_lock(a1 + 584))
          sdb2_die(a1, "Multiple threads entering in sdb!", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 8648);
        v10 = *__error();
        v11 = _SILogForLogForCategory(7);
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)valuePtr = 0;
          _os_log_impl(&dword_1B8270000, v11, OS_LOG_TYPE_DEFAULT, "Defragging index...", valuePtr, 2u);
        }
        *__error() = v10;
        v12 = *(_QWORD *)(a1 + 848);
        v13 = (double *)fd_dup(v12);
        *(_QWORD *)(a1 + 848) = v13;
        if (*(_BYTE *)(a1 + 988))
        {
          if (v12)
            v14 = *(double *)(v12 + 88);
          else
            v14 = 0.0;
          v24 = v14 - CFAbsoluteTimeGetCurrent();
          if (v24 > 0.0)
          {
            v55 = 0;
            v25 = _fd_acquire_fd((uint64_t)v13, &v55);
            *(_QWORD *)valuePtr = 0;
            *(_QWORD *)&valuePtr[8] = (unint64_t)(v24 * 1000000000.0);
            if (!fcntl(v25, 108, valuePtr))
            {
              if (v12)
                *(_QWORD *)(v12 + 88) = 0;
              if (v13)
                v13[11] = v14;
            }
            _fd_release_fd(v13, v25, 0, v55);
          }
          v13 = *(double **)(a1 + 848);
        }
        fd_copyfile(*(_QWORD *)(a1 + 840), (uint64_t)v13, 1);
        fd_release((char *)v12);
        pthread_mutex_lock((pthread_mutex_t *)(a1 + 584));
        *(_BYTE *)(a1 + 796) = 1;
        db_rwlock_wakeup(a1 + 584, 1, 1);
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 584));
      }
      if ((_DWORD)v9)
      {
        v26 = *__error();
        v27 = _SILogForLogForCategory(7);
        if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)valuePtr = 136315906;
          *(_QWORD *)&valuePtr[4] = "db2_shadow_datastore";
          *(_WORD *)&valuePtr[12] = 1024;
          *(_DWORD *)&valuePtr[14] = 8669;
          v57 = 1024;
          v58 = v9;
          v59 = 2080;
          v60 = a1 + 324;
          _os_log_error_impl(&dword_1B8270000, v27, OS_LOG_TYPE_ERROR, "%s:%d: copyFile: ERR:%d (%s)\n", valuePtr, 0x22u);
        }
        *__error() = v26;
        v18 = *(_DWORD *)(a1 + 4);
LABEL_42:
        *(_DWORD *)(a1 + 4) = v18 | 2;
        *(_DWORD *)(a1 + 800) = v9;
        goto LABEL_92;
      }
      *(_DWORD *)(a1 + 872) = 0;
      goto LABEL_44;
    }
  }
  else
  {
    pthread_mutex_unlock(&registeredFdsLock);
    CFRelease(v6);
  }
  if ((*(_DWORD *)(a1 + 4) & 0x80) != 0)
  {
    *(int8x16_t *)a1 = vrev32q_s8(*(int8x16_t *)a1);
    *(_DWORD *)(a1 + 16) = bswap32(*(_DWORD *)(a1 + 16));
    *(int8x16_t *)(a1 + 20) = vrev64q_s8(*(int8x16_t *)(a1 + 20));
    *(int8x16_t *)(a1 + 36) = vrev32q_s8(*(int8x16_t *)(a1 + 36));
    *(int8x16_t *)(a1 + 52) = vrev32q_s8(*(int8x16_t *)(a1 + 52));
  }
  v15 = sync_dirty_chunks(a1);
  if (!(_DWORD)v15)
  {
    v21 = *(_DWORD **)(a1 + 840);
    *(_QWORD *)valuePtr = 0;
    v22 = _fd_acquire_fd((uint64_t)v21, valuePtr);
    if ((_DWORD)v22 != -1)
    {
      v23 = v22;
      prot_fsync(v22, 0);
      _fd_release_fd(v21, v23, 0, *(uint64_t *)valuePtr);
    }
LABEL_44:
    if ((*(_BYTE *)(a1 + 804) & 0x14) != 0)
    {
      v28 = *(_QWORD *)(a1 + 880);
      if (v28)
      {
        v29 = *(_DWORD *)(v28 + 216);
        switch(v29)
        {
          case -270471200:
            data_map_ext_shadow(v28);
            break;
          case 1684300900:
            data_map64_shadow(v28);
            break;
          case 842150450:
            data_map32_shadow(v28);
            break;
        }
      }
      if ((*(_BYTE *)(a1 + 804) & 0x14) != 0)
      {
        v30 = *(_QWORD *)(a1 + 888);
        if (v30)
        {
          v31 = *(_DWORD *)(v30 + 216);
          switch(v31)
          {
            case -270471200:
              data_map_ext_shadow(v30);
              break;
            case 1684300900:
              data_map64_shadow(v30);
              break;
            case 842150450:
              data_map32_shadow(v30);
              break;
          }
        }
        if ((*(_BYTE *)(a1 + 804) & 0x14) != 0)
        {
          v32 = *(_QWORD *)(a1 + 896);
          if (v32)
          {
            v33 = *(_DWORD *)(v32 + 216);
            switch(v33)
            {
              case -270471200:
                data_map_ext_shadow(v32);
                break;
              case 1684300900:
                data_map64_shadow(v32);
                break;
              case 842150450:
                data_map32_shadow(v32);
                break;
            }
          }
          if ((*(_BYTE *)(a1 + 804) & 0x14) != 0)
          {
            v34 = *(_QWORD *)(a1 + 904);
            if (v34)
            {
              v35 = *(_DWORD *)(v34 + 216);
              switch(v35)
              {
                case -270471200:
                  data_map_ext_shadow(v34);
                  break;
                case 1684300900:
                  data_map64_shadow(v34);
                  break;
                case 842150450:
                  data_map32_shadow(v34);
                  break;
              }
            }
            if ((*(_BYTE *)(a1 + 804) & 0x14) != 0)
            {
              v36 = *(_QWORD *)(a1 + 912);
              if (v36)
              {
                v37 = *(_DWORD *)(v36 + 216);
                switch(v37)
                {
                  case -270471200:
                    data_map_ext_shadow(v36);
                    break;
                  case 1684300900:
                    data_map64_shadow(v36);
                    break;
                  case 842150450:
                    data_map32_shadow(v36);
                    break;
                }
              }
            }
          }
        }
      }
    }
    v38 = *(_QWORD *)(a1 + 920);
    if (v38)
    {
      v39 = *(_DWORD *)(v38 + 216);
      switch(v39)
      {
        case -270471200:
          data_map_ext_shadow(v38);
          break;
        case 1684300900:
          data_map64_shadow(v38);
          break;
        case 842150450:
          data_map32_shadow(v38);
          break;
      }
    }
    v9 = 0;
    goto LABEL_92;
  }
  v9 = v15;
  v16 = *__error();
  v17 = _SILogForLogForCategory(7);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)valuePtr = 136315906;
    *(_QWORD *)&valuePtr[4] = "db2_shadow_datastore";
    *(_WORD *)&valuePtr[12] = 1024;
    *(_DWORD *)&valuePtr[14] = 8720;
    v57 = 1024;
    v58 = v9;
    v59 = 2080;
    v60 = a1 + 324;
    _os_log_error_impl(&dword_1B8270000, v17, OS_LOG_TYPE_ERROR, "%s:%d: sync_dirty_chunks: ERR:%d (%s)\n", valuePtr, 0x22u);
  }
  *__error() = v16;
  v18 = *(_DWORD *)(a1 + 4);
  if (v18 < 0)
  {
    *(_DWORD *)a1 = bswap32(*(_DWORD *)a1);
    v19.i32[0] = v18;
    v19.i32[1] = *(_DWORD *)(a1 + 8);
    v19.i64[1] = *(_QWORD *)(a1 + 12);
    v20 = vrev32q_s8(v19);
    *(int8x16_t *)(a1 + 4) = v20;
    *(int8x16_t *)(a1 + 20) = vrev64q_s8(*(int8x16_t *)(a1 + 20));
    *(int8x16_t *)(a1 + 36) = vrev32q_s8(*(int8x16_t *)(a1 + 36));
    *(int8x16_t *)(a1 + 52) = vrev32q_s8(*(int8x16_t *)(a1 + 52));
    v18 = v20.i32[0];
  }
  if ((_DWORD)v9 != 28)
    goto LABEL_42;
LABEL_92:
  v40 = *__error();
  v41 = _SILogForLogForCategory(7);
  if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
  {
    v42 = *(_QWORD *)(a1 + 920);
    if (v42)
    {
      v43 = *(_DWORD *)(v42 + 216);
      if (v43 == -270471200)
      {
        v44 = *(_QWORD *)(v42 + 376);
      }
      else
      {
        if (v43 != 1684300900)
        {
          if (v43 == 842150450)
            v42 = (*(_DWORD *)(v42 + 364) - 1);
          else
            v42 = 0;
          goto LABEL_102;
        }
        v44 = *(_QWORD *)(v42 + 4496);
      }
      v42 = v44 - 1;
    }
LABEL_102:
    *(_DWORD *)valuePtr = 134217984;
    *(_QWORD *)&valuePtr[4] = v42;
    _os_log_impl(&dword_1B8270000, v41, OS_LOG_TYPE_DEFAULT, "Shadow completed at vector count %lld", valuePtr, 0xCu);
  }
  *__error() = v40;
  return v9;
}

uint64_t db_commit_shadow_datastore(uint64_t a1)
{
  uint64_t v2;
  unsigned int v3;
  uint64_t v4;
  int v5;
  NSObject *v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  int v18;
  _DWORD *v19;
  uint64_t v20;
  int v21;
  _DWORD *v22;
  uint64_t v23;
  int v24;
  int v26;
  NSObject *v27;
  uint64_t v28;
  int v29;
  NSObject *v30;
  uint64_t v31;
  int v32;
  NSObject *v33;
  int v34;
  char *v35;
  char *v36;
  const char *v37;
  _BYTE buf[12];
  __int16 v39;
  int v40;
  __int16 v41;
  uint64_t v42;
  __int16 v43;
  int v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)a1 != 1685287992)
  {
    v32 = *__error();
    v33 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
    {
      v34 = *(_DWORD *)a1;
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "db_commit_shadow_datastore";
      v39 = 1024;
      v40 = 271;
      v41 = 1024;
      LODWORD(v42) = v34;
      _os_log_error_impl(&dword_1B8270000, v33, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v32;
    v35 = __si_assert_copy_extra_268();
    v36 = v35;
    if (v35)
      v37 = v35;
    else
      v37 = "";
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 271, v37);
    free(v36);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  if (dword_1EF19FCA8 >= 5)
  {
    v26 = *__error();
    v27 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      v28 = data_map_count(*(_QWORD *)(a1 + 920));
      *(_DWORD *)buf = 134217984;
      *(_QWORD *)&buf[4] = v28;
      _os_log_impl(&dword_1B8270000, v27, OS_LOG_TYPE_DEFAULT, "Commit shadow at vector count %lld", buf, 0xCu);
    }
    *__error() = v26;
  }
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a1 + 4) & 0xFFFFFDFE | 1;
  v2 = fd_pwrite(*(_QWORD *)(a1 + 840), a1, 0x1000uLL, 0);
  v3 = *__error();
  if ((*(_DWORD *)(a1 + 4) & 0x80000000) != 0)
  {
    *(int8x16_t *)a1 = vrev32q_s8(*(int8x16_t *)a1);
    *(_DWORD *)(a1 + 16) = bswap32(*(_DWORD *)(a1 + 16));
    *(int8x16_t *)(a1 + 20) = vrev64q_s8(*(int8x16_t *)(a1 + 20));
    *(int8x16_t *)(a1 + 36) = vrev32q_s8(*(int8x16_t *)(a1 + 36));
    *(int8x16_t *)(a1 + 52) = vrev32q_s8(*(int8x16_t *)(a1 + 52));
  }
  if (v2 == 4096)
    goto LABEL_12;
  if (v2 >= 0)
    v4 = 22;
  else
    v4 = v3;
  v5 = *__error();
  v6 = _SILogForLogForCategory(7);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136315906;
    *(_QWORD *)&buf[4] = "db2_commit_shadow_datastore";
    v39 = 1024;
    v40 = 8768;
    v41 = 2080;
    v42 = a1 + 324;
    v43 = 1024;
    v44 = v4;
    _os_log_error_impl(&dword_1B8270000, v6, OS_LOG_TYPE_ERROR, "%s:%d: %s : ERR: Can't write DST master header (2: %d)\n", buf, 0x22u);
  }
  *__error() = v5;
  *(_DWORD *)(a1 + 4) |= 2u;
  *(_DWORD *)(a1 + 800) = v4;
  if (!(_DWORD)v4)
  {
LABEL_12:
    if ((*(_BYTE *)(a1 + 804) & 0x14) != 0)
    {
      v7 = *(_QWORD *)(a1 + 880);
      if (v7)
      {
        v8 = *(_DWORD *)(v7 + 216);
        switch(v8)
        {
          case -270471200:
            data_map_ext_commit_shadow(*(_QWORD *)(a1 + 880));
            break;
          case 1684300900:
            data_map64_commit_shadow(*(_QWORD *)(a1 + 880));
            break;
          case 842150450:
            if (!*(_DWORD *)(v7 + 440) && *(_DWORD *)(*(_QWORD *)(v7 + 264) + 16) == 2)
            {
              SIActivityJournalEvent(*(os_unfair_lock_s **)(v7 + 408), *(_DWORD *)(v7 + 416), 0xEu, 3u, *(_DWORD *)(v7 + 364));
              fd_sync(*(_QWORD *)(v7 + 248), 0);
            }
            fd_release(*(char **)(v7 + 248));
            *(_QWORD *)(v7 + 248) = 0;
            break;
        }
      }
      if ((*(_BYTE *)(a1 + 804) & 0x14) != 0)
      {
        v9 = *(_QWORD *)(a1 + 888);
        if (v9)
        {
          v10 = *(_DWORD *)(v9 + 216);
          switch(v10)
          {
            case -270471200:
              data_map_ext_commit_shadow(*(_QWORD *)(a1 + 888));
              break;
            case 1684300900:
              data_map64_commit_shadow(*(_QWORD *)(a1 + 888));
              break;
            case 842150450:
              if (!*(_DWORD *)(v9 + 440) && *(_DWORD *)(*(_QWORD *)(v9 + 264) + 16) == 2)
              {
                SIActivityJournalEvent(*(os_unfair_lock_s **)(v9 + 408), *(_DWORD *)(v9 + 416), 0xEu, 3u, *(_DWORD *)(v9 + 364));
                fd_sync(*(_QWORD *)(v9 + 248), 0);
              }
              fd_release(*(char **)(v9 + 248));
              *(_QWORD *)(v9 + 248) = 0;
              break;
          }
        }
        if ((*(_BYTE *)(a1 + 804) & 0x14) != 0)
        {
          v11 = *(_QWORD *)(a1 + 896);
          if (v11)
          {
            v12 = *(_DWORD *)(v11 + 216);
            switch(v12)
            {
              case -270471200:
                data_map_ext_commit_shadow(*(_QWORD *)(a1 + 896));
                break;
              case 1684300900:
                data_map64_commit_shadow(*(_QWORD *)(a1 + 896));
                break;
              case 842150450:
                if (!*(_DWORD *)(v11 + 440) && *(_DWORD *)(*(_QWORD *)(v11 + 264) + 16) == 2)
                {
                  SIActivityJournalEvent(*(os_unfair_lock_s **)(v11 + 408), *(_DWORD *)(v11 + 416), 0xEu, 3u, *(_DWORD *)(v11 + 364));
                  fd_sync(*(_QWORD *)(v11 + 248), 0);
                }
                fd_release(*(char **)(v11 + 248));
                *(_QWORD *)(v11 + 248) = 0;
                break;
            }
          }
          if ((*(_BYTE *)(a1 + 804) & 0x14) != 0)
          {
            v13 = *(_QWORD *)(a1 + 904);
            if (v13)
            {
              v14 = *(_DWORD *)(v13 + 216);
              switch(v14)
              {
                case -270471200:
                  data_map_ext_commit_shadow(v13);
                  break;
                case 1684300900:
                  data_map64_commit_shadow(v13);
                  break;
                case 842150450:
                  data_map32_commit_shadow(v13);
                  break;
              }
            }
            if ((*(_BYTE *)(a1 + 804) & 0x14) != 0)
            {
              v15 = *(_QWORD *)(a1 + 912);
              if (v15)
              {
                v16 = *(_DWORD *)(v15 + 216);
                switch(v16)
                {
                  case -270471200:
                    data_map_ext_commit_shadow(v15);
                    break;
                  case 1684300900:
                    data_map64_commit_shadow(v15);
                    break;
                  case 842150450:
                    data_map32_commit_shadow(v15);
                    break;
                }
              }
            }
          }
        }
      }
    }
    v17 = *(_QWORD *)(a1 + 920);
    if (v17)
    {
      v18 = *(_DWORD *)(v17 + 216);
      switch(v18)
      {
        case -270471200:
          data_map_ext_commit_shadow(*(_QWORD *)(a1 + 920));
          break;
        case 1684300900:
          data_map64_commit_shadow(*(_QWORD *)(a1 + 920));
          break;
        case 842150450:
          if (!*(_DWORD *)(v17 + 440) && *(_DWORD *)(*(_QWORD *)(v17 + 264) + 16) == 2)
          {
            SIActivityJournalEvent(*(os_unfair_lock_s **)(v17 + 408), *(_DWORD *)(v17 + 416), 0xEu, 3u, *(_DWORD *)(v17 + 364));
            v19 = *(_DWORD **)(v17 + 248);
            *(_QWORD *)buf = 0;
            v20 = _fd_acquire_fd((uint64_t)v19, buf);
            if ((_DWORD)v20 != -1)
            {
              v21 = v20;
              prot_fsync(v20, 0);
              _fd_release_fd(v19, v21, 0, *(uint64_t *)buf);
            }
          }
          fd_release(*(char **)(v17 + 248));
          v4 = 0;
          *(_QWORD *)(v17 + 248) = 0;
          goto LABEL_73;
      }
    }
    v4 = 0;
  }
LABEL_73:
  v22 = *(_DWORD **)(a1 + 840);
  *(_QWORD *)buf = 0;
  v23 = _fd_acquire_fd((uint64_t)v22, buf);
  if ((_DWORD)v23 != -1)
  {
    v24 = v23;
    prot_fsync(v23, 0);
    _fd_release_fd(v22, v24, 0, *(uint64_t *)buf);
  }
  if (dword_1EF19FCA8 >= 5)
  {
    v29 = *__error();
    v30 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      v31 = data_map_count(*(_QWORD *)(a1 + 920));
      *(_DWORD *)buf = 134217984;
      *(_QWORD *)&buf[4] = v31;
      _os_log_impl(&dword_1B8270000, v30, OS_LOG_TYPE_DEFAULT, "Commit shadow completed at vector count %lld", buf, 0xCu);
    }
    *__error() = v29;
  }
  return v4;
}

uint64_t db_commit_shadow_complete_datastore(uint64_t a1)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  NSObject *v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  int v18;
  _DWORD *v19;
  uint64_t v20;
  int v21;
  int v23;
  NSObject *v24;
  uint64_t v25;
  int v26;
  NSObject *v27;
  unsigned int v28;
  char *v29;
  char *v30;
  const char *v31;
  _BYTE buf[12];
  __int16 v33;
  int v34;
  __int16 v35;
  uint64_t v36;
  __int16 v37;
  int v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)a1 != 1685287992)
  {
    v26 = *__error();
    v27 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      v28 = *(_DWORD *)a1;
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "db_commit_shadow_complete_datastore";
      v33 = 1024;
      v34 = 272;
      v35 = 1024;
      LODWORD(v36) = v28;
      _os_log_error_impl(&dword_1B8270000, v27, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v26;
    v29 = __si_assert_copy_extra_268();
    v30 = v29;
    if (v29)
      v31 = v29;
    else
      v31 = "";
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 272, v31);
    free(v30);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  if (dword_1EF19FCA8 >= 5)
  {
    v23 = *__error();
    v24 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      v25 = data_map_count(*(_QWORD *)(a1 + 920));
      *(_DWORD *)buf = 134217984;
      *(_QWORD *)&buf[4] = v25;
      _os_log_impl(&dword_1B8270000, v24, OS_LOG_TYPE_DEFAULT, "Commit shadow complete at vector count %lld", buf, 0xCu);
    }
    *__error() = v23;
  }
  v2 = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(a1 + 4) = v2 & 0xFFFFFDFF;
  if ((v2 & 0x80) != 0)
  {
    *(_DWORD *)a1 = bswap32(*(_DWORD *)a1);
    *(_DWORD *)(a1 + 4) = bswap32(v2 & 0xFFFFFDFF);
    *(int8x8_t *)(a1 + 8) = vrev32_s8(*(int8x8_t *)(a1 + 8));
    *(_DWORD *)(a1 + 16) = bswap32(*(_DWORD *)(a1 + 16));
    *(int8x16_t *)(a1 + 20) = vrev64q_s8(*(int8x16_t *)(a1 + 20));
    *(int8x16_t *)(a1 + 36) = vrev32q_s8(*(int8x16_t *)(a1 + 36));
    *(int8x16_t *)(a1 + 52) = vrev32q_s8(*(int8x16_t *)(a1 + 52));
  }
  v3 = fd_pwrite(*(_QWORD *)(a1 + 848), a1, 0x1000uLL, 0);
  __error();
  if ((*(_DWORD *)(a1 + 4) & 0x80000000) != 0)
  {
    *(int8x16_t *)a1 = vrev32q_s8(*(int8x16_t *)a1);
    *(_DWORD *)(a1 + 16) = bswap32(*(_DWORD *)(a1 + 16));
    *(int8x16_t *)(a1 + 20) = vrev64q_s8(*(int8x16_t *)(a1 + 20));
    *(int8x16_t *)(a1 + 36) = vrev32q_s8(*(int8x16_t *)(a1 + 36));
    *(int8x16_t *)(a1 + 52) = vrev32q_s8(*(int8x16_t *)(a1 + 52));
  }
  if (v3 == 4096)
  {
    v4 = 0;
  }
  else
  {
    if (v3 < 0)
      v4 = *__error();
    else
      v4 = 22;
    v5 = *__error();
    v6 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = "db2_commit_shadow_complete_datastore";
      v33 = 1024;
      v34 = 8823;
      v35 = 2080;
      v36 = a1 + 324;
      v37 = 1024;
      v38 = v4;
      _os_log_error_impl(&dword_1B8270000, v6, OS_LOG_TYPE_ERROR, "%s:%d: %s : ERR: Can't write DST header (2: %d)\n", buf, 0x22u);
    }
    *__error() = v5;
    *(_DWORD *)(a1 + 4) |= 2u;
    *(_DWORD *)(a1 + 800) = v4;
  }
  if ((*(_BYTE *)(a1 + 804) & 0x14) != 0)
  {
    v7 = *(_QWORD *)(a1 + 880);
    if (v7)
    {
      v8 = *(_DWORD *)(v7 + 216);
      switch(v8)
      {
        case -270471200:
          data_map_ext_commit_shadow_complete(v7);
          break;
        case 1684300900:
          data_map64_commit_shadow_complete(v7);
          break;
        case 842150450:
          data_map32_commit_shadow_complete(v7);
          break;
      }
    }
    if ((*(_BYTE *)(a1 + 804) & 0x14) != 0)
    {
      v9 = *(_QWORD *)(a1 + 888);
      if (v9)
      {
        v10 = *(_DWORD *)(v9 + 216);
        switch(v10)
        {
          case -270471200:
            data_map_ext_commit_shadow_complete(v9);
            break;
          case 1684300900:
            data_map64_commit_shadow_complete(v9);
            break;
          case 842150450:
            data_map32_commit_shadow_complete(v9);
            break;
        }
      }
      if ((*(_BYTE *)(a1 + 804) & 0x14) != 0)
      {
        v11 = *(_QWORD *)(a1 + 896);
        if (v11)
        {
          v12 = *(_DWORD *)(v11 + 216);
          switch(v12)
          {
            case -270471200:
              data_map_ext_commit_shadow_complete(v11);
              break;
            case 1684300900:
              data_map64_commit_shadow_complete(v11);
              break;
            case 842150450:
              data_map32_commit_shadow_complete(v11);
              break;
          }
        }
        if ((*(_BYTE *)(a1 + 804) & 0x14) != 0)
        {
          v13 = *(_QWORD *)(a1 + 904);
          if (v13)
          {
            v14 = *(_DWORD *)(v13 + 216);
            switch(v14)
            {
              case -270471200:
                data_map_ext_commit_shadow_complete(v13);
                break;
              case 1684300900:
                data_map64_commit_shadow_complete(v13);
                break;
              case 842150450:
                data_map32_commit_shadow_complete(v13);
                break;
            }
          }
          if ((*(_BYTE *)(a1 + 804) & 0x14) != 0)
          {
            v15 = *(_QWORD *)(a1 + 912);
            if (v15)
            {
              v16 = *(_DWORD *)(v15 + 216);
              switch(v16)
              {
                case -270471200:
                  data_map_ext_commit_shadow_complete(v15);
                  break;
                case 1684300900:
                  data_map64_commit_shadow_complete(v15);
                  break;
                case 842150450:
                  data_map32_commit_shadow_complete(v15);
                  break;
              }
            }
          }
        }
      }
    }
  }
  v17 = *(_QWORD *)(a1 + 920);
  if (v17)
  {
    v18 = *(_DWORD *)(v17 + 216);
    switch(v18)
    {
      case -270471200:
        data_map_ext_commit_shadow_complete(v17);
        break;
      case 1684300900:
        data_map64_commit_shadow_complete(v17);
        break;
      case 842150450:
        data_map32_commit_shadow_complete(v17);
        break;
    }
  }
  v19 = *(_DWORD **)(a1 + 848);
  *(_QWORD *)buf = 0;
  v20 = _fd_acquire_fd((uint64_t)v19, buf);
  if ((_DWORD)v20 != -1)
  {
    v21 = v20;
    prot_fsync(v20, 0);
    _fd_release_fd(v19, v21, 0, *(uint64_t *)buf);
  }
  return v4;
}

void db_release_datastore_no_sync(int *a1)
{
  int v2;
  NSObject *v3;
  int v4;
  char *v5;
  char *v6;
  const char *v7;
  uint8_t buf[4];
  const char *v9;
  __int16 v10;
  int v11;
  __int16 v12;
  int v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (*a1 != 1685287992)
  {
    v2 = *__error();
    v3 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      v4 = *a1;
      *(_DWORD *)buf = 136315650;
      v9 = "db_release_datastore_no_sync";
      v10 = 1024;
      v11 = 273;
      v12 = 1024;
      v13 = v4;
      _os_log_error_impl(&dword_1B8270000, v3, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v2;
    v5 = __si_assert_copy_extra_268();
    v6 = v5;
    if (v5)
      v7 = v5;
    else
      v7 = "";
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 273, v7);
    free(v6);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  db2_release_datastore_no_sync((uint64_t)a1);
}

uint64_t db_get_vector_store(int *a1)
{
  int v3;
  NSObject *v4;
  int v5;
  char *v6;
  char *v7;
  const char *v8;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  int v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (*a1 != 1685287992)
  {
    v3 = *__error();
    v4 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = *a1;
      *(_DWORD *)buf = 136315650;
      v10 = "db_get_vector_store";
      v11 = 1024;
      v12 = 280;
      v13 = 1024;
      v14 = v5;
      _os_log_error_impl(&dword_1B8270000, v4, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v3;
    v6 = __si_assert_copy_extra_268();
    v7 = v6;
    if (v6)
      v8 = v6;
    else
      v8 = "";
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 280, v8);
    free(v7);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  return *((_QWORD *)a1 + 115);
}

uint64_t db_set_host(int *a1, uint64_t a2)
{
  uint64_t result;
  int v5;
  const char *v6;
  uint64_t v7;
  int v8;
  int v9;
  NSObject *v10;
  int v11;
  char *v12;
  char *v13;
  const char *v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  char __str[4];
  const char *v20;
  __int16 v21;
  int v22;
  __int16 v23;
  int v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if (*a1 != 1685287992)
  {
    v9 = *__error();
    v10 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      v11 = *a1;
      *(_DWORD *)__str = 136315650;
      v20 = "db_set_host";
      v21 = 1024;
      v22 = 283;
      v23 = 1024;
      v24 = v11;
      _os_log_error_impl(&dword_1B8270000, v10, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", (uint8_t *)__str, 0x18u);
    }
    *__error() = v9;
    v12 = __si_assert_copy_extra_268();
    v13 = v12;
    if (v12)
      v14 = v12;
    else
      v14 = "";
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 283, v14);
    free(v13);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  result = *((_QWORD *)a1 + 115);
  if (result)
    goto LABEL_9;
  bzero(__str, 0x400uLL);
  v5 = strcmp((const char *)a1 + 324, "store.db");
  v6 = "db";
  if (v5)
    v6 = (const char *)(a1 + 81);
  snprintf(__str, 0x400uLL, "%sStr-%d.map", v6, 6);
  v17 = 0u;
  v18 = 0u;
  v15 = 0u;
  v16 = 0u;
  v7 = *((_QWORD *)a1 + 105);
  v8 = v7 ? *(_DWORD *)(v7 + 44) : -1;
  LODWORD(v15) = v8;
  *((_QWORD *)&v15 + 1) = __str;
  *(_QWORD *)&v16 = 0x4100000004;
  *((_QWORD *)&v16 + 1) = _db2_synced_block_callback;
  *(_QWORD *)&v17 = _db2_unmap_callback;
  *((_QWORD *)&v17 + 1) = a1;
  DWORD2(v18) = 0;
  result = data_map_init_with_ctx((uint64_t)&v15);
  *((_QWORD *)a1 + 115) = result;
  if (result)
  {
LABEL_9:
    if (*(_DWORD *)(result + 216) == -270471200)
      *(_QWORD *)(result + 472) = a2;
  }
  return result;
}

uint64_t db_get_obj(_DWORD *a1, unint64_t a2, void **a3, int a4)
{
  char *v5;
  char *v6;
  const char *v7;

  if (*a1 != 1685287992)
  {
    v5 = __si_assert_copy_extra_268();
    v6 = v5;
    if (v5)
      v7 = v5;
    else
      v7 = "";
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 314, v7);
    free(v6);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  return db2_get_obj_callback((uint64_t)a1, a2, a3, a4, 0, 0, 0);
}

uint64_t db_delete_obj(int *a1, uint64_t a2)
{
  int v4;
  NSObject *v5;
  int v6;
  char *v7;
  char *v8;
  const char *v9;
  uint8_t buf[4];
  const char *v11;
  __int16 v12;
  int v13;
  __int16 v14;
  int v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (*a1 != 1685287992)
  {
    v4 = *__error();
    v5 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v6 = *a1;
      *(_DWORD *)buf = 136315650;
      v11 = "db_delete_obj";
      v12 = 1024;
      v13 = 330;
      v14 = 1024;
      v15 = v6;
      _os_log_error_impl(&dword_1B8270000, v5, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v4;
    v7 = __si_assert_copy_extra_268();
    v8 = v7;
    if (v7)
      v9 = v7;
    else
      v9 = "";
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 330, v9);
    free(v8);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  return db2_delete_obj_with_flags((uint64_t)a1, a2, 0);
}

uint64_t db_create_id_for_field(_DWORD *a1, char *__s, unsigned int a3, int a4)
{
  unsigned int v6;
  int v8;
  int v9;
  int v10;
  char v12;
  _BOOL4 v13;
  int v14;
  char *v16;
  char *v17;
  const char *v18;
  __int16 v19;

  if (*a1 != 1685287992)
  {
    v16 = __si_assert_copy_extra_268();
    v17 = v16;
    if (v16)
      v18 = v16;
    else
      v18 = "";
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 334, v18);
    free(v17);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  v6 = a1[201];
  if ((a3 & 0x400) != 0)
    a4 = 0;
  v8 = (a3 >> 1) & 4 | (a3 >> 7) & 1 | (a3 >> 4) & 2 | (a3 >> 5) & 8 | (a3 >> 3) & 0x40;
  v9 = (a3 >> 8) & 0x20 | (a3 >> 7) & 0x180 | v8;
  v10 = (a3 >> 5) & 0x780 | (a3 >> 6) & 0x20 | v8;
  if (a4 == 14 && (a3 & 0x4000) != 0)
    LOWORD(v10) = v10 | 0xFF80;
  if ((v6 & 4) != 0)
    LOWORD(v10) = v9;
  if ((a3 & 0x10) != 0)
    v12 = 15;
  else
    v12 = a4;
  if (a4 == 11)
    LOBYTE(a4) = v12;
  v19 = a4 | (unsigned __int16)((_WORD)v10 << 8);
  v13 = ((v6 >> 3) & 1) == 0;
  v14 = strlen(__s);
  return _get_id_for_string((unint64_t)a1, 0, __s, v14, v13, &v19);
}

uint64_t db_create_id_for_value(int *a1, char *__s)
{
  int v4;
  int v5;
  int v7;
  NSObject *v8;
  int v9;
  char *v10;
  char *v11;
  const char *v12;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  int v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (*a1 != 1685287992)
  {
    v7 = *__error();
    v8 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      v9 = *a1;
      *(_DWORD *)buf = 136315650;
      v14 = "db_create_id_for_value";
      v15 = 1024;
      v16 = 336;
      v17 = 1024;
      v18 = v9;
      _os_log_error_impl(&dword_1B8270000, v8, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v7;
    v10 = __si_assert_copy_extra_268();
    v11 = v10;
    if (v10)
      v12 = v10;
    else
      v12 = "";
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 336, v12);
    free(v11);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  if ((a1[201] & 8) != 0)
    v4 = 0;
  else
    v4 = -2147483647;
  v5 = strlen(__s);
  return _get_id_for_string((unint64_t)a1, 1, __s, v5, v4, 0);
}

uint64_t db_delete_fields_with_flags(int *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  const void *v8;
  int v9;
  int v11;
  NSObject *v12;
  int v13;
  char *v14;
  char *v15;
  const char *v16;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  int v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (*a1 != 1685287992)
  {
    v11 = *__error();
    v12 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      v13 = *a1;
      *(_DWORD *)buf = 136315650;
      v18 = "db_delete_fields_with_flags";
      v19 = 1024;
      v20 = 363;
      v21 = 1024;
      v22 = v13;
      _os_log_error_impl(&dword_1B8270000, v12, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v11;
    v14 = __si_assert_copy_extra_268();
    v15 = v14;
    if (v14)
      v16 = v14;
    else
      v16 = "";
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 363, v16);
    free(v15);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  if ((a1[201] & 8) != 0)
    return 13;
  if (a2)
  {
    v4 = *(unsigned int *)(a2 + 12);
    if (v4 < 0x31)
      return 0;
    v5 = a2 + v4;
    v6 = a2 + 48;
    while (1)
    {
      v7 = v6 + *(unsigned int *)(v6 + 8);
      if (v7 > v5)
        break;
      v8 = (const void *)(v7 + 13);
      if ((*(_WORD *)(v6 + 2) & 0x200) != 0)
      {
        v9 = v6 - (_DWORD)v8;
        memmove((void *)v6, v8, v5 - (_QWORD)v8);
        LODWORD(v4) = *(_DWORD *)(a2 + 12) + v9;
        *(_DWORD *)(a2 + 12) = v4;
      }
      else
      {
        v6 = v7 + 13;
      }
      v5 = a2 + v4;
      if (v6 >= v5)
        return 0;
    }
    *(_DWORD *)(a2 + 12) = v6 - a2;
  }
  return 2;
}

uint64_t db_delete_field(int *a1, uint64_t *a2, char *a3)
{
  int v5;
  NSObject *v6;
  int v7;
  char *v8;
  char *v9;
  const char *v10;
  uint8_t buf[4];
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (*a1 != 1685287992)
  {
    v5 = *__error();
    v6 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v7 = *a1;
      *(_DWORD *)buf = 136315650;
      v12 = "db_delete_field";
      v13 = 1024;
      v14 = 365;
      v15 = 1024;
      v16 = v7;
      _os_log_error_impl(&dword_1B8270000, v6, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v5;
    v8 = __si_assert_copy_extra_268();
    v9 = v8;
    if (v8)
      v10 = v8;
    else
      v10 = "";
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 365, v10);
    free(v9);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  return _delete_field((uint64_t)a1, *a2, a3, 0);
}

uint64_t db_get_field_locked(int *a1, uint64_t a2, char *__s, unint64_t *a4, _QWORD *a5)
{
  int *v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  int v18;
  NSObject *v19;
  int v20;
  char *v21;
  char *v22;
  const char *v23;
  _BYTE buf[18];
  __int16 v25;
  int v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  if (*a1 != 1685287992)
  {
    v18 = *__error();
    v19 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      v20 = *a1;
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "db_get_field_locked";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 369;
      v25 = 1024;
      v26 = v20;
      _os_log_error_impl(&dword_1B8270000, v19, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v18;
    v21 = __si_assert_copy_extra_268();
    v22 = v21;
    if (v21)
      v23 = v21;
    else
      v23 = "";
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 369, v23);
    free(v22);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  *(_QWORD *)buf = 0;
  *(_QWORD *)&buf[8] = 0;
  v8 = (int *)internal_copy_field_ids((uint64_t)a1, __s, (uint64_t)buf, 4uLL, 1);
  if (!v8)
    return 2;
  v9 = *(unsigned int *)(a2 + 12);
  if (v9 >= 0x31 && *v8)
  {
    v10 = a2 + v9;
    v11 = a2 + 48;
    while (2)
    {
      v12 = 1;
      v13 = *v8;
      do
      {
        if (*(_DWORD *)(v11 + 4) == v13)
        {
          if (a4)
            *a4 = v11;
          if (a5)
            *a5 = v11 + 13;
          v14 = 0;
          v15 = 0;
          goto LABEL_21;
        }
        v13 = v8[v12++];
      }
      while (v13);
      v11 += *(unsigned int *)(v11 + 8) + 13;
      if (v11 < v10)
        continue;
      break;
    }
  }
  if (a4)
    *a4 = 0;
  if (a5)
    *a5 = 0;
  v14 = 2;
  v15 = 2;
LABEL_21:
  if (buf != (_BYTE *)v8)
  {
    free(v8);
    return v14;
  }
  return v15;
}

unint64_t db_get_id_for_string(int *a1, char *__s)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v6;
  int v7;
  unint64_t result;
  unsigned int *v9;
  int v10;
  NSObject *v11;
  int v12;
  char *v13;
  char *v14;
  const char *v15;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  int v19;
  __int16 v20;
  int v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (*a1 != 1685287992)
  {
    v10 = *__error();
    v11 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      v12 = *a1;
      *(_DWORD *)buf = 136315650;
      v17 = "db_get_id_for_string";
      v18 = 1024;
      v19 = 386;
      v20 = 1024;
      v21 = v12;
      _os_log_error_impl(&dword_1B8270000, v11, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v10;
    v13 = __si_assert_copy_extra_268();
    v14 = v13;
    if (v13)
      v15 = v13;
    else
      v15 = "";
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 386, v15);
    free(v14);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  v3 = *((_QWORD *)a1 + 111);
  if ((a1[201] & 0x14) == 0)
  {
    if (*__s)
    {
      v9 = (unsigned int *)hash_lookup_extended(*(_QWORD *)(v3 + 16), __s, 0, 0);
      if (v9)
        return *v9;
    }
    return 4294967294;
  }
  if (*__s)
  {
    v4 = 1;
    while (__s[v4++])
      ;
    if (v3)
    {
      v6 = (int)v4;
      v7 = *(_DWORD *)(v3 + 216);
      switch(v7)
      {
        case -270471200:
          result = _data_map_ext_get_data_id(v3, *(_DWORD *)(v3 + 220), __s, v6, 0);
          break;
        case 1684300900:
          result = _data_map64_get_data_id(v3, *(_DWORD *)(v3 + 220), __s, v6, 0);
          break;
        case 842150450:
          result = _data_map32_get_data_id(v3, *(_DWORD *)(v3 + 220), __s, v6, 0);
          break;
        default:
          return 4294967294;
      }
      if (result)
        return result;
    }
  }
  return 4294967294;
}

uint64_t db_get_field_name_for_id(int *a1, int a2)
{
  int v4;
  NSObject *v5;
  int v6;
  char *v7;
  char *v8;
  const char *v9;
  uint8_t buf[4];
  const char *v11;
  __int16 v12;
  int v13;
  __int16 v14;
  int v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (*a1 != 1685287992)
  {
    v4 = *__error();
    v5 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v6 = *a1;
      *(_DWORD *)buf = 136315650;
      v11 = "db_get_field_name_for_id";
      v12 = 1024;
      v13 = 391;
      v14 = 1024;
      v15 = v6;
      _os_log_error_impl(&dword_1B8270000, v5, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v4;
    v7 = __si_assert_copy_extra_268();
    v8 = v7;
    if (v7)
      v9 = v7;
    else
      v9 = "";
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 391, v9);
    free(v8);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  return get_string_and_length_for_id_10395((uint64_t)a1, 0, a2, 0, 0);
}

uint64_t db_get_field_id_limit(int *a1)
{
  uint64_t v1;
  int v2;
  uint64_t v4;
  int v6;
  NSObject *v7;
  int v8;
  char *v9;
  char *v10;
  const char *v11;
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  int v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (*a1 != 1685287992)
  {
    v6 = *__error();
    v7 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      v8 = *a1;
      *(_DWORD *)buf = 136315650;
      v13 = "db_get_field_id_limit";
      v14 = 1024;
      v15 = 392;
      v16 = 1024;
      v17 = v8;
      _os_log_error_impl(&dword_1B8270000, v7, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v6;
    v9 = __si_assert_copy_extra_268();
    v10 = v9;
    if (v9)
      v11 = v9;
    else
      v11 = "";
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 392, v11);
    free(v10);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  v1 = *((_QWORD *)a1 + 110);
  if ((a1[201] & 0x14) == 0)
    return *(unsigned int *)(v1 + 56);
  if (!v1)
    return 0;
  v2 = *(_DWORD *)(v1 + 216);
  switch(v2)
  {
    case -270471200:
      v4 = *(_QWORD *)(v1 + 376);
      break;
    case 1684300900:
      v4 = *(_QWORD *)(v1 + 4496);
      break;
    case 842150450:
      return (*(_DWORD *)(v1 + 364) - 1);
    default:
      return 0;
  }
  return v4 - 1;
}

uint64_t db_get_vector_for_id_locked(uint64_t a1, unint64_t a2, _DWORD *a3, _DWORD *a4)
{
  char *v5;
  char *v6;
  const char *v7;

  if (*(_DWORD *)a1 != 1685287992)
  {
    v5 = __si_assert_copy_extra_268();
    v6 = v5;
    if (v5)
      v7 = v5;
    else
      v7 = "";
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 398, v7);
    free(v6);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  return db2_get_vector_for_id_locked(*(_QWORD *)(a1 + 920), a2, a3, a4);
}

uint64_t db_get_localized_string(int *a1, uint64_t a2, char **a3, uint64_t a4, uint64_t a5, int a6)
{
  char **v11;
  char *v12;
  int v13;
  uint64_t (*v14)(uint64_t, uint64_t, uint64_t);
  char *v15;
  uint64_t v16;
  uint64_t v18;
  void *Value;
  const __CFAllocator *v20;
  __CFArray *Mutable;
  unint64_t v22;
  CFStringRef v23;
  CFStringRef v24;
  __CFArray *v25;
  unint64_t v26;
  CFStringRef v27;
  CFStringRef v28;
  const __CFArray *v29;
  const __CFArray *v30;
  uint64_t v31;
  uint64_t (*v32)(uint64_t, uint64_t, uint64_t);
  const __CFString *ValueAtIndex;
  CFIndex Length;
  CFIndex v35;
  unsigned __int16 *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  void *v41;
  void *v42;
  unint64_t v43;
  unint64_t v44;
  uint8_t *v45;
  int v47;
  NSObject *v48;
  int v49;
  char *v50;
  char *v51;
  const char *v52;
  __CFArray *v53;
  uint64_t v54;
  const __CFArray *v55;
  uint64_t v56;
  uint64_t v57;
  __CFArray *cf;
  uint64_t key;
  uint64_t v60;
  uint64_t (*v61)(uint64_t, uint64_t, uint64_t);
  void *v62;
  uint64_t *v63;
  uint64_t *v64;
  void *v65;
  uint64_t v66;
  uint64_t v67;
  _QWORD v68[12];
  uint64_t v69;
  uint64_t *v70;
  uint64_t v71;
  char v72;
  _QWORD v73[3];
  int v74;
  uint64_t v75;
  uint64_t *v76;
  uint64_t v77;
  int v78;
  uint64_t v79;
  uint64_t *v80;
  uint64_t v81;
  uint8_t *v82;
  uint64_t v83;
  uint64_t *v84;
  uint64_t v85;
  int v86;
  uint8_t buf[4];
  const char *v88;
  __int16 v89;
  int v90;
  __int16 v91;
  int v92;
  uint64_t v93;

  v93 = *MEMORY[0x1E0C80C00];
  if (*a1 != 1685287992)
  {
    v47 = *__error();
    v48 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
    {
      v49 = *a1;
      *(_DWORD *)buf = 136315650;
      v88 = "db_get_localized_string";
      v89 = 1024;
      v90 = 407;
      v91 = 1024;
      v92 = v49;
      _os_log_error_impl(&dword_1B8270000, v48, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v47;
    v50 = __si_assert_copy_extra_268();
    v51 = v50;
    if (v50)
      v52 = v50;
    else
      v52 = "";
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 407, v52);
    free(v51);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  v83 = 0;
  v84 = &v83;
  v86 = 2;
  v85 = 0x2000000000;
  if ((*(_BYTE *)(a2 + 2) & 0x80) != 0 && *(_WORD *)a2 == 11)
  {
    v11 = a3;
    if (!a3 || (v12 = *a3) == 0)
    {
      v11 = &localized_language_defaults;
      v12 = localized_language_defaults;
    }
    bzero(buf, 0x400uLL);
    v79 = 0;
    v80 = &v79;
    v81 = 0x2000000000;
    v82 = buf;
    v75 = 0;
    v76 = &v75;
    v78 = 0;
    v77 = 0x2000000000;
    v73[0] = 0;
    v73[1] = v73;
    v74 = 128;
    v73[2] = 0x2000000000;
    v69 = 0;
    v70 = &v69;
    v71 = 0x2000000000;
    v72 = 0;
    v68[0] = MEMORY[0x1E0C809B0];
    v68[1] = 0x40000000;
    v68[2] = __db2_get_localized_string_block_invoke;
    v68[3] = &unk_1E6E37510;
    v68[10] = a4;
    v68[11] = a5;
    v68[4] = &v69;
    v68[5] = &v83;
    v68[6] = &v75;
    v68[7] = v73;
    v68[8] = &v79;
    v68[9] = v12;
    db_iterate_localized_field((uint64_t)a1, a2, a6, (uint64_t)v68);
    if (!*((_BYTE *)v70 + 24))
    {
      v13 = *((_DWORD *)v76 + 6);
      if (v13)
      {
        v14 = (uint64_t (*)(uint64_t, uint64_t, uint64_t))v80[3];
        if (sBestLanguageOnceDictionaryToken != -1)
          dispatch_once(&sBestLanguageOnceDictionaryToken, &__block_literal_global_7803);
        key = 0;
        v60 = (uint64_t)v11;
        WORD1(key) = v13;
        v61 = v14;
        v15 = *v11;
        if (*v11)
        {
          v15 = 0;
          v16 = MEMORY[0x1E0C809B0];
          while (v11[(_QWORD)v15++ + 1])
            ;
        }
        else
        {
          v16 = MEMORY[0x1E0C809B0];
        }
        LOWORD(key) = (_WORD)v15;
        pthread_rwlock_rdlock(&sBestLanguageDictionaryLock);
        Value = (void *)CFDictionaryGetValue((CFDictionaryRef)sBestLanguageDictionary, &key);
        pthread_rwlock_unlock(&sBestLanguageDictionaryLock);
        if (Value)
          goto LABEL_53;
        v20 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], WORD1(key), MEMORY[0x1E0C9B378]);
        if (WORD1(key))
        {
          v22 = 0;
          do
          {
            v23 = CFStringCreateWithCString(v20, *((const char **)v61 + v22), 0x8000100u);
            if (v23)
            {
              v24 = v23;
              CFArrayAppendValue(Mutable, v23);
              CFRelease(v24);
            }
            ++v22;
          }
          while (v22 < WORD1(key));
        }
        v25 = CFArrayCreateMutable(v20, (unsigned __int16)key, MEMORY[0x1E0C9B378]);
        if ((_WORD)key)
        {
          v26 = 0;
          do
          {
            v27 = CFStringCreateWithCString(v20, *(const char **)(v60 + 8 * v26), 0x8000100u);
            if (v27)
            {
              v28 = v27;
              CFArrayAppendValue(v25, v27);
              CFRelease(v28);
            }
            ++v26;
          }
          while (v26 < (unsigned __int16)key);
        }
        v29 = CFBundleCopyLocalizationsForPreferences(Mutable, v25);
        cf = v25;
        if (v29)
        {
          v30 = v29;
          v31 = (unsigned __int16)key;
          v56 = WORD1(key);
          v32 = v61;
          v57 = v60;
          if (CFArrayGetCount(v29))
          {
            v54 = v31;
            v55 = v30;
            ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v30, 0);
            Length = CFStringGetLength(ValueAtIndex);
            v35 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
            Value = malloc_type_malloc(v35, 0xBCB3F94uLL);
            if (CFStringGetCString(ValueAtIndex, (char *)Value, v35, 0x8000100u))
            {
              v53 = Mutable;
              v36 = (unsigned __int16 *)malloc_type_malloc(0x18uLL, 0x1080040C4643742uLL);
              v36[1] = v56;
              *((_QWORD *)v36 + 2) = malloc_type_malloc(8 * v56, 0x10040436913F5uLL);
              if (v36[1])
              {
                v37 = 0;
                v38 = 8 * v36[1];
                do
                {
                  *(_QWORD *)(*((_QWORD *)v36 + 2) + v37) = strdup(*(const char **)((char *)v32 + v37));
                  v37 += 8;
                }
                while (v38 != v37);
              }
              *v36 = v54;
              *((_QWORD *)v36 + 1) = malloc_type_malloc(8 * v54, 0x10040436913F5uLL);
              if (*v36)
              {
                v39 = 0;
                v40 = 8 * *v36;
                do
                {
                  *(_QWORD *)(*((_QWORD *)v36 + 1) + v39) = strdup(*(const char **)(v57 + v39));
                  v39 += 8;
                }
                while (v40 != v39);
              }
              pthread_rwlock_wrlock(&sBestLanguageDictionaryLock);
              v41 = (void *)CFDictionaryGetValue((CFDictionaryRef)sBestLanguageDictionary, v36);
              v16 = MEMORY[0x1E0C809B0];
              if (v41)
              {
                v42 = v41;
                free(Value);
                pthread_rwlock_unlock(&sBestLanguageDictionaryLock);
                if (v36[1])
                {
                  v43 = 0;
                  do
                    free(*(void **)(*((_QWORD *)v36 + 2) + 8 * v43++));
                  while (v43 < v36[1]);
                }
                free(*((void **)v36 + 2));
                if (*v36)
                {
                  v44 = 0;
                  do
                    free(*(void **)(*((_QWORD *)v36 + 1) + 8 * v44++));
                  while (v44 < *v36);
                }
                free(*((void **)v36 + 1));
                free(v36);
                Value = v42;
              }
              else
              {
                CFDictionarySetValue((CFMutableDictionaryRef)sBestLanguageDictionary, v36, Value);
                pthread_rwlock_unlock(&sBestLanguageDictionaryLock);
              }
              Mutable = v53;
            }
            else
            {
              free(Value);
              Value = 0;
              v16 = MEMORY[0x1E0C809B0];
            }
            v30 = v55;
          }
          else
          {
            Value = 0;
            v16 = MEMORY[0x1E0C809B0];
          }
          CFRelease(v30);
        }
        else
        {
          Value = 0;
          v16 = MEMORY[0x1E0C809B0];
        }
        CFRelease(cf);
        CFRelease(Mutable);
        if (Value)
        {
LABEL_53:
          key = v16;
          v60 = 0x40000000;
          v61 = __db2_get_localized_string_block_invoke_2;
          v62 = &unk_1E6E37538;
          v65 = Value;
          v66 = a4;
          v67 = a5;
          v63 = &v69;
          v64 = &v83;
          db_iterate_localized_field((uint64_t)a1, a2, a6, (uint64_t)&key);
        }
      }
    }
    v45 = (uint8_t *)v80[3];
    if (v45 && v45 != buf)
      free(v45);
    v18 = *((unsigned int *)v84 + 6);
    _Block_object_dispose(&v69, 8);
    _Block_object_dispose(v73, 8);
    _Block_object_dispose(&v75, 8);
    _Block_object_dispose(&v79, 8);
  }
  else
  {
    v18 = 22;
  }
  _Block_object_dispose(&v83, 8);
  return v18;
}

_DWORD *db_clear_docids_setup(int *a1)
{
  _DWORD *result;
  int v3;
  NSObject *v4;
  int v5;
  char *v6;
  char *v7;
  const char *v8;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  int v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (*a1 != 1685287992)
  {
    v3 = *__error();
    v4 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = *a1;
      *(_DWORD *)buf = 136315650;
      v10 = "db_clear_docids_setup";
      v11 = 1024;
      v12 = 412;
      v13 = 1024;
      v14 = v5;
      _os_log_error_impl(&dword_1B8270000, v4, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v3;
    v6 = __si_assert_copy_extra_268();
    v7 = v6;
    if (v6)
      v8 = v6;
    else
      v8 = "";
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 412, v8);
    free(v7);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  result = malloc_type_malloc(4uLL, 0x100004052888210uLL);
  *result = 0;
  return result;
}

void db_clear_docids_cleanup(int *a1, _DWORD *a2)
{
  pthread_override_s *v4;
  char v5;
  int v6;
  NSObject *v7;
  int v8;
  char *v9;
  char *v10;
  const char *v11;
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  int v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (*a1 != 1685287992)
  {
    v6 = *__error();
    v7 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      v8 = *a1;
      *(_DWORD *)buf = 136315650;
      v13 = "db_clear_docids_cleanup";
      v14 = 1024;
      v15 = 413;
      v16 = 1024;
      v17 = v8;
      _os_log_error_impl(&dword_1B8270000, v7, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v6;
    v9 = __si_assert_copy_extra_268();
    v10 = v9;
    if (v9)
      v11 = v9;
    else
      v11 = "";
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 413, v11);
    free(v10);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  if (a2)
  {
    if (*a2)
    {
      a1[1] &= ~0x20u;
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 146));
      a1[197] = 0;
      v4 = (pthread_override_s *)*((_QWORD *)a1 + 95);
      *((_QWORD *)a1 + 96) = 0;
      *((_QWORD *)a1 + 95) = 0;
      v5 = a1[195] != 0;
      *((_BYTE *)a1 + 796) = 0;
      db_rwlock_wakeup((uint64_t)(a1 + 146), v5, 0);
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 146));
      if (v4)
        pthread_override_qos_class_end_np(v4);
    }
    free(a2);
  }
}

uint64_t db_clear_docids_matching_bundles(_DWORD *a1, _DWORD *a2, _DWORD *a3, unsigned int *a4, unsigned int a5, unsigned int (*a6)(void *, uint64_t), uint64_t a7)
{
  uint64_t v7;
  unsigned int v13;
  unint64_t v14;
  signed int v15;
  int8x16_t *v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  int v22;
  int v23;
  char v24;
  unsigned int v25;
  unsigned int *v26;
  uint64_t v27;
  unsigned int v28;
  unsigned int v29;
  BOOL v30;
  char v31;
  char *v32;
  int8x16_t *v33;
  uint64_t v34;
  uint64_t v35;
  int8x16_t *v36;
  off_t v37;
  uint64_t v38;
  uint64_t v39;
  void *v40;
  __int8 *v41;
  uint64_t v42;
  BOOL v43;
  int v44;
  unsigned int *v45;
  uint64_t v46;
  uint64_t *v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  NSObject *v51;
  __int32 v52;
  uint64_t v53;
  uint64_t *v54;
  uint64_t v55;
  int v56;
  NSObject *v57;
  _BOOL4 v58;
  void *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  unsigned int *v64;
  int v65;
  int v66;
  unsigned int v67;
  unsigned int v68;
  int8x16_t *v69;
  uint64_t v70;
  _DWORD *v71;
  uint64_t v72;
  unsigned int v73;
  BOOL v74;
  _DWORD *v75;
  pthread_override_s *v76;
  char v77;
  int v79;
  char *v80;
  char *v81;
  const char *v82;
  uint64_t v83;
  int v84;
  NSObject *v85;
  int v86;
  char *v87;
  char *v88;
  const char *v89;
  uint64_t v90;
  uint64_t v91;
  int8x16_t *v92;
  int v93;
  uint64_t v94;
  char v95;
  unsigned int *v96;
  unsigned int (*v97)(void *, uint64_t);
  uint64_t v98;
  uint64_t v99;
  _DWORD *v100;
  uint64_t v102;
  void *v103;
  void *v104;
  uint8_t buf[4];
  const char *v106;
  __int16 v107;
  int v108;
  __int16 v109;
  _BYTE v110[14];
  __int16 v111;
  void *v112;
  __int16 v113;
  int v114;
  uint64_t v115;

  v7 = (uint64_t)a1;
  v115 = *MEMORY[0x1E0C80C00];
  if (*a1 != 1685287992)
  {
    v84 = *__error();
    v85 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v85, OS_LOG_TYPE_ERROR))
    {
      v86 = *(_DWORD *)v7;
      *(_DWORD *)buf = 136315650;
      v106 = "db_clear_docids_matching_bundles";
      v107 = 1024;
      v108 = 415;
      v109 = 1024;
      *(_DWORD *)v110 = v86;
      _os_log_error_impl(&dword_1B8270000, v85, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v84;
    v87 = __si_assert_copy_extra_268();
    v88 = v87;
    if (v87)
      v89 = v87;
    else
      v89 = "";
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 415, v89);
    free(v88);
LABEL_140:
    v83 = 2989;
LABEL_142:
    *(_DWORD *)v83 = -559038737;
    abort();
  }
  v104 = 0;
  if (!a5)
  {
    v16 = 0;
    v17 = 0;
    v18 = 2;
    goto LABEL_132;
  }
  HIDWORD(v14) = qos_class_self() - 9;
  LODWORD(v14) = HIDWORD(v14);
  v13 = v14 >> 2;
  if (v13 > 6)
    v15 = 0;
  else
    v15 = dword_1B8630ED0[v13];
  pthread_mutex_lock((pthread_mutex_t *)(v7 + 584));
  if (*(_QWORD *)(v7 + 768) || *(_DWORD *)(v7 + 780) || *(_BYTE *)(v7 + 796))
    goto LABEL_10;
  if (v15 <= 5)
  {
    if (*(_QWORD *)(v7 + 16 * v15 + 648))
    {
LABEL_10:
      db_rwlock_wait(v7 + 584, v15, 2);
      goto LABEL_11;
    }
    v53 = v15 - 1;
    v54 = (uint64_t *)(v7 + 16 * v15 + 664);
    while (v53 != 4)
    {
      v55 = *v54;
      v54 += 2;
      ++v53;
      if (v55)
      {
        if (v53 <= 4)
          goto LABEL_10;
        break;
      }
    }
  }
  *(_QWORD *)(v7 + 768) = pthread_self();
LABEL_11:
  pthread_mutex_unlock((pthread_mutex_t *)(v7 + 584));
  if (a2)
    *a2 = 1;
  _db2_clear_cache_locked(v7);
  if (sdbLargeCacheArray)
    cache_remove_all((cache_t *)sdbLargeCacheArray);
  v19 = *(_QWORD *)(v7 + 856);
  if (*(int *)(v19 + 8) < 1)
  {
    v18 = 0;
    v16 = 0;
    v17 = 0;
    goto LABEL_132;
  }
  v97 = a6;
  v98 = a7;
  v102 = v7;
  v100 = a2;
  v20 = 0;
  v21 = 0;
  v22 = 0;
  v23 = 0;
  v17 = 0;
  do
  {
    v24 = 0;
    v25 = v21;
    v21 = *(_DWORD *)(v19 + 16 * v20 + 24) & 0x7FFFFFFF;
    v26 = a4;
    v27 = a5;
    do
    {
      v29 = *v26++;
      v28 = v29;
      v30 = v29 < v25 || v28 > v21;
      v31 = !v30;
      v24 |= v31;
      --v27;
    }
    while (v27);
    if ((v24 & 1) != 0)
    {
      if (v23 + 1 >= v22)
      {
        if (v22)
          v22 *= 2;
        else
          v22 = 128;
        v18 = 12;
        v17 = (char *)reallocf(v17, 12 * v22);
        if (!v17)
        {
          v16 = 0;
          a2 = v100;
          goto LABEL_87;
        }
        v19 = *(_QWORD *)(v102 + 856);
      }
      v32 = &v17[12 * v23];
      *(_DWORD *)v32 = *(_DWORD *)(v19 + 16 * v20 + 28);
      *((_DWORD *)v32 + 1) = v20;
      *((_DWORD *)v32 + 2) = 0;
      ++v23;
    }
    ++v20;
  }
  while (v20 < *(int *)(v19 + 8));
  if (v23 < 2)
  {
    a2 = v100;
    if (!v23)
    {
      v18 = 0;
      v16 = 0;
      goto LABEL_87;
    }
  }
  else
  {
    qsort(v17, v23, 0xCuLL, (int (__cdecl *)(const void *, const void *))_db_page_info_cmp);
    a2 = v100;
  }
  v33 = (int8x16_t *)malloc_type_valloc(*(unsigned int *)(v102 + 44), 0x58ED05A2uLL);
  v16 = v33;
  if (!v33)
  {
    v18 = 12;
LABEL_87:
    v7 = v102;
    goto LABEL_132;
  }
  if (v23 < 1)
  {
    v18 = 0;
    goto LABEL_87;
  }
  v34 = 0;
  v93 = 0;
  v35 = v23;
  v36 = v33;
  v7 = v102;
  while (1)
  {
    if (*a3)
    {
      v18 = 89;
      goto LABEL_131;
    }
    if ((~*(_DWORD *)(v7 + 4) & 0x60) == 0)
    {
      v18 = 22;
      goto LABEL_131;
    }
    v37 = (unint64_t)*(unsigned int *)&v17[12 * v34] << *(_DWORD *)(v7 + 12);
    v38 = fd_pread(*(_DWORD **)(v7 + 848), v36, *(unsigned int *)(v7 + 44), v37);
    if (v38 <= 0)
    {
      v18 = v38;
      if ((v38 & 0x8000000000000000) == 0)
      {
        v18 = 96;
        goto LABEL_131;
      }
      *(_DWORD *)(v7 + 4) |= 4u;
      goto LABEL_105;
    }
    if (v36->i32[0] != 846226020 && v36->i32[0] != 1684172850)
    {
      v50 = *__error();
      v51 = _SILogForLogForCategory(7);
      if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
      {
        v52 = v36->i32[0];
        *(_DWORD *)buf = 136315906;
        v106 = "db2_clear_docids_matching_bundles";
        v107 = 1024;
        v108 = 9864;
        v109 = 1024;
        *(_DWORD *)v110 = v52;
        *(_WORD *)&v110[4] = 2048;
        *(_QWORD *)&v110[6] = v37;
        _os_log_error_impl(&dword_1B8270000, v51, OS_LOG_TYPE_ERROR, "%s:%d: unexpected page signature 0x%x at offset %lld", buf, 0x22u);
      }
      *__error() = v50;
      v7 = v102;
      goto LABEL_81;
    }
    v39 = db2_page_uncompress_swap(v7, v36, &v104, 0);
    if ((_DWORD)v39)
    {
      v18 = v39;
      goto LABEL_131;
    }
    v40 = v104;
    if (v104)
      v36 = (int8x16_t *)v104;
    if (v36->i32[0] == 1684172850)
      break;
LABEL_79:
    if (v40)
    {
      free(v40);
      v104 = 0;
      v36 = v16;
    }
LABEL_81:
    if (++v34 == v35)
    {
      v18 = 0;
LABEL_105:
      if (!(_DWORD)v18 && v93)
      {
        _db2_clear_cache_locked(v7);
        if (sdbLargeCacheArray)
          cache_remove_all((cache_t *)sdbLargeCacheArray);
        *(_DWORD *)(*(_QWORD *)(v7 + 856) + 12) |= 1u;
        do
        {
          if (!*(_DWORD *)&v17[12 * (v35 - 1) + 8])
          {
            v60 = *(_QWORD *)(v7 + 856);
            v61 = *(unsigned int *)(v60 + 8);
            if ((int)v61 >= 1)
            {
              v62 = 0;
              v63 = *(unsigned int *)&v17[12 * (v35 - 1)];
              v64 = (unsigned int *)(v60 + 28);
              v65 = -1;
              v66 = -1;
              do
              {
                v68 = *v64;
                v64 += 4;
                v67 = v68;
                if (v66 == -1 || v67 > *(_DWORD *)(v60 + 16 * v66 + 28))
                  v66 = v62;
                if (v67 == (_DWORD)v63)
                  v65 = v62;
                ++v62;
              }
              while (v61 != v62);
              if (v65 != -1)
              {
                v69 = v16;
                v70 = v60 + 16 * v66;
                v73 = *(_DWORD *)(v70 + 28);
                v71 = (_DWORD *)(v70 + 28);
                v72 = v73;
                v74 = v65 == (_DWORD)v61 - 1 && v66 == -1;
                if (!v74)
                {
                  v75 = (_DWORD *)(v60 + 16 * v65);
                  *v71 = v75[7];
                  memmove(v75 + 5, v75 + 9, 16 * ((int)v61 - v65));
                  if ((_DWORD)v72 != (_DWORD)v63)
                  {
                    fd_pread(*(_DWORD **)(v7 + 848), v36, *(unsigned int *)(v7 + 44), v72 << *(_DWORD *)(v7 + 12));
                    fd_pwrite(*(_QWORD *)(v7 + 848), (uint64_t)v36, *(unsigned int *)(v7 + 44), v63 << *(_DWORD *)(v7 + 12));
                  }
                }
                --*(_DWORD *)(*(_QWORD *)(v7 + 856) + 8);
                fd_truncate(*(_QWORD *)(v7 + 848), v72 << *(_DWORD *)(v7 + 12));
                v74 = (_DWORD)v72 == (_DWORD)v63;
                v16 = v69;
                if (!v74)
                  _add_dirty_chunk(v7, v63, *(_DWORD *)(v7 + 44), 0);
              }
            }
          }
          v30 = v35-- <= 1;
        }
        while (!v30);
        v18 = 0;
      }
      goto LABEL_131;
    }
  }
  if ((v36->i8[12] & 0xF0) != 0
    || ((v41 = &v36[1].i8[4],
         v42 = v36->i32[2],
         v96 = (unsigned __int32 *)((char *)v36->u32 + v42),
         (char *)v36[1].i64 + v36[1].u32[1] + 4 <= &v36->i8[v42])
      ? (v43 = (int)v42 < 21)
      : (v43 = 1),
        v43))
  {
LABEL_78:
    v40 = v104;
    goto LABEL_79;
  }
  v92 = v16;
  v94 = 0;
  v99 = 0;
  v44 = 0;
  v95 = 0;
  v90 = *(int *)&v17[12 * v34 + 4];
  v91 = v37 >> *(_DWORD *)(v7 + 12);
  v45 = &v36[1].u32[1];
  while (1)
  {
    if (*v45 == -4)
    {
LABEL_68:
      if ((v95 & 1) != 0)
      {
        *(_DWORD *)&v17[12 * v34 + 8] = v44;
        if (v44)
        {
          v36->i32[2] = (_DWORD)v41 - (_DWORD)v36;
          if (v94)
          {
            v49 = *(_QWORD *)(v7 + 856);
            *(_DWORD *)(v49 + 12) |= 1u;
            *(_QWORD *)(v49 + 16 * v90 + 20) = v94;
          }
          page_release(v7, v36, v91, 5u, 0);
        }
        else
        {
          ++v93;
        }
      }
      v16 = v92;
      goto LABEL_78;
    }
    v103 = 0;
    v46 = _inflateDBO(v7, v45, &v103, 0, 0x10000, 0);
    if ((_DWORD)v46)
      break;
    v47 = (uint64_t *)v103;
    if (*((_DWORD *)v103 + 3) <= 0x2Fu)
    {
      v80 = __si_assert_copy_extra_2151(0, -1);
      v81 = v80;
      v82 = "";
      if (v80)
        v82 = v80;
      __message_assert("%s:%u: failed assertion '%s' %s ", "sdb2.c", 13332, "dbo->used_bytes >= sizeof(external_db_obj)", v82);
      free(v81);
      if (__valid_fs(-1))
        goto LABEL_140;
      v83 = 3072;
      goto LABEL_142;
    }
    if (!v99)
      v99 = *(_QWORD *)v103;
    if ((*((_BYTE *)v103 + 40) & 5) != 0 || !v97(v103, v98))
    {
      v94 = *v47;
      v48 = *v45 + 4;
      if ((v95 & 1) != 0)
      {
        memcpy(v41, v45, *v45 + 4);
        v47 = (uint64_t *)v103;
      }
      ++v44;
      v41 += v48;
    }
    else
    {
      v48 = *v45 + 4;
      v95 = 1;
    }
    v45 = (unsigned int *)((char *)v45 + v48);
    free(v47);
    if (v45 >= v96)
      goto LABEL_68;
  }
  v18 = v46;
  v56 = *__error();
  v57 = _SILogForLogForCategory(7);
  v58 = os_log_type_enabled(v57, OS_LOG_TYPE_ERROR);
  v59 = v103;
  if (v58)
  {
    v79 = *v45 + 4;
    *(_DWORD *)buf = 136316418;
    v106 = "db2_clear_docids_matching_bundles";
    v107 = 1024;
    v108 = 9908;
    v109 = 2080;
    *(_QWORD *)v110 = v41;
    *(_WORD *)&v110[8] = 1024;
    *(_DWORD *)&v110[10] = v79;
    v111 = 2048;
    v112 = v103;
    v113 = 1024;
    v114 = v18;
    _os_log_error_impl(&dword_1B8270000, v57, OS_LOG_TYPE_ERROR, "%s:%d: failed to inflate DBO: mark:%s size:%d mdbo:%p err:%d", buf, 0x32u);
  }
  *__error() = v56;
  v16 = v92;
  if (v59)
    free(v59);
LABEL_131:
  a2 = v100;
LABEL_132:
  free(v104);
  free(v16);
  free(v17);
  pthread_mutex_lock((pthread_mutex_t *)(v7 + 584));
  *(_DWORD *)(v7 + 788) = 0;
  v76 = *(pthread_override_s **)(v7 + 760);
  *(_QWORD *)(v7 + 768) = 0;
  *(_QWORD *)(v7 + 760) = 0;
  v77 = *(_DWORD *)(v7 + 780) != 0;
  *(_BYTE *)(v7 + 796) = 0;
  db_rwlock_wakeup(v7 + 584, v77, 0);
  pthread_mutex_unlock((pthread_mutex_t *)(v7 + 584));
  if (v76)
    pthread_override_qos_class_end_np(v76);
  if (a2)
    *a2 = 0;
  return v18;
}

uint64_t db_set_ignore_vectors(uint64_t result, char a2)
{
  int *v2;
  int v3;
  NSObject *v4;
  int v5;
  char *v6;
  char *v7;
  const char *v8;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  int v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)result != 1685287992)
  {
    v2 = (int *)result;
    v3 = *__error();
    v4 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = *v2;
      *(_DWORD *)buf = 136315650;
      v10 = "db_set_ignore_vectors";
      v11 = 1024;
      v12 = 427;
      v13 = 1024;
      v14 = v5;
      _os_log_error_impl(&dword_1B8270000, v4, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v3;
    v6 = __si_assert_copy_extra_268();
    v7 = v6;
    if (v6)
      v8 = v6;
    else
      v8 = "";
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 427, v8);
    free(v7);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  *(_BYTE *)(result + 989) = a2;
  return result;
}

uint64_t db_apply(int *a1, uint64_t (*a2)(uint64_t, _QWORD, uint64_t), uint64_t a3)
{
  int v5;
  NSObject *v6;
  int v7;
  char *v8;
  char *v9;
  const char *v10;
  uint8_t buf[4];
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (*a1 != 1685287992)
  {
    v5 = *__error();
    v6 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v7 = *a1;
      *(_DWORD *)buf = 136315650;
      v12 = "db_apply";
      v13 = 1024;
      v14 = 431;
      v15 = 1024;
      v16 = v7;
      _os_log_error_impl(&dword_1B8270000, v6, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v5;
    v8 = __si_assert_copy_extra_268();
    v9 = v8;
    if (v8)
      v10 = v8;
    else
      v10 = "";
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 431, v10);
    free(v9);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  return db2_apply((uint64_t)a1, a2, a3);
}

uint64_t db_iterate_objects_in_range(uint64_t a1, int64_t a2, int64_t a3, int a4, uint64_t a5)
{
  pthread_mutex_t *v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  unsigned int v16;
  int64_t v17;
  uint64_t v18;
  _BOOL4 v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  unint64_t v23;
  BOOL v24;
  unsigned int v25;
  uint64_t v26;
  int v27;
  int v28;
  uint64_t v29;
  unsigned int v30;
  int64_t v31;
  uint64_t v32;
  _BOOL4 v33;
  unint64_t v34;
  unsigned int v35;
  size_t v36;
  _DWORD *v37;
  uint64_t v38;
  char *v39;
  char *v40;
  int64_t v41;
  unsigned int v42;
  unint64_t v43;
  uint64_t v44;
  NSObject *v45;
  _BYTE *v46;
  char v47;
  NSObject *v48;
  uint64_t v49;
  int v50;
  int v51;
  NSObject *v52;
  uint64_t v53;
  int v54;
  uint64_t v55;
  unsigned int v56;
  uint64_t v57;
  int v58;
  int v59;
  uint64_t result;
  char *v61;
  char *v62;
  const char *v63;
  uint64_t v64;
  int v65;
  NSObject *v66;
  uint64_t v67;
  int v68;
  uint64_t v69;
  int v70;
  int v71;
  NSObject *v72;
  uint64_t v73;
  int v74;
  int v75;
  NSObject *v76;
  int v77;
  char *v78;
  char *v79;
  const char *v80;
  NSObject *log;
  int v82;
  int v83;
  int v84;
  pthread_mutex_t *v85;
  pthread_mutex_t *v86;
  char *v88;
  void *v89;
  void *value_out;
  uint8_t buf[4];
  const char *v92;
  __int16 v93;
  _BYTE v94[10];
  _BYTE v95[14];
  __int16 v96;
  int v97;
  uint64_t v98;

  v98 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)a1 != 1685287992)
  {
    v75 = *__error();
    v76 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v76, OS_LOG_TYPE_ERROR))
    {
      v77 = *(_DWORD *)a1;
      *(_DWORD *)buf = 136315650;
      v92 = "db_iterate_objects_in_range";
      v93 = 1024;
      *(_DWORD *)v94 = 432;
      *(_WORD *)&v94[4] = 1024;
      *(_DWORD *)&v94[6] = v77;
      _os_log_error_impl(&dword_1B8270000, v76, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v75;
    v78 = __si_assert_copy_extra_268();
    v79 = v78;
    if (v78)
      v80 = v78;
    else
      v80 = "";
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 432, v80);
    free(v79);
    goto LABEL_114;
  }
  v9 = (pthread_mutex_t *)(a1 + 584);
  if (db_read_lock(a1 + 584))
    sdb2_die(a1, "Multiple threads entering in sdb!", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 15321);
  v10 = *(_QWORD *)(a1 + 856);
  v11 = *(unsigned int *)(v10 + 8);
  if ((int)v11 < 1)
  {
    LODWORD(v15) = 0;
LABEL_17:
    v19 = 0;
  }
  else
  {
    v12 = 0;
    v13 = *(unsigned int *)(v10 + 8);
    do
    {
      if ((int)v13 + v12 < 0 != __OFADD__((_DWORD)v13, v12))
        v14 = v13 + v12 + 1;
      else
        v14 = v13 + v12;
      v15 = (v14 >> 1);
      v16 = *(_DWORD *)(v10 + 16 * (int)v15 + 32);
      if (a4 == v16 >> 28)
        v17 = a2 - *(_QWORD *)(v10 + 16 * ((uint64_t)v14 >> 1) + 20);
      else
        v17 = (int)(a4 - (v16 >> 28));
      v18 = v15;
      if ((v17 & 0x8000000000000000) == 0)
      {
        if (!v17)
          goto LABEL_17;
        v12 = v15 + 1;
        v18 = v13;
      }
      v13 = v18;
    }
    while (v12 < (int)v18);
    v19 = v17 > 0;
  }
  v20 = (int)v11 - 1;
  if (v20 <= (int)v15)
    v19 = 0;
  v21 = v15 + v19;
  v22 = v21;
  v23 = v10 + 16 * v21 + 20;
  if (v21)
    v24 = (int)v11 <= v21;
  else
    v24 = 1;
  if (v24
    || ((v25 = *(_DWORD *)(v10 + 16 * v21 + 32), a4 != v25 >> 28)
      ? (v26 = (int)(a4 - (v25 >> 28)))
      : (v26 = a3 - *(_QWORD *)v23),
        v26 > 0
     || ((v55 = v10 + 16 * (v22 - 1), v56 = *(_DWORD *)(v55 + 32), a4 != v56 >> 28)
       ? (v57 = (int)(a4 - (v56 >> 28)))
       : (v57 = a3 - *(_QWORD *)(v55 + 20)),
         v34 = v23,
         v57 <= 0)))
  {
    if ((int)v11 < 1)
    {
      LODWORD(v29) = 0;
LABEL_42:
      v33 = 0;
    }
    else
    {
      v27 = 0;
      do
      {
        if ((int)v11 + v27 < 0 != __OFADD__((_DWORD)v11, v27))
          v28 = v11 + v27 + 1;
        else
          v28 = v11 + v27;
        v29 = (v28 >> 1);
        v30 = *(_DWORD *)(v10 + 16 * (int)v29 + 32);
        if (a4 == v30 >> 28)
          v31 = a3 - *(_QWORD *)(v10 + 16 * ((uint64_t)v28 >> 1) + 20);
        else
          v31 = (int)(a4 - (v30 >> 28));
        v32 = v29;
        if ((v31 & 0x8000000000000000) == 0)
        {
          if (!v31)
            goto LABEL_42;
          v27 = v29 + 1;
          v32 = v11;
        }
        v11 = v32;
      }
      while (v27 < (int)v32);
      v33 = v31 > 0;
    }
    if (v20 <= (int)v29)
      v33 = 0;
    v34 = v10 + 16 * ((int)v29 + v33) + 20;
  }
  if (dword_1EF19FCA8 >= 5)
  {
    v65 = *__error();
    v66 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
    {
      v67 = *(_QWORD *)v23;
      v68 = *(_DWORD *)(v10 + 16 * v22 + 28);
      v69 = *(_QWORD *)v34;
      v70 = *(_DWORD *)(v34 + 8);
      *(_DWORD *)buf = 134219008;
      v92 = (const char *)a1;
      v93 = 2048;
      *(_QWORD *)v94 = v67;
      *(_WORD *)&v94[8] = 1024;
      *(_DWORD *)v95 = v68;
      *(_WORD *)&v95[4] = 2048;
      *(_QWORD *)&v95[6] = v69;
      v96 = 1024;
      v97 = v70;
      _os_log_impl(&dword_1B8270000, v66, OS_LOG_TYPE_DEFAULT, "%p iterate: (%llx @%x, %llx @%x)", buf, 0x2Cu);
    }
    *__error() = v65;
    v9 = (pthread_mutex_t *)(a1 + 584);
  }
  if (v23 > v34)
    goto LABEL_104;
  while (1)
  {
    value_out = 0;
    v35 = *(_DWORD *)(v23 + 8);
    v36 = *(unsigned int *)(v23 + 12);
    if (dword_1EF19FCA8 >= 5)
    {
      v86 = v9;
      v51 = *__error();
      v52 = _SILogForLogForCategory(7);
      if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
      {
        v53 = *(_QWORD *)v23;
        v54 = *(_DWORD *)(v23 + 8);
        *(_DWORD *)buf = 134218496;
        v92 = (const char *)a1;
        v93 = 2048;
        *(_QWORD *)v94 = v53;
        *(_WORD *)&v94[8] = 1024;
        *(_DWORD *)v95 = v54;
        _os_log_impl(&dword_1B8270000, v52, OS_LOG_TYPE_DEFAULT, "%p iterate: %llx %x", buf, 0x1Cu);
      }
      *__error() = v51;
      v9 = v86;
    }
    if (_page_fetch_with_fd(a1, &value_out, v35, v36, 11, buf, 0xFFFFFFFFLL, 0))
      goto LABEL_95;
    v37 = value_out;
    if (*(_DWORD *)value_out != 1684172850 || (*((_BYTE *)value_out + 12) & 0xF0) != 0)
      goto LABEL_95;
    v38 = *((int *)value_out + 2);
    if ((int)v38 >= 21)
      break;
LABEL_94:
    page_release(a1, v37, v35, 0x10u, v37[1]);
LABEL_95:
    v23 += 16;
    if (v23 > v34)
      goto LABEL_104;
  }
  v85 = v9;
  v39 = (char *)value_out + v38;
  v40 = (char *)value_out + 20;
  v88 = (char *)value_out + v38;
  while (1)
  {
    if (*(_DWORD *)v40 == -4)
    {
LABEL_93:
      v37 = value_out;
      v9 = v85;
      goto LABEL_94;
    }
    v41 = v40[4];
    if (v40[4] < 0)
    {
      v42 = v40[4];
      if (v42 <= 0xBF)
      {
        v41 = v40[5] | ((unint64_t)(v41 & 0x3F) << 8);
        goto LABEL_72;
      }
      if (v42 > 0xDF)
      {
        if (v42 > 0xEF)
        {
          if (v42 > 0xF7)
          {
            if (v42 > 0xFB)
            {
              if (v42 > 0xFD)
              {
                if (v42 == 255)
                {
                  v41 = *(_QWORD *)(v40 + 5);
                  goto LABEL_72;
                }
                v43 = ((unint64_t)v40[5] << 48) | ((unint64_t)v40[6] << 40) | ((unint64_t)v40[7] << 32) | ((unint64_t)v40[8] << 24) | ((unint64_t)v40[9] << 16) | ((unint64_t)v40[10] << 8);
                v44 = v40[11];
              }
              else
              {
                v43 = ((unint64_t)(v41 & 1) << 48) | ((unint64_t)v40[5] << 40) | ((unint64_t)v40[6] << 32) | ((unint64_t)v40[7] << 24) | ((unint64_t)v40[8] << 16) | ((unint64_t)v40[9] << 8);
                v44 = v40[10];
              }
            }
            else
            {
              v43 = ((unint64_t)(v41 & 3) << 40) | ((unint64_t)v40[5] << 32) | ((unint64_t)v40[6] << 24) | ((unint64_t)v40[7] << 16) | ((unint64_t)v40[8] << 8);
              v44 = v40[9];
            }
          }
          else
          {
            v43 = ((unint64_t)(v41 & 7) << 32) | ((unint64_t)v40[5] << 24) | ((unint64_t)v40[6] << 16) | ((unint64_t)v40[7] << 8);
            v44 = v40[8];
          }
        }
        else
        {
          v43 = ((unint64_t)(v41 & 0xF) << 24) | ((unint64_t)v40[5] << 16) | ((unint64_t)v40[6] << 8);
          v44 = v40[7];
        }
      }
      else
      {
        v43 = ((unint64_t)(v41 & 0x1F) << 16) | ((unint64_t)v40[5] << 8);
        v44 = v40[6];
      }
      v41 = v43 | v44;
    }
LABEL_72:
    if (dword_1EF19FCA8 >= 5)
    {
      v83 = *__error();
      v48 = _SILogForLogForCategory(7);
      if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
      {
        v49 = *(_QWORD *)v23;
        v50 = *(_DWORD *)(v23 + 8);
        *(_DWORD *)buf = 134218752;
        v92 = (const char *)a1;
        v93 = 2048;
        *(_QWORD *)v94 = v41;
        *(_WORD *)&v94[8] = 2048;
        *(_QWORD *)v95 = v49;
        *(_WORD *)&v95[8] = 1024;
        *(_DWORD *)&v95[10] = v50;
        _os_log_impl(&dword_1B8270000, v48, OS_LOG_TYPE_DEFAULT, "%p iterate: %llx (%llx @%x)", buf, 0x26u);
      }
      *__error() = v83;
      v39 = v88;
    }
    if (v41 >= a3)
      break;
    if (v41 >= a2)
    {
      v89 = 0;
      _inflateDBO(a1, (unsigned int *)v40, &v89, 0, 0, 0);
      v46 = v89;
      if (*((_DWORD *)v89 + 3) > 0x2Fu)
      {
        if (dword_1EF19FCA8 >= 5)
        {
          v84 = *__error();
          log = _SILogForLogForCategory(7);
          if (os_log_type_enabled(log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 134218496;
            v92 = (const char *)a1;
            v93 = 2048;
            *(_QWORD *)v94 = v41;
            *(_WORD *)&v94[8] = 2048;
            *(_QWORD *)v95 = a2;
            _os_log_impl(&dword_1B8270000, log, OS_LOG_TYPE_DEFAULT, "%p iterate: %llx >= %llx", buf, 0x20u);
          }
          *__error() = v84;
        }
        if ((v46[40] & 5) != 0)
        {
          free(v46);
        }
        else
        {
          v47 = (*(uint64_t (**)(uint64_t, _BYTE *))(a5 + 16))(a5, v46);
          free(v46);
          if ((v47 & 1) == 0)
            goto LABEL_103;
        }
        goto LABEL_84;
      }
      v61 = __si_assert_copy_extra_2151(0, -1);
      v62 = v61;
      v63 = "";
      if (v61)
        v63 = v61;
      __message_assert("%s:%u: failed assertion '%s' %s ", "sdb2.c", 13332, "dbo->used_bytes >= sizeof(external_db_obj)", v63);
      free(v62);
      if (!__valid_fs(-1))
      {
        v64 = 3072;
LABEL_119:
        *(_DWORD *)v64 = -559038737;
        abort();
      }
LABEL_114:
      v64 = 2989;
      goto LABEL_119;
    }
    if (dword_1EF19FCA8 >= 5)
    {
      v82 = *__error();
      v45 = _SILogForLogForCategory(7);
      if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134218496;
        v92 = (const char *)a1;
        v93 = 2048;
        *(_QWORD *)v94 = v41;
        *(_WORD *)&v94[8] = 2048;
        *(_QWORD *)v95 = a2;
        _os_log_impl(&dword_1B8270000, v45, OS_LOG_TYPE_DEFAULT, "%p iterate: %llx < %llx", buf, 0x20u);
      }
      *__error() = v82;
LABEL_84:
      v39 = v88;
    }
    v40 += (*(_DWORD *)v40 + 4);
    if (v40 >= v39)
      goto LABEL_93;
  }
  if (dword_1EF19FCA8 >= 5)
  {
    v71 = *__error();
    v72 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
    {
      v73 = *(_QWORD *)v23;
      v74 = *(_DWORD *)(v23 + 8);
      *(_DWORD *)buf = 134218752;
      v92 = (const char *)a1;
      v93 = 2048;
      *(_QWORD *)v94 = v41;
      *(_WORD *)&v94[8] = 2048;
      *(_QWORD *)v95 = v73;
      *(_WORD *)&v95[8] = 1024;
      *(_DWORD *)&v95[10] = v74;
      _os_log_impl(&dword_1B8270000, v72, OS_LOG_TYPE_DEFAULT, "%p iterate: bail %llx (%llx @%x)", buf, 0x26u);
    }
    *__error() = v71;
  }
LABEL_103:
  page_release(a1, value_out, v35, 0x10u, *((_DWORD *)value_out + 1));
  v9 = v85;
LABEL_104:
  v58 = pthread_mutex_lock(v9);
  v59 = *(_DWORD *)(a1 + 780) - 1;
  *(_DWORD *)(a1 + 780) = v59;
  if (!v59)
    db_rwlock_wakeup((uint64_t)v9, 0, 0);
  result = pthread_mutex_unlock(v9);
  if (v58)
    sdb2_die(a1, "Multiple threads in sdb! (leaving)", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 15388);
  return result;
}

uint64_t db_set_dirty_chunks(uint64_t result, uint64_t a2, int a3, int a4)
{
  uint64_t v4;
  uint64_t v6;
  pthread_key_t v7;
  void *v8;
  unsigned int v9;
  unint64_t v10;
  signed int v11;
  int v12;
  unint64_t v13;
  unsigned int *v14;
  int v15;
  pthread_override_s *v16;
  char v17;
  _DWORD *v18;
  _DWORD *v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  char *v25;
  char *v26;
  const char *v27;
  int v28;
  NSObject *v29;
  uint8_t buf[4];
  const char *v31;
  __int16 v32;
  int v33;
  __int16 v34;
  int v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)result != 1685287992)
  {
    v25 = __si_assert_copy_extra_268();
    v26 = v25;
    if (v25)
      v27 = v25;
    else
      v27 = "";
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 435, v27);
    free(v26);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  LODWORD(v4) = a3;
  v6 = result;
  if (!*(_QWORD *)(result + 864))
  {
    *(_QWORD *)(result + 864) = a2;
    *(_DWORD *)(result + 872) = a3;
    *(_DWORD *)(result + 876) = a4;
    return result;
  }
  v7 = __THREAD_SLOT_KEY;
  if (!__THREAD_SLOT_KEY)
  {
    makeThreadId();
    v7 = __THREAD_SLOT_KEY;
  }
  v8 = pthread_getspecific(v7);
  HIDWORD(v10) = qos_class_self() - 9;
  LODWORD(v10) = HIDWORD(v10);
  v9 = v10 >> 2;
  if (v9 > 6)
    v11 = 0;
  else
    v11 = dword_1B8630ED0[v9];
  v12 = pthread_mutex_lock((pthread_mutex_t *)(v6 + 584));
  if (*(_QWORD *)(v6 + 768) || *(_DWORD *)(v6 + 780) || *(_BYTE *)(v6 + 796))
    goto LABEL_12;
  if (v11 <= 5)
  {
    if (*(_QWORD *)(v6 + 16 * v11 + 648))
    {
LABEL_12:
      db_rwlock_wait(v6 + 584, v11, 2);
      goto LABEL_13;
    }
    v22 = v11 - 1;
    v23 = (uint64_t *)(v6 + 16 * v11 + 664);
    while (v22 != 4)
    {
      v24 = *v23;
      v23 += 2;
      ++v22;
      if (v24)
      {
        if (v22 <= 4)
          goto LABEL_12;
        break;
      }
    }
  }
  *(_QWORD *)(v6 + 768) = pthread_self();
LABEL_13:
  pthread_mutex_unlock((pthread_mutex_t *)(v6 + 584));
  if (v12)
  {
    v28 = *__error();
    v29 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315650;
      v31 = "db2_set_dirty_chunks";
      v32 = 1024;
      v33 = 15039;
      v34 = 1024;
      v35 = v12;
      _os_log_error_impl(&dword_1B8270000, v29, OS_LOG_TYPE_ERROR, "%s:%d: Lock failed with error %d", buf, 0x18u);
    }
    *__error() = v28;
    sdb2_die(v6, "Multiple threads entering in sdb!", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 15039);
  }
  if (v8)
  {
    v13 = CIOnThreadCleanUpPush((uint64_t)v8 - 1, (uint64_t)db_write_unlock, v6 + 584);
    if (!(_DWORD)v4)
      goto LABEL_20;
LABEL_18:
    v4 = v4;
    v14 = (unsigned int *)(a2 + 4);
    do
    {
      _add_dirty_chunk(v6, *(v14 - 1), *v14, 0);
      v14 += 2;
      --v4;
    }
    while (v4);
    goto LABEL_20;
  }
  v13 = -1;
  if ((_DWORD)v4)
    goto LABEL_18;
LABEL_20:
  v15 = pthread_mutex_lock((pthread_mutex_t *)(v6 + 584));
  *(_DWORD *)(v6 + 788) = 0;
  v16 = *(pthread_override_s **)(v6 + 760);
  *(_QWORD *)(v6 + 768) = 0;
  *(_QWORD *)(v6 + 760) = 0;
  v17 = *(_DWORD *)(v6 + 780) != 0;
  *(_BYTE *)(v6 + 796) = 0;
  db_rwlock_wakeup(v6 + 584, v17, 0);
  result = pthread_mutex_unlock((pthread_mutex_t *)(v6 + 584));
  if (v16)
    result = pthread_override_qos_class_end_np(v16);
  if (v15)
    sdb2_die(v6, "Multiple threads in sdb! (leaving)", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 15043);
  if (v8)
  {
    result = CIOnThreadCleanUpClearItem((uint64_t)v8 - 1, v13);
    v18 = &threadData[18 * ((uint64_t)v8 - 1)];
    v21 = v18[14];
    v19 = v18 + 14;
    v20 = v21;
    if (v13 + 1 == v21)
      *v19 = v20 - 1;
  }
  return result;
}

void db_garbage_collect_strings_commit(uint64_t a1, _BYTE *a2, char a3)
{
  if (a2 && (a3 & 1) == 0)
  {
    if (a1 && (*(_BYTE *)(a1 + 804) & 0x14) != 0)
    {
      data_maps_garbage_compact_collect_commit(a1 + 880, (uint64_t)a2, 0);
      if (a2[16832])
        (*(void (**)(void))(*(_QWORD *)(a1 + 968) + 16))();
    }
    free(a2);
  }
}

BOOL db_uses_stringmap(uint64_t a1)
{
  char *v2;
  char *v3;
  const char *v4;

  if (*(_DWORD *)a1 != 1685287992)
  {
    v2 = __si_assert_copy_extra_268();
    v3 = v2;
    if (v2)
      v4 = v2;
    else
      v4 = "";
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 470, v4);
    free(v3);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  return (*(_BYTE *)(a1 + 804) & 0x14) != 0;
}

void *db_open_query_with_expr(_DWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  void *v5;
  void *v6;
  _BOOL4 v7;
  int v8;
  unint64_t v9;
  uint64_t v10;
  size_t v11;
  uint64_t v12;
  off_t v13;
  _DWORD *v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  _DWORD *v18;
  _DWORD *v19;
  int v20;
  int v21;
  char *v23;
  char *v24;
  const char *v25;
  int v26;
  int v27;
  NSObject *v28;
  uint64_t v29;
  _DWORD *v30;
  uint8_t buf[4];
  const char *v32;
  __int16 v33;
  int v34;
  __int16 v35;
  int v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  if (*a1 != 1685287992)
  {
    v23 = __si_assert_copy_extra_268();
    v24 = v23;
    if (v23)
      v25 = v23;
    else
      v25 = "";
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 569, v25);
    free(v24);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  if (*MEMORY[0x1E0C85AD8] <= 0x7FFuLL)
    ++sTotal_9923;
  v4 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 0x800uLL, 1uLL, 0x31F9A007uLL);
  v5 = v4;
  if (v4)
  {
    *(_DWORD *)v4 = 3506;
    v4[250] = a2;
    v4[1] = 0;
    v4[2] = a1;
    *((_DWORD *)v4 + 506) = 20;
    v6 = malloc_type_malloc(a1[11], 0x577EB802uLL);
    *((_QWORD *)v5 + 255) = v6;
    if (v6)
    {
      v29 = 0;
      v30 = 0;
      v7 = CICleanUpThreadLocGet(&v29);
      v8 = _db_write_lock((uint64_t)(a1 + 146));
      if (v8)
      {
        v26 = v8;
        v27 = *__error();
        v28 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          v32 = "db2_open_query_with_expr";
          v33 = 1024;
          v34 = 43;
          v35 = 1024;
          v36 = v26;
          _os_log_error_impl(&dword_1B8270000, v28, OS_LOG_TYPE_ERROR, "%s:%d: Lock failed with error %d", buf, 0x18u);
        }
        *__error() = v27;
        sdb2_die((uint64_t)a1, "Multiple threads entering in sdb!", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2_query.c", 43);
      }
      if (v7)
        v9 = CIOnThreadCleanUpPush(v29, (uint64_t)db_write_unlock, (uint64_t)(a1 + 146));
      else
        v9 = -1;
      _db2_flush_all_cache((uint64_t)a1, 0);
      v10 = a1[10];
      v11 = a1[11];
      v12 = a1[9];
      v13 = v10 + v12;
      *((_QWORD *)v5 + 252) = v10 + v12;
      if ((_DWORD)v10 + (_DWORD)v12 == a1[12])
      {
        v13 += 0x4000;
        *((_QWORD *)v5 + 252) = v13;
      }
      v14 = (_DWORD *)*((_QWORD *)v5 + 255);
      while (fd_pread(*(_DWORD **)(*((_QWORD *)v5 + 2) + 848), v14, v11, v13) == v11
           && !db2_page_uncompress_swap((uint64_t)a1, *((int8x16_t **)v5 + 255), &v30, 0))
      {
        v14 = (_DWORD *)*((_QWORD *)v5 + 255);
        if (v30)
        {
          free(*((void **)v5 + 255));
          v14 = v30;
          *((_QWORD *)v5 + 255) = v30;
        }
        if (*v14 != 1684172850)
          break;
        v15 = v14[3];
        if ((v15 & 0xF0) == 0)
          goto LABEL_26;
        if ((v15 & 4) != 0)
          v16 = 4;
        else
          v16 = 1;
        v11 = (int)v14[v16];
        v13 = *((_QWORD *)v5 + 252) + v11;
        *((_QWORD *)v5 + 252) = v13;
      }
      *((_DWORD *)v5 + 502) = -1;
LABEL_26:
      if (db_write_unlock((uint64_t)(a1 + 146)))
        sdb2_die((uint64_t)a1, "Multiple threads in sdb! (leaving)", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2_query.c", 96);
      if (v7)
      {
        v17 = v29;
        CIOnThreadCleanUpClearItem(v29, v9);
        v18 = &threadData[18 * v17];
        v21 = v18[14];
        v19 = v18 + 14;
        v20 = v21;
        if (v9 + 1 == v21)
          *v19 = v20 - 1;
      }
      *((_QWORD *)v5 + 254) = 0;
    }
    else
    {
      free(v5);
      return 0;
    }
  }
  else
  {
    _log_fault_for_malloc_failure();
  }
  return v5;
}

uint64_t db_store_dirty_chunk_info(uint64_t a1, uint64_t a2, char a3, int a4)
{
  uint64_t v4;
  int v8;
  int v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int *v15;
  int v16;
  NSObject *v17;
  int v18;
  NSObject *v19;
  int v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  char *v28;
  char *v29;
  const char *v30;
  uint64_t v31;
  char *v32;
  char *v33;
  const char *v34;
  char *v35;
  const char *v36;
  uint64_t v37;
  int v38;
  NSObject *v39;
  int v40;
  char *v41;
  char *v42;
  const char *v43;
  uint8_t buf[32];
  __int128 v45;
  __int128 v46;
  _BYTE __src[32];
  uint64_t v48;

  v4 = a1;
  v48 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return v4;
  if (unlinkat(a2, "store.updates", 0) == -1)
  {
    v8 = *__error();
    v9 = *__error();
    v10 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "db_store_dirty_chunk_info";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 758;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v8;
      _os_log_error_impl(&dword_1B8270000, v10, OS_LOG_TYPE_ERROR, "%s:%d: Error unliking store.updates: %d", buf, 0x18u);
    }
    *__error() = v9;
  }
  v11 = si_openat_protected(a2, "store.updates", 536872450, 3);
  if ((_DWORD)v11 != -1)
  {
    v12 = v11;
    v45 = 0u;
    v46 = 0u;
    memset(buf, 0, sizeof(buf));
    if ((store_stream_init_fd((uint64_t)buf, v11, 0, 0, 1) & 1) == 0)
    {
      v4 = *(unsigned int *)&buf[16];
      if (!*(_DWORD *)&buf[16])
        goto LABEL_16;
      goto LABEL_15;
    }
    if ((a3 & 1) != 0)
    {
      v13 = 0;
      v14 = 0;
      v15 = 0;
      goto LABEL_31;
    }
    if (*(_DWORD *)v4 != 1685287992)
    {
      v38 = *__error();
      v39 = _SILogForLogForCategory(4);
      if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
      {
        v40 = *(_DWORD *)v4;
        *(_DWORD *)__src = 136315650;
        *(_QWORD *)&__src[4] = "db_get_dirty_chunks";
        *(_WORD *)&__src[12] = 1024;
        *(_DWORD *)&__src[14] = 434;
        *(_WORD *)&__src[18] = 1024;
        *(_DWORD *)&__src[20] = v40;
        _os_log_error_impl(&dword_1B8270000, v39, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", __src, 0x18u);
      }
      *__error() = v38;
      v41 = __si_assert_copy_extra_268();
      v42 = v41;
      if (v41)
        v43 = v41;
      else
        v43 = "";
      __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 434, v43);
      free(v42);
LABEL_48:
      v31 = 2989;
LABEL_50:
      *(_DWORD *)v31 = -559038737;
      abort();
    }
    v21 = *(_DWORD *)(v4 + 804);
    if ((v21 & 0x14) == 0
      && (*(_QWORD *)(*(_QWORD *)(v4 + 880) + 8)
       || *(_QWORD *)(*(_QWORD *)(v4 + 888) + 8)
       || *(_QWORD *)(*(_QWORD *)(v4 + 896) + 8)
       || *(_QWORD *)(*(_QWORD *)(v4 + 904) + 8)
       || *(_QWORD *)(*(_QWORD *)(v4 + 912) + 8)))
    {
      v32 = __si_assert_copy_extra_2151(0, -1);
      v33 = v32;
      v34 = "";
      if (v32)
        v34 = v32;
      __message_assert("%s:%u: failed assertion '%s' %s ", "sdb2.c", 15022, "dst->string_table[i]->dirty_page == 0", v34);
    }
    else
    {
      if ((*(_BYTE *)(*(_QWORD *)(v4 + 856) + 12) & 1) == 0)
      {
        v15 = *(unsigned int **)(v4 + 864);
        v13 = *(_DWORD *)(v4 + 872);
        v14 = *(_DWORD *)(v4 + 876);
        if (a4)
        {
          *(_DWORD *)(v4 + 4) |= 8u;
          *(_DWORD *)(v4 + 804) = v21 | 8;
        }
LABEL_31:
        v22 = *((_QWORD *)&v45 + 1);
        if ((_QWORD)v45 - *((_QWORD *)&v45 + 1) < 6uLL)
        {
          *(_QWORD *)&__src[9] = 0;
          *(_QWORD *)&__src[1] = 0;
          *(_QWORD *)&__src[24] = 0;
          *(_QWORD *)&__src[17] = 0;
          __src[0] = 1;
          store_stream_write_bytes((uint64_t)buf, __src, 1uLL);
        }
        else
        {
          *(_BYTE *)(v46 + *((_QWORD *)&v45 + 1)) = 1;
          *((_QWORD *)&v45 + 1) = v22 + 1;
        }
        store_stream_write_vint32(buf, v13);
        store_stream_write_vint32(buf, v14);
        if (v13)
        {
          v23 = 0;
          v24 = 0;
          do
          {
            if (v23 * 4)
            {
              v25 = v15[v23];
              if (v25 <= v15[v23 - 2])
              {
                v28 = __si_assert_copy_extra_268();
                v29 = v28;
                v30 = "";
                if (v28)
                  v30 = v28;
                __message_assert("%s:%u: failed assertion '%s' %s ", "core-db.c", 795, "dirty_chunks[i].pgnum > dirty_chunks[i-1].pgnum", v30);
                free(v29);
                if (__valid_fs(-1))
                  goto LABEL_48;
                v31 = 3072;
                goto LABEL_50;
              }
              v26 = v25 - v24;
            }
            else
            {
              v26 = *v15;
            }
            store_stream_write_vint32(buf, v26);
            if (v15[v23 + 1] == 0x10000)
              v27 = 0;
            else
              v27 = v15[v23 + 1];
            store_stream_write_vint32(buf, v27);
            v24 = v15[v23];
            v23 += 2;
          }
          while (2 * v13 != v23);
        }
        store_stream_flush((unsigned int *)buf, 1);
        v4 = *(unsigned int *)&buf[16];
        store_stream_destroy((uint64_t)buf);
        if (!(_DWORD)v4)
        {
LABEL_16:
          close(v12);
          if (!(_DWORD)v4)
            return v4;
          goto LABEL_17;
        }
LABEL_15:
        _fd_ftruncate(v12, 0);
        goto LABEL_16;
      }
      v35 = __si_assert_copy_extra_2151(0, -1);
      v33 = v35;
      v36 = "";
      if (v35)
        v36 = v35;
      __message_assert("%s:%u: failed assertion '%s' %s ", "sdb2.c", 15024, "(dst->dbm->flags& 0x0001) == 0", v36);
    }
    free(v33);
    if (__valid_fs(-1))
      v37 = 2989;
    else
      v37 = 3072;
    *(_DWORD *)v37 = -559038737;
    abort();
  }
  v4 = *__error();
  v16 = *__error();
  v17 = _SILogForLogForCategory(4);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136315650;
    *(_QWORD *)&buf[4] = "db_store_dirty_chunk_info";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 765;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = v4;
    _os_log_error_impl(&dword_1B8270000, v17, OS_LOG_TYPE_ERROR, "%s:%d: Error opening store.updates: %d", buf, 0x18u);
  }
  *__error() = v16;
  if ((_DWORD)v4)
  {
LABEL_17:
    v18 = *__error();
    v19 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "db_store_dirty_chunk_info";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 816;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v4;
      _os_log_error_impl(&dword_1B8270000, v19, OS_LOG_TYPE_ERROR, "%s:%d: Error storing dirty sdb pages: %d", buf, 0x18u);
    }
    *__error() = v18;
  }
  return v4;
}

uint64_t db_restore_dirty_chunk_info(int a1, uint64_t a2, uint64_t a3, int a4, int a5, int a6, int a7, int a8)
{
  uint64_t v9;
  unsigned int vint32;
  uint64_t v11;
  int v12;
  NSObject *v13;
  void *v14;
  uint64_t v15;
  unint64_t v16;
  int v17;
  int v18;
  int v19;
  int v20;
  _DWORD *v21;
  int v22;
  NSObject *v23;
  os_log_type_t v24;
  int v26;
  int v27;
  char *v28;
  char *v29;
  const char *v30;
  uint64_t v31;
  char *v32;
  const char *v33;
  unsigned __int16 v34;
  uint8_t v35[4];
  const char *v36;
  __int16 v37;
  int v38;
  __int16 v39;
  int v40;
  __int16 v41;
  int v42;
  __int16 v43;
  int v44;
  uint8_t buf[16];
  __int128 v46;
  __int128 v47;
  __int128 v48;
  uint64_t v49;

  v49 = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)a2)
  {
    v28 = __si_assert_copy_extra_268();
    v29 = v28;
    v30 = "";
    if (v28)
      v30 = v28;
    __message_assert("%s:%u: failed assertion '%s' %s ", "core-db.c", 827, "!info->dirty_chunks", v30);
    goto LABEL_38;
  }
  v9 = x_openat(a1, "store.updates", 256, a4, a5, a6, a7, a8, v34);
  if ((_DWORD)v9 == -1)
  {
    v11 = *__error();
    goto LABEL_29;
  }
  v47 = 0u;
  v48 = 0u;
  *(_OWORD *)buf = 0u;
  v46 = 0u;
  if ((store_stream_init_fd((uint64_t)buf, v9, 0, 0, 0) & 1) == 0)
  {
    v11 = v46;
    goto LABEL_29;
  }
  if (store_stream_read_vint32((uint64_t)buf) != 1)
  {
    v11 = v46;
    goto LABEL_28;
  }
  *(_DWORD *)(a2 + 8) = store_stream_read_vint32((uint64_t)buf);
  vint32 = store_stream_read_vint32((uint64_t)buf);
  *(_DWORD *)(a2 + 12) = vint32;
  if (*(_DWORD *)(a2 + 8) <= vint32)
  {
    v14 = malloc_type_malloc(8 * vint32, 0x100004000313F17uLL);
    *(_QWORD *)a2 = v14;
    if (v14)
    {
      if (*(_DWORD *)(a2 + 8))
      {
        v15 = 0;
        v16 = 0;
        v17 = 0;
        while (1)
        {
          v18 = store_stream_read_vint32((uint64_t)buf);
          v19 = store_stream_read_vint32((uint64_t)buf);
          v11 = v46;
          if ((_DWORD)v46)
            break;
          v17 += v18;
          if (v19)
            v20 = v19;
          else
            v20 = 0x10000;
          v21 = (_DWORD *)(*(_QWORD *)a2 + v15);
          *v21 = v17;
          v21[1] = v20;
          ++v16;
          v15 += 8;
          if (v16 >= *(unsigned int *)(a2 + 8))
          {
            v11 = 0;
            goto LABEL_28;
          }
        }
        v14 = *(void **)a2;
      }
      else
      {
        v11 = v46;
        if (!(_DWORD)v46)
          goto LABEL_28;
      }
      free(v14);
      *(_QWORD *)a2 = 0;
LABEL_28:
      store_stream_destroy((uint64_t)buf);
      goto LABEL_29;
    }
    v32 = __si_assert_copy_extra_268();
    v29 = v32;
    v33 = "";
    if (v32)
      v33 = v32;
    __message_assert("%s:%u: failed assertion '%s' %s ", "core-db.c", 851, "info->dirty_chunks", v33);
LABEL_38:
    free(v29);
    if (__valid_fs(-1))
      v31 = 2989;
    else
      v31 = 3072;
    *(_DWORD *)v31 = -559038737;
    abort();
  }
  if ((_DWORD)v46)
    v11 = v46;
  else
    v11 = 0xFFFFFFFFLL;
  v12 = *__error();
  v13 = _SILogForLogForCategory(4);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    v26 = *(_DWORD *)(a2 + 8);
    v27 = *(_DWORD *)(a2 + 12);
    *(_DWORD *)v35 = 136316162;
    v36 = "db_restore_dirty_chunk_info";
    v37 = 1024;
    v38 = 844;
    v39 = 1024;
    v40 = v11;
    v41 = 1024;
    v42 = v26;
    v43 = 1024;
    v44 = v27;
    _os_log_error_impl(&dword_1B8270000, v13, OS_LOG_TYPE_ERROR, "%s:%d: err:%d num_chunks:%d > max_chunks:%d", v35, 0x24u);
  }
  *__error() = v12;
LABEL_29:
  close(v9);
  if ((_DWORD)v11)
  {
    v22 = *__error();
    v23 = _SILogForLogForCategory(4);
    v24 = dword_1EF19FC9C < 3;
    if (os_log_type_enabled(v23, (os_log_type_t)(dword_1EF19FC9C < 3)))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = v11;
      _os_log_impl(&dword_1B8270000, v23, v24, "*warn* Restore error: %d, recovering from shadow", buf, 8u);
    }
    *__error() = v22;
    if (*(_QWORD *)a2)
    {
      free(*(void **)a2);
      *(_QWORD *)a2 = 0;
    }
  }
  return v11;
}

uint64_t _fd_protection_class(int a1, int a2)
{
  if (a2 == -1)
    return 0;
  else
    return fcntl(a2, 63);
}

uint64_t _assert_match_address(uint64_t a1, uint64_t a2)
{
  _BOOL4 v2;

  v2 = a2 == 3072;
  if (a2 == 2989)
    v2 = 1;
  return a2 == 2816 || v2;
}

BOOL _mappingMatchAddress(unint64_t *a1, unint64_t a2)
{
  unint64_t v2;
  uint64_t v4;
  unint64_t v5;
  _QWORD *v6;
  BOOL v7;
  unint64_t v8;
  unint64_t v10;
  uint64_t v11;
  int v12;
  char *v14;
  int v15;
  int v16;
  NSObject *v17;
  BOOL v18;
  _BOOL4 v19;
  const char *v20;
  NSObject *v21;
  os_log_type_t v22;
  uint32_t v23;
  stat v24;
  uint8_t buf[4];
  const char *v26;
  __int16 v27;
  char *v28;
  __int16 v29;
  unint64_t v30;
  __int16 v31;
  unint64_t v32;
  __int16 v33;
  unint64_t v34;
  __int16 v35;
  int v36;
  __int16 v37;
  off_t st_size;
  __int16 v39;
  dev_t st_dev;
  __int16 v41;
  __darwin_ino64_t st_ino;
  _OWORD v43[16];
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  v2 = *a1;
  if (*a1)
  {
    v4 = 0;
    v5 = a1[1];
    v6 = (_QWORD *)(v5 + 8);
    v7 = 1;
    while (1)
    {
      v8 = *(v6 - 1);
      if (v8 + 1 >= 2 && v8 <= a2)
      {
        v10 = v8 + *v6;
        if (v10 > a2)
          break;
      }
      v7 = ++v4 < v2;
      v6 += 3;
      if (v2 == v4)
        return 0;
    }
    v11 = *(_QWORD *)(v5 + 24 * v4 + 16);
    memset(&v24, 0, sizeof(v24));
    memset(v43, 0, sizeof(v43));
    if (v11)
      v12 = *(_DWORD *)(v11 + 44);
    else
      v12 = -1;
    v14 = fd_name(v11, (char *)v43, 0x100uLL);
    v15 = fstatat(v12, v14, &v24, 32);
    v16 = *__error();
    v17 = _SILogForLogForCategory(0);
    v18 = gSILogLevels[0] < 3;
    v19 = os_log_type_enabled(v17, (os_log_type_t)(gSILogLevels[0] < 3));
    if (v15)
    {
      if (v19)
      {
        *(_DWORD *)buf = 136316162;
        v26 = "mapping";
        v27 = 2080;
        v28 = v14;
        v29 = 2048;
        v30 = a2;
        v31 = 2048;
        v32 = v8;
        v33 = 2048;
        v34 = v10;
        v20 = "*warn* Got exception on %s %s addr:%p start:%p map end:%p";
        v21 = v17;
        v22 = v18;
        v23 = 52;
LABEL_21:
        _os_log_impl(&dword_1B8270000, v21, v22, v20, buf, v23);
      }
    }
    else if (v19)
    {
      *(_DWORD *)buf = 136317186;
      v26 = "mapping";
      v27 = 2080;
      v28 = v14;
      v29 = 2048;
      v30 = a2;
      v31 = 2048;
      v32 = v8;
      v33 = 2048;
      v34 = v10;
      v35 = 1024;
      v36 = 0;
      v37 = 2048;
      st_size = v24.st_size;
      v39 = 1024;
      st_dev = v24.st_dev;
      v41 = 2048;
      st_ino = v24.st_ino;
      v20 = "*warn* Got exception on %s %s addr:%p start:%p map end:%p sres:%d file_size:%lld dev:%d ino:%lld";
      v21 = v17;
      v22 = v18;
      v23 = 84;
      goto LABEL_21;
    }
    *__error() = v16;
    return v7;
  }
  return 0;
}

char *copyVolumeInfoStr(int a1)
{
  int v2;
  NSObject *v3;
  char *result;
  int v5;
  char *v6;
  uint8_t buf[4];
  const char *v8;
  __int16 v9;
  int v10;
  __int16 v11;
  int v12;
  statfs v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v6 = 0;
  if (a1 == -1)
    return strdup("");
  bzero(&v13, 0x878uLL);
  if (fstatfs(a1, &v13))
  {
    v2 = *__error();
    v3 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      v5 = *__error();
      *(_DWORD *)buf = 136315650;
      v8 = "copyVolumeInfoStr";
      v9 = 1024;
      v10 = 45;
      v11 = 1024;
      v12 = v5;
      _os_log_error_impl(&dword_1B8270000, v3, OS_LOG_TYPE_ERROR, "%s:%d: fstatfs err:%d", buf, 0x18u);
    }
    *__error() = v2;
    return strdup("");
  }
  asprintf(&v6, "(%s, t: 0x%x, st: 0x%x, f: 0x%x)", v13.f_fstypename, v13.f_type, v13.f_fssubtype, v13.f_flags);
  result = v6;
  if (!v6)
    return strdup("");
  return result;
}

uint64_t check_crash_state(int a1, int a2, char a3, uint64_t *a4, int a5)
{
  time_t v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  char *v19;
  const char *v20;
  int v21;
  const char *v22;
  char *v23;
  int v24;
  int v25;
  int v26;
  ssize_t v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  uint64_t v34;
  int v35;
  int v36;
  char *v37;
  char *v38;
  ssize_t v39;
  uint64_t i;
  size_t v41;
  size_t v42;
  void *v43;
  void *v44;
  void *v45;
  uint64_t v46;
  char *v47;
  size_t v48;
  size_t v49;
  void *v50;
  void *v51;
  void *v52;
  int v53;
  NSObject *v54;
  os_log_type_t v55;
  char *v56;
  char *v57;
  void *v58;
  const char *BuildVersion;
  uint64_t v60;
  _BOOL4 v61;
  unint64_t v62;
  int v63;
  int v64;
  _BOOL4 v65;
  int v66;
  __darwin_time_t v67;
  uint64_t v68;
  uint64_t v69;
  int v70;
  NSObject *v71;
  uint64_t v72;
  int v73;
  int v74;
  char v75;
  int v76;
  NSObject *v77;
  os_signpost_id_t v78;
  int v79;
  NSObject *v80;
  int v81;
  NSObject *v82;
  int v83;
  int v84;
  BOOL v85;
  int v86;
  int v87;
  NSObject *v88;
  char *v90;
  __darwin_time_t v91;
  uint64_t v92;
  uint64_t *v93;
  uint64_t v94;
  uint64_t v95;
  int v96;
  int v97;
  signed int v98;
  time_t v99;
  int v100;
  int v101;
  int v102;
  __darwin_time_t v103;
  int v104;
  int v105;
  NSObject *v106;
  __darwin_time_t v107;
  os_signpost_id_t spid;
  void *__dst;
  size_t size;
  int v111;
  uint8_t buf[4];
  const char *v113;
  __int16 v114;
  int v115;
  __int16 v116;
  stat *v117;
  stat __str[7];
  char __s[1024];
  uint64_t v120;

  v120 = *MEMORY[0x1E0C80C00];
  v10 = time(0);
  v11 = 3600;
  if ((a3 & 4) == 0)
    v11 = 10800;
  if ((a3 & 1) != 0)
    v12 = 14400;
  else
    v12 = v11;
  spid = ((a3 & 4) >> 1) ^ 3u;
  v13 = os_log_create("com.apple.spotlight.trace", "SignPosts");
  if (a4)
    *a4 = -1;
  v111 = 0;
  bzero(__s, 0x400uLL);
  v90 = __s;
  if ((fcntl(a1, 50) & 0x80000000) == 0 && __s[0])
  {
    size = strlen(__s) + 1;
    v96 = a1;
    v97 = a2;
    v101 = a3 & 4;
    v93 = a4;
    v94 = v12;
    v99 = v10;
    if (a2)
    {
      bzero(__str, 0x400uLL);
      v19 = strrchr(__s, 47);
      if (!v19 || (v21 = v19[1], v20 = v19 + 1, !v21))
      {
        v24 = -1;
        goto LABEL_32;
      }
      if (a5)
      {
        if (a5 == 1)
        {
          v22 = "mds64-crash-state-vector-index-v2";
        }
        else
        {
          v22 = "mds64-crash-state-reverse-store-v2";
          if (a5 == 3)
            v22 = "mds64-crash-state-forward-path-index-v2";
        }
      }
      else
      {
        v22 = "mds64-crash-state-v2";
      }
      snprintf((char *)__str, 0x400uLL, "/private/var/db/Spotlight-V100/%s-%s", v20, v22);
      LOWORD(v90) = 0;
      v23 = (char *)__str;
      v25 = -1;
      v26 = 0x20000000;
    }
    else
    {
      if (a5)
      {
        if (a5 == 1)
        {
          v23 = "mds64-crash-state-vector-index-v2";
        }
        else if (a5 == 3)
        {
          v23 = "mds64-crash-state-forward-path-index-v2";
        }
        else
        {
          v23 = "mds64-crash-state-reverse-store-v2";
        }
      }
      else
      {
        v23 = "mds64-crash-state-v2";
      }
      v25 = a1;
      v26 = 0;
    }
    v24 = x_openat(v25, v23, v26, v14, v15, v16, v17, v18, (unsigned __int16)v90);
LABEL_32:
    if (v24 != -1)
    {
      v104 = 0;
      v103 = 0;
      v100 = 0;
      v91 = 0;
      v98 = 0;
      v95 = -1;
      v92 = -1;
      v106 = v13;
      v105 = v24;
      while (1)
      {
        v27 = read(v24, &v111, 4uLL);
        if (v27 != 4)
          break;
        if (read(v24, &size, 8uLL) != 8)
          goto LABEL_87;
        v33 = v111;
        v34 = size;
        if (v111 == 875967043)
        {
          v111 = 1127364148;
          v34 = bswap64(size);
          size = v34;
          v35 = 1127364148;
        }
        else
        {
          v35 = v111;
        }
        v36 = 1;
        if (v35 != 1127364148 || v34 > 4096 || v34 < 49)
          goto LABEL_88;
        v37 = (char *)malloc_type_malloc(v34, 0xB4827342uLL);
        if (!v37)
          goto LABEL_85;
        v38 = v37;
        v39 = read(v24, v37, size);
        if (v39 != size)
          goto LABEL_84;
        if (v33 == 875967043)
        {
          for (i = 0; i != 48; i += 16)
            *(int8x16_t *)&v38[i] = vrev64q_s8(*(int8x16_t *)&v38[i]);
        }
        v38[v39 - 1] = 0;
        v41 = *((_QWORD *)v38 + 4);
        v107 = *((_QWORD *)v38 + 3);
        v42 = *((_QWORD *)v38 + 5);
        v43 = malloc_type_malloc(v41, 0xA6F45376uLL);
        if (!v43)
          goto LABEL_84;
        v44 = v43;
        v45 = malloc_type_malloc(v42, 0xB972DA82uLL);
        if (!v45)
          goto LABEL_84;
        v102 = v38[48];
        v46 = -49;
        if (v102 == 43)
        {
          v47 = v38 + 49;
        }
        else
        {
          v46 = -48;
          v47 = v38 + 48;
        }
        v48 = size - (v42 + v41);
        v49 = v48 + v46;
        if ((uint64_t)(v48 + v46) < 1 || (v50 = v45, (v51 = malloc_type_malloc(v48 + v46, 0xC31342C3uLL)) == 0))
        {
LABEL_84:
          free(v38);
LABEL_85:
          v36 = 0;
          goto LABEL_88;
        }
        v52 = v51;
        __dst = v50;
        v53 = *__error();
        v54 = _SILogForLogForCategory(0);
        v55 = 2 * (gSILogLevels[0] < 4);
        if (os_log_type_enabled(v54, v55))
        {
          __str[0].st_dev = 134218496;
          *(_QWORD *)&__str[0].st_mode = v107;
          WORD2(__str[0].st_ino) = 2048;
          *(__darwin_ino64_t *)((char *)&__str[0].st_ino + 6) = v41;
          HIWORD(__str[0].st_gid) = 2048;
          *(_QWORD *)&__str[0].st_rdev = v42;
          _os_log_impl(&dword_1B8270000, v54, v55, "check_crash_state (%ld, %ld, %ld)", (uint8_t *)__str, 0x20u);
        }
        *__error() = v53;
        memcpy(v44, v47, v41);
        v56 = &v47[v41];
        memcpy(__dst, v56, v42);
        v57 = &v56[v42];
        v58 = v52;
        memcpy(v52, v57, v49);
        BuildVersion = getBuildVersion();
        if (!strcmp((const char *)v44, BuildVersion)
          && !strcmp((const char *)__dst, sSpotlightVersion)
          && !strcmp((const char *)v52, __s))
        {
          v13 = v106;
          v60 = v99 - v107;
          v24 = v105;
          if (v93)
            *v93 = v60;
          v61 = v60 > 0;
          v62 = v60 - 1;
          v63 = v98;
          if ((unint64_t)(v60 - 1) < 0x545FF)
            v63 = v98 + 1;
          v98 = v63;
          v85 = v60 < v94;
          v64 = v97;
          if (v85)
            v64 = 1;
          v65 = v104 == 0;
          v66 = v61 & v64;
          v104 += v66;
          v67 = v103;
          if (v66)
            v67 = v107;
          v103 = v67;
          v68 = v95;
          if ((v66 & v65) != 0)
            v68 = v107;
          v95 = v68;
          if (v102 == 43 && v62 <= 0x3F47E)
          {
            v69 = v92;
            if (!v100)
              v69 = v107;
            v91 = v107;
            v92 = v69;
            ++v100;
          }
        }
        else
        {
          v13 = v106;
          v24 = v105;
          if (gSILogLevels[0] >= 5)
          {
            v70 = *__error();
            v71 = _SILogForLogForCategory(0);
            if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT))
            {
              __str[0].st_dev = 136315650;
              *(_QWORD *)&__str[0].st_mode = v44;
              WORD2(__str[0].st_ino) = 2080;
              *(__darwin_ino64_t *)((char *)&__str[0].st_ino + 6) = (__darwin_ino64_t)__dst;
              HIWORD(__str[0].st_gid) = 2080;
              *(_QWORD *)&__str[0].st_rdev = v58;
              _os_log_impl(&dword_1B8270000, v71, OS_LOG_TYPE_DEFAULT, "Ignoring crash data for (%s,%s,%s)", (uint8_t *)__str, 0x20u);
            }
            *__error() = v70;
          }
        }
        free(v38);
        free(v44);
        free(__dst);
        free(v58);
      }
      if (!v27)
        goto LABEL_85;
LABEL_87:
      v36 = 1;
LABEL_88:
      if (v104 > 2 && v103 > v99 - 1800)
      {
        if ((double)v104 / (double)(v103 - v95) >= 0.00333333333)
        {
          v76 = *__error();
          v77 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v77, OS_LOG_TYPE_ERROR))
          {
            __str[0].st_dev = 136315650;
            *(_QWORD *)&__str[0].st_mode = "check_crash_state";
            WORD2(__str[0].st_ino) = 1024;
            *(_DWORD *)((char *)&__str[0].st_ino + 6) = 498;
            HIWORD(__str[0].st_uid) = 2048;
            *(_QWORD *)&__str[0].st_gid = ((unint64_t)v94 * (unsigned __int128)0x123456789ABCE0uLL) >> 64;
            _os_log_error_impl(&dword_1B8270000, v77, OS_LOG_TYPE_ERROR, "%s:%d: Detected recurring crashes %lu hour window", (uint8_t *)__str, 0x1Cu);
          }
          *__error() = v76;
          if (!os_signpost_enabled(v13))
            goto LABEL_108;
          v78 = spid | 0x24;
          LOWORD(__str[0].st_dev) = 0;
          goto LABEL_107;
        }
        if (os_signpost_enabled(v13))
        {
          LOWORD(__str[0].st_dev) = 0;
          _os_signpost_emit_with_name_impl(&dword_1B8270000, v13, OS_SIGNPOST_EVENT, spid | 4, "check_crash_state_signpost", (const char *)&unk_1B865F3E6, (uint8_t *)__str, 2u);
        }
      }
      v73 = v100;
      if (v100 < 2)
      {
        v74 = 0;
        v75 = 1;
LABEL_110:
        if (v101 || v98 < 96)
        {
          if (!(v74 | v104) && !v73 && v98 <= 95)
          {
            if (os_signpost_enabled(v13))
            {
              LOWORD(__str[0].st_dev) = 0;
              _os_signpost_emit_with_name_impl(&dword_1B8270000, v13, OS_SIGNPOST_EVENT, spid, "check_crash_state_signpost", (const char *)&unk_1B865F3E6, (uint8_t *)__str, 2u);
            }
            v72 = 0;
            if ((v36 & 1) == 0)
              goto LABEL_144;
            goto LABEL_139;
          }
          if ((v75 & 1) != 0)
          {
            v72 = 0;
LABEL_138:
            if (!v36)
            {
LABEL_144:
              close(v24);
              return v72;
            }
LABEL_139:
            bzero(__str, 0x400uLL);
            if ((fcntl(v24, 50, __str) & 0x80000000) == 0 && LOBYTE(__str[0].st_dev))
            {
              v87 = *__error();
              v88 = _SILogForLogForCategory(0);
              if (os_log_type_enabled(v88, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136315650;
                v113 = "check_crash_state";
                v114 = 1024;
                v115 = 553;
                v116 = 2080;
                v117 = __str;
                _os_log_error_impl(&dword_1B8270000, v88, OS_LOG_TYPE_ERROR, "%s:%d: invalid crash state file (%s) deleting", buf, 0x1Cu);
              }
              *__error() = v87;
              unlink((const char *)__str);
            }
            goto LABEL_144;
          }
        }
        else
        {
          v81 = *__error();
          v82 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v82, OS_LOG_TYPE_ERROR))
          {
            __str[0].st_dev = 136315650;
            *(_QWORD *)&__str[0].st_mode = "check_crash_state";
            WORD2(__str[0].st_ino) = 1024;
            *(_DWORD *)((char *)&__str[0].st_ino + 6) = 524;
            HIWORD(__str[0].st_uid) = 1024;
            __str[0].st_gid = v98;
            _os_log_error_impl(&dword_1B8270000, v82, OS_LOG_TYPE_ERROR, "%s:%d: crash count: %d", (uint8_t *)__str, 0x18u);
          }
          *__error() = v81;
          if (os_signpost_enabled(v13))
          {
            LOWORD(__str[0].st_dev) = 0;
            _os_signpost_emit_with_name_impl(&dword_1B8270000, v13, OS_SIGNPOST_EVENT, spid | 0x30, "check_crash_state_signpost", (const char *)&unk_1B865F3E6, (uint8_t *)__str, 2u);
          }
        }
        v72 = 1;
        if (v97)
        {
          if (v103)
          {
            v83 = x_openat(v96, "indexState", 0, v28, v29, v30, v31, v32, (unsigned __int16)v90);
            if (v83 != -1)
            {
              v84 = v83;
              memset(__str, 0, 144);
              if (fstat(v83, __str))
                v85 = 1;
              else
                v85 = __str[0].st_mtimespec.tv_sec <= v103;
              v86 = !v85;
              v72 = v86 ^ 1u;
              if (!v85)
                LOBYTE(v36) = 1;
              close(v84);
              if ((v36 & 1) == 0)
                goto LABEL_144;
              goto LABEL_139;
            }
          }
        }
        goto LABEL_138;
      }
      if ((double)v100 / (double)(v91 - v92) < 0.000277777778)
      {
        if (os_signpost_enabled(v13))
        {
          LOWORD(__str[0].st_dev) = 0;
          _os_signpost_emit_with_name_impl(&dword_1B8270000, v13, OS_SIGNPOST_EVENT, spid | 8, "check_crash_state_signpost", (const char *)&unk_1B865F3E6, (uint8_t *)__str, 2u);
        }
        v74 = 0;
        v75 = 1;
        goto LABEL_109;
      }
      v79 = *__error();
      v80 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v80, OS_LOG_TYPE_ERROR))
      {
        __str[0].st_dev = 136315394;
        *(_QWORD *)&__str[0].st_mode = "check_crash_state";
        WORD2(__str[0].st_ino) = 1024;
        *(_DWORD *)((char *)&__str[0].st_ino + 6) = 514;
        _os_log_error_impl(&dword_1B8270000, v80, OS_LOG_TYPE_ERROR, "%s:%d: Detected recurring crashes during compacting", (uint8_t *)__str, 0x12u);
      }
      *__error() = v79;
      if (!os_signpost_enabled(v13))
      {
LABEL_108:
        v75 = 0;
        v74 = 1;
LABEL_109:
        v73 = v100;
        goto LABEL_110;
      }
      v78 = spid | 0x28;
      LOWORD(__str[0].st_dev) = 0;
LABEL_107:
      _os_signpost_emit_with_name_impl(&dword_1B8270000, v13, OS_SIGNPOST_EVENT, v78, "check_crash_state_signpost", (const char *)&unk_1B865F3E6, (uint8_t *)__str, 2u);
      goto LABEL_108;
    }
    if (os_signpost_enabled(v13))
    {
      LOWORD(__str[0].st_dev) = 0;
      goto LABEL_82;
    }
    return 0;
  }
  if (os_signpost_enabled(v13))
  {
    LOWORD(__str[0].st_dev) = 0;
LABEL_82:
    _os_signpost_emit_with_name_impl(&dword_1B8270000, v13, OS_SIGNPOST_EVENT, spid, "check_crash_state_signpost", (const char *)&unk_1B865F3E6, (uint8_t *)__str, 2u);
  }
  return 0;
}

const char *getBuildVersion()
{
  char *v0;
  const __CFDictionary *v1;
  const __CFDictionary *v2;
  const __CFString *Value;

  v0 = sBuildVersion;
  if ((sBuildVersionWasSet & 1) == 0)
  {
    v1 = (const __CFDictionary *)_CFCopySystemVersionDictionary();
    if (v1)
    {
      v2 = v1;
      Value = (const __CFString *)CFDictionaryGetValue(v1, CFSTR("ProductBuildVersion"));
      CFStringGetCString(Value, sBuildVersion, 128, 0x8000100u);
      CFRelease(v2);
      sBuildVersionWasSet = 1;
    }
    else if (!sBuildVersionWasSet)
    {
      return "unknown";
    }
  }
  return v0;
}

void touch_crash_state(int a1)
{
  time_t v2;

  v2 = time(0);
  write_out_crash_state(0, 0, 0, v2, a1, 0, 0);
}

void write_out_crash_state(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7)
{
  const char *BuildVersion;
  size_t v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  size_t v20;
  char *v21;
  int v22;
  int v23;
  size_t v24;
  size_t v25;
  uint64_t v26;
  size_t v27;
  size_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  size_t v32;
  _BYTE v33[5];
  uint64_t v34;
  char __s[1024];
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v34 = a3;
  if ((gProcessTerminating & 1) == 0
    && (write_out_crash_state_lastDirFd != a5
     || CFAbsoluteTimeGetCurrent() - *(double *)&write_out_crash_state_lastTime >= 10.0))
  {
    qmemcpy(v33, "+462C", sizeof(v33));
    bzero(__s, 0x400uLL);
    if ((fcntl(a5, 50, __s) & 0x80000000) == 0)
    {
      if (__s[0])
      {
        BuildVersion = getBuildVersion();
        v14 = strlen(BuildVersion);
        v20 = strlen(sSpotlightVersion);
        if (a7)
        {
          if (a7 == 1)
            v21 = "mds64-crash-state-vector-index-v2";
          else
            v21 = a7 == 3 ? "mds64-crash-state-forward-path-index-v2" : "mds64-crash-state-reverse-store-v2";
        }
        else
        {
          v21 = "mds64-crash-state-v2";
        }
        v22 = x_openat(a5, v21, 536871434, v15, v16, v17, v18, v19, 0x180u);
        if ((v22 & 0x80000000) == 0)
        {
          v23 = v22;
          v24 = v20 + 1;
          write_out_crash_state_lastDirFd = a5;
          write_out_crash_state_lastTime = CFAbsoluteTimeGetCurrent();
          v25 = strlen(__s) + 1;
          v26 = 49;
          if (a6)
            v26 = 50;
          v32 = v26 + v14 + v24 + v25;
          write(v23, &v33[1], 4uLL);
          write(v23, &v32, 8uLL);
          v30 = a2;
          v31 = a1;
          v28 = v14 + 1;
          v29 = a4;
          v27 = v24;
          write(v23, &v31, 8uLL);
          write(v23, &v30, 8uLL);
          write(v23, &v34, 8uLL);
          write(v23, &v29, 8uLL);
          write(v23, &v28, 8uLL);
          write(v23, &v27, 8uLL);
          if (a6)
            write(v23, v33, 1uLL);
          write(v23, BuildVersion, v14 + 1);
          write(v23, sSpotlightVersion, v24);
          write(v23, __s, v25);
          close(v23);
        }
      }
    }
  }
}

void ContentIndex_catch_mach_exception_raise()
{
  uint8_t v0[16];

  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)v0 = 0;
    _os_log_error_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Unsupported ContentIndex_catch_mach_exception_raise", v0, 2u);
  }
}

void ContentIndex_catch_mach_exception_raise_state()
{
  uint8_t v0[16];

  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)v0 = 0;
    _os_log_error_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Unsupported ContentIndex_catch_mach_exception_raise_state", v0, 2u);
  }
}

void ContentIndex_catch_mach_exception_raise_state_identity()
{
  uint8_t v0[16];

  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)v0 = 0;
    _os_log_error_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "Unsupported ContentIndex_catch_mach_exception_raise_state_identity", v0, 2u);
  }
}

uint64_t ContentIndex_catch_mach_exception_raise_identity_protected(uint64_t a1, int a2, thread_act_array_t a3)
{
  ipc_space_t *v6;
  unint64_t v7;
  thread_read_t *v8;
  mach_port_name_t v9;
  uint64_t v10;
  uint64_t v11;
  int *v12;
  int v13;
  integer_t v14;
  char v15;
  int *v16;
  int v17;
  unsigned int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int (*v23)(_QWORD, thread_act_array_t);
  uint64_t v24;
  uint64_t (*v25)(_QWORD, _QWORD);
  unsigned int v26;
  unsigned int v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t (*v32)(_QWORD, _QWORD);
  int v33;
  double Current;
  thread_act_t *v35;
  unsigned int *v37;
  unsigned int v38;
  int v39;
  int v40;
  uint64_t v41;
  void (*v42)(_QWORD);
  unsigned int *v43;
  int v44;
  uint64_t v45;
  time_t v46;
  int v47;
  pthread_key_t v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  void (*v52)(_QWORD);
  _QWORD *v53;
  void (*v54)(_QWORD);
  uint64_t v55;
  pthread_key_t v57;
  int v58;
  uint64_t v59;
  uint64_t v60;
  void (*v61)(_QWORD);
  _QWORD *v62;
  void (*v63)(_QWORD);
  thread_act_array_t *v64;
  double *v65;
  int v66;
  NSObject *v67;
  _BOOL4 v68;
  char *v69;
  char *v70;
  const char *v71;
  uint64_t v72;
  thread_act_array_t v73;
  double v74;
  unsigned int v75;
  NSObject *log;
  NSObject *loga;
  int *v78;
  integer_t v79;
  integer_t v80;
  int v81;
  int *v82;
  uint64_t v83;
  _DWORD *v84;
  int *v85;
  void (*v86[5])(_QWORD, _QWORD);
  thread_act_array_t act_list[2];
  mach_msg_type_number_t thread_info_outCnt;
  mach_msg_type_number_t act_listCnt;
  integer_t thread_info_out[12];
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  __int128 v103;
  __int128 v104;
  uint64_t v105;

  v105 = *MEMORY[0x1E0C80C00];
  act_list[0] = 0;
  memset(thread_info_out, 0, 24);
  thread_info_outCnt = 6;
  act_listCnt = 0;
  v6 = (ipc_space_t *)MEMORY[0x1E0C83DA0];
  task_threads(*MEMORY[0x1E0C83DA0], act_list, &act_listCnt);
  if (!act_listCnt)
  {
    v8 = 0;
    v10 = 0;
    goto LABEL_14;
  }
  v7 = 0;
  v8 = 0;
  do
  {
    v9 = act_list[0][v7];
    if ((_DWORD)v8)
    {
      if ((_DWORD)v8 == v9)
      {
        v69 = __si_assert_copy_extra_268();
        v70 = v69;
        v71 = "";
        if (v69)
          v71 = v69;
        __message_assert("%s:%u: failed assertion '%s' %s ", "ContentIndexExceptionHandler.c", 820, "thread != threads[i]", v71);
        free(v70);
        if (__valid_fs(-1))
          v72 = 2989;
        else
          v72 = 3072;
        *(_DWORD *)v72 = -559038737;
        abort();
      }
      mach_port_deallocate(*v6, v9);
    }
    else
    {
      if (thread_info(act_list[0][v7], 4u, thread_info_out, &thread_info_outCnt) != 268435459)
      {
        if (*(_QWORD *)thread_info_out == a1)
        {
          v8 = (thread_read_t *)act_list[0][v7];
          goto LABEL_11;
        }
        mach_port_deallocate(*v6, act_list[0][v7]);
      }
      v8 = 0;
    }
LABEL_11:
    ++v7;
  }
  while (v7 < act_listCnt);
  v10 = 4 * act_listCnt;
LABEL_14:
  MEMORY[0x1BCCB19C4](*v6, act_list[0], v10);
  thread_info_outCnt = 4;
  act_list[0] = 0;
  act_list[1] = 0;
  v11 = 0;
  if (!thread_get_state((thread_read_t)v8, 7, (thread_state_t)act_list, &thread_info_outCnt))
    a3 = act_list[0];
  v12 = &dword_1EDBE2398;
  while (1)
  {
    v13 = *v12;
    v12 += 4;
    if (v13 == (_DWORD)v8)
      break;
    if (++v11 == 2048)
    {
      v14 = 0;
LABEL_93:
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
      {
        thread_info_out[0] = 67109632;
        thread_info_out[1] = (int)v8;
        LOWORD(thread_info_out[2]) = 2048;
        *(_QWORD *)((char *)&thread_info_out[2] + 2) = a3;
        HIWORD(thread_info_out[4]) = 1024;
        thread_info_out[5] = v14;
        _os_log_error_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "exception handler not resolved for thread 0x%x addr %p reason %d", (uint8_t *)thread_info_out, 0x18u);
      }
      v55 = 5;
      goto LABEL_96;
    }
  }
  v79 = 0;
  v15 = 0;
  v16 = &threadData[18 * v11];
  v18 = v16[4];
  v16 += 4;
  v17 = v18;
  v84 = v16 + 2;
  v85 = v16 - 2;
  v78 = v16;
  v82 = v16 + 3;
  v83 = a2;
  v19 = 320 * v18 + 212;
  v81 = a2;
  while (2)
  {
    if (v17 <= 0)
    {
      if (v79)
        v14 = v79;
      else
        v14 = 4;
      goto LABEL_92;
    }
    v20 = v17;
    v21 = *(_QWORD *)v85;
    v22 = *(_QWORD *)v85 + v19;
    if (a2 != 1)
      goto LABEL_68;
    v23 = *(unsigned int (**)(_QWORD, thread_act_array_t))(v22 - 292);
    if (!v23)
      goto LABEL_68;
    v24 = v21 + v19;
    if (!v23(*(_QWORD *)(v21 + v19 - 244), a3))
      goto LABEL_68;
    v25 = *(uint64_t (**)(_QWORD, _QWORD))(v24 - 260);
    if (v25)
    {
      v26 = v25(*(_QWORD *)(v24 - 244), *(unsigned int *)(v21 + v19 - 236));
      goto LABEL_27;
    }
    v30 = *(_QWORD *)v85;
    if (*(_DWORD *)(*(_QWORD *)v85 + 296) == -1 && !*(_QWORD *)(v30 + 272))
    {
      if (*(_DWORD *)(v30 + 320 * (*v78 > 1) + 296) != -1)
      {
        v30 += 320 * (*v78 > 1);
        goto LABEL_43;
      }
      v31 = *(_QWORD *)(v30 + 320 * (*v78 > 1) + 272);
      v30 += 320 * (*v78 > 1);
      if (v31)
        goto LABEL_43;
LABEL_50:
      v26 = 0;
      goto LABEL_51;
    }
LABEL_43:
    v32 = *(uint64_t (**)(_QWORD, _QWORD))(v30 + 272);
    if (v32)
    {
      v26 = v32(*(_QWORD *)(v30 + 288), *(unsigned int *)(v30 + 296));
      if (v26)
        goto LABEL_27;
    }
    if (*(_DWORD *)(v30 + 296) == -1)
      goto LABEL_50;
    bzero(thread_info_out, 0x400uLL);
    v33 = fcntl(*(_DWORD *)(v30 + 296), 50, thread_info_out);
    v26 = 0;
    if ((v33 & 0x80000000) == 0 && LOBYTE(thread_info_out[0]))
    {
      if (strstr((char *)thread_info_out, "NSFileProtectionComplete/"))
      {
        v26 = 1;
      }
      else if (strstr((char *)thread_info_out, "NSFileProtectionCompleteUnlessOpen/"))
      {
        v26 = 2;
      }
      else if (strstr((char *)thread_info_out, "NSFileProtectionCompleteWhenUserInactive/"))
      {
        v26 = 7;
      }
      else
      {
        v26 = 0;
      }
    }
LABEL_27:
    if (v26 > 7 || ((1 << v26) & 0x86) == 0)
      goto LABEL_51;
    v28 = v26;
    v86[0] = (void (*)(_QWORD, _QWORD))MEMORY[0x1E0C809B0];
    v86[1] = (void (*)(_QWORD, _QWORD))0x40000000;
    v86[2] = (void (*)(_QWORD, _QWORD))__ContentIndex_catch_mach_exception_raise_identity_protected_block_invoke;
    v86[3] = (void (*)(_QWORD, _QWORD))&__block_descriptor_tmp_5083;
    v86[4] = (void (*)(_QWORD, _QWORD))(v22 - 532);
    if ((_SISuspendThreadIfLocked(v8, v86) & 1) != 0)
      goto LABEL_105;
    if (!gTerminating)
    {
      v26 = v28;
      goto LABEL_51;
    }
    v29 = sGetLockStateCallback;
    if (sGetLockStateCallback)
      v29 = (*(uint64_t (**)(void))(sGetLockStateCallback + 16))();
    v26 = v28;
    if (!v29)
    {
LABEL_51:
      if ((unint64_t)a3 <= *MEMORY[0x1E0C85AD8])
        goto LABEL_65;
      v80 = v26;
      Current = CFAbsoluteTimeGetCurrent();
      v35 = *(thread_act_t **)(v21 + v19 - 332);
      if (Current - *(double *)(v21 + v19 - 340) > 1.0 || a3 != v35)
      {
        v37 = (unsigned int *)(v21 + v19 - 324);
        if (a3 == v35)
        {
          v38 = *v37 + 1;
          *v37 = v38;
          if (v38 > 5)
          {
            v39 = *__error();
            log = _SILogForLogForCategory(10);
            if (os_log_type_enabled(log, OS_LOG_TYPE_ERROR))
            {
              thread_info_out[0] = 136315906;
              *(_QWORD *)&thread_info_out[1] = "ContentIndex_catch_mach_exception_raise_identity_protected";
              LOWORD(thread_info_out[3]) = 1024;
              *(integer_t *)((char *)&thread_info_out[3] + 2) = 961;
              HIWORD(thread_info_out[4]) = 2048;
              *(_QWORD *)&thread_info_out[5] = a3;
              LOWORD(thread_info_out[7]) = 1024;
              *(integer_t *)((char *)&thread_info_out[7] + 2) = v80;
              _os_log_error_impl(&dword_1B8270000, log, OS_LOG_TYPE_ERROR, "%s:%d: Repeated error on address %p pc %d", (uint8_t *)thread_info_out, 0x22u);
            }
            v40 = 1;
LABEL_64:
            v79 = v40;
            *__error() = v39;
            goto LABEL_65;
          }
          v37 = (unsigned int *)(v21 + v19 - 324);
          v64 = (thread_act_array_t *)(v21 + v19 - 332);
          v65 = (double *)(v21 + v19 - 340);
        }
        else
        {
          v64 = (thread_act_array_t *)(v21 + v19 - 332);
          v65 = (double *)(v21 + v19 - 340);
          *v37 = 0;
        }
        v66 = *__error();
        v67 = _SILogForLogForCategory(10);
        v68 = os_log_type_enabled(v67, OS_LOG_TYPE_ERROR);
        v6 = (ipc_space_t *)MEMORY[0x1E0C83DA0];
        if (v68)
        {
          v73 = *v64;
          v74 = Current - *v65;
          v75 = *v37;
          thread_info_out[0] = 136316674;
          *(_QWORD *)&thread_info_out[1] = "ContentIndex_catch_mach_exception_raise_identity_protected";
          LOWORD(thread_info_out[3]) = 1024;
          *(integer_t *)((char *)&thread_info_out[3] + 2) = 953;
          HIWORD(thread_info_out[4]) = 2048;
          *(_QWORD *)&thread_info_out[5] = a3;
          LOWORD(thread_info_out[7]) = 2048;
          *(_QWORD *)((char *)&thread_info_out[7] + 2) = v73;
          HIWORD(thread_info_out[9]) = 2048;
          *(double *)&thread_info_out[10] = v74;
          LOWORD(v91) = 1024;
          *(_DWORD *)((char *)&v91 + 2) = v75;
          WORD3(v91) = 1024;
          DWORD2(v91) = v80;
          _os_log_error_impl(&dword_1B8270000, v67, OS_LOG_TYPE_ERROR, "%s:%d: Retry operation on address %p (%p) %f %d pc %d", (uint8_t *)thread_info_out, 0x3Cu);
        }
        *__error() = v66;
        *v64 = a3;
        *v65 = Current;
        usleep(0x30D40u);
        v55 = 0;
        goto LABEL_96;
      }
      v39 = *__error();
      loga = _SILogForLogForCategory(10);
      if (os_log_type_enabled(loga, OS_LOG_TYPE_ERROR))
      {
        thread_info_out[0] = 136315906;
        *(_QWORD *)&thread_info_out[1] = "ContentIndex_catch_mach_exception_raise_identity_protected";
        LOWORD(thread_info_out[3]) = 1024;
        *(integer_t *)((char *)&thread_info_out[3] + 2) = 965;
        HIWORD(thread_info_out[4]) = 2048;
        *(_QWORD *)&thread_info_out[5] = a3;
        LOWORD(thread_info_out[7]) = 1024;
        *(integer_t *)((char *)&thread_info_out[7] + 2) = v80;
        _os_log_error_impl(&dword_1B8270000, loga, OS_LOG_TYPE_ERROR, "%s:%d: Repeated error on address %p pc %d", (uint8_t *)thread_info_out, 0x22u);
      }
      v40 = 2;
      goto LABEL_64;
    }
LABEL_65:
    v41 = v21 + v19;
    v42 = *(void (**)(_QWORD))(v21 + v19 - 252);
    if (v42)
      v42(*(_QWORD *)(v24 - 244));
    v43 = (unsigned int *)(v41 - 320);
    v44 = *(_DWORD *)(v41 - 320);
    a2 = v81;
    if ((v44 & 0x40000000) == 0)
    {
      *v43 = v44 | 0x80000000;
      v57 = exc_pthread_key[0];
      if (!exc_pthread_key[0])
      {
        pthread_key_create(exc_pthread_key, 0);
        v57 = exc_pthread_key[0];
      }
      pthread_setspecific(v57, *(const void **)&threadData[18 * v11 + 10]);
      if (*v78 >= v20)
      {
        v58 = *v78 + 1;
        do
        {
          v59 = *(_QWORD *)v85;
          v60 = *(_QWORD *)v85 + 320 * (v58 - 2);
          CICleanUpReset(v11, *(int *)(v60 + 300));
          v63 = *(void (**)(_QWORD))(v60 + 248);
          v62 = (_QWORD *)(v60 + 248);
          v61 = v63;
          if (v63)
          {
            *v62 = 0;
            v61(*(_QWORD *)(v59 + 320 * (v58 - 2) + 288));
          }
          --v58;
        }
        while (v58 > v20);
      }
      goto LABEL_104;
    }
LABEL_68:
    v15 |= *(_BYTE *)(v22 - 316) != 0;
    if (*(_DWORD *)(v22 - 236) != -1 && !*v84)
    {
      act_listCnt = 68;
      v103 = 0u;
      v104 = 0u;
      v101 = 0u;
      v102 = 0u;
      v99 = 0u;
      v100 = 0u;
      v97 = 0u;
      v98 = 0u;
      v95 = 0u;
      v96 = 0u;
      v93 = 0u;
      v94 = 0u;
      v91 = 0u;
      v92 = 0u;
      memset(thread_info_out, 0, sizeof(thread_info_out));
      thread_get_state((thread_read_t)v8, 6, (thread_state_t)thread_info_out, &act_listCnt);
      v45 = v104;
      v46 = time(0);
      write_out_crash_state(v45, (uint64_t)a3, v83, v46, *(_DWORD *)(v22 - 236), v15 & 1, *v82);
    }
    if (a3 == (thread_act_array_t)2816)
      exit(-1);
    v19 -= 320;
    v47 = *(_DWORD *)(v19 + v21);
    v17 = v20 - 1;
    if ((v47 & 1) == 0)
      continue;
    break;
  }
  if (a3 != (thread_act_array_t)3072)
  {
    v14 = 3;
LABEL_92:
    v6 = (ipc_space_t *)MEMORY[0x1E0C83DA0];
    goto LABEL_93;
  }
  *(_DWORD *)(v21 + v19) = v47 | 0x80000000;
  v48 = exc_pthread_key[0];
  if (!exc_pthread_key[0])
  {
    pthread_key_create(exc_pthread_key, 0);
    v48 = exc_pthread_key[0];
  }
  pthread_setspecific(v48, *(const void **)&threadData[18 * v11 + 10]);
  if (*v78 >= v20)
  {
    v49 = *v78 + 1;
    do
    {
      v50 = *(_QWORD *)v85;
      v51 = *(_QWORD *)v85 + 320 * (v49 - 2);
      CICleanUpReset(v11, *(int *)(v51 + 300));
      v54 = *(void (**)(_QWORD))(v51 + 248);
      v53 = (_QWORD *)(v51 + 248);
      v52 = v54;
      if (v54)
      {
        *v53 = 0;
        v52(*(_QWORD *)(v50 + 320 * (v49 - 2) + 288));
      }
      --v49;
    }
    while (v49 > v20);
  }
LABEL_104:
  pthread_setspecific(exc_pthread_key[0], 0);
  setPC((thread_read_t)v8);
LABEL_105:
  v55 = 0;
  v6 = (ipc_space_t *)MEMORY[0x1E0C83DA0];
LABEL_96:
  mach_port_deallocate(*v6, (mach_port_name_t)v8);
  return v55;
}

int *setPC(thread_read_t a1)
{
  kern_return_t state;
  mach_error_t v3;
  int v4;
  NSObject *v5;
  int v6;
  NSObject *v7;
  int *result;
  char *v9;
  char *v10;
  mach_msg_type_number_t old_stateCnt;
  natural_t old_state[4];
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  uint8_t buf[4];
  const char *v30;
  __int16 v31;
  int v32;
  __int16 v33;
  char *v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v20 = 0u;
  v18 = 0u;
  v19 = 0u;
  v16 = 0u;
  v17 = 0u;
  v14 = 0u;
  v15 = 0u;
  *(_OWORD *)old_state = 0u;
  v13 = 0u;
  old_stateCnt = 68;
  state = thread_get_state(a1, 6, old_state, &old_stateCnt);
  if (state)
  {
    v3 = state;
    v4 = *__error();
    v5 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v9 = mach_error_string(v3);
      *(_DWORD *)buf = 136315650;
      v30 = "setPC";
      v31 = 1024;
      v32 = 724;
      v33 = 2080;
      v34 = v9;
      _os_log_error_impl(&dword_1B8270000, v5, OS_LOG_TYPE_ERROR, "%s:%d: thread_get_state: %s", buf, 0x1Cu);
    }
    *__error() = v4;
    *(_QWORD *)&v28 = in_thread_handler;
    thread_set_state(a1, 6, old_state, old_stateCnt);
    v6 = *__error();
    v7 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      v10 = mach_error_string(v3);
      *(_DWORD *)buf = 136315650;
      v30 = "setPC";
      v31 = 1024;
      v32 = 737;
      v33 = 2080;
      v34 = v10;
      _os_log_error_impl(&dword_1B8270000, v7, OS_LOG_TYPE_ERROR, "%s:%d: thread_set_state: %s", buf, 0x1Cu);
    }
    result = __error();
    *result = v6;
  }
  else
  {
    *(_QWORD *)&v28 = in_thread_handler;
    return (int *)thread_set_state(a1, 6, old_state, old_stateCnt);
  }
  return result;
}

void in_thread_handler()
{
  void *v0;
  _DWORD *v1;
  int v2;
  int v3;
  uint64_t v4;
  char *v5;
  char *v6;
  const char *v7;
  uint64_t v8;

  v0 = pthread_getspecific(__THREAD_SLOT_KEY);
  if (!v0)
  {
    v5 = __si_assert_copy_extra_268();
    v6 = v5;
    v7 = "";
    if (v5)
      v7 = v5;
    __message_assert("%s:%u: failed assertion '%s' %s ", "ContentIndexExceptionHandler.c", 689, "loc", v7);
    free(v6);
    if (__valid_fs(-1))
      v8 = 2989;
    else
      v8 = 3072;
    *(_DWORD *)v8 = -559038737;
    abort();
  }
  v1 = &threadData[18 * (_QWORD)v0];
  v2 = *(v1 - 14);
  v3 = (v2 & (v2 >> 31)) - 1;
  v4 = *((_QWORD *)v1 - 8);
  do
  {
    if (v2 < 1)
      goto LABEL_6;
    --v2;
  }
  while ((*(_DWORD *)(v4 + 320 * v2 + 212) & 0x80000001) == 0);
  v3 = v2;
LABEL_6:
  _longjmp((int *)(v4 + 320 * v3), 1);
}

BOOL SIGetExceptionPort(_DWORD *a1, _QWORD *a2)
{
  int v3;
  ipc_space_t *v5;
  kern_return_t v6;
  kern_return_t inserted;
  _BOOL8 result;
  int v9;
  NSObject *v10;
  mach_error_t v11;
  char *v12;
  char *v13;
  const char *v14;
  mach_error_t v15;
  char *v16;
  const char *v17;
  uint64_t v18;
  char *v19;
  char *v20;
  uint8_t buf[16];

  v3 = _exceptionPort;
  if (!_exceptionPort)
  {
    if (gSILogLevels[0] >= 5)
    {
      v9 = *__error();
      v10 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1B8270000, v10, OS_LOG_TYPE_DEFAULT, "Allocating threads and such.", buf, 2u);
      }
      *__error() = v9;
    }
    v5 = (ipc_space_t *)MEMORY[0x1E0C83DA0];
    v6 = mach_port_allocate(*MEMORY[0x1E0C83DA0], 1u, (mach_port_name_t *)&_exceptionPort);
    if (v6)
    {
      v11 = v6;
      v12 = __si_assert_copy_extra_268();
      v13 = v12;
      if (v12)
        v14 = v12;
      else
        v14 = "";
      v19 = mach_error_string(v11);
      __message_assert("%s:%u: failed assertion '%s' %s %s", "ContentIndexExceptionHandler.c", 1188, "krc==KERN_SUCCESS", v14, v19);
    }
    else
    {
      inserted = mach_port_insert_right(*v5, _exceptionPort, _exceptionPort, 0x14u);
      if (!inserted)
      {
        *a1 = _exceptionPort;
        goto LABEL_6;
      }
      v15 = inserted;
      v16 = __si_assert_copy_extra_268();
      v13 = v16;
      if (v16)
        v17 = v16;
      else
        v17 = "";
      v20 = mach_error_string(v15);
      __message_assert("%s:%u: failed assertion '%s' %s %s", "ContentIndexExceptionHandler.c", 1193, "krc==KERN_SUCCESS", v17, v20);
    }
    free(v13);
    if (__valid_fs(-1))
      v18 = 2989;
    else
      v18 = 3072;
    *(_DWORD *)v18 = -559038737;
    abort();
  }
LABEL_6:
  result = v3 == 0;
  *a2 = handleException;
  return result;
}

void __makeThreadId_block_invoke()
{
  uint64_t v0;
  int v1;
  NSObject *v2;
  os_log_type_t v3;
  mach_error_t v4;
  char *v5;
  char *v6;
  const char *v7;
  char *v8;
  const char *v9;
  uint64_t v10;
  char *v11;
  char *v12;
  const char *v13;
  char *v14;
  uint64_t v15;
  int v16;
  NSObject *v17;
  uint8_t buf[8];
  uint64_t v19;
  int v20;
  pthread_t v21;
  pthread_attr_t v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (!__THREAD_SLOT_KEY
    && pthread_key_create((pthread_key_t *)&__THREAD_SLOT_KEY, (void (__cdecl *)(void *))freeThreadSlot))
  {
    v5 = __si_assert_copy_extra_268();
    v6 = v5;
    v7 = "";
    if (v5)
      v7 = v5;
    __message_assert("%s:%u: failed assertion '%s' %s ", "ContentIndexExceptionHandler.c", 1214, "result==0", v7);
LABEL_19:
    free(v6);
    if (__valid_fs(-1))
      v10 = 2989;
    else
      v10 = 3072;
    *(_DWORD *)v10 = -559038737;
    abort();
  }
  if (!__THREAD_STR_DATA_KEY
    && pthread_key_create((pthread_key_t *)&__THREAD_STR_DATA_KEY, (void (__cdecl *)(void *))MEMORY[0x1E0C834A8]))
  {
    v8 = __si_assert_copy_extra_268();
    v6 = v8;
    v9 = "";
    if (v8)
      v9 = v8;
    __message_assert("%s:%u: failed assertion '%s' %s ", "ContentIndexExceptionHandler.c", 1218, "result==0", v9);
    goto LABEL_19;
  }
  v0 = 0x8000u;
  do
  {
    *(_DWORD *)((char *)&threadList + v0 - 4) = -1;
    OSAtomicEnqueue(&sAvailabeThreadEntries, (char *)&threadList + v0 - 16, 0);
    v0 -= 16;
  }
  while (v0);
  if (!_exceptionPort)
  {
    v21 = 0;
    SIGetExceptionPort(&v20, &v19);
    memset(&v22, 0, sizeof(v22));
    pthread_attr_init(&v22);
    v1 = *__error();
    v2 = _SILogForLogForCategory(0);
    v3 = 2 * (gSILogLevels[0] < 4);
    if (os_log_type_enabled(v2, v3))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1B8270000, v2, v3, "Creating exception handler thread", buf, 2u);
    }
    *__error() = v1;
    v4 = pthread_create(&v21, &v22, (void *(__cdecl *)(void *))_handleExceptions, &_exceptionPort);
    pthread_attr_destroy(&v22);
    if (v4)
    {
      v11 = __si_assert_copy_extra_268();
      v12 = v11;
      if (v11)
        v13 = v11;
      else
        v13 = "";
      v14 = mach_error_string(v4);
      __message_assert("%s:%u: failed assertion '%s' %s %s", "ContentIndexExceptionHandler.c", 1247, "krc==KERN_SUCCESS", v13, v14);
      free(v12);
      if (__valid_fs(-1))
        v15 = 2989;
      else
        v15 = 3072;
      *(_DWORD *)v15 = -559038737;
      abort();
    }
    if (gSILogLevels[0] >= 5)
    {
      v16 = *__error();
      v17 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v22.__sig) = 0;
        _os_log_impl(&dword_1B8270000, v17, OS_LOG_TYPE_DEFAULT, "Done allocating threads and such.", (uint8_t *)&v22, 2u);
      }
      *__error() = v16;
    }
  }
}

void freeThreadSlot(int a1)
{
  uint64_t v1;
  _DWORD *v2;
  _DWORD *v3;
  _DWORD *v4;
  void *v5;
  void *v6;
  void *v7;
  _DWORD *v8;
  mach_port_name_t v9;
  _DWORD *v10;
  exception_mask_t v11;
  mach_port_t v12;
  thread_act_t v13;
  char *v14;
  char *v15;
  const char *v16;
  uint64_t v17;
  int v18;
  NSObject *v19;
  uint8_t buf[4];
  int v21;
  __int16 v22;
  mach_port_name_t v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v1 = (a1 - 1);
    v2 = (_DWORD *)((char *)&threadList + 16 * v1);
    if (v2[3])
    {
      v14 = __si_assert_copy_extra_268();
      v15 = v14;
      v16 = "";
      if (v14)
        v16 = v14;
      __message_assert("%s:%u: failed assertion '%s' %s ", "ContentIndexExceptionHandler.c", 1130, "entry->count==0", v16);
      free(v15);
      if (__valid_fs(-1))
        v17 = 2989;
      else
        v17 = 3072;
      *(_DWORD *)v17 = -559038737;
      abort();
    }
    v3 = &threadData[18 * v1];
    v4 = *(_DWORD **)v3;
    if (v1 < 0x11)
    {
      v5 = 0;
      v6 = 0;
      v7 = 0;
      *(_QWORD *)v3 = 0;
      v8 = &threadData[18 * v1];
      v8[8] = 0;
      v8[14] = 0;
      v8[4] = 0;
      *((_QWORD *)v8 + 5) = 0;
    }
    else
    {
      v5 = (void *)*((_QWORD *)v3 + 1);
      v6 = (void *)*((_QWORD *)v3 + 6);
      v7 = (void *)*((_QWORD *)v3 + 8);
      *(_OWORD *)v3 = 0u;
      *((_OWORD *)v3 + 1) = 0u;
      *((_OWORD *)v3 + 2) = 0u;
      *((_OWORD *)v3 + 3) = 0u;
      *((_QWORD *)v3 + 8) = 0;
    }
    *((_QWORD *)&threadList + 2 * v1 + 1) = 0xFFFFFFFF00000000;
    OSAtomicEnqueue(&sAvailabeThreadEntries, v2, 0);
    v9 = MEMORY[0x1BCCB104C]();
    if (gSILogLevels[0] >= 5)
    {
      v18 = *__error();
      v19 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109376;
        v21 = v1;
        v22 = 1024;
        v23 = v9;
        _os_log_impl(&dword_1B8270000, v19, OS_LOG_TYPE_DEFAULT, "Dropped handler slot:%u port:%d", buf, 0xEu);
      }
      *__error() = v18;
    }
    if (*v4)
    {
      v10 = &v4[*v4 - 1];
      v11 = v10[1];
      v12 = v10[65];
      v13 = v9;
    }
    else
    {
      v13 = v9;
      v11 = 0;
      v12 = 0;
    }
    thread_set_exception_ports(v13, v11, v12, -2147483644, 1);
    mach_port_deallocate(*MEMORY[0x1E0C83DA0], v9);
    free(v5);
    free(v6);
    free(v7);
    free(v4);
  }
}

void _handleExceptions(uint64_t a1)
{
  mach_port_t *v1;
  mach_port_t v2;
  int v3;
  NSObject *v4;
  mach_msg_size_t v5;
  char v6;
  mach_msg_header_t msg;
  mach_msg_header_t v8[170];

  v1 = (mach_port_t *)MEMORY[0x1E0C80A78](a1);
  if (gSILogLevels[0] >= 5)
  {
    v3 = *__error();
    v4 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      v5 = *MEMORY[0x1E0C83DA0];
      v8[0].msgh_bits = 67109120;
      v8[0].msgh_size = v5;
      _os_log_impl(&dword_1B8270000, v4, OS_LOG_TYPE_DEFAULT, "starting exc_thread loop in task %d", (uint8_t *)v8, 8u);
    }
    *__error() = v3;
  }
  while (1)
  {
    do
    {
      bzero(v8, 0x1000uLL);
      v2 = *v1;
      v8[0].msgh_size = 4096;
      v8[0].msgh_local_port = v2;
    }
    while (mach_msg(v8, 2, 0, 0x1000u, v2, 1u, 0));
    bzero(&v6, 0x1000uLL);
    mach_exc_server(v8, (uint64_t)&v6);
    mach_msg((mach_msg_header_t *)&v6, 1, *(mach_msg_size_t *)((char *)&msg.msgh_bits + 3), 0, 0, 0, 0);
  }
}

unint64_t pushSkipCrashState()
{
  pthread_key_t v0;
  unint64_t result;

  v0 = __THREAD_SLOT_KEY;
  if (!__THREAD_SLOT_KEY)
  {
    makeThreadId();
    v0 = __THREAD_SLOT_KEY;
  }
  result = (unint64_t)pthread_getspecific(v0);
  if (result && result < 0x801
    || (makeThreadId(), (result = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY)) != 0))
  {
    if (result <= 0x800)
      ++threadData[18 * result - 12];
  }
  return result;
}

unint64_t popSkipCrashState()
{
  unint64_t result;
  _DWORD *v1;
  _DWORD *v2;
  int v3;
  int v4;

  result = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY);
  if (result && result <= 0x800)
  {
    v1 = &threadData[18 * result];
    v4 = *(v1 - 12);
    v2 = v1 - 12;
    v3 = v4;
    if (v4)
      *v2 = v3 - 1;
  }
  return result;
}

uint64_t setCrashStateTarget(int a1)
{
  pthread_key_t v2;
  unint64_t v3;
  uint64_t v4;
  _DWORD *v5;

  v2 = __THREAD_SLOT_KEY;
  if (!__THREAD_SLOT_KEY)
  {
    makeThreadId();
    v2 = __THREAD_SLOT_KEY;
  }
  v3 = (unint64_t)pthread_getspecific(v2);
  if (!v3 || v3 >= 0x801)
  {
    makeThreadId();
    v3 = (unint64_t)pthread_getspecific(__THREAD_SLOT_KEY);
  }
  v4 = 0;
  if (v3 && v3 <= 0x800)
  {
    v5 = &threadData[18 * v3];
    v4 = *(v5 - 11);
    *(v5 - 11) = a1;
  }
  return v4;
}

uint64_t CIOnThreadCleanUpReset(unsigned int a1)
{
  uint64_t result;
  _DWORD *v3;
  unsigned int *v4;
  unsigned int v5;
  uint64_t v6;

  result = (uint64_t)CICleanUpThreadLoc();
  v3 = &threadData[18 * result];
  v5 = v3[14];
  v4 = v3 + 14;
  if (v5 > a1)
  {
    v6 = result;
    do
      result = CIOnThreadCleanUpPop(v6);
    while (*v4 > a1);
  }
  return result;
}

uint64_t _data_map64_wrlock(uint64_t a1)
{
  uint64_t v1;
  int v3;
  NSObject *v4;
  int v5;
  int v6;
  const char *v7;
  __int16 v8;
  int v9;
  __int16 v10;
  int v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 4565))
    return 0;
  v1 = _db_write_lock(a1);
  if ((_DWORD)v1)
  {
    v3 = *__error();
    v4 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = v1;
      if ((_DWORD)v1 == -1)
        v5 = *__error();
      v6 = 136315650;
      v7 = "_data_map64_wrlock";
      v8 = 1024;
      v9 = 263;
      v10 = 1024;
      v11 = v5;
      _os_log_error_impl(&dword_1B8270000, v4, OS_LOG_TYPE_ERROR, "%s:%d: _data_map64_wrlock error %d", (uint8_t *)&v6, 0x18u);
    }
    *__error() = v3;
  }
  return v1;
}

uint64_t _data_map64_rdlock(uint64_t a1)
{
  uint64_t lock;
  int v3;
  NSObject *v4;
  int v5;
  int v6;
  const char *v7;
  __int16 v8;
  int v9;
  __int16 v10;
  int v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 4565))
    return 0;
  lock = db_read_lock(a1);
  if ((_DWORD)lock)
  {
    v3 = *__error();
    v4 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = lock;
      if ((_DWORD)lock == -1)
        v5 = *__error();
      v6 = 136315650;
      v7 = "_data_map64_rdlock";
      v8 = 1024;
      v9 = 273;
      v10 = 1024;
      v11 = v5;
      _os_log_error_impl(&dword_1B8270000, v4, OS_LOG_TYPE_ERROR, "%s:%d: _data_map64_rdlock error %d", (uint8_t *)&v6, 0x18u);
    }
    *__error() = v3;
  }
  return lock;
}

uint64_t _data_map64_unlock(uint64_t a1)
{
  uint64_t v1;
  int v3;
  NSObject *v4;
  int v5;
  int v6;
  const char *v7;
  __int16 v8;
  int v9;
  __int16 v10;
  int v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 4565))
    return 0;
  v1 = db_rwlock_unlock_unknown(a1);
  if ((_DWORD)v1)
  {
    v3 = *__error();
    v4 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = v1;
      if ((_DWORD)v1 == -1)
        v5 = *__error();
      v6 = 136315650;
      v7 = "_data_map64_unlock";
      v8 = 1024;
      v9 = 283;
      v10 = 1024;
      v11 = v5;
      _os_log_error_impl(&dword_1B8270000, v4, OS_LOG_TYPE_ERROR, "%s:%d: _data_map64_unlock error %d", (uint8_t *)&v6, 0x18u);
    }
    *__error() = v3;
  }
  return v1;
}

uint64_t data_map64_init_with_ctx(uint64_t a1)
{
  int v2;
  const char *v3;
  unsigned int v4;
  unsigned int v5;
  _BYTE *v6;
  _BYTE *v7;
  uint64_t v8;
  int v9;
  int v10;
  unsigned int v11;
  int v12;
  unint64_t v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  void (*v18)(_QWORD);
  int v19;
  NSObject *v20;
  size_t v21;
  int v22;
  _QWORD *v23;
  char *v24;
  char *v25;
  blkcnt_t v26;
  int v27;
  NSObject *v28;
  char *v29;
  char *v30;
  char *v31;
  int v32;
  NSObject *v33;
  char v34;
  uint64_t v35;
  uint64_t v36;
  void (*v37)(_QWORD);
  int v38;
  NSObject *v39;
  os_log_type_t v40;
  char *v41;
  uint64_t v42;
  int v44;
  NSObject *v45;
  uint64_t v46;
  _QWORD *v47;
  _QWORD *v48;
  unsigned int v49;
  NSObject *v50;
  uint64_t v51;
  const char *v52;
  uint32_t v53;
  char *v54;
  uint64_t *v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v58;
  unint64_t v59;
  uint64_t v60;
  unint64_t v61;
  uint64_t v62;
  _QWORD *v63;
  unint64_t *v64;
  BOOL v65;
  void *v66;
  int v67;
  const char *v68;
  const char *v69;
  const char *v70;
  char *sibling_with_suffix_protected;
  char *v72;
  int v73;
  uint64_t v74;
  NSObject *v75;
  NSObject *v76;
  _BOOL4 v77;
  uint64_t v78;
  const char *v79;
  NSObject *v80;
  uint64_t v81;
  uint64_t v82;
  int v83;
  NSObject *v84;
  uint64_t v85;
  uint64_t v86;
  unint64_t v87;
  unint64_t v88;
  uint64_t v89;
  unint64_t v90;
  _QWORD *v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  unint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  unsigned int v101;
  int v102;
  int v103;
  uint64_t v104;
  unint64_t v105;
  int v106;
  int v107;
  int v108;
  int v109;
  int v110;
  char v111;
  char *v112;
  unsigned int v113;
  unsigned int v114;
  int v115;
  int v116;
  unsigned int v117;
  unsigned int v118;
  unsigned int v119;
  unsigned int v120;
  uint8_t buf[4];
  blkcnt_t v122;
  __int16 v123;
  off_t st_size;
  __int16 v125;
  char *v126;
  uint8_t v127[48];
  __int128 v128;
  __int128 v129;
  __int128 v130;
  __int128 v131;
  __int128 v132;
  __int128 v133;
  __int128 v134;
  __int128 v135;
  __int128 v136;
  __int128 v137;
  __int128 v138;
  __int128 v139;
  __int128 v140;
  stat v141;
  char __str[1024];
  uint64_t v143;

  v143 = *MEMORY[0x1E0C80C00];
  v2 = *(_DWORD *)a1;
  v3 = *(const char **)(a1 + 8);
  v5 = *(_DWORD *)(a1 + 16);
  v4 = *(_DWORD *)(a1 + 20);
  bzero(__str, 0x400uLL);
  v6 = malloc_type_calloc(1uLL, 0x11E0uLL, 0x10A00400753BC05uLL);
  v7 = v6;
  v8 = (uint64_t)v6;
  v6[4565] = (v4 & 8) != 0;
  v112 = v6 + 4488;
  v9 = (v4 >> 2) & 1;
  v107 = v4 & 2;
  *((_DWORD *)v6 + 54) = 1684300900;
  if ((v4 & 8) == 0)
  {
    *((_QWORD *)v6 + 26) = 0;
    *((_OWORD *)v6 + 11) = 0u;
    *((_OWORD *)v6 + 12) = 0u;
    *((_OWORD *)v6 + 9) = 0u;
    *((_OWORD *)v6 + 10) = 0u;
    *((_OWORD *)v6 + 7) = 0u;
    *((_OWORD *)v6 + 8) = 0u;
    *((_OWORD *)v6 + 5) = 0u;
    *((_OWORD *)v6 + 6) = 0u;
    *((_OWORD *)v6 + 3) = 0u;
    *((_OWORD *)v6 + 4) = 0u;
    *((_OWORD *)v6 + 1) = 0u;
    *((_OWORD *)v6 + 2) = 0u;
    *(_OWORD *)v6 = 0u;
    pthread_mutex_init((pthread_mutex_t *)v6, 0);
    v9 = (v4 >> 2) & 1;
  }
  v109 = v2;
  v113 = v5;
  v114 = v5;
  v110 = v9;
  v111 = v4;
  v10 = v9;
  *(_QWORD *)(v8 + 224) = -1;
  *(_QWORD *)(v8 + 4440) = -1;
  *(_QWORD *)(v8 + 4480) = -1;
  *(_DWORD *)(v8 + 296) = 0;
  *(_QWORD *)(v8 + 272) = 0;
  *(_QWORD *)(v8 + 280) = 0;
  *(_QWORD *)(v8 + 264) = 0;
  *(_QWORD *)(v8 + 4528) = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(v8 + 4536) = *(_QWORD *)(a1 + 40);
  *(_DWORD *)(v8 + 4544) = 0;
  v112[76] = (v4 & 0xFFFFFF) != 0;
  makeThreadId();
  do
  {
    v11 = __ldxr(exceptionSequenceNum);
    v12 = v11 + 1;
  }
  while (__stxr(v11 + 1, exceptionSequenceNum));
  v13 = setThreadIdAndInfo(-1, sDataMapExceptionCallbacks, v8, 0, v12);
  v119 = HIDWORD(v13);
  v120 = v13;
  v117 = v15;
  v118 = v14;
  v16 = *(_QWORD *)&threadData[18 * v13 + 2];
  v17 = v16 + 320 * HIDWORD(v13);
  v115 = *(_DWORD *)(v17 + 312);
  v18 = *(void (**)(_QWORD))(v17 + 224);
  if (v18)
    v18(*(_QWORD *)(v16 + 320 * HIDWORD(v13) + 288));
  if (_setjmp((int *)v17))
  {
    v19 = *__error();
    v20 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v127 = 136315394;
      *(_QWORD *)&v127[4] = "data_map64_init_with_ctx";
      *(_WORD *)&v127[12] = 1024;
      *(_DWORD *)&v127[14] = 1316;
      _os_log_error_impl(&dword_1B8270000, v20, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", v127, 0x12u);
    }
    *__error() = v19;
    *(_DWORD *)(v17 + 312) = v115;
    CIOnThreadCleanUpReset(v117);
    dropThreadId(v120, 1, v12);
    CICleanUpReset(v120, v118);
    v44 = *__error();
    v45 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
    {
      v68 = fd_realpath(*(_DWORD **)(v8 + 240), __str);
      *(_QWORD *)&v127[4] = "data_map64_init_with_ctx";
      v69 = "";
      *(_DWORD *)v127 = 136315650;
      if (v68)
        v69 = v68;
      *(_WORD *)&v127[12] = 1024;
      *(_DWORD *)&v127[14] = 1318;
      *(_WORD *)&v127[18] = 2080;
      *(_QWORD *)&v127[20] = v69;
      _os_log_error_impl(&dword_1B8270000, v45, OS_LOG_TYPE_ERROR, "%s:%d: exception processing %s", v127, 0x1Cu);
    }
    *__error() = v44;
LABEL_39:
    data_map64_destroy(v8);
    return 0;
  }
  v116 = v12;
  if (!v3 || (v21 = strlen(v3), v2 == -1) || !v21 || v21 >= 0xF1)
  {
    v32 = *__error();
    v33 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
      goto LABEL_29;
    *(_DWORD *)v127 = 136315394;
    *(_QWORD *)&v127[4] = "data_map64_init_with_ctx";
    *(_WORD *)&v127[12] = 1024;
    *(_DWORD *)&v127[14] = 947;
    v70 = "%s:%d: param error";
    goto LABEL_62;
  }
  v108 = v10;
  if ((v4 & 2) != 0)
    v22 = 0;
  else
    v22 = ((v4 & 1) << 10) | 0x20000202;
  v106 = v22;
  snprintf(__str, 0x400uLL, "%s.header", v3);
  v23 = fd_create_protected(v2, __str, v22, 3u);
  *(_QWORD *)(v8 + 240) = v23;
  *(_QWORD *)(v8 + 256) = fd_lseek(v23, 0, 2);
  snprintf(__str, 0x400uLL, "%s.data", v3);
  v24 = (char *)fd_create_protected(v2, __str, v22, 0);
  v25 = v24;
  if ((v4 & 3) != 0
    || (memset(&v141, 0, sizeof(v141)), fd_stat((uint64_t)v24, &v141))
    || (v26 = v141.st_blocks << 9, v141.st_blocks << 9 <= v141.st_size + 0x400000))
  {
    v30 = v25;
  }
  else
  {
    bzero(v127, 0x400uLL);
    v27 = *__error();
    v28 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134218498;
      v122 = v26;
      v123 = 2048;
      st_size = v141.st_size;
      v125 = 2080;
      v126 = __str;
      _os_log_impl(&dword_1B8270000, v28, OS_LOG_TYPE_DEFAULT, "found allocated size %lld for %lld %s", buf, 0x20u);
    }
    *__error() = v27;
    snprintf((char *)v127, 0x400uLL, "tmp.%s.data.1", v3);
    v29 = (char *)fd_create_protected(v2, (const char *)v127, 1538, 0);
    if (fd_copyfile((uint64_t)v25, (uint64_t)v29, 0)
      || (snprintf((char *)v127, 0x400uLL, "tmp.%s.data.2", v3),
          fd_rename((uint64_t)v25, (const char *)v127))
      || fd_rename((uint64_t)v29, __str))
    {
      v30 = v25;
      v31 = v29;
    }
    else
    {
      _fd_unlink_with_origin((uint64_t)v25, 0);
      fd_release(v25);
      v31 = 0;
      v30 = v29;
    }
    _fd_unlink_with_origin((uint64_t)v31, 0);
    fd_release(v31);
  }
  v46 = fd_lseek(v30, 0, 2);
  *(_BYTE *)(v8 + 300) = (v4 & 2) >> 1;
  *(_QWORD *)(v8 + 272) = v30;
  *(_QWORD *)(v8 + 280) = v46;
  *(_DWORD *)(v8 + 296) = 1;
  *(_BYTE *)(v8 + 301) = 1;
  *(_QWORD *)(v8 + 304) = 0;
  *(_BYTE *)(v8 + 312) = 26;
  bzero(v7 + 320, 0x1000uLL);
  snprintf(__str, 0x400uLL, "%s.offsets", v3);
  v47 = fd_create_protected(v109, __str, v106, 3u);
  *(_QWORD *)(v8 + 4416) = v47;
  *(_QWORD *)(v8 + 4432) = fd_lseek(v47, 0, 2);
  snprintf(__str, 0x400uLL, "%s.buckets", v3);
  v48 = fd_create_protected(v109, __str, 514, 3u);
  *(_QWORD *)(v8 + 4456) = v48;
  *(_QWORD *)(v8 + 4464) = fd_lseek(v48, 0, 2);
  if ((v4 & 1) != 0)
  {
    v49 = v114;
    if (fd_truncate(*(_QWORD *)(v8 + 240), 92) == -1)
    {
      v32 = *__error();
      v50 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
        goto LABEL_29;
      *(_DWORD *)v127 = 136315394;
      *(_QWORD *)&v127[4] = "data_map64_init_with_ctx";
      *(_WORD *)&v127[12] = 1024;
      *(_DWORD *)&v127[14] = 1080;
      v52 = "%s:%d: fd_truncate error";
    }
    else
    {
      v54 = (char *)malloc_type_calloc(1uLL, 0x5CuLL, 0x100004034A301B9uLL);
      *(_QWORD *)(v8 + 264) = v54;
      if (v54)
      {
        *(_QWORD *)(v8 + 256) = 92;
        *(_QWORD *)v54 = 0x446174615064;
        *((_DWORD *)v54 + 2) = 14;
        *(_QWORD *)(v54 + 12) = v113;
        *(_QWORD *)(v54 + 20) = 0;
        v55 = (uint64_t *)MEMORY[0x1E0C85AD8];
        if ((_storageWindowsSetFileSize((_DWORD **)v7 + 34, *MEMORY[0x1E0C85AD8]) & 1) != 0)
        {
          if (fd_truncate(*(_QWORD *)(v8 + 4416), *v55 & 0xFFFFFFFFFFFFFFF0) == -1)
          {
            v32 = *__error();
            v50 = _SILogForLogForCategory(0);
            if (!os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
              goto LABEL_29;
            *(_DWORD *)v127 = 136315394;
            *(_QWORD *)&v127[4] = "data_map64_init_with_ctx";
            *(_WORD *)&v127[12] = 1024;
            *(_DWORD *)&v127[14] = 1107;
            v52 = "%s:%d: fd_truncate error";
          }
          else
          {
            v56 = fd_mmap(*(_QWORD *)(v8 + 4416));
            *(_QWORD *)(v8 + 4440) = v56;
            if (v56 == -1)
            {
              v32 = *__error();
              v50 = _SILogForLogForCategory(0);
              if (!os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
                goto LABEL_29;
              *(_DWORD *)v127 = 136315394;
              *(_QWORD *)&v127[4] = "data_map64_init_with_ctx";
              *(_WORD *)&v127[12] = 1024;
              *(_DWORD *)&v127[14] = 1112;
              v52 = "%s:%d: offsets fd_mmap error";
            }
            else
            {
              *(_QWORD *)(v8 + 4424) = 0x100000;
              v57 = *v55;
              v58 = (unint64_t)*v55 >> 4;
              *(_QWORD *)(v8 + 4432) = *v55 & 0xFFFFFFFFFFFFFFF0;
              *(_QWORD *)(v8 + 4448) = v58;
              v59 = v57 & 0xFFFFFFFFFFFFFFF8;
              if (fd_truncate(*(_QWORD *)(v8 + 4456), v57 & 0xFFFFFFFFFFFFFFF8) == -1)
              {
                v32 = *__error();
                v50 = _SILogForLogForCategory(0);
                if (!os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
                  goto LABEL_29;
                *(_DWORD *)v127 = 136315394;
                *(_QWORD *)&v127[4] = "data_map64_init_with_ctx";
                *(_WORD *)&v127[12] = 1024;
                *(_DWORD *)&v127[14] = 1122;
                v52 = "%s:%d: fd_truncate error";
              }
              else
              {
                v60 = fd_mmap(*(_QWORD *)(v8 + 4456));
                *(_QWORD *)(v8 + 4480) = v60;
                if (v60 != -1)
                {
                  *(_QWORD *)(v8 + 4472) = 0x100000;
                  *(_QWORD *)(v8 + 4464) = v59;
                  v61 = (unint64_t)*v55 >> 3;
                  *(_QWORD *)(*(_QWORD *)(v8 + 264) + 28) = v61;
                  *(_QWORD *)(v8 + 4488) = v61;
                  data_entry_store((uint64_t)(v7 + 272), dword_1E6E38348);
                  v62 = *(_QWORD *)(v8 + 264);
                  *(_QWORD *)(v62 + 20) = *(_QWORD *)(v8 + 288);
                  v63 = *(_QWORD **)(v8 + 4440);
                  *v63 = 0;
                  v63[1] = 0;
                  *(_QWORD *)(v62 + 36) = 1;
                  v64 = (unint64_t *)(v7 + 4496);
                  v65 = 0;
                  goto LABEL_121;
                }
                v32 = *__error();
                v50 = _SILogForLogForCategory(0);
                if (!os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
                  goto LABEL_29;
                *(_DWORD *)v127 = 136315394;
                *(_QWORD *)&v127[4] = "data_map64_init_with_ctx";
                *(_WORD *)&v127[12] = 1024;
                *(_DWORD *)&v127[14] = 1128;
                v52 = "%s:%d: hash fd_mmap error";
              }
            }
          }
        }
        else
        {
          v32 = *__error();
          v50 = _SILogForLogForCategory(0);
          if (!os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
            goto LABEL_29;
          *(_DWORD *)v127 = 136315394;
          *(_QWORD *)&v127[4] = "data_map64_init_with_ctx";
          *(_WORD *)&v127[12] = 1024;
          *(_DWORD *)&v127[14] = 1101;
          v52 = "%s:%d: fd_truncate error";
        }
      }
      else
      {
        v32 = *__error();
        v50 = _SILogForLogForCategory(0);
        if (!os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
          goto LABEL_29;
        *(_DWORD *)v127 = 136315394;
        *(_QWORD *)&v127[4] = "data_map64_init_with_ctx";
        *(_WORD *)&v127[12] = 1024;
        *(_DWORD *)&v127[14] = 1088;
        v52 = "%s:%d: offset fd_mmap error";
      }
    }
LABEL_131:
    v53 = 18;
    goto LABEL_132;
  }
  v49 = v114;
  if (*(_QWORD *)(v8 + 256) <= 0x5BuLL)
  {
    v32 = *__error();
    v50 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
    {
      v51 = *(_QWORD *)(v8 + 256);
      *(_DWORD *)v127 = 136315650;
      *(_QWORD *)&v127[4] = "data_map64_init_with_ctx";
      *(_WORD *)&v127[12] = 1024;
      *(_DWORD *)&v127[14] = 1152;
      *(_WORD *)&v127[18] = 2048;
      *(_QWORD *)&v127[20] = v51;
      v52 = "%s:%d: invalid header size %ld";
      v53 = 28;
LABEL_132:
      v80 = v50;
      goto LABEL_133;
    }
    goto LABEL_29;
  }
  v66 = malloc_type_calloc(1uLL, 0x5CuLL, 0x100004034A301B9uLL);
  *(_QWORD *)(v8 + 264) = v66;
  if (!v66)
  {
    v32 = *__error();
    v50 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
      goto LABEL_29;
    *(_DWORD *)v127 = 136315394;
    *(_QWORD *)&v127[4] = "data_map64_init_with_ctx";
    *(_WORD *)&v127[12] = 1024;
    *(_DWORD *)&v127[14] = 1159;
    v52 = "%s:%d: header calloc error";
    goto LABEL_131;
  }
  if ((v4 & 0x80) != 0)
  {
    sibling_with_suffix_protected = (char *)fd_create_sibling_with_suffix_protected(*(_QWORD *)(v8 + 240), ".shadow", v106);
    if (sibling_with_suffix_protected)
    {
      v72 = sibling_with_suffix_protected;
      v73 = fd_copyfile((uint64_t)sibling_with_suffix_protected, *(_QWORD *)(v8 + 240), 0);
      v65 = v73 == 0;
      if (v73)
        v67 = v110;
      else
        v67 = 0;
      fd_release(v72);
    }
    else
    {
      v65 = 0;
      v67 = v108;
    }
  }
  else
  {
    v67 = v4 & 4;
    v65 = 0;
  }
  v74 = fd_pread(*(_DWORD **)(v8 + 240), *(void **)(v8 + 264), 0x5CuLL, 0);
  v32 = *__error();
  v75 = _SILogForLogForCategory(0);
  v76 = v75;
  if (v74 != 92)
  {
    if (os_log_type_enabled(v75, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v127 = 136315394;
      *(_QWORD *)&v127[4] = "data_map64_init_with_ctx";
      *(_WORD *)&v127[12] = 1024;
      *(_DWORD *)&v127[14] = 1177;
      v52 = "%s:%d: header pread error";
      v53 = 18;
      v80 = v76;
LABEL_133:
      _os_log_error_impl(&dword_1B8270000, v80, OS_LOG_TYPE_ERROR, v52, v127, v53);
      goto LABEL_29;
    }
    goto LABEL_29;
  }
  v77 = os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT);
  if (v111 < 0)
  {
    if (!v77)
      goto LABEL_86;
    v81 = *(_QWORD *)(*(_QWORD *)(v8 + 264) + 36);
    *(_DWORD *)v127 = 134217984;
    *(_QWORD *)&v127[4] = v81;
    v79 = "recovered next_id: %llu";
  }
  else
  {
    if (!v77)
      goto LABEL_86;
    v78 = *(_QWORD *)(*(_QWORD *)(v8 + 264) + 36);
    *(_DWORD *)v127 = 134217984;
    *(_QWORD *)&v127[4] = v78;
    v79 = "opened next_id: %llu";
  }
  _os_log_impl(&dword_1B8270000, v76, OS_LOG_TYPE_DEFAULT, v79, v127, 0xCu);
LABEL_86:
  *__error() = v32;
  v82 = *(_QWORD *)(v8 + 264);
  v64 = (unint64_t *)(v7 + 4496);
  *(_QWORD *)(v8 + 288) = *(_QWORD *)(v82 + 20);
  *(_QWORD *)(v8 + 4448) = *(_QWORD *)(v8 + 4432) >> 4;
  *(_OWORD *)v112 = *(_OWORD *)(v82 + 28);
  *((_OWORD *)v112 + 1) = *(_OWORD *)(v82 + 68);
  *(_QWORD *)(v8 + 4520) = *(_QWORD *)(v82 + 84);
  if (v67)
  {
    v83 = *__error();
    v84 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v84, OS_LOG_TYPE_DEFAULT))
    {
      v85 = *(_QWORD *)(*(_QWORD *)(v8 + 264) + 60);
      *(_DWORD *)v127 = 134217984;
      *(_QWORD *)&v127[4] = v85;
      _os_log_impl(&dword_1B8270000, v84, OS_LOG_TYPE_DEFAULT, "use_shadow next_id: %llu", v127, 0xCu);
    }
    *__error() = v83;
    v86 = *(_QWORD *)(v8 + 264);
    v87 = *(_QWORD *)(v86 + 20);
    v88 = *(_QWORD *)(v86 + 44);
    if (v87 < v88)
      goto LABEL_30;
    v89 = *(_QWORD *)(v86 + 44);
    if (v88 != v87)
    {
      if (!v107)
        *(_QWORD *)(v86 + 20) = v88;
      *(_QWORD *)(v8 + 288) = v88;
    }
    v90 = *(_QWORD *)(v86 + 60);
    if (*v64 < v90)
      goto LABEL_30;
    if (*v64 != v90)
    {
      if (!v107)
      {
        *(_QWORD *)(v86 + 36) = v90;
        *(_QWORD *)(v86 + 20) = v89;
        *(_QWORD *)(v86 + 28) = 0;
      }
      *v64 = v90;
      *(_QWORD *)v112 = 0;
    }
  }
  v91 = (_QWORD *)MEMORY[0x1E0C85AD8];
  if (((unint64_t)(*(_QWORD *)(v8 + 4432) + *MEMORY[0x1E0C85AD8] - 1) & -*MEMORY[0x1E0C85AD8]) <= 0x100000)
    v92 = 0x100000;
  else
    v92 = (*(_QWORD *)(v8 + 4432) + *MEMORY[0x1E0C85AD8] - 1) & -*MEMORY[0x1E0C85AD8];
  v93 = fd_mmap(*(_QWORD *)(v8 + 4416));
  *(_QWORD *)(v8 + 4440) = v93;
  if (v93 == -1)
  {
    v32 = *__error();
    v50 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
      goto LABEL_29;
    *(_DWORD *)v127 = 136315394;
    *(_QWORD *)&v127[4] = "data_map64_init_with_ctx";
    *(_WORD *)&v127[12] = 1024;
    *(_DWORD *)&v127[14] = 1232;
    v52 = "%s:%d: offset fd_mmap error";
    goto LABEL_131;
  }
  *(_QWORD *)(v8 + 4424) = v92;
  if (((unint64_t)(*(_QWORD *)(v8 + 4464) + *v91 - 1) & -*v91) <= 0x100000)
    v94 = 0x100000;
  else
    v94 = (*(_QWORD *)(v8 + 4464) + *v91 - 1) & -*v91;
  v95 = fd_mmap(*(_QWORD *)(v8 + 4456));
  *(_QWORD *)(v8 + 4480) = v95;
  if (v95 == -1)
  {
    v32 = *__error();
    v50 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
      goto LABEL_29;
    *(_DWORD *)v127 = 136315394;
    *(_QWORD *)&v127[4] = "data_map64_init_with_ctx";
    *(_WORD *)&v127[12] = 1024;
    *(_DWORD *)&v127[14] = 1241;
    v52 = "%s:%d: offset fd_mmap error";
    goto LABEL_131;
  }
  *(_QWORD *)(v8 + 4472) = v94;
  v96 = *(_QWORD *)(v8 + 264);
  if (*(_QWORD *)(v96 + 36))
  {
    v97 = *v64;
    goto LABEL_122;
  }
  *(_QWORD *)(v96 + 36) = 1;
LABEL_121:
  v97 = 1;
  *v64 = 1;
LABEL_122:
  if (*(_QWORD *)(v8 + 4448) < v97)
  {
    v32 = *__error();
    v50 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
    {
      v98 = *(_QWORD *)(v8 + 4448);
      v99 = *(_QWORD *)(v8 + 4496);
      *(_DWORD *)v127 = 136315906;
      *(_QWORD *)&v127[4] = "data_map64_init_with_ctx";
      *(_WORD *)&v127[12] = 1024;
      *(_DWORD *)&v127[14] = 1262;
      *(_WORD *)&v127[18] = 2048;
      *(_QWORD *)&v127[20] = v98;
      *(_WORD *)&v127[28] = 2048;
      *(_QWORD *)&v127[30] = v99;
      v52 = "%s:%d: invalid offset size 1 - %lld %lld";
      v53 = 38;
      goto LABEL_132;
    }
LABEL_29:
    *__error() = v32;
LABEL_30:
    v34 = 0;
    goto LABEL_31;
  }
  v100 = *(_QWORD *)(v8 + 264);
  if (*(_QWORD *)v100 != 0x446174615064)
  {
    v32 = *__error();
    v50 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
      goto LABEL_29;
    *(_DWORD *)v127 = 136315394;
    *(_QWORD *)&v127[4] = "data_map64_init_with_ctx";
    *(_WORD *)&v127[12] = 1024;
    *(_DWORD *)&v127[14] = 1266;
    v52 = "%s:%d: invalid offset signature";
    goto LABEL_131;
  }
  v101 = *(_DWORD *)(v100 + 8);
  if (v101 <= 0xD)
  {
    v32 = *__error();
    v50 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v127 = 136315650;
      *(_QWORD *)&v127[4] = "data_map64_init_with_ctx";
      *(_WORD *)&v127[12] = 1024;
      *(_DWORD *)&v127[14] = 1272;
      *(_WORD *)&v127[18] = 1024;
      *(_DWORD *)&v127[20] = v101;
      v52 = "%s:%d: invalid version %d";
      v53 = 24;
      goto LABEL_132;
    }
    goto LABEL_29;
  }
  v102 = *(_DWORD *)(v100 + 12);
  if (v102 != v49 && v102)
  {
    v32 = *__error();
    v50 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
      goto LABEL_29;
    v103 = *(_DWORD *)(*(_QWORD *)(v8 + 264) + 12);
    *(_DWORD *)v127 = 136315906;
    *(_QWORD *)&v127[4] = "data_map64_init_with_ctx";
    *(_WORD *)&v127[12] = 1024;
    *(_DWORD *)&v127[14] = 1277;
    *(_WORD *)&v127[18] = 1024;
    *(_DWORD *)&v127[20] = v103;
    *(_WORD *)&v127[24] = 1024;
    *(_DWORD *)&v127[26] = v113;
    v52 = "%s:%d: invalid extra_size %d %d";
    v53 = 30;
    goto LABEL_132;
  }
  *(_DWORD *)(v8 + 220) = v113;
  if (*(_QWORD *)(v8 + 256) <= 0x5BuLL)
  {
    v32 = *__error();
    v50 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
      goto LABEL_29;
    *(_DWORD *)v127 = 136315394;
    *(_QWORD *)&v127[4] = "data_map64_init_with_ctx";
    *(_WORD *)&v127[12] = 1024;
    *(_DWORD *)&v127[14] = 1285;
    v52 = "%s:%d: invalid header size";
    goto LABEL_131;
  }
  if (*(_QWORD *)(v8 + 280) < *(_QWORD *)(v8 + 288))
  {
    v32 = *__error();
    v33 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
      goto LABEL_29;
    *(_DWORD *)v127 = 136315394;
    *(_QWORD *)&v127[4] = "data_map64_init_with_ctx";
    *(_WORD *)&v127[12] = 1024;
    *(_DWORD *)&v127[14] = 1290;
    v70 = "%s:%d: invalid storage size 1";
    goto LABEL_62;
  }
  if (v65
    || !*(_DWORD *)(v100 + 16)
    || (v104 = *(_QWORD *)(v8 + 4488)) == 0
    || (v105 = *(_QWORD *)(v8 + 4464), v105 < 8 * v104))
  {
    if (_data_map64_rehash(v8))
    {
      v105 = *(_QWORD *)(v8 + 4464);
      v104 = *(_QWORD *)(v8 + 4488);
      goto LABEL_151;
    }
    v32 = *__error();
    v33 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
      goto LABEL_29;
    *(_DWORD *)v127 = 136315394;
    *(_QWORD *)&v127[4] = "data_map64_init_with_ctx";
    *(_WORD *)&v127[12] = 1024;
    *(_DWORD *)&v127[14] = 1297;
    v70 = "%s:%d: re-build hash error";
LABEL_62:
    _os_log_error_impl(&dword_1B8270000, v33, OS_LOG_TYPE_ERROR, v70, v127, 0x12u);
    goto LABEL_29;
  }
LABEL_151:
  if (v105 < 8 * v104)
  {
    v32 = *__error();
    v33 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
      goto LABEL_29;
    *(_DWORD *)v127 = 136315394;
    *(_QWORD *)&v127[4] = "data_map64_init_with_ctx";
    *(_WORD *)&v127[12] = 1024;
    *(_DWORD *)&v127[14] = 1304;
    v70 = "%s:%d: invalid hash size 1";
    goto LABEL_62;
  }
  v34 = 1;
LABEL_31:
  v35 = *(_QWORD *)&threadData[18 * v120 + 2];
  v36 = v35 + 320 * v119;
  *(_DWORD *)(v36 + 312) = v115;
  v37 = *(void (**)(_QWORD))(v36 + 232);
  if (v37)
    v37(*(_QWORD *)(v35 + 320 * v119 + 288));
  dropThreadId(v120, 0, v116);
  if ((v34 & 1) == 0)
    goto LABEL_39;
  v139 = 0u;
  v140 = 0u;
  v137 = 0u;
  v138 = 0u;
  v135 = 0u;
  v136 = 0u;
  v133 = 0u;
  v134 = 0u;
  v131 = 0u;
  v132 = 0u;
  v129 = 0u;
  v130 = 0u;
  v128 = 0u;
  memset(v127, 0, sizeof(v127));
  v38 = *__error();
  v39 = _SILogForLogForCategory(7);
  v40 = 2 * (dword_1EF19FCA8 < 4);
  if (os_log_type_enabled(v39, v40))
  {
    v41 = fd_name(*(_QWORD *)(v8 + 240), (char *)v127, 0x100uLL);
    v42 = *(_QWORD *)(v8 + 4496) - 1;
    v141.st_dev = 136315394;
    *(_QWORD *)&v141.st_mode = v41;
    WORD2(v141.st_ino) = 2048;
    *(__darwin_ino64_t *)((char *)&v141.st_ino + 6) = v42;
    _os_log_impl(&dword_1B8270000, v39, v40, "Opened map %s with counts: %lld", (uint8_t *)&v141, 0x16u);
  }
  *__error() = v38;
  return v8;
}

unint64_t data_entry_store(uint64_t a1, unsigned int *a2)
{
  unsigned int v3;
  int v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  _BYTE *v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;

  v3 = *a2;
  if ((*a2 & 0x3F80) != 0)
    v4 = 2;
  else
    v4 = 1;
  if ((v3 & 0x1FC000) != 0)
    v4 = 3;
  if ((v3 & 0xFE00000) != 0)
    v4 = 4;
  if (*a2 >> 28)
    v5 = 5;
  else
    v5 = v4;
  v6 = v5 + v3;
  v7 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v7 + v6;
  v8 = (_BYTE *)_windowsResolvePtr(a1, v7, v6);
  v9 = *a2;
  v10 = *a2 >> 28;
  if (v10)
  {
    *v8 = v9 | 0x80;
    v8[1] = (v9 >> 7) | 0x80;
    v8[2] = (v9 >> 14) | 0x80;
    v8[3] = (v9 >> 21) | 0x80;
    v8[4] = v10;
    v11 = 5;
  }
  else if ((v9 & 0xFE00000) != 0)
  {
    *v8 = v9 | 0x80;
    v8[1] = (v9 >> 7) | 0x80;
    v8[2] = (v9 >> 14) | 0x80;
    v8[3] = (v9 & 0xFE00000) >> 21;
    v11 = 4;
  }
  else if ((v9 & 0x1FC000) != 0)
  {
    *v8 = v9 | 0x80;
    v8[1] = (v9 >> 7) | 0x80;
    v8[2] = (v9 & 0x1FC000) >> 14;
    v11 = 3;
  }
  else if ((v9 & 0x3F80) != 0)
  {
    *v8 = v9 | 0x80;
    v8[1] = (unsigned __int16)(v9 & 0x3F80) >> 7;
    v11 = 2;
  }
  else
  {
    *v8 = v9;
    v11 = 1;
  }
  memcpy(&v8[v11], *((const void **)a2 + 1), *a2);
  return v7;
}

uint64_t _data_map64_rehash(uint64_t a1)
{
  uint64_t v2;
  int v3;
  NSObject *v4;
  os_log_type_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  size_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t i;
  uint64_t v18;
  _QWORD *bucket_entry;
  uint64_t result;
  int v21;
  NSObject *v22;
  int *v23;
  int v24;
  const char *v25;
  __int16 v26;
  _BYTE v27[18];
  __int16 v28;
  uint64_t v29;
  __int16 v30;
  uint64_t v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)(a1 + 4512) = 0;
  v2 = *(_QWORD *)(a1 + 4496) - *(_QWORD *)(a1 + 4504);
  v3 = *__error();
  v4 = _SILogForLogForCategory(0);
  v5 = 2 * (gSILogLevels[0] < 4);
  if (os_log_type_enabled(v4, v5))
  {
    v6 = *(_QWORD *)(a1 + 4496);
    v7 = *(_QWORD *)(a1 + 4504);
    v8 = *(_QWORD *)(a1 + 4488);
    v24 = 134219008;
    v25 = (const char *)a1;
    v26 = 2048;
    *(_QWORD *)v27 = v6;
    *(_WORD *)&v27[8] = 2048;
    *(_QWORD *)&v27[10] = v7;
    v28 = 2048;
    v29 = v2;
    v30 = 2048;
    v31 = v8;
    _os_log_impl(&dword_1B8270000, v4, v5, "rehash %p max id: %lld deletes: %lld count: %lld hash_size: %lld", (uint8_t *)&v24, 0x34u);
  }
  *__error() = v3;
  msync(*(void **)(a1 + 4480), 8 * *(_QWORD *)(a1 + 4488), 4);
  if (fd_truncate(*(_QWORD *)(a1 + 4456), 0) == -1)
    goto LABEL_22;
  v9 = 2 * v2;
  if ((unint64_t)(2 * v2) <= *MEMORY[0x1E0C85AD8] >> 3)
    v9 = *MEMORY[0x1E0C85AD8] >> 3;
  *(_QWORD *)(a1 + 4488) = v9;
  v10 = 8 * v9;
  if (fd_truncate(*(_QWORD *)(a1 + 4456), 8 * v9) == -1)
    goto LABEL_22;
  if (!*(_BYTE *)(a1 + 4562))
  {
    _data_map64_dirty(a1);
    *(_BYTE *)(a1 + 4562) = 1;
  }
  *(_QWORD *)(a1 + 4464) = v10;
  v11 = *(_QWORD *)(a1 + 4472);
  if (v10 <= v11)
    goto LABEL_14;
  v12 = *(_QWORD *)(a1 + 4472);
  do
  {
    v13 = v12;
    v12 *= 2;
  }
  while (v13 < v10);
  munmap(*(void **)(a1 + 4480), v11);
  *(_QWORD *)(a1 + 4472) = 0;
  *(_QWORD *)(a1 + 4480) = -1;
  v14 = fd_mmap(*(_QWORD *)(a1 + 4456));
  *(_QWORD *)(a1 + 4480) = v14;
  if (v14 == -1)
  {
LABEL_22:
    v21 = *__error();
    v22 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      v24 = 136315650;
      v25 = "_data_map64_rehash";
      v26 = 1024;
      *(_DWORD *)v27 = 559;
      *(_WORD *)&v27[4] = 2048;
      *(_QWORD *)&v27[6] = a1;
      _os_log_error_impl(&dword_1B8270000, v22, OS_LOG_TYPE_ERROR, "%s:%d: re-build hash error %p", (uint8_t *)&v24, 0x1Cu);
    }
    v23 = __error();
    result = 0;
    *v23 = v21;
    return result;
  }
  *(_QWORD *)(a1 + 4472) = v13;
LABEL_14:
  v15 = *(_QWORD *)(a1 + 4496);
  if (v15 >= 2)
  {
    v16 = 0;
    for (i = 1; i < v15; ++i)
    {
      v18 = *(_QWORD *)(a1 + 4440) + v16;
      if (*(_QWORD *)(v18 + 16) != 1)
      {
        bucket_entry = (_QWORD *)_data_map64_get_bucket_entry((uint64_t *)a1, *(_QWORD *)(v18 + 24), i, 0, 0);
        if (!bucket_entry || *bucket_entry)
          goto LABEL_22;
        *bucket_entry = i;
        v15 = *(_QWORD *)(a1 + 4496);
      }
      v16 += 16;
    }
  }
  return 1;
}

void data_map64_destroy(uint64_t a1)
{
  _BYTE *v2;
  unsigned int v3;
  int v4;
  unint64_t v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  void (*v11)(_QWORD);
  _DWORD *v12;
  int v13;
  NSObject *v14;
  unsigned int v15;
  int v16;
  unint64_t v17;
  unsigned int v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  void (*v23)(_QWORD);
  _DWORD *v24;
  int v25;
  NSObject *v26;
  size_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  uint64_t *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  void (*v37)(_QWORD);
  void *v38;
  char *v39;
  uint64_t *v40;
  uint64_t v41;
  uint64_t v42;
  void *v43;
  void *v44;
  size_t v45;
  uint64_t v46;
  uint64_t v47;
  void (*v48)(_QWORD);
  size_t v49;
  char *v50;
  _QWORD *v51;
  const void *v52;
  unsigned int v53;
  unsigned int v54;
  unsigned int v55;
  unsigned int v56;
  unsigned int v57;
  unsigned int v58;
  unsigned int v59;
  unsigned int v60;
  char v61;
  uint8_t buf[4];
  const char *v63;
  __int16 v64;
  int v65;
  uint64_t v66;

  v66 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v2 = (_BYTE *)(a1 + 4561);
    makeThreadId();
    if ((unint64_t)(*(_QWORD *)(a1 + 224) + 1) > 1)
    {
      v61 = 0;
      do
      {
        v15 = __ldxr(exceptionSequenceNum);
        v16 = v15 + 1;
      }
      while (__stxr(v15 + 1, exceptionSequenceNum));
      v17 = setThreadIdAndInfo(-1, sDataMapExceptionCallbacks, a1, 0, v16);
      v58 = HIDWORD(v17);
      v60 = v17;
      v54 = v19;
      v56 = v18;
      v20 = *(_QWORD *)&threadData[18 * v17 + 2];
      v21 = v20 + 320 * HIDWORD(v17);
      v22 = *(_DWORD *)(v21 + 312);
      v23 = *(void (**)(_QWORD))(v21 + 224);
      if (v23)
        v23(*(_QWORD *)(v20 + 320 * HIDWORD(v17) + 288));
      if (_setjmp((int *)v21))
      {
        v24 = (_DWORD *)(v21 + 312);
        v25 = *__error();
        v26 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315394;
          v63 = "data_map64_destroy";
          v64 = 1024;
          v65 = 1743;
          _os_log_error_impl(&dword_1B8270000, v26, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
        }
        *__error() = v25;
        *v24 = v22;
        CIOnThreadCleanUpReset(v54);
        dropThreadId(v60, 1, v16);
        CICleanUpReset(v60, v56);
        v27 = 0;
      }
      else
      {
        v45 = *(_QWORD *)(*(_QWORD *)(a1 + 224) + 96);
        v61 = 1;
        v46 = *(_QWORD *)&threadData[18 * v60 + 2];
        v47 = v46 + 320 * v58;
        *(_DWORD *)(v47 + 312) = v22;
        v48 = *(void (**)(_QWORD))(v47 + 232);
        if (v48)
          v48(*(_QWORD *)(v46 + 320 * v58 + 288));
        dropThreadId(v60, 0, v16);
        v27 = v45;
      }
      v49 = v27;
      if (!v61)
        v49 = *(_QWORD *)(a1 + 232);
      munmap(*(void **)(a1 + 224), v49);
      *(_QWORD *)(a1 + 224) = -1;
      fd_release(*(char **)(a1 + 240));
      *(_QWORD *)(a1 + 240) = 0;
      v50 = *(char **)(a1 + 248);
      if (v50)
      {
        fd_release(v50);
        *(_QWORD *)(a1 + 248) = 0;
      }
    }
    else
    {
      do
      {
        v3 = __ldxr(exceptionSequenceNum);
        v4 = v3 + 1;
      }
      while (__stxr(v3 + 1, exceptionSequenceNum));
      v5 = setThreadIdAndInfo(-1, sDataMapExceptionCallbacks, a1, 0, v4);
      v57 = HIDWORD(v5);
      v59 = v5;
      v53 = v7;
      v55 = v6;
      v8 = *(_QWORD *)&threadData[18 * v5 + 2];
      v9 = v8 + 320 * HIDWORD(v5);
      v10 = *(_DWORD *)(v9 + 312);
      v11 = *(void (**)(_QWORD))(v9 + 224);
      if (v11)
        v11(*(_QWORD *)(v8 + 320 * HIDWORD(v5) + 288));
      if (_setjmp((int *)v9))
      {
        v12 = (_DWORD *)(v9 + 312);
        v13 = *__error();
        v14 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315394;
          v63 = "data_map64_destroy";
          v64 = 1024;
          v65 = 1796;
          _os_log_error_impl(&dword_1B8270000, v14, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
        }
        *__error() = v13;
        *v12 = v10;
        CIOnThreadCleanUpReset(v53);
        dropThreadId(v59, 1, v4);
        CICleanUpReset(v59, v55);
      }
      else
      {
        v28 = *(_QWORD *)(a1 + 264);
        if (v28 && !*(_DWORD *)(v28 + 16))
        {
          if (v2[1])
          {
            msync(*(void **)(a1 + 4480), 8 * *(_QWORD *)(a1 + 4488), 4);
            _fd_unlink_with_origin(*(_QWORD *)(a1 + 4456), 0);
            munmap(*(void **)(a1 + 4480), *(_QWORD *)(a1 + 4472));
            *(_QWORD *)(a1 + 4480) = -1;
          }
          if (*v2)
          {
            if (*(int *)(a1 + 296) >= 1)
            {
              v29 = 0;
              v30 = *(_DWORD *)(a1 + 296);
              do
              {
                v31 = *(_QWORD *)(a1 + 320 + 8 * v29);
                if (v31 && *(_QWORD *)(v31 + 8) && !*(_BYTE *)(v31 + 40))
                {
                  msync(*(void **)(v31 + 8), *(_QWORD *)(v31 + 24) - *(_QWORD *)(v31 + 16), 4);
                  v30 = *(_DWORD *)(a1 + 296);
                }
                ++v29;
              }
              while (v29 < v30);
              if (v30 >= 1)
              {
                v32 = (uint64_t *)(a1 + 320);
                v33 = 0;
                do
                {
                  v34 = v33;
                  storageWindowReleaseImmediate(v32);
                  v33 = v34 + 1;
                  ++v32;
                }
                while (v34 + 1 < *(int *)(a1 + 296));
              }
            }
            storageWindowsClose(a1 + 272);
            fd_truncate(*(_QWORD *)(a1 + 272), *(_QWORD *)(*(_QWORD *)(a1 + 264) + 20));
          }
          if (v2[2])
          {
            msync(*(void **)(a1 + 4440), 16 * *(_QWORD *)(a1 + 4496), 4);
            munmap(*(void **)(a1 + 4440), *(_QWORD *)(a1 + 4424));
            *(_QWORD *)(a1 + 4440) = -1;
            fd_truncate(*(_QWORD *)(a1 + 4416), 16 * *(_QWORD *)(a1 + 4496));
          }
        }
        v35 = *(_QWORD *)&threadData[18 * v59 + 2];
        v36 = v35 + 320 * v57;
        *(_DWORD *)(v36 + 312) = v10;
        v37 = *(void (**)(_QWORD))(v36 + 232);
        if (v37)
          v37(*(_QWORD *)(v35 + 320 * v57 + 288));
        dropThreadId(v59, 0, v4);
      }
      v38 = *(void **)(a1 + 264);
      if (v38)
      {
        free(v38);
        *(_QWORD *)(a1 + 264) = 0;
      }
      fd_release(*(char **)(a1 + 240));
      *(_QWORD *)(a1 + 240) = 0;
      v39 = *(char **)(a1 + 248);
      if (v39)
      {
        fd_release(v39);
        *(_QWORD *)(a1 + 248) = 0;
      }
      if (*(int *)(a1 + 296) >= 1)
      {
        v40 = (uint64_t *)(a1 + 320);
        v41 = 0;
        do
        {
          v42 = v41;
          storageWindowReleaseImmediate(v40);
          v41 = v42 + 1;
          ++v40;
        }
        while (v42 + 1 < *(int *)(a1 + 296));
      }
      storageWindowsClose(a1 + 272);
      v43 = *(void **)(a1 + 4440);
      if (v43 != (void *)-1)
      {
        munmap(v43, *(_QWORD *)(a1 + 4424));
        *(_QWORD *)(a1 + 4440) = -1;
        *(_QWORD *)(a1 + 4424) = 0;
      }
      fd_release(*(char **)(a1 + 4416));
      *(_QWORD *)(a1 + 4416) = 0;
      v44 = *(void **)(a1 + 4480);
      if (v44 != (void *)-1)
      {
        munmap(v44, *(_QWORD *)(a1 + 4472));
        *(_QWORD *)(a1 + 4480) = -1;
        *(_QWORD *)(a1 + 4472) = 0;
      }
      fd_release(*(char **)(a1 + 4456));
      *(_QWORD *)(a1 + 4456) = 0;
    }
    v51 = *(_QWORD **)(a1 + 4552);
    if (v51)
    {
      v52 = (const void *)v51[2];
      if (v52)
        CFRelease(v52);
      free(v51);
      *(_QWORD *)(a1 + 4552) = 0;
    }
    if (!v2[4])
      db_rwlock_destroy((pthread_mutex_t *)a1);
    free((void *)a1);
  }
}

uint64_t _data_map64_dirty(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *(_QWORD *)(result + 264);
  if (*(_DWORD *)(v1 + 16))
  {
    v2 = result;
    *(_DWORD *)(v1 + 16) = 0;
    fd_pwrite(*(_QWORD *)(result + 240), v1, 0x5CuLL, 0);
    return fd_sync(*(_QWORD *)(v2 + 240), 0);
  }
  return result;
}

uint64_t _data_map64_get_bucket_entry(uint64_t *a1, unint64_t a2, unint64_t a3, const void *a4, size_t a5)
{
  char v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  BOOL v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  int v19;
  NSObject *v20;
  char *v21;
  uint64_t v22;
  NSObject *v23;
  const char *v24;
  NSObject *v25;
  int v26;
  BOOL v27;
  char *v28;
  uint64_t result;
  int v30;
  NSObject *v31;
  int *v32;
  int v33;
  NSObject *v34;
  int *v35;
  uint64_t v36;
  char *v37;
  uint64_t v38;
  char *v39;
  uint64_t v40;
  uint64_t v43;
  unint64_t v44;
  char v45;
  uint64_t v46;
  void *__s2;
  char v48;
  uint8_t buf[4];
  const char *v50;
  __int16 v51;
  int v52;
  __int16 v53;
  unint64_t v54;
  __int16 v55;
  unint64_t v56;
  __int16 v57;
  uint64_t *v58;
  __int16 v59;
  char *v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  uint64_t v77;

  v77 = *MEMORY[0x1E0C80C00];
  if (a1[562] > a3)
  {
    v8 = 0;
    v9 = a1[561];
    v10 = a2 % v9;
    v43 = (uint64_t)(a1 + 34);
    v44 = v9;
    while (1)
    {
      v45 = v8;
      v11 = v10;
      if (v10 < v9)
        break;
      v27 = 0;
      v12 = v11;
LABEL_29:
      if (v27)
        return 0;
      v10 = 0;
      result = 0;
      v8 = 1;
      v9 = v11;
      if (v45 & 1 | (v12 != v44))
        return result;
    }
    v12 = v10;
    while (1)
    {
      v13 = a1[560];
      v14 = *(_QWORD *)(v13 + 8 * v12);
      if (v14)
        v15 = v14 == a3;
      else
        v15 = 1;
      if (v15)
        return v13 + 8 * v12;
      if (!a3)
      {
        if (a1[562] <= v14)
        {
          v75 = 0u;
          v76 = 0u;
          v73 = 0u;
          v74 = 0u;
          v71 = 0u;
          v72 = 0u;
          v69 = 0u;
          v70 = 0u;
          v67 = 0u;
          v68 = 0u;
          v65 = 0u;
          v66 = 0u;
          v64 = 0u;
          v62 = 0u;
          v63 = 0u;
          v61 = 0u;
          v33 = *__error();
          v34 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
          {
            v38 = a1[562];
            v39 = fd_name(a1[30], (char *)&v61, 0x100uLL);
            *(_DWORD *)buf = 136316418;
            v50 = "_data_map64_get_offset_entry";
            v51 = 1024;
            v52 = 362;
            v53 = 2048;
            v54 = v14;
            v55 = 2048;
            v56 = v38;
            v57 = 2048;
            v58 = a1;
            v59 = 2080;
            v60 = v39;
            _os_log_error_impl(&dword_1B8270000, v34, OS_LOG_TYPE_ERROR, "%s:%d: invalid data id %lld max %lld %p %s", buf, 0x3Au);
          }
          v35 = __error();
          result = 0;
          *v35 = v33;
          return result;
        }
        v16 = a1[555];
        if (!v16)
          return 0;
        v17 = *(_QWORD *)(v16 + 16 * v14);
        if (v17 == 1)
          return 0;
        if (*(_QWORD *)(v16 + 16 * v14 + 8) == a2)
        {
          v46 = 0;
          __s2 = 0;
          v48 = 0;
          v18 = a1[36];
          if (v18 <= v17)
          {
            v75 = 0u;
            v76 = 0u;
            v73 = 0u;
            v74 = 0u;
            v71 = 0u;
            v72 = 0u;
            v69 = 0u;
            v70 = 0u;
            v67 = 0u;
            v68 = 0u;
            v65 = 0u;
            v66 = 0u;
            v64 = 0u;
            v62 = 0u;
            v63 = 0u;
            v61 = 0u;
            v19 = *__error();
            v25 = _SILogForLogForCategory(0);
            if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
            {
              v40 = a1[36];
              v28 = fd_name(a1[30], (char *)&v61, 0x100uLL);
              *(_DWORD *)buf = 136316418;
              v50 = "_data_map64_get_data_entry";
              v51 = 1024;
              v52 = 379;
              v53 = 2048;
              v54 = v17;
              v55 = 2048;
              v56 = v40;
              v57 = 2048;
              v58 = a1;
              v59 = 2080;
              v60 = v28;
              v23 = v25;
              v24 = "%s:%d: invalid data offset 0x%lx 0x%lx %p %s";
LABEL_27:
              _os_log_error_impl(&dword_1B8270000, v23, OS_LOG_TYPE_ERROR, v24, buf, 0x3Au);
            }
LABEL_19:
            *__error() = v19;
            v26 = 1;
            goto LABEL_23;
          }
          data_entry_restore(v43, v17, v18, (unsigned int *)&v46, &v48);
          if (v48)
          {
            v75 = 0u;
            v76 = 0u;
            v73 = 0u;
            v74 = 0u;
            v71 = 0u;
            v72 = 0u;
            v69 = 0u;
            v70 = 0u;
            v67 = 0u;
            v68 = 0u;
            v65 = 0u;
            v66 = 0u;
            v64 = 0u;
            v62 = 0u;
            v63 = 0u;
            v61 = 0u;
            v19 = *__error();
            v20 = _SILogForLogForCategory(0);
            if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
            {
              v21 = fd_name(a1[30], (char *)&v61, 0x100uLL);
              v22 = a1[36];
              *(_DWORD *)buf = 136316418;
              v50 = "_data_map64_get_data_entry";
              v51 = 1024;
              v52 = 375;
              v53 = 2080;
              v54 = (unint64_t)v21;
              v55 = 2048;
              v56 = v17;
              v57 = 2048;
              v58 = (uint64_t *)v22;
              v59 = 2048;
              v60 = (char *)v46;
              v23 = v20;
              v24 = "%s:%d: data_entry_restore failure: %s off: 0x%lx end: 0x%lx sz: 0x%lx";
              goto LABEL_27;
            }
            goto LABEL_19;
          }
          if (v46 == a5 && !memcmp(a4, __s2, a5))
            return v13 + 8 * v12;
        }
      }
      v26 = 0;
LABEL_23:
      ++v12;
      v27 = v26 != 0;
      if (v26 || v12 >= v9)
        goto LABEL_29;
    }
  }
  if (!a3)
    return 0;
  v75 = 0u;
  v76 = 0u;
  v73 = 0u;
  v74 = 0u;
  v71 = 0u;
  v72 = 0u;
  v69 = 0u;
  v70 = 0u;
  v67 = 0u;
  v68 = 0u;
  v65 = 0u;
  v66 = 0u;
  v64 = 0u;
  v62 = 0u;
  v63 = 0u;
  v61 = 0u;
  v30 = *__error();
  v31 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
  {
    v36 = a1[562];
    v37 = fd_name(a1[30], (char *)&v61, 0x100uLL);
    *(_DWORD *)buf = 136316418;
    v50 = "_data_map64_get_bucket_entry";
    v51 = 1024;
    v52 = 449;
    v53 = 2048;
    v54 = a3;
    v55 = 2048;
    v56 = v36;
    v57 = 2048;
    v58 = a1;
    v59 = 2080;
    v60 = v37;
    _os_log_error_impl(&dword_1B8270000, v31, OS_LOG_TYPE_ERROR, "%s:%d: invalid data id %lld max %lld %p %s", buf, 0x3Au);
  }
  v32 = __error();
  result = 0;
  *v32 = v30;
  return result;
}

uint64_t _data_map64_match_address(uint64_t result, unint64_t a2)
{
  _QWORD *v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  BOOL v10;

  if (result)
  {
    v3 = (_QWORD *)result;
    v4 = *(_QWORD *)(result + 224);
    if (v4 != -1)
    {
      if (v4)
      {
        if (v4 <= a2)
        {
          v5 = *(_QWORD *)(result + 232);
          if (v4 + v5 > a2)
          {
            v6 = *(_QWORD *)(result + 240);
            v7 = "data ro header";
            v8 = a2;
            v9 = v3[29];
LABEL_21:
            log_map_access_error_5220(v8, v4, v5, v9, (uint64_t)v7, v6);
            return 1;
          }
        }
      }
      return 0;
    }
    if (storage_windows_contains_address(result + 272, a2))
      return 1;
    v4 = v3[555];
    v10 = v4 + 1 < 2 || v4 > a2;
    if (v10 || (v5 = v3[553], v4 + v5 <= a2))
    {
      v4 = v3[560];
      if (v4 + 1 < 2)
        return 0;
      if (v4 > a2)
        return 0;
      v5 = v3[559];
      if (v4 + v5 <= a2)
        return 0;
      v9 = v3[558];
      v6 = v3[557];
      v7 = "data buckets";
    }
    else
    {
      v9 = v3[554];
      v6 = v3[552];
      v7 = "data offsets";
    }
    v8 = a2;
    goto LABEL_21;
  }
  return result;
}

int *log_map_access_error_5220(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6)
{
  int v11;
  char *v12;
  int v13;
  int v14;
  NSObject *v15;
  os_log_type_t v16;
  int *result;
  stat v18;
  uint8_t buf[4];
  uint64_t v20;
  __int16 v21;
  char *v22;
  __int16 v23;
  uint64_t v24;
  __int16 v25;
  uint64_t v26;
  __int16 v27;
  uint64_t v28;
  __int16 v29;
  int v30;
  __int16 v31;
  int v32;
  __int16 v33;
  dev_t st_dev;
  __int16 v35;
  __darwin_ino64_t st_ino;
  _OWORD v37[16];
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  if (a6)
    v11 = *(_DWORD *)(a6 + 44);
  else
    v11 = -1;
  memset(&v18, 0, sizeof(v18));
  memset(v37, 0, sizeof(v37));
  v12 = fd_name(a6, (char *)v37, 0x100uLL);
  if (fstatat(v11, v12, &v18, 32) == -1)
    v13 = *__error();
  else
    v13 = 0;
  v14 = *__error();
  v15 = _SILogForLogForCategory(0);
  v16 = gSILogLevels[0] < 3;
  if (os_log_type_enabled(v15, (os_log_type_t)(gSILogLevels[0] < 3)))
  {
    *(_DWORD *)buf = 136317186;
    v20 = a5;
    v21 = 2080;
    v22 = v12;
    v23 = 2048;
    v24 = a1;
    v25 = 2048;
    v26 = a2;
    v27 = 2048;
    v28 = a2 + a3;
    v29 = 1024;
    v30 = a4;
    v31 = 1024;
    v32 = v13;
    v33 = 1024;
    st_dev = v18.st_dev;
    v35 = 2048;
    st_ino = v18.st_ino;
    _os_log_impl(&dword_1B8270000, v15, v16, "*warn* Got exception on %s %s addr:%p start:%p map end:%p file end:%d sres:%d dev:%d ino:%lld", buf, 0x50u);
  }
  result = __error();
  *result = v14;
  return result;
}

uint64_t _data_map64_sync_data(uint64_t a1)
{
  uint64_t v2;
  unsigned int v3;
  int v4;
  unint64_t v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  void (*v11)(_QWORD);
  _DWORD *v12;
  int v13;
  NSObject *v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  NSObject *v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  NSObject *v22;
  os_log_type_t v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  void (*v28)(_QWORD);
  unsigned int v30;
  unsigned int v31;
  unsigned int v32;
  unsigned int v33;
  char v34;
  uint8_t v35[4];
  char *v36;
  __int16 v37;
  const char *v38;
  __int16 v39;
  uint64_t v40;
  uint8_t buf[32];
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  v2 = a1 + 4488;
  v34 = 0;
  makeThreadId();
  do
  {
    v3 = __ldxr(exceptionSequenceNum);
    v4 = v3 + 1;
  }
  while (__stxr(v3 + 1, exceptionSequenceNum));
  v5 = setThreadIdAndInfo(-1, sDataMapExceptionCallbacks, a1, 0, v4);
  v32 = HIDWORD(v5);
  v33 = v5;
  v30 = v7;
  v31 = v6;
  v8 = *(_QWORD *)&threadData[18 * v5 + 2];
  v9 = v8 + 320 * HIDWORD(v5);
  v10 = *(_DWORD *)(v9 + 312);
  v11 = *(void (**)(_QWORD))(v9 + 224);
  if (v11)
    v11(*(_QWORD *)(v8 + 320 * HIDWORD(v5) + 288));
  if (_setjmp((int *)v9))
  {
    v12 = (_DWORD *)(v9 + 312);
    v13 = *__error();
    v14 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "_data_map64_sync_data";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 1437;
      _os_log_error_impl(&dword_1B8270000, v14, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
    }
    *__error() = v13;
    *v12 = v10;
    CIOnThreadCleanUpReset(v30);
    dropThreadId(v33, 1, v4);
    CICleanUpReset(v33, v31);
  }
  else
  {
    if (!*(_DWORD *)(a1 + 4568) && !*(_DWORD *)(*(_QWORD *)(a1 + 264) + 16))
    {
      if (*(_BYTE *)(v2 + 73))
      {
        if (*(int *)(a1 + 296) >= 1)
        {
          v15 = 0;
          do
          {
            v16 = v15;
            storageWindowSync(*(_QWORD **)(a1 + 320 + 8 * v15), 0);
            v15 = v16 + 1;
          }
          while (v16 + 1 < *(int *)(a1 + 296));
        }
        *(_BYTE *)(v2 + 73) = 0;
      }
      if (*(_BYTE *)(v2 + 75))
      {
        msync((void *)((*(_QWORD *)(a1 + 4440) + 16 * *(_QWORD *)(*(_QWORD *)(a1 + 264) + 60)) & -*MEMORY[0x1E0C85AD8]), 16 * (*(_QWORD *)(a1 + 4496) - *(_QWORD *)(*(_QWORD *)(a1 + 264) + 60)), 16);
        *(_BYTE *)(v2 + 75) = 0;
      }
      if (*(_BYTE *)(v2 + 74))
      {
        msync(*(void **)(a1 + 4480), 8 * *(_QWORD *)(a1 + 4488), 16);
        *(_BYTE *)(v2 + 74) = 0;
      }
      *(_QWORD *)(*(_QWORD *)(a1 + 264) + 20) = *(_QWORD *)(a1 + 288);
      v17 = *__error();
      v18 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        v19 = *(_QWORD *)(a1 + 4496);
        *(_DWORD *)buf = 134217984;
        *(_QWORD *)&buf[4] = v19;
        _os_log_impl(&dword_1B8270000, v18, OS_LOG_TYPE_DEFAULT, "sd update next_id = %lld", buf, 0xCu);
      }
      *__error() = v17;
      v20 = *(_QWORD *)(a1 + 264);
      *(_OWORD *)(v20 + 28) = *(_OWORD *)v2;
      *(_OWORD *)(v20 + 68) = *(_OWORD *)(v2 + 16);
      *(_QWORD *)(v20 + 84) = *(_QWORD *)(a1 + 4520);
      *(_DWORD *)(v20 + 16) = 0;
      fd_pwrite(*(_QWORD *)(a1 + 240), v20, 0x5CuLL, 0);
      v54 = 0u;
      v55 = 0u;
      v52 = 0u;
      v53 = 0u;
      v50 = 0u;
      v51 = 0u;
      v48 = 0u;
      v49 = 0u;
      v46 = 0u;
      v47 = 0u;
      v44 = 0u;
      v45 = 0u;
      v42 = 0u;
      v43 = 0u;
      memset(buf, 0, sizeof(buf));
      v21 = *__error();
      v22 = _SILogForLogForCategory(7);
      v23 = 2 * (dword_1EF19FCA8 < 4);
      if (os_log_type_enabled(v22, v23))
      {
        v24 = fd_name(*(_QWORD *)(a1 + 240), (char *)buf, 0x100uLL);
        v25 = *(_QWORD *)(a1 + 4496) - 1;
        *(_DWORD *)v35 = 136315650;
        v36 = v24;
        v37 = 2080;
        v38 = "sync";
        v39 = 2048;
        v40 = v25;
        _os_log_impl(&dword_1B8270000, v22, v23, "%s complete %s map with count: %lld", v35, 0x20u);
      }
      *__error() = v21;
    }
    v34 = 1;
    v26 = *(_QWORD *)&threadData[18 * v33 + 2];
    v27 = v26 + 320 * v32;
    *(_DWORD *)(v27 + 312) = v10;
    v28 = *(void (**)(_QWORD))(v27 + 232);
    if (v28)
      v28(*(_QWORD *)(v26 + 320 * v32 + 288));
    dropThreadId(v33, 0, v4);
  }
  if (v34)
    return *(unsigned int *)(a1 + 4568);
  *(_DWORD *)(a1 + 4568) = 22;
  return 22;
}

uint64_t _data_map64_sync_header(uint64_t a1)
{
  unsigned int v2;
  int v3;
  unint64_t v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  void (*v10)(_QWORD);
  _DWORD *v11;
  int v12;
  NSObject *v13;
  uint64_t v14;
  int v15;
  NSObject *v16;
  uint64_t v17;
  os_log_type_t v18;
  const char *v19;
  uint8_t *v20;
  uint32_t v21;
  NSObject *v22;
  uint64_t v23;
  uint64_t v24;
  void (*v25)(_QWORD);
  int v27;
  NSObject *v28;
  uint64_t v29;
  uint64_t v30;
  NSObject *v31;
  os_log_type_t v32;
  char *v33;
  uint64_t v34;
  unsigned int v35;
  unsigned int v36;
  unsigned int v37;
  unsigned int v38;
  char v39;
  int v40;
  char *v41;
  __int16 v42;
  const char *v43;
  __int16 v44;
  uint64_t v45;
  uint8_t buf[32];
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  uint64_t v61;

  v61 = *MEMORY[0x1E0C80C00];
  v39 = 0;
  makeThreadId();
  do
  {
    v2 = __ldxr(exceptionSequenceNum);
    v3 = v2 + 1;
  }
  while (__stxr(v2 + 1, exceptionSequenceNum));
  v4 = setThreadIdAndInfo(-1, sDataMapExceptionCallbacks, a1, 0, v3);
  v37 = HIDWORD(v4);
  v38 = v4;
  v35 = v6;
  v36 = v5;
  v7 = *(_QWORD *)&threadData[18 * v4 + 2];
  v8 = v7 + 320 * HIDWORD(v4);
  v9 = *(_DWORD *)(v8 + 312);
  v10 = *(void (**)(_QWORD))(v8 + 224);
  if (v10)
    v10(*(_QWORD *)(v7 + 320 * HIDWORD(v4) + 288));
  if (_setjmp((int *)v8))
  {
    v11 = (_DWORD *)(v8 + 312);
    v12 = *__error();
    v13 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "_data_map64_sync_header";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 1480;
      _os_log_error_impl(&dword_1B8270000, v13, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
    }
    *__error() = v12;
    *v11 = v9;
    CIOnThreadCleanUpReset(v35);
    dropThreadId(v38, 1, v3);
    CICleanUpReset(v38, v36);
    goto LABEL_17;
  }
  if (!*(_DWORD *)(a1 + 4568))
  {
    v14 = *(_QWORD *)(a1 + 264);
    if (*(_DWORD *)(v14 + 16) != 1)
    {
      *(_OWORD *)(v14 + 44) = *(_OWORD *)(v14 + 20);
      *(_QWORD *)(v14 + 60) = *(_QWORD *)(v14 + 36);
      *(_QWORD *)(v14 + 20) = *(_QWORD *)(a1 + 288);
      v27 = *__error();
      v28 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        v29 = *(_QWORD *)(a1 + 4496);
        *(_DWORD *)buf = 134217984;
        *(_QWORD *)&buf[4] = v29;
        _os_log_impl(&dword_1B8270000, v28, OS_LOG_TYPE_DEFAULT, "sh update next_id = %lld", buf, 0xCu);
      }
      *__error() = v27;
      v30 = *(_QWORD *)(a1 + 264);
      *(_OWORD *)(v30 + 28) = *(_OWORD *)(a1 + 4488);
      *(_DWORD *)(v30 + 16) = 0;
      fd_pwrite(*(_QWORD *)(a1 + 240), v30, 0x5CuLL, 0);
      fd_sync(*(_QWORD *)(a1 + 240), 0);
      *(_DWORD *)(*(_QWORD *)(a1 + 264) + 16) = 2;
      v59 = 0u;
      v60 = 0u;
      v57 = 0u;
      v58 = 0u;
      v55 = 0u;
      v56 = 0u;
      v53 = 0u;
      v54 = 0u;
      v51 = 0u;
      v52 = 0u;
      v49 = 0u;
      v50 = 0u;
      v47 = 0u;
      v48 = 0u;
      memset(buf, 0, sizeof(buf));
      v15 = *__error();
      v31 = _SILogForLogForCategory(7);
      v32 = 2 * (dword_1EF19FCA8 < 4);
      if (!os_log_type_enabled(v31, v32))
        goto LABEL_14;
      v33 = fd_name(*(_QWORD *)(a1 + 240), (char *)buf, 0x100uLL);
      v34 = *(_QWORD *)(a1 + 4496) - 1;
      v40 = 136315650;
      v41 = v33;
      v42 = 2080;
      v43 = "sync";
      v44 = 2048;
      v45 = v34;
      v19 = "%s complete %s header with count: %llu";
      v20 = (uint8_t *)&v40;
      v21 = 32;
      v22 = v31;
      v18 = v32;
      goto LABEL_13;
    }
  }
  v15 = *__error();
  v16 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    v17 = *(_QWORD *)(a1 + 4496);
    *(_DWORD *)buf = 134217984;
    *(_QWORD *)&buf[4] = v17;
    v18 = OS_LOG_TYPE_DEFAULT;
    v19 = "Already clean; don't update next_id = %lld";
    v20 = buf;
    v21 = 12;
    v22 = v16;
LABEL_13:
    _os_log_impl(&dword_1B8270000, v22, v18, v19, v20, v21);
  }
LABEL_14:
  *__error() = v15;
  v39 = 1;
  v23 = *(_QWORD *)&threadData[18 * v38 + 2];
  v24 = v23 + 320 * v37;
  *(_DWORD *)(v24 + 312) = v9;
  v25 = *(void (**)(_QWORD))(v24 + 232);
  if (v25)
    v25(*(_QWORD *)(v23 + 320 * v37 + 288));
  dropThreadId(v38, 0, v3);
LABEL_17:
  if (v39)
    return *(unsigned int *)(a1 + 4568);
  *(_DWORD *)(a1 + 4568) = 22;
  return 22;
}

uint64_t data_map64_shadow(uint64_t a1)
{
  int v2;
  NSObject *v3;
  uint64_t v4;
  _QWORD *sibling_with_suffix_protected;
  int v6;
  NSObject *v7;
  uint64_t v8;
  int v10;
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 4568) || *(_DWORD *)(*(_QWORD *)(a1 + 264) + 16) != 2)
  {
    v6 = *__error();
    v7 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      v8 = *(_QWORD *)(*(_QWORD *)(a1 + 264) + 36);
      v10 = 134217984;
      v11 = v8;
      _os_log_impl(&dword_1B8270000, v7, OS_LOG_TYPE_DEFAULT, "Already shadowed; don't shadow next_id = %lld",
        (uint8_t *)&v10,
        0xCu);
    }
    *__error() = v6;
  }
  else
  {
    v2 = *__error();
    v3 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4 = *(_QWORD *)(*(_QWORD *)(a1 + 264) + 36);
      v10 = 134217984;
      v11 = v4;
      _os_log_impl(&dword_1B8270000, v3, OS_LOG_TYPE_DEFAULT, "shadow update next_id = %lld", (uint8_t *)&v10, 0xCu);
    }
    *__error() = v2;
    *(_DWORD *)(*(_QWORD *)(a1 + 264) + 16) = 2;
    sibling_with_suffix_protected = fd_create_sibling_with_suffix_protected(*(_QWORD *)(a1 + 240), ".shadow", 514);
    *(_QWORD *)(a1 + 248) = sibling_with_suffix_protected;
    fd_pwrite((uint64_t)sibling_with_suffix_protected, *(_QWORD *)(a1 + 264), 0x5CuLL, 0);
  }
  return *(unsigned int *)(a1 + 4568);
}

uint64_t data_map64_commit_shadow(uint64_t a1)
{
  int v2;
  NSObject *v3;
  uint64_t v4;
  int v5;
  NSObject *v6;
  uint64_t v7;
  int v9;
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 4568) || *(_DWORD *)(*(_QWORD *)(a1 + 264) + 16) != 2)
  {
    v5 = *__error();
    v6 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      v7 = *(_QWORD *)(a1 + 4496);
      v9 = 134217984;
      v10 = v7;
      _os_log_impl(&dword_1B8270000, v6, OS_LOG_TYPE_DEFAULT, "Already shadowed cs; don't shadow next_id = %lld",
        (uint8_t *)&v9,
        0xCu);
    }
    *__error() = v5;
  }
  else
  {
    v2 = *__error();
    v3 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4 = *(_QWORD *)(a1 + 4496);
      v9 = 134217984;
      v10 = v4;
      _os_log_impl(&dword_1B8270000, v3, OS_LOG_TYPE_DEFAULT, "commit shadow update next_id = %lld", (uint8_t *)&v9, 0xCu);
    }
    *__error() = v2;
    fd_sync(*(_QWORD *)(a1 + 248), 0);
  }
  fd_release(*(char **)(a1 + 248));
  *(_QWORD *)(a1 + 248) = 0;
  return *(unsigned int *)(a1 + 4568);
}

uint64_t data_map64_commit_shadow_complete(uint64_t a1)
{
  int v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  NSObject *v7;
  uint64_t v8;
  int v10;
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 4568) || *(_DWORD *)(*(_QWORD *)(a1 + 264) + 16) != 2)
  {
    v6 = *__error();
    v7 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      v8 = *(_QWORD *)(a1 + 4496);
      v10 = 134217984;
      v11 = v8;
      _os_log_impl(&dword_1B8270000, v7, OS_LOG_TYPE_DEFAULT, "Already shadowed csc; don't shadow next_id = %lld",
        (uint8_t *)&v10,
        0xCu);
    }
    *__error() = v6;
  }
  else
  {
    v2 = *__error();
    v3 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4 = *(_QWORD *)(a1 + 4496);
      v10 = 134217984;
      v11 = v4;
      _os_log_impl(&dword_1B8270000, v3, OS_LOG_TYPE_DEFAULT, "commit shadow complete update next_id = %lld", (uint8_t *)&v10, 0xCu);
    }
    *__error() = v2;
    v5 = *(_QWORD *)(a1 + 264);
    *(_DWORD *)(v5 + 16) = 1;
    fd_pwrite(*(_QWORD *)(a1 + 240), v5, 0x5CuLL, 0);
    fd_sync(*(_QWORD *)(a1 + 240), 0);
  }
  return *(unsigned int *)(a1 + 4568);
}

uint64_t data_map64_flush(uint64_t a1)
{
  unsigned int v3;
  int v4;
  unint64_t v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  void (*v11)(_QWORD);
  _DWORD *v12;
  int v13;
  NSObject *v14;
  uint64_t v15;
  int v16;
  NSObject *v17;
  const char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void (*v22)(_QWORD);
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  unsigned int v26;
  char v27;
  uint8_t buf[4];
  const char *v29;
  __int16 v30;
  int v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  if (_data_map64_rdlock(a1))
    return 0xFFFFFFFFLL;
  v27 = 0;
  makeThreadId();
  do
  {
    v3 = __ldxr(exceptionSequenceNum);
    v4 = v3 + 1;
  }
  while (__stxr(v3 + 1, exceptionSequenceNum));
  v5 = setThreadIdAndInfo(-1, sDataMapExceptionCallbacks, a1, 0, v4);
  v25 = HIDWORD(v5);
  v26 = v5;
  v23 = v7;
  v24 = v6;
  v8 = *(_QWORD *)&threadData[18 * v5 + 2];
  v9 = v8 + 320 * HIDWORD(v5);
  v10 = *(_DWORD *)(v9 + 312);
  v11 = *(void (**)(_QWORD))(v9 + 224);
  if (v11)
    v11(*(_QWORD *)(v8 + 320 * HIDWORD(v5) + 288));
  if (_setjmp((int *)v9))
  {
    v12 = (_DWORD *)(v9 + 312);
    v13 = *__error();
    v14 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v29 = "data_map64_flush";
      v30 = 1024;
      v31 = 1563;
      _os_log_error_impl(&dword_1B8270000, v14, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
    }
    *__error() = v13;
    *v12 = v10;
    CIOnThreadCleanUpReset(v23);
    dropThreadId(v26, 1, v4);
    CICleanUpReset(v26, v24);
    v15 = 0xFFFFFFFFLL;
  }
  else
  {
    if (*(_DWORD *)(*(_QWORD *)(a1 + 264) + 16))
    {
      v16 = *__error();
      v17 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        v18 = *(const char **)(a1 + 4496);
        *(_DWORD *)buf = 134217984;
        v29 = v18;
        _os_log_impl(&dword_1B8270000, v17, OS_LOG_TYPE_DEFAULT, "Not dirty; don't flush next_id = %lld", buf, 0xCu);
      }
      *__error() = v16;
      v19 = 0xFFFFFFFFLL;
    }
    else
    {
      v19 = _data_map64_sync_data(a1);
    }
    v27 = 1;
    v20 = *(_QWORD *)&threadData[18 * v26 + 2];
    v21 = v20 + 320 * v25;
    *(_DWORD *)(v21 + 312) = v10;
    v22 = *(void (**)(_QWORD))(v21 + 232);
    if (v22)
      v22(*(_QWORD *)(v20 + 320 * v25 + 288));
    dropThreadId(v26, 0, v4);
    v15 = v19;
  }
  if (!v27)
    *(_DWORD *)(a1 + 4568) = 22;
  _data_map64_unlock(a1);
  return v15;
}

uint64_t _data_map64_commit(uint64_t a1)
{
  unsigned int v3;
  int v4;
  unint64_t v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  void (*v11)(_QWORD);
  _DWORD *v12;
  int v13;
  NSObject *v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void (*v20)(_QWORD);
  int v21;
  NSObject *v22;
  os_log_type_t v23;
  char *v24;
  uint64_t v25;
  unsigned int v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  char v30;
  uint8_t buf[4];
  char *v32;
  __int16 v33;
  const char *v34;
  __int16 v35;
  uint64_t v36;
  uint8_t v37[32];
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  uint64_t v52;

  v52 = *MEMORY[0x1E0C80C00];
  if (_data_map64_rdlock(a1))
    return 0xFFFFFFFFLL;
  v30 = 0;
  makeThreadId();
  do
  {
    v3 = __ldxr(exceptionSequenceNum);
    v4 = v3 + 1;
  }
  while (__stxr(v3 + 1, exceptionSequenceNum));
  v5 = setThreadIdAndInfo(-1, sDataMapExceptionCallbacks, a1, 0, v4);
  v29 = HIDWORD(v5);
  *(_DWORD *)buf = v5;
  v27 = v7;
  v28 = v6;
  v8 = *(_QWORD *)&threadData[18 * v5 + 2];
  v9 = v8 + 320 * HIDWORD(v5);
  v10 = *(_DWORD *)(v9 + 312);
  v11 = *(void (**)(_QWORD))(v9 + 224);
  if (v11)
    v11(*(_QWORD *)(v8 + 320 * HIDWORD(v5) + 288));
  v26 = *(_DWORD *)buf;
  if (!_setjmp((int *)v9))
  {
    v16 = *(_DWORD *)(*(_QWORD *)(a1 + 264) + 16);
    if (v16 == 1)
      goto LABEL_15;
    if (v16)
    {
      v17 = 0xFFFFFFFFLL;
    }
    else
    {
      v17 = _data_map64_sync_data(a1);
      if (!(_DWORD)v17)
      {
        v17 = _data_map64_sync_header(a1);
        if (!(_DWORD)v17)
        {
LABEL_15:
          v17 = data_map64_shadow(a1);
          if (!(_DWORD)v17)
          {
            v17 = data_map64_commit_shadow(a1);
            if (!(_DWORD)v17)
              v17 = data_map64_commit_shadow_complete(a1);
          }
        }
      }
    }
    v30 = 1;
    v18 = *(_QWORD *)&threadData[18 * *(unsigned int *)buf + 2];
    v19 = v18 + 320 * v29;
    *(_DWORD *)(v19 + 312) = v10;
    v20 = *(void (**)(_QWORD))(v19 + 232);
    if (v20)
      v20(*(_QWORD *)(v18 + 320 * v29 + 288));
    dropThreadId(v26, 0, v4);
    v15 = v17;
    goto LABEL_22;
  }
  v12 = (_DWORD *)(v9 + 312);
  v13 = *__error();
  v14 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)v37 = 136315394;
    *(_QWORD *)&v37[4] = "_data_map64_commit";
    *(_WORD *)&v37[12] = 1024;
    *(_DWORD *)&v37[14] = 1640;
    _os_log_error_impl(&dword_1B8270000, v14, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", v37, 0x12u);
  }
  *__error() = v13;
  *v12 = v10;
  CIOnThreadCleanUpReset(v27);
  dropThreadId(v26, 1, v4);
  CICleanUpReset(v26, v28);
  v15 = 0xFFFFFFFFLL;
LABEL_22:
  if (!v30)
    *(_DWORD *)(a1 + 4568) = 22;
  v50 = 0u;
  v51 = 0u;
  v48 = 0u;
  v49 = 0u;
  v46 = 0u;
  v47 = 0u;
  v44 = 0u;
  v45 = 0u;
  v42 = 0u;
  v43 = 0u;
  v40 = 0u;
  v41 = 0u;
  v38 = 0u;
  v39 = 0u;
  memset(v37, 0, sizeof(v37));
  v21 = *__error();
  v22 = _SILogForLogForCategory(7);
  v23 = 2 * (dword_1EF19FCA8 < 4);
  if (os_log_type_enabled(v22, v23))
  {
    v24 = fd_name(*(_QWORD *)(a1 + 240), (char *)v37, 0x100uLL);
    v25 = *(_QWORD *)(a1 + 4496) - 1;
    *(_DWORD *)buf = 136315650;
    v32 = v24;
    v33 = 2080;
    v34 = "commit";
    v35 = 2048;
    v36 = v25;
    _os_log_impl(&dword_1B8270000, v22, v23, "%s complete %s with count: %lld", buf, 0x20u);
  }
  *__error() = v21;
  _data_map64_unlock(a1);
  return v15;
}

void bit_vector_set_5272(uint64_t a1, CFIndex idx)
{
  CFIndex v4;
  char *v5;
  char *v6;
  const char *v7;
  uint64_t v8;
  CFIndex v9;
  char *v10;
  const char *v11;
  const __CFBitVector *v12;
  const __CFAllocator *v13;
  __CFBitVector *MutableCopy;
  __CFBitVector *v15;
  const void *v16;
  char *v17;
  const char *v18;

  if (idx < 0)
  {
    v5 = __si_assert_copy_extra_268();
    v6 = v5;
    v7 = "";
    if (v5)
      v7 = v5;
    __message_assert(v5, "bit_vector.h", 129, "bitIndex >= 0", v7);
LABEL_9:
    free(v6);
    if (__valid_fs(-1))
      v8 = 2989;
    else
      v8 = 3072;
    *(_DWORD *)v8 = -559038737;
    abort();
  }
  v4 = *(_QWORD *)(a1 + 8);
  if (v4 > idx)
    goto LABEL_3;
  if (v4)
    v9 = *(_QWORD *)(a1 + 8);
  else
    v9 = 32;
  while (1)
  {
    v9 *= 2;
    if (v9 > idx)
      break;
    if (v9 <= v4)
    {
      v10 = __si_assert_copy_extra_268();
      v6 = v10;
      v11 = "";
      if (v10)
        v11 = v10;
      __message_assert(v10, "bit_vector.h", 111, "newCapacity > bv->capacity", v11);
      goto LABEL_9;
    }
  }
  v12 = *(const __CFBitVector **)(a1 + 16);
  v13 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (v12)
    MutableCopy = CFBitVectorCreateMutableCopy(v13, v9, v12);
  else
    MutableCopy = CFBitVectorCreateMutable(v13, v9);
  v15 = MutableCopy;
  if (!MutableCopy)
  {
    v17 = __si_assert_copy_extra_268();
    v6 = v17;
    v18 = "";
    if (v17)
      v18 = v17;
    __message_assert(v17, "bit_vector.h", 115, "newBV", v18);
    goto LABEL_9;
  }
  CFBitVectorSetCount(MutableCopy, v9);
  v16 = *(const void **)(a1 + 16);
  if (v16)
    CFRelease(v16);
  *(_QWORD *)(a1 + 8) = v9;
  *(_QWORD *)(a1 + 16) = v15;
LABEL_3:
  if (*(_QWORD *)a1 <= idx)
    *(_QWORD *)a1 = idx + 1;
  CFBitVectorSetBitAtIndex(*(CFMutableBitVectorRef *)(a1 + 16), idx, 1u);
}

CFIndex data_map64_id_get_with_key(uint64_t a1, uint64_t a2, size_t a3, void *a4)
{
  unsigned int v8;
  CFIndex v9;
  unsigned int v10;
  int v11;
  unint64_t v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  void (*v18)(_QWORD);
  _DWORD *v19;
  int v20;
  NSObject *v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  unint64_t v28;
  char *v29;
  unint64_t v30;
  int v31;
  NSObject *v32;
  char *v33;
  uint64_t v34;
  NSObject *v35;
  const char *v36;
  NSObject *v37;
  unint64_t v38;
  NSObject *v39;
  char *v40;
  char *v41;
  char *v42;
  char *v43;
  const void *v44;
  uint64_t v45;
  unsigned int v46;
  uint64_t v47;
  void (*v48)(_QWORD);
  uint64_t v50;
  size_t __n;
  unint64_t v52;
  void *__s1;
  void *__s2;
  int v55;
  int v56;
  uint64_t v57;
  char *v58;
  unint64_t v59;
  unsigned int v60;
  unsigned int v61;
  unint64_t v62;
  unsigned int v63;
  unsigned int v64;
  char v65;
  char v66;
  uint8_t buf[4];
  const char *v68;
  __int16 v69;
  int v70;
  __int16 v71;
  char *v72;
  __int16 v73;
  char *v74;
  __int16 v75;
  uint64_t v76;
  __int16 v77;
  char *v78;
  _DWORD v79[8];
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  uint64_t v94;

  v94 = *MEMORY[0x1E0C80C00];
  v8 = commonHash(a3, a2);
  if (_data_map64_rdlock(a1))
  {
    v9 = 0;
    goto LABEL_41;
  }
  v52 = v8;
  v65 = 0;
  makeThreadId();
  do
  {
    v10 = __ldxr(exceptionSequenceNum);
    v11 = v10 + 1;
  }
  while (__stxr(v10 + 1, exceptionSequenceNum));
  v12 = setThreadIdAndInfo(-1, sDataMapExceptionCallbacks, a1, 0, v11);
  v63 = HIDWORD(v12);
  v64 = v12;
  v62 = __PAIR64__(v13, v14);
  v15 = *(_QWORD *)&threadData[18 * v12 + 2];
  v16 = v15 + 320 * HIDWORD(v12);
  v17 = *(_DWORD *)(v16 + 312);
  v18 = *(void (**)(_QWORD))(v16 + 224);
  if (v18)
    v18(*(_QWORD *)(v15 + 320 * HIDWORD(v12) + 288));
  v61 = v64;
  v60 = v63;
  v59 = v62;
  if (_setjmp((int *)v16))
  {
    v19 = (_DWORD *)(v16 + 312);
    v20 = *__error();
    v21 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      v79[0] = 136315394;
      *(_QWORD *)&v79[1] = "data_map64_id_get_with_key";
      LOWORD(v79[3]) = 1024;
      *(_DWORD *)((char *)&v79[3] + 2) = 2157;
      _os_log_error_impl(&dword_1B8270000, v21, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", (uint8_t *)v79, 0x12u);
    }
    *__error() = v20;
    *v19 = v17;
    CIOnThreadCleanUpReset(v59);
    dropThreadId(v61, 1, v11);
    CICleanUpReset(v61, HIDWORD(v59));
    v9 = 0;
    goto LABEL_39;
  }
  __s1 = (void *)a2;
  __s2 = a4;
  v55 = v17;
  v56 = v11;
  v22 = *(_QWORD *)(a1 + 4488);
  v23 = v8 % v22;
  v24 = v52 % v22;
  __n = *(unsigned int *)(a1 + 220);
  while (1)
  {
    v25 = *(_QWORD *)(a1 + 4480);
    v26 = *(char **)(v25 + 8 * v24);
    if (!v26)
      break;
    if (*(_QWORD *)(a1 + 4496) <= (unint64_t)v26)
    {
      v92 = 0u;
      v93 = 0u;
      v90 = 0u;
      v91 = 0u;
      v88 = 0u;
      v89 = 0u;
      v86 = 0u;
      v87 = 0u;
      v84 = 0u;
      v85 = 0u;
      v82 = 0u;
      v83 = 0u;
      v80 = 0u;
      v81 = 0u;
      memset(v79, 0, sizeof(v79));
      v31 = *__error();
      v37 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
        goto LABEL_21;
      v42 = *(char **)(a1 + 4496);
      v43 = fd_name(*(_QWORD *)(a1 + 240), (char *)v79, 0x100uLL);
      *(_DWORD *)buf = 136316418;
      v68 = "_data_map64_get_offset_entry";
      v69 = 1024;
      v70 = 362;
      v71 = 2048;
      v72 = v26;
      v73 = 2048;
      v74 = v42;
      v75 = 2048;
      v76 = a1;
      v77 = 2080;
      v78 = v43;
      v35 = v37;
      v36 = "%s:%d: invalid data id %lld max %lld %p %s";
LABEL_30:
      _os_log_error_impl(&dword_1B8270000, v35, OS_LOG_TYPE_ERROR, v36, buf, 0x3Au);
      goto LABEL_21;
    }
    v27 = *(_QWORD *)(a1 + 4440);
    v28 = *(_QWORD *)(v27 + 16 * (_QWORD)v26);
    if (v28 != 1 && *(_QWORD *)(v27 + 16 * (_QWORD)v26 + 8) == v52)
    {
      v29 = *(char **)(v27 + 16 * (_QWORD)v26);
      v57 = 0;
      v58 = 0;
      v66 = 0;
      v30 = *(_QWORD *)(a1 + 288);
      if (v30 <= v28)
      {
        v92 = 0u;
        v93 = 0u;
        v90 = 0u;
        v91 = 0u;
        v88 = 0u;
        v89 = 0u;
        v86 = 0u;
        v87 = 0u;
        v84 = 0u;
        v85 = 0u;
        v82 = 0u;
        v83 = 0u;
        v80 = 0u;
        v81 = 0u;
        memset(v79, 0, sizeof(v79));
        v31 = *__error();
        v39 = _SILogForLogForCategory(0);
        if (!os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
          goto LABEL_21;
        v40 = *(char **)(a1 + 288);
        v41 = fd_name(*(_QWORD *)(a1 + 240), (char *)v79, 0x100uLL);
        *(_DWORD *)buf = 136316418;
        v68 = "_data_map64_get_data_entry";
        v69 = 1024;
        v70 = 379;
        v71 = 2048;
        v72 = v29;
        v73 = 2048;
        v74 = v40;
        v75 = 2048;
        v76 = a1;
        v77 = 2080;
        v78 = v41;
        v35 = v39;
        v36 = "%s:%d: invalid data offset 0x%lx 0x%lx %p %s";
        goto LABEL_30;
      }
      data_entry_restore(a1 + 272, v28, v30, (unsigned int *)&v57, &v66);
      if (v66)
      {
        v92 = 0u;
        v93 = 0u;
        v90 = 0u;
        v91 = 0u;
        v88 = 0u;
        v89 = 0u;
        v86 = 0u;
        v87 = 0u;
        v84 = 0u;
        v85 = 0u;
        v82 = 0u;
        v83 = 0u;
        v80 = 0u;
        v81 = 0u;
        memset(v79, 0, sizeof(v79));
        v31 = *__error();
        v32 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
        {
          v33 = fd_name(*(_QWORD *)(a1 + 240), (char *)v79, 0x100uLL);
          v34 = *(_QWORD *)(a1 + 288);
          *(_DWORD *)buf = 136316418;
          v68 = "_data_map64_get_data_entry";
          v69 = 1024;
          v70 = 375;
          v71 = 2080;
          v72 = v33;
          v73 = 2048;
          v74 = v29;
          v75 = 2048;
          v76 = v34;
          v77 = 2048;
          v78 = (char *)v57;
          v35 = v32;
          v36 = "%s:%d: data_entry_restore failure: %s off: 0x%lx end: 0x%lx sz: 0x%lx";
          goto LABEL_30;
        }
LABEL_21:
        *__error() = v31;
        goto LABEL_22;
      }
      if (__n + a3 == v57)
      {
        v44 = v58;
        if (!memcmp(__s1, &v58[__n], a3) && !memcmp(v44, __s2, __n))
        {
          v9 = *(_QWORD *)(v25 + 8 * v24);
          goto LABEL_36;
        }
      }
    }
LABEL_22:
    if (v24 + 1 == v22)
      v38 = 0;
    else
      v38 = v24 + 1;
    v24 = v38;
    if (v38 == v23)
    {
      v9 = 0;
      goto LABEL_36;
    }
  }
  v9 = 0;
LABEL_36:
  v65 = 1;
  v45 = *(_QWORD *)&threadData[18 * v61 + 2];
  v46 = v60;
  v47 = v45 + 320 * v60;
  *(_DWORD *)(v47 + 312) = v55;
  v48 = *(void (**)(_QWORD))(v47 + 232);
  if (v48)
    v48(*(_QWORD *)(v45 + 320 * v46 + 288));
  dropThreadId(v61, 0, v56);
LABEL_39:
  if (!v65)
  {
    v9 = 0;
    *(_DWORD *)(a1 + 4568) = 22;
  }
LABEL_41:
  if (*(_QWORD *)(a1 + 4552))
  {
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 4544));
    v50 = *(_QWORD *)(a1 + 4552);
    if (v50)
      bit_vector_set_5272(v50, v9);
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 4544));
  }
  _data_map64_unlock(a1);
  return v9;
}

uint64_t data_map64_get_extra_with_key(uint64_t a1, const void *a2, size_t a3, _BYTE *a4)
{
  _BYTE *v4;
  unsigned int v8;
  unsigned int v9;
  int v10;
  unint64_t v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  void (*v17)(_QWORD);
  _DWORD *v18;
  int v19;
  NSObject *v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  CFIndex v24;
  char *v25;
  uint64_t v26;
  unint64_t v27;
  char *v28;
  unint64_t v29;
  int v30;
  NSObject *v31;
  char *v32;
  uint64_t v33;
  NSObject *v34;
  const char *v35;
  NSObject *v36;
  unint64_t v37;
  NSObject *v38;
  char *v39;
  char *v40;
  char *v41;
  char *v42;
  uint64_t v43;
  int v44;
  uint64_t v45;
  unsigned int v46;
  uint64_t v47;
  void (*v48)(_QWORD);
  NSObject *v50;
  os_log_t log;
  uint64_t v52;
  os_unfair_lock_s *lock;
  unint64_t v54;
  int v55;
  _BYTE *v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t v59;
  unsigned int v60;
  unsigned int v61;
  unint64_t v62;
  unsigned int v63;
  unsigned int v64;
  char v65;
  uint64_t v66;
  char v67;
  uint8_t buf[4];
  const char *v69;
  __int16 v70;
  int v71;
  __int16 v72;
  char *v73;
  __int16 v74;
  char *v75;
  __int16 v76;
  uint64_t v77;
  __int16 v78;
  char *v79;
  uint8_t v80[32];
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  uint64_t v95;

  v4 = a4;
  v95 = *MEMORY[0x1E0C80C00];
  *a4 = 0;
  v66 = 0;
  v8 = commonHash(a3, (uint64_t)a2);
  if (_data_map64_rdlock(a1))
    goto LABEL_43;
  v54 = v8;
  v65 = 0;
  makeThreadId();
  do
  {
    v9 = __ldxr(exceptionSequenceNum);
    v10 = v9 + 1;
  }
  while (__stxr(v9 + 1, exceptionSequenceNum));
  v11 = setThreadIdAndInfo(-1, sDataMapExceptionCallbacks, a1, 0, v10);
  v63 = HIDWORD(v11);
  v64 = v11;
  v62 = __PAIR64__(v12, v13);
  v14 = *(_QWORD *)&threadData[18 * v11 + 2];
  v15 = v14 + 320 * HIDWORD(v11);
  v16 = *(_DWORD *)(v15 + 312);
  v17 = *(void (**)(_QWORD))(v15 + 224);
  if (v17)
    v17(*(_QWORD *)(v14 + 320 * HIDWORD(v11) + 288));
  v61 = v64;
  v60 = v63;
  v59 = v62;
  if (_setjmp((int *)v15))
  {
    v18 = (_DWORD *)(v15 + 312);
    v19 = *__error();
    v20 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v80 = 136315394;
      *(_QWORD *)&v80[4] = "data_map64_get_extra_with_key";
      *(_WORD *)&v80[12] = 1024;
      *(_DWORD *)&v80[14] = 2219;
      _os_log_error_impl(&dword_1B8270000, v20, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", v80, 0x12u);
    }
    *__error() = v19;
    *v18 = v16;
    CIOnThreadCleanUpReset(v59);
    dropThreadId(v61, 1, v10);
    CICleanUpReset(v61, HIDWORD(v59));
    goto LABEL_41;
  }
  v55 = v10;
  v56 = v4;
  v21 = *(_QWORD *)(a1 + 4488);
  v22 = v54 % v21;
  lock = (os_unfair_lock_s *)(a1 + 4544);
  v52 = *(unsigned int *)(a1 + 220);
  do
  {
    v23 = *(_QWORD *)(a1 + 4480);
    v24 = *(_QWORD *)(v23 + 8 * v22);
    if (!v24)
      break;
    if (*(_QWORD *)(a1 + 4552))
    {
      os_unfair_lock_lock(lock);
      v43 = *(_QWORD *)(a1 + 4552);
      if (v43)
        bit_vector_set_5272(v43, v24);
      os_unfair_lock_unlock(lock);
      v25 = *(char **)(v23 + 8 * v22);
    }
    else
    {
      v25 = *(char **)(v23 + 8 * v22);
    }
    if (*(_QWORD *)(a1 + 4496) <= (unint64_t)v25)
    {
      v93 = 0u;
      v94 = 0u;
      v91 = 0u;
      v92 = 0u;
      v89 = 0u;
      v90 = 0u;
      v87 = 0u;
      v88 = 0u;
      v85 = 0u;
      v86 = 0u;
      v83 = 0u;
      v84 = 0u;
      v81 = 0u;
      v82 = 0u;
      memset(v80, 0, sizeof(v80));
      v30 = *__error();
      v36 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
      {
        log = v36;
        v41 = *(char **)(a1 + 4496);
        v42 = fd_name(*(_QWORD *)(a1 + 240), (char *)v80, 0x100uLL);
        *(_DWORD *)buf = 136316418;
        v69 = "_data_map64_get_offset_entry";
        v70 = 1024;
        v71 = 362;
        v72 = 2048;
        v73 = v25;
        v74 = 2048;
        v75 = v41;
        v76 = 2048;
        v77 = a1;
        v78 = 2080;
        v79 = v42;
        v34 = log;
        v35 = "%s:%d: invalid data id %lld max %lld %p %s";
LABEL_31:
        _os_log_error_impl(&dword_1B8270000, v34, OS_LOG_TYPE_ERROR, v35, buf, 0x3Au);
      }
LABEL_23:
      *__error() = v30;
      goto LABEL_24;
    }
    v26 = *(_QWORD *)(a1 + 4440);
    if (!v26)
      goto LABEL_24;
    v27 = *(_QWORD *)(v26 + 16 * (_QWORD)v25);
    if (v27 == 1 || *(_QWORD *)(v26 + 16 * (_QWORD)v25 + 8) != v54)
      goto LABEL_24;
    v28 = *(char **)(v26 + 16 * (_QWORD)v25);
    v57 = 0;
    v58 = 0;
    v67 = 0;
    v29 = *(_QWORD *)(a1 + 288);
    if (v29 <= v27)
    {
      v93 = 0u;
      v94 = 0u;
      v91 = 0u;
      v92 = 0u;
      v89 = 0u;
      v90 = 0u;
      v87 = 0u;
      v88 = 0u;
      v85 = 0u;
      v86 = 0u;
      v83 = 0u;
      v84 = 0u;
      v81 = 0u;
      v82 = 0u;
      memset(v80, 0, sizeof(v80));
      v30 = *__error();
      v38 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
      {
        v50 = v38;
        v39 = *(char **)(a1 + 288);
        v40 = fd_name(*(_QWORD *)(a1 + 240), (char *)v80, 0x100uLL);
        *(_DWORD *)buf = 136316418;
        v69 = "_data_map64_get_data_entry";
        v70 = 1024;
        v71 = 379;
        v72 = 2048;
        v73 = v28;
        v74 = 2048;
        v75 = v39;
        v76 = 2048;
        v77 = a1;
        v78 = 2080;
        v79 = v40;
        v34 = v50;
        v35 = "%s:%d: invalid data offset 0x%lx 0x%lx %p %s";
        goto LABEL_31;
      }
      goto LABEL_23;
    }
    data_entry_restore(a1 + 272, v27, v29, (unsigned int *)&v57, &v67);
    if (v67)
    {
      v93 = 0u;
      v94 = 0u;
      v91 = 0u;
      v92 = 0u;
      v89 = 0u;
      v90 = 0u;
      v87 = 0u;
      v88 = 0u;
      v85 = 0u;
      v86 = 0u;
      v83 = 0u;
      v84 = 0u;
      v81 = 0u;
      v82 = 0u;
      memset(v80, 0, sizeof(v80));
      v30 = *__error();
      v31 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      {
        v32 = fd_name(*(_QWORD *)(a1 + 240), (char *)v80, 0x100uLL);
        v33 = *(_QWORD *)(a1 + 288);
        *(_DWORD *)buf = 136316418;
        v69 = "_data_map64_get_data_entry";
        v70 = 1024;
        v71 = 375;
        v72 = 2080;
        v73 = v32;
        v74 = 2048;
        v75 = v28;
        v76 = 2048;
        v77 = v33;
        v78 = 2048;
        v79 = (char *)v57;
        v34 = v31;
        v35 = "%s:%d: data_entry_restore failure: %s off: 0x%lx end: 0x%lx sz: 0x%lx";
        goto LABEL_31;
      }
      goto LABEL_23;
    }
    if (v52 + a3 == v57 && !memcmp(a2, (const void *)(v58 + v52), a3))
    {
      v44 = *(_DWORD *)(a1 + 220);
      __memcpy_chk();
      HIDWORD(v66) = v44;
      *v56 = 1;
      break;
    }
LABEL_24:
    v37 = 0;
    if (v22 + 1 != v21)
      v37 = v22 + 1;
    v22 = v37;
  }
  while (v37 != v54 % v21);
  v65 = 1;
  v45 = *(_QWORD *)&threadData[18 * v61 + 2];
  v46 = v60;
  v47 = v45 + 320 * v60;
  *(_DWORD *)(v47 + 312) = v16;
  v48 = *(void (**)(_QWORD))(v47 + 232);
  if (v48)
    v48(*(_QWORD *)(v45 + 320 * v46 + 288));
  dropThreadId(v61, 0, v55);
  v4 = v56;
LABEL_41:
  if (!v65)
  {
    *v4 = 0;
    *(_DWORD *)(a1 + 4568) = 22;
  }
LABEL_43:
  _data_map64_unlock(a1);
  return v66;
}

unint64_t _data_map64_get_data_id(uint64_t a1, unsigned int a2, const void *a3, size_t a4, int a5)
{
  unsigned int v9;
  unsigned int v10;
  unsigned int v12;
  int v13;
  unint64_t v14;
  unsigned int v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  void (*v20)(_QWORD);
  int v21;
  NSObject *v22;
  unint64_t v23;
  unint64_t *bucket_entry;
  _QWORD *v25;
  int v26;
  int v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t *v31;
  int v32;
  NSObject *v33;
  unint64_t *v34;
  uint64_t v35;
  unsigned int v36;
  uint64_t v37;
  void (*v38)(_QWORD);
  _BYTE *v39;
  int v40;
  _QWORD v41[2];
  unint64_t v42;
  unsigned int v43;
  unsigned int v44;
  unsigned int v45;
  unsigned int v46;
  unsigned int v47;
  unsigned int v48;
  uint8_t buf[4];
  const char *v50;
  __int16 v51;
  uint64_t v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v9 = a4;
  v10 = commonHash(a4 - a2, (uint64_t)a3 + a2);
  if (_data_map64_rdlock(a1))
    return 0;
  v39 = (_BYTE *)(a1 + 4561);
  makeThreadId();
  do
  {
    v12 = __ldxr(exceptionSequenceNum);
    v13 = v12 + 1;
  }
  while (__stxr(v12 + 1, exceptionSequenceNum));
  v14 = setThreadIdAndInfo(-1, sDataMapExceptionCallbacks, a1, 0, v13);
  v47 = HIDWORD(v14);
  v48 = v14;
  v45 = v16;
  v46 = v15;
  v17 = *(_QWORD *)&threadData[18 * v14 + 2];
  v18 = v17 + 320 * HIDWORD(v14);
  v19 = *(_DWORD *)(v18 + 312);
  v20 = *(void (**)(_QWORD))(v18 + 224);
  if (v20)
    v20(*(_QWORD *)(v17 + 320 * HIDWORD(v14) + 288));
  v44 = v48;
  v43 = v47;
  v42 = __PAIR64__(v46, v45);
  if (!_setjmp((int *)v18))
  {
    bucket_entry = (unint64_t *)_data_map64_get_bucket_entry((uint64_t *)a1, v10, 0, a3, a4);
    if (!bucket_entry)
      goto LABEL_45;
    if (*bucket_entry)
    {
      if (*bucket_entry >= *(_QWORD *)(a1 + 4496))
        v23 = 0;
      else
        v23 = *bucket_entry;
      goto LABEL_46;
    }
    if (!a5)
      goto LABEL_23;
    v25 = bucket_entry;
    v41[1] = a3;
    v41[0] = v9;
    if (v9 >> 28)
    {
      v26 = 5;
    }
    else if ((v9 & 0xFE00000) != 0)
    {
      v26 = 4;
    }
    else
    {
      if ((v9 & 0x1FC000) == 0)
      {
        if ((v9 & 0x3F80) != 0)
          v27 = 2;
        else
          v27 = 1;
        goto LABEL_22;
      }
      v26 = 3;
    }
    v27 = v26;
LABEL_22:
    v28 = *(_QWORD *)(a1 + 4496);
    _data_map64_unlock(a1);
    if (_data_map64_wrlock(a1))
    {
LABEL_23:
      v23 = 0;
LABEL_46:
      v35 = *(_QWORD *)&threadData[18 * v44 + 2];
      v36 = v43;
      v37 = v35 + 320 * v43;
      *(_DWORD *)(v37 + 312) = v19;
      v38 = *(void (**)(_QWORD))(v37 + 232);
      if (v38)
        v38(*(_QWORD *)(v35 + 320 * v36 + 288));
      dropThreadId(v44, 0, v13);
      goto LABEL_49;
    }
    v29 = v28;
    if (v28 == *(_QWORD *)(a1 + 4496))
      goto LABEL_25;
    v34 = (unint64_t *)_data_map64_get_bucket_entry((uint64_t *)a1, v10, 0, a3, a4);
    if (v34)
    {
      v30 = *v34;
      v29 = *(_QWORD *)(a1 + 4496);
      if (*v34 >= v29)
        goto LABEL_23;
      if (v30)
      {
        _data_map64_set_seen_id(a1, v30);
        goto LABEL_44;
      }
      v25 = v34;
LABEL_25:
      v30 = v29;
      v40 = 0;
      if (!_data_map64_grow(a1, (v27 + a4), &v40))
        goto LABEL_23;
      if (!*(_BYTE *)(a1 + 4563))
      {
        _data_map64_dirty(a1);
        *(_BYTE *)(a1 + 4563) = 1;
      }
      v31 = (unint64_t *)(*(_QWORD *)(a1 + 4440) + 16 * v30);
      v31[1] = v10;
      if (!*v39)
      {
        _data_map64_dirty(a1);
        *v39 = 1;
      }
      *v31 = data_entry_store(a1 + 272, (unsigned int *)v41);
      ++*(_QWORD *)(a1 + 4496);
      if (!*(_BYTE *)(a1 + 4562))
      {
        _data_map64_dirty(a1);
        *(_BYTE *)(a1 + 4562) = 1;
      }
      if ((v40 & 4) != 0)
        v25 = (_QWORD *)_data_map64_get_bucket_entry((uint64_t *)a1, v10, v30, 0, 0);
      *v25 = v30;
      if (gSILogLevels[0] >= 5)
      {
        v32 = *__error();
        v33 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 134218240;
          v50 = (const char *)v30;
          v51 = 2048;
          v52 = a1;
          _os_log_impl(&dword_1B8270000, v33, OS_LOG_TYPE_DEFAULT, "added %lld to %p", buf, 0x16u);
        }
        *__error() = v32;
      }
LABEL_44:
      v23 = v30;
      goto LABEL_46;
    }
LABEL_45:
    v23 = 0;
    goto LABEL_46;
  }
  v21 = *__error();
  v22 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136315394;
    v50 = "_data_map64_get_data_id";
    v51 = 1024;
    LODWORD(v52) = 1974;
    _os_log_error_impl(&dword_1B8270000, v22, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
  }
  *__error() = v21;
  *(_DWORD *)(v18 + 312) = v19;
  CIOnThreadCleanUpReset(v42);
  dropThreadId(v44, 1, v13);
  CICleanUpReset(v44, HIDWORD(v42));
  v23 = 0;
LABEL_49:
  _data_map64_unlock(a1);
  return v23;
}

void _data_map64_set_seen_id(uint64_t a1, CFIndex a2)
{
  os_unfair_lock_s *v4;
  uint64_t v5;

  if (*(_QWORD *)(a1 + 4552))
  {
    v4 = (os_unfair_lock_s *)(a1 + 4544);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 4544));
    v5 = *(_QWORD *)(a1 + 4552);
    if (v5)
      bit_vector_set_5272(v5, a2);
    os_unfair_lock_unlock(v4);
  }
}

uint64_t _data_map64_grow(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t result;
  unint64_t v7;
  unint64_t v8;
  size_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;

  if (*(_DWORD *)(a1 + 4568))
    return 0;
  v7 = *(_QWORD *)(a1 + 4496);
  if (v7 >= *(_QWORD *)(a1 + 4448))
  {
    v8 = (*MEMORY[0x1E0C85AD8] + 16 * v7 + 15) & -*MEMORY[0x1E0C85AD8];
    if (fd_truncate(*(_QWORD *)(a1 + 4416), v8) == -1)
      goto LABEL_17;
    *(_QWORD *)(a1 + 4432) = v8;
    v9 = *(_QWORD *)(a1 + 4424);
    if (v8 > v9)
    {
      v10 = 2 * v9;
      munmap(*(void **)(a1 + 4440), v9);
      *(_QWORD *)(a1 + 4424) = 0;
      v11 = fd_mmap(*(_QWORD *)(a1 + 4416));
      *(_QWORD *)(a1 + 4440) = v11;
      if (v11 == -1)
        goto LABEL_17;
      *(_QWORD *)(a1 + 4424) = v10;
    }
    *(_QWORD *)(a1 + 4448) = v8 >> 4;
    *a3 |= 2u;
    v7 = *(_QWORD *)(a1 + 4496);
  }
  v12 = v7 - *(_QWORD *)(a1 + 4504);
  if (v12 >= 2 * *(_QWORD *)(a1 + 4488) / 3uLL || v12 < 2 * *(_QWORD *)(a1 + 4512))
  {
    if (!_data_map64_rehash(a1))
      goto LABEL_17;
    *a3 |= 4u;
  }
  v13 = a2 + *(_QWORD *)(a1 + 288) + 8;
  if (v13 <= *(_QWORD *)(a1 + 280))
    return 1;
  if (_storageWindowsSetFileSize((_DWORD **)(a1 + 272), (v13 + *MEMORY[0x1E0C85AD8] - 1) & -*MEMORY[0x1E0C85AD8]))
  {
    *a3 |= 1u;
    return 1;
  }
LABEL_17:
  if (*(_DWORD *)(a1 + 4568))
    return 0;
  result = 0;
  *(_DWORD *)(a1 + 4568) = 1;
  return result;
}

uint64_t data_map64_get_data(uint64_t a1, unint64_t a2, _QWORD *a3)
{
  uint64_t result;
  unsigned int v7;
  int v8;
  unint64_t v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  void (*v15)(_QWORD);
  int v16;
  NSObject *v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  int v23;
  NSObject *v24;
  char *v25;
  uint64_t v26;
  const char *v27;
  int v28;
  NSObject *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  void (*v34)(_QWORD);
  unint64_t v35;
  char *v36;
  unint64_t v37;
  char *v38;
  uint64_t v39;
  unsigned int v40;
  unsigned int v41;
  unsigned int v42;
  unsigned int v43;
  char v44;
  uint64_t v45;
  uint64_t v46;
  char v47;
  uint8_t v48[4];
  const char *v49;
  __int16 v50;
  int v51;
  __int16 v52;
  unint64_t v53;
  __int16 v54;
  unint64_t v55;
  __int16 v56;
  uint64_t v57;
  __int16 v58;
  char *v59;
  _DWORD buf[8];
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  uint64_t v75;

  v75 = *MEMORY[0x1E0C80C00];
  if (_data_map64_rdlock(a1))
  {
LABEL_2:
    if (a3)
      *a3 = 0;
    return 0;
  }
  v44 = 0;
  makeThreadId();
  do
  {
    v7 = __ldxr(exceptionSequenceNum);
    v8 = v7 + 1;
  }
  while (__stxr(v7 + 1, exceptionSequenceNum));
  v9 = setThreadIdAndInfo(-1, sDataMapExceptionCallbacks, a1, 0, v8);
  v42 = HIDWORD(v9);
  v43 = v9;
  v40 = v11;
  v41 = v10;
  v12 = *(_QWORD *)&threadData[18 * v9 + 2];
  v13 = v12 + 320 * HIDWORD(v9);
  v14 = *(_DWORD *)(v13 + 312);
  v15 = *(void (**)(_QWORD))(v13 + 224);
  if (v15)
    v15(*(_QWORD *)(v12 + 320 * HIDWORD(v9) + 288));
  if (_setjmp((int *)v13))
  {
    v16 = *__error();
    v17 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      buf[0] = 136315394;
      *(_QWORD *)&buf[1] = "data_map64_get_data";
      LOWORD(buf[3]) = 1024;
      *(_DWORD *)((char *)&buf[3] + 2) = 2522;
      _os_log_error_impl(&dword_1B8270000, v17, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", (uint8_t *)buf, 0x12u);
    }
    *__error() = v16;
    *(_DWORD *)(v13 + 312) = v14;
    CIOnThreadCleanUpReset(v40);
    dropThreadId(v43, 1, v8);
    CICleanUpReset(v43, v41);
    v18 = 0;
    goto LABEL_30;
  }
  if (*(_QWORD *)(a1 + 4496) <= a2)
  {
    v73 = 0u;
    v74 = 0u;
    v71 = 0u;
    v72 = 0u;
    v69 = 0u;
    v70 = 0u;
    v67 = 0u;
    v68 = 0u;
    v65 = 0u;
    v66 = 0u;
    v63 = 0u;
    v64 = 0u;
    v61 = 0u;
    v62 = 0u;
    memset(buf, 0, sizeof(buf));
    v28 = *__error();
    v29 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
    {
      v35 = *(_QWORD *)(a1 + 4496);
      v36 = fd_name(*(_QWORD *)(a1 + 240), (char *)buf, 0x100uLL);
      *(_DWORD *)v48 = 136316418;
      v49 = "_data_map64_get_offset_entry";
      v50 = 1024;
      v51 = 362;
      v52 = 2048;
      v53 = a2;
      v54 = 2048;
      v55 = v35;
      v56 = 2048;
      v57 = a1;
      v58 = 2080;
      v59 = v36;
      _os_log_error_impl(&dword_1B8270000, v29, OS_LOG_TYPE_ERROR, "%s:%d: invalid data id %lld max %lld %p %s", v48, 0x3Au);
    }
    *__error() = v28;
  }
  else
  {
    v19 = *(_QWORD *)(a1 + 4440);
    if (v19)
    {
      v20 = *(_QWORD *)(v19 + 16 * a2);
      if (v20 != 1)
      {
        v21 = v20;
        v45 = 0;
        v46 = 0;
        v47 = 0;
        v22 = *(_QWORD *)(a1 + 288);
        if (v22 <= v20)
        {
          v73 = 0u;
          v74 = 0u;
          v71 = 0u;
          v72 = 0u;
          v69 = 0u;
          v70 = 0u;
          v67 = 0u;
          v68 = 0u;
          v65 = 0u;
          v66 = 0u;
          v63 = 0u;
          v64 = 0u;
          v61 = 0u;
          v62 = 0u;
          memset(buf, 0, sizeof(buf));
          v23 = *__error();
          v24 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            v37 = *(_QWORD *)(a1 + 288);
            v38 = fd_name(*(_QWORD *)(a1 + 240), (char *)buf, 0x100uLL);
            *(_DWORD *)v48 = 136316418;
            v49 = "_data_map64_get_data_entry";
            v50 = 1024;
            v51 = 379;
            v52 = 2048;
            v53 = v21;
            v54 = 2048;
            v55 = v37;
            v56 = 2048;
            v57 = a1;
            v58 = 2080;
            v59 = v38;
            v27 = "%s:%d: invalid data offset 0x%lx 0x%lx %p %s";
            goto LABEL_39;
          }
        }
        else
        {
          data_entry_restore(a1 + 272, v20, v22, (unsigned int *)&v45, &v47);
          if (!v47)
          {
            if (a3)
              *a3 = (v45 - *(_DWORD *)(a1 + 220));
            if (*(_QWORD *)(a1 + 4552))
            {
              os_unfair_lock_lock((os_unfair_lock_t)(a1 + 4544));
              v39 = *(_QWORD *)(a1 + 4552);
              if (v39)
                bit_vector_set_5272(v39, a2);
              os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 4544));
            }
            v31 = v46 + *(unsigned int *)(a1 + 220);
            goto LABEL_26;
          }
          v73 = 0u;
          v74 = 0u;
          v71 = 0u;
          v72 = 0u;
          v69 = 0u;
          v70 = 0u;
          v67 = 0u;
          v68 = 0u;
          v65 = 0u;
          v66 = 0u;
          v63 = 0u;
          v64 = 0u;
          v61 = 0u;
          v62 = 0u;
          memset(buf, 0, sizeof(buf));
          v23 = *__error();
          v24 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            v25 = fd_name(*(_QWORD *)(a1 + 240), (char *)buf, 0x100uLL);
            v26 = *(_QWORD *)(a1 + 288);
            *(_DWORD *)v48 = 136316418;
            v49 = "_data_map64_get_data_entry";
            v50 = 1024;
            v51 = 375;
            v52 = 2080;
            v53 = (unint64_t)v25;
            v54 = 2048;
            v55 = v21;
            v56 = 2048;
            v57 = v26;
            v58 = 2048;
            v59 = (char *)v45;
            v27 = "%s:%d: data_entry_restore failure: %s off: 0x%lx end: 0x%lx sz: 0x%lx";
LABEL_39:
            _os_log_error_impl(&dword_1B8270000, v24, OS_LOG_TYPE_ERROR, v27, v48, 0x3Au);
          }
        }
        *__error() = v23;
        v31 = 0;
LABEL_26:
        v30 = v31;
        goto LABEL_27;
      }
    }
  }
  v30 = 0;
LABEL_27:
  v44 = 1;
  v32 = *(_QWORD *)&threadData[18 * v43 + 2];
  v33 = v32 + 320 * v42;
  *(_DWORD *)(v33 + 312) = v14;
  v34 = *(void (**)(_QWORD))(v33 + 232);
  if (v34)
    v34(*(_QWORD *)(v32 + 320 * v42 + 288));
  dropThreadId(v43, 0, v8);
  v18 = v30;
LABEL_30:
  if (!v44)
    *(_DWORD *)(a1 + 4568) = 22;
  _data_map64_unlock(a1);
  result = v18;
  if (!v18)
    goto LABEL_2;
  return result;
}

_QWORD *bit_vector_create(CFIndex a1)
{
  _QWORD *v2;
  _QWORD *v3;
  const __CFAllocator *v4;
  __CFBitVector *Mutable;
  char *v7;
  char *v8;
  const char *v9;
  char *v10;
  const char *v11;
  uint64_t v12;

  v2 = malloc_type_malloc(0x18uLL, 0x10200403ED2C137uLL);
  if (!v2)
  {
    v7 = __si_assert_copy_extra_268();
    v8 = v7;
    v9 = "";
    if (v7)
      v9 = v7;
    __message_assert(v7, "bit_vector.h", 41, "bv", v9);
LABEL_12:
    free(v8);
    if (__valid_fs(-1))
      v12 = 2989;
    else
      v12 = 3072;
    *(_DWORD *)v12 = -559038737;
    abort();
  }
  v3 = v2;
  v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (a1 <= 128)
    a1 = 128;
  *v3 = 0;
  v3[1] = a1;
  Mutable = CFBitVectorCreateMutable(v4, a1);
  v3[2] = Mutable;
  CFBitVectorSetCount(Mutable, a1);
  if (!v3[2])
  {
    v10 = __si_assert_copy_extra_268();
    v8 = v10;
    v11 = "";
    if (v10)
      v11 = v10;
    __message_assert(v10, "bit_vector.h", 47, "bv->_cfbv", v11);
    goto LABEL_12;
  }
  return v3;
}

uint64_t _data_map64_garbage_compact_collect(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  char v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  char *v11;
  _QWORD *sibling_protected;
  _DWORD *v13;
  char *v14;
  _DWORD *v15;
  unsigned int v16;
  int v17;
  unint64_t v18;
  unsigned int v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  void (*v23)(_QWORD);
  _DWORD *v24;
  int v25;
  NSObject *v26;
  int v27;
  NSObject *v28;
  unsigned int v29;
  uint64_t v30;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t result;
  unint64_t v35;
  uint64_t v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  int v40;
  NSObject *v41;
  char *v42;
  uint64_t v43;
  NSObject *v44;
  const char *v45;
  int v46;
  NSObject *v47;
  NSObject *v48;
  unint64_t v49;
  char *v50;
  int v51;
  int v52;
  unint64_t v53;
  NSObject *v54;
  NSObject *v55;
  const char *v56;
  uint32_t v57;
  unint64_t v58;
  char *v59;
  NSObject *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  unsigned int v65;
  uint64_t v66;
  void (*v67)(_QWORD);
  char *v68;
  char *v69;
  const char *v70;
  uint64_t v71;
  uint64_t v72;
  int v73;
  int v74;
  unint64_t v75;
  char v76;
  uint64_t v77;
  uint64_t v78;
  unint64_t v79;
  unsigned int v80;
  unsigned int v81;
  unint64_t v82;
  unsigned int v83;
  unsigned int v84;
  _QWORD v85[2];
  char v86;
  _DWORD *__src[522];
  char v88;
  __int128 v89;
  uint64_t v90;
  _DWORD *v91;
  __int128 v92;
  char v93[1024];
  char v94[1024];
  int v95;
  const char *v96;
  __int16 v97;
  int v98;
  __int16 v99;
  unint64_t v100;
  __int16 v101;
  unint64_t v102;
  __int16 v103;
  uint64_t v104;
  __int16 v105;
  char *v106;
  _QWORD v107[6];
  __int128 v108;
  __int128 v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  __int128 v117;
  __int128 v118;
  __int128 v119;
  __int128 v120;
  uint64_t v121;
  CFRange v122;

  v1 = MEMORY[0x1E0C80A78](a1);
  v3 = v2;
  v76 = v4;
  v75 = v5;
  v7 = v6;
  v8 = v1;
  v121 = *MEMORY[0x1E0C80C00];
  v9 = *(_QWORD *)(v1 + 4496);
  v10 = v9 - 1;
  bzero(v94, 0x400uLL);
  bzero(v93, 0x400uLL);
  v122.location = 0;
  *(_DWORD *)v3 = 1684300900;
  *(_QWORD *)(v3 + 8) = 0;
  *(_QWORD *)(v3 + 16) = v9;
  v122.length = v9 - 1;
  *(_QWORD *)(v3 + 24) = CFBitVectorGetCountOfBit(*(CFBitVectorRef *)(v7 + 16), v122, 1u);
  bzero(__src, 0x1050uLL);
  __src[519] = (_DWORD *)-1;
  v11 = fd_name(*(_QWORD *)(v8 + 272), v94, 0x400uLL);
  snprintf(v93, 0x400uLL, "tmp.%s", v11);
  sibling_protected = fd_create_sibling_protected(*(_QWORD *)(v8 + 272), v93, 1538, 0);
  if (fd_truncate((uint64_t)sibling_protected, *(_QWORD *)(v8 + 280)) == -1)
    goto LABEL_15;
  v13 = *(_DWORD **)(v8 + 280);
  WORD2(__src[3]) = 256;
  __src[0] = sibling_protected;
  __src[1] = v13;
  LODWORD(__src[3]) = 1;
  __src[4] = 0;
  LOBYTE(__src[5]) = 26;
  bzero(&__src[6], 0x1000uLL);
  v14 = fd_name(*(_QWORD *)(v8 + 4416), v94, 0x400uLL);
  snprintf(v93, 0x400uLL, "tmp.%s", v14);
  __src[518] = fd_create_sibling_protected(*(_QWORD *)(v8 + 4416), v93, 1538, 0);
  if (fd_truncate((uint64_t)__src[518], *(_QWORD *)(v8 + 4432)) == -1)
  {
LABEL_15:
    v29 = *__error();
    if (v29)
      v30 = v29;
    else
      v30 = 0xFFFFFFFFLL;
    goto LABEL_18;
  }
  __src[521] = *(_DWORD **)(v8 + 4432);
  __src[519] = (_DWORD *)fd_mmap((uint64_t)__src[518]);
  if (__src[519] == (_DWORD *)-1)
  {
    v27 = *__error();
    v28 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
    {
      LODWORD(v107[0]) = 136315394;
      *(_QWORD *)((char *)v107 + 4) = "_data_map64_garbage_compact_collect";
      WORD2(v107[1]) = 1024;
      *(_DWORD *)((char *)&v107[1] + 6) = 2756;
      _os_log_error_impl(&dword_1B8270000, v28, OS_LOG_TYPE_ERROR, "%s:%d: offsets fd_mmap error", (uint8_t *)v107, 0x12u);
    }
    *__error() = v27;
    goto LABEL_15;
  }
  __src[520] = *(_DWORD **)(v8 + 4424);
  data_entry_store((uint64_t)__src, dword_1E6E38348);
  v15 = __src[519];
  *(_QWORD *)__src[519] = 0;
  *((_QWORD *)v15 + 1) = 0;
  v86 = 0;
  v90 = 0;
  v92 = 0u;
  v89 = 0u;
  v91 = v15;
  *(_DWORD **)&v92 = __src[520];
  v85[0] = 2;
  v85[1] = &v89;
  do
  {
    v16 = __ldxr(exceptionSequenceNum);
    v17 = v16 + 1;
  }
  while (__stxr(v16 + 1, exceptionSequenceNum));
  v18 = setThreadIdAndInfo(-1, (__int128 *)sMappingExceptionCallbacks, (uint64_t)v85, 0x40000000, v17);
  v83 = HIDWORD(v18);
  v84 = v18;
  v82 = __PAIR64__(v19, v20);
  v21 = *(_QWORD *)&threadData[18 * v18 + 2];
  v22 = v21 + 320 * HIDWORD(v18);
  *(_BYTE *)(v22 + 216) = 0;
  v73 = *(_DWORD *)(v22 + 312);
  v23 = *(void (**)(_QWORD))(v22 + 224);
  if (v23)
    v23(*(_QWORD *)(v21 + 320 * HIDWORD(v18) + 288));
  v74 = v17;
  v81 = v84;
  v80 = v83;
  v79 = v82;
  if (_setjmp((int *)v22))
  {
    v24 = (_DWORD *)(v22 + 312);
    v25 = *__error();
    v26 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      LODWORD(v107[0]) = 136315394;
      *(_QWORD *)((char *)v107 + 4) = "_data_map64_garbage_compact_collect";
      WORD2(v107[1]) = 1024;
      *(_DWORD *)((char *)&v107[1] + 6) = 2826;
      _os_log_error_impl(&dword_1B8270000, v26, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", (uint8_t *)v107, 0x12u);
    }
    *__error() = v25;
    *v24 = v73;
    CIOnThreadCleanUpReset(v79);
    dropThreadId(v81, 1, v17);
    CICleanUpReset(v81, HIDWORD(v79));
    goto LABEL_79;
  }
  if (v10)
  {
    v35 = 1;
    v72 = v7;
    do
    {
      if (*(_QWORD *)(v8 + 4496) <= v35)
      {
        v119 = 0u;
        v120 = 0u;
        v117 = 0u;
        v118 = 0u;
        v115 = 0u;
        v116 = 0u;
        v113 = 0u;
        v114 = 0u;
        v111 = 0u;
        v112 = 0u;
        v109 = 0u;
        v110 = 0u;
        v108 = 0u;
        memset(v107, 0, sizeof(v107));
        v46 = *__error();
        v47 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
        {
          v49 = *(_QWORD *)(v8 + 4496);
          v50 = fd_name(*(_QWORD *)(v8 + 240), (char *)v107, 0x100uLL);
          v95 = 136316418;
          v96 = "_data_map64_get_offset_entry";
          v97 = 1024;
          v98 = 362;
          v99 = 2048;
          v100 = v35;
          v101 = 2048;
          v102 = v49;
          v103 = 2048;
          v104 = v8;
          v105 = 2080;
          v106 = v50;
          _os_log_error_impl(&dword_1B8270000, v47, OS_LOG_TYPE_ERROR, "%s:%d: invalid data id %lld max %lld %p %s", (uint8_t *)&v95, 0x3Au);
        }
        *__error() = v46;
        goto LABEL_43;
      }
      v36 = *(_QWORD *)(v8 + 4440);
      if (v36)
      {
        v37 = *(_QWORD *)(v36 + 16 * v35);
        if (v37 >= 2)
        {
          v38 = *(_QWORD *)(v36 + 16 * v35);
          v77 = 0;
          v78 = 0;
          v88 = 0;
          v39 = *(_QWORD *)(v8 + 288);
          if (v39 <= v37)
          {
            v119 = 0u;
            v120 = 0u;
            v117 = 0u;
            v118 = 0u;
            v115 = 0u;
            v116 = 0u;
            v113 = 0u;
            v114 = 0u;
            v111 = 0u;
            v112 = 0u;
            v109 = 0u;
            v110 = 0u;
            v108 = 0u;
            memset(v107, 0, sizeof(v107));
            v40 = *__error();
            v48 = _SILogForLogForCategory(0);
            if (!os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
              goto LABEL_42;
            v58 = *(_QWORD *)(v8 + 288);
            v59 = fd_name(*(_QWORD *)(v8 + 240), (char *)v107, 0x100uLL);
            v95 = 136316418;
            v96 = "_data_map64_get_data_entry";
            v97 = 1024;
            v98 = 379;
            v99 = 2048;
            v100 = v38;
            v101 = 2048;
            v102 = v58;
            v103 = 2048;
            v104 = v8;
            v105 = 2080;
            v106 = v59;
            v44 = v48;
            v45 = "%s:%d: invalid data offset 0x%lx 0x%lx %p %s";
            goto LABEL_67;
          }
          data_entry_restore(v8 + 272, v37, v39, (unsigned int *)&v77, &v88);
          if (v88)
          {
            v119 = 0u;
            v120 = 0u;
            v117 = 0u;
            v118 = 0u;
            v115 = 0u;
            v116 = 0u;
            v113 = 0u;
            v114 = 0u;
            v111 = 0u;
            v112 = 0u;
            v109 = 0u;
            v110 = 0u;
            v108 = 0u;
            memset(v107, 0, sizeof(v107));
            v40 = *__error();
            v41 = _SILogForLogForCategory(0);
            if (!os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
              goto LABEL_42;
            v42 = fd_name(*(_QWORD *)(v8 + 240), (char *)v107, 0x100uLL);
            v43 = *(_QWORD *)(v8 + 288);
            v95 = 136316418;
            v96 = "_data_map64_get_data_entry";
            v97 = 1024;
            v98 = 375;
            v99 = 2080;
            v100 = (unint64_t)v42;
            v101 = 2048;
            v102 = v38;
            v103 = 2048;
            v104 = v43;
            v105 = 2048;
            v106 = (char *)v77;
            v44 = v41;
            v45 = "%s:%d: data_entry_restore failure: %s off: 0x%lx end: 0x%lx sz: 0x%lx";
LABEL_67:
            _os_log_error_impl(&dword_1B8270000, v44, OS_LOG_TYPE_ERROR, v45, (uint8_t *)&v95, 0x3Au);
            goto LABEL_42;
          }
          if (v35 < v75)
            goto LABEL_50;
          if ((v35 & 0x8000000000000000) != 0)
          {
            v68 = __si_assert_copy_extra_268();
            v69 = v68;
            v70 = "";
            if (v68)
              v70 = v68;
            __message_assert(v68, "bit_vector.h", 96, "bitIndex >= 0", v70);
            free(v69);
            if (__valid_fs(-1))
              v71 = 2989;
            else
              v71 = 3072;
            *(_DWORD *)v71 = -559038737;
            abort();
          }
          if (*(_QWORD *)v72 > (int64_t)v35 && CFBitVectorGetBitAtIndex(*(CFBitVectorRef *)(v72 + 16), v35))
          {
LABEL_50:
            *(_QWORD *)(v36 + 16 * v35 + 8) = *(_QWORD *)(*(_QWORD *)(v8 + 4440) + 16 * v35 + 8);
            if ((v77 & 0x3F80) != 0)
              v51 = 2;
            else
              v51 = 1;
            if ((v77 & 0x1FC000) != 0)
              v51 = 3;
            if ((v77 & 0xFE00000) != 0)
              v51 = 4;
            if (v77 >> 28)
              v52 = 5;
            else
              v52 = v51;
            _storageWindowsExpandBacking(__src, (v52 + v77) + 8);
            v53 = data_entry_store((uint64_t)__src, (unsigned int *)&v77);
            *(_QWORD *)&__src[519][4 * v35] = v53;
            goto LABEL_44;
          }
          ++*(_QWORD *)(v3 + 8);
          if ((v76 & 2) != 0)
          {
            if ((v76 & 8) != 0)
            {
              if (gSILogLevels[0] < 5)
                goto LABEL_43;
              v40 = *__error();
              v60 = _SILogForLogForCategory(0);
              if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
              {
                v61 = v78 + *(unsigned int *)(v8 + 220);
                LODWORD(v107[0]) = 67109890;
                HIDWORD(v107[0]) = v35;
                LOWORD(v107[1]) = 1024;
                *(_DWORD *)((char *)&v107[1] + 2) = v77;
                HIWORD(v107[1]) = 2080;
                v107[2] = v61;
                LOWORD(v107[3]) = 2048;
                *(_QWORD *)((char *)&v107[3] + 2) = v8;
                v55 = v60;
                v56 = "Deleting id: %d size: %d %s from %p";
                v57 = 34;
LABEL_71:
                _os_log_impl(&dword_1B8270000, v55, OS_LOG_TYPE_DEFAULT, v56, (uint8_t *)v107, v57);
              }
            }
            else
            {
              if (gSILogLevels[0] < 5)
                goto LABEL_43;
              v40 = *__error();
              v54 = _SILogForLogForCategory(0);
              if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
              {
                LODWORD(v107[0]) = 67109632;
                HIDWORD(v107[0]) = v35;
                LOWORD(v107[1]) = 1024;
                *(_DWORD *)((char *)&v107[1] + 2) = v77;
                HIWORD(v107[1]) = 2048;
                v107[2] = v8;
                v55 = v54;
                v56 = "Deleting id: %d size: %d from %p";
                v57 = 24;
                goto LABEL_71;
              }
            }
LABEL_42:
            *__error() = v40;
          }
        }
      }
LABEL_43:
      *(_OWORD *)&__src[519][4 * v35] = xmmword_1B8631BC0;
LABEL_44:
      ++v35;
    }
    while (v35 <= v10);
  }
  if (*(_QWORD *)(v3 + 8))
  {
    if (SLODWORD(__src[3]) >= 1)
    {
      v62 = 0;
      do
      {
        v63 = v62;
        storageWindowSync(__src[v62 + 6], 1);
        v62 = v63 + 1;
      }
      while (v63 + 1 < SLODWORD(__src[3]));
    }
    msync(__src[519], (size_t)__src[521], 16);
    memcpy((void *)(v3 + 32), __src, 0x1050uLL);
    v86 = 1;
    v64 = *(_QWORD *)&threadData[18 * v81 + 2];
    v65 = v80;
    v66 = v64 + 320 * v80;
    *(_DWORD *)(v66 + 312) = v73;
    v67 = *(void (**)(_QWORD))(v66 + 232);
    if (v67)
      v67(*(_QWORD *)(v64 + 320 * v65 + 288));
    dropThreadId(v81, 0, v74);
LABEL_79:
    v30 = 0;
    result = 0;
    if (v86)
      return result;
    goto LABEL_18;
  }
  v30 = 0;
LABEL_18:
  if (sibling_protected)
  {
    if (SLODWORD(__src[3]) >= 1)
    {
      v31 = (uint64_t *)&__src[6];
      v32 = 0;
      do
      {
        v33 = v32;
        storageWindowReleaseImmediate(v31);
        v32 = v33 + 1;
        ++v31;
      }
      while (v33 + 1 < SLODWORD(__src[3]));
    }
    fd_release((char *)sibling_protected);
    _fd_unlink_with_origin((uint64_t)sibling_protected, 0);
  }
  if ((unint64_t)__src[519] + 1 >= 2)
    munmap(__src[519], (size_t)__src[520]);
  if (__src[518])
  {
    fd_release((char *)__src[518]);
    _fd_unlink_with_origin((uint64_t)__src[518], 0);
  }
  return v30;
}

uint64_t my_vm_reallocate(void **a1, size_t a2, size_t a3, int a4, uint64_t a5)
{
  void *v10;
  void *v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t v17;
  _QWORD v18[6];
  char v19;

  v10 = *a1;
  v11 = mmap(0, a3, 3, 4098, a4 << 24, 0);
  *a1 = v11;
  if (!a2 || !v10)
  {
    if (v11 != (void *)-1)
    {
      v14 = (unint64_t *)((char *)&tag_sizes + 8 * (a4 - 240));
      do
        v15 = __ldxr(v14);
      while (__stxr(v15 + a3, v14));
      return 0;
    }
    return 3;
  }
  if (v11 == (void *)-1)
  {
    *a1 = v10;
    return 3;
  }
  v12 = (unint64_t *)((char *)&tag_sizes + 8 * (a4 - 240));
  do
    v13 = __ldxr(v12);
  while (__stxr(v13 + a3, v12));
  if (a2 <= 4 * *MEMORY[0x1E0C85AD8])
  {
    memcpy(*a1, v10, a2);
    if (a5)
      goto LABEL_8;
    do
LABEL_16:
      v17 = __ldxr(v12);
    while (__stxr(v17 - a2, v12));
    munmap(v10, a2);
    return 0;
  }
  vm_copy(*MEMORY[0x1E0C83DA0], (vm_address_t)v10, a2, (vm_address_t)*a1);
  if (!a5)
    goto LABEL_16;
LABEL_8:
  v18[0] = MEMORY[0x1E0C809B0];
  v18[1] = 0x40000000;
  v18[2] = __my_vm_reallocate_block_invoke;
  v18[3] = &__block_descriptor_tmp_5312;
  v18[4] = v10;
  v18[5] = a2;
  v19 = a4;
  (*(void (**)(uint64_t, _QWORD *))(a5 + 16))(a5, v18);
  return 0;
}

uint64_t __my_vm_reallocate_block_invoke(uint64_t a1)
{
  void *v2;
  size_t v3;
  unsigned int v4;
  unint64_t *v5;
  unint64_t v6;

  v2 = *(void **)(a1 + 32);
  v3 = *(_QWORD *)(a1 + 40);
  v4 = *(unsigned __int8 *)(a1 + 48) - 240;
  if (v4 <= 0x10)
  {
    v5 = (unint64_t *)((char *)&tag_sizes + 8 * v4);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 - v3, v5));
  }
  return munmap(v2, v3);
}

void slab_vm_deallocate(void *a1, size_t a2, int a3)
{
  unint64_t v6;
  unint64_t v7;
  _QWORD *v8;
  OSQueueHead *v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t v12;
  size_t *v13;
  _QWORD *v14;
  unint64_t v15;
  unsigned int v16;
  unint64_t *v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t *v21;
  unint64_t v22;

  if (a3 == 250)
  {
    if (a2 != 0x100000)
    {
      v13 = (size_t *)MEMORY[0x1E0C85AD8];
      if (*MEMORY[0x1E0C85AD8] == a2)
      {
        v14 = node_alloc();
        v14[1] = a1;
        madvise(a1, *v13, 5);
        do
          v15 = __ldxr(qword_1EDBBE0C0);
        while (__stxr(v15 - a2, qword_1EDBBE0C0));
        v9 = &stru_1EDBBE030;
        v8 = v14;
        goto LABEL_26;
      }
      goto LABEL_29;
    }
    madvise(a1, 0x100000uLL, 5);
    do
      v6 = __ldxr(qword_1EDBBE0C0);
    while (__stxr(v6 - 0x100000, qword_1EDBBE0C0));
    do
      v7 = __ldaxr(qword_1EDBBE050);
    while (__stlxr(v7 + 1, qword_1EDBBE050));
    if (v7 <= 4)
    {
      v8 = node_alloc();
      v8[1] = a1;
      v9 = &stru_1EDBBE040;
LABEL_26:
      OSAtomicEnqueue(v9, v8, 0);
      return;
    }
    v17 = qword_1EDBBE050;
    goto LABEL_28;
  }
  if ((a3 - 243) <= 4)
  {
    if (a2 != 0x100000)
    {
      if (*MEMORY[0x1E0C85AD8] == a2)
      {
        v8 = node_alloc();
        v8[1] = a1;
        v18 = (unint64_t *)((char *)&tag_sizes + 8 * (a3 - 240));
        do
          v19 = __ldxr(v18);
        while (__stxr(v19 - a2, v18));
        v9 = &stru_1EDBBDE20;
        goto LABEL_26;
      }
      goto LABEL_29;
    }
    v10 = (unint64_t *)((char *)&tag_sizes + 8 * (a3 - 240));
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 - 0x100000, v10));
    do
      v12 = __ldaxr(qword_1EDBBDE40);
    while (__stlxr(v12 + 1, qword_1EDBBDE40));
    if (v12 <= 4)
    {
      v8 = node_alloc();
      v8[1] = a1;
      v9 = &stru_1EDBBDE30;
      goto LABEL_26;
    }
    v17 = qword_1EDBBDE40;
    do
LABEL_28:
      v20 = __ldaxr(v17);
    while (__stlxr(v20 - 1, v17));
LABEL_29:
    v16 = a3 - 240;
LABEL_30:
    v21 = (unint64_t *)((char *)&tag_sizes + 8 * v16);
    do
      v22 = __ldxr(v21);
    while (__stxr(v22 - a2, v21));
    goto LABEL_32;
  }
  v16 = a3 - 240;
  if ((a3 - 240) <= 0x10)
    goto LABEL_30;
LABEL_32:
  munmap(a1, a2);
}

BOOL _writepos_match_address(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  BOOL v4;

  v2 = *(_QWORD *)(a1 + 8);
  v4 = v2 > a2;
  v3 = v2 + 0x100000;
  return !v4 && v3 > a2;
}

uint64_t _writepos_exception_cleanup(uint64_t a1)
{
  return munmap(*(void **)(a1 + 8), 0x100000uLL);
}

BOOL _merge_match_address(unint64_t *a1, unint64_t a2)
{
  return *a1 <= a2 && a1[2] + *a1 > a2;
}

uint64_t _merge_exception_cleanup(uint64_t a1)
{
  return munmap(*(void **)a1, *(_QWORD *)(a1 + 16));
}

void *packContextInit(uint64_t a1)
{
  void *result;

  *(_QWORD *)(a1 + 80) = 0;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_DWORD *)(a1 + 40) = 16;
  *(_QWORD *)(a1 + 32) = malloc_type_malloc(0x80uLL, 0x2004093837F09uLL);
  *(_DWORD *)(a1 + 56) = 16;
  *(_QWORD *)(a1 + 48) = malloc_type_malloc(0x80uLL, 0x100004000313F17uLL);
  *(_DWORD *)(a1 + 72) = 16;
  result = malloc_type_malloc(0x10uLL, 0x100004077774924uLL);
  *(_QWORD *)(a1 + 64) = result;
  return result;
}

void packContextDestroy(void **a1)
{
  void **v1;

  v1 = a1 + 4;
  free(*a1);
  FlattenPostingsContextDestroy(v1);
}

uint64_t mergeIndexData(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  void **v4;
  void **v5;
  const char *v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  const __CFAllocator *v12;
  CFMutableDictionaryRef Mutable;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  NSObject *v37;
  os_log_type_t v38;
  __int128 v39;
  uint64_t v40;
  int v41;
  NSObject *v42;
  os_log_type_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  __int16 v48;
  uint64_t v49;
  CFMutableDictionaryRef v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  __int16 v55;
  const __CFAllocator *v57;
  uint64_t v58;
  _DWORD *v59;
  unint64_t v60;
  const CFDictionaryValueCallBacks *v61;
  uint64_t v62;
  char *v63;
  char *v64;
  char *v65;
  unsigned int v66;
  int v67;
  unint64_t v68;
  int v69;
  int v70;
  uint64_t v71;
  uint64_t v72;
  void (*v73)(_QWORD);
  void **v74;
  int v75;
  NSObject *v76;
  int v77;
  NSObject *v78;
  os_log_type_t v79;
  _BOOL4 v80;
  const char *v81;
  uint64_t v82;
  unsigned int v83;
  char v84;
  unsigned int v85;
  unsigned int v86;
  const __CFDictionary *v87;
  int v88;
  NSObject *v89;
  uint64_t v90;
  __int128 v91;
  uint64_t *v92;
  uint64_t v93;
  uint64_t v94;
  int v95;
  NSObject *v96;
  _QWORD *v97;
  uint64_t v98;
  BOOL v99;
  uint64_t v100;
  uint64_t v101;
  unsigned int v102;
  char v103;
  char v105;
  int v106;
  NSObject *v107;
  unsigned int v108;
  char v109;
  unsigned int v110;
  unsigned int v111;
  size_t v112;
  char *v113;
  uint64_t v114;
  size_t v115;
  char *v116;
  uint64_t *v117;
  _DWORD *v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  void *v122;
  void *v123;
  __int128 v124;
  uint64_t v125;
  uint64_t v126;
  size_t v127;
  void *v128;
  BOOL v129;
  char *v130;
  _QWORD *v131;
  void **v132;
  uint64_t v133;
  uint64_t v134;
  unsigned int v135;
  int v136;
  unint64_t v137;
  int v138;
  int v139;
  uint64_t v140;
  uint64_t v141;
  int v142;
  void (*v143)(_QWORD);
  int v144;
  NSObject *v145;
  uint64_t v146;
  int v147;
  NSObject *v148;
  os_log_type_t v149;
  uint64_t v150;
  unint64_t v151;
  _QWORD *v152;
  int v153;
  uint64_t v154;
  uint64_t v155;
  unsigned int v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  int v161;
  uint64_t v162;
  unint64_t v163;
  int v164;
  unint64_t v165;
  uint64_t v166;
  uint64_t v167;
  int v168;
  uint64_t v169;
  int v170;
  uint64_t v171;
  unint64_t v172;
  uint64_t v173;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  unsigned int v178;
  uint64_t v179;
  void (*v180)(_QWORD);
  __int128 v181;
  uint64_t v182;
  int v183;
  char *v184;
  uint64_t v185;
  _DWORD *v186;
  char *v187;
  unsigned int **v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  unsigned int v193;
  int v194;
  unsigned int v195;
  int v196;
  uint64_t *v197;
  int v198;
  unsigned int v199;
  uint64_t v200;
  int v201;
  unsigned int v202;
  int v203;
  unint64_t v204;
  int v205;
  int v206;
  uint64_t v207;
  uint64_t v208;
  int v209;
  void (*v210)(_QWORD);
  int8x8_t v211;
  int v212;
  int v213;
  NSObject *v214;
  int v215;
  int v216;
  int v217;
  NSObject *v218;
  os_log_type_t v219;
  _BOOL4 v220;
  unint64_t v221;
  int v222;
  uint64_t v223;
  int v224;
  int v225;
  unsigned int v226;
  uint64_t v227;
  int v228;
  unsigned int v229;
  unsigned int v230;
  unsigned int *v231;
  _QWORD *v232;
  uint64_t v233;
  uint64_t v234;
  _QWORD *v235;
  int v236;
  unint64_t v237;
  int v238;
  unint64_t v239;
  uint64_t v240;
  uint64_t v241;
  unint64_t v242;
  uint64_t v243;
  int v244;
  unint64_t v245;
  uint64_t v246;
  uint64_t v248;
  unsigned int v249;
  uint64_t v250;
  void (*v251)(_QWORD);
  unsigned int v252;
  unsigned int v253;
  uint64_t v254;
  CFMutableSetRef v255;
  unint64_t v256;
  int v257;
  os_log_t *v258;
  unsigned int v259;
  size_t v260;
  unint64_t v261;
  uint64_t v262;
  unsigned int v263;
  int v264;
  unint64_t v265;
  unsigned int v266;
  unsigned int v267;
  uint64_t v268;
  uint64_t v269;
  void (*v270)(_QWORD);
  _DWORD *v271;
  int v272;
  NSObject *v273;
  unint64_t v274;
  off_t v275;
  uint64_t *v276;
  int v277;
  int v278;
  NSObject *v279;
  unint64_t v280;
  _QWORD *v281;
  uint64_t v282;
  uint64_t v283;
  _QWORD *v284;
  _QWORD *v285;
  _QWORD *v286;
  uint64_t *v287;
  uint64_t v288;
  char v289;
  _DWORD *v290;
  uint64_t v291;
  uint64_t v292;
  uint64_t v293;
  _DWORD *v294;
  void **v295;
  uint64_t v296;
  uint64_t v297;
  uint64_t v298;
  _QWORD *v299;
  _QWORD *v300;
  void *v301;
  void *v302;
  void *v303;
  uint64_t v304;
  char v305;
  uint64_t v306;
  uint64_t v307;
  unsigned int v308;
  int v309;
  unint64_t v310;
  int v311;
  int v312;
  uint64_t v313;
  uint64_t v314;
  void (*v315)(_QWORD);
  _DWORD *v316;
  int v317;
  NSObject *v318;
  uint64_t v319;
  char *v320;
  unsigned int v321;
  int v322;
  unint64_t v323;
  int v324;
  int v325;
  uint64_t v326;
  uint64_t v327;
  void (*v328)(_QWORD);
  _DWORD *v329;
  int v330;
  NSObject *v331;
  int v332;
  unint64_t **v333;
  uint64_t v334;
  uint64_t v335;
  uint64_t v336;
  _OWORD *v337;
  unsigned int v338;
  int v339;
  unint64_t v340;
  int v341;
  int v342;
  uint64_t v343;
  uint64_t v344;
  void (*v345)(_QWORD);
  int v346;
  __int128 v347;
  __int128 v348;
  void **v349;
  _DWORD *v350;
  int v351;
  NSObject *v352;
  int v353;
  uint64_t v354;
  unint64_t v355;
  int v356;
  unint64_t v357;
  int v358;
  unint64_t v359;
  unsigned int v360;
  char v361;
  char v362;
  uint64_t *v363;
  uint64_t v364;
  unint64_t v365;
  off_t v366;
  uint64_t v367;
  off_t v368;
  ssize_t v369;
  unint64_t v370;
  uint64_t v371;
  unint64_t v372;
  uint64_t *v373;
  uint64_t v374;
  uint64_t *v375;
  unint64_t v376;
  char *v377;
  unint64_t v378;
  void **v379;
  unint64_t v380;
  uint64_t v381;
  uint64_t v382;
  uint64_t v383;
  unint64_t v384;
  char *v385;
  _DWORD *v386;
  uint64_t v387;
  uint64_t v388;
  unsigned int v389;
  unint64_t v390;
  uint64_t v391;
  uint64_t v392;
  BOOL v393;
  unint64_t v394;
  unint64_t v395;
  uint64_t v396;
  unint64_t v397;
  uint64_t v398;
  size_t v399;
  unint64_t v400;
  uint64_t v401;
  uint64_t v402;
  uint64_t v403;
  uint64_t v404;
  uint64_t v405;
  unint64_t v406;
  unint64_t v407;
  unint64_t v408;
  int v409;
  NSObject *v410;
  char *v411;
  _BYTE *v412;
  unint64_t v413;
  uint64_t v414;
  uint64_t v415;
  uint64_t v416;
  uint64_t v417;
  unint64_t v418;
  uint64_t v419;
  uint64_t v420;
  int v421;
  int v422;
  int v423;
  uint64_t v424;
  char v425;
  uint64_t v426;
  unsigned int v427;
  uint64_t v428;
  uint64_t v429;
  int v430;
  int v431;
  uint64_t v432;
  int v433;
  int v434;
  uint64_t v435;
  int v436;
  int v437;
  uint64_t v438;
  int v439;
  int v440;
  uint64_t v441;
  int v442;
  int v443;
  int v444;
  uint64_t v445;
  uint64_t v446;
  int v447;
  int v448;
  int v449;
  char *v450;
  size_t v451;
  BOOL v452;
  int v453;
  uint64_t v454;
  uint64_t v455;
  unint64_t DocID;
  unsigned int v457;
  uint64_t v458;
  unint64_t v459;
  uint64_t v460;
  unsigned int v461;
  uint64_t v462;
  int v463;
  char v464;
  int v465;
  NSObject *v466;
  int v467;
  int v468;
  uint64_t v469;
  unsigned int v470;
  _OWORD *v471;
  int v472;
  int DataForOneDocument;
  unsigned int v474;
  int v475;
  NSObject *v476;
  int v477;
  int v478;
  int v479;
  char *v480;
  int v481;
  char *v482;
  int v483;
  int v484;
  int v485;
  int v486;
  int v487;
  unint64_t v488;
  int v489;
  int v490;
  unsigned int v491;
  char *v492;
  int v493;
  int v494;
  int v495;
  int v496;
  NSObject *v497;
  int *v498;
  int v499;
  unsigned int v500;
  unint64_t v501;
  unint64_t v502;
  int v504;
  NSObject *v505;
  int v506;
  unsigned int v507;
  uint64_t v508;
  unsigned int *v509;
  unsigned int v510;
  uint64_t v511;
  unsigned int v512;
  unsigned int v513;
  char *v514;
  uint64_t *v515;
  uint64_t v516;
  _QWORD *v517;
  uint64_t v518;
  unint64_t v519;
  uint64_t *v520;
  unint64_t v521;
  off_t v522;
  int v523;
  size_t v524;
  int v525;
  NSObject *v526;
  int v527;
  NSObject *v528;
  int v529;
  uint64_t v530;
  uint64_t v531;
  uint64_t v532;
  uint64_t *v533;
  uint64_t v534;
  int v535;
  int v536;
  int *v537;
  int v538;
  uint64_t v539;
  unint64_t v540;
  unint64_t v541;
  uint64_t v542;
  char *v543;
  uint64_t v544;
  uint64_t v545;
  uint64_t v546;
  uint64_t v547;
  unsigned int v548;
  uint64_t v549;
  void (*v550)(_QWORD);
  uint64_t v551;
  unsigned int v552;
  uint64_t v553;
  void (*v554)(_QWORD);
  uint64_t v555;
  unsigned int v556;
  uint64_t v557;
  void (*v558)(_QWORD);
  uint64_t v559;
  unsigned int v560;
  uint64_t v561;
  void (*v562)(_QWORD);
  _QWORD *v563;
  uint64_t v564;
  uint64_t *v565;
  uint64_t v566;
  uint64_t v567;
  uint64_t v568;
  uint64_t v569;
  void **v570;
  unsigned int v571;
  char v572;
  uint64_t *v573;
  uint64_t v574;
  uint64_t v575;
  off_t v576;
  CFMutableDictionaryRef v577;
  NSObject *v578;
  os_signpost_id_t v579;
  int v580;
  BOOL v581;
  NSObject *v582;
  NSObject *v583;
  unsigned int v584;
  char v585;
  unsigned int v586;
  uint64_t v587;
  const void *v588;
  __int128 v589;
  uint64_t *v590;
  uint64_t v591;
  uint64_t v592;
  int v593;
  NSObject *v594;
  _QWORD *v595;
  _QWORD *v596;
  uint64_t v597;
  unsigned int v598;
  uint64_t v599;
  void (*v600)(_QWORD);
  uint64_t v601;
  CFDictionaryRef v602;
  int v603;
  NSObject *v604;
  uint64_t *v605;
  uint64_t v606;
  uint64_t v607;
  uint64_t v608;
  uint64_t v609;
  void **v610;
  void (*v611)(uint64_t, const char *, uint64_t, const char *, const char *, uint64_t);
  uint64_t v612;
  const char *v613;
  const char *v614;
  uint64_t v615;
  int v616;
  NSObject *v617;
  os_log_type_t v618;
  const char *v619;
  int *v620;
  uint64_t v621;
  uint64_t v622;
  uint64_t v623;
  uint64_t v624;
  uint64_t i;
  uint64_t v626;
  uint64_t v627;
  uint64_t j;
  uint64_t v629;
  uint64_t v630;
  uint64_t k;
  unint64_t v632;
  uint64_t v633;
  uint64_t v634;
  uint64_t v635;
  unint64_t v636;
  uint64_t v637;
  void *v638;
  int v639;
  NSObject *v640;
  os_log_type_t v641;
  uint64_t v642;
  char *v643;
  char *v644;
  const char *v645;
  uint64_t v646;
  char *v647;
  char *v648;
  const char *v649;
  char *v650;
  char *v651;
  const char *v652;
  char *v653;
  const char *v654;
  char *v655;
  char *v656;
  char *v657;
  const char *v658;
  char *v659;
  const char *v660;
  char *v661;
  const char *v662;
  char *v663;
  char *v664;
  char *v665;
  uint64_t v666;
  char *v667;
  const char *v668;
  char *v669;
  const char *v670;
  char *v671;
  const char *v672;
  char *v673;
  const char *v674;
  char *v675;
  const char *v676;
  char *v677;
  const char *v678;
  char *v679;
  const char *v680;
  char *v681;
  const char *v682;
  char *v683;
  const char *v684;
  char *v685;
  const char *v686;
  uint64_t v687;
  char *v688;
  const char *v689;
  char *v690;
  char *v691;
  const char *v692;
  uint64_t v693;
  uint64_t v694;
  os_log_t v695;
  int v696;
  __int128 v697;
  unsigned int v698;
  _DWORD *v699;
  uint64_t v700;
  __int128 v701;
  __int128 v702;
  uint64_t v703;
  uint64_t v704;
  uint64_t v705;
  uint64_t v706;
  uint64_t v707;
  uint64_t v708;
  uint64_t v709;
  uint64_t v710;
  uint64_t v711;
  uint64_t v712;
  uint64_t v713;
  uint64_t v714;
  uint64_t v715;
  uint64_t v716;
  uint64_t v717;
  uint64_t v718;
  uint64_t v719;
  uint64_t v720;
  uint64_t v721;
  uint64_t v722;
  int v723;
  unint64_t v724;
  uint64_t v725;
  uint64_t v726;
  uint64_t v727;
  _QWORD *v728;
  _QWORD *v729;
  uint64_t v730;
  uint64_t v731;
  uint64_t v732;
  uint64_t v733;
  uint64_t v734;
  uint64_t v735;
  uint64_t v736;
  uint64_t v737;
  malloc_type_id_t v738;
  size_t v739;
  malloc_type_id_t v740;
  uint64_t v741;
  uint64_t v742;
  uint64_t v743;
  uint64_t v744;
  uint64_t v745;
  uint64_t v746;
  uint64_t v747;
  uint64_t v748;
  uint64_t v749;
  uint64_t v750;
  uint64_t v751;
  CFMutableDictionaryRef v752;
  uint64_t v753;
  uint64_t v754;
  unsigned int v755;
  uint64_t v756;
  uint64_t v757;
  uint64_t v758;
  uint64_t v759;
  uint64_t v760;
  uint64_t v761;
  uint64_t v762;
  uint64_t v763;
  uint64_t v764;
  uint64_t v765;
  uint64_t v766;
  char *v767;
  uint64_t v768;
  uint64_t v769;
  uint64_t v770;
  uint64_t v771;
  uint64_t v772;
  uint64_t v773;
  uint64_t v774;
  uint64_t v775;
  uint64_t v776;
  uint64_t v777;
  const __CFAllocator *v778;
  uint64_t v779;
  uint64_t v780;
  uint64_t v781;
  uint64_t v782;
  uint64_t v783;
  uint64_t v784;
  uint64_t v785;
  uint64_t v786;
  uint64_t v787;
  uint64_t v788;
  uint64_t v789;
  uint64_t v790;
  uint64_t v791;
  uint64_t v792;
  uint64_t v793;
  uint64_t v794;
  uint64_t v795;
  uint64_t v796;
  uint64_t v797;
  uint64_t v798;
  uint64_t v799;
  uint64_t v800;
  size_t v801;
  uint64_t v802;
  uint64_t v803;
  uint64_t v804;
  uint64_t v805;
  uint64_t v806;
  int v807;
  int v808;
  unsigned int v809;
  int v810;
  __int128 v811;
  uint64_t v812;
  unsigned int v813;
  unsigned int v814;
  malloc_type_id_t v815;
  size_t v816;
  uint64_t v817;
  char *v818;
  __int128 v819;
  uint64_t v820;
  unsigned int v821;
  unsigned int v822;
  uint64_t v823;
  uint64_t v824;
  CFMutableSetRef v825;
  uint64_t v826;
  unint64_t v827;
  unint64_t v828;
  uint64_t v829;
  unint64_t v830;
  unint64_t *v831;
  uint64_t v832;
  unint64_t v833;
  uint64_t v834;
  uint64_t v835;
  unsigned int v836;
  uint64_t v837;
  void **v838;
  char *v839;
  uint64_t v840;
  _DWORD *v841;
  unsigned int v842;
  uint64_t v843;
  uint64_t *v844;
  uint64_t v845;
  unint64_t v846;
  uint64_t v847;
  unint64_t v848;
  os_log_t *v849;
  unint64_t v850;
  unint64_t v851;
  unsigned int v852;
  size_t v853;
  uint64_t v854;
  uint64_t v855;
  __int128 v856;
  __int128 v857;
  __int128 v858;
  malloc_type_id_t v859;
  __int128 v860;
  __int128 v861;
  __int128 v862;
  size_t v863;
  __int128 v864;
  __int128 v865;
  __int128 v866;
  uint64_t v867;
  int v868;
  uint64_t v869;
  char *v870;
  char *v871;
  uint64_t *v872;
  uint64_t *v873;
  unint64_t v874;
  int v875;
  unint64_t v876;
  int v877;
  char *v878;
  unint64_t v879;
  unint64_t v880;
  int v881;
  int v882;
  unsigned int *v883;
  uint64_t v884;
  uint64_t v885;
  int v886;
  int v887;
  char *v888;
  char *v889;
  char *v890;
  char *v891;
  char *v892;
  unint64_t v893;
  uint64_t v894;
  int v895;
  int v896;
  os_log_t *v897;
  unint64_t v898;
  __CFSet *v899;
  os_log_t *v900;
  char *v901;
  char *v902;
  unint64_t **v903;
  int v904;
  char *v905;
  char *v906;
  char *v907;
  char *v908;
  _OWORD *v909;
  void **v910;
  uint64_t *v911;
  uint64_t *v912;
  uint64_t v913;
  unint64_t v914;
  uint64_t v915;
  CFAllocatorRef v916;
  int v917;
  int v918;
  CFMutableDictionaryRef v919;
  uint64_t *v920;
  CFDictionaryRef v921;
  uint64_t v922;
  void **v923;
  uint64_t v924;
  const char *v925;
  os_log_t *v926;
  uint64_t v927;
  uint64_t v928;
  BOOL (*v929)(uint64_t, uint64_t, int);
  void *v930;
  __int128 *v931;
  uint64_t *v932;
  uint64_t *v933;
  __int128 *v934;
  char **v935;
  _QWORD *v936;
  uint64_t *v937;
  CFMutableDictionaryRef v938;
  CFMutableDictionaryRef v939;
  _QWORD *v940;
  uint64_t v941;
  statfs *v942;
  os_signpost_id_t v943;
  int v944;
  uint64_t v945;
  uint64_t *v946;
  uint64_t v947;
  char v948;
  __int128 v949;
  unint64_t v950;
  int v951;
  _QWORD v952[2];
  uint64_t v953;
  unsigned int v954;
  unsigned int v955;
  _BYTE v956[12];
  unsigned int v957;
  uint64_t v958;
  unsigned int v959;
  unsigned int v960;
  _BYTE v961[12];
  unsigned int v962;
  uint64_t v963;
  unsigned int v964;
  unsigned int v965;
  _BYTE v966[12];
  unsigned int v967;
  unint64_t v968;
  unsigned int v969;
  unsigned int v970;
  char v971;
  char *v972;
  uint64_t v973;
  __int128 v974;
  unint64_t v975;
  unsigned int v976;
  uint64_t v977;
  uint64_t v978;
  uint64_t (*v979)(uint64_t, uint64_t, int);
  void *v980;
  uint64_t *v981;
  uint64_t *v982;
  uint64_t *v983;
  _QWORD *v984;
  uint64_t *v985;
  uint64_t *v986;
  uint64_t *v987;
  _BYTE *v988;
  unsigned int v989;
  uint64_t v990;
  uint64_t *v991;
  uint64_t v992;
  uint64_t v993;
  uint64_t v994;
  uint64_t *v995;
  uint64_t v996;
  uint64_t v997;
  uint64_t v998;
  uint64_t *v999;
  uint64_t v1000;
  uint64_t v1001;
  uint64_t v1002;
  uint64_t *v1003;
  uint64_t v1004;
  uint64_t v1005;
  uint64_t v1006;
  uint64_t *v1007;
  uint64_t v1008;
  uint64_t v1009;
  _QWORD v1010[3];
  int v1011;
  uint64_t v1012;
  uint64_t *v1013;
  uint64_t v1014;
  int v1015;
  uint64_t v1016;
  unsigned int v1017;
  unsigned int v1018;
  _BYTE v1019[12];
  unsigned int v1020;
  uint64_t v1021;
  uint64_t *v1022;
  uint64_t v1023;
  CFMutableDictionaryRef v1024;
  char v1025;
  uint64_t v1026;
  _QWORD v1027[45];
  _QWORD v1028[15];
  _QWORD v1029[15];
  _QWORD v1030[46];
  char v1031;
  int v1032;
  unsigned int v1033;
  __int128 v1034;
  uint64_t v1035;
  size_t v1036;
  uint64_t v1037;
  statfs v1038;
  _BYTE v1039[12];
  __int16 v1040;
  _QWORD v1041[8702];
  char v1042[1024];
  _BYTE v1043[1024];
  _QWORD v1044[2];
  __int128 v1045;
  __int128 v1046;
  _BYTE v1047[1060];
  int v1048;
  uint64_t v1049;
  __int128 v1050;
  uint64_t v1051;

  v1 = MEMORY[0x1E0C80A78](a1);
  v3 = v2;
  v5 = v4;
  v7 = v6;
  v9 = v8;
  v10 = (uint64_t *)v1;
  v1051 = *MEMORY[0x1E0C80C00];
  v1033 = -1;
  v11 = *(_QWORD *)(*(_QWORD *)v1 + 72);
  v1032 = 0;
  v1031 = 0;
  bzero(v1027, 0x3C8uLL);
  v12 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 500, 0, 0);
  if ((unint64_t)v9 <= 1)
    v14 = 1;
  else
    v14 = v9;
  v884 = v14;
  if (v5)
    *v5 = 0;
  v922 = v3;
  v926 = &v695;
  v778 = v12;
  v752 = Mutable;
  v15 = 0;
  if (v9 < 1)
  {
    v33 = 0;
    v26 = 0;
    v34 = 0;
    v30 = 0;
    v31 = 0;
    v28 = 0;
    v29 = 0;
  }
  else
  {
    v16 = 0;
    v17 = v10;
    v18 = v9;
    v19 = 0;
    v20 = 0;
    v21 = 0;
    v22 = 0;
    v23 = 0;
    do
    {
      v25 = *v17++;
      v24 = v25;
      v26 = *(_QWORD *)(v25 + 16288);
      if (v26 <= v21)
        v26 = v21;
      if (*(_QWORD *)(v24 + 16296) <= v22)
        v27 = v22;
      else
        v27 = *(_QWORD *)(v24 + 16296);
      v28 = v23 + *(unsigned __int8 *)(v24 + 15162);
      if (*(_DWORD *)(v24 + 32) <= v16)
        v29 = v16;
      else
        v29 = *(_DWORD *)(v24 + 32);
      v30 = *(_QWORD *)(v24 + 4944) + v19;
      v31 = *(_QWORD *)(v24 + 9656) + v15;
      v32 = *(_QWORD *)(v24 + 480) + v20;
      v23 += *(unsigned __int8 *)(v24 + 15162);
      v22 = v27;
      v33 = v27;
      v21 = v26;
      v16 = v29;
      v20 = v32;
      v34 = v32;
      v19 = v30;
      v15 = v31;
      --v18;
    }
    while (v18);
  }
  v35 = v31;
  v885 = v30;
  v913 = v34;
  v723 = v29;
  v724 = v26;
  v726 = v33;
  v715 = v28;
  v36 = *__error();
  v37 = _SILogForLogForCategory(0);
  v38 = 2 * (gSILogLevels[0] < 4);
  if (os_log_type_enabled(v37, v38))
  {
    *(_DWORD *)v1039 = 136315394;
    *(_QWORD *)&v1039[4] = v7;
    v1040 = 1024;
    LODWORD(v1041[0]) = v9;
    _os_log_impl(&dword_1B8270000, v37, v38, "Merging started (%s) count:%d", v1039, 0x12u);
  }
  *__error() = v36;
  v924 = v9;
  v923 = v5;
  v920 = v10;
  v925 = v7;
  v894 = v35;
  if (v9 < 1)
  {
    v48 = 0;
    v49 = v922;
    v50 = v752;
    v51 = v715;
  }
  else
  {
    v706 = v11;
    v40 = 0;
    *(_QWORD *)&v39 = 136315138;
    v697 = v39;
    do
    {
      v41 = *__error();
      v42 = _SILogForLogForCategory(0);
      v43 = 2 * (gSILogLevels[0] < 4);
      if (os_log_type_enabled(v42, v43))
      {
        v44 = v920[v40] + 15168;
        *(_DWORD *)v1039 = v697;
        *(_QWORD *)&v1039[4] = v44;
        _os_log_impl(&dword_1B8270000, v42, v43, "\t%s", v1039, 0xCu);
      }
      *__error() = v41;
      ++v40;
    }
    while (v924 != v40);
    v45 = 0;
    v9 = v924;
    v10 = v920;
    do
      v46 = *(_QWORD *)(v920[v45++] + 4904);
    while (v45 < v924 && v46 == 0);
    v48 = (v46 != 0) << 6;
    v7 = v925;
    v49 = v922;
    v50 = v752;
    v51 = v715;
    v11 = v706;
  }
  v52 = *v10;
  v53 = *(_QWORD *)(*v10 + 16400);
  v54 = *(unsigned __int8 *)(*v10 + 37);
  v55 = v48 | (16 * (v51 == v9)) | ((_WORD)v54 << 8) | (*(unsigned __int8 *)(*v10 + 38) << 10);
  v1026 = 0;
  v1026 = createIndex(*(unsigned int *)(v52 + 56), v7, v11, v53, v55, 1, 0, &v1032, *(_DWORD *)(v52 + 4), *(_QWORD *)(v52 + 14344), *(_QWORD *)(v49 + 56), *(const void **)(v52 + 4912));
  if (v1032)
  {
    if (v50)
      CFRelease(v50);
    return 0;
  }
  v921 = v50;
  v57 = v778;
  *(_DWORD *)(v1026 + 32) = v723;
  *(_QWORD *)(v1026 + 16288) = v724;
  *(_QWORD *)(v1026 + 16296) = v726;
  v1025 = 0;
  v1025 = (*(uint64_t (**)(_QWORD))(v49 + 16))(*(_QWORD *)(v49 + 32));
  v58 = (uint64_t)CICleanUpThreadLoc();
  v59 = &threadData[18 * v58];
  v60 = v59[8];
  v883 = v59 + 8;
  v61 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
  v919 = CFDictionaryCreateMutable(v57, 500, 0, MEMORY[0x1E0C9B3A0]);
  v1021 = 0;
  v1022 = &v1021;
  v1023 = 0x2000000000;
  v1024 = 0;
  v916 = v57;
  v1024 = CFDictionaryCreateMutable(v57, 500, 0, v61);
  v62 = v884;
  v63 = (char *)malloc_type_calloc(1uLL, 240 * v884 + 256, 0x4D623C1FuLL);
  *((_QWORD *)v63 + 30) = v63 + 256;
  *((_QWORD *)v63 + 31) = &v63[16 * v62 + 256];
  CICleanUpPush(v58, (uint64_t)MEMORY[0x1E0C834A8], (uint64_t)v63);
  v65 = (char *)*((_QWORD *)v63 + 30);
  v64 = (char *)*((_QWORD *)v63 + 31);
  if (!*(_BYTE *)(v1026 + 8))
  {
    v77 = *__error();
    v78 = _SILogForLogForCategory(0);
    v79 = 2 * (gSILogLevels[0] < 4);
    v80 = os_log_type_enabled(v78, v79);
    v74 = v923;
    if (v80)
    {
      *(_WORD *)v1039 = 0;
      _os_log_impl(&dword_1B8270000, v78, v79, "Skipping because index is shut down", v1039, 2u);
    }
    *__error() = v77;
    goto LABEL_49;
  }
  v904 = v54;
  v915 = v58;
  v914 = v60;
  v910 = (void **)v63;
  v905 = v65;
  v906 = v65;
  v888 = v63 + 120;
  v903 = (unint64_t **)(v63 + 88);
  v907 = v64;
  v889 = v64;
  v892 = v63 + 136;
  v908 = v63;
  v909 = v63 + 152;
  do
  {
    v66 = __ldxr(exceptionSequenceNum);
    v67 = v66 + 1;
  }
  while (__stxr(v66 + 1, exceptionSequenceNum));
  v1020 = 0;
  memset(v1019, 0, sizeof(v1019));
  v68 = setThreadIdAndInfo(-1, (__int128 *)sIndexExceptionCallbacks, v1026, 0, v67);
  *(_DWORD *)&v1019[8] = HIDWORD(v68);
  v1020 = v68;
  *(_DWORD *)&v1019[4] = v69;
  *(_DWORD *)v1019 = v70;
  v71 = *(_QWORD *)&threadData[18 * v68 + 2];
  v72 = v71 + 320 * HIDWORD(v68);
  *(_BYTE *)(v72 + 216) = 0;
  v917 = *(_DWORD *)(v72 + 312);
  v73 = *(void (**)(_QWORD))(v72 + 224);
  v74 = v923;
  if (v73)
    v73(*(_QWORD *)(v71 + 320 * HIDWORD(v68) + 288));
  v918 = v67;
  v1018 = v1020;
  v1017 = *(_DWORD *)&v1019[8];
  v1016 = *(_QWORD *)v1019;
  if (_setjmp((int *)v72))
  {
    v75 = *__error();
    v76 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v76, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v1039 = 136315394;
      *(_QWORD *)&v1039[4] = "mergeIndexData";
      v1040 = 1024;
      LODWORD(v1041[0]) = 3240;
      _os_log_error_impl(&dword_1B8270000, v76, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", v1039, 0x12u);
    }
    *__error() = v75;
    *(_DWORD *)(v72 + 312) = v917;
    CIOnThreadCleanUpReset(v1016);
    dropThreadId(v1018, 1, v918);
    CICleanUpReset(v1018, HIDWORD(v1016));
LABEL_49:
    v81 = v925;
    goto LABEL_692;
  }
  *(_DWORD *)(v1026 + 4664) = 1;
  bzero(v1047, 0x848uLL);
  v1044[0] = v1026 + 88;
  v1050 = 0u;
  *(_OWORD *)&v1047[1044] = 0u;
  v1048 = 0;
  v1044[1] = 1;
  v1045 = 0u;
  v1046 = 0u;
  LODWORD(v1045) = 1;
  v1049 = 0;
  v82 = v1026;
  v1012 = 0;
  v1013 = &v1012;
  v1014 = 0x2000000000;
  v1015 = 0;
  v1010[0] = 0;
  v1010[1] = v1010;
  v1010[2] = 0x2000000000;
  v1011 = 0;
  v83 = atomic_load((unsigned int *)(*v10 + 15152));
  v84 = 1;
  if (!v83)
    v84 = (*(uint64_t (**)(_QWORD))(v922 + 16))(*(_QWORD *)(v922 + 32));
  v911 = (uint64_t *)v82;
  v1025 = v84;
  bzero(v1043, 0x400uLL);
  accurate_realpath((int *)".", (uint64_t)v1043);
  bzero(v1042, 0x400uLL);
  do
  {
    v85 = __ldxr(mergeIndexData_termIdFileCount);
    v86 = v85 + 1;
  }
  while (__stxr(v86, mergeIndexData_termIdFileCount));
  snprintf(v1042, 0x400uLL, "tmp.merge.termIdFile.%d", v86);
  v1033 = openat(*(_DWORD *)(v1026 + 56), v1042, 536873474, 384);
  unlinkat(*(_DWORD *)(v1026 + 56), v1042, 0);
  v87 = v921;
  if (v1033 == -1)
  {
    v88 = *__error();
    v89 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v89, OS_LOG_TYPE_ERROR))
    {
      v332 = *__error();
      *(_DWORD *)v1039 = 136315650;
      *(_QWORD *)&v1039[4] = "mergeIndexData";
      v1040 = 1024;
      LODWORD(v1041[0]) = 2078;
      WORD2(v1041[0]) = 1024;
      *(_DWORD *)((char *)v1041 + 6) = v332;
      _os_log_error_impl(&dword_1B8270000, v89, OS_LOG_TYPE_ERROR, "%s:%d: open termIdFile error: %d", v1039, 0x18u);
    }
    *__error() = v88;
    v1025 = 1;
    v87 = v921;
  }
  bzero(v1039, 0x11000uLL);
  v1006 = 0;
  v1007 = &v1006;
  v1008 = 0x2000000000;
  v1009 = 0;
  v1002 = 0;
  v1003 = &v1002;
  v1004 = 0x2000000000;
  v1005 = 0;
  v998 = 0;
  v999 = &v998;
  v1000 = 0x2000000000;
  v1001 = 0;
  v994 = 0;
  v995 = &v994;
  v996 = 0x2000000000;
  v997 = 0;
  if (v9 > 1)
  {
    *(_DWORD *)(v1026 + 44) = 1;
    v90 = (uint64_t)malloc_type_calloc(v9, 8uLL, 0x80040B8603338uLL);
    goto LABEL_61;
  }
  *(_DWORD *)(v1026 + 44) = 0;
  v90 = (uint64_t)malloc_type_calloc(v9, 8uLL, 0x80040B8603338uLL);
  if (v9 >= 1)
  {
LABEL_61:
    v92 = (uint64_t *)v90;
    v93 = 0;
    *(_QWORD *)&v91 = 136315650;
    v701 = v91;
    do
    {
      v94 = *(_QWORD *)(v10[v93] + 4896);
      if (v94)
      {
        v95 = *__error();
        v96 = _SILogForLogForCategory(16);
        if (os_log_type_enabled(v96, OS_LOG_TYPE_DEFAULT))
        {
          v97 = (_QWORD *)(v94 + 64);
          if (*(char *)(v94 + 87) < 0)
            v97 = (_QWORD *)*v97;
          if (*(char *)(v94 + 63) < 0)
            v98 = *(_QWORD *)(v94 + 40);
          else
            v98 = v94 + 40;
          v1038.f_bsize = v701;
          *(_QWORD *)&v1038.f_iosize = v97;
          WORD2(v1038.f_blocks) = 2048;
          *(uint64_t *)((char *)&v1038.f_blocks + 6) = v94 + 8;
          HIWORD(v1038.f_bfree) = 2080;
          v1038.f_bavail = v98;
          _os_log_impl(&dword_1B8270000, v96, OS_LOG_TYPE_DEFAULT, "[%s] createVectorIndexDumpContext: %p %s", (uint8_t *)&v1038, 0x20u);
        }
        v90 = (uint64_t)__error();
        *(_DWORD *)v90 = v95;
        v92[v93] = v94 + 8;
        v9 = v924;
        v10 = v920;
      }
      ++v93;
    }
    while (v9 != v93);
    if (v1025)
      v99 = 1;
    else
      v99 = v9 < 1;
    v74 = v923;
    if (v99)
    {
      v87 = v921;
    }
    else
    {
      v100 = 0;
      v87 = v921;
      do
      {
        v90 = *(_QWORD *)(v10[v100] + 4896);
        if (v90)
          v90 = processVectorIndexDumpContexts(v90, v100, v9, v92, 1);
        ++v100;
      }
      while (v9 != v100);
    }
    goto LABEL_83;
  }
  v92 = (uint64_t *)v90;
LABEL_83:
  v912 = v92;
  v990 = 0;
  v991 = &v990;
  v992 = 0x2000000000;
  v993 = 0;
  v101 = v922;
  if (!v1025)
  {
    v977 = MEMORY[0x1E0C809B0];
    v978 = 0x40000000;
    v979 = __mergeIndexData_block_invoke;
    v980 = &unk_1E6E30580;
    v981 = &v1006;
    v989 = v1033;
    v988 = v1039;
    v982 = &v998;
    v983 = &v1012;
    v984 = v1010;
    v985 = &v1002;
    v986 = &v994;
    v987 = &v990;
    v90 = iterateTermsForIndexes(v1026);
    v1025 = v90;
  }
  if (v1025 || (v102 = atomic_load((unsigned int *)(*v10 + 15152))) != 0)
  {
    v103 = 1;
  }
  else
  {
    v90 = (*(uint64_t (**)(_QWORD))(v101 + 16))(*(_QWORD *)(v101 + 32));
    v103 = v90;
  }
  v1025 = v103;
  if (!v103)
  {
    v90 = prot_pwrite(v1033, v1039, v1007[3], v999[3]);
    if (v90 == -1)
    {
      v106 = *__error();
      v107 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v107, OS_LOG_TYPE_ERROR))
      {
        v353 = *__error();
        v1038.f_bsize = 136315650;
        *(_QWORD *)&v1038.f_iosize = "mergeIndexData";
        WORD2(v1038.f_blocks) = 1024;
        *(_DWORD *)((char *)&v1038.f_blocks + 6) = 2200;
        WORD1(v1038.f_bfree) = 1024;
        HIDWORD(v1038.f_bfree) = v353;
        _os_log_error_impl(&dword_1B8270000, v107, OS_LOG_TYPE_ERROR, "%s:%d: pwrite error: %d", (uint8_t *)&v1038, 0x18u);
      }
      v90 = (uint64_t)__error();
      *(_DWORD *)v90 = v106;
      v1025 = 1;
      v101 = v922;
      v87 = v921;
    }
    else
    {
      if (atomic_load((unsigned int *)(*v10 + 15152)))
      {
        v105 = 1;
      }
      else
      {
        v90 = (*(uint64_t (**)(_QWORD))(v101 + 16))(*(_QWORD *)(v101 + 32));
        v105 = v90;
      }
      v1025 = v105;
    }
  }
  if (v1025 || (v108 = atomic_load((unsigned int *)(*v10 + 15152))) != 0)
  {
    v109 = 1;
  }
  else
  {
    v90 = (*(uint64_t (**)(_QWORD))(v101 + 16))(*(_QWORD *)(v101 + 32));
    v109 = v90;
  }
  v1025 = v109;
  if (!v109)
  {
    v110 = *((_DWORD *)v1013 + 6);
    if (*(_DWORD *)(v1026 + 9368) <= v110)
    {
      v90 = termIdStoreAllocBulk(v1026 + 4960, v110 - *(_DWORD *)(v1026 + 9368) + 1);
      if ((_DWORD)v90)
        v1025 = 1;
    }
  }
  if (!v1025)
  {
    v111 = *((_DWORD *)v1013 + 6);
    if (*(_DWORD *)(v1026 + 14080) <= v111)
    {
      v90 = termIdStoreAllocBulk(v1026 + 9672, v111 - *(_DWORD *)(v1026 + 14080) + 1);
      if ((_DWORD)v90)
        v1025 = 1;
    }
  }
  if (v1025)
    goto LABEL_647;
  v849 = &v695;
  MEMORY[0x1E0C80A78](v90);
  v113 = (char *)&v695 - ((v112 + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v113, v112);
  v902 = v113;
  bzero(v113, 24 * v9);
  MEMORY[0x1E0C80A78](v114);
  v116 = (char *)&v695 - ((v115 + 15) & 0xFFFFFFFFFFFFFFF0);
  v878 = v116;
  bzero(v116, v115);
  if (v9 >= 1)
  {
    v117 = v10;
    v118 = v116;
    v119 = v9;
    do
    {
      v120 = *v117++;
      *v118++ = *(_DWORD *)(v120 + 60);
      --v119;
    }
    while (v119);
  }
  v901 = v116;
  v121 = v915;
  if (!v74)
  {
    v825 = CFSetCreateMutable(0, v9, MEMORY[0x1E0C9B3B0]);
    v824 = CICleanUpPush(v121, (uint64_t)MEMORY[0x1E0C98BC0], (uint64_t)v825);
    if (v9 < 1)
    {
      v252 = 0;
      v215 = 1;
    }
    else
    {
      v182 = 0;
      v823 = 24;
      v822 = 72;
      v821 = 320;
      v820 = 15152;
      *(_QWORD *)&v181 = 136315394;
      v819 = v181;
      v183 = 0;
      while (1)
      {
        v184 = &v902[v182 * v823];
        *v184 = 1;
        v185 = v10[v182];
        *((_QWORD *)v184 + 1) = *(_QWORD *)(v185 + 72) - *(_QWORD *)(v1026 + 72);
        v186 = CIIndexSetCreateWithRange(0, *(_DWORD *)(v185 + 60), 2);
        if (v186)
        {
          CFSetSetValue(v825, v186);
          CFRelease(v186);
        }
        v187 = &v902[24 * v182];
        *((_QWORD *)v187 + 2) = v186;
        v188 = (unsigned int **)(v187 + 16);
        v189 = *(unsigned int *)(v1026 + 64);
        v190 = v10[v182];
        v191 = *(_QWORD *)(v190 + 72);
        if (v182)
        {
          v192 = v10[v182 - 1];
          v193 = *(_DWORD *)(v192 + 60);
          v194 = *(_DWORD *)(v192 + 72);
          v195 = v193 >= 2 ? v193 : 0;
          v196 = v183 + v191 - v194 - v195;
        }
        else
        {
          v196 = v183;
        }
        v197 = v10;
        v198 = v191 - *(_DWORD *)(v1026 + 72);
        v199 = atomic_load((unsigned int *)(v190 + 12));
        LOBYTE(v970) = 0;
        v200 = v197[v182];
        v201 = *(unsigned __int8 *)(v200 + 8);
        v809 = v199;
        if (v201)
        {
          v810 = v196;
          v74 = v923;
          do
          {
            v202 = __ldxr(exceptionSequenceNum);
            v203 = v202 + 1;
          }
          while (__stxr(v202 + 1, exceptionSequenceNum));
          LODWORD(v1034) = 0;
          LODWORD(v972) = 0;
          LODWORD(v949) = 0;
          LODWORD(v945) = 0;
          v204 = setThreadIdAndInfo(-1, (__int128 *)sIndexExceptionCallbacks, v200, 0, v203);
          LODWORD(v972) = HIDWORD(v204);
          LODWORD(v1034) = v204;
          LODWORD(v949) = v205;
          LODWORD(v945) = v206;
          v207 = *(_QWORD *)((char *)&threadData[2] + v204 * (unint64_t)v822);
          v208 = v207 + HIDWORD(v204) * (unint64_t)v821;
          *(_BYTE *)(v208 + 216) = 0;
          v209 = *(_DWORD *)(v208 + 312);
          v210 = *(void (**)(_QWORD))(v208 + 224);
          if (v210)
            v210(*(_QWORD *)(v207 + 320 * HIDWORD(v204) + 288));
          LODWORD(v952[0]) = v1034;
          v976 = v972;
          v975 = __PAIR64__(v949, v945);
          if (_setjmp((int *)v208))
          {
            v212 = v209;
            v213 = *__error();
            v214 = _SILogForLogForCategory(0);
            if (os_log_type_enabled(v214, OS_LOG_TYPE_ERROR))
            {
              v1038.f_bsize = v819;
              *(_QWORD *)&v1038.f_iosize = "mergeIndexData";
              WORD2(v1038.f_blocks) = 1024;
              *(_DWORD *)((char *)&v1038.f_blocks + 6) = 2365;
              _os_log_error_impl(&dword_1B8270000, v214, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", (uint8_t *)&v1038, 0x12u);
            }
            *__error() = v213;
            *(_DWORD *)(v208 + 312) = v212;
            CIOnThreadCleanUpReset(v975);
            dropThreadId(LODWORD(v952[0]), 1, v203);
            CICleanUpReset(LODWORD(v952[0]), HIDWORD(v975));
            v215 = v198;
            v9 = v924;
          }
          else
          {
            v807 = v209;
            v808 = v203;
            if (*(_DWORD *)(v920[v182] + 60) >= 2u)
            {
              v221 = 1;
              v222 = v198;
              v223 = v189;
              v9 = v924;
              v224 = v904;
              while (1)
              {
                v225 = v222;
                v226 = v222 + 1;
                if (v222 + 1 >= v223)
                {
                  v246 = v223;
                  while (1)
                  {
                    v223 = v246;
                    if (indexGrowDocumentPayloads(v1026, 0, 0))
                      break;
                    if (v1025)
                      break;
                    if (atomic_load((unsigned int *)(*v920 + v820)))
                      break;
                    v1025 = (*(uint64_t (**)(_QWORD))(v922 + 16))(*(_QWORD *)(v922 + 32));
                    v224 = v904;
                    if ((v1025 & 1) == 0)
                    {
                      v246 = *(unsigned int *)(v1026 + 64);
                      v223 = v246;
                      if (v226 >= v246)
                        continue;
                    }
                    goto LABEL_205;
                  }
                  v1025 = 1;
                  v224 = v904;
                }
LABEL_205:
                if (v1025)
                  goto LABEL_241;
                if (v224)
                {
                  v227 = v920[v182];
                  v228 = *(unsigned __int8 *)(*(_QWORD *)(v227 + 14392) + v221);
                }
                else
                {
                  v228 = (*(_DWORD *)(*(_QWORD *)(v920[v182] + 14392) + 4 * (v221 / 5uLL)) >> (6 * (v221 % 5))) & 0x3F;
                  v227 = v920[v182];
                }
                v229 = *(_DWORD *)(v227 + 72) + v221 - *(_QWORD *)(v1026 + 72);
                v230 = v229;
                if (v228)
                {
                  v231 = *v188;
                  v1038.f_bsize = -1;
                  _CIIndexSetAddIndex(v231, v221, 0, &v1038, v211);
                  v232 = (_QWORD *)v920[v182];
                  *(_QWORD *)(*(_QWORD *)(v1026 + 14368) + 8 * v229) = *(_QWORD *)(v232[1796] + 8 * v221);
                  v233 = v232[1797];
                  if (v233)
                    *(_DWORD *)(*(_QWORD *)(v1026 + 14376) + 4 * v229) = *(_DWORD *)(v233 + 4 * v221);
                  v234 = v232[1798];
                  if (v234)
                    *(_QWORD *)(*(_QWORD *)(v1026 + 14384) + 8 * v229) = *(_QWORD *)(v234 + 8 * v221);
                  v9 = v924;
                  v235 = (_QWORD *)MEMORY[0x1E0C85AD8];
                  v224 = v904;
                  if (*(_BYTE *)(v1026 + 37))
                    v236 = *(unsigned __int8 *)(*(_QWORD *)(v1026 + 14392) + v229);
                  else
                    v236 = (*(_DWORD *)(*(_QWORD *)(v1026 + 14392) + 4 * (v229 / 5uLL)) >> (6 * (v229 % 5))) & 0x3F;
                  if ((v236 & 0xFFFFFFDF) != 0)
                  {
                    v647 = __si_assert_copy_extra_5354(0, -1);
                    v648 = v647;
                    v649 = "";
                    if (v647)
                      HIDWORD(v649) = HIDWORD(v647);
                    HIDWORD(v694) = HIDWORD(v649);
                    goto LABEL_827;
                  }
                  if (*(_BYTE *)(v1026 + 37))
                  {
                    *(_BYTE *)(*(_QWORD *)(v1026 + 14392) + v229) = v228;
                    if (*(_QWORD *)(v1026 + 14400))
                      *(_BYTE *)(*(_QWORD *)(v1026 + 14400) + v229 / (unint64_t)(32 * *v235)) |= 1 << ((v229 / (unint64_t)(4 * *v235)) & 7);
                  }
                  else
                  {
                    v237 = v229 / 5uLL;
                    v238 = *(_DWORD *)(*(_QWORD *)(v1026 + 14392) + 4 * v237);
                    if (*(_QWORD *)(v1026 + 14400))
                    {
                      v239 = v237 / (8 * *MEMORY[0x1E0C85AD8]);
                      v240 = (v237 / *MEMORY[0x1E0C85AD8]) & 7;
                      *(_BYTE *)(*(_QWORD *)(v1026 + 14400) + v239) |= 1 << v240;
                      if (!*(_BYTE *)(*(_QWORD *)(v1026 + 14400) + v239))
                      {
                        v663 = __si_assert_copy_extra_5354(0, -1);
                        v651 = v663;
                        v658 = "";
                        if (v663)
                          HIDWORD(v658) = HIDWORD(v663);
                        goto LABEL_790;
                      }
                      v241 = v240 | (8 * (_DWORD)v239);
                      if (*v235 * v241 > v237)
                      {
                        v664 = __si_assert_copy_extra_5354(0, -1);
                        v651 = v664;
                        v658 = "";
                        if (v664)
                          HIDWORD(v658) = HIDWORD(v664);
                        goto LABEL_790;
                      }
                      if (*v235 * (unint64_t)(v241 + 1) <= v237)
                      {
                        v665 = __si_assert_copy_extra_5354(0, -1);
                        v651 = v665;
                        v658 = "";
                        if (v665)
                          HIDWORD(v658) = HIDWORD(v665);
                        goto LABEL_790;
                      }
                    }
                    v242 = v229 / 5uLL;
                    *(_DWORD *)(*(_QWORD *)(v1026 + 14392) + 4 * v242) = v238 & ~(63 << (6 * (v229 % 5))) | ((v228 & 0x3F) << (6 * (v229 % 5)));
                    v243 = *(_QWORD *)(v1026 + 14392);
                    if (*(_BYTE *)(v1026 + 37))
                      v244 = *(unsigned __int8 *)(v243 + v229);
                    else
                      v244 = (*(_DWORD *)(v243 + 4 * v242) >> (6 * (v229 % 5))) & 0x3F;
                    if (v244 != (v228 & 0x3F))
                    {
                      v657 = __si_assert_copy_extra_5354(0, -1);
                      v651 = v657;
                      v658 = "";
                      if (v657)
                        HIDWORD(v658) = HIDWORD(v657);
LABEL_790:
                      HIDWORD(v694) = HIDWORD(v658);
                      goto LABEL_791;
                    }
                  }
                  v227 = v920[v182];
                }
                ++v221;
                v245 = *(unsigned int *)(v227 + 60);
                v225 = v229 + 1;
                v222 = v230 + 1;
                v74 = v923;
                if (v221 >= v245)
                  goto LABEL_241;
              }
            }
            v225 = v198;
            v9 = v924;
LABEL_241:
            LOBYTE(v970) = 1;
            v248 = *(_QWORD *)&threadData[18 * LODWORD(v952[0]) + 2];
            v249 = v976;
            v250 = v248 + 320 * v976;
            *(_DWORD *)(v250 + 312) = v807;
            v251 = *(void (**)(_QWORD))(v250 + 232);
            if (v251)
              v251(*(_QWORD *)(v248 + 320 * v249 + 288));
            dropThreadId(LODWORD(v952[0]), 0, v808);
            v215 = v225;
          }
          v10 = v920;
          v216 = v810;
        }
        else
        {
          v216 = v196;
          v217 = *__error();
          v218 = _SILogForLogForCategory(0);
          v219 = 2 * (gSILogLevels[0] < 4);
          v220 = os_log_type_enabled(v218, v219);
          v74 = v923;
          if (v220)
          {
            LOWORD(v1038.f_bsize) = 0;
            _os_log_impl(&dword_1B8270000, v218, v219, "Skipping because index is shut down", (uint8_t *)&v1038, 2u);
          }
          *__error() = v217;
          v215 = v198;
          v10 = v920;
        }
        v252 = v809 + v216;
        if (!(_BYTE)v970)
          break;
        ++v182;
        v183 = v809 + v216;
        if (v182 == v9)
          goto LABEL_253;
      }
      v1025 = 1;
    }
LABEL_253:
    v254 = v824;
    atomic_store(v252, (unsigned int *)(v1026 + 12));
    v253 = v215;
    v255 = v825;
    goto LABEL_254;
  }
  v122 = malloc_type_calloc(1uLL, 0x10uLL, 0x305AB539uLL);
  if (!v122)
  {
    v669 = __si_assert_copy_extra_5354(0, -1);
    v648 = v669;
    v670 = "";
    if (v669)
      v670 = v669;
    __message_assert("%s:%u: failed assertion '%s' %s Got 0 from calloc for allocation of count %ld size %ld", "CIMerging.c", 1312, "p||count==0||size==0", v670, 1, 16);
    goto LABEL_828;
  }
  *v74 = v122;
  v123 = malloc_type_calloc(v9, 0x18uLL, 0x3AAFF090uLL);
  if (v9 && !v123)
  {
    v671 = __si_assert_copy_extra_5354(0, -1);
    v648 = v671;
    v672 = "";
    if (v671)
      v672 = v671;
    __message_assert("%s:%u: failed assertion '%s' %s Got 0 from calloc for allocation of count %ld size %ld", "CIMerging.c", 1313, "p||count==0||size==0", v672, v9, 24);
    goto LABEL_828;
  }
  *((_QWORD *)*v74 + 1) = v123;
  v125 = 1;
  if (v9 < 1)
  {
    v253 = 1;
    v254 = 0;
    v255 = 0;
    goto LABEL_254;
  }
  v126 = 0;
  v818 = v902;
  v817 = 24;
  v816 = 4;
  v815 = 1965715051;
  v814 = 72;
  v813 = 320;
  v812 = 15152;
  *(_QWORD *)&v124 = 136315394;
  v811 = v124;
  while (2)
  {
    v818[v126 * v817] = 0;
    v127 = *(unsigned int *)(v10[v126] + 60);
    v128 = malloc_type_calloc(v816, v127, v815);
    if ((_DWORD)v127)
      v129 = v128 == 0;
    else
      v129 = 0;
    if (v129)
    {
      v643 = __si_assert_copy_extra_5354(0, -1);
      v644 = v643;
      v645 = "";
      if (v643)
        v645 = v643;
      __message_assert("%s:%u: failed assertion '%s' %s Got 0 from calloc for allocation of count %ld size %ld", "CIMerging.c", 1314, "p||count==0||size==0", v645, 4, v127);
      free(v644);
      if (__valid_fs(-1))
        v646 = 2989;
      else
        v646 = 3072;
      *(_DWORD *)v646 = -559038737;
      abort();
    }
    v130 = &v902[24 * v126];
    *((_QWORD *)v130 + 2) = v128;
    v131 = v130 + 16;
    v132 = v923;
    *(_QWORD *)(*((_QWORD *)*v923 + 1) + 24 * v126 + 16) = v128;
    ++*(_QWORD *)*v132;
    v133 = *(unsigned int *)(v1026 + 64);
    LOBYTE(v970) = 0;
    v134 = v10[v126];
    if (!*(_BYTE *)(v134 + 8))
    {
      v147 = *__error();
      v148 = _SILogForLogForCategory(0);
      v149 = 2 * (gSILogLevels[0] < 4);
      if (os_log_type_enabled(v148, v149))
      {
        LOWORD(v1038.f_bsize) = 0;
        _os_log_impl(&dword_1B8270000, v148, v149, "Skipping because index is shut down", (uint8_t *)&v1038, 2u);
      }
      *__error() = v147;
      v146 = v125;
      goto LABEL_176;
    }
    do
    {
      v135 = __ldxr(exceptionSequenceNum);
      v136 = v135 + 1;
    }
    while (__stxr(v135 + 1, exceptionSequenceNum));
    LODWORD(v1034) = 0;
    LODWORD(v972) = 0;
    LODWORD(v949) = 0;
    LODWORD(v945) = 0;
    v137 = setThreadIdAndInfo(-1, (__int128 *)sIndexExceptionCallbacks, v134, 0, v136);
    LODWORD(v972) = HIDWORD(v137);
    LODWORD(v1034) = v137;
    LODWORD(v949) = v138;
    LODWORD(v945) = v139;
    v140 = *(_QWORD *)((char *)&threadData[2] + v137 * (unint64_t)v814);
    v141 = v140 + HIDWORD(v137) * (unint64_t)v813;
    *(_BYTE *)(v141 + 216) = 0;
    v142 = *(_DWORD *)(v141 + 312);
    v143 = *(void (**)(_QWORD))(v141 + 224);
    if (v143)
      v143(*(_QWORD *)(v140 + 320 * HIDWORD(v137) + 288));
    LODWORD(v952[0]) = v1034;
    v976 = v972;
    v975 = __PAIR64__(v949, v945);
    if (_setjmp((int *)v141))
    {
      v144 = *__error();
      v145 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v145, OS_LOG_TYPE_ERROR))
      {
        v1038.f_bsize = v811;
        *(_QWORD *)&v1038.f_iosize = "mergeIndexData";
        WORD2(v1038.f_blocks) = 1024;
        *(_DWORD *)((char *)&v1038.f_blocks + 6) = 2297;
        _os_log_error_impl(&dword_1B8270000, v145, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", (uint8_t *)&v1038, 0x12u);
      }
      *__error() = v144;
      *(_DWORD *)(v141 + 312) = v142;
      CIOnThreadCleanUpReset(v975);
      dropThreadId(LODWORD(v952[0]), 1, v136);
      CICleanUpReset(LODWORD(v952[0]), HIDWORD(v975));
      v146 = v125;
      v9 = v924;
      v10 = v920;
      goto LABEL_176;
    }
    v10 = v920;
    v150 = v920[v126];
    if (*(_DWORD *)(v150 + 60) < 2u)
    {
      LODWORD(v172) = *(_DWORD *)(v150 + 60);
      v171 = v920[v126];
      v175 = v125;
      goto LABEL_173;
    }
    v151 = 1;
    v152 = (_QWORD *)MEMORY[0x1E0C85AD8];
    v153 = v904;
    while (1)
    {
      v154 = v133;
      v155 = v125;
      if (!v153)
        break;
      if (*(_BYTE *)(*(_QWORD *)(v150 + 14392) + v151))
        goto LABEL_138;
LABEL_147:
      v162 = v125;
LABEL_161:
      v133 = v154;
      v171 = v150;
      ++v151;
      v172 = *(unsigned int *)(v150 + 60);
      v125 = v162;
      if (v151 >= v172)
      {
        v175 = v162;
        goto LABEL_173;
      }
    }
    if (((*(_DWORD *)(*(_QWORD *)(v150 + 14392) + 4 * (v151 / 5uLL)) >> (6 * (v151 % 5))) & 0x3F) == 0)
      goto LABEL_147;
LABEL_138:
    v156 = v125 + 1;
    if (v156 >= v154)
    {
      v173 = v154;
      while (!indexGrowDocumentPayloads(v1026, 0, 0))
      {
        if (v1025)
          break;
        if (atomic_load((unsigned int *)(*v920 + v812)))
          break;
        v1025 = (*(uint64_t (**)(_QWORD))(v922 + 16))(*(_QWORD *)(v922 + 32));
        v154 = v173;
        v152 = (_QWORD *)MEMORY[0x1E0C85AD8];
        v153 = v904;
        if ((v1025 & 1) == 0)
        {
          v173 = *(unsigned int *)(v1026 + 64);
          v154 = v173;
          if (v156 >= v173)
            continue;
        }
        goto LABEL_139;
      }
      v1025 = 1;
      v154 = v173;
      v152 = (_QWORD *)MEMORY[0x1E0C85AD8];
      v153 = v904;
    }
LABEL_139:
    v157 = v154;
    v10 = v920;
    v158 = v920[v126];
    if (!v1025)
    {
      *(_DWORD *)(*v131 + 4 * v151) = v155;
      *(_QWORD *)(*(_QWORD *)(v1026 + 14368) + 8 * v155) = *(_QWORD *)(*(_QWORD *)(v158 + 14368)
                                                                                     + 8 * v151);
      v159 = *(_QWORD *)(v158 + 14376);
      if (v159)
        *(_DWORD *)(*(_QWORD *)(v1026 + 14376) + 4 * v155) = *(_DWORD *)(v159 + 4 * v151);
      v160 = *(_QWORD *)(v158 + 14384);
      if (v160)
        *(_QWORD *)(*(_QWORD *)(v1026 + 14384) + 8 * v155) = *(_QWORD *)(v160 + 8 * v151);
      if (v153)
        LOBYTE(v161) = *(_BYTE *)(*(_QWORD *)(v10[v126] + 14392) + v151);
      else
        v161 = (*(_DWORD *)(*(_QWORD *)(v10[v126] + 14392) + 4 * (v151 / 5uLL)) >> (6
                                                                                                * (v151 % 5))) & 0x3F;
      if (*(_BYTE *)(v1026 + 37))
      {
        *(_BYTE *)(*(_QWORD *)(v1026 + 14392) + v155) = v161;
        if (*(_QWORD *)(v1026 + 14400))
          *(_BYTE *)(*(_QWORD *)(v1026 + 14400) + v155 / (unint64_t)(32 * *v152)) |= 1 << ((v155 / (unint64_t)(4 * *v152)) & 7);
        goto LABEL_160;
      }
      v163 = v155 / 5uLL;
      v164 = *(_DWORD *)(*(_QWORD *)(v1026 + 14392) + 4 * v163);
      if (*(_QWORD *)(v1026 + 14400))
      {
        v165 = v163 / (8 * *v152);
        v166 = (v163 / *v152) & 7;
        *(_BYTE *)(*(_QWORD *)(v1026 + 14400) + v165) |= 1 << v166;
        if (!*(_BYTE *)(*(_QWORD *)(v1026 + 14400) + v165))
        {
          v653 = __si_assert_copy_extra_5354(0, -1);
          v648 = v653;
          v654 = "";
          if (v653)
            HIDWORD(v654) = HIDWORD(v653);
          HIDWORD(v694) = HIDWORD(v654);
          goto LABEL_827;
        }
        v167 = v166 | (8 * (_DWORD)v165);
        if (*v152 * v167 > v163)
        {
          v655 = __si_assert_copy_extra_5354(0, -1);
          v651 = v655;
          v652 = "";
          if (v655)
            HIDWORD(v652) = HIDWORD(v655);
        }
        else
        {
          if (*v152 * (unint64_t)(v167 + 1) > v163)
            goto LABEL_156;
          v656 = __si_assert_copy_extra_5354(0, -1);
          v651 = v656;
          v652 = "";
          if (v656)
            HIDWORD(v652) = HIDWORD(v656);
        }
      }
      else
      {
LABEL_156:
        v168 = v161 & 0x3F;
        *(_DWORD *)(*(_QWORD *)(v1026 + 14392) + 4 * (v155 / 5uLL)) = v164 & ~(63 << (6
                                                                                                  * (v155 % 5))) | (v168 << (6 * (v155 % 5)));
        v169 = *(_QWORD *)(v1026 + 14392);
        if (*(_BYTE *)(v1026 + 37))
          v170 = *(unsigned __int8 *)(v169 + v155);
        else
          v170 = (*(_DWORD *)(v169 + 4 * v163) >> (6 * (v155 % 5))) & 0x3F;
        if (v170 == v168)
        {
LABEL_160:
          v150 = v10[v126];
          v154 = v157;
          v162 = (v155 + 1);
          goto LABEL_161;
        }
        v650 = __si_assert_copy_extra_5354(0, -1);
        v651 = v650;
        v652 = "";
        if (v650)
          HIDWORD(v652) = HIDWORD(v650);
      }
      HIDWORD(v694) = HIDWORD(v652);
      goto LABEL_791;
    }
    LODWORD(v172) = *(_DWORD *)(v158 + 60);
    v171 = v920[v126];
    v175 = v155;
LABEL_173:
    v176 = *((_QWORD *)*v923 + 1) + 24 * v126;
    *(_QWORD *)v176 = *(_QWORD *)(v171 + 72);
    *(_DWORD *)(v176 + 8) = v172;
    LOBYTE(v970) = 1;
    v177 = *(_QWORD *)&threadData[18 * LODWORD(v952[0]) + 2];
    v178 = v976;
    v179 = v177 + 320 * v976;
    *(_DWORD *)(v179 + 312) = v142;
    v180 = *(void (**)(_QWORD))(v179 + 232);
    if (v180)
      v180(*(_QWORD *)(v177 + 320 * v178 + 288));
    dropThreadId(LODWORD(v952[0]), 0, v136);
    v146 = v175;
    v9 = v924;
LABEL_176:
    if ((_BYTE)v970)
    {
      ++v126;
      v125 = v146;
      if (v126 == v9)
      {
        v255 = 0;
        goto LABEL_250;
      }
      continue;
    }
    break;
  }
  v255 = 0;
  v1025 = 1;
LABEL_250:
  v253 = v146;
  v254 = 0;
  v74 = v923;
LABEL_254:
  v256 = v254;
  if (v253 <= 1)
    v257 = 1;
  else
    v257 = v253;
  *(_DWORD *)(v1026 + 60) = v257;
  if (*(_QWORD *)(v1026 + 72) + (unint64_t)*(unsigned int *)(v1026 + 60) > *(_QWORD *)(v10[v9 - 1] + 72)
                                                                                 + (unint64_t)*(unsigned int *)(v10[v9 - 1] + 60))
  {
    v667 = __si_assert_copy_extra_5354(0, -1);
    v648 = v667;
    v668 = "";
    if (v667)
      HIDWORD(v668) = HIDWORD(v667);
    HIDWORD(v694) = HIDWORD(v668);
    goto LABEL_827;
  }
  v258 = v849;
  while (v253 >= *(_DWORD *)(v1026 + 64))
  {
    if (indexGrowDocumentPayloads(v1026, 0, 0)
      || v1025
      || (v259 = atomic_load((unsigned int *)(*v10 + 15152))) != 0)
    {
      v1025 = 1;
      break;
    }
    v1025 = (*(uint64_t (**)(_QWORD))(v922 + 16))(*(_QWORD *)(v922 + 32));
    if ((v1025 & 1) != 0)
      break;
  }
  v898 = v256;
  v911[616] = 8;
  v897 = &v695;
  v260 = 8 * v884;
  MEMORY[0x1E0C80A78](&v695);
  v261 = (v260 + 15) & 0xFFFFFFFFFFFFFFF0;
  v891 = (char *)&v695 - v261;
  bzero((char *)&v695 - v261, v260);
  MEMORY[0x1E0C80A78](v262);
  v890 = (char *)&v695 - v261;
  bzero((char *)&v695 - v261, v260);
  v972 = 0;
  v974 = 0u;
  v973 = 0x8000;
  v972 = (char *)malloc_type_malloc(0x8000uLL, 0x9D8A9808uLL);
  v893 = CICleanUpPush(v915, (uint64_t)RunBufferDestroy, (uint64_t)&v972);
  v949 = xmmword_1B8630D88;
  v950 = 0x100000;
  v971 = 1;
  do
  {
    v263 = __ldxr(exceptionSequenceNum);
    v264 = v263 + 1;
  }
  while (__stxr(v263 + 1, exceptionSequenceNum));
  LODWORD(v952[0]) = 0;
  v976 = 0;
  v975 = 0;
  v265 = setThreadIdAndInfo(-1, sMergeExceptionCallbacks, (uint64_t)&v949, 0, v264);
  v976 = HIDWORD(v265);
  LODWORD(v952[0]) = v265;
  v975 = __PAIR64__(v266, v267);
  v268 = *(_QWORD *)&threadData[18 * v265 + 2];
  v269 = v268 + 320 * HIDWORD(v265);
  v895 = *(_DWORD *)(v269 + 312);
  v270 = *(void (**)(_QWORD))(v269 + 224);
  if (v270)
    v270(*(_QWORD *)(v268 + 320 * HIDWORD(v265) + 288));
  v896 = v264;
  v970 = v952[0];
  v969 = v976;
  v968 = v975;
  if (_setjmp((int *)v269))
  {
    v271 = (_DWORD *)(v269 + 312);
    v272 = *__error();
    v273 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v273, OS_LOG_TYPE_ERROR))
    {
      v1038.f_bsize = 136315394;
      *(_QWORD *)&v1038.f_iosize = "mergeIndexData";
      WORD2(v1038.f_blocks) = 1024;
      *(_DWORD *)((char *)&v1038.f_blocks + 6) = 2768;
      _os_log_error_impl(&dword_1B8270000, v273, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", (uint8_t *)&v1038, 0x12u);
    }
    *__error() = v272;
    *v271 = v895;
    CIOnThreadCleanUpReset(v968);
    dropThreadId(v970, 1, v896);
    CICleanUpReset(v970, HIDWORD(v968));
    v101 = v922;
    v87 = v921;
    v274 = v898;
    goto LABEL_628;
  }
  v275 = (*MEMORY[0x1E0C85AD8] + v885) & ~*MEMORY[0x1E0C85AC0];
  v276 = v911;
  v911[618] = v275;
  v277 = fd_truncate(v276[1175], v275);
  v900 = v258;
  v899 = v255;
  if (v277 == -1)
  {
    v278 = *__error();
    v279 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v279, OS_LOG_TYPE_ERROR))
    {
      v538 = *__error();
      v1038.f_bsize = 136315650;
      *(_QWORD *)&v1038.f_iosize = "mergeIndexData";
      WORD2(v1038.f_blocks) = 1024;
      *(_DWORD *)((char *)&v1038.f_blocks + 6) = 2438;
      WORD1(v1038.f_bfree) = 1024;
      HIDWORD(v1038.f_bfree) = v538;
      _os_log_error_impl(&dword_1B8270000, v279, OS_LOG_TYPE_ERROR, "%s:%d: ftruncate error: %d", (uint8_t *)&v1038, 0x18u);
    }
    *__error() = v278;
LABEL_280:
    v1025 = 1;
  }
  else
  {
    *(_QWORD *)&v949 = fd_mmap(v276[1175]);
    if ((_QWORD)v949 == -1)
      goto LABEL_280;
  }
  v280 = *v883;
  v281 = v906;
  bzero(v906, 16 * v9);
  bzero(v889, 224 * v9);
  v282 = v915;
  if (v9 < 1)
  {
    v306 = 0;
    goto LABEL_308;
  }
  v755 = v280;
  v283 = v9;
  v284 = v907 + 200;
  v740 = 687498243;
  v739 = 0x10000;
  v738 = 2685992530;
  v285 = v890;
  v286 = v891;
  v287 = v10;
  while (2)
  {
    v288 = v283;
    v289 = atomic_load((unsigned int *)(*v287 + 28));
    v728 = v286;
    v729 = v285;
    *v286 = 0;
    v290 = *(_DWORD **)(*v287 + 9400);
    *v285 = v290;
    v281[1] = 0;
    if ((v289 & 4) != 0)
    {
LABEL_287:
      *v281 = malloc_type_malloc(*MEMORY[0x1E0C85AD8] << 6, v740);
      goto LABEL_288;
    }
    v291 = fd_lseek(v290, 0, 2);
    if (v291 != -1)
    {
      v292 = v291;
      v293 = fd_mmap((uint64_t)v290);
      if (v293 != -1)
      {
        if (!v293)
        {
          v659 = __si_assert_copy_extra_5354(0, -1);
          v651 = v659;
          v660 = "";
          if (v659)
            HIDWORD(v660) = HIDWORD(v659);
          HIDWORD(v694) = HIDWORD(v660);
          goto LABEL_791;
        }
        *v281 = v293;
        v281[1] = v292;
        if (v292)
          goto LABEL_288;
        goto LABEL_287;
      }
    }
    if (!v281[1])
      goto LABEL_287;
LABEL_288:
    v734 = v288;
    CICleanUpPush(v282, (uint64_t)finalizeReadBuffer, (uint64_t)v281);
    v294 = *(_DWORD **)(*v287 + 14112);
    *(v284 - 25) = v294;
    *((_BYTE *)v284 - 135) = 0;
    *(v284 - 22) = 0;
    v295 = (void **)(v284 - 22);
    *(v284 - 21) = 0;
    v284[2] = v1027;
    *v284 = -1;
    v284[1] = -1;
    if ((v289 & 4) != 0
      || (v296 = fd_lseek(v294, 0, 2), (unint64_t)(v296 - 1) > 0xFFFFFFFFFFFFFFFDLL)
      || (v297 = v296, v298 = fd_mmap((uint64_t)v294), v298 == -1))
    {
      if (*(v284 - 21))
      {
        v301 = *v295;
        v300 = v728;
        v299 = v729;
        if (!*v295)
          goto LABEL_300;
        *(v284 - 24) = 0;
        *(v284 - 23) = 0;
        v302 = v301;
        if ((v289 & 4) == 0)
          goto LABEL_300;
      }
      else
      {
        v303 = malloc_type_malloc(v739, v738);
        *v295 = v303;
        v300 = v728;
        v299 = v729;
        if (!v303)
          goto LABEL_300;
        *(v284 - 24) = 0;
        *(v284 - 23) = 0;
        v302 = v303;
      }
      fd_pread((_DWORD *)*(v284 - 25), v302, 0x10000uLL, 0);
      goto LABEL_300;
    }
    *(v284 - 22) = v298;
    *(v284 - 21) = v297;
    v300 = v728;
    v299 = v729;
    if (v298)
    {
      *(v284 - 24) = 0;
      *(v284 - 23) = 0;
    }
LABEL_300:
    v282 = v915;
    v304 = CICleanUpPush(v915, (uint64_t)finalizeReadPosContext, (uint64_t)(v284 - 25));
    v305 = atomic_load((unsigned int *)(*v287 + 28));
    if ((v305 & 4) != 0)
    {
      *(v284 - 18) = 0;
      *((_BYTE *)v284 - 134) = 1;
    }
    v284 += 28;
    ++v287;
    v286 = v300 + 1;
    v285 = v299 + 1;
    v281 += 2;
    v283 = v734 - 1;
    v10 = v920;
    if (v734 != 1)
      continue;
    break;
  }
  v306 = v304;
  v9 = v924;
  v74 = v923;
  v281 = v906;
  v280 = v755;
LABEL_308:
  v879 = v306;
  v880 = v280;
  v307 = (uint64_t)v910;
  v910[15] = (void *)v9;
  *(_QWORD *)(v307 + 128) = v281;
  do
  {
    v308 = __ldxr(exceptionSequenceNum);
    v309 = v308 + 1;
  }
  while (__stxr(v308 + 1, exceptionSequenceNum));
  v967 = 0;
  memset(v966, 0, sizeof(v966));
  v310 = setThreadIdAndInfo(-1, mergeIndexData_sExcReadBufferCallbacks, (uint64_t)v888, 0, v309);
  *(_DWORD *)&v966[8] = HIDWORD(v310);
  v967 = v310;
  *(_DWORD *)&v966[4] = v311;
  *(_DWORD *)v966 = v312;
  v313 = *(_QWORD *)&threadData[18 * v310 + 2];
  v314 = v313 + 320 * HIDWORD(v310);
  v886 = *(_DWORD *)(v314 + 312);
  v315 = *(void (**)(_QWORD))(v314 + 224);
  v255 = v899;
  if (v315)
    v315(*(_QWORD *)(v313 + 320 * HIDWORD(v310) + 288));
  v887 = v309;
  v965 = v967;
  v964 = *(_DWORD *)&v966[8];
  v963 = *(_QWORD *)v966;
  if (_setjmp((int *)v314))
  {
    v316 = (_DWORD *)(v314 + 312);
    v317 = *__error();
    v318 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v318, OS_LOG_TYPE_ERROR))
    {
      v1038.f_bsize = 136315394;
      *(_QWORD *)&v1038.f_iosize = "mergeIndexData";
      WORD2(v1038.f_blocks) = 1024;
      *(_DWORD *)((char *)&v1038.f_blocks + 6) = 2766;
      _os_log_error_impl(&dword_1B8270000, v318, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", (uint8_t *)&v1038, 0x12u);
    }
    *__error() = v317;
    *v316 = v886;
    CIOnThreadCleanUpReset(v963);
    dropThreadId(v965, 1, v887);
    CICleanUpReset(v965, HIDWORD(v963));
    v101 = v922;
    v87 = v921;
    v274 = v898;
    goto LABEL_625;
  }
  v319 = (uint64_t)v910;
  v320 = v889;
  v910[17] = (void *)v9;
  *(_QWORD *)(v319 + 144) = v320;
  do
  {
    v321 = __ldxr(exceptionSequenceNum);
    v322 = v321 + 1;
  }
  while (__stxr(v321 + 1, exceptionSequenceNum));
  v962 = 0;
  memset(v961, 0, sizeof(v961));
  v323 = setThreadIdAndInfo(-1, mergeIndexData_sExcReadPositionsCallbacks, (uint64_t)v892, 0, v322);
  *(_DWORD *)&v961[8] = HIDWORD(v323);
  v962 = v323;
  *(_DWORD *)&v961[4] = v324;
  *(_DWORD *)v961 = v325;
  v326 = *(_QWORD *)&threadData[18 * v323 + 2];
  v327 = v326 + 320 * HIDWORD(v323);
  v881 = *(_DWORD *)(v327 + 312);
  v328 = *(void (**)(_QWORD))(v327 + 224);
  if (v328)
    v328(*(_QWORD *)(v326 + 320 * HIDWORD(v323) + 288));
  v882 = v322;
  v960 = v962;
  v959 = *(_DWORD *)&v961[8];
  v958 = *(_QWORD *)v961;
  if (_setjmp((int *)v327))
  {
    v329 = (_DWORD *)(v327 + 312);
    v330 = *__error();
    v331 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v331, OS_LOG_TYPE_ERROR))
    {
      v1038.f_bsize = 136315394;
      *(_QWORD *)&v1038.f_iosize = "mergeIndexData";
      WORD2(v1038.f_blocks) = 1024;
      *(_DWORD *)((char *)&v1038.f_blocks + 6) = 2764;
      _os_log_error_impl(&dword_1B8270000, v331, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", (uint8_t *)&v1038, 0x12u);
    }
    *__error() = v330;
    *v329 = v881;
    CIOnThreadCleanUpReset(v958);
    dropThreadId(v960, 1, v882);
    CICleanUpReset(v960, HIDWORD(v958));
    v101 = v922;
    v87 = v921;
    v274 = v898;
    goto LABEL_622;
  }
  v333 = v903;
  *(_OWORD *)v903 = 0u;
  *((_OWORD *)v333 + 1) = 0u;
  v334 = v915;
  v335 = CICleanUpPush(v915, (uint64_t)ChangeHolderFreeDocIds, (uint64_t)v333);
  v999[3] = 0;
  v1007[3] = 0;
  if (prot_pread(v1033, v1039, 0x10000uLL, 0) == -1)
    v1025 = 1;
  v876 = v335;
  v336 = (uint64_t)v910;
  packContextInit((uint64_t)v910);
  v874 = CICleanUpPush(v334, (uint64_t)packContextDestroy, v336);
  v337 = v909;
  *v909 = 0u;
  v337[1] = 0u;
  v337[2] = 0u;
  v337[3] = 0u;
  v337[4] = 0u;
  *((_QWORD *)v337 + 10) = 0;
  writeWindowInit((uint64_t)v337, (_QWORD *)(v1026 + 9632), 3 * v995[3] + v894, *(_BYTE *)(*v10 + 16441) == 0);
  do
  {
    v338 = __ldxr(exceptionSequenceNum);
    v339 = v338 + 1;
  }
  while (__stxr(v338 + 1, exceptionSequenceNum));
  v957 = 0;
  memset(v956, 0, sizeof(v956));
  v340 = setThreadIdAndInfo(-1, sWritePosWindowExceptionCallbacks, (uint64_t)v909, 0, v339);
  *(_DWORD *)&v956[8] = HIDWORD(v340);
  v957 = v340;
  *(_DWORD *)&v956[4] = v341;
  *(_DWORD *)v956 = v342;
  v343 = *(_QWORD *)&threadData[18 * v340 + 2];
  v344 = v343 + 320 * HIDWORD(v340);
  v875 = *(_DWORD *)(v344 + 312);
  v345 = *(void (**)(_QWORD))(v344 + 224);
  if (v345)
    v345(*(_QWORD *)(v343 + 320 * HIDWORD(v340) + 288));
  v877 = v339;
  v955 = v957;
  v954 = *(_DWORD *)&v956[8];
  v953 = *(_QWORD *)v956;
  v346 = _setjmp((int *)v344);
  v349 = v910;
  if (v346)
  {
    v350 = (_DWORD *)(v344 + 312);
    v351 = *__error();
    v352 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v352, OS_LOG_TYPE_ERROR))
    {
      v1038.f_bsize = 136315394;
      *(_QWORD *)&v1038.f_iosize = "mergeIndexData";
      WORD2(v1038.f_blocks) = 1024;
      *(_DWORD *)((char *)&v1038.f_blocks + 6) = 2763;
      _os_log_error_impl(&dword_1B8270000, v352, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", (uint8_t *)&v1038, 0x12u);
    }
    *__error() = v351;
    *v350 = v875;
    CIOnThreadCleanUpReset(v953);
    dropThreadId(v955, 1, v877);
    CICleanUpReset(v955, HIDWORD(v953));
    goto LABEL_619;
  }
  v354 = v922;
  if (!v1003[3])
    goto LABEL_609;
  v355 = 0;
  v873 = (uint64_t *)(v908 + 200);
  v872 = v10 - 1;
  v871 = v902 - 24;
  v870 = v878 - 4;
  v356 = 1;
  v357 = 26570;
  v869 = 15152;
  v868 = 24;
  v358 = v904;
  v867 = 224;
  *(_QWORD *)&v347 = 134218240;
  v866 = v347;
  *(_QWORD *)&v347 = 136315906;
  v865 = v347;
  *(_QWORD *)&v347 = 136316162;
  v864 = v347;
  v863 = 2168;
  *(_QWORD *)&v347 = 136316418;
  *(_QWORD *)&v348 = 136316418;
  v862 = v348;
  v861 = v347;
  *(_QWORD *)&v347 = 67109120;
  v860 = v347;
  v859 = 4123950068;
  *(_QWORD *)&v347 = 134217984;
  v858 = v347;
  v857 = xmmword_1B8631CD0;
  v856 = 0x8200302uLL;
  v855 = 4960;
  v854 = 9672;
  v853 = 0x10000;
  while (2)
  {
    v852 = v356;
    if (v1025)
      break;
    v359 = v355;
    if (v355 > v357)
    {
      v1025 = 0;
      ++v357;
    }
    v360 = atomic_load((unsigned int *)(*v10 + v869));
    v851 = v357;
    if (v360)
    {
      v361 = 1;
    }
    else
    {
      v362 = (*(uint64_t (**)(_QWORD))(v354 + 16))(*(_QWORD *)(v354 + 32));
      v358 = v904;
      v361 = v362;
    }
    v1025 = v361;
    *((_DWORD *)v349 + 2) = 0;
    *((_DWORD *)v349 + 6) = 0;
    v349[2] = 0;
    v349[10] = 0;
    v349[12] = 0;
    v349[14] = 0;
    v363 = v999;
    v364 = v999[3];
    v365 = v359 + 2;
    if (v364 + 0x10000 <= v359 + 2)
    {
      v366 = v359 & ~*MEMORY[0x1E0C85AC0];
      v999[3] = v366;
      if (prot_pread(v1033, v1039, 0x10000uLL, v366) == -1)
        goto LABEL_608;
      v363 = v999;
      v364 = v999[3];
      v358 = v904;
    }
    v367 = *(__int16 *)&v1039[v359 - v364];
    if (!v367)
    {
      v679 = __si_assert_copy_extra_5354(0, -1);
      v651 = v679;
      v680 = "";
      if (v679)
        HIDWORD(v680) = HIDWORD(v679);
      HIDWORD(v694) = HIDWORD(v680);
      goto LABEL_791;
    }
    if (v367 > v9)
    {
      v681 = __si_assert_copy_extra_5354(0, -1);
      v648 = v681;
      v682 = "";
      if (v681)
        HIDWORD(v682) = HIDWORD(v681);
      HIDWORD(v694) = HIDWORD(v682);
      goto LABEL_827;
    }
    v847 = v367;
    if (v364 + 0x10000 <= v365 + (int)v367 * (uint64_t)v868)
    {
      v368 = v365 & ~*MEMORY[0x1E0C85AC0];
      v363[3] = v368;
      v369 = prot_pread(v1033, v1039, v853, v368);
      v358 = v904;
      if (v369 == -1)
      {
LABEL_608:
        v1025 = 1;
        break;
      }
    }
    v850 = *(_QWORD *)(v1026 + 9640);
    v349[28] = 0;
    *((_DWORD *)v349 + 58) = -1;
    if (v358 && v365 < v991[3])
    {
      createWPCOccurenceCountMap(v873);
      v358 = v904;
    }
    if ((int)v367 < 1)
    {
      v502 = v365;
      v501 = 0;
      goto LABEL_553;
    }
    v370 = 0xFFFFFFFFLL;
    v371 = 0;
    v372 = v365;
    while (2)
    {
      v373 = (uint64_t *)&v1039[v372 - v999[3]];
      v374 = v373[2];
      if (v370 <= v374)
      {
        v683 = __si_assert_copy_extra_5354(0, -1);
        v651 = v683;
        v684 = "";
        if (v683)
          HIDWORD(v684) = HIDWORD(v683);
        HIDWORD(v694) = HIDWORD(v684);
        goto LABEL_791;
      }
      v848 = v373[2];
      v375 = v872;
      v845 = v371;
      if (v371)
      {
        v376 = (v848 + 1);
        if (v370 > v376)
        {
          v377 = &v871[24 * v370];
          v378 = v370;
          do
          {
            v379 = v910;
            *((_DWORD *)v910 + 6) = *(_DWORD *)&v870[4 * v378];
            v379[2] = v377;
            v379[10] = *(void **)(v375[v378] + 14432);
            if (v379[12])
              merge_checkAgainstUpdates1((uint64_t)v379, v903, 0, *(_QWORD *)(v375[v378] + 72));
            --v378;
            v377 -= 24;
          }
          while (v378 > v376);
        }
      }
      if (v374 >= v9)
      {
        v685 = __si_assert_copy_extra_5354(0, -1);
        v648 = v685;
        v686 = "";
        if (v685)
          HIDWORD(v686) = HIDWORD(v685);
        HIDWORD(v694) = HIDWORD(v686);
        goto LABEL_827;
      }
      v380 = v848;
      v381 = (uint64_t)v910;
      *((_DWORD *)v910 + 6) = *(_DWORD *)&v901[4 * v848];
      *(_QWORD *)(v381 + 16) = &v902[24 * v374];
      *(_QWORD *)(v381 + 80) = *(_QWORD *)(v10[v380] + 14432);
      v382 = v10[v380];
      v843 = *(_QWORD *)(v382 + 14368);
      v383 = *v373;
      v384 = v373[1];
      v385 = &v905[16 * v374];
      v386 = *(_DWORD **)&v890[8 * v380];
      v387 = *(unsigned int *)(v382 + 60);
      v388 = *(_QWORD *)(v382 + 72);
      v389 = atomic_load((unsigned int *)(v382 + 28));
      v390 = *(_QWORD *)&v891[8 * v380];
      v391 = *(_QWORD *)(v381 + 16);
      v392 = *((_QWORD *)v385 + 1);
      v844 = (uint64_t *)(v385 + 8);
      if (v392)
        v393 = dword_1EF19FCB4 < 5;
      else
        v393 = 1;
      v842 = v389;
      if (!v393)
      {
        v698 = v387;
        v699 = v386;
        v700 = v383;
        v696 = *__error();
        v695 = (os_log_t)_SILogForLogForCategory(10);
        if (os_log_type_enabled(v695, OS_LOG_TYPE_DEFAULT))
        {
          v1038.f_bsize = v858;
          *(_QWORD *)&v1038.f_iosize = v700;
          _os_log_impl(&dword_1B8270000, v695, OS_LOG_TYPE_DEFAULT, "start %lld", (uint8_t *)&v1038, 0xCu);
        }
        *__error() = v696;
        v389 = v842;
        v386 = v699;
        v383 = v700;
        v387 = v698;
      }
      v846 = v372 + 24;
      v840 = v382;
      v839 = &v907[v374 * v867];
      v838 = (void **)v385;
      v841 = v386;
      v837 = v388;
      v836 = v389;
      v833 = v388 + v387;
      v832 = v388 + v387;
      v831 = (unint64_t *)&v907[224 * v374 + 40];
      v394 = v390;
      v395 = v384;
      v396 = v383;
      v9 = v924;
      v74 = v923;
      v349 = v910;
      v835 = v392;
      while (2)
      {
        v830 = v395;
        if (v392 && dword_1EF19FCB4 >= 5)
        {
          v474 = v389;
          v475 = *__error();
          v476 = _SILogForLogForCategory(10);
          if (os_log_type_enabled(v476, OS_LOG_TYPE_DEFAULT))
          {
            v1038.f_bsize = v866;
            *(_QWORD *)&v1038.f_iosize = v838;
            WORD2(v1038.f_blocks) = 2048;
            *(uint64_t *)((char *)&v1038.f_blocks + 6) = v396;
            _os_log_impl(&dword_1B8270000, v476, OS_LOG_TYPE_DEFAULT, "%p offset %lld", (uint8_t *)&v1038, 0x16u);
          }
          *__error() = v475;
          v9 = v924;
          v74 = v923;
          v349 = v910;
          v389 = v474;
          v392 = v835;
          v395 = v830;
        }
        if (resetReadPosContext(v395, (uint64_t)v839, (v389 >> 2) & 1) == -1)
        {
          v498 = __error();
          v499 = *v498;
          *((_DWORD *)v349 + 44) = *v498;
          goto LABEL_533;
        }
        if (!v396)
          goto LABEL_532;
        v834 = v396;
        if (!v392)
        {
          v399 = *MEMORY[0x1E0C85AD8] << 6;
          if (v394 && v396 > v394 && v399 + v394 > v396 + 25
            || (v394 = (0x4000000000000000 - *MEMORY[0x1E0C85AD8]) & v396,
                *(_QWORD *)&v891[8 * v848] = v394,
                fd_pread(v841, *v838, v399, v394) != -1))
          {
            v398 = v396 - v394;
            v397 = v394;
            goto LABEL_381;
          }
          v529 = *__error();
          goto LABEL_598;
        }
        *(_QWORD *)&v891[8 * v848] = 0;
        if (v396 > *v844)
        {
          v527 = *__error();
          v528 = _SILogForLogForCategory(10);
          if (os_log_type_enabled(v528, OS_LOG_TYPE_ERROR))
          {
            v534 = *v844;
            v1038.f_bsize = v865;
            *(_QWORD *)&v1038.f_iosize = "unpackAndCleanse";
            WORD2(v1038.f_blocks) = 1024;
            *(_DWORD *)((char *)&v1038.f_blocks + 6) = 3848;
            WORD1(v1038.f_bfree) = 2048;
            *(uint64_t *)((char *)&v1038.f_bfree + 4) = v396;
            WORD2(v1038.f_bavail) = 2048;
            *(uint64_t *)((char *)&v1038.f_bavail + 6) = v534;
            _os_log_error_impl(&dword_1B8270000, v528, OS_LOG_TYPE_ERROR, "%s:%d: Nextlink out of bounds %lld %lld", (uint8_t *)&v1038, 0x26u);
          }
          *__error() = v527;
          v529 = 22;
LABEL_598:
          *((_DWORD *)v349 + 44) = v529;
          goto LABEL_550;
        }
        if (v396 >= *v844)
        {
          v677 = __si_assert_copy_extra_5354(0, -1);
          v651 = v677;
          v678 = "";
          if (v677)
            HIDWORD(v678) = HIDWORD(v677);
          HIDWORD(v694) = HIDWORD(v678);
          goto LABEL_791;
        }
        v397 = 0;
        v398 = v396;
LABEL_381:
        v828 = v397;
        v400 = 0;
        v401 = 0;
        v402 = v398;
        do
        {
          v403 = v402;
          v404 = v401;
          v405 = v402 + 1;
          v406 = ((unint64_t)(*((_BYTE *)*v838 + v402) & 0x7F) << v401) | v400;
          v407 = v406;
          if ((*((_BYTE *)*v838 + v402) & 0x80) == 0)
            break;
          v401 += 7;
          ++v402;
          v400 = v406;
        }
        while (v404 != 63);
        v408 = v406 >> 1;
        v829 = v406 >> 1;
        if (v392 && v408 > *v844)
        {
          v826 = v391;
          v409 = *__error();
          v410 = _SILogForLogForCategory(10);
          if (os_log_type_enabled(v410, OS_LOG_TYPE_ERROR))
          {
            v445 = *v844;
            v1038.f_bsize = v864;
            *(_QWORD *)&v1038.f_iosize = "unpackAndCleanse";
            WORD2(v1038.f_blocks) = 1024;
            *(_DWORD *)((char *)&v1038.f_blocks + 6) = 3881;
            WORD1(v1038.f_bfree) = 2048;
            *(uint64_t *)((char *)&v1038.f_bfree + 4) = v834;
            WORD2(v1038.f_bavail) = 2048;
            *(uint64_t *)((char *)&v1038.f_bavail + 6) = v829;
            HIWORD(v1038.f_files) = 2048;
            v1038.f_ffree = v445;
            _os_log_error_impl(&dword_1B8270000, v410, OS_LOG_TYPE_ERROR, "%s:%d: %lld %lld %lld", (uint8_t *)&v1038, 0x30u);
          }
          *__error() = v409;
          v349 = v910;
          v392 = v835;
          v408 = v406 >> 1;
          v391 = v826;
        }
        if ((v836 & 4) != 0 && v406 >= 2)
        {
          bzero(&v1038, v863);
          if (fd_validfs(v841))
          {
            v535 = v841 ? v841[11] : -1;
            if (!fstatfs(v535, &v1038))
            {
              if (__valid_fsp(v841))
              {
                v690 = __si_assert_copy_extra_5354(v841, -1);
                v691 = v690;
                v692 = "";
                if (v690)
                  v692 = v690;
                si_analytics_log_2520("%s:%u: failed assertion '%s' %s Unexpected compact nxtLink %lld at offset %ld", "CIMerging.c", 3900, "!(isCompact && nxtLink != 0)", v692, v829, v405);
                free(v691);
                v693 = 2816;
              }
              else
              {
                v693 = 3072;
              }
              *(_DWORD *)v693 = -559038737;
              abort();
            }
          }
          v506 = *__error();
          v349 = v910;
LABEL_548:
          *((_DWORD *)v349 + 44) = v506;
          goto LABEL_549;
        }
        v411 = (char *)*v838;
        v412 = *v838;
        v827 = v408;
        if ((v406 & 1) == 0)
        {
          v413 = 0;
          v414 = 0;
          do
          {
            v415 = v405;
            v416 = v414;
            v417 = v405 + 1;
            v418 = ((unint64_t)(v412[v405] & 0x7F) << v414) | v413;
            if ((v412[v405] & 0x80) == 0)
              break;
            v414 += 7;
            ++v405;
            v413 = v418;
          }
          while (v416 != 63);
          v419 = v834;
          if ((v418 & 1) != 0)
          {
            v428 = v418 >> 1;
            goto LABEL_467;
          }
          v420 = v415 + 2;
          v421 = (char)v412[v417];
          v422 = v412[v417];
          if (v421 < 0)
          {
            v432 = v415 + 3;
            v433 = (char)v412[v420];
            v434 = v412[v420];
            if ((v433 & 0x80000000) == 0)
            {
              v423 = v422 & 0x7F | (v434 << 7);
              v420 = v432;
              goto LABEL_466;
            }
            v438 = v415 + 4;
            v439 = (char)v412[v432];
            v440 = v412[v432];
            if ((v439 & 0x80000000) == 0)
            {
              v423 = ((v434 & 0x7F) << 7) | (v440 << 14) | v422 & 0x7F;
              v420 = v438;
              goto LABEL_466;
            }
            v446 = v415 + 5;
            v447 = (char)v412[v438];
            v448 = v412[v438];
            if ((v447 & 0x80000000) == 0)
            {
              v423 = ((v440 & 0x7F) << 14) | (v448 << 21) | ((v434 & 0x7F) << 7) | v422 & 0x7F;
              v420 = v446;
              goto LABEL_466;
            }
            v467 = (char)v412[v446];
            if ((v467 & 0x80000000) == 0)
            {
              v468 = ((v448 & 0x7F) << 21) | (v467 << 28) | ((v440 & 0x7F) << 14) | ((v434 & 0x7F) << 7) | v422 & 0x7F;
              v420 = v415 + 6;
              v423 = v468;
              v74 = v923;
              v349 = v910;
              goto LABEL_466;
            }
            v651 = __si_assert_copy_extra_5354(0, -1);
            __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t");
            goto LABEL_792;
          }
          v423 = v422;
LABEL_466:
          v428 = v418 >> 1;
          if (!v423)
          {
            v477 = (char)v412[v420];
            v478 = v412[v420];
            v479 = v478;
            if (v477 < 0)
            {
              v480 = &v411[v420];
              v481 = v411[v420 + 1];
              if (v411[v420 + 1] < 0)
              {
                v489 = v480[2];
                v490 = v480[2];
                if (v489 < 0)
                {
                  v492 = &v411[v420];
                  v493 = v492[3];
                  if (v492[3] < 0)
                  {
                    v495 = v492[4];
                    if (v495 < 0)
                    {
LABEL_835:
                      v648 = __si_assert_copy_extra_5354(0, -1);
                      __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t");
                      goto LABEL_828;
                    }
                    v494 = ((v493 & 0x7F) << 21) | (v495 << 28) | ((v490 & 0x7F) << 14);
                  }
                  else
                  {
                    v494 = ((v490 & 0x7F) << 14) | (v493 << 21);
                  }
                  v491 = v494 & 0xFFFFC07F | ((v481 & 0x7F) << 7);
                }
                else
                {
                  v491 = ((v481 & 0x7F) << 7) | (v490 << 14);
                }
                v479 = v491 & 0xFFFFFF80 | v478 & 0x7F;
              }
              else
              {
                v479 = v478 & 0x7F | (v481 << 7);
              }
            }
            if (v479)
            {
              if (v833 <= v418 >> 1)
              {
                v496 = *__error();
                v497 = _SILogForLogForCategory(10);
                if (os_log_type_enabled(v497, OS_LOG_TYPE_ERROR))
                {
                  v1038.f_bsize = v861;
                  *(_QWORD *)&v1038.f_iosize = "unpackAndCleanse";
                  WORD2(v1038.f_blocks) = 1024;
                  *(_DWORD *)((char *)&v1038.f_blocks + 6) = 3921;
                  WORD1(v1038.f_bfree) = 2048;
                  *(uint64_t *)((char *)&v1038.f_bfree + 4) = v428;
                  WORD2(v1038.f_bavail) = 2048;
                  *(uint64_t *)((char *)&v1038.f_bavail + 6) = v832;
                  HIWORD(v1038.f_files) = 1024;
                  LODWORD(v1038.f_ffree) = v479;
                  WORD2(v1038.f_ffree) = 2048;
                  *(uint64_t *)((char *)&v1038.f_ffree + 6) = v832;
                  _os_log_error_impl(&dword_1B8270000, v497, OS_LOG_TYPE_ERROR, "%s:%d: Element outside legal range %lld>=%lld type %d (starting max %lld)", (uint8_t *)&v1038, 0x36u);
                }
                *__error() = v496;
                v74 = v923;
                v349 = v910;
              }
              else
              {
                v74 = v923;
                v349 = v910;
                if (v418 >= 2)
                  merge_handleUpdate((uint64_t)v903, v418 >> 1, v479);
              }
              goto LABEL_483;
            }
            v74 = v923;
            v349 = v910;
          }
LABEL_467:
          if (v349[12])
          {
            if (v349[14])
            {
              if (v428 + v388 <= **v903
                && (merge_checkAgainstUpdates((uint64_t)v349, (uint64_t)v903, v428, v837) & 1) != 0)
              {
                goto LABEL_483;
              }
              goto LABEL_470;
            }
            v688 = __si_assert_copy_extra_5354(0, -1);
            v651 = v688;
            v689 = "";
            if (v688)
              HIDWORD(v689) = HIDWORD(v688);
            HIDWORD(v694) = HIDWORD(v689);
LABEL_791:
            __message_assert("%s:%u: failed assertion '%s' %s ");
LABEL_792:
            free(v651);
            if (__valid_fs(-1))
              v666 = 2989;
            else
              v666 = 3072;
            *(_DWORD *)v666 = -559038737;
            abort();
          }
LABEL_470:
          if (v428 && v428 < (unint64_t)*((unsigned int *)v349 + 6))
          {
            v469 = *(_QWORD *)(v391 + 16);
            if (*(_BYTE *)v391)
            {
              if ((CIIndexSetHasIndex(v469, v428) & 1) != 0)
              {
                if (*(_BYTE *)v391)
                  v470 = *(_DWORD *)(v391 + 8) + v428;
                else
                  v470 = *(_DWORD *)(*(_QWORD *)(v391 + 16) + 4 * v428);
LABEL_488:
                packContextAppend((uint64_t)v349, v470);
                v472 = 0;
                v471 = v909;
LABEL_478:
                DataForOneDocument = readDataForOneDocument((uint64_t)v471, v472, (uint64_t)v839, v428, v836);
                if (DataForOneDocument != -1)
                {
                  if (v904 && DataForOneDocument >= 1 && *v873)
                    MDDictionaryUIntUIntIncrementValue();
                  goto LABEL_483;
                }
                *((_DWORD *)v349 + 44) = *__error();
                v9 = v924;
LABEL_550:
                v10 = v920;
                v358 = v904;
LABEL_551:
                v1025 = 1;
                v502 = v846;
                v501 = v848;
                goto LABEL_553;
              }
            }
            else
            {
              v470 = *(_DWORD *)(v469 + 4 * v428);
              if (v470)
                goto LABEL_488;
            }
          }
          v471 = v909;
          v472 = 1;
          goto LABEL_478;
        }
        v424 = v403 + 2;
        v425 = v412[v405];
        if (v425 < 0)
        {
          v429 = v403 + 3;
          v430 = (char)v412[v424];
          v431 = v412[v424];
          if (v430 < 0)
          {
            v435 = v403 + 4;
            v436 = (char)v412[v429];
            v437 = v412[v429];
            if (v436 < 0)
            {
              v441 = v403 + 5;
              v442 = (char)v412[v435];
              v443 = v412[v435];
              if (v442 < 0)
              {
                v449 = (char)v412[v441];
                if (v449 < 0)
                  goto LABEL_835;
                v441 = v403 + 6;
                v444 = ((v443 & 0x7F) << 21) | (v449 << 28) | ((v437 & 0x7F) << 14);
              }
              else
              {
                v444 = ((v437 & 0x7F) << 14) | (v443 << 21);
              }
              v427 = v444 & 0xFFFFC000 | ((v431 & 0x7F) << 7) | v425 & 0x7F;
              v426 = v441;
            }
            else
            {
              v427 = ((v431 & 0x7F) << 7) | (v437 << 14) | v425 & 0x7F;
              v426 = v403 + 4;
            }
          }
          else
          {
            v427 = v425 & 0x7F | (v431 << 7);
            v426 = v403 + 3;
          }
        }
        else
        {
          v426 = v403 + 2;
          v427 = v412[v405];
        }
        v450 = &v411[v426];
        v451 = v427;
        v804 = v426;
        if (!v392 && v426 + v427 > (*MEMORY[0x1E0C85AD8] << 6))
        {
          v482 = (char *)malloc_type_malloc(v427, v859);
          if ((v451 & 0x3F80) != 0)
            v483 = 2;
          else
            v483 = 1;
          if ((v451 & 0x1FC000) != 0)
            v483 = 3;
          if ((v451 & 0xFE00000) != 0)
            v484 = 4;
          else
            v484 = v483;
          if (v451 >> 28)
            v485 = 5;
          else
            v485 = v484;
          if (v406 >= 0x80)
          {
            v487 = 1;
            do
            {
              ++v487;
              v488 = v407 >> 14;
              v486 = v487;
              v407 >>= 7;
            }
            while (v488);
          }
          else
          {
            v486 = 1;
          }
          if (fd_pread(*(_DWORD **)(v840 + 9400), v482, v451, v834 + (v486 + v485)) != -1)
          {
            v450 = v482;
            v349 = v910;
            goto LABEL_418;
          }
          v537 = __error();
          v349 = v910;
          *((_DWORD *)v910 + 44) = *v537;
          free(v482);
LABEL_549:
          v9 = v924;
          v74 = v923;
          goto LABEL_550;
        }
LABEL_418:
        v1037 = 0;
        v1034 = 0u;
        v1035 = (uint64_t)v450;
        v801 = v451;
        v1036 = v451;
        v767 = v450;
        if (v450)
          v452 = (_DWORD)v451 == 0;
        else
          v452 = 1;
        v453 = v452;
        HIDWORD(v1037) = v453;
        LODWORD(v945) = 0;
        v454 = v832;
        while (1)
        {
          v455 = v454;
          DocID = PostingChunkEnumeratorNextDocID((unint64_t *)&v1034, (int *)&v945);
          if (!DocID)
            break;
          v457 = DocID;
          v458 = DocID;
          if ((_DWORD)v945)
          {
            if (v455 <= DocID)
            {
              v465 = *__error();
              v466 = _SILogForLogForCategory(10);
              if (os_log_type_enabled(v466, OS_LOG_TYPE_ERROR))
              {
                v1038.f_bsize = v862;
                *(_QWORD *)&v1038.f_iosize = "unpackAndCleanse";
                WORD2(v1038.f_blocks) = 1024;
                *(_DWORD *)((char *)&v1038.f_blocks + 6) = 4023;
                WORD1(v1038.f_bfree) = 2048;
                *(uint64_t *)((char *)&v1038.f_bfree + 4) = v458;
                WORD2(v1038.f_bavail) = 2048;
                *(uint64_t *)((char *)&v1038.f_bavail + 6) = v455;
                HIWORD(v1038.f_files) = 1024;
                LODWORD(v1038.f_ffree) = v945;
                WORD2(v1038.f_ffree) = 2048;
                *(uint64_t *)((char *)&v1038.f_ffree + 6) = v832;
                _os_log_error_impl(&dword_1B8270000, v466, OS_LOG_TYPE_ERROR, "%s:%d: Element outside legal range %lld>=%lld type %d (starting max %lld)", (uint8_t *)&v1038, 0x36u);
              }
              *__error() = v465;
            }
            else
            {
              merge_handleUpdate((uint64_t)v903, DocID, v945);
            }
            v454 = v455;
            v349 = v910;
          }
          else
          {
            if (!v349[12])
              goto LABEL_430;
            if (!v349[14])
            {
              v661 = __si_assert_copy_extra_5354(0, -1);
              v648 = v661;
              v662 = "";
              if (v661)
                HIDWORD(v662) = HIDWORD(v661);
              HIDWORD(v694) = HIDWORD(v662);
              goto LABEL_827;
            }
            if (v388 + (unint64_t)DocID > **v903
              || (v464 = merge_checkAgainstUpdates((uint64_t)v349, (uint64_t)v903, DocID, v837),
                  v454 = v455,
                  (v464 & 1) == 0))
            {
LABEL_430:
              if (!(_DWORD)v458)
              {
                v462 = v455;
                goto LABEL_443;
              }
              v459 = *((unsigned int *)v349 + 6);
              if (v457 >= v459)
                goto LABEL_440;
              v460 = *(_QWORD *)(v391 + 16);
              if (*(_BYTE *)v391)
              {
                if ((CIIndexSetHasIndex(v460, v458) & 1) == 0)
                {
                  v349 = v910;
                  v459 = *((unsigned int *)v910 + 6);
LABEL_440:
                  if (v457 >= v459)
                    v462 = v455;
                  else
                    v462 = v457 + v388;
LABEL_443:
                  v463 = readDataForOneDocument((uint64_t)v909, 1, (uint64_t)v839, v458, v836);
                  if (v463 == -1)
                    goto LABEL_547;
                  goto LABEL_444;
                }
                if (*(_BYTE *)v391)
                  v461 = *(_DWORD *)(v391 + 8) + v458;
                else
                  v461 = *(_DWORD *)(*(_QWORD *)(v391 + 16) + 4 * v457);
                v349 = v910;
              }
              else
              {
                v461 = *(_DWORD *)(v460 + 4 * v457);
                v349 = v910;
                if (!v461)
                  goto LABEL_440;
              }
              packContextAppend((uint64_t)v349, v461);
              v463 = readDataForOneDocument((uint64_t)v909, 0, (uint64_t)v839, v458, v836);
              if (v463 == -1)
              {
LABEL_547:
                v506 = *__error();
                goto LABEL_548;
              }
              v462 = v457 + v388;
LABEL_444:
              v454 = v462;
              if (v904)
              {
                v454 = v462;
                if (v463 >= 1)
                {
                  v454 = v462;
                  if (*v873)
                  {
                    MDDictionaryUIntUIntIncrementValue();
                    v454 = v462;
                  }
                }
              }
            }
          }
        }
        if (!v835 && v804 + v801 > (*MEMORY[0x1E0C85AD8] << 6))
          free(v767);
        v74 = v923;
        v419 = v834;
LABEL_483:
        if (v406 >= 2)
        {
          v9 = v924;
          if (v419 == v827)
          {
            v675 = __si_assert_copy_extra_5354(0, -1);
            v648 = v675;
            v676 = "";
            if (v675)
              HIDWORD(v676) = HIDWORD(v675);
            HIDWORD(v694) = HIDWORD(v676);
            goto LABEL_827;
          }
          v395 = 0;
          v394 = v828;
          v396 = v829;
          v389 = v842;
          v392 = v835;
          if (v830)
          {
            v395 = *v831;
            v394 = v828;
            v396 = v829;
          }
          continue;
        }
        break;
      }
      v9 = v924;
      if (dword_1EF19FCB4 >= 5)
      {
        v504 = *__error();
        v505 = _SILogForLogForCategory(10);
        if (os_log_type_enabled(v505, OS_LOG_TYPE_DEFAULT))
        {
          *(_QWORD *)&v1038.f_bsize = v860;
          _os_log_impl(&dword_1B8270000, v505, OS_LOG_TYPE_DEFAULT, "merging last id %d", (uint8_t *)&v1038, 8u);
        }
        *__error() = v504;
        v9 = v924;
        v74 = v923;
        v349 = v910;
      }
LABEL_532:
      v499 = *((_DWORD *)v349 + 44);
LABEL_533:
      v358 = v904;
      v10 = v920;
      if (v499)
        goto LABEL_551;
      if (v1025 || (v500 = atomic_load((unsigned int *)(*v920 + 15152))) != 0)
      {
        v1025 = 1;
LABEL_600:
        v502 = v846;
        v501 = v848;
        v358 = v904;
        break;
      }
      v1025 = (*(uint64_t (**)(_QWORD))(v922 + 16))(*(_QWORD *)(v922 + 32));
      if ((v1025 & 1) != 0)
        goto LABEL_600;
      v501 = v848;
      if (v349[12])
        merge_checkAgainstUpdates1((uint64_t)v349, v903, 0, *(_QWORD *)(v10[v848] + 72));
      v371 = v845 + 1;
      v370 = v501;
      v502 = v846;
      v372 = v846;
      v358 = v904;
      if (v845 + 1 != v847)
        continue;
      break;
    }
LABEL_553:
    v507 = v852;
    if (v358 && *v873)
    {
      *(_QWORD *)&v1038.f_bsize = MEMORY[0x1E0C809B0];
      v1038.f_blocks = 0x40000000;
      v1038.f_bfree = (uint64_t)__push_termid_counts_block_invoke;
      v1038.f_bavail = (uint64_t)&__block_descriptor_tmp_77;
      v1038.f_files = (uint64_t)v921;
      v1038.f_ffree = v852;
      MDDictionaryUIntUIntIterateValues();
      v358 = v904;
    }
    if (v1025)
      goto LABEL_592;
    v508 = *((unsigned int *)v349 + 2);
    if (!(_DWORD)v508)
    {
      if (v349[12])
      {
        v974 = v857;
        goto LABEL_565;
      }
      goto LABEL_592;
    }
    v974 = v857;
    if ((_DWORD)v508 != 1)
    {
      v509 = (unsigned int *)((char *)*v349 + 4);
      v510 = *(_DWORD *)*v349;
      v511 = v508 - 1;
      while (1)
      {
        v512 = v510;
        v513 = *v509++;
        v510 = v513;
        if (v512 <= v513)
          break;
        if (!--v511)
          goto LABEL_565;
      }
      v673 = __si_assert_copy_extra_5354(0, -1);
      v648 = v673;
      v674 = "";
      if (v673)
        HIDWORD(v674) = HIDWORD(v673);
      HIDWORD(v694) = HIDWORD(v674);
LABEL_827:
      __message_assert("%s:%u: failed assertion '%s' %s ");
LABEL_828:
      free(v648);
      if (__valid_fs(-1))
        v687 = 2989;
      else
        v687 = 3072;
      *(_DWORD *)v687 = -559038737;
      abort();
    }
LABEL_565:
    if (v501)
    {
      v514 = &v871[24 * v501];
      do
      {
        *((_DWORD *)v349 + 6) = *(_DWORD *)&v870[4 * v501];
        v349[2] = v514;
        v515 = v872;
        v349[10] = *(void **)(v872[v501] + 14432);
        if (v349[12])
          merge_checkAgainstUpdates1((uint64_t)v349, v903, 0, *(_QWORD *)(v515[v501] + 72));
        v514 -= 24;
        --v501;
      }
      while (v501);
    }
    v516 = packContextFinalize((uint64_t)&v972);
    v517 = (_QWORD *)MEMORY[0x1E0C85AD8];
    v358 = v904;
    if ((_QWORD)v974 == v516)
      goto LABEL_592;
    v518 = v516;
    v519 = v850;
    v520 = v911;
    while (1)
    {
      v521 = v520[618];
      if (v520[616] - v518 + (uint64_t)v974 + *v517 <= v521)
        break;
      v522 = v950 + v521;
      v520[618] = v950 + v521;
      v523 = fd_truncate(v520[1175], v522);
      v358 = v904;
      v517 = (_QWORD *)MEMORY[0x1E0C85AD8];
      if (v523)
      {
        v1025 = 1;
        break;
      }
    }
    if (v1025)
      goto LABEL_592;
    v524 = v974 - v518;
    if ((uint64_t)v974 - v518 + *v517 <= v950)
    {
      v530 = v911[616];
      v531 = *((_QWORD *)&v949 + 1);
      v532 = v949;
      if ((uint64_t)v974 + v530 - (v518 + *((_QWORD *)&v949 + 1)) > v950)
      {
        sync_invalidate_mapping((char *)v949, v950);
        munmap((void *)v949, v950);
        *((_QWORD *)&v949 + 1) = v911[616] & ~*MEMORY[0x1E0C85AC0];
        v532 = fd_mmap(v911[1175]);
        *(_QWORD *)&v949 = v532;
        if (v532 == -1)
        {
          v1025 = 1;
          v9 = v924;
          v74 = v923;
          v10 = v920;
          v349 = v910;
          v255 = v899;
          break;
        }
        v530 = v911[616];
        v531 = *((_QWORD *)&v949 + 1);
        v524 = v974 - v518;
      }
      memcpy((void *)(v532 + v530 - v531), &v972[v518], v524);
      goto LABEL_589;
    }
    if (fd_pwrite(v911[1175], (uint64_t)&v972[v518], v524, v911[616]) == -1)
    {
      v525 = *__error();
      v526 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v526, OS_LOG_TYPE_ERROR))
      {
        v536 = *__error();
        v1038.f_bsize = v856;
        *(_QWORD *)&v1038.f_iosize = "mergeIndexData";
        WORD2(v1038.f_blocks) = 1024;
        *(_DWORD *)((char *)&v1038.f_blocks + 6) = 2665;
        WORD1(v1038.f_bfree) = 1024;
        HIDWORD(v1038.f_bfree) = v536;
        _os_log_error_impl(&dword_1B8270000, v526, OS_LOG_TYPE_ERROR, "%s:%d: pwrite error: %d", (uint8_t *)&v1038, 0x18u);
      }
      *__error() = v525;
      v1025 = 1;
LABEL_589:
      v9 = v924;
      v74 = v923;
      v10 = v920;
      v349 = v910;
      v507 = v852;
    }
    v533 = v911;
    termIdStoreSetNext(v1026 + v855, v507, v911[616]);
    v533[616] += v974 - v518;
    finishTermForWPCBuffer((uint64_t)v909);
    v358 = v904;
    if (v850 != *(_QWORD *)(v1026 + 9640))
    {
      termIdStoreSetNext(v1026 + v854, v507, v519);
      v358 = v904;
    }
LABEL_592:
    if (v358 && *v873)
    {
      destroyWPCOccurenceCountMap((const void **)v873);
      v358 = v904;
    }
    v356 = v507 + 1;
    v355 = v502;
    v357 = v851;
    v354 = v922;
    v255 = v899;
    if (v502 < v1003[3])
      continue;
    break;
  }
LABEL_609:
  v539 = v915;
  v540 = v880;
  if (v879 && v879 >= v880)
  {
    v541 = v879 + 1;
    do
      CICleanUpClearItem(v539, v540++);
    while (v541 != v540);
  }
  if (v9 >= 1)
  {
    v542 = (uint64_t)(v907 + 24);
    v543 = v906;
    v544 = v9;
    do
    {
      v545 = v544;
      finalizeReadBuffer((uint64_t)v543);
      finalizeReadBuffer(v542);
      v542 += 224;
      v543 += 16;
      v544 = v545 - 1;
    }
    while (v545 != 1);
  }
  v546 = v915;
  CICleanUpClearItem(v915, v874);
  free(*v349);
  FlattenPostingsContextDestroy((void **)v908 + 4);
  CICleanUpClearItem(v546, v893);
  free(v972);
  sync_invalidate_mapping((char *)v949, v950);
  munmap((void *)v949, v950);
  CICleanUpClearItem(v546, v876);
  free(v349[11]);
  free(v349[26]);
  writeWindowFinalize((uint64_t)v909);
  v971 = 0;
  v547 = *(_QWORD *)&threadData[18 * v955 + 2];
  v548 = v954;
  v549 = v547 + 320 * v954;
  *(_DWORD *)(v549 + 312) = v875;
  v550 = *(void (**)(_QWORD))(v549 + 232);
  if (v550)
    v550(*(_QWORD *)(v547 + 320 * v548 + 288));
  dropThreadId(v955, 0, v877);
LABEL_619:
  v87 = v921;
  v274 = v898;
  v551 = *(_QWORD *)&threadData[18 * v960 + 2];
  v552 = v959;
  v553 = v551 + 320 * v959;
  *(_DWORD *)(v553 + 312) = v881;
  v554 = *(void (**)(_QWORD))(v553 + 232);
  v101 = v922;
  if (v554)
    v554(*(_QWORD *)(v551 + 320 * v552 + 288));
  dropThreadId(v960, 0, v882);
LABEL_622:
  v555 = *(_QWORD *)&threadData[18 * v965 + 2];
  v556 = v964;
  v557 = v555 + 320 * v964;
  *(_DWORD *)(v557 + 312) = v886;
  v558 = *(void (**)(_QWORD))(v557 + 232);
  if (v558)
    v558(*(_QWORD *)(v555 + 320 * v556 + 288));
  dropThreadId(v965, 0, v887);
LABEL_625:
  v559 = *(_QWORD *)&threadData[18 * v970 + 2];
  v560 = v969;
  v561 = v559 + 320 * v969;
  *(_DWORD *)(v561 + 312) = v895;
  v562 = *(void (**)(_QWORD))(v561 + 232);
  if (v562)
    v562(*(_QWORD *)(v559 + 320 * v560 + 288));
  dropThreadId(v970, 0, v896);
LABEL_628:
  if (v971)
    v1025 = 1;
  if (v274)
    CICleanUpClearItem(v915, v274);
  if (v255)
    CFRelease(v255);
  if (!v74 || v1025)
  {
    if (v9 >= 1)
    {
      v563 = v902 + 16;
      v564 = v9;
      do
      {
        *v563 = 0;
        v563 += 3;
        --v564;
      }
      while (v564);
    }
    if (v74)
    {
      v565 = (uint64_t *)*v74;
      if (*v74)
      {
        if (*v565 < 1)
        {
          v570 = (void **)*v74;
        }
        else
        {
          v566 = 16;
          v567 = 0;
          do
          {
            v568 = v567;
            v569 = v566;
            free(*(void **)(v565[1] + v566));
            *(_QWORD *)(*((_QWORD *)*v74 + 1) + v569) = 0;
            v567 = v568 + 1;
            v565 = (uint64_t *)*v74;
            v570 = (void **)*v74;
            v566 = v569 + 24;
          }
          while (v568 + 1 < *(_QWORD *)*v74);
        }
        free(v570[1]);
        *((_QWORD *)*v74 + 1) = 0;
        free(*v74);
        *v74 = 0;
        v101 = v922;
        v87 = v921;
      }
    }
  }
LABEL_647:
  if (v1033 != -1)
    close(v1033);
  v1033 = -1;
  if (v1025 || (v571 = atomic_load((unsigned int *)(*v10 + 15152))) != 0)
    v572 = 1;
  else
    v572 = (*(uint64_t (**)(_QWORD))(v101 + 16))(*(_QWORD *)(v101 + 32));
  v1025 = v572;
  v573 = v911;
  v574 = v911[616];
  v911[618] = v574;
  v573[615] = v574;
  v573[619] = v574;
  v575 = *(_QWORD *)(v1026 + 9640);
  *(_QWORD *)(v1026 + 9656) = v575;
  *(_QWORD *)(v1026 + 9632) = v575;
  *(_QWORD *)(v1026 + 9664) = v575;
  *(_DWORD *)(v1026 + 52) = *(_DWORD *)(v1026 + 60) - 1;
  fd_truncate(v573[1175], v573[618]);
  fd_truncate(*(_QWORD *)(v1026 + 14112), *(_QWORD *)(v1026 + 9656));
  v576 = (*MEMORY[0x1E0C85AD8] + v913) & ~*MEMORY[0x1E0C85AC0];
  if (fd_truncate(*(_QWORD *)(v1026 + 464), v576))
  {
    v1025 = 1;
  }
  else
  {
    *(_QWORD *)(v1026 + 472) = v576;
    storageUnmap(v1026 + 248);
  }
  v577 = CFDictionaryCreateMutable(v916, 0, 0, MEMORY[0x1E0C9B3A0]);
  v952[0] = v919;
  v952[1] = v577;
  CFDictionaryApplyFunction(v87, (CFDictionaryApplierFunction)popTermIdCountPairsApplier, v952);
  if (!v1025)
  {
    *(_QWORD *)&v1034 = 0;
    *((_QWORD *)&v1034 + 1) = &v1034;
    v1035 = 0x2000000000;
    v1036 = 0;
    v972 = 0;
    v973 = (uint64_t)&v972;
    v974 = 0x2000000000uLL;
    *(_QWORD *)&v949 = 0;
    *((_QWORD *)&v949 + 1) = &v949;
    v950 = 0x2000000000;
    v951 = 0;
    *((_DWORD *)v1013 + 6) = 0;
    bzero(&v1038, 0x1020uLL);
    v945 = 0;
    v946 = &v945;
    v947 = 0x2000000000;
    v948 = 0;
    v578 = _SILogForLogForCategory(0);
    v579 = os_signpost_id_make_with_pointer(v578, 0);
    v580 = *(_DWORD *)(v1026 + 9368);
    if (!v1025)
    {
      v927 = MEMORY[0x1E0C809B0];
      v928 = 0x40000000;
      v929 = __mergeIndexData_block_invoke_22;
      v930 = &unk_1E6E305A8;
      v931 = &v1034;
      v932 = &v1012;
      v944 = v580;
      v938 = v919;
      v933 = &v1021;
      v939 = v577;
      v940 = v1044;
      v941 = v1026;
      v934 = &v949;
      v935 = &v972;
      v936 = v1010;
      v937 = &v945;
      v942 = &v1038;
      v943 = v579;
      v581 = iterateTermsForIndexes(v1026);
      v1025 |= v581;
    }
    if (*((_BYTE *)v946 + 24))
    {
      v582 = _SILogForLogForCategory(0);
      if (v579 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
      {
        v583 = v582;
        if (os_signpost_enabled(v582))
        {
          LOWORD(v976) = 0;
          _os_signpost_emit_with_name_impl(&dword_1B8270000, v583, OS_SIGNPOST_INTERVAL_END, v579, "vectorIndexInsertForMerge", "End", (uint8_t *)&v976, 2u);
        }
      }
    }
    v9 = v924;
    v10 = v920;
    if (v1025 || (v584 = atomic_load((unsigned int *)(*v920 + 15152))) != 0)
      v585 = 1;
    else
      v585 = (*(uint64_t (**)(_QWORD))(v922 + 16))(*(_QWORD *)(v922 + 32));
    v1025 = v585;
    _Block_object_dispose(&v945, 8);
    _Block_object_dispose(&v949, 8);
    _Block_object_dispose(&v972, 8);
    _Block_object_dispose(&v1034, 8);
  }
  _fd_unlink_with_origin(*(_QWORD *)(v1026 + 5176), 0);
  termIdStoreDestroy(v1026 + 4960);
  _fd_unlink_with_origin(*(_QWORD *)(v1026 + 9888), 0);
  termIdStoreDestroy(v1026 + 9672);
  fd_truncate(*(_QWORD *)(v1026 + 14408), 8 * *(unsigned int *)(v1026 + 60));
  fd_truncate(*(_QWORD *)(v1026 + 14416), 4 * *(unsigned int *)(v1026 + 60));
  if (*(_QWORD *)(v1026 + 14424))
    fd_truncate(*(_QWORD *)(v1026 + 14424), 8 * *(unsigned int *)(v1026 + 60));
  v586 = *(_DWORD *)(v1026 + 60);
  v587 = v915;
  if (!*(_BYTE *)(v1026 + 37))
    v586 = (4 * *(_DWORD *)(v1026 + 60) + 4) / 5u;
  fd_truncate(*(_QWORD *)(v1026 + 14432), v586);
  storageTruncate((uint64_t *)(v1026 + 248));
  if (!v1025)
  {
    v588 = (const void *)SIUINT64SetCreate();
    _CIDeleteDuplicates(v1026, (uint64_t)v588);
    CFRelease(v588);
    if (*(_QWORD *)(v1026 + 4896))
      truncateVectorIndex(*(_QWORD *)(v1026 + 4896));
    indexPerformSync(v1026);
    v587 = v915;
    if (*(_QWORD *)(v1026 + 4896))
      IVFVectorIndex_s::makeReadOnly((_QWORD *)(*(_QWORD *)(v1026 + 4896) + 8));
  }
  CICleanUpReset(v587, v914);
  if (v1026 && CFDictionaryGetCount((CFDictionaryRef)v1022[3]))
    emitTopKTerms(v1026, (const __CFDictionary *)v1022[3]);
  v1031 = 1;
  CFRelease(v577);
  if (v9 >= 1)
  {
    *(_QWORD *)&v589 = 136315650;
    v702 = v589;
    v590 = v10;
    v591 = v924;
    do
    {
      v592 = *(_QWORD *)(*v590 + 4896);
      if (v592)
      {
        v593 = *__error();
        v594 = _SILogForLogForCategory(16);
        if (os_log_type_enabled(v594, OS_LOG_TYPE_DEFAULT))
        {
          v595 = (_QWORD *)(v592 + 64);
          if (*(char *)(v592 + 87) < 0)
            v595 = (_QWORD *)*v595;
          v596 = (_QWORD *)(v592 + 40);
          if (*(char *)(v592 + 63) < 0)
            v596 = (_QWORD *)*v596;
          v1038.f_bsize = v702;
          *(_QWORD *)&v1038.f_iosize = v595;
          WORD2(v1038.f_blocks) = 2048;
          *(uint64_t *)((char *)&v1038.f_blocks + 6) = v592 + 8;
          HIWORD(v1038.f_bfree) = 2080;
          v1038.f_bavail = (uint64_t)v596;
          _os_log_impl(&dword_1B8270000, v594, OS_LOG_TYPE_DEFAULT, "[%s] destroyVectorIndexDumpContext: %p %s", (uint8_t *)&v1038, 0x20u);
        }
        *__error() = v593;
      }
      ++v590;
      --v591;
    }
    while (v591);
  }
  free(v912);
  _Block_object_dispose(&v990, 8);
  _Block_object_dispose(&v994, 8);
  _Block_object_dispose(&v998, 8);
  _Block_object_dispose(&v1002, 8);
  _Block_object_dispose(&v1006, 8);
  _Block_object_dispose(v1010, 8);
  _Block_object_dispose(&v1012, 8);
  v597 = *(_QWORD *)&threadData[18 * v1018 + 2];
  v598 = v1017;
  v599 = v597 + 320 * v1017;
  *(_DWORD *)(v599 + 312) = v917;
  v600 = *(void (**)(_QWORD))(v599 + 232);
  if (v600)
    v600(*(_QWORD *)(v597 + 320 * v598 + 288));
  dropThreadId(v1018, 0, v918);
  v81 = v925;
  v9 = v924;
  v74 = v923;
LABEL_692:
  v601 = v922;
  v602 = v921;
  CFDictionaryApplyFunction(v921, (CFDictionaryApplierFunction)pqDisposeApplier_5412, 0);
  CFRelease(v602);
  CFRelease(v919);
  CFRelease((CFTypeRef)v1022[3]);
  if (!v1031)
  {
    v603 = *__error();
    v604 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v604, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v1039 = 136315394;
      *(_QWORD *)&v1039[4] = "mergeIndexData";
      v1040 = 1024;
      LODWORD(v1041[0]) = 3248;
      _os_log_error_impl(&dword_1B8270000, v604, OS_LOG_TYPE_ERROR, "%s:%d: Exception raised during merging", v1039, 0x12u);
    }
    *__error() = v603;
    v1025 = 1;
    v601 = v922;
  }
  if (v1033 != -1)
  {
    close(v1033);
    v1033 = -1;
  }
  if (v1025)
  {
    if (v1026)
      _CIDeleteIndex(v1026, 1);
    v1026 = 0;
  }
  if (v74)
  {
    if (!v1026)
    {
      v605 = (uint64_t *)*v74;
      if (*v74)
      {
        if (*v605 < 1)
        {
          v610 = (void **)*v74;
        }
        else
        {
          v606 = 16;
          v607 = 0;
          do
          {
            v608 = v607;
            v609 = v606;
            free(*(void **)(v605[1] + v606));
            v607 = v608 + 1;
            v605 = (uint64_t *)*v74;
            v610 = (void **)*v74;
            v606 = v609 + 24;
          }
          while (v608 + 1 < *(_QWORD *)*v74);
        }
        free(v610[1]);
        free(*v74);
        *v74 = 0;
        v601 = v922;
      }
    }
  }
  v611 = *(void (**)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(v601 + 24);
  if (v611)
  {
    if (v1026)
    {
      v612 = *(_QWORD *)(v601 + 32);
      if (v74)
        v613 = "vacuum";
      else
        v613 = "";
      v614 = "MergeSuccess";
      v615 = 1;
    }
    else if ((*(unsigned int (**)(_QWORD))(v601 + 16))(*(_QWORD *)(v601 + 32)))
    {
      v611 = *(void (**)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(v601 + 24);
      v612 = *(_QWORD *)(v601 + 32);
      if (v74)
        v613 = "vacuum";
      else
        v613 = "";
      v615 = 0;
      v614 = "MergeCanceled";
    }
    else
    {
      v611 = *(void (**)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(v601 + 24);
      v612 = *(_QWORD *)(v601 + 32);
      if (v74)
        v613 = "vacuum";
      else
        v613 = "";
      v615 = 0;
      if (v1031)
        v614 = "MergeError";
      else
        v614 = "MergeException";
    }
    v611(v612, v614, v615, "Merge", v613, v9);
  }
  v616 = *__error();
  v617 = _SILogForLogForCategory(0);
  v618 = 2 * (gSILogLevels[0] < 4);
  if (os_log_type_enabled(v617, v618))
  {
    v619 = "Complete";
    if (!v1026)
      v619 = "Canceled";
    *(_DWORD *)v1039 = 136315394;
    *(_QWORD *)&v1039[4] = v619;
    v1040 = 2080;
    v1041[0] = v81;
    _os_log_impl(&dword_1B8270000, v617, v618, "Merging %s (%s)", v1039, 0x16u);
  }
  v620 = __error();
  v621 = 0;
  *v620 = v616;
  v806 = v1027[15];
  v805 = v1027[16];
  v803 = v1027[17];
  v802 = v1027[18];
  v800 = v1027[19];
  v799 = v1027[20];
  v798 = v1027[21];
  v797 = v1027[22];
  v796 = v1027[23];
  v795 = v1027[24];
  v794 = v1027[25];
  v793 = v1027[26];
  v792 = v1027[27];
  v791 = v1027[28];
  v790 = v1027[29];
  v789 = v1027[0];
  v788 = v1027[1];
  v787 = v1027[2];
  v786 = v1027[3];
  v785 = v1027[4];
  v784 = v1027[5];
  v783 = v1027[6];
  v782 = v1027[7];
  v781 = v1027[8];
  v780 = v1027[9];
  v779 = v1027[10];
  v777 = v1027[11];
  v776 = v1027[12];
  v775 = v1027[13];
  v774 = v1027[14];
  v773 = v1027[30];
  v772 = v1027[31];
  v771 = v1027[32];
  v770 = v1027[33];
  v769 = v1027[34];
  v768 = v1027[35];
  v766 = v1027[36];
  v765 = v1027[37];
  v764 = v1027[38];
  v763 = v1027[39];
  v762 = v1027[40];
  v761 = v1027[41];
  v760 = v1027[42];
  v759 = v1027[43];
  v758 = v1027[44];
  v757 = v1028[0];
  v756 = v1028[1];
  v754 = v1028[2];
  v753 = v1028[3];
  v751 = v1028[4];
  v749 = v1028[6];
  v750 = v1028[5];
  v747 = v1028[8];
  v748 = v1028[7];
  v745 = v1028[10];
  v746 = v1028[9];
  v743 = v1028[12];
  v744 = v1028[11];
  v741 = v1028[14];
  v742 = v1028[13];
  *(_QWORD *)v1039 = 0;
  v622 = 0;
  do
  {
    v623 = v1028[v621++] + v622;
    v622 = v623;
  }
  while (v621 != 15);
  v736 = v1029[1];
  v737 = v1029[0];
  v735 = v1029[2];
  v732 = v1029[4];
  v733 = v1029[3];
  v730 = v1029[6];
  v731 = v1029[5];
  v727 = v1029[7];
  v725 = v1029[8];
  v721 = v1029[10];
  v722 = v1029[9];
  v719 = v1029[12];
  v720 = v1029[11];
  v717 = v1029[14];
  v718 = v1029[13];
  v624 = 0;
  for (i = 0; i != 15; ++i)
  {
    v626 = v1029[i] + v624;
    v624 = v626;
  }
  v716 = v1030[0];
  v713 = v1030[2];
  v714 = v1030[1];
  v711 = v1030[4];
  v712 = v1030[3];
  v709 = v1030[6];
  v710 = v1030[5];
  v707 = v1030[8];
  v708 = v1030[7];
  v704 = v1030[10];
  v705 = v1030[9];
  v703 = v1030[11];
  v627 = 0;
  for (j = 0; j != 15; ++j)
  {
    v629 = v1030[j] + v627;
    v627 = v629;
  }
  v630 = 0;
  for (k = 0; k != 15; ++k)
  {
    v632 = v1029[k];
    if (v1030[k] < v632)
      v632 = v1030[k];
    v633 = v632 + v630;
    v630 = v633;
  }
  v634 = 0;
  v635 = 0;
  do
  {
    v636 = v1029[v634];
    if (v1030[v634 + 15] < v636)
      v636 = v1030[v634 + 15];
    v637 = v636 + v635;
    ++v634;
    v635 = v637;
  }
  while (v634 != 15);
  asprintf((char **)v1039, "absolute:  %lu, %lu, %lu, %lu, %lu, %lu, %lu, %lu, %lu, %lu, %lu, %lu, %lu, %lu, %lu\ndelta:     %lu, %lu, %lu, %lu, %lu, %lu, %lu, %lu, %lu, %lu, %lu, %lu, %lu, %lu, %lu\ncount:     %lu, %lu, %lu, %lu, %lu, %lu, %lu, %lu, %lu, %lu, %lu, %lu, %lu, %lu, %lu\nbytes:     %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu total: %lld\nterm - bytes:     %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu total: %lld\nterm  - words:     %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu total:%lld\nterm  - packings:     %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu, %llu,%lld\ntotal optimized term byte count: %llu\ntotal optimized term byte count with overhead: %llu\n", v806, v805, v803, v802, v800, v799, v798,
    v797,
    v796,
    v795,
    v794,
    v793,
    v792,
    v791,
    v790,
    v789,
    v788,
    v787,
    v786,
    v785,
    v784,
    v783,
    v782,
    v781,
    v780,
    v779,
    v777,
    v776,
    v775,
    v774,
    v773,
    v772,
    v771,
    v770,
    v769,
    v768,
    v766,
    v765,
    v764,
    v763,
    v762,
    v761,
    v760,
    v759,
    v758,
    v757,
    v756,
    v754,
    v753,
    v751,
    v750,
    v749,
    v748,
    v747,
    v746,
    v745,
    v744,
    v743,
    v742,
    v741,
    v623,
    v737,
    v736,
    v735,
    v733,
    v732,
    v731,
    v730,
    v727,
    v725,
    v722,
    v721,
    v720,
    v719,
    v718,
    v717,
    v626,
    v716,
    v714,
    v713,
    v712,
    v711,
    v710,
    v709,
    v708,
    v707,
    v705,
    v704,
    v703,
    v1030[12],
    v1030[13],
    v1030[14],
    v629,
    v1030[30],
    v1030[31],
    v1030[32],
    v1030[33],
    v1030[34],
    v1030[35],
    v1030[36],
    v1030[37],
    v1030[38],
    v1030[39],
    v1030[40],
    v1030[41],
    v1030[42],
    v1030[43],
    v1030[44],
    v1030[45],
    v633,
    v637);
  v638 = *(void **)v1039;
  v639 = *__error();
  v640 = _SILogForLogForCategory(0);
  v641 = 2 * (gSILogLevels[0] < 4);
  if (os_log_type_enabled(v640, v641))
  {
    *(_DWORD *)v1039 = 136315138;
    *(_QWORD *)&v1039[4] = v638;
    _os_log_impl(&dword_1B8270000, v640, v641, "Merge statistics: %s", v1039, 0xCu);
  }
  *__error() = v639;
  free(v638);
  v642 = v1026;
  _Block_object_dispose(&v1021, 8);
  return v642;
}

uint64_t __mergeIndexData_block_invoke(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  unint64_t v13;
  uint64_t result;
  int v16;
  NSObject *v17;
  int v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  int v28;
  char *v29;
  char *v30;
  const char *v31;
  uint64_t v32;
  uint8_t buf[4];
  const char *v34;
  __int16 v35;
  int v36;
  __int16 v37;
  int v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if ((unint64_t)(v6 + 24 * a3 + 2) < 0x10000)
  {
    result = 0;
  }
  else
  {
    v7 = (uint64_t *)MEMORY[0x1E0C85AC0];
    if (prot_pwrite(*(unsigned int *)(a1 + 96), *(char **)(a1 + 88), v6 & ~*MEMORY[0x1E0C85AC0], *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24)) == -1)
    {
      v16 = *__error();
      v17 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        v28 = *__error();
        *(_DWORD *)buf = 136315650;
        v34 = "mergeIndexData_block_invoke";
        v35 = 1024;
        v36 = 2144;
        v37 = 1024;
        v38 = v28;
        _os_log_error_impl(&dword_1B8270000, v17, OS_LOG_TYPE_ERROR, "%s:%d: pwrite error: %d", buf, 0x18u);
      }
      *__error() = v16;
      result = 1;
    }
    else
    {
      v8 = *v7;
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) += *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8)
                                                                               + 24) & ~*v7;
      v9 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
      v10 = *(_QWORD *)(v9 + 24);
      if ((v8 & v10) != 0)
      {
        v11 = 0;
        v12 = 1;
        do
        {
          *(_BYTE *)(*(_QWORD *)(a1 + 88) + v11) = *(_BYTE *)(*(_QWORD *)(a1 + 88) + (v10 & ~v8) + v11);
          v11 = v12;
          v9 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
          v10 = *(_QWORD *)(v9 + 24);
          v8 = *v7;
          v13 = *v7 & v10;
        }
        while (v13 > v12++);
      }
      else
      {
        v13 = 0;
      }
      result = 0;
      *(_QWORD *)(v9 + 24) = v13;
    }
  }
  if (a3 >= 1)
  {
    v18 = 0;
    v19 = a3;
    v20 = (uint64_t *)a2;
    v21 = a3;
    do
    {
      v22 = *v20;
      v20 += 8;
      if (v22)
        ++v18;
      --v21;
    }
    while (v21);
    if (v18)
    {
      ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24);
      v23 = *(_DWORD *)(a2 + 52);
      if (!v23)
        *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24) = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8)
                                                                                + 24);
      v24 = *(_QWORD *)(a1 + 88);
      *(_WORD *)(v24 + *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24)) = v18;
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += 2;
      if (v18 > a3)
      {
        v29 = __si_assert_copy_extra_5354(0, -1);
        v30 = v29;
        v31 = "";
        if (v29)
          v31 = v29;
        __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 2179, "count <= k", v31);
        free(v30);
        if (__valid_fs(-1))
          v32 = 2989;
        else
          v32 = 3072;
        *(_DWORD *)v32 = -559038737;
        abort();
      }
      do
      {
        if (*(_QWORD *)a2)
        {
          v25 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
          v26 = (_QWORD *)(v24 + *(_QWORD *)(v25 + 24));
          v27 = *(_QWORD *)(a2 + 8);
          *v26 = *(_QWORD *)a2;
          v26[1] = v27;
          v26[2] = *(_QWORD *)(a2 + 56);
          *(_QWORD *)(v25 + 24) += 24;
        }
        a2 += 64;
        --v19;
      }
      while (v19);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24) += 24 * v18 + 2;
      ++*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8) + 24);
      if (!v23)
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 8) + 24) = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8)
                                                                                + 24);
    }
  }
  return result;
}

BOOL iterateTermsForIndexes(uint64_t a1)
{
  uint64_t v1;
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  _QWORD *v8;
  _QWORD *v9;
  int64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  size_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  char *v22;
  _QWORD *v23;
  unsigned int v24;
  int v25;
  unsigned int v26;
  uint64_t v27;
  _QWORD *v28;
  uint64_t v29;
  char *v30;
  char *v31;
  char *v32;
  pthread_mutex_t *v33;
  pthread_cond_t *v34;
  int v35;
  NSObject *v36;
  os_log_type_t v37;
  uint64_t v38;
  void *v39;
  _OWORD *v40;
  _QWORD *v41;
  uint64_t v42;
  uint64_t *v43;
  uint64_t v44;
  _QWORD *v45;
  uint64_t v46;
  uint64_t v47;
  unsigned int v48;
  int v49;
  unint64_t v50;
  unsigned int v51;
  unsigned int v52;
  uint64_t v53;
  uint64_t v54;
  void (*v55)(_QWORD);
  int v56;
  NSObject *v57;
  uint64_t v58;
  int v61;
  int v62;
  int v63;
  int v64;
  int v65;
  int64_t v66;
  uint64_t v67;
  uint64_t v68;
  __int128 *v69;
  __int128 v70;
  __int128 v71;
  unsigned int v72;
  unint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  char *v77;
  __int128 v78;
  int v79;
  uint64_t v80;
  __int128 *v81;
  int64_t v82;
  __int128 *v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  uint64_t v90;
  unsigned int v91;
  uint64_t v92;
  void (*v93)(_QWORD);
  int v94;
  NSObject *v95;
  os_log_type_t v96;
  int v97;
  NSObject *v98;
  _opaque_pthread_t **v99;
  uint64_t *v100;
  _QWORD *v101;
  int64_t v102;
  uint64_t v103;
  unsigned int v104;
  _opaque_pthread_t *v105;
  void **v106;
  int64_t v107;
  int64_t v108;
  void **v109;
  char *v111;
  char *v112;
  const char *v113;
  char *v114;
  const char *v115;
  uint64_t v116;
  char *v117;
  char *v118;
  const char *v119;
  uint64_t v120;
  _QWORD *v121;
  _QWORD *v122;
  char *v123;
  char *v124;
  const char *v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  int v129;
  malloc_type_id_t v130;
  size_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  malloc_type_id_t v138;
  size_t v139;
  char *v140;
  int v141;
  int v142;
  size_t v143;
  size_t v144;
  uint64_t v145;
  uint64_t v146;
  int64_t v147;
  __int128 *v148;
  uint64_t v149;
  int64_t v150;
  uint64_t v151;
  int v152;
  int v153;
  _QWORD *v154;
  uint64_t v155;
  uint64_t v156;
  char *v157;
  void **v158;
  _opaque_pthread_t **v159;
  _QWORD *v160;
  _QWORD *v161;
  int64_t v162;
  _OWORD v163[3];
  uint64_t v164;
  unint64_t v165;
  unsigned int v166;
  unsigned int v167;
  unint64_t v168;
  unsigned int v169;
  unsigned int v170;
  char v171;
  __int128 v172;
  __int128 v173;
  __int128 v174;
  __int128 v175;
  int v176;
  _OWORD v177[3];
  uint64_t v178;
  _OWORD v179[3];
  uint64_t v180;
  uint64_t v181;

  v1 = MEMORY[0x1E0C80A78](a1);
  v156 = v3;
  v149 = v4;
  v129 = v5;
  v7 = v6;
  v9 = v8;
  v10 = v2;
  v12 = v11;
  v151 = v1;
  v181 = *MEMORY[0x1E0C80C00];
  if (v2 <= 1)
    v13 = 1;
  else
    v13 = v2;
  MEMORY[0x1E0C80A78](v1);
  v14 = (8 * v13 + 15) & 0xFFFFFFFFFFFFFFF0;
  v159 = (_opaque_pthread_t **)((char *)&v127 - v14);
  bzero((char *)&v127 - v14, 8 * v13);
  MEMORY[0x1E0C80A78](v15);
  v17 = (char *)&v127 - v16;
  bzero((char *)&v127 - v16, v18);
  MEMORY[0x1E0C80A78](v19);
  v20 = (char *)&v127 - v14;
  bzero((char *)&v127 - v14, 8 * v13);
  MEMORY[0x1E0C80A78](v21);
  v22 = (char *)&v127 - v14;
  bzero(v22, 8 * v13);
  v23 = malloc_type_malloc(v10 << 6, 0x10100400DEE4441uLL);
  v176 = 0;
  v24 = atomic_load((unsigned int *)(*v9 + 15152));
  v155 = v12;
  if (v24)
    v25 = 1;
  else
    v25 = (*(uint64_t (**)(_QWORD))(v12 + 16))(*(_QWORD *)(v12 + 32));
  v157 = v20;
  v158 = (void **)v22;
  v176 = v25;
  v150 = v10 - 1;
  v161 = v23;
  v162 = v10;
  v160 = v9;
  v154 = v23;
  if (v10 < 1)
  {
    v40 = v23;
    v46 = 0;
    v43 = (uint64_t *)v157;
    goto LABEL_19;
  }
  v26 = 0;
  v141 = v129;
  v142 = v7;
  v143 = 245984;
  v27 = 0;
  v139 = 1;
  v140 = (char *)(v23 + 3);
  v138 = 1164316426;
  v137 = 245944;
  v136 = 4960;
  v135 = 9672;
  v134 = 245784;
  v133 = 245848;
  v132 = 245896;
  v131 = 4096;
  v130 = 2043419695;
  v28 = v17;
  v29 = 0;
  do
  {
    v30 = (char *)malloc_type_calloc(v139, v143, v138);
    if (!v30)
    {
      v114 = __si_assert_copy_extra_5354(0, -1);
      v112 = v114;
      v115 = "";
      if (v114)
        v115 = v114;
      __message_assert("%s:%u: failed assertion '%s' %s Got 0 from calloc for allocation of count %ld size %ld", "CIMerging.c", 1315, "p||count==0||size==0", v115, 1, v143);
LABEL_95:
      free(v112);
      if (__valid_fs(-1))
        v116 = 2989;
      else
        v116 = 3072;
      *(_DWORD *)v116 = -559038737;
      abort();
    }
    v31 = v30;
    *(_QWORD *)&v157[v27 * 8] = v30;
    v32 = &v30[v137];
    v28[4] = *(_QWORD *)(v149 + v27 * 8);
    *v28 = v9[v27];
    v28[1] = v30;
    v28[2] = &v176;
    *((_DWORD *)v28 + 6) = *(_DWORD *)(*v9 + 56);
    *((_BYTE *)v28 + 29) = v142;
    *((_BYTE *)v28 + 28) = v141;
    *((_QWORD *)v32 + 4) = &v176;
    *(_QWORD *)v32 = v9[v27] + v136;
    *((_QWORD *)v32 + 1) = v9[v27] + v135;
    if (v155)
      *((_OWORD *)v32 + 1) = *(_OWORD *)(v155 + 40);
    v33 = (pthread_mutex_t *)&v30[v134];
    pthread_mutex_init((pthread_mutex_t *)&v30[v134], 0);
    pthread_cond_init((pthread_cond_t *)&v31[v133], 0);
    v34 = (pthread_cond_t *)&v31[v132];
    pthread_cond_init(v34, 0);
    v35 = *__error();
    v36 = _SILogForLogForCategory(0);
    v37 = 2 * (gSILogLevels[0] < 4);
    if (os_log_type_enabled(v36, v37))
    {
      LOWORD(v179[0]) = 0;
      _os_log_impl(&dword_1B8270000, v36, v37, "Creating CI mergeIndexDataTrampoline thread", (uint8_t *)v179, 2u);
    }
    *__error() = v35;
    pthread_mutex_lock(v33);
    pthread_create(&v159[v27], 0, (void *(__cdecl *)(void *))mergeIndexDataTrampoline, v28);
    pthread_cond_wait(v34, v33);
    pthread_mutex_unlock(v33);
    v38 = (1 << v29) | v26;
    v39 = malloc_type_malloc(v131, v130);
    v158[v27] = v39;
    *(_QWORD *)&v140[1 * v27] = v39;
    ++v29;
    ++v27;
    v28 += 5;
    v26 = v38;
    v10 = v162;
    v9 = v160;
  }
  while (v162 != v29);
  v40 = v161;
  v41 = v161;
  v42 = 0;
  v43 = (uint64_t *)v157;
  do
  {
    v44 = v42;
    v45 = v41;
    getItem((uint64_t)v179, v43[v42], v9[v42], (void *)v41[3], (_DWORD *)(*v9 + 15152));
    *(_OWORD *)v45 = v179[0];
    *((_OWORD *)v45 + 1) = v179[1];
    *((_OWORD *)v45 + 2) = v179[2];
    v45[6] = v180;
    v45[7] = v44;
    v42 = v44 + 1;
    v41 = v45 + 8;
  }
  while (v10 != v44 + 1);
  v46 = v38;
LABEL_19:
  qsort(v40, v10, 0x40uLL, (int (__cdecl *)(const void *, const void *))TermItem_compare);
  v174 = 0u;
  v175 = 0u;
  v172 = 0u;
  v173 = 0u;
  bzero(v179, 0x1000uLL);
  v171 = 0;
  v47 = v151;
  if (v151 && !*(_BYTE *)(v151 + 8))
  {
    v94 = *__error();
    v95 = _SILogForLogForCategory(0);
    v96 = 2 * (gSILogLevels[0] < 4);
    if (os_log_type_enabled(v95, v96))
    {
      LOWORD(v177[0]) = 0;
      _os_log_impl(&dword_1B8270000, v95, v96, "Skipping because index is shut down", (uint8_t *)v177, 2u);
    }
    *__error() = v94;
    goto LABEL_76;
  }
  do
  {
    v48 = __ldxr(exceptionSequenceNum);
    v49 = v48 + 1;
  }
  while (__stxr(v48 + 1, exceptionSequenceNum));
  v50 = setThreadIdAndInfo(-1, (__int128 *)sIndexExceptionCallbacks, v47, 0, v49);
  v169 = HIDWORD(v50);
  v170 = v50;
  v168 = __PAIR64__(v51, v52);
  v53 = *(_QWORD *)&threadData[18 * v50 + 2];
  v54 = v53 + 320 * HIDWORD(v50);
  *(_BYTE *)(v54 + 216) = 0;
  v152 = *(_DWORD *)(v54 + 312);
  v55 = *(void (**)(_QWORD))(v54 + 224);
  if (v55)
    v55(*(_QWORD *)(v53 + 320 * HIDWORD(v50) + 288));
  v153 = v49;
  v167 = v170;
  v166 = v169;
  v165 = v168;
  if (_setjmp((int *)v54))
  {
    v56 = *__error();
    v57 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
    {
      LODWORD(v177[0]) = 136315394;
      *(_QWORD *)((char *)v177 + 4) = "iterateTermsForIndexes";
      WORD6(v177[0]) = 1024;
      *(_DWORD *)((char *)v177 + 14) = 1472;
      _os_log_error_impl(&dword_1B8270000, v57, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", (uint8_t *)v177, 0x12u);
    }
    *__error() = v56;
    *(_DWORD *)(v54 + 312) = v152;
    CIOnThreadCleanUpReset(v165);
    dropThreadId(v167, 1, v153);
    CICleanUpReset(v167, HIDWORD(v165));
    goto LABEL_72;
  }
  if (!(_DWORD)v46)
    goto LABEL_69;
  v147 = v150;
  v148 = (__int128 *)(v154 + 8);
  v146 = 15152;
  v145 = 4096;
  v144 = 64;
  v58 = v46;
  while (*(_QWORD *)v40 != -1 && v176 == 0)
  {
    v177[0] = *v40;
    v177[1] = v40[1];
    v177[2] = v40[2];
    v178 = *((_QWORD *)v40 + 6);
    if (atomic_load((unsigned int *)(*v160 + v146)))
      v61 = 1;
    else
      v61 = (*(uint64_t (**)(_QWORD))(v155 + 16))(*(_QWORD *)(v155 + 32));
    v176 = v61;
    v62 = v173 & 0x7FFFFFFF;
    if ((v173 & 0x7FFFFFFF) != 0)
    {
      v63 = DWORD1(v175);
      if (DWORD1(v175) <= 1 && (TermItem_compare((uint64_t)&v172, (uint64_t)v161) & 0x8000000000000000) == 0)
      {
        v121 = v160;
        v122 = v161;
        if (__valid_fsp(*(_DWORD **)(v160[v161[7]] + 9400)))
        {
          v123 = __si_assert_copy_extra_5354(*(_DWORD **)(v121[v122[7]] + 9400), -1);
          v124 = v123;
          v125 = "";
          if (v123)
            v125 = v123;
          si_analytics_log_2520("%s:%u: failed assertion '%s' %s lastItem(l:%d o:%lld k:%d) vs firstItem(l:%d o:%lld k:%d)", "CIMerging.c", 1425, "lastItem.item.termLen==0 || lastItem.item.kind>=Vector8 || TermItem_compare(&lastItem, &sourceTerm[0]) < 0", v125, v62, (_QWORD)v172, v63, v122[2] & 0x7FFFFFFF, *v122, *((_DWORD *)v122 + 13));
          free(v124);
          v126 = 2816;
        }
        else
        {
          v126 = 3072;
        }
        *(_DWORD *)v126 = -559038737;
        abort();
      }
    }
    if (v162 < 2)
    {
      v68 = 1;
    }
    else
    {
      v64 = HIDWORD(v178);
      v65 = v177[1];
      v66 = 1;
      v67 = (uint64_t)v148;
      while (*(_DWORD *)(v67 + 52) == v64 && *(_DWORD *)(v67 + 16) == v65 && !TermItem_IVF_compare(v67, (uint64_t)v177))
      {
        if (*(_QWORD *)(v67 + 56) >= *(_QWORD *)(v67 - 8))
        {
          v117 = __si_assert_copy_extra_5354(0, -1);
          v118 = v117;
          v119 = "";
          if (v117)
            v119 = v117;
          __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 1429, "sourceTerm[k].idx<sourceTerm[k-1].idx", v119);
          free(v118);
          if (__valid_fs(-1))
            v120 = 2989;
          else
            v120 = 3072;
          *(_DWORD *)v120 = -559038737;
          abort();
        }
        ++v66;
        v67 += 64;
        if (v162 == v66)
        {
          v66 = v162;
          break;
        }
      }
      v68 = v66;
    }
    v69 = (__int128 *)v161;
    if (!v176)
      v176 = (*(uint64_t (**)(uint64_t, _QWORD *, uint64_t))(v156 + 16))(v156, v161, v68);
    v70 = v69[1];
    v172 = *v69;
    v173 = v70;
    v71 = v69[3];
    v174 = v69[2];
    v175 = v71;
    *((_QWORD *)&v173 + 1) = v179;
    __memcpy_chk();
    if (v68 <= 1)
      v72 = 1;
    else
      v72 = v68;
    v73 = (unint64_t)v72 << 6;
    v74 = 0;
    v75 = v58;
    while (2)
    {
      v76 = v74;
      v77 = (char *)v154 + v74;
      getItem((uint64_t)v163, *(_QWORD *)&v157[8 * *(_QWORD *)((char *)v154 + v74 + 56)], v160[*(_QWORD *)((char *)v154 + v74 + 56)], *(void **)((char *)v154 + v74 + 24), (_DWORD *)(*v160 + 15152));
      v78 = v163[1];
      *(_OWORD *)v77 = v163[0];
      *((_OWORD *)v77 + 1) = v78;
      *((_OWORD *)v77 + 2) = v163[2];
      *((_QWORD *)v77 + 6) = v164;
      v79 = 1 << *((_DWORD *)v77 + 14);
      if (*(_QWORD *)v77 == -1)
      {
        v80 = v75 & ~v79;
      }
      else
      {
        v80 = v75;
        if ((v79 & v75) == 0)
        {
          v111 = __si_assert_copy_extra_5354(0, -1);
          v112 = v111;
          v113 = "";
          if (v111)
            v113 = v111;
          __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 1445, "moredata&(1<<sourceTerm[i].idx)", v113);
          goto LABEL_95;
        }
      }
      v74 = v76 + 64;
      v75 = v80;
      if (v73 != v76 + 64)
        continue;
      break;
    }
    if ((_DWORD)v68 == 1)
    {
      v82 = v147;
      v81 = v148;
      v40 = v161;
      if (v162 >= 2)
      {
        do
        {
          v83 = v81 - 4;
          if ((TermItem_compare((uint64_t)v81, (uint64_t)(v81 - 4)) & 0x8000000000000000) == 0)
            break;
          v85 = v81[2];
          v84 = v81[3];
          v87 = *v81;
          v86 = v81[1];
          v88 = *(v81 - 3);
          *v81 = *v83;
          v81[1] = v88;
          v89 = *(v81 - 1);
          v81[2] = *(v81 - 2);
          v81[3] = v89;
          *v83 = v87;
          *(v81 - 3) = v86;
          *(v81 - 2) = v85;
          *(v81 - 1) = v84;
          v81 += 4;
          --v82;
        }
        while (v82);
      }
    }
    else
    {
      v40 = v161;
      qsort(v161, v162, v144, (int (__cdecl *)(const void *, const void *))TermItem_compare);
    }
    v58 = v80;
    if ((_DWORD)v80)
      continue;
    break;
  }
LABEL_69:
  v171 = 1;
  v90 = *(_QWORD *)&threadData[18 * v167 + 2];
  v91 = v166;
  v92 = v90 + 320 * v166;
  *(_DWORD *)(v92 + 312) = v152;
  v93 = *(void (**)(_QWORD))(v92 + 232);
  if (v93)
    v93(*(_QWORD *)(v90 + 320 * v91 + 288));
  dropThreadId(v167, 0, v153);
  v10 = v162;
  v9 = v160;
LABEL_72:
  v43 = (uint64_t *)v157;
LABEL_76:
  if (!v171)
  {
    v97 = *__error();
    v98 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v98, OS_LOG_TYPE_ERROR))
    {
      LODWORD(v177[0]) = 136315394;
      *(_QWORD *)((char *)v177 + 4) = "iterateTermsForIndexes";
      WORD6(v177[0]) = 1024;
      *(_DWORD *)((char *)v177 + 14) = 1474;
      _os_log_error_impl(&dword_1B8270000, v98, OS_LOG_TYPE_ERROR, "%s:%d: Exception on new index merging", (uint8_t *)v177, 0x12u);
    }
    *__error() = v97;
    v176 = 1;
  }
  if (v10 >= 1)
  {
    v99 = v159;
    v128 = 15152;
    v100 = v43;
    v101 = v9;
    v102 = v10;
    do
    {
      v103 = *v100;
      if (v176 || (v104 = atomic_load((unsigned int *)(*v101 + v128))) != 0)
      {
        v176 = 1;
        pthread_cond_signal((pthread_cond_t *)(v103 + 245848));
      }
      *(_QWORD *)&v177[0] = 0;
      v105 = *v99++;
      pthread_join(v105, (void **)v177);
      pthread_mutex_destroy((pthread_mutex_t *)(v103 + 245784));
      pthread_cond_destroy((pthread_cond_t *)(v103 + 245848));
      pthread_cond_destroy((pthread_cond_t *)(v103 + 245896));
      free((void *)v103);
      ++v101;
      ++v100;
      --v102;
    }
    while (v102);
    v106 = v158;
    v40 = v161;
    v107 = v162;
    do
    {
      v108 = v107;
      v109 = v106 + 1;
      free(*v106);
      v106 = v109;
      v107 = v108 - 1;
    }
    while (v108 != 1);
  }
  free(v40);
  return v176 != 0;
}

char *__si_assert_copy_extra_5354(_DWORD *a1, int a2)
{
  char *v4;
  char *v5;
  const char *v6;
  const char *v7;
  char *v9;
  char v10[1024];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  bzero(v10, 0x400uLL);
  if (!a1)
  {
    if (a2 != -1)
    {
      v4 = v10;
      if ((fcntl(a2, 50, v10) & 0x80000000) == 0)
      {
        if (v10[0])
          goto LABEL_10;
      }
    }
    goto LABEL_7;
  }
  v4 = fd_realpath(a1, v10);
  if (!v4)
  {
LABEL_7:
    v5 = getcwd(v10, 0x400uLL);
    if (v5)
      v4 = v5;
    else
      v4 = "";
  }
LABEL_10:
  v9 = 0;
  v6 = (const char *)pthread_getspecific(__THREAD_STR_DATA_KEY);
  if (v6)
    v7 = v6;
  else
    v7 = "";
  asprintf(&v9, "%s %s", v4, v7);
  return v9;
}

void RunBufferDestroy(void **a1)
{
  free(*a1);
}

void finalizeReadBuffer(uint64_t a1)
{
  void *v2;
  size_t v3;

  v2 = *(void **)a1;
  v3 = *(_QWORD *)(a1 + 8);
  if (v3)
  {
    if (v2)
      munmap(v2, v3);
    *(_QWORD *)(a1 + 8) = 0;
  }
  else
  {
    free(v2);
  }
  *(_QWORD *)a1 = -1;
}

void finalizeReadPosContext(uint64_t a1)
{
  finalizeReadBuffer(a1 + 24);
}

void ChangeHolderFreeDocIds(void **a1)
{
  free(*a1);
}

uint64_t writeWindowInit(uint64_t result, _QWORD *a2, uint64_t a3, char a4)
{
  uint64_t v4;
  off_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;

  v4 = result;
  *(_QWORD *)(result + 16) = 0;
  a2[1] = 8;
  *(_QWORD *)result = a2;
  *(_QWORD *)(result + 8) = -1;
  *(_DWORD *)(result + 24) = 0;
  *(_BYTE *)(result + 41) = a4;
  if (!a3)
  {
    while (1)
    {
      v7 = *(_QWORD *)v4;
      v8 = *(_QWORD *)(*(_QWORD *)v4 + 24);
      if (v8 > 0x100000)
        break;
      *(_QWORD *)(v7 + 24) = 2 * v8;
      result = fd_truncate(*(_QWORD *)(v7 + 4480), 2 * v8);
      if ((_DWORD)result == -1)
        goto LABEL_3;
    }
LABEL_7:
    if (*(_DWORD *)(v4 + 24))
      return result;
    goto LABEL_8;
  }
  v5 = (*MEMORY[0x1E0C85AD8] + a3) & ~*MEMORY[0x1E0C85AC0];
  a2[3] = v5;
  result = fd_truncate(a2[560], v5);
  if ((_DWORD)result != -1)
    goto LABEL_7;
LABEL_3:
  result = (uint64_t)__error();
  v6 = *(_DWORD *)result;
  *(_DWORD *)(v4 + 24) = *(_DWORD *)result;
  if (v6)
    return result;
LABEL_8:
  result = fd_mmap(*(_QWORD *)(*(_QWORD *)v4 + 4480));
  *(_QWORD *)(v4 + 8) = result;
  if (result == -1)
  {
    result = (uint64_t)__error();
    *(_DWORD *)(v4 + 24) = *(_DWORD *)result;
  }
  return result;
}

uint64_t createWPCOccurenceCountMap(uint64_t *a1)
{
  uint64_t result;
  char *v3;
  char *v4;
  const char *v5;
  uint64_t v6;

  if (*a1)
  {
    v3 = __si_assert_copy_extra_5354(0, -1);
    v4 = v3;
    v5 = "";
    if (v3)
      v5 = v3;
    __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 1032, "* occurrenceCountMap == ((void *)0)", v5);
    free(v4);
    if (__valid_fs(-1))
      v6 = 2989;
    else
      v6 = 3072;
    *(_DWORD *)v6 = -559038737;
    abort();
  }
  result = MDDictionaryUIntUIntCreate();
  *a1 = result;
  return result;
}

unint64_t resetReadPosContext(unint64_t a1, uint64_t a2, int a3)
{
  unint64_t v4;
  unint64_t *v6;
  unint64_t v7;
  unint64_t v8;
  char v9;
  unint64_t v10;
  BOOL v11;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  int64_t VInt64;
  uint64_t v17;
  char *v19;
  char *v20;
  const char *v21;
  uint64_t v22;
  char *v23;
  char *v24;
  const char *v25;
  char *v26;
  const char *v27;
  uint64_t v28;

  v4 = a1;
  *(_QWORD *)(a2 + 56) = 0;
  if (a1)
  {
    v6 = (unint64_t *)(a2 + 8);
    v7 = *(_QWORD *)(a2 + 32);
    if (v7)
    {
      if (v7 <= a1)
      {
        v19 = __si_assert_copy_extra_5354(0, -1);
        v20 = v19;
        v21 = "";
        if (v19)
          v21 = v19;
        __message_assert("%s:%u: failed assertion '%s' %s Offset %lld past end of buffer %ld", "CIMerging.c", 916, "next < context->readBuffer.mappedSize", v21, v4, *(_QWORD *)(a2 + 32));
        free(v20);
        if (__valid_fs(-1))
          v22 = 2989;
        else
          v22 = 3072;
        *(_DWORD *)v22 = -559038737;
        abort();
      }
      v8 = a1;
    }
    else
    {
      v10 = *(_QWORD *)(a2 + 16);
      v11 = a1 >= v10;
      v8 = a1 - v10;
      if (!v11 || v8 - 65517 <= 0xFFFFFFFFFFFEFFFELL)
      {
        *(_QWORD *)(a2 + 16) = a1 & 0x3FFFFFFFFFFFF000;
        v13 = fd_pread(*(_DWORD **)a2, *(void **)(a2 + 24), 0x10000uLL, a1 & 0x3FFFFFFFFFFFF000);
        v14 = *(_QWORD *)(a2 + 16);
        v11 = v4 >= v14;
        v8 = v4 - v14;
        if (!v11)
        {
          v26 = __si_assert_copy_extra_5354(0, -1);
          v24 = v26;
          v27 = "";
          if (v26)
            v27 = v26;
          __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 927, "next >= context->last_offset", v27);
          goto LABEL_34;
        }
        if (v13 == -1)
        {
          v4 = -1;
          if (a3)
            goto LABEL_14;
LABEL_16:
          v15 = *(_QWORD *)(a2 + 24);
          VInt64 = v2_readVInt64(v15, (uint64_t *)(a2 + 8));
          if ((VInt64 & 1) != 0)
          {
            v17 = VInt64 >> 1;
            VInt64 = v2_readVInt64(v15, (uint64_t *)(a2 + 8));
          }
          else
          {
            v17 = 0;
          }
          if ((VInt64 & 1) == 0)
          {
            v9 = 0;
            *(_QWORD *)(a2 + 40) = v17;
            *(_QWORD *)(a2 + 48) = VInt64 >> 1;
            goto LABEL_21;
          }
          v23 = __si_assert_copy_extra_5354(0, -1);
          v24 = v23;
          v25 = "";
          if (v23)
            v25 = v23;
          __message_assert("%s:%u: failed assertion '%s' %s ", "PayloadIterator.h", 279, "(value & 1) == 0", v25);
LABEL_34:
          free(v24);
          if (__valid_fs(-1))
            v28 = 2989;
          else
            v28 = 3072;
          *(_DWORD *)v28 = -559038737;
          abort();
        }
      }
    }
    v4 = 0;
    *v6 = v8;
    if (a3)
    {
LABEL_14:
      v9 = 0;
      *(_QWORD *)(a2 + 40) = 0;
      *(_QWORD *)(a2 + 48) = 0;
      goto LABEL_21;
    }
    goto LABEL_16;
  }
  v9 = 1;
LABEL_21:
  *(_BYTE *)(a2 + 66) = v9;
  return v4;
}

uint64_t merge_handleUpdate(uint64_t a1, unint64_t a2, int a3)
{
  uint64_t v6;

  checkChangeHolderIntegrity(a1);
  changesHandleUpdate(a1, a2, a3);
  v6 = *(_QWORD *)(a1 + 8);
  if (v6 && !*(_QWORD *)(a1 + 24))
  {
    *(_OWORD *)*(_QWORD *)a1 = *(_OWORD *)(*(_QWORD *)a1 + 16 * (*(_QWORD *)(a1 + 16) - v6));
    *(_QWORD *)(a1 + 24) = 1;
  }
  return checkChangeHolderIntegrity(a1);
}

uint64_t merge_checkAgainstUpdates(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t v7;
  unint64_t *v8;
  unsigned int v9;
  uint64_t v10;
  int v11;
  NSObject *v12;
  os_log_type_t v13;
  int v14;
  uint64_t v15;
  int v17;
  uint64_t v18;
  __int16 v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (!merge_checkAgainstUpdates1(a1, (unint64_t **)a2, a3, a4)
    || (v7 = a4 + a3, v8 = *(unint64_t **)a2, v7 != **(_QWORD **)a2))
  {
    checkChangeHolderIntegrity(a2);
    return 0;
  }
  v9 = *((_DWORD *)v8 + 2);
  v10 = v9 >> 31;
  if ((v9 & 0x80000000) != 0)
  {
    if (v9 != -1)
    {
      v11 = *__error();
      v12 = _SILogForLogForCategory(10);
      v13 = 2 * (dword_1EF19FCB4 < 4);
      if (os_log_type_enabled(v12, v13))
      {
LABEL_10:
        v14 = *(_DWORD *)(*(_QWORD *)a2 + 8);
        v17 = 134218240;
        v18 = v7;
        v19 = 1024;
        v20 = v14;
        _os_log_impl(&dword_1B8270000, v12, v13, "Mismatched changed count for %lld, count %d", (uint8_t *)&v17, 0x12u);
      }
LABEL_11:
      *__error() = v11;
      v8 = *(unint64_t **)a2;
    }
  }
  else if (v9 >= 2)
  {
    v11 = *__error();
    v12 = _SILogForLogForCategory(10);
    v13 = 2 * (dword_1EF19FCB4 < 4);
    if (os_log_type_enabled(v12, v13))
      goto LABEL_10;
    goto LABEL_11;
  }
  *((_DWORD *)v8 + 2) = 0;
  v15 = *(_QWORD *)(a2 + 8) - 1;
  *(_QWORD *)(a2 + 8) = v15;
  if (v15)
    *(_OWORD *)*(_QWORD *)a2 = *(_OWORD *)(*(_QWORD *)a2 + 16 * (*(_QWORD *)(a2 + 16) - v15));
  else
    *(_QWORD *)(a2 + 24) = 0;
  checkChangeHolderIntegrity(a2);
  return v10;
}

uint64_t readDataForOneDocument(uint64_t a1, int a2, uint64_t a3, uint64_t a4, char a5)
{
  uint64_t v6;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  int v20;
  int v21;
  uint64_t v22;
  unint64_t v23;
  char *v24;
  char *v25;
  const char *v26;
  char *v27;
  char *v28;
  const char *v29;
  int v30;
  NSObject *v31;
  uint64_t v32;
  char *v33;
  char *v34;
  const char *v35;
  unint64_t v36;
  unsigned int v37;
  int v38;
  unsigned int v39;
  unsigned int v40;
  uint64_t v41;
  unsigned int v42;
  unsigned int v43;
  uint64_t v44;
  int v45;
  unint64_t v46;
  unint64_t v47;
  unint64_t v49;
  unsigned int v50;
  int v51;
  uint64_t v52;
  int v53;
  unint64_t v54;
  BOOL v55;
  unint64_t v56;
  unsigned int v57;
  int v58;
  uint64_t v59;
  int v60;
  unint64_t v61;
  unint64_t v62;
  unint64_t v63;
  uint64_t v64;
  uint64_t v65;
  unint64_t v66;
  unint64_t v67;
  unsigned int v68;
  unsigned int v69;
  unsigned int v70;
  unsigned int v71;
  unsigned int v72;
  uint64_t v73;
  int *v74;
  int Packing;
  int v76;
  unint64_t v77;
  char *v78;
  const char *v79;
  uint64_t v80;
  char *v81;
  const char *v82;
  char *v83;
  char *v84;
  const char *v85;
  char *v86;
  const char *v87;
  char *v88;
  const char *v89;
  char *v90;
  char *v91;
  char *v92;
  const char *v93;
  uint64_t v94;
  char *v95;
  const char *v96;
  char *v97;
  const char *v98;
  char *v99;
  const char *v100;
  uint64_t v101;
  char *v102;
  const char *v103;
  char *v104;
  const char *v105;
  char *v106;
  const char *v107;
  unint64_t v108;
  uint64_t v109;
  int *v110;
  uint8_t buf[4];
  _BYTE v112[14];
  __int16 v113;
  int v114;
  __int16 v115;
  int v116;
  __int16 v117;
  int v118;
  uint64_t v119;

  v119 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a3 + 66))
    return a2 ^ 1u;
  *(_BYTE *)(a1 + 40) = (a5 & 0x40) == 0;
  if (*(_QWORD *)(a1 + 64) <= 0x3FFuLL)
  {
    *(_QWORD *)(a1 + 64) = 1024;
    *(_QWORD *)(a1 + 56) = malloc_type_realloc(*(void **)(a1 + 56), 0x1000uLL, 0x100004052888210uLL);
  }
  v12 = *(_QWORD *)(a3 + 24);
  if (!v12)
  {
    v33 = __si_assert_copy_extra_5354(0, -1);
    v34 = v33;
    v35 = "";
    if (v33)
      v35 = v33;
    __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 3587, "readBuffer", v35);
    goto LABEL_158;
  }
  v13 = *(_QWORD *)(a3 + 216);
  v14 = *(_QWORD *)(a1 + 72);
  *(_QWORD *)(a1 + 32) = v14;
  *(_QWORD *)(a1 + 80) = 0xFFFFFFFFLL;
  if (v14 && *(_DWORD *)(*(_QWORD *)(a1 + 56) + 4 * v14 - 4))
  {
    v95 = __si_assert_copy_extra_5354(0, -1);
    v28 = v95;
    v96 = "";
    if (v95)
      v96 = v95;
    __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 1110, "buffer->ints[buffer->intCount-1]==0", v96);
    goto LABEL_188;
  }
  v15 = *(_QWORD *)(a3 + 8);
  v108 = v15;
  if (v15 - 65532 <= 0xFFFFFFFFFFFEFFFELL && *(_QWORD *)(a3 + 32) == 0)
  {
    if (slideBuffer(&v108, a3) == -1)
      return 0xFFFFFFFFLL;
    v15 = v108;
    if ((a5 & 4) == 0)
      goto LABEL_14;
  }
  else if ((a5 & 4) == 0)
  {
LABEL_14:
    if ((a5 & 0x40) == 0)
    {
      v17 = *(_QWORD *)(a3 + 48);
      if (v17)
      {
        v18 = v15;
        if (*(_BYTE *)(v12 + v15))
        {
          if ((a5 & 8) == 0)
          {
LABEL_18:
            v19 = v18;
            goto LABEL_58;
          }
        }
        else
        {
          v22 = *(_QWORD *)(a3 + 40);
          if (resetReadPosContext(v17, a3, 0) == -1)
            return 0xFFFFFFFFLL;
          *(_QWORD *)(a3 + 40) = v22;
          v12 = *(_QWORD *)(a3 + 24);
          v18 = *(_QWORD *)(a3 + 8);
          v108 = v18;
          if ((a5 & 8) == 0)
            goto LABEL_18;
        }
      }
      else
      {
        v18 = v15;
        if ((a5 & 8) == 0)
          goto LABEL_18;
      }
      v19 = v18 + 1;
      v20 = *(unsigned __int8 *)(v12 + v18);
      if (*(char *)(v12 + v18) < 0)
      {
        if (v20 > 0xBF)
        {
          if (v20 > 0xDF)
          {
            if (v20 > 0xEF)
            {
              v20 = *(_DWORD *)(v12 + v19);
              v19 = v18 + 5;
            }
            else
            {
              v20 = ((v20 & 0xF) << 24) | (*(unsigned __int8 *)(v12 + v19) << 16) | (*(unsigned __int8 *)(v18 + v12 + 2) << 8) | *(unsigned __int8 *)(v18 + v12 + 3);
              v19 = v18 + 4;
            }
          }
          else
          {
            v20 = ((v20 & 0x1F) << 16) | (*(unsigned __int8 *)(v12 + v19) << 8) | *(unsigned __int8 *)(v18 + v12 + 2);
            v19 = v18 + 3;
          }
        }
        else
        {
          v21 = *(unsigned __int8 *)(v12 + v19) | ((v20 & 0x3F) << 8);
          v19 = v18 + 2;
          v20 = v21;
        }
      }
      v108 = v19;
      if (v20)
      {
        v23 = *(_QWORD *)(a3 + 56);
        if (v23)
        {
          if (v23 > v20 && v23 - v20 == a4)
          {
            *(_QWORD *)(a3 + 56) = a4;
LABEL_41:
            if (!a4)
            {
              v27 = __si_assert_copy_extra_5354(0, -1);
              v28 = v27;
              v29 = "";
              if (v27)
                v29 = v27;
              __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 3649, "context->docId", v29);
              goto LABEL_188;
            }
            goto LABEL_58;
          }
        }
        else
        {
          *(_QWORD *)(a3 + 56) = v20;
          v23 = v20;
        }
        if (v23 != a4)
        {
          if (!*(_BYTE *)(a3 + 65))
          {
            v30 = *__error();
            v31 = _SILogForLogForCategory(10);
            if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
            {
              v32 = *(_QWORD *)(a3 + 56);
              *(_DWORD *)buf = 136316162;
              *(_QWORD *)v112 = "readDataForOneDocument";
              *(_WORD *)&v112[8] = 1024;
              *(_DWORD *)&v112[10] = 3637;
              v113 = 1024;
              v114 = a4;
              v115 = 1024;
              v116 = v32;
              v117 = 1024;
              v118 = v20;
              _os_log_error_impl(&dword_1B8270000, v31, OS_LOG_TYPE_ERROR, "%s:%d: missing positions for doc:%d %d %d", buf, 0x24u);
            }
            *__error() = v30;
            *(_BYTE *)(a3 + 65) = 1;
          }
          if ((a2 & 1) == 0)
          {
            _addToWPCBuffer(a1, 1u, 3642);
            _addToWPCBuffer(a1, 0, 3643);
          }
          v6 = 0;
          --v108;
          goto LABEL_123;
        }
        goto LABEL_41;
      }
      v24 = __si_assert_copy_extra_5354(*(_DWORD **)a3, -1);
      v25 = v24;
      v26 = "";
      if (v24)
        v26 = v24;
      si_analytics_log_2520("%s:%u: failure log '%s' %s Unexpected 0 delta at %ld/%ld", "CIMerging.c", 3624, "docIdDelta", v26, v15, v19);
      free(v25);
      return 0xFFFFFFFFLL;
    }
    v97 = __si_assert_copy_extra_5354(0, -1);
    v34 = v97;
    v98 = "";
    if (v97)
      v98 = v97;
    __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 3604, "!hasCompressedPositions", v98);
LABEL_158:
    free(v34);
    if (__valid_fs(-1))
      v80 = 2989;
    else
      v80 = 3072;
    *(_DWORD *)v80 = -559038737;
    abort();
  }
  v19 = v15;
  if ((a5 & 0x40) != 0)
  {
    v39 = readCompactPosition(a3, &v108);
    v40 = v39;
    if (a2)
    {
      if (v39 != -1)
      {
        while (1)
        {
          v41 = readCompactPosition(a3, &v108);
          if ((_DWORD)v41 == -1)
            break;
          v6 = v41;
          if (!(_DWORD)v41)
            goto LABEL_123;
        }
      }
    }
    else if (v39 != -1)
    {
      _addToWPCBuffer(a1, v39, 3694);
      if (v40)
        LODWORD(v6) = 0;
      else
        LODWORD(v6) = -1;
      while (1)
      {
        v42 = readCompactPosition(a3, &v108);
        if (v42 == -1)
          break;
        v43 = v42;
        _addToWPCBuffer(a1, v42, 3710);
        v6 = (v6 + 1);
        if (!v43)
          goto LABEL_123;
      }
    }
    return 0xFFFFFFFFLL;
  }
LABEL_58:
  v36 = v19 + 1;
  v37 = *(unsigned __int8 *)(v12 + v19);
  if (*(char *)(v12 + v19) < 0)
  {
    if (v37 > 0xBF)
    {
      if (v37 > 0xDF)
      {
        if (v37 > 0xEF)
        {
          v37 = *(_DWORD *)(v12 + v36);
          v36 = v19 + 5;
        }
        else
        {
          v37 = ((v37 & 0xF) << 24) | (*(unsigned __int8 *)(v12 + v36) << 16) | (*(unsigned __int8 *)(v19 + v12 + 2) << 8) | *(unsigned __int8 *)(v19 + v12 + 3);
          v36 = v19 + 4;
        }
      }
      else
      {
        v37 = ((v37 & 0x1F) << 16) | (*(unsigned __int8 *)(v12 + v36) << 8) | *(unsigned __int8 *)(v19 + v12 + 2);
        v36 = v19 + 3;
      }
    }
    else
    {
      v38 = *(unsigned __int8 *)(v12 + v36) | ((v37 & 0x3F) << 8);
      v36 = v19 + 2;
      v37 = v38;
    }
  }
  v108 = v36;
  if ((a2 & 1) != 0 || !v37)
  {
    do
    {
      v55 = v36 - 65532 <= 0xFFFFFFFFFFFEFFFELL && *(_QWORD *)(a3 + 32) == 0;
      v56 = v36;
      if (v55)
      {
        if (slideBuffer(&v108, a3) == -1)
          return 0xFFFFFFFFLL;
        v56 = v108;
      }
      v36 = v56 + 1;
      v57 = *(unsigned __int8 *)(v12 + v56);
      if (*(char *)(v12 + v56) < 0)
      {
        if (v57 > 0xBF)
        {
          if (v57 > 0xDF)
          {
            if (v57 > 0xEF)
            {
              v57 = *(_DWORD *)(v12 + v36);
              v36 = v56 + 5;
            }
            else
            {
              v57 = ((v57 & 0xF) << 24) | (*(unsigned __int8 *)(v12 + v36) << 16) | (*(unsigned __int8 *)(v56 + v12 + 2) << 8) | *(unsigned __int8 *)(v56 + v12 + 3);
              v36 = v56 + 4;
            }
          }
          else
          {
            v57 = ((v57 & 0x1F) << 16) | (*(unsigned __int8 *)(v12 + v36) << 8) | *(unsigned __int8 *)(v56 + v12 + 2);
            v36 = v56 + 3;
          }
        }
        else
        {
          v58 = *(unsigned __int8 *)(v12 + v36) | ((v57 & 0x3F) << 8);
          v36 = v56 + 2;
          v57 = v58;
        }
      }
      v108 = v36;
    }
    while (v57);
    v6 = 0;
  }
  else
  {
    _addToWPCBuffer(a1, v37, 3731);
    v44 = 0;
    do
    {
      v45 = v44;
      v46 = bucketMagnitudes[v44++];
    }
    while (v46 < v37);
    ++*(_QWORD *)(v13 + 8 * v45 + 120);
    v6 = 1;
    while (1)
    {
      v47 = v108;
      if (v108 - 65532 <= 0xFFFFFFFFFFFEFFFELL && *(_QWORD *)(a3 + 32) == 0)
      {
        if (slideBuffer(&v108, a3) == -1)
          return 0xFFFFFFFFLL;
        v47 = v108;
      }
      v49 = v47 + 1;
      v50 = *(unsigned __int8 *)(v12 + v47);
      if (*(char *)(v12 + v47) < 0)
      {
        if (v50 > 0xBF)
        {
          if (v50 > 0xDF)
          {
            if (v50 > 0xEF)
            {
              v50 = *(_DWORD *)(v12 + v49);
              v49 = v47 + 5;
            }
            else
            {
              v50 = ((v50 & 0xF) << 24) | (*(unsigned __int8 *)(v12 + v49) << 16) | (*(unsigned __int8 *)(v47 + v12 + 2) << 8) | *(unsigned __int8 *)(v47 + v12 + 3);
              v49 = v47 + 4;
            }
          }
          else
          {
            v50 = ((v50 & 0x1F) << 16) | (*(unsigned __int8 *)(v12 + v49) << 8) | *(unsigned __int8 *)(v47 + v12 + 2);
            v49 = v47 + 3;
          }
        }
        else
        {
          v51 = *(unsigned __int8 *)(v12 + v49) | ((v50 & 0x3F) << 8);
          v49 = v47 + 2;
          v50 = v51;
        }
      }
      v108 = v49;
      if (!v50)
        break;
      if (v50 >> 27)
      {
        v78 = __si_assert_copy_extra_5354(0, -1);
        v34 = v78;
        v79 = "";
        if (v78)
          v79 = v78;
        __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 3748, "nextPos < (1<<27)", v79);
        goto LABEL_158;
      }
      v52 = 0;
      do
      {
        v53 = v52;
        v54 = bucketMagnitudes[v52++];
      }
      while (v54 < v50);
      ++*(_QWORD *)(v13 + 8 * v53);
      v6 = (v6 + 1);
      _addToWPCBuffer(a1, v50, 3757);
    }
    _addToWPCBuffer(a1, 0, 3764);
    v59 = 0;
    do
    {
      v60 = v59;
      v61 = bucketMagnitudes[v59++];
    }
    while (v61 < v6);
    ++*(_QWORD *)(v13 + 8 * v60 + 240);
  }
LABEL_123:
  if ((unint64_t)(*(_QWORD *)(a3 + 32) - 1) < *(_QWORD *)(a3 + 8))
  {
    v81 = __si_assert_copy_extra_5354(0, -1);
    v28 = v81;
    v82 = "";
    if (v81)
      v82 = v81;
    __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 3771, "context->innerOffset < context->readBuffer.mappedSize || context->readBuffer.mappedSize==0", v82);
    goto LABEL_188;
  }
  *(_QWORD *)(a3 + 8) = v108;
  v62 = *(_QWORD *)(a1 + 72);
  if (v62 && *(_DWORD *)(*(_QWORD *)(a1 + 56) + 4 * v62 - 4))
  {
    v99 = __si_assert_copy_extra_5354(0, -1);
    v28 = v99;
    v100 = "";
    if (v99)
      v100 = v99;
    __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 1119, "buffer->intCount==0 ||buffer->ints[buffer->intCount-1]==0", v100);
LABEL_188:
    v90 = v28;
    goto LABEL_189;
  }
  if ((*(_DWORD *)(a1 + 80) + 1) >= 2)
  {
    v106 = __si_assert_copy_extra_5354(0, -1);
    v34 = v106;
    v107 = "";
    if (v106)
      v107 = v106;
    __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 1120, "buffer->lastPosition == (uint32_t)-1 || buffer->lastPosition == 0", v107);
    goto LABEL_158;
  }
  if ((a5 & 0x40) != 0)
    goto LABEL_147;
  if (!*(_BYTE *)(a1 + 40))
  {
    v102 = __si_assert_copy_extra_5354(0, -1);
    v34 = v102;
    v103 = "";
    if (v102)
      v103 = v102;
    __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 1122, "ctx->flip", v103);
    goto LABEL_158;
  }
  if (v62 < 3)
    return v6;
  v63 = *(_QWORD *)(a1 + 32);
  if (v62 <= v63)
    goto LABEL_147;
  v64 = *(_QWORD *)(a1 + 56);
  v65 = *(unsigned int *)(v64 + 4 * v63);
  if (v65 >> 27)
  {
    v104 = __si_assert_copy_extra_5354(0, -1);
    v34 = v104;
    v105 = "";
    if (v104)
      v105 = v104;
    __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 1129, "first < 1<<27", v105);
    goto LABEL_158;
  }
  v66 = v62 - 2;
  if (v62 - 2 > v63)
  {
    v67 = v63 + 1;
    if (v63 + 1 < v66)
    {
      v68 = *(_DWORD *)(v64 + 4 * v66);
      if (v68 > v65)
      {
        si_analytics_log_2520("Unexpected offsets f:%d, l:%d h:%d, li:%ld hi:%ld, ds:%ld, ic:%ld, is:%ld", v65, *(_DWORD *)(v64 + 4 * v67), v68, v63 + 1, v62 - 2, v63, *(_QWORD *)(a1 + 72), *(_QWORD *)(a1 + 64));
        v64 = *(_QWORD *)(a1 + 56);
        v66 = v62 - 3;
      }
    }
    if (v67 < v66)
    {
      while (1)
      {
        v69 = *(_DWORD *)(v64 + 4 * v67);
        *(_DWORD *)(v64 + 4 * v67) = *(_DWORD *)(v64 + 4 * v66);
        *(_DWORD *)(v64 + 4 * v66) = v69;
        v70 = *(_DWORD *)(v64 + 4 * v67);
        if (v70 >> 27)
          break;
        if (v69 >> 27)
        {
          v86 = __si_assert_copy_extra_5354(0, -1);
          v84 = v86;
          v87 = "";
          if (v86)
            v87 = v86;
          __message_assert("%s:%u: failed assertion '%s' %s Unexpected offsets f:%d, l:%d h:%d, li:%ld hi:%ld, ds:%ld, ic:%ld, is:%ld", "CIMerging.c", 1156, "buffer->ints[highIndex] < (1<<27)", v87, v65);
          goto LABEL_174;
        }
        v71 = v70 + v69;
        v72 = v65 - v71;
        if (v65 <= v71)
        {
          v88 = __si_assert_copy_extra_5354(0, -1);
          v84 = v88;
          v89 = "";
          if (v88)
            v89 = v88;
          __message_assert("%s:%u: failed assertion '%s' %s Unexpected offsets f:%d, l:%d h:%d, li:%ld hi:%ld, ds:%ld, ic:%ld, is:%ld", "CIMerging.c", 1160, "firstOffset > buffer->ints[lowIndex] + buffer->ints[highIndex]", v89, v65);
          goto LABEL_174;
        }
        if (v72 >> 27)
        {
          v91 = __si_assert_copy_extra_5354(0, -1);
          v92 = v91;
          v93 = "";
          if (v91)
            v93 = v91;
          __message_assert("%s:%u: failed assertion '%s' %s Unexpected computed offset f:%d, l:%d h:%d, li:%ld hi:%ld, ds:%ld, ic:%ld, is:%ld", "CIMerging.c", 1165, "firstOffset < (1<<27)", v93, v72, *(_DWORD *)(*(_QWORD *)(a1 + 56) + 4 * v67), *(_DWORD *)(*(_QWORD *)(a1 + 56) + 4 * v66), v67, v66, *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 72), *(_QWORD *)(a1 + 64));
          free(v92);
          if (__valid_fs(-1))
            v94 = 2989;
          else
            v94 = 3072;
          *(_DWORD *)v94 = -559038737;
          abort();
        }
        ++v67;
        --v66;
        v65 = v65 - v71;
        if (v67 >= v66)
          goto LABEL_144;
      }
      v83 = __si_assert_copy_extra_5354(0, -1);
      v84 = v83;
      v85 = "";
      if (v83)
        v85 = v83;
      __message_assert("%s:%u: failed assertion '%s' %s Unexpected offsets f:%d, l:%d h:%d, li:%ld hi:%ld, ds:%ld, ic:%ld, is:%ld", "CIMerging.c", 1155, "buffer->ints[lowIndex] < (1<<27)", v85, v65);
LABEL_174:
      v90 = v84;
LABEL_189:
      free(v90);
      if (__valid_fs(-1))
        v101 = 2989;
      else
        v101 = 3072;
      *(_DWORD *)v101 = -559038737;
      abort();
    }
    v72 = v65;
LABEL_144:
    if (v67 == v66)
    {
      v72 -= *(_DWORD *)(v64 + 4 * v66);
      if (v72 >> 27)
      {
        v84 = __si_assert_copy_extra_5354(0, -1);
        __message_assert("%s:%u: failed assertion '%s' %s Unexpected first offset %d, %d, %ld");
        goto LABEL_174;
      }
    }
    *(_DWORD *)(v64 + 4 * *(_QWORD *)(a1 + 32)) = v72;
    v62 = *(_QWORD *)(a1 + 72);
  }
LABEL_147:
  if (v62 >= 0x1C)
  {
    v73 = *(_QWORD *)(a1 + 56);
    v109 = v62;
    v110 = (int *)v73;
    while (1)
    {
      v74 = v110;
      Packing = findPacking(v62, (uint64_t)v110);
      if (Packing << 24 >= 251658241)
        break;
      *(_DWORD *)buf = packOneWord(&v109, (uint64_t *)&v110, (char)Packing);
      writeWindowWriteBytes((char **)a1, (char *)buf, 4uLL);
      v62 = v109;
      if (v109 <= 27)
        goto LABEL_154;
    }
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      v76 = *v74;
      v77 = *(_QWORD *)(a1 + 72) - v62;
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)v112 = v76;
      *(_WORD *)&v112[4] = 2048;
      *(_QWORD *)&v112[6] = v77;
      _os_log_fault_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "No packing found for %u at index %lu", buf, 0x12u);
    }
LABEL_154:
    memmove(*(void **)(a1 + 56), (const void *)(*(_QWORD *)(a1 + 56) + 4 * *(_QWORD *)(a1 + 72) - 4 * v62), 4 * v62);
    *(_QWORD *)(a1 + 72) = v62;
  }
  return v6;
}

void __push_termid_counts_block_invoke(uint64_t a1, unsigned int a2, uint64_t a3)
{
  int v5;
  int v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  const __CFDictionary *v10;
  __CFDictionary *v11;
  _QWORD *v12;
  _QWORD *v13;
  _QWORD *Value;
  unint64_t v15;
  _QWORD *v16;
  _DWORD *v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  size_t v23;
  _QWORD *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  uint64_t v49;
  BOOL v50;
  uint64_t v51;
  size_t v52;
  _QWORD *v53;
  _QWORD *v54;
  uint64_t v55;
  uint64_t v56;
  _QWORD *v57;
  uint64_t v58;
  uint64_t v59;
  char *v60;
  char *v61;
  const char *v62;
  uint64_t v63;

  if (a2 == 679607404)
    v5 = 0;
  else
    v5 = 50;
  if (a2 == 856881155)
    v6 = 10000;
  else
    v6 = v5;
  if (a2 == 716189596)
    v7 = 10000;
  else
    v7 = v6;
  if (a2 == 510259174)
    v8 = 10000;
  else
    v8 = v7;
  v9 = *(unsigned int *)(a1 + 40);
  v10 = (const __CFDictionary *)CFRetain(*(CFTypeRef *)(a1 + 32));
  v11 = v10;
  if ((_DWORD)a3 && (_DWORD)v8)
  {
    if (!CFDictionaryContainsKey(v10, (const void *)a2))
    {
      v12 = malloc_type_malloc(0x18uLL, 0x102004024DAA5DEuLL);
      v12[1] = v8;
      v12[2] = 1;
      v13 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 8 * v8 + 16, 0x6085D6BuLL);
      if (!v13)
        _log_fault_for_malloc_failure();
      *v12 = v13;
      *v13 = 0;
      CFDictionaryAddValue(v11, (const void *)a2, v12);
    }
    Value = CFDictionaryGetValue(v11, (const void *)a2);
    v15 = Value[2];
    if ((uint64_t)(v15 - 1) > v8)
    {
      v60 = __si_assert_copy_extra_5354(0, -1);
      v61 = v60;
      v62 = "";
      if (v60)
        v62 = v60;
      __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 1637, "queueCount <= maxTermCount", v62);
      free(v61);
      if (__valid_fs(-1))
        v63 = 2989;
      else
        v63 = 3072;
      *(_DWORD *)v63 = -559038737;
      abort();
    }
    v16 = Value;
    if ((uint64_t)v15 <= v8)
    {
      v19 = v9 | (a3 << 32);
      v20 = Value[1];
      v21 = Value[2];
      if ((uint64_t)(v15 + 2) >= v20)
      {
        v22 = 2 * v20;
        if (v20 < 4)
          v22 = 4;
        Value[1] = v22;
        v23 = 8 * v22 + 16;
        if (*Value)
          v24 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, (void *)*Value, v23, 0xECA6AA46uLL);
        else
          v24 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v23, 0x8DDAA030uLL);
        v54 = v24;
        if (!v24)
          _log_fault_for_malloc_failure();
        *v16 = v54;
        *v54 = 0;
        v21 = v16[2];
      }
      v16[2] = v21 + 1;
      *(_QWORD *)(*v16 + 8 * v15) = v19;
      if ((uint64_t)v15 >= 2)
      {
        do
        {
          v55 = *(_QWORD *)(*v16 + 8 * v15);
          v56 = *(_QWORD *)(*v16 + 8 * (v15 >> 1));
          if (HIDWORD(v55) > HIDWORD(v56))
            break;
          *(_QWORD *)(*v16 + 8 * v15) = v56;
          *(_QWORD *)(*v16 + 8 * (v15 >> 1)) = v55;
          v50 = v15 > 3;
          v15 >>= 1;
        }
        while (v50);
      }
    }
    else
    {
      v17 = (_DWORD *)*Value;
      if (*Value)
        v18 = v17[3];
      else
        v18 = 0;
      if (v18 < a3)
      {
        v25 = *(_QWORD *)&v17[2 * v15 - 2];
        *((_QWORD *)v17 + 1) = v25;
        v26 = Value[2];
        v27 = (uint64_t)Value[1] >> 1;
        Value[2] = v26 - 1;
        v28 = 3;
        v29 = 2;
        v30 = 1;
        while (1)
        {
          v31 = (_QWORD *)*Value;
          v32 = *(_QWORD *)(*Value + 8 * v29);
          if (v28 >= v26)
          {
            if (v29 >= v26)
              break;
            v33 = 0xFFFFFFFF00000000;
          }
          else
          {
            v33 = v31[v28];
          }
          v34 = HIDWORD(v32);
          if (HIDWORD(v33) >= HIDWORD(v25))
            v35 = v25;
          else
            v35 = v33;
          if (HIDWORD(v33) >= HIDWORD(v25))
            v36 = v30;
          else
            v36 = v28;
          if (HIDWORD(v33) < HIDWORD(v32))
          {
            v32 = v33;
            v29 = v28;
          }
          v37 = v34 < HIDWORD(v25) ? v32 : v35;
          v38 = v34 < HIDWORD(v25) ? v29 : v36;
          _X13 = (char *)&v31[2 * v38];
          __asm { PRFM            #1, [X13] }
          if (v38 == v30)
            break;
          v29 = 2 * v38;
          v31[v38] = v25;
          v28 = (2 * v38) | 1;
          *(_QWORD *)(*Value + 8 * v30) = v37;
          v30 = v38;
          if (v38 >= v27)
          {
            v31 = (_QWORD *)*Value;
            break;
          }
        }
        v45 = v9 | (a3 << 32);
        v46 = Value[1];
        v47 = Value[2];
        if ((uint64_t)(v47 + 2) >= v46)
        {
          v49 = 2 * v46;
          v50 = v46 < 4;
          v51 = 4;
          if (!v50)
            v51 = v49;
          Value[1] = v51;
          v52 = 8 * v51 + 16;
          if (v31)
            v53 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, v31, v52, 0xECA6AA46uLL);
          else
            v53 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v52, 0x8DDAA030uLL);
          v57 = v53;
          if (!v53)
            _log_fault_for_malloc_failure();
          *v16 = v57;
          *v57 = 0;
          v48 = v16[2];
          v31 = (_QWORD *)*v16;
        }
        else
        {
          v48 = Value[2];
        }
        v16[2] = v48 + 1;
        v31[v47] = v45;
        if ((uint64_t)v47 >= 2)
        {
          do
          {
            v58 = *(_QWORD *)(*v16 + 8 * v47);
            v59 = *(_QWORD *)(*v16 + 8 * (v47 >> 1));
            if (HIDWORD(v58) > HIDWORD(v59))
              break;
            *(_QWORD *)(*v16 + 8 * v47) = v59;
            *(_QWORD *)(*v16 + 8 * (v47 >> 1)) = v58;
            v50 = v47 > 3;
            v47 >>= 1;
          }
          while (v50);
        }
      }
    }
  }
  CFRelease(v11);
}

unint64_t termIdStoreSetNext(uint64_t a1, unsigned int a2, unint64_t a3)
{
  unint64_t v5;
  CFIndex v6;
  CFIndex v7;
  char *v9;
  char *v10;
  const char *v11;
  uint64_t v12;
  CFIndex v13;
  char *v14;
  char *v15;
  const char *v16;
  uint64_t v17;
  const __CFBitVector *v18;
  const __CFAllocator *v19;
  __CFBitVector *MutableCopy;
  __CFBitVector *v21;
  const void *v22;
  char *v23;
  const char *v24;

  if (a3 >> 62)
  {
    v9 = __si_assert_copy_extra_5354(0, -1);
    v10 = v9;
    v11 = "";
    if (v9)
      v11 = v9;
    __message_assert("%s:%u: failed assertion '%s' %s write invalid offset %llu", "TermIdStore.h", 97, "offset <= OFFSET_VALUE_MASK", v11, a3);
    free(v10);
    if (__valid_fs(-1))
      v12 = 2989;
    else
      v12 = 3072;
    *(_DWORD *)v12 = -559038737;
    abort();
  }
  v5 = 8 * a2;
  v6 = v5 / *MEMORY[0x1E0C85AD8];
  v7 = *(_QWORD *)(a1 + 4424);
  if (v7 <= v6)
  {
    if (v7)
      v13 = *(_QWORD *)(a1 + 4424);
    else
      v13 = 32;
    while (1)
    {
      v13 *= 2;
      if (v13 > v6)
        break;
      if (v13 <= v7)
      {
        v14 = __si_assert_copy_extra_5354(0, -1);
        v15 = v14;
        v16 = "";
        if (v14)
          v16 = v14;
        __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 111, "newCapacity > bv->capacity", v16);
        goto LABEL_18;
      }
    }
    v18 = *(const __CFBitVector **)(a1 + 4432);
    v19 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    if (v18)
      MutableCopy = CFBitVectorCreateMutableCopy(v19, v13, v18);
    else
      MutableCopy = CFBitVectorCreateMutable(v19, v13);
    v21 = MutableCopy;
    if (!MutableCopy)
    {
      v23 = __si_assert_copy_extra_5354(0, -1);
      v15 = v23;
      v24 = "";
      if (v23)
        v24 = v23;
      __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 115, "newBV", v24);
LABEL_18:
      free(v15);
      if (__valid_fs(-1))
        v17 = 2989;
      else
        v17 = 3072;
      *(_DWORD *)v17 = -559038737;
      abort();
    }
    CFBitVectorSetCount(MutableCopy, v13);
    v22 = *(const void **)(a1 + 4432);
    if (v22)
      CFRelease(v22);
    *(_QWORD *)(a1 + 4432) = v21;
    *(_QWORD *)(a1 + 4424) = v13;
  }
  if (*(_QWORD *)(a1 + 4416) <= v6)
    *(_QWORD *)(a1 + 4416) = v6 + 1;
  CFBitVectorSetBitAtIndex(*(CFMutableBitVectorRef *)(a1 + 4432), v6, 1u);
  *(_QWORD *)storageResolvePtr(a1, v5, 8uLL, 1) = a3;
  return a3;
}

void finishTermForWPCBuffer(uint64_t a1)
{
  uint64_t v2;
  char *v3;
  uint64_t v4;
  unint64_t v5;
  int *v6;
  unsigned int Packing;
  int v8;
  uint64_t v9;
  int v10;
  int *v11;
  uint64_t v12;
  uint8_t buf[4];
  int v14;
  __int16 v15;
  unint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (!*(_DWORD *)(a1 + 24))
  {
    v2 = *(_QWORD *)(a1 + 72);
    if (v2)
    {
      v11 = *(int **)(a1 + 56);
      v12 = v2;
      v3 = (char *)malloc_type_malloc(4 * v2 + 4, 0x100004052888210uLL);
      v4 = 0;
      v5 = v2;
      while (1)
      {
        v6 = v11;
        Packing = findPacking(v5, (uint64_t)v11);
        if (Packing >= 0x10)
          break;
        v8 = packOneWord(&v12, (uint64_t *)&v11, (char)Packing);
        v9 = v4 + 1;
        *(_DWORD *)&v3[4 * v4] = v8;
        v5 = v12;
        ++v4;
        if (v12 <= 0)
          goto LABEL_10;
      }
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        v10 = *v6;
        *(_DWORD *)buf = 67109376;
        v14 = v10;
        v15 = 2048;
        v16 = v2 - v5;
        _os_log_fault_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "No packing found for %u at index %lu", buf, 0x12u);
      }
      v9 = v4;
LABEL_10:
      writeWindowWriteBytes((char **)a1, v3, 4 * v9);
      free(v3);
    }
  }
}

void destroyWPCOccurenceCountMap(const void **a1)
{
  const void *v2;
  char *v3;
  char *v4;
  const char *v5;
  uint64_t v6;

  v2 = *a1;
  if (!v2)
  {
    v3 = __si_assert_copy_extra_5354(0, -1);
    v4 = v3;
    v5 = "";
    if (v3)
      v5 = v3;
    __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 1037, "* occurrenceCountMap != ((void *)0)", v5);
    free(v4);
    if (__valid_fs(-1))
      v6 = 2989;
    else
      v6 = 3072;
    *(_DWORD *)v6 = -559038737;
    abort();
  }
  CFRelease(v2);
  *a1 = 0;
}

char *writeWindowFinalize(uint64_t a1)
{
  char *result;

  result = *(char **)(a1 + 8);
  if (result != (char *)-1)
  {
    sync_invalidate_mapping(result, *(_QWORD *)(*(_QWORD *)a1 + 8) - *(_QWORD *)(a1 + 16));
    result = (char *)munmap(*(void **)(a1 + 8), 0x100000uLL);
    *(_QWORD *)(a1 + 8) = -1;
  }
  return result;
}

void popTermIdCountPairsApplier(unsigned int a1, uint64_t *a2, CFTypeRef *a3)
{
  const __CFDictionary *v6;
  __CFDictionary *v7;
  unint64_t v8;
  int v9;
  const __CFAllocator **v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  CFIndex v14;
  CFMutableDictionaryRef Mutable;
  const __CFDictionary *Value;
  int v17;
  int v18;
  const __CFDictionary *v19;
  int v20;
  const __CFAllocator *v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  CFMutableSetRef v25;
  __CFSet *v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  uint64_t v38;
  unint64_t v39;
  uint64_t v40;
  char *v47;
  char *v48;
  const char *v49;
  uint64_t v50;

  v6 = (const __CFDictionary *)CFRetain(*a3);
  v7 = (__CFDictionary *)CFRetain(a3[1]);
  v8 = a1;
  v9 = CFDictionaryContainsKey(v6, (const void *)a1);
  v10 = (const __CFAllocator **)MEMORY[0x1E0C9AE00];
  if (!v9)
  {
    v11 = 50;
    if (a1 == 679607404)
      v11 = 0;
    if (a1 == 856881155)
      v12 = 10000;
    else
      v12 = v11;
    if (a1 == 716189596)
      v13 = 10000;
    else
      v13 = v12;
    if (a1 == 510259174)
      v14 = 10000;
    else
      v14 = v13;
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v14, 0, 0);
    CFDictionaryAddValue(v6, (const void *)v8, Mutable);
    CFRelease(Mutable);
  }
  Value = (const __CFDictionary *)CFDictionaryGetValue(v6, (const void *)v8);
  v17 = *((_DWORD *)a2 + 4);
  v18 = v17 - 1;
  if (v17 != 1)
  {
    v19 = Value;
    v20 = 0;
    v21 = *v10;
    do
    {
      v22 = a2[2];
      if (v22 == 1)
      {
        v23 = 0;
      }
      else
      {
        v23 = *(_QWORD *)(*a2 + 8);
        v27 = *(_QWORD *)(*a2 + 8 * v22 - 8);
        *(_QWORD *)(*a2 + 8) = v27;
        v28 = a2[2];
        v29 = a2[1] >> 1;
        a2[2] = v28 - 1;
        v30 = 1;
        v31 = 2;
        v32 = 3;
        do
        {
          v33 = *a2;
          v34 = *(_QWORD *)(*a2 + 8 * v31);
          if (v32 >= v28)
          {
            if (v31 >= v28)
              break;
            v35 = 0xFFFFFFFF00000000;
          }
          else
          {
            v35 = *(_QWORD *)(v33 + 8 * v32);
          }
          v36 = HIDWORD(v34);
          if (HIDWORD(v35) >= HIDWORD(v27))
            v37 = v27;
          else
            v37 = v35;
          if (HIDWORD(v35) >= HIDWORD(v27))
            v38 = v30;
          else
            v38 = v32;
          if (HIDWORD(v35) < HIDWORD(v34))
          {
            v34 = v35;
            v31 = v32;
          }
          if (v36 < HIDWORD(v27))
            v39 = v34;
          else
            v39 = v37;
          if (v36 < HIDWORD(v27))
            v40 = v31;
          else
            v40 = v38;
          _X13 = v33 + 16 * v40;
          __asm { PRFM            #1, [X13] }
          if (v40 == v30)
            break;
          v31 = 2 * v40;
          *(_QWORD *)(v33 + 8 * v40) = v27;
          v32 = (2 * v40) | 1;
          *(_QWORD *)(*a2 + 8 * v30) = v39;
          v30 = v40;
        }
        while (v40 < v29);
      }
      v24 = v23;
      if (CFDictionaryContainsKey(v19, (const void *)v23))
      {
        v47 = __si_assert_copy_extra_5354(0, -1);
        v48 = v47;
        v49 = "";
        if (v47)
          v49 = v47;
        __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 1686, "!CFDictionaryContainsKey(submap, (void*)(uintptr_t)pair.termId)", v49);
        free(v48);
        if (__valid_fs(-1))
          v50 = 2989;
        else
          v50 = 3072;
        *(_DWORD *)v50 = -559038737;
        abort();
      }
      CFDictionarySetValue(v19, (const void *)v23, (const void *)HIDWORD(v23));
      if (!CFDictionaryContainsKey(v7, (const void *)v23))
      {
        v25 = CFSetCreateMutable(v21, 0, 0);
        CFDictionaryAddValue(v7, (const void *)v24, v25);
        CFRelease(v25);
      }
      v26 = (__CFSet *)CFDictionaryGetValue(v7, (const void *)v24);
      CFSetAddValue(v26, (const void *)v8);
      ++v20;
    }
    while (v20 != v18);
  }
  CFRelease(v6);
  CFRelease(v7);
}

BOOL __mergeIndexData_block_invoke_22(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v5;
  int v6;
  uint64_t v7;
  unsigned int v8;
  _QWORD *v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const void *Value;
  uint64_t v15;
  uint64_t i;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  unsigned int v21;
  unsigned int v22;
  unint64_t v23;
  int PathWithPostingsOffset;
  uint64_t v25;
  int v26;
  int v27;
  float v28;
  char v29;
  NSObject *v30;
  os_signpost_id_t v31;
  NSObject *v32;
  unsigned int v33;
  uint64_t v34;
  unint64_t v35;
  _DWORD *v36;
  unint64_t v37;
  unsigned int v38;
  uint64_t v39;
  char *v40;
  uint8_t *v41;
  unsigned int v42;
  uint64_t v43;
  int v44;
  int v45;
  uint8_t *v46;
  unsigned int v47;
  unsigned int v48;
  char *v49;
  int v50;
  unsigned int v51;
  uint64_t v52;
  int v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t v57;
  uint8_t *v58;
  uint64_t v59;
  uint64_t v60;
  int v61;
  int v62;
  uint64_t v63;
  int v64;
  char v65;
  uint64_t v66;
  int v67;
  int v68;
  int v69;
  int v70;
  unsigned int v71;
  unsigned int v72;
  unsigned int v73;
  BOOL v74;
  unsigned int v75;
  int v76;
  int v77;
  char *v78;
  char *v79;
  const char *v80;
  char *v81;
  const char *v82;
  uint64_t v83;
  char *v84;
  char *v85;
  const char *v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  unsigned int v95;
  unsigned int v96;
  unsigned int v97;
  uint64_t v98;
  _QWORD v99[2];
  void (*v100)(uint64_t, char *, uint64_t, uint64_t, __int16);
  void *v101;
  uint64_t v102;
  uint64_t v103;
  const void *v104;
  int v105;
  uint8_t buf[1056];
  uint64_t v107;

  v107 = *MEMORY[0x1E0C80C00];
  if (a3 < 1)
    return 0;
  v5 = 0;
  v6 = 0;
  v7 = a3;
  do
  {
    if (*(_QWORD *)(a2 + v5))
      ++v6;
    v5 += 64;
  }
  while ((unint64_t)a3 << 6 != v5);
  if (!v6)
    return 0;
  v8 = *(_DWORD *)(a2 + 16);
  v9 = *(_QWORD **)(a2 + 24);
  v10 = *(_DWORD *)(a2 + 52);
  if (v10 != 1)
  {
    if (v10)
    {
      if (v10 > 4)
      {
LABEL_55:
        LODWORD(v25) = 0;
        return (_DWORD)v25 != 0;
      }
      v26 = *(_DWORD *)(a2 + 16);
      v98 = *(_QWORD *)(a2 + 24);
      v27 = *(_DWORD *)(a2 + 40);
      v96 = *(_DWORD *)(a2 + 32);
      v97 = *(_DWORD *)(a2 + 36);
      v28 = *(float *)(a2 + 44);
      v95 = *(unsigned __int16 *)(a2 + 48);
      v29 = *(_BYTE *)(a2 + 50);
      if (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 8) + 24))
      {
        v30 = _SILogForLogForCategory(0);
        v31 = *(_QWORD *)(a1 + 128);
        if (v31 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          v32 = v30;
          if (os_signpost_enabled(v30))
          {
            *(_WORD *)buf = 0;
            _os_signpost_emit_with_name_impl(&dword_1B8270000, v32, OS_SIGNPOST_INTERVAL_BEGIN, v31, "vectorIndexInsertForMerge", "Start", buf, 2u);
          }
        }
        IVFVectorIndex_s::startMerge((IVFVectorIndex_s *)(*(_QWORD *)(*(_QWORD *)(a1 + 112) + 4896) + 8));
        *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 8) + 24) = 1;
      }
      v33 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
      if (v33 >= *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8) + 24))
      {
        if (*(_DWORD *)(a1 + 136) > v33 + 1)
        {
          if (v10 == 2)
            v34 = 2;
          else
            v34 = v10 == 3;
          v35 = v26 & 0x7FFFFFFF;
          v36 = (_DWORD *)(a2 + 16);
          while (1)
          {
            if ((*v36 & 0x80000000) != 0)
            {
              if ((_DWORD)v34 == 1)
              {
                v37 = v35 >> 1;
              }
              else
              {
                v37 = v26 & 0x7FFFFFFF;
                if (!(_DWORD)v34)
                  v37 = v35 >> 2;
              }
              v38 = v37 == 512;
              if (v37 == 768)
                v38 = 2;
              if (v37 == 256)
                v39 = 0;
              else
                v39 = v38;
              vectorIndexInsertForMerge(*(_QWORD *)(*(_QWORD *)(a1 + 112) + 4896), v96, v95, v29 & 1, v97, v98, v39, v34, 3.4028e38, 0, -1);
            }
            else if (*((_QWORD *)v36 - 2))
            {
              v48 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) + 1;
              v49 = storageResolvePtr(*(_QWORD *)(a1 + 112) + 4960, 8 * v48, 8uLL, 1);
              v25 = *(_QWORD *)v49;
              if (*(_QWORD *)v49)
              {
                if ((_DWORD)v34 == 1)
                {
                  v35 >>= 1;
                  v50 = v27;
                }
                else
                {
                  v50 = v27;
                  if (!(_DWORD)v34)
                    v35 >>= 2;
                }
                if (v35 == 768)
                  v51 = 2;
                else
                  v51 = v35 == 512;
                if (v35 == 256)
                  v52 = 0;
                else
                  v52 = v51;
                LODWORD(v25) = vectorIndexInsertForMerge(*(_QWORD *)(*(_QWORD *)(a1 + 112) + 4896), v96, v95, v29 & 1, v97, v98, v52, v34, v28, v25, v50) ^ 1;
              }
              *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = v48;
              return (_DWORD)v25 != 0;
            }
            v36 += 16;
            if (!--v7)
              goto LABEL_55;
          }
        }
        _os_feature_enabled_impl();
        si_analytics_log_2520("Bad term id encountered during merge wk: %d ve:%d");
        return 1;
      }
      v81 = __si_assert_copy_extra_5354(0, -1);
      v79 = v81;
      v82 = "";
      if (v81)
        v82 = v81;
      __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 3117, "lastId>=lastStringId", v82);
      goto LABEL_153;
    }
    ++*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
    v11 = (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) + 1);
    if (*(_DWORD *)(a1 + 136) > v11)
    {
      v12 = *(_QWORD *)(a1 + 88);
      v13 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24);
      Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 96), (const void *)(*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) + 1));
      if (!Value)
        goto LABEL_95;
      v15 = v8 & 0x7FFFFFFF;
      v99[0] = MEMORY[0x1E0C809B0];
      v99[1] = 0x40000000;
      v100 = __realizeTerm_block_invoke;
      v101 = &__block_descriptor_tmp_91;
      v102 = v12;
      v103 = v13;
      v105 = v11;
      v104 = Value;
      if ((v8 & 0x7FFFFFFF) > 0x413)
      {
LABEL_95:
        *(_QWORD *)(*(_QWORD *)(a1 + 104) + 16) = *(_QWORD *)storageResolvePtr(*(_QWORD *)(a1 + 112) + 4960, 8 * v11, 8uLL, 1);
        *(_QWORD *)(*(_QWORD *)(a1 + 104) + 24) = *(_QWORD *)storageResolvePtr(*(_QWORD *)(a1 + 112) + 9672, 8 * v11, 8uLL, 1);
        if (!*(_QWORD *)storageResolvePtr(*(_QWORD *)(a1 + 112) + 4960, 8 * v11, 8uLL, 1)
          || bt_mergeCallback((unsigned __int16)v8, v9, *(int ***)(a1 + 104)))
        {
          if (!*(_WORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
          {
            v53 = v11 & -*MEMORY[0x1E0C85AD8];
            v54 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24);
            storageInvalidate(*(_QWORD *)(a1 + 112) + 4960, 8 * v54, 8 * (v53 - v54));
            v55 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24);
            storageInvalidate(*(_QWORD *)(a1 + 112) + 9672, 8 * v55, 8 * (v53 - v55));
            *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24) = v53;
            if (*(_QWORD *)(*(_QWORD *)(a1 + 112) + 480) > 0x10000uLL)
            {
              v56 = (*(_QWORD *)(*(_QWORD *)(a1 + 112) + 480) - 0x10000) & ~*MEMORY[0x1E0C85AC0];
              v57 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24);
              storageInvalidate(*(_QWORD *)(a1 + 112) + 248, v57, v56 - v57);
              *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24) = v56;
            }
          }
          LODWORD(v25) = 0;
          *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = v11;
          return (_DWORD)v25 != 0;
        }
        return 1;
      }
      bzero(buf, 0x415uLL);
      if (!(_DWORD)v15)
        goto LABEL_64;
      for (i = 0; i != v15; ++i)
        buf[i] = tcmr[*((unsigned __int8 *)v9 + i)];
      buf[v15] = 0;
      if (v15 < 2 || buf[0] - 1 > 3)
      {
LABEL_64:
        v17 = 0;
        v19 = 0;
        v18 = 0;
        goto LABEL_65;
      }
      switch(buf[0])
      {
        case 1u:
          v17 = 1;
          if (buf[1] == 2)
            v17 = 2;
          v18 = 4 * (buf[1] == 2);
          if (buf[(v15 - 1)] == 1 && buf[(v15 - 2)] == 1)
          {
            v19 = 1;
            goto LABEL_65;
          }
          v59 = v17;
LABEL_113:
          v60 = v59 + 1;
          v19 = buf[v59];
          if (((char)buf[v59] & 0x80000000) == 0)
          {
            v17 = v59 + 1;
            goto LABEL_65;
          }
          v17 = v59 + 2;
          v61 = (char)buf[v60];
          v62 = buf[v60];
          if ((v61 & 0x80000000) == 0)
          {
            v19 = v19 & 0x7F | (v62 << 7);
            goto LABEL_65;
          }
          v63 = v59 + 3;
          v64 = (char)buf[v17];
          v65 = v64;
          if ((v64 & 0x80000000) == 0)
          {
            v66 = ((v62 & 0x7F) << 7) | (v64 << 14) | (v19 & 0x7F);
            v17 = v63;
LABEL_146:
            v19 = v66;
LABEL_65:
            v40 = (char *)&buf[v17];
            v41 = &buf[v15 - 1];
            v42 = *v41;
            if (v42 == 3)
              v43 = v18 | 2;
            else
              v43 = v18;
            if (v42 <= 5)
            {
              if (v41 <= (uint8_t *)v40)
              {
                if (v42 == 1)
                  goto LABEL_92;
              }
              else
              {
                v44 = v15 - v17;
                v45 = 1;
                v46 = &buf[v15 - 1];
                while (1)
                {
                  v47 = *--v46;
                  if (v47 > 5)
                    break;
                  ++v45;
                  v41 = v46;
                  if (v46 <= (uint8_t *)v40)
                  {
                    v41 = &buf[v17];
                    goto LABEL_90;
                  }
                }
                v44 = v45;
LABEL_90:
                if (*v41 == 1)
                {
                  if (v44 != 1)
                  {
                    if ((_DWORD)v19 || v44 < 3 || v41[2] != 5)
                    {
                      v58 = v41;
                    }
                    else
                    {
                      switch(v41[1])
                      {
                        case 2u:
                          v43 = v43 | 0x80;
                          break;
                        case 3u:
                          v43 = v43 | 0x100;
                          break;
                        case 4u:
                          v43 = v43 | 0x200;
                          break;
                        case 5u:
                          v43 = v43 | 0x400;
                          break;
                        default:
                          break;
                      }
                      v58 = v41 + 3;
                      v44 -= 3;
                    }
                    if (v44 >= 2)
                    {
                      v70 = v58[1];
                      v71 = v70 - 4;
                      if (v19 <= 1)
                        v72 = 1;
                      else
                        v72 = v19;
                      v73 = v43 | 8;
                      if (v70 != 2)
                        v73 = v43;
                      v74 = v70 == 1;
                      if (v70 == 1)
                        v75 = v72;
                      else
                        v75 = v19;
                      if (v74)
                        v73 = v43;
                      if (v71 >= 2)
                        v19 = v75;
                      else
                        v19 = v72;
                      if (v71 >= 2)
                        v43 = v73;
                      else
                        v43 = v43 | 1;
                    }
                    goto LABEL_93;
                  }
LABEL_92:
                  v43 = v43 | 1;
LABEL_93:
                  *v41 = 0;
                  v100((uint64_t)v99, v40, v41 - (uint8_t *)v40, v19, v43);
                  goto LABEL_95;
                }
              }
            }
            __realizeTerm_block_invoke((uint64_t)v99, v40, v15 - v17, v19, v43);
            goto LABEL_95;
          }
          v17 = v59 | 4;
          v67 = (char)buf[v63];
          v68 = buf[v63];
          if ((v67 & 0x80000000) == 0)
          {
            v69 = ((v65 & 0x7F) << 14) | (v68 << 21);
LABEL_145:
            v66 = v69 & 0xFFFFC000 | ((v62 & 0x7F) << 7) | v19 & 0x7F;
            goto LABEL_146;
          }
          v76 = (char)buf[v17];
          if ((v76 & 0x80000000) == 0)
          {
            v77 = v76;
            v17 = v59 + 5;
            v69 = ((v68 & 0x7F) << 21) | (v77 << 28) | ((v65 & 0x7F) << 14);
            goto LABEL_145;
          }
          v79 = __si_assert_copy_extra_268();
          __message_assert_346((uint64_t)v79, v88, v89, v90, v91, v92, v93, v94, (char)"VIntUtils.h");
          break;
        case 2u:
          v18 = 16;
          goto LABEL_112;
        case 3u:
          v18 = 32;
          goto LABEL_112;
        case 4u:
          v18 = 64;
          goto LABEL_112;
        default:
          v18 = 0;
LABEL_112:
          v59 = 1;
          goto LABEL_113;
      }
LABEL_153:
      free(v79);
      if (__valid_fs(-1))
        v83 = 2989;
      else
        v83 = 3072;
      *(_DWORD *)v83 = -559038737;
      abort();
    }
    _os_feature_enabled_impl();
    si_analytics_log_2520("Bad term id encountered during merge ve:%d");
    return 1;
  }
  v21 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  v22 = v21 + 1;
  if (*(_DWORD *)(a1 + 136) <= v21 + 1)
  {
    _os_feature_enabled_impl();
    si_analytics_log_2520("Bad term id (path) encountered during merge ve:%d");
    return 1;
  }
  if (v21 < *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8) + 24))
  {
    v78 = __si_assert_copy_extra_5354(0, -1);
    v79 = v78;
    v80 = "";
    if (v78)
      v80 = v78;
    __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 3060, "lastId>=lastStringId", v80);
    goto LABEL_153;
  }
  if (!*(_QWORD *)a2)
  {
    v84 = __si_assert_copy_extra_5354(0, -1);
    v85 = v84;
    v86 = "";
    if (v84)
      v86 = v84;
    __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 3081, "sourceItems[i].item.postingOffset", v86);
    free(v85);
    if (__valid_fs(-1))
      v87 = 2989;
    else
      v87 = 3072;
    *(_DWORD *)v87 = -559038737;
    abort();
  }
  v23 = *(_QWORD *)storageResolvePtr(*(_QWORD *)(a1 + 112) + 4960, 8 * (v21 + 1), 8uLL, 1);
  if (v23)
  {
    PathWithPostingsOffset = directoryStoreMakePathWithPostingsOffset(*(_QWORD *)(*(_QWORD *)(a1 + 112) + 4904), (v8 >> 3) & 0xFFFFFFF, v9, v23, *(_QWORD *)(a1 + 120));
    LODWORD(v25) = PathWithPostingsOffset ^ 1;
  }
  else
  {
    LOBYTE(PathWithPostingsOffset) = 0;
    LODWORD(v25) = 0;
  }
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = v22;
  if ((PathWithPostingsOffset & 1) == 0 && !(_DWORD)v25)
    LODWORD(v25) = directoryStoreMakePathWithPostingsOffset(*(_QWORD *)(*(_QWORD *)(a1 + 112) + 4904), (v8 >> 3) & 0xFFFFFFF, v9, 0, *(_QWORD *)(a1 + 120)) ^ 1;
  return (_DWORD)v25 != 0;
}

void emitTopKTerms(uint64_t a1, const __CFDictionary *a2)
{
  char *v4;
  char *v5;
  void *Mutable;
  unint64_t Length;
  uint64_t Bytes;
  _QWORD *v9;
  uint64_t v10;
  void *v11;
  unsigned int v12;
  int v13;
  unint64_t v14;
  unsigned int v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  void (*v20)(_QWORD);
  int v21;
  NSObject *v22;
  uint64_t v23;
  uint64_t v24;
  void (*v25)(_QWORD);
  unsigned int v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  _QWORD v30[2];
  _QWORD v31[3];
  char *v32;
  uint8_t buf[4];
  const char *v34;
  __int16 v35;
  int v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 37))
  {
    v32 = 0;
    if (asprintf(&v32, "%s%s", (const char *)(a1 + 15168), "topK.v2.mdplistc") >= 1)
    {
      v4 = (char *)fd_create_protected(*(_DWORD *)(a1 + 56), v32, 1538, 0);
      if (v4)
      {
        v5 = v4;
        Mutable = (void *)_MDPlistContainerCreateMutable();
        _MDPlistContainerBeginContainer();
        _MDPlistContainerBeginDictionary();
        CFDictionaryApplyFunction(a2, (CFDictionaryApplierFunction)emitTerms_5428, Mutable);
        _MDPlistContainerEndDictionary();
        _MDPlistContainerEndContainer();
        Length = _MDPlistContainerGetLength();
        Bytes = _MDPlistContainerGetBytes();
        fd_pwrite((uint64_t)v5, Bytes, Length, 0);
        fd_sync((uint64_t)v5, 0);
        v9 = fd_create_protected(*(_DWORD *)(a1 + 56), v32, 0, 0);
        *(_QWORD *)(a1 + 14448) = v9;
        if (v9)
        {
          CFRelease(Mutable);
          v10 = fd_mmap(*(_QWORD *)(a1 + 14448));
          if (v10 != -1)
          {
            v11 = (void *)v10;
            v31[0] = v10;
            v31[1] = Length;
            v31[2] = 0;
            v30[0] = 1;
            v30[1] = v31;
            do
            {
              v12 = __ldxr(exceptionSequenceNum);
              v13 = v12 + 1;
            }
            while (__stxr(v12 + 1, exceptionSequenceNum));
            v14 = setThreadIdAndInfo(-1, (__int128 *)sMappingExceptionCallbacks, (uint64_t)v30, 0, v13);
            v28 = HIDWORD(v14);
            v29 = v14;
            v26 = v16;
            v27 = v15;
            v17 = *(_QWORD *)&threadData[18 * v14 + 2];
            v18 = v17 + 320 * HIDWORD(v14);
            *(_BYTE *)(v18 + 216) = 0;
            v19 = *(_DWORD *)(v18 + 312);
            v20 = *(void (**)(_QWORD))(v18 + 224);
            if (v20)
              v20(*(_QWORD *)(v17 + 320 * HIDWORD(v14) + 288));
            if (_setjmp((int *)v18))
            {
              v21 = *__error();
              v22 = _SILogForLogForCategory(0);
              if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136315394;
                v34 = "emitTopKTerms";
                v35 = 1024;
                v36 = 1844;
                _os_log_error_impl(&dword_1B8270000, v22, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
              }
              *__error() = v21;
              *(_DWORD *)(v18 + 312) = v19;
              CIOnThreadCleanUpReset(v26);
              dropThreadId(v29, 1, v13);
              CICleanUpReset(v29, v27);
            }
            else
            {
              *(_QWORD *)(a1 + 14456) = _MDPlistContainerCreateWithBytes();
              v23 = *(_QWORD *)&threadData[18 * v29 + 2];
              v24 = v23 + 320 * v28;
              *(_DWORD *)(v24 + 312) = v19;
              v25 = *(void (**)(_QWORD))(v24 + 232);
              if (v25)
                v25(*(_QWORD *)(v23 + 320 * v28 + 288));
              dropThreadId(v29, 0, v13);
            }
            if (!*(_QWORD *)(a1 + 14456))
              munmap(v11, Length);
          }
        }
        else
        {
          _fd_unlink_with_origin((uint64_t)v5, 0);
        }
        fd_release(v5);
      }
    }
    free(v32);
  }
}

void pqDisposeApplier_5412(uint64_t a1, void **a2)
{
  free(*a2);
  free(a2);
}

void emitTerms_5428(uint64_t a1, CFTypeRef cf, void *a3)
{
  const __CFDictionary *v5;
  CFStringRef v6;

  v5 = (const __CFDictionary *)CFRetain(cf);
  v6 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%d"), a1);
  _MDPlistContainerAddObject();
  _MDPlistContainerBeginDictionary();
  CFDictionaryApplyFunction(v5, (CFDictionaryApplierFunction)emitTerm, a3);
  _MDPlistContainerEndDictionary();
  CFRelease(v5);
  CFRelease(v6);
}

void emitTerm(const void *a1)
{
  CFTypeRef v1;

  v1 = CFRetain(a1);
  _MDPlistContainerAddObject();
  _MDPlistContainerAddInt32Value();
  CFRelease(v1);
}

void __realizeTerm_block_invoke(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, __int16 a5)
{
  unint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  char v13;
  const UChar *v14;
  int32_t v15;
  CFStringRef v16;
  CFStringRef v17;
  __int128 v18;
  CFStringRef v19;
  uint64_t v20;
  UErrorCode pErrorCode[2];
  UChar dest[4];
  uint64_t v23;
  _WORD v24[7];
  uint64_t v25;
  uint64_t v26;
  _WORD v27[7];
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if ((unint64_t)(a3 - 46) >= 0xFFFFFFFFFFFFFFD3 && (a5 & 0x47F) == 0)
  {
    v7 = *a2;
    if (*a2 < 0)
    {
      v8 = utf8_byte_length(unsigned char)::utf8_len_table[v7 >> 4];
      v9 = utf8_to_code_point(unsigned char const*)::utf8_first_char_mask[v8] & v7;
      if ((~(v7 >> 4) & 0xC) != 0)
      {
        LODWORD(v7) = utf8_to_code_point(unsigned char const*)::utf8_first_char_mask[v8] & v7;
      }
      else
      {
        if (v8 <= 2)
          v10 = 2;
        else
          v10 = utf8_byte_length(unsigned char)::utf8_len_table[v7 >> 4];
        v11 = v10 - 1;
        v12 = a2 + 1;
        do
        {
          v13 = *v12++;
          LODWORD(v7) = v13 & 0x3F | (v9 << 6);
          v9 = v7;
          --v11;
        }
        while (v11);
      }
    }
    if (!u_ispunct(v7))
    {
      v25 = 0;
      v26 = 0;
      memset(v27, 0, sizeof(v27));
      *(_QWORD *)pErrorCode = 0;
      v14 = (const UChar *)strFromUTF8();
      if (v14)
      {
        if (v7 >= 0xE00
          && ((v7 & 0xFFFFFF80) == 0xE00
           || (v7 - 65376) < 0x50
           || (v7 & 0xFFFFFF00) == 0x1100
           || (v7 - 11904) >> 7 <= 0x196))
        {
          *(_QWORD *)dest = 0;
          v23 = 0;
          memset(v24, 0, sizeof(v24));
          v15 = u_strToLower(dest, 15, v14, pErrorCode[0], 0, &pErrorCode[1]);
          if (pErrorCode[1] == U_ZERO_ERROR)
          {
            v16 = CFStringCreateWithCharacters((CFAllocatorRef)*MEMORY[0x1E0C9AE00], dest, v15);
            if (v16)
            {
              v17 = v16;
              v18 = *(_OWORD *)(a1 + 32);
              v19 = v16;
              v20 = 0;
              LODWORD(v20) = *(_DWORD *)(a1 + 56);
              CFSetApplyFunction(*(CFSetRef *)(a1 + 48), (CFSetApplierFunction)bundleIndexApplier, &v18);
              CFRelease(v17);
            }
          }
        }
      }
    }
  }
}

void bundleIndexApplier(unsigned int a1, uint64_t a2)
{
  const void *v4;
  CFTypeRef v5;
  const __CFDictionary *v6;
  __CFDictionary *v7;
  unint64_t v8;
  const __CFDictionary *Value;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  CFIndex v14;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v16;
  char *v17;
  char *v18;
  const char *v19;
  uint64_t v20;

  v4 = (const void *)*(unsigned int *)(a2 + 24);
  v5 = CFRetain(*(CFTypeRef *)(a2 + 16));
  v6 = (const __CFDictionary *)CFRetain(*(CFTypeRef *)a2);
  v7 = (__CFDictionary *)CFRetain(*(CFTypeRef *)(a2 + 8));
  v8 = a1;
  Value = (const __CFDictionary *)CFDictionaryGetValue(v6, (const void *)a1);
  v10 = CFDictionaryGetValue(Value, v4);
  if (!v10)
  {
    v17 = __si_assert_copy_extra_5354(0, -1);
    v18 = v17;
    v19 = "";
    if (v17)
      v19 = v17;
    __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 1714, "count > 0", v19);
    free(v18);
    if (__valid_fs(-1))
      v20 = 2989;
    else
      v20 = 3072;
    *(_DWORD *)v20 = -559038737;
    abort();
  }
  if (!CFDictionaryContainsKey(v7, (const void *)a1))
  {
    v11 = 50;
    if (a1 == 679607404)
      v11 = 0;
    if (a1 == 856881155)
      v12 = 10000;
    else
      v12 = v11;
    if (a1 == 716189596)
      v13 = 10000;
    else
      v13 = v12;
    if (a1 == 510259174)
      v14 = 10000;
    else
      v14 = v13;
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v14, MEMORY[0x1E0C9B390], 0);
    CFDictionaryAddValue(v7, (const void *)v8, Mutable);
    CFRelease(Mutable);
  }
  v16 = (__CFDictionary *)CFDictionaryGetValue(v7, (const void *)v8);
  CFDictionarySetValue(v16, v5, (const void *)v10);
  CFRelease(v5);
  CFRelease(v6);
  CFRelease(v7);
}

uint64_t findPacking(unint64_t a1, uint64_t a2)
{
  int64x2_t v2;
  int32x4_t v3;
  int16x8_t v4;
  int16x8_t v5;
  int32x4_t v6;
  int16x8_t v7;
  int32x4_t v8;
  int32x2_t v9;
  int16x8_t v10;
  int32x4_t v11;
  int32x4_t v12;
  unsigned int v14;
  uint64_t result;
  int8x16_t v16;
  unint64_t v17;
  const float *v18;
  uint64_t v19;
  uint64_t v20;
  uint64x2_t v21;
  uint32x4_t v22;
  __int32 *v23;
  int16x8_t v24;
  int64x2_t v25;
  int64x2_t v26;
  int64x2_t v27;
  int64x2_t v28;
  int64x2_t v29;
  int64x2_t v30;
  int64x2_t v31;
  int64x2_t v32;
  int8x16_t v33;
  int32x4_t v34;
  int16x8_t v35;
  int32x2_t v36;
  int16x8_t v37;
  int16x8_t v38;
  int32x4_t v39;
  int32x2_t v40;
  int32x4_t v41;
  int16x8_t v42;
  int32x2_t v43;
  int16x8_t v44;
  int32x4_t v45;
  int32x2_t v46;
  int32x4_t v47;
  int8x16_t v48;
  int16x8_t v49;
  BOOL v52;

  v14 = *(_DWORD *)a2;
  if (*(_DWORD *)a2)
    result = packingStart[__clz(v14)];
  else
    result = 0;
  while (2)
  {
    switch((int)result)
    {
      case 2:
        if (a1 < 9)
          goto LABEL_101;
        if (v14 > 0xF)
          goto LABEL_101;
        v16 = vorrq_s8(*(int8x16_t *)(a2 + 4), *(int8x16_t *)(a2 + 20));
        *(int8x8_t *)v16.i8 = vorr_s8(*(int8x8_t *)v16.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v16, v16, 8uLL));
        if ((v16.i32[0] | v16.i32[1]) >= 8)
          goto LABEL_101;
        result = 2;
        break;
      case 4:
        if (a1 < 6)
          goto LABEL_101;
        if ((*(_DWORD *)(a2 + 4) | *(_DWORD *)(a2 + 8) | *(_DWORD *)(a2 + 12) | v14) > 0x1F
          || (*(_DWORD *)(a2 + 20) | *(_DWORD *)(a2 + 16)) >= 0x10)
        {
          goto LABEL_101;
        }
        result = 4;
        break;
      case 5:
        if (a1 < 5
          || (*(_DWORD *)(a2 + 4) | *(_DWORD *)(a2 + 8) | v14) > 0x3F
          || (*(_DWORD *)(a2 + 16) | *(_DWORD *)(a2 + 12)) >= 0x20)
        {
          goto LABEL_101;
        }
        result = 5;
        break;
      case 7:
        if (a1 < 4)
          goto LABEL_101;
        if ((*(_DWORD *)(a2 + 8) | v14) >> 14 || (*(_DWORD *)(a2 + 12) | *(_DWORD *)(a2 + 4)) != 0)
          goto LABEL_101;
        result = 7;
        break;
      case 8:
        if (a1 < 4)
          goto LABEL_101;
        v52 = (*(_DWORD *)(a2 + 4) | *(_DWORD *)(a2 + 8)) <= 0x7F && *(_DWORD *)(a2 + 12) == 0;
        if (!v52 || v14 >= 0x4000)
          goto LABEL_101;
        result = 8;
        break;
      case 9:
        if (a1 < 3 || (*(_DWORD *)(a2 + 4) | v14) > 0x7F || *(_DWORD *)(a2 + 8) >= 0x4000u)
          goto LABEL_101;
        result = 9;
        break;
      case 10:
        if (a1 < 3 || *(_DWORD *)(a2 + 4) >> 14 || (*(_DWORD *)(a2 + 8) | v14) >= 0x80)
          goto LABEL_101;
        result = 10;
        break;
      case 11:
        if (a1 < 3 || v14 >> 14 || (*(_DWORD *)(a2 + 8) | *(_DWORD *)(a2 + 4)) >= 0x80)
          goto LABEL_101;
        result = 11;
        break;
      case 12:
        if (a1 < 3)
          goto LABEL_101;
        if ((*(_DWORD *)(a2 + 4) | v14) >> 14 || *(_DWORD *)(a2 + 8) != 0)
          goto LABEL_101;
        result = 12;
        break;
      case 13:
        if (a1 < 3 || v14 > 0x3FF || (*(_DWORD *)(a2 + 8) | *(_DWORD *)(a2 + 4)) >= 0x200)
          goto LABEL_101;
        result = 13;
        break;
      case 14:
        if (a1 < 2 || (*(_DWORD *)(a2 + 4) | v14) >= 0x4000)
          goto LABEL_101;
        result = 14;
        break;
      case 15:
        if (v14 >> 27)
          goto LABEL_101;
        result = 15;
        break;
      default:
        v17 = packingCount_9286[result];
        if (v17 > a1)
          goto LABEL_101;
        v19 = v17 <= 1 ? 1 : packingCount_9286[result];
        v20 = ((_WORD)v19 + 15) & 0x1F0;
        v21 = (uint64x2_t)vdupq_n_s64(v19 - 1);
        v18 = (const float *)((char *)&packingSize + 4 * result);
        v22 = (uint32x4_t)vld1q_dup_f32(v18);
        v23 = (__int32 *)(a2 + 32);
        v24.i64[0] = 0x101010101010101;
        v24.i64[1] = 0x101010101010101;
        v25 = (int64x2_t)xmmword_1B8631BB0;
        v26 = (int64x2_t)xmmword_1B8631D90;
        v27 = (int64x2_t)xmmword_1B8631D80;
        v28 = (int64x2_t)xmmword_1B8631D70;
        v29 = (int64x2_t)xmmword_1B8631D60;
        v30 = (int64x2_t)xmmword_1B8631D50;
        v31 = (int64x2_t)xmmword_1B8631D40;
        v32 = (int64x2_t)xmmword_1B8631D30;
        do
        {
          v33 = (int8x16_t)v24;
          v34 = (int32x4_t)vcgeq_u64(v21, (uint64x2_t)v25);
          *(int32x2_t *)v10.i8 = vmovn_s64((int64x2_t)v34);
          *(int16x4_t *)v24.i8 = vmovn_s32((int32x4_t)v10);
          *(int8x8_t *)v24.i8 = vmovn_s16(v24);
          if ((v24.i8[0] & 1) != 0)
            v24.i32[0] = *(v23 - 8);
          *(int16x4_t *)v10.i8 = vmovn_s32((int32x4_t)v10);
          if ((vmovn_s16(v10).i8[1] & 1) != 0)
            v24.i32[1] = *(v23 - 7);
          v10 = (int16x8_t)vcgeq_u64(v21, (uint64x2_t)v26);
          v35 = (int16x8_t)vmovn_hight_s64(*(int32x2_t *)v11.i8, (int64x2_t)v10);
          *(int16x4_t *)v35.i8 = vmovn_s32((int32x4_t)v35);
          v36 = (int32x2_t)vmovn_s16(v35);
          if ((v36.i8[2] & 1) != 0)
            v24.i32[2] = *(v23 - 6);
          v37 = (int16x8_t)vmovn_hight_s64(v36, (int64x2_t)v10);
          *(int16x4_t *)v37.i8 = vmovn_s32((int32x4_t)v37);
          if ((vmovn_s16(v37).i8[3] & 1) != 0)
            v24.i32[3] = *(v23 - 5);
          v11 = (int32x4_t)vcgeq_u64(v21, (uint64x2_t)v27);
          *(int32x2_t *)v12.i8 = vmovn_s64((int64x2_t)v11);
          v38 = vmovn_hight_s32(*(int16x4_t *)v2.i8, v12);
          *(int8x8_t *)v38.i8 = vmovn_s16(v38);
          if ((v38.i8[4] & 1) != 0)
            v38.i32[0] = *(v23 - 4);
          if ((vmovn_s16(vmovn_hight_s32(*(int16x4_t *)&v12, v12)).i8[5] & 1) != 0)
            v38.i32[1] = *(v23 - 3);
          v12 = (int32x4_t)vcgeq_u64(v21, (uint64x2_t)v28);
          v39 = vmovn_hight_s64(*(int32x2_t *)v3.i8, (int64x2_t)v12);
          v40 = (int32x2_t)vmovn_s16(vmovn_hight_s32(*(int16x4_t *)v39.i8, v39));
          if ((v40.i8[6] & 1) != 0)
            v38.i32[2] = *(v23 - 2);
          v41 = vmovn_hight_s64(v40, (int64x2_t)v12);
          if ((vmovn_s16(vmovn_hight_s32(*(int16x4_t *)&v41, v41)).i8[7] & 1) != 0)
            v38.i32[3] = *(v23 - 1);
          v3 = (int32x4_t)vcgeq_u64(v21, (uint64x2_t)v29);
          *(int32x2_t *)v5.i8 = vmovn_s64((int64x2_t)v3);
          *(int16x4_t *)v4.i8 = vmovn_s32((int32x4_t)v5);
          *(int8x8_t *)v4.i8 = vmovn_s16(v4);
          if ((v4.i8[0] & 1) != 0)
            v4.i32[0] = *v23;
          *(int16x4_t *)v5.i8 = vmovn_s32((int32x4_t)v5);
          if ((vmovn_s16(v5).i8[1] & 1) != 0)
            v4.i32[1] = v23[1];
          v5 = (int16x8_t)vcgeq_u64(v21, (uint64x2_t)v30);
          v42 = (int16x8_t)vmovn_hight_s64(*(int32x2_t *)v6.i8, (int64x2_t)v5);
          *(int16x4_t *)v42.i8 = vmovn_s32((int32x4_t)v42);
          v43 = (int32x2_t)vmovn_s16(v42);
          if ((v43.i8[2] & 1) != 0)
            v4.i32[2] = v23[2];
          v44 = (int16x8_t)vmovn_hight_s64(v43, (int64x2_t)v5);
          *(int16x4_t *)v44.i8 = vmovn_s32((int32x4_t)v44);
          if ((vmovn_s16(v44).i8[3] & 1) != 0)
            v4.i32[3] = v23[3];
          v6 = (int32x4_t)vcgeq_u64(v21, (uint64x2_t)v31);
          *(int32x2_t *)v8.i8 = vmovn_s64((int64x2_t)v6);
          v7 = vmovn_hight_s32(*(int16x4_t *)v7.i8, v8);
          *(int8x8_t *)v7.i8 = vmovn_s16(v7);
          if ((v7.i8[4] & 1) != 0)
            v7.i32[0] = v23[4];
          if ((vmovn_s16(vmovn_hight_s32(*(int16x4_t *)&v8, v8)).i8[5] & 1) != 0)
            v7.i32[1] = v23[5];
          v8 = (int32x4_t)vcgeq_u64(v21, (uint64x2_t)v32);
          v45 = vmovn_hight_s64(v9, (int64x2_t)v8);
          v46 = (int32x2_t)vmovn_s16(vmovn_hight_s32(*(int16x4_t *)v45.i8, v45));
          if ((v46.i8[6] & 1) != 0)
            v7.i32[2] = v23[6];
          v47 = vmovn_hight_s64(v46, (int64x2_t)v8);
          v9 = (int32x2_t)vmovn_s16(vmovn_hight_s32(*(int16x4_t *)v47.i8, v47));
          if ((v9.i8[7] & 1) != 0)
            v7.i32[3] = v23[7];
          v48 = (int8x16_t)vuzp1q_s16((int16x8_t)vcgtq_u32(v22, (uint32x4_t)v24), (int16x8_t)vcgtq_u32(v22, (uint32x4_t)v38));
          v49 = (int16x8_t)vcgtq_u32(v22, (uint32x4_t)v4);
          v4 = (int16x8_t)vcgtq_u32(v22, (uint32x4_t)v7);
          v24 = (int16x8_t)vandq_s8(v33, vuzp1q_s8(v48, (int8x16_t)vuzp1q_s16(v49, v4)));
          v2 = vdupq_n_s64(0x10uLL);
          v27 = vaddq_s64(v27, v2);
          v26 = vaddq_s64(v26, v2);
          v25 = vaddq_s64(v25, v2);
          v28 = vaddq_s64(v28, v2);
          v29 = vaddq_s64(v29, v2);
          v30 = vaddq_s64(v30, v2);
          v31 = vaddq_s64(v31, v2);
          v32 = vaddq_s64(v32, v2);
          v23 += 16;
          v20 -= 16;
        }
        while (v20);
        if ((vminvq_u8((uint8x16_t)vcltzq_s8(vshlq_n_s8(vbslq_s8(vuzp1q_s8((int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32(v34, (int32x4_t)v10), (int16x8_t)vuzp1q_s32(v11, v12)), (int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32(v3, (int32x4_t)v5), (int16x8_t)vuzp1q_s32(v6, v8))), (int8x16_t)v24, v33), 7uLL))) & 1) == 0)
        {
LABEL_101:
          if ((_DWORD)++result != 16)
            continue;
          result = 16;
        }
        break;
    }
    return result;
  }
}

uint64_t packOneWord(uint64_t *a1, uint64_t *a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  int v8;
  int8x16_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  int8x16_t v14;
  unsigned int v15;
  uint64_t v16;
  BOOL v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int8x16_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t result;
  char *v26;
  char *v27;
  const char *v28;
  uint64_t v29;

  v3 = *a2;
  v4 = *a2;
  switch(a3)
  {
    case 0:
      v5 = *a1;
      if (*a1 <= 0)
      {
        v7 = 0;
      }
      else
      {
        v6 = v5 & ~(v5 >> 63);
        v7 = *(_DWORD *)v4 != 0;
        if (v6 != 1)
        {
          v7 |= 2 * (*(_DWORD *)(v4 + 4) != 0);
          if (v6 != 2)
          {
            v7 |= 4 * (*(_DWORD *)(v4 + 8) != 0);
            if (v6 != 3)
            {
              v7 |= 8 * (*(_DWORD *)(v4 + 12) != 0);
              if (v6 != 4)
              {
                v7 |= 16 * (*(_DWORD *)(v4 + 16) != 0);
                if (v6 != 5)
                {
                  v7 |= 32 * (*(_DWORD *)(v4 + 20) != 0);
                  if (v6 != 6)
                  {
                    v7 |= (*(_DWORD *)(v4 + 24) != 0) << 6;
                    if (v6 != 7)
                    {
                      v7 |= (*(_DWORD *)(v4 + 28) != 0) << 7;
                      if (v6 != 8)
                      {
                        v7 |= (*(_DWORD *)(v4 + 32) != 0) << 8;
                        if (v6 != 9)
                        {
                          v7 |= (*(_DWORD *)(v4 + 36) != 0) << 9;
                          if (v6 != 10)
                          {
                            v7 |= (*(_DWORD *)(v4 + 40) != 0) << 10;
                            if (v6 != 11)
                            {
                              v7 |= (*(_DWORD *)(v4 + 44) != 0) << 11;
                              if (v6 != 12)
                              {
                                v7 |= (*(_DWORD *)(v4 + 48) != 0) << 12;
                                if (v6 != 13)
                                {
                                  v7 |= (*(_DWORD *)(v4 + 52) != 0) << 13;
                                  if (v6 != 14)
                                  {
                                    v7 |= (*(_DWORD *)(v4 + 56) != 0) << 14;
                                    if (v6 != 15)
                                    {
                                      v7 |= (*(_DWORD *)(v4 + 60) != 0) << 15;
                                      if (v6 != 16)
                                      {
                                        v7 |= (*(_DWORD *)(v4 + 64) != 0) << 16;
                                        if (v6 != 17)
                                        {
                                          v7 |= (*(_DWORD *)(v4 + 68) != 0) << 17;
                                          if (v6 != 18)
                                          {
                                            v7 |= (*(_DWORD *)(v4 + 72) != 0) << 18;
                                            if (v6 != 19)
                                            {
                                              v7 |= (*(_DWORD *)(v4 + 76) != 0) << 19;
                                              if (v6 != 20)
                                              {
                                                v7 |= (*(_DWORD *)(v4 + 80) != 0) << 20;
                                                if (v6 != 21)
                                                {
                                                  v7 |= (*(_DWORD *)(v4 + 84) != 0) << 21;
                                                  if (v6 != 22)
                                                  {
                                                    v7 |= (*(_DWORD *)(v4 + 88) != 0) << 22;
                                                    if (v6 != 23)
                                                    {
                                                      v7 |= (*(_DWORD *)(v4 + 92) != 0) << 23;
                                                      if (v6 != 24)
                                                      {
                                                        v7 |= (*(_DWORD *)(v4 + 96) != 0) << 24;
                                                        if (v6 != 25)
                                                        {
                                                          v7 |= (*(_DWORD *)(v4 + 100) != 0) << 25;
                                                          if (v6 != 26)
                                                          {
                                                            v7 |= (*(_DWORD *)(v4 + 104) != 0) << 26;
                                                            if (v6 != 27)
                                                              v7 |= (*(_DWORD *)(v4 + 108) != 0) << 27;
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      *a1 = v5 - 28;
      v4 = v3 + 112;
      goto LABEL_94;
    case 1:
      v18 = *a1;
      if (*a1 < 1)
      {
        v7 = 0;
      }
      else
      {
        v19 = v18 & ~(v18 >> 63);
        v7 = *(_DWORD *)v4;
        if (v19 != 1)
        {
          v7 |= 4 * *(_DWORD *)(v4 + 4);
          if (v19 != 2)
          {
            v7 |= 16 * *(_DWORD *)(v4 + 8);
            if (v19 != 3)
            {
              v7 |= *(_DWORD *)(v4 + 12) << 6;
              if (v19 != 4)
              {
                v7 |= *(_DWORD *)(v4 + 16) << 8;
                if (v19 != 5)
                {
                  v7 |= *(_DWORD *)(v4 + 20) << 10;
                  if (v19 != 6)
                  {
                    v7 |= *(_DWORD *)(v4 + 24) << 12;
                    if (v19 != 7)
                    {
                      v7 |= *(_DWORD *)(v4 + 28) << 14;
                      if (v19 != 8)
                      {
                        v7 |= *(_DWORD *)(v4 + 32) << 16;
                        if (v19 != 9)
                        {
                          v7 |= *(_DWORD *)(v4 + 36) << 18;
                          if (v19 != 10)
                          {
                            v7 |= *(_DWORD *)(v4 + 40) << 20;
                            if (v19 != 11)
                            {
                              v7 |= *(_DWORD *)(v4 + 44) << 22;
                              if (v19 != 12)
                              {
                                v7 |= *(_DWORD *)(v4 + 48) << 24;
                                if (v19 != 13)
                                  v7 |= *(_DWORD *)(v4 + 52) << 26;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      v10 = v18 - 14;
      v11 = 14;
      goto LABEL_92;
    case 2:
      v14 = vorrq_s8((int8x16_t)vshlq_u32(*(uint32x4_t *)(v4 + 4), (uint32x4_t)xmmword_1B8631DD0), (int8x16_t)vshlq_u32(*(uint32x4_t *)(v4 + 20), (uint32x4_t)xmmword_1B8631DC0));
      *(int8x8_t *)v14.i8 = vorr_s8(*(int8x8_t *)v14.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v14, v14, 8uLL));
      v7 = v14.i32[0] | *(_DWORD *)v4 | v14.i32[1];
      v10 = *a1 - 9;
      v11 = 9;
      goto LABEL_92;
    case 3:
      v20 = *a1;
      if (*a1 < 1)
      {
        v7 = 0;
      }
      else
      {
        v21 = v20 & ~(v20 >> 63);
        v7 = *(_DWORD *)v4;
        if (v21 != 1)
        {
          v7 |= 16 * *(_DWORD *)(v4 + 4);
          if (v21 != 2)
          {
            v7 |= *(_DWORD *)(v4 + 8) << 8;
            if (v21 != 3)
            {
              v7 |= *(_DWORD *)(v4 + 12) << 12;
              if (v21 != 4)
              {
                v7 |= *(_DWORD *)(v4 + 16) << 16;
                if (v21 != 5)
                {
                  v7 |= *(_DWORD *)(v4 + 20) << 20;
                  if (v21 != 6)
                    v7 |= *(_DWORD *)(v4 + 24) << 24;
                }
              }
            }
          }
        }
      }
      v10 = v20 - 7;
      v11 = 7;
      goto LABEL_92;
    case 4:
      v9 = (int8x16_t)vshlq_u32(*(uint32x4_t *)(v4 + 4), (uint32x4_t)xmmword_1B8631DB0);
      *(int8x8_t *)v9.i8 = vorr_s8(*(int8x8_t *)v9.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v9, v9, 8uLL));
      v7 = v9.i32[0] | v9.i32[1] | (*(_DWORD *)(v4 + 20) << 24) | *(_DWORD *)v4;
      v10 = *a1 - 6;
      v11 = 6;
      goto LABEL_92;
    case 5:
      v22 = (int8x16_t)vshlq_u32(*(uint32x4_t *)(v4 + 4), (uint32x4_t)xmmword_1B8631DA0);
      *(int8x8_t *)v22.i8 = vorr_s8(*(int8x8_t *)v22.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v22, v22, 8uLL));
      v7 = v22.i32[0] | *(_DWORD *)v4 | v22.i32[1];
      v10 = *a1 - 5;
      v11 = 5;
      goto LABEL_92;
    case 6:
      v23 = *a1;
      if (*a1 < 1)
      {
        v7 = 0;
      }
      else
      {
        v24 = v23 & ~(v23 >> 63);
        v7 = *(_DWORD *)v4;
        if (v24 != 1)
        {
          v7 |= *(_DWORD *)(v4 + 4) << 7;
          if (v24 != 2)
          {
            v7 |= *(_DWORD *)(v4 + 8) << 14;
            if (v24 != 3)
              v7 |= *(_DWORD *)(v4 + 12) << 21;
          }
        }
      }
      v10 = v23 - 4;
      goto LABEL_91;
    case 7:
      v7 = *(_DWORD *)v4 | (*(_DWORD *)(v4 + 8) << 14);
      goto LABEL_75;
    case 8:
      v7 = *(_DWORD *)v4 | (*(_DWORD *)(v4 + 4) << 14) | (*(_DWORD *)(v4 + 8) << 21);
LABEL_75:
      v10 = *a1 - 4;
LABEL_91:
      v11 = 4;
      goto LABEL_92;
    case 9:
      v12 = *(_DWORD *)v4 | (*(_DWORD *)(v4 + 4) << 7);
      v13 = *(_DWORD *)(v4 + 8);
      goto LABEL_38;
    case 10:
      v8 = *(_DWORD *)v4 | (*(_DWORD *)(v4 + 4) << 7);
      goto LABEL_77;
    case 11:
      v8 = *(_DWORD *)v4 | (*(_DWORD *)(v4 + 4) << 14);
LABEL_77:
      v7 = v8 | (*(_DWORD *)(v4 + 8) << 21);
      goto LABEL_78;
    case 12:
      v12 = *(_DWORD *)v4;
      v13 = *(_DWORD *)(v4 + 4);
LABEL_38:
      v7 = v12 | (v13 << 14);
      goto LABEL_78;
    case 13:
      v7 = *(_DWORD *)v4 | (*(_DWORD *)(v4 + 4) << 10) | (*(_DWORD *)(v4 + 8) << 19);
LABEL_78:
      v10 = *a1 - 3;
      v11 = 3;
      goto LABEL_92;
    case 14:
      if (*a1 < 1)
      {
        v7 = 0;
      }
      else
      {
        v7 = *(_DWORD *)v4;
        if (*a1 != 1)
          v7 |= *(_DWORD *)(v4 + 4) << 14;
      }
      v10 = *a1 - 2;
      goto LABEL_82;
    case 15:
      v15 = *(_DWORD *)v4;
      v4 += 4;
      v7 = v15;
      v16 = (*a1)--;
      v17 = v16 < 2;
      v10 = v16 - 2;
      if (v17 || *(_DWORD *)v4)
        goto LABEL_93;
      v7 |= 0x8000000u;
LABEL_82:
      v11 = 2;
LABEL_92:
      *a1 = v10;
      v4 = v3 + 4 * v11;
LABEL_93:
      if (v7 >> 28)
      {
        v26 = __si_assert_copy_extra_5354(0, -1);
        v27 = v26;
        v28 = "";
        if (v26)
          v28 = v26;
        __message_assert("%s:%u: failed assertion '%s' %s ", "disk_utils.h", 1027, "word>>28 == 0", v28);
        free(v27);
        if (__valid_fs(-1))
          v29 = 2989;
        else
          v29 = 3072;
        *(_DWORD *)v29 = -559038737;
        abort();
      }
LABEL_94:
      result = v7 | (a3 << 28);
      *a2 = v4;
      return result;
    default:
      v7 = 0;
      goto LABEL_94;
  }
}

char **writeWindowWriteBytes(char **result, char *__src, size_t __n)
{
  char **v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  char *v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  off_t v13;
  char *v14;
  uint64_t v15;
  size_t v16;

  if (!*((_DWORD *)result + 6))
  {
    v5 = result;
    v6 = *((_QWORD *)*result + 1) - (_QWORD)result[2];
    if (v6 + __n > 0x100000)
    {
      v7 = 0x100000 - v6;
      result = (char **)memcpy(&result[1][v6], __src, 0x100000 - v6);
      *((_QWORD *)*v5 + 1) += v7;
      v8 = __n - v7;
      if (__n != v7)
      {
        v9 = &__src[v7];
        do
        {
          sync_invalidate_mapping(v5[1], 0x100000);
          munmap(v5[1], 0x100000uLL);
          v10 = (uint64_t)(v5[2] + 0x100000);
          v5[1] = (char *)-1;
          v5[2] = (char *)v10;
          while (1)
          {
            v11 = *v5;
            v12 = *((_QWORD *)*v5 + 3);
            if ((uint64_t)(v5[2] + 0x100000) < v12)
              break;
            if ((unint64_t)v12 >> 30)
              v13 = v12 + 0x40000000;
            else
              v13 = 2 * v12;
            *((_QWORD *)v11 + 3) = v13;
            if (fd_truncate(*((_QWORD *)v11 + 560), v13) == -1)
              goto LABEL_20;
          }
          v14 = (char *)fd_mmap(*((_QWORD *)v11 + 560));
          v5[1] = v14;
          if (v14 == (char *)-1)
          {
LABEL_20:
            result = (char **)__error();
            *((_DWORD *)v5 + 6) = *(_DWORD *)result;
            return result;
          }
          madvise(v14, 0x100000uLL, 2);
          v15 = *((_QWORD *)*v5 + 1) - (_QWORD)v5[2];
          if (v8 >= 0x100000)
            v16 = 0x100000 - v15;
          else
            v16 = v8;
          result = (char **)memcpy(&v5[1][v15], v9, v16);
          v9 += v16;
          *((_QWORD *)*v5 + 1) += v16;
          v8 -= v16;
        }
        while (v8);
      }
    }
    else
    {
      result = (char **)memcpy(&result[1][v6], __src, __n);
      *((_QWORD *)*v5 + 1) += __n;
    }
  }
  return result;
}

uint64_t slideBuffer(unint64_t *a1, uint64_t a2)
{
  void *v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  BOOL v9;
  unint64_t v10;
  char *v12;
  char *v13;
  const char *v14;
  uint64_t v15;

  v5 = *(_QWORD *)(a2 + 16);
  v4 = *(void **)(a2 + 24);
  v6 = v5 + *a1;
  *(_QWORD *)(a2 + 16) = v6 & 0x3FFFFFFFFFFFF000;
  v7 = fd_pread(*(_DWORD **)a2, v4, 0x10000uLL, v6 & 0x3FFFFFFFFFFFF000);
  if (v7 != -1)
  {
    if (v7 != 0x10000)
      *(_BYTE *)(*(_QWORD *)(a2 + 24) + v7) = 0;
    v8 = *(_QWORD *)(a2 + 16);
    v9 = v6 >= v8;
    v10 = v6 - v8;
    if (!v9)
    {
      v12 = __si_assert_copy_extra_5354(0, -1);
      v13 = v12;
      v14 = "";
      if (v12)
        v14 = v12;
      __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 897, "next >= context->last_offset", v14);
      free(v13);
      if (__valid_fs(-1))
        v15 = 2989;
      else
        v15 = 3072;
      *(_DWORD *)v15 = -559038737;
      abort();
    }
    *a1 = v10;
  }
  if (v7 == -1)
    return -1;
  else
    return 0;
}

void _addToWPCBuffer(uint64_t a1, unsigned int a2, int a3)
{
  int v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  void *v12;
  char *v13;
  char *v14;
  const char *v15;
  char *v16;
  const char *v17;
  char *v18;
  const char *v19;
  uint64_t v20;
  uint8_t buf[4];
  unsigned int v22;
  __int16 v23;
  uint64_t v24;
  __int16 v25;
  int v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 40))
  {
    v6 = *(_DWORD *)(a1 + 84);
    if (v6 - 1 < a2)
    {
      v13 = __si_assert_copy_extra_5354(0, -1);
      v14 = v13;
      v15 = "";
      if (v13)
        v15 = v13;
      __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 1077, "buffer->lastInput == 0 || buffer->lastInput > position", v15);
      goto LABEL_26;
    }
    if (v6)
    {
      v7 = v6 - a2;
    }
    else
    {
      v8 = *(_QWORD *)(a1 + 72);
      v7 = a2;
      if (v8)
      {
        v7 = a2;
        if (*(_DWORD *)(*(_QWORD *)(a1 + 56) + 4 * v8 - 4))
        {
          v18 = __si_assert_copy_extra_5354(0, -1);
          v14 = v18;
          v19 = "";
          if (v18)
            v19 = v18;
          __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 1078, "buffer->ints[buffer->intCount-1]==0", v19);
          goto LABEL_26;
        }
      }
    }
    *(_DWORD *)(a1 + 84) = v7;
  }
  if (!a2)
  {
    if (*(_DWORD *)(a1 + 80))
      goto LABEL_13;
    v16 = __si_assert_copy_extra_5354(0, -1);
    v14 = v16;
    v17 = "";
    if (v16)
      v17 = v16;
    __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 1087, "position != 0 || buffer->lastPosition != 0", v17);
LABEL_26:
    free(v14);
    if (__valid_fs(-1))
      v20 = 2989;
    else
      v20 = 3072;
    *(_DWORD *)v20 = -559038737;
    abort();
  }
  if (a2 >> 27)
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      v9 = *(_QWORD *)(a1 + 72);
      *(_DWORD *)buf = 67109632;
      v22 = a2;
      v23 = 2048;
      v24 = v9;
      v25 = 1024;
      v26 = a3;
      _os_log_fault_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "Impossibly large position added (%x) at %ld from %d", buf, 0x18u);
    }
    goto LABEL_16;
  }
LABEL_13:
  v11 = *(_QWORD *)(a1 + 64);
  v10 = *(_QWORD *)(a1 + 72);
  v12 = *(void **)(a1 + 56);
  if (v11 <= v10)
  {
    *(_QWORD *)(a1 + 64) = 2 * v11;
    v12 = malloc_type_realloc(v12, 8 * v11, 0x100004052888210uLL);
    *(_QWORD *)(a1 + 56) = v12;
    v10 = *(_QWORD *)(a1 + 72);
  }
  *(_QWORD *)(a1 + 72) = v10 + 1;
  *((_DWORD *)v12 + v10) = a2;
LABEL_16:
  *(_DWORD *)(a1 + 44) = a3;
}

uint64_t readCompactPosition(uint64_t a1, unint64_t *a2)
{
  unint64_t v3;
  uint64_t v4;
  uint64_t result;
  unint64_t v7;
  uint64_t v9;
  char *v10;
  char *v11;
  const char *v12;
  uint64_t v13;
  char *v14;
  char *v15;
  const char *v16;
  uint64_t v17;
  unint64_t v18;

  v3 = *(_QWORD *)(a1 + 184);
  if (!v3)
  {
    v18 = *a2;
    v7 = v18;
    if ((v18 & 3) != 0)
    {
      v14 = __si_assert_copy_extra_5354(0, -1);
      v15 = v14;
      v16 = "";
      if (v14)
        v16 = v14;
      __message_assert("%s:%u: failed assertion '%s' %s offset %lu @0x%p", "CIMerging.c", 3536, "(offset & 0x3) == 0", v16, v18, a2);
      free(v15);
      if (__valid_fs(-1))
        v17 = 2989;
      else
        v17 = 3072;
      *(_DWORD *)v17 = -559038737;
      abort();
    }
    if (v18 - 65533 <= 0xFFFFFFFFFFFEFFFELL && *(_QWORD *)(a1 + 32) == 0)
    {
      if (slideBuffer(&v18, a1) == -1)
        return 0xFFFFFFFFLL;
      v7 = v18;
    }
    v9 = *(unsigned int *)(*(_QWORD *)(a1 + 24) + v7);
    *(_DWORD *)(a1 + 200) = *(_DWORD *)(a1 + 204);
    *(_DWORD *)(a1 + 204) = v9;
    __asm { BR              X13 }
  }
  if (v3 >= 0x1D)
  {
    v10 = __si_assert_copy_extra_5354(0, -1);
    v11 = v10;
    v12 = "";
    if (v10)
      v12 = v10;
    __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 3525, "context->readAheadAvailable <= 28", v12);
    free(v11);
    if (__valid_fs(-1))
      v13 = 2989;
    else
      v13 = 3072;
    *(_DWORD *)v13 = -559038737;
    abort();
  }
  *(_DWORD *)(a1 + 212) = *(_DWORD *)(a1 + 208);
  v4 = *(_QWORD *)(a1 + 192);
  *(_QWORD *)(a1 + 184) = v3 - 1;
  *(_QWORD *)(a1 + 192) = v4 + 1;
  result = *(unsigned int *)(a1 + 4 * v4 + 68);
  *(_DWORD *)(a1 + 208) = result;
  return result;
}

uint64_t checkChangeHolderIntegrity(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  char *v3;
  char *v4;
  const char *v5;
  char *v6;
  const char *v7;
  uint64_t v8;

  v1 = *(_QWORD *)(result + 8);
  if (v1)
  {
    v2 = *(_QWORD *)(result + 24);
    if (v2 <= 0)
    {
      v3 = __si_assert_copy_extra_5354(0, -1);
      v4 = v3;
      v5 = "";
      if (v3)
        v5 = v3;
      __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 4105, "changes->hole>0", v5);
    }
    else
    {
      if (v2 <= v1)
        return result;
      v6 = __si_assert_copy_extra_5354(0, -1);
      v4 = v6;
      v7 = "";
      if (v6)
        v7 = v6;
      __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 4106, "changes->hole<=changes->count", v7);
    }
    free(v4);
    if (__valid_fs(-1))
      v8 = 2989;
    else
      v8 = 3072;
    *(_DWORD *)v8 = -559038737;
    abort();
  }
  return result;
}

BOOL _excReadBufferPosContextMatch(unint64_t *a1, unint64_t a2)
{
  unint64_t v2;
  uint64_t v4;
  _QWORD *v5;
  BOOL v6;
  unint64_t v7;
  int v8;
  NSObject *v9;
  int v11;
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  unint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v2 = *a1;
  if (*a1)
  {
    v4 = 0;
    v5 = (_QWORD *)(a1[1] + 32);
    v6 = 1;
    while (1)
    {
      v7 = *(v5 - 1);
      if (v7 <= a2 && v7 + *v5 > a2)
        break;
      v6 = ++v4 < v2;
      v5 += 28;
      if (v2 == v4)
        return 0;
    }
    v8 = *__error();
    v9 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v11 = 136315650;
      v12 = "_excReadBufferPosContextMatch";
      v13 = 1024;
      v14 = 1560;
      v15 = 2048;
      v16 = a2;
      _os_log_error_impl(&dword_1B8270000, v9, OS_LOG_TYPE_ERROR, "%s:%d: Caught exception  on merge positions %p", (uint8_t *)&v11, 0x1Cu);
    }
    *__error() = v8;
  }
  else
  {
    return 0;
  }
  return v6;
}

BOOL _excReadBufferMatch(unint64_t *a1, unint64_t a2)
{
  unint64_t v2;
  uint64_t v4;
  _QWORD *v5;
  BOOL v6;
  unint64_t v7;
  int v8;
  NSObject *v9;
  int v11;
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  unint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v2 = *a1;
  if (*a1)
  {
    v4 = 0;
    v5 = (_QWORD *)(a1[1] + 8);
    v6 = 1;
    while (1)
    {
      v7 = *(v5 - 1);
      if (v7 <= a2 && v7 + *v5 > a2)
        break;
      v6 = ++v4 < v2;
      v5 += 2;
      if (v2 == v4)
        return 0;
    }
    v8 = *__error();
    v9 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v11 = 136315650;
      v12 = "_excReadBufferMatch";
      v13 = 1024;
      v14 = 1532;
      v15 = 2048;
      v16 = a2;
      _os_log_error_impl(&dword_1B8270000, v9, OS_LOG_TYPE_ERROR, "%s:%d: Caught exception  on merge postings %p", (uint8_t *)&v11, 0x1Cu);
    }
    *__error() = v8;
  }
  else
  {
    return 0;
  }
  return v6;
}

uint64_t mergeIndexDataTrampoline(uint64_t a1)
{
  _QWORD *v1;
  uint64_t v2;
  unsigned int v3;
  int v4;
  unint64_t v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  void (*v11)(_QWORD);
  _DWORD *v12;
  int v13;
  NSObject *v14;
  int v15;
  NSObject *v16;
  os_log_type_t v17;
  unsigned int v18;
  int v19;
  unint64_t v20;
  unsigned int v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  void (*v26)(_QWORD);
  _DWORD *v27;
  int v28;
  NSObject *v29;
  uint64_t v30;
  char v31;
  void *v32;
  uint64_t v33;
  unint64_t v34;
  _DWORD *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unsigned int v39;
  _DWORD *v40;
  uint64_t v41;
  unsigned int v42;
  uint64_t v43;
  void (*v44)(_QWORD);
  uint64_t v45;
  unsigned int v46;
  uint64_t v47;
  void (*v48)(_QWORD);
  uint64_t v49;
  int v51;
  _QWORD v52[12];
  unint64_t v53;
  unsigned int v54;
  unsigned int v55;
  unint64_t v56;
  unsigned int v57;
  unsigned int v58;
  char v59;
  unint64_t v60;
  unsigned int v61;
  unsigned int v62;
  unint64_t v63;
  unsigned int v64;
  unsigned int v65;
  uint8_t buf[4];
  const char *v67;
  __int16 v68;
  int v69;
  uint64_t v70;

  v1 = (_QWORD *)MEMORY[0x1E0C80A78](a1);
  v70 = *MEMORY[0x1E0C80C00];
  makeThreadId();
  pthread_set_qos_class_self_np((qos_class_t)5u, -15);
  v2 = *v1;
  if (*(_BYTE *)(*v1 + 8))
  {
    do
    {
      v3 = __ldxr(exceptionSequenceNum);
      v4 = v3 + 1;
    }
    while (__stxr(v3 + 1, exceptionSequenceNum));
    v5 = setThreadIdAndInfo(*((_DWORD *)v1 + 6), (__int128 *)sIndexExceptionCallbacks, v2, 0, v4);
    v64 = HIDWORD(v5);
    v65 = v5;
    v63 = __PAIR64__(v6, v7);
    v8 = *(_QWORD *)&threadData[18 * v5 + 2];
    v9 = v8 + 320 * HIDWORD(v5);
    *(_BYTE *)(v9 + 216) = 1;
    v10 = *(_DWORD *)(v9 + 312);
    v11 = *(void (**)(_QWORD))(v9 + 224);
    if (v11)
      v11(*(_QWORD *)(v8 + 320 * HIDWORD(v5) + 288));
    v62 = v65;
    v61 = v64;
    v60 = v63;
    if (_setjmp((int *)v9))
    {
      v12 = (_DWORD *)(v9 + 312);
      v13 = *__error();
      v14 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        v67 = "mergeIndexDataTrampoline";
        v68 = 1024;
        v69 = 515;
        _os_log_error_impl(&dword_1B8270000, v14, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
      }
      *__error() = v13;
      *v12 = v10;
      CIOnThreadCleanUpReset(v60);
      dropThreadId(v62, 1, v4);
      CICleanUpReset(v62, HIDWORD(v60));
    }
    else
    {
      v59 = 0;
      do
      {
        v18 = __ldxr(exceptionSequenceNum);
        v19 = v18 + 1;
      }
      while (__stxr(v18 + 1, exceptionSequenceNum));
      v20 = setThreadIdAndInfo(-1, sAssertExceptionCallbacks, 0, 0, v19);
      v57 = HIDWORD(v20);
      v58 = v20;
      v56 = __PAIR64__(v21, v22);
      v23 = *(_QWORD *)&threadData[18 * v20 + 2];
      v24 = v23 + 320 * HIDWORD(v20);
      v25 = *(_DWORD *)(v24 + 312);
      v26 = *(void (**)(_QWORD))(v24 + 224);
      if (v26)
        v26(*(_QWORD *)(v23 + 320 * HIDWORD(v20) + 288));
      v55 = v58;
      v54 = v57;
      v53 = v56;
      if (_setjmp((int *)v24))
      {
        v27 = (_DWORD *)(v24 + 312);
        v28 = *__error();
        v29 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315394;
          v67 = "mergeIndexDataTrampoline";
          v68 = 1024;
          v69 = 509;
          _os_log_error_impl(&dword_1B8270000, v29, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
        }
        *__error() = v28;
        *v27 = v25;
        CIOnThreadCleanUpReset(v53);
        dropThreadId(v55, 1, v19);
        CICleanUpReset(v55, HIDWORD(v53));
      }
      else
      {
        v51 = v19;
        v30 = v1[1];
        v31 = atomic_load((unsigned int *)(*v1 + 28));
        if ((v31 & 4) != 0)
          v32 = compact_callback;
        else
          v32 = non_compact_callback;
        if ((v31 & 4) != 0)
          v33 = 0;
        else
          v33 = *v1 + 4960;
        v34 = *v1 + 88;
        v35 = (_DWORD *)v1[2];
        bzero(buf, 0x5160uLL);
        _dumpTrie(v34, 1, v35, buf, (uint64_t)v32, v30);
        v36 = *(_QWORD *)(*v1 + 4904);
        if (v36)
        {
          v52[6] = MEMORY[0x1E0C809B0];
          v52[7] = 0x40000000;
          v52[8] = __mergeIndexDataTrampoline_block_invoke;
          v52[9] = &__block_descriptor_tmp_52_5527;
          v52[10] = v1;
          v52[11] = v33;
          dumpDirectoryStore(v36);
        }
        if (_os_feature_enabled_impl())
        {
          v37 = *(_QWORD *)(*v1 + 4896);
          if (v37)
          {
            v38 = v1[4];
            v39 = *((unsigned __int8 *)v1 + 29);
            v40 = (_DWORD *)(*v1 + 15152);
            v52[0] = MEMORY[0x1E0C809B0];
            v52[1] = 0x40000000;
            v52[2] = __mergeIndexDataTrampoline_block_invoke_2;
            v52[3] = &__block_descriptor_tmp_57_5528;
            v52[4] = v1;
            v52[5] = v33;
            dumpVectorIndex(v37, v39, v40, v38, (uint64_t)v52);
          }
        }
        v59 = 1;
        v41 = *(_QWORD *)&threadData[18 * v55 + 2];
        v42 = v54;
        v43 = v41 + 320 * v54;
        *(_DWORD *)(v43 + 312) = v25;
        v44 = *(void (**)(_QWORD))(v43 + 232);
        if (v44)
          v44(*(_QWORD *)(v41 + 320 * v42 + 288));
        dropThreadId(v55, 0, v51);
      }
      if (!v59)
        *(_DWORD *)(v1[1] + 245776) = 1;
      v45 = *(_QWORD *)&threadData[18 * v62 + 2];
      v46 = v61;
      v47 = v45 + 320 * v61;
      *(_DWORD *)(v47 + 312) = v10;
      v48 = *(void (**)(_QWORD))(v47 + 232);
      if (v48)
        v48(*(_QWORD *)(v45 + 320 * v46 + 288));
      dropThreadId(v62, 0, v4);
    }
  }
  else
  {
    v15 = *__error();
    v16 = _SILogForLogForCategory(0);
    v17 = 2 * (gSILogLevels[0] < 4);
    if (os_log_type_enabled(v16, v17))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1B8270000, v16, v17, "Skipping because index is shut down", buf, 2u);
    }
    *__error() = v15;
  }
  pthread_mutex_lock((pthread_mutex_t *)(v1[1] + 245784));
  v49 = v1[1];
  *(_DWORD *)(v49 + 245772) = 1;
  pthread_cond_signal((pthread_cond_t *)(v49 + 245896));
  pthread_mutex_unlock((pthread_mutex_t *)(v1[1] + 245784));
  return 0;
}

uint64_t TermItem_compare(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v5;
  int v6;
  int v7;
  int v8;
  uint64_t result;
  int v10;
  const char *v11;
  uint64_t v12;
  const char *v13;
  int v14;
  uint64_t v15;
  size_t v16;
  unint64_t v17;
  unsigned int v18;
  unint64_t v19;
  unsigned int v20;
  int v21;
  unint64_t v22;
  uint64_t v23;
  int64_t *v24;
  int64_t *v25;
  BOOL v26;
  int64_t v27;
  int64_t v28;
  int64_t v29;
  int64_t v30;
  unint64_t v31;
  unint64_t v32;
  int v34;
  char *v35;
  char *v36;
  const char *v37;
  uint64_t v38;
  unsigned int v39;

  v2 = *(_QWORD *)a1;
  if (*(_QWORD *)a2 == -1)
  {
    if (v2 == -1)
      return 0;
    else
      return -1;
  }
  else if (v2 == -1)
  {
    return 1;
  }
  else
  {
    v5 = *(_DWORD *)(a2 + 52);
    v6 = *(_DWORD *)(a1 + 52) - v5;
    if (v6)
    {
      return v6;
    }
    else
    {
      switch(v5)
      {
        case 0:
          v11 = *(const char **)(a1 + 24);
          v12 = *(_DWORD *)(a1 + 16) & 0x7FFFFFFF;
          v13 = *(const char **)(a2 + 24);
          v14 = *(_DWORD *)(a2 + 16);
          v15 = v14 & 0x7FFFFFFF;
          if (v12 >= (v14 & 0x7FFFFFFFu))
            v16 = v15;
          else
            v16 = v12;
          LODWORD(result) = strncmp(v11, v13, v16);
          if ((_DWORD)result)
            result = (int)result;
          else
            result = v12 - v15;
          if (!result)
          {
            result = v12 - v15;
            if (v12 == v15)
              return *(_QWORD *)(a2 + 56) - *(_QWORD *)(a1 + 56);
          }
          return result;
        case 1:
          v17 = *(unsigned int *)(a1 + 16);
          v18 = (v17 >> 3) & 0xFFFFFFF;
          v19 = *(unsigned int *)(a2 + 16);
          v20 = (v19 >> 3) & 0xFFFFFFF;
          v21 = v18 - v20;
          if ((int)v18 >= (int)v20)
            v22 = v20;
          else
            v22 = v18;
          if (!(_DWORD)v22)
            goto LABEL_46;
          v39 = v18 - v20;
          v23 = 0;
          v24 = (int64_t *)(*(_QWORD *)(a2 + 24) + 8 * ((v19 >> 3) & 0xFFFFFFF) - 8);
          v25 = (int64_t *)(*(_QWORD *)(a1 + 24) + 8 * ((v17 >> 3) & 0xFFFFFFF) - 8);
          v26 = 1;
          break;
        case 2:
        case 3:
        case 4:
          v7 = *(_DWORD *)(a1 + 16);
          v8 = *(_DWORD *)(a2 + 16);
          if (v7 < 0)
          {
            if ((v8 & 0x80000000) == 0)
              return -1;
          }
          else if (v8 < 0)
          {
            return 1;
          }
          v10 = (v7 & 0x7FFFFFFF) - (v8 & 0x7FFFFFFF);
          if (v10)
            return v10;
          result = TermItem_IVF_compare(a1, a2);
          if (result)
            return result;
          return *(_QWORD *)(a2 + 56) - *(_QWORD *)(a1 + 56);
        default:
          v35 = __si_assert_copy_extra_5354(0, -1);
          v36 = v35;
          v37 = "";
          if (v35)
            v37 = v35;
          __message_assert("%s:%u: failed assertion '%s' %s ", "CIMerging.c", 197, "0", v37);
          free(v36);
          if (__valid_fs(-1))
            v38 = 2989;
          else
            v38 = 3072;
          *(_DWORD *)v38 = -559038737;
          abort();
      }
      do
      {
        v28 = *v25--;
        v27 = v28;
        v30 = *v24--;
        v29 = v30;
        if (v27 != v30)
        {
          v31 = hash64(v27);
          v32 = hash64(v29);
          if (v31 > v32)
            break;
          if (v27 < v29 || v31 < v32)
          {
            v34 = -1;
            goto LABEL_43;
          }
          if (v27 > v29)
            break;
        }
        v26 = ++v23 < v22;
      }
      while (v22 != v23);
      v34 = 1;
LABEL_43:
      if (v26)
        v21 = v34;
      else
        v21 = v39;
LABEL_46:
      if (v21)
        return v21;
      else
        return *(_QWORD *)(a2 + 56) - *(_QWORD *)(a1 + 56);
    }
  }
}

uint64_t getItem(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, _DWORD *a5)
{
  unsigned int *v8;
  pthread_mutex_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t result;
  uint64_t v14;
  __int128 v15;
  size_t v16;
  char *v17;
  char *v18;
  const char *v19;
  size_t v20;
  uint64_t v21;
  char *v22;
  char *v23;
  const char *v24;
  uint64_t v25;
  char *v26;
  timeval v29;
  timespec v30;

  v8 = (unsigned int *)(a2 + 245760);
  v9 = (pthread_mutex_t *)(a2 + 245784);
  pthread_mutex_lock((pthread_mutex_t *)(a2 + 245784));
  v11 = *v8;
  v10 = v8[1];
  while (1)
  {
    if ((_DWORD)v11 == (_DWORD)v10)
    {
      do
      {
        v12 = v10;
        if (v8[3])
          break;
        v12 = v10;
        if (*a5)
          break;
        *(_QWORD *)v8 = 0;
        v8[2] = 0;
        pthread_cond_signal((pthread_cond_t *)(a2 + 245848));
        v30.tv_sec = 0;
        v30.tv_nsec = 0;
        v29.tv_sec = 0;
        *(_QWORD *)&v29.tv_usec = 0;
        gettimeofday(&v29, 0);
        v30.tv_sec = v29.tv_sec;
        v30.tv_nsec = 1000 * v29.tv_usec + 500000000;
        if (v29.tv_usec >= 500000)
        {
          v30.tv_sec = v29.tv_sec + 1;
          v30.tv_nsec = 1000 * v29.tv_usec - 500000000;
        }
        pthread_cond_timedwait((pthread_cond_t *)(a2 + 245896), v9, &v30);
        v10 = *v8;
        v12 = v8[1];
      }
      while ((_DWORD)v10 == (_DWORD)v12);
    }
    else
    {
      v12 = v10;
      v10 = v11;
    }
    v11 = v10;
    v10 = v12;
    if (v8[4])
    {
      v26 = (char *)fd_create_protected(*(_DWORD *)(a3 + 56), "indexState", 0, 3u);
      _fd_unlink_with_origin((uint64_t)v26, 0);
      fd_release(v26);
      if (v8[4])
      {
        v22 = __si_assert_copy_extra_5354(0, *(_DWORD *)(a3 + 56));
        v23 = v22;
        v24 = "";
        if (v22)
          v24 = v22;
        __message_assert("%s:%u: failed assertion '%s' %s corrupt ro index need to rebuild %s", "CIMerging.c", 562, "!buffers->badIndex", v24, (const char *)(a3 + 15168));
        free(v23);
        if (__valid_fs(*(_DWORD *)(a3 + 56)))
          v25 = 2989;
        else
          v25 = 3072;
        *(_DWORD *)v25 = -559038737;
        abort();
      }
      v11 = *v8;
      v10 = v8[1];
    }
    if (v11 < v10)
      break;
    if (v8[3] || *a5)
    {
      result = pthread_mutex_unlock(v9);
      *(_QWORD *)a1 = -1;
      *(_OWORD *)(a1 + 8) = 0u;
      *(_OWORD *)(a1 + 24) = 0u;
      *(_OWORD *)(a1 + 40) = 0u;
      return result;
    }
  }
  v14 = a2 + 56 * (v11 & 0x7FF);
  v15 = *(_OWORD *)(v14 + 16);
  *(_OWORD *)a1 = *(_OWORD *)v14;
  *(_OWORD *)(a1 + 16) = v15;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(v14 + 32);
  *(_QWORD *)(a1 + 48) = *(_QWORD *)(v14 + 48);
  v16 = *(_DWORD *)(a1 + 16) & 0x7FFFFFFF;
  memcpy(a4, *(const void **)(a1 + 24), v16);
  *(_QWORD *)(a1 + 24) = a4;
  ++*v8;
  if (!*(_DWORD *)(a1 + 52))
  {
    *((_BYTE *)a4 + v16) = 0;
    if (strlen((const char *)a4) > v16)
    {
      v17 = __si_assert_copy_extra_5354(0, *(_DWORD *)(a3 + 56));
      v18 = v17;
      if (v17)
        v19 = v17;
      else
        v19 = "";
      v20 = strlen((const char *)a4);
      __message_assert("%s:%u: failed assertion '%s' %s Expected %ld to be leq %u", "CIMerging.c", 579, "strlen((char*)strbuf) <= workItem.termLen", v19, v20, v16);
      free(v18);
      if (__valid_fs(*(_DWORD *)(a3 + 56)))
        v21 = 2989;
      else
        v21 = 3072;
      *(_DWORD *)v21 = -559038737;
      abort();
    }
  }
  return pthread_mutex_unlock(v9);
}

uint64_t TermItem_IVF_compare(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  unsigned int v3;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;

  v2 = *(_DWORD *)(a1 + 32);
  v3 = *(_DWORD *)(a2 + 32);
  if (v2 < v3)
    return -1;
  if (v2 > v3)
    return 1;
  v5 = *(unsigned __int16 *)(a1 + 48);
  v6 = *(unsigned __int16 *)(a2 + 48);
  if (v5 < v6)
    return -1;
  if (v5 > v6)
    return 1;
  if (!*(_BYTE *)(a1 + 50))
  {
    if (!*(_BYTE *)(a2 + 50))
      goto LABEL_11;
    return -1;
  }
  if (!*(_BYTE *)(a2 + 50))
    return 1;
LABEL_11:
  v7 = *(_DWORD *)(a1 + 40);
  v8 = *(_DWORD *)(a2 + 40);
  if (v7 < v8)
    return -1;
  if (v7 > v8)
    return 1;
  v9 = *(_DWORD *)(a1 + 36);
  v10 = *(_DWORD *)(a2 + 36);
  if (v9 < v10)
    return -1;
  if (v9 > v10)
    return 1;
  return memcmp(*(const void **)(a1 + 24), *(const void **)(a2 + 24), *(_DWORD *)(a1 + 16) & 0x7FFFFFFF);
}

uint64_t non_compact_callback(uint64_t a1, const void *a2, unsigned int a3, uint64_t a4, uint64_t a5)
{
  unsigned int v8;
  uint64_t *v9;
  uint64_t (*v10)(_QWORD, const void *, uint64_t);
  uint64_t result;
  unint64_t v12;
  uint64_t v13;
  uint64_t *v14;

  v8 = a1;
  v9 = (uint64_t *)(a5 + 245944);
  v10 = *(uint64_t (**)(_QWORD, const void *, uint64_t))(a5 + 245960);
  if (!v10 || (result = v10(*(_QWORD *)(a5 + 245968), a2, a1), (result & 1) == 0))
  {
    v12 = 8 * a3;
    v13 = *(_QWORD *)storageResolvePtr(*v9, v12, 8uLL, 1);
    v14 = (uint64_t *)storageResolvePtr(v9[1], v12, 8uLL, 1);
    return waitForReaderWithPropertyId(a5, a2, v8, 0, 0, v13, *v14, 0, 3.4028e38, 0, 0, -1, 0);
  }
  return result;
}

uint64_t compact_callback(uint64_t a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unsigned int v9;
  uint64_t (*v10)(_QWORD, unsigned __int8 *, uint64_t);
  uint64_t result;
  unsigned int v12;
  int v13;
  unsigned __int8 *v14;
  unsigned __int8 *v15;
  int v16;
  char *v17;
  int v18;
  int v20;
  int v21;
  int v22;
  unsigned int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  char *v30;
  char *v31;
  const char *v32;
  uint64_t v33;
  char *v34;
  char *v35;
  const char *v36;
  uint64_t v37;

  v9 = a1;
  v10 = *(uint64_t (**)(_QWORD, unsigned __int8 *, uint64_t))(a5 + 245960);
  if (!v10 || (result = v10(*(_QWORD *)(a5 + 245968), a2, a1), (result & 1) == 0))
  {
    if (!a4 || v9 < 2)
      return waitForReaderWithPropertyId(a5, a2, v9, 0, 0, a3, a4, 0, 3.4028e38, 0, 0, -1, 0);
    if (*a2 > 3u)
    {
      v14 = &a2[v9];
      v15 = v14 - 6;
      if (v9 < 6)
        v15 = a2 + 1;
      v16 = (char)*(v14 - 1);
      if (v16 < 0)
        return waitForReaderWithPropertyId(a5, a2, v9, 0, 0, a3, a4, 0, 3.4028e38, 0, 0, -1, 0);
      v18 = *(v14 - 2);
      v17 = (char *)(v14 - 2);
      if (v18 == 1 && v16 == 3)
        --v17;
      if (v17 <= (char *)v15)
      {
LABEL_21:
        v20 = *v17;
      }
      else
      {
        while (*v17 < 0)
        {
          if (--v17 <= (char *)v15)
          {
            v17 = (char *)v15;
            goto LABEL_21;
          }
        }
        v20 = *v17;
      }
      if (v20 != 1)
        return waitForReaderWithPropertyId(a5, a2, v9, 0, 0, a3, a4, 0, 3.4028e38, 0, 0, -1, 0);
      v12 = v17[1];
      if ((v17[1] & 0x80000000) == 0)
        goto LABEL_41;
      v21 = v17[2];
      if ((v17[2] & 0x80000000) == 0)
      {
        v12 = v12 & 0x7F | (v21 << 7);
        goto LABEL_41;
      }
      v25 = v17[3];
      if (v17[3] < 0)
      {
        v27 = v17[4];
        if (v17[4] < 0)
        {
          v29 = v17[5];
          if (v29 < 0)
          {
            v34 = __si_assert_copy_extra_5354(0, -1);
            v35 = v34;
            v36 = "";
            if (v34)
              v36 = v34;
            __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t", "VIntUtils.h", 341, "(b4 & 0x80) == 0", v36);
            free(v35);
            if (__valid_fs(-1))
              v37 = 2989;
            else
              v37 = 3072;
            *(_DWORD *)v37 = -559038737;
            abort();
          }
          v28 = ((v27 & 0x7F) << 21) | (v29 << 28) | ((v25 & 0x7F) << 14);
        }
        else
        {
          v28 = ((v25 & 0x7F) << 14) | (v27 << 21);
        }
        v23 = v28 & 0xFFFFC07F | ((v21 & 0x7F) << 7);
      }
      else
      {
        v23 = ((v21 & 0x7F) << 7) | (v25 << 14);
      }
    }
    else
    {
      v12 = a2[1];
      if (((char)a2[1] & 0x80000000) == 0)
        goto LABEL_41;
      v13 = a2[2];
      if (((char)a2[2] & 0x80000000) == 0)
      {
        v12 = v12 & 0x7F | (v13 << 7);
        goto LABEL_41;
      }
      v22 = a2[3];
      if ((char)a2[3] < 0)
      {
        v24 = a2[4];
        if ((char)a2[4] < 0)
        {
          v26 = (char)a2[5];
          if (v26 < 0)
          {
            v30 = __si_assert_copy_extra_5354(0, -1);
            v31 = v30;
            v32 = "";
            if (v30)
              v32 = v30;
            __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t", "VIntUtils.h", 341, "(b4 & 0x80) == 0", v32);
            free(v31);
            if (__valid_fs(-1))
              v33 = 2989;
            else
              v33 = 3072;
            *(_DWORD *)v33 = -559038737;
            abort();
          }
          v12 = ((v24 & 0x7F) << 21) | (v26 << 28) | ((v22 & 0x7F) << 14) | ((v13 & 0x7F) << 7) | v12 & 0x7F;
        }
        else
        {
          v12 = ((v22 & 0x7F) << 14) | (v24 << 21) | ((v13 & 0x7F) << 7) | v12 & 0x7F;
        }
        goto LABEL_41;
      }
      v23 = ((v13 & 0x7F) << 7) | (v22 << 14);
    }
    v12 = v23 & 0xFFFFFF80 | v12 & 0x7F;
LABEL_41:
    if (v12)
      a4 = 0;
    return waitForReaderWithPropertyId(a5, a2, v9, 0, 0, a3, a4, 0, 3.4028e38, 0, 0, -1, 0);
  }
  return result;
}

BOOL __mergeIndexDataTrampoline_block_invoke(uint64_t a1, int a2, const void *a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v4 = a4;
  v8 = *(_QWORD *)(a1 + 32);
  v7 = *(_QWORD *)(a1 + 40);
  v9 = *(_QWORD *)(v8 + 8);
  if (v7)
    v4 = *(_QWORD *)storageResolvePtr(v7, 8 * a4, 8uLL, 1);
  waitForReaderWithPropertyId(v9, a3, 8 * a2, 1, 0, v4, 0, 0, 3.4028e38, 0, 0, -1, 0);
  return **(_DWORD **)(v9 + 245976) != 0;
}

BOOL __mergeIndexDataTrampoline_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned __int8 a9, int a10)
{
  uint64_t v10;
  int v11;
  __int16 v12;
  int v13;
  const void *v14;
  unsigned int v15;
  unsigned int v16;
  unint64_t v17;
  float v18;
  float v19;
  off_t v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  unint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  _QWORD *v29;
  unint64_t vint;
  size_t vint32;
  char *v32;
  char *v33;
  size_t v34;
  unint64_t v35;
  FILE *v36;
  BOOL v37;
  int v38;
  CFAbsoluteTime Current;
  double v40;
  char v41;
  unsigned int v42;
  unsigned int v43;
  const void *v44;
  uint64_t v45;
  int v46;
  int v47;
  int v48;
  unsigned int v50;
  unsigned int v51;
  int v52;
  __int16 v53;
  const void *v54;
  off_t v55;
  int v56;
  uint64_t v57;
  _QWORD v58[2];
  uint64_t (*v59)(uint64_t, uint64_t, uint64_t, uint64_t);
  void *v60;
  uint64_t *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  double *v65;
  uint64_t v66;
  uint64_t v67;
  int v68;
  __int128 v69;
  char *v70;
  size_t v71;
  uint64_t v72;
  char v73;
  int __fd;
  off_t __offseta;
  _BYTE v76[4096];
  void *__src;
  _BYTE *v78;
  int v79;
  uint64_t v80;

  v10 = MEMORY[0x1E0C80A78](a1);
  v19 = v18;
  v20 = v17;
  v21 = v10;
  v80 = *MEMORY[0x1E0C80C00];
  v23 = *(_QWORD **)(v10 + 32);
  v22 = *(_QWORD *)(v10 + 40);
  v24 = v23[1];
  if (v22)
  {
    v25 = *(unsigned int *)(v22 + 4408);
    if (v25 <= v17)
    {
      si_analytics_log_2520("Invalid termId from vector index %llu (count:%d)", v17, v25);
      v46 = **(_DWORD **)(v24 + 245976);
      return v46 != 0;
    }
    v50 = v15;
    v51 = v16;
    v52 = v13;
    v53 = v12;
    v54 = v14;
    v56 = v11;
    v57 = v24;
    v20 = *(_QWORD *)storageResolvePtr(v22, 8 * v17, 8uLL, 1);
    v23 = *(_QWORD **)(v21 + 32);
  }
  else
  {
    v50 = v15;
    v51 = v16;
    v52 = v13;
    v53 = v12;
    v54 = v14;
    v56 = v11;
    v57 = v23[1];
  }
  v64 = 0;
  v65 = (double *)&v64;
  v66 = 0x2000000000;
  v67 = 0;
  v63 = 0;
  v26 = _fd_acquire_fd(*(_QWORD *)(*v23 + 9400), &v63);
  v27 = *(_QWORD *)(v21 + 32);
  v28 = *(_QWORD *)(*(_QWORD *)v27 + 72);
  v58[0] = MEMORY[0x1E0C809B0];
  v58[1] = 0x40000000;
  v59 = __mergeIndexDataTrampoline_block_invoke_3;
  v60 = &unk_1E6E305F0;
  v61 = &v64;
  v62 = v27;
  v29 = malloc_type_malloc(0x20uLL, 0x1080040A9F9A45FuLL);
  *(_DWORD *)v29 = v26;
  v29[1] = v28;
  v29[2] = 0;
  v29[3] = v58;
  v73 = 0;
  v55 = v20;
  while (1)
  {
    bzero(&__fd, 0x1028uLL);
    __fd = v26;
    v78 = v76;
    __offseta = v20;
    __src = v76;
    file_scanner_read((ssize_t)&__fd);
    vint = file_scanner_read_vint((ssize_t)&__fd);
    if ((vint & 1) == 0)
      break;
    vint32 = file_scanner_read_vint32((ssize_t)&__fd);
    v32 = (char *)malloc_type_malloc(vint32, 0x3FCF9B56uLL);
    v33 = v32;
    if (v79)
      goto LABEL_22;
    v34 = vint32;
    v35 = v78 - (_BYTE *)__src;
    if (v78 != __src)
    {
      v34 = vint32 - v35;
      if (vint32 <= v35)
      {
        memcpy(v32, __src, vint32);
        __src = (char *)__src + vint32;
        goto LABEL_21;
      }
      memcpy(v32, __src, v78 - (_BYTE *)__src);
      __src = (char *)__src + v35;
    }
    if (pread(__fd, &v33[v35], v34, __offseta) == v34)
    {
      v78 = v76;
      __offseta += v34 + v35;
      __src = v76;
      v79 = 0;
      file_scanner_read((ssize_t)&__fd);
    }
    else
    {
      v36 = (FILE *)*MEMORY[0x1E0C80C10];
      v79 = *__error();
      fprintf(v36, "\npread error(%d) offset: 0x%llx\n", v79, __offseta);
    }
LABEL_21:
    if (!v79)
    {
      v68 = 0;
      v69 = 0u;
      v70 = v33;
      v71 = vint32;
      v72 = 0;
      if (v33)
        v37 = (_DWORD)vint32 == 0;
      else
        v37 = 1;
      v38 = v37;
      HIDWORD(v72) = v38;
      while (PostingChunkEnumeratorNextDocID((unint64_t *)&v69, &v68))
      {
        ((void (*)(_QWORD *))v59)(v58);
        if (v73)
          goto LABEL_33;
      }
    }
LABEL_22:
    free(v33);
    if (vint < 2)
      goto LABEL_33;
LABEL_23:
    v20 = vint >> 1;
  }
  if ((file_scanner_read_vint((ssize_t)&__fd) & 1) == 0 && !file_scanner_read_vint32((ssize_t)&__fd))
    file_scanner_read_vint32((ssize_t)&__fd);
  ((void (*)(_QWORD *))v59)(v58);
  if (vint >= 2 && !v73)
    goto LABEL_23;
LABEL_33:
  free(v29);
  Current = CFAbsoluteTimeGetCurrent();
  v40 = v65[3];
  v41 = Current - v40 > 31104000.0 || v40 == 0.0;
  _fd_release_fd(*(_DWORD **)(**(_QWORD **)(v21 + 32) + 9400), v26, 0, v63);
  v42 = -1;
  if (v50 > 2)
  {
    v44 = v54;
    v45 = v55;
    v43 = v51;
  }
  else
  {
    v43 = v51;
    v44 = v54;
    v45 = v55;
    if (v51 <= 2)
      v42 = vector_dimension_vec_sizes_10743[v50] * vector_size_elem_sizes_10742[v51];
  }
  if (v43 == 1)
    v47 = 3;
  else
    v47 = 4;
  if (v43 == 2)
    v48 = 2;
  else
    v48 = v47;
  waitForReaderWithPropertyId(v57, v44, v42, v48, a9, v45, 0, v56, v19, v53, v52, a10, v41);
  v46 = **(_DWORD **)(v57 + 245976);
  _Block_object_dispose(&v64, 8);
  return v46 != 0;
}

uint64_t __mergeIndexDataTrampoline_block_invoke_3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;
  uint64_t v6;

  result = _CIGetRankingSecondsForDocId(**(_QWORD **)(a1 + 40), a4);
  v6 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(double *)(v6 + 24) < (double)result)
    *(double *)(v6 + 24) = (double)result;
  return result;
}

uint64_t waitForReaderWithPropertyId(uint64_t a1, const void *a2, unsigned int a3, int a4, int a5, uint64_t a6, uint64_t a7, int a8, float a9, __int16 a10, int a11, int a12, char a13)
{
  unsigned int *v16;
  pthread_mutex_t *v17;
  unsigned int i;
  unsigned int v19;
  unsigned int v20;
  _DWORD *v21;
  uint64_t v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  void *v26;
  timeval v34;
  timespec v35;

  v16 = (unsigned int *)(a1 + 245760);
  v17 = (pthread_mutex_t *)(a1 + 245784);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 245784));
  if (((v16[2] & 0x1FFFF) + a3) >> 17)
  {
    v19 = *v16;
    for (i = v16[1]; i > *v16 && !**((_DWORD **)v16 + 27); i = v16[1])
    {
      pthread_cond_signal((pthread_cond_t *)(a1 + 245896));
      v35.tv_sec = 0;
      v35.tv_nsec = 0;
      v34.tv_sec = 0;
      *(_QWORD *)&v34.tv_usec = 0;
      gettimeofday(&v34, 0);
      v35.tv_sec = v34.tv_sec;
      v35.tv_nsec = 1000 * v34.tv_usec + 500000000;
      if (v34.tv_usec > 499999)
      {
        v35.tv_sec = v34.tv_sec + 1;
        v35.tv_nsec = 1000 * v34.tv_usec - 500000000;
      }
      pthread_cond_timedwait((pthread_cond_t *)(a1 + 245848), v17, &v35);
      v19 = *v16;
    }
  }
  else
  {
    v19 = *v16;
    i = v16[1];
  }
  v20 = v19 + 2048;
  v21 = (_DWORD *)*((_QWORD *)v16 + 27);
  if (i >= v20)
  {
    if (*v21)
      return pthread_mutex_unlock(v17);
    while (1)
    {
      pthread_cond_signal((pthread_cond_t *)(a1 + 245896));
      v35.tv_sec = 0;
      v35.tv_nsec = 0;
      v34.tv_sec = 0;
      *(_QWORD *)&v34.tv_usec = 0;
      gettimeofday(&v34, 0);
      v35.tv_sec = v34.tv_sec;
      v35.tv_nsec = 1000 * v34.tv_usec + 500000000;
      if (v34.tv_usec > 499999)
      {
        v35.tv_sec = v34.tv_sec + 1;
        v35.tv_nsec = 1000 * v34.tv_usec - 500000000;
      }
      pthread_cond_timedwait((pthread_cond_t *)(a1 + 245848), v17, &v35);
      i = v16[1];
      v21 = (_DWORD *)*((_QWORD *)v16 + 27);
      if (i < *v16 + 2048)
        break;
      if (*v21)
        return pthread_mutex_unlock(v17);
    }
  }
  if (!*v21)
  {
    v22 = a1 + 56 * (i & 0x7FF);
    *(_QWORD *)v22 = a6;
    *(_QWORD *)(v22 + 8) = a7;
    *(_DWORD *)(v22 + 52) = a4;
    if (a5)
      v23 = 0x80000000;
    else
      v23 = 0;
    *(_DWORD *)(v22 + 16) = v23 & 0x80000000 | a3 & 0x7FFFFFFF;
    *(_DWORD *)(v22 + 32) = a8;
    *(_DWORD *)(v22 + 36) = a11;
    *(_DWORD *)(v22 + 40) = a12;
    *(float *)(v22 + 44) = a9;
    *(_WORD *)(v22 + 48) = a10;
    *(_BYTE *)(v22 + 50) = a13;
    v24 = v16[2];
    v25 = (v24 & 0x1FFFF) + a3;
    if (v25 >= 0x20000)
      v26 = (void *)(a1 + 114688);
    else
      v26 = (void *)(a1 + 114688 + (*(_QWORD *)&v24 & 0x1FFFFLL));
    if (v25 >= 0x20000)
      v24 = 0;
    *(_QWORD *)(v22 + 24) = v26;
    v16[2] = v24 + a3;
    if (a2)
    {
      memcpy(v26, a2, a3);
      i = v16[1];
    }
    v16[1] = i + 1;
  }
  return pthread_mutex_unlock(v17);
}

uint64_t _db_write_lock(uint64_t a1)
{
  unsigned int v2;
  unint64_t v3;
  unsigned int v4;
  uint64_t v5;

  HIDWORD(v3) = qos_class_self() - 9;
  LODWORD(v3) = HIDWORD(v3);
  v2 = v3 >> 2;
  if (v2 > 6)
    v4 = 0;
  else
    v4 = dword_1B8630ED0[v2];
  v5 = pthread_mutex_lock((pthread_mutex_t *)a1);
  if (db_rwlock_writer_excluded(a1, v4))
    db_rwlock_wait(a1, v4, 2);
  else
    *(_QWORD *)(a1 + 184) = pthread_self();
  pthread_mutex_unlock((pthread_mutex_t *)a1);
  return v5;
}

BOOL db_rwlock_writer_excluded(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;

  if (*(_QWORD *)(a1 + 184) || *(_DWORD *)(a1 + 196) || *(_BYTE *)(a1 + 212))
    return 1;
  if (a2 > 5)
    return 0;
  if (*(_QWORD *)(a1 + 16 * a2 + 64))
    return 1;
  v3 = a2 - 1;
  v4 = (uint64_t *)(a1 + 16 * a2 + 80);
  while (v3 != 4)
  {
    v5 = *v4;
    v4 += 2;
    ++v3;
    if (v5)
      return v3 < 5;
  }
  v3 = 5;
  return v3 < 5;
}

uint64_t db_writer_yield_lock(uint64_t a1)
{
  unsigned int v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  HIDWORD(v3) = qos_class_self() - 9;
  LODWORD(v3) = HIDWORD(v3);
  v2 = v3 >> 2;
  if (v2 > 6)
    v4 = 0;
  else
    v4 = dword_1B8630ED0[v2];
  if (!*(_DWORD *)(a1 + 208) || pthread_mutex_lock((pthread_mutex_t *)a1))
    return 0;
  v5 = 16 * v4 + 64;
  while (1)
  {
    v6 = *(_QWORD *)(a1 + v5);
    if (v6)
    {
      if (*(_DWORD *)(v6 + 48) == 4)
        break;
    }
    v5 += 16;
    if (v5 == 160)
    {
      pthread_mutex_unlock((pthread_mutex_t *)a1);
      return 0;
    }
  }
  v7 = 1;
  *(_BYTE *)(a1 + 212) = 1;
  db_rwlock_wakeup(a1, 1, 1);
  pthread_mutex_unlock((pthread_mutex_t *)a1);
  db_upgrade_lock(a1);
  return v7;
}

CFTypeRef CopyAppleLanguages()
{
  CFTypeRef result;

  if (CopyAppleLanguages_once != -1)
    dispatch_once(&CopyAppleLanguages_once, &__block_literal_global_5590);
  result = (CFTypeRef)CopyAppleLanguages_sAppleLanguages;
  if (CopyAppleLanguages_sAppleLanguages)
    return CFRetain((CFTypeRef)CopyAppleLanguages_sAppleLanguages);
  return result;
}

void _MDSimpleQuerySetWidcardAttributes(uint64_t a1, CFTypeRef cf)
{
  const void *v4;

  v4 = *(const void **)(a1 + 40);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(a1 + 40) = 0;
  }
  if (cf)
    *(_QWORD *)(a1 + 40) = CFRetain(cf);
}

_QWORD *_MDCreateSimpleQueryEvaluatorWithBlock(const __CFString *a1, const void *a2)
{
  _QWORD *EvaluatorWithOptionsAndLanguages;

  EvaluatorWithOptionsAndLanguages = _MDCreateSimpleQueryEvaluatorWithOptionsAndLanguages(a1, 0, 0, 0);
  if (EvaluatorWithOptionsAndLanguages)
    EvaluatorWithOptionsAndLanguages[2] = _Block_copy(a2);
  return EvaluatorWithOptionsAndLanguages;
}

_QWORD *_MDCreateSimpleQueryEvaluatorWithOptionsAndLanguages(const __CFString *a1, uint64_t a2, char a3, const __CFArray *a4)
{
  const char *CStringPtr;
  char *v9;
  char *v10;
  char *v12;
  CFIndex Length;
  CFIndex MaximumSizeForEncoding;
  CFIndex v15;
  double Current;
  size_t v17;
  size_t v18;
  size_t v19;
  size_t tree;
  char *v21;
  const __CFString *v22;
  _QWORD *v23;
  CFIndex v24;
  CFIndex v25;
  char *v26;
  _QWORD *v27;
  unsigned int v28;
  char *v29;
  _QWORD *v30;
  const __CFArray *v31;
  CFIndex Count;
  _QWORD *v33;
  CFIndex i;
  const __CFString *ValueAtIndex;
  CFIndex v36;
  CFIndex v37;
  char *v38;
  _QWORD *v39;
  _QWORD *v40;
  _QWORD *query_node_with_ann;
  void *v43;
  _QWORD v44[130];

  v44[128] = *MEMORY[0x1E0C80C00];
  if (query_zone_init_onceToken != -1)
    dispatch_once(&query_zone_init_onceToken, &__block_literal_global_3813);
  bzero(v44, 0x400uLL);
  CStringPtr = CFStringGetCStringPtr(a1, 0x8000100u);
  if (CStringPtr)
  {
    v9 = (char *)CStringPtr;
    v10 = (char *)v44;
    goto LABEL_5;
  }
  Length = CFStringGetLength(a1);
  MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
  v15 = MaximumSizeForEncoding + 1;
  if (MaximumSizeForEncoding < 1024)
    v9 = (char *)v44;
  else
    v9 = (char *)malloc_type_malloc(MaximumSizeForEncoding + 1, 0xC21C4E46uLL);
  if (CFStringGetCString(a1, v9, v15, 0x8000100u))
  {
    v10 = v9;
    if (!v9)
      goto LABEL_30;
LABEL_5:
    if ((*v9 - 35) > 0x1D || ((1 << (*v9 - 35)) & 0x20000003) == 0)
      v12 = v9;
    else
      v12 = v9 + 1;
    query_node_with_ann = db_make_query_node_with_ann(v12, 0);
    if (!query_node_with_ann)
      goto LABEL_30;
    Current = CFAbsoluteTimeGetCurrent();
    if (db_sanitize_query_tree((uint64_t *)&query_node_with_ann, 0, 1, Current))
    {
      db_dump_query_node_with_prefix(0);
      v17 = strlen(v9);
      if (2 * v17)
        v18 = 2 * v17;
      else
        v18 = 64;
      v19 = malloc_good_size(v18);
      v43 = malloc_type_malloc(v19, 0x3992EE07uLL);
      tree = _db_render_query_tree((uint64_t)&query_node_with_ann);
      v21 = (char *)v43;
      if (tree)
      {
        db_free_query_node(query_node_with_ann);
        if (v21)
        {
          v22 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v21, 0x8000100u);
          free(v21);
          goto LABEL_31;
        }
LABEL_30:
        v22 = 0;
LABEL_31:
        v9 = v10;
        if (v10 == (char *)v44)
          goto LABEL_33;
        goto LABEL_32;
      }
      free(v43);
      v23 = query_node_with_ann;
    }
    else
    {
      v23 = query_node_with_ann;
    }
    db_free_query_node(v23);
    goto LABEL_30;
  }
  if (v9 == (char *)v44)
    return 0;
  v22 = 0;
LABEL_32:
  free(v9);
LABEL_33:
  if (!v22)
    return 0;
  v24 = CFStringGetLength(v22);
  v25 = CFStringGetMaximumSizeForEncoding(v24, 0x8000100u);
  v26 = (char *)malloc_type_malloc(v25 + 1, 0x100004077774924uLL);
  if (CFStringGetCString(v22, v26, v25, 0x8000100u))
  {
    v27 = malloc_type_calloc(0x60uLL, 1uLL, 0x1378CD6CuLL);
    if (v26)
    {
      v28 = *v26 - 35;
      v29 = v26;
      if (v28 <= 0x1D)
      {
        if (((1 << v28) & 0x20000003) != 0)
          v29 = v26 + 1;
        else
          v29 = v26;
      }
      v30 = db_make_query_node_with_ann(v29, 0);
    }
    else
    {
      v30 = 0;
    }
    *v27 = v30;
    v27[1] = a2;
    v27[4] = v26;
    v27[11] = 0;
    if ((a3 & 1) != 0)
      *((_BYTE *)v27 + 80) = 1;
    v31 = a4;
    if (a4 || (v31 = (const __CFArray *)CopyAppleLanguages()) != 0)
    {
      Count = CFArrayGetCount(v31);
      v33 = malloc_type_calloc(Count + 1, 8uLL, 0x10040436913F5uLL);
      if (Count < 1)
      {
        Count = 0;
      }
      else
      {
        for (i = 0; i != Count; ++i)
        {
          ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v31, i);
          v36 = CFStringGetLength(ValueAtIndex);
          v37 = CFStringGetMaximumSizeForEncoding(v36, 0x8000100u);
          v38 = (char *)malloc_type_malloc(v37 + 1, 0x100004077774924uLL);
          if (!CFStringGetCString(ValueAtIndex, v38, v37, 0x8000100u))
            *v38 = 0;
          v33[i] = v38;
        }
      }
      v33[Count] = 0;
      v27[3] = v33;
      if (v31 != a4)
        CFRelease(v31);
    }
    else
    {
      v39 = malloc_type_calloc(1uLL, 8uLL, 0x10040436913F5uLL);
      *v39 = 0;
      v27[3] = v39;
    }
    db_optimize_query_tree((_QWORD **)v27);
    v40 = (_QWORD *)*v27;
    v44[0] = MEMORY[0x1E0C809B0];
    v44[1] = 0x40000000;
    v44[2] = __db_query_tree_apply_block_block_invoke;
    v44[3] = &unk_1E6E377F8;
    v44[4] = &__block_literal_global_16_5603;
    db_query_tree_apply_block_with_meta(v40, (uint64_t)v44, 0);
  }
  else
  {
    free(v26);
    v27 = 0;
  }
  CFRelease(v22);
  return v27;
}

uint64_t ____walkNodes_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  const void *v4;
  const __CFDictionary *v5;
  CFMutableDictionaryRef v6;
  void *Value;
  CFDictionaryKeyCallBacks v10;

  if (a2)
  {
    v3 = *(_QWORD *)(a2 + 16);
    if (v3)
    {
      *(_QWORD *)(v3 + 32) |= 0x80uLL;
      *(_QWORD *)(v3 + 8) = __MDSimpleQueryCompareFunction;
      v4 = *(const void **)v3;
      if (*(_QWORD *)v3)
      {
        v5 = (const __CFDictionary *)CopyQueryField_sDict;
        if (!CopyQueryField_sDict)
        {
          memset(&v10, 0, 32);
          *(_OWORD *)&v10.equal = xmmword_1E6E307A0;
          v6 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, &v10, MEMORY[0x1E0C9B3A0]);
          while (!__ldaxr((unint64_t *)&CopyQueryField_sDict))
          {
            if (!__stlxr((unint64_t)v6, (unint64_t *)&CopyQueryField_sDict))
              goto LABEL_10;
          }
          __clrex();
          CFRelease(v6);
LABEL_10:
          v5 = (const __CFDictionary *)CopyQueryField_sDict;
        }
        Value = (void *)CFDictionaryGetValue(v5, v4);
        if (!Value)
          Value = (void *)CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const char *)v4, 0x8000100u);
        *(_QWORD *)(a2 + 32) = Value;
      }
    }
  }
  return a2;
}

uint64_t __MDSimpleQueryCompareFunction(uint64_t a1, uint64_t *a2, uint64_t a3, CFTypeRef *a4, uint64_t a5, uint64_t a6)
{
  CFTypeRef v10;
  const void *v11;
  int v12;
  uint64_t CompareFunctionSub;
  uint64_t (*v14)(uint64_t, uint64_t, CFTypeRef);
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  uint64_t (*v18)(uint64_t, uint64_t, CFTypeRef);
  uint64_t v19;
  uint64_t v20;
  const __CFArray *v21;
  const __CFArray *v22;
  CFTypeID v23;
  CFIndex Count;
  CFIndex v25;
  CFIndex v26;
  const void *v27;
  int v28;
  const __CFArray *v30;
  CFIndex v31;
  CFIndex v32;
  CFIndex i;
  const void *v34;
  uint64_t (*v35)(uint64_t, uint64_t, const void *);
  uint64_t v36;
  uint64_t v37;
  __CFString *v38;
  CFIndex v39;
  const void *ValueAtIndex;

  v10 = *a4;
  v11 = *(const void **)(a5 + 56);
  if (v11 && !CFEqual(v11, *a4) && !CFEqual(v10, CFSTR("*")))
    return 1;
  v12 = *(_DWORD *)(a3 + 24);
  if ((v12 - 11) <= 1)
  {
    CompareFunctionSub = v12 == 12;
    if (*(_DWORD *)(a3 + 40) == 2)
    {
      v14 = *(uint64_t (**)(uint64_t, uint64_t, CFTypeRef))(a5 + 8);
      if (v14)
      {
        v15 = *a2;
        v16 = a5;
      }
      else
      {
        v16 = *(_QWORD *)(a5 + 16);
        v15 = *a2;
        v14 = *(uint64_t (**)(uint64_t, uint64_t, CFTypeRef))(v16 + 16);
      }
      v22 = (const __CFArray *)v14(v16, v15, v10);
      v21 = v22;
      if (v22)
      {
        v23 = CFGetTypeID(v22);
        if (v23 == CFArrayGetTypeID())
        {
          Count = CFArrayGetCount(v21);
          if (Count)
          {
            v25 = Count;
            if (a6 && (*(_BYTE *)(a3 + 35) & 2) != 0)
            {
              if (Count < 1)
              {
                CompareFunctionSub = 0;
              }
              else
              {
                v39 = 0;
                CompareFunctionSub = 0;
                do
                {
                  ValueAtIndex = CFArrayGetValueAtIndex(v21, v39);
                  if (RangeMatch(a3, ValueAtIndex, v12 == 12))
                    CompareFunctionSub = db_eval_obj_qp_array_set_match_at_index(a6, a3, v39);
                  ++v39;
                }
                while (v25 != v39);
              }
            }
            else if (Count >= 1)
            {
              v26 = 0;
              while (1)
              {
                v27 = CFArrayGetValueAtIndex(v21, v26);
                v28 = RangeMatch(a3, v27, v12 == 12);
                if (v28 != (_DWORD)CompareFunctionSub)
                  break;
                if (v25 == ++v26)
                  goto LABEL_30;
              }
              CompareFunctionSub = v28 ^ 1u;
            }
          }
        }
        else
        {
          CompareFunctionSub = RangeMatch(a3, v21, v12 == 12);
        }
        goto LABEL_30;
      }
    }
    return CompareFunctionSub;
  }
  if (!*(_QWORD *)(a5 + 56))
  {
    if (*(_BYTE *)(a5 + 80))
    {
      v17 = *(const char **)a3;
    }
    else
    {
      if ((*(_BYTE *)(a3 + 33) & 4) != 0)
        return 0;
      v17 = *(const char **)a3;
      if (!strcmp(*(const char **)a3, "kMDItemTextContent") || !strncmp(v17, "_kMDItemOCRContent", 0x12uLL))
        return 0;
    }
    if (strcmp(v17, "*"))
      goto LABEL_12;
    v30 = *(const __CFArray **)(a5 + 40);
    if (v30)
    {
      v31 = CFArrayGetCount(v30);
      if (v31 >= 1)
      {
        v32 = v31;
        for (i = 0; i != v32; ++i)
        {
          v34 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a5 + 40), i);
          v35 = *(uint64_t (**)(uint64_t, uint64_t, const void *))(a5 + 8);
          if (v35)
          {
            v36 = *a2;
            v37 = a5;
          }
          else
          {
            v37 = *(_QWORD *)(a5 + 16);
            v36 = *a2;
            v35 = *(uint64_t (**)(uint64_t, uint64_t, const void *))(v37 + 16);
          }
          v38 = (__CFString *)v35(v37, v36, v34);
          CompareFunctionSub = __MDSimpleQueryCompareFunctionSub(a3, v38, (_QWORD *)a5, a6);
          if (v38)
            CFRelease(v38);
          if ((_DWORD)CompareFunctionSub)
            break;
        }
        return CompareFunctionSub;
      }
    }
    return 0;
  }
LABEL_12:
  v18 = *(uint64_t (**)(uint64_t, uint64_t, CFTypeRef))(a5 + 8);
  if (v18)
  {
    v19 = *a2;
    v20 = a5;
  }
  else
  {
    v20 = *(_QWORD *)(a5 + 16);
    v19 = *a2;
    v18 = *(uint64_t (**)(uint64_t, uint64_t, CFTypeRef))(v20 + 16);
  }
  v21 = (const __CFArray *)v18(v20, v19, v10);
  CompareFunctionSub = __MDSimpleQueryCompareFunctionSub(a3, (__CFString *)v21, (_QWORD *)a5, a6);
  if (v21)
LABEL_30:
    CFRelease(v21);
  return CompareFunctionSub;
}

BOOL _field_equal(const char *a1, const char *a2)
{
  return strcmp(a1, a2) == 0;
}

uint64_t _field_hash(const char *a1)
{
  const char *v1;
  size_t v2;
  unsigned __int8 *v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;

  v1 = a1;
  v2 = strlen(a1);
  if (v2 >= 0x11)
  {
    v6 = 0;
    v4 = v2;
    do
      v4 = v1[v6++] + 38 * v4;
    while (v6 != 8);
    v7 = -8;
    do
      v4 = v1[v2 + v7] + 38 * v4;
    while (!__CFADD__(v7++, 1));
  }
  else if (v2)
  {
    v3 = (unsigned __int8 *)&v1[v2];
    v4 = v2;
    do
    {
      v5 = *(unsigned __int8 *)v1++;
      v4 = v5 + 38 * v4;
    }
    while (v1 < (const char *)v3);
  }
  else
  {
    v4 = 0;
  }
  return ((v4 << v2) + v4);
}

uint64_t RangeMatch(uint64_t a1, CFTypeRef cf, int a3)
{
  CFTypeID v6;
  double v7;
  double v8;
  double v9;
  CFTypeID v10;
  _BOOL4 v11;
  unsigned int v12;
  double valuePtr;

  valuePtr = 0.0;
  v6 = CFGetTypeID(cf);
  if (v6 != CFNumberGetTypeID())
  {
    v10 = CFGetTypeID(cf);
    if (v10 == CFDateGetTypeID())
    {
      MEMORY[0x1BCCAF690](cf);
      v7 = strtod(**(const char ***)(a1 + 168), 0);
      v8 = strtod(*(const char **)(*(_QWORD *)(a1 + 168) + 8), 0);
      v9 = MEMORY[0x1BCCAF690](cf);
      goto LABEL_6;
    }
LABEL_10:
    v12 = 0;
    v11 = 1;
    goto LABEL_11;
  }
  v7 = strtod(**(const char ***)(a1 + 168), 0);
  v8 = strtod(*(const char **)(*(_QWORD *)(a1 + 168) + 8), 0);
  if (!CFNumberGetValue((CFNumberRef)cf, kCFNumberDoubleType, &valuePtr))
    goto LABEL_10;
  v9 = valuePtr;
LABEL_6:
  v11 = v9 > v8 || v9 < v7;
  v12 = !v11;
LABEL_11:
  if (a3)
    return v11;
  else
    return v12;
}

uint64_t __MDSimpleQueryCompareFunctionSub(uint64_t a1, __CFString *cf, _QWORD *a3, uint64_t a4)
{
  unint64_t v8;
  int v9;
  uint64_t v10;
  CFTypeID v11;
  CFIndex Count;
  CFIndex v13;
  unsigned __int8 v14;
  uint64_t v15;
  __CFString *ValueAtIndex;
  uint64_t CompareTypeWithQueryPiece;
  unsigned int v19;

  if (!cf)
    return *(_DWORD *)(a1 + 24) == 5;
  v8 = *(_QWORD *)(a1 + 32);
  if (a4)
    v9 = (v8 >> 25) & 1;
  else
    v9 = 0;
  if ((v8 & 0x4000000) != 0)
    v10 = *(int *)(a1 + 44);
  else
    v10 = -1;
  v11 = CFGetTypeID(cf);
  if (v11 == CFArrayGetTypeID())
  {
    Count = CFArrayGetCount((CFArrayRef)cf);
    v13 = Count;
    if (v10 < 0)
    {
      v14 = 1;
    }
    else
    {
      if (v10 < Count)
      {
        v13 = v10 + 1;
        v14 = 1;
        goto LABEL_20;
      }
      v14 = 0;
    }
    if (Count >= 1)
    {
      v10 = 0;
LABEL_20:
      v15 = 0;
      do
      {
        ValueAtIndex = (__CFString *)CFArrayGetValueAtIndex((CFArrayRef)cf, v10);
        CompareTypeWithQueryPiece = __MDSimpleQueryCompareTypeWithQueryPiece(a3, ValueAtIndex, a1);
        v19 = CompareTypeWithQueryPiece;
        if (!(_DWORD)CompareTypeWithQueryPiece)
          v14 = 0;
        if (v9)
        {
          if ((_DWORD)CompareTypeWithQueryPiece)
            v15 = db_eval_obj_qp_array_set_match_at_index(a4, a1, v10);
        }
        else if ((_DWORD)CompareTypeWithQueryPiece && *(_DWORD *)(a1 + 24) != 5)
        {
          return CompareTypeWithQueryPiece;
        }
        ++v10;
      }
      while (v13 != v10);
      if ((v9 & 1) != 0)
        return v15;
      goto LABEL_32;
    }
    v15 = 0;
    v19 = 0;
    if ((v9 & 1) == 0)
    {
LABEL_32:
      if (*(_DWORD *)(a1 + 24) == 5)
        return v14;
      else
        return v19;
    }
    return v15;
  }
  if (v10 > 0)
    return *(_DWORD *)(a1 + 24) == 5;
  return __MDSimpleQueryCompareTypeWithQueryPiece(a3, cf, a1);
}

uint64_t __MDSimpleQueryCompareTypeWithQueryPiece(_QWORD *a1, __CFString *a2, uint64_t a3)
{
  int v6;
  __int128 v7;
  uint64_t v8;
  int v9;
  CFTypeID v10;
  const char *v11;
  CFStringRef v12;
  const char **v13;
  CFStringRef v14;
  uint64_t v15;
  CFStringRef v16;
  const char **v17;
  CFStringRef v18;
  uint64_t v19;
  _BOOL8 v20;
  size_t v21;
  size_t v22;
  char *v23;
  const char *v24;
  size_t v25;
  int v26;
  _BOOL4 v27;
  const char *v28;
  CFNumberType Type;
  int v30;
  uint64_t v31;
  CFIndex v32;
  const __CFString *v33;
  const __CFString *v34;
  _BYTE *v35;
  const char *v36;
  CFAbsoluteTime Current;
  int v38;
  void (*v39)(_QWORD *, _QWORD, uint64_t, uint64_t, _QWORD);
  uint64_t v40;
  double v41;
  unsigned __int8 *v42;
  unint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unsigned __int8 *v46;
  unint64_t v47;
  uint64_t v48;
  unint64_t v49;
  unint64_t v50;
  char v51;
  uint64_t info;
  unint64_t v53;
  _BYTE v55[4104];
  _QWORD v56[2];
  double v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  uint64_t v77;

  v77 = *MEMORY[0x1E0C80C00];
  v6 = *(_DWORD *)(a3 + 24);
  if ((v6 - 13) <= 1)
  {
    v75 = 0u;
    v76 = 0u;
    v73 = 0u;
    v74 = 0u;
    v71 = 0u;
    v72 = 0u;
    v69 = 0u;
    v70 = 0u;
    v67 = 0u;
    v68 = 0u;
    v65 = 0u;
    v66 = 0u;
    v63 = 0u;
    v64 = 0u;
    v61 = 0u;
    v62 = 0u;
    v59 = 0u;
    v60 = 0u;
    LODWORD(v68) = 2048;
    v7 = *(_OWORD *)a3;
    DWORD2(v59) = 1;
    v58 = v7;
    if (*(int *)(a3 + 40) < 1)
    {
      v9 = 0;
    }
    else
    {
      v8 = 0;
      do
      {
        *(_QWORD *)&v74 = *(_QWORD *)(*(_QWORD *)(a3 + 168) + 8 * v8);
        v9 = __MDSimpleQueryCompareTypeWithQueryPiece(a1, a2, &v58);
        if (*((_QWORD *)&v64 + 1))
        {
          icu_ctx_release();
          *((_QWORD *)&v64 + 1) = 0;
        }
        if (v9 >= 1)
          break;
        ++v8;
      }
      while (v8 < *(int *)(a3 + 40));
      v6 = *(_DWORD *)(a3 + 24);
    }
    if (v6 == 13)
      return v9;
    else
      return v9 == 0;
  }
  v56[1] = -1;
  v57 = 0.0;
  MEMORY[0x1E0C80A78](a1);
  bzero(v55, 0x1000uLL);
  v10 = CFGetTypeID(a2);
  if (v10 != CFStringGetTypeID())
  {
    if (MDUnicodeConverterGetTypeID_once != -1)
      dispatch_once(&MDUnicodeConverterGetTypeID_once, &__block_literal_global_9528);
    if (v10 != __kMDUnicodeConverterTypeID)
    {
      if (v10 == CFNumberGetTypeID())
      {
        Type = CFNumberGetType((CFNumberRef)a2);
        v20 = 0;
        if ((unint64_t)Type > kCFNumberDoubleType)
          return v20;
        if (((1 << Type) & 0xF9E) != 0)
        {
          CFNumberGetValue((CFNumberRef)a2, kCFNumberSInt64Type, &v57);
          v30 = 0;
          v31 = 7;
        }
        else
        {
          if (((1 << Type) & 0x3060) == 0)
            return v20;
          CFNumberGetValue((CFNumberRef)a2, kCFNumberDoubleType, &v57);
          v30 = 0;
          v31 = 10;
        }
      }
      else if (v10 == CFDateGetTypeID())
      {
        v57 = MEMORY[0x1BCCAF690](a2);
        if (!a1[11])
          a1[11] = si_calendar_retain();
        bzero(&v58, 0x400uLL);
        v35 = *(_BYTE **)(a3 + 72);
        if (*v35 == 36)
        {
          v36 = v35 + 1;
          Current = CFAbsoluteTimeGetCurrent();
          if (_expandFunctions(v36, (char *)&v58, 0x400uLL, a1[11], (uint64_t)&__block_literal_global_3_3861, Current) == 0x10000)
          {
            *(double *)(a3 + 264) = strtod((const char *)&v58, 0);
            *(_DWORD *)(a3 + 160) = 4096;
            v31 = 12;
            goto LABEL_60;
          }
        }
        v30 = 0;
        v31 = 12;
      }
      else if ((__CFString *)*MEMORY[0x1E0C9AE50] == a2)
      {
        v30 = 0;
        v31 = 1;
        LOBYTE(v57) = 1;
      }
      else
      {
        if ((__CFString *)*MEMORY[0x1E0C9AE40] != a2)
          return 0;
        v30 = 0;
        LOBYTE(v57) = 0;
        v31 = 1;
      }
LABEL_50:
      if (convert_value_to_type(v31, a3))
      {
        v20 = 0;
LABEL_100:
        if ((_DWORD)v31 == 11 && v55 != *(_BYTE **)&v57)
          free(*(void **)&v57);
        return v20;
      }
      if (v30)
      {
        *(_QWORD *)&v58 = 0;
        v56[0] = 0;
        v20 = db_compare_val(11);
        if (v20)
        {
          v39 = (void (*)(_QWORD *, _QWORD, uint64_t, uint64_t, _QWORD))a1[6];
          if (v39)
          {
            v40 = 0;
            v41 = v57;
            v42 = (unsigned __int8 *)(*(_QWORD *)&v57 + v58);
            *(_QWORD *)&v58 = 0;
            while (*(_QWORD *)&v41 < (unint64_t)v42)
            {
              v43 = (unint64_t)**(_BYTE **)&v41 >> 4;
              v44 = utf8_byte_length(unsigned char)::utf8_len_table[v43];
              *(_QWORD *)&v58 = ++v40;
              *(_QWORD *)&v41 += v44;
              if ((v43 & 0xC) == 8)
                goto LABEL_100;
            }
            v45 = 0;
            v46 = &v42[v56[0]];
            v56[0] = 0;
            while (v42 < v46)
            {
              v47 = (unint64_t)*v42 >> 4;
              v48 = utf8_byte_length(unsigned char)::utf8_len_table[v47];
              v56[0] = ++v45;
              v42 += v48;
              if ((v47 & 0xC) == 8)
                goto LABEL_100;
            }
            v39(a1, a1[7], v40, v45, a1[9]);
          }
        }
        goto LABEL_100;
      }
LABEL_60:
      v20 = db_compare_val(v31);
      goto LABEL_100;
    }
    if (*(_DWORD *)(a3 + 24) != 1 || !a1[6])
    {
      *(_QWORD *)&v58 = 0;
      v32 = MDUnicodeConverterConvert(a2, 0, &v58);
      v33 = CFStringCreateWithCharacters((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const UniChar *)v58, v32);
      if (!v33 || (v34 = v33, v57 = COERCE_DOUBLE(BuildUTF8StringDecomposed(v33, v55)), CFRelease(v34), v57 != 0.0))
      {
LABEL_49:
        v31 = 11;
        v30 = 1;
        goto LABEL_50;
      }
      return 0xFFFFFFFFLL;
    }
    printf("UNICODE MATCH:%s\n", *(const char **)(a3 + 72));
    if (!*(_QWORD *)(a3 + 104))
    {
      v16 = CFStringCreateWithCString(0, *(const char **)(a3 + 72), 0x8000100u);
      v17 = (const char **)a1[3];
      if (v17)
      {
        v18 = CFStringCreateWithCString(0, *v17, 0x8000100u);
        v19 = icu_range_search_create();
        if (v18)
          CFRelease(v18);
      }
      else
      {
        v19 = icu_range_search_create();
      }
      CFRelease(v16);
      *(_QWORD *)(a3 + 104) = v19;
    }
    v58 = 0uLL;
    v56[0] = 0;
    v49 = MDUnicodeConverterConvert(a2, 0, v56);
    v50 = 0;
    v51 = 1;
    if (!v49)
      return 0;
    while (1)
    {
      info = a2[1].info;
      icu_range_search_set_uchar_text();
      if (!icu_range_search_next_match())
        goto LABEL_89;
      v53 = *((_QWORD *)&v58 + 1) + v58;
      if (!info || v53 < v49)
        break;
LABEL_90:
      v49 = MDUnicodeConverterConvert(a2, 0x100uLL, v56);
      v51 = 0;
      v50 = 256;
      if (!v49)
        return 0;
    }
    if (v51 & 1 | (v53 > v50))
    {
      ((void (*)(_QWORD *, _QWORD))a1[6])(a1, a1[7]);
      return 0;
    }
LABEL_89:
    if (!info)
      return 0;
    goto LABEL_90;
  }
  v11 = *(const char **)a3;
  if (strcmp(*(const char **)a3, "_kMDQueryScope") && strcmp(v11, "_kMDQueryItemInScopeForRankingOnly"))
  {
    if (*(_DWORD *)(a3 + 24) == 1 && a1[6])
    {
      if (!*(_QWORD *)(a3 + 104))
      {
        v12 = CFStringCreateWithCString(0, *(const char **)(a3 + 72), 0x8000100u);
        v13 = (const char **)a1[3];
        if (v13)
        {
          v14 = CFStringCreateWithCString(0, *v13, 0x8000100u);
          v15 = icu_range_search_create();
          if (v14)
            CFRelease(v14);
        }
        else
        {
          v15 = icu_range_search_create();
        }
        CFRelease(v12);
        *(_QWORD *)(a3 + 104) = v15;
      }
      icu_range_search_set_text();
      v58 = 0uLL;
      while (icu_range_search_next_match()
           && ((unsigned int (*)(_QWORD *, _QWORD, _QWORD, _QWORD, _QWORD))a1[6])(a1, a1[7], v58, *((_QWORD *)&v58 + 1), a1[9]));
      return 0;
    }
    v57 = COERCE_DOUBLE(BuildUTF8StringDecomposed(a2, v55));
    if (v57 != 0.0)
      goto LABEL_49;
    return 0xFFFFFFFFLL;
  }
  v21 = strlen(*(const char **)(a3 + 72));
  if (v21 >= 2
    && (v22 = v21, bzero(&v58, 0x400uLL), CFStringGetCString(a2, (char *)&v58, 1024, 0x8000100u))
    && (v23 = strrchr((char *)&v58, 47)) != 0)
  {
    v23[1] = 0;
    v24 = *(const char **)(a3 + 72);
    v25 = v22 - 1;
    v26 = v24[v25];
    if (*v24 == 42)
    {
      v27 = 0;
      v28 = v24 + 1;
      if (v24[1] == 47 && v58 == 47)
      {
        if (v26 == 42)
        {
          v24[v25] = 0;
          v27 = strstr((char *)&v58, v28) != 0;
          *(_BYTE *)(*(_QWORD *)(a3 + 72) + v25) = 42;
        }
        else
        {
          v27 = strstr((char *)&v58, v28) != 0;
        }
      }
    }
    else
    {
      if (v26 == 42)
        v38 = strncmp(v24, (const char *)&v58, v25);
      else
        v38 = strcmp(v24, (const char *)&v58);
      v27 = v38 == 0;
    }
  }
  else
  {
    v27 = 0;
  }
  return v27 ^ (*(_DWORD *)(a3 + 24) == 5);
}

_BYTE *BuildUTF8StringDecomposed(const __CFString *a1, _BYTE *a2)
{
  CFTypeID v4;
  CFIndex Length;
  const UniChar *CharactersPtr;
  unsigned __int16 *v7;
  unsigned __int16 *v8;
  UniChar *v9;
  uint64_t v10;
  _BYTE *v11;
  int v12;
  _BYTE *v13;
  _BYTE *v14;
  uint64_t v16;
  CFRange v17;

  if (!a1)
    return 0;
  v4 = CFGetTypeID(a1);
  if (v4 != CFStringGetTypeID())
    return 0;
  Length = CFStringGetLength(a1);
  CharactersPtr = CFStringGetCharactersPtr(a1);
  if (CharactersPtr)
  {
    v7 = (unsigned __int16 *)CharactersPtr;
    v8 = 0;
    goto LABEL_7;
  }
  v9 = (UniChar *)malloc_type_malloc(2 * Length, 0x1000040BDFB0063uLL);
  if (!v9)
    return 0;
  v7 = v9;
  v17.location = 0;
  v17.length = Length;
  CFStringGetCharacters(a1, v17, v9);
  v8 = v7;
LABEL_7:
  v10 = 6 * Length + 6;
  if (v10 <= 4096)
  {
    v10 = 4096;
    v11 = a2;
    if (a2)
      goto LABEL_9;
  }
  else
  {
    v11 = malloc_type_malloc(6 * Length + 6, 0xC1BFDD8DuLL);
    if (v11)
    {
LABEL_9:
      v12 = utf8_encodestr(v7, 2 * Length, v11, &v16, v10);
      if (v12)
        v13 = v11;
      else
        v13 = 0;
      if (v12)
        v14 = 0;
      else
        v14 = v11;
      goto LABEL_19;
    }
  }
  v13 = 0;
  v14 = 0;
LABEL_19:
  free(v8);
  if (v13 && v13 != a2)
    free(v13);
  return v14;
}

_QWORD *_MDCreateSimpleQueryEvaluator(const __CFString *a1, uint64_t a2)
{
  return _MDCreateSimpleQueryEvaluatorWithOptionsAndLanguages(a1, a2, 0, 0);
}

_QWORD *_MDCreateSimpleQueryEvaluatorWithOptions(const __CFString *a1, uint64_t a2, char a3)
{
  return _MDCreateSimpleQueryEvaluatorWithOptionsAndLanguages(a1, a2, a3, 0);
}

_QWORD *_MDSimpleQueryModifyForMatching(_QWORD *result)
{
  _QWORD v1[5];

  if (result)
  {
    result = (_QWORD *)*result;
    if (result)
    {
      v1[0] = MEMORY[0x1E0C809B0];
      v1[1] = 0x40000000;
      v1[2] = __db_query_tree_apply_block_block_invoke;
      v1[3] = &unk_1E6E377F8;
      v1[4] = &__block_literal_global_3_5615;
      return (_QWORD *)db_query_tree_apply_block_with_meta(result, (uint64_t)v1, 0);
    }
  }
  return result;
}

void _MDSimpleQueryDeallocate(_QWORD **a1)
{
  _QWORD *v2;
  void **v3;
  void *v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD v9[5];

  if (a1)
  {
    v2 = a1[5];
    if (v2)
      CFRelease(v2);
    v3 = (void **)a1[3];
    v4 = *v3;
    if (*v3)
    {
      v5 = 1;
      do
      {
        free(v4);
        v3 = (void **)a1[3];
        v4 = v3[v5++];
      }
      while (v4);
    }
    free(v3);
    v6 = *a1;
    v9[0] = MEMORY[0x1E0C809B0];
    v9[1] = 0x40000000;
    v9[2] = __db_query_tree_apply_block_block_invoke;
    v9[3] = &unk_1E6E377F8;
    v9[4] = &__block_literal_global_5_5617;
    db_query_tree_apply_block_with_meta(v6, (uint64_t)v9, 0);
    v7 = a1[2];
    if (v7)
      _Block_release(v7);
    db_free_query_node(*a1);
    free(a1[4]);
    v8 = a1[11];
    if (v8)
      OSAtomicEnqueue(&s_si_calendar_head, v8, 0);
    free(a1);
  }
}

double _MDSimpleQueryGatherRangesForKeyAndValue(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  double result;

  a1[6] = a2;
  a1[7] = a3;
  a1[8] = a4;
  a1[9] = a5;
  v6 = a1[1];
  a1[1] = rangeGetValueFunction;
  _MDSimpleQueryObjectMatches((unint64_t)a1, a4);
  a1[1] = v6;
  result = 0.0;
  *((_OWORD *)a1 + 3) = 0u;
  *((_OWORD *)a1 + 4) = 0u;
  return result;
}

CFTypeRef rangeGetValueFunction(uint64_t a1, int a2, CFTypeRef cf1)
{
  CFTypeRef v3;

  v3 = *(CFTypeRef *)(a1 + 56);
  if (v3
    && (v3 == cf1
     || CFEqual(cf1, v3)
     || CFEqual(cf1, CFSTR("*")) && !CFEqual(*(CFTypeRef *)(a1 + 56), CFSTR("kMDItemTextContent"))))
  {
    return CFRetain(*(CFTypeRef *)(a1 + 64));
  }
  else
  {
    return 0;
  }
}

unint64_t _MDSimpleQueryObjectMatches(unint64_t a1, uint64_t a2)
{
  _QWORD *v4;

  v4 = malloc_type_malloc(0x18uLL, 0x10A00404E934A1DuLL);
  v4[1] = 0;
  v4[2] = 0;
  *v4 = a2;
  if (a1)
  {
    if (*(_QWORD *)a1)
      a1 = db_eval_obj_with_options(0) != 0;
    else
      a1 = 0;
  }
  free(v4);
  return a1;
}

void __getCurrentLanguage_block_invoke()
{
  const __CFArray *v0;
  const __CFArray *v1;
  const __CFString *ValueAtIndex;
  _OWORD v3[16];
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  getCurrentLanguage_lang = (uint64_t)"";
  v0 = (const __CFArray *)CopyAppleLanguages();
  if (v0)
  {
    v1 = v0;
    if (CFArrayGetCount(v0) >= 1)
    {
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v1, 0);
      memset(v3, 0, sizeof(v3));
      if (CFStringGetCString(ValueAtIndex, (char *)v3, 256, 0x8000100u))
        getCurrentLanguage_lang = (uint64_t)strdup((const char *)v3);
    }
    CFRelease(v1);
  }
}

uint64_t __getCurrentLocale_block_invoke()
{
  uint64_t result;

  if (getCurrentLanguage_onceToken[0] != -1)
    dispatch_once(getCurrentLanguage_onceToken, &__block_literal_global_28_5621);
  getCurrentLocale_searchLocale = _icu_locale_create();
  if (getCurrentLanguage_onceToken[0] != -1)
    dispatch_once(getCurrentLanguage_onceToken, &__block_literal_global_28_5621);
  result = _icu_locale_create();
  getCurrentLocale_nonSearchLocale = result;
  return result;
}

uint64_t _MDStringPrefixOfString(uint64_t a1)
{
  const __CFString *v1;
  const __CFString *v2;
  int v3;
  int v4;
  const __CFString *v5;
  const __CFString *v6;
  CFIndex Length;
  CFIndex v8;
  uint64_t v9;
  CFRange v10;
  UniChar *v11;
  CFIndex v12;
  CFIndex v13;
  int v14;
  UniChar *v15;
  CFIndex v16;
  CFIndex v17;
  uint64_t collation;
  uint64_t v19;
  uint64_t v20;
  uint64_t RangeOfCharacterClusterAtIndex;
  uint64_t v22;
  BOOL v23;
  _BYTE v25[2048];
  _BYTE v26[2048];
  uint64_t v27;
  CFRange v28;
  CFRange v29;

  v1 = (const __CFString *)MEMORY[0x1E0C80A78](a1);
  v4 = v3;
  v5 = v2;
  v6 = v1;
  v27 = *MEMORY[0x1E0C80C00];
  if (!v1)
  {
    Length = 0;
    if (v2)
      goto LABEL_3;
    return -1;
  }
  Length = CFStringGetLength(v1);
  if (!v5)
    return -1;
LABEL_3:
  v8 = CFStringGetLength(v5);
  v9 = -1;
  if (Length && v8)
  {
    v10 = CFStringFind(v6, v5, 9uLL);
    if (v10.location == -1 || !v10.length)
    {
      v11 = (UniChar *)v26;
      bzero(v26, 0x800uLL);
      v12 = CFStringGetLength(v6);
      v13 = v12;
      if (v12 < 1025 || (v11 = (UniChar *)malloc_type_malloc(8 * v12, 0x10040436913F5uLL)) != 0)
      {
        v28.location = 0;
        v28.length = v13;
        CFStringGetCharacters(v6, v28, v11);
        v14 = 1;
      }
      else
      {
        v14 = 0;
      }
      v15 = (UniChar *)v25;
      bzero(v25, 0x800uLL);
      v16 = CFStringGetLength(v5);
      v17 = v16;
      if ((v16 < 1025 || (v15 = (UniChar *)malloc_type_malloc(8 * v16, 0x10040436913F5uLL)) != 0)
        && (v29.location = 0, v29.length = v17, CFStringGetCharacters(v5, v29, v15), v14))
      {
        if (getCurrentLocale_onceToken != -1)
          dispatch_once(&getCurrentLocale_onceToken, &__block_literal_global_31_5624);
        collation = icu_locale_get_collation();
        v9 = prefixOfString(collation);
        if ((v4 & 0x10000) != 0)
        {
          if (getCurrentLocale_onceToken != -1)
            dispatch_once(&getCurrentLocale_onceToken, &__block_literal_global_31_5624);
          v19 = icu_locale_get_collation();
          v20 = prefixOfString(v19);
          if (v9 <= v20)
            v9 = v20;
        }
      }
      else
      {
        v9 = -1;
      }
      if (v11 != (UniChar *)v26)
        free(v11);
      if (v15 != (UniChar *)v25)
        free(v15);
    }
    else
    {
      v9 = v10.location + v10.length;
    }
    if (v9 >= 1)
    {
      RangeOfCharacterClusterAtIndex = CFStringGetRangeOfCharacterClusterAtIndex();
      if (v22)
        v23 = RangeOfCharacterClusterAtIndex == -1;
      else
        v23 = 1;
      if (!v23)
        return RangeOfCharacterClusterAtIndex + v22;
    }
  }
  return v9;
}

uint64_t prefixOfString(uint64_t a1)
{
  uint64_t MatchedLength;

  if (!a1 || !usearch_openFromCollator())
    return -1;
  if (usearch_first())
    MatchedLength = -1;
  else
    MatchedLength = (int)usearch_getMatchedLength();
  usearch_close();
  return MatchedLength;
}

double std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,DocMeta *,false>(uint64_t a1, unint64_t a2, uint64_t a3, char a4, __n128 a5)
{
  __n128 *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  __n128 v15;
  __n128 v16;
  __n128 v17;
  __int128 v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  BOOL v22;
  char v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  BOOL v27;
  unint64_t v28;
  uint64_t v29;
  _BOOL4 v30;
  uint64_t v31;
  BOOL v32;
  unint64_t v33;
  __int128 v34;
  __int128 v35;
  uint64_t v36;
  BOOL v37;
  uint64_t v38;
  _BOOL4 v39;
  __int128 v40;
  BOOL v41;
  __n128 v42;
  uint64_t v43;
  BOOL v44;
  uint64_t v45;
  BOOL v46;
  uint64_t *v47;
  uint64_t v48;
  _BOOL4 v49;
  _BOOL4 v50;
  unint64_t v51;
  uint64_t v52;
  BOOL v53;
  char v54;
  __int128 v55;
  uint64_t v56;
  _BOOL4 v57;
  uint64_t v58;
  BOOL v59;
  __int128 v60;
  uint64_t v61;
  _BOOL4 v62;
  unint64_t v63;
  BOOL v64;
  char v65;
  uint64_t v66;
  unint64_t v67;
  unint64_t v68;
  uint64_t v69;
  unsigned int v70;
  _BOOL4 v71;
  char v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  BOOL v76;
  BOOL v77;
  uint64_t v78;
  int64_t v79;
  int64_t v80;
  int64_t v81;
  uint64_t v82;
  unint64_t v83;
  uint64_t v84;
  _BOOL4 v85;
  unint64_t v86;
  uint64_t v87;
  unsigned int v88;
  BOOL v89;
  char v90;
  unint64_t v91;
  __int128 v92;
  uint64_t v93;
  uint64_t v94;
  _BOOL4 v95;
  _BOOL4 v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  _OWORD *v101;
  _OWORD *v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  _BOOL4 v106;
  __int128 v107;
  uint64_t v108;
  unint64_t v109;
  unint64_t v110;
  uint64_t v111;
  unsigned int v112;
  _BOOL4 v113;
  char v114;
  unint64_t v115;
  __int128 v116;
  BOOL v117;
  uint64_t v119;
  uint64_t v120;
  unsigned int v121;
  _BOOL4 v122;
  char v123;
  uint64_t v124;
  uint64_t v125;
  unsigned int v126;
  BOOL v127;
  BOOL v128;
  __n128 v130;
  __n128 v131;
  __int128 v132;
  _BYTE v133[32];
  _BYTE v134[32];
  _BYTE v135[32];
  _BYTE v136[32];
  __int128 v137;
  __int128 v138;
  _BYTE v139[32];
  __int128 v140;

__n128 std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,DocMeta *>(__int128 *a1, uint64_t *a2, __int128 *a3, __n128 result)
{
  uint64_t v4;
  unsigned int v5;
  BOOL v6;
  _BOOL4 v7;
  BOOL v8;
  _BOOL4 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  _BOOL4 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  _BOOL4 v19;
  __int128 v20;
  _BYTE v21[32];
  _BYTE v22[32];
  _BYTE v23[32];
  _BYTE v24[32];

  v4 = *a2;
  v5 = *((unsigned __int8 *)a2 + 24);
  v6 = *a2 < *(_QWORD *)a1;
  if (*a2 == *(_QWORD *)a1)
    v6 = v5 > *((unsigned __int8 *)a1 + 24);
  v7 = *((unsigned __int8 *)a3 + 24) > v5;
  v8 = *(_QWORD *)a3 == v4;
  v9 = *(_QWORD *)a3 < v4;
  if (v8)
    v9 = v7;
  if (v6)
  {
    if (v9)
    {
      v10 = *a1;
      *(_OWORD *)v21 = *a1;
      *(_OWORD *)&v21[16] = a1[1];
      v11 = *(__int128 *)((char *)a3 + 10);
      *a1 = *a3;
      *(__int128 *)((char *)a1 + 10) = v11;
LABEL_17:
      *a3 = v10;
      result = *(__n128 *)&v21[10];
      *(__int128 *)((char *)a3 + 10) = *(_OWORD *)&v21[10];
      return result;
    }
    *(_OWORD *)v24 = *a1;
    v17 = *a1;
    *(_OWORD *)&v24[16] = a1[1];
    v18 = *(_OWORD *)((char *)a2 + 10);
    *a1 = *(_OWORD *)a2;
    *(__int128 *)((char *)a1 + 10) = v18;
    *(_OWORD *)a2 = v17;
    result = *(__n128 *)&v24[10];
    *(_OWORD *)((char *)a2 + 10) = *(_OWORD *)&v24[10];
    v19 = *(_QWORD *)a3 < *a2;
    if (*(_QWORD *)a3 == *a2)
      v19 = *((unsigned __int8 *)a3 + 24) > *((unsigned __int8 *)a2 + 24);
    if (v19)
    {
      v10 = *(_OWORD *)a2;
      *(_OWORD *)v21 = *(_OWORD *)a2;
      *(_OWORD *)&v21[16] = *((_OWORD *)a2 + 1);
      v20 = *(__int128 *)((char *)a3 + 10);
      *(_OWORD *)a2 = *a3;
      *(_OWORD *)((char *)a2 + 10) = v20;
      goto LABEL_17;
    }
  }
  else if (v9)
  {
    *(_OWORD *)v22 = *(_OWORD *)a2;
    v12 = *(_OWORD *)a2;
    *(_OWORD *)&v22[16] = *((_OWORD *)a2 + 1);
    v13 = *(__int128 *)((char *)a3 + 10);
    *(_OWORD *)a2 = *a3;
    *(_OWORD *)((char *)a2 + 10) = v13;
    *a3 = v12;
    result = *(__n128 *)&v22[10];
    *(__int128 *)((char *)a3 + 10) = *(_OWORD *)&v22[10];
    v14 = *a2 < *(_QWORD *)a1;
    if (*a2 == *(_QWORD *)a1)
      v14 = *((unsigned __int8 *)a2 + 24) > *((unsigned __int8 *)a1 + 24);
    if (v14)
    {
      *(_OWORD *)v23 = *a1;
      v15 = *a1;
      *(_OWORD *)&v23[16] = a1[1];
      v16 = *(_OWORD *)((char *)a2 + 10);
      *a1 = *(_OWORD *)a2;
      *(__int128 *)((char *)a1 + 10) = v16;
      *(_OWORD *)a2 = v15;
      result = *(__n128 *)&v23[10];
      *(_OWORD *)((char *)a2 + 10) = *(_OWORD *)&v23[10];
    }
  }
  return result;
}

__n128 std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,DocMeta *>(uint64_t a1, __int128 *a2, __int128 *a3, __int128 *a4, __n128 a5)
{
  __n128 result;
  _BOOL4 v10;
  __int128 v11;
  __int128 v12;
  _BOOL4 v13;
  __int128 v14;
  __int128 v15;
  _BOOL4 v16;
  __int128 v17;
  __int128 v18;
  _BYTE v19[32];
  _BYTE v20[32];
  _BYTE v21[32];

  result.n128_u64[0] = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,DocMeta *>((__int128 *)a1, (uint64_t *)a2, a3, a5).n128_u64[0];
  v10 = *(_QWORD *)a4 < *(_QWORD *)a3;
  if (*(_QWORD *)a4 == *(_QWORD *)a3)
    v10 = *((unsigned __int8 *)a4 + 24) > *((unsigned __int8 *)a3 + 24);
  if (v10)
  {
    *(_OWORD *)v19 = *a3;
    v11 = *a3;
    *(_OWORD *)&v19[16] = a3[1];
    v12 = *(__int128 *)((char *)a4 + 10);
    *a3 = *a4;
    *(__int128 *)((char *)a3 + 10) = v12;
    *a4 = v11;
    result = *(__n128 *)&v19[10];
    *(__int128 *)((char *)a4 + 10) = *(_OWORD *)&v19[10];
    v13 = *(_QWORD *)a3 < *(_QWORD *)a2;
    if (*(_QWORD *)a3 == *(_QWORD *)a2)
      v13 = *((unsigned __int8 *)a3 + 24) > *((unsigned __int8 *)a2 + 24);
    if (v13)
    {
      *(_OWORD *)v20 = *a2;
      v14 = *a2;
      *(_OWORD *)&v20[16] = a2[1];
      v15 = *(__int128 *)((char *)a3 + 10);
      *a2 = *a3;
      *(__int128 *)((char *)a2 + 10) = v15;
      *a3 = v14;
      result = *(__n128 *)&v20[10];
      *(__int128 *)((char *)a3 + 10) = *(_OWORD *)&v20[10];
      v16 = *(_QWORD *)a2 < *(_QWORD *)a1;
      if (*(_QWORD *)a2 == *(_QWORD *)a1)
        v16 = *((unsigned __int8 *)a2 + 24) > *(unsigned __int8 *)(a1 + 24);
      if (v16)
      {
        *(_OWORD *)v21 = *(_OWORD *)a1;
        v17 = *(_OWORD *)a1;
        *(_OWORD *)&v21[16] = *(_OWORD *)(a1 + 16);
        v18 = *(__int128 *)((char *)a2 + 10);
        *(_OWORD *)a1 = *a2;
        *(_OWORD *)(a1 + 10) = v18;
        *a2 = v17;
        result = *(__n128 *)&v21[10];
        *(__int128 *)((char *)a2 + 10) = *(_OWORD *)&v21[10];
      }
    }
  }
  return result;
}

__n128 std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,DocMeta *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, __n128 a6)
{
  __n128 result;
  _BOOL4 v12;
  __int128 v13;
  __int128 v14;
  _BOOL4 v15;
  __int128 v16;
  __int128 v17;
  _BOOL4 v18;
  __int128 v19;
  __int128 v20;
  _BOOL4 v21;
  __int128 v22;
  __int128 v23;
  _BYTE v24[32];
  _BYTE v25[32];
  _BYTE v26[32];
  _BYTE v27[32];

  result.n128_u64[0] = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,DocMeta *>(a1, (__int128 *)a2, (__int128 *)a3, (__int128 *)a4, a6).n128_u64[0];
  v12 = *(_QWORD *)a5 < *(_QWORD *)a4;
  if (*(_QWORD *)a5 == *(_QWORD *)a4)
    v12 = *(unsigned __int8 *)(a5 + 24) > *(unsigned __int8 *)(a4 + 24);
  if (v12)
  {
    *(_OWORD *)v24 = *(_OWORD *)a4;
    v13 = *(_OWORD *)a4;
    *(_OWORD *)&v24[16] = *(_OWORD *)(a4 + 16);
    v14 = *(_OWORD *)(a5 + 10);
    *(_OWORD *)a4 = *(_OWORD *)a5;
    *(_OWORD *)(a4 + 10) = v14;
    *(_OWORD *)a5 = v13;
    result = *(__n128 *)&v24[10];
    *(_OWORD *)(a5 + 10) = *(_OWORD *)&v24[10];
    v15 = *(_QWORD *)a4 < *(_QWORD *)a3;
    if (*(_QWORD *)a4 == *(_QWORD *)a3)
      v15 = *(unsigned __int8 *)(a4 + 24) > *(unsigned __int8 *)(a3 + 24);
    if (v15)
    {
      *(_OWORD *)v25 = *(_OWORD *)a3;
      v16 = *(_OWORD *)a3;
      *(_OWORD *)&v25[16] = *(_OWORD *)(a3 + 16);
      v17 = *(_OWORD *)(a4 + 10);
      *(_OWORD *)a3 = *(_OWORD *)a4;
      *(_OWORD *)(a3 + 10) = v17;
      *(_OWORD *)a4 = v16;
      result = *(__n128 *)&v25[10];
      *(_OWORD *)(a4 + 10) = *(_OWORD *)&v25[10];
      v18 = *(_QWORD *)a3 < *(_QWORD *)a2;
      if (*(_QWORD *)a3 == *(_QWORD *)a2)
        v18 = *(unsigned __int8 *)(a3 + 24) > *(unsigned __int8 *)(a2 + 24);
      if (v18)
      {
        *(_OWORD *)v26 = *(_OWORD *)a2;
        v19 = *(_OWORD *)a2;
        *(_OWORD *)&v26[16] = *(_OWORD *)(a2 + 16);
        v20 = *(_OWORD *)(a3 + 10);
        *(_OWORD *)a2 = *(_OWORD *)a3;
        *(_OWORD *)(a2 + 10) = v20;
        *(_OWORD *)a3 = v19;
        result = *(__n128 *)&v26[10];
        *(_OWORD *)(a3 + 10) = *(_OWORD *)&v26[10];
        v21 = *(_QWORD *)a2 < *(_QWORD *)a1;
        if (*(_QWORD *)a2 == *(_QWORD *)a1)
          v21 = *(unsigned __int8 *)(a2 + 24) > *(unsigned __int8 *)(a1 + 24);
        if (v21)
        {
          *(_OWORD *)v27 = *(_OWORD *)a1;
          v22 = *(_OWORD *)a1;
          *(_OWORD *)&v27[16] = *(_OWORD *)(a1 + 16);
          v23 = *(_OWORD *)(a2 + 10);
          *(_OWORD *)a1 = *(_OWORD *)a2;
          *(_OWORD *)(a1 + 10) = v23;
          *(_OWORD *)a2 = v22;
          result = *(__n128 *)&v27[10];
          *(_OWORD *)(a2 + 10) = *(_OWORD *)&v27[10];
        }
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,DocMeta *>(uint64_t a1, uint64_t a2, __n128 a3)
{
  uint64_t v5;
  _BOOL8 result;
  uint64_t v7;
  _OWORD *v8;
  BOOL v9;
  _BOOL4 v10;
  __int128 v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  unsigned int v18;
  _BOOL4 v19;
  char v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  BOOL v24;
  BOOL v25;
  uint64_t v26;
  _BYTE v27[32];
  __int128 v28;

  v5 = (a2 - a1) >> 5;
  result = 1;
  switch(v5)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v8 = (_OWORD *)(a2 - 32);
      v7 = *(_QWORD *)(a2 - 32);
      v9 = v7 == *(_QWORD *)a1;
      v10 = v7 < *(_QWORD *)a1;
      if (v9)
        v10 = *(unsigned __int8 *)(a2 - 8) > *(unsigned __int8 *)(a1 + 24);
      if (v10)
      {
        *(_OWORD *)v27 = *(_OWORD *)a1;
        v11 = *(_OWORD *)a1;
        *(_OWORD *)&v27[16] = *(_OWORD *)(a1 + 16);
        v12 = *(_OWORD *)(a2 - 22);
        *(_OWORD *)a1 = *v8;
        *(_OWORD *)(a1 + 10) = v12;
        *v8 = v11;
        *(_OWORD *)(a2 - 22) = *(_OWORD *)&v27[10];
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,DocMeta *>((__int128 *)a1, (uint64_t *)(a1 + 32), (__int128 *)(a2 - 32), a3);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,DocMeta *>(a1, (__int128 *)(a1 + 32), (__int128 *)(a1 + 64), (__int128 *)(a2 - 32), a3);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,DocMeta *>(a1, a1 + 32, a1 + 64, a1 + 96, a2 - 32, a3);
      return 1;
    default:
      v13 = a1 + 64;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,DocMeta *>((__int128 *)a1, (uint64_t *)(a1 + 32), (__int128 *)(a1 + 64), a3);
      v14 = a1 + 96;
      if (a1 + 96 == a2)
        return 1;
      v15 = 0;
      v16 = 0;
      break;
  }
  while (1)
  {
    v17 = *(_QWORD *)v14;
    v18 = *(unsigned __int8 *)(v14 + 24);
    v19 = *(_QWORD *)v14 < *(_QWORD *)v13;
    if (*(_QWORD *)v14 == *(_QWORD *)v13)
      v19 = v18 > *(unsigned __int8 *)(v13 + 24);
    if (v19)
    {
      v28 = *(_OWORD *)(v14 + 8);
      v20 = *(_BYTE *)(v14 + 25);
      v21 = v15;
      while (1)
      {
        v22 = a1 + v21;
        *(_OWORD *)(v22 + 96) = *(_OWORD *)(a1 + v21 + 64);
        *(_OWORD *)(v22 + 106) = *(_OWORD *)(a1 + v21 + 74);
        if (v21 == -64)
          break;
        v23 = *(_QWORD *)(v22 + 32);
        v24 = v18 > *(unsigned __int8 *)(v22 + 56);
        v9 = v17 == v23;
        v25 = v17 < v23;
        if (!v9)
          v24 = v25;
        v21 -= 32;
        if (!v24)
        {
          v26 = a1 + v21 + 96;
          goto LABEL_18;
        }
      }
      v26 = a1;
LABEL_18:
      *(_QWORD *)v26 = v17;
      *(_OWORD *)(v26 + 8) = v28;
      *(_BYTE *)(v26 + 24) = v18;
      *(_BYTE *)(v26 + 25) = v20;
      if (++v16 == 8)
        return v14 + 32 == a2;
    }
    v13 = v14;
    v15 += 32;
    v14 += 32;
    if (v14 == a2)
      return 1;
  }
}

uint64_t cold_shard_finish_file(uint64_t a1, uint64_t *a2)
{
  unint64_t *v4;
  unint64_t *v5;
  uint64_t v6;
  unint64_t *v7;
  __int128 v8;
  unsigned __int8 v9;
  std::string *v10;
  std::string::size_type size;
  uint64_t v12;
  std::string::size_type v13;
  unint64_t *v14;
  unint64_t *i;
  uint64_t v16;
  std::string *p_p;
  std::string::size_type v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  std::string::size_type v22;
  std::string *v23;
  uint64_t v24;
  std::string::size_type v25;
  uint64_t v26;
  std::string::size_type v27;
  std::string::size_type v28;
  off_t v29;
  uint64_t v30;
  void *v31;
  size_t v32;
  std::string __p;
  std::string v35;
  iovec v36;
  std::string::value_type __s[16];
  off_t __offseta[2];
  __int128 v39;
  __int128 v40;
  __int128 v41;
  uint64_t v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  v36.iov_base = 0;
  v36.iov_len = 0;
  v5 = (unint64_t *)a2[2];
  v4 = (unint64_t *)a2[3];
  if (v5 == v4)
  {
    memset(&v35, 0, sizeof(v35));
LABEL_19:
    v9 = 0;
    goto LABEL_20;
  }
  v6 = a2[2];
  while (*(_BYTE *)(v6 + 25))
  {
    v6 += 32;
    if ((unint64_t *)v6 == v4)
      goto LABEL_15;
  }
  if ((unint64_t *)v6 != v4)
  {
    v7 = (unint64_t *)(v6 + 32);
    if ((unint64_t *)(v6 + 32) != v4)
    {
      do
      {
        if (*((_BYTE *)v7 + 25))
        {
          v8 = *(_OWORD *)v7;
          *(_OWORD *)(v6 + 10) = *(_OWORD *)((char *)v7 + 10);
          *(_OWORD *)v6 = v8;
          v6 += 32;
        }
        v7 += 4;
      }
      while (v7 != v4);
      v5 = (unint64_t *)a2[2];
      v4 = (unint64_t *)a2[3];
    }
  }
  if ((unint64_t *)v6 != v4)
  {
    v4 = (unint64_t *)v6;
    a2[3] = v6;
  }
LABEL_15:
  memset(&v35, 0, sizeof(v35));
  if (v5 == v4)
    goto LABEL_19;
  do
  {
    v39 = 0u;
    v40 = 0u;
    *(_OWORD *)__s = 0u;
    *(_OWORD *)__offseta = 0u;
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)__s;
    v2_writeVInt64((unint64_t **)&__p, *v5);
    v2_writeVInt64((unint64_t **)&__p, v5[1]);
    v2_writeVInt64((unint64_t **)&__p, v5[2]);
    std::string::append(&v35, __s, __p.__r_.__value_.__r.__words[0] - (_QWORD)__s);
    v5 += 4;
  }
  while (v5 != v4);
  v9 = HIBYTE(v35.__r_.__value_.__r.__words[2]);
  if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0)
  {
    size = v35.__r_.__value_.__l.__size_;
    v10 = (std::string *)v35.__r_.__value_.__r.__words[0];
    goto LABEL_21;
  }
LABEL_20:
  size = v9;
  v10 = &v35;
LABEL_21:
  v36.iov_base = v10;
  v36.iov_len = size;
  v12 = writevall(a1, &v36, 1);
  if (!(_DWORD)v12)
  {
    v13 = ((unint64_t)((double)(unint64_t)((a2[3] - a2[2]) >> 1) * 1.44) + 7) >> 3;
    memset(&__p, 0, sizeof(__p));
    std::string::resize(&__p, v13, 0);
    v14 = (unint64_t *)a2[2];
    for (i = (unint64_t *)a2[3]; v14 != i; v14 += 4)
    {
      v16 = 0;
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        p_p = &__p;
      else
        p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v18 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
      else
        v18 = __p.__r_.__value_.__l.__size_;
      v19 = *v14;
      v20 = 8 * v18;
      do
      {
        v21 = (((unint64_t)bloom_filter_hash_moduli[v16] * (unsigned __int128)v19) >> 64) % (unint64_t)v20;
        p_p->__r_.__value_.__s.__data_[v21 >> 3] |= 1 << (v21 & 7);
        ++v16;
      }
      while (v16 != 16);
    }
    v22 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v23 = &__p;
    else
      v23 = (std::string *)__p.__r_.__value_.__r.__words[0];
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      v22 = __p.__r_.__value_.__l.__size_;
    v36.iov_base = v23;
    v36.iov_len = v22;
    v12 = writevall(a1, &v36, 1);
    if (!(_DWORD)v12)
    {
      v40 = 0u;
      v41 = 0u;
      *(_OWORD *)__offseta = 0u;
      v39 = 0u;
      *(_OWORD *)__s = 0u;
      v24 = a2[5];
      v42 = 0;
      *((_QWORD *)&v40 + 1) = v24;
      *(_QWORD *)&v41 = 88;
      v25 = HIBYTE(v35.__r_.__value_.__r.__words[2]);
      if ((v35.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v25 = v35.__r_.__value_.__l.__size_;
      v26 = v24 + 88;
      *(_QWORD *)&v39 = v25;
      *((_QWORD *)&v39 + 1) = v24 + 88;
      v27 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v27 = __p.__r_.__value_.__l.__size_;
      v28 = v25 + v26;
      *(_QWORD *)__s = v27;
      *(_QWORD *)&__s[8] = v28;
      if (*((char *)a2 + 71) < 0)
        v29 = a2[7];
      else
        v29 = *((unsigned __int8 *)a2 + 71);
      __offseta[0] = v29;
      __offseta[1] = v27 + v28;
      v30 = *a2;
      *(_QWORD *)&v40 = (a2[3] - a2[2]) >> 5;
      *((_QWORD *)&v41 + 1) = v30;
      v42 = 1;
      v36.iov_base = __s;
      v36.iov_len = 88;
      v12 = pwritevall(a1, &v36, 1, 0);
      if (!(_DWORD)v12)
      {
        if (*((char *)a2 + 71) < 0)
        {
          v31 = (void *)a2[6];
          v32 = a2[7];
        }
        else
        {
          v31 = a2 + 6;
          v32 = *((unsigned __int8 *)a2 + 71);
        }
        v36.iov_base = v31;
        v36.iov_len = v32;
        v12 = pwritevall(a1, &v36, 1, __offseta[1]);
      }
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v35.__r_.__value_.__l.__data_);
  return v12;
}

unint64_t **v2_writeVInt64(unint64_t **result, unint64_t a2)
{
  unint64_t *v2;
  unint64_t *v3;
  unint64_t *v4;
  unint64_t *v5;
  unint64_t *v6;
  unint64_t *v7;
  unint64_t *v8;
  unint64_t *v9;
  unint64_t *v10;
  unint64_t *v11;
  unint64_t *v12;
  unint64_t *v13;
  unint64_t *v14;
  unint64_t *v15;
  unint64_t *v16;

  if (a2 <= 0x7F)
    goto LABEL_21;
  if (!(a2 >> 14))
  {
    v2 = *result;
    *result = (unint64_t *)((char *)*result + 1);
    *(_BYTE *)v2 = BYTE1(a2) | 0x80;
LABEL_21:
    v15 = *result;
    *result = (unint64_t *)((char *)*result + 1);
    *(_BYTE *)v15 = a2;
    return result;
  }
  if (!(a2 >> 21))
  {
    v3 = *result;
    *result = (unint64_t *)((char *)*result + 1);
    *(_BYTE *)v3 = BYTE2(a2) | 0xC0;
LABEL_20:
    v14 = *result;
    *result = (unint64_t *)((char *)*result + 1);
    *(_BYTE *)v14 = BYTE1(a2);
    goto LABEL_21;
  }
  if (!(a2 >> 28))
  {
    v4 = *result;
    *result = (unint64_t *)((char *)*result + 1);
    *(_BYTE *)v4 = BYTE3(a2) | 0xE0;
LABEL_19:
    v13 = *result;
    *result = (unint64_t *)((char *)*result + 1);
    *(_BYTE *)v13 = BYTE2(a2);
    goto LABEL_20;
  }
  if (!(a2 >> 35))
  {
    v5 = *result;
    *result = (unint64_t *)((char *)*result + 1);
    *(_BYTE *)v5 = BYTE4(a2) | 0xF0;
LABEL_18:
    v12 = *result;
    *result = (unint64_t *)((char *)*result + 1);
    *(_BYTE *)v12 = BYTE3(a2);
    goto LABEL_19;
  }
  if (!(a2 >> 42))
  {
    v6 = *result;
    *result = (unint64_t *)((char *)*result + 1);
    *(_BYTE *)v6 = BYTE5(a2) | 0xF8;
LABEL_17:
    v11 = *result;
    *result = (unint64_t *)((char *)*result + 1);
    *(_BYTE *)v11 = BYTE4(a2);
    goto LABEL_18;
  }
  if (!(a2 >> 49))
  {
    v7 = *result;
    *result = (unint64_t *)((char *)*result + 1);
    *(_BYTE *)v7 = BYTE6(a2) | 0xFC;
LABEL_16:
    v10 = *result;
    *result = (unint64_t *)((char *)*result + 1);
    *(_BYTE *)v10 = BYTE5(a2);
    goto LABEL_17;
  }
  v8 = *result;
  *result = (unint64_t *)((char *)*result + 1);
  if (!HIBYTE(a2))
  {
    *(_BYTE *)v8 = -2;
    v9 = *result;
    *result = (unint64_t *)((char *)*result + 1);
    *(_BYTE *)v9 = BYTE6(a2);
    goto LABEL_16;
  }
  *(_BYTE *)v8 = -1;
  v16 = *result;
  *v16 = a2;
  *result = v16 + 1;
  return result;
}

double cold_shard_create_search_context_for_fd(uint64_t a1, uint64_t *a2)
{
  int v3;
  double result;
  unint64_t file_size;
  uint64_t v6;
  __int128 v7;
  __int128 v8;
  _QWORD v9[2];
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  uint64_t v15;

  v3 = a1;
  v15 = 0;
  v13 = 0u;
  v14 = 0u;
  v11 = 0u;
  v12 = 0u;
  v10 = 0u;
  v9[0] = &v10;
  v9[1] = 88;
  if (!preadvall(a1, (uint64_t)v9, 0))
  {
    file_size = get_file_size(v3);
    if ((file_size & 0x8000000000000000) == 0
      && (unint64_t)v14 <= file_size
      && *((_QWORD *)&v13 + 1) + (_QWORD)v14 <= file_size
      && *((_QWORD *)&v12 + 1) <= file_size
      && (_QWORD)v12 + *((_QWORD *)&v12 + 1) <= file_size
      && *((_QWORD *)&v10 + 1) <= file_size
      && (_QWORD)v10 + *((_QWORD *)&v10 + 1) <= file_size
      && *((_QWORD *)&v11 + 1) <= file_size
      && *((_QWORD *)&v11 + 1) >= 0x58uLL
      && *((_QWORD *)&v10 + 1) >= 0x58uLL
      && *((_QWORD *)&v12 + 1) >= 0x58uLL
      && (unint64_t)v14 >= 0x58
      && (_QWORD)v11 + *((_QWORD *)&v11 + 1) <= file_size
      && v15 == 1)
    {
      v6 = operator new();
      *a2 = v6;
      *(_DWORD *)(v6 + 88) = v3;
      v7 = v13;
      *(_OWORD *)(v6 + 32) = v12;
      *(_OWORD *)(v6 + 48) = v7;
      *(_OWORD *)(v6 + 64) = v14;
      *(_QWORD *)(v6 + 80) = v15;
      result = *(double *)&v10;
      v8 = v11;
      *(_OWORD *)v6 = v10;
      *(_OWORD *)(v6 + 16) = v8;
    }
  }
  return result;
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<long long,int> *,false>(uint64_t result, unint64_t a2, uint64_t a3, char a4)
{
  uint64_t v7;
  uint64_t *v8;
  unint64_t i;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int v18;
  unint64_t k;
  uint64_t v20;
  uint64_t v21;
  unint64_t m;
  uint64_t v23;
  uint64_t v24;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  BOOL v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t j;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  int v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  int v47;
  uint64_t v48;
  BOOL v50;
  uint64_t v51;
  unint64_t v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t v55;
  int v56;
  int v57;
  unint64_t v58;
  uint64_t v59;
  uint64_t v60;
  int v61;
  uint64_t v62;
  int64_t v63;
  int64_t v64;
  int64_t v65;
  uint64_t v66;
  unint64_t v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  uint64_t v71;
  int v72;
  int v73;
  unint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  int v79;
  BOOL v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  int v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  int v91;
  uint64_t v92;
  uint64_t v93;
  unint64_t v94;
  unint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  unint64_t v101;
  unint64_t v102;
  unint64_t v103;
  uint64_t v104;
  uint64_t v105;
  int v106;
  unint64_t v107;
  unint64_t v108;
  uint64_t v109;

  v7 = result;
LABEL_2:
  v8 = (uint64_t *)(a2 - 16);
  i = v7;
  while (2)
  {
    v7 = i;
    v10 = a2 - i;
    v11 = (uint64_t)(a2 - i) >> 4;
    switch(v11)
    {
      case 0uLL:
      case 1uLL:
        return result;
      case 2uLL:
        v44 = *v8;
        v45 = *(_QWORD *)i;
        if (*v8 >= *(_QWORD *)i)
        {
          if (v45 < v44)
            return result;
          v47 = *(_DWORD *)(a2 - 8);
          v46 = *(_DWORD *)(i + 8);
          if (v47 >= v46)
            return result;
        }
        else
        {
          v46 = *(_DWORD *)(i + 8);
          v47 = *(_DWORD *)(a2 - 8);
        }
        *(_QWORD *)i = v44;
        *(_QWORD *)(a2 - 16) = v45;
        *(_DWORD *)(i + 8) = v47;
        *(_DWORD *)(a2 - 8) = v46;
        return result;
      case 3uLL:
        return (uint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<long long,int> *>((uint64_t *)i, (uint64_t *)(i + 16), (uint64_t *)(a2 - 16));
      case 4uLL:
        return (uint64_t)std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<long long,int> *>(i, i + 16, i + 32, a2 - 16);
      case 5uLL:
        return (uint64_t)std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<long long,int> *>(i, i + 16, i + 32, i + 48, (uint64_t *)(a2 - 16));
      default:
        if (v10 > 383)
        {
          if (!a3)
          {
            if (i == a2)
              return result;
            v63 = (v11 - 2) >> 1;
            v64 = v63;
            while (1)
            {
              v65 = v64;
              if (v63 >= v64)
              {
                v66 = (2 * v64) | 1;
                v67 = i + 16 * v66;
                if (2 * v65 + 2 < (uint64_t)v11)
                {
                  v68 = *(_QWORD *)(v67 + 16);
                  if (*(_QWORD *)v67 < v68
                    || v68 >= *(_QWORD *)v67 && *(_DWORD *)(i + 16 * v66 + 8) < *(_DWORD *)(v67 + 24))
                  {
                    v67 += 16;
                    v66 = 2 * v65 + 2;
                  }
                }
                v69 = i + 16 * v65;
                v70 = *(_QWORD *)v67;
                v71 = *(_QWORD *)v69;
                if (*(_QWORD *)v67 >= *(_QWORD *)v69)
                {
                  if (v71 < v70)
                  {
                    v72 = *(_DWORD *)(v69 + 8);
                    v73 = *(_DWORD *)(v67 + 8);
LABEL_131:
                    *(_QWORD *)v69 = v70;
                    *(_DWORD *)(v69 + 8) = v73;
                    if (v63 >= v66)
                    {
                      while (1)
                      {
                        v75 = 2 * v66;
                        v66 = (2 * v66) | 1;
                        v74 = i + 16 * v66;
                        v76 = v75 + 2;
                        if (v76 < (uint64_t)v11)
                        {
                          v77 = *(_QWORD *)(v74 + 16);
                          if (*(_QWORD *)v74 < v77
                            || v77 >= *(_QWORD *)v74 && *(_DWORD *)(i + 16 * v66 + 8) < *(_DWORD *)(v74 + 24))
                          {
                            v74 += 16;
                            v66 = v76;
                          }
                        }
                        v78 = *(_QWORD *)v74;
                        if (*(_QWORD *)v74 < v71)
                          break;
                        v79 = *(_DWORD *)(v74 + 8);
                        v80 = v71 >= v78 && v79 < v72;
                        if (v80)
                          break;
                        *(_QWORD *)v67 = v78;
                        *(_DWORD *)(v67 + 8) = v79;
                        v67 = v74;
                        if (v63 < v66)
                          goto LABEL_133;
                      }
                    }
                    v74 = v67;
LABEL_133:
                    *(_QWORD *)v74 = v71;
                    *(_DWORD *)(v74 + 8) = v72;
                    goto LABEL_134;
                  }
                  v73 = *(_DWORD *)(v67 + 8);
                  v72 = *(_DWORD *)(i + 16 * v65 + 8);
                  if (v73 >= v72)
                    goto LABEL_131;
                }
              }
LABEL_134:
              v64 = v65 - 1;
              if (!v65)
              {
                v88 = (unint64_t)v10 >> 4;
                while (1)
                {
                  v89 = 0;
                  v90 = *(_QWORD *)i;
                  v91 = *(_DWORD *)(i + 8);
                  v92 = v88 - 2;
                  if (v88 < 2)
                    v92 = v88 - 1;
                  v93 = v92 >> 1;
                  v94 = i;
                  do
                  {
                    v95 = v94;
                    v96 = v89 + 1;
                    v94 += 16 * (v89 + 1);
                    v97 = 2 * v89;
                    result = (2 * v89) | 1;
                    v89 = result;
                    v98 = v97 + 2;
                    if (v98 < v88)
                    {
                      result = v94 + 16;
                      v99 = *(_QWORD *)(v94 + 16);
                      if (*(_QWORD *)v94 < v99
                        || v99 >= *(_QWORD *)v94 && *(_DWORD *)(v95 + 16 * v96 + 8) < *(_DWORD *)(v94 + 24))
                      {
                        v94 += 16;
                        v89 = v98;
                      }
                    }
                    *(_QWORD *)v95 = *(_QWORD *)v94;
                    *(_DWORD *)(v95 + 8) = *(_DWORD *)(v94 + 8);
                  }
                  while (v89 <= v93);
                  if (v94 == a2 - 16)
                  {
                    *(_QWORD *)v94 = v90;
                    *(_DWORD *)(v94 + 8) = v91;
                  }
                  else
                  {
                    *(_QWORD *)v94 = *(_QWORD *)(a2 - 16);
                    *(_DWORD *)(v94 + 8) = *(_DWORD *)(a2 - 8);
                    *(_QWORD *)(a2 - 16) = v90;
                    *(_DWORD *)(a2 - 8) = v91;
                    v100 = v94 - i + 16;
                    if (v100 >= 17)
                    {
                      v101 = (v100 >> 4) - 2;
                      v102 = v101 >> 1;
                      v103 = i + 16 * (v101 >> 1);
                      v104 = *(_QWORD *)v103;
                      v105 = *(_QWORD *)v94;
                      if (*(_QWORD *)v103 < *(_QWORD *)v94)
                      {
                        v106 = *(_DWORD *)(v94 + 8);
                        result = *(unsigned int *)(v103 + 8);
LABEL_175:
                        *(_QWORD *)v94 = v104;
                        *(_DWORD *)(v94 + 8) = result;
                        if (v101 >= 2)
                        {
                          while (1)
                          {
                            v108 = v102 - 1;
                            v102 = (v102 - 1) >> 1;
                            v107 = i + 16 * v102;
                            v109 = *(_QWORD *)v107;
                            if (*(_QWORD *)v107 >= v105)
                            {
                              if (v105 < v109)
                                break;
                              result = *(unsigned int *)(i + 16 * v102 + 8);
                              if ((int)result >= v106)
                                break;
                            }
                            else
                            {
                              result = *(unsigned int *)(v107 + 8);
                            }
                            *(_QWORD *)v103 = v109;
                            *(_DWORD *)(v103 + 8) = result;
                            v103 = i + 16 * v102;
                            if (v108 <= 1)
                              goto LABEL_182;
                          }
                        }
                        v107 = v103;
LABEL_182:
                        *(_QWORD *)v107 = v105;
                        *(_DWORD *)(v107 + 8) = v106;
                        goto LABEL_184;
                      }
                      if (v105 >= v104)
                      {
                        result = *(unsigned int *)(i + 16 * v102 + 8);
                        v106 = *(_DWORD *)(v94 + 8);
                        if ((int)result < v106)
                          goto LABEL_175;
                      }
                    }
                  }
LABEL_184:
                  a2 -= 16;
                  v80 = v88-- <= 2;
                  if (v80)
                    return result;
                }
              }
            }
          }
          v12 = v11 >> 1;
          v13 = i + 16 * (v11 >> 1);
          if ((unint64_t)v10 < 0x801)
          {
            result = (uint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<long long,int> *>((uint64_t *)(v7 + 16 * (v11 >> 1)), (uint64_t *)v7, (uint64_t *)(a2 - 16));
          }
          else
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<long long,int> *>((uint64_t *)v7, (uint64_t *)(v7 + 16 * (v11 >> 1)), (uint64_t *)(a2 - 16));
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<long long,int> *>((uint64_t *)(v7 + 16), (uint64_t *)(v13 - 16), (uint64_t *)(a2 - 32));
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<long long,int> *>((uint64_t *)(v7 + 32), (uint64_t *)(v7 + 16 + 16 * v12), (uint64_t *)(a2 - 48));
            result = (uint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<long long,int> *>((uint64_t *)(v13 - 16), (uint64_t *)v13, (uint64_t *)(v7 + 16 + 16 * v12));
            v14 = *(_QWORD *)v7;
            *(_QWORD *)v7 = *(_QWORD *)v13;
            *(_QWORD *)v13 = v14;
            LODWORD(v14) = *(_DWORD *)(v7 + 8);
            *(_DWORD *)(v7 + 8) = *(_DWORD *)(v13 + 8);
            *(_DWORD *)(v13 + 8) = v14;
          }
          --a3;
          v15 = *(_QWORD *)v7;
          if ((a4 & 1) == 0)
          {
            v16 = *(_QWORD *)(v7 - 16);
            if (v16 >= v15)
            {
              if (v15 < v16)
              {
                v17 = *(_DWORD *)(v7 + 8);
              }
              else
              {
                v17 = *(_DWORD *)(v7 + 8);
                if (*(_DWORD *)(v7 - 8) < v17)
                  goto LABEL_13;
              }
              v33 = *v8;
              if (v15 >= *v8 && (v33 < v15 || v17 >= *(_DWORD *)(a2 - 8)))
              {
                for (i = v7 + 16;
                      i < a2 && v15 >= *(_QWORD *)i && (*(_QWORD *)i < v15 || v17 >= *(_DWORD *)(i + 8));
              }
              else
              {
                i = v7;
                do
                {
                  v35 = *(_QWORD *)(i + 16);
                  i += 16;
                  v34 = v35;
                }
                while (v15 >= v35 && (v34 < v15 || v17 >= *(_DWORD *)(i + 8)));
              }
              j = a2;
              if (i < a2)
              {
                for (j = a2 - 16; v15 < v33 || v33 >= v15 && v17 < *(_DWORD *)(j + 8); j -= 16)
                {
                  v37 = *(_QWORD *)(j - 16);
                  v33 = v37;
                }
              }
              if (i < j)
              {
                v38 = *(_QWORD *)i;
                v39 = *(_QWORD *)j;
                do
                {
                  *(_QWORD *)i = v39;
                  *(_QWORD *)j = v38;
                  v40 = *(_QWORD *)(i + 16);
                  i += 16;
                  v38 = v40;
                  v41 = *(_DWORD *)(i - 8);
                  *(_DWORD *)(i - 8) = *(_DWORD *)(j + 8);
                  *(_DWORD *)(j + 8) = v41;
                  while (v15 >= v38 && (v38 < v15 || v17 >= *(_DWORD *)(i + 8)))
                  {
                    v42 = *(_QWORD *)(i + 16);
                    i += 16;
                    v38 = v42;
                  }
                  do
                  {
                    do
                    {
                      v43 = *(_QWORD *)(j - 16);
                      j -= 16;
                      v39 = v43;
                    }
                    while (v15 < v43);
                  }
                  while (v39 >= v15 && v17 < *(_DWORD *)(j + 8));
                }
                while (i < j);
              }
              if (i - 16 != v7)
              {
                *(_QWORD *)v7 = *(_QWORD *)(i - 16);
                *(_DWORD *)(v7 + 8) = *(_DWORD *)(i - 8);
              }
              a4 = 0;
              *(_QWORD *)(i - 16) = v15;
              *(_DWORD *)(i - 8) = v17;
              continue;
            }
          }
LABEL_13:
          v18 = *(_DWORD *)(v7 + 8);
          for (k = v7 + 16; ; k += 16)
          {
            v20 = *(_QWORD *)k;
            if (*(_QWORD *)k >= v15 && (v15 < v20 || *(_DWORD *)(k + 8) >= v18))
              break;
          }
          if (k - 16 == v7)
          {
            m = a2;
            if (k < a2)
            {
              v24 = *v8;
              m = a2 - 16;
              if (*v8 >= v15)
              {
                m = a2 - 16;
                do
                {
                  if (v15 >= v24)
                  {
                    if (*(_DWORD *)(m + 8) < v18 || k >= m)
                      break;
                  }
                  else if (k >= m)
                  {
                    break;
                  }
                  v26 = *(_QWORD *)(m - 16);
                  m -= 16;
                  v24 = v26;
                }
                while (v26 >= v15);
              }
            }
          }
          else
          {
            v21 = *v8;
            for (m = a2 - 16; v21 >= v15 && (v15 < v21 || *(_DWORD *)(m + 8) >= v18); m -= 16)
            {
              v23 = *(_QWORD *)(m - 16);
              v21 = v23;
            }
          }
          i = k;
          if (k < m)
          {
            v27 = *(_QWORD *)m;
            v28 = m;
            i = k;
            do
            {
              *(_QWORD *)i = v27;
              *(_QWORD *)v28 = v20;
              v29 = *(_DWORD *)(i + 8);
              *(_DWORD *)(i + 8) = *(_DWORD *)(v28 + 8);
              *(_DWORD *)(v28 + 8) = v29;
              do
              {
                do
                {
                  v30 = *(_QWORD *)(i + 16);
                  i += 16;
                  v20 = v30;
                }
                while (v30 < v15);
              }
              while (v15 >= v20 && *(_DWORD *)(i + 8) < v18);
              do
              {
                v31 = *(_QWORD *)(v28 - 16);
                v28 -= 16;
                v27 = v31;
              }
              while (v31 >= v15 && (v15 < v27 || *(_DWORD *)(v28 + 8) >= v18));
            }
            while (i < v28);
          }
          if (i - 16 != v7)
          {
            *(_QWORD *)v7 = *(_QWORD *)(i - 16);
            *(_DWORD *)(v7 + 8) = *(_DWORD *)(i - 8);
          }
          *(_QWORD *)(i - 16) = v15;
          *(_DWORD *)(i - 8) = v18;
          if (k < m)
          {
LABEL_50:
            result = std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<long long,int> *,false>(v7, i - 16, a3, a4 & 1);
            a4 = 0;
            continue;
          }
          v32 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<long long,int> *>(v7, i - 16);
          result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<long long,int> *>(i, a2);
          if (!(_DWORD)result)
          {
            if (v32)
              continue;
            goto LABEL_50;
          }
          a2 = i - 16;
          if (v32)
            return result;
          goto LABEL_2;
        }
        v48 = i + 16;
        v50 = i == a2 || v48 == a2;
        if ((a4 & 1) == 0)
        {
          if (v50)
            return result;
          while (1)
          {
            v81 = v7;
            v7 = v48;
            v82 = *(_QWORD *)(v81 + 16);
            v83 = *(_QWORD *)v81;
            if (v82 < *(_QWORD *)v81)
              break;
            if (v83 >= v82)
            {
              v84 = *(_DWORD *)(v81 + 24);
              if (v84 < *(_DWORD *)(v81 + 8))
                goto LABEL_156;
            }
LABEL_160:
            v48 = v7 + 16;
            if (v7 + 16 == a2)
              return result;
          }
          v84 = *(_DWORD *)(v81 + 24);
          do
          {
            do
            {
LABEL_156:
              v85 = v81;
              v86 = v83;
              v87 = *(_QWORD *)(v81 - 16);
              v81 -= 16;
              v83 = v87;
              *(_QWORD *)(v81 + 32) = v86;
              *(_DWORD *)(v81 + 40) = *(_DWORD *)(v81 + 24);
            }
            while (v82 < v87);
          }
          while (v83 >= v82 && v84 < *(_DWORD *)(v85 - 8));
          *(_QWORD *)v85 = v82;
          *(_DWORD *)(v85 + 8) = v84;
          goto LABEL_160;
        }
        if (v50)
          return result;
        v51 = 0;
        v52 = i;
        do
        {
          v53 = v52;
          v52 = v48;
          v54 = *(_QWORD *)(v53 + 16);
          v55 = *(_QWORD *)v53;
          if (v54 >= *(_QWORD *)v53)
          {
            if (v55 < v54)
              goto LABEL_117;
            v56 = *(_DWORD *)(v53 + 24);
            v57 = *(_DWORD *)(v53 + 8);
            if (v56 >= v57)
              goto LABEL_117;
          }
          else
          {
            v56 = *(_DWORD *)(v53 + 24);
            v57 = *(_DWORD *)(v53 + 8);
          }
          *(_QWORD *)(v53 + 16) = v55;
          *(_DWORD *)(v52 + 8) = v57;
          v58 = i;
          if (v53 == i)
            goto LABEL_116;
          v59 = v51;
          while (1)
          {
            v60 = *(_QWORD *)(i + v59 - 16);
            if (v54 >= v60)
              break;
            v61 = *(_DWORD *)(i + v59 - 8);
LABEL_113:
            v53 -= 16;
            v62 = i + v59;
            *(_QWORD *)v62 = v60;
            *(_DWORD *)(v62 + 8) = v61;
            v59 -= 16;
            if (!v59)
            {
              v58 = i;
              goto LABEL_116;
            }
          }
          if (v60 >= v54)
          {
            v58 = i + v59;
            v61 = *(_DWORD *)(i + v59 - 8);
            if (v56 >= v61)
              goto LABEL_116;
            goto LABEL_113;
          }
          v58 = v53;
LABEL_116:
          *(_QWORD *)v58 = v54;
          *(_DWORD *)(v58 + 8) = v56;
LABEL_117:
          v48 = v52 + 16;
          v51 += 16;
        }
        while (v52 + 16 != a2);
        return result;
    }
  }
}

uint64_t cold_shard_get_document_index(uint64_t a1, std::string *this)
{
  std::string *v2;
  std::string::size_type size;
  std::string *v5;
  _QWORD v7[2];

  v2 = this;
  std::string::resize(this, *(_QWORD *)(a1 + 32), 0);
  if (SHIBYTE(v2->__r_.__value_.__r.__words[2]) < 0)
  {
    v5 = v2;
    v2 = (std::string *)v2->__r_.__value_.__r.__words[0];
    size = v5->__r_.__value_.__l.__size_;
  }
  else
  {
    size = HIBYTE(v2->__r_.__value_.__r.__words[2]);
  }
  v7[0] = v2;
  v7[1] = size;
  return preadvall(*(unsigned int *)(a1 + 88), (uint64_t)v7, *(_QWORD *)(a1 + 40));
}

uint64_t __cold_shard_do_document_index_lookups_block_invoke(_QWORD *a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  unint64_t v4;
  unint64_t v5;
  BOOL v6;
  BOOL v7;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v4 = a1[5];
  v5 = a4 + a3;
  if (v4 >= a3)
  {
    v6 = v5 >= v4;
    v7 = v5 == v4;
  }
  else
  {
    v6 = 1;
    v7 = 0;
  }
  if (!v7 && v6)
    return 4294967274;
  v9 = a1[6];
  v10 = *(_QWORD *)(a1[4] + 8);
  v11 = *(_DWORD *)(v10 + 24);
  while (1)
  {
    v12 = v11;
    v13 = *(_QWORD *)(v9 + 16 * v11);
    if (v13 >= a2)
      break;
    *(_DWORD *)(v10 + 24) = v12 + 1;
    v10 = *(_QWORD *)(a1[4] + 8);
    v11 = *(_DWORD *)(v10 + 24);
    if (v11 == ((unint64_t)(a1[7] - v9) >> 4))
      return 1;
  }
  if (v13 == a2)
  {
    v14 = *(int *)(v9 + 16 * v12 + 8);
    v15 = a1[10];
    *(_QWORD *)(a1[9] + 8 * v14) = a3;
    *(_QWORD *)(v15 + 8 * v14) = a4;
    if (++*(_DWORD *)(*(_QWORD *)(a1[4] + 8) + 24) == ((unint64_t)(a1[7] - v9) >> 4))
      return 1;
  }
  return 0;
}

_OWORD *std::vector<std::pair<long long,int>>::__init_with_size[abi:nn180100]<std::pair<long long,int>*,std::pair<long long,int>*>(_OWORD *result, __int128 *a2, __int128 *a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  __int128 v8;

  if (a4)
  {
    if (a4 >> 60)
      abort();
    v6 = result;
    result = std::__allocate_at_least[abi:nn180100]<std::allocator<CFRange>>(a4);
    *v6 = result;
    v6[1] = result;
    v6[2] = &result[v7];
    while (a2 != a3)
    {
      v8 = *a2++;
      *result++ = v8;
    }
    v6[1] = result;
  }
  return result;
}

uint64_t cold_shard_document_index_iterate(unsigned __int8 *a1, unint64_t a2, uint64_t a3)
{
  uint64_t result;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unsigned __int8 *v9;

  v9 = a1;
  v8 = a2;
  if (!a2)
    return 0;
  while (1)
  {
    v6 = 0;
    v7 = 0;
    v5 = 0;
    result = v2_readVInt64((const unsigned __int8 **)&v9, &v8, &v7);
    if ((_DWORD)result)
      break;
    result = v2_readVInt64((const unsigned __int8 **)&v9, &v8, &v6);
    if ((_DWORD)result)
      break;
    result = v2_readVInt64((const unsigned __int8 **)&v9, &v8, &v5);
    if ((_DWORD)result)
      break;
    result = (*(uint64_t (**)(uint64_t, unint64_t, unint64_t, unint64_t))(a3 + 16))(a3, v7, v6, v5);
    if ((_DWORD)result)
      break;
    if (!v8)
      return 0;
  }
  return result;
}

uint64_t v2_readVInt64(const unsigned __int8 **a1, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3;
  char *v5;
  const unsigned __int8 *v6;
  int v7;
  unint64_t v8;
  uint64_t result;
  unint64_t v10;
  BOOL v11;
  unint64_t v12;
  const unsigned __int8 *v13;

  *a3 = 0;
  v3 = *a2;
  if (!*a2)
    return 4294967274;
  v5 = (char *)*a1;
  v6 = *a1 + 1;
  *a1 = v6;
  v7 = *v5;
  v8 = *v5;
  *a2 = v3 - 1;
  if ((v7 & 0x80000000) == 0)
  {
    result = 0;
    *a3 = v8;
    return result;
  }
  if (v7 <= 0xBFu)
  {
    if (v3 != 1)
    {
      result = 0;
      *a3 = v5[1] | ((v8 & 0x3F) << 8);
      *a1 = (const unsigned __int8 *)(v5 + 2);
      v10 = v3 - 2;
LABEL_7:
      *a2 = v10;
      return result;
    }
    return 4294967274;
  }
  if (v7 > 0xDFu)
  {
    if (v7 > 0xEFu)
    {
      if (v7 > 0xF7u)
      {
        if (v7 > 0xFBu)
        {
          if (v7 > 0xFDu)
          {
            if (v7 == 255)
            {
              if (v3 >= 9)
              {
                result = 0;
                *a3 = *(_QWORD *)v6;
                *a1 += 8;
                v10 = *a2 - 8;
                goto LABEL_7;
              }
              return 4294967274;
            }
            v11 = v3 >= 8;
            v12 = v3 - 8;
            if (!v11)
              return 4294967274;
            result = 0;
            *a3 = ((unint64_t)v5[1] << 48) | ((unint64_t)v5[2] << 40) | ((unint64_t)v5[3] << 32) | ((unint64_t)v5[4] << 24) | ((unint64_t)v5[5] << 16) | ((unint64_t)v5[6] << 8) | v5[7];
            v13 = (const unsigned __int8 *)(v5 + 8);
          }
          else
          {
            v11 = v3 >= 7;
            v12 = v3 - 7;
            if (!v11)
              return 4294967274;
            result = 0;
            *a3 = ((v8 & 1) << 48) | ((unint64_t)v5[1] << 40) | ((unint64_t)v5[2] << 32) | ((unint64_t)v5[3] << 24) | ((unint64_t)v5[4] << 16) | ((unint64_t)v5[5] << 8) | v5[6];
            v13 = (const unsigned __int8 *)(v5 + 7);
          }
        }
        else
        {
          v11 = v3 >= 6;
          v12 = v3 - 6;
          if (!v11)
            return 4294967274;
          result = 0;
          *a3 = ((v8 & 3) << 40) | ((unint64_t)v5[1] << 32) | ((unint64_t)v5[2] << 24) | ((unint64_t)v5[3] << 16) | ((unint64_t)v5[4] << 8) | v5[5];
          v13 = (const unsigned __int8 *)(v5 + 6);
        }
      }
      else
      {
        v11 = v3 >= 5;
        v12 = v3 - 5;
        if (!v11)
          return 4294967274;
        result = 0;
        *a3 = ((v8 & 7) << 32) | ((unint64_t)v5[1] << 24) | ((unint64_t)v5[2] << 16) | ((unint64_t)v5[3] << 8) | v5[4];
        v13 = (const unsigned __int8 *)(v5 + 5);
      }
    }
    else
    {
      v11 = v3 >= 4;
      v12 = v3 - 4;
      if (!v11)
        return 4294967274;
      result = 0;
      *a3 = ((v8 & 0xF) << 24) | ((unint64_t)v5[1] << 16) | ((unint64_t)v5[2] << 8) | v5[3];
      v13 = (const unsigned __int8 *)(v5 + 4);
    }
  }
  else
  {
    v11 = v3 >= 3;
    v12 = v3 - 3;
    if (!v11)
      return 4294967274;
    result = 0;
    *a3 = ((v8 & 0x1F) << 16) | ((unint64_t)v5[1] << 8) | v5[2];
    v13 = (const unsigned __int8 *)(v5 + 3);
  }
  *a1 = v13;
  *a2 = v12;
  return result;
}

_OWORD *__copy_helper_block_8_48c53_ZTSNSt3__16vectorINS_4pairIxiEENS_9allocatorIS2_EEEE(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  v2 = a1 + 48;
  *(_QWORD *)(v2 + 16) = 0;
  return std::vector<std::pair<long long,int>>::__init_with_size[abi:nn180100]<std::pair<long long,int>*,std::pair<long long,int>*>((_OWORD *)v2, *(__int128 **)(a2 + 48), *(__int128 **)(a2 + 56), (uint64_t)(*(_QWORD *)(a2 + 56) - *(_QWORD *)(a2 + 48)) >> 4);
}

void __destroy_helper_block_8_48c53_ZTSNSt3__16vectorINS_4pairIxiEENS_9allocatorIS2_EEEE(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(_QWORD *)(a1 + 56) = v2;
    operator delete(v2);
  }
}

uint64_t *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<long long,int> *>(uint64_t *result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  int v16;
  uint64_t v17;
  int v18;

  v3 = *a2;
  v4 = *result;
  if (*a2 >= *result && (v4 < v3 || *((_DWORD *)a2 + 2) >= *((_DWORD *)result + 2)))
  {
    v8 = *a3;
    if (*a3 >= v3)
    {
      if (v3 < v8)
        return result;
      v10 = *((_DWORD *)a3 + 2);
      v9 = *((_DWORD *)a2 + 2);
      if (v10 >= v9)
        return result;
    }
    else
    {
      v9 = *((_DWORD *)a2 + 2);
      v10 = *((_DWORD *)a3 + 2);
    }
    *a2 = v8;
    *a3 = v3;
    *((_DWORD *)a2 + 2) = v10;
    *((_DWORD *)a3 + 2) = v9;
    v11 = *a2;
    v12 = *result;
    if (*a2 >= *result)
    {
      if (v12 < v11)
        return result;
      v14 = *((_DWORD *)a2 + 2);
      v13 = *((_DWORD *)result + 2);
      if (v14 >= v13)
        return result;
    }
    else
    {
      v13 = *((_DWORD *)result + 2);
      v14 = *((_DWORD *)a2 + 2);
    }
    *result = v11;
    *a2 = v12;
    *((_DWORD *)result + 2) = v14;
    *((_DWORD *)a2 + 2) = v13;
    return result;
  }
  v5 = *a3;
  if (*a3 < v3)
  {
    v6 = *((_DWORD *)a3 + 2);
LABEL_6:
    *result = v5;
    *a3 = v4;
    v7 = *((_DWORD *)result + 2);
    *((_DWORD *)result + 2) = v6;
    *((_DWORD *)a3 + 2) = v7;
    return result;
  }
  if (v3 >= v5)
  {
    v6 = *((_DWORD *)a3 + 2);
    v15 = *((_DWORD *)a2 + 2);
    if (v6 < v15)
      goto LABEL_6;
  }
  else
  {
    v15 = *((_DWORD *)a2 + 2);
  }
  *result = v3;
  *a2 = v4;
  v16 = *((_DWORD *)result + 2);
  *((_DWORD *)result + 2) = v15;
  *((_DWORD *)a2 + 2) = v16;
  v17 = *a3;
  if (*a3 < v4)
  {
    v18 = *((_DWORD *)a3 + 2);
LABEL_24:
    *a2 = v17;
    *a3 = v4;
    *((_DWORD *)a2 + 2) = v18;
    *((_DWORD *)a3 + 2) = v16;
    return result;
  }
  if (v4 >= v17)
  {
    v18 = *((_DWORD *)a3 + 2);
    if (v18 < v16)
      goto LABEL_24;
  }
  return result;
}

uint64_t *std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<long long,int> *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *result;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int v20;

  result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<long long,int> *>((uint64_t *)a1, (uint64_t *)a2, (uint64_t *)a3);
  v9 = *(_QWORD *)a4;
  v10 = *(_QWORD *)a3;
  if (*(_QWORD *)a4 >= *(_QWORD *)a3)
  {
    if (v10 < v9)
      return result;
    v12 = *(_DWORD *)(a4 + 8);
    v11 = *(_DWORD *)(a3 + 8);
    if (v12 >= v11)
      return result;
  }
  else
  {
    v11 = *(_DWORD *)(a3 + 8);
    v12 = *(_DWORD *)(a4 + 8);
  }
  *(_QWORD *)a3 = v9;
  *(_QWORD *)a4 = v10;
  *(_DWORD *)(a3 + 8) = v12;
  *(_DWORD *)(a4 + 8) = v11;
  v13 = *(_QWORD *)a3;
  v14 = *(_QWORD *)a2;
  if (*(_QWORD *)a3 >= *(_QWORD *)a2)
  {
    if (v14 < v13)
      return result;
    v16 = *(_DWORD *)(a3 + 8);
    v15 = *(_DWORD *)(a2 + 8);
    if (v16 >= v15)
      return result;
  }
  else
  {
    v15 = *(_DWORD *)(a2 + 8);
    v16 = *(_DWORD *)(a3 + 8);
  }
  *(_QWORD *)a2 = v13;
  *(_QWORD *)a3 = v14;
  *(_DWORD *)(a2 + 8) = v16;
  *(_DWORD *)(a3 + 8) = v15;
  v17 = *(_QWORD *)a2;
  v18 = *(_QWORD *)a1;
  if (*(_QWORD *)a2 < *(_QWORD *)a1)
  {
    v19 = *(_DWORD *)(a1 + 8);
    v20 = *(_DWORD *)(a2 + 8);
LABEL_15:
    *(_QWORD *)a1 = v17;
    *(_QWORD *)a2 = v18;
    *(_DWORD *)(a1 + 8) = v20;
    *(_DWORD *)(a2 + 8) = v19;
    return result;
  }
  if (v18 >= v17)
  {
    v20 = *(_DWORD *)(a2 + 8);
    v19 = *(_DWORD *)(a1 + 8);
    if (v20 < v19)
      goto LABEL_15;
  }
  return result;
}

uint64_t *std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<long long,int> *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  uint64_t *result;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  int v26;

  result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<long long,int> *>(a1, a2, a3, a4);
  v11 = *a5;
  v12 = *(_QWORD *)a4;
  if (*a5 >= *(_QWORD *)a4)
  {
    if (v12 < v11)
      return result;
    v14 = *((_DWORD *)a5 + 2);
    v13 = *(_DWORD *)(a4 + 8);
    if (v14 >= v13)
      return result;
  }
  else
  {
    v13 = *(_DWORD *)(a4 + 8);
    v14 = *((_DWORD *)a5 + 2);
  }
  *(_QWORD *)a4 = v11;
  *a5 = v12;
  *(_DWORD *)(a4 + 8) = v14;
  *((_DWORD *)a5 + 2) = v13;
  v15 = *(_QWORD *)a4;
  v16 = *(_QWORD *)a3;
  if (*(_QWORD *)a4 >= *(_QWORD *)a3)
  {
    if (v16 < v15)
      return result;
    v18 = *(_DWORD *)(a4 + 8);
    v17 = *(_DWORD *)(a3 + 8);
    if (v18 >= v17)
      return result;
  }
  else
  {
    v17 = *(_DWORD *)(a3 + 8);
    v18 = *(_DWORD *)(a4 + 8);
  }
  *(_QWORD *)a3 = v15;
  *(_QWORD *)a4 = v16;
  *(_DWORD *)(a3 + 8) = v18;
  *(_DWORD *)(a4 + 8) = v17;
  v19 = *(_QWORD *)a3;
  v20 = *(_QWORD *)a2;
  if (*(_QWORD *)a3 >= *(_QWORD *)a2)
  {
    if (v20 < v19)
      return result;
    v22 = *(_DWORD *)(a3 + 8);
    v21 = *(_DWORD *)(a2 + 8);
    if (v22 >= v21)
      return result;
  }
  else
  {
    v21 = *(_DWORD *)(a2 + 8);
    v22 = *(_DWORD *)(a3 + 8);
  }
  *(_QWORD *)a2 = v19;
  *(_QWORD *)a3 = v20;
  *(_DWORD *)(a2 + 8) = v22;
  *(_DWORD *)(a3 + 8) = v21;
  v23 = *(_QWORD *)a2;
  v24 = *(_QWORD *)a1;
  if (*(_QWORD *)a2 < *(_QWORD *)a1)
  {
    v25 = *(_DWORD *)(a1 + 8);
    v26 = *(_DWORD *)(a2 + 8);
LABEL_9:
    *(_QWORD *)a1 = v23;
    *(_QWORD *)a2 = v24;
    *(_DWORD *)(a1 + 8) = v26;
    *(_DWORD *)(a2 + 8) = v25;
    return result;
  }
  if (v24 >= v23)
  {
    v26 = *(_DWORD *)(a2 + 8);
    v25 = *(_DWORD *)(a1 + 8);
    if (v26 < v25)
      goto LABEL_9;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<long long,int> *>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _BOOL8 result;
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;

  v4 = (a2 - a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = *(_QWORD *)(a2 - 16);
      v7 = *(_QWORD *)a1;
      if (v6 < *(_QWORD *)a1)
      {
        v8 = *(_DWORD *)(a1 + 8);
        v9 = *(_DWORD *)(a2 - 8);
LABEL_30:
        *(_QWORD *)a1 = v6;
        *(_QWORD *)(a2 - 16) = v7;
        *(_DWORD *)(a1 + 8) = v9;
        *(_DWORD *)(a2 - 8) = v8;
        return result;
      }
      if (v7 >= v6)
      {
        v9 = *(_DWORD *)(a2 - 8);
        v8 = *(_DWORD *)(a1 + 8);
        if (v9 < v8)
          goto LABEL_30;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<long long,int> *>((uint64_t *)a1, (uint64_t *)(a1 + 16), (uint64_t *)(a2 - 16));
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<long long,int> *>(a1, a1 + 16, a1 + 32, a2 - 16);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<long long,int> *>(a1, a1 + 16, a1 + 32, a1 + 48, (uint64_t *)(a2 - 16));
      return 1;
    default:
      v10 = a1 + 32;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<long long,int> *>((uint64_t *)a1, (uint64_t *)(a1 + 16), (uint64_t *)(a1 + 32));
      v11 = a1 + 48;
      if (a1 + 48 == a2)
        return 1;
      v12 = 0;
      v13 = 0;
      break;
  }
LABEL_6:
  v14 = *(_QWORD *)v11;
  v15 = *(_QWORD *)v10;
  if (*(_QWORD *)v11 >= *(_QWORD *)v10)
  {
    if (v15 < v14)
      goto LABEL_21;
    v16 = *(_DWORD *)(v11 + 8);
    v17 = *(_DWORD *)(v10 + 8);
    if (v16 >= v17)
      goto LABEL_21;
  }
  else
  {
    v16 = *(_DWORD *)(v11 + 8);
    v17 = *(_DWORD *)(v10 + 8);
  }
  *(_QWORD *)v11 = v15;
  *(_DWORD *)(v11 + 8) = v17;
  v18 = a1;
  if (v10 == a1)
    goto LABEL_20;
  v19 = v12;
  while (1)
  {
    v20 = a1 + v19;
    v21 = *(_QWORD *)(a1 + v19 + 16);
    if (v14 >= v21)
    {
      if (v21 < v14)
      {
        v18 = v10;
        goto LABEL_20;
      }
      v22 = *(_DWORD *)(a1 + v19 + 24);
      if (v16 >= v22)
      {
        v18 = a1 + v19 + 32;
LABEL_20:
        *(_QWORD *)v18 = v14;
        *(_DWORD *)(v18 + 8) = v16;
        if (++v13 == 8)
          return v11 + 16 == a2;
LABEL_21:
        v10 = v11;
        v12 += 16;
        v11 += 16;
        if (v11 == a2)
          return 1;
        goto LABEL_6;
      }
    }
    else
    {
      v22 = *(_DWORD *)(v20 + 24);
    }
    v10 -= 16;
    *(_QWORD *)(v20 + 32) = v21;
    *(_DWORD *)(a1 + v19 + 40) = v22;
    v19 -= 16;
    if (v19 == -32)
    {
      v18 = a1;
      goto LABEL_20;
    }
  }
}

void std::vector<unsigned long long>::resize(char **a1, unint64_t a2)
{
  char *v3;
  char *v4;
  unint64_t v5;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  char *v11;
  char *v12;
  char *v13;
  char *v14;
  uint64_t v15;
  char *v16;
  char *v17;
  uint64_t v18;
  char *v19;

  v3 = *a1;
  v4 = a1[1];
  v5 = (v4 - *a1) >> 3;
  if (a2 <= v5)
  {
    if (a2 >= v5)
      return;
    v19 = &v3[8 * a2];
    goto LABEL_15;
  }
  v6 = a2 - v5;
  v7 = a1[2];
  if (a2 - v5 <= (v7 - v4) >> 3)
  {
    bzero(a1[1], 8 * v6);
    v19 = &v4[8 * v6];
LABEL_15:
    a1[1] = v19;
    return;
  }
  if (a2 >> 61)
    abort();
  v8 = v7 - v3;
  v9 = v8 >> 2;
  if (v8 >> 2 <= a2)
    v9 = a2;
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8)
    v10 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v10 = v9;
  v11 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v10);
  v12 = *a1;
  v13 = a1[1];
  v14 = &v11[8 * v5];
  v16 = &v11[8 * v15];
  bzero(v14, 8 * v6);
  v17 = &v14[8 * v6];
  while (v13 != v12)
  {
    v18 = *((_QWORD *)v13 - 1);
    v13 -= 8;
    *((_QWORD *)v14 - 1) = v18;
    v14 -= 8;
  }
  *a1 = v14;
  a1[1] = v17;
  a1[2] = v16;
  if (v12)
    operator delete(v12);
}

uint64_t cold_shard_delete_docs(uint64_t *a1, unint64_t a2, const void *a3, int64x2_t *a4)
{
  int64x2_t *v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  void *__p;
  uint64_t *v24;
  uint64_t v25;
  void *v26;
  void *v27;
  uint64_t v28;
  void *v29;
  _BYTE *v30;
  uint64_t v31;
  char v32;

  a4->i64[0] = 0;
  a4->i64[1] = a1[7];
  a4[1].i64[0] = 0;
  v8 = a4 + 1;
  a4[1].i64[1] = 0;
  v29 = 0;
  v30 = 0;
  v31 = 0;
  v26 = 0;
  v27 = 0;
  v28 = 0;
  __p = 0;
  v24 = 0;
  v25 = 0;
  v9 = do_unpack_coldshard_docidx((uint64_t)a1, (uint64_t)&v29, (uint64_t)&v26, (uint64_t)&__p);
  if (!(_DWORD)v9)
  {
    v10 = (uint64_t *)__p;
    v11 = v24;
    if (__p != v24)
    {
      v12 = a4->i64[0];
      v13 = a4[1].i64[1] + 1;
      do
      {
        v14 = *v10++;
        v12 += v14;
        a4->i64[0] = v12;
        a4[1].i64[1] = v13++;
      }
      while (v10 != v11);
    }
    if (a2)
    {
      if (a2 >> 61)
        abort();
      v15 = std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(a2);
      memmove(v15, a3, 8 * a2);
      v32 = 0;
      std::__sort<std::__less<long long,long long> &,long long *>();
      if ((_DWORD)a2)
      {
        v16 = 0;
        v17 = 0;
        while (v17 != ((unint64_t)(v30 - (_BYTE *)v29) >> 3))
        {
          v18 = *((_QWORD *)v29 + v17);
          v19 = *((_QWORD *)v15 + v16);
          if (v18 >= v19)
          {
            if (v19 >= v18)
            {
              v20 = __p;
              a4->i64[0] -= *((_QWORD *)__p + v17);
              a4[1] = vaddq_s64(a4[1], (int64x2_t)xmmword_1B8631EE0);
              v21 = do_erase_doc((uint64_t)a1, *((_QWORD *)v26 + v17), v20[v17]);
              if ((_DWORD)v21)
              {
                v9 = v21;
                goto LABEL_23;
              }
              *((_QWORD *)v26 + v17++) = -1;
            }
            ++v16;
          }
          else
          {
            ++v17;
          }
          if (v16 == (_DWORD)a2)
            break;
        }
      }
    }
    else
    {
      v32 = 0;
      std::__sort<std::__less<long long,long long> &,long long *>();
      v15 = 0;
    }
    if (!v8->i64[0] || (v9 = do_rebuild_coldshard_docidx(a1, (uint64_t *)&v29, &v26, &__p), !(_DWORD)v9))
      v9 = 0;
    if (v15)
LABEL_23:
      operator delete(v15);
  }
  if (__p)
  {
    v24 = (uint64_t *)__p;
    operator delete(__p);
  }
  if (v26)
  {
    v27 = v26;
    operator delete(v26);
  }
  if (v29)
  {
    v30 = v29;
    operator delete(v29);
  }
  return v9;
}

uint64_t do_unpack_coldshard_docidx(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t document_index;
  std::string *p_p;
  std::string::size_type size;
  _QWORD v11[7];
  std::string __p;

  memset(&__p, 0, sizeof(__p));
  document_index = cold_shard_get_document_index(a1, &__p);
  if (!(_DWORD)document_index)
  {
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      p_p = &__p;
    else
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
    else
      size = __p.__r_.__value_.__l.__size_;
    v11[0] = MEMORY[0x1E0C809B0];
    v11[1] = 0x40000000;
    v11[2] = ___ZL26do_unpack_coldshard_docidxP22ColdShardSearchContextRNSt3__16vectorIxNS1_9allocatorIxEEEERNS2_IyNS3_IyEEEES9_P18DeletionStatistics_block_invoke;
    v11[3] = &__block_descriptor_tmp_8_5661;
    v11[4] = a2;
    v11[5] = a3;
    v11[6] = a4;
    document_index = cold_shard_document_index_iterate((unsigned __int8 *)p_p, size, (uint64_t)v11);
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  return document_index;
}

uint64_t do_erase_doc(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t result;
  _OWORD v12[16];
  _OWORD v13[16];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  memset(v13, 0, sizeof(v13));
  memset(v12, 0, sizeof(v12));
  while (a3)
  {
    v6 = 0;
    v7 = 0;
    v8 = (uint64_t *)v12 + 1;
    do
    {
      v9 = v6;
      if (a3 >= 0x100)
        v10 = 256;
      else
        v10 = a3;
      *(v8 - 1) = (uint64_t)v13;
      *v8 = v10;
      a3 -= v10;
      v7 += v10;
      ++v6;
      if (v9 > 0xE)
        break;
      v8 += 2;
    }
    while (a3);
    result = pwritevall(*(unsigned int *)(a1 + 88), v12, v6, *(_QWORD *)(a1 + 64) + a2);
    a2 += v7;
    if ((_DWORD)result)
      return result;
  }
  return 0;
}

uint64_t do_rebuild_coldshard_docidx(uint64_t *a1, uint64_t *a2, _QWORD *a3, _QWORD *a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t *v22;
  unint64_t *v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t *v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t *v34;
  unint64_t v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  std::string::size_type size;
  std::string::size_type v41;
  int v42;
  uint64_t v43;
  _QWORD *v44;
  std::string::size_type v45;
  std::string::size_type v46;
  off_t v47;
  std::string *v48;
  uint64_t v49;
  std::string::size_type v50;
  char *v52;
  std::string v53;
  std::string::value_type __s[16];
  __int128 v55;
  __int128 v56;
  __int128 v57;
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  memset(&v53, 0, sizeof(v53));
  v5 = *a2;
  v6 = a2[1];
  if ((int)((unint64_t)(v6 - *a2) >> 3) >= 1)
  {
    v10 = 0;
    do
    {
      if (*(_QWORD *)(*a3 + 8 * v10) != -1)
      {
        v56 = 0u;
        v57 = 0u;
        *(_OWORD *)__s = 0u;
        v55 = 0u;
        v52 = __s;
        v2_writeVInt64((unint64_t **)&v52, *(_QWORD *)(v5 + 8 * v10));
        v2_writeVInt64((unint64_t **)&v52, *(_QWORD *)(*a3 + 8 * v10));
        v2_writeVInt64((unint64_t **)&v52, *(_QWORD *)(*a4 + 8 * v10));
        std::string::append(&v53, __s, v52 - __s);
        v5 = *a2;
        v6 = a2[1];
      }
      ++v10;
    }
    while (v10 < (int)((unint64_t)(v6 - v5) >> 3));
  }
  v12 = *a1;
  v11 = a1[1];
  v13 = operator new(0x10uLL);
  *v13 = v11;
  v13[1] = v12;
  v15 = a1[4];
  v14 = a1[5];
  v16 = std::__allocate_at_least[abi:nn180100]<std::allocator<CFRange>>(2uLL);
  v18 = v17;
  v19 = &v16[2 * v17];
  v16[2] = v14;
  v16[3] = v15;
  *(_OWORD *)v16 = *(_OWORD *)v13;
  operator delete(v13);
  v20 = a1[7];
  v21 = a1[8];
  if (v18 < 3)
  {
    v24 = 3;
    if ((unint64_t)(v19 - v16) > 3)
      v24 = v19 - v16;
    if ((unint64_t)((char *)v19 - (char *)v16) >= 0x7FFFFFFFFFFFFFF0)
      v25 = 0xFFFFFFFFFFFFFFFLL;
    else
      v25 = v24;
    if (v25)
      v25 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<CFRange>>(v25);
    else
      v26 = 0;
    v27 = 0;
    v19 = (unint64_t *)(v25 + 16 * v26);
    *(_QWORD *)(v25 + 32) = v21;
    *(_QWORD *)(v25 + 40) = v20;
    v22 = (unint64_t *)(v25 + 48);
    do
    {
      *(_OWORD *)(v25 + 32 + v27 * 8 - 16) = *(_OWORD *)&v16[v27 + 2];
      v27 -= 2;
    }
    while (v27 != -4);
    v23 = (unint64_t *)v25;
    if (v16)
      operator delete(v16);
  }
  else
  {
    v16[4] = v21;
    v16[5] = v20;
    v22 = v16 + 6;
    v23 = v16;
  }
  v28 = a1[2];
  v29 = a1[3];
  if (v22 >= v19)
  {
    v31 = ((char *)v22 - (char *)v23) >> 4;
    v32 = v31 + 1;
    if ((unint64_t)(v31 + 1) >> 60)
      abort();
    if (v19 - v23 > v32)
      v32 = v19 - v23;
    if ((unint64_t)((char *)v19 - (char *)v23) >= 0x7FFFFFFFFFFFFFF0)
      v33 = 0xFFFFFFFFFFFFFFFLL;
    else
      v33 = v32;
    if (v33)
      v33 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<CFRange>>(v33);
    v34 = (unint64_t *)(v33 + 16 * v31);
    *v34 = v29;
    v34[1] = v28;
    v30 = v34 + 2;
    if (v22 == v23)
      goto LABEL_33;
    do
    {
      *((_OWORD *)v34 - 1) = *((_OWORD *)v22 - 1);
      v34 -= 2;
      v22 -= 2;
    }
    while (v22 != v23);
    if (v23)
LABEL_33:
      operator delete(v23);
    v23 = v34;
  }
  else
  {
    *v22 = v29;
    v22[1] = v28;
    v30 = v22 + 2;
  }
  v35 = 126 - 2 * __clz(((char *)v30 - (char *)v23) >> 4);
  v36 = (char *)v30 - (char *)v23;
  if (v30 == v23)
    v37 = 0;
  else
    v37 = v35;
  std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *,false>((unint64_t)v23, v30, v37, 1);
  v38 = 0;
  v39 = v36 >> 4;
  size = v53.__r_.__value_.__l.__size_;
  if ((v53.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v41 = HIBYTE(v53.__r_.__value_.__r.__words[2]);
  else
    v41 = v53.__r_.__value_.__l.__size_;
  v42 = v39 - 1;
  v43 = v39 & ~((int)v39 >> 31);
  v44 = v23 + 1;
  while (v43 != v38)
  {
    if ((v36 >> 4) - 1 == v38)
      goto LABEL_47;
    v45 = v44[1];
    v46 = *v44 + *(v44 - 1) + v41;
    v44 += 2;
    ++v38;
    if (v46 <= v45)
    {
      v42 = v38 - 1;
      goto LABEL_47;
    }
  }
  v42 = -1;
LABEL_47:
  v47 = v23[2 * v42 + 1] + v23[2 * v42];
  if ((*((_BYTE *)&v53.__r_.__value_.__s + 23) & 0x80) != 0)
  {
    if (!v53.__r_.__value_.__l.__size_)
    {
      a1[5] = v47;
LABEL_58:
      v50 = v53.__r_.__value_.__l.__size_;
      goto LABEL_59;
    }
    v48 = (std::string *)v53.__r_.__value_.__r.__words[0];
  }
  else
  {
    if (!*((_BYTE *)&v53.__r_.__value_.__s + 23))
    {
      LOBYTE(v50) = 0;
      a1[5] = v47;
      goto LABEL_56;
    }
    v48 = &v53;
    size = HIBYTE(v53.__r_.__value_.__r.__words[2]);
  }
  *(_QWORD *)__s = v48;
  *(_QWORD *)&__s[8] = size;
  v49 = pwritevall(*((unsigned int *)a1 + 22), __s, 1, v47);
  if ((_DWORD)v49)
    goto LABEL_60;
  LODWORD(v50) = SHIBYTE(v53.__r_.__value_.__r.__words[2]);
  a1[5] = v47;
  if ((v50 & 0x80000000) != 0)
    goto LABEL_58;
LABEL_56:
  v50 = v50;
LABEL_59:
  a1[4] = v50;
  *(_QWORD *)__s = a1;
  *(_QWORD *)&__s[8] = 88;
  v49 = pwritevall(*((unsigned int *)a1 + 22), __s, 1, 0);
LABEL_60:
  operator delete(v23);
  if (SHIBYTE(v53.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v53.__r_.__value_.__l.__data_);
  return v49;
}

unint64_t std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *,false>(unint64_t result, unint64_t *a2, uint64_t a3, char a4)
{
  unint64_t *v7;
  unint64_t *v8;
  unint64_t *i;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t *v13;
  __int128 v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t *k;
  unint64_t v20;
  unint64_t v21;
  unint64_t *m;
  unint64_t v23;
  unint64_t v24;
  unint64_t v26;
  unint64_t v27;
  unint64_t *v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  BOOL v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t *j;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t *v46;
  BOOL v48;
  uint64_t v49;
  unint64_t *v50;
  unint64_t *v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t *v55;
  uint64_t v56;
  unint64_t v57;
  unint64_t v58;
  unint64_t *v59;
  int64_t v60;
  int64_t v61;
  int64_t v62;
  uint64_t v63;
  unint64_t *v64;
  unint64_t v65;
  unint64_t *v66;
  unint64_t v67;
  unint64_t v68;
  unint64_t v69;
  unint64_t *v70;
  uint64_t v71;
  uint64_t v72;
  unint64_t v73;
  unint64_t v74;
  unint64_t *v75;
  unint64_t v76;
  unint64_t v77;
  unint64_t v78;
  unint64_t *v79;
  unint64_t v80;
  unint64_t v81;
  unint64_t v82;
  uint64_t v83;
  int64_t v84;
  unint64_t v85;
  unint64_t v86;
  uint64_t v87;
  uint64_t v88;
  unint64_t *v89;
  unint64_t *v90;
  int64_t v91;
  uint64_t v92;
  uint64_t v93;
  unint64_t v94;
  uint64_t v95;
  unint64_t v96;
  unint64_t v97;
  unint64_t *v98;
  unint64_t v99;
  unint64_t v100;
  unint64_t v101;
  unint64_t *v102;
  unint64_t v103;
  unint64_t v104;

  v7 = (unint64_t *)result;
LABEL_2:
  v8 = a2 - 2;
  i = v7;
  while (2)
  {
    v7 = i;
    v10 = (char *)a2 - (char *)i;
    v11 = ((char *)a2 - (char *)i) >> 4;
    switch(v11)
    {
      case 0uLL:
      case 1uLL:
        return result;
      case 2uLL:
        v43 = *v8;
        v44 = *i;
        if (*v8 < *i || v44 >= v43 && *(a2 - 1) < i[1])
        {
          *i = v43;
          *(a2 - 2) = v44;
          v45 = i[1];
          i[1] = *(a2 - 1);
          *(a2 - 1) = v45;
        }
        return result;
      case 3uLL:
        return (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(i, i + 2, a2 - 2);
      case 4uLL:
        return (unint64_t)std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(i, i + 2, i + 4, a2 - 2);
      case 5uLL:
        return (unint64_t)std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(i, i + 2, i + 4, i + 6, a2 - 2);
      default:
        if (v10 > 383)
        {
          if (!a3)
          {
            if (i == a2)
              return result;
            v60 = (v11 - 2) >> 1;
            v61 = v60;
            while (1)
            {
              v62 = v61;
              if (v60 >= v61)
              {
                v63 = (2 * v61) | 1;
                v64 = &i[2 * v63];
                if (2 * v62 + 2 < (uint64_t)v11)
                {
                  v65 = v64[2];
                  if (*v64 < v65 || v65 >= *v64 && i[2 * v63 + 1] < v64[3])
                  {
                    v64 += 2;
                    v63 = 2 * v62 + 2;
                  }
                }
                v66 = &i[2 * v62];
                v67 = *v64;
                v68 = *v66;
                if (*v64 >= *v66)
                {
                  if (v68 < v67)
                  {
                    v69 = v66[1];
LABEL_129:
                    *v66 = v67;
                    v66[1] = v64[1];
                    if (v60 >= v63)
                    {
                      while (1)
                      {
                        v71 = 2 * v63;
                        v63 = (2 * v63) | 1;
                        v70 = &i[2 * v63];
                        v72 = v71 + 2;
                        if (v72 < (uint64_t)v11)
                        {
                          v73 = v70[2];
                          if (*v70 < v73 || v73 >= *v70 && i[2 * v63 + 1] < v70[3])
                          {
                            v70 += 2;
                            v63 = v72;
                          }
                        }
                        v74 = *v70;
                        if (*v70 < v68 || v68 >= v74 && v70[1] < v69)
                          break;
                        *v64 = v74;
                        v64[1] = v70[1];
                        v64 = v70;
                        if (v60 < v63)
                          goto LABEL_131;
                      }
                    }
                    v70 = v64;
LABEL_131:
                    *v70 = v68;
                    v70[1] = v69;
                    goto LABEL_132;
                  }
                  v69 = i[2 * v62 + 1];
                  if (v64[1] >= v69)
                    goto LABEL_129;
                }
              }
LABEL_132:
              v61 = v62 - 1;
              if (!v62)
              {
                v83 = (unint64_t)v10 >> 4;
                while (1)
                {
                  v84 = 0;
                  v85 = *i;
                  v86 = i[1];
                  v87 = v83 - 2;
                  if (v83 < 2)
                    v87 = v83 - 1;
                  v88 = v87 >> 1;
                  v89 = i;
                  do
                  {
                    v90 = v89;
                    v91 = v84 + 1;
                    v89 += 2 * v84 + 2;
                    v92 = 2 * v84;
                    result = (2 * v84) | 1;
                    v84 = result;
                    v93 = v92 + 2;
                    if (v93 < v83)
                    {
                      result = (unint64_t)(v89 + 2);
                      v94 = v89[2];
                      if (*v89 < v94 || v94 >= *v89 && v90[2 * v91 + 1] < v89[3])
                      {
                        v89 += 2;
                        v84 = v93;
                      }
                    }
                    *v90 = *v89;
                    v90[1] = v89[1];
                  }
                  while (v84 <= v88);
                  if (v89 == a2 - 2)
                  {
                    *v89 = v85;
                    v89[1] = v86;
                  }
                  else
                  {
                    *v89 = *(a2 - 2);
                    v89[1] = *(a2 - 1);
                    *(a2 - 2) = v85;
                    *(a2 - 1) = v86;
                    v95 = (char *)v89 - (char *)i + 16;
                    if (v95 >= 17)
                    {
                      v96 = (v95 >> 4) - 2;
                      v97 = v96 >> 1;
                      v98 = &i[2 * (v96 >> 1)];
                      v99 = *v98;
                      v100 = *v89;
                      if (*v98 < *v89)
                      {
                        v101 = v89[1];
LABEL_171:
                        *v89 = v99;
                        v89[1] = i[2 * v97 + 1];
                        if (v96 >= 2)
                        {
                          while (1)
                          {
                            v103 = v97 - 1;
                            v97 = (v97 - 1) >> 1;
                            v102 = &i[2 * v97];
                            v104 = *v102;
                            if (*v102 >= v100)
                            {
                              if (v100 < v104)
                                break;
                              result = i[2 * v97 + 1];
                              if (result >= v101)
                                break;
                            }
                            else
                            {
                              result = v102[1];
                            }
                            *v98 = v104;
                            v98[1] = result;
                            v98 = &i[2 * v97];
                            if (v103 <= 1)
                              goto LABEL_178;
                          }
                        }
                        v102 = v98;
LABEL_178:
                        *v102 = v100;
                        v102[1] = v101;
                        goto LABEL_180;
                      }
                      if (v100 >= v99)
                      {
                        result = i[2 * v97 + 1];
                        v101 = v89[1];
                        if (result < v101)
                          goto LABEL_171;
                      }
                    }
                  }
LABEL_180:
                  a2 -= 2;
                  if (v83-- <= 2)
                    return result;
                }
              }
            }
          }
          v12 = v11 >> 1;
          v13 = &i[2 * (v11 >> 1)];
          if ((unint64_t)v10 < 0x801)
          {
            result = (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(&v7[2 * (v11 >> 1)], v7, a2 - 2);
          }
          else
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(v7, &v7[2 * (v11 >> 1)], a2 - 2);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(v7 + 2, v13 - 2, a2 - 4);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(v7 + 4, &v7[2 * v12 + 2], a2 - 6);
            result = (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(v13 - 2, v13, &v7[2 * v12 + 2]);
            v14 = *(_OWORD *)v7;
            *(_OWORD *)v7 = *(_OWORD *)v13;
            *(_OWORD *)v13 = v14;
          }
          --a3;
          v15 = *v7;
          if ((a4 & 1) == 0)
          {
            v16 = *(v7 - 2);
            if (v16 >= v15)
            {
              if (v15 < v16)
              {
                v17 = v7[1];
              }
              else
              {
                v17 = v7[1];
                if (*(v7 - 1) < v17)
                  goto LABEL_13;
              }
              v33 = *v8;
              if (v15 >= *v8 && (v33 < v15 || v17 >= *(a2 - 1)))
              {
                for (i = v7 + 2; i < a2 && v15 >= *i && (*i < v15 || v17 >= i[1]); i += 2)
                  ;
              }
              else
              {
                i = v7;
                do
                {
                  v35 = i[2];
                  i += 2;
                  v34 = v35;
                }
                while (v15 >= v35 && (v34 < v15 || v17 >= i[1]));
              }
              j = a2;
              if (i < a2)
              {
                for (j = a2 - 2; v15 < v33 || v33 >= v15 && v17 < j[1]; j -= 2)
                {
                  v37 = *(j - 2);
                  v33 = v37;
                }
              }
              if (i < j)
              {
                v38 = *i;
                v39 = *j;
                do
                {
                  *i = v39;
                  *j = v38;
                  v40 = i[1];
                  i[1] = j[1];
                  j[1] = v40;
                  do
                  {
                    v41 = i[2];
                    i += 2;
                    v38 = v41;
                  }
                  while (v15 >= v41 && (v38 < v15 || v17 >= i[1]));
                  do
                  {
                    do
                    {
                      v42 = *(j - 2);
                      j -= 2;
                      v39 = v42;
                    }
                    while (v15 < v42);
                  }
                  while (v39 >= v15 && v17 < j[1]);
                }
                while (i < j);
              }
              if (i - 2 != v7)
              {
                *v7 = *(i - 2);
                v7[1] = *(i - 1);
              }
              a4 = 0;
              *(i - 2) = v15;
              *(i - 1) = v17;
              continue;
            }
          }
LABEL_13:
          v18 = v7[1];
          for (k = v7 + 2; ; k += 2)
          {
            v20 = *k;
            if (*k >= v15 && (v15 < v20 || k[1] >= v18))
              break;
          }
          if (k - 2 == v7)
          {
            m = a2;
            if (k < a2)
            {
              v24 = *v8;
              m = a2 - 2;
              if (*v8 >= v15)
              {
                m = a2 - 2;
                do
                {
                  if (v15 >= v24)
                  {
                    if (m[1] < v18 || k >= m)
                      break;
                  }
                  else if (k >= m)
                  {
                    break;
                  }
                  v26 = *(m - 2);
                  m -= 2;
                  v24 = v26;
                }
                while (v26 >= v15);
              }
            }
          }
          else
          {
            v21 = *v8;
            for (m = a2 - 2; v21 >= v15 && (v15 < v21 || m[1] >= v18); m -= 2)
            {
              v23 = *(m - 2);
              v21 = v23;
            }
          }
          i = k;
          if (k < m)
          {
            v27 = *m;
            v28 = m;
            i = k;
            do
            {
              *i = v27;
              *v28 = v20;
              v29 = i[1];
              i[1] = v28[1];
              v28[1] = v29;
              do
              {
                do
                {
                  v30 = i[2];
                  i += 2;
                  v20 = v30;
                }
                while (v30 < v15);
              }
              while (v15 >= v20 && i[1] < v18);
              do
              {
                v31 = *(v28 - 2);
                v28 -= 2;
                v27 = v31;
              }
              while (v31 >= v15 && (v15 < v27 || v28[1] >= v18));
            }
            while (i < v28);
          }
          if (i - 2 != v7)
          {
            *v7 = *(i - 2);
            v7[1] = *(i - 1);
          }
          *(i - 2) = v15;
          *(i - 1) = v18;
          if (k < m)
          {
LABEL_50:
            result = std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *,false>(v7, i - 2, a3, a4 & 1);
            a4 = 0;
            continue;
          }
          v32 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(v7, i - 2);
          result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(i, a2);
          if (!(_DWORD)result)
          {
            if (v32)
              continue;
            goto LABEL_50;
          }
          a2 = i - 2;
          if (v32)
            return result;
          goto LABEL_2;
        }
        v46 = i + 2;
        v48 = i == a2 || v46 == a2;
        if ((a4 & 1) == 0)
        {
          if (v48)
            return result;
          while (1)
          {
            v75 = v7;
            v7 = v46;
            v76 = v75[2];
            v77 = *v75;
            if (v76 < *v75)
              break;
            if (v77 >= v76)
            {
              v78 = v75[3];
              if (v78 < v75[1])
                goto LABEL_152;
            }
LABEL_156:
            v46 = v7 + 2;
            if (v7 + 2 == a2)
              return result;
          }
          v78 = v75[3];
          do
          {
            do
            {
LABEL_152:
              v79 = v75;
              v80 = v77;
              v81 = *(v75 - 2);
              v75 -= 2;
              v77 = v81;
              v82 = v75[3];
              v75[4] = v80;
              v75[5] = v82;
            }
            while (v76 < v81);
          }
          while (v77 >= v76 && v78 < *(v79 - 1));
          *v79 = v76;
          v79[1] = v78;
          goto LABEL_156;
        }
        if (v48)
          return result;
        v49 = 0;
        v50 = i;
        do
        {
          v51 = v50;
          v50 = v46;
          v52 = v51[2];
          v53 = *v51;
          if (v52 >= *v51)
          {
            if (v53 < v52)
              goto LABEL_115;
            v54 = v51[3];
            if (v54 >= v51[1])
              goto LABEL_115;
          }
          else
          {
            v54 = v51[3];
          }
          v51[2] = v53;
          v50[1] = v51[1];
          v55 = i;
          if (v51 == i)
            goto LABEL_114;
          v56 = v49;
          while (1)
          {
            v57 = *(unint64_t *)((char *)i + v56 - 16);
            if (v52 >= v57)
              break;
            v58 = *(unint64_t *)((char *)i + v56 - 8);
LABEL_111:
            v51 -= 2;
            v59 = (unint64_t *)((char *)i + v56);
            *v59 = v57;
            v59[1] = v58;
            v56 -= 16;
            if (!v56)
            {
              v55 = i;
              goto LABEL_114;
            }
          }
          if (v57 >= v52)
          {
            v55 = (unint64_t *)((char *)i + v56);
            v58 = *(unint64_t *)((char *)i + v56 - 8);
            if (v54 >= v58)
              goto LABEL_114;
            goto LABEL_111;
          }
          v55 = v51;
LABEL_114:
          *v55 = v52;
          v55[1] = v54;
LABEL_115:
          v46 = v50 + 2;
          v49 += 16;
        }
        while (v50 + 2 != a2);
        return result;
    }
  }
}

unint64_t *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(unint64_t *result, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;

  v3 = *a2;
  v4 = *result;
  if (*a2 >= *result && (v4 < v3 || a2[1] >= result[1]))
  {
    v7 = *a3;
    if (*a3 < v3 || v3 >= v7 && a3[1] < a2[1])
    {
      *a2 = v7;
      *a3 = v3;
      v8 = a2 + 1;
      v9 = a2[1];
      a2[1] = a3[1];
      a3[1] = v9;
      v10 = *a2;
      v11 = *result;
      if (*a2 < *result || v11 >= v10 && *v8 < result[1])
      {
        *result++ = v10;
        *a2 = v11;
LABEL_18:
        v15 = *result;
        *result = *v8;
        *v8 = v15;
      }
    }
  }
  else
  {
    v5 = *a3;
    if (*a3 < v3 || v3 >= v5 && a3[1] < a2[1])
    {
      *result++ = v5;
      *a3 = v4;
      v6 = a3 + 1;
LABEL_17:
      v8 = v6;
      goto LABEL_18;
    }
    *result = v3;
    *a2 = v4;
    v12 = result[1];
    result[1] = a2[1];
    a2[1] = v12;
    v13 = *a3;
    v14 = *a2;
    if (*a3 < *a2 || v14 >= v13 && a3[1] < v12)
    {
      *a2 = v13;
      *a3 = v14;
      v6 = a3 + 1;
      result = a2 + 1;
      goto LABEL_17;
    }
  }
  return result;
}

unint64_t *std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(unint64_t *a1, unint64_t *a2, unint64_t *a3, unint64_t *a4)
{
  unint64_t *result;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;

  result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(a1, a2, a3);
  v9 = *a4;
  v10 = *a3;
  if (*a4 < *a3 || v10 >= v9 && a4[1] < a3[1])
  {
    *a3 = v9;
    *a4 = v10;
    v11 = a3[1];
    a3[1] = a4[1];
    a4[1] = v11;
    v12 = *a3;
    v13 = *a2;
    if (*a3 < *a2 || v13 >= v12 && a3[1] < a2[1])
    {
      *a2 = v12;
      *a3 = v13;
      v14 = a2[1];
      a2[1] = a3[1];
      a3[1] = v14;
      v15 = *a2;
      v16 = *a1;
      if (*a2 < *a1 || v16 >= v15 && a2[1] < a1[1])
      {
        *a1 = v15;
        *a2 = v16;
        v17 = a1[1];
        a1[1] = a2[1];
        a2[1] = v17;
      }
    }
  }
  return result;
}

unint64_t *std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(unint64_t *a1, unint64_t *a2, unint64_t *a3, unint64_t *a4, unint64_t *a5)
{
  unint64_t *result;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;

  result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(a1, a2, a3, a4);
  v11 = *a5;
  v12 = *a4;
  if (*a5 < *a4 || v12 >= v11 && a5[1] < a4[1])
  {
    *a4 = v11;
    *a5 = v12;
    v13 = a4[1];
    a4[1] = a5[1];
    a5[1] = v13;
    v14 = *a4;
    v15 = *a3;
    if (*a4 < *a3 || v15 >= v14 && a4[1] < a3[1])
    {
      *a3 = v14;
      *a4 = v15;
      v16 = a3[1];
      a3[1] = a4[1];
      a4[1] = v16;
      v17 = *a3;
      v18 = *a2;
      if (*a3 < *a2 || v18 >= v17 && a3[1] < a2[1])
      {
        *a2 = v17;
        *a3 = v18;
        v19 = a2[1];
        a2[1] = a3[1];
        a3[1] = v19;
        v20 = *a2;
        v21 = *a1;
        if (*a2 < *a1 || v21 >= v20 && a2[1] < a1[1])
        {
          *a1 = v20;
          *a2 = v21;
          v22 = a1[1];
          a1[1] = a2[1];
          a2[1] = v22;
        }
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(unint64_t *a1, unint64_t *a2)
{
  uint64_t v4;
  _BOOL8 result;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t *v9;
  unint64_t *v10;
  uint64_t v11;
  int v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t *v16;
  uint64_t v17;
  char *v18;
  unint64_t v19;
  unint64_t v20;

  v4 = ((char *)a2 - (char *)a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = *(a2 - 2);
      v7 = *a1;
      if (v6 < *a1 || v7 >= v6 && *(a2 - 1) < a1[1])
      {
        *a1 = v6;
        *(a2 - 2) = v7;
        v8 = a1[1];
        a1[1] = *(a2 - 1);
        *(a2 - 1) = v8;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(a1, a1 + 2, a2 - 2);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(a1, a1 + 2, a1 + 4, a2 - 2);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(a1, a1 + 2, a1 + 4, a1 + 6, a2 - 2);
      return 1;
    default:
      v9 = a1 + 4;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<unsigned long long,unsigned long long> *>(a1, a1 + 2, a1 + 4);
      v10 = a1 + 6;
      if (a1 + 6 == a2)
        return 1;
      v11 = 0;
      v12 = 0;
      break;
  }
  do
  {
    v13 = *v10;
    v14 = *v9;
    if (*v10 >= *v9)
    {
      if (v14 < v13)
        goto LABEL_23;
      v15 = v10[1];
      if (v15 >= v9[1])
        goto LABEL_23;
    }
    else
    {
      v15 = v10[1];
    }
    *v10 = v14;
    v10[1] = v9[1];
    v16 = a1;
    if (v9 == a1)
      goto LABEL_22;
    v17 = v11;
    while (1)
    {
      v18 = (char *)a1 + v17;
      v19 = *(unint64_t *)((char *)a1 + v17 + 16);
      if (v13 < v19)
      {
        v20 = *((_QWORD *)v18 + 3);
        goto LABEL_18;
      }
      if (v19 < v13)
      {
        v16 = v9;
        goto LABEL_22;
      }
      v20 = *(unint64_t *)((char *)a1 + v17 + 24);
      if (v15 >= v20)
        break;
LABEL_18:
      v9 -= 2;
      *((_QWORD *)v18 + 4) = v19;
      *(unint64_t *)((char *)a1 + v17 + 40) = v20;
      v17 -= 16;
      if (v17 == -32)
      {
        v16 = a1;
        goto LABEL_22;
      }
    }
    v16 = (unint64_t *)((char *)a1 + v17 + 32);
LABEL_22:
    *v16 = v13;
    v16[1] = v15;
    if (++v12 == 8)
      return v10 + 2 == a2;
LABEL_23:
    v9 = v10;
    v11 += 16;
    v10 += 2;
  }
  while (v10 != a2);
  return 1;
}

uint64_t ___ZL26do_unpack_coldshard_docidxP22ColdShardSearchContextRNSt3__16vectorIxNS1_9allocatorIxEEEERNS2_IyNS3_IyEEEES9_P18DeletionStatistics_block_invoke(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  BOOL v16;
  unint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  _QWORD *v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  _QWORD *v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  _QWORD *v37;
  _QWORD *v38;
  _QWORD *v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t v44;
  _QWORD *v45;
  unint64_t v46;
  uint64_t v47;

  v8 = a1[4];
  v10 = *(_QWORD **)(v8 + 8);
  v9 = *(_QWORD *)(v8 + 16);
  if ((unint64_t)v10 >= v9)
  {
    v12 = *(_QWORD **)v8;
    v13 = ((uint64_t)v10 - *(_QWORD *)v8) >> 3;
    v14 = v13 + 1;
    if ((unint64_t)(v13 + 1) >> 61)
      goto LABEL_47;
    v15 = v9 - (_QWORD)v12;
    if (v15 >> 2 > v14)
      v14 = v15 >> 2;
    v16 = (unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8;
    v17 = 0x1FFFFFFFFFFFFFFFLL;
    if (!v16)
      v17 = v14;
    if (v17)
    {
      v17 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v17);
      v12 = *(_QWORD **)v8;
      v10 = *(_QWORD **)(v8 + 8);
    }
    else
    {
      v18 = 0;
    }
    v19 = (_QWORD *)(v17 + 8 * v13);
    v20 = v17 + 8 * v18;
    *v19 = a2;
    v11 = v19 + 1;
    while (v10 != v12)
    {
      v21 = *--v10;
      *--v19 = v21;
    }
    *(_QWORD *)v8 = v19;
    *(_QWORD *)(v8 + 8) = v11;
    *(_QWORD *)(v8 + 16) = v20;
    if (v12)
      operator delete(v12);
  }
  else
  {
    *v10 = a2;
    v11 = v10 + 1;
  }
  *(_QWORD *)(v8 + 8) = v11;
  v22 = a1[5];
  v24 = *(_QWORD **)(v22 + 8);
  v23 = *(_QWORD *)(v22 + 16);
  if ((unint64_t)v24 >= v23)
  {
    v26 = *(_QWORD **)v22;
    v27 = ((uint64_t)v24 - *(_QWORD *)v22) >> 3;
    v28 = v27 + 1;
    if ((unint64_t)(v27 + 1) >> 61)
      goto LABEL_47;
    v29 = v23 - (_QWORD)v26;
    if (v29 >> 2 > v28)
      v28 = v29 >> 2;
    v16 = (unint64_t)v29 >= 0x7FFFFFFFFFFFFFF8;
    v30 = 0x1FFFFFFFFFFFFFFFLL;
    if (!v16)
      v30 = v28;
    if (v30)
    {
      v30 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v30);
      v26 = *(_QWORD **)v22;
      v24 = *(_QWORD **)(v22 + 8);
    }
    else
    {
      v31 = 0;
    }
    v32 = (_QWORD *)(v30 + 8 * v27);
    v33 = v30 + 8 * v31;
    *v32 = a3;
    v25 = v32 + 1;
    while (v24 != v26)
    {
      v34 = *--v24;
      *--v32 = v34;
    }
    *(_QWORD *)v22 = v32;
    *(_QWORD *)(v22 + 8) = v25;
    *(_QWORD *)(v22 + 16) = v33;
    if (v26)
      operator delete(v26);
  }
  else
  {
    *v24 = a3;
    v25 = v24 + 1;
  }
  *(_QWORD *)(v22 + 8) = v25;
  v35 = a1[6];
  v37 = *(_QWORD **)(v35 + 8);
  v36 = *(_QWORD *)(v35 + 16);
  if ((unint64_t)v37 < v36)
  {
    *v37 = a4;
    v38 = v37 + 1;
    goto LABEL_46;
  }
  v39 = *(_QWORD **)v35;
  v40 = ((uint64_t)v37 - *(_QWORD *)v35) >> 3;
  v41 = v40 + 1;
  if ((unint64_t)(v40 + 1) >> 61)
LABEL_47:
    abort();
  v42 = v36 - (_QWORD)v39;
  if (v42 >> 2 > v41)
    v41 = v42 >> 2;
  v16 = (unint64_t)v42 >= 0x7FFFFFFFFFFFFFF8;
  v43 = 0x1FFFFFFFFFFFFFFFLL;
  if (!v16)
    v43 = v41;
  if (v43)
  {
    v43 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v43);
    v39 = *(_QWORD **)v35;
    v37 = *(_QWORD **)(v35 + 8);
  }
  else
  {
    v44 = 0;
  }
  v45 = (_QWORD *)(v43 + 8 * v40);
  v46 = v43 + 8 * v44;
  *v45 = a4;
  v38 = v45 + 1;
  while (v37 != v39)
  {
    v47 = *--v37;
    *--v45 = v47;
  }
  *(_QWORD *)v35 = v45;
  *(_QWORD *)(v35 + 8) = v38;
  *(_QWORD *)(v35 + 16) = v46;
  if (v39)
    operator delete(v39);
LABEL_46:
  *(_QWORD *)(v35 + 8) = v38;
  return 0;
}

uint64_t __current_vector_version_block_invoke()
{
  uint64_t result;
  __int16 v1;

  result = _os_feature_enabled_impl();
  if ((_DWORD)result)
    v1 = 5;
  else
    v1 = 4;
  current_vector_version::vecVersion = v1;
  return result;
}

_DWORD *createVectorIndex(int a1, const char *a2, uint64_t a3, int a4)
{
  _DWORD *v8;

  v8 = (_DWORD *)operator new();
  *v8 = a1;
  IVFVectorIndex_s::IVFVectorIndex_s((uint64_t)(v8 + 2), a1, a2, a3, a4);
  return v8;
}

uint64_t IVFVectorIndex_s::IVFVectorIndex_s(uint64_t a1, int a2, const char *a3, uint64_t a4, int a5)
{
  std::string *v10;
  size_t v11;
  std::string::size_type v12;
  std::string *p_dst;
  uint64_t v14;
  uint64_t v15;
  size_t v16;
  size_t v17;
  _QWORD *v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  int v23;
  NSObject *v24;
  std::string::size_type size;
  std::string *v26;
  unsigned __int8 v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  uint64_t v32;
  std::ios_base *v33;
  int v35;
  NSObject *v36;
  std::string *v37;
  char *v38;
  char *v39;
  const char *v40;
  std::string __dst;
  uint64_t v42;
  _BYTE __s[32];
  __int16 v44;
  int v45;
  _QWORD v46[78];

  v46[77] = *MEMORY[0x1E0C80C00];
  *(_DWORD *)a1 = a2;
  v10 = (std::string *)(a1 + 8);
  bzero(__s, 0x400uLL);
  fcntl(a2, 50, __s);
  v11 = strlen(__s);
  if (v11 > 0x7FFFFFFFFFFFFFF7)
LABEL_41:
    abort();
  v12 = v11;
  if (v11 >= 0x17)
  {
    v14 = (v11 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v11 | 7) != 0x17)
      v14 = v11 | 7;
    v15 = v14 + 1;
    p_dst = (std::string *)operator new(v14 + 1);
    __dst.__r_.__value_.__l.__size_ = v12;
    __dst.__r_.__value_.__r.__words[2] = v15 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    goto LABEL_8;
  }
  *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v11;
  p_dst = &__dst;
  if (v11)
LABEL_8:
    memcpy(p_dst, __s, v12);
  p_dst->__r_.__value_.__s.__data_[v12] = 0;
  *v10 = __dst;
  v16 = strlen(a3);
  if (v16 > 0x7FFFFFFFFFFFFFF7)
    goto LABEL_41;
  v17 = v16;
  v18 = (_QWORD *)(a1 + 32);
  if (v16 >= 0x17)
  {
    v20 = (v16 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v16 | 7) != 0x17)
      v20 = v16 | 7;
    v21 = v20 + 1;
    v19 = operator new(v20 + 1);
    *(_QWORD *)(a1 + 40) = v17;
    *(_QWORD *)(a1 + 48) = v21 | 0x8000000000000000;
    *(_QWORD *)(a1 + 32) = v19;
    goto LABEL_16;
  }
  *(_BYTE *)(a1 + 55) = v16;
  v19 = (void *)(a1 + 32);
  if (v16)
LABEL_16:
    memmove(v19, a3, v17);
  *((_BYTE *)v19 + v17) = 0;
  v22 = (_QWORD *)(a1 + 56);
  if (*(char *)(a1 + 31) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)__s, *(const std::string::value_type **)(a1 + 8), *(_QWORD *)(a1 + 16));
  }
  else
  {
    *(_OWORD *)__s = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
    *(_QWORD *)&__s[16] = *((_QWORD *)&v10->__r_.__value_.__l + 2);
  }
  IVFVectorIndex_s::protectionClassForParentPath((char *)(a1 + 56), (uint64_t)__s);
  if ((__s[23] & 0x80000000) != 0)
    operator delete(*(void **)__s);
  *(_QWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 80) = a1 + 88;
  *(_DWORD *)(a1 + 108) = a5;
  *(_WORD *)(a1 + 112) = a5;
  *(_OWORD *)(a1 + 116) = xmmword_1B8631CE0;
  *(_QWORD *)(a1 + 136) = a4;
  v23 = *__error();
  v24 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
  {
    if (*(char *)(a1 + 79) < 0)
    {
      v22 = (_QWORD *)*v22;
      if ((*(char *)(a1 + 55) & 0x80000000) == 0)
        goto LABEL_25;
    }
    else if ((*(char *)(a1 + 55) & 0x80000000) == 0)
    {
LABEL_25:
      *(_DWORD *)__s = 136315906;
      *(_QWORD *)&__s[4] = v22;
      *(_WORD *)&__s[12] = 2048;
      *(_QWORD *)&__s[14] = a1;
      *(_WORD *)&__s[22] = 2080;
      *(_QWORD *)&__s[24] = v18;
      v44 = 1024;
      v45 = a5;
      _os_log_impl(&dword_1B8270000, v24, OS_LOG_TYPE_DEFAULT, "[%s] create %p with prefix %s indexId: %u", __s, 0x26u);
      goto LABEL_26;
    }
    v18 = (_QWORD *)*v18;
    goto LABEL_25;
  }
LABEL_26:
  *__error() = v23;
  memset(&__dst, 0, sizeof(__dst));
  IVFVectorIndex_s::metaFilename(&__dst, a1);
  memset(__s, 0, 24);
  size = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v26 = &__dst;
  else
    v26 = (std::string *)__dst.__r_.__value_.__r.__words[0];
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    size = __dst.__r_.__value_.__l.__size_;
  std::string::append[abi:nn180100]<char const*,0>((std::string *)__s, (char *)v26, (char *)v26 + size);
  std::__fs::filesystem::__status((const std::__fs::filesystem::path *)__s, 0);
  v27 = v42;
  if ((__s[23] & 0x80000000) != 0)
  {
    operator delete(*(void **)__s);
    v28 = v27;
    if (!v27)
      goto LABEL_36;
  }
  else
  {
    v28 = v42;
    if (!(_BYTE)v42)
      goto LABEL_36;
  }
  if (v28 != 255)
  {
    v35 = *__error();
    v36 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v36, OS_LOG_TYPE_FAULT))
    {
      v37 = &__dst;
      if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v37 = (std::string *)__dst.__r_.__value_.__r.__words[0];
      *(_DWORD *)__s = 136315650;
      *(_QWORD *)&__s[4] = "createMetaFile";
      *(_WORD *)&__s[12] = 1024;
      *(_DWORD *)&__s[14] = 3864;
      *(_WORD *)&__s[18] = 2080;
      *(_QWORD *)&__s[20] = v37;
      _os_log_fault_impl(&dword_1B8270000, v36, OS_LOG_TYPE_FAULT, "%s:%d: metaFile %s already exists.", __s, 0x1Cu);
    }
    *__error() = v35;
    v38 = __si_assert_copy_extra_268();
    v39 = v38;
    v40 = "";
    if (v38)
      v40 = v38;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3865, "false", v40);
    free(v39);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
LABEL_36:
  bzero(&__s[8], 0x230uLL);
  v29 = MEMORY[0x1E0DE4FB0];
  v30 = MEMORY[0x1E0DE4FB0] + 64;
  v31 = (_QWORD *)MEMORY[0x1E0DE4F48];
  v32 = *(_QWORD *)(MEMORY[0x1E0DE4F48] + 8);
  v46[0] = MEMORY[0x1E0DE4FB0] + 64;
  *(_QWORD *)__s = v32;
  *(_QWORD *)&__s[*(_QWORD *)(v32 - 24)] = *(_QWORD *)(MEMORY[0x1E0DE4F48] + 16);
  v33 = (std::ios_base *)&__s[*(_QWORD *)(*(_QWORD *)__s - 24)];
  std::ios_base::init(v33, &__s[8]);
  v33[1].__vftable = 0;
  v33[1].__fmtflags_ = -1;
  *(_QWORD *)__s = v29 + 24;
  v46[0] = v30;
  MEMORY[0x1BCCB0428](&__s[8]);
  std::ofstream::open();
  v42 = *(unsigned int *)(a1 + 108) | 0x15F1DA600000000;
  std::ostream::write();
  *(_QWORD *)__s = *v31;
  *(_QWORD *)&__s[*(_QWORD *)(*(_QWORD *)__s - 24)] = v31[3];
  MEMORY[0x1BCCB0434](&__s[8]);
  std::ostream::~ostream();
  MEMORY[0x1BCCB0650](v46);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__dst.__r_.__value_.__l.__data_);
  return a1;
}

uint64_t IVFVectorIndex_s::protectionClassForParentPath(char *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  std::ios_base *v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  char *v12;
  uint64_t v13;
  _BYTE *v14;
  unsigned __int8 *v15;
  unsigned __int8 *v16;
  unsigned __int8 *v17;
  unsigned __int8 *v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  char *v22;
  __int128 *v23;
  _OWORD *v24;
  unint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  __int128 v28;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  char *v33;
  char v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  void *v38;
  __int128 v39;
  _QWORD v40[2];
  __int128 v41;
  _OWORD v42[3];
  void *__p[2];
  __int128 v44;
  uint64_t v45;
  uint64_t v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;

  v55 = 0u;
  v54 = 0u;
  v53 = 0u;
  v52 = 0u;
  v51 = 0u;
  v50 = 0u;
  v49 = 0u;
  v48 = 0u;
  v45 = 0;
  v47 = 0u;
  v44 = 0u;
  *(_OWORD *)__p = 0u;
  memset(v42, 0, sizeof(v42));
  v41 = 0u;
  v4 = MEMORY[0x1E0DE4FD8];
  v5 = MEMORY[0x1E0DE4FD8] + 64;
  v46 = MEMORY[0x1E0DE4FD8] + 64;
  v6 = *(_QWORD *)(MEMORY[0x1E0DE4F58] + 16);
  v40[0] = *(_QWORD *)(MEMORY[0x1E0DE4F58] + 8);
  *(_QWORD *)((char *)v40 + *(_QWORD *)(v40[0] - 24)) = v6;
  v40[1] = 0;
  v7 = (std::ios_base *)((char *)v40 + *(_QWORD *)(v40[0] - 24));
  std::ios_base::init(v7, &v41);
  v7[1].__vftable = 0;
  v7[1].__fmtflags_ = -1;
  v40[0] = v4 + 24;
  v46 = v5;
  std::streambuf::basic_streambuf();
  *(_QWORD *)&v41 = MEMORY[0x1E0DE4FB8] + 16;
  *(_OWORD *)__p = 0u;
  v44 = 0u;
  LODWORD(v45) = 8;
  std::stringbuf::str();
  v37 = 0;
  v38 = operator new(0x20uLL);
  v39 = xmmword_1B8631EF0;
  strcpy((char *)v38, "NSFileProtectionComplete");
  v35 = 0;
  v36 = 0;
  while (1)
  {
    while (1)
    {
      std::getline[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(v40, (uint64_t)&v35, 0x2Fu);
      if ((*((_BYTE *)v42 + *(_QWORD *)(v40[0] - 24)) & 5) != 0)
      {
        if (*(char *)(a2 + 23) < 0)
        {
          std::string::__init_copy_ctor_external((std::string *)a1, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
        }
        else
        {
          *(_OWORD *)a1 = *(_OWORD *)a2;
          *((_QWORD *)a1 + 2) = *(_QWORD *)(a2 + 16);
        }
        goto LABEL_43;
      }
      v10 = HIBYTE(v37);
      v11 = v37 >= 0 ? HIBYTE(v37) : v36;
      v9 = HIBYTE(v39);
      if (SHIBYTE(v39) < 0)
        break;
      if (v11 >= HIBYTE(v39))
      {
        v12 = (char *)&v38;
        v13 = HIBYTE(v39);
        goto LABEL_17;
      }
    }
    v13 = v39;
    if (v11 >= (unint64_t)v39)
    {
      v12 = (char *)v38;
LABEL_17:
      v14 = v35;
      if (v37 >= 0)
        v15 = (unsigned __int8 *)&v35;
      else
        v15 = (unsigned __int8 *)v35;
      if (v13)
      {
        v16 = (unsigned __int8 *)&v12[v13];
        v17 = &v15[v13];
        while (*v12 == *v15)
        {
          ++v12;
          ++v15;
          if (!--v13)
          {
            v12 = (char *)v16;
            v15 = v17;
            break;
          }
        }
      }
      if (v39 >= 0)
        v8 = (char *)&v38;
      else
        v8 = (char *)v38;
      if (v39 < 0)
        v9 = v39;
      if (v12 == &v8[v9])
        break;
    }
  }
  if (v37 < 0)
  {
    if ((char *)v35 + v36 == (char *)v15)
      goto LABEL_42;
    v10 = v36;
  }
  else
  {
    v14 = &v35;
    if ((unsigned __int8 *)((char *)&v35 + HIBYTE(v37)) == v15)
    {
LABEL_42:
      a1[23] = 8;
      strcpy(a1, "Complete");
LABEL_43:
      v26 = (_QWORD *)MEMORY[0x1E0DE4F58];
      v27 = MEMORY[0x1E0DE4FB8];
      goto LABEL_44;
    }
  }
  v18 = &v14[v10];
  v19 = &v14[v10] - v15;
  if (v19 >= 0x7FFFFFFFFFFFFFF8)
    abort();
  if (v19 > 0x16)
  {
    v30 = (v19 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v19 | 7) != 0x17)
      v30 = v19 | 7;
    v31 = v30 + 1;
    v32 = (char *)operator new(v30 + 1);
    *((_QWORD *)a1 + 1) = v19;
    *((_QWORD *)a1 + 2) = v31 | 0x8000000000000000;
    *(_QWORD *)a1 = v32;
    a1 = v32;
    if (v15 == v18)
      goto LABEL_54;
LABEL_36:
    v20 = &v14[v10] - v15;
    if (v20 < 0x20 || (unint64_t)(a1 - (char *)v15) < 0x20)
    {
      v22 = a1;
      v26 = (_QWORD *)MEMORY[0x1E0DE4F58];
      v27 = MEMORY[0x1E0DE4FB8];
    }
    else
    {
      v21 = v20 & 0xFFFFFFFFFFFFFFE0;
      v22 = &a1[v20 & 0xFFFFFFFFFFFFFFE0];
      v23 = (__int128 *)(v15 + 16);
      v24 = a1 + 16;
      v25 = v20 & 0xFFFFFFFFFFFFFFE0;
      v26 = (_QWORD *)MEMORY[0x1E0DE4F58];
      v27 = MEMORY[0x1E0DE4FB8];
      do
      {
        v28 = *v23;
        *(v24 - 1) = *(v23 - 1);
        *v24 = v28;
        v23 += 2;
        v24 += 2;
        v25 -= 32;
      }
      while (v25);
      if (v20 == v21)
      {
        *v22 = 0;
        goto LABEL_44;
      }
      v15 += v21;
    }
    v33 = v22;
    do
    {
      v34 = *v15++;
      *v33++ = v34;
    }
    while (v15 != v18);
    *v33 = 0;
  }
  else
  {
    a1[23] = v19;
    if (v15 != v18)
      goto LABEL_36;
LABEL_54:
    v26 = (_QWORD *)MEMORY[0x1E0DE4F58];
    v27 = MEMORY[0x1E0DE4FB8];
    *a1 = 0;
  }
LABEL_44:
  if (SHIBYTE(v37) < 0)
  {
    operator delete(v35);
    if (SHIBYTE(v39) < 0)
      goto LABEL_50;
  }
  else
  {
    if ((SHIBYTE(v39) & 0x80000000) == 0)
      goto LABEL_46;
LABEL_50:
    operator delete(v38);
  }
LABEL_46:
  v40[0] = *v26;
  *(_QWORD *)((char *)v40 + *(_QWORD *)(v40[0] - 24)) = v26[3];
  *(_QWORD *)&v41 = v27 + 16;
  if (SBYTE7(v44) < 0)
    operator delete(__p[0]);
  std::streambuf::~streambuf();
  std::istream::~istream();
  return MEMORY[0x1BCCB0650](&v46);
}

void IVFVectorIndex_s::metaFilename(std::string *this, uint64_t a2)
{
  int v2;
  size_t v3;
  unint64_t v4;
  uint64_t v7;
  std::__fs::filesystem::path *p_dst;
  uint64_t v9;
  uint64_t v10;
  const void *v11;
  std::__fs::filesystem::path __dst;
  std::__fs::filesystem::path __p;
  std::string v14;

  v2 = *(char *)(a2 + 55);
  if (v2 >= 0)
    v3 = *(unsigned __int8 *)(a2 + 55);
  else
    v3 = *(_QWORD *)(a2 + 40);
  v4 = v3 + 18;
  if (v3 + 18 >= 0x7FFFFFFFFFFFFFF8)
    abort();
  v7 = a2 + 8;
  if (v4 >= 0x17)
  {
    v9 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17)
      v9 = v4 | 7;
    v10 = v9 + 1;
    p_dst = (std::__fs::filesystem::path *)operator new(v9 + 1);
    __dst.__pn_.__r_.__value_.__l.__size_ = v3 + 18;
    __dst.__pn_.__r_.__value_.__r.__words[2] = v10 | 0x8000000000000000;
    __dst.__pn_.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
  }
  else
  {
    memset(&__dst, 0, sizeof(__dst));
    p_dst = &__dst;
    *((_BYTE *)&__dst.__pn_.__r_.__value_.__s + 23) = v3 + 18;
    if (!v3)
      goto LABEL_15;
  }
  if (v2 >= 0)
    v11 = (const void *)(a2 + 32);
  else
    v11 = *(const void **)(a2 + 32);
  memmove(p_dst, v11, v3);
LABEL_15:
  strcpy((char *)p_dst + v3, "ivf-vector-indexes");
  __p = __dst;
  std::__fs::filesystem::operator/[abi:nn180100](&v14, v7, &__p);
  if ((SHIBYTE(v14.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    *this = v14;
    if ((SHIBYTE(__p.__pn_.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      return;
    goto LABEL_20;
  }
  std::string::__init_copy_ctor_external(this, v14.__r_.__value_.__l.__data_, v14.__r_.__value_.__l.__size_);
  if ((SHIBYTE(v14.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((SHIBYTE(__p.__pn_.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      return;
    goto LABEL_20;
  }
  operator delete(v14.__r_.__value_.__l.__data_);
  if (SHIBYTE(__p.__pn_.__r_.__value_.__r.__words[2]) < 0)
LABEL_20:
    operator delete(__p.__pn_.__r_.__value_.__l.__data_);
}

std::string *std::string::append[abi:nn180100]<char const*,0>(std::string *this, char *__src, char *a3)
{
  char *v4;
  unint64_t v6;
  size_t v7;
  std::string::size_type size;
  std::string::size_type v9;
  std::string *v10;
  unint64_t v11;
  void **p_dst;
  std::string *v13;
  _BYTE *v14;
  char *v15;
  unint64_t v16;
  __int128 *v17;
  _OWORD *v18;
  unint64_t v19;
  __int128 v20;
  char v21;
  std::string::size_type v22;
  uint64_t v23;
  uint64_t v24;
  const std::string::value_type *v25;
  std::string::size_type v26;
  void **__dst;
  std::string::size_type v29;
  int64_t v30;

  v4 = __src;
  LODWORD(v6) = SHIBYTE(this->__r_.__value_.__r.__words[2]);
  v7 = a3 - __src;
  if ((v6 & 0x80000000) != 0)
  {
    if (a3 == __src)
      return this;
    size = this->__r_.__value_.__l.__size_;
    v11 = this->__r_.__value_.__r.__words[2];
    v9 = (v11 & 0x7FFFFFFFFFFFFFFFLL) - 1;
    v10 = (std::string *)this->__r_.__value_.__r.__words[0];
    v6 = HIBYTE(v11);
    if (this->__r_.__value_.__r.__words[0] > (unint64_t)v4)
      goto LABEL_11;
  }
  else
  {
    if (a3 == __src)
      return this;
    size = HIBYTE(this->__r_.__value_.__r.__words[2]);
    v9 = 22;
    v10 = this;
    if (this > (std::string *)v4)
    {
LABEL_11:
      if (v9 - size < v7)
      {
        std::string::__grow_by(this, v9, size - v9 + v7, size, size, 0, 0);
        this->__r_.__value_.__l.__size_ = size;
        LOBYTE(v6) = *((_BYTE *)&this->__r_.__value_.__s + 23);
      }
      v13 = this;
      if ((v6 & 0x80) != 0)
        v13 = (std::string *)this->__r_.__value_.__r.__words[0];
      v14 = (char *)v13 + size;
      if (v7 >= 0x20)
      {
        v15 = (char *)v13 + size;
        if ((unint64_t)((char *)v13 + size - v4) >= 0x20)
        {
          v16 = v7 & 0xFFFFFFFFFFFFFFE0;
          v14 += v7 & 0xFFFFFFFFFFFFFFE0;
          v17 = (__int128 *)(v4 + 16);
          v18 = v15 + 16;
          v19 = v7 & 0xFFFFFFFFFFFFFFE0;
          do
          {
            v20 = *v17;
            *(v18 - 1) = *(v17 - 1);
            *v18 = v20;
            v17 += 2;
            v18 += 2;
            v19 -= 32;
          }
          while (v19);
          if (v7 == v16)
            goto LABEL_22;
          v4 += v16;
        }
      }
      do
      {
        v21 = *v4++;
        *v14++ = v21;
      }
      while (v4 != a3);
LABEL_22:
      *v14 = 0;
      v22 = v7 + size;
      if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0)
        this->__r_.__value_.__l.__size_ = v22;
      else
        *((_BYTE *)&this->__r_.__value_.__s + 23) = v22 & 0x7F;
      return this;
    }
  }
  if ((char *)&v10->__r_.__value_.__l.__data_ + size + 1 <= v4)
    goto LABEL_11;
  __dst = 0;
  v29 = 0;
  v30 = 0;
  if (v7 >= 0x7FFFFFFFFFFFFFF8)
    abort();
  if (v7 > 0x16)
  {
    v23 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17)
      v23 = v7 | 7;
    v24 = v23 + 1;
    p_dst = (void **)operator new(v23 + 1);
    v29 = v7;
    v30 = v24 | 0x8000000000000000;
    __dst = p_dst;
  }
  else
  {
    HIBYTE(v30) = v7;
    p_dst = (void **)&__dst;
  }
  memcpy(p_dst, v4, v7);
  *((_BYTE *)p_dst + v7) = 0;
  if (v30 >= 0)
    v25 = (const std::string::value_type *)&__dst;
  else
    v25 = (const std::string::value_type *)__dst;
  if (v30 >= 0)
    v26 = HIBYTE(v30);
  else
    v26 = v29;
  std::string::append(this, v25, v26);
  if (SHIBYTE(v30) < 0)
    operator delete(__dst);
  return this;
}

std::string *std::__fs::filesystem::operator/[abi:nn180100](std::string *this, uint64_t a2, std::__fs::filesystem::path *a3)
{
  int v6;
  std::__fs::filesystem::path *v7;
  std::string::size_type size;

  *(_OWORD *)&this->__r_.__value_.__l.__data_ = 0uLL;
  this->__r_.__value_.__r.__words[2] = 0;
  if (*(char *)(a2 + 23) < 0)
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  else
    *this = *(std::string *)a2;
  if (std::__fs::filesystem::path::__root_directory(a3).__size_)
    return std::string::operator=(this, &a3->__pn_);
  if (std::__fs::filesystem::path::__filename((const std::__fs::filesystem::path *)this).__size_)
    std::string::push_back(this, 47);
  v6 = SHIBYTE(a3->__pn_.__r_.__value_.__r.__words[2]);
  if (v6 >= 0)
    v7 = a3;
  else
    v7 = (std::__fs::filesystem::path *)a3->__pn_.__r_.__value_.__r.__words[0];
  if (v6 >= 0)
    size = HIBYTE(a3->__pn_.__r_.__value_.__r.__words[2]);
  else
    size = a3->__pn_.__r_.__value_.__l.__size_;
  return std::string::append(this, (const std::string::value_type *)v7, size);
}

uint64_t createVectorIndexWithPrototype(int a1, const char *a2, uint64_t a3, int a4)
{
  uint64_t v8;
  uint64_t v9;
  int v10;
  NSObject *v11;
  _QWORD *v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  unsigned int v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  _QWORD *v30;
  _QWORD *v31;
  BOOL v32;
  _BYTE v34[22];
  __int16 v35;
  _QWORD *v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v8 = operator new();
  v9 = *(_QWORD *)(a3 + 144);
  *(_DWORD *)v8 = a1;
  IVFVectorIndex_s::IVFVectorIndex_s(v8 + 8, a1, a2, v9, a4);
  v10 = *__error();
  v11 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    v12 = (_QWORD *)(v8 + 64);
    if (*(char *)(v8 + 87) < 0)
      v12 = (_QWORD *)*v12;
    v13 = (_QWORD *)(v8 + 40);
    if (*(char *)(v8 + 63) < 0)
      v13 = (_QWORD *)*v13;
    v14 = (_QWORD *)(a3 + 40);
    if (*(char *)(a3 + 63) < 0)
      v14 = (_QWORD *)*v14;
    *(_DWORD *)v34 = 136315650;
    *(_QWORD *)&v34[4] = v12;
    *(_WORD *)&v34[12] = 2080;
    *(_QWORD *)&v34[14] = v13;
    v35 = 2080;
    v36 = v14;
    _os_log_impl(&dword_1B8270000, v11, OS_LOG_TYPE_DEFAULT, "[%s] setupLikePrototype %s -> %s", v34, 0x20u);
  }
  *__error() = v10;
  v15 = *(_QWORD **)(a3 + 88);
  v16 = (_QWORD *)(a3 + 96);
  if (v15 != (_QWORD *)(a3 + 96))
  {
    do
    {
      v17 = v15[5];
      v18 = *(unsigned __int16 *)(v17 + 20);
      v19 = *(unsigned int *)(v17 + 8);
      v20 = *(_DWORD *)(v17 + 12);
      if (v20 == 512)
        v21 = 1;
      else
        v21 = 3;
      if (v20 == 768)
        v21 = 2;
      if (v20 == 256)
        v22 = 0;
      else
        v22 = v21;
      v23 = *(_DWORD *)(v17 + 16);
      if (v23 == 2)
        v24 = 1;
      else
        v24 = 3;
      if (v23 == 4)
        v25 = 0;
      else
        v25 = v24;
      v26 = *(unsigned __int8 *)(v17 + 22);
      *(_QWORD *)v34 = 0;
      *(_QWORD *)&v34[8] = 0;
      IVFVectorIndex_s::getOrCreateVectorIndex(v34, v8 + 8, v19, v18, v22, v25, v26);
      v27 = *(std::__shared_weak_count **)&v34[8];
      if (!*(_QWORD *)&v34[8])
        goto LABEL_30;
      v28 = (unint64_t *)(*(_QWORD *)&v34[8] + 8);
      do
        v29 = __ldaxr(v28);
      while (__stlxr(v29 - 1, v28));
      if (!v29)
      {
        ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
        std::__shared_weak_count::__release_weak(v27);
        v30 = (_QWORD *)v15[1];
        if (!v30)
        {
          do
          {
LABEL_34:
            v31 = (_QWORD *)v15[2];
            v32 = *v31 == (_QWORD)v15;
            v15 = v31;
          }
          while (!v32);
          goto LABEL_11;
        }
      }
      else
      {
LABEL_30:
        v30 = (_QWORD *)v15[1];
        if (!v30)
          goto LABEL_34;
      }
      do
      {
        v31 = v30;
        v30 = (_QWORD *)*v30;
      }
      while (v30);
LABEL_11:
      v15 = v31;
    }
    while (v31 != v16);
  }
  return v8;
}

_QWORD *IVFVectorIndex_s::getOrCreateVectorIndex(_QWORD *result, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, unsigned int a7)
{
  uint64_t *v8;
  unint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  unint64_t v13;
  BOOL v14;
  _QWORD *v15;
  __int128 v16;
  uint64_t IVFDiskOne;
  _QWORD *v18;
  _QWORD *v19;
  unint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t *v23;
  unint64_t *v24;
  unint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *p_shared_owners;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  std::ios_base *v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t *v37;
  unint64_t v38;
  char *v39;
  char *v40;
  const char *v41;
  _OWORD v42[2];
  std::string __p;
  unint64_t v44;
  uint64_t v45;
  _BYTE v46[408];
  _QWORD v47[20];

  v8 = result;
  v47[19] = *MEMORY[0x1E0C80C00];
  v9 = a7 | (2
           * (((unint64_t)(a5 & 3) << 50) | ((unint64_t)(a6 & 3) << 48) | (a4 << 32) | a3));
  v11 = (_QWORD *)(a2 + 88);
  v10 = *(_QWORD **)(a2 + 88);
  if (!v10)
    goto LABEL_12;
  v12 = (_QWORD *)(a2 + 88);
  do
  {
    v13 = v10[4];
    v14 = v13 >= v9;
    if (v13 >= v9)
      v15 = v10;
    else
      v15 = v10 + 1;
    if (v14)
      v12 = v10;
    v10 = (_QWORD *)*v15;
  }
  while (*v15);
  if (v12 == v11 || v9 < v12[4])
  {
LABEL_12:
    v16 = *(_OWORD *)(a2 + 128);
    v42[0] = *(_OWORD *)(a2 + 112);
    v42[1] = v16;
    IVFDiskOne = makeIVFDiskOne(v42, *(_DWORD *)a2, a2 + 32, a3, a4, a5, a6, a7, 1, 0, 0);
    *v8 = IVFDiskOne;
    result = (_QWORD *)operator new();
    *result = &off_1E6E30970;
    result[1] = 0;
    result[2] = 0;
    result[3] = IVFDiskOne;
    v8[1] = (uint64_t)result;
    if (!IVFDiskOne)
      return result;
    v18 = (_QWORD *)*v11;
    v19 = v11;
    if (*v11)
    {
      while (1)
      {
        while (1)
        {
          v19 = v18;
          v20 = v18[4];
          if (v9 >= v20)
            break;
          v18 = (_QWORD *)*v19;
          v11 = v19;
          if (!*v19)
            goto LABEL_20;
        }
        if (v20 >= v9)
          break;
        v18 = (_QWORD *)v19[1];
        if (!v18)
        {
          v11 = v19 + 1;
          goto LABEL_20;
        }
      }
    }
    else
    {
LABEL_20:
      v21 = v19;
      v19 = operator new(0x38uLL);
      v19[5] = 0;
      v19[6] = 0;
      v19[4] = v9;
      *v19 = 0;
      v19[1] = 0;
      v19[2] = v21;
      *v11 = v19;
      v22 = **(_QWORD **)(a2 + 80);
      v23 = v19;
      if (v22)
      {
        *(_QWORD *)(a2 + 80) = v22;
        v23 = (uint64_t *)*v11;
      }
      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a2 + 88), v23);
      ++*(_QWORD *)(a2 + 96);
      IVFDiskOne = *v8;
      result = (_QWORD *)v8[1];
      if (!result)
        goto LABEL_25;
    }
    v24 = result + 1;
    do
      v25 = __ldxr(v24);
    while (__stxr(v25 + 1, v24));
LABEL_25:
    v26 = (std::__shared_weak_count *)v19[6];
    v19[5] = IVFDiskOne;
    v19[6] = result;
    if (v26)
    {
      p_shared_owners = (unint64_t *)&v26->__shared_owners_;
      do
        v28 = __ldaxr(p_shared_owners);
      while (__stlxr(v28 - 1, p_shared_owners));
      if (!v28)
      {
        ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
        std::__shared_weak_count::__release_weak(v26);
      }
    }
    v44 = v9;
    bzero(v46, 0x230uLL);
    v29 = MEMORY[0x1E0DE4FB0];
    v30 = MEMORY[0x1E0DE4FB0] + 64;
    v31 = (uint64_t *)MEMORY[0x1E0DE4F48];
    v32 = *(_QWORD *)(MEMORY[0x1E0DE4F48] + 8);
    v33 = *(_QWORD *)(MEMORY[0x1E0DE4F48] + 16);
    v47[0] = MEMORY[0x1E0DE4FB0] + 64;
    v45 = v32;
    *(_QWORD *)&v46[*(_QWORD *)(v32 - 24) - 8] = v33;
    v34 = (std::ios_base *)&v46[*(_QWORD *)(v45 - 24) - 8];
    std::ios_base::init(v34, v46);
    v34[1].__vftable = 0;
    v34[1].__fmtflags_ = -1;
    v45 = v29 + 24;
    v47[0] = v30;
    MEMORY[0x1BCCB0428](v46);
    IVFVectorIndex_s::metaFilename(&__p, a2);
    std::ofstream::open();
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    std::ostream::write();
    v45 = *v31;
    *(_QWORD *)&v46[*(_QWORD *)(v45 - 24) - 8] = v31[3];
    MEMORY[0x1BCCB0434](v46);
    std::ostream::~ostream();
    return (_QWORD *)MEMORY[0x1BCCB0650](v47);
  }
  v35 = v12[5];
  if (*(_DWORD *)(v35 + 8) != (_DWORD)a3
    || *(unsigned __int16 *)(v35 + 20) != (_DWORD)a4
    || a6 > 2
    || *(_DWORD *)(v35 + 12) != vector_dimension_vec_sizes_10743[a5]
    || vector_size_elem_sizes_10742[a6] != *(_DWORD *)(v35 + 16)
    || *(unsigned __int8 *)(v35 + 22) != a7)
  {
    v39 = __si_assert_copy_extra_268();
    v40 = v39;
    v41 = "";
    if (v39)
      v41 = v39;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3952, "it->second->isCompatible(propertyId, vecVersion, dim, form, purgeable)", v41);
    free(v40);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v36 = v12[6];
  *result = v35;
  result[1] = v36;
  if (v36)
  {
    v37 = (unint64_t *)(v36 + 8);
    do
      v38 = __ldxr(v37);
    while (__stxr(v38 + 1, v37));
  }
  return result;
}

uint64_t makeIVFDiskOne(_OWORD *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7, char a8, char a9, unsigned __int8 a10, int *a11)
{
  int *v19;
  int v20;
  const std::string::value_type *v21;
  std::string::size_type v22;
  std::string *v23;
  std::string::size_type v24;
  _OWORD *v25;
  int v26;
  void **v27;
  int v28;
  _QWORD *v29;
  int v30;
  NSObject *v31;
  NSObject *v32;
  const char *v33;
  void **v34;
  const char *v35;
  __int128 v36;
  uint64_t VectorIndexInstance;
  const char *v38;
  _QWORD *v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  void **v43;
  _QWORD *v44;
  uint64_t v45;
  void **v46;
  _QWORD *v47;
  uint64_t v48;
  void **v49;
  _QWORD *v50;
  uint64_t v51;
  void **v52;
  _QWORD *v53;
  uint64_t v54;
  _DWORD *v55;
  int v56;
  const void *v57;
  BOOL v58;
  const char *v60;
  void **v61;
  const char *v62;
  char v63;
  uint64_t v64;
  int *v65;
  _OWORD v66[2];
  _QWORD v67[2];
  int v68;
  char v69;
  char v70;
  __int16 v71;
  int v72;
  int v73;
  void *__p[2];
  uint64_t v75;
  _BYTE v76[40];
  uint64_t v77;
  uint64_t v78;
  int v79;
  char v80;
  _BYTE v81[11];
  uint64_t v82;

  v19 = a11;
  v82 = *MEMORY[0x1E0C80C00];
  IVFIndexName((uint64_t)v76, a4, a5, a6, a7);
  v20 = *(char *)(a3 + 23);
  if (v20 >= 0)
    v21 = (const std::string::value_type *)a3;
  else
    v21 = *(const std::string::value_type **)a3;
  if (v20 >= 0)
    v22 = *(unsigned __int8 *)(a3 + 23);
  else
    v22 = *(_QWORD *)(a3 + 8);
  v23 = std::string::insert((std::string *)v76, 0, v21, v22);
  v24 = v23->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
  v75 = v24;
  v23->__r_.__value_.__l.__size_ = 0;
  v23->__r_.__value_.__r.__words[2] = 0;
  v23->__r_.__value_.__r.__words[0] = 0;
  if ((v76[23] & 0x80000000) != 0)
  {
    operator delete(*(void **)v76);
    if (a9)
      goto LABEL_9;
  }
  else if (a9)
  {
LABEL_9:
    v65 = a11;
    v63 = a8;
    v25 = a1;
    v26 = 0;
    if (v75 >= 0)
      v27 = __p;
    else
      v27 = (void **)__p[0];
    v28 = 514;
    goto LABEL_13;
  }
  if (a7)
  {
    if (a7 != 1)
      goto LABEL_78;
    if (a6 == 2)
    {
      if (v75 >= 0)
        v46 = __p;
      else
        v46 = (void **)__p[0];
      v47 = fd_create_protected(a2, (const char *)v46, 0, 0);
      if (!v47)
        goto LABEL_78;
      v65 = a11;
      v48 = (uint64_t)v47;
      v41 = operator new();
      *(_QWORD *)v41 = 0;
      *(_QWORD *)v76 = MEMORY[0x1E0C809B0];
      *(_QWORD *)&v76[8] = 0x40000000;
      *(_QWORD *)&v76[16] = ___ZN30vi_onefixedsize_disk_allocatorC2EmymN19vi_ondisk_allocator11meta_info_sEP16vector_storage_s_block_invoke;
      *(_QWORD *)&v76[24] = &__block_descriptor_tmp_80;
      *(_QWORD *)&v76[32] = v41;
      v77 = v48;
      v78 = 0x1000000;
      v79 = 0;
      v80 = 1;
      memset(v81, 0, sizeof(v81));
      v64 = v41 + 8;
      storage_array_Init((_DWORD *)(v41 + 8), 1044, 0x40000uLL, 1552, v48, 0, 0, 1, 0, 0, 0, (uint64_t)v76);
      goto LABEL_65;
    }
    if (a6 != 1)
    {
      if (a6)
        goto LABEL_78;
      v38 = v75 >= 0 ? (const char *)__p : (const char *)__p[0];
      v39 = fd_create_protected(a2, v38, 0, 0);
      if (!v39)
        goto LABEL_78;
      v65 = a11;
      v40 = (uint64_t)v39;
      v41 = operator new();
      *(_QWORD *)v41 = 0;
      *(_QWORD *)v76 = MEMORY[0x1E0C809B0];
      *(_QWORD *)&v76[8] = 0x40000000;
      *(_QWORD *)&v76[16] = ___ZN30vi_onefixedsize_disk_allocatorC2EmymN19vi_ondisk_allocator11meta_info_sEP16vector_storage_s_block_invoke;
      *(_QWORD *)&v76[24] = &__block_descriptor_tmp_80;
      *(_QWORD *)&v76[32] = v41;
      v77 = v40;
      v78 = 0x1000000;
      v79 = 0;
      v80 = 1;
      memset(v81, 0, sizeof(v81));
      v64 = v41 + 8;
      storage_array_Init((_DWORD *)(v41 + 8), 1044, 0x40000uLL, 528, v40, 0, 0, 1, 0, 0, 0, (uint64_t)v76);
      goto LABEL_65;
    }
LABEL_44:
    if (v75 >= 0)
      v43 = __p;
    else
      v43 = (void **)__p[0];
    v44 = fd_create_protected(a2, (const char *)v43, 0, 0);
    if (!v44)
      goto LABEL_78;
    v65 = a11;
    v45 = (uint64_t)v44;
    v41 = operator new();
    *(_QWORD *)v41 = 0;
    *(_QWORD *)v76 = MEMORY[0x1E0C809B0];
    *(_QWORD *)&v76[8] = 0x40000000;
    *(_QWORD *)&v76[16] = ___ZN30vi_onefixedsize_disk_allocatorC2EmymN19vi_ondisk_allocator11meta_info_sEP16vector_storage_s_block_invoke;
    *(_QWORD *)&v76[24] = &__block_descriptor_tmp_80;
    *(_QWORD *)&v76[32] = v41;
    v77 = v45;
    v78 = 0x1000000;
    v79 = 0;
    v80 = 1;
    memset(v81, 0, sizeof(v81));
    v64 = v41 + 8;
    storage_array_Init((_DWORD *)(v41 + 8), 1044, 0x40000uLL, 1040, v45, 0, 0, 1, 0, 0, 0, (uint64_t)v76);
    goto LABEL_65;
  }
  if (a6 != 2)
  {
    if (a6 == 1)
    {
      if (v75 >= 0)
        v52 = __p;
      else
        v52 = (void **)__p[0];
      v53 = fd_create_protected(a2, (const char *)v52, 0, 0);
      if (!v53)
        goto LABEL_78;
      v65 = a11;
      v54 = (uint64_t)v53;
      v41 = operator new();
      *(_QWORD *)v41 = 0;
      *(_QWORD *)v76 = MEMORY[0x1E0C809B0];
      *(_QWORD *)&v76[8] = 0x40000000;
      *(_QWORD *)&v76[16] = ___ZN30vi_onefixedsize_disk_allocatorC2EmymN19vi_ondisk_allocator11meta_info_sEP16vector_storage_s_block_invoke;
      *(_QWORD *)&v76[24] = &__block_descriptor_tmp_80;
      *(_QWORD *)&v76[32] = v41;
      v77 = v54;
      v78 = 0x1000000;
      v79 = 0;
      v80 = 1;
      memset(v81, 0, sizeof(v81));
      v64 = v41 + 8;
      storage_array_Init((_DWORD *)(v41 + 8), 1044, 0x40000uLL, 2064, v54, 0, 0, 1, 0, 0, 0, (uint64_t)v76);
      goto LABEL_65;
    }
    if (a6)
      goto LABEL_78;
    goto LABEL_44;
  }
  if (v75 >= 0)
    v49 = __p;
  else
    v49 = (void **)__p[0];
  v50 = fd_create_protected(a2, (const char *)v49, 0, 0);
  if (!v50)
    goto LABEL_78;
  v65 = a11;
  v51 = (uint64_t)v50;
  v41 = operator new();
  *(_QWORD *)v41 = 0;
  *(_QWORD *)v76 = MEMORY[0x1E0C809B0];
  *(_QWORD *)&v76[8] = 0x40000000;
  *(_QWORD *)&v76[16] = ___ZN30vi_onefixedsize_disk_allocatorC2EmymN19vi_ondisk_allocator11meta_info_sEP16vector_storage_s_block_invoke;
  *(_QWORD *)&v76[24] = &__block_descriptor_tmp_80;
  *(_QWORD *)&v76[32] = v41;
  v77 = v51;
  v78 = 0x1000000;
  v79 = 0;
  v80 = 1;
  memset(v81, 0, sizeof(v81));
  v64 = v41 + 8;
  storage_array_Init((_DWORD *)(v41 + 8), 1044, 0x40000uLL, 3088, v51, 0, 0, 1, 0, 0, 0, (uint64_t)v76);
LABEL_65:
  v55 = (_DWORD *)_windowsResolvePtr(v41 + 40, 0x400uLL, *(_QWORD *)(v41 + 16));
  if (*v55 == 23010726)
    v56 = v55[1];
  else
    v56 = -1;
  storage_array_Close(v64);
  v57 = *(const void **)(v41 + 4208);
  if (v57)
  {
    CFRelease(v57);
    *(_QWORD *)(v41 + 4208) = 0;
  }
  *(_OWORD *)(v41 + 4192) = 0u;
  MEMORY[0x1BCCB06A4](v41, 0x10A0C408BE2A288);
  v58 = v56 == 1;
  v19 = v65;
  if (v58)
  {
    v63 = a8;
    v25 = a1;
    v26 = a10;
    if (v75 >= 0)
      v27 = __p;
    else
      v27 = (void **)__p[0];
    if (a10)
      v28 = 0;
    else
      v28 = 2;
LABEL_13:
    v29 = fd_create_protected(a2, (const char *)v27, v28, 0);
    v30 = *__error();
    v31 = _SILogForLogForCategory(16);
    v32 = v31;
    if (v29)
    {
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
      {
        v33 = "open";
        if (a9)
          v33 = "create";
        v34 = __p;
        if (v75 < 0)
          v34 = (void **)__p[0];
        *(_DWORD *)v76 = 136315650;
        *(_QWORD *)&v76[4] = v33;
        *(_WORD *)&v76[12] = 2080;
        *(_QWORD *)&v76[14] = v34;
        if (v26)
          v35 = "readOnly";
        else
          v35 = "";
        *(_WORD *)&v76[22] = 2080;
        *(_QWORD *)&v76[24] = v35;
        _os_log_impl(&dword_1B8270000, v32, OS_LOG_TYPE_DEFAULT, "%s vectorIndex: %s %s", v76, 0x20u);
      }
      *__error() = v30;
      v67[0] = v29;
      v67[1] = 0x1000000;
      v68 = 0;
      v69 = v26;
      v70 = a9;
      v71 = 0;
      v72 = a5;
      v73 = 0;
      v36 = v25[1];
      v66[0] = *v25;
      v66[1] = v36;
      VectorIndexInstance = IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::createVectorIndexInstance(a4, a5, a6, a7, (uint64_t)v67, (__int16 *)v66, v63);
    }
    else
    {
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      {
        v60 = "open";
        if (a9)
          v60 = "create";
        *(_DWORD *)v76 = 136316162;
        *(_QWORD *)&v76[4] = "makeIVFDiskOne";
        v61 = __p;
        if (v75 < 0)
          v61 = (void **)__p[0];
        v62 = "";
        *(_WORD *)&v76[12] = 1024;
        *(_DWORD *)&v76[14] = 3766;
        *(_QWORD *)&v76[20] = v60;
        *(_WORD *)&v76[18] = 2080;
        *(_WORD *)&v76[28] = 2080;
        if (v26)
          v62 = "readOnly";
        *(_QWORD *)&v76[30] = v61;
        *(_WORD *)&v76[38] = 2080;
        v77 = (uint64_t)v62;
        _os_log_error_impl(&dword_1B8270000, v32, OS_LOG_TYPE_ERROR, "%s:%d: Failed to %s vectorIndex: %s %s", v76, 0x30u);
      }
      *__error() = v30;
      if (v65)
      {
        VectorIndexInstance = 0;
        if (a9)
          v42 = 2;
        else
          v42 = 3;
        *v65 = v42;
      }
      else
      {
        VectorIndexInstance = 0;
      }
    }
    goto LABEL_80;
  }
LABEL_78:
  VectorIndexInstance = 0;
  if (v19)
    *v19 = 1;
LABEL_80:
  if (SHIBYTE(v75) < 0)
    operator delete(__p[0]);
  return VectorIndexInstance;
}

void std::__shared_ptr_pointer<AnyVectorIndexInstance *,std::shared_ptr<AnyVectorIndexInstance>::__shared_ptr_default_delete<AnyVectorIndexInstance,AnyVectorIndexInstance>,std::allocator<AnyVectorIndexInstance>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BCCB06A4);
}

uint64_t std::__shared_ptr_pointer<AnyVectorIndexInstance *,std::shared_ptr<AnyVectorIndexInstance>::__shared_ptr_default_delete<AnyVectorIndexInstance,AnyVectorIndexInstance>,std::allocator<AnyVectorIndexInstance>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t IVFIndexName(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  std::ios_base *v11;
  uint64_t v12;
  uint64_t v13;
  size_t v14;
  _QWORD *v15;
  size_t v16;
  _QWORD *v17;
  uint64_t v18;
  char *v19;
  const std::locale::facet *v20;
  uint64_t *v21;
  uint64_t *v22;
  uint64_t v23;
  char *v24;
  const std::locale::facet *v25;
  uint64_t v26;
  _QWORD v30[2];
  uint64_t v31;
  __int128 v32;
  _OWORD v33[3];
  void *__p[2];
  __int128 v35;
  uint64_t v36;
  uint64_t v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  std::locale v47;

  v46 = 0u;
  v35 = 0u;
  v36 = 0;
  v45 = 0u;
  v44 = 0u;
  v43 = 0u;
  v42 = 0u;
  v41 = 0u;
  v40 = 0u;
  v39 = 0u;
  v38 = 0u;
  *(_OWORD *)__p = 0u;
  memset(v33, 0, sizeof(v33));
  v5 = MEMORY[0x1E0DE4FD0];
  v32 = 0u;
  v6 = MEMORY[0x1E0DE4FD0] + 104;
  v37 = MEMORY[0x1E0DE4FD0] + 104;
  v7 = (_QWORD *)MEMORY[0x1E0DE4F50];
  v8 = MEMORY[0x1E0DE4FD0] + 64;
  v9 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 16);
  v10 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 24);
  v31 = MEMORY[0x1E0DE4FD0] + 64;
  v30[0] = v9;
  *(_QWORD *)((char *)v30 + *(_QWORD *)(v9 - 24)) = v10;
  v30[1] = 0;
  v11 = (std::ios_base *)((char *)v30 + *(_QWORD *)(v30[0] - 24));
  std::ios_base::init(v11, &v32);
  v11[1].__vftable = 0;
  v11[1].__fmtflags_ = -1;
  v12 = v7[5];
  v31 = v7[4];
  *(uint64_t *)((char *)&v31 + *(_QWORD *)(v31 - 24)) = v12;
  v30[0] = v7[1];
  *(_QWORD *)((char *)v30 + *(_QWORD *)(v30[0] - 24)) = v7[6];
  v37 = v6;
  v30[0] = v5 + 24;
  v31 = v8;
  std::streambuf::basic_streambuf();
  v13 = MEMORY[0x1E0DE4FB8];
  *(_QWORD *)&v32 = MEMORY[0x1E0DE4FB8] + 16;
  *(_OWORD *)__p = 0u;
  v35 = 0u;
  LODWORD(v36) = 24;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v31, (uint64_t)"ivf-", 4);
  v14 = strlen(dim_name_components[a4]);
  v15 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v31, (uint64_t)dim_name_components[a4], v14);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v15, (uint64_t)"x", 1);
  v16 = strlen(off_1E6E37D30[a5]);
  v17 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v31, (uint64_t)off_1E6E37D30[a5], v16);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v17, (uint64_t)"-", 1);
  v18 = v31;
  v19 = (char *)&v31 + *(_QWORD *)(v31 - 24);
  if (*((_DWORD *)v19 + 36) == -1)
  {
    std::ios_base::getloc((const std::ios_base *)((char *)&v31 + *(_QWORD *)(v31 - 24)));
    v20 = std::locale::use_facet(&v47, MEMORY[0x1E0DE4A90]);
    ((void (*)(const std::locale::facet *, uint64_t))v20->__vftable[2].~facet_0)(v20, 32);
    std::locale::~locale(&v47);
    v18 = v31;
  }
  *((_DWORD *)v19 + 36) = 48;
  *(_QWORD *)((char *)v33 + *(_QWORD *)(v18 - 24)) = 8;
  *(_DWORD *)((char *)&v31 + *(_QWORD *)(v18 - 24) + 8) = *(_DWORD *)((_BYTE *)&v31 + *(_QWORD *)(v18 - 24) + 8) & 0xFFFFFFB5 | 8;
  v21 = (uint64_t *)std::ostream::operator<<();
  v22 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v21, (uint64_t)"-", 1);
  v23 = *v22;
  v24 = (char *)v22 + *(_QWORD *)(*v22 - 24);
  if (*((_DWORD *)v24 + 36) == -1)
  {
    std::ios_base::getloc((const std::ios_base *)((char *)v22 + *(_QWORD *)(*v22 - 24)));
    v25 = std::locale::use_facet(&v47, MEMORY[0x1E0DE4A90]);
    ((void (*)(const std::locale::facet *, uint64_t))v25->__vftable[2].~facet_0)(v25, 32);
    std::locale::~locale(&v47);
    v23 = *v21;
  }
  *((_DWORD *)v24 + 36) = 48;
  *(uint64_t *)((char *)v21 + *(_QWORD *)(v23 - 24) + 24) = 8;
  *(_DWORD *)((char *)v21 + *(_QWORD *)(v23 - 24) + 8) = *(_DWORD *)((_BYTE *)v21 + *(_QWORD *)(v23 - 24) + 8) & 0xFFFFFFB5 | 8;
  std::ostream::operator<<();
  std::stringbuf::str();
  v30[0] = *v7;
  v26 = v7[9];
  *(_QWORD *)((char *)v30 + *(_QWORD *)(v30[0] - 24)) = v7[8];
  v31 = v26;
  *(_QWORD *)&v32 = v13 + 16;
  if (SBYTE7(v35) < 0)
    operator delete(__p[0]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1BCCB0650](&v37);
}

uint64_t IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::createVectorIndexInstance(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5, __int16 *a6, char a7)
{
  uint64_t v12;
  uint64_t v13;
  unsigned __int8 v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  unsigned __int8 v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  unsigned __int8 v24;
  int v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  unsigned __int8 v29;
  int v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  unsigned __int8 v34;
  int v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  unsigned __int8 v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  _DWORD *v45;
  int v46;
  int v47;
  _QWORD *v48;
  uint64_t v49;
  uint64_t v50;
  __int16 v51;
  int v52;
  int v53;
  char *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  const void *v58;
  unint64_t v59;
  unint64_t v60;
  uint64_t v61;
  unint64_t v62;
  _QWORD *v63;
  int v64;
  NSObject *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  _QWORD *v70;
  unint64_t v71;
  unint64_t v72;
  os_unfair_lock_s *v73;
  int v74;
  int v75;
  BOOL v76;
  const char *v77;
  size_t v78;
  std::string::size_type v79;
  std::string *v80;
  uint64_t v81;
  uint64_t v82;
  int v83;
  std::string::size_type v84;
  unint64_t v85;
  _BYTE *v86;
  uint64_t v87;
  uint64_t v88;
  std::string *v89;
  std::string *v90;
  std::string::size_type v91;
  std::string *v92;
  std::string::size_type v93;
  std::string *v94;
  std::string::size_type v95;
  std::string *v96;
  std::string::size_type v97;
  std::string *v98;
  unsigned __int8 v99;
  std::string *v100;
  std::string::size_type v101;
  unint64_t v102;
  unint64_t v103;
  unint64_t v104;
  uint8x8_t v105;
  unint64_t v106;
  uint64_t **v107;
  uint64_t *v108;
  uint64_t v109;
  std::__shared_weak_count *v110;
  unint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  int v119;
  int v120;
  int v121;
  _DWORD *v122;
  int v123;
  int v124;
  _QWORD *v125;
  uint64_t v126;
  uint64_t v127;
  __int16 v128;
  int v129;
  int v130;
  char *v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  const void *v135;
  unint64_t v136;
  unint64_t v137;
  uint64_t v138;
  unint64_t v139;
  _QWORD *v140;
  int v141;
  NSObject *v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  _QWORD *v147;
  unint64_t v148;
  unint64_t v149;
  os_unfair_lock_s *v150;
  int v151;
  int v152;
  BOOL v153;
  const char *v154;
  size_t v155;
  std::string::size_type v156;
  std::string *p_dst;
  uint64_t v158;
  uint64_t v159;
  int v160;
  std::string::size_type size;
  unint64_t v162;
  _BYTE *v163;
  uint64_t v164;
  uint64_t v165;
  std::string *v166;
  std::string *v167;
  std::string::size_type v168;
  std::string *v169;
  std::string::size_type v170;
  std::string *v171;
  std::string::size_type v172;
  std::string *v173;
  std::string::size_type v174;
  std::string *v175;
  unsigned __int8 v176;
  std::string *v177;
  std::string::size_type v178;
  unint64_t v179;
  unint64_t v180;
  unint64_t v181;
  uint8x8_t v182;
  unint64_t v183;
  uint64_t **v184;
  uint64_t *v185;
  uint64_t v186;
  std::__shared_weak_count *v187;
  unint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  int v196;
  int v197;
  int v198;
  _DWORD *v199;
  int v200;
  int v201;
  _QWORD *v202;
  uint64_t v203;
  uint64_t v204;
  __int16 v205;
  int v206;
  int v207;
  char *v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  const void *v212;
  unint64_t v213;
  unint64_t v214;
  uint64_t v215;
  unint64_t v216;
  _QWORD *v217;
  int v218;
  NSObject *v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  _QWORD *v224;
  unint64_t v225;
  unint64_t v226;
  os_unfair_lock_s *v227;
  int v228;
  int v229;
  BOOL v230;
  const char *v231;
  size_t v232;
  std::string::size_type v233;
  std::string *v234;
  uint64_t v235;
  uint64_t v236;
  int v237;
  std::string::size_type v238;
  unint64_t v239;
  _BYTE *v240;
  uint64_t v241;
  uint64_t v242;
  std::string *v243;
  std::string *v244;
  std::string::size_type v245;
  std::string *v246;
  std::string::size_type v247;
  std::string *v248;
  std::string::size_type v249;
  std::string *v250;
  std::string::size_type v251;
  std::string *v252;
  unsigned __int8 v253;
  std::string *v254;
  std::string::size_type v255;
  unint64_t v256;
  unint64_t v257;
  unint64_t v258;
  uint8x8_t v259;
  unint64_t v260;
  uint64_t **v261;
  uint64_t *v262;
  uint64_t v263;
  std::__shared_weak_count *v264;
  unint64_t v265;
  uint64_t v266;
  uint64_t v267;
  uint64_t v268;
  uint64_t v269;
  uint64_t v270;
  uint64_t v271;
  uint64_t v272;
  int v273;
  int v274;
  int v275;
  _DWORD *v276;
  int v277;
  int v278;
  _QWORD *v279;
  uint64_t v280;
  uint64_t v281;
  __int16 v282;
  int v283;
  int v284;
  char *v285;
  uint64_t v286;
  uint64_t v287;
  uint64_t v288;
  const void *v289;
  unint64_t v290;
  unint64_t v291;
  uint64_t v292;
  unint64_t v293;
  _QWORD *v294;
  int v295;
  NSObject *v296;
  uint64_t v297;
  uint64_t v298;
  uint64_t v299;
  uint64_t v300;
  _QWORD *v301;
  unint64_t v302;
  unint64_t v303;
  os_unfair_lock_s *v304;
  int v305;
  int v306;
  BOOL v307;
  const char *v308;
  size_t v309;
  std::string::size_type v310;
  std::string *v311;
  uint64_t v312;
  uint64_t v313;
  int v314;
  std::string::size_type v315;
  unint64_t v316;
  _BYTE *v317;
  uint64_t v318;
  uint64_t v319;
  std::string *v320;
  std::string *v321;
  std::string::size_type v322;
  std::string *v323;
  std::string::size_type v324;
  std::string *v325;
  std::string::size_type v326;
  std::string *v327;
  std::string::size_type v328;
  std::string *v329;
  unsigned __int8 v330;
  std::string *v331;
  std::string::size_type v332;
  unint64_t v333;
  unint64_t v334;
  unint64_t v335;
  uint8x8_t v336;
  unint64_t v337;
  uint64_t **v338;
  uint64_t *v339;
  uint64_t v340;
  std::__shared_weak_count *v341;
  unint64_t v342;
  uint64_t v343;
  uint64_t v344;
  uint64_t v345;
  uint64_t v346;
  uint64_t v347;
  uint64_t v348;
  uint64_t v349;
  int v350;
  int v351;
  int v352;
  _DWORD *v353;
  int v354;
  int v355;
  _QWORD *v356;
  uint64_t v357;
  uint64_t v358;
  __int16 v359;
  int v360;
  int v361;
  char *v362;
  uint64_t v363;
  uint64_t v364;
  uint64_t v365;
  const void *v366;
  unint64_t v367;
  unint64_t v368;
  uint64_t v369;
  unint64_t v370;
  _QWORD *v371;
  int v372;
  NSObject *v373;
  uint64_t v374;
  uint64_t v375;
  uint64_t v376;
  uint64_t v377;
  _QWORD *v378;
  unint64_t v379;
  unint64_t v380;
  os_unfair_lock_s *v381;
  int v382;
  int v383;
  BOOL v384;
  const char *v385;
  size_t v386;
  std::string::size_type v387;
  std::string *v388;
  uint64_t v389;
  uint64_t v390;
  int v391;
  std::string::size_type v392;
  unint64_t v393;
  _BYTE *v394;
  uint64_t v395;
  uint64_t v396;
  std::string *v397;
  std::string *v398;
  std::string::size_type v399;
  std::string *v400;
  std::string::size_type v401;
  std::string *v402;
  std::string::size_type v403;
  std::string *v404;
  std::string::size_type v405;
  std::string *v406;
  unsigned __int8 v407;
  std::string *v408;
  std::string::size_type v409;
  unint64_t v410;
  unint64_t v411;
  unint64_t v412;
  uint8x8_t v413;
  unint64_t v414;
  uint64_t **v415;
  uint64_t *v416;
  uint64_t v417;
  std::__shared_weak_count *v418;
  unint64_t v419;
  uint64_t v420;
  uint64_t v421;
  uint64_t v422;
  uint64_t v423;
  uint64_t v424;
  uint64_t v425;
  uint64_t v426;
  int v427;
  int v428;
  int v429;
  _DWORD *v430;
  int v431;
  int v432;
  _QWORD *v433;
  uint64_t v434;
  uint64_t v435;
  __int16 v436;
  int v437;
  int v438;
  char *v439;
  uint64_t v440;
  uint64_t v441;
  uint64_t v442;
  const void *v443;
  unint64_t v444;
  unint64_t v445;
  uint64_t v446;
  unint64_t v447;
  _QWORD *v448;
  int v449;
  NSObject *v450;
  uint64_t v451;
  uint64_t v452;
  uint64_t v453;
  uint64_t v454;
  _QWORD *v455;
  unint64_t v456;
  unint64_t v457;
  os_unfair_lock_s *v458;
  int v459;
  int v460;
  BOOL v461;
  const char *v462;
  size_t v463;
  std::string::size_type v464;
  std::string *v465;
  uint64_t v466;
  uint64_t v467;
  int v468;
  std::string::size_type v469;
  unint64_t v470;
  _BYTE *v471;
  uint64_t v472;
  uint64_t v473;
  std::string *v474;
  std::string *v475;
  std::string::size_type v476;
  std::string *v477;
  std::string::size_type v478;
  std::string *v479;
  std::string::size_type v480;
  std::string *v481;
  std::string::size_type v482;
  std::string *v483;
  unsigned __int8 v484;
  std::string *v485;
  std::string::size_type v486;
  unint64_t v487;
  unint64_t v488;
  unint64_t v489;
  uint8x8_t v490;
  unint64_t v491;
  uint64_t **v492;
  uint64_t *v493;
  uint64_t v494;
  std::__shared_weak_count *v495;
  unint64_t v496;
  uint64_t v497;
  uint64_t v498;
  uint64_t v499;
  uint64_t v500;
  uint64_t v501;
  uint64_t v502;
  uint64_t v503;
  unsigned __int8 *v504;
  std::__shared_weak_count *v505;
  std::__shared_weak_count *v506;
  __int128 v507;
  uint64_t v508;
  uint64_t *v509;
  uint64_t v510;
  uint64_t v511;
  std::string *v512;
  int v513;
  NSObject *v514;
  std::string *v515;
  uint64_t v516;
  int v517;
  const std::string::value_type *v518;
  std::string::size_type v519;
  std::string *v520;
  std::string::size_type v521;
  std::string *v522;
  std::string::size_type v523;
  const char *v524;
  _QWORD *v525;
  unint64_t *v526;
  unint64_t v527;
  __int128 v528;
  unint64_t *v529;
  unint64_t v530;
  unsigned __int8 *v531;
  std::__shared_weak_count *v532;
  __int128 v533;
  std::__shared_weak_count *v534;
  unint64_t *v535;
  unint64_t v536;
  std::__shared_weak_count *v537;
  unint64_t *v538;
  unint64_t v539;
  _DWORD *v540;
  int v541;
  std::string::size_type v542;
  unsigned __int8 *v543;
  std::__shared_weak_count *v544;
  std::__shared_weak_count *v545;
  __int128 v546;
  uint64_t *v547;
  uint64_t v548;
  uint64_t v549;
  std::string *v550;
  int v551;
  NSObject *v552;
  std::string *v553;
  uint64_t v554;
  int v555;
  const std::string::value_type *v556;
  std::string::size_type v557;
  std::string *v558;
  std::string::size_type v559;
  std::string *v560;
  std::string::size_type v561;
  const char *v562;
  _QWORD *v563;
  unint64_t *p_shared_owners;
  unint64_t v565;
  __int128 v566;
  unint64_t *v567;
  unint64_t v568;
  unsigned __int8 *v569;
  std::__shared_weak_count *v570;
  __int128 v571;
  std::__shared_weak_count *v572;
  unint64_t *v573;
  unint64_t v574;
  unint64_t *v575;
  _DWORD *v576;
  int v577;
  std::string::size_type v578;
  unsigned __int8 *v579;
  std::__shared_weak_count *v580;
  std::__shared_weak_count *v581;
  __int128 v582;
  uint64_t *v583;
  uint64_t v584;
  uint64_t v585;
  std::string *v586;
  int v587;
  NSObject *v588;
  std::string *v589;
  uint64_t v590;
  int v591;
  const std::string::value_type *v592;
  std::string::size_type v593;
  std::string *v594;
  std::string::size_type v595;
  std::string *v596;
  std::string::size_type v597;
  const char *v598;
  _QWORD *v599;
  unint64_t *v600;
  unint64_t v601;
  __int128 v602;
  unint64_t *v603;
  unint64_t v604;
  unsigned __int8 *v605;
  std::__shared_weak_count *v606;
  __int128 v607;
  std::__shared_weak_count *v608;
  unint64_t *v609;
  unint64_t v610;
  unint64_t *v611;
  _DWORD *v612;
  int v613;
  std::string::size_type v614;
  unsigned __int8 *v615;
  std::__shared_weak_count *v616;
  std::__shared_weak_count *v617;
  __int128 v618;
  uint64_t *v619;
  uint64_t v620;
  uint64_t v621;
  std::string *v622;
  int v623;
  NSObject *v624;
  std::string *v625;
  uint64_t v626;
  int v627;
  const std::string::value_type *v628;
  std::string::size_type v629;
  std::string *v630;
  std::string::size_type v631;
  std::string *v632;
  std::string::size_type v633;
  const char *v634;
  _QWORD *v635;
  unint64_t *v636;
  unint64_t v637;
  __int128 v638;
  unint64_t *v639;
  unint64_t v640;
  unsigned __int8 *v641;
  std::__shared_weak_count *v642;
  __int128 v643;
  std::__shared_weak_count *v644;
  unint64_t *v645;
  unint64_t v646;
  unint64_t *v647;
  _DWORD *v648;
  int v649;
  std::string::size_type v650;
  unsigned __int8 *v651;
  std::__shared_weak_count *v652;
  std::__shared_weak_count *v653;
  __int128 v654;
  uint64_t *v655;
  uint64_t v656;
  uint64_t v657;
  std::string *v658;
  int v659;
  NSObject *v660;
  std::string *v661;
  uint64_t v662;
  int v663;
  const std::string::value_type *v664;
  std::string::size_type v665;
  std::string *v666;
  std::string::size_type v667;
  std::string *v668;
  std::string::size_type v669;
  const char *v670;
  _QWORD *v671;
  unint64_t *v672;
  unint64_t v673;
  __int128 v674;
  unint64_t *v675;
  unint64_t v676;
  unsigned __int8 *v677;
  std::__shared_weak_count *v678;
  __int128 v679;
  std::__shared_weak_count *v680;
  unint64_t *v681;
  unint64_t v682;
  unint64_t *v683;
  _DWORD *v684;
  int v685;
  std::string::size_type v686;
  unsigned __int8 *v687;
  std::__shared_weak_count *v688;
  std::__shared_weak_count *v689;
  __int128 v690;
  uint64_t *v691;
  uint64_t v692;
  uint64_t v693;
  std::string *v694;
  int v695;
  NSObject *v696;
  std::string *v697;
  uint64_t v698;
  int v699;
  const std::string::value_type *v700;
  std::string::size_type v701;
  std::string *v702;
  std::string::size_type v703;
  std::string *v704;
  std::string::size_type v705;
  const char *v706;
  _QWORD *v707;
  unint64_t *v708;
  unint64_t v709;
  __int128 v710;
  unint64_t *v711;
  unint64_t v712;
  unsigned __int8 *v713;
  std::__shared_weak_count *v714;
  __int128 v715;
  std::__shared_weak_count *v716;
  unint64_t *v717;
  unint64_t v718;
  unint64_t *v719;
  _DWORD *v720;
  int v721;
  std::string::size_type v722;
  int v723;
  char *v724;
  std::__shared_weak_count *v725;
  unint64_t *v726;
  unint64_t v727;
  unint64_t *v728;
  unint64_t v729;
  unint64_t *v730;
  unint64_t v731;
  int v732;
  char *v733;
  std::__shared_weak_count *v734;
  unint64_t *v735;
  unint64_t v736;
  unint64_t *v737;
  unint64_t v738;
  unint64_t *v739;
  unint64_t v740;
  int v741;
  char *v742;
  std::__shared_weak_count *v743;
  unint64_t *v744;
  unint64_t v745;
  unint64_t *v746;
  unint64_t v747;
  unint64_t *v748;
  unint64_t v749;
  int v750;
  char *v751;
  std::__shared_weak_count *v752;
  unint64_t *v753;
  unint64_t v754;
  unint64_t *v755;
  unint64_t v756;
  unint64_t *v757;
  unint64_t v758;
  int v759;
  char *v760;
  std::__shared_weak_count *v761;
  unint64_t *v762;
  unint64_t v763;
  unint64_t *v764;
  unint64_t v765;
  unint64_t *v766;
  unint64_t v767;
  int v768;
  char *v769;
  std::__shared_weak_count *v770;
  unint64_t *v771;
  unint64_t v772;
  unint64_t *v773;
  unint64_t v774;
  unint64_t *v775;
  unint64_t v776;
  int v777;
  NSObject *v778;
  os_log_type_t v779;
  std::string *v780;
  int v781;
  _QWORD *v782;
  int v783;
  int v784;
  unint64_t *v785;
  unint64_t v786;
  std::__shared_weak_count *v787;
  unint64_t *v788;
  unint64_t v789;
  std::__shared_weak_count *v790;
  unint64_t *v791;
  unint64_t v792;
  char *v793;
  size_t v794;
  std::string::size_type v795;
  std::string *v796;
  int v797;
  NSObject *v798;
  os_log_type_t v799;
  std::string *v800;
  int v801;
  _QWORD *v802;
  int v803;
  int v804;
  unint64_t *v805;
  unint64_t v806;
  std::__shared_weak_count *v807;
  unint64_t *v808;
  unint64_t v809;
  std::__shared_weak_count *v810;
  unint64_t *v811;
  unint64_t v812;
  char *v813;
  size_t v814;
  std::string::size_type v815;
  std::string *v816;
  int v817;
  NSObject *v818;
  os_log_type_t v819;
  std::string *v820;
  int v821;
  _QWORD *v822;
  int v823;
  int v824;
  unint64_t *v825;
  unint64_t v826;
  std::__shared_weak_count *v827;
  unint64_t *v828;
  unint64_t v829;
  std::__shared_weak_count *v830;
  unint64_t *v831;
  unint64_t v832;
  char *v833;
  size_t v834;
  std::string::size_type v835;
  std::string *v836;
  int v837;
  NSObject *v838;
  os_log_type_t v839;
  std::string *v840;
  int v841;
  _QWORD *v842;
  int v843;
  int v844;
  unint64_t *v845;
  unint64_t v846;
  std::__shared_weak_count *v847;
  unint64_t *v848;
  unint64_t v849;
  std::__shared_weak_count *v850;
  unint64_t *v851;
  unint64_t v852;
  char *v853;
  size_t v854;
  std::string::size_type v855;
  std::string *v856;
  int v857;
  NSObject *v858;
  os_log_type_t v859;
  std::string *v860;
  int v861;
  _QWORD *v862;
  int v863;
  int v864;
  unint64_t *v865;
  unint64_t v866;
  std::__shared_weak_count *v867;
  unint64_t *v868;
  unint64_t v869;
  std::__shared_weak_count *v870;
  unint64_t *v871;
  unint64_t v872;
  char *v873;
  size_t v874;
  std::string::size_type v875;
  std::string *v876;
  int v877;
  NSObject *v878;
  os_log_type_t v879;
  std::string *v880;
  int v881;
  _QWORD *v882;
  int v883;
  int v884;
  unint64_t *v885;
  unint64_t v886;
  std::__shared_weak_count *v887;
  unint64_t *v888;
  unint64_t v889;
  std::__shared_weak_count *v890;
  unint64_t *v891;
  unint64_t v892;
  char *v893;
  size_t v894;
  std::string::size_type v895;
  std::string *v896;
  uint64_t v897;
  uint64_t v898;
  int v899;
  NSObject *v900;
  os_log_type_t v901;
  std::string *v902;
  std::__shared_weak_count *v903;
  unint64_t *v904;
  unint64_t v905;
  unint64_t v906;
  std::__shared_weak_count *v907;
  unint64_t *v908;
  unint64_t v909;
  std::string::size_type v910;
  std::string::size_type v911;
  unint64_t *v912;
  unint64_t v913;
  std::__shared_weak_count *v914;
  unint64_t *v915;
  unint64_t v916;
  unint64_t *v917;
  unint64_t v918;
  int v919;
  NSObject *v920;
  std::string::size_type v921;
  std::string *v922;
  int v923;
  int v924;
  std::string::size_type v925;
  _QWORD *v926;
  int v927;
  int v928;
  std::__shared_weak_count *v929;
  unint64_t *v930;
  unint64_t v931;
  unint64_t *v932;
  uint64_t v933;
  uint64_t v934;
  int v935;
  NSObject *v936;
  os_log_type_t v937;
  std::string *v938;
  std::__shared_weak_count *v939;
  unint64_t *v940;
  unint64_t v941;
  unint64_t v942;
  std::__shared_weak_count *v943;
  unint64_t *v944;
  unint64_t v945;
  std::string::size_type v946;
  std::string::size_type v947;
  unint64_t *v948;
  unint64_t v949;
  std::__shared_weak_count *v950;
  unint64_t *v951;
  unint64_t v952;
  unint64_t *v953;
  unint64_t v954;
  int v955;
  NSObject *v956;
  std::string::size_type v957;
  std::string *v958;
  int v959;
  int v960;
  std::string::size_type v961;
  _QWORD *v962;
  int v963;
  int v964;
  std::__shared_weak_count *v965;
  unint64_t *v966;
  unint64_t v967;
  unint64_t *v968;
  uint64_t v969;
  uint64_t v970;
  int v971;
  NSObject *v972;
  os_log_type_t v973;
  std::string *v974;
  std::__shared_weak_count *v975;
  unint64_t *v976;
  unint64_t v977;
  unint64_t v978;
  std::__shared_weak_count *v979;
  unint64_t *v980;
  unint64_t v981;
  std::string::size_type v982;
  std::string::size_type v983;
  unint64_t *v984;
  unint64_t v985;
  std::__shared_weak_count *v986;
  unint64_t *v987;
  unint64_t v988;
  unint64_t *v989;
  unint64_t v990;
  int v991;
  NSObject *v992;
  std::string::size_type v993;
  std::string *v994;
  int v995;
  int v996;
  std::string::size_type v997;
  _QWORD *v998;
  int v999;
  int v1000;
  std::__shared_weak_count *v1001;
  unint64_t *v1002;
  unint64_t v1003;
  unint64_t *v1004;
  uint64_t v1005;
  uint64_t v1006;
  int v1007;
  NSObject *v1008;
  os_log_type_t v1009;
  std::string *v1010;
  std::__shared_weak_count *v1011;
  unint64_t *v1012;
  unint64_t v1013;
  unint64_t v1014;
  std::__shared_weak_count *v1015;
  unint64_t *v1016;
  unint64_t v1017;
  std::string::size_type v1018;
  std::string::size_type v1019;
  unint64_t *v1020;
  unint64_t v1021;
  std::__shared_weak_count *v1022;
  unint64_t *v1023;
  unint64_t v1024;
  unint64_t *v1025;
  unint64_t v1026;
  int v1027;
  NSObject *v1028;
  std::string::size_type v1029;
  std::string *v1030;
  int v1031;
  int v1032;
  std::string::size_type v1033;
  _QWORD *v1034;
  int v1035;
  int v1036;
  std::__shared_weak_count *v1037;
  unint64_t *v1038;
  unint64_t v1039;
  unint64_t *v1040;
  uint64_t v1041;
  uint64_t v1042;
  int v1043;
  NSObject *v1044;
  os_log_type_t v1045;
  std::string *v1046;
  std::__shared_weak_count *v1047;
  unint64_t *v1048;
  unint64_t v1049;
  unint64_t v1050;
  std::__shared_weak_count *v1051;
  unint64_t *v1052;
  unint64_t v1053;
  std::string::size_type v1054;
  std::string::size_type v1055;
  unint64_t *v1056;
  unint64_t v1057;
  std::__shared_weak_count *v1058;
  unint64_t *v1059;
  unint64_t v1060;
  unint64_t *v1061;
  unint64_t v1062;
  int v1063;
  NSObject *v1064;
  std::string::size_type v1065;
  std::string *v1066;
  int v1067;
  int v1068;
  std::string::size_type v1069;
  _QWORD *v1070;
  int v1071;
  int v1072;
  std::__shared_weak_count *v1073;
  unint64_t *v1074;
  unint64_t v1075;
  unint64_t *v1076;
  uint64_t v1077;
  uint64_t v1078;
  int v1079;
  NSObject *v1080;
  os_log_type_t v1081;
  std::string *v1082;
  std::__shared_weak_count *v1083;
  unint64_t *v1084;
  unint64_t v1085;
  unint64_t v1086;
  std::__shared_weak_count *v1087;
  unint64_t *v1088;
  unint64_t v1089;
  std::string::size_type v1090;
  std::string::size_type v1091;
  unint64_t *v1092;
  unint64_t v1093;
  std::__shared_weak_count *v1094;
  unint64_t *v1095;
  unint64_t v1096;
  unint64_t *v1097;
  unint64_t v1098;
  int v1099;
  NSObject *v1100;
  std::string::size_type v1101;
  std::string *v1102;
  int v1103;
  int v1104;
  std::string::size_type v1105;
  _QWORD *v1106;
  int v1107;
  int v1108;
  std::__shared_weak_count *v1109;
  unint64_t *v1110;
  unint64_t v1111;
  unint64_t *v1112;
  unint64_t *v1114;
  unint64_t v1115;
  std::__shared_weak_count *v1116;
  unint64_t *v1117;
  unint64_t v1118;
  std::__shared_weak_count *v1119;
  unint64_t *v1120;
  unint64_t v1121;
  unint64_t *v1122;
  unint64_t v1123;
  std::__shared_weak_count *v1124;
  unint64_t *v1125;
  unint64_t v1126;
  std::__shared_weak_count *v1127;
  unint64_t *v1128;
  unint64_t v1129;
  unint64_t *v1130;
  unint64_t v1131;
  std::__shared_weak_count *v1132;
  unint64_t *v1133;
  unint64_t v1134;
  std::__shared_weak_count *v1135;
  unint64_t *v1136;
  unint64_t v1137;
  unint64_t *v1138;
  unint64_t v1139;
  std::__shared_weak_count *v1140;
  unint64_t *v1141;
  unint64_t v1142;
  std::__shared_weak_count *v1143;
  unint64_t *v1144;
  unint64_t v1145;
  unint64_t *v1146;
  unint64_t v1147;
  std::__shared_weak_count *v1148;
  unint64_t *v1149;
  unint64_t v1150;
  std::__shared_weak_count *v1151;
  unint64_t *v1152;
  unint64_t v1153;
  unint64_t *v1154;
  unint64_t v1155;
  std::__shared_weak_count *v1156;
  unint64_t *v1157;
  unint64_t v1158;
  std::__shared_weak_count *v1159;
  unint64_t *v1160;
  unint64_t v1161;
  char *v1162;
  char *v1163;
  const char *v1164;
  char *v1165;
  const char *v1166;
  uint64_t v1167;
  char *v1168;
  char *v1169;
  const char *v1170;
  char *v1171;
  const char *v1172;
  char *v1173;
  const char *v1174;
  char *v1175;
  const char *v1176;
  int v1177;
  int v1178;
  int v1179;
  int v1180;
  int v1181;
  int v1182;
  int v1183;
  int v1184;
  int v1185;
  int v1186;
  int v1187;
  int v1188;
  int v1189;
  int v1190;
  int v1191;
  int v1192;
  int v1193;
  int v1194;
  __int16 v1195;
  __int16 v1196;
  __int16 v1197;
  __int16 v1198;
  __int16 v1199;
  __int16 v1200;
  int v1201;
  int v1202;
  int v1203;
  int v1204;
  int v1205;
  int v1206;
  uint64_t v1207;
  uint64_t v1208;
  uint64_t v1209;
  uint64_t v1210;
  uint64_t v1211;
  uint64_t v1212;
  uint64_t v1213;
  uint64_t v1214;
  uint64_t v1215;
  uint64_t v1216;
  uint64_t v1217;
  uint64_t v1218;
  unsigned __int8 v1219;
  unsigned __int8 v1220;
  unsigned __int8 v1221;
  unsigned __int8 v1222;
  unsigned __int8 v1223;
  unsigned __int8 v1224;
  unsigned int __val;
  unsigned int __vala;
  unsigned int __valb;
  unsigned int __valc;
  unsigned int __vald;
  unsigned int __vale;
  unsigned int __valf;
  unsigned int __valg;
  unsigned int __valh;
  unsigned int __vali;
  unsigned int __valj;
  unsigned int __valk;
  int v1237;
  int v1238;
  int v1239;
  int v1240;
  int v1241;
  int v1242;
  int v1243;
  int v1244;
  int v1245;
  int v1246;
  int v1247;
  int v1248;
  unsigned int v1249;
  __int128 v1250;
  __int128 v1251;
  __int128 v1252;
  __int128 v1253;
  __int128 v1254;
  __int128 v1255;
  int v1256;
  int v1257;
  int v1258;
  int v1259;
  int v1260;
  int v1261;
  uint64_t v1262;
  uint64_t v1263;
  uint64_t v1264;
  uint64_t v1265;
  uint64_t v1266;
  uint64_t v1267;
  __int16 v1268;
  char *v1269;
  std::__shared_weak_count *v1270;
  std::string __dst;
  std::string::size_type v1272;
  char *v1273;
  std::__shared_weak_count *v1274;
  _BYTE v1275[32];
  _BYTE v1276[30];
  __int16 v1277;
  std::string v1278;
  std::string v1279;
  uint64_t v1280;
  __int16 v1281;
  uint64_t v1282;
  int v1283;
  _BYTE buf[32];
  __int16 v1285;
  uint64_t v1286;
  __int16 v1287;
  uint64_t v1288;
  std::string v1289;
  _BYTE v1290[18];
  __int16 v1291;
  int v1292;
  __int16 v1293;
  _QWORD *v1294;
  __int16 v1295;
  int v1296;
  __int16 v1297;
  int v1298;
  uint64_t v1299;

  v1299 = *MEMORY[0x1E0C80C00];
  v1249 = a2;
  if (!a4)
  {
    if (a3 != 2)
    {
      if (a3 != 1)
      {
        if (a3)
          goto LABEL_1882;
        v17 = operator new();
        v18 = *(_QWORD *)a5;
        v1282 = *(_QWORD *)(a5 + 8);
        v1283 = *(_DWORD *)(a5 + 16);
        v19 = *(_BYTE *)(a5 + 20);
        v1238 = *(unsigned __int8 *)(a5 + 21);
        v1280 = *(_QWORD *)(a5 + 22);
        v1281 = *(_WORD *)(a5 + 30);
        v1196 = *a6;
        v1220 = v19;
        __vala = *((_DWORD *)a6 + 4);
        v1208 = *((_QWORD *)a6 + 3);
        *(_QWORD *)v17 = off_1E6E30C80;
        *(_DWORD *)(v17 + 8) = a1;
        *(_QWORD *)(v17 + 12) = 0x400000100;
        *(_WORD *)(v17 + 20) = a2;
        *(_BYTE *)(v17 + 22) = a7;
        IVFIndexName(v17 + 24, a1, a2, 0, 0);
        *(_QWORD *)v17 = off_1E6E34078;
        v20 = *(_DWORD *)(v17 + 12);
        if (v20 == 256)
        {
          v1190 = 0;
        }
        else
        {
          if (v20 == 768)
          {
            v21 = 2;
          }
          else if (v20 == 512)
          {
            v21 = 1;
          }
          else
          {
            v21 = 3;
          }
          v1190 = v21;
        }
        v119 = *(_DWORD *)(v17 + 16);
        v120 = *(unsigned __int16 *)(v17 + 20);
        v121 = *(unsigned __int8 *)(v17 + 22);
        v1263 = v17;
        *(_QWORD *)(v17 + 48) = &off_1E6E341D0;
        *(_QWORD *)(v17 + 56) = v18;
        v122 = (_DWORD *)(v17 + 48);
        if (v119 == 2)
          v123 = 1;
        else
          v123 = 3;
        if (v119 == 4)
          v124 = 0;
        else
          v124 = v123;
        v1184 = v124;
        if (v121)
          v120 |= 0x80000000;
        v1178 = v120;
        *(_QWORD *)(v17 + 64) = v1282;
        *(_DWORD *)(v17 + 72) = v1283;
        *(_BYTE *)(v17 + 76) = v1220;
        *(_BYTE *)(v17 + 77) = v1238;
        *(_QWORD *)(v17 + 78) = v1280;
        *(_WORD *)(v17 + 86) = v1281;
        *(_DWORD *)(v17 + 88) = a1;
        *(_WORD *)(v17 + 92) = a2;
        v125 = operator new(0x68uLL);
        v125[1] = 0;
        v125[2] = 0;
        *v125 = &off_1E6E34218;
        v125[3] = v18;
        *(_QWORD *)&buf[8] = *(_QWORD *)(v17 + 64);
        v126 = *(_QWORD *)&buf[8];
        *(_QWORD *)&buf[13] = *(_QWORD *)(v17 + 69);
        v127 = *(_QWORD *)&buf[13];
        v128 = v1280;
        *(_WORD *)&buf[22] = v1280;
        v129 = *(_DWORD *)(v17 + 80);
        v130 = v122[9];
        v125[4] = v126;
        *(_QWORD *)((char *)v125 + 37) = v127;
        *((_BYTE *)v125 + 45) = v1238;
        *((_WORD *)v125 + 23) = v128;
        *((_DWORD *)v125 + 12) = v129;
        *((_DWORD *)v125 + 13) = v130;
        v125[7] = 0;
        *((_DWORD *)v125 + 16) = 0;
        v125[11] = 0;
        v125[12] = 0;
        v125[10] = 0;
        bzero(v1290, 0x400uLL);
        v131 = fd_name(v18, v1290, 0x400uLL);
        MEMORY[0x1BCCB03B0](v125 + 10, v131);
        v132 = operator new();
        v1214 = v18;
        *(_QWORD *)buf = v18;
        buf[21] = v1238;
        *(_DWORD *)&buf[24] = v129;
        *(_DWORD *)&buf[28] = v130;
        v133 = vi_onefixedsize_disk_allocator::vi_onefixedsize_disk_allocator(v132, 20, 1040, (__int128 *)buf, (uint64_t)(v122 + 30));
        v134 = v125[7];
        v125[7] = v133;
        if (v134)
        {
          storage_array_Close(v134 + 8);
          v135 = *(const void **)(v134 + 4208);
          if (v135)
          {
            CFRelease(v135);
            *(_QWORD *)(v134 + 4208) = 0;
          }
          *(_OWORD *)(v134 + 4192) = 0u;
          MEMORY[0x1BCCB06A4](v134, 0x10A0C408BE2A288);
          v133 = v125[7];
        }
        v136 = _windowsResolvePtr(v133 + 40, 0x400uLL, *(_QWORD *)(v133 + 16));
        v137 = v136;
        if (v1238)
        {
          *(_QWORD *)v136 = 0x1015F1DA6;
          *(_DWORD *)(v136 + 8) = v129;
          v138 = 0xFFFFFFFFLL;
          *(_QWORD *)(v136 + 12) = 0xFFFFFFFFLL;
          LODWORD(v139) = *((_DWORD *)v125 + 16);
        }
        else
        {
          if (*(_DWORD *)v136 != 23010726)
            goto LABEL_1859;
          if (*(_DWORD *)(v136 + 4) != 1)
            goto LABEL_1862;
          v140 = (_QWORD *)v125[7];
          v141 = *__error();
          v142 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v142, OS_LOG_TYPE_DEFAULT))
          {
            v143 = v140[6];
            v144 = v140[7];
            v146 = v140[2];
            v145 = v140[3];
            *(_DWORD *)buf = 134219008;
            *(_QWORD *)&buf[4] = v140;
            *(_WORD *)&buf[12] = 2048;
            *(_QWORD *)&buf[14] = v143;
            *(_WORD *)&buf[22] = 2048;
            *(_QWORD *)&buf[24] = v144;
            v1285 = 2048;
            v1286 = v145;
            v1287 = 2048;
            v1288 = v146;
            _os_log_impl(&dword_1B8270000, v142, OS_LOG_TYPE_DEFAULT, "vi_onefixedsize_disk_allocator %p size: %llu, freeRegion: %llu, header: %llu, elemSize: %lu", buf, 0x34u);
          }
          *__error() = v141;
          v147 = (_QWORD *)v125[7];
          v148 = v147[2];
          v149 = v147[7] - v147[3];
          v139 = v149 / v148;
          if (v149 != v149 / v148 * v148)
            goto LABEL_1869;
          *((_DWORD *)v125 + 16) = v139;
          if (v147[3] != 1044)
            goto LABEL_1872;
          if (v147[2] != 1040)
            goto LABEL_1875;
          v138 = *(_QWORD *)(v137 + 12);
        }
        *(_DWORD *)(v1263 + 160) = 0;
        v150 = (os_unfair_lock_s *)(v1263 + 160);
        *(_QWORD *)((char *)v125 + 68) = v138;
        *(_OWORD *)(v1263 + 112) = 0u;
        *(_QWORD *)(v1263 + 96) = v125 + 3;
        *(_QWORD *)(v1263 + 104) = v125;
        *(_OWORD *)(v1263 + 128) = 0u;
        *(_OWORD *)(v1263 + 144) = 0u;
        *(_WORD *)(v1263 + 168) = v1196;
        *(_WORD *)(v1263 + 170) = v1268;
        *(_DWORD *)(v1263 + 172) = v1190;
        *(_DWORD *)(v1263 + 176) = v1184;
        *(_DWORD *)(v1263 + 180) = v1178;
        *(_DWORD *)(v1263 + 184) = __vala;
        *(_QWORD *)(v1263 + 192) = v1208;
        *(_QWORD *)(v1263 + 200) = 0xFFFFFFFF00000000;
        *(_BYTE *)(v1263 + 208) = v1220;
        *(_DWORD *)(v1263 + 212) = 0;
        *(_DWORD *)(v1263 + 216) = 0;
        if ((_DWORD)v139)
        {
          *(_DWORD *)(v1263 + 212) = *(_DWORD *)(_windowsResolvePtr(v125[7] + 40, *(_QWORD *)(v125[7] + 24), 0x410uLL)+ 1032);
          *(_DWORD *)(v1263 + 216) = *(_DWORD *)(_windowsResolvePtr(*(_QWORD *)(*(_QWORD *)(v1263 + 96) + 32) + 40, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v1263 + 96) + 32) + 24)+ *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v1263 + 96) + 32) + 16)* (*(_DWORD *)(*(_QWORD *)(v1263 + 96) + 40) - 1), 0x410uLL)+ 1032);
        }
        if (v18)
          v151 = *(_DWORD *)(v18 + 44);
        else
          v151 = -1;
        __valg = *(_DWORD *)(v1263 + 88);
        bzero(v1290, 0x400uLL);
        v152 = fcntl(v151, 50, v1290);
        if (v1290[0])
          v153 = v152 < 0;
        else
          v153 = 1;
        if (v153)
          v154 = 0;
        else
          v154 = v1290;
        v155 = strlen(v154);
        if (v155 > 0x7FFFFFFFFFFFFFF7)
          goto LABEL_1881;
        v156 = v155;
        memset(&__dst, 0, sizeof(__dst));
        v1202 = v151;
        if (v155 >= 0x17)
        {
          v158 = (v155 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v155 | 7) != 0x17)
            v158 = v155 | 7;
          v159 = v158 + 1;
          p_dst = (std::string *)operator new(v158 + 1);
          __dst.__r_.__value_.__l.__size_ = v156;
          __dst.__r_.__value_.__r.__words[2] = v159 | 0x8000000000000000;
          __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
        }
        else
        {
          *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v155;
          p_dst = &__dst;
          if (!v155)
          {
LABEL_207:
            p_dst->__r_.__value_.__s.__data_[v156] = 0;
            v160 = SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
            if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              size = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
            else
              size = __dst.__r_.__value_.__l.__size_;
            v162 = size + 1;
            if (size + 1 > 0x7FFFFFFFFFFFFFF7)
              goto LABEL_1881;
            if (v162 >= 0x17)
            {
              v164 = (v162 & 0xFFFFFFFFFFFFFFF8) + 8;
              if ((v162 | 7) != 0x17)
                v164 = v162 | 7;
              v165 = v164 + 1;
              v163 = operator new(v164 + 1);
              *(_QWORD *)&v1275[8] = size + 1;
              *(_QWORD *)&v1275[16] = v165 | 0x8000000000000000;
              *(_QWORD *)v1275 = v163;
            }
            else
            {
              memset(v1275, 0, 24);
              v163 = v1275;
              v1275[23] = size + 1;
              if (!size)
                goto LABEL_221;
            }
            if (v160 >= 0)
              v166 = &__dst;
            else
              v166 = (std::string *)__dst.__r_.__value_.__r.__words[0];
            memmove(v163, v166, size);
LABEL_221:
            *(_WORD *)&v163[size] = 47;
            std::to_string(&v1289, __valg);
            if ((v1289.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v167 = &v1289;
            else
              v167 = (std::string *)v1289.__r_.__value_.__r.__words[0];
            if ((v1289.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v168 = HIBYTE(v1289.__r_.__value_.__r.__words[2]);
            else
              v168 = v1289.__r_.__value_.__l.__size_;
            v169 = std::string::append((std::string *)v1275, (const std::string::value_type *)v167, v168);
            v170 = v169->__r_.__value_.__r.__words[2];
            *(_OWORD *)v1276 = *(_OWORD *)&v169->__r_.__value_.__l.__data_;
            *(_QWORD *)&v1276[16] = v170;
            v169->__r_.__value_.__l.__size_ = 0;
            v169->__r_.__value_.__r.__words[2] = 0;
            v169->__r_.__value_.__r.__words[0] = 0;
            v171 = std::string::append((std::string *)v1276, "-");
            v172 = v171->__r_.__value_.__r.__words[2];
            *(_OWORD *)buf = *(_OWORD *)&v171->__r_.__value_.__l.__data_;
            *(_QWORD *)&buf[16] = v172;
            v171->__r_.__value_.__l.__size_ = 0;
            v171->__r_.__value_.__r.__words[2] = 0;
            v171->__r_.__value_.__r.__words[0] = 0;
            std::to_string(&v1278, v1249);
            if ((v1278.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v173 = &v1278;
            else
              v173 = (std::string *)v1278.__r_.__value_.__r.__words[0];
            if ((v1278.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v174 = HIBYTE(v1278.__r_.__value_.__r.__words[2]);
            else
              v174 = v1278.__r_.__value_.__l.__size_;
            v175 = std::string::append((std::string *)buf, (const std::string::value_type *)v173, v174);
            v1279 = *v175;
            v175->__r_.__value_.__r.__words[0] = 0;
            v175->__r_.__value_.__l.__size_ = 0;
            v175->__r_.__value_.__r.__words[2] = 0;
            if (SHIBYTE(v1278.__r_.__value_.__r.__words[2]) < 0)
            {
              operator delete(v1278.__r_.__value_.__l.__data_);
              if ((buf[23] & 0x80000000) == 0)
              {
LABEL_235:
                if ((v1276[23] & 0x80000000) == 0)
                  goto LABEL_236;
                goto LABEL_250;
              }
            }
            else if ((buf[23] & 0x80000000) == 0)
            {
              goto LABEL_235;
            }
            operator delete(*(void **)buf);
            if ((v1276[23] & 0x80000000) == 0)
            {
LABEL_236:
              if ((SHIBYTE(v1289.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                goto LABEL_237;
              goto LABEL_251;
            }
LABEL_250:
            operator delete(*(void **)v1276);
            if ((SHIBYTE(v1289.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
LABEL_237:
              if ((v1275[23] & 0x80000000) == 0)
                goto LABEL_238;
LABEL_252:
              operator delete(*(void **)v1275);
LABEL_238:
              if ((v176 & 1) == 0
              {
                QuantizerManager<float,256>::sharedInstance(int,unsigned int,unsigned short)::managers = 0u;
                *(_OWORD *)&qword_1EF1B0710 = 0u;
                dword_1EF1B0720 = 1065353216;
                __cxa_atexit((void (*)(void *))std::unordered_map<std::string,std::weak_ptr<QuantizerManager<float,256>>>::~unordered_map[abi:nn180100], &QuantizerManager<float,256>::sharedInstance(int,unsigned int,unsigned short)::managers, &dword_1B8270000);
              }
              os_unfair_lock_lock((os_unfair_lock_t)&QuantizerManager<float,256>::sharedInstance(int,unsigned int,unsigned short)::lock);
              if ((v1279.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                v177 = &v1279;
              else
                v177 = (std::string *)v1279.__r_.__value_.__r.__words[0];
              if ((v1279.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                v178 = HIBYTE(v1279.__r_.__value_.__r.__words[2]);
              else
                v178 = v1279.__r_.__value_.__l.__size_;
              v179 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t *)v177, v178);
              v180 = *((_QWORD *)&QuantizerManager<float,256>::sharedInstance(int,unsigned int,unsigned short)::managers
                     + 1);
              if (!*((_QWORD *)&QuantizerManager<float,256>::sharedInstance(int,unsigned int,unsigned short)::managers
                    + 1))
                goto LABEL_876;
              v181 = v179;
              v182 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&QuantizerManager<float,256>::sharedInstance(int,unsigned int,unsigned short)::managers
                                                    + 8));
              v182.i16[0] = vaddlv_u8(v182);
              if (v182.u32[0] > 1uLL)
              {
                v183 = v179;
                if (v179 >= *((_QWORD *)&QuantizerManager<float,256>::sharedInstance(int,unsigned int,unsigned short)::managers
                             + 1))
                  v183 = v179
                       % *((_QWORD *)&QuantizerManager<float,256>::sharedInstance(int,unsigned int,unsigned short)::managers
                         + 1);
              }
              else
              {
                v183 = (*((_QWORD *)&QuantizerManager<float,256>::sharedInstance(int,unsigned int,unsigned short)::managers
                        + 1)
                      - 1) & v179;
              }
              v184 = *(uint64_t ***)(QuantizerManager<float,256>::sharedInstance(int,unsigned int,unsigned short)::managers
                                  + 8 * v183);
              if (!v184)
                goto LABEL_876;
              v185 = *v184;
              if (!*v184)
                goto LABEL_876;
              if (v182.u32[0] < 2uLL)
              {
                v186 = *((_QWORD *)&QuantizerManager<float,256>::sharedInstance(int,unsigned int,unsigned short)::managers
                       + 1)
                     - 1;
                while (1)
                {
                  v192 = v185[1];
                  if (v192 == v181)
                  {
                    v193 = *((unsigned __int8 *)v185 + 39);
                    if ((v193 & 0x80u) == 0)
                      v194 = *((unsigned __int8 *)v185 + 39);
                    else
                      v194 = v185[3];
                    if (v194 == v178)
                    {
                      if ((v193 & 0x80) != 0)
                      {
                        if (!memcmp((const void *)v185[2], v177, v185[3]))
                          goto LABEL_872;
                      }
                      else
                      {
                        if (!*((_BYTE *)v185 + 39))
                          goto LABEL_872;
                        v195 = 0;
                        while (*((unsigned __int8 *)v185 + v195 + 16) == v177->__r_.__value_.__s.__data_[v195])
                        {
                          if (v193 == ++v195)
                            goto LABEL_871;
                        }
                      }
                    }
                  }
                  else if ((v192 & v186) != v183)
                  {
                    goto LABEL_876;
                  }
                  v187 = 0;
                  v185 = (uint64_t *)*v185;
                  if (!v185)
                    goto LABEL_877;
                }
              }
              while (1)
              {
                v188 = v185[1];
                if (v188 == v181)
                {
                  v189 = *((unsigned __int8 *)v185 + 39);
                  if ((v189 & 0x80u) == 0)
                    v190 = *((unsigned __int8 *)v185 + 39);
                  else
                    v190 = v185[3];
                  if (v190 == v178)
                  {
                    if ((v189 & 0x80) == 0)
                    {
                      if (!*((_BYTE *)v185 + 39))
                        goto LABEL_872;
                      v191 = 0;
                      do
                      {
                        if (*((unsigned __int8 *)v185 + v191 + 16) != v177->__r_.__value_.__s.__data_[v191])
                          goto LABEL_260;
                        ++v191;
                      }
                      while (v189 != v191);
LABEL_871:
                      if (v185)
                      {
LABEL_872:
                        v543 = std::__hash_table<std::__hash_value_type<std::string,std::weak_ptr<QuantizerManager<float,256>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::weak_ptr<QuantizerManager<float,256>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::weak_ptr<QuantizerManager<float,256>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::weak_ptr<QuantizerManager<float,256>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)&v1279, (uint64_t)&v1279);
                        v544 = (std::__shared_weak_count *)*((_QWORD *)v543 + 6);
                        if (v544)
                        {
                          v545 = std::__shared_weak_count::lock(v544);
                          v187 = v545;
                          if (v545 && *((_QWORD *)v543 + 5))
                          {
                            *(_QWORD *)&v546 = *((_QWORD *)v543 + 5);
                            *((_QWORD *)&v546 + 1) = v545;
                            v1251 = v546;
                            v508 = v1263;
                            v547 = (uint64_t *)(v1263 + 112);
                            v548 = v1214;
                            goto LABEL_917;
                          }
LABEL_877:
                          v549 = operator new();
                          if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
                            std::string::__init_copy_ctor_external(&v1289, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
                          else
                            v1289 = __dst;
                          *(_DWORD *)v549 = v1202;
                          *(_DWORD *)(v549 + 4) = __valg;
                          *(_WORD *)(v549 + 8) = v1249;
                          v550 = (std::string *)(v549 + 24);
                          if (SHIBYTE(v1289.__r_.__value_.__r.__words[2]) < 0)
                          {
                            std::string::__init_copy_ctor_external(v550, v1289.__r_.__value_.__l.__data_, v1289.__r_.__value_.__l.__size_);
                          }
                          else
                          {
                            *(_OWORD *)&v550->__r_.__value_.__l.__data_ = *(_OWORD *)&v1289.__r_.__value_.__l.__data_;
                            *(_QWORD *)(v549 + 40) = *((_QWORD *)&v1289.__r_.__value_.__l + 2);
                          }
                          IVFIndexName(v549 + 48, __valg, v1249, 0, 0);
                          *(_OWORD *)(v549 + 112) = 0u;
                          *(_OWORD *)(v549 + 128) = 0u;
                          *(_OWORD *)(v549 + 80) = 0u;
                          *(_OWORD *)(v549 + 96) = 0u;
                          *(_DWORD *)(v549 + 144) = 1065353216;
                          v551 = *__error();
                          v552 = _SILogForLogForCategory(16);
                          if (os_log_type_enabled(v552, OS_LOG_TYPE_DEFAULT))
                          {
                            v553 = &v1289;
                            if ((v1289.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
                              v553 = (std::string *)v1289.__r_.__value_.__r.__words[0];
                            if (*(char *)(v549 + 71) < 0)
                              v554 = *(_QWORD *)(v549 + 48);
                            else
                              v554 = v549 + 48;
                            *(_DWORD *)buf = 136315394;
                            *(_QWORD *)&buf[4] = v553;
                            *(_WORD *)&buf[12] = 2080;
                            *(_QWORD *)&buf[14] = v554;
                            _os_log_impl(&dword_1B8270000, v552, OS_LOG_TYPE_DEFAULT, "QuantizerManager %s/%s created", buf, 0x16u);
                          }
                          *__error() = v551;
                          v1275[23] = 20;
                          strcpy(v1275, "com.apple.spotlight.");
                          v555 = *(char *)(v549 + 71);
                          if (v555 >= 0)
                            v556 = (const std::string::value_type *)(v549 + 48);
                          else
                            v556 = *(const std::string::value_type **)(v549 + 48);
                          if (v555 >= 0)
                            v557 = *(unsigned __int8 *)(v549 + 71);
                          else
                            v557 = *(_QWORD *)(v549 + 56);
                          v558 = std::string::append((std::string *)v1275, v556, v557);
                          v559 = v558->__r_.__value_.__r.__words[2];
                          *(_OWORD *)v1276 = *(_OWORD *)&v558->__r_.__value_.__l.__data_;
                          *(_QWORD *)&v1276[16] = v559;
                          v558->__r_.__value_.__l.__size_ = 0;
                          v558->__r_.__value_.__r.__words[2] = 0;
                          v558->__r_.__value_.__r.__words[0] = 0;
                          v560 = std::string::append((std::string *)v1276, ".quantizerManager");
                          v561 = v560->__r_.__value_.__r.__words[2];
                          *(_OWORD *)buf = *(_OWORD *)&v560->__r_.__value_.__l.__data_;
                          *(_QWORD *)&buf[16] = v561;
                          v560->__r_.__value_.__l.__size_ = 0;
                          v560->__r_.__value_.__r.__words[2] = 0;
                          v560->__r_.__value_.__r.__words[0] = 0;
                          if ((v1276[23] & 0x80000000) != 0)
                            operator delete(*(void **)v1276);
                          if ((v1275[23] & 0x80000000) != 0)
                            operator delete(*(void **)v1275);
                          if (buf[23] >= 0)
                            v562 = buf;
                          else
                            v562 = *(const char **)buf;
                          *(_QWORD *)(v549 + 16) = dispatch_queue_create(v562, 0);
                          atomic_store(0, (unsigned __int8 *)(v549 + 72));
                          if ((buf[23] & 0x80000000) != 0)
                            operator delete(*(void **)buf);
                          v563 = (_QWORD *)operator new();
                          *v563 = &off_1E6E34250;
                          v563[1] = 0;
                          v563[2] = 0;
                          v563[3] = v549;
                          if (v187)
                          {
                            p_shared_owners = (unint64_t *)&v187->__shared_owners_;
                            do
                              v565 = __ldaxr(p_shared_owners);
                            while (__stlxr(v565 - 1, p_shared_owners));
                            if (!v565)
                            {
                              ((void (*)(std::__shared_weak_count *))v187->__on_zero_shared)(v187);
                              std::__shared_weak_count::__release_weak(v187);
                            }
                          }
                          *(_QWORD *)&v566 = v549;
                          if (SHIBYTE(v1289.__r_.__value_.__r.__words[2]) < 0)
                          {
                            operator delete(v1289.__r_.__value_.__l.__data_);
                            *(_QWORD *)&v566 = v549;
                          }
                          *((_QWORD *)&v566 + 1) = v563;
                          v1251 = v566;
                          v567 = v563 + 2;
                          v508 = v1263;
                          v547 = (uint64_t *)(v1263 + 112);
                          do
                            v568 = __ldxr(v567);
                          while (__stxr(v568 + 1, v567));
                          v569 = std::__hash_table<std::__hash_value_type<std::string,std::weak_ptr<QuantizerManager<float,256>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::weak_ptr<QuantizerManager<float,256>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::weak_ptr<QuantizerManager<float,256>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::weak_ptr<QuantizerManager<float,256>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)&v1279, (uint64_t)&v1279);
                          v570 = (std::__shared_weak_count *)*((_QWORD *)v569 + 6);
                          *((_QWORD *)v569 + 5) = v549;
                          *((_QWORD *)v569 + 6) = v563;
                          if (v570)
                            std::__shared_weak_count::__release_weak(v570);
                          v548 = v1214;
LABEL_917:
                          os_unfair_lock_unlock((os_unfair_lock_t)&QuantizerManager<float,256>::sharedInstance(int,unsigned int,unsigned short)::lock);
                          if (SHIBYTE(v1279.__r_.__value_.__r.__words[2]) < 0)
                            operator delete(v1279.__r_.__value_.__l.__data_);
                          v571 = v1251;
                          if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
                          {
                            operator delete(__dst.__r_.__value_.__l.__data_);
                            v571 = v1251;
                          }
                          v572 = *(std::__shared_weak_count **)(v508 + 120);
                          *(_OWORD *)(v508 + 112) = v571;
                          if (v572)
                          {
                            v573 = (unint64_t *)&v572->__shared_owners_;
                            do
                              v574 = __ldaxr(v573);
                            while (__stlxr(v574 - 1, v573));
                            if (!v574)
                            {
                              ((void (*)(std::__shared_weak_count *))v572->__on_zero_shared)(v572);
                              std::__shared_weak_count::__release_weak(v572);
                            }
                          }
                          if (v1238)
                          {
                            QuantizerManager<float,256>::sharedQuantizer(v1290, *v547, 0);
                            IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::replaceQuantizer((uint64_t)v122, (uint64_t *)v1290);
                            v537 = *(std::__shared_weak_count **)&v1290[8];
                            if (*(_QWORD *)&v1290[8])
                            {
                              v575 = (unint64_t *)(*(_QWORD *)&v1290[8] + 8);
                              do
                                v539 = __ldaxr(v575);
                              while (__stlxr(v539 - 1, v575));
                              goto LABEL_1772;
                            }
                            return v508;
                          }
                          memset(buf, 0, sizeof(buf));
                          *(_QWORD *)v1276 = v548;
                          *(_QWORD *)&v1276[8] = v1282;
                          *(_DWORD *)&v1276[16] = v1283;
                          *(_WORD *)&v1276[20] = v1220;
                          *(_QWORD *)&v1276[22] = v1280;
                          v1277 = v1281;
                          *((_BYTE *)&v1279.__r_.__value_.__s + 23) = 11;
                          strcpy((char *)&v1279, ".partitions");
                          IVFVectorIndexTemplate<float,768>::childMetaInfo((uint64_t)buf, (uint64_t)v1276, (uint64_t)&v1279, 0);
                          if (SHIBYTE(v1279.__r_.__value_.__r.__words[2]) < 0)
                            operator delete(v1279.__r_.__value_.__l.__data_);
                          *(_OWORD *)&v1278.__r_.__value_.__l.__data_ = 0uLL;
                          *(_OWORD *)v1275 = *(_OWORD *)buf;
                          *(_OWORD *)&v1275[16] = *(_OWORD *)&buf[16];
                          PartitionStore<vi_onefixedsize_disk_allocator,512>::openPartitionStore<vi_onefixedsize_disk_allocator>((std::__shared_weak_count **)&v1278, (uint64_t)v1275);
                          v576 = (_DWORD *)v1278.__r_.__value_.__r.__words[0];
                          if (v1278.__r_.__value_.__r.__words[0])
                          {
                            v577 = *(_DWORD *)(v1278.__r_.__value_.__r.__words[0] + 76);
                            v578 = v1278.__r_.__value_.__r.__words[0];
                          }
                          else
                          {
                            v578 = 0;
                            v577 = 0;
                          }
                          v1273 = 0;
                          v1274 = 0;
                          QuantizerManager<float,256>::sharedQuantizer(&v1273, *v547, v577);
                          if (v578)
                          {
                            v732 = *(_DWORD *)(v578 + 76);
                            v733 = v1273;
                            if (v732 == (*(unsigned int (**)(char *))(*(_QWORD *)v1273 + 16))(v1273))
                            {
                              if (v576[18] == *(_DWORD *)(*(_QWORD *)(v508 + 96) + 40))
                              {
                                v734 = v1274;
                                if (v1274)
                                {
                                  v735 = (unint64_t *)&v1274->__shared_owners_;
                                  do
                                    v736 = __ldxr(v735);
                                  while (__stxr(v736 + 1, v735));
                                  AnyPartitionStore::replaceQuantizer((uint64_t)v576, (uint64_t)v733, (uint64_t)v734);
                                  v737 = (unint64_t *)&v734->__shared_owners_;
                                  do
                                    v738 = __ldaxr(v737);
                                  while (__stlxr(v738 - 1, v737));
                                  if (!v738)
                                  {
                                    ((void (*)(std::__shared_weak_count *))v734->__on_zero_shared)(v734);
                                    std::__shared_weak_count::__release_weak(v734);
                                  }
                                  *(_QWORD *)v1290 = v1273;
                                  *(_QWORD *)&v1290[8] = v1274;
                                  if (v1274)
                                  {
                                    v739 = (unint64_t *)&v1274->__shared_owners_;
                                    do
                                      v740 = __ldxr(v739);
                                    while (__stxr(v740 + 1, v739));
                                  }
                                }
                                else
                                {
                                  AnyPartitionStore::replaceQuantizer((uint64_t)v576, (uint64_t)v733, 0);
                                  *(_QWORD *)v1290 = v1273;
                                  *(_QWORD *)&v1290[8] = 0;
                                }
                                *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = *(_OWORD *)&v1278.__r_.__value_.__l.__data_;
                                if (v1278.__r_.__value_.__l.__size_)
                                {
                                  v1122 = (unint64_t *)(v1278.__r_.__value_.__l.__size_ + 8);
                                  do
                                    v1123 = __ldxr(v1122);
                                  while (__stxr(v1123 + 1, v1122));
                                }
                                (*(void (**)(_DWORD *, _BYTE *, std::string *))(*(_QWORD *)v122 + 48))(v122, v1290, &__dst);
                                v1124 = (std::__shared_weak_count *)__dst.__r_.__value_.__l.__size_;
                                if (__dst.__r_.__value_.__l.__size_)
                                {
                                  v1125 = (unint64_t *)(__dst.__r_.__value_.__l.__size_ + 8);
                                  do
                                    v1126 = __ldaxr(v1125);
                                  while (__stlxr(v1126 - 1, v1125));
                                  if (!v1126)
                                  {
                                    ((void (*)(std::__shared_weak_count *))v1124->__on_zero_shared)(v1124);
                                    std::__shared_weak_count::__release_weak(v1124);
                                  }
                                }
                                v1127 = *(std::__shared_weak_count **)&v1290[8];
                                if (*(_QWORD *)&v1290[8])
                                {
                                  v1128 = (unint64_t *)(*(_QWORD *)&v1290[8] + 8);
                                  do
                                    v1129 = __ldaxr(v1128);
                                  while (__stlxr(v1129 - 1, v1128));
                                  if (!v1129)
                                  {
                                    ((void (*)(std::__shared_weak_count *))v1127->__on_zero_shared)(v1127);
                                    std::__shared_weak_count::__release_weak(v1127);
                                  }
                                }
                                goto LABEL_1544;
                              }
LABEL_1309:
                              v797 = *__error();
                              v798 = _SILogForLogForCategory(16);
                              v799 = dword_1EF19FCCC < 3;
                              if (os_log_type_enabled(v798, (os_log_type_t)(dword_1EF19FCCC < 3)))
                              {
                                v1257 = v797;
                                (*(void (**)(std::string *__return_ptr, _DWORD *))(*(_QWORD *)v576 + 144))(&__dst, v576);
                                if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                                  v800 = &__dst;
                                else
                                  v800 = (std::string *)__dst.__r_.__value_.__r.__words[0];
                                v801 = v576[19];
                                v1244 = v576[18];
                                v802 = v733 + 8;
                                if (v733[31] < 0)
                                  v802 = (_QWORD *)*v802;
                                v803 = (*(uint64_t (**)(char *))(*(_QWORD *)v733 + 16))(v733);
                                v804 = *(_DWORD *)(*(_QWORD *)(v1263 + 96) + 40);
                                *(_DWORD *)v1290 = 136316418;
                                *(_QWORD *)&v1290[4] = v800;
                                *(_WORD *)&v1290[12] = 1024;
                                *(_DWORD *)&v1290[14] = v801;
                                v1291 = 1024;
                                v1292 = v1244;
                                v1293 = 2080;
                                v1294 = v802;
                                v1295 = 1024;
                                v1296 = v803;
                                v1297 = 1024;
                                v1298 = v804;
                                _os_log_impl(&dword_1B8270000, v798, v799, "*warn* Rebuild! Partitions %s version: %d count: %u not match Quantizer %s version %d vectors count:%u.", v1290, 0x2Eu);
                                if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
                                  operator delete(__dst.__r_.__value_.__l.__data_);
                                v508 = v1263;
                                v797 = v1257;
                              }
                              *__error() = v797;
                              *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = 0uLL;
                              __dst.__r_.__value_.__r.__words[2] = (std::string::size_type)v576;
                              v1272 = v1278.__r_.__value_.__l.__size_;
                              if (v1278.__r_.__value_.__l.__size_)
                              {
                                v805 = (unint64_t *)(v1278.__r_.__value_.__l.__size_ + 8);
                                do
                                  v806 = __ldxr(v805);
                                while (__stxr(v806 + 1, v805));
                              }
                              os_unfair_lock_lock(v150);
                              std::swap[abi:nn180100]<IVFVectorIndexTemplate<float,768>::QuantizerPartitions>((__int128 *)(v1263 + 128), (__int128 *)&__dst);
                              os_unfair_lock_unlock(v150);
                              v807 = (std::__shared_weak_count *)v1272;
                              if (v1272)
                              {
                                v808 = (unint64_t *)(v1272 + 8);
                                do
                                  v809 = __ldaxr(v808);
                                while (__stlxr(v809 - 1, v808));
                                if (!v809)
                                {
                                  ((void (*)(std::__shared_weak_count *))v807->__on_zero_shared)(v807);
                                  std::__shared_weak_count::__release_weak(v807);
                                }
                              }
                              v810 = (std::__shared_weak_count *)__dst.__r_.__value_.__l.__size_;
                              if (__dst.__r_.__value_.__l.__size_)
                              {
                                v811 = (unint64_t *)(__dst.__r_.__value_.__l.__size_ + 8);
                                do
                                  v812 = __ldaxr(v811);
                                while (__stlxr(v812 - 1, v811));
                                if (!v812)
                                {
                                  ((void (*)(std::__shared_weak_count *))v810->__on_zero_shared)(v810);
                                  std::__shared_weak_count::__release_weak(v810);
                                }
                              }
LABEL_1509:
                              v939 = v1274;
                              v1269 = v1273;
                              v1270 = v1274;
                              if (v1274)
                              {
                                v940 = (unint64_t *)&v1274->__shared_owners_;
                                do
                                  v941 = __ldxr(v940);
                                while (__stxr(v941 + 1, v940));
                                IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::replaceQuantizer((uint64_t)v122, (uint64_t *)&v1269);
                                do
                                  v942 = __ldaxr(v940);
                                while (__stlxr(v942 - 1, v940));
                                if (!v942)
                                {
                                  ((void (*)(std::__shared_weak_count *))v939->__on_zero_shared)(v939);
                                  std::__shared_weak_count::__release_weak(v939);
                                }
                              }
                              else
                              {
                                IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::replaceQuantizer((uint64_t)v122, (uint64_t *)&v1269);
                              }
                              os_unfair_lock_lock(v150);
                              v943 = *(std::__shared_weak_count **)(v508 + 136);
                              if (v943)
                              {
                                v944 = (unint64_t *)&v943->__shared_owners_;
                                do
                                  v945 = __ldxr(v944);
                                while (__stxr(v945 + 1, v944));
                              }
                              v947 = *(_QWORD *)(v508 + 144);
                              v946 = *(_QWORD *)(v508 + 152);
                              if (v946)
                              {
                                v948 = (unint64_t *)(v946 + 8);
                                do
                                  v949 = __ldxr(v948);
                                while (__stxr(v949 + 1, v948));
                              }
                              os_unfair_lock_unlock(v150);
                              v950 = (std::__shared_weak_count *)v1278.__r_.__value_.__l.__size_;
                              v1278.__r_.__value_.__r.__words[0] = v947;
                              v1278.__r_.__value_.__l.__size_ = v946;
                              if (v950)
                              {
                                v951 = (unint64_t *)&v950->__shared_owners_;
                                do
                                  v952 = __ldaxr(v951);
                                while (__stlxr(v952 - 1, v951));
                                if (!v952)
                                {
                                  ((void (*)(std::__shared_weak_count *))v950->__on_zero_shared)(v950);
                                  std::__shared_weak_count::__release_weak(v950);
                                }
                              }
                              if (v943)
                              {
                                v953 = (unint64_t *)&v943->__shared_owners_;
                                do
                                  v954 = __ldaxr(v953);
                                while (__stlxr(v954 - 1, v953));
                                if (!v954)
                                {
                                  ((void (*)(std::__shared_weak_count *))v943->__on_zero_shared)(v943);
                                  std::__shared_weak_count::__release_weak(v943);
                                }
                              }
                              if (*(_BYTE *)(v508 + 208))
                                (*(void (**)(std::string::size_type))(*(_QWORD *)v1278.__r_.__value_.__l.__data_
                                                                               + 120))(v1278.__r_.__value_.__r.__words[0]);
                              v955 = *__error();
                              v956 = _SILogForLogForCategory(16);
                              if (os_log_type_enabled(v956, OS_LOG_TYPE_DEFAULT))
                              {
                                v957 = v1278.__r_.__value_.__r.__words[0];
                                (*(void (**)(std::string *__return_ptr, std::string::size_type))(*(_QWORD *)v1278.__r_.__value_.__l.__data_ + 144))(&v1289, v1278.__r_.__value_.__r.__words[0]);
                                if ((v1289.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                                  v958 = &v1289;
                                else
                                  v958 = (std::string *)v1289.__r_.__value_.__r.__words[0];
                                v961 = v957 + 72;
                                v959 = *(_DWORD *)(v957 + 72);
                                v960 = *(_DWORD *)(v961 + 4);
                                v962 = v1273 + 8;
                                if (v1273[31] < 0)
                                  v962 = (_QWORD *)*v962;
                                v963 = (*(uint64_t (**)(void))(*(_QWORD *)v1273 + 16))();
                                v964 = *(_DWORD *)(*(_QWORD *)(v508 + 96) + 40);
                                *(_DWORD *)v1290 = 136316418;
                                *(_QWORD *)&v1290[4] = v958;
                                *(_WORD *)&v1290[12] = 1024;
                                *(_DWORD *)&v1290[14] = v960;
                                v1291 = 1024;
                                v1292 = v959;
                                v1293 = 2080;
                                v1294 = v962;
                                v1295 = 1024;
                                v1296 = v963;
                                v1297 = 1024;
                                v1298 = v964;
                                _os_log_impl(&dword_1B8270000, v956, OS_LOG_TYPE_DEFAULT, "Partitions rebuilt %s version: %d count: %u not match Quantizer %s version %d vectors count:%u.", v1290, 0x2Eu);
                                if (SHIBYTE(v1289.__r_.__value_.__r.__words[2]) < 0)
                                  operator delete(v1289.__r_.__value_.__l.__data_);
                              }
                              *__error() = v955;
LABEL_1544:
                              v965 = v1274;
                              if (v1274)
                              {
                                v966 = (unint64_t *)&v1274->__shared_owners_;
                                do
                                  v967 = __ldaxr(v966);
                                while (__stlxr(v967 - 1, v966));
                                if (!v967)
                                {
                                  ((void (*)(std::__shared_weak_count *))v965->__on_zero_shared)(v965);
                                  std::__shared_weak_count::__release_weak(v965);
                                }
                              }
                              v537 = (std::__shared_weak_count *)v1278.__r_.__value_.__l.__size_;
                              if (v1278.__r_.__value_.__l.__size_)
                              {
                                v968 = (unint64_t *)(v1278.__r_.__value_.__l.__size_ + 8);
                                do
                                  v539 = __ldaxr(v968);
                                while (__stlxr(v539 - 1, v968));
                                goto LABEL_1772;
                              }
                              return v508;
                            }
                            if (v576)
                              goto LABEL_1309;
                          }
                          bzero(v1290, 0x400uLL);
                          memset(&__dst, 0, sizeof(__dst));
                          v813 = fd_name(v548, v1290, 0x400uLL);
                          v814 = strlen(v813);
                          if (v814 > 0x7FFFFFFFFFFFFFF7)
                            goto LABEL_1881;
                          v815 = v814;
                          if (v814 >= 0x17)
                          {
                            v933 = (v814 & 0xFFFFFFFFFFFFFFF8) + 8;
                            if ((v814 | 7) != 0x17)
                              v933 = v814 | 7;
                            v934 = v933 + 1;
                            v816 = (std::string *)operator new(v933 + 1);
                            __dst.__r_.__value_.__l.__size_ = v815;
                            __dst.__r_.__value_.__r.__words[2] = v934 | 0x8000000000000000;
                            __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v816;
                          }
                          else
                          {
                            *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v814;
                            v816 = &__dst;
                            if (!v814)
                              goto LABEL_1502;
                          }
                          memmove(v816, v813, v815);
LABEL_1502:
                          v816->__r_.__value_.__s.__data_[v815] = 0;
                          std::string::append(&__dst, ".partitions");
                          v935 = *__error();
                          v936 = _SILogForLogForCategory(16);
                          v937 = dword_1EF19FCCC < 3;
                          if (os_log_type_enabled(v936, (os_log_type_t)(dword_1EF19FCCC < 3)))
                          {
                            if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                              v938 = &__dst;
                            else
                              v938 = (std::string *)__dst.__r_.__value_.__r.__words[0];
                            LODWORD(v1289.__r_.__value_.__l.__data_) = 136315138;
                            *(std::string::size_type *)((char *)v1289.__r_.__value_.__r.__words + 4) = (std::string::size_type)v938;
                            _os_log_impl(&dword_1B8270000, v936, v937, "*warn* Rebuild! Partitions %s currupted", (uint8_t *)&v1289, 0xCu);
                          }
                          *__error() = v935;
                          if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
                            operator delete(__dst.__r_.__value_.__l.__data_);
                          goto LABEL_1509;
                        }
                      }
LABEL_876:
                      v187 = 0;
                      goto LABEL_877;
                    }
                    if (!memcmp((const void *)v185[2], v177, v185[3]))
                      goto LABEL_872;
                  }
                }
                else
                {
                  if (v188 >= v180)
                    v188 %= v180;
                  if (v188 != v183)
                    goto LABEL_876;
                }
LABEL_260:
                v187 = 0;
                v185 = (uint64_t *)*v185;
                if (!v185)
                  goto LABEL_877;
              }
            }
LABEL_251:
            operator delete(v1289.__r_.__value_.__l.__data_);
            if ((v1275[23] & 0x80000000) == 0)
              goto LABEL_238;
            goto LABEL_252;
          }
        }
        memcpy(p_dst, v154, v156);
        goto LABEL_207;
      }
      v37 = operator new();
      v38 = *(_QWORD *)a5;
      v1282 = *(_QWORD *)(a5 + 8);
      v1283 = *(_DWORD *)(a5 + 16);
      v39 = *(_BYTE *)(a5 + 20);
      v1242 = *(unsigned __int8 *)(a5 + 21);
      v1280 = *(_QWORD *)(a5 + 22);
      v1281 = *(_WORD *)(a5 + 30);
      v1200 = *a6;
      v1224 = v39;
      __vale = *((_DWORD *)a6 + 4);
      v1212 = *((_QWORD *)a6 + 3);
      *(_QWORD *)v37 = off_1E6E30C80;
      *(_DWORD *)(v37 + 8) = a1;
      *(_QWORD *)(v37 + 12) = 0x400000200;
      *(_WORD *)(v37 + 20) = a2;
      *(_BYTE *)(v37 + 22) = a7;
      IVFIndexName(v37 + 24, a1, a2, 1, 0);
      *(_QWORD *)v37 = off_1E6E343C0;
      v40 = *(_DWORD *)(v37 + 12);
      if (v40 == 256)
      {
        v1194 = 0;
      }
      else
      {
        if (v40 == 768)
        {
          v41 = 2;
        }
        else if (v40 == 512)
        {
          v41 = 1;
        }
        else
        {
          v41 = 3;
        }
        v1194 = v41;
      }
      v427 = *(_DWORD *)(v37 + 16);
      v428 = *(unsigned __int16 *)(v37 + 20);
      v429 = *(unsigned __int8 *)(v37 + 22);
      v1267 = v37;
      *(_QWORD *)(v37 + 48) = &off_1E6E34518;
      *(_QWORD *)(v37 + 56) = v38;
      v430 = (_DWORD *)(v37 + 48);
      if (v427 == 2)
        v431 = 1;
      else
        v431 = 3;
      if (v427 == 4)
        v432 = 0;
      else
        v432 = v431;
      v1188 = v432;
      if (v429)
        v428 |= 0x80000000;
      v1182 = v428;
      *(_QWORD *)(v37 + 64) = v1282;
      *(_DWORD *)(v37 + 72) = v1283;
      *(_BYTE *)(v37 + 76) = v1224;
      *(_BYTE *)(v37 + 77) = v1242;
      *(_QWORD *)(v37 + 78) = v1280;
      *(_WORD *)(v37 + 86) = v1281;
      *(_DWORD *)(v37 + 88) = a1;
      *(_WORD *)(v37 + 92) = a2;
      v433 = operator new(0x68uLL);
      v433[1] = 0;
      v433[2] = 0;
      *v433 = &off_1E6E34560;
      v433[3] = v38;
      *(_QWORD *)&buf[8] = *(_QWORD *)(v37 + 64);
      v434 = *(_QWORD *)&buf[8];
      *(_QWORD *)&buf[13] = *(_QWORD *)(v37 + 69);
      v435 = *(_QWORD *)&buf[13];
      v436 = v1280;
      *(_WORD *)&buf[22] = v1280;
      v437 = *(_DWORD *)(v37 + 80);
      v438 = v430[9];
      v433[4] = v434;
      *(_QWORD *)((char *)v433 + 37) = v435;
      *((_BYTE *)v433 + 45) = v1242;
      *((_WORD *)v433 + 23) = v436;
      *((_DWORD *)v433 + 12) = v437;
      *((_DWORD *)v433 + 13) = v438;
      v433[7] = 0;
      *((_DWORD *)v433 + 16) = 0;
      v433[11] = 0;
      v433[12] = 0;
      v433[10] = 0;
      bzero(v1290, 0x400uLL);
      v439 = fd_name(v38, v1290, 0x400uLL);
      MEMORY[0x1BCCB03B0](v433 + 10, v439);
      v440 = operator new();
      v1218 = v38;
      *(_QWORD *)buf = v38;
      buf[21] = v1242;
      *(_DWORD *)&buf[24] = v437;
      *(_DWORD *)&buf[28] = v438;
      v441 = vi_onefixedsize_disk_allocator::vi_onefixedsize_disk_allocator(v440, 20, 2064, (__int128 *)buf, (uint64_t)(v430 + 30));
      v442 = v433[7];
      v433[7] = v441;
      if (v442)
      {
        storage_array_Close(v442 + 8);
        v443 = *(const void **)(v442 + 4208);
        if (v443)
        {
          CFRelease(v443);
          *(_QWORD *)(v442 + 4208) = 0;
        }
        *(_OWORD *)(v442 + 4192) = 0u;
        MEMORY[0x1BCCB06A4](v442, 0x10A0C408BE2A288);
        v441 = v433[7];
      }
      v444 = _windowsResolvePtr(v441 + 40, 0x400uLL, *(_QWORD *)(v441 + 16));
      v445 = v444;
      if (v1242)
      {
        *(_QWORD *)v444 = 0x1015F1DA6;
        *(_DWORD *)(v444 + 8) = v437;
        v446 = 0xFFFFFFFFLL;
        *(_QWORD *)(v444 + 12) = 0xFFFFFFFFLL;
        LODWORD(v447) = *((_DWORD *)v433 + 16);
      }
      else
      {
        if (*(_DWORD *)v444 != 23010726)
          goto LABEL_1859;
        if (*(_DWORD *)(v444 + 4) != 1)
          goto LABEL_1862;
        v448 = (_QWORD *)v433[7];
        v449 = *__error();
        v450 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v450, OS_LOG_TYPE_DEFAULT))
        {
          v451 = v448[6];
          v452 = v448[7];
          v454 = v448[2];
          v453 = v448[3];
          *(_DWORD *)buf = 134219008;
          *(_QWORD *)&buf[4] = v448;
          *(_WORD *)&buf[12] = 2048;
          *(_QWORD *)&buf[14] = v451;
          *(_WORD *)&buf[22] = 2048;
          *(_QWORD *)&buf[24] = v452;
          v1285 = 2048;
          v1286 = v453;
          v1287 = 2048;
          v1288 = v454;
          _os_log_impl(&dword_1B8270000, v450, OS_LOG_TYPE_DEFAULT, "vi_onefixedsize_disk_allocator %p size: %llu, freeRegion: %llu, header: %llu, elemSize: %lu", buf, 0x34u);
        }
        *__error() = v449;
        v455 = (_QWORD *)v433[7];
        v456 = v455[2];
        v457 = v455[7] - v455[3];
        v447 = v457 / v456;
        if (v457 != v457 / v456 * v456)
          goto LABEL_1869;
        *((_DWORD *)v433 + 16) = v447;
        if (v455[3] != 1044)
          goto LABEL_1872;
        if (v455[2] != 2064)
          goto LABEL_1875;
        v446 = *(_QWORD *)(v445 + 12);
      }
      *(_DWORD *)(v1267 + 160) = 0;
      v458 = (os_unfair_lock_s *)(v1267 + 160);
      *(_QWORD *)((char *)v433 + 68) = v446;
      *(_OWORD *)(v1267 + 112) = 0u;
      *(_QWORD *)(v1267 + 96) = v433 + 3;
      *(_QWORD *)(v1267 + 104) = v433;
      *(_OWORD *)(v1267 + 128) = 0u;
      *(_OWORD *)(v1267 + 144) = 0u;
      *(_WORD *)(v1267 + 168) = v1200;
      *(_WORD *)(v1267 + 170) = v1268;
      *(_DWORD *)(v1267 + 172) = v1194;
      *(_DWORD *)(v1267 + 176) = v1188;
      *(_DWORD *)(v1267 + 180) = v1182;
      *(_DWORD *)(v1267 + 184) = __vale;
      *(_QWORD *)(v1267 + 192) = v1212;
      *(_QWORD *)(v1267 + 200) = 0xFFFFFFFF00000000;
      *(_BYTE *)(v1267 + 208) = v1224;
      *(_DWORD *)(v1267 + 212) = 0;
      *(_DWORD *)(v1267 + 216) = 0;
      if ((_DWORD)v447)
      {
        *(_DWORD *)(v1267 + 212) = *(_DWORD *)(_windowsResolvePtr(v433[7] + 40, *(_QWORD *)(v433[7] + 24), 0x810uLL)
                                             + 2056);
        *(_DWORD *)(v1267 + 216) = *(_DWORD *)(_windowsResolvePtr(*(_QWORD *)(*(_QWORD *)(v1267 + 96) + 32) + 40, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v1267 + 96) + 32) + 24)+ *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v1267 + 96) + 32) + 16)* (*(_DWORD *)(*(_QWORD *)(v1267 + 96) + 40) - 1), 0x810uLL)+ 2056);
      }
      if (v38)
        v459 = *(_DWORD *)(v38 + 44);
      else
        v459 = -1;
      __valk = *(_DWORD *)(v1267 + 88);
      bzero(v1290, 0x400uLL);
      v460 = fcntl(v459, 50, v1290);
      if (v1290[0])
        v461 = v460 < 0;
      else
        v461 = 1;
      if (v461)
        v462 = 0;
      else
        v462 = v1290;
      v463 = strlen(v462);
      if (v463 > 0x7FFFFFFFFFFFFFF7)
        goto LABEL_1881;
      v464 = v463;
      memset(&__dst, 0, sizeof(__dst));
      v1206 = v459;
      if (v463 >= 0x17)
      {
        v466 = (v463 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v463 | 7) != 0x17)
          v466 = v463 | 7;
        v467 = v466 + 1;
        v465 = (std::string *)operator new(v466 + 1);
        __dst.__r_.__value_.__l.__size_ = v464;
        __dst.__r_.__value_.__r.__words[2] = v467 | 0x8000000000000000;
        __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v465;
      }
      else
      {
        *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v463;
        v465 = &__dst;
        if (!v463)
        {
LABEL_723:
          v465->__r_.__value_.__s.__data_[v464] = 0;
          v468 = SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
          if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v469 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
          else
            v469 = __dst.__r_.__value_.__l.__size_;
          v470 = v469 + 1;
          if (v469 + 1 > 0x7FFFFFFFFFFFFFF7)
            goto LABEL_1881;
          if (v470 >= 0x17)
          {
            v472 = (v470 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v470 | 7) != 0x17)
              v472 = v470 | 7;
            v473 = v472 + 1;
            v471 = operator new(v472 + 1);
            *(_QWORD *)&v1275[8] = v469 + 1;
            *(_QWORD *)&v1275[16] = v473 | 0x8000000000000000;
            *(_QWORD *)v1275 = v471;
          }
          else
          {
            memset(v1275, 0, 24);
            v471 = v1275;
            v1275[23] = v469 + 1;
            if (!v469)
              goto LABEL_737;
          }
          if (v468 >= 0)
            v474 = &__dst;
          else
            v474 = (std::string *)__dst.__r_.__value_.__r.__words[0];
          memmove(v471, v474, v469);
LABEL_737:
          *(_WORD *)&v471[v469] = 47;
          std::to_string(&v1289, __valk);
          if ((v1289.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v475 = &v1289;
          else
            v475 = (std::string *)v1289.__r_.__value_.__r.__words[0];
          if ((v1289.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v476 = HIBYTE(v1289.__r_.__value_.__r.__words[2]);
          else
            v476 = v1289.__r_.__value_.__l.__size_;
          v477 = std::string::append((std::string *)v1275, (const std::string::value_type *)v475, v476);
          v478 = v477->__r_.__value_.__r.__words[2];
          *(_OWORD *)v1276 = *(_OWORD *)&v477->__r_.__value_.__l.__data_;
          *(_QWORD *)&v1276[16] = v478;
          v477->__r_.__value_.__l.__size_ = 0;
          v477->__r_.__value_.__r.__words[2] = 0;
          v477->__r_.__value_.__r.__words[0] = 0;
          v479 = std::string::append((std::string *)v1276, "-");
          v480 = v479->__r_.__value_.__r.__words[2];
          *(_OWORD *)buf = *(_OWORD *)&v479->__r_.__value_.__l.__data_;
          *(_QWORD *)&buf[16] = v480;
          v479->__r_.__value_.__l.__size_ = 0;
          v479->__r_.__value_.__r.__words[2] = 0;
          v479->__r_.__value_.__r.__words[0] = 0;
          std::to_string(&v1278, v1249);
          if ((v1278.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v481 = &v1278;
          else
            v481 = (std::string *)v1278.__r_.__value_.__r.__words[0];
          if ((v1278.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v482 = HIBYTE(v1278.__r_.__value_.__r.__words[2]);
          else
            v482 = v1278.__r_.__value_.__l.__size_;
          v483 = std::string::append((std::string *)buf, (const std::string::value_type *)v481, v482);
          v1279 = *v483;
          v483->__r_.__value_.__r.__words[0] = 0;
          v483->__r_.__value_.__l.__size_ = 0;
          v483->__r_.__value_.__r.__words[2] = 0;
          if (SHIBYTE(v1278.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(v1278.__r_.__value_.__l.__data_);
            if ((buf[23] & 0x80000000) == 0)
            {
LABEL_751:
              if ((v1276[23] & 0x80000000) == 0)
                goto LABEL_752;
              goto LABEL_766;
            }
          }
          else if ((buf[23] & 0x80000000) == 0)
          {
            goto LABEL_751;
          }
          operator delete(*(void **)buf);
          if ((v1276[23] & 0x80000000) == 0)
          {
LABEL_752:
            if ((SHIBYTE(v1289.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              goto LABEL_753;
            goto LABEL_767;
          }
LABEL_766:
          operator delete(*(void **)v1276);
          if ((SHIBYTE(v1289.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
LABEL_753:
            if ((v1275[23] & 0x80000000) == 0)
              goto LABEL_754;
LABEL_768:
            operator delete(*(void **)v1275);
LABEL_754:
            if ((v484 & 1) == 0
            {
              QuantizerManager<float,512>::sharedInstance(int,unsigned int,unsigned short)::managers = 0u;
              *(_OWORD *)&qword_1EF1B0748 = 0u;
              dword_1EF1B0758 = 1065353216;
              __cxa_atexit((void (*)(void *))std::unordered_map<std::string,std::weak_ptr<QuantizerManager<float,512>>>::~unordered_map[abi:nn180100], &QuantizerManager<float,512>::sharedInstance(int,unsigned int,unsigned short)::managers, &dword_1B8270000);
            }
            os_unfair_lock_lock((os_unfair_lock_t)&QuantizerManager<float,512>::sharedInstance(int,unsigned int,unsigned short)::lock);
            if ((v1279.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v485 = &v1279;
            else
              v485 = (std::string *)v1279.__r_.__value_.__r.__words[0];
            if ((v1279.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v486 = HIBYTE(v1279.__r_.__value_.__r.__words[2]);
            else
              v486 = v1279.__r_.__value_.__l.__size_;
            v487 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t *)v485, v486);
            v488 = *((_QWORD *)&QuantizerManager<float,512>::sharedInstance(int,unsigned int,unsigned short)::managers
                   + 1);
            if (!*((_QWORD *)&QuantizerManager<float,512>::sharedInstance(int,unsigned int,unsigned short)::managers + 1))
              goto LABEL_1132;
            v489 = v487;
            v490 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&QuantizerManager<float,512>::sharedInstance(int,unsigned int,unsigned short)::managers
                                                  + 8));
            v490.i16[0] = vaddlv_u8(v490);
            if (v490.u32[0] > 1uLL)
            {
              v491 = v487;
              if (v487 >= *((_QWORD *)&QuantizerManager<float,512>::sharedInstance(int,unsigned int,unsigned short)::managers
                           + 1))
                v491 = v487
                     % *((_QWORD *)&QuantizerManager<float,512>::sharedInstance(int,unsigned int,unsigned short)::managers
                       + 1);
            }
            else
            {
              v491 = (*((_QWORD *)&QuantizerManager<float,512>::sharedInstance(int,unsigned int,unsigned short)::managers
                      + 1)
                    - 1) & v487;
            }
            v492 = *(uint64_t ***)(QuantizerManager<float,512>::sharedInstance(int,unsigned int,unsigned short)::managers
                                + 8 * v491);
            if (!v492)
              goto LABEL_1132;
            v493 = *v492;
            if (!*v492)
              goto LABEL_1132;
            if (v490.u32[0] < 2uLL)
            {
              v494 = *((_QWORD *)&QuantizerManager<float,512>::sharedInstance(int,unsigned int,unsigned short)::managers
                     + 1)
                   - 1;
              while (1)
              {
                v500 = v493[1];
                if (v500 == v489)
                {
                  v501 = *((unsigned __int8 *)v493 + 39);
                  if ((v501 & 0x80u) == 0)
                    v502 = *((unsigned __int8 *)v493 + 39);
                  else
                    v502 = v493[3];
                  if (v502 == v486)
                  {
                    if ((v501 & 0x80) != 0)
                    {
                      if (!memcmp((const void *)v493[2], v485, v493[3]))
                        goto LABEL_1128;
                    }
                    else
                    {
                      if (!*((_BYTE *)v493 + 39))
                        goto LABEL_1128;
                      v503 = 0;
                      while (*((unsigned __int8 *)v493 + v503 + 16) == v485->__r_.__value_.__s.__data_[v503])
                      {
                        if (v501 == ++v503)
                          goto LABEL_1127;
                      }
                    }
                  }
                }
                else if ((v500 & v494) != v491)
                {
                  goto LABEL_1132;
                }
                v495 = 0;
                v493 = (uint64_t *)*v493;
                if (!v493)
                  goto LABEL_1133;
              }
            }
            while (1)
            {
              v496 = v493[1];
              if (v496 == v489)
              {
                v497 = *((unsigned __int8 *)v493 + 39);
                if ((v497 & 0x80u) == 0)
                  v498 = *((unsigned __int8 *)v493 + 39);
                else
                  v498 = v493[3];
                if (v498 == v486)
                {
                  if ((v497 & 0x80) == 0)
                  {
                    if (!*((_BYTE *)v493 + 39))
                      goto LABEL_1128;
                    v499 = 0;
                    do
                    {
                      if (*((unsigned __int8 *)v493 + v499 + 16) != v485->__r_.__value_.__s.__data_[v499])
                        goto LABEL_776;
                      ++v499;
                    }
                    while (v497 != v499);
LABEL_1127:
                    if (v493)
                    {
LABEL_1128:
                      v687 = std::__hash_table<std::__hash_value_type<std::string,std::weak_ptr<QuantizerManager<float,512>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::weak_ptr<QuantizerManager<float,512>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::weak_ptr<QuantizerManager<float,512>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::weak_ptr<QuantizerManager<float,512>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)&v1279, (uint64_t)&v1279);
                      v688 = (std::__shared_weak_count *)*((_QWORD *)v687 + 6);
                      if (v688)
                      {
                        v689 = std::__shared_weak_count::lock(v688);
                        v495 = v689;
                        if (v689 && *((_QWORD *)v687 + 5))
                        {
                          *(_QWORD *)&v690 = *((_QWORD *)v687 + 5);
                          *((_QWORD *)&v690 + 1) = v689;
                          v1255 = v690;
                          v508 = v1267;
                          v691 = (uint64_t *)(v1267 + 112);
                          v692 = v1218;
                          goto LABEL_1173;
                        }
LABEL_1133:
                        v693 = operator new();
                        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
                          std::string::__init_copy_ctor_external(&v1289, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
                        else
                          v1289 = __dst;
                        *(_DWORD *)v693 = v1206;
                        *(_DWORD *)(v693 + 4) = __valk;
                        *(_WORD *)(v693 + 8) = v1249;
                        v694 = (std::string *)(v693 + 24);
                        if (SHIBYTE(v1289.__r_.__value_.__r.__words[2]) < 0)
                        {
                          std::string::__init_copy_ctor_external(v694, v1289.__r_.__value_.__l.__data_, v1289.__r_.__value_.__l.__size_);
                        }
                        else
                        {
                          *(_OWORD *)&v694->__r_.__value_.__l.__data_ = *(_OWORD *)&v1289.__r_.__value_.__l.__data_;
                          *(_QWORD *)(v693 + 40) = *((_QWORD *)&v1289.__r_.__value_.__l + 2);
                        }
                        IVFIndexName(v693 + 48, __valk, v1249, 1, 0);
                        *(_OWORD *)(v693 + 112) = 0u;
                        *(_OWORD *)(v693 + 128) = 0u;
                        *(_OWORD *)(v693 + 80) = 0u;
                        *(_OWORD *)(v693 + 96) = 0u;
                        *(_DWORD *)(v693 + 144) = 1065353216;
                        v695 = *__error();
                        v696 = _SILogForLogForCategory(16);
                        if (os_log_type_enabled(v696, OS_LOG_TYPE_DEFAULT))
                        {
                          v697 = &v1289;
                          if ((v1289.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
                            v697 = (std::string *)v1289.__r_.__value_.__r.__words[0];
                          if (*(char *)(v693 + 71) < 0)
                            v698 = *(_QWORD *)(v693 + 48);
                          else
                            v698 = v693 + 48;
                          *(_DWORD *)buf = 136315394;
                          *(_QWORD *)&buf[4] = v697;
                          *(_WORD *)&buf[12] = 2080;
                          *(_QWORD *)&buf[14] = v698;
                          _os_log_impl(&dword_1B8270000, v696, OS_LOG_TYPE_DEFAULT, "QuantizerManager %s/%s created", buf, 0x16u);
                        }
                        *__error() = v695;
                        v1275[23] = 20;
                        strcpy(v1275, "com.apple.spotlight.");
                        v699 = *(char *)(v693 + 71);
                        if (v699 >= 0)
                          v700 = (const std::string::value_type *)(v693 + 48);
                        else
                          v700 = *(const std::string::value_type **)(v693 + 48);
                        if (v699 >= 0)
                          v701 = *(unsigned __int8 *)(v693 + 71);
                        else
                          v701 = *(_QWORD *)(v693 + 56);
                        v702 = std::string::append((std::string *)v1275, v700, v701);
                        v703 = v702->__r_.__value_.__r.__words[2];
                        *(_OWORD *)v1276 = *(_OWORD *)&v702->__r_.__value_.__l.__data_;
                        *(_QWORD *)&v1276[16] = v703;
                        v702->__r_.__value_.__l.__size_ = 0;
                        v702->__r_.__value_.__r.__words[2] = 0;
                        v702->__r_.__value_.__r.__words[0] = 0;
                        v704 = std::string::append((std::string *)v1276, ".quantizerManager");
                        v705 = v704->__r_.__value_.__r.__words[2];
                        *(_OWORD *)buf = *(_OWORD *)&v704->__r_.__value_.__l.__data_;
                        *(_QWORD *)&buf[16] = v705;
                        v704->__r_.__value_.__l.__size_ = 0;
                        v704->__r_.__value_.__r.__words[2] = 0;
                        v704->__r_.__value_.__r.__words[0] = 0;
                        if ((v1276[23] & 0x80000000) != 0)
                          operator delete(*(void **)v1276);
                        if ((v1275[23] & 0x80000000) != 0)
                          operator delete(*(void **)v1275);
                        if (buf[23] >= 0)
                          v706 = buf;
                        else
                          v706 = *(const char **)buf;
                        *(_QWORD *)(v693 + 16) = dispatch_queue_create(v706, 0);
                        atomic_store(0, (unsigned __int8 *)(v693 + 72));
                        if ((buf[23] & 0x80000000) != 0)
                          operator delete(*(void **)buf);
                        v707 = (_QWORD *)operator new();
                        *v707 = &off_1E6E34598;
                        v707[1] = 0;
                        v707[2] = 0;
                        v707[3] = v693;
                        if (v495)
                        {
                          v708 = (unint64_t *)&v495->__shared_owners_;
                          do
                            v709 = __ldaxr(v708);
                          while (__stlxr(v709 - 1, v708));
                          if (!v709)
                          {
                            ((void (*)(std::__shared_weak_count *))v495->__on_zero_shared)(v495);
                            std::__shared_weak_count::__release_weak(v495);
                          }
                        }
                        *(_QWORD *)&v710 = v693;
                        if (SHIBYTE(v1289.__r_.__value_.__r.__words[2]) < 0)
                        {
                          operator delete(v1289.__r_.__value_.__l.__data_);
                          *(_QWORD *)&v710 = v693;
                        }
                        *((_QWORD *)&v710 + 1) = v707;
                        v1255 = v710;
                        v711 = v707 + 2;
                        v508 = v1267;
                        v691 = (uint64_t *)(v1267 + 112);
                        do
                          v712 = __ldxr(v711);
                        while (__stxr(v712 + 1, v711));
                        v713 = std::__hash_table<std::__hash_value_type<std::string,std::weak_ptr<QuantizerManager<float,512>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::weak_ptr<QuantizerManager<float,512>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::weak_ptr<QuantizerManager<float,512>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::weak_ptr<QuantizerManager<float,512>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)&v1279, (uint64_t)&v1279);
                        v714 = (std::__shared_weak_count *)*((_QWORD *)v713 + 6);
                        *((_QWORD *)v713 + 5) = v693;
                        *((_QWORD *)v713 + 6) = v707;
                        if (v714)
                          std::__shared_weak_count::__release_weak(v714);
                        v692 = v1218;
LABEL_1173:
                        os_unfair_lock_unlock((os_unfair_lock_t)&QuantizerManager<float,512>::sharedInstance(int,unsigned int,unsigned short)::lock);
                        if (SHIBYTE(v1279.__r_.__value_.__r.__words[2]) < 0)
                          operator delete(v1279.__r_.__value_.__l.__data_);
                        v715 = v1255;
                        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
                        {
                          operator delete(__dst.__r_.__value_.__l.__data_);
                          v715 = v1255;
                        }
                        v716 = *(std::__shared_weak_count **)(v508 + 120);
                        *(_OWORD *)(v508 + 112) = v715;
                        if (v716)
                        {
                          v717 = (unint64_t *)&v716->__shared_owners_;
                          do
                            v718 = __ldaxr(v717);
                          while (__stlxr(v718 - 1, v717));
                          if (!v718)
                          {
                            ((void (*)(std::__shared_weak_count *))v716->__on_zero_shared)(v716);
                            std::__shared_weak_count::__release_weak(v716);
                          }
                        }
                        if (v1242)
                        {
                          QuantizerManager<float,512>::sharedQuantizer(v1290, *v691, 0);
                          IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::replaceQuantizer((uint64_t)v430, (uint64_t *)v1290);
                          v537 = *(std::__shared_weak_count **)&v1290[8];
                          if (*(_QWORD *)&v1290[8])
                          {
                            v719 = (unint64_t *)(*(_QWORD *)&v1290[8] + 8);
                            do
                              v539 = __ldaxr(v719);
                            while (__stlxr(v539 - 1, v719));
                            goto LABEL_1772;
                          }
                          return v508;
                        }
                        memset(buf, 0, sizeof(buf));
                        *(_QWORD *)v1276 = v692;
                        *(_QWORD *)&v1276[8] = v1282;
                        *(_DWORD *)&v1276[16] = v1283;
                        *(_WORD *)&v1276[20] = v1224;
                        *(_QWORD *)&v1276[22] = v1280;
                        v1277 = v1281;
                        *((_BYTE *)&v1279.__r_.__value_.__s + 23) = 11;
                        strcpy((char *)&v1279, ".partitions");
                        IVFVectorIndexTemplate<float,768>::childMetaInfo((uint64_t)buf, (uint64_t)v1276, (uint64_t)&v1279, 0);
                        if (SHIBYTE(v1279.__r_.__value_.__r.__words[2]) < 0)
                          operator delete(v1279.__r_.__value_.__l.__data_);
                        *(_OWORD *)&v1278.__r_.__value_.__l.__data_ = 0uLL;
                        *(_OWORD *)v1275 = *(_OWORD *)buf;
                        *(_OWORD *)&v1275[16] = *(_OWORD *)&buf[16];
                        PartitionStore<vi_onefixedsize_disk_allocator,512>::openPartitionStore<vi_onefixedsize_disk_allocator>((std::__shared_weak_count **)&v1278, (uint64_t)v1275);
                        v720 = (_DWORD *)v1278.__r_.__value_.__r.__words[0];
                        if (v1278.__r_.__value_.__r.__words[0])
                        {
                          v721 = *(_DWORD *)(v1278.__r_.__value_.__r.__words[0] + 76);
                          v722 = v1278.__r_.__value_.__r.__words[0];
                        }
                        else
                        {
                          v722 = 0;
                          v721 = 0;
                        }
                        v1273 = 0;
                        v1274 = 0;
                        QuantizerManager<float,512>::sharedQuantizer(&v1273, *v691, v721);
                        if (v722)
                        {
                          v768 = *(_DWORD *)(v722 + 76);
                          v769 = v1273;
                          if (v768 == (*(unsigned int (**)(char *))(*(_QWORD *)v1273 + 16))(v1273))
                          {
                            if (v720[18] == *(_DWORD *)(*(_QWORD *)(v508 + 96) + 40))
                            {
                              v770 = v1274;
                              if (v1274)
                              {
                                v771 = (unint64_t *)&v1274->__shared_owners_;
                                do
                                  v772 = __ldxr(v771);
                                while (__stxr(v772 + 1, v771));
                                AnyPartitionStore::replaceQuantizer((uint64_t)v720, (uint64_t)v769, (uint64_t)v770);
                                v773 = (unint64_t *)&v770->__shared_owners_;
                                do
                                  v774 = __ldaxr(v773);
                                while (__stlxr(v774 - 1, v773));
                                if (!v774)
                                {
                                  ((void (*)(std::__shared_weak_count *))v770->__on_zero_shared)(v770);
                                  std::__shared_weak_count::__release_weak(v770);
                                }
                                *(_QWORD *)v1290 = v1273;
                                *(_QWORD *)&v1290[8] = v1274;
                                if (v1274)
                                {
                                  v775 = (unint64_t *)&v1274->__shared_owners_;
                                  do
                                    v776 = __ldxr(v775);
                                  while (__stxr(v776 + 1, v775));
                                }
                              }
                              else
                              {
                                AnyPartitionStore::replaceQuantizer((uint64_t)v720, (uint64_t)v769, 0);
                                *(_QWORD *)v1290 = v1273;
                                *(_QWORD *)&v1290[8] = 0;
                              }
                              *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = *(_OWORD *)&v1278.__r_.__value_.__l.__data_;
                              if (v1278.__r_.__value_.__l.__size_)
                              {
                                v1154 = (unint64_t *)(v1278.__r_.__value_.__l.__size_ + 8);
                                do
                                  v1155 = __ldxr(v1154);
                                while (__stxr(v1155 + 1, v1154));
                              }
                              (*(void (**)(_DWORD *, _BYTE *, std::string *))(*(_QWORD *)v430 + 48))(v430, v1290, &__dst);
                              v1156 = (std::__shared_weak_count *)__dst.__r_.__value_.__l.__size_;
                              if (__dst.__r_.__value_.__l.__size_)
                              {
                                v1157 = (unint64_t *)(__dst.__r_.__value_.__l.__size_ + 8);
                                do
                                  v1158 = __ldaxr(v1157);
                                while (__stlxr(v1158 - 1, v1157));
                                if (!v1158)
                                {
                                  ((void (*)(std::__shared_weak_count *))v1156->__on_zero_shared)(v1156);
                                  std::__shared_weak_count::__release_weak(v1156);
                                }
                              }
                              v1159 = *(std::__shared_weak_count **)&v1290[8];
                              if (*(_QWORD *)&v1290[8])
                              {
                                v1160 = (unint64_t *)(*(_QWORD *)&v1290[8] + 8);
                                do
                                  v1161 = __ldaxr(v1160);
                                while (__stlxr(v1161 - 1, v1160));
                                if (!v1161)
                                {
                                  ((void (*)(std::__shared_weak_count *))v1159->__on_zero_shared)(v1159);
                                  std::__shared_weak_count::__release_weak(v1159);
                                }
                              }
                              goto LABEL_1764;
                            }
LABEL_1417:
                            v877 = *__error();
                            v878 = _SILogForLogForCategory(16);
                            v879 = dword_1EF19FCCC < 3;
                            if (os_log_type_enabled(v878, (os_log_type_t)(dword_1EF19FCCC < 3)))
                            {
                              v1261 = v877;
                              (*(void (**)(std::string *__return_ptr, _DWORD *))(*(_QWORD *)v720 + 144))(&__dst, v720);
                              if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                                v880 = &__dst;
                              else
                                v880 = (std::string *)__dst.__r_.__value_.__r.__words[0];
                              v881 = v720[19];
                              v1248 = v720[18];
                              v882 = v769 + 8;
                              if (v769[31] < 0)
                                v882 = (_QWORD *)*v882;
                              v883 = (*(uint64_t (**)(char *))(*(_QWORD *)v769 + 16))(v769);
                              v884 = *(_DWORD *)(*(_QWORD *)(v1267 + 96) + 40);
                              *(_DWORD *)v1290 = 136316418;
                              *(_QWORD *)&v1290[4] = v880;
                              *(_WORD *)&v1290[12] = 1024;
                              *(_DWORD *)&v1290[14] = v881;
                              v1291 = 1024;
                              v1292 = v1248;
                              v1293 = 2080;
                              v1294 = v882;
                              v1295 = 1024;
                              v1296 = v883;
                              v1297 = 1024;
                              v1298 = v884;
                              _os_log_impl(&dword_1B8270000, v878, v879, "*warn* Rebuild! Partitions %s version: %d count: %u not match Quantizer %s version %d vectors count:%u.", v1290, 0x2Eu);
                              if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
                                operator delete(__dst.__r_.__value_.__l.__data_);
                              v508 = v1267;
                              v877 = v1261;
                            }
                            *__error() = v877;
                            *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = 0uLL;
                            __dst.__r_.__value_.__r.__words[2] = (std::string::size_type)v720;
                            v1272 = v1278.__r_.__value_.__l.__size_;
                            if (v1278.__r_.__value_.__l.__size_)
                            {
                              v885 = (unint64_t *)(v1278.__r_.__value_.__l.__size_ + 8);
                              do
                                v886 = __ldxr(v885);
                              while (__stxr(v886 + 1, v885));
                            }
                            os_unfair_lock_lock(v458);
                            std::swap[abi:nn180100]<IVFVectorIndexTemplate<float,768>::QuantizerPartitions>((__int128 *)(v1267 + 128), (__int128 *)&__dst);
                            os_unfair_lock_unlock(v458);
                            v887 = (std::__shared_weak_count *)v1272;
                            if (v1272)
                            {
                              v888 = (unint64_t *)(v1272 + 8);
                              do
                                v889 = __ldaxr(v888);
                              while (__stlxr(v889 - 1, v888));
                              if (!v889)
                              {
                                ((void (*)(std::__shared_weak_count *))v887->__on_zero_shared)(v887);
                                std::__shared_weak_count::__release_weak(v887);
                              }
                            }
                            v890 = (std::__shared_weak_count *)__dst.__r_.__value_.__l.__size_;
                            if (__dst.__r_.__value_.__l.__size_)
                            {
                              v891 = (unint64_t *)(__dst.__r_.__value_.__l.__size_ + 8);
                              do
                                v892 = __ldaxr(v891);
                              while (__stlxr(v892 - 1, v891));
                              if (!v892)
                              {
                                ((void (*)(std::__shared_weak_count *))v890->__on_zero_shared)(v890);
                                std::__shared_weak_count::__release_weak(v890);
                              }
                            }
LABEL_1729:
                            v1083 = v1274;
                            v1269 = v1273;
                            v1270 = v1274;
                            if (v1274)
                            {
                              v1084 = (unint64_t *)&v1274->__shared_owners_;
                              do
                                v1085 = __ldxr(v1084);
                              while (__stxr(v1085 + 1, v1084));
                              IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::replaceQuantizer((uint64_t)v430, (uint64_t *)&v1269);
                              do
                                v1086 = __ldaxr(v1084);
                              while (__stlxr(v1086 - 1, v1084));
                              if (!v1086)
                              {
                                ((void (*)(std::__shared_weak_count *))v1083->__on_zero_shared)(v1083);
                                std::__shared_weak_count::__release_weak(v1083);
                              }
                            }
                            else
                            {
                              IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::replaceQuantizer((uint64_t)v430, (uint64_t *)&v1269);
                            }
                            os_unfair_lock_lock(v458);
                            v1087 = *(std::__shared_weak_count **)(v508 + 136);
                            if (v1087)
                            {
                              v1088 = (unint64_t *)&v1087->__shared_owners_;
                              do
                                v1089 = __ldxr(v1088);
                              while (__stxr(v1089 + 1, v1088));
                            }
                            v1091 = *(_QWORD *)(v508 + 144);
                            v1090 = *(_QWORD *)(v508 + 152);
                            if (v1090)
                            {
                              v1092 = (unint64_t *)(v1090 + 8);
                              do
                                v1093 = __ldxr(v1092);
                              while (__stxr(v1093 + 1, v1092));
                            }
                            os_unfair_lock_unlock(v458);
                            v1094 = (std::__shared_weak_count *)v1278.__r_.__value_.__l.__size_;
                            v1278.__r_.__value_.__r.__words[0] = v1091;
                            v1278.__r_.__value_.__l.__size_ = v1090;
                            if (v1094)
                            {
                              v1095 = (unint64_t *)&v1094->__shared_owners_;
                              do
                                v1096 = __ldaxr(v1095);
                              while (__stlxr(v1096 - 1, v1095));
                              if (!v1096)
                              {
                                ((void (*)(std::__shared_weak_count *))v1094->__on_zero_shared)(v1094);
                                std::__shared_weak_count::__release_weak(v1094);
                              }
                            }
                            if (v1087)
                            {
                              v1097 = (unint64_t *)&v1087->__shared_owners_;
                              do
                                v1098 = __ldaxr(v1097);
                              while (__stlxr(v1098 - 1, v1097));
                              if (!v1098)
                              {
                                ((void (*)(std::__shared_weak_count *))v1087->__on_zero_shared)(v1087);
                                std::__shared_weak_count::__release_weak(v1087);
                              }
                            }
                            if (*(_BYTE *)(v508 + 208))
                              (*(void (**)(std::string::size_type))(*(_QWORD *)v1278.__r_.__value_.__l.__data_
                                                                             + 120))(v1278.__r_.__value_.__r.__words[0]);
                            v1099 = *__error();
                            v1100 = _SILogForLogForCategory(16);
                            if (os_log_type_enabled(v1100, OS_LOG_TYPE_DEFAULT))
                            {
                              v1101 = v1278.__r_.__value_.__r.__words[0];
                              (*(void (**)(std::string *__return_ptr, std::string::size_type))(*(_QWORD *)v1278.__r_.__value_.__l.__data_ + 144))(&v1289, v1278.__r_.__value_.__r.__words[0]);
                              if ((v1289.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                                v1102 = &v1289;
                              else
                                v1102 = (std::string *)v1289.__r_.__value_.__r.__words[0];
                              v1105 = v1101 + 72;
                              v1103 = *(_DWORD *)(v1101 + 72);
                              v1104 = *(_DWORD *)(v1105 + 4);
                              v1106 = v1273 + 8;
                              if (v1273[31] < 0)
                                v1106 = (_QWORD *)*v1106;
                              v1107 = (*(uint64_t (**)(void))(*(_QWORD *)v1273 + 16))();
                              v1108 = *(_DWORD *)(*(_QWORD *)(v508 + 96) + 40);
                              *(_DWORD *)v1290 = 136316418;
                              *(_QWORD *)&v1290[4] = v1102;
                              *(_WORD *)&v1290[12] = 1024;
                              *(_DWORD *)&v1290[14] = v1104;
                              v1291 = 1024;
                              v1292 = v1103;
                              v1293 = 2080;
                              v1294 = v1106;
                              v1295 = 1024;
                              v1296 = v1107;
                              v1297 = 1024;
                              v1298 = v1108;
                              _os_log_impl(&dword_1B8270000, v1100, OS_LOG_TYPE_DEFAULT, "Partitions rebuilt %s version: %d count: %u not match Quantizer %s version %d vectors count:%u.", v1290, 0x2Eu);
                              if (SHIBYTE(v1289.__r_.__value_.__r.__words[2]) < 0)
                                operator delete(v1289.__r_.__value_.__l.__data_);
                            }
                            *__error() = v1099;
LABEL_1764:
                            v1109 = v1274;
                            if (v1274)
                            {
                              v1110 = (unint64_t *)&v1274->__shared_owners_;
                              do
                                v1111 = __ldaxr(v1110);
                              while (__stlxr(v1111 - 1, v1110));
                              if (!v1111)
                              {
                                ((void (*)(std::__shared_weak_count *))v1109->__on_zero_shared)(v1109);
                                std::__shared_weak_count::__release_weak(v1109);
                              }
                            }
                            v537 = (std::__shared_weak_count *)v1278.__r_.__value_.__l.__size_;
                            if (v1278.__r_.__value_.__l.__size_)
                            {
                              v1112 = (unint64_t *)(v1278.__r_.__value_.__l.__size_ + 8);
                              do
                                v539 = __ldaxr(v1112);
                              while (__stlxr(v539 - 1, v1112));
                              goto LABEL_1772;
                            }
                            return v508;
                          }
                          if (v720)
                            goto LABEL_1417;
                        }
                        bzero(v1290, 0x400uLL);
                        memset(&__dst, 0, sizeof(__dst));
                        v893 = fd_name(v692, v1290, 0x400uLL);
                        v894 = strlen(v893);
                        if (v894 > 0x7FFFFFFFFFFFFFF7)
                          goto LABEL_1881;
                        v895 = v894;
                        if (v894 >= 0x17)
                        {
                          v1077 = (v894 & 0xFFFFFFFFFFFFFFF8) + 8;
                          if ((v894 | 7) != 0x17)
                            v1077 = v894 | 7;
                          v1078 = v1077 + 1;
                          v896 = (std::string *)operator new(v1077 + 1);
                          __dst.__r_.__value_.__l.__size_ = v895;
                          __dst.__r_.__value_.__r.__words[2] = v1078 | 0x8000000000000000;
                          __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v896;
                        }
                        else
                        {
                          *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v894;
                          v896 = &__dst;
                          if (!v894)
                            goto LABEL_1722;
                        }
                        memmove(v896, v893, v895);
LABEL_1722:
                        v896->__r_.__value_.__s.__data_[v895] = 0;
                        std::string::append(&__dst, ".partitions");
                        v1079 = *__error();
                        v1080 = _SILogForLogForCategory(16);
                        v1081 = dword_1EF19FCCC < 3;
                        if (os_log_type_enabled(v1080, (os_log_type_t)(dword_1EF19FCCC < 3)))
                        {
                          if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                            v1082 = &__dst;
                          else
                            v1082 = (std::string *)__dst.__r_.__value_.__r.__words[0];
                          LODWORD(v1289.__r_.__value_.__l.__data_) = 136315138;
                          *(std::string::size_type *)((char *)v1289.__r_.__value_.__r.__words + 4) = (std::string::size_type)v1082;
                          _os_log_impl(&dword_1B8270000, v1080, v1081, "*warn* Rebuild! Partitions %s currupted", (uint8_t *)&v1289, 0xCu);
                        }
                        *__error() = v1079;
                        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
                          operator delete(__dst.__r_.__value_.__l.__data_);
                        goto LABEL_1729;
                      }
                    }
LABEL_1132:
                    v495 = 0;
                    goto LABEL_1133;
                  }
                  if (!memcmp((const void *)v493[2], v485, v493[3]))
                    goto LABEL_1128;
                }
              }
              else
              {
                if (v496 >= v488)
                  v496 %= v488;
                if (v496 != v491)
                  goto LABEL_1132;
              }
LABEL_776:
              v495 = 0;
              v493 = (uint64_t *)*v493;
              if (!v493)
                goto LABEL_1133;
            }
          }
LABEL_767:
          operator delete(v1289.__r_.__value_.__l.__data_);
          if ((v1275[23] & 0x80000000) == 0)
            goto LABEL_754;
          goto LABEL_768;
        }
      }
      memcpy(v465, v462, v464);
      goto LABEL_723;
    }
    v32 = operator new();
    v33 = *(_QWORD *)a5;
    v1282 = *(_QWORD *)(a5 + 8);
    v1283 = *(_DWORD *)(a5 + 16);
    v34 = *(_BYTE *)(a5 + 20);
    v1241 = *(unsigned __int8 *)(a5 + 21);
    v1280 = *(_QWORD *)(a5 + 22);
    v1281 = *(_WORD *)(a5 + 30);
    v1199 = *a6;
    v1223 = v34;
    __vald = *((_DWORD *)a6 + 4);
    v1211 = *((_QWORD *)a6 + 3);
    *(_QWORD *)v32 = off_1E6E30C80;
    *(_DWORD *)(v32 + 8) = a1;
    *(_QWORD *)(v32 + 12) = 0x400000300;
    *(_WORD *)(v32 + 20) = a2;
    *(_BYTE *)(v32 + 22) = a7;
    IVFIndexName(v32 + 24, a1, a2, 2, 0);
    *(_QWORD *)v32 = off_1E6E34708;
    v35 = *(_DWORD *)(v32 + 12);
    if (v35 == 256)
    {
      v1193 = 0;
    }
    else
    {
      if (v35 == 768)
      {
        v36 = 2;
      }
      else if (v35 == 512)
      {
        v36 = 1;
      }
      else
      {
        v36 = 3;
      }
      v1193 = v36;
    }
    v350 = *(_DWORD *)(v32 + 16);
    v351 = *(unsigned __int16 *)(v32 + 20);
    v352 = *(unsigned __int8 *)(v32 + 22);
    v1266 = v32;
    *(_QWORD *)(v32 + 48) = &off_1E6E34860;
    *(_QWORD *)(v32 + 56) = v33;
    v353 = (_DWORD *)(v32 + 48);
    if (v350 == 2)
      v354 = 1;
    else
      v354 = 3;
    if (v350 == 4)
      v355 = 0;
    else
      v355 = v354;
    v1187 = v355;
    if (v352)
      v351 |= 0x80000000;
    v1181 = v351;
    *(_QWORD *)(v32 + 64) = v1282;
    *(_DWORD *)(v32 + 72) = v1283;
    *(_BYTE *)(v32 + 76) = v1223;
    *(_BYTE *)(v32 + 77) = v1241;
    *(_QWORD *)(v32 + 78) = v1280;
    *(_WORD *)(v32 + 86) = v1281;
    *(_DWORD *)(v32 + 88) = a1;
    *(_WORD *)(v32 + 92) = a2;
    v356 = operator new(0x68uLL);
    v356[1] = 0;
    v356[2] = 0;
    *v356 = &off_1E6E348A8;
    v356[3] = v33;
    *(_QWORD *)&buf[8] = *(_QWORD *)(v32 + 64);
    v357 = *(_QWORD *)&buf[8];
    *(_QWORD *)&buf[13] = *(_QWORD *)(v32 + 69);
    v358 = *(_QWORD *)&buf[13];
    v359 = v1280;
    *(_WORD *)&buf[22] = v1280;
    v360 = *(_DWORD *)(v32 + 80);
    v361 = v353[9];
    v356[4] = v357;
    *(_QWORD *)((char *)v356 + 37) = v358;
    *((_BYTE *)v356 + 45) = v1241;
    *((_WORD *)v356 + 23) = v359;
    *((_DWORD *)v356 + 12) = v360;
    *((_DWORD *)v356 + 13) = v361;
    v356[7] = 0;
    *((_DWORD *)v356 + 16) = 0;
    v356[11] = 0;
    v356[12] = 0;
    v356[10] = 0;
    bzero(v1290, 0x400uLL);
    v362 = fd_name(v33, v1290, 0x400uLL);
    MEMORY[0x1BCCB03B0](v356 + 10, v362);
    v363 = operator new();
    v1217 = v33;
    *(_QWORD *)buf = v33;
    buf[21] = v1241;
    *(_DWORD *)&buf[24] = v360;
    *(_DWORD *)&buf[28] = v361;
    v364 = vi_onefixedsize_disk_allocator::vi_onefixedsize_disk_allocator(v363, 20, 3088, (__int128 *)buf, (uint64_t)(v353 + 30));
    v365 = v356[7];
    v356[7] = v364;
    if (v365)
    {
      storage_array_Close(v365 + 8);
      v366 = *(const void **)(v365 + 4208);
      if (v366)
      {
        CFRelease(v366);
        *(_QWORD *)(v365 + 4208) = 0;
      }
      *(_OWORD *)(v365 + 4192) = 0u;
      MEMORY[0x1BCCB06A4](v365, 0x10A0C408BE2A288);
      v364 = v356[7];
    }
    v367 = _windowsResolvePtr(v364 + 40, 0x400uLL, *(_QWORD *)(v364 + 16));
    v368 = v367;
    if (v1241)
    {
      *(_QWORD *)v367 = 0x1015F1DA6;
      *(_DWORD *)(v367 + 8) = v360;
      v369 = 0xFFFFFFFFLL;
      *(_QWORD *)(v367 + 12) = 0xFFFFFFFFLL;
      LODWORD(v370) = *((_DWORD *)v356 + 16);
    }
    else
    {
      if (*(_DWORD *)v367 != 23010726)
        goto LABEL_1859;
      if (*(_DWORD *)(v367 + 4) != 1)
        goto LABEL_1862;
      v371 = (_QWORD *)v356[7];
      v372 = *__error();
      v373 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v373, OS_LOG_TYPE_DEFAULT))
      {
        v374 = v371[6];
        v375 = v371[7];
        v377 = v371[2];
        v376 = v371[3];
        *(_DWORD *)buf = 134219008;
        *(_QWORD *)&buf[4] = v371;
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = v374;
        *(_WORD *)&buf[22] = 2048;
        *(_QWORD *)&buf[24] = v375;
        v1285 = 2048;
        v1286 = v376;
        v1287 = 2048;
        v1288 = v377;
        _os_log_impl(&dword_1B8270000, v373, OS_LOG_TYPE_DEFAULT, "vi_onefixedsize_disk_allocator %p size: %llu, freeRegion: %llu, header: %llu, elemSize: %lu", buf, 0x34u);
      }
      *__error() = v372;
      v378 = (_QWORD *)v356[7];
      v379 = v378[2];
      v380 = v378[7] - v378[3];
      v370 = v380 / v379;
      if (v380 != v380 / v379 * v379)
        goto LABEL_1869;
      *((_DWORD *)v356 + 16) = v370;
      if (v378[3] != 1044)
        goto LABEL_1872;
      if (v378[2] != 3088)
        goto LABEL_1875;
      v369 = *(_QWORD *)(v368 + 12);
    }
    *(_DWORD *)(v1266 + 160) = 0;
    v381 = (os_unfair_lock_s *)(v1266 + 160);
    *(_QWORD *)((char *)v356 + 68) = v369;
    *(_OWORD *)(v1266 + 112) = 0u;
    *(_QWORD *)(v1266 + 96) = v356 + 3;
    *(_QWORD *)(v1266 + 104) = v356;
    *(_OWORD *)(v1266 + 128) = 0u;
    *(_OWORD *)(v1266 + 144) = 0u;
    *(_WORD *)(v1266 + 168) = v1199;
    *(_WORD *)(v1266 + 170) = v1268;
    *(_DWORD *)(v1266 + 172) = v1193;
    *(_DWORD *)(v1266 + 176) = v1187;
    *(_DWORD *)(v1266 + 180) = v1181;
    *(_DWORD *)(v1266 + 184) = __vald;
    *(_QWORD *)(v1266 + 192) = v1211;
    *(_QWORD *)(v1266 + 200) = 0xFFFFFFFF00000000;
    *(_BYTE *)(v1266 + 208) = v1223;
    *(_DWORD *)(v1266 + 212) = 0;
    *(_DWORD *)(v1266 + 216) = 0;
    if ((_DWORD)v370)
    {
      *(_DWORD *)(v1266 + 212) = *(_DWORD *)(_windowsResolvePtr(v356[7] + 40, *(_QWORD *)(v356[7] + 24), 0xC10uLL)
                                           + 3080);
      *(_DWORD *)(v1266 + 216) = *(_DWORD *)(_windowsResolvePtr(*(_QWORD *)(*(_QWORD *)(v1266 + 96) + 32) + 40, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v1266 + 96) + 32) + 24)+ *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v1266 + 96) + 32) + 16)* (*(_DWORD *)(*(_QWORD *)(v1266 + 96) + 40) - 1), 0xC10uLL)+ 3080);
    }
    if (v33)
      v382 = *(_DWORD *)(v33 + 44);
    else
      v382 = -1;
    __valj = *(_DWORD *)(v1266 + 88);
    bzero(v1290, 0x400uLL);
    v383 = fcntl(v382, 50, v1290);
    if (v1290[0])
      v384 = v383 < 0;
    else
      v384 = 1;
    if (v384)
      v385 = 0;
    else
      v385 = v1290;
    v386 = strlen(v385);
    if (v386 > 0x7FFFFFFFFFFFFFF7)
      goto LABEL_1881;
    v387 = v386;
    memset(&__dst, 0, sizeof(__dst));
    v1205 = v382;
    if (v386 >= 0x17)
    {
      v389 = (v386 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v386 | 7) != 0x17)
        v389 = v386 | 7;
      v390 = v389 + 1;
      v388 = (std::string *)operator new(v389 + 1);
      __dst.__r_.__value_.__l.__size_ = v387;
      __dst.__r_.__value_.__r.__words[2] = v390 | 0x8000000000000000;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v388;
    }
    else
    {
      *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v386;
      v388 = &__dst;
      if (!v386)
      {
LABEL_594:
        v388->__r_.__value_.__s.__data_[v387] = 0;
        v391 = SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
        if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v392 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
        else
          v392 = __dst.__r_.__value_.__l.__size_;
        v393 = v392 + 1;
        if (v392 + 1 > 0x7FFFFFFFFFFFFFF7)
          goto LABEL_1881;
        if (v393 >= 0x17)
        {
          v395 = (v393 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v393 | 7) != 0x17)
            v395 = v393 | 7;
          v396 = v395 + 1;
          v394 = operator new(v395 + 1);
          *(_QWORD *)&v1275[8] = v392 + 1;
          *(_QWORD *)&v1275[16] = v396 | 0x8000000000000000;
          *(_QWORD *)v1275 = v394;
        }
        else
        {
          memset(v1275, 0, 24);
          v394 = v1275;
          v1275[23] = v392 + 1;
          if (!v392)
            goto LABEL_608;
        }
        if (v391 >= 0)
          v397 = &__dst;
        else
          v397 = (std::string *)__dst.__r_.__value_.__r.__words[0];
        memmove(v394, v397, v392);
LABEL_608:
        *(_WORD *)&v394[v392] = 47;
        std::to_string(&v1289, __valj);
        if ((v1289.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v398 = &v1289;
        else
          v398 = (std::string *)v1289.__r_.__value_.__r.__words[0];
        if ((v1289.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v399 = HIBYTE(v1289.__r_.__value_.__r.__words[2]);
        else
          v399 = v1289.__r_.__value_.__l.__size_;
        v400 = std::string::append((std::string *)v1275, (const std::string::value_type *)v398, v399);
        v401 = v400->__r_.__value_.__r.__words[2];
        *(_OWORD *)v1276 = *(_OWORD *)&v400->__r_.__value_.__l.__data_;
        *(_QWORD *)&v1276[16] = v401;
        v400->__r_.__value_.__l.__size_ = 0;
        v400->__r_.__value_.__r.__words[2] = 0;
        v400->__r_.__value_.__r.__words[0] = 0;
        v402 = std::string::append((std::string *)v1276, "-");
        v403 = v402->__r_.__value_.__r.__words[2];
        *(_OWORD *)buf = *(_OWORD *)&v402->__r_.__value_.__l.__data_;
        *(_QWORD *)&buf[16] = v403;
        v402->__r_.__value_.__l.__size_ = 0;
        v402->__r_.__value_.__r.__words[2] = 0;
        v402->__r_.__value_.__r.__words[0] = 0;
        std::to_string(&v1278, v1249);
        if ((v1278.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v404 = &v1278;
        else
          v404 = (std::string *)v1278.__r_.__value_.__r.__words[0];
        if ((v1278.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v405 = HIBYTE(v1278.__r_.__value_.__r.__words[2]);
        else
          v405 = v1278.__r_.__value_.__l.__size_;
        v406 = std::string::append((std::string *)buf, (const std::string::value_type *)v404, v405);
        v1279 = *v406;
        v406->__r_.__value_.__r.__words[0] = 0;
        v406->__r_.__value_.__l.__size_ = 0;
        v406->__r_.__value_.__r.__words[2] = 0;
        if (SHIBYTE(v1278.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v1278.__r_.__value_.__l.__data_);
          if ((buf[23] & 0x80000000) == 0)
          {
LABEL_622:
            if ((v1276[23] & 0x80000000) == 0)
              goto LABEL_623;
            goto LABEL_637;
          }
        }
        else if ((buf[23] & 0x80000000) == 0)
        {
          goto LABEL_622;
        }
        operator delete(*(void **)buf);
        if ((v1276[23] & 0x80000000) == 0)
        {
LABEL_623:
          if ((SHIBYTE(v1289.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            goto LABEL_624;
          goto LABEL_638;
        }
LABEL_637:
        operator delete(*(void **)v1276);
        if ((SHIBYTE(v1289.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_624:
          if ((v1275[23] & 0x80000000) == 0)
            goto LABEL_625;
LABEL_639:
          operator delete(*(void **)v1275);
LABEL_625:
          if ((v407 & 1) == 0
          {
            QuantizerManager<float,768>::sharedInstance(int,unsigned int,unsigned short)::managers = 0u;
            *(_OWORD *)&qword_1EF1B0780 = 0u;
            dword_1EF1B0790 = 1065353216;
            __cxa_atexit((void (*)(void *))std::unordered_map<std::string,std::weak_ptr<QuantizerManager<float,768>>>::~unordered_map[abi:nn180100], &QuantizerManager<float,768>::sharedInstance(int,unsigned int,unsigned short)::managers, &dword_1B8270000);
          }
          os_unfair_lock_lock((os_unfair_lock_t)&QuantizerManager<float,768>::sharedInstance(int,unsigned int,unsigned short)::lock);
          if ((v1279.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v408 = &v1279;
          else
            v408 = (std::string *)v1279.__r_.__value_.__r.__words[0];
          if ((v1279.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v409 = HIBYTE(v1279.__r_.__value_.__r.__words[2]);
          else
            v409 = v1279.__r_.__value_.__l.__size_;
          v410 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t *)v408, v409);
          v411 = *((_QWORD *)&QuantizerManager<float,768>::sharedInstance(int,unsigned int,unsigned short)::managers + 1);
          if (!*((_QWORD *)&QuantizerManager<float,768>::sharedInstance(int,unsigned int,unsigned short)::managers + 1))
            goto LABEL_1068;
          v412 = v410;
          v413 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&QuantizerManager<float,768>::sharedInstance(int,unsigned int,unsigned short)::managers
                                                + 8));
          v413.i16[0] = vaddlv_u8(v413);
          if (v413.u32[0] > 1uLL)
          {
            v414 = v410;
            if (v410 >= *((_QWORD *)&QuantizerManager<float,768>::sharedInstance(int,unsigned int,unsigned short)::managers
                         + 1))
              v414 = v410
                   % *((_QWORD *)&QuantizerManager<float,768>::sharedInstance(int,unsigned int,unsigned short)::managers
                     + 1);
          }
          else
          {
            v414 = (*((_QWORD *)&QuantizerManager<float,768>::sharedInstance(int,unsigned int,unsigned short)::managers
                    + 1)
                  - 1) & v410;
          }
          v415 = *(uint64_t ***)(QuantizerManager<float,768>::sharedInstance(int,unsigned int,unsigned short)::managers
                              + 8 * v414);
          if (!v415)
            goto LABEL_1068;
          v416 = *v415;
          if (!*v415)
            goto LABEL_1068;
          if (v413.u32[0] < 2uLL)
          {
            v417 = *((_QWORD *)&QuantizerManager<float,768>::sharedInstance(int,unsigned int,unsigned short)::managers
                   + 1)
                 - 1;
            while (1)
            {
              v423 = v416[1];
              if (v423 == v412)
              {
                v424 = *((unsigned __int8 *)v416 + 39);
                if ((v424 & 0x80u) == 0)
                  v425 = *((unsigned __int8 *)v416 + 39);
                else
                  v425 = v416[3];
                if (v425 == v409)
                {
                  if ((v424 & 0x80) != 0)
                  {
                    if (!memcmp((const void *)v416[2], v408, v416[3]))
                      goto LABEL_1064;
                  }
                  else
                  {
                    if (!*((_BYTE *)v416 + 39))
                      goto LABEL_1064;
                    v426 = 0;
                    while (*((unsigned __int8 *)v416 + v426 + 16) == v408->__r_.__value_.__s.__data_[v426])
                    {
                      if (v424 == ++v426)
                        goto LABEL_1063;
                    }
                  }
                }
              }
              else if ((v423 & v417) != v414)
              {
                goto LABEL_1068;
              }
              v418 = 0;
              v416 = (uint64_t *)*v416;
              if (!v416)
                goto LABEL_1069;
            }
          }
          while (1)
          {
            v419 = v416[1];
            if (v419 == v412)
            {
              v420 = *((unsigned __int8 *)v416 + 39);
              if ((v420 & 0x80u) == 0)
                v421 = *((unsigned __int8 *)v416 + 39);
              else
                v421 = v416[3];
              if (v421 == v409)
              {
                if ((v420 & 0x80) == 0)
                {
                  if (!*((_BYTE *)v416 + 39))
                    goto LABEL_1064;
                  v422 = 0;
                  do
                  {
                    if (*((unsigned __int8 *)v416 + v422 + 16) != v408->__r_.__value_.__s.__data_[v422])
                      goto LABEL_647;
                    ++v422;
                  }
                  while (v420 != v422);
LABEL_1063:
                  if (v416)
                  {
LABEL_1064:
                    v651 = std::__hash_table<std::__hash_value_type<std::string,std::weak_ptr<QuantizerManager<float,768>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::weak_ptr<QuantizerManager<float,768>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::weak_ptr<QuantizerManager<float,768>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::weak_ptr<QuantizerManager<float,768>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)&v1279, (uint64_t)&v1279);
                    v652 = (std::__shared_weak_count *)*((_QWORD *)v651 + 6);
                    if (v652)
                    {
                      v653 = std::__shared_weak_count::lock(v652);
                      v418 = v653;
                      if (v653 && *((_QWORD *)v651 + 5))
                      {
                        *(_QWORD *)&v654 = *((_QWORD *)v651 + 5);
                        *((_QWORD *)&v654 + 1) = v653;
                        v1254 = v654;
                        v508 = v1266;
                        v655 = (uint64_t *)(v1266 + 112);
                        v656 = v1217;
                        goto LABEL_1109;
                      }
LABEL_1069:
                      v657 = operator new();
                      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
                        std::string::__init_copy_ctor_external(&v1289, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
                      else
                        v1289 = __dst;
                      *(_DWORD *)v657 = v1205;
                      *(_DWORD *)(v657 + 4) = __valj;
                      *(_WORD *)(v657 + 8) = v1249;
                      v658 = (std::string *)(v657 + 24);
                      if (SHIBYTE(v1289.__r_.__value_.__r.__words[2]) < 0)
                      {
                        std::string::__init_copy_ctor_external(v658, v1289.__r_.__value_.__l.__data_, v1289.__r_.__value_.__l.__size_);
                      }
                      else
                      {
                        *(_OWORD *)&v658->__r_.__value_.__l.__data_ = *(_OWORD *)&v1289.__r_.__value_.__l.__data_;
                        *(_QWORD *)(v657 + 40) = *((_QWORD *)&v1289.__r_.__value_.__l + 2);
                      }
                      IVFIndexName(v657 + 48, __valj, v1249, 2, 0);
                      *(_OWORD *)(v657 + 112) = 0u;
                      *(_OWORD *)(v657 + 128) = 0u;
                      *(_OWORD *)(v657 + 80) = 0u;
                      *(_OWORD *)(v657 + 96) = 0u;
                      *(_DWORD *)(v657 + 144) = 1065353216;
                      v659 = *__error();
                      v660 = _SILogForLogForCategory(16);
                      if (os_log_type_enabled(v660, OS_LOG_TYPE_DEFAULT))
                      {
                        v661 = &v1289;
                        if ((v1289.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
                          v661 = (std::string *)v1289.__r_.__value_.__r.__words[0];
                        if (*(char *)(v657 + 71) < 0)
                          v662 = *(_QWORD *)(v657 + 48);
                        else
                          v662 = v657 + 48;
                        *(_DWORD *)buf = 136315394;
                        *(_QWORD *)&buf[4] = v661;
                        *(_WORD *)&buf[12] = 2080;
                        *(_QWORD *)&buf[14] = v662;
                        _os_log_impl(&dword_1B8270000, v660, OS_LOG_TYPE_DEFAULT, "QuantizerManager %s/%s created", buf, 0x16u);
                      }
                      *__error() = v659;
                      v1275[23] = 20;
                      strcpy(v1275, "com.apple.spotlight.");
                      v663 = *(char *)(v657 + 71);
                      if (v663 >= 0)
                        v664 = (const std::string::value_type *)(v657 + 48);
                      else
                        v664 = *(const std::string::value_type **)(v657 + 48);
                      if (v663 >= 0)
                        v665 = *(unsigned __int8 *)(v657 + 71);
                      else
                        v665 = *(_QWORD *)(v657 + 56);
                      v666 = std::string::append((std::string *)v1275, v664, v665);
                      v667 = v666->__r_.__value_.__r.__words[2];
                      *(_OWORD *)v1276 = *(_OWORD *)&v666->__r_.__value_.__l.__data_;
                      *(_QWORD *)&v1276[16] = v667;
                      v666->__r_.__value_.__l.__size_ = 0;
                      v666->__r_.__value_.__r.__words[2] = 0;
                      v666->__r_.__value_.__r.__words[0] = 0;
                      v668 = std::string::append((std::string *)v1276, ".quantizerManager");
                      v669 = v668->__r_.__value_.__r.__words[2];
                      *(_OWORD *)buf = *(_OWORD *)&v668->__r_.__value_.__l.__data_;
                      *(_QWORD *)&buf[16] = v669;
                      v668->__r_.__value_.__l.__size_ = 0;
                      v668->__r_.__value_.__r.__words[2] = 0;
                      v668->__r_.__value_.__r.__words[0] = 0;
                      if ((v1276[23] & 0x80000000) != 0)
                        operator delete(*(void **)v1276);
                      if ((v1275[23] & 0x80000000) != 0)
                        operator delete(*(void **)v1275);
                      if (buf[23] >= 0)
                        v670 = buf;
                      else
                        v670 = *(const char **)buf;
                      *(_QWORD *)(v657 + 16) = dispatch_queue_create(v670, 0);
                      atomic_store(0, (unsigned __int8 *)(v657 + 72));
                      if ((buf[23] & 0x80000000) != 0)
                        operator delete(*(void **)buf);
                      v671 = (_QWORD *)operator new();
                      *v671 = &off_1E6E348E0;
                      v671[1] = 0;
                      v671[2] = 0;
                      v671[3] = v657;
                      if (v418)
                      {
                        v672 = (unint64_t *)&v418->__shared_owners_;
                        do
                          v673 = __ldaxr(v672);
                        while (__stlxr(v673 - 1, v672));
                        if (!v673)
                        {
                          ((void (*)(std::__shared_weak_count *))v418->__on_zero_shared)(v418);
                          std::__shared_weak_count::__release_weak(v418);
                        }
                      }
                      *(_QWORD *)&v674 = v657;
                      if (SHIBYTE(v1289.__r_.__value_.__r.__words[2]) < 0)
                      {
                        operator delete(v1289.__r_.__value_.__l.__data_);
                        *(_QWORD *)&v674 = v657;
                      }
                      *((_QWORD *)&v674 + 1) = v671;
                      v1254 = v674;
                      v675 = v671 + 2;
                      v508 = v1266;
                      v655 = (uint64_t *)(v1266 + 112);
                      do
                        v676 = __ldxr(v675);
                      while (__stxr(v676 + 1, v675));
                      v677 = std::__hash_table<std::__hash_value_type<std::string,std::weak_ptr<QuantizerManager<float,768>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::weak_ptr<QuantizerManager<float,768>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::weak_ptr<QuantizerManager<float,768>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::weak_ptr<QuantizerManager<float,768>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)&v1279, (uint64_t)&v1279);
                      v678 = (std::__shared_weak_count *)*((_QWORD *)v677 + 6);
                      *((_QWORD *)v677 + 5) = v657;
                      *((_QWORD *)v677 + 6) = v671;
                      if (v678)
                        std::__shared_weak_count::__release_weak(v678);
                      v656 = v1217;
LABEL_1109:
                      os_unfair_lock_unlock((os_unfair_lock_t)&QuantizerManager<float,768>::sharedInstance(int,unsigned int,unsigned short)::lock);
                      if (SHIBYTE(v1279.__r_.__value_.__r.__words[2]) < 0)
                        operator delete(v1279.__r_.__value_.__l.__data_);
                      v679 = v1254;
                      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
                      {
                        operator delete(__dst.__r_.__value_.__l.__data_);
                        v679 = v1254;
                      }
                      v680 = *(std::__shared_weak_count **)(v508 + 120);
                      *(_OWORD *)(v508 + 112) = v679;
                      if (v680)
                      {
                        v681 = (unint64_t *)&v680->__shared_owners_;
                        do
                          v682 = __ldaxr(v681);
                        while (__stlxr(v682 - 1, v681));
                        if (!v682)
                        {
                          ((void (*)(std::__shared_weak_count *))v680->__on_zero_shared)(v680);
                          std::__shared_weak_count::__release_weak(v680);
                        }
                      }
                      if (v1241)
                      {
                        QuantizerManager<float,768>::sharedQuantizer(v1290, *v655, 0);
                        IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::replaceQuantizer((uint64_t)v353, (uint64_t *)v1290);
                        v537 = *(std::__shared_weak_count **)&v1290[8];
                        if (*(_QWORD *)&v1290[8])
                        {
                          v683 = (unint64_t *)(*(_QWORD *)&v1290[8] + 8);
                          do
                            v539 = __ldaxr(v683);
                          while (__stlxr(v539 - 1, v683));
                          goto LABEL_1772;
                        }
                        return v508;
                      }
                      memset(buf, 0, sizeof(buf));
                      *(_QWORD *)v1276 = v656;
                      *(_QWORD *)&v1276[8] = v1282;
                      *(_DWORD *)&v1276[16] = v1283;
                      *(_WORD *)&v1276[20] = v1223;
                      *(_QWORD *)&v1276[22] = v1280;
                      v1277 = v1281;
                      *((_BYTE *)&v1279.__r_.__value_.__s + 23) = 11;
                      strcpy((char *)&v1279, ".partitions");
                      IVFVectorIndexTemplate<float,768>::childMetaInfo((uint64_t)buf, (uint64_t)v1276, (uint64_t)&v1279, 0);
                      if (SHIBYTE(v1279.__r_.__value_.__r.__words[2]) < 0)
                        operator delete(v1279.__r_.__value_.__l.__data_);
                      *(_OWORD *)&v1278.__r_.__value_.__l.__data_ = 0uLL;
                      *(_OWORD *)v1275 = *(_OWORD *)buf;
                      *(_OWORD *)&v1275[16] = *(_OWORD *)&buf[16];
                      PartitionStore<vi_onefixedsize_disk_allocator,512>::openPartitionStore<vi_onefixedsize_disk_allocator>((std::__shared_weak_count **)&v1278, (uint64_t)v1275);
                      v684 = (_DWORD *)v1278.__r_.__value_.__r.__words[0];
                      if (v1278.__r_.__value_.__r.__words[0])
                      {
                        v685 = *(_DWORD *)(v1278.__r_.__value_.__r.__words[0] + 76);
                        v686 = v1278.__r_.__value_.__r.__words[0];
                      }
                      else
                      {
                        v686 = 0;
                        v685 = 0;
                      }
                      v1273 = 0;
                      v1274 = 0;
                      QuantizerManager<float,768>::sharedQuantizer(&v1273, *v655, v685);
                      if (v686)
                      {
                        v759 = *(_DWORD *)(v686 + 76);
                        v760 = v1273;
                        if (v759 == (*(unsigned int (**)(char *))(*(_QWORD *)v1273 + 16))(v1273))
                        {
                          if (v684[18] == *(_DWORD *)(*(_QWORD *)(v508 + 96) + 40))
                          {
                            v761 = v1274;
                            if (v1274)
                            {
                              v762 = (unint64_t *)&v1274->__shared_owners_;
                              do
                                v763 = __ldxr(v762);
                              while (__stxr(v763 + 1, v762));
                              AnyPartitionStore::replaceQuantizer((uint64_t)v684, (uint64_t)v760, (uint64_t)v761);
                              v764 = (unint64_t *)&v761->__shared_owners_;
                              do
                                v765 = __ldaxr(v764);
                              while (__stlxr(v765 - 1, v764));
                              if (!v765)
                              {
                                ((void (*)(std::__shared_weak_count *))v761->__on_zero_shared)(v761);
                                std::__shared_weak_count::__release_weak(v761);
                              }
                              *(_QWORD *)v1290 = v1273;
                              *(_QWORD *)&v1290[8] = v1274;
                              if (v1274)
                              {
                                v766 = (unint64_t *)&v1274->__shared_owners_;
                                do
                                  v767 = __ldxr(v766);
                                while (__stxr(v767 + 1, v766));
                              }
                            }
                            else
                            {
                              AnyPartitionStore::replaceQuantizer((uint64_t)v684, (uint64_t)v760, 0);
                              *(_QWORD *)v1290 = v1273;
                              *(_QWORD *)&v1290[8] = 0;
                            }
                            *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = *(_OWORD *)&v1278.__r_.__value_.__l.__data_;
                            if (v1278.__r_.__value_.__l.__size_)
                            {
                              v1146 = (unint64_t *)(v1278.__r_.__value_.__l.__size_ + 8);
                              do
                                v1147 = __ldxr(v1146);
                              while (__stxr(v1147 + 1, v1146));
                            }
                            (*(void (**)(_DWORD *, _BYTE *, std::string *))(*(_QWORD *)v353 + 48))(v353, v1290, &__dst);
                            v1148 = (std::__shared_weak_count *)__dst.__r_.__value_.__l.__size_;
                            if (__dst.__r_.__value_.__l.__size_)
                            {
                              v1149 = (unint64_t *)(__dst.__r_.__value_.__l.__size_ + 8);
                              do
                                v1150 = __ldaxr(v1149);
                              while (__stlxr(v1150 - 1, v1149));
                              if (!v1150)
                              {
                                ((void (*)(std::__shared_weak_count *))v1148->__on_zero_shared)(v1148);
                                std::__shared_weak_count::__release_weak(v1148);
                              }
                            }
                            v1151 = *(std::__shared_weak_count **)&v1290[8];
                            if (*(_QWORD *)&v1290[8])
                            {
                              v1152 = (unint64_t *)(*(_QWORD *)&v1290[8] + 8);
                              do
                                v1153 = __ldaxr(v1152);
                              while (__stlxr(v1153 - 1, v1152));
                              if (!v1153)
                              {
                                ((void (*)(std::__shared_weak_count *))v1151->__on_zero_shared)(v1151);
                                std::__shared_weak_count::__release_weak(v1151);
                              }
                            }
                            goto LABEL_1709;
                          }
LABEL_1390:
                          v857 = *__error();
                          v858 = _SILogForLogForCategory(16);
                          v859 = dword_1EF19FCCC < 3;
                          if (os_log_type_enabled(v858, (os_log_type_t)(dword_1EF19FCCC < 3)))
                          {
                            v1260 = v857;
                            (*(void (**)(std::string *__return_ptr, _DWORD *))(*(_QWORD *)v684 + 144))(&__dst, v684);
                            if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                              v860 = &__dst;
                            else
                              v860 = (std::string *)__dst.__r_.__value_.__r.__words[0];
                            v861 = v684[19];
                            v1247 = v684[18];
                            v862 = v760 + 8;
                            if (v760[31] < 0)
                              v862 = (_QWORD *)*v862;
                            v863 = (*(uint64_t (**)(char *))(*(_QWORD *)v760 + 16))(v760);
                            v864 = *(_DWORD *)(*(_QWORD *)(v1266 + 96) + 40);
                            *(_DWORD *)v1290 = 136316418;
                            *(_QWORD *)&v1290[4] = v860;
                            *(_WORD *)&v1290[12] = 1024;
                            *(_DWORD *)&v1290[14] = v861;
                            v1291 = 1024;
                            v1292 = v1247;
                            v1293 = 2080;
                            v1294 = v862;
                            v1295 = 1024;
                            v1296 = v863;
                            v1297 = 1024;
                            v1298 = v864;
                            _os_log_impl(&dword_1B8270000, v858, v859, "*warn* Rebuild! Partitions %s version: %d count: %u not match Quantizer %s version %d vectors count:%u.", v1290, 0x2Eu);
                            if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
                              operator delete(__dst.__r_.__value_.__l.__data_);
                            v508 = v1266;
                            v857 = v1260;
                          }
                          *__error() = v857;
                          *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = 0uLL;
                          __dst.__r_.__value_.__r.__words[2] = (std::string::size_type)v684;
                          v1272 = v1278.__r_.__value_.__l.__size_;
                          if (v1278.__r_.__value_.__l.__size_)
                          {
                            v865 = (unint64_t *)(v1278.__r_.__value_.__l.__size_ + 8);
                            do
                              v866 = __ldxr(v865);
                            while (__stxr(v866 + 1, v865));
                          }
                          os_unfair_lock_lock(v381);
                          std::swap[abi:nn180100]<IVFVectorIndexTemplate<float,768>::QuantizerPartitions>((__int128 *)(v1266 + 128), (__int128 *)&__dst);
                          os_unfair_lock_unlock(v381);
                          v867 = (std::__shared_weak_count *)v1272;
                          if (v1272)
                          {
                            v868 = (unint64_t *)(v1272 + 8);
                            do
                              v869 = __ldaxr(v868);
                            while (__stlxr(v869 - 1, v868));
                            if (!v869)
                            {
                              ((void (*)(std::__shared_weak_count *))v867->__on_zero_shared)(v867);
                              std::__shared_weak_count::__release_weak(v867);
                            }
                          }
                          v870 = (std::__shared_weak_count *)__dst.__r_.__value_.__l.__size_;
                          if (__dst.__r_.__value_.__l.__size_)
                          {
                            v871 = (unint64_t *)(__dst.__r_.__value_.__l.__size_ + 8);
                            do
                              v872 = __ldaxr(v871);
                            while (__stlxr(v872 - 1, v871));
                            if (!v872)
                            {
                              ((void (*)(std::__shared_weak_count *))v870->__on_zero_shared)(v870);
                              std::__shared_weak_count::__release_weak(v870);
                            }
                          }
LABEL_1674:
                          v1047 = v1274;
                          v1269 = v1273;
                          v1270 = v1274;
                          if (v1274)
                          {
                            v1048 = (unint64_t *)&v1274->__shared_owners_;
                            do
                              v1049 = __ldxr(v1048);
                            while (__stxr(v1049 + 1, v1048));
                            IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::replaceQuantizer((uint64_t)v353, (uint64_t *)&v1269);
                            do
                              v1050 = __ldaxr(v1048);
                            while (__stlxr(v1050 - 1, v1048));
                            if (!v1050)
                            {
                              ((void (*)(std::__shared_weak_count *))v1047->__on_zero_shared)(v1047);
                              std::__shared_weak_count::__release_weak(v1047);
                            }
                          }
                          else
                          {
                            IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::replaceQuantizer((uint64_t)v353, (uint64_t *)&v1269);
                          }
                          os_unfair_lock_lock(v381);
                          v1051 = *(std::__shared_weak_count **)(v508 + 136);
                          if (v1051)
                          {
                            v1052 = (unint64_t *)&v1051->__shared_owners_;
                            do
                              v1053 = __ldxr(v1052);
                            while (__stxr(v1053 + 1, v1052));
                          }
                          v1055 = *(_QWORD *)(v508 + 144);
                          v1054 = *(_QWORD *)(v508 + 152);
                          if (v1054)
                          {
                            v1056 = (unint64_t *)(v1054 + 8);
                            do
                              v1057 = __ldxr(v1056);
                            while (__stxr(v1057 + 1, v1056));
                          }
                          os_unfair_lock_unlock(v381);
                          v1058 = (std::__shared_weak_count *)v1278.__r_.__value_.__l.__size_;
                          v1278.__r_.__value_.__r.__words[0] = v1055;
                          v1278.__r_.__value_.__l.__size_ = v1054;
                          if (v1058)
                          {
                            v1059 = (unint64_t *)&v1058->__shared_owners_;
                            do
                              v1060 = __ldaxr(v1059);
                            while (__stlxr(v1060 - 1, v1059));
                            if (!v1060)
                            {
                              ((void (*)(std::__shared_weak_count *))v1058->__on_zero_shared)(v1058);
                              std::__shared_weak_count::__release_weak(v1058);
                            }
                          }
                          if (v1051)
                          {
                            v1061 = (unint64_t *)&v1051->__shared_owners_;
                            do
                              v1062 = __ldaxr(v1061);
                            while (__stlxr(v1062 - 1, v1061));
                            if (!v1062)
                            {
                              ((void (*)(std::__shared_weak_count *))v1051->__on_zero_shared)(v1051);
                              std::__shared_weak_count::__release_weak(v1051);
                            }
                          }
                          if (*(_BYTE *)(v508 + 208))
                            (*(void (**)(std::string::size_type))(*(_QWORD *)v1278.__r_.__value_.__l.__data_
                                                                           + 120))(v1278.__r_.__value_.__r.__words[0]);
                          v1063 = *__error();
                          v1064 = _SILogForLogForCategory(16);
                          if (os_log_type_enabled(v1064, OS_LOG_TYPE_DEFAULT))
                          {
                            v1065 = v1278.__r_.__value_.__r.__words[0];
                            (*(void (**)(std::string *__return_ptr, std::string::size_type))(*(_QWORD *)v1278.__r_.__value_.__l.__data_ + 144))(&v1289, v1278.__r_.__value_.__r.__words[0]);
                            if ((v1289.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                              v1066 = &v1289;
                            else
                              v1066 = (std::string *)v1289.__r_.__value_.__r.__words[0];
                            v1069 = v1065 + 72;
                            v1067 = *(_DWORD *)(v1065 + 72);
                            v1068 = *(_DWORD *)(v1069 + 4);
                            v1070 = v1273 + 8;
                            if (v1273[31] < 0)
                              v1070 = (_QWORD *)*v1070;
                            v1071 = (*(uint64_t (**)(void))(*(_QWORD *)v1273 + 16))();
                            v1072 = *(_DWORD *)(*(_QWORD *)(v508 + 96) + 40);
                            *(_DWORD *)v1290 = 136316418;
                            *(_QWORD *)&v1290[4] = v1066;
                            *(_WORD *)&v1290[12] = 1024;
                            *(_DWORD *)&v1290[14] = v1068;
                            v1291 = 1024;
                            v1292 = v1067;
                            v1293 = 2080;
                            v1294 = v1070;
                            v1295 = 1024;
                            v1296 = v1071;
                            v1297 = 1024;
                            v1298 = v1072;
                            _os_log_impl(&dword_1B8270000, v1064, OS_LOG_TYPE_DEFAULT, "Partitions rebuilt %s version: %d count: %u not match Quantizer %s version %d vectors count:%u.", v1290, 0x2Eu);
                            if (SHIBYTE(v1289.__r_.__value_.__r.__words[2]) < 0)
                              operator delete(v1289.__r_.__value_.__l.__data_);
                          }
                          *__error() = v1063;
LABEL_1709:
                          v1073 = v1274;
                          if (v1274)
                          {
                            v1074 = (unint64_t *)&v1274->__shared_owners_;
                            do
                              v1075 = __ldaxr(v1074);
                            while (__stlxr(v1075 - 1, v1074));
                            if (!v1075)
                            {
                              ((void (*)(std::__shared_weak_count *))v1073->__on_zero_shared)(v1073);
                              std::__shared_weak_count::__release_weak(v1073);
                            }
                          }
                          v537 = (std::__shared_weak_count *)v1278.__r_.__value_.__l.__size_;
                          if (v1278.__r_.__value_.__l.__size_)
                          {
                            v1076 = (unint64_t *)(v1278.__r_.__value_.__l.__size_ + 8);
                            do
                              v539 = __ldaxr(v1076);
                            while (__stlxr(v539 - 1, v1076));
                            goto LABEL_1772;
                          }
                          return v508;
                        }
                        if (v684)
                          goto LABEL_1390;
                      }
                      bzero(v1290, 0x400uLL);
                      memset(&__dst, 0, sizeof(__dst));
                      v873 = fd_name(v656, v1290, 0x400uLL);
                      v874 = strlen(v873);
                      if (v874 > 0x7FFFFFFFFFFFFFF7)
                        goto LABEL_1881;
                      v875 = v874;
                      if (v874 >= 0x17)
                      {
                        v1041 = (v874 & 0xFFFFFFFFFFFFFFF8) + 8;
                        if ((v874 | 7) != 0x17)
                          v1041 = v874 | 7;
                        v1042 = v1041 + 1;
                        v876 = (std::string *)operator new(v1041 + 1);
                        __dst.__r_.__value_.__l.__size_ = v875;
                        __dst.__r_.__value_.__r.__words[2] = v1042 | 0x8000000000000000;
                        __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v876;
                      }
                      else
                      {
                        *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v874;
                        v876 = &__dst;
                        if (!v874)
                          goto LABEL_1667;
                      }
                      memmove(v876, v873, v875);
LABEL_1667:
                      v876->__r_.__value_.__s.__data_[v875] = 0;
                      std::string::append(&__dst, ".partitions");
                      v1043 = *__error();
                      v1044 = _SILogForLogForCategory(16);
                      v1045 = dword_1EF19FCCC < 3;
                      if (os_log_type_enabled(v1044, (os_log_type_t)(dword_1EF19FCCC < 3)))
                      {
                        if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                          v1046 = &__dst;
                        else
                          v1046 = (std::string *)__dst.__r_.__value_.__r.__words[0];
                        LODWORD(v1289.__r_.__value_.__l.__data_) = 136315138;
                        *(std::string::size_type *)((char *)v1289.__r_.__value_.__r.__words + 4) = (std::string::size_type)v1046;
                        _os_log_impl(&dword_1B8270000, v1044, v1045, "*warn* Rebuild! Partitions %s currupted", (uint8_t *)&v1289, 0xCu);
                      }
                      *__error() = v1043;
                      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
                        operator delete(__dst.__r_.__value_.__l.__data_);
                      goto LABEL_1674;
                    }
                  }
LABEL_1068:
                  v418 = 0;
                  goto LABEL_1069;
                }
                if (!memcmp((const void *)v416[2], v408, v416[3]))
                  goto LABEL_1064;
              }
            }
            else
            {
              if (v419 >= v411)
                v419 %= v411;
              if (v419 != v414)
                goto LABEL_1068;
            }
LABEL_647:
            v418 = 0;
            v416 = (uint64_t *)*v416;
            if (!v416)
              goto LABEL_1069;
          }
        }
LABEL_638:
        operator delete(v1289.__r_.__value_.__l.__data_);
        if ((v1275[23] & 0x80000000) == 0)
          goto LABEL_625;
        goto LABEL_639;
      }
    }
    memcpy(v388, v385, v387);
    goto LABEL_594;
  }
  if (a4 != 1)
  {
LABEL_1882:
    v1175 = __si_assert_copy_extra_268();
    v1169 = v1175;
    v1176 = "";
    if (v1175)
      v1176 = v1175;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3568, "false", v1176);
    goto LABEL_1878;
  }
  if (a3 == 2)
  {
    v22 = operator new();
    v23 = *(_QWORD *)a5;
    v1282 = *(_QWORD *)(a5 + 8);
    v1283 = *(_DWORD *)(a5 + 16);
    v24 = *(_BYTE *)(a5 + 20);
    v1239 = *(unsigned __int8 *)(a5 + 21);
    v1280 = *(_QWORD *)(a5 + 22);
    v1281 = *(_WORD *)(a5 + 30);
    v1197 = *a6;
    v1221 = v24;
    __valb = *((_DWORD *)a6 + 4);
    v1209 = *((_QWORD *)a6 + 3);
    *(_QWORD *)v22 = off_1E6E30C80;
    *(_DWORD *)(v22 + 8) = a1;
    *(_QWORD *)(v22 + 12) = 0x200000300;
    *(_WORD *)(v22 + 20) = a2;
    *(_BYTE *)(v22 + 22) = a7;
    IVFIndexName(v22 + 24, a1, a2, 2, 1);
    *(_QWORD *)v22 = off_1E6E33D30;
    v25 = *(_DWORD *)(v22 + 12);
    if (v25 == 256)
    {
      v1191 = 0;
    }
    else
    {
      if (v25 == 768)
      {
        v26 = 2;
      }
      else if (v25 == 512)
      {
        v26 = 1;
      }
      else
      {
        v26 = 3;
      }
      v1191 = v26;
    }
    v196 = *(_DWORD *)(v22 + 16);
    v197 = *(unsigned __int16 *)(v22 + 20);
    v198 = *(unsigned __int8 *)(v22 + 22);
    v1264 = v22;
    *(_QWORD *)(v22 + 48) = &off_1E6E33E88;
    *(_QWORD *)(v22 + 56) = v23;
    v199 = (_DWORD *)(v22 + 48);
    if (v196 == 2)
      v200 = 1;
    else
      v200 = 3;
    if (v196 == 4)
      v201 = 0;
    else
      v201 = v200;
    v1185 = v201;
    if (v198)
      v197 |= 0x80000000;
    v1179 = v197;
    *(_QWORD *)(v22 + 64) = v1282;
    *(_DWORD *)(v22 + 72) = v1283;
    *(_BYTE *)(v22 + 76) = v1221;
    *(_BYTE *)(v22 + 77) = v1239;
    *(_QWORD *)(v22 + 78) = v1280;
    *(_WORD *)(v22 + 86) = v1281;
    *(_DWORD *)(v22 + 88) = a1;
    *(_WORD *)(v22 + 92) = a2;
    v202 = operator new(0x68uLL);
    v202[1] = 0;
    v202[2] = 0;
    *v202 = &off_1E6E33ED0;
    v202[3] = v23;
    *(_QWORD *)&buf[8] = *(_QWORD *)(v22 + 64);
    v203 = *(_QWORD *)&buf[8];
    *(_QWORD *)&buf[13] = *(_QWORD *)(v22 + 69);
    v204 = *(_QWORD *)&buf[13];
    v205 = v1280;
    *(_WORD *)&buf[22] = v1280;
    v206 = *(_DWORD *)(v22 + 80);
    v207 = v199[9];
    v202[4] = v203;
    *(_QWORD *)((char *)v202 + 37) = v204;
    *((_BYTE *)v202 + 45) = v1239;
    *((_WORD *)v202 + 23) = v205;
    *((_DWORD *)v202 + 12) = v206;
    *((_DWORD *)v202 + 13) = v207;
    v202[7] = 0;
    *((_DWORD *)v202 + 16) = 0;
    v202[11] = 0;
    v202[12] = 0;
    v202[10] = 0;
    bzero(v1290, 0x400uLL);
    v208 = fd_name(v23, v1290, 0x400uLL);
    MEMORY[0x1BCCB03B0](v202 + 10, v208);
    v209 = operator new();
    v1215 = v23;
    *(_QWORD *)buf = v23;
    buf[21] = v1239;
    *(_DWORD *)&buf[24] = v206;
    *(_DWORD *)&buf[28] = v207;
    v210 = vi_onefixedsize_disk_allocator::vi_onefixedsize_disk_allocator(v209, 20, 1552, (__int128 *)buf, (uint64_t)(v199 + 30));
    v211 = v202[7];
    v202[7] = v210;
    if (v211)
    {
      storage_array_Close(v211 + 8);
      v212 = *(const void **)(v211 + 4208);
      if (v212)
      {
        CFRelease(v212);
        *(_QWORD *)(v211 + 4208) = 0;
      }
      *(_OWORD *)(v211 + 4192) = 0u;
      MEMORY[0x1BCCB06A4](v211, 0x10A0C408BE2A288);
      v210 = v202[7];
    }
    v213 = _windowsResolvePtr(v210 + 40, 0x400uLL, *(_QWORD *)(v210 + 16));
    v214 = v213;
    if (v1239)
    {
      *(_QWORD *)v213 = 0x1015F1DA6;
      *(_DWORD *)(v213 + 8) = v206;
      v215 = 0xFFFFFFFFLL;
      *(_QWORD *)(v213 + 12) = 0xFFFFFFFFLL;
      LODWORD(v216) = *((_DWORD *)v202 + 16);
    }
    else
    {
      if (*(_DWORD *)v213 != 23010726)
        goto LABEL_1859;
      if (*(_DWORD *)(v213 + 4) != 1)
        goto LABEL_1862;
      v217 = (_QWORD *)v202[7];
      v218 = *__error();
      v219 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v219, OS_LOG_TYPE_DEFAULT))
      {
        v220 = v217[6];
        v221 = v217[7];
        v223 = v217[2];
        v222 = v217[3];
        *(_DWORD *)buf = 134219008;
        *(_QWORD *)&buf[4] = v217;
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = v220;
        *(_WORD *)&buf[22] = 2048;
        *(_QWORD *)&buf[24] = v221;
        v1285 = 2048;
        v1286 = v222;
        v1287 = 2048;
        v1288 = v223;
        _os_log_impl(&dword_1B8270000, v219, OS_LOG_TYPE_DEFAULT, "vi_onefixedsize_disk_allocator %p size: %llu, freeRegion: %llu, header: %llu, elemSize: %lu", buf, 0x34u);
      }
      *__error() = v218;
      v224 = (_QWORD *)v202[7];
      v225 = v224[2];
      v226 = v224[7] - v224[3];
      v216 = v226 / v225;
      if (v226 != v226 / v225 * v225)
        goto LABEL_1869;
      *((_DWORD *)v202 + 16) = v216;
      if (v224[3] != 1044)
        goto LABEL_1872;
      if (v224[2] != 1552)
        goto LABEL_1875;
      v215 = *(_QWORD *)(v214 + 12);
    }
    *(_DWORD *)(v1264 + 160) = 0;
    v227 = (os_unfair_lock_s *)(v1264 + 160);
    *(_QWORD *)((char *)v202 + 68) = v215;
    *(_OWORD *)(v1264 + 112) = 0u;
    *(_QWORD *)(v1264 + 96) = v202 + 3;
    *(_QWORD *)(v1264 + 104) = v202;
    *(_OWORD *)(v1264 + 128) = 0u;
    *(_OWORD *)(v1264 + 144) = 0u;
    *(_WORD *)(v1264 + 168) = v1197;
    *(_WORD *)(v1264 + 170) = v1268;
    *(_DWORD *)(v1264 + 172) = v1191;
    *(_DWORD *)(v1264 + 176) = v1185;
    *(_DWORD *)(v1264 + 180) = v1179;
    *(_DWORD *)(v1264 + 184) = __valb;
    *(_QWORD *)(v1264 + 192) = v1209;
    *(_QWORD *)(v1264 + 200) = 0xFFFFFFFF00000000;
    *(_BYTE *)(v1264 + 208) = v1221;
    *(_DWORD *)(v1264 + 212) = 0;
    *(_DWORD *)(v1264 + 216) = 0;
    if ((_DWORD)v216)
    {
      *(_DWORD *)(v1264 + 212) = *(_DWORD *)(_windowsResolvePtr(v202[7] + 40, *(_QWORD *)(v202[7] + 24), 0x610uLL)
                                           + 1544);
      *(_DWORD *)(v1264 + 216) = *(_DWORD *)(_windowsResolvePtr(*(_QWORD *)(*(_QWORD *)(v1264 + 96) + 32) + 40, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v1264 + 96) + 32) + 24)+ *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v1264 + 96) + 32) + 16)* (*(_DWORD *)(*(_QWORD *)(v1264 + 96) + 40) - 1), 0x610uLL)+ 1544);
    }
    if (v23)
      v228 = *(_DWORD *)(v23 + 44);
    else
      v228 = -1;
    __valh = *(_DWORD *)(v1264 + 88);
    bzero(v1290, 0x400uLL);
    v229 = fcntl(v228, 50, v1290);
    if (v1290[0])
      v230 = v229 < 0;
    else
      v230 = 1;
    if (v230)
      v231 = 0;
    else
      v231 = v1290;
    v232 = strlen(v231);
    if (v232 > 0x7FFFFFFFFFFFFFF7)
      goto LABEL_1881;
    v233 = v232;
    memset(&__dst, 0, sizeof(__dst));
    v1203 = v228;
    if (v232 >= 0x17)
    {
      v235 = (v232 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v232 | 7) != 0x17)
        v235 = v232 | 7;
      v236 = v235 + 1;
      v234 = (std::string *)operator new(v235 + 1);
      __dst.__r_.__value_.__l.__size_ = v233;
      __dst.__r_.__value_.__r.__words[2] = v236 | 0x8000000000000000;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v234;
    }
    else
    {
      *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v232;
      v234 = &__dst;
      if (!v232)
      {
LABEL_336:
        v234->__r_.__value_.__s.__data_[v233] = 0;
        v237 = SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
        if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v238 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
        else
          v238 = __dst.__r_.__value_.__l.__size_;
        v239 = v238 + 1;
        if (v238 + 1 > 0x7FFFFFFFFFFFFFF7)
          goto LABEL_1881;
        if (v239 >= 0x17)
        {
          v241 = (v239 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v239 | 7) != 0x17)
            v241 = v239 | 7;
          v242 = v241 + 1;
          v240 = operator new(v241 + 1);
          *(_QWORD *)&v1275[8] = v238 + 1;
          *(_QWORD *)&v1275[16] = v242 | 0x8000000000000000;
          *(_QWORD *)v1275 = v240;
        }
        else
        {
          memset(v1275, 0, 24);
          v240 = v1275;
          v1275[23] = v238 + 1;
          if (!v238)
            goto LABEL_350;
        }
        if (v237 >= 0)
          v243 = &__dst;
        else
          v243 = (std::string *)__dst.__r_.__value_.__r.__words[0];
        memmove(v240, v243, v238);
LABEL_350:
        *(_WORD *)&v240[v238] = 47;
        std::to_string(&v1289, __valh);
        if ((v1289.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v244 = &v1289;
        else
          v244 = (std::string *)v1289.__r_.__value_.__r.__words[0];
        if ((v1289.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v245 = HIBYTE(v1289.__r_.__value_.__r.__words[2]);
        else
          v245 = v1289.__r_.__value_.__l.__size_;
        v246 = std::string::append((std::string *)v1275, (const std::string::value_type *)v244, v245);
        v247 = v246->__r_.__value_.__r.__words[2];
        *(_OWORD *)v1276 = *(_OWORD *)&v246->__r_.__value_.__l.__data_;
        *(_QWORD *)&v1276[16] = v247;
        v246->__r_.__value_.__l.__size_ = 0;
        v246->__r_.__value_.__r.__words[2] = 0;
        v246->__r_.__value_.__r.__words[0] = 0;
        v248 = std::string::append((std::string *)v1276, "-");
        v249 = v248->__r_.__value_.__r.__words[2];
        *(_OWORD *)buf = *(_OWORD *)&v248->__r_.__value_.__l.__data_;
        *(_QWORD *)&buf[16] = v249;
        v248->__r_.__value_.__l.__size_ = 0;
        v248->__r_.__value_.__r.__words[2] = 0;
        v248->__r_.__value_.__r.__words[0] = 0;
        std::to_string(&v1278, v1249);
        if ((v1278.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v250 = &v1278;
        else
          v250 = (std::string *)v1278.__r_.__value_.__r.__words[0];
        if ((v1278.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v251 = HIBYTE(v1278.__r_.__value_.__r.__words[2]);
        else
          v251 = v1278.__r_.__value_.__l.__size_;
        v252 = std::string::append((std::string *)buf, (const std::string::value_type *)v250, v251);
        v1279 = *v252;
        v252->__r_.__value_.__r.__words[0] = 0;
        v252->__r_.__value_.__l.__size_ = 0;
        v252->__r_.__value_.__r.__words[2] = 0;
        if (SHIBYTE(v1278.__r_.__value_.__r.__words[2]) < 0)
        {
          operator delete(v1278.__r_.__value_.__l.__data_);
          if ((buf[23] & 0x80000000) == 0)
          {
LABEL_364:
            if ((v1276[23] & 0x80000000) == 0)
              goto LABEL_365;
            goto LABEL_379;
          }
        }
        else if ((buf[23] & 0x80000000) == 0)
        {
          goto LABEL_364;
        }
        operator delete(*(void **)buf);
        if ((v1276[23] & 0x80000000) == 0)
        {
LABEL_365:
          if ((SHIBYTE(v1289.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            goto LABEL_366;
          goto LABEL_380;
        }
LABEL_379:
        operator delete(*(void **)v1276);
        if ((SHIBYTE(v1289.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_366:
          if ((v1275[23] & 0x80000000) == 0)
            goto LABEL_367;
LABEL_381:
          operator delete(*(void **)v1275);
LABEL_367:
          v253 = atomic_load((unsigned __int8 *)&_ZGVZN16QuantizerManagerIDF16_Li768EE14sharedInstanceEijtE8managers);
          if ((v253 & 1) == 0
            && __cxa_guard_acquire(&_ZGVZN16QuantizerManagerIDF16_Li768EE14sharedInstanceEijtE8managers))
          {
            _ZZN16QuantizerManagerIDF16_Li768EE14sharedInstanceEijtE8managers = 0u;
            *(_OWORD *)&qword_1EF1B06D8 = 0u;
            dword_1EF1B06E8 = 1065353216;
            __cxa_atexit((void (*)(void *))_ZNSt3__113unordered_mapINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEENS_8weak_ptrI16QuantizerManagerIDF16_Li768EEEENS_4hashIS6_EENS_8equal_toIS6_EENS4_INS_4pairIKS6_SA_EEEEED1B8nn180100Ev, &_ZZN16QuantizerManagerIDF16_Li768EE14sharedInstanceEijtE8managers, &dword_1B8270000);
            __cxa_guard_release(&_ZGVZN16QuantizerManagerIDF16_Li768EE14sharedInstanceEijtE8managers);
          }
          os_unfair_lock_lock((os_unfair_lock_t)&_ZZN16QuantizerManagerIDF16_Li768EE14sharedInstanceEijtE4lock);
          if ((v1279.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v254 = &v1279;
          else
            v254 = (std::string *)v1279.__r_.__value_.__r.__words[0];
          if ((v1279.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v255 = HIBYTE(v1279.__r_.__value_.__r.__words[2]);
          else
            v255 = v1279.__r_.__value_.__l.__size_;
          v256 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t *)v254, v255);
          v257 = *((_QWORD *)&_ZZN16QuantizerManagerIDF16_Li768EE14sharedInstanceEijtE8managers + 1);
          if (!*((_QWORD *)&_ZZN16QuantizerManagerIDF16_Li768EE14sharedInstanceEijtE8managers + 1))
            goto LABEL_940;
          v258 = v256;
          v259 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&_ZZN16QuantizerManagerIDF16_Li768EE14sharedInstanceEijtE8managers
                                                + 8));
          v259.i16[0] = vaddlv_u8(v259);
          if (v259.u32[0] > 1uLL)
          {
            v260 = v256;
            if (v256 >= *((_QWORD *)&_ZZN16QuantizerManagerIDF16_Li768EE14sharedInstanceEijtE8managers + 1))
              v260 = v256 % *((_QWORD *)&_ZZN16QuantizerManagerIDF16_Li768EE14sharedInstanceEijtE8managers + 1);
          }
          else
          {
            v260 = (*((_QWORD *)&_ZZN16QuantizerManagerIDF16_Li768EE14sharedInstanceEijtE8managers + 1) - 1) & v256;
          }
          v261 = *(uint64_t ***)(_ZZN16QuantizerManagerIDF16_Li768EE14sharedInstanceEijtE8managers + 8 * v260);
          if (!v261)
            goto LABEL_940;
          v262 = *v261;
          if (!*v261)
            goto LABEL_940;
          if (v259.u32[0] < 2uLL)
          {
            v263 = *((_QWORD *)&_ZZN16QuantizerManagerIDF16_Li768EE14sharedInstanceEijtE8managers + 1) - 1;
            while (1)
            {
              v269 = v262[1];
              if (v269 == v258)
              {
                v270 = *((unsigned __int8 *)v262 + 39);
                if ((v270 & 0x80u) == 0)
                  v271 = *((unsigned __int8 *)v262 + 39);
                else
                  v271 = v262[3];
                if (v271 == v255)
                {
                  if ((v270 & 0x80) != 0)
                  {
                    if (!memcmp((const void *)v262[2], v254, v262[3]))
                      goto LABEL_936;
                  }
                  else
                  {
                    if (!*((_BYTE *)v262 + 39))
                      goto LABEL_936;
                    v272 = 0;
                    while (*((unsigned __int8 *)v262 + v272 + 16) == v254->__r_.__value_.__s.__data_[v272])
                    {
                      if (v270 == ++v272)
                        goto LABEL_935;
                    }
                  }
                }
              }
              else if ((v269 & v263) != v260)
              {
                goto LABEL_940;
              }
              v264 = 0;
              v262 = (uint64_t *)*v262;
              if (!v262)
                goto LABEL_941;
            }
          }
          while (1)
          {
            v265 = v262[1];
            if (v265 == v258)
            {
              v266 = *((unsigned __int8 *)v262 + 39);
              if ((v266 & 0x80u) == 0)
                v267 = *((unsigned __int8 *)v262 + 39);
              else
                v267 = v262[3];
              if (v267 == v255)
              {
                if ((v266 & 0x80) == 0)
                {
                  if (!*((_BYTE *)v262 + 39))
                    goto LABEL_936;
                  v268 = 0;
                  do
                  {
                    if (*((unsigned __int8 *)v262 + v268 + 16) != v254->__r_.__value_.__s.__data_[v268])
                      goto LABEL_389;
                    ++v268;
                  }
                  while (v266 != v268);
LABEL_935:
                  if (v262)
                  {
LABEL_936:
                    v579 = _ZNSt3__112__hash_tableINS_17__hash_value_typeINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEENS_8weak_ptrI16QuantizerManagerIDF16_Li768EEEEEENS_22__unordered_map_hasherIS7_SC_NS_4hashIS7_EENS_8equal_toIS7_EELb1EEENS_21__unordered_map_equalIS7_SC_SH_SF_Lb1EEENS5_ISC_EEE25__emplace_unique_key_argsIS7_JRKNS_21piecewise_construct_tENS_5tupleIJRKS7_EEENSR_IJEEEEEENS_4pairINS_15__hash_iteratorIPNS_11__hash_nodeISC_PvEEEEbEERKT_DpOT0_((uint64_t)&v1279, (uint64_t)&v1279);
                    v580 = (std::__shared_weak_count *)*((_QWORD *)v579 + 6);
                    if (v580)
                    {
                      v581 = std::__shared_weak_count::lock(v580);
                      v264 = v581;
                      if (v581 && *((_QWORD *)v579 + 5))
                      {
                        *(_QWORD *)&v582 = *((_QWORD *)v579 + 5);
                        *((_QWORD *)&v582 + 1) = v581;
                        v1252 = v582;
                        v508 = v1264;
                        v583 = (uint64_t *)(v1264 + 112);
                        v584 = v1215;
                        goto LABEL_981;
                      }
LABEL_941:
                      v585 = operator new();
                      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
                        std::string::__init_copy_ctor_external(&v1289, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
                      else
                        v1289 = __dst;
                      *(_DWORD *)v585 = v1203;
                      *(_DWORD *)(v585 + 4) = __valh;
                      *(_WORD *)(v585 + 8) = v1249;
                      v586 = (std::string *)(v585 + 24);
                      if (SHIBYTE(v1289.__r_.__value_.__r.__words[2]) < 0)
                      {
                        std::string::__init_copy_ctor_external(v586, v1289.__r_.__value_.__l.__data_, v1289.__r_.__value_.__l.__size_);
                      }
                      else
                      {
                        *(_OWORD *)&v586->__r_.__value_.__l.__data_ = *(_OWORD *)&v1289.__r_.__value_.__l.__data_;
                        *(_QWORD *)(v585 + 40) = *((_QWORD *)&v1289.__r_.__value_.__l + 2);
                      }
                      IVFIndexName(v585 + 48, __valh, v1249, 2, 1);
                      *(_OWORD *)(v585 + 112) = 0u;
                      *(_OWORD *)(v585 + 128) = 0u;
                      *(_OWORD *)(v585 + 80) = 0u;
                      *(_OWORD *)(v585 + 96) = 0u;
                      *(_DWORD *)(v585 + 144) = 1065353216;
                      v587 = *__error();
                      v588 = _SILogForLogForCategory(16);
                      if (os_log_type_enabled(v588, OS_LOG_TYPE_DEFAULT))
                      {
                        v589 = &v1289;
                        if ((v1289.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
                          v589 = (std::string *)v1289.__r_.__value_.__r.__words[0];
                        if (*(char *)(v585 + 71) < 0)
                          v590 = *(_QWORD *)(v585 + 48);
                        else
                          v590 = v585 + 48;
                        *(_DWORD *)buf = 136315394;
                        *(_QWORD *)&buf[4] = v589;
                        *(_WORD *)&buf[12] = 2080;
                        *(_QWORD *)&buf[14] = v590;
                        _os_log_impl(&dword_1B8270000, v588, OS_LOG_TYPE_DEFAULT, "QuantizerManager %s/%s created", buf, 0x16u);
                      }
                      *__error() = v587;
                      v1275[23] = 20;
                      strcpy(v1275, "com.apple.spotlight.");
                      v591 = *(char *)(v585 + 71);
                      if (v591 >= 0)
                        v592 = (const std::string::value_type *)(v585 + 48);
                      else
                        v592 = *(const std::string::value_type **)(v585 + 48);
                      if (v591 >= 0)
                        v593 = *(unsigned __int8 *)(v585 + 71);
                      else
                        v593 = *(_QWORD *)(v585 + 56);
                      v594 = std::string::append((std::string *)v1275, v592, v593);
                      v595 = v594->__r_.__value_.__r.__words[2];
                      *(_OWORD *)v1276 = *(_OWORD *)&v594->__r_.__value_.__l.__data_;
                      *(_QWORD *)&v1276[16] = v595;
                      v594->__r_.__value_.__l.__size_ = 0;
                      v594->__r_.__value_.__r.__words[2] = 0;
                      v594->__r_.__value_.__r.__words[0] = 0;
                      v596 = std::string::append((std::string *)v1276, ".quantizerManager");
                      v597 = v596->__r_.__value_.__r.__words[2];
                      *(_OWORD *)buf = *(_OWORD *)&v596->__r_.__value_.__l.__data_;
                      *(_QWORD *)&buf[16] = v597;
                      v596->__r_.__value_.__l.__size_ = 0;
                      v596->__r_.__value_.__r.__words[2] = 0;
                      v596->__r_.__value_.__r.__words[0] = 0;
                      if ((v1276[23] & 0x80000000) != 0)
                        operator delete(*(void **)v1276);
                      if ((v1275[23] & 0x80000000) != 0)
                        operator delete(*(void **)v1275);
                      if (buf[23] >= 0)
                        v598 = buf;
                      else
                        v598 = *(const char **)buf;
                      *(_QWORD *)(v585 + 16) = dispatch_queue_create(v598, 0);
                      atomic_store(0, (unsigned __int8 *)(v585 + 72));
                      if ((buf[23] & 0x80000000) != 0)
                        operator delete(*(void **)buf);
                      v599 = (_QWORD *)operator new();
                      *v599 = &off_1E6E33F08;
                      v599[1] = 0;
                      v599[2] = 0;
                      v599[3] = v585;
                      if (v264)
                      {
                        v600 = (unint64_t *)&v264->__shared_owners_;
                        do
                          v601 = __ldaxr(v600);
                        while (__stlxr(v601 - 1, v600));
                        if (!v601)
                        {
                          ((void (*)(std::__shared_weak_count *))v264->__on_zero_shared)(v264);
                          std::__shared_weak_count::__release_weak(v264);
                        }
                      }
                      *(_QWORD *)&v602 = v585;
                      if (SHIBYTE(v1289.__r_.__value_.__r.__words[2]) < 0)
                      {
                        operator delete(v1289.__r_.__value_.__l.__data_);
                        *(_QWORD *)&v602 = v585;
                      }
                      *((_QWORD *)&v602 + 1) = v599;
                      v1252 = v602;
                      v603 = v599 + 2;
                      v508 = v1264;
                      v583 = (uint64_t *)(v1264 + 112);
                      do
                        v604 = __ldxr(v603);
                      while (__stxr(v604 + 1, v603));
                      v605 = _ZNSt3__112__hash_tableINS_17__hash_value_typeINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEENS_8weak_ptrI16QuantizerManagerIDF16_Li768EEEEEENS_22__unordered_map_hasherIS7_SC_NS_4hashIS7_EENS_8equal_toIS7_EELb1EEENS_21__unordered_map_equalIS7_SC_SH_SF_Lb1EEENS5_ISC_EEE25__emplace_unique_key_argsIS7_JRKNS_21piecewise_construct_tENS_5tupleIJRKS7_EEENSR_IJEEEEEENS_4pairINS_15__hash_iteratorIPNS_11__hash_nodeISC_PvEEEEbEERKT_DpOT0_((uint64_t)&v1279, (uint64_t)&v1279);
                      v606 = (std::__shared_weak_count *)*((_QWORD *)v605 + 6);
                      *((_QWORD *)v605 + 5) = v585;
                      *((_QWORD *)v605 + 6) = v599;
                      if (v606)
                        std::__shared_weak_count::__release_weak(v606);
                      v584 = v1215;
LABEL_981:
                      os_unfair_lock_unlock((os_unfair_lock_t)&_ZZN16QuantizerManagerIDF16_Li768EE14sharedInstanceEijtE4lock);
                      if (SHIBYTE(v1279.__r_.__value_.__r.__words[2]) < 0)
                        operator delete(v1279.__r_.__value_.__l.__data_);
                      v607 = v1252;
                      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
                      {
                        operator delete(__dst.__r_.__value_.__l.__data_);
                        v607 = v1252;
                      }
                      v608 = *(std::__shared_weak_count **)(v508 + 120);
                      *(_OWORD *)(v508 + 112) = v607;
                      if (v608)
                      {
                        v609 = (unint64_t *)&v608->__shared_owners_;
                        do
                          v610 = __ldaxr(v609);
                        while (__stlxr(v610 - 1, v609));
                        if (!v610)
                        {
                          ((void (*)(std::__shared_weak_count *))v608->__on_zero_shared)(v608);
                          std::__shared_weak_count::__release_weak(v608);
                        }
                      }
                      if (v1239)
                      {
                        _ZN16QuantizerManagerIDF16_Li768EE15sharedQuantizerEi(v1290, *v583, 0);
                        IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::replaceQuantizer((uint64_t)v199, (uint64_t *)v1290);
                        v537 = *(std::__shared_weak_count **)&v1290[8];
                        if (*(_QWORD *)&v1290[8])
                        {
                          v611 = (unint64_t *)(*(_QWORD *)&v1290[8] + 8);
                          do
                            v539 = __ldaxr(v611);
                          while (__stlxr(v539 - 1, v611));
                          goto LABEL_1772;
                        }
                        return v508;
                      }
                      memset(buf, 0, sizeof(buf));
                      *(_QWORD *)v1276 = v584;
                      *(_QWORD *)&v1276[8] = v1282;
                      *(_DWORD *)&v1276[16] = v1283;
                      *(_WORD *)&v1276[20] = v1221;
                      *(_QWORD *)&v1276[22] = v1280;
                      v1277 = v1281;
                      *((_BYTE *)&v1279.__r_.__value_.__s + 23) = 11;
                      strcpy((char *)&v1279, ".partitions");
                      IVFVectorIndexTemplate<float,768>::childMetaInfo((uint64_t)buf, (uint64_t)v1276, (uint64_t)&v1279, 0);
                      if (SHIBYTE(v1279.__r_.__value_.__r.__words[2]) < 0)
                        operator delete(v1279.__r_.__value_.__l.__data_);
                      *(_OWORD *)&v1278.__r_.__value_.__l.__data_ = 0uLL;
                      *(_OWORD *)v1275 = *(_OWORD *)buf;
                      *(_OWORD *)&v1275[16] = *(_OWORD *)&buf[16];
                      PartitionStore<vi_onefixedsize_disk_allocator,512>::openPartitionStore<vi_onefixedsize_disk_allocator>((std::__shared_weak_count **)&v1278, (uint64_t)v1275);
                      v612 = (_DWORD *)v1278.__r_.__value_.__r.__words[0];
                      if (v1278.__r_.__value_.__r.__words[0])
                      {
                        v613 = *(_DWORD *)(v1278.__r_.__value_.__r.__words[0] + 76);
                        v614 = v1278.__r_.__value_.__r.__words[0];
                      }
                      else
                      {
                        v614 = 0;
                        v613 = 0;
                      }
                      v1273 = 0;
                      v1274 = 0;
                      _ZN16QuantizerManagerIDF16_Li768EE15sharedQuantizerEi(&v1273, *v583, v613);
                      if (v614)
                      {
                        v741 = *(_DWORD *)(v614 + 76);
                        v742 = v1273;
                        if (v741 == (*(unsigned int (**)(char *))(*(_QWORD *)v1273 + 16))(v1273))
                        {
                          if (v612[18] == *(_DWORD *)(*(_QWORD *)(v508 + 96) + 40))
                          {
                            v743 = v1274;
                            if (v1274)
                            {
                              v744 = (unint64_t *)&v1274->__shared_owners_;
                              do
                                v745 = __ldxr(v744);
                              while (__stxr(v745 + 1, v744));
                              AnyPartitionStore::replaceQuantizer((uint64_t)v612, (uint64_t)v742, (uint64_t)v743);
                              v746 = (unint64_t *)&v743->__shared_owners_;
                              do
                                v747 = __ldaxr(v746);
                              while (__stlxr(v747 - 1, v746));
                              if (!v747)
                              {
                                ((void (*)(std::__shared_weak_count *))v743->__on_zero_shared)(v743);
                                std::__shared_weak_count::__release_weak(v743);
                              }
                              *(_QWORD *)v1290 = v1273;
                              *(_QWORD *)&v1290[8] = v1274;
                              if (v1274)
                              {
                                v748 = (unint64_t *)&v1274->__shared_owners_;
                                do
                                  v749 = __ldxr(v748);
                                while (__stxr(v749 + 1, v748));
                              }
                            }
                            else
                            {
                              AnyPartitionStore::replaceQuantizer((uint64_t)v612, (uint64_t)v742, 0);
                              *(_QWORD *)v1290 = v1273;
                              *(_QWORD *)&v1290[8] = 0;
                            }
                            *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = *(_OWORD *)&v1278.__r_.__value_.__l.__data_;
                            if (v1278.__r_.__value_.__l.__size_)
                            {
                              v1130 = (unint64_t *)(v1278.__r_.__value_.__l.__size_ + 8);
                              do
                                v1131 = __ldxr(v1130);
                              while (__stxr(v1131 + 1, v1130));
                            }
                            (*(void (**)(_DWORD *, _BYTE *, std::string *))(*(_QWORD *)v199 + 48))(v199, v1290, &__dst);
                            v1132 = (std::__shared_weak_count *)__dst.__r_.__value_.__l.__size_;
                            if (__dst.__r_.__value_.__l.__size_)
                            {
                              v1133 = (unint64_t *)(__dst.__r_.__value_.__l.__size_ + 8);
                              do
                                v1134 = __ldaxr(v1133);
                              while (__stlxr(v1134 - 1, v1133));
                              if (!v1134)
                              {
                                ((void (*)(std::__shared_weak_count *))v1132->__on_zero_shared)(v1132);
                                std::__shared_weak_count::__release_weak(v1132);
                              }
                            }
                            v1135 = *(std::__shared_weak_count **)&v1290[8];
                            if (*(_QWORD *)&v1290[8])
                            {
                              v1136 = (unint64_t *)(*(_QWORD *)&v1290[8] + 8);
                              do
                                v1137 = __ldaxr(v1136);
                              while (__stlxr(v1137 - 1, v1136));
                              if (!v1137)
                              {
                                ((void (*)(std::__shared_weak_count *))v1135->__on_zero_shared)(v1135);
                                std::__shared_weak_count::__release_weak(v1135);
                              }
                            }
                            goto LABEL_1599;
                          }
LABEL_1336:
                          v817 = *__error();
                          v818 = _SILogForLogForCategory(16);
                          v819 = dword_1EF19FCCC < 3;
                          if (os_log_type_enabled(v818, (os_log_type_t)(dword_1EF19FCCC < 3)))
                          {
                            v1258 = v817;
                            (*(void (**)(std::string *__return_ptr, _DWORD *))(*(_QWORD *)v612 + 144))(&__dst, v612);
                            if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                              v820 = &__dst;
                            else
                              v820 = (std::string *)__dst.__r_.__value_.__r.__words[0];
                            v821 = v612[19];
                            v1245 = v612[18];
                            v822 = v742 + 8;
                            if (v742[31] < 0)
                              v822 = (_QWORD *)*v822;
                            v823 = (*(uint64_t (**)(char *))(*(_QWORD *)v742 + 16))(v742);
                            v824 = *(_DWORD *)(*(_QWORD *)(v1264 + 96) + 40);
                            *(_DWORD *)v1290 = 136316418;
                            *(_QWORD *)&v1290[4] = v820;
                            *(_WORD *)&v1290[12] = 1024;
                            *(_DWORD *)&v1290[14] = v821;
                            v1291 = 1024;
                            v1292 = v1245;
                            v1293 = 2080;
                            v1294 = v822;
                            v1295 = 1024;
                            v1296 = v823;
                            v1297 = 1024;
                            v1298 = v824;
                            _os_log_impl(&dword_1B8270000, v818, v819, "*warn* Rebuild! Partitions %s version: %d count: %u not match Quantizer %s version %d vectors count:%u.", v1290, 0x2Eu);
                            if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
                              operator delete(__dst.__r_.__value_.__l.__data_);
                            v508 = v1264;
                            v817 = v1258;
                          }
                          *__error() = v817;
                          *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = 0uLL;
                          __dst.__r_.__value_.__r.__words[2] = (std::string::size_type)v612;
                          v1272 = v1278.__r_.__value_.__l.__size_;
                          if (v1278.__r_.__value_.__l.__size_)
                          {
                            v825 = (unint64_t *)(v1278.__r_.__value_.__l.__size_ + 8);
                            do
                              v826 = __ldxr(v825);
                            while (__stxr(v826 + 1, v825));
                          }
                          os_unfair_lock_lock(v227);
                          std::swap[abi:nn180100]<IVFVectorIndexTemplate<float,768>::QuantizerPartitions>((__int128 *)(v1264 + 128), (__int128 *)&__dst);
                          os_unfair_lock_unlock(v227);
                          v827 = (std::__shared_weak_count *)v1272;
                          if (v1272)
                          {
                            v828 = (unint64_t *)(v1272 + 8);
                            do
                              v829 = __ldaxr(v828);
                            while (__stlxr(v829 - 1, v828));
                            if (!v829)
                            {
                              ((void (*)(std::__shared_weak_count *))v827->__on_zero_shared)(v827);
                              std::__shared_weak_count::__release_weak(v827);
                            }
                          }
                          v830 = (std::__shared_weak_count *)__dst.__r_.__value_.__l.__size_;
                          if (__dst.__r_.__value_.__l.__size_)
                          {
                            v831 = (unint64_t *)(__dst.__r_.__value_.__l.__size_ + 8);
                            do
                              v832 = __ldaxr(v831);
                            while (__stlxr(v832 - 1, v831));
                            if (!v832)
                            {
                              ((void (*)(std::__shared_weak_count *))v830->__on_zero_shared)(v830);
                              std::__shared_weak_count::__release_weak(v830);
                            }
                          }
LABEL_1564:
                          v975 = v1274;
                          v1269 = v1273;
                          v1270 = v1274;
                          if (v1274)
                          {
                            v976 = (unint64_t *)&v1274->__shared_owners_;
                            do
                              v977 = __ldxr(v976);
                            while (__stxr(v977 + 1, v976));
                            IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::replaceQuantizer((uint64_t)v199, (uint64_t *)&v1269);
                            do
                              v978 = __ldaxr(v976);
                            while (__stlxr(v978 - 1, v976));
                            if (!v978)
                            {
                              ((void (*)(std::__shared_weak_count *))v975->__on_zero_shared)(v975);
                              std::__shared_weak_count::__release_weak(v975);
                            }
                          }
                          else
                          {
                            IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::replaceQuantizer((uint64_t)v199, (uint64_t *)&v1269);
                          }
                          os_unfair_lock_lock(v227);
                          v979 = *(std::__shared_weak_count **)(v508 + 136);
                          if (v979)
                          {
                            v980 = (unint64_t *)&v979->__shared_owners_;
                            do
                              v981 = __ldxr(v980);
                            while (__stxr(v981 + 1, v980));
                          }
                          v983 = *(_QWORD *)(v508 + 144);
                          v982 = *(_QWORD *)(v508 + 152);
                          if (v982)
                          {
                            v984 = (unint64_t *)(v982 + 8);
                            do
                              v985 = __ldxr(v984);
                            while (__stxr(v985 + 1, v984));
                          }
                          os_unfair_lock_unlock(v227);
                          v986 = (std::__shared_weak_count *)v1278.__r_.__value_.__l.__size_;
                          v1278.__r_.__value_.__r.__words[0] = v983;
                          v1278.__r_.__value_.__l.__size_ = v982;
                          if (v986)
                          {
                            v987 = (unint64_t *)&v986->__shared_owners_;
                            do
                              v988 = __ldaxr(v987);
                            while (__stlxr(v988 - 1, v987));
                            if (!v988)
                            {
                              ((void (*)(std::__shared_weak_count *))v986->__on_zero_shared)(v986);
                              std::__shared_weak_count::__release_weak(v986);
                            }
                          }
                          if (v979)
                          {
                            v989 = (unint64_t *)&v979->__shared_owners_;
                            do
                              v990 = __ldaxr(v989);
                            while (__stlxr(v990 - 1, v989));
                            if (!v990)
                            {
                              ((void (*)(std::__shared_weak_count *))v979->__on_zero_shared)(v979);
                              std::__shared_weak_count::__release_weak(v979);
                            }
                          }
                          if (*(_BYTE *)(v508 + 208))
                            (*(void (**)(std::string::size_type))(*(_QWORD *)v1278.__r_.__value_.__l.__data_
                                                                           + 120))(v1278.__r_.__value_.__r.__words[0]);
                          v991 = *__error();
                          v992 = _SILogForLogForCategory(16);
                          if (os_log_type_enabled(v992, OS_LOG_TYPE_DEFAULT))
                          {
                            v993 = v1278.__r_.__value_.__r.__words[0];
                            (*(void (**)(std::string *__return_ptr, std::string::size_type))(*(_QWORD *)v1278.__r_.__value_.__l.__data_ + 144))(&v1289, v1278.__r_.__value_.__r.__words[0]);
                            if ((v1289.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                              v994 = &v1289;
                            else
                              v994 = (std::string *)v1289.__r_.__value_.__r.__words[0];
                            v997 = v993 + 72;
                            v995 = *(_DWORD *)(v993 + 72);
                            v996 = *(_DWORD *)(v997 + 4);
                            v998 = v1273 + 8;
                            if (v1273[31] < 0)
                              v998 = (_QWORD *)*v998;
                            v999 = (*(uint64_t (**)(void))(*(_QWORD *)v1273 + 16))();
                            v1000 = *(_DWORD *)(*(_QWORD *)(v508 + 96) + 40);
                            *(_DWORD *)v1290 = 136316418;
                            *(_QWORD *)&v1290[4] = v994;
                            *(_WORD *)&v1290[12] = 1024;
                            *(_DWORD *)&v1290[14] = v996;
                            v1291 = 1024;
                            v1292 = v995;
                            v1293 = 2080;
                            v1294 = v998;
                            v1295 = 1024;
                            v1296 = v999;
                            v1297 = 1024;
                            v1298 = v1000;
                            _os_log_impl(&dword_1B8270000, v992, OS_LOG_TYPE_DEFAULT, "Partitions rebuilt %s version: %d count: %u not match Quantizer %s version %d vectors count:%u.", v1290, 0x2Eu);
                            if (SHIBYTE(v1289.__r_.__value_.__r.__words[2]) < 0)
                              operator delete(v1289.__r_.__value_.__l.__data_);
                          }
                          *__error() = v991;
LABEL_1599:
                          v1001 = v1274;
                          if (v1274)
                          {
                            v1002 = (unint64_t *)&v1274->__shared_owners_;
                            do
                              v1003 = __ldaxr(v1002);
                            while (__stlxr(v1003 - 1, v1002));
                            if (!v1003)
                            {
                              ((void (*)(std::__shared_weak_count *))v1001->__on_zero_shared)(v1001);
                              std::__shared_weak_count::__release_weak(v1001);
                            }
                          }
                          v537 = (std::__shared_weak_count *)v1278.__r_.__value_.__l.__size_;
                          if (v1278.__r_.__value_.__l.__size_)
                          {
                            v1004 = (unint64_t *)(v1278.__r_.__value_.__l.__size_ + 8);
                            do
                              v539 = __ldaxr(v1004);
                            while (__stlxr(v539 - 1, v1004));
                            goto LABEL_1772;
                          }
                          return v508;
                        }
                        if (v612)
                          goto LABEL_1336;
                      }
                      bzero(v1290, 0x400uLL);
                      memset(&__dst, 0, sizeof(__dst));
                      v833 = fd_name(v584, v1290, 0x400uLL);
                      v834 = strlen(v833);
                      if (v834 > 0x7FFFFFFFFFFFFFF7)
                        goto LABEL_1881;
                      v835 = v834;
                      if (v834 >= 0x17)
                      {
                        v969 = (v834 & 0xFFFFFFFFFFFFFFF8) + 8;
                        if ((v834 | 7) != 0x17)
                          v969 = v834 | 7;
                        v970 = v969 + 1;
                        v836 = (std::string *)operator new(v969 + 1);
                        __dst.__r_.__value_.__l.__size_ = v835;
                        __dst.__r_.__value_.__r.__words[2] = v970 | 0x8000000000000000;
                        __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v836;
                      }
                      else
                      {
                        *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v834;
                        v836 = &__dst;
                        if (!v834)
                          goto LABEL_1557;
                      }
                      memmove(v836, v833, v835);
LABEL_1557:
                      v836->__r_.__value_.__s.__data_[v835] = 0;
                      std::string::append(&__dst, ".partitions");
                      v971 = *__error();
                      v972 = _SILogForLogForCategory(16);
                      v973 = dword_1EF19FCCC < 3;
                      if (os_log_type_enabled(v972, (os_log_type_t)(dword_1EF19FCCC < 3)))
                      {
                        if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                          v974 = &__dst;
                        else
                          v974 = (std::string *)__dst.__r_.__value_.__r.__words[0];
                        LODWORD(v1289.__r_.__value_.__l.__data_) = 136315138;
                        *(std::string::size_type *)((char *)v1289.__r_.__value_.__r.__words + 4) = (std::string::size_type)v974;
                        _os_log_impl(&dword_1B8270000, v972, v973, "*warn* Rebuild! Partitions %s currupted", (uint8_t *)&v1289, 0xCu);
                      }
                      *__error() = v971;
                      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
                        operator delete(__dst.__r_.__value_.__l.__data_);
                      goto LABEL_1564;
                    }
                  }
LABEL_940:
                  v264 = 0;
                  goto LABEL_941;
                }
                if (!memcmp((const void *)v262[2], v254, v262[3]))
                  goto LABEL_936;
              }
            }
            else
            {
              if (v265 >= v257)
                v265 %= v257;
              if (v265 != v260)
                goto LABEL_940;
            }
LABEL_389:
            v264 = 0;
            v262 = (uint64_t *)*v262;
            if (!v262)
              goto LABEL_941;
          }
        }
LABEL_380:
        operator delete(v1289.__r_.__value_.__l.__data_);
        if ((v1275[23] & 0x80000000) == 0)
          goto LABEL_367;
        goto LABEL_381;
      }
    }
    memcpy(v234, v231, v233);
    goto LABEL_336;
  }
  if (a3 == 1)
  {
    v27 = operator new();
    v28 = *(_QWORD *)a5;
    v1282 = *(_QWORD *)(a5 + 8);
    v1283 = *(_DWORD *)(a5 + 16);
    v29 = *(_BYTE *)(a5 + 20);
    v1240 = *(unsigned __int8 *)(a5 + 21);
    v1280 = *(_QWORD *)(a5 + 22);
    v1281 = *(_WORD *)(a5 + 30);
    v1198 = *a6;
    v1222 = v29;
    __valc = *((_DWORD *)a6 + 4);
    v1210 = *((_QWORD *)a6 + 3);
    *(_QWORD *)v27 = off_1E6E30C80;
    *(_DWORD *)(v27 + 8) = a1;
    *(_QWORD *)(v27 + 12) = 0x200000200;
    *(_WORD *)(v27 + 20) = a2;
    *(_BYTE *)(v27 + 22) = a7;
    IVFIndexName(v27 + 24, a1, a2, 1, 1);
    *(_QWORD *)v27 = off_1E6E339E8;
    v30 = *(_DWORD *)(v27 + 12);
    if (v30 == 256)
    {
      v1192 = 0;
    }
    else
    {
      if (v30 == 768)
      {
        v31 = 2;
      }
      else if (v30 == 512)
      {
        v31 = 1;
      }
      else
      {
        v31 = 3;
      }
      v1192 = v31;
    }
    v273 = *(_DWORD *)(v27 + 16);
    v274 = *(unsigned __int16 *)(v27 + 20);
    v275 = *(unsigned __int8 *)(v27 + 22);
    v1265 = v27;
    *(_QWORD *)(v27 + 48) = &off_1E6E33B40;
    *(_QWORD *)(v27 + 56) = v28;
    v276 = (_DWORD *)(v27 + 48);
    if (v273 == 2)
      v277 = 1;
    else
      v277 = 3;
    if (v273 == 4)
      v278 = 0;
    else
      v278 = v277;
    v1186 = v278;
    if (v275)
      v274 |= 0x80000000;
    v1180 = v274;
    *(_QWORD *)(v27 + 64) = v1282;
    *(_DWORD *)(v27 + 72) = v1283;
    *(_BYTE *)(v27 + 76) = v1222;
    *(_BYTE *)(v27 + 77) = v1240;
    *(_QWORD *)(v27 + 78) = v1280;
    *(_WORD *)(v27 + 86) = v1281;
    *(_DWORD *)(v27 + 88) = a1;
    *(_WORD *)(v27 + 92) = a2;
    v279 = operator new(0x68uLL);
    v279[1] = 0;
    v279[2] = 0;
    *v279 = &off_1E6E33B88;
    v279[3] = v28;
    *(_QWORD *)&buf[8] = *(_QWORD *)(v27 + 64);
    v280 = *(_QWORD *)&buf[8];
    *(_QWORD *)&buf[13] = *(_QWORD *)(v27 + 69);
    v281 = *(_QWORD *)&buf[13];
    v282 = v1280;
    *(_WORD *)&buf[22] = v1280;
    v283 = *(_DWORD *)(v27 + 80);
    v284 = v276[9];
    v279[4] = v280;
    *(_QWORD *)((char *)v279 + 37) = v281;
    *((_BYTE *)v279 + 45) = v1240;
    *((_WORD *)v279 + 23) = v282;
    *((_DWORD *)v279 + 12) = v283;
    *((_DWORD *)v279 + 13) = v284;
    v279[7] = 0;
    *((_DWORD *)v279 + 16) = 0;
    v279[11] = 0;
    v279[12] = 0;
    v279[10] = 0;
    bzero(v1290, 0x400uLL);
    v285 = fd_name(v28, v1290, 0x400uLL);
    MEMORY[0x1BCCB03B0](v279 + 10, v285);
    v286 = operator new();
    v1216 = v28;
    *(_QWORD *)buf = v28;
    buf[21] = v1240;
    *(_DWORD *)&buf[24] = v283;
    *(_DWORD *)&buf[28] = v284;
    v287 = vi_onefixedsize_disk_allocator::vi_onefixedsize_disk_allocator(v286, 20, 1040, (__int128 *)buf, (uint64_t)(v276 + 30));
    v288 = v279[7];
    v279[7] = v287;
    if (v288)
    {
      storage_array_Close(v288 + 8);
      v289 = *(const void **)(v288 + 4208);
      if (v289)
      {
        CFRelease(v289);
        *(_QWORD *)(v288 + 4208) = 0;
      }
      *(_OWORD *)(v288 + 4192) = 0u;
      MEMORY[0x1BCCB06A4](v288, 0x10A0C408BE2A288);
      v287 = v279[7];
    }
    v290 = _windowsResolvePtr(v287 + 40, 0x400uLL, *(_QWORD *)(v287 + 16));
    v291 = v290;
    if (v1240)
    {
      *(_QWORD *)v290 = 0x1015F1DA6;
      *(_DWORD *)(v290 + 8) = v283;
      v292 = 0xFFFFFFFFLL;
      *(_QWORD *)(v290 + 12) = 0xFFFFFFFFLL;
      LODWORD(v293) = *((_DWORD *)v279 + 16);
      goto LABEL_446;
    }
    if (*(_DWORD *)v290 == 23010726)
    {
      if (*(_DWORD *)(v290 + 4) != 1)
        goto LABEL_1862;
      v294 = (_QWORD *)v279[7];
      v295 = *__error();
      v296 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v296, OS_LOG_TYPE_DEFAULT))
      {
        v297 = v294[6];
        v298 = v294[7];
        v300 = v294[2];
        v299 = v294[3];
        *(_DWORD *)buf = 134219008;
        *(_QWORD *)&buf[4] = v294;
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = v297;
        *(_WORD *)&buf[22] = 2048;
        *(_QWORD *)&buf[24] = v298;
        v1285 = 2048;
        v1286 = v299;
        v1287 = 2048;
        v1288 = v300;
        _os_log_impl(&dword_1B8270000, v296, OS_LOG_TYPE_DEFAULT, "vi_onefixedsize_disk_allocator %p size: %llu, freeRegion: %llu, header: %llu, elemSize: %lu", buf, 0x34u);
      }
      *__error() = v295;
      v301 = (_QWORD *)v279[7];
      v302 = v301[2];
      v303 = v301[7] - v301[3];
      v293 = v303 / v302;
      if (v303 != v303 / v302 * v302)
        goto LABEL_1869;
      *((_DWORD *)v279 + 16) = v293;
      if (v301[3] != 1044)
        goto LABEL_1872;
      if (v301[2] != 1040)
        goto LABEL_1875;
      v292 = *(_QWORD *)(v291 + 12);
LABEL_446:
      *(_DWORD *)(v1265 + 160) = 0;
      v304 = (os_unfair_lock_s *)(v1265 + 160);
      *(_QWORD *)((char *)v279 + 68) = v292;
      *(_OWORD *)(v1265 + 112) = 0u;
      *(_QWORD *)(v1265 + 96) = v279 + 3;
      *(_QWORD *)(v1265 + 104) = v279;
      *(_OWORD *)(v1265 + 128) = 0u;
      *(_OWORD *)(v1265 + 144) = 0u;
      *(_WORD *)(v1265 + 168) = v1198;
      *(_WORD *)(v1265 + 170) = v1268;
      *(_DWORD *)(v1265 + 172) = v1192;
      *(_DWORD *)(v1265 + 176) = v1186;
      *(_DWORD *)(v1265 + 180) = v1180;
      *(_DWORD *)(v1265 + 184) = __valc;
      *(_QWORD *)(v1265 + 192) = v1210;
      *(_QWORD *)(v1265 + 200) = 0xFFFFFFFF00000000;
      *(_BYTE *)(v1265 + 208) = v1222;
      *(_DWORD *)(v1265 + 212) = 0;
      *(_DWORD *)(v1265 + 216) = 0;
      if ((_DWORD)v293)
      {
        *(_DWORD *)(v1265 + 212) = *(_DWORD *)(_windowsResolvePtr(v279[7] + 40, *(_QWORD *)(v279[7] + 24), 0x410uLL)
                                             + 1032);
        *(_DWORD *)(v1265 + 216) = *(_DWORD *)(_windowsResolvePtr(*(_QWORD *)(*(_QWORD *)(v1265 + 96) + 32) + 40, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v1265 + 96) + 32) + 24)+ *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v1265 + 96) + 32) + 16)* (*(_DWORD *)(*(_QWORD *)(v1265 + 96) + 40) - 1), 0x410uLL)+ 1032);
      }
      if (v28)
        v305 = *(_DWORD *)(v28 + 44);
      else
        v305 = -1;
      __vali = *(_DWORD *)(v1265 + 88);
      bzero(v1290, 0x400uLL);
      v306 = fcntl(v305, 50, v1290);
      if (v1290[0])
        v307 = v306 < 0;
      else
        v307 = 1;
      if (v307)
        v308 = 0;
      else
        v308 = v1290;
      v309 = strlen(v308);
      if (v309 > 0x7FFFFFFFFFFFFFF7)
        goto LABEL_1881;
      v310 = v309;
      memset(&__dst, 0, sizeof(__dst));
      v1204 = v305;
      if (v309 >= 0x17)
      {
        v312 = (v309 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v309 | 7) != 0x17)
          v312 = v309 | 7;
        v313 = v312 + 1;
        v311 = (std::string *)operator new(v312 + 1);
        __dst.__r_.__value_.__l.__size_ = v310;
        __dst.__r_.__value_.__r.__words[2] = v313 | 0x8000000000000000;
        __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v311;
      }
      else
      {
        *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v309;
        v311 = &__dst;
        if (!v309)
        {
LABEL_465:
          v311->__r_.__value_.__s.__data_[v310] = 0;
          v314 = SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
          if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v315 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
          else
            v315 = __dst.__r_.__value_.__l.__size_;
          v316 = v315 + 1;
          if (v315 + 1 > 0x7FFFFFFFFFFFFFF7)
            goto LABEL_1881;
          if (v316 >= 0x17)
          {
            v318 = (v316 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v316 | 7) != 0x17)
              v318 = v316 | 7;
            v319 = v318 + 1;
            v317 = operator new(v318 + 1);
            *(_QWORD *)&v1275[8] = v315 + 1;
            *(_QWORD *)&v1275[16] = v319 | 0x8000000000000000;
            *(_QWORD *)v1275 = v317;
          }
          else
          {
            memset(v1275, 0, 24);
            v317 = v1275;
            v1275[23] = v315 + 1;
            if (!v315)
              goto LABEL_479;
          }
          if (v314 >= 0)
            v320 = &__dst;
          else
            v320 = (std::string *)__dst.__r_.__value_.__r.__words[0];
          memmove(v317, v320, v315);
LABEL_479:
          *(_WORD *)&v317[v315] = 47;
          std::to_string(&v1289, __vali);
          if ((v1289.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v321 = &v1289;
          else
            v321 = (std::string *)v1289.__r_.__value_.__r.__words[0];
          if ((v1289.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v322 = HIBYTE(v1289.__r_.__value_.__r.__words[2]);
          else
            v322 = v1289.__r_.__value_.__l.__size_;
          v323 = std::string::append((std::string *)v1275, (const std::string::value_type *)v321, v322);
          v324 = v323->__r_.__value_.__r.__words[2];
          *(_OWORD *)v1276 = *(_OWORD *)&v323->__r_.__value_.__l.__data_;
          *(_QWORD *)&v1276[16] = v324;
          v323->__r_.__value_.__l.__size_ = 0;
          v323->__r_.__value_.__r.__words[2] = 0;
          v323->__r_.__value_.__r.__words[0] = 0;
          v325 = std::string::append((std::string *)v1276, "-");
          v326 = v325->__r_.__value_.__r.__words[2];
          *(_OWORD *)buf = *(_OWORD *)&v325->__r_.__value_.__l.__data_;
          *(_QWORD *)&buf[16] = v326;
          v325->__r_.__value_.__l.__size_ = 0;
          v325->__r_.__value_.__r.__words[2] = 0;
          v325->__r_.__value_.__r.__words[0] = 0;
          std::to_string(&v1278, v1249);
          if ((v1278.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v327 = &v1278;
          else
            v327 = (std::string *)v1278.__r_.__value_.__r.__words[0];
          if ((v1278.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v328 = HIBYTE(v1278.__r_.__value_.__r.__words[2]);
          else
            v328 = v1278.__r_.__value_.__l.__size_;
          v329 = std::string::append((std::string *)buf, (const std::string::value_type *)v327, v328);
          v1279 = *v329;
          v329->__r_.__value_.__r.__words[0] = 0;
          v329->__r_.__value_.__l.__size_ = 0;
          v329->__r_.__value_.__r.__words[2] = 0;
          if (SHIBYTE(v1278.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(v1278.__r_.__value_.__l.__data_);
            if ((buf[23] & 0x80000000) == 0)
            {
LABEL_493:
              if ((v1276[23] & 0x80000000) == 0)
                goto LABEL_494;
              goto LABEL_508;
            }
          }
          else if ((buf[23] & 0x80000000) == 0)
          {
            goto LABEL_493;
          }
          operator delete(*(void **)buf);
          if ((v1276[23] & 0x80000000) == 0)
          {
LABEL_494:
            if ((SHIBYTE(v1289.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              goto LABEL_495;
            goto LABEL_509;
          }
LABEL_508:
          operator delete(*(void **)v1276);
          if ((SHIBYTE(v1289.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
LABEL_495:
            if ((v1275[23] & 0x80000000) == 0)
              goto LABEL_496;
LABEL_510:
            operator delete(*(void **)v1275);
LABEL_496:
            v330 = atomic_load((unsigned __int8 *)&_ZGVZN16QuantizerManagerIDF16_Li512EE14sharedInstanceEijtE8managers);
            if ((v330 & 1) == 0
              && __cxa_guard_acquire(&_ZGVZN16QuantizerManagerIDF16_Li512EE14sharedInstanceEijtE8managers))
            {
              _ZZN16QuantizerManagerIDF16_Li512EE14sharedInstanceEijtE8managers = 0u;
              *(_OWORD *)&qword_1EF1AD230 = 0u;
              dword_1EF1AD240 = 1065353216;
              __cxa_atexit((void (*)(void *))_ZNSt3__113unordered_mapINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEENS_8weak_ptrI16QuantizerManagerIDF16_Li512EEEENS_4hashIS6_EENS_8equal_toIS6_EENS4_INS_4pairIKS6_SA_EEEEED1B8nn180100Ev, &_ZZN16QuantizerManagerIDF16_Li512EE14sharedInstanceEijtE8managers, &dword_1B8270000);
              __cxa_guard_release(&_ZGVZN16QuantizerManagerIDF16_Li512EE14sharedInstanceEijtE8managers);
            }
            os_unfair_lock_lock((os_unfair_lock_t)&_ZZN16QuantizerManagerIDF16_Li512EE14sharedInstanceEijtE4lock);
            if ((v1279.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v331 = &v1279;
            else
              v331 = (std::string *)v1279.__r_.__value_.__r.__words[0];
            if ((v1279.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v332 = HIBYTE(v1279.__r_.__value_.__r.__words[2]);
            else
              v332 = v1279.__r_.__value_.__l.__size_;
            v333 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t *)v331, v332);
            v334 = *((_QWORD *)&_ZZN16QuantizerManagerIDF16_Li512EE14sharedInstanceEijtE8managers + 1);
            if (!*((_QWORD *)&_ZZN16QuantizerManagerIDF16_Li512EE14sharedInstanceEijtE8managers + 1))
              goto LABEL_1004;
            v335 = v333;
            v336 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&_ZZN16QuantizerManagerIDF16_Li512EE14sharedInstanceEijtE8managers
                                                  + 8));
            v336.i16[0] = vaddlv_u8(v336);
            if (v336.u32[0] > 1uLL)
            {
              v337 = v333;
              if (v333 >= *((_QWORD *)&_ZZN16QuantizerManagerIDF16_Li512EE14sharedInstanceEijtE8managers + 1))
                v337 = v333 % *((_QWORD *)&_ZZN16QuantizerManagerIDF16_Li512EE14sharedInstanceEijtE8managers + 1);
            }
            else
            {
              v337 = (*((_QWORD *)&_ZZN16QuantizerManagerIDF16_Li512EE14sharedInstanceEijtE8managers + 1) - 1) & v333;
            }
            v338 = *(uint64_t ***)(_ZZN16QuantizerManagerIDF16_Li512EE14sharedInstanceEijtE8managers + 8 * v337);
            if (!v338)
              goto LABEL_1004;
            v339 = *v338;
            if (!*v338)
              goto LABEL_1004;
            if (v336.u32[0] < 2uLL)
            {
              v340 = *((_QWORD *)&_ZZN16QuantizerManagerIDF16_Li512EE14sharedInstanceEijtE8managers + 1) - 1;
              while (1)
              {
                v346 = v339[1];
                if (v346 == v335)
                {
                  v347 = *((unsigned __int8 *)v339 + 39);
                  if ((v347 & 0x80u) == 0)
                    v348 = *((unsigned __int8 *)v339 + 39);
                  else
                    v348 = v339[3];
                  if (v348 == v332)
                  {
                    if ((v347 & 0x80) != 0)
                    {
                      if (!memcmp((const void *)v339[2], v331, v339[3]))
                        goto LABEL_1000;
                    }
                    else
                    {
                      if (!*((_BYTE *)v339 + 39))
                        goto LABEL_1000;
                      v349 = 0;
                      while (*((unsigned __int8 *)v339 + v349 + 16) == v331->__r_.__value_.__s.__data_[v349])
                      {
                        if (v347 == ++v349)
                          goto LABEL_999;
                      }
                    }
                  }
                }
                else if ((v346 & v340) != v337)
                {
                  goto LABEL_1004;
                }
                v341 = 0;
                v339 = (uint64_t *)*v339;
                if (!v339)
                  goto LABEL_1005;
              }
            }
            while (1)
            {
              v342 = v339[1];
              if (v342 == v335)
              {
                v343 = *((unsigned __int8 *)v339 + 39);
                if ((v343 & 0x80u) == 0)
                  v344 = *((unsigned __int8 *)v339 + 39);
                else
                  v344 = v339[3];
                if (v344 == v332)
                {
                  if ((v343 & 0x80) == 0)
                  {
                    if (!*((_BYTE *)v339 + 39))
                      goto LABEL_1000;
                    v345 = 0;
                    do
                    {
                      if (*((unsigned __int8 *)v339 + v345 + 16) != v331->__r_.__value_.__s.__data_[v345])
                        goto LABEL_518;
                      ++v345;
                    }
                    while (v343 != v345);
LABEL_999:
                    if (v339)
                    {
LABEL_1000:
                      v615 = _ZNSt3__112__hash_tableINS_17__hash_value_typeINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEENS_8weak_ptrI16QuantizerManagerIDF16_Li512EEEEEENS_22__unordered_map_hasherIS7_SC_NS_4hashIS7_EENS_8equal_toIS7_EELb1EEENS_21__unordered_map_equalIS7_SC_SH_SF_Lb1EEENS5_ISC_EEE25__emplace_unique_key_argsIS7_JRKNS_21piecewise_construct_tENS_5tupleIJRKS7_EEENSR_IJEEEEEENS_4pairINS_15__hash_iteratorIPNS_11__hash_nodeISC_PvEEEEbEERKT_DpOT0_((uint64_t)&v1279, (uint64_t)&v1279);
                      v616 = (std::__shared_weak_count *)*((_QWORD *)v615 + 6);
                      if (v616)
                      {
                        v617 = std::__shared_weak_count::lock(v616);
                        v341 = v617;
                        if (v617 && *((_QWORD *)v615 + 5))
                        {
                          *(_QWORD *)&v618 = *((_QWORD *)v615 + 5);
                          *((_QWORD *)&v618 + 1) = v617;
                          v1253 = v618;
                          v508 = v1265;
                          v619 = (uint64_t *)(v1265 + 112);
                          v620 = v1216;
                          goto LABEL_1045;
                        }
LABEL_1005:
                        v621 = operator new();
                        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
                          std::string::__init_copy_ctor_external(&v1289, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
                        else
                          v1289 = __dst;
                        *(_DWORD *)v621 = v1204;
                        *(_DWORD *)(v621 + 4) = __vali;
                        *(_WORD *)(v621 + 8) = v1249;
                        v622 = (std::string *)(v621 + 24);
                        if (SHIBYTE(v1289.__r_.__value_.__r.__words[2]) < 0)
                        {
                          std::string::__init_copy_ctor_external(v622, v1289.__r_.__value_.__l.__data_, v1289.__r_.__value_.__l.__size_);
                        }
                        else
                        {
                          *(_OWORD *)&v622->__r_.__value_.__l.__data_ = *(_OWORD *)&v1289.__r_.__value_.__l.__data_;
                          *(_QWORD *)(v621 + 40) = *((_QWORD *)&v1289.__r_.__value_.__l + 2);
                        }
                        IVFIndexName(v621 + 48, __vali, v1249, 1, 1);
                        *(_OWORD *)(v621 + 112) = 0u;
                        *(_OWORD *)(v621 + 128) = 0u;
                        *(_OWORD *)(v621 + 80) = 0u;
                        *(_OWORD *)(v621 + 96) = 0u;
                        *(_DWORD *)(v621 + 144) = 1065353216;
                        v623 = *__error();
                        v624 = _SILogForLogForCategory(16);
                        if (os_log_type_enabled(v624, OS_LOG_TYPE_DEFAULT))
                        {
                          v625 = &v1289;
                          if ((v1289.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
                            v625 = (std::string *)v1289.__r_.__value_.__r.__words[0];
                          if (*(char *)(v621 + 71) < 0)
                            v626 = *(_QWORD *)(v621 + 48);
                          else
                            v626 = v621 + 48;
                          *(_DWORD *)buf = 136315394;
                          *(_QWORD *)&buf[4] = v625;
                          *(_WORD *)&buf[12] = 2080;
                          *(_QWORD *)&buf[14] = v626;
                          _os_log_impl(&dword_1B8270000, v624, OS_LOG_TYPE_DEFAULT, "QuantizerManager %s/%s created", buf, 0x16u);
                        }
                        *__error() = v623;
                        v1275[23] = 20;
                        strcpy(v1275, "com.apple.spotlight.");
                        v627 = *(char *)(v621 + 71);
                        if (v627 >= 0)
                          v628 = (const std::string::value_type *)(v621 + 48);
                        else
                          v628 = *(const std::string::value_type **)(v621 + 48);
                        if (v627 >= 0)
                          v629 = *(unsigned __int8 *)(v621 + 71);
                        else
                          v629 = *(_QWORD *)(v621 + 56);
                        v630 = std::string::append((std::string *)v1275, v628, v629);
                        v631 = v630->__r_.__value_.__r.__words[2];
                        *(_OWORD *)v1276 = *(_OWORD *)&v630->__r_.__value_.__l.__data_;
                        *(_QWORD *)&v1276[16] = v631;
                        v630->__r_.__value_.__l.__size_ = 0;
                        v630->__r_.__value_.__r.__words[2] = 0;
                        v630->__r_.__value_.__r.__words[0] = 0;
                        v632 = std::string::append((std::string *)v1276, ".quantizerManager");
                        v633 = v632->__r_.__value_.__r.__words[2];
                        *(_OWORD *)buf = *(_OWORD *)&v632->__r_.__value_.__l.__data_;
                        *(_QWORD *)&buf[16] = v633;
                        v632->__r_.__value_.__l.__size_ = 0;
                        v632->__r_.__value_.__r.__words[2] = 0;
                        v632->__r_.__value_.__r.__words[0] = 0;
                        if ((v1276[23] & 0x80000000) != 0)
                          operator delete(*(void **)v1276);
                        if ((v1275[23] & 0x80000000) != 0)
                          operator delete(*(void **)v1275);
                        if (buf[23] >= 0)
                          v634 = buf;
                        else
                          v634 = *(const char **)buf;
                        *(_QWORD *)(v621 + 16) = dispatch_queue_create(v634, 0);
                        atomic_store(0, (unsigned __int8 *)(v621 + 72));
                        if ((buf[23] & 0x80000000) != 0)
                          operator delete(*(void **)buf);
                        v635 = (_QWORD *)operator new();
                        *v635 = &off_1E6E33BC0;
                        v635[1] = 0;
                        v635[2] = 0;
                        v635[3] = v621;
                        if (v341)
                        {
                          v636 = (unint64_t *)&v341->__shared_owners_;
                          do
                            v637 = __ldaxr(v636);
                          while (__stlxr(v637 - 1, v636));
                          if (!v637)
                          {
                            ((void (*)(std::__shared_weak_count *))v341->__on_zero_shared)(v341);
                            std::__shared_weak_count::__release_weak(v341);
                          }
                        }
                        *(_QWORD *)&v638 = v621;
                        if (SHIBYTE(v1289.__r_.__value_.__r.__words[2]) < 0)
                        {
                          operator delete(v1289.__r_.__value_.__l.__data_);
                          *(_QWORD *)&v638 = v621;
                        }
                        *((_QWORD *)&v638 + 1) = v635;
                        v1253 = v638;
                        v639 = v635 + 2;
                        v508 = v1265;
                        v619 = (uint64_t *)(v1265 + 112);
                        do
                          v640 = __ldxr(v639);
                        while (__stxr(v640 + 1, v639));
                        v641 = _ZNSt3__112__hash_tableINS_17__hash_value_typeINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEENS_8weak_ptrI16QuantizerManagerIDF16_Li512EEEEEENS_22__unordered_map_hasherIS7_SC_NS_4hashIS7_EENS_8equal_toIS7_EELb1EEENS_21__unordered_map_equalIS7_SC_SH_SF_Lb1EEENS5_ISC_EEE25__emplace_unique_key_argsIS7_JRKNS_21piecewise_construct_tENS_5tupleIJRKS7_EEENSR_IJEEEEEENS_4pairINS_15__hash_iteratorIPNS_11__hash_nodeISC_PvEEEEbEERKT_DpOT0_((uint64_t)&v1279, (uint64_t)&v1279);
                        v642 = (std::__shared_weak_count *)*((_QWORD *)v641 + 6);
                        *((_QWORD *)v641 + 5) = v621;
                        *((_QWORD *)v641 + 6) = v635;
                        if (v642)
                          std::__shared_weak_count::__release_weak(v642);
                        v620 = v1216;
LABEL_1045:
                        os_unfair_lock_unlock((os_unfair_lock_t)&_ZZN16QuantizerManagerIDF16_Li512EE14sharedInstanceEijtE4lock);
                        if (SHIBYTE(v1279.__r_.__value_.__r.__words[2]) < 0)
                          operator delete(v1279.__r_.__value_.__l.__data_);
                        v643 = v1253;
                        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
                        {
                          operator delete(__dst.__r_.__value_.__l.__data_);
                          v643 = v1253;
                        }
                        v644 = *(std::__shared_weak_count **)(v508 + 120);
                        *(_OWORD *)(v508 + 112) = v643;
                        if (v644)
                        {
                          v645 = (unint64_t *)&v644->__shared_owners_;
                          do
                            v646 = __ldaxr(v645);
                          while (__stlxr(v646 - 1, v645));
                          if (!v646)
                          {
                            ((void (*)(std::__shared_weak_count *))v644->__on_zero_shared)(v644);
                            std::__shared_weak_count::__release_weak(v644);
                          }
                        }
                        if (v1240)
                        {
                          _ZN16QuantizerManagerIDF16_Li512EE15sharedQuantizerEi(v1290, *v619, 0);
                          IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::replaceQuantizer((uint64_t)v276, (uint64_t *)v1290);
                          v537 = *(std::__shared_weak_count **)&v1290[8];
                          if (*(_QWORD *)&v1290[8])
                          {
                            v647 = (unint64_t *)(*(_QWORD *)&v1290[8] + 8);
                            do
                              v539 = __ldaxr(v647);
                            while (__stlxr(v539 - 1, v647));
                            goto LABEL_1772;
                          }
                          return v508;
                        }
                        memset(buf, 0, sizeof(buf));
                        *(_QWORD *)v1276 = v620;
                        *(_QWORD *)&v1276[8] = v1282;
                        *(_DWORD *)&v1276[16] = v1283;
                        *(_WORD *)&v1276[20] = v1222;
                        *(_QWORD *)&v1276[22] = v1280;
                        v1277 = v1281;
                        *((_BYTE *)&v1279.__r_.__value_.__s + 23) = 11;
                        strcpy((char *)&v1279, ".partitions");
                        IVFVectorIndexTemplate<float,768>::childMetaInfo((uint64_t)buf, (uint64_t)v1276, (uint64_t)&v1279, 0);
                        if (SHIBYTE(v1279.__r_.__value_.__r.__words[2]) < 0)
                          operator delete(v1279.__r_.__value_.__l.__data_);
                        *(_OWORD *)&v1278.__r_.__value_.__l.__data_ = 0uLL;
                        *(_OWORD *)v1275 = *(_OWORD *)buf;
                        *(_OWORD *)&v1275[16] = *(_OWORD *)&buf[16];
                        PartitionStore<vi_onefixedsize_disk_allocator,512>::openPartitionStore<vi_onefixedsize_disk_allocator>((std::__shared_weak_count **)&v1278, (uint64_t)v1275);
                        v648 = (_DWORD *)v1278.__r_.__value_.__r.__words[0];
                        if (v1278.__r_.__value_.__r.__words[0])
                        {
                          v649 = *(_DWORD *)(v1278.__r_.__value_.__r.__words[0] + 76);
                          v650 = v1278.__r_.__value_.__r.__words[0];
                        }
                        else
                        {
                          v650 = 0;
                          v649 = 0;
                        }
                        v1273 = 0;
                        v1274 = 0;
                        _ZN16QuantizerManagerIDF16_Li512EE15sharedQuantizerEi(&v1273, *v619, v649);
                        if (v650)
                        {
                          v750 = *(_DWORD *)(v650 + 76);
                          v751 = v1273;
                          if (v750 == (*(unsigned int (**)(char *))(*(_QWORD *)v1273 + 16))(v1273))
                          {
                            if (v648[18] == *(_DWORD *)(*(_QWORD *)(v508 + 96) + 40))
                            {
                              v752 = v1274;
                              if (v1274)
                              {
                                v753 = (unint64_t *)&v1274->__shared_owners_;
                                do
                                  v754 = __ldxr(v753);
                                while (__stxr(v754 + 1, v753));
                                AnyPartitionStore::replaceQuantizer((uint64_t)v648, (uint64_t)v751, (uint64_t)v752);
                                v755 = (unint64_t *)&v752->__shared_owners_;
                                do
                                  v756 = __ldaxr(v755);
                                while (__stlxr(v756 - 1, v755));
                                if (!v756)
                                {
                                  ((void (*)(std::__shared_weak_count *))v752->__on_zero_shared)(v752);
                                  std::__shared_weak_count::__release_weak(v752);
                                }
                                *(_QWORD *)v1290 = v1273;
                                *(_QWORD *)&v1290[8] = v1274;
                                if (v1274)
                                {
                                  v757 = (unint64_t *)&v1274->__shared_owners_;
                                  do
                                    v758 = __ldxr(v757);
                                  while (__stxr(v758 + 1, v757));
                                }
                              }
                              else
                              {
                                AnyPartitionStore::replaceQuantizer((uint64_t)v648, (uint64_t)v751, 0);
                                *(_QWORD *)v1290 = v1273;
                                *(_QWORD *)&v1290[8] = 0;
                              }
                              *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = *(_OWORD *)&v1278.__r_.__value_.__l.__data_;
                              if (v1278.__r_.__value_.__l.__size_)
                              {
                                v1138 = (unint64_t *)(v1278.__r_.__value_.__l.__size_ + 8);
                                do
                                  v1139 = __ldxr(v1138);
                                while (__stxr(v1139 + 1, v1138));
                              }
                              (*(void (**)(_DWORD *, _BYTE *, std::string *))(*(_QWORD *)v276 + 48))(v276, v1290, &__dst);
                              v1140 = (std::__shared_weak_count *)__dst.__r_.__value_.__l.__size_;
                              if (__dst.__r_.__value_.__l.__size_)
                              {
                                v1141 = (unint64_t *)(__dst.__r_.__value_.__l.__size_ + 8);
                                do
                                  v1142 = __ldaxr(v1141);
                                while (__stlxr(v1142 - 1, v1141));
                                if (!v1142)
                                {
                                  ((void (*)(std::__shared_weak_count *))v1140->__on_zero_shared)(v1140);
                                  std::__shared_weak_count::__release_weak(v1140);
                                }
                              }
                              v1143 = *(std::__shared_weak_count **)&v1290[8];
                              if (*(_QWORD *)&v1290[8])
                              {
                                v1144 = (unint64_t *)(*(_QWORD *)&v1290[8] + 8);
                                do
                                  v1145 = __ldaxr(v1144);
                                while (__stlxr(v1145 - 1, v1144));
                                if (!v1145)
                                {
                                  ((void (*)(std::__shared_weak_count *))v1143->__on_zero_shared)(v1143);
                                  std::__shared_weak_count::__release_weak(v1143);
                                }
                              }
                              goto LABEL_1654;
                            }
LABEL_1363:
                            v837 = *__error();
                            v838 = _SILogForLogForCategory(16);
                            v839 = dword_1EF19FCCC < 3;
                            if (os_log_type_enabled(v838, (os_log_type_t)(dword_1EF19FCCC < 3)))
                            {
                              v1259 = v837;
                              (*(void (**)(std::string *__return_ptr, _DWORD *))(*(_QWORD *)v648 + 144))(&__dst, v648);
                              if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                                v840 = &__dst;
                              else
                                v840 = (std::string *)__dst.__r_.__value_.__r.__words[0];
                              v841 = v648[19];
                              v1246 = v648[18];
                              v842 = v751 + 8;
                              if (v751[31] < 0)
                                v842 = (_QWORD *)*v842;
                              v843 = (*(uint64_t (**)(char *))(*(_QWORD *)v751 + 16))(v751);
                              v844 = *(_DWORD *)(*(_QWORD *)(v1265 + 96) + 40);
                              *(_DWORD *)v1290 = 136316418;
                              *(_QWORD *)&v1290[4] = v840;
                              *(_WORD *)&v1290[12] = 1024;
                              *(_DWORD *)&v1290[14] = v841;
                              v1291 = 1024;
                              v1292 = v1246;
                              v1293 = 2080;
                              v1294 = v842;
                              v1295 = 1024;
                              v1296 = v843;
                              v1297 = 1024;
                              v1298 = v844;
                              _os_log_impl(&dword_1B8270000, v838, v839, "*warn* Rebuild! Partitions %s version: %d count: %u not match Quantizer %s version %d vectors count:%u.", v1290, 0x2Eu);
                              if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
                                operator delete(__dst.__r_.__value_.__l.__data_);
                              v508 = v1265;
                              v837 = v1259;
                            }
                            *__error() = v837;
                            *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = 0uLL;
                            __dst.__r_.__value_.__r.__words[2] = (std::string::size_type)v648;
                            v1272 = v1278.__r_.__value_.__l.__size_;
                            if (v1278.__r_.__value_.__l.__size_)
                            {
                              v845 = (unint64_t *)(v1278.__r_.__value_.__l.__size_ + 8);
                              do
                                v846 = __ldxr(v845);
                              while (__stxr(v846 + 1, v845));
                            }
                            os_unfair_lock_lock(v304);
                            std::swap[abi:nn180100]<IVFVectorIndexTemplate<float,768>::QuantizerPartitions>((__int128 *)(v1265 + 128), (__int128 *)&__dst);
                            os_unfair_lock_unlock(v304);
                            v847 = (std::__shared_weak_count *)v1272;
                            if (v1272)
                            {
                              v848 = (unint64_t *)(v1272 + 8);
                              do
                                v849 = __ldaxr(v848);
                              while (__stlxr(v849 - 1, v848));
                              if (!v849)
                              {
                                ((void (*)(std::__shared_weak_count *))v847->__on_zero_shared)(v847);
                                std::__shared_weak_count::__release_weak(v847);
                              }
                            }
                            v850 = (std::__shared_weak_count *)__dst.__r_.__value_.__l.__size_;
                            if (__dst.__r_.__value_.__l.__size_)
                            {
                              v851 = (unint64_t *)(__dst.__r_.__value_.__l.__size_ + 8);
                              do
                                v852 = __ldaxr(v851);
                              while (__stlxr(v852 - 1, v851));
                              if (!v852)
                              {
                                ((void (*)(std::__shared_weak_count *))v850->__on_zero_shared)(v850);
                                std::__shared_weak_count::__release_weak(v850);
                              }
                            }
LABEL_1619:
                            v1011 = v1274;
                            v1269 = v1273;
                            v1270 = v1274;
                            if (v1274)
                            {
                              v1012 = (unint64_t *)&v1274->__shared_owners_;
                              do
                                v1013 = __ldxr(v1012);
                              while (__stxr(v1013 + 1, v1012));
                              IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::replaceQuantizer((uint64_t)v276, (uint64_t *)&v1269);
                              do
                                v1014 = __ldaxr(v1012);
                              while (__stlxr(v1014 - 1, v1012));
                              if (!v1014)
                              {
                                ((void (*)(std::__shared_weak_count *))v1011->__on_zero_shared)(v1011);
                                std::__shared_weak_count::__release_weak(v1011);
                              }
                            }
                            else
                            {
                              IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::replaceQuantizer((uint64_t)v276, (uint64_t *)&v1269);
                            }
                            os_unfair_lock_lock(v304);
                            v1015 = *(std::__shared_weak_count **)(v508 + 136);
                            if (v1015)
                            {
                              v1016 = (unint64_t *)&v1015->__shared_owners_;
                              do
                                v1017 = __ldxr(v1016);
                              while (__stxr(v1017 + 1, v1016));
                            }
                            v1019 = *(_QWORD *)(v508 + 144);
                            v1018 = *(_QWORD *)(v508 + 152);
                            if (v1018)
                            {
                              v1020 = (unint64_t *)(v1018 + 8);
                              do
                                v1021 = __ldxr(v1020);
                              while (__stxr(v1021 + 1, v1020));
                            }
                            os_unfair_lock_unlock(v304);
                            v1022 = (std::__shared_weak_count *)v1278.__r_.__value_.__l.__size_;
                            v1278.__r_.__value_.__r.__words[0] = v1019;
                            v1278.__r_.__value_.__l.__size_ = v1018;
                            if (v1022)
                            {
                              v1023 = (unint64_t *)&v1022->__shared_owners_;
                              do
                                v1024 = __ldaxr(v1023);
                              while (__stlxr(v1024 - 1, v1023));
                              if (!v1024)
                              {
                                ((void (*)(std::__shared_weak_count *))v1022->__on_zero_shared)(v1022);
                                std::__shared_weak_count::__release_weak(v1022);
                              }
                            }
                            if (v1015)
                            {
                              v1025 = (unint64_t *)&v1015->__shared_owners_;
                              do
                                v1026 = __ldaxr(v1025);
                              while (__stlxr(v1026 - 1, v1025));
                              if (!v1026)
                              {
                                ((void (*)(std::__shared_weak_count *))v1015->__on_zero_shared)(v1015);
                                std::__shared_weak_count::__release_weak(v1015);
                              }
                            }
                            if (*(_BYTE *)(v508 + 208))
                              (*(void (**)(std::string::size_type))(*(_QWORD *)v1278.__r_.__value_.__l.__data_
                                                                             + 120))(v1278.__r_.__value_.__r.__words[0]);
                            v1027 = *__error();
                            v1028 = _SILogForLogForCategory(16);
                            if (os_log_type_enabled(v1028, OS_LOG_TYPE_DEFAULT))
                            {
                              v1029 = v1278.__r_.__value_.__r.__words[0];
                              (*(void (**)(std::string *__return_ptr, std::string::size_type))(*(_QWORD *)v1278.__r_.__value_.__l.__data_ + 144))(&v1289, v1278.__r_.__value_.__r.__words[0]);
                              if ((v1289.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                                v1030 = &v1289;
                              else
                                v1030 = (std::string *)v1289.__r_.__value_.__r.__words[0];
                              v1033 = v1029 + 72;
                              v1031 = *(_DWORD *)(v1029 + 72);
                              v1032 = *(_DWORD *)(v1033 + 4);
                              v1034 = v1273 + 8;
                              if (v1273[31] < 0)
                                v1034 = (_QWORD *)*v1034;
                              v1035 = (*(uint64_t (**)(void))(*(_QWORD *)v1273 + 16))();
                              v1036 = *(_DWORD *)(*(_QWORD *)(v508 + 96) + 40);
                              *(_DWORD *)v1290 = 136316418;
                              *(_QWORD *)&v1290[4] = v1030;
                              *(_WORD *)&v1290[12] = 1024;
                              *(_DWORD *)&v1290[14] = v1032;
                              v1291 = 1024;
                              v1292 = v1031;
                              v1293 = 2080;
                              v1294 = v1034;
                              v1295 = 1024;
                              v1296 = v1035;
                              v1297 = 1024;
                              v1298 = v1036;
                              _os_log_impl(&dword_1B8270000, v1028, OS_LOG_TYPE_DEFAULT, "Partitions rebuilt %s version: %d count: %u not match Quantizer %s version %d vectors count:%u.", v1290, 0x2Eu);
                              if (SHIBYTE(v1289.__r_.__value_.__r.__words[2]) < 0)
                                operator delete(v1289.__r_.__value_.__l.__data_);
                            }
                            *__error() = v1027;
LABEL_1654:
                            v1037 = v1274;
                            if (v1274)
                            {
                              v1038 = (unint64_t *)&v1274->__shared_owners_;
                              do
                                v1039 = __ldaxr(v1038);
                              while (__stlxr(v1039 - 1, v1038));
                              if (!v1039)
                              {
                                ((void (*)(std::__shared_weak_count *))v1037->__on_zero_shared)(v1037);
                                std::__shared_weak_count::__release_weak(v1037);
                              }
                            }
                            v537 = (std::__shared_weak_count *)v1278.__r_.__value_.__l.__size_;
                            if (v1278.__r_.__value_.__l.__size_)
                            {
                              v1040 = (unint64_t *)(v1278.__r_.__value_.__l.__size_ + 8);
                              do
                                v539 = __ldaxr(v1040);
                              while (__stlxr(v539 - 1, v1040));
                              goto LABEL_1772;
                            }
                            return v508;
                          }
                          if (v648)
                            goto LABEL_1363;
                        }
                        bzero(v1290, 0x400uLL);
                        memset(&__dst, 0, sizeof(__dst));
                        v853 = fd_name(v620, v1290, 0x400uLL);
                        v854 = strlen(v853);
                        if (v854 <= 0x7FFFFFFFFFFFFFF7)
                        {
                          v855 = v854;
                          if (v854 >= 0x17)
                          {
                            v1005 = (v854 & 0xFFFFFFFFFFFFFFF8) + 8;
                            if ((v854 | 7) != 0x17)
                              v1005 = v854 | 7;
                            v1006 = v1005 + 1;
                            v856 = (std::string *)operator new(v1005 + 1);
                            __dst.__r_.__value_.__l.__size_ = v855;
                            __dst.__r_.__value_.__r.__words[2] = v1006 | 0x8000000000000000;
                            __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v856;
                          }
                          else
                          {
                            *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v854;
                            v856 = &__dst;
                            if (!v854)
                              goto LABEL_1612;
                          }
                          memmove(v856, v853, v855);
LABEL_1612:
                          v856->__r_.__value_.__s.__data_[v855] = 0;
                          std::string::append(&__dst, ".partitions");
                          v1007 = *__error();
                          v1008 = _SILogForLogForCategory(16);
                          v1009 = dword_1EF19FCCC < 3;
                          if (os_log_type_enabled(v1008, (os_log_type_t)(dword_1EF19FCCC < 3)))
                          {
                            if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                              v1010 = &__dst;
                            else
                              v1010 = (std::string *)__dst.__r_.__value_.__r.__words[0];
                            LODWORD(v1289.__r_.__value_.__l.__data_) = 136315138;
                            *(std::string::size_type *)((char *)v1289.__r_.__value_.__r.__words + 4) = (std::string::size_type)v1010;
                            _os_log_impl(&dword_1B8270000, v1008, v1009, "*warn* Rebuild! Partitions %s currupted", (uint8_t *)&v1289, 0xCu);
                          }
                          *__error() = v1007;
                          if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
                            operator delete(__dst.__r_.__value_.__l.__data_);
                          goto LABEL_1619;
                        }
LABEL_1881:
                        abort();
                      }
                    }
LABEL_1004:
                    v341 = 0;
                    goto LABEL_1005;
                  }
                  if (!memcmp((const void *)v339[2], v331, v339[3]))
                    goto LABEL_1000;
                }
              }
              else
              {
                if (v342 >= v334)
                  v342 %= v334;
                if (v342 != v337)
                  goto LABEL_1004;
              }
LABEL_518:
              v341 = 0;
              v339 = (uint64_t *)*v339;
              if (!v339)
                goto LABEL_1005;
            }
          }
LABEL_509:
          operator delete(v1289.__r_.__value_.__l.__data_);
          if ((v1275[23] & 0x80000000) == 0)
            goto LABEL_496;
          goto LABEL_510;
        }
      }
      memcpy(v311, v308, v310);
      goto LABEL_465;
    }
LABEL_1859:
    v1162 = __si_assert_copy_extra_268();
    v1163 = v1162;
    v1164 = "";
    if (v1162)
      v1164 = v1162;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1675, "header->signature == 0x015F1DA6", v1164);
LABEL_1865:
    free(v1163);
    if (__valid_fs(-1))
      v1167 = 2989;
    else
      v1167 = 3072;
    *(_DWORD *)v1167 = -559038737;
    abort();
  }
  if (a3)
    goto LABEL_1882;
  v12 = operator new();
  v13 = *(_QWORD *)a5;
  v1282 = *(_QWORD *)(a5 + 8);
  v1283 = *(_DWORD *)(a5 + 16);
  v14 = *(_BYTE *)(a5 + 20);
  v1237 = *(unsigned __int8 *)(a5 + 21);
  v1280 = *(_QWORD *)(a5 + 22);
  v1281 = *(_WORD *)(a5 + 30);
  v1195 = *a6;
  v1219 = v14;
  __val = *((_DWORD *)a6 + 4);
  v1207 = *((_QWORD *)a6 + 3);
  *(_QWORD *)v12 = off_1E6E30C80;
  *(_DWORD *)(v12 + 8) = a1;
  *(_QWORD *)(v12 + 12) = 0x200000100;
  *(_WORD *)(v12 + 20) = a2;
  *(_BYTE *)(v12 + 22) = a7;
  IVFIndexName(v12 + 24, a1, a2, 0, 1);
  *(_QWORD *)v12 = off_1E6E33480;
  v15 = *(_DWORD *)(v12 + 12);
  if (v15 == 256)
  {
    v1189 = 0;
  }
  else
  {
    if (v15 == 768)
    {
      v16 = 2;
    }
    else if (v15 == 512)
    {
      v16 = 1;
    }
    else
    {
      v16 = 3;
    }
    v1189 = v16;
  }
  v42 = *(_DWORD *)(v12 + 16);
  v43 = *(unsigned __int16 *)(v12 + 20);
  v44 = *(unsigned __int8 *)(v12 + 22);
  v1262 = v12;
  *(_QWORD *)(v12 + 48) = &off_1E6E335D8;
  *(_QWORD *)(v12 + 56) = v13;
  v45 = (_DWORD *)(v12 + 48);
  if (v42 == 2)
    v46 = 1;
  else
    v46 = 3;
  if (v42 == 4)
    v47 = 0;
  else
    v47 = v46;
  v1183 = v47;
  if (v44)
    v43 |= 0x80000000;
  v1177 = v43;
  *(_QWORD *)(v12 + 64) = v1282;
  *(_DWORD *)(v12 + 72) = v1283;
  *(_BYTE *)(v12 + 76) = v1219;
  *(_BYTE *)(v12 + 77) = v1237;
  *(_QWORD *)(v12 + 78) = v1280;
  *(_WORD *)(v12 + 86) = v1281;
  *(_DWORD *)(v12 + 88) = a1;
  *(_WORD *)(v12 + 92) = a2;
  v48 = operator new(0x68uLL);
  v48[1] = 0;
  v48[2] = 0;
  *v48 = &off_1E6E33620;
  v48[3] = v13;
  *(_QWORD *)&buf[8] = *(_QWORD *)(v12 + 64);
  v49 = *(_QWORD *)&buf[8];
  *(_QWORD *)&buf[13] = *(_QWORD *)(v12 + 69);
  v50 = *(_QWORD *)&buf[13];
  v51 = v1280;
  *(_WORD *)&buf[22] = v1280;
  v52 = *(_DWORD *)(v12 + 80);
  v53 = v45[9];
  v48[4] = v49;
  *(_QWORD *)((char *)v48 + 37) = v50;
  *((_BYTE *)v48 + 45) = v1237;
  *((_WORD *)v48 + 23) = v51;
  *((_DWORD *)v48 + 12) = v52;
  *((_DWORD *)v48 + 13) = v53;
  v48[7] = 0;
  *((_DWORD *)v48 + 16) = 0;
  v48[11] = 0;
  v48[12] = 0;
  v48[10] = 0;
  bzero(v1290, 0x400uLL);
  v54 = fd_name(v13, v1290, 0x400uLL);
  MEMORY[0x1BCCB03B0](v48 + 10, v54);
  v55 = operator new();
  v1213 = v13;
  *(_QWORD *)buf = v13;
  buf[21] = v1237;
  *(_DWORD *)&buf[24] = v52;
  *(_DWORD *)&buf[28] = v53;
  v56 = vi_onefixedsize_disk_allocator::vi_onefixedsize_disk_allocator(v55, 20, 528, (__int128 *)buf, (uint64_t)(v45 + 30));
  v57 = v48[7];
  v48[7] = v56;
  if (v57)
  {
    storage_array_Close(v57 + 8);
    v58 = *(const void **)(v57 + 4208);
    if (v58)
    {
      CFRelease(v58);
      *(_QWORD *)(v57 + 4208) = 0;
    }
    *(_OWORD *)(v57 + 4192) = 0u;
    MEMORY[0x1BCCB06A4](v57, 0x10A0C408BE2A288);
    v56 = v48[7];
  }
  v59 = _windowsResolvePtr(v56 + 40, 0x400uLL, *(_QWORD *)(v56 + 16));
  v60 = v59;
  if (v1237)
  {
    *(_QWORD *)v59 = 0x1015F1DA6;
    *(_DWORD *)(v59 + 8) = v52;
    v61 = 0xFFFFFFFFLL;
    *(_QWORD *)(v59 + 12) = 0xFFFFFFFFLL;
    LODWORD(v62) = *((_DWORD *)v48 + 16);
    goto LABEL_59;
  }
  if (*(_DWORD *)v59 != 23010726)
    goto LABEL_1859;
  if (*(_DWORD *)(v59 + 4) != 1)
  {
LABEL_1862:
    v1165 = __si_assert_copy_extra_268();
    v1163 = v1165;
    v1166 = "";
    if (v1165)
      v1166 = v1165;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1676, "header->index_version == 1", v1166);
    goto LABEL_1865;
  }
  v63 = (_QWORD *)v48[7];
  v64 = *__error();
  v65 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
  {
    v66 = v63[6];
    v67 = v63[7];
    v69 = v63[2];
    v68 = v63[3];
    *(_DWORD *)buf = 134219008;
    *(_QWORD *)&buf[4] = v63;
    *(_WORD *)&buf[12] = 2048;
    *(_QWORD *)&buf[14] = v66;
    *(_WORD *)&buf[22] = 2048;
    *(_QWORD *)&buf[24] = v67;
    v1285 = 2048;
    v1286 = v68;
    v1287 = 2048;
    v1288 = v69;
    _os_log_impl(&dword_1B8270000, v65, OS_LOG_TYPE_DEFAULT, "vi_onefixedsize_disk_allocator %p size: %llu, freeRegion: %llu, header: %llu, elemSize: %lu", buf, 0x34u);
  }
  *__error() = v64;
  v70 = (_QWORD *)v48[7];
  v71 = v70[2];
  v72 = v70[7] - v70[3];
  v62 = v72 / v71;
  if (v72 != v72 / v71 * v71)
  {
LABEL_1869:
    v1168 = __si_assert_copy_extra_268();
    v1169 = v1168;
    v1170 = "";
    if (v1168)
      v1170 = v1168;
    __message_assert("%s:%u: failed assertion '%s' %s ", "VectorIndexSupport.hh", 504, "offset % elemSize == 0", v1170);
    goto LABEL_1878;
  }
  *((_DWORD *)v48 + 16) = v62;
  if (v70[3] != 1044)
  {
LABEL_1872:
    v1171 = __si_assert_copy_extra_268();
    v1169 = v1171;
    v1172 = "";
    if (v1171)
      v1172 = v1171;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1679, "vi_onefixedsize_disk_allocator::getHeaderSize(storage.get()) == sizeof(VectorStoreHeader_s)", v1172);
    goto LABEL_1878;
  }
  if (v70[2] != 528)
  {
LABEL_1875:
    v1173 = __si_assert_copy_extra_268();
    v1169 = v1173;
    v1174 = "";
    if (v1173)
      v1174 = v1173;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1680, "vi_onefixedsize_disk_allocator::getElementSize(storage.get()) == sizeof(Entry)", v1174);
LABEL_1878:
    free(v1169);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    goto LABEL_1881;
  }
  v61 = *(_QWORD *)(v60 + 12);
LABEL_59:
  *(_DWORD *)(v1262 + 160) = 0;
  v73 = (os_unfair_lock_s *)(v1262 + 160);
  *(_QWORD *)((char *)v48 + 68) = v61;
  *(_OWORD *)(v1262 + 112) = 0u;
  *(_QWORD *)(v1262 + 96) = v48 + 3;
  *(_QWORD *)(v1262 + 104) = v48;
  *(_OWORD *)(v1262 + 128) = 0u;
  *(_OWORD *)(v1262 + 144) = 0u;
  *(_WORD *)(v1262 + 168) = v1195;
  *(_WORD *)(v1262 + 170) = v1268;
  *(_DWORD *)(v1262 + 172) = v1189;
  *(_DWORD *)(v1262 + 176) = v1183;
  *(_DWORD *)(v1262 + 180) = v1177;
  *(_DWORD *)(v1262 + 184) = __val;
  *(_QWORD *)(v1262 + 192) = v1207;
  *(_QWORD *)(v1262 + 200) = 0xFFFFFFFF00000000;
  *(_BYTE *)(v1262 + 208) = v1219;
  *(_DWORD *)(v1262 + 212) = 0;
  *(_DWORD *)(v1262 + 216) = 0;
  if ((_DWORD)v62)
  {
    *(_DWORD *)(v1262 + 212) = *(_DWORD *)(_windowsResolvePtr(v48[7] + 40, *(_QWORD *)(v48[7] + 24), 0x210uLL) + 520);
    *(_DWORD *)(v1262 + 216) = *(_DWORD *)(_windowsResolvePtr(*(_QWORD *)(*(_QWORD *)(v1262 + 96) + 32) + 40, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v1262 + 96) + 32) + 24)+ *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v1262 + 96) + 32) + 16)* (*(_DWORD *)(*(_QWORD *)(v1262 + 96) + 40) - 1), 0x210uLL)+ 520);
  }
  if (v13)
    v74 = *(_DWORD *)(v13 + 44);
  else
    v74 = -1;
  __valf = *(_DWORD *)(v1262 + 88);
  bzero(v1290, 0x400uLL);
  v75 = fcntl(v74, 50, v1290);
  if (v1290[0])
    v76 = v75 < 0;
  else
    v76 = 1;
  if (v76)
    v77 = 0;
  else
    v77 = v1290;
  v78 = strlen(v77);
  if (v78 > 0x7FFFFFFFFFFFFFF7)
    goto LABEL_1881;
  v79 = v78;
  memset(&__dst, 0, sizeof(__dst));
  v1201 = v74;
  if (v78 >= 0x17)
  {
    v81 = (v78 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v78 | 7) != 0x17)
      v81 = v78 | 7;
    v82 = v81 + 1;
    v80 = (std::string *)operator new(v81 + 1);
    __dst.__r_.__value_.__l.__size_ = v79;
    __dst.__r_.__value_.__r.__words[2] = v82 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v80;
    goto LABEL_77;
  }
  *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v78;
  v80 = &__dst;
  if (v78)
LABEL_77:
    memcpy(v80, v77, v79);
  v80->__r_.__value_.__s.__data_[v79] = 0;
  v83 = SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v84 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
  else
    v84 = __dst.__r_.__value_.__l.__size_;
  v85 = v84 + 1;
  if (v84 + 1 > 0x7FFFFFFFFFFFFFF7)
    goto LABEL_1881;
  if (v85 >= 0x17)
  {
    v87 = (v85 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v85 | 7) != 0x17)
      v87 = v85 | 7;
    v88 = v87 + 1;
    v86 = operator new(v87 + 1);
    *(_QWORD *)&v1275[8] = v84 + 1;
    *(_QWORD *)&v1275[16] = v88 | 0x8000000000000000;
    *(_QWORD *)v1275 = v86;
  }
  else
  {
    memset(v1275, 0, 24);
    v86 = v1275;
    v1275[23] = v84 + 1;
    if (!v84)
      goto LABEL_92;
  }
  if (v83 >= 0)
    v89 = &__dst;
  else
    v89 = (std::string *)__dst.__r_.__value_.__r.__words[0];
  memmove(v86, v89, v84);
LABEL_92:
  *(_WORD *)&v86[v84] = 47;
  std::to_string(&v1289, __valf);
  if ((v1289.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v90 = &v1289;
  else
    v90 = (std::string *)v1289.__r_.__value_.__r.__words[0];
  if ((v1289.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v91 = HIBYTE(v1289.__r_.__value_.__r.__words[2]);
  else
    v91 = v1289.__r_.__value_.__l.__size_;
  v92 = std::string::append((std::string *)v1275, (const std::string::value_type *)v90, v91);
  v93 = v92->__r_.__value_.__r.__words[2];
  *(_OWORD *)v1276 = *(_OWORD *)&v92->__r_.__value_.__l.__data_;
  *(_QWORD *)&v1276[16] = v93;
  v92->__r_.__value_.__l.__size_ = 0;
  v92->__r_.__value_.__r.__words[2] = 0;
  v92->__r_.__value_.__r.__words[0] = 0;
  v94 = std::string::append((std::string *)v1276, "-");
  v95 = v94->__r_.__value_.__r.__words[2];
  *(_OWORD *)buf = *(_OWORD *)&v94->__r_.__value_.__l.__data_;
  *(_QWORD *)&buf[16] = v95;
  v94->__r_.__value_.__l.__size_ = 0;
  v94->__r_.__value_.__r.__words[2] = 0;
  v94->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&v1278, v1249);
  if ((v1278.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v96 = &v1278;
  else
    v96 = (std::string *)v1278.__r_.__value_.__r.__words[0];
  if ((v1278.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v97 = HIBYTE(v1278.__r_.__value_.__r.__words[2]);
  else
    v97 = v1278.__r_.__value_.__l.__size_;
  v98 = std::string::append((std::string *)buf, (const std::string::value_type *)v96, v97);
  v1279 = *v98;
  v98->__r_.__value_.__r.__words[0] = 0;
  v98->__r_.__value_.__l.__size_ = 0;
  v98->__r_.__value_.__r.__words[2] = 0;
  if (SHIBYTE(v1278.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v1278.__r_.__value_.__l.__data_);
    if ((buf[23] & 0x80000000) == 0)
    {
LABEL_106:
      if ((v1276[23] & 0x80000000) == 0)
        goto LABEL_107;
      goto LABEL_121;
    }
  }
  else if ((buf[23] & 0x80000000) == 0)
  {
    goto LABEL_106;
  }
  operator delete(*(void **)buf);
  if ((v1276[23] & 0x80000000) == 0)
  {
LABEL_107:
    if ((SHIBYTE(v1289.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_108;
LABEL_122:
    operator delete(v1289.__r_.__value_.__l.__data_);
    if ((v1275[23] & 0x80000000) == 0)
      goto LABEL_109;
    goto LABEL_123;
  }
LABEL_121:
  operator delete(*(void **)v1276);
  if (SHIBYTE(v1289.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_122;
LABEL_108:
  if ((v1275[23] & 0x80000000) == 0)
    goto LABEL_109;
LABEL_123:
  operator delete(*(void **)v1275);
LABEL_109:
  v99 = atomic_load((unsigned __int8 *)&_ZGVZN16QuantizerManagerIDF16_Li256EE14sharedInstanceEijtE8managers);
  if ((v99 & 1) == 0 && __cxa_guard_acquire(&_ZGVZN16QuantizerManagerIDF16_Li256EE14sharedInstanceEijtE8managers))
  {
    _ZZN16QuantizerManagerIDF16_Li256EE14sharedInstanceEijtE8managers = 0u;
    *(_OWORD *)&qword_1EF1B0698 = 0u;
    dword_1EF1B06A8 = 1065353216;
    __cxa_atexit((void (*)(void *))_ZNSt3__113unordered_mapINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEENS_8weak_ptrI16QuantizerManagerIDF16_Li256EEEENS_4hashIS6_EENS_8equal_toIS6_EENS4_INS_4pairIKS6_SA_EEEEED1B8nn180100Ev, &_ZZN16QuantizerManagerIDF16_Li256EE14sharedInstanceEijtE8managers, &dword_1B8270000);
    __cxa_guard_release(&_ZGVZN16QuantizerManagerIDF16_Li256EE14sharedInstanceEijtE8managers);
  }
  os_unfair_lock_lock((os_unfair_lock_t)&_ZZN16QuantizerManagerIDF16_Li256EE14sharedInstanceEijtE4lock);
  if ((v1279.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v100 = &v1279;
  else
    v100 = (std::string *)v1279.__r_.__value_.__r.__words[0];
  if ((v1279.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v101 = HIBYTE(v1279.__r_.__value_.__r.__words[2]);
  else
    v101 = v1279.__r_.__value_.__l.__size_;
  v102 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t *)v100, v101);
  v103 = *((_QWORD *)&_ZZN16QuantizerManagerIDF16_Li256EE14sharedInstanceEijtE8managers + 1);
  if (!*((_QWORD *)&_ZZN16QuantizerManagerIDF16_Li256EE14sharedInstanceEijtE8managers + 1))
    goto LABEL_812;
  v104 = v102;
  v105 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&_ZZN16QuantizerManagerIDF16_Li256EE14sharedInstanceEijtE8managers + 8));
  v105.i16[0] = vaddlv_u8(v105);
  if (v105.u32[0] > 1uLL)
  {
    v106 = v102;
    if (v102 >= *((_QWORD *)&_ZZN16QuantizerManagerIDF16_Li256EE14sharedInstanceEijtE8managers + 1))
      v106 = v102 % *((_QWORD *)&_ZZN16QuantizerManagerIDF16_Li256EE14sharedInstanceEijtE8managers + 1);
  }
  else
  {
    v106 = (*((_QWORD *)&_ZZN16QuantizerManagerIDF16_Li256EE14sharedInstanceEijtE8managers + 1) - 1) & v102;
  }
  v107 = *(uint64_t ***)(_ZZN16QuantizerManagerIDF16_Li256EE14sharedInstanceEijtE8managers + 8 * v106);
  if (!v107)
    goto LABEL_812;
  v108 = *v107;
  if (!*v107)
    goto LABEL_812;
  if (v105.u32[0] < 2uLL)
  {
    v109 = *((_QWORD *)&_ZZN16QuantizerManagerIDF16_Li256EE14sharedInstanceEijtE8managers + 1) - 1;
    while (1)
    {
      v115 = v108[1];
      if (v115 == v104)
      {
        v116 = *((unsigned __int8 *)v108 + 39);
        if ((v116 & 0x80u) == 0)
          v117 = *((unsigned __int8 *)v108 + 39);
        else
          v117 = v108[3];
        if (v117 == v101)
        {
          if ((v116 & 0x80) != 0)
          {
            if (!memcmp((const void *)v108[2], v100, v108[3]))
              goto LABEL_808;
          }
          else
          {
            if (!*((_BYTE *)v108 + 39))
              goto LABEL_808;
            v118 = 0;
            while (*((unsigned __int8 *)v108 + v118 + 16) == v100->__r_.__value_.__s.__data_[v118])
            {
              if (v116 == ++v118)
                goto LABEL_807;
            }
          }
        }
      }
      else if ((v115 & v109) != v106)
      {
        goto LABEL_812;
      }
      v110 = 0;
      v108 = (uint64_t *)*v108;
      if (!v108)
        goto LABEL_813;
    }
  }
  while (1)
  {
    v111 = v108[1];
    if (v111 != v104)
    {
      if (v111 >= v103)
        v111 %= v103;
      if (v111 != v106)
        goto LABEL_812;
      goto LABEL_131;
    }
    v112 = *((unsigned __int8 *)v108 + 39);
    if ((v112 & 0x80u) == 0)
      v113 = *((unsigned __int8 *)v108 + 39);
    else
      v113 = v108[3];
    if (v113 != v101)
      goto LABEL_131;
    if ((v112 & 0x80) != 0)
      break;
    if (!*((_BYTE *)v108 + 39))
      goto LABEL_808;
    v114 = 0;
    while (*((unsigned __int8 *)v108 + v114 + 16) == v100->__r_.__value_.__s.__data_[v114])
    {
      if (v112 == ++v114)
      {
LABEL_807:
        if (!v108)
          goto LABEL_812;
        goto LABEL_808;
      }
    }
LABEL_131:
    v110 = 0;
    v108 = (uint64_t *)*v108;
    if (!v108)
      goto LABEL_813;
  }
  if (memcmp((const void *)v108[2], v100, v108[3]))
    goto LABEL_131;
LABEL_808:
  v504 = _ZNSt3__112__hash_tableINS_17__hash_value_typeINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEENS_8weak_ptrI16QuantizerManagerIDF16_Li256EEEEEENS_22__unordered_map_hasherIS7_SC_NS_4hashIS7_EENS_8equal_toIS7_EELb1EEENS_21__unordered_map_equalIS7_SC_SH_SF_Lb1EEENS5_ISC_EEE25__emplace_unique_key_argsIS7_JRKNS_21piecewise_construct_tENS_5tupleIJRKS7_EEENSR_IJEEEEEENS_4pairINS_15__hash_iteratorIPNS_11__hash_nodeISC_PvEEEEbEERKT_DpOT0_((uint64_t)&v1279, (uint64_t)&v1279);
  v505 = (std::__shared_weak_count *)*((_QWORD *)v504 + 6);
  if (!v505)
  {
LABEL_812:
    v110 = 0;
    goto LABEL_813;
  }
  v506 = std::__shared_weak_count::lock(v505);
  v110 = v506;
  if (v506 && *((_QWORD *)v504 + 5))
  {
    *(_QWORD *)&v507 = *((_QWORD *)v504 + 5);
    *((_QWORD *)&v507 + 1) = v506;
    v1250 = v507;
    v508 = v1262;
    v509 = (uint64_t *)(v1262 + 112);
    v510 = v1213;
    goto LABEL_853;
  }
LABEL_813:
  v511 = operator new();
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(&v1289, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
  else
    v1289 = __dst;
  *(_DWORD *)v511 = v1201;
  *(_DWORD *)(v511 + 4) = __valf;
  *(_WORD *)(v511 + 8) = v1249;
  v512 = (std::string *)(v511 + 24);
  if (SHIBYTE(v1289.__r_.__value_.__r.__words[2]) < 0)
  {
    std::string::__init_copy_ctor_external(v512, v1289.__r_.__value_.__l.__data_, v1289.__r_.__value_.__l.__size_);
  }
  else
  {
    *(_OWORD *)&v512->__r_.__value_.__l.__data_ = *(_OWORD *)&v1289.__r_.__value_.__l.__data_;
    *(_QWORD *)(v511 + 40) = *((_QWORD *)&v1289.__r_.__value_.__l + 2);
  }
  IVFIndexName(v511 + 48, __valf, v1249, 0, 1);
  *(_OWORD *)(v511 + 112) = 0u;
  *(_OWORD *)(v511 + 128) = 0u;
  *(_OWORD *)(v511 + 80) = 0u;
  *(_OWORD *)(v511 + 96) = 0u;
  *(_DWORD *)(v511 + 144) = 1065353216;
  v513 = *__error();
  v514 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v514, OS_LOG_TYPE_DEFAULT))
  {
    v515 = &v1289;
    if ((v1289.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      v515 = (std::string *)v1289.__r_.__value_.__r.__words[0];
    if (*(char *)(v511 + 71) < 0)
      v516 = *(_QWORD *)(v511 + 48);
    else
      v516 = v511 + 48;
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = v515;
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = v516;
    _os_log_impl(&dword_1B8270000, v514, OS_LOG_TYPE_DEFAULT, "QuantizerManager %s/%s created", buf, 0x16u);
  }
  *__error() = v513;
  v1275[23] = 20;
  strcpy(v1275, "com.apple.spotlight.");
  v517 = *(char *)(v511 + 71);
  if (v517 >= 0)
    v518 = (const std::string::value_type *)(v511 + 48);
  else
    v518 = *(const std::string::value_type **)(v511 + 48);
  if (v517 >= 0)
    v519 = *(unsigned __int8 *)(v511 + 71);
  else
    v519 = *(_QWORD *)(v511 + 56);
  v520 = std::string::append((std::string *)v1275, v518, v519);
  v521 = v520->__r_.__value_.__r.__words[2];
  *(_OWORD *)v1276 = *(_OWORD *)&v520->__r_.__value_.__l.__data_;
  *(_QWORD *)&v1276[16] = v521;
  v520->__r_.__value_.__l.__size_ = 0;
  v520->__r_.__value_.__r.__words[2] = 0;
  v520->__r_.__value_.__r.__words[0] = 0;
  v522 = std::string::append((std::string *)v1276, ".quantizerManager");
  v523 = v522->__r_.__value_.__r.__words[2];
  *(_OWORD *)buf = *(_OWORD *)&v522->__r_.__value_.__l.__data_;
  *(_QWORD *)&buf[16] = v523;
  v522->__r_.__value_.__l.__size_ = 0;
  v522->__r_.__value_.__r.__words[2] = 0;
  v522->__r_.__value_.__r.__words[0] = 0;
  if ((v1276[23] & 0x80000000) != 0)
    operator delete(*(void **)v1276);
  if ((v1275[23] & 0x80000000) != 0)
    operator delete(*(void **)v1275);
  if (buf[23] >= 0)
    v524 = buf;
  else
    v524 = *(const char **)buf;
  *(_QWORD *)(v511 + 16) = dispatch_queue_create(v524, 0);
  atomic_store(0, (unsigned __int8 *)(v511 + 72));
  if ((buf[23] & 0x80000000) != 0)
    operator delete(*(void **)buf);
  v525 = (_QWORD *)operator new();
  *v525 = &off_1E6E33658;
  v525[1] = 0;
  v525[2] = 0;
  v525[3] = v511;
  if (v110)
  {
    v526 = (unint64_t *)&v110->__shared_owners_;
    do
      v527 = __ldaxr(v526);
    while (__stlxr(v527 - 1, v526));
    if (!v527)
    {
      ((void (*)(std::__shared_weak_count *))v110->__on_zero_shared)(v110);
      std::__shared_weak_count::__release_weak(v110);
    }
  }
  *(_QWORD *)&v528 = v511;
  if (SHIBYTE(v1289.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v1289.__r_.__value_.__l.__data_);
    *(_QWORD *)&v528 = v511;
  }
  *((_QWORD *)&v528 + 1) = v525;
  v1250 = v528;
  v529 = v525 + 2;
  v508 = v1262;
  v509 = (uint64_t *)(v1262 + 112);
  do
    v530 = __ldxr(v529);
  while (__stxr(v530 + 1, v529));
  v531 = _ZNSt3__112__hash_tableINS_17__hash_value_typeINS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEENS_8weak_ptrI16QuantizerManagerIDF16_Li256EEEEEENS_22__unordered_map_hasherIS7_SC_NS_4hashIS7_EENS_8equal_toIS7_EELb1EEENS_21__unordered_map_equalIS7_SC_SH_SF_Lb1EEENS5_ISC_EEE25__emplace_unique_key_argsIS7_JRKNS_21piecewise_construct_tENS_5tupleIJRKS7_EEENSR_IJEEEEEENS_4pairINS_15__hash_iteratorIPNS_11__hash_nodeISC_PvEEEEbEERKT_DpOT0_((uint64_t)&v1279, (uint64_t)&v1279);
  v532 = (std::__shared_weak_count *)*((_QWORD *)v531 + 6);
  *((_QWORD *)v531 + 5) = v511;
  *((_QWORD *)v531 + 6) = v525;
  if (v532)
    std::__shared_weak_count::__release_weak(v532);
  v510 = v1213;
LABEL_853:
  os_unfair_lock_unlock((os_unfair_lock_t)&_ZZN16QuantizerManagerIDF16_Li256EE14sharedInstanceEijtE4lock);
  if (SHIBYTE(v1279.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v1279.__r_.__value_.__l.__data_);
  v533 = v1250;
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__dst.__r_.__value_.__l.__data_);
    v533 = v1250;
  }
  v534 = *(std::__shared_weak_count **)(v508 + 120);
  *(_OWORD *)(v508 + 112) = v533;
  if (v534)
  {
    v535 = (unint64_t *)&v534->__shared_owners_;
    do
      v536 = __ldaxr(v535);
    while (__stlxr(v536 - 1, v535));
    if (!v536)
    {
      ((void (*)(std::__shared_weak_count *))v534->__on_zero_shared)(v534);
      std::__shared_weak_count::__release_weak(v534);
    }
  }
  if (v1237)
  {
    _ZN16QuantizerManagerIDF16_Li256EE15sharedQuantizerEi(v1290, *v509, 0);
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::replaceQuantizer((uint64_t)v45, (uint64_t *)v1290);
    v537 = *(std::__shared_weak_count **)&v1290[8];
    if (*(_QWORD *)&v1290[8])
    {
      v538 = (unint64_t *)(*(_QWORD *)&v1290[8] + 8);
      do
        v539 = __ldaxr(v538);
      while (__stlxr(v539 - 1, v538));
LABEL_1772:
      if (!v539)
      {
        ((void (*)(std::__shared_weak_count *))v537->__on_zero_shared)(v537);
        std::__shared_weak_count::__release_weak(v537);
      }
    }
    return v508;
  }
  memset(buf, 0, sizeof(buf));
  *(_QWORD *)v1276 = v510;
  *(_QWORD *)&v1276[8] = v1282;
  *(_DWORD *)&v1276[16] = v1283;
  *(_WORD *)&v1276[20] = v1219;
  *(_QWORD *)&v1276[22] = v1280;
  v1277 = v1281;
  *((_BYTE *)&v1279.__r_.__value_.__s + 23) = 11;
  strcpy((char *)&v1279, ".partitions");
  IVFVectorIndexTemplate<float,768>::childMetaInfo((uint64_t)buf, (uint64_t)v1276, (uint64_t)&v1279, 0);
  if (SHIBYTE(v1279.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v1279.__r_.__value_.__l.__data_);
  *(_OWORD *)&v1278.__r_.__value_.__l.__data_ = 0uLL;
  *(_OWORD *)v1275 = *(_OWORD *)buf;
  *(_OWORD *)&v1275[16] = *(_OWORD *)&buf[16];
  PartitionStore<vi_onefixedsize_disk_allocator,512>::openPartitionStore<vi_onefixedsize_disk_allocator>((std::__shared_weak_count **)&v1278, (uint64_t)v1275);
  v540 = (_DWORD *)v1278.__r_.__value_.__r.__words[0];
  if (v1278.__r_.__value_.__r.__words[0])
  {
    v541 = *(_DWORD *)(v1278.__r_.__value_.__r.__words[0] + 76);
    v542 = v1278.__r_.__value_.__r.__words[0];
  }
  else
  {
    v542 = 0;
    v541 = 0;
  }
  v1273 = 0;
  v1274 = 0;
  _ZN16QuantizerManagerIDF16_Li256EE15sharedQuantizerEi(&v1273, *v509, v541);
  if (!v542)
  {
LABEL_1304:
    bzero(v1290, 0x400uLL);
    memset(&__dst, 0, sizeof(__dst));
    v793 = fd_name(v510, v1290, 0x400uLL);
    v794 = strlen(v793);
    if (v794 > 0x7FFFFFFFFFFFFFF7)
      goto LABEL_1881;
    v795 = v794;
    if (v794 >= 0x17)
    {
      v897 = (v794 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v794 | 7) != 0x17)
        v897 = v794 | 7;
      v898 = v897 + 1;
      v796 = (std::string *)operator new(v897 + 1);
      __dst.__r_.__value_.__l.__size_ = v795;
      __dst.__r_.__value_.__r.__words[2] = v898 | 0x8000000000000000;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v796;
    }
    else
    {
      *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v794;
      v796 = &__dst;
      if (!v794)
        goto LABEL_1447;
    }
    memmove(v796, v793, v795);
LABEL_1447:
    v796->__r_.__value_.__s.__data_[v795] = 0;
    std::string::append(&__dst, ".partitions");
    v899 = *__error();
    v900 = _SILogForLogForCategory(16);
    v901 = dword_1EF19FCCC < 3;
    if (os_log_type_enabled(v900, (os_log_type_t)(dword_1EF19FCCC < 3)))
    {
      if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v902 = &__dst;
      else
        v902 = (std::string *)__dst.__r_.__value_.__r.__words[0];
      LODWORD(v1289.__r_.__value_.__l.__data_) = 136315138;
      *(std::string::size_type *)((char *)v1289.__r_.__value_.__r.__words + 4) = (std::string::size_type)v902;
      _os_log_impl(&dword_1B8270000, v900, v901, "*warn* Rebuild! Partitions %s currupted", (uint8_t *)&v1289, 0xCu);
    }
    *__error() = v899;
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__dst.__r_.__value_.__l.__data_);
    goto LABEL_1454;
  }
  v723 = *(_DWORD *)(v542 + 76);
  v724 = v1273;
  if (v723 != (*(unsigned int (**)(char *))(*(_QWORD *)v1273 + 16))(v1273))
  {
    if (v540)
      goto LABEL_1282;
    goto LABEL_1304;
  }
  if (v540[18] == *(_DWORD *)(*(_QWORD *)(v508 + 96) + 40))
  {
    v725 = v1274;
    if (v1274)
    {
      v726 = (unint64_t *)&v1274->__shared_owners_;
      do
        v727 = __ldxr(v726);
      while (__stxr(v727 + 1, v726));
      AnyPartitionStore::replaceQuantizer((uint64_t)v540, (uint64_t)v724, (uint64_t)v725);
      v728 = (unint64_t *)&v725->__shared_owners_;
      do
        v729 = __ldaxr(v728);
      while (__stlxr(v729 - 1, v728));
      if (!v729)
      {
        ((void (*)(std::__shared_weak_count *))v725->__on_zero_shared)(v725);
        std::__shared_weak_count::__release_weak(v725);
      }
      *(_QWORD *)v1290 = v1273;
      *(_QWORD *)&v1290[8] = v1274;
      if (v1274)
      {
        v730 = (unint64_t *)&v1274->__shared_owners_;
        do
          v731 = __ldxr(v730);
        while (__stxr(v731 + 1, v730));
      }
    }
    else
    {
      AnyPartitionStore::replaceQuantizer((uint64_t)v540, (uint64_t)v724, 0);
      *(_QWORD *)v1290 = v1273;
      *(_QWORD *)&v1290[8] = 0;
    }
    *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = *(_OWORD *)&v1278.__r_.__value_.__l.__data_;
    if (v1278.__r_.__value_.__l.__size_)
    {
      v1114 = (unint64_t *)(v1278.__r_.__value_.__l.__size_ + 8);
      do
        v1115 = __ldxr(v1114);
      while (__stxr(v1115 + 1, v1114));
    }
    (*(void (**)(_DWORD *, _BYTE *, std::string *))(*(_QWORD *)v45 + 48))(v45, v1290, &__dst);
    v1116 = (std::__shared_weak_count *)__dst.__r_.__value_.__l.__size_;
    if (__dst.__r_.__value_.__l.__size_)
    {
      v1117 = (unint64_t *)(__dst.__r_.__value_.__l.__size_ + 8);
      do
        v1118 = __ldaxr(v1117);
      while (__stlxr(v1118 - 1, v1117));
      if (!v1118)
      {
        ((void (*)(std::__shared_weak_count *))v1116->__on_zero_shared)(v1116);
        std::__shared_weak_count::__release_weak(v1116);
      }
    }
    v1119 = *(std::__shared_weak_count **)&v1290[8];
    if (*(_QWORD *)&v1290[8])
    {
      v1120 = (unint64_t *)(*(_QWORD *)&v1290[8] + 8);
      do
        v1121 = __ldaxr(v1120);
      while (__stlxr(v1121 - 1, v1120));
      if (!v1121)
      {
        ((void (*)(std::__shared_weak_count *))v1119->__on_zero_shared)(v1119);
        std::__shared_weak_count::__release_weak(v1119);
      }
    }
    goto LABEL_1489;
  }
LABEL_1282:
  v777 = *__error();
  v778 = _SILogForLogForCategory(16);
  v779 = dword_1EF19FCCC < 3;
  if (os_log_type_enabled(v778, (os_log_type_t)(dword_1EF19FCCC < 3)))
  {
    v1256 = v777;
    (*(void (**)(std::string *__return_ptr, _DWORD *))(*(_QWORD *)v540 + 144))(&__dst, v540);
    if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v780 = &__dst;
    else
      v780 = (std::string *)__dst.__r_.__value_.__r.__words[0];
    v781 = v540[19];
    v1243 = v540[18];
    v782 = v724 + 8;
    if (v724[31] < 0)
      v782 = (_QWORD *)*v782;
    v783 = (*(uint64_t (**)(char *))(*(_QWORD *)v724 + 16))(v724);
    v784 = *(_DWORD *)(*(_QWORD *)(v1262 + 96) + 40);
    *(_DWORD *)v1290 = 136316418;
    *(_QWORD *)&v1290[4] = v780;
    *(_WORD *)&v1290[12] = 1024;
    *(_DWORD *)&v1290[14] = v781;
    v1291 = 1024;
    v1292 = v1243;
    v1293 = 2080;
    v1294 = v782;
    v1295 = 1024;
    v1296 = v783;
    v1297 = 1024;
    v1298 = v784;
    _os_log_impl(&dword_1B8270000, v778, v779, "*warn* Rebuild! Partitions %s version: %d count: %u not match Quantizer %s version %d vectors count:%u.", v1290, 0x2Eu);
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__dst.__r_.__value_.__l.__data_);
    v508 = v1262;
    v777 = v1256;
  }
  *__error() = v777;
  *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = 0uLL;
  __dst.__r_.__value_.__r.__words[2] = (std::string::size_type)v540;
  v1272 = v1278.__r_.__value_.__l.__size_;
  if (v1278.__r_.__value_.__l.__size_)
  {
    v785 = (unint64_t *)(v1278.__r_.__value_.__l.__size_ + 8);
    do
      v786 = __ldxr(v785);
    while (__stxr(v786 + 1, v785));
  }
  os_unfair_lock_lock(v73);
  std::swap[abi:nn180100]<IVFVectorIndexTemplate<float,768>::QuantizerPartitions>((__int128 *)(v1262 + 128), (__int128 *)&__dst);
  os_unfair_lock_unlock(v73);
  v787 = (std::__shared_weak_count *)v1272;
  if (v1272)
  {
    v788 = (unint64_t *)(v1272 + 8);
    do
      v789 = __ldaxr(v788);
    while (__stlxr(v789 - 1, v788));
    if (!v789)
    {
      ((void (*)(std::__shared_weak_count *))v787->__on_zero_shared)(v787);
      std::__shared_weak_count::__release_weak(v787);
    }
  }
  v790 = (std::__shared_weak_count *)__dst.__r_.__value_.__l.__size_;
  if (__dst.__r_.__value_.__l.__size_)
  {
    v791 = (unint64_t *)(__dst.__r_.__value_.__l.__size_ + 8);
    do
      v792 = __ldaxr(v791);
    while (__stlxr(v792 - 1, v791));
    if (!v792)
    {
      ((void (*)(std::__shared_weak_count *))v790->__on_zero_shared)(v790);
      std::__shared_weak_count::__release_weak(v790);
    }
  }
LABEL_1454:
  v903 = v1274;
  v1269 = v1273;
  v1270 = v1274;
  if (v1274)
  {
    v904 = (unint64_t *)&v1274->__shared_owners_;
    do
      v905 = __ldxr(v904);
    while (__stxr(v905 + 1, v904));
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::replaceQuantizer((uint64_t)v45, (uint64_t *)&v1269);
    do
      v906 = __ldaxr(v904);
    while (__stlxr(v906 - 1, v904));
    if (!v906)
    {
      ((void (*)(std::__shared_weak_count *))v903->__on_zero_shared)(v903);
      std::__shared_weak_count::__release_weak(v903);
    }
  }
  else
  {
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::replaceQuantizer((uint64_t)v45, (uint64_t *)&v1269);
  }
  os_unfair_lock_lock(v73);
  v907 = *(std::__shared_weak_count **)(v508 + 136);
  if (v907)
  {
    v908 = (unint64_t *)&v907->__shared_owners_;
    do
      v909 = __ldxr(v908);
    while (__stxr(v909 + 1, v908));
  }
  v911 = *(_QWORD *)(v508 + 144);
  v910 = *(_QWORD *)(v508 + 152);
  if (v910)
  {
    v912 = (unint64_t *)(v910 + 8);
    do
      v913 = __ldxr(v912);
    while (__stxr(v913 + 1, v912));
  }
  os_unfair_lock_unlock(v73);
  v914 = (std::__shared_weak_count *)v1278.__r_.__value_.__l.__size_;
  v1278.__r_.__value_.__r.__words[0] = v911;
  v1278.__r_.__value_.__l.__size_ = v910;
  if (v914)
  {
    v915 = (unint64_t *)&v914->__shared_owners_;
    do
      v916 = __ldaxr(v915);
    while (__stlxr(v916 - 1, v915));
    if (!v916)
    {
      ((void (*)(std::__shared_weak_count *))v914->__on_zero_shared)(v914);
      std::__shared_weak_count::__release_weak(v914);
    }
  }
  if (v907)
  {
    v917 = (unint64_t *)&v907->__shared_owners_;
    do
      v918 = __ldaxr(v917);
    while (__stlxr(v918 - 1, v917));
    if (!v918)
    {
      ((void (*)(std::__shared_weak_count *))v907->__on_zero_shared)(v907);
      std::__shared_weak_count::__release_weak(v907);
    }
  }
  if (*(_BYTE *)(v508 + 208))
    (*(void (**)(std::string::size_type))(*(_QWORD *)v1278.__r_.__value_.__l.__data_ + 120))(v1278.__r_.__value_.__r.__words[0]);
  v919 = *__error();
  v920 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v920, OS_LOG_TYPE_DEFAULT))
  {
    v921 = v1278.__r_.__value_.__r.__words[0];
    (*(void (**)(std::string *__return_ptr, std::string::size_type))(*(_QWORD *)v1278.__r_.__value_.__l.__data_
                                                                              + 144))(&v1289, v1278.__r_.__value_.__r.__words[0]);
    if ((v1289.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v922 = &v1289;
    else
      v922 = (std::string *)v1289.__r_.__value_.__r.__words[0];
    v925 = v921 + 72;
    v923 = *(_DWORD *)(v921 + 72);
    v924 = *(_DWORD *)(v925 + 4);
    v926 = v1273 + 8;
    if (v1273[31] < 0)
      v926 = (_QWORD *)*v926;
    v927 = (*(uint64_t (**)(void))(*(_QWORD *)v1273 + 16))();
    v928 = *(_DWORD *)(*(_QWORD *)(v508 + 96) + 40);
    *(_DWORD *)v1290 = 136316418;
    *(_QWORD *)&v1290[4] = v922;
    *(_WORD *)&v1290[12] = 1024;
    *(_DWORD *)&v1290[14] = v924;
    v1291 = 1024;
    v1292 = v923;
    v1293 = 2080;
    v1294 = v926;
    v1295 = 1024;
    v1296 = v927;
    v1297 = 1024;
    v1298 = v928;
    _os_log_impl(&dword_1B8270000, v920, OS_LOG_TYPE_DEFAULT, "Partitions rebuilt %s version: %d count: %u not match Quantizer %s version %d vectors count:%u.", v1290, 0x2Eu);
    if (SHIBYTE(v1289.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v1289.__r_.__value_.__l.__data_);
  }
  *__error() = v919;
LABEL_1489:
  v929 = v1274;
  if (v1274)
  {
    v930 = (unint64_t *)&v1274->__shared_owners_;
    do
      v931 = __ldaxr(v930);
    while (__stlxr(v931 - 1, v930));
    if (!v931)
    {
      ((void (*)(std::__shared_weak_count *))v929->__on_zero_shared)(v929);
      std::__shared_weak_count::__release_weak(v929);
    }
  }
  v537 = (std::__shared_weak_count *)v1278.__r_.__value_.__l.__size_;
  if (v1278.__r_.__value_.__l.__size_)
  {
    v932 = (unint64_t *)(v1278.__r_.__value_.__l.__size_ + 8);
    do
      v539 = __ldaxr(v932);
    while (__stlxr(v539 - 1, v932));
    goto LABEL_1772;
  }
  return v508;
}

void IVFVectorIndexTemplate<float,768>::childMetaInfo(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  char *v8;
  char *v9;
  int v10;
  size_t v11;
  size_t v12;
  _BYTE *v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  const std::string::value_type *v18;
  std::string::size_type v19;
  std::string *v20;
  _QWORD *v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t v26;
  int *v27;
  std::string *v28;
  int v29;
  int v30;
  _QWORD *v31;
  uint64_t v32;
  char v33;
  int v34;
  NSObject *v35;
  const char *v36;
  std::string *v37;
  char *v38;
  char *v39;
  const char *v40;
  std::string v41;
  _BYTE __dst[28];
  __int16 v43;
  std::string *v44;
  __int16 v45;
  int v46;
  char v47[1024];
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  bzero(v47, 0x400uLL);
  v8 = fd_name(*(_QWORD *)a2, v47, 0x400uLL);
  v9 = v8;
  if (*(_QWORD *)a2)
    v10 = *(_DWORD *)(*(_QWORD *)a2 + 44);
  else
    v10 = -1;
  v11 = strlen(v8);
  if (v11 >= 0x7FFFFFFFFFFFFFF8)
    goto LABEL_64;
  v12 = v11;
  if (v11 >= 0x17)
  {
    v14 = (v11 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v11 | 7) != 0x17)
      v14 = v11 | 7;
    v15 = v14 + 1;
    v13 = operator new(v14 + 1);
    *(_QWORD *)&__dst[8] = v12;
    *(_QWORD *)&__dst[16] = v15 | 0x8000000000000000;
    *(_QWORD *)__dst = v13;
    goto LABEL_11;
  }
  __dst[23] = v11;
  v13 = __dst;
  if (v11)
LABEL_11:
    memmove(v13, v9, v12);
  v13[v12] = 0;
  memset(&v41, 0, sizeof(v41));
  v16 = __dst[23];
  if ((__dst[23] & 0x80000000) != 0)
    std::string::__init_copy_ctor_external(&v41, *(const std::string::value_type **)__dst, *(std::string::size_type *)&__dst[8]);
  else
    v41 = *(std::string *)__dst;
  v17 = *(char *)(a3 + 23);
  if (v17 >= 0)
    v18 = (const std::string::value_type *)a3;
  else
    v18 = *(const std::string::value_type **)a3;
  if (v17 >= 0)
    v19 = *(unsigned __int8 *)(a3 + 23);
  else
    v19 = *(_QWORD *)(a3 + 8);
  std::string::append(&v41, v18, v19);
  if (v16 < 0)
  {
    operator delete(*(void **)__dst);
    if (!a4)
      goto LABEL_36;
  }
  else if (!a4)
  {
    goto LABEL_36;
  }
  if ((v41.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v20 = &v41;
  else
    v20 = (std::string *)v41.__r_.__value_.__r.__words[0];
  v21 = fd_create_protected(v10, (const char *)v20, 0, 3u);
  if (v21)
  {
    v22 = (uint64_t)v21;
    do
    {
      v23 = fchmodat(*(_DWORD *)(v22 + 44), *(const char **)(v22 + 72), 0x180u, 2048);
      v24 = g_prot_error_callback;
      if (v23 != -1 || g_prot_error_callback == 0)
        break;
      v26 = *(unsigned int *)(v22 + 40);
      v27 = __error();
    }
    while (((*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t))(v24 + 16))(v24, v26, *v27, 19) & 1) != 0);
    _fd_unlink_with_origin(v22, 0);
    fd_release((char *)v22);
  }
LABEL_36:
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  if ((v41.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v28 = &v41;
  else
    v28 = (std::string *)v41.__r_.__value_.__r.__words[0];
  if (*(_BYTE *)(a2 + 20))
    v29 = a4;
  else
    v29 = 1;
  if (v29)
    v30 = 514;
  else
    v30 = 0;
  v31 = fd_create_protected(v10, (const char *)v28, v30, 3u);
  v32 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)a1 = v31;
  *(_QWORD *)(a1 + 8) = v32;
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  if (*(_BYTE *)(a2 + 20))
    v33 = a4 ^ 1;
  else
    v33 = 0;
  *(_BYTE *)(a1 + 20) = v33;
  *(_BYTE *)(a1 + 21) = a4;
  *(_BYTE *)(a1 + 22) = *(_BYTE *)(a2 + 22);
  *(_DWORD *)(a1 + 24) = 0;
  if (!v31)
  {
    v34 = *__error();
    v35 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
    {
      v36 = "open";
      if (a4)
        v36 = "create";
      *(_DWORD *)__dst = 136316162;
      *(_QWORD *)&__dst[4] = "childMetaInfo";
      *(_DWORD *)&__dst[14] = 1940;
      v37 = &v41;
      *(_WORD *)&__dst[12] = 1024;
      if ((v41.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        v37 = (std::string *)v41.__r_.__value_.__r.__words[0];
      *(_WORD *)&__dst[18] = 2080;
      *(_QWORD *)&__dst[20] = v36;
      v43 = 2080;
      v44 = v37;
      v45 = 1024;
      v46 = v10;
      _os_log_error_impl(&dword_1B8270000, v35, OS_LOG_TYPE_ERROR, "%s:%d: Failed to %s %s in parentFd: %i", __dst, 0x2Cu);
    }
    *__error() = v34;
    if (a4)
    {
      v38 = __si_assert_copy_extra_268();
      v39 = v38;
      v40 = "";
      if (v38)
        v40 = v38;
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1941, "!newFile", v40);
      free(v39);
      if (__valid_fs(-1))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
LABEL_64:
      abort();
    }
  }
  if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v41.__r_.__value_.__l.__data_);
}

void PartitionStore<vi_onefixedsize_disk_allocator,512>::openPartitionStore<vi_onefixedsize_disk_allocator>(std::__shared_weak_count **a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v8;
  int *v9;
  unsigned int v10;
  int v11;
  unint64_t v12;
  unsigned int v13;
  unsigned int v14;
  unint64_t v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  void (*v20)(_QWORD);
  int v21;
  NSObject *v22;
  void *v23;
  void *v24;
  uint64_t v25;
  _DWORD *v26;
  unsigned int *v27;
  unsigned int v28;
  int v29;
  NSObject *v30;
  int v31;
  NSObject *v32;
  std::__shared_weak_count *v33;
  uint64_t v34;
  int v35;
  int v36;
  int v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t *v41;
  uint64_t shared_owners;
  std::__shared_weak_count **v43;
  uint64_t v44;
  const void *v45;
  _DWORD *v46;
  _QWORD *v47;
  int v48;
  NSObject *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  char *v55;
  size_t v56;
  std::string::size_type v57;
  std::string *p_dst;
  uint64_t v59;
  uint64_t v60;
  std::string *v61;
  std::string *v62;
  std::string::size_type v63;
  std::string *v64;
  std::string::size_type size;
  std::string *v66;
  std::string::size_type v67;
  std::string *v68;
  std::__shared_weak_count_vtbl *v69;
  char v70;
  uint64_t v71;
  unint64_t v72;
  char *v73;
  uint64_t v74;
  std::__shared_weak_count_vtbl *v75;
  std::__shared_weak_count_vtbl *v76;
  uint64_t shared_weak_owners;
  std::__shared_weak_count_vtbl *v78;
  unint64_t v79;
  char *v80;
  std::__shared_weak_count_vtbl *v81;
  size_t v82;
  uint64_t v83;
  BOOL v84;
  unint64_t v85;
  uint64_t v86;
  std::__shared_weak_count_vtbl *v87;
  uint64_t v88;
  unsigned int v89;
  unsigned int v90;
  unsigned int v91;
  unsigned int v92;
  int v93;
  unsigned int v94;
  float v95;
  unint64_t v96;
  std::__shared_weak_count_vtbl *v97;
  std::__shared_weak_count_vtbl *v98;
  uint64_t p_on_zero_shared;
  std::__shared_weak_count_vtbl *v100;
  uint64_t v101;
  unint64_t v102;
  uint64_t v103;
  unint64_t v104;
  char *v105;
  std::__shared_weak_count_vtbl *v106;
  std::__shared_weak_count_vtbl *v107;
  std::__shared_weak_count_vtbl *v108;
  int on_zero_shared_weak;
  uint64_t v110;
  unsigned int v111;
  float v112;
  int v113;
  uint64_t v114;
  unsigned int v115;
  uint64_t v116;
  void (*v117)(_QWORD);
  unint64_t *v118;
  unint64_t v119;
  int v120;
  NSObject *v121;
  unint64_t v122;
  int v123;
  char *v124;
  char *v125;
  const char *v126;
  uint64_t v127;
  char *v128;
  char *v129;
  const char *v130;
  char *v131;
  const char *v132;
  char v133;
  uint64_t v134;
  std::__shared_weak_count *v135;
  unint64_t *p_shared_owners;
  int v137;
  int v138;
  std::__shared_weak_count **v139;
  _QWORD v140[5];
  int v141;
  unsigned int v142;
  unsigned int v143;
  unsigned int v144;
  unsigned int v145;
  uint64_t v146;
  uint64_t *v147;
  uint64_t v148;
  int v149;
  stat v150;
  std::string v151;
  std::string __dst;
  std::string v153;
  std::string v154;
  _QWORD v155[2];
  _BYTE buf[32];
  _BYTE v157[24];
  int v158;
  char v159;
  char v160;
  char v161;
  char v162;
  uint64_t v163;
  uint64_t v164;

  v164 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a2 + 21))
  {
    v124 = __si_assert_copy_extra_268();
    v125 = v124;
    v126 = "";
    if (v124)
      v126 = v124;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1182, "!meta.newFile", v126);
    free(v125);
    if (__valid_fs(-1))
      v127 = 2989;
    else
      v127 = 3072;
    *(_DWORD *)v127 = -559038737;
    abort();
  }
  memset(&v150, 0, sizeof(v150));
  v4 = *(_QWORD *)a2;
  if (!*(_QWORD *)a2)
    goto LABEL_26;
  while (1)
  {
    v5 = fstatat(*(_DWORD *)(v4 + 44), *(const char **)(v4 + 72), &v150, 2048);
    v6 = g_prot_error_callback;
    if (v5 != -1 || g_prot_error_callback == 0)
      break;
    v8 = *(unsigned int *)(v4 + 40);
    v9 = __error();
    if (((*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t))(v6 + 16))(v6, v8, *v9, 8) & 1) == 0)
      goto LABEL_26;
  }
  if (v5 || v150.st_size <= 123)
  {
LABEL_26:
    v31 = *__error();
    v32 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v32, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "openPartitionStore";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 1185;
      *(_WORD *)&buf[18] = 2048;
      *(_QWORD *)&buf[20] = v150.st_size;
      _os_log_fault_impl(&dword_1B8270000, v32, OS_LOG_TYPE_FAULT, "%s:%d: Partitions corrupted size=%llu", buf, 0x1Cu);
    }
    *__error() = v31;
    *a1 = 0;
    a1[1] = 0;
    return;
  }
  v146 = 0;
  v147 = &v146;
  v149 = 0;
  v148 = 0x2000000000;
  do
  {
    v10 = __ldxr(exceptionSequenceNum);
    v11 = v10 + 1;
  }
  while (__stxr(v10 + 1, exceptionSequenceNum));
  v12 = setThreadIdAndInfo(-1, sAssertExceptionCallbacks, 0, 0, v11);
  v14 = v13;
  v15 = v12;
  v17 = v16;
  v18 = *(_QWORD *)&threadData[18 * v12 + 2];
  v19 = v18 + 320 * HIDWORD(v12);
  v137 = *(_DWORD *)(v19 + 312);
  v20 = *(void (**)(_QWORD))(v19 + 224);
  if (v20)
    v20(*(_QWORD *)(v18 + 320 * HIDWORD(v12) + 288));
  v138 = v11;
  v144 = HIDWORD(v15);
  v145 = v15;
  v142 = v14;
  v143 = v17;
  if (_setjmp((int *)v19))
  {
    v21 = *__error();
    v22 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "openPartitionStore";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 1204;
      _os_log_error_impl(&dword_1B8270000, v22, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
    }
    *__error() = v21;
    *(_DWORD *)(v19 + 312) = v137;
    if (__THREAD_SLOT_KEY)
    {
      v23 = pthread_getspecific(__THREAD_SLOT_KEY);
      if (!v23)
        goto LABEL_134;
    }
    else
    {
      makeThreadId();
      v23 = pthread_getspecific(__THREAD_SLOT_KEY);
      if (!v23)
        goto LABEL_134;
    }
    v24 = v23;
    if ((unint64_t)v23 < 0x801)
    {
LABEL_21:
      v25 = (uint64_t)v24 - 1;
      v26 = &threadData[18 * ((uint64_t)v24 - 1)];
      v28 = v26[14];
      v27 = v26 + 14;
      if (v28 > v142)
      {
        do
          CIOnThreadCleanUpPop(v25);
        while (*v27 > v142);
      }
      dropThreadId(v145, 1, v11);
      CICleanUpReset(v145, v143);
      v29 = *__error();
      v30 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)&buf[4] = "openPartitionStore";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 1207;
        _os_log_fault_impl(&dword_1B8270000, v30, OS_LOG_TYPE_FAULT, "%s:%d: Partitions corrupted", buf, 0x12u);
      }
      *__error() = v29;
      *a1 = 0;
      a1[1] = 0;
      _Block_object_dispose(&v146, 8);
      return;
    }
LABEL_134:
    makeThreadId();
    v24 = pthread_getspecific(__THREAD_SLOT_KEY);
    goto LABEL_21;
  }
  v139 = a1;
  v33 = (std::__shared_weak_count *)operator new(0xC0uLL);
  v33->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v33->__shared_owners_;
  v33->__shared_weak_owners_ = 0;
  v33->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6E336B8;
  v34 = *(_QWORD *)a2;
  v134 = *(_QWORD *)(a2 + 8);
  v35 = *(_DWORD *)(a2 + 16);
  v36 = *(unsigned __int8 *)(a2 + 20);
  v37 = *(unsigned __int8 *)(a2 + 21);
  v38 = *(unsigned __int8 *)(a2 + 22);
  v133 = *(_BYTE *)(a2 + 23);
  *(_QWORD *)buf = 0;
  *(_QWORD *)&buf[8] = 0;
  v39 = *(_QWORD *)(a2 + 24);
  v135 = v33 + 1;
  AnyPartitionStore::AnyPartitionStore((uint64_t)&v33[1], buf);
  v33[5].std::__shared_count = 0u;
  v33[1].__vftable = (std::__shared_weak_count_vtbl *)off_1E6E336F0;
  v33[4].__shared_owners_ = 0;
  LODWORD(v33[4].__shared_weak_owners_) = 0;
  *(_OWORD *)&v33[5].__shared_weak_owners_ = 0u;
  *(_OWORD *)&v33[6].__shared_owners_ = 0u;
  v33[7].std::__shared_count = 0u;
  v33[7].__shared_weak_owners_ = 0;
  v40 = operator new();
  *(_QWORD *)v40 = 0;
  *(_QWORD *)buf = MEMORY[0x1E0C809B0];
  *(_QWORD *)&buf[8] = 0x40000000;
  v41 = (unint64_t *)v40;
  *(_QWORD *)&buf[16] = ___ZN30vi_onefixedsize_disk_allocatorC2EmymN19vi_ondisk_allocator11meta_info_sEP16vector_storage_s_block_invoke;
  *(_QWORD *)&buf[24] = &__block_descriptor_tmp_80;
  *(_QWORD *)v157 = v40;
  *(_QWORD *)&v157[8] = v34;
  *(_QWORD *)&v157[16] = v134;
  v158 = v35;
  v159 = v36;
  v160 = v37;
  v161 = v38;
  v162 = v133;
  v163 = v39;
  storage_array_Init((_DWORD *)(v40 + 8), 1148, 0x40000uLL, 4108, v34, v37 != 0, v35, v36 != 0, v38 != 0, v39, 0, (uint64_t)buf);
  if (v37)
    vi_onefixedsize_disk_allocator::storeHeader(v41);
  shared_owners = v33[4].__shared_owners_;
  v33[4].__shared_owners_ = (uint64_t)v41;
  v43 = v139;
  if (shared_owners)
  {
    v44 = shared_owners;
    storage_array_Close(shared_owners + 8);
    v45 = *(const void **)(v44 + 4208);
    if (v45)
    {
      CFRelease(v45);
      *(_QWORD *)(v44 + 4208) = 0;
    }
    *(_OWORD *)(v44 + 4192) = 0u;
    MEMORY[0x1BCCB06A4](v44, 0x10A0C408BE2A288);
    v41 = (unint64_t *)v33[4].__shared_owners_;
  }
  v46 = (_DWORD *)_windowsResolvePtr((uint64_t)(v41 + 5), 0x400uLL, v41[2]);
  LODWORD(v33[4].__shared_weak_owners_) = v46[1];
  HIDWORD(v33[4].__vftable) = *v46;
  v47 = (_QWORD *)v33[4].__shared_owners_;
  v48 = *__error();
  v49 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
  {
    v50 = v47[6];
    v51 = v47[7];
    v53 = v47[2];
    v52 = v47[3];
    *(_DWORD *)buf = 134219008;
    *(_QWORD *)&buf[4] = v47;
    *(_WORD *)&buf[12] = 2048;
    *(_QWORD *)&buf[14] = v50;
    *(_WORD *)&buf[22] = 2048;
    *(_QWORD *)&buf[24] = v51;
    *(_WORD *)v157 = 2048;
    *(_QWORD *)&v157[2] = v52;
    *(_WORD *)&v157[10] = 2048;
    *(_QWORD *)&v157[12] = v53;
    _os_log_impl(&dword_1B8270000, v49, OS_LOG_TYPE_DEFAULT, "vi_onefixedsize_disk_allocator %p size: %llu, freeRegion: %llu, header: %llu, elemSize: %lu", buf, 0x34u);
  }
  *__error() = v48;
  v54 = v33[4].__shared_owners_;
  if (*(_QWORD *)(v54 + 24) != 4 * LODWORD(v33[4].__shared_weak_owners_) + 1148)
  {
    v128 = __si_assert_copy_extra_268();
    v129 = v128;
    v130 = "";
    if (v128)
      v130 = v128;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1162, "vi_onefixedsize_disk_allocator::getHeaderSize(storage.get()) == headerSize()", v130);
LABEL_141:
    free(v129);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  if (*(_QWORD *)(v54 + 16) != 4108)
  {
    v131 = __si_assert_copy_extra_268();
    v129 = v131;
    v132 = "";
    if (v131)
      v132 = v131;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1163, "vi_onefixedsize_disk_allocator::getElementSize(storage.get()) == sizeof(PartitionBlock_t)", v132);
    goto LABEL_141;
  }
  bzero(buf, 0x400uLL);
  v55 = fd_name(v34, buf, 0x400uLL);
  v56 = strlen(v55);
  if (v56 >= 0x7FFFFFFFFFFFFFF8)
    goto LABEL_144;
  v57 = v56;
  if (v56 >= 0x17)
  {
    v59 = (v56 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v56 | 7) != 0x17)
      v59 = v56 | 7;
    v60 = v59 + 1;
    v61 = (std::string *)operator new(v59 + 1);
    __dst.__r_.__value_.__l.__size_ = v57;
    __dst.__r_.__value_.__r.__words[2] = v60 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v61;
    p_dst = v61;
  }
  else
  {
    *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v56;
    p_dst = &__dst;
    if (!v56)
    {
      p_dst = &__dst;
      goto LABEL_48;
    }
  }
  memmove(p_dst, v55, v57);
LABEL_48:
  p_dst->__r_.__value_.__s.__data_[v57] = 0;
  v62 = std::string::append(&__dst, "(");
  v63 = v62->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v153.__r_.__value_.__l.__data_ = *(_OWORD *)&v62->__r_.__value_.__l.__data_;
  v153.__r_.__value_.__r.__words[2] = v63;
  v62->__r_.__value_.__l.__size_ = 0;
  v62->__r_.__value_.__r.__words[2] = 0;
  v62->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&v151, HIDWORD(v33[4].__vftable));
  if ((v151.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v64 = &v151;
  else
    v64 = (std::string *)v151.__r_.__value_.__r.__words[0];
  if ((v151.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(v151.__r_.__value_.__r.__words[2]);
  else
    size = v151.__r_.__value_.__l.__size_;
  v66 = std::string::append(&v153, (const std::string::value_type *)v64, size);
  v67 = v66->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v154.__r_.__value_.__l.__data_ = *(_OWORD *)&v66->__r_.__value_.__l.__data_;
  v154.__r_.__value_.__r.__words[2] = v67;
  v66->__r_.__value_.__l.__size_ = 0;
  v66->__r_.__value_.__r.__words[2] = 0;
  v66->__r_.__value_.__r.__words[0] = 0;
  v68 = std::string::append(&v154, ")");
  v69 = (std::__shared_weak_count_vtbl *)v68->__r_.__value_.__r.__words[0];
  v155[0] = v68->__r_.__value_.__l.__size_;
  *(_QWORD *)((char *)v155 + 7) = *(std::string::size_type *)((char *)&v68->__r_.__value_.__r.__words[1] + 7);
  v70 = HIBYTE(v68->__r_.__value_.__r.__words[2]);
  v68->__r_.__value_.__l.__size_ = 0;
  v68->__r_.__value_.__r.__words[2] = 0;
  v68->__r_.__value_.__r.__words[0] = 0;
  if (SHIBYTE(v33[6].__shared_weak_owners_) < 0)
    operator delete(v33[6].__vftable);
  v71 = v155[0];
  v33[6].__vftable = v69;
  v33[6].__shared_owners_ = v71;
  *(uint64_t *)((char *)&v33[6].__shared_owners_ + 7) = *(_QWORD *)((char *)v155 + 7);
  HIBYTE(v33[6].__shared_weak_owners_) = v70;
  if ((SHIBYTE(v154.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((SHIBYTE(v151.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_58;
LABEL_68:
    operator delete(v151.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v153.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_59;
    goto LABEL_69;
  }
  operator delete(v154.__r_.__value_.__l.__data_);
  if (SHIBYTE(v151.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_68;
LABEL_58:
  if ((SHIBYTE(v153.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    goto LABEL_59;
LABEL_69:
  operator delete(v153.__r_.__value_.__l.__data_);
LABEL_59:
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__dst.__r_.__value_.__l.__data_);
  v72 = v46[2];
  HIDWORD(v33[3].__shared_weak_owners_) = v72;
  LODWORD(v33[4].__vftable) = v46[3];
  v73 = (char *)(v46 + 31);
  v74 = (uint64_t)&v46[v72 + 31];
  v75 = v33[5].__vftable;
  v76 = v75;
  if (v72 <= (v33[5].__shared_weak_owners_ - (uint64_t)v75) >> 2)
  {
    v78 = (std::__shared_weak_count_vtbl *)v33[5].__shared_owners_;
    v79 = ((char *)v78 - (char *)v75) >> 2;
    if (v79 >= v72)
    {
      v82 = 4 * v72;
      if ((char *)v74 != v73)
        memmove(v33[5].__vftable, v73, v82);
    }
    else
    {
      v80 = &v73[4 * v79];
      if (v78 == v75)
      {
        v81 = v33[5].__vftable;
      }
      else
      {
        memmove(v33[5].__vftable, v73, (char *)v78 - (char *)v75);
        v81 = (std::__shared_weak_count_vtbl *)v33[5].__shared_owners_;
      }
      if ((char *)v74 != v80)
        memmove(v81, v80, v74 - (_QWORD)v80);
      v82 = v74 - (_QWORD)v80;
      v76 = v81;
    }
    goto LABEL_84;
  }
  if (v75)
  {
    v33[5].__shared_owners_ = (uint64_t)v75;
    operator delete(v75);
    shared_weak_owners = 0;
    v33[5].__vftable = 0;
    v33[5].__shared_owners_ = 0;
    v33[5].__shared_weak_owners_ = 0;
  }
  else
  {
    shared_weak_owners = v33[5].__shared_weak_owners_;
  }
  v83 = shared_weak_owners >> 1;
  if (shared_weak_owners >> 1 <= v72)
    v83 = v72;
  v84 = (unint64_t)shared_weak_owners >= 0x7FFFFFFFFFFFFFFCLL;
  v85 = 0x3FFFFFFFFFFFFFFFLL;
  if (!v84)
    v85 = v83;
  if (v85 >> 62)
LABEL_144:
    abort();
  v86 = 4 * v85;
  v87 = (std::__shared_weak_count_vtbl *)operator new(4 * v85);
  v76 = v87;
  v33[5].__vftable = v87;
  v33[5].__shared_owners_ = (uint64_t)v87;
  v33[5].__shared_weak_owners_ = (uint64_t)v87 + v86;
  v82 = 4 * v72;
  if ((char *)v74 != v73)
    memcpy(v87, v73, v82);
LABEL_84:
  v33[5].__shared_owners_ = (uint64_t)v76 + v82;
  if (HIDWORD(v33[3].__shared_weak_owners_))
  {
    v88 = 0;
    do
    {
      v97 = (std::__shared_weak_count_vtbl *)v33[7].__shared_owners_;
      v96 = v33[7].__shared_weak_owners_;
      v98 = v97;
      if ((unint64_t)v97 >= v96)
      {
        v100 = v33[7].__vftable;
        v101 = ((char *)v97 - (char *)v100) >> 4;
        v102 = v101 + 1;
        if ((unint64_t)(v101 + 1) >> 60)
          goto LABEL_144;
        v103 = v96 - (_QWORD)v100;
        if (v103 >> 3 > v102)
          v102 = v103 >> 3;
        if ((unint64_t)v103 >= 0x7FFFFFFFFFFFFFF0)
          v104 = 0xFFFFFFFFFFFFFFFLL;
        else
          v104 = v102;
        if (v104)
        {
          if (v104 >> 60)
            std::__throw_bad_array_new_length[abi:nn180100]();
          v105 = (char *)operator new(16 * v104);
        }
        else
        {
          v105 = 0;
        }
        v106 = (std::__shared_weak_count_vtbl *)&v105[16 * v101];
        v107 = v106;
        v106->~__shared_weak_count = (void (__cdecl *)(std::__shared_weak_count *__hidden))v135;
        LODWORD(v106->~__shared_weak_count_0) = v88;
        if (v97 != v100)
        {
          v108 = (std::__shared_weak_count_vtbl *)&v105[16 * v101];
          do
          {
            on_zero_shared_weak = (int)v98[-1].__on_zero_shared_weak;
            v108[-1].__get_deleter = v98[-1].__get_deleter;
            v108 = (std::__shared_weak_count_vtbl *)((char *)v108 - 16);
            v98 = (std::__shared_weak_count_vtbl *)((char *)v98 - 16);
            LODWORD(v108->~__shared_weak_count_0) = on_zero_shared_weak;
          }
          while (v98 != v100);
          v107 = v108;
          v98 = v33[7].__vftable;
        }
        p_on_zero_shared = (uint64_t)&v106->__on_zero_shared;
        v33[7].__vftable = v107;
        v33[7].__shared_owners_ = (uint64_t)&v106->__on_zero_shared;
        v33[7].__shared_weak_owners_ = (uint64_t)&v105[16 * v104];
        if (v98)
          operator delete(v98);
        v43 = v139;
      }
      else
      {
        v97->~__shared_weak_count = (void (__cdecl *)(std::__shared_weak_count *__hidden))v135;
        LODWORD(v97->~__shared_weak_count_0) = v88;
        p_on_zero_shared = (uint64_t)&v97->__on_zero_shared;
      }
      v33[7].__shared_owners_ = p_on_zero_shared;
      v110 = ((uint64_t (*)(std::__shared_weak_count *, uint64_t))v33[1].__on_zero_shared_weak)(v135, v88);
      v111 = *(_DWORD *)v110;
      if (*(_DWORD *)v110 != -1)
      {
        v112 = *(float *)(v110 + 4);
        if (v112 == 0.0)
        {
          v95 = 3.4028e38;
        }
        else
        {
          v89 = v33[3].__shared_weak_owners_;
          v90 = v89 / 0xADC8;
          v91 = 48271 * (v89 % 0xADC8);
          v90 *= 3399;
          v84 = v91 >= v90;
          v92 = v91 - v90;
          if (v84)
            v93 = 0;
          else
            v93 = 0x7FFFFFFF;
          v94 = v93 + v92;
          LODWORD(v33[3].__shared_weak_owners_) = v94;
          v95 = (float)-logf((float)(v94 - 1) * 4.6566e-10) / v112;
        }
        v154.__r_.__value_.__r.__words[0] = __PAIR64__(LODWORD(v95), v111);
        MaxSizePriorityQueue<AnyPartitionStore::CandidateEntry,std::vector<AnyPartitionStore::CandidateEntry>,AnyPartitionStore::CandidateQueue::Lesser>::push(&v33[2].__vftable, (uint64_t)&v154);
      }
      v88 = (v88 + 1);
    }
    while (v88 < HIDWORD(v33[3].__shared_weak_owners_));
  }
  v113 = (int)v33[4].__vftable;
  v140[0] = MEMORY[0x1E0C809B0];
  v140[1] = 0x40000000;
  v140[2] = ___ZN14PartitionStoreI30vi_onefixedsize_disk_allocatorLi512EE18openPartitionStoreIS0_EENSt3__110shared_ptrI17AnyPartitionStoreEENS3_9enable_ifIXsr13is_persistentIT_EE5valueES8_E4type11meta_info_sE_block_invoke;
  v140[3] = &unk_1E6E33688;
  v140[4] = &v146;
  v141 = v113;
  ((void (*)(std::__shared_weak_count *, _QWORD *))v33[1].__vftable[1].__get_deleter)(v135, v140);
  v114 = *(_QWORD *)&threadData[18 * v145 + 2];
  v115 = v144;
  v116 = v114 + 320 * v144;
  *(_DWORD *)(v116 + 312) = v137;
  v117 = *(void (**)(_QWORD))(v116 + 232);
  if (v117)
    v117(*(_QWORD *)(v114 + 320 * v115 + 288));
  dropThreadId(v145, 0, v138);
  if (*((_DWORD *)v147 + 6) == v113)
  {
    *v43 = v135;
    v43[1] = v33;
    v118 = (unint64_t *)&v33->__shared_owners_;
    do
      v119 = __ldxr(p_shared_owners);
    while (__stxr(v119 + 1, p_shared_owners));
  }
  else
  {
    v120 = *__error();
    v121 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v121, OS_LOG_TYPE_FAULT))
    {
      v123 = *((_DWORD *)v147 + 6);
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = "openPartitionStore";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 1211;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v123;
      *(_WORD *)&buf[24] = 1024;
      *(_DWORD *)&buf[26] = v113;
      _os_log_fault_impl(&dword_1B8270000, v121, OS_LOG_TYPE_FAULT, "%s:%d: Invalid partitions: number of offsets %u != nVectors=%u", buf, 0x1Eu);
    }
    *__error() = v120;
    *v43 = 0;
    v43[1] = 0;
    v118 = (unint64_t *)&v33->__shared_owners_;
  }
  _Block_object_dispose(&v146, 8);
  do
    v122 = __ldaxr(v118);
  while (__stlxr(v122 - 1, v118));
  if (!v122)
  {
    ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
    std::__shared_weak_count::__release_weak(v33);
  }
}

void QuantizerManager<float,768>::sharedQuantizer(_QWORD *a1, uint64_t a2, int a3)
{
  unsigned __int8 v6;
  unint64_t *v7;
  unint64_t v8;
  NSObject *v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  _QWORD v16[6];
  int v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  __n128 (*v21)(uint64_t, uint64_t);
  void (*v22)(uint64_t);
  uint64_t v23;
  uint64_t v24;

  v18 = 0;
  v19 = &v18;
  v20 = 0x3802000000;
  v21 = __Block_byref_object_copy__789;
  v22 = __Block_byref_object_dispose__790;
  v23 = 0;
  v24 = 0;
  if ((v6 & 1) == 0
  {
    __cxa_atexit((void (*)(void *))std::shared_ptr<Quantizer<float,768>>::~shared_ptr[abi:nn180100], &ZeroVectorQuantizer<float,768>::sharedInstance(void)::zvq, &dword_1B8270000);
  }
  if (ZeroVectorQuantizer<float,768>::sharedInstance(void)::onceToken != -1)
    dispatch_once(&ZeroVectorQuantizer<float,768>::sharedInstance(void)::onceToken, &__block_literal_global_731_5706);
  v23 = ZeroVectorQuantizer<float,768>::sharedInstance(void)::zvq;
  v24 = qword_1EF1AFA68;
  if (qword_1EF1AFA68)
  {
    v7 = (unint64_t *)(qword_1EF1AFA68 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  v9 = *(NSObject **)(a2 + 16);
  v16[0] = MEMORY[0x1E0C809B0];
  v16[1] = 0x40000000;
  v16[2] = ___ZN16QuantizerManagerIfLi768EE15sharedQuantizerEi_block_invoke;
  v16[3] = &unk_1E6E33258;
  v17 = a3;
  v16[4] = &v18;
  v16[5] = a2;
  dispatch_sync(v9, v16);
  v10 = v19[6];
  *a1 = v19[5];
  a1[1] = v10;
  if (v10)
  {
    v11 = (unint64_t *)(v10 + 8);
    do
      v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
  }
  _Block_object_dispose(&v18, 8);
  v13 = (std::__shared_weak_count *)v24;
  if (v24)
  {
    v14 = (unint64_t *)(v24 + 8);
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
}

void AnyPartitionStore::replaceQuantizer(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t *v3;
  unint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  char *v8;
  char *v9;
  const char *v10;
  char *v11;
  const char *v12;

  if (*(_QWORD *)(a1 + 8))
  {
    v8 = __si_assert_copy_extra_268();
    v9 = v8;
    v10 = "";
    if (v8)
      v10 = v8;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 876, "_quantizer == nullptr", v10);
LABEL_18:
    free(v9);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  if (!a2)
  {
    v11 = __si_assert_copy_extra_268();
    v9 = v11;
    v12 = "";
    if (v11)
      v12 = v11;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 877, "newQuantizer != nullptr", v12);
    goto LABEL_18;
  }
  if (a3)
  {
    v3 = (unint64_t *)(a3 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  v5 = *(std::__shared_weak_count **)(a1 + 16);
  *(_QWORD *)(a1 + 8) = a2;
  *(_QWORD *)(a1 + 16) = a3;
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
}

void std::swap[abi:nn180100]<IVFVectorIndexTemplate<float,768>::QuantizerPartitions>(__int128 *a1, __int128 *a2)
{
  __int128 v4;
  __int128 v5;
  __int128 v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  __int128 v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;

  v5 = *a1;
  v4 = a1[1];
  *(_QWORD *)a1 = 0;
  *((_QWORD *)a1 + 1) = 0;
  *((_QWORD *)a1 + 2) = 0;
  *((_QWORD *)a1 + 3) = 0;
  v6 = *a2;
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0;
  v7 = (std::__shared_weak_count *)*((_QWORD *)a1 + 1);
  *a1 = v6;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      v20 = v5;
      v22 = v4;
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
      v5 = v20;
      v4 = v22;
    }
  }
  v10 = a2[1];
  *((_QWORD *)a2 + 2) = 0;
  *((_QWORD *)a2 + 3) = 0;
  v11 = (std::__shared_weak_count *)*((_QWORD *)a1 + 3);
  a1[1] = v10;
  if (v11)
  {
    v12 = (unint64_t *)&v11->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      v21 = v5;
      v23 = v4;
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
      v5 = v21;
      v4 = v23;
    }
  }
  v14 = (std::__shared_weak_count *)*((_QWORD *)a2 + 1);
  *a2 = v5;
  if (v14)
  {
    v15 = (unint64_t *)&v14->__shared_owners_;
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      v24 = v4;
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
      v4 = v24;
    }
  }
  v17 = (std::__shared_weak_count *)*((_QWORD *)a2 + 3);
  a2[1] = v4;
  if (v17)
  {
    v18 = (unint64_t *)&v17->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
  }
}

void IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::replaceQuantizer(uint64_t a1, uint64_t *a2)
{
  os_unfair_lock_s *v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  unint64_t *v28;
  unint64_t v29;
  unint64_t *v30;
  unint64_t v31;
  uint64_t v32;
  std::__shared_weak_count *v33;
  uint64_t v34;
  std::__shared_weak_count *v35;
  uint64_t v36;
  std::__shared_weak_count *v37;

  v4 = (os_unfair_lock_s *)(a1 + 112);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 112));
  v6 = *(_QWORD *)(a1 + 80);
  v5 = *(std::__shared_weak_count **)(a1 + 88);
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }
  v9 = *(std::__shared_weak_count **)(a1 + 104);
  if (v9)
  {
    v10 = (unint64_t *)&v9->__shared_owners_;
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }
  os_unfair_lock_unlock(v4);
  v12 = *a2;
  if (v6 != *a2)
  {
    v13 = (std::__shared_weak_count *)a2[1];
    v36 = *a2;
    v37 = v13;
    if (v13)
    {
      v14 = (unint64_t *)&v13->__shared_owners_;
      do
        v15 = __ldxr(v14);
      while (__stxr(v15 + 1, v14));
      v16 = (std::__shared_weak_count *)a2[1];
      v32 = *a2;
      v33 = v16;
      if (v16)
      {
        v17 = (unint64_t *)&v16->__shared_owners_;
        do
          v18 = __ldxr(v17);
        while (__stxr(v18 + 1, v17));
      }
    }
    else
    {
      v32 = v12;
      v33 = 0;
    }
    (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t *))(*(_QWORD *)a1 + 40))(&v34, a1, &v32);
    (*(void (**)(uint64_t, uint64_t *, uint64_t *))(*(_QWORD *)a1 + 48))(a1, &v36, &v34);
    v19 = v35;
    if (v35)
    {
      v20 = (unint64_t *)&v35->__shared_owners_;
      do
        v21 = __ldaxr(v20);
      while (__stlxr(v21 - 1, v20));
      if (!v21)
      {
        ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
        std::__shared_weak_count::__release_weak(v19);
      }
    }
    v22 = v33;
    if (v33)
    {
      v23 = (unint64_t *)&v33->__shared_owners_;
      do
        v24 = __ldaxr(v23);
      while (__stlxr(v24 - 1, v23));
      if (!v24)
      {
        ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
        std::__shared_weak_count::__release_weak(v22);
      }
    }
    v25 = v37;
    if (v37)
    {
      v26 = (unint64_t *)&v37->__shared_owners_;
      do
        v27 = __ldaxr(v26);
      while (__stlxr(v27 - 1, v26));
      if (!v27)
      {
        ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
        std::__shared_weak_count::__release_weak(v25);
      }
    }
  }
  if (!v9)
    goto LABEL_35;
  v28 = (unint64_t *)&v9->__shared_owners_;
  do
    v29 = __ldaxr(v28);
  while (__stlxr(v29 - 1, v28));
  if (!v29)
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
    if (!v5)
      return;
  }
  else
  {
LABEL_35:
    if (!v5)
      return;
  }
  v30 = (unint64_t *)&v5->__shared_owners_;
  do
    v31 = __ldaxr(v30);
  while (__stlxr(v31 - 1, v30));
  if (!v31)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
}

__n128 __Block_byref_object_copy__789(uint64_t a1, uint64_t a2)
{
  __n128 result;

  result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 40) = result;
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  return result;
}

void __Block_byref_object_dispose__790(uint64_t a1)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v3;

  v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

uint64_t std::shared_ptr<Quantizer<float,768>>::~shared_ptr[abi:nn180100](uint64_t a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;

  v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  return a1;
}

void ___ZN16QuantizerManagerIfLi768EE15sharedQuantizerEi_block_invoke(uint64_t a1)
{
  int *v2;
  unint64_t v3;
  uint64_t v4;
  int8x8_t v5;
  uint8x8_t v6;
  unint64_t v7;
  uint64_t **v8;
  uint64_t *v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  int v13;
  size_t v14;
  unint64_t v15;
  std::string *p_dst;
  uint64_t v17;
  uint64_t v18;
  const void *v19;
  std::string *v20;
  std::string::size_type size;
  std::string *v22;
  std::string::size_type v23;
  std::string *v24;
  int64_t v25;
  const char *v26;
  _QWORD *v27;
  _QWORD *v28;
  uint64_t v29;
  std::__shared_weak_count *v30;
  std::__shared_weak_count *v31;
  unint64_t *p_shared_owners;
  unint64_t v33;
  uint64_t v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  unint64_t v37;
  unint64_t *p_shared_weak_owners;
  unint64_t v39;
  _QWORD *v40;
  std::__shared_weak_count *v41;
  std::__shared_weak_count *v42;
  unint64_t *v43;
  unint64_t v44;
  unint64_t *v45;
  unint64_t v46;
  uint64_t v47;
  std::__shared_weak_count *v48;
  std::__shared_weak_count *v49;
  unint64_t v50;
  uint64_t v51;
  unsigned __int8 v52;
  std::__shared_weak_count *v53;
  uint64_t v54;
  unint64_t *v55;
  unint64_t v56;
  uint64_t v57;
  unint64_t v58;
  uint64_t v59;
  uint64_t v60;
  unint64_t *v61;
  unint64_t v62;
  uint64_t v63;
  std::__shared_weak_count *v64;
  unint64_t *v65;
  unint64_t v66;
  int v67;
  size_t v68;
  unint64_t v69;
  char *v70;
  uint64_t v71;
  uint64_t v72;
  const void *v73;
  const char *v74;
  _QWORD *v75;
  _QWORD *v76;
  uint64_t v77;
  _QWORD *v78;
  std::__shared_weak_count *v79;
  unint64_t *v80;
  unint64_t v81;
  unint64_t *v82;
  unint64_t v83;
  uint64_t v84;
  std::__shared_weak_count *v85;
  unint64_t *v86;
  unint64_t v87;
  _QWORD *v88;
  std::__shared_weak_count *v89;
  uint64_t v90;
  uint64_t v91;
  std::__shared_weak_count *v92;
  unint64_t *v93;
  unint64_t v94;
  _QWORD v95[2];
  int v96;
  char v97;
  _BYTE v98[11];
  _QWORD v99[2];
  int v100;
  char v101;
  _BYTE v102[11];
  std::string v103;
  std::string __dst;
  std::string v105;
  __int128 v106;
  int64_t v107;

  v2 = (int *)(a1 + 48);
  v3 = *(int *)(a1 + 48);
  v4 = *(_QWORD *)(a1 + 40);
  if (!(_DWORD)v3)
    goto LABEL_79;
  v5 = *(int8x8_t *)(v4 + 120);
  if (!*(_QWORD *)&v5)
    goto LABEL_22;
  v6 = (uint8x8_t)vcnt_s8(v5);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    v7 = *(int *)(a1 + 48);
    if (*(_QWORD *)&v5 <= v3)
      v7 = v3 % *(_QWORD *)&v5;
  }
  else
  {
    v7 = (*(_QWORD *)&v5 - 1) & v3;
  }
  v8 = *(uint64_t ***)(*(_QWORD *)(v4 + 112) + 8 * v7);
  if (!v8 || (v9 = *v8) == 0)
  {
LABEL_22:
    v106 = 0uLL;
    v107 = 0;
    v13 = *(char *)(v4 + 71);
    if (v13 >= 0)
      v14 = *(unsigned __int8 *)(v4 + 71);
    else
      v14 = *(_QWORD *)(v4 + 56);
    v15 = v14 + 1;
    if (v14 + 1 > 0x7FFFFFFFFFFFFFF7)
      goto LABEL_147;
    if (v15 >= 0x17)
    {
      v17 = (v15 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v15 | 7) != 0x17)
        v17 = v15 | 7;
      v18 = v17 + 1;
      p_dst = (std::string *)operator new(v17 + 1);
      __dst.__r_.__value_.__l.__size_ = v14 + 1;
      __dst.__r_.__value_.__r.__words[2] = v18 | 0x8000000000000000;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    }
    else
    {
      memset(&__dst, 0, sizeof(__dst));
      p_dst = &__dst;
      *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v14 + 1;
      if (!v14)
        goto LABEL_36;
    }
    if (v13 >= 0)
      v19 = (const void *)(v4 + 48);
    else
      v19 = *(const void **)(v4 + 48);
    memmove(p_dst, v19, v14);
LABEL_36:
    *(_WORD *)((char *)&p_dst->__r_.__value_.__l.__data_ + v14) = 46;
    std::to_string(&v103, v3);
    if ((v103.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v20 = &v103;
    else
      v20 = (std::string *)v103.__r_.__value_.__r.__words[0];
    if ((v103.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      size = HIBYTE(v103.__r_.__value_.__r.__words[2]);
    else
      size = v103.__r_.__value_.__l.__size_;
    v22 = std::string::append(&__dst, (const std::string::value_type *)v20, size);
    v23 = v22->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v105.__r_.__value_.__l.__data_ = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
    v105.__r_.__value_.__r.__words[2] = v23;
    v22->__r_.__value_.__l.__size_ = 0;
    v22->__r_.__value_.__r.__words[2] = 0;
    v22->__r_.__value_.__r.__words[0] = 0;
    v24 = std::string::append(&v105, ".quantizer");
    v25 = v24->__r_.__value_.__r.__words[2];
    v106 = *(_OWORD *)&v24->__r_.__value_.__l.__data_;
    v107 = v25;
    v24->__r_.__value_.__l.__size_ = 0;
    v24->__r_.__value_.__r.__words[2] = 0;
    v24->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v105.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v105.__r_.__value_.__l.__data_);
      if ((SHIBYTE(v103.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_44:
        if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_45;
LABEL_67:
        operator delete(__dst.__r_.__value_.__l.__data_);
LABEL_45:
        if (v107 >= 0)
          v26 = (const char *)&v106;
        else
          v26 = (const char *)v106;
        v27 = fd_create_protected(*(_DWORD *)v4, v26, 0, 3u);
        if (!v27)
          goto LABEL_76;
        v28 = v27;
        v29 = operator new();
        v99[0] = v28;
        v99[1] = 0x1000000;
        v100 = 0;
        v101 = 1;
        memset(v102, 0, sizeof(v102));
        AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,768>::AllocatedVectorQuantizer(v29, (uint64_t)v99);
        v30 = (std::__shared_weak_count *)operator new();
        v31 = v30;
        v30->__shared_owners_ = 0;
        p_shared_owners = (unint64_t *)&v30->__shared_owners_;
        v30->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6E332E8;
        v30->__shared_weak_owners_ = 0;
        v30[1].__vftable = (std::__shared_weak_count_vtbl *)v29;
        do
          v33 = __ldxr(p_shared_owners);
        while (__stxr(v33 + 1, p_shared_owners));
        v34 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
        v35 = *(std::__shared_weak_count **)(v34 + 48);
        *(_QWORD *)(v34 + 40) = v29;
        *(_QWORD *)(v34 + 48) = v30;
        if (v35)
        {
          v36 = (unint64_t *)&v35->__shared_owners_;
          do
            v37 = __ldaxr(v36);
          while (__stlxr(v37 - 1, v36));
          if (!v37)
          {
            ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
            std::__shared_weak_count::__release_weak(v35);
          }
        }
        p_shared_weak_owners = (unint64_t *)&v31->__shared_weak_owners_;
        do
          v39 = __ldxr(p_shared_weak_owners);
        while (__stxr(v39 + 1, p_shared_weak_owners));
        v40 = std::__hash_table<std::__hash_value_type<int,std::weak_ptr<Quantizer<float,768>>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::weak_ptr<Quantizer<float,768>>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::weak_ptr<Quantizer<float,768>>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::weak_ptr<Quantizer<float,768>>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(v4 + 112, *v2, v2);
        v41 = std::__shared_weak_count::lock(v31);
        v42 = v41;
        if (v41)
        {
          v43 = (unint64_t *)&v41->__shared_weak_owners_;
          do
            v44 = __ldxr(v43);
          while (__stxr(v44 + 1, v43));
          std::__shared_weak_count::__release_weak(v31);
          v45 = (unint64_t *)&v42->__shared_owners_;
          do
            v46 = __ldaxr(v45);
          while (__stlxr(v46 - 1, v45));
          if (v46)
          {
            v47 = v29;
            goto LABEL_71;
          }
          ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
          v48 = v42;
          v47 = v29;
        }
        else
        {
          v47 = 0;
          v48 = v31;
        }
        std::__shared_weak_count::__release_weak(v48);
LABEL_71:
        v49 = (std::__shared_weak_count *)v40[4];
        v40[3] = v47;
        v40[4] = v42;
        if (v49)
          std::__shared_weak_count::__release_weak(v49);
        atomic_store(1u, (unsigned __int8 *)(v29 + 57));
        do
          v50 = __ldaxr(p_shared_owners);
        while (__stlxr(v50 - 1, p_shared_owners));
        if (!v50)
        {
          ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
          std::__shared_weak_count::__release_weak(v31);
          if ((SHIBYTE(v107) & 0x80000000) == 0)
            goto LABEL_79;
          goto LABEL_77;
        }
LABEL_76:
        if ((SHIBYTE(v107) & 0x80000000) == 0)
          goto LABEL_79;
LABEL_77:
        operator delete((void *)v106);
        goto LABEL_79;
      }
    }
    else if ((SHIBYTE(v103.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      goto LABEL_44;
    }
    operator delete(v103.__r_.__value_.__l.__data_);
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_45;
    goto LABEL_67;
  }
  if (v6.u32[0] < 2uLL)
  {
    v10 = *(_QWORD *)&v5 - 1;
    while (1)
    {
      v12 = v9[1];
      if (v12 == v3)
      {
        if (*((_DWORD *)v9 + 4) == (_DWORD)v3)
          goto LABEL_136;
      }
      else if ((v12 & v10) != v7)
      {
        goto LABEL_22;
      }
      v9 = (uint64_t *)*v9;
      if (!v9)
        goto LABEL_22;
    }
  }
  while (1)
  {
    v11 = v9[1];
    if (v11 == v3)
      break;
    if (v11 >= *(_QWORD *)&v5)
      v11 %= *(_QWORD *)&v5;
    if (v11 != v7)
      goto LABEL_22;
LABEL_12:
    v9 = (uint64_t *)*v9;
    if (!v9)
      goto LABEL_22;
  }
  if (*((_DWORD *)v9 + 4) != (_DWORD)v3)
    goto LABEL_12;
LABEL_136:
  v88 = std::__hash_table<std::__hash_value_type<int,std::weak_ptr<Quantizer<float,768>>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::weak_ptr<Quantizer<float,768>>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::weak_ptr<Quantizer<float,768>>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::weak_ptr<Quantizer<float,768>>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(v4 + 112, v3, v2);
  v89 = (std::__shared_weak_count *)v88[4];
  if (v89 && (v89 = std::__shared_weak_count::lock(v89)) != 0)
    v90 = v88[3];
  else
    v90 = 0;
  v91 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v92 = *(std::__shared_weak_count **)(v91 + 48);
  *(_QWORD *)(v91 + 40) = v90;
  *(_QWORD *)(v91 + 48) = v89;
  if (v92)
  {
    v93 = (unint64_t *)&v92->__shared_owners_;
    do
      v94 = __ldaxr(v93);
    while (__stlxr(v94 - 1, v93));
    if (!v94)
    {
      ((void (*)(std::__shared_weak_count *))v92->__on_zero_shared)(v92);
      std::__shared_weak_count::__release_weak(v92);
    }
  }
LABEL_79:
  v51 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if ((v52 & 1) == 0
  {
    __cxa_atexit((void (*)(void *))std::shared_ptr<Quantizer<float,768>>::~shared_ptr[abi:nn180100], &ZeroVectorQuantizer<float,768>::sharedInstance(void)::zvq, &dword_1B8270000);
  }
  if (ZeroVectorQuantizer<float,768>::sharedInstance(void)::onceToken != -1)
    dispatch_once(&ZeroVectorQuantizer<float,768>::sharedInstance(void)::onceToken, &__block_literal_global_731_5706);
  v54 = ZeroVectorQuantizer<float,768>::sharedInstance(void)::zvq;
  v53 = (std::__shared_weak_count *)qword_1EF1AFA68;
  if (!qword_1EF1AFA68)
  {
    if (*(_QWORD *)(v51 + 40) != ZeroVectorQuantizer<float,768>::sharedInstance(void)::zvq)
      return;
LABEL_93:
    v59 = *(_QWORD *)(v4 + 80);
    if (v59)
    {
      v60 = *(_QWORD *)(v4 + 88);
      if (v60)
      {
        v61 = (unint64_t *)(v60 + 8);
        do
          v62 = __ldxr(v61);
        while (__stxr(v62 + 1, v61));
      }
      v63 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
      v64 = *(std::__shared_weak_count **)(v63 + 48);
      *(_QWORD *)(v63 + 40) = v59;
      *(_QWORD *)(v63 + 48) = v60;
      if (v64)
      {
        v65 = (unint64_t *)&v64->__shared_owners_;
        do
          v66 = __ldaxr(v65);
        while (__stlxr(v66 - 1, v65));
        if (!v66)
        {
          ((void (*)(std::__shared_weak_count *))v64->__on_zero_shared)(v64);
          std::__shared_weak_count::__release_weak(v64);
        }
      }
      return;
    }
    v67 = *(char *)(v4 + 71);
    if (v67 >= 0)
      v68 = *(unsigned __int8 *)(v4 + 71);
    else
      v68 = *(_QWORD *)(v4 + 56);
    v69 = v68 + 10;
    if (v68 + 10 <= 0x7FFFFFFFFFFFFFF7)
    {
      if (v69 >= 0x17)
      {
        v71 = (v69 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v69 | 7) != 0x17)
          v71 = v69 | 7;
        v72 = v71 + 1;
        v70 = (char *)operator new(v71 + 1);
        *((_QWORD *)&v106 + 1) = v68 + 10;
        v107 = v72 | 0x8000000000000000;
        *(_QWORD *)&v106 = v70;
      }
      else
      {
        v107 = 0;
        v106 = 0uLL;
        v70 = (char *)&v106;
        HIBYTE(v107) = v68 + 10;
        if (!v68)
        {
LABEL_116:
          strcpy(&v70[v68], ".quantizer");
          if (v107 >= 0)
            v74 = (const char *)&v106;
          else
            v74 = (const char *)v106;
          v75 = fd_create_protected(*(_DWORD *)v4, v74, 0, 3u);
          if (v75)
          {
            v76 = v75;
            v77 = operator new();
            v95[0] = v76;
            v95[1] = 0x1000000;
            v96 = 0;
            v97 = 1;
            memset(v98, 0, sizeof(v98));
            AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,768>::AllocatedVectorQuantizer(v77, (uint64_t)v95);
            v78 = (_QWORD *)operator new();
            *v78 = &off_1E6E332E8;
            v78[1] = 0;
            v78[2] = 0;
            v78[3] = v77;
            v79 = *(std::__shared_weak_count **)(v4 + 88);
            *(_QWORD *)(v4 + 80) = v77;
            *(_QWORD *)(v4 + 88) = v78;
            if (!v79)
              goto LABEL_126;
            v80 = (unint64_t *)&v79->__shared_owners_;
            do
              v81 = __ldaxr(v80);
            while (__stlxr(v81 - 1, v80));
            if (!v81)
            {
              ((void (*)(std::__shared_weak_count *))v79->__on_zero_shared)(v79);
              std::__shared_weak_count::__release_weak(v79);
            }
            v77 = *(_QWORD *)(v4 + 80);
            v78 = *(_QWORD **)(v4 + 88);
            if (v78)
            {
LABEL_126:
              v82 = v78 + 1;
              do
                v83 = __ldxr(v82);
              while (__stxr(v83 + 1, v82));
            }
            v84 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
            v85 = *(std::__shared_weak_count **)(v84 + 48);
            *(_QWORD *)(v84 + 40) = v77;
            *(_QWORD *)(v84 + 48) = v78;
            if (v85)
            {
              v86 = (unint64_t *)&v85->__shared_owners_;
              do
                v87 = __ldaxr(v86);
              while (__stlxr(v87 - 1, v86));
              if (!v87)
              {
                ((void (*)(std::__shared_weak_count *))v85->__on_zero_shared)(v85);
                std::__shared_weak_count::__release_weak(v85);
              }
            }
          }
          if (SHIBYTE(v107) < 0)
            operator delete((void *)v106);
          return;
        }
      }
      if (v67 >= 0)
        v73 = (const void *)(v4 + 48);
      else
        v73 = *(const void **)(v4 + 48);
      memmove(v70, v73, v68);
      goto LABEL_116;
    }
LABEL_147:
    abort();
  }
  v55 = (unint64_t *)(qword_1EF1AFA68 + 8);
  do
    v56 = __ldxr(v55);
  while (__stxr(v56 + 1, v55));
  v57 = *(_QWORD *)(v51 + 40);
  do
    v58 = __ldaxr(v55);
  while (__stlxr(v58 - 1, v55));
  if (v58)
  {
    if (v57 == v54)
      goto LABEL_93;
  }
  else
  {
    ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
    std::__shared_weak_count::__release_weak(v53);
    if (v57 == v54)
      goto LABEL_93;
  }
}

_QWORD *std::__hash_table<std::__hash_value_type<int,std::weak_ptr<Quantizer<float,768>>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::weak_ptr<Quantizer<float,768>>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::weak_ptr<Quantizer<float,768>>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::weak_ptr<Quantizer<float,768>>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(uint64_t a1, int a2, _DWORD *a3)
{
  unint64_t v5;
  unint64_t v6;
  uint8x8_t v7;
  unint64_t v8;
  void **v9;
  _QWORD *v10;
  unint64_t v11;
  uint64_t v12;
  float v13;
  float v14;
  _BOOL8 v15;
  unint64_t v16;
  unint64_t v17;
  size_t prime;
  unint64_t v19;
  uint8x8_t v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  unint64_t v24;

  v5 = a2;
  v6 = *(_QWORD *)(a1 + 8);
  if (v6)
  {
    v7 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      v8 = a2;
      if (v6 <= a2)
        v8 = a2 % v6;
    }
    else
    {
      v8 = (v6 - 1) & a2;
    }
    v9 = *(void ***)(*(_QWORD *)a1 + 8 * v8);
    if (v9)
    {
      v10 = *v9;
      if (*v9)
      {
        if (v7.u32[0] < 2uLL)
        {
          while (1)
          {
            v12 = v10[1];
            if (v12 == a2)
            {
              if (*((_DWORD *)v10 + 4) == a2)
                return v10;
            }
            else if ((v12 & (v6 - 1)) != v8)
            {
              goto LABEL_22;
            }
            v10 = (_QWORD *)*v10;
            if (!v10)
              goto LABEL_22;
          }
        }
        do
        {
          v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2)
              return v10;
          }
          else
          {
            if (v11 >= v6)
              v11 %= v6;
            if (v11 != v8)
              break;
          }
          v10 = (_QWORD *)*v10;
        }
        while (v10);
      }
    }
  }
  else
  {
    v8 = 0;
  }
LABEL_22:
  v10 = operator new(0x28uLL);
  *v10 = 0;
  v10[1] = v5;
  *((_DWORD *)v10 + 4) = *a3;
  v10[3] = 0;
  v10[4] = 0;
  v13 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v14 = *(float *)(a1 + 32);
  if (!v6 || (float)(v14 * (float)v6) < v13)
  {
    v15 = 1;
    if (v6 >= 3)
      v15 = (v6 & (v6 - 1)) != 0;
    v16 = v15 | (2 * v6);
    v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17)
      prime = v17;
    else
      prime = v16;
    if (prime == 1)
    {
      prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      prime = std::__next_prime(prime);
      v6 = *(_QWORD *)(a1 + 8);
    }
    if (prime > v6)
      goto LABEL_44;
    if (prime < v6)
    {
      v19 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v6 < 3 || (v20 = (uint8x8_t)vcnt_s8((int8x8_t)v6), v20.i16[0] = vaddlv_u8(v20), v20.u32[0] > 1uLL))
      {
        v19 = std::__next_prime(v19);
      }
      else
      {
        v21 = 1 << -(char)__clz(v19 - 1);
        if (v19 >= 2)
          v19 = v21;
      }
      if (prime <= v19)
        prime = v19;
      if (prime < v6)
LABEL_44:
        std::__hash_table<std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,std::__unordered_map_hasher<SIUnicodeString,std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,HashFunction,HashEqual,true>,std::__unordered_map_equal<SIUnicodeString,std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,HashEqual,HashFunction,true>,std::allocator<std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>>>::__do_rehash<true>(a1, prime);
    }
    v6 = *(_QWORD *)(a1 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v6 <= v5)
        v8 = v5 % v6;
      else
        v8 = v5;
    }
    else
    {
      v8 = (v6 - 1) & v5;
    }
  }
  v22 = *(_QWORD *)a1;
  v23 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v8);
  if (v23)
  {
    *v10 = *v23;
LABEL_58:
    *v23 = v10;
    goto LABEL_59;
  }
  *v10 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v10;
  *(_QWORD *)(v22 + 8 * v8) = a1 + 16;
  if (*v10)
  {
    v24 = *(_QWORD *)(*v10 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v24 >= v6)
        v24 %= v6;
    }
    else
    {
      v24 &= v6 - 1;
    }
    v23 = (_QWORD *)(*(_QWORD *)a1 + 8 * v24);
    goto LABEL_58;
  }
LABEL_59:
  ++*(_QWORD *)(a1 + 24);
  return v10;
}

uint64_t AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,768>::AllocatedVectorQuantizer(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  int v12;
  char v13;
  uint64_t v14;
  const void *v15;
  _DWORD *v16;
  _DWORD *v17;
  int v18;
  _QWORD *v19;
  int v20;
  NSObject *v21;
  uint64_t v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  char *v31;
  char *v32;
  const char *v33;
  char *v34;
  const char *v35;
  char *v36;
  const char *v37;
  char *v38;
  const char *v39;
  char *v40;
  const char *v41;
  char v42[1024];
  _BYTE buf[24];
  void *v44;
  _BYTE v45[24];
  int v46;
  char v47;
  char v48;
  char v49;
  char v50;
  uint64_t v51;
  uint64_t v52;

  v52 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  v4 = a1 + 8;
  *(_QWORD *)a1 = &off_1E6E33288;
  *(_QWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(_WORD *)(a1 + 56) = *(unsigned __int8 *)(a2 + 20);
  *(_QWORD *)(a1 + 64) = fd_dup(*(_QWORD *)a2);
  bzero(v42, 0x400uLL);
  v5 = fd_name(*(_QWORD *)a2, v42, 0x400uLL);
  MEMORY[0x1BCCB03B0](v4, v5);
  if (!*(_QWORD *)(a1 + 64))
  {
    v31 = __si_assert_copy_extra_268();
    v32 = v31;
    v33 = "";
    if (v31)
      v33 = v31;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 478, "fdPtr != nullptr", v33);
    goto LABEL_32;
  }
  v6 = operator new();
  v7 = *(_QWORD *)a2;
  v8 = *(_QWORD *)(a2 + 8);
  v9 = *(_DWORD *)(a2 + 16);
  v10 = *(unsigned __int8 *)(a2 + 20);
  v11 = *(unsigned __int8 *)(a2 + 21);
  v12 = *(unsigned __int8 *)(a2 + 22);
  v13 = *(_BYTE *)(a2 + 23);
  *(_QWORD *)v6 = 0;
  *(_QWORD *)buf = MEMORY[0x1E0C809B0];
  *(_QWORD *)&buf[8] = 0x40000000;
  *(_QWORD *)&buf[16] = ___ZN30vi_onefixedsize_disk_allocatorC2EmymN19vi_ondisk_allocator11meta_info_sEP16vector_storage_s_block_invoke;
  v44 = &__block_descriptor_tmp_80;
  *(_QWORD *)v45 = v6;
  *(_QWORD *)&v45[8] = v7;
  *(_QWORD *)&v45[16] = v8;
  v46 = v9;
  v47 = v10;
  v48 = v11;
  v49 = v12;
  v50 = v13;
  v51 = *(_QWORD *)(a2 + 24);
  storage_array_Init((_DWORD *)(v6 + 8), 1040, 0x40000uLL, 3072, v7, v11 != 0, v9, v10 != 0, v12 != 0, v51, 0, (uint64_t)buf);
  if (v11)
    vi_onefixedsize_disk_allocator::storeHeader((unint64_t *)v6);
  v14 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 40) = v6;
  if (v14)
  {
    storage_array_Close(v14 + 8);
    v15 = *(const void **)(v14 + 4208);
    if (v15)
    {
      CFRelease(v15);
      *(_QWORD *)(v14 + 4208) = 0;
    }
    *(_OWORD *)(v14 + 4192) = 0u;
    MEMORY[0x1BCCB06A4](v14, 0x10A0C408BE2A288);
    v6 = *(_QWORD *)(a1 + 40);
  }
  v16 = (_DWORD *)_windowsResolvePtr(v6 + 40, 0x400uLL, *(_QWORD *)(v6 + 16));
  v17 = v16;
  if (!*(_BYTE *)(a2 + 21))
  {
    *(_DWORD *)(a1 + 52) = *v16;
    v19 = *(_QWORD **)(a1 + 40);
    v20 = *__error();
    v21 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      v22 = v19[6];
      v23 = (void *)v19[7];
      v25 = v19[2];
      v24 = v19[3];
      *(_DWORD *)buf = 134219008;
      *(_QWORD *)&buf[4] = v19;
      *(_WORD *)&buf[12] = 2048;
      *(_QWORD *)&buf[14] = v22;
      *(_WORD *)&buf[22] = 2048;
      v44 = v23;
      *(_WORD *)v45 = 2048;
      *(_QWORD *)&v45[2] = v24;
      *(_WORD *)&v45[10] = 2048;
      *(_QWORD *)&v45[12] = v25;
      _os_log_impl(&dword_1B8270000, v21, OS_LOG_TYPE_DEFAULT, "vi_onefixedsize_disk_allocator %p size: %llu, freeRegion: %llu, header: %llu, elemSize: %lu", buf, 0x34u);
    }
    *__error() = v20;
    v26 = *(_QWORD **)(a1 + 40);
    v27 = v26[2];
    v28 = v26[7] - v26[3];
    v29 = v28 / v27;
    if (v28 == v28 / v27 * v27)
    {
      *(_DWORD *)(a1 + 48) = v29;
      if (v17[1] == (_DWORD)v29)
      {
        if (v26[3] == 1040)
        {
          if (v26[2] == 3072)
            return a1;
          v40 = __si_assert_copy_extra_268();
          v32 = v40;
          v41 = "";
          if (v40)
            v41 = v40;
          __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 490, "vi_onefixedsize_disk_allocator::getElementSize(storage.get()) == sizeof(CIVector_t)", v41);
        }
        else
        {
          v38 = __si_assert_copy_extra_268();
          v32 = v38;
          v39 = "";
          if (v38)
            v39 = v38;
          __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 489, "vi_onefixedsize_disk_allocator::getHeaderSize(storage.get()) == sizeof(QuantizerHeader_t)", v39);
        }
      }
      else
      {
        v36 = __si_assert_copy_extra_268();
        v32 = v36;
        v37 = "";
        if (v36)
          v37 = v36;
        __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 488, "nCentroids == header->count", v37);
      }
    }
    else
    {
      v34 = __si_assert_copy_extra_268();
      v32 = v34;
      v35 = "";
      if (v34)
        v35 = v34;
      __message_assert("%s:%u: failed assertion '%s' %s ", "VectorIndexSupport.hh", 504, "offset % elemSize == 0", v35);
    }
LABEL_32:
    free(v32);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v16[1] = 0;
  v18 = *(_DWORD *)(a2 + 24);
  *v16 = v18;
  *(_DWORD *)(a1 + 52) = v18;
  return a1;
}

void std::__shared_ptr_pointer<AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,768> *,std::shared_ptr<AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,768>>::__shared_ptr_default_delete<AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,768>,AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,768>>,std::allocator<AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,768>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BCCB06A4);
}

uint64_t std::__shared_ptr_pointer<AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,768> *,std::shared_ptr<AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,768>>::__shared_ptr_default_delete<AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,768>,AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,768>>,std::allocator<AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,768>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void ___ZN30vi_onefixedsize_disk_allocatorC2EmymN19vi_ondisk_allocator11meta_info_sEP16vector_storage_s_block_invoke(uint64_t a1)
{
  _DWORD *v1;
  _QWORD *v2;
  unsigned int v3;
  uint64_t v4;
  int v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  char v10;
  BOOL v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  char *v21;
  char v22;
  uint64_t v23;
  uint64_t v24;
  char v25;
  int v26;
  int v27;
  NSObject *v28;
  char *v29;
  char *v30;
  const char *v31;
  _BYTE v32[8];
  unsigned __int8 v33;
  unsigned __int8 v34;
  unsigned __int8 v35;
  unsigned __int8 v36;
  char v37;
  _BYTE v38[3];
  uint8_t buf[4];
  const char *v40;
  __int16 v41;
  int v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 61))
    return;
  v2 = *(_QWORD **)(a1 + 32);
  v1 = *(_DWORD **)(a1 + 40);
  bzero(v32, 0x400uLL);
  if (fd_pread(v1, v32, 0x400uLL, 0) != 1024)
    return;
  bzero(v2 + 1, 0x1080uLL);
  v3 = v33;
  if (((char)v33 & 0x80000000) == 0)
  {
    v4 = 1;
LABEL_12:
    v6 = (char *)(&v33 + v4);
    v2[2] = v3;
    goto LABEL_13;
  }
  if (((char)v34 & 0x80000000) == 0)
  {
    v3 = v33 & 0x7F | (v34 << 7);
    v4 = 2;
    goto LABEL_12;
  }
  if (((char)v35 & 0x80000000) == 0)
  {
    v5 = ((v34 & 0x7F) << 7) | (v35 << 14) | v33 & 0x7F;
    v4 = 3;
LABEL_11:
    v3 = v5;
    goto LABEL_12;
  }
  if (((char)v36 & 0x80000000) == 0)
  {
    v5 = ((v35 & 0x7F) << 14) | (v36 << 21) | ((v34 & 0x7F) << 7) | v33 & 0x7F;
    v4 = 4;
    goto LABEL_11;
  }
  v26 = v37;
  v6 = v38;
  v2[2] = ((v36 & 0x7F) << 21) | (v37 << 28) | ((v35 & 0x7F) << 14) | ((v34 & 0x7F) << 7) | v33 & 0x7Fu;
  if ((v26 & 0x80000000) == 0)
  {
    v27 = *__error();
    v28 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v40 = "storage_array_HeaderRestore";
      v41 = 1024;
      v42 = 311;
      _os_log_error_impl(&dword_1B8270000, v28, OS_LOG_TYPE_ERROR, "%s:%d: invalid storage_array data", buf, 0x12u);
    }
    *__error() = v27;
    goto LABEL_27;
  }
LABEL_13:
  v7 = 0;
  v8 = 0;
  v9 = 0;
  do
  {
    v10 = v6[v8++];
    v9 |= (unint64_t)(v10 & 0x7F) << v7;
    if ((v10 & 0x80) == 0)
      break;
    v11 = v7 == 63;
    v7 += 7;
  }
  while (!v11);
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v2[7] = v9;
  do
  {
    v15 = v13 + 1;
    v16 = v6[v13 + v8];
    v14 |= (unint64_t)(v16 & 0x7F) << v12;
    if ((v16 & 0x80) == 0)
      break;
    v13 = v15;
    v11 = v12 == 63;
    v12 += 7;
  }
  while (!v11);
  v2[6] = v14;
  if (v14 < v9)
  {
    v29 = __si_assert_copy_extra_268();
    v30 = v29;
    v31 = "";
    if (v29)
      v31 = v29;
    __message_assert(v29, "storage_array.c", 305, "storage_array->_windows._size>= storage_array->_windows._freeRegion", v31);
    free(v30);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v20 = &v6[v8 + v15];
  v21 = v20;
  do
  {
    ++v18;
    v22 = *v21++;
    v19 |= (unint64_t)(v22 & 0x7F) << v17;
    if ((v22 & 0x80) == 0)
      break;
    v11 = v17 == 63;
    v17 += 7;
  }
  while (!v11);
  v6 = &v20[v18];
  v2[3] = v19;
LABEL_27:
  v23 = 0;
  v24 = 0;
  do
  {
    v25 = *v6++;
    v24 |= (unint64_t)(v25 & 0x7F) << v23;
    if ((v25 & 0x80) == 0)
      break;
    v11 = v23 == 63;
    v23 += 7;
  }
  while (!v11);
  *v2 = v24;
}

uint64_t vi_onefixedsize_disk_allocator::storeHeader(unint64_t *a1)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  uint64x2_t v8;
  int16x8_t v9;
  uint64x2_t v10;
  uint64x2_t v11;
  int16x8_t v12;
  uint64x2_t v13;
  int16x8_t v14;
  char *v15;
  uint64_t v16;
  uint64x2_t v17;
  int16x8_t v18;
  uint64x2_t v19;
  uint64x2_t v20;
  int16x8_t v21;
  uint64x2_t v22;
  int16x8_t v23;
  char *v24;
  unint64_t v25;
  uint64_t v26;
  uint64x2_t v27;
  int16x8_t v28;
  uint64x2_t v29;
  uint64x2_t v30;
  int16x8_t v31;
  uint64x2_t v32;
  int16x8_t v33;
  char *v34;
  unint64_t v35;
  uint64x2_t v36;
  int16x8_t v37;
  uint64x2_t v38;
  uint64x2_t v39;
  int16x8_t v40;
  uint64x2_t v41;
  int16x8_t v42;
  char *v44;
  char *v45;
  const char *v46;
  char *v47;
  const char *v48;
  char v49[8];
  char v50;
  char v51;
  char v52;
  char v53;
  char v54;
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  if (a1[3] <= 0x3FF)
  {
    v44 = __si_assert_copy_extra_268();
    v45 = v44;
    v46 = "";
    if (v44)
      v46 = v44;
    __message_assert("%s:%u: failed assertion '%s' %s ", "VectorIndexSupport.hh", 301, "allocator->storage._headerSize >= MAP_HEADER_SIZE", v46);
LABEL_95:
    free(v45);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  bzero(v49, 0x400uLL);
  fd_pread((_DWORD *)a1[5], v49, 0x400uLL, 0);
  v2 = a1[6];
  v3 = a1[7];
  if (v2 < v3)
  {
    v47 = __si_assert_copy_extra_268();
    v45 = v47;
    v48 = "";
    if (v47)
      v48 = v47;
    __message_assert(v47, "storage_array.c", 283, "storage_array->_windows._size>= storage_array->_windows._freeRegion", v48);
    goto LABEL_95;
  }
  v4 = a1[2];
  if (v4 >> 28)
  {
    v50 = v4 | 0x80;
    v51 = (v4 >> 7) | 0x80;
    v52 = (v4 >> 14) | 0x80;
    v53 = (v4 >> 21) | 0x80;
    v54 = v4 >> 28;
    v5 = 5;
  }
  else if ((v4 & 0xFE00000) != 0)
  {
    v50 = v4 | 0x80;
    v51 = (v4 >> 7) | 0x80;
    v52 = (v4 >> 14) | 0x80;
    v53 = (v4 & 0xFE00000) >> 21;
    v5 = 4;
  }
  else if ((v4 & 0x1FC000) != 0)
  {
    v50 = v4 | 0x80;
    v51 = (v4 >> 7) | 0x80;
    v52 = (v4 & 0x1FC000) >> 14;
    v5 = 3;
  }
  else if ((v4 & 0x3F80) != 0)
  {
    v50 = v4 | 0x80;
    v51 = (unsigned __int16)(v4 & 0x3F80) >> 7;
    v5 = 2;
  }
  else
  {
    v50 = a1[2];
    v5 = 1;
  }
  v6 = &v50 + v5;
  if (HIDWORD(v3))
  {
    if ((v3 & 0x8000000000000000) != 0)
    {
      *v6 = v3 | 0x80;
      v10 = (uint64x2_t)vdupq_n_s64(v3);
      *(int8x8_t *)(v6 + 1) = vorr_s8(vmovn_s16(vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v10, (uint64x2_t)xmmword_1B8631BA0), (int32x4_t)vshlq_u64(v10, (uint64x2_t)xmmword_1B8631B90)), (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v10, (uint64x2_t)xmmword_1B8631CB0), (int32x4_t)vshlq_u64(v10, (uint64x2_t)xmmword_1B8631CA0)))), (int8x8_t)0x8080808080808080);
      v6[9] = 1;
      v7 = 10;
    }
    else if ((v3 & 0x7F00000000000000) != 0)
    {
      v8 = (uint64x2_t)vdupq_n_s64(v3);
      *v6 = v3 | 0x80;
      v9 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v8, (uint64x2_t)xmmword_1B8631BA0), (int32x4_t)vshlq_u64(v8, (uint64x2_t)xmmword_1B8631B90));
      v9.i64[0] = *(_QWORD *)&vmovn_s32((int32x4_t)v9) | 0x80008000800080;
      *(_DWORD *)(v6 + 1) = vmovn_s16(v9).u32[0];
      v6[5] = (v3 >> 35) | 0x80;
      v6[6] = (v3 >> 42) | 0x80;
      v6[7] = (v3 >> 49) | 0x80;
      v6[8] = HIBYTE(v3) & 0x7F;
      v7 = 9;
    }
    else if ((v3 & 0xFE000000000000) != 0)
    {
      *v6 = v3 | 0x80;
      v11 = (uint64x2_t)vdupq_n_s64(v3);
      v12 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v11, (uint64x2_t)xmmword_1B8631BA0), (int32x4_t)vshlq_u64(v11, (uint64x2_t)xmmword_1B8631B90));
      v12.i64[0] = *(_QWORD *)&vmovn_s32((int32x4_t)v12) | 0x80008000800080;
      *(_DWORD *)(v6 + 1) = vmovn_s16(v12).u32[0];
      v6[5] = (v3 >> 35) | 0x80;
      v6[6] = (v3 >> 42) | 0x80;
      v6[7] = (v3 & 0xFE000000000000) >> 49;
      v7 = 8;
    }
    else
    {
      *v6 = v3 | 0x80;
      v13 = (uint64x2_t)vdupq_n_s64(v3);
      v14 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v13, (uint64x2_t)xmmword_1B8631BA0), (int32x4_t)vshlq_u64(v13, (uint64x2_t)xmmword_1B8631B90));
      v14.i64[0] = *(_QWORD *)&vmovn_s32((int32x4_t)v14) | 0x80008000800080;
      *(_DWORD *)(v6 + 1) = vmovn_s16(v14).u32[0];
      if ((v3 & 0x1FC0000000000) != 0)
      {
        v6[5] = (v3 >> 35) | 0x80;
        v6[6] = (v3 & 0x1FC0000000000) >> 42;
        v7 = 7;
      }
      else
      {
        v6[5] = (v3 >> 35) & 0x7F;
        v7 = 6;
      }
    }
  }
  else if ((v3 & 0x7F0000000) != 0)
  {
    *v6 = v3 | 0x80;
    v6[1] = (v3 >> 7) | 0x80;
    v6[2] = (v3 >> 14) | 0x80;
    v6[3] = (v3 >> 21) | 0x80;
    v6[4] = (v3 & 0x7F0000000) >> 28;
    v7 = 5;
  }
  else if ((v3 & 0xFE00000) != 0)
  {
    *v6 = v3 | 0x80;
    v6[1] = (v3 >> 7) | 0x80;
    v6[2] = (v3 >> 14) | 0x80;
    v6[3] = (v3 & 0xFE00000) >> 21;
    v7 = 4;
  }
  else if ((v3 & 0x1FC000) != 0)
  {
    *v6 = v3 | 0x80;
    v6[1] = (v3 >> 7) | 0x80;
    v6[2] = (v3 & 0x1FC000) >> 14;
    v7 = 3;
  }
  else if ((v3 & 0x3F80) != 0)
  {
    *v6 = v3 | 0x80;
    v6[1] = (v3 & 0x3F80) >> 7;
    v7 = 2;
  }
  else
  {
    *v6 = v3;
    v7 = 1;
  }
  v15 = &v6[v7];
  if (HIDWORD(v2))
  {
    if ((v2 & 0x8000000000000000) != 0)
    {
      *v15 = v2 | 0x80;
      v19 = (uint64x2_t)vdupq_n_s64(v2);
      *(int8x8_t *)(v15 + 1) = vorr_s8(vmovn_s16(vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v19, (uint64x2_t)xmmword_1B8631BA0), (int32x4_t)vshlq_u64(v19, (uint64x2_t)xmmword_1B8631B90)), (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v19, (uint64x2_t)xmmword_1B8631CB0), (int32x4_t)vshlq_u64(v19, (uint64x2_t)xmmword_1B8631CA0)))), (int8x8_t)0x8080808080808080);
      v15[9] = 1;
      v16 = 10;
    }
    else if ((v2 & 0x7F00000000000000) != 0)
    {
      v17 = (uint64x2_t)vdupq_n_s64(v2);
      *v15 = v2 | 0x80;
      v18 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v17, (uint64x2_t)xmmword_1B8631BA0), (int32x4_t)vshlq_u64(v17, (uint64x2_t)xmmword_1B8631B90));
      v18.i64[0] = *(_QWORD *)&vmovn_s32((int32x4_t)v18) | 0x80008000800080;
      *(_DWORD *)(v15 + 1) = vmovn_s16(v18).u32[0];
      v15[5] = (v2 >> 35) | 0x80;
      v15[6] = (v2 >> 42) | 0x80;
      v15[7] = (v2 >> 49) | 0x80;
      v15[8] = HIBYTE(v2) & 0x7F;
      v16 = 9;
    }
    else if ((v2 & 0xFE000000000000) != 0)
    {
      *v15 = v2 | 0x80;
      v20 = (uint64x2_t)vdupq_n_s64(v2);
      v21 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v20, (uint64x2_t)xmmword_1B8631BA0), (int32x4_t)vshlq_u64(v20, (uint64x2_t)xmmword_1B8631B90));
      v21.i64[0] = *(_QWORD *)&vmovn_s32((int32x4_t)v21) | 0x80008000800080;
      *(_DWORD *)(v15 + 1) = vmovn_s16(v21).u32[0];
      v15[5] = (v2 >> 35) | 0x80;
      v15[6] = (v2 >> 42) | 0x80;
      v15[7] = (v2 & 0xFE000000000000) >> 49;
      v16 = 8;
    }
    else
    {
      *v15 = v2 | 0x80;
      v22 = (uint64x2_t)vdupq_n_s64(v2);
      v23 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v22, (uint64x2_t)xmmword_1B8631BA0), (int32x4_t)vshlq_u64(v22, (uint64x2_t)xmmword_1B8631B90));
      v23.i64[0] = *(_QWORD *)&vmovn_s32((int32x4_t)v23) | 0x80008000800080;
      *(_DWORD *)(v15 + 1) = vmovn_s16(v23).u32[0];
      if ((v2 & 0x1FC0000000000) != 0)
      {
        v15[5] = (v2 >> 35) | 0x80;
        v15[6] = (v2 & 0x1FC0000000000) >> 42;
        v16 = 7;
      }
      else
      {
        v15[5] = (v2 >> 35) & 0x7F;
        v16 = 6;
      }
    }
  }
  else if ((v2 & 0x7F0000000) != 0)
  {
    *v15 = v2 | 0x80;
    v15[1] = (v2 >> 7) | 0x80;
    v15[2] = (v2 >> 14) | 0x80;
    v15[3] = (v2 >> 21) | 0x80;
    v15[4] = (v2 & 0x7F0000000) >> 28;
    v16 = 5;
  }
  else if ((v2 & 0xFE00000) != 0)
  {
    *v15 = v2 | 0x80;
    v15[1] = (v2 >> 7) | 0x80;
    v15[2] = (v2 >> 14) | 0x80;
    v15[3] = (v2 & 0xFE00000) >> 21;
    v16 = 4;
  }
  else if ((v2 & 0x1FC000) != 0)
  {
    *v15 = v2 | 0x80;
    v15[1] = (v2 >> 7) | 0x80;
    v15[2] = (v2 & 0x1FC000) >> 14;
    v16 = 3;
  }
  else if ((v2 & 0x3F80) != 0)
  {
    *v15 = v2 | 0x80;
    v15[1] = (v2 & 0x3F80) >> 7;
    v16 = 2;
  }
  else
  {
    *v15 = v2;
    v16 = 1;
  }
  v24 = &v15[v16];
  v25 = a1[3];
  if (HIDWORD(v25))
  {
    if ((v25 & 0x8000000000000000) != 0)
    {
      *v24 = v25 | 0x80;
      v29 = (uint64x2_t)vdupq_n_s64(v25);
      *(int8x8_t *)(v24 + 1) = vorr_s8(vmovn_s16(vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v29, (uint64x2_t)xmmword_1B8631BA0), (int32x4_t)vshlq_u64(v29, (uint64x2_t)xmmword_1B8631B90)), (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v29, (uint64x2_t)xmmword_1B8631CB0), (int32x4_t)vshlq_u64(v29, (uint64x2_t)xmmword_1B8631CA0)))), (int8x8_t)0x8080808080808080);
      v24[9] = 1;
      v26 = 10;
    }
    else if ((v25 & 0x7F00000000000000) != 0)
    {
      v27 = (uint64x2_t)vdupq_n_s64(v25);
      *v24 = v25 | 0x80;
      v28 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v27, (uint64x2_t)xmmword_1B8631BA0), (int32x4_t)vshlq_u64(v27, (uint64x2_t)xmmword_1B8631B90));
      v28.i64[0] = *(_QWORD *)&vmovn_s32((int32x4_t)v28) | 0x80008000800080;
      *(_DWORD *)(v24 + 1) = vmovn_s16(v28).u32[0];
      v24[5] = (v25 >> 35) | 0x80;
      v24[6] = (v25 >> 42) | 0x80;
      v24[7] = (v25 >> 49) | 0x80;
      v24[8] = HIBYTE(v25) & 0x7F;
      v26 = 9;
    }
    else if ((v25 & 0xFE000000000000) != 0)
    {
      *v24 = v25 | 0x80;
      v30 = (uint64x2_t)vdupq_n_s64(v25);
      v31 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v30, (uint64x2_t)xmmword_1B8631BA0), (int32x4_t)vshlq_u64(v30, (uint64x2_t)xmmword_1B8631B90));
      v31.i64[0] = *(_QWORD *)&vmovn_s32((int32x4_t)v31) | 0x80008000800080;
      *(_DWORD *)(v24 + 1) = vmovn_s16(v31).u32[0];
      v24[5] = (v25 >> 35) | 0x80;
      v24[6] = (v25 >> 42) | 0x80;
      v24[7] = (v25 & 0xFE000000000000) >> 49;
      v26 = 8;
    }
    else
    {
      *v24 = v25 | 0x80;
      v32 = (uint64x2_t)vdupq_n_s64(v25);
      v33 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v32, (uint64x2_t)xmmword_1B8631BA0), (int32x4_t)vshlq_u64(v32, (uint64x2_t)xmmword_1B8631B90));
      v33.i64[0] = *(_QWORD *)&vmovn_s32((int32x4_t)v33) | 0x80008000800080;
      *(_DWORD *)(v24 + 1) = vmovn_s16(v33).u32[0];
      if ((v25 & 0x1FC0000000000) != 0)
      {
        v24[5] = (v25 >> 35) | 0x80;
        v24[6] = (v25 & 0x1FC0000000000) >> 42;
        v26 = 7;
      }
      else
      {
        v24[5] = (v25 >> 35) & 0x7F;
        v26 = 6;
      }
    }
  }
  else if ((v25 & 0x7F0000000) != 0)
  {
    *v24 = v25 | 0x80;
    v24[1] = (v25 >> 7) | 0x80;
    v24[2] = (v25 >> 14) | 0x80;
    v24[3] = (v25 >> 21) | 0x80;
    v24[4] = (v25 & 0x7F0000000) >> 28;
    v26 = 5;
  }
  else if ((v25 & 0xFE00000) != 0)
  {
    *v24 = v25 | 0x80;
    v24[1] = (v25 >> 7) | 0x80;
    v24[2] = (v25 >> 14) | 0x80;
    v24[3] = (v25 & 0xFE00000) >> 21;
    v26 = 4;
  }
  else if ((v25 & 0x1FC000) != 0)
  {
    *v24 = v25 | 0x80;
    v24[1] = (v25 >> 7) | 0x80;
    v24[2] = (v25 & 0x1FC000) >> 14;
    v26 = 3;
  }
  else if ((v25 & 0x3F80) != 0)
  {
    *v24 = v25 | 0x80;
    v24[1] = (v25 & 0x3F80) >> 7;
    v26 = 2;
  }
  else
  {
    *v24 = v25;
    v26 = 1;
  }
  v34 = &v24[v26];
  v35 = *a1;
  if (HIDWORD(*a1))
  {
    if ((v35 & 0x8000000000000000) != 0)
    {
      *v34 = v35 | 0x80;
      v38 = (uint64x2_t)vdupq_n_s64(v35);
      *(int8x8_t *)(v34 + 1) = vorr_s8(vmovn_s16(vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v38, (uint64x2_t)xmmword_1B8631BA0), (int32x4_t)vshlq_u64(v38, (uint64x2_t)xmmword_1B8631B90)), (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v38, (uint64x2_t)xmmword_1B8631CB0), (int32x4_t)vshlq_u64(v38, (uint64x2_t)xmmword_1B8631CA0)))), (int8x8_t)0x8080808080808080);
      v34[9] = 1;
    }
    else if ((v35 & 0x7F00000000000000) != 0)
    {
      *v34 = v35 | 0x80;
      v36 = (uint64x2_t)vdupq_n_s64(v35);
      v37 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v36, (uint64x2_t)xmmword_1B8631BA0), (int32x4_t)vshlq_u64(v36, (uint64x2_t)xmmword_1B8631B90));
      v37.i64[0] = *(_QWORD *)&vmovn_s32((int32x4_t)v37) | 0x80008000800080;
      *(_DWORD *)(v34 + 1) = vmovn_s16(v37).u32[0];
      v34[5] = (v35 >> 35) | 0x80;
      v34[6] = (v35 >> 42) | 0x80;
      v34[7] = (v35 >> 49) | 0x80;
      v34[8] = HIBYTE(v35) & 0x7F;
    }
    else if ((v35 & 0xFE000000000000) != 0)
    {
      *v34 = v35 | 0x80;
      v39 = (uint64x2_t)vdupq_n_s64(v35);
      v40 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v39, (uint64x2_t)xmmword_1B8631BA0), (int32x4_t)vshlq_u64(v39, (uint64x2_t)xmmword_1B8631B90));
      v40.i64[0] = *(_QWORD *)&vmovn_s32((int32x4_t)v40) | 0x80008000800080;
      *(_DWORD *)(v34 + 1) = vmovn_s16(v40).u32[0];
      v34[5] = (v35 >> 35) | 0x80;
      v34[6] = (v35 >> 42) | 0x80;
      v34[7] = (v35 & 0xFE000000000000) >> 49;
    }
    else
    {
      *v34 = v35 | 0x80;
      v41 = (uint64x2_t)vdupq_n_s64(v35);
      v42 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v41, (uint64x2_t)xmmword_1B8631BA0), (int32x4_t)vshlq_u64(v41, (uint64x2_t)xmmword_1B8631B90));
      v42.i64[0] = *(_QWORD *)&vmovn_s32((int32x4_t)v42) | 0x80008000800080;
      *(_DWORD *)(v34 + 1) = vmovn_s16(v42).u32[0];
      if ((v35 & 0x1FC0000000000) != 0)
      {
        v34[5] = (v35 >> 35) | 0x80;
        v34[6] = (v35 & 0x1FC0000000000) >> 42;
      }
      else
      {
        v34[5] = (v35 >> 35) & 0x7F;
      }
    }
  }
  else if ((v35 & 0x7F0000000) != 0)
  {
    *v34 = v35 | 0x80;
    v34[1] = (v35 >> 7) | 0x80;
    v34[2] = (v35 >> 14) | 0x80;
    v34[3] = (v35 >> 21) | 0x80;
    v34[4] = (v35 & 0x7F0000000) >> 28;
  }
  else if ((v35 & 0xFE00000) != 0)
  {
    *v34 = v35 | 0x80;
    v34[1] = (v35 >> 7) | 0x80;
    v34[2] = (v35 >> 14) | 0x80;
    v34[3] = (v35 & 0xFE00000) >> 21;
  }
  else if ((v35 & 0x1FC000) != 0)
  {
    *v34 = v35 | 0x80;
    v34[1] = (v35 >> 7) | 0x80;
    v34[2] = (v35 & 0x1FC000) >> 14;
  }
  else if ((v35 & 0x3F80) != 0)
  {
    *v34 = v35 | 0x80;
    v34[1] = (v35 & 0x3F80) >> 7;
  }
  else
  {
    *v34 = v35;
  }
  return fd_pwrite(a1[5], (uint64_t)v49, 0x400uLL, 0);
}

void AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,768>::~AllocatedVectorQuantizer(uint64_t a1)
{
  AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,768>::~AllocatedVectorQuantizer(a1);
  JUMPOUT(0x1BCCB06A4);
}

uint64_t AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,768>::version(uint64_t a1)
{
  return *(unsigned int *)(a1 + 52);
}

uint64_t AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,768>::count(uint64_t a1)
{
  return *(unsigned int *)(a1 + 48);
}

uint64_t Quantizer<float,768>::dimension()
{
  return 768;
}

uint64_t Quantizer<float,768>::elementSize()
{
  return 4;
}

BOOL Quantizer<float,768>::operator==(uint64_t a1, uint64_t a2)
{
  int v4;
  uint64_t v5;
  const void *v6;
  const void *v7;
  int v8;
  _BOOL8 result;
  char *v10;
  char *v11;
  const char *v12;
  char *v13;
  const char *v14;

  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)a2 + 32))(a2) != 768)
  {
    v10 = __si_assert_copy_extra_268();
    v11 = v10;
    v12 = "";
    if (v10)
      v12 = v10;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 282, "D == other.dimension()", v12);
LABEL_17:
    free(v11);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  if ((*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 40))(a2) != 4)
  {
    v13 = __si_assert_copy_extra_268();
    v11 = v13;
    v14 = "";
    if (v13)
      v14 = v13;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 283, "sizeof(ELEM_TYPE) == other.elementSize()", v14);
    goto LABEL_17;
  }
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
  if (v4 != (*(unsigned int (**)(uint64_t))(*(_QWORD *)a2 + 24))(a2))
    return 0;
  if (!(*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1))
    return 1;
  v5 = 0;
  while (1)
  {
    v6 = (const void *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 64))(a1, v5);
    v7 = (const void *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 64))(a2, v5);
    v8 = memcmp(v6, v7, 0xC00uLL);
    result = v8 == 0;
    if (v8)
      break;
    v5 = (v5 + 1);
    if (v5 >= (*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1))
      return 1;
  }
  return result;
}

BOOL Quantizer<float,768>::isPersistent(uint64_t a1)
{
  _QWORD *v1;
  int v2;

  v1 = (_QWORD *)(a1 + 8);
  v2 = *(char *)(a1 + 31);
  if ((v2 & 0x80000000) == 0)
  {
    if (v2 != 8)
      return 1;
    return *v1 != 0x3E79726F6D656D3CLL;
  }
  if (*(_QWORD *)(a1 + 16) == 8)
  {
    v1 = (_QWORD *)*v1;
    return *v1 != 0x3E79726F6D656D3CLL;
  }
  return 1;
}

unint64_t AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,768>::getCentroid(uint64_t a1, unsigned int a2)
{
  char *v3;
  char *v4;
  const char *v5;

  if (*(_DWORD *)(a1 + 48) <= a2)
  {
    v3 = __si_assert_copy_extra_268();
    v4 = v3;
    v5 = "";
    if (v3)
      v5 = v3;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 514, "i < nCentroids", v5);
    free(v4);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  return _windowsResolvePtr(*(_QWORD *)(a1 + 40) + 40, *(_QWORD *)(*(_QWORD *)(a1 + 40) + 24) + *(_QWORD *)(*(_QWORD *)(a1 + 40) + 16) * a2, 0xC00uLL);
}

void Quantizer<float,768>::topKPartitions(uint64_t a1@<X0>, const float *a2@<X1>, unsigned int a3@<W2>, int **a4@<X8>)
{
  char *v7;
  char *v8;
  char *v9;
  unint64_t v10;
  unint64_t v11;
  const float *v12;
  const float *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  float v17;
  int v18;
  _BOOL4 v19;
  uint64_t v20;
  char *v21;
  float v22;
  float v23;
  float v24;
  _BOOL4 v25;
  float *v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  _BYTE *v30;
  _DWORD *v31;
  unint64_t v32;
  char *v33;
  char *v34;
  uint64_t v35;
  char *v36;
  uint64_t v37;
  unint64_t v38;
  float *v39;
  float v40;
  float v41;
  int v42;
  float v43;
  _BOOL4 v44;
  float *v45;
  float v46;
  BOOL v47;
  unint64_t v48;
  float *v49;
  unsigned int v50;
  char *v51;
  float v52;
  float v53;
  int v54;
  _BOOL4 v55;
  float *v56;
  float v57;
  BOOL v58;
  char *v59;
  unint64_t v60;
  float *v61;
  float v62;
  int v63;
  _BOOL4 v64;
  float *v65;
  float v66;
  BOOL v67;
  uint64_t v68;
  _OWORD *v69;
  char *v70;
  uint64_t v71;
  __int128 v72;
  uint64_t v73;
  int *v74;
  float *v75;
  uint64_t v76;
  uint64_t v78;
  int v79;
  int v80;
  float *v81;
  float v82;
  float v83;
  float v84;
  _BOOL4 v85;
  float *v86;
  uint64_t v87;
  char *v88;
  uint64_t v89;
  unint64_t v90;
  float *v91;
  float v92;
  float v93;
  float v94;
  float v95;
  _BOOL4 v96;
  float *v97;
  float v98;
  BOOL v99;
  int **v100;
  unsigned int __C;

  if (!(*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1))
  {
    v7 = 0;
    v75 = 0;
    v74 = 0;
    *a4 = 0;
    a4[1] = 0;
    a4[2] = 0;
    goto LABEL_74;
  }
  v100 = a4;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = a3;
  v12 = a2;
  do
  {
    v13 = (const float *)(*(uint64_t (**)(uint64_t, unint64_t))(*(_QWORD *)a1 + 64))(a1, v10);
    __C = 2139095039;
    vDSP_distancesq(v13, 1, v12, 1, (float *)&__C, 0x300uLL);
    v14 = (v10 | ((unint64_t)__C << 32)) >> 32;
    v15 = v7 - v9;
    v16 = (v7 - v9) >> 3;
    if (v16 < v11)
    {
      if (v7 < v8)
      {
        *(_DWORD *)v7 = v10;
        *((_DWORD *)v7 + 1) = v14;
        v7 += 8;
LABEL_47:
        if (v7 - v9 >= 9)
        {
          v48 = (((unint64_t)(v7 - v9) >> 3) - 2) >> 1;
          v49 = (float *)&v9[8 * v48];
          v51 = v7 - 8;
          v50 = *((_DWORD *)v7 - 2);
          v52 = v49[1];
          v53 = *((float *)v7 - 1);
          v54 = *(_DWORD *)v49;
          v55 = *(_DWORD *)v49 < v50;
          if (v52 != v53)
            v55 = v52 < v53;
          if (v55)
          {
            do
            {
              v56 = v49;
              *(_DWORD *)v51 = v54;
              *((float *)v51 + 1) = v49[1];
              if (!v48)
                break;
              v48 = (v48 - 1) >> 1;
              v49 = (float *)&v9[8 * v48];
              v57 = v49[1];
              v54 = *(_DWORD *)v49;
              v58 = v57 < v53;
              if (v57 == v53)
                v58 = *(_DWORD *)v49 < v50;
              v51 = (char *)v56;
            }
            while (v58);
            *(_DWORD *)v56 = v50;
            v56[1] = v53;
          }
        }
        goto LABEL_4;
      }
      if ((v8 - v9) >> 2 <= (unint64_t)(v16 + 1))
        v28 = v16 + 1;
      else
        v28 = (v8 - v9) >> 2;
      if ((unint64_t)(v8 - v9) >= 0x7FFFFFFFFFFFFFF8)
        v28 = 0x1FFFFFFFFFFFFFFFLL;
      if (v28 >> 61)
        std::__throw_bad_array_new_length[abi:nn180100]();
      v29 = 8 * v28;
      v30 = operator new(8 * v28);
      v31 = &v30[8 * v16];
      *v31 = v10;
      v31[1] = v14;
      if (v7 == v9)
      {
        v36 = v7;
        v9 = &v30[8 * v16];
        goto LABEL_44;
      }
      v32 = v7 - v9 - 8;
      if (v32 >= 0x58 && (unint64_t)(v9 - v30) >= 0x20)
      {
        v68 = (v32 >> 3) + 1;
        v33 = &v7[-8 * (v68 & 0x3FFFFFFFFFFFFFFCLL)];
        v69 = &v30[8 * v16 - 16];
        v70 = v7 - 16;
        v71 = v68 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          v72 = *(_OWORD *)v70;
          *(v69 - 1) = *((_OWORD *)v70 - 1);
          *v69 = v72;
          v69 -= 2;
          v70 -= 32;
          v71 -= 4;
        }
        while (v71);
        v34 = (char *)&v31[-2 * (v68 & 0x3FFFFFFFFFFFFFFCLL)];
        if (v68 == (v68 & 0x3FFFFFFFFFFFFFFCLL))
          goto LABEL_32;
      }
      else
      {
        v33 = v7;
        v34 = &v30[8 * v16];
      }
      do
      {
        v35 = *((_QWORD *)v33 - 1);
        v33 -= 8;
        *((_QWORD *)v34 - 1) = v35;
        v34 -= 8;
      }
      while (v33 != v9);
LABEL_32:
      v36 = v9;
      v9 = v34;
LABEL_44:
      v8 = &v30[v29];
      v7 = (char *)(v31 + 2);
      if (v36)
        operator delete(v36);
      v12 = a2;
      goto LABEL_47;
    }
    v17 = *((float *)v9 + 1);
    v18 = *(_DWORD *)v9;
    v19 = *(_DWORD *)v9 > v10;
    if (v17 != *(float *)&v14)
      v19 = v17 > *(float *)&v14;
    if (v19)
    {
      if (v15 <= 8)
      {
        *((_DWORD *)v7 - 2) = v10;
        *((_DWORD *)v7 - 1) = v14;
      }
      else
      {
        v20 = 0;
        v21 = v9;
        do
        {
          v26 = (float *)&v21[8 * v20 + 8];
          v27 = (2 * v20) | 1;
          v20 = 2 * v20 + 2;
          if (v20 < v16)
          {
            v22 = v26[1];
            v23 = v26[3];
            v24 = *v26;
            v25 = *(_DWORD *)v26 < *((_DWORD *)v26 + 2);
            if (v22 != v23)
              v25 = v22 < v23;
            if (v25)
            {
              v24 = v26[2];
              v26 += 2;
            }
            else
            {
              v20 = v27;
            }
          }
          else
          {
            v24 = *v26;
            v20 = v27;
          }
          *(float *)v21 = v24;
          *((float *)v21 + 1) = v26[1];
          v21 = (char *)v26;
        }
        while (v20 <= (uint64_t)((unint64_t)(v16 - 2) >> 1));
        if (v26 == (float *)(v7 - 8))
        {
          *(_DWORD *)v26 = v18;
          v26[1] = v17;
        }
        else
        {
          *v26 = *((float *)v7 - 2);
          v26[1] = *((float *)v7 - 1);
          *((_DWORD *)v7 - 2) = v18;
          *((float *)v7 - 1) = v17;
          v37 = (char *)v26 - v9 + 8;
          if (v37 >= 9)
          {
            v38 = (((unint64_t)v37 >> 3) - 2) >> 1;
            v39 = (float *)&v9[8 * v38];
            v40 = v39[1];
            v41 = v26[1];
            v42 = *(_DWORD *)v39;
            v43 = *v26;
            v44 = *(_DWORD *)v39 < *(_DWORD *)v26;
            if (v40 != v41)
              v44 = v40 < v41;
            if (v44)
            {
              do
              {
                v45 = v39;
                *(_DWORD *)v26 = v42;
                v26[1] = v39[1];
                if (!v38)
                  break;
                v38 = (v38 - 1) >> 1;
                v39 = (float *)&v9[8 * v38];
                v46 = v39[1];
                v42 = *(_DWORD *)v39;
                v47 = v46 < v41;
                if (v46 == v41)
                  v47 = *(_DWORD *)v39 < LODWORD(v43);
                v26 = v45;
              }
              while (v47);
              *v45 = v43;
              v45[1] = v41;
            }
          }
        }
        *((_DWORD *)v7 - 2) = v10;
        *((_DWORD *)v7 - 1) = v14;
        v59 = v7 - 8;
        v60 = (((unint64_t)v15 >> 3) - 2) >> 1;
        v61 = (float *)&v9[8 * v60];
        v62 = v61[1];
        v63 = *(_DWORD *)v61;
        v64 = *(_DWORD *)v61 < v10;
        if (v62 != *(float *)&v14)
          v64 = v62 < *(float *)&v14;
        if (v64)
        {
          do
          {
            v65 = v61;
            *(_DWORD *)v59 = v63;
            *((float *)v59 + 1) = v61[1];
            if (!v60)
              break;
            v60 = (v60 - 1) >> 1;
            v61 = (float *)&v9[8 * v60];
            v66 = v61[1];
            v63 = *(_DWORD *)v61;
            v67 = v66 < *(float *)&v14;
            if (v66 == *(float *)&v14)
              v67 = *(_DWORD *)v61 < v10;
            v59 = (char *)v65;
          }
          while (v67);
          *(_DWORD *)v65 = v10;
          *((_DWORD *)v65 + 1) = v14;
        }
      }
    }
LABEL_4:
    ++v10;
  }
  while (v10 < (*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1));
  *v100 = 0;
  v100[1] = 0;
  v100[2] = 0;
  v73 = v7 - v9;
  if (v7 == v9)
  {
    v75 = 0;
    v74 = 0;
  }
  else
  {
    if (v73 < 0)
      abort();
    v74 = (int *)operator new(v7 - v9);
    *v100 = v74;
    v100[2] = &v74[2 * (v73 >> 3)];
    memcpy(v74, v9, v73 & 0xFFFFFFFFFFFFFFF8);
    v75 = (float *)((char *)v74 + (v73 & 0xFFFFFFFFFFFFFFF8));
    v100[1] = (int *)v75;
    v7 = v9;
  }
LABEL_74:
  if ((char *)v75 - (char *)v74 >= 9)
  {
    v76 = (unint64_t)((char *)v75 - (char *)v74) >> 3;
    do
    {
      v78 = 0;
      v79 = *v74;
      v80 = v74[1];
      v81 = (float *)v74;
      do
      {
        v86 = &v81[2 * v78 + 2];
        v87 = (2 * v78) | 1;
        v78 = 2 * v78 + 2;
        if (v78 < v76)
        {
          v82 = v86[1];
          v83 = v86[3];
          v84 = *v86;
          v85 = *(_DWORD *)v86 < *((_DWORD *)v86 + 2);
          if (v82 != v83)
            v85 = v82 < v83;
          if (v85)
          {
            v84 = v86[2];
            v86 += 2;
          }
          else
          {
            v78 = v87;
          }
        }
        else
        {
          v84 = *v86;
          v78 = v87;
        }
        *v81 = v84;
        v81[1] = v86[1];
        v81 = v86;
      }
      while (v78 <= (uint64_t)((unint64_t)(v76 - 2) >> 1));
      v88 = (char *)(v75 - 2);
      if (v86 == v75 - 2)
      {
        *(_DWORD *)v86 = v79;
        *((_DWORD *)v86 + 1) = v80;
      }
      else
      {
        *v86 = *(v75 - 2);
        v86[1] = *(v75 - 1);
        *((_DWORD *)v75 - 2) = v79;
        *((_DWORD *)v75 - 1) = v80;
        v89 = (char *)v86 - (char *)v74 + 8;
        if (v89 >= 9)
        {
          v90 = (((unint64_t)v89 >> 3) - 2) >> 1;
          v91 = (float *)&v74[2 * v90];
          v92 = v91[1];
          v93 = v86[1];
          v94 = *v91;
          v95 = *v86;
          v96 = *(_DWORD *)v91 < *(_DWORD *)v86;
          if (v92 != v93)
            v96 = v92 < v93;
          if (v96)
          {
            do
            {
              v97 = v91;
              *v86 = v94;
              v86[1] = v91[1];
              if (!v90)
                break;
              v90 = (v90 - 1) >> 1;
              v91 = (float *)&v74[2 * v90];
              v98 = v91[1];
              v94 = *v91;
              v99 = v98 < v93;
              if (v98 == v93)
                v99 = *(_DWORD *)v91 < LODWORD(v95);
              v86 = v97;
            }
            while (v99);
            *v97 = v95;
            v97[1] = v93;
          }
        }
      }
      v75 = (float *)v88;
    }
    while (v76-- > 2);
  }
  if (v7)
    operator delete(v7);
}

uint64_t AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,768>::~AllocatedVectorQuantizer(uint64_t a1)
{
  unsigned __int8 v2;
  uint64_t v3;
  const void *v4;
  uint64_t v5;
  const void *v6;

  *(_QWORD *)a1 = &off_1E6E33288;
  v2 = atomic_load((unsigned __int8 *)(a1 + 57));
  if ((v2 & 1) != 0)
    vi_onefixedsize_disk_allocator::unlinkStorage(*(_QWORD *)(a1 + 40));
  v3 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 40) = 0;
  if (v3)
  {
    storage_array_Close(v3 + 8);
    v4 = *(const void **)(v3 + 4208);
    if (v4)
    {
      CFRelease(v4);
      *(_QWORD *)(v3 + 4208) = 0;
    }
    *(_OWORD *)(v3 + 4192) = 0u;
    MEMORY[0x1BCCB06A4](v3, 0x10A0C408BE2A288);
  }
  fd_release(*(char **)(a1 + 64));
  v5 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 40) = 0;
  if (v5)
  {
    storage_array_Close(v5 + 8);
    v6 = *(const void **)(v5 + 4208);
    if (v6)
    {
      CFRelease(v6);
      *(_QWORD *)(v5 + 4208) = 0;
    }
    *(_OWORD *)(v5 + 4192) = 0u;
    MEMORY[0x1BCCB06A4](v5, 0x10A0C408BE2A288);
  }
  *(_QWORD *)a1 = off_1E6E30F58;
  if (*(char *)(a1 + 31) < 0)
    operator delete(*(void **)(a1 + 8));
  return a1;
}

BOOL vi_onefixedsize_disk_allocator::unlinkStorage(uint64_t a1)
{
  char *v2;
  char *v3;
  char *v4;
  char *sibling_protected;
  char *v6;
  char *v8;
  char *v9;
  const char *v10;
  char v11[1024];
  char v12[1024];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  bzero(v12, 0x400uLL);
  v2 = fd_name(*(_QWORD *)(a1 + 40), v12, 0x400uLL);
  if (v2)
  {
    bzero(v11, 0x400uLL);
    v3 = fd_name(*(_QWORD *)(a1 + 40), v11, 0x400uLL);
    v4 = v3;
    if (v3)
    {
      strlcat(v3, ".shadow", 0x400uLL);
      sibling_protected = (char *)fd_create_sibling_protected(*(_QWORD *)(a1 + 40), v4, 0, 0);
      if (sibling_protected)
      {
        v6 = sibling_protected;
        _fd_unlink_with_origin((uint64_t)sibling_protected, 0);
        fd_release(v6);
      }
    }
    _fd_unlink_with_origin(*(_QWORD *)(a1 + 40), 0);
    if (strstr(v4, ".shadow.shadow"))
    {
      v8 = __si_assert_copy_extra_268();
      v9 = v8;
      v10 = "";
      if (v8)
        v10 = v8;
      __message_assert("%s:%u: failed assertion '%s' %s ", "VectorIndexSupport.hh", 362, "0==strstr(shadowpathPtr, \".shadow.shadow\")", v10);
      free(v9);
      if (__valid_fs(-1))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
  }
  return v2 != 0;
}

uint64_t AnyQuantizer::version(AnyQuantizer *this)
{
  return 0;
}

void ___ZN19ZeroVectorQuantizerIfLi768EE14sharedInstanceEv_block_invoke()
{
  uint64_t v0;
  unsigned __int8 v1;
  void **v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  std::ios_base *v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  std::__shared_weak_count *v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  __int128 v18;
  uint64_t v19;
  char __str[8];
  uint64_t v21;
  uint64_t v22;
  _OWORD v23[4];
  void *__p[2];
  __int128 v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v0 = operator new();
  if ((v1 & 1) == 0
  {
    bzero(&ZeroVectorQuantizer<float,768>::centroid(void)::centroid, 0xC00uLL);
  }
  if (ZeroVectorQuantizer<float,768>::centroid(void)::onceToken != -1)
    dispatch_once(&ZeroVectorQuantizer<float,768>::centroid(void)::onceToken, &__block_literal_global_733);
  *(_QWORD *)(v0 + 8) = 0;
  v2 = (void **)(v0 + 8);
  *(_QWORD *)(v0 + 16) = 0;
  *(_QWORD *)(v0 + 24) = 0;
  *(_QWORD *)v0 = off_1E6E330F8;
  memcpy((void *)(v0 + 33), &ZeroVectorQuantizer<float,768>::centroid(void)::centroid, 0xC00uLL);
  bzero(__str, 0x400uLL);
  snprintf(__str, 0x400uLL, "S%08x%08x-1x%dx%u", ZeroVectorQuantizer<float,768>::centroid(void)::centroid, dword_1EF1B067C, 768, 32);
  MEMORY[0x1BCCB03B0](v0 + 8, __str);
  *(_QWORD *)v0 = off_1E6E33058;
  v36 = 0u;
  v26 = 0;
  v35 = 0u;
  v34 = 0u;
  v33 = 0u;
  v32 = 0u;
  v31 = 0u;
  v30 = 0u;
  v29 = 0u;
  v28 = 0u;
  v25 = 0u;
  *(_OWORD *)__p = 0u;
  memset(v23, 0, sizeof(v23));
  v3 = MEMORY[0x1E0DE4FD0];
  v4 = MEMORY[0x1E0DE4FD0] + 104;
  v27 = MEMORY[0x1E0DE4FD0] + 104;
  v5 = (_QWORD *)MEMORY[0x1E0DE4F50];
  v6 = MEMORY[0x1E0DE4FD0] + 64;
  v7 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 16);
  v8 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 24);
  v22 = MEMORY[0x1E0DE4FD0] + 64;
  *(_QWORD *)__str = v7;
  *(_QWORD *)&__str[*(_QWORD *)(v7 - 24)] = v8;
  v21 = 0;
  v9 = (std::ios_base *)&__str[*(_QWORD *)(*(_QWORD *)__str - 24)];
  std::ios_base::init(v9, v23);
  v9[1].__vftable = 0;
  v9[1].__fmtflags_ = -1;
  v10 = v5[5];
  v22 = v5[4];
  *(uint64_t *)((char *)&v22 + *(_QWORD *)(v22 - 24)) = v10;
  *(_QWORD *)__str = v5[1];
  *(_QWORD *)&__str[*(_QWORD *)(*(_QWORD *)__str - 24)] = v5[6];
  v27 = v4;
  *(_QWORD *)__str = v3 + 24;
  v22 = v6;
  std::streambuf::basic_streambuf();
  v11 = MEMORY[0x1E0DE4FB8] + 16;
  *(_QWORD *)&v23[0] = MEMORY[0x1E0DE4FB8] + 16;
  *(_OWORD *)__p = 0u;
  v25 = 0u;
  LODWORD(v26) = 24;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v22, (uint64_t)"Z1000000000000000-1x", 20);
  v12 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v12, (uint64_t)"x", 1);
  std::ostream::operator<<();
  std::stringbuf::str();
  if (*(char *)(v0 + 31) < 0)
    operator delete(*v2);
  *(_OWORD *)v2 = v18;
  *(_QWORD *)(v0 + 24) = v19;
  *(_QWORD *)__str = *v5;
  v13 = v5[9];
  *(_QWORD *)&__str[*(_QWORD *)(*(_QWORD *)__str - 24)] = v5[8];
  v22 = v13;
  *(_QWORD *)&v23[0] = v11;
  if (SBYTE7(v25) < 0)
    operator delete(__p[0]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x1BCCB0650](&v27);
  v14 = (_QWORD *)operator new();
  *v14 = &off_1E6E33158;
  v14[1] = 0;
  v14[2] = 0;
  v14[3] = v0;
  v15 = (std::__shared_weak_count *)qword_1EF1AFA68;
  ZeroVectorQuantizer<float,768>::sharedInstance(void)::zvq = v0;
  qword_1EF1AFA68 = (uint64_t)v14;
  if (v15)
  {
    p_shared_owners = (unint64_t *)&v15->__shared_owners_;
    do
      v17 = __ldaxr(p_shared_owners);
    while (__stlxr(v17 - 1, p_shared_owners));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
}

void std::__shared_ptr_pointer<ZeroVectorQuantizer<float,768> *,std::shared_ptr<Quantizer<float,768>>::__shared_ptr_default_delete<Quantizer<float,768>,ZeroVectorQuantizer<float,768>>,std::allocator<ZeroVectorQuantizer<float,768>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BCCB06A4);
}

uint64_t std::__shared_ptr_pointer<ZeroVectorQuantizer<float,768> *,std::shared_ptr<Quantizer<float,768>>::__shared_ptr_default_delete<Quantizer<float,768>,ZeroVectorQuantizer<float,768>>,std::allocator<ZeroVectorQuantizer<float,768>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

_QWORD *std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  const std::locale::facet *v11;
  uint64_t v12;
  BOOL v13;
  size_t v14;
  size_t v15;
  std::locale::__imp *p_b;
  uint64_t v17;
  uint64_t v18;
  void *locale;
  uint64_t v20;
  uint64_t v21;
  _QWORD v23[2];
  std::locale __b;
  size_t v25;
  int64_t v26;

  v23[0] = 0;
  v23[1] = 0;
  MEMORY[0x1BCCB04A0](v23, a1);
  if (!LOBYTE(v23[0]))
    goto LABEL_32;
  v6 = (char *)a1 + *(_QWORD *)(*a1 - 24);
  v7 = *((_QWORD *)v6 + 5);
  v8 = a2 + a3;
  if ((*((_DWORD *)v6 + 2) & 0xB0) == 0x20)
    v9 = a2 + a3;
  else
    v9 = a2;
  v10 = *((_DWORD *)v6 + 36);
  if (v10 == -1)
  {
    std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)));
    v11 = std::locale::use_facet(&__b, MEMORY[0x1E0DE4A90]);
    v10 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v11->__vftable[2].~facet_0)(v11, 32);
    std::locale::~locale(&__b);
    *((_DWORD *)v6 + 36) = v10;
    if (!v7)
      goto LABEL_31;
  }
  else if (!v7)
  {
    goto LABEL_31;
  }
  v12 = *((_QWORD *)v6 + 3);
  v13 = v12 <= a3;
  v14 = v12 - a3;
  if (v13)
    v15 = 0;
  else
    v15 = v14;
  if (v9 - a2 >= 1
    && (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v7 + 96))(v7, a2, v9 - a2) != v9 - a2)
  {
    goto LABEL_31;
  }
  if ((uint64_t)v15 >= 1)
  {
    __b.__locale_ = 0;
    v25 = 0;
    v26 = 0;
    if (v15 >= 0x7FFFFFFFFFFFFFF8)
      abort();
    if (v15 >= 0x17)
    {
      v17 = (v15 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v15 | 7) != 0x17)
        v17 = v15 | 7;
      v18 = v17 + 1;
      p_b = (std::locale::__imp *)operator new(v17 + 1);
      v25 = v15;
      v26 = v18 | 0x8000000000000000;
      __b.__locale_ = p_b;
    }
    else
    {
      HIBYTE(v26) = v15;
      p_b = (std::locale::__imp *)&__b;
    }
    memset(p_b, v10, v15);
    *((_BYTE *)p_b + v15) = 0;
    if (v26 >= 0)
      locale = &__b;
    else
      locale = __b.__locale_;
    v20 = (*(uint64_t (**)(uint64_t, void *, size_t))(*(_QWORD *)v7 + 96))(v7, locale, v15);
    v21 = v20;
    if ((SHIBYTE(v26) & 0x80000000) == 0)
    {
      if (v20 != v15)
        goto LABEL_31;
      goto LABEL_28;
    }
    operator delete(__b.__locale_);
    if (v21 != v15)
    {
LABEL_31:
      std::ios_base::clear((std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24) + 32) | 5);
      goto LABEL_32;
    }
  }
LABEL_28:
  if (v8 - v9 >= 1
    && (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v7 + 96))(v7, v9, v8 - v9) != v8 - v9)
  {
    goto LABEL_31;
  }
  *((_QWORD *)v6 + 3) = 0;
LABEL_32:
  MEMORY[0x1BCCB04AC](v23);
  return a1;
}

uint64_t ZeroVectorQuantizer<float,768>::~ZeroVectorQuantizer(uint64_t a1)
{
  *(_QWORD *)a1 = off_1E6E30F58;
  if (*(char *)(a1 + 31) < 0)
    operator delete(*(void **)(a1 + 8));
  return a1;
}

void ZeroVectorQuantizer<float,768>::~ZeroVectorQuantizer(uint64_t a1)
{
  *(_QWORD *)a1 = off_1E6E30F58;
  if (*(char *)(a1 + 31) < 0)
    operator delete(*(void **)(a1 + 8));
  JUMPOUT(0x1BCCB06A4);
}

uint64_t SingleVectorQuantizer<float,768>::count()
{
  return 1;
}

uint64_t SingleVectorQuantizer<float,768>::getCentroid(uint64_t a1, int a2)
{
  char *v3;
  char *v4;
  const char *v5;

  if (a2)
  {
    v3 = __si_assert_copy_extra_268();
    v4 = v3;
    v5 = "";
    if (v3)
      v5 = v3;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 387, "i < 1", v5);
    free(v4);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  return a1 + 33;
}

float *SingleVectorQuantizer<float,768>::topKPartitions@<X0>(const float *__A@<X1>, uint64_t a2@<X0>, float **a3@<X8>)
{
  float v4;
  float *result;
  float __C;

  __C = 3.4028e38;
  vDSP_distancesq(__A, 1, (const float *)(a2 + 33), 1, &__C, 0x300uLL);
  v4 = __C;
  result = (float *)operator new(8uLL);
  a3[1] = result + 2;
  a3[2] = result + 2;
  *result = 0.0;
  result[1] = v4;
  *a3 = result;
  return result;
}

uint64_t SingleVectorQuantizer<float,768>::~SingleVectorQuantizer(uint64_t a1)
{
  *(_QWORD *)a1 = off_1E6E30F58;
  if (*(char *)(a1 + 31) < 0)
    operator delete(*(void **)(a1 + 8));
  return a1;
}

void SingleVectorQuantizer<float,768>::~SingleVectorQuantizer(uint64_t a1)
{
  *(_QWORD *)a1 = off_1E6E30F58;
  if (*(char *)(a1 + 31) < 0)
    operator delete(*(void **)(a1 + 8));
  JUMPOUT(0x1BCCB06A4);
}

void ___ZN19ZeroVectorQuantizerIfLi768EE8centroidEv_block_invoke()
{
  bzero(&unk_1EF1AFA84, 0xBFCuLL);
  ZeroVectorQuantizer<float,768>::centroid(void)::centroid = 1065353216;
}

uint64_t AnyPartitionStore::AnyPartitionStore(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;
  uint64_t v6;
  uint32_t v7;
  unsigned int v8;
  std::random_device v10;
  std::string __token;

  *(_QWORD *)a1 = &unk_1E6E310A8;
  *(_QWORD *)(a1 + 8) = *a2;
  v3 = a2[1];
  *(_QWORD *)(a1 + 16) = v3;
  if (v3)
  {
    v4 = (unint64_t *)(v3 + 8);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  *(_DWORD *)(a1 + 24) = 31;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 64) = 1;
  v6 = *a2;
  if (*a2)
    LODWORD(v6) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v6 + 16))(v6);
  *(_DWORD *)(a1 + 76) = v6;
  v10.__padding_ = 0;
  *((_BYTE *)&__token.__r_.__value_.__s + 23) = 12;
  strcpy((char *)&__token, "/dev/urandom");
  std::random_device::random_device(&v10, &__token);
  if (SHIBYTE(__token.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__token.__r_.__value_.__l.__data_);
  v7 = arc4random();
  v8 = v7 + ((v7 / 0x7FFFFFFF) | ((v7 / 0x7FFFFFFF) << 31));
  if (v8 <= 1)
    v8 = 1;
  *(_DWORD *)(a1 + 64) = v8;
  std::random_device::~random_device(&v10);
  return a1;
}

uint64_t vi_onefixedsize_disk_allocator::vi_onefixedsize_disk_allocator(uint64_t a1, uint64_t a2, uint64_t a3, __int128 *a4, uint64_t a5)
{
  uint64_t v9;
  void *v10;
  uint64_t v11;
  int v12;
  int v13;
  char v14;
  char v15;
  int v16;
  _QWORD v18[5];
  __int128 v19;
  __int128 v20;
  _QWORD aBlock[5];

  *(_QWORD *)a1 = 0;
  v9 = MEMORY[0x1E0C809B0];
  if (a5)
  {
    aBlock[0] = MEMORY[0x1E0C809B0];
    aBlock[1] = 0x40000000;
    aBlock[2] = ___ZN16vector_storage_s21copy_safe_unmap_blockEv_block_invoke;
    aBlock[3] = &__block_descriptor_tmp_82_5739;
    aBlock[4] = a5;
    v10 = _Block_copy(aBlock);
  }
  else
  {
    v10 = 0;
  }
  v11 = *(_QWORD *)a4;
  v12 = *((unsigned __int8 *)a4 + 21);
  v13 = *((_DWORD *)a4 + 4);
  v14 = *((_BYTE *)a4 + 20);
  v15 = *((_BYTE *)a4 + 22);
  v16 = *((_DWORD *)a4 + 6);
  v18[0] = v9;
  v18[1] = 0x40000000;
  v18[2] = ___ZN30vi_onefixedsize_disk_allocatorC2EmymN19vi_ondisk_allocator11meta_info_sEP16vector_storage_s_block_invoke;
  v18[3] = &__block_descriptor_tmp_80;
  v18[4] = a1;
  v19 = *a4;
  v20 = a4[1];
  storage_array_Init((_DWORD *)(a1 + 8), a2 + 1024, 0x40000uLL, a3, v11, v12, v13, v14, v15, v16, v10, (uint64_t)v18);
  if (*((_BYTE *)a4 + 21))
    vi_onefixedsize_disk_allocator::storeHeader((unint64_t *)a1);
  if (v10)
    _Block_release(v10);
  return a1;
}

void MaxSizePriorityQueue<AnyPartitionStore::CandidateEntry,std::vector<AnyPartitionStore::CandidateEntry>,AnyPartitionStore::CandidateQueue::Lesser>::push(_QWORD *a1, uint64_t a2)
{
  float *v4;
  float *v5;
  uint64_t v6;
  unint64_t v7;
  float *v8;
  uint64_t v9;
  uint64_t v10;
  float *v11;
  float *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  unint64_t v18;
  uint64_t v19;
  char *v20;
  char *v21;
  unint64_t v22;
  uint64_t v23;
  char *v24;
  __int128 *v25;
  uint64_t v26;
  __int128 v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  float v31;
  int v32;
  float *v33;
  int v34;
  float *v35;
  float *v36;
  uint64_t v37;
  unint64_t v38;
  float v39;
  int v40;
  float *v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  int v45;
  float *v46;

  v5 = (float *)a1[1];
  v4 = (float *)a1[2];
  v6 = ((char *)v4 - (char *)v5) >> 3;
  if (v6 >= (unint64_t)*(unsigned int *)a1)
  {
    if (*(float *)(a2 + 4) < v5[1])
    {
      if ((char *)v4 - (char *)v5 >= 9)
      {
        v9 = 0;
        v10 = *(_QWORD *)v5;
        v11 = (float *)a1[1];
        do
        {
          v12 = v11;
          v11 += 2 * v9 + 2;
          v13 = 2 * v9;
          v9 = (2 * v9) | 1;
          v14 = v13 + 2;
          if (v14 < v6 && v11[1] < v11[3])
          {
            v11 += 2;
            v9 = v14;
          }
          *(_QWORD *)v12 = *(_QWORD *)v11;
        }
        while (v9 <= (uint64_t)((unint64_t)(v6 - 2) >> 1));
        v36 = v4 - 2;
        if (v11 == v4 - 2)
        {
          *(_QWORD *)v11 = v10;
        }
        else
        {
          *(_QWORD *)v11 = *(_QWORD *)v36;
          *(_QWORD *)v36 = v10;
          v37 = (char *)v11 - (char *)v5 + 8;
          if (v37 >= 9)
          {
            v38 = (((unint64_t)v37 >> 3) - 2) >> 1;
            v39 = v11[1];
            if (v5[2 * v38 + 1] < v39)
            {
              v40 = *(_DWORD *)v11;
              do
              {
                v41 = v11;
                v11 = &v5[2 * v38];
                *(_QWORD *)v41 = *(_QWORD *)v11;
                if (!v38)
                  break;
                v38 = (v38 - 1) >> 1;
              }
              while (v5[2 * v38 + 1] < v39);
              *(_DWORD *)v11 = v40;
              v11[1] = v39;
            }
          }
        }
      }
      *(_QWORD *)(a1[2] - 8) = *(_QWORD *)a2;
      v42 = a1[1];
      v43 = a1[2];
      if (v43 - v42 >= 9)
      {
        v44 = (((unint64_t)(v43 - v42) >> 3) - 2) >> 1;
        v31 = *(float *)(v43 - 4);
        if (*(float *)(v42 + 8 * v44 + 4) < v31)
        {
          v45 = *(_DWORD *)(v43 - 8);
          v33 = (float *)(v43 - 8);
          v32 = v45;
          do
          {
            v46 = v33;
            v33 = (float *)(v42 + 8 * v44);
            *(_QWORD *)v46 = *(_QWORD *)v33;
            if (!v44)
              break;
            v44 = (v44 - 1) >> 1;
          }
          while (*(float *)(v42 + 8 * v44 + 4) < v31);
          goto LABEL_46;
        }
      }
    }
  }
  else
  {
    v7 = a1[3];
    if ((unint64_t)v4 >= v7)
    {
      v15 = v7 - (_QWORD)v5;
      if (v15 >> 2 <= (unint64_t)(v6 + 1))
        v16 = v6 + 1;
      else
        v16 = v15 >> 2;
      v17 = (unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8;
      v18 = 0x1FFFFFFFFFFFFFFFLL;
      if (!v17)
        v18 = v16;
      if (v18 >> 61)
        std::__throw_bad_array_new_length[abi:nn180100]();
      v19 = 8 * v18;
      v20 = (char *)operator new(8 * v18);
      v21 = &v20[8 * v6];
      *(_QWORD *)v21 = *(_QWORD *)a2;
      v8 = (float *)(v21 + 8);
      if (v4 != v5)
      {
        v22 = (char *)v4 - (char *)v5 - 8;
        if (v22 < 0x58)
          goto LABEL_51;
        if ((unint64_t)((char *)v5 - v20) < 0x20)
          goto LABEL_51;
        v23 = (v22 >> 3) + 1;
        v24 = &v20[8 * v6 - 16];
        v25 = (__int128 *)(v4 - 4);
        v26 = v23 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          v27 = *v25;
          *((_OWORD *)v24 - 1) = *(v25 - 1);
          *(_OWORD *)v24 = v27;
          v24 -= 32;
          v25 -= 2;
          v26 -= 4;
        }
        while (v26);
        v21 -= 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
        v4 -= 2 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
        if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_51:
          do
          {
            v28 = *((_QWORD *)v4 - 1);
            v4 -= 2;
            *((_QWORD *)v21 - 1) = v28;
            v21 -= 8;
          }
          while (v4 != v5);
        }
        v4 = v5;
      }
      a1[1] = v21;
      a1[2] = v8;
      a1[3] = &v20[v19];
      if (v4)
        operator delete(v4);
    }
    else
    {
      *(_QWORD *)v4 = *(_QWORD *)a2;
      v8 = v4 + 2;
    }
    a1[2] = v8;
    v29 = a1[1];
    if ((uint64_t)v8 - v29 >= 9)
    {
      v30 = ((((unint64_t)v8 - v29) >> 3) - 2) >> 1;
      v31 = *(v8 - 1);
      if (*(float *)(v29 + 8 * v30 + 4) < v31)
      {
        v34 = *((_DWORD *)v8 - 2);
        v33 = v8 - 2;
        v32 = v34;
        do
        {
          v35 = v33;
          v33 = (float *)(v29 + 8 * v30);
          *(_QWORD *)v35 = *(_QWORD *)v33;
          if (!v30)
            break;
          v30 = (v30 - 1) >> 1;
        }
        while (*(float *)(v29 + 8 * v30 + 4) < v31);
LABEL_46:
        *(_DWORD *)v33 = v32;
        v33[1] = v31;
      }
    }
  }
}

uint64_t ___ZN16vector_storage_s21copy_safe_unmap_blockEv_block_invoke(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  int v3;
  uint64_t (*v4)(_QWORD);
  uint64_t (*v5)(_QWORD);
  uint64_t (*v6)(_QWORD);

  v2 = *(_QWORD *)(*(_QWORD *)(result + 32) + 24);
  if (v2)
  {
    v3 = *(_DWORD *)(v2 + 216);
    switch(v3)
    {
      case -270471200:
        v5 = *(uint64_t (**)(_QWORD))(v2 + 424);
        if (v5)
          return v5(*(_QWORD *)(v2 + 432));
        break;
      case 1684300900:
        v6 = *(uint64_t (**)(_QWORD))(v2 + 4528);
        if (v6)
          return v6(*(_QWORD *)(v2 + 4536));
        break;
      case 842150450:
        v4 = *(uint64_t (**)(_QWORD))(v2 + 392);
        if (v4)
          return v4(*(_QWORD *)(v2 + 400));
        break;
      default:
        return result;
    }
  }
  return (*(uint64_t (**)(uint64_t))(a2 + 16))(a2);
}

uint64_t PartitionStore<vi_onefixedsize_disk_allocator,512>::newPartition(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unsigned int v5;
  unsigned int v6;
  _QWORD *v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unsigned int v17;
  unint64_t v18;
  _DWORD *v19;
  unint64_t v20;
  unint64_t v21;
  char *v22;
  _DWORD *v23;
  char *v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t v28;
  _BYTE *v29;
  _DWORD *v30;
  char *v31;
  unint64_t v32;
  uint64_t v33;
  _OWORD *v34;
  char *v35;
  uint64_t v36;
  __int128 v37;
  int v38;
  unint64_t v39;
  char *v40;
  char *v41;
  _BYTE *v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  unint64_t v46;
  char *v47;
  char *v48;
  uint64_t v49;
  int v50;
  char *v52;
  char *v53;
  const char *v54;
  char *v55;
  const char *v56;
  char *v57;
  char *v58;
  const char *v59;
  char *v60;
  const char *v61;
  uint64_t v62;

  v3 = *(_QWORD *)(a1 + 8);
  if (!v3)
  {
    v52 = __si_assert_copy_extra_268();
    v53 = v52;
    v54 = "";
    if (v52)
      v54 = v52;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 872, "_quantizer != nullptr", v54);
LABEL_72:
    free(v53);
    if (__valid_fs(-1))
      v62 = 2989;
    else
      v62 = 3072;
    *(_DWORD *)v62 = -559038737;
    abort();
  }
  v5 = *(_DWORD *)(a1 + 68);
  if (v5 > (*(unsigned int (**)(uint64_t))(*(_QWORD *)v3 + 24))(v3))
  {
    v55 = __si_assert_copy_extra_268();
    v53 = v55;
    v56 = "";
    if (v55)
      v56 = v55;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1317, "n_partitions <= quantizer()->count()", v56);
    goto LABEL_72;
  }
  v6 = *(_DWORD *)(a1 + 68);
  if (v6 > *(_DWORD *)(a1 + 88) - 1)
  {
    v57 = __si_assert_copy_extra_268();
    v58 = v57;
    v59 = "";
    if (v57)
      v59 = v57;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1318, "n_partitions <= max_partitions - 1", v59);
    free(v58);
    if (!__valid_fs(-1))
    {
      MEMORY[0xC00] = -559038737;
      abort();
    }
    MEMORY[0xBAD] = -559038737;
    goto LABEL_68;
  }
  if (v6 != (_DWORD)a2)
  {
    v60 = __si_assert_copy_extra_268();
    v53 = v60;
    v61 = "";
    if (v60)
      v61 = v60;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1320, "centOffset == partID", v61);
    goto LABEL_72;
  }
  v7 = *(_QWORD **)(a1 + 80);
  v8 = v7[2];
  v9 = v7[7];
  v10 = v9 + v8;
  if (v9 + v8 >= v7[6])
  {
    if (!_storage_array_Expand((uint64_t)(v7 + 1)))
    {
      v11 = 0;
      goto LABEL_7;
    }
    v9 = v7[7];
    v10 = v9 + v8;
  }
  v7[7] = v10;
  v11 = (v9 - v7[3]) / v8;
LABEL_7:
  if (v8 >> 2 <= 0x402)
  {
    v12 = v7[2];
    if (v12 >> 2 <= 0x402)
    {
      LODWORD(v13) = 4108;
      do
      {
        v14 = v7[7] + v12;
        if (v14 >= v7[6])
        {
          if (!_storage_array_Expand((uint64_t)(v7 + 1)))
            goto LABEL_12;
          v14 = v7[7] + v12;
        }
        v7[7] = v14;
LABEL_12:
        v12 = v7[2];
        v13 = (v13 - v12);
      }
      while (v12 < v13);
    }
  }
  v15 = (uint64_t)(v7 + 524);
  bit_vector_set_9027((uint64_t)(v7 + 524), (v11 >> 20));
  v16 = (v11 + 4108) >> 20;
  if (v16 > (v11 >> 20))
  {
    v17 = (v11 >> 20) + 1;
    do
    {
      v18 = v17;
      bit_vector_set_9027(v15, v17++);
    }
    while (v16 > v18);
  }
  v19 = (_DWORD *)_windowsResolvePtr(*(_QWORD *)(a1 + 80) + 40, *(_QWORD *)(*(_QWORD *)(a1 + 80) + 24) + *(_QWORD *)(*(_QWORD *)(a1 + 80) + 16) * v11, 0x100CuLL);
  bzero(v19, 0x100CuLL);
  v19[1] = a2;
  *(_DWORD *)(_windowsResolvePtr(*(_QWORD *)(a1 + 80) + 40, *(_QWORD *)(*(_QWORD *)(a1 + 80) + 24) + *(_QWORD *)(*(_QWORD *)(a1 + 80) + 16) * v11, 0x100CuLL)+ 12) = -1;
  ++*(_DWORD *)(a1 + 68);
  v20 = _windowsResolvePtr(*(_QWORD *)(a1 + 80) + 40, 0x400uLL, *(_QWORD *)(*(_QWORD *)(a1 + 80) + 16));
  *(_DWORD *)(v20 + 4 * a2 + 124) = v11;
  *(_DWORD *)(v20 + 8) = *(_DWORD *)(a1 + 68);
  v22 = *(char **)(a1 + 104);
  v21 = *(_QWORD *)(a1 + 112);
  if ((unint64_t)v22 >= v21)
  {
    v24 = *(char **)(a1 + 96);
    v25 = (v22 - v24) >> 2;
    v26 = v25 + 1;
    if ((unint64_t)(v25 + 1) >> 62)
      goto LABEL_68;
    v27 = v21 - (_QWORD)v24;
    if (v27 >> 1 > v26)
      v26 = v27 >> 1;
    if ((unint64_t)v27 >= 0x7FFFFFFFFFFFFFFCLL)
      v28 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v28 = v26;
    if (v28)
    {
      if (v28 >> 62)
        goto LABEL_80;
      v29 = operator new(4 * v28);
    }
    else
    {
      v29 = 0;
    }
    v30 = &v29[4 * v25];
    v31 = &v29[4 * v28];
    *v30 = v11;
    v23 = v30 + 1;
    if (v22 != v24)
    {
      v32 = v22 - v24 - 4;
      if (v32 < 0x2C)
        goto LABEL_83;
      if ((unint64_t)(v24 - v29) < 0x20)
        goto LABEL_83;
      v33 = (v32 >> 2) + 1;
      v34 = &v29[4 * v25 - 16];
      v35 = v22 - 16;
      v36 = v33 & 0x7FFFFFFFFFFFFFF8;
      do
      {
        v37 = *(_OWORD *)v35;
        *(v34 - 1) = *((_OWORD *)v35 - 1);
        *v34 = v37;
        v34 -= 2;
        v35 -= 32;
        v36 -= 8;
      }
      while (v36);
      v30 -= v33 & 0x7FFFFFFFFFFFFFF8;
      v22 -= 4 * (v33 & 0x7FFFFFFFFFFFFFF8);
      if (v33 != (v33 & 0x7FFFFFFFFFFFFFF8))
      {
LABEL_83:
        do
        {
          v38 = *((_DWORD *)v22 - 1);
          v22 -= 4;
          *--v30 = v38;
        }
        while (v22 != v24);
      }
    }
    *(_QWORD *)(a1 + 96) = v30;
    *(_QWORD *)(a1 + 104) = v23;
    *(_QWORD *)(a1 + 112) = v31;
    if (v24)
      operator delete(v24);
  }
  else
  {
    *(_DWORD *)v22 = v11;
    v23 = v22 + 4;
  }
  *(_QWORD *)(a1 + 104) = v23;
  v40 = *(char **)(a1 + 152);
  v39 = *(_QWORD *)(a1 + 160);
  if ((unint64_t)v40 < v39)
  {
    *(_QWORD *)v40 = a1;
    *((_DWORD *)v40 + 2) = a2;
    v41 = v40 + 16;
    goto LABEL_57;
  }
  v42 = *(_BYTE **)(a1 + 144);
  v43 = (v40 - v42) >> 4;
  v44 = v43 + 1;
  if ((unint64_t)(v43 + 1) >> 60)
LABEL_68:
    abort();
  v45 = v39 - (_QWORD)v42;
  if (v45 >> 3 > v44)
    v44 = v45 >> 3;
  if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFF0)
    v46 = 0xFFFFFFFFFFFFFFFLL;
  else
    v46 = v44;
  if (!v46)
  {
    v47 = 0;
    goto LABEL_52;
  }
  if (v46 >> 60)
LABEL_80:
    std::__throw_bad_array_new_length[abi:nn180100]();
  v47 = (char *)operator new(16 * v46);
LABEL_52:
  v48 = &v47[16 * v43];
  *(_QWORD *)v48 = a1;
  *((_DWORD *)v48 + 2) = a2;
  v41 = v48 + 16;
  if (v40 != v42)
  {
    do
    {
      v49 = *((_QWORD *)v40 - 2);
      v40 -= 16;
      v50 = *((_DWORD *)v40 + 2);
      *((_QWORD *)v48 - 2) = v49;
      v48 -= 16;
      *((_DWORD *)v48 + 2) = v50;
    }
    while (v40 != v42);
    v40 = *(char **)(a1 + 144);
  }
  *(_QWORD *)(a1 + 144) = v48;
  *(_QWORD *)(a1 + 152) = v41;
  *(_QWORD *)(a1 + 160) = &v47[16 * v46];
  if (v40)
    operator delete(v40);
LABEL_57:
  *(_QWORD *)(a1 + 152) = v41;
  return a2;
}

void PartitionStore<vi_onefixedsize_disk_allocator,512>::~PartitionStore(uint64_t a1)
{
  PartitionStore<vi_onefixedsize_disk_allocator,512>::~PartitionStore(a1);
  JUMPOUT(0x1BCCB06A4);
}

uint64_t PartitionStore<vi_onefixedsize_disk_allocator,512>::isPersistent()
{
  return 1;
}

unint64_t PartitionStore<vi_onefixedsize_disk_allocator,512>::farthestVectorInPartition(uint64_t a1, unsigned int a2)
{
  return _windowsResolvePtr(*(_QWORD *)(a1 + 80) + 40, *(_QWORD *)(*(_QWORD *)(a1 + 80) + 24)+ *(_QWORD *)(*(_QWORD *)(a1 + 80) + 16) * *(unsigned int *)(*(_QWORD *)(a1 + 96) + 4 * a2), 0x100CuLL)+ 12;
}

uint64_t PartitionStore<vi_onefixedsize_disk_allocator,512>::centOffsetForPartition(uint64_t a1, uint64_t a2)
{
  char *v4;
  char *v5;
  const char *v6;

  if (*(_DWORD *)(_windowsResolvePtr(*(_QWORD *)(a1 + 80) + 40, *(_QWORD *)(*(_QWORD *)(a1 + 80) + 24)+ *(_QWORD *)(*(_QWORD *)(a1 + 80) + 16)* *(unsigned int *)(*(_QWORD *)(a1 + 96) + 4 * a2), 0x100CuLL)+ 4) != (_DWORD)a2)
  {
    v4 = __si_assert_copy_extra_268();
    v5 = v4;
    v6 = "";
    if (v4)
      v6 = v4;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1257, "block->centOffset == partitionID", v6);
    free(v5);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  return a2;
}

uint64_t PartitionStore<vi_onefixedsize_disk_allocator,512>::vectorCountInPartition(uint64_t a1, unsigned int a2)
{
  int v2;
  BOOL v3;
  unsigned int v4;

  v2 = *(_DWORD *)(_windowsResolvePtr(*(_QWORD *)(a1 + 80) + 40, *(_QWORD *)(*(_QWORD *)(a1 + 80) + 24)+ *(_QWORD *)(*(_QWORD *)(a1 + 80) + 16) * *(unsigned int *)(*(_QWORD *)(a1 + 96) + 4 * a2), 0x100CuLL)+ 8);
  v3 = v2 != 0;
  v4 = v2 - 1;
  if (v3)
    return v4;
  else
    return 0;
}

unint64_t PartitionStore<vi_onefixedsize_disk_allocator,512>::append(uint64_t a1, unsigned int a2, unsigned int a3, float a4)
{
  unint64_t v6;
  int v7;
  char v8;
  _DWORD *v9;
  unint64_t v10;
  unint64_t v11;
  float *v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unsigned int v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  _DWORD **v23;
  unint64_t v24;
  unint64_t v25;
  pthread_rwlock_t *v26;
  unsigned int *v27;
  unsigned int *v28;
  unsigned int v29;
  unsigned int v30;
  void *v31;
  _QWORD *v32;
  char *v33;
  uint64_t v34;
  unsigned int v35;
  unsigned int v36;
  void *v37;
  uint64_t v38;
  unint64_t v39;
  unsigned int v40;
  unint64_t v41;
  pthread_rwlock_t *v42;
  unsigned int *sig;
  unsigned int *v44;
  unsigned int *v45;
  unsigned int v46;
  unsigned int v47;
  uint64_t v48;
  char *v49;
  uint64_t v50;
  _QWORD *v51;
  unsigned int v52;
  unsigned int v53;
  void *v54;
  unsigned int *v55;
  float v56;
  unsigned int v57;
  unsigned int v58;
  unsigned int v59;
  BOOL v60;
  unsigned int v61;
  int v62;
  unsigned int v63;
  unint64_t result;
  char *v65;
  char *v66;
  const char *v67;
  uint64_t v68;
  _DWORD **v69;
  unsigned int *v70;
  _QWORD *v71;
  void *__new;
  unsigned int *__newa;
  _DWORD v75[2];

  v6 = *(unsigned int *)(*(_QWORD *)(a1 + 96) + 4 * a2);
  v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1);
  v8 = 1;
  while (1)
  {
    v10 = v6;
    v11 = _windowsResolvePtr(*(_QWORD *)(a1 + 80) + 40, *(_QWORD *)(*(_QWORD *)(a1 + 80) + 24) + *(_QWORD *)(*(_QWORD *)(a1 + 80) + 16) * v6, 0x100CuLL);
    if (*(_DWORD *)(v11 + 4) != v7)
    {
      v65 = __si_assert_copy_extra_268();
      v66 = v65;
      v67 = "";
      if (v65)
        v67 = v65;
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1288, "block->centOffset == centOffset", v67);
      free(v66);
      if (__valid_fs(-1))
        v68 = 2989;
      else
        v68 = 3072;
      *(_DWORD *)v68 = -559038737;
      abort();
    }
    v12 = (float *)v11;
    v13 = v10 >> 20;
    v14 = *(_QWORD *)(a1 + 80) + 4192;
    bit_vector_set_9027(v14, v10 >> 20);
    v15 = (v10 + 4108) >> 20;
    if (v15 > v10 >> 20)
    {
      do
        bit_vector_set_9027(v14, ++v13);
      while (v15 != v13);
    }
    v16 = *((_DWORD *)v12 + 2);
    if ((v8 & 1) == 0)
      goto LABEL_10;
    if (!v16)
      break;
    if (v12[4] < a4)
    {
      *((_DWORD *)v12 + 3) = a3;
      v12[4] = a4;
    }
LABEL_10:
    if (v16 < 0x200)
      goto LABEL_61;
    v8 = 0;
    *((_DWORD *)v12 + 2) = v16 + 1;
    v6 = *(unsigned int *)v12;
    if (!(_DWORD)v6)
    {
      v17 = *(_QWORD *)(a1 + 80);
      v18 = *(_QWORD *)(v17 + 16);
      v19 = *(_QWORD *)(v17 + 56);
      v20 = v19 + v18;
      if (v19 + v18 >= *(_QWORD *)(v17 + 48))
      {
        if (!_storageWindowsExpandBacking((_DWORD **)(v17 + 40), *(_QWORD *)(v17 + 16)))
        {
          v21 = 0;
          goto LABEL_14;
        }
        pthread_rwlock_wrlock(*(pthread_rwlock_t **)(v17 + 4224));
        v42 = *(pthread_rwlock_t **)(v17 + 4224);
        sig = (unsigned int *)v42[1].__sig;
        v42[1].__sig = 0;
        pthread_rwlock_unlock(v42);
        if (sig)
        {
          v44 = sig;
          v45 = sig + 2;
          do
          {
            v46 = __ldaxr(v45);
            v47 = v46 - 1;
          }
          while (__stlxr(v47, v45));
          if (!v47)
          {
            v48 = 0;
            __newa = v44;
            do
            {
              v49 = (char *)&v44[2 * v48];
              v50 = *((_QWORD *)v49 + 72);
              if (v50)
              {
                v51 = v49 + 576;
                do
                {
                  v52 = __ldaxr((unsigned int *)v50);
                  v53 = v52 - 1;
                }
                while (__stlxr(v53, (unsigned int *)v50));
                if (!v53)
                {
                  v54 = *(void **)(v50 + 8);
                  if (v54)
                    munmap(v54, *(_QWORD *)(v50 + 24) - *(_QWORD *)(v50 + 16));
                  free((void *)v50);
                  v44 = __newa;
                }
                *v51 = 0;
              }
              ++v48;
            }
            while (v48 != 512);
            OSAtomicEnqueue(&availableArrayReaders, v44, 0);
          }
        }
        v19 = *(_QWORD *)(v17 + 56);
        v20 = v19 + v18;
      }
      *(_QWORD *)(v17 + 56) = v20;
      v21 = (v19 - *(_QWORD *)(v17 + 24)) / v18;
LABEL_14:
      if (v18 >> 2 <= 0x402)
      {
        v22 = *(_QWORD *)(v17 + 16);
        if (v22 >> 2 <= 0x402)
        {
          v23 = (_DWORD **)(v17 + 40);
          LODWORD(v24) = 4108;
          do
          {
            v25 = *(_QWORD *)(v17 + 56) + v22;
            if (v25 >= *(_QWORD *)(v17 + 48))
            {
              if (!_storageWindowsExpandBacking(v23, v22))
                goto LABEL_19;
              pthread_rwlock_wrlock(*(pthread_rwlock_t **)(v17 + 4224));
              v26 = *(pthread_rwlock_t **)(v17 + 4224);
              v70 = (unsigned int *)v26[1].__sig;
              v26[1].__sig = 0;
              pthread_rwlock_unlock(v26);
              v27 = v70;
              if (v70)
              {
                v28 = v70 + 2;
                do
                {
                  v29 = __ldaxr(v28);
                  v30 = v29 - 1;
                }
                while (__stlxr(v30, v28));
                if (!v30)
                {
                  v69 = v23;
                  v31 = 0;
                  do
                  {
                    v33 = (char *)&v27[2 * (_QWORD)v31];
                    v34 = *((_QWORD *)v33 + 72);
                    if (v34)
                    {
                      v32 = v33 + 576;
                      do
                      {
                        v35 = __ldaxr((unsigned int *)v34);
                        v36 = v35 - 1;
                      }
                      while (__stlxr(v36, (unsigned int *)v34));
                      if (!v36)
                      {
                        v71 = v32;
                        __new = v31;
                        v37 = *(void **)(v34 + 8);
                        if (v37)
                          munmap(v37, *(_QWORD *)(v34 + 24) - *(_QWORD *)(v34 + 16));
                        free((void *)v34);
                        v27 = v70;
                        v32 = v71;
                        v31 = __new;
                      }
                      *v32 = 0;
                    }
                    v31 = (char *)v31 + 1;
                  }
                  while (v31 != (void *)512);
                  OSAtomicEnqueue(&availableArrayReaders, v27, 0);
                  v23 = v69;
                }
              }
              v25 = *(_QWORD *)(v17 + 56) + v22;
            }
            *(_QWORD *)(v17 + 56) = v25;
LABEL_19:
            v22 = *(_QWORD *)(v17 + 16);
            v24 = (v24 - v22);
          }
          while (v22 < v24);
        }
      }
      v38 = v17 + 4192;
      bit_vector_set_9027(v17 + 4192, (v21 >> 20));
      v39 = (v21 + 4108) >> 20;
      if (v39 > (v21 >> 20))
      {
        v40 = (v21 >> 20) + 1;
        do
        {
          v41 = v40;
          bit_vector_set_9027(v38, v40++);
        }
        while (v39 > v41);
      }
      v9 = (_DWORD *)_windowsResolvePtr(*(_QWORD *)(a1 + 80) + 40, *(_QWORD *)(*(_QWORD *)(a1 + 80) + 24) + *(_QWORD *)(*(_QWORD *)(a1 + 80) + 16) * v21, 0x100CuLL);
      bzero(v9, 0x100CuLL);
      v9[1] = v7;
      v6 = v21;
      v8 = 0;
      *(_DWORD *)_windowsResolvePtr(*(_QWORD *)(a1 + 80) + 40, *(_QWORD *)(*(_QWORD *)(a1 + 80) + 24) + *(_QWORD *)(*(_QWORD *)(a1 + 80) + 16) * v10, 0x100CuLL) = v21;
    }
  }
  v12[4] = a4;
  v16 = 1;
  *((_DWORD *)v12 + 2) = 1;
  *((_DWORD *)v12 + 3) = a3;
LABEL_61:
  *((_DWORD *)v12 + 2) = v16 + 1;
  v55 = (unsigned int *)&v12[2 * v16];
  v55[3] = a3;
  *((float *)v55 + 4) = a4;
  if (a4 == 0.0)
  {
    v56 = 3.4028e38;
  }
  else
  {
    v57 = *(_DWORD *)(a1 + 64);
    v58 = v57 / 0xADC8;
    v59 = 48271 * (v57 % 0xADC8);
    v58 *= 3399;
    v60 = v59 >= v58;
    v61 = v59 - v58;
    if (v60)
      v62 = 0;
    else
      v62 = 0x7FFFFFFF;
    v63 = v62 + v61;
    *(_DWORD *)(a1 + 64) = v63;
    v56 = (float)-logf((float)(v63 - 1) * 4.6566e-10) / a4;
  }
  v75[0] = a3;
  *(float *)&v75[1] = v56;
  MaxSizePriorityQueue<AnyPartitionStore::CandidateEntry,std::vector<AnyPartitionStore::CandidateEntry>,AnyPartitionStore::CandidateQueue::Lesser>::push((_QWORD *)(a1 + 24), (uint64_t)v75);
  ++*(_DWORD *)(a1 + 72);
  result = _windowsResolvePtr(*(_QWORD *)(a1 + 80) + 40, 0x400uLL, *(_QWORD *)(*(_QWORD *)(a1 + 80) + 16));
  *(_DWORD *)(result + 12) = *(_DWORD *)(a1 + 72);
  return result;
}

void PartitionStore<vi_onefixedsize_disk_allocator,512>::enumeratePartitions(_DWORD *a1, uint64_t a2)
{
  uint64_t v2;
  unsigned int v4;
  char *v5;
  char *v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  _BYTE *v11;
  char *v12;
  char *v13;
  unint64_t v14;
  char *v15;
  uint64_t v16;
  _OWORD *v17;
  char *v18;
  uint64_t v19;
  __int128 v20;
  int v21;
  uint64_t v22;
  char *v23;
  char *v24;
  void *__p;
  void *v27;
  char *v28;

  v2 = a2;
  if (!a1[17])
  {
    v5 = 0;
    __p = 0;
    v27 = 0;
    v28 = 0;
    goto LABEL_37;
  }
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  do
  {
    if (v7 < v6)
    {
      *(_DWORD *)v7 = v4;
      v7 += 4;
      goto LABEL_4;
    }
    v8 = (v7 - v5) >> 2;
    v9 = v8 + 1;
    if ((unint64_t)(v8 + 1) >> 62)
      goto LABEL_42;
    if ((v6 - v5) >> 1 > v9)
      v9 = (v6 - v5) >> 1;
    if ((unint64_t)(v6 - v5) >= 0x7FFFFFFFFFFFFFFCLL)
      v10 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v10 = v9;
    if (v10)
    {
      if (v10 >> 62)
        std::__throw_bad_array_new_length[abi:nn180100]();
      v11 = operator new(4 * v10);
    }
    else
    {
      v11 = 0;
    }
    v12 = &v11[4 * v8];
    *(_DWORD *)v12 = v4;
    v13 = v12 + 4;
    if (v7 != v5)
    {
      v14 = v7 - 4 - v5;
      if (v14 >= 0xBC)
      {
        if (&v11[v7 - v5 - 4 - (v14 & 0xFFFFFFFFFFFFFFFCLL)] > &v11[v7 - v5 - 4])
        {
          v15 = v7;
        }
        else if (&v7[-(v14 & 0xFFFFFFFFFFFFFFFCLL) - 4] > v7 - 4)
        {
          v15 = v7;
        }
        else if ((unint64_t)(v5 - v11) >= 0x20)
        {
          v16 = (v14 >> 2) + 1;
          v15 = &v7[-4 * (v16 & 0x7FFFFFFFFFFFFFF8)];
          v17 = &v11[4 * v8 - 16];
          v18 = v7 - 16;
          v19 = v16 & 0x7FFFFFFFFFFFFFF8;
          do
          {
            v20 = *(_OWORD *)v18;
            *(v17 - 1) = *((_OWORD *)v18 - 1);
            *v17 = v20;
            v17 -= 2;
            v18 -= 32;
            v19 -= 8;
          }
          while (v19);
          v12 -= 4 * (v16 & 0x7FFFFFFFFFFFFFF8);
          if (v16 == (v16 & 0x7FFFFFFFFFFFFFF8))
            goto LABEL_29;
        }
        else
        {
          v15 = v7;
        }
      }
      else
      {
        v15 = v7;
      }
      do
      {
        v21 = *((_DWORD *)v15 - 1);
        v15 -= 4;
        *((_DWORD *)v12 - 1) = v21;
        v12 -= 4;
      }
      while (v15 != v5);
    }
LABEL_29:
    v6 = &v11[4 * v10];
    if (v5)
      operator delete(v5);
    v5 = v12;
    v7 = v13;
LABEL_4:
    ++v4;
  }
  while (v4 < a1[17]);
  __p = 0;
  v27 = 0;
  v28 = 0;
  v22 = v7 - v5;
  if (v7 != v5)
  {
    if (v22 < 0)
LABEL_42:
      abort();
    v23 = (char *)operator new(v7 - v5);
    v24 = &v23[4 * (v22 >> 2)];
    __p = v23;
    v28 = v24;
    memcpy(v23, v5, v7 - v5);
    v27 = v24;
  }
  v2 = a2;
LABEL_37:
  (*(void (**)(_DWORD *, void **, uint64_t))(*(_QWORD *)a1 + 72))(a1, &__p, v2);
  if (__p)
  {
    v27 = __p;
    operator delete(__p);
  }
  if (v5)
    operator delete(v5);
}

void PartitionStore<vi_onefixedsize_disk_allocator,512>::enumeratePartitions(_QWORD *a1, unsigned int **a2, uint64_t a3, __n128 a4)
{
  unsigned int *v4;
  uint64_t v6;
  char *v7;
  char *v8;
  uint64_t v9;
  __n128 v10;
  __int128 v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  char *v17;
  __int128 v18;
  char *v19;
  uint64_t v20;
  __int128 v21;
  uint64_t v22;
  char *v23;
  __int128 v24;
  uint64_t v25;
  __int128 v26;
  char *v27;
  char *v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;
  uint64_t v32;
  __n128 v33;
  __int128 v34;
  __int128 v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  __n128 v44;
  __int128 v45;
  __int128 v46;
  uint64_t v47;
  int v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  BOOL v56;
  __n128 *v57;
  __n128 *v58;
  __n128 v59;
  __int128 v60;
  __n128 v61;
  __int128 v62;
  __n128 v63;
  __int128 v64;
  __int128 v65;
  uint64_t v66;
  unint64_t v67;
  uint64_t v68;
  _DWORD *v69;
  __int128 v70;
  __n128 v71;
  __int128 v72;
  int v73;
  uint64_t v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  char v83;
  _OWORD v84[3];
  __n128 v85;
  __int128 v86;
  uint64_t v87;
  __n128 v88;
  __int128 v89;
  uint64_t v90;
  __n128 v91;
  __int128 v92;

  v4 = *a2;
  if (*a2 == a2[1])
  {
    v7 = 0;
    v6 = 0;
  }
  else
  {
    v6 = 0;
    v7 = 0;
    v8 = 0;
    do
    {
      v12 = *v4;
      if ((*(unsigned int (**)(_QWORD *, uint64_t))(*a1 + 48))(a1, v12))
      {
        v13 = (*(uint64_t (**)(_QWORD *, uint64_t))(*a1 + 40))(a1, v12);
        v14 = a1[18] + 16 * v12;
        memset(v84, 0, sizeof(v84));
        PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionEnumerator::PartitionEnumerator((uint64_t)v84, *(_QWORD *)v14, *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v14 + 96) + 4 * *(unsigned int *)(v14 + 8)));
        *(_QWORD *)&v84[0] = &off_1E6E337C0;
        PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionEnumerator::next((uint64_t)v84);
        v92 = 0uLL;
        v88 = *(__n128 *)((char *)v84 + 8);
        v89 = *(_OWORD *)((char *)&v84[1] + 8);
        v90 = *((_QWORD *)&v84[2] + 1);
        v85 = v91;
        v86 = 0uLL;
        if (v7 < v8)
        {
          *(_QWORD *)v7 = &off_1E6E337F0;
          v9 = v90;
          v10 = v88;
          *(_OWORD *)(v7 + 24) = v89;
          *(__n128 *)(v7 + 8) = v10;
          *((_QWORD *)v7 + 5) = v9;
          *((_QWORD *)v7 + 6) = &off_1E6E337C0;
          *(_QWORD *)v7 = &off_1E6E337C0;
          *((_QWORD *)v7 + 7) = 0;
          a4 = v85;
          v11 = v86;
          *((__n128 *)v7 + 4) = v85;
          *((_OWORD *)v7 + 5) = v11;
          *((_DWORD *)v7 + 24) = v13;
          v7 += 104;
        }
        else
        {
          v15 = 0x4EC4EC4EC4EC4EC5 * ((uint64_t)&v7[-v6] >> 3) + 1;
          if (v15 > 0x276276276276276)
            abort();
          if (0x9D89D89D89D89D8ALL * ((uint64_t)&v8[-v6] >> 3) > v15)
            v15 = 0x9D89D89D89D89D8ALL * ((uint64_t)&v8[-v6] >> 3);
          if ((unint64_t)(0x4EC4EC4EC4EC4EC5 * ((uint64_t)&v8[-v6] >> 3)) >= 0x13B13B13B13B13BLL)
            v16 = 0x276276276276276;
          else
            v16 = v15;
          if (v16)
          {
            if (v16 > 0x276276276276276)
              std::__throw_bad_array_new_length[abi:nn180100]();
            v17 = (char *)operator new(104 * v16);
          }
          else
          {
            v17 = 0;
          }
          v18 = v89;
          v19 = &v17[8 * ((uint64_t)&v7[-v6] >> 3)];
          *(__n128 *)(v19 + 8) = v88;
          *(_OWORD *)(v19 + 24) = v18;
          v20 = v90;
          *(_QWORD *)v19 = &off_1E6E337C0;
          *((_QWORD *)v19 + 6) = &off_1E6E337C0;
          *((_QWORD *)v19 + 7) = 0;
          a4 = v85;
          v21 = v86;
          *((__n128 *)v19 + 4) = v85;
          *((_OWORD *)v19 + 5) = v21;
          *((_QWORD *)v19 + 5) = v20;
          *((_DWORD *)v19 + 24) = v13;
          if (v7 == (char *)v6)
          {
            v27 = &v17[8 * ((uint64_t)&v7[-v6] >> 3)];
          }
          else
          {
            v22 = 0;
            do
            {
              v23 = &v19[v22];
              *((_QWORD *)v23 - 13) = &off_1E6E337F0;
              v24 = *(_OWORD *)&v7[v22 - 80];
              v25 = *(_QWORD *)&v7[v22 - 64];
              *((_OWORD *)v23 - 6) = *(_OWORD *)&v7[v22 - 96];
              *((_OWORD *)v23 - 5) = v24;
              *((_QWORD *)v23 - 13) = &off_1E6E337C0;
              *((_QWORD *)v23 - 8) = v25;
              *((_QWORD *)v23 - 7) = &off_1E6E337F0;
              a4 = *(__n128 *)&v7[v22 - 48];
              v26 = *(_OWORD *)&v7[v22 - 32];
              *((_QWORD *)v23 - 2) = *(_QWORD *)&v7[v22 - 16];
              *((__n128 *)v23 - 3) = a4;
              *((_OWORD *)v23 - 2) = v26;
              *((_QWORD *)v23 - 7) = &off_1E6E337C0;
              *((_DWORD *)v23 - 2) = *(_DWORD *)&v7[v22 - 8];
              v22 -= 104;
            }
            while (&v7[v22] != (char *)v6);
            v27 = &v19[v22];
          }
          v8 = &v17[104 * v16];
          v7 = v19 + 104;
          if (v6)
            operator delete((void *)v6);
          v6 = (uint64_t)v27;
        }
      }
      ++v4;
    }
    while (v4 != a2[1]);
  }
  v28 = &v7[-v6];
  if ((uint64_t)&v7[-v6] >= 105)
  {
    v29 = (uint64_t)v28 / 104;
    v30 = (unint64_t)((uint64_t)v28 / 104 - 2) >> 1;
    v31 = v30 + 1;
    v32 = v6 + 104 * v30;
    do
    {
      a4 = std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,PartitionStore<vi_onefixedsize_disk_allocator,512>::enumeratePartitions(std::vector<unsigned int>,void({block_pointer})(unsigned int,AnyPartitionStore::VectorEntry_s const&,BOOL *))::Greater &,std::__wrap_iter<std::tuple<PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionIterator,PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionIterator,unsigned int> *>>(v6, v29, v32);
      v32 -= 104;
      --v31;
    }
    while (v31);
  }
  if (v7 == (char *)v6)
  {
LABEL_54:
    if (!v6)
      return;
  }
  else
  {
    while (1)
    {
      v36 = *(_QWORD *)(v6 + 40);
      v37 = *(unsigned int *)(v6 + 96);
      v83 = 0;
      (*(void (**)(uint64_t, uint64_t, uint64_t, char *, __n128))(a3 + 16))(a3, v37, v36, &v83, a4);
      if (v83)
        break;
      v38 = (uint64_t)&v7[-v6];
      v39 = (uint64_t)&v7[-v6] / 104;
      (*(void (**)(uint64_t))(*(_QWORD *)v6 + 24))(v6);
      if (*(_QWORD *)(v6 + 40) == *(_QWORD *)(v6 + 88))
      {
        if (v38 >= 105)
        {
          v43 = 0;
          v44 = *(__n128 *)(v6 + 8);
          v45 = *(_OWORD *)(v6 + 24);
          v90 = *(_QWORD *)(v6 + 40);
          v88 = v44;
          v89 = v45;
          v46 = *(_OWORD *)(v6 + 72);
          v85 = *(__n128 *)(v6 + 56);
          v86 = v46;
          v87 = *(_QWORD *)(v6 + 88);
          v47 = v6;
          v48 = *(_DWORD *)(v6 + 96);
          do
          {
            v53 = v47 + 104 * v43 + 104;
            v54 = (2 * v43) | 1;
            v55 = 2 * v43 + 2;
            if (v55 < v39)
            {
              v56 = **(_DWORD **)(v53 + 40) > **(_DWORD **)(v53 + 144);
              v53 += 104 * v56;
              if (v56)
                v54 = v55;
            }
            v49 = *(_OWORD *)(v53 + 8);
            v50 = *(_OWORD *)(v53 + 24);
            *(_QWORD *)(v47 + 40) = *(_QWORD *)(v53 + 40);
            *(_OWORD *)(v47 + 24) = v50;
            *(_OWORD *)(v47 + 8) = v49;
            v51 = *(_OWORD *)(v53 + 56);
            v52 = *(_OWORD *)(v53 + 72);
            *(_QWORD *)(v47 + 88) = *(_QWORD *)(v53 + 88);
            *(_OWORD *)(v47 + 72) = v52;
            *(_OWORD *)(v47 + 56) = v51;
            *(_DWORD *)(v47 + 96) = *(_DWORD *)(v53 + 96);
            v47 = v53;
            v43 = v54;
          }
          while (v54 <= (uint64_t)((unint64_t)(v39 - 2) >> 1));
          v57 = (__n128 *)(v53 + 8);
          v58 = (__n128 *)(v53 + 56);
          if ((char *)v53 == v7 - 104)
          {
            v33 = v88;
            v34 = v89;
            *(_QWORD *)(v53 + 40) = v90;
            *v57 = v33;
            *(_OWORD *)(v53 + 24) = v34;
            a4 = v85;
            v35 = v86;
            *(_QWORD *)(v53 + 88) = v87;
            *v58 = a4;
            *(_OWORD *)(v53 + 72) = v35;
            *(_DWORD *)(v53 + 96) = v48;
          }
          else
          {
            v59 = *((__n128 *)v7 - 6);
            v60 = *((_OWORD *)v7 - 5);
            *(_QWORD *)(v53 + 40) = *((_QWORD *)v7 - 8);
            *v57 = v59;
            *(_OWORD *)(v53 + 24) = v60;
            v61 = *((__n128 *)v7 - 3);
            v62 = *((_OWORD *)v7 - 2);
            *(_QWORD *)(v53 + 88) = *((_QWORD *)v7 - 2);
            *v58 = v61;
            *(_OWORD *)(v53 + 72) = v62;
            *(_DWORD *)(v53 + 96) = *((_DWORD *)v7 - 2);
            v63 = v88;
            v64 = v89;
            *((_QWORD *)v7 - 8) = v90;
            *((__n128 *)v7 - 6) = v63;
            *((_OWORD *)v7 - 5) = v64;
            a4 = v85;
            v65 = v86;
            *((_QWORD *)v7 - 2) = v87;
            *((__n128 *)v7 - 3) = a4;
            *((_OWORD *)v7 - 2) = v65;
            *((_DWORD *)v7 - 2) = v48;
            v66 = v53 - v6 + 104;
            if (v66 >= 105)
            {
              v67 = (v66 / 0x68uLL - 2) >> 1;
              v68 = v6 + 104 * v67;
              v69 = *(_DWORD **)(v53 + 40);
              if (**(_DWORD **)(v68 + 40) > *v69)
              {
                v70 = *(_OWORD *)(v53 + 24);
                v91 = *v57;
                v92 = v70;
                v71 = *v58;
                v72 = *(_OWORD *)(v53 + 72);
                *(_QWORD *)&v84[2] = *(_QWORD *)(v53 + 88);
                v84[0] = v71;
                v84[1] = v72;
                v73 = *(_DWORD *)(v53 + 96);
                do
                {
                  v74 = v53;
                  v53 = v68;
                  v75 = *(_OWORD *)(v68 + 8);
                  v76 = *(_OWORD *)(v68 + 24);
                  *(_QWORD *)(v74 + 40) = *(_QWORD *)(v68 + 40);
                  *(_OWORD *)(v74 + 24) = v76;
                  *(_OWORD *)(v74 + 8) = v75;
                  v77 = *(_OWORD *)(v68 + 56);
                  v78 = *(_OWORD *)(v68 + 72);
                  *(_QWORD *)(v74 + 88) = *(_QWORD *)(v68 + 88);
                  *(_OWORD *)(v74 + 72) = v78;
                  *(_OWORD *)(v74 + 56) = v77;
                  *(_DWORD *)(v74 + 96) = *(_DWORD *)(v68 + 96);
                  if (!v67)
                    break;
                  v67 = (v67 - 1) >> 1;
                  v68 = v6 + 104 * v67;
                }
                while (**(_DWORD **)(v68 + 40) > *v69);
                v79 = v92;
                *(__n128 *)(v53 + 8) = v91;
                *(_OWORD *)(v53 + 24) = v79;
                *(_QWORD *)(v53 + 40) = v69;
                a4 = (__n128)v84[0];
                v80 = v84[1];
                *(_OWORD *)(v53 + 56) = v84[0];
                *(_OWORD *)(v53 + 72) = v80;
                *(_QWORD *)(v53 + 88) = *(_QWORD *)&v84[2];
                *(_DWORD *)(v53 + 96) = v73;
              }
            }
          }
        }
        v7 -= 104;
      }
      else if (v38 >= 105)
      {
        v40 = (unint64_t)(v39 - 2) >> 1;
        v41 = v40 + 1;
        v42 = v6 + 104 * v40;
        do
        {
          a4 = std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,PartitionStore<vi_onefixedsize_disk_allocator,512>::enumeratePartitions(std::vector<unsigned int>,void({block_pointer})(unsigned int,AnyPartitionStore::VectorEntry_s const&,BOOL *))::Greater &,std::__wrap_iter<std::tuple<PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionIterator,PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionIterator,unsigned int> *>>(v6, (uint64_t)&v7[-v6] / 104, v42);
          v42 -= 104;
          --v41;
        }
        while (v41);
      }
      if (v7 == (char *)v6)
        goto LABEL_54;
    }
  }
  operator delete((void *)v6);
}

uint64_t PartitionStore<vi_onefixedsize_disk_allocator,512>::enumeratePartition(_QWORD *a1, unsigned int a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t result;
  uint64_t i;
  char v10;
  _OWORD v11[2];
  __int128 v12;

  v6 = (*(uint64_t (**)(_QWORD *))(*a1 + 40))(a1);
  v7 = a1[18] + 16 * a2;
  v12 = 0u;
  memset(v11, 0, sizeof(v11));
  PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionEnumerator::PartitionEnumerator((uint64_t)v11, *(_QWORD *)v7, *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v7 + 96) + 4 * *(unsigned int *)(v7 + 8)));
  *(_QWORD *)&v11[0] = &off_1E6E337C0;
  result = PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionEnumerator::next((uint64_t)v11);
  for (i = *((_QWORD *)&v12 + 1); *((_QWORD *)&v12 + 1); i = *((_QWORD *)&v12 + 1))
  {
    v10 = 0;
    result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, char *))(a3 + 16))(a3, v6, i, &v10);
    if (v10)
      break;
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)&v11[0] + 24))((uint64_t)v11);
  }
  return result;
}

uint64_t PartitionStore<vi_onefixedsize_disk_allocator,512>::vectorOffsetsInPartition@<X0>(uint64_t a1@<X0>, unsigned int a2@<W1>, _QWORD *a3@<X8>)
{
  uint64_t v4;
  uint64_t result;
  int *i;
  _OWORD v7[2];
  __int128 v8;
  _QWORD *v9;

  v4 = *(_QWORD *)(a1 + 144) + 16 * a2;
  a3[1] = 0;
  a3[2] = 0;
  *a3 = 0;
  memset(v7, 0, sizeof(v7));
  v8 = 0u;
  PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionEnumerator::PartitionEnumerator((uint64_t)v7, *(_QWORD *)v4, *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v4 + 96) + 4 * *(unsigned int *)(v4 + 8)));
  *(_QWORD *)&v7[0] = &off_1E6E337C0;
  result = PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionEnumerator::next((uint64_t)v7);
  v9 = a3;
  for (i = (int *)*((_QWORD *)&v8 + 1); *((_QWORD *)&v8 + 1); i = (int *)*((_QWORD *)&v8 + 1))
  {
    std::back_insert_iterator<std::vector<unsigned int>>::operator=[abi:nn180100]((uint64_t *)&v9, *i);
    result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)&v7[0] + 24))((uint64_t)v7);
  }
  return result;
}

uint64_t PartitionStore<vi_onefixedsize_disk_allocator,512>::enumerator@<X0>(uint64_t a1@<X0>, unsigned int a2@<W1>, uint64_t *a3@<X8>)
{
  unsigned int v5;
  _QWORD *v6;
  uint64_t result;

  v5 = *(_DWORD *)(*(_QWORD *)(a1 + 96) + 4 * a2);
  v6 = operator new(0x48uLL);
  v6[1] = 0;
  v6[2] = 0;
  *v6 = &off_1E6E33820;
  result = PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionEnumerator::PartitionEnumerator((uint64_t)(v6 + 3), a1, v5);
  *a3 = result;
  a3[1] = (uint64_t)v6;
  return result;
}

uint64_t PartitionStore<vi_onefixedsize_disk_allocator,512>::dump(_QWORD *a1, _QWORD *a2, int a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  _QWORD *v16;
  const std::locale::facet *v17;
  uint64_t result;
  uint64_t v19;
  const std::locale::facet *v20;
  _QWORD *v21;
  _QWORD *v22;
  _QWORD *v23;
  const std::locale::facet *v24;
  uint64_t v25;
  const std::locale::facet *v26;
  char *v27;
  uint64_t v28;
  char *v29;
  int v30;
  const std::locale::facet *v31;
  uint64_t v32;
  BOOL v33;
  size_t v34;
  size_t v35;
  std::locale::__imp *p_b;
  uint64_t v37;
  uint64_t v38;
  void *locale;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  _QWORD *v43;
  char *v44;
  uint64_t v45;
  char *v46;
  int v47;
  const std::locale::facet *v48;
  uint64_t v49;
  size_t v50;
  size_t v51;
  std::locale::__imp *v52;
  uint64_t v53;
  uint64_t v54;
  void *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  _QWORD *v59;
  char *v60;
  uint64_t v61;
  char *v62;
  int v63;
  const std::locale::facet *v64;
  uint64_t v65;
  size_t v66;
  size_t v67;
  std::locale::__imp *v68;
  uint64_t v69;
  uint64_t v70;
  void *v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  const std::locale::facet *v75;
  char *v76;
  char *v77;
  const char *v78;
  uint64_t v79;
  _QWORD *v80;
  int v81;
  uint64_t v82;
  std::locale v83[2];
  __int128 v84;
  __int128 v85;
  uint64_t v86;
  uint64_t v87;
  std::locale __b;
  size_t v89;
  int64_t v90;

  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"Quantizer ", 10);
  v6 = a1[1];
  if (!v6)
  {
    v76 = __si_assert_copy_extra_268();
    v77 = v76;
    v78 = "";
    if (v76)
      v78 = v76;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 872, "_quantizer != nullptr", v78);
    free(v77);
    if (__valid_fs(-1))
      v79 = 2989;
    else
      v79 = 3072;
    *(_DWORD *)v79 = -559038737;
LABEL_118:
    abort();
  }
  v9 = *(_QWORD *)(v6 + 8);
  v7 = v6 + 8;
  v8 = v9;
  v10 = *(char *)(v7 + 23);
  if (v10 >= 0)
    v11 = v7;
  else
    v11 = v8;
  if (v10 >= 0)
    v12 = *(unsigned __int8 *)(v7 + 23);
  else
    v12 = *(_QWORD *)(v7 + 8);
  v13 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, v11, v12);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v13, (uint64_t)" , ", 3);
  v14 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v14, (uint64_t)" vectors in ", 12);
  v15 = (_QWORD *)std::ostream::operator<<();
  v16 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v15, (uint64_t)" partitions:", 12);
  std::ios_base::getloc((const std::ios_base *)((char *)v16 + *(_QWORD *)(*v16 - 24)));
  v17 = std::locale::use_facet(v83, MEMORY[0x1E0DE4A90]);
  ((void (*)(const std::locale::facet *, uint64_t))v17->__vftable[2].~facet_0)(v17, 10);
  std::locale::~locale(v83);
  std::ostream::put();
  result = std::ostream::flush();
  if (a3 >= 3)
  {
    if (*((_DWORD *)a1 + 17))
    {
      v19 = 0;
      v81 = a3;
      v80 = a1;
      while (1)
      {
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"partition ", 10);
        v21 = (_QWORD *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v21, (uint64_t)" (", 2);
        (*(void (**)(_QWORD *, uint64_t))(*a1 + 48))(a1, v19);
        v22 = (_QWORD *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v22, (uint64_t)")\t<=", 4);
        (*(void (**)(_QWORD *, uint64_t))(*a1 + 32))(a1, v19);
        v23 = (_QWORD *)std::ostream::operator<<();
        std::ios_base::getloc((const std::ios_base *)((char *)v23 + *(_QWORD *)(*v23 - 24)));
        v24 = std::locale::use_facet(v83, MEMORY[0x1E0DE4A90]);
        ((void (*)(const std::locale::facet *, uint64_t))v24->__vftable[2].~facet_0)(v24, 10);
        std::locale::~locale(v83);
        std::ostream::put();
        std::ostream::flush();
        if (a3 < 4)
          goto LABEL_12;
        v82 = v19;
        v25 = a1[18] + 16 * v19;
        v84 = 0u;
        v85 = 0u;
        *(_OWORD *)&v83[0].__locale_ = 0u;
        PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionEnumerator::PartitionEnumerator((uint64_t)v83, *(_QWORD *)v25, *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v25 + 96) + 4 * *(unsigned int *)(v25 + 8)));
        v83[0].__locale_ = (std::locale::__imp *)&off_1E6E337C0;
        PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionEnumerator::next((uint64_t)v83);
        if (*((_QWORD *)&v85 + 1))
          break;
LABEL_11:
        std::ios_base::getloc((const std::ios_base *)((char *)a2 + *(_QWORD *)(*a2 - 24)));
        v20 = std::locale::use_facet(v83, MEMORY[0x1E0DE4A90]);
        ((void (*)(const std::locale::facet *, uint64_t))v20->__vftable[2].~facet_0)(v20, 10);
        std::locale::~locale(v83);
        std::ostream::put();
        std::ostream::flush();
        a3 = v81;
        a1 = v80;
        v19 = v82;
LABEL_12:
        if (++v19 >= (unint64_t)*((unsigned int *)a1 + 17))
          goto LABEL_110;
      }
      while (1)
      {
        v86 = 0;
        v87 = 0;
        MEMORY[0x1BCCB04A0](&v86, a2);
        if (!(_BYTE)v86)
          goto LABEL_49;
        v27 = (char *)a2 + *(_QWORD *)(*a2 - 24);
        v28 = *((_QWORD *)v27 + 5);
        if ((*((_DWORD *)v27 + 2) & 0xB0) == 0x20)
          v29 = "";
        else
          v29 = "  ";
        v30 = *((_DWORD *)v27 + 36);
        if (v30 == -1)
        {
          std::ios_base::getloc((const std::ios_base *)((char *)a2 + *(_QWORD *)(*a2 - 24)));
          v31 = std::locale::use_facet(&__b, MEMORY[0x1E0DE4A90]);
          v30 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v31->__vftable[2].~facet_0)(v31, 32);
          std::locale::~locale(&__b);
          *((_DWORD *)v27 + 36) = v30;
          if (!v28)
            goto LABEL_48;
        }
        else if (!v28)
        {
          goto LABEL_48;
        }
        v32 = *((_QWORD *)v27 + 3);
        v33 = v32 <= 2;
        v34 = v32 - 2;
        if (v33)
          v35 = 0;
        else
          v35 = v34;
        if (v29 - "  " >= 1
          && (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(_QWORD *)v28 + 96))(v28, "  ", v29 - "  ") != v29 - "  ")
        {
          goto LABEL_48;
        }
        if ((uint64_t)v35 >= 1)
        {
          __b.__locale_ = 0;
          v89 = 0;
          v90 = 0;
          if (v35 > 0x7FFFFFFFFFFFFFF7)
            goto LABEL_118;
          if (v35 >= 0x17)
          {
            v37 = (v35 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v35 | 7) != 0x17)
              v37 = v35 | 7;
            v38 = v37 + 1;
            p_b = (std::locale::__imp *)operator new(v37 + 1);
            v89 = v35;
            v90 = v38 | 0x8000000000000000;
            __b.__locale_ = p_b;
          }
          else
          {
            HIBYTE(v90) = v35;
            p_b = (std::locale::__imp *)&__b;
          }
          memset(p_b, v30, v35);
          *((_BYTE *)p_b + v35) = 0;
          if (v90 >= 0)
            locale = &__b;
          else
            locale = __b.__locale_;
          v40 = (*(uint64_t (**)(uint64_t, void *, size_t))(*(_QWORD *)v28 + 96))(v28, locale, v35);
          v41 = v40;
          if (SHIBYTE(v90) < 0)
          {
            operator delete(__b.__locale_);
            if (v41 != v35)
              goto LABEL_48;
          }
          else if (v40 != v35)
          {
            goto LABEL_48;
          }
        }
        v42 = "  " - v29 + 2;
        if (v42 < 1
          || (*(uint64_t (**)(uint64_t, char *, int64_t))(*(_QWORD *)v28 + 96))(v28, v29, "  " - v29 + 2) == v42)
        {
          *((_QWORD *)v27 + 3) = 0;
          goto LABEL_49;
        }
LABEL_48:
        std::ios_base::clear((std::ios_base *)((char *)a2 + *(_QWORD *)(*a2 - 24)), *(_DWORD *)((char *)a2 + *(_QWORD *)(*a2 - 24) + 32) | 5);
LABEL_49:
        MEMORY[0x1BCCB04AC](&v86);
        v43 = (_QWORD *)std::ostream::operator<<();
        v86 = 0;
        v87 = 0;
        MEMORY[0x1BCCB04A0](&v86, v43);
        if (!(_BYTE)v86)
          goto LABEL_80;
        v44 = (char *)v43 + *(_QWORD *)(*v43 - 24);
        v45 = *((_QWORD *)v44 + 5);
        if ((*((_DWORD *)v44 + 2) & 0xB0) == 0x20)
          v46 = "";
        else
          v46 = "(";
        v47 = *((_DWORD *)v44 + 36);
        if (v47 == -1)
        {
          std::ios_base::getloc((const std::ios_base *)((char *)v43 + *(_QWORD *)(*v43 - 24)));
          v48 = std::locale::use_facet(&__b, MEMORY[0x1E0DE4A90]);
          v47 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v48->__vftable[2].~facet_0)(v48, 32);
          std::locale::~locale(&__b);
          *((_DWORD *)v44 + 36) = v47;
          if (!v45)
            goto LABEL_79;
        }
        else if (!v45)
        {
          goto LABEL_79;
        }
        v49 = *((_QWORD *)v44 + 3);
        v33 = v49 <= 1;
        v50 = v49 - 1;
        if (v33)
          v51 = 0;
        else
          v51 = v50;
        if (v46 - "(" >= 1
          && (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(_QWORD *)v45 + 96))(v45, "(", v46 - "(") != v46 - "(")
        {
          goto LABEL_79;
        }
        if ((uint64_t)v51 >= 1)
        {
          __b.__locale_ = 0;
          v89 = 0;
          v90 = 0;
          if (v51 > 0x7FFFFFFFFFFFFFF7)
            goto LABEL_118;
          if (v51 >= 0x17)
          {
            v53 = (v51 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v51 | 7) != 0x17)
              v53 = v51 | 7;
            v54 = v53 + 1;
            v52 = (std::locale::__imp *)operator new(v53 + 1);
            v89 = v51;
            v90 = v54 | 0x8000000000000000;
            __b.__locale_ = v52;
          }
          else
          {
            HIBYTE(v90) = v51;
            v52 = (std::locale::__imp *)&__b;
          }
          memset(v52, v47, v51);
          *((_BYTE *)v52 + v51) = 0;
          if (v90 >= 0)
            v55 = &__b;
          else
            v55 = __b.__locale_;
          v56 = (*(uint64_t (**)(uint64_t, void *, size_t))(*(_QWORD *)v45 + 96))(v45, v55, v51);
          v57 = v56;
          if (SHIBYTE(v90) < 0)
          {
            operator delete(__b.__locale_);
            if (v57 != v51)
              goto LABEL_79;
          }
          else if (v56 != v51)
          {
            goto LABEL_79;
          }
        }
        v58 = "(" - v46 + 1;
        if (v58 < 1
          || (*(uint64_t (**)(uint64_t, char *, int64_t))(*(_QWORD *)v45 + 96))(v45, v46, "(" - v46 + 1) == v58)
        {
          *((_QWORD *)v44 + 3) = 0;
          goto LABEL_80;
        }
LABEL_79:
        std::ios_base::clear((std::ios_base *)((char *)v43 + *(_QWORD *)(*v43 - 24)), *(_DWORD *)((char *)v43 + *(_QWORD *)(*v43 - 24) + 32) | 5);
LABEL_80:
        MEMORY[0x1BCCB04AC](&v86);
        v59 = (_QWORD *)std::ostream::operator<<();
        v86 = 0;
        v87 = 0;
        MEMORY[0x1BCCB04A0](&v86, v59);
        if (!(_BYTE)v86)
          goto LABEL_17;
        v60 = (char *)v59 + *(_QWORD *)(*v59 - 24);
        v61 = *((_QWORD *)v60 + 5);
        if ((*((_DWORD *)v60 + 2) & 0xB0) == 0x20)
          v62 = "";
        else
          v62 = ")";
        v63 = *((_DWORD *)v60 + 36);
        if (v63 == -1)
        {
          std::ios_base::getloc((const std::ios_base *)((char *)v59 + *(_QWORD *)(*v59 - 24)));
          v64 = std::locale::use_facet(&__b, MEMORY[0x1E0DE4A90]);
          v63 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v64->__vftable[2].~facet_0)(v64, 32);
          std::locale::~locale(&__b);
          *((_DWORD *)v60 + 36) = v63;
          if (!v61)
            goto LABEL_16;
        }
        else if (!v61)
        {
          goto LABEL_16;
        }
        v65 = *((_QWORD *)v60 + 3);
        v33 = v65 <= 1;
        v66 = v65 - 1;
        if (v33)
          v67 = 0;
        else
          v67 = v66;
        if (v62 - ")" < 1
          || (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(_QWORD *)v61 + 96))(v61, ")", v62 - ")") == v62 - ")")
        {
          if ((uint64_t)v67 < 1)
            goto LABEL_107;
          __b.__locale_ = 0;
          v89 = 0;
          v90 = 0;
          if (v67 > 0x7FFFFFFFFFFFFFF7)
            goto LABEL_118;
          if (v67 >= 0x17)
          {
            v69 = (v67 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v67 | 7) != 0x17)
              v69 = v67 | 7;
            v70 = v69 + 1;
            v68 = (std::locale::__imp *)operator new(v69 + 1);
            v89 = v67;
            v90 = v70 | 0x8000000000000000;
            __b.__locale_ = v68;
          }
          else
          {
            HIBYTE(v90) = v67;
            v68 = (std::locale::__imp *)&__b;
          }
          memset(v68, v63, v67);
          *((_BYTE *)v68 + v67) = 0;
          if (v90 >= 0)
            v71 = &__b;
          else
            v71 = __b.__locale_;
          v72 = (*(uint64_t (**)(uint64_t, void *, size_t))(*(_QWORD *)v61 + 96))(v61, v71, v67);
          v73 = v72;
          if (SHIBYTE(v90) < 0)
          {
            operator delete(__b.__locale_);
            if (v73 == v67)
            {
LABEL_107:
              v74 = ")" - v62 + 1;
              if (v74 < 1
                || (*(uint64_t (**)(uint64_t, char *, int64_t))(*(_QWORD *)v61 + 96))(v61, v62, ")" - v62 + 1) == v74)
              {
                *((_QWORD *)v60 + 3) = 0;
                goto LABEL_17;
              }
            }
          }
          else if (v72 == v67)
          {
            goto LABEL_107;
          }
        }
LABEL_16:
        std::ios_base::clear((std::ios_base *)((char *)v59 + *(_QWORD *)(*v59 - 24)), *(_DWORD *)((char *)v59 + *(_QWORD *)(*v59 - 24) + 32) | 5);
LABEL_17:
        MEMORY[0x1BCCB04AC](&v86);
        std::ios_base::getloc((const std::ios_base *)((char *)v59 + *(_QWORD *)(*v59 - 24)));
        v26 = std::locale::use_facet(&__b, MEMORY[0x1E0DE4A90]);
        ((void (*)(const std::locale::facet *, uint64_t))v26->__vftable[2].~facet_0)(v26, 10);
        std::locale::~locale(&__b);
        std::ostream::put();
        std::ostream::flush();
        (*((void (**)(uint64_t))v83[0].__locale_ + 3))((uint64_t)v83);
        if (!*((_QWORD *)&v85 + 1))
          goto LABEL_11;
      }
    }
LABEL_110:
    std::ios_base::getloc((const std::ios_base *)((char *)a2 + *(_QWORD *)(*a2 - 24)));
    v75 = std::locale::use_facet(v83, MEMORY[0x1E0DE4A90]);
    ((void (*)(const std::locale::facet *, uint64_t))v75->__vftable[2].~facet_0)(v75, 10);
    std::locale::~locale(v83);
    std::ostream::put();
    return std::ostream::flush();
  }
  return result;
}

int *PartitionStore<vi_onefixedsize_disk_allocator,512>::flush(uint64_t a1)
{
  unint64_t *v2;

  v2 = *(unint64_t **)(a1 + 80);
  *v2 = 0;
  vi_onefixedsize_disk_allocator::storeHeader(v2);
  return storage_array_SyncPages(*(_QWORD *)(a1 + 80) + 8, *(_QWORD *)(a1 + 80) + 4192);
}

uint64_t PartitionStore<vi_onefixedsize_disk_allocator,512>::makeReadOnly(_QWORD *a1)
{
  uint64_t v2;
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v7;
  int *v8;

  (*(void (**)(_QWORD *))(*a1 + 136))(a1);
  v2 = a1[10];
  result = fd_make_readonly(*(_QWORD *)(v2 + 40));
  v4 = *(_QWORD *)(v2 + 40);
  if (v4)
  {
    do
    {
      result = fchmodat(*(_DWORD *)(v4 + 44), *(const char **)(v4 + 72), 0x100u, 2048);
      v5 = g_prot_error_callback;
      if ((_DWORD)result != -1 || g_prot_error_callback == 0)
        break;
      v7 = *(unsigned int *)(v4 + 40);
      v8 = __error();
      result = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t))(v5 + 16))(v5, v7, *v8, 19);
    }
    while ((result & 1) != 0);
  }
  return result;
}

_DWORD *PartitionStore<vi_onefixedsize_disk_allocator,512>::makePurgeable(uint64_t a1)
{
  return fd_mark_purgable(*(_DWORD **)(*(_QWORD *)(a1 + 80) + 40));
}

_DWORD *PartitionStore<vi_onefixedsize_disk_allocator,512>::truncate(uint64_t a1)
{
  return storage_array_Truncate((uint64_t *)(*(_QWORD *)(a1 + 80) + 8));
}

void PartitionStore<vi_onefixedsize_disk_allocator,512>::name(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  if (*(char *)(a1 + 143) < 0)
  {
    std::string::__init_copy_ctor_external(a2, *(const std::string::value_type **)(a1 + 120), *(_QWORD *)(a1 + 128));
  }
  else
  {
    *(_OWORD *)&a2->__r_.__value_.__l.__data_ = *(_OWORD *)(a1 + 120);
    a2->__r_.__value_.__r.__words[2] = *(_QWORD *)(a1 + 136);
  }
}

uint64_t PartitionStore<vi_onefixedsize_disk_allocator,512>::rename(uint64_t a1, const char *a2)
{
  return fd_rename(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 40), a2);
}

uint64_t PartitionStore<vi_onefixedsize_disk_allocator,512>::shadow(uint64_t a1, char a2, _DWORD *a3)
{
  return vi_onefixedsize_disk_allocator::shadow(*(_QWORD *)(a1 + 80), a2, a3);
}

uint64_t PartitionStore<vi_onefixedsize_disk_allocator,512>::subvert(uint64_t a1, uint64_t *a2)
{
  char *v5;
  char *v6;
  const char *v7;

  if (((*(uint64_t (**)(uint64_t *))(*a2 + 24))(a2) & 1) == 0)
  {
    v5 = __si_assert_copy_extra_268();
    v6 = v5;
    v7 = "";
    if (v5)
      v7 = v5;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1571, "old->isPersistent()", v7);
    free(v6);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  vi_onefixedsize_disk_allocator::subvert(a2[10], *(_QWORD *)(a1 + 80));
  return 1;
}

BOOL PartitionStore<vi_onefixedsize_disk_allocator,512>::unlink(uint64_t a1)
{
  return vi_onefixedsize_disk_allocator::unlinkStorage(*(_QWORD *)(a1 + 80));
}

uint64_t PartitionStore<vi_onefixedsize_disk_allocator,512>::storageSize(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 80) + 48);
}

uint64_t vi_onefixedsize_disk_allocator::subvert(uint64_t a1, uint64_t a2)
{
  char *v4;
  char *v5;
  char *v6;
  char *sibling_protected;
  char *v8;
  char *v9;
  char *v10;
  char *v11;
  char *v13;
  char *v14;
  const char *v15;
  char v16[1024];
  char v17[1024];
  char v18[1024];
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  bzero(v18, 0x400uLL);
  v4 = fd_name(*(_QWORD *)(a1 + 40), v18, 0x400uLL);
  bzero(v17, 0x400uLL);
  v5 = fd_name(*(_QWORD *)(a1 + 40), v17, 0x400uLL);
  v6 = v5;
  if (v5)
  {
    strlcat(v5, ".shadow", 0x400uLL);
    sibling_protected = (char *)fd_create_sibling_protected(*(_QWORD *)(a1 + 40), v6, 0, 0);
    if (sibling_protected)
    {
      v8 = sibling_protected;
      _fd_unlink_with_origin((uint64_t)sibling_protected, 0);
      fd_release(v8);
    }
  }
  _fd_unlink_with_origin(*(_QWORD *)(a1 + 40), 0);
  if (strstr(v6, ".shadow.shadow"))
  {
    v13 = __si_assert_copy_extra_268();
    v14 = v13;
    v15 = "";
    if (v13)
      v15 = v13;
    __message_assert("%s:%u: failed assertion '%s' %s ", "VectorIndexSupport.hh", 391, "0==strstr(shadowpathPtr, \".shadow.shadow\")", v15);
    free(v14);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  bzero(v16, 0x400uLL);
  v9 = fd_name(*(_QWORD *)(a2 + 40), v16, 0x400uLL);
  strlcat(v9, ".shadow", 0x400uLL);
  v10 = (char *)fd_create_sibling_protected(*(_QWORD *)(a2 + 40), v9, 0, 0);
  if (v10)
  {
    v11 = v10;
    _fd_unlink_with_origin((uint64_t)v10, 0);
    fd_release(v11);
  }
  return fd_rename(*(_QWORD *)(a2 + 40), v4);
}

uint64_t vi_onefixedsize_disk_allocator::shadow(uint64_t a1, char a2, _DWORD *a3)
{
  char *v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  NSObject *v11;
  CFNumberRef v13;
  int v14;
  CFIndex v15;
  int v16;
  _QWORD *sibling_protected;
  int v18;
  int v19;
  uint64_t v20;
  char *v21;
  char *v22;
  size_t v23;
  _DWORD *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  CFIndex *v29;
  uint64_t v30;
  unsigned int v31;
  uint64_t v32;
  CFIndex *v33;
  off_t v34;
  ssize_t v35;
  uint64_t v36;
  int *v38;
  char *v39;
  unint64_t v40;
  unint64_t v41;
  uint64_t v42;
  int *v43;
  BOOL v44;
  unsigned int v45;
  int v46;
  NSObject *v47;
  const char *v48;
  NSObject *v49;
  NSObject *v50;
  CFIndex v51;
  uint64_t v52;
  CFIndex v53;
  CFIndex v54;
  ssize_t v55;
  uint64_t v56;
  int *v58;
  char *v59;
  unint64_t v60;
  unint64_t v61;
  uint64_t v62;
  int *v63;
  uint64_t v64;
  unsigned int *v65;
  CFIndex v66;
  NSObject *v67;
  const char *v68;
  NSObject *v69;
  CFIndex v70;
  char *v71;
  char *v72;
  const char *v73;
  char *v74;
  const char *v75;
  uint64_t v76;
  uint64_t v77;
  CFIndex v78;
  CFIndex v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  CFIndex v84;
  char *v85;
  CFIndex *v86;
  CFIndex *v87;
  _DWORD *v88;
  unsigned int v89;
  uint64_t v90;
  uint64_t v91;
  _BYTE buf[12];
  __int16 v93;
  int v94;
  __int16 v95;
  unsigned int v96;
  __int16 v97;
  char *v98;
  _OWORD valuePtr[25];
  char __dst[1024];
  char v101[1024];
  uint64_t v102;
  CFRange v103;

  v102 = *MEMORY[0x1E0C80C00];
  bzero(v101, 0x400uLL);
  bzero(__dst, 0x400uLL);
  v6 = fd_name(*(_QWORD *)(a1 + 40), v101, 0x400uLL);
  if (v6)
  {
    v7 = v6;
    if (strstr(v6, "tmp."))
    {
      v71 = __si_assert_copy_extra_268();
      v72 = v71;
      v73 = "";
      if (v71)
        v73 = v71;
      __message_assert("%s:%u: failed assertion '%s' %s ", "VectorIndexSupport.hh", 551, "strstr(pathPtr, \"tmp.\") == 0", v73);
    }
    else
    {
      strlcpy(__dst, v7, 0x400uLL);
      strlcat(v7, ".shadow", 0x400uLL);
      v8 = *(_QWORD *)(a1 + 40);
      if (v8)
        v9 = *(unsigned int *)(v8 + 44);
      else
        v9 = 0xFFFFFFFFLL;
      LODWORD(valuePtr[0]) = v9;
      v13 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, valuePtr);
      pthread_mutex_lock(&registeredFdsLock);
      if (registeredCloneFds)
      {
        v14 = CFSetContainsValue((CFSetRef)registeredCloneFds, v13);
        pthread_mutex_unlock(&registeredFdsLock);
        CFRelease(v13);
        if (v14 && copyFileFallback(v9, __dst, v9, v7, a3, 0, 1))
        {
          v15 = *(_QWORD *)(a1 + 4192);
          if (v15 >= 1)
          {
            bit_vector_internal_touch_for_set((CFIndex *)(a1 + 4192), v15 - 1);
            v103.location = 0;
            v103.length = v15;
            CFBitVectorSetBits(*(CFMutableBitVectorRef *)(a1 + 4208), v103, 0);
          }
          return 0;
        }
      }
      else
      {
        pthread_mutex_unlock(&registeredFdsLock);
        CFRelease(v13);
      }
      v16 = *(_DWORD *)(a1 + 56);
      memset(valuePtr, 0, sizeof(valuePtr));
      v90 = 0;
      v91 = 0;
      sibling_protected = fd_create_sibling_protected(*(_QWORD *)(a1 + 40), v7, 514, 0);
      *(_QWORD *)buf = 0;
      v18 = _fd_acquire_fd((uint64_t)sibling_protected, buf);
      if (v18 == -1)
      {
        if (!sibling_protected)
        {
          v45 = *__error();
          v46 = *__error();
          v49 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315906;
            *(_QWORD *)&buf[4] = "shadow";
            v93 = 1024;
            v94 = 583;
            v95 = 1024;
            v96 = v45;
            v97 = 2080;
            v98 = v7;
            _os_log_error_impl(&dword_1B8270000, v49, OS_LOG_TYPE_ERROR, "%s:%d: open err: %d, %s", buf, 0x22u);
          }
          v22 = 0;
          goto LABEL_68;
        }
      }
      else
      {
        v19 = v18;
        *((_WORD *)sibling_protected + 28) |= 1u;
        fcntl(v18, 48, 1);
        fcntl(v19, 76, sibling_protected[7] & 1);
        _fd_release_fd(sibling_protected, v19, 0, *(uint64_t *)buf);
      }
      v20 = (v16 + 0xFFFFF) >> 20;
      if ((a2 & 1) == 0 && v20 >= *(_QWORD *)(a1 + 4192))
        v20 = *(_QWORD *)(a1 + 4192);
      v21 = (char *)malloc_type_malloc(0x100000uLL, 0x418DA263uLL);
      if (v21)
      {
        v22 = v21;
        v23 = *(_QWORD *)(a1 + 56);
        v24 = *(_DWORD **)(a1 + 40);
        if (!(v23 >> 20))
        {
          if (fd_pread(v24, v22, v23, 0) != -1)
          {
            if (fd_pwrite((uint64_t)sibling_protected, (uint64_t)v22, *(_QWORD *)(a1 + 56), 0) != -1)
            {
              bit_vector_internal_touch_for_set((CFIndex *)(a1 + 4192), 0);
              CFBitVectorSetBitAtIndex(*(CFMutableBitVectorRef *)(a1 + 4208), 0, 0);
LABEL_128:
              fd_release((char *)sibling_protected);
              free(v22);
              return 0;
            }
            v45 = *__error();
            v46 = *__error();
            v47 = _SILogForLogForCategory(0);
            if (!os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
              goto LABEL_68;
            *(_DWORD *)buf = 136315650;
            *(_QWORD *)&buf[4] = "shadow";
            v93 = 1024;
            v94 = 602;
            v95 = 1024;
            v96 = v45;
            v48 = "%s:%d: pwrite err: %d";
            goto LABEL_67;
          }
          v45 = *__error();
          v46 = *__error();
          v47 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315650;
            *(_QWORD *)&buf[4] = "shadow";
            v93 = 1024;
            v94 = 597;
            v95 = 1024;
            v96 = v45;
            v48 = "%s:%d: read err: %d";
LABEL_67:
            _os_log_error_impl(&dword_1B8270000, v47, OS_LOG_TYPE_ERROR, v48, buf, 0x18u);
            goto LABEL_68;
          }
          goto LABEL_68;
        }
        v25 = _fd_acquire_fd((uint64_t)v24, &v90);
        if ((_DWORD)v25 == -1)
        {
          v45 = *__error();
          v46 = *__error();
          v47 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315650;
            *(_QWORD *)&buf[4] = "shadow";
            v93 = 1024;
            v94 = 610;
            v95 = 1024;
            v96 = v45;
            v48 = "%s:%d: fd_open err: %d";
            goto LABEL_67;
          }
LABEL_68:
          LODWORD(v28) = -1;
          LODWORD(v26) = -1;
LABEL_69:
          *__error() = v46;
          goto LABEL_70;
        }
        v26 = v25;
        v27 = _fd_acquire_fd((uint64_t)sibling_protected, &v91);
        if ((_DWORD)v27 == -1)
        {
          v45 = *__error();
          v46 = *__error();
          v50 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315650;
            *(_QWORD *)&buf[4] = "shadow";
            v93 = 1024;
            v94 = 616;
            v95 = 1024;
            v96 = v45;
            _os_log_error_impl(&dword_1B8270000, v50, OS_LOG_TYPE_ERROR, "%s:%d: fd_open err: %d", buf, 0x18u);
          }
          LODWORD(v28) = -1;
          goto LABEL_69;
        }
        v28 = v27;
        if (v20 >= 1)
        {
          v29 = (CFIndex *)(a1 + 4192);
          v89 = v27;
          v88 = a3;
          if ((a2 & 1) != 0)
          {
            v30 = 0;
            v31 = 0;
            while (v31 != 100)
            {
LABEL_56:
              *((_DWORD *)valuePtr + v31++) = v30;
              if (++v30 == v20)
                goto LABEL_106;
            }
            v32 = 0;
            while (*a3 != 1 && *a3 != -1)
            {
              v81 = v32;
              v83 = v30;
              v33 = v29;
              v79 = *((unsigned int *)valuePtr + v32);
              v34 = v79 << 20;
              while (1)
              {
                v35 = pread(v26, v22, 0x100000uLL, v34);
                v36 = g_prot_error_callback;
                if (v35 != -1 || g_prot_error_callback == 0)
                  break;
                v38 = __error();
                if (((*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t))(v36 + 16))(v36, v26, *v38, 4) & 1) == 0)goto LABEL_116;
              }
              if (v35 == -1)
                goto LABEL_116;
              if (*v88 == 1 || *v88 == -1)
                goto LABEL_131;
              v85 = v22;
              v86 = v33;
              v77 = 0;
              v39 = v22;
              v40 = 0x100000;
              while (1)
              {
                while (1)
                {
                  v41 = guarded_pwrite_np();
                  if ((v41 & 0x8000000000000000) == 0)
                    break;
                  v42 = g_prot_error_callback;
                  if (g_prot_error_callback)
                  {
                    v43 = __error();
                    if (((*(uint64_t (**)(uint64_t, _QWORD, _QWORD, uint64_t))(v42 + 16))(v42, v89, *v43, 5) & 1) != 0)continue;
                  }
                  goto LABEL_119;
                }
                v44 = v40 > v41;
                v40 -= v41;
                if (!v44)
                  break;
                v77 += v41;
                v39 += v41;
                v34 += v41;
              }
              v28 = v89;
              if (v41 + v77 == -1)
                goto LABEL_119;
              bit_vector_internal_touch_for_set(v86, v79);
              CFBitVectorSetBitAtIndex(*(CFMutableBitVectorRef *)(a1 + 4208), v79, 0);
              v29 = v86;
              v30 = v83;
              v32 = v81 + 1;
              a3 = v88;
              if (v81 == 99)
              {
                v31 = 0;
                goto LABEL_56;
              }
            }
            goto LABEL_130;
          }
          v51 = 0;
          v31 = 0;
          do
          {
            if (v31 == 100)
            {
              v52 = 0;
              while (2)
              {
                if (*a3 == 1)
                  goto LABEL_130;
                v82 = v52;
                v84 = v51;
                v53 = *((unsigned int *)valuePtr + v52);
                v54 = v53 << 20;
                while (1)
                {
                  v55 = pread(v26, v22, 0x100000uLL, v53 << 20);
                  v56 = g_prot_error_callback;
                  if (v55 != -1 || g_prot_error_callback == 0)
                    break;
                  v58 = __error();
                  if (((*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t))(v56 + 16))(v56, v26, *v58, 4) & 1) == 0)goto LABEL_116;
                }
                if (v55 == -1)
                {
LABEL_116:
                  v45 = *__error();
                  v46 = *__error();
                  v67 = _SILogForLogForCategory(0);
                  LODWORD(v28) = v89;
                  if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)buf = 136315650;
                    *(_QWORD *)&buf[4] = "shadow";
                    v93 = 1024;
                    v94 = 629;
                    v95 = 1024;
                    v96 = v45;
                    v68 = "%s:%d: read err: %d";
LABEL_118:
                    _os_log_error_impl(&dword_1B8270000, v67, OS_LOG_TYPE_ERROR, v68, buf, 0x18u);
                  }
                  goto LABEL_69;
                }
                if (*v88 == 1)
                {
LABEL_131:
                  v45 = 89;
                  LODWORD(v28) = v89;
                  goto LABEL_70;
                }
                v78 = v53;
                v80 = 0;
                v85 = v22;
                v59 = v22;
                v60 = 0x100000;
                while (1)
                {
                  while (1)
                  {
                    v61 = guarded_pwrite_np();
                    if ((v61 & 0x8000000000000000) == 0)
                      break;
                    v62 = g_prot_error_callback;
                    if (g_prot_error_callback)
                    {
                      v63 = __error();
                      if (((*(uint64_t (**)(uint64_t, _QWORD, _QWORD, uint64_t))(v62 + 16))(v62, v89, *v63, 5) & 1) != 0)continue;
                    }
                    goto LABEL_119;
                  }
                  v44 = v60 > v61;
                  v60 -= v61;
                  if (!v44)
                    break;
                  v80 += v61;
                  v59 += v61;
                  v54 += v61;
                }
                v28 = v89;
                if (v61 + v80 == -1)
                {
LABEL_119:
                  v45 = *__error();
                  v46 = *__error();
                  v69 = _SILogForLogForCategory(0);
                  if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)buf = 136315650;
                    *(_QWORD *)&buf[4] = "shadow";
                    v93 = 1024;
                    v94 = 638;
                    v95 = 1024;
                    v96 = v45;
                    _os_log_error_impl(&dword_1B8270000, v69, OS_LOG_TYPE_ERROR, "%s:%d: pwrite err: %d", buf, 0x18u);
                  }
                  LODWORD(v28) = v89;
                  v22 = v85;
                  goto LABEL_69;
                }
                bit_vector_internal_touch_for_set((CFIndex *)(a1 + 4192), v78);
                CFBitVectorSetBitAtIndex(*(CFMutableBitVectorRef *)(a1 + 4208), v78, 0);
                v51 = v84;
                v52 = v82 + 1;
                a3 = v88;
                if (v82 != 99)
                  continue;
                break;
              }
              v29 = (CFIndex *)(a1 + 4192);
              v31 = 0;
            }
            if (*v29 > v51)
            {
              if (CFBitVectorGetBitAtIndex(*(CFBitVectorRef *)(a1 + 4208), v51))
                *((_DWORD *)valuePtr + v31++) = v51;
              v29 = (CFIndex *)(a1 + 4192);
            }
            ++v51;
          }
          while (v51 != v20);
LABEL_106:
          v87 = v29;
          if (v31)
          {
            v64 = v31;
            v65 = (unsigned int *)valuePtr;
            if ((a2 & 1) != 0)
            {
              while (*a3 != 1 && *a3 != -1)
              {
                v66 = *v65;
                if (prot_pread(v26, v22, 0x100000uLL, v66 << 20) == -1)
                  goto LABEL_142;
                if (*a3 == 1 || *a3 == -1)
                  break;
                if (prot_pwrite_guarded(v28, (uint64_t)&v91, (uint64_t)v22, 0x100000uLL, v66 << 20) == -1)
                  goto LABEL_144;
                bit_vector_internal_touch_for_set(v87, v66);
                CFBitVectorSetBitAtIndex(*(CFMutableBitVectorRef *)(a1 + 4208), v66, 0);
                ++v65;
                if (!--v64)
                  goto LABEL_127;
              }
            }
            else
            {
              while (*a3 != 1)
              {
                v70 = *v65;
                if (prot_pread(v26, v22, 0x100000uLL, v70 << 20) == -1)
                {
LABEL_142:
                  v45 = *__error();
                  v46 = *__error();
                  v67 = _SILogForLogForCategory(0);
                  if (!os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
                    goto LABEL_69;
                  *(_DWORD *)buf = 136315650;
                  *(_QWORD *)&buf[4] = "shadow";
                  v93 = 1024;
                  v94 = 666;
                  v95 = 1024;
                  v96 = v45;
                  v68 = "%s:%d: pread err: %d";
                  goto LABEL_118;
                }
                if (*a3 == 1)
                  break;
                if (prot_pwrite_guarded(v28, (uint64_t)&v91, (uint64_t)v22, 0x100000uLL, v70 << 20) == -1)
                {
LABEL_144:
                  v45 = *__error();
                  v46 = *__error();
                  v67 = _SILogForLogForCategory(0);
                  if (!os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
                    goto LABEL_69;
                  *(_DWORD *)buf = 136315650;
                  *(_QWORD *)&buf[4] = "shadow";
                  v93 = 1024;
                  v94 = 675;
                  v95 = 1024;
                  v96 = v45;
                  v68 = "%s:%d: pwrite err: %d";
                  goto LABEL_118;
                }
                bit_vector_internal_touch_for_set(v87, v70);
                CFBitVectorSetBitAtIndex(*(CFMutableBitVectorRef *)(a1 + 4208), v70, 0);
                ++v65;
                if (!--v64)
                  goto LABEL_127;
              }
            }
LABEL_130:
            v45 = 89;
LABEL_70:
            free(v22);
            _fd_release_fd(*(_DWORD **)(a1 + 40), v26, 0, v90);
            _fd_release_fd(sibling_protected, v28, 0, v91);
            fd_release((char *)sibling_protected);
            if (v45)
              return v45;
            else
              return 0xFFFFFFFFLL;
          }
        }
LABEL_127:
        _fd_release_fd(*(_DWORD **)(a1 + 40), v26, 0, v90);
        _fd_release_fd(sibling_protected, v28, 0, v91);
        goto LABEL_128;
      }
      v74 = __si_assert_copy_extra_268();
      v72 = v74;
      v75 = "";
      if (v74)
        v75 = v74;
      __message_assert("%s:%u: failed assertion '%s' %s ", "VectorIndexSupport.hh", 593, "readBuffer", v75);
    }
    free(v72);
    if (__valid_fs(-1))
      v76 = 2989;
    else
      v76 = 3072;
    *(_DWORD *)v76 = -559038737;
    abort();
  }
  v10 = *__error();
  v11 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    LODWORD(valuePtr[0]) = 136315394;
    *(_QWORD *)((char *)valuePtr + 4) = "shadow";
    WORD6(valuePtr[0]) = 1024;
    *(_DWORD *)((char *)valuePtr + 14) = 547;
    _os_log_error_impl(&dword_1B8270000, v11, OS_LOG_TYPE_ERROR, "%s:%d: no path for shadow", (uint8_t *)valuePtr, 0x12u);
  }
  *__error() = v10;
  return 0xFFFFFFFFLL;
}

uint64_t PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionEnumerator::PartitionEnumerator(uint64_t a1, uint64_t a2, unsigned int a3)
{
  unint64_t v4;
  unsigned int v5;
  char *v7;
  char *v8;
  const char *v9;

  *(_QWORD *)a1 = &off_1E6E337F0;
  *(_QWORD *)(a1 + 8) = a2;
  *(_QWORD *)(a1 + 20) = 0x100000001;
  *(_QWORD *)(a1 + 40) = 0;
  if (!a2)
  {
    v7 = __si_assert_copy_extra_268();
    v8 = v7;
    v9 = "";
    if (v7)
      v9 = v7;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1367, "store != nullptr", v9);
    free(v8);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v4 = _windowsResolvePtr(*(_QWORD *)(a2 + 80) + 40, *(_QWORD *)(*(_QWORD *)(a2 + 80) + 24) + *(_QWORD *)(*(_QWORD *)(a2 + 80) + 16) * a3, 0x100CuLL);
  v5 = *(_DWORD *)(v4 + 8);
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v4 + 4);
  if (v5 > *(_DWORD *)(a1 + 24))
    *(_QWORD *)(a1 + 32) = v4;
  return a1;
}

uint64_t PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionEnumerator::next(uint64_t a1)
{
  uint64_t v2;
  unsigned int *v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t result;
  uint64_t v7;
  unint64_t v8;
  int v9;
  NSObject *v10;
  int *v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  double v17;
  char *v18;
  char *v19;
  const char *v20;
  char *v21;
  const char *v22;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  int v26;
  __int16 v27;
  int v28;
  __int16 v29;
  int v30;
  __int16 v31;
  int v32;
  __int16 v33;
  int v34;
  __int16 v35;
  int v36;
  __int16 v37;
  int v38;
  __int16 v39;
  double v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 8);
  if (!v2 || (v3 = *(unsigned int **)(a1 + 32)) == 0 || (v4 = *(_DWORD *)(a1 + 24), v4 >= v3[2]))
  {
    result = 0;
    goto LABEL_7;
  }
  v5 = *(unsigned int *)(a1 + 20);
  if (v5 <= 0x1FF)
  {
    *(_DWORD *)(a1 + 20) = v5 + 1;
    *(_DWORD *)(a1 + 24) = v4 + 1;
    result = (uint64_t)&v3[2 * v5 + 3];
LABEL_7:
    *(_QWORD *)(a1 + 40) = result;
    return result;
  }
  v7 = *v3;
  if ((_DWORD)v7)
  {
    v8 = _windowsResolvePtr(*(_QWORD *)(v2 + 80) + 40, *(_QWORD *)(*(_QWORD *)(v2 + 80) + 24) + *(_QWORD *)(*(_QWORD *)(v2 + 80) + 16) * v7, 0x100CuLL);
    if (*(_DWORD *)(v8 + 8))
      goto LABEL_13;
    v9 = *__error();
    v10 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      v11 = *(int **)(a1 + 32);
      v12 = *v11;
      v13 = *(_DWORD *)(a1 + 16);
      v14 = *(_DWORD *)(a1 + 20);
      v15 = *(_DWORD *)(a1 + 24);
      LODWORD(v11) = v11[2];
      v16 = *(_DWORD *)(v8 + 12);
      v17 = *(float *)(v8 + 16);
      *(_DWORD *)buf = 136317186;
      v24 = "next";
      v25 = 1024;
      v26 = 1392;
      v27 = 1024;
      v28 = v12;
      v29 = 1024;
      v30 = v13;
      v31 = 1024;
      v32 = v14;
      v33 = 1024;
      v34 = v15;
      v35 = 1024;
      v36 = (int)v11;
      v37 = 1024;
      v38 = v16;
      v39 = 2048;
      v40 = v17;
      _os_log_error_impl(&dword_1B8270000, v10, OS_LOG_TYPE_ERROR, "%s:%d: blockAt(%u).count=0 centOffset=%u currentOffset=%u visited=%u count=%u vec[0]=%u(%f)", buf, 0x40u);
    }
    *__error() = v9;
    if (*(_DWORD *)(v8 + 8))
    {
LABEL_13:
      if (*(_DWORD *)(v8 + 4) == *(_DWORD *)(a1 + 16))
      {
        *(_QWORD *)(a1 + 32) = v8;
        result = v8 + 12;
        *(_QWORD *)(a1 + 20) = 0x100000001;
        goto LABEL_7;
      }
      v21 = __si_assert_copy_extra_268();
      v19 = v21;
      v22 = "";
      if (v21)
        v22 = v21;
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1395, "block->centOffset == centOffset", v22);
    }
    else
    {
      v18 = __si_assert_copy_extra_268();
      v19 = v18;
      v20 = "";
      if (v18)
        v20 = v18;
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1394, "block->count > 0", v20);
    }
    free(v19);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  return 0;
}

void PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionIterator::~PartitionIterator()
{
  JUMPOUT(0x1BCCB06A4);
}

uint64_t PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionEnumerator::centroidOffset(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

void PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionEnumerator::~PartitionEnumerator()
{
  JUMPOUT(0x1BCCB06A4);
}

void std::__shared_ptr_emplace<PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionEnumerator,std::allocator<PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionEnumerator>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6E33820;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionEnumerator,std::allocator<PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionEnumerator>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6E33820;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BCCB06A4);
}

uint64_t std::__shared_ptr_emplace<PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionEnumerator,std::allocator<PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionEnumerator>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

uint64_t *std::back_insert_iterator<std::vector<unsigned int>>::operator=[abi:nn180100](uint64_t *a1, int a2)
{
  uint64_t v4;
  unint64_t v5;
  char *v6;
  char *v7;
  _DWORD *v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  _BYTE *v15;
  _DWORD *v16;
  char *v17;
  unint64_t v18;
  uint64_t v19;
  _OWORD *v20;
  char *v21;
  uint64_t v22;
  __int128 v23;
  int v24;

  v4 = *a1;
  v6 = *(char **)(*a1 + 8);
  v5 = *(_QWORD *)(*a1 + 16);
  v7 = v6;
  if ((unint64_t)v6 >= v5)
  {
    v9 = *(char **)v4;
    v10 = (uint64_t)&v6[-*(_QWORD *)v4];
    v11 = v10 >> 2;
    v12 = (v10 >> 2) + 1;
    if (v12 >> 62)
      abort();
    v13 = v5 - (_QWORD)v9;
    if (v13 >> 1 > v12)
      v12 = v13 >> 1;
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFFCLL)
      v14 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v14 = v12;
    if (v14)
    {
      if (v14 >> 62)
        std::__throw_bad_array_new_length[abi:nn180100]();
      v15 = operator new(4 * v14);
    }
    else
    {
      v15 = 0;
    }
    v16 = &v15[4 * v11];
    v17 = &v15[4 * v14];
    *v16 = a2;
    v8 = v16 + 1;
    if (v6 != v9)
    {
      v18 = v6 - v9 - 4;
      if (v18 < 0x2C)
        goto LABEL_27;
      if ((unint64_t)(v6 - v15 - v10) < 0x20)
        goto LABEL_27;
      v19 = (v18 >> 2) + 1;
      v7 = &v6[-4 * (v19 & 0x7FFFFFFFFFFFFFF8)];
      v20 = &v15[4 * v11 - 16];
      v21 = v6 - 16;
      v22 = v19 & 0x7FFFFFFFFFFFFFF8;
      do
      {
        v23 = *(_OWORD *)v21;
        *(v20 - 1) = *((_OWORD *)v21 - 1);
        *v20 = v23;
        v20 -= 2;
        v21 -= 32;
        v22 -= 8;
      }
      while (v22);
      v16 -= v19 & 0x7FFFFFFFFFFFFFF8;
      if (v19 != (v19 & 0x7FFFFFFFFFFFFFF8))
      {
LABEL_27:
        do
        {
          v24 = *((_DWORD *)v7 - 1);
          v7 -= 4;
          *--v16 = v24;
        }
        while (v7 != v9);
      }
    }
    *(_QWORD *)v4 = v16;
    *(_QWORD *)(v4 + 8) = v8;
    *(_QWORD *)(v4 + 16) = v17;
    if (v9)
      operator delete(v9);
  }
  else
  {
    *(_DWORD *)v6 = a2;
    v8 = v6 + 4;
  }
  *(_QWORD *)(v4 + 8) = v8;
  return a1;
}

__n128 std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,PartitionStore<vi_onefixedsize_disk_allocator,512>::enumeratePartitions(std::vector<unsigned int>,void({block_pointer})(unsigned int,AnyPartitionStore::VectorEntry_s const&,BOOL *))::Greater &,std::__wrap_iter<std::tuple<PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionIterator,PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionIterator,unsigned int> *>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int64_t v3;
  int64_t v4;
  uint64_t v5;
  BOOL v6;
  _DWORD *v7;
  int v8;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  uint64_t v15;
  __n128 result;
  __n128 v17;
  __int128 v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;

  if (a2 >= 2)
  {
    v3 = (unint64_t)(a2 - 2) >> 1;
    if (v3 >= 0x4EC4EC4EC4EC4EC5 * ((a3 - a1) >> 3))
    {
      v4 = (0x9D89D89D89D89D8ALL * ((a3 - a1) >> 3)) | 1;
      v5 = a1 + 104 * v4;
      if ((uint64_t)(0x9D89D89D89D89D8ALL * ((a3 - a1) >> 3) + 2) < a2)
      {
        v6 = **(_DWORD **)(v5 + 40) > **(_DWORD **)(v5 + 144);
        v5 += 104 * v6;
        if (v6)
          v4 = 0x9D89D89D89D89D8ALL * ((a3 - a1) >> 3) + 2;
      }
      v7 = *(_DWORD **)(a3 + 40);
      if (**(_DWORD **)(v5 + 40) <= *v7)
      {
        v20 = *(_OWORD *)(a3 + 8);
        v21 = *(_OWORD *)(a3 + 24);
        v17 = *(__n128 *)(a3 + 56);
        v18 = *(_OWORD *)(a3 + 72);
        v19 = *(_QWORD *)(a3 + 88);
        v8 = *(_DWORD *)(a3 + 96);
        do
        {
          v9 = a3;
          a3 = v5;
          v10 = *(_OWORD *)(v5 + 8);
          v11 = *(_OWORD *)(v5 + 24);
          *(_QWORD *)(v9 + 40) = *(_QWORD *)(v5 + 40);
          *(_OWORD *)(v9 + 24) = v11;
          *(_OWORD *)(v9 + 8) = v10;
          v12 = *(_OWORD *)(v5 + 56);
          v13 = *(_OWORD *)(v5 + 72);
          *(_QWORD *)(v9 + 88) = *(_QWORD *)(v5 + 88);
          *(_OWORD *)(v9 + 72) = v13;
          *(_OWORD *)(v9 + 56) = v12;
          *(_DWORD *)(v9 + 96) = *(_DWORD *)(v5 + 96);
          if (v3 < v4)
            break;
          v14 = (2 * v4) | 1;
          v5 = a1 + 104 * v14;
          v15 = 2 * v4 + 2;
          if (v15 < a2)
          {
            v6 = **(_DWORD **)(v5 + 40) > **(_DWORD **)(v5 + 144);
            v5 += 104 * v6;
            if (v6)
              v14 = v15;
          }
          v4 = v14;
        }
        while (**(_DWORD **)(v5 + 40) <= *v7);
        *(_OWORD *)(a3 + 8) = v20;
        *(_OWORD *)(a3 + 24) = v21;
        *(_QWORD *)(a3 + 40) = v7;
        result = v17;
        *(__n128 *)(a3 + 56) = v17;
        *(_OWORD *)(a3 + 72) = v18;
        *(_QWORD *)(a3 + 88) = v19;
        *(_DWORD *)(a3 + 96) = v8;
      }
    }
  }
  return result;
}

uint64_t PartitionStore<vi_onefixedsize_disk_allocator,512>::~PartitionStore(uint64_t a1)
{
  void *v2;
  void *v3;
  uint64_t v4;
  const void *v5;
  void *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;

  *(_QWORD *)a1 = off_1E6E336F0;
  v2 = *(void **)(a1 + 144);
  if (v2)
  {
    *(_QWORD *)(a1 + 152) = v2;
    operator delete(v2);
  }
  if ((*(char *)(a1 + 143) & 0x80000000) == 0)
  {
    v3 = *(void **)(a1 + 96);
    if (!v3)
      goto LABEL_6;
    goto LABEL_5;
  }
  operator delete(*(void **)(a1 + 120));
  v3 = *(void **)(a1 + 96);
  if (v3)
  {
LABEL_5:
    *(_QWORD *)(a1 + 104) = v3;
    operator delete(v3);
  }
LABEL_6:
  v4 = *(_QWORD *)(a1 + 80);
  *(_QWORD *)(a1 + 80) = 0;
  if (v4)
  {
    storage_array_Close(v4 + 8);
    v5 = *(const void **)(v4 + 4208);
    if (v5)
    {
      CFRelease(v5);
      *(_QWORD *)(v4 + 4208) = 0;
    }
    *(_OWORD *)(v4 + 4192) = 0u;
    MEMORY[0x1BCCB06A4](v4, 0x10A0C408BE2A288);
  }
  *(_QWORD *)a1 = &unk_1E6E310A8;
  v6 = *(void **)(a1 + 32);
  if (v6)
  {
    *(_QWORD *)(a1 + 40) = v6;
    operator delete(v6);
  }
  v7 = *(std::__shared_weak_count **)(a1 + 16);
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  return a1;
}

uint64_t AnyPartitionStore::shadow(AnyPartitionStore *this, BOOL a2, volatile int *a3)
{
  return 0;
}

uint64_t AnyPartitionStore::subvert(AnyPartitionStore *this, const AnyPartitionStore *a2)
{
  return 1;
}

uint64_t AnyPartitionStore::unlink(AnyPartitionStore *this)
{
  return 1;
}

void std::__shared_ptr_emplace<PartitionStore<vi_onefixedsize_disk_allocator,512>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6E336B8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PartitionStore<vi_onefixedsize_disk_allocator,512>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6E336B8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BCCB06A4);
}

uint64_t std::__shared_ptr_emplace<PartitionStore<vi_onefixedsize_disk_allocator,512>>::__on_zero_shared(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)(a1 + 24) + 8))(a1 + 24);
}

uint64_t std::unordered_map<std::string,std::weak_ptr<QuantizerManager<float,768>>>::~unordered_map[abi:nn180100](uint64_t a1)
{
  char *v2;
  void *v3;
  char *v5;
  std::__shared_weak_count *v6;

  v2 = *(char **)(a1 + 16);
  if (v2)
  {
    do
    {
      v5 = *(char **)v2;
      v6 = (std::__shared_weak_count *)*((_QWORD *)v2 + 6);
      if (v6)
        std::__shared_weak_count::__release_weak(v6);
      if (v2[39] < 0)
        operator delete(*((void **)v2 + 2));
      operator delete(v2);
      v2 = v5;
    }
    while (v5);
  }
  v3 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v3)
    operator delete(v3);
  return a1;
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::weak_ptr<QuantizerManager<float,768>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::weak_ptr<QuantizerManager<float,768>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::weak_ptr<QuantizerManager<float,768>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::weak_ptr<QuantizerManager<float,768>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1, uint64_t a2)
{
  int v3;
  uint64_t *v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint8x8_t v9;
  unint64_t v10;
  void **v11;
  unsigned __int8 *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  std::string *v21;
  float v22;
  _BOOL8 v23;
  unint64_t v24;
  unint64_t v25;
  size_t prime;
  void *v27;
  void *v28;
  uint64_t v29;
  _QWORD **v30;
  size_t v31;
  size_t v32;
  size_t v33;
  _QWORD *i;
  size_t v35;
  uint64_t v36;
  unint64_t v37;
  uint8x8_t v38;
  uint64_t v39;
  _QWORD *v40;
  uint64_t v41;
  size_t v42;
  uint64_t v43;
  _QWORD *v44;
  unint64_t v45;
  void *v47;

  v3 = *(char *)(a1 + 23);
  if (v3 >= 0)
    v4 = (uint64_t *)a1;
  else
    v4 = *(uint64_t **)a1;
  if (v3 >= 0)
    v5 = *(unsigned __int8 *)(a1 + 23);
  else
    v5 = *(_QWORD *)(a1 + 8);
  v6 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v4, v5);
  v7 = v6;
  v8 = *((_QWORD *)&QuantizerManager<float,768>::sharedInstance(int,unsigned int,unsigned short)::managers + 1);
  if (*((_QWORD *)&QuantizerManager<float,768>::sharedInstance(int,unsigned int,unsigned short)::managers + 1))
  {
    v9 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&QuantizerManager<float,768>::sharedInstance(int,unsigned int,unsigned short)::managers
                                        + 8));
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      v10 = v6;
      if (v6 >= *((_QWORD *)&QuantizerManager<float,768>::sharedInstance(int,unsigned int,unsigned short)::managers + 1))
        v10 = v6
            % *((_QWORD *)&QuantizerManager<float,768>::sharedInstance(int,unsigned int,unsigned short)::managers + 1);
    }
    else
    {
      v10 = (*((_QWORD *)&QuantizerManager<float,768>::sharedInstance(int,unsigned int,unsigned short)::managers + 1)
           - 1) & v6;
    }
    v11 = *(void ***)(QuantizerManager<float,768>::sharedInstance(int,unsigned int,unsigned short)::managers + 8 * v10);
    if (v11)
    {
      v12 = (unsigned __int8 *)*v11;
      if (*v11)
      {
        if (v9.u32[0] < 2uLL)
        {
          while (1)
          {
            v17 = *((_QWORD *)v12 + 1);
            if (v17 == v7)
            {
              v18 = v12[39];
              if ((v18 & 0x80u) == 0)
                v19 = v12[39];
              else
                v19 = *((_QWORD *)v12 + 3);
              if (v19 == v5)
              {
                if ((v18 & 0x80) != 0)
                {
                  if (!memcmp(*((const void **)v12 + 2), v4, *((_QWORD *)v12 + 3)))
                    return v12;
                }
                else
                {
                  if (!v12[39])
                    return v12;
                  v20 = 0;
                  while (v12[v20 + 16] == *((unsigned __int8 *)v4 + v20))
                  {
                    if (v18 == ++v20)
                      return v12;
                  }
                }
              }
            }
            else if ((v17 & (v8 - 1)) != v10)
            {
              goto LABEL_49;
            }
            v12 = *(unsigned __int8 **)v12;
            if (!v12)
              goto LABEL_49;
          }
        }
        do
        {
          v13 = *((_QWORD *)v12 + 1);
          if (v13 == v7)
          {
            v14 = v12[39];
            if ((v14 & 0x80u) == 0)
              v15 = v12[39];
            else
              v15 = *((_QWORD *)v12 + 3);
            if (v15 == v5)
            {
              if ((v14 & 0x80) != 0)
              {
                if (!memcmp(*((const void **)v12 + 2), v4, *((_QWORD *)v12 + 3)))
                  return v12;
              }
              else
              {
                if (!v12[39])
                  return v12;
                v16 = 0;
                while (v12[v16 + 16] == *((unsigned __int8 *)v4 + v16))
                {
                  if (v14 == ++v16)
                    return v12;
                }
              }
            }
          }
          else
          {
            if (v13 >= v8)
              v13 %= v8;
            if (v13 != v10)
              break;
          }
          v12 = *(unsigned __int8 **)v12;
        }
        while (v12);
      }
    }
  }
  else
  {
    v10 = 0;
  }
LABEL_49:
  v12 = (unsigned __int8 *)operator new(0x38uLL);
  *(_QWORD *)v12 = 0;
  *((_QWORD *)v12 + 1) = v7;
  v21 = (std::string *)(v12 + 16);
  if (*(char *)(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v21, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)&v21->__r_.__value_.__l.__data_ = *(_OWORD *)a2;
    *((_QWORD *)v12 + 4) = *(_QWORD *)(a2 + 16);
  }
  *((_QWORD *)v12 + 5) = 0;
  *((_QWORD *)v12 + 6) = 0;
  v22 = (float)(unint64_t)(qword_1EF1B0788 + 1);
  if (!v8 || (float)(*(float *)&dword_1EF1B0790 * (float)v8) < v22)
  {
    v23 = 1;
    if (v8 >= 3)
      v23 = (v8 & (v8 - 1)) != 0;
    v24 = v23 | (2 * v8);
    v25 = vcvtps_u32_f32(v22 / *(float *)&dword_1EF1B0790);
    if (v24 <= v25)
      prime = v25;
    else
      prime = v24;
    if (prime == 1)
    {
      prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      prime = std::__next_prime(prime);
    }
    v8 = *((_QWORD *)&QuantizerManager<float,768>::sharedInstance(int,unsigned int,unsigned short)::managers + 1);
    if (prime <= *((_QWORD *)&QuantizerManager<float,768>::sharedInstance(int,unsigned int,unsigned short)::managers + 1))
    {
      if (prime >= *((_QWORD *)&QuantizerManager<float,768>::sharedInstance(int,unsigned int,unsigned short)::managers
                    + 1))
        goto LABEL_89;
      v37 = vcvtps_u32_f32((float)(unint64_t)qword_1EF1B0788 / *(float *)&dword_1EF1B0790);
      if (*((_QWORD *)&QuantizerManager<float,768>::sharedInstance(int,unsigned int,unsigned short)::managers + 1) < 3uLL
        || (v38 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&QuantizerManager<float,768>::sharedInstance(int,unsigned int,unsigned short)::managers
                                                 + 8)),
            v38.i16[0] = vaddlv_u8(v38),
            v38.u32[0] > 1uLL))
      {
        v37 = std::__next_prime(v37);
      }
      else
      {
        v39 = 1 << -(char)__clz(v37 - 1);
        if (v37 >= 2)
          v37 = v39;
      }
      if (prime <= v37)
        prime = v37;
      if (prime >= v8)
      {
        v8 = *((_QWORD *)&QuantizerManager<float,768>::sharedInstance(int,unsigned int,unsigned short)::managers + 1);
LABEL_89:
        if ((v8 & (v8 - 1)) != 0)
        {
          if (v7 >= v8)
            v10 = v7 % v8;
          else
            v10 = v7;
        }
        else
        {
          v10 = (v8 - 1) & v7;
        }
        goto LABEL_102;
      }
      if (!prime)
      {
        v47 = (void *)QuantizerManager<float,768>::sharedInstance(int,unsigned int,unsigned short)::managers;
        *(_QWORD *)&QuantizerManager<float,768>::sharedInstance(int,unsigned int,unsigned short)::managers = 0;
        if (v47)
          operator delete(v47);
        v8 = 0;
        *((_QWORD *)&QuantizerManager<float,768>::sharedInstance(int,unsigned int,unsigned short)::managers + 1) = 0;
        goto LABEL_89;
      }
    }
    if (prime >> 61)
      std::__throw_bad_array_new_length[abi:nn180100]();
    v27 = operator new(8 * prime);
    v28 = (void *)QuantizerManager<float,768>::sharedInstance(int,unsigned int,unsigned short)::managers;
    *(_QWORD *)&QuantizerManager<float,768>::sharedInstance(int,unsigned int,unsigned short)::managers = v27;
    if (v28)
      operator delete(v28);
    v29 = 0;
    *((_QWORD *)&QuantizerManager<float,768>::sharedInstance(int,unsigned int,unsigned short)::managers + 1) = prime;
    do
      *(_QWORD *)(QuantizerManager<float,768>::sharedInstance(int,unsigned int,unsigned short)::managers + 8 * v29++) = 0;
    while (prime != v29);
    v30 = (_QWORD **)qword_1EF1B0780;
    if (!qword_1EF1B0780)
    {
LABEL_88:
      v8 = prime;
      goto LABEL_89;
    }
    v31 = *(_QWORD *)(qword_1EF1B0780 + 8);
    v32 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      v33 = v31 & v32;
      *(_QWORD *)(QuantizerManager<float,768>::sharedInstance(int,unsigned int,unsigned short)::managers + 8 * v33) = &qword_1EF1B0780;
      for (i = *v30; *v30; i = *v30)
      {
        v35 = i[1] & v32;
        if (v35 == v33)
        {
          v30 = (_QWORD **)i;
        }
        else if (*(_QWORD *)(QuantizerManager<float,768>::sharedInstance(int,unsigned int,unsigned short)::managers
                            + 8 * v35))
        {
          *v30 = (_QWORD *)*i;
          v36 = 8 * v35;
          *i = **(_QWORD **)(QuantizerManager<float,768>::sharedInstance(int,unsigned int,unsigned short)::managers + v36);
          **(_QWORD **)(QuantizerManager<float,768>::sharedInstance(int,unsigned int,unsigned short)::managers + v36) = i;
        }
        else
        {
          *(_QWORD *)(QuantizerManager<float,768>::sharedInstance(int,unsigned int,unsigned short)::managers + 8 * v35) = v30;
          v30 = (_QWORD **)i;
          v33 = v35;
        }
      }
      goto LABEL_88;
    }
    if (v31 >= prime)
      v31 %= prime;
    *(_QWORD *)(QuantizerManager<float,768>::sharedInstance(int,unsigned int,unsigned short)::managers + 8 * v31) = &qword_1EF1B0780;
    v40 = *v30;
    if (!*v30)
      goto LABEL_88;
    while (1)
    {
      v42 = v40[1];
      if (v42 >= prime)
        v42 %= prime;
      if (v42 != v31)
      {
        if (!*(_QWORD *)(QuantizerManager<float,768>::sharedInstance(int,unsigned int,unsigned short)::managers
                        + 8 * v42))
        {
          *(_QWORD *)(QuantizerManager<float,768>::sharedInstance(int,unsigned int,unsigned short)::managers + 8 * v42) = v30;
          goto LABEL_93;
        }
        *v30 = (_QWORD *)*v40;
        v41 = 8 * v42;
        *v40 = **(_QWORD **)(QuantizerManager<float,768>::sharedInstance(int,unsigned int,unsigned short)::managers + v41);
        **(_QWORD **)(QuantizerManager<float,768>::sharedInstance(int,unsigned int,unsigned short)::managers + v41) = v40;
        v40 = v30;
      }
      v42 = v31;
LABEL_93:
      v30 = (_QWORD **)v40;
      v40 = (_QWORD *)*v40;
      v31 = v42;
      if (!v40)
        goto LABEL_88;
    }
  }
LABEL_102:
  v43 = QuantizerManager<float,768>::sharedInstance(int,unsigned int,unsigned short)::managers;
  v44 = *(_QWORD **)(QuantizerManager<float,768>::sharedInstance(int,unsigned int,unsigned short)::managers + 8 * v10);
  if (v44)
  {
    *(_QWORD *)v12 = *v44;
LABEL_110:
    *v44 = v12;
    goto LABEL_111;
  }
  *(_QWORD *)v12 = qword_1EF1B0780;
  qword_1EF1B0780 = (uint64_t)v12;
  *(_QWORD *)(v43 + 8 * v10) = &qword_1EF1B0780;
  if (*(_QWORD *)v12)
  {
    v45 = *(_QWORD *)(*(_QWORD *)v12 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v45 >= v8)
        v45 %= v8;
    }
    else
    {
      v45 &= v8 - 1;
    }
    v44 = (_QWORD *)(QuantizerManager<float,768>::sharedInstance(int,unsigned int,unsigned short)::managers + 8 * v45);
    goto LABEL_110;
  }
LABEL_111:
  ++qword_1EF1B0788;
  return v12;
}

void std::__shared_ptr_pointer<QuantizerManager<float,768> *,std::shared_ptr<QuantizerManager<float,768>>::__shared_ptr_default_delete<QuantizerManager<float,768>,QuantizerManager<float,768>>,std::allocator<QuantizerManager<float,768>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BCCB06A4);
}

uint64_t std::__shared_ptr_pointer<QuantizerManager<float,768> *,std::shared_ptr<QuantizerManager<float,768>>::__shared_ptr_default_delete<QuantizerManager<float,768>,QuantizerManager<float,768>>,std::allocator<QuantizerManager<float,768>>>::__on_zero_shared(uint64_t result)
{
  uint64_t v1;
  int v2;
  NSObject *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  void *v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  _QWORD *v14;
  std::__shared_weak_count *v15;
  int v16;
  _QWORD *v17;
  __int16 v18;
  _QWORD *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = *(_QWORD *)(result + 24);
  if (v1)
  {
    v2 = *__error();
    v3 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4 = (_QWORD *)(v1 + 24);
      if (*(char *)(v1 + 47) < 0)
        v4 = (_QWORD *)*v4;
      v5 = (_QWORD *)(v1 + 48);
      if (*(char *)(v1 + 71) < 0)
        v5 = (_QWORD *)*v5;
      v16 = 136315394;
      v17 = v4;
      v18 = 2080;
      v19 = v5;
      _os_log_impl(&dword_1B8270000, v3, OS_LOG_TYPE_DEFAULT, "QuantizerManager %s/%s destroyed", (uint8_t *)&v16, 0x16u);
    }
    *__error() = v2;
    v6 = *(_QWORD **)(v1 + 128);
    if (v6)
    {
      do
      {
        v14 = (_QWORD *)*v6;
        v15 = (std::__shared_weak_count *)v6[4];
        if (v15)
          std::__shared_weak_count::__release_weak(v15);
        operator delete(v6);
        v6 = v14;
      }
      while (v14);
    }
    v7 = *(void **)(v1 + 112);
    *(_QWORD *)(v1 + 112) = 0;
    if (v7)
      operator delete(v7);
    v8 = *(std::__shared_weak_count **)(v1 + 104);
    if (v8)
    {
      p_shared_owners = (unint64_t *)&v8->__shared_owners_;
      do
        v10 = __ldaxr(p_shared_owners);
      while (__stlxr(v10 - 1, p_shared_owners));
      if (!v10)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }
    v11 = *(std::__shared_weak_count **)(v1 + 88);
    if (!v11)
      goto LABEL_20;
    v12 = (unint64_t *)&v11->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
      if ((*(char *)(v1 + 71) & 0x80000000) == 0)
      {
LABEL_21:
        if ((*(char *)(v1 + 47) & 0x80000000) == 0)
          goto LABEL_30;
        goto LABEL_29;
      }
    }
    else
    {
LABEL_20:
      if ((*(char *)(v1 + 71) & 0x80000000) == 0)
        goto LABEL_21;
    }
    operator delete(*(void **)(v1 + 48));
    if ((*(char *)(v1 + 47) & 0x80000000) == 0)
LABEL_30:
      JUMPOUT(0x1BCCB06A4);
LABEL_29:
    operator delete(*(void **)(v1 + 24));
    goto LABEL_30;
  }
  return result;
}

void std::__shared_ptr_emplace<IVFVectorIndexTemplate<float,768>::VectorStore<vi_onefixedsize_disk_allocator,vi_disk_postings>,std::allocator<IVFVectorIndexTemplate<float,768>::VectorStore<vi_onefixedsize_disk_allocator,vi_disk_postings>>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6E348A8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<IVFVectorIndexTemplate<float,768>::VectorStore<vi_onefixedsize_disk_allocator,vi_disk_postings>,std::allocator<IVFVectorIndexTemplate<float,768>::VectorStore<vi_onefixedsize_disk_allocator,vi_disk_postings>>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6E348A8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BCCB06A4);
}

void std::__shared_ptr_emplace<IVFVectorIndexTemplate<float,768>::VectorStore<vi_onefixedsize_disk_allocator,vi_disk_postings>,std::allocator<IVFVectorIndexTemplate<float,768>::VectorStore<vi_onefixedsize_disk_allocator,vi_disk_postings>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v2;
  const void *v3;

  if (*(char *)(a1 + 103) < 0)
    operator delete(*(void **)(a1 + 80));
  v2 = *(_QWORD *)(a1 + 56);
  *(_QWORD *)(a1 + 56) = 0;
  if (v2)
  {
    storage_array_Close(v2 + 8);
    v3 = *(const void **)(v2 + 4208);
    if (v3)
    {
      CFRelease(v3);
      *(_QWORD *)(v2 + 4208) = 0;
    }
    *(_OWORD *)(v2 + 4192) = 0u;
    JUMPOUT(0x1BCCB06A4);
  }
}

void IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::~IVFVectorIndexRoot_s(_QWORD *a1)
{
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::~IVFVectorIndexRoot_s(a1);
  JUMPOUT(0x1BCCB06A4);
}

void IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::getQuantizer(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  os_unfair_lock_s *v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;

  v4 = (os_unfair_lock_s *)(a1 + 112);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 112));
  v6 = *(_QWORD *)(a1 + 80);
  v5 = *(std::__shared_weak_count **)(a1 + 88);
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }
  v9 = *(std::__shared_weak_count **)(a1 + 104);
  if (v9)
  {
    v10 = (unint64_t *)&v9->__shared_owners_;
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }
  os_unfair_lock_unlock(v4);
  *a2 = v6;
  a2[1] = v5;
  if (v5)
  {
    v12 = (unint64_t *)&v5->__shared_owners_;
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  if (!v9)
    goto LABEL_14;
  v14 = (unint64_t *)&v9->__shared_owners_;
  do
    v15 = __ldaxr(v14);
  while (__stlxr(v15 - 1, v14));
  if (!v15)
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
    if (!v5)
      return;
  }
  else
  {
LABEL_14:
    if (!v5)
      return;
  }
  v16 = (unint64_t *)&v5->__shared_owners_;
  do
    v17 = __ldaxr(v16);
  while (__stlxr(v17 - 1, v16));
  if (!v17)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
}

void IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::getPartitions(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  os_unfair_lock_s *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;

  v4 = (os_unfair_lock_s *)(a1 + 112);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 112));
  v5 = *(std::__shared_weak_count **)(a1 + 88);
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  v9 = *(_QWORD *)(a1 + 96);
  v8 = *(std::__shared_weak_count **)(a1 + 104);
  if (!v8)
  {
    os_unfair_lock_unlock(v4);
    *a2 = v9;
    a2[1] = 0;
    if (!v5)
      return;
    goto LABEL_15;
  }
  v10 = (unint64_t *)&v8->__shared_owners_;
  do
    v11 = __ldxr(v10);
  while (__stxr(v11 + 1, v10));
  os_unfair_lock_unlock(v4);
  *a2 = v9;
  a2[1] = v8;
  do
    v12 = __ldxr(v10);
  while (__stxr(v12 + 1, v10));
  do
    v13 = __ldaxr(v10);
  while (__stlxr(v13 - 1, v10));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
  if (v5)
  {
LABEL_15:
    v14 = (unint64_t *)&v5->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
}

unint64_t IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::getVectorAtOffset(uint64_t a1, unsigned int a2)
{
  return _windowsResolvePtr(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 32) + 40, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 32) + 24)+ *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 32) + 16) * a2, 0xC10uLL);
}

void IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::newPartitions(uint64_t a1@<X0>, char **a2@<X1>, _QWORD *a3@<X8>)
{
  os_unfair_lock_s *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  const char *v14;
  __int128 v15;
  size_t v16;
  void *v17;
  void **v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _DWORD *v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  unint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  unint64_t v29;
  char *v30;
  unint64_t v31;
  int v32;
  int v33;
  NSObject *v34;
  void **v35;
  int v36;
  int v37;
  char *v38;
  _QWORD *v39;
  int v40;
  unint64_t *v41;
  unint64_t v42;
  unint64_t *v43;
  unint64_t v44;
  char *v45;
  char *v46;
  const char *v47;
  void *__p[2];
  char v49;
  _OWORD v50[2];
  void *__dst[2];
  unint64_t v52;
  _OWORD v53[2];
  __int128 v54;
  __int128 v55;
  uint8_t buf[24];
  __int16 v57;
  _QWORD *v58;
  __int16 v59;
  int v60;
  uint64_t v61;

  v61 = *MEMORY[0x1E0C80C00];
  v6 = (os_unfair_lock_s *)(a1 + 112);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 112));
  v7 = *(std::__shared_weak_count **)(a1 + 88);
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }
  v11 = *(_QWORD *)(a1 + 96);
  v10 = *(std::__shared_weak_count **)(a1 + 104);
  if (v10)
  {
    v12 = (unint64_t *)&v10->__shared_owners_;
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  os_unfair_lock_unlock(v6);
  v14 = ".partitions";
  if (v11 && (*(unsigned int (**)(uint64_t))(*(_QWORD *)v11 + 24))(v11))
    v14 = ".tmp.partitions";
  v55 = 0u;
  v15 = *(_OWORD *)(a1 + 24);
  v53[0] = *(_OWORD *)(a1 + 8);
  v53[1] = v15;
  v54 = 0u;
  v16 = strlen(v14);
  if (v16 >= 0x7FFFFFFFFFFFFFF8)
LABEL_60:
    abort();
  v17 = (void *)v16;
  if (v16 >= 0x17)
  {
    v19 = (v16 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v16 | 7) != 0x17)
      v19 = v16 | 7;
    v20 = v19 + 1;
    v18 = (void **)operator new(v19 + 1);
    __dst[1] = v17;
    v52 = v20 | 0x8000000000000000;
    __dst[0] = v18;
    goto LABEL_17;
  }
  HIBYTE(v52) = v16;
  v18 = __dst;
  if (v16)
LABEL_17:
    memcpy(v18, v14, (size_t)v17);
  *((_BYTE *)v17 + (_QWORD)v18) = 0;
  IVFVectorIndexTemplate<float,768>::childMetaInfo((uint64_t)&v54, (uint64_t)v53, (uint64_t)__dst, 1);
  if (SHIBYTE(v52) < 0)
    operator delete(__dst[0]);
  v21 = operator new();
  v22 = (_DWORD *)v21;
  v50[0] = v54;
  v50[1] = v55;
  v23 = (std::__shared_weak_count *)a2[1];
  *(_QWORD *)buf = *a2;
  *(_QWORD *)&buf[8] = v23;
  if (v23)
  {
    v24 = (unint64_t *)&v23->__shared_owners_;
    do
      v25 = __ldxr(v24);
    while (__stxr(v25 + 1, v24));
    PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionStore<vi_onefixedsize_disk_allocator>(v21, (uint64_t)v50, buf);
    do
      v26 = __ldaxr(v24);
    while (__stlxr(v26 - 1, v24));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
  else
  {
    PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionStore<vi_onefixedsize_disk_allocator>(v21, (uint64_t)v50, buf);
  }
  *a3 = v22;
  v27 = (_QWORD *)operator new();
  *v27 = &off_1E6E33858;
  v27[1] = 0;
  v27[2] = 0;
  v27[3] = v22;
  a3[1] = v27;
  v28 = *(_QWORD *)(a1 + 48);
  if (*(_DWORD *)(v28 + 40))
  {
    v29 = 0;
    do
    {
      memset(buf, 0, sizeof(buf));
      v30 = *a2;
      v31 = _windowsResolvePtr(*(_QWORD *)(v28 + 32) + 40, *(_QWORD *)(*(_QWORD *)(v28 + 32) + 24) + *(_QWORD *)(*(_QWORD *)(v28 + 32) + 16) * v29, 0xC10uLL);
      (*(void (**)(uint8_t *__return_ptr, char *, unint64_t, uint64_t))(*(_QWORD *)v30 + 72))(buf, v30, v31, 1);
      (*(void (**)(_DWORD *, _QWORD, unint64_t, float))(*(_QWORD *)v22 + 56))(v22, **(_DWORD **)buf, v29, *(float *)(*(_QWORD *)buf + 4));
      if (*(_QWORD *)buf)
      {
        *(_QWORD *)&buf[8] = *(_QWORD *)buf;
        operator delete(*(void **)buf);
      }
      ++v29;
      v28 = *(_QWORD *)(a1 + 48);
    }
    while (v29 < *(unsigned int *)(v28 + 40));
  }
  (*(void (**)(_DWORD *, _QWORD))(*(_QWORD *)v22 + 112))(v22, 0);
  v32 = *(_DWORD *)(*(_QWORD *)(a1 + 48) + 40);
  if (v32)
  {
    v33 = *__error();
    v34 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
    {
      (*(void (**)(void **__return_ptr, _DWORD *))(*(_QWORD *)v22 + 144))(__p, v22);
      if (v49 >= 0)
        v35 = __p;
      else
        v35 = (void **)__p[0];
      v36 = v22[17];
      v37 = v22[18];
      v38 = *a2;
      v39 = *a2 + 8;
      if (v38[31] < 0)
        v39 = (_QWORD *)*v39;
      v40 = (*(uint64_t (**)(char *))(*(_QWORD *)v38 + 16))(v38);
      *(_DWORD *)buf = 136316162;
      *(_QWORD *)&buf[4] = v35;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v37;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v36;
      v57 = 2080;
      v58 = v39;
      v59 = 1024;
      v60 = v40;
      _os_log_impl(&dword_1B8270000, v34, OS_LOG_TYPE_DEFAULT, "Create new partitions %s(%u/%u) for new quantizer %s(%u)", buf, 0x28u);
      if (v49 < 0)
        operator delete(__p[0]);
    }
    *__error() = v33;
    v32 = *(_DWORD *)(*(_QWORD *)(a1 + 48) + 40);
  }
  if (v22[18] != v32)
  {
    v45 = __si_assert_copy_extra_268();
    v46 = v45;
    v47 = "";
    if (v45)
      v47 = v45;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2363, "newPartitions->nVectors() == vectors->count()", v47);
    free(v46);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    goto LABEL_60;
  }
  if (v10)
  {
    v41 = (unint64_t *)&v10->__shared_owners_;
    do
      v42 = __ldaxr(v41);
    while (__stlxr(v42 - 1, v41));
    if (!v42)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  if (v7)
  {
    v43 = (unint64_t *)&v7->__shared_owners_;
    do
      v44 = __ldaxr(v43);
    while (__stlxr(v44 - 1, v43));
    if (!v44)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
}

void IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::replaceQuantizer(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  os_unfair_lock_s *v6;
  os_unfair_lock_s *v7;
  std::__shared_weak_count *v8;
  __int128 *v9;
  char *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  std::__shared_weak_count *v13;
  _DWORD *v14;
  unint64_t *v15;
  unint64_t v16;
  int v17;
  _DWORD *v18;
  NSObject *v19;
  _QWORD *v20;
  int v21;
  _QWORD *v22;
  void **v23;
  int v24;
  void **v25;
  int v26;
  int v27;
  BOOL v28;
  uint64_t v29;
  unint64_t *v30;
  unint64_t v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  unint64_t v37;
  std::__shared_weak_count *v38;
  unint64_t *v39;
  unint64_t v40;
  unint64_t *v41;
  unint64_t v42;
  unint64_t *v43;
  unint64_t v44;
  char *v45;
  char *v46;
  const char *v47;
  char *v48;
  const char *v49;
  _QWORD *v50;
  _QWORD *v51;
  int v52;
  int v53;
  int v54;
  os_unfair_lock_s *v55;
  int v56;
  __int128 v57;
  uint64_t v58;
  std::__shared_weak_count *v59;
  void *__p[2];
  char v61;
  void *v62[2];
  char v63;
  uint8_t buf[4];
  _QWORD *v65;
  __int16 v66;
  int v67;
  __int16 v68;
  _QWORD *v69;
  __int16 v70;
  int v71;
  __int16 v72;
  void **v73;
  __int16 v74;
  int v75;
  __int16 v76;
  int v77;
  __int16 v78;
  void **v79;
  __int16 v80;
  int v81;
  __int16 v82;
  int v83;
  uint64_t v84;

  v84 = *MEMORY[0x1E0C80C00];
  v6 = (os_unfair_lock_s *)(a1 + 152);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 152));
  v7 = (os_unfair_lock_s *)(a1 + 112);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 112));
  v10 = *(char **)(a1 + 80);
  v8 = *(std::__shared_weak_count **)(a1 + 88);
  v9 = (__int128 *)(a1 + 80);
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }
  v14 = *(_DWORD **)(a1 + 96);
  v13 = *(std::__shared_weak_count **)(a1 + 104);
  if (v13)
  {
    v15 = (unint64_t *)&v13->__shared_owners_;
    do
      v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 112));
  v17 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a2 + 24))(*a2);
  v18 = (_DWORD *)*a3;
  if (v17 != *(_DWORD *)(*a3 + 68))
  {
    v45 = __si_assert_copy_extra_268();
    v46 = v45;
    v47 = "";
    if (v45)
      v47 = v45;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2381, "newQuantizer->count() == newPartitions->nPartitions()", v47);
LABEL_64:
    free(v46);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  if (*(_DWORD *)(*(_QWORD *)(a1 + 48) + 40) != v18[18])
  {
    v48 = __si_assert_copy_extra_268();
    v46 = v48;
    v49 = "";
    if (v48)
      v49 = v48;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2382, "vectors->count() == newPartitions->nVectors()", v49);
    goto LABEL_64;
  }
  if (v10 && v14)
  {
    v56 = *__error();
    v19 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      v20 = v10 + 8;
      if (v10[31] < 0)
        v20 = (_QWORD *)*v20;
      v51 = v20;
      v21 = (*(uint64_t (**)(char *))(*(_QWORD *)v10 + 16))(v10);
      v22 = (_QWORD *)(*a2 + 8);
      v55 = v6;
      v54 = v21;
      if (*(char *)(*a2 + 31) < 0)
        v22 = (_QWORD *)*v22;
      v50 = v22;
      v53 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a2 + 16))(*a2);
      v23 = v62;
      (*(void (**)(void **__return_ptr, _DWORD *))(*(_QWORD *)v14 + 144))(v62, v14);
      if (v63 < 0)
        v23 = (void **)v62[0];
      v24 = v14[18];
      v52 = v14[17];
      (*(void (**)(void **__return_ptr))(*(_QWORD *)*a3 + 144))(__p);
      v25 = __p;
      if (v61 < 0)
        v25 = (void **)__p[0];
      v26 = *(_DWORD *)(*a3 + 68);
      v27 = *(_DWORD *)(*a3 + 72);
      *(_DWORD *)buf = 136317442;
      v65 = v51;
      v66 = 1024;
      v67 = v54;
      v68 = 2080;
      v69 = v50;
      v70 = 1024;
      v71 = v53;
      v72 = 2080;
      v73 = v23;
      v74 = 1024;
      v75 = v24;
      v76 = 1024;
      v77 = v52;
      v78 = 2080;
      v79 = v25;
      v80 = 1024;
      v81 = v27;
      v82 = 1024;
      v83 = v26;
      _os_log_impl(&dword_1B8270000, v19, OS_LOG_TYPE_DEFAULT, "Replace quantizer %s(%u) -> %s(%u), partitions %s(%u/%u) -> %s(%u/%u)", buf, 0x4Eu);
      if (v61 < 0)
        operator delete(__p[0]);
      v6 = v55;
      if (v63 < 0)
        operator delete(v62[0]);
    }
    *__error() = v56;
    v18 = (_DWORD *)*a3;
  }
  if ((*(unsigned int (**)(_DWORD *))(*(_QWORD *)v18 + 24))(v18))
    v28 = v14 == 0;
  else
    v28 = 1;
  if (!v28 && (*(unsigned int (**)(_DWORD *))(*(_QWORD *)v14 + 24))(v14))
    (*(void (**)(_QWORD, _DWORD *))(*(_QWORD *)*a3 + 168))(*a3, v14);
  v29 = a2[1];
  *(_QWORD *)&v57 = *a2;
  *((_QWORD *)&v57 + 1) = v29;
  if (v29)
  {
    v30 = (unint64_t *)(v29 + 8);
    do
      v31 = __ldxr(v30);
    while (__stxr(v31 + 1, v30));
  }
  v32 = (std::__shared_weak_count *)a3[1];
  v58 = *a3;
  v59 = v32;
  if (v32)
  {
    v33 = (unint64_t *)&v32->__shared_owners_;
    do
      v34 = __ldxr(v33);
    while (__stxr(v34 + 1, v33));
  }
  os_unfair_lock_lock(v7);
  std::swap[abi:nn180100]<IVFVectorIndexTemplate<float,768>::QuantizerPartitions>(v9, &v57);
  os_unfair_lock_unlock(v7);
  v35 = v59;
  if (v59)
  {
    v36 = (unint64_t *)&v59->__shared_owners_;
    do
      v37 = __ldaxr(v36);
    while (__stlxr(v37 - 1, v36));
    if (!v37)
    {
      ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
      std::__shared_weak_count::__release_weak(v35);
    }
  }
  v38 = (std::__shared_weak_count *)*((_QWORD *)&v57 + 1);
  if (*((_QWORD *)&v57 + 1))
  {
    v39 = (unint64_t *)(*((_QWORD *)&v57 + 1) + 8);
    do
      v40 = __ldaxr(v39);
    while (__stlxr(v40 - 1, v39));
    if (!v40)
    {
      ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
      std::__shared_weak_count::__release_weak(v38);
    }
  }
  os_unfair_lock_unlock(v6);
  if (v13)
  {
    v41 = (unint64_t *)&v13->__shared_owners_;
    do
      v42 = __ldaxr(v41);
    while (__stlxr(v42 - 1, v41));
    if (!v42)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  if (v8)
  {
    v43 = (unint64_t *)&v8->__shared_owners_;
    do
      v44 = __ldaxr(v43);
    while (__stlxr(v44 - 1, v43));
    if (!v44)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
}

uint64_t PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionStore<vi_onefixedsize_disk_allocator>(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  _QWORD *v6;
  uint64_t v7;
  char *v8;
  size_t v9;
  std::string::size_type v10;
  std::string *p_dst;
  uint64_t v12;
  uint64_t v13;
  std::string *v14;
  std::string::size_type v15;
  std::string *v16;
  std::string::size_type size;
  std::string *v18;
  std::string::size_type v19;
  std::string *v20;
  std::string::size_type v21;
  char v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  int v30;
  int v31;
  int v32;
  char v33;
  uint64_t v34;
  const void *v35;
  unint64_t v36;
  const char *v37;
  uint64_t v38;
  char *v40;
  char *v41;
  const char *v42;
  char *v43;
  const char *v44;
  std::string v45;
  std::string __dst;
  std::string v47;
  std::string v48;
  void *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  int v53;
  char v54;
  char v55;
  char v56;
  char v57;
  uint64_t v58;
  _QWORD v59[2];
  char v60[1024];
  uint64_t v61;

  v61 = *MEMORY[0x1E0C80C00];
  v6 = (_QWORD *)AnyPartitionStore::AnyPartitionStore(a1, a3);
  *v6 = off_1E6E336F0;
  v6[10] = 0;
  *(_DWORD *)(a1 + 88) = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a3 + 24))(*a3);
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_QWORD *)(a1 + 160) = 0;
  v7 = *(_QWORD *)a2;
  if (!*(_QWORD *)a2)
  {
    v43 = __si_assert_copy_extra_268();
    v41 = v43;
    v44 = "";
    if (v43)
      v44 = v43;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1137, "meta.fdPtr != nullptr", v44);
    goto LABEL_45;
  }
  bzero(v60, 0x400uLL);
  v8 = fd_name(v7, v60, 0x400uLL);
  v9 = strlen(v8);
  if (v9 >= 0x7FFFFFFFFFFFFFF8)
    goto LABEL_48;
  v10 = v9;
  if (v9 >= 0x17)
  {
    v12 = (v9 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v9 | 7) != 0x17)
      v12 = v9 | 7;
    v13 = v12 + 1;
    p_dst = (std::string *)operator new(v12 + 1);
    __dst.__r_.__value_.__l.__size_ = v10;
    __dst.__r_.__value_.__r.__words[2] = v13 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    goto LABEL_9;
  }
  *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v9;
  p_dst = &__dst;
  if (v9)
LABEL_9:
    memmove(p_dst, v8, v10);
  p_dst->__r_.__value_.__s.__data_[v10] = 0;
  v14 = std::string::append(&__dst, "(");
  v15 = v14->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v47.__r_.__value_.__l.__data_ = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
  v47.__r_.__value_.__r.__words[2] = v15;
  v14->__r_.__value_.__l.__size_ = 0;
  v14->__r_.__value_.__r.__words[2] = 0;
  v14->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&v45, *(_DWORD *)(a1 + 76));
  if ((v45.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v16 = &v45;
  else
    v16 = (std::string *)v45.__r_.__value_.__r.__words[0];
  if ((v45.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(v45.__r_.__value_.__r.__words[2]);
  else
    size = v45.__r_.__value_.__l.__size_;
  v18 = std::string::append(&v47, (const std::string::value_type *)v16, size);
  v19 = v18->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v48.__r_.__value_.__l.__data_ = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
  v48.__r_.__value_.__r.__words[2] = v19;
  v18->__r_.__value_.__l.__size_ = 0;
  v18->__r_.__value_.__r.__words[2] = 0;
  v18->__r_.__value_.__r.__words[0] = 0;
  v20 = std::string::append(&v48, ")");
  v21 = v20->__r_.__value_.__r.__words[0];
  v59[0] = v20->__r_.__value_.__l.__size_;
  *(_QWORD *)((char *)v59 + 7) = *(std::string::size_type *)((char *)&v20->__r_.__value_.__r.__words[1] + 7);
  v22 = HIBYTE(v20->__r_.__value_.__r.__words[2]);
  v20->__r_.__value_.__l.__size_ = 0;
  v20->__r_.__value_.__r.__words[2] = 0;
  v20->__r_.__value_.__r.__words[0] = 0;
  if (*(char *)(a1 + 143) < 0)
    operator delete(*(void **)(a1 + 120));
  v23 = v59[0];
  *(_QWORD *)(a1 + 120) = v21;
  *(_QWORD *)(a1 + 128) = v23;
  *(_QWORD *)(a1 + 135) = *(_QWORD *)((char *)v59 + 7);
  *(_BYTE *)(a1 + 143) = v22;
  if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v48.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v45.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_20:
      if ((SHIBYTE(v47.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        goto LABEL_21;
      goto LABEL_37;
    }
  }
  else if ((SHIBYTE(v45.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_20;
  }
  operator delete(v45.__r_.__value_.__l.__data_);
  if ((SHIBYTE(v47.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_21:
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_22;
    goto LABEL_38;
  }
LABEL_37:
  operator delete(v47.__r_.__value_.__l.__data_);
  if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_22:
    if (*(_BYTE *)(a2 + 21))
      goto LABEL_23;
    goto LABEL_39;
  }
LABEL_38:
  operator delete(__dst.__r_.__value_.__l.__data_);
  if (!*(_BYTE *)(a2 + 21))
  {
LABEL_39:
    v40 = __si_assert_copy_extra_268();
    v41 = v40;
    v42 = "";
    if (v40)
      v42 = v40;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1139, "meta.newFile", v42);
LABEL_45:
    free(v41);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
LABEL_48:
    abort();
  }
LABEL_23:
  v24 = 4 * *(unsigned int *)(a1 + 88);
  v25 = 4108 * (*(unsigned int (**)(_QWORD))(*(_QWORD *)*a3 + 24))(*a3);
  v26 = operator new();
  v27 = *(_QWORD *)a2;
  v28 = *(_QWORD *)(a2 + 8);
  v29 = *(_DWORD *)(a2 + 16);
  v30 = *(unsigned __int8 *)(a2 + 20);
  v31 = *(unsigned __int8 *)(a2 + 21);
  v32 = *(unsigned __int8 *)(a2 + 22);
  *(_QWORD *)v26 = 0;
  v33 = *(_BYTE *)(a2 + 23);
  v48.__r_.__value_.__r.__words[0] = MEMORY[0x1E0C809B0];
  v48.__r_.__value_.__l.__size_ = 0x40000000;
  v48.__r_.__value_.__r.__words[2] = (std::string::size_type)___ZN30vi_onefixedsize_disk_allocatorC2EmymN19vi_ondisk_allocator11meta_info_sEP16vector_storage_s_block_invoke;
  v49 = &__block_descriptor_tmp_80;
  v50 = v26;
  v51 = v27;
  v52 = v28;
  v53 = v29;
  v54 = v30;
  v55 = v31;
  v56 = v32;
  v57 = v33;
  v58 = *(_QWORD *)(a2 + 24);
  storage_array_Init((_DWORD *)(v26 + 8), v24 + 1148, v25, 4108, v27, v31 != 0, v29, v30 != 0, v32 != 0, v58, 0, (uint64_t)&v48);
  if (v31)
    vi_onefixedsize_disk_allocator::storeHeader((unint64_t *)v26);
  v34 = *(_QWORD *)(a1 + 80);
  *(_QWORD *)(a1 + 80) = v26;
  if (v34)
  {
    storage_array_Close(v34 + 8);
    v35 = *(const void **)(v34 + 4208);
    if (v35)
    {
      CFRelease(v35);
      *(_QWORD *)(v34 + 4208) = 0;
    }
    *(_OWORD *)(v34 + 4192) = 0u;
    MEMORY[0x1BCCB06A4](v34, 0x10A0C408BE2A288);
    v26 = *(_QWORD *)(a1 + 80);
  }
  v36 = _windowsResolvePtr(v26 + 40, 0x400uLL, *(_QWORD *)(v26 + 16));
  *(_DWORD *)v36 = *(_DWORD *)(a1 + 76);
  *(_DWORD *)(v36 + 4) = *(_DWORD *)(a1 + 88);
  v37 = (const char *)(*a3 + 8);
  if (*(char *)(*a3 + 31) < 0)
    v37 = *(const char **)v37;
  strncpy((char *)(v36 + 16), v37, 0x6BuLL);
  *(_DWORD *)(v36 + 12) = 0;
  if ((*(unsigned int (**)(_QWORD))(*(_QWORD *)*a3 + 24))(*a3))
  {
    v38 = 0;
    do
    {
      (**(void (***)(uint64_t, uint64_t))a1)(a1, v38);
      v38 = (v38 + 1);
    }
    while (v38 < (*(unsigned int (**)(_QWORD))(*(_QWORD *)*a3 + 24))(*a3));
  }
  return a1;
}

void std::__shared_ptr_pointer<PartitionStore<vi_onefixedsize_disk_allocator,512> *,std::shared_ptr<AnyPartitionStore>::__shared_ptr_default_delete<AnyPartitionStore,PartitionStore<vi_onefixedsize_disk_allocator,512>>,std::allocator<PartitionStore<vi_onefixedsize_disk_allocator,512>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BCCB06A4);
}

uint64_t std::__shared_ptr_pointer<PartitionStore<vi_onefixedsize_disk_allocator,512> *,std::shared_ptr<AnyPartitionStore>::__shared_ptr_default_delete<AnyPartitionStore,PartitionStore<vi_onefixedsize_disk_allocator,512>>,std::allocator<PartitionStore<vi_onefixedsize_disk_allocator,512>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 16))(result);
  return result;
}

_QWORD *IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::~IVFVectorIndexRoot_s(_QWORD *a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;

  *a1 = &off_1E6E34860;
  v2 = (std::__shared_weak_count *)a1[13];
  if (!v2)
    goto LABEL_5;
  p_shared_owners = (unint64_t *)&v2->__shared_owners_;
  do
    v4 = __ldaxr(p_shared_owners);
  while (__stlxr(v4 - 1, p_shared_owners));
  if (!v4)
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    v5 = (std::__shared_weak_count *)a1[11];
    if (!v5)
      goto LABEL_11;
  }
  else
  {
LABEL_5:
    v5 = (std::__shared_weak_count *)a1[11];
    if (!v5)
      goto LABEL_11;
  }
  v6 = (unint64_t *)&v5->__shared_owners_;
  do
    v7 = __ldaxr(v6);
  while (__stlxr(v7 - 1, v6));
  if (!v7)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
LABEL_11:
  v8 = (std::__shared_weak_count *)a1[9];
  if (!v8)
    goto LABEL_15;
  v9 = (unint64_t *)&v8->__shared_owners_;
  do
    v10 = __ldaxr(v9);
  while (__stlxr(v10 - 1, v9));
  if (!v10)
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
    v11 = (std::__shared_weak_count *)a1[7];
    if (!v11)
      return a1;
  }
  else
  {
LABEL_15:
    v11 = (std::__shared_weak_count *)a1[7];
    if (!v11)
      return a1;
  }
  v12 = (unint64_t *)&v11->__shared_owners_;
  do
    v13 = __ldaxr(v12);
  while (__stlxr(v13 - 1, v12));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  return a1;
}

uint64_t IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::~IVFVectorIndexInstance(uint64_t a1)
{
  *(_QWORD *)a1 = off_1E6E34708;
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::~IVFVectorIndexRoot_s((_QWORD *)(a1 + 48));
  *(_QWORD *)a1 = off_1E6E30C80;
  if (*(char *)(a1 + 47) < 0)
    operator delete(*(void **)(a1 + 24));
  return a1;
}

void IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::~IVFVectorIndexInstance(uint64_t a1)
{
  *(_QWORD *)a1 = off_1E6E34708;
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::~IVFVectorIndexRoot_s((_QWORD *)(a1 + 48));
  *(_QWORD *)a1 = off_1E6E30C80;
  if (*(char *)(a1 + 47) < 0)
    operator delete(*(void **)(a1 + 24));
  JUMPOUT(0x1BCCB06A4);
}

uint64_t IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::nVectors(uint64_t a1)
{
  return IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nVectors(a1 + 48);
}

uint64_t IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::nPartitions(uint64_t a1)
{
  return IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nPartitions(a1 + 48);
}

uint64_t IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::allExist(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  float v9;
  uint64_t v10;
  int v11;
  NSObject *v12;
  char *v14;
  char *v15;
  const char *v16;
  uint8_t buf[4];
  double v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if ((_DWORD)a3)
  {
    v5 = a1 + 48;
    v6 = a3;
    if (a3 <= 0x3E8)
    {
      while (IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::exists(v5, a2))
      {
        a2 += 3072;
        if (!--v6)
          return a3;
      }
    }
    else
    {
      v7 = 0;
      v8 = a3 / 0xA;
      v9 = 1.0 / (float)a3;
      while (1)
      {
        v10 = v7 + 1;
        if (!(((int)v7 + 1) % v8))
        {
          v11 = *__error();
          v12 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 134217984;
            v18 = (float)((float)((float)v7 * 100.0) * v9);
            _os_log_impl(&dword_1B8270000, v12, OS_LOG_TYPE_DEFAULT, "allExist: %.0f%%", buf, 0xCu);
          }
          *__error() = v11;
        }
        if (!IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::exists(v5, a2))break;
        a2 += 3072;
        ++v7;
        if (a3 == v10)
          return a3;
      }
    }
    v14 = __si_assert_copy_extra_268();
    v15 = v14;
    v16 = "";
    if (v14)
      v16 = v14;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3151, "false", v16);
    free(v15);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  return a3;
}

BOOL IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::validAddress(uint64_t a1, unint64_t a2)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 96) + 32);
  v3 = *(unsigned int *)(v2 + 64);
  if ((int)v3 < 1)
  {
    v8 = -1;
  }
  else
  {
    v4 = 11;
    do
    {
      v5 = *(_QWORD **)(v2 + 8 * v4);
      if (v5 && (v6 = v5[1], v6 + 1 >= 2) && v6 <= a2 && (v7 = v5[2], v6 - v7 + v5[3] > a2))
        v8 = a2 - v6 + v7;
      else
        v8 = -1;
      if (v4 - 10 >= v3)
        break;
      ++v4;
    }
    while (v8 == -1);
  }
  return v8 != -1;
}

uint64_t IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::shadow(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  os_unfair_lock_s *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t *v17;
  unint64_t v18;

  v6 = (os_unfair_lock_s *)(a1 + 160);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 160));
  v7 = *(std::__shared_weak_count **)(a1 + 136);
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }
  v11 = *(_QWORD *)(a1 + 144);
  v10 = *(std::__shared_weak_count **)(a1 + 152);
  if (v10)
  {
    v12 = (unint64_t *)&v10->__shared_owners_;
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  os_unfair_lock_unlock(v6);
  (*(void (**)(uint64_t, uint64_t, _DWORD *))(*(_QWORD *)v11 + 160))(v11, a2, a3);
  v14 = vi_onefixedsize_disk_allocator::shadow(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 32), a2, a3);
  if (!v10)
    goto LABEL_11;
  v15 = (unint64_t *)&v10->__shared_owners_;
  do
    v16 = __ldaxr(v15);
  while (__stlxr(v16 - 1, v15));
  if (!v16)
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
    if (!v7)
      return v14;
  }
  else
  {
LABEL_11:
    if (!v7)
      return v14;
  }
  v17 = (unint64_t *)&v7->__shared_owners_;
  do
    v18 = __ldaxr(v17);
  while (__stlxr(v18 - 1, v17));
  if (!v18)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  return v14;
}

_DWORD *IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::bulkInsertForTest(_DWORD *result, char *a2, unsigned int *a3, unsigned int a4, unsigned int *a5)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  float v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  NSObject *v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  uint8_t buf[4];
  double v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (a4)
  {
    v8 = (uint64_t)(result + 12);
    v9 = a4;
    if (a4 <= 0x3E8)
    {
      do
      {
        v19 = *a5++;
        v18 = v19;
        v20 = *a3++;
        result = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::lookupForInsert(v8, v18, a2, 0xFFFFFFFFLL, 0, 3.4028e38);
        *((_QWORD *)result + 384) = v20;
        a2 += 3072;
        --v9;
      }
      while (v9);
    }
    else
    {
      v10 = 0;
      v11 = a4 / 0xA;
      v12 = 1.0 / (float)a4;
      do
      {
        v15 = v10 + 1;
        if (!(((int)v10 + 1) % v11))
        {
          v16 = *__error();
          v17 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 134217984;
            v22 = (float)((float)((float)v10 * 100.0) * v12);
            _os_log_impl(&dword_1B8270000, v17, OS_LOG_TYPE_DEFAULT, "bulkInsertForTest: %.0f%%", buf, 0xCu);
          }
          *__error() = v16;
        }
        v13 = a5[v10];
        v14 = a3[v10];
        result = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::lookupForInsert(v8, v13, a2, 0xFFFFFFFFLL, 0, 3.4028e38);
        *((_QWORD *)result + 384) = v14;
        a2 += 3072;
        v10 = v15;
      }
      while (v9 != v15);
    }
  }
  return result;
}

void IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::insertVector(_DWORD *a1, int a2, unsigned int a3, void *a4, int a5, int a6)
{
  char *v6;
  char *v7;
  const char *v8;
  char *v9;
  const char *v10;

  if (a1[2] == a2
    && a6 <= 2
    && a1[3] == vector_dimension_vec_sizes_10743[a5]
    && vector_size_elem_sizes_10742[a6] == a1[4])
  {
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::lookupForInsert((uint64_t)(a1 + 12), a3, a4, 0xFFFFFFFFLL, 0, 3.4028e38);
    v6 = __si_assert_copy_extra_268();
    v7 = v6;
    v8 = "";
    if (v6)
      v8 = v6;
    __message_assert("%s:%u: failed assertion '%s' %s ", "VectorIndexSupport.hh", 2636, "0", v8);
  }
  else
  {
    v9 = __si_assert_copy_extra_268();
    v7 = v9;
    v10 = "";
    if (v9)
      v10 = v9;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3070, "compatible", v10);
  }
  free(v7);
  if (__valid_fs(-1))
  {
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  MEMORY[0xC00] = -559038737;
  abort();
}

uint64_t IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::insertForMerge(uint64_t a1, int a2, int a3, unsigned int a4, void *a5, int a6, int a7, uint64_t a8, float a9, unsigned int a10)
{
  char *v11;
  char *v12;
  const char *v13;

  if (*(_DWORD *)(a1 + 8) != a2
    || *(unsigned __int16 *)(a1 + 20) != a3
    || a7 > 2
    || *(_DWORD *)(a1 + 12) != vector_dimension_vec_sizes_10743[a6]
    || vector_size_elem_sizes_10742[a7] != *(_DWORD *)(a1 + 16))
  {
    v11 = __si_assert_copy_extra_268();
    v12 = v11;
    v13 = "";
    if (v11)
      v13 = v11;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3070, "compatible", v13);
    free(v12);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::insertForCompact(a1 + 48, a4, a5, a8, a10, a9);
  return 1;
}

_DWORD *IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::insertForTest(_DWORD *a1, int a2, unsigned int a3, void *a4, int a5, int a6, unsigned int a7)
{
  uint64_t v7;
  _DWORD *result;
  char *v9;
  char *v10;
  const char *v11;

  if (a1[2] != a2
    || a6 > 2
    || a1[3] != vector_dimension_vec_sizes_10743[a5]
    || vector_size_elem_sizes_10742[a6] != a1[4])
  {
    v9 = __si_assert_copy_extra_268();
    v10 = v9;
    v11 = "";
    if (v9)
      v11 = v9;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3070, "compatible", v11);
    free(v10);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v7 = a7;
  result = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::lookupForInsert((uint64_t)(a1 + 12), a3, a4, 0xFFFFFFFFLL, 0, 3.4028e38);
  *((_QWORD *)result + 384) = v7;
  return result;
}

void IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::train(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v3;
  unint64_t v4;
  char *v7;
  char *v8;
  unint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  int64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  _BYTE *v19;
  _QWORD *v20;
  char *v21;
  unint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  _OWORD *v26;
  char *v27;
  uint64_t v28;
  __int128 v29;
  char *v30;
  char *v31;
  const char *v32;
  char *v33;
  char *v34;
  const char *v35;
  char *v36;
  const char *v37;
  uint64_t v38;
  void *__p;
  _QWORD *v40;
  char *v41;

  v3 = *(_QWORD **)a2;
  v2 = *(_QWORD *)(a2 + 8);
  v4 = v2 - *(_QWORD *)a2;
  if (v2 == *(_QWORD *)a2)
  {
    v33 = __si_assert_copy_extra_268();
    v34 = v33;
    v35 = "";
    if (v33)
      v35 = v33;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3170, "vi.size() > 0", v35);
    goto LABEL_53;
  }
  if (*v3 != a1)
  {
    v36 = __si_assert_copy_extra_268();
    v34 = v36;
    v37 = "";
    if (v36)
      v37 = v36;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3171, "this == vi[0]", v37);
LABEL_53:
    free(v34);
    if (__valid_fs(-1))
      v38 = 2989;
    else
      v38 = 3072;
    *(_DWORD *)v38 = -559038737;
LABEL_57:
    abort();
  }
  v7 = (char *)operator new(8uLL);
  *(_QWORD *)v7 = a1 + 48;
  v8 = v7 + 8;
  v40 = v7 + 8;
  v41 = v7 + 8;
  __p = v7;
  if (v4 < 9)
    goto LABEL_39;
  v9 = 1;
  do
  {
    v11 = v3[v9];
    if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(v11 + 8)
      || *(unsigned __int16 *)(a1 + 20) != *(unsigned __int16 *)(v11 + 20)
      || *(_DWORD *)(a1 + 12) != *(_DWORD *)(v11 + 12)
      || *(_DWORD *)(a1 + 16) != *(_DWORD *)(v11 + 16))
    {
      v30 = __si_assert_copy_extra_268();
      v31 = v30;
      v32 = "";
      if (v30)
        v32 = v30;
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3075, "compatible", v32);
      free(v31);
      if (__valid_fs(-1))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
    v12 = v11 + 48;
    if (v8 < v41)
    {
      *(_QWORD *)v8 = v12;
      v10 = v8 + 8;
      goto LABEL_6;
    }
    v13 = (char *)__p;
    v14 = v8 - (_BYTE *)__p;
    v15 = (v8 - (_BYTE *)__p) >> 3;
    v16 = v15 + 1;
    if ((unint64_t)(v15 + 1) >> 61)
      goto LABEL_57;
    v17 = v41 - (_BYTE *)__p;
    if ((v41 - (_BYTE *)__p) >> 2 > v16)
      v16 = v17 >> 2;
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8)
      v18 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v18 = v16;
    if (v18)
    {
      if (v18 >> 61)
        std::__throw_bad_array_new_length[abi:nn180100]();
      v19 = operator new(8 * v18);
    }
    else
    {
      v19 = 0;
    }
    v20 = &v19[8 * v15];
    v21 = &v19[8 * v18];
    *v20 = v12;
    v10 = v20 + 1;
    if (v8 == v13)
    {
      __p = &v19[8 * v15];
      v41 = v21;
LABEL_33:
      operator delete(v8);
      goto LABEL_6;
    }
    v22 = v8 - 8 - v13;
    if (v22 > 0x167
      && &v19[v14 - 8 - (v22 & 0xFFFFFFFFFFFFFFF8)] <= &v19[v14 - 8]
      && &v8[-(v22 & 0xFFFFFFFFFFFFFFF8) - 8] <= v8 - 8
      && (unint64_t)(v8 - v19 - v14) >= 0x20)
    {
      v25 = (v22 >> 3) + 1;
      v23 = &v8[-8 * (v25 & 0x3FFFFFFFFFFFFFFCLL)];
      v26 = &v19[8 * v15 - 16];
      v27 = v8 - 16;
      v28 = v25 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v20 -= v25 & 0x3FFFFFFFFFFFFFFCLL;
      if (v25 == (v25 & 0x3FFFFFFFFFFFFFFCLL))
        goto LABEL_30;
    }
    else
    {
      v23 = v8;
    }
    do
    {
      v24 = *((_QWORD *)v23 - 1);
      v23 -= 8;
      *--v20 = v24;
    }
    while (v23 != v13);
    v13 = (char *)__p;
LABEL_30:
    __p = v20;
    v41 = v21;
    v8 = v13;
    if (v13)
      goto LABEL_33;
LABEL_6:
    v40 = v10;
    ++v9;
    v3 = *(_QWORD **)a2;
    v8 = (char *)v10;
  }
  while (v9 < (uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 3);
  v7 = (char *)__p;
LABEL_39:
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::train<vi_onefixedsize_disk_allocator>(*(_QWORD *)(a1 + 112), *(std::__shared_weak_count **)(a1 + 120), (uint64_t)&__p);
  if (v7)
    operator delete(v7);
}

uint64_t IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::mergeUpdateSet(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v7;
  NSObject *v8;
  os_log_type_t v9;
  int v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  float v18;
  unsigned int v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  _QWORD *v24;
  _DWORD *v25;
  uint64_t v26;
  uint64_t result;
  std::__shared_weak_count *v28;
  unint64_t *p_shared_owners;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  char *v34;
  char *v35;
  const char *v36;
  char *v37;
  const char *v38;
  _DWORD v39[4];
  void *__src;
  uint64_t v41;
  uint8_t buf[3072];
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)
    || *(unsigned __int16 *)(a1 + 20) != *(unsigned __int16 *)(a2 + 20)
    || *(_DWORD *)(a1 + 12) != *(_DWORD *)(a2 + 12)
    || *(_DWORD *)(a1 + 16) != *(_DWORD *)(a2 + 16))
  {
    v37 = __si_assert_copy_extra_268();
    v35 = v37;
    v38 = "";
    if (v37)
      v38 = v37;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3075, "compatible", v38);
LABEL_38:
    free(v35);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v7 = *__error();
  v8 = _SILogForLogForCategory(16);
  v9 = 2 * (dword_1EF19FCCC < 4);
  if (os_log_type_enabled(v8, v9))
  {
    v10 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
    v11 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
    v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
    v13 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 24))(a2);
    *(_DWORD *)buf = 67109888;
    *(_DWORD *)&buf[4] = v10;
    *(_WORD *)&buf[8] = 1024;
    *(_DWORD *)&buf[10] = v11;
    *(_WORD *)&buf[14] = 1024;
    *(_DWORD *)&buf[16] = v12;
    *(_WORD *)&buf[20] = 1024;
    *(_DWORD *)&buf[22] = v13;
    _os_log_impl(&dword_1B8270000, v8, v9, "mergeUpdateSet(termIds) %u vectors in %u partitions and %u vectors in %u partitions", buf, 0x1Au);
  }
  *__error() = v7;
  v14 = a2 + 48;
  v15 = operator new(0x10uLL);
  *(_QWORD *)&buf[8] = v15 + 2;
  *(_QWORD *)&buf[16] = v15 + 2;
  *v15 = a1 + 48;
  v15[1] = v14;
  *(_QWORD *)buf = v15;
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::train<vi_onefixedsize_disk_allocator>(*(_QWORD *)(a1 + 112), *(std::__shared_weak_count **)(a1 + 120), (uint64_t)buf);
  operator delete(v15);
  v16 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::enumerator(v14);
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::beginMerge(a1 + 48);
  while (1)
  {
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::enumerator_s::next((uint64_t)v39, v16);
    if (!__src)
      break;
    v17 = v39[0];
    v18 = *(float *)&v39[1];
    v19 = v39[2];
    v20 = v41;
    memcpy(buf, __src, sizeof(buf));
    v22 = *(_QWORD *)(a4 + 8);
    v21 = *(_QWORD *)(a4 + 16);
    v23 = v22 + 1;
    if (v22 + 1 < v21)
    {
      v24 = *(_QWORD **)a4;
      goto LABEL_17;
    }
    if (v21)
    {
      if (v23 >= v21)
        goto LABEL_14;
    }
    else
    {
      *(_QWORD *)(a4 + 16) = 1024;
      v21 = 1024;
      if (v23 >= 0x400)
      {
        do
LABEL_14:
          v21 *= 2;
        while (v23 >= v21);
        *(_QWORD *)(a4 + 16) = v21;
      }
    }
    v24 = malloc_type_realloc(*(void **)a4, 24 * v21, 0x10200409F4E64B8uLL);
    *(_QWORD *)a4 = v24;
    v22 = *(_QWORD *)(a4 + 8);
    v23 = v22 + 1;
LABEL_17:
    v24[3 * v22 + 1] = v20;
    *(_QWORD *)(a4 + 8) = v23;
    if (*(_DWORD *)(a1 + 204) == -1)
    {
      v34 = __si_assert_copy_extra_268();
      v35 = v34;
      v36 = "";
      if (v34)
        v36 = v34;
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2689, "mergeBeginVectorOffset < VECTOR_NOT_FOUND", v36);
      goto LABEL_38;
    }
    v25 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::lookupForInsert(a1 + 48, v19, buf, v17, 0, v18);
    v26 = *((_QWORD *)v25 + 384);
    if (!v26)
    {
      v26 = (*(_DWORD *)(a4 + 24) + 1);
      *(_DWORD *)(a4 + 24) = v26;
      *((_QWORD *)v25 + 384) = v26;
    }
    *(_DWORD *)(*(_QWORD *)a4 + 24 * v22) = v26;
  }
  result = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::endMerge(a1 + 48);
  if (v16)
  {
    std::deque<std::shared_ptr<AnyPartitionStore::Enumerator>>::~deque[abi:nn180100](v16 + 32);
    v28 = *(std::__shared_weak_count **)(v16 + 24);
    if (v28)
    {
      p_shared_owners = (unint64_t *)&v28->__shared_owners_;
      do
        v30 = __ldaxr(p_shared_owners);
      while (__stlxr(v30 - 1, p_shared_owners));
      if (!v30)
      {
        ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
        std::__shared_weak_count::__release_weak(v28);
      }
    }
    v31 = *(std::__shared_weak_count **)(v16 + 8);
    if (v31)
    {
      v32 = (unint64_t *)&v31->__shared_owners_;
      do
        v33 = __ldaxr(v32);
      while (__stlxr(v33 - 1, v32));
      if (!v33)
      {
        ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
        std::__shared_weak_count::__release_weak(v31);
      }
    }
    return MEMORY[0x1BCCB06A4](v16, 0x10A0C40B50FE552);
  }
  return result;
}

int *IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::mergeUpdateSet(int *result, uint64_t a2)
{
  int *v3;
  uint64_t v4;
  char *v5;
  char *v6;
  const char *v7;
  int v8;
  NSObject *v9;
  int v10;
  int v11;
  int v12;
  int v13;
  char *v14;
  const char *v15;
  uint8_t buf[4];
  int v17;
  __int16 v18;
  int v19;
  __int16 v20;
  int v21;
  __int16 v22;
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (result[2] != *(_DWORD *)(a2 + 8)
    || (v3 = result, *((unsigned __int16 *)result + 10) != *(unsigned __int16 *)(a2 + 20))
    || result[3] != *(_DWORD *)(a2 + 12)
    || result[4] != *(_DWORD *)(a2 + 16))
  {
    v5 = __si_assert_copy_extra_268();
    v6 = v5;
    v7 = "";
    if (v5)
      v7 = v5;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3075, "compatible", v7);
LABEL_11:
    free(v6);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  if (dword_1EF19FCCC >= 5)
  {
    v8 = *__error();
    v9 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      v10 = (*(uint64_t (**)(int *))(*(_QWORD *)v3 + 16))(v3);
      v11 = (*(uint64_t (**)(int *))(*(_QWORD *)v3 + 24))(v3);
      v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
      v13 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 24))(a2);
      *(_DWORD *)buf = 67109888;
      v17 = v10;
      v18 = 1024;
      v19 = v11;
      v20 = 1024;
      v21 = v12;
      v22 = 1024;
      v23 = v13;
      _os_log_impl(&dword_1B8270000, v9, OS_LOG_TYPE_DEFAULT, "mergeUpdateSet(DocID) %u vectors in %u partitions and %u vectors in %u partitions", buf, 0x1Au);
    }
    result = __error();
    *result = v8;
  }
  v4 = *(_QWORD *)(a2 + 80);
  if (*(_DWORD *)(v4 + 24))
  {
    IVFVectorIndexTemplate<float,768>::VectorStore<vi_onefixedsize_memory_allocator,vi_memory_postings>::Iterator::operator->(v4, 0);
    IVFVectorIndexTemplate<float,768>::VectorStore<vi_onefixedsize_memory_allocator,vi_memory_postings>::Iterator::operator->(v4, 0);
    IVFVectorIndexTemplate<float,768>::VectorStore<vi_onefixedsize_memory_allocator,vi_memory_postings>::Iterator::operator->(v4, 0);
    v14 = __si_assert_copy_extra_268();
    v6 = v14;
    v15 = "";
    if (v14)
      v15 = v14;
    __message_assert("%s:%u: failed assertion '%s' %s ", "VectorIndexSupport.hh", 2447, "0", v15);
    goto LABEL_11;
  }
  return result;
}

uint64_t IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::mergeUpdateSetForTest(uint64_t a1, uint64_t a2)
{
  int v4;
  NSObject *v5;
  os_log_type_t v6;
  int v7;
  int v8;
  int v9;
  int v10;
  _QWORD *v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  _DWORD *v17;
  uint64_t v18;
  uint64_t result;
  std::__shared_weak_count *v20;
  unint64_t *p_shared_owners;
  unint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  char *v26;
  char *v27;
  const char *v28;
  char *v29;
  const char *v30;
  uint8_t buf[8];
  _QWORD *v32;
  __int128 v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)
    || *(unsigned __int16 *)(a1 + 20) != *(unsigned __int16 *)(a2 + 20)
    || *(_DWORD *)(a1 + 12) != *(_DWORD *)(a2 + 12)
    || *(_DWORD *)(a1 + 16) != *(_DWORD *)(a2 + 16))
  {
    v26 = __si_assert_copy_extra_268();
    v27 = v26;
    v28 = "";
    if (v26)
      v28 = v26;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3075, "compatible", v28);
LABEL_32:
    free(v27);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v4 = *__error();
  v5 = _SILogForLogForCategory(16);
  v6 = 2 * (dword_1EF19FCCC < 4);
  if (os_log_type_enabled(v5, v6))
  {
    v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
    v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
    v9 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
    v10 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 24))(a2);
    *(_DWORD *)buf = 67109888;
    *(_DWORD *)&buf[4] = v7;
    LOWORD(v32) = 1024;
    *(_DWORD *)((char *)&v32 + 2) = v8;
    HIWORD(v32) = 1024;
    LODWORD(v33) = v9;
    WORD2(v33) = 1024;
    *(_DWORD *)((char *)&v33 + 6) = v10;
    _os_log_impl(&dword_1B8270000, v5, v6, "mergeUpdateSetForTest %u vectors in %u partitions and %u vectors in %u partitions", buf, 0x1Au);
  }
  *__error() = v4;
  v11 = operator new(0x10uLL);
  v32 = v11 + 2;
  *(_QWORD *)&v33 = v11 + 2;
  *v11 = a1 + 48;
  v11[1] = a2 + 48;
  *(_QWORD *)buf = v11;
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::train<vi_onefixedsize_disk_allocator>(*(_QWORD *)(a1 + 112), *(std::__shared_weak_count **)(a1 + 120), (uint64_t)buf);
  operator delete(v11);
  v12 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::enumerator(a2 + 48);
  v13 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  v14 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::beginMerge(a1 + 48);
  v15 = 0;
  while (1)
  {
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::enumerator_s::next((uint64_t)buf, v12);
    if (!(_QWORD)v33)
      break;
    v16 = *(unsigned int *)(*((_QWORD *)&v33 + 1) + 8);
    v17 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::lookupForInsert(a1 + 48, v32, (void *)v33, *(unsigned int *)buf, 0, *(float *)&buf[4]);
    v18 = *((_QWORD *)v17 + 384);
    *((_QWORD *)v17 + 384) = v16;
    if (v18)
      ++v15;
  }
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::endMerge(a1 + 48);
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  if ((_DWORD)result + v15 != v14 + v13)
  {
    v29 = __si_assert_copy_extra_268();
    v27 = v29;
    v30 = "";
    if (v29)
      v30 = v29;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3267, "nVectors() + dup == old + added", v30);
    goto LABEL_32;
  }
  if (v12)
  {
    std::deque<std::shared_ptr<AnyPartitionStore::Enumerator>>::~deque[abi:nn180100](v12 + 32);
    v20 = *(std::__shared_weak_count **)(v12 + 24);
    if (v20)
    {
      p_shared_owners = (unint64_t *)&v20->__shared_owners_;
      do
        v22 = __ldaxr(p_shared_owners);
      while (__stlxr(v22 - 1, p_shared_owners));
      if (!v22)
      {
        ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
        std::__shared_weak_count::__release_weak(v20);
      }
    }
    v23 = *(std::__shared_weak_count **)(v12 + 8);
    if (v23)
    {
      v24 = (unint64_t *)&v23->__shared_owners_;
      do
        v25 = __ldaxr(v24);
      while (__stlxr(v25 - 1, v24));
      if (!v25)
      {
        ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
        std::__shared_weak_count::__release_weak(v23);
      }
    }
    return MEMORY[0x1BCCB06A4](v12, 0x10A0C40B50FE552);
  }
  return result;
}

uint64_t IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::mergeIndexForTest(uint64_t a1, uint64_t a2)
{
  int v4;
  NSObject *v5;
  os_log_type_t v6;
  float v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  _DWORD *v16;
  uint64_t v17;
  uint64_t result;
  std::__shared_weak_count *v19;
  unint64_t *p_shared_owners;
  unint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  char *v25;
  char *v26;
  const char *v27;
  char *v28;
  const char *v29;
  uint8_t buf[4];
  float v31;
  _BYTE v32[6];
  __int16 v33;
  __int128 v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)
    || *(unsigned __int16 *)(a1 + 20) != *(unsigned __int16 *)(a2 + 20)
    || *(_DWORD *)(a1 + 12) != *(_DWORD *)(a2 + 12)
    || *(_DWORD *)(a1 + 16) != *(_DWORD *)(a2 + 16))
  {
    v25 = __si_assert_copy_extra_268();
    v26 = v25;
    v27 = "";
    if (v25)
      v27 = v25;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3075, "compatible", v27);
LABEL_32:
    free(v26);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v4 = *__error();
  v5 = _SILogForLogForCategory(16);
  v6 = 2 * (dword_1EF19FCCC < 4);
  if (os_log_type_enabled(v5, v6))
  {
    LODWORD(v7) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
    v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
    v9 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
    v10 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 24))(a2);
    *(_DWORD *)buf = 67109888;
    v31 = v7;
    *(_WORD *)v32 = 1024;
    *(_DWORD *)&v32[2] = v8;
    v33 = 1024;
    LODWORD(v34) = v9;
    WORD2(v34) = 1024;
    *(_DWORD *)((char *)&v34 + 6) = v10;
    _os_log_impl(&dword_1B8270000, v5, v6, "mergeIndexForTest %u vectors in %u partitions and %u vectors in %u partitions", buf, 0x1Au);
  }
  *__error() = v4;
  v11 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::enumerator(a2 + 48);
  v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  v13 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::beginMerge(a1 + 48);
  v14 = 0;
  while (1)
  {
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::enumerator_s::next((uint64_t)buf, v11);
    if (!(_QWORD)v34)
      break;
    v15 = **((_QWORD **)&v34 + 1);
    v16 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::lookupForInsert(a1 + 48, *(unsigned int *)v32, (void *)v34, *(unsigned int *)buf, 0, v31);
    v17 = *((_QWORD *)v16 + 384);
    *((_QWORD *)v16 + 384) = v15;
    if (v17)
      ++v14;
  }
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::endMerge(a1 + 48);
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  if ((_DWORD)result + v14 != v13 + v12)
  {
    v28 = __si_assert_copy_extra_268();
    v26 = v28;
    v29 = "";
    if (v28)
      v29 = v28;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3281, "nVectors() + dup == old + added", v29);
    goto LABEL_32;
  }
  if (v11)
  {
    std::deque<std::shared_ptr<AnyPartitionStore::Enumerator>>::~deque[abi:nn180100](v11 + 32);
    v19 = *(std::__shared_weak_count **)(v11 + 24);
    if (v19)
    {
      p_shared_owners = (unint64_t *)&v19->__shared_owners_;
      do
        v21 = __ldaxr(p_shared_owners);
      while (__stlxr(v21 - 1, p_shared_owners));
      if (!v21)
      {
        ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
        std::__shared_weak_count::__release_weak(v19);
      }
    }
    v22 = *(std::__shared_weak_count **)(v11 + 8);
    if (v22)
    {
      v23 = (unint64_t *)&v22->__shared_owners_;
      do
        v24 = __ldaxr(v23);
      while (__stlxr(v24 - 1, v23));
      if (!v24)
      {
        ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
        std::__shared_weak_count::__release_weak(v22);
      }
    }
    return MEMORY[0x1BCCB06A4](v11, 0x10A0C40B50FE552);
  }
  return result;
}

void IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::dump(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  os_unfair_lock_s *v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  std::__shared_weak_count *v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  uint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  unint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  unint64_t *v33;
  unint64_t v34;
  unint64_t *v35;
  unint64_t v36;
  _QWORD v37[2];
  uint64_t (*v38)(uint64_t, uint64_t, BOOL *);
  void *v39;
  uint64_t v40;
  uint64_t v41;
  _QWORD v42[2];
  uint64_t v43;
  std::__shared_weak_count *v44;
  __int128 v45;
  __int128 v46;
  _OWORD v47[3];
  __int128 v48;
  __int128 v49;
  char v50;
  __int128 v51;
  __int128 v52;

  v9 = (os_unfair_lock_s *)(a1 + 160);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 160));
  v10 = *(std::__shared_weak_count **)(a1 + 136);
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }
  v14 = *(_QWORD *)(a1 + 144);
  v13 = *(std::__shared_weak_count **)(a1 + 152);
  if (v13)
  {
    v15 = (unint64_t *)&v13->__shared_owners_;
    do
      v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
  }
  os_unfair_lock_unlock(v9);
  v46 = 0u;
  memset(v47, 0, sizeof(v47));
  v45 = 0u;
  v43 = v14;
  v44 = v13;
  if (v13)
  {
    v17 = (unint64_t *)&v13->__shared_owners_;
    do
      v18 = __ldxr(v17);
    while (__stxr(v18 + 1, v17));
  }
  v19 = *(_QWORD *)(a1 + 96);
  v20 = *(std::__shared_weak_count **)(a1 + 104);
  v42[0] = v19;
  v42[1] = v20;
  if (v20)
  {
    v21 = (unint64_t *)&v20->__shared_owners_;
    do
      v22 = __ldxr(v21);
    while (__stxr(v22 + 1, v21));
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::enumerator_s::enumerator_s((uint64_t)&v45, &v43, v42);
    do
      v23 = __ldaxr(v21);
    while (__stlxr(v23 - 1, v21));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
  else
  {
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::enumerator_s::enumerator_s((uint64_t)&v45, &v43, v42);
  }
  v24 = v44;
  if (v44)
  {
    v25 = (unint64_t *)&v44->__shared_owners_;
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }
  v37[0] = MEMORY[0x1E0C809B0];
  v37[1] = 0x40000000;
  v38 = ___ZNK22IVFVectorIndexTemplateIfLi768EE20IVFVectorIndexRoot_sI30vi_onefixedsize_disk_allocator16vi_disk_postingsE4dumpEbbPViPvU13block_pointerFbjPKvybjfE_block_invoke;
  v39 = &unk_1E6E34970;
  v40 = a6;
  v41 = a4;
  v51 = 0u;
  v52 = 0u;
  v50 = 0;
  do
  {
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::enumerator_s::next((uint64_t)&v48, (uint64_t)&v45);
    v51 = v48;
    v52 = v49;
    if (!(_QWORD)v49)
      break;
    v38((uint64_t)v37, (uint64_t)&v51, (BOOL *)&v50);
  }
  while (!v50);
  std::deque<std::shared_ptr<AnyPartitionStore::Enumerator>>::~deque[abi:nn180100]((uint64_t)v47);
  v27 = (std::__shared_weak_count *)*((_QWORD *)&v46 + 1);
  if (!*((_QWORD *)&v46 + 1))
    goto LABEL_30;
  v28 = (unint64_t *)(*((_QWORD *)&v46 + 1) + 8);
  do
    v29 = __ldaxr(v28);
  while (__stlxr(v29 - 1, v28));
  if (!v29)
  {
    ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
    std::__shared_weak_count::__release_weak(v27);
    v30 = (std::__shared_weak_count *)*((_QWORD *)&v45 + 1);
    if (!*((_QWORD *)&v45 + 1))
      goto LABEL_36;
  }
  else
  {
LABEL_30:
    v30 = (std::__shared_weak_count *)*((_QWORD *)&v45 + 1);
    if (!*((_QWORD *)&v45 + 1))
      goto LABEL_36;
  }
  v31 = (unint64_t *)&v30->__shared_owners_;
  do
    v32 = __ldaxr(v31);
  while (__stlxr(v32 - 1, v31));
  if (!v32)
  {
    ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
    std::__shared_weak_count::__release_weak(v30);
  }
  if (!v13)
    goto LABEL_40;
LABEL_36:
  v33 = (unint64_t *)&v13->__shared_owners_;
  do
    v34 = __ldaxr(v33);
  while (__stlxr(v34 - 1, v33));
  if (!v34)
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
    if (!v10)
      return;
  }
  else
  {
LABEL_40:
    if (!v10)
      return;
  }
  v35 = (unint64_t *)&v10->__shared_owners_;
  do
    v36 = __ldaxr(v35);
  while (__stlxr(v36 - 1, v35));
  if (!v36)
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
}

void IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::flush(uint64_t a1, uint64_t a2)
{
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::flush(a1 + 48, a2);
}

void IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::compact(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __int128 *a5, uint64_t a6)
{
  int v10;
  NSObject *v11;
  os_log_type_t v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  uint64_t v17;
  _QWORD *v18;
  std::__shared_weak_count *v19;
  uint64_t v20;
  unint64_t *p_shared_owners;
  unint64_t v22;
  uint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  unint64_t *v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t *v31;
  unint64_t v32;
  uint64_t v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  unint64_t v37;
  std::__shared_weak_count *v38;
  unint64_t *v39;
  unint64_t v40;
  std::__shared_weak_count *v41;
  unint64_t *v42;
  unint64_t v43;
  std::__shared_weak_count *v44;
  unint64_t *v45;
  unint64_t v46;
  unint64_t *v47;
  unint64_t v48;
  unint64_t *v49;
  unint64_t v50;
  char *v51;
  char *v52;
  const char *v53;
  char *v54;
  const char *v55;
  int v56;
  __int128 v59;
  __int128 v60;
  _QWORD v61[2];
  uint64_t v62;
  std::__shared_weak_count *v63;
  __int128 v64;
  __int128 v65;
  _OWORD v66[3];
  _QWORD v67[3];
  char v68;
  uint64_t v69[2];
  void *__p[3];
  __int128 v71;
  __int128 v72;
  char v73;
  __int128 v74;
  __int128 v75;
  uint8_t buf[8];
  uint64_t v77;
  __int128 v78;
  _QWORD *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  __int128 v84;
  __int128 v85;
  uint64_t v86;

  v86 = *MEMORY[0x1E0C80C00];
  v10 = *__error();
  v11 = _SILogForLogForCategory(16);
  v12 = 2 * (dword_1EF19FCCC < 4);
  if (os_log_type_enabled(v11, v12))
  {
    v56 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
    v13 = a4;
    v14 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
    v15 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
    v16 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 24))(a2);
    *(_DWORD *)buf = 67109888;
    *(_DWORD *)&buf[4] = v56;
    LOWORD(v77) = 1024;
    *(_DWORD *)((char *)&v77 + 2) = v14;
    a4 = v13;
    HIWORD(v77) = 1024;
    LODWORD(v78) = v15;
    WORD2(v78) = 1024;
    *(_DWORD *)((char *)&v78 + 6) = v16;
    _os_log_impl(&dword_1B8270000, v11, v12, "compact %u vectors in %u partitions and %u vectors in %u partitions", buf, 0x1Au);
  }
  *__error() = v10;
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)
    || *(unsigned __int16 *)(a1 + 20) != *(unsigned __int16 *)(a2 + 20)
    || *(_DWORD *)(a1 + 12) != *(_DWORD *)(a2 + 12)
    || *(_DWORD *)(a1 + 16) != *(_DWORD *)(a2 + 16))
  {
    v51 = __si_assert_copy_extra_268();
    v52 = v51;
    v53 = "";
    if (v51)
      v53 = v51;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3075, "compatible", v53);
LABEL_70:
    free(v52);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v59 = *a5;
  v60 = a5[1];
  v17 = a2 + 48;
  if (IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nVectors(a2 + 48))
  {
    v54 = __si_assert_copy_extra_268();
    v52 = v54;
    v55 = "";
    if (v54)
      v55 = v54;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2566, "target->nVectors() == 0", v55);
    goto LABEL_70;
  }
  v18 = operator new(8uLL);
  __p[0] = v18;
  *v18 = a1 + 48;
  __p[1] = v18 + 1;
  __p[2] = v18 + 1;
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::train<vi_onefixedsize_disk_allocator>(*(_QWORD *)(a1 + 112), *(std::__shared_weak_count **)(a1 + 120), (uint64_t)__p);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 160));
  v20 = *(_QWORD *)(a1 + 128);
  v19 = *(std::__shared_weak_count **)(a1 + 136);
  if (v19)
  {
    p_shared_owners = (unint64_t *)&v19->__shared_owners_;
    do
      v22 = __ldxr(p_shared_owners);
    while (__stxr(v22 + 1, p_shared_owners));
  }
  v23 = *(_QWORD *)(a1 + 144);
  v24 = *(std::__shared_weak_count **)(a1 + 152);
  if (v24)
  {
    v25 = (unint64_t *)&v24->__shared_owners_;
    do
      v26 = __ldxr(v25);
    while (__stxr(v26 + 1, v25));
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 160));
  v69[0] = v20;
  v69[1] = (uint64_t)v19;
  if (v19)
  {
    v27 = (unint64_t *)&v19->__shared_owners_;
    v28 = a3;
    do
      v29 = __ldxr(v27);
    while (__stxr(v29 + 1, v27));
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::replaceQuantizer(v17, v69);
    do
      v30 = __ldaxr(v27);
    while (__stlxr(v30 - 1, v27));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
  else
  {
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::replaceQuantizer(v17, v69);
    v28 = a3;
  }
  v67[0] = 0;
  v67[1] = v67;
  v67[2] = 0x2000000000;
  v68 = 1;
  v65 = 0u;
  memset(v66, 0, sizeof(v66));
  v64 = 0u;
  v62 = v23;
  v63 = v24;
  if (v24)
  {
    v31 = (unint64_t *)&v24->__shared_owners_;
    do
      v32 = __ldxr(v31);
    while (__stxr(v32 + 1, v31));
  }
  v33 = *(_QWORD *)(a1 + 96);
  v34 = *(std::__shared_weak_count **)(a1 + 104);
  v61[0] = v33;
  v61[1] = v34;
  if (v34)
  {
    v35 = (unint64_t *)&v34->__shared_owners_;
    do
      v36 = __ldxr(v35);
    while (__stxr(v36 + 1, v35));
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::enumerator_s::enumerator_s((uint64_t)&v64, &v62, v61);
    do
      v37 = __ldaxr(v35);
    while (__stlxr(v37 - 1, v35));
    if (!v37)
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
  }
  else
  {
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::enumerator_s::enumerator_s((uint64_t)&v64, &v62, v61);
  }
  v38 = v63;
  if (v63)
  {
    v39 = (unint64_t *)&v63->__shared_owners_;
    do
      v40 = __ldaxr(v39);
    while (__stlxr(v40 - 1, v39));
    if (!v40)
    {
      ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
      std::__shared_weak_count::__release_weak(v38);
    }
  }
  *(_QWORD *)buf = MEMORY[0x1E0C809B0];
  v77 = 0x40000000;
  *(_QWORD *)&v78 = ___ZN22IVFVectorIndexTemplateIfLi768EE20IVFVectorIndexRoot_sI30vi_onefixedsize_disk_allocator16vi_disk_postingsE7compactIS2_EENSt3__19enable_ifIXsr13is_persistentIT_EE5valueEbE4typeEPS4_P12uint32_map_tP11TermIdStore18CICompactCallbacksPVi_block_invoke;
  *((_QWORD *)&v78 + 1) = &unk_1E6E34998;
  v79 = v67;
  v80 = v28;
  v81 = a4;
  v82 = v17;
  v83 = a6;
  v84 = v59;
  v85 = v60;
  v74 = 0u;
  v75 = 0u;
  v73 = 0;
  do
  {
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::enumerator_s::next((uint64_t)&v71, (uint64_t)&v64);
    v74 = v71;
    v75 = v72;
    if (!(_QWORD)v72)
      break;
    ((void (*)(uint8_t *, __int128 *, char *))v78)(buf, &v74, &v73);
  }
  while (!v73);
  std::deque<std::shared_ptr<AnyPartitionStore::Enumerator>>::~deque[abi:nn180100]((uint64_t)v66);
  v41 = (std::__shared_weak_count *)*((_QWORD *)&v65 + 1);
  if (*((_QWORD *)&v65 + 1))
  {
    v42 = (unint64_t *)(*((_QWORD *)&v65 + 1) + 8);
    do
      v43 = __ldaxr(v42);
    while (__stlxr(v43 - 1, v42));
    if (!v43)
    {
      ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
      std::__shared_weak_count::__release_weak(v41);
    }
  }
  v44 = (std::__shared_weak_count *)*((_QWORD *)&v64 + 1);
  if (*((_QWORD *)&v64 + 1))
  {
    v45 = (unint64_t *)(*((_QWORD *)&v64 + 1) + 8);
    do
      v46 = __ldaxr(v45);
    while (__stlxr(v46 - 1, v45));
    if (!v46)
    {
      ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
      std::__shared_weak_count::__release_weak(v44);
    }
  }
  _Block_object_dispose(v67, 8);
  if (v24)
  {
    v47 = (unint64_t *)&v24->__shared_owners_;
    do
      v48 = __ldaxr(v47);
    while (__stlxr(v48 - 1, v47));
    if (!v48)
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }
  if (v19)
  {
    v49 = (unint64_t *)&v19->__shared_owners_;
    do
      v50 = __ldaxr(v49);
    while (__stlxr(v50 - 1, v49));
    if (!v50)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
  if (__p[0])
    operator delete(__p[0]);
}

void IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::compactForTest(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6;
  NSObject *v7;
  os_log_type_t v8;
  int v9;
  int v10;
  int v11;
  int v12;
  char *v13;
  char *v14;
  const char *v15;
  uint8_t buf[4];
  int v17;
  __int16 v18;
  int v19;
  __int16 v20;
  int v21;
  __int16 v22;
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)
    || *(unsigned __int16 *)(a1 + 20) != *(unsigned __int16 *)(a2 + 20)
    || *(_DWORD *)(a1 + 12) != *(_DWORD *)(a2 + 12)
    || *(_DWORD *)(a1 + 16) != *(_DWORD *)(a2 + 16))
  {
    v13 = __si_assert_copy_extra_268();
    v14 = v13;
    v15 = "";
    if (v13)
      v15 = v13;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3075, "compatible", v15);
    free(v14);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v6 = *__error();
  v7 = _SILogForLogForCategory(16);
  v8 = 2 * (dword_1EF19FCCC < 4);
  if (os_log_type_enabled(v7, v8))
  {
    v9 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
    v10 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
    v11 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
    v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 24))(a2);
    *(_DWORD *)buf = 67109888;
    v17 = v9;
    v18 = 1024;
    v19 = v10;
    v20 = 1024;
    v21 = v11;
    v22 = 1024;
    v23 = v12;
    _os_log_impl(&dword_1B8270000, v7, v8, "compactForTest %u vectors in %u partitions and %u vectors in %u partitions", buf, 0x1Au);
  }
  *__error() = v6;
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::compactForTest<vi_onefixedsize_disk_allocator>(a1 + 48, a2 + 48, a3);
}

void IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::subvert(uint64_t a1, uint64_t a2)
{
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  uint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  char *v26;
  char *v27;
  const char *v28;

  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)
    || *(unsigned __int16 *)(a1 + 20) != *(unsigned __int16 *)(a2 + 20)
    || *(_DWORD *)(a1 + 12) != *(_DWORD *)(a2 + 12)
    || *(_DWORD *)(a1 + 16) != *(_DWORD *)(a2 + 16))
  {
    v26 = __si_assert_copy_extra_268();
    v27 = v26;
    v28 = "";
    if (v26)
      v28 = v26;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3075, "compatible", v28);
    free(v27);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 160));
  v4 = *(std::__shared_weak_count **)(a1 + 136);
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  v8 = *(_QWORD *)(a1 + 144);
  v7 = *(std::__shared_weak_count **)(a1 + 152);
  if (v7)
  {
    v9 = (unint64_t *)&v7->__shared_owners_;
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 160));
  if (v4)
  {
    v11 = (unint64_t *)&v4->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 160));
  v13 = *(std::__shared_weak_count **)(a2 + 136);
  if (v13)
  {
    v14 = (unint64_t *)&v13->__shared_owners_;
    do
      v15 = __ldxr(v14);
    while (__stxr(v15 + 1, v14));
  }
  v17 = *(_QWORD *)(a2 + 144);
  v16 = *(std::__shared_weak_count **)(a2 + 152);
  if (v16)
  {
    v18 = (unint64_t *)&v16->__shared_owners_;
    do
      v19 = __ldxr(v18);
    while (__stxr(v19 + 1, v18));
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a2 + 160));
  if (v13)
  {
    v20 = (unint64_t *)&v13->__shared_owners_;
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v8 + 168))(v8, v17);
  vi_onefixedsize_disk_allocator::subvert(*(_QWORD *)(*(_QWORD *)(a2 + 96) + 32), *(_QWORD *)(*(_QWORD *)(a1 + 96) + 32));
  if (!v16)
    goto LABEL_31;
  v22 = (unint64_t *)&v16->__shared_owners_;
  do
    v23 = __ldaxr(v22);
  while (__stlxr(v23 - 1, v22));
  if (!v23)
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
    if (!v7)
      return;
  }
  else
  {
LABEL_31:
    if (!v7)
      return;
  }
  v24 = (unint64_t *)&v7->__shared_owners_;
  do
    v25 = __ldaxr(v24);
  while (__stlxr(v25 - 1, v24));
  if (!v25)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
}

BOOL IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::unlink(uint64_t a1)
{
  os_unfair_lock_s *v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  uint64_t v10;
  int v11;
  NSObject *v12;
  _QWORD *v13;
  int v14;
  int v15;
  int v16;
  _BOOL8 v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  int v23;
  _QWORD *v24;
  __int16 v25;
  int v26;
  __int16 v27;
  int v28;
  __int16 v29;
  int v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v2 = (os_unfair_lock_s *)(a1 + 160);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 160));
  v3 = *(std::__shared_weak_count **)(a1 + 136);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  v7 = *(_QWORD *)(a1 + 144);
  v6 = *(std::__shared_weak_count **)(a1 + 152);
  if (v6)
  {
    v8 = (unint64_t *)&v6->__shared_owners_;
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  os_unfair_lock_unlock(v2);
  (*(void (**)(uint64_t))(*(_QWORD *)v7 + 176))(v7);
  v10 = *(_QWORD *)(a1 + 96);
  v11 = *__error();
  v12 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    v13 = (_QWORD *)(v10 + 56);
    if (*(char *)(v10 + 79) < 0)
      v13 = (_QWORD *)*v13;
    v14 = *(_DWORD *)(v10 + 40);
    v15 = *(_DWORD *)(_windowsResolvePtr(*(_QWORD *)(v10 + 32) + 40, *(_QWORD *)(*(_QWORD *)(v10 + 32) + 24), 0xC10uLL)+ 3080);
    v16 = *(_DWORD *)(_windowsResolvePtr(*(_QWORD *)(v10 + 32) + 40, *(_QWORD *)(*(_QWORD *)(v10 + 32) + 24)+ *(_QWORD *)(*(_QWORD *)(v10 + 32) + 16) * (*(_DWORD *)(v10 + 40) - 1), 0xC10uLL)+ 3080);
    v23 = 136315906;
    v24 = v13;
    v25 = 1024;
    v26 = v14;
    v27 = 1024;
    v28 = v15;
    v29 = 1024;
    v30 = v16;
    _os_log_impl(&dword_1B8270000, v12, OS_LOG_TYPE_DEFAULT, "unlink VectorStore %s(%u)[%u,%u]", (uint8_t *)&v23, 0x1Eu);
  }
  *__error() = v11;
  v17 = vi_onefixedsize_disk_allocator::unlinkStorage(*(_QWORD *)(v10 + 32));
  if (v6)
  {
    v18 = (unint64_t *)&v6->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  if (v3)
  {
    v20 = (unint64_t *)&v3->__shared_owners_;
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  return v17;
}

void IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::truncate(uint64_t a1)
{
  int v1;
  NSObject *v2;
  os_log_type_t v3;
  os_unfair_lock_s *v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  uint8_t v16[16];

  if (*(_BYTE *)(a1 + 208))
  {
    v1 = *__error();
    v2 = _SILogForLogForCategory(16);
    v3 = dword_1EF19FCCC < 3;
    if (os_log_type_enabled(v2, (os_log_type_t)(dword_1EF19FCCC < 3)))
    {
      *(_WORD *)v16 = 0;
      _os_log_impl(&dword_1B8270000, v2, v3, "*warn* call truncate on readOnly index.", v16, 2u);
    }
    *__error() = v1;
  }
  else
  {
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::flush(a1 + 48, 0);
    IVFVectorIndexTemplate<float,768>::VectorStore<vi_onefixedsize_disk_allocator,vi_disk_postings>::truncate(*(_QWORD *)(a1 + 96));
    v5 = (os_unfair_lock_s *)(a1 + 160);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 160));
    v6 = *(std::__shared_weak_count **)(a1 + 136);
    if (v6)
    {
      p_shared_owners = (unint64_t *)&v6->__shared_owners_;
      do
        v8 = __ldxr(p_shared_owners);
      while (__stxr(v8 + 1, p_shared_owners));
    }
    v10 = *(_QWORD *)(a1 + 144);
    v9 = *(std::__shared_weak_count **)(a1 + 152);
    if (v9)
    {
      v11 = (unint64_t *)&v9->__shared_owners_;
      do
        v12 = __ldxr(v11);
      while (__stxr(v12 + 1, v11));
      os_unfair_lock_unlock(v5);
      (*(void (**)(uint64_t))(*(_QWORD *)v10 + 136))(v10);
      do
        v13 = __ldaxr(v11);
      while (__stlxr(v13 - 1, v11));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
    else
    {
      os_unfair_lock_unlock(v5);
      (*(void (**)(uint64_t))(*(_QWORD *)v10 + 136))(v10);
    }
    if (v6)
    {
      v14 = (unint64_t *)&v6->__shared_owners_;
      do
        v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }
}

void IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::makeReadOnly(uint64_t a1)
{
  int v1;
  NSObject *v2;
  os_log_type_t v3;
  uint64_t v5;
  int v6;
  NSObject *v7;
  _QWORD *v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v17;
  int *v18;
  std::__shared_weak_count *v19;
  unint64_t *p_shared_owners;
  unint64_t v21;
  std::__shared_weak_count *v22;
  uint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t *v27;
  unint64_t v28;
  int v29;
  _QWORD *v30;
  __int16 v31;
  int v32;
  __int16 v33;
  int v34;
  __int16 v35;
  int v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 208))
  {
    v1 = *__error();
    v2 = _SILogForLogForCategory(16);
    v3 = dword_1EF19FCCC < 3;
    if (os_log_type_enabled(v2, (os_log_type_t)(dword_1EF19FCCC < 3)))
    {
      LOWORD(v29) = 0;
      _os_log_impl(&dword_1B8270000, v2, v3, "*warn* call makeReadOnly on readOnly index.", (uint8_t *)&v29, 2u);
    }
    *__error() = v1;
  }
  else
  {
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::flush(a1 + 48, 0);
    v5 = *(_QWORD *)(a1 + 96);
    v6 = *__error();
    v7 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      v8 = (_QWORD *)(v5 + 56);
      if (*(char *)(v5 + 79) < 0)
        v8 = (_QWORD *)*v8;
      v9 = *(_DWORD *)(v5 + 40);
      v10 = *(_DWORD *)(_windowsResolvePtr(*(_QWORD *)(v5 + 32) + 40, *(_QWORD *)(*(_QWORD *)(v5 + 32) + 24), 0xC10uLL)+ 3080);
      v11 = *(_DWORD *)(_windowsResolvePtr(*(_QWORD *)(v5 + 32) + 40, *(_QWORD *)(*(_QWORD *)(v5 + 32) + 24)+ *(_QWORD *)(*(_QWORD *)(v5 + 32) + 16) * (*(_DWORD *)(v5 + 40) - 1), 0xC10uLL)+ 3080);
      v29 = 136315906;
      v30 = v8;
      v31 = 1024;
      v32 = v9;
      v33 = 1024;
      v34 = v10;
      v35 = 1024;
      v36 = v11;
      _os_log_impl(&dword_1B8270000, v7, OS_LOG_TYPE_DEFAULT, "makeReadOnly VectorStore %s(%u)[%u,%u]", (uint8_t *)&v29, 0x1Eu);
    }
    *__error() = v6;
    IVFVectorIndexTemplate<float,768>::VectorStore<vi_onefixedsize_disk_allocator,vi_disk_postings>::truncate(v5);
    v12 = *(_QWORD *)(v5 + 32);
    fd_make_readonly(*(_QWORD *)(v12 + 40));
    v13 = *(_QWORD *)(v12 + 40);
    if (v13)
    {
      do
      {
        v14 = fchmodat(*(_DWORD *)(v13 + 44), *(const char **)(v13 + 72), 0x100u, 2048);
        v15 = g_prot_error_callback;
        if (v14 != -1 || g_prot_error_callback == 0)
          break;
        v17 = *(unsigned int *)(v13 + 40);
        v18 = __error();
      }
      while (((*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t))(v15 + 16))(v15, v17, *v18, 19) & 1) != 0);
    }
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 160));
    v19 = *(std::__shared_weak_count **)(a1 + 136);
    if (v19)
    {
      p_shared_owners = (unint64_t *)&v19->__shared_owners_;
      do
        v21 = __ldxr(p_shared_owners);
      while (__stxr(v21 + 1, p_shared_owners));
    }
    v23 = *(_QWORD *)(a1 + 144);
    v22 = *(std::__shared_weak_count **)(a1 + 152);
    if (v22)
    {
      v24 = (unint64_t *)&v22->__shared_owners_;
      do
        v25 = __ldxr(v24);
      while (__stxr(v25 + 1, v24));
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 160));
      (*(void (**)(uint64_t))(*(_QWORD *)v23 + 120))(v23);
      *(_BYTE *)(a1 + 208) = 1;
      do
        v26 = __ldaxr(v24);
      while (__stlxr(v26 - 1, v24));
      if (!v26)
      {
        ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
        std::__shared_weak_count::__release_weak(v22);
      }
    }
    else
    {
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 160));
      (*(void (**)(uint64_t))(*(_QWORD *)v23 + 120))(v23);
      *(_BYTE *)(a1 + 208) = 1;
    }
    if (v19)
    {
      v27 = (unint64_t *)&v19->__shared_owners_;
      do
        v28 = __ldaxr(v27);
      while (__stlxr(v28 - 1, v27));
      if (!v28)
      {
        ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
        std::__shared_weak_count::__release_weak(v19);
      }
    }
  }
}

void IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::makePurgeable(uint64_t a1)
{
  uint64_t v2;
  int v3;
  NSObject *v4;
  _QWORD *v5;
  int v6;
  int v7;
  int v8;
  os_unfair_lock_s *v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  std::__shared_weak_count *v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  int v20;
  _QWORD *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 96);
  v3 = *__error();
  v4 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v5 = (_QWORD *)(v2 + 56);
    if (*(char *)(v2 + 79) < 0)
      v5 = (_QWORD *)*v5;
    v6 = *(_DWORD *)(v2 + 40);
    v7 = *(_DWORD *)(_windowsResolvePtr(*(_QWORD *)(v2 + 32) + 40, *(_QWORD *)(*(_QWORD *)(v2 + 32) + 24), 0xC10uLL)
                   + 3080);
    v8 = *(_DWORD *)(_windowsResolvePtr(*(_QWORD *)(v2 + 32) + 40, *(_QWORD *)(*(_QWORD *)(v2 + 32) + 24)+ *(_QWORD *)(*(_QWORD *)(v2 + 32) + 16) * (*(_DWORD *)(v2 + 40) - 1), 0xC10uLL)+ 3080);
    v20 = 136315906;
    v21 = v5;
    v22 = 1024;
    v23 = v6;
    v24 = 1024;
    v25 = v7;
    v26 = 1024;
    v27 = v8;
    _os_log_impl(&dword_1B8270000, v4, OS_LOG_TYPE_DEFAULT, "makePurgeable VectorStore %s(%u)[%u,%u]", (uint8_t *)&v20, 0x1Eu);
  }
  *__error() = v3;
  fd_mark_purgable(*(_DWORD **)(*(_QWORD *)(v2 + 32) + 40));
  v9 = (os_unfair_lock_s *)(a1 + 160);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 160));
  v10 = *(std::__shared_weak_count **)(a1 + 136);
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }
  v14 = *(_QWORD *)(a1 + 144);
  v13 = *(std::__shared_weak_count **)(a1 + 152);
  if (!v13)
  {
    os_unfair_lock_unlock(v9);
    (*(void (**)(uint64_t))(*(_QWORD *)v14 + 128))(v14);
    if (!v10)
      return;
    goto LABEL_18;
  }
  v15 = (unint64_t *)&v13->__shared_owners_;
  do
    v16 = __ldxr(v15);
  while (__stxr(v16 + 1, v15));
  os_unfair_lock_unlock(v9);
  (*(void (**)(uint64_t))(*(_QWORD *)v14 + 128))(v14);
  do
    v17 = __ldaxr(v15);
  while (__stlxr(v17 - 1, v15));
  if (!v17)
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  if (v10)
  {
LABEL_18:
    v18 = (unint64_t *)&v10->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
}

void IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::rename(uint64_t a1, const char *a2)
{
  int v4;
  NSObject *v5;
  size_t v6;
  std::string::size_type v7;
  std::string *p_buf;
  uint64_t v9;
  uint64_t v10;
  int v11;
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  std::__shared_weak_count *v15;
  uint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  std::string *v19;
  uint64_t v20;
  int v21;
  NSObject *v22;
  _QWORD *v23;
  int v24;
  int v25;
  int v26;
  unint64_t *v27;
  unint64_t v28;
  unint64_t *v29;
  unint64_t v30;
  std::string::value_type __s[23];
  char v32;
  std::string v33;
  std::string buf;
  int v35;
  __int16 v36;
  int v37;
  __int16 v38;
  int v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  v4 = *__error();
  v5 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
    _os_log_impl(&dword_1B8270000, v5, OS_LOG_TYPE_DEFAULT, "rename: %s", (uint8_t *)&buf, 0xCu);
  }
  *__error() = v4;
  v6 = strlen(a2);
  if (v6 >= 0x7FFFFFFFFFFFFFF8)
    abort();
  v7 = v6;
  if (v6 >= 0x17)
  {
    v9 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v6 | 7) != 0x17)
      v9 = v6 | 7;
    v10 = v9 + 1;
    p_buf = (std::string *)operator new(v9 + 1);
    buf.__r_.__value_.__l.__size_ = v7;
    buf.__r_.__value_.__r.__words[2] = v10 | 0x8000000000000000;
    buf.__r_.__value_.__r.__words[0] = (std::string::size_type)p_buf;
    goto LABEL_10;
  }
  *((_BYTE *)&buf.__r_.__value_.__s + 23) = v6;
  p_buf = &buf;
  if (v6)
LABEL_10:
    memcpy(p_buf, a2, v7);
  p_buf->__r_.__value_.__s.__data_[v7] = 0;
  v32 = 11;
  strcpy(__s, ".partitions");
  memset(&v33, 0, sizeof(v33));
  v11 = SHIBYTE(buf.__r_.__value_.__r.__words[2]);
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(&v33, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
  else
    v33 = buf;
  std::string::append(&v33, __s, 0xBuLL);
  if (v32 < 0)
  {
    operator delete(*(void **)__s);
    if ((v11 & 0x80000000) == 0)
      goto LABEL_16;
  }
  else if ((v11 & 0x80000000) == 0)
  {
    goto LABEL_16;
  }
  operator delete(buf.__r_.__value_.__l.__data_);
LABEL_16:
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 160));
  v12 = *(std::__shared_weak_count **)(a1 + 136);
  if (v12)
  {
    p_shared_owners = (unint64_t *)&v12->__shared_owners_;
    do
      v14 = __ldxr(p_shared_owners);
    while (__stxr(v14 + 1, p_shared_owners));
  }
  v16 = *(_QWORD *)(a1 + 144);
  v15 = *(std::__shared_weak_count **)(a1 + 152);
  if (v15)
  {
    v17 = (unint64_t *)&v15->__shared_owners_;
    do
      v18 = __ldxr(v17);
    while (__stxr(v18 + 1, v17));
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 160));
  if ((v33.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v19 = &v33;
  else
    v19 = (std::string *)v33.__r_.__value_.__r.__words[0];
  (*(void (**)(uint64_t, std::string *))(*(_QWORD *)v16 + 152))(v16, v19);
  v20 = *(_QWORD *)(a1 + 96);
  v21 = *__error();
  v22 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    v23 = (_QWORD *)(v20 + 56);
    if (*(char *)(v20 + 79) < 0)
      v23 = (_QWORD *)*v23;
    v24 = *(_DWORD *)(v20 + 40);
    v25 = *(_DWORD *)(_windowsResolvePtr(*(_QWORD *)(v20 + 32) + 40, *(_QWORD *)(*(_QWORD *)(v20 + 32) + 24), 0xC10uLL)+ 3080);
    v26 = *(_DWORD *)(_windowsResolvePtr(*(_QWORD *)(v20 + 32) + 40, *(_QWORD *)(*(_QWORD *)(v20 + 32) + 24)+ *(_QWORD *)(*(_QWORD *)(v20 + 32) + 16) * (*(_DWORD *)(v20 + 40) - 1), 0xC10uLL)+ 3080);
    LODWORD(buf.__r_.__value_.__l.__data_) = 136316162;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v23;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)a2;
    HIWORD(buf.__r_.__value_.__r.__words[2]) = 1024;
    v35 = v24;
    v36 = 1024;
    v37 = v25;
    v38 = 1024;
    v39 = v26;
    _os_log_impl(&dword_1B8270000, v22, OS_LOG_TYPE_DEFAULT, "rename VectorStore %s -> %s(%u)[%u,%u]", (uint8_t *)&buf, 0x28u);
  }
  *__error() = v21;
  MEMORY[0x1BCCB03B0](v20 + 56, a2);
  fd_rename(*(_QWORD *)(*(_QWORD *)(v20 + 32) + 40), a2);
  if (v15)
  {
    v27 = (unint64_t *)&v15->__shared_owners_;
    do
      v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  if (!v12)
    goto LABEL_38;
  v29 = (unint64_t *)&v12->__shared_owners_;
  do
    v30 = __ldaxr(v29);
  while (__stlxr(v30 - 1, v29));
  if (v30)
  {
LABEL_38:
    if ((SHIBYTE(v33.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      return;
    goto LABEL_39;
  }
  ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
  std::__shared_weak_count::__release_weak(v12);
  if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0)
LABEL_39:
    operator delete(v33.__r_.__value_.__l.__data_);
}

void IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::storeUpdateSet()
{
  char *v0;
  char *v1;
  const char *v2;

  v0 = __si_assert_copy_extra_268();
  v1 = v0;
  v2 = "";
  if (v0)
    v2 = v0;
  __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2998, "false", v2);
  free(v1);
  if (__valid_fs(-1))
  {
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  MEMORY[0xC00] = -559038737;
  abort();
}

void IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::restoreUpdateSet()
{
  char *v0;
  char *v1;
  const char *v2;

  v0 = __si_assert_copy_extra_268();
  v1 = v0;
  v2 = "";
  if (v0)
    v2 = v0;
  __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3003, "false", v2);
  free(v1);
  if (__valid_fs(-1))
  {
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  MEMORY[0xC00] = -559038737;
  abort();
}

uint64_t IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::aNN(uint64_t a1, int a2, int a3, unsigned __int8 *a4, int a5, int a6, int a7, char a8, float a9, uint64_t a10)
{
  uint64_t v13;
  int v14;
  _QWORD *v15;
  char *v17;
  char *v18;
  const char *v19;
  _QWORD v20[5];

  if (*(_DWORD *)(a1 + 8) != a2
    || *(unsigned __int16 *)(a1 + 20) != a3
    || a6 > 2
    || *(_DWORD *)(a1 + 12) != vector_dimension_vec_sizes_10743[a5]
    || vector_size_elem_sizes_10742[a6] != *(_DWORD *)(a1 + 16))
  {
    v17 = __si_assert_copy_extra_268();
    v18 = v17;
    v19 = "";
    if (v17)
      v19 = v17;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3070, "compatible", v19);
    free(v18);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v13 = a1 + 48;
  v20[0] = MEMORY[0x1E0C809B0];
  v20[1] = 0x40000000;
  v20[2] = ___ZNK16IVFVectorIndexenI30vi_onefixedsize_disk_allocator16vi_disk_postingsE22IVFVectorIndexInstanceIfLi768EE3aNNEjtPKv14vec_dimensions15vec_data_formatfjbU13block_pointerFvPvfE_block_invoke;
  v20[3] = &unk_1E6E349C0;
  v20[4] = a10;
  if ((a7 - 10001) >= 0xFFFFD8F0)
    v14 = a7;
  else
    v14 = 10000;
  v15 = (_QWORD *)operator new();
  *(_DWORD *)v15 = v14;
  v15[2] = 0;
  v15[3] = 0;
  v15[1] = 0;
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::aNN(v13, a4, a8, v15, 0, a9);
  return IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::aNNProcessResult((uint64_t)v15, (uint64_t)v20);
}

uint64_t IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::aNNForTest(uint64_t a1, int a2, int a3, unsigned __int8 *a4, int a5, int a6, int a7, char a8, float a9, uint64_t a10, unsigned int a11)
{
  uint64_t v14;
  int v15;
  _QWORD *v16;
  char *v18;
  char *v19;
  const char *v20;

  if (*(_DWORD *)(a1 + 8) != a2
    || *(unsigned __int16 *)(a1 + 20) != a3
    || a6 > 2
    || *(_DWORD *)(a1 + 12) != vector_dimension_vec_sizes_10743[a5]
    || vector_size_elem_sizes_10742[a6] != *(_DWORD *)(a1 + 16))
  {
    v18 = __si_assert_copy_extra_268();
    v19 = v18;
    v20 = "";
    if (v18)
      v20 = v18;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3070, "compatible", v20);
    free(v19);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v14 = a1 + 48;
  if ((a7 - 10001) >= 0xFFFFD8F0)
    v15 = a7;
  else
    v15 = 10000;
  v16 = (_QWORD *)operator new();
  *(_DWORD *)v16 = v15;
  v16[2] = 0;
  v16[3] = 0;
  v16[1] = 0;
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::aNN(v14, a4, a8, v16, a11, a9);
  return IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::aNNForTestProcessResult((uint64_t)v16, a10);
}

uint64_t IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::createCandidateQueue(uint64_t a1, int a2)
{
  int v2;
  uint64_t result;

  if ((a2 - 10001) >= 0xFFFFD8F0)
    v2 = a2;
  else
    v2 = 10000;
  result = operator new();
  *(_DWORD *)result = v2;
  *(_QWORD *)(result + 16) = 0;
  *(_QWORD *)(result + 24) = 0;
  *(_QWORD *)(result + 8) = 0;
  return result;
}

void IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::aNN(uint64_t a1, int a2, int a3, unsigned __int8 *a4, int a5, int a6, char a7, _QWORD *a8, float a9)
{
  char *v9;
  char *v10;
  const char *v11;

  if (*(_DWORD *)(a1 + 8) != a2
    || *(unsigned __int16 *)(a1 + 20) != a3
    || a6 > 2
    || *(_DWORD *)(a1 + 12) != vector_dimension_vec_sizes_10743[a5]
    || vector_size_elem_sizes_10742[a6] != *(_DWORD *)(a1 + 16))
  {
    v9 = __si_assert_copy_extra_268();
    v10 = v9;
    v11 = "";
    if (v9)
      v11 = v9;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3070, "compatible", v11);
    free(v10);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::aNN(a1 + 48, a4, a7, a8, 0, a9);
}

uint64_t IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::aNNProcessResult(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD v4[5];

  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 0x40000000;
  v4[2] = ___ZNK16IVFVectorIndexenI30vi_onefixedsize_disk_allocator16vi_disk_postingsE22IVFVectorIndexInstanceIfLi768EE16aNNProcessResultEPvU13block_pointerFvS5_fE_block_invoke;
  v4[3] = &unk_1E6E34A20;
  v4[4] = a3;
  return IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::aNNProcessResult(a2, (uint64_t)v4);
}

uint64_t IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::aNNForTestProcessResult(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::aNNForTestProcessResult(a2, a3);
}

uint64_t IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::aNNForDebugProcessResult(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  std::ios_base *v13;
  uint64_t v14;
  __int128 *v15;
  BOOL v16;
  int v17;
  __int128 *v18;
  _QWORD *v19;
  _QWORD *v20;
  char *v21;
  unint64_t v22;
  int v23;
  NSObject *v24;
  void **v25;
  __int128 *v26;
  char *v27;
  uint64_t v28;
  int v29;
  NSObject *v30;
  void **v31;
  void *v32;
  uint64_t v33;
  int v35;
  __int128 *v36;
  CFIndex AppIntegerValue;
  __int128 *v38;
  __int128 *v39;
  uint64_t v40;
  uint8_t v41[4];
  void **v42;
  void *__p[2];
  uint64_t v44;
  uint64_t v45;
  __int128 buf;
  uint64_t v47;
  _QWORD v48[8];
  __int128 v49;
  __int128 v50;
  uint64_t v51;
  uint64_t v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  uint64_t v62;

  v62 = *MEMORY[0x1E0C80C00];
  v5 = *__error();
  v6 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    v7 = (uint64_t)(*(_QWORD *)(a2 + 16) - *(_QWORD *)(a2 + 8)) >> 4;
    LODWORD(buf) = 134217984;
    *(_QWORD *)((char *)&buf + 4) = v7;
    _os_log_impl(&dword_1B8270000, v6, OS_LOG_TYPE_DEFAULT, "search return %zu results", (uint8_t *)&buf, 0xCu);
  }
  *__error() = v5;
  LOBYTE(buf) = 0;
  AppIntegerValue = CFPreferencesGetAppIntegerValue(CFSTR("IVFANNLogQueryResult"), CFSTR("com.apple.Spotlight"), (Boolean *)&buf);
  v35 = buf;
  v61 = 0u;
  v51 = 0;
  v60 = 0u;
  v59 = 0u;
  v58 = 0u;
  v57 = 0u;
  v56 = 0u;
  v55 = 0u;
  v54 = 0u;
  v53 = 0u;
  v50 = 0u;
  v49 = 0u;
  memset(v48, 0, sizeof(v48));
  v8 = MEMORY[0x1E0DE4FD0] + 104;
  v52 = MEMORY[0x1E0DE4FD0] + 104;
  v9 = (_QWORD *)MEMORY[0x1E0DE4F50];
  v10 = MEMORY[0x1E0DE4FD0] + 64;
  v11 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 16);
  v12 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 24);
  v47 = MEMORY[0x1E0DE4FD0] + 64;
  *(_QWORD *)&buf = v11;
  *(_QWORD *)((char *)&buf + *(_QWORD *)(v11 - 24)) = v12;
  *((_QWORD *)&buf + 1) = 0;
  v13 = (std::ios_base *)((char *)&buf + *(_QWORD *)(buf - 24));
  std::ios_base::init(v13, v48);
  v13[1].__vftable = 0;
  v13[1].__fmtflags_ = -1;
  v14 = v9[5];
  v47 = v9[4];
  *(_QWORD *)((char *)&v48[-1] + *(_QWORD *)(v47 - 24)) = v14;
  *(_QWORD *)&buf = v9[1];
  *(_QWORD *)((char *)&buf + *(_QWORD *)(buf - 24)) = v9[6];
  v52 = v8;
  *(_QWORD *)&buf = MEMORY[0x1E0DE4FD0] + 24;
  v47 = v10;
  std::streambuf::basic_streambuf();
  v48[0] = MEMORY[0x1E0DE4FB8] + 16;
  v49 = 0u;
  v50 = 0u;
  LODWORD(v51) = 24;
  v38 = 0;
  v39 = 0;
  v40 = 0;
  MaxSizePriorityQueue<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>,std::vector<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>,std::allocator<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>>>,std::less<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>>>::allItems(&v38, *(_BYTE **)(a2 + 8), *(_BYTE **)(a2 + 16));
  v15 = v39;
  v36 = v38;
  if (v38 != v39)
  {
    if (AppIntegerValue)
      v16 = v35 == 0;
    else
      v16 = 1;
    if (v16)
    {
      v26 = v38;
      do
      {
        (*(void (**)(uint64_t, _QWORD, _QWORD, float))(a3 + 16))(a3, *(unsigned int *)v26, *((unsigned int *)v26 + 2), *((float *)v26 + 3));
        ++v26;
      }
      while (v26 != v15);
    }
    else
    {
      v17 = 0;
      v18 = v38;
      do
      {
        (*(void (**)(uint64_t, _QWORD, _QWORD, float))(a3 + 16))(a3, *(unsigned int *)v18, *((unsigned int *)v18 + 2), *((float *)v18 + 3));
        v19 = (_QWORD *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v19, (uint64_t)",", 1);
        v20 = (_QWORD *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v20, (uint64_t)";", 1);
        v21 = (char *)&v48[-1] + *(_QWORD *)(v47 - 24);
        if ((v21[32] & 5) == 0
          && ((*(void (**)(void **__return_ptr, _QWORD, _QWORD, uint64_t, uint64_t))(**((_QWORD **)v21 + 5)
                                                                                            + 32))(__p, *((_QWORD *)v21 + 5), 0, 1, 16), v45 > 1000)|| (++v17, HIDWORD(v22) = -1030792151 * v17 + 85899344, LODWORD(v22) = HIDWORD(v22), (v22 >> 1) < 0x51EB851))
        {
          v23 = *__error();
          v24 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
          {
            std::stringbuf::str();
            v25 = __p;
            if (v44 < 0)
              v25 = (void **)__p[0];
            *(_DWORD *)v41 = 136315138;
            v42 = v25;
            _os_log_impl(&dword_1B8270000, v24, OS_LOG_TYPE_DEFAULT, "%s", v41, 0xCu);
            if (SHIBYTE(v44) < 0)
              operator delete(__p[0]);
          }
          *__error() = v23;
          __p[0] = 0;
          __p[1] = 0;
          v44 = 0;
          std::stringbuf::str();
          if (SHIBYTE(v44) < 0)
            operator delete(__p[0]);
        }
        ++v18;
      }
      while (v18 != v15);
    }
  }
  v27 = (char *)&v48[-1] + *(_QWORD *)(v47 - 24);
  if ((v27[32] & 5) != 0)
  {
    v28 = a2;
  }
  else
  {
    (*(void (**)(void **__return_ptr, _QWORD, _QWORD, uint64_t, uint64_t))(**((_QWORD **)v27 + 5) + 32))(__p, *((_QWORD *)v27 + 5), 0, 1, 16);
    v28 = a2;
    if (v45 > 0)
    {
      v29 = *__error();
      v30 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        std::stringbuf::str();
        v31 = v44 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)v41 = 136315138;
        v42 = v31;
        _os_log_impl(&dword_1B8270000, v30, OS_LOG_TYPE_DEFAULT, "%s", v41, 0xCu);
        if (SHIBYTE(v44) < 0)
          operator delete(__p[0]);
      }
      *__error() = v29;
    }
  }
  if (v28)
  {
    v32 = *(void **)(v28 + 8);
    if (v32)
    {
      *(_QWORD *)(v28 + 16) = v32;
      operator delete(v32);
    }
    MEMORY[0x1BCCB06A4](v28, 0x1020C403EC25235);
  }
  if (v36)
    operator delete(v36);
  *(_QWORD *)&buf = *MEMORY[0x1E0DE4F50];
  v33 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 72);
  *(_QWORD *)((char *)&buf + *(_QWORD *)(buf - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 64);
  v47 = v33;
  v48[0] = MEMORY[0x1E0DE4FB8] + 16;
  if (SBYTE7(v50) < 0)
    operator delete((void *)v49);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1BCCB0650](&v52);
}

uint64_t IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::storageSize(uint64_t a1)
{
  os_unfair_lock_s *v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;

  v2 = (os_unfair_lock_s *)(a1 + 160);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 160));
  v3 = *(std::__shared_weak_count **)(a1 + 136);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  v7 = *(_QWORD *)(a1 + 144);
  v6 = *(std::__shared_weak_count **)(a1 + 152);
  if (v6)
  {
    v8 = (unint64_t *)&v6->__shared_owners_;
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  os_unfair_lock_unlock(v2);
  v10 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 32) + 48);
  v11 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 184))(v7);
  if (!v6)
    goto LABEL_11;
  v12 = (unint64_t *)&v6->__shared_owners_;
  do
    v13 = __ldaxr(v12);
  while (__stlxr(v13 - 1, v12));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
    if (!v3)
      return v11 + v10;
  }
  else
  {
LABEL_11:
    if (!v3)
      return v11 + v10;
  }
  v14 = (unint64_t *)&v3->__shared_owners_;
  do
    v15 = __ldaxr(v14);
  while (__stlxr(v15 - 1, v14));
  if (!v15)
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return v11 + v10;
}

uint64_t IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::setVectorStore(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 192) = a2;
  return result;
}

uint64_t IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::getDataForOffset(_QWORD *a1, uint64_t a2, int *a3)
{
  uint64_t result;
  int v7;
  int v8;
  NSObject *v9;
  int *v10;
  int v11;
  int v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  int v17;
  __int16 v18;
  int v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if ((*(unsigned int (**)(_QWORD *))(*a1 + 16))(a1) <= a2)
  {
    v8 = *__error();
    v9 = _SILogForLogForCategory(2);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v11 = (*(uint64_t (**)(_QWORD *))(*a1 + 16))(a1);
      v12 = 136315906;
      v13 = "getDataForOffset";
      v14 = 1024;
      v15 = 3455;
      v16 = 1024;
      v17 = a2;
      v18 = 1024;
      v19 = v11;
      _os_log_error_impl(&dword_1B8270000, v9, OS_LOG_TYPE_ERROR, "%s:%d: offset out of range: %u >= %u", (uint8_t *)&v12, 0x1Eu);
    }
    v10 = __error();
    v7 = 0;
    result = 0;
    *v10 = v8;
  }
  else
  {
    result = (*(uint64_t (**)(_QWORD *, uint64_t))(a1[6] + 32))(a1 + 6, a2);
    v7 = 3072;
  }
  *a3 = v7;
  return result;
}

uint64_t IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::updateVectorStorageOffsets(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;
  unint64_t i;
  uint64_t result;
  unint64_t v7;
  unint64_t v8;
  int v9;
  char v10;
  uint64_t v11;
  int v12;
  unint64_t j;
  unint64_t v14;

  v2 = a2;
  v4 = a1 + 48;
  if (a2)
  {
    for (i = 0; ; ++i)
    {
      result = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nVectors(v4);
      if (i >= result)
        break;
      v7 = _windowsResolvePtr(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 32) + 40, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 32) + 24)+ *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 32) + 16) * i, 0xC10uLL);
      if (!*(_BYTE *)(v2 + 184))
      {
        v8 = *(unsigned int *)(v7 + 3080);
        v9 = *(_DWORD *)(v2 + 24);
        if (!v9 || !((*(_QWORD *)(v2 + 16) ^ v8) >> (-4 * v9)))
        {
          v10 = (60 - 4 * v9) & 0xFC;
          v11 = *(_QWORD *)(v2 + 56 + 8 * ((v8 >> v10) & 0xF));
          if ((v11 & 1) != 0)
          {
            v12 = v9 + 2;
            do
            {
              v10 = (64 - 4 * v12) & 0xFC;
              v11 = *(_QWORD *)((v11 & 0xFFFFFFFFFFFFFFFELL) + 8 * ((v8 >> v10) & 0xF));
              ++v12;
            }
            while ((v11 & 1) != 0);
          }
          if (v11)
          {
            if ((*(unsigned int (**)(uint64_t, unint64_t, uint64_t))(*(_QWORD *)v11 + 16))(v11, v8, ~(-1 << v10)))
            {
              data_map_set_offset_for_id(*(_QWORD *)(a1 + 192), v8, ((unint64_t)*(unsigned int *)(a1 + 88) << 36) | (16 * i) | (4 * (*(_DWORD *)(a1 + 176) & 3)) | *(_DWORD *)(a1 + 172) & 3, *(unsigned __int16 *)(a1 + 168) | ((unint64_t)*(unsigned int *)(a1 + 180) << 32), *(_DWORD *)(a1 + 184));
            }
          }
        }
      }
    }
  }
  else
  {
    for (j = 0; ; ++j)
    {
      result = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nVectors(v4);
      if (j >= result)
        break;
      v14 = _windowsResolvePtr(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 32) + 40, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 32) + 24)+ *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 32) + 16) * j, 0xC10uLL);
      data_map_set_offset_for_id(*(_QWORD *)(a1 + 192), *(unsigned int *)(v14 + 3080), v2 | ((unint64_t)*(unsigned int *)(a1 + 88) << 36) | (4 * (*(_DWORD *)(a1 + 176) & 3)) | *(_DWORD *)(a1 + 172) & 3, *(unsigned __int16 *)(a1 + 168) | ((unint64_t)*(unsigned int *)(a1 + 180) << 32), *(_DWORD *)(a1 + 184));
      v2 += 16;
    }
  }
  return result;
}

uint64_t IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::status(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  std::ios_base *v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  _QWORD *v22;
  _QWORD *v23;
  std::__shared_weak_count *v24;
  unint64_t *p_shared_owners;
  unint64_t v26;
  _QWORD *v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  _QWORD *v31;
  uint64_t v32;
  uint64_t v34;
  std::__shared_weak_count *v35;
  uint64_t v36;
  std::__shared_weak_count *v37;
  _QWORD v38[2];
  uint64_t v39;
  _OWORD v40[4];
  void *__p[2];
  __int128 v42;
  uint64_t v43;
  uint64_t v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;

  v53 = 0u;
  v43 = 0;
  v52 = 0u;
  v51 = 0u;
  v50 = 0u;
  v49 = 0u;
  v48 = 0u;
  v47 = 0u;
  v46 = 0u;
  v45 = 0u;
  v42 = 0u;
  *(_OWORD *)__p = 0u;
  v4 = MEMORY[0x1E0DE4FD0];
  memset(v40, 0, sizeof(v40));
  v5 = MEMORY[0x1E0DE4FD0] + 104;
  v44 = MEMORY[0x1E0DE4FD0] + 104;
  v6 = (_QWORD *)MEMORY[0x1E0DE4F50];
  v7 = MEMORY[0x1E0DE4FD0] + 64;
  v8 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 16);
  v9 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 24);
  v39 = MEMORY[0x1E0DE4FD0] + 64;
  v38[0] = v8;
  *(_QWORD *)((char *)v38 + *(_QWORD *)(v8 - 24)) = v9;
  v38[1] = 0;
  v10 = (std::ios_base *)((char *)v38 + *(_QWORD *)(v38[0] - 24));
  std::ios_base::init(v10, v40);
  v10[1].__vftable = 0;
  v10[1].__fmtflags_ = -1;
  v11 = v6[5];
  v39 = v6[4];
  *(uint64_t *)((char *)&v39 + *(_QWORD *)(v39 - 24)) = v11;
  v38[0] = v6[1];
  *(_QWORD *)((char *)v38 + *(_QWORD *)(v38[0] - 24)) = v6[6];
  v44 = v5;
  v38[0] = v4 + 24;
  v39 = v7;
  std::streambuf::basic_streambuf();
  v12 = MEMORY[0x1E0DE4FB8];
  *(_QWORD *)&v40[0] = MEMORY[0x1E0DE4FB8] + 16;
  *(_OWORD *)__p = 0u;
  v42 = 0u;
  LODWORD(v43) = 24;
  v13 = *(char *)(a2 + 23);
  if (v13 >= 0)
    v14 = a2;
  else
    v14 = *(_QWORD *)a2;
  if (v13 >= 0)
    v15 = *(unsigned __int8 *)(a2 + 23);
  else
    v15 = *(_QWORD *)(a2 + 8);
  v16 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v39, v14, v15);
  v17 = *(char *)(a1 + 47);
  if (v17 >= 0)
    v18 = a1 + 24;
  else
    v18 = *(_QWORD *)(a1 + 24);
  if (v17 >= 0)
    v19 = *(unsigned __int8 *)(a1 + 47);
  else
    v19 = *(_QWORD *)(a1 + 32);
  v20 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v16, v18, v19);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v20, (uint64_t)"(", 1);
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  v21 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v21, (uint64_t)"/", 1);
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
  v22 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v22, (uint64_t)"v", 1);
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::getPartitions(a1 + 48, &v36);
  if (v36)
  {
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::getPartitions(a1 + 48, &v34);
    v23 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v23, (uint64_t)")", 1);
    v24 = v35;
    if (v35)
    {
      p_shared_owners = (unint64_t *)&v35->__shared_owners_;
      do
        v26 = __ldaxr(p_shared_owners);
      while (__stlxr(v26 - 1, p_shared_owners));
      if (!v26)
      {
        ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
        std::__shared_weak_count::__release_weak(v24);
      }
    }
  }
  else
  {
    v27 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v27, (uint64_t)")", 1);
  }
  v28 = v37;
  if (v37)
  {
    v29 = (unint64_t *)&v37->__shared_owners_;
    do
      v30 = __ldaxr(v29);
    while (__stlxr(v30 - 1, v29));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v39, (uint64_t)"[", 1);
  std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v39, (uint64_t)",", 1);
  v31 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v31, (uint64_t)"] indexId: ", 11);
  std::ostream::operator<<();
  std::stringbuf::str();
  v38[0] = *v6;
  v32 = v6[9];
  *(_QWORD *)((char *)v38 + *(_QWORD *)(v38[0] - 24)) = v6[8];
  v39 = v32;
  *(_QWORD *)&v40[0] = v12 + 16;
  if (SBYTE7(v42) < 0)
    operator delete(__p[0]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1BCCB0650](&v44);
}

uint64_t IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,768>::diagnoseDump(uint64_t a1, uint64_t a2, _QWORD *a3, int a4)
{
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  _QWORD *v16;
  const char *v17;
  uint64_t v18;
  _QWORD *v19;
  const std::locale::facet *v20;
  uint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *p_shared_owners;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  unint64_t *v28;
  unint64_t v29;
  unint64_t *v30;
  unint64_t v31;
  uint64_t v32;
  unint64_t *v33;
  unint64_t v34;
  _QWORD *v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  _QWORD *v39;
  _QWORD *v40;
  _QWORD *v41;
  _QWORD *v42;
  const std::locale::facet *v43;
  uint64_t v44;
  std::locale *v45;
  uint64_t v46;
  const std::locale::facet *v47;
  uint64_t v48;
  _QWORD *v49;
  const char *v50;
  uint64_t v51;
  const std::locale::facet *v52;
  unint64_t v53;
  std::locale::id *v54;
  const std::locale::facet *v55;
  unint64_t v56;
  _QWORD *v57;
  _QWORD *v58;
  _QWORD *v59;
  void *locale;
  uint64_t v61;
  void *v62;
  uint64_t v63;
  _QWORD *v64;
  unint64_t v65;
  std::locale::id *v66;
  _QWORD *v67;
  _QWORD *v68;
  const std::locale::facet *v69;
  const std::locale::facet *v70;
  uint64_t v71;
  std::__shared_weak_count *v72;
  unint64_t *v73;
  unint64_t v74;
  unint64_t *v75;
  unint64_t v76;
  uint64_t v78;
  unsigned int v79;
  uint64_t v80;
  std::__shared_weak_count *v81;
  std::locale v82;
  std::locale v83;
  uint64_t v84;
  unsigned __int8 v85;

  v7 = *(_QWORD *)(a2 + 8);
  if (*(char *)(a2 + 23) >= 0)
  {
    v8 = *(unsigned __int8 *)(a2 + 23);
  }
  else
  {
    a2 = *(_QWORD *)a2;
    v8 = v7;
  }
  v9 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, a2, v8);
  v10 = *(char *)(a1 + 47);
  if (v10 >= 0)
    v11 = a1 + 24;
  else
    v11 = *(_QWORD *)(a1 + 24);
  if (v10 >= 0)
    v12 = *(unsigned __int8 *)(a1 + 47);
  else
    v12 = *(_QWORD *)(a1 + 32);
  v13 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v9, v11, v12);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v13, (uint64_t)": ", 2);
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  v14 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v14, (uint64_t)" vectors ", 9);
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
  v15 = (_QWORD *)std::ostream::operator<<();
  v16 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v15, (uint64_t)" partitions.", 12);
  if (*(_BYTE *)(a1 + 208))
    v17 = "(readOnly)";
  else
    v17 = "(readWrite)";
  if (*(_BYTE *)(a1 + 208))
    v18 = 10;
  else
    v18 = 11;
  v19 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v16, (uint64_t)v17, v18);
  std::ios_base::getloc((const std::ios_base *)((char *)v19 + *(_QWORD *)(*v19 - 24)));
  v20 = std::locale::use_facet(&v83, MEMORY[0x1E0DE4A90]);
  ((void (*)(const std::locale::facet *, uint64_t))v20->__vftable[2].~facet_0)(v20, 10);
  std::locale::~locale(&v83);
  std::ostream::put();
  std::ostream::flush();
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 160));
  v21 = *(_QWORD *)(a1 + 128);
  v22 = *(std::__shared_weak_count **)(a1 + 136);
  if (v22)
  {
    p_shared_owners = (unint64_t *)&v22->__shared_owners_;
    do
      v24 = __ldxr(p_shared_owners);
    while (__stxr(v24 + 1, p_shared_owners));
  }
  v25 = *(std::__shared_weak_count **)(a1 + 152);
  if (v25)
  {
    v26 = (unint64_t *)&v25->__shared_owners_;
    do
      v27 = __ldxr(v26);
    while (__stxr(v27 + 1, v26));
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 160));
  if (v22)
  {
    v28 = (unint64_t *)&v22->__shared_owners_;
    do
      v29 = __ldxr(v28);
    while (__stxr(v29 + 1, v28));
  }
  if (!v25)
    goto LABEL_29;
  v30 = (unint64_t *)&v25->__shared_owners_;
  do
    v31 = __ldaxr(v30);
  while (__stlxr(v31 - 1, v30));
  if (!v31)
  {
    ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
    std::__shared_weak_count::__release_weak(v25);
    v32 = a1 + 48;
    if (!v22)
      goto LABEL_35;
  }
  else
  {
LABEL_29:
    v32 = a1 + 48;
    if (!v22)
      goto LABEL_35;
  }
  v33 = (unint64_t *)&v22->__shared_owners_;
  do
    v34 = __ldaxr(v33);
  while (__stlxr(v34 - 1, v33));
  if (!v34)
  {
    ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
    std::__shared_weak_count::__release_weak(v22);
  }
LABEL_35:
  if (v21)
  {
    v35 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, (uint64_t)"Quantizer: ", 11);
    v36 = *(char *)(v21 + 31);
    if (v36 >= 0)
      v37 = v21 + 8;
    else
      v37 = *(_QWORD *)(v21 + 8);
    if (v36 >= 0)
      v38 = *(unsigned __int8 *)(v21 + 31);
    else
      v38 = *(_QWORD *)(v21 + 16);
    v39 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v35, v37, v38);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v39, (uint64_t)"(", 1);
    (*(void (**)(uint64_t))(*(_QWORD *)v21 + 16))(v21);
    v40 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v40, (uint64_t)") ", 2);
    (*(void (**)(uint64_t))(*(_QWORD *)v21 + 24))(v21);
    v41 = (_QWORD *)std::ostream::operator<<();
    v42 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v41, (uint64_t)" centroids.", 11);
    std::ios_base::getloc((const std::ios_base *)((char *)v42 + *(_QWORD *)(*v42 - 24)));
    v43 = std::locale::use_facet(&v83, MEMORY[0x1E0DE4A90]);
    ((void (*)(const std::locale::facet *, uint64_t))v43->__vftable[2].~facet_0)(v43, 10);
    std::locale::~locale(&v83);
    std::ostream::put();
    std::ostream::flush();
  }
  v80 = 0;
  v81 = 0;
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::getPartitions(v32, &v80);
  v44 = v80;
  if (!v80)
    goto LABEL_51;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, (uint64_t)"Partition: ", 11);
  (*(void (**)(std::locale *__return_ptr, uint64_t))(*(_QWORD *)v44 + 144))(&v83, v44);
  v45 = (v85 & 0x80u) == 0 ? &v83 : (std::locale *)v83.__locale_;
  v46 = (v85 & 0x80u) == 0 ? v85 : v84;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, (uint64_t)v45, v46);
  std::ios_base::getloc((const std::ios_base *)((char *)a3 + *(_QWORD *)(*a3 - 24)));
  v47 = std::locale::use_facet(&v82, MEMORY[0x1E0DE4A90]);
  ((void (*)(const std::locale::facet *, uint64_t))v47->__vftable[2].~facet_0)(v47, 10);
  std::locale::~locale(&v82);
  std::ostream::put();
  std::ostream::flush();
  if ((char)v85 < 0)
  {
    operator delete(v83.__locale_);
    if (!a4)
      goto LABEL_84;
  }
  else
  {
LABEL_51:
    if (!a4)
      goto LABEL_84;
  }
  v78 = v44;
  v48 = *(_QWORD *)(a1 + 96);
  v49 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, (uint64_t)"offset,vid", 10);
  v79 = a4;
  if (a4 <= 1)
    v50 = ",";
  else
    v50 = ",vector";
  if (a4 <= 1)
    v51 = 1;
  else
    v51 = 7;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v49, (uint64_t)v50, v51);
  std::ios_base::getloc((const std::ios_base *)((char *)a3 + *(_QWORD *)(*a3 - 24)));
  v52 = std::locale::use_facet(&v83, MEMORY[0x1E0DE4A90]);
  ((void (*)(const std::locale::facet *, uint64_t))v52->__vftable[2].~facet_0)(v52, 10);
  std::locale::~locale(&v83);
  std::ostream::put();
  std::ostream::flush();
  if (*(_DWORD *)(v48 + 40))
  {
    if (a4 <= 1)
    {
      v65 = 0;
      v66 = (std::locale::id *)MEMORY[0x1E0DE4A90];
      do
      {
        _windowsResolvePtr(*(_QWORD *)(v48 + 32) + 40, *(_QWORD *)(*(_QWORD *)(v48 + 32) + 24) + *(_QWORD *)(*(_QWORD *)(v48 + 32) + 16) * v65, 0xC10uLL);
        v67 = (_QWORD *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v67, (uint64_t)",", 1);
        v68 = (_QWORD *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v68, (uint64_t)",", 1);
        std::ios_base::getloc((const std::ios_base *)((char *)a3 + *(_QWORD *)(*a3 - 24)));
        v69 = std::locale::use_facet(&v83, v66);
        ((void (*)(const std::locale::facet *, uint64_t))v69->__vftable[2].~facet_0)(v69, 10);
        std::locale::~locale(&v83);
        std::ostream::put();
        std::ostream::flush();
        ++v65;
      }
      while (v65 < *(unsigned int *)(v48 + 40));
    }
    else
    {
      v53 = 0;
      v54 = (std::locale::id *)MEMORY[0x1E0DE4A90];
      do
      {
        v56 = _windowsResolvePtr(*(_QWORD *)(v48 + 32) + 40, *(_QWORD *)(*(_QWORD *)(v48 + 32) + 24) + *(_QWORD *)(*(_QWORD *)(v48 + 32) + 16) * v53, 0xC10uLL);
        v57 = (_QWORD *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v57, (uint64_t)",", 1);
        v58 = (_QWORD *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v58, (uint64_t)",", 1);
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, (uint64_t)"{length = ", 10);
        v59 = (_QWORD *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v59, (uint64_t)", bytes = 0x", 12);
        data2hexString((const unsigned __int8 *)&v83, v56, 16);
        if ((v85 & 0x80u) == 0)
          locale = &v83;
        else
          locale = v83.__locale_;
        if ((v85 & 0x80u) == 0)
          v61 = v85;
        else
          v61 = v84;
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v59, (uint64_t)locale, v61);
        if ((char)v85 < 0)
          operator delete(v83.__locale_);
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, (uint64_t)" ... ", 5);
        data2hexString((const unsigned __int8 *)&v83, v56 + 3064, 8);
        if ((v85 & 0x80u) == 0)
          v62 = &v83;
        else
          v62 = v83.__locale_;
        if ((v85 & 0x80u) == 0)
          v63 = v85;
        else
          v63 = v84;
        v64 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, (uint64_t)v62, v63);
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v64, (uint64_t)" }", 2);
        if ((char)v85 < 0)
          operator delete(v83.__locale_);
        std::ios_base::getloc((const std::ios_base *)((char *)a3 + *(_QWORD *)(*a3 - 24)));
        v55 = std::locale::use_facet(&v83, v54);
        ((void (*)(const std::locale::facet *, uint64_t))v55->__vftable[2].~facet_0)(v55, 10);
        std::locale::~locale(&v83);
        std::ostream::put();
        std::ostream::flush();
        ++v53;
      }
      while (v53 < *(unsigned int *)(v48 + 40));
    }
  }
  std::ios_base::getloc((const std::ios_base *)((char *)a3 + *(_QWORD *)(*a3 - 24)));
  v70 = std::locale::use_facet(&v83, MEMORY[0x1E0DE4A90]);
  ((void (*)(const std::locale::facet *, uint64_t))v70->__vftable[2].~facet_0)(v70, 10);
  std::locale::~locale(&v83);
  std::ostream::put();
  std::ostream::flush();
  if (v78)
    (*(void (**)(uint64_t, _QWORD *, _QWORD))(*(_QWORD *)v78 + 104))(v78, a3, v79);
LABEL_84:
  v71 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  v72 = v81;
  if (!v81)
    goto LABEL_88;
  v73 = (unint64_t *)&v81->__shared_owners_;
  do
    v74 = __ldaxr(v73);
  while (__stlxr(v74 - 1, v73));
  if (!v74)
  {
    ((void (*)(std::__shared_weak_count *))v72->__on_zero_shared)(v72);
    std::__shared_weak_count::__release_weak(v72);
    if (!v22)
      return v71;
  }
  else
  {
LABEL_88:
    if (!v22)
      return v71;
  }
  v75 = (unint64_t *)&v22->__shared_owners_;
  do
    v76 = __ldaxr(v75);
  while (__stlxr(v76 - 1, v75));
  if (!v76)
  {
    ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
    std::__shared_weak_count::__release_weak(v22);
  }
  return v71;
}

uint64_t data2hexString(const unsigned __int8 *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  std::ios_base *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const std::ios_base *v14;
  const std::locale::facet *v15;
  uint64_t v16;
  uint64_t v18;
  _QWORD v19[2];
  uint64_t v20;
  __int128 v21;
  _OWORD v22[3];
  void *__p[2];
  __int128 v24;
  uint64_t v25;
  uint64_t v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  std::locale v36;

  v35 = 0u;
  v24 = 0u;
  v25 = 0;
  v34 = 0u;
  v33 = 0u;
  v32 = 0u;
  v31 = 0u;
  v30 = 0u;
  v29 = 0u;
  v28 = 0u;
  v27 = 0u;
  *(_OWORD *)__p = 0u;
  memset(v22, 0, sizeof(v22));
  v21 = 0u;
  v4 = MEMORY[0x1E0DE4FD0];
  v5 = MEMORY[0x1E0DE4FD0] + 104;
  v26 = MEMORY[0x1E0DE4FD0] + 104;
  v6 = (_QWORD *)MEMORY[0x1E0DE4F50];
  v7 = MEMORY[0x1E0DE4FD0] + 64;
  v8 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 16);
  v9 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 24);
  v20 = MEMORY[0x1E0DE4FD0] + 64;
  v19[0] = v8;
  *(_QWORD *)((char *)v19 + *(_QWORD *)(v8 - 24)) = v9;
  v19[1] = 0;
  v10 = (std::ios_base *)((char *)v19 + *(_QWORD *)(v19[0] - 24));
  std::ios_base::init(v10, &v21);
  v10[1].__vftable = 0;
  v10[1].__fmtflags_ = -1;
  v11 = v6[5];
  v20 = v6[4];
  *(uint64_t *)((char *)&v20 + *(_QWORD *)(v20 - 24)) = v11;
  v19[0] = v6[1];
  *(_QWORD *)((char *)v19 + *(_QWORD *)(v19[0] - 24)) = v6[6];
  v26 = v5;
  v19[0] = v4 + 24;
  v20 = v7;
  std::streambuf::basic_streambuf();
  v18 = MEMORY[0x1E0DE4FB8] + 16;
  *(_QWORD *)&v21 = MEMORY[0x1E0DE4FB8] + 16;
  *(_OWORD *)__p = 0u;
  v24 = 0u;
  LODWORD(v25) = 24;
  *(_DWORD *)((char *)&v20 + *(_QWORD *)(v20 - 24) + 8) = *(_DWORD *)((_BYTE *)&v20 + *(_QWORD *)(v20 - 24) + 8) & 0xFFFFFFB5 | 8;
  if (a3 >= 1)
  {
    v12 = 0;
    do
    {
      v13 = v20;
      *(_QWORD *)((char *)v22 + *(_QWORD *)(v20 - 24)) = 2;
      v14 = (const std::ios_base *)((char *)&v20 + *(_QWORD *)(v13 - 24));
      if (v14[1].__fmtflags_ == -1)
      {
        std::ios_base::getloc(v14);
        v15 = std::locale::use_facet(&v36, MEMORY[0x1E0DE4A90]);
        ((void (*)(const std::locale::facet *, uint64_t))v15->__vftable[2].~facet_0)(v15, 32);
        std::locale::~locale(&v36);
      }
      v14[1].__fmtflags_ = 48;
      std::ostream::operator<<();
      if ((~(_BYTE)v12 & 3) == 0 && a3 - 1 != v12)
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v20, (uint64_t)" ", 1);
      ++v12;
    }
    while (a3 != v12);
  }
  std::stringbuf::str();
  v19[0] = *MEMORY[0x1E0DE4F50];
  v16 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 72);
  *(_QWORD *)((char *)v19 + *(_QWORD *)(v19[0] - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 64);
  v20 = v16;
  *(_QWORD *)&v21 = v18;
  if (SBYTE7(v24) < 0)
    operator delete(__p[0]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1BCCB0650](&v26);
}

uint64_t IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nVectors(uint64_t a1)
{
  os_unfair_lock_s *v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  char *v15;
  char *v16;
  const char *v17;

  v2 = (os_unfair_lock_s *)(a1 + 112);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 112));
  v3 = *(std::__shared_weak_count **)(a1 + 88);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  v7 = *(_QWORD *)(a1 + 96);
  v6 = *(std::__shared_weak_count **)(a1 + 104);
  if (!v6)
  {
    os_unfair_lock_unlock(v2);
    if (v7)
    {
      v10 = *(unsigned int *)(v7 + 72);
      goto LABEL_14;
    }
LABEL_20:
    v15 = __si_assert_copy_extra_268();
    v16 = v15;
    v17 = "";
    if (v15)
      v17 = v15;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2312, "cur.partitions != nullptr", v17);
    free(v16);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v8 = (unint64_t *)&v6->__shared_owners_;
  do
    v9 = __ldxr(v8);
  while (__stxr(v9 + 1, v8));
  os_unfair_lock_unlock(v2);
  if (!v7)
    goto LABEL_20;
  v10 = *(unsigned int *)(v7 + 72);
  do
    v11 = __ldaxr(v8);
  while (__stlxr(v11 - 1, v8));
  if (!v11)
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
LABEL_14:
  if (v3)
  {
    v12 = (unint64_t *)&v3->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  return v10;
}

__int128 **MaxSizePriorityQueue<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>,std::vector<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>,std::allocator<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>>>,std::less<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>>>::allItems(__int128 **result, _BYTE *a2, _BYTE *a3)
{
  int64_t v3;
  __int128 **v5;
  __int128 *v6;
  char *v7;
  uint64_t v8;
  uint64_t v10;
  char *v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  float v17;
  char *v18;
  __int128 v19;
  uint64_t v20;
  int v21;

  *result = 0;
  result[1] = 0;
  result[2] = 0;
  v3 = a3 - a2;
  if (a3 == a2)
  {
    v7 = 0;
    v6 = 0;
  }
  else
  {
    if (v3 < 0)
      abort();
    v5 = result;
    v6 = (__int128 *)operator new(a3 - a2);
    *v5 = v6;
    v7 = (char *)&v6[v3 >> 4];
    v5[2] = (__int128 *)v7;
    result = (__int128 **)memcpy(v6, a2, v3);
    v5[1] = (__int128 *)v7;
  }
  if (v7 - (char *)v6 >= 17)
  {
    v8 = (unint64_t)(v7 - (char *)v6) >> 4;
    do
    {
      v10 = 0;
      v19 = *v6;
      v11 = (char *)v6;
      do
      {
        v12 = v11;
        v11 += 16 * v10 + 16;
        v13 = 2 * v10;
        v10 = (2 * v10) | 1;
        v14 = v13 + 2;
        if (v14 < v8 && *((float *)v11 + 3) < *((float *)v11 + 7))
        {
          v11 += 16;
          v10 = v14;
        }
        *(_OWORD *)v12 = *(_OWORD *)v11;
      }
      while (v10 <= (uint64_t)((unint64_t)(v8 - 2) >> 1));
      v7 -= 16;
      if (v11 == v7)
      {
        *(_OWORD *)v11 = v19;
      }
      else
      {
        *(_OWORD *)v11 = *(_OWORD *)v7;
        *(_OWORD *)v7 = v19;
        v15 = v11 - (char *)v6 + 16;
        if (v15 >= 17)
        {
          v16 = (((unint64_t)v15 >> 4) - 2) >> 1;
          v17 = *((float *)v11 + 3);
          if (*((float *)&v6[v16] + 3) < v17)
          {
            v21 = *((_DWORD *)v11 + 2);
            v20 = *(_QWORD *)v11;
            do
            {
              v18 = v11;
              v11 = (char *)&v6[v16];
              *(_OWORD *)v18 = *(_OWORD *)v11;
              if (!v16)
                break;
              v16 = (v16 - 1) >> 1;
            }
            while (*((float *)&v6[v16] + 3) < v17);
            *(_QWORD *)v11 = v20;
            *((_DWORD *)v11 + 2) = v21;
            *((float *)v11 + 3) = v17;
          }
        }
      }
    }
    while (v8-- > 2);
  }
  return result;
}

uint64_t IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::aNNForTestProcessResult(uint64_t a1, uint64_t a2)
{
  int v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  std::ios_base *v12;
  uint64_t v13;
  __int128 *v14;
  BOOL v15;
  int v16;
  __int128 *v17;
  _QWORD *v18;
  _QWORD *v19;
  char *v20;
  unint64_t v21;
  int v22;
  NSObject *v23;
  void **v24;
  __int128 *v25;
  char *v26;
  uint64_t v27;
  int v28;
  NSObject *v29;
  void **v30;
  void *v31;
  uint64_t v32;
  int v34;
  __int128 *v35;
  CFIndex AppIntegerValue;
  __int128 *v37;
  __int128 *v38;
  uint64_t v39;
  uint8_t v40[4];
  void **v41;
  void *__p[2];
  uint64_t v43;
  uint64_t v44;
  __int128 buf;
  uint64_t v46;
  _QWORD v47[8];
  __int128 v48;
  __int128 v49;
  uint64_t v50;
  uint64_t v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  uint64_t v61;

  v61 = *MEMORY[0x1E0C80C00];
  v4 = *__error();
  v5 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v6 = (uint64_t)(*(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8)) >> 4;
    LODWORD(buf) = 134217984;
    *(_QWORD *)((char *)&buf + 4) = v6;
    _os_log_impl(&dword_1B8270000, v5, OS_LOG_TYPE_DEFAULT, "search return %zu results", (uint8_t *)&buf, 0xCu);
  }
  *__error() = v4;
  LOBYTE(buf) = 0;
  AppIntegerValue = CFPreferencesGetAppIntegerValue(CFSTR("IVFANNLogQueryResult"), CFSTR("com.apple.Spotlight"), (Boolean *)&buf);
  v34 = buf;
  v60 = 0u;
  v50 = 0;
  v59 = 0u;
  v58 = 0u;
  v57 = 0u;
  v56 = 0u;
  v55 = 0u;
  v54 = 0u;
  v53 = 0u;
  v52 = 0u;
  v49 = 0u;
  v48 = 0u;
  memset(v47, 0, sizeof(v47));
  v7 = MEMORY[0x1E0DE4FD0] + 104;
  v51 = MEMORY[0x1E0DE4FD0] + 104;
  v8 = (_QWORD *)MEMORY[0x1E0DE4F50];
  v9 = MEMORY[0x1E0DE4FD0] + 64;
  v10 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 16);
  v11 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 24);
  v46 = MEMORY[0x1E0DE4FD0] + 64;
  *(_QWORD *)&buf = v10;
  *(_QWORD *)((char *)&buf + *(_QWORD *)(v10 - 24)) = v11;
  *((_QWORD *)&buf + 1) = 0;
  v12 = (std::ios_base *)((char *)&buf + *(_QWORD *)(buf - 24));
  std::ios_base::init(v12, v47);
  v12[1].__vftable = 0;
  v12[1].__fmtflags_ = -1;
  v13 = v8[5];
  v46 = v8[4];
  *(_QWORD *)((char *)&v47[-1] + *(_QWORD *)(v46 - 24)) = v13;
  *(_QWORD *)&buf = v8[1];
  *(_QWORD *)((char *)&buf + *(_QWORD *)(buf - 24)) = v8[6];
  v51 = v7;
  *(_QWORD *)&buf = MEMORY[0x1E0DE4FD0] + 24;
  v46 = v9;
  std::streambuf::basic_streambuf();
  v47[0] = MEMORY[0x1E0DE4FB8] + 16;
  v48 = 0u;
  v49 = 0u;
  LODWORD(v50) = 24;
  v37 = 0;
  v38 = 0;
  v39 = 0;
  MaxSizePriorityQueue<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>,std::vector<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>,std::allocator<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>>>,std::less<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>>>::allItems(&v37, *(_BYTE **)(a1 + 8), *(_BYTE **)(a1 + 16));
  v14 = v38;
  v35 = v37;
  if (v37 != v38)
  {
    if (AppIntegerValue)
      v15 = v34 == 0;
    else
      v15 = 1;
    if (v15)
    {
      v25 = v37;
      do
      {
        (*(void (**)(uint64_t, _QWORD, float))(a2 + 16))(a2, *(unsigned int *)v25, *((float *)v25 + 3));
        ++v25;
      }
      while (v25 != v14);
    }
    else
    {
      v16 = 0;
      v17 = v37;
      do
      {
        (*(void (**)(uint64_t, _QWORD, float))(a2 + 16))(a2, *(unsigned int *)v17, *((float *)v17 + 3));
        v18 = (_QWORD *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v18, (uint64_t)",", 1);
        v19 = (_QWORD *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v19, (uint64_t)";", 1);
        v20 = (char *)&v47[-1] + *(_QWORD *)(v46 - 24);
        if ((v20[32] & 5) == 0
          && ((*(void (**)(void **__return_ptr, _QWORD, _QWORD, uint64_t, uint64_t))(**((_QWORD **)v20 + 5)
                                                                                            + 32))(__p, *((_QWORD *)v20 + 5), 0, 1, 16), v44 > 1000)|| (++v16, HIDWORD(v21) = -1030792151 * v16 + 85899344, LODWORD(v21) = HIDWORD(v21), (v21 >> 1) < 0x51EB851))
        {
          v22 = *__error();
          v23 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
          {
            std::stringbuf::str();
            v24 = __p;
            if (v43 < 0)
              v24 = (void **)__p[0];
            *(_DWORD *)v40 = 136315138;
            v41 = v24;
            _os_log_impl(&dword_1B8270000, v23, OS_LOG_TYPE_DEFAULT, "%s", v40, 0xCu);
            if (SHIBYTE(v43) < 0)
              operator delete(__p[0]);
          }
          *__error() = v22;
          __p[0] = 0;
          __p[1] = 0;
          v43 = 0;
          std::stringbuf::str();
          if (SHIBYTE(v43) < 0)
            operator delete(__p[0]);
        }
        ++v17;
      }
      while (v17 != v14);
    }
  }
  v26 = (char *)&v47[-1] + *(_QWORD *)(v46 - 24);
  if ((v26[32] & 5) != 0)
  {
    v27 = a1;
  }
  else
  {
    (*(void (**)(void **__return_ptr, _QWORD, _QWORD, uint64_t, uint64_t))(**((_QWORD **)v26 + 5) + 32))(__p, *((_QWORD *)v26 + 5), 0, 1, 16);
    v27 = a1;
    if (v44 > 0)
    {
      v28 = *__error();
      v29 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      {
        std::stringbuf::str();
        v30 = v43 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)v40 = 136315138;
        v41 = v30;
        _os_log_impl(&dword_1B8270000, v29, OS_LOG_TYPE_DEFAULT, "%s", v40, 0xCu);
        if (SHIBYTE(v43) < 0)
          operator delete(__p[0]);
      }
      *__error() = v28;
    }
  }
  if (v27)
  {
    v31 = *(void **)(v27 + 8);
    if (v31)
    {
      *(_QWORD *)(v27 + 16) = v31;
      operator delete(v31);
    }
    MEMORY[0x1BCCB06A4](v27, 0x1020C403EC25235);
  }
  if (v35)
    operator delete(v35);
  *(_QWORD *)&buf = *MEMORY[0x1E0DE4F50];
  v32 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 72);
  *(_QWORD *)((char *)&buf + *(_QWORD *)(buf - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 64);
  v46 = v32;
  v47[0] = MEMORY[0x1E0DE4FB8] + 16;
  if (SBYTE7(v49) < 0)
    operator delete((void *)v48);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1BCCB0650](&v51);
}

uint64_t ___ZNK16IVFVectorIndexenI30vi_onefixedsize_disk_allocator16vi_disk_postingsE22IVFVectorIndexInstanceIfLi768EE16aNNProcessResultEPvU13block_pointerFvS5_fE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::aNNProcessResult(uint64_t a1, uint64_t a2)
{
  int v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  std::ios_base *v12;
  uint64_t v13;
  __int128 *v14;
  BOOL v15;
  int v16;
  __int128 *v17;
  _QWORD *v18;
  _QWORD *v19;
  char *v20;
  unint64_t v21;
  int v22;
  NSObject *v23;
  void **v24;
  __int128 *v25;
  char *v26;
  uint64_t v27;
  int v28;
  NSObject *v29;
  void **v30;
  void *v31;
  uint64_t v32;
  int v34;
  __int128 *v35;
  CFIndex AppIntegerValue;
  uint64_t v37;
  __int128 *v38;
  __int128 *v39;
  uint64_t v40;
  uint8_t v41[4];
  void **v42;
  void *__p[2];
  uint64_t v44;
  uint64_t v45;
  __int128 buf;
  uint64_t v47;
  _QWORD v48[8];
  __int128 v49;
  __int128 v50;
  uint64_t v51;
  uint64_t v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  uint64_t v62;

  v62 = *MEMORY[0x1E0C80C00];
  v4 = *__error();
  v5 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v6 = (uint64_t)(*(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8)) >> 4;
    LODWORD(buf) = 134217984;
    *(_QWORD *)((char *)&buf + 4) = v6;
    _os_log_impl(&dword_1B8270000, v5, OS_LOG_TYPE_DEFAULT, "search return %zu results", (uint8_t *)&buf, 0xCu);
  }
  *__error() = v4;
  LOBYTE(buf) = 0;
  AppIntegerValue = CFPreferencesGetAppIntegerValue(CFSTR("IVFANNLogQueryResult"), CFSTR("com.apple.Spotlight"), (Boolean *)&buf);
  v34 = buf;
  v61 = 0u;
  v51 = 0;
  v60 = 0u;
  v59 = 0u;
  v58 = 0u;
  v57 = 0u;
  v56 = 0u;
  v55 = 0u;
  v54 = 0u;
  v53 = 0u;
  v50 = 0u;
  v49 = 0u;
  memset(v48, 0, sizeof(v48));
  v7 = MEMORY[0x1E0DE4FD0] + 104;
  v52 = MEMORY[0x1E0DE4FD0] + 104;
  v8 = (_QWORD *)MEMORY[0x1E0DE4F50];
  v9 = MEMORY[0x1E0DE4FD0] + 64;
  v10 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 16);
  v11 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 24);
  v47 = MEMORY[0x1E0DE4FD0] + 64;
  *(_QWORD *)&buf = v10;
  *(_QWORD *)((char *)&buf + *(_QWORD *)(v10 - 24)) = v11;
  *((_QWORD *)&buf + 1) = 0;
  v12 = (std::ios_base *)((char *)&buf + *(_QWORD *)(buf - 24));
  std::ios_base::init(v12, v48);
  v12[1].__vftable = 0;
  v12[1].__fmtflags_ = -1;
  v13 = v8[5];
  v47 = v8[4];
  *(_QWORD *)((char *)&v48[-1] + *(_QWORD *)(v47 - 24)) = v13;
  *(_QWORD *)&buf = v8[1];
  *(_QWORD *)((char *)&buf + *(_QWORD *)(buf - 24)) = v8[6];
  v52 = v7;
  *(_QWORD *)&buf = MEMORY[0x1E0DE4FD0] + 24;
  v47 = v9;
  std::streambuf::basic_streambuf();
  v48[0] = MEMORY[0x1E0DE4FB8] + 16;
  v49 = 0u;
  v50 = 0u;
  LODWORD(v51) = 24;
  v38 = 0;
  v39 = 0;
  v40 = 0;
  MaxSizePriorityQueue<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>,std::vector<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>,std::allocator<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>>>,std::less<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>>>::allItems(&v38, *(_BYTE **)(a1 + 8), *(_BYTE **)(a1 + 16));
  v14 = v39;
  v35 = v38;
  if (v38 != v39)
  {
    if (AppIntegerValue)
      v15 = v34 == 0;
    else
      v15 = 1;
    if (v15)
    {
      v25 = v38;
      do
      {
        v37 = *(_QWORD *)v25;
        (*(void (**)(uint64_t, uint64_t *, float))(a2 + 16))(a2, &v37, *((float *)v25++ + 3));
      }
      while (v25 != v14);
    }
    else
    {
      v16 = 0;
      v17 = v38;
      do
      {
        v37 = *(_QWORD *)v17;
        (*(void (**)(uint64_t, uint64_t *, float))(a2 + 16))(a2, &v37, *((float *)v17 + 3));
        v18 = (_QWORD *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v18, (uint64_t)",", 1);
        v19 = (_QWORD *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v19, (uint64_t)";", 1);
        v20 = (char *)&v48[-1] + *(_QWORD *)(v47 - 24);
        if ((v20[32] & 5) == 0
          && ((*(void (**)(void **__return_ptr, _QWORD, _QWORD, uint64_t, uint64_t))(**((_QWORD **)v20 + 5)
                                                                                            + 32))(__p, *((_QWORD *)v20 + 5), 0, 1, 16), v45 > 1000)|| (++v16, HIDWORD(v21) = -1030792151 * v16 + 85899344, LODWORD(v21) = HIDWORD(v21), (v21 >> 1) < 0x51EB851))
        {
          v22 = *__error();
          v23 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
          {
            std::stringbuf::str();
            v24 = __p;
            if (v44 < 0)
              v24 = (void **)__p[0];
            *(_DWORD *)v41 = 136315138;
            v42 = v24;
            _os_log_impl(&dword_1B8270000, v23, OS_LOG_TYPE_DEFAULT, "%s", v41, 0xCu);
            if (SHIBYTE(v44) < 0)
              operator delete(__p[0]);
          }
          *__error() = v22;
          __p[0] = 0;
          __p[1] = 0;
          v44 = 0;
          std::stringbuf::str();
          if (SHIBYTE(v44) < 0)
            operator delete(__p[0]);
        }
        ++v17;
      }
      while (v17 != v14);
    }
  }
  v26 = (char *)&v48[-1] + *(_QWORD *)(v47 - 24);
  if ((v26[32] & 5) != 0)
  {
    v27 = a1;
  }
  else
  {
    (*(void (**)(void **__return_ptr, _QWORD, _QWORD, uint64_t, uint64_t))(**((_QWORD **)v26 + 5) + 32))(__p, *((_QWORD *)v26 + 5), 0, 1, 16);
    v27 = a1;
    if (v45 > 0)
    {
      v28 = *__error();
      v29 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      {
        std::stringbuf::str();
        v30 = v44 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)v41 = 136315138;
        v42 = v30;
        _os_log_impl(&dword_1B8270000, v29, OS_LOG_TYPE_DEFAULT, "%s", v41, 0xCu);
        if (SHIBYTE(v44) < 0)
          operator delete(__p[0]);
      }
      *__error() = v28;
    }
  }
  if (v27)
  {
    v31 = *(void **)(v27 + 8);
    if (v31)
    {
      *(_QWORD *)(v27 + 16) = v31;
      operator delete(v31);
    }
    MEMORY[0x1BCCB06A4](v27, 0x1020C403EC25235);
  }
  if (v35)
    operator delete(v35);
  *(_QWORD *)&buf = *MEMORY[0x1E0DE4F50];
  v32 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 72);
  *(_QWORD *)((char *)&buf + *(_QWORD *)(buf - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 64);
  v47 = v32;
  v48[0] = MEMORY[0x1E0DE4FB8] + 16;
  if (SBYTE7(v50) < 0)
    operator delete((void *)v49);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1BCCB0650](&v52);
}

void IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::aNN(uint64_t a1, unsigned __int8 *a2, char a3, _QWORD *a4, CFIndex AppIntegerValue, float a6)
{
  int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  double Current;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  unsigned int v30;
  int v31;
  char v32;
  int v33;
  char v34;
  unsigned int v35;
  char v36;
  unsigned int v37;
  int v38;
  int v39;
  int v40;
  unsigned int v41;
  int v42;
  NSObject *v43;
  int v44;
  int v45;
  uint64_t v46;
  std::__shared_weak_count *v47;
  unint64_t *p_shared_owners;
  unint64_t v49;
  std::__shared_weak_count *v50;
  uint64_t v51;
  unint64_t *v52;
  unint64_t v53;
  int *v54;
  int *v55;
  int v56;
  int v57;
  void *v58;
  int64_t v59;
  char *v60;
  char *v61;
  int v62;
  NSObject *v63;
  int v64;
  int v65;
  double v66;
  uint64_t v67;
  int v68;
  uint64_t v69;
  unint64_t v70;
  unint64_t v71;
  uint8x8_t v72;
  unint64_t v73;
  uint64_t *v74;
  unint64_t v75;
  uint64_t v76;
  float v77;
  int v79;
  NSObject *v80;
  int v81;
  NSObject *v82;
  int v83;
  int v84;
  NSObject *v85;
  int v86;
  int v87;
  int v88;
  int v89;
  uint64_t v90;
  CFAbsoluteTime v91;
  _QWORD *v92;
  _QWORD *v93;
  void *v94;
  _QWORD *v95;
  _QWORD *v96;
  void *v97;
  unint64_t *v98;
  unint64_t v99;
  unint64_t *v100;
  unint64_t v101;
  char *v102;
  char *v103;
  const char *v104;
  char *v105;
  const char *v106;
  uint64_t v107;
  int v108;
  unint64_t v109;
  unsigned int lock;
  _QWORD v112[8];
  void *v113;
  void *v114;
  _QWORD *v115;
  float v116;
  void *v117;
  void *v118;
  char *v119;
  void *v120;
  _BYTE *v121;
  uint64_t v122;
  __int128 v123;
  __int128 __p;
  uint64_t v125;
  uint64_t v126;
  uint64_t *v127;
  uint64_t v128;
  int v129;
  uint64_t v130;
  uint64_t *v131;
  uint64_t v132;
  int v133;
  void **v134;
  _BYTE keyExistsAndHasValidFormat[46];
  __int16 v136;
  int v137;
  __int16 v138;
  int v139;
  __int16 v140;
  uint64_t v141;
  __int16 v142;
  CFAbsoluteTime v143;
  _OWORD __str[2];
  uint64_t v145;

  v145 = *MEMORY[0x1E0C80C00];
  v11 = *(_DWORD *)a4;
  memset(__str, 0, sizeof(__str));
  snprintf((char *)__str, 0x20uLL, "%02x%02x%02x%02x...%02x%02x%02x%02x", *a2, a2[1], a2[2], a2[3], a2[3068], a2[3069], a2[3070], a2[3071]);
  if (!(_DWORD)AppIntegerValue)
    AppIntegerValue = CFPreferencesGetAppIntegerValue(CFSTR("IVFNumberOfParitionsProbe"), CFSTR("com.apple.Spotlight"), 0);
  keyExistsAndHasValidFormat[0] = 0;
  v12 = CFPreferencesGetAppIntegerValue(CFSTR("IVFPartitionProbeMin"), CFSTR("com.apple.Spotlight"), keyExistsAndHasValidFormat);
  if (keyExistsAndHasValidFormat[0])
    v13 = v12;
  else
    v13 = 10000;
  if (10 * v11 <= v13)
    v14 = v13;
  else
    v14 = 10 * v11;
  v15 = v14
      * IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nPartitions(a1);
  v16 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nVectors(a1);
  keyExistsAndHasValidFormat[0] = 0;
  v17 = v15 / v16;
  v18 = CFPreferencesGetAppIntegerValue(CFSTR("IVFPartitionProbeMin"), CFSTR("com.apple.Spotlight"), keyExistsAndHasValidFormat);
  if (keyExistsAndHasValidFormat[0])
    v19 = v18;
  else
    v19 = 7;
  v130 = 0;
  v131 = &v130;
  if (v17 <= v19)
    v20 = v19;
  else
    v20 = v17;
  v133 = 0;
  v132 = 0x2000000000;
  v126 = 0;
  v127 = &v126;
  v129 = 0;
  v128 = 0x2000000000;
  v125 = 0;
  v123 = 0u;
  __p = 0u;
  QuantizerManager<float,768>::aNNLogQueryVecIds((uint64_t)&v123);
  Current = CFAbsoluteTimeGetCurrent();
  if ((a3 & 1) != 0
    || IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nPartitions(a1) <= v20
    || IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nVectors(a1) <= v14)
  {
    v62 = *__error();
    v63 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
    {
      v64 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nVectors(a1);
      v65 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nPartitions(a1);
      v66 = a6;
      *(_DWORD *)keyExistsAndHasValidFormat = 136316162;
      *(_QWORD *)&keyExistsAndHasValidFormat[4] = __str;
      *(_WORD *)&keyExistsAndHasValidFormat[12] = 1024;
      *(_DWORD *)&keyExistsAndHasValidFormat[14] = v11;
      *(_WORD *)&keyExistsAndHasValidFormat[18] = 1024;
      *(_DWORD *)&keyExistsAndHasValidFormat[20] = v64;
      *(_WORD *)&keyExistsAndHasValidFormat[24] = 1024;
      *(_DWORD *)&keyExistsAndHasValidFormat[26] = v65;
      *(_WORD *)&keyExistsAndHasValidFormat[30] = 2048;
      *(double *)&keyExistsAndHasValidFormat[32] = a6;
      _os_log_impl(&dword_1B8270000, v63, OS_LOG_TYPE_DEFAULT, "brute force search %s top %u of %u vectors in %u partitions max_distance=%f", keyExistsAndHasValidFormat, 0x28u);
    }
    else
    {
      v66 = a6;
    }
    *__error() = v62;
    v108 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nPartitions(a1);
    v67 = 0;
    v68 = 0;
    v69 = *(_QWORD *)(a1 + 48);
    while (v68 != *(_DWORD *)(v69 + 40))
    {
      ++*((_DWORD *)v131 + 6);
      if (*(_DWORD *)(v69 + 40) <= v67)
      {
        v102 = __si_assert_copy_extra_268();
        v103 = v102;
        v104 = "";
        if (v102)
          v104 = v102;
        __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1798, "offset < store->endOffset()", v104);
LABEL_133:
        free(v103);
        if (__valid_fs(-1))
          v107 = 2989;
        else
          v107 = 3072;
        *(_DWORD *)v107 = -559038737;
        abort();
      }
      v70 = _windowsResolvePtr(*(_QWORD *)(v69 + 32) + 40, *(_QWORD *)(*(_QWORD *)(v69 + 32) + 24) + *(_QWORD *)(*(_QWORD *)(v69 + 32) + 16) * v67, 0xC10uLL);
      v71 = *(unsigned int *)(v70 + 3080);
      *(_DWORD *)keyExistsAndHasValidFormat = 2139095039;
      vDSP_distancesq((const float *)a2, 1, (const float *)v70, 1, (float *)keyExistsAndHasValidFormat, 0x300uLL);
      if (*((_QWORD *)&v123 + 1))
      {
        v72 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v123 + 8));
        v72.i16[0] = vaddlv_u8(v72);
        if (v72.u32[0] > 1uLL)
        {
          v73 = v71;
          if (*((_QWORD *)&v123 + 1) <= v71)
            v73 = v71 % *((_QWORD *)&v123 + 1);
        }
        else
        {
          v73 = (DWORD2(v123) - 1) & v71;
        }
        v74 = *(uint64_t **)(v123 + 8 * v73);
        if (v74)
        {
          v74 = (uint64_t *)*v74;
          if (v74)
          {
            if (v72.u32[0] < 2uLL)
            {
              while (1)
              {
                v76 = v74[1];
                if (v76 == v71)
                {
                  if (*((_DWORD *)v74 + 4) == (_DWORD)v71)
                    goto LABEL_85;
                }
                else if ((v76 & (*((_QWORD *)&v123 + 1) - 1)) != v73)
                {
                  goto LABEL_84;
                }
                v74 = (uint64_t *)*v74;
                if (!v74)
                  goto LABEL_85;
              }
            }
            do
            {
              v75 = v74[1];
              if (v75 == v71)
              {
                if (*((_DWORD *)v74 + 4) == (_DWORD)v71)
                  break;
              }
              else
              {
                if (v75 >= *((_QWORD *)&v123 + 1))
                  v75 %= *((_QWORD *)&v123 + 1);
                if (v75 != v73)
                  goto LABEL_84;
              }
              v74 = (uint64_t *)*v74;
            }
            while (v74);
          }
        }
      }
      else
      {
LABEL_84:
        v74 = 0;
      }
LABEL_85:
      v77 = *(float *)keyExistsAndHasValidFormat;
      if (a6 == 0.0 || *(float *)keyExistsAndHasValidFormat <= a6)
      {
        if (v74)
        {
          v79 = *__error();
          v80 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v80, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)keyExistsAndHasValidFormat = 67109376;
            *(_DWORD *)&keyExistsAndHasValidFormat[4] = v71;
            *(_WORD *)&keyExistsAndHasValidFormat[8] = 2048;
            *(double *)&keyExistsAndHasValidFormat[10] = v77;
            _os_log_impl(&dword_1B8270000, v80, OS_LOG_TYPE_DEFAULT, "Include vec_id: %u distance %f", keyExistsAndHasValidFormat, 0x12u);
          }
          *__error() = v79;
        }
        *(_QWORD *)keyExistsAndHasValidFormat = *(_QWORD *)(v70 + 3072);
        *(_DWORD *)&keyExistsAndHasValidFormat[8] = v71;
        *(float *)&keyExistsAndHasValidFormat[12] = v77;
        MaxSizePriorityQueue<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>,std::vector<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>,std::allocator<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>>>,std::less<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>>>::push(a4, (uint64_t)keyExistsAndHasValidFormat);
      }
      else
      {
        if (v74)
        {
          v81 = *__error();
          v82 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)keyExistsAndHasValidFormat = 67109632;
            *(_DWORD *)&keyExistsAndHasValidFormat[4] = v71;
            *(_WORD *)&keyExistsAndHasValidFormat[8] = 2048;
            *(double *)&keyExistsAndHasValidFormat[10] = v77;
            *(_WORD *)&keyExistsAndHasValidFormat[18] = 2048;
            *(double *)&keyExistsAndHasValidFormat[20] = v66;
            _os_log_impl(&dword_1B8270000, v82, OS_LOG_TYPE_DEFAULT, "Skip vec_id: %u distance %f > %f", keyExistsAndHasValidFormat, 0x1Cu);
          }
          *__error() = v81;
        }
        ++*((_DWORD *)v127 + 6);
      }
      v67 = (v67 + 1);
      v68 = v67;
      if (v69 != *(_QWORD *)(a1 + 48))
      {
        v105 = __si_assert_copy_extra_268();
        v103 = v105;
        v106 = "";
        if (v105)
          v106 = v105;
        __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1814, "store == other.store", v106);
        goto LABEL_133;
      }
    }
    v83 = v11;
  }
  else
  {
    if (!(_DWORD)AppIntegerValue)
    {
      keyExistsAndHasValidFormat[0] = 0;
      v22 = CFPreferencesGetAppIntegerValue(CFSTR("IVFPartitionProbeMax"), CFSTR("com.apple.Spotlight"), keyExistsAndHasValidFormat);
      if (keyExistsAndHasValidFormat[0])
        v23 = v22;
      else
        v23 = 40;
      lock = v23;
      keyExistsAndHasValidFormat[0] = 0;
      v24 = CFPreferencesGetAppIntegerValue(CFSTR("IVFPartitionSizeFactor"), CFSTR("com.apple.Spotlight"), keyExistsAndHasValidFormat);
      if (keyExistsAndHasValidFormat[0])
        v25 = v24;
      else
        v25 = 45;
      keyExistsAndHasValidFormat[0] = 0;
      v26 = CFPreferencesGetAppIntegerValue(CFSTR("IVFPartitionProbeNumerator"), CFSTR("com.apple.Spotlight"), keyExistsAndHasValidFormat);
      v27 = keyExistsAndHasValidFormat[0];
      v28 = 8 * v26;
      v29 = v25 * v25;
      keyExistsAndHasValidFormat[0] = 0;
      v30 = CFPreferencesGetAppIntegerValue(CFSTR("IVFpartitionProbeDecayExponent"), CFSTR("com.apple.Spotlight"), keyExistsAndHasValidFormat);
      v31 = keyExistsAndHasValidFormat[0];
      if (v30 <= 0x12)
        v32 = 18;
      else
        v32 = v30;
      v33 = v11;
      v34 = v32 - 3;
      v35 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nVectors(a1);
      if (v31)
        v36 = v34;
      else
        v36 = 17;
      v11 = v33;
      v37 = v35 >> v36;
      if (v37 <= 8)
        v38 = 8;
      else
        v38 = v37;
      v39 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nPartitions(a1);
      if (v27)
        v40 = v28;
      else
        v40 = 800;
      v41 = v40 * v39 / (v29 * v38);
      if (lock < v41)
        v41 = lock;
      if (v41 <= v20)
        AppIntegerValue = v20;
      else
        AppIntegerValue = v41;
    }
    v42 = *__error();
    v43 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
    {
      v44 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nVectors(a1);
      v45 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nPartitions(a1);
      *(_DWORD *)keyExistsAndHasValidFormat = 136316418;
      *(_QWORD *)&keyExistsAndHasValidFormat[4] = __str;
      *(_WORD *)&keyExistsAndHasValidFormat[12] = 1024;
      *(_DWORD *)&keyExistsAndHasValidFormat[14] = v11;
      *(_WORD *)&keyExistsAndHasValidFormat[18] = 1024;
      *(_DWORD *)&keyExistsAndHasValidFormat[20] = v44;
      *(_WORD *)&keyExistsAndHasValidFormat[24] = 1024;
      *(_DWORD *)&keyExistsAndHasValidFormat[26] = AppIntegerValue;
      *(_WORD *)&keyExistsAndHasValidFormat[30] = 1024;
      *(_DWORD *)&keyExistsAndHasValidFormat[32] = v45;
      *(_WORD *)&keyExistsAndHasValidFormat[36] = 2048;
      *(double *)&keyExistsAndHasValidFormat[38] = a6;
      _os_log_impl(&dword_1B8270000, v43, OS_LOG_TYPE_DEFAULT, "aNN search %s top %u of %u vectors in %u of %u partitions max_distance=%f", keyExistsAndHasValidFormat, 0x2Eu);
    }
    *__error() = v42;
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 152));
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 112));
    v46 = *(_QWORD *)(a1 + 80);
    v47 = *(std::__shared_weak_count **)(a1 + 88);
    if (v47)
    {
      p_shared_owners = (unint64_t *)&v47->__shared_owners_;
      do
        v49 = __ldxr(p_shared_owners);
      while (__stxr(v49 + 1, p_shared_owners));
    }
    v51 = *(_QWORD *)(a1 + 96);
    v50 = *(std::__shared_weak_count **)(a1 + 104);
    if (v50)
    {
      v52 = (unint64_t *)&v50->__shared_owners_;
      do
        v53 = __ldxr(v52);
      while (__stxr(v53 + 1, v52));
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 112));
    memset(keyExistsAndHasValidFormat, 0, 24);
    (*(void (**)(_BYTE *__return_ptr, uint64_t, unsigned __int8 *, CFIndex))(*(_QWORD *)v46 + 72))(keyExistsAndHasValidFormat, v46, a2, AppIntegerValue);
    v55 = *(int **)keyExistsAndHasValidFormat;
    v54 = *(int **)&keyExistsAndHasValidFormat[8];
    v120 = 0;
    v121 = 0;
    v122 = 0;
    v134 = &v120;
    v109 = *(_QWORD *)&keyExistsAndHasValidFormat[8] - *(_QWORD *)keyExistsAndHasValidFormat;
    v56 = v11;
    if (*(_QWORD *)&keyExistsAndHasValidFormat[8] == *(_QWORD *)keyExistsAndHasValidFormat)
    {
      v118 = 0;
      v119 = 0;
      v117 = 0;
    }
    else
    {
      do
      {
        v57 = *v55;
        v55 += 2;
        std::back_insert_iterator<std::vector<unsigned int>>::operator=[abi:nn180100]((uint64_t *)&v134, v57);
      }
      while (v55 != v54);
      v58 = v120;
      v118 = 0;
      v119 = 0;
      v117 = 0;
      v59 = v121 - (_BYTE *)v120;
      if (v121 != v120)
      {
        if (v59 < 0)
          abort();
        v60 = (char *)operator new(v121 - (_BYTE *)v120);
        v61 = &v60[4 * (v59 >> 2)];
        v117 = v60;
        v119 = v61;
        memcpy(v60, v58, v59);
        v118 = v61;
      }
    }
    v112[0] = MEMORY[0x1E0C809B0];
    v112[1] = 1174405120;
    v112[2] = ___ZNK22IVFVectorIndexTemplateIfLi768EE20IVFVectorIndexRoot_sI30vi_onefixedsize_disk_allocator16vi_disk_postingsE3aNNERK10CIVector_sIfLi768EEfbP20MaxSizePriorityQueueINS0_18candidate_result_sIS3_EENSt3__16vectorISB_NSC_9allocatorISB_EEEENSC_4lessISB_EEEj_block_invoke;
    v112[3] = &unk_1E6E349E8;
    v112[6] = a1;
    v112[7] = a2;
    v112[4] = &v130;
    std::unordered_set<unsigned int>::unordered_set((uint64_t)&v113, (uint64_t)&v123);
    v116 = a6;
    v112[5] = &v126;
    v115 = a4;
    (*(void (**)(uint64_t, void **, _QWORD *))(*(_QWORD *)v51 + 72))(v51, &v117, v112);
    if (v117)
    {
      v118 = v117;
      operator delete(v117);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 152));
    v95 = v114;
    if (v114)
    {
      do
      {
        v96 = (_QWORD *)*v95;
        operator delete(v95);
        v95 = v96;
      }
      while (v96);
    }
    v97 = v113;
    v113 = 0;
    if (v97)
      operator delete(v97);
    v83 = v56;
    if (v120)
    {
      v121 = v120;
      operator delete(v120);
    }
    if (*(_QWORD *)keyExistsAndHasValidFormat)
    {
      *(_QWORD *)&keyExistsAndHasValidFormat[8] = *(_QWORD *)keyExistsAndHasValidFormat;
      operator delete(*(void **)keyExistsAndHasValidFormat);
    }
    if (v50)
    {
      v98 = (unint64_t *)&v50->__shared_owners_;
      do
        v99 = __ldaxr(v98);
      while (__stlxr(v99 - 1, v98));
      if (!v99)
      {
        ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
        std::__shared_weak_count::__release_weak(v50);
      }
    }
    v108 = v109 >> 3;
    if (v47)
    {
      v100 = (unint64_t *)&v47->__shared_owners_;
      do
        v101 = __ldaxr(v100);
      while (__stlxr(v101 - 1, v100));
      if (!v101)
      {
        ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
        std::__shared_weak_count::__release_weak(v47);
      }
    }
  }
  v84 = *__error();
  v85 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v85, OS_LOG_TYPE_DEFAULT))
  {
    v86 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nVectors(a1);
    v87 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nPartitions(a1);
    v88 = *((_DWORD *)v127 + 6);
    v89 = *((_DWORD *)v131 + 6);
    v90 = (uint64_t)(a4[2] - a4[1]) >> 4;
    v91 = CFAbsoluteTimeGetCurrent();
    *(_DWORD *)keyExistsAndHasValidFormat = 136317442;
    *(_QWORD *)&keyExistsAndHasValidFormat[4] = __str;
    *(_WORD *)&keyExistsAndHasValidFormat[12] = 1024;
    *(_DWORD *)&keyExistsAndHasValidFormat[14] = v83;
    *(_WORD *)&keyExistsAndHasValidFormat[18] = 1024;
    *(_DWORD *)&keyExistsAndHasValidFormat[20] = v86;
    *(_WORD *)&keyExistsAndHasValidFormat[24] = 2048;
    *(double *)&keyExistsAndHasValidFormat[26] = a6;
    *(_WORD *)&keyExistsAndHasValidFormat[34] = 1024;
    *(_DWORD *)&keyExistsAndHasValidFormat[36] = v108;
    *(_WORD *)&keyExistsAndHasValidFormat[40] = 1024;
    *(_DWORD *)&keyExistsAndHasValidFormat[42] = v87;
    v136 = 1024;
    v137 = v88;
    v138 = 1024;
    v139 = v89;
    v140 = 2048;
    v141 = v90;
    v142 = 2048;
    v143 = v91 - Current;
    _os_log_impl(&dword_1B8270000, v85, OS_LOG_TYPE_DEFAULT, "search %s top %u of %u vectors max_distance=%f in %u of %u partitions skip %u of %u populate %zu results in duration: %f", keyExistsAndHasValidFormat, 0x4Eu);
  }
  *__error() = v84;
  v92 = (_QWORD *)__p;
  if ((_QWORD)__p)
  {
    do
    {
      v93 = (_QWORD *)*v92;
      operator delete(v92);
      v92 = v93;
    }
    while (v93);
  }
  v94 = (void *)v123;
  *(_QWORD *)&v123 = 0;
  if (v94)
    operator delete(v94);
  _Block_object_dispose(&v126, 8);
  _Block_object_dispose(&v130, 8);
}

uint64_t IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nPartitions(uint64_t a1)
{
  os_unfair_lock_s *v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  char *v15;
  char *v16;
  const char *v17;

  v2 = (os_unfair_lock_s *)(a1 + 112);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 112));
  v3 = *(std::__shared_weak_count **)(a1 + 88);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  v7 = *(_QWORD *)(a1 + 96);
  v6 = *(std::__shared_weak_count **)(a1 + 104);
  if (!v6)
  {
    os_unfair_lock_unlock(v2);
    if (v7)
    {
      v10 = *(unsigned int *)(v7 + 68);
      goto LABEL_14;
    }
LABEL_20:
    v15 = __si_assert_copy_extra_268();
    v16 = v15;
    v17 = "";
    if (v15)
      v17 = v15;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2306, "cur.partitions != nullptr", v17);
    free(v16);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v8 = (unint64_t *)&v6->__shared_owners_;
  do
    v9 = __ldxr(v8);
  while (__stxr(v9 + 1, v8));
  os_unfair_lock_unlock(v2);
  if (!v7)
    goto LABEL_20;
  v10 = *(unsigned int *)(v7 + 68);
  do
    v11 = __ldaxr(v8);
  while (__stlxr(v11 - 1, v8));
  if (!v11)
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
LABEL_14:
  if (v3)
  {
    v12 = (unint64_t *)&v3->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  return v10;
}

const __CFString *QuantizerManager<float,768>::aNNLogQueryVecIds(uint64_t a1)
{
  const __CFString *result;
  const __CFString *v3;
  CFIndex v4;
  void *v5;
  size_t v6;
  std::string::size_type v7;
  std::string *p_p;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  std::ios_base *v16;
  uint64_t v17;
  int v18;
  std::string __p;
  _QWORD v20[2];
  __int128 v21;
  _OWORD v22[3];
  void *v23[2];
  __int128 v24;
  _QWORD v25[21];

  *(_QWORD *)(a1 + 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  result = (const __CFString *)CFPreferencesCopyAppValue(CFSTR("IVFANNLogQueryVecIds"), CFSTR("com.apple.Spotlight"));
  if (result)
  {
    v3 = result;
    v4 = CFStringGetLength(result) + 1;
    v5 = (void *)operator new[]();
    bzero(v5, v4);
    if (!CFStringGetCString(v3, (char *)v5, v4, 0x8000100u))
    {
LABEL_22:
      CFRelease(v3);
      return (const __CFString *)MEMORY[0x1BCCB068C](v5, 0x1000C8077774924);
    }
    memset(v25, 0, 160);
    v24 = 0u;
    *(_OWORD *)v23 = 0u;
    memset(v22, 0, sizeof(v22));
    v21 = 0u;
    v6 = strlen((const char *)v5);
    if (v6 >= 0x7FFFFFFFFFFFFFF8)
      abort();
    v7 = v6;
    if (v6 >= 0x17)
    {
      v9 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v6 | 7) != 0x17)
        v9 = v6 | 7;
      v10 = v9 + 1;
      p_p = (std::string *)operator new(v9 + 1);
      __p.__r_.__value_.__l.__size_ = v7;
      __p.__r_.__value_.__r.__words[2] = v10 | 0x8000000000000000;
      __p.__r_.__value_.__r.__words[0] = (std::string::size_type)p_p;
    }
    else
    {
      *((_BYTE *)&__p.__r_.__value_.__s + 23) = v6;
      p_p = &__p;
      if (!v6)
        goto LABEL_11;
    }
    memcpy(p_p, v5, v7);
LABEL_11:
    p_p->__r_.__value_.__s.__data_[v7] = 0;
    v11 = MEMORY[0x1E0DE4FD8];
    v12 = (_QWORD *)MEMORY[0x1E0DE4F58];
    v13 = MEMORY[0x1E0DE4FD8] + 64;
    v14 = *(_QWORD *)(MEMORY[0x1E0DE4F58] + 8);
    v15 = *(_QWORD *)(MEMORY[0x1E0DE4F58] + 16);
    v25[1] = MEMORY[0x1E0DE4FD8] + 64;
    v20[0] = v14;
    *(_QWORD *)((char *)v20 + *(_QWORD *)(v14 - 24)) = v15;
    v20[1] = 0;
    v16 = (std::ios_base *)((char *)v20 + *(_QWORD *)(v20[0] - 24));
    std::ios_base::init(v16, &v21);
    v16[1].__vftable = 0;
    v16[1].__fmtflags_ = -1;
    v20[0] = v11 + 24;
    v25[1] = v13;
    std::streambuf::basic_streambuf();
    v17 = MEMORY[0x1E0DE4FB8];
    *(_QWORD *)&v21 = MEMORY[0x1E0DE4FB8] + 16;
    *(_OWORD *)v23 = 0u;
    v24 = 0u;
    LODWORD(v25[0]) = 8;
    std::stringbuf::str();
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    memset(&__p, 0, sizeof(__p));
    while (1)
    {
      std::getline[abi:nn180100]<char,std::char_traits<char>,std::allocator<char>>(v20, (uint64_t)&__p, 0x2Cu);
      if ((*((_BYTE *)v22 + *(_QWORD *)(v20[0] - 24)) & 5) != 0)
        break;
      v18 = std::stoi(&__p, 0, 10);
      if (v18 >= 1)
        std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>(a1, v18, v18);
    }
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    v20[0] = *v12;
    *(_QWORD *)((char *)v20 + *(_QWORD *)(v20[0] - 24)) = v12[3];
    *(_QWORD *)&v21 = v17 + 16;
    if (SBYTE7(v24) < 0)
      operator delete(v23[0]);
    std::streambuf::~streambuf();
    std::istream::~istream();
    MEMORY[0x1BCCB0650](&v25[1]);
    goto LABEL_22;
  }
  return result;
}

void MaxSizePriorityQueue<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>,std::vector<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>,std::allocator<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>>>,std::less<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>>>::push(_QWORD *a1, uint64_t a2)
{
  float *v4;
  float *v5;
  uint64_t v6;
  unint64_t v7;
  float *v8;
  uint64_t v9;
  float *v10;
  float *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  unint64_t v17;
  uint64_t v18;
  char *v19;
  char *v20;
  uint64_t v21;
  unint64_t v22;
  float v23;
  float *v24;
  uint64_t v25;
  float *v26;
  float *v27;
  uint64_t v28;
  unint64_t v29;
  float v30;
  float *v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  float v35;
  uint64_t v36;
  uint64_t v37;
  _OWORD *v38;
  __int128 v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  int v43;
  uint64_t v44;
  int v45;

  v5 = (float *)a1[1];
  v4 = (float *)a1[2];
  v6 = ((char *)v4 - (char *)v5) >> 4;
  if (v6 >= (unint64_t)*(unsigned int *)a1)
  {
    if (*(float *)(a2 + 12) < v5[3])
    {
      if ((char *)v4 - (char *)v5 >= 17)
      {
        v9 = 0;
        v39 = *(_OWORD *)v5;
        v10 = (float *)a1[1];
        do
        {
          v11 = v10;
          v10 += 4 * v9 + 4;
          v12 = 2 * v9;
          v9 = (2 * v9) | 1;
          v13 = v12 + 2;
          if (v13 < v6 && v10[3] < v10[7])
          {
            v10 += 4;
            v9 = v13;
          }
          *(_OWORD *)v11 = *(_OWORD *)v10;
        }
        while (v9 <= (uint64_t)((unint64_t)(v6 - 2) >> 1));
        v27 = v4 - 4;
        if (v10 == v4 - 4)
        {
          *(_OWORD *)v10 = v39;
        }
        else
        {
          *(_OWORD *)v10 = *(_OWORD *)v27;
          *(_OWORD *)v27 = v39;
          v28 = (char *)v10 - (char *)v5 + 16;
          if (v28 >= 17)
          {
            v29 = (((unint64_t)v28 >> 4) - 2) >> 1;
            v30 = v10[3];
            if (v5[4 * v29 + 3] < v30)
            {
              v45 = *((_DWORD *)v10 + 2);
              v44 = *(_QWORD *)v10;
              do
              {
                v31 = v10;
                v10 = &v5[4 * v29];
                *(_OWORD *)v31 = *(_OWORD *)v10;
                if (!v29)
                  break;
                v29 = (v29 - 1) >> 1;
              }
              while (v5[4 * v29 + 3] < v30);
              *(_QWORD *)v10 = v44;
              *((_DWORD *)v10 + 2) = v45;
              v10[3] = v30;
            }
          }
        }
        v4 = (float *)a1[2];
      }
      *((_OWORD *)v4 - 1) = *(_OWORD *)a2;
      v33 = a1[1];
      v32 = a1[2];
      if (v32 - v33 >= 17)
      {
        v34 = (((unint64_t)(v32 - v33) >> 4) - 2) >> 1;
        v35 = *(float *)(v32 - 4);
        if (*(float *)(v33 + 16 * v34 + 12) < v35)
        {
          v37 = *(_QWORD *)(v32 - 16);
          v36 = v32 - 16;
          v41 = v37;
          v43 = *(_DWORD *)(v36 + 8);
          do
          {
            v38 = (_OWORD *)v36;
            v36 = v33 + 16 * v34;
            *v38 = *(_OWORD *)v36;
            if (!v34)
              break;
            v34 = (v34 - 1) >> 1;
          }
          while (*(float *)(v33 + 16 * v34 + 12) < v35);
          *(_QWORD *)v36 = v41;
          *(_DWORD *)(v36 + 8) = v43;
          *(float *)(v36 + 12) = v35;
        }
      }
    }
  }
  else
  {
    v7 = a1[3];
    if ((unint64_t)v4 >= v7)
    {
      v14 = v7 - (_QWORD)v5;
      if (v14 >> 3 <= (unint64_t)(v6 + 1))
        v15 = v6 + 1;
      else
        v15 = v14 >> 3;
      v16 = (unint64_t)v14 >= 0x7FFFFFFFFFFFFFF0;
      v17 = 0xFFFFFFFFFFFFFFFLL;
      if (!v16)
        v17 = v15;
      if (v17 >> 60)
        std::__throw_bad_array_new_length[abi:nn180100]();
      v18 = 16 * v17;
      v19 = (char *)operator new(16 * v17);
      v20 = &v19[16 * v6];
      *(_OWORD *)v20 = *(_OWORD *)a2;
      v8 = (float *)(v20 + 16);
      if (v4 != v5)
      {
        do
        {
          *((_OWORD *)v20 - 1) = *((_OWORD *)v4 - 1);
          v20 -= 16;
          v4 -= 4;
        }
        while (v4 != v5);
        v4 = v5;
      }
      a1[1] = v20;
      a1[2] = v8;
      a1[3] = &v19[v18];
      if (v4)
        operator delete(v4);
    }
    else
    {
      *(_OWORD *)v4 = *(_OWORD *)a2;
      v8 = v4 + 4;
    }
    a1[2] = v8;
    v21 = a1[1];
    if ((uint64_t)v8 - v21 >= 17)
    {
      v22 = ((((unint64_t)v8 - v21) >> 4) - 2) >> 1;
      v23 = *(v8 - 1);
      if (*(float *)(v21 + 16 * v22 + 12) < v23)
      {
        v25 = *((_QWORD *)v8 - 2);
        v24 = v8 - 4;
        v40 = v25;
        v42 = *((_DWORD *)v24 + 2);
        do
        {
          v26 = v24;
          v24 = (float *)(v21 + 16 * v22);
          *(_OWORD *)v26 = *(_OWORD *)v24;
          if (!v22)
            break;
          v22 = (v22 - 1) >> 1;
        }
        while (*(float *)(v21 + 16 * v22 + 12) < v23);
        *(_QWORD *)v24 = v40;
        *((_DWORD *)v24 + 2) = v42;
        v24[3] = v23;
      }
    }
  }
}

void ___ZNK22IVFVectorIndexTemplateIfLi768EE20IVFVectorIndexRoot_sI30vi_onefixedsize_disk_allocator16vi_disk_postingsE3aNNERK10CIVector_sIfLi768EEfbP20MaxSizePriorityQueueINS0_18candidate_result_sIS3_EENSt3__16vectorISB_NSC_9allocatorISB_EEEENSC_4lessISB_EEEj_block_invoke(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  uint64_t v4;
  unint64_t v5;
  const float *v6;
  unint64_t v7;
  int8x8_t v8;
  uint8x8_t v9;
  unint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  float v15;
  float v16;
  int v17;
  NSObject *v18;
  double v19;
  int v20;
  NSObject *v21;
  uint64_t v22;
  _BYTE v23[10];
  __int16 v24;
  double v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a1 + 48);
  ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  v5 = _windowsResolvePtr(*(_QWORD *)(*(_QWORD *)(v4 + 48) + 32) + 40, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v4 + 48) + 32) + 24)+ *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v4 + 48) + 32) + 16) * *a3, 0xC10uLL);
  v6 = *(const float **)(a1 + 56);
  LODWORD(v22) = 2139095039;
  vDSP_distancesq(v6, 1, (const float *)v5, 1, (float *)&v22, 0x300uLL);
  v7 = *(unsigned int *)(v5 + 3080);
  v8 = *(int8x8_t *)(a1 + 72);
  if (v8)
  {
    v9 = (uint8x8_t)vcnt_s8(v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      v10 = *(unsigned int *)(v5 + 3080);
      if (*(_QWORD *)&v8 <= v7)
        v10 = v7 % *(_QWORD *)&v8;
    }
    else
    {
      v10 = (v8.i32[0] - 1) & v7;
    }
    v11 = *(uint64_t **)(*(_QWORD *)(a1 + 64) + 8 * v10);
    if (v11)
    {
      v11 = (uint64_t *)*v11;
      if (v11)
      {
        if (v9.u32[0] < 2uLL)
        {
          v12 = *(_QWORD *)&v8 - 1;
          while (1)
          {
            v14 = v11[1];
            if (v14 == v7)
            {
              if (*((_DWORD *)v11 + 4) == (_DWORD)v7)
                goto LABEL_22;
            }
            else if ((v14 & v12) != v10)
            {
              goto LABEL_21;
            }
            v11 = (uint64_t *)*v11;
            if (!v11)
              goto LABEL_22;
          }
        }
        do
        {
          v13 = v11[1];
          if (v13 == v7)
          {
            if (*((_DWORD *)v11 + 4) == (_DWORD)v7)
              break;
          }
          else
          {
            if (v13 >= *(_QWORD *)&v8)
              v13 %= *(_QWORD *)&v8;
            if (v13 != v10)
              goto LABEL_21;
          }
          v11 = (uint64_t *)*v11;
        }
        while (v11);
      }
    }
  }
  else
  {
LABEL_21:
    v11 = 0;
  }
LABEL_22:
  v15 = *(float *)&v22;
  v16 = *(float *)(a1 + 112);
  if (v16 == 0.0 || *(float *)&v22 <= v16)
  {
    if (v11)
    {
      v20 = *__error();
      v21 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(v22) = 67109376;
        HIDWORD(v22) = v7;
        *(_WORD *)v23 = 2048;
        *(double *)&v23[2] = v15;
        _os_log_impl(&dword_1B8270000, v21, OS_LOG_TYPE_DEFAULT, "Include vec_id: %u distance %f", (uint8_t *)&v22, 0x12u);
      }
      *__error() = v20;
    }
    v22 = *(_QWORD *)(v5 + 3072);
    *(_DWORD *)v23 = v7;
    *(float *)&v23[4] = v15;
    MaxSizePriorityQueue<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>,std::vector<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>,std::allocator<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>>>,std::less<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>>>::push(*(_QWORD **)(a1 + 104), (uint64_t)&v22);
  }
  else
  {
    if (v11)
    {
      v17 = *__error();
      v18 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        v19 = *(float *)(a1 + 112);
        LODWORD(v22) = 67109632;
        HIDWORD(v22) = v7;
        *(_WORD *)v23 = 2048;
        *(double *)&v23[2] = v15;
        v24 = 2048;
        v25 = v19;
        _os_log_impl(&dword_1B8270000, v18, OS_LOG_TYPE_DEFAULT, "Skip vec_id: %u distance %f > %f", (uint8_t *)&v22, 0x1Cu);
      }
      *__error() = v17;
    }
    ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  }
}

uint64_t std::unordered_set<unsigned int>::unordered_set(uint64_t a1, uint64_t a2)
{
  size_t prime;
  int8x8_t v5;
  BOOL v6;
  unint64_t v7;
  uint8x8_t v8;
  uint64_t v9;
  uint64_t *v10;
  _QWORD *v11;
  unint64_t v12;
  unint64_t v13;
  uint8x8_t v14;
  unint64_t v15;
  uint64_t **v16;
  uint64_t *v17;
  unint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  float v21;
  float v22;
  _BOOL8 v23;
  unint64_t v24;
  unint64_t v25;
  size_t v26;
  unint64_t v27;
  uint8x8_t v28;
  uint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  unint64_t v32;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  prime = *(_QWORD *)(a2 + 8);
  if (prime == 1)
  {
    prime = 2;
LABEL_17:
    std::__hash_table<std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,std::__unordered_map_hasher<SIUnicodeString,std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,HashFunction,HashEqual,true>,std::__unordered_map_equal<SIUnicodeString,std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,HashEqual,HashFunction,true>,std::allocator<std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>>>::__do_rehash<true>(a1, prime);
    goto LABEL_18;
  }
  if ((prime & (prime - 1)) != 0)
  {
    prime = std::__next_prime(*(_QWORD *)(a2 + 8));
    v5 = *(int8x8_t *)(a1 + 8);
    v6 = prime >= *(_QWORD *)&v5;
    if (prime > *(_QWORD *)&v5)
      goto LABEL_17;
  }
  else
  {
    v5 = 0;
    v6 = 1;
    if (prime)
      goto LABEL_17;
  }
  if (!v6)
  {
    v7 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(_QWORD *)&v5 < 3uLL || (v8 = (uint8x8_t)vcnt_s8(v5), v8.i16[0] = vaddlv_u8(v8), v8.u32[0] > 1uLL))
    {
      v7 = std::__next_prime(v7);
    }
    else
    {
      v9 = 1 << -(char)__clz(v7 - 1);
      if (v7 >= 2)
        v7 = v9;
    }
    if (prime <= v7)
      prime = v7;
    if (prime < *(_QWORD *)&v5)
      goto LABEL_17;
  }
LABEL_18:
  v10 = *(uint64_t **)(a2 + 16);
  if (v10)
  {
    v11 = (_QWORD *)(a1 + 16);
    v12 = *(_QWORD *)(a1 + 8);
    do
    {
      v13 = *((unsigned int *)v10 + 4);
      if (v12)
      {
        v14 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
        v14.i16[0] = vaddlv_u8(v14);
        if (v14.u32[0] > 1uLL)
        {
          v15 = *((unsigned int *)v10 + 4);
          if (v12 <= v13)
            v15 = v13 % v12;
        }
        else
        {
          v15 = ((_DWORD)v12 - 1) & v13;
        }
        v16 = *(uint64_t ***)(*(_QWORD *)a1 + 8 * v15);
        if (v16)
        {
          v17 = *v16;
          if (v17)
          {
            if (v14.u32[0] < 2uLL)
            {
              while (1)
              {
                v19 = v17[1];
                if (v19 == v13)
                {
                  if (*((_DWORD *)v17 + 4) == (_DWORD)v13)
                    goto LABEL_79;
                }
                else if ((v19 & (v12 - 1)) != v15)
                {
                  goto LABEL_41;
                }
                v17 = (uint64_t *)*v17;
                if (!v17)
                  goto LABEL_41;
              }
            }
            do
            {
              v18 = v17[1];
              if (v18 == v13)
              {
                if (*((_DWORD *)v17 + 4) == (_DWORD)v13)
                  goto LABEL_79;
              }
              else
              {
                if (v18 >= v12)
                  v18 %= v12;
                if (v18 != v15)
                  break;
              }
              v17 = (uint64_t *)*v17;
            }
            while (v17);
          }
        }
      }
      else
      {
        v15 = 0;
      }
LABEL_41:
      v20 = operator new(0x18uLL);
      *v20 = 0;
      v20[1] = v13;
      *((_DWORD *)v20 + 4) = *((_DWORD *)v10 + 4);
      v21 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
      v22 = *(float *)(a1 + 32);
      if (!v12 || (float)(v22 * (float)v12) < v21)
      {
        v23 = (v12 & (v12 - 1)) != 0;
        if (v12 < 3)
          v23 = 1;
        v24 = v23 | (2 * v12);
        v25 = vcvtps_u32_f32(v21 / v22);
        if (v24 <= v25)
          v26 = v25;
        else
          v26 = v24;
        if (v26 == 1)
        {
          v26 = 2;
        }
        else if ((v26 & (v26 - 1)) != 0)
        {
          v26 = std::__next_prime(v26);
          v12 = *(_QWORD *)(a1 + 8);
        }
        if (v26 > v12)
          goto LABEL_53;
        if (v26 < v12)
        {
          v27 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
          if (v12 < 3 || (v28 = (uint8x8_t)vcnt_s8((int8x8_t)v12), v28.i16[0] = vaddlv_u8(v28), v28.u32[0] > 1uLL))
          {
            v27 = std::__next_prime(v27);
          }
          else
          {
            v29 = 1 << -(char)__clz(v27 - 1);
            if (v27 >= 2)
              v27 = v29;
          }
          if (v26 <= v27)
            v26 = v27;
          if (v26 < v12)
LABEL_53:
            std::__hash_table<std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,std::__unordered_map_hasher<SIUnicodeString,std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,HashFunction,HashEqual,true>,std::__unordered_map_equal<SIUnicodeString,std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,HashEqual,HashFunction,true>,std::allocator<std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>>>::__do_rehash<true>(a1, v26);
        }
        v12 = *(_QWORD *)(a1 + 8);
        if ((v12 & (v12 - 1)) != 0)
        {
          if (v12 <= v13)
            v15 = v13 % v12;
          else
            v15 = v13;
        }
        else
        {
          v15 = ((_DWORD)v12 - 1) & v13;
        }
      }
      v30 = *(_QWORD *)a1;
      v31 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v15);
      if (v31)
      {
        *v20 = *v31;
      }
      else
      {
        *v20 = *v11;
        *v11 = v20;
        *(_QWORD *)(v30 + 8 * v15) = v11;
        if (!*v20)
          goto LABEL_78;
        v32 = *(_QWORD *)(*v20 + 8);
        if ((v12 & (v12 - 1)) != 0)
        {
          if (v32 >= v12)
            v32 %= v12;
        }
        else
        {
          v32 &= v12 - 1;
        }
        v31 = (_QWORD *)(*(_QWORD *)a1 + 8 * v32);
      }
      *v31 = v20;
LABEL_78:
      ++*(_QWORD *)(a1 + 24);
LABEL_79:
      v10 = (uint64_t *)*v10;
    }
    while (v10);
  }
  return a1;
}

uint64_t __copy_helper_block_8_64c75_ZTSNSt3__113unordered_setIjNS_4hashIjEENS_8equal_toIjEENS_9allocatorIjEEEE(uint64_t a1, uint64_t a2)
{
  return std::unordered_set<unsigned int>::unordered_set(a1 + 64, a2 + 64);
}

void __destroy_helper_block_8_64c75_ZTSNSt3__113unordered_setIjNS_4hashIjEENS_8equal_toIjEENS_9allocatorIjEEEE(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;

  v2 = *(_QWORD **)(a1 + 80);
  if (v2)
  {
    do
    {
      v3 = (_QWORD *)*v2;
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = *(void **)(a1 + 64);
  *(_QWORD *)(a1 + 64) = 0;
  if (v4)
    operator delete(v4);
}

void std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int>(uint64_t a1, unsigned int a2, int a3)
{
  unint64_t v5;
  unint64_t v6;
  uint8x8_t v7;
  unint64_t v8;
  uint64_t **v9;
  uint64_t *v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  float v14;
  float v15;
  _BOOL8 v16;
  unint64_t v17;
  unint64_t v18;
  size_t prime;
  unint64_t v20;
  uint8x8_t v21;
  uint64_t v22;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  unint64_t v26;

  v5 = a2;
  v6 = *(_QWORD *)(a1 + 8);
  if (v6)
  {
    v7 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      v8 = a2;
      if (v6 <= a2)
        v8 = a2 % v6;
    }
    else
    {
      v8 = ((_DWORD)v6 - 1) & a2;
    }
    v9 = *(uint64_t ***)(*(_QWORD *)a1 + 8 * v8);
    if (v9)
    {
      v10 = *v9;
      if (v10)
      {
        if (v7.u32[0] < 2uLL)
        {
          while (1)
          {
            v12 = v10[1];
            if (v12 == a2)
            {
              if (*((_DWORD *)v10 + 4) == a2)
                return;
            }
            else if ((v12 & (v6 - 1)) != v8)
            {
              goto LABEL_22;
            }
            v10 = (uint64_t *)*v10;
            if (!v10)
              goto LABEL_22;
          }
        }
        do
        {
          v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2)
              return;
          }
          else
          {
            if (v11 >= v6)
              v11 %= v6;
            if (v11 != v8)
              break;
          }
          v10 = (uint64_t *)*v10;
        }
        while (v10);
      }
    }
  }
  else
  {
    v8 = 0;
  }
LABEL_22:
  v13 = operator new(0x18uLL);
  v13[1] = v5;
  *((_DWORD *)v13 + 4) = a3;
  v14 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v15 = *(float *)(a1 + 32);
  if (!v6 || (float)(v15 * (float)v6) < v14)
  {
    v16 = 1;
    if (v6 >= 3)
      v16 = (v6 & (v6 - 1)) != 0;
    v17 = v16 | (2 * v6);
    v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18)
      prime = v18;
    else
      prime = v17;
    if (prime == 1)
    {
      prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      prime = std::__next_prime(prime);
      v6 = *(_QWORD *)(a1 + 8);
    }
    if (prime > v6)
      goto LABEL_44;
    if (prime < v6)
    {
      v20 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v6 < 3 || (v21 = (uint8x8_t)vcnt_s8((int8x8_t)v6), v21.i16[0] = vaddlv_u8(v21), v21.u32[0] > 1uLL))
      {
        v20 = std::__next_prime(v20);
      }
      else
      {
        v22 = 1 << -(char)__clz(v20 - 1);
        if (v20 >= 2)
          v20 = v22;
      }
      if (prime <= v20)
        prime = v20;
      if (prime < v6)
LABEL_44:
        std::__hash_table<std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,std::__unordered_map_hasher<SIUnicodeString,std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,HashFunction,HashEqual,true>,std::__unordered_map_equal<SIUnicodeString,std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,HashEqual,HashFunction,true>,std::allocator<std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>>>::__do_rehash<true>(a1, prime);
    }
    v6 = *(_QWORD *)(a1 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v6 <= v5)
        v8 = v5 % v6;
      else
        v8 = v5;
    }
    else
    {
      v8 = ((_DWORD)v6 - 1) & v5;
    }
  }
  v23 = *(_QWORD *)a1;
  v24 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v8);
  if (v24)
  {
    *v13 = *v24;
LABEL_58:
    *v24 = v13;
    goto LABEL_59;
  }
  v25 = *(_QWORD *)(a1 + 16);
  *v13 = v25;
  *(_QWORD *)(a1 + 16) = v13;
  *(_QWORD *)(v23 + 8 * v8) = a1 + 16;
  if (v25)
  {
    v26 = *(_QWORD *)(v25 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v26 >= v6)
        v26 %= v6;
    }
    else
    {
      v26 &= v6 - 1;
    }
    v24 = (_QWORD *)(*(_QWORD *)a1 + 8 * v26);
    goto LABEL_58;
  }
LABEL_59:
  ++*(_QWORD *)(a1 + 24);
}

uint64_t ___ZNK16IVFVectorIndexenI30vi_onefixedsize_disk_allocator16vi_disk_postingsE22IVFVectorIndexInstanceIfLi768EE3aNNEjtPKv14vec_dimensions15vec_data_formatfjbU13block_pointerFvPvfE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::flush(uint64_t a1, uint64_t a2)
{
  int v2;
  NSObject *v3;
  os_log_type_t v4;
  uint64_t v7;
  unint64_t *v8;
  os_unfair_lock_s *v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  std::__shared_weak_count *v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  uint8_t v20[16];

  if (*(_BYTE *)(a1 + 160))
  {
    v2 = *__error();
    v3 = _SILogForLogForCategory(16);
    v4 = dword_1EF19FCCC < 3;
    if (os_log_type_enabled(v3, (os_log_type_t)(dword_1EF19FCCC < 3)))
    {
      *(_WORD *)v20 = 0;
      _os_log_impl(&dword_1B8270000, v3, v4, "*warn* call flush on readOnly index.", v20, 2u);
    }
    *__error() = v2;
  }
  else
  {
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::persistPartitions<vi_onefixedsize_disk_allocator>(a1);
    v7 = *(_QWORD *)(a1 + 48);
    v8 = *(unint64_t **)(v7 + 32);
    *v8 = 0;
    vi_onefixedsize_disk_allocator::storeHeader(v8);
    storage_array_SyncPages(*(_QWORD *)(v7 + 32) + 8, *(_QWORD *)(v7 + 32) + 4192);
    v9 = (os_unfair_lock_s *)(a1 + 112);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 112));
    v10 = *(std::__shared_weak_count **)(a1 + 88);
    if (v10)
    {
      p_shared_owners = (unint64_t *)&v10->__shared_owners_;
      do
        v12 = __ldxr(p_shared_owners);
      while (__stxr(v12 + 1, p_shared_owners));
    }
    v14 = *(_QWORD *)(a1 + 96);
    v13 = *(std::__shared_weak_count **)(a1 + 104);
    if (v13)
    {
      v15 = (unint64_t *)&v13->__shared_owners_;
      do
        v16 = __ldxr(v15);
      while (__stxr(v16 + 1, v15));
      os_unfair_lock_unlock(v9);
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v14 + 112))(v14, a2);
      do
        v17 = __ldaxr(v15);
      while (__stlxr(v17 - 1, v15));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
    else
    {
      os_unfair_lock_unlock(v9);
      (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v14 + 112))(v14, a2);
    }
    if (v10)
    {
      v18 = (unint64_t *)&v10->__shared_owners_;
      do
        v19 = __ldaxr(v18);
      while (__stlxr(v19 - 1, v18));
      if (!v19)
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
  }
}

_DWORD *IVFVectorIndexTemplate<float,768>::VectorStore<vi_onefixedsize_disk_allocator,vi_disk_postings>::truncate(uint64_t a1)
{
  int v2;
  NSObject *v3;
  _QWORD *v4;
  int v5;
  int v6;
  int v7;
  int v9;
  _QWORD *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  int v14;
  __int16 v15;
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v2 = *__error();
  v3 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = (_QWORD *)(a1 + 56);
    if (*(char *)(a1 + 79) < 0)
      v4 = (_QWORD *)*v4;
    v5 = *(_DWORD *)(a1 + 40);
    v6 = *(_DWORD *)(_windowsResolvePtr(*(_QWORD *)(a1 + 32) + 40, *(_QWORD *)(*(_QWORD *)(a1 + 32) + 24), 0xC10uLL)
                   + 3080);
    v7 = *(_DWORD *)(_windowsResolvePtr(*(_QWORD *)(a1 + 32) + 40, *(_QWORD *)(*(_QWORD *)(a1 + 32) + 24)+ *(_QWORD *)(*(_QWORD *)(a1 + 32) + 16) * (*(_DWORD *)(a1 + 40) - 1), 0xC10uLL)+ 3080);
    v9 = 136315906;
    v10 = v4;
    v11 = 1024;
    v12 = v5;
    v13 = 1024;
    v14 = v6;
    v15 = 1024;
    v16 = v7;
    _os_log_impl(&dword_1B8270000, v3, OS_LOG_TYPE_DEFAULT, "truncate VectorStore %s(%u)[%u,%u]", (uint8_t *)&v9, 0x1Eu);
  }
  *__error() = v2;
  return storage_array_Truncate((uint64_t *)(*(_QWORD *)(a1 + 32) + 8));
}

void IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::persistPartitions<vi_onefixedsize_disk_allocator>(uint64_t a1)
{
  os_unfair_lock_s *v2;
  std::__shared_weak_count *v3;
  char *v4;
  __int128 *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  __int128 v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  uint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  const char *v21;
  __int128 v22;
  size_t v23;
  void *v24;
  void **v25;
  uint64_t v26;
  os_unfair_lock_s *v27;
  __int128 *v28;
  std::__shared_weak_count *v29;
  std::__shared_weak_count *v30;
  std::__shared_weak_count *v31;
  uint64_t v32;
  unint64_t v33;
  char *v34;
  uint64_t v35;
  _DWORD *v36;
  uint64_t v37;
  _QWORD *v38;
  __int128 v39;
  unint64_t *v40;
  unint64_t v41;
  unint64_t *v42;
  unint64_t v43;
  unint64_t *v44;
  unint64_t v45;
  unint64_t *v46;
  unint64_t v47;
  unint64_t *v48;
  unint64_t v49;
  unint64_t *v50;
  unint64_t v51;
  std::__shared_weak_count *v52;
  unint64_t *v53;
  unint64_t v54;
  std::__shared_weak_count *v55;
  unint64_t *v56;
  unint64_t v57;
  int v58;
  NSObject *v59;
  void **v60;
  int v61;
  int v62;
  _QWORD *v63;
  int v64;
  unint64_t *v65;
  unint64_t v66;
  unint64_t *v67;
  unint64_t v68;
  char *v69;
  char *v70;
  const char *v71;
  char *v72;
  const char *v73;
  char *v74;
  char *v75;
  const char *v76;
  uint64_t v77;
  std::__shared_weak_count *v78;
  char *v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  _OWORD v84[2];
  void *__dst[2];
  unint64_t v86;
  void *__p[2];
  __int128 v88;
  _BYTE buf[34];
  __int16 v90;
  int v91;
  uint64_t v92;

  v92 = *MEMORY[0x1E0C80C00];
  v2 = (os_unfair_lock_s *)(a1 + 112);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 112));
  v4 = *(char **)(a1 + 80);
  v3 = *(std::__shared_weak_count **)(a1 + 88);
  v5 = (__int128 *)(a1 + 80);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  v8 = *(_OWORD *)(a1 + 96);
  v81 = v8;
  v9 = *(std::__shared_weak_count **)(a1 + 104);
  if (*((_QWORD *)&v8 + 1))
  {
    v10 = (unint64_t *)(*((_QWORD *)&v8 + 1) + 8);
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }
  os_unfair_lock_unlock(v2);
  if (((*(uint64_t (**)(_QWORD))(*(_QWORD *)v81 + 24))(v81) & 1) == 0)
  {
    if (v9)
    {
      v12 = (unint64_t *)&v9->__shared_owners_;
      do
        v13 = __ldxr(v12);
      while (__stxr(v13 + 1, v12));
    }
    os_unfair_lock_lock(v2);
    v14 = *(std::__shared_weak_count **)(a1 + 88);
    if (v14)
    {
      v15 = (unint64_t *)&v14->__shared_owners_;
      do
        v16 = __ldxr(v15);
      while (__stxr(v16 + 1, v15));
    }
    v79 = v4;
    v17 = *(_QWORD *)(a1 + 96);
    v18 = *(std::__shared_weak_count **)(a1 + 104);
    if (v18)
    {
      v19 = (unint64_t *)&v18->__shared_owners_;
      do
        v20 = __ldxr(v19);
      while (__stxr(v20 + 1, v19));
    }
    os_unfair_lock_unlock(v2);
    v21 = ".partitions";
    if (v17 && (*(unsigned int (**)(uint64_t))(*(_QWORD *)v17 + 24))(v17))
      v21 = ".tmp.partitions";
    memset(buf, 0, 32);
    v22 = *(_OWORD *)(a1 + 24);
    *(_OWORD *)__p = *(_OWORD *)(a1 + 8);
    v88 = v22;
    v23 = strlen(v21);
    if (v23 >= 0x7FFFFFFFFFFFFFF8)
      abort();
    v24 = (void *)v23;
    if (v23 >= 0x17)
    {
      v26 = (v23 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v23 | 7) != 0x17)
        v26 = v23 | 7;
      v78 = v9;
      v27 = v2;
      v28 = v5;
      v29 = v18;
      v30 = v3;
      v31 = v14;
      v32 = v26 + 1;
      v25 = (void **)operator new(v26 + 1);
      v33 = v32 | 0x8000000000000000;
      v14 = v31;
      v3 = v30;
      v18 = v29;
      v5 = v28;
      v2 = v27;
      v9 = v78;
      __dst[1] = v24;
      v86 = v33;
      __dst[0] = v25;
    }
    else
    {
      HIBYTE(v86) = v23;
      v25 = __dst;
      if (!v23)
      {
LABEL_28:
        v34 = v79;
        *((_BYTE *)v24 + (_QWORD)v25) = 0;
        IVFVectorIndexTemplate<float,768>::childMetaInfo((uint64_t)buf, (uint64_t)__p, (uint64_t)__dst, 1);
        if (SHIBYTE(v86) < 0)
        {
          operator delete(__dst[0]);
          if (*(_QWORD *)buf)
          {
LABEL_30:
            v35 = operator new();
            v84[0] = *(_OWORD *)buf;
            v84[1] = *(_OWORD *)&buf[16];
            if (*(_QWORD *)(v81 + 8))
            {
              v36 = (_DWORD *)v35;
              v37 = PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionStore<vi_onefixedsize_disk_allocator>(v35, (uint64_t)v84, (_QWORD *)(v81 + 8));
              PartitionStore<vi_onefixedsize_disk_allocator,512>::copyFrom(v37, v81);
              (*(void (**)(_DWORD *, _QWORD))(*(_QWORD *)v36 + 112))(v36, 0);
              if (v36[17] == *(_DWORD *)(v81 + 68))
              {
                if (v36[18] != *(_DWORD *)(v81 + 72))
                {
                  v74 = __si_assert_copy_extra_268();
                  v75 = v74;
                  v76 = "";
                  if (v74)
                    v76 = v74;
                  __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2519, "newPartitions->nVectors() == aPartitions->nVectors()", v76);
                  free(v75);
                  if (__valid_fs(-1))
                    v77 = 2989;
                  else
                    v77 = 3072;
                  *(_DWORD *)v77 = -559038737;
                  abort();
                }
                v38 = (_QWORD *)operator new();
                *v38 = &off_1E6E33858;
                v38[1] = 0;
                v38[2] = 0;
                v38[3] = v36;
                *(_QWORD *)&v39 = v36;
                *((_QWORD *)&v39 + 1) = v38;
                v80 = v39;
                if (!v18)
                  goto LABEL_41;
                goto LABEL_37;
              }
              v72 = __si_assert_copy_extra_268();
              v70 = v72;
              v73 = "";
              if (v72)
                v73 = v72;
              __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2518, "newPartitions->nPartitions() == aPartitions->nPartitions()", v73);
            }
            else
            {
              v69 = __si_assert_copy_extra_268();
              v70 = v69;
              v71 = "";
              if (v69)
                v71 = v69;
              __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 872, "_quantizer != nullptr", v71);
            }
            free(v70);
            if (__valid_fs(-1))
            {
              MEMORY[0xBAD] = -559038737;
              abort();
            }
            MEMORY[0xC00] = -559038737;
            abort();
          }
        }
        else if (*(_QWORD *)buf)
        {
          goto LABEL_30;
        }
        v80 = v81;
        v81 = 0u;
        if (!v18)
        {
LABEL_41:
          if (v14)
          {
            v42 = (unint64_t *)&v14->__shared_owners_;
            do
              v43 = __ldaxr(v42);
            while (__stlxr(v43 - 1, v42));
            if (!v43)
            {
              ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
              std::__shared_weak_count::__release_weak(v14);
            }
          }
          if (v9)
          {
            v44 = (unint64_t *)&v9->__shared_owners_;
            do
              v45 = __ldaxr(v44);
            while (__stlxr(v45 - 1, v44));
            if (!v45)
            {
              ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
              std::__shared_weak_count::__release_weak(v9);
            }
          }
          if (*((_QWORD *)&v81 + 1))
          {
            v46 = (unint64_t *)(*((_QWORD *)&v81 + 1) + 8);
            do
              v47 = __ldaxr(v46);
            while (__stlxr(v47 - 1, v46));
            if (!v47)
            {
              (*(void (**)(_QWORD))(**((_QWORD **)&v81 + 1) + 16))(*((_QWORD *)&v81 + 1));
              std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v81 + 1));
            }
          }
          *(_QWORD *)&v82 = v34;
          *((_QWORD *)&v82 + 1) = v3;
          if (v3)
          {
            v48 = (unint64_t *)&v3->__shared_owners_;
            do
              v49 = __ldxr(v48);
            while (__stxr(v49 + 1, v48));
          }
          v83 = v80;
          v9 = (std::__shared_weak_count *)*((_QWORD *)&v80 + 1);
          if (*((_QWORD *)&v80 + 1))
          {
            v50 = (unint64_t *)(*((_QWORD *)&v80 + 1) + 8);
            do
              v51 = __ldxr(v50);
            while (__stxr(v51 + 1, v50));
          }
          os_unfair_lock_lock(v2);
          std::swap[abi:nn180100]<IVFVectorIndexTemplate<float,768>::QuantizerPartitions>(v5, &v82);
          os_unfair_lock_unlock(v2);
          v52 = (std::__shared_weak_count *)*((_QWORD *)&v83 + 1);
          if (*((_QWORD *)&v83 + 1))
          {
            v53 = (unint64_t *)(*((_QWORD *)&v83 + 1) + 8);
            do
              v54 = __ldaxr(v53);
            while (__stlxr(v54 - 1, v53));
            if (!v54)
            {
              ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
              std::__shared_weak_count::__release_weak(v52);
            }
          }
          v55 = (std::__shared_weak_count *)*((_QWORD *)&v82 + 1);
          if (*((_QWORD *)&v82 + 1))
          {
            v56 = (unint64_t *)(*((_QWORD *)&v82 + 1) + 8);
            do
              v57 = __ldaxr(v56);
            while (__stlxr(v57 - 1, v56));
            if (!v57)
            {
              ((void (*)(std::__shared_weak_count *))v55->__on_zero_shared)(v55);
              std::__shared_weak_count::__release_weak(v55);
            }
          }
          v58 = *__error();
          v59 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
          {
            (*(void (**)(void **__return_ptr, _QWORD))(*(_QWORD *)v80 + 144))(__p, v80);
            if ((SBYTE7(v88) & 0x80u) == 0)
              v60 = __p;
            else
              v60 = (void **)__p[0];
            v61 = *(_DWORD *)(v80 + 68);
            v62 = *(_DWORD *)(v80 + 72);
            v63 = v34 + 8;
            if (v34[31] < 0)
              v63 = (_QWORD *)*v63;
            v64 = (*(uint64_t (**)(char *))(*(_QWORD *)v34 + 16))(v34);
            *(_DWORD *)buf = 136316162;
            *(_QWORD *)&buf[4] = v60;
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v62;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v61;
            *(_WORD *)&buf[24] = 2080;
            *(_QWORD *)&buf[26] = v63;
            v90 = 1024;
            v91 = v64;
            _os_log_impl(&dword_1B8270000, v59, OS_LOG_TYPE_DEFAULT, "Persist Partitions %s(%u/%u) with quantizer %s(%u) ", buf, 0x28u);
            if (SBYTE7(v88) < 0)
              operator delete(__p[0]);
          }
          *__error() = v58;
          goto LABEL_81;
        }
LABEL_37:
        v40 = (unint64_t *)&v18->__shared_owners_;
        do
          v41 = __ldaxr(v40);
        while (__stlxr(v41 - 1, v40));
        if (!v41)
        {
          ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
          std::__shared_weak_count::__release_weak(v18);
        }
        goto LABEL_41;
      }
    }
    memcpy(v25, v21, (size_t)v24);
    goto LABEL_28;
  }
LABEL_81:
  if (v9)
  {
    v65 = (unint64_t *)&v9->__shared_owners_;
    do
      v66 = __ldaxr(v65);
    while (__stlxr(v66 - 1, v65));
    if (!v66)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  if (v3)
  {
    v67 = (unint64_t *)&v3->__shared_owners_;
    do
      v68 = __ldaxr(v67);
    while (__stlxr(v68 - 1, v67));
    if (!v68)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

uint64_t PartitionStore<vi_onefixedsize_disk_allocator,512>::copyFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t result;
  char *v6;
  char *v7;
  const char *v8;
  char *v9;
  const char *v10;
  char *v11;
  const char *v12;
  char *v13;
  const char *v14;
  char *v15;
  const char *v16;
  char *v17;
  const char *v18;
  _QWORD v19[5];

  v3 = *(_QWORD *)(a1 + 8);
  if (!v3 || !*(_QWORD *)(a2 + 8))
  {
    v6 = __si_assert_copy_extra_268();
    v7 = v6;
    v8 = "";
    if (v6)
      v8 = v6;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 872, "_quantizer != nullptr", v8);
LABEL_27:
    free(v7);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  if (((*(uint64_t (**)(uint64_t))(*(_QWORD *)v3 + 48))(v3) & 1) == 0)
  {
    v9 = __si_assert_copy_extra_268();
    v7 = v9;
    v10 = "";
    if (v9)
      v10 = v9;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1239, "*quantizer() == *partitionStore.quantizer()", v10);
    goto LABEL_27;
  }
  if (*(_DWORD *)(a1 + 72))
  {
    v11 = __si_assert_copy_extra_268();
    v7 = v11;
    v12 = "";
    if (v11)
      v12 = v11;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1240, "nVectors() == 0", v12);
    goto LABEL_27;
  }
  if (*(_DWORD *)(a1 + 68) != *(_DWORD *)(a2 + 68))
  {
    v13 = __si_assert_copy_extra_268();
    v7 = v13;
    v14 = "";
    if (v13)
      v14 = v13;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1241, "nPartitions() == partitionStore.nPartitions()", v14);
    goto LABEL_27;
  }
  v19[0] = MEMORY[0x1E0C809B0];
  v19[1] = 0x40000000;
  v19[2] = ___ZN14PartitionStoreI30vi_onefixedsize_disk_allocatorLi512EE8copyFromERK17AnyPartitionStore_block_invoke;
  v19[3] = &__block_descriptor_tmp_894_5850;
  v19[4] = a1;
  result = (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)a2 + 64))(a2, v19);
  if (*(_DWORD *)(a1 + 68) != *(_DWORD *)(a2 + 68))
  {
    v15 = __si_assert_copy_extra_268();
    v7 = v15;
    v16 = "";
    if (v15)
      v16 = v15;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1245, "nPartitions() == partitionStore.nPartitions()", v16);
    goto LABEL_27;
  }
  if (*(_DWORD *)(a1 + 72) != *(_DWORD *)(a2 + 72))
  {
    v17 = __si_assert_copy_extra_268();
    v7 = v17;
    v18 = "";
    if (v17)
      v18 = v17;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1246, "nVectors() == partitionStore.nVectors()", v18);
    goto LABEL_27;
  }
  return result;
}

uint64_t ___ZN14PartitionStoreI30vi_onefixedsize_disk_allocatorLi512EE8copyFromERK17AnyPartitionStore_block_invoke(uint64_t a1, uint64_t a2, float *a3)
{
  return (*(uint64_t (**)(_QWORD, uint64_t, _QWORD, float))(**(_QWORD **)(a1 + 32) + 56))(*(_QWORD *)(a1 + 32), a2, *(unsigned int *)a3, a3[1]);
}

void IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::compactForTest<vi_onefixedsize_disk_allocator>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  uint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  unint64_t *v34;
  unint64_t v35;
  unint64_t *v36;
  unint64_t v37;
  char *v38;
  char *v39;
  const char *v40;
  _QWORD v41[2];
  _DWORD *(*v42)(uint64_t, unsigned int *, BOOL *);
  void *v43;
  uint64_t v44;
  uint64_t v45;
  _QWORD v46[2];
  uint64_t v47;
  std::__shared_weak_count *v48;
  __int128 v49;
  __int128 v50;
  _OWORD v51[3];
  uint64_t v52[2];
  void *v53[3];
  __int128 v54;
  __int128 v55;
  char v56;
  __int128 v57;
  __int128 v58;

  if (IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nVectors(a2))
  {
    v38 = __si_assert_copy_extra_268();
    v39 = v38;
    v40 = "";
    if (v38)
      v40 = v38;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2589, "target->nVectors() == 0", v40);
    free(v39);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v6 = operator new(8uLL);
  v53[0] = v6;
  *v6 = a1;
  v53[1] = v6 + 1;
  v53[2] = v6 + 1;
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::train<vi_onefixedsize_disk_allocator>(*(_QWORD *)(a1 + 64), *(std::__shared_weak_count **)(a1 + 72), (uint64_t)v53);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 112));
  v8 = *(_QWORD *)(a1 + 80);
  v7 = *(std::__shared_weak_count **)(a1 + 88);
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
  }
  v12 = *(_QWORD *)(a1 + 96);
  v11 = *(std::__shared_weak_count **)(a1 + 104);
  if (v11)
  {
    v13 = (unint64_t *)&v11->__shared_owners_;
    do
      v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 112));
  v52[0] = v8;
  v52[1] = (uint64_t)v7;
  if (v7)
  {
    v15 = (unint64_t *)&v7->__shared_owners_;
    do
      v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::replaceQuantizer(a2, v52);
    do
      v17 = __ldaxr(v15);
    while (__stlxr(v17 - 1, v15));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  else
  {
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::replaceQuantizer(a2, v52);
  }
  v50 = 0u;
  memset(v51, 0, sizeof(v51));
  v49 = 0u;
  v47 = v12;
  v48 = v11;
  if (v11)
  {
    v18 = (unint64_t *)&v11->__shared_owners_;
    do
      v19 = __ldxr(v18);
    while (__stxr(v19 + 1, v18));
  }
  v20 = *(_QWORD *)(a1 + 48);
  v21 = *(std::__shared_weak_count **)(a1 + 56);
  v46[0] = v20;
  v46[1] = v21;
  if (v21)
  {
    v22 = (unint64_t *)&v21->__shared_owners_;
    do
      v23 = __ldxr(v22);
    while (__stxr(v23 + 1, v22));
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::enumerator_s::enumerator_s((uint64_t)&v49, &v47, v46);
    do
      v24 = __ldaxr(v22);
    while (__stlxr(v24 - 1, v22));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }
  else
  {
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::enumerator_s::enumerator_s((uint64_t)&v49, &v47, v46);
  }
  v25 = v48;
  if (v48)
  {
    v26 = (unint64_t *)&v48->__shared_owners_;
    do
      v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
  v41[0] = MEMORY[0x1E0C809B0];
  v41[1] = 0x40000000;
  v42 = ___ZN22IVFVectorIndexTemplateIfLi768EE20IVFVectorIndexRoot_sI30vi_onefixedsize_disk_allocator16vi_disk_postingsE14compactForTestIS2_EENSt3__19enable_ifIXsr13is_persistentIT_EE5valueEbE4typeEPS4_PVi_block_invoke;
  v43 = &__block_descriptor_tmp_781;
  v44 = a2;
  v45 = a3;
  v57 = 0u;
  v58 = 0u;
  v56 = 0;
  do
  {
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::enumerator_s::next((uint64_t)&v54, (uint64_t)&v49);
    v57 = v54;
    v58 = v55;
    if (!(_QWORD)v55)
      break;
    v42((uint64_t)v41, (unsigned int *)&v57, (BOOL *)&v56);
  }
  while (!v56);
  std::deque<std::shared_ptr<AnyPartitionStore::Enumerator>>::~deque[abi:nn180100]((uint64_t)v51);
  v28 = (std::__shared_weak_count *)*((_QWORD *)&v50 + 1);
  if (*((_QWORD *)&v50 + 1))
  {
    v29 = (unint64_t *)(*((_QWORD *)&v50 + 1) + 8);
    do
      v30 = __ldaxr(v29);
    while (__stlxr(v30 - 1, v29));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }
  v31 = (std::__shared_weak_count *)*((_QWORD *)&v49 + 1);
  if (*((_QWORD *)&v49 + 1))
  {
    v32 = (unint64_t *)(*((_QWORD *)&v49 + 1) + 8);
    do
      v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }
  if (v11)
  {
    v34 = (unint64_t *)&v11->__shared_owners_;
    do
      v35 = __ldaxr(v34);
    while (__stlxr(v35 - 1, v34));
    if (!v35)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  if (v7)
  {
    v36 = (unint64_t *)&v7->__shared_owners_;
    do
      v37 = __ldaxr(v36);
    while (__stlxr(v37 - 1, v36));
    if (!v37)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  if (v53[0])
    operator delete(v53[0]);
}

void IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::train<vi_onefixedsize_disk_allocator>(uint64_t a1, std::__shared_weak_count *a2, uint64_t a3)
{
  unint64_t *p_shared_owners;
  unint64_t v6;
  uint64_t v7;
  const void *v8;
  int64_t v9;
  char *v10;
  char *v11;
  uint64_t v12;
  char *v13;
  char *v14;
  unint64_t v15;
  unsigned int v16;
  unint64_t v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  uint64_t v20;
  unint64_t *v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  std::__shared_weak_count *v29;
  uint64_t v30;
  unint64_t *v31;
  unint64_t v32;
  char *v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  std::__shared_weak_count *v37;
  unint64_t *v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t *v44;
  unint64_t v45;
  std::__shared_weak_count *v46;
  unint64_t *v47;
  unint64_t v48;
  std::__shared_weak_count *v49;
  unint64_t *v50;
  unint64_t v51;
  std::__shared_weak_count *v52;
  unint64_t *v53;
  unint64_t v54;
  std::__shared_weak_count *v55;
  uint64_t v56;
  unint64_t *v57;
  unint64_t v58;
  std::__shared_weak_count *v59;
  int v60;
  unint64_t *v61;
  unint64_t v62;
  unsigned int AppIntegerValue;
  unsigned int v64;
  unsigned int v65;
  double v66;
  unsigned __int8 *v67;
  unsigned __int8 v68;
  char *FdPtrForFile;
  char *v70;
  NSObject *v71;
  os_signpost_id_t v72;
  NSObject *v73;
  NSObject *v74;
  _QWORD *v75;
  uint64_t v76;
  std::ios_base *v77;
  uint64_t v78;
  char *v79;
  _QWORD *v80;
  std::__shared_weak_count *v81;
  unint64_t *v82;
  unint64_t v83;
  int v84;
  NSObject *v85;
  os_log_type_t v86;
  std::__shared_weak_count *v87;
  std::__shared_weak_count *v88;
  int v89;
  NSObject *v90;
  os_log_type_t v91;
  Boolean *v92;
  double Current;
  unsigned int v94;
  unsigned int v95;
  unsigned int v96;
  unsigned int v97;
  uint64_t v98;
  unint64_t *v99;
  unint64_t v100;
  char *v101;
  unsigned int v102;
  unsigned int v103;
  unsigned int v104;
  int v105;
  unint64_t *v106;
  unint64_t v107;
  unsigned int v108;
  std::__shared_weak_count *v109;
  unint64_t *v110;
  unint64_t v111;
  std::__shared_weak_count *v112;
  unint64_t *v113;
  unint64_t v114;
  char *v115;
  int v116;
  unint64_t v117;
  int v118;
  unsigned int v119;
  unsigned __int8 v120;
  NSObject *v121;
  unsigned int v122;
  std::__shared_weak_count *v123;
  unint64_t *v124;
  unint64_t v125;
  NSObject *v126;
  NSObject *v127;
  int v128;
  NSObject *v129;
  CFAbsoluteTime v130;
  uint64_t v131;
  std::__shared_weak_count *v132;
  unint64_t *v133;
  unint64_t v134;
  unint64_t *v135;
  unint64_t v136;
  unint64_t *v137;
  unint64_t v138;
  unint64_t *v139;
  unsigned int v140;
  unsigned int v141;
  unsigned int v142;
  uint64_t v143;
  unint64_t v144;
  char *v145;
  unsigned int v146;
  unsigned int v147;
  int v148;
  unint64_t v149;
  std::__shared_weak_count *v150;
  unint64_t *v151;
  unint64_t v152;
  char *v153;
  char *v154;
  const char *v155;
  char *v156;
  char *v157;
  const char *v158;
  uint64_t v159;
  char *v160;
  const char *v161;
  os_signpost_id_t spid;
  unint64_t v163;
  uint64_t v164;
  unsigned int v165;
  uint64_t v166;
  unsigned int v167;
  size_t __sz;
  unint64_t v169;
  uint64_t v170;
  std::__shared_weak_count *v171;
  char *v172;
  char *v173;
  char *v174;
  char *v175;
  uint64_t v176[2];
  uint64_t v177;
  std::__shared_weak_count *v178;
  Boolean keyExistsAndHasValidFormat[8];
  std::__shared_weak_count *v180;
  uint64_t v181;
  _OWORD v182[4];
  __int128 __p;
  __int128 v184;
  uint64_t v185;
  uint64_t v186;
  __int128 v187;
  __int128 v188;
  __int128 v189;
  __int128 v190;
  __int128 v191;
  __int128 v192;
  __int128 v193;
  __int128 v194;
  __int128 v195;
  uint64_t v196;
  std::__shared_weak_count *v197;
  uint64_t v198;
  std::__shared_weak_count *v199;
  uint64_t v200;
  std::__shared_weak_count *v201;
  uint64_t v202;
  std::__shared_weak_count *v203;
  uint8_t buf[32];
  Boolean block[8];
  uint64_t v206;
  _BYTE v207[24];
  uint64_t v208;

  v208 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    p_shared_owners = (unint64_t *)&a2->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  v8 = *(const void **)a3;
  v7 = *(_QWORD *)(a3 + 8);
  v9 = v7 - *(_QWORD *)a3;
  if (v7 == *(_QWORD *)a3)
  {
    v10 = 0;
    v11 = 0;
  }
  else
  {
    if (v9 < 0)
      goto LABEL_251;
    v10 = (char *)operator new(v7 - *(_QWORD *)a3);
    v11 = &v10[8 * (v9 >> 3)];
    memcpy(v10, v8, v9);
  }
  v202 = 0;
  v203 = 0;
  QuantizerManager<float,768>::sharedQuantizer(&v202, a1, 0);
  v12 = v11 - v10;
  v170 = a1;
  v171 = a2;
  if (v11 == v10)
  {
    v14 = 0;
    v13 = 0;
  }
  else
  {
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF9)
      goto LABEL_251;
    v13 = (char *)operator new(2 * v12);
    bzero(v13, 2 * v12);
    v14 = &v13[2 * v12];
  }
  __sz = v11 - v10;
  v15 = v12 >> 3;
  v16 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v202 + 24))(v202);
  v172 = v11;
  v169 = v15;
  v17 = 0;
  if (v11 != v10)
  {
    if (v15 <= 1)
      v15 = 1;
    while (1)
    {
      (*(void (**)(Boolean *__return_ptr))(**(_QWORD **)&v10[8 * v17] + 16))(keyExistsAndHasValidFormat);
      v18 = v202;
      v20 = *(_QWORD *)keyExistsAndHasValidFormat;
      v19 = v180;
      if (!v180)
        goto LABEL_21;
      v21 = (unint64_t *)&v180->__shared_owners_;
      do
        v22 = __ldaxr(v21);
      while (__stlxr(v22 - 1, v21));
      if (!v22)
      {
        ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
        std::__shared_weak_count::__release_weak(v19);
        if (v20 == v18)
          goto LABEL_16;
      }
      else
      {
LABEL_21:
        if (v20 == v18)
          goto LABEL_16;
      }
      *(_QWORD *)keyExistsAndHasValidFormat = 0;
      v180 = 0;
      v23 = *(_QWORD *)&v10[8 * v17];
      v200 = v202;
      v201 = v203;
      if (v203)
      {
        v24 = (unint64_t *)&v203->__shared_owners_;
        do
          v25 = __ldxr(v24);
        while (__stxr(v25 + 1, v24));
      }
      (*(void (**)(Boolean *__return_ptr, uint64_t, uint64_t *))(*(_QWORD *)v23 + 40))(keyExistsAndHasValidFormat, v23, &v200);
      v26 = v201;
      if (!v201)
        goto LABEL_29;
      v27 = (unint64_t *)&v201->__shared_owners_;
      do
        v28 = __ldaxr(v27);
      while (__stlxr(v28 - 1, v27));
      if (!v28)
      {
        ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
        std::__shared_weak_count::__release_weak(v26);
        v30 = *(_QWORD *)keyExistsAndHasValidFormat;
        v29 = v180;
        if (!v180)
          goto LABEL_32;
      }
      else
      {
LABEL_29:
        v30 = *(_QWORD *)keyExistsAndHasValidFormat;
        v29 = v180;
        if (!v180)
          goto LABEL_32;
      }
      v31 = (unint64_t *)&v29->__shared_owners_;
      do
        v32 = __ldxr(v31);
      while (__stxr(v32 + 1, v31));
LABEL_32:
      v33 = &v13[16 * v17];
      v34 = (std::__shared_weak_count *)*((_QWORD *)v33 + 1);
      *(_QWORD *)v33 = v30;
      *((_QWORD *)v33 + 1) = v29;
      if (!v34)
        goto LABEL_36;
      v35 = (unint64_t *)&v34->__shared_owners_;
      do
        v36 = __ldaxr(v35);
      while (__stlxr(v36 - 1, v35));
      if (!v36)
      {
        ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
        std::__shared_weak_count::__release_weak(v34);
        v37 = v180;
        if (v180)
        {
LABEL_37:
          v38 = (unint64_t *)&v37->__shared_owners_;
          do
            v39 = __ldaxr(v38);
          while (__stlxr(v39 - 1, v38));
          if (!v39)
          {
            ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
            std::__shared_weak_count::__release_weak(v37);
          }
        }
      }
      else
      {
LABEL_36:
        v37 = v180;
        if (v180)
          goto LABEL_37;
      }
LABEL_16:
      if (++v17 == v15)
      {
        v17 = 0;
        v40 = 0;
        if (v169 <= 1)
          v41 = 1;
        else
          v41 = v169;
        while (1)
        {
          v42 = *(_QWORD *)&v13[16 * v40];
          if (v42)
          {
            v43 = *(_QWORD *)&v10[8 * v40];
            v198 = v202;
            v199 = v203;
            if (v203)
            {
              v44 = (unint64_t *)&v203->__shared_owners_;
              do
                v45 = __ldxr(v44);
              while (__stxr(v45 + 1, v44));
            }
            v46 = *(std::__shared_weak_count **)&v13[16 * v40 + 8];
            v196 = v42;
            v197 = v46;
            if (v46)
            {
              v47 = (unint64_t *)&v46->__shared_owners_;
              do
                v48 = __ldxr(v47);
              while (__stxr(v48 + 1, v47));
            }
            (*(void (**)(uint64_t, uint64_t *, uint64_t *))(*(_QWORD *)v43 + 48))(v43, &v198, &v196);
            v49 = v197;
            if (!v197)
              goto LABEL_61;
            v50 = (unint64_t *)&v197->__shared_owners_;
            do
              v51 = __ldaxr(v50);
            while (__stlxr(v51 - 1, v50));
            if (!v51)
            {
              ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
              std::__shared_weak_count::__release_weak(v49);
              v52 = v199;
              if (!v199)
                goto LABEL_67;
            }
            else
            {
LABEL_61:
              v52 = v199;
              if (!v199)
                goto LABEL_67;
            }
            v53 = (unint64_t *)&v52->__shared_owners_;
            do
              v54 = __ldaxr(v53);
            while (__stlxr(v54 - 1, v53));
            if (!v54)
            {
              ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
              std::__shared_weak_count::__release_weak(v52);
            }
          }
LABEL_67:
          (*(void (**)(Boolean *__return_ptr))(**(_QWORD **)&v10[8 * v40] + 24))(keyExistsAndHasValidFormat);
          v55 = v180;
          v56 = *(unsigned int *)(*(_QWORD *)keyExistsAndHasValidFormat + 72);
          if (v180)
          {
            v57 = (unint64_t *)&v180->__shared_owners_;
            do
              v58 = __ldaxr(v57);
            while (__stlxr(v58 - 1, v57));
            if (!v58)
            {
              ((void (*)(std::__shared_weak_count *))v55->__on_zero_shared)(v55);
              std::__shared_weak_count::__release_weak(v55);
            }
          }
          (*(void (**)(Boolean *__return_ptr))(**(_QWORD **)&v10[8 * v40] + 24))(keyExistsAndHasValidFormat);
          v59 = v180;
          v60 = *(_DWORD *)(*(_QWORD *)keyExistsAndHasValidFormat + 68);
          if (v180)
          {
            v61 = (unint64_t *)&v180->__shared_owners_;
            do
              v62 = __ldaxr(v61);
            while (__stlxr(v62 - 1, v61));
            if (!v62)
            {
              ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
              std::__shared_weak_count::__release_weak(v59);
            }
          }
          if (v60 != v16)
          {
            v153 = __si_assert_copy_extra_268();
            v154 = v153;
            v155 = "";
            if (v153)
              v155 = v153;
            __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2080, "vectorIndexes[i]->getPartitions()->nPartitions() == nPartitions", v155);
LABEL_239:
            free(v154);
            if (__valid_fs(-1))
            {
              MEMORY[0xBAD] = -559038737;
              abort();
            }
            MEMORY[0xC00] = -559038737;
            abort();
          }
          v17 += v56;
          if (++v40 == v41)
            goto LABEL_79;
        }
      }
    }
  }
LABEL_79:
  keyExistsAndHasValidFormat[0] = 0;
  AppIntegerValue = CFPreferencesGetAppIntegerValue(CFSTR("IVFPartitionSizeFactor"), CFSTR("com.apple.Spotlight"), keyExistsAndHasValidFormat);
  if (keyExistsAndHasValidFormat[0])
    v64 = AppIntegerValue;
  else
    v64 = 45;
  keyExistsAndHasValidFormat[0] = 0;
  v65 = CFPreferencesGetAppIntegerValue(CFSTR("IVFTrainingTimeBudget"), CFSTR("com.apple.Spotlight"), keyExistsAndHasValidFormat);
  if (keyExistsAndHasValidFormat[0])
    v66 = (double)v65;
  else
    v66 = 30.0;
  if (v17 >> 4 < 0x271 || v17 < v64 * (unint64_t)v16 * v64 * (unint64_t)v16 / 0x64)
  {
LABEL_108:
    v87 = v171;
    if (!v13)
      goto LABEL_109;
    goto LABEL_187;
  }
  v67 = (unsigned __int8 *)(v170 + 72);
  do
    v68 = __ldaxr(v67);
  while (__stlxr(1u, v67));
  if ((v68 & 1) == 0 && *(_QWORD *)(v170 + 96))
  {
    v156 = __si_assert_copy_extra_268();
    v157 = v156;
    v158 = "";
    if (v156)
      v158 = v156;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 717, "_trainingQuantizer == nullptr", v158);
    free(v157);
    if (__valid_fs(-1))
      v159 = 2989;
    else
      v159 = 3072;
    *(_DWORD *)v159 = -559038737;
    goto LABEL_251;
  }
  FdPtrForFile = (char *)QuantizerManager<float,768>::createFdPtrForFile(v170, "dummy");
  if (!FdPtrForFile)
  {
    atomic_store(0, v67);
    goto LABEL_105;
  }
  v70 = FdPtrForFile;
  _fd_unlink_with_origin((uint64_t)FdPtrForFile, 0);
  fd_release(v70);
  if ((v68 & 1) != 0)
  {
LABEL_105:
    v84 = *__error();
    v85 = _SILogForLogForCategory(16);
    v86 = 2 * (dword_1EF19FCCC < 4);
    if (os_log_type_enabled(v85, v86))
    {
      *(_WORD *)keyExistsAndHasValidFormat = 0;
      _os_log_impl(&dword_1B8270000, v85, v86, "training quantizer already happen in other thread. Skip!", keyExistsAndHasValidFormat, 2u);
    }
    *__error() = v84;
    goto LABEL_108;
  }
  v167 = v64;
  v71 = _SILogForLogForCategory(0);
  v72 = os_signpost_id_make_with_pointer(v71, 0);
  v73 = _SILogForLogForCategory(0);
  spid = v72;
  v163 = v72 - 1;
  if (v72 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v74 = v73;
    if (os_signpost_enabled(v73))
    {
      *(_WORD *)keyExistsAndHasValidFormat = 0;
      _os_signpost_emit_with_name_impl(&dword_1B8270000, v74, OS_SIGNPOST_INTERVAL_BEGIN, v72, "IVFVectorIndexTrain", "Start", keyExistsAndHasValidFormat, 2u);
    }
  }
  v195 = 0u;
  v194 = 0u;
  v193 = 0u;
  v192 = 0u;
  v191 = 0u;
  v190 = 0u;
  v189 = 0u;
  v188 = 0u;
  v187 = 0u;
  v185 = 0;
  v184 = 0u;
  __p = 0u;
  memset(v182, 0, sizeof(v182));
  v180 = 0;
  v166 = MEMORY[0x1E0DE4FD0] + 104;
  v186 = MEMORY[0x1E0DE4FD0] + 104;
  v164 = MEMORY[0x1E0DE4FD0] + 64;
  v181 = MEMORY[0x1E0DE4FD0] + 64;
  v75 = (_QWORD *)MEMORY[0x1E0DE4F50];
  v76 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 24);
  *(_QWORD *)keyExistsAndHasValidFormat = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 16);
  *(_QWORD *)&keyExistsAndHasValidFormat[*(_QWORD *)(*(_QWORD *)keyExistsAndHasValidFormat - 24)] = v76;
  v180 = 0;
  v77 = (std::ios_base *)&keyExistsAndHasValidFormat[*(_QWORD *)(*(_QWORD *)keyExistsAndHasValidFormat - 24)];
  std::ios_base::init(v77, v182);
  v77[1].__vftable = 0;
  v77[1].__fmtflags_ = -1;
  v78 = v75[5];
  v181 = v75[4];
  *(uint64_t *)((char *)&v181 + *(_QWORD *)(v181 - 24)) = v78;
  *(_QWORD *)keyExistsAndHasValidFormat = v75[1];
  *(_QWORD *)&keyExistsAndHasValidFormat[*(_QWORD *)(*(_QWORD *)keyExistsAndHasValidFormat - 24)] = v75[6];
  v186 = v166;
  *(_QWORD *)keyExistsAndHasValidFormat = MEMORY[0x1E0DE4FD0] + 24;
  v181 = v164;
  std::streambuf::basic_streambuf();
  *(_QWORD *)&v182[0] = MEMORY[0x1E0DE4FB8] + 16;
  __p = 0u;
  v184 = 0u;
  LODWORD(v185) = 24;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v181, (uint64_t)"[", 1);
  if (v172 != v10)
  {
    v79 = v10;
    do
    {
      (*(void (**)(Boolean *__return_ptr))(**(_QWORD **)v79 + 24))(block);
      v80 = (_QWORD *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v80, (uint64_t)", ", 2);
      v81 = (std::__shared_weak_count *)v206;
      if (v206)
      {
        v82 = (unint64_t *)(v206 + 8);
        do
          v83 = __ldaxr(v82);
        while (__stlxr(v83 - 1, v82));
        if (!v83)
        {
          ((void (*)(std::__shared_weak_count *))v81->__on_zero_shared)(v81);
          std::__shared_weak_count::__release_weak(v81);
        }
      }
      v79 += 8;
    }
    while (v79 != v172);
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v181, (uint64_t)"]", 1);
  v89 = *__error();
  v90 = _SILogForLogForCategory(16);
  v91 = 2 * (dword_1EF19FCCC < 4);
  if (os_log_type_enabled(v90, v91))
  {
    std::stringbuf::str();
    v92 = v207[7] >= 0 ? block : *(Boolean **)block;
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = v92;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v16;
    _os_log_impl(&dword_1B8270000, v90, v91, "training quantizer with %s vectors in %u partitions", buf, 0x12u);
    if ((v207[7] & 0x80000000) != 0)
      operator delete(*(void **)block);
  }
  *__error() = v89;
  Current = CFAbsoluteTimeGetCurrent();
  if (CFAbsoluteTimeGetCurrent() - Current >= v66)
  {
    v102 = 0;
    goto LABEL_169;
  }
  v94 = (sqrt((double)v17) / (double)v167);
  block[0] = 0;
  v95 = CFPreferencesGetAppIntegerValue(CFSTR("IVFSeedCentroidPerTraining"), CFSTR("com.apple.Spotlight"), block);
  if (block[0])
    v96 = v95;
  else
    v96 = 60;
  v165 = v94;
  v97 = 2 * (v94 - v16);
  if (v96 <= v97)
    v98 = v97;
  else
    v98 = v96;
  v177 = v170;
  v178 = v171;
  if (v171)
  {
    v99 = (unint64_t *)&v171->__shared_owners_;
    do
      v100 = __ldxr(v99);
    while (__stxr(v100 + 1, v99));
  }
  memset(buf, 0, 24);
  if (v172 == v10)
  {
    v101 = 0;
    goto LABEL_132;
  }
  if ((__sz & 0x8000000000000000) != 0)
LABEL_251:
    abort();
  v101 = (char *)operator new(__sz);
  *(_QWORD *)buf = v101;
  *(_QWORD *)&buf[16] = &v101[8 * v169];
  memcpy(v101, v10, __sz);
  *(_QWORD *)&buf[8] = &v101[8 * v169];
LABEL_132:
  block[0] = 0;
  v103 = CFPreferencesGetAppIntegerValue(CFSTR("IVFPartitionRecycleTheshold"), CFSTR("com.apple.Spotlight"), block);
  if (block[0])
    v104 = v103;
  else
    v104 = 3;
  v105 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRootBase::trainOnce(&v177, (std::string::size_type *)buf, v98, v104);
  if (v101)
  {
    *(_QWORD *)&buf[8] = v101;
    operator delete(v101);
  }
  if (v171)
  {
    v106 = (unint64_t *)&v171->__shared_owners_;
    do
      v107 = __ldaxr(v106);
    while (__stlxr(v107 - 1, v106));
    if (!v107)
    {
      ((void (*)(std::__shared_weak_count *))v171->__on_zero_shared)(v171);
      std::__shared_weak_count::__release_weak(v171);
    }
  }
  if (v105)
  {
    QuantizerManager<float,768>::lastTrainedQuantizer(block, v170);
    v108 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)block + 24))(*(_QWORD *)block);
    v109 = (std::__shared_weak_count *)v206;
    if (v206)
    {
      v110 = (unint64_t *)(v206 + 8);
      do
        v111 = __ldaxr(v110);
      while (__stlxr(v111 - 1, v110));
      if (!v111)
      {
        ((void (*)(std::__shared_weak_count *))v109->__on_zero_shared)(v109);
        std::__shared_weak_count::__release_weak(v109);
      }
    }
    if (v17 >= v167 * (unint64_t)v108 * v167 * (unint64_t)v108 / 0x64)
    {
      v112 = v171;
      v139 = (unint64_t *)&v171->__shared_owners_;
      v102 = 1;
      while (CFAbsoluteTimeGetCurrent() - Current < v66)
      {
        block[0] = 0;
        v140 = CFPreferencesGetAppIntegerValue(CFSTR("IVFSeedCentroidPerTraining"), CFSTR("com.apple.Spotlight"), block);
        if (block[0])
          v141 = v140;
        else
          v141 = 60;
        v142 = 2 * (v165 - v108);
        if (v141 <= v142)
          v143 = v142;
        else
          v143 = v141;
        v177 = v170;
        v178 = v112;
        if (v112)
        {
          do
            v144 = __ldxr(v139);
          while (__stxr(v144 + 1, v139));
        }
        memset(buf, 0, 24);
        if (v172 == v10)
        {
          v145 = 0;
        }
        else
        {
          if ((__sz & 0x8000000000000000) != 0)
            goto LABEL_251;
          v145 = (char *)operator new(__sz);
          *(_QWORD *)buf = v145;
          *(_QWORD *)&buf[16] = &v145[8 * v169];
          memcpy(v145, v10, __sz);
          *(_QWORD *)&buf[8] = &v145[8 * v169];
        }
        block[0] = 0;
        v146 = CFPreferencesGetAppIntegerValue(CFSTR("IVFPartitionRecycleTheshold"), CFSTR("com.apple.Spotlight"), block);
        if (block[0])
          v147 = v146;
        else
          v147 = 3;
        v148 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRootBase::trainOnce(&v177, (std::string::size_type *)buf, v143, v147);
        if (v145)
        {
          *(_QWORD *)&buf[8] = v145;
          operator delete(v145);
        }
        if (v171)
        {
          do
            v149 = __ldaxr(v139);
          while (__stlxr(v149 - 1, v139));
          if (!v149)
          {
            ((void (*)(std::__shared_weak_count *))v171->__on_zero_shared)(v171);
            std::__shared_weak_count::__release_weak(v171);
          }
        }
        ++v102;
        if (!v148)
          goto LABEL_169;
        QuantizerManager<float,768>::lastTrainedQuantizer(block, v170);
        v108 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)block + 24))(*(_QWORD *)block);
        v150 = (std::__shared_weak_count *)v206;
        if (v206)
        {
          v151 = (unint64_t *)(v206 + 8);
          do
            v152 = __ldaxr(v151);
          while (__stlxr(v152 - 1, v151));
          if (!v152)
          {
            ((void (*)(std::__shared_weak_count *))v150->__on_zero_shared)(v150);
            std::__shared_weak_count::__release_weak(v150);
          }
        }
        v112 = v171;
        if (v17 < v167 * (unint64_t)v108 * v167 * (unint64_t)v108 / 0x64)
          break;
      }
    }
    else
    {
      v102 = 1;
      v112 = v171;
    }
    v113 = (unint64_t *)&v112->__shared_owners_;
    while (1)
    {
      if (CFAbsoluteTimeGetCurrent() - Current >= v66)
        goto LABEL_169;
      v176[0] = v170;
      v176[1] = (uint64_t)v171;
      if (v171)
      {
        do
          v114 = __ldxr(v113);
        while (__stxr(v114 + 1, v113));
      }
      v173 = 0;
      v174 = 0;
      v175 = 0;
      if (v172 != v10)
        break;
      v116 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRootBase::trainOnce(v176, (std::string::size_type *)&v173, 0, 2u);
      if (v171)
        goto LABEL_159;
LABEL_162:
      ++v102;
      if (v116)
      {
        block[0] = 0;
        v118 = CFPreferencesGetAppIntegerValue(CFSTR("IVFMaxTrainingIteration"), CFSTR("com.apple.Spotlight"), block);
        v119 = block[0] ? v118 : 3;
        if (v102 <= v119)
          continue;
      }
      goto LABEL_169;
    }
    if ((__sz & 0x8000000000000000) != 0)
      goto LABEL_251;
    v115 = (char *)operator new(__sz);
    v173 = v115;
    v175 = &v115[8 * v169];
    memcpy(v115, v10, __sz);
    v174 = &v115[8 * v169];
    v116 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRootBase::trainOnce(v176, (std::string::size_type *)&v173, 0, 2u);
    v174 = v115;
    operator delete(v115);
    if (!v171)
      goto LABEL_162;
    do
LABEL_159:
      v117 = __ldaxr(v113);
    while (__stlxr(v117 - 1, v113));
    if (!v117)
    {
      ((void (*)(std::__shared_weak_count *))v171->__on_zero_shared)(v171);
      std::__shared_weak_count::__release_weak(v171);
    }
    goto LABEL_162;
  }
  v102 = 1;
LABEL_169:
  v120 = atomic_load(v67);
  if ((v120 & 1) == 0)
  {
    v160 = __si_assert_copy_extra_268();
    v154 = v160;
    v161 = "";
    if (v160)
      v161 = v160;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 794, "_training.test()", v161);
    goto LABEL_239;
  }
  if (*(_QWORD *)(v170 + 96))
  {
    v121 = *(NSObject **)(v170 + 16);
    *(_QWORD *)block = MEMORY[0x1E0C809B0];
    v206 = 0x40000000;
    *(_QWORD *)v207 = ___ZN16QuantizerManagerIfLi768EE23commitTrainingQuantizerEv_block_invoke;
    *(_QWORD *)&v207[8] = &__block_descriptor_tmp_798;
    *(_QWORD *)&v207[16] = v170;
    dispatch_sync(v121, block);
  }
  atomic_store(0, (unsigned __int8 *)(v170 + 72));
  QuantizerManager<float,768>::sharedQuantizer(block, v170, 0);
  v122 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)block + 24))(*(_QWORD *)block);
  v123 = (std::__shared_weak_count *)v206;
  if (v206)
  {
    v124 = (unint64_t *)(v206 + 8);
    do
      v125 = __ldaxr(v124);
    while (__stlxr(v125 - 1, v124));
    if (!v125)
    {
      ((void (*)(std::__shared_weak_count *))v123->__on_zero_shared)(v123);
      std::__shared_weak_count::__release_weak(v123);
    }
  }
  v126 = _SILogForLogForCategory(0);
  if (v163 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v127 = v126;
    if (os_signpost_enabled(v126))
    {
      *(_WORD *)block = 0;
      _os_signpost_emit_with_name_impl(&dword_1B8270000, v127, OS_SIGNPOST_INTERVAL_END, spid, "IVFVectorIndexTrain", "End", block, 2u);
    }
  }
  v128 = *__error();
  v129 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v129, OS_LOG_TYPE_DEFAULT))
  {
    v130 = CFAbsoluteTimeGetCurrent();
    *(_DWORD *)block = 67110144;
    *(_DWORD *)&block[4] = v17;
    LOWORD(v206) = 1024;
    *(_DWORD *)((char *)&v206 + 2) = v122;
    HIWORD(v206) = 1024;
    *(_DWORD *)v207 = v17 / v122;
    *(_WORD *)&v207[4] = 1024;
    *(_DWORD *)&v207[6] = v102;
    *(_WORD *)&v207[10] = 2048;
    *(double *)&v207[12] = v130 - Current;
    _os_log_impl(&dword_1B8270000, v129, OS_LOG_TYPE_DEFAULT, "training quantizer for %u vectors in %u partitions average size: %u for %u iterations duration: %fs", block, 0x24u);
  }
  *__error() = v128;
  *(_QWORD *)keyExistsAndHasValidFormat = *MEMORY[0x1E0DE4F50];
  v131 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 72);
  *(_QWORD *)&keyExistsAndHasValidFormat[*(_QWORD *)(*(_QWORD *)keyExistsAndHasValidFormat - 24)] = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 64);
  v181 = v131;
  *(_QWORD *)&v182[0] = MEMORY[0x1E0DE4FB8] + 16;
  if (SBYTE7(v184) < 0)
    operator delete((void *)__p);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x1BCCB0650](&v186);
  v87 = v171;
  if (!v13)
  {
LABEL_109:
    v88 = v203;
    if (!v203)
      goto LABEL_198;
    goto LABEL_194;
  }
LABEL_187:
  while (v14 != v13)
  {
    v132 = (std::__shared_weak_count *)*((_QWORD *)v14 - 1);
    if (v132)
    {
      v133 = (unint64_t *)&v132->__shared_owners_;
      do
        v134 = __ldaxr(v133);
      while (__stlxr(v134 - 1, v133));
      if (!v134)
      {
        ((void (*)(std::__shared_weak_count *))v132->__on_zero_shared)(v132);
        std::__shared_weak_count::__release_weak(v132);
      }
    }
    v14 -= 16;
  }
  operator delete(v13);
  v88 = v203;
  if (v203)
  {
LABEL_194:
    v135 = (unint64_t *)&v88->__shared_owners_;
    do
      v136 = __ldaxr(v135);
    while (__stlxr(v136 - 1, v135));
    if (!v136)
    {
      ((void (*)(std::__shared_weak_count *))v88->__on_zero_shared)(v88);
      std::__shared_weak_count::__release_weak(v88);
    }
  }
LABEL_198:
  if (v10)
    operator delete(v10);
  if (v87)
  {
    v137 = (unint64_t *)&v87->__shared_owners_;
    do
      v138 = __ldaxr(v137);
    while (__stlxr(v138 - 1, v137));
    if (!v138)
    {
      ((void (*)(std::__shared_weak_count *))v87->__on_zero_shared)(v87);
      std::__shared_weak_count::__release_weak(v87);
    }
  }
}

uint64_t IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::enumerator_s::enumerator_s(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  int v12;
  NSObject *v13;
  int v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  __int128 v25;
  int v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)a1 = *a2;
  v6 = a2[1];
  *(_QWORD *)(a1 + 8) = v6;
  if (v6)
  {
    v7 = (unint64_t *)(v6 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  *(_QWORD *)(a1 + 16) = *a3;
  v9 = a3[1];
  *(_QWORD *)(a1 + 24) = v9;
  if (v9)
  {
    v10 = (unint64_t *)(v9 + 8);
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  v12 = *__error();
  v13 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    v14 = *(_DWORD *)(*a3 + 40);
    v15 = *(_DWORD *)(*a2 + 68);
    v16 = *(_DWORD *)(*a2 + 76);
    LODWORD(v25) = 67109632;
    DWORD1(v25) = v14;
    WORD4(v25) = 1024;
    *(_DWORD *)((char *)&v25 + 10) = v15;
    HIWORD(v25) = 1024;
    v26 = v16;
    _os_log_impl(&dword_1B8270000, v13, OS_LOG_TYPE_DEFAULT, "enumerator %u vectors in %u partitions v%d.", (uint8_t *)&v25, 0x14u);
  }
  *__error() = v12;
  v17 = *a2;
  if (*(_DWORD *)(*a2 + 68))
  {
    v18 = 0;
    do
    {
      (*(void (**)(__int128 *__return_ptr, uint64_t, uint64_t))(*(_QWORD *)v17 + 96))(&v25, v17, v18);
      v19 = *(_QWORD *)(a1 + 48);
      v20 = *(_QWORD *)(a1 + 40);
      if (v19 == v20)
        v21 = 0;
      else
        v21 = 32 * (v19 - v20) - 1;
      v22 = *(_QWORD *)(a1 + 72);
      v23 = v22 + *(_QWORD *)(a1 + 64);
      if (v21 == v23)
      {
        std::deque<std::shared_ptr<AnyPartitionStore::Enumerator>>::__add_back_capacity(a1 + 32);
        v20 = *(_QWORD *)(a1 + 40);
        v22 = *(_QWORD *)(a1 + 72);
        v23 = v22 + *(_QWORD *)(a1 + 64);
      }
      *(_OWORD *)(*(_QWORD *)(v20 + ((v23 >> 5) & 0x7FFFFFFFFFFFFF8)) + 16 * v23) = v25;
      *(_QWORD *)(a1 + 72) = v22 + 1;
      v17 = *a2;
      v18 = (v18 + 1);
    }
    while (v18 < *(_DWORD *)(*a2 + 68));
  }
  return a1;
}

void IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::enumerator_s::next(uint64_t a1, uint64_t a2)
{
  uint64_t i;
  uint64_t v5;
  unsigned int *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  if (*(_QWORD *)(a2 + 72))
  {
    for (i = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + ((*(_QWORD *)(a2 + 64) >> 5) & 0x7FFFFFFFFFFFFF8))
                        + 16 * *(_QWORD *)(a2 + 64));
          ;
          i = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + ((v11 >> 5) & 0x7FFFFFFFFFFFFF8))
                        + 16 * v11))
    {
      *(_DWORD *)a1 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)i + 16))(i);
      if (!*(_QWORD *)(a2 + 72))
        break;
      v5 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + ((*(_QWORD *)(a2 + 64) >> 5) & 0x7FFFFFFFFFFFFF8))
                     + 16 * *(_QWORD *)(a2 + 64));
      v6 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 24))(v5);
      if (v6)
      {
        *(_DWORD *)(a1 + 4) = v6[1];
        v12 = _windowsResolvePtr(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 32) + 40, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 32) + 24)+ *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 32) + 16) * *v6, 0xC10uLL);
        *(_DWORD *)(a1 + 8) = *(_DWORD *)(v12 + 3080);
        *(_QWORD *)(a1 + 16) = v12;
        *(_QWORD *)(a1 + 24) = v12 + 3072;
        return;
      }
      v7 = *(std::__shared_weak_count **)(*(_QWORD *)(*(_QWORD *)(a2 + 40)
                                                    + ((*(_QWORD *)(a2 + 64) >> 5) & 0x7FFFFFFFFFFFFF8))
                                        + 16 * *(_QWORD *)(a2 + 64)
                                        + 8);
      if (v7)
      {
        p_shared_owners = (unint64_t *)&v7->__shared_owners_;
        do
          v9 = __ldaxr(p_shared_owners);
        while (__stlxr(v9 - 1, p_shared_owners));
        if (!v9)
        {
          ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
          std::__shared_weak_count::__release_weak(v7);
        }
      }
      v10 = *(_QWORD *)(a2 + 72) - 1;
      v11 = *(_QWORD *)(a2 + 64) + 1;
      *(_QWORD *)(a2 + 64) = v11;
      *(_QWORD *)(a2 + 72) = v10;
      if (v11 >= 0x200)
      {
        operator delete(**(void ***)(a2 + 40));
        *(_QWORD *)(a2 + 40) += 8;
        v10 = *(_QWORD *)(a2 + 72);
        v11 = *(_QWORD *)(a2 + 64) - 256;
        *(_QWORD *)(a2 + 64) = v11;
      }
      if (!v10)
        return;
    }
  }
}

uint64_t std::deque<std::shared_ptr<AnyPartitionStore::Enumerator>>::~deque[abi:nn180100](uint64_t a1)
{
  void **v2;
  void **v3;
  _QWORD *v4;
  unint64_t v5;
  void **v6;
  uint64_t v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;

  v2 = *(void ***)(a1 + 8);
  v3 = *(void ***)(a1 + 16);
  if (v3 == v2)
  {
    v4 = (_QWORD *)(a1 + 40);
    v3 = *(void ***)(a1 + 8);
  }
  else
  {
    v4 = (_QWORD *)(a1 + 40);
    v5 = *(_QWORD *)(a1 + 32);
    v6 = &v2[v5 >> 8];
    v7 = (uint64_t)*v6 + 16 * v5;
    v8 = *(uint64_t *)((char *)v2 + (((*(_QWORD *)(a1 + 40) + v5) >> 5) & 0x7FFFFFFFFFFFFF8))
       + 16 * (*(_BYTE *)(a1 + 40) + v5);
    if (v7 != v8)
    {
      do
      {
        v9 = *(std::__shared_weak_count **)(v7 + 8);
        if (v9)
        {
          p_shared_owners = (unint64_t *)&v9->__shared_owners_;
          do
            v11 = __ldaxr(p_shared_owners);
          while (__stlxr(v11 - 1, p_shared_owners));
          if (!v11)
          {
            ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
            std::__shared_weak_count::__release_weak(v9);
          }
        }
        v7 += 16;
        if (v7 - (_QWORD)*v6 == 4096)
        {
          v12 = (uint64_t)v6[1];
          ++v6;
          v7 = v12;
        }
      }
      while (v7 != v8);
      v2 = *(void ***)(a1 + 8);
      v3 = *(void ***)(a1 + 16);
    }
  }
  *v4 = 0;
  v13 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      v3 = *(void ***)(a1 + 16);
      v2 = (void **)(*(_QWORD *)(a1 + 8) + 8);
      *(_QWORD *)(a1 + 8) = v2;
      v13 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  v14 = v13 >> 3;
  if (v14 == 1)
  {
    v15 = 128;
    goto LABEL_20;
  }
  if (v14 == 2)
  {
    v15 = 256;
LABEL_20:
    *(_QWORD *)(a1 + 32) = v15;
  }
  if (v2 != v3)
  {
    do
    {
      v16 = *v2++;
      operator delete(v16);
    }
    while (v2 != v3);
    v18 = *(_QWORD *)(a1 + 8);
    v17 = *(_QWORD *)(a1 + 16);
    if (v17 != v18)
      *(_QWORD *)(a1 + 16) = v17 + ((v18 - v17 + 7) & 0xFFFFFFFFFFFFFFF8);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

_DWORD *IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::lookupForInsert(uint64_t a1, unsigned int a2, void *a3, uint64_t a4, char a5, float a6)
{
  uint64_t v9;
  unsigned int Vector;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  _DWORD *v16;
  const UInt8 *data;
  int v18;
  NSObject *v19;
  int v20;
  NSObject *v21;
  int v22;
  NSObject *v23;
  _BYTE *v24;
  int v25;
  NSObject *v26;
  _BYTE *v27;
  std::__shared_weak_count *v28;
  unint64_t *p_shared_owners;
  unint64_t v30;
  std::__shared_weak_count *v31;
  _DWORD *v32;
  unint64_t *v33;
  unint64_t v34;
  uint64_t v35;
  _QWORD *v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  NSObject *v44;
  const UInt8 *v45;
  int v46;
  NSObject *v47;
  size_t v48;
  int v49;
  NSObject *v50;
  int v51;
  NSObject *v52;
  _BYTE *v53;
  int v54;
  NSObject *v55;
  _BYTE *v56;
  NSObject *v57;
  int v58;
  NSObject *v59;
  int v60;
  int v61;
  char *v62;
  char *v63;
  const char *v64;
  char *v65;
  char *v66;
  const char *v67;
  uint64_t v68;
  uint64_t v69;
  unint64_t v70;
  unsigned int v71;
  unint64_t v72;
  uint64_t v73;
  unint64_t v74;
  int v75;
  NSObject *v76;
  _QWORD *v77;
  int v78;
  NSObject *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  _QWORD *v84;
  uint64_t v85;
  uint64_t v86;
  unint64_t v87;
  uint64_t v88;
  unint64_t v89;
  unint64_t *v90;
  unint64_t v91;
  unint64_t *v92;
  unint64_t v93;
  int v95;
  char *v96;
  const char *v97;
  char *v98;
  const char *v99;
  char *v100;
  const char *v101;
  char *v102;
  const char *v103;
  char *v104;
  const char *v105;
  std::__shared_weak_count *v106;
  unsigned int v107;
  void *__src;
  uint64_t v109;
  float v110;
  unsigned int v111;
  uint8_t buf[4];
  _BYTE *v113;
  _BYTE __p[12];
  __int16 v115;
  _BYTE v116[20];
  _BYTE v117[10];
  uint64_t v118;
  uint64_t v119;

  v119 = *MEMORY[0x1E0C80C00];
  v111 = a4;
  v110 = a6;
  if (*(_BYTE *)(a1 + 160))
  {
    v62 = __si_assert_copy_extra_268();
    v63 = v62;
    v64 = "";
    if (v62)
      v64 = v62;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2430, "!readOnly", v64);
    goto LABEL_121;
  }
  if ((a5 & 1) != 0)
  {
    v9 = a4;
    if ((_DWORD)a4 == -1)
      goto LABEL_79;
    goto LABEL_30;
  }
  Vector = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::findVector(a1, (uint64_t)a3, (int *)&v111, &v110, a2);
  v9 = v111;
  if (v111 == -1)
  {
LABEL_79:
    v65 = __si_assert_copy_extra_268();
    v66 = v65;
    v67 = "";
    if (v65)
      v67 = v65;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2435, "partID != VECTOR_NOT_FOUND", v67);
    goto LABEL_82;
  }
  if (Vector == -1)
  {
LABEL_30:
    __src = a3;
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 112));
    v28 = *(std::__shared_weak_count **)(a1 + 88);
    if (v28)
    {
      p_shared_owners = (unint64_t *)&v28->__shared_owners_;
      do
        v30 = __ldxr(p_shared_owners);
      while (__stxr(v30 + 1, p_shared_owners));
    }
    v106 = v28;
    v32 = *(_DWORD **)(a1 + 96);
    v31 = *(std::__shared_weak_count **)(a1 + 104);
    if (v31)
    {
      v33 = (unint64_t *)&v31->__shared_owners_;
      do
        v34 = __ldxr(v33);
      while (__stxr(v34 + 1, v33));
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 112));
    v35 = *(_QWORD *)(a1 + 48);
    v36 = *(_QWORD **)(v35 + 32);
    v37 = v36[2];
    v38 = v36[7];
    v39 = v38 + v37;
    v107 = a2;
    if (v38 + v37 >= v36[6])
    {
      if (!_storage_array_Expand((uint64_t)(v36 + 1)))
      {
        v40 = 0;
        if (v37 > 0xC0F)
          goto LABEL_89;
        goto LABEL_38;
      }
      v38 = v36[7];
      v39 = v38 + v37;
    }
    v36[7] = v39;
    v40 = (v38 - v36[3]) / v37;
    if (v37 > 0xC0F)
      goto LABEL_89;
LABEL_38:
    v41 = v36[2];
    if (v41 <= 0xC0F)
    {
      LODWORD(v42) = 3088;
      do
      {
        v43 = v36[7] + v41;
        if (v43 >= v36[6])
        {
          if (!_storage_array_Expand((uint64_t)(v36 + 1)))
            goto LABEL_42;
          v43 = v36[7] + v41;
        }
        v36[7] = v43;
LABEL_42:
        v41 = v36[2];
        v42 = (v42 - v41);
      }
      while (v41 < v42);
    }
LABEL_89:
    v69 = (uint64_t)(v36 + 524);
    bit_vector_set_9027((uint64_t)(v36 + 524), (v40 >> 20));
    v70 = (v40 + 3088) >> 20;
    if (v70 > (v40 >> 20))
    {
      v71 = (v40 >> 20) + 1;
      do
      {
        v72 = v71;
        bit_vector_set_9027(v69, v71++);
      }
      while (v70 > v72);
    }
    v73 = *(unsigned int *)(v35 + 40);
    v74 = v40;
    if (v40 != v73)
    {
      v75 = *__error();
      v76 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v76, OS_LOG_TYPE_ERROR))
      {
        v95 = *(_DWORD *)(v35 + 40);
        *(_DWORD *)__p = 136315906;
        *(_QWORD *)&__p[4] = "newEntry";
        v115 = 1024;
        *(_DWORD *)v116 = 1779;
        *(_WORD *)&v116[4] = 2048;
        *(_QWORD *)&v116[6] = v40;
        *(_WORD *)&v116[14] = 1024;
        *(_DWORD *)&v116[16] = v95;
        _os_log_error_impl(&dword_1B8270000, v76, OS_LOG_TYPE_ERROR, "%s:%d: offset: %llu, nVectors: %u", __p, 0x22u);
      }
      *__error() = v75;
      v77 = *(_QWORD **)(v35 + 32);
      v78 = *__error();
      v79 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v79, OS_LOG_TYPE_DEFAULT))
      {
        v80 = v77[6];
        v81 = v77[7];
        v83 = v77[2];
        v82 = v77[3];
        *(_DWORD *)__p = 134219008;
        *(_QWORD *)&__p[4] = v77;
        v115 = 2048;
        *(_QWORD *)v116 = v80;
        *(_WORD *)&v116[8] = 2048;
        *(_QWORD *)&v116[10] = v81;
        *(_WORD *)&v116[18] = 2048;
        *(_QWORD *)v117 = v82;
        *(_WORD *)&v117[8] = 2048;
        v118 = v83;
        _os_log_impl(&dword_1B8270000, v79, OS_LOG_TYPE_DEFAULT, "vi_onefixedsize_disk_allocator %p size: %llu, freeRegion: %llu, header: %llu, elemSize: %lu", __p, 0x34u);
      }
      *__error() = v78;
      v74 = *(unsigned int *)(v35 + 40);
      LODWORD(v73) = *(_DWORD *)(v35 + 40);
    }
    if (v40 == v74)
    {
      *(_DWORD *)(v35 + 40) = v73 + 1;
      v84 = (_QWORD *)_windowsResolvePtr(*(_QWORD *)(v35 + 32) + 40, *(_QWORD *)(*(_QWORD *)(v35 + 32) + 24) + *(_QWORD *)(*(_QWORD *)(v35 + 32) + 16) * v40, 0xC10uLL);
      memcpy(v84, __src, 0xC00uLL);
      v84[384] = 0;
      (*(void (**)(_DWORD *, uint64_t, unint64_t, float))(*(_QWORD *)v32 + 56))(v32, v9, v40, v110);
      v85 = *(_QWORD *)(a1 + 48);
      if (v32[18] == *(_DWORD *)(v85 + 40))
      {
        v86 = v40;
        v87 = v40 >> 20;
        v88 = *(_QWORD *)(v85 + 32) + 4192;
        bit_vector_set_9027(v88, v87);
        v89 = ((unint64_t)v40 + 3088) >> 20;
        if (v89 > v87)
        {
          do
            bit_vector_set_9027(v88, ++v87);
          while (v89 != v87);
        }
        v16 = (_DWORD *)_windowsResolvePtr(*(_QWORD *)(v85 + 32) + 40, *(_QWORD *)(*(_QWORD *)(v85 + 32) + 24) + *(_QWORD *)(*(_QWORD *)(v85 + 32) + 16) * v86, 0xC10uLL);
        v16[770] = v107;
        if (*(_DWORD *)(*(_QWORD *)(a1 + 48) + 40) == 1)
          *(_DWORD *)(a1 + 164) = v107;
        *(_DWORD *)(a1 + 168) = v107;
        data_map_set_offset_for_id(*(_QWORD *)(a1 + 144), v107, (16 * v86) | ((unint64_t)*(unsigned int *)(a1 + 40) << 36) | (4 * (*(_DWORD *)(a1 + 128) & 3)) | *(_DWORD *)(a1 + 124) & 3, *(unsigned __int16 *)(a1 + 120) | ((unint64_t)*(unsigned int *)(a1 + 132) << 32), *(_DWORD *)(a1 + 136));
        if (v31)
        {
          v90 = (unint64_t *)&v31->__shared_owners_;
          do
            v91 = __ldaxr(v90);
          while (__stlxr(v91 - 1, v90));
          if (!v91)
          {
            ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
            std::__shared_weak_count::__release_weak(v31);
          }
        }
        if (v106)
        {
          v92 = (unint64_t *)&v106->__shared_owners_;
          do
            v93 = __ldaxr(v92);
          while (__stlxr(v93 - 1, v92));
          if (!v93)
          {
            ((void (*)(std::__shared_weak_count *))v106->__on_zero_shared)(v106);
            std::__shared_weak_count::__release_weak(v106);
          }
        }
        return v16;
      }
      v98 = __si_assert_copy_extra_268();
      v63 = v98;
      v99 = "";
      if (v98)
        v99 = v98;
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2440, "cur.partitions->nVectors() == vectors->count()", v99);
    }
    else
    {
      v96 = __si_assert_copy_extra_268();
      v63 = v96;
      v97 = "";
      if (v96)
        v97 = v96;
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1782, "offset == nVectors", v97);
    }
LABEL_121:
    free(v63);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v11 = *(_QWORD *)(a1 + 48);
  v12 = Vector;
  v13 = (unint64_t)Vector >> 20;
  v14 = *(_QWORD *)(v11 + 32) + 4192;
  bit_vector_set_9027(v14, v13);
  v15 = (unint64_t)(v12 + 3088) >> 20;
  if (v15 > v13)
  {
    do
      bit_vector_set_9027(v14, ++v13);
    while (v15 != v13);
  }
  v16 = (_DWORD *)_windowsResolvePtr(*(_QWORD *)(v11 + 32) + 40, *(_QWORD *)(*(_QWORD *)(v11 + 32) + 24) + *(_QWORD *)(*(_QWORD *)(v11 + 32) + 16) * v12, 0xC10uLL);
  if (v16[770] != a2)
  {
    v109 = 0;
    data = data_map_get_data(*(_QWORD *)(a1 + 144), a2, &v109);
    v18 = *__error();
    v19 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__p = 136316162;
      *(_QWORD *)&__p[4] = "lookupForInsert";
      v115 = 1024;
      *(_DWORD *)v116 = 2463;
      *(_WORD *)&v116[4] = 1024;
      *(_DWORD *)&v116[6] = a2;
      *(_WORD *)&v116[10] = 2048;
      *(_QWORD *)&v116[12] = data;
      *(_WORD *)v117 = 2048;
      *(_QWORD *)&v117[2] = v109;
      _os_log_error_impl(&dword_1B8270000, v19, OS_LOG_TYPE_ERROR, "%s:%d: vectorId=%u in datamap: %p size=%zd", __p, 0x2Cu);
    }
    *__error() = v18;
    if (v109 < 1)
    {
      v25 = *__error();
      v44 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__p = 136315394;
        *(_QWORD *)&__p[4] = "lookupForInsert";
        v115 = 1024;
        *(_DWORD *)v116 = 2472;
        _os_log_error_impl(&dword_1B8270000, v44, OS_LOG_TYPE_ERROR, "%s:%d: vectorId is invalid", __p, 0x12u);
      }
    }
    else
    {
      if (v109 != 3072)
      {
        v102 = __si_assert_copy_extra_268();
        v63 = v102;
        v103 = "";
        if (v102)
          v103 = v102;
        __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2465, "size == D * sizeof(ELEM_TYPE)", v103);
        goto LABEL_121;
      }
      if (!data || !memcmp(data, a3, 0xC00uLL))
      {
LABEL_49:
        v45 = data_map_get_data(*(_QWORD *)(a1 + 144), v16[770], &v109);
        v46 = *__error();
        v47 = _SILogForLogForCategory(16);
        if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
        {
          v60 = v16[770];
          *(_DWORD *)__p = 136316162;
          *(_QWORD *)&__p[4] = "lookupForInsert";
          v115 = 1024;
          *(_DWORD *)v116 = 2475;
          *(_WORD *)&v116[4] = 1024;
          *(_DWORD *)&v116[6] = v60;
          *(_WORD *)&v116[10] = 2048;
          *(_QWORD *)&v116[12] = v45;
          *(_WORD *)v117 = 2048;
          *(_QWORD *)&v117[2] = v109;
          _os_log_error_impl(&dword_1B8270000, v47, OS_LOG_TYPE_ERROR, "%s:%d: old vectorId=%u in datamap: %p size=%zd", __p, 0x2Cu);
        }
        *__error() = v46;
        if (v109 < 1)
        {
          v54 = *__error();
          v57 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)__p = 136315394;
            *(_QWORD *)&__p[4] = "lookupForInsert";
            v115 = 1024;
            *(_DWORD *)v116 = 2484;
            _os_log_error_impl(&dword_1B8270000, v57, OS_LOG_TYPE_ERROR, "%s:%d: old vectorId is invalid", __p, 0x12u);
          }
        }
        else
        {
          if (v109 != 3072)
          {
            v104 = __si_assert_copy_extra_268();
            v63 = v104;
            v105 = "";
            if (v104)
              v105 = v104;
            __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2477, "size == D * sizeof(ELEM_TYPE)", v105);
            goto LABEL_121;
          }
          v48 = 3072;
          if (!v45 || !memcmp(v45, v16, 0xC00uLL))
            goto LABEL_72;
          v49 = *__error();
          v50 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)__p = 136315394;
            *(_QWORD *)&__p[4] = "lookupForInsert";
            v115 = 1024;
            *(_DWORD *)v116 = 2479;
            _os_log_error_impl(&dword_1B8270000, v50, OS_LOG_TYPE_ERROR, "%s:%d: vector in datamap is not same as vector passed in", __p, 0x12u);
          }
          *__error() = v49;
          v51 = *__error();
          v52 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
          {
            data2hexString(__p, (uint64_t)v45, v109);
            v53 = v116[9] >= 0 ? __p : *(_BYTE **)__p;
            *(_DWORD *)buf = 136315138;
            v113 = v53;
            _os_log_impl(&dword_1B8270000, v52, OS_LOG_TYPE_DEFAULT, "vector in datamap: %s", buf, 0xCu);
            if ((v116[9] & 0x80000000) != 0)
              operator delete(*(void **)__p);
          }
          *__error() = v51;
          v54 = *__error();
          v55 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
          {
            data2hexString(__p, (uint64_t)v16, v109);
            v56 = v116[9] >= 0 ? __p : *(_BYTE **)__p;
            *(_DWORD *)buf = 136315138;
            v113 = v56;
            _os_log_impl(&dword_1B8270000, v55, OS_LOG_TYPE_DEFAULT, "vector in vector store: %s", buf, 0xCu);
            if ((v116[9] & 0x80000000) != 0)
              operator delete(*(void **)__p);
          }
        }
        *__error() = v54;
        v48 = v109;
LABEL_72:
        if (memcmp(a3, v16, v48))
        {
          v100 = __si_assert_copy_extra_268();
          v66 = v100;
          v101 = "";
          if (v100)
            v101 = v100;
          __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2486, "memcmp(vec.vec, entry->vec.vec, size) == 0", v101);
LABEL_82:
          free(v66);
          if (__valid_fs(-1))
            v68 = 2989;
          else
            v68 = 3072;
          *(_DWORD *)v68 = -559038737;
          abort();
        }
        v58 = *__error();
        v59 = _SILogForLogForCategory(16);
        if (os_log_type_enabled(v59, OS_LOG_TYPE_FAULT))
        {
          v61 = v16[770];
          *(_DWORD *)__p = 136315906;
          *(_QWORD *)&__p[4] = "lookupForInsert";
          v115 = 1024;
          *(_DWORD *)v116 = 2487;
          *(_WORD *)&v116[4] = 1024;
          *(_DWORD *)&v116[6] = a2;
          *(_WORD *)&v116[10] = 1024;
          *(_DWORD *)&v116[12] = v61;
          _os_log_fault_impl(&dword_1B8270000, v59, OS_LOG_TYPE_FAULT, "%s:%d: Dup vector with new vectorId=%u old=%u", __p, 0x1Eu);
        }
        *__error() = v58;
        return v16;
      }
      v20 = *__error();
      v21 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__p = 136315394;
        *(_QWORD *)&__p[4] = "lookupForInsert";
        v115 = 1024;
        *(_DWORD *)v116 = 2467;
        _os_log_error_impl(&dword_1B8270000, v21, OS_LOG_TYPE_ERROR, "%s:%d: vector in datamap is not same as vector passed in", __p, 0x12u);
      }
      *__error() = v20;
      v22 = *__error();
      v23 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        data2hexString(__p, (uint64_t)data, v109);
        v24 = v116[9] >= 0 ? __p : *(_BYTE **)__p;
        *(_DWORD *)buf = 136315138;
        v113 = v24;
        _os_log_impl(&dword_1B8270000, v23, OS_LOG_TYPE_DEFAULT, "vector in datamap: %s", buf, 0xCu);
        if ((v116[9] & 0x80000000) != 0)
          operator delete(*(void **)__p);
      }
      *__error() = v22;
      v25 = *__error();
      v26 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        data2hexString(__p, (uint64_t)a3, v109);
        v27 = v116[9] >= 0 ? __p : *(_BYTE **)__p;
        *(_DWORD *)buf = 136315138;
        v113 = v27;
        _os_log_impl(&dword_1B8270000, v26, OS_LOG_TYPE_DEFAULT, "vector passed in: %s", buf, 0xCu);
        if ((v116[9] & 0x80000000) != 0)
          operator delete(*(void **)__p);
      }
    }
    *__error() = v25;
    goto LABEL_49;
  }
  return v16;
}

uint64_t IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::findVector(uint64_t a1, uint64_t a2, int *a3, _DWORD *a4, int a5)
{
  os_unfair_lock_s *v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  std::__shared_weak_count *v15;
  _DWORD *v16;
  unint64_t *v17;
  unint64_t v18;
  uint64_t v19;
  _DWORD *v20;
  unsigned int v21;
  uint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  unint64_t *v25;
  unint64_t v26;
  char *v28;
  char *v29;
  const char *v30;
  char *v31;
  const char *v32;
  char *v33;
  char *v34;
  const char *v35;
  int v36;
  int v37;
  int v38;
  int v39;
  _QWORD v40[8];
  int v41;
  _DWORD *v42;
  char *v43;
  uint64_t v44;
  int v45;

  v10 = (os_unfair_lock_s *)(a1 + 112);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 112));
  v12 = *(_QWORD *)(a1 + 80);
  v11 = *(std::__shared_weak_count **)(a1 + 88);
  if (v11)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      v14 = __ldxr(p_shared_owners);
    while (__stxr(v14 + 1, p_shared_owners));
  }
  v16 = *(_DWORD **)(a1 + 96);
  v15 = *(std::__shared_weak_count **)(a1 + 104);
  if (v15)
  {
    v17 = (unint64_t *)&v15->__shared_owners_;
    do
      v18 = __ldxr(v17);
    while (__stxr(v18 + 1, v17));
  }
  os_unfair_lock_unlock(v10);
  v19 = *a3;
  if ((_DWORD)v19 == -1)
  {
    if (*(_DWORD *)(a1 + 156) == -1)
    {
      v42 = 0;
      v43 = 0;
      v44 = 0;
      (*(void (**)(_DWORD **__return_ptr, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v12 + 72))(&v42, v12, a2, 1);
      v20 = v42;
      if (v43 - (char *)v42 == 8)
      {
        v21 = *v42;
        *a3 = *v42;
        *a4 = v20[1];
        if (v21 >= IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nPartitions(a1))
        {
          v33 = __si_assert_copy_extra_268();
          v34 = v33;
          if (v33)
            v35 = v33;
          else
            v35 = "";
          v36 = *a3;
          v37 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nPartitions(a1);
          v38 = v16[19];
          v39 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v12 + 16))(v12);
          __message_assert("%s:%u: failed assertion '%s' %s Invalid partId %u >= %u (partitions: v%u quantizer v%u", "IVFVectorIndex.hh", 2403, "partID < nPartitions()", v35, v36, v37, v38, v39);
          free(v34);
          if (__valid_fs(-1))
          {
            MEMORY[0xBAD] = -559038737;
            abort();
          }
          MEMORY[0xC00] = -559038737;
          abort();
        }
        if (v42)
        {
          v43 = (char *)v42;
          operator delete(v42);
        }
        v19 = *a3;
        goto LABEL_14;
      }
      v31 = __si_assert_copy_extra_268();
      v29 = v31;
      v32 = "";
      if (v31)
        v32 = v31;
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2398, "topPartition.size() == 1", v32);
    }
    else
    {
      v28 = __si_assert_copy_extra_268();
      v29 = v28;
      v30 = "";
      if (v28)
        v30 = v28;
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2396, "mergeBeginVectorOffset == VECTOR_NOT_FOUND", v30);
    }
    free(v29);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
LABEL_14:
  v42 = 0;
  v43 = (char *)&v42;
  v45 = -1;
  v44 = 0x2000000000;
  v40[0] = MEMORY[0x1E0C809B0];
  v40[1] = 0x40000000;
  v40[2] = ___ZN22IVFVectorIndexTemplateIfLi768EE20IVFVectorIndexRoot_sI30vi_onefixedsize_disk_allocator16vi_disk_postingsE10findVectorERK10CIVector_sIfLi768EERjRfj_block_invoke;
  v40[3] = &unk_1E6E333C8;
  v41 = a5;
  v40[6] = a4;
  v40[7] = a2;
  v40[4] = &v42;
  v40[5] = a1;
  (*(void (**)(_DWORD *, uint64_t, _QWORD *))(*(_QWORD *)v16 + 80))(v16, v19, v40);
  v22 = *((unsigned int *)v43 + 6);
  _Block_object_dispose(&v42, 8);
  if (v15)
  {
    v23 = (unint64_t *)&v15->__shared_owners_;
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  if (v11)
  {
    v25 = (unint64_t *)&v11->__shared_owners_;
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  return v22;
}

unint64_t ___ZN22IVFVectorIndexTemplateIfLi768EE20IVFVectorIndexRoot_sI30vi_onefixedsize_disk_allocator16vi_disk_postingsE10findVectorERK10CIVector_sIfLi768EERjRfj_block_invoke(unint64_t result, uint64_t a2, float *a3, _BYTE *a4)
{
  uint64_t v5;
  uint64_t v6;
  unint64_t v8;
  float v9;
  float v10;
  BOOL v11;
  float v12;
  float v13;
  int v15;
  const void *v16;
  const void *v17;

  v5 = *(_QWORD *)(result + 40);
  v6 = *(unsigned int *)a3;
  if (v6 >= *(_DWORD *)(v5 + 156))
    goto LABEL_12;
  v8 = result;
  v9 = **(float **)(result + 48);
  v10 = a3[1];
  v11 = v9 == v10;
  v12 = vabds_f32(v9, v10);
  v13 = fmaxf(fminf(fabsf(v10), fabsf(v9)) * 0.000015259, 0.000015259);
  if (v11 || v12 <= v13)
  {
    v15 = *(_DWORD *)(result + 64);
    if (v15)
    {
      result = _windowsResolvePtr(*(_QWORD *)(*(_QWORD *)(v5 + 48) + 32) + 40, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 48) + 32) + 24)+ *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 48) + 32) + 16) * v6, 0xC10uLL);
      if (v15 != *(_DWORD *)(result + 3080))
        return result;
      *(float *)&v6 = *a3;
    }
    v16 = *(const void **)(v8 + 56);
    v17 = (const void *)_windowsResolvePtr(*(_QWORD *)(*(_QWORD *)(v5 + 48) + 32) + 40, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 48) + 32) + 24)+ *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 48) + 32) + 16) * v6, 0xC10uLL);
    result = memcmp(v16, v17, 0xC00uLL);
    if (!(_DWORD)result)
    {
      *(float *)(*(_QWORD *)(*(_QWORD *)(v8 + 32) + 8) + 24) = *a3;
LABEL_12:
      *a4 = 1;
    }
  }
  return result;
}

void std::deque<std::shared_ptr<AnyPartitionStore::Enumerator>>::__add_back_capacity(uint64_t a1)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;
  char *v5;
  _QWORD *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  int64_t v16;
  char *v17;
  char *v18;
  char *v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  void *v24;
  void *v25;
  uint64_t v26;
  unint64_t v27;
  char *v28;
  char *v29;
  char *v30;
  void *v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  uint64_t v35;
  char *v36;
  char *v37;
  char *v38;
  BOOL v39;
  int64_t v40;
  unint64_t v41;
  char *v42;
  char *v43;
  unint64_t v44;
  uint64_t v45;
  char *v46;
  char *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  _OWORD *v52;
  unint64_t v53;
  unint64_t v54;
  uint64_t v55;
  char *v56;
  char *v57;
  int64_t v58;
  unint64_t v59;
  char *v60;
  char *v61;
  uint64_t v62;
  uint64_t v63;
  __int128 *v64;
  char *v65;
  uint64_t v66;
  __int128 v67;
  uint64_t v68;
  unint64_t v69;
  unint64_t v70;
  uint64_t v71;
  char *v72;
  char *v73;
  char *v74;
  char *v75;
  char *v76;
  char *v77;
  unint64_t v78;
  uint64_t v79;
  __int128 *v80;
  _OWORD *v81;
  uint64_t v82;
  __int128 v83;
  char *v84;
  uint64_t v85;
  uint64_t v86;
  __int128 *v87;
  _OWORD *v88;
  uint64_t v89;
  __int128 v90;
  uint64_t v91;
  uint64_t v92;
  unint64_t v93;
  unint64_t v94;
  uint64_t v95;
  int64_t v96;
  unint64_t v97;
  char *v98;
  char *v99;
  uint64_t v100;
  uint64_t v101;
  __int128 *v102;
  _OWORD *v103;
  uint64_t v104;
  __int128 v105;
  uint64_t v106;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = v2 >= 0x100;
  v4 = v2 - 256;
  if (v3)
  {
    *(_QWORD *)(a1 + 32) = v4;
    v6 = *(_QWORD **)(a1 + 8);
    v5 = *(char **)(a1 + 16);
    v7 = (char *)(v6 + 1);
    v8 = *v6;
    *(_QWORD *)(a1 + 8) = v6 + 1;
    if (v5 != *(char **)(a1 + 24))
    {
LABEL_83:
      *(_QWORD *)v5 = v8;
      goto LABEL_84;
    }
    v9 = *(char **)a1;
    v10 = (uint64_t)&v7[-*(_QWORD *)a1];
    if ((unint64_t)v7 <= *(_QWORD *)a1)
    {
      v33 = (v5 - v9) >> 2;
      if (v5 == v9)
        v33 = 1;
      if (!(v33 >> 61))
      {
        v34 = v33 >> 2;
        v35 = 8 * v33;
        v36 = (char *)operator new(8 * v33);
        v37 = &v36[8 * v34];
        v38 = &v36[v35];
        v40 = v5 - v7;
        v39 = v5 == v7;
        v5 = v37;
        if (!v39)
        {
          v5 = &v37[v40 & 0xFFFFFFFFFFFFFFF8];
          v41 = v40 - 8;
          if ((unint64_t)(v40 - 8) >= 0x38)
          {
            v84 = &v36[8 * v34];
            v42 = v84;
            if ((unint64_t)(v84 - v7) >= 0x20)
            {
              v85 = (v41 >> 3) + 1;
              v86 = 8 * (v85 & 0x3FFFFFFFFFFFFFFCLL);
              v42 = &v37[v86];
              v87 = (__int128 *)(v6 + 3);
              v88 = v84 + 16;
              v89 = v85 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                v90 = *v87;
                *(v88 - 1) = *(v87 - 1);
                *v88 = v90;
                v87 += 2;
                v88 += 2;
                v89 -= 4;
              }
              while (v89);
              if (v85 == (v85 & 0x3FFFFFFFFFFFFFFCLL))
                goto LABEL_76;
              v7 += v86;
            }
          }
          else
          {
            v42 = &v36[8 * v34];
          }
          do
          {
            v91 = *(_QWORD *)v7;
            v7 += 8;
            *(_QWORD *)v42 = v91;
            v42 += 8;
          }
          while (v42 != v5);
        }
        goto LABEL_76;
      }
LABEL_100:
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
LABEL_5:
    v11 = v10 >> 3;
    if (v11 >= -1)
      v12 = v11 + 1;
    else
      v12 = v11 + 2;
    v13 = v12 >> 1;
    v14 = -v13;
    v15 = &v7[-8 * v13];
    v16 = v5 - v7;
    if (v5 != v7)
    {
      memmove(&v7[-8 * v13], v7, v5 - v7);
      v7 = *(char **)(a1 + 8);
    }
    v5 = &v15[v16];
    *(_QWORD *)(a1 + 8) = &v7[8 * v14];
    *(_QWORD *)(a1 + 16) = &v15[v16];
    goto LABEL_83;
  }
  v18 = *(char **)(a1 + 16);
  v17 = *(char **)(a1 + 24);
  v20 = *(char **)a1;
  v19 = *(char **)(a1 + 8);
  v21 = v18 - v19;
  v22 = (v18 - v19) >> 3;
  v23 = (uint64_t)&v17[-*(_QWORD *)a1];
  if (v22 < (unint64_t)(v23 >> 3))
  {
    v24 = operator new(0x1000uLL);
    v25 = v24;
    if (v17 != v18)
    {
      *(_QWORD *)v18 = v24;
LABEL_84:
      *(_QWORD *)(a1 + 16) += 8;
      return;
    }
    if (v19 != v20)
    {
      v43 = v19;
      goto LABEL_82;
    }
    v69 = (v17 - v19) >> 2;
    if (v18 == v19)
      v69 = 1;
    if (v69 >> 61)
      goto LABEL_100;
    v70 = (v69 + 3) >> 2;
    v71 = 8 * v69;
    v72 = (char *)operator new(8 * v69);
    v43 = &v72[8 * v70];
    v73 = &v72[v71];
    v74 = v43;
    if (v18 != v19)
    {
      v74 = &v43[8 * v22];
      v75 = &v72[8 * v70];
      v76 = v19;
      if ((unint64_t)(v21 - 8) > 0x37)
      {
        v77 = &v72[8 * v70];
        v75 = v77;
        v76 = v19;
        if ((unint64_t)(v77 - v19) >= 0x20)
        {
          v78 = ((unint64_t)(v21 - 8) >> 3) + 1;
          v79 = 8 * (v78 & 0x3FFFFFFFFFFFFFFCLL);
          v75 = &v43[v79];
          v80 = (__int128 *)(v19 + 16);
          v81 = v77 + 16;
          v82 = v78 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            v83 = *v80;
            *(v81 - 1) = *(v80 - 1);
            *v81 = v83;
            v80 += 2;
            v81 += 2;
            v82 -= 4;
          }
          while (v82);
          if (v78 == (v78 & 0x3FFFFFFFFFFFFFFCLL))
          {
            *(_QWORD *)a1 = v72;
            *(_QWORD *)(a1 + 8) = v43;
            *(_QWORD *)(a1 + 16) = v74;
            *(_QWORD *)(a1 + 24) = v73;
LABEL_81:
            operator delete(v19);
            v43 = *(char **)(a1 + 8);
LABEL_82:
            *((_QWORD *)v43 - 1) = v25;
            v7 = *(char **)(a1 + 8);
            v5 = *(char **)(a1 + 16);
            *(_QWORD *)(a1 + 8) = v7 - 8;
            v8 = *((_QWORD *)v7 - 1);
            *(_QWORD *)(a1 + 8) = v7;
            if (v5 != *(char **)(a1 + 24))
              goto LABEL_83;
            v9 = *(char **)a1;
            v10 = (uint64_t)&v7[-*(_QWORD *)a1];
            if ((unint64_t)v7 <= *(_QWORD *)a1)
            {
              v93 = (v5 - v9) >> 2;
              if (v5 == v9)
                v93 = 1;
              if (!(v93 >> 61))
              {
                v94 = v93 >> 2;
                v95 = 8 * v93;
                v36 = (char *)operator new(8 * v93);
                v37 = &v36[8 * v94];
                v38 = &v36[v95];
                v96 = v5 - v7;
                v39 = v5 == v7;
                v5 = v37;
                if (!v39)
                {
                  v5 = &v37[v96 & 0xFFFFFFFFFFFFFFF8];
                  v97 = v96 - 8;
                  if ((unint64_t)(v96 - 8) >= 0x38)
                  {
                    v99 = &v36[8 * v94];
                    v98 = v99;
                    if ((unint64_t)(v99 - v7) >= 0x20)
                    {
                      v100 = (v97 >> 3) + 1;
                      v101 = 8 * (v100 & 0x3FFFFFFFFFFFFFFCLL);
                      v98 = &v37[v101];
                      v102 = (__int128 *)(v7 + 16);
                      v103 = v99 + 16;
                      v104 = v100 & 0x3FFFFFFFFFFFFFFCLL;
                      do
                      {
                        v105 = *v102;
                        *(v103 - 1) = *(v102 - 1);
                        *v103 = v105;
                        v102 += 2;
                        v103 += 2;
                        v104 -= 4;
                      }
                      while (v104);
                      if (v100 == (v100 & 0x3FFFFFFFFFFFFFFCLL))
                        goto LABEL_76;
                      v7 += v101;
                    }
                  }
                  else
                  {
                    v98 = &v36[8 * v94];
                  }
                  do
                  {
                    v106 = *(_QWORD *)v7;
                    v7 += 8;
                    *(_QWORD *)v98 = v106;
                    v98 += 8;
                  }
                  while (v98 != v5);
                }
LABEL_76:
                *(_QWORD *)a1 = v36;
                *(_QWORD *)(a1 + 8) = v37;
                *(_QWORD *)(a1 + 16) = v5;
                *(_QWORD *)(a1 + 24) = v38;
                if (v9)
                {
                  operator delete(v9);
                  v5 = *(char **)(a1 + 16);
                }
                goto LABEL_83;
              }
              goto LABEL_100;
            }
            goto LABEL_5;
          }
          v76 = &v19[v79];
        }
      }
      do
      {
        v92 = *(_QWORD *)v76;
        v76 += 8;
        *(_QWORD *)v75 = v92;
        v75 += 8;
      }
      while (v75 != v74);
    }
    *(_QWORD *)a1 = v72;
    *(_QWORD *)(a1 + 8) = v43;
    *(_QWORD *)(a1 + 16) = v74;
    *(_QWORD *)(a1 + 24) = v73;
    if (!v19)
      goto LABEL_82;
    goto LABEL_81;
  }
  v26 = v23 >> 2;
  if (v17 == v20)
    v27 = 1;
  else
    v27 = v26;
  if (v27 >> 61)
    goto LABEL_100;
  v28 = (char *)operator new(8 * v27);
  v29 = &v28[8 * v22];
  v30 = &v28[8 * v27];
  v31 = operator new(0x1000uLL);
  if (v22 == v27)
  {
    if (v21 < 1)
    {
      v44 = v21 >> 2;
      if (v18 == v19)
        v44 = 1;
      if (v44 >> 61)
        goto LABEL_100;
      v45 = 8 * v44;
      v29 = (char *)operator new(8 * v44);
      v30 = &v29[v45];
      operator delete(v28);
      v19 = *(char **)(a1 + 8);
      v18 = *(char **)(a1 + 16);
      v28 = v29;
    }
    else
    {
      v32 = v22 + 2;
      if (v22 >= -1)
        v32 = v22 + 1;
      v29 -= 8 * (v32 >> 1);
    }
  }
  *(_QWORD *)v29 = v31;
  v46 = v29 + 8;
  if (v18 != v19)
  {
    do
    {
      if (v29 != v28)
        goto LABEL_39;
      if (v46 < v30)
      {
        v49 = (v30 - v46) >> 3;
        if (v49 >= -1)
          v50 = v49 + 1;
        else
          v50 = v49 + 2;
        v51 = v50 >> 1;
        v29 = &v28[8 * (v50 >> 1)];
        v52 = v28;
        if (v46 != v28)
        {
          memmove(v29, v28, v46 - v28);
          v52 = v46;
        }
        v46 = (char *)v52 + 8 * v51;
        goto LABEL_39;
      }
      v53 = (v30 - v28) >> 2;
      if (v30 == v28)
        v53 = 1;
      if (v53 >> 61)
        goto LABEL_100;
      v54 = (v53 + 3) >> 2;
      v55 = 8 * v53;
      v56 = (char *)operator new(8 * v53);
      v57 = v56;
      v29 = &v56[8 * v54];
      v58 = v46 - v28;
      v39 = v46 == v28;
      v46 = v29;
      if (!v39)
      {
        v46 = &v29[v58 & 0xFFFFFFFFFFFFFFF8];
        v59 = v58 - 8;
        v60 = &v56[8 * v54];
        v61 = v28;
        if (v59 >= 0x38)
        {
          v60 = &v56[8 * v54];
          v61 = v28;
          if ((unint64_t)(v60 - v28) >= 0x20)
          {
            v62 = (v59 >> 3) + 1;
            v63 = 8 * (v62 & 0x3FFFFFFFFFFFFFFCLL);
            v60 = &v29[v63];
            v64 = (__int128 *)(v28 + 16);
            v65 = &v56[8 * v54 + 16];
            v66 = v62 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              v67 = *v64;
              *((_OWORD *)v65 - 1) = *(v64 - 1);
              *(_OWORD *)v65 = v67;
              v64 += 2;
              v65 += 32;
              v66 -= 4;
            }
            while (v66);
            if (v62 == (v62 & 0x3FFFFFFFFFFFFFFCLL))
              goto LABEL_38;
            v61 = &v28[v63];
          }
        }
        do
        {
          v68 = *(_QWORD *)v61;
          v61 += 8;
          *(_QWORD *)v60 = v68;
          v60 += 8;
        }
        while (v60 != v46);
      }
LABEL_38:
      v30 = &v56[v55];
      operator delete(v28);
      v28 = v57;
LABEL_39:
      v48 = *((_QWORD *)v18 - 1);
      v18 -= 8;
      *((_QWORD *)v29 - 1) = v48;
      v29 -= 8;
    }
    while (v18 != *(char **)(a1 + 8));
  }
  v47 = *(char **)a1;
  *(_QWORD *)a1 = v28;
  *(_QWORD *)(a1 + 8) = v29;
  *(_QWORD *)(a1 + 16) = v46;
  *(_QWORD *)(a1 + 24) = v30;
  if (v47)
    operator delete(v47);
}

uint64_t IVFVectorIndexTemplate<float,768>::IVFVectorIndexRootBase::trainOnce(uint64_t *a1, std::string::size_type *a2, uint64_t a3, unsigned int a4)
{
  double Current;
  std::string::size_type v7;
  uint64_t v8;
  void *v9;
  int v10;
  uint64_t v11;
  size_t v12;
  uint64_t v13;
  std::__shared_weak_count *v14;
  uint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *p_shared_owners;
  unint64_t v20;
  std::__shared_weak_count *v21;
  int v22;
  unint64_t *v23;
  unint64_t v24;
  uint64_t v25;
  unsigned __int8 v26;
  NSObject *v27;
  uint64_t v28;
  int v29;
  int v30;
  size_t v31;
  unint64_t v32;
  std::string *v33;
  uint64_t v34;
  uint64_t v35;
  const void *v36;
  int v37;
  std::string *v38;
  std::string::size_type size;
  std::string *v40;
  std::string::size_type v41;
  std::string *v42;
  std::string::size_type v43;
  const char *v44;
  _QWORD *FdPtrForFile;
  _QWORD *v46;
  uint64_t v47;
  std::__shared_weak_count *v48;
  std::__shared_weak_count *v49;
  unint64_t *v50;
  unint64_t v51;
  unint64_t *v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t *v56;
  char *v57;
  char *v58;
  size_t v59;
  std::__shared_weak_count *v60;
  unint64_t *v61;
  unint64_t v62;
  _BYTE *v63;
  _BYTE *v64;
  _QWORD *v65;
  size_t v66;
  char *v67;
  char *v68;
  char *v69;
  uint64_t v70;
  uint64_t v71;
  unint64_t v72;
  unint64_t v73;
  char *v74;
  char *v75;
  uint64_t *v76;
  char *v77;
  __int128 v78;
  int v79;
  NSObject *v80;
  std::__shared_weak_count *v81;
  unint64_t v82;
  char *v83;
  char *v84;
  uint64_t v85;
  const void *v86;
  _BYTE *v87;
  _BYTE *v88;
  _BYTE *v89;
  unint64_t v90;
  unint64_t v91;
  std::__shared_weak_count *v92;
  char *v93;
  char *v94;
  uint64_t v95;
  uint64_t v96;
  int64_t v97;
  uint64_t v98;
  BOOL v99;
  uint64_t *v100;
  __int128 v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t *v104;
  uint64_t v105;
  uint64_t v106;
  int64_t v107;
  uint64_t *v108;
  uint64_t *v109;
  uint64_t *v110;
  uint64_t v111;
  char *v112;
  char *v113;
  char *v114;
  void *v115;
  void *v116;
  unsigned int v117;
  std::__shared_weak_count_vtbl *v118;
  std::__shared_weak_count_vtbl *v119;
  std::__shared_weak_count *v120;
  __int128 v121;
  unint64_t *v122;
  uint64_t v123;
  size_t v124;
  uint64_t v125;
  uint64_t v126;
  unint64_t v127;
  std::__shared_weak_count *v128;
  unint64_t *v129;
  unint64_t v130;
  std::__shared_weak_count *v131;
  unint64_t *v132;
  unint64_t v133;
  int v134;
  int v135;
  std::string::size_type v136;
  uint64_t v137;
  int v138;
  uint64_t v139;
  uint64_t v140;
  const void *v141;
  const void *v142;
  uint64_t v143;
  float *v144;
  float v145;
  _QWORD *v146;
  unint64_t v147;
  uint64_t v148;
  uint64_t v149;
  unint64_t v150;
  unint64_t v151;
  unint64_t v152;
  unint64_t v153;
  int v154;
  int v155;
  NSObject *v156;
  unsigned int v157;
  uint64_t v158;
  unint64_t v159;
  unsigned int v160;
  unint64_t v161;
  void *v162;
  size_t v163;
  __int128 *v164;
  std::string::size_type v165;
  std::__shared_weak_count *v166;
  unint64_t *v167;
  unint64_t v168;
  std::string::size_type v169;
  unint64_t v170;
  unint64_t *v171;
  uint64_t v172;
  unint64_t v173;
  __int128 v174;
  unint64_t *v175;
  unint64_t v176;
  std::__shared_weak_count *v177;
  unint64_t *v178;
  unint64_t v179;
  std::__shared_weak_count *v180;
  unint64_t *v181;
  unint64_t v182;
  int v183;
  std::__shared_weak_count *v184;
  int v185;
  unint64_t *v186;
  unint64_t v187;
  int v188;
  NSObject *v189;
  int v190;
  int v191;
  CFAbsoluteTime v192;
  std::__shared_weak_count *v193;
  unint64_t *v194;
  unint64_t v195;
  __int128 *v196;
  std::__shared_weak_count *v197;
  unint64_t *v198;
  unint64_t v199;
  unint64_t v200;
  std::__shared_weak_count *v201;
  unint64_t *v202;
  unint64_t v203;
  std::__shared_weak_count *v204;
  unint64_t *v205;
  unint64_t v206;
  int64_t v208;
  uint64_t v209;
  uint64_t *v210;
  __int128 v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t *v214;
  _BYTE *v215;
  int v216;
  char *v217;
  char *v218;
  const char *v219;
  uint64_t v220;
  char *v221;
  char *v222;
  const char *v223;
  char *v224;
  const char *v225;
  char *v226;
  const char *v227;
  char *v228;
  const char *v229;
  char *v230;
  const char *v231;
  char *v232;
  const char *v233;
  __int128 v234;
  uint64_t v235;
  size_t v236;
  std::string::size_type v237;
  std::string::size_type v238;
  uint64_t v239;
  int v240;
  unsigned int v241;
  std::__shared_weak_count *v242;
  _DWORD *v243;
  uint64_t v244;
  std::__shared_weak_count *v245;
  std::string::size_type v246;
  int v247;
  std::string::size_type *v248;
  __int128 v249;
  std::string::size_type v250;
  std::__shared_weak_count *v251;
  std::string v252;
  std::__shared_weak_count *v253;
  _QWORD v254[7];
  std::__shared_weak_count *v255;
  int v256;
  int v257;
  _BYTE v258[24];
  __int128 v259;
  _BYTE *v260;
  _BYTE *v261;
  unint64_t v262;
  uint64_t v263;
  std::__shared_weak_count *v264;
  std::string v265;
  _BYTE v266[1000];
  uint64_t v267;

  v241 = a4;
  v239 = a3;
  v267 = *MEMORY[0x1E0C80C00];
  Current = CFAbsoluteTimeGetCurrent();
  v263 = 0;
  v264 = 0;
  QuantizerManager<float,768>::lastTrainedQuantizer(&v263, *a1);
  v7 = a2[1];
  v237 = *a2;
  v238 = v7;
  v8 = v7 - v237;
  if (v7 == v237)
  {
    v9 = 0;
  }
  else
  {
    if (v8 < 0)
      goto LABEL_322;
    v9 = operator new((unint64_t)v8 >> 1);
    bzero(v9, (unint64_t)v8 >> 1);
  }
  v235 = v8;
  v236 = v8 >> 3;
  v10 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v263 + 24))(v263);
  if (v238 != v237)
  {
    v11 = 0;
    if (v236 <= 1)
      v12 = 1;
    else
      v12 = v236;
    while (1)
    {
      (*(void (**)(_BYTE *__return_ptr))(**(_QWORD **)(*a2 + 8 * v11) + 16))(v266);
      v13 = v263;
      v15 = *(_QWORD *)v266;
      v14 = *(std::__shared_weak_count **)&v266[8];
      if (*(_QWORD *)&v266[8])
      {
        v16 = (unint64_t *)(*(_QWORD *)&v266[8] + 8);
        do
          v17 = __ldaxr(v16);
        while (__stlxr(v17 - 1, v16));
        if (!v17)
        {
          ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
          std::__shared_weak_count::__release_weak(v14);
        }
      }
      if (v15 != v13)
        break;
      (*(void (**)(_BYTE *__return_ptr))(**(_QWORD **)(*a2 + 8 * v11) + 24))(v266);
      v18 = *(std::__shared_weak_count **)&v266[8];
      *((_DWORD *)v9 + v11) = *(_DWORD *)(*(_QWORD *)v266 + 72);
      if (v18)
      {
        p_shared_owners = (unint64_t *)&v18->__shared_owners_;
        do
          v20 = __ldaxr(p_shared_owners);
        while (__stlxr(v20 - 1, p_shared_owners));
        if (!v20)
        {
          ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
          std::__shared_weak_count::__release_weak(v18);
        }
      }
      (*(void (**)(_BYTE *__return_ptr))(**(_QWORD **)(*a2 + 8 * v11) + 24))(v266);
      v21 = *(std::__shared_weak_count **)&v266[8];
      v22 = *(_DWORD *)(*(_QWORD *)v266 + 68);
      if (*(_QWORD *)&v266[8])
      {
        v23 = (unint64_t *)(*(_QWORD *)&v266[8] + 8);
        do
          v24 = __ldaxr(v23);
        while (__stlxr(v24 - 1, v23));
        if (!v24)
        {
          ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
          std::__shared_weak_count::__release_weak(v21);
        }
      }
      if (v22 != v10)
      {
        v221 = __si_assert_copy_extra_268();
        v222 = v221;
        v223 = "";
        if (v221)
          v223 = v221;
        __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1967, "vectorIndexes[i]->getPartitions()->nPartitions() == nPartitions", v223);
LABEL_316:
        free(v222);
        if (__valid_fs(-1))
        {
          MEMORY[0xBAD] = -559038737;
          abort();
        }
        MEMORY[0xC00] = -559038737;
        abort();
      }
      if (++v11 == v12)
        goto LABEL_27;
    }
    v217 = __si_assert_copy_extra_268();
    v218 = v217;
    v219 = "";
    if (v217)
      v219 = v217;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1965, "vectorIndexes[i]->getQuantizer() == quantizer", v219);
LABEL_297:
    free(v218);
    if (__valid_fs(-1))
      v220 = 2989;
    else
      v220 = 3072;
    *(_DWORD *)v220 = -559038737;
    abort();
  }
LABEL_27:
  v25 = *a1;
  v26 = atomic_load((unsigned __int8 *)(v25 + 72));
  if ((v26 & 1) == 0)
  {
    v232 = __si_assert_copy_extra_268();
    v218 = v232;
    v233 = "";
    if (v232)
      v233 = v232;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 752, "_training.test()", v233);
    goto LABEL_297;
  }
  if (*(_QWORD *)(v25 + 96))
  {
    v27 = *(NSObject **)(v25 + 16);
    *(_QWORD *)v266 = MEMORY[0x1E0C809B0];
    *(_QWORD *)&v266[8] = 0x40000000;
    *(_QWORD *)&v266[16] = ___ZN16QuantizerManagerIfLi768EE23commitTrainingQuantizerEv_block_invoke;
    *(_QWORD *)&v266[24] = &__block_descriptor_tmp_798;
    *(_QWORD *)&v266[32] = v25;
    dispatch_sync(v27, v266);
  }
  v28 = *(_QWORD *)(v25 + 80);
  v247 = v10;
  if (v28)
    v29 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v28 + 16))(v28) + 1;
  else
    v29 = 1;
  v30 = *(char *)(v25 + 71);
  if (v30 >= 0)
    v31 = *(unsigned __int8 *)(v25 + 71);
  else
    v31 = *(_QWORD *)(v25 + 56);
  v32 = v31 + 1;
  if (v31 + 1 >= 0x7FFFFFFFFFFFFFF8)
LABEL_322:
    abort();
  if (v32 >= 0x17)
  {
    v34 = (v32 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v32 | 7) != 0x17)
      v34 = v32 | 7;
    v35 = v34 + 1;
    v33 = (std::string *)operator new(v34 + 1);
    v252.__r_.__value_.__l.__size_ = v31 + 1;
    v252.__r_.__value_.__r.__words[2] = v35 | 0x8000000000000000;
    v252.__r_.__value_.__r.__words[0] = (std::string::size_type)v33;
  }
  else
  {
    memset(&v252, 0, sizeof(v252));
    v33 = &v252;
    *((_BYTE *)&v252.__r_.__value_.__s + 23) = v31 + 1;
    if (!v31)
      goto LABEL_47;
  }
  if (v30 >= 0)
    v36 = (const void *)(v25 + 48);
  else
    v36 = *(const void **)(v25 + 48);
  memmove(v33, v36, v31);
LABEL_47:
  v37 = v247;
  *(_WORD *)((char *)&v33->__r_.__value_.__l.__data_ + v31) = 46;
  std::to_string(&v265, v29);
  if ((v265.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v38 = &v265;
  else
    v38 = (std::string *)v265.__r_.__value_.__r.__words[0];
  if ((v265.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(v265.__r_.__value_.__r.__words[2]);
  else
    size = v265.__r_.__value_.__l.__size_;
  v40 = std::string::append(&v252, (const std::string::value_type *)v38, size);
  v41 = v40->__r_.__value_.__r.__words[2];
  *(_OWORD *)v266 = *(_OWORD *)&v40->__r_.__value_.__l.__data_;
  *(_QWORD *)&v266[16] = v41;
  v40->__r_.__value_.__l.__size_ = 0;
  v40->__r_.__value_.__r.__words[2] = 0;
  v40->__r_.__value_.__r.__words[0] = 0;
  v42 = std::string::append((std::string *)v266, ".quantizer");
  v43 = v42->__r_.__value_.__r.__words[2];
  *(_OWORD *)v258 = *(_OWORD *)&v42->__r_.__value_.__l.__data_;
  *(_QWORD *)&v258[16] = v43;
  v42->__r_.__value_.__l.__size_ = 0;
  v42->__r_.__value_.__r.__words[2] = 0;
  v42->__r_.__value_.__r.__words[0] = 0;
  if ((v266[23] & 0x80000000) == 0)
  {
    if ((SHIBYTE(v265.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_55;
LABEL_107:
    operator delete(v265.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v252.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_56;
    goto LABEL_108;
  }
  operator delete(*(void **)v266);
  if (SHIBYTE(v265.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_107;
LABEL_55:
  if ((SHIBYTE(v252.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    goto LABEL_56;
LABEL_108:
  operator delete(v252.__r_.__value_.__l.__data_);
LABEL_56:
  if (v258[23] >= 0)
    v44 = v258;
  else
    v44 = *(const char **)v258;
  FdPtrForFile = QuantizerManager<float,768>::createFdPtrForFile(v25, v44);
  if (FdPtrForFile)
  {
    v46 = FdPtrForFile;
    v47 = operator new();
    *(_QWORD *)v266 = v46;
    *(_QWORD *)&v266[8] = 0x1000000;
    *(_DWORD *)&v266[16] = 0;
    *(_DWORD *)&v266[20] = 65792;
    *(_DWORD *)&v266[24] = v29;
    *(_DWORD *)&v266[28] = 0;
    AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,768>::AllocatedVectorQuantizer(v47, (uint64_t)v266);
    v48 = (std::__shared_weak_count *)operator new();
    v48->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6E332E8;
    v48->__shared_owners_ = 0;
    v48->__shared_weak_owners_ = 0;
    v48[1].__vftable = (std::__shared_weak_count_vtbl *)v47;
    v49 = *(std::__shared_weak_count **)(v25 + 104);
    *(_QWORD *)(v25 + 96) = v47;
    *(_QWORD *)(v25 + 104) = v48;
    if (v49)
    {
      v50 = (unint64_t *)&v49->__shared_owners_;
      do
        v51 = __ldaxr(v50);
      while (__stlxr(v51 - 1, v50));
      if (v51)
      {
        v47 = *(_QWORD *)(v25 + 96);
        v48 = *(std::__shared_weak_count **)(v25 + 104);
        if (v48)
          goto LABEL_65;
      }
      else
      {
        ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
        std::__shared_weak_count::__release_weak(v49);
        v47 = *(_QWORD *)(v25 + 96);
        v48 = *(std::__shared_weak_count **)(v25 + 104);
        if (v48)
          goto LABEL_65;
      }
      v245 = 0;
      if ((v258[23] & 0x80000000) == 0)
        goto LABEL_68;
      goto LABEL_111;
    }
LABEL_65:
    v245 = v48;
    v52 = (unint64_t *)&v48->__shared_owners_;
    do
      v53 = __ldxr(v52);
    while (__stxr(v53 + 1, v52));
    if ((v258[23] & 0x80000000) == 0)
      goto LABEL_68;
    goto LABEL_111;
  }
  v79 = *__error();
  v80 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v80, OS_LOG_TYPE_FAULT))
  {
    v215 = v258;
    if (v258[23] < 0)
      v215 = *(_BYTE **)v258;
    v216 = *(_DWORD *)v25;
    *(_DWORD *)v266 = 136315906;
    *(_QWORD *)&v266[4] = "newQuantizer";
    *(_WORD *)&v266[12] = 1024;
    *(_DWORD *)&v266[14] = 772;
    *(_WORD *)&v266[18] = 2080;
    *(_QWORD *)&v266[20] = v215;
    *(_WORD *)&v266[28] = 1024;
    *(_DWORD *)&v266[30] = v216;
    _os_log_fault_impl(&dword_1B8270000, v80, OS_LOG_TYPE_FAULT, "%s:%d: Failed to create %s in parentFd: %i", v266, 0x22u);
  }
  v47 = 0;
  v245 = 0;
  *__error() = v79;
  if ((v258[23] & 0x80000000) == 0)
  {
LABEL_68:
    if (v47)
      goto LABEL_69;
LABEL_112:
    v81 = v245;
    goto LABEL_272;
  }
LABEL_111:
  operator delete(*(void **)v258);
  if (!v47)
    goto LABEL_112;
LABEL_69:
  v248 = a2;
  v243 = v9;
  v259 = 0u;
  *(_OWORD *)&v258[8] = 0u;
  *(_QWORD *)v258 = off_1E6E33370;
  v260 = 0;
  v261 = 0;
  v262 = 0;
  bzero(v266, 0x400uLL);
  snprintf(v266, 0x400uLL, "A0-%ux%dx%u", v239, 768, 32);
  MEMORY[0x1BCCB03B0](&v258[8], v266);
  v246 = v47;
  v54 = MEMORY[0x1E0C809B0];
  if ((_DWORD)v239)
  {
    memset(v266, 0, 24);
    if (v238 == v237)
    {
      v57 = 0;
      v56 = 0;
    }
    else
    {
      v55 = 0;
      v56 = 0;
      v57 = 0;
      v58 = 0;
      if (v236 <= 1)
        v59 = 1;
      else
        v59 = v236;
      do
      {
        memset(&v252, 0, sizeof(v252));
        (*(void (**)(std::string *__return_ptr))(**(_QWORD **)(*v248 + 8 * v55) + 24))(&v265);
        MaxSizePriorityQueue<AnyPartitionStore::CandidateEntry,std::vector<AnyPartitionStore::CandidateEntry>,AnyPartitionStore::CandidateQueue::Lesser>::allItems((uint64_t **)&v252, *(_BYTE **)(v265.__r_.__value_.__r.__words[0] + 32), *(_BYTE **)(v265.__r_.__value_.__r.__words[0] + 40));
        v60 = (std::__shared_weak_count *)v265.__r_.__value_.__l.__size_;
        if (v265.__r_.__value_.__l.__size_)
        {
          v61 = (unint64_t *)(v265.__r_.__value_.__l.__size_ + 8);
          do
            v62 = __ldaxr(v61);
          while (__stlxr(v62 - 1, v61));
          if (!v62)
          {
            ((void (*)(std::__shared_weak_count *))v60->__on_zero_shared)(v60);
            std::__shared_weak_count::__release_weak(v60);
          }
        }
        v63 = (_BYTE *)v252.__r_.__value_.__l.__size_;
        v64 = (_BYTE *)v252.__r_.__value_.__r.__words[0];
        if (v252.__r_.__value_.__l.__size_ != v252.__r_.__value_.__r.__words[0])
        {
          v65 = *(_QWORD **)&v266[8];
          if (*(_QWORD *)&v266[8] >= *(_QWORD *)&v266[16])
          {
            v69 = std::vector<std::vector<AnyPartitionStore::CandidateEntry>>::__push_back_slow_path<std::vector<AnyPartitionStore::CandidateEntry> const&>((char **)v266, v252.__r_.__value_.__l.__data_, v252.__r_.__value_.__l.__size_);
          }
          else
          {
            **(_QWORD **)&v266[8] = 0;
            v65[1] = 0;
            v65[2] = 0;
            v66 = v63 - v64;
            if (v63 - v64 < 0)
              goto LABEL_322;
            v67 = (char *)operator new(v63 - v64);
            *v65 = v67;
            v65[1] = v67;
            v68 = &v67[v66];
            v65[2] = &v67[v66];
            memcpy(v67, v64, v66);
            v65[1] = v68;
            v69 = (char *)(v65 + 3);
          }
          *(_QWORD *)&v266[8] = v69;
          v71 = *((_QWORD *)v69 - 3);
          v70 = *((_QWORD *)v69 - 2);
          if (v57 >= v58)
          {
            v72 = 0xAAAAAAAAAAAAAAABLL * ((v57 - (char *)v56) >> 3) + 1;
            if (v72 > 0xAAAAAAAAAAAAAAALL)
              goto LABEL_322;
            if (0x5555555555555556 * ((v58 - (char *)v56) >> 3) > v72)
              v72 = 0x5555555555555556 * ((v58 - (char *)v56) >> 3);
            if (0xAAAAAAAAAAAAAAABLL * ((v58 - (char *)v56) >> 3) >= 0x555555555555555)
              v73 = 0xAAAAAAAAAAAAAAALL;
            else
              v73 = v72;
            if (v73)
            {
              if (v73 > 0xAAAAAAAAAAAAAAALL)
LABEL_323:
                std::__throw_bad_array_new_length[abi:nn180100]();
              v74 = (char *)operator new(24 * v73);
            }
            else
            {
              v74 = 0;
            }
            v75 = &v74[8 * ((v57 - (char *)v56) >> 3)];
            *(_QWORD *)v75 = v71;
            *((_QWORD *)v75 + 1) = v70;
            *((_QWORD *)v75 + 2) = v55;
            v76 = (uint64_t *)v75;
            if (v57 != (char *)v56)
            {
              v77 = &v74[8 * ((v57 - (char *)v56) >> 3)];
              do
              {
                v76 = (uint64_t *)(v77 - 24);
                v78 = *(_OWORD *)(v57 - 24);
                *((_QWORD *)v77 - 1) = *((_QWORD *)v57 - 1);
                *(_OWORD *)(v77 - 24) = v78;
                v57 -= 24;
                v77 -= 24;
              }
              while (v57 != (char *)v56);
            }
            v58 = &v74[24 * v73];
            if (v56)
              operator delete(v56);
            v57 = v75;
            v56 = v76;
          }
          else
          {
            *(_QWORD *)v57 = v71;
            *((_QWORD *)v57 + 1) = v70;
            *((_QWORD *)v57 + 2) = v55;
          }
          v57 += 24;
          v63 = (_BYTE *)v252.__r_.__value_.__r.__words[0];
        }
        if (v63)
          operator delete(v63);
        ++v55;
      }
      while (v55 != v59);
    }
    v82 = v57 - (char *)v56;
    if (v57 - (char *)v56 >= 25 && v82 >= 0x30)
    {
      v208 = (v82 / 0x18 - 2) >> 1;
      v209 = v208;
      do
      {
        if (v208 >= v209)
        {
          v210 = &v56[3 * v209];
          v211 = *(_OWORD *)v210;
          v212 = v210[2];
          v213 = v209;
          do
          {
            v214 = v210;
            v213 = (2 * v213) | 1;
            v210 = &v56[3 * v213];
            *v214 = *v210;
            *(_OWORD *)(v214 + 1) = *(_OWORD *)(v210 + 1);
          }
          while (v208 >= v213);
          *(_OWORD *)v210 = v211;
          v210[2] = v212;
        }
        v99 = v209-- <= 0;
      }
      while (!v99);
    }
    for (; v57 != (char *)v56; v82 = v57 - (char *)v56)
    {
      if (-1431655765 * ((unint64_t)(v261 - v260) >> 10) >= v239)
        break;
      v244 = v82;
      v85 = *(_QWORD *)(*v248 + 8 * v56[2]);
      v86 = (const void *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v85 + 32))(v85, *(unsigned int *)*v56);
      v87 = v261;
      if ((unint64_t)v261 >= v262)
      {
        v89 = v260;
        v90 = 0xAAAAAAAAAAAAAAABLL * ((v261 - v260) >> 10) + 1;
        if (v90 > 0x15555555555555)
          goto LABEL_322;
        if (0x5555555555555556 * ((uint64_t)(v262 - (_QWORD)v260) >> 10) > v90)
          v90 = 0x5555555555555556 * ((uint64_t)(v262 - (_QWORD)v260) >> 10);
        v91 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v262 - (_QWORD)v260) >> 10) >= 0xAAAAAAAAAAAAALL
            ? 0x15555555555555
            : v90;
        if (v91)
        {
          if (v91 > 0x15555555555555)
            goto LABEL_323;
          v92 = (std::__shared_weak_count *)operator new(3072 * v91);
        }
        else
        {
          v92 = 0;
        }
        v242 = v92;
        v93 = (char *)v92 + 1024 * ((v87 - v89) >> 10);
        memcpy(v93, v86, 0xC00uLL);
        v94 = v93;
        if (v87 != v89)
        {
          do
          {
            v87 -= 3072;
            v94 -= 3072;
            memcpy(v94, v87, 0xC00uLL);
          }
          while (v87 != v89);
          v87 = v89;
        }
        v88 = v93 + 3072;
        v260 = v94;
        v261 = v88;
        v262 = (unint64_t)&v242[128 * v91];
        if (v87)
          operator delete(v87);
      }
      else
      {
        memcpy(v261, v86, 0xC00uLL);
        v88 = v87 + 3072;
      }
      v261 = v88;
      v95 = v56[1];
      v96 = *v56 + 8;
      *v56 = v96;
      if (v96 == v95)
      {
        if (v244 >= 25)
        {
          v105 = 0;
          v106 = v56[2];
          v107 = (v244 / 0x18uLL - 2) >> 1;
          v108 = v56;
          do
          {
            v109 = v108;
            v110 = &v108[3 * v105];
            v111 = v110[3];
            v108 = v110 + 3;
            v105 = (2 * v105) | 1;
            *v109 = v111;
            *(_OWORD *)(v109 + 1) = *(_OWORD *)(v108 + 1);
          }
          while (v105 <= v107);
          if (v108 == (uint64_t *)(v57 - 24))
          {
            v83 = (char *)(v108 + 1);
            v84 = (char *)(v108 + 2);
          }
          else
          {
            *v108 = *((_QWORD *)v57 - 3);
            v83 = v57 - 16;
            v84 = v57 - 8;
            *(_OWORD *)(v108 + 1) = *((_OWORD *)v57 - 1);
            v108 = (uint64_t *)(v57 - 24);
          }
          *v108 = v96;
          *(_QWORD *)v83 = v95;
          *(_QWORD *)v84 = v106;
        }
        v57 -= 24;
      }
      else if (v244 >= 48)
      {
        v97 = (v244 / 0x18uLL - 2) >> 1;
        v98 = v97;
        do
        {
          if (v97 >= v98)
          {
            v100 = &v56[3 * v98];
            v101 = *(_OWORD *)v100;
            v102 = v100[2];
            v103 = v98;
            do
            {
              v104 = v100;
              v103 = (2 * v103) | 1;
              v100 = &v56[3 * v103];
              *v104 = *v100;
              *(_OWORD *)(v104 + 1) = *(_OWORD *)(v100 + 1);
            }
            while (v97 >= v103);
            *(_OWORD *)v100 = v101;
            v100[2] = v102;
          }
          v99 = v98-- <= 0;
        }
        while (!v99);
      }
    }
    v112 = *(char **)v266;
    v37 = v247;
    v54 = MEMORY[0x1E0C809B0];
    if (*(_QWORD *)v266)
    {
      v113 = *(char **)&v266[8];
      if (*(_QWORD *)&v266[8] != *(_QWORD *)v266)
      {
        v114 = *(char **)&v266[8];
        do
        {
          v116 = (void *)*((_QWORD *)v114 - 3);
          v114 -= 24;
          v115 = v116;
          if (v116)
          {
            *((_QWORD *)v113 - 2) = v115;
            operator delete(v115);
          }
          v113 = v114;
        }
        while (v114 != v112);
      }
      operator delete(v112);
    }
    if (v56)
      operator delete(v56);
  }
  LODWORD(v244) = -1431655765 * ((unint64_t)(v261 - v260) >> 10);
  v117 = v37 - 1431655765 * ((unint64_t)(v261 - v260) >> 10);
  v118 = (std::__shared_weak_count_vtbl *)operator new[]();
  v119 = v118;
  if (v117)
    bzero(v118, 3076 * ((3076 * (unint64_t)v117 - 3076) / 0xC04) + 3076);
  v120 = (std::__shared_weak_count *)operator new();
  v120->__shared_owners_ = 0;
  v122 = (unint64_t *)&v120->__shared_owners_;
  v120->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6E32118;
  v120->__shared_weak_owners_ = 0;
  v120[1].__vftable = v119;
  v242 = v120;
  if (v238 != v237)
  {
    v123 = 0;
    if (v236 <= 1)
      v124 = 1;
    else
      v124 = v236;
    do
    {
      v125 = *(_QWORD *)(*v248 + 8 * v123);
      *(_QWORD *)v266 = 0;
      *(_QWORD *)&v266[8] = 0;
      (*(void (**)(_BYTE *__return_ptr, uint64_t))(*(_QWORD *)v125 + 24))(v266, v125);
      v126 = *(_QWORD *)v266;
      v254[0] = v54;
      v254[1] = 1174405120;
      v254[2] = ___ZN22IVFVectorIndexTemplateIfLi768EE22IVFVectorIndexRootBase9trainOnceENSt3__110shared_ptrI16QuantizerManagerIfLi768EEEENS2_6vectorIPS1_NS2_9allocatorIS8_EEEEjj_block_invoke;
      v254[3] = &__block_descriptor_tmp_794;
      v254[4] = v125;
      v254[5] = v258;
      v256 = v244;
      v257 = v247;
      v254[6] = v119;
      v255 = v242;
      do
        v127 = __ldxr(v122);
      while (__stxr(v127 + 1, v122));
      (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v126 + 64))(v126, v254);
      v128 = v255;
      if (!v255)
        goto LABEL_178;
      v129 = (unint64_t *)&v255->__shared_owners_;
      do
        v130 = __ldaxr(v129);
      while (__stlxr(v130 - 1, v129));
      if (!v130)
      {
        ((void (*)(std::__shared_weak_count *))v128->__on_zero_shared)(v128);
        std::__shared_weak_count::__release_weak(v128);
        v131 = *(std::__shared_weak_count **)&v266[8];
        if (*(_QWORD *)&v266[8])
        {
LABEL_179:
          v132 = (unint64_t *)&v131->__shared_owners_;
          do
            v133 = __ldaxr(v132);
          while (__stlxr(v133 - 1, v132));
          if (!v133)
          {
            ((void (*)(std::__shared_weak_count *))v131->__on_zero_shared)(v131);
            std::__shared_weak_count::__release_weak(v131);
          }
        }
      }
      else
      {
LABEL_178:
        v131 = *(std::__shared_weak_count **)&v266[8];
        if (*(_QWORD *)&v266[8])
          goto LABEL_179;
      }
      ++v123;
    }
    while (v123 != v124);
  }
  v134 = v247;
  if (v247 != 1431655765 * ((unint64_t)(v261 - v260) >> 10))
  {
    v143 = 0;
    v135 = 0;
    *(_QWORD *)&v121 = 67109376;
    v234 = v121;
    v136 = v246;
    while (1)
    {
      v144 = (float *)((char *)v119 + 3076 * v143);
      v145 = v144[768];
      if (v145 < v241)
      {
        ++v135;
        if (dword_1EF19FCCC >= 5)
        {
          v154 = v135;
          v155 = *__error();
          v156 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v156, OS_LOG_TYPE_DEFAULT))
          {
            v157 = v144[768];
            *(_DWORD *)v266 = v234;
            *(_DWORD *)&v266[4] = v143;
            *(_WORD *)&v266[8] = 1024;
            *(_DWORD *)&v266[10] = v157;
            _os_log_impl(&dword_1B8270000, v156, OS_LOG_TYPE_DEFAULT, "remove outlier newCentroid[%u] with member: %u", v266, 0xEu);
          }
          *__error() = v155;
          v135 = v154;
        }
        goto LABEL_195;
      }
      if (v145 <= 0.0)
      {
        v226 = __si_assert_copy_extra_268();
        v222 = v226;
        v227 = "";
        if (v226)
          v227 = v226;
        __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 152, "_count > 0.0f", v227);
        goto LABEL_316;
      }
      if (*(_BYTE *)(v136 + 56))
      {
        v228 = __si_assert_copy_extra_268();
        v222 = v228;
        v229 = "";
        if (v228)
          v229 = v228;
        __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 522, "!readOnly", v229);
        goto LABEL_316;
      }
      v240 = v135;
      v146 = *(_QWORD **)(v136 + 40);
      v147 = v146[2];
      v148 = v146[7];
      v149 = v148 + v147;
      if (v148 + v147 < v146[6])
        goto LABEL_200;
      if (_storage_array_Expand((uint64_t)(v146 + 1)))
        break;
      v150 = 0;
      if (v147 <= 0xBFF)
      {
LABEL_201:
        v151 = v146[2];
        if (v151 <= 0xBFF)
        {
          LODWORD(v152) = 3072;
          do
          {
            v153 = v146[7] + v151;
            if (v153 >= v146[6])
            {
              if (!_storage_array_Expand((uint64_t)(v146 + 1)))
                goto LABEL_205;
              v153 = v146[7] + v151;
            }
            v146[7] = v153;
LABEL_205:
            v151 = v146[2];
            v152 = (v152 - v151);
          }
          while (v151 < v152);
        }
      }
LABEL_215:
      v158 = (uint64_t)(v146 + 524);
      bit_vector_set_9027(v158, (v150 >> 20));
      v159 = (v150 + 3072) >> 20;
      if (v159 > (v150 >> 20))
      {
        v160 = (v150 >> 20) + 1;
        do
        {
          v161 = v160;
          bit_vector_set_9027(v158, v160++);
        }
        while (v159 > v161);
      }
      v136 = v246;
      if (v150 != *(_DWORD *)(v246 + 48))
      {
        v230 = __si_assert_copy_extra_268();
        v222 = v230;
        v231 = "";
        if (v230)
          v231 = v230;
        __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 524, "offset == nCentroids", v231);
        goto LABEL_316;
      }
      v162 = (void *)_windowsResolvePtr(*(_QWORD *)(v246 + 40) + 40, *(_QWORD *)(*(_QWORD *)(v246 + 40) + 24) + *(_QWORD *)(*(_QWORD *)(v246 + 40) + 16) * v150, 0xC00uLL);
      memcpy(v162, (char *)v119 + 3076 * v143, 0xC00uLL);
      ++*(_DWORD *)(v246 + 48);
      *(_DWORD *)(_windowsResolvePtr(*(_QWORD *)(v136 + 40) + 40, 0x400uLL, *(_QWORD *)(*(_QWORD *)(v136 + 40) + 16))+ 4) = *(_DWORD *)(v136 + 48);
      v134 = v247;
      v135 = v240;
LABEL_195:
      if (++v143 >= (unint64_t)(v134 - 1431655765 * ((unint64_t)(v261 - v260) >> 10)))
        goto LABEL_187;
    }
    v148 = v146[7];
    v149 = v148 + v147;
LABEL_200:
    v146[7] = v149;
    v150 = (v148 - v146[3]) / v147;
    if (v147 <= 0xBFF)
      goto LABEL_201;
    goto LABEL_215;
  }
  v135 = 0;
  v136 = v246;
LABEL_187:
  v240 = v135;
  v137 = v263;
  v138 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v263 + 24))(v263);
  v139 = (*(uint64_t (**)(std::string::size_type))(*(_QWORD *)v136 + 24))(v136);
  if (v138 == (_DWORD)v139)
  {
    v139 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v137 + 24))(v137);
    if ((_DWORD)v139)
    {
      v140 = 0;
      while (1)
      {
        v141 = (const void *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v137 + 64))(v137, v140);
        v142 = (const void *)(*(uint64_t (**)(std::string::size_type, uint64_t))(*(_QWORD *)v136 + 64))(v136, v140);
        v139 = memcmp(v141, v142, 0xC00uLL);
        v47 = (_DWORD)v139 != 0;
        if ((_DWORD)v139)
          break;
        v140 = (v140 + 1);
        v139 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v137 + 24))(v137);
        if (v140 >= v139)
          goto LABEL_192;
      }
    }
    else
    {
LABEL_192:
      v47 = 0;
    }
  }
  else
  {
    v47 = 1;
  }
  v163 = 16 * v236;
  MEMORY[0x1E0C80A78](v139);
  v164 = &v234 - v236;
  bzero(v164, 2 * v235);
  if (v238 != v237)
    bzero((char *)&v234 - v163, v163);
  v165 = *v248;
  v252.__r_.__value_.__r.__words[0] = (std::string::size_type)&v234 - v163;
  v252.__r_.__value_.__l.__size_ = v165;
  v166 = v245;
  v252.__r_.__value_.__r.__words[2] = v136;
  v253 = v245;
  if (v245)
  {
    v167 = (unint64_t *)&v245->__shared_owners_;
    do
      v168 = __ldxr(v167);
    while (__stxr(v168 + 1, v167));
  }
  dispatch_apply_f(v236, 0, &v252, (void (__cdecl *)(void *, size_t))IVFVectorIndexTemplate<float,768>::IVFVectorIndexRootBase::trainOnce(std::shared_ptr<QuantizerManager<float,768>>,std::vector<IVFVectorIndexTemplate<float,768>::IVFVectorIndexRootBase*,std::allocator<IVFVectorIndexTemplate<float,768>::IVFVectorIndexRootBase*>>,unsigned int,unsigned int)::{lambda(void *,unsigned long)#1}::__invoke);
  v169 = *v248;
  if (v248[1] != *v248)
  {
    v170 = 0;
    v171 = (unint64_t *)&v166->__shared_owners_;
    do
    {
      v172 = *(_QWORD *)(v169 + 8 * v170);
      v250 = v136;
      v251 = v166;
      if (v166)
      {
        do
          v173 = __ldxr(v171);
        while (__stxr(v173 + 1, v171));
      }
      v174 = v164[v170];
      v249 = v174;
      if (*((_QWORD *)&v174 + 1))
      {
        v175 = (unint64_t *)(*((_QWORD *)&v174 + 1) + 8);
        do
          v176 = __ldxr(v175);
        while (__stxr(v176 + 1, v175));
      }
      (*(void (**)(uint64_t, std::string::size_type *, __int128 *))(*(_QWORD *)v172 + 48))(v172, &v250, &v249);
      v177 = (std::__shared_weak_count *)*((_QWORD *)&v249 + 1);
      if (!*((_QWORD *)&v249 + 1))
        goto LABEL_237;
      v178 = (unint64_t *)(*((_QWORD *)&v249 + 1) + 8);
      do
        v179 = __ldaxr(v178);
      while (__stlxr(v179 - 1, v178));
      if (!v179)
      {
        ((void (*)(std::__shared_weak_count *))v177->__on_zero_shared)(v177);
        std::__shared_weak_count::__release_weak(v177);
        v180 = v251;
        if (!v251)
          goto LABEL_243;
      }
      else
      {
LABEL_237:
        v180 = v251;
        if (!v251)
          goto LABEL_243;
      }
      v181 = (unint64_t *)&v180->__shared_owners_;
      do
        v182 = __ldaxr(v181);
      while (__stlxr(v182 - 1, v181));
      if (!v182)
      {
        ((void (*)(std::__shared_weak_count *))v180->__on_zero_shared)(v180);
        std::__shared_weak_count::__release_weak(v180);
      }
LABEL_243:
      v183 = v243[v170];
      (*(void (**)(_BYTE *__return_ptr))(**(_QWORD **)(*v248 + 8 * v170) + 24))(v266);
      v184 = *(std::__shared_weak_count **)&v266[8];
      v185 = *(_DWORD *)(*(_QWORD *)v266 + 72);
      if (*(_QWORD *)&v266[8])
      {
        v186 = (unint64_t *)(*(_QWORD *)&v266[8] + 8);
        do
          v187 = __ldaxr(v186);
        while (__stlxr(v187 - 1, v186));
        if (!v187)
        {
          ((void (*)(std::__shared_weak_count *))v184->__on_zero_shared)(v184);
          std::__shared_weak_count::__release_weak(v184);
        }
      }
      if (v183 != v185)
      {
        v224 = __si_assert_copy_extra_268();
        v222 = v224;
        v225 = "";
        if (v224)
          v225 = v224;
        __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2056, "vectorCounts[i] == vectorIndexes[i]->getPartitions()->nVectors()", v225);
        goto LABEL_316;
      }
      ++v170;
      v169 = *v248;
      v166 = v245;
      v136 = v246;
    }
    while (v170 < (uint64_t)(v248[1] - *v248) >> 3);
  }
  v188 = *__error();
  v189 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v189, OS_LOG_TYPE_DEFAULT))
  {
    v190 = v240;
    v191 = v244 - v240;
    v192 = CFAbsoluteTimeGetCurrent();
    *(_DWORD *)v266 = 67110144;
    *(_DWORD *)&v266[4] = v239;
    *(_WORD *)&v266[8] = 1024;
    *(_DWORD *)&v266[10] = v191;
    *(_WORD *)&v266[14] = 1024;
    *(_DWORD *)&v266[16] = v190;
    *(_WORD *)&v266[20] = 1024;
    *(_DWORD *)&v266[22] = v47;
    *(_WORD *)&v266[26] = 2048;
    *(double *)&v266[28] = v192 - Current;
    _os_log_impl(&dword_1B8270000, v189, OS_LOG_TYPE_DEFAULT, "training quantizer try addCentroids=%u added=%d removed=%u changed=%d duration: %fs", v266, 0x24u);
  }
  *__error() = v188;
  v193 = v253;
  if (v253)
  {
    v194 = (unint64_t *)&v253->__shared_owners_;
    do
      v195 = __ldaxr(v194);
    while (__stlxr(v195 - 1, v194));
    if (!v195)
    {
      ((void (*)(std::__shared_weak_count *))v193->__on_zero_shared)(v193);
      std::__shared_weak_count::__release_weak(v193);
    }
  }
  if (v238 != v237)
  {
    v196 = &v164[v236];
    do
    {
      v197 = (std::__shared_weak_count *)*((_QWORD *)v196 - 1);
      if (v197)
      {
        v198 = (unint64_t *)&v197->__shared_owners_;
        do
          v199 = __ldaxr(v198);
        while (__stlxr(v199 - 1, v198));
        if (!v199)
        {
          ((void (*)(std::__shared_weak_count *))v197->__on_zero_shared)(v197);
          std::__shared_weak_count::__release_weak(v197);
        }
      }
      --v196;
    }
    while (v196 != v164);
  }
  do
    v200 = __ldaxr(v122);
  while (__stlxr(v200 - 1, v122));
  v81 = v245;
  if (!v200)
  {
    v201 = v242;
    ((void (*)(std::__shared_weak_count *))v242->__on_zero_shared)(v242);
    std::__shared_weak_count::__release_weak(v201);
  }
  *(_QWORD *)v258 = off_1E6E33370;
  v9 = v243;
  if (v260)
  {
    v261 = v260;
    operator delete(v260);
  }
  *(_QWORD *)v258 = off_1E6E30F58;
  if (SBYTE7(v259) < 0)
    operator delete(*(void **)&v258[8]);
LABEL_272:
  if (v81)
  {
    v202 = (unint64_t *)&v81->__shared_owners_;
    do
      v203 = __ldaxr(v202);
    while (__stlxr(v203 - 1, v202));
    if (!v203)
    {
      ((void (*)(std::__shared_weak_count *))v81->__on_zero_shared)(v81);
      std::__shared_weak_count::__release_weak(v81);
    }
  }
  if (v9)
    operator delete(v9);
  v204 = v264;
  if (v264)
  {
    v205 = (unint64_t *)&v264->__shared_owners_;
    do
      v206 = __ldaxr(v205);
    while (__stlxr(v206 - 1, v205));
    if (!v206)
    {
      ((void (*)(std::__shared_weak_count *))v204->__on_zero_shared)(v204);
      std::__shared_weak_count::__release_weak(v204);
    }
  }
  return v47;
}

_QWORD *QuantizerManager<float,768>::lastTrainedQuantizer(_QWORD *result, uint64_t a2)
{
  unsigned __int8 v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned __int8 v6;
  unint64_t *v7;
  unint64_t v8;
  char *v9;
  char *v10;
  const char *v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  int v15;

  v2 = atomic_load((unsigned __int8 *)(a2 + 72));
  if ((v2 & 1) == 0)
  {
    v9 = __si_assert_copy_extra_268();
    v10 = v9;
    v11 = "";
    if (v9)
      v11 = v9;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 730, "_training.test()", v11);
    free(v10);
    if (__valid_fs(-1))
      v12 = 2989;
    else
      v12 = 3072;
    *(_DWORD *)v12 = -559038737;
    abort();
  }
  v3 = *(_QWORD *)(a2 + 96);
  if (v3)
  {
    v4 = *(_QWORD *)(a2 + 104);
    *result = v3;
    result[1] = v4;
    if (!v4)
      return result;
    goto LABEL_12;
  }
  v5 = *(_QWORD *)(a2 + 80);
  if (v5)
  {
    v4 = *(_QWORD *)(a2 + 88);
    *result = v5;
    result[1] = v4;
    if (!v4)
      return result;
    goto LABEL_12;
  }
  if ((v6 & 1) == 0)
  {
    v14 = result;
    result = v14;
    if (v15)
    {
      __cxa_atexit((void (*)(void *))std::shared_ptr<Quantizer<float,768>>::~shared_ptr[abi:nn180100], &ZeroVectorQuantizer<float,768>::sharedInstance(void)::zvq, &dword_1B8270000);
      result = v14;
    }
  }
  if (ZeroVectorQuantizer<float,768>::sharedInstance(void)::onceToken != -1)
  {
    v13 = result;
    dispatch_once(&ZeroVectorQuantizer<float,768>::sharedInstance(void)::onceToken, &__block_literal_global_731_5706);
    result = v13;
  }
  v4 = qword_1EF1AFA68;
  *result = ZeroVectorQuantizer<float,768>::sharedInstance(void)::zvq;
  result[1] = v4;
  if (v4)
  {
LABEL_12:
    v7 = (unint64_t *)(v4 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  return result;
}

void ___ZN16QuantizerManagerIfLi768EE23commitTrainingQuantizerEv_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  int v3;
  size_t v4;
  unint64_t v5;
  std::string *p_dst;
  uint64_t v7;
  uint64_t v8;
  const void *v9;
  int v10;
  std::string *p_p;
  std::string::size_type size;
  std::string *v13;
  std::string::size_type v14;
  std::string *v15;
  int64_t v16;
  uint64_t v17;
  void **v18;
  std::__shared_weak_count *v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t *p_shared_weak_owners;
  unint64_t v23;
  uint64_t *v24;
  int v25;
  int v26;
  unint64_t v27;
  unint64_t v28;
  uint8x8_t v29;
  unint64_t v30;
  void **v31;
  void *v32;
  unint64_t v33;
  uint64_t v34;
  float v35;
  float v36;
  _BOOL8 v37;
  unint64_t v38;
  unint64_t v39;
  size_t prime;
  unint64_t v41;
  uint8x8_t v42;
  uint64_t v43;
  uint64_t v44;
  _QWORD *v45;
  unint64_t v46;
  std::__shared_weak_count *v47;
  std::__shared_weak_count *v48;
  unint64_t *v49;
  unint64_t v50;
  unint64_t *p_shared_owners;
  unint64_t v52;
  std::__shared_weak_count *v53;
  int v54;
  size_t v55;
  unint64_t v56;
  void *v57;
  uint64_t v58;
  uint64_t v59;
  const void *v60;
  uint64_t v61;
  uint64_t v62;
  unint64_t *v63;
  unint64_t v64;
  std::__shared_weak_count *v65;
  unint64_t *v66;
  unint64_t v67;
  uint64_t v68;
  void **v69;
  uint64_t v70;
  unint64_t *v71;
  uint64_t v72;
  uint64_t v73;
  int v74;
  uint64_t v75;
  uint64_t v77;
  int *v78;
  std::__shared_weak_count *v79;
  unint64_t *v80;
  unint64_t v81;
  std::string __p;
  std::string __dst;
  std::string v84;
  void *v85[2];
  int64_t v86;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(_QWORD *)(v1 + 80);
  if (!v2)
    goto LABEL_109;
  v3 = *(char *)(v1 + 71);
  if (v3 >= 0)
    v4 = *(unsigned __int8 *)(v1 + 71);
  else
    v4 = *(_QWORD *)(v1 + 56);
  v5 = v4 + 1;
  if (v4 + 1 > 0x7FFFFFFFFFFFFFF7)
LABEL_149:
    abort();
  if (v5 >= 0x17)
  {
    v7 = (v5 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v5 | 7) != 0x17)
      v7 = v5 | 7;
    v8 = v7 + 1;
    p_dst = (std::string *)operator new(v7 + 1);
    __dst.__r_.__value_.__l.__size_ = v4 + 1;
    __dst.__r_.__value_.__r.__words[2] = v8 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
  }
  else
  {
    memset(&__dst, 0, sizeof(__dst));
    p_dst = &__dst;
    *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v4 + 1;
    if (!v4)
      goto LABEL_16;
  }
  if (v3 >= 0)
    v9 = (const void *)(v1 + 48);
  else
    v9 = *(const void **)(v1 + 48);
  memmove(p_dst, v9, v4);
LABEL_16:
  *(_WORD *)((char *)&p_dst->__r_.__value_.__l.__data_ + v4) = 46;
  v10 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 16))(v2);
  std::to_string(&__p, v10);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  else
    size = __p.__r_.__value_.__l.__size_;
  v13 = std::string::append(&__dst, (const std::string::value_type *)p_p, size);
  v14 = v13->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v84.__r_.__value_.__l.__data_ = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
  v84.__r_.__value_.__r.__words[2] = v14;
  v13->__r_.__value_.__l.__size_ = 0;
  v13->__r_.__value_.__r.__words[2] = 0;
  v13->__r_.__value_.__r.__words[0] = 0;
  v15 = std::string::append(&v84, ".quantizer");
  v16 = v15->__r_.__value_.__r.__words[2];
  *(_OWORD *)v85 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
  v86 = v16;
  v15->__r_.__value_.__l.__size_ = 0;
  v15->__r_.__value_.__r.__words[2] = 0;
  v15->__r_.__value_.__r.__words[0] = 0;
  if ((SHIBYTE(v84.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_24;
LABEL_36:
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_25;
    goto LABEL_37;
  }
  operator delete(v84.__r_.__value_.__l.__data_);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_36;
LABEL_24:
  if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    goto LABEL_25;
LABEL_37:
  operator delete(__dst.__r_.__value_.__l.__data_);
LABEL_25:
  v17 = *(_QWORD *)(v1 + 80);
  if (v86 >= 0)
    v18 = v85;
  else
    v18 = (void **)v85[0];
  fd_rename(*(_QWORD *)(*(_QWORD *)(v17 + 40) + 40), (const char *)v18);
  MEMORY[0x1BCCB03B0](v17 + 8, v18);
  atomic_store(1u, (unsigned __int8 *)(*(_QWORD *)(v1 + 80) + 57));
  v20 = *(_QWORD *)(v1 + 80);
  v19 = *(std::__shared_weak_count **)(v1 + 88);
  v21 = v20;
  if (v19)
  {
    p_shared_weak_owners = (unint64_t *)&v19->__shared_weak_owners_;
    do
      v23 = __ldxr(p_shared_weak_owners);
    while (__stxr(v23 + 1, p_shared_weak_owners));
    v21 = *(_QWORD *)(v1 + 80);
  }
  v24 = (uint64_t *)(v1 + 112);
  v25 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v21 + 16))(v21);
  v26 = v25;
  v27 = v25;
  v28 = *(_QWORD *)(v1 + 120);
  if (v28)
  {
    v29 = (uint8x8_t)vcnt_s8((int8x8_t)v28);
    v29.i16[0] = vaddlv_u8(v29);
    if (v29.u32[0] > 1uLL)
    {
      v30 = v25;
      if (v28 <= v25)
        v30 = v25 % v28;
    }
    else
    {
      v30 = (v28 - 1) & v25;
    }
    v31 = *(void ***)(*v24 + 8 * v30);
    if (v31)
    {
      v32 = *v31;
      if (*v31)
      {
        if (v29.u32[0] < 2uLL)
        {
          while (1)
          {
            v34 = *((_QWORD *)v32 + 1);
            if (v34 == v25)
            {
              if (*((_DWORD *)v32 + 4) == v25)
                goto LABEL_94;
            }
            else if ((v34 & (v28 - 1)) != v30)
            {
              goto LABEL_56;
            }
            v32 = *(void **)v32;
            if (!v32)
              goto LABEL_56;
          }
        }
        do
        {
          v33 = *((_QWORD *)v32 + 1);
          if (v33 == v25)
          {
            if (*((_DWORD *)v32 + 4) == v25)
              goto LABEL_94;
          }
          else
          {
            if (v33 >= v28)
              v33 %= v28;
            if (v33 != v30)
              break;
          }
          v32 = *(void **)v32;
        }
        while (v32);
      }
    }
  }
  else
  {
    v30 = 0;
  }
LABEL_56:
  v32 = operator new(0x28uLL);
  *(_QWORD *)v32 = 0;
  *((_QWORD *)v32 + 1) = v27;
  *((_DWORD *)v32 + 4) = v26;
  *((_QWORD *)v32 + 3) = 0;
  *((_QWORD *)v32 + 4) = 0;
  v35 = (float)(unint64_t)(*(_QWORD *)(v1 + 136) + 1);
  v36 = *(float *)(v1 + 144);
  if (!v28 || (float)(v36 * (float)v28) < v35)
  {
    v37 = 1;
    if (v28 >= 3)
      v37 = (v28 & (v28 - 1)) != 0;
    v38 = v37 | (2 * v28);
    v39 = vcvtps_u32_f32(v35 / v36);
    if (v38 <= v39)
      prime = v39;
    else
      prime = v38;
    if (prime == 1)
    {
      prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      prime = std::__next_prime(prime);
      v28 = *(_QWORD *)(v1 + 120);
    }
    if (prime > v28)
      goto LABEL_78;
    if (prime < v28)
    {
      v41 = vcvtps_u32_f32((float)*(unint64_t *)(v1 + 136) / *(float *)(v1 + 144));
      if (v28 < 3 || (v42 = (uint8x8_t)vcnt_s8((int8x8_t)v28), v42.i16[0] = vaddlv_u8(v42), v42.u32[0] > 1uLL))
      {
        v41 = std::__next_prime(v41);
      }
      else
      {
        v43 = 1 << -(char)__clz(v41 - 1);
        if (v41 >= 2)
          v41 = v43;
      }
      if (prime <= v41)
        prime = v41;
      if (prime < v28)
LABEL_78:
        std::__hash_table<std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,std::__unordered_map_hasher<SIUnicodeString,std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,HashFunction,HashEqual,true>,std::__unordered_map_equal<SIUnicodeString,std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,HashEqual,HashFunction,true>,std::allocator<std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>>>::__do_rehash<true>(v1 + 112, prime);
    }
    v28 = *(_QWORD *)(v1 + 120);
    if ((v28 & (v28 - 1)) != 0)
    {
      if (v28 <= v27)
        v30 = v27 % v28;
      else
        v30 = v27;
    }
    else
    {
      v30 = (v28 - 1) & v27;
    }
  }
  v44 = *v24;
  v45 = *(_QWORD **)(*v24 + 8 * v30);
  if (v45)
  {
    *(_QWORD *)v32 = *v45;
LABEL_92:
    *v45 = v32;
    goto LABEL_93;
  }
  *(_QWORD *)v32 = *(_QWORD *)(v1 + 128);
  *(_QWORD *)(v1 + 128) = v32;
  *(_QWORD *)(v44 + 8 * v30) = v1 + 128;
  if (*(_QWORD *)v32)
  {
    v46 = *(_QWORD *)(*(_QWORD *)v32 + 8);
    if ((v28 & (v28 - 1)) != 0)
    {
      if (v46 >= v28)
        v46 %= v28;
    }
    else
    {
      v46 &= v28 - 1;
    }
    v45 = (_QWORD *)(*v24 + 8 * v46);
    goto LABEL_92;
  }
LABEL_93:
  ++*(_QWORD *)(v1 + 136);
LABEL_94:
  if (v19)
  {
    v47 = std::__shared_weak_count::lock(v19);
    v48 = v47;
    if (v47)
    {
      v49 = (unint64_t *)&v47->__shared_weak_owners_;
      do
        v50 = __ldxr(v49);
      while (__stxr(v50 + 1, v49));
      std::__shared_weak_count::__release_weak(v19);
      p_shared_owners = (unint64_t *)&v48->__shared_owners_;
      do
        v52 = __ldaxr(p_shared_owners);
      while (__stlxr(v52 - 1, p_shared_owners));
      if (v52)
        goto LABEL_105;
      ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
      v19 = v48;
    }
    else
    {
      v20 = 0;
    }
    std::__shared_weak_count::__release_weak(v19);
  }
  else
  {
    v20 = 0;
    v48 = 0;
  }
LABEL_105:
  v53 = (std::__shared_weak_count *)*((_QWORD *)v32 + 4);
  *((_QWORD *)v32 + 3) = v20;
  *((_QWORD *)v32 + 4) = v48;
  if (v53)
    std::__shared_weak_count::__release_weak(v53);
  if (SHIBYTE(v86) < 0)
    operator delete(v85[0]);
LABEL_109:
  v54 = *(char *)(v1 + 71);
  if (v54 >= 0)
    v55 = *(unsigned __int8 *)(v1 + 71);
  else
    v55 = *(_QWORD *)(v1 + 56);
  v56 = v55 + 10;
  if (v55 + 10 > 0x7FFFFFFFFFFFFFF7)
    goto LABEL_149;
  if (v56 >= 0x17)
  {
    v58 = (v56 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v56 | 7) != 0x17)
      v58 = v56 | 7;
    v59 = v58 + 1;
    v57 = operator new(v58 + 1);
    v85[1] = (void *)(v55 + 10);
    v86 = v59 | 0x8000000000000000;
    v85[0] = v57;
  }
  else
  {
    v85[1] = 0;
    v86 = 0;
    v85[0] = 0;
    v57 = v85;
    HIBYTE(v86) = v55 + 10;
    if (!v55)
      goto LABEL_123;
  }
  if (v54 >= 0)
    v60 = (const void *)(v1 + 48);
  else
    v60 = *(const void **)(v1 + 48);
  memmove(v57, v60, v55);
LABEL_123:
  strcpy((char *)v57 + v55, ".quantizer");
  v62 = *(_QWORD *)(v1 + 96);
  v61 = *(_QWORD *)(v1 + 104);
  if (v61)
  {
    v63 = (unint64_t *)(v61 + 8);
    do
      v64 = __ldxr(v63);
    while (__stxr(v64 + 1, v63));
  }
  v65 = *(std::__shared_weak_count **)(v1 + 88);
  *(_QWORD *)(v1 + 80) = v62;
  *(_QWORD *)(v1 + 88) = v61;
  if (v65)
  {
    v66 = (unint64_t *)&v65->__shared_owners_;
    do
      v67 = __ldaxr(v66);
    while (__stlxr(v67 - 1, v66));
    if (!v67)
    {
      ((void (*)(std::__shared_weak_count *))v65->__on_zero_shared)(v65);
      std::__shared_weak_count::__release_weak(v65);
    }
  }
  v68 = *(_QWORD *)(v1 + 80);
  if (v86 >= 0)
    v69 = v85;
  else
    v69 = (void **)v85[0];
  fd_rename(*(_QWORD *)(*(_QWORD *)(v68 + 40) + 40), (const char *)v69);
  MEMORY[0x1BCCB03B0](v68 + 8, v69);
  v70 = *(_QWORD *)(v1 + 80);
  v71 = *(unint64_t **)(v70 + 40);
  *v71 = 0;
  vi_onefixedsize_disk_allocator::storeHeader(v71);
  storage_array_SyncPages(*(_QWORD *)(v70 + 40) + 8, *(_QWORD *)(v70 + 40) + 4192);
  storage_array_Truncate((uint64_t *)(*(_QWORD *)(v70 + 40) + 8));
  v72 = *(_QWORD *)(v70 + 40);
  fd_make_readonly(*(_QWORD *)(v72 + 40));
  v73 = *(_QWORD *)(v72 + 40);
  if (v73)
  {
    do
    {
      v74 = fchmodat(*(_DWORD *)(v73 + 44), *(const char **)(v73 + 72), 0x100u, 2048);
      v75 = g_prot_error_callback;
      if (v74 != -1 || g_prot_error_callback == 0)
        break;
      v77 = *(unsigned int *)(v73 + 40);
      v78 = __error();
    }
    while (((*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t))(v75 + 16))(v75, v77, *v78, 19) & 1) != 0);
  }
  *(_BYTE *)(v70 + 56) = 1;
  v79 = *(std::__shared_weak_count **)(v1 + 104);
  *(_QWORD *)(v1 + 96) = 0;
  *(_QWORD *)(v1 + 104) = 0;
  if (!v79)
    goto LABEL_144;
  v80 = (unint64_t *)&v79->__shared_owners_;
  do
    v81 = __ldaxr(v80);
  while (__stlxr(v81 - 1, v80));
  if (v81)
  {
LABEL_144:
    if ((SHIBYTE(v86) & 0x80000000) == 0)
      return;
    goto LABEL_145;
  }
  ((void (*)(std::__shared_weak_count *))v79->__on_zero_shared)(v79);
  std::__shared_weak_count::__release_weak(v79);
  if (SHIBYTE(v86) < 0)
LABEL_145:
    operator delete(v85[0]);
}

uint64_t **MaxSizePriorityQueue<AnyPartitionStore::CandidateEntry,std::vector<AnyPartitionStore::CandidateEntry>,AnyPartitionStore::CandidateQueue::Lesser>::allItems(uint64_t **result, _BYTE *a2, _BYTE *a3)
{
  int64_t v3;
  uint64_t **v5;
  uint64_t *v6;
  char *v7;
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  float v18;
  int v19;
  char *v20;

  *result = 0;
  result[1] = 0;
  result[2] = 0;
  v3 = a3 - a2;
  if (a3 == a2)
  {
    v7 = 0;
    v6 = 0;
  }
  else
  {
    if (v3 < 0)
      abort();
    v5 = result;
    v6 = (uint64_t *)operator new(a3 - a2);
    *v5 = v6;
    v7 = (char *)&v6[v3 >> 3];
    v5[2] = (uint64_t *)v7;
    result = (uint64_t **)memcpy(v6, a2, v3);
    v5[1] = (uint64_t *)v7;
  }
  if (v7 - (char *)v6 >= 9)
  {
    v8 = (unint64_t)(v7 - (char *)v6) >> 3;
    do
    {
      v10 = 0;
      v11 = *v6;
      v12 = (char *)v6;
      do
      {
        v13 = v12;
        v12 += 8 * v10 + 8;
        v14 = 2 * v10;
        v10 = (2 * v10) | 1;
        v15 = v14 + 2;
        if (v15 < v8 && *((float *)v12 + 1) < *((float *)v12 + 3))
        {
          v12 += 8;
          v10 = v15;
        }
        *(_QWORD *)v13 = *(_QWORD *)v12;
      }
      while (v10 <= (uint64_t)((unint64_t)(v8 - 2) >> 1));
      v7 -= 8;
      if (v12 == v7)
      {
        *(_QWORD *)v12 = v11;
      }
      else
      {
        *(_QWORD *)v12 = *(_QWORD *)v7;
        *(_QWORD *)v7 = v11;
        v16 = v12 - (char *)v6 + 8;
        if (v16 >= 9)
        {
          v17 = (((unint64_t)v16 >> 3) - 2) >> 1;
          v18 = *((float *)v12 + 1);
          if (*((float *)&v6[v17] + 1) < v18)
          {
            v19 = *(_DWORD *)v12;
            do
            {
              v20 = v12;
              v12 = (char *)&v6[v17];
              *(_QWORD *)v20 = *(_QWORD *)v12;
              if (!v17)
                break;
              v17 = (v17 - 1) >> 1;
            }
            while (*((float *)&v6[v17] + 1) < v18);
            *(_DWORD *)v12 = v19;
            *((float *)v12 + 1) = v18;
          }
        }
      }
    }
    while (v8-- > 2);
  }
  return result;
}

char *std::vector<std::vector<AnyPartitionStore::CandidateEntry>>::__push_back_slow_path<std::vector<AnyPartitionStore::CandidateEntry> const&>(char **a1, const void *a2, uint64_t a3)
{
  char *v3;
  char *v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v10;
  char *v11;
  char *v12;
  int64_t v13;
  void *v14;
  unint64_t v15;
  char *v16;
  char *v17;
  char *v18;
  __int128 v19;
  char *v20;
  char *v21;
  void *v22;
  void *v23;

  v4 = *a1;
  v3 = a1[1];
  v5 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  v6 = v5 + 1;
  if (v5 + 1 > 0xAAAAAAAAAAAAAAALL)
    goto LABEL_25;
  if (0x5555555555555556 * ((a1[2] - v4) >> 3) > v6)
    v6 = 0x5555555555555556 * ((a1[2] - v4) >> 3);
  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - v4) >> 3) >= 0x555555555555555)
    v10 = 0xAAAAAAAAAAAAAAALL;
  else
    v10 = v6;
  if (v10)
  {
    if (v10 > 0xAAAAAAAAAAAAAAALL)
      std::__throw_bad_array_new_length[abi:nn180100]();
    v11 = (char *)operator new(24 * v10);
  }
  else
  {
    v11 = 0;
  }
  v12 = &v11[24 * v5];
  *((_QWORD *)v12 + 1) = 0;
  *(_QWORD *)v12 = 0;
  *((_QWORD *)v12 + 2) = 0;
  v13 = a3 - (_QWORD)a2;
  if (v13)
  {
    if ((v13 & 0x8000000000000000) == 0)
    {
      v14 = operator new(v13);
      *(_QWORD *)v12 = v14;
      v15 = (unint64_t)v14 + 8 * (v13 >> 3);
      memcpy(v14, a2, v13);
      *(int64x2_t *)(v12 + 8) = vdupq_n_s64(v15);
      goto LABEL_14;
    }
LABEL_25:
    abort();
  }
LABEL_14:
  v16 = &v11[24 * v10];
  v17 = v12 + 24;
  if (v3 == v4)
  {
    *a1 = v12;
    a1[1] = v17;
    a1[2] = v16;
  }
  else
  {
    do
    {
      v18 = v12;
      *((_QWORD *)v12 - 2) = 0;
      *((_QWORD *)v12 - 1) = 0;
      v19 = *(_OWORD *)(v3 - 24);
      v3 -= 24;
      *(_OWORD *)(v12 - 24) = v19;
      v12 -= 24;
      *((_QWORD *)v18 - 1) = *((_QWORD *)v3 + 2);
      *(_QWORD *)v3 = 0;
      *((_QWORD *)v3 + 1) = 0;
      *((_QWORD *)v3 + 2) = 0;
    }
    while (v3 != v4);
    v3 = *a1;
    v20 = a1[1];
    *a1 = v12;
    a1[1] = v17;
    a1[2] = v16;
    if (v20 != v3)
    {
      v21 = v20;
      do
      {
        v23 = (void *)*((_QWORD *)v21 - 3);
        v21 -= 24;
        v22 = v23;
        if (v23)
        {
          *((_QWORD *)v20 - 2) = v22;
          operator delete(v22);
        }
        v20 = v21;
      }
      while (v21 != v3);
    }
  }
  if (v3)
    operator delete(v3);
  return v17;
}

float ___ZN22IVFVectorIndexTemplateIfLi768EE22IVFVectorIndexRootBase9trainOnceENSt3__110shared_ptrI16QuantizerManagerIfLi768EEEENS2_6vectorIPS1_NS2_9allocatorIS8_EEEEjj_block_invoke(uint64_t a1, unsigned int a2, float *a3)
{
  const void *v6;
  uint64_t v7;
  float *v8;
  float *v9;
  float v10;
  float result;
  void *__p;
  void *v13;
  uint64_t v14;

  v6 = (const void *)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 32) + 32))(*(_QWORD *)(a1 + 32), *(unsigned int *)a3);
  if (*(_DWORD *)(a1 + 64))
  {
    __p = 0;
    v13 = 0;
    v14 = 0;
    (*(void (**)(void **__return_ptr, _QWORD, const void *, uint64_t))(**(_QWORD **)(a1 + 40) + 72))(&__p, *(_QWORD *)(a1 + 40), v6, 1);
    if (*((float *)__p + 1) < a3[1])
      a2 = *(_DWORD *)(a1 + 68) + *(_DWORD *)__p;
    v13 = __p;
    operator delete(__p);
  }
  v7 = *(_QWORD *)(a1 + 48);
  v8 = (float *)(v7 + 3076 * a2);
  v9 = v8 + 768;
  v10 = v8[768];
  if (v10 == 0.0)
  {
    memcpy((void *)(v7 + 3076 * a2), v6, 0xC00uLL);
  }
  else
  {
    vDSP_vavlin((const float *)v6, 1, v8 + 768, v8, 1, 0x300uLL);
    v10 = *v9;
  }
  result = v10 + 1.0;
  *v9 = v10 + 1.0;
  return result;
}

void IVFVectorIndexTemplate<float,768>::IVFVectorIndexRootBase::trainOnce(std::shared_ptr<QuantizerManager<float,768>>,std::vector<IVFVectorIndexTemplate<float,768>::IVFVectorIndexRootBase*,std::allocator<IVFVectorIndexTemplate<float,768>::IVFVectorIndexRootBase*>>,unsigned int,unsigned int)::{lambda(void *,unsigned long)#1}::__invoke(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  _QWORD *v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  uint64_t v23;
  std::__shared_weak_count *v24;
  uint64_t v25;
  std::__shared_weak_count *v26;

  v4 = a1[2];
  v5 = *(_QWORD *)(a1[1] + 8 * a2);
  v6 = (std::__shared_weak_count *)a1[3];
  v23 = v4;
  v24 = v6;
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t *))(*(_QWORD *)v5 + 40))(&v25, v5, &v23);
  v9 = (_QWORD *)(*a1 + 16 * a2);
  v11 = v25;
  v10 = v26;
  if (v26)
  {
    v12 = (unint64_t *)&v26->__shared_owners_;
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  v14 = (std::__shared_weak_count *)v9[1];
  *v9 = v11;
  v9[1] = v10;
  if (!v14)
    goto LABEL_11;
  v15 = (unint64_t *)&v14->__shared_owners_;
  do
    v16 = __ldaxr(v15);
  while (__stlxr(v16 - 1, v15));
  if (!v16)
  {
    ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
    std::__shared_weak_count::__release_weak(v14);
    v17 = v26;
    if (!v26)
      goto LABEL_17;
  }
  else
  {
LABEL_11:
    v17 = v26;
    if (!v26)
      goto LABEL_17;
  }
  v18 = (unint64_t *)&v17->__shared_owners_;
  do
    v19 = __ldaxr(v18);
  while (__stlxr(v19 - 1, v18));
  if (!v19)
  {
    ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
    std::__shared_weak_count::__release_weak(v17);
  }
LABEL_17:
  v20 = v24;
  if (v24)
  {
    v21 = (unint64_t *)&v24->__shared_owners_;
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
}

uint64_t __copy_helper_block_8_48c61_ZTSNSt3__110shared_ptrIA_23IVFVectorMeanCalculatorILi768EEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(result + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 56) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void __destroy_helper_block_8_48c61_ZTSNSt3__110shared_ptrIA_23IVFVectorMeanCalculatorILi768EEEE(uint64_t a1)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v3;

  v1 = *(std::__shared_weak_count **)(a1 + 56);
  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

void std::__shared_ptr_pointer<IVFVectorMeanCalculator<768> *,std::shared_ptr<IVFVectorMeanCalculator<768>[]>::__shared_ptr_default_delete<IVFVectorMeanCalculator<768>[],IVFVectorMeanCalculator<768>>,std::allocator<IVFVectorMeanCalculator<768>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BCCB06A4);
}

uint64_t std::__shared_ptr_pointer<IVFVectorMeanCalculator<768> *,std::shared_ptr<IVFVectorMeanCalculator<768>[]>::__shared_ptr_default_delete<IVFVectorMeanCalculator<768>[],IVFVectorMeanCalculator<768>>,std::allocator<IVFVectorMeanCalculator<768>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    JUMPOUT(0x1BCCB068CLL);
  return result;
}

uint64_t ArrayVectorQuantizer<float,768>::~ArrayVectorQuantizer(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = off_1E6E33370;
  v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(_QWORD *)(a1 + 48) = v2;
    operator delete(v2);
  }
  *(_QWORD *)a1 = off_1E6E30F58;
  if (*(char *)(a1 + 31) < 0)
    operator delete(*(void **)(a1 + 8));
  return a1;
}

void ArrayVectorQuantizer<float,768>::~ArrayVectorQuantizer(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = off_1E6E33370;
  v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(_QWORD *)(a1 + 48) = v2;
    operator delete(v2);
  }
  *(_QWORD *)a1 = off_1E6E30F58;
  if (*(char *)(a1 + 31) < 0)
    operator delete(*(void **)(a1 + 8));
  JUMPOUT(0x1BCCB06A4);
}

uint64_t ArrayVectorQuantizer<float,768>::count(uint64_t a1)
{
  return -1431655765 * ((*(_QWORD *)(a1 + 48) - *(_QWORD *)(a1 + 40)) >> 10);
}

uint64_t ArrayVectorQuantizer<float,768>::getCentroid(uint64_t a1, unsigned int a2)
{
  uint64_t v2;
  char *v4;
  char *v5;
  const char *v6;

  v2 = *(_QWORD *)(a1 + 40);
  if (0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(a1 + 48) - v2) >> 10) <= a2)
  {
    v4 = __si_assert_copy_extra_268();
    v5 = v4;
    v6 = "";
    if (v4)
      v6 = v4;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 443, "i < centroids.size()", v6);
    free(v5);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  return v2 + 3072 * a2;
}

_QWORD *QuantizerManager<float,768>::createFdPtrForFile(uint64_t a1, const char *a2)
{
  _QWORD *result;
  int v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  NSObject *v11;
  int *v12;
  int v13;
  uint64_t v14;
  const char *v15;
  int v16;
  const char *v17;
  __int16 v18;
  int v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  result = fd_create_protected(*(_DWORD *)a1, a2, 514, 3u);
  if (!result)
  {
    v5 = *__error();
    v6 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v13 = *(_DWORD *)a1;
      v16 = 136315906;
      v17 = "createFdPtrForFile";
      v18 = 1024;
      v19 = 742;
      v20 = 2080;
      v21 = a2;
      v22 = 1024;
      v23 = v13;
      _os_log_error_impl(&dword_1B8270000, v6, OS_LOG_TYPE_ERROR, "%s:%d: Could not create %s in parentFd: %i", (uint8_t *)&v16, 0x22u);
    }
    *__error() = v5;
    v7 = *(_QWORD *)(a1 + 80);
    if (v7)
    {
      v8 = *(_QWORD *)(v7 + 64);
      if (v8)
      {
        v9 = *(_DWORD *)(v8 + 44);
        *(_DWORD *)a1 = v9;
        if (v9 != -1)
          return fd_create_protected(v9, a2, 514, 3u);
      }
      else
      {
        *(_DWORD *)a1 = -1;
      }
    }
    v10 = *__error();
    v11 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT))
    {
      v14 = *(_QWORD *)(a1 + 80);
      if (v14)
      {
        v15 = (const char *)(v14 + 8);
        if (*(char *)(v14 + 31) < 0)
          v15 = *(const char **)v15;
      }
      else
      {
        v15 = "(null)";
      }
      v16 = 136315650;
      v17 = "createFdPtrForFile";
      v18 = 1024;
      v19 = 744;
      v20 = 2080;
      v21 = v15;
      _os_log_fault_impl(&dword_1B8270000, v11, OS_LOG_TYPE_FAULT, "%s:%d: Could not get parentFd from quantizer %s", (uint8_t *)&v16, 0x1Cu);
    }
    v12 = __error();
    result = 0;
    *v12 = v10;
  }
  return result;
}

uint64_t ___ZN22IVFVectorIndexTemplateIfLi768EE20IVFVectorIndexRoot_sI30vi_onefixedsize_disk_allocator16vi_disk_postingsE7compactIS2_EENSt3__19enable_ifIXsr13is_persistentIT_EE5valueEbE4typeEPS4_P12uint32_map_tP11TermIdStore18CICompactCallbacksPVi_block_invoke(uint64_t a1, unsigned int *a2, _BYTE *a3)
{
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  BOOL v9;
  uint64_t v10;
  char *v11;
  uint64_t result;
  char *v13;
  char *v14;
  const char *v15;

  v6 = (uint64_t *)*((_QWORD *)a2 + 3);
  v7 = *(_QWORD *)(a1 + 40);
  v8 = *v6;
  if (v6)
    v9 = v7 == 0;
  else
    v9 = 1;
  if (!v9)
  {
    if ((_DWORD)v8)
    {
      if (*(_DWORD *)(v7 + 4408) <= v8)
      {
        v13 = __si_assert_copy_extra(0);
        v14 = v13;
        v15 = "";
        if (v13)
          v15 = v13;
        __message_assert("%s:%u: failed assertion '%s' %s ", "storage.c", 1530, "position && position < inMap->count", v15);
        free(v14);
        if (__valid_fs(-1))
        {
          MEMORY[0xBAD] = -559038737;
          abort();
        }
        MEMORY[0xC00] = -559038737;
        abort();
      }
      v10 = *(_QWORD *)(a1 + 48);
      v11 = storageResolvePtr(v7, 4 * *v6, 4uLL, 1);
      v8 = *(_QWORD *)storageResolvePtr(v10, 8 * *(unsigned int *)v11, 8uLL, 1);
    }
    else
    {
      v8 = 0;
    }
  }
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::insertForCompact(*(_QWORD *)(a1 + 56), a2[2], *((void **)a2 + 2), v8, *a2, *((float *)a2 + 1));
  result = 1;
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
  if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) && !**(_DWORD **)(a1 + 64))
    result = (*(uint64_t (**)(_QWORD))(a1 + 88))(*(_QWORD *)(a1 + 96));
  *a3 = result;
  return result;
}

void IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::insertForCompact(uint64_t a1, unsigned int a2, void *a3, uint64_t a4, uint64_t a5, float a6)
{
  os_unfair_lock_s *v12;
  std::__shared_weak_count *v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  std::__shared_weak_count *v16;
  uint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  uint64_t v20;
  unsigned int v21;
  void *v22;
  uint64_t v23;
  float v24;
  char v25;
  unint64_t *v26;
  unint64_t v27;
  unint64_t *v28;
  unint64_t v29;
  char *v30;
  char *v31;
  const char *v32;

  v12 = (os_unfair_lock_s *)(a1 + 112);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 112));
  v13 = *(std::__shared_weak_count **)(a1 + 88);
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v15 = __ldxr(p_shared_owners);
    while (__stxr(v15 + 1, p_shared_owners));
  }
  v17 = *(_QWORD *)(a1 + 96);
  v16 = *(std::__shared_weak_count **)(a1 + 104);
  if (v16)
  {
    v18 = (unint64_t *)&v16->__shared_owners_;
    do
      v19 = __ldxr(v18);
    while (__stxr(v19 + 1, v18));
  }
  os_unfair_lock_unlock(v12);
  if ((_DWORD)a5 == -1)
  {
    v20 = a1;
    v21 = a2;
    v22 = a3;
    v23 = 0xFFFFFFFFLL;
    v24 = a6;
    v25 = 0;
  }
  else
  {
    if (*(_DWORD *)(v17 + 68) <= a5)
    {
      v30 = __si_assert_copy_extra_268();
      v31 = v30;
      v32 = "";
      if (v30)
        v32 = v30;
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2605, "partID == VECTOR_NOT_FOUND || partID < cur.partitions->nPartitions()", v32);
      free(v31);
      if (__valid_fs(-1))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
    v20 = a1;
    v21 = a2;
    v22 = a3;
    v23 = a5;
    v24 = a6;
    v25 = 1;
  }
  *((_QWORD *)IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::lookupForInsert(v20, v21, v22, v23, v25, v24)+ 384) = a4;
  if (!v16)
    goto LABEL_15;
  v26 = (unint64_t *)&v16->__shared_owners_;
  do
    v27 = __ldaxr(v26);
  while (__stlxr(v27 - 1, v26));
  if (!v27)
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
    if (!v13)
      return;
  }
  else
  {
LABEL_15:
    if (!v13)
      return;
  }
  v28 = (unint64_t *)&v13->__shared_owners_;
  do
    v29 = __ldaxr(v28);
  while (__stlxr(v29 - 1, v28));
  if (!v29)
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
}

uint64_t ___ZNK22IVFVectorIndexTemplateIfLi768EE20IVFVectorIndexRoot_sI30vi_onefixedsize_disk_allocator16vi_disk_postingsE4dumpEbbPViPvU13block_pointerFbjPKvybjfE_block_invoke(uint64_t a1, uint64_t a2, BOOL *a3)
{
  uint64_t result;

  result = (*(uint64_t (**)(float))(*(_QWORD *)(a1 + 32) + 16))(*(float *)(a2 + 4));
  *a3 = **(_DWORD **)(a1 + 40) != 0;
  return result;
}

uint64_t IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::enumerator(uint64_t a1)
{
  os_unfair_lock_s *v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  _QWORD v27[2];
  uint64_t v28;
  std::__shared_weak_count *v29;

  v2 = (os_unfair_lock_s *)(a1 + 112);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 112));
  v3 = *(std::__shared_weak_count **)(a1 + 88);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  v7 = *(_QWORD *)(a1 + 96);
  v6 = *(std::__shared_weak_count **)(a1 + 104);
  if (v6)
  {
    v8 = (unint64_t *)&v6->__shared_owners_;
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  os_unfair_lock_unlock(v2);
  v10 = operator new();
  v11 = v10;
  v28 = v7;
  v29 = v6;
  if (v6)
  {
    v12 = (unint64_t *)&v6->__shared_owners_;
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  v14 = *(_QWORD *)(a1 + 48);
  v15 = *(std::__shared_weak_count **)(a1 + 56);
  v27[0] = v14;
  v27[1] = v15;
  if (v15)
  {
    v16 = (unint64_t *)&v15->__shared_owners_;
    do
      v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::enumerator_s::enumerator_s(v10, &v28, v27);
    do
      v18 = __ldaxr(v16);
    while (__stlxr(v18 - 1, v16));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  else
  {
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::enumerator_s::enumerator_s(v10, &v28, v27);
  }
  v19 = v29;
  if (!v29)
    goto LABEL_22;
  v20 = (unint64_t *)&v29->__shared_owners_;
  do
    v21 = __ldaxr(v20);
  while (__stlxr(v21 - 1, v20));
  if (!v21)
  {
    ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
    std::__shared_weak_count::__release_weak(v19);
    if (!v6)
      goto LABEL_28;
  }
  else
  {
LABEL_22:
    if (!v6)
      goto LABEL_28;
  }
  v22 = (unint64_t *)&v6->__shared_owners_;
  do
    v23 = __ldaxr(v22);
  while (__stlxr(v23 - 1, v22));
  if (!v23)
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
LABEL_28:
  if (v3)
  {
    v24 = (unint64_t *)&v3->__shared_owners_;
    do
      v25 = __ldaxr(v24);
    while (__stlxr(v25 - 1, v24));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  return v11;
}

uint64_t IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::beginMerge(uint64_t a1)
{
  uint64_t result;
  char *v3;
  char *v4;
  const char *v5;

  if (*(_DWORD *)(a1 + 156) != -1)
  {
    v3 = __si_assert_copy_extra_268();
    v4 = v3;
    v5 = "";
    if (v3)
      v5 = v3;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2674, "mergeBeginVectorOffset == VECTOR_NOT_FOUND", v5);
    free(v4);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  result = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nVectors(a1);
  *(_DWORD *)(a1 + 156) = result;
  return result;
}

uint64_t IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::endMerge(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  std::ios_base *v8;
  uint64_t v9;
  uint64_t v10;
  os_unfair_lock_s *v11;
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  std::__shared_weak_count *v15;
  uint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  int v19;
  NSObject *v20;
  os_log_type_t v21;
  void **v22;
  unint64_t *v23;
  unint64_t v24;
  unint64_t *v25;
  unint64_t v26;
  uint64_t v27;
  char *v29;
  char *v30;
  const char *v31;
  void *__p;
  char v33;
  _QWORD v34[2];
  uint64_t v35;
  _OWORD v36[4];
  void *v37[2];
  __int128 v38;
  uint64_t v39;
  uint64_t v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  uint8_t buf[4];
  void **v51;
  uint64_t v52;

  v52 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 156) == -1)
  {
    v29 = __si_assert_copy_extra_268();
    v30 = v29;
    v31 = "";
    if (v29)
      v31 = v29;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2679, "mergeBeginVectorOffset < VECTOR_NOT_FOUND", v31);
    free(v30);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  *(_DWORD *)(a1 + 156) = -1;
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::persistPartitions<vi_onefixedsize_disk_allocator>(a1);
  v49 = 0u;
  v39 = 0;
  v48 = 0u;
  v47 = 0u;
  v46 = 0u;
  v45 = 0u;
  v44 = 0u;
  v43 = 0u;
  v42 = 0u;
  v41 = 0u;
  v38 = 0u;
  *(_OWORD *)v37 = 0u;
  v2 = MEMORY[0x1E0DE4FD0];
  memset(v36, 0, sizeof(v36));
  v3 = MEMORY[0x1E0DE4FD0] + 104;
  v40 = MEMORY[0x1E0DE4FD0] + 104;
  v4 = (_QWORD *)MEMORY[0x1E0DE4F50];
  v5 = MEMORY[0x1E0DE4FD0] + 64;
  v6 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 16);
  v7 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 24);
  v35 = MEMORY[0x1E0DE4FD0] + 64;
  v34[0] = v6;
  *(_QWORD *)((char *)v34 + *(_QWORD *)(v6 - 24)) = v7;
  v34[1] = 0;
  v8 = (std::ios_base *)((char *)v34 + *(_QWORD *)(v34[0] - 24));
  std::ios_base::init(v8, v36);
  v8[1].__vftable = 0;
  v8[1].__fmtflags_ = -1;
  v9 = v4[5];
  v35 = v4[4];
  *(uint64_t *)((char *)&v35 + *(_QWORD *)(v35 - 24)) = v9;
  v34[0] = v4[1];
  *(_QWORD *)((char *)v34 + *(_QWORD *)(v34[0] - 24)) = v4[6];
  v40 = v3;
  v34[0] = v2 + 24;
  v35 = v5;
  std::streambuf::basic_streambuf();
  v10 = MEMORY[0x1E0DE4FB8];
  *(_QWORD *)&v36[0] = MEMORY[0x1E0DE4FB8] + 16;
  *(_OWORD *)v37 = 0u;
  v38 = 0u;
  LODWORD(v39) = 24;
  v11 = (os_unfair_lock_s *)(a1 + 112);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 112));
  v12 = *(std::__shared_weak_count **)(a1 + 88);
  if (v12)
  {
    p_shared_owners = (unint64_t *)&v12->__shared_owners_;
    do
      v14 = __ldxr(p_shared_owners);
    while (__stxr(v14 + 1, p_shared_owners));
  }
  v16 = *(_QWORD *)(a1 + 96);
  v15 = *(std::__shared_weak_count **)(a1 + 104);
  if (v15)
  {
    v17 = (unint64_t *)&v15->__shared_owners_;
    do
      v18 = __ldxr(v17);
    while (__stxr(v18 + 1, v17));
  }
  os_unfair_lock_unlock(v11);
  (*(void (**)(uint64_t, uint64_t *, _QWORD))(*(_QWORD *)v16 + 104))(v16, &v35, 0);
  v19 = *__error();
  v20 = _SILogForLogForCategory(16);
  v21 = 2 * (dword_1EF19FCCC < 4);
  if (os_log_type_enabled(v20, v21))
  {
    std::stringbuf::str();
    v22 = v33 >= 0 ? &__p : (void **)__p;
    *(_DWORD *)buf = 136315138;
    v51 = v22;
    _os_log_impl(&dword_1B8270000, v20, v21, "%s", buf, 0xCu);
    if (v33 < 0)
      operator delete(__p);
  }
  *__error() = v19;
  if (v15)
  {
    v23 = (unint64_t *)&v15->__shared_owners_;
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  if (v12)
  {
    v25 = (unint64_t *)&v12->__shared_owners_;
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  v34[0] = *v4;
  v27 = v4[9];
  *(_QWORD *)((char *)v34 + *(_QWORD *)(v34[0] - 24)) = v4[8];
  v35 = v27;
  *(_QWORD *)&v36[0] = v10 + 16;
  if (SBYTE7(v38) < 0)
    operator delete(v37[0]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1BCCB0650](&v40);
}

uint64_t IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::enumerator(uint64_t a1)
{
  os_unfair_lock_s *v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  _QWORD v27[2];
  uint64_t v28;
  std::__shared_weak_count *v29;

  v2 = (os_unfair_lock_s *)(a1 + 96);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 96));
  v3 = *(std::__shared_weak_count **)(a1 + 72);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  v7 = *(_QWORD *)(a1 + 80);
  v6 = *(std::__shared_weak_count **)(a1 + 88);
  if (v6)
  {
    v8 = (unint64_t *)&v6->__shared_owners_;
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  os_unfair_lock_unlock(v2);
  v10 = operator new();
  v11 = v10;
  v28 = v7;
  v29 = v6;
  if (v6)
  {
    v12 = (unint64_t *)&v6->__shared_owners_;
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  v14 = *(_QWORD *)(a1 + 32);
  v15 = *(std::__shared_weak_count **)(a1 + 40);
  v27[0] = v14;
  v27[1] = v15;
  if (v15)
  {
    v16 = (unint64_t *)&v15->__shared_owners_;
    do
      v17 = __ldxr(v16);
    while (__stxr(v17 + 1, v16));
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::enumerator_s::enumerator_s(v10, &v28, v27);
    do
      v18 = __ldaxr(v16);
    while (__stlxr(v18 - 1, v16));
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  else
  {
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::enumerator_s::enumerator_s(v10, &v28, v27);
  }
  v19 = v29;
  if (!v29)
    goto LABEL_22;
  v20 = (unint64_t *)&v29->__shared_owners_;
  do
    v21 = __ldaxr(v20);
  while (__stlxr(v21 - 1, v20));
  if (!v21)
  {
    ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
    std::__shared_weak_count::__release_weak(v19);
    if (!v6)
      goto LABEL_28;
  }
  else
  {
LABEL_22:
    if (!v6)
      goto LABEL_28;
  }
  v22 = (unint64_t *)&v6->__shared_owners_;
  do
    v23 = __ldaxr(v22);
  while (__stlxr(v23 - 1, v22));
  if (!v23)
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
LABEL_28:
  if (v3)
  {
    v24 = (unint64_t *)&v3->__shared_owners_;
    do
      v25 = __ldaxr(v24);
    while (__stlxr(v25 - 1, v24));
    if (!v25)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  return v11;
}

void IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::enumerator_s::next(uint64_t a1, uint64_t a2)
{
  uint64_t i;
  uint64_t v5;
  unsigned int *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t Ptr;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  if (*(_QWORD *)(a2 + 72))
  {
    for (i = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + ((*(_QWORD *)(a2 + 64) >> 5) & 0x7FFFFFFFFFFFFF8))
                        + 16 * *(_QWORD *)(a2 + 64));
          ;
          i = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + ((v11 >> 5) & 0x7FFFFFFFFFFFFF8))
                        + 16 * v11))
    {
      *(_DWORD *)a1 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)i + 16))(i);
      if (!*(_QWORD *)(a2 + 72))
        break;
      v5 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + ((*(_QWORD *)(a2 + 64) >> 5) & 0x7FFFFFFFFFFFFF8))
                     + 16 * *(_QWORD *)(a2 + 64));
      v6 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 24))(v5);
      if (v6)
      {
        *(_DWORD *)(a1 + 4) = v6[1];
        Ptr = vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(*(_QWORD *)(a2 + 16) + 16), *v6, 3092);
        *(_DWORD *)(a1 + 8) = *(_DWORD *)(Ptr + 3088);
        *(_QWORD *)(a1 + 16) = Ptr;
        *(_QWORD *)(a1 + 24) = Ptr + 3072;
        return;
      }
      v7 = *(std::__shared_weak_count **)(*(_QWORD *)(*(_QWORD *)(a2 + 40)
                                                    + ((*(_QWORD *)(a2 + 64) >> 5) & 0x7FFFFFFFFFFFFF8))
                                        + 16 * *(_QWORD *)(a2 + 64)
                                        + 8);
      if (v7)
      {
        p_shared_owners = (unint64_t *)&v7->__shared_owners_;
        do
          v9 = __ldaxr(p_shared_owners);
        while (__stlxr(v9 - 1, p_shared_owners));
        if (!v9)
        {
          ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
          std::__shared_weak_count::__release_weak(v7);
        }
      }
      v10 = *(_QWORD *)(a2 + 72) - 1;
      v11 = *(_QWORD *)(a2 + 64) + 1;
      *(_QWORD *)(a2 + 64) = v11;
      *(_QWORD *)(a2 + 72) = v10;
      if (v11 >= 0x200)
      {
        operator delete(**(void ***)(a2 + 40));
        *(_QWORD *)(a2 + 40) += 8;
        v10 = *(_QWORD *)(a2 + 72);
        v11 = *(_QWORD *)(a2 + 64) - 256;
        *(_QWORD *)(a2 + 64) = v11;
      }
      if (!v10)
        return;
    }
  }
}

unint64_t vi_onefixedsize_memory_allocator::getPtr(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3;
  char *v5;
  char *v6;
  const char *v7;
  char *v8;
  const char *v9;
  char *v10;
  const char *v11;

  if (a1[4] != a3)
  {
    v5 = __si_assert_copy_extra_268();
    v6 = v5;
    v7 = "";
    if (v5)
      v7 = v5;
    __message_assert("%s:%u: failed assertion '%s' %s ", "VectorIndexSupport.hh", 1354, "size == allocator->baseSize", v7);
LABEL_14:
    free(v6);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v3 = a3 * a2;
  if (a1[2] < (unint64_t)(a3 * a2))
  {
    v8 = __si_assert_copy_extra_268();
    v6 = v8;
    v9 = "";
    if (v8)
      v9 = v8;
    __message_assert("%s:%u: failed assertion '%s' %s ", "VectorIndexSupport.hh", 1356, "allocator->size>=inOffset", v9);
    goto LABEL_14;
  }
  if (a1[3] < v3)
  {
    v10 = __si_assert_copy_extra_268();
    v6 = v10;
    v11 = "";
    if (v10)
      v11 = v10;
    __message_assert("%s:%u: failed assertion '%s' %s ", "VectorIndexSupport.hh", 1357, "allocator->freeRegion >= inOffset", v11);
    goto LABEL_14;
  }
  return a1[1] + v3;
}

uint64_t IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::enumerator_s::enumerator_s(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  int v12;
  NSObject *v13;
  int v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  __int128 v25;
  int v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)a1 = *a2;
  v6 = a2[1];
  *(_QWORD *)(a1 + 8) = v6;
  if (v6)
  {
    v7 = (unint64_t *)(v6 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  *(_QWORD *)(a1 + 16) = *a3;
  v9 = a3[1];
  *(_QWORD *)(a1 + 24) = v9;
  if (v9)
  {
    v10 = (unint64_t *)(v9 + 8);
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  v12 = *__error();
  v13 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    v14 = *(_DWORD *)(*a3 + 24);
    v15 = *(_DWORD *)(*a2 + 68);
    v16 = *(_DWORD *)(*a2 + 76);
    LODWORD(v25) = 67109632;
    DWORD1(v25) = v14;
    WORD4(v25) = 1024;
    *(_DWORD *)((char *)&v25 + 10) = v15;
    HIWORD(v25) = 1024;
    v26 = v16;
    _os_log_impl(&dword_1B8270000, v13, OS_LOG_TYPE_DEFAULT, "enumerator %u vectors in %u partitions v%d.", (uint8_t *)&v25, 0x14u);
  }
  *__error() = v12;
  v17 = *a2;
  if (*(_DWORD *)(*a2 + 68))
  {
    v18 = 0;
    do
    {
      (*(void (**)(__int128 *__return_ptr, uint64_t, uint64_t))(*(_QWORD *)v17 + 96))(&v25, v17, v18);
      v19 = *(_QWORD *)(a1 + 48);
      v20 = *(_QWORD *)(a1 + 40);
      if (v19 == v20)
        v21 = 0;
      else
        v21 = 32 * (v19 - v20) - 1;
      v22 = *(_QWORD *)(a1 + 72);
      v23 = v22 + *(_QWORD *)(a1 + 64);
      if (v21 == v23)
      {
        std::deque<std::shared_ptr<AnyPartitionStore::Enumerator>>::__add_back_capacity(a1 + 32);
        v20 = *(_QWORD *)(a1 + 40);
        v22 = *(_QWORD *)(a1 + 72);
        v23 = v22 + *(_QWORD *)(a1 + 64);
      }
      *(_OWORD *)(*(_QWORD *)(v20 + ((v23 >> 5) & 0x7FFFFFFFFFFFFF8)) + 16 * v23) = v25;
      *(_QWORD *)(a1 + 72) = v22 + 1;
      v17 = *a2;
      v18 = (v18 + 1);
    }
    while (v18 < *(_DWORD *)(*a2 + 68));
  }
  return a1;
}

unint64_t IVFVectorIndexTemplate<float,768>::VectorStore<vi_onefixedsize_memory_allocator,vi_memory_postings>::Iterator::operator->(uint64_t a1, unsigned int a2)
{
  char *v3;
  char *v4;
  const char *v5;

  if (*(_DWORD *)(a1 + 24) <= a2)
  {
    v3 = __si_assert_copy_extra_268();
    v4 = v3;
    v5 = "";
    if (v3)
      v5 = v3;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1802, "offset < store->endOffset()", v5);
    free(v4);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  return vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(a1 + 16), a2, 3092);
}

BOOL IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::exists(uint64_t a1, uint64_t a2)
{
  int Vector;
  int v6;
  NSObject *v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  std::__shared_weak_count *v12;
  uint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  unsigned int v16;
  uint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  _QWORD v32[8];
  std::__shared_weak_count *v33;
  uint64_t v34;
  std::__shared_weak_count *v35;
  unsigned int v36;
  _QWORD v37[7];
  unsigned int v38;
  float v39;
  float v40;
  unsigned int v41;
  _BYTE buf[24];
  _DWORD v43[4];
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  v40 = 3.4028e38;
  v41 = -1;
  Vector = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::findVector(a1, a2, (int *)&v41, &v40, 0);
  if (Vector == -1)
  {
    v6 = *__error();
    v7 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = "exists";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 2632;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v41;
      LOWORD(v43[0]) = 2048;
      *(double *)((char *)v43 + 2) = v40;
      _os_log_error_impl(&dword_1B8270000, v7, OS_LOG_TYPE_ERROR, "%s:%d: Vector not found partID=%u distsq=%e", buf, 0x22u);
    }
    *__error() = v6;
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 112));
    v9 = *(_QWORD *)(a1 + 80);
    v8 = *(std::__shared_weak_count **)(a1 + 88);
    if (v8)
    {
      p_shared_owners = (unint64_t *)&v8->__shared_owners_;
      do
        v11 = __ldxr(p_shared_owners);
      while (__stxr(v11 + 1, p_shared_owners));
    }
    v13 = *(_QWORD *)(a1 + 96);
    v12 = *(std::__shared_weak_count **)(a1 + 104);
    if (v12)
    {
      v14 = (unint64_t *)&v12->__shared_owners_;
      do
        v15 = __ldxr(v14);
      while (__stxr(v15 + 1, v14));
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 112));
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    v43[0] = -1;
    *(_QWORD *)&buf[16] = 0x2000000000;
    v16 = v41;
    v17 = MEMORY[0x1E0C809B0];
    v37[0] = MEMORY[0x1E0C809B0];
    v37[1] = 0x40000000;
    v37[2] = ___ZN22IVFVectorIndexTemplateIfLi768EE20IVFVectorIndexRoot_sI30vi_onefixedsize_disk_allocator16vi_disk_postingsE6existsERK10CIVector_sIfLi768EE_block_invoke;
    v37[3] = &unk_1E6E34910;
    v37[5] = a1;
    v37[6] = a2;
    v38 = v41;
    v39 = v40;
    v37[4] = buf;
    (*(void (**)(uint64_t, _QWORD, _QWORD *))(*(_QWORD *)v13 + 80))(v13, v41, v37);
    if (*(_DWORD *)(*(_QWORD *)&buf[8] + 24) == -1)
    {
      v32[0] = v17;
      v32[1] = 1174405120;
      v32[2] = ___ZN22IVFVectorIndexTemplateIfLi768EE20IVFVectorIndexRoot_sI30vi_onefixedsize_disk_allocator16vi_disk_postingsE6existsERK10CIVector_sIfLi768EE_block_invoke_1218;
      v32[3] = &unk_1E6E34938;
      v32[5] = a1;
      v32[6] = a2;
      v32[7] = v9;
      v33 = v8;
      if (v8)
      {
        v22 = (unint64_t *)&v8->__shared_owners_;
        do
          v23 = __ldxr(v22);
        while (__stxr(v23 + 1, v22));
      }
      v34 = v13;
      v35 = v12;
      if (v12)
      {
        v24 = (unint64_t *)&v12->__shared_owners_;
        do
          v25 = __ldxr(v24);
        while (__stxr(v25 + 1, v24));
      }
      v36 = v16;
      v32[4] = buf;
      (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v13 + 64))(v13, v32);
      v26 = v35;
      if (v35)
      {
        v27 = (unint64_t *)&v35->__shared_owners_;
        do
          v28 = __ldaxr(v27);
        while (__stlxr(v28 - 1, v27));
        if (!v28)
        {
          ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
          std::__shared_weak_count::__release_weak(v26);
        }
      }
      v29 = v33;
      if (v33)
      {
        v30 = (unint64_t *)&v33->__shared_owners_;
        do
          v31 = __ldaxr(v30);
        while (__stlxr(v31 - 1, v30));
        if (!v31)
        {
          ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
          std::__shared_weak_count::__release_weak(v29);
        }
      }
    }
    _Block_object_dispose(buf, 8);
    if (v12)
    {
      v18 = (unint64_t *)&v12->__shared_owners_;
      do
        v19 = __ldaxr(v18);
      while (__stlxr(v19 - 1, v18));
      if (!v19)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
    if (v8)
    {
      v20 = (unint64_t *)&v8->__shared_owners_;
      do
        v21 = __ldaxr(v20);
      while (__stlxr(v21 - 1, v20));
      if (!v21)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }
  }
  return Vector != -1;
}

void ___ZN22IVFVectorIndexTemplateIfLi768EE20IVFVectorIndexRoot_sI30vi_onefixedsize_disk_allocator16vi_disk_postingsE6existsERK10CIVector_sIfLi768EE_block_invoke_1218(uint64_t a1, int a2, float *a3, _BYTE *a4)
{
  const void *v8;
  uint64_t v9;
  const void *v10;
  int v11;
  NSObject *v12;
  const float *v13;
  const float *v14;
  float v15;
  int v16;
  NSObject *v17;
  int v18;
  NSObject *v19;
  int v20;
  NSObject *v21;
  int v22;
  NSObject *v23;
  int v24;
  NSObject *v25;
  int v26;
  NSObject *v27;
  uint64_t v28;
  unint64_t v29;
  int v30;
  NSObject *v31;
  int v32;
  NSObject *v33;
  int v34;
  NSObject *v35;
  int v36;
  NSObject *v37;
  int v38;
  NSObject *v39;
  double v40;
  int v41;
  int v42;
  float v43;
  int v44;
  float v45;
  _BOOL4 v46;
  int v47;
  int v48;
  _BOOL4 v49;
  int v50;
  int v51;
  _BOOL4 v52;
  int v53;
  int v54;
  _BOOL4 v55;
  int v56;
  int v57;
  float v58;
  float v59;
  double v60;
  float v61;
  _BOOL4 v62;
  _BOOL4 v63;
  int v64;
  float v65;
  int v66;
  float v67;
  _BOOL4 v68;
  int v69;
  int v70;
  _BOOL4 v71;
  int v72;
  int v73;
  _BOOL4 v74;
  int v75;
  int v76;
  _BOOL4 v77;
  int v78;
  int v79;
  float v80;
  float v81;
  float v82;
  _BOOL4 v83;
  _BOOL4 v84;
  _BOOL4 v85;
  float v86;
  float v87;
  float v88;
  float v89;
  void *__p;
  void *v91;
  uint64_t v92;
  void *v93;
  void *v94;
  uint64_t v95;
  float __C;
  const char *v97;
  __int16 v98;
  int v99;
  __int16 v100;
  int v101;
  __int16 v102;
  _BYTE v103[14];
  __int16 v104;
  double v105;
  __int16 v106;
  uint64_t v107;
  __int16 v108;
  _BOOL4 v109;
  __int16 v110;
  _BOOL4 v111;
  __int16 v112;
  _BOOL4 v113;
  __int16 v114;
  _BOOL4 v115;
  uint64_t v116;

  v116 = *MEMORY[0x1E0C80C00];
  v9 = *(_QWORD *)(a1 + 40);
  v8 = *(const void **)(a1 + 48);
  v10 = (const void *)_windowsResolvePtr(*(_QWORD *)(*(_QWORD *)(v9 + 48) + 32) + 40, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v9 + 48) + 32) + 24)+ *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v9 + 48) + 32) + 16) * *(unsigned int *)a3, 0xC10uLL);
  if (!memcmp(v8, v10, 0xC00uLL))
  {
    v11 = *__error();
    v12 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      v40 = a3[1];
      __C = 4.8153e-34;
      v97 = "exists_block_invoke";
      v98 = 1024;
      v99 = 2647;
      v100 = 1024;
      v101 = a2;
      v102 = 2048;
      *(double *)v103 = v40;
      _os_log_error_impl(&dword_1B8270000, v12, OS_LOG_TYPE_ERROR, "%s:%d: Vector not found actually in partID=%u distsq=%e", (uint8_t *)&__C, 0x22u);
    }
    *__error() = v11;
    v13 = *(const float **)(a1 + 48);
    v14 = (const float *)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 56) + 64))(*(_QWORD *)(a1 + 56), *(unsigned int *)(a1 + 88));
    __C = 3.4028e38;
    vDSP_distancesq(v13, 1, v14, 1, &__C, 0x300uLL);
    v15 = __C;
    v16 = *__error();
    v17 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      v41 = *(_DWORD *)(a1 + 88);
      __C = 4.8153e-34;
      v97 = "exists_block_invoke";
      v98 = 1024;
      v99 = 2649;
      v100 = 1024;
      v101 = v41;
      v102 = 2048;
      *(double *)v103 = v15;
      _os_log_error_impl(&dword_1B8270000, v17, OS_LOG_TYPE_ERROR, "%s:%d: Vec distance to centroid %u distsq=%e", (uint8_t *)&__C, 0x22u);
    }
    *__error() = v16;
    v93 = 0;
    v94 = 0;
    v95 = 0;
    (*(void (**)(void **__return_ptr, _QWORD, _QWORD, uint64_t))(**(_QWORD **)(a1 + 56) + 72))(&v93, *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 48), 2);
    v18 = *__error();
    v19 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      v42 = *(_DWORD *)v93;
      v43 = *((float *)v93 + 1);
      v44 = *((_DWORD *)v93 + 2);
      v45 = *((float *)v93 + 3);
      v46 = v43 == v45 || vabds_f32(v43, v45) <= fmaxf(fminf(fabsf(v45), fabsf(v43)) * 0.000015259, 0.000015259);
      __C = 4.8156e-34;
      v97 = "exists_block_invoke";
      v98 = 1024;
      v99 = 2651;
      v100 = 1024;
      v101 = v42;
      v102 = 2048;
      *(double *)v103 = v43;
      *(_WORD *)&v103[8] = 1024;
      *(_DWORD *)&v103[10] = v44;
      v104 = 2048;
      v105 = v45;
      v106 = 1024;
      LODWORD(v107) = v46;
      _os_log_error_impl(&dword_1B8270000, v19, OS_LOG_TYPE_ERROR, "%s:%d: topKPartition(vec, 2) <%u, %e>, <%u, %e>, %d", (uint8_t *)&__C, 0x38u);
    }
    *__error() = v18;
    v20 = *__error();
    v21 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      v47 = *(_DWORD *)v93;
      v48 = *((_DWORD *)v93 + 2);
      v49 = *((float *)v93 + 1) == *((float *)v93 + 3);
      __C = 4.8154e-34;
      v97 = "exists_block_invoke";
      v98 = 1024;
      v99 = 2652;
      v100 = 1024;
      v101 = v47;
      v102 = 1024;
      *(_DWORD *)v103 = v48;
      *(_WORD *)&v103[4] = 1024;
      *(_DWORD *)&v103[6] = v49;
      _os_log_error_impl(&dword_1B8270000, v21, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) == distsq(%u) is %d", (uint8_t *)&__C, 0x24u);
    }
    *__error() = v20;
    v22 = *__error();
    v23 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      v50 = *(_DWORD *)v93;
      v51 = *((_DWORD *)v93 + 2);
      v52 = *((float *)v93 + 1) < *((float *)v93 + 3);
      __C = 4.8154e-34;
      v97 = "exists_block_invoke";
      v98 = 1024;
      v99 = 2653;
      v100 = 1024;
      v101 = v50;
      v102 = 1024;
      *(_DWORD *)v103 = v51;
      *(_WORD *)&v103[4] = 1024;
      *(_DWORD *)&v103[6] = v52;
      _os_log_error_impl(&dword_1B8270000, v23, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) < distsq(%u) is %d", (uint8_t *)&__C, 0x24u);
    }
    *__error() = v22;
    v24 = *__error();
    v25 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      v53 = *(_DWORD *)v93;
      v54 = *((_DWORD *)v93 + 2);
      v55 = *((float *)v93 + 1) > *((float *)v93 + 3);
      __C = 4.8154e-34;
      v97 = "exists_block_invoke";
      v98 = 1024;
      v99 = 2654;
      v100 = 1024;
      v101 = v53;
      v102 = 1024;
      *(_DWORD *)v103 = v54;
      *(_WORD *)&v103[4] = 1024;
      *(_DWORD *)&v103[6] = v55;
      _os_log_error_impl(&dword_1B8270000, v25, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) > distsq(%u) is %d", (uint8_t *)&__C, 0x24u);
    }
    *__error() = v24;
    v26 = *__error();
    v27 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      v56 = *(_DWORD *)v93;
      v57 = *((_DWORD *)v93 + 2);
      v58 = *((float *)v93 + 1);
      v59 = *((float *)v93 + 3);
      v60 = (float)(v58 - v59);
      v61 = vabds_f32(v58, v59);
      if (v58 == v59)
      {
        v62 = 1;
        v63 = 1;
      }
      else
      {
        v86 = fabsf(v58);
        v87 = fabsf(v59);
        v62 = v61 <= fmaxf(fminf(v87, v86) * 0.000015259, 0.000015259);
        v63 = v61 <= (float)(fmaxf(v86, v87) * 0.000015259);
      }
      __C = 4.8161e-34;
      v97 = "exists_block_invoke";
      v98 = 1024;
      v99 = 2655;
      v100 = 1024;
      v101 = v56;
      v102 = 1024;
      *(_DWORD *)v103 = v57;
      *(_WORD *)&v103[4] = 2048;
      *(double *)&v103[6] = v60;
      v104 = 2048;
      v105 = 1.17549435e-38;
      v106 = 2048;
      v107 = 0x3E80000000000000;
      v108 = 1024;
      v109 = v61 < 1.1755e-38;
      v110 = 1024;
      v111 = v61 < 0.00000011921;
      v112 = 1024;
      v113 = v62;
      v114 = 1024;
      v115 = v63;
      _os_log_error_impl(&dword_1B8270000, v27, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) - distsq(%u) = %e, FLT_MIN=%e, EPSILON=%e, %d, %d, %d, %d", (uint8_t *)&__C, 0x54u);
    }
    *__error() = v26;
    v91 = 0;
    v92 = 0;
    __p = 0;
    v28 = *(_QWORD *)(a1 + 56);
    v29 = _windowsResolvePtr(*(_QWORD *)(*(_QWORD *)(v9 + 48) + 32) + 40, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v9 + 48) + 32) + 24)+ *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v9 + 48) + 32) + 16) * *(unsigned int *)a3, 0xC10uLL);
    (*(void (**)(void **__return_ptr, uint64_t, unint64_t, uint64_t))(*(_QWORD *)v28 + 72))(&__p, v28, v29, 2);
    v30 = *__error();
    v31 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
    {
      v64 = *(_DWORD *)__p;
      v65 = *((float *)__p + 1);
      v66 = *((_DWORD *)__p + 2);
      v67 = *((float *)__p + 3);
      v68 = v65 == v67 || vabds_f32(v65, v67) <= fmaxf(fminf(fabsf(v67), fabsf(v65)) * 0.000015259, 0.000015259);
      __C = 4.8156e-34;
      v97 = "exists_block_invoke";
      v98 = 1024;
      v99 = 2658;
      v100 = 1024;
      v101 = v64;
      v102 = 2048;
      *(double *)v103 = v65;
      *(_WORD *)&v103[8] = 1024;
      *(_DWORD *)&v103[10] = v66;
      v104 = 2048;
      v105 = v67;
      v106 = 1024;
      LODWORD(v107) = v68;
      _os_log_error_impl(&dword_1B8270000, v31, OS_LOG_TYPE_ERROR, "%s:%d: topKPartition(entry->vec, 2) <%u, %e>, <%u, %e>, %d", (uint8_t *)&__C, 0x38u);
    }
    *__error() = v30;
    v32 = *__error();
    v33 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
    {
      v69 = *(_DWORD *)__p;
      v70 = *((_DWORD *)__p + 2);
      v71 = *((float *)__p + 1) == *((float *)__p + 3);
      __C = 4.8154e-34;
      v97 = "exists_block_invoke";
      v98 = 1024;
      v99 = 2659;
      v100 = 1024;
      v101 = v69;
      v102 = 1024;
      *(_DWORD *)v103 = v70;
      *(_WORD *)&v103[4] = 1024;
      *(_DWORD *)&v103[6] = v71;
      _os_log_error_impl(&dword_1B8270000, v33, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) == distsq(%u) is %d", (uint8_t *)&__C, 0x24u);
    }
    *__error() = v32;
    v34 = *__error();
    v35 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
    {
      v72 = *(_DWORD *)__p;
      v73 = *((_DWORD *)__p + 2);
      v74 = *((float *)__p + 1) < *((float *)__p + 3);
      __C = 4.8154e-34;
      v97 = "exists_block_invoke";
      v98 = 1024;
      v99 = 2660;
      v100 = 1024;
      v101 = v72;
      v102 = 1024;
      *(_DWORD *)v103 = v73;
      *(_WORD *)&v103[4] = 1024;
      *(_DWORD *)&v103[6] = v74;
      _os_log_error_impl(&dword_1B8270000, v35, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) < distsq(%u) is %d", (uint8_t *)&__C, 0x24u);
    }
    *__error() = v34;
    v36 = *__error();
    v37 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
    {
      v75 = *(_DWORD *)__p;
      v76 = *((_DWORD *)__p + 2);
      v77 = *((float *)__p + 1) > *((float *)__p + 3);
      __C = 4.8154e-34;
      v97 = "exists_block_invoke";
      v98 = 1024;
      v99 = 2661;
      v100 = 1024;
      v101 = v75;
      v102 = 1024;
      *(_DWORD *)v103 = v76;
      *(_WORD *)&v103[4] = 1024;
      *(_DWORD *)&v103[6] = v77;
      _os_log_error_impl(&dword_1B8270000, v37, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) > distsq(%u) is %d", (uint8_t *)&__C, 0x24u);
    }
    *__error() = v36;
    v38 = *__error();
    v39 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
    {
      v78 = *(_DWORD *)__p;
      v79 = *((_DWORD *)__p + 2);
      v80 = *((float *)__p + 1);
      v81 = *((float *)__p + 3);
      v82 = vabds_f32(v80, v81);
      v83 = (float)(v80 - v81) < 1.1755e-38;
      if (v80 == v81)
      {
        v84 = 1;
        v85 = 1;
      }
      else
      {
        v88 = fabsf(v80);
        v89 = fabsf(v81);
        v84 = v82 <= fmaxf(fminf(v89, v88) * 0.000015259, 0.000015259);
        v85 = v82 <= (float)(fmaxf(v88, v89) * 0.000015259);
      }
      __C = 4.8161e-34;
      v97 = "exists_block_invoke";
      v98 = 1024;
      v99 = 2662;
      v100 = 1024;
      v101 = v78;
      v102 = 1024;
      *(_DWORD *)v103 = v79;
      *(_WORD *)&v103[4] = 2048;
      *(double *)&v103[6] = v82;
      v104 = 2048;
      v105 = 1.17549435e-38;
      v106 = 2048;
      v107 = 0x3E80000000000000;
      v108 = 1024;
      v109 = v83;
      v110 = 1024;
      v111 = v82 < 0.00000011921;
      v112 = 1024;
      v113 = v84;
      v114 = 1024;
      v115 = v85;
      _os_log_error_impl(&dword_1B8270000, v39, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) - distsq(%u) = %e, FLT_MIN=%e, EPSILON=%e, %d, %d, %d, %d", (uint8_t *)&__C, 0x54u);
    }
    *__error() = v38;
    *(float *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *a3;
    *a4 = 1;
    if (__p)
    {
      v91 = __p;
      operator delete(__p);
    }
    if (v93)
    {
      v94 = v93;
      operator delete(v93);
    }
  }
}

_QWORD *__copy_helper_block_8_56c60_ZTSN22IVFVectorIndexTemplateIfLi768EE19QuantizerPartitionsE(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  v2 = a2[8];
  result[7] = a2[7];
  result[8] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  v5 = a2[10];
  result[9] = a2[9];
  result[10] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  return result;
}

void __destroy_helper_block_8_56c60_ZTSN22IVFVectorIndexTemplateIfLi768EE19QuantizerPartitionsE(uint64_t a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;

  v2 = *(std::__shared_weak_count **)(a1 + 80);
  if (!v2)
    goto LABEL_5;
  p_shared_owners = (unint64_t *)&v2->__shared_owners_;
  do
    v4 = __ldaxr(p_shared_owners);
  while (__stlxr(v4 - 1, p_shared_owners));
  if (!v4)
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    v5 = *(std::__shared_weak_count **)(a1 + 64);
    if (!v5)
      return;
  }
  else
  {
LABEL_5:
    v5 = *(std::__shared_weak_count **)(a1 + 64);
    if (!v5)
      return;
  }
  v6 = (unint64_t *)&v5->__shared_owners_;
  do
    v7 = __ldaxr(v6);
  while (__stlxr(v7 - 1, v6));
  if (!v7)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
}

void QuantizerManager<float,512>::sharedQuantizer(_QWORD *a1, uint64_t a2, int a3)
{
  unsigned __int8 v6;
  unint64_t *v7;
  unint64_t v8;
  NSObject *v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  _QWORD v16[6];
  int v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  __n128 (*v21)(uint64_t, uint64_t);
  void (*v22)(uint64_t);
  uint64_t v23;
  uint64_t v24;

  v18 = 0;
  v19 = &v18;
  v20 = 0x3802000000;
  v21 = __Block_byref_object_copy__679;
  v22 = __Block_byref_object_dispose__680;
  v23 = 0;
  v24 = 0;
  if ((v6 & 1) == 0
  {
    __cxa_atexit((void (*)(void *))std::shared_ptr<Quantizer<float,512>>::~shared_ptr[abi:nn180100], &ZeroVectorQuantizer<float,512>::sharedInstance(void)::zvq, &dword_1B8270000);
  }
  if (ZeroVectorQuantizer<float,512>::sharedInstance(void)::onceToken != -1)
    dispatch_once(&ZeroVectorQuantizer<float,512>::sharedInstance(void)::onceToken, &__block_literal_global_621);
  v23 = ZeroVectorQuantizer<float,512>::sharedInstance(void)::zvq;
  v24 = qword_1EF1AF238;
  if (qword_1EF1AF238)
  {
    v7 = (unint64_t *)(qword_1EF1AF238 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  v9 = *(NSObject **)(a2 + 16);
  v16[0] = MEMORY[0x1E0C809B0];
  v16[1] = 0x40000000;
  v16[2] = ___ZN16QuantizerManagerIfLi512EE15sharedQuantizerEi_block_invoke;
  v16[3] = &unk_1E6E32C18;
  v17 = a3;
  v16[4] = &v18;
  v16[5] = a2;
  dispatch_sync(v9, v16);
  v10 = v19[6];
  *a1 = v19[5];
  a1[1] = v10;
  if (v10)
  {
    v11 = (unint64_t *)(v10 + 8);
    do
      v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
  }
  _Block_object_dispose(&v18, 8);
  v13 = (std::__shared_weak_count *)v24;
  if (v24)
  {
    v14 = (unint64_t *)(v24 + 8);
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
}

__n128 __Block_byref_object_copy__679(uint64_t a1, uint64_t a2)
{
  __n128 result;

  result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 40) = result;
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  return result;
}

void __Block_byref_object_dispose__680(uint64_t a1)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v3;

  v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

uint64_t std::shared_ptr<Quantizer<float,512>>::~shared_ptr[abi:nn180100](uint64_t a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;

  v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  return a1;
}

void ___ZN16QuantizerManagerIfLi512EE15sharedQuantizerEi_block_invoke(uint64_t a1)
{
  int *v2;
  unint64_t v3;
  uint64_t v4;
  int8x8_t v5;
  uint8x8_t v6;
  unint64_t v7;
  uint64_t **v8;
  uint64_t *v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  int v13;
  size_t v14;
  unint64_t v15;
  std::string *p_dst;
  uint64_t v17;
  uint64_t v18;
  const void *v19;
  std::string *v20;
  std::string::size_type size;
  std::string *v22;
  std::string::size_type v23;
  std::string *v24;
  int64_t v25;
  const char *v26;
  _QWORD *v27;
  _QWORD *v28;
  uint64_t v29;
  std::__shared_weak_count *v30;
  std::__shared_weak_count *v31;
  unint64_t *p_shared_owners;
  unint64_t v33;
  uint64_t v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  unint64_t v37;
  unint64_t *p_shared_weak_owners;
  unint64_t v39;
  _QWORD *v40;
  std::__shared_weak_count *v41;
  std::__shared_weak_count *v42;
  unint64_t *v43;
  unint64_t v44;
  unint64_t *v45;
  unint64_t v46;
  uint64_t v47;
  std::__shared_weak_count *v48;
  std::__shared_weak_count *v49;
  unint64_t v50;
  uint64_t v51;
  unsigned __int8 v52;
  std::__shared_weak_count *v53;
  uint64_t v54;
  unint64_t *v55;
  unint64_t v56;
  uint64_t v57;
  unint64_t v58;
  uint64_t v59;
  uint64_t v60;
  unint64_t *v61;
  unint64_t v62;
  uint64_t v63;
  std::__shared_weak_count *v64;
  unint64_t *v65;
  unint64_t v66;
  int v67;
  size_t v68;
  unint64_t v69;
  char *v70;
  uint64_t v71;
  uint64_t v72;
  const void *v73;
  const char *v74;
  _QWORD *v75;
  _QWORD *v76;
  uint64_t v77;
  _QWORD *v78;
  std::__shared_weak_count *v79;
  unint64_t *v80;
  unint64_t v81;
  unint64_t *v82;
  unint64_t v83;
  uint64_t v84;
  std::__shared_weak_count *v85;
  unint64_t *v86;
  unint64_t v87;
  _QWORD *v88;
  std::__shared_weak_count *v89;
  uint64_t v90;
  uint64_t v91;
  std::__shared_weak_count *v92;
  unint64_t *v93;
  unint64_t v94;
  _QWORD v95[2];
  int v96;
  char v97;
  _BYTE v98[11];
  _QWORD v99[2];
  int v100;
  char v101;
  _BYTE v102[11];
  std::string v103;
  std::string __dst;
  std::string v105;
  __int128 v106;
  int64_t v107;

  v2 = (int *)(a1 + 48);
  v3 = *(int *)(a1 + 48);
  v4 = *(_QWORD *)(a1 + 40);
  if (!(_DWORD)v3)
    goto LABEL_79;
  v5 = *(int8x8_t *)(v4 + 120);
  if (!*(_QWORD *)&v5)
    goto LABEL_22;
  v6 = (uint8x8_t)vcnt_s8(v5);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    v7 = *(int *)(a1 + 48);
    if (*(_QWORD *)&v5 <= v3)
      v7 = v3 % *(_QWORD *)&v5;
  }
  else
  {
    v7 = (*(_QWORD *)&v5 - 1) & v3;
  }
  v8 = *(uint64_t ***)(*(_QWORD *)(v4 + 112) + 8 * v7);
  if (!v8 || (v9 = *v8) == 0)
  {
LABEL_22:
    v106 = 0uLL;
    v107 = 0;
    v13 = *(char *)(v4 + 71);
    if (v13 >= 0)
      v14 = *(unsigned __int8 *)(v4 + 71);
    else
      v14 = *(_QWORD *)(v4 + 56);
    v15 = v14 + 1;
    if (v14 + 1 > 0x7FFFFFFFFFFFFFF7)
      goto LABEL_147;
    if (v15 >= 0x17)
    {
      v17 = (v15 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v15 | 7) != 0x17)
        v17 = v15 | 7;
      v18 = v17 + 1;
      p_dst = (std::string *)operator new(v17 + 1);
      __dst.__r_.__value_.__l.__size_ = v14 + 1;
      __dst.__r_.__value_.__r.__words[2] = v18 | 0x8000000000000000;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    }
    else
    {
      memset(&__dst, 0, sizeof(__dst));
      p_dst = &__dst;
      *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v14 + 1;
      if (!v14)
        goto LABEL_36;
    }
    if (v13 >= 0)
      v19 = (const void *)(v4 + 48);
    else
      v19 = *(const void **)(v4 + 48);
    memmove(p_dst, v19, v14);
LABEL_36:
    *(_WORD *)((char *)&p_dst->__r_.__value_.__l.__data_ + v14) = 46;
    std::to_string(&v103, v3);
    if ((v103.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v20 = &v103;
    else
      v20 = (std::string *)v103.__r_.__value_.__r.__words[0];
    if ((v103.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      size = HIBYTE(v103.__r_.__value_.__r.__words[2]);
    else
      size = v103.__r_.__value_.__l.__size_;
    v22 = std::string::append(&__dst, (const std::string::value_type *)v20, size);
    v23 = v22->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v105.__r_.__value_.__l.__data_ = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
    v105.__r_.__value_.__r.__words[2] = v23;
    v22->__r_.__value_.__l.__size_ = 0;
    v22->__r_.__value_.__r.__words[2] = 0;
    v22->__r_.__value_.__r.__words[0] = 0;
    v24 = std::string::append(&v105, ".quantizer");
    v25 = v24->__r_.__value_.__r.__words[2];
    v106 = *(_OWORD *)&v24->__r_.__value_.__l.__data_;
    v107 = v25;
    v24->__r_.__value_.__l.__size_ = 0;
    v24->__r_.__value_.__r.__words[2] = 0;
    v24->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v105.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v105.__r_.__value_.__l.__data_);
      if ((SHIBYTE(v103.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_44:
        if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_45;
LABEL_67:
        operator delete(__dst.__r_.__value_.__l.__data_);
LABEL_45:
        if (v107 >= 0)
          v26 = (const char *)&v106;
        else
          v26 = (const char *)v106;
        v27 = fd_create_protected(*(_DWORD *)v4, v26, 0, 3u);
        if (!v27)
          goto LABEL_76;
        v28 = v27;
        v29 = operator new();
        v99[0] = v28;
        v99[1] = 0x1000000;
        v100 = 0;
        v101 = 1;
        memset(v102, 0, sizeof(v102));
        AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,512>::AllocatedVectorQuantizer(v29, (uint64_t)v99);
        v30 = (std::__shared_weak_count *)operator new();
        v31 = v30;
        v30->__shared_owners_ = 0;
        p_shared_owners = (unint64_t *)&v30->__shared_owners_;
        v30->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6E32CA8;
        v30->__shared_weak_owners_ = 0;
        v30[1].__vftable = (std::__shared_weak_count_vtbl *)v29;
        do
          v33 = __ldxr(p_shared_owners);
        while (__stxr(v33 + 1, p_shared_owners));
        v34 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
        v35 = *(std::__shared_weak_count **)(v34 + 48);
        *(_QWORD *)(v34 + 40) = v29;
        *(_QWORD *)(v34 + 48) = v30;
        if (v35)
        {
          v36 = (unint64_t *)&v35->__shared_owners_;
          do
            v37 = __ldaxr(v36);
          while (__stlxr(v37 - 1, v36));
          if (!v37)
          {
            ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
            std::__shared_weak_count::__release_weak(v35);
          }
        }
        p_shared_weak_owners = (unint64_t *)&v31->__shared_weak_owners_;
        do
          v39 = __ldxr(p_shared_weak_owners);
        while (__stxr(v39 + 1, p_shared_weak_owners));
        v40 = std::__hash_table<std::__hash_value_type<int,std::weak_ptr<Quantizer<float,768>>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::weak_ptr<Quantizer<float,768>>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::weak_ptr<Quantizer<float,768>>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::weak_ptr<Quantizer<float,768>>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(v4 + 112, *v2, v2);
        v41 = std::__shared_weak_count::lock(v31);
        v42 = v41;
        if (v41)
        {
          v43 = (unint64_t *)&v41->__shared_weak_owners_;
          do
            v44 = __ldxr(v43);
          while (__stxr(v44 + 1, v43));
          std::__shared_weak_count::__release_weak(v31);
          v45 = (unint64_t *)&v42->__shared_owners_;
          do
            v46 = __ldaxr(v45);
          while (__stlxr(v46 - 1, v45));
          if (v46)
          {
            v47 = v29;
            goto LABEL_71;
          }
          ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
          v48 = v42;
          v47 = v29;
        }
        else
        {
          v47 = 0;
          v48 = v31;
        }
        std::__shared_weak_count::__release_weak(v48);
LABEL_71:
        v49 = (std::__shared_weak_count *)v40[4];
        v40[3] = v47;
        v40[4] = v42;
        if (v49)
          std::__shared_weak_count::__release_weak(v49);
        atomic_store(1u, (unsigned __int8 *)(v29 + 57));
        do
          v50 = __ldaxr(p_shared_owners);
        while (__stlxr(v50 - 1, p_shared_owners));
        if (!v50)
        {
          ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
          std::__shared_weak_count::__release_weak(v31);
          if ((SHIBYTE(v107) & 0x80000000) == 0)
            goto LABEL_79;
          goto LABEL_77;
        }
LABEL_76:
        if ((SHIBYTE(v107) & 0x80000000) == 0)
          goto LABEL_79;
LABEL_77:
        operator delete((void *)v106);
        goto LABEL_79;
      }
    }
    else if ((SHIBYTE(v103.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      goto LABEL_44;
    }
    operator delete(v103.__r_.__value_.__l.__data_);
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_45;
    goto LABEL_67;
  }
  if (v6.u32[0] < 2uLL)
  {
    v10 = *(_QWORD *)&v5 - 1;
    while (1)
    {
      v12 = v9[1];
      if (v12 == v3)
      {
        if (*((_DWORD *)v9 + 4) == (_DWORD)v3)
          goto LABEL_136;
      }
      else if ((v12 & v10) != v7)
      {
        goto LABEL_22;
      }
      v9 = (uint64_t *)*v9;
      if (!v9)
        goto LABEL_22;
    }
  }
  while (1)
  {
    v11 = v9[1];
    if (v11 == v3)
      break;
    if (v11 >= *(_QWORD *)&v5)
      v11 %= *(_QWORD *)&v5;
    if (v11 != v7)
      goto LABEL_22;
LABEL_12:
    v9 = (uint64_t *)*v9;
    if (!v9)
      goto LABEL_22;
  }
  if (*((_DWORD *)v9 + 4) != (_DWORD)v3)
    goto LABEL_12;
LABEL_136:
  v88 = std::__hash_table<std::__hash_value_type<int,std::weak_ptr<Quantizer<float,768>>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::weak_ptr<Quantizer<float,768>>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::weak_ptr<Quantizer<float,768>>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::weak_ptr<Quantizer<float,768>>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(v4 + 112, v3, v2);
  v89 = (std::__shared_weak_count *)v88[4];
  if (v89 && (v89 = std::__shared_weak_count::lock(v89)) != 0)
    v90 = v88[3];
  else
    v90 = 0;
  v91 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v92 = *(std::__shared_weak_count **)(v91 + 48);
  *(_QWORD *)(v91 + 40) = v90;
  *(_QWORD *)(v91 + 48) = v89;
  if (v92)
  {
    v93 = (unint64_t *)&v92->__shared_owners_;
    do
      v94 = __ldaxr(v93);
    while (__stlxr(v94 - 1, v93));
    if (!v94)
    {
      ((void (*)(std::__shared_weak_count *))v92->__on_zero_shared)(v92);
      std::__shared_weak_count::__release_weak(v92);
    }
  }
LABEL_79:
  v51 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if ((v52 & 1) == 0
  {
    __cxa_atexit((void (*)(void *))std::shared_ptr<Quantizer<float,512>>::~shared_ptr[abi:nn180100], &ZeroVectorQuantizer<float,512>::sharedInstance(void)::zvq, &dword_1B8270000);
  }
  if (ZeroVectorQuantizer<float,512>::sharedInstance(void)::onceToken != -1)
    dispatch_once(&ZeroVectorQuantizer<float,512>::sharedInstance(void)::onceToken, &__block_literal_global_621);
  v54 = ZeroVectorQuantizer<float,512>::sharedInstance(void)::zvq;
  v53 = (std::__shared_weak_count *)qword_1EF1AF238;
  if (!qword_1EF1AF238)
  {
    if (*(_QWORD *)(v51 + 40) != ZeroVectorQuantizer<float,512>::sharedInstance(void)::zvq)
      return;
LABEL_93:
    v59 = *(_QWORD *)(v4 + 80);
    if (v59)
    {
      v60 = *(_QWORD *)(v4 + 88);
      if (v60)
      {
        v61 = (unint64_t *)(v60 + 8);
        do
          v62 = __ldxr(v61);
        while (__stxr(v62 + 1, v61));
      }
      v63 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
      v64 = *(std::__shared_weak_count **)(v63 + 48);
      *(_QWORD *)(v63 + 40) = v59;
      *(_QWORD *)(v63 + 48) = v60;
      if (v64)
      {
        v65 = (unint64_t *)&v64->__shared_owners_;
        do
          v66 = __ldaxr(v65);
        while (__stlxr(v66 - 1, v65));
        if (!v66)
        {
          ((void (*)(std::__shared_weak_count *))v64->__on_zero_shared)(v64);
          std::__shared_weak_count::__release_weak(v64);
        }
      }
      return;
    }
    v67 = *(char *)(v4 + 71);
    if (v67 >= 0)
      v68 = *(unsigned __int8 *)(v4 + 71);
    else
      v68 = *(_QWORD *)(v4 + 56);
    v69 = v68 + 10;
    if (v68 + 10 <= 0x7FFFFFFFFFFFFFF7)
    {
      if (v69 >= 0x17)
      {
        v71 = (v69 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v69 | 7) != 0x17)
          v71 = v69 | 7;
        v72 = v71 + 1;
        v70 = (char *)operator new(v71 + 1);
        *((_QWORD *)&v106 + 1) = v68 + 10;
        v107 = v72 | 0x8000000000000000;
        *(_QWORD *)&v106 = v70;
      }
      else
      {
        v107 = 0;
        v106 = 0uLL;
        v70 = (char *)&v106;
        HIBYTE(v107) = v68 + 10;
        if (!v68)
        {
LABEL_116:
          strcpy(&v70[v68], ".quantizer");
          if (v107 >= 0)
            v74 = (const char *)&v106;
          else
            v74 = (const char *)v106;
          v75 = fd_create_protected(*(_DWORD *)v4, v74, 0, 3u);
          if (v75)
          {
            v76 = v75;
            v77 = operator new();
            v95[0] = v76;
            v95[1] = 0x1000000;
            v96 = 0;
            v97 = 1;
            memset(v98, 0, sizeof(v98));
            AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,512>::AllocatedVectorQuantizer(v77, (uint64_t)v95);
            v78 = (_QWORD *)operator new();
            *v78 = &off_1E6E32CA8;
            v78[1] = 0;
            v78[2] = 0;
            v78[3] = v77;
            v79 = *(std::__shared_weak_count **)(v4 + 88);
            *(_QWORD *)(v4 + 80) = v77;
            *(_QWORD *)(v4 + 88) = v78;
            if (!v79)
              goto LABEL_126;
            v80 = (unint64_t *)&v79->__shared_owners_;
            do
              v81 = __ldaxr(v80);
            while (__stlxr(v81 - 1, v80));
            if (!v81)
            {
              ((void (*)(std::__shared_weak_count *))v79->__on_zero_shared)(v79);
              std::__shared_weak_count::__release_weak(v79);
            }
            v77 = *(_QWORD *)(v4 + 80);
            v78 = *(_QWORD **)(v4 + 88);
            if (v78)
            {
LABEL_126:
              v82 = v78 + 1;
              do
                v83 = __ldxr(v82);
              while (__stxr(v83 + 1, v82));
            }
            v84 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
            v85 = *(std::__shared_weak_count **)(v84 + 48);
            *(_QWORD *)(v84 + 40) = v77;
            *(_QWORD *)(v84 + 48) = v78;
            if (v85)
            {
              v86 = (unint64_t *)&v85->__shared_owners_;
              do
                v87 = __ldaxr(v86);
              while (__stlxr(v87 - 1, v86));
              if (!v87)
              {
                ((void (*)(std::__shared_weak_count *))v85->__on_zero_shared)(v85);
                std::__shared_weak_count::__release_weak(v85);
              }
            }
          }
          if (SHIBYTE(v107) < 0)
            operator delete((void *)v106);
          return;
        }
      }
      if (v67 >= 0)
        v73 = (const void *)(v4 + 48);
      else
        v73 = *(const void **)(v4 + 48);
      memmove(v70, v73, v68);
      goto LABEL_116;
    }
LABEL_147:
    abort();
  }
  v55 = (unint64_t *)(qword_1EF1AF238 + 8);
  do
    v56 = __ldxr(v55);
  while (__stxr(v56 + 1, v55));
  v57 = *(_QWORD *)(v51 + 40);
  do
    v58 = __ldaxr(v55);
  while (__stlxr(v58 - 1, v55));
  if (v58)
  {
    if (v57 == v54)
      goto LABEL_93;
  }
  else
  {
    ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
    std::__shared_weak_count::__release_weak(v53);
    if (v57 == v54)
      goto LABEL_93;
  }
}

uint64_t AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,512>::AllocatedVectorQuantizer(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  int v12;
  char v13;
  uint64_t v14;
  const void *v15;
  _DWORD *v16;
  _DWORD *v17;
  int v18;
  _QWORD *v19;
  int v20;
  NSObject *v21;
  uint64_t v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  char *v31;
  char *v32;
  const char *v33;
  char *v34;
  const char *v35;
  char *v36;
  const char *v37;
  char *v38;
  const char *v39;
  char *v40;
  const char *v41;
  char v42[1024];
  _BYTE buf[24];
  void *v44;
  _BYTE v45[24];
  int v46;
  char v47;
  char v48;
  char v49;
  char v50;
  uint64_t v51;
  uint64_t v52;

  v52 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  v4 = a1 + 8;
  *(_QWORD *)a1 = &off_1E6E32C48;
  *(_QWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(_WORD *)(a1 + 56) = *(unsigned __int8 *)(a2 + 20);
  *(_QWORD *)(a1 + 64) = fd_dup(*(_QWORD *)a2);
  bzero(v42, 0x400uLL);
  v5 = fd_name(*(_QWORD *)a2, v42, 0x400uLL);
  MEMORY[0x1BCCB03B0](v4, v5);
  if (!*(_QWORD *)(a1 + 64))
  {
    v31 = __si_assert_copy_extra_268();
    v32 = v31;
    v33 = "";
    if (v31)
      v33 = v31;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 478, "fdPtr != nullptr", v33);
    goto LABEL_32;
  }
  v6 = operator new();
  v7 = *(_QWORD *)a2;
  v8 = *(_QWORD *)(a2 + 8);
  v9 = *(_DWORD *)(a2 + 16);
  v10 = *(unsigned __int8 *)(a2 + 20);
  v11 = *(unsigned __int8 *)(a2 + 21);
  v12 = *(unsigned __int8 *)(a2 + 22);
  v13 = *(_BYTE *)(a2 + 23);
  *(_QWORD *)v6 = 0;
  *(_QWORD *)buf = MEMORY[0x1E0C809B0];
  *(_QWORD *)&buf[8] = 0x40000000;
  *(_QWORD *)&buf[16] = ___ZN30vi_onefixedsize_disk_allocatorC2EmymN19vi_ondisk_allocator11meta_info_sEP16vector_storage_s_block_invoke;
  v44 = &__block_descriptor_tmp_80;
  *(_QWORD *)v45 = v6;
  *(_QWORD *)&v45[8] = v7;
  *(_QWORD *)&v45[16] = v8;
  v46 = v9;
  v47 = v10;
  v48 = v11;
  v49 = v12;
  v50 = v13;
  v51 = *(_QWORD *)(a2 + 24);
  storage_array_Init((_DWORD *)(v6 + 8), 1040, 0x40000uLL, 2048, v7, v11 != 0, v9, v10 != 0, v12 != 0, v51, 0, (uint64_t)buf);
  if (v11)
    vi_onefixedsize_disk_allocator::storeHeader((unint64_t *)v6);
  v14 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 40) = v6;
  if (v14)
  {
    storage_array_Close(v14 + 8);
    v15 = *(const void **)(v14 + 4208);
    if (v15)
    {
      CFRelease(v15);
      *(_QWORD *)(v14 + 4208) = 0;
    }
    *(_OWORD *)(v14 + 4192) = 0u;
    MEMORY[0x1BCCB06A4](v14, 0x10A0C408BE2A288);
    v6 = *(_QWORD *)(a1 + 40);
  }
  v16 = (_DWORD *)_windowsResolvePtr(v6 + 40, 0x400uLL, *(_QWORD *)(v6 + 16));
  v17 = v16;
  if (!*(_BYTE *)(a2 + 21))
  {
    *(_DWORD *)(a1 + 52) = *v16;
    v19 = *(_QWORD **)(a1 + 40);
    v20 = *__error();
    v21 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      v22 = v19[6];
      v23 = (void *)v19[7];
      v25 = v19[2];
      v24 = v19[3];
      *(_DWORD *)buf = 134219008;
      *(_QWORD *)&buf[4] = v19;
      *(_WORD *)&buf[12] = 2048;
      *(_QWORD *)&buf[14] = v22;
      *(_WORD *)&buf[22] = 2048;
      v44 = v23;
      *(_WORD *)v45 = 2048;
      *(_QWORD *)&v45[2] = v24;
      *(_WORD *)&v45[10] = 2048;
      *(_QWORD *)&v45[12] = v25;
      _os_log_impl(&dword_1B8270000, v21, OS_LOG_TYPE_DEFAULT, "vi_onefixedsize_disk_allocator %p size: %llu, freeRegion: %llu, header: %llu, elemSize: %lu", buf, 0x34u);
    }
    *__error() = v20;
    v26 = *(_QWORD **)(a1 + 40);
    v27 = v26[2];
    v28 = v26[7] - v26[3];
    v29 = v28 / v27;
    if (v28 == v28 / v27 * v27)
    {
      *(_DWORD *)(a1 + 48) = v29;
      if (v17[1] == (_DWORD)v29)
      {
        if (v26[3] == 1040)
        {
          if (v26[2] == 2048)
            return a1;
          v40 = __si_assert_copy_extra_268();
          v32 = v40;
          v41 = "";
          if (v40)
            v41 = v40;
          __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 490, "vi_onefixedsize_disk_allocator::getElementSize(storage.get()) == sizeof(CIVector_t)", v41);
        }
        else
        {
          v38 = __si_assert_copy_extra_268();
          v32 = v38;
          v39 = "";
          if (v38)
            v39 = v38;
          __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 489, "vi_onefixedsize_disk_allocator::getHeaderSize(storage.get()) == sizeof(QuantizerHeader_t)", v39);
        }
      }
      else
      {
        v36 = __si_assert_copy_extra_268();
        v32 = v36;
        v37 = "";
        if (v36)
          v37 = v36;
        __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 488, "nCentroids == header->count", v37);
      }
    }
    else
    {
      v34 = __si_assert_copy_extra_268();
      v32 = v34;
      v35 = "";
      if (v34)
        v35 = v34;
      __message_assert("%s:%u: failed assertion '%s' %s ", "VectorIndexSupport.hh", 504, "offset % elemSize == 0", v35);
    }
LABEL_32:
    free(v32);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v16[1] = 0;
  v18 = *(_DWORD *)(a2 + 24);
  *v16 = v18;
  *(_DWORD *)(a1 + 52) = v18;
  return a1;
}

void std::__shared_ptr_pointer<AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,512> *,std::shared_ptr<AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,512>>::__shared_ptr_default_delete<AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,512>,AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,512>>,std::allocator<AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,512>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BCCB06A4);
}

uint64_t std::__shared_ptr_pointer<AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,512> *,std::shared_ptr<AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,512>>::__shared_ptr_default_delete<AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,512>,AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,512>>,std::allocator<AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,512>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,512>::~AllocatedVectorQuantizer(uint64_t a1)
{
  AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,512>::~AllocatedVectorQuantizer(a1);
  JUMPOUT(0x1BCCB06A4);
}

uint64_t AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,512>::version(uint64_t a1)
{
  return *(unsigned int *)(a1 + 52);
}

uint64_t AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,512>::count(uint64_t a1)
{
  return *(unsigned int *)(a1 + 48);
}

uint64_t Quantizer<float,512>::dimension()
{
  return 512;
}

uint64_t Quantizer<float,512>::elementSize()
{
  return 4;
}

BOOL Quantizer<float,512>::operator==(uint64_t a1, uint64_t a2)
{
  int v4;
  uint64_t v5;
  const void *v6;
  const void *v7;
  int v8;
  _BOOL8 result;
  char *v10;
  char *v11;
  const char *v12;
  char *v13;
  const char *v14;

  if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)a2 + 32))(a2) != 512)
  {
    v10 = __si_assert_copy_extra_268();
    v11 = v10;
    v12 = "";
    if (v10)
      v12 = v10;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 282, "D == other.dimension()", v12);
LABEL_17:
    free(v11);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  if ((*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 40))(a2) != 4)
  {
    v13 = __si_assert_copy_extra_268();
    v11 = v13;
    v14 = "";
    if (v13)
      v14 = v13;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 283, "sizeof(ELEM_TYPE) == other.elementSize()", v14);
    goto LABEL_17;
  }
  v4 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
  if (v4 != (*(unsigned int (**)(uint64_t))(*(_QWORD *)a2 + 24))(a2))
    return 0;
  if (!(*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1))
    return 1;
  v5 = 0;
  while (1)
  {
    v6 = (const void *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 64))(a1, v5);
    v7 = (const void *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 64))(a2, v5);
    v8 = memcmp(v6, v7, 0x800uLL);
    result = v8 == 0;
    if (v8)
      break;
    v5 = (v5 + 1);
    if (v5 >= (*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1))
      return 1;
  }
  return result;
}

BOOL Quantizer<float,512>::isPersistent(uint64_t a1)
{
  _QWORD *v1;
  int v2;

  v1 = (_QWORD *)(a1 + 8);
  v2 = *(char *)(a1 + 31);
  if ((v2 & 0x80000000) == 0)
  {
    if (v2 != 8)
      return 1;
    return *v1 != 0x3E79726F6D656D3CLL;
  }
  if (*(_QWORD *)(a1 + 16) == 8)
  {
    v1 = (_QWORD *)*v1;
    return *v1 != 0x3E79726F6D656D3CLL;
  }
  return 1;
}

unint64_t AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,512>::getCentroid(uint64_t a1, unsigned int a2)
{
  char *v3;
  char *v4;
  const char *v5;

  if (*(_DWORD *)(a1 + 48) <= a2)
  {
    v3 = __si_assert_copy_extra_268();
    v4 = v3;
    v5 = "";
    if (v3)
      v5 = v3;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 514, "i < nCentroids", v5);
    free(v4);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  return _windowsResolvePtr(*(_QWORD *)(a1 + 40) + 40, *(_QWORD *)(*(_QWORD *)(a1 + 40) + 24) + *(_QWORD *)(*(_QWORD *)(a1 + 40) + 16) * a2, 0x800uLL);
}

void Quantizer<float,512>::topKPartitions(uint64_t a1@<X0>, const float *a2@<X1>, unsigned int a3@<W2>, int **a4@<X8>)
{
  char *v7;
  char *v8;
  char *v9;
  unint64_t v10;
  unint64_t v11;
  const float *v12;
  const float *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  float v17;
  int v18;
  _BOOL4 v19;
  uint64_t v20;
  char *v21;
  float v22;
  float v23;
  float v24;
  _BOOL4 v25;
  float *v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  _BYTE *v30;
  _DWORD *v31;
  unint64_t v32;
  char *v33;
  char *v34;
  uint64_t v35;
  char *v36;
  uint64_t v37;
  unint64_t v38;
  float *v39;
  float v40;
  float v41;
  int v42;
  float v43;
  _BOOL4 v44;
  float *v45;
  float v46;
  BOOL v47;
  unint64_t v48;
  float *v49;
  unsigned int v50;
  char *v51;
  float v52;
  float v53;
  int v54;
  _BOOL4 v55;
  float *v56;
  float v57;
  BOOL v58;
  char *v59;
  unint64_t v60;
  float *v61;
  float v62;
  int v63;
  _BOOL4 v64;
  float *v65;
  float v66;
  BOOL v67;
  uint64_t v68;
  _OWORD *v69;
  char *v70;
  uint64_t v71;
  __int128 v72;
  uint64_t v73;
  int *v74;
  float *v75;
  uint64_t v76;
  uint64_t v78;
  int v79;
  int v80;
  float *v81;
  float v82;
  float v83;
  float v84;
  _BOOL4 v85;
  float *v86;
  uint64_t v87;
  char *v88;
  uint64_t v89;
  unint64_t v90;
  float *v91;
  float v92;
  float v93;
  float v94;
  float v95;
  _BOOL4 v96;
  float *v97;
  float v98;
  BOOL v99;
  int **v100;
  unsigned int __C;

  if (!(*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1))
  {
    v7 = 0;
    v75 = 0;
    v74 = 0;
    *a4 = 0;
    a4[1] = 0;
    a4[2] = 0;
    goto LABEL_74;
  }
  v100 = a4;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = a3;
  v12 = a2;
  do
  {
    v13 = (const float *)(*(uint64_t (**)(uint64_t, unint64_t))(*(_QWORD *)a1 + 64))(a1, v10);
    __C = 2139095039;
    vDSP_distancesq(v13, 1, v12, 1, (float *)&__C, 0x200uLL);
    v14 = (v10 | ((unint64_t)__C << 32)) >> 32;
    v15 = v7 - v9;
    v16 = (v7 - v9) >> 3;
    if (v16 < v11)
    {
      if (v7 < v8)
      {
        *(_DWORD *)v7 = v10;
        *((_DWORD *)v7 + 1) = v14;
        v7 += 8;
LABEL_47:
        if (v7 - v9 >= 9)
        {
          v48 = (((unint64_t)(v7 - v9) >> 3) - 2) >> 1;
          v49 = (float *)&v9[8 * v48];
          v51 = v7 - 8;
          v50 = *((_DWORD *)v7 - 2);
          v52 = v49[1];
          v53 = *((float *)v7 - 1);
          v54 = *(_DWORD *)v49;
          v55 = *(_DWORD *)v49 < v50;
          if (v52 != v53)
            v55 = v52 < v53;
          if (v55)
          {
            do
            {
              v56 = v49;
              *(_DWORD *)v51 = v54;
              *((float *)v51 + 1) = v49[1];
              if (!v48)
                break;
              v48 = (v48 - 1) >> 1;
              v49 = (float *)&v9[8 * v48];
              v57 = v49[1];
              v54 = *(_DWORD *)v49;
              v58 = v57 < v53;
              if (v57 == v53)
                v58 = *(_DWORD *)v49 < v50;
              v51 = (char *)v56;
            }
            while (v58);
            *(_DWORD *)v56 = v50;
            v56[1] = v53;
          }
        }
        goto LABEL_4;
      }
      if ((v8 - v9) >> 2 <= (unint64_t)(v16 + 1))
        v28 = v16 + 1;
      else
        v28 = (v8 - v9) >> 2;
      if ((unint64_t)(v8 - v9) >= 0x7FFFFFFFFFFFFFF8)
        v28 = 0x1FFFFFFFFFFFFFFFLL;
      if (v28 >> 61)
        std::__throw_bad_array_new_length[abi:nn180100]();
      v29 = 8 * v28;
      v30 = operator new(8 * v28);
      v31 = &v30[8 * v16];
      *v31 = v10;
      v31[1] = v14;
      if (v7 == v9)
      {
        v36 = v7;
        v9 = &v30[8 * v16];
        goto LABEL_44;
      }
      v32 = v7 - v9 - 8;
      if (v32 >= 0x58 && (unint64_t)(v9 - v30) >= 0x20)
      {
        v68 = (v32 >> 3) + 1;
        v33 = &v7[-8 * (v68 & 0x3FFFFFFFFFFFFFFCLL)];
        v69 = &v30[8 * v16 - 16];
        v70 = v7 - 16;
        v71 = v68 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          v72 = *(_OWORD *)v70;
          *(v69 - 1) = *((_OWORD *)v70 - 1);
          *v69 = v72;
          v69 -= 2;
          v70 -= 32;
          v71 -= 4;
        }
        while (v71);
        v34 = (char *)&v31[-2 * (v68 & 0x3FFFFFFFFFFFFFFCLL)];
        if (v68 == (v68 & 0x3FFFFFFFFFFFFFFCLL))
          goto LABEL_32;
      }
      else
      {
        v33 = v7;
        v34 = &v30[8 * v16];
      }
      do
      {
        v35 = *((_QWORD *)v33 - 1);
        v33 -= 8;
        *((_QWORD *)v34 - 1) = v35;
        v34 -= 8;
      }
      while (v33 != v9);
LABEL_32:
      v36 = v9;
      v9 = v34;
LABEL_44:
      v8 = &v30[v29];
      v7 = (char *)(v31 + 2);
      if (v36)
        operator delete(v36);
      v12 = a2;
      goto LABEL_47;
    }
    v17 = *((float *)v9 + 1);
    v18 = *(_DWORD *)v9;
    v19 = *(_DWORD *)v9 > v10;
    if (v17 != *(float *)&v14)
      v19 = v17 > *(float *)&v14;
    if (v19)
    {
      if (v15 <= 8)
      {
        *((_DWORD *)v7 - 2) = v10;
        *((_DWORD *)v7 - 1) = v14;
      }
      else
      {
        v20 = 0;
        v21 = v9;
        do
        {
          v26 = (float *)&v21[8 * v20 + 8];
          v27 = (2 * v20) | 1;
          v20 = 2 * v20 + 2;
          if (v20 < v16)
          {
            v22 = v26[1];
            v23 = v26[3];
            v24 = *v26;
            v25 = *(_DWORD *)v26 < *((_DWORD *)v26 + 2);
            if (v22 != v23)
              v25 = v22 < v23;
            if (v25)
            {
              v24 = v26[2];
              v26 += 2;
            }
            else
            {
              v20 = v27;
            }
          }
          else
          {
            v24 = *v26;
            v20 = v27;
          }
          *(float *)v21 = v24;
          *((float *)v21 + 1) = v26[1];
          v21 = (char *)v26;
        }
        while (v20 <= (uint64_t)((unint64_t)(v16 - 2) >> 1));
        if (v26 == (float *)(v7 - 8))
        {
          *(_DWORD *)v26 = v18;
          v26[1] = v17;
        }
        else
        {
          *v26 = *((float *)v7 - 2);
          v26[1] = *((float *)v7 - 1);
          *((_DWORD *)v7 - 2) = v18;
          *((float *)v7 - 1) = v17;
          v37 = (char *)v26 - v9 + 8;
          if (v37 >= 9)
          {
            v38 = (((unint64_t)v37 >> 3) - 2) >> 1;
            v39 = (float *)&v9[8 * v38];
            v40 = v39[1];
            v41 = v26[1];
            v42 = *(_DWORD *)v39;
            v43 = *v26;
            v44 = *(_DWORD *)v39 < *(_DWORD *)v26;
            if (v40 != v41)
              v44 = v40 < v41;
            if (v44)
            {
              do
              {
                v45 = v39;
                *(_DWORD *)v26 = v42;
                v26[1] = v39[1];
                if (!v38)
                  break;
                v38 = (v38 - 1) >> 1;
                v39 = (float *)&v9[8 * v38];
                v46 = v39[1];
                v42 = *(_DWORD *)v39;
                v47 = v46 < v41;
                if (v46 == v41)
                  v47 = *(_DWORD *)v39 < LODWORD(v43);
                v26 = v45;
              }
              while (v47);
              *v45 = v43;
              v45[1] = v41;
            }
          }
        }
        *((_DWORD *)v7 - 2) = v10;
        *((_DWORD *)v7 - 1) = v14;
        v59 = v7 - 8;
        v60 = (((unint64_t)v15 >> 3) - 2) >> 1;
        v61 = (float *)&v9[8 * v60];
        v62 = v61[1];
        v63 = *(_DWORD *)v61;
        v64 = *(_DWORD *)v61 < v10;
        if (v62 != *(float *)&v14)
          v64 = v62 < *(float *)&v14;
        if (v64)
        {
          do
          {
            v65 = v61;
            *(_DWORD *)v59 = v63;
            *((float *)v59 + 1) = v61[1];
            if (!v60)
              break;
            v60 = (v60 - 1) >> 1;
            v61 = (float *)&v9[8 * v60];
            v66 = v61[1];
            v63 = *(_DWORD *)v61;
            v67 = v66 < *(float *)&v14;
            if (v66 == *(float *)&v14)
              v67 = *(_DWORD *)v61 < v10;
            v59 = (char *)v65;
          }
          while (v67);
          *(_DWORD *)v65 = v10;
          *((_DWORD *)v65 + 1) = v14;
        }
      }
    }
LABEL_4:
    ++v10;
  }
  while (v10 < (*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1));
  *v100 = 0;
  v100[1] = 0;
  v100[2] = 0;
  v73 = v7 - v9;
  if (v7 == v9)
  {
    v75 = 0;
    v74 = 0;
  }
  else
  {
    if (v73 < 0)
      abort();
    v74 = (int *)operator new(v7 - v9);
    *v100 = v74;
    v100[2] = &v74[2 * (v73 >> 3)];
    memcpy(v74, v9, v73 & 0xFFFFFFFFFFFFFFF8);
    v75 = (float *)((char *)v74 + (v73 & 0xFFFFFFFFFFFFFFF8));
    v100[1] = (int *)v75;
    v7 = v9;
  }
LABEL_74:
  if ((char *)v75 - (char *)v74 >= 9)
  {
    v76 = (unint64_t)((char *)v75 - (char *)v74) >> 3;
    do
    {
      v78 = 0;
      v79 = *v74;
      v80 = v74[1];
      v81 = (float *)v74;
      do
      {
        v86 = &v81[2 * v78 + 2];
        v87 = (2 * v78) | 1;
        v78 = 2 * v78 + 2;
        if (v78 < v76)
        {
          v82 = v86[1];
          v83 = v86[3];
          v84 = *v86;
          v85 = *(_DWORD *)v86 < *((_DWORD *)v86 + 2);
          if (v82 != v83)
            v85 = v82 < v83;
          if (v85)
          {
            v84 = v86[2];
            v86 += 2;
          }
          else
          {
            v78 = v87;
          }
        }
        else
        {
          v84 = *v86;
          v78 = v87;
        }
        *v81 = v84;
        v81[1] = v86[1];
        v81 = v86;
      }
      while (v78 <= (uint64_t)((unint64_t)(v76 - 2) >> 1));
      v88 = (char *)(v75 - 2);
      if (v86 == v75 - 2)
      {
        *(_DWORD *)v86 = v79;
        *((_DWORD *)v86 + 1) = v80;
      }
      else
      {
        *v86 = *(v75 - 2);
        v86[1] = *(v75 - 1);
        *((_DWORD *)v75 - 2) = v79;
        *((_DWORD *)v75 - 1) = v80;
        v89 = (char *)v86 - (char *)v74 + 8;
        if (v89 >= 9)
        {
          v90 = (((unint64_t)v89 >> 3) - 2) >> 1;
          v91 = (float *)&v74[2 * v90];
          v92 = v91[1];
          v93 = v86[1];
          v94 = *v91;
          v95 = *v86;
          v96 = *(_DWORD *)v91 < *(_DWORD *)v86;
          if (v92 != v93)
            v96 = v92 < v93;
          if (v96)
          {
            do
            {
              v97 = v91;
              *v86 = v94;
              v86[1] = v91[1];
              if (!v90)
                break;
              v90 = (v90 - 1) >> 1;
              v91 = (float *)&v74[2 * v90];
              v98 = v91[1];
              v94 = *v91;
              v99 = v98 < v93;
              if (v98 == v93)
                v99 = *(_DWORD *)v91 < LODWORD(v95);
              v86 = v97;
            }
            while (v99);
            *v97 = v95;
            v97[1] = v93;
          }
        }
      }
      v75 = (float *)v88;
    }
    while (v76-- > 2);
  }
  if (v7)
    operator delete(v7);
}

uint64_t AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,512>::~AllocatedVectorQuantizer(uint64_t a1)
{
  unsigned __int8 v2;
  uint64_t v3;
  const void *v4;
  uint64_t v5;
  const void *v6;

  *(_QWORD *)a1 = &off_1E6E32C48;
  v2 = atomic_load((unsigned __int8 *)(a1 + 57));
  if ((v2 & 1) != 0)
    vi_onefixedsize_disk_allocator::unlinkStorage(*(_QWORD *)(a1 + 40));
  v3 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 40) = 0;
  if (v3)
  {
    storage_array_Close(v3 + 8);
    v4 = *(const void **)(v3 + 4208);
    if (v4)
    {
      CFRelease(v4);
      *(_QWORD *)(v3 + 4208) = 0;
    }
    *(_OWORD *)(v3 + 4192) = 0u;
    MEMORY[0x1BCCB06A4](v3, 0x10A0C408BE2A288);
  }
  fd_release(*(char **)(a1 + 64));
  v5 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 40) = 0;
  if (v5)
  {
    storage_array_Close(v5 + 8);
    v6 = *(const void **)(v5 + 4208);
    if (v6)
    {
      CFRelease(v6);
      *(_QWORD *)(v5 + 4208) = 0;
    }
    *(_OWORD *)(v5 + 4192) = 0u;
    MEMORY[0x1BCCB06A4](v5, 0x10A0C408BE2A288);
  }
  *(_QWORD *)a1 = off_1E6E30F58;
  if (*(char *)(a1 + 31) < 0)
    operator delete(*(void **)(a1 + 8));
  return a1;
}

void ___ZN19ZeroVectorQuantizerIfLi512EE14sharedInstanceEv_block_invoke()
{
  uint64_t v0;
  unsigned __int8 v1;
  void **v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  std::ios_base *v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  std::__shared_weak_count *v15;
  unint64_t *p_shared_owners;
  unint64_t v17;
  __int128 v18;
  uint64_t v19;
  char __str[8];
  uint64_t v21;
  uint64_t v22;
  _OWORD v23[4];
  void *__p[2];
  __int128 v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v0 = operator new();
  if ((v1 & 1) == 0
  {
    bzero(&ZeroVectorQuantizer<float,512>::centroid(void)::centroid, 0x800uLL);
  }
  if (ZeroVectorQuantizer<float,512>::centroid(void)::onceToken != -1)
    dispatch_once(&ZeroVectorQuantizer<float,512>::centroid(void)::onceToken, &__block_literal_global_623);
  *(_QWORD *)(v0 + 8) = 0;
  v2 = (void **)(v0 + 8);
  *(_QWORD *)(v0 + 16) = 0;
  *(_QWORD *)(v0 + 24) = 0;
  *(_QWORD *)v0 = off_1E6E32AB8;
  memcpy((void *)(v0 + 33), &ZeroVectorQuantizer<float,512>::centroid(void)::centroid, 0x800uLL);
  bzero(__str, 0x400uLL);
  snprintf(__str, 0x400uLL, "S%08x%08x-1x%dx%u", ZeroVectorQuantizer<float,512>::centroid(void)::centroid, dword_1EF1AFA4C, 512, 32);
  MEMORY[0x1BCCB03B0](v0 + 8, __str);
  *(_QWORD *)v0 = off_1E6E32A18;
  v36 = 0u;
  v26 = 0;
  v35 = 0u;
  v34 = 0u;
  v33 = 0u;
  v32 = 0u;
  v31 = 0u;
  v30 = 0u;
  v29 = 0u;
  v28 = 0u;
  v25 = 0u;
  *(_OWORD *)__p = 0u;
  memset(v23, 0, sizeof(v23));
  v3 = MEMORY[0x1E0DE4FD0];
  v4 = MEMORY[0x1E0DE4FD0] + 104;
  v27 = MEMORY[0x1E0DE4FD0] + 104;
  v5 = (_QWORD *)MEMORY[0x1E0DE4F50];
  v6 = MEMORY[0x1E0DE4FD0] + 64;
  v7 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 16);
  v8 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 24);
  v22 = MEMORY[0x1E0DE4FD0] + 64;
  *(_QWORD *)__str = v7;
  *(_QWORD *)&__str[*(_QWORD *)(v7 - 24)] = v8;
  v21 = 0;
  v9 = (std::ios_base *)&__str[*(_QWORD *)(*(_QWORD *)__str - 24)];
  std::ios_base::init(v9, v23);
  v9[1].__vftable = 0;
  v9[1].__fmtflags_ = -1;
  v10 = v5[5];
  v22 = v5[4];
  *(uint64_t *)((char *)&v22 + *(_QWORD *)(v22 - 24)) = v10;
  *(_QWORD *)__str = v5[1];
  *(_QWORD *)&__str[*(_QWORD *)(*(_QWORD *)__str - 24)] = v5[6];
  v27 = v4;
  *(_QWORD *)__str = v3 + 24;
  v22 = v6;
  std::streambuf::basic_streambuf();
  v11 = MEMORY[0x1E0DE4FB8] + 16;
  *(_QWORD *)&v23[0] = MEMORY[0x1E0DE4FB8] + 16;
  *(_OWORD *)__p = 0u;
  v25 = 0u;
  LODWORD(v26) = 24;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v22, (uint64_t)"Z1000000000000000-1x", 20);
  v12 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v12, (uint64_t)"x", 1);
  std::ostream::operator<<();
  std::stringbuf::str();
  if (*(char *)(v0 + 31) < 0)
    operator delete(*v2);
  *(_OWORD *)v2 = v18;
  *(_QWORD *)(v0 + 24) = v19;
  *(_QWORD *)__str = *v5;
  v13 = v5[9];
  *(_QWORD *)&__str[*(_QWORD *)(*(_QWORD *)__str - 24)] = v5[8];
  v22 = v13;
  *(_QWORD *)&v23[0] = v11;
  if (SBYTE7(v25) < 0)
    operator delete(__p[0]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x1BCCB0650](&v27);
  v14 = (_QWORD *)operator new();
  *v14 = &off_1E6E32B18;
  v14[1] = 0;
  v14[2] = 0;
  v14[3] = v0;
  v15 = (std::__shared_weak_count *)qword_1EF1AF238;
  ZeroVectorQuantizer<float,512>::sharedInstance(void)::zvq = v0;
  qword_1EF1AF238 = (uint64_t)v14;
  if (v15)
  {
    p_shared_owners = (unint64_t *)&v15->__shared_owners_;
    do
      v17 = __ldaxr(p_shared_owners);
    while (__stlxr(v17 - 1, p_shared_owners));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
}

void std::__shared_ptr_pointer<ZeroVectorQuantizer<float,512> *,std::shared_ptr<Quantizer<float,512>>::__shared_ptr_default_delete<Quantizer<float,512>,ZeroVectorQuantizer<float,512>>,std::allocator<ZeroVectorQuantizer<float,512>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BCCB06A4);
}

uint64_t std::__shared_ptr_pointer<ZeroVectorQuantizer<float,512> *,std::shared_ptr<Quantizer<float,512>>::__shared_ptr_default_delete<Quantizer<float,512>,ZeroVectorQuantizer<float,512>>,std::allocator<ZeroVectorQuantizer<float,512>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t ZeroVectorQuantizer<float,512>::~ZeroVectorQuantizer(uint64_t a1)
{
  *(_QWORD *)a1 = off_1E6E30F58;
  if (*(char *)(a1 + 31) < 0)
    operator delete(*(void **)(a1 + 8));
  return a1;
}

void ZeroVectorQuantizer<float,512>::~ZeroVectorQuantizer(uint64_t a1)
{
  *(_QWORD *)a1 = off_1E6E30F58;
  if (*(char *)(a1 + 31) < 0)
    operator delete(*(void **)(a1 + 8));
  JUMPOUT(0x1BCCB06A4);
}

uint64_t SingleVectorQuantizer<float,512>::count()
{
  return 1;
}

uint64_t SingleVectorQuantizer<float,512>::getCentroid(uint64_t a1, int a2)
{
  char *v3;
  char *v4;
  const char *v5;

  if (a2)
  {
    v3 = __si_assert_copy_extra_268();
    v4 = v3;
    v5 = "";
    if (v3)
      v5 = v3;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 387, "i < 1", v5);
    free(v4);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  return a1 + 33;
}

float *SingleVectorQuantizer<float,512>::topKPartitions@<X0>(const float *__A@<X1>, uint64_t a2@<X0>, float **a3@<X8>)
{
  float v4;
  float *result;
  float __C;

  __C = 3.4028e38;
  vDSP_distancesq(__A, 1, (const float *)(a2 + 33), 1, &__C, 0x200uLL);
  v4 = __C;
  result = (float *)operator new(8uLL);
  a3[1] = result + 2;
  a3[2] = result + 2;
  *result = 0.0;
  result[1] = v4;
  *a3 = result;
  return result;
}

uint64_t SingleVectorQuantizer<float,512>::~SingleVectorQuantizer(uint64_t a1)
{
  *(_QWORD *)a1 = off_1E6E30F58;
  if (*(char *)(a1 + 31) < 0)
    operator delete(*(void **)(a1 + 8));
  return a1;
}

void SingleVectorQuantizer<float,512>::~SingleVectorQuantizer(uint64_t a1)
{
  *(_QWORD *)a1 = off_1E6E30F58;
  if (*(char *)(a1 + 31) < 0)
    operator delete(*(void **)(a1 + 8));
  JUMPOUT(0x1BCCB06A4);
}

void ___ZN19ZeroVectorQuantizerIfLi512EE8centroidEv_block_invoke()
{
  bzero(&unk_1EF1AF254, 0x7FCuLL);
  ZeroVectorQuantizer<float,512>::centroid(void)::centroid = 1065353216;
}

uint64_t std::unordered_map<std::string,std::weak_ptr<QuantizerManager<float,512>>>::~unordered_map[abi:nn180100](uint64_t a1)
{
  char *v2;
  void *v3;
  char *v5;
  std::__shared_weak_count *v6;

  v2 = *(char **)(a1 + 16);
  if (v2)
  {
    do
    {
      v5 = *(char **)v2;
      v6 = (std::__shared_weak_count *)*((_QWORD *)v2 + 6);
      if (v6)
        std::__shared_weak_count::__release_weak(v6);
      if (v2[39] < 0)
        operator delete(*((void **)v2 + 2));
      operator delete(v2);
      v2 = v5;
    }
    while (v5);
  }
  v3 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v3)
    operator delete(v3);
  return a1;
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::string,std::weak_ptr<QuantizerManager<float,512>>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::weak_ptr<QuantizerManager<float,512>>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::weak_ptr<QuantizerManager<float,512>>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::weak_ptr<QuantizerManager<float,512>>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1, uint64_t a2)
{
  int v3;
  uint64_t *v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint8x8_t v9;
  unint64_t v10;
  void **v11;
  unsigned __int8 *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  std::string *v21;
  float v22;
  _BOOL8 v23;
  unint64_t v24;
  unint64_t v25;
  size_t prime;
  void *v27;
  void *v28;
  uint64_t v29;
  _QWORD **v30;
  size_t v31;
  size_t v32;
  size_t v33;
  _QWORD *i;
  size_t v35;
  uint64_t v36;
  unint64_t v37;
  uint8x8_t v38;
  uint64_t v39;
  _QWORD *v40;
  uint64_t v41;
  size_t v42;
  uint64_t v43;
  _QWORD *v44;
  unint64_t v45;
  void *v47;

  v3 = *(char *)(a1 + 23);
  if (v3 >= 0)
    v4 = (uint64_t *)a1;
  else
    v4 = *(uint64_t **)a1;
  if (v3 >= 0)
    v5 = *(unsigned __int8 *)(a1 + 23);
  else
    v5 = *(_QWORD *)(a1 + 8);
  v6 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v4, v5);
  v7 = v6;
  v8 = *((_QWORD *)&QuantizerManager<float,512>::sharedInstance(int,unsigned int,unsigned short)::managers + 1);
  if (*((_QWORD *)&QuantizerManager<float,512>::sharedInstance(int,unsigned int,unsigned short)::managers + 1))
  {
    v9 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&QuantizerManager<float,512>::sharedInstance(int,unsigned int,unsigned short)::managers
                                        + 8));
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      v10 = v6;
      if (v6 >= *((_QWORD *)&QuantizerManager<float,512>::sharedInstance(int,unsigned int,unsigned short)::managers + 1))
        v10 = v6
            % *((_QWORD *)&QuantizerManager<float,512>::sharedInstance(int,unsigned int,unsigned short)::managers + 1);
    }
    else
    {
      v10 = (*((_QWORD *)&QuantizerManager<float,512>::sharedInstance(int,unsigned int,unsigned short)::managers + 1)
           - 1) & v6;
    }
    v11 = *(void ***)(QuantizerManager<float,512>::sharedInstance(int,unsigned int,unsigned short)::managers + 8 * v10);
    if (v11)
    {
      v12 = (unsigned __int8 *)*v11;
      if (*v11)
      {
        if (v9.u32[0] < 2uLL)
        {
          while (1)
          {
            v17 = *((_QWORD *)v12 + 1);
            if (v17 == v7)
            {
              v18 = v12[39];
              if ((v18 & 0x80u) == 0)
                v19 = v12[39];
              else
                v19 = *((_QWORD *)v12 + 3);
              if (v19 == v5)
              {
                if ((v18 & 0x80) != 0)
                {
                  if (!memcmp(*((const void **)v12 + 2), v4, *((_QWORD *)v12 + 3)))
                    return v12;
                }
                else
                {
                  if (!v12[39])
                    return v12;
                  v20 = 0;
                  while (v12[v20 + 16] == *((unsigned __int8 *)v4 + v20))
                  {
                    if (v18 == ++v20)
                      return v12;
                  }
                }
              }
            }
            else if ((v17 & (v8 - 1)) != v10)
            {
              goto LABEL_49;
            }
            v12 = *(unsigned __int8 **)v12;
            if (!v12)
              goto LABEL_49;
          }
        }
        do
        {
          v13 = *((_QWORD *)v12 + 1);
          if (v13 == v7)
          {
            v14 = v12[39];
            if ((v14 & 0x80u) == 0)
              v15 = v12[39];
            else
              v15 = *((_QWORD *)v12 + 3);
            if (v15 == v5)
            {
              if ((v14 & 0x80) != 0)
              {
                if (!memcmp(*((const void **)v12 + 2), v4, *((_QWORD *)v12 + 3)))
                  return v12;
              }
              else
              {
                if (!v12[39])
                  return v12;
                v16 = 0;
                while (v12[v16 + 16] == *((unsigned __int8 *)v4 + v16))
                {
                  if (v14 == ++v16)
                    return v12;
                }
              }
            }
          }
          else
          {
            if (v13 >= v8)
              v13 %= v8;
            if (v13 != v10)
              break;
          }
          v12 = *(unsigned __int8 **)v12;
        }
        while (v12);
      }
    }
  }
  else
  {
    v10 = 0;
  }
LABEL_49:
  v12 = (unsigned __int8 *)operator new(0x38uLL);
  *(_QWORD *)v12 = 0;
  *((_QWORD *)v12 + 1) = v7;
  v21 = (std::string *)(v12 + 16);
  if (*(char *)(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v21, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)&v21->__r_.__value_.__l.__data_ = *(_OWORD *)a2;
    *((_QWORD *)v12 + 4) = *(_QWORD *)(a2 + 16);
  }
  *((_QWORD *)v12 + 5) = 0;
  *((_QWORD *)v12 + 6) = 0;
  v22 = (float)(unint64_t)(qword_1EF1B0750 + 1);
  if (!v8 || (float)(*(float *)&dword_1EF1B0758 * (float)v8) < v22)
  {
    v23 = 1;
    if (v8 >= 3)
      v23 = (v8 & (v8 - 1)) != 0;
    v24 = v23 | (2 * v8);
    v25 = vcvtps_u32_f32(v22 / *(float *)&dword_1EF1B0758);
    if (v24 <= v25)
      prime = v25;
    else
      prime = v24;
    if (prime == 1)
    {
      prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      prime = std::__next_prime(prime);
    }
    v8 = *((_QWORD *)&QuantizerManager<float,512>::sharedInstance(int,unsigned int,unsigned short)::managers + 1);
    if (prime <= *((_QWORD *)&QuantizerManager<float,512>::sharedInstance(int,unsigned int,unsigned short)::managers + 1))
    {
      if (prime >= *((_QWORD *)&QuantizerManager<float,512>::sharedInstance(int,unsigned int,unsigned short)::managers
                    + 1))
        goto LABEL_89;
      v37 = vcvtps_u32_f32((float)(unint64_t)qword_1EF1B0750 / *(float *)&dword_1EF1B0758);
      if (*((_QWORD *)&QuantizerManager<float,512>::sharedInstance(int,unsigned int,unsigned short)::managers + 1) < 3uLL
        || (v38 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&QuantizerManager<float,512>::sharedInstance(int,unsigned int,unsigned short)::managers
                                                 + 8)),
            v38.i16[0] = vaddlv_u8(v38),
            v38.u32[0] > 1uLL))
      {
        v37 = std::__next_prime(v37);
      }
      else
      {
        v39 = 1 << -(char)__clz(v37 - 1);
        if (v37 >= 2)
          v37 = v39;
      }
      if (prime <= v37)
        prime = v37;
      if (prime >= v8)
      {
        v8 = *((_QWORD *)&QuantizerManager<float,512>::sharedInstance(int,unsigned int,unsigned short)::managers + 1);
LABEL_89:
        if ((v8 & (v8 - 1)) != 0)
        {
          if (v7 >= v8)
            v10 = v7 % v8;
          else
            v10 = v7;
        }
        else
        {
          v10 = (v8 - 1) & v7;
        }
        goto LABEL_102;
      }
      if (!prime)
      {
        v47 = (void *)QuantizerManager<float,512>::sharedInstance(int,unsigned int,unsigned short)::managers;
        *(_QWORD *)&QuantizerManager<float,512>::sharedInstance(int,unsigned int,unsigned short)::managers = 0;
        if (v47)
          operator delete(v47);
        v8 = 0;
        *((_QWORD *)&QuantizerManager<float,512>::sharedInstance(int,unsigned int,unsigned short)::managers + 1) = 0;
        goto LABEL_89;
      }
    }
    if (prime >> 61)
      std::__throw_bad_array_new_length[abi:nn180100]();
    v27 = operator new(8 * prime);
    v28 = (void *)QuantizerManager<float,512>::sharedInstance(int,unsigned int,unsigned short)::managers;
    *(_QWORD *)&QuantizerManager<float,512>::sharedInstance(int,unsigned int,unsigned short)::managers = v27;
    if (v28)
      operator delete(v28);
    v29 = 0;
    *((_QWORD *)&QuantizerManager<float,512>::sharedInstance(int,unsigned int,unsigned short)::managers + 1) = prime;
    do
      *(_QWORD *)(QuantizerManager<float,512>::sharedInstance(int,unsigned int,unsigned short)::managers + 8 * v29++) = 0;
    while (prime != v29);
    v30 = (_QWORD **)qword_1EF1B0748;
    if (!qword_1EF1B0748)
    {
LABEL_88:
      v8 = prime;
      goto LABEL_89;
    }
    v31 = *(_QWORD *)(qword_1EF1B0748 + 8);
    v32 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      v33 = v31 & v32;
      *(_QWORD *)(QuantizerManager<float,512>::sharedInstance(int,unsigned int,unsigned short)::managers + 8 * v33) = &qword_1EF1B0748;
      for (i = *v30; *v30; i = *v30)
      {
        v35 = i[1] & v32;
        if (v35 == v33)
        {
          v30 = (_QWORD **)i;
        }
        else if (*(_QWORD *)(QuantizerManager<float,512>::sharedInstance(int,unsigned int,unsigned short)::managers
                            + 8 * v35))
        {
          *v30 = (_QWORD *)*i;
          v36 = 8 * v35;
          *i = **(_QWORD **)(QuantizerManager<float,512>::sharedInstance(int,unsigned int,unsigned short)::managers + v36);
          **(_QWORD **)(QuantizerManager<float,512>::sharedInstance(int,unsigned int,unsigned short)::managers + v36) = i;
        }
        else
        {
          *(_QWORD *)(QuantizerManager<float,512>::sharedInstance(int,unsigned int,unsigned short)::managers + 8 * v35) = v30;
          v30 = (_QWORD **)i;
          v33 = v35;
        }
      }
      goto LABEL_88;
    }
    if (v31 >= prime)
      v31 %= prime;
    *(_QWORD *)(QuantizerManager<float,512>::sharedInstance(int,unsigned int,unsigned short)::managers + 8 * v31) = &qword_1EF1B0748;
    v40 = *v30;
    if (!*v30)
      goto LABEL_88;
    while (1)
    {
      v42 = v40[1];
      if (v42 >= prime)
        v42 %= prime;
      if (v42 != v31)
      {
        if (!*(_QWORD *)(QuantizerManager<float,512>::sharedInstance(int,unsigned int,unsigned short)::managers
                        + 8 * v42))
        {
          *(_QWORD *)(QuantizerManager<float,512>::sharedInstance(int,unsigned int,unsigned short)::managers + 8 * v42) = v30;
          goto LABEL_93;
        }
        *v30 = (_QWORD *)*v40;
        v41 = 8 * v42;
        *v40 = **(_QWORD **)(QuantizerManager<float,512>::sharedInstance(int,unsigned int,unsigned short)::managers + v41);
        **(_QWORD **)(QuantizerManager<float,512>::sharedInstance(int,unsigned int,unsigned short)::managers + v41) = v40;
        v40 = v30;
      }
      v42 = v31;
LABEL_93:
      v30 = (_QWORD **)v40;
      v40 = (_QWORD *)*v40;
      v31 = v42;
      if (!v40)
        goto LABEL_88;
    }
  }
LABEL_102:
  v43 = QuantizerManager<float,512>::sharedInstance(int,unsigned int,unsigned short)::managers;
  v44 = *(_QWORD **)(QuantizerManager<float,512>::sharedInstance(int,unsigned int,unsigned short)::managers + 8 * v10);
  if (v44)
  {
    *(_QWORD *)v12 = *v44;
LABEL_110:
    *v44 = v12;
    goto LABEL_111;
  }
  *(_QWORD *)v12 = qword_1EF1B0748;
  qword_1EF1B0748 = (uint64_t)v12;
  *(_QWORD *)(v43 + 8 * v10) = &qword_1EF1B0748;
  if (*(_QWORD *)v12)
  {
    v45 = *(_QWORD *)(*(_QWORD *)v12 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v45 >= v8)
        v45 %= v8;
    }
    else
    {
      v45 &= v8 - 1;
    }
    v44 = (_QWORD *)(QuantizerManager<float,512>::sharedInstance(int,unsigned int,unsigned short)::managers + 8 * v45);
    goto LABEL_110;
  }
LABEL_111:
  ++qword_1EF1B0750;
  return v12;
}

void std::__shared_ptr_pointer<QuantizerManager<float,512> *,std::shared_ptr<QuantizerManager<float,512>>::__shared_ptr_default_delete<QuantizerManager<float,512>,QuantizerManager<float,512>>,std::allocator<QuantizerManager<float,512>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BCCB06A4);
}

uint64_t std::__shared_ptr_pointer<QuantizerManager<float,512> *,std::shared_ptr<QuantizerManager<float,512>>::__shared_ptr_default_delete<QuantizerManager<float,512>,QuantizerManager<float,512>>,std::allocator<QuantizerManager<float,512>>>::__on_zero_shared(uint64_t result)
{
  uint64_t v1;
  int v2;
  NSObject *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  void *v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;
  _QWORD *v14;
  std::__shared_weak_count *v15;
  int v16;
  _QWORD *v17;
  __int16 v18;
  _QWORD *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v1 = *(_QWORD *)(result + 24);
  if (v1)
  {
    v2 = *__error();
    v3 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4 = (_QWORD *)(v1 + 24);
      if (*(char *)(v1 + 47) < 0)
        v4 = (_QWORD *)*v4;
      v5 = (_QWORD *)(v1 + 48);
      if (*(char *)(v1 + 71) < 0)
        v5 = (_QWORD *)*v5;
      v16 = 136315394;
      v17 = v4;
      v18 = 2080;
      v19 = v5;
      _os_log_impl(&dword_1B8270000, v3, OS_LOG_TYPE_DEFAULT, "QuantizerManager %s/%s destroyed", (uint8_t *)&v16, 0x16u);
    }
    *__error() = v2;
    v6 = *(_QWORD **)(v1 + 128);
    if (v6)
    {
      do
      {
        v14 = (_QWORD *)*v6;
        v15 = (std::__shared_weak_count *)v6[4];
        if (v15)
          std::__shared_weak_count::__release_weak(v15);
        operator delete(v6);
        v6 = v14;
      }
      while (v14);
    }
    v7 = *(void **)(v1 + 112);
    *(_QWORD *)(v1 + 112) = 0;
    if (v7)
      operator delete(v7);
    v8 = *(std::__shared_weak_count **)(v1 + 104);
    if (v8)
    {
      p_shared_owners = (unint64_t *)&v8->__shared_owners_;
      do
        v10 = __ldaxr(p_shared_owners);
      while (__stlxr(v10 - 1, p_shared_owners));
      if (!v10)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }
    v11 = *(std::__shared_weak_count **)(v1 + 88);
    if (!v11)
      goto LABEL_20;
    v12 = (unint64_t *)&v11->__shared_owners_;
    do
      v13 = __ldaxr(v12);
    while (__stlxr(v13 - 1, v12));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
      if ((*(char *)(v1 + 71) & 0x80000000) == 0)
      {
LABEL_21:
        if ((*(char *)(v1 + 47) & 0x80000000) == 0)
          goto LABEL_30;
        goto LABEL_29;
      }
    }
    else
    {
LABEL_20:
      if ((*(char *)(v1 + 71) & 0x80000000) == 0)
        goto LABEL_21;
    }
    operator delete(*(void **)(v1 + 48));
    if ((*(char *)(v1 + 47) & 0x80000000) == 0)
LABEL_30:
      JUMPOUT(0x1BCCB06A4);
LABEL_29:
    operator delete(*(void **)(v1 + 24));
    goto LABEL_30;
  }
  return result;
}

void std::__shared_ptr_emplace<IVFVectorIndexTemplate<float,512>::VectorStore<vi_onefixedsize_disk_allocator,vi_disk_postings>,std::allocator<IVFVectorIndexTemplate<float,512>::VectorStore<vi_onefixedsize_disk_allocator,vi_disk_postings>>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6E34560;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<IVFVectorIndexTemplate<float,512>::VectorStore<vi_onefixedsize_disk_allocator,vi_disk_postings>,std::allocator<IVFVectorIndexTemplate<float,512>::VectorStore<vi_onefixedsize_disk_allocator,vi_disk_postings>>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6E34560;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BCCB06A4);
}

void std::__shared_ptr_emplace<IVFVectorIndexTemplate<float,512>::VectorStore<vi_onefixedsize_disk_allocator,vi_disk_postings>,std::allocator<IVFVectorIndexTemplate<float,512>::VectorStore<vi_onefixedsize_disk_allocator,vi_disk_postings>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v2;
  const void *v3;

  if (*(char *)(a1 + 103) < 0)
    operator delete(*(void **)(a1 + 80));
  v2 = *(_QWORD *)(a1 + 56);
  *(_QWORD *)(a1 + 56) = 0;
  if (v2)
  {
    storage_array_Close(v2 + 8);
    v3 = *(const void **)(v2 + 4208);
    if (v3)
    {
      CFRelease(v3);
      *(_QWORD *)(v2 + 4208) = 0;
    }
    *(_OWORD *)(v2 + 4192) = 0u;
    JUMPOUT(0x1BCCB06A4);
  }
}

void IVFVectorIndexTemplate<float,512>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::~IVFVectorIndexRoot_s(_QWORD *a1)
{
  IVFVectorIndexTemplate<float,512>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::~IVFVectorIndexRoot_s(a1);
  JUMPOUT(0x1BCCB06A4);
}

void IVFVectorIndexTemplate<float,512>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::getQuantizer(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  os_unfair_lock_s *v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;

  v4 = (os_unfair_lock_s *)(a1 + 112);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 112));
  v6 = *(_QWORD *)(a1 + 80);
  v5 = *(std::__shared_weak_count **)(a1 + 88);
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }
  v9 = *(std::__shared_weak_count **)(a1 + 104);
  if (v9)
  {
    v10 = (unint64_t *)&v9->__shared_owners_;
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
  }
  os_unfair_lock_unlock(v4);
  *a2 = v6;
  a2[1] = v5;
  if (v5)
  {
    v12 = (unint64_t *)&v5->__shared_owners_;
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  if (!v9)
    goto LABEL_14;
  v14 = (unint64_t *)&v9->__shared_owners_;
  do
    v15 = __ldaxr(v14);
  while (__stlxr(v15 - 1, v14));
  if (!v15)
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
    if (!v5)
      return;
  }
  else
  {
LABEL_14:
    if (!v5)
      return;
  }
  v16 = (unint64_t *)&v5->__shared_owners_;
  do
    v17 = __ldaxr(v16);
  while (__stlxr(v17 - 1, v16));
  if (!v17)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
}

void IVFVectorIndexTemplate<float,512>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::getPartitions(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  os_unfair_lock_s *v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  unint64_t v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;

  v4 = (os_unfair_lock_s *)(a1 + 112);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 112));
  v5 = *(std::__shared_weak_count **)(a1 + 88);
  if (v5)
  {
    p_shared_owners = (unint64_t *)&v5->__shared_owners_;
    do
      v7 = __ldxr(p_shared_owners);
    while (__stxr(v7 + 1, p_shared_owners));
  }
  v9 = *(_QWORD *)(a1 + 96);
  v8 = *(std::__shared_weak_count **)(a1 + 104);
  if (!v8)
  {
    os_unfair_lock_unlock(v4);
    *a2 = v9;
    a2[1] = 0;
    if (!v5)
      return;
    goto LABEL_15;
  }
  v10 = (unint64_t *)&v8->__shared_owners_;
  do
    v11 = __ldxr(v10);
  while (__stxr(v11 + 1, v10));
  os_unfair_lock_unlock(v4);
  *a2 = v9;
  a2[1] = v8;
  do
    v12 = __ldxr(v10);
  while (__stxr(v12 + 1, v10));
  do
    v13 = __ldaxr(v10);
  while (__stlxr(v13 - 1, v10));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
  if (v5)
  {
LABEL_15:
    v14 = (unint64_t *)&v5->__shared_owners_;
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
}

unint64_t IVFVectorIndexTemplate<float,512>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::getVectorAtOffset(uint64_t a1, unsigned int a2)
{
  return _windowsResolvePtr(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 32) + 40, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 32) + 24)+ *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 32) + 16) * a2, 0x810uLL);
}

void IVFVectorIndexTemplate<float,512>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::newPartitions(uint64_t a1@<X0>, char **a2@<X1>, _QWORD *a3@<X8>)
{
  os_unfair_lock_s *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  const char *v14;
  __int128 v15;
  size_t v16;
  void *v17;
  void **v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _DWORD *v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  unint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  unint64_t v29;
  char *v30;
  unint64_t v31;
  int v32;
  int v33;
  NSObject *v34;
  void **v35;
  int v36;
  int v37;
  char *v38;
  _QWORD *v39;
  int v40;
  unint64_t *v41;
  unint64_t v42;
  unint64_t *v43;
  unint64_t v44;
  char *v45;
  char *v46;
  const char *v47;
  void *__p[2];
  char v49;
  _OWORD v50[2];
  void *__dst[2];
  unint64_t v52;
  _OWORD v53[2];
  __int128 v54;
  __int128 v55;
  uint8_t buf[24];
  __int16 v57;
  _QWORD *v58;
  __int16 v59;
  int v60;
  uint64_t v61;

  v61 = *MEMORY[0x1E0C80C00];
  v6 = (os_unfair_lock_s *)(a1 + 112);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 112));
  v7 = *(std::__shared_weak_count **)(a1 + 88);
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }
  v11 = *(_QWORD *)(a1 + 96);
  v10 = *(std::__shared_weak_count **)(a1 + 104);
  if (v10)
  {
    v12 = (unint64_t *)&v10->__shared_owners_;
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  os_unfair_lock_unlock(v6);
  v14 = ".partitions";
  if (v11 && (*(unsigned int (**)(uint64_t))(*(_QWORD *)v11 + 24))(v11))
    v14 = ".tmp.partitions";
  v55 = 0u;
  v15 = *(_OWORD *)(a1 + 24);
  v53[0] = *(_OWORD *)(a1 + 8);
  v53[1] = v15;
  v54 = 0u;
  v16 = strlen(v14);
  if (v16 >= 0x7FFFFFFFFFFFFFF8)
LABEL_60:
    abort();
  v17 = (void *)v16;
  if (v16 >= 0x17)
  {
    v19 = (v16 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v16 | 7) != 0x17)
      v19 = v16 | 7;
    v20 = v19 + 1;
    v18 = (void **)operator new(v19 + 1);
    __dst[1] = v17;
    v52 = v20 | 0x8000000000000000;
    __dst[0] = v18;
    goto LABEL_17;
  }
  HIBYTE(v52) = v16;
  v18 = __dst;
  if (v16)
LABEL_17:
    memcpy(v18, v14, (size_t)v17);
  *((_BYTE *)v17 + (_QWORD)v18) = 0;
  IVFVectorIndexTemplate<float,768>::childMetaInfo((uint64_t)&v54, (uint64_t)v53, (uint64_t)__dst, 1);
  if (SHIBYTE(v52) < 0)
    operator delete(__dst[0]);
  v21 = operator new();
  v22 = (_DWORD *)v21;
  v50[0] = v54;
  v50[1] = v55;
  v23 = (std::__shared_weak_count *)a2[1];
  *(_QWORD *)buf = *a2;
  *(_QWORD *)&buf[8] = v23;
  if (v23)
  {
    v24 = (unint64_t *)&v23->__shared_owners_;
    do
      v25 = __ldxr(v24);
    while (__stxr(v25 + 1, v24));
    PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionStore<vi_onefixedsize_disk_allocator>(v21, (uint64_t)v50, buf);
    do
      v26 = __ldaxr(v24);
    while (__stlxr(v26 - 1, v24));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
  else
  {
    PartitionStore<vi_onefixedsize_disk_allocator,512>::PartitionStore<vi_onefixedsize_disk_allocator>(v21, (uint64_t)v50, buf);
  }
  *a3 = v22;
  v27 = (_QWORD *)operator new();
  *v27 = &off_1E6E33858;
  v27[1] = 0;
  v27[2] = 0;
  v27[3] = v22;
  a3[1] = v27;
  v28 = *(_QWORD *)(a1 + 48);
  if (*(_DWORD *)(v28 + 40))
  {
    v29 = 0;
    do
    {
      memset(buf, 0, sizeof(buf));
      v30 = *a2;
      v31 = _windowsResolvePtr(*(_QWORD *)(v28 + 32) + 40, *(_QWORD *)(*(_QWORD *)(v28 + 32) + 24) + *(_QWORD *)(*(_QWORD *)(v28 + 32) + 16) * v29, 0x810uLL);
      (*(void (**)(uint8_t *__return_ptr, char *, unint64_t, uint64_t))(*(_QWORD *)v30 + 72))(buf, v30, v31, 1);
      (*(void (**)(_DWORD *, _QWORD, unint64_t, float))(*(_QWORD *)v22 + 56))(v22, **(_DWORD **)buf, v29, *(float *)(*(_QWORD *)buf + 4));
      if (*(_QWORD *)buf)
      {
        *(_QWORD *)&buf[8] = *(_QWORD *)buf;
        operator delete(*(void **)buf);
      }
      ++v29;
      v28 = *(_QWORD *)(a1 + 48);
    }
    while (v29 < *(unsigned int *)(v28 + 40));
  }
  (*(void (**)(_DWORD *, _QWORD))(*(_QWORD *)v22 + 112))(v22, 0);
  v32 = *(_DWORD *)(*(_QWORD *)(a1 + 48) + 40);
  if (v32)
  {
    v33 = *__error();
    v34 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
    {
      (*(void (**)(void **__return_ptr, _DWORD *))(*(_QWORD *)v22 + 144))(__p, v22);
      if (v49 >= 0)
        v35 = __p;
      else
        v35 = (void **)__p[0];
      v36 = v22[17];
      v37 = v22[18];
      v38 = *a2;
      v39 = *a2 + 8;
      if (v38[31] < 0)
        v39 = (_QWORD *)*v39;
      v40 = (*(uint64_t (**)(char *))(*(_QWORD *)v38 + 16))(v38);
      *(_DWORD *)buf = 136316162;
      *(_QWORD *)&buf[4] = v35;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v37;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v36;
      v57 = 2080;
      v58 = v39;
      v59 = 1024;
      v60 = v40;
      _os_log_impl(&dword_1B8270000, v34, OS_LOG_TYPE_DEFAULT, "Create new partitions %s(%u/%u) for new quantizer %s(%u)", buf, 0x28u);
      if (v49 < 0)
        operator delete(__p[0]);
    }
    *__error() = v33;
    v32 = *(_DWORD *)(*(_QWORD *)(a1 + 48) + 40);
  }
  if (v22[18] != v32)
  {
    v45 = __si_assert_copy_extra_268();
    v46 = v45;
    v47 = "";
    if (v45)
      v47 = v45;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2363, "newPartitions->nVectors() == vectors->count()", v47);
    free(v46);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    goto LABEL_60;
  }
  if (v10)
  {
    v41 = (unint64_t *)&v10->__shared_owners_;
    do
      v42 = __ldaxr(v41);
    while (__stlxr(v42 - 1, v41));
    if (!v42)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
  if (v7)
  {
    v43 = (unint64_t *)&v7->__shared_owners_;
    do
      v44 = __ldaxr(v43);
    while (__stlxr(v44 - 1, v43));
    if (!v44)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
}

void IVFVectorIndexTemplate<float,512>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::replaceQuantizer(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  os_unfair_lock_s *v6;
  os_unfair_lock_s *v7;
  std::__shared_weak_count *v8;
  __int128 *v9;
  char *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  std::__shared_weak_count *v13;
  _DWORD *v14;
  unint64_t *v15;
  unint64_t v16;
  int v17;
  _DWORD *v18;
  NSObject *v19;
  _QWORD *v20;
  int v21;
  _QWORD *v22;
  void **v23;
  int v24;
  void **v25;
  int v26;
  int v27;
  BOOL v28;
  uint64_t v29;
  unint64_t *v30;
  unint64_t v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  unint64_t v37;
  std::__shared_weak_count *v38;
  unint64_t *v39;
  unint64_t v40;
  unint64_t *v41;
  unint64_t v42;
  unint64_t *v43;
  unint64_t v44;
  char *v45;
  char *v46;
  const char *v47;
  char *v48;
  const char *v49;
  _QWORD *v50;
  _QWORD *v51;
  int v52;
  int v53;
  int v54;
  os_unfair_lock_s *v55;
  int v56;
  __int128 v57;
  uint64_t v58;
  std::__shared_weak_count *v59;
  void *__p[2];
  char v61;
  void *v62[2];
  char v63;
  uint8_t buf[4];
  _QWORD *v65;
  __int16 v66;
  int v67;
  __int16 v68;
  _QWORD *v69;
  __int16 v70;
  int v71;
  __int16 v72;
  void **v73;
  __int16 v74;
  int v75;
  __int16 v76;
  int v77;
  __int16 v78;
  void **v79;
  __int16 v80;
  int v81;
  __int16 v82;
  int v83;
  uint64_t v84;

  v84 = *MEMORY[0x1E0C80C00];
  v6 = (os_unfair_lock_s *)(a1 + 152);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 152));
  v7 = (os_unfair_lock_s *)(a1 + 112);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 112));
  v10 = *(char **)(a1 + 80);
  v8 = *(std::__shared_weak_count **)(a1 + 88);
  v9 = (__int128 *)(a1 + 80);
  if (v8)
  {
    p_shared_owners = (unint64_t *)&v8->__shared_owners_;
    do
      v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }
  v14 = *(_DWORD **)(a1 + 96);
  v13 = *(std::__shared_weak_count **)(a1 + 104);
  if (v13)
  {
    v15 = (unint64_t *)&v13->__shared_owners_;
    do
      v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 112));
  v17 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a2 + 24))(*a2);
  v18 = (_DWORD *)*a3;
  if (v17 != *(_DWORD *)(*a3 + 68))
  {
    v45 = __si_assert_copy_extra_268();
    v46 = v45;
    v47 = "";
    if (v45)
      v47 = v45;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2381, "newQuantizer->count() == newPartitions->nPartitions()", v47);
LABEL_64:
    free(v46);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  if (*(_DWORD *)(*(_QWORD *)(a1 + 48) + 40) != v18[18])
  {
    v48 = __si_assert_copy_extra_268();
    v46 = v48;
    v49 = "";
    if (v48)
      v49 = v48;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2382, "vectors->count() == newPartitions->nVectors()", v49);
    goto LABEL_64;
  }
  if (v10 && v14)
  {
    v56 = *__error();
    v19 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      v20 = v10 + 8;
      if (v10[31] < 0)
        v20 = (_QWORD *)*v20;
      v51 = v20;
      v21 = (*(uint64_t (**)(char *))(*(_QWORD *)v10 + 16))(v10);
      v22 = (_QWORD *)(*a2 + 8);
      v55 = v6;
      v54 = v21;
      if (*(char *)(*a2 + 31) < 0)
        v22 = (_QWORD *)*v22;
      v50 = v22;
      v53 = (*(uint64_t (**)(_QWORD))(*(_QWORD *)*a2 + 16))(*a2);
      v23 = v62;
      (*(void (**)(void **__return_ptr, _DWORD *))(*(_QWORD *)v14 + 144))(v62, v14);
      if (v63 < 0)
        v23 = (void **)v62[0];
      v24 = v14[18];
      v52 = v14[17];
      (*(void (**)(void **__return_ptr))(*(_QWORD *)*a3 + 144))(__p);
      v25 = __p;
      if (v61 < 0)
        v25 = (void **)__p[0];
      v26 = *(_DWORD *)(*a3 + 68);
      v27 = *(_DWORD *)(*a3 + 72);
      *(_DWORD *)buf = 136317442;
      v65 = v51;
      v66 = 1024;
      v67 = v54;
      v68 = 2080;
      v69 = v50;
      v70 = 1024;
      v71 = v53;
      v72 = 2080;
      v73 = v23;
      v74 = 1024;
      v75 = v24;
      v76 = 1024;
      v77 = v52;
      v78 = 2080;
      v79 = v25;
      v80 = 1024;
      v81 = v27;
      v82 = 1024;
      v83 = v26;
      _os_log_impl(&dword_1B8270000, v19, OS_LOG_TYPE_DEFAULT, "Replace quantizer %s(%u) -> %s(%u), partitions %s(%u/%u) -> %s(%u/%u)", buf, 0x4Eu);
      if (v61 < 0)
        operator delete(__p[0]);
      v6 = v55;
      if (v63 < 0)
        operator delete(v62[0]);
    }
    *__error() = v56;
    v18 = (_DWORD *)*a3;
  }
  if ((*(unsigned int (**)(_DWORD *))(*(_QWORD *)v18 + 24))(v18))
    v28 = v14 == 0;
  else
    v28 = 1;
  if (!v28 && (*(unsigned int (**)(_DWORD *))(*(_QWORD *)v14 + 24))(v14))
    (*(void (**)(_QWORD, _DWORD *))(*(_QWORD *)*a3 + 168))(*a3, v14);
  v29 = a2[1];
  *(_QWORD *)&v57 = *a2;
  *((_QWORD *)&v57 + 1) = v29;
  if (v29)
  {
    v30 = (unint64_t *)(v29 + 8);
    do
      v31 = __ldxr(v30);
    while (__stxr(v31 + 1, v30));
  }
  v32 = (std::__shared_weak_count *)a3[1];
  v58 = *a3;
  v59 = v32;
  if (v32)
  {
    v33 = (unint64_t *)&v32->__shared_owners_;
    do
      v34 = __ldxr(v33);
    while (__stxr(v34 + 1, v33));
  }
  os_unfair_lock_lock(v7);
  std::swap[abi:nn180100]<IVFVectorIndexTemplate<float,768>::QuantizerPartitions>(v9, &v57);
  os_unfair_lock_unlock(v7);
  v35 = v59;
  if (v59)
  {
    v36 = (unint64_t *)&v59->__shared_owners_;
    do
      v37 = __ldaxr(v36);
    while (__stlxr(v37 - 1, v36));
    if (!v37)
    {
      ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
      std::__shared_weak_count::__release_weak(v35);
    }
  }
  v38 = (std::__shared_weak_count *)*((_QWORD *)&v57 + 1);
  if (*((_QWORD *)&v57 + 1))
  {
    v39 = (unint64_t *)(*((_QWORD *)&v57 + 1) + 8);
    do
      v40 = __ldaxr(v39);
    while (__stlxr(v40 - 1, v39));
    if (!v40)
    {
      ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
      std::__shared_weak_count::__release_weak(v38);
    }
  }
  os_unfair_lock_unlock(v6);
  if (v13)
  {
    v41 = (unint64_t *)&v13->__shared_owners_;
    do
      v42 = __ldaxr(v41);
    while (__stlxr(v42 - 1, v41));
    if (!v42)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  if (v8)
  {
    v43 = (unint64_t *)&v8->__shared_owners_;
    do
      v44 = __ldaxr(v43);
    while (__stlxr(v44 - 1, v43));
    if (!v44)
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
}

_QWORD *IVFVectorIndexTemplate<float,512>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::~IVFVectorIndexRoot_s(_QWORD *a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;
  std::__shared_weak_count *v8;
  unint64_t *v9;
  unint64_t v10;
  std::__shared_weak_count *v11;
  unint64_t *v12;
  unint64_t v13;

  *a1 = &off_1E6E34518;
  v2 = (std::__shared_weak_count *)a1[13];
  if (!v2)
    goto LABEL_5;
  p_shared_owners = (unint64_t *)&v2->__shared_owners_;
  do
    v4 = __ldaxr(p_shared_owners);
  while (__stlxr(v4 - 1, p_shared_owners));
  if (!v4)
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    v5 = (std::__shared_weak_count *)a1[11];
    if (!v5)
      goto LABEL_11;
  }
  else
  {
LABEL_5:
    v5 = (std::__shared_weak_count *)a1[11];
    if (!v5)
      goto LABEL_11;
  }
  v6 = (unint64_t *)&v5->__shared_owners_;
  do
    v7 = __ldaxr(v6);
  while (__stlxr(v7 - 1, v6));
  if (!v7)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
LABEL_11:
  v8 = (std::__shared_weak_count *)a1[9];
  if (!v8)
    goto LABEL_15;
  v9 = (unint64_t *)&v8->__shared_owners_;
  do
    v10 = __ldaxr(v9);
  while (__stlxr(v10 - 1, v9));
  if (!v10)
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
    v11 = (std::__shared_weak_count *)a1[7];
    if (!v11)
      return a1;
  }
  else
  {
LABEL_15:
    v11 = (std::__shared_weak_count *)a1[7];
    if (!v11)
      return a1;
  }
  v12 = (unint64_t *)&v11->__shared_owners_;
  do
    v13 = __ldaxr(v12);
  while (__stlxr(v13 - 1, v12));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  return a1;
}

uint64_t IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,512>::~IVFVectorIndexInstance(uint64_t a1)
{
  *(_QWORD *)a1 = off_1E6E343C0;
  IVFVectorIndexTemplate<float,512>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::~IVFVectorIndexRoot_s((_QWORD *)(a1 + 48));
  *(_QWORD *)a1 = off_1E6E30C80;
  if (*(char *)(a1 + 47) < 0)
    operator delete(*(void **)(a1 + 24));
  return a1;
}

void IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,512>::~IVFVectorIndexInstance(uint64_t a1)
{
  *(_QWORD *)a1 = off_1E6E343C0;
  IVFVectorIndexTemplate<float,512>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::~IVFVectorIndexRoot_s((_QWORD *)(a1 + 48));
  *(_QWORD *)a1 = off_1E6E30C80;
  if (*(char *)(a1 + 47) < 0)
    operator delete(*(void **)(a1 + 24));
  JUMPOUT(0x1BCCB06A4);
}

uint64_t IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,512>::nVectors(uint64_t a1)
{
  return IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nVectors(a1 + 48);
}

uint64_t IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,512>::nPartitions(uint64_t a1)
{
  return IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nPartitions(a1 + 48);
}

uint64_t IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,512>::allExist(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  float v9;
  uint64_t v10;
  int v11;
  NSObject *v12;
  char *v14;
  char *v15;
  const char *v16;
  uint8_t buf[4];
  double v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if ((_DWORD)a3)
  {
    v5 = a1 + 48;
    v6 = a3;
    if (a3 <= 0x3E8)
    {
      while (IVFVectorIndexTemplate<float,512>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::exists(v5, a2))
      {
        a2 += 2048;
        if (!--v6)
          return a3;
      }
    }
    else
    {
      v7 = 0;
      v8 = a3 / 0xA;
      v9 = 1.0 / (float)a3;
      while (1)
      {
        v10 = v7 + 1;
        if (!(((int)v7 + 1) % v8))
        {
          v11 = *__error();
          v12 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 134217984;
            v18 = (float)((float)((float)v7 * 100.0) * v9);
            _os_log_impl(&dword_1B8270000, v12, OS_LOG_TYPE_DEFAULT, "allExist: %.0f%%", buf, 0xCu);
          }
          *__error() = v11;
        }
        if (!IVFVectorIndexTemplate<float,512>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::exists(v5, a2))break;
        a2 += 2048;
        ++v7;
        if (a3 == v10)
          return a3;
      }
    }
    v14 = __si_assert_copy_extra_268();
    v15 = v14;
    v16 = "";
    if (v14)
      v16 = v14;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3151, "false", v16);
    free(v15);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  return a3;
}

BOOL IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,512>::validAddress(uint64_t a1, unint64_t a2)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 96) + 32);
  v3 = *(unsigned int *)(v2 + 64);
  if ((int)v3 < 1)
  {
    v8 = -1;
  }
  else
  {
    v4 = 11;
    do
    {
      v5 = *(_QWORD **)(v2 + 8 * v4);
      if (v5 && (v6 = v5[1], v6 + 1 >= 2) && v6 <= a2 && (v7 = v5[2], v6 - v7 + v5[3] > a2))
        v8 = a2 - v6 + v7;
      else
        v8 = -1;
      if (v4 - 10 >= v3)
        break;
      ++v4;
    }
    while (v8 == -1);
  }
  return v8 != -1;
}

uint64_t IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,512>::shadow(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  os_unfair_lock_s *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t *v17;
  unint64_t v18;

  v6 = (os_unfair_lock_s *)(a1 + 160);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 160));
  v7 = *(std::__shared_weak_count **)(a1 + 136);
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
  }
  v11 = *(_QWORD *)(a1 + 144);
  v10 = *(std::__shared_weak_count **)(a1 + 152);
  if (v10)
  {
    v12 = (unint64_t *)&v10->__shared_owners_;
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  os_unfair_lock_unlock(v6);
  (*(void (**)(uint64_t, uint64_t, _DWORD *))(*(_QWORD *)v11 + 160))(v11, a2, a3);
  v14 = vi_onefixedsize_disk_allocator::shadow(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 32), a2, a3);
  if (!v10)
    goto LABEL_11;
  v15 = (unint64_t *)&v10->__shared_owners_;
  do
    v16 = __ldaxr(v15);
  while (__stlxr(v16 - 1, v15));
  if (!v16)
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
    if (!v7)
      return v14;
  }
  else
  {
LABEL_11:
    if (!v7)
      return v14;
  }
  v17 = (unint64_t *)&v7->__shared_owners_;
  do
    v18 = __ldaxr(v17);
  while (__stlxr(v18 - 1, v17));
  if (!v18)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  return v14;
}

_DWORD *IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,512>::bulkInsertForTest(_DWORD *result, char *a2, unsigned int *a3, unsigned int a4, unsigned int *a5)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  float v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  NSObject *v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  uint8_t buf[4];
  double v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (a4)
  {
    v8 = (uint64_t)(result + 12);
    v9 = a4;
    if (a4 <= 0x3E8)
    {
      do
      {
        v19 = *a5++;
        v18 = v19;
        v20 = *a3++;
        result = IVFVectorIndexTemplate<float,512>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::lookupForInsert(v8, v18, a2, 0xFFFFFFFFLL, 0, 3.4028e38);
        *((_QWORD *)result + 256) = v20;
        a2 += 2048;
        --v9;
      }
      while (v9);
    }
    else
    {
      v10 = 0;
      v11 = a4 / 0xA;
      v12 = 1.0 / (float)a4;
      do
      {
        v15 = v10 + 1;
        if (!(((int)v10 + 1) % v11))
        {
          v16 = *__error();
          v17 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 134217984;
            v22 = (float)((float)((float)v10 * 100.0) * v12);
            _os_log_impl(&dword_1B8270000, v17, OS_LOG_TYPE_DEFAULT, "bulkInsertForTest: %.0f%%", buf, 0xCu);
          }
          *__error() = v16;
        }
        v13 = a5[v10];
        v14 = a3[v10];
        result = IVFVectorIndexTemplate<float,512>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::lookupForInsert(v8, v13, a2, 0xFFFFFFFFLL, 0, 3.4028e38);
        *((_QWORD *)result + 256) = v14;
        a2 += 2048;
        v10 = v15;
      }
      while (v9 != v15);
    }
  }
  return result;
}

void IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,512>::insertVector(_DWORD *a1, int a2, unsigned int a3, void *a4, int a5, int a6)
{
  char *v6;
  char *v7;
  const char *v8;
  char *v9;
  const char *v10;

  if (a1[2] == a2
    && a6 <= 2
    && a1[3] == vector_dimension_vec_sizes_10743[a5]
    && vector_size_elem_sizes_10742[a6] == a1[4])
  {
    IVFVectorIndexTemplate<float,512>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::lookupForInsert((uint64_t)(a1 + 12), a3, a4, 0xFFFFFFFFLL, 0, 3.4028e38);
    v6 = __si_assert_copy_extra_268();
    v7 = v6;
    v8 = "";
    if (v6)
      v8 = v6;
    __message_assert("%s:%u: failed assertion '%s' %s ", "VectorIndexSupport.hh", 2636, "0", v8);
  }
  else
  {
    v9 = __si_assert_copy_extra_268();
    v7 = v9;
    v10 = "";
    if (v9)
      v10 = v9;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3070, "compatible", v10);
  }
  free(v7);
  if (__valid_fs(-1))
  {
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  MEMORY[0xC00] = -559038737;
  abort();
}

uint64_t IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,512>::insertForMerge(uint64_t a1, int a2, int a3, unsigned int a4, void *a5, int a6, int a7, uint64_t a8, float a9, unsigned int a10)
{
  char *v11;
  char *v12;
  const char *v13;

  if (*(_DWORD *)(a1 + 8) != a2
    || *(unsigned __int16 *)(a1 + 20) != a3
    || a7 > 2
    || *(_DWORD *)(a1 + 12) != vector_dimension_vec_sizes_10743[a6]
    || vector_size_elem_sizes_10742[a7] != *(_DWORD *)(a1 + 16))
  {
    v11 = __si_assert_copy_extra_268();
    v12 = v11;
    v13 = "";
    if (v11)
      v13 = v11;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3070, "compatible", v13);
    free(v12);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  IVFVectorIndexTemplate<float,512>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::insertForCompact(a1 + 48, a4, a5, a8, a10, a9);
  return 1;
}

_DWORD *IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,512>::insertForTest(_DWORD *a1, int a2, unsigned int a3, void *a4, int a5, int a6, unsigned int a7)
{
  uint64_t v7;
  _DWORD *result;
  char *v9;
  char *v10;
  const char *v11;

  if (a1[2] != a2
    || a6 > 2
    || a1[3] != vector_dimension_vec_sizes_10743[a5]
    || vector_size_elem_sizes_10742[a6] != a1[4])
  {
    v9 = __si_assert_copy_extra_268();
    v10 = v9;
    v11 = "";
    if (v9)
      v11 = v9;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3070, "compatible", v11);
    free(v10);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v7 = a7;
  result = IVFVectorIndexTemplate<float,512>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::lookupForInsert((uint64_t)(a1 + 12), a3, a4, 0xFFFFFFFFLL, 0, 3.4028e38);
  *((_QWORD *)result + 256) = v7;
  return result;
}

void IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,512>::train(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v3;
  unint64_t v4;
  char *v7;
  char *v8;
  unint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  int64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  _BYTE *v19;
  _QWORD *v20;
  char *v21;
  unint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  _OWORD *v26;
  char *v27;
  uint64_t v28;
  __int128 v29;
  char *v30;
  char *v31;
  const char *v32;
  char *v33;
  char *v34;
  const char *v35;
  char *v36;
  const char *v37;
  uint64_t v38;
  void *__p;
  _QWORD *v40;
  char *v41;

  v3 = *(_QWORD **)a2;
  v2 = *(_QWORD *)(a2 + 8);
  v4 = v2 - *(_QWORD *)a2;
  if (v2 == *(_QWORD *)a2)
  {
    v33 = __si_assert_copy_extra_268();
    v34 = v33;
    v35 = "";
    if (v33)
      v35 = v33;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3170, "vi.size() > 0", v35);
    goto LABEL_53;
  }
  if (*v3 != a1)
  {
    v36 = __si_assert_copy_extra_268();
    v34 = v36;
    v37 = "";
    if (v36)
      v37 = v36;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3171, "this == vi[0]", v37);
LABEL_53:
    free(v34);
    if (__valid_fs(-1))
      v38 = 2989;
    else
      v38 = 3072;
    *(_DWORD *)v38 = -559038737;
LABEL_57:
    abort();
  }
  v7 = (char *)operator new(8uLL);
  *(_QWORD *)v7 = a1 + 48;
  v8 = v7 + 8;
  v40 = v7 + 8;
  v41 = v7 + 8;
  __p = v7;
  if (v4 < 9)
    goto LABEL_39;
  v9 = 1;
  do
  {
    v11 = v3[v9];
    if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(v11 + 8)
      || *(unsigned __int16 *)(a1 + 20) != *(unsigned __int16 *)(v11 + 20)
      || *(_DWORD *)(a1 + 12) != *(_DWORD *)(v11 + 12)
      || *(_DWORD *)(a1 + 16) != *(_DWORD *)(v11 + 16))
    {
      v30 = __si_assert_copy_extra_268();
      v31 = v30;
      v32 = "";
      if (v30)
        v32 = v30;
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3075, "compatible", v32);
      free(v31);
      if (__valid_fs(-1))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
    v12 = v11 + 48;
    if (v8 < v41)
    {
      *(_QWORD *)v8 = v12;
      v10 = v8 + 8;
      goto LABEL_6;
    }
    v13 = (char *)__p;
    v14 = v8 - (_BYTE *)__p;
    v15 = (v8 - (_BYTE *)__p) >> 3;
    v16 = v15 + 1;
    if ((unint64_t)(v15 + 1) >> 61)
      goto LABEL_57;
    v17 = v41 - (_BYTE *)__p;
    if ((v41 - (_BYTE *)__p) >> 2 > v16)
      v16 = v17 >> 2;
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8)
      v18 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v18 = v16;
    if (v18)
    {
      if (v18 >> 61)
        std::__throw_bad_array_new_length[abi:nn180100]();
      v19 = operator new(8 * v18);
    }
    else
    {
      v19 = 0;
    }
    v20 = &v19[8 * v15];
    v21 = &v19[8 * v18];
    *v20 = v12;
    v10 = v20 + 1;
    if (v8 == v13)
    {
      __p = &v19[8 * v15];
      v41 = v21;
LABEL_33:
      operator delete(v8);
      goto LABEL_6;
    }
    v22 = v8 - 8 - v13;
    if (v22 > 0x167
      && &v19[v14 - 8 - (v22 & 0xFFFFFFFFFFFFFFF8)] <= &v19[v14 - 8]
      && &v8[-(v22 & 0xFFFFFFFFFFFFFFF8) - 8] <= v8 - 8
      && (unint64_t)(v8 - v19 - v14) >= 0x20)
    {
      v25 = (v22 >> 3) + 1;
      v23 = &v8[-8 * (v25 & 0x3FFFFFFFFFFFFFFCLL)];
      v26 = &v19[8 * v15 - 16];
      v27 = v8 - 16;
      v28 = v25 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v29 = *(_OWORD *)v27;
        *(v26 - 1) = *((_OWORD *)v27 - 1);
        *v26 = v29;
        v26 -= 2;
        v27 -= 32;
        v28 -= 4;
      }
      while (v28);
      v20 -= v25 & 0x3FFFFFFFFFFFFFFCLL;
      if (v25 == (v25 & 0x3FFFFFFFFFFFFFFCLL))
        goto LABEL_30;
    }
    else
    {
      v23 = v8;
    }
    do
    {
      v24 = *((_QWORD *)v23 - 1);
      v23 -= 8;
      *--v20 = v24;
    }
    while (v23 != v13);
    v13 = (char *)__p;
LABEL_30:
    __p = v20;
    v41 = v21;
    v8 = v13;
    if (v13)
      goto LABEL_33;
LABEL_6:
    v40 = v10;
    ++v9;
    v3 = *(_QWORD **)a2;
    v8 = (char *)v10;
  }
  while (v9 < (uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 3);
  v7 = (char *)__p;
LABEL_39:
  IVFVectorIndexTemplate<float,512>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::train<vi_onefixedsize_disk_allocator>(*(_QWORD *)(a1 + 112), *(std::__shared_weak_count **)(a1 + 120), (uint64_t)&__p);
  if (v7)
    operator delete(v7);
}

uint64_t IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,512>::mergeUpdateSet(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v7;
  NSObject *v8;
  os_log_type_t v9;
  int v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  float v18;
  unsigned int v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  _QWORD *v24;
  _DWORD *v25;
  uint64_t v26;
  uint64_t result;
  std::__shared_weak_count *v28;
  unint64_t *p_shared_owners;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  char *v34;
  char *v35;
  const char *v36;
  char *v37;
  const char *v38;
  _DWORD v39[4];
  void *__src;
  uint64_t v41;
  uint8_t buf[2048];
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)
    || *(unsigned __int16 *)(a1 + 20) != *(unsigned __int16 *)(a2 + 20)
    || *(_DWORD *)(a1 + 12) != *(_DWORD *)(a2 + 12)
    || *(_DWORD *)(a1 + 16) != *(_DWORD *)(a2 + 16))
  {
    v37 = __si_assert_copy_extra_268();
    v35 = v37;
    v38 = "";
    if (v37)
      v38 = v37;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3075, "compatible", v38);
LABEL_38:
    free(v35);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v7 = *__error();
  v8 = _SILogForLogForCategory(16);
  v9 = 2 * (dword_1EF19FCCC < 4);
  if (os_log_type_enabled(v8, v9))
  {
    v10 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
    v11 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
    v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
    v13 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 24))(a2);
    *(_DWORD *)buf = 67109888;
    *(_DWORD *)&buf[4] = v10;
    *(_WORD *)&buf[8] = 1024;
    *(_DWORD *)&buf[10] = v11;
    *(_WORD *)&buf[14] = 1024;
    *(_DWORD *)&buf[16] = v12;
    *(_WORD *)&buf[20] = 1024;
    *(_DWORD *)&buf[22] = v13;
    _os_log_impl(&dword_1B8270000, v8, v9, "mergeUpdateSet(termIds) %u vectors in %u partitions and %u vectors in %u partitions", buf, 0x1Au);
  }
  *__error() = v7;
  v14 = a2 + 48;
  v15 = operator new(0x10uLL);
  *(_QWORD *)&buf[8] = v15 + 2;
  *(_QWORD *)&buf[16] = v15 + 2;
  *v15 = a1 + 48;
  v15[1] = v14;
  *(_QWORD *)buf = v15;
  IVFVectorIndexTemplate<float,512>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::train<vi_onefixedsize_disk_allocator>(*(_QWORD *)(a1 + 112), *(std::__shared_weak_count **)(a1 + 120), (uint64_t)buf);
  operator delete(v15);
  v16 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::enumerator(v14);
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::beginMerge(a1 + 48);
  while (1)
  {
    IVFVectorIndexTemplate<float,512>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::enumerator_s::next((uint64_t)v39, v16);
    if (!__src)
      break;
    v17 = v39[0];
    v18 = *(float *)&v39[1];
    v19 = v39[2];
    v20 = v41;
    memcpy(buf, __src, sizeof(buf));
    v22 = *(_QWORD *)(a4 + 8);
    v21 = *(_QWORD *)(a4 + 16);
    v23 = v22 + 1;
    if (v22 + 1 < v21)
    {
      v24 = *(_QWORD **)a4;
      goto LABEL_17;
    }
    if (v21)
    {
      if (v23 >= v21)
        goto LABEL_14;
    }
    else
    {
      *(_QWORD *)(a4 + 16) = 1024;
      v21 = 1024;
      if (v23 >= 0x400)
      {
        do
LABEL_14:
          v21 *= 2;
        while (v23 >= v21);
        *(_QWORD *)(a4 + 16) = v21;
      }
    }
    v24 = malloc_type_realloc(*(void **)a4, 24 * v21, 0x10200409F4E64B8uLL);
    *(_QWORD *)a4 = v24;
    v22 = *(_QWORD *)(a4 + 8);
    v23 = v22 + 1;
LABEL_17:
    v24[3 * v22 + 1] = v20;
    *(_QWORD *)(a4 + 8) = v23;
    if (*(_DWORD *)(a1 + 204) == -1)
    {
      v34 = __si_assert_copy_extra_268();
      v35 = v34;
      v36 = "";
      if (v34)
        v36 = v34;
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2689, "mergeBeginVectorOffset < VECTOR_NOT_FOUND", v36);
      goto LABEL_38;
    }
    v25 = IVFVectorIndexTemplate<float,512>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::lookupForInsert(a1 + 48, v19, buf, v17, 0, v18);
    v26 = *((_QWORD *)v25 + 256);
    if (!v26)
    {
      v26 = (*(_DWORD *)(a4 + 24) + 1);
      *(_DWORD *)(a4 + 24) = v26;
      *((_QWORD *)v25 + 256) = v26;
    }
    *(_DWORD *)(*(_QWORD *)a4 + 24 * v22) = v26;
  }
  result = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::endMerge(a1 + 48);
  if (v16)
  {
    std::deque<std::shared_ptr<AnyPartitionStore::Enumerator>>::~deque[abi:nn180100](v16 + 32);
    v28 = *(std::__shared_weak_count **)(v16 + 24);
    if (v28)
    {
      p_shared_owners = (unint64_t *)&v28->__shared_owners_;
      do
        v30 = __ldaxr(p_shared_owners);
      while (__stlxr(v30 - 1, p_shared_owners));
      if (!v30)
      {
        ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
        std::__shared_weak_count::__release_weak(v28);
      }
    }
    v31 = *(std::__shared_weak_count **)(v16 + 8);
    if (v31)
    {
      v32 = (unint64_t *)&v31->__shared_owners_;
      do
        v33 = __ldaxr(v32);
      while (__stlxr(v33 - 1, v32));
      if (!v33)
      {
        ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
        std::__shared_weak_count::__release_weak(v31);
      }
    }
    return MEMORY[0x1BCCB06A4](v16, 0x10A0C40B50FE552);
  }
  return result;
}

int *IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,512>::mergeUpdateSet(int *result, uint64_t a2)
{
  int *v3;
  uint64_t v4;
  char *v5;
  char *v6;
  const char *v7;
  int v8;
  NSObject *v9;
  int v10;
  int v11;
  int v12;
  int v13;
  char *v14;
  const char *v15;
  uint8_t buf[4];
  int v17;
  __int16 v18;
  int v19;
  __int16 v20;
  int v21;
  __int16 v22;
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (result[2] != *(_DWORD *)(a2 + 8)
    || (v3 = result, *((unsigned __int16 *)result + 10) != *(unsigned __int16 *)(a2 + 20))
    || result[3] != *(_DWORD *)(a2 + 12)
    || result[4] != *(_DWORD *)(a2 + 16))
  {
    v5 = __si_assert_copy_extra_268();
    v6 = v5;
    v7 = "";
    if (v5)
      v7 = v5;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3075, "compatible", v7);
LABEL_11:
    free(v6);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  if (dword_1EF19FCCC >= 5)
  {
    v8 = *__error();
    v9 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      v10 = (*(uint64_t (**)(int *))(*(_QWORD *)v3 + 16))(v3);
      v11 = (*(uint64_t (**)(int *))(*(_QWORD *)v3 + 24))(v3);
      v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
      v13 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 24))(a2);
      *(_DWORD *)buf = 67109888;
      v17 = v10;
      v18 = 1024;
      v19 = v11;
      v20 = 1024;
      v21 = v12;
      v22 = 1024;
      v23 = v13;
      _os_log_impl(&dword_1B8270000, v9, OS_LOG_TYPE_DEFAULT, "mergeUpdateSet(DocID) %u vectors in %u partitions and %u vectors in %u partitions", buf, 0x1Au);
    }
    result = __error();
    *result = v8;
  }
  v4 = *(_QWORD *)(a2 + 80);
  if (*(_DWORD *)(v4 + 24))
  {
    IVFVectorIndexTemplate<float,512>::VectorStore<vi_onefixedsize_memory_allocator,vi_memory_postings>::Iterator::operator->(v4, 0);
    IVFVectorIndexTemplate<float,512>::VectorStore<vi_onefixedsize_memory_allocator,vi_memory_postings>::Iterator::operator->(v4, 0);
    IVFVectorIndexTemplate<float,512>::VectorStore<vi_onefixedsize_memory_allocator,vi_memory_postings>::Iterator::operator->(v4, 0);
    v14 = __si_assert_copy_extra_268();
    v6 = v14;
    v15 = "";
    if (v14)
      v15 = v14;
    __message_assert("%s:%u: failed assertion '%s' %s ", "VectorIndexSupport.hh", 2447, "0", v15);
    goto LABEL_11;
  }
  return result;
}

uint64_t IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,512>::mergeUpdateSetForTest(uint64_t a1, uint64_t a2)
{
  int v4;
  NSObject *v5;
  os_log_type_t v6;
  int v7;
  int v8;
  int v9;
  int v10;
  _QWORD *v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  _DWORD *v17;
  uint64_t v18;
  uint64_t result;
  std::__shared_weak_count *v20;
  unint64_t *p_shared_owners;
  unint64_t v22;
  std::__shared_weak_count *v23;
  unint64_t *v24;
  unint64_t v25;
  char *v26;
  char *v27;
  const char *v28;
  char *v29;
  const char *v30;
  uint8_t buf[8];
  _QWORD *v32;
  __int128 v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)
    || *(unsigned __int16 *)(a1 + 20) != *(unsigned __int16 *)(a2 + 20)
    || *(_DWORD *)(a1 + 12) != *(_DWORD *)(a2 + 12)
    || *(_DWORD *)(a1 + 16) != *(_DWORD *)(a2 + 16))
  {
    v26 = __si_assert_copy_extra_268();
    v27 = v26;
    v28 = "";
    if (v26)
      v28 = v26;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3075, "compatible", v28);
LABEL_32:
    free(v27);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v4 = *__error();
  v5 = _SILogForLogForCategory(16);
  v6 = 2 * (dword_1EF19FCCC < 4);
  if (os_log_type_enabled(v5, v6))
  {
    v7 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
    v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
    v9 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
    v10 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 24))(a2);
    *(_DWORD *)buf = 67109888;
    *(_DWORD *)&buf[4] = v7;
    LOWORD(v32) = 1024;
    *(_DWORD *)((char *)&v32 + 2) = v8;
    HIWORD(v32) = 1024;
    LODWORD(v33) = v9;
    WORD2(v33) = 1024;
    *(_DWORD *)((char *)&v33 + 6) = v10;
    _os_log_impl(&dword_1B8270000, v5, v6, "mergeUpdateSetForTest %u vectors in %u partitions and %u vectors in %u partitions", buf, 0x1Au);
  }
  *__error() = v4;
  v11 = operator new(0x10uLL);
  v32 = v11 + 2;
  *(_QWORD *)&v33 = v11 + 2;
  *v11 = a1 + 48;
  v11[1] = a2 + 48;
  *(_QWORD *)buf = v11;
  IVFVectorIndexTemplate<float,512>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::train<vi_onefixedsize_disk_allocator>(*(_QWORD *)(a1 + 112), *(std::__shared_weak_count **)(a1 + 120), (uint64_t)buf);
  operator delete(v11);
  v12 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::enumerator(a2 + 48);
  v13 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  v14 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::beginMerge(a1 + 48);
  v15 = 0;
  while (1)
  {
    IVFVectorIndexTemplate<float,512>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::enumerator_s::next((uint64_t)buf, v12);
    if (!(_QWORD)v33)
      break;
    v16 = *(unsigned int *)(*((_QWORD *)&v33 + 1) + 8);
    v17 = IVFVectorIndexTemplate<float,512>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::lookupForInsert(a1 + 48, v32, (void *)v33, *(unsigned int *)buf, 0, *(float *)&buf[4]);
    v18 = *((_QWORD *)v17 + 256);
    *((_QWORD *)v17 + 256) = v16;
    if (v18)
      ++v15;
  }
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::endMerge(a1 + 48);
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  if ((_DWORD)result + v15 != v14 + v13)
  {
    v29 = __si_assert_copy_extra_268();
    v27 = v29;
    v30 = "";
    if (v29)
      v30 = v29;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3267, "nVectors() + dup == old + added", v30);
    goto LABEL_32;
  }
  if (v12)
  {
    std::deque<std::shared_ptr<AnyPartitionStore::Enumerator>>::~deque[abi:nn180100](v12 + 32);
    v20 = *(std::__shared_weak_count **)(v12 + 24);
    if (v20)
    {
      p_shared_owners = (unint64_t *)&v20->__shared_owners_;
      do
        v22 = __ldaxr(p_shared_owners);
      while (__stlxr(v22 - 1, p_shared_owners));
      if (!v22)
      {
        ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
        std::__shared_weak_count::__release_weak(v20);
      }
    }
    v23 = *(std::__shared_weak_count **)(v12 + 8);
    if (v23)
    {
      v24 = (unint64_t *)&v23->__shared_owners_;
      do
        v25 = __ldaxr(v24);
      while (__stlxr(v25 - 1, v24));
      if (!v25)
      {
        ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
        std::__shared_weak_count::__release_weak(v23);
      }
    }
    return MEMORY[0x1BCCB06A4](v12, 0x10A0C40B50FE552);
  }
  return result;
}

uint64_t IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,512>::mergeIndexForTest(uint64_t a1, uint64_t a2)
{
  int v4;
  NSObject *v5;
  os_log_type_t v6;
  float v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  _DWORD *v16;
  uint64_t v17;
  uint64_t result;
  std::__shared_weak_count *v19;
  unint64_t *p_shared_owners;
  unint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  char *v25;
  char *v26;
  const char *v27;
  char *v28;
  const char *v29;
  uint8_t buf[4];
  float v31;
  _BYTE v32[6];
  __int16 v33;
  __int128 v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)
    || *(unsigned __int16 *)(a1 + 20) != *(unsigned __int16 *)(a2 + 20)
    || *(_DWORD *)(a1 + 12) != *(_DWORD *)(a2 + 12)
    || *(_DWORD *)(a1 + 16) != *(_DWORD *)(a2 + 16))
  {
    v25 = __si_assert_copy_extra_268();
    v26 = v25;
    v27 = "";
    if (v25)
      v27 = v25;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3075, "compatible", v27);
LABEL_32:
    free(v26);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v4 = *__error();
  v5 = _SILogForLogForCategory(16);
  v6 = 2 * (dword_1EF19FCCC < 4);
  if (os_log_type_enabled(v5, v6))
  {
    LODWORD(v7) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
    v8 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
    v9 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
    v10 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 24))(a2);
    *(_DWORD *)buf = 67109888;
    v31 = v7;
    *(_WORD *)v32 = 1024;
    *(_DWORD *)&v32[2] = v8;
    v33 = 1024;
    LODWORD(v34) = v9;
    WORD2(v34) = 1024;
    *(_DWORD *)((char *)&v34 + 6) = v10;
    _os_log_impl(&dword_1B8270000, v5, v6, "mergeIndexForTest %u vectors in %u partitions and %u vectors in %u partitions", buf, 0x1Au);
  }
  *__error() = v4;
  v11 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::enumerator(a2 + 48);
  v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  v13 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::beginMerge(a1 + 48);
  v14 = 0;
  while (1)
  {
    IVFVectorIndexTemplate<float,512>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::enumerator_s::next((uint64_t)buf, v11);
    if (!(_QWORD)v34)
      break;
    v15 = **((_QWORD **)&v34 + 1);
    v16 = IVFVectorIndexTemplate<float,512>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::lookupForInsert(a1 + 48, *(unsigned int *)v32, (void *)v34, *(unsigned int *)buf, 0, v31);
    v17 = *((_QWORD *)v16 + 256);
    *((_QWORD *)v16 + 256) = v15;
    if (v17)
      ++v14;
  }
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::endMerge(a1 + 48);
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  if ((_DWORD)result + v14 != v13 + v12)
  {
    v28 = __si_assert_copy_extra_268();
    v26 = v28;
    v29 = "";
    if (v28)
      v29 = v28;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3281, "nVectors() + dup == old + added", v29);
    goto LABEL_32;
  }
  if (v11)
  {
    std::deque<std::shared_ptr<AnyPartitionStore::Enumerator>>::~deque[abi:nn180100](v11 + 32);
    v19 = *(std::__shared_weak_count **)(v11 + 24);
    if (v19)
    {
      p_shared_owners = (unint64_t *)&v19->__shared_owners_;
      do
        v21 = __ldaxr(p_shared_owners);
      while (__stlxr(v21 - 1, p_shared_owners));
      if (!v21)
      {
        ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
        std::__shared_weak_count::__release_weak(v19);
      }
    }
    v22 = *(std::__shared_weak_count **)(v11 + 8);
    if (v22)
    {
      v23 = (unint64_t *)&v22->__shared_owners_;
      do
        v24 = __ldaxr(v23);
      while (__stlxr(v24 - 1, v23));
      if (!v24)
      {
        ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
        std::__shared_weak_count::__release_weak(v22);
      }
    }
    return MEMORY[0x1BCCB06A4](v11, 0x10A0C40B50FE552);
  }
  return result;
}

void IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,512>::dump(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  os_unfair_lock_s *v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  std::__shared_weak_count *v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  uint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  unint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  std::__shared_weak_count *v27;
  unint64_t *v28;
  unint64_t v29;
  std::__shared_weak_count *v30;
  unint64_t *v31;
  unint64_t v32;
  unint64_t *v33;
  unint64_t v34;
  unint64_t *v35;
  unint64_t v36;
  _QWORD v37[2];
  uint64_t (*v38)(uint64_t, uint64_t, BOOL *);
  void *v39;
  uint64_t v40;
  uint64_t v41;
  _QWORD v42[2];
  uint64_t v43;
  std::__shared_weak_count *v44;
  __int128 v45;
  __int128 v46;
  _OWORD v47[3];
  __int128 v48;
  __int128 v49;
  char v50;
  __int128 v51;
  __int128 v52;

  v9 = (os_unfair_lock_s *)(a1 + 160);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 160));
  v10 = *(std::__shared_weak_count **)(a1 + 136);
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }
  v14 = *(_QWORD *)(a1 + 144);
  v13 = *(std::__shared_weak_count **)(a1 + 152);
  if (v13)
  {
    v15 = (unint64_t *)&v13->__shared_owners_;
    do
      v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
  }
  os_unfair_lock_unlock(v9);
  v46 = 0u;
  memset(v47, 0, sizeof(v47));
  v45 = 0u;
  v43 = v14;
  v44 = v13;
  if (v13)
  {
    v17 = (unint64_t *)&v13->__shared_owners_;
    do
      v18 = __ldxr(v17);
    while (__stxr(v18 + 1, v17));
  }
  v19 = *(_QWORD *)(a1 + 96);
  v20 = *(std::__shared_weak_count **)(a1 + 104);
  v42[0] = v19;
  v42[1] = v20;
  if (v20)
  {
    v21 = (unint64_t *)&v20->__shared_owners_;
    do
      v22 = __ldxr(v21);
    while (__stxr(v22 + 1, v21));
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::enumerator_s::enumerator_s((uint64_t)&v45, &v43, v42);
    do
      v23 = __ldaxr(v21);
    while (__stlxr(v23 - 1, v21));
    if (!v23)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
  else
  {
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::enumerator_s::enumerator_s((uint64_t)&v45, &v43, v42);
  }
  v24 = v44;
  if (v44)
  {
    v25 = (unint64_t *)&v44->__shared_owners_;
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }
  v37[0] = MEMORY[0x1E0C809B0];
  v37[1] = 0x40000000;
  v38 = ___ZNK22IVFVectorIndexTemplateIfLi512EE20IVFVectorIndexRoot_sI30vi_onefixedsize_disk_allocator16vi_disk_postingsE4dumpEbbPViPvU13block_pointerFbjPKvybjfE_block_invoke;
  v39 = &unk_1E6E34628;
  v40 = a6;
  v41 = a4;
  v51 = 0u;
  v52 = 0u;
  v50 = 0;
  do
  {
    IVFVectorIndexTemplate<float,512>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::enumerator_s::next((uint64_t)&v48, (uint64_t)&v45);
    v51 = v48;
    v52 = v49;
    if (!(_QWORD)v49)
      break;
    v38((uint64_t)v37, (uint64_t)&v51, (BOOL *)&v50);
  }
  while (!v50);
  std::deque<std::shared_ptr<AnyPartitionStore::Enumerator>>::~deque[abi:nn180100]((uint64_t)v47);
  v27 = (std::__shared_weak_count *)*((_QWORD *)&v46 + 1);
  if (!*((_QWORD *)&v46 + 1))
    goto LABEL_30;
  v28 = (unint64_t *)(*((_QWORD *)&v46 + 1) + 8);
  do
    v29 = __ldaxr(v28);
  while (__stlxr(v29 - 1, v28));
  if (!v29)
  {
    ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
    std::__shared_weak_count::__release_weak(v27);
    v30 = (std::__shared_weak_count *)*((_QWORD *)&v45 + 1);
    if (!*((_QWORD *)&v45 + 1))
      goto LABEL_36;
  }
  else
  {
LABEL_30:
    v30 = (std::__shared_weak_count *)*((_QWORD *)&v45 + 1);
    if (!*((_QWORD *)&v45 + 1))
      goto LABEL_36;
  }
  v31 = (unint64_t *)&v30->__shared_owners_;
  do
    v32 = __ldaxr(v31);
  while (__stlxr(v32 - 1, v31));
  if (!v32)
  {
    ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
    std::__shared_weak_count::__release_weak(v30);
  }
  if (!v13)
    goto LABEL_40;
LABEL_36:
  v33 = (unint64_t *)&v13->__shared_owners_;
  do
    v34 = __ldaxr(v33);
  while (__stlxr(v34 - 1, v33));
  if (!v34)
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
    if (!v10)
      return;
  }
  else
  {
LABEL_40:
    if (!v10)
      return;
  }
  v35 = (unint64_t *)&v10->__shared_owners_;
  do
    v36 = __ldaxr(v35);
  while (__stlxr(v36 - 1, v35));
  if (!v36)
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
}

void IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,512>::flush(uint64_t a1, uint64_t a2)
{
  IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::flush(a1 + 48, a2);
}

void IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,512>::compact(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __int128 *a5, uint64_t a6)
{
  int v10;
  NSObject *v11;
  os_log_type_t v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  uint64_t v17;
  _QWORD *v18;
  std::__shared_weak_count *v19;
  uint64_t v20;
  unint64_t *p_shared_owners;
  unint64_t v22;
  uint64_t v23;
  std::__shared_weak_count *v24;
  unint64_t *v25;
  unint64_t v26;
  unint64_t *v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t *v31;
  unint64_t v32;
  uint64_t v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  unint64_t v37;
  std::__shared_weak_count *v38;
  unint64_t *v39;
  unint64_t v40;
  std::__shared_weak_count *v41;
  unint64_t *v42;
  unint64_t v43;
  std::__shared_weak_count *v44;
  unint64_t *v45;
  unint64_t v46;
  unint64_t *v47;
  unint64_t v48;
  unint64_t *v49;
  unint64_t v50;
  char *v51;
  char *v52;
  const char *v53;
  char *v54;
  const char *v55;
  int v56;
  __int128 v59;
  __int128 v60;
  _QWORD v61[2];
  uint64_t v62;
  std::__shared_weak_count *v63;
  __int128 v64;
  __int128 v65;
  _OWORD v66[3];
  _QWORD v67[3];
  char v68;
  uint64_t v69[2];
  void *__p[3];
  __int128 v71;
  __int128 v72;
  char v73;
  __int128 v74;
  __int128 v75;
  uint8_t buf[8];
  uint64_t v77;
  __int128 v78;
  _QWORD *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  __int128 v84;
  __int128 v85;
  uint64_t v86;

  v86 = *MEMORY[0x1E0C80C00];
  v10 = *__error();
  v11 = _SILogForLogForCategory(16);
  v12 = 2 * (dword_1EF19FCCC < 4);
  if (os_log_type_enabled(v11, v12))
  {
    v56 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
    v13 = a4;
    v14 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
    v15 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
    v16 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 24))(a2);
    *(_DWORD *)buf = 67109888;
    *(_DWORD *)&buf[4] = v56;
    LOWORD(v77) = 1024;
    *(_DWORD *)((char *)&v77 + 2) = v14;
    a4 = v13;
    HIWORD(v77) = 1024;
    LODWORD(v78) = v15;
    WORD2(v78) = 1024;
    *(_DWORD *)((char *)&v78 + 6) = v16;
    _os_log_impl(&dword_1B8270000, v11, v12, "compact %u vectors in %u partitions and %u vectors in %u partitions", buf, 0x1Au);
  }
  *__error() = v10;
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)
    || *(unsigned __int16 *)(a1 + 20) != *(unsigned __int16 *)(a2 + 20)
    || *(_DWORD *)(a1 + 12) != *(_DWORD *)(a2 + 12)
    || *(_DWORD *)(a1 + 16) != *(_DWORD *)(a2 + 16))
  {
    v51 = __si_assert_copy_extra_268();
    v52 = v51;
    v53 = "";
    if (v51)
      v53 = v51;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3075, "compatible", v53);
LABEL_70:
    free(v52);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v59 = *a5;
  v60 = a5[1];
  v17 = a2 + 48;
  if (IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nVectors(a2 + 48))
  {
    v54 = __si_assert_copy_extra_268();
    v52 = v54;
    v55 = "";
    if (v54)
      v55 = v54;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2566, "target->nVectors() == 0", v55);
    goto LABEL_70;
  }
  v18 = operator new(8uLL);
  __p[0] = v18;
  *v18 = a1 + 48;
  __p[1] = v18 + 1;
  __p[2] = v18 + 1;
  IVFVectorIndexTemplate<float,512>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::train<vi_onefixedsize_disk_allocator>(*(_QWORD *)(a1 + 112), *(std::__shared_weak_count **)(a1 + 120), (uint64_t)__p);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 160));
  v20 = *(_QWORD *)(a1 + 128);
  v19 = *(std::__shared_weak_count **)(a1 + 136);
  if (v19)
  {
    p_shared_owners = (unint64_t *)&v19->__shared_owners_;
    do
      v22 = __ldxr(p_shared_owners);
    while (__stxr(v22 + 1, p_shared_owners));
  }
  v23 = *(_QWORD *)(a1 + 144);
  v24 = *(std::__shared_weak_count **)(a1 + 152);
  if (v24)
  {
    v25 = (unint64_t *)&v24->__shared_owners_;
    do
      v26 = __ldxr(v25);
    while (__stxr(v26 + 1, v25));
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 160));
  v69[0] = v20;
  v69[1] = (uint64_t)v19;
  if (v19)
  {
    v27 = (unint64_t *)&v19->__shared_owners_;
    v28 = a3;
    do
      v29 = __ldxr(v27);
    while (__stxr(v29 + 1, v27));
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::replaceQuantizer(v17, v69);
    do
      v30 = __ldaxr(v27);
    while (__stlxr(v30 - 1, v27));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
  else
  {
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::replaceQuantizer(v17, v69);
    v28 = a3;
  }
  v67[0] = 0;
  v67[1] = v67;
  v67[2] = 0x2000000000;
  v68 = 1;
  v65 = 0u;
  memset(v66, 0, sizeof(v66));
  v64 = 0u;
  v62 = v23;
  v63 = v24;
  if (v24)
  {
    v31 = (unint64_t *)&v24->__shared_owners_;
    do
      v32 = __ldxr(v31);
    while (__stxr(v32 + 1, v31));
  }
  v33 = *(_QWORD *)(a1 + 96);
  v34 = *(std::__shared_weak_count **)(a1 + 104);
  v61[0] = v33;
  v61[1] = v34;
  if (v34)
  {
    v35 = (unint64_t *)&v34->__shared_owners_;
    do
      v36 = __ldxr(v35);
    while (__stxr(v36 + 1, v35));
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::enumerator_s::enumerator_s((uint64_t)&v64, &v62, v61);
    do
      v37 = __ldaxr(v35);
    while (__stlxr(v37 - 1, v35));
    if (!v37)
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
  }
  else
  {
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::enumerator_s::enumerator_s((uint64_t)&v64, &v62, v61);
  }
  v38 = v63;
  if (v63)
  {
    v39 = (unint64_t *)&v63->__shared_owners_;
    do
      v40 = __ldaxr(v39);
    while (__stlxr(v40 - 1, v39));
    if (!v40)
    {
      ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
      std::__shared_weak_count::__release_weak(v38);
    }
  }
  *(_QWORD *)buf = MEMORY[0x1E0C809B0];
  v77 = 0x40000000;
  *(_QWORD *)&v78 = ___ZN22IVFVectorIndexTemplateIfLi512EE20IVFVectorIndexRoot_sI30vi_onefixedsize_disk_allocator16vi_disk_postingsE7compactIS2_EENSt3__19enable_ifIXsr13is_persistentIT_EE5valueEbE4typeEPS4_P12uint32_map_tP11TermIdStore18CICompactCallbacksPVi_block_invoke;
  *((_QWORD *)&v78 + 1) = &unk_1E6E34650;
  v79 = v67;
  v80 = v28;
  v81 = a4;
  v82 = v17;
  v83 = a6;
  v84 = v59;
  v85 = v60;
  v74 = 0u;
  v75 = 0u;
  v73 = 0;
  do
  {
    IVFVectorIndexTemplate<float,512>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::enumerator_s::next((uint64_t)&v71, (uint64_t)&v64);
    v74 = v71;
    v75 = v72;
    if (!(_QWORD)v72)
      break;
    ((void (*)(uint8_t *, __int128 *, char *))v78)(buf, &v74, &v73);
  }
  while (!v73);
  std::deque<std::shared_ptr<AnyPartitionStore::Enumerator>>::~deque[abi:nn180100]((uint64_t)v66);
  v41 = (std::__shared_weak_count *)*((_QWORD *)&v65 + 1);
  if (*((_QWORD *)&v65 + 1))
  {
    v42 = (unint64_t *)(*((_QWORD *)&v65 + 1) + 8);
    do
      v43 = __ldaxr(v42);
    while (__stlxr(v43 - 1, v42));
    if (!v43)
    {
      ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
      std::__shared_weak_count::__release_weak(v41);
    }
  }
  v44 = (std::__shared_weak_count *)*((_QWORD *)&v64 + 1);
  if (*((_QWORD *)&v64 + 1))
  {
    v45 = (unint64_t *)(*((_QWORD *)&v64 + 1) + 8);
    do
      v46 = __ldaxr(v45);
    while (__stlxr(v46 - 1, v45));
    if (!v46)
    {
      ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
      std::__shared_weak_count::__release_weak(v44);
    }
  }
  _Block_object_dispose(v67, 8);
  if (v24)
  {
    v47 = (unint64_t *)&v24->__shared_owners_;
    do
      v48 = __ldaxr(v47);
    while (__stlxr(v48 - 1, v47));
    if (!v48)
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }
  if (v19)
  {
    v49 = (unint64_t *)&v19->__shared_owners_;
    do
      v50 = __ldaxr(v49);
    while (__stlxr(v50 - 1, v49));
    if (!v50)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
  if (__p[0])
    operator delete(__p[0]);
}

void IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,512>::compactForTest(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6;
  NSObject *v7;
  os_log_type_t v8;
  int v9;
  int v10;
  int v11;
  int v12;
  char *v13;
  char *v14;
  const char *v15;
  uint8_t buf[4];
  int v17;
  __int16 v18;
  int v19;
  __int16 v20;
  int v21;
  __int16 v22;
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)
    || *(unsigned __int16 *)(a1 + 20) != *(unsigned __int16 *)(a2 + 20)
    || *(_DWORD *)(a1 + 12) != *(_DWORD *)(a2 + 12)
    || *(_DWORD *)(a1 + 16) != *(_DWORD *)(a2 + 16))
  {
    v13 = __si_assert_copy_extra_268();
    v14 = v13;
    v15 = "";
    if (v13)
      v15 = v13;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3075, "compatible", v15);
    free(v14);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v6 = *__error();
  v7 = _SILogForLogForCategory(16);
  v8 = 2 * (dword_1EF19FCCC < 4);
  if (os_log_type_enabled(v7, v8))
  {
    v9 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
    v10 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
    v11 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
    v12 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 24))(a2);
    *(_DWORD *)buf = 67109888;
    v17 = v9;
    v18 = 1024;
    v19 = v10;
    v20 = 1024;
    v21 = v11;
    v22 = 1024;
    v23 = v12;
    _os_log_impl(&dword_1B8270000, v7, v8, "compactForTest %u vectors in %u partitions and %u vectors in %u partitions", buf, 0x1Au);
  }
  *__error() = v6;
  IVFVectorIndexTemplate<float,512>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::compactForTest<vi_onefixedsize_disk_allocator>(a1 + 48, a2 + 48, a3);
}

void IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,512>::subvert(uint64_t a1, uint64_t a2)
{
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  uint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  char *v26;
  char *v27;
  const char *v28;

  if (*(_DWORD *)(a1 + 8) != *(_DWORD *)(a2 + 8)
    || *(unsigned __int16 *)(a1 + 20) != *(unsigned __int16 *)(a2 + 20)
    || *(_DWORD *)(a1 + 12) != *(_DWORD *)(a2 + 12)
    || *(_DWORD *)(a1 + 16) != *(_DWORD *)(a2 + 16))
  {
    v26 = __si_assert_copy_extra_268();
    v27 = v26;
    v28 = "";
    if (v26)
      v28 = v26;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3075, "compatible", v28);
    free(v27);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 160));
  v4 = *(std::__shared_weak_count **)(a1 + 136);
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  v8 = *(_QWORD *)(a1 + 144);
  v7 = *(std::__shared_weak_count **)(a1 + 152);
  if (v7)
  {
    v9 = (unint64_t *)&v7->__shared_owners_;
    do
      v10 = __ldxr(v9);
    while (__stxr(v10 + 1, v9));
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 160));
  if (v4)
  {
    v11 = (unint64_t *)&v4->__shared_owners_;
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 - 1, v11));
    if (!v12)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 160));
  v13 = *(std::__shared_weak_count **)(a2 + 136);
  if (v13)
  {
    v14 = (unint64_t *)&v13->__shared_owners_;
    do
      v15 = __ldxr(v14);
    while (__stxr(v15 + 1, v14));
  }
  v17 = *(_QWORD *)(a2 + 144);
  v16 = *(std::__shared_weak_count **)(a2 + 152);
  if (v16)
  {
    v18 = (unint64_t *)&v16->__shared_owners_;
    do
      v19 = __ldxr(v18);
    while (__stxr(v19 + 1, v18));
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a2 + 160));
  if (v13)
  {
    v20 = (unint64_t *)&v13->__shared_owners_;
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)v8 + 168))(v8, v17);
  vi_onefixedsize_disk_allocator::subvert(*(_QWORD *)(*(_QWORD *)(a2 + 96) + 32), *(_QWORD *)(*(_QWORD *)(a1 + 96) + 32));
  if (!v16)
    goto LABEL_31;
  v22 = (unint64_t *)&v16->__shared_owners_;
  do
    v23 = __ldaxr(v22);
  while (__stlxr(v23 - 1, v22));
  if (!v23)
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
    if (!v7)
      return;
  }
  else
  {
LABEL_31:
    if (!v7)
      return;
  }
  v24 = (unint64_t *)&v7->__shared_owners_;
  do
    v25 = __ldaxr(v24);
  while (__stlxr(v25 - 1, v24));
  if (!v25)
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
}

BOOL IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,512>::unlink(uint64_t a1)
{
  os_unfair_lock_s *v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  uint64_t v10;
  int v11;
  NSObject *v12;
  _QWORD *v13;
  int v14;
  int v15;
  int v16;
  _BOOL8 v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  int v23;
  _QWORD *v24;
  __int16 v25;
  int v26;
  __int16 v27;
  int v28;
  __int16 v29;
  int v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v2 = (os_unfair_lock_s *)(a1 + 160);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 160));
  v3 = *(std::__shared_weak_count **)(a1 + 136);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  v7 = *(_QWORD *)(a1 + 144);
  v6 = *(std::__shared_weak_count **)(a1 + 152);
  if (v6)
  {
    v8 = (unint64_t *)&v6->__shared_owners_;
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  os_unfair_lock_unlock(v2);
  (*(void (**)(uint64_t))(*(_QWORD *)v7 + 176))(v7);
  v10 = *(_QWORD *)(a1 + 96);
  v11 = *__error();
  v12 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    v13 = (_QWORD *)(v10 + 56);
    if (*(char *)(v10 + 79) < 0)
      v13 = (_QWORD *)*v13;
    v14 = *(_DWORD *)(v10 + 40);
    v15 = *(_DWORD *)(_windowsResolvePtr(*(_QWORD *)(v10 + 32) + 40, *(_QWORD *)(*(_QWORD *)(v10 + 32) + 24), 0x810uLL)+ 2056);
    v16 = *(_DWORD *)(_windowsResolvePtr(*(_QWORD *)(v10 + 32) + 40, *(_QWORD *)(*(_QWORD *)(v10 + 32) + 24)+ *(_QWORD *)(*(_QWORD *)(v10 + 32) + 16) * (*(_DWORD *)(v10 + 40) - 1), 0x810uLL)+ 2056);
    v23 = 136315906;
    v24 = v13;
    v25 = 1024;
    v26 = v14;
    v27 = 1024;
    v28 = v15;
    v29 = 1024;
    v30 = v16;
    _os_log_impl(&dword_1B8270000, v12, OS_LOG_TYPE_DEFAULT, "unlink VectorStore %s(%u)[%u,%u]", (uint8_t *)&v23, 0x1Eu);
  }
  *__error() = v11;
  v17 = vi_onefixedsize_disk_allocator::unlinkStorage(*(_QWORD *)(v10 + 32));
  if (v6)
  {
    v18 = (unint64_t *)&v6->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  if (v3)
  {
    v20 = (unint64_t *)&v3->__shared_owners_;
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  return v17;
}

void IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,512>::truncate(uint64_t a1)
{
  int v1;
  NSObject *v2;
  os_log_type_t v3;
  os_unfair_lock_s *v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  std::__shared_weak_count *v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  uint8_t v16[16];

  if (*(_BYTE *)(a1 + 208))
  {
    v1 = *__error();
    v2 = _SILogForLogForCategory(16);
    v3 = dword_1EF19FCCC < 3;
    if (os_log_type_enabled(v2, (os_log_type_t)(dword_1EF19FCCC < 3)))
    {
      *(_WORD *)v16 = 0;
      _os_log_impl(&dword_1B8270000, v2, v3, "*warn* call truncate on readOnly index.", v16, 2u);
    }
    *__error() = v1;
  }
  else
  {
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::flush(a1 + 48, 0);
    IVFVectorIndexTemplate<float,512>::VectorStore<vi_onefixedsize_disk_allocator,vi_disk_postings>::truncate(*(_QWORD *)(a1 + 96));
    v5 = (os_unfair_lock_s *)(a1 + 160);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 160));
    v6 = *(std::__shared_weak_count **)(a1 + 136);
    if (v6)
    {
      p_shared_owners = (unint64_t *)&v6->__shared_owners_;
      do
        v8 = __ldxr(p_shared_owners);
      while (__stxr(v8 + 1, p_shared_owners));
    }
    v10 = *(_QWORD *)(a1 + 144);
    v9 = *(std::__shared_weak_count **)(a1 + 152);
    if (v9)
    {
      v11 = (unint64_t *)&v9->__shared_owners_;
      do
        v12 = __ldxr(v11);
      while (__stxr(v12 + 1, v11));
      os_unfair_lock_unlock(v5);
      (*(void (**)(uint64_t))(*(_QWORD *)v10 + 136))(v10);
      do
        v13 = __ldaxr(v11);
      while (__stlxr(v13 - 1, v11));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
    }
    else
    {
      os_unfair_lock_unlock(v5);
      (*(void (**)(uint64_t))(*(_QWORD *)v10 + 136))(v10);
    }
    if (v6)
    {
      v14 = (unint64_t *)&v6->__shared_owners_;
      do
        v15 = __ldaxr(v14);
      while (__stlxr(v15 - 1, v14));
      if (!v15)
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }
}

void IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,512>::makeReadOnly(uint64_t a1)
{
  int v1;
  NSObject *v2;
  os_log_type_t v3;
  uint64_t v5;
  int v6;
  NSObject *v7;
  _QWORD *v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v17;
  int *v18;
  std::__shared_weak_count *v19;
  unint64_t *p_shared_owners;
  unint64_t v21;
  std::__shared_weak_count *v22;
  uint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t *v27;
  unint64_t v28;
  int v29;
  _QWORD *v30;
  __int16 v31;
  int v32;
  __int16 v33;
  int v34;
  __int16 v35;
  int v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 208))
  {
    v1 = *__error();
    v2 = _SILogForLogForCategory(16);
    v3 = dword_1EF19FCCC < 3;
    if (os_log_type_enabled(v2, (os_log_type_t)(dword_1EF19FCCC < 3)))
    {
      LOWORD(v29) = 0;
      _os_log_impl(&dword_1B8270000, v2, v3, "*warn* call makeReadOnly on readOnly index.", (uint8_t *)&v29, 2u);
    }
    *__error() = v1;
  }
  else
  {
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::flush(a1 + 48, 0);
    v5 = *(_QWORD *)(a1 + 96);
    v6 = *__error();
    v7 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      v8 = (_QWORD *)(v5 + 56);
      if (*(char *)(v5 + 79) < 0)
        v8 = (_QWORD *)*v8;
      v9 = *(_DWORD *)(v5 + 40);
      v10 = *(_DWORD *)(_windowsResolvePtr(*(_QWORD *)(v5 + 32) + 40, *(_QWORD *)(*(_QWORD *)(v5 + 32) + 24), 0x810uLL)+ 2056);
      v11 = *(_DWORD *)(_windowsResolvePtr(*(_QWORD *)(v5 + 32) + 40, *(_QWORD *)(*(_QWORD *)(v5 + 32) + 24)+ *(_QWORD *)(*(_QWORD *)(v5 + 32) + 16) * (*(_DWORD *)(v5 + 40) - 1), 0x810uLL)+ 2056);
      v29 = 136315906;
      v30 = v8;
      v31 = 1024;
      v32 = v9;
      v33 = 1024;
      v34 = v10;
      v35 = 1024;
      v36 = v11;
      _os_log_impl(&dword_1B8270000, v7, OS_LOG_TYPE_DEFAULT, "makeReadOnly VectorStore %s(%u)[%u,%u]", (uint8_t *)&v29, 0x1Eu);
    }
    *__error() = v6;
    IVFVectorIndexTemplate<float,512>::VectorStore<vi_onefixedsize_disk_allocator,vi_disk_postings>::truncate(v5);
    v12 = *(_QWORD *)(v5 + 32);
    fd_make_readonly(*(_QWORD *)(v12 + 40));
    v13 = *(_QWORD *)(v12 + 40);
    if (v13)
    {
      do
      {
        v14 = fchmodat(*(_DWORD *)(v13 + 44), *(const char **)(v13 + 72), 0x100u, 2048);
        v15 = g_prot_error_callback;
        if (v14 != -1 || g_prot_error_callback == 0)
          break;
        v17 = *(unsigned int *)(v13 + 40);
        v18 = __error();
      }
      while (((*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t))(v15 + 16))(v15, v17, *v18, 19) & 1) != 0);
    }
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 160));
    v19 = *(std::__shared_weak_count **)(a1 + 136);
    if (v19)
    {
      p_shared_owners = (unint64_t *)&v19->__shared_owners_;
      do
        v21 = __ldxr(p_shared_owners);
      while (__stxr(v21 + 1, p_shared_owners));
    }
    v23 = *(_QWORD *)(a1 + 144);
    v22 = *(std::__shared_weak_count **)(a1 + 152);
    if (v22)
    {
      v24 = (unint64_t *)&v22->__shared_owners_;
      do
        v25 = __ldxr(v24);
      while (__stxr(v25 + 1, v24));
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 160));
      (*(void (**)(uint64_t))(*(_QWORD *)v23 + 120))(v23);
      *(_BYTE *)(a1 + 208) = 1;
      do
        v26 = __ldaxr(v24);
      while (__stlxr(v26 - 1, v24));
      if (!v26)
      {
        ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
        std::__shared_weak_count::__release_weak(v22);
      }
    }
    else
    {
      os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 160));
      (*(void (**)(uint64_t))(*(_QWORD *)v23 + 120))(v23);
      *(_BYTE *)(a1 + 208) = 1;
    }
    if (v19)
    {
      v27 = (unint64_t *)&v19->__shared_owners_;
      do
        v28 = __ldaxr(v27);
      while (__stlxr(v28 - 1, v27));
      if (!v28)
      {
        ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
        std::__shared_weak_count::__release_weak(v19);
      }
    }
  }
}

void IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,512>::makePurgeable(uint64_t a1)
{
  uint64_t v2;
  int v3;
  NSObject *v4;
  _QWORD *v5;
  int v6;
  int v7;
  int v8;
  os_unfair_lock_s *v9;
  std::__shared_weak_count *v10;
  unint64_t *p_shared_owners;
  unint64_t v12;
  std::__shared_weak_count *v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  int v20;
  _QWORD *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 96);
  v3 = *__error();
  v4 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v5 = (_QWORD *)(v2 + 56);
    if (*(char *)(v2 + 79) < 0)
      v5 = (_QWORD *)*v5;
    v6 = *(_DWORD *)(v2 + 40);
    v7 = *(_DWORD *)(_windowsResolvePtr(*(_QWORD *)(v2 + 32) + 40, *(_QWORD *)(*(_QWORD *)(v2 + 32) + 24), 0x810uLL)
                   + 2056);
    v8 = *(_DWORD *)(_windowsResolvePtr(*(_QWORD *)(v2 + 32) + 40, *(_QWORD *)(*(_QWORD *)(v2 + 32) + 24)+ *(_QWORD *)(*(_QWORD *)(v2 + 32) + 16) * (*(_DWORD *)(v2 + 40) - 1), 0x810uLL)+ 2056);
    v20 = 136315906;
    v21 = v5;
    v22 = 1024;
    v23 = v6;
    v24 = 1024;
    v25 = v7;
    v26 = 1024;
    v27 = v8;
    _os_log_impl(&dword_1B8270000, v4, OS_LOG_TYPE_DEFAULT, "makePurgeable VectorStore %s(%u)[%u,%u]", (uint8_t *)&v20, 0x1Eu);
  }
  *__error() = v3;
  fd_mark_purgable(*(_DWORD **)(*(_QWORD *)(v2 + 32) + 40));
  v9 = (os_unfair_lock_s *)(a1 + 160);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 160));
  v10 = *(std::__shared_weak_count **)(a1 + 136);
  if (v10)
  {
    p_shared_owners = (unint64_t *)&v10->__shared_owners_;
    do
      v12 = __ldxr(p_shared_owners);
    while (__stxr(v12 + 1, p_shared_owners));
  }
  v14 = *(_QWORD *)(a1 + 144);
  v13 = *(std::__shared_weak_count **)(a1 + 152);
  if (!v13)
  {
    os_unfair_lock_unlock(v9);
    (*(void (**)(uint64_t))(*(_QWORD *)v14 + 128))(v14);
    if (!v10)
      return;
    goto LABEL_18;
  }
  v15 = (unint64_t *)&v13->__shared_owners_;
  do
    v16 = __ldxr(v15);
  while (__stxr(v16 + 1, v15));
  os_unfair_lock_unlock(v9);
  (*(void (**)(uint64_t))(*(_QWORD *)v14 + 128))(v14);
  do
    v17 = __ldaxr(v15);
  while (__stlxr(v17 - 1, v15));
  if (!v17)
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  if (v10)
  {
LABEL_18:
    v18 = (unint64_t *)&v10->__shared_owners_;
    do
      v19 = __ldaxr(v18);
    while (__stlxr(v19 - 1, v18));
    if (!v19)
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
  }
}

void IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,512>::rename(uint64_t a1, const char *a2)
{
  int v4;
  NSObject *v5;
  size_t v6;
  std::string::size_type v7;
  std::string *p_buf;
  uint64_t v9;
  uint64_t v10;
  int v11;
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  std::__shared_weak_count *v15;
  uint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  std::string *v19;
  uint64_t v20;
  int v21;
  NSObject *v22;
  _QWORD *v23;
  int v24;
  int v25;
  int v26;
  unint64_t *v27;
  unint64_t v28;
  unint64_t *v29;
  unint64_t v30;
  std::string::value_type __s[23];
  char v32;
  std::string v33;
  std::string buf;
  int v35;
  __int16 v36;
  int v37;
  __int16 v38;
  int v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  v4 = *__error();
  v5 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf.__r_.__value_.__l.__data_) = 136315138;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)a2;
    _os_log_impl(&dword_1B8270000, v5, OS_LOG_TYPE_DEFAULT, "rename: %s", (uint8_t *)&buf, 0xCu);
  }
  *__error() = v4;
  v6 = strlen(a2);
  if (v6 >= 0x7FFFFFFFFFFFFFF8)
    abort();
  v7 = v6;
  if (v6 >= 0x17)
  {
    v9 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v6 | 7) != 0x17)
      v9 = v6 | 7;
    v10 = v9 + 1;
    p_buf = (std::string *)operator new(v9 + 1);
    buf.__r_.__value_.__l.__size_ = v7;
    buf.__r_.__value_.__r.__words[2] = v10 | 0x8000000000000000;
    buf.__r_.__value_.__r.__words[0] = (std::string::size_type)p_buf;
    goto LABEL_10;
  }
  *((_BYTE *)&buf.__r_.__value_.__s + 23) = v6;
  p_buf = &buf;
  if (v6)
LABEL_10:
    memcpy(p_buf, a2, v7);
  p_buf->__r_.__value_.__s.__data_[v7] = 0;
  v32 = 11;
  strcpy(__s, ".partitions");
  memset(&v33, 0, sizeof(v33));
  v11 = SHIBYTE(buf.__r_.__value_.__r.__words[2]);
  if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0)
    std::string::__init_copy_ctor_external(&v33, buf.__r_.__value_.__l.__data_, buf.__r_.__value_.__l.__size_);
  else
    v33 = buf;
  std::string::append(&v33, __s, 0xBuLL);
  if (v32 < 0)
  {
    operator delete(*(void **)__s);
    if ((v11 & 0x80000000) == 0)
      goto LABEL_16;
  }
  else if ((v11 & 0x80000000) == 0)
  {
    goto LABEL_16;
  }
  operator delete(buf.__r_.__value_.__l.__data_);
LABEL_16:
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 160));
  v12 = *(std::__shared_weak_count **)(a1 + 136);
  if (v12)
  {
    p_shared_owners = (unint64_t *)&v12->__shared_owners_;
    do
      v14 = __ldxr(p_shared_owners);
    while (__stxr(v14 + 1, p_shared_owners));
  }
  v16 = *(_QWORD *)(a1 + 144);
  v15 = *(std::__shared_weak_count **)(a1 + 152);
  if (v15)
  {
    v17 = (unint64_t *)&v15->__shared_owners_;
    do
      v18 = __ldxr(v17);
    while (__stxr(v18 + 1, v17));
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 160));
  if ((v33.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v19 = &v33;
  else
    v19 = (std::string *)v33.__r_.__value_.__r.__words[0];
  (*(void (**)(uint64_t, std::string *))(*(_QWORD *)v16 + 152))(v16, v19);
  v20 = *(_QWORD *)(a1 + 96);
  v21 = *__error();
  v22 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    v23 = (_QWORD *)(v20 + 56);
    if (*(char *)(v20 + 79) < 0)
      v23 = (_QWORD *)*v23;
    v24 = *(_DWORD *)(v20 + 40);
    v25 = *(_DWORD *)(_windowsResolvePtr(*(_QWORD *)(v20 + 32) + 40, *(_QWORD *)(*(_QWORD *)(v20 + 32) + 24), 0x810uLL)+ 2056);
    v26 = *(_DWORD *)(_windowsResolvePtr(*(_QWORD *)(v20 + 32) + 40, *(_QWORD *)(*(_QWORD *)(v20 + 32) + 24)+ *(_QWORD *)(*(_QWORD *)(v20 + 32) + 16) * (*(_DWORD *)(v20 + 40) - 1), 0x810uLL)+ 2056);
    LODWORD(buf.__r_.__value_.__l.__data_) = 136316162;
    *(std::string::size_type *)((char *)buf.__r_.__value_.__r.__words + 4) = (std::string::size_type)v23;
    WORD2(buf.__r_.__value_.__r.__words[1]) = 2080;
    *(std::string::size_type *)((char *)&buf.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)a2;
    HIWORD(buf.__r_.__value_.__r.__words[2]) = 1024;
    v35 = v24;
    v36 = 1024;
    v37 = v25;
    v38 = 1024;
    v39 = v26;
    _os_log_impl(&dword_1B8270000, v22, OS_LOG_TYPE_DEFAULT, "rename VectorStore %s -> %s(%u)[%u,%u]", (uint8_t *)&buf, 0x28u);
  }
  *__error() = v21;
  MEMORY[0x1BCCB03B0](v20 + 56, a2);
  fd_rename(*(_QWORD *)(*(_QWORD *)(v20 + 32) + 40), a2);
  if (v15)
  {
    v27 = (unint64_t *)&v15->__shared_owners_;
    do
      v28 = __ldaxr(v27);
    while (__stlxr(v28 - 1, v27));
    if (!v28)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  if (!v12)
    goto LABEL_38;
  v29 = (unint64_t *)&v12->__shared_owners_;
  do
    v30 = __ldaxr(v29);
  while (__stlxr(v30 - 1, v29));
  if (v30)
  {
LABEL_38:
    if ((SHIBYTE(v33.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      return;
    goto LABEL_39;
  }
  ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
  std::__shared_weak_count::__release_weak(v12);
  if (SHIBYTE(v33.__r_.__value_.__r.__words[2]) < 0)
LABEL_39:
    operator delete(v33.__r_.__value_.__l.__data_);
}

void IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,512>::storeUpdateSet()
{
  char *v0;
  char *v1;
  const char *v2;

  v0 = __si_assert_copy_extra_268();
  v1 = v0;
  v2 = "";
  if (v0)
    v2 = v0;
  __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2998, "false", v2);
  free(v1);
  if (__valid_fs(-1))
  {
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  MEMORY[0xC00] = -559038737;
  abort();
}

void IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,512>::restoreUpdateSet()
{
  char *v0;
  char *v1;
  const char *v2;

  v0 = __si_assert_copy_extra_268();
  v1 = v0;
  v2 = "";
  if (v0)
    v2 = v0;
  __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3003, "false", v2);
  free(v1);
  if (__valid_fs(-1))
  {
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  MEMORY[0xC00] = -559038737;
  abort();
}

uint64_t IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,512>::aNN(uint64_t a1, int a2, int a3, unsigned __int8 *a4, int a5, int a6, int a7, char a8, float a9, uint64_t a10)
{
  uint64_t v13;
  int v14;
  _QWORD *v15;
  char *v17;
  char *v18;
  const char *v19;
  _QWORD v20[5];

  if (*(_DWORD *)(a1 + 8) != a2
    || *(unsigned __int16 *)(a1 + 20) != a3
    || a6 > 2
    || *(_DWORD *)(a1 + 12) != vector_dimension_vec_sizes_10743[a5]
    || vector_size_elem_sizes_10742[a6] != *(_DWORD *)(a1 + 16))
  {
    v17 = __si_assert_copy_extra_268();
    v18 = v17;
    v19 = "";
    if (v17)
      v19 = v17;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3070, "compatible", v19);
    free(v18);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v13 = a1 + 48;
  v20[0] = MEMORY[0x1E0C809B0];
  v20[1] = 0x40000000;
  v20[2] = ___ZNK16IVFVectorIndexenI30vi_onefixedsize_disk_allocator16vi_disk_postingsE22IVFVectorIndexInstanceIfLi512EE3aNNEjtPKv14vec_dimensions15vec_data_formatfjbU13block_pointerFvPvfE_block_invoke;
  v20[3] = &unk_1E6E34678;
  v20[4] = a10;
  if ((a7 - 10001) >= 0xFFFFD8F0)
    v14 = a7;
  else
    v14 = 10000;
  v15 = (_QWORD *)operator new();
  *(_DWORD *)v15 = v14;
  v15[2] = 0;
  v15[3] = 0;
  v15[1] = 0;
  IVFVectorIndexTemplate<float,512>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::aNN(v13, a4, a8, v15, 0, a9);
  return IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::aNNProcessResult((uint64_t)v15, (uint64_t)v20);
}

uint64_t IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,512>::aNNForTest(uint64_t a1, int a2, int a3, unsigned __int8 *a4, int a5, int a6, int a7, char a8, float a9, uint64_t a10, unsigned int a11)
{
  uint64_t v14;
  int v15;
  _QWORD *v16;
  char *v18;
  char *v19;
  const char *v20;

  if (*(_DWORD *)(a1 + 8) != a2
    || *(unsigned __int16 *)(a1 + 20) != a3
    || a6 > 2
    || *(_DWORD *)(a1 + 12) != vector_dimension_vec_sizes_10743[a5]
    || vector_size_elem_sizes_10742[a6] != *(_DWORD *)(a1 + 16))
  {
    v18 = __si_assert_copy_extra_268();
    v19 = v18;
    v20 = "";
    if (v18)
      v20 = v18;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3070, "compatible", v20);
    free(v19);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v14 = a1 + 48;
  if ((a7 - 10001) >= 0xFFFFD8F0)
    v15 = a7;
  else
    v15 = 10000;
  v16 = (_QWORD *)operator new();
  *(_DWORD *)v16 = v15;
  v16[2] = 0;
  v16[3] = 0;
  v16[1] = 0;
  IVFVectorIndexTemplate<float,512>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::aNN(v14, a4, a8, v16, a11, a9);
  return IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::aNNForTestProcessResult((uint64_t)v16, a10);
}

uint64_t IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,512>::createCandidateQueue(uint64_t a1, int a2)
{
  int v2;
  uint64_t result;

  if ((a2 - 10001) >= 0xFFFFD8F0)
    v2 = a2;
  else
    v2 = 10000;
  result = operator new();
  *(_DWORD *)result = v2;
  *(_QWORD *)(result + 16) = 0;
  *(_QWORD *)(result + 24) = 0;
  *(_QWORD *)(result + 8) = 0;
  return result;
}

void IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,512>::aNN(uint64_t a1, int a2, int a3, unsigned __int8 *a4, int a5, int a6, char a7, _QWORD *a8, float a9)
{
  char *v9;
  char *v10;
  const char *v11;

  if (*(_DWORD *)(a1 + 8) != a2
    || *(unsigned __int16 *)(a1 + 20) != a3
    || a6 > 2
    || *(_DWORD *)(a1 + 12) != vector_dimension_vec_sizes_10743[a5]
    || vector_size_elem_sizes_10742[a6] != *(_DWORD *)(a1 + 16))
  {
    v9 = __si_assert_copy_extra_268();
    v10 = v9;
    v11 = "";
    if (v9)
      v11 = v9;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 3070, "compatible", v11);
    free(v10);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  IVFVectorIndexTemplate<float,512>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::aNN(a1 + 48, a4, a7, a8, 0, a9);
}

uint64_t IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,512>::aNNProcessResult(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD v4[5];

  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 0x40000000;
  v4[2] = ___ZNK16IVFVectorIndexenI30vi_onefixedsize_disk_allocator16vi_disk_postingsE22IVFVectorIndexInstanceIfLi512EE16aNNProcessResultEPvU13block_pointerFvS5_fE_block_invoke;
  v4[3] = &unk_1E6E346D8;
  v4[4] = a3;
  return IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::aNNProcessResult(a2, (uint64_t)v4);
}

uint64_t IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,512>::aNNForTestProcessResult(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::aNNForTestProcessResult(a2, a3);
}

uint64_t IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,512>::aNNForDebugProcessResult(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  std::ios_base *v13;
  uint64_t v14;
  __int128 *v15;
  BOOL v16;
  int v17;
  __int128 *v18;
  _QWORD *v19;
  _QWORD *v20;
  char *v21;
  unint64_t v22;
  int v23;
  NSObject *v24;
  void **v25;
  __int128 *v26;
  char *v27;
  uint64_t v28;
  int v29;
  NSObject *v30;
  void **v31;
  void *v32;
  uint64_t v33;
  int v35;
  __int128 *v36;
  CFIndex AppIntegerValue;
  __int128 *v38;
  __int128 *v39;
  uint64_t v40;
  uint8_t v41[4];
  void **v42;
  void *__p[2];
  uint64_t v44;
  uint64_t v45;
  __int128 buf;
  uint64_t v47;
  _QWORD v48[8];
  __int128 v49;
  __int128 v50;
  uint64_t v51;
  uint64_t v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  uint64_t v62;

  v62 = *MEMORY[0x1E0C80C00];
  v5 = *__error();
  v6 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    v7 = (uint64_t)(*(_QWORD *)(a2 + 16) - *(_QWORD *)(a2 + 8)) >> 4;
    LODWORD(buf) = 134217984;
    *(_QWORD *)((char *)&buf + 4) = v7;
    _os_log_impl(&dword_1B8270000, v6, OS_LOG_TYPE_DEFAULT, "search return %zu results", (uint8_t *)&buf, 0xCu);
  }
  *__error() = v5;
  LOBYTE(buf) = 0;
  AppIntegerValue = CFPreferencesGetAppIntegerValue(CFSTR("IVFANNLogQueryResult"), CFSTR("com.apple.Spotlight"), (Boolean *)&buf);
  v35 = buf;
  v61 = 0u;
  v51 = 0;
  v60 = 0u;
  v59 = 0u;
  v58 = 0u;
  v57 = 0u;
  v56 = 0u;
  v55 = 0u;
  v54 = 0u;
  v53 = 0u;
  v50 = 0u;
  v49 = 0u;
  memset(v48, 0, sizeof(v48));
  v8 = MEMORY[0x1E0DE4FD0] + 104;
  v52 = MEMORY[0x1E0DE4FD0] + 104;
  v9 = (_QWORD *)MEMORY[0x1E0DE4F50];
  v10 = MEMORY[0x1E0DE4FD0] + 64;
  v11 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 16);
  v12 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 24);
  v47 = MEMORY[0x1E0DE4FD0] + 64;
  *(_QWORD *)&buf = v11;
  *(_QWORD *)((char *)&buf + *(_QWORD *)(v11 - 24)) = v12;
  *((_QWORD *)&buf + 1) = 0;
  v13 = (std::ios_base *)((char *)&buf + *(_QWORD *)(buf - 24));
  std::ios_base::init(v13, v48);
  v13[1].__vftable = 0;
  v13[1].__fmtflags_ = -1;
  v14 = v9[5];
  v47 = v9[4];
  *(_QWORD *)((char *)&v48[-1] + *(_QWORD *)(v47 - 24)) = v14;
  *(_QWORD *)&buf = v9[1];
  *(_QWORD *)((char *)&buf + *(_QWORD *)(buf - 24)) = v9[6];
  v52 = v8;
  *(_QWORD *)&buf = MEMORY[0x1E0DE4FD0] + 24;
  v47 = v10;
  std::streambuf::basic_streambuf();
  v48[0] = MEMORY[0x1E0DE4FB8] + 16;
  v49 = 0u;
  v50 = 0u;
  LODWORD(v51) = 24;
  v38 = 0;
  v39 = 0;
  v40 = 0;
  MaxSizePriorityQueue<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>,std::vector<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>,std::allocator<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>>>,std::less<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>>>::allItems(&v38, *(_BYTE **)(a2 + 8), *(_BYTE **)(a2 + 16));
  v15 = v39;
  v36 = v38;
  if (v38 != v39)
  {
    if (AppIntegerValue)
      v16 = v35 == 0;
    else
      v16 = 1;
    if (v16)
    {
      v26 = v38;
      do
      {
        (*(void (**)(uint64_t, _QWORD, _QWORD, float))(a3 + 16))(a3, *(unsigned int *)v26, *((unsigned int *)v26 + 2), *((float *)v26 + 3));
        ++v26;
      }
      while (v26 != v15);
    }
    else
    {
      v17 = 0;
      v18 = v38;
      do
      {
        (*(void (**)(uint64_t, _QWORD, _QWORD, float))(a3 + 16))(a3, *(unsigned int *)v18, *((unsigned int *)v18 + 2), *((float *)v18 + 3));
        v19 = (_QWORD *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v19, (uint64_t)",", 1);
        v20 = (_QWORD *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v20, (uint64_t)";", 1);
        v21 = (char *)&v48[-1] + *(_QWORD *)(v47 - 24);
        if ((v21[32] & 5) == 0
          && ((*(void (**)(void **__return_ptr, _QWORD, _QWORD, uint64_t, uint64_t))(**((_QWORD **)v21 + 5)
                                                                                            + 32))(__p, *((_QWORD *)v21 + 5), 0, 1, 16), v45 > 1000)|| (++v17, HIDWORD(v22) = -1030792151 * v17 + 85899344, LODWORD(v22) = HIDWORD(v22), (v22 >> 1) < 0x51EB851))
        {
          v23 = *__error();
          v24 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
          {
            std::stringbuf::str();
            v25 = __p;
            if (v44 < 0)
              v25 = (void **)__p[0];
            *(_DWORD *)v41 = 136315138;
            v42 = v25;
            _os_log_impl(&dword_1B8270000, v24, OS_LOG_TYPE_DEFAULT, "%s", v41, 0xCu);
            if (SHIBYTE(v44) < 0)
              operator delete(__p[0]);
          }
          *__error() = v23;
          __p[0] = 0;
          __p[1] = 0;
          v44 = 0;
          std::stringbuf::str();
          if (SHIBYTE(v44) < 0)
            operator delete(__p[0]);
        }
        ++v18;
      }
      while (v18 != v15);
    }
  }
  v27 = (char *)&v48[-1] + *(_QWORD *)(v47 - 24);
  if ((v27[32] & 5) != 0)
  {
    v28 = a2;
  }
  else
  {
    (*(void (**)(void **__return_ptr, _QWORD, _QWORD, uint64_t, uint64_t))(**((_QWORD **)v27 + 5) + 32))(__p, *((_QWORD *)v27 + 5), 0, 1, 16);
    v28 = a2;
    if (v45 > 0)
    {
      v29 = *__error();
      v30 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        std::stringbuf::str();
        v31 = v44 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)v41 = 136315138;
        v42 = v31;
        _os_log_impl(&dword_1B8270000, v30, OS_LOG_TYPE_DEFAULT, "%s", v41, 0xCu);
        if (SHIBYTE(v44) < 0)
          operator delete(__p[0]);
      }
      *__error() = v29;
    }
  }
  if (v28)
  {
    v32 = *(void **)(v28 + 8);
    if (v32)
    {
      *(_QWORD *)(v28 + 16) = v32;
      operator delete(v32);
    }
    MEMORY[0x1BCCB06A4](v28, 0x1020C403EC25235);
  }
  if (v36)
    operator delete(v36);
  *(_QWORD *)&buf = *MEMORY[0x1E0DE4F50];
  v33 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 72);
  *(_QWORD *)((char *)&buf + *(_QWORD *)(buf - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 64);
  v47 = v33;
  v48[0] = MEMORY[0x1E0DE4FB8] + 16;
  if (SBYTE7(v50) < 0)
    operator delete((void *)v49);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1BCCB0650](&v52);
}

uint64_t IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,512>::storageSize(uint64_t a1)
{
  os_unfair_lock_s *v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;

  v2 = (os_unfair_lock_s *)(a1 + 160);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 160));
  v3 = *(std::__shared_weak_count **)(a1 + 136);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  v7 = *(_QWORD *)(a1 + 144);
  v6 = *(std::__shared_weak_count **)(a1 + 152);
  if (v6)
  {
    v8 = (unint64_t *)&v6->__shared_owners_;
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
  }
  os_unfair_lock_unlock(v2);
  v10 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 32) + 48);
  v11 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v7 + 184))(v7);
  if (!v6)
    goto LABEL_11;
  v12 = (unint64_t *)&v6->__shared_owners_;
  do
    v13 = __ldaxr(v12);
  while (__stlxr(v13 - 1, v12));
  if (!v13)
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
    if (!v3)
      return v11 + v10;
  }
  else
  {
LABEL_11:
    if (!v3)
      return v11 + v10;
  }
  v14 = (unint64_t *)&v3->__shared_owners_;
  do
    v15 = __ldaxr(v14);
  while (__stlxr(v15 - 1, v14));
  if (!v15)
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return v11 + v10;
}

uint64_t IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,512>::setVectorStore(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 192) = a2;
  return result;
}

uint64_t IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,512>::getDataForOffset(_QWORD *a1, uint64_t a2, int *a3)
{
  uint64_t result;
  int v7;
  int v8;
  NSObject *v9;
  int *v10;
  int v11;
  int v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  int v17;
  __int16 v18;
  int v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if ((*(unsigned int (**)(_QWORD *))(*a1 + 16))(a1) <= a2)
  {
    v8 = *__error();
    v9 = _SILogForLogForCategory(2);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v11 = (*(uint64_t (**)(_QWORD *))(*a1 + 16))(a1);
      v12 = 136315906;
      v13 = "getDataForOffset";
      v14 = 1024;
      v15 = 3455;
      v16 = 1024;
      v17 = a2;
      v18 = 1024;
      v19 = v11;
      _os_log_error_impl(&dword_1B8270000, v9, OS_LOG_TYPE_ERROR, "%s:%d: offset out of range: %u >= %u", (uint8_t *)&v12, 0x1Eu);
    }
    v10 = __error();
    v7 = 0;
    result = 0;
    *v10 = v8;
  }
  else
  {
    result = (*(uint64_t (**)(_QWORD *, uint64_t))(a1[6] + 32))(a1 + 6, a2);
    v7 = 2048;
  }
  *a3 = v7;
  return result;
}

uint64_t IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,512>::updateVectorStorageOffsets(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;
  unint64_t i;
  uint64_t result;
  unint64_t v7;
  unint64_t v8;
  int v9;
  char v10;
  uint64_t v11;
  int v12;
  unint64_t j;
  unint64_t v14;

  v2 = a2;
  v4 = a1 + 48;
  if (a2)
  {
    for (i = 0; ; ++i)
    {
      result = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nVectors(v4);
      if (i >= result)
        break;
      v7 = _windowsResolvePtr(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 32) + 40, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 32) + 24)+ *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 32) + 16) * i, 0x810uLL);
      if (!*(_BYTE *)(v2 + 184))
      {
        v8 = *(unsigned int *)(v7 + 2056);
        v9 = *(_DWORD *)(v2 + 24);
        if (!v9 || !((*(_QWORD *)(v2 + 16) ^ v8) >> (-4 * v9)))
        {
          v10 = (60 - 4 * v9) & 0xFC;
          v11 = *(_QWORD *)(v2 + 56 + 8 * ((v8 >> v10) & 0xF));
          if ((v11 & 1) != 0)
          {
            v12 = v9 + 2;
            do
            {
              v10 = (64 - 4 * v12) & 0xFC;
              v11 = *(_QWORD *)((v11 & 0xFFFFFFFFFFFFFFFELL) + 8 * ((v8 >> v10) & 0xF));
              ++v12;
            }
            while ((v11 & 1) != 0);
          }
          if (v11)
          {
            if ((*(unsigned int (**)(uint64_t, unint64_t, uint64_t))(*(_QWORD *)v11 + 16))(v11, v8, ~(-1 << v10)))
            {
              data_map_set_offset_for_id(*(_QWORD *)(a1 + 192), v8, ((unint64_t)*(unsigned int *)(a1 + 88) << 36) | (16 * i) | (4 * (*(_DWORD *)(a1 + 176) & 3)) | *(_DWORD *)(a1 + 172) & 3, *(unsigned __int16 *)(a1 + 168) | ((unint64_t)*(unsigned int *)(a1 + 180) << 32), *(_DWORD *)(a1 + 184));
            }
          }
        }
      }
    }
  }
  else
  {
    for (j = 0; ; ++j)
    {
      result = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nVectors(v4);
      if (j >= result)
        break;
      v14 = _windowsResolvePtr(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 32) + 40, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 32) + 24)+ *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 32) + 16) * j, 0x810uLL);
      data_map_set_offset_for_id(*(_QWORD *)(a1 + 192), *(unsigned int *)(v14 + 2056), v2 | ((unint64_t)*(unsigned int *)(a1 + 88) << 36) | (4 * (*(_DWORD *)(a1 + 176) & 3)) | *(_DWORD *)(a1 + 172) & 3, *(unsigned __int16 *)(a1 + 168) | ((unint64_t)*(unsigned int *)(a1 + 180) << 32), *(_DWORD *)(a1 + 184));
      v2 += 16;
    }
  }
  return result;
}

uint64_t IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,512>::status(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  std::ios_base *v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  _QWORD *v22;
  _QWORD *v23;
  std::__shared_weak_count *v24;
  unint64_t *p_shared_owners;
  unint64_t v26;
  _QWORD *v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  _QWORD *v31;
  uint64_t v32;
  uint64_t v34;
  std::__shared_weak_count *v35;
  uint64_t v36;
  std::__shared_weak_count *v37;
  _QWORD v38[2];
  uint64_t v39;
  _OWORD v40[4];
  void *__p[2];
  __int128 v42;
  uint64_t v43;
  uint64_t v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;

  v53 = 0u;
  v43 = 0;
  v52 = 0u;
  v51 = 0u;
  v50 = 0u;
  v49 = 0u;
  v48 = 0u;
  v47 = 0u;
  v46 = 0u;
  v45 = 0u;
  v42 = 0u;
  *(_OWORD *)__p = 0u;
  v4 = MEMORY[0x1E0DE4FD0];
  memset(v40, 0, sizeof(v40));
  v5 = MEMORY[0x1E0DE4FD0] + 104;
  v44 = MEMORY[0x1E0DE4FD0] + 104;
  v6 = (_QWORD *)MEMORY[0x1E0DE4F50];
  v7 = MEMORY[0x1E0DE4FD0] + 64;
  v8 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 16);
  v9 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 24);
  v39 = MEMORY[0x1E0DE4FD0] + 64;
  v38[0] = v8;
  *(_QWORD *)((char *)v38 + *(_QWORD *)(v8 - 24)) = v9;
  v38[1] = 0;
  v10 = (std::ios_base *)((char *)v38 + *(_QWORD *)(v38[0] - 24));
  std::ios_base::init(v10, v40);
  v10[1].__vftable = 0;
  v10[1].__fmtflags_ = -1;
  v11 = v6[5];
  v39 = v6[4];
  *(uint64_t *)((char *)&v39 + *(_QWORD *)(v39 - 24)) = v11;
  v38[0] = v6[1];
  *(_QWORD *)((char *)v38 + *(_QWORD *)(v38[0] - 24)) = v6[6];
  v44 = v5;
  v38[0] = v4 + 24;
  v39 = v7;
  std::streambuf::basic_streambuf();
  v12 = MEMORY[0x1E0DE4FB8];
  *(_QWORD *)&v40[0] = MEMORY[0x1E0DE4FB8] + 16;
  *(_OWORD *)__p = 0u;
  v42 = 0u;
  LODWORD(v43) = 24;
  v13 = *(char *)(a2 + 23);
  if (v13 >= 0)
    v14 = a2;
  else
    v14 = *(_QWORD *)a2;
  if (v13 >= 0)
    v15 = *(unsigned __int8 *)(a2 + 23);
  else
    v15 = *(_QWORD *)(a2 + 8);
  v16 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v39, v14, v15);
  v17 = *(char *)(a1 + 47);
  if (v17 >= 0)
    v18 = a1 + 24;
  else
    v18 = *(_QWORD *)(a1 + 24);
  if (v17 >= 0)
    v19 = *(unsigned __int8 *)(a1 + 47);
  else
    v19 = *(_QWORD *)(a1 + 32);
  v20 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v16, v18, v19);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v20, (uint64_t)"(", 1);
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  v21 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v21, (uint64_t)"/", 1);
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
  v22 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v22, (uint64_t)"v", 1);
  IVFVectorIndexTemplate<float,512>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::getPartitions(a1 + 48, &v36);
  if (v36)
  {
    IVFVectorIndexTemplate<float,512>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::getPartitions(a1 + 48, &v34);
    v23 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v23, (uint64_t)")", 1);
    v24 = v35;
    if (v35)
    {
      p_shared_owners = (unint64_t *)&v35->__shared_owners_;
      do
        v26 = __ldaxr(p_shared_owners);
      while (__stlxr(v26 - 1, p_shared_owners));
      if (!v26)
      {
        ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
        std::__shared_weak_count::__release_weak(v24);
      }
    }
  }
  else
  {
    v27 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v27, (uint64_t)")", 1);
  }
  v28 = v37;
  if (v37)
  {
    v29 = (unint64_t *)&v37->__shared_owners_;
    do
      v30 = __ldaxr(v29);
    while (__stlxr(v30 - 1, v29));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v39, (uint64_t)"[", 1);
  std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v39, (uint64_t)",", 1);
  v31 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v31, (uint64_t)"] indexId: ", 11);
  std::ostream::operator<<();
  std::stringbuf::str();
  v38[0] = *v6;
  v32 = v6[9];
  *(_QWORD *)((char *)v38 + *(_QWORD *)(v38[0] - 24)) = v6[8];
  v39 = v32;
  *(_QWORD *)&v40[0] = v12 + 16;
  if (SBYTE7(v42) < 0)
    operator delete(__p[0]);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1BCCB0650](&v44);
}

uint64_t IVFVectorIndexen<vi_onefixedsize_disk_allocator,vi_disk_postings>::IVFVectorIndexInstance<float,512>::diagnoseDump(uint64_t a1, uint64_t a2, _QWORD *a3, int a4)
{
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  _QWORD *v16;
  const char *v17;
  uint64_t v18;
  _QWORD *v19;
  const std::locale::facet *v20;
  uint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *p_shared_owners;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  unint64_t *v28;
  unint64_t v29;
  unint64_t *v30;
  unint64_t v31;
  uint64_t v32;
  unint64_t *v33;
  unint64_t v34;
  _QWORD *v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  _QWORD *v39;
  _QWORD *v40;
  _QWORD *v41;
  _QWORD *v42;
  const std::locale::facet *v43;
  uint64_t v44;
  std::locale *v45;
  uint64_t v46;
  const std::locale::facet *v47;
  uint64_t v48;
  _QWORD *v49;
  const char *v50;
  uint64_t v51;
  const std::locale::facet *v52;
  unint64_t v53;
  std::locale::id *v54;
  const std::locale::facet *v55;
  unint64_t v56;
  _QWORD *v57;
  _QWORD *v58;
  _QWORD *v59;
  void *locale;
  uint64_t v61;
  void *v62;
  uint64_t v63;
  _QWORD *v64;
  unint64_t v65;
  std::locale::id *v66;
  _QWORD *v67;
  _QWORD *v68;
  const std::locale::facet *v69;
  const std::locale::facet *v70;
  uint64_t v71;
  std::__shared_weak_count *v72;
  unint64_t *v73;
  unint64_t v74;
  unint64_t *v75;
  unint64_t v76;
  uint64_t v78;
  unsigned int v79;
  uint64_t v80;
  std::__shared_weak_count *v81;
  std::locale v82;
  std::locale v83;
  uint64_t v84;
  unsigned __int8 v85;

  v7 = *(_QWORD *)(a2 + 8);
  if (*(char *)(a2 + 23) >= 0)
  {
    v8 = *(unsigned __int8 *)(a2 + 23);
  }
  else
  {
    a2 = *(_QWORD *)a2;
    v8 = v7;
  }
  v9 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, a2, v8);
  v10 = *(char *)(a1 + 47);
  if (v10 >= 0)
    v11 = a1 + 24;
  else
    v11 = *(_QWORD *)(a1 + 24);
  if (v10 >= 0)
    v12 = *(unsigned __int8 *)(a1 + 47);
  else
    v12 = *(_QWORD *)(a1 + 32);
  v13 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v9, v11, v12);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v13, (uint64_t)": ", 2);
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  v14 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v14, (uint64_t)" vectors ", 9);
  (*(void (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
  v15 = (_QWORD *)std::ostream::operator<<();
  v16 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v15, (uint64_t)" partitions.", 12);
  if (*(_BYTE *)(a1 + 208))
    v17 = "(readOnly)";
  else
    v17 = "(readWrite)";
  if (*(_BYTE *)(a1 + 208))
    v18 = 10;
  else
    v18 = 11;
  v19 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v16, (uint64_t)v17, v18);
  std::ios_base::getloc((const std::ios_base *)((char *)v19 + *(_QWORD *)(*v19 - 24)));
  v20 = std::locale::use_facet(&v83, MEMORY[0x1E0DE4A90]);
  ((void (*)(const std::locale::facet *, uint64_t))v20->__vftable[2].~facet_0)(v20, 10);
  std::locale::~locale(&v83);
  std::ostream::put();
  std::ostream::flush();
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 160));
  v21 = *(_QWORD *)(a1 + 128);
  v22 = *(std::__shared_weak_count **)(a1 + 136);
  if (v22)
  {
    p_shared_owners = (unint64_t *)&v22->__shared_owners_;
    do
      v24 = __ldxr(p_shared_owners);
    while (__stxr(v24 + 1, p_shared_owners));
  }
  v25 = *(std::__shared_weak_count **)(a1 + 152);
  if (v25)
  {
    v26 = (unint64_t *)&v25->__shared_owners_;
    do
      v27 = __ldxr(v26);
    while (__stxr(v27 + 1, v26));
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 160));
  if (v22)
  {
    v28 = (unint64_t *)&v22->__shared_owners_;
    do
      v29 = __ldxr(v28);
    while (__stxr(v29 + 1, v28));
  }
  if (!v25)
    goto LABEL_29;
  v30 = (unint64_t *)&v25->__shared_owners_;
  do
    v31 = __ldaxr(v30);
  while (__stlxr(v31 - 1, v30));
  if (!v31)
  {
    ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
    std::__shared_weak_count::__release_weak(v25);
    v32 = a1 + 48;
    if (!v22)
      goto LABEL_35;
  }
  else
  {
LABEL_29:
    v32 = a1 + 48;
    if (!v22)
      goto LABEL_35;
  }
  v33 = (unint64_t *)&v22->__shared_owners_;
  do
    v34 = __ldaxr(v33);
  while (__stlxr(v34 - 1, v33));
  if (!v34)
  {
    ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
    std::__shared_weak_count::__release_weak(v22);
  }
LABEL_35:
  if (v21)
  {
    v35 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, (uint64_t)"Quantizer: ", 11);
    v36 = *(char *)(v21 + 31);
    if (v36 >= 0)
      v37 = v21 + 8;
    else
      v37 = *(_QWORD *)(v21 + 8);
    if (v36 >= 0)
      v38 = *(unsigned __int8 *)(v21 + 31);
    else
      v38 = *(_QWORD *)(v21 + 16);
    v39 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v35, v37, v38);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v39, (uint64_t)"(", 1);
    (*(void (**)(uint64_t))(*(_QWORD *)v21 + 16))(v21);
    v40 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v40, (uint64_t)") ", 2);
    (*(void (**)(uint64_t))(*(_QWORD *)v21 + 24))(v21);
    v41 = (_QWORD *)std::ostream::operator<<();
    v42 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v41, (uint64_t)" centroids.", 11);
    std::ios_base::getloc((const std::ios_base *)((char *)v42 + *(_QWORD *)(*v42 - 24)));
    v43 = std::locale::use_facet(&v83, MEMORY[0x1E0DE4A90]);
    ((void (*)(const std::locale::facet *, uint64_t))v43->__vftable[2].~facet_0)(v43, 10);
    std::locale::~locale(&v83);
    std::ostream::put();
    std::ostream::flush();
  }
  v80 = 0;
  v81 = 0;
  IVFVectorIndexTemplate<float,512>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::getPartitions(v32, &v80);
  v44 = v80;
  if (!v80)
    goto LABEL_51;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, (uint64_t)"Partition: ", 11);
  (*(void (**)(std::locale *__return_ptr, uint64_t))(*(_QWORD *)v44 + 144))(&v83, v44);
  v45 = (v85 & 0x80u) == 0 ? &v83 : (std::locale *)v83.__locale_;
  v46 = (v85 & 0x80u) == 0 ? v85 : v84;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, (uint64_t)v45, v46);
  std::ios_base::getloc((const std::ios_base *)((char *)a3 + *(_QWORD *)(*a3 - 24)));
  v47 = std::locale::use_facet(&v82, MEMORY[0x1E0DE4A90]);
  ((void (*)(const std::locale::facet *, uint64_t))v47->__vftable[2].~facet_0)(v47, 10);
  std::locale::~locale(&v82);
  std::ostream::put();
  std::ostream::flush();
  if ((char)v85 < 0)
  {
    operator delete(v83.__locale_);
    if (!a4)
      goto LABEL_84;
  }
  else
  {
LABEL_51:
    if (!a4)
      goto LABEL_84;
  }
  v78 = v44;
  v48 = *(_QWORD *)(a1 + 96);
  v49 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, (uint64_t)"offset,vid", 10);
  v79 = a4;
  if (a4 <= 1)
    v50 = ",";
  else
    v50 = ",vector";
  if (a4 <= 1)
    v51 = 1;
  else
    v51 = 7;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v49, (uint64_t)v50, v51);
  std::ios_base::getloc((const std::ios_base *)((char *)a3 + *(_QWORD *)(*a3 - 24)));
  v52 = std::locale::use_facet(&v83, MEMORY[0x1E0DE4A90]);
  ((void (*)(const std::locale::facet *, uint64_t))v52->__vftable[2].~facet_0)(v52, 10);
  std::locale::~locale(&v83);
  std::ostream::put();
  std::ostream::flush();
  if (*(_DWORD *)(v48 + 40))
  {
    if (a4 <= 1)
    {
      v65 = 0;
      v66 = (std::locale::id *)MEMORY[0x1E0DE4A90];
      do
      {
        _windowsResolvePtr(*(_QWORD *)(v48 + 32) + 40, *(_QWORD *)(*(_QWORD *)(v48 + 32) + 24) + *(_QWORD *)(*(_QWORD *)(v48 + 32) + 16) * v65, 0x810uLL);
        v67 = (_QWORD *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v67, (uint64_t)",", 1);
        v68 = (_QWORD *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v68, (uint64_t)",", 1);
        std::ios_base::getloc((const std::ios_base *)((char *)a3 + *(_QWORD *)(*a3 - 24)));
        v69 = std::locale::use_facet(&v83, v66);
        ((void (*)(const std::locale::facet *, uint64_t))v69->__vftable[2].~facet_0)(v69, 10);
        std::locale::~locale(&v83);
        std::ostream::put();
        std::ostream::flush();
        ++v65;
      }
      while (v65 < *(unsigned int *)(v48 + 40));
    }
    else
    {
      v53 = 0;
      v54 = (std::locale::id *)MEMORY[0x1E0DE4A90];
      do
      {
        v56 = _windowsResolvePtr(*(_QWORD *)(v48 + 32) + 40, *(_QWORD *)(*(_QWORD *)(v48 + 32) + 24) + *(_QWORD *)(*(_QWORD *)(v48 + 32) + 16) * v53, 0x810uLL);
        v57 = (_QWORD *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v57, (uint64_t)",", 1);
        v58 = (_QWORD *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v58, (uint64_t)",", 1);
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, (uint64_t)"{length = ", 10);
        v59 = (_QWORD *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v59, (uint64_t)", bytes = 0x", 12);
        data2hexString((const unsigned __int8 *)&v83, v56, 16);
        if ((v85 & 0x80u) == 0)
          locale = &v83;
        else
          locale = v83.__locale_;
        if ((v85 & 0x80u) == 0)
          v61 = v85;
        else
          v61 = v84;
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v59, (uint64_t)locale, v61);
        if ((char)v85 < 0)
          operator delete(v83.__locale_);
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, (uint64_t)" ... ", 5);
        data2hexString((const unsigned __int8 *)&v83, v56 + 2040, 8);
        if ((v85 & 0x80u) == 0)
          v62 = &v83;
        else
          v62 = v83.__locale_;
        if ((v85 & 0x80u) == 0)
          v63 = v85;
        else
          v63 = v84;
        v64 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a3, (uint64_t)v62, v63);
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v64, (uint64_t)" }", 2);
        if ((char)v85 < 0)
          operator delete(v83.__locale_);
        std::ios_base::getloc((const std::ios_base *)((char *)a3 + *(_QWORD *)(*a3 - 24)));
        v55 = std::locale::use_facet(&v83, v54);
        ((void (*)(const std::locale::facet *, uint64_t))v55->__vftable[2].~facet_0)(v55, 10);
        std::locale::~locale(&v83);
        std::ostream::put();
        std::ostream::flush();
        ++v53;
      }
      while (v53 < *(unsigned int *)(v48 + 40));
    }
  }
  std::ios_base::getloc((const std::ios_base *)((char *)a3 + *(_QWORD *)(*a3 - 24)));
  v70 = std::locale::use_facet(&v83, MEMORY[0x1E0DE4A90]);
  ((void (*)(const std::locale::facet *, uint64_t))v70->__vftable[2].~facet_0)(v70, 10);
  std::locale::~locale(&v83);
  std::ostream::put();
  std::ostream::flush();
  if (v78)
    (*(void (**)(uint64_t, _QWORD *, _QWORD))(*(_QWORD *)v78 + 104))(v78, a3, v79);
LABEL_84:
  v71 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
  v72 = v81;
  if (!v81)
    goto LABEL_88;
  v73 = (unint64_t *)&v81->__shared_owners_;
  do
    v74 = __ldaxr(v73);
  while (__stlxr(v74 - 1, v73));
  if (!v74)
  {
    ((void (*)(std::__shared_weak_count *))v72->__on_zero_shared)(v72);
    std::__shared_weak_count::__release_weak(v72);
    if (!v22)
      return v71;
  }
  else
  {
LABEL_88:
    if (!v22)
      return v71;
  }
  v75 = (unint64_t *)&v22->__shared_owners_;
  do
    v76 = __ldaxr(v75);
  while (__stlxr(v76 - 1, v75));
  if (!v76)
  {
    ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
    std::__shared_weak_count::__release_weak(v22);
  }
  return v71;
}

uint64_t ___ZNK16IVFVectorIndexenI30vi_onefixedsize_disk_allocator16vi_disk_postingsE22IVFVectorIndexInstanceIfLi512EE16aNNProcessResultEPvU13block_pointerFvS5_fE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void IVFVectorIndexTemplate<float,512>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::aNN(uint64_t a1, unsigned __int8 *a2, char a3, _QWORD *a4, CFIndex AppIntegerValue, float a6)
{
  int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  double Current;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  unsigned int v30;
  int v31;
  char v32;
  int v33;
  char v34;
  unsigned int v35;
  char v36;
  unsigned int v37;
  int v38;
  int v39;
  int v40;
  unsigned int v41;
  int v42;
  NSObject *v43;
  int v44;
  int v45;
  uint64_t v46;
  std::__shared_weak_count *v47;
  unint64_t *p_shared_owners;
  unint64_t v49;
  std::__shared_weak_count *v50;
  uint64_t v51;
  unint64_t *v52;
  unint64_t v53;
  int *v54;
  int *v55;
  int v56;
  int v57;
  void *v58;
  int64_t v59;
  char *v60;
  char *v61;
  int v62;
  NSObject *v63;
  int v64;
  int v65;
  double v66;
  uint64_t v67;
  int v68;
  uint64_t v69;
  unint64_t v70;
  unint64_t v71;
  uint8x8_t v72;
  unint64_t v73;
  uint64_t *v74;
  unint64_t v75;
  uint64_t v76;
  float v77;
  int v79;
  NSObject *v80;
  int v81;
  NSObject *v82;
  int v83;
  int v84;
  NSObject *v85;
  int v86;
  int v87;
  int v88;
  int v89;
  uint64_t v90;
  CFAbsoluteTime v91;
  _QWORD *v92;
  _QWORD *v93;
  void *v94;
  _QWORD *v95;
  _QWORD *v96;
  void *v97;
  unint64_t *v98;
  unint64_t v99;
  unint64_t *v100;
  unint64_t v101;
  char *v102;
  char *v103;
  const char *v104;
  char *v105;
  const char *v106;
  uint64_t v107;
  int v108;
  unint64_t v109;
  unsigned int lock;
  _QWORD v112[8];
  void *v113;
  void *v114;
  _QWORD *v115;
  float v116;
  void *v117;
  void *v118;
  char *v119;
  void *v120;
  _BYTE *v121;
  uint64_t v122;
  __int128 v123;
  __int128 __p;
  uint64_t v125;
  uint64_t v126;
  uint64_t *v127;
  uint64_t v128;
  int v129;
  uint64_t v130;
  uint64_t *v131;
  uint64_t v132;
  int v133;
  void **v134;
  _BYTE keyExistsAndHasValidFormat[46];
  __int16 v136;
  int v137;
  __int16 v138;
  int v139;
  __int16 v140;
  uint64_t v141;
  __int16 v142;
  CFAbsoluteTime v143;
  _OWORD __str[2];
  uint64_t v145;

  v145 = *MEMORY[0x1E0C80C00];
  v11 = *(_DWORD *)a4;
  memset(__str, 0, sizeof(__str));
  snprintf((char *)__str, 0x20uLL, "%02x%02x%02x%02x...%02x%02x%02x%02x", *a2, a2[1], a2[2], a2[3], a2[2044], a2[2045], a2[2046], a2[2047]);
  if (!(_DWORD)AppIntegerValue)
    AppIntegerValue = CFPreferencesGetAppIntegerValue(CFSTR("IVFNumberOfParitionsProbe"), CFSTR("com.apple.Spotlight"), 0);
  keyExistsAndHasValidFormat[0] = 0;
  v12 = CFPreferencesGetAppIntegerValue(CFSTR("IVFPartitionProbeMin"), CFSTR("com.apple.Spotlight"), keyExistsAndHasValidFormat);
  if (keyExistsAndHasValidFormat[0])
    v13 = v12;
  else
    v13 = 10000;
  if (10 * v11 <= v13)
    v14 = v13;
  else
    v14 = 10 * v11;
  v15 = v14
      * IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nPartitions(a1);
  v16 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nVectors(a1);
  keyExistsAndHasValidFormat[0] = 0;
  v17 = v15 / v16;
  v18 = CFPreferencesGetAppIntegerValue(CFSTR("IVFPartitionProbeMin"), CFSTR("com.apple.Spotlight"), keyExistsAndHasValidFormat);
  if (keyExistsAndHasValidFormat[0])
    v19 = v18;
  else
    v19 = 7;
  v130 = 0;
  v131 = &v130;
  if (v17 <= v19)
    v20 = v19;
  else
    v20 = v17;
  v133 = 0;
  v132 = 0x2000000000;
  v126 = 0;
  v127 = &v126;
  v129 = 0;
  v128 = 0x2000000000;
  v125 = 0;
  v123 = 0u;
  __p = 0u;
  QuantizerManager<float,768>::aNNLogQueryVecIds((uint64_t)&v123);
  Current = CFAbsoluteTimeGetCurrent();
  if ((a3 & 1) != 0
    || IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nPartitions(a1) <= v20
    || IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nVectors(a1) <= v14)
  {
    v62 = *__error();
    v63 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
    {
      v64 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nVectors(a1);
      v65 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nPartitions(a1);
      v66 = a6;
      *(_DWORD *)keyExistsAndHasValidFormat = 136316162;
      *(_QWORD *)&keyExistsAndHasValidFormat[4] = __str;
      *(_WORD *)&keyExistsAndHasValidFormat[12] = 1024;
      *(_DWORD *)&keyExistsAndHasValidFormat[14] = v11;
      *(_WORD *)&keyExistsAndHasValidFormat[18] = 1024;
      *(_DWORD *)&keyExistsAndHasValidFormat[20] = v64;
      *(_WORD *)&keyExistsAndHasValidFormat[24] = 1024;
      *(_DWORD *)&keyExistsAndHasValidFormat[26] = v65;
      *(_WORD *)&keyExistsAndHasValidFormat[30] = 2048;
      *(double *)&keyExistsAndHasValidFormat[32] = a6;
      _os_log_impl(&dword_1B8270000, v63, OS_LOG_TYPE_DEFAULT, "brute force search %s top %u of %u vectors in %u partitions max_distance=%f", keyExistsAndHasValidFormat, 0x28u);
    }
    else
    {
      v66 = a6;
    }
    *__error() = v62;
    v108 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nPartitions(a1);
    v67 = 0;
    v68 = 0;
    v69 = *(_QWORD *)(a1 + 48);
    while (v68 != *(_DWORD *)(v69 + 40))
    {
      ++*((_DWORD *)v131 + 6);
      if (*(_DWORD *)(v69 + 40) <= v67)
      {
        v102 = __si_assert_copy_extra_268();
        v103 = v102;
        v104 = "";
        if (v102)
          v104 = v102;
        __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1798, "offset < store->endOffset()", v104);
LABEL_133:
        free(v103);
        if (__valid_fs(-1))
          v107 = 2989;
        else
          v107 = 3072;
        *(_DWORD *)v107 = -559038737;
        abort();
      }
      v70 = _windowsResolvePtr(*(_QWORD *)(v69 + 32) + 40, *(_QWORD *)(*(_QWORD *)(v69 + 32) + 24) + *(_QWORD *)(*(_QWORD *)(v69 + 32) + 16) * v67, 0x810uLL);
      v71 = *(unsigned int *)(v70 + 2056);
      *(_DWORD *)keyExistsAndHasValidFormat = 2139095039;
      vDSP_distancesq((const float *)a2, 1, (const float *)v70, 1, (float *)keyExistsAndHasValidFormat, 0x200uLL);
      if (*((_QWORD *)&v123 + 1))
      {
        v72 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v123 + 8));
        v72.i16[0] = vaddlv_u8(v72);
        if (v72.u32[0] > 1uLL)
        {
          v73 = v71;
          if (*((_QWORD *)&v123 + 1) <= v71)
            v73 = v71 % *((_QWORD *)&v123 + 1);
        }
        else
        {
          v73 = (DWORD2(v123) - 1) & v71;
        }
        v74 = *(uint64_t **)(v123 + 8 * v73);
        if (v74)
        {
          v74 = (uint64_t *)*v74;
          if (v74)
          {
            if (v72.u32[0] < 2uLL)
            {
              while (1)
              {
                v76 = v74[1];
                if (v76 == v71)
                {
                  if (*((_DWORD *)v74 + 4) == (_DWORD)v71)
                    goto LABEL_85;
                }
                else if ((v76 & (*((_QWORD *)&v123 + 1) - 1)) != v73)
                {
                  goto LABEL_84;
                }
                v74 = (uint64_t *)*v74;
                if (!v74)
                  goto LABEL_85;
              }
            }
            do
            {
              v75 = v74[1];
              if (v75 == v71)
              {
                if (*((_DWORD *)v74 + 4) == (_DWORD)v71)
                  break;
              }
              else
              {
                if (v75 >= *((_QWORD *)&v123 + 1))
                  v75 %= *((_QWORD *)&v123 + 1);
                if (v75 != v73)
                  goto LABEL_84;
              }
              v74 = (uint64_t *)*v74;
            }
            while (v74);
          }
        }
      }
      else
      {
LABEL_84:
        v74 = 0;
      }
LABEL_85:
      v77 = *(float *)keyExistsAndHasValidFormat;
      if (a6 == 0.0 || *(float *)keyExistsAndHasValidFormat <= a6)
      {
        if (v74)
        {
          v79 = *__error();
          v80 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v80, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)keyExistsAndHasValidFormat = 67109376;
            *(_DWORD *)&keyExistsAndHasValidFormat[4] = v71;
            *(_WORD *)&keyExistsAndHasValidFormat[8] = 2048;
            *(double *)&keyExistsAndHasValidFormat[10] = v77;
            _os_log_impl(&dword_1B8270000, v80, OS_LOG_TYPE_DEFAULT, "Include vec_id: %u distance %f", keyExistsAndHasValidFormat, 0x12u);
          }
          *__error() = v79;
        }
        *(_QWORD *)keyExistsAndHasValidFormat = *(_QWORD *)(v70 + 2048);
        *(_DWORD *)&keyExistsAndHasValidFormat[8] = v71;
        *(float *)&keyExistsAndHasValidFormat[12] = v77;
        MaxSizePriorityQueue<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>,std::vector<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>,std::allocator<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>>>,std::less<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>>>::push(a4, (uint64_t)keyExistsAndHasValidFormat);
      }
      else
      {
        if (v74)
        {
          v81 = *__error();
          v82 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)keyExistsAndHasValidFormat = 67109632;
            *(_DWORD *)&keyExistsAndHasValidFormat[4] = v71;
            *(_WORD *)&keyExistsAndHasValidFormat[8] = 2048;
            *(double *)&keyExistsAndHasValidFormat[10] = v77;
            *(_WORD *)&keyExistsAndHasValidFormat[18] = 2048;
            *(double *)&keyExistsAndHasValidFormat[20] = v66;
            _os_log_impl(&dword_1B8270000, v82, OS_LOG_TYPE_DEFAULT, "Skip vec_id: %u distance %f > %f", keyExistsAndHasValidFormat, 0x1Cu);
          }
          *__error() = v81;
        }
        ++*((_DWORD *)v127 + 6);
      }
      v67 = (v67 + 1);
      v68 = v67;
      if (v69 != *(_QWORD *)(a1 + 48))
      {
        v105 = __si_assert_copy_extra_268();
        v103 = v105;
        v106 = "";
        if (v105)
          v106 = v105;
        __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1814, "store == other.store", v106);
        goto LABEL_133;
      }
    }
    v83 = v11;
  }
  else
  {
    if (!(_DWORD)AppIntegerValue)
    {
      keyExistsAndHasValidFormat[0] = 0;
      v22 = CFPreferencesGetAppIntegerValue(CFSTR("IVFPartitionProbeMax"), CFSTR("com.apple.Spotlight"), keyExistsAndHasValidFormat);
      if (keyExistsAndHasValidFormat[0])
        v23 = v22;
      else
        v23 = 40;
      lock = v23;
      keyExistsAndHasValidFormat[0] = 0;
      v24 = CFPreferencesGetAppIntegerValue(CFSTR("IVFPartitionSizeFactor"), CFSTR("com.apple.Spotlight"), keyExistsAndHasValidFormat);
      if (keyExistsAndHasValidFormat[0])
        v25 = v24;
      else
        v25 = 45;
      keyExistsAndHasValidFormat[0] = 0;
      v26 = CFPreferencesGetAppIntegerValue(CFSTR("IVFPartitionProbeNumerator"), CFSTR("com.apple.Spotlight"), keyExistsAndHasValidFormat);
      v27 = keyExistsAndHasValidFormat[0];
      v28 = 8 * v26;
      v29 = v25 * v25;
      keyExistsAndHasValidFormat[0] = 0;
      v30 = CFPreferencesGetAppIntegerValue(CFSTR("IVFpartitionProbeDecayExponent"), CFSTR("com.apple.Spotlight"), keyExistsAndHasValidFormat);
      v31 = keyExistsAndHasValidFormat[0];
      if (v30 <= 0x12)
        v32 = 18;
      else
        v32 = v30;
      v33 = v11;
      v34 = v32 - 3;
      v35 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nVectors(a1);
      if (v31)
        v36 = v34;
      else
        v36 = 17;
      v11 = v33;
      v37 = v35 >> v36;
      if (v37 <= 8)
        v38 = 8;
      else
        v38 = v37;
      v39 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nPartitions(a1);
      if (v27)
        v40 = v28;
      else
        v40 = 800;
      v41 = v40 * v39 / (v29 * v38);
      if (lock < v41)
        v41 = lock;
      if (v41 <= v20)
        AppIntegerValue = v20;
      else
        AppIntegerValue = v41;
    }
    v42 = *__error();
    v43 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
    {
      v44 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nVectors(a1);
      v45 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nPartitions(a1);
      *(_DWORD *)keyExistsAndHasValidFormat = 136316418;
      *(_QWORD *)&keyExistsAndHasValidFormat[4] = __str;
      *(_WORD *)&keyExistsAndHasValidFormat[12] = 1024;
      *(_DWORD *)&keyExistsAndHasValidFormat[14] = v11;
      *(_WORD *)&keyExistsAndHasValidFormat[18] = 1024;
      *(_DWORD *)&keyExistsAndHasValidFormat[20] = v44;
      *(_WORD *)&keyExistsAndHasValidFormat[24] = 1024;
      *(_DWORD *)&keyExistsAndHasValidFormat[26] = AppIntegerValue;
      *(_WORD *)&keyExistsAndHasValidFormat[30] = 1024;
      *(_DWORD *)&keyExistsAndHasValidFormat[32] = v45;
      *(_WORD *)&keyExistsAndHasValidFormat[36] = 2048;
      *(double *)&keyExistsAndHasValidFormat[38] = a6;
      _os_log_impl(&dword_1B8270000, v43, OS_LOG_TYPE_DEFAULT, "aNN search %s top %u of %u vectors in %u of %u partitions max_distance=%f", keyExistsAndHasValidFormat, 0x2Eu);
    }
    *__error() = v42;
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 152));
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 112));
    v46 = *(_QWORD *)(a1 + 80);
    v47 = *(std::__shared_weak_count **)(a1 + 88);
    if (v47)
    {
      p_shared_owners = (unint64_t *)&v47->__shared_owners_;
      do
        v49 = __ldxr(p_shared_owners);
      while (__stxr(v49 + 1, p_shared_owners));
    }
    v51 = *(_QWORD *)(a1 + 96);
    v50 = *(std::__shared_weak_count **)(a1 + 104);
    if (v50)
    {
      v52 = (unint64_t *)&v50->__shared_owners_;
      do
        v53 = __ldxr(v52);
      while (__stxr(v53 + 1, v52));
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 112));
    memset(keyExistsAndHasValidFormat, 0, 24);
    (*(void (**)(_BYTE *__return_ptr, uint64_t, unsigned __int8 *, CFIndex))(*(_QWORD *)v46 + 72))(keyExistsAndHasValidFormat, v46, a2, AppIntegerValue);
    v55 = *(int **)keyExistsAndHasValidFormat;
    v54 = *(int **)&keyExistsAndHasValidFormat[8];
    v120 = 0;
    v121 = 0;
    v122 = 0;
    v134 = &v120;
    v109 = *(_QWORD *)&keyExistsAndHasValidFormat[8] - *(_QWORD *)keyExistsAndHasValidFormat;
    v56 = v11;
    if (*(_QWORD *)&keyExistsAndHasValidFormat[8] == *(_QWORD *)keyExistsAndHasValidFormat)
    {
      v118 = 0;
      v119 = 0;
      v117 = 0;
    }
    else
    {
      do
      {
        v57 = *v55;
        v55 += 2;
        std::back_insert_iterator<std::vector<unsigned int>>::operator=[abi:nn180100]((uint64_t *)&v134, v57);
      }
      while (v55 != v54);
      v58 = v120;
      v118 = 0;
      v119 = 0;
      v117 = 0;
      v59 = v121 - (_BYTE *)v120;
      if (v121 != v120)
      {
        if (v59 < 0)
          abort();
        v60 = (char *)operator new(v121 - (_BYTE *)v120);
        v61 = &v60[4 * (v59 >> 2)];
        v117 = v60;
        v119 = v61;
        memcpy(v60, v58, v59);
        v118 = v61;
      }
    }
    v112[0] = MEMORY[0x1E0C809B0];
    v112[1] = 1174405120;
    v112[2] = ___ZNK22IVFVectorIndexTemplateIfLi512EE20IVFVectorIndexRoot_sI30vi_onefixedsize_disk_allocator16vi_disk_postingsE3aNNERK10CIVector_sIfLi512EEfbP20MaxSizePriorityQueueINS0_18candidate_result_sIS3_EENSt3__16vectorISB_NSC_9allocatorISB_EEEENSC_4lessISB_EEEj_block_invoke;
    v112[3] = &unk_1E6E346A0;
    v112[6] = a1;
    v112[7] = a2;
    v112[4] = &v130;
    std::unordered_set<unsigned int>::unordered_set((uint64_t)&v113, (uint64_t)&v123);
    v116 = a6;
    v112[5] = &v126;
    v115 = a4;
    (*(void (**)(uint64_t, void **, _QWORD *))(*(_QWORD *)v51 + 72))(v51, &v117, v112);
    if (v117)
    {
      v118 = v117;
      operator delete(v117);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 152));
    v95 = v114;
    if (v114)
    {
      do
      {
        v96 = (_QWORD *)*v95;
        operator delete(v95);
        v95 = v96;
      }
      while (v96);
    }
    v97 = v113;
    v113 = 0;
    if (v97)
      operator delete(v97);
    v83 = v56;
    if (v120)
    {
      v121 = v120;
      operator delete(v120);
    }
    if (*(_QWORD *)keyExistsAndHasValidFormat)
    {
      *(_QWORD *)&keyExistsAndHasValidFormat[8] = *(_QWORD *)keyExistsAndHasValidFormat;
      operator delete(*(void **)keyExistsAndHasValidFormat);
    }
    if (v50)
    {
      v98 = (unint64_t *)&v50->__shared_owners_;
      do
        v99 = __ldaxr(v98);
      while (__stlxr(v99 - 1, v98));
      if (!v99)
      {
        ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
        std::__shared_weak_count::__release_weak(v50);
      }
    }
    v108 = v109 >> 3;
    if (v47)
    {
      v100 = (unint64_t *)&v47->__shared_owners_;
      do
        v101 = __ldaxr(v100);
      while (__stlxr(v101 - 1, v100));
      if (!v101)
      {
        ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
        std::__shared_weak_count::__release_weak(v47);
      }
    }
  }
  v84 = *__error();
  v85 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v85, OS_LOG_TYPE_DEFAULT))
  {
    v86 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nVectors(a1);
    v87 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nPartitions(a1);
    v88 = *((_DWORD *)v127 + 6);
    v89 = *((_DWORD *)v131 + 6);
    v90 = (uint64_t)(a4[2] - a4[1]) >> 4;
    v91 = CFAbsoluteTimeGetCurrent();
    *(_DWORD *)keyExistsAndHasValidFormat = 136317442;
    *(_QWORD *)&keyExistsAndHasValidFormat[4] = __str;
    *(_WORD *)&keyExistsAndHasValidFormat[12] = 1024;
    *(_DWORD *)&keyExistsAndHasValidFormat[14] = v83;
    *(_WORD *)&keyExistsAndHasValidFormat[18] = 1024;
    *(_DWORD *)&keyExistsAndHasValidFormat[20] = v86;
    *(_WORD *)&keyExistsAndHasValidFormat[24] = 2048;
    *(double *)&keyExistsAndHasValidFormat[26] = a6;
    *(_WORD *)&keyExistsAndHasValidFormat[34] = 1024;
    *(_DWORD *)&keyExistsAndHasValidFormat[36] = v108;
    *(_WORD *)&keyExistsAndHasValidFormat[40] = 1024;
    *(_DWORD *)&keyExistsAndHasValidFormat[42] = v87;
    v136 = 1024;
    v137 = v88;
    v138 = 1024;
    v139 = v89;
    v140 = 2048;
    v141 = v90;
    v142 = 2048;
    v143 = v91 - Current;
    _os_log_impl(&dword_1B8270000, v85, OS_LOG_TYPE_DEFAULT, "search %s top %u of %u vectors max_distance=%f in %u of %u partitions skip %u of %u populate %zu results in duration: %f", keyExistsAndHasValidFormat, 0x4Eu);
  }
  *__error() = v84;
  v92 = (_QWORD *)__p;
  if ((_QWORD)__p)
  {
    do
    {
      v93 = (_QWORD *)*v92;
      operator delete(v92);
      v92 = v93;
    }
    while (v93);
  }
  v94 = (void *)v123;
  *(_QWORD *)&v123 = 0;
  if (v94)
    operator delete(v94);
  _Block_object_dispose(&v126, 8);
  _Block_object_dispose(&v130, 8);
}

void ___ZNK22IVFVectorIndexTemplateIfLi512EE20IVFVectorIndexRoot_sI30vi_onefixedsize_disk_allocator16vi_disk_postingsE3aNNERK10CIVector_sIfLi512EEfbP20MaxSizePriorityQueueINS0_18candidate_result_sIS3_EENSt3__16vectorISB_NSC_9allocatorISB_EEEENSC_4lessISB_EEEj_block_invoke(uint64_t a1, uint64_t a2, unsigned int *a3)
{
  uint64_t v4;
  unint64_t v5;
  const float *v6;
  unint64_t v7;
  int8x8_t v8;
  uint8x8_t v9;
  unint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  float v15;
  float v16;
  int v17;
  NSObject *v18;
  double v19;
  int v20;
  NSObject *v21;
  uint64_t v22;
  _BYTE v23[10];
  __int16 v24;
  double v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a1 + 48);
  ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  v5 = _windowsResolvePtr(*(_QWORD *)(*(_QWORD *)(v4 + 48) + 32) + 40, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v4 + 48) + 32) + 24)+ *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v4 + 48) + 32) + 16) * *a3, 0x810uLL);
  v6 = *(const float **)(a1 + 56);
  LODWORD(v22) = 2139095039;
  vDSP_distancesq(v6, 1, (const float *)v5, 1, (float *)&v22, 0x200uLL);
  v7 = *(unsigned int *)(v5 + 2056);
  v8 = *(int8x8_t *)(a1 + 72);
  if (v8)
  {
    v9 = (uint8x8_t)vcnt_s8(v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      v10 = *(unsigned int *)(v5 + 2056);
      if (*(_QWORD *)&v8 <= v7)
        v10 = v7 % *(_QWORD *)&v8;
    }
    else
    {
      v10 = (v8.i32[0] - 1) & v7;
    }
    v11 = *(uint64_t **)(*(_QWORD *)(a1 + 64) + 8 * v10);
    if (v11)
    {
      v11 = (uint64_t *)*v11;
      if (v11)
      {
        if (v9.u32[0] < 2uLL)
        {
          v12 = *(_QWORD *)&v8 - 1;
          while (1)
          {
            v14 = v11[1];
            if (v14 == v7)
            {
              if (*((_DWORD *)v11 + 4) == (_DWORD)v7)
                goto LABEL_22;
            }
            else if ((v14 & v12) != v10)
            {
              goto LABEL_21;
            }
            v11 = (uint64_t *)*v11;
            if (!v11)
              goto LABEL_22;
          }
        }
        do
        {
          v13 = v11[1];
          if (v13 == v7)
          {
            if (*((_DWORD *)v11 + 4) == (_DWORD)v7)
              break;
          }
          else
          {
            if (v13 >= *(_QWORD *)&v8)
              v13 %= *(_QWORD *)&v8;
            if (v13 != v10)
              goto LABEL_21;
          }
          v11 = (uint64_t *)*v11;
        }
        while (v11);
      }
    }
  }
  else
  {
LABEL_21:
    v11 = 0;
  }
LABEL_22:
  v15 = *(float *)&v22;
  v16 = *(float *)(a1 + 112);
  if (v16 == 0.0 || *(float *)&v22 <= v16)
  {
    if (v11)
    {
      v20 = *__error();
      v21 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(v22) = 67109376;
        HIDWORD(v22) = v7;
        *(_WORD *)v23 = 2048;
        *(double *)&v23[2] = v15;
        _os_log_impl(&dword_1B8270000, v21, OS_LOG_TYPE_DEFAULT, "Include vec_id: %u distance %f", (uint8_t *)&v22, 0x12u);
      }
      *__error() = v20;
    }
    v22 = *(_QWORD *)(v5 + 2048);
    *(_DWORD *)v23 = v7;
    *(float *)&v23[4] = v15;
    MaxSizePriorityQueue<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>,std::vector<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>,std::allocator<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>>>,std::less<IVFVectorIndexTemplate<float,768>::candidate_result_s<vi_disk_postings>>>::push(*(_QWORD **)(a1 + 104), (uint64_t)&v22);
  }
  else
  {
    if (v11)
    {
      v17 = *__error();
      v18 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        v19 = *(float *)(a1 + 112);
        LODWORD(v22) = 67109632;
        HIDWORD(v22) = v7;
        *(_WORD *)v23 = 2048;
        *(double *)&v23[2] = v15;
        v24 = 2048;
        v25 = v19;
        _os_log_impl(&dword_1B8270000, v18, OS_LOG_TYPE_DEFAULT, "Skip vec_id: %u distance %f > %f", (uint8_t *)&v22, 0x1Cu);
      }
      *__error() = v17;
    }
    ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  }
}

uint64_t ___ZNK16IVFVectorIndexenI30vi_onefixedsize_disk_allocator16vi_disk_postingsE22IVFVectorIndexInstanceIfLi512EE3aNNEjtPKv14vec_dimensions15vec_data_formatfjbU13block_pointerFvPvfE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

_DWORD *IVFVectorIndexTemplate<float,512>::VectorStore<vi_onefixedsize_disk_allocator,vi_disk_postings>::truncate(uint64_t a1)
{
  int v2;
  NSObject *v3;
  _QWORD *v4;
  int v5;
  int v6;
  int v7;
  int v9;
  _QWORD *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  int v14;
  __int16 v15;
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v2 = *__error();
  v3 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = (_QWORD *)(a1 + 56);
    if (*(char *)(a1 + 79) < 0)
      v4 = (_QWORD *)*v4;
    v5 = *(_DWORD *)(a1 + 40);
    v6 = *(_DWORD *)(_windowsResolvePtr(*(_QWORD *)(a1 + 32) + 40, *(_QWORD *)(*(_QWORD *)(a1 + 32) + 24), 0x810uLL)
                   + 2056);
    v7 = *(_DWORD *)(_windowsResolvePtr(*(_QWORD *)(a1 + 32) + 40, *(_QWORD *)(*(_QWORD *)(a1 + 32) + 24)+ *(_QWORD *)(*(_QWORD *)(a1 + 32) + 16) * (*(_DWORD *)(a1 + 40) - 1), 0x810uLL)+ 2056);
    v9 = 136315906;
    v10 = v4;
    v11 = 1024;
    v12 = v5;
    v13 = 1024;
    v14 = v6;
    v15 = 1024;
    v16 = v7;
    _os_log_impl(&dword_1B8270000, v3, OS_LOG_TYPE_DEFAULT, "truncate VectorStore %s(%u)[%u,%u]", (uint8_t *)&v9, 0x1Eu);
  }
  *__error() = v2;
  return storage_array_Truncate((uint64_t *)(*(_QWORD *)(a1 + 32) + 8));
}

void IVFVectorIndexTemplate<float,512>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::compactForTest<vi_onefixedsize_disk_allocator>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  uint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *v22;
  unint64_t v23;
  unint64_t v24;
  std::__shared_weak_count *v25;
  unint64_t *v26;
  unint64_t v27;
  std::__shared_weak_count *v28;
  unint64_t *v29;
  unint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  unint64_t v33;
  unint64_t *v34;
  unint64_t v35;
  unint64_t *v36;
  unint64_t v37;
  char *v38;
  char *v39;
  const char *v40;
  _QWORD v41[2];
  _DWORD *(*v42)(uint64_t, unsigned int *, BOOL *);
  void *v43;
  uint64_t v44;
  uint64_t v45;
  _QWORD v46[2];
  uint64_t v47;
  std::__shared_weak_count *v48;
  __int128 v49;
  __int128 v50;
  _OWORD v51[3];
  uint64_t v52[2];
  void *v53[3];
  __int128 v54;
  __int128 v55;
  char v56;
  __int128 v57;
  __int128 v58;

  if (IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nVectors(a2))
  {
    v38 = __si_assert_copy_extra_268();
    v39 = v38;
    v40 = "";
    if (v38)
      v40 = v38;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2589, "target->nVectors() == 0", v40);
    free(v39);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v6 = operator new(8uLL);
  v53[0] = v6;
  *v6 = a1;
  v53[1] = v6 + 1;
  v53[2] = v6 + 1;
  IVFVectorIndexTemplate<float,512>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::train<vi_onefixedsize_disk_allocator>(*(_QWORD *)(a1 + 64), *(std::__shared_weak_count **)(a1 + 72), (uint64_t)v53);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 112));
  v8 = *(_QWORD *)(a1 + 80);
  v7 = *(std::__shared_weak_count **)(a1 + 88);
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
  }
  v12 = *(_QWORD *)(a1 + 96);
  v11 = *(std::__shared_weak_count **)(a1 + 104);
  if (v11)
  {
    v13 = (unint64_t *)&v11->__shared_owners_;
    do
      v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 112));
  v52[0] = v8;
  v52[1] = (uint64_t)v7;
  if (v7)
  {
    v15 = (unint64_t *)&v7->__shared_owners_;
    do
      v16 = __ldxr(v15);
    while (__stxr(v16 + 1, v15));
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::replaceQuantizer(a2, v52);
    do
      v17 = __ldaxr(v15);
    while (__stlxr(v17 - 1, v15));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  else
  {
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::replaceQuantizer(a2, v52);
  }
  v50 = 0u;
  memset(v51, 0, sizeof(v51));
  v49 = 0u;
  v47 = v12;
  v48 = v11;
  if (v11)
  {
    v18 = (unint64_t *)&v11->__shared_owners_;
    do
      v19 = __ldxr(v18);
    while (__stxr(v19 + 1, v18));
  }
  v20 = *(_QWORD *)(a1 + 48);
  v21 = *(std::__shared_weak_count **)(a1 + 56);
  v46[0] = v20;
  v46[1] = v21;
  if (v21)
  {
    v22 = (unint64_t *)&v21->__shared_owners_;
    do
      v23 = __ldxr(v22);
    while (__stxr(v23 + 1, v22));
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::enumerator_s::enumerator_s((uint64_t)&v49, &v47, v46);
    do
      v24 = __ldaxr(v22);
    while (__stlxr(v24 - 1, v22));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }
  else
  {
    IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::enumerator_s::enumerator_s((uint64_t)&v49, &v47, v46);
  }
  v25 = v48;
  if (v48)
  {
    v26 = (unint64_t *)&v48->__shared_owners_;
    do
      v27 = __ldaxr(v26);
    while (__stlxr(v27 - 1, v26));
    if (!v27)
    {
      ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
      std::__shared_weak_count::__release_weak(v25);
    }
  }
  v41[0] = MEMORY[0x1E0C809B0];
  v41[1] = 0x40000000;
  v42 = ___ZN22IVFVectorIndexTemplateIfLi512EE20IVFVectorIndexRoot_sI30vi_onefixedsize_disk_allocator16vi_disk_postingsE14compactForTestIS2_EENSt3__19enable_ifIXsr13is_persistentIT_EE5valueEbE4typeEPS4_PVi_block_invoke;
  v43 = &__block_descriptor_tmp_671;
  v44 = a2;
  v45 = a3;
  v57 = 0u;
  v58 = 0u;
  v56 = 0;
  do
  {
    IVFVectorIndexTemplate<float,512>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::enumerator_s::next((uint64_t)&v54, (uint64_t)&v49);
    v57 = v54;
    v58 = v55;
    if (!(_QWORD)v55)
      break;
    v42((uint64_t)v41, (unsigned int *)&v57, (BOOL *)&v56);
  }
  while (!v56);
  std::deque<std::shared_ptr<AnyPartitionStore::Enumerator>>::~deque[abi:nn180100]((uint64_t)v51);
  v28 = (std::__shared_weak_count *)*((_QWORD *)&v50 + 1);
  if (*((_QWORD *)&v50 + 1))
  {
    v29 = (unint64_t *)(*((_QWORD *)&v50 + 1) + 8);
    do
      v30 = __ldaxr(v29);
    while (__stlxr(v30 - 1, v29));
    if (!v30)
    {
      ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
      std::__shared_weak_count::__release_weak(v28);
    }
  }
  v31 = (std::__shared_weak_count *)*((_QWORD *)&v49 + 1);
  if (*((_QWORD *)&v49 + 1))
  {
    v32 = (unint64_t *)(*((_QWORD *)&v49 + 1) + 8);
    do
      v33 = __ldaxr(v32);
    while (__stlxr(v33 - 1, v32));
    if (!v33)
    {
      ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
      std::__shared_weak_count::__release_weak(v31);
    }
  }
  if (v11)
  {
    v34 = (unint64_t *)&v11->__shared_owners_;
    do
      v35 = __ldaxr(v34);
    while (__stlxr(v35 - 1, v34));
    if (!v35)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  if (v7)
  {
    v36 = (unint64_t *)&v7->__shared_owners_;
    do
      v37 = __ldaxr(v36);
    while (__stlxr(v37 - 1, v36));
    if (!v37)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  if (v53[0])
    operator delete(v53[0]);
}

void IVFVectorIndexTemplate<float,512>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::train<vi_onefixedsize_disk_allocator>(uint64_t a1, std::__shared_weak_count *a2, uint64_t a3)
{
  unint64_t *p_shared_owners;
  unint64_t v6;
  uint64_t v7;
  const void *v8;
  int64_t v9;
  char *v10;
  char *v11;
  uint64_t v12;
  char *v13;
  char *v14;
  unint64_t v15;
  unsigned int v16;
  unint64_t v17;
  uint64_t v18;
  std::__shared_weak_count *v19;
  uint64_t v20;
  unint64_t *v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  std::__shared_weak_count *v29;
  uint64_t v30;
  unint64_t *v31;
  unint64_t v32;
  char *v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  std::__shared_weak_count *v37;
  unint64_t *v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t *v44;
  unint64_t v45;
  std::__shared_weak_count *v46;
  unint64_t *v47;
  unint64_t v48;
  std::__shared_weak_count *v49;
  unint64_t *v50;
  unint64_t v51;
  std::__shared_weak_count *v52;
  unint64_t *v53;
  unint64_t v54;
  std::__shared_weak_count *v55;
  uint64_t v56;
  unint64_t *v57;
  unint64_t v58;
  std::__shared_weak_count *v59;
  int v60;
  unint64_t *v61;
  unint64_t v62;
  unsigned int AppIntegerValue;
  unsigned int v64;
  unsigned int v65;
  double v66;
  unsigned __int8 *v67;
  unsigned __int8 v68;
  char *FdPtrForFile;
  char *v70;
  NSObject *v71;
  os_signpost_id_t v72;
  NSObject *v73;
  NSObject *v74;
  _QWORD *v75;
  uint64_t v76;
  std::ios_base *v77;
  uint64_t v78;
  char *v79;
  _QWORD *v80;
  std::__shared_weak_count *v81;
  unint64_t *v82;
  unint64_t v83;
  int v84;
  NSObject *v85;
  os_log_type_t v86;
  std::__shared_weak_count *v87;
  std::__shared_weak_count *v88;
  int v89;
  NSObject *v90;
  os_log_type_t v91;
  Boolean *v92;
  double Current;
  unsigned int v94;
  unsigned int v95;
  unsigned int v96;
  unsigned int v97;
  uint64_t v98;
  unint64_t *v99;
  unint64_t v100;
  char *v101;
  unsigned int v102;
  unsigned int v103;
  unsigned int v104;
  int v105;
  unint64_t *v106;
  unint64_t v107;
  unsigned int v108;
  std::__shared_weak_count *v109;
  unint64_t *v110;
  unint64_t v111;
  std::__shared_weak_count *v112;
  unint64_t *v113;
  unint64_t v114;
  char *v115;
  int v116;
  unint64_t v117;
  int v118;
  unsigned int v119;
  unsigned __int8 v120;
  NSObject *v121;
  unsigned int v122;
  std::__shared_weak_count *v123;
  unint64_t *v124;
  unint64_t v125;
  NSObject *v126;
  NSObject *v127;
  int v128;
  NSObject *v129;
  CFAbsoluteTime v130;
  uint64_t v131;
  std::__shared_weak_count *v132;
  unint64_t *v133;
  unint64_t v134;
  unint64_t *v135;
  unint64_t v136;
  unint64_t *v137;
  unint64_t v138;
  unint64_t *v139;
  unsigned int v140;
  unsigned int v141;
  unsigned int v142;
  uint64_t v143;
  unint64_t v144;
  char *v145;
  unsigned int v146;
  unsigned int v147;
  int v148;
  unint64_t v149;
  std::__shared_weak_count *v150;
  unint64_t *v151;
  unint64_t v152;
  char *v153;
  char *v154;
  const char *v155;
  char *v156;
  char *v157;
  const char *v158;
  uint64_t v159;
  char *v160;
  const char *v161;
  os_signpost_id_t spid;
  unint64_t v163;
  uint64_t v164;
  unsigned int v165;
  uint64_t v166;
  unsigned int v167;
  size_t __sz;
  unint64_t v169;
  uint64_t v170;
  std::__shared_weak_count *v171;
  char *v172;
  char *v173;
  char *v174;
  char *v175;
  uint64_t v176[2];
  uint64_t v177;
  std::__shared_weak_count *v178;
  Boolean keyExistsAndHasValidFormat[8];
  std::__shared_weak_count *v180;
  uint64_t v181;
  _OWORD v182[4];
  __int128 __p;
  __int128 v184;
  uint64_t v185;
  uint64_t v186;
  __int128 v187;
  __int128 v188;
  __int128 v189;
  __int128 v190;
  __int128 v191;
  __int128 v192;
  __int128 v193;
  __int128 v194;
  __int128 v195;
  uint64_t v196;
  std::__shared_weak_count *v197;
  uint64_t v198;
  std::__shared_weak_count *v199;
  uint64_t v200;
  std::__shared_weak_count *v201;
  uint64_t v202;
  std::__shared_weak_count *v203;
  uint8_t buf[32];
  Boolean block[8];
  uint64_t v206;
  _BYTE v207[24];
  uint64_t v208;

  v208 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    p_shared_owners = (unint64_t *)&a2->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  v8 = *(const void **)a3;
  v7 = *(_QWORD *)(a3 + 8);
  v9 = v7 - *(_QWORD *)a3;
  if (v7 == *(_QWORD *)a3)
  {
    v10 = 0;
    v11 = 0;
  }
  else
  {
    if (v9 < 0)
      goto LABEL_251;
    v10 = (char *)operator new(v7 - *(_QWORD *)a3);
    v11 = &v10[8 * (v9 >> 3)];
    memcpy(v10, v8, v9);
  }
  v202 = 0;
  v203 = 0;
  QuantizerManager<float,512>::sharedQuantizer(&v202, a1, 0);
  v12 = v11 - v10;
  v170 = a1;
  v171 = a2;
  if (v11 == v10)
  {
    v14 = 0;
    v13 = 0;
  }
  else
  {
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF9)
      goto LABEL_251;
    v13 = (char *)operator new(2 * v12);
    bzero(v13, 2 * v12);
    v14 = &v13[2 * v12];
  }
  __sz = v11 - v10;
  v15 = v12 >> 3;
  v16 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v202 + 24))(v202);
  v172 = v11;
  v169 = v15;
  v17 = 0;
  if (v11 != v10)
  {
    if (v15 <= 1)
      v15 = 1;
    while (1)
    {
      (*(void (**)(Boolean *__return_ptr))(**(_QWORD **)&v10[8 * v17] + 16))(keyExistsAndHasValidFormat);
      v18 = v202;
      v20 = *(_QWORD *)keyExistsAndHasValidFormat;
      v19 = v180;
      if (!v180)
        goto LABEL_21;
      v21 = (unint64_t *)&v180->__shared_owners_;
      do
        v22 = __ldaxr(v21);
      while (__stlxr(v22 - 1, v21));
      if (!v22)
      {
        ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
        std::__shared_weak_count::__release_weak(v19);
        if (v20 == v18)
          goto LABEL_16;
      }
      else
      {
LABEL_21:
        if (v20 == v18)
          goto LABEL_16;
      }
      *(_QWORD *)keyExistsAndHasValidFormat = 0;
      v180 = 0;
      v23 = *(_QWORD *)&v10[8 * v17];
      v200 = v202;
      v201 = v203;
      if (v203)
      {
        v24 = (unint64_t *)&v203->__shared_owners_;
        do
          v25 = __ldxr(v24);
        while (__stxr(v25 + 1, v24));
      }
      (*(void (**)(Boolean *__return_ptr, uint64_t, uint64_t *))(*(_QWORD *)v23 + 40))(keyExistsAndHasValidFormat, v23, &v200);
      v26 = v201;
      if (!v201)
        goto LABEL_29;
      v27 = (unint64_t *)&v201->__shared_owners_;
      do
        v28 = __ldaxr(v27);
      while (__stlxr(v28 - 1, v27));
      if (!v28)
      {
        ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
        std::__shared_weak_count::__release_weak(v26);
        v30 = *(_QWORD *)keyExistsAndHasValidFormat;
        v29 = v180;
        if (!v180)
          goto LABEL_32;
      }
      else
      {
LABEL_29:
        v30 = *(_QWORD *)keyExistsAndHasValidFormat;
        v29 = v180;
        if (!v180)
          goto LABEL_32;
      }
      v31 = (unint64_t *)&v29->__shared_owners_;
      do
        v32 = __ldxr(v31);
      while (__stxr(v32 + 1, v31));
LABEL_32:
      v33 = &v13[16 * v17];
      v34 = (std::__shared_weak_count *)*((_QWORD *)v33 + 1);
      *(_QWORD *)v33 = v30;
      *((_QWORD *)v33 + 1) = v29;
      if (!v34)
        goto LABEL_36;
      v35 = (unint64_t *)&v34->__shared_owners_;
      do
        v36 = __ldaxr(v35);
      while (__stlxr(v36 - 1, v35));
      if (!v36)
      {
        ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
        std::__shared_weak_count::__release_weak(v34);
        v37 = v180;
        if (v180)
        {
LABEL_37:
          v38 = (unint64_t *)&v37->__shared_owners_;
          do
            v39 = __ldaxr(v38);
          while (__stlxr(v39 - 1, v38));
          if (!v39)
          {
            ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
            std::__shared_weak_count::__release_weak(v37);
          }
        }
      }
      else
      {
LABEL_36:
        v37 = v180;
        if (v180)
          goto LABEL_37;
      }
LABEL_16:
      if (++v17 == v15)
      {
        v17 = 0;
        v40 = 0;
        if (v169 <= 1)
          v41 = 1;
        else
          v41 = v169;
        while (1)
        {
          v42 = *(_QWORD *)&v13[16 * v40];
          if (v42)
          {
            v43 = *(_QWORD *)&v10[8 * v40];
            v198 = v202;
            v199 = v203;
            if (v203)
            {
              v44 = (unint64_t *)&v203->__shared_owners_;
              do
                v45 = __ldxr(v44);
              while (__stxr(v45 + 1, v44));
            }
            v46 = *(std::__shared_weak_count **)&v13[16 * v40 + 8];
            v196 = v42;
            v197 = v46;
            if (v46)
            {
              v47 = (unint64_t *)&v46->__shared_owners_;
              do
                v48 = __ldxr(v47);
              while (__stxr(v48 + 1, v47));
            }
            (*(void (**)(uint64_t, uint64_t *, uint64_t *))(*(_QWORD *)v43 + 48))(v43, &v198, &v196);
            v49 = v197;
            if (!v197)
              goto LABEL_61;
            v50 = (unint64_t *)&v197->__shared_owners_;
            do
              v51 = __ldaxr(v50);
            while (__stlxr(v51 - 1, v50));
            if (!v51)
            {
              ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
              std::__shared_weak_count::__release_weak(v49);
              v52 = v199;
              if (!v199)
                goto LABEL_67;
            }
            else
            {
LABEL_61:
              v52 = v199;
              if (!v199)
                goto LABEL_67;
            }
            v53 = (unint64_t *)&v52->__shared_owners_;
            do
              v54 = __ldaxr(v53);
            while (__stlxr(v54 - 1, v53));
            if (!v54)
            {
              ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
              std::__shared_weak_count::__release_weak(v52);
            }
          }
LABEL_67:
          (*(void (**)(Boolean *__return_ptr))(**(_QWORD **)&v10[8 * v40] + 24))(keyExistsAndHasValidFormat);
          v55 = v180;
          v56 = *(unsigned int *)(*(_QWORD *)keyExistsAndHasValidFormat + 72);
          if (v180)
          {
            v57 = (unint64_t *)&v180->__shared_owners_;
            do
              v58 = __ldaxr(v57);
            while (__stlxr(v58 - 1, v57));
            if (!v58)
            {
              ((void (*)(std::__shared_weak_count *))v55->__on_zero_shared)(v55);
              std::__shared_weak_count::__release_weak(v55);
            }
          }
          (*(void (**)(Boolean *__return_ptr))(**(_QWORD **)&v10[8 * v40] + 24))(keyExistsAndHasValidFormat);
          v59 = v180;
          v60 = *(_DWORD *)(*(_QWORD *)keyExistsAndHasValidFormat + 68);
          if (v180)
          {
            v61 = (unint64_t *)&v180->__shared_owners_;
            do
              v62 = __ldaxr(v61);
            while (__stlxr(v62 - 1, v61));
            if (!v62)
            {
              ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
              std::__shared_weak_count::__release_weak(v59);
            }
          }
          if (v60 != v16)
          {
            v153 = __si_assert_copy_extra_268();
            v154 = v153;
            v155 = "";
            if (v153)
              v155 = v153;
            __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2080, "vectorIndexes[i]->getPartitions()->nPartitions() == nPartitions", v155);
LABEL_239:
            free(v154);
            if (__valid_fs(-1))
            {
              MEMORY[0xBAD] = -559038737;
              abort();
            }
            MEMORY[0xC00] = -559038737;
            abort();
          }
          v17 += v56;
          if (++v40 == v41)
            goto LABEL_79;
        }
      }
    }
  }
LABEL_79:
  keyExistsAndHasValidFormat[0] = 0;
  AppIntegerValue = CFPreferencesGetAppIntegerValue(CFSTR("IVFPartitionSizeFactor"), CFSTR("com.apple.Spotlight"), keyExistsAndHasValidFormat);
  if (keyExistsAndHasValidFormat[0])
    v64 = AppIntegerValue;
  else
    v64 = 45;
  keyExistsAndHasValidFormat[0] = 0;
  v65 = CFPreferencesGetAppIntegerValue(CFSTR("IVFTrainingTimeBudget"), CFSTR("com.apple.Spotlight"), keyExistsAndHasValidFormat);
  if (keyExistsAndHasValidFormat[0])
    v66 = (double)v65;
  else
    v66 = 30.0;
  if (v17 >> 4 < 0x271 || v17 < v64 * (unint64_t)v16 * v64 * (unint64_t)v16 / 0x64)
  {
LABEL_108:
    v87 = v171;
    if (!v13)
      goto LABEL_109;
    goto LABEL_187;
  }
  v67 = (unsigned __int8 *)(v170 + 72);
  do
    v68 = __ldaxr(v67);
  while (__stlxr(1u, v67));
  if ((v68 & 1) == 0 && *(_QWORD *)(v170 + 96))
  {
    v156 = __si_assert_copy_extra_268();
    v157 = v156;
    v158 = "";
    if (v156)
      v158 = v156;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 717, "_trainingQuantizer == nullptr", v158);
    free(v157);
    if (__valid_fs(-1))
      v159 = 2989;
    else
      v159 = 3072;
    *(_DWORD *)v159 = -559038737;
    goto LABEL_251;
  }
  FdPtrForFile = (char *)QuantizerManager<float,768>::createFdPtrForFile(v170, "dummy");
  if (!FdPtrForFile)
  {
    atomic_store(0, v67);
    goto LABEL_105;
  }
  v70 = FdPtrForFile;
  _fd_unlink_with_origin((uint64_t)FdPtrForFile, 0);
  fd_release(v70);
  if ((v68 & 1) != 0)
  {
LABEL_105:
    v84 = *__error();
    v85 = _SILogForLogForCategory(16);
    v86 = 2 * (dword_1EF19FCCC < 4);
    if (os_log_type_enabled(v85, v86))
    {
      *(_WORD *)keyExistsAndHasValidFormat = 0;
      _os_log_impl(&dword_1B8270000, v85, v86, "training quantizer already happen in other thread. Skip!", keyExistsAndHasValidFormat, 2u);
    }
    *__error() = v84;
    goto LABEL_108;
  }
  v167 = v64;
  v71 = _SILogForLogForCategory(0);
  v72 = os_signpost_id_make_with_pointer(v71, 0);
  v73 = _SILogForLogForCategory(0);
  spid = v72;
  v163 = v72 - 1;
  if (v72 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v74 = v73;
    if (os_signpost_enabled(v73))
    {
      *(_WORD *)keyExistsAndHasValidFormat = 0;
      _os_signpost_emit_with_name_impl(&dword_1B8270000, v74, OS_SIGNPOST_INTERVAL_BEGIN, v72, "IVFVectorIndexTrain", "Start", keyExistsAndHasValidFormat, 2u);
    }
  }
  v195 = 0u;
  v194 = 0u;
  v193 = 0u;
  v192 = 0u;
  v191 = 0u;
  v190 = 0u;
  v189 = 0u;
  v188 = 0u;
  v187 = 0u;
  v185 = 0;
  v184 = 0u;
  __p = 0u;
  memset(v182, 0, sizeof(v182));
  v180 = 0;
  v166 = MEMORY[0x1E0DE4FD0] + 104;
  v186 = MEMORY[0x1E0DE4FD0] + 104;
  v164 = MEMORY[0x1E0DE4FD0] + 64;
  v181 = MEMORY[0x1E0DE4FD0] + 64;
  v75 = (_QWORD *)MEMORY[0x1E0DE4F50];
  v76 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 24);
  *(_QWORD *)keyExistsAndHasValidFormat = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 16);
  *(_QWORD *)&keyExistsAndHasValidFormat[*(_QWORD *)(*(_QWORD *)keyExistsAndHasValidFormat - 24)] = v76;
  v180 = 0;
  v77 = (std::ios_base *)&keyExistsAndHasValidFormat[*(_QWORD *)(*(_QWORD *)keyExistsAndHasValidFormat - 24)];
  std::ios_base::init(v77, v182);
  v77[1].__vftable = 0;
  v77[1].__fmtflags_ = -1;
  v78 = v75[5];
  v181 = v75[4];
  *(uint64_t *)((char *)&v181 + *(_QWORD *)(v181 - 24)) = v78;
  *(_QWORD *)keyExistsAndHasValidFormat = v75[1];
  *(_QWORD *)&keyExistsAndHasValidFormat[*(_QWORD *)(*(_QWORD *)keyExistsAndHasValidFormat - 24)] = v75[6];
  v186 = v166;
  *(_QWORD *)keyExistsAndHasValidFormat = MEMORY[0x1E0DE4FD0] + 24;
  v181 = v164;
  std::streambuf::basic_streambuf();
  *(_QWORD *)&v182[0] = MEMORY[0x1E0DE4FB8] + 16;
  __p = 0u;
  v184 = 0u;
  LODWORD(v185) = 24;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v181, (uint64_t)"[", 1);
  if (v172 != v10)
  {
    v79 = v10;
    do
    {
      (*(void (**)(Boolean *__return_ptr))(**(_QWORD **)v79 + 24))(block);
      v80 = (_QWORD *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v80, (uint64_t)", ", 2);
      v81 = (std::__shared_weak_count *)v206;
      if (v206)
      {
        v82 = (unint64_t *)(v206 + 8);
        do
          v83 = __ldaxr(v82);
        while (__stlxr(v83 - 1, v82));
        if (!v83)
        {
          ((void (*)(std::__shared_weak_count *))v81->__on_zero_shared)(v81);
          std::__shared_weak_count::__release_weak(v81);
        }
      }
      v79 += 8;
    }
    while (v79 != v172);
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v181, (uint64_t)"]", 1);
  v89 = *__error();
  v90 = _SILogForLogForCategory(16);
  v91 = 2 * (dword_1EF19FCCC < 4);
  if (os_log_type_enabled(v90, v91))
  {
    std::stringbuf::str();
    v92 = v207[7] >= 0 ? block : *(Boolean **)block;
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = v92;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v16;
    _os_log_impl(&dword_1B8270000, v90, v91, "training quantizer with %s vectors in %u partitions", buf, 0x12u);
    if ((v207[7] & 0x80000000) != 0)
      operator delete(*(void **)block);
  }
  *__error() = v89;
  Current = CFAbsoluteTimeGetCurrent();
  if (CFAbsoluteTimeGetCurrent() - Current >= v66)
  {
    v102 = 0;
    goto LABEL_169;
  }
  v94 = (sqrt((double)v17) / (double)v167);
  block[0] = 0;
  v95 = CFPreferencesGetAppIntegerValue(CFSTR("IVFSeedCentroidPerTraining"), CFSTR("com.apple.Spotlight"), block);
  if (block[0])
    v96 = v95;
  else
    v96 = 60;
  v165 = v94;
  v97 = 2 * (v94 - v16);
  if (v96 <= v97)
    v98 = v97;
  else
    v98 = v96;
  v177 = v170;
  v178 = v171;
  if (v171)
  {
    v99 = (unint64_t *)&v171->__shared_owners_;
    do
      v100 = __ldxr(v99);
    while (__stxr(v100 + 1, v99));
  }
  memset(buf, 0, 24);
  if (v172 == v10)
  {
    v101 = 0;
    goto LABEL_132;
  }
  if ((__sz & 0x8000000000000000) != 0)
LABEL_251:
    abort();
  v101 = (char *)operator new(__sz);
  *(_QWORD *)buf = v101;
  *(_QWORD *)&buf[16] = &v101[8 * v169];
  memcpy(v101, v10, __sz);
  *(_QWORD *)&buf[8] = &v101[8 * v169];
LABEL_132:
  block[0] = 0;
  v103 = CFPreferencesGetAppIntegerValue(CFSTR("IVFPartitionRecycleTheshold"), CFSTR("com.apple.Spotlight"), block);
  if (block[0])
    v104 = v103;
  else
    v104 = 3;
  v105 = IVFVectorIndexTemplate<float,512>::IVFVectorIndexRootBase::trainOnce(&v177, (std::string::size_type *)buf, v98, v104);
  if (v101)
  {
    *(_QWORD *)&buf[8] = v101;
    operator delete(v101);
  }
  if (v171)
  {
    v106 = (unint64_t *)&v171->__shared_owners_;
    do
      v107 = __ldaxr(v106);
    while (__stlxr(v107 - 1, v106));
    if (!v107)
    {
      ((void (*)(std::__shared_weak_count *))v171->__on_zero_shared)(v171);
      std::__shared_weak_count::__release_weak(v171);
    }
  }
  if (v105)
  {
    QuantizerManager<float,512>::lastTrainedQuantizer(block, v170);
    v108 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)block + 24))(*(_QWORD *)block);
    v109 = (std::__shared_weak_count *)v206;
    if (v206)
    {
      v110 = (unint64_t *)(v206 + 8);
      do
        v111 = __ldaxr(v110);
      while (__stlxr(v111 - 1, v110));
      if (!v111)
      {
        ((void (*)(std::__shared_weak_count *))v109->__on_zero_shared)(v109);
        std::__shared_weak_count::__release_weak(v109);
      }
    }
    if (v17 >= v167 * (unint64_t)v108 * v167 * (unint64_t)v108 / 0x64)
    {
      v112 = v171;
      v139 = (unint64_t *)&v171->__shared_owners_;
      v102 = 1;
      while (CFAbsoluteTimeGetCurrent() - Current < v66)
      {
        block[0] = 0;
        v140 = CFPreferencesGetAppIntegerValue(CFSTR("IVFSeedCentroidPerTraining"), CFSTR("com.apple.Spotlight"), block);
        if (block[0])
          v141 = v140;
        else
          v141 = 60;
        v142 = 2 * (v165 - v108);
        if (v141 <= v142)
          v143 = v142;
        else
          v143 = v141;
        v177 = v170;
        v178 = v112;
        if (v112)
        {
          do
            v144 = __ldxr(v139);
          while (__stxr(v144 + 1, v139));
        }
        memset(buf, 0, 24);
        if (v172 == v10)
        {
          v145 = 0;
        }
        else
        {
          if ((__sz & 0x8000000000000000) != 0)
            goto LABEL_251;
          v145 = (char *)operator new(__sz);
          *(_QWORD *)buf = v145;
          *(_QWORD *)&buf[16] = &v145[8 * v169];
          memcpy(v145, v10, __sz);
          *(_QWORD *)&buf[8] = &v145[8 * v169];
        }
        block[0] = 0;
        v146 = CFPreferencesGetAppIntegerValue(CFSTR("IVFPartitionRecycleTheshold"), CFSTR("com.apple.Spotlight"), block);
        if (block[0])
          v147 = v146;
        else
          v147 = 3;
        v148 = IVFVectorIndexTemplate<float,512>::IVFVectorIndexRootBase::trainOnce(&v177, (std::string::size_type *)buf, v143, v147);
        if (v145)
        {
          *(_QWORD *)&buf[8] = v145;
          operator delete(v145);
        }
        if (v171)
        {
          do
            v149 = __ldaxr(v139);
          while (__stlxr(v149 - 1, v139));
          if (!v149)
          {
            ((void (*)(std::__shared_weak_count *))v171->__on_zero_shared)(v171);
            std::__shared_weak_count::__release_weak(v171);
          }
        }
        ++v102;
        if (!v148)
          goto LABEL_169;
        QuantizerManager<float,512>::lastTrainedQuantizer(block, v170);
        v108 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)block + 24))(*(_QWORD *)block);
        v150 = (std::__shared_weak_count *)v206;
        if (v206)
        {
          v151 = (unint64_t *)(v206 + 8);
          do
            v152 = __ldaxr(v151);
          while (__stlxr(v152 - 1, v151));
          if (!v152)
          {
            ((void (*)(std::__shared_weak_count *))v150->__on_zero_shared)(v150);
            std::__shared_weak_count::__release_weak(v150);
          }
        }
        v112 = v171;
        if (v17 < v167 * (unint64_t)v108 * v167 * (unint64_t)v108 / 0x64)
          break;
      }
    }
    else
    {
      v102 = 1;
      v112 = v171;
    }
    v113 = (unint64_t *)&v112->__shared_owners_;
    while (1)
    {
      if (CFAbsoluteTimeGetCurrent() - Current >= v66)
        goto LABEL_169;
      v176[0] = v170;
      v176[1] = (uint64_t)v171;
      if (v171)
      {
        do
          v114 = __ldxr(v113);
        while (__stxr(v114 + 1, v113));
      }
      v173 = 0;
      v174 = 0;
      v175 = 0;
      if (v172 != v10)
        break;
      v116 = IVFVectorIndexTemplate<float,512>::IVFVectorIndexRootBase::trainOnce(v176, (std::string::size_type *)&v173, 0, 2u);
      if (v171)
        goto LABEL_159;
LABEL_162:
      ++v102;
      if (v116)
      {
        block[0] = 0;
        v118 = CFPreferencesGetAppIntegerValue(CFSTR("IVFMaxTrainingIteration"), CFSTR("com.apple.Spotlight"), block);
        v119 = block[0] ? v118 : 3;
        if (v102 <= v119)
          continue;
      }
      goto LABEL_169;
    }
    if ((__sz & 0x8000000000000000) != 0)
      goto LABEL_251;
    v115 = (char *)operator new(__sz);
    v173 = v115;
    v175 = &v115[8 * v169];
    memcpy(v115, v10, __sz);
    v174 = &v115[8 * v169];
    v116 = IVFVectorIndexTemplate<float,512>::IVFVectorIndexRootBase::trainOnce(v176, (std::string::size_type *)&v173, 0, 2u);
    v174 = v115;
    operator delete(v115);
    if (!v171)
      goto LABEL_162;
    do
LABEL_159:
      v117 = __ldaxr(v113);
    while (__stlxr(v117 - 1, v113));
    if (!v117)
    {
      ((void (*)(std::__shared_weak_count *))v171->__on_zero_shared)(v171);
      std::__shared_weak_count::__release_weak(v171);
    }
    goto LABEL_162;
  }
  v102 = 1;
LABEL_169:
  v120 = atomic_load(v67);
  if ((v120 & 1) == 0)
  {
    v160 = __si_assert_copy_extra_268();
    v154 = v160;
    v161 = "";
    if (v160)
      v161 = v160;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 794, "_training.test()", v161);
    goto LABEL_239;
  }
  if (*(_QWORD *)(v170 + 96))
  {
    v121 = *(NSObject **)(v170 + 16);
    *(_QWORD *)block = MEMORY[0x1E0C809B0];
    v206 = 0x40000000;
    *(_QWORD *)v207 = ___ZN16QuantizerManagerIfLi512EE23commitTrainingQuantizerEv_block_invoke;
    *(_QWORD *)&v207[8] = &__block_descriptor_tmp_688;
    *(_QWORD *)&v207[16] = v170;
    dispatch_sync(v121, block);
  }
  atomic_store(0, (unsigned __int8 *)(v170 + 72));
  QuantizerManager<float,512>::sharedQuantizer(block, v170, 0);
  v122 = (*(uint64_t (**)(_QWORD))(**(_QWORD **)block + 24))(*(_QWORD *)block);
  v123 = (std::__shared_weak_count *)v206;
  if (v206)
  {
    v124 = (unint64_t *)(v206 + 8);
    do
      v125 = __ldaxr(v124);
    while (__stlxr(v125 - 1, v124));
    if (!v125)
    {
      ((void (*)(std::__shared_weak_count *))v123->__on_zero_shared)(v123);
      std::__shared_weak_count::__release_weak(v123);
    }
  }
  v126 = _SILogForLogForCategory(0);
  if (v163 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    v127 = v126;
    if (os_signpost_enabled(v126))
    {
      *(_WORD *)block = 0;
      _os_signpost_emit_with_name_impl(&dword_1B8270000, v127, OS_SIGNPOST_INTERVAL_END, spid, "IVFVectorIndexTrain", "End", block, 2u);
    }
  }
  v128 = *__error();
  v129 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v129, OS_LOG_TYPE_DEFAULT))
  {
    v130 = CFAbsoluteTimeGetCurrent();
    *(_DWORD *)block = 67110144;
    *(_DWORD *)&block[4] = v17;
    LOWORD(v206) = 1024;
    *(_DWORD *)((char *)&v206 + 2) = v122;
    HIWORD(v206) = 1024;
    *(_DWORD *)v207 = v17 / v122;
    *(_WORD *)&v207[4] = 1024;
    *(_DWORD *)&v207[6] = v102;
    *(_WORD *)&v207[10] = 2048;
    *(double *)&v207[12] = v130 - Current;
    _os_log_impl(&dword_1B8270000, v129, OS_LOG_TYPE_DEFAULT, "training quantizer for %u vectors in %u partitions average size: %u for %u iterations duration: %fs", block, 0x24u);
  }
  *__error() = v128;
  *(_QWORD *)keyExistsAndHasValidFormat = *MEMORY[0x1E0DE4F50];
  v131 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 72);
  *(_QWORD *)&keyExistsAndHasValidFormat[*(_QWORD *)(*(_QWORD *)keyExistsAndHasValidFormat - 24)] = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 64);
  v181 = v131;
  *(_QWORD *)&v182[0] = MEMORY[0x1E0DE4FB8] + 16;
  if (SBYTE7(v184) < 0)
    operator delete((void *)__p);
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x1BCCB0650](&v186);
  v87 = v171;
  if (!v13)
  {
LABEL_109:
    v88 = v203;
    if (!v203)
      goto LABEL_198;
    goto LABEL_194;
  }
LABEL_187:
  while (v14 != v13)
  {
    v132 = (std::__shared_weak_count *)*((_QWORD *)v14 - 1);
    if (v132)
    {
      v133 = (unint64_t *)&v132->__shared_owners_;
      do
        v134 = __ldaxr(v133);
      while (__stlxr(v134 - 1, v133));
      if (!v134)
      {
        ((void (*)(std::__shared_weak_count *))v132->__on_zero_shared)(v132);
        std::__shared_weak_count::__release_weak(v132);
      }
    }
    v14 -= 16;
  }
  operator delete(v13);
  v88 = v203;
  if (v203)
  {
LABEL_194:
    v135 = (unint64_t *)&v88->__shared_owners_;
    do
      v136 = __ldaxr(v135);
    while (__stlxr(v136 - 1, v135));
    if (!v136)
    {
      ((void (*)(std::__shared_weak_count *))v88->__on_zero_shared)(v88);
      std::__shared_weak_count::__release_weak(v88);
    }
  }
LABEL_198:
  if (v10)
    operator delete(v10);
  if (v87)
  {
    v137 = (unint64_t *)&v87->__shared_owners_;
    do
      v138 = __ldaxr(v137);
    while (__stlxr(v138 - 1, v137));
    if (!v138)
    {
      ((void (*)(std::__shared_weak_count *))v87->__on_zero_shared)(v87);
      std::__shared_weak_count::__release_weak(v87);
    }
  }
}

void IVFVectorIndexTemplate<float,512>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::enumerator_s::next(uint64_t a1, uint64_t a2)
{
  uint64_t i;
  uint64_t v5;
  unsigned int *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  if (*(_QWORD *)(a2 + 72))
  {
    for (i = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + ((*(_QWORD *)(a2 + 64) >> 5) & 0x7FFFFFFFFFFFFF8))
                        + 16 * *(_QWORD *)(a2 + 64));
          ;
          i = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + ((v11 >> 5) & 0x7FFFFFFFFFFFFF8))
                        + 16 * v11))
    {
      *(_DWORD *)a1 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)i + 16))(i);
      if (!*(_QWORD *)(a2 + 72))
        break;
      v5 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + ((*(_QWORD *)(a2 + 64) >> 5) & 0x7FFFFFFFFFFFFF8))
                     + 16 * *(_QWORD *)(a2 + 64));
      v6 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 24))(v5);
      if (v6)
      {
        *(_DWORD *)(a1 + 4) = v6[1];
        v12 = _windowsResolvePtr(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 32) + 40, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 32) + 24)+ *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 32) + 16) * *v6, 0x810uLL);
        *(_DWORD *)(a1 + 8) = *(_DWORD *)(v12 + 2056);
        *(_QWORD *)(a1 + 16) = v12;
        *(_QWORD *)(a1 + 24) = v12 + 2048;
        return;
      }
      v7 = *(std::__shared_weak_count **)(*(_QWORD *)(*(_QWORD *)(a2 + 40)
                                                    + ((*(_QWORD *)(a2 + 64) >> 5) & 0x7FFFFFFFFFFFFF8))
                                        + 16 * *(_QWORD *)(a2 + 64)
                                        + 8);
      if (v7)
      {
        p_shared_owners = (unint64_t *)&v7->__shared_owners_;
        do
          v9 = __ldaxr(p_shared_owners);
        while (__stlxr(v9 - 1, p_shared_owners));
        if (!v9)
        {
          ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
          std::__shared_weak_count::__release_weak(v7);
        }
      }
      v10 = *(_QWORD *)(a2 + 72) - 1;
      v11 = *(_QWORD *)(a2 + 64) + 1;
      *(_QWORD *)(a2 + 64) = v11;
      *(_QWORD *)(a2 + 72) = v10;
      if (v11 >= 0x200)
      {
        operator delete(**(void ***)(a2 + 40));
        *(_QWORD *)(a2 + 40) += 8;
        v10 = *(_QWORD *)(a2 + 72);
        v11 = *(_QWORD *)(a2 + 64) - 256;
        *(_QWORD *)(a2 + 64) = v11;
      }
      if (!v10)
        return;
    }
  }
}

_DWORD *IVFVectorIndexTemplate<float,512>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::lookupForInsert(uint64_t a1, unsigned int a2, void *a3, uint64_t a4, char a5, float a6)
{
  uint64_t v9;
  unsigned int Vector;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  _DWORD *v16;
  const UInt8 *data;
  int v18;
  NSObject *v19;
  int v20;
  NSObject *v21;
  int v22;
  NSObject *v23;
  _BYTE *v24;
  int v25;
  NSObject *v26;
  _BYTE *v27;
  std::__shared_weak_count *v28;
  unint64_t *p_shared_owners;
  unint64_t v30;
  std::__shared_weak_count *v31;
  _DWORD *v32;
  unint64_t *v33;
  unint64_t v34;
  uint64_t v35;
  _QWORD *v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  NSObject *v44;
  const UInt8 *v45;
  int v46;
  NSObject *v47;
  size_t v48;
  int v49;
  NSObject *v50;
  int v51;
  NSObject *v52;
  _BYTE *v53;
  int v54;
  NSObject *v55;
  _BYTE *v56;
  NSObject *v57;
  int v58;
  NSObject *v59;
  int v60;
  int v61;
  char *v62;
  char *v63;
  const char *v64;
  char *v65;
  char *v66;
  const char *v67;
  uint64_t v68;
  uint64_t v69;
  unint64_t v70;
  unsigned int v71;
  unint64_t v72;
  uint64_t v73;
  unint64_t v74;
  int v75;
  NSObject *v76;
  _QWORD *v77;
  int v78;
  NSObject *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  _QWORD *v84;
  uint64_t v85;
  uint64_t v86;
  unint64_t v87;
  uint64_t v88;
  unint64_t v89;
  unint64_t *v90;
  unint64_t v91;
  unint64_t *v92;
  unint64_t v93;
  int v95;
  char *v96;
  const char *v97;
  char *v98;
  const char *v99;
  char *v100;
  const char *v101;
  char *v102;
  const char *v103;
  char *v104;
  const char *v105;
  std::__shared_weak_count *v106;
  unsigned int v107;
  void *__src;
  uint64_t v109;
  float v110;
  unsigned int v111;
  uint8_t buf[4];
  _BYTE *v113;
  _BYTE __p[12];
  __int16 v115;
  _BYTE v116[20];
  _BYTE v117[10];
  uint64_t v118;
  uint64_t v119;

  v119 = *MEMORY[0x1E0C80C00];
  v111 = a4;
  v110 = a6;
  if (*(_BYTE *)(a1 + 160))
  {
    v62 = __si_assert_copy_extra_268();
    v63 = v62;
    v64 = "";
    if (v62)
      v64 = v62;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2430, "!readOnly", v64);
    goto LABEL_121;
  }
  if ((a5 & 1) != 0)
  {
    v9 = a4;
    if ((_DWORD)a4 == -1)
      goto LABEL_79;
    goto LABEL_30;
  }
  Vector = IVFVectorIndexTemplate<float,512>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::findVector(a1, (uint64_t)a3, (int *)&v111, &v110, a2);
  v9 = v111;
  if (v111 == -1)
  {
LABEL_79:
    v65 = __si_assert_copy_extra_268();
    v66 = v65;
    v67 = "";
    if (v65)
      v67 = v65;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2435, "partID != VECTOR_NOT_FOUND", v67);
    goto LABEL_82;
  }
  if (Vector == -1)
  {
LABEL_30:
    __src = a3;
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 112));
    v28 = *(std::__shared_weak_count **)(a1 + 88);
    if (v28)
    {
      p_shared_owners = (unint64_t *)&v28->__shared_owners_;
      do
        v30 = __ldxr(p_shared_owners);
      while (__stxr(v30 + 1, p_shared_owners));
    }
    v106 = v28;
    v32 = *(_DWORD **)(a1 + 96);
    v31 = *(std::__shared_weak_count **)(a1 + 104);
    if (v31)
    {
      v33 = (unint64_t *)&v31->__shared_owners_;
      do
        v34 = __ldxr(v33);
      while (__stxr(v34 + 1, v33));
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 112));
    v35 = *(_QWORD *)(a1 + 48);
    v36 = *(_QWORD **)(v35 + 32);
    v37 = v36[2];
    v38 = v36[7];
    v39 = v38 + v37;
    v107 = a2;
    if (v38 + v37 >= v36[6])
    {
      if (!_storage_array_Expand((uint64_t)(v36 + 1)))
      {
        v40 = 0;
        if (v37 > 0x80F)
          goto LABEL_89;
        goto LABEL_38;
      }
      v38 = v36[7];
      v39 = v38 + v37;
    }
    v36[7] = v39;
    v40 = (v38 - v36[3]) / v37;
    if (v37 > 0x80F)
      goto LABEL_89;
LABEL_38:
    v41 = v36[2];
    if (v41 <= 0x80F)
    {
      LODWORD(v42) = 2064;
      do
      {
        v43 = v36[7] + v41;
        if (v43 >= v36[6])
        {
          if (!_storage_array_Expand((uint64_t)(v36 + 1)))
            goto LABEL_42;
          v43 = v36[7] + v41;
        }
        v36[7] = v43;
LABEL_42:
        v41 = v36[2];
        v42 = (v42 - v41);
      }
      while (v41 < v42);
    }
LABEL_89:
    v69 = (uint64_t)(v36 + 524);
    bit_vector_set_9027((uint64_t)(v36 + 524), (v40 >> 20));
    v70 = (v40 + 2064) >> 20;
    if (v70 > (v40 >> 20))
    {
      v71 = (v40 >> 20) + 1;
      do
      {
        v72 = v71;
        bit_vector_set_9027(v69, v71++);
      }
      while (v70 > v72);
    }
    v73 = *(unsigned int *)(v35 + 40);
    v74 = v40;
    if (v40 != v73)
    {
      v75 = *__error();
      v76 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v76, OS_LOG_TYPE_ERROR))
      {
        v95 = *(_DWORD *)(v35 + 40);
        *(_DWORD *)__p = 136315906;
        *(_QWORD *)&__p[4] = "newEntry";
        v115 = 1024;
        *(_DWORD *)v116 = 1779;
        *(_WORD *)&v116[4] = 2048;
        *(_QWORD *)&v116[6] = v40;
        *(_WORD *)&v116[14] = 1024;
        *(_DWORD *)&v116[16] = v95;
        _os_log_error_impl(&dword_1B8270000, v76, OS_LOG_TYPE_ERROR, "%s:%d: offset: %llu, nVectors: %u", __p, 0x22u);
      }
      *__error() = v75;
      v77 = *(_QWORD **)(v35 + 32);
      v78 = *__error();
      v79 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v79, OS_LOG_TYPE_DEFAULT))
      {
        v80 = v77[6];
        v81 = v77[7];
        v83 = v77[2];
        v82 = v77[3];
        *(_DWORD *)__p = 134219008;
        *(_QWORD *)&__p[4] = v77;
        v115 = 2048;
        *(_QWORD *)v116 = v80;
        *(_WORD *)&v116[8] = 2048;
        *(_QWORD *)&v116[10] = v81;
        *(_WORD *)&v116[18] = 2048;
        *(_QWORD *)v117 = v82;
        *(_WORD *)&v117[8] = 2048;
        v118 = v83;
        _os_log_impl(&dword_1B8270000, v79, OS_LOG_TYPE_DEFAULT, "vi_onefixedsize_disk_allocator %p size: %llu, freeRegion: %llu, header: %llu, elemSize: %lu", __p, 0x34u);
      }
      *__error() = v78;
      v74 = *(unsigned int *)(v35 + 40);
      LODWORD(v73) = *(_DWORD *)(v35 + 40);
    }
    if (v40 == v74)
    {
      *(_DWORD *)(v35 + 40) = v73 + 1;
      v84 = (_QWORD *)_windowsResolvePtr(*(_QWORD *)(v35 + 32) + 40, *(_QWORD *)(*(_QWORD *)(v35 + 32) + 24) + *(_QWORD *)(*(_QWORD *)(v35 + 32) + 16) * v40, 0x810uLL);
      memcpy(v84, __src, 0x800uLL);
      v84[256] = 0;
      (*(void (**)(_DWORD *, uint64_t, unint64_t, float))(*(_QWORD *)v32 + 56))(v32, v9, v40, v110);
      v85 = *(_QWORD *)(a1 + 48);
      if (v32[18] == *(_DWORD *)(v85 + 40))
      {
        v86 = v40;
        v87 = v40 >> 20;
        v88 = *(_QWORD *)(v85 + 32) + 4192;
        bit_vector_set_9027(v88, v87);
        v89 = ((unint64_t)v40 + 2064) >> 20;
        if (v89 > v87)
        {
          do
            bit_vector_set_9027(v88, ++v87);
          while (v89 != v87);
        }
        v16 = (_DWORD *)_windowsResolvePtr(*(_QWORD *)(v85 + 32) + 40, *(_QWORD *)(*(_QWORD *)(v85 + 32) + 24) + *(_QWORD *)(*(_QWORD *)(v85 + 32) + 16) * v86, 0x810uLL);
        v16[514] = v107;
        if (*(_DWORD *)(*(_QWORD *)(a1 + 48) + 40) == 1)
          *(_DWORD *)(a1 + 164) = v107;
        *(_DWORD *)(a1 + 168) = v107;
        data_map_set_offset_for_id(*(_QWORD *)(a1 + 144), v107, (16 * v86) | ((unint64_t)*(unsigned int *)(a1 + 40) << 36) | (4 * (*(_DWORD *)(a1 + 128) & 3)) | *(_DWORD *)(a1 + 124) & 3, *(unsigned __int16 *)(a1 + 120) | ((unint64_t)*(unsigned int *)(a1 + 132) << 32), *(_DWORD *)(a1 + 136));
        if (v31)
        {
          v90 = (unint64_t *)&v31->__shared_owners_;
          do
            v91 = __ldaxr(v90);
          while (__stlxr(v91 - 1, v90));
          if (!v91)
          {
            ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
            std::__shared_weak_count::__release_weak(v31);
          }
        }
        if (v106)
        {
          v92 = (unint64_t *)&v106->__shared_owners_;
          do
            v93 = __ldaxr(v92);
          while (__stlxr(v93 - 1, v92));
          if (!v93)
          {
            ((void (*)(std::__shared_weak_count *))v106->__on_zero_shared)(v106);
            std::__shared_weak_count::__release_weak(v106);
          }
        }
        return v16;
      }
      v98 = __si_assert_copy_extra_268();
      v63 = v98;
      v99 = "";
      if (v98)
        v99 = v98;
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2440, "cur.partitions->nVectors() == vectors->count()", v99);
    }
    else
    {
      v96 = __si_assert_copy_extra_268();
      v63 = v96;
      v97 = "";
      if (v96)
        v97 = v96;
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1782, "offset == nVectors", v97);
    }
LABEL_121:
    free(v63);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v11 = *(_QWORD *)(a1 + 48);
  v12 = Vector;
  v13 = (unint64_t)Vector >> 20;
  v14 = *(_QWORD *)(v11 + 32) + 4192;
  bit_vector_set_9027(v14, v13);
  v15 = (unint64_t)(v12 + 2064) >> 20;
  if (v15 > v13)
  {
    do
      bit_vector_set_9027(v14, ++v13);
    while (v15 != v13);
  }
  v16 = (_DWORD *)_windowsResolvePtr(*(_QWORD *)(v11 + 32) + 40, *(_QWORD *)(*(_QWORD *)(v11 + 32) + 24) + *(_QWORD *)(*(_QWORD *)(v11 + 32) + 16) * v12, 0x810uLL);
  if (v16[514] != a2)
  {
    v109 = 0;
    data = data_map_get_data(*(_QWORD *)(a1 + 144), a2, &v109);
    v18 = *__error();
    v19 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__p = 136316162;
      *(_QWORD *)&__p[4] = "lookupForInsert";
      v115 = 1024;
      *(_DWORD *)v116 = 2463;
      *(_WORD *)&v116[4] = 1024;
      *(_DWORD *)&v116[6] = a2;
      *(_WORD *)&v116[10] = 2048;
      *(_QWORD *)&v116[12] = data;
      *(_WORD *)v117 = 2048;
      *(_QWORD *)&v117[2] = v109;
      _os_log_error_impl(&dword_1B8270000, v19, OS_LOG_TYPE_ERROR, "%s:%d: vectorId=%u in datamap: %p size=%zd", __p, 0x2Cu);
    }
    *__error() = v18;
    if (v109 < 1)
    {
      v25 = *__error();
      v44 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__p = 136315394;
        *(_QWORD *)&__p[4] = "lookupForInsert";
        v115 = 1024;
        *(_DWORD *)v116 = 2472;
        _os_log_error_impl(&dword_1B8270000, v44, OS_LOG_TYPE_ERROR, "%s:%d: vectorId is invalid", __p, 0x12u);
      }
    }
    else
    {
      if (v109 != 2048)
      {
        v102 = __si_assert_copy_extra_268();
        v63 = v102;
        v103 = "";
        if (v102)
          v103 = v102;
        __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2465, "size == D * sizeof(ELEM_TYPE)", v103);
        goto LABEL_121;
      }
      if (!data || !memcmp(data, a3, 0x800uLL))
      {
LABEL_49:
        v45 = data_map_get_data(*(_QWORD *)(a1 + 144), v16[514], &v109);
        v46 = *__error();
        v47 = _SILogForLogForCategory(16);
        if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
        {
          v60 = v16[514];
          *(_DWORD *)__p = 136316162;
          *(_QWORD *)&__p[4] = "lookupForInsert";
          v115 = 1024;
          *(_DWORD *)v116 = 2475;
          *(_WORD *)&v116[4] = 1024;
          *(_DWORD *)&v116[6] = v60;
          *(_WORD *)&v116[10] = 2048;
          *(_QWORD *)&v116[12] = v45;
          *(_WORD *)v117 = 2048;
          *(_QWORD *)&v117[2] = v109;
          _os_log_error_impl(&dword_1B8270000, v47, OS_LOG_TYPE_ERROR, "%s:%d: old vectorId=%u in datamap: %p size=%zd", __p, 0x2Cu);
        }
        *__error() = v46;
        if (v109 < 1)
        {
          v54 = *__error();
          v57 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)__p = 136315394;
            *(_QWORD *)&__p[4] = "lookupForInsert";
            v115 = 1024;
            *(_DWORD *)v116 = 2484;
            _os_log_error_impl(&dword_1B8270000, v57, OS_LOG_TYPE_ERROR, "%s:%d: old vectorId is invalid", __p, 0x12u);
          }
        }
        else
        {
          if (v109 != 2048)
          {
            v104 = __si_assert_copy_extra_268();
            v63 = v104;
            v105 = "";
            if (v104)
              v105 = v104;
            __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2477, "size == D * sizeof(ELEM_TYPE)", v105);
            goto LABEL_121;
          }
          v48 = 2048;
          if (!v45 || !memcmp(v45, v16, 0x800uLL))
            goto LABEL_72;
          v49 = *__error();
          v50 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)__p = 136315394;
            *(_QWORD *)&__p[4] = "lookupForInsert";
            v115 = 1024;
            *(_DWORD *)v116 = 2479;
            _os_log_error_impl(&dword_1B8270000, v50, OS_LOG_TYPE_ERROR, "%s:%d: vector in datamap is not same as vector passed in", __p, 0x12u);
          }
          *__error() = v49;
          v51 = *__error();
          v52 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
          {
            data2hexString(__p, (uint64_t)v45, v109);
            v53 = v116[9] >= 0 ? __p : *(_BYTE **)__p;
            *(_DWORD *)buf = 136315138;
            v113 = v53;
            _os_log_impl(&dword_1B8270000, v52, OS_LOG_TYPE_DEFAULT, "vector in datamap: %s", buf, 0xCu);
            if ((v116[9] & 0x80000000) != 0)
              operator delete(*(void **)__p);
          }
          *__error() = v51;
          v54 = *__error();
          v55 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
          {
            data2hexString(__p, (uint64_t)v16, v109);
            v56 = v116[9] >= 0 ? __p : *(_BYTE **)__p;
            *(_DWORD *)buf = 136315138;
            v113 = v56;
            _os_log_impl(&dword_1B8270000, v55, OS_LOG_TYPE_DEFAULT, "vector in vector store: %s", buf, 0xCu);
            if ((v116[9] & 0x80000000) != 0)
              operator delete(*(void **)__p);
          }
        }
        *__error() = v54;
        v48 = v109;
LABEL_72:
        if (memcmp(a3, v16, v48))
        {
          v100 = __si_assert_copy_extra_268();
          v66 = v100;
          v101 = "";
          if (v100)
            v101 = v100;
          __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2486, "memcmp(vec.vec, entry->vec.vec, size) == 0", v101);
LABEL_82:
          free(v66);
          if (__valid_fs(-1))
            v68 = 2989;
          else
            v68 = 3072;
          *(_DWORD *)v68 = -559038737;
          abort();
        }
        v58 = *__error();
        v59 = _SILogForLogForCategory(16);
        if (os_log_type_enabled(v59, OS_LOG_TYPE_FAULT))
        {
          v61 = v16[514];
          *(_DWORD *)__p = 136315906;
          *(_QWORD *)&__p[4] = "lookupForInsert";
          v115 = 1024;
          *(_DWORD *)v116 = 2487;
          *(_WORD *)&v116[4] = 1024;
          *(_DWORD *)&v116[6] = a2;
          *(_WORD *)&v116[10] = 1024;
          *(_DWORD *)&v116[12] = v61;
          _os_log_fault_impl(&dword_1B8270000, v59, OS_LOG_TYPE_FAULT, "%s:%d: Dup vector with new vectorId=%u old=%u", __p, 0x1Eu);
        }
        *__error() = v58;
        return v16;
      }
      v20 = *__error();
      v21 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__p = 136315394;
        *(_QWORD *)&__p[4] = "lookupForInsert";
        v115 = 1024;
        *(_DWORD *)v116 = 2467;
        _os_log_error_impl(&dword_1B8270000, v21, OS_LOG_TYPE_ERROR, "%s:%d: vector in datamap is not same as vector passed in", __p, 0x12u);
      }
      *__error() = v20;
      v22 = *__error();
      v23 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        data2hexString(__p, (uint64_t)data, v109);
        v24 = v116[9] >= 0 ? __p : *(_BYTE **)__p;
        *(_DWORD *)buf = 136315138;
        v113 = v24;
        _os_log_impl(&dword_1B8270000, v23, OS_LOG_TYPE_DEFAULT, "vector in datamap: %s", buf, 0xCu);
        if ((v116[9] & 0x80000000) != 0)
          operator delete(*(void **)__p);
      }
      *__error() = v22;
      v25 = *__error();
      v26 = _SILogForLogForCategory(16);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        data2hexString(__p, (uint64_t)a3, v109);
        v27 = v116[9] >= 0 ? __p : *(_BYTE **)__p;
        *(_DWORD *)buf = 136315138;
        v113 = v27;
        _os_log_impl(&dword_1B8270000, v26, OS_LOG_TYPE_DEFAULT, "vector passed in: %s", buf, 0xCu);
        if ((v116[9] & 0x80000000) != 0)
          operator delete(*(void **)__p);
      }
    }
    *__error() = v25;
    goto LABEL_49;
  }
  return v16;
}

uint64_t IVFVectorIndexTemplate<float,512>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::findVector(uint64_t a1, uint64_t a2, int *a3, _DWORD *a4, int a5)
{
  os_unfair_lock_s *v10;
  std::__shared_weak_count *v11;
  uint64_t v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  std::__shared_weak_count *v15;
  _DWORD *v16;
  unint64_t *v17;
  unint64_t v18;
  uint64_t v19;
  _DWORD *v20;
  unsigned int v21;
  uint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  unint64_t *v25;
  unint64_t v26;
  char *v28;
  char *v29;
  const char *v30;
  char *v31;
  const char *v32;
  char *v33;
  char *v34;
  const char *v35;
  int v36;
  int v37;
  int v38;
  int v39;
  _QWORD v40[8];
  int v41;
  _DWORD *v42;
  char *v43;
  uint64_t v44;
  int v45;

  v10 = (os_unfair_lock_s *)(a1 + 112);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 112));
  v12 = *(_QWORD *)(a1 + 80);
  v11 = *(std::__shared_weak_count **)(a1 + 88);
  if (v11)
  {
    p_shared_owners = (unint64_t *)&v11->__shared_owners_;
    do
      v14 = __ldxr(p_shared_owners);
    while (__stxr(v14 + 1, p_shared_owners));
  }
  v16 = *(_DWORD **)(a1 + 96);
  v15 = *(std::__shared_weak_count **)(a1 + 104);
  if (v15)
  {
    v17 = (unint64_t *)&v15->__shared_owners_;
    do
      v18 = __ldxr(v17);
    while (__stxr(v18 + 1, v17));
  }
  os_unfair_lock_unlock(v10);
  v19 = *a3;
  if ((_DWORD)v19 == -1)
  {
    if (*(_DWORD *)(a1 + 156) == -1)
    {
      v42 = 0;
      v43 = 0;
      v44 = 0;
      (*(void (**)(_DWORD **__return_ptr, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v12 + 72))(&v42, v12, a2, 1);
      v20 = v42;
      if (v43 - (char *)v42 == 8)
      {
        v21 = *v42;
        *a3 = *v42;
        *a4 = v20[1];
        if (v21 >= IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nPartitions(a1))
        {
          v33 = __si_assert_copy_extra_268();
          v34 = v33;
          if (v33)
            v35 = v33;
          else
            v35 = "";
          v36 = *a3;
          v37 = IVFVectorIndexTemplate<float,768>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::nPartitions(a1);
          v38 = v16[19];
          v39 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v12 + 16))(v12);
          __message_assert("%s:%u: failed assertion '%s' %s Invalid partId %u >= %u (partitions: v%u quantizer v%u", "IVFVectorIndex.hh", 2403, "partID < nPartitions()", v35, v36, v37, v38, v39);
          free(v34);
          if (__valid_fs(-1))
          {
            MEMORY[0xBAD] = -559038737;
            abort();
          }
          MEMORY[0xC00] = -559038737;
          abort();
        }
        if (v42)
        {
          v43 = (char *)v42;
          operator delete(v42);
        }
        v19 = *a3;
        goto LABEL_14;
      }
      v31 = __si_assert_copy_extra_268();
      v29 = v31;
      v32 = "";
      if (v31)
        v32 = v31;
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2398, "topPartition.size() == 1", v32);
    }
    else
    {
      v28 = __si_assert_copy_extra_268();
      v29 = v28;
      v30 = "";
      if (v28)
        v30 = v28;
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2396, "mergeBeginVectorOffset == VECTOR_NOT_FOUND", v30);
    }
    free(v29);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
LABEL_14:
  v42 = 0;
  v43 = (char *)&v42;
  v45 = -1;
  v44 = 0x2000000000;
  v40[0] = MEMORY[0x1E0C809B0];
  v40[1] = 0x40000000;
  v40[2] = ___ZN22IVFVectorIndexTemplateIfLi512EE20IVFVectorIndexRoot_sI30vi_onefixedsize_disk_allocator16vi_disk_postingsE10findVectorERK10CIVector_sIfLi512EERjRfj_block_invoke;
  v40[3] = &unk_1E6E32D88;
  v41 = a5;
  v40[6] = a4;
  v40[7] = a2;
  v40[4] = &v42;
  v40[5] = a1;
  (*(void (**)(_DWORD *, uint64_t, _QWORD *))(*(_QWORD *)v16 + 80))(v16, v19, v40);
  v22 = *((unsigned int *)v43 + 6);
  _Block_object_dispose(&v42, 8);
  if (v15)
  {
    v23 = (unint64_t *)&v15->__shared_owners_;
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 - 1, v23));
    if (!v24)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  if (v11)
  {
    v25 = (unint64_t *)&v11->__shared_owners_;
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 - 1, v25));
    if (!v26)
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  return v22;
}

unint64_t ___ZN22IVFVectorIndexTemplateIfLi512EE20IVFVectorIndexRoot_sI30vi_onefixedsize_disk_allocator16vi_disk_postingsE10findVectorERK10CIVector_sIfLi512EERjRfj_block_invoke(unint64_t result, uint64_t a2, float *a3, _BYTE *a4)
{
  uint64_t v5;
  uint64_t v6;
  unint64_t v8;
  float v9;
  float v10;
  BOOL v11;
  float v12;
  float v13;
  int v15;
  const void *v16;
  const void *v17;

  v5 = *(_QWORD *)(result + 40);
  v6 = *(unsigned int *)a3;
  if (v6 >= *(_DWORD *)(v5 + 156))
    goto LABEL_12;
  v8 = result;
  v9 = **(float **)(result + 48);
  v10 = a3[1];
  v11 = v9 == v10;
  v12 = vabds_f32(v9, v10);
  v13 = fmaxf(fminf(fabsf(v10), fabsf(v9)) * 0.000015259, 0.000015259);
  if (v11 || v12 <= v13)
  {
    v15 = *(_DWORD *)(result + 64);
    if (v15)
    {
      result = _windowsResolvePtr(*(_QWORD *)(*(_QWORD *)(v5 + 48) + 32) + 40, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 48) + 32) + 24)+ *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 48) + 32) + 16) * v6, 0x810uLL);
      if (v15 != *(_DWORD *)(result + 2056))
        return result;
      *(float *)&v6 = *a3;
    }
    v16 = *(const void **)(v8 + 56);
    v17 = (const void *)_windowsResolvePtr(*(_QWORD *)(*(_QWORD *)(v5 + 48) + 32) + 40, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 48) + 32) + 24)+ *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v5 + 48) + 32) + 16) * v6, 0x810uLL);
    result = memcmp(v16, v17, 0x800uLL);
    if (!(_DWORD)result)
    {
      *(float *)(*(_QWORD *)(*(_QWORD *)(v8 + 32) + 8) + 24) = *a3;
LABEL_12:
      *a4 = 1;
    }
  }
  return result;
}

uint64_t IVFVectorIndexTemplate<float,512>::IVFVectorIndexRootBase::trainOnce(uint64_t *a1, std::string::size_type *a2, uint64_t a3, unsigned int a4)
{
  double Current;
  std::string::size_type v7;
  uint64_t v8;
  void *v9;
  int v10;
  uint64_t v11;
  size_t v12;
  uint64_t v13;
  std::__shared_weak_count *v14;
  uint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *p_shared_owners;
  unint64_t v20;
  std::__shared_weak_count *v21;
  int v22;
  unint64_t *v23;
  unint64_t v24;
  uint64_t v25;
  unsigned __int8 v26;
  NSObject *v27;
  uint64_t v28;
  int v29;
  int v30;
  size_t v31;
  unint64_t v32;
  std::string *v33;
  uint64_t v34;
  uint64_t v35;
  const void *v36;
  int v37;
  std::string *v38;
  std::string::size_type size;
  std::string *v40;
  std::string::size_type v41;
  std::string *v42;
  std::string::size_type v43;
  const char *v44;
  _QWORD *FdPtrForFile;
  _QWORD *v46;
  uint64_t v47;
  std::__shared_weak_count *v48;
  std::__shared_weak_count *v49;
  unint64_t *v50;
  unint64_t v51;
  unint64_t *v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t *v56;
  char *v57;
  char *v58;
  size_t v59;
  std::__shared_weak_count *v60;
  unint64_t *v61;
  unint64_t v62;
  _BYTE *v63;
  _BYTE *v64;
  _QWORD *v65;
  size_t v66;
  char *v67;
  char *v68;
  char *v69;
  uint64_t v70;
  uint64_t v71;
  unint64_t v72;
  unint64_t v73;
  char *v74;
  char *v75;
  uint64_t *v76;
  char *v77;
  __int128 v78;
  int v79;
  NSObject *v80;
  std::__shared_weak_count *v81;
  uint64_t v82;
  char *v83;
  char *v84;
  uint64_t v85;
  const void *v86;
  _BYTE *v87;
  _BYTE *v88;
  _BYTE *v89;
  int64_t v90;
  unint64_t v91;
  uint64_t v92;
  unint64_t v93;
  std::__shared_weak_count *v94;
  char *v95;
  char *v96;
  uint64_t v97;
  uint64_t v98;
  int64_t v99;
  uint64_t v100;
  BOOL v101;
  uint64_t *v102;
  __int128 v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t *v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t *v109;
  uint64_t *v110;
  uint64_t *v111;
  uint64_t v112;
  char *v113;
  char *v114;
  char *v115;
  void *v116;
  void *v117;
  std::__shared_weak_count_vtbl *v118;
  std::__shared_weak_count_vtbl *v119;
  std::__shared_weak_count *v120;
  __int128 v121;
  unint64_t *v122;
  uint64_t v123;
  size_t v124;
  uint64_t v125;
  uint64_t v126;
  unint64_t v127;
  std::__shared_weak_count *v128;
  unint64_t *v129;
  unint64_t v130;
  std::__shared_weak_count *v131;
  unint64_t *v132;
  unint64_t v133;
  int v134;
  int v135;
  std::string::size_type v136;
  uint64_t v137;
  int v138;
  uint64_t v139;
  uint64_t v140;
  const void *v141;
  const void *v142;
  uint64_t v143;
  float *v144;
  float v145;
  _QWORD *v146;
  unint64_t v147;
  uint64_t v148;
  uint64_t v149;
  unint64_t v150;
  unint64_t v151;
  unint64_t v152;
  unint64_t v153;
  int v154;
  int v155;
  NSObject *v156;
  unsigned int v157;
  uint64_t v158;
  unint64_t v159;
  unsigned int v160;
  unint64_t v161;
  void *v162;
  size_t v163;
  __int128 *v164;
  std::string::size_type v165;
  std::__shared_weak_count *v166;
  unint64_t *v167;
  unint64_t v168;
  std::string::size_type v169;
  unint64_t v170;
  unint64_t *v171;
  uint64_t v172;
  unint64_t v173;
  __int128 v174;
  unint64_t *v175;
  unint64_t v176;
  std::__shared_weak_count *v177;
  unint64_t *v178;
  unint64_t v179;
  std::__shared_weak_count *v180;
  unint64_t *v181;
  unint64_t v182;
  int v183;
  std::__shared_weak_count *v184;
  int v185;
  unint64_t *v186;
  unint64_t v187;
  int v188;
  NSObject *v189;
  int v190;
  int v191;
  CFAbsoluteTime v192;
  std::__shared_weak_count *v193;
  unint64_t *v194;
  unint64_t v195;
  __int128 *v196;
  std::__shared_weak_count *v197;
  unint64_t *v198;
  unint64_t v199;
  unint64_t v200;
  std::__shared_weak_count *v201;
  unint64_t *v202;
  unint64_t v203;
  std::__shared_weak_count *v204;
  unint64_t *v205;
  unint64_t v206;
  int64_t v208;
  uint64_t v209;
  uint64_t *v210;
  __int128 v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t *v214;
  _BYTE *v215;
  int v216;
  char *v217;
  char *v218;
  const char *v219;
  uint64_t v220;
  char *v221;
  char *v222;
  const char *v223;
  char *v224;
  const char *v225;
  char *v226;
  const char *v227;
  char *v228;
  const char *v229;
  char *v230;
  const char *v231;
  char *v232;
  const char *v233;
  __int128 v234;
  uint64_t v235;
  size_t v236;
  std::string::size_type v237;
  std::string::size_type v238;
  uint64_t v239;
  int v240;
  unsigned int v241;
  std::__shared_weak_count *v242;
  _DWORD *v243;
  unint64_t v244;
  std::__shared_weak_count *v245;
  std::string::size_type v246;
  int v247;
  std::string::size_type *v248;
  __int128 v249;
  std::string::size_type v250;
  std::__shared_weak_count *v251;
  std::string v252;
  std::__shared_weak_count *v253;
  _QWORD v254[7];
  std::__shared_weak_count *v255;
  int v256;
  int v257;
  _BYTE v258[24];
  __int128 v259;
  _BYTE *v260;
  _BYTE *v261;
  unint64_t v262;
  uint64_t v263;
  std::__shared_weak_count *v264;
  std::string v265;
  _BYTE v266[1000];
  uint64_t v267;

  v241 = a4;
  v239 = a3;
  v267 = *MEMORY[0x1E0C80C00];
  Current = CFAbsoluteTimeGetCurrent();
  v263 = 0;
  v264 = 0;
  QuantizerManager<float,512>::lastTrainedQuantizer(&v263, *a1);
  v7 = a2[1];
  v237 = *a2;
  v238 = v7;
  v8 = v7 - v237;
  if (v7 == v237)
  {
    v9 = 0;
  }
  else
  {
    if (v8 < 0)
      goto LABEL_322;
    v9 = operator new((unint64_t)v8 >> 1);
    bzero(v9, (unint64_t)v8 >> 1);
  }
  v235 = v8;
  v236 = v8 >> 3;
  v10 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v263 + 24))(v263);
  if (v238 != v237)
  {
    v11 = 0;
    if (v236 <= 1)
      v12 = 1;
    else
      v12 = v236;
    while (1)
    {
      (*(void (**)(_BYTE *__return_ptr))(**(_QWORD **)(*a2 + 8 * v11) + 16))(v266);
      v13 = v263;
      v15 = *(_QWORD *)v266;
      v14 = *(std::__shared_weak_count **)&v266[8];
      if (*(_QWORD *)&v266[8])
      {
        v16 = (unint64_t *)(*(_QWORD *)&v266[8] + 8);
        do
          v17 = __ldaxr(v16);
        while (__stlxr(v17 - 1, v16));
        if (!v17)
        {
          ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
          std::__shared_weak_count::__release_weak(v14);
        }
      }
      if (v15 != v13)
        break;
      (*(void (**)(_BYTE *__return_ptr))(**(_QWORD **)(*a2 + 8 * v11) + 24))(v266);
      v18 = *(std::__shared_weak_count **)&v266[8];
      *((_DWORD *)v9 + v11) = *(_DWORD *)(*(_QWORD *)v266 + 72);
      if (v18)
      {
        p_shared_owners = (unint64_t *)&v18->__shared_owners_;
        do
          v20 = __ldaxr(p_shared_owners);
        while (__stlxr(v20 - 1, p_shared_owners));
        if (!v20)
        {
          ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
          std::__shared_weak_count::__release_weak(v18);
        }
      }
      (*(void (**)(_BYTE *__return_ptr))(**(_QWORD **)(*a2 + 8 * v11) + 24))(v266);
      v21 = *(std::__shared_weak_count **)&v266[8];
      v22 = *(_DWORD *)(*(_QWORD *)v266 + 68);
      if (*(_QWORD *)&v266[8])
      {
        v23 = (unint64_t *)(*(_QWORD *)&v266[8] + 8);
        do
          v24 = __ldaxr(v23);
        while (__stlxr(v24 - 1, v23));
        if (!v24)
        {
          ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
          std::__shared_weak_count::__release_weak(v21);
        }
      }
      if (v22 != v10)
      {
        v221 = __si_assert_copy_extra_268();
        v222 = v221;
        v223 = "";
        if (v221)
          v223 = v221;
        __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1967, "vectorIndexes[i]->getPartitions()->nPartitions() == nPartitions", v223);
LABEL_316:
        free(v222);
        if (__valid_fs(-1))
        {
          MEMORY[0xBAD] = -559038737;
          abort();
        }
        MEMORY[0xC00] = -559038737;
        abort();
      }
      if (++v11 == v12)
        goto LABEL_27;
    }
    v217 = __si_assert_copy_extra_268();
    v218 = v217;
    v219 = "";
    if (v217)
      v219 = v217;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1965, "vectorIndexes[i]->getQuantizer() == quantizer", v219);
LABEL_297:
    free(v218);
    if (__valid_fs(-1))
      v220 = 2989;
    else
      v220 = 3072;
    *(_DWORD *)v220 = -559038737;
    abort();
  }
LABEL_27:
  v25 = *a1;
  v26 = atomic_load((unsigned __int8 *)(v25 + 72));
  if ((v26 & 1) == 0)
  {
    v232 = __si_assert_copy_extra_268();
    v218 = v232;
    v233 = "";
    if (v232)
      v233 = v232;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 752, "_training.test()", v233);
    goto LABEL_297;
  }
  if (*(_QWORD *)(v25 + 96))
  {
    v27 = *(NSObject **)(v25 + 16);
    *(_QWORD *)v266 = MEMORY[0x1E0C809B0];
    *(_QWORD *)&v266[8] = 0x40000000;
    *(_QWORD *)&v266[16] = ___ZN16QuantizerManagerIfLi512EE23commitTrainingQuantizerEv_block_invoke;
    *(_QWORD *)&v266[24] = &__block_descriptor_tmp_688;
    *(_QWORD *)&v266[32] = v25;
    dispatch_sync(v27, v266);
  }
  v28 = *(_QWORD *)(v25 + 80);
  v247 = v10;
  if (v28)
    v29 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v28 + 16))(v28) + 1;
  else
    v29 = 1;
  v30 = *(char *)(v25 + 71);
  if (v30 >= 0)
    v31 = *(unsigned __int8 *)(v25 + 71);
  else
    v31 = *(_QWORD *)(v25 + 56);
  v32 = v31 + 1;
  if (v31 + 1 >= 0x7FFFFFFFFFFFFFF8)
LABEL_322:
    abort();
  if (v32 >= 0x17)
  {
    v34 = (v32 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v32 | 7) != 0x17)
      v34 = v32 | 7;
    v35 = v34 + 1;
    v33 = (std::string *)operator new(v34 + 1);
    v252.__r_.__value_.__l.__size_ = v31 + 1;
    v252.__r_.__value_.__r.__words[2] = v35 | 0x8000000000000000;
    v252.__r_.__value_.__r.__words[0] = (std::string::size_type)v33;
  }
  else
  {
    memset(&v252, 0, sizeof(v252));
    v33 = &v252;
    *((_BYTE *)&v252.__r_.__value_.__s + 23) = v31 + 1;
    if (!v31)
      goto LABEL_47;
  }
  if (v30 >= 0)
    v36 = (const void *)(v25 + 48);
  else
    v36 = *(const void **)(v25 + 48);
  memmove(v33, v36, v31);
LABEL_47:
  v37 = v247;
  *(_WORD *)((char *)&v33->__r_.__value_.__l.__data_ + v31) = 46;
  std::to_string(&v265, v29);
  if ((v265.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v38 = &v265;
  else
    v38 = (std::string *)v265.__r_.__value_.__r.__words[0];
  if ((v265.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(v265.__r_.__value_.__r.__words[2]);
  else
    size = v265.__r_.__value_.__l.__size_;
  v40 = std::string::append(&v252, (const std::string::value_type *)v38, size);
  v41 = v40->__r_.__value_.__r.__words[2];
  *(_OWORD *)v266 = *(_OWORD *)&v40->__r_.__value_.__l.__data_;
  *(_QWORD *)&v266[16] = v41;
  v40->__r_.__value_.__l.__size_ = 0;
  v40->__r_.__value_.__r.__words[2] = 0;
  v40->__r_.__value_.__r.__words[0] = 0;
  v42 = std::string::append((std::string *)v266, ".quantizer");
  v43 = v42->__r_.__value_.__r.__words[2];
  *(_OWORD *)v258 = *(_OWORD *)&v42->__r_.__value_.__l.__data_;
  *(_QWORD *)&v258[16] = v43;
  v42->__r_.__value_.__l.__size_ = 0;
  v42->__r_.__value_.__r.__words[2] = 0;
  v42->__r_.__value_.__r.__words[0] = 0;
  if ((v266[23] & 0x80000000) == 0)
  {
    if ((SHIBYTE(v265.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_55;
LABEL_107:
    operator delete(v265.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v252.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_56;
    goto LABEL_108;
  }
  operator delete(*(void **)v266);
  if (SHIBYTE(v265.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_107;
LABEL_55:
  if ((SHIBYTE(v252.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    goto LABEL_56;
LABEL_108:
  operator delete(v252.__r_.__value_.__l.__data_);
LABEL_56:
  if (v258[23] >= 0)
    v44 = v258;
  else
    v44 = *(const char **)v258;
  FdPtrForFile = QuantizerManager<float,768>::createFdPtrForFile(v25, v44);
  if (FdPtrForFile)
  {
    v46 = FdPtrForFile;
    v47 = operator new();
    *(_QWORD *)v266 = v46;
    *(_QWORD *)&v266[8] = 0x1000000;
    *(_DWORD *)&v266[16] = 0;
    *(_DWORD *)&v266[20] = 65792;
    *(_DWORD *)&v266[24] = v29;
    *(_DWORD *)&v266[28] = 0;
    AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,512>::AllocatedVectorQuantizer(v47, (uint64_t)v266);
    v48 = (std::__shared_weak_count *)operator new();
    v48->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6E32CA8;
    v48->__shared_owners_ = 0;
    v48->__shared_weak_owners_ = 0;
    v48[1].__vftable = (std::__shared_weak_count_vtbl *)v47;
    v49 = *(std::__shared_weak_count **)(v25 + 104);
    *(_QWORD *)(v25 + 96) = v47;
    *(_QWORD *)(v25 + 104) = v48;
    if (v49)
    {
      v50 = (unint64_t *)&v49->__shared_owners_;
      do
        v51 = __ldaxr(v50);
      while (__stlxr(v51 - 1, v50));
      if (v51)
      {
        v47 = *(_QWORD *)(v25 + 96);
        v48 = *(std::__shared_weak_count **)(v25 + 104);
        if (v48)
          goto LABEL_65;
      }
      else
      {
        ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
        std::__shared_weak_count::__release_weak(v49);
        v47 = *(_QWORD *)(v25 + 96);
        v48 = *(std::__shared_weak_count **)(v25 + 104);
        if (v48)
          goto LABEL_65;
      }
      v245 = 0;
      if ((v258[23] & 0x80000000) == 0)
        goto LABEL_68;
      goto LABEL_111;
    }
LABEL_65:
    v245 = v48;
    v52 = (unint64_t *)&v48->__shared_owners_;
    do
      v53 = __ldxr(v52);
    while (__stxr(v53 + 1, v52));
    if ((v258[23] & 0x80000000) == 0)
      goto LABEL_68;
    goto LABEL_111;
  }
  v79 = *__error();
  v80 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v80, OS_LOG_TYPE_FAULT))
  {
    v215 = v258;
    if (v258[23] < 0)
      v215 = *(_BYTE **)v258;
    v216 = *(_DWORD *)v25;
    *(_DWORD *)v266 = 136315906;
    *(_QWORD *)&v266[4] = "newQuantizer";
    *(_WORD *)&v266[12] = 1024;
    *(_DWORD *)&v266[14] = 772;
    *(_WORD *)&v266[18] = 2080;
    *(_QWORD *)&v266[20] = v215;
    *(_WORD *)&v266[28] = 1024;
    *(_DWORD *)&v266[30] = v216;
    _os_log_fault_impl(&dword_1B8270000, v80, OS_LOG_TYPE_FAULT, "%s:%d: Failed to create %s in parentFd: %i", v266, 0x22u);
  }
  v47 = 0;
  v245 = 0;
  *__error() = v79;
  if ((v258[23] & 0x80000000) == 0)
  {
LABEL_68:
    if (v47)
      goto LABEL_69;
LABEL_112:
    v81 = v245;
    goto LABEL_272;
  }
LABEL_111:
  operator delete(*(void **)v258);
  if (!v47)
    goto LABEL_112;
LABEL_69:
  v248 = a2;
  v243 = v9;
  v259 = 0u;
  *(_OWORD *)&v258[8] = 0u;
  *(_QWORD *)v258 = off_1E6E32D30;
  v260 = 0;
  v261 = 0;
  v262 = 0;
  bzero(v266, 0x400uLL);
  snprintf(v266, 0x400uLL, "A0-%ux%dx%u", v239, 512, 32);
  MEMORY[0x1BCCB03B0](&v258[8], v266);
  v246 = v47;
  v54 = MEMORY[0x1E0C809B0];
  if ((_DWORD)v239)
  {
    memset(v266, 0, 24);
    if (v238 == v237)
    {
      v57 = 0;
      v56 = 0;
    }
    else
    {
      v55 = 0;
      v56 = 0;
      v57 = 0;
      v58 = 0;
      if (v236 <= 1)
        v59 = 1;
      else
        v59 = v236;
      do
      {
        memset(&v252, 0, sizeof(v252));
        (*(void (**)(std::string *__return_ptr))(**(_QWORD **)(*v248 + 8 * v55) + 24))(&v265);
        MaxSizePriorityQueue<AnyPartitionStore::CandidateEntry,std::vector<AnyPartitionStore::CandidateEntry>,AnyPartitionStore::CandidateQueue::Lesser>::allItems((uint64_t **)&v252, *(_BYTE **)(v265.__r_.__value_.__r.__words[0] + 32), *(_BYTE **)(v265.__r_.__value_.__r.__words[0] + 40));
        v60 = (std::__shared_weak_count *)v265.__r_.__value_.__l.__size_;
        if (v265.__r_.__value_.__l.__size_)
        {
          v61 = (unint64_t *)(v265.__r_.__value_.__l.__size_ + 8);
          do
            v62 = __ldaxr(v61);
          while (__stlxr(v62 - 1, v61));
          if (!v62)
          {
            ((void (*)(std::__shared_weak_count *))v60->__on_zero_shared)(v60);
            std::__shared_weak_count::__release_weak(v60);
          }
        }
        v63 = (_BYTE *)v252.__r_.__value_.__l.__size_;
        v64 = (_BYTE *)v252.__r_.__value_.__r.__words[0];
        if (v252.__r_.__value_.__l.__size_ != v252.__r_.__value_.__r.__words[0])
        {
          v65 = *(_QWORD **)&v266[8];
          if (*(_QWORD *)&v266[8] >= *(_QWORD *)&v266[16])
          {
            v69 = std::vector<std::vector<AnyPartitionStore::CandidateEntry>>::__push_back_slow_path<std::vector<AnyPartitionStore::CandidateEntry> const&>((char **)v266, v252.__r_.__value_.__l.__data_, v252.__r_.__value_.__l.__size_);
          }
          else
          {
            **(_QWORD **)&v266[8] = 0;
            v65[1] = 0;
            v65[2] = 0;
            v66 = v63 - v64;
            if (v63 - v64 < 0)
              goto LABEL_322;
            v67 = (char *)operator new(v63 - v64);
            *v65 = v67;
            v65[1] = v67;
            v68 = &v67[v66];
            v65[2] = &v67[v66];
            memcpy(v67, v64, v66);
            v65[1] = v68;
            v69 = (char *)(v65 + 3);
          }
          *(_QWORD *)&v266[8] = v69;
          v71 = *((_QWORD *)v69 - 3);
          v70 = *((_QWORD *)v69 - 2);
          if (v57 >= v58)
          {
            v72 = 0xAAAAAAAAAAAAAAABLL * ((v57 - (char *)v56) >> 3) + 1;
            if (v72 > 0xAAAAAAAAAAAAAAALL)
              goto LABEL_322;
            if (0x5555555555555556 * ((v58 - (char *)v56) >> 3) > v72)
              v72 = 0x5555555555555556 * ((v58 - (char *)v56) >> 3);
            if (0xAAAAAAAAAAAAAAABLL * ((v58 - (char *)v56) >> 3) >= 0x555555555555555)
              v73 = 0xAAAAAAAAAAAAAAALL;
            else
              v73 = v72;
            if (v73)
            {
              if (v73 > 0xAAAAAAAAAAAAAAALL)
LABEL_323:
                std::__throw_bad_array_new_length[abi:nn180100]();
              v74 = (char *)operator new(24 * v73);
            }
            else
            {
              v74 = 0;
            }
            v75 = &v74[8 * ((v57 - (char *)v56) >> 3)];
            *(_QWORD *)v75 = v71;
            *((_QWORD *)v75 + 1) = v70;
            *((_QWORD *)v75 + 2) = v55;
            v76 = (uint64_t *)v75;
            if (v57 != (char *)v56)
            {
              v77 = &v74[8 * ((v57 - (char *)v56) >> 3)];
              do
              {
                v76 = (uint64_t *)(v77 - 24);
                v78 = *(_OWORD *)(v57 - 24);
                *((_QWORD *)v77 - 1) = *((_QWORD *)v57 - 1);
                *(_OWORD *)(v77 - 24) = v78;
                v57 -= 24;
                v77 -= 24;
              }
              while (v57 != (char *)v56);
            }
            v58 = &v74[24 * v73];
            if (v56)
              operator delete(v56);
            v57 = v75;
            v56 = v76;
          }
          else
          {
            *(_QWORD *)v57 = v71;
            *((_QWORD *)v57 + 1) = v70;
            *((_QWORD *)v57 + 2) = v55;
          }
          v57 += 24;
          v63 = (_BYTE *)v252.__r_.__value_.__r.__words[0];
        }
        if (v63)
          operator delete(v63);
        ++v55;
      }
      while (v55 != v59);
    }
    v82 = v57 - (char *)v56;
    if (v57 - (char *)v56 >= 25 && (unint64_t)v82 >= 0x30)
    {
      v208 = (v82 / 0x18uLL - 2) >> 1;
      v209 = v208;
      do
      {
        if (v208 >= v209)
        {
          v210 = &v56[3 * v209];
          v211 = *(_OWORD *)v210;
          v212 = v210[2];
          v213 = v209;
          do
          {
            v214 = v210;
            v213 = (2 * v213) | 1;
            v210 = &v56[3 * v213];
            *v214 = *v210;
            *(_OWORD *)(v214 + 1) = *(_OWORD *)(v210 + 1);
          }
          while (v208 >= v213);
          *(_OWORD *)v210 = v211;
          v210[2] = v212;
        }
        v101 = v209-- <= 0;
      }
      while (!v101);
    }
    for (; v57 != (char *)v56; v82 = v57 - (char *)v56)
    {
      if (((unint64_t)(v261 - v260) >> 11) >= v239)
        break;
      v85 = *(_QWORD *)(*v248 + 8 * v56[2]);
      v86 = (const void *)(*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v85 + 32))(v85, *(unsigned int *)*v56);
      v87 = v261;
      if ((unint64_t)v261 >= v262)
      {
        v244 = v82;
        v89 = v260;
        v90 = (v261 - v260) >> 11;
        v91 = v90 + 1;
        if ((unint64_t)(v90 + 1) >> 53)
          goto LABEL_322;
        v92 = v262 - (_QWORD)v260;
        if ((uint64_t)(v262 - (_QWORD)v260) >> 10 > v91)
          v91 = v92 >> 10;
        v93 = (unint64_t)v92 >= 0x7FFFFFFFFFFFF800 ? 0x1FFFFFFFFFFFFFLL : v91;
        if (v93)
        {
          if (v93 >> 53)
            goto LABEL_323;
          v94 = (std::__shared_weak_count *)operator new(v93 << 11);
        }
        else
        {
          v94 = 0;
        }
        v242 = v94;
        v95 = (char *)v94 + 2048 * v90;
        memcpy(v95, v86, 0x800uLL);
        v96 = v95;
        if (v87 != v89)
        {
          do
          {
            v87 -= 2048;
            v96 -= 2048;
            memcpy(v96, v87, 0x800uLL);
          }
          while (v87 != v89);
          v87 = v89;
        }
        v88 = v95 + 2048;
        v260 = v96;
        v261 = v88;
        v262 = (unint64_t)v242 + 2048 * v93;
        v82 = v244;
        if (v87)
          operator delete(v87);
      }
      else
      {
        memcpy(v261, v86, 0x800uLL);
        v88 = v87 + 2048;
      }
      v261 = v88;
      v97 = v56[1];
      v98 = *v56 + 8;
      *v56 = v98;
      if (v98 == v97)
      {
        if (v82 >= 25)
        {
          v107 = 0;
          v108 = v56[2];
          v109 = v56;
          do
          {
            v110 = v109;
            v111 = &v109[3 * v107];
            v112 = v111[3];
            v109 = v111 + 3;
            v107 = (2 * v107) | 1;
            *v110 = v112;
            *(_OWORD *)(v110 + 1) = *(_OWORD *)(v109 + 1);
          }
          while (v107 <= (uint64_t)((v82 / 0x18uLL - 2) >> 1));
          if (v109 == (uint64_t *)(v57 - 24))
          {
            v83 = (char *)(v109 + 1);
            v84 = (char *)(v109 + 2);
          }
          else
          {
            *v109 = *((_QWORD *)v57 - 3);
            v83 = v57 - 16;
            v84 = v57 - 8;
            *(_OWORD *)(v109 + 1) = *((_OWORD *)v57 - 1);
            v109 = (uint64_t *)(v57 - 24);
          }
          *v109 = v98;
          *(_QWORD *)v83 = v97;
          *(_QWORD *)v84 = v108;
        }
        v57 -= 24;
      }
      else if (v82 >= 48)
      {
        v99 = (v82 / 0x18uLL - 2) >> 1;
        v100 = v99;
        do
        {
          if (v99 >= v100)
          {
            v102 = &v56[3 * v100];
            v103 = *(_OWORD *)v102;
            v104 = v102[2];
            v105 = v100;
            do
            {
              v106 = v102;
              v105 = (2 * v105) | 1;
              v102 = &v56[3 * v105];
              *v106 = *v102;
              *(_OWORD *)(v106 + 1) = *(_OWORD *)(v102 + 1);
            }
            while (v99 >= v105);
            *(_OWORD *)v102 = v103;
            v102[2] = v104;
          }
          v101 = v100-- <= 0;
        }
        while (!v101);
      }
    }
    v113 = *(char **)v266;
    v37 = v247;
    v54 = MEMORY[0x1E0C809B0];
    if (*(_QWORD *)v266)
    {
      v114 = *(char **)&v266[8];
      if (*(_QWORD *)&v266[8] != *(_QWORD *)v266)
      {
        v115 = *(char **)&v266[8];
        do
        {
          v117 = (void *)*((_QWORD *)v115 - 3);
          v115 -= 24;
          v116 = v117;
          if (v117)
          {
            *((_QWORD *)v114 - 2) = v116;
            operator delete(v116);
          }
          v114 = v115;
        }
        while (v115 != v113);
      }
      operator delete(v113);
    }
    if (v56)
      operator delete(v56);
  }
  v244 = (unint64_t)(v261 - v260) >> 11;
  v118 = (std::__shared_weak_count_vtbl *)operator new[]();
  v119 = v118;
  if (v37 + (_DWORD)v244)
    bzero(v118, 2052 * ((2052 * (unint64_t)(v37 + v244) - 2052) / 0x804) + 2052);
  v120 = (std::__shared_weak_count *)operator new();
  v120->__shared_owners_ = 0;
  v122 = (unint64_t *)&v120->__shared_owners_;
  v120->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6E31AC0;
  v120->__shared_weak_owners_ = 0;
  v120[1].__vftable = v119;
  v242 = v120;
  if (v238 != v237)
  {
    v123 = 0;
    if (v236 <= 1)
      v124 = 1;
    else
      v124 = v236;
    do
    {
      v125 = *(_QWORD *)(*v248 + 8 * v123);
      *(_QWORD *)v266 = 0;
      *(_QWORD *)&v266[8] = 0;
      (*(void (**)(_BYTE *__return_ptr, uint64_t))(*(_QWORD *)v125 + 24))(v266, v125);
      v126 = *(_QWORD *)v266;
      v254[0] = v54;
      v254[1] = 1174405120;
      v254[2] = ___ZN22IVFVectorIndexTemplateIfLi512EE22IVFVectorIndexRootBase9trainOnceENSt3__110shared_ptrI16QuantizerManagerIfLi512EEEENS2_6vectorIPS1_NS2_9allocatorIS8_EEEEjj_block_invoke;
      v254[3] = &__block_descriptor_tmp_684;
      v254[4] = v125;
      v254[5] = v258;
      v256 = v244;
      v257 = v247;
      v254[6] = v119;
      v255 = v242;
      do
        v127 = __ldxr(v122);
      while (__stxr(v127 + 1, v122));
      (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v126 + 64))(v126, v254);
      v128 = v255;
      if (!v255)
        goto LABEL_178;
      v129 = (unint64_t *)&v255->__shared_owners_;
      do
        v130 = __ldaxr(v129);
      while (__stlxr(v130 - 1, v129));
      if (!v130)
      {
        ((void (*)(std::__shared_weak_count *))v128->__on_zero_shared)(v128);
        std::__shared_weak_count::__release_weak(v128);
        v131 = *(std::__shared_weak_count **)&v266[8];
        if (*(_QWORD *)&v266[8])
        {
LABEL_179:
          v132 = (unint64_t *)&v131->__shared_owners_;
          do
            v133 = __ldaxr(v132);
          while (__stlxr(v133 - 1, v132));
          if (!v133)
          {
            ((void (*)(std::__shared_weak_count *))v131->__on_zero_shared)(v131);
            std::__shared_weak_count::__release_weak(v131);
          }
        }
      }
      else
      {
LABEL_178:
        v131 = *(std::__shared_weak_count **)&v266[8];
        if (*(_QWORD *)&v266[8])
          goto LABEL_179;
      }
      ++v123;
    }
    while (v123 != v124);
  }
  v134 = v247;
  if (v247 + ((unint64_t)(v261 - v260) >> 11))
  {
    v143 = 0;
    v135 = 0;
    *(_QWORD *)&v121 = 67109376;
    v234 = v121;
    v136 = v246;
    while (1)
    {
      v144 = (float *)((char *)v119 + 2052 * v143);
      v145 = v144[512];
      if (v145 < v241)
      {
        ++v135;
        if (dword_1EF19FCCC >= 5)
        {
          v154 = v135;
          v155 = *__error();
          v156 = _SILogForLogForCategory(16);
          if (os_log_type_enabled(v156, OS_LOG_TYPE_DEFAULT))
          {
            v157 = v144[512];
            *(_DWORD *)v266 = v234;
            *(_DWORD *)&v266[4] = v143;
            *(_WORD *)&v266[8] = 1024;
            *(_DWORD *)&v266[10] = v157;
            _os_log_impl(&dword_1B8270000, v156, OS_LOG_TYPE_DEFAULT, "remove outlier newCentroid[%u] with member: %u", v266, 0xEu);
          }
          *__error() = v155;
          v135 = v154;
        }
        goto LABEL_195;
      }
      if (v145 <= 0.0)
      {
        v226 = __si_assert_copy_extra_268();
        v222 = v226;
        v227 = "";
        if (v226)
          v227 = v226;
        __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 152, "_count > 0.0f", v227);
        goto LABEL_316;
      }
      if (*(_BYTE *)(v136 + 56))
      {
        v228 = __si_assert_copy_extra_268();
        v222 = v228;
        v229 = "";
        if (v228)
          v229 = v228;
        __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 522, "!readOnly", v229);
        goto LABEL_316;
      }
      v240 = v135;
      v146 = *(_QWORD **)(v136 + 40);
      v147 = v146[2];
      v148 = v146[7];
      v149 = v148 + v147;
      if (v148 + v147 < v146[6])
        goto LABEL_200;
      if (_storage_array_Expand((uint64_t)(v146 + 1)))
        break;
      v150 = 0;
      if (v147 <= 0x7FF)
      {
LABEL_201:
        v151 = v146[2];
        if (v151 <= 0x7FF)
        {
          LODWORD(v152) = 2048;
          do
          {
            v153 = v146[7] + v151;
            if (v153 >= v146[6])
            {
              if (!_storage_array_Expand((uint64_t)(v146 + 1)))
                goto LABEL_205;
              v153 = v146[7] + v151;
            }
            v146[7] = v153;
LABEL_205:
            v151 = v146[2];
            v152 = (v152 - v151);
          }
          while (v151 < v152);
        }
      }
LABEL_215:
      v158 = (uint64_t)(v146 + 524);
      bit_vector_set_9027(v158, (v150 >> 20));
      v159 = (v150 + 2048) >> 20;
      if (v159 > (v150 >> 20))
      {
        v160 = (v150 >> 20) + 1;
        do
        {
          v161 = v160;
          bit_vector_set_9027(v158, v160++);
        }
        while (v159 > v161);
      }
      v136 = v246;
      if (v150 != *(_DWORD *)(v246 + 48))
      {
        v230 = __si_assert_copy_extra_268();
        v222 = v230;
        v231 = "";
        if (v230)
          v231 = v230;
        __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 524, "offset == nCentroids", v231);
        goto LABEL_316;
      }
      v162 = (void *)_windowsResolvePtr(*(_QWORD *)(v246 + 40) + 40, *(_QWORD *)(*(_QWORD *)(v246 + 40) + 24) + *(_QWORD *)(*(_QWORD *)(v246 + 40) + 16) * v150, 0x800uLL);
      memcpy(v162, (char *)v119 + 2052 * v143, 0x800uLL);
      ++*(_DWORD *)(v246 + 48);
      *(_DWORD *)(_windowsResolvePtr(*(_QWORD *)(v136 + 40) + 40, 0x400uLL, *(_QWORD *)(*(_QWORD *)(v136 + 40) + 16))+ 4) = *(_DWORD *)(v136 + 48);
      v134 = v247;
      v135 = v240;
LABEL_195:
      if (++v143 >= (unint64_t)(v134 + ((unint64_t)(v261 - v260) >> 11)))
        goto LABEL_187;
    }
    v148 = v146[7];
    v149 = v148 + v147;
LABEL_200:
    v146[7] = v149;
    v150 = (v148 - v146[3]) / v147;
    if (v147 <= 0x7FF)
      goto LABEL_201;
    goto LABEL_215;
  }
  v135 = 0;
  v136 = v246;
LABEL_187:
  v240 = v135;
  v137 = v263;
  v138 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v263 + 24))(v263);
  v139 = (*(uint64_t (**)(std::string::size_type))(*(_QWORD *)v136 + 24))(v136);
  if (v138 == (_DWORD)v139)
  {
    v139 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v137 + 24))(v137);
    if ((_DWORD)v139)
    {
      v140 = 0;
      while (1)
      {
        v141 = (const void *)(*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v137 + 64))(v137, v140);
        v142 = (const void *)(*(uint64_t (**)(std::string::size_type, uint64_t))(*(_QWORD *)v136 + 64))(v136, v140);
        v139 = memcmp(v141, v142, 0x800uLL);
        v47 = (_DWORD)v139 != 0;
        if ((_DWORD)v139)
          break;
        v140 = (v140 + 1);
        v139 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v137 + 24))(v137);
        if (v140 >= v139)
          goto LABEL_192;
      }
    }
    else
    {
LABEL_192:
      v47 = 0;
    }
  }
  else
  {
    v47 = 1;
  }
  v163 = 16 * v236;
  MEMORY[0x1E0C80A78](v139);
  v164 = &v234 - v236;
  bzero(v164, 2 * v235);
  if (v238 != v237)
    bzero((char *)&v234 - v163, v163);
  v165 = *v248;
  v252.__r_.__value_.__r.__words[0] = (std::string::size_type)&v234 - v163;
  v252.__r_.__value_.__l.__size_ = v165;
  v166 = v245;
  v252.__r_.__value_.__r.__words[2] = v136;
  v253 = v245;
  if (v245)
  {
    v167 = (unint64_t *)&v245->__shared_owners_;
    do
      v168 = __ldxr(v167);
    while (__stxr(v168 + 1, v167));
  }
  dispatch_apply_f(v236, 0, &v252, (void (__cdecl *)(void *, size_t))IVFVectorIndexTemplate<float,512>::IVFVectorIndexRootBase::trainOnce(std::shared_ptr<QuantizerManager<float,512>>,std::vector<IVFVectorIndexTemplate<float,512>::IVFVectorIndexRootBase*,std::allocator<IVFVectorIndexTemplate<float,512>::IVFVectorIndexRootBase*>>,unsigned int,unsigned int)::{lambda(void *,unsigned long)#1}::__invoke);
  v169 = *v248;
  if (v248[1] != *v248)
  {
    v170 = 0;
    v171 = (unint64_t *)&v166->__shared_owners_;
    do
    {
      v172 = *(_QWORD *)(v169 + 8 * v170);
      v250 = v136;
      v251 = v166;
      if (v166)
      {
        do
          v173 = __ldxr(v171);
        while (__stxr(v173 + 1, v171));
      }
      v174 = v164[v170];
      v249 = v174;
      if (*((_QWORD *)&v174 + 1))
      {
        v175 = (unint64_t *)(*((_QWORD *)&v174 + 1) + 8);
        do
          v176 = __ldxr(v175);
        while (__stxr(v176 + 1, v175));
      }
      (*(void (**)(uint64_t, std::string::size_type *, __int128 *))(*(_QWORD *)v172 + 48))(v172, &v250, &v249);
      v177 = (std::__shared_weak_count *)*((_QWORD *)&v249 + 1);
      if (!*((_QWORD *)&v249 + 1))
        goto LABEL_237;
      v178 = (unint64_t *)(*((_QWORD *)&v249 + 1) + 8);
      do
        v179 = __ldaxr(v178);
      while (__stlxr(v179 - 1, v178));
      if (!v179)
      {
        ((void (*)(std::__shared_weak_count *))v177->__on_zero_shared)(v177);
        std::__shared_weak_count::__release_weak(v177);
        v180 = v251;
        if (!v251)
          goto LABEL_243;
      }
      else
      {
LABEL_237:
        v180 = v251;
        if (!v251)
          goto LABEL_243;
      }
      v181 = (unint64_t *)&v180->__shared_owners_;
      do
        v182 = __ldaxr(v181);
      while (__stlxr(v182 - 1, v181));
      if (!v182)
      {
        ((void (*)(std::__shared_weak_count *))v180->__on_zero_shared)(v180);
        std::__shared_weak_count::__release_weak(v180);
      }
LABEL_243:
      v183 = v243[v170];
      (*(void (**)(_BYTE *__return_ptr))(**(_QWORD **)(*v248 + 8 * v170) + 24))(v266);
      v184 = *(std::__shared_weak_count **)&v266[8];
      v185 = *(_DWORD *)(*(_QWORD *)v266 + 72);
      if (*(_QWORD *)&v266[8])
      {
        v186 = (unint64_t *)(*(_QWORD *)&v266[8] + 8);
        do
          v187 = __ldaxr(v186);
        while (__stlxr(v187 - 1, v186));
        if (!v187)
        {
          ((void (*)(std::__shared_weak_count *))v184->__on_zero_shared)(v184);
          std::__shared_weak_count::__release_weak(v184);
        }
      }
      if (v183 != v185)
      {
        v224 = __si_assert_copy_extra_268();
        v222 = v224;
        v225 = "";
        if (v224)
          v225 = v224;
        __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2056, "vectorCounts[i] == vectorIndexes[i]->getPartitions()->nVectors()", v225);
        goto LABEL_316;
      }
      ++v170;
      v169 = *v248;
      v166 = v245;
      v136 = v246;
    }
    while (v170 < (uint64_t)(v248[1] - *v248) >> 3);
  }
  v188 = *__error();
  v189 = _SILogForLogForCategory(16);
  if (os_log_type_enabled(v189, OS_LOG_TYPE_DEFAULT))
  {
    v190 = v240;
    v191 = v244 - v240;
    v192 = CFAbsoluteTimeGetCurrent();
    *(_DWORD *)v266 = 67110144;
    *(_DWORD *)&v266[4] = v239;
    *(_WORD *)&v266[8] = 1024;
    *(_DWORD *)&v266[10] = v191;
    *(_WORD *)&v266[14] = 1024;
    *(_DWORD *)&v266[16] = v190;
    *(_WORD *)&v266[20] = 1024;
    *(_DWORD *)&v266[22] = v47;
    *(_WORD *)&v266[26] = 2048;
    *(double *)&v266[28] = v192 - Current;
    _os_log_impl(&dword_1B8270000, v189, OS_LOG_TYPE_DEFAULT, "training quantizer try addCentroids=%u added=%d removed=%u changed=%d duration: %fs", v266, 0x24u);
  }
  *__error() = v188;
  v193 = v253;
  if (v253)
  {
    v194 = (unint64_t *)&v253->__shared_owners_;
    do
      v195 = __ldaxr(v194);
    while (__stlxr(v195 - 1, v194));
    if (!v195)
    {
      ((void (*)(std::__shared_weak_count *))v193->__on_zero_shared)(v193);
      std::__shared_weak_count::__release_weak(v193);
    }
  }
  if (v238 != v237)
  {
    v196 = &v164[v236];
    do
    {
      v197 = (std::__shared_weak_count *)*((_QWORD *)v196 - 1);
      if (v197)
      {
        v198 = (unint64_t *)&v197->__shared_owners_;
        do
          v199 = __ldaxr(v198);
        while (__stlxr(v199 - 1, v198));
        if (!v199)
        {
          ((void (*)(std::__shared_weak_count *))v197->__on_zero_shared)(v197);
          std::__shared_weak_count::__release_weak(v197);
        }
      }
      --v196;
    }
    while (v196 != v164);
  }
  do
    v200 = __ldaxr(v122);
  while (__stlxr(v200 - 1, v122));
  v81 = v245;
  if (!v200)
  {
    v201 = v242;
    ((void (*)(std::__shared_weak_count *))v242->__on_zero_shared)(v242);
    std::__shared_weak_count::__release_weak(v201);
  }
  *(_QWORD *)v258 = off_1E6E32D30;
  v9 = v243;
  if (v260)
  {
    v261 = v260;
    operator delete(v260);
  }
  *(_QWORD *)v258 = off_1E6E30F58;
  if (SBYTE7(v259) < 0)
    operator delete(*(void **)&v258[8]);
LABEL_272:
  if (v81)
  {
    v202 = (unint64_t *)&v81->__shared_owners_;
    do
      v203 = __ldaxr(v202);
    while (__stlxr(v203 - 1, v202));
    if (!v203)
    {
      ((void (*)(std::__shared_weak_count *))v81->__on_zero_shared)(v81);
      std::__shared_weak_count::__release_weak(v81);
    }
  }
  if (v9)
    operator delete(v9);
  v204 = v264;
  if (v264)
  {
    v205 = (unint64_t *)&v264->__shared_owners_;
    do
      v206 = __ldaxr(v205);
    while (__stlxr(v206 - 1, v205));
    if (!v206)
    {
      ((void (*)(std::__shared_weak_count *))v204->__on_zero_shared)(v204);
      std::__shared_weak_count::__release_weak(v204);
    }
  }
  return v47;
}

_QWORD *QuantizerManager<float,512>::lastTrainedQuantizer(_QWORD *result, uint64_t a2)
{
  unsigned __int8 v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned __int8 v6;
  unint64_t *v7;
  unint64_t v8;
  char *v9;
  char *v10;
  const char *v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  int v15;

  v2 = atomic_load((unsigned __int8 *)(a2 + 72));
  if ((v2 & 1) == 0)
  {
    v9 = __si_assert_copy_extra_268();
    v10 = v9;
    v11 = "";
    if (v9)
      v11 = v9;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 730, "_training.test()", v11);
    free(v10);
    if (__valid_fs(-1))
      v12 = 2989;
    else
      v12 = 3072;
    *(_DWORD *)v12 = -559038737;
    abort();
  }
  v3 = *(_QWORD *)(a2 + 96);
  if (v3)
  {
    v4 = *(_QWORD *)(a2 + 104);
    *result = v3;
    result[1] = v4;
    if (!v4)
      return result;
    goto LABEL_12;
  }
  v5 = *(_QWORD *)(a2 + 80);
  if (v5)
  {
    v4 = *(_QWORD *)(a2 + 88);
    *result = v5;
    result[1] = v4;
    if (!v4)
      return result;
    goto LABEL_12;
  }
  if ((v6 & 1) == 0)
  {
    v14 = result;
    result = v14;
    if (v15)
    {
      __cxa_atexit((void (*)(void *))std::shared_ptr<Quantizer<float,512>>::~shared_ptr[abi:nn180100], &ZeroVectorQuantizer<float,512>::sharedInstance(void)::zvq, &dword_1B8270000);
      result = v14;
    }
  }
  if (ZeroVectorQuantizer<float,512>::sharedInstance(void)::onceToken != -1)
  {
    v13 = result;
    dispatch_once(&ZeroVectorQuantizer<float,512>::sharedInstance(void)::onceToken, &__block_literal_global_621);
    result = v13;
  }
  v4 = qword_1EF1AF238;
  *result = ZeroVectorQuantizer<float,512>::sharedInstance(void)::zvq;
  result[1] = v4;
  if (v4)
  {
LABEL_12:
    v7 = (unint64_t *)(v4 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  return result;
}

void ___ZN16QuantizerManagerIfLi512EE23commitTrainingQuantizerEv_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  int v3;
  size_t v4;
  unint64_t v5;
  std::string *p_dst;
  uint64_t v7;
  uint64_t v8;
  const void *v9;
  int v10;
  std::string *p_p;
  std::string::size_type size;
  std::string *v13;
  std::string::size_type v14;
  std::string *v15;
  int64_t v16;
  uint64_t v17;
  void **v18;
  std::__shared_weak_count *v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t *p_shared_weak_owners;
  unint64_t v23;
  uint64_t *v24;
  int v25;
  int v26;
  unint64_t v27;
  unint64_t v28;
  uint8x8_t v29;
  unint64_t v30;
  void **v31;
  void *v32;
  unint64_t v33;
  uint64_t v34;
  float v35;
  float v36;
  _BOOL8 v37;
  unint64_t v38;
  unint64_t v39;
  size_t prime;
  unint64_t v41;
  uint8x8_t v42;
  uint64_t v43;
  uint64_t v44;
  _QWORD *v45;
  unint64_t v46;
  std::__shared_weak_count *v47;
  std::__shared_weak_count *v48;
  unint64_t *v49;
  unint64_t v50;
  unint64_t *p_shared_owners;
  unint64_t v52;
  std::__shared_weak_count *v53;
  int v54;
  size_t v55;
  unint64_t v56;
  void *v57;
  uint64_t v58;
  uint64_t v59;
  const void *v60;
  uint64_t v61;
  uint64_t v62;
  unint64_t *v63;
  unint64_t v64;
  std::__shared_weak_count *v65;
  unint64_t *v66;
  unint64_t v67;
  uint64_t v68;
  void **v69;
  uint64_t v70;
  unint64_t *v71;
  uint64_t v72;
  uint64_t v73;
  int v74;
  uint64_t v75;
  uint64_t v77;
  int *v78;
  std::__shared_weak_count *v79;
  unint64_t *v80;
  unint64_t v81;
  std::string __p;
  std::string __dst;
  std::string v84;
  void *v85[2];
  int64_t v86;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(_QWORD *)(v1 + 80);
  if (!v2)
    goto LABEL_109;
  v3 = *(char *)(v1 + 71);
  if (v3 >= 0)
    v4 = *(unsigned __int8 *)(v1 + 71);
  else
    v4 = *(_QWORD *)(v1 + 56);
  v5 = v4 + 1;
  if (v4 + 1 > 0x7FFFFFFFFFFFFFF7)
LABEL_149:
    abort();
  if (v5 >= 0x17)
  {
    v7 = (v5 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v5 | 7) != 0x17)
      v7 = v5 | 7;
    v8 = v7 + 1;
    p_dst = (std::string *)operator new(v7 + 1);
    __dst.__r_.__value_.__l.__size_ = v4 + 1;
    __dst.__r_.__value_.__r.__words[2] = v8 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
  }
  else
  {
    memset(&__dst, 0, sizeof(__dst));
    p_dst = &__dst;
    *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v4 + 1;
    if (!v4)
      goto LABEL_16;
  }
  if (v3 >= 0)
    v9 = (const void *)(v1 + 48);
  else
    v9 = *(const void **)(v1 + 48);
  memmove(p_dst, v9, v4);
LABEL_16:
  *(_WORD *)((char *)&p_dst->__r_.__value_.__l.__data_ + v4) = 46;
  v10 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v2 + 16))(v2);
  std::to_string(&__p, v10);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  else
    size = __p.__r_.__value_.__l.__size_;
  v13 = std::string::append(&__dst, (const std::string::value_type *)p_p, size);
  v14 = v13->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v84.__r_.__value_.__l.__data_ = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
  v84.__r_.__value_.__r.__words[2] = v14;
  v13->__r_.__value_.__l.__size_ = 0;
  v13->__r_.__value_.__r.__words[2] = 0;
  v13->__r_.__value_.__r.__words[0] = 0;
  v15 = std::string::append(&v84, ".quantizer");
  v16 = v15->__r_.__value_.__r.__words[2];
  *(_OWORD *)v85 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
  v86 = v16;
  v15->__r_.__value_.__l.__size_ = 0;
  v15->__r_.__value_.__r.__words[2] = 0;
  v15->__r_.__value_.__r.__words[0] = 0;
  if ((SHIBYTE(v84.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_24;
LABEL_36:
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_25;
    goto LABEL_37;
  }
  operator delete(v84.__r_.__value_.__l.__data_);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    goto LABEL_36;
LABEL_24:
  if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    goto LABEL_25;
LABEL_37:
  operator delete(__dst.__r_.__value_.__l.__data_);
LABEL_25:
  v17 = *(_QWORD *)(v1 + 80);
  if (v86 >= 0)
    v18 = v85;
  else
    v18 = (void **)v85[0];
  fd_rename(*(_QWORD *)(*(_QWORD *)(v17 + 40) + 40), (const char *)v18);
  MEMORY[0x1BCCB03B0](v17 + 8, v18);
  atomic_store(1u, (unsigned __int8 *)(*(_QWORD *)(v1 + 80) + 57));
  v20 = *(_QWORD *)(v1 + 80);
  v19 = *(std::__shared_weak_count **)(v1 + 88);
  v21 = v20;
  if (v19)
  {
    p_shared_weak_owners = (unint64_t *)&v19->__shared_weak_owners_;
    do
      v23 = __ldxr(p_shared_weak_owners);
    while (__stxr(v23 + 1, p_shared_weak_owners));
    v21 = *(_QWORD *)(v1 + 80);
  }
  v24 = (uint64_t *)(v1 + 112);
  v25 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v21 + 16))(v21);
  v26 = v25;
  v27 = v25;
  v28 = *(_QWORD *)(v1 + 120);
  if (v28)
  {
    v29 = (uint8x8_t)vcnt_s8((int8x8_t)v28);
    v29.i16[0] = vaddlv_u8(v29);
    if (v29.u32[0] > 1uLL)
    {
      v30 = v25;
      if (v28 <= v25)
        v30 = v25 % v28;
    }
    else
    {
      v30 = (v28 - 1) & v25;
    }
    v31 = *(void ***)(*v24 + 8 * v30);
    if (v31)
    {
      v32 = *v31;
      if (*v31)
      {
        if (v29.u32[0] < 2uLL)
        {
          while (1)
          {
            v34 = *((_QWORD *)v32 + 1);
            if (v34 == v25)
            {
              if (*((_DWORD *)v32 + 4) == v25)
                goto LABEL_94;
            }
            else if ((v34 & (v28 - 1)) != v30)
            {
              goto LABEL_56;
            }
            v32 = *(void **)v32;
            if (!v32)
              goto LABEL_56;
          }
        }
        do
        {
          v33 = *((_QWORD *)v32 + 1);
          if (v33 == v25)
          {
            if (*((_DWORD *)v32 + 4) == v25)
              goto LABEL_94;
          }
          else
          {
            if (v33 >= v28)
              v33 %= v28;
            if (v33 != v30)
              break;
          }
          v32 = *(void **)v32;
        }
        while (v32);
      }
    }
  }
  else
  {
    v30 = 0;
  }
LABEL_56:
  v32 = operator new(0x28uLL);
  *(_QWORD *)v32 = 0;
  *((_QWORD *)v32 + 1) = v27;
  *((_DWORD *)v32 + 4) = v26;
  *((_QWORD *)v32 + 3) = 0;
  *((_QWORD *)v32 + 4) = 0;
  v35 = (float)(unint64_t)(*(_QWORD *)(v1 + 136) + 1);
  v36 = *(float *)(v1 + 144);
  if (!v28 || (float)(v36 * (float)v28) < v35)
  {
    v37 = 1;
    if (v28 >= 3)
      v37 = (v28 & (v28 - 1)) != 0;
    v38 = v37 | (2 * v28);
    v39 = vcvtps_u32_f32(v35 / v36);
    if (v38 <= v39)
      prime = v39;
    else
      prime = v38;
    if (prime == 1)
    {
      prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      prime = std::__next_prime(prime);
      v28 = *(_QWORD *)(v1 + 120);
    }
    if (prime > v28)
      goto LABEL_78;
    if (prime < v28)
    {
      v41 = vcvtps_u32_f32((float)*(unint64_t *)(v1 + 136) / *(float *)(v1 + 144));
      if (v28 < 3 || (v42 = (uint8x8_t)vcnt_s8((int8x8_t)v28), v42.i16[0] = vaddlv_u8(v42), v42.u32[0] > 1uLL))
      {
        v41 = std::__next_prime(v41);
      }
      else
      {
        v43 = 1 << -(char)__clz(v41 - 1);
        if (v41 >= 2)
          v41 = v43;
      }
      if (prime <= v41)
        prime = v41;
      if (prime < v28)
LABEL_78:
        std::__hash_table<std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,std::__unordered_map_hasher<SIUnicodeString,std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,HashFunction,HashEqual,true>,std::__unordered_map_equal<SIUnicodeString,std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>,HashEqual,HashFunction,true>,std::allocator<std::__hash_value_type<SIUnicodeString,std::unique_ptr<NGram_s>>>>::__do_rehash<true>(v1 + 112, prime);
    }
    v28 = *(_QWORD *)(v1 + 120);
    if ((v28 & (v28 - 1)) != 0)
    {
      if (v28 <= v27)
        v30 = v27 % v28;
      else
        v30 = v27;
    }
    else
    {
      v30 = (v28 - 1) & v27;
    }
  }
  v44 = *v24;
  v45 = *(_QWORD **)(*v24 + 8 * v30);
  if (v45)
  {
    *(_QWORD *)v32 = *v45;
LABEL_92:
    *v45 = v32;
    goto LABEL_93;
  }
  *(_QWORD *)v32 = *(_QWORD *)(v1 + 128);
  *(_QWORD *)(v1 + 128) = v32;
  *(_QWORD *)(v44 + 8 * v30) = v1 + 128;
  if (*(_QWORD *)v32)
  {
    v46 = *(_QWORD *)(*(_QWORD *)v32 + 8);
    if ((v28 & (v28 - 1)) != 0)
    {
      if (v46 >= v28)
        v46 %= v28;
    }
    else
    {
      v46 &= v28 - 1;
    }
    v45 = (_QWORD *)(*v24 + 8 * v46);
    goto LABEL_92;
  }
LABEL_93:
  ++*(_QWORD *)(v1 + 136);
LABEL_94:
  if (v19)
  {
    v47 = std::__shared_weak_count::lock(v19);
    v48 = v47;
    if (v47)
    {
      v49 = (unint64_t *)&v47->__shared_weak_owners_;
      do
        v50 = __ldxr(v49);
      while (__stxr(v50 + 1, v49));
      std::__shared_weak_count::__release_weak(v19);
      p_shared_owners = (unint64_t *)&v48->__shared_owners_;
      do
        v52 = __ldaxr(p_shared_owners);
      while (__stlxr(v52 - 1, p_shared_owners));
      if (v52)
        goto LABEL_105;
      ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
      v19 = v48;
    }
    else
    {
      v20 = 0;
    }
    std::__shared_weak_count::__release_weak(v19);
  }
  else
  {
    v20 = 0;
    v48 = 0;
  }
LABEL_105:
  v53 = (std::__shared_weak_count *)*((_QWORD *)v32 + 4);
  *((_QWORD *)v32 + 3) = v20;
  *((_QWORD *)v32 + 4) = v48;
  if (v53)
    std::__shared_weak_count::__release_weak(v53);
  if (SHIBYTE(v86) < 0)
    operator delete(v85[0]);
LABEL_109:
  v54 = *(char *)(v1 + 71);
  if (v54 >= 0)
    v55 = *(unsigned __int8 *)(v1 + 71);
  else
    v55 = *(_QWORD *)(v1 + 56);
  v56 = v55 + 10;
  if (v55 + 10 > 0x7FFFFFFFFFFFFFF7)
    goto LABEL_149;
  if (v56 >= 0x17)
  {
    v58 = (v56 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v56 | 7) != 0x17)
      v58 = v56 | 7;
    v59 = v58 + 1;
    v57 = operator new(v58 + 1);
    v85[1] = (void *)(v55 + 10);
    v86 = v59 | 0x8000000000000000;
    v85[0] = v57;
  }
  else
  {
    v85[1] = 0;
    v86 = 0;
    v85[0] = 0;
    v57 = v85;
    HIBYTE(v86) = v55 + 10;
    if (!v55)
      goto LABEL_123;
  }
  if (v54 >= 0)
    v60 = (const void *)(v1 + 48);
  else
    v60 = *(const void **)(v1 + 48);
  memmove(v57, v60, v55);
LABEL_123:
  strcpy((char *)v57 + v55, ".quantizer");
  v62 = *(_QWORD *)(v1 + 96);
  v61 = *(_QWORD *)(v1 + 104);
  if (v61)
  {
    v63 = (unint64_t *)(v61 + 8);
    do
      v64 = __ldxr(v63);
    while (__stxr(v64 + 1, v63));
  }
  v65 = *(std::__shared_weak_count **)(v1 + 88);
  *(_QWORD *)(v1 + 80) = v62;
  *(_QWORD *)(v1 + 88) = v61;
  if (v65)
  {
    v66 = (unint64_t *)&v65->__shared_owners_;
    do
      v67 = __ldaxr(v66);
    while (__stlxr(v67 - 1, v66));
    if (!v67)
    {
      ((void (*)(std::__shared_weak_count *))v65->__on_zero_shared)(v65);
      std::__shared_weak_count::__release_weak(v65);
    }
  }
  v68 = *(_QWORD *)(v1 + 80);
  if (v86 >= 0)
    v69 = v85;
  else
    v69 = (void **)v85[0];
  fd_rename(*(_QWORD *)(*(_QWORD *)(v68 + 40) + 40), (const char *)v69);
  MEMORY[0x1BCCB03B0](v68 + 8, v69);
  v70 = *(_QWORD *)(v1 + 80);
  v71 = *(unint64_t **)(v70 + 40);
  *v71 = 0;
  vi_onefixedsize_disk_allocator::storeHeader(v71);
  storage_array_SyncPages(*(_QWORD *)(v70 + 40) + 8, *(_QWORD *)(v70 + 40) + 4192);
  storage_array_Truncate((uint64_t *)(*(_QWORD *)(v70 + 40) + 8));
  v72 = *(_QWORD *)(v70 + 40);
  fd_make_readonly(*(_QWORD *)(v72 + 40));
  v73 = *(_QWORD *)(v72 + 40);
  if (v73)
  {
    do
    {
      v74 = fchmodat(*(_DWORD *)(v73 + 44), *(const char **)(v73 + 72), 0x100u, 2048);
      v75 = g_prot_error_callback;
      if (v74 != -1 || g_prot_error_callback == 0)
        break;
      v77 = *(unsigned int *)(v73 + 40);
      v78 = __error();
    }
    while (((*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t))(v75 + 16))(v75, v77, *v78, 19) & 1) != 0);
  }
  *(_BYTE *)(v70 + 56) = 1;
  v79 = *(std::__shared_weak_count **)(v1 + 104);
  *(_QWORD *)(v1 + 96) = 0;
  *(_QWORD *)(v1 + 104) = 0;
  if (!v79)
    goto LABEL_144;
  v80 = (unint64_t *)&v79->__shared_owners_;
  do
    v81 = __ldaxr(v80);
  while (__stlxr(v81 - 1, v80));
  if (v81)
  {
LABEL_144:
    if ((SHIBYTE(v86) & 0x80000000) == 0)
      return;
    goto LABEL_145;
  }
  ((void (*)(std::__shared_weak_count *))v79->__on_zero_shared)(v79);
  std::__shared_weak_count::__release_weak(v79);
  if (SHIBYTE(v86) < 0)
LABEL_145:
    operator delete(v85[0]);
}

float ___ZN22IVFVectorIndexTemplateIfLi512EE22IVFVectorIndexRootBase9trainOnceENSt3__110shared_ptrI16QuantizerManagerIfLi512EEEENS2_6vectorIPS1_NS2_9allocatorIS8_EEEEjj_block_invoke(uint64_t a1, unsigned int a2, float *a3)
{
  const void *v6;
  uint64_t v7;
  float *v8;
  float *v9;
  float v10;
  float result;
  void *__p;
  void *v13;
  uint64_t v14;

  v6 = (const void *)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 32) + 32))(*(_QWORD *)(a1 + 32), *(unsigned int *)a3);
  if (*(_DWORD *)(a1 + 64))
  {
    __p = 0;
    v13 = 0;
    v14 = 0;
    (*(void (**)(void **__return_ptr, _QWORD, const void *, uint64_t))(**(_QWORD **)(a1 + 40) + 72))(&__p, *(_QWORD *)(a1 + 40), v6, 1);
    if (*((float *)__p + 1) < a3[1])
      a2 = *(_DWORD *)(a1 + 68) + *(_DWORD *)__p;
    v13 = __p;
    operator delete(__p);
  }
  v7 = *(_QWORD *)(a1 + 48);
  v8 = (float *)(v7 + 2052 * a2);
  v9 = v8 + 512;
  v10 = v8[512];
  if (v10 == 0.0)
  {
    memcpy((void *)(v7 + 2052 * a2), v6, 0x800uLL);
  }
  else
  {
    vDSP_vavlin((const float *)v6, 1, v8 + 512, v8, 1, 0x200uLL);
    v10 = *v9;
  }
  result = v10 + 1.0;
  *v9 = v10 + 1.0;
  return result;
}

void IVFVectorIndexTemplate<float,512>::IVFVectorIndexRootBase::trainOnce(std::shared_ptr<QuantizerManager<float,512>>,std::vector<IVFVectorIndexTemplate<float,512>::IVFVectorIndexRootBase*,std::allocator<IVFVectorIndexTemplate<float,512>::IVFVectorIndexRootBase*>>,unsigned int,unsigned int)::{lambda(void *,unsigned long)#1}::__invoke(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  _QWORD *v9;
  std::__shared_weak_count *v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  std::__shared_weak_count *v14;
  unint64_t *v15;
  unint64_t v16;
  std::__shared_weak_count *v17;
  unint64_t *v18;
  unint64_t v19;
  std::__shared_weak_count *v20;
  unint64_t *v21;
  unint64_t v22;
  uint64_t v23;
  std::__shared_weak_count *v24;
  uint64_t v25;
  std::__shared_weak_count *v26;

  v4 = a1[2];
  v5 = *(_QWORD *)(a1[1] + 8 * a2);
  v6 = (std::__shared_weak_count *)a1[3];
  v23 = v4;
  v24 = v6;
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t *))(*(_QWORD *)v5 + 40))(&v25, v5, &v23);
  v9 = (_QWORD *)(*a1 + 16 * a2);
  v11 = v25;
  v10 = v26;
  if (v26)
  {
    v12 = (unint64_t *)&v26->__shared_owners_;
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  v14 = (std::__shared_weak_count *)v9[1];
  *v9 = v11;
  v9[1] = v10;
  if (!v14)
    goto LABEL_11;
  v15 = (unint64_t *)&v14->__shared_owners_;
  do
    v16 = __ldaxr(v15);
  while (__stlxr(v16 - 1, v15));
  if (!v16)
  {
    ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
    std::__shared_weak_count::__release_weak(v14);
    v17 = v26;
    if (!v26)
      goto LABEL_17;
  }
  else
  {
LABEL_11:
    v17 = v26;
    if (!v26)
      goto LABEL_17;
  }
  v18 = (unint64_t *)&v17->__shared_owners_;
  do
    v19 = __ldaxr(v18);
  while (__stlxr(v19 - 1, v18));
  if (!v19)
  {
    ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
    std::__shared_weak_count::__release_weak(v17);
  }
LABEL_17:
  v20 = v24;
  if (v24)
  {
    v21 = (unint64_t *)&v24->__shared_owners_;
    do
      v22 = __ldaxr(v21);
    while (__stlxr(v22 - 1, v21));
    if (!v22)
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
}

uint64_t __copy_helper_block_8_48c61_ZTSNSt3__110shared_ptrIA_23IVFVectorMeanCalculatorILi512EEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 56);
  *(_QWORD *)(result + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(result + 56) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void __destroy_helper_block_8_48c61_ZTSNSt3__110shared_ptrIA_23IVFVectorMeanCalculatorILi512EEEE(uint64_t a1)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v3;

  v1 = *(std::__shared_weak_count **)(a1 + 56);
  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

void std::__shared_ptr_pointer<IVFVectorMeanCalculator<512> *,std::shared_ptr<IVFVectorMeanCalculator<512>[]>::__shared_ptr_default_delete<IVFVectorMeanCalculator<512>[],IVFVectorMeanCalculator<512>>,std::allocator<IVFVectorMeanCalculator<512>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BCCB06A4);
}

uint64_t std::__shared_ptr_pointer<IVFVectorMeanCalculator<512> *,std::shared_ptr<IVFVectorMeanCalculator<512>[]>::__shared_ptr_default_delete<IVFVectorMeanCalculator<512>[],IVFVectorMeanCalculator<512>>,std::allocator<IVFVectorMeanCalculator<512>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    JUMPOUT(0x1BCCB068CLL);
  return result;
}

uint64_t ArrayVectorQuantizer<float,512>::~ArrayVectorQuantizer(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = off_1E6E32D30;
  v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(_QWORD *)(a1 + 48) = v2;
    operator delete(v2);
  }
  *(_QWORD *)a1 = off_1E6E30F58;
  if (*(char *)(a1 + 31) < 0)
    operator delete(*(void **)(a1 + 8));
  return a1;
}

void ArrayVectorQuantizer<float,512>::~ArrayVectorQuantizer(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = off_1E6E32D30;
  v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(_QWORD *)(a1 + 48) = v2;
    operator delete(v2);
  }
  *(_QWORD *)a1 = off_1E6E30F58;
  if (*(char *)(a1 + 31) < 0)
    operator delete(*(void **)(a1 + 8));
  JUMPOUT(0x1BCCB06A4);
}

uint64_t ArrayVectorQuantizer<float,512>::count(uint64_t a1)
{
  return (*(_QWORD *)(a1 + 48) - *(_QWORD *)(a1 + 40)) >> 11;
}

uint64_t ArrayVectorQuantizer<float,512>::getCentroid(uint64_t a1, unsigned int a2)
{
  uint64_t v2;
  char *v4;
  char *v5;
  const char *v6;

  v2 = *(_QWORD *)(a1 + 40);
  if (a2 >= (unint64_t)((*(_QWORD *)(a1 + 48) - v2) >> 11))
  {
    v4 = __si_assert_copy_extra_268();
    v5 = v4;
    v6 = "";
    if (v4)
      v6 = v4;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 443, "i < centroids.size()", v6);
    free(v5);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  return v2 + ((unint64_t)a2 << 11);
}

uint64_t ___ZN22IVFVectorIndexTemplateIfLi512EE20IVFVectorIndexRoot_sI30vi_onefixedsize_disk_allocator16vi_disk_postingsE7compactIS2_EENSt3__19enable_ifIXsr13is_persistentIT_EE5valueEbE4typeEPS4_P12uint32_map_tP11TermIdStore18CICompactCallbacksPVi_block_invoke(uint64_t a1, unsigned int *a2, _BYTE *a3)
{
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  BOOL v9;
  uint64_t v10;
  char *v11;
  uint64_t result;
  char *v13;
  char *v14;
  const char *v15;

  v6 = (uint64_t *)*((_QWORD *)a2 + 3);
  v7 = *(_QWORD *)(a1 + 40);
  v8 = *v6;
  if (v6)
    v9 = v7 == 0;
  else
    v9 = 1;
  if (!v9)
  {
    if ((_DWORD)v8)
    {
      if (*(_DWORD *)(v7 + 4408) <= v8)
      {
        v13 = __si_assert_copy_extra(0);
        v14 = v13;
        v15 = "";
        if (v13)
          v15 = v13;
        __message_assert("%s:%u: failed assertion '%s' %s ", "storage.c", 1530, "position && position < inMap->count", v15);
        free(v14);
        if (__valid_fs(-1))
        {
          MEMORY[0xBAD] = -559038737;
          abort();
        }
        MEMORY[0xC00] = -559038737;
        abort();
      }
      v10 = *(_QWORD *)(a1 + 48);
      v11 = storageResolvePtr(v7, 4 * *v6, 4uLL, 1);
      v8 = *(_QWORD *)storageResolvePtr(v10, 8 * *(unsigned int *)v11, 8uLL, 1);
    }
    else
    {
      v8 = 0;
    }
  }
  IVFVectorIndexTemplate<float,512>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::insertForCompact(*(_QWORD *)(a1 + 56), a2[2], *((void **)a2 + 2), v8, *a2, *((float *)a2 + 1));
  result = 1;
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
  if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) && !**(_DWORD **)(a1 + 64))
    result = (*(uint64_t (**)(_QWORD))(a1 + 88))(*(_QWORD *)(a1 + 96));
  *a3 = result;
  return result;
}

void IVFVectorIndexTemplate<float,512>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::insertForCompact(uint64_t a1, unsigned int a2, void *a3, uint64_t a4, uint64_t a5, float a6)
{
  os_unfair_lock_s *v12;
  std::__shared_weak_count *v13;
  unint64_t *p_shared_owners;
  unint64_t v15;
  std::__shared_weak_count *v16;
  uint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  uint64_t v20;
  unsigned int v21;
  void *v22;
  uint64_t v23;
  float v24;
  char v25;
  unint64_t *v26;
  unint64_t v27;
  unint64_t *v28;
  unint64_t v29;
  char *v30;
  char *v31;
  const char *v32;

  v12 = (os_unfair_lock_s *)(a1 + 112);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 112));
  v13 = *(std::__shared_weak_count **)(a1 + 88);
  if (v13)
  {
    p_shared_owners = (unint64_t *)&v13->__shared_owners_;
    do
      v15 = __ldxr(p_shared_owners);
    while (__stxr(v15 + 1, p_shared_owners));
  }
  v17 = *(_QWORD *)(a1 + 96);
  v16 = *(std::__shared_weak_count **)(a1 + 104);
  if (v16)
  {
    v18 = (unint64_t *)&v16->__shared_owners_;
    do
      v19 = __ldxr(v18);
    while (__stxr(v19 + 1, v18));
  }
  os_unfair_lock_unlock(v12);
  if ((_DWORD)a5 == -1)
  {
    v20 = a1;
    v21 = a2;
    v22 = a3;
    v23 = 0xFFFFFFFFLL;
    v24 = a6;
    v25 = 0;
  }
  else
  {
    if (*(_DWORD *)(v17 + 68) <= a5)
    {
      v30 = __si_assert_copy_extra_268();
      v31 = v30;
      v32 = "";
      if (v30)
        v32 = v30;
      __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 2605, "partID == VECTOR_NOT_FOUND || partID < cur.partitions->nPartitions()", v32);
      free(v31);
      if (__valid_fs(-1))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
    v20 = a1;
    v21 = a2;
    v22 = a3;
    v23 = a5;
    v24 = a6;
    v25 = 1;
  }
  *((_QWORD *)IVFVectorIndexTemplate<float,512>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::lookupForInsert(v20, v21, v22, v23, v25, v24)+ 256) = a4;
  if (!v16)
    goto LABEL_15;
  v26 = (unint64_t *)&v16->__shared_owners_;
  do
    v27 = __ldaxr(v26);
  while (__stlxr(v27 - 1, v26));
  if (!v27)
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
    if (!v13)
      return;
  }
  else
  {
LABEL_15:
    if (!v13)
      return;
  }
  v28 = (unint64_t *)&v13->__shared_owners_;
  do
    v29 = __ldaxr(v28);
  while (__stlxr(v29 - 1, v28));
  if (!v29)
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
}

uint64_t ___ZNK22IVFVectorIndexTemplateIfLi512EE20IVFVectorIndexRoot_sI30vi_onefixedsize_disk_allocator16vi_disk_postingsE4dumpEbbPViPvU13block_pointerFbjPKvybjfE_block_invoke(uint64_t a1, uint64_t a2, BOOL *a3)
{
  uint64_t result;

  result = (*(uint64_t (**)(float))(*(_QWORD *)(a1 + 32) + 16))(*(float *)(a2 + 4));
  *a3 = **(_DWORD **)(a1 + 40) != 0;
  return result;
}

void IVFVectorIndexTemplate<float,512>::IVFVectorIndexRoot_s<vi_onefixedsize_memory_allocator,vi_memory_postings>::enumerator_s::next(uint64_t a1, uint64_t a2)
{
  uint64_t i;
  uint64_t v5;
  unsigned int *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t Ptr;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  if (*(_QWORD *)(a2 + 72))
  {
    for (i = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + ((*(_QWORD *)(a2 + 64) >> 5) & 0x7FFFFFFFFFFFFF8))
                        + 16 * *(_QWORD *)(a2 + 64));
          ;
          i = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + ((v11 >> 5) & 0x7FFFFFFFFFFFFF8))
                        + 16 * v11))
    {
      *(_DWORD *)a1 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)i + 16))(i);
      if (!*(_QWORD *)(a2 + 72))
        break;
      v5 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 40) + ((*(_QWORD *)(a2 + 64) >> 5) & 0x7FFFFFFFFFFFFF8))
                     + 16 * *(_QWORD *)(a2 + 64));
      v6 = (unsigned int *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v5 + 24))(v5);
      if (v6)
      {
        *(_DWORD *)(a1 + 4) = v6[1];
        Ptr = vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(*(_QWORD *)(a2 + 16) + 16), *v6, 2068);
        *(_DWORD *)(a1 + 8) = *(_DWORD *)(Ptr + 2064);
        *(_QWORD *)(a1 + 16) = Ptr;
        *(_QWORD *)(a1 + 24) = Ptr + 2048;
        return;
      }
      v7 = *(std::__shared_weak_count **)(*(_QWORD *)(*(_QWORD *)(a2 + 40)
                                                    + ((*(_QWORD *)(a2 + 64) >> 5) & 0x7FFFFFFFFFFFFF8))
                                        + 16 * *(_QWORD *)(a2 + 64)
                                        + 8);
      if (v7)
      {
        p_shared_owners = (unint64_t *)&v7->__shared_owners_;
        do
          v9 = __ldaxr(p_shared_owners);
        while (__stlxr(v9 - 1, p_shared_owners));
        if (!v9)
        {
          ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
          std::__shared_weak_count::__release_weak(v7);
        }
      }
      v10 = *(_QWORD *)(a2 + 72) - 1;
      v11 = *(_QWORD *)(a2 + 64) + 1;
      *(_QWORD *)(a2 + 64) = v11;
      *(_QWORD *)(a2 + 72) = v10;
      if (v11 >= 0x200)
      {
        operator delete(**(void ***)(a2 + 40));
        *(_QWORD *)(a2 + 40) += 8;
        v10 = *(_QWORD *)(a2 + 72);
        v11 = *(_QWORD *)(a2 + 64) - 256;
        *(_QWORD *)(a2 + 64) = v11;
      }
      if (!v10)
        return;
    }
  }
}

unint64_t IVFVectorIndexTemplate<float,512>::VectorStore<vi_onefixedsize_memory_allocator,vi_memory_postings>::Iterator::operator->(uint64_t a1, unsigned int a2)
{
  char *v3;
  char *v4;
  const char *v5;

  if (*(_DWORD *)(a1 + 24) <= a2)
  {
    v3 = __si_assert_copy_extra_268();
    v4 = v3;
    v5 = "";
    if (v3)
      v5 = v3;
    __message_assert("%s:%u: failed assertion '%s' %s ", "IVFVectorIndex.hh", 1802, "offset < store->endOffset()", v5);
    free(v4);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  return vi_onefixedsize_memory_allocator::getPtr(*(_QWORD **)(a1 + 16), a2, 2068);
}

BOOL IVFVectorIndexTemplate<float,512>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::exists(uint64_t a1, uint64_t a2)
{
  int Vector;
  int v6;
  NSObject *v7;
  std::__shared_weak_count *v8;
  uint64_t v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  std::__shared_weak_count *v12;
  uint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  unsigned int v16;
  uint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  std::__shared_weak_count *v26;
  unint64_t *v27;
  unint64_t v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  _QWORD v32[8];
  std::__shared_weak_count *v33;
  uint64_t v34;
  std::__shared_weak_count *v35;
  unsigned int v36;
  _QWORD v37[7];
  unsigned int v38;
  float v39;
  float v40;
  unsigned int v41;
  _BYTE buf[24];
  _DWORD v43[4];
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  v40 = 3.4028e38;
  v41 = -1;
  Vector = IVFVectorIndexTemplate<float,512>::IVFVectorIndexRoot_s<vi_onefixedsize_disk_allocator,vi_disk_postings>::findVector(a1, a2, (int *)&v41, &v40, 0);
  if (Vector == -1)
  {
    v6 = *__error();
    v7 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = "exists";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 2632;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v41;
      LOWORD(v43[0]) = 2048;
      *(double *)((char *)v43 + 2) = v40;
      _os_log_error_impl(&dword_1B8270000, v7, OS_LOG_TYPE_ERROR, "%s:%d: Vector not found partID=%u distsq=%e", buf, 0x22u);
    }
    *__error() = v6;
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 112));
    v9 = *(_QWORD *)(a1 + 80);
    v8 = *(std::__shared_weak_count **)(a1 + 88);
    if (v8)
    {
      p_shared_owners = (unint64_t *)&v8->__shared_owners_;
      do
        v11 = __ldxr(p_shared_owners);
      while (__stxr(v11 + 1, p_shared_owners));
    }
    v13 = *(_QWORD *)(a1 + 96);
    v12 = *(std::__shared_weak_count **)(a1 + 104);
    if (v12)
    {
      v14 = (unint64_t *)&v12->__shared_owners_;
      do
        v15 = __ldxr(v14);
      while (__stxr(v15 + 1, v14));
    }
    os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 112));
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    v43[0] = -1;
    *(_QWORD *)&buf[16] = 0x2000000000;
    v16 = v41;
    v17 = MEMORY[0x1E0C809B0];
    v37[0] = MEMORY[0x1E0C809B0];
    v37[1] = 0x40000000;
    v37[2] = ___ZN22IVFVectorIndexTemplateIfLi512EE20IVFVectorIndexRoot_sI30vi_onefixedsize_disk_allocator16vi_disk_postingsE6existsERK10CIVector_sIfLi512EE_block_invoke;
    v37[3] = &unk_1E6E345C8;
    v37[5] = a1;
    v37[6] = a2;
    v38 = v41;
    v39 = v40;
    v37[4] = buf;
    (*(void (**)(uint64_t, _QWORD, _QWORD *))(*(_QWORD *)v13 + 80))(v13, v41, v37);
    if (*(_DWORD *)(*(_QWORD *)&buf[8] + 24) == -1)
    {
      v32[0] = v17;
      v32[1] = 1174405120;
      v32[2] = ___ZN22IVFVectorIndexTemplateIfLi512EE20IVFVectorIndexRoot_sI30vi_onefixedsize_disk_allocator16vi_disk_postingsE6existsERK10CIVector_sIfLi512EE_block_invoke_1150;
      v32[3] = &unk_1E6E345F0;
      v32[5] = a1;
      v32[6] = a2;
      v32[7] = v9;
      v33 = v8;
      if (v8)
      {
        v22 = (unint64_t *)&v8->__shared_owners_;
        do
          v23 = __ldxr(v22);
        while (__stxr(v23 + 1, v22));
      }
      v34 = v13;
      v35 = v12;
      if (v12)
      {
        v24 = (unint64_t *)&v12->__shared_owners_;
        do
          v25 = __ldxr(v24);
        while (__stxr(v25 + 1, v24));
      }
      v36 = v16;
      v32[4] = buf;
      (*(void (**)(uint64_t, _QWORD *))(*(_QWORD *)v13 + 64))(v13, v32);
      v26 = v35;
      if (v35)
      {
        v27 = (unint64_t *)&v35->__shared_owners_;
        do
          v28 = __ldaxr(v27);
        while (__stlxr(v28 - 1, v27));
        if (!v28)
        {
          ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
          std::__shared_weak_count::__release_weak(v26);
        }
      }
      v29 = v33;
      if (v33)
      {
        v30 = (unint64_t *)&v33->__shared_owners_;
        do
          v31 = __ldaxr(v30);
        while (__stlxr(v31 - 1, v30));
        if (!v31)
        {
          ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
          std::__shared_weak_count::__release_weak(v29);
        }
      }
    }
    _Block_object_dispose(buf, 8);
    if (v12)
    {
      v18 = (unint64_t *)&v12->__shared_owners_;
      do
        v19 = __ldaxr(v18);
      while (__stlxr(v19 - 1, v18));
      if (!v19)
      {
        ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
        std::__shared_weak_count::__release_weak(v12);
      }
    }
    if (v8)
    {
      v20 = (unint64_t *)&v8->__shared_owners_;
      do
        v21 = __ldaxr(v20);
      while (__stlxr(v21 - 1, v20));
      if (!v21)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }
  }
  return Vector != -1;
}

void ___ZN22IVFVectorIndexTemplateIfLi512EE20IVFVectorIndexRoot_sI30vi_onefixedsize_disk_allocator16vi_disk_postingsE6existsERK10CIVector_sIfLi512EE_block_invoke_1150(uint64_t a1, int a2, float *a3, _BYTE *a4)
{
  const void *v8;
  uint64_t v9;
  const void *v10;
  int v11;
  NSObject *v12;
  const float *v13;
  const float *v14;
  float v15;
  int v16;
  NSObject *v17;
  int v18;
  NSObject *v19;
  int v20;
  NSObject *v21;
  int v22;
  NSObject *v23;
  int v24;
  NSObject *v25;
  int v26;
  NSObject *v27;
  uint64_t v28;
  unint64_t v29;
  int v30;
  NSObject *v31;
  int v32;
  NSObject *v33;
  int v34;
  NSObject *v35;
  int v36;
  NSObject *v37;
  int v38;
  NSObject *v39;
  double v40;
  int v41;
  int v42;
  float v43;
  int v44;
  float v45;
  _BOOL4 v46;
  int v47;
  int v48;
  _BOOL4 v49;
  int v50;
  int v51;
  _BOOL4 v52;
  int v53;
  int v54;
  _BOOL4 v55;
  int v56;
  int v57;
  float v58;
  float v59;
  double v60;
  float v61;
  _BOOL4 v62;
  _BOOL4 v63;
  int v64;
  float v65;
  int v66;
  float v67;
  _BOOL4 v68;
  int v69;
  int v70;
  _BOOL4 v71;
  int v72;
  int v73;
  _BOOL4 v74;
  int v75;
  int v76;
  _BOOL4 v77;
  int v78;
  int v79;
  float v80;
  float v81;
  float v82;
  _BOOL4 v83;
  _BOOL4 v84;
  _BOOL4 v85;
  float v86;
  float v87;
  float v88;
  float v89;
  void *__p;
  void *v91;
  uint64_t v92;
  void *v93;
  void *v94;
  uint64_t v95;
  float __C;
  const char *v97;
  __int16 v98;
  int v99;
  __int16 v100;
  int v101;
  __int16 v102;
  _BYTE v103[14];
  __int16 v104;
  double v105;
  __int16 v106;
  uint64_t v107;
  __int16 v108;
  _BOOL4 v109;
  __int16 v110;
  _BOOL4 v111;
  __int16 v112;
  _BOOL4 v113;
  __int16 v114;
  _BOOL4 v115;
  uint64_t v116;

  v116 = *MEMORY[0x1E0C80C00];
  v9 = *(_QWORD *)(a1 + 40);
  v8 = *(const void **)(a1 + 48);
  v10 = (const void *)_windowsResolvePtr(*(_QWORD *)(*(_QWORD *)(v9 + 48) + 32) + 40, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v9 + 48) + 32) + 24)+ *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v9 + 48) + 32) + 16) * *(unsigned int *)a3, 0x810uLL);
  if (!memcmp(v8, v10, 0x800uLL))
  {
    v11 = *__error();
    v12 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      v40 = a3[1];
      __C = 4.8153e-34;
      v97 = "exists_block_invoke";
      v98 = 1024;
      v99 = 2647;
      v100 = 1024;
      v101 = a2;
      v102 = 2048;
      *(double *)v103 = v40;
      _os_log_error_impl(&dword_1B8270000, v12, OS_LOG_TYPE_ERROR, "%s:%d: Vector not found actually in partID=%u distsq=%e", (uint8_t *)&__C, 0x22u);
    }
    *__error() = v11;
    v13 = *(const float **)(a1 + 48);
    v14 = (const float *)(*(uint64_t (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 56) + 64))(*(_QWORD *)(a1 + 56), *(unsigned int *)(a1 + 88));
    __C = 3.4028e38;
    vDSP_distancesq(v13, 1, v14, 1, &__C, 0x200uLL);
    v15 = __C;
    v16 = *__error();
    v17 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      v41 = *(_DWORD *)(a1 + 88);
      __C = 4.8153e-34;
      v97 = "exists_block_invoke";
      v98 = 1024;
      v99 = 2649;
      v100 = 1024;
      v101 = v41;
      v102 = 2048;
      *(double *)v103 = v15;
      _os_log_error_impl(&dword_1B8270000, v17, OS_LOG_TYPE_ERROR, "%s:%d: Vec distance to centroid %u distsq=%e", (uint8_t *)&__C, 0x22u);
    }
    *__error() = v16;
    v93 = 0;
    v94 = 0;
    v95 = 0;
    (*(void (**)(void **__return_ptr, _QWORD, _QWORD, uint64_t))(**(_QWORD **)(a1 + 56) + 72))(&v93, *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 48), 2);
    v18 = *__error();
    v19 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      v42 = *(_DWORD *)v93;
      v43 = *((float *)v93 + 1);
      v44 = *((_DWORD *)v93 + 2);
      v45 = *((float *)v93 + 3);
      v46 = v43 == v45 || vabds_f32(v43, v45) <= fmaxf(fminf(fabsf(v45), fabsf(v43)) * 0.000015259, 0.000015259);
      __C = 4.8156e-34;
      v97 = "exists_block_invoke";
      v98 = 1024;
      v99 = 2651;
      v100 = 1024;
      v101 = v42;
      v102 = 2048;
      *(double *)v103 = v43;
      *(_WORD *)&v103[8] = 1024;
      *(_DWORD *)&v103[10] = v44;
      v104 = 2048;
      v105 = v45;
      v106 = 1024;
      LODWORD(v107) = v46;
      _os_log_error_impl(&dword_1B8270000, v19, OS_LOG_TYPE_ERROR, "%s:%d: topKPartition(vec, 2) <%u, %e>, <%u, %e>, %d", (uint8_t *)&__C, 0x38u);
    }
    *__error() = v18;
    v20 = *__error();
    v21 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      v47 = *(_DWORD *)v93;
      v48 = *((_DWORD *)v93 + 2);
      v49 = *((float *)v93 + 1) == *((float *)v93 + 3);
      __C = 4.8154e-34;
      v97 = "exists_block_invoke";
      v98 = 1024;
      v99 = 2652;
      v100 = 1024;
      v101 = v47;
      v102 = 1024;
      *(_DWORD *)v103 = v48;
      *(_WORD *)&v103[4] = 1024;
      *(_DWORD *)&v103[6] = v49;
      _os_log_error_impl(&dword_1B8270000, v21, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) == distsq(%u) is %d", (uint8_t *)&__C, 0x24u);
    }
    *__error() = v20;
    v22 = *__error();
    v23 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      v50 = *(_DWORD *)v93;
      v51 = *((_DWORD *)v93 + 2);
      v52 = *((float *)v93 + 1) < *((float *)v93 + 3);
      __C = 4.8154e-34;
      v97 = "exists_block_invoke";
      v98 = 1024;
      v99 = 2653;
      v100 = 1024;
      v101 = v50;
      v102 = 1024;
      *(_DWORD *)v103 = v51;
      *(_WORD *)&v103[4] = 1024;
      *(_DWORD *)&v103[6] = v52;
      _os_log_error_impl(&dword_1B8270000, v23, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) < distsq(%u) is %d", (uint8_t *)&__C, 0x24u);
    }
    *__error() = v22;
    v24 = *__error();
    v25 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      v53 = *(_DWORD *)v93;
      v54 = *((_DWORD *)v93 + 2);
      v55 = *((float *)v93 + 1) > *((float *)v93 + 3);
      __C = 4.8154e-34;
      v97 = "exists_block_invoke";
      v98 = 1024;
      v99 = 2654;
      v100 = 1024;
      v101 = v53;
      v102 = 1024;
      *(_DWORD *)v103 = v54;
      *(_WORD *)&v103[4] = 1024;
      *(_DWORD *)&v103[6] = v55;
      _os_log_error_impl(&dword_1B8270000, v25, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) > distsq(%u) is %d", (uint8_t *)&__C, 0x24u);
    }
    *__error() = v24;
    v26 = *__error();
    v27 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      v56 = *(_DWORD *)v93;
      v57 = *((_DWORD *)v93 + 2);
      v58 = *((float *)v93 + 1);
      v59 = *((float *)v93 + 3);
      v60 = (float)(v58 - v59);
      v61 = vabds_f32(v58, v59);
      if (v58 == v59)
      {
        v62 = 1;
        v63 = 1;
      }
      else
      {
        v86 = fabsf(v58);
        v87 = fabsf(v59);
        v62 = v61 <= fmaxf(fminf(v87, v86) * 0.000015259, 0.000015259);
        v63 = v61 <= (float)(fmaxf(v86, v87) * 0.000015259);
      }
      __C = 4.8161e-34;
      v97 = "exists_block_invoke";
      v98 = 1024;
      v99 = 2655;
      v100 = 1024;
      v101 = v56;
      v102 = 1024;
      *(_DWORD *)v103 = v57;
      *(_WORD *)&v103[4] = 2048;
      *(double *)&v103[6] = v60;
      v104 = 2048;
      v105 = 1.17549435e-38;
      v106 = 2048;
      v107 = 0x3E80000000000000;
      v108 = 1024;
      v109 = v61 < 1.1755e-38;
      v110 = 1024;
      v111 = v61 < 0.00000011921;
      v112 = 1024;
      v113 = v62;
      v114 = 1024;
      v115 = v63;
      _os_log_error_impl(&dword_1B8270000, v27, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) - distsq(%u) = %e, FLT_MIN=%e, EPSILON=%e, %d, %d, %d, %d", (uint8_t *)&__C, 0x54u);
    }
    *__error() = v26;
    v91 = 0;
    v92 = 0;
    __p = 0;
    v28 = *(_QWORD *)(a1 + 56);
    v29 = _windowsResolvePtr(*(_QWORD *)(*(_QWORD *)(v9 + 48) + 32) + 40, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v9 + 48) + 32) + 24)+ *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v9 + 48) + 32) + 16) * *(unsigned int *)a3, 0x810uLL);
    (*(void (**)(void **__return_ptr, uint64_t, unint64_t, uint64_t))(*(_QWORD *)v28 + 72))(&__p, v28, v29, 2);
    v30 = *__error();
    v31 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
    {
      v64 = *(_DWORD *)__p;
      v65 = *((float *)__p + 1);
      v66 = *((_DWORD *)__p + 2);
      v67 = *((float *)__p + 3);
      v68 = v65 == v67 || vabds_f32(v65, v67) <= fmaxf(fminf(fabsf(v67), fabsf(v65)) * 0.000015259, 0.000015259);
      __C = 4.8156e-34;
      v97 = "exists_block_invoke";
      v98 = 1024;
      v99 = 2658;
      v100 = 1024;
      v101 = v64;
      v102 = 2048;
      *(double *)v103 = v65;
      *(_WORD *)&v103[8] = 1024;
      *(_DWORD *)&v103[10] = v66;
      v104 = 2048;
      v105 = v67;
      v106 = 1024;
      LODWORD(v107) = v68;
      _os_log_error_impl(&dword_1B8270000, v31, OS_LOG_TYPE_ERROR, "%s:%d: topKPartition(entry->vec, 2) <%u, %e>, <%u, %e>, %d", (uint8_t *)&__C, 0x38u);
    }
    *__error() = v30;
    v32 = *__error();
    v33 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
    {
      v69 = *(_DWORD *)__p;
      v70 = *((_DWORD *)__p + 2);
      v71 = *((float *)__p + 1) == *((float *)__p + 3);
      __C = 4.8154e-34;
      v97 = "exists_block_invoke";
      v98 = 1024;
      v99 = 2659;
      v100 = 1024;
      v101 = v69;
      v102 = 1024;
      *(_DWORD *)v103 = v70;
      *(_WORD *)&v103[4] = 1024;
      *(_DWORD *)&v103[6] = v71;
      _os_log_error_impl(&dword_1B8270000, v33, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) == distsq(%u) is %d", (uint8_t *)&__C, 0x24u);
    }
    *__error() = v32;
    v34 = *__error();
    v35 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
    {
      v72 = *(_DWORD *)__p;
      v73 = *((_DWORD *)__p + 2);
      v74 = *((float *)__p + 1) < *((float *)__p + 3);
      __C = 4.8154e-34;
      v97 = "exists_block_invoke";
      v98 = 1024;
      v99 = 2660;
      v100 = 1024;
      v101 = v72;
      v102 = 1024;
      *(_DWORD *)v103 = v73;
      *(_WORD *)&v103[4] = 1024;
      *(_DWORD *)&v103[6] = v74;
      _os_log_error_impl(&dword_1B8270000, v35, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) < distsq(%u) is %d", (uint8_t *)&__C, 0x24u);
    }
    *__error() = v34;
    v36 = *__error();
    v37 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
    {
      v75 = *(_DWORD *)__p;
      v76 = *((_DWORD *)__p + 2);
      v77 = *((float *)__p + 1) > *((float *)__p + 3);
      __C = 4.8154e-34;
      v97 = "exists_block_invoke";
      v98 = 1024;
      v99 = 2661;
      v100 = 1024;
      v101 = v75;
      v102 = 1024;
      *(_DWORD *)v103 = v76;
      *(_WORD *)&v103[4] = 1024;
      *(_DWORD *)&v103[6] = v77;
      _os_log_error_impl(&dword_1B8270000, v37, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) > distsq(%u) is %d", (uint8_t *)&__C, 0x24u);
    }
    *__error() = v36;
    v38 = *__error();
    v39 = _SILogForLogForCategory(16);
    if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
    {
      v78 = *(_DWORD *)__p;
      v79 = *((_DWORD *)__p + 2);
      v80 = *((float *)__p + 1);
      v81 = *((float *)__p + 3);
      v82 = vabds_f32(v80, v81);
      v83 = (float)(v80 - v81) < 1.1755e-38;
      if (v80 == v81)
      {
        v84 = 1;
        v85 = 1;
      }
      else
      {
        v88 = fabsf(v80);
        v89 = fabsf(v81);
        v84 = v82 <= fmaxf(fminf(v89, v88) * 0.000015259, 0.000015259);
        v85 = v82 <= (float)(fmaxf(v88, v89) * 0.000015259);
      }
      __C = 4.8161e-34;
      v97 = "exists_block_invoke";
      v98 = 1024;
      v99 = 2662;
      v100 = 1024;
      v101 = v78;
      v102 = 1024;
      *(_DWORD *)v103 = v79;
      *(_WORD *)&v103[4] = 2048;
      *(double *)&v103[6] = v82;
      v104 = 2048;
      v105 = 1.17549435e-38;
      v106 = 2048;
      v107 = 0x3E80000000000000;
      v108 = 1024;
      v109 = v83;
      v110 = 1024;
      v111 = v82 < 0.00000011921;
      v112 = 1024;
      v113 = v84;
      v114 = 1024;
      v115 = v85;
      _os_log_error_impl(&dword_1B8270000, v39, OS_LOG_TYPE_ERROR, "%s:%d: distsq(%u) - distsq(%u) = %e, FLT_MIN=%e, EPSILON=%e, %d, %d, %d, %d", (uint8_t *)&__C, 0x54u);
    }
    *__error() = v38;
    *(float *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *a3;
    *a4 = 1;
    if (__p)
    {
      v91 = __p;
      operator delete(__p);
    }
    if (v93)
    {
      v94 = v93;
      operator delete(v93);
    }
  }
}

_QWORD *__copy_helper_block_8_56c60_ZTSN22IVFVectorIndexTemplateIfLi512EE19QuantizerPartitionsE(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;

  v2 = a2[8];
  result[7] = a2[7];
  result[8] = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  v5 = a2[10];
  result[9] = a2[9];
  result[10] = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  return result;
}

void __destroy_helper_block_8_56c60_ZTSN22IVFVectorIndexTemplateIfLi512EE19QuantizerPartitionsE(uint64_t a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *v6;
  unint64_t v7;

  v2 = *(std::__shared_weak_count **)(a1 + 80);
  if (!v2)
    goto LABEL_5;
  p_shared_owners = (unint64_t *)&v2->__shared_owners_;
  do
    v4 = __ldaxr(p_shared_owners);
  while (__stlxr(v4 - 1, p_shared_owners));
  if (!v4)
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    v5 = *(std::__shared_weak_count **)(a1 + 64);
    if (!v5)
      return;
  }
  else
  {
LABEL_5:
    v5 = *(std::__shared_weak_count **)(a1 + 64);
    if (!v5)
      return;
  }
  v6 = (unint64_t *)&v5->__shared_owners_;
  do
    v7 = __ldaxr(v6);
  while (__stlxr(v7 - 1, v6));
  if (!v7)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
}

void QuantizerManager<float,256>::sharedQuantizer(_QWORD *a1, uint64_t a2, int a3)
{
  unsigned __int8 v6;
  unint64_t *v7;
  unint64_t v8;
  NSObject *v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  std::__shared_weak_count *v13;
  unint64_t *v14;
  unint64_t v15;
  _QWORD v16[6];
  int v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  __n128 (*v21)(uint64_t, uint64_t);
  void (*v22)(uint64_t);
  uint64_t v23;
  uint64_t v24;

  v18 = 0;
  v19 = &v18;
  v20 = 0x3802000000;
  v21 = __Block_byref_object_copy__569;
  v22 = __Block_byref_object_dispose__570;
  v23 = 0;
  v24 = 0;
  if ((v6 & 1) == 0
  {
    __cxa_atexit((void (*)(void *))std::shared_ptr<Quantizer<float,256>>::~shared_ptr[abi:nn180100], &ZeroVectorQuantizer<float,256>::sharedInstance(void)::zvq, &dword_1B8270000);
  }
  if (ZeroVectorQuantizer<float,256>::sharedInstance(void)::onceToken != -1)
    dispatch_once(&ZeroVectorQuantizer<float,256>::sharedInstance(void)::onceToken, &__block_literal_global_511);
  v23 = ZeroVectorQuantizer<float,256>::sharedInstance(void)::zvq;
  v24 = qword_1EF1AEE08;
  if (qword_1EF1AEE08)
  {
    v7 = (unint64_t *)(qword_1EF1AEE08 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  v9 = *(NSObject **)(a2 + 16);
  v16[0] = MEMORY[0x1E0C809B0];
  v16[1] = 0x40000000;
  v16[2] = ___ZN16QuantizerManagerIfLi256EE15sharedQuantizerEi_block_invoke;
  v16[3] = &unk_1E6E325F8;
  v17 = a3;
  v16[4] = &v18;
  v16[5] = a2;
  dispatch_sync(v9, v16);
  v10 = v19[6];
  *a1 = v19[5];
  a1[1] = v10;
  if (v10)
  {
    v11 = (unint64_t *)(v10 + 8);
    do
      v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
  }
  _Block_object_dispose(&v18, 8);
  v13 = (std::__shared_weak_count *)v24;
  if (v24)
  {
    v14 = (unint64_t *)(v24 + 8);
    do
      v15 = __ldaxr(v14);
    while (__stlxr(v15 - 1, v14));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
  }
}

__n128 __Block_byref_object_copy__569(uint64_t a1, uint64_t a2)
{
  __n128 result;

  result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 40) = result;
  *(_QWORD *)(a2 + 40) = 0;
  *(_QWORD *)(a2 + 48) = 0;
  return result;
}

void __Block_byref_object_dispose__570(uint64_t a1)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v3;

  v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

uint64_t std::shared_ptr<Quantizer<float,256>>::~shared_ptr[abi:nn180100](uint64_t a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;

  v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  return a1;
}

void ___ZN16QuantizerManagerIfLi256EE15sharedQuantizerEi_block_invoke(uint64_t a1)
{
  int *v2;
  unint64_t v3;
  uint64_t v4;
  int8x8_t v5;
  uint8x8_t v6;
  unint64_t v7;
  uint64_t **v8;
  uint64_t *v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  int v13;
  size_t v14;
  unint64_t v15;
  std::string *p_dst;
  uint64_t v17;
  uint64_t v18;
  const void *v19;
  std::string *v20;
  std::string::size_type size;
  std::string *v22;
  std::string::size_type v23;
  std::string *v24;
  int64_t v25;
  const char *v26;
  _QWORD *v27;
  _QWORD *v28;
  uint64_t v29;
  std::__shared_weak_count *v30;
  std::__shared_weak_count *v31;
  unint64_t *p_shared_owners;
  unint64_t v33;
  uint64_t v34;
  std::__shared_weak_count *v35;
  unint64_t *v36;
  unint64_t v37;
  unint64_t *p_shared_weak_owners;
  unint64_t v39;
  _QWORD *v40;
  std::__shared_weak_count *v41;
  std::__shared_weak_count *v42;
  unint64_t *v43;
  unint64_t v44;
  unint64_t *v45;
  unint64_t v46;
  uint64_t v47;
  std::__shared_weak_count *v48;
  std::__shared_weak_count *v49;
  unint64_t v50;
  uint64_t v51;
  unsigned __int8 v52;
  std::__shared_weak_count *v53;
  uint64_t v54;
  unint64_t *v55;
  unint64_t v56;
  uint64_t v57;
  unint64_t v58;
  uint64_t v59;
  uint64_t v60;
  unint64_t *v61;
  unint64_t v62;
  uint64_t v63;
  std::__shared_weak_count *v64;
  unint64_t *v65;
  unint64_t v66;
  int v67;
  size_t v68;
  unint64_t v69;
  char *v70;
  uint64_t v71;
  uint64_t v72;
  const void *v73;
  const char *v74;
  _QWORD *v75;
  _QWORD *v76;
  uint64_t v77;
  _QWORD *v78;
  std::__shared_weak_count *v79;
  unint64_t *v80;
  unint64_t v81;
  unint64_t *v82;
  unint64_t v83;
  uint64_t v84;
  std::__shared_weak_count *v85;
  unint64_t *v86;
  unint64_t v87;
  _QWORD *v88;
  std::__shared_weak_count *v89;
  uint64_t v90;
  uint64_t v91;
  std::__shared_weak_count *v92;
  unint64_t *v93;
  unint64_t v94;
  _QWORD v95[2];
  int v96;
  char v97;
  _BYTE v98[11];
  _QWORD v99[2];
  int v100;
  char v101;
  _BYTE v102[11];
  std::string v103;
  std::string __dst;
  std::string v105;
  __int128 v106;
  int64_t v107;

  v2 = (int *)(a1 + 48);
  v3 = *(int *)(a1 + 48);
  v4 = *(_QWORD *)(a1 + 40);
  if (!(_DWORD)v3)
    goto LABEL_79;
  v5 = *(int8x8_t *)(v4 + 120);
  if (!*(_QWORD *)&v5)
    goto LABEL_22;
  v6 = (uint8x8_t)vcnt_s8(v5);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    v7 = *(int *)(a1 + 48);
    if (*(_QWORD *)&v5 <= v3)
      v7 = v3 % *(_QWORD *)&v5;
  }
  else
  {
    v7 = (*(_QWORD *)&v5 - 1) & v3;
  }
  v8 = *(uint64_t ***)(*(_QWORD *)(v4 + 112) + 8 * v7);
  if (!v8 || (v9 = *v8) == 0)
  {
LABEL_22:
    v106 = 0uLL;
    v107 = 0;
    v13 = *(char *)(v4 + 71);
    if (v13 >= 0)
      v14 = *(unsigned __int8 *)(v4 + 71);
    else
      v14 = *(_QWORD *)(v4 + 56);
    v15 = v14 + 1;
    if (v14 + 1 > 0x7FFFFFFFFFFFFFF7)
      goto LABEL_147;
    if (v15 >= 0x17)
    {
      v17 = (v15 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v15 | 7) != 0x17)
        v17 = v15 | 7;
      v18 = v17 + 1;
      p_dst = (std::string *)operator new(v17 + 1);
      __dst.__r_.__value_.__l.__size_ = v14 + 1;
      __dst.__r_.__value_.__r.__words[2] = v18 | 0x8000000000000000;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    }
    else
    {
      memset(&__dst, 0, sizeof(__dst));
      p_dst = &__dst;
      *((_BYTE *)&__dst.__r_.__value_.__s + 23) = v14 + 1;
      if (!v14)
        goto LABEL_36;
    }
    if (v13 >= 0)
      v19 = (const void *)(v4 + 48);
    else
      v19 = *(const void **)(v4 + 48);
    memmove(p_dst, v19, v14);
LABEL_36:
    *(_WORD *)((char *)&p_dst->__r_.__value_.__l.__data_ + v14) = 46;
    std::to_string(&v103, v3);
    if ((v103.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v20 = &v103;
    else
      v20 = (std::string *)v103.__r_.__value_.__r.__words[0];
    if ((v103.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      size = HIBYTE(v103.__r_.__value_.__r.__words[2]);
    else
      size = v103.__r_.__value_.__l.__size_;
    v22 = std::string::append(&__dst, (const std::string::value_type *)v20, size);
    v23 = v22->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v105.__r_.__value_.__l.__data_ = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
    v105.__r_.__value_.__r.__words[2] = v23;
    v22->__r_.__value_.__l.__size_ = 0;
    v22->__r_.__value_.__r.__words[2] = 0;
    v22->__r_.__value_.__r.__words[0] = 0;
    v24 = std::string::append(&v105, ".quantizer");
    v25 = v24->__r_.__value_.__r.__words[2];
    v106 = *(_OWORD *)&v24->__r_.__value_.__l.__data_;
    v107 = v25;
    v24->__r_.__value_.__l.__size_ = 0;
    v24->__r_.__value_.__r.__words[2] = 0;
    v24->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v105.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v105.__r_.__value_.__l.__data_);
      if ((SHIBYTE(v103.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      {
LABEL_44:
        if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          goto LABEL_45;
LABEL_67:
        operator delete(__dst.__r_.__value_.__l.__data_);
LABEL_45:
        if (v107 >= 0)
          v26 = (const char *)&v106;
        else
          v26 = (const char *)v106;
        v27 = fd_create_protected(*(_DWORD *)v4, v26, 0, 3u);
        if (!v27)
          goto LABEL_76;
        v28 = v27;
        v29 = operator new();
        v99[0] = v28;
        v99[1] = 0x1000000;
        v100 = 0;
        v101 = 1;
        memset(v102, 0, sizeof(v102));
        AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,256>::AllocatedVectorQuantizer(v29, (uint64_t)v99);
        v30 = (std::__shared_weak_count *)operator new();
        v31 = v30;
        v30->__shared_owners_ = 0;
        p_shared_owners = (unint64_t *)&v30->__shared_owners_;
        v30->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6E32688;
        v30->__shared_weak_owners_ = 0;
        v30[1].__vftable = (std::__shared_weak_count_vtbl *)v29;
        do
          v33 = __ldxr(p_shared_owners);
        while (__stxr(v33 + 1, p_shared_owners));
        v34 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
        v35 = *(std::__shared_weak_count **)(v34 + 48);
        *(_QWORD *)(v34 + 40) = v29;
        *(_QWORD *)(v34 + 48) = v30;
        if (v35)
        {
          v36 = (unint64_t *)&v35->__shared_owners_;
          do
            v37 = __ldaxr(v36);
          while (__stlxr(v37 - 1, v36));
          if (!v37)
          {
            ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
            std::__shared_weak_count::__release_weak(v35);
          }
        }
        p_shared_weak_owners = (unint64_t *)&v31->__shared_weak_owners_;
        do
          v39 = __ldxr(p_shared_weak_owners);
        while (__stxr(v39 + 1, p_shared_weak_owners));
        v40 = std::__hash_table<std::__hash_value_type<int,std::weak_ptr<Quantizer<float,768>>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::weak_ptr<Quantizer<float,768>>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::weak_ptr<Quantizer<float,768>>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::weak_ptr<Quantizer<float,768>>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(v4 + 112, *v2, v2);
        v41 = std::__shared_weak_count::lock(v31);
        v42 = v41;
        if (v41)
        {
          v43 = (unint64_t *)&v41->__shared_weak_owners_;
          do
            v44 = __ldxr(v43);
          while (__stxr(v44 + 1, v43));
          std::__shared_weak_count::__release_weak(v31);
          v45 = (unint64_t *)&v42->__shared_owners_;
          do
            v46 = __ldaxr(v45);
          while (__stlxr(v46 - 1, v45));
          if (v46)
          {
            v47 = v29;
            goto LABEL_71;
          }
          ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
          v48 = v42;
          v47 = v29;
        }
        else
        {
          v47 = 0;
          v48 = v31;
        }
        std::__shared_weak_count::__release_weak(v48);
LABEL_71:
        v49 = (std::__shared_weak_count *)v40[4];
        v40[3] = v47;
        v40[4] = v42;
        if (v49)
          std::__shared_weak_count::__release_weak(v49);
        atomic_store(1u, (unsigned __int8 *)(v29 + 57));
        do
          v50 = __ldaxr(p_shared_owners);
        while (__stlxr(v50 - 1, p_shared_owners));
        if (!v50)
        {
          ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
          std::__shared_weak_count::__release_weak(v31);
          if ((SHIBYTE(v107) & 0x80000000) == 0)
            goto LABEL_79;
          goto LABEL_77;
        }
LABEL_76:
        if ((SHIBYTE(v107) & 0x80000000) == 0)
          goto LABEL_79;
LABEL_77:
        operator delete((void *)v106);
        goto LABEL_79;
      }
    }
    else if ((SHIBYTE(v103.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      goto LABEL_44;
    }
    operator delete(v103.__r_.__value_.__l.__data_);
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
      goto LABEL_45;
    goto LABEL_67;
  }
  if (v6.u32[0] < 2uLL)
  {
    v10 = *(_QWORD *)&v5 - 1;
    while (1)
    {
      v12 = v9[1];
      if (v12 == v3)
      {
        if (*((_DWORD *)v9 + 4) == (_DWORD)v3)
          goto LABEL_136;
      }
      else if ((v12 & v10) != v7)
      {
        goto LABEL_22;
      }
      v9 = (uint64_t *)*v9;
      if (!v9)
        goto LABEL_22;
    }
  }
  while (1)
  {
    v11 = v9[1];
    if (v11 == v3)
      break;
    if (v11 >= *(_QWORD *)&v5)
      v11 %= *(_QWORD *)&v5;
    if (v11 != v7)
      goto LABEL_22;
LABEL_12:
    v9 = (uint64_t *)*v9;
    if (!v9)
      goto LABEL_22;
  }
  if (*((_DWORD *)v9 + 4) != (_DWORD)v3)
    goto LABEL_12;
LABEL_136:
  v88 = std::__hash_table<std::__hash_value_type<int,std::weak_ptr<Quantizer<float,768>>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,std::weak_ptr<Quantizer<float,768>>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,std::weak_ptr<Quantizer<float,768>>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,std::weak_ptr<Quantizer<float,768>>>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(v4 + 112, v3, v2);
  v89 = (std::__shared_weak_count *)v88[4];
  if (v89 && (v89 = std::__shared_weak_count::lock(v89)) != 0)
    v90 = v88[3];
  else
    v90 = 0;
  v91 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v92 = *(std::__shared_weak_count **)(v91 + 48);
  *(_QWORD *)(v91 + 40) = v90;
  *(_QWORD *)(v91 + 48) = v89;
  if (v92)
  {
    v93 = (unint64_t *)&v92->__shared_owners_;
    do
      v94 = __ldaxr(v93);
    while (__stlxr(v94 - 1, v93));
    if (!v94)
    {
      ((void (*)(std::__shared_weak_count *))v92->__on_zero_shared)(v92);
      std::__shared_weak_count::__release_weak(v92);
    }
  }
LABEL_79:
  v51 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if ((v52 & 1) == 0
  {
    __cxa_atexit((void (*)(void *))std::shared_ptr<Quantizer<float,256>>::~shared_ptr[abi:nn180100], &ZeroVectorQuantizer<float,256>::sharedInstance(void)::zvq, &dword_1B8270000);
  }
  if (ZeroVectorQuantizer<float,256>::sharedInstance(void)::onceToken != -1)
    dispatch_once(&ZeroVectorQuantizer<float,256>::sharedInstance(void)::onceToken, &__block_literal_global_511);
  v54 = ZeroVectorQuantizer<float,256>::sharedInstance(void)::zvq;
  v53 = (std::__shared_weak_count *)qword_1EF1AEE08;
  if (!qword_1EF1AEE08)
  {
    if (*(_QWORD *)(v51 + 40) != ZeroVectorQuantizer<float,256>::sharedInstance(void)::zvq)
      return;
LABEL_93:
    v59 = *(_QWORD *)(v4 + 80);
    if (v59)
    {
      v60 = *(_QWORD *)(v4 + 88);
      if (v60)
      {
        v61 = (unint64_t *)(v60 + 8);
        do
          v62 = __ldxr(v61);
        while (__stxr(v62 + 1, v61));
      }
      v63 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
      v64 = *(std::__shared_weak_count **)(v63 + 48);
      *(_QWORD *)(v63 + 40) = v59;
      *(_QWORD *)(v63 + 48) = v60;
      if (v64)
      {
        v65 = (unint64_t *)&v64->__shared_owners_;
        do
          v66 = __ldaxr(v65);
        while (__stlxr(v66 - 1, v65));
        if (!v66)
        {
          ((void (*)(std::__shared_weak_count *))v64->__on_zero_shared)(v64);
          std::__shared_weak_count::__release_weak(v64);
        }
      }
      return;
    }
    v67 = *(char *)(v4 + 71);
    if (v67 >= 0)
      v68 = *(unsigned __int8 *)(v4 + 71);
    else
      v68 = *(_QWORD *)(v4 + 56);
    v69 = v68 + 10;
    if (v68 + 10 <= 0x7FFFFFFFFFFFFFF7)
    {
      if (v69 >= 0x17)
      {
        v71 = (v69 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v69 | 7) != 0x17)
          v71 = v69 | 7;
        v72 = v71 + 1;
        v70 = (char *)operator new(v71 + 1);
        *((_QWORD *)&v106 + 1) = v68 + 10;
        v107 = v72 | 0x8000000000000000;
        *(_QWORD *)&v106 = v70;
      }
      else
      {
        v107 = 0;
        v106 = 0uLL;
        v70 = (char *)&v106;
        HIBYTE(v107) = v68 + 10;
        if (!v68)
        {
LABEL_116:
          strcpy(&v70[v68], ".quantizer");
          if (v107 >= 0)
            v74 = (const char *)&v106;
          else
            v74 = (const char *)v106;
          v75 = fd_create_protected(*(_DWORD *)v4, v74, 0, 3u);
          if (v75)
          {
            v76 = v75;
            v77 = operator new();
            v95[0] = v76;
            v95[1] = 0x1000000;
            v96 = 0;
            v97 = 1;
            memset(v98, 0, sizeof(v98));
            AllocatedVectorQuantizer<vi_onefixedsize_disk_allocator,float,256>::AllocatedVectorQuantizer(v77, (uint64_t)v95);
            v78 = (_QWORD *)operator new();
            *v78 = &off_1E6E32688;
            v78[1] = 0;
            v78[2] = 0;
            v78[3] = v77;
            v79 = *(std::__shared_weak_count **)(v4 + 88);
            *(_QWORD *)(v4 + 80) = v77;
            *(_QWORD *)(v4 + 88) = v78;
            if (!v79)
              goto LABEL_126;
            v80 = (unint64_t *)&v79->__shared_owners_;
            do
              v81 = __ldaxr(v80);
            while (__stlxr(v81 - 1, v80));
            if (!v81)
            {
              ((void (*)(std::__shared_weak_count *))v79->__on_zero_shared)(v79);
              std::__shared_weak_count::__release_weak(v79);
            }
            v77 = *(_QWORD *)(v4 + 80);
            v78 = *(_QWORD **)(v4 + 88);
            if (v78)
            {
LABEL_126:
              v82 = v78 + 1;
              do
                v83 = __ldxr(v82);
              while (__stxr(v83 + 1, v82));
            }
            v84 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
            v85 = *(std::__shared_weak_count **)(v84 + 48);
            *(_QWORD *)(v84 + 40) = v77;
            *(_QWORD *)(v84 + 48) = v78;
            if (v85)
            {
              v86 = (unint64_t *)&v85->__shared_owners_;
              do
                v87 = __ldaxr(v86);
              while (__stlxr(v87 - 1, v86));
              if (!v87)
              {
                ((void (*)(std::__shared_weak_count *))v85->__on_zero_shared)(v85);
                std::__shared_weak_count::__release_weak(v85);
              }
            }
          }
          if (SHIBYTE(v107) < 0)
            operator delete((void *)v106);
          return;
        }
      }
      if (v67 >= 0)
        v73 = (const void *)(v4 + 48);
      else
        v73 = *(const void **)(v4 + 48);
      memmove(v70, v73, v68);
      goto LABEL_116;
    }
LABEL_147:
    abort();
  }
  v55 = (unint64_t *)(qword_1EF1AEE08 + 8);
  do
    v56 = __ldxr(v55);
  while (__stxr(v56 + 1, v55));
  v57 = *(_QWORD *)(v51 + 40);
  do
    v58 = __ldaxr(v55);
  while (__stlxr(v58 - 1, v55));
  if (v58)
  {
    if (v57 == v54)
      goto LABEL_93;
  }
  else
  {
    ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
    std::__shared_weak_count::__release_weak(v53);
    if (v57 == v54)
      goto LABEL_93;
  }
}

