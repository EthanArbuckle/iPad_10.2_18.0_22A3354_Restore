void SIValueSet<unsigned int>::RLEKeyHolder<unsigned int>::Apply(uint64_t a1, uint64_t a2, int a3, void (*a4)(char *, uint64_t, uint64_t), uint64_t a5)
{
  uint64_t v9;
  size_t v10;
  char *v11;
  uint64_t v12;
  int *v13;
  unint64_t v14;
  int v15;
  int v16;
  uint64_t v17;
  int *v18;
  _QWORD v19[2];

  v19[1] = *MEMORY[0x1E0C80C00];
  v9 = MEMORY[0x1E0C80A78](a1);
  v11 = (char *)v19 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = *(unsigned int *)(v9 + 8);
  if (v12 > 0x3F)
    return;
  v13 = (int *)(v9 + 12);
  v14 = v9 + 12 + 4 * v12;
  bzero((char *)v19 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0), v10);
  v15 = 0;
  v16 = 0;
LABEL_3:
  v17 = 0;
  while (v16)
  {
    --v16;
    ++v15;
LABEL_15:
    *(_DWORD *)&v11[4 * v17++] = v15 | a3;
    if (v17 == a2)
    {
      a4(v11, a2, a5);
      goto LABEL_3;
    }
  }
  if ((unint64_t)v13 < v14)
  {
    v18 = v13 + 1;
    v15 = *v13;
    if ((unint64_t)(v13 + 1) >= v14)
    {
      v16 = 0;
      ++v13;
    }
    else
    {
      if (*v18 < 0)
        v13 += 2;
      else
        ++v13;
      if (*v18 < 0)
        v16 = *v18 & 0x7FFFFFFF;
      else
        v16 = 0;
    }
    goto LABEL_15;
  }
  if (v17)
    a4(v11, v17, a5);
}

BOOL SIValueSet<unsigned int>::RLEKeyHolder<unsigned int>::IsEmpty(uint64_t a1)
{
  return *(_DWORD *)(a1 + 8) == 0;
}

uint64_t SIValueSet<unsigned int>::RLEKeyHolder<unsigned int>::GetRawCount(uint64_t a1)
{
  return *(unsigned int *)(a1 + 8);
}

uint64_t SIValueSet<unsigned int>::RLEKeyHolder<unsigned int>::Serialize(uint64_t a1, uint64_t a2)
{
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 8))(a2, 4);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 8))(a2, *(unsigned int *)(a1 + 8));
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 16))(a2, a1 + 12, 4 * *(unsigned int *)(a1 + 8));
}

void SIValueSet<unsigned int>::RLEKeyHolder<unsigned int>::~RLEKeyHolder()
{
  JUMPOUT(0x1BCCB06A4);
}

uint64_t SIValueSet<unsigned int>::RLEKeyHolder<unsigned int>::valueIterator(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(unsigned int *)(a1 + 8);
  *(_QWORD *)a3 = off_1E6E2A3F8;
  *(_QWORD *)(a3 + 8) = a1 + 12;
  *(_QWORD *)(a3 + 16) = a1 + 12 + 4 * v3;
  *(_QWORD *)(a3 + 24) = 0;
  *(_DWORD *)(a3 + 32) = a2;
  return a3;
}

uint64_t SIValueSet<unsigned int>::RLEKeyHolder<unsigned int>::RLEKeyIterator::nextKey(uint64_t a1)
{
  unsigned int v1;
  int v2;
  int v3;
  int v4;
  int *v6;
  unint64_t v7;
  int v8;
  int v9;

  v2 = *(_DWORD *)(a1 + 28);
  v1 = *(_DWORD *)(a1 + 32);
  if (v2)
  {
    v3 = v2 - 1;
    v4 = *(_DWORD *)(a1 + 24) + 1;
    *(_DWORD *)(a1 + 24) = v4;
    *(_DWORD *)(a1 + 28) = v3;
    return v4 | v1;
  }
  else
  {
    v6 = *(int **)(a1 + 8);
    v7 = *(_QWORD *)(a1 + 16);
    v8 = *v6;
    *(_QWORD *)(a1 + 8) = v6 + 1;
    *(_DWORD *)(a1 + 24) = v8;
    if ((unint64_t)(v6 + 1) < v7 && (v9 = v6[1], v9 < 0))
    {
      *(_QWORD *)(a1 + 8) = v6 + 2;
      *(_DWORD *)(a1 + 28) = v9 & 0x7FFFFFFF;
      return v8 | v1;
    }
    else
    {
      return v8 | v1;
    }
  }
}

BOOL SIValueSet<unsigned int>::RLEKeyHolder<unsigned int>::RLEKeyIterator::hasMore(uint64_t a1)
{
  return *(_DWORD *)(a1 + 28) || *(_QWORD *)(a1 + 8) < *(_QWORD *)(a1 + 16);
}

void SIValueSet<unsigned int>::RLEKeyHolder<unsigned int>::RLEKeyIterator::~RLEKeyIterator()
{
  JUMPOUT(0x1BCCB06A4);
}

BOOL SIValueSet<unsigned int>::RLEKeyHolder<unsigned long long>::AddKey(uint64_t a1, unsigned int a2, int a3)
{
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t *v8;
  unint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  int *v17;
  unint64_t *v18;
  int v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t *v22;
  char v23;
  unint64_t v24;
  int *v25;
  uint64_t v26;
  int *v27;
  uint64_t v28;
  BOOL v29;
  _BOOL8 v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  BOOL v34;
  _BOOL8 v35;
  uint64_t v36;
  unsigned int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  unint64_t v42;
  BOOL v43;
  uint64_t v44;
  uint64_t v45;
  _QWORD *v46;
  char *v47;
  char *v48;
  const char *v49;
  char *v50;
  const char *v51;
  unint64_t v52;
  unint64_t *v53;
  char *v55;
  char *v56;
  const char *v57;
  uint64_t v58;
  char *v59;
  char *v60;
  const char *v61;
  uint64_t v62;
  uint64_t v64;
  _QWORD *v65;
  unint64_t v66;
  unint64_t *v67;
  unint64_t *v68;
  int v69;

  v3 = a3 & a2;
  v69 = a3 & a2;
  v4 = *(_QWORD *)(a1 + 8);
  v5 = 8 * v4;
  v6 = a1 + 16 + 8 * v4;
  if (v4 >= 1 && (unint64_t)v5 >= 0x18)
  {
    v9 = a1 + 16 + 8 * v4;
    v8 = (unint64_t *)(a1 + 16);
    do
    {
      v10 = &v8[v5 >> 4];
      v11 = *v10;
      if ((*v10 & 0x8000000000000000) != 0)
      {
        v12 = *--v10;
        v11 = v12;
      }
      if (v10 <= v8)
        break;
      if (v11 == v3)
      {
        v8 = v10;
        break;
      }
      if (v11 > v3)
        v9 = (unint64_t)v10;
      else
        v8 = v10;
      v5 = v9 - (_QWORD)v8;
    }
    while (v9 > (unint64_t)v8 && (unint64_t)v5 > 0x17);
  }
  else
  {
    v8 = (unint64_t *)(a1 + 16);
  }
  v62 = a1 + 16;
  v14 = 0;
  v15 = 0;
  v16 = a1 + 520;
  v17 = &v69;
  v18 = v8;
  v19 = 1;
  v66 = a1 + 520;
  while (2)
  {
    v20 = 0;
    v21 = 0;
    v22 = v8;
    while (1)
    {
      if ((unint64_t)v22 >= v6)
      {
        v27 = v17++;
        if (!v21)
        {
          while (1)
          {
            v20 = v3;
            v21 = 1;
            v36 = 1;
LABEL_58:
            if (v3 != *v27)
              break;
            v15 += v36;
            if (v27 >= &v69)
              goto LABEL_62;
            v37 = *v17++;
            v3 = v37;
            ++v19;
            v14 = (v14 + 1);
            v27 = v17 - 1;
            if (v21)
              goto LABEL_48;
          }
LABEL_104:
          v47 = __si_assert_copy_extra_268();
          v48 = v47;
          v49 = "";
          if (v47)
            v49 = v47;
          __message_assert("%s:%u: failed assertion '%s' %s ", "SIValueSetInternals.h", 761, "v==key", v49);
          goto LABEL_107;
        }
LABEL_48:
        if (v21 + v20 >= v3 && v3 + 1 >= v20)
        {
          v33 = v21 + v20 - 1;
          v34 = v20 > v3;
          v35 = v20 > v3;
          if (v20 >= v3)
            v20 = v3;
          if (v34)
            v21 = v33;
          if (v3 < v21 + v20)
          {
            v36 = v35;
          }
          else
          {
            v21 = v3 + 1 - v20;
            v36 = 1;
          }
          goto LABEL_58;
        }
LABEL_65:
        v32 = 1;
        v17 = v27;
        if ((unint64_t)v22 >= v6)
          goto LABEL_88;
        goto LABEL_66;
      }
      v24 = *v22;
      if (v3 < *v22)
        break;
      v32 = 1;
LABEL_68:
      if ((unint64_t)(v22 + 1) >= v6)
      {
        v39 = 1;
        v40 = 1;
        if (v21)
          goto LABEL_78;
      }
      else
      {
        v38 = v22[1];
        if (v38 < 0)
          v39 = 2;
        else
          v39 = 1;
        if (v38 < 0)
          v40 = (v38 & 0x7FFFFFFFFFFFFFFFLL) + 1;
        else
          v40 = 1;
        if (v21)
        {
LABEL_78:
          if (v21 + v20 < v24)
            goto LABEL_88;
          v41 = v40 + v24;
          if (v40 + v24 < v20)
            goto LABEL_88;
          v42 = v21 + v20 - v40;
          v43 = v20 > v24;
          if (v20 < v24)
            v24 = v20;
          if (v43)
            v44 = v42;
          else
            v44 = v21;
          v40 = v41 - v24;
          if (v41 <= v44 + v24)
            v40 = v44;
        }
      }
      v22 += v39;
      if (v3 <= v40 + v24)
        v23 = v32;
      else
        v23 = 0;
      v20 = v24;
      v21 = v40;
      if ((v23 & 1) == 0)
        goto LABEL_89;
    }
    v25 = v17 + 1;
    v26 = v14;
    while (1)
    {
      v14 = v26;
      v17 = v25;
      v27 = v25 - 1;
      if (v21)
      {
        if (v21 + v20 < v3 || v3 + 1 < v20)
          goto LABEL_65;
        v28 = v21 + v20 - 1;
        v29 = v20 > v3;
        v30 = v20 > v3;
        if (v20 >= v3)
          v20 = v3;
        if (v29)
          v21 = v28;
        if (v3 < v21 + v20)
        {
          v31 = v30;
        }
        else
        {
          v21 = v3 + 1 - v20;
          v31 = 1;
        }
      }
      else
      {
        v20 = v3;
        v21 = 1;
        v31 = 1;
      }
      if (v3 != *v27)
        goto LABEL_104;
      v15 += v31;
      if (v27 >= &v69)
        break;
      v25 = v17 + 1;
      v3 = *v17;
      ++v19;
      v26 = (v14 + 1);
      if (v24 <= v3)
      {
        v32 = 1;
        goto LABEL_63;
      }
    }
LABEL_62:
    v32 = 0;
LABEL_63:
    v14 = (v14 + 1);
    if ((unint64_t)v22 < v6)
    {
LABEL_66:
      v24 = *v22;
      goto LABEL_68;
    }
LABEL_88:
    v24 = v20;
    v40 = v21;
LABEL_89:
    v45 = v40 - 1;
    if (v40 != 1)
    {
      if (v40)
      {
        v46 = v18 + 1;
        if (v18 + 1 < v22)
        {
          v8 = v22;
          goto LABEL_22;
        }
        if (v6 + 16 > v16)
          goto LABEL_125;
        v8 = (unint64_t *)(v16 - (v6 - (_QWORD)v22));
        if ((unint64_t *)v6 != v22)
        {
          v67 = v18;
          v64 = v40 - 1;
          v65 = v18 + 1;
          memmove((void *)(v16 - (v6 - (_QWORD)v22)), v22, v6 - (_QWORD)v22);
          v45 = v64;
          v46 = v65;
          v16 = v66;
          v18 = v67;
        }
        v6 = v16;
LABEL_22:
        *v18 = v24;
        v18[1] = v45 | 0x8000000000000000;
        v18 = v46 + 1;
        if (!v32)
          goto LABEL_103;
LABEL_23:
        if ((unint64_t)v18 + v6 - (_QWORD)v8 + 16 > v16)
          goto LABEL_111;
        continue;
      }
      v8 = v22;
      if (!v32)
        goto LABEL_115;
LABEL_111:
      if ((int)v14 < v19)
        goto LABEL_116;
      v50 = __si_assert_copy_extra_268();
      v48 = v50;
      v51 = "";
      if (v50)
        v51 = v50;
      __message_assert("%s:%u: failed assertion '%s' %s ", "SIValueSetInternals.h", 810, "popped<peeked", v51);
LABEL_107:
      free(v48);
      if (__valid_fs(-1))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
    break;
  }
  if (v18 < v22)
  {
    v8 = v22;
    goto LABEL_102;
  }
  if (v6 + 16 > v16)
  {
LABEL_125:
    v59 = __si_assert_copy_extra_268();
    v60 = v59;
    if (v59)
      v61 = v59;
    else
      v61 = "";
    __message_assert("%s:%u: Unexpected code path %s ", "SIValueSetInternals.h", 626, v61);
    free(v60);
    goto LABEL_122;
  }
  v8 = (unint64_t *)(v16 - (v6 - (_QWORD)v22));
  if ((unint64_t *)v6 != v22)
  {
    v68 = v18;
    memmove((void *)(v16 - (v6 - (_QWORD)v22)), v22, v6 - (_QWORD)v22);
    v16 = v66;
    v18 = v68;
  }
  v6 = v16;
LABEL_102:
  *v18++ = v24;
  if (v32)
    goto LABEL_23;
LABEL_103:
  v22 = v8;
LABEL_115:
  v8 = v22;
  if ((_DWORD)v14 != v19)
  {
    v55 = __si_assert_copy_extra_268();
    v56 = v55;
    v57 = "";
    if (v55)
      v57 = v55;
    __message_assert("%s:%u: failed assertion '%s' %s ", "SIValueSetInternals.h", 811, "popped==peeked", v57);
    free(v56);
    if (!__valid_fs(-1))
    {
      v58 = 3072;
LABEL_124:
      *(_DWORD *)v58 = -559038737;
      abort();
    }
LABEL_122:
    v58 = 2989;
    goto LABEL_124;
  }
LABEL_116:
  v52 = v6 - (_QWORD)v8;
  if (v6 > (unint64_t)v8)
  {
    v53 = v18;
    memmove(v18, v8, v6 - (_QWORD)v8);
    v18 = (unint64_t *)((char *)v53 + v52);
  }
  *(_QWORD *)(a1 + 8) = ((uint64_t)v18 - v62) >> 3;
  return v15 != 0;
}

uint64_t SIValueSet<unsigned int>::RLEKeyHolder<unsigned long long>::AddSortedKeysWithContext(uint64_t a1, int **a2, uint64_t a3)
{
  unsigned int v5;
  unint64_t v6;
  unint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  BOOL v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t v18;
  int v20;
  unint64_t v21;
  unint64_t *v22;
  int v23;
  unint64_t v24;
  uint64_t v25;
  unint64_t *v26;
  BOOL v27;
  char v28;
  uint64_t v29;
  unint64_t v30;
  int v31;
  uint64_t v32;
  BOOL v33;
  _BOOL4 v34;
  int *v35;
  int v36;
  int v37;
  unint64_t v38;
  int v39;
  int v40;
  int64_t v41;
  uint64_t v42;
  BOOL v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  _QWORD *v48;
  unint64_t *v49;
  char *v50;
  char *v51;
  const char *v52;
  char *v53;
  char *v54;
  const char *v55;
  uint64_t v56;
  char *v57;
  const char *v58;
  unint64_t v59;
  unint64_t *v60;
  char *v61;
  const char *v62;
  char *v63;
  char *v64;
  const char *v65;
  uint64_t v66;
  uint64_t v67;
  unint64_t v68;
  unint64_t *v69;

  if (*a2 >= a2[1] || (*((_DWORD *)a2 + 5) & **a2) != *((_DWORD *)a2 + 4))
    return 0;
  v5 = SIValueSet<unsigned int>::FlatContextWithPfx::peek(a2);
  v6 = v5;
  v7 = (unint64_t *)(a1 + 16);
  v8 = *(_QWORD *)(a1 + 8);
  v9 = 8 * v8;
  v10 = a1 + 16 + 8 * v8;
  v11 = v8 >= 1 && (unint64_t)v9 >= 0x18;
  v67 = a1 + 16;
  if (v11)
  {
    v15 = a1 + 16 + 8 * v8;
    v12 = a3;
    do
    {
      v16 = &v7[v9 >> 4];
      v17 = *v16;
      if ((*v16 & 0x8000000000000000) != 0)
      {
        v18 = *--v16;
        v17 = v18;
      }
      if (v16 <= v7)
        break;
      if (v17 == v5)
      {
        v7 = v16;
        break;
      }
      if (v17 > v5)
        v15 = (unint64_t)v16;
      else
        v7 = v16;
      v9 = v15 - (_QWORD)v7;
    }
    while (v15 > (unint64_t)v7 && (unint64_t)v9 > 0x17);
  }
  else
  {
    v12 = a3;
  }
  v20 = 0;
  v13 = 0;
  v66 = a1;
  v21 = a1 + 520;
  v22 = v7;
  v23 = 1;
  v68 = v21;
  while (2)
  {
    v69 = v22;
    v24 = 0;
    v25 = 0;
    v26 = v7;
    while (1)
    {
      v29 = v25;
      v30 = v24;
      if ((unint64_t)v26 >= v10)
        break;
LABEL_40:
      v24 = *v26;
      if (v6 < *v26)
        break;
      v31 = 1;
LABEL_65:
      if ((unint64_t)(v26 + 1) >= v10)
      {
        v44 = 1;
        v25 = 1;
        if (v29)
          goto LABEL_72;
      }
      else
      {
        v41 = v26[1];
        v42 = v41 & 0x7FFFFFFFFFFFFFFFLL;
        v43 = v41 >= 0;
        v25 = 1;
        v44 = 2;
        if (v43)
          v44 = 1;
        else
          v25 = v42 + 1;
        if (v29)
        {
LABEL_72:
          if (v29 + v30 < v24)
            goto LABEL_76;
          v45 = v25 + v24;
          if (v25 + v24 < v30)
            goto LABEL_76;
          v25 = v29 + v30 - v25;
          v27 = v30 > v24;
          if (v30 < v24)
            v24 = v30;
          if (!v27)
            v25 = v29;
          if (v45 > v25 + v24)
            v25 = v45 - v24;
        }
      }
      v26 += v44;
      if (v6 <= v25 + v24)
        v28 = v31;
      else
        v28 = 0;
      if ((v28 & 1) == 0)
        goto LABEL_77;
    }
    while (2)
    {
      if (v29)
      {
        v31 = 1;
        if (v29 + v30 < v6 || v6 + 1 < v30)
          goto LABEL_63;
        v32 = v29 + v30 - 1;
        v33 = v30 > v6;
        v34 = v30 > v6;
        if (v30 >= v6)
          v30 = v6;
        if (v33)
          v29 = v32;
        if (v6 >= v29 + v30)
        {
          v29 = v6 + 1 - v30;
          goto LABEL_51;
        }
      }
      else
      {
        v29 = 1;
        v30 = v6;
LABEL_51:
        v34 = 1;
      }
      v35 = *a2 + 1;
      v36 = **a2;
      *a2 = v35;
      v37 = *((_DWORD *)a2 + 5);
      if ((v37 & v36) != *((_DWORD *)a2 + 4))
      {
        v50 = __si_assert_copy_extra_268();
        v51 = v50;
        v52 = "";
        if (v50)
          v52 = v50;
        __message_assert("%s:%u: failed assertion '%s' %s ", "SIValueSetInternals.h", 172, "(key & fMask) == fPfx", v52);
LABEL_95:
        free(v51);
        if (__valid_fs(-1))
        {
          MEMORY[0xBAD] = -559038737;
          abort();
        }
        MEMORY[0xC00] = -559038737;
        abort();
      }
      if (v6 != (v36 & ~v37))
      {
        v53 = __si_assert_copy_extra_268();
        v54 = v53;
        v55 = "";
        if (v53)
          v55 = v53;
        __message_assert("%s:%u: failed assertion '%s' %s ", "SIValueSetInternals.h", 761, "v==key", v55);
        goto LABEL_100;
      }
      if (v34)
      {
        ++v13;
      }
      else if (v12)
      {
        v38 = v10;
        SIValueSet<unsigned int>::SIValueSetInsert(*(unsigned int **)(v12 + 8), *(_DWORD *)v12 | v6);
        v10 = v38;
        v12 = a3;
        v35 = *a2;
      }
      if (v35 < a2[1])
      {
        v39 = *v35;
        v40 = *((_DWORD *)a2 + 5);
        if ((v40 & v39) == *((_DWORD *)a2 + 4))
        {
          v6 = v39 & ~v40;
          ++v23;
          ++v20;
          if ((unint64_t)v26 < v10)
            goto LABEL_40;
          continue;
        }
      }
      break;
    }
    v31 = 0;
    ++v20;
LABEL_63:
    if ((unint64_t)v26 < v10)
    {
      v24 = *v26;
      goto LABEL_65;
    }
LABEL_76:
    v24 = v30;
    v25 = v29;
LABEL_77:
    v46 = v25 - 1;
    if (v25 == 1)
    {
      v47 = v68;
      v49 = v69;
      if (v69 >= v26)
      {
        if (v10 + 16 > v68)
          goto LABEL_117;
        v7 = (unint64_t *)(v68 - (v10 - (_QWORD)v26));
        if ((unint64_t *)v10 != v26)
        {
          memmove((void *)(v68 - (v10 - (_QWORD)v26)), v26, v10 - (_QWORD)v26);
          v47 = v68;
          v49 = v69;
          v12 = a3;
        }
        v10 = v47;
      }
      else
      {
        v7 = v26;
      }
      *v49 = v24;
      v22 = v49 + 1;
      if (v31)
        goto LABEL_27;
      goto LABEL_91;
    }
    v47 = v68;
    v22 = v69;
    if (v25)
    {
      v48 = v69 + 1;
      if (v69 + 1 < v26)
      {
        v7 = v26;
        goto LABEL_26;
      }
      if (v10 + 16 <= v68)
      {
        v7 = (unint64_t *)(v68 - (v10 - (_QWORD)v26));
        if ((unint64_t *)v10 != v26)
        {
          memmove((void *)(v68 - (v10 - (_QWORD)v26)), v26, v10 - (_QWORD)v26);
          v48 = v69 + 1;
          v47 = v68;
          v22 = v69;
          v12 = a3;
        }
        v10 = v47;
LABEL_26:
        *v22 = v24;
        v22[1] = v46 | 0x8000000000000000;
        v22 = v48 + 1;
        if (v31)
        {
LABEL_27:
          if ((unint64_t)v22 + v10 - (_QWORD)v7 + 16 > v47)
            goto LABEL_106;
          continue;
        }
LABEL_91:
        v26 = v7;
LABEL_110:
        v7 = v26;
        if (v20 == v23)
          goto LABEL_111;
        v61 = __si_assert_copy_extra_268();
        v54 = v61;
        v62 = "";
        if (v61)
          v62 = v61;
        __message_assert("%s:%u: failed assertion '%s' %s ", "SIValueSetInternals.h", 811, "popped==peeked", v62);
LABEL_100:
        free(v54);
        if (__valid_fs(-1))
LABEL_101:
          v56 = 2989;
        else
          v56 = 3072;
        *(_DWORD *)v56 = -559038737;
        abort();
      }
LABEL_117:
      v63 = __si_assert_copy_extra_268();
      v64 = v63;
      if (v63)
        v65 = v63;
      else
        v65 = "";
      __message_assert("%s:%u: Unexpected code path %s ", "SIValueSetInternals.h", 626, v65);
      free(v64);
      goto LABEL_101;
    }
    break;
  }
  v7 = v26;
  if (!v31)
    goto LABEL_110;
LABEL_106:
  if (v20 >= v23)
  {
    v57 = __si_assert_copy_extra_268();
    v51 = v57;
    v58 = "";
    if (v57)
      v58 = v57;
    __message_assert("%s:%u: failed assertion '%s' %s ", "SIValueSetInternals.h", 810, "popped<peeked", v58);
    goto LABEL_95;
  }
LABEL_111:
  v59 = v10 - (_QWORD)v7;
  v60 = v22;
  if (v10 > (unint64_t)v7)
  {
    memmove(v22, v7, v10 - (_QWORD)v7);
    v60 = (unint64_t *)((char *)v60 + v59);
  }
  *(_QWORD *)(v66 + 8) = ((uint64_t)v60 - v67) >> 3;
  return v13;
}

uint64_t SIValueSet<unsigned int>::RLEKeyHolder<unsigned long long>::ContainsKey(uint64_t a1, unsigned int a2, int a3)
{
  unint64_t v3;
  unsigned int *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v9;
  unsigned int *v10;
  unint64_t v11;
  unint64_t v12;
  unsigned int v14;

  v3 = a3 & a2;
  v4 = (unsigned int *)(a1 + 16);
  v5 = *(_QWORD *)(a1 + 8);
  v6 = 8 * v5;
  v7 = a1 + 16 + 8 * v5;
  if (v5 >= 1 && (unint64_t)v6 >= 0x18)
  {
    v9 = a1 + 16 + 8 * v5;
    do
    {
      v10 = &v4[2 * (v6 >> 4)];
      v11 = *(_QWORD *)v10;
      if ((*(_QWORD *)v10 & 0x8000000000000000) != 0)
      {
        v12 = *((_QWORD *)v10 - 1);
        v10 -= 2;
        v11 = v12;
      }
      if (v10 <= v4)
        break;
      if (v11 == v3)
      {
        v4 = v10;
        goto LABEL_20;
      }
      if (v11 > v3)
        v9 = (unint64_t)v10;
      else
        v4 = v10;
      v6 = v9 - (_QWORD)v4;
    }
    while (v9 > (unint64_t)v4 && (unint64_t)v6 > 0x17);
  }
  while (1)
  {
LABEL_20:
    if ((unint64_t)v4 >= v7)
      return 0;
    v14 = *v4;
    if ((_DWORD)v3 == *v4)
      break;
    v4 += 2;
    if (v3 < v14)
      return 0;
  }
  return 1;
}

unint64_t SIValueSet<unsigned int>::RLEKeyHolder<unsigned long long>::CloseKey(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t v3;
  unint64_t result;
  unsigned int *v6;
  unint64_t v7;
  uint64_t v9;
  unint64_t v10;
  unsigned int *v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v15;

  v3 = *(_QWORD *)(a1 + 8);
  if (!v3)
    return 0;
  result = a3 & a2;
  v6 = (unsigned int *)(a1 + 16);
  v7 = 8 * v3;
  if (v3 >= 1 && v7 >= 0x18)
  {
    v9 = 8 * v3;
    v10 = a1 + 16 + 8 * v3;
    do
    {
      v11 = &v6[2 * (v9 >> 4)];
      v12 = *(_QWORD *)v11;
      if ((*(_QWORD *)v11 & 0x8000000000000000) != 0)
      {
        v13 = *((_QWORD *)v11 - 1);
        v11 -= 2;
        v12 = v13;
      }
      if (v11 <= v6)
        break;
      if (v12 == result)
      {
        v6 = v11;
        break;
      }
      if (v12 > result)
        v10 = (unint64_t)v11;
      else
        v6 = v11;
      v9 = v10 - (_QWORD)v6;
    }
    while (v10 > (unint64_t)v6 && (unint64_t)v9 > 0x17);
  }
  while ((unint64_t)v6 < a1 + 16 + 8 * v3)
  {
    v15 = *v6;
    if ((_DWORD)result == (_DWORD)v15)
      return result;
    v6 += 2;
    if (result < v15)
      return v15;
  }
  result = *(_QWORD *)(a1 + 8 * v3 + 8);
  if ((result & 0x8000000000000000) != 0)
    return (*(_DWORD *)(v7 + a1) + result);
  return result;
}

uint64_t SIValueSet<unsigned int>::RLEKeyHolder<unsigned long long>::RemoveKey(uint64_t a1, unsigned int a2, int a3)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t *v10;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  size_t v19;
  unint64_t *v20;
  unint64_t v21;
  uint64_t result;
  unint64_t v23;
  unint64_t v24;
  uint64_t v26;
  unint64_t *v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  void *v33;
  unint64_t v34;
  uint64_t v35;
  unint64_t v36;
  char *v37;
  char *v38;
  const char *v39;

  v4 = a3 & a2;
  v5 = a1 + 16;
  v6 = *(_QWORD *)(a1 + 8);
  v7 = 8 * v6;
  v8 = a1 + 16 + 8 * v6;
  if (v6 >= 1 && (unint64_t)v7 >= 0x18)
  {
    v11 = a1 + 16 + 8 * v6;
    v10 = (unint64_t *)(a1 + 16);
    do
    {
      v12 = &v10[v7 >> 4];
      v13 = *v12;
      if ((*v12 & 0x8000000000000000) != 0)
      {
        v14 = *--v12;
        v13 = v14;
      }
      if (v12 <= v10)
        break;
      if (v13 == v4)
      {
        v10 = v12;
        if ((unint64_t)v12 >= v8)
          return 0;
        goto LABEL_20;
      }
      if (v13 > v4)
        v11 = (unint64_t)v12;
      else
        v10 = v12;
      v7 = v11 - (_QWORD)v10;
    }
    while (v11 > (unint64_t)v10 && (unint64_t)v7 > 0x17);
    if ((unint64_t)v10 >= v8)
      return 0;
  }
  else
  {
    v10 = (unint64_t *)(a1 + 16);
    if (v5 >= v8)
      return 0;
  }
LABEL_20:
  v17 = v10 + 1;
  v16 = *v10;
  if (*v10 == v4)
  {
    if ((unint64_t)v17 < v8)
    {
LABEL_22:
      v18 = *v17;
      if ((*v17 & 0x8000000000000000) == 0)
      {
        v19 = v8 - (_QWORD)v17;
        v20 = v17;
LABEL_41:
        memmove(v10, v20, v19);
        v26 = *(_QWORD *)(a1 + 8) - 1;
        goto LABEL_42;
      }
      *v10 = v4 + 1;
      if ((v18 & 0x7FFFFFFFFFFFFFFFLL) == 1)
      {
        v20 = v10 + 2;
        v19 = v8 - (_QWORD)(v10 + 2);
        v10 = v17;
        goto LABEL_41;
      }
      v28 = (v18 - 1) | 0x8000000000000000;
LABEL_50:
      *v17 = v28;
      return 1;
    }
LABEL_38:
    *(_QWORD *)(a1 + 8) = v6 - 1;
    return 1;
  }
  while (1)
  {
    if ((v16 & 0x8000000000000000) == 0)
    {
      result = 0;
      if (v16 > v4 || (unint64_t)v17 >= v8)
        return result;
      goto LABEL_24;
    }
    v23 = *(v17 - 2);
    v24 = v23 + (v16 & 0x7FFFFFFFFFFFFFFFLL);
    if (v23 < v4 && v24 >= v4)
      break;
    if ((unint64_t)v17 >= v8)
      return 0;
LABEL_24:
    v21 = *v17++;
    v16 = v21;
    if (v21 == v4)
    {
      v10 = v17 - 1;
      if ((unint64_t)v17 < v8)
        goto LABEL_22;
      goto LABEL_38;
    }
  }
  v27 = v17 - 1;
  if ((v16 & 0x7FFFFFFFFFFFFFFFLL) != 1)
  {
    if (v24 == v4)
    {
      *v27 = (v16 - 1) | 0x8000000000000000;
      return 1;
    }
    if (v23 + 1 == v4)
    {
      *v27 = v4 + 1;
      v29 = v24 + ~v4;
      if (!v29)
        return 1;
      v30 = *(_QWORD *)(a1 + 8);
      if (v30 < 0x3F)
      {
        v31 = (uint64_t)((uint64_t)v17 - v5) >> 3;
        if (v30 != v31)
        {
          v32 = v30 - v31;
          v33 = v17 + 1;
LABEL_65:
          memmove(v33, v17, 8 * v32);
          v31 = *(_QWORD *)(a1 + 8);
          goto LABEL_66;
        }
        goto LABEL_66;
      }
    }
    else
    {
      *(v17 - 1) = ((v4 - 1) - v23) | 0x8000000000000000;
      v34 = *(_QWORD *)(a1 + 8);
      if (v34 < 0x3F)
      {
        v35 = (uint64_t)((uint64_t)v17 - v5) >> 3;
        if (v34 != v35)
        {
          memmove(v17 + 1, v17, 8 * (v34 - v35));
          v35 = *(_QWORD *)(a1 + 8);
        }
        *(_QWORD *)(a1 + 8) = v35 + 1;
        *v17 = (v4 + 1);
        v29 = v24 + ~v4;
        if (!v29)
          return 1;
        v36 = *(_QWORD *)(a1 + 8);
        if (v36 < 0x3F)
        {
          ++v17;
          v31 = (uint64_t)((uint64_t)v27 - v5 + 16) >> 3;
          if (v36 != v31)
          {
            v32 = v36 - v31;
            v33 = v27 + 3;
            goto LABEL_65;
          }
LABEL_66:
          *(_QWORD *)(a1 + 8) = v31 + 1;
          v28 = v29 | 0x8000000000000000;
          goto LABEL_50;
        }
      }
    }
    v37 = __si_assert_copy_extra_268();
    v38 = v37;
    if (v37)
      v39 = v37;
    else
      v39 = "";
    __message_assert("%s:%u: Unexpected code path %s ", "SIValueSetInternals.h", 649, v39);
    free(v38);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  if ((unint64_t)v17 < v8)
  {
    memmove(v17 - 1, v17, v8 - (_QWORD)v17);
    v6 = *(_QWORD *)(a1 + 8);
  }
  v26 = v6 - 1;
LABEL_42:
  *(_QWORD *)(a1 + 8) = v26;
  return 1;
}

void SIValueSet<unsigned int>::RLEKeyHolder<unsigned long long>::Apply(uint64_t a1, uint64_t a2, int a3, void (*a4)(char *, uint64_t, uint64_t), uint64_t a5)
{
  uint64_t v9;
  size_t v10;
  char *v11;
  unint64_t v12;
  uint64_t *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  _QWORD v19[2];

  v19[1] = *MEMORY[0x1E0C80C00];
  v9 = MEMORY[0x1E0C80A78](a1);
  v11 = (char *)v19 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = *(_QWORD *)(v9 + 8);
  if (v12 > 0x3F)
    return;
  v13 = (uint64_t *)(v9 + 16);
  v14 = v9 + 16 + 8 * v12;
  bzero((char *)v19 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0), v10);
  LODWORD(v15) = 0;
  v16 = 0;
LABEL_3:
  v17 = 0;
  while (v16)
  {
    --v16;
    LODWORD(v15) = v15 + 1;
LABEL_15:
    *(_DWORD *)&v11[4 * v17++] = v15 | a3;
    if (v17 == a2)
    {
      a4(v11, a2, a5);
      goto LABEL_3;
    }
  }
  if ((unint64_t)v13 < v14)
  {
    v18 = v13 + 1;
    v15 = *v13;
    if ((unint64_t)(v13 + 1) >= v14)
    {
      v16 = 0;
      ++v13;
    }
    else
    {
      if (*v18 < 0)
        v13 += 2;
      else
        ++v13;
      if (*v18 < 0)
        v16 = *v18 & 0x7FFFFFFFFFFFFFFFLL;
      else
        v16 = 0;
    }
    goto LABEL_15;
  }
  if (v17)
    a4(v11, v17, a5);
}

BOOL SIValueSet<unsigned int>::RLEKeyHolder<unsigned long long>::IsEmpty(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8) == 0;
}

uint64_t SIValueSet<unsigned int>::RLEKeyHolder<unsigned long long>::GetRawCount(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t SIValueSet<unsigned int>::RLEKeyHolder<unsigned long long>::Serialize(uint64_t a1, uint64_t a2)
{
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 8))(a2, 8);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 8))(a2, *(unsigned int *)(a1 + 8));
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 16))(a2, a1 + 16, 8 * *(_QWORD *)(a1 + 8));
}

void SIValueSet<unsigned int>::RLEKeyHolder<unsigned long long>::~RLEKeyHolder()
{
  JUMPOUT(0x1BCCB06A4);
}

uint64_t SIValueSet<unsigned int>::RLEKeyHolder<unsigned long long>::valueIterator(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  *(_QWORD *)a3 = off_1E6E2A538;
  *(_QWORD *)(a3 + 8) = a1 + 16;
  *(_QWORD *)(a3 + 16) = a1 + 16 + 8 * v3;
  *(_QWORD *)(a3 + 24) = 0;
  *(_QWORD *)(a3 + 32) = 0;
  *(_DWORD *)(a3 + 40) = a2;
  return a3;
}

uint64_t SIValueSet<unsigned int>::RLEKeyHolder<unsigned long long>::RLEKeyIterator::nextKey(uint64_t a1)
{
  int v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t *v6;
  unint64_t v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;

  v1 = *(_DWORD *)(a1 + 40);
  v2 = *(_QWORD *)(a1 + 32);
  if (v2)
  {
    v3 = v2 - 1;
    v4 = *(_QWORD *)(a1 + 24) + 1;
    *(_QWORD *)(a1 + 24) = v4;
    *(_QWORD *)(a1 + 32) = v3;
    return v1 | v4;
  }
  else
  {
    v6 = *(uint64_t **)(a1 + 8);
    v7 = *(_QWORD *)(a1 + 16);
    v9 = *v6;
    v8 = *v6;
    *(_QWORD *)(a1 + 8) = v6 + 1;
    *(_QWORD *)(a1 + 24) = v9;
    if ((unint64_t)(v6 + 1) < v7 && (v10 = v6[1], v10 < 0))
    {
      *(_QWORD *)(a1 + 8) = v6 + 2;
      *(_QWORD *)(a1 + 32) = v10 & 0x7FFFFFFFFFFFFFFFLL;
      return v1 | v8;
    }
    else
    {
      return v1 | v8;
    }
  }
}

BOOL SIValueSet<unsigned int>::RLEKeyHolder<unsigned long long>::RLEKeyIterator::hasMore(_QWORD *a1)
{
  return a1[4] || a1[1] < a1[2];
}

void SIValueSet<unsigned int>::RLEKeyHolder<unsigned long long>::RLEKeyIterator::~RLEKeyIterator()
{
  JUMPOUT(0x1BCCB06A4);
}

uint64_t SIUINT64SetCreate()
{
  if (!__kSIUINT64SetTypeID)
    __kSIUINT64SetTypeID = _CFRuntimeRegisterClass();
  return _CFRuntimeCreateInstance();
}

double __SIUINT64SetInit(char *a1)
{
  const __CFAllocator *v2;
  void *v3;
  double result;

  v2 = CFGetAllocator(a1);
  *((_QWORD *)a1 + 2) = 0;
  *((_DWORD *)a1 + 6) = 0;
  *((_QWORD *)a1 + 5) = 0;
  *((_QWORD *)a1 + 6) = v2;
  v3 = CFAllocatorAllocate(v2, 8072, 0);
  bzero(v3, 0x1F88uLL);
  *((_QWORD *)a1 + 4) = v3;
  result = 0.0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  a1[184] = 1;
  return result;
}

void __SIUINT64SetFinalize(const void *a1)
{
  void **v2;

  SIValueSet<unsigned int>::_SIValueSetInnerDealloc((_QWORD *)a1 + 7, *((const __CFAllocator **)a1 + 6));
  v2 = (void **)*((_QWORD *)a1 + 4);
  if (v2)
  {
    SIValueSet<unsigned int>::CombLevel_s::malloc_chain_s::chain_s::clear(v2, *((const __CFAllocator **)a1 + 6), *((_QWORD *)a1 + 5));
    CFAllocatorDeallocate(*((CFAllocatorRef *)a1 + 6), *((void **)a1 + 4));
    *((_QWORD *)a1 + 4) = 0;
  }
}

uint64_t SIUINT64SetGetTypeID()
{
  uint64_t result;

  result = __kSIUINT64SetTypeID;
  if (!__kSIUINT64SetTypeID)
  {
    result = _CFRuntimeRegisterClass();
    __kSIUINT64SetTypeID = result;
  }
  return result;
}

uint64_t SIUINT64SetContainsValue(uint64_t a1, unint64_t a2)
{
  int v3;
  uint64_t v4;
  int v5;

  if (*(_BYTE *)(a1 + 184))
    return 0;
  v3 = *(_DWORD *)(a1 + 24);
  if (v3)
  {
    if ((*(_QWORD *)(a1 + 16) ^ a2) >> (-4 * v3))
      return 0;
  }
  v4 = *(_QWORD *)(a1 + 8 * ((a2 >> ((60 - 4 * v3) & 0xFC)) & 0xF) + 56);
  if ((v4 & 1) != 0)
  {
    v5 = v3 + 2;
    do
      v4 = *(_QWORD *)((v4 & 0xFFFFFFFFFFFFFFFELL) + 8 * ((a2 >> ((64 - 4 * v5++) & 0xFC)) & 0xF));
    while ((v4 & 1) != 0);
  }
  if (!v4)
    return 0;
  else
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 16))(v4);
}

uint64_t SIUINT64SetAddValue(uint64_t a1, unint64_t a2)
{
  return SIValueSet<unsigned long long>::SIValueSetInsert((unint64_t *)(a1 + 16), a2);
}

uint64_t SIValueSet<unsigned long long>::_SIValueSetBurstRLE(_QWORD *a1, int a2, uint64_t a3)
{
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  unint64_t v9;
  uint64_t v10;
  int v11;
  unint64_t v12;
  uint64_t *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t i;
  uint64_t v20;
  unsigned int *v21;
  unint64_t v22;
  unsigned int v23;
  int v24;
  uint64_t v25;
  int v26;
  uint64_t j;
  unint64_t *v28;
  unint64_t v29;
  unint64_t v30;
  unsigned __int16 *v31;
  unint64_t v32;
  unsigned __int16 v33;
  __int16 v34;
  uint64_t v35;
  int v36;
  uint64_t k;
  unint64_t *v38;
  unint64_t v39;
  unint64_t *v40;
  unint64_t v41;
  uint64_t v43;
  uint64_t *v44;
  _QWORD v45[128];
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD *)(a3 + 8);
  if (v6 == 63 || (v7 = *(_QWORD **)a3) == 0)
  {
    v7 = CFAllocatorAllocate(*(CFAllocatorRef *)(a3 + 16), 8072, 0);
    *v7 = *(_QWORD *)a3;
    bzero(v7 + 1, 0x1F80uLL);
    v6 = 0;
    *(_QWORD *)a3 = v7;
  }
  *(_QWORD *)(a3 + 8) = v6 + 1;
  v8 = &v7[16 * v6];
  *(_OWORD *)(v8 + 1) = 0u;
  v9 = (unint64_t)(v8 + 1);
  *(_OWORD *)(v9 + 96) = 0u;
  *(_OWORD *)(v9 + 112) = 0u;
  *(_OWORD *)(v9 + 64) = 0u;
  *(_OWORD *)(v9 + 80) = 0u;
  *(_OWORD *)(v9 + 32) = 0u;
  *(_OWORD *)(v9 + 48) = 0u;
  v10 = (a2 + 1);
  v11 = 64 - 4 * v10;
  *(_OWORD *)(v9 + 16) = 0u;
  if (v11 >= 32)
  {
    v12 = a1[1];
    if (v12 > 0x3F)
      goto LABEL_71;
    v44 = &v43;
    v13 = a1 + 2;
    v14 = (unint64_t)&a1[v12 + 2];
    bzero(v45, 0x400uLL);
    v15 = 0;
    v16 = 0;
LABEL_7:
    v17 = 0;
    while (1)
    {
      if (v16)
      {
        --v16;
        ++v15;
      }
      else
      {
        if ((unint64_t)v13 >= v14)
        {
          if (v17)
          {
            v28 = v45;
            do
            {
              v29 = *v28++;
              SIValueSet<unsigned long long>::_SIValueSetInnerInsert(v9, v29, v10, a3);
              --v17;
            }
            while (v17);
          }
          goto LABEL_71;
        }
        v18 = v13 + 1;
        v15 = *v13;
        if ((unint64_t)(v13 + 1) >= v14)
        {
          v16 = 0;
          ++v13;
        }
        else
        {
          if (*v18 < 0)
            v13 += 2;
          else
            ++v13;
          if (*v18 < 0)
            v16 = *v18 & 0x7FFFFFFFFFFFFFFFLL;
          else
            v16 = 0;
        }
      }
      v45[v17++] = v15;
      if (v17 == 128)
      {
        for (i = 0; i != 128; ++i)
          SIValueSet<unsigned long long>::_SIValueSetInnerInsert(v9, v45[i], v10, a3);
        goto LABEL_7;
      }
    }
  }
  if (v11 >= 16)
  {
    v20 = *((unsigned int *)a1 + 2);
    if (v20 > 0x3F)
      goto LABEL_71;
    v44 = &v43;
    v21 = (unsigned int *)a1 + 3;
    v22 = (unint64_t)a1 + 4 * v20 + 12;
    bzero(v45, 0x400uLL);
    v23 = 0;
    v24 = 0;
LABEL_26:
    v25 = 0;
    while (1)
    {
      if (v24)
      {
        --v24;
        ++v23;
      }
      else
      {
        if ((unint64_t)v21 >= v22)
        {
          if (v25)
          {
            v38 = v45;
            do
            {
              v39 = *v38++;
              SIValueSet<unsigned long long>::_SIValueSetInnerInsert(v9, v39, v10, a3);
              --v25;
            }
            while (v25);
          }
          goto LABEL_71;
        }
        v23 = *v21;
        if ((unint64_t)(v21 + 1) >= v22)
        {
          v24 = 0;
          ++v21;
        }
        else
        {
          v26 = v21[1];
          if (v26 < 0)
            v21 += 2;
          else
            ++v21;
          if (v26 < 0)
            v24 = v26 & 0x7FFFFFFF;
          else
            v24 = 0;
        }
      }
      v45[v25++] = v23;
      if (v25 == 128)
      {
        for (j = 0; j != 128; ++j)
          SIValueSet<unsigned long long>::_SIValueSetInnerInsert(v9, v45[j], v10, a3);
        goto LABEL_26;
      }
    }
  }
  v30 = *((unsigned __int16 *)a1 + 4);
  if (v30 > 0x3F)
    goto LABEL_71;
  v44 = &v43;
  v31 = (unsigned __int16 *)a1 + 5;
  v32 = (unint64_t)a1 + 2 * v30 + 10;
  bzero(v45, 0x400uLL);
  v33 = 0;
  v34 = 0;
LABEL_48:
  v35 = 0;
  while (v34)
  {
    --v34;
    ++v33;
LABEL_60:
    v45[v35++] = v33;
    if (v35 == 128)
    {
      for (k = 0; k != 128; ++k)
        SIValueSet<unsigned long long>::_SIValueSetInnerInsert(v9, v45[k], v10, a3);
      goto LABEL_48;
    }
  }
  if ((unint64_t)v31 < v32)
  {
    v33 = *v31;
    if ((unint64_t)(v31 + 1) >= v32)
    {
      v34 = 0;
      ++v31;
    }
    else
    {
      v36 = (__int16)v31[1];
      if (v36 < 0)
        v34 = v36 & 0x7FFF;
      else
        v34 = 0;
      if (v36 < 0)
        v31 += 2;
      else
        ++v31;
    }
    goto LABEL_60;
  }
  if (v35)
  {
    v40 = v45;
    do
    {
      v41 = *v40++;
      SIValueSet<unsigned long long>::_SIValueSetInnerInsert(v9, v41, v10, a3);
      --v35;
    }
    while (v35);
  }
LABEL_71:
  (*(void (**)(_QWORD *))(*a1 + 72))(a1);
  CFAllocatorDeallocate(*(CFAllocatorRef *)(a3 + 16), a1);
  return v9 | 1;
}

BOOL SIValueSet<unsigned long long>::BitmapHolder::AddKey(uint64_t a1, int a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v3 = 1 << (a3 & a2);
  v4 = a1 + ((uint64_t)((unint64_t)((a3 & a2) << 16 >> 22) << 48) >> 45);
  v7 = *(_QWORD *)(v4 + 8);
  v5 = (uint64_t *)(v4 + 8);
  v6 = v7;
  v8 = v7 & v3;
  if ((v7 & v3) == 0)
    *v5 = v6 | v3;
  return v8 == 0;
}

uint64_t SIValueSet<unsigned long long>::BitmapHolder::CloseKey(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4;
  int v5;
  unsigned int v6;

  if (((*(_QWORD *)(a1 + 8 * ((int)((a3 & a2) << 16) >> 22) + 8) >> (a3 & a2)) & 1) != 0)
    return a2;
  v4 = a2;
  LOWORD(v5) = a3 & a2;
  while (1)
  {
    v5 = (__int16)(v5 + 1);
    if (v5 >= 64)
      break;
    ++v4;
    if (((*(_QWORD *)(a1 + 8 * (v5 >> 6) + 8) >> v5) & 1) != 0)
      return v4;
  }
  v6 = (unsigned __int16)(a3 & a2);
  v4 = a2;
  while ((__int16)v6 >= 1)
  {
    --v6;
    --v4;
    if (((*(_QWORD *)(a1 + 8 * (v6 >> 6) + 8) >> v6) & 1) != 0)
      return v4;
  }
  return 0;
}

BOOL SIValueSet<unsigned long long>::BitmapHolder::RemoveKey(uint64_t a1, int a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v3 = 1 << (a3 & a2);
  v4 = a1 + 8 * ((a3 & a2) << 16 >> 22);
  v7 = *(_QWORD *)(v4 + 8);
  v5 = (uint64_t *)(v4 + 8);
  v6 = v7;
  v8 = v7 & v3;
  if ((v7 & v3) != 0)
    *v5 = v6 ^ v3;
  return v8 != 0;
}

void SIValueSet<unsigned long long>::BitmapHolder::Apply(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(char *, uint64_t, uint64_t), uint64_t a5)
{
  size_t v10;
  char *v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  __int16 v17;
  int v18;
  uint64_t v19;
  char v20;
  _QWORD v21[2];

  v21[1] = *MEMORY[0x1E0C80C00];
  MEMORY[0x1E0C80A78](a1);
  v11 = (char *)v21 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v11, v10);
  v12 = 0;
  v13 = 0;
  v14 = a1 + 8;
  do
  {
    while (1)
    {
      v15 = *(_QWORD *)(v14 + 8 * ((__int16)v13 >> 6));
      if (v15)
        break;
LABEL_2:
      v13 = (__int16)(v13 + 64);
      if (v13 >= 4096)
        goto LABEL_16;
    }
    v16 = v13 & 0x3F;
    v17 = v13 & 0xFFC0;
    while (((v15 >> v16) & 1) == 0)
    {
      ++v13;
      if (++v16 == 64)
      {
        LOWORD(v13) = v17;
        goto LABEL_2;
      }
    }
    if ((__int16)v13 > 4095)
    {
LABEL_11:
      v19 = 0;
    }
    else
    {
      while (!*(_QWORD *)(v14 + 8 * ((__int16)v13 >> 6)))
      {
        v18 = (__int16)v13;
        v13 += 64;
        if (v18 >= 4032)
          goto LABEL_11;
      }
      LOWORD(v19) = v13++;
      v19 = (__int16)v19;
    }
    *(_QWORD *)&v11[8 * v12++] = v19 | a3;
    if (v12 == a2)
    {
      v20 = a4(v11, a2, a5);
      v12 = 0;
      if ((v20 & 1) != 0)
        break;
    }
  }
  while ((__int16)v13 < 4096);
LABEL_16:
  if (v12)
    a4(v11, v12, a5);
}

uint64_t SIValueSet<unsigned long long>::BitmapHolder::IsEmpty(uint64_t a1)
{
  int v1;
  unint64_t v2;
  uint64_t v3;

  LOWORD(v1) = 0;
  while (1)
  {
    v2 = *(_QWORD *)(a1 + 8 + 8 * ((__int16)v1 >> 6));
    if (v2)
      break;
LABEL_2:
    v1 = (__int16)(v1 + 64);
    if (v1 >= 4096)
      return 1;
  }
  v3 = v1 & 0x3F;
  LOWORD(v1) = v1 & 0xFFC0;
  while (((v2 >> v3) & 1) == 0)
  {
    if (++v3 == 64)
      goto LABEL_2;
  }
  return 0;
}

uint64_t SIValueSet<unsigned long long>::BitmapHolder::GetRawCount()
{
  return 61;
}

uint64_t SIValueSet<unsigned long long>::BitmapHolder::Serialize(uint64_t a1, uint64_t a2)
{
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 8))(a2, 0);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 16))(a2, a1 + 8, 512);
}

void SIValueSet<unsigned long long>::BitmapHolder::~BitmapHolder()
{
  JUMPOUT(0x1BCCB06A4);
}

uint64_t SIValueSet<unsigned long long>::BitmapHolder::valueIterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)a3 = off_1E6E2A5D8;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = a1 + 8;
  *(_WORD *)(a3 + 24) = 0;
  *(_QWORD *)(a3 + 32) = a2;
  return a3;
}

uint64_t SIValueSet<unsigned long long>::BitmapHolder::BitmapIterator::nextKey(uint64_t a1)
{
  uint64_t v1;
  int v2;
  uint64_t v3;
  int v4;
  uint64_t v6;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(__int16 *)(a1 + 24);
  if (v2 > 4095)
    return v1;
  v3 = *(_QWORD *)(a1 + 16);
  while (!*(_QWORD *)(v3 + 8 * ((__int16)v2 >> 6)))
  {
    v4 = (__int16)v2;
    LOWORD(v2) = v2 + 64;
    *(_WORD *)(a1 + 24) = v2;
    if (v4 >= 4032)
      return v1;
  }
  v6 = *(_QWORD *)(a1 + 8);
  *(_WORD *)(a1 + 24) = v2 + 1;
  return v6 | (__int16)v2 | v1;
}

uint64_t SIValueSet<unsigned long long>::BitmapHolder::BitmapIterator::hasMore(uint64_t a1)
{
  int v1;
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;

  v1 = *(__int16 *)(a1 + 24);
  if (v1 > 4095)
    return 0;
  v2 = *(_QWORD *)(a1 + 16);
  while (1)
  {
    v3 = *(_QWORD *)(v2 + 8 * ((__int16)v1 >> 6));
    if (v3)
      break;
    v1 += 64;
    *(_WORD *)(a1 + 24) = v1;
LABEL_9:
    if ((__int16)v1 >= 4096)
      return 0;
  }
  v4 = v1 & 0x3F;
  while (((v3 >> v4) & 1) == 0)
  {
    *(_WORD *)(a1 + 24) = ++v1;
    if (++v4 == 64)
      goto LABEL_9;
  }
  return 1;
}

void SIValueSet<unsigned long long>::BitmapHolder::BitmapIterator::~BitmapIterator()
{
  JUMPOUT(0x1BCCB06A4);
}

BOOL SIValueSet<unsigned long long>::RLEKeyHolder<unsigned short>::AddKey(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v3;
  unint64_t v4;
  unint64_t v5;
  __int16 *v6;
  uint64_t v7;
  unint64_t v8;
  __int16 *v9;
  int v10;
  __int16 v11;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unsigned __int16 *v16;
  __int16 *v17;
  int v18;
  unsigned __int16 v19;
  uint64_t v20;
  __int16 *v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v26;
  BOOL v27;
  unsigned int v28;
  unint64_t v29;
  char v30;
  unsigned __int16 *v31;
  uint64_t v32;
  unsigned __int16 *v33;
  unint64_t v34;
  unsigned int v35;
  uint64_t v36;
  unint64_t v37;
  int v38;
  unsigned int v39;
  int v40;
  unsigned __int16 *v41;
  unint64_t v42;
  unsigned int v43;
  uint64_t v44;
  unint64_t v45;
  int v46;
  unsigned int v47;
  unsigned __int16 v48;
  int v49;
  BOOL v50;
  _WORD *v51;
  unint64_t v52;
  char *v53;
  char *v54;
  const char *v55;
  char *v56;
  const char *v57;
  int v58;
  int v59;
  char *v61;
  char *v62;
  const char *v63;
  uint64_t v64;
  char *v65;
  char *v66;
  const char *v67;
  int v68;
  _WORD *v70;
  unint64_t v71;
  void *v72;
  void *v73;
  __int16 *v74;
  __int16 *v75;
  uint64_t v76;

  LOWORD(v3) = a3 & a2;
  v76 = a3 & a2;
  v4 = *(unsigned __int16 *)(a1 + 8);
  v5 = a1 + 10 + 2 * v4;
  v6 = (__int16 *)(a1 + 10);
  if (v4 >= 3)
  {
    v7 = 2 * v4;
    v8 = a1 + 10 + 2 * v4;
    v6 = (__int16 *)(a1 + 10);
    do
    {
      v9 = &v6[v7 >> 2];
      v10 = *v9;
      if (v10 < 0)
      {
        v11 = *--v9;
        LOWORD(v10) = v11;
      }
      if (v9 <= v6)
        break;
      if ((unsigned __int16)v10 == (unsigned __int16)v3)
      {
        v6 = v9;
        break;
      }
      if ((unsigned __int16)v10 > (unsigned __int16)v3)
        v8 = (unint64_t)v9;
      else
        v6 = v9;
      v7 = v8 - (_QWORD)v6;
    }
    while (v8 > (unint64_t)v6 && (unint64_t)v7 > 5);
  }
  v68 = a1 + 10;
  v13 = 0;
  v14 = 0;
  v15 = a1 + 136;
  v16 = (unsigned __int16 *)&v76;
  v17 = v6;
  v18 = 1;
  while (2)
  {
    v19 = 0;
    v20 = 0;
    v21 = v6;
    while (2)
    {
      if ((unint64_t)v21 >= v5)
      {
        v16 += 4;
        v41 = v16 - 4;
        if (!v20)
          goto LABEL_73;
LABEL_61:
        v42 = v20 + v19;
        if (v42 < (unsigned __int16)v3 || (unint64_t)(unsigned __int16)v3 + 1 < v19)
        {
          v40 = 1;
          v16 = v41;
          goto LABEL_81;
        }
        v43 = v19;
        v44 = v20 + v19 - 1;
        v45 = v44 + (unsigned __int16)v3;
        if (v19 > (unsigned __int16)v3)
          v19 = v3;
        if (v43 <= (unsigned __int16)v3)
        {
          v46 = 0;
        }
        else
        {
          v20 = v44;
          v46 = 1;
        }
        if (v43 > (unsigned __int16)v3)
          v42 = v45;
        if (v42 > (unsigned __int16)v3)
        {
          v47 = v46;
        }
        else
        {
          v20 = v20 + (unsigned __int16)v3 + 1 - v42;
          v47 = 1;
        }
        while (*v41 == (unsigned __int16)v3)
        {
          v14 += v47;
          if (v41 >= (unsigned __int16 *)&v76)
          {
            v40 = 0;
            v13 = (v13 + 1);
            goto LABEL_81;
          }
          v48 = *v16;
          v16 += 4;
          LOWORD(v3) = v48;
          ++v18;
          v13 = (v13 + 1);
          v41 = v16 - 4;
          if (v20)
            goto LABEL_61;
LABEL_73:
          v20 = 1;
          v19 = v3;
          v47 = 1;
        }
LABEL_110:
        v53 = __si_assert_copy_extra_268();
        v54 = v53;
        v55 = "";
        if (v53)
          v55 = v53;
        __message_assert("%s:%u: failed assertion '%s' %s ", "SIValueSetInternals.h", 761, "v==key", v55);
LABEL_113:
        free(v54);
        if (__valid_fs(-1))
        {
          MEMORY[0xBAD] = -559038737;
          abort();
        }
        MEMORY[0xC00] = -559038737;
        abort();
      }
      v28 = (unsigned __int16)*v21;
      if (v28 <= (unsigned __int16)v3)
      {
        v40 = 1;
        goto LABEL_83;
      }
      v31 = v16 + 4;
      v32 = v13;
      while (1)
      {
        v13 = v32;
        v16 = v31;
        v33 = v31 - 4;
        if (!v20)
        {
          v20 = 1;
          v19 = v3;
          v39 = 1;
          goto LABEL_56;
        }
        v34 = v20 + v19;
        if (v34 < (unsigned __int16)v3 || (unint64_t)(unsigned __int16)v3 + 1 < v19)
          break;
        v35 = v19;
        v36 = v20 + v19 - 1;
        v37 = v36 + (unsigned __int16)v3;
        if (v19 > (unsigned __int16)v3)
          v19 = v3;
        if (v35 <= (unsigned __int16)v3)
        {
          v38 = 0;
        }
        else
        {
          v20 = v36;
          v38 = 1;
        }
        if (v35 > (unsigned __int16)v3)
          v34 = v37;
        if (v34 > (unsigned __int16)v3)
        {
          v39 = v38;
        }
        else
        {
          v20 = v20 + (unsigned __int16)v3 + 1 - v34;
          v39 = 1;
        }
LABEL_56:
        if (*v33 != (unsigned __int16)v3)
          goto LABEL_110;
        v14 += v39;
        if (v33 >= (unsigned __int16 *)&v76)
        {
          v40 = 0;
          v13 = (v13 + 1);
          goto LABEL_81;
        }
        v31 = v16 + 4;
        v3 = *v16;
        ++v18;
        v32 = (v13 + 1);
        if (v28 <= v3)
        {
          v40 = 1;
          v13 = (v13 + 1);
          goto LABEL_81;
        }
      }
      v40 = 1;
      v16 = v33;
LABEL_81:
      if ((unint64_t)v21 >= v5)
        goto LABEL_94;
      v28 = (unsigned __int16)*v21;
LABEL_83:
      if ((unint64_t)(v21 + 1) >= v5)
      {
        v22 = 1;
        v23 = 1;
        if (!v20)
          goto LABEL_35;
      }
      else
      {
        v49 = v21[1];
        v50 = v49 >= 0;
        if (v49 < 0)
          v22 = 2;
        else
          v22 = 1;
        if (v50)
          v23 = 1;
        else
          v23 = (v21[1] & 0x7FFF) + 1;
        if (!v20)
          goto LABEL_35;
      }
      v24 = v23 + v28;
      if (v20 + (unint64_t)v19 < v28 || v24 < v19)
      {
LABEL_94:
        LOWORD(v28) = v19;
        v23 = v20;
        break;
      }
      v26 = v20 - v23 + v19 + v28;
      v27 = v19 > v28;
      if (v19 < v28)
        v28 = v19;
      if (v27)
      {
        v20 = v20 - v23 + v19;
        v29 = v26;
      }
      else
      {
        v29 = v20 + v19;
      }
      if (v24 > v29)
        v23 = v20 + v24 - v29;
      else
        v23 = v20;
LABEL_35:
      v21 += v22;
      if (v23 + (unint64_t)v28 >= (unsigned __int16)v3)
        v30 = v40;
      else
        v30 = 0;
      v19 = v28;
      v20 = v23;
      if ((v30 & 1) != 0)
        continue;
      break;
    }
    if (v23 == 1)
    {
      if (v17 < v21)
      {
        v6 = v21;
      }
      else
      {
        if (v5 + 4 > v15)
        {
LABEL_132:
          v65 = __si_assert_copy_extra_268();
          v66 = v65;
          if (v65)
            v67 = v65;
          else
            v67 = "";
          __message_assert("%s:%u: Unexpected code path %s ", "SIValueSetInternals.h", 626, v67);
          free(v66);
          goto LABEL_129;
        }
        v6 = (__int16 *)(v15 - (v5 - (_QWORD)v21));
        if ((__int16 *)v5 == v21)
        {
          v5 = v15;
        }
        else
        {
          v72 = (void *)(v15 - (v5 - (_QWORD)v21));
          v74 = v17;
          v52 = v15;
          memmove(v72, v21, v5 - (_QWORD)v21);
          v6 = (__int16 *)v72;
          v17 = v74;
          v15 = v52;
          v5 = v52;
        }
      }
      *v17++ = v28;
      if (!v40)
        goto LABEL_116;
      goto LABEL_19;
    }
    if (v23)
    {
      v51 = v17 + 1;
      if (v17 + 1 < v21)
      {
        v6 = v21;
        goto LABEL_107;
      }
      if (v5 + 4 > v15)
        goto LABEL_132;
      v6 = (__int16 *)(v15 - (v5 - (_QWORD)v21));
      if ((__int16 *)v5 != v21)
      {
        v73 = (void *)(v15 - (v5 - (_QWORD)v21));
        v75 = v17;
        v70 = v17 + 1;
        v71 = v15;
        memmove(v73, v21, v5 - (_QWORD)v21);
        v51 = v70;
        v15 = v71;
        v6 = (__int16 *)v73;
        v17 = v75;
      }
      v5 = v15;
LABEL_107:
      *v17 = v28;
      v17[1] = (v23 - 1) | 0x8000;
      v17 = v51 + 1;
      if (!v40)
      {
LABEL_116:
        v21 = v6;
        goto LABEL_122;
      }
LABEL_19:
      if ((unint64_t)v17 + v5 - (_QWORD)v6 + 4 > v15)
        goto LABEL_118;
      continue;
    }
    break;
  }
  v6 = v21;
  if (!v40)
  {
LABEL_122:
    v6 = v21;
    if ((_DWORD)v13 == v18)
      goto LABEL_123;
    v61 = __si_assert_copy_extra_268();
    v62 = v61;
    v63 = "";
    if (v61)
      v63 = v61;
    __message_assert("%s:%u: failed assertion '%s' %s ", "SIValueSetInternals.h", 811, "popped==peeked", v63);
    free(v62);
    if (!__valid_fs(-1))
    {
      v64 = 3072;
LABEL_131:
      *(_DWORD *)v64 = -559038737;
      abort();
    }
LABEL_129:
    v64 = 2989;
    goto LABEL_131;
  }
LABEL_118:
  if ((int)v13 >= v18)
  {
    v56 = __si_assert_copy_extra_268();
    v54 = v56;
    v57 = "";
    if (v56)
      v57 = v56;
    __message_assert("%s:%u: failed assertion '%s' %s ", "SIValueSetInternals.h", 810, "popped<peeked", v57);
    goto LABEL_113;
  }
LABEL_123:
  v58 = v5 - (_DWORD)v6;
  if (v5 > (unint64_t)v6)
  {
    v59 = (int)v17;
    memmove(v17, v6, v5 - (_QWORD)v6);
    LODWORD(v17) = v59 + v58;
  }
  *(_WORD *)(a1 + 8) = ((_DWORD)v17 - v68) >> 1;
  return v14 != 0;
}

uint64_t SIValueSet<unsigned long long>::RLEKeyHolder<unsigned short>::AddSortedKeysWithContext(uint64_t a1, uint64_t **a2, uint64_t a3)
{
  unsigned __int16 v6;
  unsigned __int16 v7;
  unint64_t v8;
  unint64_t v9;
  __int16 *v10;
  uint64_t v11;
  unint64_t v12;
  __int16 *v13;
  int v14;
  __int16 v15;
  uint64_t result;
  int v18;
  unint64_t v19;
  __int16 *v20;
  int v21;
  unint64_t v22;
  unsigned int v23;
  uint64_t v24;
  __int16 *v25;
  char v26;
  uint64_t v27;
  unsigned __int16 v28;
  unint64_t v29;
  int v30;
  int v31;
  uint64_t *v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  unint64_t v38;
  int v39;
  uint64_t v40;
  BOOL v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t v45;
  unint64_t v46;
  BOOL v47;
  _WORD *v48;
  __int16 *v49;
  uint64_t v50;
  char *v51;
  char *v52;
  const char *v53;
  char *v54;
  char *v55;
  const char *v56;
  uint64_t v57;
  char *v58;
  const char *v59;
  int v60;
  uint64_t v61;
  char *v62;
  const char *v63;
  char *v64;
  char *v65;
  const char *v66;
  uint64_t v67;
  int v68;
  uint64_t v69;
  unint64_t v70;
  __int16 *v71;
  uint64_t v72;

  if (*a2 >= a2[1] || (uint64_t *)((unint64_t)a2[3] & **a2) != a2[2])
    return 0;
  v6 = SIValueSet<unsigned long long>::FlatContextWithPfx::peek(a2);
  v7 = v6;
  v8 = *(unsigned __int16 *)(a1 + 8);
  v9 = a1 + 10 + 2 * v8;
  v10 = (__int16 *)(a1 + 10);
  if (v8 >= 3)
  {
    v11 = 2 * v8;
    v12 = a1 + 10 + 2 * v8;
    v10 = (__int16 *)(a1 + 10);
    do
    {
      v13 = &v10[v11 >> 2];
      v14 = *v13;
      if (v14 < 0)
      {
        v15 = *--v13;
        LOWORD(v14) = v15;
      }
      if (v13 <= v10)
        break;
      if ((unsigned __int16)v14 == v6)
      {
        v10 = v13;
        break;
      }
      if ((unsigned __int16)v14 > v6)
        v12 = (unint64_t)v13;
      else
        v10 = v13;
      v11 = v12 - (_QWORD)v10;
    }
    while (v12 > (unint64_t)v10 && (unint64_t)v11 > 5);
  }
  v67 = a1;
  v68 = a1 + 10;
  v18 = 0;
  result = 0;
  v19 = a1 + 136;
  v20 = v10;
  v21 = 1;
  v72 = a3;
  v70 = v19;
  while (2)
  {
    v71 = v20;
    LOWORD(v23) = 0;
    v24 = 0;
    v25 = v10;
    while (1)
    {
      v27 = v24;
      v28 = v23;
      if ((unint64_t)v25 >= v9)
        break;
LABEL_29:
      v23 = (unsigned __int16)*v25;
      if (v23 > v7)
        break;
      v30 = 1;
LABEL_53:
      if ((unint64_t)(v25 + 1) >= v9)
      {
        v42 = 1;
        v24 = 1;
        if (v27)
          goto LABEL_60;
      }
      else
      {
        v39 = v25[1];
        v40 = v39 & 0x7FFF;
        v41 = v39 >= 0;
        v42 = 2;
        if (v41)
        {
          v42 = 1;
          v24 = 1;
        }
        else
        {
          v24 = v40 + 1;
        }
        if (v27)
        {
LABEL_60:
          v43 = v24 + v23;
          if (v27 + (unint64_t)v28 < v23 || v43 < v28)
            goto LABEL_73;
          v45 = v27 - v24 + v28;
          v46 = v45 + v23;
          v47 = v28 > v23;
          if (v28 < v23)
            v23 = v28;
          if (!v47)
          {
            v45 = v27;
            v46 = v27 + v28;
          }
          if (v43 > v46)
            v24 = v45 + v43 - v46;
          else
            v24 = v45;
        }
      }
      v25 += v42;
      if (v24 + (unint64_t)v23 >= v7)
        v26 = v30;
      else
        v26 = 0;
      if ((v26 & 1) == 0)
        goto LABEL_74;
    }
    while (2)
    {
      if (!v27)
      {
        v27 = 1;
        v28 = v7;
LABEL_39:
        v31 = 1;
        goto LABEL_40;
      }
      v29 = v27 + v28;
      v30 = 1;
      if (v29 < v7 || (unint64_t)v7 + 1 < v28)
        goto LABEL_51;
      if (v28 <= v7)
      {
        v31 = 0;
        if (v29 > v7)
          goto LABEL_40;
        goto LABEL_38;
      }
      v27 = v27 + v28 - 1;
      v29 = v27 + v7;
      v31 = 1;
      v28 = v7;
      if (v29 <= v7)
      {
LABEL_38:
        v27 = v27 + v7 + 1 - v29;
        goto LABEL_39;
      }
LABEL_40:
      v32 = *a2 + 1;
      v33 = **a2;
      *a2 = v32;
      v34 = (unint64_t)a2[3];
      if ((uint64_t *)(v34 & v33) != a2[2])
      {
        v51 = __si_assert_copy_extra_268();
        v52 = v51;
        v53 = "";
        if (v51)
          v53 = v51;
        __message_assert("%s:%u: failed assertion '%s' %s ", "SIValueSetInternals.h", 172, "(key & fMask) == fPfx", v53);
LABEL_92:
        free(v52);
        if (__valid_fs(-1))
        {
          MEMORY[0xBAD] = -559038737;
          abort();
        }
        MEMORY[0xC00] = -559038737;
        abort();
      }
      if (v7 != (unsigned __int16)(v33 & ~(_WORD)v34))
      {
        v54 = __si_assert_copy_extra_268();
        v55 = v54;
        v56 = "";
        if (v54)
          v56 = v54;
        __message_assert("%s:%u: failed assertion '%s' %s ", "SIValueSetInternals.h", 761, "v==key", v56);
        goto LABEL_97;
      }
      if (v31)
      {
        ++result;
      }
      else if (v72)
      {
        v35 = result;
        v36 = v9;
        SIValueSet<unsigned long long>::SIValueSetInsert(*(unint64_t **)(v72 + 8), *(_QWORD *)v72 | v7);
        result = v35;
        v9 = v36;
        v32 = *a2;
      }
      if (v32 < a2[1])
      {
        v37 = *v32;
        v38 = (unint64_t)a2[3];
        if ((uint64_t *)(v38 & v37) == a2[2])
        {
          v7 = v37 & ~(_WORD)v38;
          ++v21;
          ++v18;
          if ((unint64_t)v25 < v9)
            goto LABEL_29;
          continue;
        }
      }
      break;
    }
    v30 = 0;
    ++v18;
LABEL_51:
    if ((unint64_t)v25 < v9)
    {
      v23 = (unsigned __int16)*v25;
      goto LABEL_53;
    }
LABEL_73:
    LOWORD(v23) = v28;
    v24 = v27;
LABEL_74:
    if (v24 == 1)
    {
      v49 = v71;
      if (v71 >= v25)
      {
        if (v9 + 4 > v70)
          goto LABEL_114;
        v10 = (__int16 *)(v70 - (v9 - (_QWORD)v25));
        if ((__int16 *)v9 != v25)
        {
          v50 = result;
          memmove((void *)(v70 - (v9 - (_QWORD)v25)), v25, v9 - (_QWORD)v25);
          result = v50;
          v49 = v71;
        }
        v9 = v70;
        v22 = v70;
      }
      else
      {
        v10 = v25;
        v22 = v70;
      }
      *v49 = v23;
      v20 = v49 + 1;
      if (v30)
        goto LABEL_22;
      goto LABEL_88;
    }
    if (v24)
    {
      v48 = v71 + 1;
      if (v71 + 1 < v25)
      {
        v10 = v25;
        v22 = v70;
        goto LABEL_21;
      }
      if (v9 + 4 <= v70)
      {
        v10 = (__int16 *)(v70 - (v9 - (_QWORD)v25));
        if ((__int16 *)v9 != v25)
        {
          v69 = result;
          memmove((void *)(v70 - (v9 - (_QWORD)v25)), v25, v9 - (_QWORD)v25);
          v48 = v71 + 1;
          result = v69;
        }
        v9 = v70;
        v22 = v70;
LABEL_21:
        *v71 = v23;
        v71[1] = (v24 - 1) | 0x8000;
        v20 = v48 + 1;
        if (v30)
        {
LABEL_22:
          if ((unint64_t)v20 + v9 - (_QWORD)v10 + 4 > v22)
            goto LABEL_103;
          continue;
        }
LABEL_88:
        v25 = v10;
LABEL_107:
        v10 = v25;
        if (v18 == v21)
          goto LABEL_108;
        v62 = __si_assert_copy_extra_268();
        v55 = v62;
        v63 = "";
        if (v62)
          v63 = v62;
        __message_assert("%s:%u: failed assertion '%s' %s ", "SIValueSetInternals.h", 811, "popped==peeked", v63);
LABEL_97:
        free(v55);
        if (__valid_fs(-1))
LABEL_98:
          v57 = 2989;
        else
          v57 = 3072;
        *(_DWORD *)v57 = -559038737;
        abort();
      }
LABEL_114:
      v64 = __si_assert_copy_extra_268();
      v65 = v64;
      if (v64)
        v66 = v64;
      else
        v66 = "";
      __message_assert("%s:%u: Unexpected code path %s ", "SIValueSetInternals.h", 626, v66);
      free(v65);
      goto LABEL_98;
    }
    break;
  }
  v10 = v25;
  v20 = v71;
  if (!v30)
    goto LABEL_107;
LABEL_103:
  if (v18 >= v21)
  {
    v58 = __si_assert_copy_extra_268();
    v52 = v58;
    v59 = "";
    if (v58)
      v59 = v58;
    __message_assert("%s:%u: failed assertion '%s' %s ", "SIValueSetInternals.h", 810, "popped<peeked", v59);
    goto LABEL_92;
  }
LABEL_108:
  v60 = v9 - (_DWORD)v10;
  if (v9 > (unint64_t)v10)
  {
    v61 = result;
    memmove(v20, v10, v9 - (_QWORD)v10);
    result = v61;
    LODWORD(v20) = (_DWORD)v20 + v60;
  }
  *(_WORD *)(v67 + 8) = ((_DWORD)v20 - v68) >> 1;
  return result;
}

uint64_t SIValueSet<unsigned long long>::RLEKeyHolder<unsigned short>::ContainsKey(uint64_t a1, unsigned __int16 a2, unsigned __int16 a3)
{
  unint64_t v3;
  __int16 *v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  __int16 *v9;
  unsigned int v10;
  unsigned int v11;
  unint64_t v13;
  uint64_t result;
  unsigned __int16 *v15;
  __int16 v16;
  unsigned int v17;
  unint64_t v18;
  unint64_t v19;

  v3 = a2 & a3 & 0x7FFF;
  v4 = (__int16 *)(a1 + 10);
  v5 = *(unsigned __int16 *)(a1 + 8);
  v6 = a1 + 10 + 2 * v5;
  if (v5 < 3)
  {
LABEL_15:
    if ((unint64_t)v4 >= v6)
      return 0;
  }
  else
  {
    v7 = 2 * v5;
    v8 = a1 + 10 + 2 * v5;
    while (1)
    {
      v9 = &v4[v7 >> 2];
      if (*v9 < 0)
      {
        v11 = (unsigned __int16)*--v9;
        v10 = v11;
        if (v9 <= v4)
          goto LABEL_15;
      }
      else
      {
        v10 = (unsigned __int16)*v9;
        if (v9 <= v4)
          goto LABEL_15;
      }
      if (v10 == (_DWORD)v3)
        break;
      if (v10 > v3)
        v8 = (unint64_t)v9;
      else
        v4 = v9;
      v7 = v8 - (_QWORD)v4;
      if (v8 <= (unint64_t)v4 || (unint64_t)v7 <= 5)
        goto LABEL_15;
    }
    v4 = v9;
    if ((unint64_t)v9 >= v6)
      return 0;
  }
  v13 = (unsigned __int16)*v4;
  if (v3 != v13)
  {
    v15 = (unsigned __int16 *)(v4 + 1);
    v16 = v13;
    do
    {
      if (v16 < 0)
      {
        v18 = *(v15 - 2);
        v19 = v18 + (v16 & 0x7FFF);
        if (v3 >= v18 && v3 <= v19)
          return 1;
        if ((unint64_t)v15 >= v6)
          return 0;
      }
      else
      {
        result = 0;
        if (v3 < v13 || (unint64_t)v15 >= v6)
          return result;
      }
      v17 = *v15++;
      v13 = v17;
      v16 = v17;
    }
    while (v3 != v17);
  }
  return 1;
}

uint64_t SIValueSet<unsigned long long>::RLEKeyHolder<unsigned short>::CloseKey(uint64_t a1, int a2, unsigned int a3)
{
  uint64_t v3;
  unint64_t v4;
  __int16 *v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  __int16 *v9;
  unsigned int v10;
  unsigned int v11;
  unsigned __int16 *v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v17;
  unsigned int v18;
  uint64_t v20;

  v3 = *(unsigned __int16 *)(a1 + 8);
  if (!*(_WORD *)(a1 + 8))
    return 0;
  v4 = a2 & a3 & 0x7FFFLL;
  v5 = (__int16 *)(a1 + 10);
  v6 = a1 + 10 + 2 * v3;
  if (v3 < 3)
  {
LABEL_16:
    if ((unint64_t)v5 >= v6)
    {
LABEL_31:
      v20 = a1 + 2 * v3;
      v17 = *(unsigned __int16 *)(v20 + 8);
      if (*(__int16 *)(v20 + 8) < 0)
        return (v17 & 0x7FFF) + *(unsigned __int16 *)(v20 + 6);
      else
        return v17;
    }
  }
  else
  {
    v7 = 2 * v3;
    v8 = a1 + 10 + 2 * v3;
    while (1)
    {
      v9 = &v5[v7 >> 2];
      if (*v9 < 0)
      {
        v11 = (unsigned __int16)*--v9;
        v10 = v11;
        if (v9 <= v5)
          goto LABEL_16;
      }
      else
      {
        v10 = (unsigned __int16)*v9;
        if (v9 <= v5)
          goto LABEL_16;
      }
      if (v10 == (_DWORD)v4)
        break;
      if (v10 > v4)
        v8 = (unint64_t)v9;
      else
        v5 = v9;
      v7 = v8 - (_QWORD)v5;
      if (v8 <= (unint64_t)v5 || (unint64_t)v7 <= 5)
        goto LABEL_16;
    }
    v5 = v9;
    if ((unint64_t)v9 >= v6)
      goto LABEL_31;
  }
  v13 = (unsigned __int16 *)v5;
  while (1)
  {
    v18 = *v13++;
    v17 = v18;
    if (v4 == v18)
      return a2 & a3 & 0x7FFFLL;
    if ((v17 & 0x8000) != 0)
    {
      v14 = (unsigned __int16)*(v5 - 1);
      v15 = v14 + (v17 & 0x7FFF);
      if (v4 >= v14 && v4 <= v15)
        return a2 & a3 & 0x7FFFLL;
    }
    else if (v4 < v17)
    {
      return v17;
    }
    v5 = (__int16 *)v13;
    if ((unint64_t)v13 >= v6)
      goto LABEL_31;
  }
}

uint64_t SIValueSet<unsigned long long>::RLEKeyHolder<unsigned short>::RemoveKey(uint64_t a1, unsigned __int16 a2, unsigned __int16 a3)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  __int16 *v8;
  uint64_t v9;
  unint64_t v10;
  __int16 *v11;
  int v12;
  __int16 v13;
  unint64_t v15;
  _WORD *v16;
  unsigned int v17;
  uint64_t result;
  unint64_t v19;
  unint64_t v20;
  int v22;
  size_t v23;
  const void *v24;
  __int16 v25;
  _WORD *v26;
  __int16 v27;
  __int16 v28;
  unint64_t v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  __int16 v33;
  __int16 v34;
  unint64_t v35;
  uint64_t v36;
  char *v37;
  char *v38;
  const char *v39;

  v4 = a2 & a3 & 0x7FFF;
  v5 = a1 + 10;
  v6 = *(unsigned __int16 *)(a1 + 8);
  v7 = a1 + 10 + 2 * v6;
  if (v6 >= 3)
  {
    v9 = 2 * v6;
    v10 = a1 + 10 + 2 * v6;
    v8 = (__int16 *)(a1 + 10);
    do
    {
      v11 = &v8[v9 >> 2];
      v12 = *v11;
      if (v12 < 0)
      {
        v13 = *--v11;
        LOWORD(v12) = v13;
      }
      if (v11 <= v8)
        break;
      if ((_DWORD)v4 == (unsigned __int16)v12)
      {
        v8 = v11;
        if ((unint64_t)v11 >= v7)
          return 0;
        goto LABEL_17;
      }
      if ((unsigned __int16)v12 > v4)
        v10 = (unint64_t)v11;
      else
        v8 = v11;
      v9 = v10 - (_QWORD)v8;
    }
    while (v10 > (unint64_t)v8 && (unint64_t)v9 > 5);
    if ((unint64_t)v8 >= v7)
      return 0;
  }
  else
  {
    v8 = (__int16 *)(a1 + 10);
    if (v5 >= v7)
      return 0;
  }
LABEL_17:
  v16 = v8 + 1;
  v15 = (unsigned __int16)*v8;
  if (v4 == v15)
  {
    if ((unint64_t)v16 >= v7)
      goto LABEL_43;
    goto LABEL_35;
  }
  while (1)
  {
    if ((v15 & 0x8000) == 0)
    {
      result = 0;
      if (v4 < v15 || (unint64_t)v16 >= v7)
        return result;
      goto LABEL_20;
    }
    v19 = (unsigned __int16)*(v16 - 2);
    v20 = (unsigned __int16)(v19 + (v15 & 0x7FFF));
    if (v4 > v19 && v4 <= v20)
      break;
    if ((unint64_t)v16 >= v7)
      return 0;
LABEL_20:
    v17 = (unsigned __int16)*v16++;
    v15 = v17;
    if (v4 == v17)
    {
      v8 = v16 - 1;
      if ((unint64_t)v16 >= v7)
        goto LABEL_43;
LABEL_35:
      v22 = (__int16)*v16;
      if ((v22 & 0x80000000) == 0)
      {
        v23 = v7 - (_QWORD)v16;
        v24 = v16;
LABEL_39:
        memmove(v8, v24, v23);
        v25 = *(_WORD *)(a1 + 8) - 1;
        goto LABEL_44;
      }
      *v8 = v15 + 1;
      if ((v22 & 0x7FFF) == 1)
      {
        v24 = v8 + 2;
        v23 = v7 - (_QWORD)(v8 + 2);
        v8 = v16;
        goto LABEL_39;
      }
      v27 = v22 - 1;
      goto LABEL_48;
    }
  }
  v26 = v16 - 1;
  if ((v15 & 0x7FFF) != 1)
  {
    if (v4 == v20)
    {
      *v26 = (v15 - 1) | 0x8000;
      return 1;
    }
    if (v4 == v19 + 1)
    {
      *v26 = v4 + 1;
      if (!(~(_DWORD)v4 + (_DWORD)v20))
        return 1;
      v29 = *(unsigned __int16 *)(a1 + 8);
      if (v29 < 0x3F)
      {
        v30 = (uint64_t)((uint64_t)v16 - v5) >> 1;
        if (v29 != v30)
        {
          memmove(v16 + 1, v16, 2 * (v29 - v30));
          LOWORD(v29) = *(_WORD *)(a1 + 8);
        }
        *(_WORD *)(a1 + 8) = v29 + 1;
        v27 = v20 + ~(_WORD)v4;
LABEL_48:
        v28 = v27 | 0x8000;
LABEL_49:
        *v16 = v28;
        return 1;
      }
    }
    else
    {
      *(v16 - 1) = (v4 + ~(_WORD)v19) | 0x8000;
      v31 = *(unsigned __int16 *)(a1 + 8);
      if (v31 < 0x3F)
      {
        v32 = (uint64_t)((uint64_t)v16 - v5) >> 1;
        if (v31 != v32)
        {
          memmove(v16 + 1, v16, 2 * (v31 - v32));
          LOWORD(v31) = *(_WORD *)(a1 + 8);
        }
        *(_WORD *)(a1 + 8) = v31 + 1;
        *v16 = v4 + 1;
        v33 = ~(_WORD)v4;
        v34 = v20 + ~(_WORD)v4;
        if (!((_WORD)v20 + v33))
          return 1;
        v35 = *(unsigned __int16 *)(a1 + 8);
        if (v35 < 0x3F)
        {
          ++v16;
          v36 = (uint64_t)((uint64_t)v26 - v5 + 4) >> 1;
          if (v35 != v36)
          {
            memmove(v26 + 3, v26 + 2, 2 * (v35 - v36));
            LOWORD(v35) = *(_WORD *)(a1 + 8);
          }
          *(_WORD *)(a1 + 8) = v35 + 1;
          v28 = v34 | 0x8000;
          goto LABEL_49;
        }
      }
    }
    v37 = __si_assert_copy_extra_268();
    v38 = v37;
    if (v37)
      v39 = v37;
    else
      v39 = "";
    __message_assert("%s:%u: Unexpected code path %s ", "SIValueSetInternals.h", 649, v39);
    free(v38);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  if ((unint64_t)v16 < v7)
  {
    memmove(v16 - 1, v16, v7 - (_QWORD)v16);
    LOWORD(v6) = *(_WORD *)(a1 + 8);
  }
LABEL_43:
  v25 = v6 - 1;
LABEL_44:
  *(_WORD *)(a1 + 8) = v25;
  return 1;
}

void SIValueSet<unsigned long long>::RLEKeyHolder<unsigned short>::Apply(uint64_t a1, uint64_t a2, unint64_t a3, void (*a4)(char *, uint64_t, uint64_t), uint64_t a5)
{
  uint64_t v9;
  size_t v10;
  char *v11;
  unint64_t v12;
  unsigned __int16 *v13;
  unint64_t v14;
  unsigned __int16 v15;
  __int16 v16;
  uint64_t v17;
  int v18;
  _QWORD v19[2];

  v19[1] = *MEMORY[0x1E0C80C00];
  v9 = MEMORY[0x1E0C80A78](a1);
  v11 = (char *)v19 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = *(unsigned __int16 *)(v9 + 8);
  if (v12 > 0x3F)
    return;
  v13 = (unsigned __int16 *)(v9 + 10);
  v14 = v9 + 10 + 2 * v12;
  bzero((char *)v19 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0), v10);
  v15 = 0;
  v16 = 0;
LABEL_3:
  v17 = 0;
  while (v16)
  {
    --v16;
    ++v15;
LABEL_15:
    *(_QWORD *)&v11[8 * v17++] = v15 | a3;
    if (v17 == a2)
    {
      a4(v11, a2, a5);
      goto LABEL_3;
    }
  }
  if ((unint64_t)v13 < v14)
  {
    v15 = *v13;
    if ((unint64_t)(v13 + 1) >= v14)
    {
      v16 = 0;
      ++v13;
    }
    else
    {
      v18 = (__int16)v13[1];
      if (v18 < 0)
        v16 = v18 & 0x7FFF;
      else
        v16 = 0;
      if (v18 < 0)
        v13 += 2;
      else
        ++v13;
    }
    goto LABEL_15;
  }
  if (v17)
    a4(v11, v17, a5);
}

BOOL SIValueSet<unsigned long long>::RLEKeyHolder<unsigned short>::IsEmpty(uint64_t a1)
{
  return *(_WORD *)(a1 + 8) == 0;
}

uint64_t SIValueSet<unsigned long long>::RLEKeyHolder<unsigned short>::GetRawCount(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 8);
}

uint64_t SIValueSet<unsigned long long>::RLEKeyHolder<unsigned short>::Serialize(uint64_t a1, uint64_t a2)
{
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 8))(a2, 2);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 8))(a2, *(unsigned __int16 *)(a1 + 8));
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 16))(a2, a1 + 10, 2 * *(unsigned __int16 *)(a1 + 8));
}

void SIValueSet<unsigned long long>::RLEKeyHolder<unsigned short>::~RLEKeyHolder()
{
  JUMPOUT(0x1BCCB06A4);
}

uint64_t SIValueSet<unsigned long long>::RLEKeyHolder<unsigned short>::valueIterator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = *(unsigned __int16 *)(a1 + 8);
  *(_QWORD *)a3 = off_1E6E2A750;
  *(_QWORD *)(a3 + 8) = a1 + 10;
  *(_QWORD *)(a3 + 16) = a1 + 10 + 2 * v3;
  *(_DWORD *)(a3 + 24) = 0;
  *(_QWORD *)(a3 + 32) = a2;
  return a3;
}

uint64_t SIValueSet<unsigned long long>::RLEKeyHolder<unsigned short>::RLEKeyIterator::nextKey(uint64_t a1)
{
  uint64_t v1;
  unsigned __int16 v2;
  unsigned __int16 *v3;
  unint64_t v4;
  int v5;

  v1 = *(_QWORD *)(a1 + 32);
  if (*(_WORD *)(a1 + 26))
  {
    --*(_WORD *)(a1 + 26);
    v2 = *(_WORD *)(a1 + 24) + 1;
    *(_WORD *)(a1 + 24) = v2;
  }
  else
  {
    v3 = *(unsigned __int16 **)(a1 + 8);
    v4 = *(_QWORD *)(a1 + 16);
    v2 = *v3;
    *(_QWORD *)(a1 + 8) = v3 + 1;
    *(_WORD *)(a1 + 24) = v2;
    if ((unint64_t)(v3 + 1) < v4)
    {
      v5 = (__int16)v3[1];
      if (v5 < 0)
      {
        *(_QWORD *)(a1 + 8) = v3 + 2;
        *(_WORD *)(a1 + 26) = v5 & 0x7FFF;
      }
    }
  }
  return v1 | v2;
}

BOOL SIValueSet<unsigned long long>::RLEKeyHolder<unsigned short>::RLEKeyIterator::hasMore(uint64_t a1)
{
  return *(_WORD *)(a1 + 26) || *(_QWORD *)(a1 + 8) < *(_QWORD *)(a1 + 16);
}

void SIValueSet<unsigned long long>::RLEKeyHolder<unsigned short>::RLEKeyIterator::~RLEKeyIterator()
{
  JUMPOUT(0x1BCCB06A4);
}

unint64_t SIValueSet<unsigned long long>::RLEKeyHolder<unsigned int>::CloseKey(uint64_t a1, int a2, int a3)
{
  uint64_t v3;
  unint64_t v4;
  unsigned int *v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unsigned int *v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int *v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v17;
  unsigned int v18;

  v3 = *(unsigned int *)(a1 + 8);
  if (!(_DWORD)v3)
    return 0;
  v4 = a2 & a3 & 0x7FFFFFFF;
  v5 = (unsigned int *)(a1 + 12);
  v6 = a1 + 12 + 4 * v3;
  if (v3 >= 3)
  {
    v7 = 4 * v3;
    v8 = a1 + 12 + 4 * v3;
    do
    {
      v9 = &v5[v7 >> 3];
      v10 = *v9;
      if ((*v9 & 0x80000000) != 0)
      {
        v11 = *--v9;
        v10 = v11;
      }
      if (v9 <= v5)
        break;
      if (v10 == (_DWORD)v4)
      {
        v5 = v9;
        if ((unint64_t)v9 < v6)
          goto LABEL_16;
        goto LABEL_30;
      }
      if (v10 > v4)
        v8 = (unint64_t)v9;
      else
        v5 = v9;
      v7 = v8 - (_QWORD)v5;
    }
    while (v8 > (unint64_t)v5 && (unint64_t)v7 > 0xB);
  }
  if ((unint64_t)v5 >= v6)
  {
LABEL_30:
    v17 = *(unsigned int *)(a1 + 4 * (v3 - 1) + 12);
    if ((v17 & 0x80000000) != 0)
      return *(_DWORD *)(a1 + 4 * (v3 - 2) + 12) + (v17 & 0x7FFFFFFF);
    else
      return v17;
  }
  else
  {
LABEL_16:
    v13 = v5;
    while (1)
    {
      v18 = *v13++;
      v17 = v18;
      if (v4 == v18)
        return a2 & a3 & 0x7FFFFFFF;
      if ((v17 & 0x80000000) != 0)
      {
        v14 = *(v5 - 1);
        v15 = v14 + (v17 & 0x7FFFFFFF);
        if (v4 >= v14 && v4 <= v15)
          return a2 & a3 & 0x7FFFFFFF;
      }
      else if (v4 < v17)
      {
        return v17;
      }
      v5 = v13;
      if ((unint64_t)v13 >= v6)
        goto LABEL_30;
    }
  }
}

uint64_t SIValueSet<unsigned long long>::RLEKeyHolder<unsigned int>::RemoveKey(uint64_t a1, int a2, int a3)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unsigned int *v8;
  uint64_t v9;
  unint64_t v10;
  unsigned int *v11;
  unsigned int v12;
  unsigned int v13;
  unint64_t v15;
  unsigned int *v16;
  unsigned int v17;
  uint64_t result;
  unint64_t v19;
  unint64_t v20;
  unsigned int v22;
  size_t v23;
  unsigned int *v24;
  int v25;
  unsigned int *v26;
  unsigned int v27;
  unsigned int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  char *v36;
  char *v37;
  const char *v38;

  v4 = a2 & a3 & 0x7FFFFFFF;
  v5 = a1 + 12;
  v6 = *(unsigned int *)(a1 + 8);
  v7 = a1 + 12 + 4 * v6;
  if (v6 >= 3)
  {
    v9 = 4 * v6;
    v10 = a1 + 12 + 4 * v6;
    v8 = (unsigned int *)(a1 + 12);
    do
    {
      v11 = &v8[v9 >> 3];
      v12 = *v11;
      if ((*v11 & 0x80000000) != 0)
      {
        v13 = *--v11;
        v12 = v13;
      }
      if (v11 <= v8)
        break;
      if (v12 == (_DWORD)v4)
      {
        v8 = v11;
        if ((unint64_t)v11 >= v7)
          return 0;
        goto LABEL_17;
      }
      if (v12 > v4)
        v10 = (unint64_t)v11;
      else
        v8 = v11;
      v9 = v10 - (_QWORD)v8;
    }
    while (v10 > (unint64_t)v8 && (unint64_t)v9 > 0xB);
    if ((unint64_t)v8 >= v7)
      return 0;
  }
  else
  {
    v8 = (unsigned int *)(a1 + 12);
    if (v5 >= v7)
      return 0;
  }
LABEL_17:
  v16 = v8 + 1;
  v15 = *v8;
  if (v4 == v15)
  {
    if ((unint64_t)v16 >= v7)
      goto LABEL_43;
    goto LABEL_35;
  }
  while (1)
  {
    if ((v15 & 0x80000000) == 0)
    {
      result = 0;
      if (v4 < v15 || (unint64_t)v16 >= v7)
        return result;
      goto LABEL_20;
    }
    v19 = *(v16 - 2);
    v20 = v19 + (v15 & 0x7FFFFFFF);
    if (v4 > v19 && v4 <= v20)
      break;
    if ((unint64_t)v16 >= v7)
      return 0;
LABEL_20:
    v17 = *v16++;
    v15 = v17;
    if (v4 == v17)
    {
      v8 = v16 - 1;
      if ((unint64_t)v16 >= v7)
        goto LABEL_43;
LABEL_35:
      v22 = *v16;
      if ((*v16 & 0x80000000) == 0)
      {
        v23 = v7 - (_QWORD)v16;
        v24 = v16;
LABEL_39:
        memmove(v8, v24, v23);
        v25 = *(_DWORD *)(a1 + 8) - 1;
        goto LABEL_44;
      }
      *v8 = v15 + 1;
      if ((v22 & 0x7FFFFFFF) == 1)
      {
        v24 = v8 + 2;
        v23 = v7 - (_QWORD)(v8 + 2);
        v8 = v16;
        goto LABEL_39;
      }
      v27 = v22 - 1;
      goto LABEL_48;
    }
  }
  v26 = v16 - 1;
  if ((v15 & 0x7FFFFFFF) != 1)
  {
    if (v4 == v20)
    {
      *v26 = (v15 - 1) | 0x80000000;
      return 1;
    }
    if (v4 == (_DWORD)v19 + 1)
    {
      *v26 = v4 + 1;
      if ((_DWORD)v20 == (_DWORD)v4 + 1)
        return 1;
      v29 = *(unsigned int *)(a1 + 8);
      if (v29 < 0x3F)
      {
        v30 = (uint64_t)((uint64_t)v16 - v5) >> 2;
        if (v29 != v30)
        {
          memmove(v16 + 1, v16, 4 * (v29 - v30));
          LODWORD(v29) = *(_DWORD *)(a1 + 8);
        }
        *(_DWORD *)(a1 + 8) = v29 + 1;
        v27 = v20 + ~(_DWORD)v4;
LABEL_48:
        v28 = v27 | 0x80000000;
LABEL_49:
        *v16 = v28;
        return 1;
      }
    }
    else
    {
      *(v16 - 1) = (v4 + ~(_DWORD)v19) | 0x80000000;
      v31 = *(unsigned int *)(a1 + 8);
      if (v31 < 0x3F)
      {
        v32 = (uint64_t)((uint64_t)v16 - v5) >> 2;
        if (v31 != v32)
        {
          memmove(v16 + 1, v16, 4 * (v31 - v32));
          LODWORD(v31) = *(_DWORD *)(a1 + 8);
        }
        *(_DWORD *)(a1 + 8) = v31 + 1;
        *v16 = v4 + 1;
        v33 = v20 + ~(_DWORD)v4;
        if (!v33)
          return 1;
        v34 = *(unsigned int *)(a1 + 8);
        if (v34 < 0x3F)
        {
          ++v16;
          v35 = (uint64_t)((uint64_t)v26 - v5 + 8) >> 2;
          if (v34 != v35)
          {
            memmove(v26 + 3, v26 + 2, 4 * (v34 - v35));
            LODWORD(v34) = *(_DWORD *)(a1 + 8);
          }
          *(_DWORD *)(a1 + 8) = v34 + 1;
          v28 = v33 | 0x80000000;
          goto LABEL_49;
        }
      }
    }
    v36 = __si_assert_copy_extra_268();
    v37 = v36;
    if (v36)
      v38 = v36;
    else
      v38 = "";
    __message_assert("%s:%u: Unexpected code path %s ", "SIValueSetInternals.h", 649, v38);
    free(v37);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  if ((unint64_t)v16 < v7)
  {
    memmove(v16 - 1, v16, v7 - (_QWORD)v16);
    LODWORD(v6) = *(_DWORD *)(a1 + 8);
  }
LABEL_43:
  v25 = v6 - 1;
LABEL_44:
  *(_DWORD *)(a1 + 8) = v25;
  return 1;
}

void SIValueSet<unsigned long long>::RLEKeyHolder<unsigned int>::Apply(uint64_t a1, uint64_t a2, unint64_t a3, void (*a4)(char *, uint64_t, uint64_t), uint64_t a5)
{
  uint64_t v9;
  size_t v10;
  char *v11;
  uint64_t v12;
  _DWORD *v13;
  unint64_t v14;
  unsigned int v15;
  int v16;
  uint64_t v17;
  int *v18;
  _QWORD v19[2];

  v19[1] = *MEMORY[0x1E0C80C00];
  v9 = MEMORY[0x1E0C80A78](a1);
  v11 = (char *)v19 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = *(unsigned int *)(v9 + 8);
  if (v12 > 0x3F)
    return;
  v13 = (_DWORD *)(v9 + 12);
  v14 = v9 + 12 + 4 * v12;
  bzero((char *)v19 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0), v10);
  v15 = 0;
  v16 = 0;
LABEL_3:
  v17 = 0;
  while (v16)
  {
    --v16;
    ++v15;
LABEL_15:
    *(_QWORD *)&v11[8 * v17++] = v15 | a3;
    if (v17 == a2)
    {
      a4(v11, a2, a5);
      goto LABEL_3;
    }
  }
  if ((unint64_t)v13 < v14)
  {
    v18 = v13 + 1;
    v15 = *v13;
    if ((unint64_t)(v13 + 1) >= v14)
    {
      v16 = 0;
      ++v13;
    }
    else
    {
      if (*v18 < 0)
        v13 += 2;
      else
        ++v13;
      if (*v18 < 0)
        v16 = *v18 & 0x7FFFFFFF;
      else
        v16 = 0;
    }
    goto LABEL_15;
  }
  if (v17)
    a4(v11, v17, a5);
}

BOOL SIValueSet<unsigned long long>::RLEKeyHolder<unsigned int>::IsEmpty(uint64_t a1)
{
  return *(_DWORD *)(a1 + 8) == 0;
}

uint64_t SIValueSet<unsigned long long>::RLEKeyHolder<unsigned int>::Serialize(uint64_t a1, uint64_t a2)
{
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 8))(a2, 4);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 8))(a2, *(unsigned int *)(a1 + 8));
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 16))(a2, a1 + 12, 4 * *(unsigned int *)(a1 + 8));
}

void SIValueSet<unsigned long long>::RLEKeyHolder<unsigned int>::~RLEKeyHolder()
{
  JUMPOUT(0x1BCCB06A4);
}

_QWORD *SIValueSet<unsigned long long>::RLEKeyHolder<unsigned int>::valueIterator(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v3;

  v3 = *(unsigned int *)(a1 + 8);
  *a3 = off_1E6E2A6B0;
  a3[1] = a1 + 12;
  a3[2] = a1 + 12 + 4 * v3;
  a3[3] = 0;
  a3[4] = a2;
  return a3;
}

uint64_t SIValueSet<unsigned long long>::RLEKeyHolder<unsigned int>::RLEKeyIterator::nextKey(uint64_t a1)
{
  uint64_t v1;
  int v2;
  int v3;
  unsigned int v4;
  unsigned int *v5;
  unint64_t v6;
  unsigned int v7;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(_DWORD *)(a1 + 28);
  if (v2)
  {
    v3 = v2 - 1;
    v4 = *(_DWORD *)(a1 + 24) + 1;
    *(_DWORD *)(a1 + 24) = v4;
    *(_DWORD *)(a1 + 28) = v3;
  }
  else
  {
    v5 = *(unsigned int **)(a1 + 8);
    v6 = *(_QWORD *)(a1 + 16);
    v4 = *v5;
    *(_QWORD *)(a1 + 8) = v5 + 1;
    *(_DWORD *)(a1 + 24) = v4;
    if ((unint64_t)(v5 + 1) < v6)
    {
      v7 = v5[1];
      if ((v7 & 0x80000000) != 0)
      {
        *(_QWORD *)(a1 + 8) = v5 + 2;
        *(_DWORD *)(a1 + 28) = v7 & 0x7FFFFFFF;
      }
    }
  }
  return v1 | v4;
}

BOOL SIValueSet<unsigned long long>::RLEKeyHolder<unsigned int>::RLEKeyIterator::hasMore(uint64_t a1)
{
  return *(_DWORD *)(a1 + 28) || *(_QWORD *)(a1 + 8) < *(_QWORD *)(a1 + 16);
}

void SIValueSet<unsigned long long>::RLEKeyHolder<unsigned int>::RLEKeyIterator::~RLEKeyIterator()
{
  JUMPOUT(0x1BCCB06A4);
}

BOOL SIValueSet<unsigned long long>::RLEKeyHolder<unsigned long long>::AddKey(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t *v8;
  unint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t *v17;
  unint64_t *v18;
  int v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t *v22;
  char v23;
  unint64_t v24;
  unint64_t *v25;
  uint64_t v26;
  unint64_t *v27;
  uint64_t v28;
  BOOL v29;
  _BOOL8 v30;
  uint64_t v31;
  int v32;
  unint64_t v33;
  uint64_t v34;
  BOOL v35;
  _BOOL8 v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  unint64_t v43;
  BOOL v44;
  uint64_t v45;
  uint64_t v46;
  _QWORD *v47;
  char *v48;
  char *v49;
  const char *v50;
  char *v51;
  const char *v52;
  unint64_t v53;
  unint64_t *v54;
  char *v56;
  char *v57;
  const char *v58;
  uint64_t v59;
  char *v60;
  char *v61;
  const char *v62;
  uint64_t v63;
  uint64_t v65;
  _QWORD *v66;
  unint64_t v67;
  unint64_t *v68;
  unint64_t *v69;
  uint64_t v70;

  v3 = a3 & a2;
  v70 = a3 & a2;
  v4 = *(_QWORD *)(a1 + 8);
  v5 = 8 * v4;
  v6 = a1 + 16 + 8 * v4;
  if (v4 >= 1 && (unint64_t)v5 >= 0x18)
  {
    v9 = a1 + 16 + 8 * v4;
    v8 = (unint64_t *)(a1 + 16);
    do
    {
      v10 = &v8[v5 >> 4];
      v11 = *v10;
      if ((*v10 & 0x8000000000000000) != 0)
      {
        v12 = *--v10;
        v11 = v12;
      }
      if (v10 <= v8)
        break;
      if (v11 == v3)
      {
        v8 = v10;
        break;
      }
      if (v11 > v3)
        v9 = (unint64_t)v10;
      else
        v8 = v10;
      v5 = v9 - (_QWORD)v8;
    }
    while (v9 > (unint64_t)v8 && (unint64_t)v5 > 0x17);
  }
  else
  {
    v8 = (unint64_t *)(a1 + 16);
  }
  v63 = a1 + 16;
  v14 = 0;
  v15 = 0;
  v16 = a1 + 520;
  v17 = (unint64_t *)&v70;
  v18 = v8;
  v19 = 1;
  v67 = a1 + 520;
  while (2)
  {
    v20 = 0;
    v21 = 0;
    v22 = v8;
    while (1)
    {
      if ((unint64_t)v22 >= v6)
      {
        v27 = v17++;
        if (!v21)
        {
          while (1)
          {
            v20 = v3;
            v21 = 1;
            v37 = 1;
LABEL_58:
            if (*v27 != v3)
              break;
            v15 += v37;
            if (v27 >= (unint64_t *)&v70)
              goto LABEL_62;
            v38 = *v17++;
            v3 = v38;
            ++v19;
            v14 = (v14 + 1);
            v27 = v17 - 1;
            if (v21)
              goto LABEL_48;
          }
LABEL_104:
          v48 = __si_assert_copy_extra_268();
          v49 = v48;
          v50 = "";
          if (v48)
            v50 = v48;
          __message_assert("%s:%u: failed assertion '%s' %s ", "SIValueSetInternals.h", 761, "v==key", v50);
          goto LABEL_107;
        }
LABEL_48:
        if (v21 + v20 >= v3)
        {
          v33 = v3 + 1;
          if (v3 + 1 >= v20)
          {
            v34 = v21 + v20 - 1;
            v35 = v20 > v3;
            v36 = v20 > v3;
            if (v20 >= v3)
              v20 = v3;
            if (v35)
              v21 = v34;
            if (v33 <= v21 + v20)
            {
              v37 = v36;
            }
            else
            {
              v21 = v33 - v20;
              v37 = 1;
            }
            goto LABEL_58;
          }
        }
LABEL_65:
        v32 = 1;
        v17 = v27;
        if ((unint64_t)v22 >= v6)
          goto LABEL_88;
        goto LABEL_66;
      }
      v24 = *v22;
      if (v3 < *v22)
        break;
      v32 = 1;
LABEL_68:
      if ((unint64_t)(v22 + 1) >= v6)
      {
        v40 = 1;
        v41 = 1;
        if (v21)
          goto LABEL_78;
      }
      else
      {
        v39 = v22[1];
        if (v39 < 0)
          v40 = 2;
        else
          v40 = 1;
        if (v39 < 0)
          v41 = (v39 & 0x7FFFFFFFFFFFFFFFLL) + 1;
        else
          v41 = 1;
        if (v21)
        {
LABEL_78:
          if (v21 + v20 < v24)
            goto LABEL_88;
          v42 = v41 + v24;
          if (v41 + v24 < v20)
            goto LABEL_88;
          v43 = v21 + v20 - v41;
          v44 = v20 > v24;
          if (v20 < v24)
            v24 = v20;
          if (v44)
            v45 = v43;
          else
            v45 = v21;
          v41 = v42 - v24;
          if (v42 <= v45 + v24)
            v41 = v45;
        }
      }
      v22 += v40;
      if (v3 <= v41 + v24)
        v23 = v32;
      else
        v23 = 0;
      v20 = v24;
      v21 = v41;
      if ((v23 & 1) == 0)
        goto LABEL_89;
    }
    v25 = v17 + 1;
    v26 = v14;
    while (1)
    {
      v14 = v26;
      v17 = v25;
      v27 = v25 - 1;
      if (v21)
      {
        if (v21 + v20 < v3 || v3 + 1 < v20)
          goto LABEL_65;
        v28 = v21 + v20 - 1;
        v29 = v20 > v3;
        v30 = v20 > v3;
        if (v20 >= v3)
          v20 = v3;
        if (v29)
          v21 = v28;
        if (v3 < v21 + v20)
        {
          v31 = v30;
        }
        else
        {
          v21 = v3 + 1 - v20;
          v31 = 1;
        }
      }
      else
      {
        v20 = v3;
        v21 = 1;
        v31 = 1;
      }
      if (*v27 != v3)
        goto LABEL_104;
      v15 += v31;
      if (v27 >= (unint64_t *)&v70)
        break;
      v25 = v17 + 1;
      v3 = *v17;
      ++v19;
      v26 = (v14 + 1);
      if (*v17 >= v24)
      {
        v32 = 1;
        goto LABEL_63;
      }
    }
LABEL_62:
    v32 = 0;
LABEL_63:
    v14 = (v14 + 1);
    if ((unint64_t)v22 < v6)
    {
LABEL_66:
      v24 = *v22;
      goto LABEL_68;
    }
LABEL_88:
    v24 = v20;
    v41 = v21;
LABEL_89:
    v46 = v41 - 1;
    if (v41 != 1)
    {
      if (v41)
      {
        v47 = v18 + 1;
        if (v18 + 1 < v22)
        {
          v8 = v22;
          goto LABEL_22;
        }
        if (v6 + 16 > v16)
          goto LABEL_125;
        v8 = (unint64_t *)(v16 - (v6 - (_QWORD)v22));
        if ((unint64_t *)v6 != v22)
        {
          v68 = v18;
          v65 = v41 - 1;
          v66 = v18 + 1;
          memmove((void *)(v16 - (v6 - (_QWORD)v22)), v22, v6 - (_QWORD)v22);
          v46 = v65;
          v47 = v66;
          v16 = v67;
          v18 = v68;
        }
        v6 = v16;
LABEL_22:
        *v18 = v24;
        v18[1] = v46 | 0x8000000000000000;
        v18 = v47 + 1;
        if (!v32)
          goto LABEL_103;
LABEL_23:
        if ((unint64_t)v18 + v6 - (_QWORD)v8 + 16 > v16)
          goto LABEL_111;
        continue;
      }
      v8 = v22;
      if (!v32)
        goto LABEL_115;
LABEL_111:
      if ((int)v14 < v19)
        goto LABEL_116;
      v51 = __si_assert_copy_extra_268();
      v49 = v51;
      v52 = "";
      if (v51)
        v52 = v51;
      __message_assert("%s:%u: failed assertion '%s' %s ", "SIValueSetInternals.h", 810, "popped<peeked", v52);
LABEL_107:
      free(v49);
      if (__valid_fs(-1))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
    break;
  }
  if (v18 < v22)
  {
    v8 = v22;
    goto LABEL_102;
  }
  if (v6 + 16 > v16)
  {
LABEL_125:
    v60 = __si_assert_copy_extra_268();
    v61 = v60;
    if (v60)
      v62 = v60;
    else
      v62 = "";
    __message_assert("%s:%u: Unexpected code path %s ", "SIValueSetInternals.h", 626, v62);
    free(v61);
    goto LABEL_122;
  }
  v8 = (unint64_t *)(v16 - (v6 - (_QWORD)v22));
  if ((unint64_t *)v6 != v22)
  {
    v69 = v18;
    memmove((void *)(v16 - (v6 - (_QWORD)v22)), v22, v6 - (_QWORD)v22);
    v16 = v67;
    v18 = v69;
  }
  v6 = v16;
LABEL_102:
  *v18++ = v24;
  if (v32)
    goto LABEL_23;
LABEL_103:
  v22 = v8;
LABEL_115:
  v8 = v22;
  if ((_DWORD)v14 != v19)
  {
    v56 = __si_assert_copy_extra_268();
    v57 = v56;
    v58 = "";
    if (v56)
      v58 = v56;
    __message_assert("%s:%u: failed assertion '%s' %s ", "SIValueSetInternals.h", 811, "popped==peeked", v58);
    free(v57);
    if (!__valid_fs(-1))
    {
      v59 = 3072;
LABEL_124:
      *(_DWORD *)v59 = -559038737;
      abort();
    }
LABEL_122:
    v59 = 2989;
    goto LABEL_124;
  }
LABEL_116:
  v53 = v6 - (_QWORD)v8;
  if (v6 > (unint64_t)v8)
  {
    v54 = v18;
    memmove(v18, v8, v6 - (_QWORD)v8);
    v18 = (unint64_t *)((char *)v54 + v53);
  }
  *(_QWORD *)(a1 + 8) = ((uint64_t)v18 - v63) >> 3;
  return v15 != 0;
}

uint64_t SIValueSet<unsigned long long>::RLEKeyHolder<unsigned long long>::AddSortedKeysWithContext(uint64_t a1, uint64_t **a2, uint64_t a3)
{
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t v18;
  int v20;
  unint64_t v21;
  unint64_t *v22;
  int v23;
  unint64_t v24;
  uint64_t v25;
  unint64_t *v26;
  BOOL v27;
  char v28;
  uint64_t v29;
  unint64_t v30;
  int v31;
  unint64_t v32;
  uint64_t v33;
  BOOL v34;
  _BOOL4 v35;
  int v36;
  uint64_t *v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  unint64_t *v48;
  void *v49;
  char *v50;
  char *v51;
  const char *v52;
  char *v53;
  char *v54;
  const char *v55;
  uint64_t v56;
  char *v57;
  const char *v58;
  unint64_t v59;
  unint64_t *v60;
  char *v61;
  const char *v62;
  char *v63;
  char *v64;
  const char *v65;
  uint64_t v66;
  uint64_t v67;
  void *v68;
  unint64_t v69;
  unint64_t *v70;

  if (*a2 >= a2[1] || (uint64_t *)((unint64_t)a2[3] & **a2) != a2[2])
    return 0;
  v5 = SIValueSet<unsigned long long>::FlatContextWithPfx::peek(a2);
  v6 = v5;
  v7 = *(_QWORD *)(a1 + 8);
  v8 = 8 * v7;
  v9 = a1 + 16 + 8 * v7;
  if (v7 >= 1 && (unint64_t)v8 >= 0x18)
  {
    v15 = a1 + 16 + 8 * v7;
    v11 = (unint64_t *)(a1 + 16);
    v12 = a3;
    do
    {
      v16 = &v11[v8 >> 4];
      v17 = *v16;
      if ((*v16 & 0x8000000000000000) != 0)
      {
        v18 = *--v16;
        v17 = v18;
      }
      if (v16 <= v11)
        break;
      if (v17 == v5)
      {
        v11 = v16;
        break;
      }
      if (v17 > v5)
        v15 = (unint64_t)v16;
      else
        v11 = v16;
      v8 = v15 - (_QWORD)v11;
    }
    while (v15 > (unint64_t)v11 && (unint64_t)v8 > 0x17);
  }
  else
  {
    v11 = (unint64_t *)(a1 + 16);
    v12 = a3;
  }
  v66 = a1;
  v67 = a1 + 16;
  v20 = 0;
  v13 = 0;
  v21 = a1 + 520;
  v22 = v11;
  v23 = 1;
  v69 = v21;
  while (2)
  {
    v70 = v22;
    v24 = 0;
    v25 = 0;
    v26 = v11;
    while (1)
    {
      v29 = v25;
      v30 = v24;
      if ((unint64_t)v26 >= v9)
        break;
LABEL_40:
      v24 = *v26;
      if (v6 < *v26)
        break;
      v31 = 1;
LABEL_68:
      if ((unint64_t)(v26 + 1) >= v9)
      {
        v44 = 1;
        v25 = 1;
        if (v29)
          goto LABEL_78;
      }
      else
      {
        v43 = v26[1];
        if (v43 < 0)
          v44 = 2;
        else
          v44 = 1;
        if (v43 < 0)
          v25 = (v43 & 0x7FFFFFFFFFFFFFFFLL) + 1;
        else
          v25 = 1;
        if (v29)
        {
LABEL_78:
          if (v29 + v30 < v24)
            goto LABEL_82;
          v45 = v25 + v24;
          if (v25 + v24 < v30)
            goto LABEL_82;
          v25 = v29 + v30 - v25;
          v27 = v30 > v24;
          if (v30 < v24)
            v24 = v30;
          if (!v27)
            v25 = v29;
          if (v45 > v25 + v24)
            v25 = v45 - v24;
        }
      }
      v26 += v44;
      if (v6 <= v25 + v24)
        v28 = v31;
      else
        v28 = 0;
      if ((v28 & 1) == 0)
        goto LABEL_83;
    }
    while (2)
    {
      if (v29)
      {
        v31 = 1;
        if (v29 + v30 < v6)
          goto LABEL_66;
        v32 = v6 + 1;
        if (v6 + 1 < v30)
          goto LABEL_66;
        v33 = v29 + v30 - 1;
        v34 = v30 > v6;
        v35 = v30 > v6;
        if (v30 >= v6)
          v30 = v6;
        if (!v34)
          v33 = v29;
        if (v32 > v33 + v30)
          v29 = v32 - v30;
        else
          v29 = v33;
        v36 = v32 > v33 + v30 || v35;
      }
      else
      {
        v29 = 1;
        v30 = v6;
        v36 = 1;
      }
      v37 = *a2 + 1;
      v38 = **a2;
      *a2 = v37;
      v39 = (unint64_t)a2[3];
      if ((uint64_t *)(v39 & v38) != a2[2])
      {
        v50 = __si_assert_copy_extra_268();
        v51 = v50;
        v52 = "";
        if (v50)
          v52 = v50;
        __message_assert("%s:%u: failed assertion '%s' %s ", "SIValueSetInternals.h", 172, "(key & fMask) == fPfx", v52);
LABEL_101:
        free(v51);
        if (__valid_fs(-1))
        {
          MEMORY[0xBAD] = -559038737;
          abort();
        }
        MEMORY[0xC00] = -559038737;
        abort();
      }
      if ((v38 & ~v39) != v6)
      {
        v53 = __si_assert_copy_extra_268();
        v54 = v53;
        v55 = "";
        if (v53)
          v55 = v53;
        __message_assert("%s:%u: failed assertion '%s' %s ", "SIValueSetInternals.h", 761, "v==key", v55);
        goto LABEL_106;
      }
      if (v36)
      {
        ++v13;
      }
      else if (v12)
      {
        v40 = v9;
        SIValueSet<unsigned long long>::SIValueSetInsert(*(unint64_t **)(v12 + 8), *(_QWORD *)v12 | v6);
        v9 = v40;
        v12 = a3;
        v37 = *a2;
      }
      if (v37 < a2[1])
      {
        v41 = *v37;
        v42 = (unint64_t)a2[3];
        if ((uint64_t *)(v42 & v41) == a2[2])
        {
          v6 = v41 & ~v42;
          ++v23;
          ++v20;
          if ((unint64_t)v26 < v9)
            goto LABEL_40;
          continue;
        }
      }
      break;
    }
    v31 = 0;
    ++v20;
LABEL_66:
    if ((unint64_t)v26 < v9)
    {
      v24 = *v26;
      goto LABEL_68;
    }
LABEL_82:
    v24 = v30;
    v25 = v29;
LABEL_83:
    v46 = v25 - 1;
    if (v25 == 1)
    {
      v47 = v69;
      v48 = v70;
      if (v70 >= v26)
      {
        if (v9 + 16 > v69)
          goto LABEL_123;
        v11 = (unint64_t *)(v69 - (v9 - (_QWORD)v26));
        if ((unint64_t *)v9 != v26)
        {
          v49 = (void *)(v69 - (v9 - (_QWORD)v26));
          memmove(v49, v26, v9 - (_QWORD)v26);
          v11 = (unint64_t *)v49;
          v47 = v69;
          v48 = v70;
          v12 = a3;
        }
        v9 = v47;
      }
      else
      {
        v11 = v26;
      }
      *v48 = v24;
      v22 = v48 + 1;
      if (v31)
        goto LABEL_27;
      goto LABEL_97;
    }
    v47 = v69;
    v22 = v70;
    if (v25)
    {
      if (v70 + 1 < v26)
      {
        v11 = v26;
        goto LABEL_26;
      }
      if (v9 + 16 <= v69)
      {
        v11 = (unint64_t *)(v69 - (v9 - (_QWORD)v26));
        if ((unint64_t *)v9 != v26)
        {
          v68 = (void *)(v69 - (v9 - (_QWORD)v26));
          memmove(v68, v26, v9 - (_QWORD)v26);
          v11 = (unint64_t *)v68;
          v47 = v69;
          v22 = v70;
          v12 = a3;
        }
        v9 = v47;
LABEL_26:
        *v22 = v24;
        v22[1] = v46 | 0x8000000000000000;
        v22 = v70 + 2;
        if (v31)
        {
LABEL_27:
          if ((unint64_t)v22 + v9 - (_QWORD)v11 + 16 > v47)
            goto LABEL_112;
          continue;
        }
LABEL_97:
        v26 = v11;
LABEL_116:
        v11 = v26;
        if (v20 == v23)
          goto LABEL_117;
        v61 = __si_assert_copy_extra_268();
        v54 = v61;
        v62 = "";
        if (v61)
          v62 = v61;
        __message_assert("%s:%u: failed assertion '%s' %s ", "SIValueSetInternals.h", 811, "popped==peeked", v62);
LABEL_106:
        free(v54);
        if (__valid_fs(-1))
LABEL_107:
          v56 = 2989;
        else
          v56 = 3072;
        *(_DWORD *)v56 = -559038737;
        abort();
      }
LABEL_123:
      v63 = __si_assert_copy_extra_268();
      v64 = v63;
      if (v63)
        v65 = v63;
      else
        v65 = "";
      __message_assert("%s:%u: Unexpected code path %s ", "SIValueSetInternals.h", 626, v65);
      free(v64);
      goto LABEL_107;
    }
    break;
  }
  v11 = v26;
  if (!v31)
    goto LABEL_116;
LABEL_112:
  if (v20 >= v23)
  {
    v57 = __si_assert_copy_extra_268();
    v51 = v57;
    v58 = "";
    if (v57)
      v58 = v57;
    __message_assert("%s:%u: failed assertion '%s' %s ", "SIValueSetInternals.h", 810, "popped<peeked", v58);
    goto LABEL_101;
  }
LABEL_117:
  v59 = v9 - (_QWORD)v11;
  v60 = v22;
  if (v9 > (unint64_t)v11)
  {
    memmove(v22, v11, v9 - (_QWORD)v11);
    v60 = (unint64_t *)((char *)v60 + v59);
  }
  *(_QWORD *)(v66 + 8) = ((uint64_t)v60 - v67) >> 3;
  return v13;
}

uint64_t SIValueSet<unsigned long long>::RLEKeyHolder<unsigned long long>::ContainsKey(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3;
  unint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t v12;
  BOOL v13;
  BOOL v14;
  unint64_t v15;
  uint64_t result;
  unint64_t *v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  BOOL v21;
  BOOL v22;

  v3 = a2 & a3 & 0x7FFFFFFFFFFFFFFFLL;
  v4 = (unint64_t *)(a1 + 16);
  v5 = *(_QWORD *)(a1 + 8);
  v6 = 8 * v5;
  v7 = a1 + 16 + 8 * v5;
  if (v5 >= 1 && (unint64_t)v6 >= 0x18)
  {
    v9 = a1 + 16 + 8 * v5;
    do
    {
      v10 = &v4[v6 >> 4];
      v11 = *v10;
      if ((*v10 & 0x8000000000000000) != 0)
      {
        v12 = *--v10;
        v11 = v12;
      }
      if (v10 <= v4)
        break;
      if (v11 == v3)
      {
        v4 = v10;
        if ((unint64_t)v10 < v7)
          goto LABEL_19;
        return 0;
      }
      if (v11 > v3)
        v9 = (unint64_t)v10;
      else
        v4 = v10;
      v6 = v9 - (_QWORD)v4;
      if (v9 > (unint64_t)v4)
      {
        v13 = (unint64_t)v6 >= 0x17;
        v14 = v6 == 23;
      }
      else
      {
        v13 = 0;
        v14 = 0;
      }
    }
    while (!v14 && v13);
  }
  if ((unint64_t)v4 >= v7)
    return 0;
LABEL_19:
  v15 = *v4;
  if (*v4 != v3)
  {
    v17 = v4 + 1;
    do
    {
      if ((v15 & 0x8000000000000000) != 0)
      {
        v19 = *(v17 - 2);
        v20 = v19 + (v15 & 0x7FFFFFFFFFFFFFFFLL);
        if (v3 >= v19)
        {
          v21 = v3 >= v20;
          v22 = v3 == v20;
        }
        else
        {
          v21 = 1;
          v22 = 0;
        }
        if (v22 || !v21)
          return 1;
        if ((unint64_t)v17 >= v7)
          return 0;
      }
      else
      {
        result = 0;
        if (v15 > v3 || (unint64_t)v17 >= v7)
          return result;
      }
      v18 = *v17++;
      v15 = v18;
    }
    while (v18 != v3);
  }
  return 1;
}

uint64_t SIValueSet<unsigned long long>::RLEKeyHolder<unsigned long long>::CloseKey(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t *v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v18;
  unint64_t v19;

  v3 = *(_QWORD *)(a1 + 8);
  if (!v3)
    return 0;
  v4 = a2 & a3 & 0x7FFFFFFFFFFFFFFFLL;
  v5 = (unint64_t *)(a1 + 16);
  v6 = 8 * v3;
  v7 = a1 + 16 + 8 * v3;
  if (v3 >= 1 && (unint64_t)v6 >= 0x18)
  {
    v9 = a1 + 16 + 8 * v3;
    do
    {
      v10 = &v5[v6 >> 4];
      v11 = *v10;
      if ((*v10 & 0x8000000000000000) != 0)
      {
        v12 = *--v10;
        v11 = v12;
      }
      if (v10 <= v5)
        break;
      if (v11 == v4)
      {
        v5 = v10;
        if ((unint64_t)v10 < v7)
          goto LABEL_20;
        goto LABEL_34;
      }
      if (v11 > v4)
        v9 = (unint64_t)v10;
      else
        v5 = v10;
      v6 = v9 - (_QWORD)v5;
    }
    while (v9 > (unint64_t)v5 && (unint64_t)v6 > 0x17);
  }
  if ((unint64_t)v5 >= v7)
  {
LABEL_34:
    v18 = *(_QWORD *)(a1 + 8 * v3 + 8);
    if ((v18 & 0x8000000000000000) != 0)
      return *(_QWORD *)(a1 + 8 * v3) + (v18 & 0x7FFFFFFFFFFFFFFFLL);
    else
      return v18;
  }
  else
  {
LABEL_20:
    v14 = v5;
    while (1)
    {
      v19 = *v14++;
      v18 = v19;
      if (v19 == v4)
        return a2 & a3 & 0x7FFFFFFFFFFFFFFFLL;
      if ((v18 & 0x8000000000000000) != 0)
      {
        v15 = *(v5 - 1);
        v16 = v15 + (v18 & 0x7FFFFFFFFFFFFFFFLL);
        if (v4 >= v15 && v4 <= v16)
          return a2 & a3 & 0x7FFFFFFFFFFFFFFFLL;
      }
      else if (v18 > v4)
      {
        return v18;
      }
      v5 = v14;
      if ((unint64_t)v14 >= v7)
        goto LABEL_34;
    }
  }
}

uint64_t SIValueSet<unsigned long long>::RLEKeyHolder<unsigned long long>::RemoveKey(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t *v10;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  size_t v19;
  unint64_t *v20;
  unint64_t v21;
  uint64_t result;
  unint64_t v23;
  unint64_t v24;
  uint64_t v26;
  unint64_t *v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  void *v33;
  unint64_t v34;
  uint64_t v35;
  unint64_t v36;
  char *v37;
  char *v38;
  const char *v39;

  v4 = a2 & a3 & 0x7FFFFFFFFFFFFFFFLL;
  v5 = a1 + 16;
  v6 = *(_QWORD *)(a1 + 8);
  v7 = 8 * v6;
  v8 = a1 + 16 + 8 * v6;
  if (v6 >= 1 && (unint64_t)v7 >= 0x18)
  {
    v11 = a1 + 16 + 8 * v6;
    v10 = (unint64_t *)(a1 + 16);
    do
    {
      v12 = &v10[v7 >> 4];
      v13 = *v12;
      if ((*v12 & 0x8000000000000000) != 0)
      {
        v14 = *--v12;
        v13 = v14;
      }
      if (v12 <= v10)
        break;
      if (v13 == v4)
      {
        v10 = v12;
        if ((unint64_t)v12 >= v8)
          return 0;
        goto LABEL_20;
      }
      if (v13 > v4)
        v11 = (unint64_t)v12;
      else
        v10 = v12;
      v7 = v11 - (_QWORD)v10;
    }
    while (v11 > (unint64_t)v10 && (unint64_t)v7 > 0x17);
    if ((unint64_t)v10 >= v8)
      return 0;
  }
  else
  {
    v10 = (unint64_t *)(a1 + 16);
    if (v5 >= v8)
      return 0;
  }
LABEL_20:
  v17 = v10 + 1;
  v16 = *v10;
  if (*v10 == v4)
  {
    if ((unint64_t)v17 < v8)
    {
LABEL_22:
      v18 = *v17;
      if ((*v17 & 0x8000000000000000) == 0)
      {
        v19 = v8 - (_QWORD)v17;
        v20 = v17;
LABEL_42:
        memmove(v10, v20, v19);
        v26 = *(_QWORD *)(a1 + 8) - 1;
        goto LABEL_43;
      }
      *v10 = v4 + 1;
      if ((v18 & 0x7FFFFFFFFFFFFFFFLL) == 1)
      {
        v20 = v10 + 2;
        v19 = v8 - (_QWORD)(v10 + 2);
        v10 = v17;
        goto LABEL_42;
      }
      v28 = (v18 - 1) | 0x8000000000000000;
LABEL_51:
      *v17 = v28;
      return 1;
    }
LABEL_39:
    *(_QWORD *)(a1 + 8) = v6 - 1;
    return 1;
  }
  while (1)
  {
    if ((v16 & 0x8000000000000000) == 0)
    {
      result = 0;
      if (v16 > v4 || (unint64_t)v17 >= v8)
        return result;
      goto LABEL_24;
    }
    v23 = *(v17 - 2);
    v24 = v23 + (v16 & 0x7FFFFFFFFFFFFFFFLL);
    if (v4 > v23 && v4 <= v24)
      break;
    if ((unint64_t)v17 >= v8)
      return 0;
LABEL_24:
    v21 = *v17++;
    v16 = v21;
    if (v21 == v4)
    {
      v10 = v17 - 1;
      if ((unint64_t)v17 < v8)
        goto LABEL_22;
      goto LABEL_39;
    }
  }
  v27 = v17 - 1;
  if ((v16 & 0x7FFFFFFFFFFFFFFFLL) != 1)
  {
    if (v4 == v24)
    {
      *v27 = (v16 - 1) | 0x8000000000000000;
      return 1;
    }
    if (v4 == v23 + 1)
    {
      *v27 = v4 + 1;
      v29 = v24 + ~v4;
      if (!v29)
        return 1;
      v30 = *(_QWORD *)(a1 + 8);
      if (v30 < 0x3F)
      {
        v31 = (uint64_t)((uint64_t)v17 - v5) >> 3;
        if (v30 != v31)
        {
          v32 = v30 - v31;
          v33 = v17 + 1;
LABEL_66:
          memmove(v33, v17, 8 * v32);
          v31 = *(_QWORD *)(a1 + 8);
          goto LABEL_67;
        }
        goto LABEL_67;
      }
    }
    else
    {
      *(v17 - 1) = (v4 + ~v23) | 0x8000000000000000;
      v34 = *(_QWORD *)(a1 + 8);
      if (v34 < 0x3F)
      {
        v35 = (uint64_t)((uint64_t)v17 - v5) >> 3;
        if (v34 != v35)
        {
          memmove(v17 + 1, v17, 8 * (v34 - v35));
          v35 = *(_QWORD *)(a1 + 8);
        }
        *(_QWORD *)(a1 + 8) = v35 + 1;
        *v17 = v4 + 1;
        v29 = v24 + ~v4;
        if (!v29)
          return 1;
        v36 = *(_QWORD *)(a1 + 8);
        if (v36 < 0x3F)
        {
          ++v17;
          v31 = (uint64_t)((uint64_t)v27 - v5 + 16) >> 3;
          if (v36 != v31)
          {
            v32 = v36 - v31;
            v33 = v27 + 3;
            goto LABEL_66;
          }
LABEL_67:
          *(_QWORD *)(a1 + 8) = v31 + 1;
          v28 = v29 | 0x8000000000000000;
          goto LABEL_51;
        }
      }
    }
    v37 = __si_assert_copy_extra_268();
    v38 = v37;
    if (v37)
      v39 = v37;
    else
      v39 = "";
    __message_assert("%s:%u: Unexpected code path %s ", "SIValueSetInternals.h", 649, v39);
    free(v38);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  if ((unint64_t)v17 < v8)
  {
    memmove(v17 - 1, v17, v8 - (_QWORD)v17);
    v6 = *(_QWORD *)(a1 + 8);
  }
  v26 = v6 - 1;
LABEL_43:
  *(_QWORD *)(a1 + 8) = v26;
  return 1;
}

void SIValueSet<unsigned long long>::RLEKeyHolder<unsigned long long>::Apply(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(char *, uint64_t, uint64_t), uint64_t a5)
{
  uint64_t v9;
  size_t v10;
  char *v11;
  unint64_t v12;
  uint64_t *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  _QWORD v19[2];

  v19[1] = *MEMORY[0x1E0C80C00];
  v9 = MEMORY[0x1E0C80A78](a1);
  v11 = (char *)v19 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = *(_QWORD *)(v9 + 8);
  if (v12 > 0x3F)
    return;
  v13 = (uint64_t *)(v9 + 16);
  v14 = v9 + 16 + 8 * v12;
  bzero((char *)v19 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0), v10);
  v15 = 0;
  v16 = 0;
LABEL_3:
  v17 = 0;
  while (v16)
  {
    --v16;
    ++v15;
LABEL_15:
    *(_QWORD *)&v11[8 * v17++] = v15 | a3;
    if (v17 == a2)
    {
      a4(v11, a2, a5);
      goto LABEL_3;
    }
  }
  if ((unint64_t)v13 < v14)
  {
    v18 = v13 + 1;
    v15 = *v13;
    if ((unint64_t)(v13 + 1) >= v14)
    {
      v16 = 0;
      ++v13;
    }
    else
    {
      if (*v18 < 0)
        v13 += 2;
      else
        ++v13;
      if (*v18 < 0)
        v16 = *v18 & 0x7FFFFFFFFFFFFFFFLL;
      else
        v16 = 0;
    }
    goto LABEL_15;
  }
  if (v17)
    a4(v11, v17, a5);
}

BOOL SIValueSet<unsigned long long>::RLEKeyHolder<unsigned long long>::IsEmpty(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8) == 0;
}

uint64_t SIValueSet<unsigned long long>::RLEKeyHolder<unsigned long long>::GetRawCount(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t SIValueSet<unsigned long long>::RLEKeyHolder<unsigned long long>::Serialize(uint64_t a1, uint64_t a2)
{
  (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 8))(a2, 8);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 8))(a2, *(unsigned int *)(a1 + 8));
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 16))(a2, a1 + 16, 8 * *(_QWORD *)(a1 + 8));
}

void SIValueSet<unsigned long long>::RLEKeyHolder<unsigned long long>::~RLEKeyHolder()
{
  JUMPOUT(0x1BCCB06A4);
}

_QWORD *SIValueSet<unsigned long long>::RLEKeyHolder<unsigned long long>::valueIterator(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  *a3 = off_1E6E2A7F0;
  a3[1] = a1 + 16;
  a3[2] = a1 + 16 + 8 * v3;
  a3[3] = 0;
  a3[4] = 0;
  a3[5] = a2;
  return a3;
}

uint64_t SIValueSet<unsigned long long>::RLEKeyHolder<unsigned long long>::RLEKeyIterator::nextKey(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t *v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v2 = a1[4];
  v1 = a1[5];
  if (v2)
  {
    v3 = v2 - 1;
    v4 = a1[3] + 1;
    a1[3] = v4;
    a1[4] = v3;
    return v4 | v1;
  }
  else
  {
    v6 = (uint64_t *)a1[1];
    v7 = a1[2];
    v8 = *v6;
    a1[1] = v6 + 1;
    a1[3] = v8;
    if ((unint64_t)(v6 + 1) < v7 && (v9 = v6[1], v9 < 0))
    {
      a1[1] = v6 + 2;
      a1[4] = v9 & 0x7FFFFFFFFFFFFFFFLL;
      return v8 | v1;
    }
    else
    {
      return v8 | v1;
    }
  }
}

BOOL SIValueSet<unsigned long long>::RLEKeyHolder<unsigned long long>::RLEKeyIterator::hasMore(_QWORD *a1)
{
  return a1[4] || a1[1] < a1[2];
}

void SIValueSet<unsigned long long>::RLEKeyHolder<unsigned long long>::RLEKeyIterator::~RLEKeyIterator()
{
  JUMPOUT(0x1BCCB06A4);
}

uint64_t SIUINT64SetRemoveValue(uint64_t result, unint64_t a2)
{
  int v2;

  if (!*(_BYTE *)(result + 184))
  {
    v2 = *(_DWORD *)(result + 24);
    if (!v2 || *(_QWORD *)(result + 16) == ((-1 << (-4 * v2)) & a2))
      return SIValueSet<unsigned long long>::_SIValueSetInnerRemove(result + 56, a2, v2, result + 32);
  }
  return result;
}

uint64_t SIValueSet<unsigned long long>::_SIValueSetInnerRemove(unint64_t a1, unint64_t a2, int a3, uint64_t a4)
{
  int v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;

  v5 = a3;
  v6 = (a2 >> ((60 - 4 * a3) & 0xFC)) & 0xF;
  v7 = *(_QWORD *)(a1 + 8 * v6);
  if ((v7 & 1) != 0)
  {
    do
    {
      v8 = v7 & 0xFFFFFFFFFFFFFFFELL;
      v6 = (a2 >> ((56 - 4 * v5) & 0xFC)) & 0xF;
      v7 = *(_QWORD *)((v7 & 0xFFFFFFFFFFFFFFFELL) + 8 * v6);
      ++v5;
    }
    while ((v7 & 1) != 0);
  }
  else
  {
    v8 = a1;
  }
  if (!v7)
    return 0;
  v9 = (*(uint64_t (**)(unint64_t))(*(_QWORD *)v7 + 32))(v7);
  v10 = (*(uint64_t (**)(unint64_t))(*(_QWORD *)v7 + 56))(v7);
  if (v10 >= 0x3E)
  {
    v11 = SIValueSet<unsigned long long>::_SIValueSetBurstRLE((_QWORD *)v7, v5, a4);
LABEL_10:
    *(_QWORD *)(v8 + 8 * v6) = v11;
    return v9;
  }
  if (!v10)
  {
    (*(void (**)(unint64_t))(*(_QWORD *)v7 + 72))(v7);
    CFAllocatorDeallocate(*(CFAllocatorRef *)(a4 + 16), (void *)v7);
    v11 = 0;
    goto LABEL_10;
  }
  return v9;
}

uint64_t SIUINT64SetIterate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return SIValueSet<unsigned long long>::_SIValueSetInnerIterate(a1 + 56, *(_QWORD *)(a1 + 16), *(_DWORD *)(a1 + 24), a2, a4, a3);
}

void shutdown_runLoop(uint64_t a1, void (*a2)(uint64_t, _QWORD), uint64_t a3)
{
  pthread_t v6;
  NSObject *v7;
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t (*v12)(uint64_t);
  void *v13;
  uint64_t v14;
  pthread_t v15;

  v6 = pthread_self();
  v7 = *(NSObject **)(a1 + 32);
  v8 = MEMORY[0x1E0C809B0];
  v10 = MEMORY[0x1E0C809B0];
  v11 = 0x40000000;
  v12 = __si_scheduler_set_thread_block_invoke;
  v13 = &__block_descriptor_tmp_29_1050;
  v14 = a1;
  v15 = v6;
  dispatch_sync(v7, &v10);
  a2(a3, 0);
  v9 = *(NSObject **)(a1 + 32);
  v10 = v8;
  v11 = 0x40000000;
  v12 = __si_scheduler_set_thread_block_invoke;
  v13 = &__block_descriptor_tmp_29_1050;
  v14 = a1;
  v15 = 0;
  dispatch_sync(v9, &v10);
}

void getattr_runLoop(uint64_t a1, void (*a2)(uint64_t, _QWORD), uint64_t a3)
{
  pthread_t v6;
  NSObject *v7;
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t (*v12)(uint64_t);
  void *v13;
  uint64_t v14;
  pthread_t v15;

  v6 = pthread_self();
  v7 = *(NSObject **)(a1 + 32);
  v8 = MEMORY[0x1E0C809B0];
  v10 = MEMORY[0x1E0C809B0];
  v11 = 0x40000000;
  v12 = __si_scheduler_set_thread_block_invoke;
  v13 = &__block_descriptor_tmp_29_1050;
  v14 = a1;
  v15 = v6;
  dispatch_sync(v7, &v10);
  a2(a3, 0);
  v9 = *(NSObject **)(a1 + 32);
  v10 = v8;
  v11 = 0x40000000;
  v12 = __si_scheduler_set_thread_block_invoke;
  v13 = &__block_descriptor_tmp_29_1050;
  v14 = a1;
  v15 = 0;
  dispatch_sync(v9, &v10);
}

void volume_runLoop(uint64_t a1, void (*a2)(uint64_t, _QWORD), uint64_t a3)
{
  pthread_t v6;
  NSObject *v7;
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t (*v12)(uint64_t);
  void *v13;
  uint64_t v14;
  pthread_t v15;

  v6 = pthread_self();
  v7 = *(NSObject **)(a1 + 32);
  v8 = MEMORY[0x1E0C809B0];
  v10 = MEMORY[0x1E0C809B0];
  v11 = 0x40000000;
  v12 = __si_scheduler_set_thread_block_invoke;
  v13 = &__block_descriptor_tmp_29_1050;
  v14 = a1;
  v15 = v6;
  dispatch_sync(v7, &v10);
  a2(a3, 0);
  v9 = *(NSObject **)(a1 + 32);
  v10 = v8;
  v11 = 0x40000000;
  v12 = __si_scheduler_set_thread_block_invoke;
  v13 = &__block_descriptor_tmp_29_1050;
  v14 = a1;
  v15 = 0;
  dispatch_sync(v9, &v10);
}

void utility_query_runLoop(uint64_t a1, void (*a2)(uint64_t, _QWORD), uint64_t a3)
{
  pthread_t v6;
  NSObject *v7;
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t (*v12)(uint64_t);
  void *v13;
  uint64_t v14;
  pthread_t v15;

  v6 = pthread_self();
  v7 = *(NSObject **)(a1 + 32);
  v8 = MEMORY[0x1E0C809B0];
  v10 = MEMORY[0x1E0C809B0];
  v11 = 0x40000000;
  v12 = __si_scheduler_set_thread_block_invoke;
  v13 = &__block_descriptor_tmp_29_1050;
  v14 = a1;
  v15 = v6;
  dispatch_sync(v7, &v10);
  a2(a3, 0);
  v9 = *(NSObject **)(a1 + 32);
  v10 = v8;
  v11 = 0x40000000;
  v12 = __si_scheduler_set_thread_block_invoke;
  v13 = &__block_descriptor_tmp_29_1050;
  v14 = a1;
  v15 = 0;
  dispatch_sync(v9, &v10);
}

void compaction_runLoop(uint64_t a1, void (*a2)(uint64_t, _QWORD), uint64_t a3)
{
  pthread_t v6;
  NSObject *v7;
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t (*v12)(uint64_t);
  void *v13;
  uint64_t v14;
  pthread_t v15;

  v6 = pthread_self();
  v7 = *(NSObject **)(a1 + 32);
  v8 = MEMORY[0x1E0C809B0];
  v10 = MEMORY[0x1E0C809B0];
  v11 = 0x40000000;
  v12 = __si_scheduler_set_thread_block_invoke;
  v13 = &__block_descriptor_tmp_29_1050;
  v14 = a1;
  v15 = v6;
  dispatch_sync(v7, &v10);
  a2(a3, 0);
  v9 = *(NSObject **)(a1 + 32);
  v10 = v8;
  v11 = 0x40000000;
  v12 = __si_scheduler_set_thread_block_invoke;
  v13 = &__block_descriptor_tmp_29_1050;
  v14 = a1;
  v15 = 0;
  dispatch_sync(v9, &v10);
}

void initCountsArray_block_invoke(CFMutableArrayRef theArray, uint64_t a2)
{
  uint64_t v2;

  if (theArray)
  {
    v2 = a2;
    if (a2 >= 1)
    {
      if (initCountsArray_block_invoke_onceToken != -1)
        dispatch_once(&initCountsArray_block_invoke_onceToken, &__block_literal_global_460);
      do
      {
        CFArrayAppendValue(theArray, (const void *)initCountsArray_block_invoke_cfZero);
        --v2;
      }
      while (v2);
    }
  }
}

CFNumberRef initCountsArray_block_invoke_2()
{
  CFNumberRef result;

  result = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberLongType, &initCountsArray_block_invoke_zero);
  initCountsArray_block_invoke_cfZero = (uint64_t)result;
  return result;
}

void readFromAllCountsArray_block_invoke_3(const __CFArray *a1, __CFArray *a2, char a3, uint64_t a4)
{
  const __CFNumber *ValueAtIndex;
  CFIndex v9;
  uint8x8_t v10;
  CFIndex v11;
  CFIndex v12;
  const void *v13;
  unint64_t valuePtr;

  if (a1)
  {
    if (CFArrayGetCount(a1))
    {
      valuePtr = 0;
      ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(a1, 0);
      CFNumberGetValue(ValueAtIndex, kCFNumberSInt64Type, &valuePtr);
      if (a4 >= 1)
      {
        v9 = 0;
        v10 = (uint8x8_t)vcnt_s8((int8x8_t)(valuePtr & ~(-1 << a3)));
        v10.i16[0] = vaddlv_u8(v10);
        v11 = v10.u32[0] + 1;
        do
        {
          if (((valuePtr >> (a3 + v9)) & 1) != 0)
          {
            v12 = v11 + 1;
            v13 = CFArrayGetValueAtIndex(a1, v11);
            CFArraySetValueAtIndex(a2, v9, v13);
            v11 = v12;
          }
          ++v9;
        }
        while (a4 != v9);
      }
    }
  }
}

BOOL _journalPlaybackMatchAddress(uint64_t a1, char *a2)
{
  uint64_t *v2;

  return a1 && (v2 = *(uint64_t **)(a1 + 8)) != 0 && _journalMatchAddress(v2, a2);
}

void _journalPlaybackSuspend(uint64_t a1)
{
  if (a1)
  {
    if (*(_QWORD *)a1)
      si_indexingWatchdogSuspend(*(_QWORD *)(*(_QWORD *)a1 + 64));
  }
}

void _journalPlaybackResume(uint64_t a1)
{
  if (a1)
  {
    if (*(_QWORD *)a1)
      si_indexingWatchdogResume(*(_QWORD *)(*(_QWORD *)a1 + 64));
  }
}

BOOL _journalMatchAddress(uint64_t *a1, char *a2)
{
  unint64_t v2;
  unint64_t v3;
  _BOOL8 v6;
  char *v9;
  int v10;
  NSObject *v11;
  os_log_type_t v12;
  int v13;
  int v14;
  NSObject *v15;
  BOOL v16;
  _BOOL4 v17;
  const char *v18;
  NSObject *v19;
  os_log_type_t v20;
  uint32_t v21;
  stat v23;
  uint8_t buf[4];
  char *v25;
  __int16 v26;
  unint64_t v27;
  __int16 v28;
  off_t st_size;
  __int16 v30;
  char *v31;
  char v32[1024];
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v2 = a1[2];
  v3 = v2 + a1[3];
  v6 = v2 != -1 && v2 <= (unint64_t)a2 && v3 > (unint64_t)a2;
  if (v6)
  {
    bzero(v32, 0x400uLL);
    v9 = fd_name(a1[1], v32, 0x400uLL);
    memset(&v23, 0, sizeof(v23));
    v10 = *__error();
    v11 = _SILogForLogForCategory(10);
    v12 = dword_1EF19FCB4 < 3;
    if (os_log_type_enabled(v11, (os_log_type_t)(dword_1EF19FCB4 < 3)))
    {
      *(_DWORD *)buf = 134218754;
      v25 = a2;
      v26 = 2048;
      v27 = v2;
      v28 = 2048;
      st_size = v3;
      v30 = 2080;
      v31 = v9;
      _os_log_impl(&dword_1B8270000, v11, v12, "*warn* Got a journal exception at address:%p, map:[%p, %p), name: %s.", buf, 0x2Au);
    }
    *__error() = v10;
    v13 = fd_stat(a1[1], &v23);
    v14 = *__error();
    v15 = _SILogForLogForCategory(10);
    v16 = dword_1EF19FCB4 < 3;
    v17 = os_log_type_enabled(v15, (os_log_type_t)(dword_1EF19FCB4 < 3));
    if (v13)
    {
      if (v17)
      {
        *(_DWORD *)buf = 136315138;
        v25 = v9;
        v18 = "*warn* Stat failed for name: %s.";
        v19 = v15;
        v20 = v16;
        v21 = 12;
LABEL_18:
        _os_log_impl(&dword_1B8270000, v19, v20, v18, buf, v21);
      }
    }
    else if (v17)
    {
      *(_DWORD *)buf = 134218496;
      v25 = (char *)v2;
      v26 = 2048;
      v27 = v3;
      v28 = 2048;
      st_size = v23.st_size;
      v18 = "*warn* map:[%p, %p), size: %llx";
      v19 = v15;
      v20 = v16;
      v21 = 32;
      goto LABEL_18;
    }
    *__error() = v14;
    fd_assert_not_unlinked(a1[1]);
  }
  return v6;
}

BOOL _journalCtxMatchAddress(uint64_t a1, char *a2)
{
  uint64_t *v2;

  return a1 && (v2 = *(uint64_t **)(a1 + 8)) != 0 && _journalMatchAddress(v2, a2);
}

void _journalCtxSuspend(uint64_t a1)
{
  if (a1)
  {
    if (*(_QWORD *)a1)
      si_indexingWatchdogSuspend(*(_QWORD *)(*(_QWORD *)a1 + 64));
  }
}

void _journalCtxResume(uint64_t a1)
{
  if (a1)
  {
    if (*(_QWORD *)a1)
      si_indexingWatchdogResume(*(_QWORD *)(*(_QWORD *)a1 + 64));
  }
}

void si_routine_mail(_BYTE *a1)
{
  (*(void (**)(_QWORD))a1)(*((_QWORD *)a1 + 1));
  if (a1[16])
    free(a1);
}

void si_routine_messages(_BYTE *a1)
{
  (*(void (**)(_QWORD))a1)(*((_QWORD *)a1 + 1));
  if (a1[16])
    free(a1);
}

void si_routine_calendar(_BYTE *a1)
{
  (*(void (**)(_QWORD))a1)(*((_QWORD *)a1 + 1));
  if (a1[16])
    free(a1);
}

void si_routine_fileProvider(_BYTE *a1)
{
  (*(void (**)(_QWORD))a1)(*((_QWORD *)a1 + 1));
  if (a1[16])
    free(a1);
}

void si_routine_localFileProvider(_BYTE *a1)
{
  (*(void (**)(_QWORD))a1)(*((_QWORD *)a1 + 1));
  if (a1[16])
    free(a1);
}

void si_routine_notes(_BYTE *a1)
{
  (*(void (**)(_QWORD))a1)(*((_QWORD *)a1 + 1));
  if (a1[16])
    free(a1);
}

void si_routine_photos(_BYTE *a1)
{
  (*(void (**)(_QWORD))a1)(*((_QWORD *)a1 + 1));
  if (a1[16])
    free(a1);
}

void si_routine_pommesctl(_BYTE *a1)
{
  (*(void (**)(_QWORD))a1)(*((_QWORD *)a1 + 1));
  if (a1[16])
    free(a1);
}

void si_routine_thirdParty(_BYTE *a1)
{
  (*(void (**)(_QWORD))a1)(*((_QWORD *)a1 + 1));
  if (a1[16])
    free(a1);
}

void si_routine_priority(_BYTE *a1)
{
  (*(void (**)(_QWORD))a1)(*((_QWORD *)a1 + 1));
  if (a1[16])
    free(a1);
}

void si_routine_protectionClassA(_BYTE *a1)
{
  (*(void (**)(_QWORD))a1)(*((_QWORD *)a1 + 1));
  if (a1[16])
    free(a1);
}

void si_routine_protectionClassCX(_BYTE *a1)
{
  (*(void (**)(_QWORD))a1)(*((_QWORD *)a1 + 1));
  if (a1[16])
    free(a1);
}

uint64_t si_get_contentindex_for_id(uint64_t a1, int a2)
{
  uint64_t **v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t **v6;
  uint64_t v7;
  uint64_t *i;

  v2 = *(uint64_t ***)(a1 + 1384);
  v3 = *((unsigned int *)v2 + 2);
  if ((_DWORD)v3)
  {
    v4 = *v2;
    while (1)
    {
      v5 = *v4;
      if (*(_DWORD *)(*v4 + 48) == a2)
        break;
      ++v4;
      if (!--v3)
        goto LABEL_5;
    }
  }
  else
  {
LABEL_5:
    v6 = *(uint64_t ***)(a1 + 1392);
    v7 = *((unsigned int *)v6 + 2);
    if ((_DWORD)v7)
    {
      for (i = *v6; ; ++i)
      {
        v5 = *i;
        if (*(_DWORD *)(*i + 48) == a2)
          break;
        if (!--v7)
          return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  return v5;
}

uint64_t si_storecookieRef(uint64_t a1)
{
  _DWORD *indexmetadata;
  int field;
  const __CFAllocator *v4;
  const __CFUUID *v5;
  __n128 v6;
  int v7;
  NSObject *v8;
  os_log_type_t v9;
  const __CFUUID *v10;
  const __CFUUID *v11;
  uint8_t buf[8];
  unint64_t v14;
  CFUUIDBytes *v15;
  _DWORD *v16;

  if (!*(_QWORD *)(a1 + 1440))
  {
    if (*(_QWORD *)(a1 + 1184))
    {
      indexmetadata = si_create_indexmetadata(a1, 1);
      v16 = indexmetadata;
      if (indexmetadata)
      {
        v14 = 0;
        v15 = 0;
        field = db_get_field(*(int **)(a1 + 1184), (uint64_t)indexmetadata, "kMDStoreUUID", &v14, &v15);
        v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        if (field)
        {
          v5 = CFUUIDCreate(v4);
          *(_QWORD *)(a1 + 1440) = v5;
          *(CFUUIDBytes *)(a1 + 1424) = CFUUIDGetUUIDBytes(v5);
          db_add_field(*(int **)(a1 + 1184), &v16, 1u, "kMDStoreUUID", 0, 0x108u, 14, (unsigned __int8 *)(a1 + 1424), v6, 16);
          indexmetadata = v16;
          if (db_update_obj(*(int **)(a1 + 1184), (uint64_t)v16, 12))
          {
            v7 = *__error();
            v8 = _SILogForLogForCategory(7);
            v9 = dword_1EF19FCA8 < 3;
            if (os_log_type_enabled(v8, (os_log_type_t)(dword_1EF19FCA8 < 3)))
            {
              *(_WORD *)buf = 0;
              _os_log_impl(&dword_1B8270000, v8, v9, "*warn* Failed getting store cookie", buf, 2u);
            }
            *__error() = v7;
          }
        }
        else
        {
          v11 = CFUUIDCreateFromUUIDBytes(v4, *v15);
          *(_QWORD *)(a1 + 1440) = v11;
          *(CFUUIDBytes *)(a1 + 1424) = CFUUIDGetUUIDBytes(v11);
        }
      }
      free(indexmetadata);
    }
    else
    {
      v10 = CFUUIDCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00]);
      *(_QWORD *)(a1 + 1440) = v10;
      *(CFUUIDBytes *)(a1 + 1424) = CFUUIDGetUUIDBytes(v10);
    }
  }
  return *(_QWORD *)(a1 + 1440);
}

void si_power_info_init(uint64_t a1, xpc_object_t object, uint64_t a3, NSObject *a4)
{
  xpc_object_t v6;

  *(_DWORD *)a1 = 0;
  *(_QWORD *)(a1 + 16) = a3;
  if (object)
    v6 = xpc_retain(object);
  else
    v6 = 0;
  *(_QWORD *)(a1 + 8) = v6;
  if (a4)
  {
    *(_QWORD *)(a1 + 24) = a4;
    dispatch_retain(a4);
    dispatch_group_enter(*(dispatch_group_t *)(a1 + 24));
  }
  else
  {
    *(_QWORD *)(a1 + 24) = 0;
  }
}

uint64_t si_power_info_assert_power(uint64_t result, uint64_t a2)
{
  _DWORD *v2;
  uint64_t v3;
  uint64_t (*v4)(_QWORD, const char *);

  if (!*(_QWORD *)(result + 24))
  {
    v2 = (_DWORD *)result;
    if (!*(_DWORD *)result)
    {
      v3 = *(_QWORD *)(a2 + 2360);
      if (v3)
      {
        v4 = *(uint64_t (**)(_QWORD, const char *))(v3 + 64);
        if (v4)
        {
          result = v4(*(_QWORD *)(v3 + 136), "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SIStoring.c");
          *v2 = result;
        }
      }
    }
  }
  return result;
}

BOOL lowDiskSpaceCallback(uint64_t a1)
{
  int v2;

  pthread_mutex_lock(&mergeMutex);
  v2 = *(unsigned __int8 *)(a1 + 2435);
  if (*(_BYTE *)(a1 + 2435))
  {
    ++*(_DWORD *)(a1 + 2428);
    do
      pthread_cond_wait(&mergeCond, &mergeMutex);
    while (*(_BYTE *)(a1 + 2435));
    --*(_DWORD *)(a1 + 2428);
  }
  pthread_mutex_unlock(&mergeMutex);
  return v2 != 0;
}

uint64_t __syncIndex_block_invoke(uint64_t a1, uint64_t a2)
{
  char v2;
  uint64_t v5;
  _QWORD *v6;

  v2 = atomic_load((unsigned int *)(a2 + 28));
  if ((v2 & 2) == 0 && !*(_BYTE *)(a2 + 15163) && (*(_BYTE *)(a2 + 15160) & 6) == 2)
  {
    v5 = *(_QWORD *)(a1 + 32);
    if (!*(_BYTE *)(v5 + 6944) && *(int *)(v5 + 6960) <= 0)
    {
      v6 = malloc_type_calloc(1uLL, 0x60uLL, 0x10B0040E0DE4348uLL);
      *v6 = *(_QWORD *)(a1 + 32);
      v6[1] = a2;
      *((_DWORD *)v6 + 5) = *(_DWORD *)(a2 + 48);
      si_forceSplitIndex();
    }
  }
  return 1;
}

uint64_t ContentIndexListsApply(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;

  if (result && (v5 = result, *(_DWORD *)(result + 8)))
  {
    v6 = 0;
    while (1)
    {
      result = (*(uint64_t (**)(uint64_t, _QWORD, _QWORD))(a3 + 16))(a3, *(_QWORD *)(*(_QWORD *)v5 + 8 * v6), 0);
      if (!(_DWORD)result)
        break;
      if (++v6 >= (unint64_t)*(unsigned int *)(v5 + 8))
        goto LABEL_6;
    }
  }
  else
  {
LABEL_6:
    if (a2 && *(_DWORD *)(a2 + 8))
    {
      v7 = 0;
      do
      {
        result = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(a3 + 16))(a3, *(_QWORD *)(*(_QWORD *)a2 + 8 * v7), 1);
        if (!(_DWORD)result)
          break;
        ++v7;
      }
      while (v7 < *(unsigned int *)(a2 + 8));
    }
  }
  return result;
}

void si_deleteExhaustedRemappings(uint64_t a1, CFArrayRef theArray)
{
  CFIndex i;
  _QWORD *ValueAtIndex;
  int v6;
  char *v7;
  char __str[1024];
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (theArray)
  {
    for (i = 0; i < CFArrayGetCount(theArray); ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(theArray, i);
      v6 = *(_DWORD *)(a1 + 32);
      bzero(__str, 0x400uLL);
      snprintf(__str, 0x400uLL, "remapping%ld", ValueAtIndex[5]);
      v7 = (char *)fd_create_protected(v6, __str, 0, 3u);
      _fd_unlink_with_origin((uint64_t)v7, 0);
      fd_release(v7);
    }
    CFRelease(theArray);
  }
}

void si_makeUnavailable(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unsigned __int8 *v9;
  unsigned __int8 v10;
  int v12;
  int v13;
  NSObject *v14;
  os_log_type_t v15;
  BOOL v16;
  _BYTE *v17;
  uint64_t i;
  uint64_t v19;
  uint64_t v20;
  void (*v21)(_QWORD, uint64_t, uint64_t, uint64_t);
  int v22;
  NSObject *v23;
  os_log_type_t v24;
  int v25;
  int v26;
  int v27;
  int v28;
  NSObject *v29;
  const __CFAllocator *v30;
  const __CFDictionary *v31;
  __CFNotificationCenter *LocalCenter;
  int v33;
  NSObject *v34;
  os_log_type_t v35;
  int v36;
  BOOL v37;
  uint8_t *v38;
  int v39;
  void *keys;
  dev_t valuePtr;
  stat v42;
  _BYTE v43[1024];
  _BYTE values[14];
  int v45;
  __int16 v46;
  dev_t st_dev;
  __int16 v48;
  uint8_t *v49;
  uint8_t buf[4];
  int v51;
  __int16 v52;
  uint64_t v53;
  __int16 v54;
  uint64_t v55;
  __int16 v56;
  _BYTE *v57;
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  if (**(_DWORD **)(a1 + 6592)
    || (v9 = (unsigned __int8 *)(a1 + 2439), v10 = atomic_load((unsigned __int8 *)(a1 + 2439)), (v10 & 1) != 0))
  {
LABEL_22:
    v22 = *__error();
    v23 = _SILogForLogForCategory(0);
    v24 = gSILogLevels[0] < 3;
    if (os_log_type_enabled(v23, (os_log_type_t)(gSILogLevels[0] < 3)))
    {
      *(_DWORD *)buf = 67109634;
      v51 = a2;
      v52 = 2080;
      v53 = a5;
      v54 = 2048;
      v55 = a3;
      _os_log_impl(&dword_1B8270000, v23, v24, "*warn* Index already unavailable, error:%d, reason:\"%s\", options:0x%lx", buf, 0x1Cu);
    }
    *__error() = v22;
  }
  else
  {
    do
    {
      if (__ldaxr(v9))
      {
        __clrex();
        goto LABEL_22;
      }
    }
    while (__stlxr(1u, v9));
    bzero(v43, 0x400uLL);
    v12 = fcntl(*(_DWORD *)(a1 + 32), 50, v43);
    v13 = v43[0];
    v39 = *__error();
    v14 = _SILogForLogForCategory(0);
    v15 = gSILogLevels[0] < 3;
    if (os_log_type_enabled(v14, (os_log_type_t)(gSILogLevels[0] < 3)))
    {
      if (v13)
        v16 = v12 < 0;
      else
        v16 = 1;
      *(_DWORD *)buf = 67109890;
      v51 = a2;
      v17 = v43;
      if (v16)
        v17 = 0;
      v52 = 2080;
      v53 = a5;
      v54 = 2048;
      v55 = a3;
      v56 = 2080;
      v57 = v17;
      _os_log_impl(&dword_1B8270000, v14, v15, "*warn* Marking the index as unavailable, error:%d, reason:\"%s\", options:0x%lx, path:%s", buf, 0x26u);
    }
    *__error() = v39;
    analytics_send_event_lazy();
    for (i = 0; i != 160; i += 8)
    {
      v19 = *(_QWORD *)(a1 + 1008 + i);
      if (v19)
        *(_DWORD *)(v19 + 36) = 1;
    }
    if ((a3 & 1) != 0)
    {
      v25 = *(_DWORD *)(a1 + 32);
      bzero(buf, 0x400uLL);
      memset(&v42, 0, sizeof(v42));
      if (fstat(v25, &v42) == -1)
      {
        v33 = *__error();
        v34 = _SILogForLogForCategory(0);
        v35 = 2 * (gSILogLevels[0] < 4);
        if (os_log_type_enabled(v34, v35))
        {
          v36 = *__error();
          *(_DWORD *)values = 67109376;
          *(_DWORD *)&values[4] = v25;
          *(_WORD *)&values[8] = 1024;
          *(_DWORD *)&values[10] = v36;
          _os_log_impl(&dword_1B8270000, v34, v35, "fstat(%d) err: %d", values, 0xEu);
        }
        *__error() = v33;
      }
      else
      {
        v26 = fcntl(v25, 50, buf);
        v27 = buf[0];
        v28 = *__error();
        v29 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
        {
          if (v27)
            v37 = v26 < 0;
          else
            v37 = 1;
          v38 = buf;
          if (v37)
            v38 = 0;
          *(_DWORD *)values = 136315906;
          *(_QWORD *)&values[4] = "notify_lowspace";
          *(_WORD *)&values[12] = 1024;
          v45 = 15511;
          v46 = 1024;
          st_dev = v42.st_dev;
          v48 = 2080;
          v49 = v38;
          _os_log_error_impl(&dword_1B8270000, v29, OS_LOG_TYPE_ERROR, "%s:%d: low space for device %d (%s)", values, 0x22u);
        }
        *__error() = v28;
        valuePtr = v42.st_dev;
        v30 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        *(_QWORD *)values = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, &valuePtr);
        keys = CFSTR("DeviceNumber");
        v31 = CFDictionaryCreate(v30, (const void **)&keys, (const void **)values, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        LocalCenter = CFNotificationCenterGetLocalCenter();
        CFNotificationCenterPostNotification(LocalCenter, CFSTR("com.apple.Spotlight.lowdiskspace"), 0, v31, 1u);
        CFRelease(*(CFTypeRef *)values);
        CFRelease(v31);
      }
    }
    else
    {
      v20 = *(_QWORD *)(a1 + 2360);
      v21 = *(void (**)(_QWORD, uint64_t, uint64_t, uint64_t))(v20 + 32);
      if (v21)
      {
        if ((a3 & 2) != 0)
        {
          touch_crash_state(*(_DWORD *)(a1 + 32));
          v20 = *(_QWORD *)(a1 + 2360);
          v21 = *(void (**)(_QWORD, uint64_t, uint64_t, uint64_t))(v20 + 32);
        }
        v21(*(_QWORD *)(v20 + 136), a2, a3, a5);
      }
    }
  }
}

uint64_t delete_index_recovery_files(int a1)
{
  uint64_t result;
  char *v3;
  int i;
  int v5;
  NSObject *v6;
  int v7;
  NSObject *v8;
  uint8_t buf[4];
  char *v10;
  char __s[1024];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  bzero(__s, 0x400uLL);
  result = fcntl(a1, 50, __s);
  if ((result & 0x80000000) == 0 && __s[0])
  {
    v3 = &__s[strlen(__s)];
    sprintf(v3, "/%s", "store.db.recover");
    if (gSILogLevels[0] >= 5)
    {
      v5 = *__error();
      v6 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315138;
        v10 = __s;
        _os_log_impl(&dword_1B8270000, v6, OS_LOG_TYPE_DEFAULT, "deleting %s", buf, 0xCu);
      }
      *__error() = v5;
    }
    unlink(__s);
    sprintf(v3, "/%s", ".store.db.recover");
    if (gSILogLevels[0] >= 5)
    {
      v7 = *__error();
      v8 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315138;
        v10 = __s;
        _os_log_impl(&dword_1B8270000, v8, OS_LOG_TYPE_DEFAULT, "deleting %s", buf, 0xCu);
      }
      *__error() = v7;
    }
    unlink(__s);
    for (i = 1; i != 6; ++i)
    {
      sprintf(v3, "/store.db.recoverStr-%d.map.header", i);
      unlink(__s);
      sprintf(v3, "/store.db.recoverStr-%d.map.offsets", i);
      unlink(__s);
      sprintf(v3, "/store.db.recoverStr-%d.map.data", i);
      unlink(__s);
      sprintf(v3, "/store.db.recoverStr-%d.map.buckets", i);
      result = unlink(__s);
    }
  }
  return result;
}

int *creationTouchFileUnlink(int a1)
{
  int v2;
  int *result;
  int v4;
  int v5;
  NSObject *v6;
  NSObject *v7;
  uint8_t buf[4];
  const char *v9;
  __int16 v10;
  int v11;
  __int16 v12;
  int v13;
  char v14[1024];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  bzero(v14, 0x400uLL);
  fcntl(a1, 50, v14);
  __strcat_chk();
  v2 = unlink(v14);
  result = __error();
  if (v2)
  {
    v4 = *result;
    if (*result == 2)
      return result;
    v5 = *__error();
    v6 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315650;
      v9 = "creationTouchFileUnlink";
      v10 = 1024;
      v11 = 2021;
      v12 = 1024;
      v13 = v4;
      _os_log_error_impl(&dword_1B8270000, v6, OS_LOG_TYPE_ERROR, "%s:%d: [IndexLoss] Failed to delete touch file: %d", buf, 0x18u);
    }
    *__error() = v5;
  }
  else
  {
    v4 = *__error();
    v7 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1B8270000, v7, OS_LOG_TYPE_DEFAULT, "[IndexLoss] Deleted creation touch file", buf, 2u);
    }
  }
  result = __error();
  *result = v4;
  return result;
}

xpc_object_t __si_makeUnavailable_block_invoke(uint64_t a1)
{
  xpc_object_t empty;
  unsigned int v3;
  int64_t v4;
  xpc_object_t v5;
  xpc_object_t v6;
  xpc_object_t v7;
  xpc_object_t v8;

  empty = xpc_dictionary_create_empty();
  v3 = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 60);
  if ((v3 & 1) != 0)
    v4 = 0xFFFFFFFFLL;
  else
    v4 = v3 >> 1;
  v5 = xpc_int64_create(v4);
  xpc_dictionary_set_int64(empty, "pc", (int64_t)v5);
  v6 = xpc_uint64_create(*(unsigned int *)(a1 + 40));
  xpc_dictionary_set_uint64(empty, "reason", (uint64_t)v6);
  v7 = xpc_int64_create(*(int *)(a1 + 44));
  xpc_dictionary_set_int64(empty, "error", (int64_t)v7);
  v8 = xpc_uint64_create(*(unsigned int *)(a1 + 48));
  xpc_dictionary_set_uint64(empty, "options", (uint64_t)v8);
  return empty;
}

uint64_t si_set_obj_state(os_unfair_lock_s *a1, uint64_t a2)
{
  os_unfair_lock_s *v4;
  uint64_t v5;

  v4 = a1 + 1644;
  os_unfair_lock_lock(a1 + 1644);
  v5 = si_set_obj_state_locked((uint64_t)a1, a2, 1);
  os_unfair_lock_unlock(v4);
  return v5;
}

char *__si_assert_copy_extra_521(int a1)
{
  char *v2;
  char *v3;
  const char *v4;
  const char *v5;
  char *v7;
  char v8[1024];
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v2 = v8;
  bzero(v8, 0x400uLL);
  if (a1 == -1 || fcntl(a1, 50, v8) < 0 || !v8[0])
  {
    v3 = getcwd(v8, 0x400uLL);
    if (v3)
      v2 = v3;
    else
      v2 = "";
  }
  v7 = 0;
  v4 = (const char *)pthread_getspecific(__THREAD_STR_DATA_KEY);
  if (v4)
    v5 = v4;
  else
    v5 = "";
  asprintf(&v7, "%s %s", v2, v5);
  return v7;
}

uint64_t __si_set_obj_state_locked_block_invoke_2(uint64_t a1, uint64_t a2)
{
  int v2;
  int v3;

  v2 = *(unsigned __int8 *)(a2 + 15161);
  v3 = *(unsigned __int8 *)(a1 + 40);
  if (v2 != 4 && v2 != v3)
  {
    *(_BYTE *)(a2 + 15161) = v3;
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
  }
  return 1;
}

const char *SISetCrashCStr(const char *result)
{
  const char *v2;
  char *v3;
  pthread_t v4;
  char __source[2048];
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  if (result)
  {
    if (gSICrashBufferSize && gSICrashBuffer != 0)
    {
      v2 = result;
      pthread_mutex_lock(&sSICrashStrLock);
      bzero(__source, 0x800uLL);
      v3 = (char *)gSICrashBuffer;
      if (*(_BYTE *)gSICrashBuffer)
      {
        __strlcpy_chk();
        __strlcat_chk();
        v3 = (char *)gSICrashBuffer;
      }
      *v3 = 0;
      v4 = pthread_self();
      snprintf(v3, 0x800uLL, "[%p] %s", v4, v2);
      if (__source[0])
        strlcat((char *)gSICrashBuffer, __source, gSICrashBufferSize);
      return (const char *)pthread_mutex_unlock(&sSICrashStrLock);
    }
  }
  return result;
}

void lock_datastore(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  db_lock_datastore(*(int **)(a1 + 24));
  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(_QWORD *)(v2 + 6624);
  if (v3)
  {
    _db_write_lock(v3 + 4416);
    v2 = *(_QWORD *)(a1 + 32);
  }
  os_unfair_lock_lock((os_unfair_lock_t)(v2 + 6576));
}

uint64_t unlock_datastore(uint64_t a1)
{
  uint64_t v2;

  os_unfair_lock_unlock((os_unfair_lock_t)(*(_QWORD *)(a1 + 32) + 6576));
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 6624);
  if (v2)
    db_write_unlock(v2 + 4416);
  return db_unlock_datastore(*(int **)(a1 + 24));
}

uint64_t sync_datastore(uint64_t a1, _DWORD *a2, uint64_t *a3)
{
  uint64_t v3;
  void (*v6)(uint64_t, uint8_t *);
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  NSObject *v20;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  char *v27;
  unint64_t v28;
  unint64_t v29;
  size_t v30;
  unint64_t v31;
  int *v32;
  uint64_t v33;
  int v34;
  CFIndex v35;
  _QWORD *v36;
  unint64_t v37;
  int v38;
  NSObject *v39;
  char *v40;
  const char *v41;
  unint64_t v42;
  unint64_t v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  NSObject *v47;
  char *v48;
  unint64_t v49;
  unint64_t v50;
  uint64_t v51;
  int v52;
  NSObject *v53;
  char *v54;
  _BYTE *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  char *v59;
  uint64_t v60;
  unint64_t v61;
  uint64_t v62;
  uint64_t v63;
  size_t v64;
  uint64_t v65;
  unint64_t v66;
  uint64_t v67;
  uint64_t v68;
  size_t v69;
  uint64_t v70;
  int v71;
  NSObject *v72;
  const void *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint8_t *v77;
  size_t i;
  uint64_t v79;
  char *v80;
  char *v81;
  const char *v82;
  uint64_t v83;
  int v84;
  NSObject *v85;
  int v86;
  char *v87;
  char *v88;
  const char *v89;
  uint64_t v90;
  uint64_t v91;
  int v92;
  char *v93;
  unint64_t v94;
  unint64_t v95;
  char *v96;
  _QWORD v97[5];
  _OWORD v98[2];
  __int128 v99;
  __int128 v100;
  _BYTE buf[40];
  _BYTE v102[10];
  char *v103;
  __int16 v104;
  char *v105;
  uint8_t __src[96];
  __int128 v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  uint64_t v117;

  v117 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(*(_QWORD *)(a1 + 32) + 2481) == 3)
    return 89;
  v6 = *(void (**)(uint64_t, uint8_t *))a1;
  if (*(_QWORD *)a1)
  {
    v8 = a3[7];
    v7 = a3[8];
    v10 = a3[4];
    v9 = a3[5];
    v12 = *a3;
    v11 = a3[1];
    v13 = a3[3];
    v14 = a3[6];
    v15 = *((_OWORD *)a3 + 5);
    v16 = a3[12];
    v17 = *(_QWORD *)(a1 + 16);
    *(_QWORD *)__src = a3[2];
    *(_QWORD *)&__src[8] = v9;
    *(_QWORD *)&__src[16] = v7;
    *(_QWORD *)&__src[24] = v11;
    *(_QWORD *)&__src[32] = v10;
    *(_QWORD *)&__src[40] = v8;
    *(_QWORD *)&__src[48] = v12;
    *(_QWORD *)&__src[56] = v13;
    *(_OWORD *)&__src[72] = v15;
    *(_QWORD *)&__src[64] = v14;
    *(_QWORD *)&__src[88] = v16;
    v6(v17, __src);
  }
  v18 = db_flush_datastore(*(_QWORD *)(a1 + 24), a2);
  if ((_DWORD)v18)
  {
    v3 = v18;
    v19 = *__error();
    v20 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
LABEL_7:
      *__error() = v19;
      return v3;
    }
    *(_DWORD *)__src = 136315650;
    *(_QWORD *)&__src[4] = "sync_datastore";
    *(_WORD *)&__src[12] = 1024;
    *(_DWORD *)&__src[14] = 1393;
    *(_WORD *)&__src[18] = 1024;
    *(_DWORD *)&__src[20] = v3;
    v41 = "%s:%d: db_flush_datastore err:%d";
    goto LABEL_39;
  }
  v22 = *(_QWORD *)(a1 + 32);
  if (*(_BYTE *)(v22 + 6872))
  {
    v23 = (char *)fd_create_protected(*(_DWORD *)(v22 + 32), "tmp.spotlight.loc", 536872450, 0);
    v99 = 0u;
    v100 = 0u;
    memset(v98, 0, sizeof(v98));
    if (!store_stream_init((uint64_t)v98, v23, 1))
    {
      _fd_unlink_with_origin((uint64_t)v23, 0);
LABEL_67:
      store_stream_destroy((uint64_t)v98);
      fd_release(v23);
      goto LABEL_68;
    }
    v24 = *((_QWORD *)&v99 + 1);
    v25 = v99;
    v26 = *((_QWORD *)&v99 + 1) + 1;
    v96 = v23;
    if ((_QWORD)v99 - *((_QWORD *)&v99 + 1) < 6uLL)
    {
      *(_OWORD *)&__src[1] = 0uLL;
      *(_QWORD *)&__src[24] = 0;
      *(_QWORD *)&__src[17] = 0;
      __src[0] = 13;
      v77 = __src;
      for (i = 1; ; v26 = *((_QWORD *)&v99 + 1) + i)
      {
        if (v26 < v25)
        {
          memcpy((void *)(v100 + v24), v77, i);
          v26 = *((_QWORD *)&v99 + 1) + i;
          goto LABEL_13;
        }
        v79 = v25 - v24;
        memcpy((void *)(v100 + v24), v77, v25 - v24);
        *((_QWORD *)&v99 + 1) += v79;
        if (store_stream_flush((unsigned int *)v98, 0))
          break;
        v77 += v79;
        i -= v79;
        v24 = *((_QWORD *)&v99 + 1);
        v25 = v99;
      }
      v26 = *((_QWORD *)&v99 + 1);
    }
    else
    {
      *(_BYTE *)(v100 + *((_QWORD *)&v99 + 1)) = 13;
LABEL_13:
      *((_QWORD *)&v99 + 1) = v26;
    }
    v27 = (char *)(v22 + 6856);
    v28 = v26 + 16;
    v29 = v99;
    v30 = 16;
    while (v28 >= v29)
    {
      v31 = v29 - v26;
      memcpy((void *)(v100 + v26), v27, v29 - v26);
      *((_QWORD *)&v99 + 1) += v31;
      if (store_stream_flush((unsigned int *)v98, 0))
        goto LABEL_20;
      v27 += v31;
      v30 -= v31;
      v26 = *((_QWORD *)&v99 + 1);
      v29 = v99;
      v28 = *((_QWORD *)&v99 + 1) + v30;
    }
    memcpy((void *)(v100 + v26), v27, v30);
    *((_QWORD *)&v99 + 1) += v30;
LABEL_20:
    v32 = *(int **)(v22 + 1184);
    if (*v32 != 1685287992)
    {
      v84 = *__error();
      v85 = _SILogForLogForCategory(4);
      if (os_log_type_enabled(v85, OS_LOG_TYPE_ERROR))
      {
        v86 = *v32;
        *(_DWORD *)__src = 136315650;
        *(_QWORD *)&__src[4] = "db_copy_delete_localized_term_ids";
        *(_WORD *)&__src[12] = 1024;
        *(_DWORD *)&__src[14] = 442;
        *(_WORD *)&__src[18] = 1024;
        *(_DWORD *)&__src[20] = v86;
        _os_log_error_impl(&dword_1B8270000, v85, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", __src, 0x18u);
      }
      *__error() = v84;
      v87 = __si_assert_copy_extra_268();
      v88 = v87;
      if (v87)
        v89 = v87;
      else
        v89 = "";
      __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 442, v89);
      free(v88);
      goto LABEL_130;
    }
    if ((v32[201] & 0x14) == 0)
      goto LABEL_65;
    v33 = *((_QWORD *)v32 + 114);
    if (!v33)
      goto LABEL_65;
    v34 = *(_DWORD *)(v33 + 216);
    if (v34 != -270471200)
    {
      if (v34 != 1684300900)
      {
        if (v34 == 842150450 && *(_DWORD *)(v33 + 368))
        {
          v35 = *(unsigned int *)(v33 + 364);
          v36 = bit_vector_create(v35);
          if (v35 >= 2)
          {
            v37 = 1;
            while (1)
            {
              if (v37 >= *(unsigned int *)(v33 + 364))
              {
                v115 = 0u;
                v116 = 0u;
                v113 = 0u;
                v114 = 0u;
                v111 = 0u;
                v112 = 0u;
                v109 = 0u;
                v110 = 0u;
                v107 = 0u;
                v108 = 0u;
                memset(__src, 0, sizeof(__src));
                v38 = *__error();
                v39 = _SILogForLogForCategory(0);
                if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
                {
                  v92 = *(_DWORD *)(v33 + 364);
                  v40 = fd_name(*(_QWORD *)(v33 + 240), (char *)__src, 0x100uLL);
                  *(_DWORD *)buf = 136316418;
                  *(_QWORD *)&buf[4] = "_data_map32_get_offset_entry";
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = 421;
                  *(_WORD *)&buf[18] = 1024;
                  *(_DWORD *)&buf[20] = v37;
                  *(_WORD *)&buf[24] = 1024;
                  *(_DWORD *)&buf[26] = v92;
                  *(_WORD *)&buf[30] = 2048;
                  *(_QWORD *)&buf[32] = v33;
                  *(_WORD *)v102 = 2080;
                  *(_QWORD *)&v102[2] = v40;
                  _os_log_error_impl(&dword_1B8270000, v39, OS_LOG_TYPE_ERROR, "%s:%d: invalid data id %d max %d %p %s", buf, 0x32u);
                }
                *__error() = v38;
              }
              else if (*(_DWORD *)(*(_QWORD *)(v33 + 320) + 4 * v37) != 1)
              {
                goto LABEL_36;
              }
              bit_vector_set_9027((uint64_t)v36, v37);
LABEL_36:
              if (v35 == ++v37)
                goto LABEL_102;
            }
          }
          goto LABEL_102;
        }
LABEL_65:
        TermUpdateSetStore(*(_DWORD **)(v22 + 6648), 0, v98, 0);
        v55 = (_BYTE *)(v22 + 6872);
        v23 = v96;
LABEL_66:
        *v55 = 0;
        store_stream_flush((unsigned int *)v98, 0);
        goto LABEL_67;
      }
      if (!*(_QWORD *)(v33 + 4504))
        goto LABEL_65;
      v49 = *(_QWORD *)(v33 + 4496);
      v36 = bit_vector_create(v49);
      if (v49 >= 2)
      {
        v50 = 1;
        v51 = 16;
        v95 = v49;
        do
        {
          if (*(_QWORD *)(v33 + 4496) <= v50)
          {
            v115 = 0u;
            v116 = 0u;
            v113 = 0u;
            v114 = 0u;
            v111 = 0u;
            v112 = 0u;
            v109 = 0u;
            v110 = 0u;
            v107 = 0u;
            v108 = 0u;
            memset(__src, 0, sizeof(__src));
            v52 = *__error();
            v53 = _SILogForLogForCategory(0);
            if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
            {
              v91 = *(_QWORD *)(v33 + 4496);
              v54 = fd_name(*(_QWORD *)(v33 + 240), (char *)__src, 0x100uLL);
              *(_DWORD *)buf = 136316418;
              *(_QWORD *)&buf[4] = "_data_map64_get_offset_entry";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = 362;
              *(_WORD *)&buf[18] = 2048;
              *(_QWORD *)&buf[20] = v50;
              *(_WORD *)&buf[28] = 2048;
              *(_QWORD *)&buf[30] = v91;
              *(_WORD *)&buf[38] = 2048;
              *(_QWORD *)v102 = v33;
              *(_WORD *)&v102[8] = 2080;
              v103 = v54;
              _os_log_error_impl(&dword_1B8270000, v53, OS_LOG_TYPE_ERROR, "%s:%d: invalid data id %lld max %lld %p %s", buf, 0x3Au);
            }
            *__error() = v52;
            v49 = v95;
          }
          else if (*(_QWORD *)(*(_QWORD *)(v33 + 4440) + v51) != 1)
          {
            goto LABEL_63;
          }
          bit_vector_set_5272((uint64_t)v36, v50);
LABEL_63:
          ++v50;
          v51 += 16;
        }
        while (v49 != v50);
      }
LABEL_102:
      TermUpdateSetStore(*(_DWORD **)(v22 + 6648), (uint64_t)v36, v98, 0);
      v55 = (_BYTE *)(v22 + 6872);
      v23 = v96;
      if (v36)
      {
        v73 = (const void *)v36[2];
        if (v73)
          CFRelease(v73);
        free(v36);
      }
      goto LABEL_66;
    }
    if (!*(_QWORD *)(v33 + 384))
      goto LABEL_65;
    v42 = *(_QWORD *)(v33 + 376);
    v36 = bit_vector_create(v42);
    v94 = v42;
    if (v42 < 2)
      goto LABEL_102;
    v43 = 1;
    v44 = 24;
    while (1)
    {
      if (*(_QWORD *)(v33 + 376) > v43 && (v45 = *(_QWORD *)(v33 + 288), (unint64_t)(v45 + 1) > 1))
      {
        if (*(_QWORD *)(v45 + v44) != -2)
          goto LABEL_49;
      }
      else
      {
        v115 = 0u;
        v116 = 0u;
        v113 = 0u;
        v114 = 0u;
        v111 = 0u;
        v112 = 0u;
        v109 = 0u;
        v110 = 0u;
        v107 = 0u;
        v108 = 0u;
        memset(__src, 0, sizeof(__src));
        v46 = *__error();
        v47 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
        {
          v90 = *(_QWORD *)(v33 + 376);
          v93 = *(char **)(v33 + 288);
          v48 = fd_name(*(_QWORD *)(v33 + 240), (char *)__src, 0x100uLL);
          *(_DWORD *)buf = 136316674;
          *(_QWORD *)&buf[4] = "_data_map_ext_get_offset_entry";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 409;
          *(_WORD *)&buf[18] = 2048;
          *(_QWORD *)&buf[20] = v43;
          *(_WORD *)&buf[28] = 2048;
          *(_QWORD *)&buf[30] = v90;
          *(_WORD *)&buf[38] = 2048;
          *(_QWORD *)v102 = v33;
          *(_WORD *)&v102[8] = 2048;
          v103 = v93;
          v104 = 2080;
          v105 = v48;
          _os_log_error_impl(&dword_1B8270000, v47, OS_LOG_TYPE_ERROR, "%s:%d: invalid data id %lld max %lld %p map: %p %s", buf, 0x44u);
        }
        *__error() = v46;
      }
      bit_vector_set_5272((uint64_t)v36, v43);
LABEL_49:
      ++v43;
      v44 += 24;
      if (v94 == v43)
        goto LABEL_102;
    }
  }
LABEL_68:
  db_downgrade_datastore(*(int **)(a1 + 24));
  v56 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 6624);
  if (!v56)
    goto LABEL_112;
  v57 = flushReverseStore(v56);
  if ((_DWORD)v57)
  {
    v3 = v57;
    v19 = *__error();
    v20 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      goto LABEL_7;
    *(_DWORD *)__src = 136315650;
    *(_QWORD *)&__src[4] = "sync_datastore";
    *(_WORD *)&__src[12] = 1024;
    *(_DWORD *)&__src[14] = 1405;
    *(_WORD *)&__src[18] = 1024;
    *(_DWORD *)&__src[20] = v3;
    v41 = "%s:%d: flushReverseStore err:%d";
    goto LABEL_39;
  }
  db_downgrade_lock((pthread_mutex_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 6624) + 4416));
  v58 = *(_QWORD *)(a1 + 32);
  if (!*(_QWORD *)(v58 + 6640))
  {
    if (!*(_BYTE *)(v58 + 6944) && *(int *)(v58 + 6960) <= 0)
      deleteStaleOverlay(*(_DWORD *)(v58 + 32));
LABEL_112:
    if (!*(_BYTE *)(a1 + 40) || !*a2)
      return 0;
    v75 = db_store_dirty_chunk_info(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 1184), *(unsigned int *)(*(_QWORD *)(a1 + 32) + 32), 0, *(unsigned __int8 *)(a1 + 41));
    if ((_DWORD)v75)
    {
      v3 = v75;
      v19 = *__error();
      v20 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        goto LABEL_7;
      *(_DWORD *)__src = 136315650;
      *(_QWORD *)&__src[4] = "sync_datastore";
      *(_WORD *)&__src[12] = 1024;
      *(_DWORD *)&__src[14] = 1484;
      *(_WORD *)&__src[18] = 1024;
      *(_DWORD *)&__src[20] = v3;
      v41 = "%s:%d: db_store_dirty_chunk_info err:%d";
      goto LABEL_39;
    }
    v76 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 6624);
    if (!v76)
      return 0;
    v3 = reverseStoreStoreDirtyBitmap(v76);
    if (!(_DWORD)v3)
      return v3;
    v19 = *__error();
    v20 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      goto LABEL_7;
    *(_DWORD *)__src = 136315650;
    *(_QWORD *)&__src[4] = "sync_datastore";
    *(_WORD *)&__src[12] = 1024;
    *(_DWORD *)&__src[14] = 1491;
    *(_WORD *)&__src[18] = 1024;
    *(_DWORD *)&__src[20] = v3;
    v41 = "%s:%d: reverseStoreStoreDirtyBitmap err:%d";
LABEL_39:
    _os_log_error_impl(&dword_1B8270000, v20, OS_LOG_TYPE_ERROR, v41, __src, 0x18u);
    goto LABEL_7;
  }
  if (!*(_QWORD *)(a1 + 48) || !*(_QWORD *)(a1 + 56))
  {
    v80 = __si_assert_copy_extra_521(-1);
    v81 = v80;
    v82 = "";
    if (v80)
      v82 = v80;
    __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 1410, "ctx->syncSet && ctx->liveSet", v82);
    free(v81);
    if (!__valid_fs(-1))
    {
      v83 = 3072;
LABEL_132:
      *(_DWORD *)v83 = -559038737;
      abort();
    }
LABEL_130:
    v83 = 2989;
    goto LABEL_132;
  }
  *(_QWORD *)__src = 0;
  *(_QWORD *)&__src[8] = __src;
  *(_QWORD *)&__src[16] = 0x5800000000;
  memset(&__src[24], 0, 64);
  v59 = (char *)fd_create_protected(*(_DWORD *)(v58 + 32), "tmp.dirStore.overlay", 1538, 0);
  if (store_stream_init(*(_QWORD *)&__src[8] + 24, v59, 1))
  {
    v60 = *(_QWORD *)(a1 + 48);
    if (*(_DWORD *)(v60 + 8))
    {
      v61 = 0;
      do
      {
        if (CFSetContainsValue(*(CFSetRef *)(*(_QWORD *)(a1 + 32) + 6640), (const void *)*(int *)(*(_QWORD *)(*(_QWORD *)v60 + 8 * v61) + 48)))
        {
          v62 = *(_QWORD *)&__src[8];
          ++v61;
          v63 = *(_QWORD *)(*(_QWORD *)&__src[8] + 64);
          if ((unint64_t)(*(_QWORD *)(*(_QWORD *)&__src[8] + 56) - v63) < 0xB)
          {
            memset(buf, 0, 32);
            v64 = writeVInt64((uint64_t)buf, 0, v61);
            store_stream_write_bytes(v62 + 24, buf, v64);
          }
          else
          {
            *(_QWORD *)(v62 + 64) = writeVInt64(*(_QWORD *)(*(_QWORD *)&__src[8] + 72), v63, v61);
          }
        }
        else
        {
          ++v61;
        }
        v60 = *(_QWORD *)(a1 + 48);
      }
      while (v61 < *(unsigned int *)(v60 + 8));
    }
    store_stream_write_vint((_QWORD *)(*(_QWORD *)&__src[8] + 24));
    v65 = *(_QWORD *)(a1 + 56);
    if (*(_DWORD *)(v65 + 8))
    {
      v66 = 0;
      do
      {
        if (CFSetContainsValue(*(CFSetRef *)(*(_QWORD *)(a1 + 32) + 6640), (const void *)*(int *)(*(_QWORD *)(*(_QWORD *)v65 + 8 * v66) + 48)))
        {
          v67 = *(_QWORD *)&__src[8];
          ++v66;
          v68 = *(_QWORD *)(*(_QWORD *)&__src[8] + 64);
          if ((unint64_t)(*(_QWORD *)(*(_QWORD *)&__src[8] + 56) - v68) < 0xB)
          {
            memset(buf, 0, 32);
            v69 = writeVInt64((uint64_t)buf, 0, v66);
            store_stream_write_bytes(v67 + 24, buf, v69);
          }
          else
          {
            *(_QWORD *)(v67 + 64) = writeVInt64(*(_QWORD *)(*(_QWORD *)&__src[8] + 72), v68, v66);
          }
        }
        else
        {
          ++v66;
        }
        v65 = *(_QWORD *)(a1 + 56);
      }
      while (v66 < *(unsigned int *)(v65 + 8));
    }
    store_stream_write_vint((_QWORD *)(*(_QWORD *)&__src[8] + 24));
    v70 = *(_QWORD *)(*(_QWORD *)&__src[8] + 64);
    v3 = *(unsigned int *)(*(_QWORD *)&__src[8] + 40);
    if ((_DWORD)v3)
    {
      v71 = *__error();
      v72 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v72, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = "sync_datastore";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 1438;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v3;
        _os_log_error_impl(&dword_1B8270000, v72, OS_LOG_TYPE_ERROR, "%s:%d: store dirStore overlay err:%d", buf, 0x18u);
      }
      *__error() = v71;
    }
    else
    {
      v74 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 6632);
      v97[0] = MEMORY[0x1E0C809B0];
      v97[1] = 0x40000000;
      v97[2] = __sync_datastore_block_invoke;
      v97[3] = &unk_1E6E2D1B0;
      v97[4] = __src;
      directoryOverlayProcessPaths(v74, (uint64_t)v97);
    }
    if (*(_QWORD *)(*(_QWORD *)&__src[8] + 64) == v70)
    {
      _fd_unlink_with_origin((uint64_t)v59, 0);
      deleteStaleOverlay(*(_DWORD *)(*(_QWORD *)(a1 + 32) + 32));
    }
    else
    {
      store_stream_write_vint32((_QWORD *)(*(_QWORD *)&__src[8] + 24), 0);
      store_stream_write_vint32((_QWORD *)(*(_QWORD *)&__src[8] + 24), 0);
      store_stream_flush((unsigned int *)(*(_QWORD *)&__src[8] + 24), 0);
      fd_rename((uint64_t)v59, "dirStore.overlay");
    }
    store_stream_destroy(*(_QWORD *)&__src[8] + 24);
  }
  else
  {
    v3 = *(unsigned int *)(*(_QWORD *)&__src[8] + 40);
  }
  fd_release(v59);
  _Block_object_dispose(__src, 8);
  if (!(_DWORD)v3)
    goto LABEL_112;
  return v3;
}

uint64_t commit_sync_datastore(uint64_t a1, int a2)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  NSObject *v9;
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  std::mutex *v13;
  int v14;
  int v15;
  NSObject *v16;
  os_log_type_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  os_unfair_lock_s *v21;
  double Current;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  char v27;
  _QWORD v29[2];
  uint8_t buf[4];
  const char *v31;
  __int16 v32;
  int v33;
  char __str[32];
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  uint64_t v65;

  v65 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a1 + 32);
  if (a2)
    v5 = 2;
  else
    v5 = 3;
  v6 = si_set_obj_state_locked(v4, 0, v5);
  if ((_DWORD)v6)
  {
    v7 = v6;
    v8 = *__error();
    v9 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__str = 136315650;
      *(_QWORD *)&__str[4] = "commit_sync_datastore";
      *(_WORD *)&__str[12] = 1024;
      *(_DWORD *)&__str[14] = 1508;
      *(_WORD *)&__str[18] = 1024;
      *(_DWORD *)&__str[20] = v7;
      v10 = "%s:%d: si_set_index_state err:%d";
LABEL_34:
      _os_log_error_impl(&dword_1B8270000, v9, OS_LOG_TYPE_ERROR, v10, (uint8_t *)__str, 0x18u);
      goto LABEL_9;
    }
    goto LABEL_9;
  }
  v11 = db_commit_sync_datastore(*(_QWORD *)(a1 + 24), a2);
  if ((_DWORD)v11)
  {
    v7 = v11;
    v8 = *__error();
    v9 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__str = 136315650;
      *(_QWORD *)&__str[4] = "commit_sync_datastore";
      *(_WORD *)&__str[12] = 1024;
      *(_DWORD *)&__str[14] = 1512;
      *(_WORD *)&__str[18] = 1024;
      *(_DWORD *)&__str[20] = v7;
      v10 = "%s:%d: db_commit_sync_datastore err:%d";
      goto LABEL_34;
    }
    goto LABEL_9;
  }
  v25 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 6624);
  if (v25)
  {
    v7 = commitSyncReverseStore(v25, a2);
    if ((_DWORD)v7)
    {
      v8 = *__error();
      v9 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__str = 136315650;
        *(_QWORD *)&__str[4] = "commit_sync_datastore";
        *(_WORD *)&__str[12] = 1024;
        *(_DWORD *)&__str[14] = 1518;
        *(_WORD *)&__str[18] = 1024;
        *(_DWORD *)&__str[20] = v7;
        v10 = "%s:%d: commitSyncReverseStore err:%d";
        goto LABEL_34;
      }
LABEL_9:
      *__error() = v8;
    }
  }
  else
  {
    v7 = 0;
  }
  v12 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 1296);
  v63 = 0u;
  v64 = 0u;
  v61 = 0u;
  v62 = 0u;
  v59 = 0u;
  v60 = 0u;
  v57 = 0u;
  v58 = 0u;
  v55 = 0u;
  v56 = 0u;
  v53 = 0u;
  v54 = 0u;
  v51 = 0u;
  v52 = 0u;
  v49 = 0u;
  v50 = 0u;
  v47 = 0u;
  v48 = 0u;
  v45 = 0u;
  v46 = 0u;
  v43 = 0u;
  v44 = 0u;
  v41 = 0u;
  v42 = 0u;
  v39 = 0u;
  v40 = 0u;
  v37 = 0u;
  v38 = 0u;
  v35 = 0u;
  v36 = 0u;
  memset(__str, 0, sizeof(__str));
  snprintf(__str, 0x200uLL, "doc_store_sync(%p)", (const void *)v12);
  v29[0] = 0;
  v29[1] = 0;
  ScopeLogger::ScopeLogger((ScopeLogger *)v29, __str);
  if (v12)
  {
    v13 = (std::mutex *)(v12 + 40);
    std::mutex::lock((std::mutex *)(v12 + 40));
    v14 = fsync(*(_DWORD *)(v12 + 4));
    std::mutex::unlock(v13);
    v15 = *__error();
    v16 = _SILogForLogForCategory(8);
    v17 = 2 * (dword_1EF19FCAC < 4);
    if (os_log_type_enabled(v16, v17))
    {
      *(_DWORD *)buf = 136315394;
      v31 = "doc_store_sync";
      v32 = 1024;
      v33 = v14;
      _os_log_impl(&dword_1B8270000, v16, v17, "%s returns %d\n", buf, 0x12u);
    }
    *__error() = v15;
  }
  ScopeLogger::~ScopeLogger((ScopeLogger *)v29);
  v18 = *(_QWORD *)(a1 + 32);
  v19 = v18 + 2192;
  v20 = *(_QWORD *)(v18 + 2408);
  memset(__str, 0, sizeof(__str));
  v21 = (os_unfair_lock_s *)(v18 + 2224);
  os_unfair_lock_lock((os_unfair_lock_t)(v18 + 2224));
  Current = CFAbsoluteTimeGetCurrent();
  v23 = (unint64_t)Current;
  if ((unint64_t)Current > 0x7F)
  {
    if (v23 >> 14)
    {
      if (v23 >> 21)
      {
        if (v23 >> 28)
        {
          if (v23 >> 35)
          {
            if (v23 >> 42)
            {
              if (v23 >> 49)
              {
                if (HIBYTE(v23))
                {
                  __str[0] = -1;
                  *(_QWORD *)&__str[1] = (unint64_t)Current;
                  v24 = 9;
                }
                else
                {
                  __str[0] = -2;
                  __str[1] = (unint64_t)Current >> 48;
                  __str[2] = (unsigned __int16)((unint64_t)Current >> 32) >> 8;
                  __str[3] = (unint64_t)Current >> 32;
                  __str[4] = (unint64_t)Current >> 24;
                  __str[5] = (unint64_t)Current >> 16;
                  __str[6] = (unsigned __int16)(unint64_t)Current >> 8;
                  v24 = 8;
                  __str[7] = (unint64_t)Current;
                }
              }
              else
              {
                __str[0] = BYTE6(v23) | 0xFC;
                __str[1] = (unsigned __int16)((unint64_t)Current >> 32) >> 8;
                __str[2] = (unint64_t)Current >> 32;
                __str[3] = (unint64_t)Current >> 24;
                __str[4] = (unint64_t)Current >> 16;
                __str[5] = (unsigned __int16)(unint64_t)Current >> 8;
                v24 = 7;
                __str[6] = (unint64_t)Current;
              }
            }
            else
            {
              __str[0] = BYTE5(v23) | 0xF8;
              __str[1] = (unint64_t)Current >> 32;
              __str[2] = (unint64_t)Current >> 24;
              __str[3] = (unint64_t)Current >> 16;
              __str[4] = (unsigned __int16)(unint64_t)Current >> 8;
              __str[5] = (unint64_t)Current;
              v24 = 6;
            }
          }
          else
          {
            __str[0] = BYTE4(v23) | 0xF0;
            __str[1] = (unint64_t)Current >> 24;
            __str[2] = (unint64_t)Current >> 16;
            __str[3] = (unsigned __int16)(unint64_t)Current >> 8;
            __str[4] = (unint64_t)Current;
            v24 = 5;
          }
        }
        else
        {
          __str[0] = BYTE3(v23) | 0xE0;
          __str[1] = (unint64_t)Current >> 16;
          __str[2] = (unsigned __int16)(unint64_t)Current >> 8;
          __str[3] = (unint64_t)Current;
          v24 = 4;
        }
      }
      else
      {
        __str[0] = BYTE2(v23) | 0xC0;
        __str[1] = (unsigned __int16)(unint64_t)Current >> 8;
        __str[2] = (unint64_t)Current;
        v24 = 3;
      }
    }
    else
    {
      __str[0] = BYTE1(v23) | 0x80;
      __str[1] = (unint64_t)Current;
      v24 = 2;
    }
  }
  else
  {
    __str[0] = (unint64_t)Current;
    v24 = 1;
  }
  v26 = v2_writeVInt64_7950((uint64_t)__str, v24, v20);
  if ((_DWORD)v7)
    v27 = 6;
  else
    v27 = 40;
  activityJournalWrite(v19, v27, __str, v26);
  os_unfair_lock_unlock(v21);
  if (!(_DWORD)v7)
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 2152) = 0;
  return v7;
}

uint64_t shadow_datastore(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  NSObject *v5;
  os_unfair_lock_s *v6;
  uint64_t v7;
  os_unfair_lock_s *v8;
  char v9;
  CFAbsoluteTime Current;
  uint64_t v12;
  uint64_t v13;
  const char *v14;
  char *v15;
  char *v16;
  const char *v17;
  uint64_t v18;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  int v22;
  __int16 v23;
  int v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 40))
  {
    v15 = __si_assert_copy_extra_521(-1);
    v16 = v15;
    v17 = "";
    if (v15)
      v17 = v15;
    __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 1537, "!ctx->syncDirtyChunks", v17);
    free(v16);
    if (__valid_fs(-1))
      v18 = 2989;
    else
      v18 = 3072;
    *(_DWORD *)v18 = -559038737;
    abort();
  }
  v2 = db_shadow_datastore(*(_QWORD *)(a1 + 24), *(unsigned __int8 *)(a1 + 42));
  if ((_DWORD)v2)
  {
    v3 = v2;
    v4 = *__error();
    v5 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
LABEL_4:
      *__error() = v4;
      goto LABEL_5;
    }
    *(_DWORD *)buf = 136315650;
    v20 = "shadow_datastore";
    v21 = 1024;
    v22 = 1540;
    v23 = 1024;
    v24 = v3;
    v14 = "%s:%d: db_shadow_datastore err:%d";
LABEL_15:
    _os_log_error_impl(&dword_1B8270000, v5, OS_LOG_TYPE_ERROR, v14, buf, 0x18u);
    goto LABEL_4;
  }
  v12 = *(_QWORD *)(a1 + 32);
  v13 = *(_QWORD *)(v12 + 6624);
  if (v13)
  {
    v3 = shadowReverseStore(v13, 0, *(_DWORD **)(v12 + 6592));
    if ((_DWORD)v3)
    {
      v4 = *__error();
      v5 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        goto LABEL_4;
      *(_DWORD *)buf = 136315650;
      v20 = "shadow_datastore";
      v21 = 1024;
      v22 = 1546;
      v23 = 1024;
      v24 = v3;
      v14 = "%s:%d: shadowReverseStore err:%d";
      goto LABEL_15;
    }
  }
  else
  {
    v3 = 0;
  }
LABEL_5:
  v6 = *(os_unfair_lock_s **)(a1 + 32);
  v7 = (uint64_t)&v6[548];
  v8 = v6 + 556;
  os_unfair_lock_lock(v6 + 556);
  if ((_DWORD)v3)
    v9 = 8;
  else
    v9 = 7;
  Current = CFAbsoluteTimeGetCurrent();
  activityJournalWriteVInt64(v7, v9, (unint64_t)Current);
  os_unfair_lock_unlock(v8);
  return v3;
}

uint64_t post_shadow_datastore(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  NSObject *v5;
  const char *v6;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  char *v12;
  const char *v13;
  uint64_t v14;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 40))
  {
    v11 = __si_assert_copy_extra_521(-1);
    v12 = v11;
    v13 = "";
    if (v11)
      v13 = v11;
    __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 1567, "!ctx->syncDirtyChunks", v13);
    free(v12);
    if (__valid_fs(-1))
      v14 = 2989;
    else
      v14 = 3072;
    *(_DWORD *)v14 = -559038737;
    abort();
  }
  v2 = si_set_obj_state_locked(*(_QWORD *)(a1 + 32), 0, 4);
  if ((_DWORD)v2)
  {
    v3 = v2;
    v4 = *__error();
    v5 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315650;
      v16 = "post_shadow_datastore";
      v17 = 1024;
      v18 = 1571;
      v19 = 1024;
      v20 = v3;
      v6 = "%s:%d: si_set_index_state err:%d";
LABEL_17:
      _os_log_error_impl(&dword_1B8270000, v5, OS_LOG_TYPE_ERROR, v6, buf, 0x18u);
    }
  }
  else
  {
    v7 = db_commit_shadow_datastore(*(_QWORD *)(a1 + 24));
    if ((_DWORD)v7)
    {
      v3 = v7;
      v4 = *__error();
      v5 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315650;
        v16 = "post_shadow_datastore";
        v17 = 1024;
        v18 = 1577;
        v19 = 1024;
        v20 = v3;
        v6 = "%s:%d: db_commit_shadow_datastore err:%d";
        goto LABEL_17;
      }
    }
    else
    {
      v3 = db_store_dirty_chunk_info(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 1184), *(unsigned int *)(*(_QWORD *)(a1 + 32) + 32), 1, 0);
      v9 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 6624);
      if (!v9)
        return v3;
      v10 = commitShadowReverseStore(v9);
      if (!(_DWORD)v10)
      {
        v3 = reverseStoreStoreDirtyBitmap(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 6624));
        if (!(_DWORD)v3)
          return v3;
        v4 = *__error();
        v5 = _SILogForLogForCategory(0);
        if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
          goto LABEL_7;
        *(_DWORD *)buf = 136315650;
        v16 = "post_shadow_datastore";
        v17 = 1024;
        v18 = 1588;
        v19 = 1024;
        v20 = v3;
        v6 = "%s:%d: reverseStoreStoreDirtyBitmap err:%d";
        goto LABEL_17;
      }
      v3 = v10;
      v4 = *__error();
      v5 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315650;
        v16 = "post_shadow_datastore";
        v17 = 1024;
        v18 = 1585;
        v19 = 1024;
        v20 = v3;
        v6 = "%s:%d: commitShadowReverseStore err:%d";
        goto LABEL_17;
      }
    }
  }
LABEL_7:
  *__error() = v4;
  return v3;
}

uint64_t commit_shadow(uint64_t a1)
{
  char *v2;
  char *v3;
  const char *v4;
  uint64_t v5;

  if (*(_BYTE *)(a1 + 40))
  {
    v2 = __si_assert_copy_extra_521(-1);
    v3 = v2;
    v4 = "";
    if (v2)
      v4 = v2;
    __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 1598, "!ctx->syncDirtyChunks", v4);
    free(v3);
    if (__valid_fs(-1))
      v5 = 2989;
    else
      v5 = 3072;
    *(_DWORD *)v5 = -559038737;
    abort();
  }
  db_commit_shadow_complete_datastore(*(_QWORD *)(a1 + 24));
  return 0;
}

uint64_t retire_docs(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t (*v12)(uint64_t, _QWORD, _QWORD *);
  _QWORD v14[9];
  __int128 v15;
  uint64_t v16;

  v3 = a2[7];
  v2 = a2[8];
  v5 = a2[4];
  v4 = a2[5];
  v7 = *a2;
  v6 = a2[1];
  v8 = a2[3];
  v9 = a2[6];
  v10 = a2[12];
  v12 = *(uint64_t (**)(uint64_t, _QWORD, _QWORD *))(a1 + 8);
  v11 = *(_QWORD *)(a1 + 16);
  v14[0] = a2[2];
  v14[1] = v4;
  v14[2] = v2;
  v14[3] = v6;
  v14[4] = v5;
  v14[5] = v3;
  v14[6] = v7;
  v14[7] = v8;
  v14[8] = v9;
  v15 = *((_OWORD *)a2 + 5);
  v16 = v10;
  return v12(v11, 0, v14);
}

_QWORD *store_stream_write_vint(_QWORD *result)
{
  uint64_t v1;
  _OWORD v2[2];
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  v1 = result[5];
  if ((unint64_t)(result[4] - v1) < 0xB)
  {
    memset(v2, 0, sizeof(v2));
    return (_QWORD *)store_stream_write_bytes((uint64_t)result, (char *)v2, 1uLL);
  }
  else
  {
    *(_BYTE *)(result[6] + v1) = 0;
    result[5] = v1 + 1;
  }
  return result;
}

uint64_t __sync_datastore_block_invoke(uint64_t result, signed int a2, uint64_t a3, signed int a4, uint64_t a5)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  size_t v14;
  uint64_t v15;
  size_t v16;
  size_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  size_t v23;
  __int128 *v24;
  size_t v25;
  size_t v26;
  __int128 *__src;
  __int128 v28;
  __int128 v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  if (a4)
  {
    v9 = result;
    store_stream_write_vint32((_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24), a2);
    if (a2 >= 1)
    {
      v10 = 0;
      v11 = a2;
      do
      {
        v12 = *(_QWORD *)(*(_QWORD *)(v9 + 32) + 8);
        v13 = *(_QWORD *)(a3 + 8 * v10);
        v14 = *(_QWORD *)(v12 + 56);
        v15 = *(_QWORD *)(v12 + 64);
        if (v14 - v15 < 0xB)
        {
          v28 = 0u;
          v29 = 0u;
          __src = &v28;
          v16 = writeVInt64((uint64_t)&v28, 0, v13);
          if (v16 + v15 >= v14)
          {
            __src = &v28;
            while (1)
            {
              v17 = v14 - v15;
              memcpy((void *)(*(_QWORD *)(v12 + 72) + v15), __src, v17);
              *(_QWORD *)(v12 + 64) += v17;
              if (store_stream_flush((unsigned int *)(v12 + 24), 0))
                break;
              __src = (__int128 *)((char *)__src + v17);
              v16 -= v17;
              v14 = *(_QWORD *)(v12 + 56);
              v15 = *(_QWORD *)(v12 + 64);
              if (v15 + v16 < v14)
                goto LABEL_9;
            }
          }
          else
          {
LABEL_9:
            memcpy((void *)(*(_QWORD *)(v12 + 72) + v15), __src, v16);
            *(_QWORD *)(v12 + 64) += v16;
          }
        }
        else
        {
          *(_QWORD *)(v12 + 64) = writeVInt64(*(_QWORD *)(v12 + 72), *(_QWORD *)(v12 + 64), v13);
        }
        ++v10;
      }
      while (v10 != v11);
    }
    result = (uint64_t)store_stream_write_vint32((_QWORD *)(*(_QWORD *)(*(_QWORD *)(v9 + 32) + 8) + 24), a4);
    if (a4 >= 1)
    {
      v18 = 0;
      v19 = a4;
      do
      {
        v20 = *(_QWORD *)(*(_QWORD *)(v9 + 32) + 8);
        v21 = *(_QWORD *)(a5 + 8 * v18);
        v23 = *(_QWORD *)(v20 + 56);
        v22 = *(_QWORD *)(v20 + 64);
        if (v23 - v22 < 0xB)
        {
          v28 = 0u;
          v29 = 0u;
          v24 = &v28;
          v25 = writeVInt64((uint64_t)&v28, 0, v21);
          if (v25 + v22 >= v23)
          {
            v24 = &v28;
            while (1)
            {
              v26 = v23 - v22;
              memcpy((void *)(*(_QWORD *)(v20 + 72) + v22), v24, v26);
              *(_QWORD *)(v20 + 64) += v26;
              result = store_stream_flush((unsigned int *)(v20 + 24), 0);
              if ((_DWORD)result)
                break;
              v24 = (__int128 *)((char *)v24 + v26);
              v25 -= v26;
              v23 = *(_QWORD *)(v20 + 56);
              v22 = *(_QWORD *)(v20 + 64);
              if (v22 + v25 < v23)
                goto LABEL_21;
            }
          }
          else
          {
LABEL_21:
            result = (uint64_t)memcpy((void *)(*(_QWORD *)(v20 + 72) + v22), v24, v25);
            *(_QWORD *)(v20 + 64) += v25;
          }
        }
        else
        {
          result = writeVInt64(*(_QWORD *)(v20 + 72), *(_QWORD *)(v20 + 64), v21);
          *(_QWORD *)(v20 + 64) = result;
        }
        ++v18;
      }
      while (v18 != v19);
    }
  }
  return result;
}

_QWORD *store_stream_write_vint32(_QWORD *result, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  _BYTE *v5;
  _BYTE *v6;
  _BYTE *v7;
  size_t v8;
  _OWORD v9[2];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v2 = result[5];
  if ((unint64_t)(result[4] - v2) < 6)
  {
    memset(v9, 0, sizeof(v9));
    if (a2 >> 28)
    {
      LOBYTE(v9[0]) = a2 | 0x80;
      BYTE1(v9[0]) = (a2 >> 7) | 0x80;
      BYTE2(v9[0]) = (a2 >> 14) | 0x80;
      BYTE3(v9[0]) = (a2 >> 21) | 0x80;
      BYTE4(v9[0]) = a2 >> 28;
      v8 = 5;
    }
    else if ((a2 & 0xFE00000) != 0)
    {
      LOBYTE(v9[0]) = a2 | 0x80;
      BYTE1(v9[0]) = (a2 >> 7) | 0x80;
      BYTE2(v9[0]) = (a2 >> 14) | 0x80;
      BYTE3(v9[0]) = (a2 & 0xFE00000) >> 21;
      v8 = 4;
    }
    else if ((a2 & 0x1FC000) != 0)
    {
      LOBYTE(v9[0]) = a2 | 0x80;
      BYTE1(v9[0]) = (a2 >> 7) | 0x80;
      BYTE2(v9[0]) = (a2 & 0x1FC000) >> 14;
      v8 = 3;
    }
    else if ((a2 & 0x3F80) != 0)
    {
      LOBYTE(v9[0]) = a2 | 0x80;
      BYTE1(v9[0]) = (unsigned __int16)(a2 & 0x3F80) >> 7;
      v8 = 2;
    }
    else
    {
      LOBYTE(v9[0]) = a2;
      v8 = 1;
    }
    return (_QWORD *)store_stream_write_bytes((uint64_t)result, (char *)v9, v8);
  }
  else
  {
    v3 = result[6];
    v4 = a2 >> 28;
    if (a2 >> 28)
    {
      v6 = (_BYTE *)(v3 + v2);
      *v6 = a2 | 0x80;
      v6[1] = (a2 >> 7) | 0x80;
      v6[2] = (a2 >> 14) | 0x80;
      v2 += 4;
      v6[3] = (a2 >> 21) | 0x80;
    }
    else if ((a2 & 0xFE00000) != 0)
    {
      v5 = (_BYTE *)(v3 + v2);
      *v5 = a2 | 0x80;
      v5[1] = (a2 >> 7) | 0x80;
      v2 += 3;
      v5[2] = (a2 >> 14) | 0x80;
      v4 = (a2 & 0xFE00000) >> 21;
    }
    else if ((a2 & 0x1FC000) != 0)
    {
      v7 = (_BYTE *)(v3 + v2);
      *v7 = a2 | 0x80;
      v2 += 2;
      v7[1] = (a2 >> 7) | 0x80;
      v4 = (a2 & 0x1FC000) >> 14;
    }
    else if ((a2 & 0x3F80) != 0)
    {
      *(_BYTE *)(v3 + v2++) = a2 | 0x80;
      v4 = (unsigned __int16)(a2 & 0x3F80) >> 7;
    }
    else
    {
      LOBYTE(v4) = a2;
    }
    *(_BYTE *)(v3 + v2) = v4;
    result[5] = v2 + 1;
  }
  return result;
}

void deleteStaleOverlay(int a1)
{
  char *v1;
  char *v2;

  v1 = (char *)fd_create_protected(a1, "dirStore.overlay", 1026, 0);
  if (v1)
  {
    v2 = v1;
    _fd_unlink_with_origin((uint64_t)v1, 0);
    fd_release(v2);
  }
}

uint64_t __si_indexDeleteByOid_block_invoke(uint64_t a1, uint64_t a2)
{
  _CIDeleteByOidsBulk(a2, *(_QWORD *)(a1 + 32));
  return 1;
}

uint64_t attrsKeyValueMatchesString(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, uint64_t a5)
{
  uint64_t result;
  const void *Value;

  result = _MDPlistDictionaryGetPlistObjectForKey();
  if ((_DWORD)result)
  {
    result = 0;
    if (_MDPlistGetPlistObjectType() == 244)
    {
      Value = (const void *)_MDPlistStringGetValue();
      if (!a5 && !memcmp(Value, a4, 0))
        return 1;
    }
  }
  return result;
}

uint64_t attrsKeyValueEnabled()
{
  uint64_t result;
  int PlistObjectType;

  result = _MDPlistDictionaryGetPlistObjectForKey();
  if ((_DWORD)result)
  {
    PlistObjectType = _MDPlistGetPlistObjectType();
    if (PlistObjectType > 225)
    {
      if ((PlistObjectType - 226) > 1)
        return 0;
    }
    else if (PlistObjectType != 35 && PlistObjectType != 51)
    {
      return PlistObjectType == 225 && _MDPlistBooleanGetValue();
    }
    return _MDPlistNumberGetIntValue() != 0;
  }
  return result;
}

uint64_t SIPersistClientStateAndMeta(uint64_t a1, char a2)
{
  unsigned int v3;
  uint64_t result;
  BOOL v5;
  int v6;
  BOOL v7;
  const __CFData *v8;
  const __CFData *v9;
  char *v10;
  char *v11;
  CFIndex Length;
  const UInt8 *BytePtr;
  uint64_t v14;
  int v15;
  NSObject *v16;
  int *v17;
  char *v18;
  const char *v19;
  int v20;
  NSObject *v21;
  int v22;
  NSObject *v23;
  int *v24;
  int *v25;
  char *v26;
  int *v27;
  char *v28;
  CFErrorRef error;
  uint8_t buf[4];
  const char *v31;
  __int16 v32;
  int v33;
  __int16 v34;
  CFErrorRef v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)(a1 + 2072) || (*(_BYTE *)(a1 + 829) & 0x10) != 0)
    return 1;
  if ((a2 & 1) != 0
    || ((v3 = *(_DWORD *)(a1 + 60) >> 1, result = 1, v5 = v3 > 7, v6 = (1 << v3) & 0x86, !v5)
      ? (v7 = v6 == 0)
      : (v7 = 1),
        !v7))
  {
    error = 0;
    v8 = CFPropertyListCreateData((CFAllocatorRef)*MEMORY[0x1E0C9AE00], *(CFPropertyListRef *)(a1 + 72), kCFPropertyListXMLFormat_v1_0, 0, &error);
    v9 = v8;
    if (error || !v8 || !CFDataGetBytePtr(v8) || !CFDataGetLength(v9))
    {
      v20 = *__error();
      v21 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315650;
        v31 = "SIPersistClientStateAndMeta";
        v32 = 1024;
        v33 = 4738;
        v34 = 2112;
        v35 = error;
        _os_log_error_impl(&dword_1B8270000, v21, OS_LOG_TYPE_ERROR, "%s:%d: client state meta convert to CFData failed: %@", buf, 0x1Cu);
      }
      *__error() = v20;
      CFRelease(error);
      if (v9)
        CFRelease(v9);
      return 0;
    }
    v10 = (char *)fd_create_protected(*(_DWORD *)(a1 + 32), "clientstatesmetafile.tmp", 536872450, 3u);
    if (v10)
    {
      v11 = v10;
      Length = CFDataGetLength(v9);
      BytePtr = CFDataGetBytePtr(v9);
      v14 = fd_write((uint64_t)v11, (uint64_t)BytePtr, Length);
      CFRelease(v9);
      if (v14 != Length)
      {
        v15 = *__error();
        v16 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          v27 = __error();
          v28 = strerror(*v27);
          *(_DWORD *)buf = 136315650;
          v31 = "SIPersistClientStateAndMeta";
          v32 = 1024;
          v33 = 4751;
          v34 = 2080;
          v35 = (CFErrorRef)v28;
          v19 = "%s:%d: write client state meta tmp file failed: %s";
          goto LABEL_31;
        }
LABEL_26:
        *__error() = v15;
        fd_release(v11);
        return 0;
      }
      if (fd_rename((uint64_t)v11, "clientstatesmetafile"))
      {
        v15 = *__error();
        v16 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          v17 = __error();
          v18 = strerror(*v17);
          *(_DWORD *)buf = 136315650;
          v31 = "SIPersistClientStateAndMeta";
          v32 = 1024;
          v33 = 4757;
          v34 = 2080;
          v35 = (CFErrorRef)v18;
          v19 = "%s:%d: rename client state meta tmp file failed: %s";
LABEL_31:
          _os_log_error_impl(&dword_1B8270000, v16, OS_LOG_TYPE_ERROR, v19, buf, 0x1Cu);
          goto LABEL_26;
        }
        goto LABEL_26;
      }
      fd_release(v11);
      return 1;
    }
    CFRelease(v9);
    v22 = *__error();
    v23 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      v25 = __error();
      v26 = strerror(*v25);
      *(_DWORD *)buf = 136315650;
      v31 = "SIPersistClientStateAndMeta";
      v32 = 1024;
      v33 = 4767;
      v34 = 2080;
      v35 = (CFErrorRef)v26;
      _os_log_error_impl(&dword_1B8270000, v23, OS_LOG_TYPE_ERROR, "%s:%d: open client state meta tmp file failed: %s", buf, 0x1Cu);
    }
    v24 = __error();
    result = 0;
    *v24 = v22;
  }
  return result;
}

uint64_t _SIProtectionClass(uint64_t a1)
{
  return *(_DWORD *)(a1 + 60) >> 1;
}

void remap_update_callback(uint64_t a1, _QWORD *a2)
{
  *(_QWORD *)(a2[1] + 24) = *a2;
}

void si_compact_lock(uint64_t a1)
{
  unsigned int *v2;
  unsigned int v3;
  unsigned int v4;

  if (a1)
  {
    pthread_mutex_lock(&mergeMutex);
    *(_BYTE *)(a1 + 2435) = 0;
    if (*(_DWORD *)(a1 + 2428))
      pthread_cond_signal(&mergeCond);
    pthread_mutex_unlock(&mergeMutex);
    si_scheduler_suspend(*(_QWORD *)(a1 + 896));
    si_scheduler_suspend(*(_QWORD *)(a1 + 864));
    v2 = (unsigned int *)(a1 + 1452);
    do
      v3 = __ldaxr(v2);
    while (__stlxr(v3 + 1, v2));
    si_scheduler_suspend(*(_QWORD *)(a1 + 872));
    do
      v4 = __ldaxr(v2);
    while (__stlxr(v4 - 1, v2));
    si_scheduler_suspend(*(_QWORD *)(a1 + 880));
    si_scheduler_suspend(*(_QWORD *)(a1 + 928));
    si_scheduler_suspend(*(_QWORD *)(a1 + 936));
  }
}

uint64_t si_compact_unlock(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    v1 = result;
    pthread_mutex_lock(&mergeMutex);
    *(_BYTE *)(v1 + 2435) = 1;
    pthread_mutex_unlock(&mergeMutex);
    si_scheduler_resume(*(_QWORD *)(v1 + 936), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 6220);
    si_scheduler_resume(*(_QWORD *)(v1 + 928), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 6221);
    si_scheduler_resume(*(_QWORD *)(v1 + 880), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 6222);
    si_scheduler_resume(*(_QWORD *)(v1 + 872), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 6223);
    si_scheduler_resume(*(_QWORD *)(v1 + 864), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 6224);
    return si_scheduler_resume(*(_QWORD *)(v1 + 896), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 6225);
  }
  return result;
}

BOOL si_compact_cancel(uint64_t a1)
{
  si_suspend_if_bad_time(a1);
  return *(_DWORD *)(a1 + 2428) != 0;
}

uint64_t si_suspend_if_bad_time(uint64_t result)
{
  uint64_t v1;

  if (sInGameMode)
  {
    v1 = result;
    pthread_mutex_lock(&sGameModeMutex);
    while (sInGameMode)
    {
      if (*(_DWORD *)(v1 + 2428))
        break;
      if (*(_BYTE *)(v1 + 2432))
        break;
      pthread_cond_wait(&sGameModeCond, &sGameModeMutex);
    }
    return pthread_mutex_unlock(&sGameModeMutex);
  }
  return result;
}

void si_cleanup(uint64_t a1, uint64_t a2)
{
  unsigned int *v4;
  uint64_t v5;
  void *v6[4];

  v4 = (unsigned int *)malloc_type_malloc(0x28uLL, 0x10A0040A9CEF559uLL);
  v5 = 0;
  *((_QWORD *)v4 + 1) = a1;
  *((_QWORD *)v4 + 2) = a2;
  atomic_store(1u, v4);
  *((_QWORD *)v4 + 3) = 0;
  *((_QWORD *)v4 + 4) = DeallocContentIndexList;
  do
  {
    si_enqueue_cleanup_if_busy(*(_QWORD *)(a1 + 1008 + v5), (uint64_t)v4);
    v5 += 8;
  }
  while (v5 != 136);
  v6[0] = v4;
  memset(&v6[1], 0, 24);
  si_collect_inner(v6);
}

void DeallocContentIndexList(os_unfair_lock_s *a1, void **a2, uint64_t a3, int a4)
{
  os_unfair_lock_s *v5;

  if (a4)
  {
    ContentIndexListFree(a2);
  }
  else
  {
    v5 = a1 + 1645;
    os_unfair_lock_lock(a1 + 1645);
    ContentIndexListFree(a2);
    os_unfair_lock_unlock(v5);
  }
}

void _SIScanQueuesDrained(uint64_t a1)
{
  _QWORD *v2;

  if (a1)
  {
    if (*(_QWORD *)(a1 + 1048))
    {
      v2 = malloc_type_malloc(0x20uLL, 0x10A0040D5506429uLL);
      v2[1] = a1;
      v2[2] = _fullyDrained;
      *v2 = a1;
      *((_DWORD *)v2 + 6) = 0;
      si_enqueue_work_with_qos(*(_QWORD *)(a1 + 1096), 5, (uint64_t)delayed_op0, (uint64_t)v2);
    }
  }
}

int *_fullyDrained(int *result, int a2)
{
  int *v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;

  if (!a2)
  {
    v2 = result;
    if (!*((_BYTE *)result + 2438))
    {
      *((_BYTE *)result + 2438) = 1;
      v3 = *((_QWORD *)result + 173);
      LODWORD(v4) = *(_DWORD *)(v3 + 8);
      if (v4 >= 3)
      {
        v5 = 0;
        do
        {
          ContentIndexSetEmergency(*(int **)(*(_QWORD *)v3 + 8 * v5), 0);
          v6 = v5 + 3;
          ++v5;
          v4 = *(unsigned int *)(v3 + 8);
        }
        while (v6 < v4);
      }
      result = *(int **)(*(_QWORD *)v3 + 8 * (v4 - 1));
      if (result)
      {
        if (*((_BYTE *)result + 36))
        {
          ContentIndexSetEmergency(result, 0);
          _SIIssueSplit((uint64_t)v2, 1);
          return SIInitialIndexingEnded(v2, 0);
        }
      }
    }
  }
  return result;
}

void delayed_op3(uint64_t a1, int a2)
{
  void *v3;

  if (a2)
  {
    (*(void (**)(_QWORD))(a1 + 16))(*(_QWORD *)a1);
    free((void *)a1);
  }
  else
  {
    if (*(_DWORD *)(a1 + 24) == 4)
      v3 = delayed_op_final;
    else
      v3 = delayed_op4;
    si_enqueue_work_with_qos(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 1056), 5, (uint64_t)v3, a1);
  }
}

void delayed_op4(_QWORD *a1, int a2)
{
  uint64_t v3;

  if (!a2 && (v3 = a1[1], (*(_BYTE *)(v3 + 6584) & 0x10) != 0))
  {
    si_enqueue_work_with_qos(*(_QWORD *)(v3 + 1088), 5, (uint64_t)delayed_op_final, (uint64_t)a1);
  }
  else
  {
    ((void (*)(_QWORD))a1[2])(*a1);
    free(a1);
  }
}

void _SIIssueSplit(uint64_t a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  NSObject *v7;
  os_log_type_t v8;
  void *v9;
  _DWORD *LiveIndex;
  int v11;
  uint8_t v12[16];

  if (a2)
  {
    v4 = *(_QWORD *)(a1 + 1384);
    if (!v4 || !*(_DWORD *)(v4 + 8))
      return;
  }
  else
  {
    v5 = *(_QWORD *)(a1 + 1392);
    if (!v5 || !*(_DWORD *)(v5 + 8) || !*(_DWORD *)(a1 + 1232))
      return;
  }
  v6 = *__error();
  v7 = _SILogForLogForCategory(4);
  v8 = 2 * (dword_1EF19FC9C < 4);
  if (os_log_type_enabled(v7, v8))
  {
    *(_WORD *)v12 = 0;
    _os_log_impl(&dword_1B8270000, v7, v8, "_SIIssueSplit called", v12, 2u);
  }
  *__error() = v6;
  v9 = malloc_type_calloc(1uLL, 0x60uLL, 0x10B0040E0DE4348uLL);
  *(_QWORD *)v9 = a1;
  if (a2)
    LiveIndex = si_getLiveIndex(*(_QWORD *)(a1 + 1384));
  else
    LiveIndex = si_getSyncIndex(a1, 0);
  *((_QWORD *)v9 + 1) = LiveIndex;
  v11 = LiveIndex[12];
  *((_DWORD *)v9 + 4) = 2;
  *((_DWORD *)v9 + 5) = v11;
  si_scheduler_async_suspend_and_enqueue(*(_QWORD *)(a1 + 872), *(_QWORD *)(a1 + 1040), (uint64_t)_swapIndex, (uint64_t)v9, (unsigned int **)v9 + 11);
}

int *SIInitialIndexingEnded(int *result, int a2)
{
  uint64_t v3;
  uint64_t v4;
  __n128 v5;
  uint64_t v6;
  int v7;
  NSObject *v8;
  os_log_type_t v9;
  int v10;
  BOOL v11;
  _BYTE *v12;
  uint64_t v13;
  uint64_t (*v14)(_QWORD, const char *, uint64_t, const char *, __n128);
  uint8_t buf[4];
  _BYTE *v16;
  _BYTE v17[1024];
  uint64_t v18;

  v3 = (uint64_t)result;
  v18 = *MEMORY[0x1E0C80C00];
  if (a2 == -1 && *((_QWORD *)result + 860) && *((_BYTE *)result + 6893))
    return (int *)SISyncIndex((uint64_t)result);
  if ((result[207] & 4) == 0)
  {
    bzero(v17, 0x400uLL);
    v5 = (__n128)si_sync_ctx_create_with_defer_fd(v3, 0);
    v6 = v4;
    *(_DWORD *)(v4 + 80) = a2;
    if (!*(_QWORD *)(v4 + 128) && !*(_DWORD *)(v4 + 104))
    {
      v13 = *(_QWORD *)(v3 + 2360);
      if (v13)
      {
        v14 = *(uint64_t (**)(_QWORD, const char *, uint64_t, const char *, __n128))(v13 + 64);
        if (v14)
          *(_DWORD *)(v4 + 104) = v14(*(_QWORD *)(v13 + 136), "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 19773, "void SIInitialIndexingEnded(SIRef, int32_t)", v5);
      }
    }
    si_enqueue_work_with_qos(*(_QWORD *)(v3 + 1096), 9, (uint64_t)si_initialIndexingEndedQueueOnHold, v6);
    v7 = *__error();
    v8 = _SILogForLogForCategory(0);
    v9 = 2 * (gSILogLevels[0] < 4);
    if (os_log_type_enabled(v8, v9))
    {
      v10 = fcntl(*(_DWORD *)(v3 + 48), 50, v17);
      if (v17[0])
        v11 = v10 < 0;
      else
        v11 = 1;
      if (v11)
        v12 = 0;
      else
        v12 = v17;
      *(_DWORD *)buf = 136315138;
      v16 = v12;
      _os_log_impl(&dword_1B8270000, v8, v9, "Finished initial indexing of %s", buf, 0xCu);
    }
    result = __error();
    *result = v7;
  }
  return result;
}

void si_initialIndexingEndedQueueOnHold(char *a1, int a2)
{
  char *v3;
  uint64_t v4;
  uint64_t v5;

  v3 = a1;
  if (!a2)
  {
    v4 = *(_QWORD *)a1;
    v5 = *(_QWORD *)(*(_QWORD *)a1 + 1152);
    if (v5)
    {
      if (!*(_BYTE *)(v4 + 2072) && !*(_BYTE *)(v4 + 2437))
      {
        attachJournal(v3);
        v5 = *(_QWORD *)(v4 + 1152);
      }
      si_enqueue_barrier_with_qos(v5, 9, (uint64_t)si_initialIndexingEndedQueueOnSet, (uint64_t)v3);
      v3 = 0;
    }
  }
  si_sync_ctx_free((uint64_t)v3, a2 != 0);
}

char *attachJournal(char *result)
{
  char *v1;
  int v2;
  unsigned int v3;
  unsigned int v4;

  v1 = result;
  do
    v2 = __ldaxr(journalsEnqueued);
  while (__stlxr(v2 + 1, journalsEnqueued));
  if (v2 >= 16 || (result = *(char **)result, *(_DWORD *)(*(_QWORD *)v1 + 6964)))
  {
    do
      v3 = __ldaxr(journalsEnqueued);
    while (__stlxr(v3 - 1, journalsEnqueued));
  }
  else
  {
    result = getJournalFd((uint64_t)result, 1, 1);
    *((_QWORD *)v1 + 8) = result;
    if (result)
    {
      *((_DWORD *)v1 + 14) = 2549;
    }
    else
    {
      do
        v4 = __ldaxr(journalsEnqueued);
      while (__stlxr(v4 - 1, journalsEnqueued));
    }
  }
  return result;
}

void si_initialIndexingEndedQueueOnSet(uint64_t a1, int a2)
{
  uint64_t v3;

  v3 = a1;
  if (!a2)
  {
    si_enqueue_barrier_with_qos(*(_QWORD *)(*(_QWORD *)a1 + 1048), 9, (uint64_t)si_initialIndexingEndedQueueOnFlush, a1);
    v3 = 0;
  }
  si_sync_ctx_free(v3, a2 != 0);
}

void si_initialIndexingEndedQueueOnFlush(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  char v9;
  __int128 *v10;
  _QWORD *v11;
  unint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  unsigned int *v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  _QWORD *v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  char v25;
  unint64_t v26;
  unsigned int v27;
  char v28;
  uint64_t v29;
  char v30;
  _OWORD *v31;
  uint64_t v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  uint64_t v39;
  uint64_t (*v40)(_QWORD, const char *, uint64_t, const char *);
  int v41;
  NSObject *v42;
  os_log_type_t v43;
  BOOL v44;
  int v45;
  char *v46;
  char *v47;
  const char *v48;
  uint64_t v49;
  unsigned int v50;
  uint8_t buf[12];
  unsigned int v52;

  v3 = a1;
  if (a2)
    goto LABEL_58;
  v4 = *(_QWORD *)a1;
  v5 = *(unsigned int *)(a1 + 80);
  v52 = 0;
  if (!fd_setDir(*(unsigned int *)(v4 + 32), (int *)&v52))
    goto LABEL_58;
  *(_BYTE *)(v4 + 2436) = 0;
  v6 = *(_QWORD *)(v4 + 1392);
  v7 = *(_DWORD *)(v6 + 8);
  if (v7)
  {
    v8 = *(_QWORD *)(*(_QWORD *)v6 + 8 * (v7 - 1));
    v9 = atomic_load((unsigned int *)(v8 + 28));
    if ((v9 & 3) == 0 && !*(_BYTE *)(v8 + 15163))
    {
      *(_DWORD *)(*(_QWORD *)(v4 + 1392) + 16) = -1;
      while (1)
      {
        v10 = *(__int128 **)(v4 + 1392);
        v11 = ContentIndexListClone(v10);
        *((_DWORD *)v11 + 4) = -1;
        if (si_swapIndexSet((int *)v4, (uint64_t)v10, (unint64_t)v11, (unint64_t *)(v4 + 1392)))break;
        ContentIndexListFree((void **)v11);
      }
      _CIDisableUpdates(*(_QWORD *)(*v11 + 8 * (*((_DWORD *)v11 + 2) - 1)));
    }
  }
  v12 = (unint64_t *)(v4 + 1384);
  if ((_DWORD)v5 == 1)
  {
    si_perform_livequeries_bulk_updates(v4);
LABEL_42:
    v16 = 0;
    goto LABEL_43;
  }
  v13 = *v12;
  LODWORD(v14) = *(_DWORD *)(*v12 + 16);
  if ((v14 & 0x80000000) != 0)
    goto LABEL_42;
  v15 = 0;
  v16 = 0;
  v17 = (unsigned int *)(v4 + 1400);
LABEL_14:
  do
  {
    if (v15 >= *(_DWORD *)(v13 + 8) - 1)
      break;
    v18 = *(_QWORD *)(*(_QWORD *)v13 + 8 * v15);
    if (*(_BYTE *)(v18 + 36) || (_DWORD)v5 && (int)v5 < *(_DWORD *)(v18 + 32))
      break;
    ++v16;
    if (v15 == v14)
    {
      v19 = v16;
      v20 = v5;
      v21 = ContentIndexListClone((__int128 *)v13);
      v22 = v21;
      do
      {
        v23 = *((int *)v21 + 4) + 1;
        *((_DWORD *)v21 + 4) = v23;
        if ((int)v23 >= *((_DWORD *)v21 + 2))
          break;
        v24 = *(_QWORD *)(*v21 + 8 * v23);
        v25 = atomic_load((unsigned int *)(v24 + 28));
      }
      while ((v25 & 3) != 0 || *(_BYTE *)(v24 + 15163));
      while (1)
      {
        v26 = __ldaxr(v12);
        if (v26 != v13)
          break;
        if (!__stlxr((unint64_t)v21, v12))
        {
          si_cleanup(v4, v13);
          do
            v27 = __ldxr(v17);
          while (__stxr(v27 + 1, v17));
          _si_log_indexes((int *)v4);
          v18 = *(_QWORD *)(*v22 + 8 * v15);
          v13 = (uint64_t)v22;
          v5 = v20;
          v16 = v19;
          goto LABEL_28;
        }
      }
      __clrex();
      free((void *)*v21);
      free(v22);
      v15 = 0;
      v13 = *v12;
      LODWORD(v14) = *(_DWORD *)(*v12 + 16);
      v5 = v20;
      v16 = v19;
      if ((v14 & 0x80000000) == 0)
        goto LABEL_14;
      break;
    }
LABEL_28:
    v28 = atomic_load((unsigned int *)(v18 + 28));
    if ((v28 & 3) == 0 && !*(_BYTE *)(v18 + 15163))
    {
      v50 = v5;
      _CIDisableUpdates(*(_QWORD *)(*(_QWORD *)v13 + 8 * v15));
      si_perform_livequeries_bulk_updates(v4);
      v29 = *(_QWORD *)(*(_QWORD *)v13 + 8 * *(int *)(v13 + 16));
      v30 = atomic_load((unsigned int *)(v29 + 28));
      if ((v30 & 3) != 0 || *(_BYTE *)(v29 + 15163))
      {
        v46 = __si_assert_copy_extra_521(-1);
        v47 = v46;
        v48 = "";
        if (v46)
          v48 = v46;
        __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 8804, "ContentIndexWritable(indexSet->index[indexSet->currentIndex])", v48);
        free(v47);
        if (__valid_fs(-1))
          v49 = 2989;
        else
          v49 = 3072;
        *(_DWORD *)v49 = -559038737;
        abort();
      }
      v31 = malloc_type_calloc(1uLL, 0x90uLL, 0x10B00402663C8FFuLL);
      v32 = (uint64_t)v31;
      *v31 = *(_OWORD *)v3;
      v33 = *(_OWORD *)(v3 + 64);
      v35 = *(_OWORD *)(v3 + 16);
      v34 = *(_OWORD *)(v3 + 32);
      v31[3] = *(_OWORD *)(v3 + 48);
      v31[4] = v33;
      v31[1] = v35;
      v31[2] = v34;
      v36 = *(_OWORD *)(v3 + 128);
      v38 = *(_OWORD *)(v3 + 80);
      v37 = *(_OWORD *)(v3 + 96);
      v31[7] = *(_OWORD *)(v3 + 112);
      v31[8] = v36;
      v31[5] = v38;
      v31[6] = v37;
      *(_DWORD *)(v3 + 104) = 0;
      *(_QWORD *)(v3 + 120) = 0;
      *(_QWORD *)(v3 + 128) = 0;
      *(_QWORD *)(v3 + 112) = 0;
      *((_QWORD *)v31 + 1) = *(_QWORD *)(*(_QWORD *)v13 + 8 * v15);
      *(_QWORD *)(v3 + 64) = 0;
      if (!*((_QWORD *)v31 + 16) && !*((_DWORD *)v31 + 26))
      {
        v39 = *(_QWORD *)(v4 + 2360);
        if (v39)
        {
          v40 = *(uint64_t (**)(_QWORD, const char *, uint64_t, const char *))(v39 + 64);
          if (v40)
            *((_DWORD *)v31 + 26) = v40(*(_QWORD *)(v39 + 136), "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 8810, "void si_initialIndexingEndedQueueOnFlush(si_sync_ctx *, Boolean)");
        }
      }
      si_indexDeleteDeferredItems(*(_QWORD *)v3);
      si_enqueue_work_with_qos(*(_QWORD *)(v4 + 1040), 9, (uint64_t)si_scanEnded, v32);
      v5 = v50;
    }
    v14 = *(int *)(v13 + 16);
    v44 = v15++ < v14;
  }
  while (v44);
LABEL_43:
  v41 = *__error();
  v42 = _SILogForLogForCategory(4);
  v43 = 2 * (dword_1EF19FC9C < 4);
  if (os_log_type_enabled(v42, v43))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1B8270000, v42, v43, "Advanced transaction id", buf, 2u);
  }
  *__error() = v41;
  if ((_DWORD)v5 == 1)
  {
    if (*(_DWORD *)(*(_QWORD *)(v4 + 1392) + 8))
      v44 = 0;
    else
      v44 = v16 <= 2;
    if (v44)
      goto LABEL_54;
    goto LABEL_53;
  }
  if (v16 >= 3)
  {
LABEL_53:
    si_enqueue_work_with_qos(*(_QWORD *)(v4 + 1040), 9, (uint64_t)si_initialIndexingEnded, v3);
    v3 = 0;
  }
LABEL_54:
  if (!*(_DWORD *)(*v12 + 8))
    SISetScanCount(v4, (const char *)1, 1);
  v45 = v52;
  MEMORY[0x1BCCB1484](v52);
  if ((v45 & 0x80000000) == 0)
    close(v45);
LABEL_58:
  si_sync_ctx_free(v3, a2 != 0);
}

int *_si_log_indexes(int *result)
{
  int *v1;
  uint64_t v2;

  if (result)
  {
    v1 = result;
    v2 = *((_QWORD *)result + 173);
    if (v2)
      ContentIndexListDump(v2);
    result = (int *)*((_QWORD *)v1 + 174);
    if (result)
      return ContentIndexListDump((uint64_t)result);
  }
  return result;
}

void si_scanEnded(uint64_t *a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  void (*v6)(uint64_t, _QWORD);
  uint64_t v7;
  int v8;
  uint64_t v9;
  void (*v10)(uint64_t, _QWORD, const __CFString *, _QWORD *);
  uint64_t v11;
  _QWORD v12[4];
  int v13;

  if (!a2)
  {
    v4 = *a1;
    if (**(_QWORD **)(*a1 + 1392))
    {
      v5 = *(_QWORD *)(v4 + 1416);
      if (v5)
      {
        v6 = *(void (**)(uint64_t, _QWORD))(v5 + 88);
        if (v6)
        {
          if (!*(_BYTE *)(v5 + 240))
            v6(v5, *(_QWORD *)(v5 + 24));
        }
      }
      si_sync_ctx_create_with_defer_fd(v4, 0);
      *(_QWORD *)(v7 + 64) = a1[8];
      a1[8] = 0;
      syncIndex(v7, 0);
      v8 = *(_DWORD *)(a1[1] + 48);
      if (gSISystemOnBattery
        && (v9 = *(_QWORD *)(v4 + 2360)) != 0
        && (v10 = *(void (**)(uint64_t, _QWORD, const __CFString *, _QWORD *))(v9 + 80)) != 0)
      {
        v11 = *(_QWORD *)(v9 + 136);
        v12[0] = MEMORY[0x1E0C809B0];
        v12[1] = 0x40000000;
        v12[2] = __si_scanEnded_block_invoke;
        v12[3] = &__block_descriptor_tmp_678;
        v13 = v8;
        v10(v11, 0, CFSTR("ScanEnded"), v12);
      }
      else
      {
        setupAndIssueMergeScan(v4, v8, 0, 0, 0);
      }
    }
  }
  si_sync_ctx_free((uint64_t)a1, a2 != 0);
}

void si_initialIndexingEnded(uint64_t a1, int a2)
{
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  void (*v9)(uint64_t, _QWORD, const __CFString *, _QWORD *);
  uint64_t v10;
  _QWORD v11[4];
  int v12;

  if (!a2)
  {
    v4 = *(uint64_t **)a1;
    if (**(_QWORD **)(*(_QWORD *)a1 + 1392))
    {
      si_sync_ctx_create_with_defer_fd(*(_QWORD *)a1, 0);
      *(_QWORD *)(v5 + 64) = *(_QWORD *)(a1 + 64);
      *(_DWORD *)(v5 + 56) = 8478;
      *(_QWORD *)(a1 + 64) = 0;
      syncIndex(v5, 0);
      v6 = db_shrink_cache(v4[148]);
      if ((_DWORD)v6)
      {
        si_makeUnavailable((uint64_t)v4, v6, 0, 4, (uint64_t)"Failure in db_shrink_cache at si_initialIndexingEnded");
      }
      else
      {
        v7 = *(_DWORD *)(a1 + 80);
        if (gSISystemOnBattery
          && (v8 = v4[295]) != 0
          && (v9 = *(void (**)(uint64_t, _QWORD, const __CFString *, _QWORD *))(v8 + 80)) != 0)
        {
          v10 = *(_QWORD *)(v8 + 136);
          v11[0] = MEMORY[0x1E0C809B0];
          v11[1] = 0x40000000;
          v11[2] = __si_initialIndexingEnded_block_invoke;
          v11[3] = &__block_descriptor_tmp_682;
          v12 = v7;
          v9(v10, 0, CFSTR("InitialIndexingEnded"), v11);
        }
        else
        {
          setupAndIssueMerge(v4, v7, 0, 0, 0);
        }
      }
    }
  }
  si_sync_ctx_free(a1, a2 != 0);
}

uint64_t SISetScanCount(uint64_t a1, const char *a2, int a3)
{
  os_unfair_lock_s *v6;
  int v7;
  uint64_t v8;
  int v9;
  char v10;
  unsigned int v11;
  int v12;
  unint64_t v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  void (*v18)(_QWORD);
  int v19;
  int v20;
  NSObject *v21;
  uint64_t v22;
  uint64_t v24;
  int *v25;
  uint64_t v26;
  int v27;
  unsigned int v28;
  NSObject *v29;
  const char *v30;
  uint64_t v31;
  int v32;
  uint64_t *v33;
  int v34;
  NSObject *v35;
  os_log_type_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  void (*v40)(_QWORD);
  int v41;
  uint64_t v42;
  _QWORD *v43;
  int v44;
  int v45;
  NSObject *v46;
  _QWORD *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  char v51;
  _BYTE *v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  NSObject *v59;
  _BYTE *v60;
  int v61;
  int v62;
  int v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  int v68;
  int v69;
  int v70;
  int v71;
  int v72;
  int v73;
  NSObject *v74;
  os_log_type_t v75;
  int v76;
  _QWORD *v77;
  int v78;
  void **v79;
  uint64_t v80;
  char v81;
  int v82;
  unsigned int v83;
  int *v84;
  char *v85;
  char *v86;
  const char *v87;
  uint64_t v88;
  int v89;
  unsigned int v90;
  int v91;
  unsigned int v92;
  unsigned int v93;
  unsigned int v94;
  unsigned int v95;
  unsigned int v96;
  uint8_t buf[4];
  const char *v98;
  __int16 v99;
  const char *v100;
  uint64_t v101;

  v101 = *MEMORY[0x1E0C80C00];
  makeThreadId();
  if (!a1 || !*(_QWORD *)(a1 + 1048))
    return 0;
  v6 = (os_unfair_lock_s *)(a1 + 6580);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 6580));
  v96 = 0;
  v7 = fd_setDir(*(unsigned int *)(a1 + 32), (int *)&v96);
  v8 = 0;
  if (v7)
  {
    v9 = a3;
    v10 = a3;
    do
    {
      v11 = __ldxr(exceptionSequenceNum);
      v12 = v11 + 1;
    }
    while (__stxr(v11 + 1, exceptionSequenceNum));
    v13 = setThreadIdAndInfo(*(_DWORD *)(a1 + 32), sFdExceptionCallbacks, 0, 1, v12);
    v94 = HIDWORD(v13);
    v95 = v13;
    v92 = v15;
    v93 = v14;
    v16 = *(_QWORD *)&threadData[18 * v13 + 2];
    v17 = v16 + 320 * HIDWORD(v13);
    *(_BYTE *)(v17 + 216) = 0;
    v91 = *(_DWORD *)(v17 + 312);
    v18 = *(void (**)(_QWORD))(v17 + 224);
    if (v18)
      v18(*(_QWORD *)(v16 + 320 * HIDWORD(v13) + 288));
    v19 = v12;
    if (_setjmp((int *)v17))
    {
      v20 = *__error();
      v21 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        v98 = "SISetScanCount";
        v99 = 1024;
        LODWORD(v100) = 20366;
        _os_log_error_impl(&dword_1B8270000, v21, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
      }
      *__error() = v20;
      *(_DWORD *)(v17 + 312) = v91;
      CIOnThreadCleanUpReset(v92);
      dropThreadId(v95, 1, v12);
      CICleanUpReset(v95, v93);
      v22 = 0;
LABEL_36:
      v41 = v96;
      MEMORY[0x1BCCB1484](v96);
      if ((v41 & 0x80000000) == 0)
        close(v41);
      v8 = v22;
      goto LABEL_39;
    }
    v24 = *(_QWORD *)(a1 + 1392);
    if (!v24 || !*(_QWORD *)v24 || (v25 = *(int **)(a1 + 1384)) == 0 || (v26 = *(_QWORD *)v25) == 0)
    {
      v34 = *__error();
      v35 = _SILogForLogForCategory(0);
      v36 = gSILogLevels[0] < 3;
      if (os_log_type_enabled(v35, (os_log_type_t)(gSILogLevels[0] < 3)))
      {
        *(_DWORD *)buf = 136315138;
        v98 = "int32_t SISetScanCount(SIRef, CFIndex, _Bool)";
        _os_log_impl(&dword_1B8270000, v35, v36, "*warn* %s called on fs-only index", buf, 0xCu);
      }
      *__error() = v34;
      v37 = 0;
LABEL_33:
      v38 = *(_QWORD *)&threadData[18 * v95 + 2];
      v39 = v38 + 320 * v94;
      *(_DWORD *)(v39 + 312) = v91;
      v40 = *(void (**)(_QWORD))(v39 + 232);
      if (v40)
        v40(*(_QWORD *)(v38 + 320 * v94 + 288));
      dropThreadId(v95, 0, v19);
      v22 = v37;
      goto LABEL_36;
    }
    v27 = v25[2];
    if (v27)
    {
      v28 = v27 - 1;
      do
      {
        if (*(_QWORD *)(v26 + 8 * v28))
          break;
        v25[2] = v28--;
      }
      while (v28 != -1);
    }
    v89 = *__error();
    v29 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      v30 = "no";
      if (a3)
        v30 = "yes";
      *(_DWORD *)buf = 134218242;
      v98 = a2;
      v99 = 2080;
      v100 = v30;
      _os_log_impl(&dword_1B8270000, v29, OS_LOG_TYPE_DEFAULT, "SISetScanCount:%ld full:%s", buf, 0x16u);
    }
    *__error() = v89;
    v31 = v25[2];
    if ((_DWORD)v31)
    {
      if (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)v25 + 8 * (v31 - 1)) + 60) <= 1u)
      {
        v32 = *(_DWORD *)(v24 + 8);
        if (!v32)
        {
          checkIndexSets(a1);
          v63 = 1;
          goto LABEL_73;
        }
        if (v31 < 2)
          v33 = (uint64_t *)(*(_QWORD *)v24 + 8 * (v32 - 1));
        else
          v33 = (uint64_t *)(*(_QWORD *)v25 + 8 * v31 - 16);
        v64 = *v33;
        if (a2)
        {
          v65 = v31 - 1;
          if (v25[2] <= 1)
            v66 = 0;
          else
            v66 = v65;
          LODWORD(v67) = *(_DWORD *)(v64 + 60);
          if (v67 >= 2)
            v67 = v67;
          else
            v67 = 0;
          rebaseIndexes(v25, v66, (uint64_t)&a2[*(_QWORD *)(v64 + 72) + 1025 + v67]);
        }
        v57 = *(_DWORD *)(v64 + 32);
        v56 = 1;
LABEL_69:
        v68 = v57;
        v69 = v56;
        checkIndexSets(a1);
        v62 = v68;
        v61 = v69;
        v63 = v69;
        if (v68)
        {
LABEL_70:
          v70 = *(_DWORD *)(a1 + 6876);
          if (v70 >= v62)
            v70 = v62;
          v71 = v62;
          v72 = v70;
          goto LABEL_74;
        }
LABEL_73:
        v71 = 0;
        v61 = v63;
        v72 = *(_DWORD *)(a1 + 6876);
LABEL_74:
        v90 = v71;
        *(_DWORD *)(a1 + 6876) = v72;
        if (v72 >= 3)
        {
          v73 = *__error();
          v74 = _SILogForLogForCategory(0);
          v75 = 2 * (gSILogLevels[0] < 4);
          if (os_log_type_enabled(v74, v75))
          {
            v76 = *(_DWORD *)(a1 + 6876);
            *(_DWORD *)buf = 67109120;
            LODWORD(v98) = v76;
            _os_log_impl(&dword_1B8270000, v74, v75, "Starting cleanup for transactions below %d", buf, 8u);
          }
          *__error() = v73;
          SIInitialIndexingEnded(a1, (*(_DWORD *)(a1 + 6876) - 1));
        }
        if (current_index_not_writable(*(_QWORD *)(a1 + 1384)))
        {
          while (1)
          {
            v77 = ContentIndexListClone((__int128 *)v25);
            v78 = *((_DWORD *)v77 + 4);
            if (v78 == -1)
              break;
            v79 = (void **)v77;
            if (v78 < *((_DWORD *)v77 + 2))
            {
              do
              {
                v80 = *(_QWORD *)(*v77 + 8 * v78);
                v81 = atomic_load((unsigned int *)(v80 + 28));
                if ((v81 & 3) == 0 && !*(_BYTE *)(v80 + 15163))
                  break;
                v82 = *((_DWORD *)v77 + 4) + 1;
                *((_DWORD *)v77 + 4) = v82;
                v78 = v82;
              }
              while (v82 < *((_DWORD *)v77 + 2));
            }
            si_scheduler_suspend(*(_QWORD *)(a1 + 944));
            if (si_swapIndexSet((int *)a1, (uint64_t)v25, (unint64_t)v79, (unint64_t *)(a1 + 1384)))
            {
              si_scheduler_resume(*(_QWORD *)(a1 + 944), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 20354);
              break;
            }
            free(*v79);
            free(v79);
            si_scheduler_resume(*(_QWORD *)(a1 + 944), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 20350);
          }
        }
        if (v61)
          si_scheduler_resume(*(_QWORD *)(a1 + 872), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 20361);
        v37 = v90;
        goto LABEL_33;
      }
      if (!a3)
      {
        v43 = ContentIndexListClone((__int128 *)v25);
        v44 = count_IndexSetForWriting((uint64_t)v43, *((_DWORD *)v43 + 2) - 1);
        v45 = *__error();
        v46 = _SILogForLogForCategory(11);
        if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 67109120;
          LODWORD(v98) = v44;
          _os_log_impl(&dword_1B8270000, v46, OS_LOG_TYPE_DEFAULT, "SISetScanCount: Counted %d live indexes", buf, 8u);
        }
        *__error() = v45;
        v47 = (_QWORD *)*v43;
        v48 = (*((_DWORD *)v43 + 2) - 1);
        if ((!a2 || v44 > 14 || (v49 = v47[v48]) != 0 && *(_BYTE *)(v49 + 36))
          && (v50 = v47[v48]) != 0
          && (v51 = atomic_load((unsigned int *)(v50 + 28)), (v51 & 3) == 0)
          && !*(_BYTE *)(v50 + 15163))
        {
          v83 = *((_DWORD *)v43 + 2) - 1;
          if (*((_DWORD *)v43 + 4) == -1)
            *((_DWORD *)v43 + 4) = v83;
          v84 = *(int **)(*v43 + 8 * v83);
          v53 = v84[8];
          if (a2)
            ContentIndexSetEmergency(v84, 1);
          v54 = 1;
        }
        else
        {
          v52 = malloc_type_calloc(1uLL, 0x18uLL, 0x10200408F8695FCuLL);
          v52[20] = v10;
          *((_DWORD *)v52 + 4) = 0;
          *(_QWORD *)v52 = a1;
          *((_QWORD *)v52 + 1) = a2;
          v53 = *(_DWORD *)(*(_QWORD *)(*v43 + 8 * (*((_DWORD *)v43 + 2) - 1)) + 32);
          si_enqueue_work_with_qos(*(_QWORD *)(a1 + 1056), 17, (uint64_t)si_set_scan_count, (uint64_t)v52);
          v54 = 0;
        }
        v55 = v54;
        free((void *)*v43);
        free(v43);
        v56 = v55;
        v57 = v53;
        goto LABEL_69;
      }
    }
    v58 = *__error();
    v59 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134217984;
      v98 = a2;
      _os_log_impl(&dword_1B8270000, v59, OS_LOG_TYPE_DEFAULT, "full scan:%ld", buf, 0xCu);
    }
    *__error() = v58;
    if (v9 && v25[2] && *(_QWORD *)(**(_QWORD **)v25 + 72) < (uint64_t)a2)
    {
      v85 = __si_assert_copy_extra_521(-1);
      v86 = v85;
      v87 = "";
      if (v85)
        v87 = v85;
      __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 20289, "oldLiveSet->indexCount==0 || (CFIndex)ContentIndexBaseDocId(oldLiveSet->index[0]) >= count", v87);
      free(v86);
      if (__valid_fs(-1))
        v88 = 2989;
      else
        v88 = 3072;
      *(_DWORD *)v88 = -559038737;
      abort();
    }
    v60 = malloc_type_calloc(1uLL, 0x18uLL, 0x10200408F8695FCuLL);
    v60[20] = v10;
    *((_DWORD *)v60 + 4) = 1;
    *(_QWORD *)v60 = a1;
    *((_QWORD *)v60 + 1) = a2;
    si_enqueue_work_with_qos(*(_QWORD *)(a1 + 1056), 17, (uint64_t)si_set_scan_count, (uint64_t)v60);
    checkIndexSets(a1);
    v61 = 0;
    v62 = 1;
    goto LABEL_70;
  }
LABEL_39:
  v42 = v8;
  os_unfair_lock_unlock(v6);
  return v42;
}

void checkIndexSets(uint64_t a1)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t *v4;

  v2 = *(uint64_t **)(a1 + 1392);
  do
  {
    do
    {
      v3 = v2;
      v4 = *(uint64_t **)(a1 + 1384);
      __dmb(0xBu);
      v2 = *(uint64_t **)(a1 + 1392);
    }
    while (v3 != v2);
  }
  while (v4 != *(uint64_t **)(a1 + 1384));
  __checkIndexSetDocIdOrder(a1, v4);
  __checkIndexSetDocIdOrder(a1, v3);
}

int *rebaseIndexes(int *result, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  int *v5;

  if (result[2] > a2)
  {
    v4 = a2;
    v5 = result;
    do
    {
      result = _CIRebaseDocId(*(_QWORD *)(*(_QWORD *)v5 + 8 * v4), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v5 + 8 * v4) + 72) + a3, 20223);
      ++v4;
    }
    while (v4 < v5[2]);
  }
  return result;
}

void si_set_scan_count(uint64_t *a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  unsigned int v7;
  int v8;
  unint64_t v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  void (*v14)(_QWORD);
  int v15;
  NSObject *v16;
  _QWORD *v17;
  unint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  BOOL v21;
  uint64_t v22;
  int v23;
  int v24;
  uint64_t v25;
  int v26;
  CFStringRef v27;
  int v28;
  int v29;
  int v30;
  uint64_t v31;
  __int16 v32;
  __int16 v33;
  uint64_t **v34;
  uint64_t v35;
  int v36;
  int *v37;
  uint64_t v38;
  const __CFString *v39;
  _QWORD *v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  uint64_t *v44;
  void **v45;
  int v46;
  int v47;
  NSObject *v48;
  _QWORD *v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  char v54;
  char *v55;
  const __CFString *v56;
  int v57;
  int v58;
  __int16 v59;
  uint64_t v60;
  uint64_t v61;
  unsigned int v62;
  uint64_t v63;
  uint64_t v64;
  int v65;
  int *v66;
  const __CFString *v67;
  uint64_t vector_store;
  uint64_t v69;
  uint64_t v70;
  int v71;
  int v72;
  const __CFString *v73;
  uint64_t New;
  uint64_t v75;
  uint64_t v76;
  int v77;
  int v78;
  int v79;
  uint64_t v80;
  unsigned int v81;
  unsigned int v82;
  NSObject *v83;
  signed int v84;
  uint64_t v85;
  char v86;
  unsigned int v87;
  unsigned int v88;
  int v89;
  unsigned int v90;
  unsigned int v91;
  uint64_t v92;
  uint64_t v93;
  char v94;
  int v95;
  unsigned int v96;
  int *v97;
  int v98;
  _BYTE *v99;
  BOOL v100;
  int v101;
  NSObject *v102;
  os_log_type_t v103;
  uint64_t v104;
  unsigned int v105;
  uint64_t v106;
  void (*v107)(_QWORD);
  int v108;
  int v109;
  NSObject *v110;
  int v111;
  uint64_t *v112;
  uint64_t *v113;
  int v114;
  int v115;
  int v116;
  NSObject *v117;
  os_log_type_t v118;
  int v119;
  unint64_t v120;
  uint64_t v121;
  uint64_t v122;
  char v123;
  unsigned __int8 v124;
  unsigned int v125;
  CFStringRef v126;
  int v127;
  _BYTE *v128;
  BOOL v129;
  char *v130;
  char *v131;
  const char *v132;
  int v133;
  uint64_t v134;
  char *v135;
  char *v136;
  const char *v137;
  int v138;
  const char *v139;
  BOOL v140;
  uint64_t v141;
  char *v142;
  const char *v143;
  const char *v144;
  const char *v145;
  int v146;
  int v147;
  int v148;
  _BYTE *v149;
  const __CFAllocator *alloc;
  uint64_t v151;
  int v152;
  uint64_t v153;
  uint64_t v154;
  const __CFAllocator *v155;
  int v156;
  int v157;
  _QWORD v158[6];
  _QWORD v159[5];
  _QWORD v160[5];
  _QWORD aBlock[6];
  _QWORD v162[5];
  _QWORD v163[5];
  unint64_t v164;
  unsigned int v165;
  unsigned int v166;
  unsigned int v167;
  unint64_t v168;
  unsigned int v169;
  unsigned int v170;
  uint8_t v171[4];
  const char *v172;
  __int16 v173;
  int v174;
  __int16 v175;
  _BYTE *v176;
  _BYTE buf[12];
  __int16 v178;
  int v179;
  uint64_t v180;

  v180 = *MEMORY[0x1E0C80C00];
  if (a2)
    goto LABEL_2;
  v3 = *a1;
  if (!*(_QWORD *)(*a1 + 1048))
    goto LABEL_2;
  v4 = *a1;
  v5 = a1[1];
  v6 = *((unsigned __int8 *)a1 + 20);
  v170 = 0;
  if (!fd_setDir(*(unsigned int *)(v3 + 32), (int *)&v170))
    goto LABEL_2;
  v151 = v5;
  do
  {
    v7 = __ldxr(exceptionSequenceNum);
    v8 = v7 + 1;
  }
  while (__stxr(v7 + 1, exceptionSequenceNum));
  v169 = 0;
  v168 = 0;
  v167 = 0;
  v9 = setThreadIdAndInfo(*(_DWORD *)(v3 + 32), sFdExceptionCallbacks, 0, 1, v8);
  v169 = v9;
  v168 = __PAIR64__(HIDWORD(v9), v10);
  v167 = v11;
  v12 = *(_QWORD *)&threadData[18 * v9 + 2];
  v13 = v12 + 320 * HIDWORD(v9);
  *(_BYTE *)(v13 + 216) = 0;
  v156 = *(_DWORD *)(v13 + 312);
  v14 = *(void (**)(_QWORD))(v13 + 224);
  if (v14)
    v14(*(_QWORD *)(v12 + 320 * HIDWORD(v9) + 288));
  v157 = v8;
  v166 = v169;
  v165 = HIDWORD(v168);
  v164 = __PAIR64__(v168, v167);
  if (_setjmp((int *)v13))
  {
    v15 = *__error();
    v16 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "si_set_scan_count";
      v178 = 1024;
      v179 = 20207;
      _os_log_error_impl(&dword_1B8270000, v16, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
    }
    *__error() = v15;
    *(_DWORD *)(v13 + 312) = v156;
    CIOnThreadCleanUpReset(v164);
    dropThreadId(v166, 1, v157);
    CICleanUpReset(v166, HIDWORD(v164));
    goto LABEL_112;
  }
  v152 = v6;
  v153 = v5;
  v154 = v3;
  v17 = *(_QWORD **)(v3 + 1392);
  if (!v17)
  {
LABEL_106:
    v101 = *__error();
    v102 = _SILogForLogForCategory(0);
    v103 = gSILogLevels[0] < 3;
    if (os_log_type_enabled(v102, (os_log_type_t)(gSILogLevels[0] < 3)))
    {
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = "void si_set_scan_count(void *, Boolean)";
      _os_log_impl(&dword_1B8270000, v102, v103, "*warn* %s called on fs-only index", buf, 0xCu);
    }
    *__error() = v101;
    goto LABEL_109;
  }
  v18 = (unint64_t *)(v3 + 1384);
  v155 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v149 = (_BYTE *)(v3 + 6944);
  alloc = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v19 = MEMORY[0x1E0C809B0];
  while (1)
  {
    v20 = *v18;
    if (*v17)
      v21 = v20 == 0;
    else
      v21 = 1;
    if (v21)
      goto LABEL_106;
    v22 = *(_QWORD *)v20;
    if (!*(_QWORD *)v20)
      goto LABEL_106;
    v23 = *(_DWORD *)(v20 + 8);
    if (!v23)
      goto LABEL_27;
    v24 = v23 - 1;
    v25 = 8 * (v23 - 1);
    v26 = v24;
    while (!*(_QWORD *)(v22 + v25))
    {
      *(_DWORD *)(v20 + 8) = v26--;
      v25 -= 8;
      if (v26 == -1)
        goto LABEL_27;
    }
    if (v152)
      break;
    v40 = ContentIndexListClone((__int128 *)v20);
    v46 = count_IndexSetForWriting((uint64_t)v40, *((_DWORD *)v40 + 2) - 1);
    v47 = *__error();
    v48 = _SILogForLogForCategory(11);
    if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = v46;
      _os_log_impl(&dword_1B8270000, v48, OS_LOG_TYPE_DEFAULT, "si_set_scancount: Counted %d live indexes", buf, 8u);
    }
    *__error() = v47;
    v49 = (_QWORD *)*v40;
    v50 = *((_DWORD *)v40 + 2);
    v51 = (v50 - 1);
    if (!v151 || v46 > 14 || (v52 = v49[v51]) != 0 && *(_BYTE *)(v52 + 36))
    {
      v53 = v49[v51];
      if (v53)
      {
        v54 = atomic_load((unsigned int *)(v53 + 28));
        if ((v54 & 3) != 0)
        {
          v50 = *((_DWORD *)v40 + 2);
        }
        else
        {
          v50 = *((_DWORD *)v40 + 2);
          if (!*(_BYTE *)(v53 + 15163))
          {
            v96 = *((_DWORD *)v40 + 2) - 1;
            if (*((_DWORD *)v40 + 4) == -1)
              *((_DWORD *)v40 + 4) = v96;
            v97 = *(int **)(*v40 + 8 * v96);
            v43 = v97[8];
            v18 = (unint64_t *)(v154 + 1384);
            if (v151)
              ContentIndexSetEmergency(v97, 1);
            v95 = -1;
            goto LABEL_91;
          }
        }
      }
    }
    if (v50 == *((_DWORD *)v40 + 3))
    {
      *((_DWORD *)v40 + 3) = 2 * v50;
      v55 = (char *)malloc_type_realloc((void *)*v40, 8 * (2 * v50), 0x2004093837F09uLL);
      *v40 = v55;
      bzero(&v55[8 * *((unsigned int *)v40 + 2)], 8 * *((unsigned int *)v40 + 3) - 8 * *((unsigned int *)v40 + 2));
    }
    v56 = CFStringCreateWithFormat(alloc, 0, CFSTR("live.%d."), *(unsigned int *)(v20 + 8));
    v148 = *(_DWORD *)(*(_QWORD *)(*v40 + 8 * (*((_DWORD *)v40 + 2) - 1)) + 32);
    v57 = ((*(_DWORD *)(v4 + 828) & 1) << 6) ^ 0x50;
    if (*(_BYTE *)(v4 + 2072))
      v57 |= 0x100u;
    if (*(_BYTE *)(v4 + 2073))
      v57 |= 0x400u;
    v58 = v57 | (*(_DWORD *)(v4 + 6584) >> 7) & 0x800;
    if (*v149)
      v59 = v58 | 0x1000;
    else
      v59 = v58;
    v160[0] = v19;
    v160[1] = 0x40000000;
    v160[2] = __si_set_scan_count_block_invoke_1417;
    v160[3] = &__block_descriptor_tmp_1418;
    v160[4] = v4;
    v60 = *(unsigned int *)(v4 + 32);
    v61 = *(_QWORD *)(*v40 + 8 * (*((_DWORD *)v40 + 2) - 1));
    v62 = *(_DWORD *)(v61 + 60);
    v63 = *(_QWORD *)(v61 + 72);
    if (v62 >= 2)
      v64 = v62;
    else
      v64 = 0;
    v65 = *(_DWORD *)(v4 + 1276);
    v66 = *(int **)(v4 + 1184);
    if (v66)
    {
      v67 = v56;
      vector_store = db_get_vector_store(v66);
      v56 = v67;
      v69 = vector_store;
    }
    else
    {
      v69 = 0;
    }
    v19 = MEMORY[0x1E0C809B0];
    v159[0] = MEMORY[0x1E0C809B0];
    v70 = v153 + 1025 + v63 + v64;
    v159[1] = 0x40000000;
    v71 = v148;
    v72 = v65;
    v73 = v56;
    v159[2] = __si_set_scan_count_block_invoke_2_1419;
    v159[3] = &__block_descriptor_tmp_1420;
    v159[4] = v4;
    New = ContentIndexCreateNew(v60, v56, v70, v148 + 1, v59, 1, v72, v69, (uint64_t)v159, v160);
    v75 = *((unsigned int *)v40 + 2);
    *(_QWORD *)(*v40 + 8 * v75) = New;
    if (New)
    {
      v76 = *(_QWORD *)(*v40 + 8 * v75);
      v158[0] = v19;
      v158[1] = 0x40000000;
      v158[2] = __si_set_scan_count_block_invoke_3_1421;
      v158[3] = &__block_descriptor_tmp_1422;
      v158[4] = v4;
      v158[5] = v76;
      ContentIndexSetDirtyCallback(v76, v158);
      *(_BYTE *)(v76 + 15161) = 4;
      v77 = 1;
    }
    else
    {
      v77 = -1;
    }
    v18 = (unint64_t *)(v154 + 1384);
    v147 = v77;
    v78 = *((_DWORD *)v40 + 4);
    if (v78 == -1)
    {
      v79 = *((_DWORD *)v40 + 2) - 1;
      *((_DWORD *)v40 + 4) = v79;
      v78 = v79;
    }
    v80 = New;
    if (New)
    {
      v81 = *((_DWORD *)v40 + 2) + 1;
      *((_DWORD *)v40 + 2) = v81;
      v82 = v78;
    }
    else
    {
      bzero(buf, 0x400uLL);
      v146 = *__error();
      v83 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v83, OS_LOG_TYPE_ERROR))
      {
        v98 = fcntl(*(_DWORD *)(v4 + 32), 50, buf);
        v99 = 0;
        *(_DWORD *)v171 = 136315650;
        if (buf[0])
          v100 = v98 < 0;
        else
          v100 = 1;
        v172 = "si_set_scan_count";
        if (!v100)
          v99 = buf;
        v71 = v148;
        v173 = 1024;
        v174 = 20153;
        v175 = 2080;
        v176 = v99;
        _os_log_error_impl(&dword_1B8270000, v83, OS_LOG_TYPE_ERROR, "%s:%d: Couldn't create live store at %s.", v171, 0x1Cu);
      }
      *__error() = v146;
      v82 = *((_DWORD *)v40 + 4);
      v81 = *((_DWORD *)v40 + 2);
    }
    if (v82 < v81)
    {
      v84 = v82;
      do
      {
        v85 = *(_QWORD *)(*v40 + 8 * v84);
        v86 = atomic_load((unsigned int *)(v85 + 28));
        if ((v86 & 3) != 0)
        {
          v87 = *((_DWORD *)v40 + 4);
          v88 = *((_DWORD *)v40 + 2);
        }
        else
        {
          v89 = *(unsigned __int8 *)(v85 + 15163);
          v87 = *((_DWORD *)v40 + 4);
          v88 = *((_DWORD *)v40 + 2);
          v81 = v88;
          v82 = v87;
          if (!v89)
            break;
        }
        v90 = v88;
        v91 = v87 + 1;
        *((_DWORD *)v40 + 4) = v91;
        v84 = v91;
        v82 = v91;
        v81 = v90;
      }
      while (v91 < v90);
    }
    if (v82 == v81)
      *((_DWORD *)v40 + 4) = -1;
    CFRelease(v73);
    bzero(buf, 0x400uLL);
    if (v80)
    {
      v92 = *((int *)v40 + 4);
      if ((_DWORD)v92 != -1)
      {
        v93 = *(_QWORD *)(*v40 + 8 * v92);
        v94 = atomic_load((unsigned int *)(v93 + 28));
        if ((v94 & 3) != 0 || *(_BYTE *)(v93 + 15163))
        {
          v135 = __si_assert_copy_extra_521(*(_DWORD *)(v4 + 32));
          v136 = v135;
          if (v135)
            v137 = v135;
          else
            v137 = "";
          v138 = fcntl(*(_DWORD *)(v4 + 32), 50, buf);
          v139 = 0;
          if (buf[0])
            v140 = v138 < 0;
          else
            v140 = 1;
          if (!v140)
            v139 = buf;
          __message_assert("%s:%u: failed assertion '%s' %s No writable index available for %s", "SpotlightIndex.c", 20168, "(ci_rc != ContentIndex_OpenedNew) || (indexSet->currentIndex==~0) || ContentIndexWritable(indexSet->index[indexSet->currentIndex])", v137, v139);
          free(v136);
          if (__valid_fs(*(_DWORD *)(v4 + 32)))
            v141 = 2989;
          else
            v141 = 3072;
          *(_DWORD *)v141 = -559038737;
          abort();
        }
      }
    }
    v43 = v71;
    v95 = v147;
LABEL_91:
    if (si_swapIndexSet((int *)v4, v20, (unint64_t)v40, v18))
    {
      v111 = v95;
      goto LABEL_117;
    }
    if (v95 == 1)
    {
      v44 = (uint64_t *)(*v40 + 8 * (*((_DWORD *)v40 + 2) - 1));
LABEL_40:
      v45 = (void **)v40;
      if (*v44)
        _CIDeleteIndex(*v44, 1);
      goto LABEL_42;
    }
    v45 = (void **)v40;
LABEL_42:
    free(*v45);
    free(v45);
    v17 = *(_QWORD **)(v4 + 1392);
    if (!v17)
      goto LABEL_106;
  }
  if (*(_QWORD *)(*(_QWORD *)v22 + 72) < v153)
  {
    v130 = __si_assert_copy_extra_521(-1);
    v131 = v130;
    v132 = "";
    if (v130)
      v132 = v130;
    v144 = "oldLiveSet->indexCount==0 || (CFIndex)ContentIndexBaseDocId(oldLiveSet->index[0]) >= count";
    v145 = v132;
    v133 = 20042;
LABEL_155:
    __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", v133, v144, v145);
    free(v131);
    if (__valid_fs(-1))
      v134 = 2989;
    else
      v134 = 3072;
    *(_DWORD *)v134 = -559038737;
    abort();
  }
LABEL_27:
  v27 = CFStringCreateWithFormat(alloc, 0, CFSTR("live.0."));
  v28 = ((*(_DWORD *)(v4 + 828) & 1) << 6) ^ 0x50;
  if (*(_BYTE *)(v4 + 2072))
    LOWORD(v28) = v28 | 0x100;
  if (*(_BYTE *)(v4 + 2073))
    LOWORD(v28) = v28 | 0x400;
  v29 = (*(_DWORD *)(v4 + 6584) >> 7) & 0x800;
  v30 = *v149;
  v31 = v19;
  v163[0] = v19;
  v32 = v28 | v29;
  v163[1] = 0x40000000;
  if (v30)
    v33 = v32 | 0x1000;
  else
    v33 = v32;
  v163[2] = __si_set_scan_count_block_invoke;
  v163[3] = &__block_descriptor_tmp_1414;
  v163[4] = v4;
  v34 = (uint64_t **)ContentIndexListClone((__int128 *)v20);
  v35 = *(unsigned int *)(v4 + 32);
  v36 = *(_DWORD *)(v4 + 1276);
  v37 = *(int **)(v4 + 1184);
  if (v37)
    v38 = db_get_vector_store(v37);
  else
    v38 = 0;
  v162[0] = v31;
  v39 = v27;
  v162[1] = 0x40000000;
  v40 = v34;
  v162[2] = __si_set_scan_count_block_invoke_2;
  v162[3] = &__block_descriptor_tmp_1415;
  v162[4] = v4;
  v41 = ContentIndexCreateNew(v35, v39, v153 + 1025, 2, v33, 1, v36, v38, (uint64_t)v162, v163);
  **v34 = v41;
  if (v41)
  {
    v42 = **v34;
    aBlock[0] = v31;
    aBlock[1] = 0x40000000;
    aBlock[2] = __si_set_scan_count_block_invoke_3;
    aBlock[3] = &__block_descriptor_tmp_1416;
    aBlock[4] = v4;
    aBlock[5] = v42;
    ContentIndexSetDirtyCallback(v42, aBlock);
    *(_BYTE *)(v42 + 15161) = 4;
    __checkIndexSetDocIdOrder(v4, v40);
    CFRelease(v39);
    v43 = 1;
    *((_DWORD *)v40 + 2) = 1;
    *((_DWORD *)v40 + 4) = -1;
    v18 = (unint64_t *)(v154 + 1384);
    if (si_swapIndexSet((int *)v4, v20, (unint64_t)v40, (unint64_t *)(v154 + 1384)))
    {
      v111 = 1;
      goto LABEL_117;
    }
    v19 = v31;
    v44 = (uint64_t *)*v40;
    goto LABEL_40;
  }
  CFRelease(v39);
  bzero(buf, 0x400uLL);
  v109 = *__error();
  v110 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v110, OS_LOG_TYPE_ERROR))
  {
    v127 = fcntl(*(_DWORD *)(v4 + 32), 50, buf);
    v128 = 0;
    *(_DWORD *)v171 = 136315650;
    v172 = "si_set_scan_count";
    if (buf[0])
      v129 = v127 < 0;
    else
      v129 = 1;
    if (!v129)
      v128 = buf;
    v173 = 1024;
    v174 = 20087;
    v175 = 2080;
    v176 = v128;
    _os_log_error_impl(&dword_1B8270000, v110, OS_LOG_TYPE_ERROR, "%s:%d: Couldn't create live store at %s.", v171, 0x1Cu);
  }
  *__error() = v109;
  v43 = 1;
  v111 = -1;
  v18 = (unint64_t *)(v154 + 1384);
LABEL_117:
  v112 = (uint64_t *)*v18;
  if (*v18)
  {
    *(_QWORD *)buf = v4;
    __checkIndexSetDocIdOrder(v4, v112);
  }
  v113 = *(uint64_t **)(v4 + 1392);
  if (v113)
  {
    *(_QWORD *)buf = v4;
    __checkIndexSetDocIdOrder(v4, v113);
  }
  v114 = *(_DWORD *)(v4 + 6876);
  if (v114 >= v43)
    v115 = v43;
  else
    v115 = *(_DWORD *)(v4 + 6876);
  if (v43)
    v114 = v115;
  *(_DWORD *)(v4 + 6876) = v114;
  if (v114 >= 3)
  {
    v116 = *__error();
    v117 = _SILogForLogForCategory(0);
    v118 = 2 * (gSILogLevels[0] < 4);
    if (os_log_type_enabled(v117, v118))
    {
      v119 = *(_DWORD *)(v4 + 6876);
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = v119;
      _os_log_impl(&dword_1B8270000, v117, v118, "Starting cleanup for transactions below %d", buf, 8u);
    }
    *__error() = v116;
    SIInitialIndexingEnded(v4, (*(_DWORD *)(v4 + 6876) - 1));
  }
  v120 = *v18;
  if (*v18)
  {
    v121 = *(int *)(v120 + 16);
    if ((_DWORD)v121 != -1)
    {
      v122 = *(_QWORD *)(*(_QWORD *)v120 + 8 * v121);
      v123 = atomic_load((unsigned int *)(v122 + 28));
      if ((v123 & 3) != 0 || *(_BYTE *)(v122 + 15163))
      {
        v142 = __si_assert_copy_extra_521(-1);
        v131 = v142;
        v143 = "";
        if (v142)
          v143 = v142;
        v144 = "!ref->liveSet || ref->liveSet->currentIndex==~0 || ContentIndexWritable(ref->liveSet->index[ref->liveSet->currentIndex])";
        v145 = v143;
        v133 = 20196;
        goto LABEL_155;
      }
    }
  }
  if (v111 < 0)
  {
    v124 = atomic_load((unsigned __int8 *)(v154 + 2439));
    if ((v124 & 1) == 0)
    {
      if (SIIsAppleInternal_onceToken != -1)
        dispatch_once(&SIIsAppleInternal_onceToken, &__block_literal_global_4644);
      if (SIIsAppleInternal_internal)
      {
        do
          v125 = __ldxr(si_set_scan_count__crashCount);
        while (__stxr(v125 + 1, si_set_scan_count__crashCount));
        if (!v125)
        {
          v126 = CFStringCreateWithFormat(v155, 0, CFSTR("si_set_scan_count, rc:%d"), 0xFFFFFFFFLL);
          getpid();
          SISimulateCrashForPid(0, (uint64_t)v126);
          if (v126)
            CFRelease(v126);
        }
      }
    }
    si_makeUnavailable(v4, 22, 2, 14, (uint64_t)"could not create live index");
  }
  else
  {
    si_scheduler_resume(*(_QWORD *)(v4 + 872), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 20199);
  }
LABEL_109:
  v104 = *(_QWORD *)&threadData[18 * v166 + 2];
  v105 = v165;
  v106 = v104 + 320 * v165;
  *(_DWORD *)(v106 + 312) = v156;
  v107 = *(void (**)(_QWORD))(v106 + 232);
  if (v107)
    v107(*(_QWORD *)(v104 + 320 * v105 + 288));
  dropThreadId(v166, 0, v157);
LABEL_112:
  v108 = v170;
  MEMORY[0x1BCCB1484](v170);
  if ((v108 & 0x80000000) == 0)
    close(v108);
LABEL_2:
  free(a1);
}

BOOL current_index_not_writable(_BOOL8 result)
{
  uint64_t v1;
  uint64_t v2;
  char v3;

  if (result)
  {
    v1 = *(int *)(result + 16);
    if ((_DWORD)v1 == -1)
    {
      return 0;
    }
    else
    {
      v2 = *(_QWORD *)(*(_QWORD *)result + 8 * v1);
      v3 = atomic_load((unsigned int *)(v2 + 28));
      return (v3 & 3) != 0 || *(unsigned __int8 *)(v2 + 15163) != 0;
    }
  }
  return result;
}

uint64_t si_swapIndexSet(int *a1, uint64_t a2, unint64_t a3, unint64_t *a4)
{
  unint64_t v6;
  unsigned int *v7;
  unsigned int v8;
  uint64_t result;

  do
  {
    v6 = __ldaxr(a4);
    if (v6 != a2)
    {
      result = 0;
      __clrex();
      return result;
    }
  }
  while (__stlxr(a3, a4));
  si_write_index_state((uint64_t)a1, 1, 0);
  si_cleanup((uint64_t)a1, a2);
  v7 = (unsigned int *)(a1 + 350);
  do
    v8 = __ldxr(v7);
  while (__stxr(v8 + 1, v7));
  _si_log_indexes(a1);
  return 1;
}

void __si_set_scan_count_block_invoke(uint64_t a1, const void *a2)
{
  si_collect_block(*(_QWORD *)(a1 + 32), a2);
}

uint64_t __si_set_scan_count_block_invoke_2(uint64_t a1, uint64_t a2)
{
  return _si_next_index_id(*(os_unfair_lock_s **)(a1 + 32), a2, 1, 0);
}

uint64_t __si_set_scan_count_block_invoke_3(uint64_t a1)
{
  return si_set_obj_state(*(os_unfair_lock_s **)(a1 + 32), *(_QWORD *)(a1 + 40));
}

void __si_set_scan_count_block_invoke_1417(uint64_t a1, const void *a2)
{
  si_collect_block(*(_QWORD *)(a1 + 32), a2);
}

uint64_t __si_set_scan_count_block_invoke_2_1419(uint64_t a1, uint64_t a2)
{
  return _si_next_index_id(*(os_unfair_lock_s **)(a1 + 32), a2, 1, 0);
}

uint64_t __si_set_scan_count_block_invoke_3_1421(uint64_t a1)
{
  return si_set_obj_state(*(os_unfair_lock_s **)(a1 + 32), *(_QWORD *)(a1 + 40));
}

void si_collect_block(uint64_t a1, const void *a2)
{
  unsigned int *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9[4];

  if (a2)
  {
    v4 = (unsigned int *)malloc_type_malloc(0x28uLL, 0x10A0040A9CEF559uLL);
    atomic_store(1u, v4);
    v5 = _Block_copy(a2);
    v6 = 0;
    *((_QWORD *)v4 + 2) = v5;
    *((_QWORD *)v4 + 3) = 0;
    *((_QWORD *)v4 + 4) = dbGCBlock;
    v7 = a1 + 1008;
    do
    {
      v8 = *(_QWORD *)(v7 + v6);
      if (v8)
        si_enqueue_cleanup_if_busy(v8, (uint64_t)v4);
      v6 += 8;
    }
    while (v6 != 136);
    v9[0] = v4;
    memset(&v9[1], 0, 24);
    si_collect_inner(v9);
  }
}

void dbGCBlock(uint64_t a1, void (**a2)(_QWORD))
{
  a2[2](a2);
  _Block_release(a2);
}

void __si_initialIndexingEnded_block_invoke(uint64_t a1, uint64_t *a2, void *a3, uint64_t a4, NSObject *a5)
{
  if (a2)
    setupAndIssueMerge(a2, *(_DWORD *)(a1 + 32), a3, a4, a5);
}

void setupAndIssueMerge(uint64_t *a1, int a2, void *a3, uint64_t a4, NSObject *a5)
{
  NSObject *v5;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  _BOOL4 v17;
  uint64_t v18;
  uint64_t *v19;
  char *v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  _DWORD *v27;
  uint64_t v28;
  uint64_t (*v29)(_QWORD, const char *, uint64_t, const char *);
  NSObject *v30;

  v5 = a5;
  v9 = a1[174];
  v10 = a1[173];
  v11 = *(unsigned int *)(v9 + 8);
  if ((_DWORD)v11)
  {
    v12 = 0;
    v13 = 0;
    v14 = 0;
    v15 = *(_QWORD *)v9;
    do
    {
      while (*(_DWORD *)(*(_QWORD *)(v15 + 8 * v12) + 32) != a2)
      {
        if (v14)
          goto LABEL_11;
        if (++v12 >= v11)
          goto LABEL_13;
      }
      if (!v14)
        v14 = *(_QWORD *)(v15 + 8 * v12);
      ++v13;
      ++v12;
    }
    while (v12 < v11);
    if (!v14)
      goto LABEL_13;
LABEL_11:
    v16 = 0;
    v17 = 1;
    goto LABEL_25;
  }
  v13 = 0;
LABEL_13:
  v18 = *(unsigned int *)(v10 + 8);
  if ((_DWORD)v18)
  {
    v16 = 0;
    v14 = 0;
    v19 = *(uint64_t **)v10;
    do
    {
      if (*(_DWORD *)(*v19 + 32) == a2)
      {
        if (!v14)
          v14 = *v19;
        ++v13;
        v16 = 1;
      }
      else if (v14)
      {
        break;
      }
      ++v19;
      --v18;
    }
    while (v18);
    v17 = v16 == 0;
    if (v11 >= 2 && v16)
      setupAndIssueMerge(a1, 1, a3, a4, a5);
    if (v14)
    {
LABEL_25:
      v20 = (char *)malloc_type_calloc(1uLL, 0x460uLL, 0x1070040C187FD8AuLL);
      *(_QWORD *)v20 = a1;
      if (v16 && v13 == 1)
      {
        v21 = a1[173];
        v22 = *(_DWORD *)(v14 + 48);
        if (v22 && (v23 = *(unsigned int *)(v21 + 8), (_DWORD)v23))
        {
          v30 = v5;
          v24 = 0;
          while (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)v21 + 8 * v24) + 48) != v22)
          {
            if (v23 == ++v24)
              goto LABEL_36;
          }
          if ((v24 + 1) < 2)
          {
LABEL_36:
            v25 = 0;
            v13 = 1;
            goto LABEL_38;
          }
          v13 = count_IndexSet(v21, (int)v24 - 1, *(_DWORD *)(v14 + 44));
          v25 = (int)v24 - v13;
LABEL_38:
          v5 = v30;
        }
        else
        {
          v25 = 0;
          v13 = 1;
        }
        v14 = *(_QWORD *)(*(_QWORD *)v21 + 8 * v25);
      }
      if (v17)
        v26 = -1;
      else
        v26 = v13;
      *((_DWORD *)v20 + 2) = *(_DWORD *)(v14 + 48);
      *((_DWORD *)v20 + 3) = v26;
      v20[16] = v16;
      *(_WORD *)(v20 + 1041) = 0;
      *((_QWORD *)v20 + 131) = "void setupAndIssueMerge(SIRef, uint32_t, _Bool, xpc_activity_t, _Bool *, dispatch_group_t)";
      *((_DWORD *)v20 + 274) = 5;
      v20[1100] = 0;
      __strlcpy_chk();
      v27 = v20 + 1064;
      si_power_info_init((uint64_t)(v20 + 1064), a3, a4, v5);
      if (!*((_QWORD *)v20 + 136) && !*v27)
      {
        v28 = a1[295];
        if (v28)
        {
          v29 = *(uint64_t (**)(_QWORD, const char *, uint64_t, const char *))(v28 + 64);
          if (v29)
            *v27 = v29(*(_QWORD *)(v28 + 136), "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 8447, "void setupAndIssueMerge(SIRef, uint32_t, _Bool, xpc_activity_t, _Bool *, dispatch_group_t)");
        }
      }
      si_enqueue_work(a1[132], (uint64_t)si_mergeIndex, (uint64_t)v20);
    }
  }
}

void si_mergeIndex(uint64_t *a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  int v7;
  unint64_t v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  void (*v14)(_QWORD);
  int v15;
  NSObject *v16;
  uint64_t v17;
  unint64_t *i;
  _QWORD *v19;
  uint64_t v20;
  uint64_t (*v21)(_QWORD, const char *, uint64_t, const char *);
  int v22;
  NSObject *v23;
  os_log_type_t v24;
  const char *v25;
  const char *v26;
  char *v27;
  int v28;
  const char *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t *v34;
  int v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  signed int v39;
  int v40;
  NSObject *v41;
  os_log_type_t v42;
  int v43;
  uint64_t *v44;
  int v45;
  NSObject *v46;
  os_log_type_t v47;
  char *v48;
  int v49;
  const char *v50;
  int v51;
  BOOL v52;
  unsigned int v53;
  const char *v54;
  const char *v55;
  int v56;
  _BYTE *v57;
  BOOL v58;
  int v59;
  NSObject *v60;
  os_log_type_t v61;
  const char *v62;
  char *v63;
  int v64;
  int v65;
  const char *v66;
  const char *v67;
  int v68;
  signed int v69;
  __int128 **v70;
  int v71;
  int v72;
  uint64_t v73;
  int v74;
  signed int v75;
  signed int v76;
  signed int v77;
  signed int v78;
  signed int v79;
  uint64_t v80;
  unsigned int v81;
  int v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  char v88;
  int v89;
  unsigned __int8 v90;
  unsigned int v91;
  uint64_t v92;
  uint64_t v93;
  int v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  int *v98;
  uint64_t v99;
  char *v100;
  time_t v101;
  uint64_t v102;
  uint64_t v103;
  void (*v104)(_QWORD);
  uint64_t v105;
  int v106;
  char *v107;
  char *v108;
  const char *v109;
  int v110;
  unsigned int v111;
  int v112;
  char *v113;
  const char *v114;
  uint64_t v115;
  const char *v116;
  uint64_t v117;
  _QWORD *v118;
  __int128 **v119;
  uint64_t v120;
  __int128 *v121;
  int v122;
  unsigned int v123;
  unsigned int v124;
  unsigned int v125;
  unsigned int v126;
  unsigned int v127;
  _BYTE v128[12];
  __int16 v129;
  const char *v130;
  __int16 v131;
  char *v132;
  __int16 v133;
  const char *v134;
  __int16 v135;
  int v136;
  _BYTE buf[12];
  __int16 v138;
  const char *v139;
  __int16 v140;
  char *v141;
  __int16 v142;
  const char *v143;
  __int16 v144;
  int v145;
  __int16 v146;
  _BOOL4 v147;
  __int16 v148;
  const char *v149;
  uint64_t v150;

  v3 = (uint64_t)a1;
  v150 = *MEMORY[0x1E0C80C00];
  if (!a2)
  {
    v4 = *a1;
    v5 = *a1;
    if (!a1[138])
      a1[138] = time(0);
    disableProcMon();
    v127 = 0;
    if (!fd_setDir(*(unsigned int *)(v5 + 32), (int *)&v127))
      goto LABEL_149;
    do
    {
      v6 = __ldxr(exceptionSequenceNum);
      v7 = v6 + 1;
    }
    while (__stxr(v6 + 1, exceptionSequenceNum));
    v8 = setThreadIdAndInfo(-1, (__int128 *)sSDBExceptionCallbacks, *(_QWORD *)(v5 + 1184), 0x40000000, v7);
    v125 = HIDWORD(v8);
    v126 = v8;
    v123 = v10;
    v124 = v9;
    v11 = *(_QWORD *)&threadData[18 * v8 + 2];
    v12 = v11 + 320 * HIDWORD(v8);
    *(_BYTE *)(v12 + 216) = 0;
    v13 = *(_DWORD *)(v12 + 312);
    v14 = *(void (**)(_QWORD))(v12 + 224);
    if (v14)
      v14(*(_QWORD *)(v11 + 320 * HIDWORD(v8) + 288));
    if (_setjmp((int *)v12))
    {
      v15 = *__error();
      v16 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)&buf[4] = "si_mergeIndex";
        v138 = 1024;
        LODWORD(v139) = 8352;
        _os_log_error_impl(&dword_1B8270000, v16, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
      }
      *__error() = v15;
      *(_DWORD *)(v12 + 312) = v13;
      CIOnThreadCleanUpReset(v123);
      dropThreadId(v126, 1, v7);
      CICleanUpReset(v126, v124);
LABEL_146:
      v105 = v3;
      v106 = v127;
      MEMORY[0x1BCCB1484](v127);
      if ((v106 & 0x80000000) == 0)
        close(v106);
      v3 = v105;
LABEL_149:
      enableProcMon();
      goto LABEL_150;
    }
    if (!*(_QWORD *)(v3 + 1088) && !*(_DWORD *)(v3 + 1064))
    {
      v20 = *(_QWORD *)(v5 + 2360);
      if (v20)
      {
        v21 = *(uint64_t (**)(_QWORD, const char *, uint64_t, const char *))(v20 + 64);
        if (v21)
          *(_DWORD *)(v3 + 1064) = v21(*(_QWORD *)(v20 + 136), "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 8170, "void si_mergeIndex(void *, Boolean)");
      }
    }
    if (!*(_DWORD *)(v3 + 8) && (*(_BYTE *)(v3 + 1042) || !*(_BYTE *)(v3 + 16)))
    {
      v17 = *(_QWORD *)(v5 + 1392);
      if (*(_DWORD *)(v17 + 16) != -1)
      {
        for (i = (unint64_t *)(v4 + 1392); ; v17 = *i)
        {
          v19 = ContentIndexListClone((__int128 *)v17);
          *((_DWORD *)v19 + 4) = -1;
          if (si_swapIndexSet((int *)v5, v17, (unint64_t)v19, i))
            break;
          ContentIndexListFree((void **)v19);
        }
        _CIDisableUpdates(*(_QWORD *)(*v19 + 8 * (*((_DWORD *)v19 + 2) - 1)));
      }
    }
    v22 = *__error();
    v23 = _SILogForLogForCategory(0);
    v24 = 2 * (gSILogLevels[0] < 4);
    if (os_log_type_enabled(v23, v24))
    {
      if (*(_BYTE *)(v3 + 1042))
        v25 = "Full";
      else
        v25 = "Partial";
      v26 = "Vacuum";
      v27 = si_merge_reason_names[*(unsigned int *)(v3 + 1096)];
      v28 = *(unsigned __int8 *)(v3 + 1043);
      if (!*(_BYTE *)(v3 + 1041))
        v26 = "Normal";
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = v25;
      v29 = "Voluntary";
      v138 = 2080;
      v139 = v26;
      v140 = 2080;
      v141 = v27;
      if (v28)
        v29 = "Forced";
      v142 = 2080;
      v143 = v29;
      _os_log_impl(&dword_1B8270000, v23, v24, "Attempt to merge (%s/%s/%s/%s)", buf, 0x2Au);
    }
    *__error() = v22;
    if (*(_BYTE *)(v3 + 1042))
    {
      *(_DWORD *)(v3 + 12) = -1;
      if ((transfer_live_indexes(v5) & 1) == 0)
      {
        v40 = *__error();
        v41 = _SILogForLogForCategory(0);
        v42 = 2 * (gSILogLevels[0] < 4);
        if (os_log_type_enabled(v41, v42))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_1B8270000, v41, v42, "Failed to transfer live indexes", buf, 2u);
        }
        *__error() = v40;
        goto LABEL_140;
      }
    }
    v122 = v7;
    v30 = *(_QWORD *)v3;
    if (*(_BYTE *)(v3 + 16))
      v31 = 1384;
    else
      v31 = 1392;
    if (*(_BYTE *)(v3 + 16))
      v32 = *(_QWORD *)v3 + 1384;
    else
      v32 = *(_QWORD *)v3 + 1392;
    v33 = *(uint64_t **)(v30 + v31);
    v34 = v33;
    *(_QWORD *)buf = v5;
    __checkIndexSetDocIdOrder(v5, v33);
    v35 = *(_DWORD *)(v3 + 12);
    if (v35 == -1)
    {
      v39 = 0;
      v43 = *((_DWORD *)v34 + 2);
      *(_DWORD *)(v3 + 12) = v43;
      v35 = v43;
    }
    else
    {
      v36 = *(_DWORD *)(v3 + 8);
      if (v36 && (v37 = *((unsigned int *)v34 + 2), (_DWORD)v37))
      {
        v38 = 0;
        while (*(_DWORD *)(*(_QWORD *)(*v34 + 8 * v38) + 48) != v36)
        {
          if (v37 == ++v38)
            goto LABEL_48;
        }
        v39 = v38;
      }
      else
      {
LABEL_48:
        v39 = 0;
      }
    }
    if (!v35 || (v39 + v35) > *((_DWORD *)v34 + 2))
    {
      v44 = v34;
      v45 = *__error();
      v46 = _SILogForLogForCategory(0);
      v47 = 2 * (gSILogLevels[0] < 4);
      if (os_log_type_enabled(v46, v47))
      {
        v48 = si_merge_reason_names[*(unsigned int *)(v3 + 1096)];
        v49 = *(unsigned __int8 *)(v3 + 1043);
        if (*(_BYTE *)(v3 + 1042))
          v50 = "Full";
        else
          v50 = "Partial";
        v51 = *(_DWORD *)(v3 + 12);
        v52 = *(_BYTE *)(v3 + 1041) == 0;
        v53 = *((_DWORD *)v44 + 2);
        *(_DWORD *)buf = 136316674;
        *(_QWORD *)&buf[4] = v50;
        if (v52)
          v54 = "Normal";
        else
          v54 = "Vacuum";
        v138 = 2080;
        v139 = v54;
        v55 = "Voluntary";
        v140 = 2080;
        if (v49)
          v55 = "Forced";
        v141 = v48;
        v142 = 2080;
        v143 = v55;
        v144 = 1024;
        v145 = v51;
        v146 = 1024;
        v147 = v51 + v39 <= v53;
        v148 = 2080;
        v149 = "";
        _os_log_impl(&dword_1B8270000, v46, v47, "Skipped merge (%s/%s/%s/%s/%d/%d)%s", buf, 0x40u);
      }
      *__error() = v45;
      v7 = v122;
      goto LABEL_140;
    }
    v119 = (__int128 **)v32;
    v120 = v31;
    v121 = (__int128 *)v34;
    v118 = ContentIndexListClone((__int128 *)v34);
    bzero(buf, 0x400uLL);
    v56 = fcntl(*(_DWORD *)(v5 + 32), 50, buf);
    v57 = 0;
    if (buf[0])
      v58 = v56 < 0;
    else
      v58 = 1;
    if (!v58)
      v57 = buf;
    v117 = (uint64_t)v57;
    v59 = *__error();
    v60 = _SILogForLogForCategory(0);
    v61 = 2 * (gSILogLevels[0] < 4);
    if (os_log_type_enabled(v60, v61))
    {
      if (*(_BYTE *)(v3 + 1042))
        v62 = "Full";
      else
        v62 = "Partial";
      v52 = *(_BYTE *)(v3 + 1041) == 0;
      v63 = si_merge_reason_names[*(unsigned int *)(v3 + 1096)];
      v64 = *(unsigned __int8 *)(v3 + 1043);
      v65 = *(_DWORD *)(v3 + 12);
      *(_DWORD *)v128 = 136316162;
      *(_QWORD *)&v128[4] = v62;
      if (v52)
        v66 = "Normal";
      else
        v66 = "Vacuum";
      v129 = 2080;
      v130 = v66;
      v67 = "Voluntary";
      v131 = 2080;
      if (v64)
        v67 = "Forced";
      v132 = v63;
      v133 = 2080;
      v134 = v67;
      v135 = 1024;
      v136 = v65;
      _os_log_impl(&dword_1B8270000, v60, v61, "Merging (%s/%s/%s/%s/%d)", v128, 0x30u);
    }
    *__error() = v59;
    v68 = *(_DWORD *)(v3 + 12);
    if (*((_DWORD *)v118 + 2) == v68 && !*(_BYTE *)(v3 + 16))
      *((_DWORD *)v118 + 4) = -1;
    v69 = *((_DWORD *)v118 + 4);
    v70 = v119;
    if (v39 <= v69 && v69 < v68 + v39)
    {
      if (v39 >= v69)
      {
        *(_DWORD *)(v3 + 12) = v68 - 1;
        ++v39;
      }
      else
      {
        *(_DWORD *)(v3 + 12) = v69 + ~v39;
      }
    }
    v71 = v39;
    if (CompactIndexes(v5, v3, v39, v118)
      && (!*(_BYTE *)(v3 + 1041)
       || *(_QWORD *)(v5 + 1144)
       || (v73 = *(int *)(v3 + 12), (int)v73 + v39 <= *((_DWORD *)v118 + 2))
       && ((SetupDeferQueue(v5, (uint64_t)v118, v39, v73) & 1) != 0
        || (v89 = *((_DWORD *)v118 + 2) + ~v39,
            *(_DWORD *)(v3 + 12) = v89,
            SetupDeferQueue(v5, (uint64_t)v118, v39, v89)))))
    {
      v72 = CompactIndexes(v5, v3, v39, v118);
    }
    else
    {
      v72 = 0;
    }
    if (!*(_BYTE *)(v3 + 1041) && *(_QWORD *)(v5 + 1144))
      handleDeferQueue(v5);
    if (!v72)
      goto LABEL_137;
    v74 = *(_DWORD *)(v3 + 12);
    if (v74 < 2)
      goto LABEL_137;
    v75 = *(_DWORD *)(v3 + 12);
    v76 = *((_DWORD *)v118 + 4);
    if (v76 == -1)
    {
      if (!*(_BYTE *)(v3 + 16))
      {
        v90 = 0;
        v91 = *(_DWORD *)(v3 + 12);
LABEL_129:
        v92 = MergeIndexes(v5, *(_DWORD *)(v3 + 8), v71, v91, v70, v121, v118, v117, (const char *)(v3 + 17), *(_BYTE *)(v3 + 1041), v90);
        if (v92)
        {
          v93 = *(_QWORD *)(v30 + v120);
          v7 = v122;
          if (*(_DWORD *)(v3 + 8)
            && (v94 = *(_DWORD *)(v92 + 48)) != 0
            && (v95 = *(unsigned int *)(v93 + 8), (_DWORD)v95))
          {
            v96 = v92;
            v97 = 0;
            while (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)v93 + 8 * v97) + 48) != v94)
            {
              if (v95 == ++v97)
                goto LABEL_136;
            }
            v111 = v97;
            *(_QWORD *)v128 = v5;
            __checkIndexSetDocIdOrder(v5, (uint64_t *)v93);
            if (v111)
            {
              v112 = count_IndexSet(v93, v111, *(_DWORD *)(v96 + 44));
              if (v112 >= 5 && v112 < *(_DWORD *)(v3 + 12))
              {
                *(_DWORD *)(v3 + 8) = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v93 + 8 * (v111 - v112 + 1)) + 48);
                *(_DWORD *)(v3 + 12) = v112;
                *(_WORD *)(v3 + 1041) = 0;
                *(_QWORD *)(v3 + 1048) = "void si_mergeIndex(void *, Boolean)";
                si_enqueue_work(*(_QWORD *)(v5 + 1056), (uint64_t)si_mergeIndex, v3);
                v3 = 0;
LABEL_140:
                if (*(_QWORD *)(v5 + 1144) && *(_BYTE *)(v3 + 1041))
                  handleDeferQueue(v5);
                v102 = *(_QWORD *)&threadData[18 * v126 + 2];
                v103 = v102 + 320 * v125;
                *(_DWORD *)(v103 + 312) = v13;
                v104 = *(void (**)(_QWORD))(v103 + 232);
                if (v104)
                  v104(*(_QWORD *)(v102 + 320 * v125 + 288));
                dropThreadId(v126, 0, v7);
                goto LABEL_146;
              }
            }
          }
          else
          {
LABEL_136:
            *(_QWORD *)v128 = v5;
            __checkIndexSetDocIdOrder(v5, (uint64_t *)v93);
          }
LABEL_139:
          v98 = (int *)*(unsigned __int8 *)(v3 + 1100);
          v99 = gSISystemInDarkWake;
          v100 = si_merge_reason_names[*(unsigned int *)(v3 + 1096)];
          v101 = time(0);
          si_message_trace_darkwake(v98, v5, (uint64_t)"DarkMerge", v99, (uint64_t)v100, (uint64_t)"Index merge in dark wake", v101 - *(_QWORD *)(v3 + 1104));
          goto LABEL_140;
        }
        v7 = v122;
        if (*(_BYTE *)(v3 + 1041))
          handleDeferQueue(v5);
        if (!*(_QWORD *)(v5 + 1144))
          goto LABEL_139;
        v107 = __si_assert_copy_extra_521(-1);
        v108 = v107;
        v109 = "";
        if (v107)
          v109 = v107;
        v116 = v109;
        v110 = 8320;
LABEL_165:
        __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", v110, "!ref->workqueues.queues[SI_DEFER_QUEUE_IDX]", v116);
        free(v108);
        if (__valid_fs(-1))
          v115 = 2989;
        else
          v115 = 3072;
        *(_DWORD *)v115 = -559038737;
        abort();
      }
      v81 = *((_DWORD *)v118 + 2);
      if (v39 >= v81)
      {
        *(_DWORD *)(v3 + 12) = 0;
        goto LABEL_137;
      }
      if (v74 + v39 >= v81)
      {
        v82 = v81 + ~v39;
        *(_DWORD *)(v3 + 12) = v82;
        if (v82 < 1)
          goto LABEL_137;
      }
      v83 = 0;
      do
      {
        v84 = v83;
        _CIDisableUpdates(*(_QWORD *)(*v118 + 8 * (v71 + v83)));
        v83 = v84 + 1;
        v80 = *(int *)(v3 + 12);
      }
      while (v84 + 1 < v80);
      v70 = v119;
    }
    else
    {
      if (v39 == v76)
      {
        *(_DWORD *)(v3 + 12) = 0;
        v75 = 0;
      }
      v77 = v75;
      if (v39 < v76)
      {
        v78 = v75 + v39;
        v79 = v76;
        if (v78 > v76)
        {
LABEL_106:
          LODWORD(v80) = v79 - v39;
          *(_DWORD *)(v3 + 12) = v79 - v39;
          goto LABEL_127;
        }
      }
      if (v39 <= v76)
      {
        LODWORD(v80) = v77;
      }
      else
      {
        LODWORD(v80) = v77;
        if (v39 < v77)
        {
          v85 = v39;
          while (1)
          {
            v86 = v85;
            v87 = *(_QWORD *)(*v118 + 8 * v85);
            v88 = atomic_load((unsigned int *)(v87 + 28));
            if ((v88 & 3) == 0 && !*(_BYTE *)(v87 + 15163))
              break;
            v85 = v86 + 1;
            if (v86 + 1 >= *(int *)(v3 + 12))
            {
              LODWORD(v80) = *(_DWORD *)(v3 + 12);
              goto LABEL_127;
            }
          }
          v79 = v86;
          goto LABEL_106;
        }
      }
    }
LABEL_127:
    if ((int)v80 >= 2)
    {
      v90 = *(_BYTE *)(v3 + 16) != 0;
      v91 = v80;
      goto LABEL_129;
    }
LABEL_137:
    free((void *)*v118);
    free(v118);
    v7 = v122;
    if (!*(_QWORD *)(v5 + 1144))
      goto LABEL_139;
    handleDeferQueue(v5);
    if (!*(_QWORD *)(v5 + 1144))
      goto LABEL_139;
    v113 = __si_assert_copy_extra_521(-1);
    v108 = v113;
    v114 = "";
    if (v113)
      v114 = v113;
    v116 = v114;
    v110 = 8327;
    goto LABEL_165;
  }
LABEL_150:
  si_merge_ctx_free(v3, a2 != 0);
}

uint64_t disableProcMon()
{
  int v0;
  NSObject *v1;
  os_log_type_t v2;
  int v3;
  NSObject *v4;
  os_log_type_t v5;
  uint8_t v7[16];
  uint8_t buf[16];

  getpid();
  pthread_mutex_lock(&sProcMonLock);
  if (!sDisableProcMon && proc_get_cpumon_params())
  {
    v0 = *__error();
    v1 = _SILogForLogForCategory(0);
    v2 = 2 * (gSILogLevels[0] < 4);
    if (os_log_type_enabled(v1, v2))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1B8270000, v1, v2, "Failed to get cpumon_params", buf, 2u);
    }
    *__error() = v0;
  }
  if (proc_set_cpumon_params())
  {
    v3 = *__error();
    v4 = _SILogForLogForCategory(0);
    v5 = gSILogLevels[0] < 3;
    if (os_log_type_enabled(v4, (os_log_type_t)(gSILogLevels[0] < 3)))
    {
      *(_WORD *)v7 = 0;
      _os_log_impl(&dword_1B8270000, v4, v5, "*warn* Failed to set cpumon_params", v7, 2u);
    }
    *__error() = v3;
  }
  ++sDisableProcMon;
  return pthread_mutex_unlock(&sProcMonLock);
}

uint64_t transfer_live_indexes(uint64_t a1)
{
  int v2;
  NSObject *v3;
  uint64_t i;
  __int128 *v5;
  __int128 *v6;
  _QWORD *v7;
  _QWORD *v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char v14;
  int v15;
  int v16;
  __int16 v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int v22;
  int *v23;
  int v24;
  __int16 v25;
  uint64_t vector_store;
  uint64_t v27;
  uint64_t New;
  uint64_t v29;
  char v30;
  unsigned int v31;
  int v32;
  unsigned int v33;
  char *v34;
  uint64_t v35;
  unint64_t v36;
  unint64_t v37;
  uint64_t v38;
  char v39;
  uint64_t v40;
  char v41;
  unint64_t *v42;
  unint64_t v43;
  unsigned int *v44;
  unsigned int v45;
  unsigned int v46;
  unsigned int v47;
  uint64_t j;
  char *v49;
  uint64_t v50;
  int v51;
  NSObject *v52;
  char *v54;
  char *v55;
  const char *v56;
  uint64_t v57;
  char *v58;
  char *v59;
  const char *v60;
  char *v61;
  const char *v62;
  uint64_t v63;
  char *v64;
  char *v65;
  const char *v66;
  uint64_t v67;
  uint64_t v68;
  _QWORD aBlock[6];
  _QWORD v70[5];
  _QWORD v71[5];
  uint8_t buf[1024];
  uint64_t v73;

  v73 = *MEMORY[0x1E0C80C00];
  v2 = *__error();
  v3 = _SILogForLogForCategory(6);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1B8270000, v3, OS_LOG_TYPE_DEFAULT, "transfer_live_indexes begin\n", buf, 2u);
  }
  *__error() = v2;
  for (i = 864; i != 944; i += 8)
    si_scheduler_suspend(*(_QWORD *)(a1 + i));
  v5 = *(__int128 **)(a1 + 1392);
  v6 = *(__int128 **)(a1 + 1384);
  v7 = ContentIndexListClone(v6);
  v8 = ContentIndexListClone(v5);
  v9 = (unint64_t)v8;
  v10 = *((unsigned int *)v8 + 2);
  v11 = *(_QWORD *)(*v7 + 8 * (*((_DWORD *)v7 + 2) - 1));
  if (*((_DWORD *)v7 + 2) == 1)
  {
LABEL_11:
    v15 = 1;
  }
  else
  {
    v12 = 0;
    while (1)
    {
      v13 = *(_QWORD *)(*v7 + 8 * v12);
      if (!v13)
        break;
      v14 = atomic_load((unsigned int *)(v13 + 28));
      if ((v14 & 3) == 0 && !*(_BYTE *)(v13 + 15163))
        break;
      if (++v12 >= (unint64_t)(*((_DWORD *)v7 + 2) - 1))
        goto LABEL_11;
    }
    v15 = 0;
  }
  v16 = *((_DWORD *)v8 + 4);
  if (*(_BYTE *)(a1 + 6944))
    v17 = (((*(_WORD *)(a1 + 828) & 1) << 6) | (*(unsigned __int8 *)(a1 + 2072) << 8) | (*(unsigned __int8 *)(a1 + 2073) << 10) | (*(_DWORD *)(a1 + 6584) >> 7) & 0x800) ^ 0x50 | 0x1000;
  else
    v17 = (((*(_WORD *)(a1 + 828) & 1) << 6) | (*(unsigned __int8 *)(a1 + 2072) << 8) | (*(unsigned __int8 *)(a1 + 2073) << 10) | (*(_DWORD *)(a1 + 6584) >> 7) & 0x800) ^ 0x50;
  v71[0] = MEMORY[0x1E0C809B0];
  v71[1] = 0x40000000;
  v71[2] = __transfer_live_indexes_block_invoke;
  v71[3] = &__block_descriptor_tmp_648;
  v71[4] = a1;
  if (!v15 || v16 != -1)
    goto LABEL_32;
  v68 = (uint64_t)v6;
  v18 = *(unsigned int *)(a1 + 32);
  LODWORD(v19) = *(_DWORD *)(v11 + 60);
  v19 = v19 >= 2 ? v19 : 0;
  v20 = *(_QWORD *)(v11 + 72) + v19 + 1025;
  v21 = *(_DWORD *)(v11 + 32);
  v22 = *(_DWORD *)(a1 + 1276);
  v23 = *(int **)(a1 + 1184);
  if (v23)
  {
    v67 = v11;
    v24 = *(_DWORD *)(a1 + 1276);
    v25 = v17;
    vector_store = db_get_vector_store(v23);
    v17 = v25;
    v22 = v24;
    v11 = v67;
    v27 = vector_store;
  }
  else
  {
    v27 = 0;
  }
  v70[0] = MEMORY[0x1E0C809B0];
  v70[1] = 0x40000000;
  v70[2] = __transfer_live_indexes_block_invoke_2;
  v70[3] = &__block_descriptor_tmp_651;
  v70[4] = a1;
  New = ContentIndexCreateNew(v18, CFSTR("tmp."), v20, v21, v17, 1, v22, v27, (uint64_t)v70, v71);
  if (!New)
  {
LABEL_32:
    free((void *)*v7);
    free(v7);
    free(*(void **)v9);
    free((void *)v9);
    v35 = 0;
    goto LABEL_59;
  }
  v29 = New;
  v30 = atomic_load((unsigned int *)(v11 + 28));
  if ((v30 & 3) == 0 && !*(_BYTE *)(v11 + 15163))
    _CIDisableUpdates(v11);
  *(_DWORD *)(v68 + 16) = -1;
  if (*(_DWORD *)(v9 + 16) != -1)
  {
    v58 = __si_assert_copy_extra_521(-1);
    v59 = v58;
    v60 = "";
    if (v58)
      v60 = v58;
    __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 6726, "indexSet2->currentIndex==~0", v60);
LABEL_81:
    free(v59);
    if (__valid_fs(-1))
    {
LABEL_82:
      v63 = 2989;
      goto LABEL_87;
    }
LABEL_86:
    v63 = 3072;
LABEL_87:
    *(_DWORD *)v63 = -559038737;
    abort();
  }
  v31 = *((_DWORD *)v7 + 2);
  v32 = *(_DWORD *)(v9 + 8);
  v33 = *(_DWORD *)(v9 + 12);
  if (v33 >= v32 + v31)
  {
    v34 = *(char **)v9;
  }
  else
  {
    do
      v33 *= 2;
    while (v33 < v32 + v31);
    *(_DWORD *)(v9 + 12) = v33;
    v34 = (char *)malloc_type_realloc(*(void **)v9, 8 * v33, 0x2004093837F09uLL);
    *(_QWORD *)v9 = v34;
    v32 = *(_DWORD *)(v9 + 8);
    v31 = *((_DWORD *)v7 + 2);
  }
  memcpy(&v34[8 * v32], (const void *)*v7, 8 * v31);
  LODWORD(v36) = *(_DWORD *)(v9 + 8) + *((_DWORD *)v7 + 2);
  *(_DWORD *)(v9 + 8) = v36;
  if (v10 < v36)
  {
    v37 = v10;
    do
    {
      v38 = *(_QWORD *)(*(_QWORD *)v9 + 8 * v37);
      v39 = atomic_load((unsigned int *)(v38 + 28));
      if ((v39 & 3) == 0 && !*(_BYTE *)(v38 + 15163))
        _CIDisableUpdates(*(_QWORD *)(*(_QWORD *)v9 + 8 * v37));
      ++v37;
      v36 = *(unsigned int *)(v9 + 8);
    }
    while (v37 < v36);
  }
  if (v10 < v36)
  {
    do
    {
      bzero(buf, 0x400uLL);
      snprintf((char *)buf, 0x400uLL, "%u.", v10);
      ContentIndexChangePrefix(*(_QWORD *)(*(_QWORD *)v9 + 8 * v10));
      v40 = *(_QWORD *)(*(_QWORD *)v9 + 8 * v10);
      v41 = atomic_load((unsigned int *)(v40 + 28));
      if ((v41 & 3) == 0 && !*(_BYTE *)(v40 + 15163))
      {
        v54 = __si_assert_copy_extra_521(-1);
        v55 = v54;
        v56 = "";
        if (v54)
          v56 = v54;
        __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 6747, "!ContentIndexWritable(indexSet2->index[i])", v56);
        free(v55);
        if (__valid_fs(-1))
          v57 = 2989;
        else
          v57 = 3072;
        *(_DWORD *)v57 = -559038737;
        abort();
      }
      ++v10;
    }
    while (v10 < *(unsigned int *)(v9 + 8));
  }
  v42 = (unint64_t *)(a1 + 1392);
  ContentIndexChangePrefix(v29);
  aBlock[0] = MEMORY[0x1E0C809B0];
  aBlock[1] = 0x40000000;
  aBlock[2] = __transfer_live_indexes_block_invoke_3;
  aBlock[3] = &__block_descriptor_tmp_656;
  aBlock[4] = a1;
  aBlock[5] = v29;
  ContentIndexSetDirtyCallback(v29, aBlock);
  *(_BYTE *)(v29 + 15161) = 4;
  *(_DWORD *)(v9 + 16) = -1;
  do
  {
    v43 = __ldaxr(v42);
    if ((__int128 *)v43 != v5)
    {
      __clrex();
      v64 = __si_assert_copy_extra_521(-1);
      v65 = v64;
      v66 = "";
      if (v64)
        v66 = v64;
      __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 6755, "si_swapIndexSet(ref,oldIndexSet2,indexSet2,&ref->syncSet,0, 0)", v66);
      free(v65);
      if (__valid_fs(-1))
        goto LABEL_82;
      goto LABEL_86;
    }
  }
  while (__stlxr(v9, v42));
  si_cleanup(a1, (uint64_t)v5);
  v44 = (unsigned int *)(a1 + 1400);
  do
    v45 = __ldxr(v44);
  while (__stxr(v45 + 1, v44));
  _si_log_indexes((int *)a1);
  *((_DWORD *)v7 + 2) = 1;
  *(_QWORD *)*v7 = v29;
  *((_DWORD *)v7 + 4) = 0;
  if (!si_swapIndexSet((int *)a1, v68, (unint64_t)v7, (unint64_t *)(a1 + 1384)))
  {
    v61 = __si_assert_copy_extra_521(-1);
    v59 = v61;
    v62 = "";
    if (v61)
      v62 = v61;
    __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 6762, "si_swapIndexSet(ref,oldIndexSet1,indexSet1,&ref->liveSet,1, 1)", v62);
    goto LABEL_81;
  }
  v46 = *(_DWORD *)(*(_QWORD *)(a1 + 1392) + 8);
  if (*(_DWORD *)(a1 + 1232) > v46)
    *(_DWORD *)(a1 + 1232) = v46;
  if (*(_DWORD *)(a1 + 1240) > v46)
    *(_DWORD *)(a1 + 1240) = v46;
  v47 = *(_DWORD *)(*(_QWORD *)(a1 + 1384) + 8);
  if (*(_DWORD *)(a1 + 1236) > v47)
    *(_DWORD *)(a1 + 1236) = v47;
  if (*(_DWORD *)(a1 + 1244) > v47)
    *(_DWORD *)(a1 + 1244) = v47;
  _CIMetaInfoSync(a1 + 1192, gTerminating == 0);
  v35 = 1;
  *(_BYTE *)(a1 + 2437) = 1;
  _CreateDeferQueue(a1, *(uint64_t **)(a1 + 1392), 0, *(unsigned int *)(*(_QWORD *)(a1 + 1392) + 8));
LABEL_59:
  for (j = 936; j != 864; j -= 8)
    si_scheduler_resume(*(_QWORD *)(a1 + j), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 6786);
  if ((v35 & 1) != 0)
  {
    si_sync_ctx_create_with_defer_fd(a1, 0);
    v50 = (uint64_t)v49;
    v49[96] = 1;
    if (!*(_BYTE *)(*(_QWORD *)v49 + 2437) && !*(_BYTE *)(*(_QWORD *)v49 + 2072))
      attachJournal(v49);
    syncIndex(v50, 0);
  }
  si_scheduler_resume(*(_QWORD *)(a1 + 864), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 6800);
  v51 = *__error();
  v52 = _SILogForLogForCategory(6);
  if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1B8270000, v52, OS_LOG_TYPE_DEFAULT, "transfer_live_indexes end\n", buf, 2u);
  }
  *__error() = v51;
  return v35;
}

uint64_t CompactIndexes(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  unsigned int *v8;
  uint64_t v9;
  uint64_t v10;
  char v11;
  const __CFAllocator *v12;
  uint64_t v13;
  uint64_t v14;
  char v15;
  char v16;
  char v17;
  CFSetRef v18;
  int v19;
  int v20;
  uint64_t v21;
  _DWORD *v23;
  char v24;
  void *values;
  __int128 v26;
  BOOL (*v27)(uint64_t);
  uint64_t v28;

  if ((*(_BYTE *)(a1 + 6586) & 4) != 0)
    return 1;
  pthread_mutex_lock(&mergeMutex);
  *(_WORD *)(a1 + 2434) = 257;
  pthread_mutex_unlock(&mergeMutex);
  v8 = (unsigned int *)(a4 + 1);
  if (a2)
    v8 = (unsigned int *)(a2 + 12);
  v9 = *v8;
  if ((int)v9 < 1)
  {
    v11 = 0;
    goto LABEL_26;
  }
  v23 = (_DWORD *)(a2 + 12);
  v10 = 0;
  v11 = 0;
  v12 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v13 = 8 * a3;
  while (1)
  {
    v14 = *(_QWORD *)(*a4 + v13 + 8 * v10);
    v15 = atomic_load((unsigned int *)(v14 + 28));
    if ((v15 & 4) != 0)
      goto LABEL_18;
    v16 = atomic_load((unsigned int *)(v14 + 28));
    if ((v16 & 2) != 0)
    {
      if (a2)
        goto LABEL_16;
LABEL_14:
      v17 = atomic_load((unsigned int *)(v14 + 28));
      if ((v17 & 2) == 0 && !*(_BYTE *)(v14 + 15163))
        goto LABEL_26;
      goto LABEL_16;
    }
    if (a2)
      break;
    if (*(_BYTE *)(v14 + 15163))
      goto LABEL_14;
LABEL_18:
    ++v10;
    v11 = 1;
    if (v9 == v10)
      goto LABEL_26;
  }
  if (!*(_BYTE *)(v14 + 15163))
  {
    *(_BYTE *)(a2 + 1041) = 0;
    *(_DWORD *)(a2 + 12) = v10;
    goto LABEL_26;
  }
LABEL_16:
  values = (void *)*(int *)(v14 + 48);
  v18 = CFSetCreate(v12, (const void **)&values, 1, 0);
  setUpOverlay(a1, v18);
  CFRelease(v18);
  v24 = 0;
  v19 = (*(_DWORD *)(a1 + 6584) >> 4) & 1;
  *(_QWORD *)&v26 = si_compact_lock;
  *((_QWORD *)&v26 + 1) = si_compact_unlock;
  v27 = si_compact_cancel;
  v28 = a1;
  v20 = _CICompact(v14, &v26, v19, &v24);
  mergeOverlay((uint64_t *)a1, 0);
  if (!a2 || !v20)
    goto LABEL_18;
  if (v24)
  {
    *v23 = 0;
    si_recycleForBadIndex(a1, v14, (uint64_t)"compact err");
  }
  else
  {
    *v23 = v10;
  }
  *(_BYTE *)(a2 + 1041) = 0;
LABEL_26:
  pthread_mutex_lock(&mergeMutex);
  v21 = v11 & (*(_DWORD *)(a1 + 2428) == 0);
  *(_WORD *)(a1 + 2434) = 0;
  pthread_cond_broadcast(&mergeCond);
  pthread_mutex_unlock(&mergeMutex);
  return v21;
}

uint64_t SetupDeferQueue(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned int *v8;
  unsigned int v9;
  unsigned int v10;
  int v11;
  NSObject *v12;
  os_log_type_t v13;
  int v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  char v18;
  CFSetRef v19;
  int v20;
  int v21;
  _BOOL8 v22;
  int v23;
  NSObject *v24;
  int v26;
  char v27;
  void *values;
  _BYTE buf[24];
  uint64_t v30;
  int v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  if (a4 && a4 + a3 <= *(unsigned int *)(a2 + 8))
  {
    si_scheduler_suspend(*(_QWORD *)(a1 + 864));
    *(_BYTE *)(a1 + 2437) = 1;
    v8 = (unsigned int *)(a1 + 1452);
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 + 1, v8));
    si_scheduler_suspend(*(_QWORD *)(a1 + 872));
    do
      v10 = __ldaxr(v8);
    while (__stlxr(v10 - 1, v8));
    si_scheduler_suspend(*(_QWORD *)(a1 + 880));
    si_scheduler_suspend(*(_QWORD *)(a1 + 928));
    si_scheduler_suspend(*(_QWORD *)(a1 + 936));
    v11 = *__error();
    v12 = _SILogForLogForCategory(0);
    v13 = 2 * (gSILogLevels[0] < 4);
    if (os_log_type_enabled(v12, v13))
    {
      v14 = *(_DWORD *)(a2 + 8);
      *(_DWORD *)buf = 67109632;
      *(_DWORD *)&buf[4] = v14;
      *(_WORD *)&buf[8] = 1024;
      *(_DWORD *)&buf[10] = a3;
      *(_WORD *)&buf[14] = 1024;
      *(_DWORD *)&buf[16] = a4;
      _os_log_impl(&dword_1B8270000, v12, v13, "size:%d start:%d count:%d", buf, 0x14u);
    }
    *__error() = v11;
    _CreateDeferQueue(a1, (uint64_t *)a2, a3, a4);
    v15 = new_live_index(a1, 1, 0);
    si_scheduler_resume(*(_QWORD *)(a1 + 936), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 6435);
    si_scheduler_resume(*(_QWORD *)(a1 + 928), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 6436);
    si_scheduler_resume(*(_QWORD *)(a1 + 880), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 6437);
    si_scheduler_resume(*(_QWORD *)(a1 + 872), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 6438);
    si_scheduler_resume(*(_QWORD *)(a1 + 864), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 6439);
    if (v15)
    {
      si_scheduler_suspend(*(_QWORD *)(a1 + 864));
      si_sync_ctx_create_with_defer_fd(a1, 0);
      v17 = (uint64_t)v16;
      v16[96] = 1;
      if (!*(_BYTE *)(*(_QWORD *)v16 + 2437) && !*(_BYTE *)(*(_QWORD *)v16 + 2072))
        attachJournal(v16);
      syncIndex(v17, 0);
      si_scheduler_resume(*(_QWORD *)(a1 + 864), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 6455);
      if ((*(_BYTE *)(a1 + 6586) & 4) != 0)
        return 1;
      v18 = atomic_load((unsigned int *)(v15 + 28));
      if ((v18 & 4) != 0)
        return 1;
      values = (void *)*(int *)(v15 + 48);
      v19 = CFSetCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)&values, 1, 0);
      setUpOverlay(a1, v19);
      CFRelease(v19);
      v27 = 0;
      v20 = (*(_DWORD *)(a1 + 6584) >> 4) & 1;
      *(_QWORD *)buf = si_compact_lock;
      *(_QWORD *)&buf[8] = si_compact_unlock;
      *(_QWORD *)&buf[16] = si_compact_cancel;
      v30 = a1;
      v21 = _CICompact(v15, buf, v20, &v27);
      v22 = v21 == 0;
      if (!v21 || !v27)
      {
        mergeOverlay((uint64_t *)a1, 0);
        return v22;
      }
      si_recycleForBadIndex(a1, v15, (uint64_t)"compact err");
    }
    return 0;
  }
  else
  {
    v23 = *__error();
    v24 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      v26 = *(_DWORD *)(a2 + 8);
      *(_DWORD *)buf = 136316162;
      *(_QWORD *)&buf[4] = "SetupDeferQueue";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 6414;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v26;
      LOWORD(v30) = 1024;
      *(_DWORD *)((char *)&v30 + 2) = a3;
      HIWORD(v30) = 1024;
      v31 = a4;
      _os_log_error_impl(&dword_1B8270000, v24, OS_LOG_TYPE_ERROR, "%s:%d: invalid range - size:%d start:%d count:%d", buf, 0x24u);
    }
    v22 = 0;
    *__error() = v23;
  }
  return v22;
}

uint64_t handleDeferQueue(uint64_t a1)
{
  pthread_mutex_t *v2;
  uint64_t v3;
  uint64_t v4;
  unsigned int *v5;
  unsigned int v6;
  uint64_t DeferJournalFd;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;

  v2 = (pthread_mutex_t *)(a1 + 1320);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1320));
  v3 = *(_QWORD *)(a1 + 1144);
  v4 = *(_QWORD *)(a1 + 872);
  if (v4)
  {
    v5 = (unsigned int *)(v4 + 80);
    do
      v6 = __ldaxr(v5);
    while (__stlxr(v6 + 1, v5));
  }
  *(_QWORD *)(a1 + 1144) = 0;
  *(_BYTE *)(a1 + 2437) = 0;
  *(_OWORD *)(a1 + 1304) = 0u;
  DeferJournalFd = getDeferJournalFd(a1, 1);
  dispatch_resume(*(dispatch_object_t *)(v3 + 16));
  v8 = malloc_type_malloc(0x20uLL, 0x20040DC1BFBCFuLL);
  *v8 = v3;
  v8[1] = v4;
  v8[2] = DeferJournalFd;
  v8[3] = a1;
  v9 = malloc_type_malloc(0x10uLL, 0x20040A4A59CD2uLL);
  *v9 = 0;
  v9[1] = v3;
  v10 = *(_QWORD **)(a1 + 1168);
  if (v10)
  {
    do
    {
      v11 = v10;
      v10 = (_QWORD *)*v10;
    }
    while (v10);
  }
  else
  {
    v11 = (_QWORD *)(a1 + 1168);
  }
  *v11 = v9;
  si_enqueue_barrier(v3, (uint64_t)si_deferqueue_cleanup, (uint64_t)v8);
  return pthread_mutex_unlock(v2);
}

uint64_t MergeIndexes(uint64_t a1, int a2, int a3, unsigned int a4, __int128 **a5, __int128 *a6, _QWORD *a7, uint64_t a8, const char *a9, unsigned __int8 a10, unsigned __int8 a11)
{
  __int128 **v13;
  unsigned int v14;
  uint64_t v15;
  unint64_t v18;
  char v19;
  unsigned int v20;
  unsigned int v21;
  __int128 *v22;
  __int128 *v23;
  _BOOL4 v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  int v28;
  unsigned int v29;
  unsigned int v30;
  uint64_t v31;
  int v32;
  char v33;
  int v34;
  unsigned __int8 v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  __int128 *v39;
  __int128 *v41;
  char *v42;
  char *v43;
  const char *v44;
  char *v45;
  const char *v46;
  uint64_t v47;
  os_log_type_t type;
  NSObject *log;
  int v50;
  unint64_t v52;
  char v53;
  unsigned int v54;
  uint8_t buf[8];
  __int16 v57;
  unsigned int v58;
  uint64_t v59;

  v13 = a5;
  v14 = a4;
  LODWORD(v15) = a3;
  v59 = *MEMORY[0x1E0C80C00];
  v18 = a4;
  v19 = 1;
LABEL_2:
  v53 = v19;
  v52 = v18;
  v20 = 0;
  v21 = 0;
  v22 = *v13;
  while (1)
  {
    v23 = a6;
    a6 = v22;
    if (v23 == v22)
      break;
    ContentIndexListFree((void **)a7);
    a7 = ContentIndexListClone(a6);
    v22 = *v13;
    if (a6 == *v13)
      break;
    v24 = 0;
LABEL_16:
    if (a6 == v22)
    {
      v29 = v14 - v24;
      if (v21 >= v29)
        v30 = v29;
      else
        v30 = v21;
      v54 = v30;
      v31 = v29 + (_DWORD)v15 - v30;
      v32 = *(_DWORD *)(*(_QWORD *)(*a7 + 8 * v31) + 48);
      v33 = a10 ^ 1;
      if (v29 <= v21)
        v33 = 1;
      v34 = *(_DWORD *)(*(_QWORD *)(*a7 + 8 * v31) + 48);
      if ((v33 & 1) == 0)
      {
        v50 = *__error();
        log = _SILogForLogForCategory(0);
        type = 2 * (gSILogLevels[0] < 4);
        if (os_log_type_enabled(log, type))
        {
          *(_DWORD *)buf = 67109376;
          *(_DWORD *)&buf[4] = v29;
          v57 = 1024;
          v58 = v54;
          _os_log_impl(&dword_1B8270000, log, type, "mergeCount:%d != count:%d", buf, 0xEu);
        }
        *__error() = v50;
        v34 = *(_DWORD *)(*(_QWORD *)(*a7 + 8 * v31) + 48);
      }
      v35 = a10;
      if (v29 > v21)
        v35 = 0;
      v36 = OuterMerge(a1, v34, v54, v13, (uint64_t)a6, a7, a8, a9, v35, a11);
      v37 = v36;
      if (!v36)
        return v37;
      if (v32 == a2)
        a2 = *(_DWORD *)(v36 + 48);
      a6 = *v13;
      v38 = *((unsigned int *)*v13 + 2);
      if (a2)
      {
        if (!(_DWORD)v38)
        {
          LODWORD(v15) = 0;
          a2 = *(_DWORD *)(v36 + 48);
LABEL_45:
          v14 = v29 - (v54 - 1);
          if (v15 + v14 > v38)
          {
            v42 = __si_assert_copy_extra_521(-1);
            v43 = v42;
            v44 = "";
            if (v42)
              v44 = v42;
            __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 7814, "start+count <= oldIndexSet->indexCount", v44);
LABEL_61:
            free(v43);
            if (__valid_fs(-1))
              v47 = 2989;
            else
              v47 = 3072;
            *(_DWORD *)v47 = -559038737;
            abort();
          }
          if (v38 + v54 - 1 < v20)
          {
            v45 = __si_assert_copy_extra_521(-1);
            v43 = v45;
            v46 = "";
            if (v45)
              v46 = v45;
            __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 7815, "oldIndexSet->indexCount+(mergeCount-1) >= preCount", v46);
            goto LABEL_61;
          }
          *(_QWORD *)buf = a1;
          __checkIndexSetDocIdOrder(a1, (uint64_t *)a6);
          if (v14 < 2)
          {
            v41 = *v13;
            *(_QWORD *)buf = a1;
            __checkIndexSetDocIdOrder(a1, (uint64_t *)v41);
            return v37;
          }
          a7 = ContentIndexListClone(a6);
          v39 = *v13;
          *(_QWORD *)buf = a1;
          __checkIndexSetDocIdOrder(a1, (uint64_t *)v39);
          v19 = 0;
          v18 = v29 - (v54 - 1);
          if (v52 <= v14)
            return v37;
          goto LABEL_2;
        }
        v15 = 0;
        while (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)a6 + 8 * v15) + 48) != a2)
        {
          if (v38 == ++v15)
            goto LABEL_36;
        }
      }
      else
      {
LABEL_36:
        LODWORD(v15) = 0;
      }
      if (v15 >= v38)
      {
        LODWORD(v15) = 0;
        a2 = *(_DWORD *)(v36 + 48);
        if (a2)
        {
          if ((_DWORD)v38)
          {
            v15 = 0;
            while (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)a6 + 8 * v15) + 48) != a2)
            {
              if (v38 == ++v15)
              {
                LODWORD(v15) = 0;
                goto LABEL_45;
              }
            }
          }
        }
      }
      goto LABEL_45;
    }
  }
  v25 = a1;
  if (!a2 || *(_DWORD *)(*(_QWORD *)(*a7 + 8 * v15) + 48) == a2)
  {
LABEL_14:
    v20 = *((_DWORD *)a7 + 2);
    v27 = v15 + v14;
    if (v15 + v14 > v20)
      goto LABEL_50;
    v28 = count_IndexSet((uint64_t)a7, v27 - 1, *(_DWORD *)(*(_QWORD *)(*a7 + 8 * (v27 - 1)) + 44));
    v24 = v28 == 0;
    v21 = count_IndexSet((uint64_t)a7, v27 - 2, *(_DWORD *)(*(_QWORD *)(*a7 + 8 * (v27 - 2)) + 44))
        + v28;
    a1 = v25;
    *(_QWORD *)buf = v25;
    __checkIndexSetDocIdOrder(v25, a7);
    v13 = a5;
    v22 = *a5;
    goto LABEL_16;
  }
  v26 = *((unsigned int *)a7 + 2);
  if (!(_DWORD)v26)
  {
LABEL_12:
    LODWORD(v15) = 0;
    goto LABEL_14;
  }
  v15 = 0;
  while (*(_DWORD *)(*(_QWORD *)(*a7 + 8 * v15) + 48) != a2)
  {
    if (v26 == ++v15)
      goto LABEL_12;
  }
  if (v26 >= v15)
    goto LABEL_14;
LABEL_50:
  if ((v53 & 1) != 0)
    ContentIndexListFree((void **)a7);
  return 0;
}

int *si_message_trace_darkwake(int *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  int v10;
  uint64_t v12;
  uint64_t (*v13)(_QWORD, const char *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  int v14;
  NSObject *v15;
  int v16;
  uint64_t v17;
  __int16 v18;
  int v19;
  __int16 v20;
  uint64_t v21;
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  uint64_t v25;
  uint64_t v26;

  v10 = a4;
  v26 = *MEMORY[0x1E0C80C00];
  if ((_DWORD)result)
  {
    if (a2)
    {
      v12 = *(_QWORD *)(a2 + 2360);
      v13 = *(uint64_t (**)(_QWORD, const char *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v12 + 88);
      if (v13)
        return (int *)v13(*(_QWORD *)(v12 + 136), "com.apple.spotlight.mds.index-darkwake", a3, a4, a5, a6, a7);
    }
  }
  else if (gSILogLevels[0] >= 5)
  {
    v14 = *__error();
    v15 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      v16 = 136316162;
      v17 = a3;
      v18 = 1024;
      v19 = v10;
      v20 = 2080;
      v21 = a5;
      v22 = 2080;
      v23 = a6;
      v24 = 2048;
      v25 = a7;
      _os_log_impl(&dword_1B8270000, v15, OS_LOG_TYPE_DEFAULT, "Not tracing com.apple.spotlight.mds.index-darkwake %s %d %s %s %ld", (uint8_t *)&v16, 0x30u);
    }
    result = __error();
    *result = v14;
  }
  return result;
}

uint64_t enableProcMon()
{
  int v0;
  NSObject *v1;
  os_log_type_t v2;
  uint8_t v4[16];

  getpid();
  pthread_mutex_lock(&sProcMonLock);
  if (sDisableProcMon == 1 && proc_set_cpumon_params() && proc_set_cpumon_defaults())
  {
    v0 = *__error();
    v1 = _SILogForLogForCategory(0);
    v2 = gSILogLevels[0] < 3;
    if (os_log_type_enabled(v1, (os_log_type_t)(gSILogLevels[0] < 3)))
    {
      *(_WORD *)v4 = 0;
      _os_log_impl(&dword_1B8270000, v1, v2, "*warn* Failed to reset cpumon_params", v4, 2u);
    }
    *__error() = v0;
  }
  --sDisableProcMon;
  return pthread_mutex_unlock(&sProcMonLock);
}

void si_merge_ctx_free(uint64_t a1, char a2)
{
  NSObject *v4;
  NSObject *v5;

  if (a1)
  {
    v4 = *(NSObject **)(a1 + 1056);
    if (v4)
    {
      dispatch_resume(v4);
      dispatch_release(*(dispatch_object_t *)(a1 + 1056));
      *(_QWORD *)(a1 + 1056) = 0;
    }
    si_power_info_cleanup(a1 + 1064, *(_QWORD *)a1, a2);
    v5 = *(NSObject **)(a1 + 1112);
    if (v5)
    {
      dispatch_group_leave(*(dispatch_group_t *)(a1 + 1112));
      dispatch_release(v5);
    }
    free((void *)a1);
  }
}

uint64_t OuterMerge(uint64_t a1, int a2, unsigned int a3, __int128 **a4, uint64_t a5, uint64_t *a6, uint64_t a7, const char *a8, unsigned __int8 a9, unsigned __int8 a10)
{
  int v14;
  NSObject *v15;
  os_log_type_t v16;
  const char *v17;
  const char *v18;
  _QWORD *v19;
  _QWORD *v20;
  uint64_t v21;
  int v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  NSObject *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  NSObject *v34;
  os_log_type_t v35;
  int v36;
  NSObject *v37;
  os_log_type_t v38;
  unsigned int v39;
  unsigned int v40;
  unsigned int v41;
  _QWORD *v42;
  unsigned int v43;
  int v44;
  BOOL v45;
  unsigned int v46;
  uint64_t v47;
  int v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t *v51;
  _QWORD *v52;
  int v53;
  NSObject *v54;
  int v55;
  int v56;
  NSObject *v57;
  const char *v58;
  NSObject *v59;
  uint32_t v60;
  uint64_t v61;
  char v62;
  uint64_t v63;
  char v64;
  int v65;
  NSObject *v66;
  NSObject *v67;
  __int128 *v69;
  char *v70;
  char *v71;
  const char *v72;
  uint64_t v73;
  int v74;
  char *v75;
  char *v76;
  const char *v77;
  uint64_t v78;
  char *v79;
  const char *v80;
  int v81;
  __int128 *v84;
  _BYTE v87[14];
  _BYTE v88[10];
  uint64_t v89;
  statfs buf;
  uint64_t v91;

  v91 = *MEMORY[0x1E0C80C00];
  v14 = *__error();
  v15 = _SILogForLogForCategory(0);
  v16 = 2 * (gSILogLevels[0] < 4);
  if (os_log_type_enabled(v15, v16))
  {
    v17 = "false";
    if (a10)
      v17 = "true";
    v18 = "";
    buf.f_bsize = 67109634;
    buf.f_iosize = a3;
    *(uint64_t *)((char *)&buf.f_blocks + 2) = (uint64_t)v17;
    LOWORD(buf.f_blocks) = 2080;
    if (a9)
      v18 = "vacuum";
    WORD1(buf.f_bfree) = 2080;
    *(uint64_t *)((char *)&buf.f_bfree + 4) = (uint64_t)v18;
    _os_log_impl(&dword_1B8270000, v15, v16, "Outer Merge - count:%d live:%s %s", (uint8_t *)&buf, 0x1Cu);
  }
  *__error() = v14;
  if (a2 && (v19 = (_QWORD *)*(unsigned int *)(a5 + 8), (_DWORD)v19))
  {
    v20 = 0;
    while (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)a5 + 8 * (_QWORD)v20) + 48) != a2)
    {
      v20 = (_QWORD *)((char *)v20 + 1);
      if (v19 == v20)
        goto LABEL_12;
    }
  }
  else
  {
LABEL_12:
    v20 = 0;
  }
  if (a9 && !*(_QWORD *)(a1 + 1144))
  {
    v75 = __si_assert_copy_extra_521(-1);
    v76 = v75;
    v77 = "";
    if (v75)
      v77 = v75;
    __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 7603, "ref->workqueues.queues[SI_DEFER_QUEUE_IDX]", v77);
LABEL_104:
    free(v76);
    if (__valid_fs(-1))
      v78 = 2989;
    else
      v78 = 3072;
    *(_DWORD *)v78 = -559038737;
    abort();
  }
  *(_QWORD *)&buf.f_bsize = a1;
  __checkIndexSetDocIdOrder(a1, a6);
  if (a3)
  {
    v21 = 0;
    v22 = *(_DWORD *)(a1 + 6584) & 1 | 2;
    v23 = (uint64_t *)(*(_QWORD *)a5 + 8 * v20);
    v24 = a3;
    do
    {
      v25 = *v23++;
      v21 += index_calculate_size(v25, v22);
      --v24;
    }
    while (v24);
  }
  else
  {
    v21 = 0;
  }
  bzero(&buf, 0x878uLL);
  if (fstatfs(*(_DWORD *)(a1 + 32), &buf))
  {
    v26 = *__error();
    v27 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      v74 = *__error();
      *(_DWORD *)v87 = 136315650;
      *(_QWORD *)&v87[4] = "OuterMerge";
      *(_WORD *)&v87[12] = 1024;
      *(_DWORD *)v88 = 7623;
      *(_WORD *)&v88[4] = 1024;
      *(_DWORD *)&v88[6] = v74;
      _os_log_error_impl(&dword_1B8270000, v27, OS_LOG_TYPE_ERROR, "%s:%d: error (%d) getting free space", v87, 0x18u);
    }
    *__error() = v26;
    ContentIndexListFree((void **)a6);
    return 0;
  }
  v29 = 0x6400000 / buf.f_bsize;
  if (2 * (buf.f_blocks / 0x64) < v29)
    v29 = 2 * (buf.f_blocks / 0x64);
  v30 = 5 * (buf.f_blocks / 0x64);
  if (v30 >= 0x20000000 / buf.f_bsize)
    v30 = 0x20000000 / buf.f_bsize;
  if ((*(_BYTE *)(a1 + 6584) & 1) == 0)
    v30 = v29;
  v31 = v30 * buf.f_bsize;
  v32 = buf.f_bfree * buf.f_bsize;
  if (v32 < v31)
  {
    v33 = *__error();
    v34 = _SILogForLogForCategory(0);
    v35 = gSILogLevels[0] < 3;
    if (os_log_type_enabled(v34, (os_log_type_t)(gSILogLevels[0] < 3)))
    {
      *(_DWORD *)v87 = 134218496;
      *(_QWORD *)&v87[4] = v21;
      *(_WORD *)&v87[12] = 2048;
      *(_QWORD *)v88 = v32;
      *(_WORD *)&v88[8] = 2048;
      v89 = v31;
      _os_log_impl(&dword_1B8270000, v34, v35, "*warn* Merge canceled - low disk space (%lld %lld %lld)", v87, 0x20u);
    }
    v28 = 0;
    *__error() = v33;
    return v28;
  }
  v84 = (__int128 *)a5;
  if (a3 > 8 || a3 >= 2 && v32 < v31 + v21)
  {
    v36 = *__error();
    v37 = _SILogForLogForCategory(0);
    v38 = 2 * (gSILogLevels[0] < 4);
    if (os_log_type_enabled(v37, v38))
    {
      *(_DWORD *)v87 = 134218240;
      *(_QWORD *)&v87[4] = v21;
      *(_WORD *)&v87[12] = 2048;
      *(_QWORD *)v88 = v32;
      _os_log_impl(&dword_1B8270000, v37, v38, "used:%lld, free:%lld", v87, 0x16u);
    }
    v39 = (a3 + 1) >> 1;
    v40 = 0;
    v41 = 0;
    *__error() = v36;
    LODWORD(v42) = (_DWORD)v20;
    v43 = a3;
    while (1)
    {
      v40 += v39;
      v44 = (_DWORD)v42 + v43 - v40;
      v46 = v43 - v40;
      v45 = v44 < (int)v42 || v46 == 0;
      if (v44 >= (int)v42)
        v46 = 0;
      v47 = v46 + v39;
      if (v45)
        v48 = (int)v42;
      else
        v48 = v44;
      BYTE1(v81) = a10;
      LOBYTE(v81) = 0;
      v49 = OuterMerge(a1, *(unsigned int *)(*(_QWORD *)(*a6 + 8 * v48) + 48), v47, a4, v84, a6, a7, a8, v81);
      if (!v49)
      {
        v56 = *__error();
        v57 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)v87 = 136315394;
          *(_QWORD *)&v87[4] = "OuterMerge";
          *(_WORD *)&v87[12] = 1024;
          *(_DWORD *)v88 = 7689;
          v58 = "%s:%d: Merging failed";
          v59 = v57;
          v60 = 18;
          goto LABEL_100;
        }
        goto LABEL_88;
      }
      v50 = v49;
      if (v44 <= (int)v42 && a2)
        a2 = *(_DWORD *)(v49 + 48);
      v84 = *a4;
      v51 = ContentIndexListClone(*a4);
      a6 = v51;
      v52 = (_QWORD *)*((unsigned int *)v51 + 2);
      if (!a2)
        break;
      if ((_DWORD)v52)
      {
        v42 = 0;
        while (*(_DWORD *)(*(_QWORD *)(*v51 + 8 * (_QWORD)v42) + 48) != a2)
        {
          v42 = (_QWORD *)((char *)v42 + 1);
          if (v52 == v42)
            goto LABEL_55;
        }
        goto LABEL_56;
      }
      v42 = 0;
      if (*(_DWORD *)(v50 + 48))
        a2 = *(_DWORD *)(v50 + 48);
      else
        a2 = 0;
LABEL_66:
      if ((_DWORD)v42 != (_DWORD)v20 && gSILogLevels[0] >= 5)
      {
        v53 = *__error();
        v54 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
        {
          v55 = *((_DWORD *)a6 + 2);
          *(_DWORD *)v87 = 67109632;
          *(_DWORD *)&v87[4] = (_DWORD)v20;
          *(_WORD *)&v87[8] = 1024;
          *(_DWORD *)&v87[10] = (_DWORD)v42;
          *(_WORD *)v88 = 1024;
          *(_DWORD *)&v88[2] = v55;
          _os_log_impl(&dword_1B8270000, v54, OS_LOG_TYPE_DEFAULT, "cindex was added during merge, old start %d new start: %d cindex count:%d", v87, 0x14u);
        }
        *__error() = v53;
      }
      *(_QWORD *)v87 = a1;
      __checkIndexSetDocIdOrder(a1, a6);
      ++v41;
      v43 = a3;
      if (v40 >= a3)
        goto LABEL_76;
    }
LABEL_55:
    v42 = 0;
LABEL_56:
    if (v42 >= v52)
    {
      a2 = *(_DWORD *)(v50 + 48);
      if (a2 && (_DWORD)v52)
      {
        v42 = 0;
        while (*(_DWORD *)(*(_QWORD *)(*v51 + 8 * (_QWORD)v42) + 48) != a2)
        {
          v42 = (_QWORD *)((char *)v42 + 1);
          if (v52 == v42)
            goto LABEL_62;
        }
      }
      else
      {
LABEL_62:
        v42 = 0;
      }
    }
    goto LABEL_66;
  }
  v42 = v20;
  v41 = a3;
LABEL_76:
  if (a9 && !*(_QWORD *)(a1 + 1144))
  {
    v79 = __si_assert_copy_extra_521(-1);
    v76 = v79;
    v80 = "";
    if (v79)
      v80 = v79;
    __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 7698, "ref->workqueues.queues[SI_DEFER_QUEUE_IDX]", v80);
    goto LABEL_104;
  }
  v61 = *(_QWORD *)(*a6 + 8 * v42);
  v62 = atomic_load((unsigned int *)(v61 + 28));
  if (((v62 & 3) != 0 || *(_BYTE *)(v61 + 15163)) && (_DWORD)v42 != *((_DWORD *)a6 + 4))
  {
    v28 = InnerMerge(a1, v42, v41, (uint64_t *)a4, v84, a6, a7, a8, a9, a10);
    if (v28)
    {
      if (!*(_DWORD *)(a1 + 2428))
      {
        v69 = *a4;
        *(_QWORD *)v87 = a1;
        __checkIndexSetDocIdOrder(a1, (uint64_t *)v69);
      }
      if (a9 && *(_QWORD *)(a1 + 1144))
      {
        v70 = __si_assert_copy_extra_521(-1);
        v71 = v70;
        v72 = "";
        if (v70)
          v72 = v70;
        __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 7712, "!ref->workqueues.queues[SI_DEFER_QUEUE_IDX]", v72);
        free(v71);
        if (__valid_fs(-1))
          v73 = 2989;
        else
          v73 = 3072;
        *(_DWORD *)v73 = -559038737;
        abort();
      }
    }
  }
  else
  {
    v63 = *(_QWORD *)(*a6 + 8 * v42);
    v64 = atomic_load((unsigned int *)(v63 + 28));
    if ((v64 & 3) == 0 && !*(_BYTE *)(v63 + 15163))
    {
      v65 = *__error();
      v66 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v87 = 136315650;
        *(_QWORD *)&v87[4] = "OuterMerge";
        *(_WORD *)&v87[12] = 1024;
        *(_DWORD *)v88 = 7715;
        *(_WORD *)&v88[4] = 1024;
        *(_DWORD *)&v88[6] = (_DWORD)v42;
        _os_log_error_impl(&dword_1B8270000, v66, OS_LOG_TYPE_ERROR, "%s:%d: Failed to merge; index at %d is writable",
          v87,
          0x18u);
      }
      *__error() = v65;
    }
    if ((_DWORD)v42 != *((_DWORD *)a6 + 4))
      return 0;
    v56 = *__error();
    v67 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v87 = 136315650;
      *(_QWORD *)&v87[4] = "OuterMerge";
      *(_WORD *)&v87[12] = 1024;
      *(_DWORD *)v88 = 7717;
      *(_WORD *)&v88[4] = 1024;
      *(_DWORD *)&v88[6] = (_DWORD)v42;
      v58 = "%s:%d: Failed to merge; index at %d is current";
      v59 = v67;
      v60 = 24;
LABEL_100:
      _os_log_error_impl(&dword_1B8270000, v59, OS_LOG_TYPE_ERROR, v58, v87, v60);
    }
LABEL_88:
    v28 = 0;
    *__error() = v56;
  }
  return v28;
}

uint64_t InnerMerge(uint64_t a1, _QWORD *a2, unsigned int a3, uint64_t *a4, _QWORD *a5, _QWORD *a6, uint64_t a7, const char *a8, unsigned __int8 a9, unsigned __int8 a10)
{
  int v14;
  NSObject *v15;
  os_log_type_t v16;
  const char *v17;
  const char *v18;
  unint64_t v19;
  int v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  NSObject *v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  NSObject *v33;
  os_log_type_t v34;
  uint64_t v36;
  const char *v37;
  const char *v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  int field_id_limit;
  const __CFAllocator *v55;
  CFIndex v56;
  uint64_t v57;
  char *v58;
  int *v59;
  _DWORD *v60;
  __int128 *v61;
  _DWORD *v62;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  unsigned int v67;
  _QWORD *v68;
  uint64_t v69;
  CFSetRef v70;
  uint64_t **v71;
  uint64_t *v72;
  char *v73;
  _QWORD *v74;
  int v75;
  unsigned int *v76;
  unsigned int v77;
  unsigned int v78;
  int v79;
  NSObject *v80;
  os_log_type_t v81;
  uint64_t v82;
  int v83;
  uint64_t i;
  unint64_t *v85;
  uint64_t v86;
  int v87;
  uint64_t v88;
  _QWORD *v89;
  uint64_t v90;
  int v91;
  NSObject *v92;
  uint64_t v93;
  int v94;
  NSObject *v95;
  uint64_t v96;
  uint64_t v97;
  _QWORD *v98;
  unsigned int v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  __CFArray *Mutable;
  int v104;
  unint64_t v105;
  unint64_t v106;
  uint64_t v107;
  char v108;
  _QWORD *v109;
  unsigned int v110;
  uint64_t v111;
  unint64_t v112;
  const char *v113;
  const char *v114;
  unsigned int *v115;
  unsigned int v116;
  const char *v117;
  const char *v118;
  unsigned int v119;
  unsigned int v120;
  unint64_t v121;
  _QWORD *v122;
  uint64_t v123;
  qos_class_t v124;
  char *v125;
  uint64_t v126;
  uint64_t v127;
  unint64_t v128;
  int v129;
  NSObject *v130;
  os_log_type_t v131;
  uint64_t *v132;
  _QWORD *v133;
  uint64_t v134;
  void (*v135)(_QWORD, uint64_t, uint64_t);
  char *v136;
  char *v137;
  const char *v138;
  char *v139;
  const char *v140;
  char *v141;
  const char *v142;
  char *v143;
  const char *v144;
  char *v145;
  const char *v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  CFAllocatorRef v150;
  uint64_t v151;
  char *v152;
  _QWORD *v153;
  uint64_t v154;
  uint64_t v155;
  const char *v156;
  uint64_t *v157;
  int v158;
  int v159;
  _QWORD *v160;
  _QWORD v161[6];
  _QWORD v162[5];
  _OWORD v163[4];
  char *v164;
  _QWORD *v165;
  __int128 v166;
  uint64_t v167;
  __int128 v168;
  uint64_t v169;
  _QWORD v170[2];
  void (*v171)(uint64_t, CFIndex);
  void *v172;
  char *v173;
  _OWORD *v174;
  statfs v175;
  __int128 v176[2];
  uint64_t v177;
  uint64_t (*v178)(_QWORD *, unsigned __int8 *, unsigned int);
  _OWORD *v179;
  _QWORD *v180;
  uint64_t v181;

  v155 = a7;
  v156 = a8;
  v160 = a5;
  v157 = a4;
  v159 = a10;
  v181 = *MEMORY[0x1E0C80C00];
  v164 = 0;
  v165 = 0;
  ++*(_QWORD *)(a1 + 2392);
  asprintf(&v164, "tmp.merge.%ld.", v148);
  *(_QWORD *)&v175.f_bsize = a1;
  __checkIndexSetDocIdOrder(a1, a6);
  v14 = *__error();
  v15 = _SILogForLogForCategory(0);
  v16 = 2 * (gSILogLevels[0] < 4);
  if (os_log_type_enabled(v15, v16))
  {
    v17 = "false";
    if (v159)
      v17 = "true";
    v18 = "";
    v175.f_bsize = 67109634;
    v175.f_iosize = a3;
    *(uint64_t *)((char *)&v175.f_blocks + 2) = (uint64_t)v17;
    LOWORD(v175.f_blocks) = 2080;
    if (a9)
      v18 = "vacuum";
    WORD1(v175.f_bfree) = 2080;
    *(uint64_t *)((char *)&v175.f_bfree + 4) = (uint64_t)v18;
    _os_log_impl(&dword_1B8270000, v15, v16, "Inner Merge - count:%d live:%s %s", (uint8_t *)&v175, 0x1Cu);
  }
  v158 = a9;
  *__error() = v14;
  v19 = 0;
  if (a3)
  {
    v20 = *(_DWORD *)(a1 + 6584) & 1 | 2;
    v21 = (uint64_t *)(*v160 + 8 * a2);
    v22 = a3;
    do
    {
      v23 = *v21++;
      v19 += index_calculate_size(v23, v20);
      --v22;
    }
    while (v22);
  }
  bzero(&v175, 0x878uLL);
  if (fstatfs(*(_DWORD *)(a1 + 32), &v175))
  {
    v24 = *__error();
    v25 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      v39 = *__error();
      LODWORD(v176[0]) = 136315650;
      *(_QWORD *)((char *)v176 + 4) = "InnerMerge";
      WORD6(v176[0]) = 1024;
      *(_DWORD *)((char *)v176 + 14) = 7441;
      WORD1(v176[1]) = 1024;
      DWORD1(v176[1]) = v39;
      _os_log_error_impl(&dword_1B8270000, v25, OS_LOG_TYPE_ERROR, "%s:%d: error (%d) getting free space", (uint8_t *)v176, 0x18u);
    }
    *__error() = v24;
    ContentIndexListFree((void **)a6);
    return 0;
  }
  v27 = v175.f_blocks / 0x64;
  v28 = 0x6400000 / v175.f_bsize;
  if (2 * (v175.f_blocks / 0x64) < v28)
    v28 = 2 * v27;
  v29 = 5 * v27;
  if (v29 >= 0x20000000 / v175.f_bsize)
    v29 = 0x20000000 / v175.f_bsize;
  if ((*(_BYTE *)(a1 + 6584) & 1) == 0)
    v29 = v28;
  v30 = v29 * v175.f_bsize;
  v31 = v175.f_bfree * v175.f_bsize;
  if (v31 < v30 || v19 > v31 && v19 - v31 < v30 || v31 > v19 && v31 - v19 < v30)
  {
    v32 = *__error();
    v33 = _SILogForLogForCategory(0);
    v34 = gSILogLevels[0] < 3;
    if (os_log_type_enabled(v33, (os_log_type_t)(gSILogLevels[0] < 3)))
    {
      LODWORD(v176[0]) = 134218496;
      *(_QWORD *)((char *)v176 + 4) = v19;
      WORD6(v176[0]) = 2048;
      *(_QWORD *)((char *)v176 + 14) = v31;
      WORD3(v176[1]) = 2048;
      *((_QWORD *)&v176[1] + 1) = v30;
      _os_log_impl(&dword_1B8270000, v33, v34, "*warn* Merge canceled - low disk space (%lld %lld %lld)", (uint8_t *)v176, 0x20u);
    }
    v26 = 0;
    *__error() = v32;
    return v26;
  }
  v36 = a2;
  if (*(_QWORD *)(*(_QWORD *)(a1 + 2360) + 96))
  {
    v37 = "merge";
    *(_QWORD *)&v176[0] = 0;
    if (v158)
      v37 = "vacuum";
    if (v159)
      v38 = "live";
    else
      v38 = "sync";
    asprintf((char **)v176, "com.apple.spotlightindex.%s.%s.%d", v37, v38, 64 - __clz(v19));
    v151 = (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 2360) + 96))(*(_QWORD *)(*(_QWORD *)(a1 + 2360) + 136), *(_QWORD *)&v176[0]);
    free(*(void **)&v176[0]);
  }
  else
  {
    v151 = 0;
  }
  pthread_mutex_lock(&mergeMutex);
  *(_WORD *)(a1 + 2434) = 257;
  pthread_mutex_unlock(&mergeMutex);
  v40 = *a6 + 8 * a2;
  v41 = a3;
  v42 = *(_QWORD *)(v40 + 8 * a3 - 8);
  LODWORD(v43) = *(_DWORD *)(v42 + 60);
  v44 = *(_QWORD *)(v42 + 72);
  if (v43 >= 2)
    v43 = v43;
  else
    v43 = 0;
  v45 = v44 + v43 - *(_QWORD *)(*(_QWORD *)v40 + 72);
  v46 = 8 * a3;
  if (a3)
  {
    v47 = 0;
    v48 = 0;
    do
    {
      if (v47)
      {
        v50 = *(_QWORD *)(v40 + v47 - 8);
        v49 = *(_QWORD *)(v40 + v47);
        LODWORD(v51) = *(_DWORD *)(v50 + 60);
        v52 = *(_QWORD *)(v50 + 72);
        if (v51 >= 2)
          v51 = v51;
        else
          v51 = 0;
        v48 = *(_QWORD *)(v49 + 72) + v48 - v52 - v51;
      }
      else
      {
        v49 = *(_QWORD *)v40;
      }
      v53 = atomic_load((unsigned int *)(v49 + 12));
      v48 += v53;
      v47 += 8;
    }
    while (v46 != v47);
  }
  else
  {
    v48 = 0;
  }
  v154 = a2;
  if (v45 <= 0xE38E38E || (v26 = 0, v158) && v45 - v48 <= 0xCCCCCCB)
  {
    memset(&v163[1], 0, 40);
    v163[0] = 0u;
    field_id_limit = db_get_field_id_limit(*(int **)(a1 + 1184));
    memset((char *)&v163[1] + 8, 0, 32);
    v55 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v163[0] = (unint64_t)a1;
    v56 = (field_id_limit + 1);
    *(_QWORD *)&v163[1] = v56;
    v150 = v55;
    if (field_id_limit == -1)
    {
      *(_QWORD *)&v163[2] = 0;
      *((_QWORD *)&v163[2] + 1) = v56;
      *(_QWORD *)&v163[3] = 0;
      v57 = MEMORY[0x1E0C809B0];
    }
    else
    {
      *((_QWORD *)&v163[1] + 1) = CFBitVectorCreateMutable(v55, v56);
      CFBitVectorSetCount(*((CFMutableBitVectorRef *)&v163[1] + 1), v56);
      if (!*((_QWORD *)&v163[1] + 1)
        || (*(_QWORD *)&v163[2] = 0,
            *((_QWORD *)&v163[2] + 1) = v56,
            *(_QWORD *)&v163[3] = CFBitVectorCreateMutable(v55, v56),
            CFBitVectorSetCount(*(CFMutableBitVectorRef *)&v163[3], v56),
            !*(_QWORD *)&v163[3]))
      {
        v136 = __si_assert_copy_extra_521(-1);
        v137 = v136;
        v138 = "";
        if (v136)
          v138 = v136;
        __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 47, "bv->_cfbv", v138);
LABEL_197:
        free(v137);
        if (__valid_fs(-1))
          v147 = 2989;
        else
          v147 = 3072;
        *(_DWORD *)v147 = -559038737;
        abort();
      }
      v57 = MEMORY[0x1E0C809B0];
    }
    v58 = (char *)v163 + 8;
    v59 = *(int **)(a1 + 1184);
    v170[0] = v57;
    v170[1] = 0x40000000;
    v171 = __si_merge_term_filter_ctx_init_block_invoke;
    v172 = &__block_descriptor_tmp_605;
    v173 = (char *)v163 + 8;
    v174 = &v163[2];
    v153 = &v163[2];
    memset(v176, 0, sizeof(v176));
    v60 = db_copy_field_ids_with_buffer(v59, "_kMDItemExternalID", (uint64_t)v176, 8uLL);
    v152 = (char *)v163 + 8;
    if (v60)
    {
      v61 = (__int128 *)v60;
      if (*v60)
      {
        v62 = v60 + 1;
        do
          ((void (*)(_QWORD *))v171)(v170);
        while (*v62++);
      }
      v58 = v152;
      if (v61 != v176)
        free(v61);
    }
    bit_vector_set((uint64_t)v58, *(unsigned int *)(a1 + 2040));
    bit_vector_set((uint64_t)v58, *(unsigned int *)(a1 + 2044));
    bit_vector_set((uint64_t)v58, *(unsigned int *)(a1 + 2048));
    v64 = gDefaultSchema;
    v65 = MEMORY[0x1E0C809B0];
    if (gDefaultSchema)
    {
      v168 = 0uLL;
      v169 = 0;
      v176[0] = xmmword_1E6E2CA98;
      *(_QWORD *)&v176[1] = 0;
      _MDPlistContainerGetPlistObjectAtKeyArray();
      *(_QWORD *)&v176[0] = v65;
      *((_QWORD *)&v176[0] + 1) = 0x40000000;
      *(_QWORD *)&v176[1] = __si_merge_term_filter_ctx_init_block_invoke_2;
      *((_QWORD *)&v176[1] + 1) = &__block_descriptor_tmp_611;
      v177 = a1;
      v178 = (uint64_t (*)(_QWORD *, unsigned __int8 *, unsigned int))v58;
      v179 = v153;
      v166 = v168;
      v167 = v169;
      v64 = _MDPlistDictionaryIterate();
    }
    v162[0] = v65;
    v162[1] = 0x40000000;
    v162[2] = __InnerMerge_block_invoke;
    v162[3] = &__block_descriptor_tmp_599;
    v162[4] = a1;
    MEMORY[0x1E0C80A78](v64);
    bzero((char *)&v149 - ((v46 + 15) & 0xFFFFFFFF0), 8 * a3);
    if (a3)
    {
      v66 = *a6;
      v67 = a2;
      v68 = (uint64_t *)((char *)&v149 - ((v46 + 15) & 0xFFFFFFFF0));
      v69 = a3;
      do
      {
        *v68++ = *(int *)(*(_QWORD *)(v66 + 8 * v67++) + 48);
        --v69;
      }
      while (v69);
    }
    v70 = CFSetCreate(v150, (const void **)((char *)&v149 - ((v46 + 15) & 0xFFFFFFFF0)), a3, 0);
    setUpOverlay(a1, v70);
    CFRelease(v70);
    v71 = (uint64_t **)(*a6 + 8 * v154);
    *(_QWORD *)&v176[0] = si_merge_lock;
    *((_QWORD *)&v176[0] + 1) = si_merge_unlock;
    if (v158)
      v72 = (uint64_t *)&v165;
    else
      v72 = 0;
    *(_QWORD *)&v176[1] = si_should_cancel_merge;
    *((_QWORD *)&v176[1] + 1) = si_message_trace_lifecycle;
    v177 = a1;
    v178 = si_merge_term_filter;
    v179 = v163;
    v180 = v162;
    v26 = ContentIndexMergeIndexes(v71, a3, v164, v72, v176);
    if (*((_QWORD *)&v163[1] + 1))
    {
      CFRelease(*((CFTypeRef *)&v163[1] + 1));
      *((_QWORD *)&v163[1] + 1) = 0;
    }
    v73 = v152;
    *(_QWORD *)v152 = 0;
    *((_QWORD *)v73 + 1) = 0;
    if (*(_QWORD *)&v163[3])
    {
      CFRelease(*(CFTypeRef *)&v163[3]);
      *(_QWORD *)&v163[3] = 0;
    }
    v74 = v153;
    *v153 = 0;
    v74[1] = 0;
    if (v26)
      SIActivityJournalMergeIndices((os_unfair_lock_s *)(a1 + 2192), a2, a3, v159);
    v36 = v154;
  }
  v75 = *(_DWORD *)(*(_QWORD *)(*a6 + 8 * v36) + 48);
  free(v164);
  if (!v26)
  {
    v91 = *__error();
    v92 = _SILogForLogForCategory(10);
    v93 = (2 * (dword_1EF19FCB4 < 4));
    if (os_log_type_enabled(v92, (os_log_type_t)(2 * (dword_1EF19FCB4 < 4))))
    {
      LODWORD(v176[0]) = 136315138;
      *(_QWORD *)((char *)v176 + 4) = v155;
      _os_log_impl(&dword_1B8270000, v92, (os_log_type_t)v93, "CIMergeIndex failure at %s", (uint8_t *)v176, 0xCu);
    }
    *__error() = v91;
    free((void *)*a6);
    free(a6);
    goto LABEL_110;
  }
  if (v165)
    SetupRemapping(a1, (uint64_t)v165);
  if (v158 && !*(_QWORD *)(a1 + 1144))
  {
    v139 = __si_assert_copy_extra_521(-1);
    v137 = v139;
    v140 = "";
    if (v139)
      v140 = v139;
    __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 7524, "ref->workqueues.queues[SI_DEFER_QUEUE_IDX]", v140);
    goto LABEL_197;
  }
  LODWORD(v152) = v75;
  v153 = v165;
  pthread_mutex_lock(&mergeMutex);
  *(_BYTE *)(a1 + 2435) = 0;
  if (*(_DWORD *)(a1 + 2428))
    pthread_cond_broadcast(&mergeCond);
  pthread_mutex_unlock(&mergeMutex);
  v76 = (unsigned int *)(a1 + 1452);
  do
    v77 = __ldaxr(v76);
  while (__stlxr(v77 + 1, v76));
  si_scheduler_suspend(*(_QWORD *)(a1 + 872));
  do
    v78 = __ldaxr(v76);
  while (__stlxr(v78 - 1, v76));
  pthread_mutex_lock(&mergeMutex);
  *(_BYTE *)(a1 + 2435) = 1;
  pthread_mutex_unlock(&mergeMutex);
  v79 = *__error();
  v80 = _SILogForLogForCategory(0);
  v81 = 2 * (gSILogLevels[0] < 4);
  if (os_log_type_enabled(v80, v81))
  {
    v82 = *(_QWORD *)(a1 + 1384);
    v83 = *(_DWORD *)(v82 + 8);
    LODWORD(v82) = *(_DWORD *)(v82 + 16);
    LODWORD(v176[0]) = 134218496;
    *(_QWORD *)((char *)v176 + 4) = a1;
    WORD6(v176[0]) = 1024;
    *(_DWORD *)((char *)v176 + 14) = v83;
    WORD1(v176[1]) = 1024;
    DWORD1(v176[1]) = v82;
    _os_log_impl(&dword_1B8270000, v80, v81, "InsertNewIndex %p live count %d current %d", (uint8_t *)v176, 0x18u);
  }
  *__error() = v79;
  if (!_CIMergeDeletes(v26, (uint64_t)v153, *a6 + 8 * v154, a3))
  {
    mergeOverlay((uint64_t *)a1, 0);
    si_scheduler_resume(*(_QWORD *)(a1 + 872), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 6968);
    v94 = *__error();
    v95 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v95, OS_LOG_TYPE_ERROR))
    {
      LODWORD(v176[0]) = 136315650;
      *(_QWORD *)((char *)v176 + 4) = "InnerMerge";
      WORD6(v176[0]) = 1024;
      *(_DWORD *)((char *)v176 + 14) = 7528;
      WORD1(v176[1]) = 2080;
      *(_QWORD *)((char *)&v176[1] + 4) = v155;
      _os_log_error_impl(&dword_1B8270000, v95, OS_LOG_TYPE_ERROR, "%s:%d: InsertNewIndex failed at %s", (uint8_t *)v176, 0x1Cu);
    }
    *__error() = v94;
    free((void *)*a6);
    free(a6);
    _CIDeleteIndex(v26, 1);
LABEL_110:
    pthread_mutex_lock(&mergeMutex);
    *(_WORD *)(a1 + 2434) = 0;
    if (*(_DWORD *)(a1 + 2428))
      pthread_cond_broadcast(&mergeCond);
    pthread_mutex_unlock(&mergeMutex);
    mergeOverlay((uint64_t *)a1, 0);
    v26 = 0;
    v96 = 0;
    goto LABEL_179;
  }
  si_scheduler_suspend(*(_QWORD *)(a1 + 864));
  for (i = 880; i != 944; i += 8)
    si_scheduler_suspend(*(_QWORD *)(a1 + i));
  v85 = (unint64_t *)v157;
  v86 = *v157;
  if ((_QWORD *)*v157 == v160)
  {
    v86 = (uint64_t)v160;
    v90 = v154;
    v87 = (int)v152;
  }
  else
  {
    free((void *)*a6);
    free(a6);
    a6 = ContentIndexListClone((__int128 *)v86);
    v87 = (int)v152;
    if ((_DWORD)v152 && (v88 = *(unsigned int *)(v86 + 8), (_DWORD)v88))
    {
      v89 = 0;
      while (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)v86 + 8 * (_QWORD)v89) + 48) != (_DWORD)v152)
      {
        v89 = (_QWORD *)((char *)v89 + 1);
        if ((_QWORD *)v88 == v89)
          goto LABEL_102;
      }
      a2 = v89;
    }
    else
    {
LABEL_102:
      a2 = 0;
    }
    v90 = a2;
  }
  v160 = a2;
  v154 = v86;
  if (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)v86 + 8 * v90) + 48) != v87)
  {
    v141 = __si_assert_copy_extra_521(-1);
    v137 = v141;
    v142 = "";
    if (v141)
      v142 = v141;
    __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 6994, "ContentIndexGetId(oldIndexSet->index[start])==anchor", v142);
    goto LABEL_197;
  }
  v97 = v90;
  v98 = ContentIndexListClone(0);
  if (a3)
  {
    v99 = v160;
    do
    {
      v100 = v99;
      v101 = *(_QWORD *)(*a6 + 8 * v99);
      if (v101)
      {
        _CIDeleteIndex(v101, 0);
        v102 = *(_QWORD *)(*a6 + 8 * v100);
      }
      else
      {
        v102 = 0;
      }
      ContentIndexListAppend((uint64_t)v98, v102);
      *(_QWORD *)(*a6 + 8 * v100) = 0;
      v99 = v100 + 1;
      --v41;
    }
    while (v41);
  }
  *(_QWORD *)(*a6 + 8 * v97) = v26;
  if (v153)
  {
    Mutable = *(__CFArray **)(a1 + 2368);
    if (!Mutable)
    {
      Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
      *(_QWORD *)(a1 + 2368) = Mutable;
    }
    CFArrayAppendValue(Mutable, v153);
  }
  v104 = _os_feature_enabled_impl();
  LODWORD(v105) = *((_DWORD *)a6 + 2);
  if (v104)
  {
    if (!(_DWORD)v105)
    {
      v109 = v160;
      v110 = (_DWORD)v160 + a3;
      goto LABEL_139;
    }
    v106 = 0;
    do
    {
      v107 = *(_QWORD *)(*a6 + 8 * v106);
      if (v107)
      {
        v108 = atomic_load((unsigned int *)(v107 + 28));
        if ((v108 & 3) == 0 && !*(_BYTE *)(v107 + 15163))
          _CIFlushCache(v107, 1, 0, 0, (uint64_t)&__block_literal_global_626);
      }
      ++v106;
      v105 = *((unsigned int *)a6 + 2);
    }
    while (v106 < v105);
    v85 = (unint64_t *)v157;
  }
  v109 = v160;
  v110 = (_DWORD)v160 + a3;
  if (v160 + a3 < v105)
  {
    v111 = ((_DWORD)v160 + 1);
    v152 = (char *)(v160 + a3);
    v112 = (unint64_t)v152;
    v113 = v156;
    do
    {
      *(_QWORD *)(*a6 + 8 * v111) = *(_QWORD *)(*a6 + 8 * v112);
      bzero(v176, 0x400uLL);
      v114 = fmtcheck(v113, "%i");
      snprintf((char *)v176, 0x400uLL, v114, v111);
      ContentIndexChangePrefix(*(_QWORD *)(*a6 + 8 * v111));
      ++v112;
      v105 = *((unsigned int *)a6 + 2);
      v111 = (v111 + 1);
    }
    while (v112 < v105);
    v85 = (unint64_t *)v157;
    v109 = v160;
    v110 = v152;
  }
LABEL_139:
  if (v159)
  {
    v115 = (unsigned int *)(a6 + 2);
    v116 = *((_DWORD *)a6 + 4);
  }
  else
  {
    v116 = *(_DWORD *)(*(_QWORD *)(a1 + 1392) + 16);
    v115 = (unsigned int *)(a6 + 2);
    if (v116 == -1)
      *v115 = -1;
    else
      v116 = *v115;
    if (v116 == v110 - 1)
    {
      *v115 = -1;
      v117 = v156;
      goto LABEL_149;
    }
  }
  v117 = v156;
  if (v116 != -1 && v116 > v109)
    *v115 = v116 - a3 + 1;
LABEL_149:
  *((_DWORD *)a6 + 2) = v105 - a3 + 1;
  bzero(v176, 0x400uLL);
  v118 = fmtcheck(v117, "%i");
  snprintf((char *)v176, 0x400uLL, v118, v109);
  ContentIndexChangePrefix(v26);
  ContentIndexMergeComplete((_DWORD *)v26);
  *(_QWORD *)&v163[0] = MEMORY[0x1E0C809B0];
  *((_QWORD *)&v163[0] + 1) = 0x40000000;
  *(_QWORD *)&v163[1] = __InsertNewIndex_block_invoke_2;
  *((_QWORD *)&v163[1] + 1) = &__block_descriptor_tmp_629;
  *(_QWORD *)&v163[2] = a1;
  *((_QWORD *)&v163[2] + 1) = v26;
  ContentIndexSetDirtyCallback(v26, v163);
  *(_BYTE *)(v26 + 15161) = 4;
  if (!si_swapIndexSet((int *)a1, v154, (unint64_t)a6, v85))
  {
    v143 = __si_assert_copy_extra_521(-1);
    v137 = v143;
    v144 = "";
    if (v143)
      v144 = v143;
    __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 7075, "si_swapIndexSet(ref, oldIndexSet, indexSet, indexSetPtr,1, live)", v144);
    goto LABEL_197;
  }
  ++*(_DWORD *)(a1 + 1400);
  v119 = *(_DWORD *)(*(_QWORD *)(a1 + 1392) + 8);
  if (*(_DWORD *)(a1 + 1232) > v119)
    *(_DWORD *)(a1 + 1232) = v119;
  if (*(_DWORD *)(a1 + 1240) > v119)
    *(_DWORD *)(a1 + 1240) = v119;
  v120 = *(_DWORD *)(*(_QWORD *)(a1 + 1384) + 8);
  if (*(_DWORD *)(a1 + 1236) > v120)
    *(_DWORD *)(a1 + 1236) = v120;
  if (*(_DWORD *)(a1 + 1244) > v120)
    *(_DWORD *)(a1 + 1244) = v120;
  _CIMetaInfoSync(a1 + 1192, gTerminating == 0);
  si_set_obj_state((os_unfair_lock_s *)a1, v26);
  if (*((_DWORD *)v98 + 2))
  {
    v121 = 0;
    do
    {
      v122 = malloc_type_malloc(0x10uLL, 0x20040A4A59CD2uLL);
      v122[1] = a1;
      *v122 = *(_QWORD *)(*v98 + 8 * v121);
      v123 = *(_QWORD *)(a1 + 1096);
      v124 = qos_class_self();
      si_enqueue_work_with_qos(v123, v124, (uint64_t)si_freeIndex0, (uint64_t)v122);
      ++v121;
    }
    while (v121 < *((unsigned int *)v98 + 2));
  }
  free((void *)*v98);
  free(v98);
  if ((v158 & 1) != 0)
    handleDeferQueue(a1);
  if (v153)
  {
    si_sync_ctx_create_with_defer_fd(a1, 0);
    v126 = (uint64_t)v125;
    v125[96] = 1;
    if (!*(_BYTE *)(*(_QWORD *)v125 + 2437) && !*(_BYTE *)(*(_QWORD *)v125 + 2072))
      attachJournal(v125);
    syncIndex(v126, 0);
  }
  v127 = 117;
  do
  {
    si_scheduler_resume(*(_QWORD *)(a1 + 8 * v127), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 7137);
    v128 = v127 - 108;
    --v127;
  }
  while (v128 > 2);
  si_scheduler_resume(*(_QWORD *)(a1 + 864), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 7140);
  mergeOverlay((uint64_t *)a1, v26);
  db_scan_lost_ids(*(int **)(a1 + 1184));
  si_scheduler_resume(*(_QWORD *)(a1 + 872), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 7146);
  v129 = *__error();
  v130 = _SILogForLogForCategory(10);
  v131 = 2 * (dword_1EF19FCB4 < 4);
  if (os_log_type_enabled(v130, v131))
  {
    LODWORD(v176[0]) = 136315138;
    *(_QWORD *)((char *)v176 + 4) = v155;
    _os_log_impl(&dword_1B8270000, v130, v131, "InsertNewIndex success at %s", (uint8_t *)v176, 0xCu);
  }
  *__error() = v129;
  v161[0] = MEMORY[0x1E0C809B0];
  v161[1] = 0x40000000;
  v161[2] = __InnerMerge_block_invoke_600;
  v161[3] = &__block_descriptor_tmp_602;
  v161[4] = a1;
  v161[5] = v26;
  dispatch_apply(2uLL, 0, v161);
  v132 = (uint64_t *)*v85;
  *(_QWORD *)&v176[0] = a1;
  __checkIndexSetDocIdOrder(a1, v132);
  if (v158 && *(_QWORD *)(a1 + 1144))
  {
    v145 = __si_assert_copy_extra_521(-1);
    v137 = v145;
    v146 = "";
    if (v145)
      v146 = v145;
    __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 7552, "!ref->workqueues.queues[SI_DEFER_QUEUE_IDX]", v146);
    goto LABEL_197;
  }
  if (v165)
  {
    v133 = malloc_type_malloc(0x18uLL, 0x20040960023A9uLL);
    *v133 = a1;
    v133[1] = v26;
    v133[2] = v165;
    si_remapForIndex((uint64_t)v133, 0);
  }
  pthread_mutex_lock(&mergeMutex);
  *(_WORD *)(a1 + 2434) = 0;
  if (*(_DWORD *)(a1 + 2428))
    pthread_cond_broadcast(&mergeCond);
  pthread_mutex_unlock(&mergeMutex);
  v96 = 1;
LABEL_179:
  v134 = *(_QWORD *)(a1 + 2360);
  v135 = *(void (**)(_QWORD, uint64_t, uint64_t))(v134 + 104);
  if (v135)
    v135(*(_QWORD *)(v134 + 136), v151, v96);
  return v26;
}

void __si_merge_term_filter_ctx_init_block_invoke(uint64_t a1, CFIndex idx)
{
  CFIndex v3;

  v3 = idx;
  bit_vector_set(*(_QWORD *)(a1 + 32), idx);
  bit_vector_set(*(_QWORD *)(a1 + 40), v3);
}

void bit_vector_set(uint64_t a1, CFIndex idx)
{
  CFIndex v4;
  CFIndex v5;
  char *v6;
  char *v7;
  const char *v8;
  uint64_t v9;
  const __CFBitVector *v10;
  const __CFAllocator *v11;
  __CFBitVector *MutableCopy;
  __CFBitVector *v13;
  const void *v14;
  char *v15;
  const char *v16;

  v4 = *(_QWORD *)(a1 + 8);
  if (v4 <= idx)
  {
    if (v4)
      v5 = *(_QWORD *)(a1 + 8);
    else
      v5 = 32;
    while (1)
    {
      v5 *= 2;
      if (v5 > idx)
        break;
      if (v5 <= v4)
      {
        v6 = __si_assert_copy_extra_521(-1);
        v7 = v6;
        v8 = "";
        if (v6)
          v8 = v6;
        __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 111, "newCapacity > bv->capacity", v8);
        goto LABEL_13;
      }
    }
    v10 = *(const __CFBitVector **)(a1 + 16);
    v11 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    if (v10)
      MutableCopy = CFBitVectorCreateMutableCopy(v11, v5, v10);
    else
      MutableCopy = CFBitVectorCreateMutable(v11, v5);
    v13 = MutableCopy;
    if (!MutableCopy)
    {
      v15 = __si_assert_copy_extra_521(-1);
      v7 = v15;
      v16 = "";
      if (v15)
        v16 = v15;
      __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 115, "newBV", v16);
LABEL_13:
      free(v7);
      if (__valid_fs(-1))
        v9 = 2989;
      else
        v9 = 3072;
      *(_DWORD *)v9 = -559038737;
      abort();
    }
    CFBitVectorSetCount(MutableCopy, v5);
    v14 = *(const void **)(a1 + 16);
    if (v14)
      CFRelease(v14);
    *(_QWORD *)(a1 + 8) = v5;
    *(_QWORD *)(a1 + 16) = v13;
  }
  if (*(_QWORD *)a1 <= idx)
    *(_QWORD *)a1 = idx + 1;
  CFBitVectorSetBitAtIndex(*(CFMutableBitVectorRef *)(a1 + 16), idx, 1u);
}

void __si_merge_term_filter_ctx_init_block_invoke_2(uint64_t a1, char *a2, uint64_t a3, __int128 *a4)
{
  int *v7;
  _DWORD *v8;
  __int128 *v9;
  _DWORD *v10;
  uint64_t v12;
  int *v13;
  _DWORD *v14;
  _DWORD *v15;
  _QWORD v17[2];
  void (*v18)(uint64_t, CFIndex);
  void *v19;
  uint64_t v20;
  _QWORD v21[2];
  void (*v22)(uint64_t, CFIndex);
  void *v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v25 = 0uLL;
  v26 = 0;
  v27 = *a4;
  *(_QWORD *)&v28 = *((_QWORD *)a4 + 2);
  if (_MDPlistDictionaryGetPlistObjectForKey())
  {
    v27 = v25;
    *(_QWORD *)&v28 = v26;
    if (_MDPlistGetPlistObjectType() == 225)
    {
      v27 = v25;
      *(_QWORD *)&v28 = v26;
      if (_MDPlistBooleanGetValue())
      {
        v7 = *(int **)(*(_QWORD *)(a1 + 32) + 1184);
        v21[0] = MEMORY[0x1E0C809B0];
        v21[1] = 0x40000000;
        v22 = __si_merge_term_filter_ctx_init_block_invoke_3;
        v23 = &__block_descriptor_tmp_608;
        v24 = *(_OWORD *)(a1 + 40);
        v27 = 0u;
        v28 = 0u;
        v8 = db_copy_field_ids_with_buffer(v7, a2, (uint64_t)&v27, 8uLL);
        if (v8)
        {
          v9 = (__int128 *)v8;
          if (*v8)
          {
            v10 = v8 + 1;
            do
              ((void (*)(_QWORD *))v22)(v21);
            while (*v10++);
          }
LABEL_16:
          if (v9 != &v27)
            free(v9);
        }
      }
    }
  }
  else
  {
    v27 = *a4;
    *(_QWORD *)&v28 = *((_QWORD *)a4 + 2);
    if (_MDPlistDictionaryGetPlistObjectForKey())
    {
      v27 = v25;
      *(_QWORD *)&v28 = v26;
      if (_MDPlistGetPlistObjectType() == 225)
      {
        v27 = v25;
        *(_QWORD *)&v28 = v26;
        if (_MDPlistBooleanGetValue())
        {
          v12 = *(_QWORD *)(a1 + 40);
          v13 = *(int **)(*(_QWORD *)(a1 + 32) + 1184);
          v17[0] = MEMORY[0x1E0C809B0];
          v17[1] = 0x40000000;
          v18 = __si_merge_term_filter_ctx_init_block_invoke_4;
          v19 = &__block_descriptor_tmp_609;
          v20 = v12;
          v27 = 0u;
          v28 = 0u;
          v14 = db_copy_field_ids_with_buffer(v13, a2, (uint64_t)&v27, 8uLL);
          if (v14)
          {
            v9 = (__int128 *)v14;
            if (*v14)
            {
              v15 = v14 + 1;
              do
                ((void (*)(_QWORD *))v18)(v17);
              while (*v15++);
            }
            goto LABEL_16;
          }
        }
      }
    }
  }
}

void si_merge_lock(uint64_t a1)
{
  unsigned int *v1;
  unsigned int v2;
  unsigned int v3;

  if (a1)
  {
    v1 = (unsigned int *)(a1 + 1452);
    do
      v2 = __ldaxr(v1);
    while (__stlxr(v2 + 1, v1));
    si_scheduler_suspend(*(_QWORD *)(a1 + 872));
    do
      v3 = __ldaxr(v1);
    while (__stlxr(v3 - 1, v1));
  }
}

uint64_t si_merge_unlock(uint64_t result)
{
  if (result)
    return si_scheduler_resume(*(_QWORD *)(result + 872), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 6053);
  return result;
}

BOOL si_should_cancel_merge(uint64_t a1)
{
  si_suspend_if_bad_time(a1);
  return *(_DWORD *)(a1 + 2428) != 0;
}

uint64_t si_message_trace_lifecycle(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6;
  uint64_t (*v7)(_QWORD, const char *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);

  if (result)
  {
    v6 = *(_QWORD *)(result + 2360);
    v7 = *(uint64_t (**)(_QWORD, const char *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v6 + 88);
    if (v7)
      return v7(*(_QWORD *)(v6 + 136), "com.apple.spotlight.mds.index-lifecycle", a2, a3, a4, a5, a6);
  }
  return result;
}

uint64_t si_merge_term_filter(_QWORD *a1, unsigned __int8 *a2, unsigned int a3)
{
  int v6;
  unsigned int v7;
  int v9;
  CFIndex v10;
  const __CFBitVector *v11;
  char *v12;
  char *v13;
  const char *v14;
  uint64_t v15;
  char *v16;
  char *v17;
  const char *v18;
  uint64_t v19;

  v6 = triePropertyID(a2, a3);
  if (v6 != si_merge_term_filter_lastID)
    si_merge_term_filter_lastID = v6;
  if (a3 == 2)
  {
    if (*a2 > 5u)
      return 0;
    v7 = a2[1];
    return v7 < 6;
  }
  if (a3 == 1)
  {
    v7 = *a2;
    return v7 < 6;
  }
  if (a3 >= 3 && *a2 <= 5u)
  {
    v9 = triePropertyID(a2, a3);
    if (v9)
    {
      if (*a2 == 1 && a2[1] == 2)
      {
        if (v9 < 0)
        {
          v16 = __si_assert_copy_extra_521(-1);
          v17 = v16;
          v18 = "";
          if (v16)
            v18 = v16;
          __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 96, "bitIndex >= 0", v18);
          free(v17);
          if (__valid_fs(-1))
            v19 = 2989;
          else
            v19 = 3072;
          *(_DWORD *)v19 = -559038737;
          abort();
        }
        v10 = v9;
        if (a1[4] <= v9)
          return 0;
        v11 = (const __CFBitVector *)a1[6];
      }
      else
      {
        if (v9 < 0)
        {
          v12 = __si_assert_copy_extra_521(-1);
          v13 = v12;
          v14 = "";
          if (v12)
            v14 = v12;
          __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 96, "bitIndex >= 0", v14);
          free(v13);
          if (__valid_fs(-1))
            v15 = 2989;
          else
            v15 = 3072;
          *(_DWORD *)v15 = -559038737;
          abort();
        }
        v10 = v9;
        if (a1[1] <= v9)
          return 0;
        v11 = (const __CFBitVector *)a1[3];
      }
      if (CFBitVectorGetBitAtIndex(v11, v10))
        return 1;
    }
  }
  return 0;
}

uint64_t setUpOverlay(uint64_t result, const void *a2)
{
  uint64_t *v3;
  unsigned int *v4;
  unsigned int v5;
  unsigned int v6;
  char *v7;
  pthread_rwlockattr_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)(result + 6624))
  {
    v3 = (uint64_t *)result;
    v4 = (unsigned int *)(result + 1452);
    do
      v5 = __ldaxr(v4);
    while (__stlxr(v5 + 1, v4));
    si_scheduler_suspend(*(_QWORD *)(result + 872));
    do
      v6 = __ldaxr(v4);
    while (__stlxr(v6 - 1, v4));
    si_scheduler_suspend(v3[108]);
    v7 = (char *)malloc_type_calloc(1uLL, 0x1D8uLL, 0x103004099AB8BE7uLL);
    atomic_store(1u, (unsigned int *)v7);
    *((_QWORD *)v7 + 26) = 2;
    memset(&v8, 0, sizeof(v8));
    pthread_rwlockattr_init(&v8);
    pthread_rwlock_init((pthread_rwlock_t *)(v7 + 240), &v8);
    pthread_rwlock_init((pthread_rwlock_t *)(v7 + 8), &v8);
    pthread_rwlockattr_destroy(&v8);
    v3[829] = (uint64_t)v7;
    v3[830] = (uint64_t)CFRetain(a2);
    si_scheduler_resume(v3[109], (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 7935);
    return si_scheduler_resume(v3[108], (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 7936);
  }
  return result;
}

uint64_t SetupRemapping(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  int v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  __int128 *v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  NSObject *v21;
  os_log_type_t v22;
  int v23;
  uint64_t v24;
  unsigned int v25;
  int v26;
  unsigned int v27;
  uint8_t buf[16];
  _BYTE v29[28];
  char __str[1024];
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v25 = 0;
  result = fd_setDir(*(unsigned int *)(a1 + 32), (int *)&v25);
  if ((_DWORD)result)
  {
    bzero(__str, 0x400uLL);
    v5 = 51;
    while (1)
    {
      v6 = *(_QWORD *)(a1 + 2384);
      *(_QWORD *)(a2 + 40) = v6;
      *(_QWORD *)(a1 + 2384) = v6 + 1;
      snprintf(__str, 0x400uLL, "remapping%ld", v6);
      v7 = (char *)fd_create_protected(*(_DWORD *)(a1 + 32), __str, 536873474, 3u);
      v24 = 0;
      v8 = _fd_acquire_fd((uint64_t)v7, &v24);
      if ((_DWORD)v8 != -1)
        break;
      fd_release(v7);
      if (!--v5)
      {
        v9 = *__error();
        v10 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)v29 = 136315650;
          *(_QWORD *)&v29[4] = "SetupRemapping";
          *(_WORD *)&v29[12] = 1024;
          *(_DWORD *)&v29[14] = 6513;
          *(_WORD *)&v29[18] = 2080;
          *(_QWORD *)&v29[20] = __str;
          _os_log_error_impl(&dword_1B8270000, v10, OS_LOG_TYPE_ERROR, "%s:%d: open remp failed: %s", v29, 0x1Cu);
        }
        *__error() = v9;
        goto LABEL_16;
      }
    }
    v11 = v8;
    v12 = **(_QWORD **)(a2 + 16);
    v26 = 268435454;
    v27 = v12;
    prot_pwrite_guarded(v8, (uint64_t)&v24, (uint64_t)&v26, 4uLL, 0);
    prot_pwrite_guarded(v11, (uint64_t)&v24, a2 + 32, 8uLL, 4);
    prot_pwrite_guarded(v11, (uint64_t)&v24, (uint64_t)&v27, 4uLL, 12);
    if (v27)
    {
      v13 = 0;
      v14 = 0;
      v15 = 16;
      do
      {
        v16 = (__int128 *)(*(_QWORD *)(*(_QWORD *)(a2 + 16) + 8) + v13);
        v17 = *v16;
        *(_QWORD *)&v29[16] = *((_QWORD *)v16 + 2);
        *(_OWORD *)v29 = v17;
        prot_pwrite_guarded(v11, (uint64_t)&v24, (uint64_t)v29, 8uLL, v15);
        prot_pwrite_guarded(v11, (uint64_t)&v24, (uint64_t)&v29[8], 4uLL, v15 + 8);
        v18 = v15 + 12;
        v19 = prot_pwrite_guarded(v11, (uint64_t)&v24, *(uint64_t *)&v29[16], 4 * *(unsigned int *)&v29[8], v18);
        if (v19 != 4 * *(unsigned int *)&v29[8])
        {
          v20 = *__error();
          v21 = _SILogForLogForCategory(0);
          v22 = gSILogLevels[0] < 3;
          if (os_log_type_enabled(v21, (os_log_type_t)(gSILogLevels[0] < 3)))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_1B8270000, v21, v22, "*warn* Failed writing remapping data. Will cause index corruption if remapping fails.", buf, 2u);
          }
          *__error() = v20;
          v19 = 4 * *(unsigned int *)&v29[8];
        }
        v15 = v19 + v18;
        ++v14;
        v13 += 24;
      }
      while (v14 < v27);
    }
    _fd_release_fd(v7, v11, 0, v24);
    fd_release(v7);
LABEL_16:
    v23 = v25;
    result = MEMORY[0x1BCCB1484](v25);
    if ((v23 & 0x80000000) == 0)
      return close(v23);
  }
  return result;
}

void si_freeIndex0(uint64_t *a1, int a2)
{
  uint64_t v3;
  qos_class_t v4;

  if (a2)
  {
    freeIndex(*a1);
  }
  else
  {
    v3 = *(_QWORD *)(a1[1] + 1096);
    v4 = qos_class_self();
    si_enqueue_work_with_qos(v3, v4, (uint64_t)si_freeIndex, *a1);
  }
  free(a1);
}

void mergeOverlay(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int *v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  NSObject *v13;
  NSObject *v14;
  NSObject *v15;
  NSObject *v16;
  _QWORD block[9];
  _QWORD v18[8];

  v2 = a1[829];
  if (v2)
  {
    v5 = a1 + 829;
    v6 = a1[830];
    v7 = a1[173];
    v8 = a1[174];
    v9 = (unsigned int *)a1 + 363;
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 + 1, v9));
    si_scheduler_suspend(a1[109]);
    do
      v11 = __ldaxr(v9);
    while (__stlxr(v11 - 1, v9));
    v12 = MEMORY[0x1E0C809B0];
    v18[0] = MEMORY[0x1E0C809B0];
    v18[1] = 0x40000000;
    v18[2] = __mergeOverlay_block_invoke;
    v18[3] = &__block_descriptor_tmp_184;
    v18[4] = a2;
    v18[5] = v8;
    v18[6] = v6;
    v18[7] = v7;
    directoryOverlayProcessPaths(v2, (uint64_t)v18);
    si_scheduler_suspend(a1[108]);
    *v5 = 0;
    v5[1] = 0;
    si_scheduler_resume(a1[109], (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 7978);
    si_scheduler_resume(a1[108], (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 7979);
    v13 = *(NSObject **)(a1[108] + 136);
    v14 = *(NSObject **)(a1[116] + 136);
    v15 = *(NSObject **)(a1[117] + 136);
    v16 = *(NSObject **)(a1[110] + 136);
    dispatch_retain(v14);
    dispatch_retain(v13);
    dispatch_retain(v16);
    block[0] = v12;
    block[1] = 0x40000000;
    block[2] = __mergeOverlay_block_invoke_2;
    block[3] = &__block_descriptor_tmp_189;
    block[4] = v14;
    block[5] = v16;
    block[6] = v13;
    block[7] = v2;
    block[8] = v6;
    dispatch_barrier_async(v15, block);
  }
}

void si_remapForIndex(uint64_t a1, int a2)
{
  uint64_t v3;
  void *v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  void *v9;
  uint64_t v10;
  int *v11;
  int updated;
  int v13;
  int v14;
  NSObject *v15;
  uint64_t v16;
  int v17;
  NSObject *v18;
  os_log_type_t v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  int v24;
  NSObject *v25;
  int v26;
  char *v27;
  char *v28;
  const char *v29;
  _QWORD v30[2];
  void *v31;
  unint64_t v32;
  unsigned int v33;
  uint8_t buf[4];
  const char *v35;
  __int16 v36;
  int v37;
  __int16 v38;
  int v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  if (!a2)
  {
    v3 = *(_QWORD *)a1;
    v4 = (void *)os_transaction_create();
    v33 = 0;
    if (fd_setDir(*(unsigned int *)(v3 + 32), (int *)&v33))
    {
      v32 = 0;
      while (1)
      {
        v5 = ContentIndexRemappingNextDocId(*(_QWORD **)(a1 + 16), &v32);
        if (!v5)
          break;
        v6 = v5;
        si_suspend_if_bad_time(v3);
        v7 = v32;
        if (v6 == v32)
        {
          *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24) = v6 + 1;
        }
        else
        {
          v8 = _CIGetOIDForDocId(*(_QWORD *)(a1 + 8), v6, 0);
          v31 = 0;
          if (**(_DWORD **)(v3 + 6592))
          {
            v17 = *__error();
            v18 = _SILogForLogForCategory(0);
            v19 = 2 * (gSILogLevels[0] < 4);
            if (os_log_type_enabled(v18, v19))
            {
              *(_WORD *)buf = 0;
              _os_log_impl(&dword_1B8270000, v18, v19, "remapping canceled", buf, 2u);
            }
            *__error() = v17;
            goto LABEL_31;
          }
          if (db_get_obj(*(_DWORD **)(v3 + 1184), v8, &v31, 0))
          {
            *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24) = v7 + 1;
          }
          else
          {
            v9 = v31;
            if (*((_QWORD *)v31 + 4) == v7)
            {
              v10 = *(_QWORD *)(a1 + 16);
              v30[0] = v7 + 1;
              v30[1] = v10;
              *((_QWORD *)v31 + 4) = v6;
              v11 = *(int **)(v3 + 1184);
              if (*v11 != 1685287992)
              {
                v24 = *__error();
                v25 = _SILogForLogForCategory(4);
                if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
                {
                  v26 = *v11;
                  *(_DWORD *)buf = 136315650;
                  v35 = "db_update_obj_callback";
                  v36 = 1024;
                  v37 = 323;
                  v38 = 1024;
                  v39 = v26;
                  _os_log_error_impl(&dword_1B8270000, v25, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
                }
                *__error() = v24;
                v27 = __si_assert_copy_extra_268();
                v28 = v27;
                if (v27)
                  v29 = v27;
                else
                  v29 = "";
                __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 323, v29);
                free(v28);
                MEMORY[0xBAD] = -559038737;
                abort();
              }
              updated = db2_update_obj_callback(*(_QWORD *)(v3 + 1184), (uint64_t)v9, 0, (void (*)(uint64_t, uint64_t, uint64_t))remap_update_callback, (uint64_t)v30);
              if (updated && dword_1EF19FCA8 >= 5)
              {
                v13 = updated;
                v14 = *__error();
                v15 = _SILogForLogForCategory(7);
                if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 67109120;
                  LODWORD(v35) = v13;
                  _os_log_impl(&dword_1B8270000, v15, OS_LOG_TYPE_DEFAULT, "Updating item for remap failed with error %d", buf, 8u);
                }
                *__error() = v14;
              }
              v9 = v31;
            }
            else
            {
              *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24) = v7 + 1;
            }
            free(v9);
          }
        }
      }
      if (!**(_DWORD **)(v3 + 6592))
      {
        db_perform_callback(*(_QWORD *)(v3 + 1184), (void (*)(uint64_t))si_removeRemapping, a1);
        v16 = db_shrink_cache(*(_QWORD *)(v3 + 1184));
        if ((_DWORD)v16)
        {
          si_makeUnavailable(v3, v16, 0, 3, (uint64_t)"Failure in db_shrink_cache at si_remapForIndex");
        }
        else
        {
          si_sync_ctx_create_with_defer_fd(v3, 0);
          v21 = (uint64_t)v20;
          v20[96] = 1;
          if (!*(_BYTE *)(*(_QWORD *)a1 + 2072))
            attachJournal(v20);
          *(_QWORD *)(v21 + 40) = si_os_release_routine;
          os_retain(v4);
          *(_QWORD *)(v21 + 48) = v4;
          v22 = *(_QWORD *)a1;
          if (*(_BYTE *)(*(_QWORD *)a1 + 2072))
          {
            flushGraphCache();
            v22 = *(_QWORD *)a1;
          }
          si_enqueue_work(*(_QWORD *)(v22 + 1040), (uint64_t)syncIndex, v21);
        }
      }
LABEL_31:
      v23 = v33;
      MEMORY[0x1BCCB1484](v33);
      if ((v23 & 0x80000000) == 0)
        close(v23);
    }
    os_release(v4);
  }
  CFRelease(*(CFTypeRef *)(a1 + 16));
  free((void *)a1);
}

uint64_t si_removeRemapping(const void **a1)
{
  __CFArray *Mutable;
  const __CFArray *v3;
  CFIndex FirstIndexOfValue;
  CFRange v6;

  pthread_mutex_lock(&schlock);
  Mutable = (__CFArray *)*((_QWORD *)*a1 + 297);
  if (!Mutable)
  {
    Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
    *((_QWORD *)*a1 + 297) = Mutable;
  }
  CFArrayAppendValue(Mutable, a1[2]);
  pthread_mutex_unlock(&schlock);
  v3 = (const __CFArray *)*((_QWORD *)*a1 + 296);
  v6.length = CFArrayGetCount(v3);
  v6.location = 0;
  FirstIndexOfValue = CFArrayGetFirstIndexOfValue(v3, v6, a1[2]);
  if (FirstIndexOfValue == -1)
    return 0xFFFFFFFFLL;
  CFArrayRemoveValueAtIndex(*((CFMutableArrayRef *)*a1 + 296), FirstIndexOfValue);
  return 0;
}

void flushGraphCacheApply(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v82;
  uint64_t v83;

  if (*a3)
    v83 = MEMORY[0x1BCCAF3F0](*a3, a1);
  else
    v83 = 0;
  v5 = a3[1];
  if (v5)
    v82 = MEMORY[0x1BCCAF3F0](v5, a1);
  else
    v82 = 0;
  v6 = a3[2];
  if (v6)
    v80 = MEMORY[0x1BCCAF3F0](v6, a1);
  else
    v80 = 0;
  v7 = a3[3];
  if (v7)
    v79 = MEMORY[0x1BCCAF3F0](v7, a1);
  else
    v79 = 0;
  v8 = a3[4];
  if (v8)
    v78 = MEMORY[0x1BCCAF3F0](v8, a1);
  else
    v78 = 0;
  v9 = a3[5];
  if (v9)
    v77 = MEMORY[0x1BCCAF3F0](v9, a1);
  else
    v77 = 0;
  v10 = a3[6];
  if (v10)
    v76 = MEMORY[0x1BCCAF3F0](v10, a1);
  else
    v76 = 0;
  v11 = a3[7];
  if (v11)
    v75 = MEMORY[0x1BCCAF3F0](v11, a1);
  else
    v75 = 0;
  v12 = a3[8];
  if (v12)
    v74 = MEMORY[0x1BCCAF3F0](v12, a1);
  else
    v74 = 0;
  v13 = a3[9];
  if (v13)
    v73 = MEMORY[0x1BCCAF3F0](v13, a1);
  else
    v73 = 0;
  v14 = a3[10];
  if (v14)
    v72 = MEMORY[0x1BCCAF3F0](v14, a1);
  else
    v72 = 0;
  v15 = a3[11];
  if (v15)
    v71 = MEMORY[0x1BCCAF3F0](v15, a1);
  else
    v71 = 0;
  v16 = a3[12];
  if (v16)
    v70 = MEMORY[0x1BCCAF3F0](v16, a1);
  else
    v70 = 0;
  v17 = a3[13];
  if (v17)
    v69 = MEMORY[0x1BCCAF3F0](v17, a1);
  else
    v69 = 0;
  v18 = a3[14];
  if (v18)
    v68 = MEMORY[0x1BCCAF3F0](v18, a1);
  else
    v68 = 0;
  v19 = a3[15];
  if (v19)
    v67 = MEMORY[0x1BCCAF3F0](v19, a1);
  else
    v67 = 0;
  v20 = a3[16];
  if (v20)
    v66 = MEMORY[0x1BCCAF3F0](v20, a1);
  else
    v66 = 0;
  v21 = a3[17];
  if (v21)
    v65 = MEMORY[0x1BCCAF3F0](v21, a1);
  else
    v65 = 0;
  v22 = a3[18];
  if (v22)
    v64 = MEMORY[0x1BCCAF3F0](v22, a1);
  else
    v64 = 0;
  v23 = a3[19];
  if (v23)
    v63 = MEMORY[0x1BCCAF3F0](v23, a1);
  else
    v63 = 0;
  v24 = a3[20];
  if (v24)
    v62 = MEMORY[0x1BCCAF3F0](v24, a1);
  else
    v62 = 0;
  v25 = a3[21];
  if (v25)
    v61 = MEMORY[0x1BCCAF3F0](v25, a1);
  else
    v61 = 0;
  v26 = a3[22];
  if (v26)
    v60 = MEMORY[0x1BCCAF3F0](v26, a1);
  else
    v60 = 0;
  v27 = a3[23];
  if (v27)
    v59 = MEMORY[0x1BCCAF3F0](v27, a1);
  else
    v59 = 0;
  v28 = a3[24];
  if (v28)
    v58 = MEMORY[0x1BCCAF3F0](v28, a1);
  else
    v58 = 0;
  v29 = a3[25];
  if (v29)
    v57 = MEMORY[0x1BCCAF3F0](v29, a1);
  else
    v57 = 0;
  v30 = a3[26];
  if (v30)
    v56 = MEMORY[0x1BCCAF3F0](v30, a1);
  else
    v56 = 0;
  v31 = a3[27];
  if (v31)
    v55 = MEMORY[0x1BCCAF3F0](v31, a1);
  else
    v55 = 0;
  v32 = a3[28];
  if (v32)
    v54 = MEMORY[0x1BCCAF3F0](v32, a1);
  else
    v54 = 0;
  v33 = a3[29];
  if (v33)
    v53 = MEMORY[0x1BCCAF3F0](v33, a1);
  else
    v53 = 0;
  v34 = a3[30];
  if (v34)
    v52 = MEMORY[0x1BCCAF3F0](v34, a1);
  else
    v52 = 0;
  v35 = a3[31];
  if (v35)
    v36 = MEMORY[0x1BCCAF3F0](v35, a1);
  else
    v36 = 0;
  v37 = a3[32];
  if (v37)
    v38 = MEMORY[0x1BCCAF3F0](v37, a1);
  else
    v38 = 0;
  v39 = a3[33];
  if (v39)
    v40 = MEMORY[0x1BCCAF3F0](v39, a1);
  else
    v40 = 0;
  v41 = a3[34];
  if (v41)
    v42 = MEMORY[0x1BCCAF3F0](v41, a1);
  else
    v42 = 0;
  v43 = a3[35];
  if (v43)
    v44 = MEMORY[0x1BCCAF3F0](v43, a1);
  else
    v44 = 0;
  v45 = a3[36];
  if (v45)
    v46 = MEMORY[0x1BCCAF3F0](v45, a1);
  else
    v46 = 0;
  v47 = a3[37];
  if (v47)
    v48 = MEMORY[0x1BCCAF3F0](v47, a1);
  else
    v48 = 0;
  v49 = a3[38];
  if (v49)
    v50 = MEMORY[0x1BCCAF3F0](v49, a1);
  else
    v50 = 0;
  v51 = a3[39];
  if (v51)
    v51 = MEMORY[0x1BCCAF3F0](v51, a1);
  si_updateContactInfo(a3[40], a1, v83, v82, v80, v79, v78, v77, v76, v75, v74, v73, v72, v71, v70, v69, v68, v67, v66,
    v65,
    v64,
    v63,
    v62,
    v61,
    v60,
    v59,
    v58,
    v57,
    v56,
    v55,
    v54,
    v53,
    v52,
    v36,
    v38,
    v40,
    v42,
    v44,
    v46,
    v48,
    v50,
    v51,
    a2);
}

void indexContactGraphData(uint64_t a1, int a2)
{
  CFDictionaryRef v3;
  int v4;
  NSObject *v5;
  os_log_type_t v6;
  CFIndex Count;
  const __CFAllocator *v8;
  const void *Mutable;
  const UInt8 *Bytes;
  CFIndex Length;
  const __CFData *v12;
  int v13;
  NSObject *v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  int v25;
  NSObject *v26;
  uint8_t v27[4];
  const char *v28;
  __int16 v29;
  int v30;
  uint8_t buf[320];
  const void *v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v3 = *(CFDictionaryRef *)a1;
  if (v3)
  {
    if (a2)
      goto LABEL_10;
    v4 = *__error();
    v5 = _SILogForLogForCategory(4);
    v6 = 2 * (dword_1EF19FC9C < 4);
    if (os_log_type_enabled(v5, v6))
    {
      Count = CFDictionaryGetCount(*(CFDictionaryRef *)a1);
      *(_DWORD *)buf = 134217984;
      *(_QWORD *)&buf[4] = Count;
      _os_log_impl(&dword_1B8270000, v5, v6, "Index contact graph data; %ld items", buf, 0xCu);
    }
    *__error() = v4;
    memcpy(buf, (const void *)(a1 + 8), sizeof(buf));
    v8 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    Mutable = (const void *)_MDPlistContainerCreateMutable();
    v32 = Mutable;
    _MDPlistContainerBeginContainer();
    _MDPlistContainerBeginArray();
    CFDictionaryApplyFunction(*(CFDictionaryRef *)a1, (CFDictionaryApplierFunction)flushGraphCacheApply2, buf);
    _MDPlistContainerAddNullValue();
    _MDPlistContainerEndArray();
    _MDPlistContainerEndContainer();
    Bytes = (const UInt8 *)_MDPlistContainerGetBytes();
    Length = _MDPlistContainerGetLength();
    v12 = CFDataCreateWithBytesNoCopy(v8, Bytes, Length, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
    if (!SISetCodedAttributes(*(_QWORD *)(a1 + 328), CFSTR("com.apple.MobileAddressBook"), 0, 0, v12, 0, 0, 0, 9, 0, 0))
    {
      v13 = *__error();
      v14 = _SILogForLogForCategory(4);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v27 = 136315394;
        v28 = "indexContactGraphData";
        v29 = 1024;
        v30 = 25455;
        _os_log_error_impl(&dword_1B8270000, v14, OS_LOG_TYPE_ERROR, "%s:%d: SISetCodedAttributes failed in indexContactGraphData", v27, 0x12u);
      }
      *__error() = v13;
    }
    CFRelease(v12);
    CFRelease(Mutable);
    v3 = *(CFDictionaryRef *)a1;
    if (*(_QWORD *)a1)
LABEL_10:
      CFRelease(v3);
    *(_QWORD *)a1 = 0;
    v15 = *(_OWORD *)(a1 + 24);
    *(_OWORD *)buf = *(_OWORD *)(a1 + 8);
    *(_OWORD *)&buf[16] = v15;
    v16 = *(_OWORD *)(a1 + 56);
    *(_OWORD *)&buf[32] = *(_OWORD *)(a1 + 40);
    *(_OWORD *)&buf[48] = v16;
    releaseCommDates((uint64_t)buf);
    v17 = *(_OWORD *)(a1 + 88);
    *(_OWORD *)buf = *(_OWORD *)(a1 + 72);
    *(_OWORD *)&buf[16] = v17;
    v18 = *(_OWORD *)(a1 + 120);
    *(_OWORD *)&buf[32] = *(_OWORD *)(a1 + 104);
    *(_OWORD *)&buf[48] = v18;
    releaseCommDates((uint64_t)buf);
    v19 = *(_OWORD *)(a1 + 152);
    *(_OWORD *)buf = *(_OWORD *)(a1 + 136);
    *(_OWORD *)&buf[16] = v19;
    v20 = *(_OWORD *)(a1 + 184);
    *(_OWORD *)&buf[32] = *(_OWORD *)(a1 + 168);
    *(_OWORD *)&buf[48] = v20;
    releaseCommDates((uint64_t)buf);
    v21 = *(_OWORD *)(a1 + 216);
    *(_OWORD *)buf = *(_OWORD *)(a1 + 200);
    *(_OWORD *)&buf[16] = v21;
    v22 = *(_OWORD *)(a1 + 248);
    *(_OWORD *)&buf[32] = *(_OWORD *)(a1 + 232);
    *(_OWORD *)&buf[48] = v22;
    releaseCommDates((uint64_t)buf);
    v23 = *(_OWORD *)(a1 + 280);
    *(_OWORD *)buf = *(_OWORD *)(a1 + 264);
    *(_OWORD *)&buf[16] = v23;
    v24 = *(_OWORD *)(a1 + 312);
    *(_OWORD *)&buf[32] = *(_OWORD *)(a1 + 296);
    *(_OWORD *)&buf[48] = v24;
    releaseCommDates((uint64_t)buf);
    free((void *)a1);
  }
  else
  {
    v25 = *__error();
    v26 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "indexContactGraphData";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 25431;
      _os_log_error_impl(&dword_1B8270000, v26, OS_LOG_TYPE_ERROR, "%s:%d: ~~~ No ctx->usedDates.", buf, 0x12u);
    }
    *__error() = v25;
  }
}

uint64_t flushGraphCacheApply2(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  _QWORD v85[4];
  _QWORD v86[4];
  _QWORD v87[4];
  _QWORD v88[4];
  _QWORD v89[4];
  _QWORD v90[4];
  _QWORD v91[4];
  _QWORD v92[4];
  _QWORD v93[4];
  _QWORD v94[6];

  v94[4] = *MEMORY[0x1E0C80C00];
  if (*a3)
    v83 = MEMORY[0x1BCCAF3F0](*a3, a1);
  else
    v83 = 0;
  v5 = a3[1];
  if (v5)
    v82 = MEMORY[0x1BCCAF3F0](v5, a1);
  else
    v82 = 0;
  v6 = a3[2];
  if (v6)
    v81 = MEMORY[0x1BCCAF3F0](v6, a1);
  else
    v81 = 0;
  v7 = a3[3];
  if (v7)
    v80 = MEMORY[0x1BCCAF3F0](v7, a1);
  else
    v80 = 0;
  v8 = a3[4];
  if (v8)
    v79 = MEMORY[0x1BCCAF3F0](v8, a1);
  else
    v79 = 0;
  v9 = a3[5];
  if (v9)
    v78 = MEMORY[0x1BCCAF3F0](v9, a1);
  else
    v78 = 0;
  v10 = a3[6];
  if (v10)
    v77 = MEMORY[0x1BCCAF3F0](v10, a1);
  else
    v77 = 0;
  v11 = a3[7];
  if (v11)
    v76 = MEMORY[0x1BCCAF3F0](v11, a1);
  else
    v76 = 0;
  v12 = a3[8];
  if (v12)
    v75 = MEMORY[0x1BCCAF3F0](v12, a1);
  else
    v75 = 0;
  v13 = a3[9];
  if (v13)
    v74 = MEMORY[0x1BCCAF3F0](v13, a1);
  else
    v74 = 0;
  v14 = a3[10];
  if (v14)
    v73 = MEMORY[0x1BCCAF3F0](v14, a1);
  else
    v73 = 0;
  v15 = a3[11];
  if (v15)
    v72 = MEMORY[0x1BCCAF3F0](v15, a1);
  else
    v72 = 0;
  v16 = a3[12];
  if (v16)
    v71 = MEMORY[0x1BCCAF3F0](v16, a1);
  else
    v71 = 0;
  v17 = a3[13];
  if (v17)
    v70 = MEMORY[0x1BCCAF3F0](v17, a1);
  else
    v70 = 0;
  v18 = a3[14];
  if (v18)
    v69 = MEMORY[0x1BCCAF3F0](v18, a1);
  else
    v69 = 0;
  v19 = a3[15];
  if (v19)
    v68 = MEMORY[0x1BCCAF3F0](v19, a1);
  else
    v68 = 0;
  v20 = a3[16];
  if (v20)
    v67 = MEMORY[0x1BCCAF3F0](v20, a1);
  else
    v67 = 0;
  v21 = a3[17];
  if (v21)
    v66 = MEMORY[0x1BCCAF3F0](v21, a1);
  else
    v66 = 0;
  v22 = a3[18];
  if (v22)
    v65 = MEMORY[0x1BCCAF3F0](v22, a1);
  else
    v65 = 0;
  v23 = a3[19];
  if (v23)
    v64 = MEMORY[0x1BCCAF3F0](v23, a1);
  else
    v64 = 0;
  v24 = a3[20];
  if (v24)
    v63 = MEMORY[0x1BCCAF3F0](v24, a1);
  else
    v63 = 0;
  v25 = a3[21];
  if (v25)
    v62 = MEMORY[0x1BCCAF3F0](v25, a1);
  else
    v62 = 0;
  v26 = a3[22];
  if (v26)
    v61 = MEMORY[0x1BCCAF3F0](v26, a1);
  else
    v61 = 0;
  v27 = a3[23];
  if (v27)
    v60 = MEMORY[0x1BCCAF3F0](v27, a1);
  else
    v60 = 0;
  v28 = a3[24];
  if (v28)
    v59 = MEMORY[0x1BCCAF3F0](v28, a1);
  else
    v59 = 0;
  v29 = a3[25];
  if (v29)
    v58 = MEMORY[0x1BCCAF3F0](v29, a1);
  else
    v58 = 0;
  v30 = a3[26];
  if (v30)
    v57 = MEMORY[0x1BCCAF3F0](v30, a1);
  else
    v57 = 0;
  v31 = a3[27];
  if (v31)
    v56 = MEMORY[0x1BCCAF3F0](v31, a1);
  else
    v56 = 0;
  v32 = a3[28];
  if (v32)
    v55 = MEMORY[0x1BCCAF3F0](v32, a1);
  else
    v55 = 0;
  v33 = a3[29];
  if (v33)
    v54 = MEMORY[0x1BCCAF3F0](v33, a1);
  else
    v54 = 0;
  v34 = a3[30];
  if (v34)
    v53 = MEMORY[0x1BCCAF3F0](v34, a1);
  else
    v53 = 0;
  v35 = a3[31];
  if (v35)
    v36 = MEMORY[0x1BCCAF3F0](v35, a1);
  else
    v36 = 0;
  v37 = a3[32];
  if (v37)
    v38 = MEMORY[0x1BCCAF3F0](v37, a1);
  else
    v38 = 0;
  v39 = a3[33];
  if (v39)
    v40 = MEMORY[0x1BCCAF3F0](v39, a1);
  else
    v40 = 0;
  v41 = a3[34];
  if (v41)
    v42 = MEMORY[0x1BCCAF3F0](v41, a1);
  else
    v42 = 0;
  v43 = a3[35];
  if (v43)
    v44 = MEMORY[0x1BCCAF3F0](v43, a1);
  else
    v44 = 0;
  v45 = a3[36];
  if (v45)
    v46 = MEMORY[0x1BCCAF3F0](v45, a1);
  else
    v46 = 0;
  v47 = a3[37];
  if (v47)
    v48 = MEMORY[0x1BCCAF3F0](v47, a1);
  else
    v48 = 0;
  v49 = a3[38];
  if (v49)
    v50 = MEMORY[0x1BCCAF3F0](v49, a1);
  else
    v50 = 0;
  v51 = a3[39];
  if (v51)
    v51 = MEMORY[0x1BCCAF3F0](v51, a1);
  v94[0] = v83;
  v94[1] = v82;
  v94[2] = v81;
  v94[3] = v80;
  v93[0] = v79;
  v93[1] = v78;
  v93[2] = v77;
  v93[3] = v76;
  v92[0] = v75;
  v92[1] = v74;
  v92[2] = v73;
  v92[3] = v72;
  v91[0] = v71;
  v91[1] = v70;
  v91[2] = v69;
  v91[3] = v68;
  v90[0] = v67;
  v90[1] = v66;
  v90[2] = v65;
  v90[3] = v64;
  v89[0] = v63;
  v89[1] = v62;
  v89[2] = v61;
  v89[3] = v60;
  v88[0] = v59;
  v88[1] = v58;
  v88[2] = v57;
  v88[3] = v56;
  v87[0] = v55;
  v87[1] = v54;
  v87[2] = v53;
  v87[3] = v36;
  v86[0] = v38;
  v86[1] = v40;
  v86[2] = v42;
  v86[3] = v44;
  v85[0] = v46;
  v85[1] = v48;
  v85[2] = v50;
  v85[3] = v51;
  _MDPlistContainerBeginArray();
  _MDPlistContainerAddNullValue();
  _MDPlistContainerAddInt32Value();
  addContactInfoToContainer(a3[40], a1, a2, (uint64_t)v94, (uint64_t)v93, (uint64_t)v92, (uint64_t)v91, (uint64_t)v90, (uint64_t)v89, (uint64_t)v88, (uint64_t)v87, (uint64_t)v86, (uint64_t)v85);
  return _MDPlistContainerEndArray();
}

const void *si_get_clientstates_dict(uint64_t a1, const void *a2)
{
  __CFDictionary *Value;
  const void *Mutable;
  const __CFAllocator *v6;
  const CFDictionaryKeyCallBacks *v7;
  const CFDictionaryValueCallBacks *v8;

  Value = (__CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 72), CFSTR("clientStates"));
  if (Value)
    goto LABEL_2;
  v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v7 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
  v8 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
  Value = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  Mutable = CFDictionaryCreateMutable(v6, 1, v7, v8);
  CFDictionarySetValue(Value, a2, Mutable);
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 72), CFSTR("clientStates"), Value);
  CFRelease(Mutable);
  CFRelease(Value);
  if (!Mutable)
  {
LABEL_2:
    Mutable = CFDictionaryGetValue(Value, a2);
    if (!Mutable)
    {
      Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      CFDictionarySetValue(Value, a2, Mutable);
      CFRelease(Mutable);
    }
  }
  return Mutable;
}

void playBackMobileJournal(uint64_t *a1, int a2)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  size_t v8;
  void *v9;
  BOOL v10;
  char v11;
  unsigned int v12;
  int v13;
  unint64_t v14;
  unsigned int v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  void (*v20)(_QWORD);
  _DWORD *v21;
  int v22;
  NSObject *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  __n128 v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unsigned int v39;
  unint64_t v40;
  int v41;
  char v42;
  int64_t VInt64;
  int64_t v44;
  char v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  uint64_t v49;
  int v50;
  unint64_t v51;
  uint64_t v52;
  const char *v53;
  size_t v54;
  CFStringRef v55;
  unint64_t v56;
  unint64_t v57;
  unint64_t v58;
  uint64_t v59;
  char v60;
  const void *v61;
  uint64_t v62;
  int v63;
  NSObject *v64;
  BOOL v65;
  BOOL v66;
  unsigned int v67;
  uint64_t v68;
  uint64_t (*v69)();
  uint64_t v70;
  int64_t v71;
  char v72;
  uint64_t v73;
  uint64_t v74;
  size_t v75;
  uint64_t v76;
  const char *v77;
  size_t v78;
  size_t v79;
  CFStringRef v80;
  CFStringRef v81;
  BOOL v82;
  BOOL v83;
  unsigned int v84;
  uint64_t v85;
  uint64_t (*v86)();
  int64_t v87;
  uint64_t v88;
  unint64_t v89;
  uint64_t v90;
  uint64_t v91;
  int v92;
  NSObject *v93;
  int v94;
  NSObject *v95;
  CFStringRef v96;
  BOOL v97;
  char v98;
  int v99;
  NSObject *v100;
  unint64_t v101;
  uint64_t v102;
  uint64_t v103;
  _QWORD *v104;
  unsigned int v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  unint64_t v109;
  uint64_t tv_sec;
  int v111;
  NSObject *v112;
  uint64_t v113;
  int v114;
  NSObject *v115;
  int v116;
  NSObject *v117;
  NSObject *v118;
  uint64_t v119;
  uint64_t v120;
  __n128 v121;
  uint64_t v122;
  uint64_t v123;
  unsigned int v124;
  uint64_t v125;
  void (*v126)(_QWORD);
  unsigned int *v127;
  unsigned int v128;
  unsigned int v129;
  int v130;
  NSObject *v131;
  unsigned int v132;
  unsigned int v133;
  uint64_t v134;
  int v135;
  NSObject *v136;
  size_t v138;
  unint64_t v139;
  unint64_t v140;
  uint64_t v141;
  const __CFAllocator *alloc;
  uint64_t v143;
  int64_t v144;
  uint64_t v145;
  int64_t v146;
  int64_t v147;
  unint64_t v148;
  uint64_t v149;
  char v150;
  int v151;
  int v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t *v155;
  timespec v156;
  uint64_t v157;
  unsigned __int128 v158;
  uint64_t v159;
  unint64_t v160;
  unint64_t v161;
  unint64_t v162;
  unint64_t v163;
  unint64_t v164;
  _BYTE buf[38];
  __int16 v166;
  unint64_t v167;
  __int16 v168;
  uint64_t v169;
  __int16 v170;
  size_t v171;
  __int16 v172;
  uint64_t v173;
  uint64_t v174;

  v2 = a1;
  v174 = *MEMORY[0x1E0C80C00];
  v3 = a1[1];
  if (a2)
    goto LABEL_185;
  v4 = *a1;
  v5 = *a1;
  v6 = fd_lseek(*(_DWORD **)(v3 + 8), 0, 2);
  v7 = v6;
  v148 = v6;
  if (v6)
  {
    v8 = *(_QWORD *)(v3 + 24);
    if (v8)
    {
      v9 = *(void **)(v3 + 16);
      if (v9 != (void *)-1)
      {
        v10 = v8 == v148 && *(_QWORD *)(v3 + 32) == 0;
        if (v10)
        {
          v11 = 1;
          goto LABEL_14;
        }
        munmap(v9, v8);
      }
      *(_QWORD *)(v3 + 24) = v7;
      *(_QWORD *)(v3 + 32) = 0;
      v11 = 1;
      *(_QWORD *)(v3 + 16) = fd_mmap(*(_QWORD *)(v3 + 8));
    }
    else
    {
      v11 = 0;
      *(_QWORD *)(v3 + 24) = v6;
      *(_QWORD *)(v3 + 32) = 0;
    }
  }
  else
  {
    v11 = 0;
  }
LABEL_14:
  v149 = v7;
  v150 = v11;
  v144 = *(_QWORD *)(v5 + 2136);
  do
  {
    v12 = __ldxr(exceptionSequenceNum);
    v13 = v12 + 1;
  }
  while (__stxr(v12 + 1, exceptionSequenceNum));
  v14 = setThreadIdAndInfo(-1, (__int128 *)sJournalExceptionCallbacks, (uint64_t)v2, 0x40000000, v13);
  v164 = __PAIR64__(v14, HIDWORD(v14));
  v163 = __PAIR64__(v15, v16);
  v17 = *(_QWORD *)&threadData[18 * v14 + 2];
  v18 = v17 + 320 * HIDWORD(v14);
  *(_BYTE *)(v18 + 216) = 0;
  v19 = *(_DWORD *)(v18 + 312);
  v20 = *(void (**)(_QWORD))(v18 + 224);
  if (v20)
    v20(*(_QWORD *)(v17 + 320 * HIDWORD(v14) + 288));
  v162 = v164;
  v161 = v163;
  if (_setjmp((int *)v18))
  {
    v21 = (_DWORD *)(v18 + 312);
    v22 = *__error();
    v23 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "playBackMobileJournal";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 4694;
      _os_log_error_impl(&dword_1B8270000, v23, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
    }
    *__error() = v22;
    *v21 = v19;
    CIOnThreadCleanUpReset(v161);
    dropThreadId(HIDWORD(v162), 1, v13);
    CICleanUpReset(HIDWORD(v162), HIDWORD(v161));
    goto LABEL_179;
  }
  if (!v149)
    goto LABEL_176;
  if ((v11 & 1) == 0)
    si_mobile_journal_map_activate((int *)v3);
  v151 = v19;
  v152 = v13;
  v154 = v4;
  v155 = v2;
  v24 = 0;
  v25 = -1;
  v143 = *(_QWORD *)(v3 + 16);
  v26 = 0;
  if (v143 == -1 || v148 < 0xC)
    goto LABEL_170;
  v27 = -1;
  alloc = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v28 = 0;
  v29 = 0;
  v30 = 0;
  v153 = v5;
  while (2)
  {
    v26 = v28;
    v31 = v30;
    v25 = v27;
    if (*(_BYTE *)(v5 + 2433))
    {
      v113 = v27;
      v114 = *__error();
      v115 = _SILogForLogForCategory(4);
      if (os_log_type_enabled(v115, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1B8270000, v115, OS_LOG_TYPE_DEFAULT, "Interrupting indexing; process quitting", buf, 2u);
      }
      *__error() = v114;
      v24 = v31;
      v25 = v113;
      goto LABEL_170;
    }
    v32 = *(_QWORD *)(v5 + 872);
    if (v32 && (*(_DWORD *)(v32 + 104) || *(_QWORD *)(v32 + 120)) && !*(_BYTE *)(v32 + 51))
    {
      v156.tv_sec = 0;
      pthread_mutex_lock(*(pthread_mutex_t **)(v32 + 8));
      if ((*(_DWORD *)(v32 + 104) || *(_QWORD *)(v32 + 120)) && !*(_BYTE *)(v32 + 51))
      {
        ++*(_DWORD *)(v32 + 108);
        *(_DWORD *)(v32 + 168) = 0;
        si_scheduler_do_suspend(v32, &v156);
        tv_sec = v156.tv_sec;
        if (v156.tv_sec)
        {
          pthread_mutex_unlock(*(pthread_mutex_t **)(v32 + 8));
          si_scheduler_trigger_tokens(tv_sec);
          pthread_mutex_lock(*(pthread_mutex_t **)(v32 + 8));
        }
        do
        {
          *(_QWORD *)buf = 0;
          *(_QWORD *)&buf[8] = 0;
          v158 = 0uLL;
          gettimeofday((timeval *)buf, 0);
          v158 = (unint64_t)(*(_QWORD *)buf + 1);
          pthread_cond_timedwait(*(pthread_cond_t **)(v32 + 16), *(pthread_mutex_t **)(v32 + 8), (const timespec *)&v158);
        }
        while (*(_DWORD *)(v32 + 100) && !*(_BYTE *)(v32 + 51));
        --*(_DWORD *)(v32 + 108);
        v5 = v153;
      }
      pthread_mutex_unlock(*(pthread_mutex_t **)(v32 + 8));
      if (*(_BYTE *)(v5 + 2433))
      {
        v134 = v25;
        v135 = *__error();
        v136 = _SILogForLogForCategory(4);
        if (os_log_type_enabled(v136, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_1B8270000, v136, OS_LOG_TYPE_DEFAULT, "Interrupting indexing; process quitting", buf, 2u);
        }
        *__error() = v135;
        v24 = v31;
        v25 = v134;
        v5 = v153;
        goto LABEL_170;
      }
    }
    if ((~(_WORD)v31 & 0xFFF) != 0)
    {
      v33 = v26;
    }
    else
    {
      v33 = v26;
      if (v26 != v31)
      {
        v35 = (__n128)si_sync_ctx_create_with_defer_fd(v5, 0);
        v36 = *(_QWORD *)(v34 + 88);
        if (v36 <= v25 + 1)
          v36 = v25 + 1;
        *(_QWORD *)(v34 + 88) = v36;
        si_sync_index_delayed2(v35);
        v33 = v31;
      }
    }
    v26 = v33;
    v37 = v143 + v29;
    v38 = v143 + v29;
    v39 = *(_DWORD *)(v143 + v29);
    v160 = 0;
    HIDWORD(v40) = v39 + 264306963;
    LODWORD(v40) = v39 + 264306963;
    v145 = v31;
    v141 = v33;
    v41 = -263323923;
    switch((v40 >> 20))
    {
      case 0u:
        v42 = 1;
        VInt64 = v2_readVInt64(v37 + 12, (uint64_t *)&v160);
        goto LABEL_51;
      case 1u:
        goto LABEL_76;
      case 2u:
        v44 = v2_readVInt64(v37 + 18, (uint64_t *)&v160);
        v45 = 1;
        goto LABEL_42;
      case 4u:
        v41 = -262275347;
LABEL_76:
        v147 = v25;
        v39 = v41;
        v71 = v2_readVInt64(v37 + 32, (uint64_t *)&v160);
        v72 = 1;
        goto LABEL_77;
      default:
        if (v39 == -264372499)
        {
          v42 = 0;
          VInt64 = 0;
LABEL_51:
          v56 = *(unsigned int *)(v38 + 4);
          if (v56 > 0xFFFFFFF3 || (v57 = v56 + 12, v58 = v29 + v56 + 12, v148 < v58))
          {
            v147 = v25;
            v116 = *__error();
            v118 = _SILogForLogForCategory(0);
            if (!os_log_type_enabled(v118, OS_LOG_TYPE_ERROR))
              goto LABEL_167;
            *(_DWORD *)buf = 136316418;
            *(_QWORD *)&buf[4] = "playBackMobileJournal";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 4528;
            *(_WORD *)&buf[18] = 2048;
            *(_QWORD *)&buf[20] = 4030594797;
            *(_WORD *)&buf[28] = 2048;
            *(_QWORD *)&buf[30] = v56;
            v166 = 2048;
            v167 = v29;
            v168 = 2048;
            v169 = v149;
            goto LABEL_191;
          }
          if (v56 <= v160)
            goto LABEL_57;
          memset(buf, 0, 24);
          _MDPlistGetRootPlistObjectFromBytes();
          v158 = *(_OWORD *)buf;
          v159 = *(_QWORD *)&buf[16];
          if (!_MDPlistArrayGetCount())
            goto LABEL_57;
          v158 = 0uLL;
          v159 = 0;
          v156 = *(timespec *)buf;
          v157 = *(_QWORD *)&buf[16];
          _MDPlistArrayGetPlistObjectAtIndex();
          v156 = (timespec)v158;
          v157 = v159;
          v59 = _MDPlistContainerCopyObject();
          if (v59)
          {
            v60 = 0;
            v61 = (const void *)v59;
          }
          else
          {
LABEL_57:
            v62 = v25;
            v63 = *__error();
            v64 = _SILogForLogForCategory(0);
            if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136316418;
              *(_QWORD *)&buf[4] = "playBackMobileJournal";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = 4546;
              *(_WORD *)&buf[18] = 2048;
              *(_QWORD *)&buf[20] = 4030594797;
              *(_WORD *)&buf[28] = 2048;
              *(_QWORD *)&buf[30] = v56;
              v166 = 2048;
              v167 = v29;
              v168 = 2048;
              v169 = v149;
              _os_log_error_impl(&dword_1B8270000, v64, OS_LOG_TYPE_ERROR, "%s:%d: Invalid journal entry - nil bundleID, magic:0x%08lx, size:%ld, pos:%ld, end:%ld", buf, 0x3Au);
            }
            v61 = 0;
            *__error() = v63;
            v60 = 1;
            v25 = v62;
          }
          v65 = VInt64 != 0;
          if (v25)
            v66 = VInt64 != 0;
          else
            v66 = 0;
          if (VInt64 >= v25)
            v66 = 0;
          if (VInt64 > v144)
            v65 = 0;
          if (v66 || v65)
          {
            v70 = v145;
            if ((v60 & 1) != 0)
            {
LABEL_100:
              v89 = v58;
              v90 = v70;
              v91 = v25;
LABEL_108:
              v5 = v153;
              goto LABEL_143;
            }
          }
          else
          {
            *(_QWORD *)buf = si_mobile_set_attr_ctx_create(v153, v61);
            *(_DWORD *)(*(_QWORD *)buf + 80) |= 0x10u;
            do
              v67 = __ldaxr((unsigned int *)v3);
            while (__stlxr(v67 + 1, (unsigned int *)v3));
            v68 = *(_QWORD *)buf;
            *(_QWORD *)(*(_QWORD *)buf + 8) = v3;
            *(_QWORD *)(v68 + 16) = v29;
            *(_QWORD *)(v68 + 24) = v57;
            *(_BYTE *)(v68 + 32) = v42;
            *(CFAbsoluteTime *)(v68 + 64) = CFAbsoluteTimeGetCurrent();
            v69 = si_backtrace_routine_resolve(*(_QWORD *)v68, *(const __CFString **)(v68 + 72), (uint64_t (*)())setCSAttributes1, (_QWORD *)v68, buf);
            ((void (*)(_QWORD, _QWORD))v69)(*(_QWORD *)buf, 0);
            if (v25 <= VInt64)
              v25 = VInt64;
            v70 = v145 + 1;
            if ((v60 & 1) != 0)
              goto LABEL_100;
          }
          CFRelease(v61);
          goto LABEL_100;
        }
        if ((v39 & 0xFFEFFFFF) == 0xF04DFEED)
        {
          v147 = v25;
          v71 = 0;
          v72 = 0;
LABEL_77:
          v73 = *(unsigned int *)(v38 + 4);
          v74 = (v73 + 12);
          if (v74 < 0x20 || v148 < v29 + v74)
          {
            v116 = *__error();
            v117 = _SILogForLogForCategory(0);
            v5 = v153;
            if (os_log_type_enabled(v117, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136316418;
              *(_QWORD *)&buf[4] = "playBackMobileJournal";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = 4578;
              *(_WORD *)&buf[18] = 2048;
              *(_QWORD *)&buf[20] = v39;
              *(_WORD *)&buf[28] = 2048;
              *(_QWORD *)&buf[30] = v73;
              v166 = 2048;
              v167 = v29;
              v168 = 2048;
              v169 = v149;
              _os_log_error_impl(&dword_1B8270000, v117, OS_LOG_TYPE_ERROR, "%s:%d: Invalid journal entry, magic:0x%08lx, size:%ld, pos:%ld, end:%ld", buf, 0x3Au);
            }
            goto LABEL_168;
          }
          v140 = v29 + v74;
          v75 = v73 - 20 - v160;
          if (v73 - 20 > v160)
          {
            v139 = v29;
            v76 = *(_WORD *)(v38 + 12) & 0x3FF;
            v77 = (const char *)(v37 + v160 + 32);
            v78 = strnlen(v77, v75);
            v79 = v78;
            if (v78 == v75 || v78 + 1 != v76)
            {
              v92 = *__error();
              v93 = _SILogForLogForCategory(0);
              if (os_log_type_enabled(v93, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136316930;
                *(_QWORD *)&buf[4] = "playBackMobileJournal";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = 4594;
                *(_WORD *)&buf[18] = 2048;
                *(_QWORD *)&buf[20] = v39;
                *(_WORD *)&buf[28] = 2048;
                *(_QWORD *)&buf[30] = v73;
                v166 = 2048;
                v167 = v139;
                v168 = 2048;
                v169 = v149;
                v170 = 2048;
                v171 = v79;
                v172 = 2048;
                v173 = v76;
                _os_log_error_impl(&dword_1B8270000, v93, OS_LOG_TYPE_ERROR, "%s:%d: Invalid journal entry, magic:0x%08lx, size:%ld, pos:%ld, end:%ld, len:%ld(%ld)", buf, 0x4Eu);
              }
              *__error() = v92;
              v29 = v139;
            }
            else
            {
              v80 = CFStringCreateWithCString(alloc, v77, 0x8000100u);
              v29 = v139;
              if (v80)
              {
                v81 = v80;
                v82 = v71 != 0;
                if (v147)
                  v83 = v71 != 0;
                else
                  v83 = 0;
                if (v71 >= v147)
                  v83 = 0;
                if (v71 > v144)
                  v82 = 0;
                if (v83 || v82)
                {
                  if (gSILogLevels[0] >= 5)
                  {
                    v111 = *__error();
                    v112 = _SILogForLogForCategory(0);
                    if (os_log_type_enabled(v112, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)buf = 134218496;
                      *(_QWORD *)&buf[4] = v71;
                      *(_WORD *)&buf[12] = 2048;
                      *(_QWORD *)&buf[14] = v147;
                      *(_WORD *)&buf[22] = 2048;
                      *(_QWORD *)&buf[24] = v144;
                      _os_log_impl(&dword_1B8270000, v112, OS_LOG_TYPE_DEFAULT, "Playback skipping sn: %lld mrsn: %lld csn: %lld", buf, 0x20u);
                    }
                    *__error() = v111;
                  }
                  v88 = v145;
                  v87 = v147;
                }
                else
                {
                  *(_QWORD *)buf = si_mobile_set_attr_ctx_create(v153, v80);
                  *(_DWORD *)(*(_QWORD *)buf + 80) |= 0x10u;
                  do
                    v84 = __ldaxr((unsigned int *)v3);
                  while (__stlxr(v84 + 1, (unsigned int *)v3));
                  v85 = *(_QWORD *)buf;
                  *(_QWORD *)(*(_QWORD *)buf + 8) = v3;
                  *(_QWORD *)(v85 + 16) = v139;
                  *(_QWORD *)(v85 + 24) = v74;
                  *(_BYTE *)(v85 + 32) = v72;
                  *(CFAbsoluteTime *)(v85 + 64) = CFAbsoluteTimeGetCurrent();
                  v86 = si_backtrace_routine_resolve(*(_QWORD *)v85, *(const __CFString **)(v85 + 72), (uint64_t (*)())setCSAttributes2, (_QWORD *)v85, buf);
                  ((void (*)(_QWORD, _QWORD))v86)(*(_QWORD *)buf, 0);
                  if (v147 <= v71)
                    v87 = v71;
                  else
                    v87 = v147;
                  v88 = v145 + 1;
                }
                v5 = v153;
                v25 = v87;
                v108 = v88;
                CFRelease(v81);
                v89 = v140;
                v90 = v108;
                goto LABEL_142;
              }
            }
          }
          v94 = *__error();
          v95 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v95, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136316418;
            *(_QWORD *)&buf[4] = "playBackMobileJournal";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 4601;
            *(_WORD *)&buf[18] = 2048;
            *(_QWORD *)&buf[20] = v39;
            *(_WORD *)&buf[28] = 2048;
            *(_QWORD *)&buf[30] = v73;
            v166 = 2048;
            v167 = v29;
            v168 = 2048;
            v169 = v149;
            _os_log_error_impl(&dword_1B8270000, v95, OS_LOG_TYPE_ERROR, "%s:%d: Invalid journal entry - nil bundleID, magic:0x%08lx, size:%ld, pos:%ld, end:%ld", buf, 0x3Au);
          }
          *__error() = v94;
          v89 = v140;
          v90 = v145;
          v91 = v147;
          goto LABEL_108;
        }
        if (v39 != -261161235)
          goto LABEL_169;
        v44 = 0;
        v45 = 0;
LABEL_42:
        v46 = *(unsigned int *)(v38 + 4);
        v47 = (v46 + 12);
        if (v47 >= 0x12 && v148 >= v29 + v47)
        {
          v48 = v29 + v47;
          v49 = *(unsigned __int16 *)(v38 + 12);
          v50 = *(unsigned __int16 *)(v38 + 12);
          v51 = v46 - 6 - v160;
          if (v46 - 6 <= v160)
          {
            v55 = 0;
LABEL_121:
            v97 = v55 == 0;
            v5 = v153;
            if (!v55 && v50)
            {
              v89 = v48;
              v90 = v145;
              goto LABEL_142;
            }
            if (v44 && v25 && v44 < v25)
            {
              v101 = v48;
              v96 = v55;
              v102 = v25;
              v103 = v145;
              if (v55)
              {
LABEL_138:
                v106 = v103;
                v107 = v102;
                CFRelease(v96);
                v89 = v101;
                v90 = v106;
                v91 = v107;
                goto LABEL_143;
              }
              v89 = v48;
              v90 = v145;
LABEL_142:
              v91 = v25;
              goto LABEL_143;
            }
            v146 = v25;
            v96 = v55;
LABEL_130:
            v98 = v97;
            goto LABEL_131;
          }
          v146 = v25;
          if (v50)
          {
            v52 = v49;
            v53 = (const char *)(v37 + v160 + 18);
            v54 = strnlen(v53, v46 - 6 - v160);
            if (v54 == v51 || v54 + 1 != v52)
            {
              v138 = v54;
              v99 = *__error();
              v100 = _SILogForLogForCategory(0);
              if (os_log_type_enabled(v100, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136316930;
                *(_QWORD *)&buf[4] = "playBackMobileJournal";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = 4651;
                *(_WORD *)&buf[18] = 2048;
                *(_QWORD *)&buf[20] = 4033806061;
                *(_WORD *)&buf[28] = 2048;
                *(_QWORD *)&buf[30] = v46;
                v166 = 2048;
                v167 = v29;
                v168 = 2048;
                v169 = v149;
                v170 = 2048;
                v171 = v138;
                v172 = 2048;
                v173 = v52;
                _os_log_error_impl(&dword_1B8270000, v100, OS_LOG_TYPE_ERROR, "%s:%d: Invalid journal entry, magic:0x%08lx, size:%ld, pos:%ld, end:%ld, len:%ld(%ld)", buf, 0x4Eu);
              }
              *__error() = v99;
              v55 = 0;
            }
            else
            {
              v55 = CFStringCreateWithCString(alloc, v53, 0x8000100u);
            }
            v25 = v146;
            v48 = v29 + v47;
            goto LABEL_121;
          }
          v96 = 0;
          v97 = 1;
          if (v44)
          {
            v5 = v153;
            if (v25)
            {
              v98 = 1;
              if (v44 < v146)
              {
                v89 = v29 + v47;
                v90 = v145;
                v91 = v146;
                goto LABEL_143;
              }
              goto LABEL_131;
            }
            goto LABEL_130;
          }
          v98 = 1;
          v5 = v153;
LABEL_131:
          v101 = v48;
          v104 = si_mobile_delete_attr_ctx_create(v5, v96);
          *((_DWORD *)v104 + 10) |= 0x10u;
          do
            v105 = __ldaxr((unsigned int *)v3);
          while (__stlxr(v105 + 1, (unsigned int *)v3));
          v104[1] = v3;
          v104[2] = v29;
          v104[3] = v47;
          *((_BYTE *)v104 + 32) = v45;
          *((CFAbsoluteTime *)v104 + 6) = CFAbsoluteTimeGetCurrent();
          deleteCSAttributes((unsigned __int8 *)v104, 0);
          if (v146 <= v44)
            v91 = v44;
          else
            v91 = v146;
          v102 = v91;
          v103 = v145 + 1;
          if ((v98 & 1) == 0)
            goto LABEL_138;
          v89 = v101;
          v90 = v145 + 1;
LABEL_143:
          v27 = v91;
          v30 = v90;
          v29 = v89;
          v109 = v89 + 12;
          v25 = v91;
          v24 = v90;
          v26 = v141;
          v28 = v141;
          if (v109 > v148)
            goto LABEL_170;
          continue;
        }
        v147 = v25;
        v116 = *__error();
        v118 = _SILogForLogForCategory(0);
        if (!os_log_type_enabled(v118, OS_LOG_TYPE_ERROR))
          goto LABEL_167;
        *(_DWORD *)buf = 136316418;
        *(_QWORD *)&buf[4] = "playBackMobileJournal";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 4635;
        *(_WORD *)&buf[18] = 2048;
        *(_QWORD *)&buf[20] = 4033806061;
        *(_WORD *)&buf[28] = 2048;
        *(_QWORD *)&buf[30] = v46;
        v166 = 2048;
        v167 = v29;
        v168 = 2048;
        v169 = v149;
LABEL_191:
        _os_log_error_impl(&dword_1B8270000, v118, OS_LOG_TYPE_ERROR, "%s:%d: Invalid journal entry, magic:0x%08lx, size:%ld, pos:%ld, end:%ld", buf, 0x3Au);
LABEL_167:
        v5 = v153;
LABEL_168:
        v31 = v145;
        v26 = v141;
        *__error() = v116;
        v25 = v147;
LABEL_169:
        v24 = v31;
LABEL_170:
        v119 = v24;
        if ((v150 & 1) == 0)
          si_mobile_journal_map_deactivate((_QWORD *)v3);
        v10 = v119 == v26;
        v4 = v154;
        v2 = v155;
        v19 = v151;
        v13 = v152;
        if (!v10)
        {
          v121 = (__n128)si_sync_ctx_create_with_defer_fd(v5, 0);
          v122 = *(_QWORD *)(v120 + 88);
          if (v122 <= v25 + 1)
            v122 = v25 + 1;
          *(_QWORD *)(v120 + 88) = v122;
          si_sync_index_delayed2(v121);
        }
LABEL_176:
        v123 = *(_QWORD *)&threadData[18 * HIDWORD(v162) + 2];
        v124 = v162;
        v125 = v123 + 320 * v162;
        *(_DWORD *)(v125 + 312) = v19;
        v126 = *(void (**)(_QWORD))(v125 + 232);
        if (v126)
          v126(*(_QWORD *)(v123 + 320 * v124 + 288));
        dropThreadId(HIDWORD(v162), 0, v13);
LABEL_179:
        v127 = (unsigned int *)(v4 + 6888);
        do
        {
          v128 = __ldaxr(v127);
          v129 = v128 - 1;
        }
        while (__stlxr(v129, v127));
        if (!v129)
        {
          v130 = *__error();
          v131 = _SILogForLogForCategory(4);
          if (os_log_type_enabled(v131, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_1B8270000, v131, OS_LOG_TYPE_DEFAULT, "Playback finished.", buf, 2u);
          }
          *__error() = v130;
        }
LABEL_185:
        if (v3)
        {
          do
          {
            v132 = __ldaxr((unsigned int *)v3);
            v133 = v132 - 1;
          }
          while (__stlxr(v133, (unsigned int *)v3));
          if (!v133)
            _si_mobile_journal_finalize(v3, 1);
        }
        free(v2);
        return;
    }
  }
}

void _si_mobile_journal_finalize(uint64_t a1, int a2)
{
  BOOL v3;
  xpc_object_t message;
  int v5;
  int v6;
  NSObject *v7;
  _BOOL4 v8;
  const char *v9;
  int v10;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  char *v14;
  void *v15;
  int v16;
  uint64_t v17;
  __int16 v18;
  uint64_t v19;
  __int16 v20;
  uint64_t v21;
  __int16 v22;
  char *v23;
  stat v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  _BYTE v30[31];
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)(a1 + 80))
  {
    if (*(_BYTE *)(a1 + 109))
      v3 = 1;
    else
      v3 = a2 == 0;
    if (v3 || !*(_DWORD *)(a1 + 56) || !*(_QWORD *)(a1 + 64) || !*(_QWORD *)(a1 + 72) || *(uint64_t *)(a1 + 40) < 1)
    {
LABEL_18:
      fd_release(*(char **)(a1 + 80));
      goto LABEL_19;
    }
    message = _si_mobile_journal_create_message(a1, 2u);
    memset(&v24, 0, sizeof(v24));
    fd_stat(*(_QWORD *)(a1 + 80), &v24);
    xpc_dictionary_set_uint64(message, "toc_s", v24.st_size);
    v5 = si_xpc_send_client_msg(message, (uint64_t)&__block_literal_global_823);
    v6 = *__error();
    v7 = _SILogForLogForCategory(0);
    v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
    if (v5)
    {
      if (!v8)
        goto LABEL_16;
      LOWORD(v16) = 0;
      v9 = "### skg journal_complete message sent";
    }
    else
    {
      if (!v8)
        goto LABEL_16;
      LOWORD(v16) = 0;
      v9 = "### skg journal_complete NOT sent";
    }
    _os_log_impl(&dword_1B8270000, v7, OS_LOG_TYPE_DEFAULT, v9, (uint8_t *)&v16, 2u);
LABEL_16:
    *__error() = v6;
    if (message)
      CFRelease(message);
    goto LABEL_18;
  }
LABEL_19:
  if (*(_QWORD *)(a1 + 24))
  {
    v29 = 0u;
    memset(v30, 0, sizeof(v30));
    v27 = 0u;
    v28 = 0u;
    v25 = 0u;
    v26 = 0u;
    memset(&v24, 0, sizeof(v24));
    v10 = *__error();
    v11 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      v13 = *(_QWORD *)(a1 + 16);
      v12 = *(_QWORD *)(a1 + 24);
      v14 = fd_name(*(_QWORD *)(a1 + 8), (char *)&v24, 0xFFuLL);
      v16 = 134218754;
      v17 = a1;
      v18 = 2048;
      v19 = v13;
      v20 = 2048;
      v21 = v12;
      v22 = 2080;
      v23 = v14;
      _os_log_impl(&dword_1B8270000, v11, OS_LOG_TYPE_DEFAULT, "Finalizing journal %p %p %lx %s", (uint8_t *)&v16, 0x2Au);
    }
    *__error() = v10;
    fd_guarded_munmap(*(_QWORD *)(a1 + 8), *(void **)(a1 + 16), *(_QWORD *)(a1 + 24));
  }
  fd_release(*(char **)(a1 + 8));
  free(*(void **)(a1 + 48));
  v15 = *(void **)(a1 + 112);
  if (v15)
    free(v15);
  free((void *)a1);
}

xpc_object_t _si_mobile_journal_create_message(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  xpc_object_t v5;

  do
    v4 = __ldaxr(&g_si_msg_id);
  while (__stlxr(v4 + 1, &g_si_msg_id));
  v5 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_uint64(v5, "msg_id", v4);
  xpc_dictionary_set_uint64(v5, "je", a2);
  xpc_dictionary_set_string(v5, "command", "j");
  xpc_dictionary_set_string(v5, "j_name", *(const char **)(a1 + 48));
  xpc_dictionary_set_uint64(v5, "j_num", *(_QWORD *)(a1 + 40));
  xpc_dictionary_set_string(v5, "j_cookie", *(const char **)(a1 + 112));
  xpc_dictionary_set_uint64(v5, "j_dev", *(int *)(a1 + 56));
  xpc_dictionary_set_uint64(v5, "j_ino", *(_QWORD *)(a1 + 64));
  xpc_dictionary_set_uint64(v5, "toc_ino", *(_QWORD *)(a1 + 72));
  xpc_dictionary_set_uint64(v5, "i_pc_pr", *(unsigned int *)(a1 + 104));
  return v5;
}

int *___si_mobile_journal_notify_complete_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4;
  NSObject *v5;
  int *result;
  int v7;
  uint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v4 = *__error();
  v5 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v7 = 134217984;
    v8 = a3;
    _os_log_impl(&dword_1B8270000, v5, OS_LOG_TYPE_DEFAULT, "### skg journal_complete result %lld", (uint8_t *)&v7, 0xCu);
  }
  result = __error();
  *result = v4;
  return result;
}

int *si_mobile_journal_map_activate(int *result)
{
  uint64_t *v1;
  int v2;
  NSObject *v3;
  os_log_type_t v4;
  uint64_t v5;
  uint64_t v6;
  char *v7;
  int v8;
  uint64_t *v9;
  __int16 v10;
  uint64_t v11;
  __int16 v12;
  uint64_t v13;
  __int16 v14;
  char *v15;
  _OWORD v16[16];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  if (*((_QWORD *)result + 3))
  {
    v1 = (uint64_t *)result;
    if (*((_QWORD *)result + 2) == -1)
    {
      *((_QWORD *)result + 2) = fd_guarded_mmap(*((_QWORD *)result + 1));
      memset(v16, 0, 255);
      v2 = *__error();
      v3 = _SILogForLogForCategory(4);
      v4 = 2 * (dword_1EF19FC9C < 4);
      if (os_log_type_enabled(v3, v4))
      {
        v6 = v1[2];
        v5 = v1[3];
        v7 = fd_name(v1[1], (char *)v16, 0xFFuLL);
        v8 = 134218754;
        v9 = v1;
        v10 = 2048;
        v11 = v6;
        v12 = 2048;
        v13 = v5;
        v14 = 2080;
        v15 = v7;
        _os_log_impl(&dword_1B8270000, v3, v4, "Activated journal %p %p %lx %s", (uint8_t *)&v8, 0x2Au);
      }
      result = __error();
      *result = v2;
    }
  }
  return result;
}

void setCSAttributes1(unsigned __int8 *a1, int a2)
{
  double Current;
  BOOL v6;
  uint64_t v7;
  __uint64_t v8;
  __uint64_t v9;
  unsigned int v10;
  int v11;
  unint64_t v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  void (*v18)(_QWORD);
  _DWORD *v19;
  int v20;
  NSObject *v21;
  uint64_t *base;
  uint64_t v23;
  unint64_t VInt64;
  const __CFString *v25;
  CFTypeID TypeID;
  unsigned int Count;
  uint64_t v28;
  void (*v29)(uint64_t, const __CFString *, uint64_t, int64_t, _QWORD *);
  int64_t v30;
  uint64_t v31;
  uint64_t v32;
  int64_t v33;
  __uint64_t v34;
  int v35;
  int v36;
  NSObject *v37;
  int v38;
  uint64_t v39;
  unsigned int v40;
  uint64_t v41;
  void (*v42)(_QWORD);
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  void (*v46)(_QWORD, _QWORD);
  unsigned int *v47;
  unsigned int v48;
  unsigned int v49;
  const void *v50;
  int v51;
  NSObject *v52;
  CFAbsoluteTime v54;
  const char *v55;
  double v56;
  int v57;
  int v58;
  _QWORD v59[8];
  __int128 v60;
  uint64_t v61;
  unint64_t v62;
  unsigned __int8 *v63;
  int v64;
  __int128 v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  __int128 v70;
  uint64_t v71;
  unint64_t v72;
  unint64_t v73;
  unint64_t v74;
  unint64_t v75;
  unsigned __int8 v76;
  _BYTE buf[28];
  __int16 v78;
  const __CFString *v79;
  uint64_t v80;

  v80 = *MEMORY[0x1E0C80C00];
  v76 = a2;
  Current = CFAbsoluteTimeGetCurrent();
  if (*((_QWORD *)a1 + 7))
    v6 = dword_1EF19FC98 < 5;
  else
    v6 = 1;
  if (!v6)
  {
    v51 = *__error();
    v52 = _SILogForLogForCategory(3);
    if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
    {
      v54 = CFAbsoluteTimeGetCurrent();
      v55 = " canceled";
      v56 = v54 - *((double *)a1 + 8);
      if (!a2)
        v55 = "";
      *(_DWORD *)buf = 134218242;
      *(double *)&buf[4] = v56;
      *(_WORD *)&buf[12] = 2080;
      *(_QWORD *)&buf[14] = v55;
      _os_log_impl(&dword_1B8270000, v52, OS_LOG_TYPE_DEFAULT, "Set attributes waited for %f seconds%s", buf, 0x16u);
    }
    *__error() = v51;
  }
  v7 = *(_QWORD *)a1;
  v8 = clock_gettime_nsec_np(_CLOCK_UPTIME_RAW);
  if (!a2)
  {
    v9 = v8;
    do
    {
      v10 = __ldxr(exceptionSequenceNum);
      v11 = v10 + 1;
    }
    while (__stxr(v10 + 1, exceptionSequenceNum));
    v12 = setThreadIdAndInfo(-1, (__int128 *)sJournalCtxExceptionCallbacks, (uint64_t)a1, 0x40000000, v11);
    v75 = __PAIR64__(v12, HIDWORD(v12));
    v74 = __PAIR64__(v13, v14);
    v15 = *(_QWORD *)&threadData[18 * v12 + 2];
    v16 = v15 + 320 * HIDWORD(v12);
    *(_BYTE *)(v16 + 216) = 0;
    v17 = *(_DWORD *)(v16 + 312);
    v18 = *(void (**)(_QWORD))(v16 + 224);
    if (v18)
      v18(*(_QWORD *)(v15 + 320 * HIDWORD(v12) + 288));
    v73 = v75;
    v72 = v74;
    if (_setjmp((int *)v16))
    {
      v19 = (_DWORD *)(v16 + 312);
      v20 = *__error();
      v21 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)&buf[4] = "setCSAttributes1";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 27482;
        _os_log_error_impl(&dword_1B8270000, v21, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
      }
      *__error() = v20;
      *v19 = v17;
      CIOnThreadCleanUpReset(v72);
      dropThreadId(HIDWORD(v73), 1, v11);
      CICleanUpReset(HIDWORD(v73), HIDWORD(v72));
LABEL_39:
      bumpWorkTime(v7, Current);
      goto LABEL_40;
    }
    base = si_mobile_journal_get_base(*((uint64_t **)a1 + 1), *((_QWORD *)a1 + 2), *((_QWORD *)a1 + 3));
    if (!base || *((_QWORD *)a1 + 3) < 0xCuLL || *(_DWORD *)base != -264306963 && *(_DWORD *)base != -264372499)
    {
LABEL_36:
      v39 = *(_QWORD *)&threadData[18 * HIDWORD(v73) + 2];
      v40 = v73;
      v41 = v39 + 320 * v73;
      *(_DWORD *)(v41 + 312) = v17;
      v42 = *(void (**)(_QWORD))(v41 + 232);
      if (v42)
        v42(*(_QWORD *)(v39 + 320 * v40 + 288));
      dropThreadId(HIDWORD(v73), 0, v11);
      goto LABEL_39;
    }
    v57 = *((_DWORD *)a1 + 20);
    v58 = *((_DWORD *)base + 2);
    v23 = (uint64_t)base + 12;
    if (a1[32])
    {
      *(_QWORD *)buf = 0;
      VInt64 = v2_readVInt64(v23, (uint64_t *)buf);
    }
    else
    {
      VInt64 = 0;
    }
    v70 = 0uLL;
    v71 = 0;
    _MDPlistGetRootPlistObjectFromBytes();
    memset(buf, 0, 24);
    if (_MDPlistArrayGetCount() != 2)
    {
      v35 = 0;
LABEL_33:
      if (VInt64 && !v35)
        *(_QWORD *)(v7 + 2136) = VInt64;
      goto LABEL_36;
    }
    v67 = 0;
    v68 = 0;
    v69 = 0;
    *(_OWORD *)buf = v70;
    *(_QWORD *)&buf[16] = v71;
    _MDPlistArrayGetPlistObjectAtIndex();
    v65 = 0uLL;
    v66 = 0;
    *(_OWORD *)buf = v70;
    *(_QWORD *)&buf[16] = v71;
    _MDPlistArrayGetPlistObjectAtIndex();
    memset(buf, 0, 24);
    v25 = (const __CFString *)_MDPlistContainerCopyObject();
    if (v25 && (TypeID = CFStringGetTypeID(), TypeID == CFGetTypeID(v25)))
    {
      *(_OWORD *)buf = v65;
      *(_QWORD *)&buf[16] = v66;
      Count = _MDPlistArrayGetCount();
      v28 = *(_QWORD *)(v7 + 2360);
      v29 = *(void (**)(uint64_t, const __CFString *, uint64_t, int64_t, _QWORD *))(v28 + 120);
      v30 = Count;
      v31 = *(_QWORD *)(v28 + 136);
      v32 = a1[85];
      v59[0] = MEMORY[0x1E0C809B0];
      v59[1] = 0x40000000;
      v59[2] = __setCSAttributes1_block_invoke;
      v59[3] = &__block_descriptor_tmp_1475;
      v59[4] = v7;
      v59[5] = v25;
      v59[6] = v30;
      v59[7] = a1;
      v60 = v65;
      v61 = v66;
      v62 = VInt64;
      v64 = v57 | v58;
      v63 = &v76;
      v29(v31, v25, v32, v30, v59);
      v33 = SIGetAccumulatedSizeForGroup(v7, v25, 0);
      v34 = clock_gettime_nsec_np(_CLOCK_UPTIME_RAW);
      logIndexingEventInCoreAnalyticsWithBundleId(v25, v30, v33, v34 - v9);
    }
    else
    {
      v36 = *__error();
      v37 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315906;
        *(_QWORD *)&buf[4] = "setCSAttributes1";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 27417;
        *(_WORD *)&buf[18] = 2048;
        *(_QWORD *)&buf[20] = VInt64;
        v78 = 2112;
        v79 = v25;
        _os_log_error_impl(&dword_1B8270000, v37, OS_LOG_TYPE_ERROR, "%s:%d: Invalid bundleID %ld %@", buf, 0x26u);
      }
      *__error() = v36;
      if (!v25)
      {
        v38 = 0;
        goto LABEL_32;
      }
    }
    CFRelease(v25);
    v38 = v76;
LABEL_32:
    v35 = v38;
    goto LABEL_33;
  }
LABEL_40:
  v43 = *((_QWORD *)a1 + 3);
  if (v43)
  {
    v44 = -v43;
    do
      v45 = __ldxr(&gEnqueuedSize);
    while (__stxr(v45 + v44, &gEnqueuedSize));
  }
  v46 = (void (*)(_QWORD, _QWORD))*((_QWORD *)a1 + 5);
  if (v46)
    v46(*((_QWORD *)a1 + 6), v76);
  v47 = (unsigned int *)*((_QWORD *)a1 + 1);
  if (v47)
  {
    do
    {
      v48 = __ldaxr(v47);
      v49 = v48 - 1;
    }
    while (__stlxr(v49, v47));
    if (!v49)
      _si_mobile_journal_finalize((uint64_t)v47, 1);
  }
  v50 = (const void *)*((_QWORD *)a1 + 9);
  if (v50)
    CFRelease(v50);
  free(a1);
}

void si_mobile_journal_map_deactivate(_QWORD *a1)
{
  int v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  void *v7;
  int v8;
  _QWORD *v9;
  __int16 v10;
  uint64_t v11;
  __int16 v12;
  uint64_t v13;
  __int16 v14;
  char *v15;
  _OWORD v16[16];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  memset(v16, 0, 255);
  v2 = *__error();
  v3 = _SILogForLogForCategory(4);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v5 = a1[2];
    v4 = a1[3];
    v6 = fd_name(a1[1], (char *)v16, 0xFFuLL);
    v8 = 134218754;
    v9 = a1;
    v10 = 2048;
    v11 = v5;
    v12 = 2048;
    v13 = v4;
    v14 = 2080;
    v15 = v6;
    _os_log_impl(&dword_1B8270000, v3, OS_LOG_TYPE_DEFAULT, "Deactivating journal %p %p %lx %s", (uint8_t *)&v8, 0x2Au);
  }
  *__error() = v2;
  v7 = (void *)a1[2];
  if (v7 != (void *)-1)
    fd_guarded_munmap(a1[1], v7, a1[3]);
  a1[2] = -1;
  a1[3] = 0;
}

void __deleteCSAttributes_block_invoke(uint64_t a1)
{
  unsigned int v2;
  int v3;
  unint64_t v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  void (*v10)(_QWORD);
  _DWORD *v11;
  int v12;
  NSObject *v13;
  char v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  size_t v18;
  size_t v19;
  uint64_t v20;
  int v21;
  int v22;
  uint64_t v23;
  unsigned int v24;
  uint64_t v25;
  void (*v26)(_QWORD);
  _QWORD v27[6];
  int8x16_t v28;
  uint64_t v29;
  int v30;
  int v31;
  __int16 v32;
  char v33;
  char v34;
  char v35;
  unint64_t v36;
  unsigned int v37;
  unsigned int v38;
  unint64_t v39;
  unsigned int v40;
  unsigned int v41;
  _BYTE buf[12];
  __int16 v43;
  int v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  do
  {
    v2 = __ldxr(exceptionSequenceNum);
    v3 = v2 + 1;
  }
  while (__stxr(v2 + 1, exceptionSequenceNum));
  v4 = setThreadIdAndInfo(-1, (__int128 *)sJournalCtxExceptionCallbacks, *(_QWORD *)(a1 + 32), 0x40000000, v3);
  v40 = HIDWORD(v4);
  v41 = v4;
  v39 = __PAIR64__(v5, v6);
  v7 = *(_QWORD *)&threadData[18 * v4 + 2];
  v8 = v7 + 320 * HIDWORD(v4);
  *(_BYTE *)(v8 + 216) = 0;
  v9 = *(_DWORD *)(v8 + 312);
  v10 = *(void (**)(_QWORD))(v8 + 224);
  if (v10)
    v10(*(_QWORD *)(v7 + 320 * HIDWORD(v4) + 288));
  v38 = v41;
  v37 = v40;
  v36 = v39;
  if (_setjmp((int *)v8))
  {
    v11 = (_DWORD *)(v8 + 312);
    v12 = *__error();
    v13 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "deleteCSAttributes_block_invoke";
      v43 = 1024;
      v44 = 28286;
      _os_log_error_impl(&dword_1B8270000, v13, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
    }
    *__error() = v12;
    *v11 = v9;
    CIOnThreadCleanUpReset(v36);
    dropThreadId(v38, 1, v3);
    CICleanUpReset(v38, HIDWORD(v36));
  }
  else
  {
    v14 = *(_BYTE *)(a1 + 56) ^ 1;
    if (*(_BYTE *)(a1 + 56))
    {
      v15 = 0;
    }
    else
    {
      v16 = *(_QWORD *)(a1 + 40);
      if (!*(_QWORD *)(v16 + 288))
      {
        v17 = *(_QWORD *)(v16 + 296);
        if (v17)
        {
          *(_QWORD *)(v16 + 288) = v17;
          *(_QWORD *)(*(_QWORD *)(a1 + 40) + 296) = 0;
        }
        else
        {
          *(_QWORD *)(*(_QWORD *)(a1 + 40) + 288) = RLEOIDArrayCreateMutable((const __CFAllocator *)*MEMORY[0x1E0C9AE00]);
        }
      }
      v15 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 288);
    }
    *(_QWORD *)buf = 0;
    LODWORD(v18) = *(_DWORD *)(a1 + 59);
    if (gCPUCount >= v18)
      v18 = v18;
    else
      v18 = gCPUCount;
    v19 = v18;
    v20 = *(_QWORD *)(a1 + 32);
    if ((_DWORD)v18)
      v21 = *(_DWORD *)(*(_QWORD *)v20 + 32);
    else
      v21 = -1;
    v27[0] = MEMORY[0x1E0C809B0];
    v27[1] = 0x40000000;
    v27[2] = __deleteCSAttributes_block_invoke_2;
    v27[3] = &__block_descriptor_tmp_1477;
    v27[4] = v20;
    v27[5] = buf;
    v22 = *(_DWORD *)(a1 + 57);
    v30 = v21;
    v31 = v22;
    v32 = *(_WORD *)(a1 + 61);
    v28 = vextq_s8(*(int8x16_t *)(a1 + 40), *(int8x16_t *)(a1 + 40), 8uLL);
    v33 = *(_BYTE *)(a1 + 56);
    v29 = v15;
    v34 = 0;
    v35 = v14;
    dispatch_apply(v19, 0, v27);
    v23 = *(_QWORD *)&threadData[18 * v38 + 2];
    v24 = v37;
    v25 = v23 + 320 * v37;
    *(_DWORD *)(v25 + 312) = v9;
    v26 = *(void (**)(_QWORD))(v25 + 232);
    if (v26)
      v26(*(_QWORD *)(v23 + 320 * v24 + 288));
    dropThreadId(v38, 0, v3);
  }
  si_finish_text_store_deletions(*(_QWORD *)(a1 + 40));
}

uint64_t si_zombifyItem(uint64_t a1)
{
  uint64_t v1;
  char v2;
  char v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const void *Mutable;
  uint64_t v12;
  int v14;
  NSObject *v15;
  _BYTE v16[31];
  char v17;
  __int128 v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22[512];
  __int128 buf;
  uint64_t v24;
  uint64_t v25;

  v1 = MEMORY[0x1E0C80A78](a1);
  v3 = v2;
  v5 = v4;
  v7 = v6;
  v9 = v8;
  v10 = v1;
  v25 = *MEMORY[0x1E0C80C00];
  bzero(v22, 0x1000uLL);
  _SIStackAllocatorCreate(v22, 4096, indexingZone);
  if (!v22[3])
    v22[1] = (v22[0] + 55) & 0xFFFFFFFFFFFFFFF0;
  Mutable = (const void *)_MDPlistContainerCreateMutable();
  _MDPlistContainerBeginContainer();
  _MDPlistContainerBeginArray();
  _MDPlistContainerBeginDictionary();
  v20 = 0;
  v21 = 0;
  db_get_field(*(int **)(v10 + 1184), v7, "_kMDItemExternalID", &v21, &v20);
  _MDPlistContainerAddCString();
  _MDPlistContainerAddCString();
  _MDPlistContainerAddCString();
  CFAbsoluteTimeGetCurrent();
  _MDPlistContainerAddDateValue();
  _MDPlistContainerAddCString();
  _MDPlistContainerAddBooleanValue();
  _MDPlistContainerEndDictionary();
  _MDPlistContainerAddNullValue();
  _MDPlistContainerEndArray();
  _MDPlistContainerEndContainer();
  v18 = 0uLL;
  v19 = 0;
  _MDPlistGetRootPlistObjectFromPlist();
  if (gSILogLevels[0] >= 5)
  {
    v14 = *__error();
    v15 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 134217984;
      *(_QWORD *)((char *)&buf + 4) = v9;
      _os_log_impl(&dword_1B8270000, v15, OS_LOG_TYPE_DEFAULT, "Zombifying oid %lld", (uint8_t *)&buf, 0xCu);
    }
    *__error() = v14;
  }
  buf = v18;
  v24 = v19;
  _MDPlistArrayGetPlistObjectAtIndex();
  v24 = 0;
  buf = 0u;
  v12 = processOneCS(v10, -1, v5, 0, 0, v16, &buf, 0, 0, 0, v3, 0, 0, &v17);
  CFRelease(Mutable);
  return v12;
}

void si_enqueue_text_store_doc_for_deletion(uint64_t a1, unint64_t a2)
{
  unint64_t **v4;
  unint64_t *v5;
  unint64_t *v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t *v9;
  int v10;
  const char *v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  os_unfair_lock_lock((os_unfair_lock_t)&text_store_docs_lock);
  v4 = *(unint64_t ***)(a1 + 6936);
  if (!v4)
  {
    v4 = (unint64_t **)malloc_type_calloc(0x18uLL, 1uLL, 0x713F5A7AuLL);
    *(_QWORD *)(a1 + 6936) = v4;
  }
  v5 = v4[1];
  v6 = *v4;
  if (v5 != v4[2])
    goto LABEL_9;
  v7 = 2 * (_QWORD)v5;
  if (v7 <= 0x10)
    v8 = 16;
  else
    v8 = v7;
  v9 = (unint64_t *)reallocf(*v4, 8 * v8);
  *v4 = v9;
  if (v9)
  {
    v6 = v9;
    v4[2] = (unint64_t *)v8;
    v5 = v4[1];
LABEL_9:
    v4[1] = (unint64_t *)((char *)v5 + 1);
    v6[(_QWORD)v5] = a2;
    if (v5 == (unint64_t *)0x7FFF)
    {
      si_text_store_bulk_delete(a1, v6, 0x8000);
      free(v4);
      *(_QWORD *)(a1 + 6936) = 0;
    }
    goto LABEL_13;
  }
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    v10 = 136315138;
    v11 = "si_enqueue_text_store_doc_for_deletion";
    _os_log_fault_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "allocation failure in %s", (uint8_t *)&v10, 0xCu);
  }
LABEL_13:
  os_unfair_lock_unlock((os_unfair_lock_t)&text_store_docs_lock);
}

void cleanupRelatedItemWithBundle(char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  char *v12;
  char *v13;
  CFIndex v14;
  uint64_t v15;
  int v16;
  NSObject *v17;
  CFIndex v18;
  const __CFAllocator *v19;
  CFStringRef v20;
  CFStringRef v21;
  CFStringRef v22;
  BOOL v23;
  uint64_t v24;
  void (*v25)(_QWORD, _QWORD, CFStringRef, CFStringRef, _QWORD);
  NSObject *v26;
  int v27;
  NSObject *v28;
  int v29;
  unint64_t v30;
  uint8_t buf[4];
  char *v32;
  __int16 v33;
  char *v34;
  __int16 v35;
  char *v36;
  __int16 v37;
  unint64_t v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  v12 = strchr(a1, 58);
  if (!v12)
    return;
  *v12 = 0;
  v13 = v12 + 1;
  v14 = v12 - a1;
  v15 = a2 - (v12 - a1);
  v30 = 0;
  if (dword_1EF19FC9C >= 5)
  {
    v29 = *__error();
    v26 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315650;
      v32 = a1;
      v33 = 2080;
      v34 = a1;
      v35 = 2080;
      v36 = v13;
      _os_log_impl(&dword_1B8270000, v26, OS_LOG_TYPE_DEFAULT, "Deleting related item for %s (%s , %s)", buf, 0x20u);
    }
    *__error() = v29;
  }
  if (_si_get_object_for_identifier_createParentDBO(a5, (int)v15 - 1, v13, (int)v14 + 1, (uint64_t)a1, 0, 0, 0, &v30, 0, 0))
  {
    if (dword_1EF19FC9C >= 5)
    {
      v16 = *__error();
      v17 = _SILogForLogForCategory(4);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315650;
        v32 = a1;
        v33 = 2080;
        v34 = a1;
        v35 = 2080;
        v36 = v13;
        _os_log_impl(&dword_1B8270000, v17, OS_LOG_TYPE_DEFAULT, "Failed to find related item for %s (%s , %s)", buf, 0x20u);
      }
      *__error() = v16;
    }
    return;
  }
  v18 = v15 - 2;
  if (dword_1EF19FC9C >= 5)
  {
    v27 = *__error();
    v28 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315906;
      v32 = a1;
      v33 = 2080;
      v34 = a1;
      v35 = 2080;
      v36 = v13;
      v37 = 2048;
      v38 = v30;
      _os_log_impl(&dword_1B8270000, v28, OS_LOG_TYPE_DEFAULT, "Found related item for %s (%s , %s), oid: %lld", buf, 0x2Au);
    }
    *__error() = v27;
  }
  buf[0] = 0;
  _si_delete_attributes_inner(a5, v30, 0, a3, a4, a6, buf);
  si_finish_text_store_deletions(a5);
  if (buf[0])
    notify_post("com.apple.spotlight.SyndicatedContentDeleted");
  v19 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v20 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const UInt8 *)v13, v18, 0x8000100u, 0);
  v21 = CFStringCreateWithBytes(v19, (const UInt8 *)a1, v14, 0x8000100u, 0);
  v22 = v21;
  if (v20)
    v23 = v21 == 0;
  else
    v23 = 1;
  if (!v23)
  {
    v24 = *(_QWORD *)(a5 + 2360);
    v25 = *(void (**)(_QWORD, _QWORD, CFStringRef, CFStringRef, _QWORD))(v24 + 112);
    if (v25 && *(_BYTE *)(a5 + 2072))
      v25(*(_QWORD *)(v24 + 136), 0, v21, v20, 0);
    goto LABEL_21;
  }
  if (v20)
LABEL_21:
    CFRelease(v20);
  if (v22)
    CFRelease(v22);
}

uint64_t si_mobile_journal_create(uint64_t a1)
{
  uint64_t v1;
  int v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int *v11;
  uint64_t v12;
  unsigned int *v13;
  unsigned int v14;
  const __CFAllocator *v15;
  const __CFUUID *v16;
  const __CFString *v17;
  CFIndex v18;
  char *v19;
  char *v20;
  const char *v21;
  char *v22;
  char *v23;
  const char *v24;
  int v25;
  uint64_t v26;
  _QWORD *sibling_with_suffix_protected;
  const char *v28;
  char *v29;
  char v30;
  char v31;
  const char *v32;
  const char *v33;
  const char *v34;
  const char *v35;
  unsigned int v36;
  unsigned int v37;
  const char *v38;
  int v39;
  NSObject *v40;
  uint64_t v41;
  uint64_t v42;
  const char *v43;
  int v44;
  int v45;
  NSObject *v46;
  NSObject *v47;
  int v48;
  char *v49;
  char *v50;
  uint64_t i;
  int v52;
  int v53;
  NSObject *v54;
  NSObject *v55;
  int v56;
  const char *v57;
  NSObject *v58;
  uint32_t v59;
  int v60;
  NSObject *v61;
  int v62;
  NSObject *v63;
  int v64;
  NSObject *v65;
  uint64_t v66;
  uint64_t v67;
  NSObject *v68;
  xpc_object_t message;
  int v70;
  int v71;
  NSObject *v72;
  _BOOL4 v73;
  const char *v74;
  int v76;
  stat v77;
  _OWORD v78[16];
  uint8_t buf[4];
  char *v80;
  __int16 v81;
  _BYTE v82[20];
  __int16 v83;
  char *v84;
  stat v85;
  char v86[1024];
  char v87;
  char __str[1024];
  _BYTE v89[1024];
  _BYTE v90[1024];
  char *v91[130];

  v1 = MEMORY[0x1E0C80A78](a1);
  v3 = v2;
  v5 = v4;
  v7 = v6;
  v9 = v8;
  v10 = v1;
  v91[129] = *(char **)MEMORY[0x1E0C80C00];
  v11 = (unsigned int *)malloc_type_calloc(1uLL, 0x78uLL, 0x10F004029A00669uLL);
  v12 = (uint64_t)v11;
  if (v11)
  {
    *((_QWORD *)v11 + 2) = -1;
    atomic_store(1u, v11);
    if (v9)
    {
      v13 = (unsigned int *)(v9 + 32);
      do
        v14 = __ldxr(v13);
      while (__stxr(v14 + 1, v13));
    }
    *((_QWORD *)v11 + 1) = v9;
    v15 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v16 = (const __CFUUID *)si_storecookieRef(v10);
    v17 = CFUUIDCreateString(v15, v16);
    v18 = CFStringGetLength(v17) + 1;
    v19 = (char *)malloc_type_malloc(v18, 0x100004077774924uLL);
    CFStringGetCString(v17, v19, v18, 0x8000100u);
    CFRelease(v17);
    *(_QWORD *)(v12 + 112) = v19;
    *(_DWORD *)(v12 + 104) = v7;
    if (v5)
    {
      memset(v78, 0, sizeof(v78));
      v20 = fd_name(*(_QWORD *)(v12 + 8), (char *)v78, 0x100uLL);
      if (v20)
      {
        v21 = v20;
        v22 = strrchr(v20, 46);
        if (v22)
        {
          v23 = v22;
          v25 = v22[1];
          v24 = v22 + 1;
          if (v25)
          {
            v91[0] = 0;
            v26 = strtol(v24, v91, 0);
            *(_QWORD *)(v12 + 40) = v26;
            if (v26 >= 1)
              *(_QWORD *)(v12 + 48) = strndup(v21, v23 - v21);
          }
        }
      }
      if (*(uint64_t *)(v12 + 40) >= 1)
      {
        memset(&v77, 0, sizeof(v77));
        if (!fd_stat(*(_QWORD *)(v12 + 8), &v77))
        {
          *(_DWORD *)(v12 + 56) = v77.st_dev;
          *(_QWORD *)(v12 + 64) = v77.st_ino;
        }
        sibling_with_suffix_protected = fd_create_sibling_with_suffix_protected(*(_QWORD *)(v12 + 8), "_toc", 1537);
        *(_QWORD *)(v12 + 80) = sibling_with_suffix_protected;
        if (!fd_stat((uint64_t)sibling_with_suffix_protected, &v77))
          *(_QWORD *)(v12 + 72) = v77.st_ino;
        if (v3)
        {
          bzero(v91, 0x400uLL);
          bzero(v90, 0x400uLL);
          bzero(v89, 0x400uLL);
          bzero(__str, 0x400uLL);
          bzero(&v87, 0x400uLL);
          bzero(v86, 0x400uLL);
          v28 = 0;
          if ((fcntl(*(_DWORD *)(v10 + 32), 50, v91) & 0x80000000) == 0)
          {
            if (LOBYTE(v91[0]))
            {
              v28 = (const char *)v91;
              v29 = strrchr((char *)v91, 47);
              if (v29)
              {
                v30 = 1;
                do
                {
                  v31 = v30;
                  if (v29 <= (char *)v91)
                  {
LABEL_25:
                    if (*v29 != 47)
                      break;
                  }
                  else
                  {
                    while (*v29 != 47)
                    {
                      if (--v29 <= (char *)v91)
                      {
                        v29 = (char *)v91;
                        goto LABEL_25;
                      }
                    }
                  }
                  v30 = 0;
                  *v29 = 0;
                }
                while ((v31 & 1) != 0);
                v28 = (const char *)v91;
              }
            }
          }
          v32 = fd_realpath(*(_DWORD **)(v12 + 8), v90);
          if (v32)
          {
            v33 = v32;
            v34 = fd_realpath(*(_DWORD **)(v12 + 80), v89);
            if (v34)
            {
              v35 = v34;
              v36 = *(_DWORD *)(v12 + 104);
              if ((v36 & 1) != 0)
              {
                v38 = "cs_priority";
              }
              else
              {
                v37 = (v36 >> 1) - 1;
                if (v37 > 6)
                  v38 = "cs_default";
                else
                  v38 = off_1E6E35AF8[v37];
              }
              snprintf(__str, 0x400uLL, "%s/%s/%d/%s", v28, "SpotlightKnowledgeEvents/index.V2/journals", 10, v38);
              snprintf(&v87, 0x400uLL, "%s/%s_%s_%d_%llu_%s_%ld.journal", __str, "skg_events", *(const char **)(v12 + 112), *(_DWORD *)(v12 + 56), *(_QWORD *)(v12 + 64), *(const char **)(v12 + 48), *(_QWORD *)(v12 + 40));
              snprintf(v86, 0x400uLL, "%s/%s_%s_%d_%s_%ld.toc", __str, "skg_events", *(const char **)(v12 + 112), *(_DWORD *)(v12 + 56), *(const char **)(v12 + 48), *(_QWORD *)(v12 + 40));
              memset(&v85, 0, sizeof(v85));
              if (stat(__str, &v85) != -1)
                goto LABEL_40;
              v49 = strdup(__str);
              if (v49)
              {
                v50 = v49;
                for (i = 1; ; ++i)
                {
                  if (v50[i] == 47)
                  {
                    v50[i] = 0;
                    if (mkdir(v50, 0x1FFu) == -1 && *__error() != 17)
                    {
                      v64 = *__error();
                      v65 = _SILogForLogForCategory(4);
                      if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
                      {
                        *(_DWORD *)buf = 136315650;
                        v80 = "si_create_nested_dirs";
                        v81 = 1024;
                        *(_DWORD *)v82 = 4069;
                        *(_WORD *)&v82[4] = 2080;
                        *(_QWORD *)&v82[6] = v50;
                        goto LABEL_91;
                      }
LABEL_72:
                      *__error() = v64;
                      free(v50);
                      goto LABEL_73;
                    }
                    v50[i] = 47;
                  }
                  else if (!v50[i])
                  {
                    if (mkdir(v50, 0x1FFu) == -1 && *__error() != 17)
                    {
                      v64 = *__error();
                      v65 = _SILogForLogForCategory(4);
                      if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
                      {
                        *(_DWORD *)buf = 136315650;
                        v80 = "si_create_nested_dirs";
                        v81 = 1024;
                        *(_DWORD *)v82 = 4080;
                        *(_WORD *)&v82[4] = 2080;
                        *(_QWORD *)&v82[6] = v50;
LABEL_91:
                        _os_log_error_impl(&dword_1B8270000, v65, OS_LOG_TYPE_ERROR, "%s:%d: SpotlightIndex#si_create_nested_dirsmkdir failed on %s", buf, 0x1Cu);
                      }
                      goto LABEL_72;
                    }
                    free(v50);
                    v60 = *__error();
                    v61 = _SILogForLogForCategory(4);
                    if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)buf = 136315138;
                      v80 = __str;
                      _os_log_impl(&dword_1B8270000, v61, OS_LOG_TYPE_DEFAULT, "SpotlightIndex#si_mobile_journal_hardlink_new_journal Created dir for hardlinking journals: %s", buf, 0xCu);
                    }
                    *__error() = v60;
LABEL_40:
                    v44 = link(v33, &v87);
                    v45 = *__error();
                    v46 = _SILogForLogForCategory(4);
                    v47 = v46;
                    if (v44)
                    {
                      if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
                      {
                        v48 = *__error();
                        *(_DWORD *)buf = 136316162;
                        v80 = "si_mobile_journal_hardlink_new_journal";
                        v81 = 1024;
                        *(_DWORD *)v82 = 4166;
                        *(_WORD *)&v82[4] = 1024;
                        *(_DWORD *)&v82[6] = v48;
                        *(_WORD *)&v82[10] = 2080;
                        *(_QWORD *)&v82[12] = v33;
                        v83 = 2080;
                        v84 = &v87;
                        _os_log_error_impl(&dword_1B8270000, v47, OS_LOG_TYPE_ERROR, "%s:%d: SpotlightIndex#si_mobile_journal_hardlink_new_journal Error %d linking journal(%s) for spotlightknowledged(%s)", buf, 0x2Cu);
                      }
                    }
                    else if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)buf = 136315394;
                      v80 = (char *)v33;
                      v81 = 2080;
                      *(_QWORD *)v82 = &v87;
                      _os_log_impl(&dword_1B8270000, v47, OS_LOG_TYPE_DEFAULT, "SpotlightIndex#si_mobile_journal_hardlink_new_journal Linked journal(%s) for spotlightknowledged(%s)", buf, 0x16u);
                    }
                    *__error() = v45;
                    v52 = link(v35, v86);
                    v53 = *__error();
                    v54 = _SILogForLogForCategory(4);
                    v55 = v54;
                    if (v52)
                    {
                      if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
                      {
                        v56 = *__error();
                        *(_DWORD *)buf = 136316162;
                        v80 = "si_mobile_journal_hardlink_new_journal";
                        v81 = 1024;
                        *(_DWORD *)v82 = 4173;
                        *(_WORD *)&v82[4] = 1024;
                        *(_DWORD *)&v82[6] = v56;
                        *(_WORD *)&v82[10] = 2080;
                        *(_QWORD *)&v82[12] = v35;
                        v83 = 2080;
                        v84 = v86;
                        v57 = "%s:%d: SpotlightIndex#si_mobile_journal_hardlink_new_journal Error %d linking journal toc("
                              "%s) for spotlightknowledged(%s)";
                        v58 = v55;
                        v59 = 44;
                        goto LABEL_89;
                      }
                    }
                    else if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)buf = 136315394;
                      v80 = (char *)v35;
                      v81 = 2080;
                      *(_QWORD *)v82 = v86;
                      _os_log_impl(&dword_1B8270000, v55, OS_LOG_TYPE_DEFAULT, "SpotlightIndex#si_mobile_journal_hardlink_new_journal Linked journal toc(%s) for spotlightknowledged(%s)", buf, 0x16u);
                    }
                    goto LABEL_74;
                  }
                }
              }
              v62 = *__error();
              v63 = _SILogForLogForCategory(4);
              if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136315650;
                v80 = "si_create_nested_dirs";
                v81 = 1024;
                *(_DWORD *)v82 = 4059;
                *(_WORD *)&v82[4] = 2080;
                *(_QWORD *)&v82[6] = __str;
                _os_log_error_impl(&dword_1B8270000, v63, OS_LOG_TYPE_ERROR, "%s:%d: SpotlightIndex#si_create_nested_dirs strdup failed on %s", buf, 0x1Cu);
              }
              *__error() = v62;
LABEL_73:
              v53 = *__error();
              v68 = _SILogForLogForCategory(4);
              if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
              {
                v76 = *__error();
                *(_DWORD *)buf = 136315906;
                v80 = "si_mobile_journal_hardlink_new_journal";
                v81 = 1024;
                *(_DWORD *)v82 = 4156;
                *(_WORD *)&v82[4] = 1024;
                *(_DWORD *)&v82[6] = v76;
                *(_WORD *)&v82[10] = 2080;
                *(_QWORD *)&v82[12] = __str;
                v57 = "%s:%d: SpotlightIndex#si_mobile_journal_hardlink_new_journal Error %d creating dir for hardlinkging: %s";
                v58 = v68;
                v59 = 34;
LABEL_89:
                _os_log_error_impl(&dword_1B8270000, v58, OS_LOG_TYPE_ERROR, v57, buf, v59);
              }
LABEL_74:
              *__error() = v53;
LABEL_75:
              if (!*(_DWORD *)(v12 + 56)
                || !*(_QWORD *)(v12 + 64)
                || !*(_QWORD *)(v12 + 72)
                || *(uint64_t *)(v12 + 40) < 1)
              {
                return v12;
              }
              message = _si_mobile_journal_create_message(v12, 1u);
              v70 = si_xpc_send_client_msg(message, (uint64_t)&__block_literal_global_809);
              v71 = *__error();
              v72 = _SILogForLogForCategory(0);
              v73 = os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT);
              if (v70)
              {
                if (!v73)
                  goto LABEL_85;
                LOWORD(v91[0]) = 0;
                v74 = "### skg journal_new message sent";
              }
              else
              {
                if (!v73)
                  goto LABEL_85;
                LOWORD(v91[0]) = 0;
                v74 = "### skg journal_new NOT sent";
              }
              _os_log_impl(&dword_1B8270000, v72, OS_LOG_TYPE_DEFAULT, v74, (uint8_t *)v91, 2u);
LABEL_85:
              *__error() = v71;
              if (message)
                CFRelease(message);
              return v12;
            }
            v39 = *__error();
            v40 = _SILogForLogForCategory(4);
            if (!os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
            {
LABEL_36:
              *__error() = v39;
              goto LABEL_75;
            }
            v67 = *(_QWORD *)(v12 + 40);
            v66 = *(_QWORD *)(v12 + 48);
            v85.st_dev = 136315906;
            *(_QWORD *)&v85.st_mode = "si_mobile_journal_hardlink_new_journal";
            WORD2(v85.st_ino) = 1024;
            *(_DWORD *)((char *)&v85.st_ino + 6) = 4132;
            HIWORD(v85.st_uid) = 2080;
            *(_QWORD *)&v85.st_gid = v66;
            *((_WORD *)&v85.st_rdev + 2) = 2048;
            *(_QWORD *)((char *)&v85.st_rdev + 6) = v67;
            v43 = "%s:%d: SpotlightIndex#si_mobile_journal_hardlink_new_journal Could not get journal toc realpath for journal: %s.%ld";
          }
          else
          {
            v39 = *__error();
            v40 = _SILogForLogForCategory(4);
            if (!os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
              goto LABEL_36;
            v42 = *(_QWORD *)(v12 + 40);
            v41 = *(_QWORD *)(v12 + 48);
            v85.st_dev = 136315906;
            *(_QWORD *)&v85.st_mode = "si_mobile_journal_hardlink_new_journal";
            WORD2(v85.st_ino) = 1024;
            *(_DWORD *)((char *)&v85.st_ino + 6) = 4126;
            HIWORD(v85.st_uid) = 2080;
            *(_QWORD *)&v85.st_gid = v41;
            *((_WORD *)&v85.st_rdev + 2) = 2048;
            *(_QWORD *)((char *)&v85.st_rdev + 6) = v42;
            v43 = "%s:%d: SpotlightIndex#si_mobile_journal_hardlink_new_journal Could not get journal realpath: %s.%ld";
          }
          _os_log_error_impl(&dword_1B8270000, v40, OS_LOG_TYPE_ERROR, v43, (uint8_t *)&v85, 0x26u);
          goto LABEL_36;
        }
      }
    }
  }
  return v12;
}

int *___si_mobile_journal_notify_new_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4;
  NSObject *v5;
  int *result;
  int v7;
  uint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v4 = *__error();
  v5 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    v7 = 134217984;
    v8 = a3;
    _os_log_impl(&dword_1B8270000, v5, OS_LOG_TYPE_DEFAULT, "### skg journal_new result %lld", (uint8_t *)&v7, 0xCu);
  }
  result = __error();
  *result = v4;
  return result;
}

void __processOneCS_block_invoke(uint64_t a1, uint64_t a2, unint64_t a3)
{
  BOOL v5;
  _BOOL4 v6;
  const __CFURL *v12;
  const __CFURL *v13;
  const __CFURL *v14;
  const __CFURL *v15;
  CFStringRef v16;
  const __CFString *v17;
  CFStringRef v18;
  CFStringRef v19;
  uint64_t v20;

  if (a3 >= 8)
  {
    v5 = *(_DWORD *)a2 == 1229213035 && *(_DWORD *)(a2 + 3) == 1835365449;
    v6 = !v5;
    if (a3 >= 0xE && !v6)
    {
      if (*(_DWORD *)(a3 + a2 - 7) == 1936876880 && *(_DWORD *)(a3 + a2 - 4) == 1936617331)
        return;
      if (a3 >= 0x11)
      {
        if (*(_QWORD *)(a3 + a2 - 10) == 0x616E6F6974636944 && *(_WORD *)(a3 + a2 - 2) == 31090)
          return;
        if (*(_QWORD *)(a3 + a2 - 10) == 0x69747265706F7250 && *(_WORD *)(a3 + a2 - 2) == 29541)
          return;
        if (a3 >= 0x12)
        {
          if (*(_QWORD *)(a3 + a2 - 11) == 0x746E6F434C4D5448 && *(_QWORD *)(a3 + a2 - 8) == 0x746E65746E6F434CLL)
            return;
          if (a3 >= 0x16
            && *(_QWORD *)(a3 + a2 - 15) == 0x746E6F434C4D5448
            && *(_QWORD *)(a3 + a2 - 8) == 0x61746144746E6574)
          {
            return;
          }
        }
      }
    }
  }
  if (_MDPlistGetPlistObjectType() == 247)
  {
    v12 = (const __CFURL *)_MDPlistContainerCopyObject();
    if (!v12)
      return;
    v13 = v12;
    v14 = CFURLCopyAbsoluteURL(v12);
    if (v14)
    {
      v15 = v14;
      v16 = CFURLGetString(v14);
      v17 = v16 ? (const __CFString *)CFRetain(v16) : 0;
      CFRelease(v15);
    }
    else
    {
      v17 = 0;
    }
    CFRelease(v13);
    if (!v17)
      return;
  }
  else
  {
    v17 = _copyMDPlistObject(*(const __CFAllocator **)(a1 + 40));
    if (!v17)
      return;
  }
  v18 = CFStringCreateWithCStringNoCopy(*(CFAllocatorRef *)(a1 + 40), (const char *)a2, 0x8000100u, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
  if (v18)
  {
    v19 = v18;
    v20 = *(_QWORD *)(a1 + 48);
    if (v20 == CFGetTypeID(v17))
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += CFStringGetLength(v17);
    CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 56), v19, v17);
    CFRelease(v19);
  }
  CFRelease(v17);
}

void __processOneCS_block_invoke_2(uint64_t a1, const char *a2)
{
  CFStringRef v3;
  CFStringRef v4;
  unint64_t IntValue;
  const __CFAllocator *v6;
  CFStringRef v7;
  const __CFString *v8;
  CFTypeID v9;
  _BOOL8 v10;
  unint64_t v11;
  uint64_t v12;
  char v13;
  unint64_t v14;
  const void *v15;

  v3 = CFStringCreateWithCString(*(CFAllocatorRef *)(a1 + 40), a2, 0x8000100u);
  if (v3)
  {
    v4 = v3;
    if (!CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 48), v3)
      && _MDPlistGetPlistObjectType() == 240
      && _MDPlistArrayGetCount() == 2)
    {
      _MDPlistArrayGetPlistObjectAtIndex();
      IntValue = _MDPlistNumberGetIntValue();
      v6 = *(const __CFAllocator **)(a1 + 40);
      _MDPlistArrayGetPlistObjectAtIndex();
      v7 = _copyMDPlistObject(v6);
      if (v7)
      {
        v8 = v7;
        v9 = CFGetTypeID(v7);
        v10 = (IntValue & 3) == 0;
        v11 = IntValue >> 3;
        v12 = ((_DWORD)IntValue << 7) & 0x100;
        v13 = 4 * IntValue;
        v14 = (v12 & 0xFFFFFFFFFFFFFFDFLL | (32 * (v11 & 1)) | (8 * v10)) ^ 0x100;
        if (*(_QWORD *)(a1 + 56) == v9)
        {
          v15 = (const void *)(v14 | v13 & 0x10);
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += CFStringGetLength(v8);
        }
        else if (v9 == CFDictionaryGetTypeID())
        {
          v15 = (const void *)(v14 | v13 & 0x10);
        }
        else
        {
          v15 = (const void *)v14;
        }
        CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 64), v4, v15);
        CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 48), v4, v8);
        CFRelease(v8);
      }
    }
    CFRelease(v4);
  }
}

void si_removeRelatedItem(uint64_t a1, uint64_t *a2, CFStringRef theString, const __CFString *a4, uint64_t a5, const char *a6)
{
  const __CFAllocator *v11;
  CFIndex Length;
  CFIndex v13;
  __CFString *MutableCopy;
  char *v15;
  char *v16;
  size_t v17;
  int field;
  int v19;
  const char *v20;
  CFStringRef v21;
  int v22;
  NSObject *v23;
  BOOL v24;
  const char *v25;
  NSObject *v26;
  os_log_type_t v27;
  uint32_t v28;
  __int16 v29;
  unint64_t v30;
  char *v31;
  size_t v32;
  unint64_t v33;
  char *v34;
  char *v35;
  size_t v36;
  size_t v37;
  size_t v38;
  char *v39;
  uint64_t v40;
  __n128 v41;
  NSObject *v42;
  char *v43;
  char *v44;
  const char *v45;
  char *v46;
  const char *v47;
  uint64_t v48;
  char *v49;
  char *v50;
  const char *v51;
  uint64_t v52;
  int v53;
  const __CFString *v54;
  CFStringRef v55;
  uint64_t v56;
  char *__s1;
  unint64_t v58;
  size_t v59;
  char v60;
  uint8_t buf[4];
  const char *v62;
  __int16 v63;
  CFStringRef v64;
  __int16 v65;
  const __CFString *v66;
  __int16 v67;
  const __CFString *v68;
  _OWORD v69[16];
  uint64_t v70;

  v70 = *MEMORY[0x1E0C80C00];
  if (!a2 || !*a2)
  {
    v46 = __si_assert_copy_extra_521(-1);
    v44 = v46;
    v47 = "";
    if (v46)
      v47 = v46;
    __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 24156, "dbop && *dbop", v47);
LABEL_47:
    free(v44);
    if (__valid_fs(-1))
      v48 = 2989;
    else
      v48 = 3072;
    *(_DWORD *)v48 = -559038737;
    abort();
  }
  memset(v69, 0, sizeof(v69));
  v60 = 0;
  v59 = 0;
  if (a5)
  {
    v11 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    Length = CFStringGetLength(theString);
    v13 = CFStringGetLength(a4);
    MutableCopy = CFStringCreateMutableCopy(v11, Length + v13 + 1, theString);
    CFStringAppend(MutableCopy, CFSTR(":"));
    CFStringAppend(MutableCopy, a4);
    v15 = fasterUTF8String(a4, &v59, (char *)v69, 256, &v60);
    CFRelease(MutableCopy);
    v16 = "_kMDItemRelatedObjectsWithBundle";
  }
  else
  {
    v15 = fasterUTF8String(a4, &v59, (char *)v69, 256, &v60);
    v16 = "_kMDItemRelatedObjects";
  }
  v17 = v59;
  __s1 = 0;
  v58 = 0;
  field = db_get_field(*(int **)(a1 + 1184), *a2, v16, &v58, &__s1);
  if (field)
  {
    v19 = field;
    if (field != 2)
    {
      v20 = a6;
      v21 = theString;
      v22 = *__error();
      v23 = _SILogForLogForCategory(4);
      v24 = dword_1EF19FC9C < 3;
      if (os_log_type_enabled(v23, (os_log_type_t)(dword_1EF19FC9C < 3)))
      {
        *(_DWORD *)buf = 138413058;
        v62 = v20;
        v63 = 2112;
        v64 = v21;
        v65 = 2112;
        v66 = a4;
        v67 = 1024;
        LODWORD(v68) = v19;
        v25 = "*warn* Failed to fetch the dbo for relatedIdentifier:%@, bundleID:%@, identifier:%@, rc:%d";
        v26 = v23;
        v27 = v24;
        v28 = 38;
        goto LABEL_10;
      }
      goto LABEL_11;
    }
    goto LABEL_12;
  }
  v29 = *(_WORD *)(v58 + 2);
  if ((v29 & 0x90) != 0)
  {
    v49 = __si_assert_copy_extra_521(-1);
    v50 = v49;
    v51 = "";
    if (v49)
      v51 = v49;
    __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 24190, "(fieldFlags & (DB_FIELD_UNIQUED_VALS|DB_FIELD_LOCALIZED_STR)) == 0", v51);
    free(v50);
    if (__valid_fs(-1))
      v52 = 2989;
    else
      v52 = 3072;
    *(_DWORD *)v52 = -559038737;
    abort();
  }
  v55 = theString;
  v56 = a1;
  v54 = (const __CFString *)a6;
  v30 = *(unsigned int *)(v58 + 8);
  v31 = __s1;
  if ((v29 & 0x20) == 0)
  {
    v32 = strnlen(__s1, *(unsigned int *)(v58 + 8));
    if (v32 + 1 < v30)
      v33 = v32 + 1;
    else
      v33 = v30;
    if (v17 != v33 || memcmp(v31, v15, v17))
      goto LABEL_12;
LABEL_37:
    v40 = v56;
    db_delete_field(*(int **)(v56 + 1184), a2, v16);
    goto LABEL_38;
  }
  if (!(_DWORD)v30)
    goto LABEL_12;
  v34 = &__s1[v30];
  v35 = __s1;
  while (1)
  {
    v36 = v34 - v35;
    v37 = strnlen(v35, v34 - v35);
    if (v37 + 1 < v34 - v35)
      v36 = v37 + 1;
    if (!v36)
    {
      v43 = __si_assert_copy_extra_521(-1);
      v44 = v43;
      v45 = "";
      if (v43)
        v45 = v43;
      __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 24201, "size", v45);
      goto LABEL_47;
    }
    if (v17 == v36 && !memcmp(v35, v15, v17))
      break;
    v35 += v36;
    if (v35 >= v34)
      goto LABEL_12;
  }
  if (v17 >= v30)
    goto LABEL_37;
  if (v30 >= v17)
    v38 = v30 - v17;
  else
    v38 = 0;
  v53 = v38;
  v39 = (char *)malloc_type_malloc(v38, 0xF0C60941uLL);
  memcpy(v39, v31, v35 - v31);
  memcpy(&v39[v35 - v31], &v35[v17], v34 - &v35[v17]);
  v40 = v56;
  db_add_field(*(int **)(v56 + 1184), (_DWORD **)a2, 1u, v16, 0, 0x2120u, 11, (unsigned __int8 *)v39, v41, v53);
  free(v39);
LABEL_38:
  db_update_obj(*(int **)(v40 + 1184), *a2, 3);
  if (dword_1EF19FC9C >= 5)
  {
    v22 = *__error();
    v42 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315906;
      v62 = "_kMDItemRelatedObjects";
      v63 = 2112;
      v64 = v54;
      v65 = 2112;
      v66 = v55;
      v67 = 2112;
      v68 = a4;
      v25 = "Updated \"%s\" field for relatedIdentifier:%@, bundleID:%@, identifier:%@";
      v26 = v42;
      v27 = OS_LOG_TYPE_DEFAULT;
      v28 = 42;
LABEL_10:
      _os_log_impl(&dword_1B8270000, v26, v27, v25, buf, v28);
    }
LABEL_11:
    *__error() = v22;
  }
LABEL_12:
  if (v60)
    free(v15);
}

BOOL BOOLValueForDBOProperty(int *a1, uint64_t a2)
{
  unint64_t v3;
  _BYTE *v4;

  v3 = 0;
  v4 = 0;
  return !db_get_field(a1, a2, "_kMDItemIsZombie", &v3, &v4) && *v4 != 0;
}

uint64_t changesExistingSyndicationAttributes(uint64_t a1, uint64_t a2, CFDictionaryRef theDict)
{
  const __CFNumber *Value;
  const __CFNumber *v7;
  CFTypeID TypeID;
  const __CFNumber *v9;
  const __CFNumber *v10;
  CFTypeID v11;
  uint64_t result;
  const __CFBoolean *v13;
  CFTypeID v14;
  int v15;
  unsigned __int8 *valuePtr;
  unsigned __int8 **v17;
  unint64_t v18;

  v17 = 0;
  v18 = 0;
  Value = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("com_apple_mobilesms_isHighlightedContent"));
  if (Value)
  {
    v7 = Value;
    TypeID = CFNumberGetTypeID();
    if (TypeID == CFGetTypeID(v7))
    {
      if (!db_get_field(*(int **)(a1 + 1184), a2, "com_apple_mobilesms_isHighlightedContent", &v18, &v17))
      {
        valuePtr = 0;
        if (CFNumberGetValue(v7, kCFNumberSInt64Type, &valuePtr))
        {
          if (v17 && *v17 != valuePtr)
            return 1;
        }
      }
      v17 = 0;
    }
  }
  v9 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("kMDItemSyndicationStatus"));
  if (v9)
  {
    v10 = v9;
    v11 = CFNumberGetTypeID();
    if (v11 == CFGetTypeID(v10)
      && !db_get_field(*(int **)(a1 + 1184), a2, "kMDItemSyndicationStatus", &v18, &v17))
    {
      valuePtr = 0;
      if (CFNumberGetValue(v10, kCFNumberSInt64Type, &valuePtr))
      {
        if (v17 && *v17 != valuePtr)
          return 1;
      }
    }
  }
  valuePtr = 0;
  result = (uint64_t)CFDictionaryGetValue(theDict, CFSTR("com_apple_mobilesms_isChatAutoDonating"));
  if (result)
  {
    v13 = (const __CFBoolean *)result;
    v14 = CFBooleanGetTypeID();
    if (v14 == CFGetTypeID(v13)
      && !db_get_field(*(int **)(a1 + 1184), a2, "com_apple_mobilesms_isChatAutoDonating", &v18, &valuePtr))
    {
      v15 = CFBooleanGetValue(v13);
      if (valuePtr)
      {
        if (*valuePtr != v15)
          return 1;
      }
    }
    return 0;
  }
  return result;
}

CFDateRef SICopyRoundedDate()
{
  double v0;

  v0 = MEMORY[0x1BCCAF690]();
  return CFDateCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (double)(86400 * ((unint64_t)v0 / 0x15180)));
}

void __processOneCS_block_invoke_1133(uint64_t a1, CFArrayRef theArray, uint64_t a3)
{
  CFIndex v5;
  const __CFAllocator *v6;
  const __CFNumber *ValueAtIndex;
  CFNumberRef v8;
  uint64_t v9;
  const __CFAllocator *v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  const __CFArray *v14;
  uint64_t v15;
  CFIndex v16;
  const __CFNumber *v17;
  CFNumberRef v18;
  uint64_t valuePtr;

  if (a3 == 4)
  {
    v5 = 0;
    v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    do
    {
      valuePtr = 0;
      ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(theArray, v5);
      CFNumberGetValue(ValueAtIndex, kCFNumberSInt64Type, &valuePtr);
      if (valuePtr)
      {
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) |= 1 << *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8)
                                                                                        + 24);
        v8 = CFNumberCreate(v6, kCFNumberSInt64Type, &valuePtr);
        CFArrayAppendValue(*(CFMutableArrayRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24), v8);
        CFRelease(v8);
      }
      v9 = *(_QWORD *)(a1 + 40);
      if (*(_BYTE *)(a1 + 80))
      {
        if (((*(_QWORD *)(a1 + 64) >> *(_DWORD *)(*(_QWORD *)(v9 + 8) + 24)) & 1) != 0)
        {
          ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24);
          v9 = *(_QWORD *)(a1 + 40);
        }
      }
      ++*(_DWORD *)(*(_QWORD *)(v9 + 8) + 24);
      ++v5;
    }
    while (v5 != 4);
  }
  else if (*(_BYTE *)(a1 + 80))
  {
    v10 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v11 = 4;
    do
    {
      v12 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
      v13 = *(_DWORD *)(v12 + 24);
      if (((1 << v13) & *(_QWORD *)(a1 + 64)) != 0)
      {
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) |= 1 << v13;
        valuePtr = 0;
        v14 = *(const __CFArray **)(a1 + 72);
        v15 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8);
        v16 = *(int *)(v15 + 24);
        *(_DWORD *)(v15 + 24) = v16 + 1;
        v17 = (const __CFNumber *)CFArrayGetValueAtIndex(v14, v16);
        CFNumberGetValue(v17, kCFNumberSInt64Type, &valuePtr);
        v18 = CFNumberCreate(v10, kCFNumberSInt64Type, &valuePtr);
        CFArrayAppendValue(*(CFMutableArrayRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24), v18);
        CFRelease(v18);
        v12 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
        v13 = *(_DWORD *)(v12 + 24);
      }
      *(_DWORD *)(v12 + 24) = v13 + 1;
      --v11;
    }
    while (v11);
  }
  else
  {
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) += 4;
  }
}

CFMutableStringRef safeCFStringCopy(const __CFString *a1)
{
  const __CFAllocator *v2;
  CFIndex Length;

  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Length = CFStringGetLength(a1);
  return CFStringCreateMutableCopy(v2, Length, a1);
}

void updatedRelatedPersons(uint64_t a1, const __CFArray *a2, const __CFArray *a3, uint64_t a4, const void *a5)
{
  unint64_t v10;
  unint64_t v11;
  CFDateRef v12;
  __CFBag **v13;
  __CFBag *Mutable;
  __CFBag **v15;
  __CFBag *v16;
  __CFBag *v17;
  CFIndex Count;
  CFIndex v19;
  CFIndex v20;
  const __CFString *ValueAtIndex;
  CFTypeID v22;
  CFIndex Length;
  CFMutableStringRef MutableCopy;
  const __CFDate *Value;
  CFIndex v26;
  CFIndex v27;
  CFIndex v28;
  const __CFString *v29;
  CFTypeID v30;
  CFIndex v31;
  CFMutableStringRef v32;
  const __CFDate *v33;
  const __CFArray *v34;
  __CFBag *v35;
  const __CFAllocator *allocator;

  v10 = 86400 * ((unint64_t)CFAbsoluteTimeGetCurrent() / 0x15180);
  v11 = (unint64_t)MEMORY[0x1BCCAF690](a4);
  allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v12 = CFDateCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (double)v11);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 328));
  if (CFEqual(a5, CFSTR("com.apple.mobilemail")))
  {
    v13 = (__CFBag **)(a1 + 400);
  }
  else if (CFEqual(a5, CFSTR("com.apple.MobileSMS")))
  {
    v13 = (__CFBag **)(a1 + 464);
  }
  else if (CFEqual(a5, CFSTR("com.apple.mobilecal")))
  {
    v13 = (__CFBag **)(a1 + 528);
  }
  else if (CFEqual(a5, CFSTR("com.apple.CloudDocs.iCloudDriveFileProvider"))
         || CFEqual(a5, CFSTR("com.apple.CloudDocs.iCloudDriveFileProviderManaged"))
         || CFEqual(a5, CFSTR("com.apple.CloudDocs.MobileDocumentsFileProvider")))
  {
    v13 = (__CFBag **)(a1 + 592);
  }
  else
  {
    v13 = 0;
  }
  v34 = a3;
  if (v10 <= v11)
  {
    Mutable = *(__CFBag **)(a1 + 336);
    if (!Mutable)
    {
      Mutable = CFBagCreateMutable(allocator, 0, MEMORY[0x1E0C9B388]);
      *(_QWORD *)(a1 + 336) = Mutable;
    }
    v35 = *(__CFBag **)(a1 + 368);
    if (v35)
    {
      if (!v13)
        goto LABEL_54;
    }
    else
    {
      v35 = CFBagCreateMutable(allocator, 0, MEMORY[0x1E0C9B388]);
      *(_QWORD *)(a1 + 368) = v35;
      Mutable = *(__CFBag **)(a1 + 336);
      if (!v13)
        goto LABEL_54;
    }
    v16 = *v13;
    if (!*v13)
    {
      v16 = CFBagCreateMutable(allocator, 0, MEMORY[0x1E0C9B388]);
      *v13 = v16;
    }
    v17 = v13[4];
    if (!v17)
    {
      v17 = CFBagCreateMutable(allocator, 0, MEMORY[0x1E0C9B388]);
      v13[4] = v17;
LABEL_53:
      v16 = *v13;
      goto LABEL_55;
    }
    goto LABEL_55;
  }
  if (v11 + 604800 >= v10)
  {
    Mutable = *(__CFBag **)(a1 + 344);
    if (!Mutable)
    {
      Mutable = CFBagCreateMutable(allocator, 0, MEMORY[0x1E0C9B388]);
      *(_QWORD *)(a1 + 344) = Mutable;
    }
    v35 = *(__CFBag **)(a1 + 376);
    if (v35)
    {
      if (!v13)
        goto LABEL_54;
    }
    else
    {
      v35 = CFBagCreateMutable(allocator, 0, MEMORY[0x1E0C9B388]);
      *(_QWORD *)(a1 + 376) = v35;
      Mutable = *(__CFBag **)(a1 + 344);
      if (!v13)
        goto LABEL_54;
    }
    v15 = v13 + 1;
    v16 = v13[1];
    if (!v16)
    {
      v16 = CFBagCreateMutable(allocator, 0, MEMORY[0x1E0C9B388]);
      *v15 = v16;
    }
    v17 = v13[5];
    if (!v17)
    {
      v17 = CFBagCreateMutable(allocator, 0, MEMORY[0x1E0C9B388]);
      v13[5] = v17;
      goto LABEL_52;
    }
    goto LABEL_55;
  }
  if (v11 + 2592000 < v10)
  {
    Mutable = *(__CFBag **)(a1 + 360);
    if (!Mutable)
    {
      Mutable = CFBagCreateMutable(allocator, 0, MEMORY[0x1E0C9B388]);
      *(_QWORD *)(a1 + 360) = Mutable;
    }
    v35 = *(__CFBag **)(a1 + 392);
    if (!v35)
    {
      v35 = CFBagCreateMutable(allocator, 0, MEMORY[0x1E0C9B388]);
      *(_QWORD *)(a1 + 392) = v35;
      Mutable = *(__CFBag **)(a1 + 360);
    }
    if (v13)
    {
      v15 = v13 + 3;
      v16 = v13[3];
      if (!v16)
      {
        v16 = CFBagCreateMutable(allocator, 0, MEMORY[0x1E0C9B388]);
        *v15 = v16;
      }
      v17 = v13[7];
      if (!v17)
      {
        v17 = CFBagCreateMutable(allocator, 0, MEMORY[0x1E0C9B388]);
        v13[7] = v17;
LABEL_52:
        v13 = v15;
        goto LABEL_53;
      }
      goto LABEL_55;
    }
LABEL_54:
    v16 = 0;
    v17 = 0;
    goto LABEL_55;
  }
  Mutable = *(__CFBag **)(a1 + 352);
  if (!Mutable)
  {
    Mutable = CFBagCreateMutable(allocator, 0, MEMORY[0x1E0C9B388]);
    *(_QWORD *)(a1 + 352) = Mutable;
  }
  v35 = *(__CFBag **)(a1 + 384);
  if (!v35)
  {
    v35 = CFBagCreateMutable(allocator, 0, MEMORY[0x1E0C9B388]);
    *(_QWORD *)(a1 + 384) = v35;
    Mutable = *(__CFBag **)(a1 + 352);
  }
  if (!v13)
    goto LABEL_54;
  v15 = v13 + 2;
  v16 = v13[2];
  if (!v16)
  {
    v16 = CFBagCreateMutable(allocator, 0, MEMORY[0x1E0C9B388]);
    *v15 = v16;
  }
  v17 = v13[6];
  if (!v17)
  {
    v17 = CFBagCreateMutable(allocator, 0, MEMORY[0x1E0C9B388]);
    v13[6] = v17;
    goto LABEL_52;
  }
LABEL_55:
  if (a2)
  {
    Count = CFArrayGetCount(a2);
    if ((unint64_t)(Count - 1) <= 3)
    {
      v19 = Count;
      v20 = 0;
      do
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a2, v20);
        v22 = CFGetTypeID(ValueAtIndex);
        if (v22 == CFStringGetTypeID())
        {
          Length = CFStringGetLength(ValueAtIndex);
          MutableCopy = CFStringCreateMutableCopy(allocator, Length, ValueAtIndex);
          CFBagAddValue(Mutable, MutableCopy);
          if (v16)
            CFBagAddValue(v16, MutableCopy);
          Value = (const __CFDate *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 656), MutableCopy);
          if (!Value || CFDateCompare(v12, Value, 0) == kCFCompareGreaterThan)
            CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 656), MutableCopy, v12);
          CFRelease(MutableCopy);
        }
        ++v20;
      }
      while (v19 != v20);
    }
  }
  if (v34)
  {
    v26 = CFArrayGetCount(v34);
    if ((unint64_t)(v26 - 1) <= 3)
    {
      v27 = v26;
      v28 = 0;
      do
      {
        v29 = (const __CFString *)CFArrayGetValueAtIndex(v34, v28);
        v30 = CFGetTypeID(v29);
        if (v30 == CFStringGetTypeID())
        {
          v31 = CFStringGetLength(v29);
          v32 = CFStringCreateMutableCopy(allocator, v31, v29);
          CFBagAddValue(v35, v32);
          if (v17)
            CFBagAddValue(v17, v32);
          v33 = (const __CFDate *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 656), v32);
          if (!v33 || CFDateCompare(v12, v33, 0) == kCFCompareGreaterThan)
            CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 656), v32, v12);
          CFRelease(v32);
        }
        ++v28;
      }
      while (v27 != v28);
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 328));
  CFRelease(v12);
}

CFStringRef CopyUserTag(const __CFString *a1)
{
  CFRange v2;
  CFRange v4;

  v2 = CFStringFind(a1, CFSTR("\n"), 0);
  if (v2.length)
  {
    v4.length = v2.location;
    v4.location = 0;
    return CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a1, v4);
  }
  else
  {
    if (a1)
      CFRetain(a1);
    return a1;
  }
}

void generateLocalPartsWithNewFieldName(uint64_t a1, const void *a2, const __CFString *cf)
{
  CFTypeID v6;
  const __CFAllocator *v7;
  CFIndex Count;
  __CFArray *Mutable;
  CFIndex v10;
  CFIndex v11;
  CFIndex i;
  const __CFString *ValueAtIndex;
  CFStringRef v14;
  CFStringRef v15;
  uint64_t v16;
  const void *v17;
  const void *v18;
  CFStringRef v19;

  v6 = CFGetTypeID(cf);
  if (v6 != CFArrayGetTypeID())
  {
    v19 = copyLocalPartFromEmailAddress(cf);
    if (!v19)
      return;
    v18 = v19;
    v16 = a1;
    v17 = a2;
    goto LABEL_11;
  }
  v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Count = CFArrayGetCount((CFArrayRef)cf);
  Mutable = CFArrayCreateMutable(v7, Count, MEMORY[0x1E0C9B378]);
  v10 = CFArrayGetCount((CFArrayRef)cf);
  if (v10 >= 1)
  {
    v11 = v10;
    for (i = 0; i != v11; ++i)
    {
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)cf, i);
      v14 = copyLocalPartFromEmailAddress(ValueAtIndex);
      if (v14)
      {
        v15 = v14;
        CFArrayAppendValue(Mutable, v14);
        CFRelease(v15);
      }
    }
  }
  if (CFArrayGetCount(Mutable))
  {
    v16 = a1;
    v17 = a2;
    v18 = Mutable;
LABEL_11:
    InsertPreProcessContextAddAttr(v16, v17, v18, 0);
    return;
  }
  CFRelease(Mutable);
}

void __postPreprocess_block_invoke_2(uint64_t a1, const __CFArray *a2)
{
  CFTypeID TypeID;
  __CFArray *v5;
  CFTypeID v6;
  CFRange v7;

  TypeID = CFArrayGetTypeID();
  if (TypeID == CFGetTypeID(a2))
  {
    v5 = *(__CFArray **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
    v7.length = CFArrayGetCount(a2);
    v7.location = 0;
    CFArrayAppendArray(v5, a2, v7);
  }
  else
  {
    v6 = CFStringGetTypeID();
    if (v6 == CFGetTypeID(a2))
      CFArrayAppendValue(*(CFMutableArrayRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24), a2);
  }
}

CFStringRef copyLocalPartFromEmailAddress(const __CFString *a1)
{
  CFTypeID TypeID;
  CFIndex Length;
  const UniChar *CharactersPtr;
  const char *CStringPtr;
  uint64_t v6;
  CFIndex v7;
  CFIndex v8;
  uint64_t i;
  uint64_t v10;
  CFIndex v11;
  UniChar v12;
  uint64_t v14;
  uint64_t v15;
  CFIndex v16;
  CFIndex v17;
  _OWORD v19[8];
  CFStringRef theString;
  const UniChar *v21;
  const char *v22;
  uint64_t v23;
  CFIndex v24;
  CFIndex v25;
  CFIndex v26;
  CFRange v27;
  CFRange v28;

  TypeID = CFStringGetTypeID();
  if (TypeID != CFGetTypeID(a1))
    return 0;
  memset(v19, 0, sizeof(v19));
  Length = CFStringGetLength(a1);
  theString = a1;
  v23 = 0;
  v24 = Length;
  CharactersPtr = CFStringGetCharactersPtr(a1);
  CStringPtr = 0;
  v21 = CharactersPtr;
  if (!CharactersPtr)
    CStringPtr = CFStringGetCStringPtr(a1, 0x600u);
  v25 = 0;
  v26 = 0;
  v22 = CStringPtr;
  if (Length < 1)
    return 0;
  v6 = 0;
  v7 = 0;
  v8 = 0;
  for (i = 64; ; ++i)
  {
    v10 = (unint64_t)v8 >= 4 ? 4 : v8;
    v11 = v24;
    if (v24 > v8)
    {
      if (v21)
      {
        v12 = v21[v8 + v23];
      }
      else if (v22)
      {
        v12 = v22[v23 + v8];
      }
      else
      {
        if (v26 <= v8 || v7 > v8)
        {
          v14 = v10 + v6;
          v15 = i - v10;
          v16 = v8 - v10;
          v17 = v16 + 64;
          if (v16 + 64 >= v24)
            v17 = v24;
          v25 = v16;
          v26 = v17;
          if (v24 >= v15)
            v11 = v15;
          v27.length = v11 + v14;
          v27.location = v16 + v23;
          CFStringGetCharacters(theString, v27, (UniChar *)v19);
          v7 = v25;
        }
        v12 = *((_WORD *)v19 + v8 - v7);
      }
      if (v12 == 64)
        break;
    }
    ++v8;
    --v6;
    if (Length == v8)
      return 0;
  }
  if (!v8)
    return 0;
  v28.location = 0;
  v28.length = v8;
  return CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a1, v28);
}

CFArrayRef __postPreprocess_block_invoke()
{
  const __CFAllocator *v0;
  CFArrayRef result;
  const void *v2[2];

  v2[1] = *(const void **)MEMORY[0x1E0C80C00];
  v0 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v2[0] = CFSTR("MDSystemFile");
  result = CFArrayCreate(v0, v2, 1, MEMORY[0x1E0C9B378]);
  postPreprocess_arrSystemFile = (uint64_t)result;
  return result;
}

void _InsertPreProcessContextAddDateAttr(uint64_t a1, __CFString *a2, const void *a3, uint64_t a4, uint64_t a5)
{
  double v10;
  CFAllocatorRef *v11;
  double v12;
  CFDateRef v13;
  uint64_t v14;
  const void *v15;
  CFCalendarRef *v16;
  const __CFAllocator *v17;
  CFNumberRef v18;
  CFNumberRef v19;
  CFStringRef v20;
  CFNumberRef v21;
  CFNumberRef v22;
  CFStringRef v23;
  CFNumberRef v24;
  CFNumberRef v25;
  CFStringRef v26;
  CFNumberRef v27;
  CFNumberRef v28;
  CFStringRef v29;
  CFNumberRef v30;
  CFNumberRef v31;
  CFStringRef v32;
  CFNumberRef v33;
  CFNumberRef v34;
  CFStringRef v35;
  CFNumberRef v36;
  CFNumberRef v37;
  CFStringRef v38;
  CFNumberRef v39;
  CFNumberRef v40;
  CFStringRef v41;
  uint64_t v42;
  uint64_t v43;
  __int128 valuePtr;
  _OWORD v45[2];

  v10 = MEMORY[0x1BCCAF690](a3);
  InsertPreProcessContextAddAttr(a1, a2, a3, 1);
  v11 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
  if (a2 == CFSTR("kMDItemEndDate")
    || a2 == CFSTR("kMDItemStartDate")
    || a2 == CFSTR("kMDItemContentCreationDate")
    || a2 == CFSTR("kMDItemContentModificationDate"))
  {
    v42 = a4;
    v43 = a5;
    valuePtr = 0u;
    v45[0] = 0u;
    v16 = (CFCalendarRef *)si_retain_calendar();
    CFCalendarDecomposeAbsoluteTime(v16[1], v10, "HdyMEFWw", &valuePtr, (char *)&valuePtr + 4, (unint64_t)&valuePtr | 0xC, (char *)&valuePtr + 8, v45, (char *)v45 + 4, (char *)v45 + 8, (char *)v45 + 12);
    OSAtomicEnqueue(&sCalenderQueueHead, v16, 0);
    v17 = *v11;
    v18 = CFNumberCreate(*v11, kCFNumberSInt32Type, &valuePtr);
    if (v18)
    {
      v19 = v18;
      v20 = CFStringCreateWithFormat(v17, 0, CFSTR("_%@%@"), a2, CFSTR("Hour"));
      InsertPreProcessContextAddAttr(a1, v20, v19, 0);
      CFRelease(v20);
    }
    v21 = CFNumberCreate(v17, kCFNumberSInt32Type, (char *)&valuePtr + 4);
    if (v21)
    {
      v22 = v21;
      v23 = CFStringCreateWithFormat(v17, 0, CFSTR("_%@%@"), a2, CFSTR("Day"));
      InsertPreProcessContextAddAttr(a1, v23, v22, 0);
      CFRelease(v23);
    }
    v24 = CFNumberCreate(v17, kCFNumberSInt32Type, (char *)&valuePtr + 8);
    v11 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
    if (v24)
    {
      v25 = v24;
      v26 = CFStringCreateWithFormat(v17, 0, CFSTR("_%@%@"), a2, CFSTR("Month"));
      InsertPreProcessContextAddAttr(a1, v26, v25, 0);
      CFRelease(v26);
    }
    v27 = CFNumberCreate(v17, kCFNumberSInt32Type, (const void *)((unint64_t)&valuePtr | 0xC));
    if (v27)
    {
      v28 = v27;
      v29 = CFStringCreateWithFormat(v17, 0, CFSTR("_%@%@"), a2, CFSTR("Year"));
      InsertPreProcessContextAddAttr(a1, v29, v28, 0);
      CFRelease(v29);
    }
    v30 = CFNumberCreate(v17, kCFNumberSInt32Type, v45);
    if (v30)
    {
      v31 = v30;
      v32 = CFStringCreateWithFormat(v17, 0, CFSTR("_%@%@"), a2, CFSTR("Weekday"));
      InsertPreProcessContextAddAttr(a1, v32, v31, 0);
      CFRelease(v32);
    }
    v33 = CFNumberCreate(v17, kCFNumberSInt32Type, (char *)v45 + 4);
    if (v33)
    {
      v34 = v33;
      v35 = CFStringCreateWithFormat(v17, 0, CFSTR("_%@%@"), a2, CFSTR("WeekdayOrdinal"));
      InsertPreProcessContextAddAttr(a1, v35, v34, 0);
      CFRelease(v35);
    }
    v36 = CFNumberCreate(v17, kCFNumberSInt32Type, (char *)v45 + 8);
    if (v36)
    {
      v37 = v36;
      v38 = CFStringCreateWithFormat(v17, 0, CFSTR("_%@%@"), a2, CFSTR("WeekOfMonth"));
      InsertPreProcessContextAddAttr(a1, v38, v37, 0);
      CFRelease(v38);
    }
    v39 = CFNumberCreate(v17, kCFNumberSInt32Type, (char *)v45 + 12);
    if (v39)
    {
      v40 = v39;
      v41 = CFStringCreateWithFormat(v17, 0, CFSTR("_%@%@"), a2, CFSTR("WeekOfYear"));
      InsertPreProcessContextAddAttr(a1, v41, v40, 0);
      CFRelease(v41);
    }
    a5 = v43;
    if (v42)
      goto LABEL_6;
  }
  else if (a4)
  {
LABEL_6:
    v12 = MEMORY[0x1BCCAF690](a3);
    v13 = CFDateCreate(*v11, (double)(86400 * ((unint64_t)v12 / 0x15180)));
    InsertPreProcessContextAddAttr(a1, CFSTR("kMDItemContentCreationDate_Ranking"), v13, 0);
  }
  if (a5)
  {
    v14 = *(_QWORD *)(a1 + 288);
    if (v14 < a5 || v14 == a5 && MEMORY[0x1BCCAF690](*(_QWORD *)(a1 + 280)) < v10)
    {
      v15 = *(const void **)(a1 + 280);
      if (v15)
        CFRelease(v15);
      *(_QWORD *)(a1 + 280) = 0;
      *(_QWORD *)(a1 + 280) = CFRetain(a3);
      *(_QWORD *)(a1 + 288) = a5;
    }
  }
}

void InsertPreProcessContextAddLocAttr(uint64_t a1, CFTypeRef cf, CFTypeRef a3, int a4)
{
  CFTypeRef v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  CFStringRef v11;

  if (*(_QWORD *)(a1 + 184) >= *(_QWORD *)(a1 + 192))
  {
    if (SIIsAppleInternal_onceToken != -1)
      dispatch_once(&SIIsAppleInternal_onceToken, &__block_literal_global_4644);
    if (SIIsAppleInternal_internal)
    {
      do
        v10 = __ldxr((unsigned int *)&InsertPreProcessContextAddLocAttr__crashCount);
      while (__stxr(v10 + 1, (unsigned int *)&InsertPreProcessContextAddLocAttr__crashCount));
      if (!v10)
      {
        v11 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("localized attr count %d exceeded %d"), *(_QWORD *)(a1 + 184), *(_QWORD *)(a1 + 192));
        getpid();
        SISimulateCrashForPid(0, (uint64_t)v11);
        if (v11)
          CFRelease(v11);
      }
    }
    *(_DWORD *)(a1 + 28) = 22;
  }
  else
  {
    v7 = CFRetain(cf);
    v8 = *(_QWORD *)(a1 + 184);
    *(_QWORD *)(*(_QWORD *)(a1 + 168) + 8 * v8) = v7;
    if (a4)
    {
      a3 = CFRetain(a3);
      v8 = *(_QWORD *)(a1 + 184);
    }
    v9 = *(_QWORD *)(a1 + 176);
    *(_QWORD *)(a1 + 184) = v8 + 1;
    *(_QWORD *)(v9 + 8 * v8) = a3;
  }
}

CFSetRef __preProcess_block_invoke()
{
  CFSetRef result;
  _OWORD v1[2];
  uint64_t v2;

  v2 = *MEMORY[0x1E0C80C00];
  v1[0] = xmmword_1E6E2DEE0;
  v1[1] = *(_OWORD *)off_1E6E2DEF0;
  result = CFSetCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)v1, 4, MEMORY[0x1E0C9B3B0]);
  preProcess_localizeFieldNames = (uint64_t)result;
  return result;
}

void ___copyMDPlistObject_block_invoke_2(uint64_t a1, const char *a2, uint64_t a3, __int128 *a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const void *v9;
  CFStringRef v10;
  CFStringRef v11;
  __int128 v12;
  uint64_t v13;

  v6 = *(_QWORD *)(a1 + 32);
  v7 = *(_QWORD *)(a1 + 40);
  v12 = *a4;
  v13 = *((_QWORD *)a4 + 2);
  v8 = _copyMDPlistObject(v6, &v12, v7);
  if (v8)
  {
    v9 = (const void *)v8;
    v10 = CFStringCreateWithCStringNoCopy(*(CFAllocatorRef *)(a1 + 32), a2, 0x8000100u, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
    if (v10)
    {
      v11 = v10;
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 48), v10, v9);
      CFRelease(v11);
    }
    CFRelease(v9);
  }
}

void __setCSAttributes2_block_invoke(uint64_t a1)
{
  unsigned int v2;
  int v3;
  unint64_t v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  void (*v10)(_QWORD);
  uint64_t v11;
  int v12;
  NSObject *v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  __int128 v17;
  unint64_t v18;
  int *v19;
  uint64_t v20;
  const __CFString *v21;
  uint64_t v22;
  uint64_t v23;
  NSObject *v24;
  uint64_t v25;
  size_t v26;
  int v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  unsigned int v31;
  uint64_t v32;
  int v33;
  void (*v34)(_QWORD);
  unint64_t v35[513];
  int v36;
  __int128 v37;
  int v38;
  int v39;
  _QWORD v40[7];
  __int128 v41;
  uint64_t v42;
  __int128 v43;
  int v44;
  unsigned int v45;
  char v46;
  __int128 v47;
  uint64_t v48;
  unsigned int v49;
  unsigned int v50;
  unsigned int v51;
  unsigned int v52;
  unsigned int v53;
  unsigned int v54;
  unsigned int v55;
  unsigned int v56;
  _BYTE v57[24];
  _BYTE buf[24];
  char v59;
  uint64_t v60;

  v60 = *MEMORY[0x1E0C80C00];
  do
  {
    v2 = __ldxr(exceptionSequenceNum);
    v3 = v2 + 1;
  }
  while (__stxr(v2 + 1, exceptionSequenceNum));
  v4 = setThreadIdAndInfo(-1, (__int128 *)sJournalCtxExceptionCallbacks, *(_QWORD *)(a1 + 32), 0x40000000, v3);
  v55 = HIDWORD(v4);
  v56 = v4;
  v53 = v6;
  v54 = v5;
  v7 = *(_QWORD *)&threadData[18 * v4 + 2];
  v8 = v7 + 320 * HIDWORD(v4);
  *(_BYTE *)(v8 + 216) = 0;
  v9 = *(_DWORD *)(v8 + 312);
  v10 = *(void (**)(_QWORD))(v8 + 224);
  if (v10)
    v10(*(_QWORD *)(v7 + 320 * HIDWORD(v4) + 288));
  v52 = v56;
  v51 = v55;
  v50 = v54;
  v49 = v53;
  v11 = _setjmp((int *)v8);
  if ((_DWORD)v11)
  {
    v12 = *__error();
    v13 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "setCSAttributes2_block_invoke";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 27813;
      _os_log_error_impl(&dword_1B8270000, v13, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
    }
    *__error() = v12;
    *(_DWORD *)(v8 + 312) = v9;
    CIOnThreadCleanUpReset(v49);
    dropThreadId(v52, 1, v3);
    CICleanUpReset(v52, v50);
  }
  else
  {
    if (gCPUCount <= 1)
      v14 = 1;
    else
      v14 = gCPUCount;
    v15 = *(_DWORD *)(a1 + 80);
    if (v14 >= v15)
      v14 = *(_DWORD *)(a1 + 80);
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    if (v14 >= 0x10)
      v16 = 16;
    else
      v16 = v14;
    *(_QWORD *)&buf[16] = 0x2000000000;
    v59 = 0;
    v38 = v9;
    v39 = v3;
    if ((_DWORD)v16 == 1)
    {
      MEMORY[0x1E0C80A78](v11);
      bzero(v35, 0x1000uLL);
      _SIStackAllocatorCreate(v35, 4096, indexingZone);
      if (*(_DWORD *)(a1 + 80))
      {
        v18 = 0;
        v19 = (int *)&unk_1EF19F000;
        *(_QWORD *)&v17 = 138412546;
        v37 = v17;
        do
        {
          if (!v35[3])
            v35[1] = (v35[0] + 55) & 0xFFFFFFFFFFFFFFF0;
          v47 = 0uLL;
          v48 = 0;
          *(_OWORD *)v57 = *(_OWORD *)(a1 + 40);
          *(_QWORD *)&v57[16] = *(_QWORD *)(a1 + 56);
          _MDPlistArrayGetPlistObjectAtIndex();
          *(_OWORD *)v57 = v47;
          *(_QWORD *)&v57[16] = v48;
          v20 = _MDPlistContainerCopyObject();
          if (v20)
          {
            v21 = (const __CFString *)v20;
            if (v19[807] >= 5)
            {
              v36 = *__error();
              v24 = _SILogForLogForCategory(4);
              if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
              {
                v25 = *(_QWORD *)(a1 + 64);
                *(_DWORD *)v57 = v37;
                *(_QWORD *)&v57[4] = v25;
                *(_WORD *)&v57[12] = 2112;
                *(_QWORD *)&v57[14] = v21;
                _os_log_impl(&dword_1B8270000, v24, OS_LOG_TYPE_DEFAULT, "Index delete bundleID:%@, identifier:%@", v57, 0x16u);
              }
              *__error() = v36;
              v19 = (_DWORD *)&unk_1EF19F000;
            }
            *(_QWORD *)v57 = 0;
            if (!si_get_object_for_identifier_createParentDBO(*(_QWORD *)(a1 + 72), *(const __CFString **)(a1 + 64), v21, 0, 0, (unint64_t *)v57, 0, 0))
            {
              v22 = *(_QWORD *)(a1 + 72);
              _si_delete_attributes_inner(v22, *(unint64_t *)v57, *(unsigned __int8 *)(a1 + 84), 0, 0, 0, (_BYTE *)(*(_QWORD *)&buf[8] + 24));
              v23 = v22;
              v19 = (_DWORD *)&unk_1EF19F000;
              si_finish_text_store_deletions(v23);
            }
            CFRelease(v21);
          }
          ++v18;
        }
        while (v18 < *(unsigned int *)(a1 + 80));
      }
    }
    else
    {
      v26 = v16;
      v27 = v16;
      *(_QWORD *)&v47 = 0;
      v28 = *(_QWORD *)(a1 + 32);
      if (v27)
        v29 = *(_DWORD *)(*(_QWORD *)v28 + 32);
      else
        v29 = -1;
      v40[0] = MEMORY[0x1E0C809B0];
      v40[1] = 0x40000000;
      v40[2] = __setCSAttributes2_block_invoke_1379;
      v40[3] = &unk_1E6E2E000;
      v40[5] = v28;
      v40[6] = &v47;
      v44 = v29;
      v45 = v15;
      v41 = *(_OWORD *)(a1 + 40);
      v42 = *(_QWORD *)(a1 + 56);
      v43 = *(_OWORD *)(a1 + 64);
      v46 = *(_BYTE *)(a1 + 84);
      v40[4] = buf;
      dispatch_apply(v26, 0, v40);
    }
    if (*(_BYTE *)(*(_QWORD *)&buf[8] + 24) && CFEqual(*(CFTypeRef *)(a1 + 64), CFSTR("com.apple.MobileSMS")))
      notify_post("com.apple.spotlight.SyndicatedContentDeleted");
    v30 = *(_QWORD *)&threadData[18 * v52 + 2];
    v31 = v51;
    v32 = v30 + 320 * v51;
    v33 = v39;
    *(_DWORD *)(v32 + 312) = v38;
    v34 = *(void (**)(_QWORD))(v32 + 232);
    if (v34)
      v34(*(_QWORD *)(v30 + 320 * v31 + 288));
    dropThreadId(v52, 0, v33);
    _Block_object_dispose(buf, 8);
  }
}

void __setCSAttributes2_block_invoke_1382(uint64_t a1)
{
  uint64_t v1;
  unsigned int v2;
  int8x16_t v3;
  __int128 v4;
  uint64_t v5;
  _QWORD v6[4];
  int8x16_t v7;
  __int128 v8;
  uint64_t v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;
  unsigned int v16;
  __int16 v17;
  __int128 v18;
  int v19;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = *(_DWORD *)(a1 + 136);
  v6[0] = MEMORY[0x1E0C809B0];
  v6[1] = 0x40000000;
  v6[2] = __setCSAttributes2_block_invoke_2;
  v6[3] = &__block_descriptor_tmp_1387;
  v17 = *(_WORD *)(a1 + 140);
  v16 = v2;
  v3 = *(int8x16_t *)(a1 + 40);
  v4 = *(_OWORD *)(a1 + 56);
  v7 = vextq_s8(v3, v3, 8uLL);
  v8 = v4;
  v9 = *(_QWORD *)(a1 + 72);
  v10 = *(_OWORD *)(a1 + 80);
  v5 = *(_QWORD *)(a1 + 104);
  v11 = *(_QWORD *)(a1 + 96);
  v12 = v1;
  v13 = v5;
  v14 = *(_OWORD *)(a1 + 112);
  v15 = *(_QWORD *)(a1 + 128);
  v19 = *(_DWORD *)(a1 + 158);
  v18 = *(_OWORD *)(a1 + 142);
  si_indexingWatchdogPerform(v1, v3.i64[0], v2, 6u, (uint64_t)v6);
}

void __setCSAttributes2_block_invoke_2(uint64_t a1)
{
  uint64_t v1;
  unsigned int v2;
  int v3;
  unint64_t v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  void (*v10)(_QWORD);
  int v11;
  NSObject *v12;
  _QWORD *v13;
  CFIndex v14;
  uint64_t v15;
  __CFSet *v16;
  __CFSet *v17;
  const __CFString *v18;
  const __CFString *v19;
  __CFSet *Mutable;
  char v21;
  int v22;
  unsigned int v23;
  const __CFString *v24;
  const __CFString *v25;
  unsigned int v26;
  size_t v27;
  unsigned int v28;
  size_t v29;
  uint64_t v30;
  CFAllocatorRef v31;
  unint64_t v32;
  int Count;
  int v34;
  int IntValue;
  int v36;
  unsigned int v37;
  uint64_t PlistObjectSize;
  const __CFString *v39;
  const __CFString *v40;
  CFStringRef v41;
  CFStringRef v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  NSObject *v47;
  _BYTE *v48;
  int v49;
  const char *v50;
  uint64_t v51;
  unsigned int v52;
  uint64_t v53;
  void (*v54)(_QWORD);
  uint64_t v55;
  int v56;
  __int128 v57;
  int v58;
  uint64_t v59;
  const __CFAllocator *v60;
  const __CFAllocator *allocator;
  const __CFAllocator *v62;
  int v63;
  int v64;
  _QWORD block[7];
  __int128 v66;
  uint64_t v67;
  __int128 v68;
  uint64_t v69;
  __int128 v70;
  uint64_t v71;
  __int128 v72;
  uint64_t v73;
  int v74;
  int v75;
  char v76;
  __int128 v77;
  uint64_t v78;
  __int128 v79;
  uint64_t v80;
  __int128 v81;
  uint64_t v82;
  __int128 v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t *v86;
  uint64_t v87;
  char v88;
  __int128 v89;
  uint64_t v90;
  unint64_t v91;
  unsigned int v92;
  unsigned int v93;
  unint64_t v94;
  unsigned int v95;
  unsigned int v96;
  __int128 v97;
  uint64_t v98;
  __int128 v99;
  uint64_t v100;
  _BYTE buf[24];
  uint64_t v102;
  uint64_t v103;

  v1 = MEMORY[0x1E0C80A78](a1);
  v103 = *MEMORY[0x1E0C80C00];
  do
  {
    v2 = __ldxr(exceptionSequenceNum);
    v3 = v2 + 1;
  }
  while (__stxr(v2 + 1, exceptionSequenceNum));
  v4 = setThreadIdAndInfo(-1, (__int128 *)sJournalCtxExceptionCallbacks, *(_QWORD *)(v1 + 32), 0x40000000, v3);
  v95 = HIDWORD(v4);
  v96 = v4;
  v94 = __PAIR64__(v5, v6);
  v7 = *(_QWORD *)&threadData[18 * v4 + 2];
  v8 = v7 + 320 * HIDWORD(v4);
  *(_BYTE *)(v8 + 216) = 0;
  v9 = *(_DWORD *)(v8 + 312);
  v10 = *(void (**)(_QWORD))(v8 + 224);
  if (v10)
    v10(*(_QWORD *)(v7 + 320 * HIDWORD(v4) + 288));
  v93 = v96;
  v92 = v95;
  v91 = v94;
  if (_setjmp((int *)v8))
  {
    v11 = *__error();
    v12 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "setCSAttributes2_block_invoke";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 28073;
      _os_log_error_impl(&dword_1B8270000, v12, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
    }
    *__error() = v11;
    *(_DWORD *)(v8 + 312) = v9;
    CIOnThreadCleanUpReset(v91);
    dropThreadId(v93, 1, v3);
    CICleanUpReset(v93, HIDWORD(v91));
    return;
  }
  if (_kMDItemRelatedObjectsWithBundle_block_invoke_4_once != -1)
    dispatch_once(&_kMDItemRelatedObjectsWithBundle_block_invoke_4_once, &__block_literal_global_1384);
  v13 = &unk_1B862B000;
  v63 = v9;
  v64 = v3;
  if (*(_BYTE *)(v1 + 140))
    goto LABEL_12;
  if (*(_DWORD *)(v1 + 136) < 2u)
    goto LABEL_50;
  if (!CFEqual(*(CFTypeRef *)(v1 + 40), CFSTR("com.apple.MobileSMS")))
  {
    if (!CFEqual(*(CFTypeRef *)(v1 + 40), CFSTR("com.apple.mobilenotes")))
      goto LABEL_50;
    v26 = *(_DWORD *)(v1 + 136);
    *(_OWORD *)buf = *(_OWORD *)(v1 + 48);
    *(_QWORD *)&buf[16] = *(_QWORD *)(v1 + 64);
    if (!forceProcessCSSerialForNotes(v26, (__int128 *)buf))
      goto LABEL_50;
LABEL_12:
    v85 = 0;
    v86 = &v85;
    v87 = v13[85];
    v88 = 0;
    goto LABEL_64;
  }
  v14 = *(unsigned int *)(v1 + 136);
  v89 = *(_OWORD *)(v1 + 48);
  v90 = *(_QWORD *)(v1 + 64);
  if ((_DWORD)v14)
  {
    v15 = 0;
    allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v16 = 0;
    do
    {
      v85 = 0;
      v86 = 0;
      v87 = 0;
      v97 = 0uLL;
      v98 = 0;
      v17 = v16;
      LODWORD(v83) = 0;
      *(_OWORD *)buf = v89;
      *(_QWORD *)&buf[16] = v90;
      if (getCSInfoAtIndex((uint64_t)buf, v15, (uint64_t)&v85, &v83, (uint64_t)&v97))
      {
        *(_OWORD *)buf = v97;
        *(_QWORD *)&buf[16] = v98;
        if (attrsKeyValueMatchesString((uint64_t)buf, (uint64_t)"_kMDItemDomainIdentifier", 24, "attachmentDomain", 16))
        {
          *(_OWORD *)buf = v97;
          *(_QWORD *)&buf[16] = v98;
          v99 = 0uLL;
          v100 = 0;
          if (_MDPlistDictionaryGetPlistObjectForKey())
          {
            *(_OWORD *)buf = v99;
            *(_QWORD *)&buf[16] = v100;
            if (_MDPlistGetPlistObjectType() == 244
              || (*(_OWORD *)buf = v99, *(_QWORD *)&buf[16] = v100, _MDPlistGetPlistObjectType() == 245))
            {
              *(_OWORD *)buf = v99;
              *(_QWORD *)&buf[16] = v100;
              v18 = _copyMDPlistObject(allocator);
              if (v18)
              {
                v19 = v18;
                if (CFStringGetLength(v18))
                {
                  Mutable = v17;
                  if (!v17)
                    Mutable = CFSetCreateMutable(allocator, 0, MEMORY[0x1E0C9B3B0]);
                  v17 = Mutable;
                  CFSetAddValue(Mutable, v19);
                }
                CFRelease(v19);
              }
            }
          }
        }
      }
      v15 = (v15 + 1);
      v16 = v17;
    }
    while ((_DWORD)v14 != (_DWORD)v15);
    v13 = &unk_1B862B000;
    if (v17)
    {
      if (CFSetGetCount(v17) >= v14)
      {
        CFRelease(v17);
        goto LABEL_50;
      }
      v21 = 0;
      v22 = 1;
      do
      {
        v23 = v22;
        v85 = 0;
        v86 = 0;
        v87 = 0;
        v97 = 0uLL;
        v98 = 0;
        LODWORD(v83) = 0;
        *(_OWORD *)buf = v89;
        *(_QWORD *)&buf[16] = v90;
        if (getCSInfoAtIndex((uint64_t)buf, (v22 - 1), (uint64_t)&v85, &v83, (uint64_t)&v97))
        {
          *(_OWORD *)buf = v97;
          *(_QWORD *)&buf[16] = v98;
          if ((attrsKeyValueMatchesString((uint64_t)buf, (uint64_t)"_kMDItemDomainIdentifier", 24, "attachmentDomain", 16) & 1) == 0)
          {
            *(_OWORD *)buf = v97;
            *(_QWORD *)&buf[16] = v98;
            v99 = 0uLL;
            v100 = 0;
            if (_MDPlistDictionaryGetPlistObjectForKey())
            {
              *(_OWORD *)buf = v99;
              *(_QWORD *)&buf[16] = v100;
              if (_MDPlistGetPlistObjectType() == 244
                || (*(_OWORD *)buf = v99, *(_QWORD *)&buf[16] = v100, _MDPlistGetPlistObjectType() == 245))
              {
                *(_OWORD *)buf = v99;
                *(_QWORD *)&buf[16] = v100;
                v24 = _copyMDPlistObject(allocator);
                if (v24)
                {
                  v25 = v24;
                  if (CFStringGetLength(v24) && CFSetContainsValue(v17, v25))
                    v21 = 1;
                  CFRelease(v25);
                }
              }
            }
          }
        }
        if ((v21 & 1) != 0)
          break;
        v22 = v23 + 1;
      }
      while (v23 < v14);
      CFRelease(v17);
      v3 = v64;
      v13 = (_QWORD *)&unk_1B862B000;
      if ((v21 & 1) != 0)
        goto LABEL_12;
    }
  }
LABEL_50:
  LODWORD(v27) = gCPUCount;
  if (gCPUCount <= 1)
    LODWORD(v27) = 1;
  v28 = *(_DWORD *)(v1 + 136);
  if (v27 >= v28)
    v27 = v28;
  else
    v27 = v27;
  v29 = v27;
  if (v27 >= 2)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&_kMDItemRelatedObjectsWithBundle_block_invoke_4_poolLock);
    if (_kMDItemRelatedObjectsWithBundle_block_invoke_4_indexingPool <= v29)
    {
      if ((unint64_t)_kMDItemRelatedObjectsWithBundle_block_invoke_4_indexingPool < 2)
      {
        v29 = 1;
        goto LABEL_62;
      }
      v29 = _kMDItemRelatedObjectsWithBundle_block_invoke_4_indexingPool - 1;
      v30 = 1;
    }
    else
    {
      v30 = _kMDItemRelatedObjectsWithBundle_block_invoke_4_indexingPool - v29;
    }
    _kMDItemRelatedObjectsWithBundle_block_invoke_4_indexingPool = v30;
LABEL_62:
    os_unfair_lock_unlock((os_unfair_lock_t)&_kMDItemRelatedObjectsWithBundle_block_invoke_4_poolLock);
  }
  v85 = 0;
  v86 = &v85;
  v87 = v13[85];
  v88 = 0;
  if (v29 != 1)
  {
    *(_QWORD *)buf = 0;
    v55 = *(_QWORD *)(v1 + 32);
    if (v29)
      v56 = *(_DWORD *)(*(_QWORD *)v55 + 32);
    else
      v56 = -1;
    v49 = v9;
    block[1] = 0x40000000;
    v66 = *(_OWORD *)(v1 + 48);
    v68 = *(_OWORD *)(v1 + 72);
    v57 = *(_OWORD *)(v1 + 112);
    v70 = *(_OWORD *)(v1 + 96);
    block[0] = MEMORY[0x1E0C809B0];
    block[2] = __setCSAttributes2_block_invoke_4;
    block[3] = &unk_1E6E2E088;
    block[5] = v55;
    block[6] = buf;
    v58 = *(_DWORD *)(v1 + 136);
    v74 = v56;
    v75 = v58;
    v67 = *(_QWORD *)(v1 + 64);
    v76 = *(_BYTE *)(v1 + 141);
    v69 = *(_QWORD *)(v1 + 88);
    v71 = *(_QWORD *)(v1 + 40);
    v72 = v57;
    block[4] = &v85;
    v73 = *(_QWORD *)(v1 + 128);
    dispatch_apply(v29, 0, block);
    os_unfair_lock_lock((os_unfair_lock_t)&_kMDItemRelatedObjectsWithBundle_block_invoke_4_poolLock);
    _kMDItemRelatedObjectsWithBundle_block_invoke_4_indexingPool += v29;
    os_unfair_lock_unlock((os_unfair_lock_t)&_kMDItemRelatedObjectsWithBundle_block_invoke_4_poolLock);
    goto LABEL_88;
  }
LABEL_64:
  bzero(buf, 0x1000uLL);
  v31 = _SIStackAllocatorCreate((unint64_t *)buf, 4096, indexingZone);
  if (*(_DWORD *)(v1 + 136))
  {
    v32 = 0;
    v62 = v31;
    v60 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    do
    {
      if (!v102)
        *(_QWORD *)&buf[8] = (*(_QWORD *)buf + 55) & 0xFFFFFFFFFFFFFFF0;
      v97 = 0uLL;
      v98 = 0;
      v99 = *(_OWORD *)(v1 + 48);
      v100 = *(_QWORD *)(v1 + 64);
      _MDPlistArrayGetPlistObjectAtIndex();
      v99 = v97;
      v100 = v98;
      if (_MDPlistGetPlistObjectType() == 246)
      {
        *(_QWORD *)&v89 = 0;
        v99 = v97;
        v100 = v98;
        _MDPlistDataGetBytePtr();
        _MDPlistGetRootPlistObjectFromBytes();
        v97 = v99;
        v98 = v100;
      }
      v99 = v97;
      v100 = v98;
      if (_MDPlistGetPlistObjectType() != 240)
        goto LABEL_86;
      v99 = v97;
      v100 = v98;
      Count = _MDPlistArrayGetCount();
      if ((Count - 3) > 1)
        goto LABEL_86;
      v34 = Count;
      v99 = v97;
      v100 = v98;
      _MDPlistArrayGetPlistObjectAtIndex();
      IntValue = _MDPlistNumberGetIntValue();
      if ((IntValue & 2) != 0)
        goto LABEL_86;
      v36 = IntValue;
      v37 = *(_DWORD *)(*(_QWORD *)(v1 + 32) + 80);
      v89 = 0uLL;
      v90 = 0;
      v99 = v97;
      v100 = v98;
      _MDPlistArrayGetPlistObjectAtIndex();
      v83 = 0uLL;
      v84 = 0;
      v99 = v89;
      v100 = v90;
      if (!_MDPlistDictionaryGetPlistObjectForKey())
        goto LABEL_86;
      v99 = v97;
      v100 = v98;
      PlistObjectSize = _MDPlistGetPlistObjectSize();
      v99 = v83;
      v100 = v84;
      v39 = _copyMDPlistObject(v62);
      if (!v39)
        goto LABEL_86;
      v59 = PlistObjectSize;
      v40 = v39;
      if (CFStringGetLength(v39))
      {
        v81 = 0uLL;
        v82 = 0;
        if (v34 == 4)
        {
          v99 = v97;
          v100 = v98;
          _MDPlistArrayGetPlistObjectAtIndex();
        }
        if (*(_BYTE *)(v1 + 141))
        {
          bzero(&v99, 0x400uLL);
          v41 = 0;
          if (CFStringGetCString(v40, (char *)&v99, 1024, 0x8000100u))
          {
            v79 = 0uLL;
            v80 = 0;
            v77 = *(_OWORD *)(v1 + 72);
            v78 = *(_QWORD *)(v1 + 88);
            if (_MDPlistDictionaryGetPlistObjectForKey())
            {
              v77 = v79;
              v78 = v80;
              v41 = _copyMDPlistObject(v60);
            }
          }
        }
        else
        {
          v41 = 0;
        }
        v43 = *(_QWORD *)(v1 + 96);
        v44 = *(_QWORD *)(v1 + 104);
        v45 = *(_QWORD *)(v1 + 40);
        v46 = *(_QWORD *)(v1 + 112);
        v47 = *(NSObject **)(v1 + 120);
        v48 = *(_BYTE **)(v1 + 128);
        v99 = v89;
        v100 = v90;
        v79 = v81;
        v80 = v82;
        processOneCS(v43, v44, v45, v46, (v36 << 16) & 0x100000 | ((v36 & 1) << 17) | (v36 << 28 >> 31) & 0xA0000 | v37, (uint64_t)&v99, (uint64_t)&v79, (uint64_t)v41, v59, v62, 0, v47, (_BYTE *)v86 + 24, v48);
        CFRelease(v40);
        v42 = v41;
        if (!v41)
          goto LABEL_86;
      }
      else
      {
        v42 = v40;
      }
      CFRelease(v42);
LABEL_86:
      ++v32;
    }
    while (v32 < *(unsigned int *)(v1 + 136));
  }
  v49 = v63;
  v3 = v64;
LABEL_88:
  if (*((_BYTE *)v86 + 24))
  {
    if (*(_DWORD *)(v1 + 146) >= 2u)
      v50 = "com.apple.spotlight.SyndicatedContentDeleted";
    else
      v50 = "com.apple.spotlight.SyndicatedContentRefreshed";
    notify_post(v50);
  }
  v51 = *(_QWORD *)&threadData[18 * v93 + 2];
  v52 = v92;
  v53 = v51 + 320 * v92;
  *(_DWORD *)(v53 + 312) = v49;
  v54 = *(void (**)(_QWORD))(v53 + 232);
  if (v54)
    v54(*(_QWORD *)(v51 + 320 * v52 + 288));
  dropThreadId(v93, 0, v3);
  _Block_object_dispose(&v85, 8);
}

BOOL getCSInfoAtIndex(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, uint64_t a5)
{
  int IntValue;
  BOOL v9;
  _BOOL8 result;

  _MDPlistArrayGetPlistObjectAtIndex();
  if (_MDPlistGetPlistObjectType() == 246)
  {
    _MDPlistDataGetBytePtr();
    _MDPlistGetRootPlistObjectFromBytes();
  }
  if (_MDPlistGetPlistObjectType() != 240)
    return 0;
  if (_MDPlistArrayGetCount() - 5 < 0xFFFFFFFE)
    return 0;
  _MDPlistArrayGetPlistObjectAtIndex();
  IntValue = _MDPlistNumberGetIntValue();
  if ((IntValue & 2) != 0)
    return 0;
  _MDPlistArrayGetPlistObjectAtIndex();
  v9 = _MDPlistGetPlistObjectType() == 241;
  result = v9;
  if (v9)
  {
    *(_OWORD *)a3 = 0uLL;
    *(_QWORD *)(a3 + 16) = 0;
    *a4 = IntValue;
    *(_QWORD *)(a5 + 16) = 0;
    *(_OWORD *)a5 = 0uLL;
  }
  return result;
}

BOOL forceProcessCSSerialForNotes(unsigned int a1, __int128 *a2)
{
  uint64_t v4;
  BOOL v5;
  __int128 v7;
  uint64_t v8;
  int v9;
  __int128 v10;
  uint64_t v11;
  _BYTE v12[24];

  if (a1)
  {
    v4 = 0;
    v5 = 1;
    while (1)
    {
      v10 = 0uLL;
      v11 = 0;
      v7 = *a2;
      v8 = *((_QWORD *)a2 + 2);
      if (getCSInfoAtIndex((uint64_t)&v7, v4, (uint64_t)v12, &v9, (uint64_t)&v10))
      {
        v7 = v10;
        v8 = v11;
        if (attrsKeyValueEnabled())
          break;
      }
      v4 = (v4 + 1);
      v5 = v4 < a1;
      if (a1 == (_DWORD)v4)
        return 0;
    }
  }
  else
  {
    return 0;
  }
  return v5;
}

uint64_t __setCSAttributes2_block_invoke_3()
{
  uint64_t result;

  qos_class_self();
  result = pthread_qos_max_parallelism();
  _kMDItemRelatedObjectsWithBundle_block_invoke_4_indexingPool = (int)result;
  return result;
}

uint64_t __setCSAttributes2_block_invoke_1379(uint64_t a1)
{
  unsigned int v2;
  int v3;
  unint64_t v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  void (*v10)(_QWORD);
  int v11;
  NSObject *v12;
  unsigned int v14;
  int v15;
  unint64_t v16;
  unsigned int v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  void (*v21)(_QWORD);
  uint64_t v22;
  _DWORD *v23;
  int v24;
  NSObject *v25;
  __int128 v26;
  unint64_t *v27;
  unint64_t v28;
  uint64_t v29;
  const __CFString *v30;
  uint64_t v31;
  unint64_t *v32;
  unint64_t v33;
  NSObject *v34;
  uint64_t v35;
  uint64_t v36;
  unsigned int v37;
  uint64_t v38;
  void (*v39)(_QWORD);
  uint64_t v40;
  unsigned int v41;
  uint64_t v42;
  void (*v43)(_QWORD);
  unint64_t v44[513];
  int v45;
  __int128 v46;
  int v47;
  int v48;
  int v49;
  unsigned int v50;
  unsigned int v51;
  unsigned int v52;
  unsigned int v53;
  unsigned int v54;
  unsigned int v55;
  unsigned int v56;
  unsigned int v57;
  unsigned int v58;
  unsigned int v59;
  unsigned int v60;
  unsigned int v61;
  unsigned int v62;
  unsigned int v63;
  unsigned int v64;
  unsigned int v65;
  _BYTE v66[24];
  uint8_t buf[32];
  uint64_t v68;

  v68 = *MEMORY[0x1E0C80C00];
  makeThreadId();
  do
  {
    v2 = __ldxr(exceptionSequenceNum);
    v3 = v2 + 1;
  }
  while (__stxr(v2 + 1, exceptionSequenceNum));
  v4 = setThreadIdAndInfo(*(_DWORD *)(a1 + 96), sFdExceptionCallbacks, 0, 1, v3);
  v64 = HIDWORD(v4);
  v65 = v4;
  v62 = v6;
  v63 = v5;
  v7 = *(_QWORD *)&threadData[18 * v4 + 2];
  v8 = v7 + 320 * HIDWORD(v4);
  *(_BYTE *)(v8 + 216) = 0;
  v9 = *(_DWORD *)(v8 + 312);
  v10 = *(void (**)(_QWORD))(v8 + 224);
  if (v10)
    v10(*(_QWORD *)(v7 + 320 * HIDWORD(v4) + 288));
  v61 = v65;
  v60 = v64;
  v59 = v63;
  v58 = v62;
  if (_setjmp((int *)v8))
  {
    v11 = *__error();
    v12 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "setCSAttributes2_block_invoke";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 27806;
      _os_log_error_impl(&dword_1B8270000, v12, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
    }
    *__error() = v11;
    *(_DWORD *)(v8 + 312) = v9;
    CIOnThreadCleanUpReset(v58);
    dropThreadId(v61, 1, v3);
    return CICleanUpReset(v61, v59);
  }
  else
  {
    do
    {
      v14 = __ldxr(exceptionSequenceNum);
      v15 = v14 + 1;
    }
    while (__stxr(v14 + 1, exceptionSequenceNum));
    v16 = setThreadIdAndInfo(-1, (__int128 *)sJournalCtxExceptionCallbacks, *(_QWORD *)(a1 + 40), 0x40000000, v15);
    v56 = HIDWORD(v16);
    v57 = v16;
    v54 = v18;
    v55 = v17;
    v19 = *(_QWORD *)&threadData[18 * v16 + 2];
    v20 = v19 + 320 * HIDWORD(v16);
    *(_BYTE *)(v20 + 216) = 0;
    v47 = *(_DWORD *)(v20 + 312);
    v21 = *(void (**)(_QWORD))(v20 + 224);
    if (v21)
      v21(*(_QWORD *)(v19 + 320 * HIDWORD(v16) + 288));
    v53 = v57;
    v52 = v56;
    v51 = v55;
    v50 = v54;
    v22 = _setjmp((int *)v20);
    if ((_DWORD)v22)
    {
      v23 = (_DWORD *)(v20 + 312);
      v24 = *__error();
      v25 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)&buf[4] = "setCSAttributes2_block_invoke";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 27805;
        _os_log_error_impl(&dword_1B8270000, v25, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
      }
      *__error() = v24;
      *v23 = v47;
      CIOnThreadCleanUpReset(v50);
      dropThreadId(v53, 1, v15);
      CICleanUpReset(v53, v51);
    }
    else
    {
      v48 = v15;
      v49 = v3;
      MEMORY[0x1E0C80A78](v22);
      bzero(v44, 0x1000uLL);
      _SIStackAllocatorCreate(v44, 4096, indexingZone);
      v27 = *(unint64_t **)(a1 + 48);
      do
        v28 = __ldxr(v27);
      while (__stxr(v28 + 1, v27));
      if (v28 < *(unsigned int *)(a1 + 100))
      {
        *(_QWORD *)&v26 = 138412546;
        v46 = v26;
        do
        {
          memset(buf, 0, 24);
          *(_OWORD *)v66 = *(_OWORD *)(a1 + 56);
          *(_QWORD *)&v66[16] = *(_QWORD *)(a1 + 72);
          _MDPlistArrayGetPlistObjectAtIndex();
          if (!v44[3])
            v44[1] = (v44[0] + 55) & 0xFFFFFFFFFFFFFFF0;
          *(_OWORD *)v66 = *(_OWORD *)buf;
          *(_QWORD *)&v66[16] = *(_QWORD *)&buf[16];
          v29 = _MDPlistContainerCopyObject();
          if (v29)
          {
            v30 = (const __CFString *)v29;
            if (dword_1EF19FC9C >= 5)
            {
              v45 = *__error();
              v34 = _SILogForLogForCategory(4);
              if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
              {
                v35 = *(_QWORD *)(a1 + 80);
                *(_DWORD *)v66 = v46;
                *(_QWORD *)&v66[4] = v35;
                *(_WORD *)&v66[12] = 2112;
                *(_QWORD *)&v66[14] = v30;
                _os_log_impl(&dword_1B8270000, v34, OS_LOG_TYPE_DEFAULT, "Index delete bundleID:%@, identifier:%@", v66, 0x16u);
              }
              *__error() = v45;
            }
            *(_QWORD *)v66 = 0;
            if (!si_get_object_for_identifier_createParentDBO(*(_QWORD *)(a1 + 88), *(const __CFString **)(a1 + 80), v30, 0, 0, (unint64_t *)v66, 0, 0))
            {
              v31 = *(_QWORD *)(a1 + 88);
              _si_delete_attributes_inner(v31, *(unint64_t *)v66, *(unsigned __int8 *)(a1 + 104), 0, 1u, 0, (_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
              si_finish_text_store_deletions(v31);
            }
            CFRelease(v30);
          }
          v32 = *(unint64_t **)(a1 + 48);
          do
            v33 = __ldxr(v32);
          while (__stxr(v33 + 1, v32));
        }
        while (v33 < *(unsigned int *)(a1 + 100));
      }
      v36 = *(_QWORD *)&threadData[18 * v53 + 2];
      v37 = v52;
      v38 = v36 + 320 * v52;
      *(_DWORD *)(v38 + 312) = v47;
      v39 = *(void (**)(_QWORD))(v38 + 232);
      if (v39)
        v39(*(_QWORD *)(v36 + 320 * v37 + 288));
      dropThreadId(v53, 0, v48);
      v3 = v49;
    }
    v40 = *(_QWORD *)&threadData[18 * v61 + 2];
    v41 = v60;
    v42 = v40 + 320 * v60;
    *(_DWORD *)(v42 + 312) = v9;
    v43 = *(void (**)(_QWORD))(v42 + 232);
    if (v43)
      v43(*(_QWORD *)(v40 + 320 * v41 + 288));
    return dropThreadId(v61, 0, v3);
  }
}

void __setCSAttributes1_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD v5[6];
  __int128 v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;

  v2 = *(_QWORD *)(a1 + 32);
  v1 = *(_QWORD *)(a1 + 40);
  v5[0] = MEMORY[0x1E0C809B0];
  v5[1] = 0x40000000;
  v5[2] = __setCSAttributes1_block_invoke_2;
  v5[3] = &__block_descriptor_tmp_1474;
  v3 = *(_QWORD *)(a1 + 48);
  v5[4] = *(_QWORD *)(a1 + 56);
  v5[5] = v3;
  v6 = *(_OWORD *)(a1 + 64);
  v4 = *(_QWORD *)(a1 + 88);
  v7 = *(_QWORD *)(a1 + 80);
  v8 = v2;
  v9 = v4;
  v10 = v1;
  v12 = *(_DWORD *)(a1 + 104);
  v11 = *(_QWORD *)(a1 + 96);
  si_indexingWatchdogPerform(v2, v1, v3, 6u, (uint64_t)v5);
}

uint64_t __setCSAttributes1_block_invoke_2(uint64_t a1)
{
  unsigned int v2;
  int v3;
  unint64_t v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  void (*v10)(_QWORD);
  int v11;
  NSObject *v12;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t v20;
  void (*v21)(_QWORD);
  _QWORD v22[7];
  __int128 v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  __int128 v27;
  int v28;
  int v29;
  char v30;
  unsigned int v31;
  unsigned int v32;
  unsigned int v33;
  unsigned int v34;
  unsigned int v35;
  unsigned int v36;
  unsigned int v37;
  unsigned int v38;
  _BYTE buf[12];
  __int16 v40;
  int v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  do
  {
    v2 = __ldxr(exceptionSequenceNum);
    v3 = v2 + 1;
  }
  while (__stxr(v2 + 1, exceptionSequenceNum));
  v4 = setThreadIdAndInfo(-1, (__int128 *)sJournalCtxExceptionCallbacks, *(_QWORD *)(a1 + 32), 0x40000000, v3);
  v37 = HIDWORD(v4);
  v38 = v4;
  v35 = v6;
  v36 = v5;
  v7 = *(_QWORD *)&threadData[18 * v4 + 2];
  v8 = v7 + 320 * HIDWORD(v4);
  *(_BYTE *)(v8 + 216) = 0;
  v9 = *(_DWORD *)(v8 + 312);
  v10 = *(void (**)(_QWORD))(v8 + 224);
  if (v10)
    v10(*(_QWORD *)(v7 + 320 * HIDWORD(v4) + 288));
  v34 = v38;
  v33 = v37;
  v32 = v36;
  v31 = v35;
  if (_setjmp((int *)v8))
  {
    v11 = *__error();
    v12 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "setCSAttributes1_block_invoke";
      v40 = 1024;
      v41 = 27465;
      _os_log_error_impl(&dword_1B8270000, v12, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
    }
    *__error() = v11;
    *(_DWORD *)(v8 + 312) = v9;
    CIOnThreadCleanUpReset(v31);
    dropThreadId(v34, 1, v3);
    return CICleanUpReset(v34, v32);
  }
  else
  {
    *(_QWORD *)buf = 0;
    v14 = *(_QWORD *)(a1 + 32);
    v15 = *(_QWORD *)(a1 + 40);
    v16 = *(_DWORD *)(*(_QWORD *)v14 + 32);
    v22[0] = MEMORY[0x1E0C809B0];
    v22[1] = 0x40000000;
    v22[2] = __setCSAttributes1_block_invoke_3;
    v22[3] = &__block_descriptor_tmp_1473;
    v22[4] = v14;
    v22[5] = buf;
    v22[6] = v15;
    v23 = *(_OWORD *)(a1 + 48);
    v17 = *(_QWORD *)(a1 + 72);
    v24 = *(_QWORD *)(a1 + 64);
    v25 = v17;
    v26 = *(_QWORD *)(a1 + 80);
    LODWORD(v14) = *(_DWORD *)(a1 + 104);
    v28 = v16;
    v29 = v14;
    v30 = 0;
    v27 = *(_OWORD *)(a1 + 88);
    dispatch_apply(1uLL, 0, v22);
    v18 = *(_QWORD *)&threadData[18 * v34 + 2];
    v19 = v33;
    v20 = v18 + 320 * v33;
    *(_DWORD *)(v20 + 312) = v9;
    v21 = *(void (**)(_QWORD))(v20 + 232);
    if (v21)
      v21(*(_QWORD *)(v18 + 320 * v19 + 288));
    return dropThreadId(v34, 0, v3);
  }
}

uint64_t __setCSAttributes1_block_invoke_3(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  int v5;
  unint64_t v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  void (*v12)(_QWORD);
  int v13;
  NSObject *v14;
  unsigned int v16;
  int v17;
  unint64_t v18;
  unsigned int v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  void (*v24)(_QWORD);
  uint64_t v25;
  _DWORD *v26;
  int v27;
  NSObject *v28;
  const __CFAllocator *v29;
  unint64_t *v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unsigned int v34;
  _BYTE *v35;
  uint64_t v36;
  _BYTE *v37;
  BOOL v38;
  unint64_t *v39;
  unint64_t v40;
  uint64_t v41;
  unsigned int v42;
  uint64_t v43;
  void (*v44)(_QWORD);
  uint64_t v45;
  unsigned int v46;
  uint64_t v47;
  void (*v48)(_QWORD);
  unint64_t v49[512];
  int v50;
  int v51;
  int v52;
  __int128 v53;
  uint64_t v54;
  unsigned int v55;
  unsigned int v56;
  unsigned int v57;
  unsigned int v58;
  unsigned int v59;
  unsigned int v60;
  unsigned int v61;
  unsigned int v62;
  unsigned int v63;
  unsigned int v64;
  unsigned int v65;
  unsigned int v66;
  unsigned int v67;
  unsigned int v68;
  unsigned int v69;
  unsigned int v70;
  uint8_t buf[32];
  uint64_t v72;

  v72 = *MEMORY[0x1E0C80C00];
  makeThreadId();
  do
  {
    v4 = __ldxr(exceptionSequenceNum);
    v5 = v4 + 1;
  }
  while (__stxr(v4 + 1, exceptionSequenceNum));
  v6 = setThreadIdAndInfo(*(_DWORD *)(a1 + 112), sFdExceptionCallbacks, 0, 1, v5);
  v69 = HIDWORD(v6);
  v70 = v6;
  v67 = v8;
  v68 = v7;
  v9 = *(_QWORD *)&threadData[18 * v6 + 2];
  v10 = v9 + 320 * HIDWORD(v6);
  *(_BYTE *)(v10 + 216) = 0;
  v11 = *(_DWORD *)(v10 + 312);
  v12 = *(void (**)(_QWORD))(v10 + 224);
  if (v12)
    v12(*(_QWORD *)(v9 + 320 * HIDWORD(v6) + 288));
  v66 = v70;
  v65 = v69;
  v64 = v68;
  v63 = v67;
  if (_setjmp((int *)v10))
  {
    v13 = *__error();
    v14 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "setCSAttributes1_block_invoke";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 27458;
      _os_log_error_impl(&dword_1B8270000, v14, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
    }
    *__error() = v13;
    *(_DWORD *)(v10 + 312) = v11;
    CIOnThreadCleanUpReset(v63);
    dropThreadId(v66, 1, v5);
    return CICleanUpReset(v66, v64);
  }
  else
  {
    do
    {
      v16 = __ldxr(exceptionSequenceNum);
      v17 = v16 + 1;
    }
    while (__stxr(v16 + 1, exceptionSequenceNum));
    v18 = setThreadIdAndInfo(-1, (__int128 *)sJournalCtxExceptionCallbacks, *(_QWORD *)(a1 + 32), 0x40000000, v17);
    v61 = HIDWORD(v18);
    v62 = v18;
    v59 = v20;
    v60 = v19;
    v21 = *(_QWORD *)&threadData[18 * v18 + 2];
    v22 = v21 + 320 * HIDWORD(v18);
    *(_BYTE *)(v22 + 216) = 0;
    v23 = *(_DWORD *)(v22 + 312);
    v24 = *(void (**)(_QWORD))(v22 + 224);
    if (v24)
      v24(*(_QWORD *)(v21 + 320 * HIDWORD(v18) + 288));
    v58 = v62;
    v57 = v61;
    v56 = v60;
    v55 = v59;
    v25 = _setjmp((int *)v22);
    if ((_DWORD)v25)
    {
      v26 = (_DWORD *)(v22 + 312);
      v27 = *__error();
      v28 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)&buf[4] = "setCSAttributes1_block_invoke_3";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 27457;
        _os_log_error_impl(&dword_1B8270000, v28, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
      }
      *__error() = v27;
      *v26 = v23;
      CIOnThreadCleanUpReset(v55);
      dropThreadId(v58, 1, v17);
      CICleanUpReset(v58, v56);
    }
    else
    {
      v50 = v23;
      v51 = v17;
      v52 = v5;
      MEMORY[0x1E0C80A78](v25);
      bzero(v49, 0x1000uLL);
      v29 = _SIStackAllocatorCreate(v49, 4096, indexingZone);
      v30 = *(unint64_t **)(a1 + 40);
      do
        v31 = __ldxr(v30);
      while (__stxr(v31 + 1, v30));
      if (v31 < *(_QWORD *)(a1 + 48))
      {
        do
        {
          if (!v49[3])
            v49[1] = (v49[0] + 55) & 0xFFFFFFFFFFFFFFF0;
          memset(buf, 0, 24);
          v53 = *(_OWORD *)(a1 + 56);
          v54 = *(_QWORD *)(a1 + 72);
          _MDPlistArrayGetPlistObjectAtIndex();
          v32 = *(_QWORD *)(a1 + 80);
          v33 = *(_QWORD *)(a1 + 88);
          v34 = *(_DWORD *)(a1 + 116);
          v35 = (_BYTE *)*(unsigned __int8 *)(a1 + 120);
          v36 = *(_QWORD *)(a1 + 96);
          v37 = *(_BYTE **)(a1 + 104);
          v53 = *(_OWORD *)buf;
          v54 = *(_QWORD *)&buf[16];
          v38 = processOne(v32, v33, v36, 0, &v53, v34, v29, 1u, v35, v37);
          if (a2 && v38)
            break;
          v39 = *(unint64_t **)(a1 + 40);
          do
            v40 = __ldxr(v39);
          while (__stxr(v40 + 1, v39));
        }
        while (v40 < *(_QWORD *)(a1 + 48));
      }
      v41 = *(_QWORD *)&threadData[18 * v58 + 2];
      v42 = v57;
      v43 = v41 + 320 * v57;
      *(_DWORD *)(v43 + 312) = v50;
      v44 = *(void (**)(_QWORD))(v43 + 232);
      if (v44)
        v44(*(_QWORD *)(v41 + 320 * v42 + 288));
      dropThreadId(v58, 0, v51);
      v5 = v52;
    }
    v45 = *(_QWORD *)&threadData[18 * v66 + 2];
    v46 = v65;
    v47 = v45 + 320 * v65;
    *(_DWORD *)(v47 + 312) = v11;
    v48 = *(void (**)(_QWORD))(v47 + 232);
    if (v48)
      v48(*(_QWORD *)(v45 + 320 * v46 + 288));
    return dropThreadId(v66, 0, v5);
  }
}

uint64_t getDeferJournalFd(uint64_t a1, int a2)
{
  uint64_t v4;
  int v5;
  int v6;
  unsigned __int8 v7;
  _QWORD *v8;
  char *v9;
  char *v10;
  const char *v11;
  uint64_t v12;
  unsigned int *v13;
  unsigned int v14;
  unsigned int v15;
  char *v17;
  char *v18;
  const char *v19;
  uint64_t v20;
  char __str[16];
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  _BYTE v35[31];
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a1 + 2328);
  if (v4 || (a2 & 1) != 0)
  {
LABEL_16:
    if (a2)
    {
      if (*(_BYTE *)(a1 + 2072))
      {
        v13 = *(unsigned int **)(a1 + 2112);
        if (v13)
        {
          do
          {
            v14 = __ldaxr(v13);
            v15 = v14 - 1;
          }
          while (__stlxr(v15, v13));
          if (!v15)
            _si_mobile_journal_finalize((uint64_t)v13, 1);
        }
        *(_QWORD *)(a1 + 2112) = 0;
      }
      *(_QWORD *)(a1 + 2328) = 0;
    }
  }
  else
  {
    v5 = *(_DWORD *)(a1 + 32);
    if (v5 == -1)
    {
      v17 = __si_assert_copy_extra_521(-1);
      v18 = v17;
      v19 = "";
      if (v17)
        v19 = v17;
      __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 3580, "indexFd != -1", v19);
      free(v18);
      if (__valid_fs(-1))
        v20 = 2989;
      else
        v20 = 3072;
      *(_DWORD *)v20 = -559038737;
      abort();
    }
    v6 = *(_DWORD *)(a1 + 2348);
    if (v6 == 0x7FFFFFFF)
    {
LABEL_11:
      v9 = __si_assert_copy_extra_521(-1);
      v10 = v9;
      v11 = "";
      if (v9)
        v11 = v9;
      __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 3585, "syncCount < 2147483647", v11);
      free(v10);
      if (__valid_fs(-1))
        v12 = 2989;
      else
        v12 = 3072;
      *(_DWORD *)v12 = -559038737;
      abort();
    }
    while (1)
    {
      v34 = 0u;
      memset(v35, 0, sizeof(v35));
      v32 = 0u;
      v33 = 0u;
      v30 = 0u;
      v31 = 0u;
      v28 = 0u;
      v29 = 0u;
      v26 = 0u;
      v27 = 0u;
      v24 = 0u;
      v25 = 0u;
      v22 = 0u;
      v23 = 0u;
      *(_OWORD *)__str = 0u;
      snprintf(__str, 0xFFuLL, "%s%d", "deferAttr.", v6);
      if ((*(_DWORD *)(a1 + 60) & 0xFFFFFFFE) == 2)
        v7 = 2;
      else
        v7 = 0;
      v8 = fd_create_protected(v5, __str, 536873482, v7);
      if (v8)
      {
        ++*(_DWORD *)(a1 + 2348);
        *(_QWORD *)(a1 + 2328) = v8;
        SIActivityJournalNewJournal((os_unfair_lock_s *)(a1 + 2192), (uint64_t)v8);
        _fd_acquire_fd(*(_QWORD *)(a1 + 2328), __str);
        v4 = *(_QWORD *)(a1 + 2328);
        goto LABEL_16;
      }
      if (*__error() != 17)
        return 0;
      v6 = *(_DWORD *)(a1 + 2348) + 1;
      *(_DWORD *)(a1 + 2348) = v6;
      if (v6 == 0x7FFFFFFF)
        goto LABEL_11;
    }
  }
  return v4;
}

uint64_t si_clientstatesandmeta_update(uint64_t a1, uint64_t a2, int a3)
{
  unsigned int v4;
  uint64_t v5;
  BOOL v6;
  int v7;
  const __CFNumber *Value;
  const __CFAllocator *v12;
  CFNumberRef v13;
  CFNumberRef v14;
  CFNumberRef v15;
  CFNumberRef v16;
  CFNumberRef v17;
  CFNumberRef v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  CFStringRef v22;
  CFStringRef v23;
  uint64_t v25;
  uint64_t valuePtr;

  valuePtr = a2;
  if (!*(_BYTE *)(a1 + 2072))
    return 1;
  v4 = *(_DWORD *)(a1 + 60) >> 1;
  v5 = 1;
  v6 = v4 > 7;
  v7 = (1 << v4) & 0x86;
  if (!v6 && v7 != 0)
  {
    pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 80));
    Value = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 72), CFSTR("journalSerialNumber"));
    if (Value)
    {
      v25 = 0;
      CFNumberGetValue(Value, kCFNumberSInt64Type, &v25);
      if (v25 >= a2)
        valuePtr = v25;
    }
    v12 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v13 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt64Type, &valuePtr);
    if (v13)
    {
      v14 = v13;
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 72), CFSTR("journalSerialNumber"), v13);
      CFRelease(v14);
    }
    v15 = CFNumberCreate(v12, kCFNumberIntType, (const void *)(a1 + 2344));
    if (v15)
    {
      v16 = v15;
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 72), CFSTR("syncCount"), v15);
      CFRelease(v16);
    }
    v17 = CFNumberCreate(v12, kCFNumberIntType, (const void *)(a1 + 2348));
    if (v17)
    {
      v18 = v17;
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 72), CFSTR("deferSyncCount"), v17);
      CFRelease(v18);
    }
    v19 = 2320;
    if (a3)
      v19 = 2328;
    v20 = *(_QWORD *)(a1 + v19);
    if (v20)
    {
      v21 = (const char *)fd_name_ptr(v20);
      if (v21)
      {
        v22 = CFStringCreateWithCString(v12, v21, 0x8000100u);
        if (v22)
        {
          v23 = v22;
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 72), CFSTR("journalName"), v22);
          CFRelease(v23);
        }
      }
    }
    v5 = SIPersistClientStateAndMeta(a1, 0);
    pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 80));
  }
  return v5;
}

uint64_t bundleIdHash(uint64_t a1, int a2)
{
  int v2;
  int v3;
  unsigned __int8 *v4;
  int v5;
  int v6;
  uint64_t v7;
  int v8;
  int v9;
  unint64_t v10;
  int v11;
  int v13;
  int v14;
  unint64_t v15;
  int v16;
  unsigned int v17;

  v2 = -1759636613;
  if (a2 >= 0)
    v3 = a2;
  else
    v3 = a2 + 3;
  v4 = (unsigned __int8 *)(a1 + (int)(v3 & 0xFFFFFFFC));
  if ((a2 + 3) >= 7)
  {
    v7 = -(v3 >> 2);
    v8 = -1789642873;
    v9 = 718793509;
    do
    {
      v8 = 5 * v8 + 2071795100;
      v9 = 5 * v9 + 1808688022;
      HIDWORD(v10) = v8 * *(_DWORD *)&v4[4 * v7];
      LODWORD(v10) = HIDWORD(v10);
      v11 = (v10 >> 21) * v9;
      HIDWORD(v10) = v2;
      LODWORD(v10) = v2;
      v2 = v11 ^ (5 * (v10 >> 19) + 1390208809);
    }
    while (!__CFADD__(v7++, 1));
    v6 = 5 * v8 + 2071795100;
    v5 = 5 * v9 + 1808688022;
  }
  else
  {
    v5 = 1107688271;
    v6 = 1713515327;
  }
  v13 = 0;
  v14 = a2 & 3;
  switch(v14)
  {
    case 1:
      goto LABEL_15;
    case 2:
LABEL_14:
      v13 |= v4[1] << 8;
LABEL_15:
      HIDWORD(v15) = (v13 ^ *v4) * v6;
      LODWORD(v15) = HIDWORD(v15);
      v16 = (v15 >> 21) * v5;
      HIDWORD(v15) = v2;
      LODWORD(v15) = v2;
      v2 = v16 ^ (5 * (v15 >> 19) + 1390208809);
      break;
    case 3:
      v13 = v4[2] << 16;
      goto LABEL_14;
  }
  v17 = -1028477387 * ((-2048144789 * (v2 ^ a2)) ^ ((-2048144789 * (v2 ^ a2)) >> 13));
  return v17 & 0x7FFFFFFF ^ HIWORD(v17);
}

void _mobile_journal_update_toc(uint64_t a1, __int128 *a2, NSObject *a3)
{
  uint64_t v6;
  uint64_t v7;
  int v8;
  NSObject *v9;
  int v10;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  int v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (*(_DWORD *)(a1 + 56))
    {
      if (*(_QWORD *)(a1 + 64))
      {
        if (*(_QWORD *)(a1 + 72))
        {
          if (*(uint64_t *)(a1 + 40) >= 1)
          {
            v11 = *a2;
            v12 = *((_QWORD *)a2 + 2);
            v13 = *((_QWORD *)a2 + 3);
            v6 = fd_lseek(*(_DWORD **)(a1 + 80), 0, 2);
            if (v6 != -1)
            {
              v7 = v6;
              if (fd_write(*(_QWORD *)(a1 + 80), (uint64_t)&v11, 0x20uLL) == -1)
              {
                v8 = *__error();
                v9 = _SILogForLogForCategory(0);
                if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
                {
                  v10 = *__error();
                  *(_DWORD *)buf = 136315650;
                  v15 = "_mobile_journal_update_toc";
                  v16 = 1024;
                  v17 = 17989;
                  v18 = 1024;
                  v19 = v10;
                  _os_log_error_impl(&dword_1B8270000, v9, OS_LOG_TYPE_ERROR, "%s:%d: journal TOC write error : %d", buf, 0x18u);
                }
                *__error() = v8;
              }
              else
              {
                *(_QWORD *)(a1 + 88) = v7 + 32;
                _mobile_journal_notify_toc_event(a1, *(_QWORD *)a2, *((_DWORD *)a2 + 7), v7, a3);
              }
            }
          }
        }
      }
    }
  }
}

void _mobile_journal_notify_toc_event(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, NSObject *a5)
{
  xpc_object_t message;
  unsigned int v11;
  int v12;
  NSObject *v13;
  unsigned int v14;
  unsigned int v15;
  uint8_t v16[8];
  _QWORD v17[6];
  unsigned int v18;

  if (a1
    && *(_DWORD *)(a1 + 56)
    && *(_QWORD *)(a1 + 64)
    && *(_QWORD *)(a1 + 72)
    && *(uint64_t *)(a1 + 40) >= 1
    && !*(_BYTE *)(a1 + 108))
  {
    *(_BYTE *)(a1 + 108) = 1;
    message = _si_mobile_journal_create_message(a1, 3u);
    xpc_dictionary_set_uint64(message, "jsn", a2);
    xpc_dictionary_set_uint64(message, "toc_o", a4);
    xpc_dictionary_set_uint64(message, "toc_f", a3);
    do
      v11 = __ldaxr((unsigned int *)a1);
    while (__stlxr(v11 + 1, (unsigned int *)a1));
    dispatch_retain(a5);
    v17[0] = MEMORY[0x1E0C809B0];
    v17[1] = 0x40000000;
    v17[2] = ___mobile_journal_notify_toc_event_block_invoke;
    v17[3] = &__block_descriptor_tmp_1376;
    v17[4] = a1;
    v17[5] = a5;
    v18 = a3;
    if ((si_xpc_send_client_msg(message, (uint64_t)v17) & 1) == 0)
    {
      v12 = *__error();
      v13 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)v16 = 0;
        _os_log_impl(&dword_1B8270000, v13, OS_LOG_TYPE_DEFAULT, "### skg journal_add message NOT sent", v16, 2u);
      }
      *__error() = v12;
      do
      {
        v14 = __ldaxr((unsigned int *)a1);
        v15 = v14 - 1;
      }
      while (__stlxr(v15, (unsigned int *)a1));
      if (!v15)
        _si_mobile_journal_finalize(a1, 1);
    }
    if (message)
      CFRelease(message);
  }
}

void ___mobile_journal_notify_toc_event_block_invoke(uint64_t a1, xpc_object_t xdict, uint64_t a3)
{
  uint64_t v4;
  int64_t uint64;
  int64_t v6;
  NSObject *v7;
  _QWORD v8[7];
  int v9;

  v4 = *(_QWORD *)(a1 + 32);
  *(_BYTE *)(v4 + 108) = 0;
  if (a3 < 0
    || (uint64 = xpc_dictionary_get_uint64(xdict, "toc_p"),
        v4 = *(_QWORD *)(a1 + 32),
        (*(_QWORD *)(v4 + 96) = uint64) == 0))
  {
    v6 = 0;
  }
  else if (uint64 >= *(_QWORD *)(v4 + 88))
  {
    v6 = 0;
  }
  else
  {
    v6 = uint64;
  }
  v7 = *(NSObject **)(a1 + 40);
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 0x40000000;
  v8[2] = ___mobile_journal_notify_toc_event_block_invoke_2;
  v8[3] = &__block_descriptor_tmp_1375;
  v8[4] = v6;
  v8[5] = v4;
  v9 = *(_DWORD *)(a1 + 48);
  v8[6] = v7;
  dispatch_async(v7, v8);
}

void ___mobile_journal_notify_toc_event_block_invoke_2(uint64_t a1)
{
  uint64_t v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;

  v2 = *(_QWORD *)(a1 + 32);
  if (v2)
    _mobile_journal_notify_toc_event(*(_QWORD *)(a1 + 40), 0, *(unsigned int *)(a1 + 56), v2, *(_QWORD *)(a1 + 48));
  v3 = *(unsigned int **)(a1 + 40);
  if (v3)
  {
    do
    {
      v4 = __ldaxr(v3);
      v5 = v4 - 1;
    }
    while (__stlxr(v5, v3));
    if (!v5)
      _si_mobile_journal_finalize((uint64_t)v3, 1);
  }
  dispatch_release(*(dispatch_object_t *)(a1 + 48));
}

uint64_t addContactInfoToContainer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  uint64_t i;
  uint64_t j;
  uint64_t k;
  uint64_t m;
  uint64_t n;
  uint64_t ii;
  uint64_t jj;
  uint64_t kk;
  uint64_t mm;
  uint64_t nn;
  uint64_t v30;

  _MDPlistContainerBeginDictionary();
  _MDPlistContainerAddCString();
  _MDPlistContainerAddObject();
  if (a4)
  {
    v30 = a3;
    _MDPlistContainerAddCString();
    _MDPlistContainerBeginArray();
    for (i = 0; i != 32; i += 8)
      _MDPlistContainerAddInt64Value();
    _MDPlistContainerEndArray();
    a3 = v30;
  }
  if (a5)
  {
    _MDPlistContainerAddCString();
    _MDPlistContainerBeginArray();
    for (j = 0; j != 32; j += 8)
      _MDPlistContainerAddInt64Value();
    _MDPlistContainerEndArray();
  }
  if (a6)
  {
    _MDPlistContainerAddCString();
    _MDPlistContainerBeginArray();
    for (k = 0; k != 32; k += 8)
      _MDPlistContainerAddInt64Value();
    _MDPlistContainerEndArray();
  }
  if (a7)
  {
    _MDPlistContainerAddCString();
    _MDPlistContainerBeginArray();
    for (m = 0; m != 32; m += 8)
      _MDPlistContainerAddInt64Value();
    _MDPlistContainerEndArray();
  }
  if (a8)
  {
    _MDPlistContainerAddCString();
    _MDPlistContainerBeginArray();
    for (n = 0; n != 32; n += 8)
      _MDPlistContainerAddInt64Value();
    _MDPlistContainerEndArray();
  }
  if (a9)
  {
    _MDPlistContainerAddCString();
    _MDPlistContainerBeginArray();
    for (ii = 0; ii != 32; ii += 8)
      _MDPlistContainerAddInt64Value();
    _MDPlistContainerEndArray();
  }
  if (a10)
  {
    _MDPlistContainerAddCString();
    _MDPlistContainerBeginArray();
    for (jj = 0; jj != 32; jj += 8)
      _MDPlistContainerAddInt64Value();
    _MDPlistContainerEndArray();
  }
  if (a11)
  {
    _MDPlistContainerAddCString();
    _MDPlistContainerBeginArray();
    for (kk = 0; kk != 32; kk += 8)
      _MDPlistContainerAddInt64Value();
    _MDPlistContainerEndArray();
  }
  if (a12)
  {
    _MDPlistContainerAddCString();
    _MDPlistContainerBeginArray();
    for (mm = 0; mm != 32; mm += 8)
      _MDPlistContainerAddInt64Value();
    _MDPlistContainerEndArray();
  }
  if (a13)
  {
    _MDPlistContainerAddCString();
    _MDPlistContainerBeginArray();
    for (nn = 0; nn != 32; nn += 8)
      _MDPlistContainerAddInt64Value();
    _MDPlistContainerEndArray();
  }
  if (a3)
  {
    _MDPlistContainerAddCString();
    _MDPlistContainerAddObject();
  }
  return _MDPlistContainerEndDictionary();
}

void si_updateContactInfo(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43)
{
  CFAllocatorRef v43;
  __int128 *v44;
  __int128 *v45;
  _QWORD *v46;
  _QWORD *v47;
  _QWORD *v48;
  _QWORD *v49;
  _QWORD *v50;
  _QWORD *v51;
  _QWORD *v52;
  _QWORD *v53;
  const __CFAllocator *v54;
  const void *Mutable;
  __int128 v56;
  __int128 v59;
  uint64_t v60;
  uint64_t v61;
  _BYTE v64[24];
  _BYTE v65[24];
  unint64_t v66[256];
  _QWORD v67[4];
  _QWORD v68[4];
  _QWORD v69[4];
  _QWORD v70[4];
  _QWORD v71[4];
  _QWORD v72[4];
  _QWORD v73[4];
  _QWORD v74[4];
  __int128 v75;
  uint64_t v76;
  uint64_t v77;
  __int128 v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;

  *(_QWORD *)&v59 = a7;
  *((_QWORD *)&v59 + 1) = a8;
  *(_QWORD *)&v56 = a3;
  *((_QWORD *)&v56 + 1) = a4;
  v81 = *MEMORY[0x1E0C80C00];
  bzero(v66, 0x800uLL);
  v43 = _SIStackAllocatorCreate(v66, 512, indexingZone);
  if (!v66[3])
    v66[1] = (v66[0] + 55) & 0xFFFFFFFFFFFFFFF0;
  v78 = v56;
  v79 = a5;
  v80 = a6;
  v75 = v59;
  v76 = a9;
  v77 = a10;
  if (*((_QWORD *)&v56 + 1) | (unint64_t)v56 | a5 | a6)
    v44 = &v78;
  else
    v44 = 0;
  v74[0] = a11;
  v74[1] = a12;
  v74[2] = a13;
  v74[3] = a14;
  v45 = &v75;
  if (!(*((_QWORD *)&v59 + 1) | (unint64_t)v59 | a9 | a10))
    v45 = 0;
  v60 = (uint64_t)v45;
  v61 = (uint64_t)v44;
  v73[0] = a15;
  v73[1] = a16;
  v73[2] = a17;
  v73[3] = a18;
  if (a12 | a11 | a13 | a14)
    v46 = v74;
  else
    v46 = 0;
  v72[0] = a19;
  v72[1] = a20;
  v72[2] = a21;
  v72[3] = a22;
  if (a16 | a15 | a17 | a18)
    v47 = v73;
  else
    v47 = 0;
  v71[0] = a23;
  v71[1] = a24;
  v71[2] = a25;
  v71[3] = a26;
  if (a20 | a19 | a21 | a22)
    v48 = v72;
  else
    v48 = 0;
  v70[0] = a27;
  v70[1] = a28;
  v70[2] = a29;
  v70[3] = a30;
  if (a24 | a23 | a25 | a26)
    v49 = v71;
  else
    v49 = 0;
  v69[0] = a31;
  v69[1] = a32;
  v69[2] = a33;
  v69[3] = a34;
  if (a28 | a27 | a29 | a30)
    v50 = v70;
  else
    v50 = 0;
  v68[0] = a35;
  v68[1] = a36;
  v68[2] = a37;
  if (a32 | a31 | a33 | a34)
    v51 = v69;
  else
    v51 = 0;
  v68[3] = a38;
  v67[0] = a39;
  v67[1] = a40;
  if (a36 | a35 | a37 | a38)
    v52 = v68;
  else
    v52 = 0;
  v67[2] = a41;
  v67[3] = a42;
  if (a40 | a39 | a41 | a42)
    v53 = v67;
  else
    v53 = 0;
  v54 = v43;
  Mutable = (const void *)_MDPlistContainerCreateMutable();
  _MDPlistContainerBeginContainer();
  _MDPlistContainerBeginArray();
  addContactInfoToContainer((uint64_t)Mutable, a2, a43, v61, v60, (uint64_t)v46, (uint64_t)v47, (uint64_t)v48, (uint64_t)v49, (uint64_t)v50, (uint64_t)v51, (uint64_t)v52, (uint64_t)v53);
  _MDPlistContainerAddNullValue();
  _MDPlistContainerEndArray();
  _MDPlistContainerEndContainer();
  v78 = 0uLL;
  v79 = 0;
  _MDPlistGetRootPlistObjectFromPlist();
  v75 = v78;
  v76 = v79;
  _MDPlistArrayGetPlistObjectAtIndex();
  v75 = v78;
  v76 = v79;
  _MDPlistArrayGetPlistObjectAtIndex();
  processOneCS(a1, -1, (uint64_t)CFSTR("com.apple.MobileAddressBook"), 0, 0x20000, (uint64_t)v65, (uint64_t)v64, 0, 0, v54, 0, 0, 0, &v75);
  CFRelease(Mutable);
}

void recalculateTopK(uint64_t a1)
{
  char *v2;
  char *v3;
  const __CFAllocator *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  CFMutableDictionaryRef v9;
  void *v10;
  unint64_t Length;
  uint64_t Bytes;
  char *v13;
  char *v14;
  uint64_t v15;
  unsigned int v16;
  int v17;
  unint64_t v18;
  unsigned int v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  void (*v24)(_QWORD);
  int v25;
  NSObject *v26;
  void *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  void (*v31)(_QWORD);
  const void *v32;
  void *v33;
  unsigned int v34;
  unsigned int v35;
  unsigned int v36;
  unsigned int v37;
  _QWORD v38[2];
  _QWORD v39[3];
  _QWORD v40[2];
  uint64_t (*v41)(uint64_t, uint64_t);
  void *v42;
  uint64_t *v43;
  uint64_t v44;
  uint64_t *v45;
  uint64_t v46;
  CFMutableDictionaryRef Mutable;
  uint8_t buf[4];
  const char *v49;
  __int16 v50;
  int v51;
  uint64_t v52;

  v52 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 2072))
  {
    if ((*(_BYTE *)(a1 + 830) & 4) == 0)
    {
      v2 = (char *)fd_create_protected(*(_DWORD *)(a1 + 32), "tmp.topK.v2.mdplistc", 1538, 0);
      if (v2)
      {
        v3 = v2;
        v44 = 0;
        v45 = &v44;
        v46 = 0x2000000000;
        Mutable = 0;
        v4 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 500, 0, MEMORY[0x1E0C9B3A0]);
        v5 = *(_QWORD *)(a1 + 1392);
        v6 = *(_QWORD *)(a1 + 1384);
        v40[0] = MEMORY[0x1E0C809B0];
        v40[1] = 0x40000000;
        v41 = __recalculateTopK_block_invoke;
        v42 = &unk_1E6E2D2D8;
        v43 = &v44;
        if (v5 && *(_DWORD *)(v5 + 8))
        {
          v7 = 0;
          while (((unsigned int (*)(_QWORD *, _QWORD, _QWORD))v41)(v40, *(_QWORD *)(*(_QWORD *)v5 + 8 * v7), 0))
          {
            if (++v7 >= (unint64_t)*(unsigned int *)(v5 + 8))
              goto LABEL_9;
          }
        }
        else
        {
LABEL_9:
          if (v6 && *(_DWORD *)(v6 + 8))
          {
            v8 = 0;
            do
            {
              if (!((unsigned int (*)(_QWORD *, _QWORD, uint64_t))v41)(v40, *(_QWORD *)(*(_QWORD *)v6 + 8 * v8), 1))break;
              ++v8;
            }
            while (v8 < *(unsigned int *)(v6 + 8));
          }
        }
        v9 = CFDictionaryCreateMutable(v4, 500, 0, 0);
        CFDictionaryApplyFunction((CFDictionaryRef)v45[3], (CFDictionaryApplierFunction)heapifyDicts, v9);
        v10 = (void *)_MDPlistContainerCreateMutable();
        _MDPlistContainerBeginContainer();
        _MDPlistContainerBeginDictionary();
        CFDictionaryApplyFunction(v9, (CFDictionaryApplierFunction)emitTerms, v10);
        _MDPlistContainerEndDictionary();
        _MDPlistContainerEndContainer();
        Length = _MDPlistContainerGetLength();
        Bytes = _MDPlistContainerGetBytes();
        fd_pwrite((uint64_t)v3, Bytes, Length, 0);
        fd_sync((uint64_t)v3, 0);
        CFRelease(v10);
        v13 = (char *)fd_create_protected(*(_DWORD *)(a1 + 32), "tmp.topK.v2.mdplistc", 0, 0);
        if (!v13)
        {
          _fd_unlink_with_origin((uint64_t)v3, 0);
LABEL_33:
          fd_release(v3);
          CFRelease((CFTypeRef)v45[3]);
          CFDictionaryApplyFunction(v9, (CFDictionaryApplierFunction)pqDisposeApplier, 0);
          CFRelease(v9);
          _Block_object_dispose(&v44, 8);
          return;
        }
        v14 = v13;
        v15 = fd_mmap((uint64_t)v13);
        if (v15 != -1)
        {
          v33 = (void *)v15;
          v39[0] = v15;
          v39[1] = Length;
          v39[2] = 0;
          v38[0] = 1;
          v38[1] = v39;
          do
          {
            v16 = __ldxr(exceptionSequenceNum);
            v17 = v16 + 1;
          }
          while (__stxr(v16 + 1, exceptionSequenceNum));
          v18 = setThreadIdAndInfo(-1, (__int128 *)sMappingExceptionCallbacks, (uint64_t)v38, 0, v17);
          v36 = HIDWORD(v18);
          v37 = v18;
          v34 = v20;
          v35 = v19;
          v21 = *(_QWORD *)&threadData[18 * v18 + 2];
          v22 = v21 + 320 * HIDWORD(v18);
          *(_BYTE *)(v22 + 216) = 0;
          v23 = *(_DWORD *)(v22 + 312);
          v24 = *(void (**)(_QWORD))(v22 + 224);
          if (v24)
            v24(*(_QWORD *)(v21 + 320 * HIDWORD(v18) + 288));
          if (_setjmp((int *)v22))
          {
            v25 = *__error();
            v26 = _SILogForLogForCategory(0);
            if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136315394;
              v49 = "recalculateTopK";
              v50 = 1024;
              v51 = 7373;
              _os_log_error_impl(&dword_1B8270000, v26, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
            }
            *__error() = v25;
            *(_DWORD *)(v22 + 312) = v23;
            CIOnThreadCleanUpReset(v34);
            dropThreadId(v37, 1, v17);
            CICleanUpReset(v37, v35);
            v27 = v33;
          }
          else
          {
            v27 = v33;
            v28 = _MDPlistContainerCreateWithBytes();
            v29 = *(_QWORD *)&threadData[18 * v37 + 2];
            v30 = v29 + 320 * v36;
            *(_DWORD *)(v30 + 312) = v23;
            v31 = *(void (**)(_QWORD))(v30 + 232);
            if (v31)
              v31(*(_QWORD *)(v29 + 320 * v36 + 288));
            dropThreadId(v37, 0, v17);
            if (v28)
            {
              fd_rename((uint64_t)v3, "topK.v2.mdplistc");
              si_scheduler_suspend(*(_QWORD *)(a1 + 912));
              v32 = *(const void **)(a1 + 664);
              *(_QWORD *)(a1 + 664) = v28;
              if (v32)
                CFRelease(v32);
              si_scheduler_resume(*(_QWORD *)(a1 + 912), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 7388);
              goto LABEL_32;
            }
          }
          munmap(v27, Length);
        }
LABEL_32:
        fd_release(v14);
        goto LABEL_33;
      }
    }
  }
}

uint64_t __recalculateTopK_block_invoke(uint64_t a1, uint64_t a2)
{
  const void *v3;
  CFTypeRef v4;
  const void *v5;
  unsigned int v6;
  int v7;
  unint64_t v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  void (*v14)(_QWORD);
  int v15;
  NSObject *v16;
  const __CFDictionary *v17;
  const __CFDictionary *v18;
  CFTypeID v19;
  uint64_t v20;
  uint64_t v21;
  void (*v22)(_QWORD);
  unsigned int v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  _QWORD v28[2];
  _QWORD v29[3];
  uint8_t buf[4];
  const char *v31;
  __int16 v32;
  int v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v3 = *(const void **)(a2 + 14456);
  if (v3)
  {
    v4 = CFRetain(v3);
    if (v4)
    {
      v5 = v4;
      v29[0] = _MDPlistContainerGetBytes();
      v29[1] = _MDPlistContainerGetLength();
      v29[2] = 0;
      v28[0] = 1;
      v28[1] = v29;
      do
      {
        v6 = __ldxr(exceptionSequenceNum);
        v7 = v6 + 1;
      }
      while (__stxr(v6 + 1, exceptionSequenceNum));
      v8 = setThreadIdAndInfo(-1, (__int128 *)sMappingExceptionCallbacks, (uint64_t)v28, 0, v7);
      v26 = HIDWORD(v8);
      v27 = v8;
      v24 = v10;
      v25 = v9;
      v11 = *(_QWORD *)&threadData[18 * v8 + 2];
      v12 = v11 + 320 * HIDWORD(v8);
      *(_BYTE *)(v12 + 216) = 0;
      v13 = *(_DWORD *)(v12 + 312);
      v14 = *(void (**)(_QWORD))(v12 + 224);
      if (v14)
        v14(*(_QWORD *)(v11 + 320 * HIDWORD(v8) + 288));
      if (_setjmp((int *)v12))
      {
        v15 = *__error();
        v16 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315394;
          v31 = "recalculateTopK_block_invoke";
          v32 = 1024;
          v33 = 7328;
          _os_log_error_impl(&dword_1B8270000, v16, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
        }
        *__error() = v15;
        *(_DWORD *)(v12 + 312) = v13;
        CIOnThreadCleanUpReset(v24);
        dropThreadId(v27, 1, v7);
        CICleanUpReset(v27, v25);
      }
      else
      {
        v17 = (const __CFDictionary *)_MDPlistContainerCopyRootObject();
        v18 = v17;
        if (v17)
        {
          v19 = CFGetTypeID(v17);
          if (v19 == CFDictionaryGetTypeID())
            CFDictionaryApplyFunction(v18, (CFDictionaryApplierFunction)sumDicts, *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
        }
        v20 = *(_QWORD *)&threadData[18 * v27 + 2];
        v21 = v20 + 320 * v26;
        *(_DWORD *)(v21 + 312) = v13;
        v22 = *(void (**)(_QWORD))(v21 + 232);
        if (v22)
          v22(*(_QWORD *)(v20 + 320 * v26 + 288));
        dropThreadId(v27, 0, v7);
        if (v18)
          CFRelease(v18);
      }
      CFRelease(v5);
    }
  }
  return 1;
}

void heapifyDicts(int a1, CFTypeRef cf, const void *a3)
{
  const __CFDictionary *v5;
  __CFDictionary *v6;
  unint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;
  void *Value;

  v5 = (const __CFDictionary *)CFRetain(cf);
  v6 = (__CFDictionary *)CFRetain(a3);
  v7 = a1;
  if (!CFDictionaryContainsKey(v6, (const void *)a1))
  {
    v8 = malloc_type_malloc(0x18uLL, 0x102004024DAA5DEuLL);
    v9 = v8;
    v10 = 10000;
    if (a1 > 716189595)
    {
      if (a1 == 716189596 || a1 == 856881155)
        goto LABEL_9;
    }
    else
    {
      if (a1 == 510259174)
      {
LABEL_9:
        v8[1] = v10;
        v8[2] = 1;
        v11 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 16 * v10 + 32, 0x6085D6BuLL);
        if (!v11)
          _log_fault_for_malloc_failure();
        *v9 = v11;
        *v11 = 0;
        v11[1] = 0;
        goto LABEL_12;
      }
      if (a1 == 679607404)
      {
        *(_OWORD *)(v8 + 1) = xmmword_1B8631BB0;
        *v8 = 0;
LABEL_12:
        CFDictionaryAddValue(v6, (const void *)v7, v9);
        goto LABEL_13;
      }
    }
    v10 = 50;
    goto LABEL_9;
  }
LABEL_13:
  Value = (void *)CFDictionaryGetValue(v6, (const void *)v7);
  CFDictionaryApplyFunction(v5, (CFDictionaryApplierFunction)heapifyDict, Value);
  CFRelease(v5);
  CFRelease(v6);
}

void emitTerms(uint64_t a1, uint64_t *a2)
{
  CFStringRef v3;
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  const void *v8;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD *v29;
  BOOL v30;
  char *v33;
  char *v34;
  const char *v35;
  uint64_t v36;

  if (!a1 || !a2)
  {
    v33 = __si_assert_copy_extra_521(-1);
    v34 = v33;
    v35 = "";
    if (v33)
      v35 = v33;
    __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 7264, "k && v", v35);
    free(v34);
    if (__valid_fs(-1))
      v36 = 2989;
    else
      v36 = 3072;
    *(_DWORD *)v36 = -559038737;
    abort();
  }
  v3 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%d"), a1);
  _MDPlistContainerAddObject();
  _MDPlistContainerBeginDictionary();
  v4 = *((_DWORD *)a2 + 4);
  v5 = v4 - 1;
  if (v4 == 1)
    goto LABEL_22;
  v6 = 0;
  do
  {
    v7 = a2[2];
    if (v7 == 1)
    {
      v8 = 0;
      goto LABEL_7;
    }
    v8 = *(const void **)(*a2 + 16);
    v9 = *(_OWORD *)(*a2 + 16 * v7 - 16);
    *(_OWORD *)(*a2 + 16) = v9;
    v11 = a2[1];
    v10 = a2[2];
    a2[2] = v10 - 1;
    v12 = v11 >> 1;
    v13 = 1;
    v14 = 2;
    v15 = 3;
    while (1)
    {
      v16 = *a2;
      v17 = (uint64_t *)(*a2 + 16 * v14);
      v19 = *v17;
      v18 = v17[1];
      if (v15 >= v10)
      {
        if (v14 >= v10)
          goto LABEL_7;
        v21 = 0;
        v22 = 0xFFFFFFFFLL;
      }
      else
      {
        v20 = (uint64_t *)(v16 + 16 * v15);
        v21 = *v20;
        v22 = v20[1];
      }
      if (DWORD2(v9) > v18)
      {
        if (v22 >= v18)
        {
          v22 = v18;
          v21 = v19;
          v15 = v14;
        }
        goto LABEL_15;
      }
      if (DWORD2(v9) <= v22)
        break;
LABEL_15:
      _X14 = v16 + 32 * v15;
      __asm { PRFM            #1, [X14] }
      if (v15 != v13)
      {
        v14 = 2 * v15;
        *(_OWORD *)(v16 + 16 * v15) = v9;
        v29 = (_QWORD *)(*a2 + 16 * v13);
        v13 = v15;
        *v29 = v21;
        v29[1] = v22;
        v30 = v15 < v12;
        v15 = (2 * v15) | 1;
        if (v30)
          continue;
      }
      goto LABEL_7;
    }
    _X8 = v16 + 32 * v13;
    __asm { PRFM            #1, [X8] }
LABEL_7:
    _MDPlistContainerAddObject();
    _MDPlistContainerAddInt32Value();
    CFRelease(v8);
    ++v6;
  }
  while (v6 != v5);
LABEL_22:
  _MDPlistContainerEndDictionary();
  CFRelease(v3);
}

void pqDisposeApplier(uint64_t a1, void **a2)
{
  free(*a2);
  free(a2);
}

void heapifyDict(const void *a1, unsigned int a2, uint64_t a3)
{
  CFTypeRef v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  size_t v11;
  _QWORD *v12;
  _DWORD *v13;
  unsigned int v14;
  __int128 v15;
  const void *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _OWORD *v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t *v27;
  uint64_t v28;
  uint64_t v29;
  _QWORD *v36;
  BOOL v37;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  size_t v45;
  _QWORD *v46;
  _QWORD *v47;
  _QWORD *v48;
  _OWORD *v49;
  unint64_t v50;
  __int128 v51;
  _QWORD *v52;
  _QWORD *v53;
  _OWORD *v54;
  unint64_t v55;
  __int128 v56;

  if (!a2)
    return;
  v5 = CFRetain(a1);
  v6 = a2;
  v7 = *(_QWORD *)(a3 + 16);
  if (v7 <= 20000)
  {
    v8 = *(_QWORD *)(a3 + 8);
    v9 = *(_QWORD *)(a3 + 16);
    if (v7 + 2 >= v8)
    {
      v10 = 2 * v8;
      if (v8 < 4)
        v10 = 4;
      *(_QWORD *)(a3 + 8) = v10;
      v11 = 16 * v10 + 32;
      if (*(_QWORD *)a3)
        v12 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, *(void **)a3, v11, 0xECA6AA46uLL);
      else
        v12 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v11, 0x8DDAA030uLL);
      v47 = v12;
      if (!v12)
        _log_fault_for_malloc_failure();
      *(_QWORD *)a3 = v47;
      *v47 = 0;
      v47[1] = 0;
      v9 = *(_QWORD *)(a3 + 16);
    }
    *(_QWORD *)(a3 + 16) = v9 + 1;
    v48 = (_QWORD *)(*(_QWORD *)a3 + 16 * v7);
    *v48 = v5;
    v48[1] = v6;
    if (v7 >= 2)
    {
      do
      {
        v49 = *(_OWORD **)a3;
        v50 = (unint64_t)v7 >> 1;
        if (*(_DWORD *)(*(_QWORD *)a3 + 16 * v7 + 8) > *(_DWORD *)(*(_QWORD *)a3 + 16 * ((unint64_t)v7 >> 1) + 8))
          break;
        v51 = v49[v7];
        v49[v7] = v49[v50];
        *(_OWORD *)(*(_QWORD *)a3 + 16 * v50) = v51;
        v37 = (unint64_t)v7 > 3;
        v7 = (unint64_t)v7 >> 1;
      }
      while (v37);
    }
    return;
  }
  v13 = *(_DWORD **)a3;
  if (*(_QWORD *)a3)
    v14 = v13[6];
  else
    v14 = 0;
  if (v14 >= a2)
    goto LABEL_47;
  v15 = *(_OWORD *)&v13[4 * v7 - 4];
  v16 = (const void *)*((_QWORD *)v13 + 2);
  *((_OWORD *)v13 + 1) = v15;
  v18 = *(_QWORD *)(a3 + 8);
  v17 = *(_QWORD *)(a3 + 16);
  *(_QWORD *)(a3 + 16) = v17 - 1;
  v19 = v18 >> 1;
  v20 = 3;
  v21 = 2;
  v22 = 1;
  while (1)
  {
    v23 = *(_OWORD **)a3;
    v24 = (uint64_t *)(*(_QWORD *)a3 + 16 * v21);
    v25 = *v24;
    v26 = v24[1];
    if (v20 >= v17)
    {
      if (v21 >= v17)
        goto LABEL_25;
      v28 = 0;
      v29 = 0xFFFFFFFFLL;
    }
    else
    {
      v27 = (uint64_t *)&v23[v20];
      v28 = *v27;
      v29 = v27[1];
    }
    if (DWORD2(v15) > v26)
    {
      if (v29 >= v26)
      {
        v29 = v26;
        v28 = v25;
        v20 = v21;
      }
      goto LABEL_18;
    }
    if (DWORD2(v15) <= v29)
      break;
LABEL_18:
    _X13 = (char *)&v23[2 * v20];
    __asm { PRFM            #1, [X13] }
    if (v20 == v22)
      goto LABEL_25;
    v21 = 2 * v20;
    v23[v20] = v15;
    v36 = (_QWORD *)(*(_QWORD *)a3 + 16 * v22);
    v22 = v20;
    *v36 = v28;
    v36[1] = v29;
    v37 = v20 < v19;
    v20 = (2 * v20) | 1;
    if (!v37)
    {
      v23 = *(_OWORD **)a3;
      goto LABEL_25;
    }
  }
  _X8 = (char *)&v23[2 * v22];
  __asm { PRFM            #1, [X8] }
LABEL_25:
  v40 = *(_QWORD *)(a3 + 8);
  v41 = *(_QWORD *)(a3 + 16);
  if ((uint64_t)(v41 + 2) >= v40)
  {
    v43 = 2 * v40;
    v37 = v40 < 4;
    v44 = 4;
    if (!v37)
      v44 = v43;
    *(_QWORD *)(a3 + 8) = v44;
    v45 = 16 * v44 + 32;
    if (v23)
      v46 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, v23, v45, 0xECA6AA46uLL);
    else
      v46 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v45, 0x8DDAA030uLL);
    v52 = v46;
    if (!v46)
      _log_fault_for_malloc_failure();
    *(_QWORD *)a3 = v52;
    *v52 = 0;
    v52[1] = 0;
    v42 = *(_QWORD *)(a3 + 16);
    v23 = *(_OWORD **)a3;
  }
  else
  {
    v42 = *(_QWORD *)(a3 + 16);
  }
  *(_QWORD *)(a3 + 16) = v42 + 1;
  v53 = &v23[v41];
  *v53 = v5;
  v53[1] = v6;
  v5 = v16;
  if ((uint64_t)v41 >= 2)
  {
    do
    {
      v54 = *(_OWORD **)a3;
      v55 = v41 >> 1;
      if (*(_DWORD *)(*(_QWORD *)a3 + 16 * v41 + 8) > *(_DWORD *)(*(_QWORD *)a3 + 16 * (v41 >> 1) + 8))
        break;
      v56 = v54[v41];
      v54[v41] = v54[v55];
      *(_OWORD *)(*(_QWORD *)a3 + 16 * v55) = v56;
      v37 = v41 > 3;
      v41 >>= 1;
    }
    while (v37);
    v5 = v16;
  }
LABEL_47:
  CFRelease(v5);
}

void sumDicts(const void *a1, const void *a2, CFTypeRef cf)
{
  __CFDictionary *v5;
  const __CFString *v6;
  SInt32 IntValue;
  unsigned int v8;
  const __CFDictionary *v9;
  const __CFDictionary *v10;
  CFTypeID v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  CFIndex v16;
  CFMutableDictionaryRef Mutable;
  void *Value;
  int v19;
  NSObject *v20;
  os_log_type_t v21;
  int v22;
  const __CFString *v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v5 = (__CFDictionary *)CFRetain(cf);
  v6 = (const __CFString *)CFRetain(a1);
  IntValue = CFStringGetIntValue(v6);
  if (IntValue)
  {
    v8 = IntValue;
    v9 = (const __CFDictionary *)CFRetain(a2);
    v10 = v9;
    if (v9)
    {
      v11 = CFGetTypeID(v9);
      if (v11 == CFDictionaryGetTypeID())
      {
        v12 = v8;
        if (!CFDictionaryContainsKey(v5, (const void *)v8))
        {
          v13 = 50;
          if (v8 == 679607404)
            v13 = 0;
          if (v8 == 856881155)
            v14 = 10000;
          else
            v14 = v13;
          if (v8 == 716189596)
            v15 = 10000;
          else
            v15 = v14;
          if (v8 == 510259174)
            v16 = 10000;
          else
            v16 = v15;
          Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v16, MEMORY[0x1E0C9B390], 0);
          CFDictionaryAddValue(v5, (const void *)v12, Mutable);
          CFRelease(Mutable);
        }
        Value = (void *)CFDictionaryGetValue(v5, (const void *)v12);
        CFDictionaryApplyFunction(v10, (CFDictionaryApplierFunction)sumDict, Value);
      }
    }
    CFRelease(v10);
    CFRelease(v5);
    CFRelease(v6);
  }
  else
  {
    v19 = *__error();
    v20 = _SILogForLogForCategory(0);
    v21 = gSILogLevels[0] < 3;
    if (os_log_type_enabled(v20, (os_log_type_t)(gSILogLevels[0] < 3)))
    {
      v22 = 138412290;
      v23 = v6;
      _os_log_impl(&dword_1B8270000, v20, v21, "*warn* Skipped deprecated topK bundleIndex %@", (uint8_t *)&v22, 0xCu);
    }
    *__error() = v19;
  }
}

void sumDict(const void *a1, const __CFNumber *a2, CFTypeRef cf)
{
  const __CFDictionary *v5;
  unsigned int Value;
  int valuePtr;

  v5 = (const __CFDictionary *)CFRetain(cf);
  Value = CFDictionaryGetValue(v5, a1);
  valuePtr = 0;
  CFNumberGetValue(a2, kCFNumberSInt32Type, &valuePtr);
  CFDictionarySetValue(v5, a1, (const void *)(valuePtr + Value));
  CFRelease(v5);
}

uint64_t __mergeOverlay_block_invoke(uint64_t a1, int a2, uint64_t *a3, int a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;

  result = *(_QWORD *)(a1 + 32);
  if (result)
    result = _CIMoveDirectory(result, a2, a3, a4, a5);
  v11 = *(_QWORD *)(a1 + 40);
  if (*(_DWORD *)(v11 + 8))
  {
    v12 = 0;
    do
    {
      result = CFSetContainsValue(*(CFSetRef *)(a1 + 48), (const void *)*(int *)(*(_QWORD *)(*(_QWORD *)v11 + 8 * v12) + 48));
      if ((_DWORD)result)
        result = _CIMoveDirectory(*(_QWORD *)(**(_QWORD **)(a1 + 40) + 8 * v12), a2, a3, a4, a5);
      ++v12;
      v11 = *(_QWORD *)(a1 + 40);
    }
    while (v12 < *(unsigned int *)(v11 + 8));
  }
  v13 = *(_QWORD *)(a1 + 56);
  if (*(_DWORD *)(v13 + 8))
  {
    v14 = 0;
    do
    {
      result = CFSetContainsValue(*(CFSetRef *)(a1 + 48), (const void *)*(int *)(*(_QWORD *)(*(_QWORD *)v13 + 8 * v14) + 48));
      if ((_DWORD)result)
        result = _CIMoveDirectory(*(_QWORD *)(**(_QWORD **)(a1 + 56) + 8 * v14), a2, a3, a4, a5);
      ++v14;
      v13 = *(_QWORD *)(a1 + 56);
    }
    while (v14 < *(unsigned int *)(v13 + 8));
  }
  return result;
}

void __mergeOverlay_block_invoke_2(uint64_t a1)
{
  NSObject *v2;
  __int128 v3;
  _QWORD v4[4];
  __int128 v5;
  __int128 v6;

  v2 = *(NSObject **)(a1 + 32);
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 0x40000000;
  v4[2] = __mergeOverlay_block_invoke_3;
  v4[3] = &__block_descriptor_tmp_188;
  v3 = *(_OWORD *)(a1 + 56);
  v5 = *(_OWORD *)(a1 + 40);
  v6 = v3;
  dispatch_barrier_async(v2, v4);
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
}

void __mergeOverlay_block_invoke_3(uint64_t a1)
{
  NSObject *v2;
  _QWORD block[4];
  __int128 v4;
  uint64_t v5;

  v2 = *(NSObject **)(a1 + 32);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __mergeOverlay_block_invoke_4;
  block[3] = &__block_descriptor_tmp_187;
  v4 = *(_OWORD *)(a1 + 40);
  v5 = *(_QWORD *)(a1 + 56);
  dispatch_barrier_async(v2, block);
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
}

void __mergeOverlay_block_invoke_4(uint64_t a1)
{
  NSObject *v2;
  _QWORD v3[4];
  __int128 v4;

  v2 = *(NSObject **)(a1 + 32);
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 0x40000000;
  v3[2] = __mergeOverlay_block_invoke_5;
  v3[3] = &__block_descriptor_tmp_186;
  v4 = *(_OWORD *)(a1 + 40);
  dispatch_barrier_async(v2, v3);
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
}

void __mergeOverlay_block_invoke_5(uint64_t a1)
{
  uint64_t v2;
  unsigned int v3;
  unsigned int v4;
  _QWORD *v5;
  _QWORD *v6;

  v2 = *(_QWORD *)(a1 + 32);
  do
  {
    v3 = __ldaxr((unsigned int *)v2);
    v4 = v3 - 1;
  }
  while (__stlxr(v4, (unsigned int *)v2));
  if (!v4)
  {
    pthread_rwlock_destroy((pthread_rwlock_t *)(v2 + 240));
    pthread_rwlock_destroy((pthread_rwlock_t *)(v2 + 8));
    free(*(void **)(v2 + 448));
    freeOverlayDir(v2 + 208);
    v5 = *(_QWORD **)(v2 + 456);
    if (v5)
    {
      do
      {
        v6 = (_QWORD *)*v5;
        free(v5);
        v5 = v6;
      }
      while (v6);
    }
    free((void *)v2);
  }
  CFRelease(*(CFTypeRef *)(a1 + 40));
}

uint64_t triePropertyID(_BYTE *a1, unsigned int a2)
{
  uint64_t result;
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  unsigned __int8 *v6;
  int *v7;
  uint64_t v8;
  int v9;
  int v10;
  char *v11;
  char *v12;
  const char *v13;
  uint64_t v14;
  int v15;
  __int16 v16;

  if (a2 < 3 || *a1 != 1)
    return 0;
  if (a1[a2 - 1] == 1 && a1[a2 - 2] == 1)
    return 1;
  v16 = 0;
  v15 = 0;
  if (a1[1] == 2)
    v3 = 2;
  else
    v3 = 1;
  LODWORD(v4) = a2 - v3;
  if ((int)(a2 - v3) < 1)
  {
    v7 = &v15;
  }
  else
  {
    if ((int)v4 >= 5)
      v4 = 5;
    else
      v4 = v4;
    v5 = v4 - 1;
    v6 = &a1[v3];
    v7 = &v15;
    do
    {
      v8 = v5;
      v9 = *v6++;
      v10 = tcmr[v9];
      *(_BYTE *)v7 = tcmr[v9];
      v7 = (int *)((char *)v7 + 1);
      if ((v10 & 0x80000000) == 0)
        break;
      v5 = v8 - 1;
    }
    while (v8);
  }
  *(_BYTE *)v7 = 0;
  result = v15;
  if ((char)v15 < 0)
  {
    if (SBYTE1(v15) < 0)
    {
      if (SBYTE2(v15) < 0)
      {
        if (SHIBYTE(v15) < 0)
        {
          if ((char)v16 < 0)
          {
            v11 = __si_assert_copy_extra_521(-1);
            v12 = v11;
            v13 = "";
            if (v11)
              v13 = v11;
            __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t", "VIntUtils.h", 341, "(b4 & 0x80) == 0", v13);
            free(v12);
            if (__valid_fs(-1))
              v14 = 2989;
            else
              v14 = 3072;
            *(_DWORD *)v14 = -559038737;
            abort();
          }
          return ((HIBYTE(v15) & 0x7F) << 21) | (v16 << 28) | ((BYTE2(v15) & 0x7F) << 14) | ((BYTE1(v15) & 0x7F) << 7) | v15 & 0x7Fu;
        }
        else
        {
          return ((BYTE2(v15) & 0x7F) << 14) | (HIBYTE(v15) << 21) | ((BYTE1(v15) & 0x7F) << 7) | v15 & 0x7Fu;
        }
      }
      else
      {
        return ((BYTE1(v15) & 0x7F) << 7) | (BYTE2(v15) << 14) | v15 & 0x7Fu;
      }
    }
    else
    {
      return v15 & 0x7F | (BYTE1(v15) << 7);
    }
  }
  return result;
}

void __si_merge_term_filter_ctx_init_block_invoke_3(uint64_t a1, CFIndex idx)
{
  CFIndex v3;

  v3 = idx;
  bit_vector_set(*(_QWORD *)(a1 + 32), idx);
  bit_vector_set(*(_QWORD *)(a1 + 40), v3);
}

void __si_merge_term_filter_ctx_init_block_invoke_4(uint64_t a1, CFIndex idx)
{
  bit_vector_set(*(_QWORD *)(a1 + 32), idx);
}

void si_deferqueue_cleanup(_QWORD *a1, int a2)
{
  uint64_t v3;
  unsigned int *v4;
  unsigned int v5;
  unsigned int v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  NSObject *v12;
  NSObject *v13;
  _QWORD *v14;
  uint64_t v15;
  _QWORD v16[6];
  _QWORD block[5];

  if (!a2)
  {
    pthread_mutex_lock((pthread_mutex_t *)(a1[3] + 1320));
    v7 = (_QWORD *)(a1[3] + 1168);
    v9 = (_QWORD *)*a1;
    v8 = a1[1];
    while (1)
    {
      v10 = v7;
      v7 = (_QWORD *)*v7;
      if (!v7)
        break;
      if ((_QWORD *)v7[1] == v9)
      {
        *v10 = *v7;
        free(v7);
        break;
      }
    }
    if (*v9 == v8)
    {
      v11 = MEMORY[0x1E0C809B0];
      v12 = *(NSObject **)(v8 + 32);
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 0x40000000;
      block[2] = __si_scheduler_remove_and_destroy_block_invoke;
      block[3] = &__block_descriptor_tmp_14_990;
      block[4] = v8;
      dispatch_sync(v12, block);
      v13 = v9[2];
      v16[0] = v11;
      v16[1] = 0x40000000;
      v16[2] = __si_scheduler_remove_and_destroy_block_invoke_2;
      v16[3] = &__block_descriptor_tmp_15_991;
      v16[4] = v9;
      v16[5] = v8;
      dispatch_barrier_async(v13, v16);
    }
    pthread_mutex_unlock((pthread_mutex_t *)(a1[3] + 1320));
    v14 = (_QWORD *)a1[3];
    if (v14 && v14[148] && v14[130] && v14[(v14[137] != 0) + 126])
    {
      si_sync_ctx_create_with_defer_fd(a1[3], a1[2]);
      si_enqueue_work_with_qos(v14[137], 9, (uint64_t)si_sync_index_delayed0, v15);
    }
  }
  v3 = a1[1];
  if (v3)
  {
    v4 = (unsigned int *)(v3 + 80);
    do
    {
      v5 = __ldaxr(v4);
      v6 = v5 - 1;
    }
    while (__stlxr(v6, v4));
    if (!v6)
      _si_scheduler_destroy(v3);
  }
  free(a1);
}

uint64_t _CreateDeferQueue(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  pthread_mutex_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v14;
  char *v15;
  const char *v16;
  uint64_t v17;

  v8 = (pthread_mutex_t *)(a1 + 1320);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1320));
  if (*(_QWORD *)(a1 + 1144))
  {
    v14 = __si_assert_copy_extra_521(-1);
    v15 = v14;
    v16 = "";
    if (v14)
      v16 = v14;
    __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 6404, "!ref->workqueues.queues[SI_DEFER_QUEUE_IDX]", v16);
    free(v15);
    if (__valid_fs(-1))
      v17 = 2989;
    else
      v17 = 3072;
    *(_DWORD *)v17 = -559038737;
    abort();
  }
  *(_QWORD *)(a1 + 1144) = si_create_child_queue(*(_QWORD *)(a1 + 872));
  v9 = *a2;
  *(_QWORD *)(a1 + 1304) = *(_QWORD *)(*(_QWORD *)(*a2 + 8 * a3) + 72);
  v10 = *(_QWORD *)(v9 + 8 * (a3 + a4) - 8);
  LODWORD(v11) = *(_DWORD *)(v10 + 60);
  v12 = *(_QWORD *)(v10 + 72);
  if (v11 >= 2)
    v11 = v11;
  else
    v11 = 0;
  *(_QWORD *)(a1 + 1312) = v12 + v11;
  return pthread_mutex_unlock(v8);
}

uint64_t new_live_index(uint64_t a1, int a2, unint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  const __CFString *v8;
  int v9;
  int v10;
  uint64_t v11;
  __int16 v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  int v17;
  int v18;
  int *v19;
  uint64_t vector_store;
  uint64_t New;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  int v27;
  int v28;
  int *v29;
  uint64_t v30;
  _DWORD *v31;
  int v32;
  int v33;
  uint64_t v34;
  int v35;
  int v36;
  _QWORD *v37;
  unint64_t v38;
  unsigned int v39;
  unsigned int v40;
  unint64_t *v41;
  unint64_t v42;
  unsigned int *v43;
  unsigned int v44;
  int v45;
  char *v47;
  char *v48;
  const char *v49;
  uint64_t v50;
  int v51;
  _QWORD aBlock[6];
  _QWORD v53[5];
  _QWORD v54[5];
  _QWORD v55[5];
  unsigned int v56;
  char __str[1024];
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  v6 = *(_QWORD *)(a1 + 1384);
  v7 = *(unsigned int *)(v6 + 8);
  v56 = 0;
  if (!fd_setDir(*(unsigned int *)(a1 + 32), (int *)&v56))
    return 0;
  v51 = a2;
  v8 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("live.%d."), v7);
  v9 = ((*(_DWORD *)(a1 + 828) & 1) << 6) ^ 0x50;
  if (*(_BYTE *)(a1 + 2072))
    v9 |= 0x100u;
  if (*(_BYTE *)(a1 + 2073))
    v9 |= 0x400u;
  v10 = v9 | (*(_DWORD *)(a1 + 6584) >> 7) & 0x800;
  v11 = MEMORY[0x1E0C809B0];
  if (*(_BYTE *)(a1 + 6944))
    v12 = v10 | 0x1000;
  else
    v12 = v10;
  v55[0] = MEMORY[0x1E0C809B0];
  v55[1] = 0x40000000;
  v55[2] = __new_live_index_block_invoke;
  v55[3] = &__block_descriptor_tmp_662;
  v55[4] = a1;
  if ((_DWORD)v7)
  {
    v13 = *(_QWORD *)(*(_QWORD *)v6 + 8 * (v7 - 1));
    LODWORD(v14) = *(_DWORD *)(v13 + 60);
    if (v14 >= 2)
      v14 = v14;
    else
      v14 = 0;
    v15 = *(_QWORD *)(v13 + 72) + v14;
    if (v15 > a3)
      a3 = v15;
    v16 = *(unsigned int *)(a1 + 32);
    v17 = *(_DWORD *)(v13 + 32);
    v18 = *(_DWORD *)(a1 + 1276);
    v19 = *(int **)(a1 + 1184);
    if (v19)
      vector_store = db_get_vector_store(v19);
    else
      vector_store = 0;
    v53[0] = v11;
    v53[1] = 0x40000000;
    v53[2] = __new_live_index_block_invoke_3;
    v53[3] = &__block_descriptor_tmp_664;
    v53[4] = a1;
    New = ContentIndexCreateNew(v16, v8, a3, v17, v12, 1, v18, vector_store, (uint64_t)v53, v55);
    v31 = *(_DWORD **)(*(_QWORD *)v6 + 8 * (*(_DWORD *)(v6 + 8) - 1));
    v32 = a3;
    v33 = 6616;
  }
  else
  {
    v22 = *(uint64_t **)(a1 + 1392);
    v23 = *(_QWORD *)(*v22 + 8 * (*((_DWORD *)v22 + 2) - 1));
    LODWORD(v24) = *(_DWORD *)(v23 + 60);
    if (v24 >= 2)
      v24 = v24;
    else
      v24 = 0;
    v25 = *(_QWORD *)(v23 + 72) + v24;
    if (v25 > a3)
      a3 = v25;
    v26 = *(unsigned int *)(a1 + 32);
    v27 = *(_DWORD *)(v23 + 32);
    v28 = *(_DWORD *)(a1 + 1276);
    v29 = *(int **)(a1 + 1184);
    if (v29)
      v30 = db_get_vector_store(v29);
    else
      v30 = 0;
    v54[0] = MEMORY[0x1E0C809B0];
    v54[1] = 0x40000000;
    v54[2] = __new_live_index_block_invoke_2;
    v54[3] = &__block_descriptor_tmp_663;
    v54[4] = a1;
    New = ContentIndexCreateNew(v26, v8, a3, v27, v12, 1, v28, v30, (uint64_t)v54, v55);
    v34 = *v22;
    v35 = *((_DWORD *)v22 + 2);
    v11 = MEMORY[0x1E0C809B0];
    v31 = *(_DWORD **)(v34 + 8 * (v35 - 1));
    v32 = a3;
    v33 = 6611;
  }
  _ContentIndexSetPayloadMaxCount(v31, v32, v33);
  CFRelease(v8);
  if (New)
  {
    SIActivityJournalNewLiveIndex((os_unfair_lock_s *)(a1 + 2192), v7, a3);
    v36 = *(_DWORD *)(v6 + 8);
    if (v36)
      ContentIndexSetEmergency((int *)New, *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)v6 + 8 * (v7 - 1)) + 36));
    aBlock[0] = v11;
    aBlock[1] = 0x40000000;
    aBlock[2] = __new_live_index_block_invoke_4;
    aBlock[3] = &__block_descriptor_tmp_665;
    aBlock[4] = a1;
    aBlock[5] = New;
    ContentIndexSetDirtyCallback(New, aBlock);
    *(_BYTE *)(New + 15161) = 4;
    v37 = ContentIndexListClone((__int128 *)v6);
    v38 = (unint64_t)v37;
    v39 = *((_DWORD *)v37 + 3);
    if (v39 <= *((_DWORD *)v37 + 2))
    {
      v40 = 2 * v39;
      *((_DWORD *)v37 + 3) = v40;
      *v37 = malloc_type_realloc((void *)*v37, 8 * v40, 0x2004093837F09uLL);
    }
    v41 = (unint64_t *)(a1 + 1384);
    bzero(__str, 0x400uLL);
    snprintf(__str, 0x400uLL, "live.%d.", v7);
    ContentIndexChangePrefix(New);
    *(_QWORD *)(*(_QWORD *)v38 + 8 * v7) = New;
    *(_DWORD *)(v38 + 16) = v7;
    ++*(_DWORD *)(v38 + 8);
    do
    {
      v42 = __ldaxr(v41);
      if (v42 != v6)
      {
        __clrex();
        v47 = __si_assert_copy_extra_521(*(_DWORD *)(a1 + 32));
        v48 = v47;
        v49 = "";
        if (v47)
          v49 = v47;
        __message_assert("%s:%u: failed assertion '%s' %s This should be impossible; this thread is supposed to be  suspended when the o"
          "ther thread changes index sets.",
          "SpotlightIndex.c",
          6647,
          "OSAtomicCompareAndSwapPtrBarrier(oldIndexSet,indexSet,(void* volatile*)indexSetPtr)",
          v49);
        free(v48);
        if (__valid_fs(*(_DWORD *)(a1 + 32)))
          v50 = 2989;
        else
          v50 = 3072;
        *(_DWORD *)v50 = -559038737;
        abort();
      }
    }
    while (__stlxr(v38, v41));
    si_write_index_state(a1, 1, 0);
    if (v51)
    {
      si_cleanup(a1, v6);
      v43 = (unsigned int *)(a1 + 1400);
      do
        v44 = __ldxr(v43);
      while (__stxr(v44 + 1, v43));
      if (v36)
        goto LABEL_41;
    }
    else
    {
      free(*(void **)v6);
      free((void *)v6);
      if (v36)
      {
LABEL_41:
        _CIDisableUpdates(*(_QWORD *)(*(_QWORD *)v38 + 8 * (v7 - 1)));
        New = *(_QWORD *)(*(_QWORD *)v38 + 8 * (v7 - 1));
      }
    }
  }
  v45 = v56;
  MEMORY[0x1BCCB1484](v56);
  if ((v45 & 0x80000000) == 0)
    close(v45);
  return New;
}

void si_recycleForBadIndex(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6;
  NSObject *v7;
  unsigned __int8 v8;
  unsigned int v9;
  CFStringRef v10;
  uint8_t buf[4];
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v6 = *__error();
  v7 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136315650;
    v12 = "si_recycleForBadIndex";
    v13 = 1024;
    v14 = 15609;
    v15 = 2080;
    v16 = a3;
    _os_log_error_impl(&dword_1B8270000, v7, OS_LOG_TYPE_ERROR, "%s:%d: recycle %s", buf, 0x1Cu);
  }
  *__error() = v6;
  _CIMakeInvalid(a2);
  if (a1)
  {
    v8 = atomic_load((unsigned __int8 *)(a1 + 2439));
    if ((v8 & 1) == 0)
    {
      if (SIIsAppleInternal_onceToken != -1)
        dispatch_once(&SIIsAppleInternal_onceToken, &__block_literal_global_4644);
      if (SIIsAppleInternal_internal)
      {
        do
          v9 = __ldxr(si_recycleForBadIndex__crashCount);
        while (__stxr(v9 + 1, si_recycleForBadIndex__crashCount));
        if (!v9)
        {
          v10 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("recycle, message:%s"), a3);
          getpid();
          SISimulateCrashForPid(0, (uint64_t)v10);
          if (v10)
            CFRelease(v10);
        }
      }
    }
  }
  si_makeUnavailable(a1, 22, 2, 7, a3);
}

uint64_t __new_live_index_block_invoke_2(uint64_t a1, uint64_t a2)
{
  return _si_next_index_id(*(os_unfair_lock_s **)(a1 + 32), a2, 1, 0);
}

uint64_t __new_live_index_block_invoke_3(uint64_t a1, uint64_t a2)
{
  return _si_next_index_id(*(os_unfair_lock_s **)(a1 + 32), a2, 1, 0);
}

uint64_t __new_live_index_block_invoke_4(uint64_t a1)
{
  return si_set_obj_state(*(os_unfair_lock_s **)(a1 + 32), *(_QWORD *)(a1 + 40));
}

void __transfer_live_indexes_block_invoke(uint64_t a1, const void *a2)
{
  si_collect_block(*(_QWORD *)(a1 + 32), a2);
}

uint64_t __transfer_live_indexes_block_invoke_2(uint64_t a1, uint64_t a2)
{
  return _si_next_index_id(*(os_unfair_lock_s **)(a1 + 32), a2, 1, 0);
}

uint64_t __transfer_live_indexes_block_invoke_3(uint64_t a1)
{
  return si_set_obj_state(*(os_unfair_lock_s **)(a1 + 32), *(_QWORD *)(a1 + 40));
}

void __si_scanEnded_block_invoke(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, NSObject *a5)
{
  if (a2)
    setupAndIssueMergeScan(a2, *(_DWORD *)(a1 + 32), a3, a4, a5);
}

void setupAndIssueMergeScan(uint64_t a1, int a2, void *a3, uint64_t a4, NSObject *a5)
{
  BOOL v9;
  int v10;
  BOOL v11;
  char *v12;
  _DWORD *v13;
  uint64_t v14;
  uint64_t (*v15)(_QWORD, const char *, uint64_t, const char *);
  int v16;
  int v17;

  v16 = 0;
  v17 = a2;
  v9 = si_needsVaccuum(*(uint64_t **)(a1 + 1384), &v17, &v16);
  v10 = v16;
  if (v16)
  {
    v11 = v9;
    v12 = (char *)malloc_type_calloc(1uLL, 0x460uLL, 0x1070040C187FD8AuLL);
    *(_QWORD *)v12 = a1;
    v12[16] = 1;
    v12[1041] = v11;
    *((_DWORD *)v12 + 2) = v17;
    *((_DWORD *)v12 + 3) = v10;
    v12[1042] = 0;
    *((_QWORD *)v12 + 131) = "void setupAndIssueMergeScan(SIRef, int32_t, _Bool, xpc_activity_t, _Bool *, dispatch_group_t)";
    *((_DWORD *)v12 + 274) = 6;
    v12[1100] = 1;
    __strlcpy_chk();
    v13 = v12 + 1064;
    si_power_info_init((uint64_t)(v12 + 1064), a3, a4, a5);
    if (!*((_QWORD *)v12 + 136) && !*v13)
    {
      v14 = *(_QWORD *)(a1 + 2360);
      if (v14)
      {
        v15 = *(uint64_t (**)(_QWORD, const char *, uint64_t, const char *))(v14 + 64);
        if (v15)
          *v13 = v15(*(_QWORD *)(v14 + 136), "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 8657, "void setupAndIssueMergeScan(SIRef, int32_t, _Bool, xpc_activity_t, _Bool *, dispatch_group_t)");
      }
    }
    si_enqueue_work(*(_QWORD *)(a1 + 1056), (uint64_t)si_mergeIndex, (uint64_t)v12);
  }
}

BOOL si_needsVaccuum(uint64_t *a1, _DWORD *a2, _DWORD *a3)
{
  unsigned int v3;
  uint64_t v4;
  int v5;
  char v6;
  _DWORD *v7;
  _DWORD *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v15;
  int v16;
  unsigned int *v17;
  uint64_t v18;

  *a3 = 0;
  v3 = *((_DWORD *)a1 + 2);
  v4 = *a1;
  if (!v3)
    goto LABEL_13;
  v5 = 0;
  v6 = 0;
  v7 = 0;
LABEL_3:
  --v3;
  do
  {
    v8 = *(_DWORD **)(v4 + 8 * v3);
    if (v8[12] == *a2)
    {
      v5 = v8[8];
      v6 = 1;
      *a3 = 1;
      v7 = v8;
      if (v3)
        goto LABEL_3;
      goto LABEL_10;
    }
    --v3;
  }
  while (v3 != -1);
  v8 = v7;
  if ((v6 & 1) == 0)
    goto LABEL_13;
LABEL_10:
  v9 = *((unsigned int *)a1 + 2);
  if ((_DWORD)v9)
  {
    while (*(_DWORD *)(*(_QWORD *)(v4 + 8 * v9 - 8) + 32) != v5)
    {
      if (!--v9)
        goto LABEL_13;
    }
    v11 = 0;
    v10 = 0;
    v15 = 8 * (v9 - 1);
    v16 = v9;
    while (1)
    {
      v4 = *a1;
      v17 = *(unsigned int **)(*a1 + v15);
      if (v17[8] != v5 && v17[11] != v8[11])
        break;
      ++*a3;
      v18 = atomic_load(v17 + 3);
      v10 += v18;
      LODWORD(v18) = v17[15];
      if (v18 >= 2)
        v18 = v18;
      else
        v18 = 0;
      v11 += v18;
      v15 -= 8;
      if (!--v16)
      {
        v4 = *a1;
        break;
      }
    }
    v12 = v9 - *a3;
  }
  else
  {
LABEL_13:
    v10 = 0;
    v11 = 0;
    v12 = 0;
  }
  v13 = *(_QWORD *)(v4 + 8 * (v12 & ~(v12 >> 31)));
  if (!v13)
    return 0;
  *a2 = *(_DWORD *)(v13 + 48);
  return v11 < 3 * v10;
}

_DWORD *si_getSyncIndex(uint64_t a1, int a2)
{
  uint64_t *v3;
  uint64_t *v4;
  uint64_t v5;
  int v6;
  uint64_t i;
  uint64_t v8;
  char v9;
  uint64_t v10;
  char v11;
  uint64_t v12;
  uint64_t v13;
  char v14;
  uint64_t v15;
  uint64_t v16;
  char v17;
  uint64_t v18;
  uint64_t v19;
  _DWORD *LiveIndex;
  char v21;
  int v22;
  NSObject *v23;
  char *v25;
  char *v26;
  const char *v27;
  uint64_t v28;
  int v29;
  char *v30;
  const char *v31;
  char *v32;
  const char *v33;
  char *v34;
  char *v35;
  const char *v36;
  uint64_t v37;
  uint8_t buf[4];
  const char *v39;
  __int16 v40;
  int v41;
  __int16 v42;
  int v43;
  __int16 v44;
  int v45;
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  v3 = *(uint64_t **)(a1 + 1392);
  v4 = *(uint64_t **)(a1 + 1384);
  v5 = *((unsigned int *)v3 + 2);
  if ((int)v5 >= 1)
  {
    LOBYTE(v6) = 0;
    for (i = v5 + 1; i > 1; --i)
    {
      if ((v6 & 1) != 0)
      {
        v5 = (v5 - 1);
      }
      else
      {
        v5 = (v5 - 1);
        v8 = *(_QWORD *)(*v3 + 8 * v5);
        v9 = atomic_load((unsigned int *)(v8 + 28));
        if ((v9 & 3) == 0)
        {
          v6 = *(unsigned __int8 *)(v8 + 15163);
          if (!v6)
            continue;
        }
      }
      v10 = *(_QWORD *)(*v3 + 8 * v5);
      v11 = atomic_load((unsigned int *)(v10 + 28));
      if ((v11 & 3) == 0 && !*(_BYTE *)(v10 + 15163))
      {
        v25 = __si_assert_copy_extra_521(-1);
        v26 = v25;
        v27 = "";
        if (v25)
          v27 = v25;
        __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 9228, "!ContentIndexWritable(indexSet->index[i-1])", v27);
LABEL_35:
        free(v26);
        if (__valid_fs(-1))
          v28 = 2989;
        else
          v28 = 3072;
        *(_DWORD *)v28 = -559038737;
        abort();
      }
      LOBYTE(v6) = 1;
    }
  }
  v12 = *((int *)v4 + 4);
  if ((_DWORD)v12 != -1)
  {
    v13 = *(_QWORD *)(*v4 + 8 * v12);
    v14 = atomic_load((unsigned int *)(v13 + 28));
    if ((v14 & 3) != 0 || *(_BYTE *)(v13 + 15163))
    {
      v34 = __si_assert_copy_extra_521(-1);
      v35 = v34;
      v36 = "";
      if (v34)
        v36 = v34;
      __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 9231, "indexLiveSet->currentIndex==~0 || ContentIndexWritable(indexLiveSet->index[indexLiveSet->currentIndex])", v36);
      free(v35);
      if (__valid_fs(-1))
        v37 = 2989;
      else
        v37 = 3072;
      *(_DWORD *)v37 = -559038737;
      abort();
    }
  }
  v15 = *((int *)v3 + 4);
  if ((_DWORD)v15 != -1)
  {
    v16 = *(_QWORD *)(*v3 + 8 * v15);
    v17 = atomic_load((unsigned int *)(v16 + 28));
    if ((v17 & 3) == 0 && !*(_BYTE *)(v16 + 15163))
    {
      v19 = *v3;
      v18 = *((int *)v3 + 4);
      goto LABEL_19;
    }
  }
  v18 = *((int *)v4 + 4);
  if ((_DWORD)v18 != -1)
  {
    v19 = *v4;
LABEL_19:
    LiveIndex = *(_DWORD **)(v19 + 8 * v18);
    goto LABEL_21;
  }
  LiveIndex = si_getLiveIndex(*(_QWORD *)(a1 + 1384));
LABEL_21:
  if (*LiveIndex != -1163003219)
  {
    v30 = __si_assert_copy_extra_521(-1);
    v26 = v30;
    v31 = "";
    if (v30)
      v31 = v30;
    __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 9240, "ContentIndexValidIndex(cindex)", v31);
    goto LABEL_35;
  }
  v21 = atomic_load(LiveIndex + 7);
  if ((v21 & 3) != 0 || *((_BYTE *)LiveIndex + 15163))
  {
    v32 = __si_assert_copy_extra_521(-1);
    v26 = v32;
    v33 = "";
    if (v32)
      v33 = v32;
    __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 9241, "ContentIndexWritable(cindex)", v33);
    goto LABEL_35;
  }
  if (a2 && LiveIndex[8] != a2 && !*((_BYTE *)LiveIndex + 36))
  {
    v22 = *__error();
    v23 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      v29 = LiveIndex[8];
      *(_DWORD *)buf = 136315906;
      v39 = "si_getSyncIndex";
      v40 = 1024;
      v41 = 9244;
      v42 = 1024;
      v43 = a2;
      v44 = 1024;
      v45 = v29;
      _os_log_error_impl(&dword_1B8270000, v23, OS_LOG_TYPE_ERROR, "%s:%d: Unexpected transaction id %d != %d", buf, 0x1Eu);
    }
    *__error() = v22;
  }
  return LiveIndex;
}

uint64_t si_mergeOneIndex(uint64_t a1, uint64_t a2)
{
  __int128 *v4;
  uint64_t *v5;
  int v6;
  BOOL v7;
  _BYTE *v8;
  uint64_t v9;
  int v10;
  unsigned int v12;
  _BYTE v13[1024];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v12 = 0;
  if (!fd_setDir(*(unsigned int *)(a1 + 32), (int *)&v12))
    return 0;
  v4 = *(__int128 **)(a1 + 1384);
  v5 = ContentIndexListClone(v4);
  bzero(v13, 0x400uLL);
  v6 = fcntl(*(_DWORD *)(a1 + 32), 50, v13);
  if (v13[0])
    v7 = v6 < 0;
  else
    v7 = 1;
  if (v7)
    v8 = 0;
  else
    v8 = v13;
  v9 = OuterMerge(a1, *(_DWORD *)(a2 + 48), 1u, (__int128 **)(a1 + 1384), (uint64_t)v4, v5, (uint64_t)v8, "live.%d.", 0, 1u);
  v10 = v12;
  MEMORY[0x1BCCB1484](v12);
  if ((v10 & 0x80000000) == 0)
    close(v10);
  return v9;
}

uint64_t si_indexIdForOID(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v4 = *(_QWORD *)(a1 + 1384);
  v5 = *(unsigned int *)(v4 + 8);
  if ((_DWORD)v5)
  {
    v6 = v5 - 1;
    while (1)
    {
      v7 = *(_QWORD *)(*(_QWORD *)v4 + 8 * v6);
      if (v7)
      {
        result = _CIDocIdForOID(v7, a2);
        if (result)
          break;
      }
      if ((unint64_t)--v6 >= 0xFFFFFFFFFFFFFFFELL)
        goto LABEL_6;
    }
  }
  else
  {
LABEL_6:
    v9 = *(_QWORD *)(a1 + 1392);
    v10 = *(unsigned int *)(v9 + 8);
    if ((_DWORD)v10)
    {
      v11 = v10 - 1;
      while (1)
      {
        v12 = *(_QWORD *)(*(_QWORD *)v9 + 8 * v11);
        if (v12)
        {
          result = _CIDocIdForOID(v12, a2);
          if (result)
            break;
        }
        if ((unint64_t)--v11 >= 0xFFFFFFFFFFFFFFFELL)
          return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t SICreateIndex(uint64_t *a1, const __CFString *a2, uint64_t a3, uint64_t a4, uint64_t a5, _QWORD *a6, _QWORD *a7, _QWORD *a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t result;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  __int128 v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;
  char buffer[1024];
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  bzero(buffer, 0x400uLL);
  if (!CFStringGetFileSystemRepresentation(a2, buffer, 1024))
    return 0xFFFFFFFFLL;
  result = open(buffer, 1081344);
  if ((_DWORD)result != -1)
  {
    v20 = result;
    if (a6 && a7 && a8)
    {
      v34 = 0;
      v32 = 0u;
      v33 = 0u;
      v30 = 0u;
      v31 = 0u;
      v28 = 0u;
      v29 = 0u;
      v26 = *(_OWORD *)a9;
      v27 = *(_QWORD *)(a9 + 16);
      v21 = a11;
      result = _SIOpenIndex((uint64_t)a1, result, a3, a4, a5, (uint64_t)&v28, (uint64_t)&v26, a10, a11, 0, &SICreateIndex_cancel);
      if ((result & 0x80000000) == 0)
      {
        v22 = *((_QWORD *)&v31 + 1);
        v23 = v29;
        v24 = *((_QWORD *)&v28 + 1);
        *a6 = *((_QWORD *)&v29 + 1) + v31 + v28;
        v25 = *((_QWORD *)&v30 + 1);
        *a7 = v30 + v22 + v24;
        *a8 = v25 + v32 + v23;
      }
    }
    else
    {
      v28 = *(_OWORD *)a9;
      *(_QWORD *)&v29 = *(_QWORD *)(a9 + 16);
      v21 = a11;
      result = _SIOpenIndex((uint64_t)a1, result, a3, a4, a5, 0, (uint64_t)&v28, a10, a11, 0, &SICreateIndex_cancel);
    }
    if ((a5 & 6) == 2 && (result & 0x80000000) != 0)
    {
      if (a6)
        *a6 = 0;
      if (a7)
        *a7 = 0;
      if (a8)
        *a8 = 0;
      v28 = *(_OWORD *)a9;
      *(_QWORD *)&v29 = *(_QWORD *)(a9 + 16);
      LODWORD(result) = SICreateNewIndex(a1, v20, a3, a4, a5, &v28, a10, v21, &SICreateIndex_cancel);
      if (result <= 1)
        return 1;
      else
        return result;
    }
  }
  return result;
}

uint64_t _SIOpenIndex(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, _BYTE *a10, _DWORD *a11)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  uint64_t v22;
  int v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int v27;
  uint64_t v28;
  unsigned int v29;
  int v30;
  uint64_t v31;
  int v32;
  int v33;
  _QWORD *v34;
  uint64_t v35;
  unsigned int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  void (*v42)(uint64_t);
  const void *v43;
  unsigned int v45;
  int v46;
  _BOOL4 v47;
  int v48;
  int v49;
  unsigned int v50;
  int v51;
  int v52;
  unsigned int v53;
  int v54;
  uint64_t v55;
  uint64_t v56;
  char *v57;
  char *v58;
  const char *v59;
  uint64_t v60;
  __int16 v61;
  unsigned int v62;
  unsigned int v63;
  int v64;
  int v65;
  int v66;
  NSObject *v67;
  const char *v68;
  int *v69;
  uint64_t v70;
  NSObject *v71;
  os_log_type_t v72;
  int v73;
  _BYTE *v74;
  BOOL v75;
  int v76;
  int v77;
  int v78;
  NSObject *v79;
  os_log_type_t v80;
  uint64_t v81;
  int v82;
  _BYTE *v83;
  BOOL v84;
  int v85;
  NSObject *v86;
  int v87;
  NSObject *v88;
  int v89;
  _DWORD *v90;
  void *v91;
  uint64_t v92;
  _DWORD *v93;
  void *v94;
  uint64_t v95;
  unsigned int v96;
  int v97;
  unint64_t v98;
  unsigned int v99;
  unsigned int v100;
  uint64_t v101;
  uint64_t v102;
  void (*v103)(_QWORD);
  _DWORD *v104;
  int v105;
  NSObject *v106;
  unsigned int v107;
  uint64_t v108;
  int v109;
  int v110;
  DIR *v111;
  DIR *v112;
  unint64_t v113;
  unint64_t v114;
  uint64_t v115;
  time_t v116;
  time_t v117;
  unint64_t v118;
  dirent *v119;
  dirent *v120;
  char *d_name;
  size_t v122;
  uint64_t v123;
  int v124;
  _QWORD *v125;
  int v126;
  int v127;
  uint64_t v128;
  unsigned int v129;
  uint64_t v130;
  void (*v131)(_QWORD);
  int v132;
  NSObject *v133;
  int v134;
  NSObject *v135;
  os_log_type_t v136;
  int v137;
  NSObject *v138;
  os_log_type_t v139;
  int v140;
  int v141;
  NSObject *v142;
  os_log_type_t v143;
  int v144;
  int v145;
  unsigned int v146;
  _DWORD *indexmetadata;
  uint64_t *v148;
  uint64_t *v149;
  int *v150;
  int *v151;
  uint64_t v152;
  int NotCompactCount;
  int NotMergedCount;
  int LiveCount;
  uint64_t v156;
  int v157;
  int v158;
  NSObject *v159;
  os_log_type_t v160;
  int v161;
  uint64_t v162;
  uint64_t v163;
  int v164;
  int v165;
  unsigned int v166;
  uint64_t v167;
  int v168;
  int v169;
  int v170;
  int v171;
  int v172;
  NSObject *v173;
  _BOOL4 v174;
  int v175;
  const char *v176;
  unsigned int v177;
  int v178;
  int v179;
  NSObject *v180;
  os_log_type_t v181;
  const char *v182;
  int v183;
  unsigned int v184;
  uint64_t v185;
  unsigned int v186;
  uint64_t v187;
  void (*v188)(_QWORD);
  int v189;
  NSObject *v190;
  int v191;
  int v192;
  _BYTE *v193;
  BOOL v194;
  int v195;
  int v196;
  NSObject *v197;
  os_log_type_t v198;
  uint64_t v199;
  int v200;
  int v201;
  int v202;
  int v203;
  int v204;
  int v205;
  NSObject *v206;
  os_log_type_t v207;
  unsigned int v208;
  int v209;
  int v210;
  int v211;
  int v212;
  int v213;
  int v214;
  int v215;
  int v216;
  uint64_t v217;
  int v218;
  int v219;
  int v220;
  int v221;
  NSObject *v222;
  NSObject *v223;
  os_log_type_t v224;
  const char *v225;
  uint32_t v226;
  NSObject *v227;
  int v228;
  NSObject *v229;
  os_log_type_t v230;
  BOOL v231;
  NSObject *v232;
  os_log_type_t v233;
  int v234;
  NSObject *v235;
  os_log_type_t v236;
  const char *v237;
  uint64_t v238;
  unsigned int v239;
  uint64_t v240;
  void (*v241)(_QWORD);
  int v242;
  NSObject *v243;
  int v244;
  NSObject *v245;
  os_log_type_t v246;
  uint64_t v247;
  unsigned int v248;
  uint64_t v249;
  void (*v250)(_QWORD);
  int v251;
  NSObject *v252;
  uint64_t v253;
  unsigned int v254;
  uint64_t v255;
  void (*v256)(_QWORD);
  _BOOL4 v257;
  uint64_t v258;
  unsigned int v259;
  uint64_t v260;
  void (*v261)(_QWORD);
  const char *v262;
  int v263;
  unsigned int v264;
  int v265;
  int v266;
  int v267;
  const __CFBoolean *v268;
  const __CFBoolean *v269;
  int VersionForDirectory;
  int v271;
  int v272;
  int v273;
  int v274;
  int v275;
  NSObject *v276;
  os_log_type_t v277;
  uint64_t v278;
  unsigned int v279;
  uint64_t v280;
  void (*v281)(_QWORD);
  uint64_t v282;
  int v283;
  uint64_t v284;
  uint64_t v285;
  uint64_t v286;
  int *v287;
  uint64_t v288;
  uint64_t vector_store;
  uint64_t v290;
  unsigned int v291;
  int v292;
  NSObject *v293;
  os_log_type_t v294;
  uint64_t v295;
  unsigned int v296;
  int v297;
  unsigned int v298;
  const char *v299;
  int v300;
  int v301;
  int v302;
  int v303;
  uint64_t v304;
  unsigned int v305;
  uint64_t v306;
  void (*v307)(_QWORD);
  int v308;
  const char *v309;
  int v310;
  NSObject *v311;
  os_log_type_t v312;
  int v313;
  NSObject *v314;
  os_log_type_t v315;
  uint64_t v316;
  unsigned int v317;
  uint64_t v318;
  void (*v319)(_QWORD);
  int v320;
  NSObject *v321;
  os_log_type_t v322;
  uint64_t v323;
  unsigned int v324;
  uint64_t v325;
  void (*v326)(_QWORD);
  int v327;
  NSObject *v328;
  os_log_type_t v329;
  NSObject *v330;
  uint64_t v331;
  int v332;
  _BYTE *v333;
  BOOL v334;
  NSObject *v335;
  void *v336;
  void *v337;
  int v338;
  BOOL v339;
  char v340;
  int v341;
  NSObject *v342;
  os_log_type_t v343;
  int v344;
  uint64_t datastore_with_ctx;
  char *v346;
  const __CFNumber *v347;
  const __CFNumber *v348;
  CFTypeID v349;
  uint64_t v350;
  uint64_t v351;
  unsigned int v352;
  uint64_t v353;
  void (*v354)(_QWORD);
  uint64_t v355;
  unsigned int v356;
  uint64_t v357;
  void (*v358)(_QWORD);
  _BOOL4 is_dirty;
  char v360;
  uint64_t v361;
  uint64_t v362;
  uint64_t v363;
  int v364;
  uint64_t v365;
  char *v366;
  uint64_t v367;
  uint64_t i;
  int v369;
  uint64_t v370;
  char *v371;
  uint64_t v372;
  uint64_t j;
  int v374;
  uint64_t v375;
  int v376;
  char *v377;
  int v378;
  char *v379;
  uint64_t v380;
  uint64_t v381;
  void *v382;
  unsigned int v383;
  int v384;
  unint64_t v385;
  unint64_t v386;
  unsigned int v387;
  unsigned int v388;
  uint64_t v389;
  uint64_t v390;
  int v391;
  void (*v392)(_QWORD);
  _DWORD *v393;
  int v394;
  NSObject *v395;
  uint64_t v396;
  uint64_t v397;
  void (*v398)(_QWORD);
  uint64_t v399;
  unsigned int v400;
  uint64_t v401;
  void (*v402)(_QWORD);
  NSObject *log;
  int v404;
  int v405;
  int v406;
  int v407;
  int v408;
  unsigned int v409;
  int v410;
  int v411;
  int v412;
  int v413;
  int v414;
  time_t v415;
  uint64_t v416;
  unint64_t v417;
  time_t v418;
  unint64_t v419;
  unint64_t v420;
  int v421;
  uint64_t v422;
  char *v423;
  int v424;
  int v425;
  int v426;
  int v427;
  unsigned int v428;
  uint64_t v429;
  int v430;
  int v431;
  int v432;
  unsigned int v433;
  unsigned int v434;
  int v435;
  uint64_t v436;
  char *v437;
  int v438;
  unsigned int v439;
  unsigned int v440;
  uint64_t v441;
  uint64_t v442;
  int v443;
  unsigned int v444;
  int v445;
  int v446;
  int v447;
  unsigned int v448;
  uint64_t v449;
  _QWORD *v450;
  unsigned int v451;
  unsigned int v452;
  unsigned int v453;
  _QWORD v454[2];
  _QWORD v455[5];
  uint64_t v456;
  _QWORD v457[5];
  _QWORD v458[5];
  _QWORD v459[5];
  _QWORD v460[5];
  unint64_t v461;
  unsigned int v462;
  unsigned int v463;
  unsigned int v464;
  unint64_t v465;
  unsigned int v466;
  char v467;
  uint64_t v468;
  void *v469;
  uint64_t v470;
  __int128 v471;
  CFTypeRef v472;
  _QWORD v473[5];
  __CFArray *v474;
  __CFArray *v475;
  int v476;
  uint8_t v477[4];
  const char *v478;
  __int16 v479;
  int v480;
  uint8_t v481[32];
  _BYTE buf[4096];
  _BYTE v483[1024];
  _BYTE v484[24];
  time_t v485;
  __int16 v486;
  unint64_t v487;
  __int16 v488;
  uint64_t v489;
  uint64_t v490;

  v11 = MEMORY[0x1E0C80A78](a1);
  v13 = v12;
  v15 = v14;
  v436 = v16;
  v18 = v17;
  v441 = v19;
  v442 = v20;
  v444 = v21;
  v450 = (_QWORD *)v11;
  v490 = *MEMORY[0x1E0C80C00];
  v476 = 0;
  v22 = open(".", 4);
  _SITuningInit();
  makeThreadId();
  v474 = 0;
  v475 = 0;
  *a10 = 0;
  _si_set_error_str(0);
  v23 = 1;
  _si_set_rebuild_reason(0, 1);
  v24 = (char *)malloc_type_calloc(1uLL, 0x2780uLL, 0x10F0040E1D49570uLL);
  v25 = (uint64_t)v24;
  *(_QWORD *)v24 = 0xC0DE10DE10DEC0DELL;
  SIInitIndexLocks((uint64_t)v24);
  v473[0] = MEMORY[0x1E0C809B0];
  v473[1] = 0x40000000;
  v473[2] = ___SIOpenIndex_block_invoke;
  v473[3] = &__block_descriptor_tmp_685;
  v473[4] = v24;
  *((_DWORD *)v24 + 15) = HIBYTE(v18);
  *((_DWORD *)v24 + 8) = -1;
  *((_DWORD *)v24 + 12) = -1;
  v26 = *(_QWORD *)(v15 + 16);
  *(_OWORD *)(v24 + 8) = *(_OWORD *)v15;
  *((_QWORD *)v24 + 3) = v26;
  v449 = v13;
  *((_QWORD *)v24 + 295) = v13;
  *((_QWORD *)v24 + 290) = 0;
  *((_QWORD *)v24 + 824) = a11;
  *((_DWORD *)v24 + 364) = 1;
  v27 = *((_DWORD *)v24 + 1646) & 0xFFFBFFFF;
  *((_DWORD *)v24 + 1646) = v27;
  v24[6944] = (v18 & 0x40000) != 0;
  v28 = *((_QWORD *)v24 + 148);
  if (v28)
  {
    db_datastore_set_bg_assertion_flag(v28, (v18 & 0x40000) != 0);
    v29 = *((_DWORD *)v24 + 1646);
  }
  else
  {
    v29 = v27;
  }
  *((_DWORD *)v24 + 1741) = 0;
  v30 = (v18 >> 8) & 1;
  v24[2072] = BYTE1(v18) & 1;
  if ((v18 & 0x100) != 0)
  {
    *((_DWORD *)v24 + 1646) = v29 | 0x40000;
  }
  else
  {
    v23 = 0;
    if (v442 && (v29 & 0x40000) != 0)
      v23 = (*(unsigned __int8 *)(v442 + 28) >> 4) & 1;
  }
  *(_OWORD *)(v24 + 1208) = 0u;
  *(_OWORD *)(v24 + 1224) = 0u;
  *((_DWORD *)v24 + 302) = -1;
  v31 = v22;
  *(_OWORD *)(v24 + 1256) = 0u;
  *(_OWORD *)(v24 + 1272) = 0u;
  *(_OWORD *)(v24 + 1240) = 0u;
  *(_OWORD *)(v24 + 1192) = 0u;
  v471 = 0uLL;
  v472 = 0;
  v469 = 0;
  v470 = 0;
  if (*a11)
  {
    _si_set_error_str("open canceled");
    v32 = 89;
    v33 = v23;
LABEL_11:
    v34 = v450;
LABEL_12:
    v35 = v13;
    goto LABEL_13;
  }
  v36 = v18 & 0x80040001;
  v37 = v18 & 4;
  v451 = v22;
  v448 = v18;
  v38 = v441;
  v435 = v37;
  v440 = HIBYTE(v18);
  if (v441)
  {
    v39 = *(_DWORD *)(v441 + 28) & 1;
    v40 = dup(*(_DWORD *)(v441 + 4));
    v36 = v18 & 0x80040001;
    v37 = v18 & 4;
    *((_DWORD *)v24 + 12) = v40;
    v30 = v24[2072];
    v38 = v39;
  }
  v45 = v36;
  v46 = v37;
  v47 = v37 != 0;
  if (v30)
    v48 = v38;
  else
    v48 = v47;
  if ((v448 & 8) != 0)
  {
    v49 = -1;
    v50 = 0;
    v31 = v451;
    goto LABEL_36;
  }
  v434 = v36;
  bzero(v484, 0x400uLL);
  v55 = guarded_dup(v444);
  *((_QWORD *)v24 + 4) = v55;
  *((_QWORD *)v24 + 5) = v56;
  if ((_DWORD)v55 == -1 || MEMORY[0x1BCCB1484]())
  {
    v32 = *__error();
    _si_set_error_str("invalid path");
    v33 = v23;
    v31 = v451;
    goto LABEL_11;
  }
  v439 = v45;
  v446 = v46;
  v437 = v24 + 6944;
  if (v24[6944])
    v33 = 0;
  else
    v33 = v23;
  registerForCloning(*((_DWORD *)v24 + 8), v33);
  bzero(v483, 0x400uLL);
  v406 = *__error();
  v71 = _SILogForLogForCategory(11);
  v72 = 2 * (dword_1EF19FCB8 < 4);
  if (os_log_type_enabled(v71, v72))
  {
    v73 = fcntl(*((_DWORD *)v24 + 8), 50, v483);
    v74 = 0;
    if (v483[0])
      v75 = v73 < 0;
    else
      v75 = 1;
    if (!v75)
      v74 = v483;
    *(_DWORD *)buf = 134218242;
    *(_QWORD *)&buf[4] = v24;
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = v74;
    _os_log_impl(&dword_1B8270000, v71, v72, "%p Open fd %s", buf, 0x16u);
  }
  *__error() = v406;
  if (v24[2072])
  {
    *(_DWORD *)v481 = 0;
    if ((fd_setDir(*((unsigned int *)v24 + 8), (int *)v481) & 1) != 0)
    {
      memset(buf, 0, 144);
      if (!stat("activityJournal", (stat *)buf))
      {
        _si_set_error_str("Rebuilding index");
        _si_set_rebuild_reason("rebuildActivityJournalName", 1);
        v31 = v451;
        v34 = v450;
        goto LABEL_189;
      }
      fd_resetDir(*(int *)v481);
    }
  }
  v76 = v33;
  v468 = 0;
  v421 = v48;
  v77 = check_crash_state(*((_DWORD *)v24 + 8), v48, v448, &v468, 0);
  v78 = *__error();
  v79 = _SILogForLogForCategory(0);
  v80 = 2 * (gSILogLevels[0] < 4);
  if (os_log_type_enabled(v79, v80))
  {
    log = v79;
    v81 = v468;
    v82 = fcntl(*((_DWORD *)v24 + 8), 50, v484);
    v83 = 0;
    if (v484[0])
      v84 = v82 < 0;
    else
      v84 = 1;
    if (!v84)
      v83 = v484;
    *(_DWORD *)buf = 134218242;
    *(_QWORD *)&buf[4] = v81;
    *(_WORD *)&buf[12] = 2080;
    *(_QWORD *)&buf[14] = v83;
    _os_log_impl(&dword_1B8270000, log, v80, "last_crash_delta: %ld for %s", buf, 0x16u);
  }
  *__error() = v78;
  if ((unint64_t)(v468 - 1) <= 0x545E)
    icu_rules_clear_cache();
  v31 = v451;
  if (v77)
  {
    v85 = *__error();
    v86 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v86, OS_LOG_TYPE_ERROR))
    {
      v192 = fcntl(*((_DWORD *)v24 + 8), 50, v484);
      v193 = 0;
      *(_QWORD *)&buf[4] = "_SIOpenIndex";
      *(_DWORD *)&buf[14] = 10849;
      *(_DWORD *)buf = 136315906;
      if (v484[0])
        v194 = v192 < 0;
      else
        v194 = 1;
      *(_WORD *)&buf[12] = 1024;
      if (!v194)
        v193 = v484;
      v31 = v451;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v77;
      *(_WORD *)&buf[24] = 2080;
      *(_QWORD *)&buf[26] = v193;
      _os_log_error_impl(&dword_1B8270000, v86, OS_LOG_TYPE_ERROR, "%s:%d: check_crash_state: %d for %s", buf, 0x22u);
    }
    *__error() = v85;
    if (CFPreferencesGetAppBooleanValue(CFSTR("SpotlightDisableIndexRebuild"), (CFStringRef)*MEMORY[0x1E0C9B228], 0))
    {
      v87 = *__error();
      v88 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v88, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)&buf[4] = "_SIOpenIndex";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 10861;
        _os_log_error_impl(&dword_1B8270000, v88, OS_LOG_TYPE_ERROR, "%s:%d: Index rebuild disabled by SpotlightDisableIndexRebuild", buf, 0x12u);
      }
      *__error() = v87;
      goto LABEL_99;
    }
    _si_set_error_str("Rebuilding index because of repeated crashes");
    v34 = v450;
    v33 = v76;
LABEL_189:
    v32 = 22;
    goto LABEL_12;
  }
LABEL_99:
  v426 = check_crash_state(v444, v421, v448, 0, 1);
  v89 = check_crash_state(v444, v421, v448, 0, 3);
  v425 = v89;
  v447 = v76;
  if (v89)
  {
    v476 = 2;
    v89 = 2;
  }
  v431 = v89;
  v429 = (uint64_t)(v24 + 1192);
  v90 = malloc_type_calloc(1uLL, 0x18uLL, 0x1080040A085CBA5uLL);
  *((_QWORD *)v24 + 174) = v90;
  v90[3] = 2;
  v91 = malloc_type_calloc(2uLL, 8uLL, 0x2004093837F09uLL);
  v92 = *((_QWORD *)v24 + 174);
  *(_QWORD *)v92 = v91;
  *(_DWORD *)(v92 + 16) = -1;
  v93 = malloc_type_calloc(1uLL, 0x18uLL, 0x1080040A085CBA5uLL);
  *((_QWORD *)v24 + 173) = v93;
  v93[3] = 2;
  v94 = malloc_type_calloc(2uLL, 8uLL, 0x2004093837F09uLL);
  v95 = *((_QWORD *)v24 + 173);
  *(_QWORD *)v95 = v94;
  *(_DWORD *)(v95 + 16) = -1;
  v467 = 0;
  do
  {
    v96 = __ldxr(exceptionSequenceNum);
    v97 = v96 + 1;
  }
  while (__stxr(v96 + 1, exceptionSequenceNum));
  v466 = 0;
  v465 = 0;
  v464 = 0;
  v98 = setThreadIdAndInfo(*((_DWORD *)v24 + 8), sFdExceptionCallbacks, 0, 1, v97);
  v466 = v98;
  v465 = __PAIR64__(HIDWORD(v98), v99);
  v464 = v100;
  v101 = *(_QWORD *)&threadData[18 * v98 + 2];
  v102 = v101 + 320 * HIDWORD(v98);
  *(_BYTE *)(v102 + 216) = 0;
  v438 = *(_DWORD *)(v102 + 312);
  v103 = *(void (**)(_QWORD))(v102 + 224);
  v34 = v450;
  if (v103)
    v103(*(_QWORD *)(v101 + 320 * HIDWORD(v98) + 288));
  v443 = v97;
  v463 = v466;
  v462 = HIDWORD(v465);
  v461 = __PAIR64__(v465, v464);
  if (!_setjmp((int *)v102))
  {
    v31 = v451;
    if (SIIsAppleInternal_onceToken != -1)
      dispatch_once(&SIIsAppleInternal_onceToken, &__block_literal_global_4644);
    v124 = v435;
    if (SIIsAppleInternal_internal)
    {
      v125 = fd_create_protected(*((_DWORD *)v24 + 8), "activityJournal.1", 536871433, 3u);
      si_activity_journal_init((uint64_t)(v24 + 2192), v125);
      fd_mark_purgable(*((_DWORD **)v24 + 274));
      v124 = v435;
    }
    v126 = CIMetaInfoOpenAndLock(*((_DWORD *)v24 + 8), v124 != 0, v429);
    if (v126)
    {
      v127 = v126;
      v128 = *(_QWORD *)&threadData[18 * v463 + 2];
      v129 = v462;
      v130 = v128 + 320 * v462;
      *(_DWORD *)(v130 + 312) = v438;
      v131 = *(void (**)(_QWORD))(v130 + 232);
      if (v131)
        v131(*(_QWORD *)(v128 + 320 * v129 + 288));
      v32 = v127;
      dropThreadId(v463, 0, v443);
      _si_set_error_str("open meta info error");
      v132 = *__error();
      v133 = _SILogForLogForCategory(10);
      v35 = v13;
      if (os_log_type_enabled(v133, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = "_SIOpenIndex";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 10903;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v32;
        _os_log_error_impl(&dword_1B8270000, v133, OS_LOG_TYPE_ERROR, "%s:%d: open meta info error %d", buf, 0x18u);
      }
      *__error() = v132;
      v33 = v447;
      goto LABEL_63;
    }
    v161 = *((_DWORD *)v24 + 319);
    if (v24[2072])
    {
      v162 = v444;
      v163 = MEMORY[0x1E0C809B0];
      if (v161 <= 112)
        goto LABEL_199;
    }
    else
    {
      v162 = v444;
      v163 = MEMORY[0x1E0C809B0];
      if (v161 < 100)
      {
LABEL_199:
        v460[0] = v163;
        v460[1] = 0x40000000;
        v460[2] = ___SIOpenIndex_block_invoke_693;
        v460[3] = &__block_descriptor_tmp_694;
        v460[4] = v24;
        check_touch_file(v162, "tmp.Glow", (uint64_t)v460);
        v459[0] = v163;
        v459[1] = 0x40000000;
        v459[2] = ___SIOpenIndex_block_invoke_2;
        v459[3] = &__block_descriptor_tmp_695;
        v459[4] = v24;
        check_touch_file(v162, "Glow.created", (uint64_t)v459);
        if ((v448 & 0x40) != 0)
        {
          *((_DWORD *)v24 + 1646) |= 0x40u;
        }
        else
        {
          v458[0] = v163;
          v458[1] = 0x40000000;
          v458[2] = ___SIOpenIndex_block_invoke_3;
          v458[3] = &__block_descriptor_tmp_696;
          v458[4] = v24;
          check_touch_file(v162, "tmp.Cab", (uint64_t)v458);
        }
        if ((v448 & 0x400) != 0)
        {
          *((_DWORD *)v24 + 1646) |= 0x100u;
        }
        else
        {
          v457[0] = v163;
          v457[1] = 0x40000000;
          v457[2] = ___SIOpenIndex_block_invoke_4;
          v457[3] = &__block_descriptor_tmp_697;
          v457[4] = v24;
          check_touch_file(v162, "tmp.Star", (uint64_t)v457);
        }
        v456 = 0;
        if (!v446)
        {
          si_read_index_state((uint64_t)v24);
          v177 = v24[2481];
          if (v24[2481])
          {
            v178 = v24[2481];
            if (!*v437 || v177 == 1 || v177 == 4)
            {
              memcpy(buf, v24 + 2480, sizeof(buf));
              v179 = *__error();
              v180 = _SILogForLogForCategory(11);
              v181 = 2 * (dword_1EF19FCB8 < 4);
              if (os_log_type_enabled(v180, v181))
              {
                if (v177 > 4)
                  v182 = "unknown";
                else
                  v182 = off_1E6E2E448[(v177 - 1)];
                *(_DWORD *)v481 = 134218242;
                *(_QWORD *)&v481[4] = v24;
                *(_WORD *)&v481[12] = 2080;
                *(_QWORD *)&v481[14] = v182;
                _os_log_impl(&dword_1B8270000, v180, v181, "%p si state: %s", v481, 0x16u);
              }
              *__error() = v179;
              v107 = _SIOpenIndexFilesWithState((uint64_t)v24, v177, v434 == 0, (*((_DWORD *)v24 + 1646) >> 4) & 1, v448, a10, &v456, v436, &v476);
              v244 = *__error();
              v245 = _SILogForLogForCategory(11);
              v246 = 2 * (dword_1EF19FCB8 < 4);
              if (os_log_type_enabled(v245, v246))
              {
                *(_DWORD *)v481 = 134218240;
                *(_QWORD *)&v481[4] = v24;
                *(_WORD *)&v481[12] = 1024;
                *(_DWORD *)&v481[14] = v107;
                _os_log_impl(&dword_1B8270000, v245, v246, "%p _SIOpenIndexFilesWithState: %d", v481, 0x12u);
              }
              *__error() = v244;
              v191 = *__error();
              if (v107 != 2)
              {
                v76 = v447;
                if (v107 == -1)
                {
                  v247 = *(_QWORD *)&threadData[18 * v463 + 2];
                  v248 = v462;
                  v249 = v247 + 320 * v462;
                  *(_DWORD *)(v249 + 312) = v438;
                  v250 = *(void (**)(_QWORD))(v249 + 232);
                  if (v250)
                    v250(*(_QWORD *)(v247 + 320 * v248 + 288));
                  dropThreadId(v463, 0, v443);
                  _si_set_error_str("open meta info error");
                  v251 = *__error();
                  v252 = _SILogForLogForCategory(10);
                  v35 = v13;
                  v34 = v450;
                  if (os_log_type_enabled(v252, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)v481 = 136315650;
                    *(_QWORD *)&v481[4] = "_SIOpenIndex";
                    *(_WORD *)&v481[12] = 1024;
                    *(_DWORD *)&v481[14] = 10956;
                    *(_WORD *)&v481[18] = 1024;
                    *(_DWORD *)&v481[20] = v191;
                    _os_log_error_impl(&dword_1B8270000, v252, OS_LOG_TYPE_ERROR, "%s:%d: open meta info error %d", v481, 0x18u);
                  }
                  *__error() = v251;
                  goto LABEL_485;
                }
                v257 = v177 == 3;
                goto LABEL_398;
              }
              v34 = v450;
              v76 = v447;
              if (handleDirStoreOverlay((uint64_t)v24))
                v476 |= 2u;
              if (!handleIndexRepair((uint64_t)v24, v13, v456))
              {
                v257 = 0;
LABEL_398:
                si_handle_tmp_files(*((unsigned int *)v24 + 8), v257, (v448 >> 12) & 1, &v475, &v474);
                if (memcmp(buf, v24 + 2480, 0x1000uLL))
                  si_write_index_state((uint64_t)v24, 0, 0);
                goto LABEL_529;
              }
              v253 = *(_QWORD *)&threadData[18 * v463 + 2];
              v254 = v462;
              v255 = v253 + 320 * v462;
              *(_DWORD *)(v255 + 312) = v438;
              v256 = *(void (**)(_QWORD))(v255 + 232);
              if (v256)
                v256(*(_QWORD *)(v253 + 320 * v254 + 288));
              dropThreadId(v463, 0, v443);
              _si_set_error_str("recover datastore error");
              goto LABEL_484;
            }
            v238 = *(_QWORD *)&threadData[18 * v463 + 2];
            v239 = v462;
            v240 = v238 + 320 * v462;
            *(_DWORD *)(v240 + 312) = v438;
            v241 = *(void (**)(_QWORD))(v240 + 232);
            if (v241)
              v241(*(_QWORD *)(v238 + 320 * v239 + 288));
            dropThreadId(v463, 0, v443);
            v242 = *__error();
            v243 = _SILogForLogForCategory(10);
            v35 = v13;
            v34 = v450;
            if (os_log_type_enabled(v243, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136315650;
              *(_QWORD *)&buf[4] = "_SIOpenIndex";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = 10941;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = v178;
              _os_log_error_impl(&dword_1B8270000, v243, OS_LOG_TYPE_ERROR, "%s:%d: open indexstate not clean for locked indexing: %d", buf, 0x18u);
            }
            *__error() = v242;
            goto LABEL_424;
          }
        }
        if (v24[2072])
          v183 = 75776;
        else
          v183 = 141312;
        v184 = v183 & 0xFFFFFFF1 | (2 * (v435 & 7));
        if (CIMetaInfoRead(v429, v24[2072]))
        {
          if (!v446 && (db_check_datastore(*((_DWORD *)v24 + 8), v184) & 0x80000000) == 0)
            *a10 = 1;
          v185 = *(_QWORD *)&threadData[18 * v463 + 2];
          v186 = v462;
          v187 = v185 + 320 * v462;
          *(_DWORD *)(v187 + 312) = v438;
          v188 = *(void (**)(_QWORD))(v187 + 232);
          v35 = v13;
          v34 = v450;
          if (v188)
            v188(*(_QWORD *)(v185 + 320 * v186 + 288));
          dropThreadId(v463, 0, v443);
          _si_set_error_str("open meta info error");
          v189 = *__error();
          v190 = _SILogForLogForCategory(10);
          if (os_log_type_enabled(v190, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315650;
            *(_QWORD *)&buf[4] = "_SIOpenIndex";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 11014;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = -1;
            _os_log_error_impl(&dword_1B8270000, v190, OS_LOG_TYPE_ERROR, "%s:%d: open meta info error %d", buf, 0x18u);
          }
          *__error() = v189;
          v191 = -1;
          goto LABEL_485;
        }
        v195 = db_check_datastore(*((_DWORD *)v24 + 8), v184);
        v405 = *__error();
        v196 = *__error();
        v197 = _SILogForLogForCategory(0);
        v198 = 2 * (gSILogLevels[0] < 4);
        if (os_log_type_enabled(v197, v198))
        {
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&buf[4] = v195;
          _os_log_impl(&dword_1B8270000, v197, v198, "db_check_datastore: %d", buf, 8u);
        }
        *__error() = v196;
        if (v195 == -1 && v405 == 2)
        {
          v205 = *__error();
          v206 = _SILogForLogForCategory(0);
          v207 = 2 * (gSILogLevels[0] < 4);
          if (os_log_type_enabled(v206, v207))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_1B8270000, v206, v207, "file didn't exist, try shadow", buf, 2u);
          }
          *__error() = v205;
          v208 = v439;
          v209 = v435;
        }
        else
        {
          v211 = v195;
          if (!v195)
          {
            v210 = 7;
            v212 = 0;
            v213 = v184;
            v208 = v439;
            v209 = v435;
            goto LABEL_278;
          }
          v76 = v447;
          v208 = v439;
          v209 = v435;
          if (v195 != 2)
          {
            if (v195 != 1)
            {
              v304 = *(_QWORD *)&threadData[18 * v463 + 2];
              v305 = v462;
              v306 = v304 + 320 * v462;
              *(_DWORD *)(v306 + 312) = v438;
              v307 = *(void (**)(_QWORD))(v306 + 232);
              if (v307)
                v307(*(_QWORD *)(v304 + 320 * v305 + 288));
              dropThreadId(v463, 0, v443);
              __error();
              v262 = "invalid datastore";
              goto LABEL_396;
            }
            v213 = v184 | 1;
            v210 = 7;
            v211 = 1;
            v212 = 1;
LABEL_278:
            v424 = v213;
            v427 = v212;
            v214 = v210 | 0x2000;
            if (!v426)
              v214 = v210;
            if (v425)
              v215 = v214 | 0x4000;
            else
              v215 = v214;
            v216 = v215;
            v217 = MEMORY[0x1E0C809B0];
            if (v208)
            {
LABEL_284:
              if (v215 != 7)
                goto LABEL_348;
LABEL_285:
              if (db_restore_dirty_chunk_info(*((_DWORD *)v24 + 8), (uint64_t)&v469, v199, v200, v201, v202, v203, v204))
              {
                _si_set_error_str("restore db dirty pages failed");
                v216 = 4;
              }
              else
              {
                v216 = 7;
              }
              if (!v208)
              {
                v263 = reverseStoreRestoreDirtyBitmap(*((_DWORD *)v24 + 8), (uint64_t)&v471);
                v209 = v435;
                if (v263)
                {
                  _si_set_error_str("restore rs dirty pages failed");
                  v209 = v435;
                  v216 = 4;
                }
LABEL_348:
                v264 = *((_DWORD *)v24 + 1646);
                if ((v264 & 0x10) != 0)
                  v265 = 48;
                else
                  v265 = 16;
                v266 = v216 | (2 * v209) | v265;
                if (!v434)
                  v266 |= 0x40u;
                if (v24[2072])
                  v267 = v266 | 0x100;
                else
                  v267 = v266;
                v268 = (const __CFBoolean *)SICopyProperty((uint64_t)v24, CFSTR("kSITokenizerUseCRF"));
                v34 = v450;
                if (v268)
                {
                  v269 = v268;
                  if (CFBooleanGetValue(v268))
                    *((_DWORD *)v24 + 1646) = *((_DWORD *)v24 + 1646) & 0xFFE7FFFF | 0x80000;
                  CFRelease(v269);
                }
                VersionForDirectory = ContentIndexGetVersionForDirectory(*((_DWORD *)v24 + 8));
                v271 = v24[2072];
                if (v24[2072])
                {
                  if ((VersionForDirectory - 115) <= 0xFFFFFFFC)
                  {
                    v272 = 114;
                    goto LABEL_363;
                  }
                }
                else if ((VersionForDirectory - 96) >= 5 && VersionForDirectory != 102)
                {
                  v272 = 102;
LABEL_363:
                  v273 = VersionForDirectory;
                  if (VersionForDirectory >= v272
                    || (v271 ? (v274 = 111) : (v274 = 95), VersionForDirectory != -1 && VersionForDirectory < v274))
                  {
                    _si_set_error_str("invalid index version reindexing");
                    v275 = *__error();
                    v276 = _SILogForLogForCategory(0);
                    v277 = gSILogLevels[0] < 3;
                    if (os_log_type_enabled(v276, (os_log_type_t)(gSILogLevels[0] < 3)))
                    {
                      *(_DWORD *)buf = 67109376;
                      *(_DWORD *)&buf[4] = v273;
                      *(_WORD *)&buf[8] = 1024;
                      *(_DWORD *)&buf[10] = v272;
                      _os_log_impl(&dword_1B8270000, v276, v277, "*warn* Index version %d out of date, expected %d, reindexing", buf, 0xEu);
                    }
                    *__error() = v275;
                    if (!v446)
                    {
                      x_unlinkat(*(_DWORD *)(v25 + 32), "store.db", 0);
                      x_unlinkat(*(_DWORD *)(v25 + 32), ".store.db", 0);
                    }
                    v278 = *(_QWORD *)&threadData[18 * v463 + 2];
                    v279 = v462;
                    v280 = v278 + 320 * v462;
                    *(_DWORD *)(v280 + 312) = v438;
                    v281 = *(void (**)(_QWORD))(v280 + 232);
                    v35 = v13;
                    v76 = v447;
                    if (v281)
                      v281(*(_QWORD *)(v278 + 320 * v279 + 288));
                    dropThreadId(v463, 0, v443);
LABEL_424:
                    v191 = 0;
                    goto LABEL_485;
                  }
                  _si_set_error_str("invalid index version recovering");
                  v310 = *__error();
                  v311 = _SILogForLogForCategory(0);
                  v312 = gSILogLevels[0] < 3;
                  if (os_log_type_enabled(v311, (os_log_type_t)(gSILogLevels[0] < 3)))
                  {
                    *(_DWORD *)buf = 67109376;
                    *(_DWORD *)&buf[4] = v273;
                    *(_WORD *)&buf[8] = 1024;
                    *(_DWORD *)&buf[10] = v272;
                    _os_log_impl(&dword_1B8270000, v311, v312, "*warn* Index version %d out of date, expected %d, recovering", buf, 0xEu);
                  }
                  *__error() = v310;
                  *a10 = 1;
                  v308 = *(_DWORD *)(v25 + 1456);
LABEL_417:
                  v35 = v13;
                  *(_DWORD *)(v25 + 1456) = v308;
                  v313 = *__error();
                  v314 = _SILogForLogForCategory(0);
                  v315 = 2 * (gSILogLevels[0] < 4);
                  if (os_log_type_enabled(v314, v315))
                  {
                    *(_WORD *)buf = 0;
                    _os_log_impl(&dword_1B8270000, v314, v315, "Could not open existing content index", buf, 2u);
                  }
                  *__error() = v313;
                  v316 = *(_QWORD *)&threadData[18 * v463 + 2];
                  v317 = v462;
                  v318 = v316 + 320 * v462;
                  *(_DWORD *)(v318 + 312) = v438;
                  v319 = *(void (**)(_QWORD))(v318 + 232);
                  if (v319)
                    v319(*(_QWORD *)(v316 + 320 * v317 + 288));
                  dropThreadId(v463, 0, v443);
                  v76 = v447;
                  if (!__si_error_str_key || !pthread_getspecific(__si_error_str_key))
                    _si_set_error_str("open index error");
                  goto LABEL_424;
                }
                v282 = v267 | (v264 >> 7) & 0x800;
                *a10 = 1;
                v283 = *((_DWORD *)v24 + 364);
                v455[0] = v217;
                v455[1] = 0x40000000;
                v455[2] = ___SIOpenIndex_block_invoke_708;
                v455[3] = &__block_descriptor_tmp_709;
                v455[4] = v24;
                _si_next_index_id((os_unfair_lock_s *)v24, (*(_DWORD *)(*((_QWORD *)v24 + 173) + 8) + *(_DWORD *)(*((_QWORD *)v24 + 174) + 8)), 0, 1);
                v284 = *((_QWORD *)v24 + 174);
                v285 = *((_QWORD *)v24 + 173);
                v286 = *((_QWORD *)v24 + 824);
                v287 = (int *)*((_QWORD *)v24 + 148);
                v412 = v283;
                if (v287)
                {
                  v288 = *((_QWORD *)v24 + 173);
                  vector_store = db_get_vector_store(v287);
                  v285 = v288;
                  v290 = vector_store;
                }
                else
                {
                  v290 = 0;
                }
                v291 = ContentIndexOpenBulk(v429, v436, v284, v285, v282, v286, (uint64_t)(v24 + 2408), (uint64_t)&v456, v290, (uint64_t)v455, v473);
                v292 = *__error();
                v293 = _SILogForLogForCategory(0);
                v294 = 2 * (gSILogLevels[0] < 4);
                if (os_log_type_enabled(v293, v294))
                {
                  v295 = *((_QWORD *)v24 + 301);
                  *(_DWORD *)buf = 67109632;
                  *(_DWORD *)&buf[4] = v291;
                  *(_WORD *)&buf[8] = 2048;
                  *(_QWORD *)&buf[10] = v24;
                  *(_WORD *)&buf[18] = 2048;
                  *(_QWORD *)&buf[20] = v295;
                  _os_log_impl(&dword_1B8270000, v293, v294, "ContentIndexOpenBulk: %d opened %p with recovery time %llu", buf, 0x1Cu);
                }
                *__error() = v292;
                if (v291 == 3)
                {
                  v296 = 0;
                  v297 = v435;
                }
                else
                {
                  v296 = v291;
                  v297 = v435;
                  if ((v291 & 0x80000000) != 0)
                  {
                    v308 = v412;
                    v34 = v450;
                    goto LABEL_417;
                  }
                }
                v298 = v296;
                if (!v446)
                {
                  si_handle_tmp_files(*((unsigned int *)v24 + 8), v291 == 3, (v448 >> 12) & 1, &v475, &v474);
                  v297 = v435;
                }
                v76 = v447;
                v428 = v298;
                if (v298 == 2)
                {
                  if (__si_error_str_key)
                    v299 = (const char *)pthread_getspecific(__si_error_str_key);
                  else
                    v299 = 0;
                  if (v299)
                    v309 = v299;
                  else
                    v309 = "";
                  if (!strcmp(v309, "invalid term update set"))
                  {
                    _si_set_error_str("invalid term update set from lion");
                    _si_set_rebuild_reason("invalid term update set ", 0);
                  }
                  v303 = v424 | 0x20;
                  if (v439)
                  {
                    v300 = v431;
                    v302 = v424 | 0x20;
                    goto LABEL_449;
                  }
                  if (handleDirStoreOverlay((uint64_t)v24))
                  {
                    v476 = 2;
                    v301 = 2;
                  }
                  else
                  {
                    v301 = v431;
                  }
                  v297 = v435;
                }
                else
                {
                  v300 = v431;
                  v301 = v431;
                  v302 = v424;
                  v303 = v424;
                  if (v439)
                    goto LABEL_449;
                }
                v414 = v303;
                v408 = check_crash_state(*((_DWORD *)v24 + 8), v297 != 0, v448, &v468, 2);
                bzero(buf, 0x400uLL);
                v327 = *__error();
                v328 = _SILogForLogForCategory(0);
                v329 = 2 * (gSILogLevels[0] < 4);
                if (os_log_type_enabled(v328, v329))
                {
                  v413 = v301;
                  v330 = v328;
                  v331 = v468;
                  v332 = fcntl(*((_DWORD *)v24 + 8), 50, buf);
                  v333 = 0;
                  if (buf[0])
                    v334 = v332 < 0;
                  else
                    v334 = 1;
                  if (!v334)
                    v333 = buf;
                  *(_DWORD *)v481 = 134218242;
                  *(_QWORD *)&v481[4] = v331;
                  *(_WORD *)&v481[12] = 2080;
                  *(_QWORD *)&v481[14] = v333;
                  v335 = v330;
                  v301 = v413;
                  _os_log_impl(&dword_1B8270000, v335, v329, "rs last_crash_delta: %ld for %s", v481, 0x16u);
                }
                *__error() = v327;
                v336 = openReverseStore(*((_DWORD *)v24 + 8), v408 != 0, v428 == 2, v435 != 0, *((_DWORD **)v24 + 824), &v471, v473);
                *((_QWORD *)v24 + 828) = v336;
                if (v472)
                {
                  CFRelease(v472);
                  v472 = 0;
                  v337 = (void *)*((_QWORD *)v24 + 828);
                }
                else
                {
                  v337 = v336;
                }
                v76 = v447;
                v471 = 0uLL;
                if (v337)
                {
                  v300 = v301;
                }
                else
                {
                  v476 = v301 | 1;
                  v300 = v301 | 1;
                }
                v302 = v414;
LABEL_449:
                v338 = v302;
                v339 = (v302 & 0x20) == 0;
                v340 = v427 ^ 1;
                if (v339)
                  v340 = 1;
                if ((v340 & 1) != 0)
                {
                  memset(buf, 0, 40);
                  v344 = *((_DWORD *)v24 + 8);
                  *(_QWORD *)&buf[8] = "store.db";
                  *(_DWORD *)buf = v344;
                  *(_DWORD *)&buf[16] = v338;
                  *(_DWORD *)&buf[20] = *((_DWORD *)v24 + 15);
                  v34 = v450;
                  if (SIIsAppleInternal_onceToken != -1)
                    dispatch_once(&SIIsAppleInternal_onceToken, &__block_literal_global_4644);
                  datastore_with_ctx = 0;
                  if (SIIsAppleInternal_internal)
                    v346 = v24 + 2192;
                  else
                    v346 = 0;
                  *(_QWORD *)&buf[24] = v346;
                  buf[32] = 0;
                  if ((v338 & 0x1000) == 0)
                    datastore_with_ctx = db2_get_datastore_with_ctx((unsigned int *)buf);
                  *((_QWORD *)v24 + 148) = datastore_with_ctx;
                  __error();
                }
                else
                {
                  v341 = *__error();
                  v342 = _SILogForLogForCategory(0);
                  v343 = gSILogLevels[0] < 3;
                  v34 = v450;
                  if (os_log_type_enabled(v342, (os_log_type_t)(gSILogLevels[0] < 3)))
                  {
                    *(_WORD *)buf = 0;
                    _os_log_impl(&dword_1B8270000, v342, v343, "*warn* datastore clean, index dirty, recovering...", buf, 2u);
                  }
                  *__error() = v341;
                  v76 = v447;
                }
                if (!*((_QWORD *)v24 + 148))
                {
                  v355 = *(_QWORD *)&threadData[18 * v463 + 2];
                  v356 = v462;
                  v357 = v355 + 320 * v462;
                  *(_DWORD *)(v357 + 312) = v438;
                  v358 = *(void (**)(_QWORD))(v357 + 232);
                  if (v358)
                    v358(*(_QWORD *)(v355 + 320 * v356 + 288));
                  dropThreadId(v463, 0, v443);
                  _si_set_error_str("open datastore failed");
                  v191 = 0;
LABEL_484:
                  v35 = v13;
                  goto LABEL_485;
                }
                *(_DWORD *)buf = 0;
                v347 = (const __CFNumber *)SICopyProperty((uint64_t)v24, CFSTR("kSINextIndexId"));
                if (v347)
                {
                  v348 = v347;
                  v349 = CFGetTypeID(v347);
                  if (v349 == CFNumberGetTypeID())
                    CFNumberGetValue(v348, kCFNumberSInt32Type, buf);
                  CFRelease(v348);
                }
                if (*(_DWORD *)buf > *((_DWORD *)v24 + 364))
                  *((_DWORD *)v24 + 364) = *(_DWORD *)buf;
                db_datastore_set_bg_assertion_flag(*((_QWORD *)v24 + 148), *v437);
                if (v428)
                {
                  if (!v446 && v428 == 2)
                  {
                    db_set_dirty_chunks(*((_QWORD *)v24 + 148), 0, 0, 0);
                    db_store_dirty_chunk_info(*((_QWORD *)v24 + 148), *((unsigned int *)v24 + 8), 1, 0);
                    v350 = *((_QWORD *)v24 + 828);
                    if (v350)
                      reverseStoreStoreDirtyBitmap(v350);
                    if (handleIndexRepair((uint64_t)v24, v13, v456))
                    {
                      v351 = *(_QWORD *)&threadData[18 * v463 + 2];
                      v352 = v462;
                      v353 = v351 + 320 * v462;
                      *(_DWORD *)(v353 + 312) = v438;
                      v354 = *(void (**)(_QWORD))(v353 + 232);
                      if (v354)
                        v354(*(_QWORD *)(v351 + 320 * v352 + 288));
                      dropThreadId(v463, 0, v443);
                      _si_set_error_str("recover datastore error");
LABEL_480:
                      v191 = 0;
                      v35 = v13;
                      v34 = v450;
                      v76 = v447;
                      goto LABEL_485;
                    }
                    goto LABEL_489;
                  }
                }
                else
                {
                  db_set_dirty_chunks(*((_QWORD *)v24 + 148), (uint64_t)v469, v470, SHIDWORD(v470));
                  v469 = 0;
                }
                if (v446)
                {
                  v107 = v428;
                  v191 = 0;
                  goto LABEL_529;
                }
LABEL_489:
                v24[2481] = 4;
                is_dirty = db_is_dirty(*((int **)v24 + 148));
                v360 = 4;
                if (is_dirty)
                {
                  v360 = 1;
                  v24[2481] = 1;
                }
                v24[2482] = v360;
                if (v439)
                {
                  v24[2483] = 0;
LABEL_502:
                  v362 = *((_QWORD *)v24 + 174);
                  v363 = *(unsigned int *)(*((_QWORD *)v24 + 173) + 8);
                  v364 = *(_DWORD *)(v362 + 8);
                  if (*v437)
                    v364 = *((unsigned __int16 *)v24 + 1242);
                  if (*(_DWORD *)(v362 + 8))
                  {
                    v365 = *(unsigned int *)(v362 + 8);
                    v366 = v24 + 2488;
                    v367 = **((_QWORD **)v24 + 174);
                    for (i = 0; v365 != i; ++i)
                    {
                      v369 = atomic_load((unsigned int *)(*(_QWORD *)(v367 + 8 * i) + 24));
                      if (v369 > 0)
                      {
                        if (v369 == 1)
                        {
LABEL_514:
                          LOBYTE(v369) = 4;
                          v366[i] = 4;
                          goto LABEL_515;
                        }
                        if (v369 != 2)
LABEL_512:
                          LOBYTE(v369) = 1;
                      }
                      else
                      {
                        if (v369 == -1073623027)
                          goto LABEL_514;
                        if (v369 != -804450864)
                          goto LABEL_512;
                        LOBYTE(v369) = 3;
                      }
                      v366[i] = v369;
                      v24[2481] = 1;
LABEL_515:
                      v370 = **((_QWORD **)v24 + 174);
                      *(_BYTE *)(*(_QWORD *)(v370 + 8 * i) + 15161) = v369;
                      v367 = v370;
                    }
                  }
                  if ((_DWORD)v363)
                  {
                    v371 = v24 + 2488;
                    v372 = **((_QWORD **)v24 + 173);
                    for (j = 0; v363 != j; ++j)
                    {
                      v374 = atomic_load((unsigned int *)(*(_QWORD *)(v372 + 8 * j) + 24));
                      if (v374 > 0)
                      {
                        if (v374 == 1)
                        {
LABEL_526:
                          v371[(v364 + j)] = 4;
                          LOBYTE(v374) = 4;
                          goto LABEL_527;
                        }
                        if (v374 != 2)
LABEL_524:
                          LOBYTE(v374) = 1;
                      }
                      else
                      {
                        if (v374 == -1073623027)
                          goto LABEL_526;
                        if (v374 != -804450864)
                          goto LABEL_524;
                        LOBYTE(v374) = 3;
                      }
                      v371[(v364 + j)] = v374;
                      v24[2481] = 1;
LABEL_527:
                      v375 = **((_QWORD **)v24 + 173);
                      *(_BYTE *)(*(_QWORD *)(v375 + 8 * j) + 15161) = v374;
                      v372 = v375;
                    }
                  }
                  si_write_index_state((uint64_t)v24, 1, 0);
                  v107 = v428;
                  v191 = 0;
                  v76 = v447;
LABEL_529:
                  v45 = v439;
                  v376 = v191;
                  v31 = v451;
                  if (!*v437)
                  {
                    v377 = (char *)fd_create_protected(*((_DWORD *)v24 + 8), "topK.v2.mdplistc", 0, 0);
                    if (v377)
                    {
                      v409 = v107;
                      v378 = v376;
                      v379 = v377;
                      memset(buf, 0, 144);
                      fd_stat((uint64_t)v377, (stat *)buf);
                      v423 = v379;
                      v380 = (uint64_t)v379;
                      v376 = v378;
                      v381 = fd_mmap(v380);
                      if (v381 != -1)
                      {
                        v382 = (void *)v381;
                        *(_QWORD *)v481 = v381;
                        *(_QWORD *)&v481[8] = *(_QWORD *)&buf[96];
                        *(_QWORD *)&v481[16] = 0;
                        v454[0] = 1;
                        v454[1] = v481;
                        do
                        {
                          v383 = __ldxr(exceptionSequenceNum);
                          v384 = v383 + 1;
                        }
                        while (__stxr(v383 + 1, exceptionSequenceNum));
                        v385 = setThreadIdAndInfo(-1, (__int128 *)sMappingExceptionCallbacks, (uint64_t)v454, 0, v384);
                        v386 = v385;
                        v453 = v387;
                        v452 = v388;
                        v389 = *(_QWORD *)&threadData[18 * v385 + 2];
                        v390 = v389 + 320 * HIDWORD(v385);
                        *(_BYTE *)(v390 + 216) = 0;
                        v391 = *(_DWORD *)(v390 + 312);
                        v392 = *(void (**)(_QWORD))(v390 + 224);
                        if (v392)
                          v392(*(_QWORD *)(v389 + 320 * HIDWORD(v385) + 288));
                        if (_setjmp((int *)v390))
                        {
                          v393 = (_DWORD *)(v390 + 312);
                          v394 = *__error();
                          v395 = _SILogForLogForCategory(0);
                          if (os_log_type_enabled(v395, OS_LOG_TYPE_ERROR))
                          {
                            *(_DWORD *)v477 = 136315394;
                            v478 = "_SIOpenIndex";
                            v479 = 1024;
                            v480 = 11406;
                            _os_log_error_impl(&dword_1B8270000, v395, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", v477, 0x12u);
                          }
                          *__error() = v394;
                          *v393 = v391;
                          CIOnThreadCleanUpReset(v452);
                          dropThreadId(v386, 1, v384);
                          CICleanUpReset(v386, v453);
                        }
                        else
                        {
                          *((_QWORD *)v24 + 83) = _MDPlistContainerCreateWithBytes();
                          v396 = *(_QWORD *)&threadData[18 * v386 + 2];
                          v397 = v396 + 320 * HIDWORD(v386);
                          *(_DWORD *)(v397 + 312) = v391;
                          v398 = *(void (**)(_QWORD))(v397 + 232);
                          if (v398)
                            v398(*(_QWORD *)(v396 + 320 * HIDWORD(v386) + 288));
                          dropThreadId(v386, 0, v384);
                        }
                        if (!*((_QWORD *)v24 + 83))
                          munmap(v382, *(size_t *)&buf[96]);
                        v31 = v451;
                        v76 = v447;
                        v45 = v439;
                        v376 = v378;
                      }
                      fd_release(v423);
                      v107 = v409;
                    }
                  }
                  v467 = 1;
                  v399 = *(_QWORD *)&threadData[18 * v463 + 2];
                  v400 = v462;
                  v401 = v399 + 320 * v462;
                  *(_DWORD *)(v401 + 312) = v438;
                  v402 = *(void (**)(_QWORD))(v401 + 232);
                  if (v402)
                    v402(*(_QWORD *)(v399 + 320 * v400 + 288));
                  dropThreadId(v463, 0, v443);
                  v49 = v376;
                  goto LABEL_109;
                }
                v361 = *((_QWORD *)v24 + 828);
                if (v361)
                {
                  LODWORD(v361) = *(_DWORD *)(v361 + 4408);
                  switch((_DWORD)v361)
                  {
                    case 0xC001D00D:
                      v24[2483] = 4;
                      goto LABEL_502;
                    case 0xD00D0DD0:
                      LOBYTE(v361) = 3;
                      break;
                    case 2:
                      break;
                    default:
                      v24[2483] = 1;
                      v24[2481] = 1;
                      goto LABEL_502;
                  }
                }
                v24[2483] = v361;
                v476 = v300 | 1;
                goto LABEL_502;
              }
LABEL_345:
              v209 = v435;
              goto LABEL_348;
            }
            v411 = v211;
            v407 = reverseStoreNeedsRecover(*((_DWORD *)v24 + 8));
            v404 = *__error();
            v232 = _SILogForLogForCategory(0);
            v233 = 2 * (gSILogLevels[0] < 4);
            if (os_log_type_enabled(v232, v233))
            {
              *(_DWORD *)buf = 67109120;
              *(_DWORD *)&buf[4] = v407;
              _os_log_impl(&dword_1B8270000, v232, v233, "reverse store state: %x", buf, 8u);
            }
            *__error() = v404;
            if (v407 < 0)
            {
              v76 = v447;
              v217 = MEMORY[0x1E0C809B0];
              v208 = v439;
              v209 = v435;
              if (v407 == -1073623027)
                goto LABEL_284;
              if (v407 == -804450864)
              {
                if (v215 == 7)
                  goto LABEL_285;
                if (v215 != 4)
                  goto LABEL_348;
                v234 = *__error();
                v235 = _SILogForLogForCategory(0);
                v236 = gSILogLevels[0] < 3;
                if (os_log_type_enabled(v235, (os_log_type_t)(gSILogLevels[0] < 3)))
                {
                  *(_DWORD *)buf = 67109632;
                  *(_DWORD *)&buf[4] = 4;
                  *(_WORD *)&buf[8] = 1024;
                  *(_DWORD *)&buf[10] = -804450864;
                  *(_WORD *)&buf[14] = 1024;
                  *(_DWORD *)&buf[16] = v411;
                  _os_log_impl(&dword_1B8270000, v235, v236, "*warn* datastore dirty, reverse store needs shadow -- forcing repair (%u, %u, %u)", buf, 0x14u);
                }
                *__error() = v234;
                v237 = "ds dirty, rs needs shadow ";
LABEL_429:
                _si_set_error_str(v237);
                *a10 = 1;
                v323 = *(_QWORD *)&threadData[18 * v463 + 2];
                v324 = v462;
                v325 = v323 + 320 * v462;
                *(_DWORD *)(v325 + 312) = v438;
                v326 = *(void (**)(_QWORD))(v325 + 232);
                if (v326)
                  v326(*(_QWORD *)(v323 + 320 * v324 + 288));
                dropThreadId(v463, 0, v443);
                goto LABEL_480;
              }
            }
            else
            {
              if (!v407)
              {
                if (!v427)
                {
                  v216 = 4;
                  v217 = MEMORY[0x1E0C809B0];
                  goto LABEL_345;
                }
                v320 = *__error();
                v321 = _SILogForLogForCategory(0);
                v322 = gSILogLevels[0] < 3;
                if (os_log_type_enabled(v321, (os_log_type_t)(gSILogLevels[0] < 3)))
                {
                  *(_WORD *)buf = 0;
                  _os_log_impl(&dword_1B8270000, v321, v322, "*warn* datastore needs shadow, reverse store dirty -- forcing repair", buf, 2u);
                }
                *__error() = v320;
                v237 = "ds needs shadow, rs dirty";
                goto LABEL_429;
              }
              v76 = v447;
              v217 = MEMORY[0x1E0C809B0];
              v208 = v439;
              v209 = v435;
              if (v407 == 2)
                goto LABEL_284;
            }
            v258 = *(_QWORD *)&threadData[18 * v463 + 2];
            v259 = v462;
            v260 = v258 + 320 * v462;
            *(_DWORD *)(v260 + 312) = v438;
            v261 = *(void (**)(_QWORD))(v260 + 232);
            if (v261)
              v261(*(_QWORD *)(v258 + 320 * v259 + 288));
            dropThreadId(v463, 0, v443);
            v262 = "invalid reverse store";
LABEL_396:
            _si_set_error_str(v262);
            v191 = 0;
            v35 = v13;
            v34 = v450;
LABEL_485:
            v33 = v76;
            v32 = v191;
            v31 = v451;
            goto LABEL_63;
          }
        }
        v210 = 4;
        v211 = 2;
        v212 = 0;
        v213 = v184;
        goto LABEL_278;
      }
    }
    v24[2073] = 1;
    goto LABEL_199;
  }
  v104 = (_DWORD *)(v102 + 312);
  v105 = *__error();
  v106 = _SILogForLogForCategory(0);
  v31 = v451;
  if (os_log_type_enabled(v106, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)&buf[4] = "_SIOpenIndex";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 11415;
    _os_log_error_impl(&dword_1B8270000, v106, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
  }
  *__error() = v105;
  *v104 = v438;
  CIOnThreadCleanUpReset(v461);
  dropThreadId(v463, 1, v443);
  CICleanUpReset(v463, HIDWORD(v461));
  v49 = -1;
  v107 = 0;
  v76 = v447;
  v45 = v439;
LABEL_109:
  if (!v467)
  {
    _si_set_error_str("index setup error");
    v32 = 22;
    v33 = v76;
    v34 = v450;
    goto LABEL_62;
  }
  v50 = v107;
  v23 = v76;
  v46 = v446;
LABEL_36:
  v51 = v49;
  v52 = v23;
  v53 = v50;
  v34 = v450;
  *v450 = v24;
  v432 = v52;
  v430 = v51;
  if (v45)
  {
    v54 = v476;
  }
  else if ((v448 & 8) != 0 || v24[2072] || *((_QWORD *)v24 + 828))
  {
    v54 = v476;
  }
  else
  {
    v54 = v476;
    if (!v476)
    {
      v57 = __si_assert_copy_extra_521(-1);
      v58 = v57;
      v59 = "";
      if (v57)
        v59 = v57;
      __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 11432, "fs_only || newIndex->dirStore || rebuildDirStore", v59);
      free(v58);
      if (__valid_fs(-1))
        v60 = 2989;
      else
        v60 = 3072;
      *(_DWORD *)v60 = -559038737;
      abort();
    }
  }
  v61 = v448;
  v62 = SIInitIndex((uint64_t)v24, v441, v442, v448, a9, (uint64_t)v475, (uint64_t)v474, 0, v54);
  if ((v62 & 0x80000000) != 0)
  {
    if (__si_error_str_key && pthread_getspecific(__si_error_str_key))
      goto LABEL_61;
    v68 = "init index error";
LABEL_60:
    _si_set_error_str(v68);
LABEL_61:
    v32 = 22;
    v33 = v432;
LABEL_62:
    v35 = v449;
LABEL_63:
    if (v472)
    {
      CFRelease(v472);
      v472 = 0;
    }
    v471 = 0uLL;
    _SICloseIndex(v25, 0);
    v69 = *(int **)(v25 + 1184);
    if (v69)
    {
      db_release_datastore_no_sync(v69);
      *(_QWORD *)(v25 + 1184) = 0;
    }
    v70 = *(_QWORD *)(v25 + 6624);
    if (v70)
    {
      freeReverseDirStore(v70);
      *(_QWORD *)(v25 + 6624) = 0;
    }
    *v34 = 0;
LABEL_13:
    if (v474)
      CFRelease(v474);
    if (v475)
      CFRelease(v475);
    MEMORY[0x1BCCB1484](v31);
    close(v31);
    free(v469);
    if (*(_QWORD *)(v25 + 40))
    {
      guarded_close_np();
      if (!v33)
      {
LABEL_25:
        ContentIndexListFree(*(void ***)(v25 + 1392));
        ContentIndexListFree(*(void ***)(v25 + 1384));
        if (v35)
        {
          v42 = *(void (**)(_QWORD))(v35 + 24);
          if (v42)
            v42(v35);
        }
        v43 = *(const void **)(v25 + 1496);
        if (v43)
          CFRelease(v43);
        free((void *)v25);
        *v34 = 0;
        *__error() = v32;
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      close(*(_DWORD *)(v25 + 32));
      if (!v33)
        goto LABEL_25;
    }
    v41 = *(_DWORD *)(v25 + 32);
    if ((v41 & 0x80000000) == 0)
      unregisterForCloning(v41);
    goto LABEL_25;
  }
  v63 = v62;
  v433 = v53;
  if ((~v448 & 0x80100) == 0)
  {
    v64 = *((_DWORD *)v24 + 586);
    *(_QWORD *)v484 = 0;
    *(_QWORD *)&v484[8] = v484;
    *(_QWORD *)&v484[16] = 0x2000000000;
    LOBYTE(v485) = 0;
    *(_QWORD *)buf = MEMORY[0x1E0C809B0];
    *(_QWORD *)&buf[8] = 0x40000000;
    *(_QWORD *)&buf[16] = __exist_precheck_touch_file_block_invoke;
    *(_QWORD *)&buf[24] = &unk_1E6E2D6A0;
    *(_QWORD *)&buf[32] = v484;
    check_touch_file(v444, "132427543.fixed", (uint64_t)buf);
    v65 = *(unsigned __int8 *)(*(_QWORD *)&v484[8] + 24);
    _Block_object_dispose(v484, 8);
    if (v65)
    {
      v61 = v448;
      if (gSILogLevels[0] < 5)
        goto LABEL_163;
      v445 = v46;
      v66 = *__error();
      v67 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109120;
        *(_DWORD *)&buf[4] = v440;
        _os_log_impl(&dword_1B8270000, v67, OS_LOG_TYPE_DEFAULT, "(%u) precheck touch file exists", buf, 8u);
      }
      *__error() = v66;
      v31 = v451;
      v34 = v450;
      goto LABEL_162;
    }
    if (totalDiskSpaceSize_onceToken[0] != -1)
      dispatch_once(totalDiskSpaceSize_onceToken, &__block_literal_global_774);
    v108 = gTotalDiskSpaceSize;
    v109 = openat(v444, ".", 0);
    v445 = v46;
    if (v109 == -1)
    {
      v137 = *__error();
      v138 = _SILogForLogForCategory(0);
      v139 = gSILogLevels[0] < 3;
      if (os_log_type_enabled(v138, (os_log_type_t)(gSILogLevels[0] < 3)))
      {
        v140 = *__error();
        *(_DWORD *)buf = 67109376;
        *(_DWORD *)&buf[4] = v444;
        *(_WORD *)&buf[8] = 1024;
        *(_DWORD *)&buf[10] = v140;
        _os_log_impl(&dword_1B8270000, v138, v139, "*warn* openat(%d): %d", buf, 0xEu);
      }
      *__error() = v137;
      goto LABEL_162;
    }
    v110 = v109;
    v111 = fdopendir(v109);
    if (!v111)
    {
      v141 = *__error();
      v142 = _SILogForLogForCategory(0);
      v143 = gSILogLevels[0] < 3;
      if (os_log_type_enabled(v142, (os_log_type_t)(gSILogLevels[0] < 3)))
      {
        v144 = *__error();
        *(_DWORD *)buf = 67109376;
        *(_DWORD *)&buf[4] = v110;
        *(_WORD *)&buf[8] = 1024;
        *(_DWORD *)&buf[10] = v144;
        _os_log_impl(&dword_1B8270000, v142, v143, "*warn* fdopendir(%d): %d", buf, 0xEu);
      }
      *__error() = v141;
      close(v110);
      v31 = v451;
      goto LABEL_162;
    }
    v420 = v108;
    v422 = v108;
    v112 = v111;
    memset(buf, 0, 144);
    v113 = 0;
    v415 = time(0);
    v114 = 0;
    v115 = 0;
    v116 = 0;
LABEL_116:
    v416 = v115;
    v419 = v113;
    v117 = v116;
LABEL_117:
    v418 = v117;
    v118 = v114;
LABEL_118:
    v417 = v118;
    while (1)
    {
      v119 = readdir(v112);
      if (!v119)
        break;
      v120 = v119;
      if (v119->d_type == 8)
      {
        d_name = v119->d_name;
        if (v119->d_name[0] != 46 && !strstr(v119->d_name, ".shadow") && !fstatat(v444, d_name, (stat *)buf, 32))
        {
          if (!strncmp(d_name, "journalAttr.", 0xCuLL))
          {
            v122 = strlen(d_name);
            if (strncmp(&d_name[v122 - 3], "toc", 3uLL))
            {
              *(_DWORD *)v484 = 0;
              if (sscanf(&v120->d_name[12], "%d", v484) == 1
                && *(int *)v484 > v64
                && (v113 += *(_QWORD *)&buf[96], v415 > *(uint64_t *)&buf[48]))
              {
                if (v416 <= v415 - *(_QWORD *)&buf[48])
                  v123 = v415 - *(_QWORD *)&buf[48];
                else
                  v123 = v416;
              }
              else
              {
                v123 = v416;
              }
              v115 = v123;
              v114 = v417;
              v116 = v418;
              goto LABEL_116;
            }
          }
          if (strstr(d_name, ".indexPostings") && !strncmp(&d_name[v120->d_namlen - 14], ".indexPostings", 0xEuLL))
          {
            v114 = *(_QWORD *)&buf[96] + v417;
            v118 = *(_QWORD *)&buf[96] + v417;
            if (v415 <= *(uint64_t *)&buf[48])
              goto LABEL_118;
            v117 = v418;
            if (v418 <= v415 - *(_QWORD *)&buf[48])
              v117 = v415 - *(_QWORD *)&buf[48];
            goto LABEL_117;
          }
        }
      }
    }
    closedir(v112);
    if (v113 >> 29 && v416 >= 604801)
    {
      v134 = *__error();
      v135 = _SILogForLogForCategory(0);
      v136 = gSILogLevels[0] < 3;
      v31 = v451;
      v34 = v450;
      if (os_log_type_enabled(v135, (os_log_type_t)(gSILogLevels[0] < 3)))
      {
        *(_DWORD *)v484 = 134218240;
        *(_QWORD *)&v484[4] = v419;
        *(_WORD *)&v484[12] = 2048;
        *(_QWORD *)&v484[14] = v416;
        _os_log_impl(&dword_1B8270000, v135, v136, "*warn* Huge unprocessed journal files detected. size:%llu age:%lus", v484, 0x16u);
      }
LABEL_195:
      v35 = v449;
      v33 = v432;
      *__error() = v134;
      dump_filesystem_meta(v444);
      _si_set_error_str("Rebuilding index because of huge journals or merge files");
      v32 = 22;
      goto LABEL_13;
    }
    if (v417 >> 30 >= 5 && v420 <= 10 * v417)
    {
      v158 = *__error();
      v159 = _SILogForLogForCategory(0);
      v160 = gSILogLevels[0] < 3;
      v31 = v451;
      v34 = v450;
      if (os_log_type_enabled(v159, (os_log_type_t)(gSILogLevels[0] < 3)))
      {
        *(_DWORD *)v484 = 136316162;
        *(_QWORD *)&v484[4] = ".indexPostings";
        *(_WORD *)&v484[12] = 2048;
        *(_QWORD *)&v484[14] = v417;
        *(_WORD *)&v484[22] = 2048;
        v485 = v418;
        v486 = 2048;
        v487 = v419;
        v488 = 2048;
        v489 = v422;
        _os_log_impl(&dword_1B8270000, v159, v160, "*warn* Huge *%s files detected. size:%llu age:%lus journals:%llu totalDisk:%llu", v484, 0x34u);
      }
      v134 = v158;
      goto LABEL_195;
    }
    v170 = unlinkat(v444, "130162031.fixed", 0);
    v171 = *__error();
    v172 = *__error();
    v173 = _SILogForLogForCategory(0);
    v174 = os_log_type_enabled(v173, OS_LOG_TYPE_DEFAULT);
    if (v170)
    {
      v175 = v444;
      if (v174)
      {
        *(_DWORD *)v484 = 67109632;
        *(_DWORD *)&v484[4] = v440;
        *(_WORD *)&v484[8] = 1024;
        *(_DWORD *)&v484[10] = v444;
        *(_WORD *)&v484[14] = 1024;
        *(_DWORD *)&v484[16] = v171;
        v176 = "(%u) did not delete previous touch file %d err %d";
LABEL_289:
        _os_log_impl(&dword_1B8270000, v173, OS_LOG_TYPE_DEFAULT, v176, v484, 0x14u);
      }
    }
    else
    {
      v175 = v444;
      if (v174)
      {
        *(_DWORD *)v484 = 67109632;
        *(_DWORD *)&v484[4] = v440;
        *(_WORD *)&v484[8] = 1024;
        *(_DWORD *)&v484[10] = v444;
        *(_WORD *)&v484[14] = 1024;
        *(_DWORD *)&v484[16] = v171;
        v176 = "(%u) deleted previous touch file %d err %d";
        goto LABEL_289;
      }
    }
    *__error() = v172;
    *__error() = v171;
    v218 = openat(v175, "132427543.fixed", 513, 384);
    v219 = *__error();
    v220 = v219;
    if (v218 != -1)
    {
      v410 = v218;
      v221 = *__error();
      v222 = _SILogForLogForCategory(0);
      v223 = v222;
      if (v219 == 2)
      {
        v46 = v445;
        if (os_log_type_enabled(v222, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)v484 = 67109376;
          *(_DWORD *)&v484[4] = v440;
          *(_WORD *)&v484[8] = 1024;
          *(_DWORD *)&v484[10] = v444;
          v224 = OS_LOG_TYPE_DEFAULT;
          v225 = "(%u) create touch file %d";
          v226 = 14;
          v227 = v223;
LABEL_299:
          _os_log_impl(&dword_1B8270000, v227, v224, v225, v484, v226);
        }
      }
      else
      {
        v231 = gSILogLevels[0] < 3;
        v46 = v445;
        if (os_log_type_enabled(v222, (os_log_type_t)(gSILogLevels[0] < 3)))
        {
          *(_DWORD *)v484 = 67109632;
          *(_DWORD *)&v484[4] = v440;
          *(_WORD *)&v484[8] = 1024;
          *(_DWORD *)&v484[10] = v444;
          *(_WORD *)&v484[14] = 1024;
          *(_DWORD *)&v484[16] = v220;
          v225 = "*warn* (%u) create touch file %d err %d";
          v226 = 20;
          v227 = v223;
          v224 = v231;
          goto LABEL_299;
        }
      }
      *__error() = v221;
      *__error() = v220;
      close(v410);
      v31 = v451;
      v34 = v450;
      v61 = v448;
      goto LABEL_163;
    }
    v228 = *__error();
    v229 = _SILogForLogForCategory(0);
    v230 = gSILogLevels[0] < 3;
    if (os_log_type_enabled(v229, (os_log_type_t)(gSILogLevels[0] < 3)))
    {
      *(_DWORD *)v484 = 67109632;
      *(_DWORD *)&v484[4] = v440;
      *(_WORD *)&v484[8] = 1024;
      *(_DWORD *)&v484[10] = v444;
      *(_WORD *)&v484[14] = 1024;
      *(_DWORD *)&v484[16] = v220;
      _os_log_impl(&dword_1B8270000, v229, v230, "*warn* (%u) create touch file %d err %d", v484, 0x14u);
    }
    *__error() = v228;
    *__error() = v220;
    v31 = v451;
    v34 = v450;
LABEL_162:
    v61 = v448;
    v46 = v445;
  }
LABEL_163:
  v145 = v61 & 0xC;
  if ((v61 & 0xC) == 0)
  {
    if ((v61 & 0x200) != 0 && !v24[2073])
    {
      _si_set_error_str("index not created with unigrams error");
      v33 = v432;
      v32 = v430;
      goto LABEL_62;
    }
    if ((si_validate_db((uint64_t)v24) & 1) == 0)
    {
      v35 = v449;
      if (!__si_error_str_key || !pthread_getspecific(__si_error_str_key))
        _si_set_error_str("name table is missing dummy values");
      v32 = 22;
      v33 = v432;
      goto LABEL_63;
    }
    indexmetadata = si_create_indexmetadata((uint64_t)v24, 1);
    if (indexmetadata)
    {
      free(indexmetadata);
LABEL_171:
      v148 = (uint64_t *)*((_QWORD *)v24 + 173);
      *(_QWORD *)buf = v24;
      __checkIndexSetDocIdOrder((uint64_t)v24, v148);
      v149 = (uint64_t *)*((_QWORD *)v24 + 174);
      *(_QWORD *)buf = v24;
      __checkIndexSetDocIdOrder((uint64_t)v24, v149);
      if (v46)
        goto LABEL_217;
      v150 = (int *)*((_QWORD *)v24 + 173);
      v151 = (int *)*((_QWORD *)v24 + 174);
      v152 = (uint64_t)v151;
      disableWritingForAllButLastOfRunsOfTransaction(v150);
      disableWritingForAllButLastOfRunsOfTransaction(v151);
      if (v150[2] >= 2)
      {
        if ((v24[6586] & 4) != 0)
          NotCompactCount = 0;
        else
          NotCompactCount = indexSetGetNotCompactCount((uint64_t)v150);
        NotMergedCount = indexSetGetNotMergedCount((uint64_t *)v150);
        LiveCount = indexSetGetLiveCount(*(_QWORD *)v150, v150[2]);
        if (NotCompactCount >= 10)
        {
          v156 = (uint64_t)v24;
          v157 = NotCompactCount;
LABEL_203:
          holdAndIssueMerge(v156, v157, (uint64_t)v150, 1);
          v152 = (uint64_t)v151;
          goto LABEL_204;
        }
        if (NotMergedCount > 10)
        {
          v156 = (uint64_t)v24;
          v157 = NotMergedCount;
          goto LABEL_203;
        }
        if (LiveCount >= 6)
        {
          v157 = LiveCount - 1;
          v156 = (uint64_t)v24;
          goto LABEL_203;
        }
        v152 = (uint64_t)v151;
        if (NotCompactCount)
          compactReadOnlyIndexes((uint64_t)v24, 1);
      }
LABEL_204:
      v31 = v451;
      if (*(_DWORD *)(v152 + 8) >= 2u)
      {
        if ((v24[6586] & 4) != 0)
          v164 = 0;
        else
          v164 = indexSetGetNotCompactCount(v152);
        v165 = indexSetGetNotMergedCount((uint64_t *)v152);
        if (indexSetGetWritableCount(v152) || (v166 = *(_DWORD *)(v152 + 8), v166 < 2))
        {
          if (v164 >= 10)
          {
            v167 = (uint64_t)v24;
            v168 = v164;
LABEL_216:
            holdAndIssueMerge(v167, v168, v152, 0);
            v31 = v451;
            goto LABEL_217;
          }
          if (v165 > 10)
          {
            v167 = (uint64_t)v24;
            v168 = v165;
            goto LABEL_216;
          }
          v166 = *(_DWORD *)(v152 + 8);
          if (v166 < 0x1A)
          {
            v31 = v451;
            if (v164)
              compactReadOnlyIndexes((uint64_t)v24, 0);
            goto LABEL_217;
          }
        }
        v168 = v166 >> 1;
        v167 = (uint64_t)v24;
        goto LABEL_216;
      }
LABEL_217:
      free(v469);
      MEMORY[0x1BCCB1484](v31);
      close(v31);
      if ((v448 & 1) == 0)
        _SIPreHeatIndex((uint64_t)v24, 0, 1);
      v146 = v433;
      if (!(v63 | v145))
      {
        if (v433)
          v169 = 39;
        else
          v169 = 38;
        SIActivityJournalOpen((uint64_t)(v24 + 2192), v169, *((_DWORD *)v24 + 586), *(_DWORD *)(*((_QWORD *)v24 + 174) + 8), *(_DWORD *)(*((_QWORD *)v24 + 173) + 8), *((_QWORD *)v24 + 266), *((_QWORD *)v24 + 267), *((_QWORD *)v24 + 301));
      }
      goto LABEL_224;
    }
    if (__si_error_str_key && pthread_getspecific(__si_error_str_key))
      goto LABEL_61;
    v68 = "missing system dbo";
    goto LABEL_60;
  }
  if ((v61 & 8) == 0)
    goto LABEL_171;
  free(v469);
  MEMORY[0x1BCCB1484](v31);
  close(v31);
  v146 = v433;
LABEL_224:
  if (v475)
    CFRelease(v475);
  if (v474)
    CFRelease(v474);
  si_cacheIndexVersion((uint64_t)v24);
  if (v63)
    return v63;
  else
    return v146;
}

uint64_t SICreateNewIndex(uint64_t *a1, unsigned int a2, uint64_t a3, uint64_t a4, unsigned int a5, __int128 *a6, uint64_t a7, uint64_t a8, _DWORD *a9)
{
  uint64_t v15;
  unsigned int v16;
  unsigned int v17;
  char *v18;
  __int128 v19;
  _DWORD *v20;
  int v21;
  int v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  int v26;
  NSObject *v27;
  os_log_type_t v28;
  const void *v29;
  void (*v30)(void);
  uint64_t v32;
  uint64_t v33;
  int v34;
  int v35;
  _BOOL4 v36;
  int v37;
  int v38;
  NSObject *v39;
  int v40;
  uint64_t v41;
  int v42;
  int v43;
  int v44;
  NSObject *v45;
  uint64_t v46;
  const void *v47;
  const __CFAllocator *v48;
  CFNumberRef v49;
  CFStringRef v50;
  CFNumberRef v51;
  uint64_t v52;
  int v53;
  int v54;
  _QWORD *v55;
  char *v56;
  char *v57;
  char *v58;
  char *v59;
  char *v60;
  char *v61;
  char *v62;
  char *v63;
  _DWORD *v64;
  void *v65;
  uint64_t v66;
  _DWORD *v67;
  void *v68;
  uint64_t v69;
  int v70;
  unsigned int v71;
  unsigned int v72;
  int *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  int *vector_store;
  int v79;
  unsigned int v80;
  int v81;
  NSObject *v82;
  int v83;
  BOOL v84;
  _BYTE *v85;
  time_t v86;
  uint64_t v87;
  int *LiveIndex;
  int *v89;
  int v90;
  int v91;
  uint64_t v92;
  _DWORD *datastore_with_ctx;
  void *ReverseStore;
  int v95;
  int **v96;
  unsigned int id_for_field;
  const __CFAllocator *v98;
  __CFDictionary *Mutable;
  int id_for_value;
  int v101;
  int v102;
  int v103;
  int v104;
  int v105;
  int v106;
  int v107;
  int v108;
  int v109;
  int v110;
  int v111;
  int v112;
  int v113;
  int v114;
  int v115;
  int v116;
  int v117;
  int v118;
  int v119;
  int v120;
  int v121;
  int v122;
  int v123;
  int v124;
  int v125;
  int v126;
  int v127;
  int v128;
  int v129;
  int v130;
  int v131;
  int v132;
  int v133;
  int v134;
  int v135;
  int v136;
  int v137;
  int v138;
  int v139;
  int v140;
  int v141;
  int v142;
  int v143;
  int v144;
  int v145;
  int v146;
  int v147;
  int v148;
  int v149;
  int v150;
  int v151;
  int v152;
  int v153;
  int v154;
  int v155;
  int v156;
  int v157;
  int v158;
  int v159;
  int v160;
  int v161;
  int v162;
  int v163;
  int v164;
  int v165;
  int v166;
  int v167;
  int v168;
  int v169;
  int v170;
  int v171;
  int v172;
  int v173;
  int v174;
  int v175;
  int v176;
  int v177;
  int v178;
  int v179;
  int v180;
  int v181;
  int v182;
  int v183;
  int v184;
  int v185;
  int v186;
  int v187;
  int v188;
  int v189;
  int v190;
  int v191;
  int v192;
  int v193;
  int v194;
  int v195;
  int v196;
  int v197;
  int v198;
  int v199;
  int v200;
  int v201;
  int v202;
  int v203;
  int v204;
  int v205;
  int v206;
  int v207;
  int v208;
  int v209;
  int v210;
  int v211;
  int v212;
  int v213;
  int v214;
  int v215;
  int v216;
  int v217;
  int v218;
  int v219;
  int v220;
  int v221;
  int v222;
  int v223;
  int v224;
  int v225;
  int v226;
  int v227;
  int v228;
  int v229;
  int v230;
  int v231;
  int v232;
  int v233;
  int v234;
  int v235;
  int v236;
  int v237;
  CFNumberRef v238;
  int v239;
  NSObject *v240;
  int v241;
  NSObject *v242;
  unsigned int v243;
  uint64_t v244;
  NSObject *v245;
  int v246;
  BOOL v247;
  _BYTE *v248;
  int v249;
  BOOL v250;
  _BYTE *v251;
  char *v252;
  char *v253;
  const char *v254;
  uint64_t v255;
  int v256;
  BOOL v257;
  _BYTE *v258;
  int v259;
  NSObject *v260;
  int v261;
  BOOL v262;
  _BYTE *v263;
  int v264;
  NSObject *v265;
  int v266;
  BOOL v267;
  _BYTE *v268;
  int v269;
  NSObject *v270;
  int v271;
  BOOL v272;
  _BYTE *v273;
  unsigned int v274;
  int v275;
  unsigned int v276;
  uint64_t v277;
  uint64_t v278;
  int v279;
  uint64_t v280;
  uint64_t *v281;
  unsigned int v282;
  uint64_t v283;
  unsigned int v284;
  _QWORD v285[5];
  uint64_t v286;
  _QWORD v287[5];
  uint8_t valuePtr[4];
  const char *v289;
  __int16 v290;
  int v291;
  __int16 v292;
  _BYTE *v293;
  __int16 v294;
  const char *v295;
  uint8_t buf[40];
  _BYTE v297[1024];
  uint64_t v298;

  v298 = *MEMORY[0x1E0C80C00];
  if (freeQueueOnce[0] != -1)
  {
    v243 = a5;
    v244 = a3;
    dispatch_once(freeQueueOnce, &__block_literal_global_223);
    a3 = v244;
    a5 = v243;
  }
  v15 = 0xFFFFFFFFLL;
  if ((a5 & 4) != 0)
    return v15;
  v280 = a3;
  v281 = a1;
  v277 = a4;
  v278 = a8;
  v279 = a2;
  v16 = a5 & 0x100;
  v17 = a5 & 0x200;
  v284 = a5;
  v282 = open(".", 4);
  bzero(v297, 0x400uLL);
  _SITuningInit();
  makeThreadId();
  v18 = (char *)malloc_type_calloc(1uLL, 0x2780uLL, 0x10F0040E1D49570uLL);
  SIInitIndexLocks((uint64_t)v18);
  v287[0] = MEMORY[0x1E0C809B0];
  v287[1] = 0x40000000;
  v287[2] = __SICreateNewIndex_block_invoke_2;
  v287[3] = &__block_descriptor_tmp_226;
  v287[4] = v18;
  *(_QWORD *)v18 = 0xC0DE10DE10DEC0DELL;
  *((_DWORD *)v18 + 15) = HIBYTE(v284);
  *((_DWORD *)v18 + 8) = -1;
  *((_DWORD *)v18 + 12) = -1;
  v18[2072] = BYTE1(v16);
  v18[2073] = v17 >> 9;
  v19 = *a6;
  *((_QWORD *)v18 + 3) = *((_QWORD *)a6 + 2);
  *(_OWORD *)(v18 + 8) = v19;
  v283 = a7;
  *((_QWORD *)v18 + 295) = a7;
  *((_QWORD *)v18 + 290) = 0;
  *((_QWORD *)v18 + 824) = a9;
  *((_DWORD *)v18 + 364) = 1;
  v20 = v18;
  *((_DWORD *)v18 + 1646) = *((_DWORD *)v18 + 1646) & 0xFFFBFFFF | (v16 << 10);
  if (*a9)
  {
    _si_set_error_str("open canceled");
LABEL_6:
    v21 = 0;
    v22 = 0;
    v23 = v282;
    v24 = a1;
    v25 = (uint64_t)v20;
LABEL_7:
    v26 = *__error();
    v27 = _SILogForLogForCategory(0);
    v28 = 2 * (gSILogLevels[0] < 4);
    if (os_log_type_enabled(v27, v28))
    {
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)&buf[4] = v22;
      *(_WORD *)&buf[8] = 1024;
      *(_DWORD *)&buf[10] = v21;
      _os_log_impl(&dword_1B8270000, v27, v28, "Failed at %d (%d)", buf, 0xEu);
    }
    *__error() = v26;
    MEMORY[0x1BCCB1484](v23);
    close(v23);
    ContentIndexListFree(*(void ***)(v25 + 1392));
    ContentIndexListFree(*(void ***)(v25 + 1384));
    v29 = *(const void **)(v25 + 1496);
    if (v29)
      CFRelease(v29);
    if (v283)
    {
      v30 = *(void (**)(void))(v283 + 24);
      if (v30)
        v30();
    }
    free((void *)v25);
    *v24 = 0;
    return 0xFFFFFFFFLL;
  }
  v276 = v17;
  if (v16)
  {
    v37 = 0;
    v36 = 1;
    v32 = a2;
  }
  else
  {
    v32 = a2;
    v33 = v280;
    if (v280 && ((v34 = *(_DWORD *)(v280 + 4), v34 == -1) || (v35 = dup(v34), v33 = v280, v20[12] = v35, v35 == -1)))
    {
      if ((v284 & 8) != 0)
        goto LABEL_6;
      v37 = *(_BYTE *)(v33 + 28) & 1;
      v36 = (v284 & 0x180) != 0;
    }
    else
    {
      v36 = 0;
      v37 = 0;
    }
  }
  *(_DWORD *)buf = 0;
  v25 = (uint64_t)v20;
  if (fd_setDir(v32, (int *)buf))
  {
    v38 = *__error();
    v39 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)valuePtr = 0;
      _os_log_impl(&dword_1B8270000, v39, OS_LOG_TYPE_DEFAULT, "Creating New Index", valuePtr, 2u);
    }
    *__error() = v38;
    v40 = *(_DWORD *)buf;
    MEMORY[0x1BCCB1484](*(unsigned int *)buf);
    if ((v40 & 0x80000000) == 0)
      close(v40);
  }
  v41 = v284;
  if ((v284 & 8) == 0)
  {
    if (!a7)
    {
      v252 = __si_assert_copy_extra_521(-1);
      v253 = v252;
      v254 = "";
      if (v252)
        v254 = v252;
      __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 12718, "callbacks", v254);
      free(v253);
      if (__valid_fs(-1))
        v255 = 2989;
      else
        v255 = 3072;
      *(_DWORD *)v255 = -559038737;
      abort();
    }
    v42 = check_crash_state(v32, v37, v284, 0, 0);
    if (v42)
    {
      v43 = v42;
      v44 = *__error();
      v45 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
      {
        v83 = fcntl(v32, 50, v297);
        if (v297[0])
          v84 = v83 < 0;
        else
          v84 = 1;
        if (v84)
          v85 = 0;
        else
          v85 = v297;
        *(_DWORD *)buf = 136315906;
        *(_QWORD *)&buf[4] = "SICreateNewIndex";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 12721;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v43;
        *(_WORD *)&buf[24] = 2080;
        *(_QWORD *)&buf[26] = v85;
        _os_log_error_impl(&dword_1B8270000, v45, OS_LOG_TYPE_ERROR, "%s:%d: check_crash_state: %d for %s", buf, 0x22u);
      }
      v21 = 0;
      v22 = 0;
      *__error() = v44;
      v23 = v282;
      v24 = v281;
      goto LABEL_7;
    }
    *((_QWORD *)v20 + 4) = guarded_dup(v32);
    *((_QWORD *)v20 + 5) = v52;
    check_crash_state(v32, v37, v284, 0, 1);
    if ((v284 & 0x80000001) != 0)
      v53 = 17;
    else
      v53 = 81;
    if (*((_BYTE *)v20 + 2072))
      v53 |= 0x100u;
    if (*((_BYTE *)v20 + 2073))
      v53 |= 0x400u;
    v54 = v53 | 0x80;
    if (!v36)
      v54 = v53;
    if ((v20[8] & 0x80000000) != 0)
    {
      v21 = 0;
      v22 = 0;
      goto LABEL_70;
    }
    v274 = v54;
    if (dword_1EF19FCA8 >= 5)
    {
      v259 = *__error();
      v260 = _SILogForLogForCategory(7);
      if (os_log_type_enabled(v260, OS_LOG_TYPE_DEFAULT))
      {
        v261 = fcntl(v279, 50, v297);
        if (v297[0])
          v262 = v261 < 0;
        else
          v262 = 1;
        if (v262)
          v263 = 0;
        else
          v263 = v297;
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)&buf[4] = v263;
        _os_log_impl(&dword_1B8270000, v260, OS_LOG_TYPE_DEFAULT, "Opened %s successfully", buf, 0xCu);
      }
      *__error() = v259;
      v25 = (uint64_t)v20;
      if (dword_1EF19FCA8 >= 5)
      {
        v264 = *__error();
        v265 = _SILogForLogForCategory(7);
        if (os_log_type_enabled(v265, OS_LOG_TYPE_DEFAULT))
        {
          v266 = fcntl(v279, 50, v297);
          if (v297[0])
            v267 = v266 < 0;
          else
            v267 = 1;
          if (v267)
            v268 = 0;
          else
            v268 = v297;
          *(_DWORD *)buf = 136315394;
          *(_QWORD *)&buf[4] = v268;
          *(_WORD *)&buf[12] = 2080;
          *(_QWORD *)&buf[14] = "store.db";
          _os_log_impl(&dword_1B8270000, v265, OS_LOG_TYPE_DEFAULT, "Try %s/%s", buf, 0x16u);
        }
        *__error() = v264;
        v25 = (uint64_t)v20;
      }
    }
    registerForCloning(*(_DWORD *)(v25 + 32), v16 >> 8);
    if (SIIsAppleInternal_onceToken != -1)
      dispatch_once(&SIIsAppleInternal_onceToken, &__block_literal_global_4644);
    if (SIIsAppleInternal_internal)
    {
      v55 = fd_create_protected(*(_DWORD *)(v25 + 32), "activityJournal.1", 536872457, 3u);
      si_activity_journal_init(v25 + 2192, v55);
      fd_mark_purgable(*(_DWORD **)(v25 + 2192));
    }
    v275 = v284 & 8;
    unlinkat(*(_DWORD *)(v25 + 32), "mds64-crash-state", 0);
    unlinkat(*(_DWORD *)(v25 + 32), "mds64-crash-state-v2", 0);
    v56 = (char *)fd_create_protected(*(_DWORD *)(v25 + 32), "CrystalGlow.created", 512, 0);
    fd_release(v56);
    if (!v16)
    {
      v57 = (char *)fd_create_protected(*(_DWORD *)(v25 + 32), "tmp.Lion", 512, 0);
      fd_release(v57);
      v58 = (char *)fd_create_protected(*(_DWORD *)(v25 + 32), "Lion.created", 512, 0);
      fd_release(v58);
      v59 = (char *)fd_create_protected(*(_DWORD *)(v25 + 32), "Glow.created", 512, 0);
      fd_release(v59);
      v60 = (char *)fd_create_protected(*(_DWORD *)(v25 + 32), "tmp.Glow", 512, 0);
      fd_release(v60);
      v61 = (char *)fd_create_protected(*(_DWORD *)(v25 + 32), "tmp.Cab", 512, 0);
      fd_release(v61);
      v62 = (char *)fd_create_protected(*(_DWORD *)(v25 + 32), "Cab.created", 512, 0);
      fd_release(v62);
      *(_DWORD *)(v25 + 6584) |= 0x40u;
      v63 = (char *)fd_create_protected(*(_DWORD *)(v25 + 32), "tmp.Star", 512, 0);
      fd_release(v63);
    }
    v64 = malloc_type_calloc(1uLL, 0x18uLL, 0x1080040A085CBA5uLL);
    *(_QWORD *)(v25 + 1392) = v64;
    v64[3] = 2;
    v65 = malloc_type_calloc(2uLL, 8uLL, 0x2004093837F09uLL);
    v66 = *(_QWORD *)(v25 + 1392);
    *(_QWORD *)v66 = v65;
    *(_DWORD *)(v66 + 16) = -1;
    v67 = malloc_type_calloc(1uLL, 0x18uLL, 0x1080040A085CBA5uLL);
    *(_QWORD *)(v25 + 1384) = v67;
    v67[3] = 2;
    v68 = malloc_type_calloc(2uLL, 8uLL, 0x2004093837F09uLL);
    v69 = *(_QWORD *)(v25 + 1384);
    *(_QWORD *)v69 = v68;
    *(_DWORD *)(v69 + 16) = -1;
    MEMORY[0x1BCCB1484](*(unsigned int *)(v25 + 32));
    if (v276)
      v70 = 3;
    else
      v70 = 1;
    v71 = v16;
    if (v16)
      v72 = v70;
    else
      v72 = v276 >> 8;
    if (CIMetaInfoCreate(*(_DWORD *)(v25 + 32), v25 + 1192, v72))
    {
      v21 = 0;
      v22 = 12844;
LABEL_70:
      v23 = v282;
      v24 = v281;
      goto LABEL_71;
    }
    v286 = 0;
    v75 = *(_QWORD *)(v25 + 1392);
    v76 = *(_QWORD *)(v25 + 1384);
    v77 = *(_QWORD *)(v25 + 6592);
    vector_store = *(int **)(v25 + 1184);
    if (vector_store)
      vector_store = (int *)db_get_vector_store(vector_store);
    v285[0] = MEMORY[0x1E0C809B0];
    v285[1] = 0x40000000;
    v285[2] = __SICreateNewIndex_block_invoke_236;
    v285[3] = &__block_descriptor_tmp_238;
    v285[4] = v25;
    v79 = ContentIndexOpenBulk(v25 + 1192, 0, v75, v76, v274, v77, v25 + 2408, (uint64_t)&v286, (uint64_t)vector_store, (uint64_t)v285, v287);
    if (v79 == 1)
    {
      v86 = time(0);
      v87 = *(_QWORD *)(v25 + 1392);
      v80 = v284 & 0x80000001;
      if (*(_DWORD *)(v87 + 8))
      {
        ContentIndexUpdateTimeStamp(**(int ***)v87, v86, 0, 1);
        ContentIndexUpdateTimeStamp(***(int ****)(v25 + 1392), v86, 1, 1);
      }
      LiveIndex = si_getLiveIndex(*(_QWORD *)(v25 + 1384));
      ContentIndexUpdateTimeStamp(LiveIndex, v86, 0, 1);
      v89 = si_getLiveIndex(*(_QWORD *)(v25 + 1384));
      ContentIndexUpdateTimeStamp(v89, v86, 1, 1);
    }
    else
    {
      v80 = v284 & 0x80000001;
      if (v79 == -1)
      {
        v81 = *__error();
        v82 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v82, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315394;
          *(_QWORD *)&buf[4] = "SICreateNewIndex";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 12856;
          _os_log_error_impl(&dword_1B8270000, v82, OS_LOG_TYPE_ERROR, "%s:%d: Could not create new content index", buf, 0x12u);
        }
        v21 = 0;
        *__error() = v81;
        v22 = 12855;
        goto LABEL_70;
      }
    }
    if (v36)
      v90 = 133376;
    else
      v90 = 256;
    if (*(_BYTE *)(v25 + 2072))
      v91 = 67584;
    else
      v91 = v90;
    if (dword_1EF19FCA8 >= 5)
    {
      v269 = *__error();
      v270 = _SILogForLogForCategory(7);
      if (os_log_type_enabled(v270, OS_LOG_TYPE_DEFAULT))
      {
        v271 = fcntl(v279, 50, v297);
        if (v297[0])
          v272 = v271 < 0;
        else
          v272 = 1;
        if (v272)
          v273 = 0;
        else
          v273 = v297;
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)&buf[4] = v273;
        *(_WORD *)&buf[12] = 2080;
        *(_QWORD *)&buf[14] = "store.db";
        _os_log_impl(&dword_1B8270000, v270, OS_LOG_TYPE_DEFAULT, "Creating store at %s/%s.", buf, 0x16u);
      }
      *__error() = v269;
      v71 = v16;
      v25 = (uint64_t)v20;
      v80 = v284 & 0x80000001;
    }
    memset(buf, 0, sizeof(buf));
    *(_DWORD *)buf = *(_DWORD *)(v25 + 32);
    *(_QWORD *)&buf[8] = "store.db";
    *(_DWORD *)&buf[20] = *(_DWORD *)(v25 + 60);
    if (SIIsAppleInternal_onceToken != -1)
      dispatch_once(&SIIsAppleInternal_onceToken, &__block_literal_global_4644);
    if (SIIsAppleInternal_internal)
      v92 = v25 + 2192;
    else
      v92 = 0;
    *(_QWORD *)&buf[24] = v92;
    buf[32] = 0;
    *(_DWORD *)&buf[16] = v91;
    datastore_with_ctx = db2_create_datastore_with_ctx((uint64_t)buf);
    *(_QWORD *)(v25 + 1184) = datastore_with_ctx;
    if (datastore_with_ctx)
    {
      si_set_vector_store(v25);
      if (v80
        || (ReverseStore = createReverseStore(*(_DWORD *)(v25 + 32), "", v287),
            (*(_QWORD *)(v25 + 6624) = ReverseStore) != 0))
      {
        v95 = 0;
        v96 = (int **)(v25 + 1184);
        do
        {
          id_for_field = db_create_id_for_field(*v96, "_kMDXXXX___DUMMY", (unsigned __int16)v95, (unsigned __int16)v95);
          ++v95;
        }
        while (id_for_field < 6);
        db_create_id_for_value(*v96, "public.message");
        db_create_id_for_value(*v96, "com.apple.mail.emlx");
        db_create_id_for_value(*v96, "com.apple.mail.eml");
        db_create_id_for_value(*v96, "com.microsoft.entourage.virtual.message");
        db_create_id_for_value(*v96, "com.apple.ichat.transcript");
        db_create_id_for_value(*v96, "public.contact");
        db_create_id_for_value(*v96, "public.vcard");
        db_create_id_for_value(*v96, "com.apple.addressbook.person");
        db_create_id_for_value(*v96, "com.apple.addressbook.group");
        db_create_id_for_value(*v96, "com.microsoft.entourage.virtual.contact");
        db_create_id_for_value(*v96, "com.microsoft.entourage.virtual.group");
        db_create_id_for_value(*v96, "com.apple.systempreference.prefpane");
        db_create_id_for_value(*v96, "public.font");
        db_create_id_for_value(*v96, "public.bookmark");
        db_create_id_for_value(*v96, "com.apple.safari.bookmark");
        db_create_id_for_value(*v96, "com.apple.safari.history");
        db_create_id_for_value(*v96, "public.to-do-item");
        db_create_id_for_value(*v96, "public.calendar-event");
        db_create_id_for_value(*v96, "com.apple.ical.bookmark");
        db_create_id_for_value(*v96, "com.apple.ical.bookmark.todo");
        db_create_id_for_value(*v96, "com.apple.ical.ics.event");
        db_create_id_for_value(*v96, "com.apple.ical.ics.todo");
        db_create_id_for_value(*v96, "com.microsoft.entourage.virtual.event");
        db_create_id_for_value(*v96, "com.microsoft.entourage.virtual.task");
        db_create_id_for_value(*v96, "public.movie");
        db_create_id_for_value(*v96, "com.apple.quicktime-movie");
        db_create_id_for_value(*v96, "public.mpeg-video");
        db_create_id_for_value(*v96, "public.mpeg-4");
        db_create_id_for_value(*v96, "public.mpeg");
        db_create_id_for_value(*v96, "public.3gpp");
        db_create_id_for_value(*v96, "public.3gpp2");
        db_create_id_for_value(*v96, "com.apple.application-bundle");
        db_create_id_for_value(*v96, "com.apple.application-file");
        db_create_id_for_value(*v96, "com.apple.dashboard-widget");
        db_create_id_for_value(*v96, "public.folder");
        db_create_id_for_value(*v96, "com.apple.mount-point");
        db_create_id_for_value(*v96, "public.audio");
        db_create_id_for_value(*v96, "public.mpeg-4-audio");
        db_create_id_for_value(*v96, "com.apple.protected-mpeg-4-audio");
        db_create_id_for_value(*v96, "com.adobe.pdf");
        db_create_id_for_value(*v96, "com.apple.localized-pdf-bundle");
        db_create_id_for_value(*v96, "public.presentation");
        db_create_id_for_value(*v96, "com.microsoft.powerpoint.ppt");
        db_create_id_for_value(*v96, "com.apple.keynote.key");
        db_create_id_for_value(*v96, "com.apple.iwork.keynote.key");
        db_create_id_for_value(*v96, "public.image");
        db_create_id_for_value(*v96, "com.apple.motion.project");
        db_create_id_for_value(*v96, "com.apple.iwork.pages.pages");
        db_create_id_for_value(*v96, "com.apple.iwork.pages.sffpages");
        db_create_id_for_value(*v96, "com.apple.iwork.pages.template");
        db_create_id_for_value(*v96, "com.apple.iwork.pages.sfftemplate");
        db_create_id_for_value(*v96, "public.rtf");
        db_create_id_for_value(*v96, "com.apple.rtfd");
        db_create_id_for_value(*v96, "com.apple.flat-rtfd");
        db_create_id_for_value(*v96, "com.microsoft.word.doc");
        db_create_id_for_value(*v96, "org.khronos.collada.digital-asset-exchange");
        db_create_id_for_value(*v96, "public.plain-text");
        db_create_id_for_value(*v96, "public.html");
        db_create_id_for_value(*v96, "public.xhtml");
        db_create_id_for_value(*v96, "public.shell-script");
        db_create_id_for_value(*v96, "public.source-code");
        db_create_id_for_value(*v96, "public.unix-executable");
        db_create_id_for_value(*v96, "com.apple.xcode.project");
        db_create_id_for_value(*v96, "com.apple.xcode.model");
        db_create_id_for_value(*v96, "com.apple.xcode.archive");
        db_create_id_for_value(*v96, "com.apple.xcode.docset");
        db_create_id_for_value(*v96, "com.apple.xcode.projectdata");
        db_create_id_for_value(*v96, "com.apple.xcode.dsym");
        db_create_id_for_value(*v96, "com.apple.xcode.configsettings");
        db_create_id_for_value(*v96, "com.apple.xcode.usersettings");
        db_create_id_for_value(*v96, "com.apple.xcode.strings-text");
        db_create_id_for_value(*v96, "com.apple.xcode.plugin");
        db_create_id_for_value(*v96, "com.apple.xcode.mom");
        db_create_id_for_value(*v96, "com.apple.property-list");
        db_create_id_for_value(*v96, "dyn.ah62d4rv4ge81a7dk");
        db_create_id_for_value(*v96, "dyn.ah62d4rv4ge80u5pbsa");
        db_create_id_for_value(*v96, "com.apple.dashcode.xml");
        db_create_id_for_value(*v96, "com.apple.dashcode.css");
        db_create_id_for_value(*v96, "com.apple.dashcode.javascript");
        db_create_id_for_value(*v96, "com.apple.dashcode.json");
        db_create_id_for_value(*v96, "com.apple.dashcode.manifest");
        db_create_id_for_value(*v96, "com.apple.interfacebuilder.document");
        db_create_id_for_value(*v96, "com.apple.interfacebuilder.document.cocoa");
        db_create_id_for_value(*v96, "com.apple.rez-source");
        db_create_id_for_value(*v96, "com.apple.iphone.developerprofile");
        db_create_id_for_value(*v96, "com.apple.iphone.mobileprovision");
        db_create_id_for_value(*v96, "com.apple.coreanimation-bundle");
        db_create_id_for_value(*v96, "com.apple.coreanimation-xml");
        db_create_id_for_value(*v96, "com.sun.java-class");
        db_create_id_for_value(*v96, "com.apple.scripting-definition");
        db_create_id_for_value(*v96, "com.apple.dt.document.workspace");
        db_create_id_for_value(*v96, "com.apple.dt.document.scheme");
        db_create_id_for_value(*v96, "com.apple.dt.ide.plug-in");
        db_create_id_for_value(*v96, "com.apple.dt.dvt.plug-in");
        db_create_id_for_value(*v96, "com.apple.dt.document.snapshot");
        db_create_id_for_value(*v96, "com.apple.dt.bundle.unit-test.objective-c");
        db_create_id_for_value(*v96, "com.apple.instruments.tracetemplate");
        db_create_id_for_value(*v96, "com.apple.quartzdebug.introspectiontrace");
        db_create_id_for_value(*v96, "com.apple.applescript.text-object");
        db_create_id_for_value(*v96, "com.apple.applescript.data-object");
        db_create_id_for_value(*v96, "com.apple.applescript.url-object");
        db_create_id_for_value(*v96, "com.apple.applescript.alias-object");
        db_create_id_for_value(*v96, "com.apple.symbol-export");
        db_create_id_for_value(*v96, "com.apple.mach-o-binary");
        db_create_id_for_value(*v96, "com.apple.mach-o-object");
        db_create_id_for_value(*v96, "com.apple.mach-o-executable");
        db_create_id_for_value(*v96, "com.apple.x11-mach-o-executable");
        db_create_id_for_value(*v96, "public.object-code");
        db_create_id_for_value(*v96, "com.microsoft.windows-executable");
        db_create_id_for_value(*v96, "com.microsoft.windows-dynamic-link-library");
        db_create_id_for_value(*v96, "com.sun.java-archive");
        db_create_id_for_value(*v96, "com.sun.web-application-archive");
        db_create_id_for_value(*v96, "com.apple.xcode.plugindata");
        db_create_id_for_value(*v96, "com.apple.dt.playground");
        db_create_id_for_value(*v96, "com.apple.iwork.numbers.sffnumbers");
        db_create_id_for_value(*v96, "com.apple.iwork.numbers.numbers");
        db_create_id_for_value(*v96, "com.apple.iwork.numbers.template");
        db_create_id_for_value(*v96, "com.microsoft.excel.xls");
        db_create_id_for_value(*v96, "org.openxmlformats.spreadsheetml.sheet");
        db_create_id_for_value(*v96, "public.spreadsheet");
        db_create_id_for_value(*v96, "public.xml");
        db_create_id_for_value(*v96, "com.apple.log");
        db_create_id_for_value(*v96, "com.apple.crashreport");
        db_create_id_for_value(*v96, "com.apple.spinreport");
        db_create_id_for_value(*v96, "com.apple.panicreport");
        db_create_id_for_value(*v96, "com.apple.shutdownstall");
        db_create_id_for_value(*v96, "com.apple.hangreport");
        db_create_id_for_value(*v96, "public.json");
        db_create_id_for_value(*v96, "public.log");
        db_create_id_for_value(*v96, "public.content");
        db_create_id_for_value(*v96, "com.microsoft.excel.sheet.binary.macroenabled");
        db_create_id_for_value(*v96, "org.openxmlformats.spreadsheetml.sheet.macroenabled");
        db_create_id_for_value(*v96, "com.apple.protected-mpeg-4-audio-b");
        db_create_id_for_value(*v96, "com.audible.aa-audiobook");
        db_create_id_for_value(*v96, "com.audible.aax-audiobook");
        db_create_id_for_value(*v96, "com.apple.tips");
        db_create_id_for_value(*v96, "com.apple.helpviewer");
        db_create_id_for_value(*v96, "com.apple.help.topic");
        db_create_id_for_field(*v96, "kMDItemContentTypeTree", 0x330u, 11);
        db_create_id_for_field(*v96, "kMDItemSupportFileType", 0x330u, 11);
        db_create_id_for_field(*v96, "_kMDItemTimeMachinePath", 0, 0);
        db_create_id_for_field(*v96, "kMDItemContentType", 0x310u, 11);
        db_create_id_for_field(*v96, "_kMDItemGroupId", 0x108u, 2);
        if (!v71)
        {
          v98 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
          Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, 0);
          id_for_value = db_create_id_for_value(*v96, "public.message");
          if (id_for_value != -2)
            CFDictionarySetValue(Mutable, (const void *)(id_for_value & 0x7FFFFFFF), (const void *)1);
          v101 = db_create_id_for_value(*v96, "com.apple.mail.emlx");
          if (v101 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v101 & 0x7FFFFFFF), (const void *)2);
          v102 = db_create_id_for_value(*v96, "com.apple.mail.eml");
          if (v102 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v102 & 0x7FFFFFFF), (const void *)3);
          v103 = db_create_id_for_value(*v96, "com.microsoft.entourage.virtual.message");
          if (v103 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v103 & 0x7FFFFFFF), (const void *)4);
          v104 = db_create_id_for_value(*v96, "com.apple.ichat.transcript");
          if (v104 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v104 & 0x7FFFFFFF), (const void *)5);
          v105 = db_create_id_for_value(*v96, "public.contact");
          if (v105 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v105 & 0x7FFFFFFF), (const void *)6);
          v106 = db_create_id_for_value(*v96, "public.vcard");
          if (v106 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v106 & 0x7FFFFFFF), (const void *)7);
          v107 = db_create_id_for_value(*v96, "com.apple.addressbook.person");
          if (v107 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v107 & 0x7FFFFFFF), (const void *)8);
          v108 = db_create_id_for_value(*v96, "com.apple.addressbook.group");
          if (v108 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v108 & 0x7FFFFFFF), (const void *)9);
          v109 = db_create_id_for_value(*v96, "com.microsoft.entourage.virtual.contact");
          if (v109 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v109 & 0x7FFFFFFF), (const void *)0xA);
          v110 = db_create_id_for_value(*v96, "com.microsoft.entourage.virtual.group");
          if (v110 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v110 & 0x7FFFFFFF), (const void *)0xB);
          v111 = db_create_id_for_value(*v96, "com.apple.systempreference.prefpane");
          if (v111 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v111 & 0x7FFFFFFF), (const void *)0xC);
          v112 = db_create_id_for_value(*v96, "public.font");
          if (v112 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v112 & 0x7FFFFFFF), (const void *)0xD);
          v113 = db_create_id_for_value(*v96, "public.bookmark");
          if (v113 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v113 & 0x7FFFFFFF), (const void *)0xE);
          v114 = db_create_id_for_value(*v96, "com.apple.safari.bookmark");
          if (v114 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v114 & 0x7FFFFFFF), (const void *)0xF);
          v115 = db_create_id_for_value(*v96, "com.apple.safari.history");
          if (v115 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v115 & 0x7FFFFFFF), (const void *)0x10);
          v116 = db_create_id_for_value(*v96, "public.to-do-item");
          if (v116 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v116 & 0x7FFFFFFF), (const void *)0x11);
          v117 = db_create_id_for_value(*v96, "public.calendar-event");
          if (v117 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v117 & 0x7FFFFFFF), (const void *)0x12);
          v118 = db_create_id_for_value(*v96, "com.apple.ical.bookmark");
          if (v118 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v118 & 0x7FFFFFFF), (const void *)0x13);
          v119 = db_create_id_for_value(*v96, "com.apple.ical.bookmark.todo");
          if (v119 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v119 & 0x7FFFFFFF), (const void *)0x14);
          v120 = db_create_id_for_value(*v96, "com.apple.ical.ics.event");
          if (v120 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v120 & 0x7FFFFFFF), (const void *)0x15);
          v121 = db_create_id_for_value(*v96, "com.apple.ical.ics.todo");
          if (v121 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v121 & 0x7FFFFFFF), (const void *)0x16);
          v122 = db_create_id_for_value(*v96, "com.microsoft.entourage.virtual.event");
          if (v122 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v122 & 0x7FFFFFFF), (const void *)0x17);
          v123 = db_create_id_for_value(*v96, "com.microsoft.entourage.virtual.task");
          if (v123 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v123 & 0x7FFFFFFF), (const void *)0x18);
          v124 = db_create_id_for_value(*v96, "public.movie");
          if (v124 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v124 & 0x7FFFFFFF), (const void *)0x19);
          v125 = db_create_id_for_value(*v96, "com.apple.quicktime-movie");
          if (v125 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v125 & 0x7FFFFFFF), (const void *)0x1A);
          v126 = db_create_id_for_value(*v96, "public.mpeg-video");
          if (v126 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v126 & 0x7FFFFFFF), (const void *)0x1B);
          v127 = db_create_id_for_value(*v96, "public.mpeg-4");
          if (v127 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v127 & 0x7FFFFFFF), (const void *)0x1C);
          v128 = db_create_id_for_value(*v96, "public.mpeg");
          if (v128 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v128 & 0x7FFFFFFF), (const void *)0x1D);
          v129 = db_create_id_for_value(*v96, "public.3gpp");
          if (v129 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v129 & 0x7FFFFFFF), (const void *)0x1E);
          v130 = db_create_id_for_value(*v96, "public.3gpp2");
          if (v130 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v130 & 0x7FFFFFFF), (const void *)0x1F);
          v131 = db_create_id_for_value(*v96, "com.apple.application-bundle");
          if (v131 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v131 & 0x7FFFFFFF), (const void *)0x20);
          v132 = db_create_id_for_value(*v96, "com.apple.application-file");
          if (v132 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v132 & 0x7FFFFFFF), (const void *)0x21);
          v133 = db_create_id_for_value(*v96, "com.apple.dashboard-widget");
          if (v133 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v133 & 0x7FFFFFFF), (const void *)0x22);
          v134 = db_create_id_for_value(*v96, "public.folder");
          if (v134 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v134 & 0x7FFFFFFF), (const void *)0x23);
          v135 = db_create_id_for_value(*v96, "com.apple.mount-point");
          if (v135 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v135 & 0x7FFFFFFF), (const void *)0x24);
          v136 = db_create_id_for_value(*v96, "public.audio");
          if (v136 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v136 & 0x7FFFFFFF), (const void *)0x25);
          v137 = db_create_id_for_value(*v96, "public.mpeg-4-audio");
          if (v137 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v137 & 0x7FFFFFFF), (const void *)0x26);
          v138 = db_create_id_for_value(*v96, "com.apple.protected-mpeg-4-audio");
          if (v138 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v138 & 0x7FFFFFFF), (const void *)0x27);
          v139 = db_create_id_for_value(*v96, "com.adobe.pdf");
          if (v139 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v139 & 0x7FFFFFFF), (const void *)0x28);
          v140 = db_create_id_for_value(*v96, "com.apple.localized-pdf-bundle");
          if (v140 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v140 & 0x7FFFFFFF), (const void *)0x29);
          v141 = db_create_id_for_value(*v96, "public.presentation");
          if (v141 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v141 & 0x7FFFFFFF), (const void *)0x2A);
          v142 = db_create_id_for_value(*v96, "com.microsoft.powerpoint.ppt");
          if (v142 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v142 & 0x7FFFFFFF), (const void *)0x2B);
          v143 = db_create_id_for_value(*v96, "com.apple.keynote.key");
          if (v143 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v143 & 0x7FFFFFFF), (const void *)0x2C);
          v144 = db_create_id_for_value(*v96, "com.apple.iwork.keynote.key");
          if (v144 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v144 & 0x7FFFFFFF), (const void *)0x2D);
          v145 = db_create_id_for_value(*v96, "public.image");
          if (v145 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v145 & 0x7FFFFFFF), (const void *)0x2E);
          v146 = db_create_id_for_value(*v96, "com.apple.motion.project");
          if (v146 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v146 & 0x7FFFFFFF), (const void *)0x2F);
          v147 = db_create_id_for_value(*v96, "com.apple.iwork.pages.pages");
          if (v147 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v147 & 0x7FFFFFFF), (const void *)0x30);
          v148 = db_create_id_for_value(*v96, "com.apple.iwork.pages.sffpages");
          if (v148 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v148 & 0x7FFFFFFF), (const void *)0x31);
          v149 = db_create_id_for_value(*v96, "com.apple.iwork.pages.template");
          if (v149 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v149 & 0x7FFFFFFF), (const void *)0x32);
          v150 = db_create_id_for_value(*v96, "com.apple.iwork.pages.sfftemplate");
          if (v150 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v150 & 0x7FFFFFFF), (const void *)0x33);
          v151 = db_create_id_for_value(*v96, "public.rtf");
          if (v151 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v151 & 0x7FFFFFFF), (const void *)0x34);
          v152 = db_create_id_for_value(*v96, "com.apple.rtfd");
          if (v152 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v152 & 0x7FFFFFFF), (const void *)0x35);
          v153 = db_create_id_for_value(*v96, "com.apple.flat-rtfd");
          if (v153 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v153 & 0x7FFFFFFF), (const void *)0x36);
          v154 = db_create_id_for_value(*v96, "com.microsoft.word.doc");
          if (v154 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v154 & 0x7FFFFFFF), (const void *)0x37);
          v155 = db_create_id_for_value(*v96, "org.khronos.collada.digital-asset-exchange");
          if (v155 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v155 & 0x7FFFFFFF), (const void *)0x38);
          v156 = db_create_id_for_value(*v96, "public.plain-text");
          if (v156 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v156 & 0x7FFFFFFF), (const void *)0x39);
          v157 = db_create_id_for_value(*v96, "public.html");
          if (v157 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v157 & 0x7FFFFFFF), (const void *)0x3A);
          v158 = db_create_id_for_value(*v96, "public.xhtml");
          if (v158 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v158 & 0x7FFFFFFF), (const void *)0x3B);
          v159 = db_create_id_for_value(*v96, "public.shell-script");
          if (v159 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v159 & 0x7FFFFFFF), (const void *)0x3C);
          v160 = db_create_id_for_value(*v96, "public.source-code");
          if (v160 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v160 & 0x7FFFFFFF), (const void *)0x3D);
          v161 = db_create_id_for_value(*v96, "public.unix-executable");
          if (v161 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v161 & 0x7FFFFFFF), (const void *)0x3E);
          v162 = db_create_id_for_value(*v96, "com.apple.xcode.project");
          if (v162 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v162 & 0x7FFFFFFF), (const void *)0x3F);
          v163 = db_create_id_for_value(*v96, "com.apple.xcode.model");
          if (v163 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v163 & 0x7FFFFFFF), (const void *)0x40);
          v164 = db_create_id_for_value(*v96, "com.apple.xcode.archive");
          if (v164 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v164 & 0x7FFFFFFF), (const void *)0x41);
          v165 = db_create_id_for_value(*v96, "com.apple.xcode.docset");
          if (v165 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v165 & 0x7FFFFFFF), (const void *)0x42);
          v166 = db_create_id_for_value(*v96, "com.apple.xcode.projectdata");
          if (v166 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v166 & 0x7FFFFFFF), (const void *)0x43);
          v167 = db_create_id_for_value(*v96, "com.apple.xcode.dsym");
          if (v167 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v167 & 0x7FFFFFFF), (const void *)0x44);
          v168 = db_create_id_for_value(*v96, "com.apple.xcode.configsettings");
          if (v168 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v168 & 0x7FFFFFFF), (const void *)0x45);
          v169 = db_create_id_for_value(*v96, "com.apple.xcode.usersettings");
          if (v169 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v169 & 0x7FFFFFFF), (const void *)0x46);
          v170 = db_create_id_for_value(*v96, "com.apple.xcode.strings-text");
          if (v170 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v170 & 0x7FFFFFFF), (const void *)0x47);
          v171 = db_create_id_for_value(*v96, "com.apple.xcode.plugin");
          if (v171 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v171 & 0x7FFFFFFF), (const void *)0x48);
          v172 = db_create_id_for_value(*v96, "com.apple.xcode.mom");
          if (v172 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v172 & 0x7FFFFFFF), (const void *)0x49);
          v173 = db_create_id_for_value(*v96, "com.apple.property-list");
          if (v173 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v173 & 0x7FFFFFFF), (const void *)0x4A);
          v174 = db_create_id_for_value(*v96, "dyn.ah62d4rv4ge81a7dk");
          if (v174 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v174 & 0x7FFFFFFF), (const void *)0x4B);
          v175 = db_create_id_for_value(*v96, "dyn.ah62d4rv4ge80u5pbsa");
          if (v175 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v175 & 0x7FFFFFFF), (const void *)0x4C);
          v176 = db_create_id_for_value(*v96, "com.apple.dashcode.xml");
          if (v176 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v176 & 0x7FFFFFFF), (const void *)0x4D);
          v177 = db_create_id_for_value(*v96, "com.apple.dashcode.css");
          if (v177 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v177 & 0x7FFFFFFF), (const void *)0x4E);
          v178 = db_create_id_for_value(*v96, "com.apple.dashcode.javascript");
          if (v178 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v178 & 0x7FFFFFFF), (const void *)0x4F);
          v179 = db_create_id_for_value(*v96, "com.apple.dashcode.json");
          if (v179 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v179 & 0x7FFFFFFF), (const void *)0x50);
          v180 = db_create_id_for_value(*v96, "com.apple.dashcode.manifest");
          if (v180 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v180 & 0x7FFFFFFF), (const void *)0x51);
          v181 = db_create_id_for_value(*v96, "com.apple.interfacebuilder.document");
          if (v181 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v181 & 0x7FFFFFFF), (const void *)0x52);
          v182 = db_create_id_for_value(*v96, "com.apple.interfacebuilder.document.cocoa");
          if (v182 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v182 & 0x7FFFFFFF), (const void *)0x53);
          v183 = db_create_id_for_value(*v96, "com.apple.rez-source");
          if (v183 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v183 & 0x7FFFFFFF), (const void *)0x54);
          v184 = db_create_id_for_value(*v96, "com.apple.iphone.developerprofile");
          if (v184 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v184 & 0x7FFFFFFF), (const void *)0x55);
          v185 = db_create_id_for_value(*v96, "com.apple.iphone.mobileprovision");
          if (v185 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v185 & 0x7FFFFFFF), (const void *)0x56);
          v186 = db_create_id_for_value(*v96, "com.apple.coreanimation-bundle");
          if (v186 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v186 & 0x7FFFFFFF), (const void *)0x57);
          v187 = db_create_id_for_value(*v96, "com.apple.coreanimation-xml");
          if (v187 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v187 & 0x7FFFFFFF), (const void *)0x58);
          v188 = db_create_id_for_value(*v96, "com.sun.java-class");
          if (v188 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v188 & 0x7FFFFFFF), (const void *)0x59);
          v189 = db_create_id_for_value(*v96, "com.apple.scripting-definition");
          if (v189 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v189 & 0x7FFFFFFF), (const void *)0x5A);
          v190 = db_create_id_for_value(*v96, "com.apple.dt.document.workspace");
          if (v190 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v190 & 0x7FFFFFFF), (const void *)0x5B);
          v191 = db_create_id_for_value(*v96, "com.apple.dt.document.scheme");
          if (v191 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v191 & 0x7FFFFFFF), (const void *)0x5C);
          v192 = db_create_id_for_value(*v96, "com.apple.dt.ide.plug-in");
          if (v192 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v192 & 0x7FFFFFFF), (const void *)0x5D);
          v193 = db_create_id_for_value(*v96, "com.apple.dt.dvt.plug-in");
          if (v193 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v193 & 0x7FFFFFFF), (const void *)0x5E);
          v194 = db_create_id_for_value(*v96, "com.apple.dt.document.snapshot");
          if (v194 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v194 & 0x7FFFFFFF), (const void *)0x5F);
          v195 = db_create_id_for_value(*v96, "com.apple.dt.bundle.unit-test.objective-c");
          if (v195 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v195 & 0x7FFFFFFF), (const void *)0x60);
          v196 = db_create_id_for_value(*v96, "com.apple.instruments.tracetemplate");
          if (v196 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v196 & 0x7FFFFFFF), (const void *)0x61);
          v197 = db_create_id_for_value(*v96, "com.apple.quartzdebug.introspectiontrace");
          if (v197 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v197 & 0x7FFFFFFF), (const void *)0x62);
          v198 = db_create_id_for_value(*v96, "com.apple.applescript.text-object");
          if (v198 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v198 & 0x7FFFFFFF), (const void *)0x63);
          v199 = db_create_id_for_value(*v96, "com.apple.applescript.data-object");
          if (v199 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v199 & 0x7FFFFFFF), (const void *)0x64);
          v200 = db_create_id_for_value(*v96, "com.apple.applescript.url-object");
          if (v200 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v200 & 0x7FFFFFFF), (const void *)0x65);
          v201 = db_create_id_for_value(*v96, "com.apple.applescript.alias-object");
          if (v201 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v201 & 0x7FFFFFFF), (const void *)0x66);
          v202 = db_create_id_for_value(*v96, "com.apple.symbol-export");
          if (v202 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v202 & 0x7FFFFFFF), (const void *)0x67);
          v203 = db_create_id_for_value(*v96, "com.apple.mach-o-binary");
          if (v203 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v203 & 0x7FFFFFFF), (const void *)0x68);
          v204 = db_create_id_for_value(*v96, "com.apple.mach-o-object");
          if (v204 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v204 & 0x7FFFFFFF), (const void *)0x69);
          v205 = db_create_id_for_value(*v96, "com.apple.mach-o-executable");
          if (v205 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v205 & 0x7FFFFFFF), (const void *)0x6A);
          v206 = db_create_id_for_value(*v96, "com.apple.x11-mach-o-executable");
          if (v206 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v206 & 0x7FFFFFFF), (const void *)0x6B);
          v207 = db_create_id_for_value(*v96, "public.object-code");
          if (v207 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v207 & 0x7FFFFFFF), (const void *)0x6C);
          v208 = db_create_id_for_value(*v96, "com.microsoft.windows-executable");
          if (v208 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v208 & 0x7FFFFFFF), (const void *)0x6D);
          v209 = db_create_id_for_value(*v96, "com.microsoft.windows-dynamic-link-library");
          if (v209 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v209 & 0x7FFFFFFF), (const void *)0x6E);
          v210 = db_create_id_for_value(*v96, "com.sun.java-archive");
          if (v210 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v210 & 0x7FFFFFFF), (const void *)0x6F);
          v211 = db_create_id_for_value(*v96, "com.sun.web-application-archive");
          if (v211 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v211 & 0x7FFFFFFF), (const void *)0x70);
          v212 = db_create_id_for_value(*v96, "com.apple.xcode.plugindata");
          if (v212 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v212 & 0x7FFFFFFF), (const void *)0x71);
          v213 = db_create_id_for_value(*v96, "com.apple.dt.playground");
          if (v213 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v213 & 0x7FFFFFFF), (const void *)0x72);
          v214 = db_create_id_for_value(*v96, "com.apple.iwork.numbers.sffnumbers");
          if (v214 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v214 & 0x7FFFFFFF), (const void *)0x73);
          v215 = db_create_id_for_value(*v96, "com.apple.iwork.numbers.numbers");
          if (v215 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v215 & 0x7FFFFFFF), (const void *)0x74);
          v216 = db_create_id_for_value(*v96, "com.apple.iwork.numbers.template");
          if (v216 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v216 & 0x7FFFFFFF), (const void *)0x75);
          v217 = db_create_id_for_value(*v96, "com.microsoft.excel.xls");
          if (v217 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v217 & 0x7FFFFFFF), (const void *)0x76);
          v218 = db_create_id_for_value(*v96, "org.openxmlformats.spreadsheetml.sheet");
          if (v218 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v218 & 0x7FFFFFFF), (const void *)0x77);
          v219 = db_create_id_for_value(*v96, "public.spreadsheet");
          if (v219 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v219 & 0x7FFFFFFF), (const void *)0x78);
          v220 = db_create_id_for_value(*v96, "public.xml");
          if (v220 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v220 & 0x7FFFFFFF), (const void *)0x79);
          v221 = db_create_id_for_value(*v96, "com.apple.log");
          if (v221 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v221 & 0x7FFFFFFF), (const void *)0x7A);
          v222 = db_create_id_for_value(*v96, "com.apple.crashreport");
          if (v222 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v222 & 0x7FFFFFFF), (const void *)0x7B);
          v223 = db_create_id_for_value(*v96, "com.apple.spinreport");
          if (v223 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v223 & 0x7FFFFFFF), (const void *)0x7C);
          v224 = db_create_id_for_value(*v96, "com.apple.panicreport");
          if (v224 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v224 & 0x7FFFFFFF), (const void *)0x7D);
          v225 = db_create_id_for_value(*v96, "com.apple.shutdownstall");
          if (v225 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v225 & 0x7FFFFFFF), (const void *)0x7E);
          v226 = db_create_id_for_value(*v96, "com.apple.hangreport");
          if (v226 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v226 & 0x7FFFFFFF), (const void *)0x7F);
          v227 = db_create_id_for_value(*v96, "public.json");
          if (v227 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v227 & 0x7FFFFFFF), (const void *)0x80);
          v228 = db_create_id_for_value(*v96, "public.log");
          if (v228 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v228 & 0x7FFFFFFF), (const void *)0x81);
          v229 = db_create_id_for_value(*v96, "public.content");
          if (v229 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v229 & 0x7FFFFFFF), (const void *)0x82);
          v230 = db_create_id_for_value(*v96, "com.microsoft.excel.sheet.binary.macroenabled");
          if (v230 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v230 & 0x7FFFFFFF), (const void *)0x83);
          v231 = db_create_id_for_value(*v96, "org.openxmlformats.spreadsheetml.sheet.macroenabled");
          if (v231 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v231 & 0x7FFFFFFF), (const void *)0x84);
          v232 = db_create_id_for_value(*v96, "com.apple.protected-mpeg-4-audio-b");
          if (v232 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v232 & 0x7FFFFFFF), (const void *)0x85);
          v233 = db_create_id_for_value(*v96, "com.audible.aa-audiobook");
          if (v233 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v233 & 0x7FFFFFFF), (const void *)0x86);
          v234 = db_create_id_for_value(*v96, "com.audible.aax-audiobook");
          if (v234 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v234 & 0x7FFFFFFF), (const void *)0x87);
          v235 = db_create_id_for_value(*v96, "com.apple.tips");
          if (v235 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v235 & 0x7FFFFFFF), (const void *)0x88);
          v236 = db_create_id_for_value(*v96, "com.apple.helpviewer");
          if (v236 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v236 & 0x7FFFFFFF), (const void *)0x89);
          v237 = db_create_id_for_value(*v96, "com.apple.help.topic");
          if (v237 != -2)
            CFDictionarySetValue(Mutable, (const void *)(v237 & 0x7FFFFFFF), (const void *)0x8A);
          *(_QWORD *)(v25 + 6608) = CFDictionaryCreateCopy(v98, Mutable);
          CFRelease(Mutable);
        }
        db_create_id_for_field(*v96, "kMDStoreProperties", 0x108u, 14);
        if (!*v96)
        {
          v241 = *__error();
          v242 = _SILogForLogForCategory(7);
          v23 = v282;
          v24 = v281;
          if (os_log_type_enabled(v242, OS_LOG_TYPE_ERROR))
          {
            v249 = fcntl(v279, 50, v297);
            if (v297[0])
              v250 = v249 < 0;
            else
              v250 = 1;
            if (v250)
              v251 = 0;
            else
              v251 = v297;
            *(_DWORD *)buf = 136315906;
            *(_QWORD *)&buf[4] = "SICreateNewIndex";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 12987;
            *(_WORD *)&buf[18] = 2080;
            *(_QWORD *)&buf[20] = v251;
            *(_WORD *)&buf[28] = 2080;
            *(_QWORD *)&buf[30] = "store.db";
            _os_log_error_impl(&dword_1B8270000, v242, OS_LOG_TYPE_ERROR, "%s:%d: Could not create store at path '%s/%s'", buf, 0x26u);
          }
          *__error() = v241;
          v22 = 12988;
          v21 = 1;
          goto LABEL_71;
        }
        *(_DWORD *)buf = 2;
        v238 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, buf);
        SISetProperty(v25, CFSTR("YukonRecomputedSizes"), v238);
        CFRelease(v238);
        v21 = 1;
        _si_next_index_id((os_unfair_lock_s *)v25, *(unsigned int *)(v25 + 1456), 1, 1);
        v23 = v282;
        v24 = v281;
        v41 = v284;
        goto LABEL_33;
      }
      v239 = *__error();
      v245 = _SILogForLogForCategory(7);
      if (os_log_type_enabled(v245, OS_LOG_TYPE_ERROR))
      {
        v256 = fcntl(v279, 50, v297);
        if (v297[0])
          v257 = v256 < 0;
        else
          v257 = 1;
        if (v257)
          v258 = 0;
        else
          v258 = v297;
        *(_DWORD *)valuePtr = 136315650;
        v289 = "SICreateNewIndex";
        v290 = 1024;
        v291 = 12915;
        v292 = 2080;
        v293 = v258;
        _os_log_error_impl(&dword_1B8270000, v245, OS_LOG_TYPE_ERROR, "%s:%d: Could not create reverse dir store at path '%s'", valuePtr, 0x1Cu);
      }
      v22 = 12916;
    }
    else
    {
      v239 = *__error();
      v240 = _SILogForLogForCategory(7);
      if (os_log_type_enabled(v240, OS_LOG_TYPE_ERROR))
      {
        v246 = fcntl(v279, 50, v297);
        if (v297[0])
          v247 = v246 < 0;
        else
          v247 = 1;
        if (v247)
          v248 = 0;
        else
          v248 = v297;
        *(_DWORD *)valuePtr = 136315906;
        v289 = "SICreateNewIndex";
        v290 = 1024;
        v291 = 12903;
        v292 = 2080;
        v293 = v248;
        v294 = 2080;
        v295 = "store.db";
        _os_log_error_impl(&dword_1B8270000, v240, OS_LOG_TYPE_ERROR, "%s:%d: Could not create store at path '%s/%s'", valuePtr, 0x26u);
      }
      v22 = 12904;
    }
    v23 = v282;
    v24 = v281;
    v21 = 0;
    *__error() = v239;
    goto LABEL_71;
  }
  v275 = v284 & 8;
  v21 = 0;
  v23 = v282;
  v24 = v281;
LABEL_33:
  *v24 = v25;
  *(_DWORD *)(v25 + 6584) |= 0x380000u;
  v46 = SIInitIndex(v25, v280, v277, v41, v278, 0, 0, 1, 0);
  if ((v46 & 0x80000000) != 0)
  {
    v22 = 0;
LABEL_71:
    _SICloseIndex(v25, 0);
    v73 = *(int **)(v25 + 1184);
    if (v73)
    {
      db_release_datastore_no_sync(v73);
      *(_QWORD *)(v25 + 1184) = 0;
    }
    v74 = *(_QWORD *)(v25 + 6624);
    if (v74)
    {
      freeReverseDirStore(v74);
      *(_QWORD *)(v25 + 6624) = 0;
    }
    goto LABEL_7;
  }
  v15 = v46;
  if (!(v46 | v275))
  {
    v47 = (const void *)*MEMORY[0x1E0C9AE50];
    if (v276)
      si_set_property(v25, CFSTR("kSITokenizerUnigrams"), (const void *)*MEMORY[0x1E0C9AE50], 1, 0);
    si_set_property(v25, CFSTR("kSITokenizerUseCRF"), v47, 1, 0);
    *(_DWORD *)buf = (*(_DWORD *)(v25 + 6584) >> 19) & 3;
    v48 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v49 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, buf);
    si_set_property(v25, CFSTR("kSITokenizerVersion"), v49, 1, 0);
    CFRelease(v49);
    v50 = CFStringCreateWithCString(v48, (const char *)sysVersionCStr, 0x8000100u);
    si_set_property(v25, CFSTR("kSIRepairSizes"), v50, 1, 0);
    CFRelease(v50);
    *(_DWORD *)valuePtr = (*(_DWORD *)(v25 + 6584) >> 21) & 1;
    v51 = CFNumberCreate(v48, kCFNumberIntType, valuePtr);
    si_set_property(v25, CFSTR("kSIIdentifierHashVersion"), v51, 1, 0);
    CFRelease(v51);
    si_set_property(v25, CFSTR("kSIRepairedIndex"), v47, 1, 0);
    _si_set_version_property(v25, CFSTR("VEC_EXT_CLEARED_JOURNALS"), 0);
    _si_set_version_property(v25, CFSTR("VEC_EXT_CLEARED_VECTORS"), 1);
    os_unfair_lock_lock((os_unfair_lock_t)(v25 + 6576));
    si_set_obj_state_locked(v25, v25, 1);
    os_unfair_lock_unlock((os_unfair_lock_t)(v25 + 6576));
  }
  MEMORY[0x1BCCB1484](v23);
  close(v23);
  if (!v275)
    SIActivityJournalOpen(v25 + 2192, 37, *(_DWORD *)(v25 + 2344), *(_DWORD *)(*(_QWORD *)(v25 + 1392) + 8), *(_DWORD *)(*(_QWORD *)(v25 + 1384) + 8), 0, 0, *(_QWORD *)(v25 + 2408));
  si_cacheIndexVersion(v25);
  return v15;
}

void _SITuningInit()
{
  pthread_once(&_SITuningInit_once_control, (void (*)(void))_onceInitTuning);
  if (_SITuningInit_indexOnce != -1)
    dispatch_once(&_SITuningInit_indexOnce, &__block_literal_global_849);
}

double SIInitIndexLocks(uint64_t a1)
{
  double result;

  pthread_mutex_init((pthread_mutex_t *)(a1 + 1880), 0);
  pthread_cond_init((pthread_cond_t *)(a1 + 1944), 0);
  pthread_mutex_init((pthread_mutex_t *)(a1 + 1504), 0);
  pthread_mutex_init((pthread_mutex_t *)(a1 + 1568), 0);
  pthread_mutex_init((pthread_mutex_t *)(a1 + 1632), 0);
  pthread_mutex_init((pthread_mutex_t *)(a1 + 6976), 0);
  pthread_mutex_init((pthread_mutex_t *)(a1 + 2256), 0);
  pthread_rwlock_init((pthread_rwlock_t *)(a1 + 80), 0);
  *(_DWORD *)(a1 + 1696) = 0;
  result = 0.0;
  *(_QWORD *)(a1 + 6576) = 0;
  atomic_store(0, (unsigned int *)(a1 + 1452));
  return result;
}

uint64_t guarded_dup(int a1)
{
  int v1;
  int v2;
  int v3;
  NSObject *v4;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  int v14;
  __int16 v15;
  int v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v8 = 0;
  v7 = dup(a1);
  arc4random_buf(&v8, 8uLL);
  v1 = change_fdguard_np();
  if (v1)
  {
    v2 = v1;
    v3 = *__error();
    v4 = _SILogForLogForCategory(11);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v6 = *__error();
      *(_DWORD *)buf = 136315906;
      v10 = "guarded_dup";
      v11 = 1024;
      v12 = 12595;
      v13 = 1024;
      v14 = v2;
      v15 = 1024;
      v16 = v6;
      _os_log_error_impl(&dword_1B8270000, v4, OS_LOG_TYPE_ERROR, "%s:%d: Failed to protect fd with %d %d", buf, 0x1Eu);
    }
    *__error() = v3;
  }
  return v7;
}

int *si_set_vector_store(uint64_t a1)
{
  int *result;
  uint64_t vector_store;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  _QWORD v8[2];
  uint64_t (*v9)(uint64_t, _QWORD *);
  void *v10;
  uint64_t v11;

  result = *(int **)(a1 + 1184);
  if (result)
  {
    vector_store = db_get_vector_store(result);
    v4 = *(_QWORD *)(a1 + 1392);
    v5 = *(_QWORD *)(a1 + 1384);
    v8[0] = MEMORY[0x1E0C809B0];
    v8[1] = 0x40000000;
    v9 = __si_set_vector_store_block_invoke;
    v10 = &__block_descriptor_tmp_845;
    v11 = vector_store;
    if (v4 && *(_DWORD *)(v4 + 8))
    {
      v6 = 0;
      while (((unsigned int (*)(_QWORD *, _QWORD, _QWORD))v9)(v8, *(_QWORD *)(*(_QWORD *)v4 + 8 * v6), 0))
      {
        if (++v6 >= (unint64_t)*(unsigned int *)(v4 + 8))
          goto LABEL_7;
      }
    }
    else
    {
LABEL_7:
      if (v5 && *(_DWORD *)(v5 + 8))
      {
        v7 = 0;
        do
        {
          if (!((unsigned int (*)(_QWORD *, _QWORD, uint64_t))v9)(v8, *(_QWORD *)(*(_QWORD *)v5 + 8 * v7), 1))break;
          ++v7;
        }
        while (v7 < *(unsigned int *)(v5 + 8));
      }
    }
    return (int *)db_set_host(*(int **)(a1 + 1184), a1);
  }
  return result;
}

uint64_t SISetProperty(uint64_t result, const void *a2, const void *a3)
{
  uint64_t v3;

  if (result)
  {
    v3 = result;
    if (*(_QWORD *)(result + 1184))
    {
      if (CFEqual(CFSTR("database.shutdowntime"), a2))
      {
        si_scheduler_boost_and_forget(*(_QWORD *)(v3 + 864));
        si_scheduler_boost_and_forget(*(_QWORD *)(v3 + 944));
      }
      return si_set_property(v3, a2, a3, 0, 0);
    }
  }
  return result;
}

uint64_t SIInitIndex(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  uint64_t v9;
  int v10;
  int v11;
  const __CFArray *v12;
  const __CFArray *v13;
  const void *v14;
  const void *v15;
  unsigned int v16;
  unsigned int v17;
  int *v18;
  int *v19;
  _DWORD *v20;
  _DWORD *v21;
  uint64_t v22;
  NSObject *v23;
  int v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  NSObject *v29;
  NSObject *v30;
  NSObject *v31;
  _QWORD *v32;
  pthread_mutex_t *v33;
  unsigned int v34;
  int v35;
  unint64_t v36;
  unsigned int v37;
  unsigned int v38;
  uint64_t v39;
  uint64_t v40;
  void (*v41)(_QWORD);
  _DWORD *v42;
  int v43;
  NSObject *v44;
  const __CFAllocator *v45;
  const __CFAllocator *v46;
  CFNumberRef v47;
  CFNumberRef v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  int *v53;
  int v54;
  int32_t v55;
  DIR *v56;
  DIR *v57;
  uint64_t v58;
  char *d_name;
  int v60;
  NSObject *v61;
  os_log_type_t v62;
  _OWORD *v63;
  __int128 v64;
  int v65;
  NSObject *v66;
  os_log_type_t v67;
  int v68;
  int v69;
  off_t file_size;
  unint64_t v71;
  unint64_t v72;
  __int128 v73;
  uint64_t v74;
  uint64_t v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  char *v79;
  uint64_t v80;
  char *v81;
  char *v82;
  uint64_t v83;
  uint64_t v84;
  unint64_t v85;
  char *v86;
  __int128 v87;
  int64x2_t v88;
  unint64_t v89;
  unint64_t v90;
  unint64_t v91;
  char *v92;
  uint64_t v93;
  uint64_t v94;
  char *v95;
  std::string *v96;
  int v97;
  char *v98;
  char *v99;
  __int128 v100;
  uint64_t v101;
  uint64_t v102;
  char *v103;
  __int128 v104;
  int64x2_t v105;
  char *v106;
  std::string *v107;
  std::string *v108;
  unint64_t v109;
  uint64_t v110;
  uint64_t *v111;
  const void **v112;
  unint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  const char *v118;
  uint64_t v119;
  int v120;
  int v121;
  NSObject *v122;
  NSObject *v123;
  int v124;
  int v125;
  NSObject *v126;
  int v127;
  _BOOL4 v128;
  std::string *v129;
  int v130;
  int v131;
  NSObject *v132;
  int v133;
  const char *v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  _QWORD *v141;
  std::string *v142;
  std::string *v143;
  std::string *v144;
  NSObject *v145;
  const char *v146;
  std::string *v147;
  std::string *v148;
  std::string *v149;
  std::string *v150;
  std::string *v151;
  std::string *v152;
  int v153;
  NSObject *v154;
  os_log_type_t v155;
  int32_t v156;
  int *v157;
  char *v158;
  NSObject *v159;
  os_log_type_t v160;
  int *v161;
  char *v162;
  int v163;
  const char *v164;
  int v165;
  uint64_t v166;
  int v167;
  int v168;
  int v169;
  NSObject *v170;
  os_log_type_t v171;
  std::string *v172;
  std::string *v173;
  std::string *v174;
  int v175;
  NSObject *v176;
  os_log_type_t v177;
  int v178;
  std::string *v179;
  std::string *v180;
  int *v181;
  std::string *v182;
  CachingHotShard *v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  BOOL v188;
  uint64_t v189;
  BOOL v190;
  int v191;
  NSObject *v192;
  os_log_type_t v193;
  std::string *v194;
  uint64_t v195;
  int v196;
  NSObject *v197;
  NSObject *v198;
  int v199;
  int v200;
  uint64_t v201;
  DocStore *v202;
  DocStore *v203;
  int v204;
  uint64_t v205;
  int v206;
  NSObject *v207;
  NSObject *v208;
  os_log_type_t v209;
  int v210;
  char *v211;
  char *v212;
  const __CFNumber *v213;
  const __CFNumber *v214;
  CFTypeID v215;
  const __CFNumber *v216;
  const __CFNumber *v217;
  CFTypeID v218;
  const __CFNumber *v219;
  const __CFNumber *v220;
  CFTypeID v221;
  const __CFNumber *v222;
  const __CFNumber *v223;
  CFTypeID v224;
  unsigned int v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  unint64_t v229;
  unsigned int v230;
  CFNumberRef v231;
  const void *v232;
  const __CFNumber *v233;
  _DWORD *v234;
  const __CFNumber *v235;
  const __CFNumber *v236;
  _DWORD *v237;
  const __CFNumber *v238;
  const __CFBoolean *v239;
  const __CFBoolean *v240;
  const __CFBoolean *v241;
  const __CFBoolean *v242;
  const __CFNumber *v243;
  const __CFNumber *v244;
  CFTypeID v245;
  const __CFArray *v246;
  const __CFArray *v247;
  const __CFString *ValueAtIndex;
  int v249;
  NSObject *v250;
  _DWORD *v251;
  unsigned int v252;
  unsigned int v253;
  unsigned int v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t i;
  __CFSet *Mutable;
  unsigned int v259;
  uint64_t v260;
  unsigned int v261;
  uint64_t v262;
  void (*v263)(_QWORD);
  unsigned int v265;
  int v266;
  NSObject *v267;
  const char *v268;
  uint64_t v269;
  uint64_t j;
  uint64_t v271;
  uint64_t v272;
  uint64_t v273;
  void **v274;
  void *root_scheduler;
  uint64_t v276;
  __int16 v277;
  unsigned int v278;
  unint64_t v279;
  const char **v280;
  uint64_t v281;
  uint64_t v282;
  int v283;
  uint64_t v284;
  __darwin_time_t v285;
  dispatch_object_t *scheduler;
  uint64_t v287;
  unsigned int *v288;
  unsigned int v289;
  NSObject *v290;
  void *v291;
  uint64_t v292;
  uint64_t v293;
  unsigned int *v294;
  unsigned int v295;
  unsigned int v296;
  uint64_t v297;
  int v298;
  int v299;
  NSObject *v300;
  os_log_type_t v301;
  uint64_t v302;
  _QWORD *v303;
  _QWORD *v304;
  const __CFAllocator *v305;
  uint64_t k;
  uint64_t v307;
  uint64_t v308;
  int v309;
  uint64_t v310;
  const __CFDictionary *v311;
  const __CFDictionary *v312;
  const __CFNumber *Value;
  const __CFArray *v314;
  CFIndex Count;
  CFIndex m;
  const __CFDictionary *v317;
  int v318;
  const __CFNumber *v319;
  const __CFNumber *v320;
  BOOL v321;
  _QWORD *v322;
  _QWORD *v323;
  unint64_t DocId;
  uint64_t v325;
  _QWORD *v326;
  __CFArray *v327;
  uint64_t v328;
  _DWORD *v329;
  uint64_t v330;
  uint64_t v331;
  _DWORD *v332;
  pthread_mutex_t *v333;
  unsigned int v334;
  unint64_t v335;
  signed int v336;
  unsigned int v337;
  uint64_t v338;
  int8x16_t *v339;
  int8x16_t *v340;
  uint64_t Instance;
  stat *v342;
  stat *v343;
  stat *v344;
  uint64_t st_dev;
  mode_t *p_st_mode;
  mode_t *v347;
  int8x16_t *v348;
  _DWORD *v349;
  int v350;
  pthread_mutex_t *v351;
  uint64_t v352;
  pthread_override_s *v353;
  char v354;
  off_t v355;
  uint64_t v356;
  uint64_t v357;
  std::__split_buffer<std::string>::pointer first;
  int8x16_t *v360;
  int v361;
  NSObject *v362;
  os_log_type_t v363;
  uint64_t v364;
  int data;
  int v366;
  int v367;
  int v368;
  uint64_t v369;
  uint64_t v370;
  uint64_t v371;
  uint64_t v372;
  uint64_t v374;
  int *v375;
  int v376;
  int *v377;
  uint64_t v378;
  int v379;
  int v380;
  unsigned int *v381;
  uint64_t v382;
  char *v383;
  uint64_t v385;
  unsigned int *v386;
  uint64_t v387;
  int v388;
  char *v389;
  uint64_t v390;
  int v391;
  unsigned int v392;
  uint64_t v393;
  unsigned int *v394;
  int v395;
  unsigned int *v396;
  unsigned int *v397;
  unsigned int *v398;
  unsigned int *v399;
  char v400;
  uint64_t v401;
  unsigned int *v402;
  unsigned int *v403;
  uint64_t v404;
  uint64_t v405;
  uint64_t v406;
  int v407;
  uint64_t v408;
  char v409;
  uint64_t v410;
  int v411;
  uint64_t v412;
  uint64_t v413;
  uint64_t v414;
  int v415;
  unsigned int *v416;
  uint64_t v417;
  uint64_t v418;
  unsigned int *v419;
  char *v420;
  int *v421;
  unint64_t v422;
  unsigned int v423;
  char *v424;
  char *v425;
  const void *v426;
  size_t v427;
  unsigned int v428;
  int *v429;
  unint64_t v430;
  int v431;
  int v432;
  int v433;
  std::string *v434;
  uint64_t v435;
  char *v436;
  char *v437;
  signed int v438;
  char *v439;
  unsigned int *v440;
  unsigned int *v441;
  unsigned int *v442;
  int v443;
  uint64_t v444;
  int8x16_t *v445;
  int v446;
  uint64_t v447;
  int v448;
  uint64_t v449;
  uint64_t v450;
  uint64_t v451;
  int v452;
  int v453;
  uint64_t v454;
  unsigned int v455;
  uint64_t v456;
  int v457;
  uint64_t v458;
  _BOOL4 v459;
  _BOOL4 v460;
  char *v461;
  char *v462;
  const char *v463;
  int v464;
  char *v465;
  const char *v466;
  char *v467;
  char *v468;
  const char *v469;
  uint64_t v470;
  char *v471;
  const char *v472;
  uint64_t v473;
  uint64_t v474;
  uint64_t *v475;
  uint64_t v476;
  uint64_t v477;
  int v478;
  int v479;
  NSObject *v480;
  _BOOL4 v481;
  void *v482;
  pthread_override_s *v483;
  char v484;
  int v485;
  NSObject *v486;
  os_log_type_t v487;
  uint64_t v488;
  uint64_t v489;
  uint64_t v490;
  uint64_t v491;
  uint64_t v492;
  uint64_t v493;
  gid_t v494;
  gid_t v495;
  int v496;
  gid_t v497;
  int v498;
  gid_t v499;
  int v500;
  int v501;
  gid_t v502;
  int v503;
  unsigned int v504;
  int v505;
  int v506;
  gid_t v507;
  int v508;
  gid_t v509;
  gid_t v510;
  gid_t v511;
  int v512;
  gid_t v513;
  char *v514;
  char *v515;
  int v516;
  dev_t v517;
  int v518;
  NSObject *v519;
  int v520;
  int v521;
  NSObject *v522;
  signed int v523;
  signed int v524;
  int v525;
  int v526;
  _BOOL4 v527;
  int v528;
  NSObject *v529;
  _BOOL4 v530;
  int v531;
  uint64_t v532;
  signed int v533;
  int v534;
  uint64_t v535;
  char *v536;
  int v537;
  NSObject *v538;
  uint64_t v539;
  uint64_t v540;
  char *v541;
  int v542;
  NSObject *v543;
  CFIndex v544;
  CFIndex v545;
  CFIndex n;
  const void *v547;
  int v548;
  int v549;
  NSObject *v550;
  int v551;
  NSObject *v552;
  dev_t v553;
  signed int v554;
  int v555;
  _BOOL4 v556;
  _BOOL4 v557;
  __darwin_time_t v558;
  signed int v559;
  dev_t v560;
  int v561;
  NSObject *v562;
  _BOOL4 v563;
  dev_t v564;
  signed int v565;
  char *v566;
  int v567;
  NSObject *v568;
  _BOOL4 v569;
  uint64_t v570;
  uint64_t v571;
  __darwin_time_t v572;
  CFIndex v573;
  CFIndex v574;
  CFIndex ii;
  const void *v576;
  int v577;
  int v578;
  NSObject *v579;
  int v580;
  NSObject *v581;
  __darwin_time_t v582;
  __darwin_time_t v583;
  __darwin_time_t v584;
  int v585;
  NSObject *v586;
  int v587;
  uint64_t v588;
  const __CFDictionary *clientstates_file;
  const __CFDictionary *v590;
  const __CFString *v591;
  const __CFString *v592;
  CFTypeRef v593;
  CFTypeRef v594;
  const void *v595;
  CFNumberRef v596;
  CFNumberRef v597;
  CFNumberRef v598;
  CFNumberRef v599;
  CFNumberRef v600;
  CFNumberRef v601;
  const __CFUUID *v602;
  CFStringRef v603;
  CFStringRef v604;
  const __CFNumber *v605;
  const __CFNumber *v606;
  signed int f_bsize;
  uint64_t v608;
  unsigned int v609;
  uint64_t v610;
  void (*v611)(_QWORD);
  char *v612;
  const char *v613;
  char *v614;
  const char *v615;
  char *v616;
  const char *v617;
  unsigned int v618;
  char *v619;
  const char *v620;
  char *v621;
  const char *v622;
  char *v623;
  const char *v624;
  int v625;
  NSObject *v626;
  uint64_t v627;
  int v628;
  NSObject *v629;
  uint64_t v630;
  char *v631;
  const char *v632;
  unsigned int v633;
  char *v634;
  const char *v635;
  char *v636;
  const char *v637;
  char *v638;
  const char *v639;
  char *v640;
  const char *v641;
  char *v642;
  const char *v643;
  char *v644;
  char *v645;
  const char *v646;
  const char *v647;
  const char *v648;
  uint64_t v649;
  unsigned int v650;
  int v651;
  __CFArray *theArray;
  int v653;
  dev_t v654;
  const __CFDictionary *v655;
  dev_t v656;
  unsigned int v657;
  char *v658;
  uint64_t v659;
  int *ptr;
  uint64_t v661;
  int v662;
  unsigned int *__dst;
  unsigned int v664;
  unsigned int v665;
  uint64_t v666;
  int v667;
  int v668;
  gid_t v669;
  uint64_t v670;
  uint64_t v671;
  __darwin_time_t v672;
  __darwin_time_t v673;
  _QWORD *v674;
  _QWORD *v675;
  _DWORD *v676;
  int8x16_t *v677;
  const char *v678;
  uint64_t v679;
  pthread_mutex_t *v680;
  gid_t v681;
  CFTypeRef cf;
  pthread_mutex_t *v683;
  _DWORD *v684;
  int *v685;
  int v686;
  char v687;
  int v688;
  const __CFArray *v689;
  const __CFAllocator *allocator;
  unsigned int v691;
  const __CFArray *v692;
  int v693;
  int v694;
  unsigned int v695;
  uint64_t v696;
  _QWORD v697[5];
  uint64_t v698;
  _QWORD aBlock[5];
  _QWORD block[5];
  _QWORD v701[2];
  uint64_t (*v702)(uint64_t, uint64_t);
  void *v703;
  statfs *p_handler;
  int valuePtr;
  unint64_t v706;
  unsigned int v707;
  unsigned int v708;
  unsigned int v709;
  unint64_t v710;
  unsigned int v711;
  _OWORD v712[2];
  _QWORD v713[2];
  off_t v714;
  void *__p[2];
  uint64_t v716;
  __int16 v717;
  int64x2_t v718;
  std::string *v719;
  dirent *v720;
  _OWORD v721[6];
  char __s1[1024];
  statfs handler;
  stat v724;
  __int128 v725;
  __int128 v726;
  __int128 v727;
  __int128 v728;
  __int128 v729;
  __int128 v730;
  __int128 v731;
  __int128 v732;
  __int128 v733;
  __int128 v734;
  __int128 v735;
  __int128 v736;
  __int128 v737;
  __int128 v738;
  __int128 v739;
  __int128 v740;
  __int128 v741;
  __int128 v742;
  __int128 v743;
  __int128 v744;
  __int128 v745;
  __int128 v746;
  __int128 v747;
  std::__split_buffer<std::string> buf;
  uint64_t v749;

  v9 = MEMORY[0x1E0C80A78](a1);
  v11 = v10;
  v692 = v12;
  v689 = v13;
  v15 = v14;
  v17 = v16;
  v19 = v18;
  v21 = v20;
  v22 = v9;
  v749 = *MEMORY[0x1E0C80C00];
  if (registerForGameModeChange_onceToken != -1)
    dispatch_once(&registerForGameModeChange_onceToken, &__block_literal_global_873);
  cf = v15;
  if (freeQueueOnce[0] != -1)
    dispatch_once(freeQueueOnce, &__block_literal_global_851);
  v686 = v11;
  v687 = v11;
  si_set_vector_store(v22);
  v23 = dispatch_queue_attr_make_with_qos_class(MEMORY[0x1E0C80D50], QOS_CLASS_BACKGROUND, 0);
  *(_QWORD *)(v22 + 1176) = dispatch_queue_create("com.apple.spotlight.index.journal.toc", v23);
  bzero(__s1, 0x400uLL);
  v24 = *(_DWORD *)(v22 + 32);
  bzero(&handler, 0x878uLL);
  v25 = fstatfs(v24, &handler);
  v26 = handler.f_blocks * handler.f_bsize;
  if (v25)
    v26 = -1;
  *(_QWORD *)(v22 + 2472) = v26;
  *(_DWORD *)(v22 + 6876) = 0x7FFFFFFF;
  v27 = 832;
  do
  {
    v28 = v27;
    *(_QWORD *)(v22 + v27) = dispatch_semaphore_create(16);
    v27 = v28 + 8;
  }
  while (v28 != 856);
  v685 = v19;
  atomic_store(0, (unsigned int *)(v22 + 6888));
  *(_BYTE *)(v22 + 1480) = 0;
  *(_QWORD *)(v22 + 1472) = 0;
  if (!*(_BYTE *)(v22 + 2072))
  {
    *(_QWORD *)(v22 + 64) = 0;
    if ((v17 & 0x100) == 0)
      goto LABEL_12;
    goto LABEL_11;
  }
  v29 = dispatch_workloop_create("Watchdog workloop");
  v30 = dispatch_queue_create_with_target_V2("Watchdog timer queue", 0, v29);
  v31 = dispatch_source_create(MEMORY[0x1E0C80DD0], 1uLL, 0, v30);
  dispatch_release(v29);
  v32 = malloc_type_calloc(1uLL, 0x70uLL, 0x1060040BF51B5CEuLL);
  *v32 = v31;
  v32[1] = v30;
  *((_BYTE *)v32 + 16) = 0;
  v32[9] = 0;
  v32[11] = 0;
  v32[13] = 0;
  *((_DWORD *)v32 + 20) = 0;
  *((_OWORD *)v32 + 2) = 0u;
  *((_OWORD *)v32 + 3) = 0u;
  *((_DWORD *)v32 + 16) = 0;
  *(_QWORD *)(v22 + 64) = v32;
  *(_QWORD *)&handler.f_bsize = MEMORY[0x1E0C809B0];
  handler.f_blocks = 0x40000000;
  handler.f_bfree = (uint64_t)__si_indexingWatchdogInit_block_invoke;
  handler.f_bavail = (uint64_t)&__block_descriptor_tmp_7_2650;
  handler.f_files = (uint64_t)v32;
  handler.f_ffree = v22;
  dispatch_source_set_event_handler(v31, &handler);
  if ((v17 & 0x100) != 0)
  {
LABEL_11:
    *(_OWORD *)(v22 + 2128) = xmmword_1B8631BC0;
    *(_BYTE *)(v22 + 672) = 0;
    *(_DWORD *)(v22 + 328) = 0;
    *(_QWORD *)(v22 + 656) = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  }
LABEL_12:
  v33 = (pthread_mutex_t *)(v22 + 6976);
  bzero((void *)(v22 + 7040), 0xC00uLL);
  do
  {
    v34 = __ldxr(exceptionSequenceNum);
    v35 = v34 + 1;
  }
  while (__stxr(v34 + 1, exceptionSequenceNum));
  v711 = 0;
  v710 = 0;
  v709 = 0;
  v36 = setThreadIdAndInfo(*(_DWORD *)(v22 + 32), sFdExceptionCallbacks, 0, 1, v35);
  v711 = v36;
  v710 = __PAIR64__(HIDWORD(v36), v37);
  v709 = v38;
  v39 = *(_QWORD *)&threadData[18 * v36 + 2];
  v40 = v39 + 320 * HIDWORD(v36);
  *(_BYTE *)(v40 + 216) = 0;
  v693 = *(_DWORD *)(v40 + 312);
  v41 = *(void (**)(_QWORD))(v40 + 224);
  if (v41)
    v41(*(_QWORD *)(v39 + 320 * HIDWORD(v36) + 288));
  v708 = v711;
  v707 = HIDWORD(v710);
  v706 = __PAIR64__(v710, v709);
  if (_setjmp((int *)v40))
  {
    v42 = (_DWORD *)(v40 + 312);
    v43 = *__error();
    v44 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
    {
      handler.f_bsize = 136315394;
      *(_QWORD *)&handler.f_iosize = "SIInitIndex";
      WORD2(handler.f_blocks) = 1024;
      *(_DWORD *)((char *)&handler.f_blocks + 6) = 14438;
      _os_log_error_impl(&dword_1B8270000, v44, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", (uint8_t *)&handler, 0x12u);
    }
    *__error() = v43;
    *v42 = v693;
    CIOnThreadCleanUpReset(v706);
    dropThreadId(v708, 1, v35);
    CICleanUpReset(v708, HIDWORD(v706));
LABEL_306:
    _SICloseIndex(v22, 0);
    pthread_mutex_destroy((pthread_mutex_t *)(v22 + 1880));
    pthread_cond_destroy((pthread_cond_t *)(v22 + 1944));
    pthread_mutex_destroy((pthread_mutex_t *)(v22 + 1504));
    pthread_mutex_destroy((pthread_mutex_t *)(v22 + 1568));
    pthread_mutex_destroy((pthread_mutex_t *)(v22 + 1632));
    pthread_mutex_destroy(v33);
    pthread_mutex_destroy((pthread_mutex_t *)(v22 + 2256));
    pthread_rwlock_destroy((pthread_rwlock_t *)(v22 + 80));
    return 0xFFFFFFFFLL;
  }
  v45 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v46 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  *(_QWORD *)(v22 + 72) = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  valuePtr = 1;
  v47 = CFNumberCreate(v45, kCFNumberIntType, &valuePtr);
  if (v47)
  {
    v48 = v47;
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(v22 + 72), CFSTR("version"), v47);
    CFRelease(v48);
  }
  *(_QWORD *)(v22 + 1704) = CFBagCreateMutable(v46, 64, MEMORY[0x1E0C9B388]);
  if (*(_DWORD *)(v22 + 32) && *(_QWORD *)(v22 + 1184))
    _si_init_localized_terms(v22);
  if ((v17 & 0x80000109) == 0 && !a9 && !*(_QWORD *)(v22 + 6624))
  {
    v631 = __si_assert_copy_extra_521(-1);
    v468 = v631;
    v632 = "";
    if (v631)
      v632 = v631;
    __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 13859, "fs_only || newIndex->dirStore || rebuildDirStore", v632);
    goto LABEL_563;
  }
  *(_DWORD *)(v22 + 828) = v17;
  if (*(_BYTE *)(v22 + 2072))
    *(_DWORD *)(v22 + 6584) |= 0xC000u;
  v691 = v17 & 0x80000109;
  v696 = v22;
  v695 = v17;
  allocator = v46;
  v684 = v21;
  v683 = (pthread_mutex_t *)(v22 + 6976);
  v694 = v35;
  if ((v17 & 0x100) == 0)
  {
    _os_feature_enabled_impl();
    goto LABEL_202;
  }
  v49 = *(_DWORD *)(v22 + 32);
  v747 = 0u;
  v746 = 0u;
  v745 = 0u;
  v744 = 0u;
  v743 = 0u;
  v742 = 0u;
  v741 = 0u;
  v740 = 0u;
  v739 = 0u;
  v738 = 0u;
  v737 = 0u;
  v736 = 0u;
  v735 = 0u;
  v734 = 0u;
  v733 = 0u;
  v732 = 0u;
  v731 = 0u;
  v730 = 0u;
  v729 = 0u;
  v728 = 0u;
  v727 = 0u;
  v726 = 0u;
  v725 = 0u;
  memset(&v724, 0, sizeof(v724));
  snprintf((char *)&v724, 0x200uLL, "doc_store_load(%d, %s, %lld)", v49, "docstore", 1);
  v713[1] = 0;
  v713[0] = 0;
  ScopeLogger::ScopeLogger((ScopeLogger *)v713, (const char *)&v724);
  memset(v712, 0, sizeof(v712));
  analytics::ScopedLogger<analytics::OpenEvent>::ScopedLogger((std::chrono::steady_clock::time_point *)v712);
  v50 = *(_QWORD *)&v712[0];
  **(_DWORD **)&v712[0] = 1;
  *(_BYTE *)(v50 + 4) = 1;
  v51 = operator new();
  DocStore::DocStore((DocStore *)v51, v49);
  v52 = *(_QWORD *)&v712[0];
  DocStore::init_file_backed_bloom_map(v53);
  v54 = openat(*(_DWORD *)v51, ".", 0x20000000);
  if (v54 < 0)
  {
    v153 = *__error();
    v154 = _SILogForLogForCategory(8);
    v155 = dword_1EF19FCAC < 3;
    if (os_log_type_enabled(v154, (os_log_type_t)(dword_1EF19FCAC < 3)))
    {
      v156 = *(_DWORD *)v51;
      v157 = __error();
      v158 = strerror(*v157);
      handler.f_bsize = 67109378;
      handler.f_iosize = v156;
      LOWORD(handler.f_blocks) = 2080;
      *(uint64_t *)((char *)&handler.f_blocks + 2) = (uint64_t)v158;
      _os_log_impl(&dword_1B8270000, v154, v155, "*warn* openat(%d, \".\", 0): %s", (uint8_t *)&handler, 0x12u);
    }
  }
  else
  {
    v55 = v54;
    v56 = fdopendir(v54);
    if (v56)
    {
      v57 = v56;
      v58 = v52;
      bzero(&handler, 0x418uLL);
      v720 = 0;
      v718 = 0uLL;
      v719 = 0;
      if (!*(_BYTE *)(v52 + 48))
        *(_BYTE *)(v52 + 48) = 1;
      *(_QWORD *)(v52 + 40) = 0;
      if (!*(_BYTE *)(v52 + 64))
        *(_BYTE *)(v52 + 64) = 1;
      *(_QWORD *)(v52 + 56) = 0;
      if (!*(_BYTE *)(v52 + 104))
        *(_BYTE *)(v52 + 104) = 1;
      *(_QWORD *)(v52 + 96) = 0;
      if (!*(_BYTE *)(v52 + 88))
        *(_BYTE *)(v52 + 88) = 1;
      v674 = (_QWORD *)(v52 + 96);
      v675 = (_QWORD *)(v52 + 80);
      *(_QWORD *)(v52 + 80) = 0;
      while (!readdir_r(v57, (dirent *)&handler, &v720) && v720)
      {
        d_name = v720->d_name;
        if (!strncmp(v720->d_name, "cold.", 5uLL))
        {
          v65 = *__error();
          v66 = _SILogForLogForCategory(8);
          v67 = 2 * (dword_1EF19FCAC < 4);
          if (os_log_type_enabled(v66, v67))
          {
            LODWORD(buf.__first_) = 136315138;
            *(std::__split_buffer<std::string>::pointer *)((char *)&buf.__first_ + 4) = (std::__split_buffer<std::string>::pointer)v720->d_name;
            _os_log_impl(&dword_1B8270000, v66, v67, "found cold file %s", (uint8_t *)&buf, 0xCu);
          }
          *__error() = v65;
          if (!*(_BYTE *)(v58 + 48))
LABEL_826:
            std::__throw_bad_optional_access[abi:nn180100]();
          ++*(_QWORD *)(v58 + 40);
          v68 = openat(*(_DWORD *)v51, v720->d_name, 0);
          if (v68 >= 1)
          {
            v69 = v68;
            file_size = get_file_size(v68);
            if (file_size >= 1)
            {
              if (!*(_BYTE *)(v58 + 64))
                goto LABEL_826;
              *(_QWORD *)(v58 + 56) += file_size;
            }
            close(v69);
          }
          std::string::basic_string[abi:nn180100]<0>(__p, v720->d_name);
          v717 = 0;
          v71 = *(_QWORD *)(v51 + 24);
          v72 = *(_QWORD *)(v51 + 32);
          if (v71 >= v72)
          {
            v74 = *(_QWORD *)(v51 + 16);
            v75 = (uint64_t)(v71 - v74) >> 5;
            v76 = v75 + 1;
            if ((unint64_t)(v75 + 1) >> 59)
              goto LABEL_827;
            v77 = v72 - v74;
            if (v77 >> 4 > v76)
              v76 = v77 >> 4;
            if ((unint64_t)v77 >= 0x7FFFFFFFFFFFFFE0)
              v78 = 0x7FFFFFFFFFFFFFFLL;
            else
              v78 = v76;
            buf.__end_cap_.__value_ = (std::allocator<std::string> *)(v51 + 32);
            v79 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<std::string,_freeTextCandidate *>>>(v78);
            v81 = &v79[32 * v75];
            v82 = v81;
            v83 = v716;
            *(_OWORD *)v81 = *(_OWORD *)__p;
            *((_QWORD *)v81 + 2) = v83;
            v716 = 0;
            __p[1] = 0;
            __p[0] = 0;
            *((_WORD *)v81 + 12) = v717;
            v84 = *(_QWORD *)(v51 + 16);
            v85 = *(_QWORD *)(v51 + 24);
            if (v85 == v84)
            {
              v88 = vdupq_n_s64(v85);
              v86 = &v79[32 * v75];
            }
            else
            {
              do
              {
                v86 = v82 - 32;
                v87 = *(_OWORD *)(v85 - 32);
                *((_QWORD *)v82 - 2) = *(_QWORD *)(v85 - 16);
                *((_OWORD *)v82 - 2) = v87;
                *(_QWORD *)(v85 - 24) = 0;
                *(_QWORD *)(v85 - 16) = 0;
                *(_QWORD *)(v85 - 32) = 0;
                *((_WORD *)v82 - 4) = *(_WORD *)(v85 - 8);
                v85 -= 32;
                v82 -= 32;
              }
              while (v85 != v84);
              v88 = *(int64x2_t *)(v51 + 16);
            }
            v95 = v81 + 32;
            *(_QWORD *)(v51 + 16) = v86;
            *(_QWORD *)(v51 + 24) = v81 + 32;
            *(int64x2_t *)&buf.__begin_ = v88;
            v96 = *(std::string **)(v51 + 32);
            *(_QWORD *)(v51 + 32) = &v79[32 * v80];
            buf.__end_cap_.__value_ = v96;
            buf.__first_ = (std::__split_buffer<std::string>::pointer)v88.i64[0];
            std::__split_buffer<std::pair<std::string,_freeTextCandidate *>>::~__split_buffer((uint64_t)&buf);
            v97 = SHIBYTE(v716);
            *(_QWORD *)(v51 + 24) = v95;
            if (v97 < 0)
              goto LABEL_89;
          }
          else
          {
            v73 = *(_OWORD *)__p;
            *(_QWORD *)(v71 + 16) = v716;
            *(_OWORD *)v71 = v73;
            v716 = 0;
            __p[1] = 0;
            __p[0] = 0;
            *(_WORD *)(v71 + 24) = v717;
            *(_QWORD *)(v51 + 24) = v71 + 32;
          }
        }
        else if (!strncmp(d_name, "hot.", 4uLL))
        {
          v60 = *__error();
          v61 = _SILogForLogForCategory(8);
          v62 = 2 * (dword_1EF19FCAC < 4);
          if (os_log_type_enabled(v61, v62))
          {
            LODWORD(buf.__first_) = 136315138;
            *(std::__split_buffer<std::string>::pointer *)((char *)&buf.__first_ + 4) = (std::__split_buffer<std::string>::pointer)v720->d_name;
            _os_log_impl(&dword_1B8270000, v61, v62, "found hot file %s", (uint8_t *)&buf, 0xCu);
          }
          *__error() = v60;
          std::string::basic_string[abi:nn180100]<0>(__p, v720->d_name);
          v63 = (_OWORD *)v718.i64[1];
          if (v718.i64[1] >= (unint64_t)v719)
          {
            v89 = 0xAAAAAAAAAAAAAAABLL * ((v718.i64[1] - v718.i64[0]) >> 3);
            v90 = v89 + 1;
            if (v89 + 1 > 0xAAAAAAAAAAAAAAALL)
LABEL_827:
              abort();
            if (0x5555555555555556 * (((uint64_t)v719 - v718.i64[0]) >> 3) > v90)
              v90 = 0x5555555555555556 * (((uint64_t)v719 - v718.i64[0]) >> 3);
            if (0xAAAAAAAAAAAAAAABLL * (((uint64_t)v719 - v718.i64[0]) >> 3) >= 0x555555555555555)
              v91 = 0xAAAAAAAAAAAAAAALL;
            else
              v91 = v90;
            buf.__end_cap_.__value_ = (std::allocator<std::string> *)&v719;
            if (v91)
            {
              v92 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::string>>(v91);
              v94 = v93;
            }
            else
            {
              v94 = 0;
              v92 = 0;
            }
            v98 = &v92[24 * v89];
            v99 = v98;
            v100 = *(_OWORD *)__p;
            *((_QWORD *)v98 + 2) = v716;
            *(_OWORD *)v98 = v100;
            v716 = 0;
            __p[1] = 0;
            __p[0] = 0;
            v101 = v718.i64[1];
            v102 = v718.i64[0];
            if (v718.i64[1] == v718.i64[0])
            {
              v105 = vdupq_n_s64(v718.u64[1]);
              v103 = &v92[24 * v89];
            }
            else
            {
              do
              {
                v103 = v99 - 24;
                v104 = *(_OWORD *)(v101 - 24);
                *((_QWORD *)v99 - 1) = *(_QWORD *)(v101 - 8);
                *(_OWORD *)(v99 - 24) = v104;
                *(_QWORD *)(v101 - 16) = 0;
                *(_QWORD *)(v101 - 8) = 0;
                *(_QWORD *)(v101 - 24) = 0;
                v101 -= 24;
                v99 -= 24;
              }
              while (v101 != v102);
              v105 = v718;
            }
            v106 = v98 + 24;
            v107 = (std::string *)&v92[24 * v94];
            v718.i64[0] = (uint64_t)v103;
            v718.i64[1] = (uint64_t)(v98 + 24);
            *(int64x2_t *)&buf.__begin_ = v105;
            v108 = v719;
            v719 = v107;
            buf.__end_cap_.__value_ = v108;
            buf.__first_ = (std::__split_buffer<std::string>::pointer)v105.i64[0];
            std::__split_buffer<std::string>::~__split_buffer(&buf);
            v718.i64[1] = (uint64_t)v106;
            if (SHIBYTE(v716) < 0)
LABEL_89:
              operator delete(__p[0]);
          }
          else
          {
            v64 = *(_OWORD *)__p;
            *(_QWORD *)(v718.i64[1] + 16) = v716;
            *v63 = v64;
            v718.i64[1] = (uint64_t)v63 + 24;
          }
        }
      }
      closedir(v57);
      v109 = 126 - 2 * __clz(0xAAAAAAAAAAAAAAABLL * ((v718.i64[1] - v718.i64[0]) >> 3));
      if (v718.i64[1] == v718.i64[0])
        v110 = 0;
      else
        v110 = v109;
      std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *,false>((__n128 *)v718.i64[0], (__n128 *)v718.i64[1], v110, 1);
      v111 = *(uint64_t **)(v51 + 16);
      v112 = *(const void ***)(v51 + 24);
      v113 = 126 - 2 * __clz(((char *)v112 - (char *)v111) >> 5);
      if (v112 == (const void **)v111)
        v114 = 0;
      else
        v114 = v113;
      std::__introsort<std::_ClassicAlgPolicy,DocStore::load(analytics::OpenEvent *,BOOL)::{lambda(DocStore::ColdShardDescriptor const&,DocStore::ColdShardDescriptor const&)#1} &,DocStore::ColdShardDescriptor*,false>(v111, v112, v114, 1);
      v115 = v718.i64[1];
      v116 = v718.i64[0];
      if (0xAAAAAAAAAAAAAAABLL * ((v718.i64[1] - v718.i64[0]) >> 3) >= 2)
      {
        v117 = v718.i64[0];
        while (1)
        {
          v118 = (const char *)v117;
          if (*(char *)(v117 + 23) < 0)
            v118 = *(const char **)v117;
          v119 = openat(*(_DWORD *)v51, v118, 536870914);
          *(_DWORD *)(v51 + 4) = v119;
          if ((v119 & 0x80000000) == 0)
            break;
          v124 = *__error();
          if (v124 != 4 && v124 != 35)
          {
            v125 = *__error();
            v126 = _SILogForLogForCategory(8);
            if (os_log_type_enabled(v126, OS_LOG_TYPE_ERROR))
            {
              v150 = (std::string *)v117;
              if (*(char *)(v117 + 23) < 0)
                v150 = *(std::string **)v117;
              v151 = v150;
              v152 = (std::string *)strerror(v124);
              LODWORD(buf.__first_) = 136315906;
              *(std::__split_buffer<std::string>::pointer *)((char *)&buf.__first_ + 4) = (std::__split_buffer<std::string>::pointer)"load";
              WORD2(buf.__begin_) = 1024;
              *(_DWORD *)((char *)&buf.__begin_ + 6) = 208;
              WORD1(buf.__end_) = 2080;
              *(std::__split_buffer<std::string>::pointer *)((char *)&buf.__end_ + 4) = v151;
              WORD2(buf.__end_cap_.__value_) = 2080;
              *(std::string **)((char *)&buf.__end_cap_.__value_ + 6) = v152;
              _os_log_error_impl(&dword_1B8270000, v126, OS_LOG_TYPE_ERROR, "%s:%d: Unable to open dup hot shard %s (err %s), deleting it.", (uint8_t *)&buf, 0x26u);
              v21 = v684;
            }
            *__error() = v125;
            v127 = 0;
            goto LABEL_116;
          }
LABEL_136:
          v115 = v718.i64[1];
          v116 = v718.i64[0];
          v117 = v718.i64[0];
          if (0xAAAAAAAAAAAAAAABLL * ((v718.i64[1] - v718.i64[0]) >> 3) <= 1)
            goto LABEL_155;
        }
        __p[0] = 0;
        v120 = hot_shard_trim(v119, &v714, __p);
        v121 = *__error();
        v122 = _SILogForLogForCategory(8);
        v123 = v122;
        if (v120)
        {
          if (!os_log_type_enabled(v122, OS_LOG_TYPE_ERROR))
          {
LABEL_103:
            v21 = v684;
            goto LABEL_114;
          }
          v142 = (std::string *)v117;
          if (*(char *)(v117 + 23) < 0)
            v142 = *(std::string **)v117;
          v143 = v142;
          v144 = (std::string *)strerror(-v120);
          LODWORD(buf.__first_) = 136315906;
          *(std::__split_buffer<std::string>::pointer *)((char *)&buf.__first_ + 4) = (std::__split_buffer<std::string>::pointer)"load";
          WORD2(buf.__begin_) = 1024;
          *(_DWORD *)((char *)&buf.__begin_ + 6) = 215;
          WORD1(buf.__end_) = 2080;
          *(std::__split_buffer<std::string>::pointer *)((char *)&buf.__end_ + 4) = v143;
          WORD2(buf.__end_cap_.__value_) = 2080;
          *(std::string **)((char *)&buf.__end_cap_.__value_ + 6) = v144;
          v145 = v123;
          v146 = "%s:%d: Failed trimming a dup hot shard %s (err %s), deleting it.";
        }
        else
        {
          v128 = dword_1EF19FCAC < 3;
          if (os_log_type_enabled(v122, (os_log_type_t)(dword_1EF19FCAC < 3)))
          {
            v129 = (std::string *)(v718.i64[1] - 24);
            if (*(char *)(v718.i64[1] - 1) < 0)
              v129 = (std::string *)v129->__r_.__value_.__r.__words[0];
            LODWORD(buf.__first_) = 136315138;
            *(std::__split_buffer<std::string>::pointer *)((char *)&buf.__first_ + 4) = v129;
            _os_log_impl(&dword_1B8270000, v123, (os_log_type_t)v128, "*warn* Found extra hot shard %s; cooling.",
              (uint8_t *)&buf,
              0xCu);
          }
          *__error() = v121;
          v130 = DocStore::do_cool_hot_shard((DocStore *)v51);
          if (!v130)
          {
            v133 = 1;
            v21 = v684;
            goto LABEL_115;
          }
          v131 = v130;
          v121 = *__error();
          v132 = _SILogForLogForCategory(8);
          v21 = v684;
          if (!os_log_type_enabled(v132, OS_LOG_TYPE_ERROR))
          {
LABEL_114:
            *__error() = v121;
            v133 = 0;
LABEL_115:
            v127 = v133;
LABEL_116:
            close(*(_DWORD *)(v51 + 4));
            *(_DWORD *)(v51 + 4) = -1;
            if (*(char *)(v117 + 23) < 0)
              v134 = *(const char **)v117;
            else
              v134 = (const char *)v117;
            unlinkat(*(_DWORD *)v51, v134, 0);
            v135 = v718.i64[1];
            if (v718.i64[0] + 24 == v718.i64[1])
            {
              v139 = v718.i64[0];
              v138 = v718.i64[0] + 24;
            }
            else
            {
              v136 = v718.i64[0];
              do
              {
                if (*(char *)(v136 + 23) < 0)
                  operator delete(*(void **)v136);
                *(_OWORD *)v136 = *(_OWORD *)(v136 + 24);
                *(_QWORD *)(v136 + 16) = *(_QWORD *)(v136 + 40);
                *(_BYTE *)(v136 + 47) = 0;
                v137 = v136 + 48;
                *(_BYTE *)(v136 + 24) = 0;
                v136 += 24;
              }
              while (v137 != v135);
              v138 = v718.i64[1];
              v139 = v136;
            }
            if (v138 != v139)
            {
              v140 = v138;
              do
              {
                if (*(char *)(v140 - 1) < 0)
                  operator delete(*(void **)(v140 - 24));
                v140 -= 24;
              }
              while (v140 != v139);
            }
            v718.i64[1] = v139;
            if (v127)
            {
              v141 = v674;
              if (!*(_BYTE *)(v58 + 104))
                goto LABEL_826;
            }
            else
            {
              v141 = v675;
              if (!*(_BYTE *)(v58 + 88))
                goto LABEL_826;
            }
            ++*v141;
            goto LABEL_136;
          }
          v147 = (std::string *)v117;
          if (*(char *)(v117 + 23) < 0)
            v147 = *(std::string **)v117;
          v148 = v147;
          v149 = (std::string *)strerror(-v131);
          LODWORD(buf.__first_) = 136315906;
          *(std::__split_buffer<std::string>::pointer *)((char *)&buf.__first_ + 4) = (std::__split_buffer<std::string>::pointer)"load";
          WORD2(buf.__begin_) = 1024;
          *(_DWORD *)((char *)&buf.__begin_ + 6) = 221;
          WORD1(buf.__end_) = 2080;
          *(std::__split_buffer<std::string>::pointer *)((char *)&buf.__end_ + 4) = v148;
          WORD2(buf.__end_cap_.__value_) = 2080;
          *(std::string **)((char *)&buf.__end_cap_.__value_ + 6) = v149;
          v145 = v132;
          v146 = "%s:%d: Failed cooling down a dup hot shard %s (err %s), deleting it.";
        }
        _os_log_error_impl(&dword_1B8270000, v145, OS_LOG_TYPE_ERROR, v146, (uint8_t *)&buf, 0x26u);
        goto LABEL_103;
      }
LABEL_155:
      v22 = v696;
      if (v115 != v116)
      {
        if (*(char *)(v115 - 1) < 0)
          v164 = *(const char **)(v115 - 24);
        else
          v164 = (const char *)(v115 - 24);
        v166 = openat(*(_DWORD *)v51, v164, 536870914);
        *(_DWORD *)(v51 + 4) = v166;
        if ((v166 & 0x80000000) != 0)
        {
          v175 = *__error();
          v176 = _SILogForLogForCategory(8);
          v177 = dword_1EF19FCAC < 3;
          v17 = v695;
          v35 = v694;
          if (os_log_type_enabled(v176, (os_log_type_t)(dword_1EF19FCAC < 3)))
          {
            v178 = *(_DWORD *)v51;
            v179 = (std::string *)(v718.i64[1] - 24);
            if (*(char *)(v718.i64[1] - 1) < 0)
              v179 = (std::string *)v179->__r_.__value_.__r.__words[0];
            v180 = v179;
            v181 = __error();
            v182 = (std::string *)strerror(*v181);
            LODWORD(buf.__first_) = 67109634;
            HIDWORD(buf.__first_) = v178;
            LOWORD(buf.__begin_) = 2080;
            *(std::__split_buffer<std::string>::pointer *)((char *)&buf.__begin_ + 2) = v180;
            WORD1(buf.__end_) = 2080;
            *(std::__split_buffer<std::string>::pointer *)((char *)&buf.__end_ + 4) = v182;
            _os_log_impl(&dword_1B8270000, v176, v177, "*warn* openat(%d, %s, O_RDWR): %s", (uint8_t *)&buf, 0x1Cu);
          }
          *__error() = v175;
          v165 = -*__error();
          goto LABEL_183;
        }
        v167 = hot_shard_trim(v166, (off_t *)(v51 + 112), (_QWORD *)(v51 + 104));
        v17 = v695;
        v35 = v694;
        if (v167)
        {
          v168 = v167;
          v169 = *__error();
          v170 = _SILogForLogForCategory(8);
          v171 = dword_1EF19FCAC < 3;
          if (os_log_type_enabled(v170, (os_log_type_t)(dword_1EF19FCAC < 3)))
          {
            v172 = (std::string *)(v718.i64[1] - 24);
            if (*(char *)(v718.i64[1] - 1) < 0)
              v172 = (std::string *)v172->__r_.__value_.__r.__words[0];
            v173 = v172;
            v174 = (std::string *)strerror(-v168);
            LODWORD(buf.__first_) = 136315394;
            *(std::__split_buffer<std::string>::pointer *)((char *)&buf.__first_ + 4) = v173;
            WORD2(buf.__begin_) = 2080;
            *(std::__split_buffer<std::string>::pointer *)((char *)&buf.__begin_ + 6) = v174;
            _os_log_impl(&dword_1B8270000, v170, v171, "*warn* hot_shard_trim(%s): %s", (uint8_t *)&buf, 0x16u);
          }
          *__error() = v169;
          v165 = v168;
          goto LABEL_183;
        }
        *(_QWORD *)(v58 + 24) = *(_QWORD *)(v51 + 112);
        *(_BYTE *)(v58 + 32) = 1;
        caching_hot_shard_alloc((uint64_t *)(v51 + 8));
        v183 = *(CachingHotShard **)(v51 + 8);
        if (v183)
        {
          v165 = CachingHotShard::Bind(v183, *(_DWORD *)(v51 + 4));
          if (!v165)
          {
            if (*(_QWORD *)(v51 + 24) == *(_QWORD *)(v51 + 16))
            {
              v165 = 0;
            }
            else
            {
              v184 = 24;
              v185 = 0;
              do
              {
                v186 = v185;
                v187 = v184;
                v188 = DocStore::add_cold_shard_to_bloom_filter((DocStore *)v51, v185) == 0;
                v189 = *(_QWORD *)(v51 + 16);
                *(_BYTE *)(v189 + v187) = v188;
                v190 = v186 + 1 >= (unint64_t)((*(_QWORD *)(v51 + 24) - v189) >> 5);
                v185 = v186 + 1;
                v184 = v187 + 32;
                v165 = 0;
              }
              while (!v190);
            }
            goto LABEL_183;
          }
        }
        else
        {
          v165 = -14;
        }
        v191 = *__error();
        v192 = _SILogForLogForCategory(8);
        v193 = dword_1EF19FCAC < 3;
        if (os_log_type_enabled(v192, (os_log_type_t)(dword_1EF19FCAC < 3)))
        {
          v194 = (std::string *)strerror(-v165);
          LODWORD(buf.__first_) = 136315138;
          *(std::__split_buffer<std::string>::pointer *)((char *)&buf.__first_ + 4) = v194;
          _os_log_impl(&dword_1B8270000, v192, v193, "*warn* caching_hot_shard_bind: %s", (uint8_t *)&buf, 0xCu);
        }
        *__error() = v191;
        goto LABEL_183;
      }
      v165 = DocStore::create((DocStore *)v51);
      v17 = v695;
      v35 = v694;
LABEL_183:
      buf.__first_ = (std::__split_buffer<std::string>::pointer)&v718;
      std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&buf);
      v163 = v165;
      goto LABEL_184;
    }
    v153 = *__error();
    v159 = _SILogForLogForCategory(8);
    v160 = dword_1EF19FCAC < 3;
    if (os_log_type_enabled(v159, (os_log_type_t)(dword_1EF19FCAC < 3)))
    {
      v161 = __error();
      v162 = strerror(*v161);
      handler.f_bsize = 67109378;
      handler.f_iosize = v55;
      LOWORD(handler.f_blocks) = 2080;
      *(uint64_t *)((char *)&handler.f_blocks + 2) = (uint64_t)v162;
      _os_log_impl(&dword_1B8270000, v159, v160, "*warn* fdopendir(%d): %s", (uint8_t *)&handler, 0x12u);
    }
  }
  *__error() = v153;
  v163 = -*__error();
LABEL_184:
  v195 = *(_QWORD *)&v712[0];
  *(_DWORD *)(*(_QWORD *)&v712[0] + 12) = v163;
  *(_BYTE *)(v195 + 16) = 1;
  *(_WORD *)(v195 + 8) = (v163 == 0) | 0x100;
  v196 = *__error();
  v197 = _SILogForLogForCategory(8);
  v198 = v197;
  if (v163)
  {
    if (os_log_type_enabled(v197, OS_LOG_TYPE_ERROR))
    {
      handler.f_bsize = 136315650;
      *(_QWORD *)&handler.f_iosize = "doc_store_load";
      WORD2(handler.f_blocks) = 1024;
      *(_DWORD *)((char *)&handler.f_blocks + 6) = 937;
      WORD1(handler.f_bfree) = 1024;
      HIDWORD(handler.f_bfree) = v163;
      _os_log_error_impl(&dword_1B8270000, v198, OS_LOG_TYPE_ERROR, "%s:%d: Load error %d", (uint8_t *)&handler, 0x18u);
    }
    *__error() = v196;
    DocStore::~DocStore((DocStore *)v51);
    MEMORY[0x1BCCB06A4]();
    v51 = 0;
  }
  else
  {
    v199 = (2 * (dword_1EF19FCAC < 4));
    if (os_log_type_enabled(v197, (os_log_type_t)(2 * (dword_1EF19FCAC < 4))))
    {
      handler.f_bsize = 136315394;
      *(_QWORD *)&handler.f_iosize = "docstore";
      WORD2(handler.f_blocks) = 2048;
      *(uint64_t *)((char *)&handler.f_blocks + 6) = v51;
      _os_log_impl(&dword_1B8270000, v198, (os_log_type_t)v199, "Loaded doc store %s as %p", (uint8_t *)&handler, 0x16u);
    }
    *__error() = v196;
  }
  analytics::ScopedLogger<analytics::OpenEvent>::~ScopedLogger(v712);
  ScopeLogger::~ScopeLogger((ScopeLogger *)v713);
  *(_QWORD *)(v22 + 1296) = v51;
  if (!v51)
  {
    v200 = *(_DWORD *)(v22 + 32);
    memset(&handler, 0, 512);
    snprintf((char *)&handler, 0x200uLL, "doc_store_create(%d, %s, %lld)", v200, "docstore", 1);
    __p[1] = 0;
    __p[0] = 0;
    ScopeLogger::ScopeLogger((ScopeLogger *)__p, (const char *)&handler);
    memset(&v724, 0, 32);
    analytics::ScopedLogger<analytics::OpenEvent>::ScopedLogger((std::chrono::steady_clock::time_point *)&v724);
    v201 = *(_QWORD *)&v724.st_dev;
    **(_DWORD **)&v724.st_dev = 0;
    *(_BYTE *)(v201 + 4) = 1;
    v202 = (DocStore *)operator new();
    DocStore::DocStore(v202, v200);
    v204 = DocStore::create(v203);
    v205 = *(_QWORD *)&v724.st_dev;
    *(_DWORD *)(*(_QWORD *)&v724.st_dev + 12) = v204;
    *(_BYTE *)(v205 + 16) = 1;
    *(_WORD *)(v205 + 8) = (v204 == 0) | 0x100;
    v206 = *__error();
    v207 = _SILogForLogForCategory(8);
    v208 = v207;
    if (v204)
    {
      if (os_log_type_enabled(v207, OS_LOG_TYPE_ERROR))
      {
        LODWORD(buf.__first_) = 136315650;
        *(std::__split_buffer<std::string>::pointer *)((char *)&buf.__first_ + 4) = (std::__split_buffer<std::string>::pointer)"doc_store_create";
        WORD2(buf.__begin_) = 1024;
        *(_DWORD *)((char *)&buf.__begin_ + 6) = 954;
        WORD1(buf.__end_) = 1024;
        HIDWORD(buf.__end_) = v204;
        _os_log_error_impl(&dword_1B8270000, v208, OS_LOG_TYPE_ERROR, "%s:%d: Create error %d", (uint8_t *)&buf, 0x18u);
      }
      *__error() = v206;
      DocStore::~DocStore(v202);
      MEMORY[0x1BCCB06A4]();
      v202 = 0;
    }
    else
    {
      v209 = 2 * (dword_1EF19FCAC < 4);
      if (os_log_type_enabled(v207, v209))
      {
        LODWORD(buf.__first_) = 136315394;
        *(std::__split_buffer<std::string>::pointer *)((char *)&buf.__first_ + 4) = (std::__split_buffer<std::string>::pointer)"docstore";
        WORD2(buf.__begin_) = 2048;
        *(std::__split_buffer<std::string>::pointer *)((char *)&buf.__begin_ + 6) = (std::__split_buffer<std::string>::pointer)v202;
        _os_log_impl(&dword_1B8270000, v208, v209, "Created doc store %s as %p", (uint8_t *)&buf, 0x16u);
      }
      *__error() = v206;
    }
    v35 = v694;
    analytics::ScopedLogger<analytics::OpenEvent>::~ScopedLogger(&v724);
    ScopeLogger::~ScopeLogger((ScopeLogger *)__p);
    *(_QWORD *)(v22 + 1296) = v202;
  }
  v46 = allocator;
  if (_os_feature_enabled_impl())
    *(_QWORD *)(v22 + 1288) = MDTrieCreate();
LABEL_202:
  v210 = fcntl(*(_DWORD *)(v22 + 32), 50, __s1);
  v211 = 0;
  if ((v210 & 0x80000000) == 0 && __s1[0])
  {
    v212 = strstr(__s1, "NSFile");
    if (v212)
      v211 = v212;
    else
      v211 = __s1;
  }
  v678 = v211;
  if (*(_QWORD *)(v22 + 1184))
  {
    _SIInitSDB(v22, v17, (v17 >> 2) & 1);
    v213 = (const __CFNumber *)SICopyProperty(v22, CFSTR("JournalSerialNumber"));
    if (v213)
    {
      v214 = v213;
      v215 = CFGetTypeID(v213);
      if (v215 == CFNumberGetTypeID())
      {
        *(_QWORD *)&handler.f_bsize = 0;
        CFNumberGetValue(v214, kCFNumberSInt64Type, &handler);
        if (*(_QWORD *)&handler.f_bsize)
          *(_QWORD *)(v22 + 2128) = *(_QWORD *)&handler.f_bsize;
      }
      CFRelease(v214);
    }
    v216 = (const __CFNumber *)SICopyProperty(v22, CFSTR("ConsumedJournalSerialNumber"));
    if (v216)
    {
      v217 = v216;
      v218 = CFGetTypeID(v216);
      if (v218 == CFNumberGetTypeID())
      {
        *(_QWORD *)&handler.f_bsize = 0;
        CFNumberGetValue(v217, kCFNumberSInt64Type, &handler);
        if (*(_QWORD *)&handler.f_bsize)
          *(_QWORD *)(v22 + 2136) = *(_QWORD *)&handler.f_bsize;
      }
      CFRelease(v217);
    }
    v219 = (const __CFNumber *)SICopyProperty(v22, CFSTR("kSIIdentifierHashVersion"));
    if (v219)
    {
      v220 = v219;
      v221 = CFGetTypeID(v219);
      if (v221 == CFNumberGetTypeID())
      {
        handler.f_bsize = 0;
        CFNumberGetValue(v220, kCFNumberIntType, &handler);
        *(_DWORD *)(v22 + 6584) = *(_DWORD *)(v22 + 6584) & 0xFFDFFFFF | ((handler.f_bsize & 1) << 21);
      }
      CFRelease(v220);
    }
    v222 = (const __CFNumber *)SICopyProperty(v22, CFSTR("kSIIdentifierHashVersion"));
    if (v222)
    {
      v223 = v222;
      v224 = CFGetTypeID(v222);
      if (v224 == CFNumberGetTypeID())
      {
        handler.f_bsize = 0;
        CFNumberGetValue(v223, kCFNumberIntType, &handler);
        *(_DWORD *)(v22 + 6584) = *(_DWORD *)(v22 + 6584) & 0xFFDFFFFF | ((handler.f_bsize & 1) << 21);
      }
      CFRelease(v223);
    }
    if ((v687 & 1) == 0)
    {
      v225 = *(_DWORD *)(v22 + 1456);
      if (v225 <= 1)
        v225 = 1;
      *(_QWORD *)&handler.f_bsize = 0;
      handler.f_blocks = (uint64_t)&handler;
      handler.f_bfree = 0x2000000000;
      LODWORD(handler.f_bavail) = v225;
      v226 = *(_QWORD *)(v22 + 1392);
      v227 = *(_QWORD *)(v22 + 1384);
      v701[0] = MEMORY[0x1E0C809B0];
      v701[1] = 0x40000000;
      v702 = __SIInitIndex_block_invoke_2;
      v703 = &unk_1E6E2D970;
      p_handler = &handler;
      if (v226 && *(_DWORD *)(v226 + 8))
      {
        v228 = 0;
        while (v702((uint64_t)v701, *(_QWORD *)(*(_QWORD *)v226 + 8 * v228)))
        {
          if (++v228 >= (unint64_t)*(unsigned int *)(v226 + 8))
            goto LABEL_234;
        }
      }
      else
      {
LABEL_234:
        if (v227 && *(_DWORD *)(v227 + 8))
        {
          v229 = 0;
          do
          {
            if (!v702((uint64_t)v701, *(_QWORD *)(*(_QWORD *)v227 + 8 * v229)))
              break;
            ++v229;
          }
          while (v229 < *(unsigned int *)(v227 + 8));
        }
      }
      v230 = *(_DWORD *)(handler.f_blocks + 24);
      v46 = allocator;
      if (v230 > *(_DWORD *)(v22 + 1456))
      {
        *(_DWORD *)(v22 + 1456) = v230;
        v231 = CFNumberCreate(allocator, kCFNumberSInt32Type, (const void *)(v22 + 1456));
        SISetProperty(v22, CFSTR("kSINextIndexId"), v231);
        CFRelease(v231);
      }
      _Block_object_dispose(&handler, 8);
    }
  }
  *(_QWORD *)(v22 + 1776) = CFSetCreateMutable(v46, 0, &kSILQCallbacks);
  *(_QWORD *)(v22 + 1784) = CFDictionaryCreateMutable(v46, 0, MEMORY[0x1E0C9B390], &kQueryNodeUniqueSetValueCallbacks);
  pthread_mutex_init((pthread_mutex_t *)(v22 + 1712), 0);
  pthread_mutex_init((pthread_mutex_t *)(v22 + 1320), 0);
  *(_QWORD *)(v22 + 1440) = 0;
  if ((v17 & 0xC) != 0)
  {
    v232 = cf;
    if ((v17 & 8) != 0)
      goto LABEL_280;
  }
  else
  {
    v233 = (const __CFNumber *)SICopyProperty(v22, CFSTR("kMDSIndexSyncCount"));
    v234 = (_DWORD *)(v22 + 2344);
    if (v233)
    {
      v235 = v233;
      CFNumberGetValue(v233, kCFNumberIntType, v234);
      CFRelease(v235);
    }
    else
    {
      *v234 = 1;
    }
    v236 = (const __CFNumber *)SICopyProperty(v22, CFSTR("kMDSIndexDeferSyncCount"));
    v237 = (_DWORD *)(v22 + 2348);
    if (v236)
    {
      v238 = v236;
      CFNumberGetValue(v236, kCFNumberIntType, v237);
      CFRelease(v238);
    }
    else
    {
      *v237 = 1;
    }
    v232 = cf;
  }
  if (!*(_BYTE *)(v22 + 2073))
  {
    v239 = (const __CFBoolean *)SICopyProperty(v22, CFSTR("kSITokenizerUnigrams"));
    if (v239)
    {
      v240 = v239;
      if (CFBooleanGetValue(v239))
        *(_BYTE *)(v22 + 2073) = 1;
      CFRelease(v240);
      v232 = cf;
    }
  }
  if ((*(_BYTE *)(v22 + 6586) & 0x18) == 0)
  {
    v241 = (const __CFBoolean *)SICopyProperty(v22, CFSTR("kSITokenizerUseCRF"));
    if (v241)
    {
      v242 = v241;
      if (CFBooleanGetValue(v241))
        *(_DWORD *)(v22 + 6584) = *(_DWORD *)(v22 + 6584) & 0xFFE7FFFF | 0x80000;
      CFRelease(v242);
      v232 = cf;
    }
    v243 = (const __CFNumber *)SICopyProperty(v22, CFSTR("kSITokenizerVersion"));
    if (v243)
    {
      v244 = v243;
      *(_DWORD *)(v22 + 6584) |= 0x180000u;
      v245 = CFGetTypeID(v243);
      if (v245 == CFNumberGetTypeID())
      {
        handler.f_bsize = 0;
        if (CFNumberGetValue(v244, kCFNumberIntType, &handler))
        {
          if (handler.f_bsize - 1 <= 2)
            *(_DWORD *)(v22 + 6584) = *(_DWORD *)(v22 + 6584) & 0xFFE7FFFF | ((handler.f_bsize & 3) << 19);
        }
      }
      CFRelease(v244);
      v232 = cf;
    }
    if ((v17 & 1) == 0 && (~*(_DWORD *)(v22 + 6584) & 0x180000) != 0)
    {
      v246 = CFLocaleCopyPreferredLanguages();
      if (v246)
      {
        v247 = v246;
        if (CFArrayGetCount(v246))
        {
          ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v247, 0);
          if ((unint64_t)CFStringFind(ValueAtIndex, CFSTR("ko"), 9uLL).length)
          {
            v249 = *__error();
            v250 = _SILogForLogForCategory(0);
            if (os_log_type_enabled(v250, OS_LOG_TYPE_ERROR))
            {
              v618 = *(_DWORD *)(v22 + 6584);
              handler.f_bsize = 136315906;
              *(_QWORD *)&handler.f_iosize = "SIInitIndex";
              WORD2(handler.f_blocks) = 1024;
              *(_DWORD *)((char *)&handler.f_blocks + 6) = 14073;
              WORD1(handler.f_bfree) = 1024;
              HIDWORD(handler.f_bfree) = (v618 >> 19) & 3;
              LOWORD(handler.f_bavail) = 2112;
              *(uint64_t *)((char *)&handler.f_bavail + 2) = (uint64_t)ValueAtIndex;
              _os_log_error_impl(&dword_1B8270000, v250, OS_LOG_TYPE_ERROR, "%s:%d: rebuild index for tokenizer (%d) %@", (uint8_t *)&handler, 0x22u);
            }
            *__error() = v249;
            CFRelease(v247);
            _si_set_error_str("rebuild for tokenizer");
            _si_set_rebuild_reason("tokenizer", 1);
            goto LABEL_303;
          }
        }
        CFRelease(v247);
        v46 = allocator;
      }
    }
  }
  if ((v17 & 0xC) == 0)
  {
    v251 = *(_DWORD **)(v22 + 1184);
    if (v251)
      db_create_id_for_field(v251, "kMDItemAttributeChangeDate", 0, 12);
  }
LABEL_280:
  if (v232)
    CFRetain(v232);
  *(_QWORD *)(v22 + 1416) = v232;
  if (v21 && (v17 & 0x100) == 0)
  {
    v252 = *(_DWORD *)(v22 + 6584) & 0xFFFFFFFD | (2 * ((v21[7] & 0x180) == 256));
    *(_DWORD *)(v22 + 6584) = v252;
    v253 = v252 & 0xFFFFFFFB | (4 * ((v21[7] >> 5) & 1));
    *(_DWORD *)(v22 + 6584) = v253;
    v254 = v253 & 0xFFFFFFFE | (v21[7] >> 13) & 1;
    *(_DWORD *)(v22 + 6584) = v254;
    *(_DWORD *)(v22 + 6584) = (v254 & 0xFFFEFFFF | (((v21[7] >> 2) & 1) << 16)) ^ 0x10000;
LABEL_286:
    if (v232)
      goto LABEL_287;
    _si_set_error_str("open persistent id store error");
LABEL_303:
    v33 = v683;
    v260 = *(_QWORD *)&threadData[18 * v708 + 2];
    v261 = v707;
    v262 = v260 + 320 * v707;
    *(_DWORD *)(v262 + 312) = v693;
    v263 = *(void (**)(_QWORD))(v262 + 232);
    if (v263)
      v263(*(_QWORD *)(v260 + 320 * v261 + 288));
    dropThreadId(v708, 0, v35);
    goto LABEL_306;
  }
  if ((v17 & 0x100) == 0)
    goto LABEL_286;
LABEL_287:
  memset(v721, 0, sizeof(v721));
  pthread_mutex_lock(&schlock);
  v255 = 12;
  if ((v17 & 4) != 0)
    v255 = 9;
  if ((v17 & 8) != 0)
    v256 = 6;
  else
    v256 = v255;
  for (i = 0; i != v256; ++i)
  {
    if (!global_schedulers[i])
      global_schedulers[i] = (uint64_t)CFDictionaryCreateMutable(v46, 0, 0, &kSISchedulerDictionaryValueCallBacks);
  }
  if ((v17 & 8) == 0)
  {
    Mutable = (__CFSet *)gAllIndexes;
    if (!gAllIndexes)
    {
      Mutable = CFSetCreateMutable(v46, 0, 0);
      gAllIndexes = (uint64_t)Mutable;
    }
    CFSetAddValue(Mutable, (const void *)v22);
  }
  v259 = v685;
  if (v685)
    v259 = *v685;
  v665 = v259;
  if (v21)
    v265 = *v21;
  else
    v265 = 0;
  *(_DWORD *)(v22 + 1404) = v665;
  v664 = v265;
  *(_DWORD *)(v22 + 1408) = v265;
  *(_DWORD *)(v22 + 6584) |= 0x40000u;
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __SIInitIndex_block_invoke_860;
  block[3] = &__block_descriptor_tmp_863;
  block[4] = v22;
  if (SIInitIndex_once != -1)
    dispatch_once(&SIInitIndex_once, block);
  v688 = v17 & 0xC;
  if (SIInitIndex_override == 1 && ((*(_DWORD *)(v22 + 6584) >> 18) & 1) != SIInitIndex_lowLatency)
  {
    v266 = *__error();
    v267 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v267, OS_LOG_TYPE_DEFAULT))
    {
      if (SIInitIndex_lowLatency)
        v268 = "true";
      else
        v268 = "false";
      handler.f_bsize = 136315138;
      *(_QWORD *)&handler.f_iosize = v268;
      _os_log_impl(&dword_1B8270000, v267, OS_LOG_TYPE_DEFAULT, "setting low latency: %s", (uint8_t *)&handler, 0xCu);
    }
    *__error() = v266;
    *(_DWORD *)(v22 + 6584) = *(_DWORD *)(v22 + 6584) & 0xFFFBFFFF | (SIInitIndex_lowLatency << 18);
  }
  v269 = v22 + 864;
  for (j = 0; j != 336; j += 56)
  {
    bzero(&handler, 0x450uLL);
    v271 = *(int *)((char *)&free_scheduler_settings + j + 48);
    v272 = *(int *)((char *)&free_scheduler_settings + j + 52);
    snprintf((char *)&handler, 0x450uLL, "%s scheduler for index at %s", *(const char **)((char *)&free_scheduler_settings + j + 40), v678);
    if (*(_QWORD *)(v269 + 8 * v271))
    {
      v461 = __si_assert_copy_extra_521(-1);
      v462 = v461;
      v463 = "";
      if (v461)
        v463 = v461;
      v647 = "newIndex->workqueues.schedulers[schedId]==0";
      v648 = v463;
      v464 = 14201;
      goto LABEL_568;
    }
    v273 = v22 + 8 * v272;
    if (*(_QWORD *)(v273 + 1008))
    {
      v465 = __si_assert_copy_extra_521(-1);
      v462 = v465;
      v466 = "";
      if (v465)
        v466 = v465;
      v647 = "newIndex->workqueues.queues[queueId]==0";
      v648 = v466;
      v464 = 14202;
      goto LABEL_568;
    }
    v274 = (void **)(v273 + 1008);
    root_scheduler = si_create_root_scheduler((uint64_t)&handler);
    *(_QWORD *)(v269 + 8 * v271) = root_scheduler;
    *v274 = si_create_child_queue((uint64_t)root_scheduler);
  }
  v276 = 0;
  v277 = v695;
  do
  {
    if ((v277 & 0x100) != 0)
    {
      v278 = 0;
    }
    else
    {
      v278 = v665;
      if (*((_BYTE *)&scheduler_settings + 56 * v276 + 17))
        v278 = v664;
    }
    v279 = v278;
    if (!CFDictionaryGetValueIfPresent((CFDictionaryRef)global_schedulers[v276], (const void *)v278, (const void **)v721 + v276))
    {
      bzero(&handler, 0x400uLL);
      snprintf((char *)&handler, 0x400uLL, "%s scheduler for spindle %d", *((const char **)&scheduler_settings + 7 * v276 + 5), v279);
      v291 = si_create_root_scheduler((uint64_t)&handler);
      *((_QWORD *)v721 + v276) = v291;
      CFDictionarySetValue((CFMutableDictionaryRef)global_schedulers[v276], (const void *)v279, v291);
      v292 = *((_QWORD *)v721 + v276);
      if (v292)
      {
        v293 = *((_QWORD *)v721 + v276);
        v294 = (unsigned int *)(v292 + 80);
        do
        {
          v295 = __ldaxr(v294);
          v296 = v295 - 1;
        }
        while (__stlxr(v296, v294));
        if (!v296)
          _si_scheduler_destroy(v293);
      }
    }
    bzero(&handler, 0x450uLL);
    v280 = (const char **)((char *)&scheduler_settings + 56 * v276);
    v281 = *((int *)v280 + 12);
    v282 = *((int *)v280 + 13);
    v283 = *(unsigned __int8 *)v280;
    snprintf((char *)&handler, 0x450uLL, "%s scheduler for index at %s", v280[5], v678);
    if (*(_QWORD *)(v269 + 8 * v281))
    {
      v467 = __si_assert_copy_extra_521(-1);
      v468 = v467;
      v469 = "";
      if (v467)
        v469 = v467;
      __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 14240, "newIndex->workqueues.schedulers[schedId]==0", v469);
      goto LABEL_563;
    }
    v284 = v696 + 8 * v282;
    if (*(_QWORD *)(v284 + 1008))
    {
      v471 = __si_assert_copy_extra_521(-1);
      v462 = v471;
      v472 = "";
      if (v471)
        v472 = v471;
      v647 = "newIndex->workqueues.queues[queueId]==0";
      v648 = v472;
      v464 = 14241;
      goto LABEL_568;
    }
    v285 = *((_QWORD *)v721 + v276);
    scheduler = (dispatch_object_t *)si_create_scheduler(*(_QWORD *)(v285 + 32));
    v287 = (uint64_t)scheduler;
    if (v283)
    {
      dispatch_suspend(scheduler[17]);
      ++*(_DWORD *)(v287 + 100);
    }
    *(_OWORD *)(v287 + 8) = *(_OWORD *)(v285 + 8);
    v288 = (unsigned int *)(v285 + 80);
    do
      v289 = __ldaxr(v288);
    while (__stlxr(v289 + 1, v288));
    dispatch_activate(*(dispatch_object_t *)(v287 + 32));
    v290 = *(NSObject **)(v285 + 32);
    *(_QWORD *)&v724.st_dev = MEMORY[0x1E0C809B0];
    v724.st_ino = 0x40000000;
    *(_QWORD *)&v724.st_uid = __si_create_child_scheduler_block_invoke;
    *(_QWORD *)&v724.st_rdev = &__block_descriptor_tmp_16_1003;
    v724.st_atimespec.tv_sec = v285;
    v724.st_atimespec.tv_nsec = v287;
    dispatch_sync(v290, &v724);
    *(_QWORD *)(v269 + 8 * v281) = v287;
    *(_QWORD *)(v284 + 1008) = si_create_child_queue(v287);
    ++v276;
    v277 = v695;
  }
  while (v276 != v256);
  v297 = v696;
  v298 = v688;
  if (*(_QWORD *)(v696 + 896))
  {
    v299 = *__error();
    v300 = _SILogForLogForCategory(3);
    v301 = 2 * (dword_1EF19FC98 < 4);
    if (os_log_type_enabled(v300, v301))
    {
      v302 = *(_QWORD *)(v696 + 896);
      handler.f_bsize = 134218242;
      *(_QWORD *)&handler.f_iosize = v302;
      WORD2(handler.f_blocks) = 2080;
      *(uint64_t *)((char *)&handler.f_blocks + 6) = (uint64_t)v678;
      _os_log_impl(&dword_1B8270000, v300, v301, "Suspending root scheduler for %p (%s)", (uint8_t *)&handler, 0x16u);
    }
    *__error() = v299;
    v303 = *(_QWORD **)(v696 + 896);
    do
    {
      v304 = v303;
      if (!v303)
        break;
      v303 = (_QWORD *)*v303;
    }
    while (*v304);
    *(_QWORD *)(v696 + 2448) = si_scheduler_suspend_async((uint64_t)v304);
  }
  v305 = allocator;
  if (dword_1EF19FC98 >= 5)
  {
    v625 = *__error();
    v626 = _SILogForLogForCategory(3);
    if (os_log_type_enabled(v626, OS_LOG_TYPE_DEFAULT))
    {
      v627 = *(_QWORD *)(v696 + 904);
      handler.f_bsize = 134217984;
      *(_QWORD *)&handler.f_iosize = v627;
      _os_log_impl(&dword_1B8270000, v626, OS_LOG_TYPE_DEFAULT, "Created volume scheduler %p", (uint8_t *)&handler, 0xCu);
    }
    *__error() = v625;
    if (dword_1EF19FC98 >= 5)
    {
      v628 = *__error();
      v629 = _SILogForLogForCategory(3);
      if (os_log_type_enabled(v629, OS_LOG_TYPE_DEFAULT))
      {
        v630 = *(_QWORD *)(v696 + 928);
        handler.f_bsize = 134217984;
        *(_QWORD *)&handler.f_iosize = v630;
        _os_log_impl(&dword_1B8270000, v629, OS_LOG_TYPE_DEFAULT, "Created index scheduler %p", (uint8_t *)&handler, 0xCu);
      }
      *__error() = v628;
    }
  }
  if (!v688)
    *(_QWORD *)(v696 + 1152) = si_create_child_queue(*(_QWORD *)(v696 + 872));
  pthread_mutex_unlock(&schlock);
  *(_QWORD *)(v696 + 6920) = copyVolumeInfoStr(*(_DWORD *)(v696 + 32));
  for (k = 1008; k != 1160; k += 8)
  {
    v307 = *(_QWORD *)(v696 + k);
    if (v307)
    {
      v308 = *(_QWORD *)(v696 + k);
      v309 = *(_DWORD *)(v696 + 32);
      *(_DWORD *)(v307 + 40) = v309;
      *(_QWORD *)(v308 + 48) = copyVolumeInfoStr(v309);
    }
  }
  if (*(_QWORD *)(v696 + 1160))
  {
    v310 = *(_QWORD *)(v696 + 1160);
    *(_DWORD *)(v310 + 40) = -1;
    *(_QWORD *)(v310 + 48) = strdup("");
  }
  if (*(_QWORD *)(v696 + 1184))
  {
    si_create_propertydict(v696, 0, 1);
    if (!*(_QWORD *)(v696 + 1440))
      si_storecookieRef(v696);
    si_getsizes(v696, v686 ^ 1);
  }
  if ((v695 & 8) == 0)
  {
    v311 = (const __CFDictionary *)SICopyProperty(v696, CFSTR("kIndexRemappingData"));
    if (v311)
    {
      v312 = v311;
      Value = (const __CFNumber *)CFDictionaryGetValue(v311, remapping_keys[0]);
      v314 = (const __CFArray *)CFDictionaryGetValue(v312, off_1EF19FD68);
      if (Value)
        CFNumberGetValue(Value, kCFNumberCFIndexType, (void *)(v696 + 2384));
      if (v314)
      {
        v655 = v312;
        Count = CFArrayGetCount(v314);
        theArray = CFArrayCreateMutable(allocator, 0, MEMORY[0x1E0C9B378]);
        if (Count >= 1)
        {
          for (m = 0; Count != m; ++m)
          {
            v317 = (const __CFDictionary *)CFArrayGetValueAtIndex(v314, m);
            v318 = *(_DWORD *)(v696 + 32);
            v319 = (const __CFNumber *)CFDictionaryGetValue(v317, remapping_keys_8410[0]);
            v320 = (const __CFNumber *)CFDictionaryGetValue(v317, off_1EF1A0B28);
            if (v320)
              v321 = v319 == 0;
            else
              v321 = 1;
            if (v321)
              continue;
            *(_QWORD *)&handler.f_bsize = 0;
            v724.st_dev = 0;
            if (!CFNumberGetValue(v320, kCFNumberCFIndexType, &handler))
              continue;
            if (!CFNumberGetValue(v319, kCFNumberSInt32Type, &v724))
              continue;
            v322 = (_QWORD *)CIDecodeRemappingMetadataWithIndex(v318, v724.st_dev, *(uint64_t *)&handler.f_bsize);
            if (!v322)
              continue;
            v323 = v322;
            CFArrayAppendValue(theArray, v322);
            if ((v695 & 4) == 0)
            {
              DocId = ContentIndexRemappingNextDocId(v323, (unint64_t *)&handler.f_bsize);
              if (!DocId)
                continue;
              v325 = si_indexForDocId(v696, DocId);
              if (!v325)
                continue;
              v649 = v325;
              v326 = malloc_type_malloc(0x18uLL, 0x20040960023A9uLL);
              *v326 = v696;
              v326[1] = v649;
              v326[2] = CFRetain(v323);
              si_enqueue_work(*(_QWORD *)(v696 + 1056), (uint64_t)si_remapForIndex, (uint64_t)v326);
            }
            CFRelease(v323);
          }
        }
        v277 = v695;
        v297 = v696;
        si_inflateLeakedRemapping(v696, (v695 & 4) != 0, *(_QWORD *)(v696 + 2384), theArray);
        v312 = v655;
        if (CFArrayGetCount(theArray))
        {
          *(_QWORD *)(v696 + 2368) = theArray;
        }
        else
        {
          *(_QWORD *)(v696 + 2368) = 0;
          CFRelease(theArray);
        }
        v305 = allocator;
        v298 = v688;
      }
      else
      {
        v327 = CFArrayCreateMutable(allocator, 0, MEMORY[0x1E0C9B378]);
        if (*(_QWORD *)(v696 + 2384) <= 1uLL)
          v328 = 1;
        else
          v328 = *(_QWORD *)(v696 + 2384);
        si_inflateLeakedRemapping(v696, (v695 & 4) != 0, v328, v327);
        if (CFArrayGetCount(v327))
        {
          *(_QWORD *)(v696 + 2368) = v327;
        }
        else
        {
          *(_QWORD *)(v696 + 2368) = 0;
          CFRelease(v327);
        }
        v305 = allocator;
      }
      CFRelease(v312);
    }
  }
  si_populateClientStates(v297);
  if (a9 && *(_QWORD *)(v297 + 872) && *(_QWORD *)(v297 + 1040))
  {
    v329 = malloc_type_calloc(1uLL, 0x10uLL, 0x10200403A5D3213uLL);
    v329[2] = a9;
    *(_QWORD *)v329 = v297;
    si_scheduler_suspend(*(_QWORD *)(v297 + 872));
    si_enqueue_work(*(_QWORD *)(v297 + 1040), (uint64_t)si_repair_index_file_tree, (uint64_t)v329);
  }
  if (v298 || (v687 & 1) != 0)
    goto LABEL_751;
  if (!_os_feature_enabled_impl())
    goto LABEL_610;
  if (!si_check_version_property(v297, CFSTR("VEC_EXT_CLEARED_VECTORS")))
  {
    if (si_check_version_property(v297, CFSTR("VEC_EXT_CLEARED_JOURNALS")))
      goto LABEL_609;
    goto LABEL_610;
  }
  v330 = *(_QWORD *)(v297 + 1184);
  if (*(_DWORD *)v330 != 1685287992)
  {
    v644 = __si_assert_copy_extra_268();
    v645 = v644;
    if (v644)
      v646 = v644;
    else
      v646 = "";
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 428, v646);
    free(v645);
    goto LABEL_569;
  }
  v331 = *(_QWORD *)(v297 + 1184);
  v332 = *(_DWORD **)(v297 + 6592);
  buf.__first_ = 0;
  v333 = (pthread_mutex_t *)(v330 + 584);
  HIDWORD(v335) = qos_class_self() - 9;
  LODWORD(v335) = HIDWORD(v335);
  v334 = v335 >> 2;
  if (v334 > 6)
    v336 = 0;
  else
    v336 = dword_1B8630ED0[v334];
  pthread_mutex_lock((pthread_mutex_t *)(v330 + 584));
  if (*(_QWORD *)(v330 + 768) || *(_DWORD *)(v330 + 780) || *(_BYTE *)(v330 + 796))
  {
LABEL_414:
    db_rwlock_wait(v330 + 584, v336, 2);
  }
  else
  {
    if (v336 <= 5)
    {
      if (*(_QWORD *)(v330 + 16 * v336 + 648))
        goto LABEL_414;
      v474 = v336 - 1;
      v475 = (uint64_t *)(v330 + 16 * v336 + 664);
      while (v474 != 4)
      {
        v476 = *v475;
        v475 += 2;
        v477 = ++v474;
        if (v476)
        {
          if (v477 <= 4)
            goto LABEL_414;
          break;
        }
      }
    }
    *(_QWORD *)(v330 + 768) = pthread_self();
  }
  pthread_mutex_unlock((pthread_mutex_t *)(v330 + 584));
  _db2_flush_all_cache(v330, 0);
  v338 = *(unsigned int *)(v330 + 36);
  v337 = *(_DWORD *)(v330 + 40);
  v339 = (int8x16_t *)malloc_type_valloc(*(unsigned int *)(v331 + 44), 0xA3486755uLL);
  if (v339)
  {
    v340 = v339;
    v650 = v337;
    v680 = v333;
    if (!__kSIUINT32SetTypeID)
      __kSIUINT32SetTypeID = _CFRuntimeRegisterClass();
    v676 = v332;
    Instance = _CFRuntimeCreateInstance();
    *(_OWORD *)&v724.st_dev = 0uLL;
    v679 = v331;
    v342 = (stat *)internal_copy_field_ids(v331, "kMDItemEmbeddingVersion", (uint64_t)&v724, 4uLL, 0);
    if (v342)
    {
      v343 = v342;
      v344 = v342;
      if (v342->st_dev)
      {
        st_dev = v342->st_dev;
        p_st_mode = &v342->st_mode;
        do
        {
          v347 = p_st_mode;
          SIValueSet<unsigned int>::SIValueSetInsert((unsigned int *)(Instance + 16), st_dev);
          st_dev = *(unsigned int *)v347;
          p_st_mode = v347 + 2;
        }
        while (*(_DWORD *)v347);
      }
      v277 = v695;
      if (v343 != &v724)
        free(v344);
    }
    v348 = v340;
    v349 = v676;
    if (*v676)
    {
      v350 = 89;
      v297 = v696;
      v298 = v688;
      v351 = v680;
      v352 = v679;
      goto LABEL_593;
    }
    v355 = v650 + v338;
    v356 = 0;
    v297 = v696;
    v352 = v679;
    v677 = v340;
LABEL_430:
    v670 = v355;
    v357 = fd_pread(*(_DWORD **)(v352 + 848), v340, *(unsigned int *)(v352 + 44), v355);
    if (v357 <= 0)
    {
      v298 = v688;
      v351 = v680;
      if (v357 < 0)
        *(_DWORD *)(v352 + 4) |= 4u;
      v350 = v357;
    }
    else
    {
      if (v340->i32[0] != 846226020 && v340->i32[0] != 1684172850)
      {
        v380 = 1 << *(_DWORD *)(v352 + 12);
        goto LABEL_472;
      }
      if (!db2_page_uncompress_swap(v352, v340, &buf, 0))
      {
        if (buf.__first_)
          first = buf.__first_;
        else
          first = (std::__split_buffer<std::string>::pointer)v340;
        v360 = (int8x16_t *)first;
        v361 = *__error();
        v362 = _SILogForLogForCategory(7);
        v363 = 2 * (dword_1EF19FCA8 < 4);
        if (os_log_type_enabled(v362, v363))
        {
          v364 = v670 >> *(_DWORD *)(v679 + 12);
          data = (int)first->__r_.__value_.__l.__data_;
          v366 = HIDWORD(first->__r_.__value_.__r.__words[0]);
          v367 = first->__r_.__value_.__r.__words[1];
          v368 = HIDWORD(first->__r_.__value_.__r.__words[1]);
          handler.f_bsize = 67110144;
          handler.f_iosize = v364;
          LOWORD(handler.f_blocks) = 1024;
          *(_DWORD *)((char *)&handler.f_blocks + 2) = data;
          HIWORD(handler.f_blocks) = 1024;
          LODWORD(handler.f_bfree) = v366;
          WORD2(handler.f_bfree) = 1024;
          *(_DWORD *)((char *)&handler.f_bfree + 6) = v367;
          WORD1(handler.f_bavail) = 1024;
          HIDWORD(handler.f_bavail) = v368;
          _os_log_impl(&dword_1B8270000, v362, v363, "Read page:%d sig:0x%4.4x sz:0x%4.4x used:0x%4.4x flags:0x%4.4x", (uint8_t *)&handler, 0x20u);
        }
        *__error() = v361;
        if (LODWORD(first->__r_.__value_.__l.__data_) == 1684172850)
        {
          v277 = v695;
          v348 = v677;
          if ((first->__r_.__value_.__s.__data_[12] & 0xF0) == 0)
          {
            v369 = 0;
            v370 = v670 >> *(_DWORD *)(v679 + 12);
            v371 = *(_QWORD *)(v679 + 856);
            v372 = *(int *)(v371 + 8);
            if (v356 < v372 && v356 > -1)
              v369 = v356;
            if (v369 >= v372)
            {
LABEL_453:
              if (v369 >= 1)
              {
                v377 = (int *)(v371 + 28);
                v378 = 0;
                while (1)
                {
                  v379 = *v377;
                  v377 += 4;
                  if (v379 == (_DWORD)v370)
                    break;
                  if (v369 == ++v378)
                    goto LABEL_462;
                }
                v374 = v378;
                goto LABEL_461;
              }
            }
            else
            {
              v374 = v369;
              v375 = (int *)(v371 + 16 * v369 + 28);
              while (1)
              {
                v376 = *v375;
                v375 += 4;
                if (v376 == (_DWORD)v370)
                  break;
                if (v372 == ++v374)
                  goto LABEL_453;
              }
LABEL_461:
              v356 = v374 + 1;
            }
LABEL_462:
            v381 = (unsigned int *)&first->__r_.__value_.__r.__words[2] + 1;
            v382 = SLODWORD(first->__r_.__value_.__r.__words[1]);
            v383 = (char *)first + v382;
            if ((char *)&first->__r_.__value_.__r.__words[2] + HIDWORD(first->__r_.__value_.__r.__words[2]) + 4 <= (char *)first + v382
              && (int)v382 >= 21)
            {
              v666 = v356;
              v385 = 0;
              v386 = (unsigned int *)&first->__r_.__value_.__r.__words[2] + 1;
              v387 = 0;
              v388 = 0;
              v389 = v383;
              while (1)
              {
                v390 = v387;
                __dst = v381;
                if (*v386 == -4)
                {
                  v445 = v360;
                  v444 = v385;
                  v443 = v388;
                  v446 = (int)v381;
LABEL_526:
                  v340 = v445;
                  if ((v390 & 1) == 0)
                  {
                    v356 = v666;
                    v352 = v679;
                    goto LABEL_553;
                  }
                  v445->i32[2] = v446 - (_DWORD)v445;
                  v352 = v679;
                  v447 = *(_QWORD *)(v679 + 856);
                  v448 = *(_DWORD *)(v447 + 8);
                  if (!v448)
                  {
                    v356 = v666;
                    goto LABEL_553;
                  }
                  v449 = *(int *)(v447 + 16);
                  v356 = v666;
                  if ((int)v449 < v448)
                  {
                    v450 = v447 + 16 * v449;
                    if (*(_QWORD *)(v450 + 20) == v444 && v443 == *(_DWORD *)(v450 + 32) >> 28)
                      goto LABEL_552;
                  }
                  if (v448 < 1)
                  {
                    v459 = 0;
                    v457 = 0;
                    goto LABEL_548;
                  }
                  v451 = *(unsigned int *)(v447 + 8);
                  v452 = 0;
                  while (1)
                  {
                    if ((int)v451 + v452 < 0 != __OFADD__((_DWORD)v451, v452))
                      v453 = v451 + v452 + 1;
                    else
                      v453 = v451 + v452;
                    v454 = (v453 >> 1);
                    v455 = *(_DWORD *)(v447 + 16 * (int)v454 + 32);
                    if (v443 == v455 >> 28)
                      v456 = v444 - *(_QWORD *)(v447 + 16 * ((uint64_t)v453 >> 1) + 20);
                    else
                      v456 = (int)(v443 - (v455 >> 28));
                    v457 = v453 >> 1;
                    v458 = v454;
                    if ((v456 & 0x8000000000000000) == 0)
                    {
                      if (!v456)
                      {
                        v459 = 0;
LABEL_548:
                        v460 = v448 - 1 > v457 && v459;
                        v449 = v457 + v460;
                        *(_DWORD *)(v447 + 16) = v457 + v460;
LABEL_552:
                        page_release(v679, v445, *(_DWORD *)(v447 + 16 * v449 + 28), 5u, 0);
LABEL_553:
                        v348 = v677;
LABEL_468:
                        if (buf.__first_)
                        {
                          free(buf.__first_);
                          buf.__first_ = 0;
                          v340 = v348;
                        }
                        if ((~*(_DWORD *)(v352 + 4) & 0x60) == 0)
                          goto LABEL_572;
                        v380 = v340->i32[1];
LABEL_472:
                        v355 = v670 + v380;
                        if (*v349)
                        {
LABEL_572:
                          v350 = 89;
                          goto LABEL_586;
                        }
                        goto LABEL_430;
                      }
                      v452 = v454 + 1;
                      v458 = v451;
                    }
                    v451 = v458;
                    if (v452 >= (int)v458)
                    {
                      v459 = v456 > 0;
                      goto LABEL_548;
                    }
                  }
                }
                v658 = v389;
                ptr = (int *)v360;
                __p[0] = 0;
                v391 = _inflateDBO(v679, v386, __p, 0, 0x10000, 0);
                if (v391)
                {
                  v478 = v391;
                  v479 = *__error();
                  v480 = _SILogForLogForCategory(7);
                  v481 = os_log_type_enabled(v480, OS_LOG_TYPE_ERROR);
                  v482 = __p[0];
                  if (v481)
                  {
                    v633 = *v386;
                    handler.f_bsize = 136316418;
                    *(_QWORD *)&handler.f_iosize = "db2_clear_vector_fields";
                    WORD2(handler.f_blocks) = 1024;
                    *(_DWORD *)((char *)&handler.f_blocks + 6) = 9337;
                    WORD1(handler.f_bfree) = 2080;
                    *(uint64_t *)((char *)&handler.f_bfree + 4) = (uint64_t)__dst;
                    WORD2(handler.f_bavail) = 1024;
                    *(_DWORD *)((char *)&handler.f_bavail + 6) = v633 + 4;
                    WORD1(handler.f_files) = 2048;
                    *(void **)((char *)&handler.f_files + 4) = __p[0];
                    WORD2(handler.f_ffree) = 1024;
                    *(_DWORD *)((char *)&handler.f_ffree + 6) = v478;
                    _os_log_error_impl(&dword_1B8270000, v480, OS_LOG_TYPE_ERROR, "%s:%d: failed to inflate DBO: mark:%s size:%d mdbo:%p err:%d", (uint8_t *)&handler, 0x32u);
                  }
                  *__error() = v479;
                  v298 = v688;
                  v351 = v680;
                  if (v482)
                    free(v482);
                  v350 = 89;
                  v352 = v679;
                  v348 = v677;
                  goto LABEL_593;
                }
                v392 = *((_DWORD *)__p[0] + 3);
                if (v392 <= 0x2F)
                {
                  v636 = __si_assert_copy_extra_2151(0, -1);
                  v468 = v636;
                  v637 = "";
                  if (v636)
                    v637 = v636;
                  __message_assert("%s:%u: failed assertion '%s' %s ", "sdb2.c", 13332, "dbo->used_bytes >= sizeof(external_db_obj)", v637);
                  goto LABEL_563;
                }
                v393 = v385;
                v671 = Instance + 48;
                if (!v385)
                {
                  v393 = *(_QWORD *)__p[0];
                  if ((*(_BYTE *)(v679 + 804) & 1) != 0)
                    v388 = (*((_DWORD *)__p[0] + 10) >> 5) & 1;
                  else
                    v388 = 0;
                }
                v662 = v388;
                v661 = v393;
                if ((*((_BYTE *)__p[0] + 40) & 5) != 0 || v392 < 0x31)
                {
                  v417 = v390;
LABEL_506:
                  v390 = v417;
                  v418 = *v386 + 4;
                  if ((v417 & 1) != 0 && __dst != v386)
                    memmove(__dst, v386, *v386 + 4);
                  v419 = (unsigned int *)((char *)v386 + v418);
                  v420 = (char *)__dst + v418;
                  v421 = ptr;
                  v422 = (unint64_t)v658;
                  goto LABEL_522;
                }
                v394 = (unsigned int *)((char *)__p[0] + 48);
                v395 = 0;
                v396 = (unsigned int *)__p[0];
                v397 = (unsigned int *)__p[0];
                v398 = (unsigned int *)__p[0];
                v399 = (unsigned int *)((char *)__p[0] + 48);
                v400 = 0;
                v401 = v390;
LABEL_484:
                v651 = v395;
                v402 = v397;
                v403 = v398;
                do
                {
                  if ((~*((unsigned __int16 *)v399 + 1) & 0x5020) == 0 && *(_WORD *)v399 == 14)
                    goto LABEL_502;
                  if (!*(_BYTE *)(Instance + 176))
                  {
                    v406 = v399[1];
                    v407 = *(_DWORD *)(Instance + 20);
                    if (!v407 || !((*(_DWORD *)(Instance + 16) ^ v406) >> (-4 * v407)))
                    {
                      v408 = *(_QWORD *)(v671 + 8 * ((v406 >> (28 - 4 * v407)) & 0xF));
                      if ((v408 & 1) != 0)
                      {
                        v411 = v407 + 2;
                        v412 = *(_QWORD *)(v671 + 8 * ((v406 >> (28 - 4 * v407)) & 0xF));
                        do
                        {
                          v409 = 32 - 4 * v411;
                          v413 = *(_QWORD *)((v412 & 0xFFFFFFFFFFFFFFFELL) + 8 * ((v406 >> v409) & 0xF));
                          v412 = v413;
                          ++v411;
                        }
                        while ((v413 & 1) != 0);
                        v410 = v413;
                      }
                      else
                      {
                        v409 = 28 - 4 * v407;
                        v410 = v408;
                      }
                      if (v410
                        && (*(unsigned int (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v410 + 16))(v410, v406, ~(-1 << v409)))
                      {
                        v403 = v402;
LABEL_502:
                        v414 = v399[2];
                        v399 = (unsigned int *)((char *)v399 + v414 + 13);
                        v397 = v402;
                        v398 = v403;
                        v395 = v651 + v414 + 13;
                        v400 = 1;
                        v401 = 1;
                        if (v399 < (unsigned int *)((char *)v403 + v403[3]))
                          goto LABEL_484;
                        LODWORD(v405) = v403[3];
                        v390 = 1;
                        v415 = v651 + v414 + 13;
                        v416 = v403;
                        goto LABEL_510;
                      }
                    }
                  }
                  v404 = v399[2];
                  if (v394 != v399)
                  {
                    memmove(v394, v399, v404 + 13);
                    v401 = 1;
                    v396 = (unsigned int *)__p[0];
                    v400 = 1;
                  }
                  v399 = (unsigned int *)((char *)v399 + v404 + 13);
                  v394 = (unsigned int *)((char *)v394 + v394[2] + 13);
                  v405 = v396[3];
                  v402 = v396;
                  v403 = v396;
                }
                while (v399 < (unsigned int *)((char *)v396 + v405));
                v417 = v401;
                v416 = v396;
                v390 = v401;
                v415 = v651;
                if ((v400 & 1) == 0)
                  goto LABEL_506;
LABEL_510:
                v416[3] = v405 - v415;
                v423 = *v386 + 4;
                v424 = (char *)v386 + v423;
                v425 = v424;
                *(_QWORD *)&handler.f_bsize = 0;
                serializeDBO(v679);
                v426 = *(const void **)&handler.f_bsize;
                v427 = (**(_DWORD **)&handler.f_bsize + 4);
                v190 = v427 >= v423;
                v428 = v427 - v423;
                if (v428 != 0 && v190)
                {
                  v429 = ptr;
                  if (v428 > (int)v386 - (int)__dst)
                  {
                    v430 = ptr[1];
                    v431 = ptr[2];
                    v421 = ptr;
                    if (v430 < v431 + v428)
                    {
                      if (v428 <= 0x1000)
                        v432 = 4096;
                      else
                        v432 = v428;
                      v433 = v430 + v432;
                      ptr[1] = v433;
                      v434 = (std::string *)malloc_type_realloc(ptr, v433, 0x1F0C25BEuLL);
                      v429 = ptr;
                      v421 = (int *)v434;
                      buf.__first_ = v434;
                      v431 = v434->__r_.__value_.__r.__words[1];
                    }
                    v435 = v424 - (char *)v429;
                    v436 = (char *)v421 + v424 - (char *)v429;
                    v437 = (char *)v421 + (char *)__dst - (char *)v429;
                    v425 = &v436[v428];
                    memmove(v425, v436, v431 - v435 + 20);
                    v438 = v421[2] + v428;
                    v439 = (char *)v421 + v438;
                    v426 = *(const void **)&handler.f_bsize;
                    v421[2] = v438;
                    v440 = (unsigned int *)v437;
                    goto LABEL_521;
                  }
                  v421 = ptr;
                }
                else
                {
                  v421 = ptr;
                }
                v439 = v658;
                v440 = __dst;
LABEL_521:
                v422 = (unint64_t)v439;
                memmove(v440, v426, v427);
                free(*(void **)&handler.f_bsize);
                v420 = (char *)v440 + v427;
                v419 = (unsigned int *)v425;
LABEL_522:
                v441 = v419;
                v442 = (unsigned int *)v420;
                free(__p[0]);
                v381 = v442;
                v443 = v662;
                v388 = v662;
                v444 = v661;
                v385 = v661;
                v387 = v390;
                v389 = (char *)v422;
                v386 = v441;
                v360 = (int8x16_t *)v421;
                v445 = (int8x16_t *)v421;
                v446 = (int)v442;
                v190 = (unint64_t)v441 >= v422;
                v297 = v696;
                v277 = v695;
                v305 = allocator;
                v349 = v676;
                if (v190)
                  goto LABEL_526;
              }
            }
          }
        }
        else
        {
          v348 = v677;
          v277 = v695;
          if (v677->i32[0] != 1684172850)
          {
            v352 = v679;
            v677->i32[1] = *(_DWORD *)(v679 + 44);
            v340 = v360;
            goto LABEL_468;
          }
        }
        v340 = (int8x16_t *)first;
        v352 = v679;
        goto LABEL_468;
      }
      v350 = 0;
LABEL_586:
      v298 = v688;
      v351 = v680;
    }
LABEL_593:
    if (buf.__first_)
      free(buf.__first_);
    free(v348);
    pthread_mutex_lock(v351);
    *(_DWORD *)(v352 + 788) = 0;
    v483 = *(pthread_override_s **)(v352 + 760);
    *(_QWORD *)(v352 + 768) = 0;
    *(_QWORD *)(v352 + 760) = 0;
    v484 = *(_DWORD *)(v352 + 780) != 0;
    *(_BYTE *)(v352 + 796) = 0;
    db_rwlock_wakeup((uint64_t)v351, v484, 0);
    pthread_mutex_unlock(v351);
    if (v483)
      pthread_override_qos_class_end_np(v483);
    if (!v350)
    {
      v485 = *__error();
      v486 = _SILogForLogForCategory(16);
      v487 = dword_1EF19FCCC < 3;
      if (os_log_type_enabled(v486, (os_log_type_t)(dword_1EF19FCCC < 3)))
      {
        LOWORD(handler.f_bsize) = 0;
        _os_log_impl(&dword_1B8270000, v486, v487, "*warn* Reset vector indexes", (uint8_t *)&handler, 2u);
      }
      *__error() = v485;
      v488 = *(_QWORD *)(v297 + 1392);
      v489 = *(_QWORD *)(v297 + 1384);
      if (v488 && *(_DWORD *)(v488 + 8))
      {
        v490 = 0;
        do
        {
          v491 = v490;
          ContentIndexResetVectorIndex(*(_QWORD *)(*(_QWORD *)v488 + 8 * v490));
          v490 = v491 + 1;
        }
        while (v491 + 1 < (unint64_t)*(unsigned int *)(v488 + 8));
      }
      if (v489 && *(_DWORD *)(v489 + 8))
      {
        v492 = 0;
        do
        {
          v493 = v492;
          ContentIndexResetVectorIndex(*(_QWORD *)(*(_QWORD *)v489 + 8 * v492));
          v492 = v493 + 1;
        }
        while (v493 + 1 < (unint64_t)*(unsigned int *)(v489 + 8));
      }
      _si_set_version_property(v297, CFSTR("VEC_EXT_CLEARED_VECTORS"), 1);
    }
  }
  else
  {
    pthread_mutex_lock(v333);
    *(_DWORD *)(v331 + 788) = 0;
    v353 = *(pthread_override_s **)(v331 + 760);
    *(_QWORD *)(v331 + 768) = 0;
    *(_QWORD *)(v331 + 760) = 0;
    v354 = *(_DWORD *)(v331 + 780) != 0;
    *(_BYTE *)(v331 + 796) = 0;
    db_rwlock_wakeup((uint64_t)v333, v354, 0);
    pthread_mutex_unlock(v333);
    if (v353)
      pthread_override_qos_class_end_np(v353);
    v297 = v696;
  }
LABEL_609:
  db_set_ignore_vectors(*(_QWORD *)(v297 + 1184), 1);
LABEL_610:
  LODWORD(__p[0]) = 0;
  if (!fd_setDir(*(unsigned int *)(v297 + 32), (int *)__p))
    goto LABEL_749;
  bzero(&handler, 0x400uLL);
  v494 = *(_DWORD *)(v297 + 2344);
  v669 = v494;
  v681 = *(_DWORD *)(v297 + 2348);
  v495 = v494 + 1;
  while (v495 != 0x7FFFFFFF)
  {
    if (snprintf((char *)&handler, 0x400uLL, "%s%d", "journalAttr.", v495) >= 0x400)
    {
      v612 = __si_assert_copy_extra_521(-1);
      v468 = v612;
      v613 = "";
      if (v612)
        v613 = v612;
      __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 5565, "0 <= count && count < pathBufferSize", v613);
      goto LABEL_563;
    }
    memset(&v724, 0, sizeof(v724));
    v496 = stat((const char *)&handler, &v724);
    v497 = ++v495;
    if (v496)
    {
      v498 = v497 - 2;
      goto LABEL_617;
    }
  }
  v498 = 2147483646;
LABEL_617:
  v499 = v494 - 1;
  v500 = -2147483647;
  v654 = v498;
  while (2)
  {
    if (v494 == v500)
    {
      v504 = 0x80000000;
      v503 = -2147483647;
      goto LABEL_623;
    }
    if (snprintf((char *)&handler, 0x400uLL, "%s%d", "journalAttr.", v499) >= 0x400)
    {
      v614 = __si_assert_copy_extra_521(-1);
      v462 = v614;
      v615 = "";
      if (v614)
        v615 = v614;
      v647 = "0 <= count && count < pathBufferSize";
      v648 = v615;
      v464 = 5577;
      goto LABEL_568;
    }
    memset(&v724, 0, sizeof(v724));
    v501 = stat((const char *)&handler, &v724);
    v502 = --v499;
    ++v500;
    if (!v501)
      continue;
    break;
  }
  v503 = v502 + 2;
  v504 = v502 + 1;
LABEL_623:
  v657 = v504;
  v505 = v681;
  v506 = v681;
  if (!*(_BYTE *)(v297 + 2072))
    goto LABEL_637;
  v507 = v681 + 1;
  do
  {
    if (v507 == 0x7FFFFFFF)
    {
      v506 = 2147483646;
      goto LABEL_630;
    }
    if (snprintf((char *)&handler, 0x400uLL, "%s%d", "deferAttr.", v507) >= 0x400)
    {
      v619 = __si_assert_copy_extra_521(-1);
      v468 = v619;
      v620 = "";
      if (v619)
        v620 = v619;
      __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 5591, "0 <= count && count < pathBufferSize", v620);
      goto LABEL_563;
    }
    memset(&v724, 0, sizeof(v724));
    v508 = stat((const char *)&handler, &v724);
    v509 = ++v507;
  }
  while (!v508);
  v506 = v509 - 2;
LABEL_630:
  v510 = v681 - 1;
  v511 = v681 + 0x7FFFFFFF;
  while (v511)
  {
    if (snprintf((char *)&handler, 0x400uLL, "%s%d", "deferAttr.", v510) >= 0x400)
    {
      v621 = __si_assert_copy_extra_521(-1);
      v462 = v621;
      v622 = "";
      if (v621)
        v622 = v621;
      v647 = "0 <= count && count < pathBufferSize";
      v648 = v622;
      v464 = 5603;
      goto LABEL_568;
    }
    memset(&v724, 0, sizeof(v724));
    v512 = stat((const char *)&handler, &v724);
    v513 = --v510;
    --v511;
    if (v512)
    {
      v505 = v513 + 2;
      goto LABEL_636;
    }
  }
  v505 = -2147483647;
LABEL_636:
  v297 = v696;
LABEL_637:
  v667 = v506;
  v514 = *(char **)(v297 + 6952);
  v668 = v505;
  if (!v514)
  {
    v514 = (char *)fd_create_protected(*(_DWORD *)(v297 + 32), "journalRepair.1", 0, 0);
    if (!v514)
    {
      v515 = 0;
      v523 = v503;
      v517 = v654;
      goto LABEL_651;
    }
  }
  memset(&v724, 0, sizeof(v724));
  if (fd_stat((uint64_t)v514, &v724))
  {
    v515 = v514;
    v516 = v503;
    v517 = v654;
    goto LABEL_650;
  }
  v518 = *__error();
  v519 = _SILogForLogForCategory(0);
  v520 = v503;
  v517 = v654;
  if (os_log_type_enabled(v519, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf.__first_) = 136316162;
    *(std::__split_buffer<std::string>::pointer *)((char *)&buf.__first_ + 4) = (std::__split_buffer<std::string>::pointer)"journalRepair.1";
    WORD2(buf.__begin_) = 2048;
    *(std::__split_buffer<std::string>::pointer *)((char *)&buf.__begin_ + 6) = (std::__split_buffer<std::string>::pointer)v724.st_size;
    HIWORD(buf.__end_) = 1024;
    LODWORD(buf.__end_cap_.__value_) = v494;
    WORD2(buf.__end_cap_.__value_) = 1024;
    *(_DWORD *)((char *)&buf.__end_cap_.__value_ + 6) = v520;
    WORD1(buf.__end_cap_.__value_) = 1024;
    HIDWORD(buf.__end_cap_.__value_) = v654;
    _os_log_impl(&dword_1B8270000, v519, OS_LOG_TYPE_DEFAULT, "Found %s, size:%lld, syncCount:%d, first:%d, last:%d", (uint8_t *)&buf, 0x28u);
  }
  *__error() = v518;
  if (!v724.st_size)
  {
    _fd_unlink_with_origin((uint64_t)v514, 0);
    fd_release(v514);
    v515 = 0;
    v516 = v520;
    goto LABEL_650;
  }
  if (snprintf((char *)&handler, 0x400uLL, "%s%d", "journalAttr.", v657) >= 0x400)
  {
    v642 = __si_assert_copy_extra_521(-1);
    v468 = v642;
    v643 = "";
    if (v642)
      v643 = v642;
    __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 5631, "0 <= count && count < pathBufferSize", v643);
    goto LABEL_563;
  }
  v521 = *__error();
  v522 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v522, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf.__first_) = 136316162;
    *(std::__split_buffer<std::string>::pointer *)((char *)&buf.__first_ + 4) = (std::__split_buffer<std::string>::pointer)"journalRepair.1";
    WORD2(buf.__begin_) = 2080;
    *(std::__split_buffer<std::string>::pointer *)((char *)&buf.__begin_ + 6) = (std::__split_buffer<std::string>::pointer)&handler;
    HIWORD(buf.__end_) = 1024;
    LODWORD(buf.__end_cap_.__value_) = v494;
    WORD2(buf.__end_cap_.__value_) = 1024;
    *(_DWORD *)((char *)&buf.__end_cap_.__value_ + 6) = v657;
    WORD1(buf.__end_cap_.__value_) = 1024;
    HIDWORD(buf.__end_cap_.__value_) = v654;
    _os_log_impl(&dword_1B8270000, v522, OS_LOG_TYPE_DEFAULT, "Moving %s to %s, syncCount:%d, first:%d, last:%d", (uint8_t *)&buf, 0x28u);
  }
  *__error() = v521;
  fd_rename((uint64_t)v514, (const char *)&handler);
  v515 = v514;
  v516 = v657;
LABEL_650:
  v523 = v516;
LABEL_651:
  if (v517 == v494 || v523 == v494)
  {
    if (snprintf((char *)&handler, 0x400uLL, "%s%d", "journalAttr.", v494) >= 0x400)
    {
      v638 = __si_assert_copy_extra_521(-1);
      v462 = v638;
      v639 = "";
      if (v638)
        v639 = v638;
      v647 = "0 <= count && count < pathBufferSize";
      v648 = v639;
      v464 = 5641;
      goto LABEL_568;
    }
    memset(&v724, 0, sizeof(v724));
    v525 = stat((const char *)&handler, &v724);
    if (v525)
      v526 = v517 == v494;
    else
      v526 = 0;
    if (v525)
      v527 = v523 == v494;
    else
      v527 = 0;
    v517 -= v526;
    v524 = v523 + v527;
  }
  else
  {
    v524 = v523;
  }
  v673 = *(_QWORD *)(v297 + 2128);
  v672 = *(_QWORD *)(v297 + 2136);
  v528 = *__error();
  v529 = _SILogForLogForCategory(0);
  v530 = os_log_type_enabled(v529, OS_LOG_TYPE_DEFAULT);
  v656 = v517;
  v531 = v517 - v524;
  if (v517 >= v524)
  {
    if (v530)
    {
      v724.st_dev = 67110656;
      *(_DWORD *)&v724.st_mode = v531 + 1;
      LOWORD(v724.st_ino) = 2048;
      *(__darwin_ino64_t *)((char *)&v724.st_ino + 2) = v297;
      HIWORD(v724.st_uid) = 1024;
      v724.st_gid = v494;
      LOWORD(v724.st_rdev) = 1024;
      *(dev_t *)((char *)&v724.st_rdev + 2) = v524;
      *((_WORD *)&v724.st_rdev + 3) = 1024;
      LODWORD(v724.st_atimespec.tv_sec) = v517;
      WORD2(v724.st_atimespec.tv_sec) = 2048;
      *(__darwin_time_t *)((char *)&v724.st_atimespec.tv_sec + 6) = v673;
      HIWORD(v724.st_atimespec.tv_nsec) = 2048;
      v724.st_mtimespec.tv_sec = v672;
      _os_log_impl(&dword_1B8270000, v529, OS_LOG_TYPE_DEFAULT, "Replaying %d journals for %p, syncCount:%d, first:%d, last:%d, journalSerialNumber:%lld, consumedJournalSerialNumber:%lld", (uint8_t *)&v724, 0x38u);
    }
    *__error() = v528;
    if (v517 >= *(_DWORD *)(v297 + 2344))
      *(_DWORD *)(v297 + 2344) = v517 + 1;
    v534 = 0;
    v653 = v531 + 1;
    v535 = -1;
    while (snprintf((char *)&handler, 0x400uLL, "%s%d", "journalAttr.", v524 + v534) < 0x400)
    {
      if (v515 && (v536 = v515, !v534)
        || (v536 = (char *)fd_create_protected(*(_DWORD *)(v696 + 32), (const char *)&handler, 0, 0)) != 0)
      {
        v537 = *__error();
        v538 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v538, OS_LOG_TYPE_DEFAULT))
        {
          v724.st_dev = 136315906;
          *(_QWORD *)&v724.st_mode = &handler;
          WORD2(v724.st_ino) = 1024;
          *(_DWORD *)((char *)&v724.st_ino + 6) = v669;
          HIWORD(v724.st_uid) = 1024;
          v724.st_gid = v524;
          LOWORD(v724.st_rdev) = 1024;
          *(dev_t *)((char *)&v724.st_rdev + 2) = v656;
          _os_log_impl(&dword_1B8270000, v538, OS_LOG_TYPE_DEFAULT, "Replaying %s, syncCount:%d, first:%d, last:%d", (uint8_t *)&v724, 0x1Eu);
        }
        *__error() = v537;
        v539 = si_playbackJournal(v696, (uint64_t)v536);
        if (v535 <= v539)
          v540 = v539;
        else
          v540 = v535;
        v541 = v536;
        v297 = v696;
        fd_release(v541);
        v532 = v540;
      }
      else
      {
        v542 = *__error();
        v543 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v543, OS_LOG_TYPE_DEFAULT))
        {
          v724.st_dev = 136315906;
          *(_QWORD *)&v724.st_mode = &handler;
          WORD2(v724.st_ino) = 1024;
          *(_DWORD *)((char *)&v724.st_ino + 6) = v669;
          HIWORD(v724.st_uid) = 1024;
          v724.st_gid = v524;
          LOWORD(v724.st_rdev) = 1024;
          *(dev_t *)((char *)&v724.st_rdev + 2) = v656;
          _os_log_impl(&dword_1B8270000, v543, OS_LOG_TYPE_DEFAULT, "Missing %s, syncCount:%d, first:%d, last:%d", (uint8_t *)&v724, 0x1Eu);
        }
        *__error() = v542;
        v532 = v535;
        v297 = v696;
      }
      ++v534;
      v535 = v532;
      if (v653 == v534)
      {
        v533 = v524;
        goto LABEL_686;
      }
    }
    v616 = __si_assert_copy_extra_521(-1);
    v462 = v616;
    v617 = "";
    if (v616)
      v617 = v616;
    v647 = "0 <= count && count < pathBufferSize";
    v648 = v617;
    v464 = 5667;
LABEL_568:
    __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", v464, v647, v648);
    free(v462);
    if (!__valid_fs(-1))
    {
      v473 = 3072;
LABEL_571:
      *(_DWORD *)v473 = -559038737;
      abort();
    }
LABEL_569:
    v473 = 2989;
    goto LABEL_571;
  }
  if (v530)
  {
    v724.st_dev = 134219264;
    *(_QWORD *)&v724.st_mode = v297;
    WORD2(v724.st_ino) = 1024;
    *(_DWORD *)((char *)&v724.st_ino + 6) = v494;
    HIWORD(v724.st_uid) = 1024;
    v724.st_gid = v524;
    LOWORD(v724.st_rdev) = 1024;
    *(dev_t *)((char *)&v724.st_rdev + 2) = v517;
    *((_WORD *)&v724.st_rdev + 3) = 2048;
    v724.st_atimespec.tv_sec = v673;
    LOWORD(v724.st_atimespec.tv_nsec) = 2048;
    *(uint64_t *)((char *)&v724.st_atimespec.tv_nsec + 2) = v672;
    _os_log_impl(&dword_1B8270000, v529, OS_LOG_TYPE_DEFAULT, "No journals to replay for %p, syncCount:%d, first:%d, last:%d, journalSerialNumber:%lld, consumedJournalSerialNumber:%lld", (uint8_t *)&v724, 0x32u);
  }
  *__error() = v528;
  v532 = -1;
  v533 = v517;
LABEL_686:
  v659 = v532;
  v277 = v695;
  if (v689)
  {
    v544 = CFArrayGetCount(v689);
    if (v544 >= 1)
    {
      v545 = v544;
      for (n = 0; n != v545; ++n)
      {
        v547 = CFArrayGetValueAtIndex(v689, n);
        if ((unint64_t)v547 < v533)
        {
          v548 = (int)v547;
          snprintf((char *)&handler, 0x400uLL, "%s%d", "journalAttr.", (_DWORD)v547);
          v549 = *__error();
          v550 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v550, OS_LOG_TYPE_DEFAULT))
          {
            v724.st_dev = 136315138;
            *(_QWORD *)&v724.st_mode = &handler;
            _os_log_impl(&dword_1B8270000, v550, OS_LOG_TYPE_DEFAULT, "Unlinking dropped file %s", (uint8_t *)&v724, 0xCu);
          }
          *__error() = v549;
          unlink((const char *)&handler);
          snprintf((char *)&handler, 0x400uLL, "%s%d_toc", "journalAttr.", v548);
          v551 = *__error();
          v552 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v552, OS_LOG_TYPE_DEFAULT))
          {
            v724.st_dev = 136315138;
            *(_QWORD *)&v724.st_mode = &handler;
            _os_log_impl(&dword_1B8270000, v552, OS_LOG_TYPE_DEFAULT, "Unlinking dropped file %s", (uint8_t *)&v724, 0xCu);
          }
          *__error() = v551;
          unlink((const char *)&handler);
          v297 = v696;
          v277 = v695;
        }
      }
    }
  }
  v298 = v688;
  if (*(_BYTE *)(v297 + 2072))
  {
    if (v667 != v681 && v668 != v681)
    {
      v553 = v667;
      v554 = v668;
      goto LABEL_708;
    }
    if (snprintf((char *)&handler, 0x400uLL, "%s%d", "deferAttr.", v681) >= 0x400)
    {
      v640 = __si_assert_copy_extra_521(-1);
      v468 = v640;
      v641 = "";
      if (v640)
        v641 = v640;
      __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 5707, "0 <= count && count < pathBufferSize", v641);
    }
    else
    {
      memset(&v724, 0, sizeof(v724));
      v555 = stat((const char *)&handler, &v724);
      if (v555)
        v556 = v667 == v681;
      else
        v556 = 0;
      if (v555)
        v557 = v668 == v681;
      else
        v557 = 0;
      v553 = v667 - v556;
      v554 = v668 + v557;
LABEL_708:
      v558 = v659;
      v559 = v554;
      v560 = v553;
      v561 = *__error();
      v562 = _SILogForLogForCategory(0);
      v563 = os_log_type_enabled(v562, OS_LOG_TYPE_DEFAULT);
      if (v560 < v559)
      {
        if (v563)
        {
          v724.st_dev = 134219264;
          *(_QWORD *)&v724.st_mode = v297;
          WORD2(v724.st_ino) = 1024;
          *(_DWORD *)((char *)&v724.st_ino + 6) = v681;
          HIWORD(v724.st_uid) = 1024;
          v724.st_gid = v559;
          LOWORD(v724.st_rdev) = 1024;
          *(dev_t *)((char *)&v724.st_rdev + 2) = v560;
          *((_WORD *)&v724.st_rdev + 3) = 2048;
          v724.st_atimespec.tv_sec = v673;
          LOWORD(v724.st_atimespec.tv_nsec) = 2048;
          *(uint64_t *)((char *)&v724.st_atimespec.tv_nsec + 2) = v672;
          _os_log_impl(&dword_1B8270000, v562, OS_LOG_TYPE_DEFAULT, "No defer journals to replay for %p, deferSyncCount:%d, first:%d, last:%d, journalSerialNumber:%lld, consumedJournalSerialNumber:%lld", (uint8_t *)&v724, 0x32u);
        }
        *__error() = v561;
        v564 = v560;
LABEL_730:
        if (v692)
        {
          v573 = CFArrayGetCount(v692);
          if (v573 >= 1)
          {
            v574 = v573;
            for (ii = 0; ii != v574; ++ii)
            {
              v576 = CFArrayGetValueAtIndex(v692, ii);
              if ((unint64_t)v576 < v564)
              {
                v577 = (int)v576;
                snprintf((char *)&handler, 0x400uLL, "%s%d", "deferAttr.", (_DWORD)v576);
                v578 = *__error();
                v579 = _SILogForLogForCategory(0);
                if (os_log_type_enabled(v579, OS_LOG_TYPE_DEFAULT))
                {
                  v724.st_dev = 136315138;
                  *(_QWORD *)&v724.st_mode = &handler;
                  _os_log_impl(&dword_1B8270000, v579, OS_LOG_TYPE_DEFAULT, "Unlinking dropped file %s", (uint8_t *)&v724, 0xCu);
                }
                *__error() = v578;
                unlink((const char *)&handler);
                snprintf((char *)&handler, 0x400uLL, "%s%d_toc", "deferAttr.", v577);
                v580 = *__error();
                v581 = _SILogForLogForCategory(0);
                if (os_log_type_enabled(v581, OS_LOG_TYPE_DEFAULT))
                {
                  v724.st_dev = 136315138;
                  *(_QWORD *)&v724.st_mode = &handler;
                  _os_log_impl(&dword_1B8270000, v581, OS_LOG_TYPE_DEFAULT, "Unlinking dropped file %s", (uint8_t *)&v724, 0xCu);
                }
                *__error() = v580;
                unlink((const char *)&handler);
                v297 = v696;
                v277 = v695;
              }
            }
          }
        }
        v582 = v672;
        if (v558 > v672)
          v582 = v558;
        v583 = v673;
        if (v673 <= v582)
        {
          v584 = v582 + 1;
          *(_QWORD *)(v297 + 2128) = v584;
          v583 = v584;
        }
        v585 = *__error();
        v586 = _SILogForLogForCategory(0);
        v298 = v688;
        if (os_log_type_enabled(v586, OS_LOG_TYPE_DEFAULT))
        {
          v724.st_dev = 134218240;
          *(_QWORD *)&v724.st_mode = v583;
          WORD2(v724.st_ino) = 2048;
          *(__darwin_ino64_t *)((char *)&v724.st_ino + 6) = v672;
          _os_log_impl(&dword_1B8270000, v586, OS_LOG_TYPE_DEFAULT, "journalSerialNumber:%lld, consumedJournalSerialNumber:%lld", (uint8_t *)&v724, 0x16u);
        }
        *__error() = v585;
        goto LABEL_747;
      }
      if (v563)
      {
        v724.st_dev = 67110656;
        *(_DWORD *)&v724.st_mode = v560 - v559 + 1;
        LOWORD(v724.st_ino) = 2048;
        *(__darwin_ino64_t *)((char *)&v724.st_ino + 2) = v297;
        HIWORD(v724.st_uid) = 1024;
        v724.st_gid = v681;
        LOWORD(v724.st_rdev) = 1024;
        *(dev_t *)((char *)&v724.st_rdev + 2) = v559;
        *((_WORD *)&v724.st_rdev + 3) = 1024;
        LODWORD(v724.st_atimespec.tv_sec) = v560;
        WORD2(v724.st_atimespec.tv_sec) = 2048;
        *(__darwin_time_t *)((char *)&v724.st_atimespec.tv_sec + 6) = v673;
        HIWORD(v724.st_atimespec.tv_nsec) = 2048;
        v724.st_mtimespec.tv_sec = v672;
        _os_log_impl(&dword_1B8270000, v562, OS_LOG_TYPE_DEFAULT, "Replaying %d defer journals for %p, syncCount:%d, first:%d, last:%d, journalSerialNumber:%lld, consumedJournalSerialNumber:%lld", (uint8_t *)&v724, 0x38u);
      }
      *__error() = v561;
      if (v560 >= *(_DWORD *)(v297 + 2348))
        *(_DWORD *)(v297 + 2348) = v560 + 1;
      v565 = v559;
      while (snprintf((char *)&handler, 0x400uLL, "%s%d", "deferAttr.", v565) < 0x400)
      {
        v566 = (char *)fd_create_protected(*(_DWORD *)(v297 + 32), (const char *)&handler, 0, 0);
        v567 = *__error();
        v568 = _SILogForLogForCategory(0);
        v569 = os_log_type_enabled(v568, OS_LOG_TYPE_DEFAULT);
        if (v566)
        {
          if (v569)
          {
            v724.st_dev = 136315906;
            *(_QWORD *)&v724.st_mode = &handler;
            WORD2(v724.st_ino) = 1024;
            *(_DWORD *)((char *)&v724.st_ino + 6) = v681;
            HIWORD(v724.st_uid) = 1024;
            v724.st_gid = v559;
            LOWORD(v724.st_rdev) = 1024;
            *(dev_t *)((char *)&v724.st_rdev + 2) = v560;
            _os_log_impl(&dword_1B8270000, v568, OS_LOG_TYPE_DEFAULT, "Replaying %s, syncCount:%d, first:%d, last:%d", (uint8_t *)&v724, 0x1Eu);
          }
          *__error() = v567;
          v297 = v696;
          v570 = si_playbackJournal(v696, (uint64_t)v566);
          if (v558 <= v570)
            v571 = v570;
          else
            v571 = v558;
          fd_release(v566);
          v572 = v571;
        }
        else
        {
          if (v569)
          {
            v724.st_dev = 136315906;
            *(_QWORD *)&v724.st_mode = &handler;
            WORD2(v724.st_ino) = 1024;
            *(_DWORD *)((char *)&v724.st_ino + 6) = v681;
            HIWORD(v724.st_uid) = 1024;
            v724.st_gid = v559;
            LOWORD(v724.st_rdev) = 1024;
            *(dev_t *)((char *)&v724.st_rdev + 2) = v560;
            _os_log_impl(&dword_1B8270000, v568, OS_LOG_TYPE_DEFAULT, "Missing %s, syncCount:%d, first:%d, last:%d", (uint8_t *)&v724, 0x1Eu);
          }
          *__error() = v567;
          v572 = v558;
          v297 = v696;
        }
        ++v565;
        v558 = v572;
        if (v560 + 1 == v565)
        {
          v558 = v572;
          v564 = v559;
          v277 = v695;
          goto LABEL_730;
        }
      }
      v623 = __si_assert_copy_extra_521(-1);
      v468 = v623;
      v624 = "";
      if (v623)
        v624 = v623;
      __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 5729, "0 <= count && count < pathBufferSize", v624);
    }
LABEL_563:
    free(v468);
    if (__valid_fs(-1))
      v470 = 2989;
    else
      v470 = 3072;
    *(_DWORD *)v470 = -559038737;
    abort();
  }
LABEL_747:
  v587 = (int)__p[0];
  MEMORY[0x1BCCB1484](LODWORD(__p[0]));
  v305 = allocator;
  if ((v587 & 0x80000000) == 0)
    close(v587);
LABEL_749:
  if (_os_feature_enabled_impl())
  {
    v588 = *(_QWORD *)(v297 + 1048);
    aBlock[0] = MEMORY[0x1E0C809B0];
    aBlock[1] = 0x40000000;
    aBlock[2] = __SIInitIndex_block_invoke_866;
    aBlock[3] = &__block_descriptor_tmp_867;
    aBlock[4] = v297;
    si_enqueue_block(v588, aBlock);
  }
LABEL_751:
  if (*(_BYTE *)(v297 + 2072) && (clientstates_file = (const __CFDictionary *)si_read_clientstates_file(v297)) != 0)
  {
    v590 = clientstates_file;
    v591 = (const __CFString *)CFDictionaryGetValue(clientstates_file, CFSTR("journalName"));
    if (v591)
    {
      v592 = v591;
      v593 = CFRetain(v591);
      SIReleaseJournalAssertion(v297, v592);
      v594 = v593;
    }
    else
    {
      v594 = 0;
      SIReleaseJournalAssertion(v297, 0);
    }
    CFRelease(v590);
    v595 = v594;
  }
  else
  {
    v595 = 0;
  }
  v698 = 0;
  v698 = *(_QWORD *)(v297 + 2128);
  v596 = CFNumberCreate(v305, kCFNumberSInt64Type, &v698);
  if (v596)
  {
    v597 = v596;
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(v297 + 72), CFSTR("journalSerialNumber"), v596);
    CFRelease(v597);
  }
  v598 = CFNumberCreate(v305, kCFNumberIntType, (const void *)(v297 + 2344));
  if (v598)
  {
    v599 = v598;
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(v297 + 72), CFSTR("syncCount"), v598);
    CFRelease(v599);
  }
  v600 = CFNumberCreate(v305, kCFNumberIntType, (const void *)(v297 + 2348));
  if (v600)
  {
    v601 = v600;
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(v297 + 72), CFSTR("deferSyncCount"), v600);
    CFRelease(v601);
  }
  if (v595)
  {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(v297 + 72), CFSTR("journalName"), v595);
    CFRelease(v595);
  }
  v602 = (const __CFUUID *)si_storecookieRef(v297);
  v603 = CFUUIDCreateString(v305, v602);
  if (v603)
  {
    v604 = v603;
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(v297 + 72), CFSTR("cookie"), v603);
    CFRelease(v604);
  }
  SIPersistClientStateAndMeta(v297, 1);
  if (!v298)
    si_enqueue_barrier(*(_QWORD *)(v297 + 1048), (uint64_t)resumeHoldQueue, *(_QWORD *)(*(_QWORD *)(v297 + 1152) + 16));
  v605 = (const __CFNumber *)SICopyProperty(v297, CFSTR("YukonRecomputedSizes"));
  if (v605)
  {
    v606 = v605;
    handler.f_bsize = 0;
    CFNumberGetValue(v605, kCFNumberIntType, &handler);
    f_bsize = handler.f_bsize;
    CFRelease(v606);
    if ((v277 & 0x800) == 0 && f_bsize < 2)
    {
LABEL_773:
      v697[0] = MEMORY[0x1E0C809B0];
      v697[1] = 0x40000000;
      v697[2] = __SIInitIndex_block_invoke_2_868;
      v697[3] = &__block_descriptor_tmp_869;
      v697[4] = v297;
      _SIRecomputeSizesWithCallback(v297, 0, v697);
    }
  }
  else if ((v277 & 0x800) == 0)
  {
    goto LABEL_773;
  }
  v608 = *(_QWORD *)&threadData[18 * v708 + 2];
  v609 = v707;
  v610 = v608 + 320 * v707;
  *(_DWORD *)(v610 + 312) = v693;
  v611 = *(void (**)(_QWORD))(v610 + 232);
  if (v611)
    v611(*(_QWORD *)(v608 + 320 * v609 + 288));
  dropThreadId(v708, 0, v694);
  if (!v691 && !a9 && !*(_QWORD *)(v297 + 6624))
  {
    v634 = __si_assert_copy_extra_521(-1);
    v468 = v634;
    v635 = "";
    if (v634)
      v635 = v634;
    __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 14374, "fs_only||newIndex->dirStore || rebuildDirStore", v635);
    goto LABEL_563;
  }
  if (gTerminating)
  {
    _si_set_error_str("process terminating");
    return 4294967293;
  }
  else
  {
    si_scheduler_resume(*(_QWORD *)(v297 + 864), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 14432);
    si_scheduler_resume(*(_QWORD *)(v297 + 944), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 14433);
    return 0;
  }
}

void _si_set_version_property(uint64_t a1, const void *a2, int a3)
{
  CFNumberRef v6;
  uint64_t valuePtr;

  valuePtr = 5;
  v6 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberCFIndexType, &valuePtr);
  si_set_property(a1, a2, v6, 1, a3);
  CFRelease(v6);
}

uint64_t si_cacheIndexVersion(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD v7[2];
  uint64_t (*v8)(uint64_t, uint64_t);
  void *v9;
  uint64_t v10;

  v1 = *(_QWORD *)(result + 1392);
  v2 = *(_QWORD *)(result + 1384);
  v7[0] = MEMORY[0x1E0C809B0];
  v7[1] = 0x40000000;
  v8 = __si_cacheIndexVersion_block_invoke;
  v9 = &__block_descriptor_tmp_846;
  v10 = result;
  if (v2)
  {
    v3 = *(unsigned int *)(v2 + 8);
    while ((int)v3 >= 1)
    {
      v4 = v3 - 1;
      result = ((uint64_t (*)(_QWORD *, _QWORD, uint64_t))v8)(v7, *(_QWORD *)(*(_QWORD *)v2 + 8 * v3 - 8), 1);
      v3 = v4;
      if (!(_DWORD)result)
        return result;
    }
  }
  if (v1)
  {
    v5 = *(unsigned int *)(v1 + 8);
    do
    {
      if ((int)v5 < 1)
        break;
      v6 = v5 - 1;
      result = ((uint64_t (*)(_QWORD *, _QWORD, _QWORD))v8)(v7, *(_QWORD *)(*(_QWORD *)v1 + 8 * v5 - 8), 0);
      v5 = v6;
    }
    while ((_DWORD)result);
  }
  return result;
}

void _SICloseIndex(uint64_t a1, int a2)
{
  if (a1 && sContactsIndex == a1)
    sContactsIndex = 0;
  if (a2)
  {
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 1880));
    if (!gTerminating)
      SIShutdownIndex(a1, 0, 0);
    while (!*(_DWORD *)(a1 + 2416))
      pthread_cond_wait((pthread_cond_t *)(a1 + 1944), (pthread_mutex_t *)(a1 + 1880));
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1880));
  }
  else
  {
    if ((*(_DWORD *)(a1 + 828) & 8) == 0)
    {
      pthread_mutex_lock(&schlock);
      if (gAllIndexes)
        CFSetRemoveValue((CFMutableSetRef)gAllIndexes, (const void *)a1);
      pthread_mutex_unlock(&schlock);
    }
    _SIShutdownIndex(a1);
  }
}

void SIShutdownIndex(uint64_t a1, void (*a2)(uint64_t, uint64_t), uint64_t a3)
{
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  NSObject *v9;
  _QWORD block[5];

  if (!a1)
    goto LABEL_6;
  if (sContactsIndex == a1)
    sContactsIndex = 0;
  if (*(_BYTE *)(a1 + 2432) || *(_DWORD *)(a1 + 2416))
  {
LABEL_6:
    if (a2)
      a2(a3, 0xFFFFFFFFLL);
  }
  else
  {
    *(_BYTE *)(a1 + 2432) = 1;
    v5 = malloc_type_malloc(0x18uLL, 0xA00402214FCE6uLL);
    v5[1] = a3;
    v5[2] = a2;
    *v5 = a1;
    v6 = 864;
    v7 = MEMORY[0x1E0C809B0];
    *(_DWORD *)(a1 + 2428) = 1;
    do
    {
      v8 = *(_QWORD *)(a1 + v6);
      if (v8)
      {
        v9 = *(NSObject **)(v8 + 32);
        block[0] = v7;
        block[1] = 0x40000000;
        block[2] = __si_scheduler_set_stopped_block_invoke;
        block[3] = &__block_descriptor_tmp_23_1039;
        block[4] = v8;
        dispatch_async(v9, block);
      }
      v6 += 8;
    }
    while (v6 != 1000);
    *(_BYTE *)(a1 + 2433) = 1;
    if (*(_QWORD *)(a1 + 2448))
      awakenPreheat(a1);
    si_enqueue_work(*(_QWORD *)(a1 + 1160), (uint64_t)si_shutdown, (uint64_t)v5);
  }
}

void _SIShutdownIndex(uint64_t a1)
{
  int *v2;
  int v3;
  BOOL v4;
  _BYTE *v5;
  int v6;
  NSObject *v7;
  _DWORD *v8;
  os_log_type_t v9;
  double Current;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v23;
  int v24;
  unint64_t v25;
  unsigned int v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  void (*v31)(_QWORD);
  int v32;
  NSObject *v33;
  int v34;
  NSObject *v35;
  uint64_t v36;
  uint64_t v37;
  unsigned __int8 v38;
  CFNumberRef v39;
  CFNumberRef v40;
  uint64_t v41;
  int v42;
  uint64_t v43;
  unsigned int v44;
  uint64_t v45;
  void (*v46)(_QWORD);
  int v47;
  NSObject *v48;
  os_log_type_t v49;
  CFAbsoluteTime v50;
  char *v51;
  int v52;
  unsigned int *v53;
  unsigned int v54;
  BOOL v55;
  unsigned int v56;
  unsigned int *v57;
  unsigned int v58;
  unsigned int v59;
  unsigned int *v60;
  unsigned int v61;
  unsigned int v62;
  char *v63;
  int v64;
  int v65;
  int v66;
  int v67;
  NSObject *v68;
  os_log_type_t v69;
  CFAbsoluteTime v70;
  int v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 *v76;
  unint64_t v77;
  unsigned int v78;
  unsigned int v79;
  unsigned int v80;
  unint64_t v81;
  unsigned int v82;
  __int128 v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  unsigned int v90;
  _QWORD v91[2];
  uint64_t (*v92)(uint64_t, uint64_t);
  void *v93;
  uint64_t *v94;
  uint64_t v95;
  uint64_t *v96;
  uint64_t v97;
  char v98;
  _BYTE valuePtr[48];
  __int128 v100;
  _OWORD *v101;
  uint8_t buf[32];
  __int128 v103;
  __int128 v104;
  _OWORD *v105;
  _BYTE v106[1024];
  uint64_t v107;

  v107 = *MEMORY[0x1E0C80C00];
  bzero(v106, 0x400uLL);
  v2 = (int *)(a1 + 32);
  v3 = fcntl(*(_DWORD *)(a1 + 32), 50, v106);
  if (v106[0])
    v4 = v3 < 0;
  else
    v4 = 1;
  if (v4)
    v5 = 0;
  else
    v5 = v106;
  v6 = *__error();
  v7 = _SILogForLogForCategory(0);
  v8 = &unk_1EF19F000;
  v9 = 2 * (gSILogLevels[0] < 4);
  if (os_log_type_enabled(v7, v9))
  {
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)&buf[4] = v5;
    _os_log_impl(&dword_1B8270000, v7, v9, "Index shut down starting for index at %s.", buf, 0xCu);
  }
  *__error() = v6;
  Current = CFAbsoluteTimeGetCurrent();
  if (sContactsIndex == a1)
    sContactsIndex = 0;
  *(_DWORD *)(a1 + 2428) = 1;
  v95 = 0;
  v96 = &v95;
  v97 = 0x2000000000;
  v98 = 0;
  v11 = *(_QWORD *)(a1 + 1392);
  v12 = *(_QWORD *)(a1 + 1384);
  v91[0] = MEMORY[0x1E0C809B0];
  v91[1] = 0x40000000;
  v92 = ___SIShutdownIndex_block_invoke;
  v93 = &unk_1E6E2DC18;
  v94 = &v95;
  if (v11 && *(_DWORD *)(v11 + 8))
  {
    v13 = 0;
    while (((unsigned int (*)(_QWORD *, _QWORD, _QWORD))v92)(v91, *(_QWORD *)(*(_QWORD *)v11 + 8 * v13), 0))
    {
      if (++v13 >= (unint64_t)*(unsigned int *)(v11 + 8))
        goto LABEL_16;
    }
  }
  else
  {
LABEL_16:
    if (v12 && *(_DWORD *)(v12 + 8))
    {
      v14 = 0;
      do
      {
        if (!((unsigned int (*)(_QWORD *, _QWORD, uint64_t))v92)(v91, *(_QWORD *)(*(_QWORD *)v12 + 8 * v14), 1))break;
        ++v14;
      }
      while (v14 < *(unsigned int *)(v12 + 8));
    }
  }
  if (!*((_BYTE *)v96 + 24))
  {
    si_scheduler_boost_and_forget(*(_QWORD *)(a1 + 944));
    si_scheduler_boost_and_forget(*(_QWORD *)(a1 + 864));
    si_scheduler_boost_and_forget(*(_QWORD *)(a1 + 872));
    si_scheduler_boost_and_forget(*(_QWORD *)(a1 + 896));
    si_scheduler_boost_and_forget(*(_QWORD *)(a1 + 912));
    si_scheduler_boost_and_forget(*(_QWORD *)(a1 + 888));
    si_scheduler_boost_and_forget(*(_QWORD *)(a1 + 880));
    si_scheduler_boost_and_forget(*(_QWORD *)(a1 + 952));
    _SIShutdownIndexSchedulers(a1, 0, 0, Current);
    v90 = 0;
    v15 = *(_QWORD *)(a1 + 6592);
    v16 = *(_QWORD *)(a1 + 1184);
    v17 = *(_QWORD *)(a1 + 1392);
    if (v16)
    {
      v18 = *(_QWORD *)(a1 + 1384);
    }
    else
    {
      v18 = *(_QWORD *)(a1 + 1384);
      if (*(_OWORD *)(a1 + 1384) == 0)
        goto LABEL_60;
    }
    v84 = 0;
    v87 = 257;
    v85 = v16;
    v86 = a1;
    v19 = v18;
    v83 = 0u;
    v88 = v17;
    v89 = v18;
    v105 = 0;
    v103 = 0u;
    v104 = 0u;
    memset(buf, 0, sizeof(buf));
    if (gTerminating)
      *(_DWORD *)(a1 + 2420) = 1;
    do
    {
      v20 = v17;
      v21 = v19;
      __dmb(0xBu);
      v17 = *(_QWORD *)(a1 + 1392);
      v19 = *(_QWORD *)(a1 + 1384);
    }
    while (v20 != v17 || v21 != v19);
    if (!fd_setDir(*v2, (int *)&v90))
    {
      v34 = *__error();
      v35 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
      {
        v71 = *__error();
        *(_DWORD *)valuePtr = 136315906;
        *(_QWORD *)&valuePtr[4] = "_SIShutdownIndex";
        *(_WORD *)&valuePtr[12] = 1024;
        *(_DWORD *)&valuePtr[14] = 15210;
        *(_WORD *)&valuePtr[18] = 1024;
        *(_DWORD *)&valuePtr[20] = v71;
        *(_WORD *)&valuePtr[24] = 2080;
        *(_QWORD *)&valuePtr[26] = v5;
        _os_log_error_impl(&dword_1B8270000, v35, OS_LOG_TYPE_ERROR, "%s:%d: setDir 2 error %d (%s)", valuePtr, 0x22u);
      }
      *__error() = v34;
      v36 = *(_QWORD *)(a1 + 1392);
      v37 = *(_QWORD *)(a1 + 1384);
      *(_OWORD *)&valuePtr[32] = v103;
      v100 = v104;
      v101 = v105;
      *(_OWORD *)valuePtr = *(_OWORD *)buf;
      *(_OWORD *)&valuePtr[16] = *(_OWORD *)&buf[16];
      ContentIndexCloseIndexBulk_Step1(0, v36, v37, (__int128 *)valuePtr, v15);
      CIMetaInfoClose(a1 + 1192);
      goto LABEL_57;
    }
    do
    {
      v23 = __ldxr(exceptionSequenceNum);
      v24 = v23 + 1;
    }
    while (__stxr(v23 + 1, exceptionSequenceNum));
    v82 = 0;
    v81 = 0;
    v80 = 0;
    v25 = setThreadIdAndInfo(*v2, sFdExceptionCallbacks, 0, 1, v24);
    v82 = v25;
    v80 = v27;
    v81 = __PAIR64__(HIDWORD(v25), v26);
    v28 = *(_QWORD *)&threadData[18 * v25 + 2];
    v29 = v28 + 320 * HIDWORD(v25);
    *(_BYTE *)(v29 + 216) = 0;
    v30 = *(_DWORD *)(v29 + 312);
    v31 = *(void (**)(_QWORD))(v29 + 224);
    if (v31)
      v31(*(_QWORD *)(v28 + 320 * HIDWORD(v25) + 288));
    v79 = v82;
    v78 = HIDWORD(v81);
    v77 = __PAIR64__(v81, v80);
    if (_setjmp((int *)v29))
    {
      v32 = *__error();
      v33 = _SILogForLogForCategory(0);
      v8 = (_DWORD *)&unk_1EF19F000;
      if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)valuePtr = 136315394;
        *(_QWORD *)&valuePtr[4] = "_SIShutdownIndex";
        *(_WORD *)&valuePtr[12] = 1024;
        *(_DWORD *)&valuePtr[14] = 15208;
        _os_log_error_impl(&dword_1B8270000, v33, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", valuePtr, 0x12u);
      }
      *__error() = v32;
      *(_DWORD *)(v29 + 312) = v30;
      CIOnThreadCleanUpReset(v77);
      dropThreadId(v79, 1, v24);
      CICleanUpReset(v79, HIDWORD(v77));
LABEL_57:
      v47 = *__error();
      v48 = _SILogForLogForCategory(0);
      v49 = 2 * (v8[803] < 4);
      if (os_log_type_enabled(v48, v49))
      {
        v50 = CFAbsoluteTimeGetCurrent();
        *(_DWORD *)valuePtr = 136315394;
        *(_QWORD *)&valuePtr[4] = v5;
        *(_WORD *)&valuePtr[12] = 2048;
        *(double *)&valuePtr[14] = v50 - Current;
        _os_log_impl(&dword_1B8270000, v48, v49, "Index closed for %s after %f seconds.", valuePtr, 0x16u);
      }
      *__error() = v47;
LABEL_60:
      SIActivityJournalClose((os_unfair_lock_s *)(a1 + 2192));
      v51 = *(char **)(a1 + 2192);
      *(_QWORD *)(a1 + 2192) = 0;
      if (v51)
        fd_release(v51);
      if (!*(_BYTE *)(a1 + 2072))
        goto LABEL_81;
      v52 = *(_DWORD *)(a1 + 6964);
      v53 = *(unsigned int **)(a1 + 2104);
      if (v52)
      {
        if (v53)
        {
          do
          {
            v54 = __ldaxr(v53);
            v55 = --v54 == 0;
          }
          while (__stlxr(v54, v53));
          goto LABEL_69;
        }
      }
      else if (v53)
      {
        do
        {
          v56 = __ldaxr(v53);
          v55 = --v56 == 0;
        }
        while (__stlxr(v56, v53));
LABEL_69:
        if (v55)
          _si_mobile_journal_finalize((uint64_t)v53, v52 == 0);
      }
      *(_QWORD *)(a1 + 2104) = 0;
      v57 = *(unsigned int **)(a1 + 2112);
      if (v57)
      {
        do
        {
          v58 = __ldaxr(v57);
          v59 = v58 - 1;
        }
        while (__stlxr(v59, v57));
        if (!v59)
          _si_mobile_journal_finalize((uint64_t)v57, 1);
      }
      *(_QWORD *)(a1 + 2112) = 0;
      v60 = *(unsigned int **)(a1 + 2120);
      if (v60)
      {
        do
        {
          v61 = __ldaxr(v60);
          v62 = v61 - 1;
        }
        while (__stlxr(v62, v60));
        if (!v62)
          _si_mobile_journal_finalize((uint64_t)v60, 1);
      }
      *(_QWORD *)(a1 + 2120) = 0;
LABEL_81:
      v63 = *(char **)(a1 + 2320);
      *(_QWORD *)(a1 + 2320) = 0;
      if (v63)
        fd_release(v63);
      doc_store_close(*(DocStore **)(a1 + 1296));
      *(_QWORD *)(a1 + 1296) = 0;
      if (_os_feature_enabled_impl() && *(_BYTE *)(a1 + 2072))
      {
        MDTrieClose();
        *(_QWORD *)(a1 + 1288) = 0;
      }
      *(_OWORD *)buf = *(_OWORD *)v2;
      *v2 = -1;
      v64 = *(_DWORD *)buf;
      if (*(_DWORD *)buf != -1)
      {
        if (*(_QWORD *)&buf[8])
        {
          guarded_close_np();
          v65 = *(_DWORD *)buf;
        }
        else
        {
          close(*(int *)buf);
          v65 = v64;
        }
        unregisterForCloning(v65);
      }
      v66 = *(_DWORD *)(a1 + 48);
      *(_DWORD *)(a1 + 48) = -1;
      if (v66 != -1)
        close(v66);
      v67 = *__error();
      v68 = _SILogForLogForCategory(0);
      v69 = 2 * (v8[803] < 4);
      if (os_log_type_enabled(v68, v69))
      {
        v70 = CFAbsoluteTimeGetCurrent();
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)&buf[4] = v5;
        *(_WORD *)&buf[12] = 2048;
        *(double *)&buf[14] = v70 - Current;
        _os_log_impl(&dword_1B8270000, v68, v69, "Index shut down finished for index at %s after %f seconds.", buf, 0x16u);
      }
      *__error() = v67;
      goto LABEL_96;
    }
    v38 = atomic_load((unsigned __int8 *)(a1 + 2439));
    v8 = &unk_1EF19F000;
    if ((v38 & 1) == 0)
    {
      if (!*(_QWORD *)(a1 + 1184))
      {
        v41 = a1 + 1192;
        goto LABEL_51;
      }
      *(_QWORD *)valuePtr = 0;
      *(_QWORD *)valuePtr = *(_QWORD *)(a1 + 2136);
      v39 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt64Type, valuePtr);
      if (v39)
      {
        v40 = v39;
        si_set_property(a1, CFSTR("ConsumedJournalSerialNumber"), v39, 1, 0);
        CFRelease(v40);
      }
      _si_store_propery_cache(a1, 0, 1);
      si_storesizes(a1, 0);
    }
    v41 = a1 + 1192;
    if (*(_QWORD *)(a1 + 1184))
    {
      v72 = xmmword_1E6E2DC80;
      v73 = *(_OWORD *)&off_1E6E2DC90;
      v74 = xmmword_1E6E2DCA0;
      v75 = *(_OWORD *)off_1E6E2DCB0;
      v76 = &v83;
LABEL_52:
      ContentIndexCloseIndexBulk_Step1(v41, v20, v21, &v72, v15);
      CIMetaInfoClose(v41);
      v42 = v90;
      MEMORY[0x1BCCB1484](v90);
      if ((v42 & 0x80000000) == 0)
        close(v42);
      v43 = *(_QWORD *)&threadData[18 * v79 + 2];
      v44 = v78;
      v45 = v43 + 320 * v78;
      *(_DWORD *)(v45 + 312) = v30;
      v46 = *(void (**)(_QWORD))(v45 + 232);
      if (v46)
        v46(*(_QWORD *)(v43 + 320 * v44 + 288));
      dropThreadId(v79, 0, v24);
      goto LABEL_57;
    }
LABEL_51:
    v74 = v103;
    v75 = v104;
    v76 = v105;
    v72 = *(_OWORD *)buf;
    v73 = *(_OWORD *)&buf[16];
    goto LABEL_52;
  }
LABEL_96:
  _Block_object_dispose(&v95, 8);
}

void _SIShutdownIndexSchedulers(uint64_t a1, char a2, int a3, double a4)
{
  _BOOL4 v9;
  NSObject *v10;
  int v11;
  uint64_t v12;
  unint64_t v13;
  int v14;
  NSObject *v15;
  os_log_type_t v16;
  _BYTE *v17;
  uint64_t i;
  uint64_t v19;
  void *v20;
  int j;
  char v22;
  BOOL v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int *v28;
  unsigned int v29;
  NSObject *initially_inactive;
  NSObject *v31;
  _QWORD block[5];
  _BYTE v33[312];
  NSObject *v34;
  NSObject *v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  _QWORD buf[39];
  _BYTE v40[1024];
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  bzero(v40, 0x400uLL);
  v9 = fcntl(*(_DWORD *)(a1 + 32), 50, v40) < 0 || v40[0] == 0;
  v10 = dispatch_group_create();
  pthread_mutex_lock(&sGameModeMutex);
  pthread_cond_broadcast(&sGameModeCond);
  pthread_mutex_unlock(&sGameModeMutex);
  v11 = *(_DWORD *)(a1 + 6972);
  v12 = 124;
  do
  {
    if (!v11 || v12 == 119)
      si_scheduler_stop(*(_QWORD *)(a1 + 8 * v12), (uint64_t)v10);
    v13 = v12 - 107;
    --v12;
  }
  while (v13 > 1);
  *(_BYTE *)(a1 + 2433) = 1;
  if (*(_QWORD *)(a1 + 2448))
    awakenPreheat(a1);
  dispatch_group_wait(v10, 0xFFFFFFFFFFFFFFFFLL);
  v14 = *__error();
  v15 = _SILogForLogForCategory(0);
  v16 = 2 * (gSILogLevels[0] < 4);
  if (os_log_type_enabled(v15, v16))
  {
    if (v9)
      v17 = 0;
    else
      v17 = v40;
    LODWORD(buf[0]) = 136315394;
    *(_QWORD *)((char *)buf + 4) = v17;
    WORD2(buf[1]) = 2048;
    *(double *)((char *)&buf[1] + 6) = CFAbsoluteTimeGetCurrent() - a4;
    _os_log_impl(&dword_1B8270000, v15, v16, "Shedulers stopped for %s after %f seconds.", (uint8_t *)buf, 0x16u);
  }
  *__error() = v14;
  if (a3)
  {
    for (i = 1008; i != 1168; i += 8)
    {
      if (i == 1160 && (a2 & 1) != 0)
        break;
      v19 = *(_QWORD *)(a1 + i);
      if (v19)
      {
        if (*(_QWORD *)v19)
          si_scheduler_remove_workqueue(*(_QWORD *)v19, *(_QWORD **)(a1 + i));
        if (i == 1144)
          dispatch_resume(*(dispatch_object_t *)(v19 + 16));
        si_workqueue_drain(v19);
      }
    }
    cleanup_retiring(a1);
  }
  else
  {
    v20 = malloc_type_calloc(0x14uLL, 8uLL, 0x2004093837F09uLL);
    for (j = 0; j != 20; ++j)
    {
      if (j == 19)
        v22 = a2;
      else
        v22 = 0;
      v23 = j == 11 || v11 == 0;
      if (v23 && (v22 & 1) == 0)
      {
        if (j == 17)
        {
          pthread_mutex_lock((pthread_mutex_t *)(a1 + 1320));
          si_handleWorkQueue(a1, (uint64_t)v20, v10, 17);
          pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1320));
        }
        else
        {
          si_handleWorkQueue(a1, (uint64_t)v20, v10, j);
        }
      }
    }
    si_cancel_activectx((void *)a1);
    memcpy(buf, (const void *)(a1 + 864), sizeof(buf));
    v24 = 0;
    v25 = *(unsigned int *)(a1 + 1404);
    v26 = *(unsigned int *)(a1 + 1408);
    do
    {
      v27 = buf[v24];
      if (v27)
      {
        v28 = (unsigned int *)(v27 + 80);
        do
          v29 = __ldaxr(v28);
        while (__stlxr(v29 + 1, v28));
      }
      ++v24;
    }
    while (v24 != 17);
    if (!v11)
      cleanup_retiring(a1);
    initially_inactive = dispatch_queue_attr_make_initially_inactive(0);
    v31 = dispatch_queue_create("com.apple.spotlight.index.shutdown.shortlived", initially_inactive);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = ___SIShutdownIndexSchedulers_block_invoke;
    block[3] = &__block_descriptor_tmp_934;
    block[4] = v20;
    memcpy(v33, buf, sizeof(v33));
    v34 = v10;
    v35 = v31;
    v38 = v11;
    v36 = v26;
    v37 = v25;
    dispatch_group_notify(v10, v31, block);
    dispatch_activate(v31);
    dispatch_release(v31);
  }
}

void awakenPreheat(uint64_t a1)
{
  int v2;
  NSObject *v3;
  os_log_type_t v4;
  uint64_t v5;
  unsigned int *v6;
  unint64_t *v7;
  unint64_t v8;
  int v9;
  NSObject *v10;
  os_log_type_t v11;
  uint64_t v12;
  int v13;
  NSObject *v14;
  os_log_type_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v2 = *__error();
  v3 = _SILogForLogForCategory(3);
  v4 = 2 * (dword_1EF19FC98 < 4);
  if (os_log_type_enabled(v3, v4))
  {
    v5 = *(_QWORD *)(a1 + 896);
    v17 = 134217984;
    v18 = v5;
    _os_log_impl(&dword_1B8270000, v3, v4, "awakenPreheat entered for %p", (uint8_t *)&v17, 0xCu);
  }
  *__error() = v2;
  v6 = *(unsigned int **)(a1 + 2448);
  if (v6)
  {
    v7 = (unint64_t *)(a1 + 2448);
    do
    {
      v8 = __ldxr(v7);
      if ((unsigned int *)v8 != v6)
      {
        __clrex();
        goto LABEL_11;
      }
    }
    while (__stxr(0, v7));
    v9 = *__error();
    v10 = _SILogForLogForCategory(3);
    v11 = 2 * (dword_1EF19FC98 < 4);
    if (os_log_type_enabled(v10, v11))
    {
      v12 = *(_QWORD *)(a1 + 896);
      v17 = 134217984;
      v18 = v12;
      _os_log_impl(&dword_1B8270000, v10, v11, "awakenPreheat continued for %p", (uint8_t *)&v17, 0xCu);
    }
    *__error() = v9;
    si_scheduler_resume_with_token(v6);
  }
  else
  {
LABEL_11:
    v13 = *__error();
    v14 = _SILogForLogForCategory(3);
    v15 = 2 * (dword_1EF19FC98 < 4);
    if (os_log_type_enabled(v14, v15))
    {
      v16 = *(_QWORD *)(a1 + 896);
      v17 = 134217984;
      v18 = v16;
      _os_log_impl(&dword_1B8270000, v14, v15, "awakenPreheat skipped for %p", (uint8_t *)&v17, 0xCu);
    }
    *__error() = v13;
  }
}

uint64_t cleanup_retiring(uint64_t a1)
{
  _QWORD *v2;
  pthread_mutex_t *v3;
  _QWORD *v4;

  v2 = *(_QWORD **)(a1 + 1168);
  *(_QWORD *)(a1 + 1168) = 0;
  v3 = (pthread_mutex_t *)(a1 + 1320);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1320));
  if (v2)
  {
    do
    {
      v4 = (_QWORD *)*v2;
      si_scheduler_remove_workqueue(*(_QWORD *)(a1 + 872), (_QWORD *)v2[1]);
      si_workqueue_drain(v2[1]);
      si_workqueue_destroy(v2[1]);
      free(v2);
      v2 = v4;
    }
    while (v4);
  }
  return pthread_mutex_unlock(v3);
}

void si_handleWorkQueue(uint64_t a1, uint64_t a2, NSObject *a3, int a4)
{
  uint64_t v4;
  uint64_t v5;
  NSObject *v9;
  _QWORD block[5];

  v4 = a1 + 8 * a4;
  v5 = *(_QWORD *)(v4 + 1008);
  *(_QWORD *)(v4 + 1008) = 0;
  if (v5)
  {
    if (*(_QWORD *)v5)
      si_scheduler_remove_workqueue(*(_QWORD *)v5, (_QWORD *)v5);
    if (a4 == 17)
      dispatch_resume(*(dispatch_object_t *)(v5 + 16));
    si_workqueue_drain(v5);
    dispatch_group_enter(a3);
    dispatch_retain(a3);
    v9 = *(NSObject **)(v5 + 16);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __si_handleWorkQueue_block_invoke;
    block[3] = &__block_descriptor_tmp_935;
    block[4] = a3;
    dispatch_barrier_async(v9, block);
    *(_QWORD *)(a2 + 8 * a4) = v5;
  }
}

void __si_handleWorkQueue_block_invoke(uint64_t a1)
{
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
}

int *si_shutdown(uint64_t *a1)
{
  int v2;
  NSObject *v3;
  os_log_type_t v4;
  double Current;
  uint64_t v6;
  void (*v7)(uint64_t, uint64_t);
  uint64_t v8;
  void (*v9)(uint64_t, _QWORD);
  int v10;
  NSObject *v11;
  os_log_type_t v12;
  CFAbsoluteTime v13;
  int *result;
  int v15;
  double v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v2 = *__error();
  v3 = _SILogForLogForCategory(3);
  v4 = 2 * (dword_1EF19FC98 < 4);
  if (os_log_type_enabled(v3, v4))
  {
    LOWORD(v15) = 0;
    _os_log_impl(&dword_1B8270000, v3, v4, "Shutdown started", (uint8_t *)&v15, 2u);
  }
  *__error() = v2;
  Current = CFAbsoluteTimeGetCurrent();
  if (*a1)
  {
    pthread_mutex_lock((pthread_mutex_t *)(*a1 + 1880));
    v6 = *a1;
    if (!*(_DWORD *)(*a1 + 2416))
    {
      _SIShutdownIndex(v6);
      v8 = *a1;
      *(_DWORD *)(*a1 + 2416) = 1;
      v9 = (void (*)(uint64_t, _QWORD))a1[2];
      if (v9)
      {
        v9(a1[1], 0);
        pthread_cond_signal((pthread_cond_t *)(*a1 + 1944));
        pthread_mutex_unlock((pthread_mutex_t *)(*a1 + 1880));
        goto LABEL_10;
      }
      pthread_cond_signal((pthread_cond_t *)(v8 + 1944));
      v6 = *a1;
    }
    pthread_mutex_unlock((pthread_mutex_t *)(v6 + 1880));
  }
  v7 = (void (*)(uint64_t, uint64_t))a1[2];
  if (v7)
    v7(a1[1], 0xFFFFFFFFLL);
LABEL_10:
  free(a1);
  v10 = *__error();
  v11 = _SILogForLogForCategory(3);
  v12 = 2 * (dword_1EF19FC98 < 4);
  if (os_log_type_enabled(v11, v12))
  {
    v13 = CFAbsoluteTimeGetCurrent();
    v15 = 134217984;
    v16 = v13 - Current;
    _os_log_impl(&dword_1B8270000, v11, v12, "Shutdown ended after %f seconds", (uint8_t *)&v15, 0xCu);
  }
  result = __error();
  *result = v10;
  return result;
}

uint64_t __si_cacheIndexVersion_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  if (!a2)
    return 1;
  result = 0;
  *(_DWORD *)(*(_QWORD *)(a1 + 32) + 6932) = *(_DWORD *)(a2 + 4);
  return result;
}

uint64_t _si_init_localized_terms(uint64_t a1)
{
  _QWORD *v2;
  _DWORD *v3;
  char *v4;
  uint64_t v5;
  int v6;
  int v7;
  off_t st_size;
  const __CFData *v10;
  const __CFData *v11;
  char v12;
  uint64_t v13;
  unsigned int v14;
  int v15;
  unint64_t v16;
  unsigned int v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  void (*v22)(_QWORD);
  int v23;
  NSObject *v24;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  unint64_t v31;
  unsigned int v32;
  uint64_t updated;
  int v34;
  NSObject *v35;
  os_log_type_t v36;
  int v37;
  unsigned int v38;
  uint64_t v39;
  unsigned int v40;
  uint64_t v41;
  void (*v42)(_QWORD);
  char *v43;
  char *v44;
  const char *v45;
  uint64_t v46;
  _QWORD aBlock[5];
  unint64_t v48;
  unsigned int v49;
  unsigned int v50;
  unint64_t v51;
  uint8_t buf[8];
  uint64_t v53;
  uint64_t v54;
  void (*v55)(uint64_t, const void *);
  void *v56;
  uint64_t v57;
  stat v58;
  uint64_t v59;
  UInt8 buffer[8];
  uint64_t v61;
  _BYTE v62[32];
  __int128 v63;
  __int128 v64;
  uint64_t v65;
  CFRange v66;

  v65 = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)(a1 + 6648))
  {
    v43 = __si_assert_copy_extra_521(-1);
    v44 = v43;
    v45 = "";
    if (v43)
      v45 = v43;
    __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 29658, "!ref->uniqueLocalizedTerms", v45);
    free(v44);
    if (__valid_fs(-1))
      v46 = 2989;
    else
      v46 = 3072;
    *(_DWORD *)v46 = -559038737;
    abort();
  }
  v2 = fd_create_protected(*(_DWORD *)(a1 + 32), "tmp.spotlight.loc", 0, 0);
  v3 = v2;
  v4 = (char *)v2;
  if (*(_BYTE *)(a1 + 2073))
    v5 = 122;
  else
    v5 = 90;
  v59 = 0;
  v6 = _fd_acquire_fd((uint64_t)v2, &v59);
  memset(&v58, 0, sizeof(v58));
  v7 = fstat(v6, &v58);
  st_size = v58.st_size;
  _fd_release_fd(v3, v6, 0, v59);
  if (v7 == -1 || st_size == 0)
  {
    fd_release(v4);
    v53 = MEMORY[0x1E0C809B0];
    v54 = 0x40000000;
    v55 = ___si_init_localized_terms_block_invoke;
    v56 = &__block_descriptor_tmp_882;
    v57 = a1;
  }
  else
  {
    v53 = MEMORY[0x1E0C809B0];
    v54 = 0x40000000;
    v55 = ___si_init_localized_terms_block_invoke;
    v56 = &__block_descriptor_tmp_882;
    v57 = a1;
    if (v4)
    {
      v63 = 0u;
      v64 = 0u;
      memset(v62, 0, sizeof(v62));
      store_stream_init((uint64_t)v62, v4, 0);
      if (!*(_DWORD *)&v62[16] && *(int *)(a1 + 1276) >= 84)
      {
        v10 = (const __CFData *)SICopyProperty(a1, CFSTR("database.localizedtermsuuid"));
        if (v10)
        {
          v11 = v10;
          if (CFDataGetLength(v10) == 16 && store_stream_read_vint32_566((uint64_t)v62) == 13)
          {
            v66.location = 0;
            *(_QWORD *)buffer = 0;
            v61 = 0;
            v66.length = 16;
            CFDataGetBytes(v11, v66, buffer);
            store_stream_read_bytes_567((unsigned int *)v62, (char *)(a1 + 6856), 0x10uLL);
            if (!uuid_compare(buffer, (const unsigned __int8 *)(a1 + 6856)))
            {
              updated = TermUpdateSetRestore((uint64_t)v62, 0, 0, 0, 1, v5, 0, 0, 0, 0, &v53);
              *(_QWORD *)(a1 + 6648) = updated;
              if (updated)
              {
                v34 = *__error();
                v35 = _SILogForLogForCategory(0);
                v36 = 2 * (gSILogLevels[0] < 4);
                if (os_log_type_enabled(v35, v36))
                {
                  *(_WORD *)buf = 0;
                  _os_log_impl(&dword_1B8270000, v35, v36, "restored localized terms", buf, 2u);
                }
                *__error() = v34;
                CFRelease(v11);
                store_stream_destroy((uint64_t)v62);
                fd_release(v4);
                v12 = 1;
                goto LABEL_21;
              }
            }
          }
          CFRelease(v11);
        }
      }
      store_stream_destroy((uint64_t)v62);
      fd_release(v4);
    }
  }
  *(_QWORD *)(a1 + 6648) = TermUpdateSetCreate(0, 0, 0, 1, v5, 0, 0, &v53);
  v12 = 0;
LABEL_21:
  memset(v62, 0, 24);
  pthread_rwlockattr_init((pthread_rwlockattr_t *)v62);
  pthread_rwlock_init((pthread_rwlock_t *)(a1 + 6656), (const pthread_rwlockattr_t *)v62);
  pthread_rwlockattr_destroy((pthread_rwlockattr_t *)v62);
  v13 = *(_QWORD *)(a1 + 6648);
  *(_QWORD *)(v13 + 280) = a1 + 6656;
  *(_QWORD *)(v13 + 608) = getPropertyStringCallback;
  *(_BYTE *)(a1 + 6872) = 0;
  do
  {
    v14 = __ldxr(exceptionSequenceNum);
    v15 = v14 + 1;
  }
  while (__stxr(v14 + 1, exceptionSequenceNum));
  v16 = setThreadIdAndInfo(*(_DWORD *)(a1 + 32), sFdExceptionCallbacks, 0, 1, v15);
  *(_DWORD *)buf = HIDWORD(v16);
  *(_DWORD *)buffer = v16;
  v51 = __PAIR64__(v17, v18);
  v19 = *(_QWORD *)&threadData[18 * v16 + 2];
  v20 = v19 + 320 * HIDWORD(v16);
  *(_BYTE *)(v20 + 216) = 0;
  v21 = *(_DWORD *)(v20 + 312);
  v22 = *(void (**)(_QWORD))(v20 + 224);
  if (v22)
    v22(*(_QWORD *)(v19 + 320 * HIDWORD(v16) + 288));
  v50 = *(_DWORD *)buffer;
  v49 = *(_DWORD *)buf;
  v48 = v51;
  if (_setjmp((int *)v20))
  {
    v23 = *__error();
    v24 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v62 = 136315394;
      *(_QWORD *)&v62[4] = "_si_init_localized_terms";
      *(_WORD *)&v62[12] = 1024;
      *(_DWORD *)&v62[14] = 29757;
      _os_log_error_impl(&dword_1B8270000, v24, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", v62, 0x12u);
    }
    *__error() = v23;
    *(_DWORD *)(v20 + 312) = v21;
    CIOnThreadCleanUpReset(v48);
    dropThreadId(v50, 1, v15);
    return CICleanUpReset(v50, HIDWORD(v48));
  }
  if (*(int *)(a1 + 1276) < 84)
    goto LABEL_54;
  v26 = *(_QWORD *)(a1 + 1184);
  aBlock[0] = MEMORY[0x1E0C809B0];
  aBlock[1] = 0x40000000;
  aBlock[2] = ___si_init_localized_terms_block_invoke_885;
  aBlock[3] = &__block_descriptor_tmp_886;
  aBlock[4] = a1;
  if (*(_DWORD *)v26 == 1685287992)
    *(_QWORD *)(v26 + 968) = _Block_copy(aBlock);
  if ((v12 & 1) != 0)
    goto LABEL_54;
  v27 = *(_QWORD *)(a1 + 1184);
  if (*(_DWORD *)v27 != 1685287992)
    goto LABEL_54;
  v28 = *(_QWORD *)(a1 + 1184);
  if (!*(_QWORD *)(v27 + 968))
    goto LABEL_54;
  v29 = *(_QWORD *)(v28 + 912);
  if ((*(_BYTE *)(v28 + 804) & 0x14) == 0)
  {
    if (*(_DWORD *)(v29 + 56) >= 2u)
    {
      v32 = 1;
      do
      {
        (*(void (**)(void))(*(_QWORD *)(v28 + 968) + 16))();
        ++v32;
      }
      while (v32 < *(_DWORD *)(v29 + 56));
    }
    goto LABEL_54;
  }
  if (!v29)
    goto LABEL_54;
  v30 = *(_DWORD *)(v29 + 216);
  switch(v30)
  {
    case -270471200:
      v31 = *(_QWORD *)(v29 + 376);
LABEL_51:
      if (v31 >= 2)
      {
        v37 = 2;
        do
        {
          v38 = v37;
          (*(void (**)(void))(*(_QWORD *)(v28 + 968) + 16))();
          v37 = v38 + 1;
        }
        while (v31 > v38);
      }
      break;
    case 1684300900:
      v31 = *(_QWORD *)(v29 + 4496);
      goto LABEL_51;
    case 842150450:
      v31 = (*(_DWORD *)(v29 + 364) - 1) + 1;
      goto LABEL_51;
  }
LABEL_54:
  v39 = *(_QWORD *)&threadData[18 * v50 + 2];
  v40 = v49;
  v41 = v39 + 320 * v49;
  *(_DWORD *)(v41 + 312) = v21;
  v42 = *(void (**)(_QWORD))(v41 + 232);
  if (v42)
    v42(*(_QWORD *)(v39 + 320 * v40 + 288));
  return dropThreadId(v50, 0, v15);
}

uint64_t _SIInitSDB(uint64_t a1, __int16 a2, int a3)
{
  unsigned int v6;
  int v7;
  unint64_t v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  void (*v14)(_QWORD);
  int v15;
  CFAllocatorRef *v16;
  int v17;
  NSObject *v18;
  _QWORD *v19;
  uint64_t v20;
  int *v21;
  void *v22;
  const void *v23;
  uint64_t v24;
  void *v25;
  const void *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  const __CFDictionary *v31;
  const __CFAllocator *v32;
  const __CFDictionary *v33;
  __CFBitVector *Mutable;
  int **v35;
  const __CFAllocator *v36;
  __CFDictionary *v37;
  int *v38;
  int id_for_string;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  int v67;
  int v68;
  int v69;
  int v70;
  int v71;
  int v72;
  int v73;
  int v74;
  int v75;
  int v76;
  int v77;
  int v78;
  int v79;
  int v80;
  int v81;
  int v82;
  int v83;
  int v84;
  int v85;
  int v86;
  int v87;
  int v88;
  int v89;
  int v90;
  int v91;
  int v92;
  int v93;
  int v94;
  int v95;
  int v96;
  int v97;
  int v98;
  int v99;
  int v100;
  int v101;
  int v102;
  int v103;
  int v104;
  int v105;
  int v106;
  int v107;
  int v108;
  int v109;
  int v110;
  int v111;
  int v112;
  int v113;
  int v114;
  int v115;
  int v116;
  int v117;
  int v118;
  int v119;
  int v120;
  int v121;
  int v122;
  int v123;
  int v124;
  int v125;
  int v126;
  int v127;
  int v128;
  int v129;
  int v130;
  int v131;
  int v132;
  int v133;
  int v134;
  int v135;
  int v136;
  int v137;
  int v138;
  int *v139;
  int v140;
  int v141;
  int v142;
  int v143;
  int v144;
  int v145;
  int v146;
  int v147;
  int v148;
  int v149;
  int v150;
  int v151;
  int v152;
  int v153;
  int v154;
  int v155;
  int v156;
  int v157;
  int v158;
  int v159;
  int v160;
  int v161;
  int v162;
  int v163;
  int v164;
  int v165;
  int v166;
  int v167;
  int v168;
  int v169;
  int v170;
  int v171;
  int v172;
  int v173;
  int v174;
  int v175;
  int v176;
  int v177;
  char *v178;
  const __CFAllocator *v179;
  __CFDictionary *v180;
  int id_for_value;
  int v182;
  int v183;
  int v184;
  int v185;
  int v186;
  int v187;
  int v188;
  int v189;
  int v190;
  int v191;
  int v192;
  int v193;
  int v194;
  int v195;
  int v196;
  int v197;
  int v198;
  int v199;
  int v200;
  int v201;
  int v202;
  int v203;
  int v204;
  int v205;
  int v206;
  int v207;
  int v208;
  int v209;
  int v210;
  int v211;
  int v212;
  int v213;
  int v214;
  int v215;
  int v216;
  int v217;
  int v218;
  int v219;
  int v220;
  int v221;
  int v222;
  int v223;
  int v224;
  int v225;
  int v226;
  int v227;
  int v228;
  int v229;
  int v230;
  int v231;
  int v232;
  int v233;
  int v234;
  int v235;
  int v236;
  int v237;
  int v238;
  int v239;
  int v240;
  int v241;
  int v242;
  int v243;
  int v244;
  int v245;
  int v246;
  int v247;
  int v248;
  int v249;
  int v250;
  int v251;
  int v252;
  int v253;
  int v254;
  int v255;
  int v256;
  int v257;
  int v258;
  int v259;
  int v260;
  int v261;
  int v262;
  int v263;
  int v264;
  int v265;
  int v266;
  int v267;
  int v268;
  int v269;
  int v270;
  int v271;
  int v272;
  int v273;
  int v274;
  int v275;
  int v276;
  int v277;
  int v278;
  int v279;
  int v280;
  int v281;
  int v282;
  int v283;
  int v284;
  int v285;
  int v286;
  int v287;
  int v288;
  int v289;
  int v290;
  int v291;
  int v292;
  int v293;
  int v294;
  int v295;
  int v296;
  int v297;
  int v298;
  int v299;
  int v300;
  int v301;
  int v302;
  int v303;
  int v304;
  int v305;
  int v306;
  int v307;
  int v308;
  int v309;
  int v310;
  int v311;
  int v312;
  int v313;
  int v314;
  int v315;
  int v316;
  int v317;
  int v318;
  char *v319;
  int id_for_field;
  int *v321;
  unsigned int v322;
  unsigned int v323;
  __int16 v324;
  unsigned int v325;
  __int16 v326;
  unsigned int v327;
  __int16 v328;
  unsigned int v329;
  __int16 v330;
  unsigned int v331;
  __int16 v332;
  unsigned int v333;
  __int16 v334;
  uint64_t v335;
  unsigned int v336;
  uint64_t v337;
  void (*v338)(_QWORD);
  const __CFAllocator *v339;
  char *v341;
  char *v342;
  const char *v343;
  int v344;
  NSObject *v345;
  int v346;
  char *v347;
  const char *v348;
  int v349;
  NSObject *v350;
  int v351;
  char *v352;
  const char *v353;
  int v354;
  int v355;
  _QWORD v356[2];
  uint64_t (*v357)(uint64_t, uint64_t);
  void *v358;
  uint64_t v359;
  _QWORD v360[5];
  _QWORD aBlock[5];
  _QWORD v362[5];
  _QWORD v363[5];
  _QWORD v364[5];
  unsigned int v365;
  unsigned int v366;
  unsigned int v367;
  unsigned int v368;
  unsigned int v369;
  unsigned int v370;
  unsigned int v371;
  unsigned int v372;
  uint8_t buf[4];
  const char *v374;
  __int16 v375;
  int v376;
  __int16 v377;
  int v378;
  uint64_t v379;

  v379 = *MEMORY[0x1E0C80C00];
  do
  {
    v6 = __ldxr(exceptionSequenceNum);
    v7 = v6 + 1;
  }
  while (__stxr(v6 + 1, exceptionSequenceNum));
  v8 = setThreadIdAndInfo(-1, (__int128 *)sSDBExceptionCallbacks, *(_QWORD *)(a1 + 1184), 0x40000000, v7);
  v371 = HIDWORD(v8);
  v372 = v8;
  v369 = v10;
  v370 = v9;
  v11 = *(_QWORD *)&threadData[18 * v8 + 2];
  v12 = v11 + 320 * HIDWORD(v8);
  *(_BYTE *)(v12 + 216) = 0;
  v13 = *(_DWORD *)(v12 + 312);
  v14 = *(void (**)(_QWORD))(v12 + 224);
  if (v14)
    v14(*(_QWORD *)(v11 + 320 * HIDWORD(v8) + 288));
  v368 = v372;
  v367 = v371;
  v366 = v370;
  v365 = v369;
  v15 = _setjmp((int *)v12);
  v16 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
  if (v15)
  {
    v17 = *__error();
    v18 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v374 = "_SIInitSDB";
      v375 = 1024;
      v376 = 13588;
      _os_log_error_impl(&dword_1B8270000, v18, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
    }
    *__error() = v17;
    *(_DWORD *)(v12 + 312) = v13;
    CIOnThreadCleanUpReset(v365);
    dropThreadId(v368, 1, v7);
    CICleanUpReset(v368, v366);
    goto LABEL_619;
  }
  v19 = *(_QWORD **)(a1 + 1184);
  v20 = MEMORY[0x1E0C809B0];
  v364[0] = MEMORY[0x1E0C809B0];
  v364[1] = 0x40000000;
  v364[2] = ___SIInitSDB_block_invoke;
  v364[3] = &__block_descriptor_tmp_888;
  v364[4] = a1;
  v362[4] = a1;
  v363[0] = MEMORY[0x1E0C809B0];
  v363[1] = 0x40000000;
  v363[2] = ___SIInitSDB_block_invoke_2;
  v363[3] = &__block_descriptor_tmp_890;
  v363[4] = a1;
  v362[0] = MEMORY[0x1E0C809B0];
  v362[1] = 0x40000000;
  v362[2] = ___SIInitSDB_block_invoke_3;
  v362[3] = &__block_descriptor_tmp_891;
  if (*(_DWORD *)v19 != 1685287992)
  {
    v341 = __si_assert_copy_extra_268();
    v342 = v341;
    v343 = "";
    if (v341)
      v343 = v341;
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 233, v343);
LABEL_633:
    free(v342);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  v354 = v13;
  db2_set_garbage_collector(v19, v364, v363, v362);
  v21 = *(int **)(a1 + 1184);
  aBlock[0] = v20;
  aBlock[1] = 0x40000000;
  aBlock[2] = ___SIInitSDB_block_invoke_4;
  aBlock[3] = &__block_descriptor_tmp_893;
  aBlock[4] = a1;
  if (*v21 != 1685287992)
  {
    v344 = *__error();
    v345 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v345, OS_LOG_TYPE_ERROR))
    {
      v346 = *v21;
      *(_DWORD *)buf = 136315650;
      v374 = "db_set_dirty_callback";
      v375 = 1024;
      v376 = 235;
      v377 = 1024;
      v378 = v346;
      _os_log_error_impl(&dword_1B8270000, v345, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v344;
    v347 = __si_assert_copy_extra_268();
    v342 = v347;
    v348 = "";
    if (v347)
      v348 = v347;
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 235, v348);
    goto LABEL_633;
  }
  v22 = _Block_copy(aBlock);
  v23 = (const void *)*((_QWORD *)v21 + 104);
  if (v23)
    _Block_release(v23);
  *((_QWORD *)v21 + 104) = v22;
  v24 = *(_QWORD *)(a1 + 6624);
  if (v24)
  {
    v360[0] = v20;
    v360[1] = 0x40000000;
    v360[2] = ___SIInitSDB_block_invoke_5;
    v360[3] = &__block_descriptor_tmp_894;
    v360[4] = a1;
    v25 = _Block_copy(v360);
    v26 = *(const void **)(v24 + 4632);
    if (v26)
      _Block_release(v26);
    *(_QWORD *)(v24 + 4632) = v25;
  }
  v355 = v7;
  v27 = *(_QWORD *)(a1 + 1392);
  v28 = *(_QWORD *)(a1 + 1384);
  v356[0] = v20;
  v356[1] = 0x40000000;
  v357 = ___SIInitSDB_block_invoke_6;
  v358 = &__block_descriptor_tmp_896;
  v359 = a1;
  if (v27 && *(_DWORD *)(v27 + 8))
  {
    v29 = 0;
    while (((unsigned int (*)(_QWORD *, _QWORD, _QWORD))v357)(v356, *(_QWORD *)(*(_QWORD *)v27 + 8 * v29), 0))
    {
      if (++v29 >= (unint64_t)*(unsigned int *)(v27 + 8))
        goto LABEL_22;
    }
  }
  else
  {
LABEL_22:
    if (v28 && *(_DWORD *)(v28 + 8))
    {
      v30 = 0;
      do
      {
        if (!((unsigned int (*)(_QWORD *, _QWORD, uint64_t))v357)(v356, *(_QWORD *)(*(_QWORD *)v28 + 8 * v30), 1))break;
        ++v30;
      }
      while (v30 < *(unsigned int *)(v28 + 8));
    }
  }
  if (*(_BYTE *)(a1 + 2072))
  {
    v31 = (const __CFDictionary *)SICopyProperty(a1, CFSTR("GroupAssignments"));
    v32 = *v16;
    if (v31)
    {
      v33 = v31;
      *(_QWORD *)(a1 + 2088) = CFDictionaryCreateMutableCopy(*v16, 0, v31);
      CFRelease(v33);
    }
    else
    {
      *(_QWORD *)(a1 + 2088) = CFDictionaryCreateMutable(*v16, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    }
    Mutable = CFBitVectorCreateMutable(v32, 256);
    *(_QWORD *)(a1 + 2096) = Mutable;
    CFBitVectorSetCount(Mutable, 256);
    CFBitVectorSetAllBits(*(CFMutableBitVectorRef *)(a1 + 2096), 0);
    CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 2088), (CFDictionaryApplierFunction)updateUsedBites, *(void **)(a1 + 2096));
  }
  v35 = (int **)(a1 + 1184);
  *(_DWORD *)(a1 + 2060) = db_create_id_for_field(*(_DWORD **)(a1 + 1184), "_kMDItemExternalID", 0x2308u, 11);
  *(_DWORD *)(a1 + 2064) = db_create_id_for_field(*(_DWORD **)(a1 + 1184), "_kMDItemBundleID", 0x4318u, 11);
  *(_DWORD *)(a1 + 2056) = db_create_id_for_field(*(_DWORD **)(a1 + 1184), "_kMDItemOwnerUserID", 0x308u, 7);
  *(_DWORD *)(a1 + 2068) = db_create_id_for_field(*(_DWORD **)(a1 + 1184), "_kMDItemDomainIdentifier", 0x4300u, 11);
  *(_DWORD *)(a1 + 2032) = db_create_id_for_field(*(_DWORD **)(a1 + 1184), "_kMDItemFileName", 0x308u, 11);
  *(_DWORD *)(a1 + 2000) = db_create_id_for_field(*(_DWORD **)(a1 + 1184), "kMDItemContentTypeTree", 0x330u, 11);
  *(_DWORD *)(a1 + 2004) = db_create_id_for_field(*(_DWORD **)(a1 + 1184), "kMDItemSupportFileType", 0x330u, 11);
  *(_DWORD *)(a1 + 1996) = db_create_id_for_field(*(_DWORD **)(a1 + 1184), "kMDItemContentType", 0x310u, 11);
  *(_DWORD *)(a1 + 2008) = db_create_id_for_field(*(_DWORD **)(a1 + 1184), "_kMDItemGroupId", 0x108u, 2);
  if (a3)
  {
    if ((a2 & 0x100) != 0)
    {
      v178 = "_kMDItemStorageSize";
    }
    else
    {
      if (!*(_QWORD *)(a1 + 6608))
      {
        v36 = *v16;
        v37 = CFDictionaryCreateMutable(*v16, 0, 0, 0);
        v38 = *v35;
        id_for_string = db_get_id_for_string(*v35, "public.message");
        if (id_for_string != -2)
        {
          CFDictionarySetValue(v37, (const void *)(id_for_string & 0x7FFFFFFF), (const void *)1);
          v38 = *v35;
        }
        v40 = db_get_id_for_string(v38, "com.apple.mail.emlx");
        if (v40 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v40 & 0x7FFFFFFF), (const void *)2);
          v38 = *v35;
        }
        v41 = db_get_id_for_string(v38, "com.apple.mail.eml");
        if (v41 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v41 & 0x7FFFFFFF), (const void *)3);
          v38 = *v35;
        }
        v42 = db_get_id_for_string(v38, "com.microsoft.entourage.virtual.message");
        if (v42 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v42 & 0x7FFFFFFF), (const void *)4);
          v38 = *v35;
        }
        v43 = db_get_id_for_string(v38, "com.apple.ichat.transcript");
        if (v43 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v43 & 0x7FFFFFFF), (const void *)5);
          v38 = *v35;
        }
        v44 = db_get_id_for_string(v38, "public.contact");
        if (v44 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v44 & 0x7FFFFFFF), (const void *)6);
          v38 = *v35;
        }
        v45 = db_get_id_for_string(v38, "public.vcard");
        if (v45 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v45 & 0x7FFFFFFF), (const void *)7);
          v38 = *v35;
        }
        v46 = db_get_id_for_string(v38, "com.apple.addressbook.person");
        if (v46 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v46 & 0x7FFFFFFF), (const void *)8);
          v38 = *v35;
        }
        v47 = db_get_id_for_string(v38, "com.apple.addressbook.group");
        if (v47 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v47 & 0x7FFFFFFF), (const void *)9);
          v38 = *v35;
        }
        v48 = db_get_id_for_string(v38, "com.microsoft.entourage.virtual.contact");
        if (v48 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v48 & 0x7FFFFFFF), (const void *)0xA);
          v38 = *v35;
        }
        v49 = db_get_id_for_string(v38, "com.microsoft.entourage.virtual.group");
        if (v49 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v49 & 0x7FFFFFFF), (const void *)0xB);
          v38 = *v35;
        }
        v50 = db_get_id_for_string(v38, "com.apple.systempreference.prefpane");
        if (v50 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v50 & 0x7FFFFFFF), (const void *)0xC);
          v38 = *v35;
        }
        v51 = db_get_id_for_string(v38, "public.font");
        if (v51 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v51 & 0x7FFFFFFF), (const void *)0xD);
          v38 = *v35;
        }
        v52 = db_get_id_for_string(v38, "public.bookmark");
        if (v52 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v52 & 0x7FFFFFFF), (const void *)0xE);
          v38 = *v35;
        }
        v53 = db_get_id_for_string(v38, "com.apple.safari.bookmark");
        if (v53 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v53 & 0x7FFFFFFF), (const void *)0xF);
          v38 = *v35;
        }
        v54 = db_get_id_for_string(v38, "com.apple.safari.history");
        if (v54 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v54 & 0x7FFFFFFF), (const void *)0x10);
          v38 = *v35;
        }
        v55 = db_get_id_for_string(v38, "public.to-do-item");
        if (v55 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v55 & 0x7FFFFFFF), (const void *)0x11);
          v38 = *v35;
        }
        v56 = db_get_id_for_string(v38, "public.calendar-event");
        if (v56 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v56 & 0x7FFFFFFF), (const void *)0x12);
          v38 = *v35;
        }
        v57 = db_get_id_for_string(v38, "com.apple.ical.bookmark");
        if (v57 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v57 & 0x7FFFFFFF), (const void *)0x13);
          v38 = *v35;
        }
        v58 = db_get_id_for_string(v38, "com.apple.ical.bookmark.todo");
        if (v58 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v58 & 0x7FFFFFFF), (const void *)0x14);
          v38 = *v35;
        }
        v59 = db_get_id_for_string(v38, "com.apple.ical.ics.event");
        if (v59 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v59 & 0x7FFFFFFF), (const void *)0x15);
          v38 = *v35;
        }
        v60 = db_get_id_for_string(v38, "com.apple.ical.ics.todo");
        if (v60 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v60 & 0x7FFFFFFF), (const void *)0x16);
          v38 = *v35;
        }
        v61 = db_get_id_for_string(v38, "com.microsoft.entourage.virtual.event");
        if (v61 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v61 & 0x7FFFFFFF), (const void *)0x17);
          v38 = *v35;
        }
        v62 = db_get_id_for_string(v38, "com.microsoft.entourage.virtual.task");
        if (v62 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v62 & 0x7FFFFFFF), (const void *)0x18);
          v38 = *v35;
        }
        v63 = db_get_id_for_string(v38, "public.movie");
        if (v63 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v63 & 0x7FFFFFFF), (const void *)0x19);
          v38 = *v35;
        }
        v64 = db_get_id_for_string(v38, "com.apple.quicktime-movie");
        if (v64 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v64 & 0x7FFFFFFF), (const void *)0x1A);
          v38 = *v35;
        }
        v65 = db_get_id_for_string(v38, "public.mpeg-video");
        if (v65 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v65 & 0x7FFFFFFF), (const void *)0x1B);
          v38 = *v35;
        }
        v66 = db_get_id_for_string(v38, "public.mpeg-4");
        if (v66 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v66 & 0x7FFFFFFF), (const void *)0x1C);
          v38 = *v35;
        }
        v67 = db_get_id_for_string(v38, "public.mpeg");
        if (v67 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v67 & 0x7FFFFFFF), (const void *)0x1D);
          v38 = *v35;
        }
        v68 = db_get_id_for_string(v38, "public.3gpp");
        if (v68 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v68 & 0x7FFFFFFF), (const void *)0x1E);
          v38 = *v35;
        }
        v69 = db_get_id_for_string(v38, "public.3gpp2");
        if (v69 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v69 & 0x7FFFFFFF), (const void *)0x1F);
          v38 = *v35;
        }
        v70 = db_get_id_for_string(v38, "com.apple.application-bundle");
        if (v70 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v70 & 0x7FFFFFFF), (const void *)0x20);
          v38 = *v35;
        }
        v71 = db_get_id_for_string(v38, "com.apple.application-file");
        if (v71 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v71 & 0x7FFFFFFF), (const void *)0x21);
          v38 = *v35;
        }
        v72 = db_get_id_for_string(v38, "com.apple.dashboard-widget");
        if (v72 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v72 & 0x7FFFFFFF), (const void *)0x22);
          v38 = *v35;
        }
        v73 = db_get_id_for_string(v38, "public.folder");
        if (v73 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v73 & 0x7FFFFFFF), (const void *)0x23);
          v38 = *v35;
        }
        v74 = db_get_id_for_string(v38, "com.apple.mount-point");
        if (v74 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v74 & 0x7FFFFFFF), (const void *)0x24);
          v38 = *v35;
        }
        v75 = db_get_id_for_string(v38, "public.audio");
        if (v75 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v75 & 0x7FFFFFFF), (const void *)0x25);
          v38 = *v35;
        }
        v76 = db_get_id_for_string(v38, "public.mpeg-4-audio");
        if (v76 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v76 & 0x7FFFFFFF), (const void *)0x26);
          v38 = *v35;
        }
        v77 = db_get_id_for_string(v38, "com.apple.protected-mpeg-4-audio");
        if (v77 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v77 & 0x7FFFFFFF), (const void *)0x27);
          v38 = *v35;
        }
        v78 = db_get_id_for_string(v38, "com.adobe.pdf");
        if (v78 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v78 & 0x7FFFFFFF), (const void *)0x28);
          v38 = *v35;
        }
        v79 = db_get_id_for_string(v38, "com.apple.localized-pdf-bundle");
        if (v79 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v79 & 0x7FFFFFFF), (const void *)0x29);
          v38 = *v35;
        }
        v80 = db_get_id_for_string(v38, "public.presentation");
        if (v80 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v80 & 0x7FFFFFFF), (const void *)0x2A);
          v38 = *v35;
        }
        v81 = db_get_id_for_string(v38, "com.microsoft.powerpoint.ppt");
        if (v81 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v81 & 0x7FFFFFFF), (const void *)0x2B);
          v38 = *v35;
        }
        v82 = db_get_id_for_string(v38, "com.apple.keynote.key");
        if (v82 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v82 & 0x7FFFFFFF), (const void *)0x2C);
          v38 = *v35;
        }
        v83 = db_get_id_for_string(v38, "com.apple.iwork.keynote.key");
        if (v83 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v83 & 0x7FFFFFFF), (const void *)0x2D);
          v38 = *v35;
        }
        v84 = db_get_id_for_string(v38, "public.image");
        if (v84 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v84 & 0x7FFFFFFF), (const void *)0x2E);
          v38 = *v35;
        }
        v85 = db_get_id_for_string(v38, "com.apple.motion.project");
        if (v85 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v85 & 0x7FFFFFFF), (const void *)0x2F);
          v38 = *v35;
        }
        v86 = db_get_id_for_string(v38, "com.apple.iwork.pages.pages");
        if (v86 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v86 & 0x7FFFFFFF), (const void *)0x30);
          v38 = *v35;
        }
        v87 = db_get_id_for_string(v38, "com.apple.iwork.pages.sffpages");
        if (v87 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v87 & 0x7FFFFFFF), (const void *)0x31);
          v38 = *v35;
        }
        v88 = db_get_id_for_string(v38, "com.apple.iwork.pages.template");
        if (v88 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v88 & 0x7FFFFFFF), (const void *)0x32);
          v38 = *v35;
        }
        v89 = db_get_id_for_string(v38, "com.apple.iwork.pages.sfftemplate");
        if (v89 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v89 & 0x7FFFFFFF), (const void *)0x33);
          v38 = *v35;
        }
        v90 = db_get_id_for_string(v38, "public.rtf");
        if (v90 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v90 & 0x7FFFFFFF), (const void *)0x34);
          v38 = *v35;
        }
        v91 = db_get_id_for_string(v38, "com.apple.rtfd");
        if (v91 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v91 & 0x7FFFFFFF), (const void *)0x35);
          v38 = *v35;
        }
        v92 = db_get_id_for_string(v38, "com.apple.flat-rtfd");
        if (v92 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v92 & 0x7FFFFFFF), (const void *)0x36);
          v38 = *v35;
        }
        v93 = db_get_id_for_string(v38, "com.microsoft.word.doc");
        if (v93 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v93 & 0x7FFFFFFF), (const void *)0x37);
          v38 = *v35;
        }
        v94 = db_get_id_for_string(v38, "org.khronos.collada.digital-asset-exchange");
        if (v94 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v94 & 0x7FFFFFFF), (const void *)0x38);
          v38 = *v35;
        }
        v95 = db_get_id_for_string(v38, "public.plain-text");
        if (v95 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v95 & 0x7FFFFFFF), (const void *)0x39);
          v38 = *v35;
        }
        v96 = db_get_id_for_string(v38, "public.html");
        if (v96 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v96 & 0x7FFFFFFF), (const void *)0x3A);
          v38 = *v35;
        }
        v97 = db_get_id_for_string(v38, "public.xhtml");
        if (v97 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v97 & 0x7FFFFFFF), (const void *)0x3B);
          v38 = *v35;
        }
        v98 = db_get_id_for_string(v38, "public.shell-script");
        if (v98 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v98 & 0x7FFFFFFF), (const void *)0x3C);
          v38 = *v35;
        }
        v99 = db_get_id_for_string(v38, "public.source-code");
        if (v99 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v99 & 0x7FFFFFFF), (const void *)0x3D);
          v38 = *v35;
        }
        v100 = db_get_id_for_string(v38, "public.unix-executable");
        if (v100 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v100 & 0x7FFFFFFF), (const void *)0x3E);
          v38 = *v35;
        }
        v101 = db_get_id_for_string(v38, "com.apple.xcode.project");
        if (v101 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v101 & 0x7FFFFFFF), (const void *)0x3F);
          v38 = *v35;
        }
        v102 = db_get_id_for_string(v38, "com.apple.xcode.model");
        if (v102 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v102 & 0x7FFFFFFF), (const void *)0x40);
          v38 = *v35;
        }
        v103 = db_get_id_for_string(v38, "com.apple.xcode.archive");
        if (v103 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v103 & 0x7FFFFFFF), (const void *)0x41);
          v38 = *v35;
        }
        v104 = db_get_id_for_string(v38, "com.apple.xcode.docset");
        if (v104 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v104 & 0x7FFFFFFF), (const void *)0x42);
          v38 = *v35;
        }
        v105 = db_get_id_for_string(v38, "com.apple.xcode.projectdata");
        if (v105 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v105 & 0x7FFFFFFF), (const void *)0x43);
          v38 = *v35;
        }
        v106 = db_get_id_for_string(v38, "com.apple.xcode.dsym");
        if (v106 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v106 & 0x7FFFFFFF), (const void *)0x44);
          v38 = *v35;
        }
        v107 = db_get_id_for_string(v38, "com.apple.xcode.configsettings");
        if (v107 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v107 & 0x7FFFFFFF), (const void *)0x45);
          v38 = *v35;
        }
        v108 = db_get_id_for_string(v38, "com.apple.xcode.usersettings");
        if (v108 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v108 & 0x7FFFFFFF), (const void *)0x46);
          v38 = *v35;
        }
        v109 = db_get_id_for_string(v38, "com.apple.xcode.strings-text");
        if (v109 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v109 & 0x7FFFFFFF), (const void *)0x47);
          v38 = *v35;
        }
        v110 = db_get_id_for_string(v38, "com.apple.xcode.plugin");
        if (v110 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v110 & 0x7FFFFFFF), (const void *)0x48);
          v38 = *v35;
        }
        v111 = db_get_id_for_string(v38, "com.apple.xcode.mom");
        if (v111 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v111 & 0x7FFFFFFF), (const void *)0x49);
          v38 = *v35;
        }
        v112 = db_get_id_for_string(v38, "com.apple.property-list");
        if (v112 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v112 & 0x7FFFFFFF), (const void *)0x4A);
          v38 = *v35;
        }
        v113 = db_get_id_for_string(v38, "dyn.ah62d4rv4ge81a7dk");
        if (v113 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v113 & 0x7FFFFFFF), (const void *)0x4B);
          v38 = *v35;
        }
        v114 = db_get_id_for_string(v38, "dyn.ah62d4rv4ge80u5pbsa");
        if (v114 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v114 & 0x7FFFFFFF), (const void *)0x4C);
          v38 = *v35;
        }
        v115 = db_get_id_for_string(v38, "com.apple.dashcode.xml");
        if (v115 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v115 & 0x7FFFFFFF), (const void *)0x4D);
          v38 = *v35;
        }
        v116 = db_get_id_for_string(v38, "com.apple.dashcode.css");
        if (v116 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v116 & 0x7FFFFFFF), (const void *)0x4E);
          v38 = *v35;
        }
        v117 = db_get_id_for_string(v38, "com.apple.dashcode.javascript");
        if (v117 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v117 & 0x7FFFFFFF), (const void *)0x4F);
          v38 = *v35;
        }
        v118 = db_get_id_for_string(v38, "com.apple.dashcode.json");
        if (v118 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v118 & 0x7FFFFFFF), (const void *)0x50);
          v38 = *v35;
        }
        v119 = db_get_id_for_string(v38, "com.apple.dashcode.manifest");
        if (v119 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v119 & 0x7FFFFFFF), (const void *)0x51);
          v38 = *v35;
        }
        v120 = db_get_id_for_string(v38, "com.apple.interfacebuilder.document");
        if (v120 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v120 & 0x7FFFFFFF), (const void *)0x52);
          v38 = *v35;
        }
        v121 = db_get_id_for_string(v38, "com.apple.interfacebuilder.document.cocoa");
        if (v121 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v121 & 0x7FFFFFFF), (const void *)0x53);
          v38 = *v35;
        }
        v122 = db_get_id_for_string(v38, "com.apple.rez-source");
        if (v122 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v122 & 0x7FFFFFFF), (const void *)0x54);
          v38 = *v35;
        }
        v123 = db_get_id_for_string(v38, "com.apple.iphone.developerprofile");
        if (v123 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v123 & 0x7FFFFFFF), (const void *)0x55);
          v38 = *v35;
        }
        v124 = db_get_id_for_string(v38, "com.apple.iphone.mobileprovision");
        if (v124 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v124 & 0x7FFFFFFF), (const void *)0x56);
          v38 = *v35;
        }
        v125 = db_get_id_for_string(v38, "com.apple.coreanimation-bundle");
        if (v125 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v125 & 0x7FFFFFFF), (const void *)0x57);
          v38 = *v35;
        }
        v126 = db_get_id_for_string(v38, "com.apple.coreanimation-xml");
        if (v126 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v126 & 0x7FFFFFFF), (const void *)0x58);
          v38 = *v35;
        }
        v127 = db_get_id_for_string(v38, "com.sun.java-class");
        if (v127 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v127 & 0x7FFFFFFF), (const void *)0x59);
          v38 = *v35;
        }
        v128 = db_get_id_for_string(v38, "com.apple.scripting-definition");
        if (v128 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v128 & 0x7FFFFFFF), (const void *)0x5A);
          v38 = *v35;
        }
        v129 = db_get_id_for_string(v38, "com.apple.dt.document.workspace");
        if (v129 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v129 & 0x7FFFFFFF), (const void *)0x5B);
          v38 = *v35;
        }
        v130 = db_get_id_for_string(v38, "com.apple.dt.document.scheme");
        if (v130 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v130 & 0x7FFFFFFF), (const void *)0x5C);
          v38 = *v35;
        }
        v131 = db_get_id_for_string(v38, "com.apple.dt.ide.plug-in");
        if (v131 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v131 & 0x7FFFFFFF), (const void *)0x5D);
          v38 = *v35;
        }
        v132 = db_get_id_for_string(v38, "com.apple.dt.dvt.plug-in");
        if (v132 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v132 & 0x7FFFFFFF), (const void *)0x5E);
          v38 = *v35;
        }
        v133 = db_get_id_for_string(v38, "com.apple.dt.document.snapshot");
        if (v133 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v133 & 0x7FFFFFFF), (const void *)0x5F);
          v38 = *v35;
        }
        v134 = db_get_id_for_string(v38, "com.apple.dt.bundle.unit-test.objective-c");
        if (v134 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v134 & 0x7FFFFFFF), (const void *)0x60);
          v38 = *v35;
        }
        v135 = db_get_id_for_string(v38, "com.apple.instruments.tracetemplate");
        if (v135 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v135 & 0x7FFFFFFF), (const void *)0x61);
          v38 = *v35;
        }
        v136 = db_get_id_for_string(v38, "com.apple.quartzdebug.introspectiontrace");
        if (v136 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v136 & 0x7FFFFFFF), (const void *)0x62);
          v38 = *v35;
        }
        v137 = db_get_id_for_string(v38, "com.apple.applescript.text-object");
        if (v137 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v137 & 0x7FFFFFFF), (const void *)0x63);
          v38 = *v35;
        }
        v138 = db_get_id_for_string(v38, "com.apple.applescript.data-object");
        if (v138 != -2)
          CFDictionarySetValue(v37, (const void *)(v138 & 0x7FFFFFFF), (const void *)0x64);
        v139 = *v35;
        v140 = db_get_id_for_string(*v35, "com.apple.applescript.url-object");
        if (v140 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v140 & 0x7FFFFFFF), (const void *)0x65);
          v139 = *v35;
        }
        v141 = db_get_id_for_string(v139, "com.apple.applescript.alias-object");
        if (v141 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v141 & 0x7FFFFFFF), (const void *)0x66);
          v139 = *v35;
        }
        v142 = db_get_id_for_string(v139, "com.apple.symbol-export");
        if (v142 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v142 & 0x7FFFFFFF), (const void *)0x67);
          v139 = *v35;
        }
        v143 = db_get_id_for_string(v139, "com.apple.mach-o-binary");
        if (v143 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v143 & 0x7FFFFFFF), (const void *)0x68);
          v139 = *v35;
        }
        v144 = db_get_id_for_string(v139, "com.apple.mach-o-object");
        if (v144 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v144 & 0x7FFFFFFF), (const void *)0x69);
          v139 = *v35;
        }
        v145 = db_get_id_for_string(v139, "com.apple.mach-o-executable");
        if (v145 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v145 & 0x7FFFFFFF), (const void *)0x6A);
          v139 = *v35;
        }
        v146 = db_get_id_for_string(v139, "com.apple.x11-mach-o-executable");
        if (v146 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v146 & 0x7FFFFFFF), (const void *)0x6B);
          v139 = *v35;
        }
        v147 = db_get_id_for_string(v139, "public.object-code");
        if (v147 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v147 & 0x7FFFFFFF), (const void *)0x6C);
          v139 = *v35;
        }
        v148 = db_get_id_for_string(v139, "com.microsoft.windows-executable");
        if (v148 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v148 & 0x7FFFFFFF), (const void *)0x6D);
          v139 = *v35;
        }
        v149 = db_get_id_for_string(v139, "com.microsoft.windows-dynamic-link-library");
        if (v149 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v149 & 0x7FFFFFFF), (const void *)0x6E);
          v139 = *v35;
        }
        v150 = db_get_id_for_string(v139, "com.sun.java-archive");
        if (v150 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v150 & 0x7FFFFFFF), (const void *)0x6F);
          v139 = *v35;
        }
        v151 = db_get_id_for_string(v139, "com.sun.web-application-archive");
        if (v151 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v151 & 0x7FFFFFFF), (const void *)0x70);
          v139 = *v35;
        }
        v152 = db_get_id_for_string(v139, "com.apple.xcode.plugindata");
        if (v152 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v152 & 0x7FFFFFFF), (const void *)0x71);
          v139 = *v35;
        }
        v153 = db_get_id_for_string(v139, "com.apple.dt.playground");
        if (v153 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v153 & 0x7FFFFFFF), (const void *)0x72);
          v139 = *v35;
        }
        v154 = db_get_id_for_string(v139, "com.apple.iwork.numbers.sffnumbers");
        if (v154 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v154 & 0x7FFFFFFF), (const void *)0x73);
          v139 = *v35;
        }
        v155 = db_get_id_for_string(v139, "com.apple.iwork.numbers.numbers");
        if (v155 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v155 & 0x7FFFFFFF), (const void *)0x74);
          v139 = *v35;
        }
        v156 = db_get_id_for_string(v139, "com.apple.iwork.numbers.template");
        if (v156 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v156 & 0x7FFFFFFF), (const void *)0x75);
          v139 = *v35;
        }
        v157 = db_get_id_for_string(v139, "com.microsoft.excel.xls");
        if (v157 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v157 & 0x7FFFFFFF), (const void *)0x76);
          v139 = *v35;
        }
        v158 = db_get_id_for_string(v139, "org.openxmlformats.spreadsheetml.sheet");
        if (v158 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v158 & 0x7FFFFFFF), (const void *)0x77);
          v139 = *v35;
        }
        v159 = db_get_id_for_string(v139, "public.spreadsheet");
        if (v159 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v159 & 0x7FFFFFFF), (const void *)0x78);
          v139 = *v35;
        }
        v160 = db_get_id_for_string(v139, "public.xml");
        if (v160 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v160 & 0x7FFFFFFF), (const void *)0x79);
          v139 = *v35;
        }
        v161 = db_get_id_for_string(v139, "com.apple.log");
        if (v161 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v161 & 0x7FFFFFFF), (const void *)0x7A);
          v139 = *v35;
        }
        v162 = db_get_id_for_string(v139, "com.apple.crashreport");
        if (v162 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v162 & 0x7FFFFFFF), (const void *)0x7B);
          v139 = *v35;
        }
        v163 = db_get_id_for_string(v139, "com.apple.spinreport");
        if (v163 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v163 & 0x7FFFFFFF), (const void *)0x7C);
          v139 = *v35;
        }
        v164 = db_get_id_for_string(v139, "com.apple.panicreport");
        if (v164 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v164 & 0x7FFFFFFF), (const void *)0x7D);
          v139 = *v35;
        }
        v165 = db_get_id_for_string(v139, "com.apple.shutdownstall");
        if (v165 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v165 & 0x7FFFFFFF), (const void *)0x7E);
          v139 = *v35;
        }
        v166 = db_get_id_for_string(v139, "com.apple.hangreport");
        if (v166 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v166 & 0x7FFFFFFF), (const void *)0x7F);
          v139 = *v35;
        }
        v167 = db_get_id_for_string(v139, "public.json");
        if (v167 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v167 & 0x7FFFFFFF), (const void *)0x80);
          v139 = *v35;
        }
        v168 = db_get_id_for_string(v139, "public.log");
        if (v168 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v168 & 0x7FFFFFFF), (const void *)0x81);
          v139 = *v35;
        }
        v169 = db_get_id_for_string(v139, "public.content");
        if (v169 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v169 & 0x7FFFFFFF), (const void *)0x82);
          v139 = *v35;
        }
        v170 = db_get_id_for_string(v139, "com.microsoft.excel.sheet.binary.macroenabled");
        if (v170 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v170 & 0x7FFFFFFF), (const void *)0x83);
          v139 = *v35;
        }
        v171 = db_get_id_for_string(v139, "org.openxmlformats.spreadsheetml.sheet.macroenabled");
        if (v171 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v171 & 0x7FFFFFFF), (const void *)0x84);
          v139 = *v35;
        }
        v172 = db_get_id_for_string(v139, "com.apple.protected-mpeg-4-audio-b");
        if (v172 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v172 & 0x7FFFFFFF), (const void *)0x85);
          v139 = *v35;
        }
        v173 = db_get_id_for_string(v139, "com.audible.aa-audiobook");
        if (v173 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v173 & 0x7FFFFFFF), (const void *)0x86);
          v139 = *v35;
        }
        v174 = db_get_id_for_string(v139, "com.audible.aax-audiobook");
        if (v174 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v174 & 0x7FFFFFFF), (const void *)0x87);
          v139 = *v35;
        }
        v175 = db_get_id_for_string(v139, "com.apple.tips");
        if (v175 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v175 & 0x7FFFFFFF), (const void *)0x88);
          v139 = *v35;
        }
        v176 = db_get_id_for_string(v139, "com.apple.helpviewer");
        if (v176 != -2)
        {
          CFDictionarySetValue(v37, (const void *)(v176 & 0x7FFFFFFF), (const void *)0x89);
          v139 = *v35;
        }
        v177 = db_get_id_for_string(v139, "com.apple.help.topic");
        if (v177 != -2)
          CFDictionarySetValue(v37, (const void *)(v177 & 0x7FFFFFFF), (const void *)0x8A);
        *(_QWORD *)(a1 + 6608) = CFDictionaryCreateCopy(v36, v37);
        CFRelease(v37);
      }
      v178 = "kMDItemPhysicalSize";
    }
    *(_DWORD *)(a1 + 2012) = db_get_id_for_field(*(int **)(a1 + 1184), v178);
    id_for_field = db_get_id_for_field(*(int **)(a1 + 1184), "kMDItemWhereFroms");
  }
  else
  {
    if ((a2 & 0x100) != 0)
    {
      v319 = "_kMDItemStorageSize";
    }
    else
    {
      if (!*(_QWORD *)(a1 + 6608))
      {
        v179 = *v16;
        v180 = CFDictionaryCreateMutable(*v16, 0, 0, 0);
        id_for_value = db_create_id_for_value(*v35, "public.message");
        if (id_for_value != -2)
          CFDictionarySetValue(v180, (const void *)(id_for_value & 0x7FFFFFFF), (const void *)1);
        v182 = db_create_id_for_value(*v35, "com.apple.mail.emlx");
        if (v182 != -2)
          CFDictionarySetValue(v180, (const void *)(v182 & 0x7FFFFFFF), (const void *)2);
        v183 = db_create_id_for_value(*v35, "com.apple.mail.eml");
        if (v183 != -2)
          CFDictionarySetValue(v180, (const void *)(v183 & 0x7FFFFFFF), (const void *)3);
        v184 = db_create_id_for_value(*v35, "com.microsoft.entourage.virtual.message");
        if (v184 != -2)
          CFDictionarySetValue(v180, (const void *)(v184 & 0x7FFFFFFF), (const void *)4);
        v185 = db_create_id_for_value(*v35, "com.apple.ichat.transcript");
        if (v185 != -2)
          CFDictionarySetValue(v180, (const void *)(v185 & 0x7FFFFFFF), (const void *)5);
        v186 = db_create_id_for_value(*v35, "public.contact");
        if (v186 != -2)
          CFDictionarySetValue(v180, (const void *)(v186 & 0x7FFFFFFF), (const void *)6);
        v187 = db_create_id_for_value(*v35, "public.vcard");
        if (v187 != -2)
          CFDictionarySetValue(v180, (const void *)(v187 & 0x7FFFFFFF), (const void *)7);
        v188 = db_create_id_for_value(*v35, "com.apple.addressbook.person");
        if (v188 != -2)
          CFDictionarySetValue(v180, (const void *)(v188 & 0x7FFFFFFF), (const void *)8);
        v189 = db_create_id_for_value(*v35, "com.apple.addressbook.group");
        if (v189 != -2)
          CFDictionarySetValue(v180, (const void *)(v189 & 0x7FFFFFFF), (const void *)9);
        v190 = db_create_id_for_value(*v35, "com.microsoft.entourage.virtual.contact");
        if (v190 != -2)
          CFDictionarySetValue(v180, (const void *)(v190 & 0x7FFFFFFF), (const void *)0xA);
        v191 = db_create_id_for_value(*v35, "com.microsoft.entourage.virtual.group");
        if (v191 != -2)
          CFDictionarySetValue(v180, (const void *)(v191 & 0x7FFFFFFF), (const void *)0xB);
        v192 = db_create_id_for_value(*v35, "com.apple.systempreference.prefpane");
        if (v192 != -2)
          CFDictionarySetValue(v180, (const void *)(v192 & 0x7FFFFFFF), (const void *)0xC);
        v193 = db_create_id_for_value(*v35, "public.font");
        if (v193 != -2)
          CFDictionarySetValue(v180, (const void *)(v193 & 0x7FFFFFFF), (const void *)0xD);
        v194 = db_create_id_for_value(*v35, "public.bookmark");
        if (v194 != -2)
          CFDictionarySetValue(v180, (const void *)(v194 & 0x7FFFFFFF), (const void *)0xE);
        v195 = db_create_id_for_value(*v35, "com.apple.safari.bookmark");
        if (v195 != -2)
          CFDictionarySetValue(v180, (const void *)(v195 & 0x7FFFFFFF), (const void *)0xF);
        v196 = db_create_id_for_value(*v35, "com.apple.safari.history");
        if (v196 != -2)
          CFDictionarySetValue(v180, (const void *)(v196 & 0x7FFFFFFF), (const void *)0x10);
        v197 = db_create_id_for_value(*v35, "public.to-do-item");
        if (v197 != -2)
          CFDictionarySetValue(v180, (const void *)(v197 & 0x7FFFFFFF), (const void *)0x11);
        v198 = db_create_id_for_value(*v35, "public.calendar-event");
        if (v198 != -2)
          CFDictionarySetValue(v180, (const void *)(v198 & 0x7FFFFFFF), (const void *)0x12);
        v199 = db_create_id_for_value(*v35, "com.apple.ical.bookmark");
        if (v199 != -2)
          CFDictionarySetValue(v180, (const void *)(v199 & 0x7FFFFFFF), (const void *)0x13);
        v200 = db_create_id_for_value(*v35, "com.apple.ical.bookmark.todo");
        if (v200 != -2)
          CFDictionarySetValue(v180, (const void *)(v200 & 0x7FFFFFFF), (const void *)0x14);
        v201 = db_create_id_for_value(*v35, "com.apple.ical.ics.event");
        if (v201 != -2)
          CFDictionarySetValue(v180, (const void *)(v201 & 0x7FFFFFFF), (const void *)0x15);
        v202 = db_create_id_for_value(*v35, "com.apple.ical.ics.todo");
        if (v202 != -2)
          CFDictionarySetValue(v180, (const void *)(v202 & 0x7FFFFFFF), (const void *)0x16);
        v203 = db_create_id_for_value(*v35, "com.microsoft.entourage.virtual.event");
        if (v203 != -2)
          CFDictionarySetValue(v180, (const void *)(v203 & 0x7FFFFFFF), (const void *)0x17);
        v204 = db_create_id_for_value(*v35, "com.microsoft.entourage.virtual.task");
        if (v204 != -2)
          CFDictionarySetValue(v180, (const void *)(v204 & 0x7FFFFFFF), (const void *)0x18);
        v205 = db_create_id_for_value(*v35, "public.movie");
        if (v205 != -2)
          CFDictionarySetValue(v180, (const void *)(v205 & 0x7FFFFFFF), (const void *)0x19);
        v206 = db_create_id_for_value(*v35, "com.apple.quicktime-movie");
        if (v206 != -2)
          CFDictionarySetValue(v180, (const void *)(v206 & 0x7FFFFFFF), (const void *)0x1A);
        v207 = db_create_id_for_value(*v35, "public.mpeg-video");
        if (v207 != -2)
          CFDictionarySetValue(v180, (const void *)(v207 & 0x7FFFFFFF), (const void *)0x1B);
        v208 = db_create_id_for_value(*v35, "public.mpeg-4");
        if (v208 != -2)
          CFDictionarySetValue(v180, (const void *)(v208 & 0x7FFFFFFF), (const void *)0x1C);
        v209 = db_create_id_for_value(*v35, "public.mpeg");
        if (v209 != -2)
          CFDictionarySetValue(v180, (const void *)(v209 & 0x7FFFFFFF), (const void *)0x1D);
        v210 = db_create_id_for_value(*v35, "public.3gpp");
        if (v210 != -2)
          CFDictionarySetValue(v180, (const void *)(v210 & 0x7FFFFFFF), (const void *)0x1E);
        v211 = db_create_id_for_value(*v35, "public.3gpp2");
        if (v211 != -2)
          CFDictionarySetValue(v180, (const void *)(v211 & 0x7FFFFFFF), (const void *)0x1F);
        v212 = db_create_id_for_value(*v35, "com.apple.application-bundle");
        if (v212 != -2)
          CFDictionarySetValue(v180, (const void *)(v212 & 0x7FFFFFFF), (const void *)0x20);
        v213 = db_create_id_for_value(*v35, "com.apple.application-file");
        if (v213 != -2)
          CFDictionarySetValue(v180, (const void *)(v213 & 0x7FFFFFFF), (const void *)0x21);
        v214 = db_create_id_for_value(*v35, "com.apple.dashboard-widget");
        if (v214 != -2)
          CFDictionarySetValue(v180, (const void *)(v214 & 0x7FFFFFFF), (const void *)0x22);
        v215 = db_create_id_for_value(*v35, "public.folder");
        if (v215 != -2)
          CFDictionarySetValue(v180, (const void *)(v215 & 0x7FFFFFFF), (const void *)0x23);
        v216 = db_create_id_for_value(*v35, "com.apple.mount-point");
        if (v216 != -2)
          CFDictionarySetValue(v180, (const void *)(v216 & 0x7FFFFFFF), (const void *)0x24);
        v217 = db_create_id_for_value(*v35, "public.audio");
        if (v217 != -2)
          CFDictionarySetValue(v180, (const void *)(v217 & 0x7FFFFFFF), (const void *)0x25);
        v218 = db_create_id_for_value(*v35, "public.mpeg-4-audio");
        if (v218 != -2)
          CFDictionarySetValue(v180, (const void *)(v218 & 0x7FFFFFFF), (const void *)0x26);
        v219 = db_create_id_for_value(*v35, "com.apple.protected-mpeg-4-audio");
        if (v219 != -2)
          CFDictionarySetValue(v180, (const void *)(v219 & 0x7FFFFFFF), (const void *)0x27);
        v220 = db_create_id_for_value(*v35, "com.adobe.pdf");
        if (v220 != -2)
          CFDictionarySetValue(v180, (const void *)(v220 & 0x7FFFFFFF), (const void *)0x28);
        v221 = db_create_id_for_value(*v35, "com.apple.localized-pdf-bundle");
        if (v221 != -2)
          CFDictionarySetValue(v180, (const void *)(v221 & 0x7FFFFFFF), (const void *)0x29);
        v222 = db_create_id_for_value(*v35, "public.presentation");
        if (v222 != -2)
          CFDictionarySetValue(v180, (const void *)(v222 & 0x7FFFFFFF), (const void *)0x2A);
        v223 = db_create_id_for_value(*v35, "com.microsoft.powerpoint.ppt");
        if (v223 != -2)
          CFDictionarySetValue(v180, (const void *)(v223 & 0x7FFFFFFF), (const void *)0x2B);
        v224 = db_create_id_for_value(*v35, "com.apple.keynote.key");
        if (v224 != -2)
          CFDictionarySetValue(v180, (const void *)(v224 & 0x7FFFFFFF), (const void *)0x2C);
        v225 = db_create_id_for_value(*v35, "com.apple.iwork.keynote.key");
        if (v225 != -2)
          CFDictionarySetValue(v180, (const void *)(v225 & 0x7FFFFFFF), (const void *)0x2D);
        v226 = db_create_id_for_value(*v35, "public.image");
        if (v226 != -2)
          CFDictionarySetValue(v180, (const void *)(v226 & 0x7FFFFFFF), (const void *)0x2E);
        v227 = db_create_id_for_value(*v35, "com.apple.motion.project");
        if (v227 != -2)
          CFDictionarySetValue(v180, (const void *)(v227 & 0x7FFFFFFF), (const void *)0x2F);
        v228 = db_create_id_for_value(*v35, "com.apple.iwork.pages.pages");
        if (v228 != -2)
          CFDictionarySetValue(v180, (const void *)(v228 & 0x7FFFFFFF), (const void *)0x30);
        v229 = db_create_id_for_value(*v35, "com.apple.iwork.pages.sffpages");
        if (v229 != -2)
          CFDictionarySetValue(v180, (const void *)(v229 & 0x7FFFFFFF), (const void *)0x31);
        v230 = db_create_id_for_value(*v35, "com.apple.iwork.pages.template");
        if (v230 != -2)
          CFDictionarySetValue(v180, (const void *)(v230 & 0x7FFFFFFF), (const void *)0x32);
        v231 = db_create_id_for_value(*v35, "com.apple.iwork.pages.sfftemplate");
        if (v231 != -2)
          CFDictionarySetValue(v180, (const void *)(v231 & 0x7FFFFFFF), (const void *)0x33);
        v232 = db_create_id_for_value(*v35, "public.rtf");
        if (v232 != -2)
          CFDictionarySetValue(v180, (const void *)(v232 & 0x7FFFFFFF), (const void *)0x34);
        v233 = db_create_id_for_value(*v35, "com.apple.rtfd");
        if (v233 != -2)
          CFDictionarySetValue(v180, (const void *)(v233 & 0x7FFFFFFF), (const void *)0x35);
        v234 = db_create_id_for_value(*v35, "com.apple.flat-rtfd");
        if (v234 != -2)
          CFDictionarySetValue(v180, (const void *)(v234 & 0x7FFFFFFF), (const void *)0x36);
        v235 = db_create_id_for_value(*v35, "com.microsoft.word.doc");
        if (v235 != -2)
          CFDictionarySetValue(v180, (const void *)(v235 & 0x7FFFFFFF), (const void *)0x37);
        v236 = db_create_id_for_value(*v35, "org.khronos.collada.digital-asset-exchange");
        if (v236 != -2)
          CFDictionarySetValue(v180, (const void *)(v236 & 0x7FFFFFFF), (const void *)0x38);
        v237 = db_create_id_for_value(*v35, "public.plain-text");
        if (v237 != -2)
          CFDictionarySetValue(v180, (const void *)(v237 & 0x7FFFFFFF), (const void *)0x39);
        v238 = db_create_id_for_value(*v35, "public.html");
        if (v238 != -2)
          CFDictionarySetValue(v180, (const void *)(v238 & 0x7FFFFFFF), (const void *)0x3A);
        v239 = db_create_id_for_value(*v35, "public.xhtml");
        if (v239 != -2)
          CFDictionarySetValue(v180, (const void *)(v239 & 0x7FFFFFFF), (const void *)0x3B);
        v240 = db_create_id_for_value(*v35, "public.shell-script");
        if (v240 != -2)
          CFDictionarySetValue(v180, (const void *)(v240 & 0x7FFFFFFF), (const void *)0x3C);
        v241 = db_create_id_for_value(*v35, "public.source-code");
        if (v241 != -2)
          CFDictionarySetValue(v180, (const void *)(v241 & 0x7FFFFFFF), (const void *)0x3D);
        v242 = db_create_id_for_value(*v35, "public.unix-executable");
        if (v242 != -2)
          CFDictionarySetValue(v180, (const void *)(v242 & 0x7FFFFFFF), (const void *)0x3E);
        v243 = db_create_id_for_value(*v35, "com.apple.xcode.project");
        if (v243 != -2)
          CFDictionarySetValue(v180, (const void *)(v243 & 0x7FFFFFFF), (const void *)0x3F);
        v244 = db_create_id_for_value(*v35, "com.apple.xcode.model");
        if (v244 != -2)
          CFDictionarySetValue(v180, (const void *)(v244 & 0x7FFFFFFF), (const void *)0x40);
        v245 = db_create_id_for_value(*v35, "com.apple.xcode.archive");
        if (v245 != -2)
          CFDictionarySetValue(v180, (const void *)(v245 & 0x7FFFFFFF), (const void *)0x41);
        v246 = db_create_id_for_value(*v35, "com.apple.xcode.docset");
        if (v246 != -2)
          CFDictionarySetValue(v180, (const void *)(v246 & 0x7FFFFFFF), (const void *)0x42);
        v247 = db_create_id_for_value(*v35, "com.apple.xcode.projectdata");
        if (v247 != -2)
          CFDictionarySetValue(v180, (const void *)(v247 & 0x7FFFFFFF), (const void *)0x43);
        v248 = db_create_id_for_value(*v35, "com.apple.xcode.dsym");
        if (v248 != -2)
          CFDictionarySetValue(v180, (const void *)(v248 & 0x7FFFFFFF), (const void *)0x44);
        v249 = db_create_id_for_value(*v35, "com.apple.xcode.configsettings");
        if (v249 != -2)
          CFDictionarySetValue(v180, (const void *)(v249 & 0x7FFFFFFF), (const void *)0x45);
        v250 = db_create_id_for_value(*v35, "com.apple.xcode.usersettings");
        if (v250 != -2)
          CFDictionarySetValue(v180, (const void *)(v250 & 0x7FFFFFFF), (const void *)0x46);
        v251 = db_create_id_for_value(*v35, "com.apple.xcode.strings-text");
        if (v251 != -2)
          CFDictionarySetValue(v180, (const void *)(v251 & 0x7FFFFFFF), (const void *)0x47);
        v252 = db_create_id_for_value(*v35, "com.apple.xcode.plugin");
        if (v252 != -2)
          CFDictionarySetValue(v180, (const void *)(v252 & 0x7FFFFFFF), (const void *)0x48);
        v253 = db_create_id_for_value(*v35, "com.apple.xcode.mom");
        if (v253 != -2)
          CFDictionarySetValue(v180, (const void *)(v253 & 0x7FFFFFFF), (const void *)0x49);
        v254 = db_create_id_for_value(*v35, "com.apple.property-list");
        if (v254 != -2)
          CFDictionarySetValue(v180, (const void *)(v254 & 0x7FFFFFFF), (const void *)0x4A);
        v255 = db_create_id_for_value(*v35, "dyn.ah62d4rv4ge81a7dk");
        if (v255 != -2)
          CFDictionarySetValue(v180, (const void *)(v255 & 0x7FFFFFFF), (const void *)0x4B);
        v256 = db_create_id_for_value(*v35, "dyn.ah62d4rv4ge80u5pbsa");
        if (v256 != -2)
          CFDictionarySetValue(v180, (const void *)(v256 & 0x7FFFFFFF), (const void *)0x4C);
        v257 = db_create_id_for_value(*v35, "com.apple.dashcode.xml");
        if (v257 != -2)
          CFDictionarySetValue(v180, (const void *)(v257 & 0x7FFFFFFF), (const void *)0x4D);
        v258 = db_create_id_for_value(*v35, "com.apple.dashcode.css");
        if (v258 != -2)
          CFDictionarySetValue(v180, (const void *)(v258 & 0x7FFFFFFF), (const void *)0x4E);
        v259 = db_create_id_for_value(*v35, "com.apple.dashcode.javascript");
        if (v259 != -2)
          CFDictionarySetValue(v180, (const void *)(v259 & 0x7FFFFFFF), (const void *)0x4F);
        v260 = db_create_id_for_value(*v35, "com.apple.dashcode.json");
        if (v260 != -2)
          CFDictionarySetValue(v180, (const void *)(v260 & 0x7FFFFFFF), (const void *)0x50);
        v261 = db_create_id_for_value(*v35, "com.apple.dashcode.manifest");
        if (v261 != -2)
          CFDictionarySetValue(v180, (const void *)(v261 & 0x7FFFFFFF), (const void *)0x51);
        v262 = db_create_id_for_value(*v35, "com.apple.interfacebuilder.document");
        if (v262 != -2)
          CFDictionarySetValue(v180, (const void *)(v262 & 0x7FFFFFFF), (const void *)0x52);
        v263 = db_create_id_for_value(*v35, "com.apple.interfacebuilder.document.cocoa");
        if (v263 != -2)
          CFDictionarySetValue(v180, (const void *)(v263 & 0x7FFFFFFF), (const void *)0x53);
        v264 = db_create_id_for_value(*v35, "com.apple.rez-source");
        if (v264 != -2)
          CFDictionarySetValue(v180, (const void *)(v264 & 0x7FFFFFFF), (const void *)0x54);
        v265 = db_create_id_for_value(*v35, "com.apple.iphone.developerprofile");
        if (v265 != -2)
          CFDictionarySetValue(v180, (const void *)(v265 & 0x7FFFFFFF), (const void *)0x55);
        v266 = db_create_id_for_value(*v35, "com.apple.iphone.mobileprovision");
        if (v266 != -2)
          CFDictionarySetValue(v180, (const void *)(v266 & 0x7FFFFFFF), (const void *)0x56);
        v267 = db_create_id_for_value(*v35, "com.apple.coreanimation-bundle");
        if (v267 != -2)
          CFDictionarySetValue(v180, (const void *)(v267 & 0x7FFFFFFF), (const void *)0x57);
        v268 = db_create_id_for_value(*v35, "com.apple.coreanimation-xml");
        if (v268 != -2)
          CFDictionarySetValue(v180, (const void *)(v268 & 0x7FFFFFFF), (const void *)0x58);
        v269 = db_create_id_for_value(*v35, "com.sun.java-class");
        if (v269 != -2)
          CFDictionarySetValue(v180, (const void *)(v269 & 0x7FFFFFFF), (const void *)0x59);
        v270 = db_create_id_for_value(*v35, "com.apple.scripting-definition");
        if (v270 != -2)
          CFDictionarySetValue(v180, (const void *)(v270 & 0x7FFFFFFF), (const void *)0x5A);
        v271 = db_create_id_for_value(*v35, "com.apple.dt.document.workspace");
        if (v271 != -2)
          CFDictionarySetValue(v180, (const void *)(v271 & 0x7FFFFFFF), (const void *)0x5B);
        v272 = db_create_id_for_value(*v35, "com.apple.dt.document.scheme");
        if (v272 != -2)
          CFDictionarySetValue(v180, (const void *)(v272 & 0x7FFFFFFF), (const void *)0x5C);
        v273 = db_create_id_for_value(*v35, "com.apple.dt.ide.plug-in");
        if (v273 != -2)
          CFDictionarySetValue(v180, (const void *)(v273 & 0x7FFFFFFF), (const void *)0x5D);
        v274 = db_create_id_for_value(*v35, "com.apple.dt.dvt.plug-in");
        if (v274 != -2)
          CFDictionarySetValue(v180, (const void *)(v274 & 0x7FFFFFFF), (const void *)0x5E);
        v275 = db_create_id_for_value(*v35, "com.apple.dt.document.snapshot");
        if (v275 != -2)
          CFDictionarySetValue(v180, (const void *)(v275 & 0x7FFFFFFF), (const void *)0x5F);
        v276 = db_create_id_for_value(*v35, "com.apple.dt.bundle.unit-test.objective-c");
        if (v276 != -2)
          CFDictionarySetValue(v180, (const void *)(v276 & 0x7FFFFFFF), (const void *)0x60);
        v277 = db_create_id_for_value(*v35, "com.apple.instruments.tracetemplate");
        if (v277 != -2)
          CFDictionarySetValue(v180, (const void *)(v277 & 0x7FFFFFFF), (const void *)0x61);
        v278 = db_create_id_for_value(*v35, "com.apple.quartzdebug.introspectiontrace");
        if (v278 != -2)
          CFDictionarySetValue(v180, (const void *)(v278 & 0x7FFFFFFF), (const void *)0x62);
        v279 = db_create_id_for_value(*v35, "com.apple.applescript.text-object");
        if (v279 != -2)
          CFDictionarySetValue(v180, (const void *)(v279 & 0x7FFFFFFF), (const void *)0x63);
        v280 = db_create_id_for_value(*v35, "com.apple.applescript.data-object");
        if (v280 != -2)
          CFDictionarySetValue(v180, (const void *)(v280 & 0x7FFFFFFF), (const void *)0x64);
        v281 = db_create_id_for_value(*v35, "com.apple.applescript.url-object");
        if (v281 != -2)
          CFDictionarySetValue(v180, (const void *)(v281 & 0x7FFFFFFF), (const void *)0x65);
        v282 = db_create_id_for_value(*v35, "com.apple.applescript.alias-object");
        if (v282 != -2)
          CFDictionarySetValue(v180, (const void *)(v282 & 0x7FFFFFFF), (const void *)0x66);
        v283 = db_create_id_for_value(*v35, "com.apple.symbol-export");
        if (v283 != -2)
          CFDictionarySetValue(v180, (const void *)(v283 & 0x7FFFFFFF), (const void *)0x67);
        v284 = db_create_id_for_value(*v35, "com.apple.mach-o-binary");
        if (v284 != -2)
          CFDictionarySetValue(v180, (const void *)(v284 & 0x7FFFFFFF), (const void *)0x68);
        v285 = db_create_id_for_value(*v35, "com.apple.mach-o-object");
        if (v285 != -2)
          CFDictionarySetValue(v180, (const void *)(v285 & 0x7FFFFFFF), (const void *)0x69);
        v286 = db_create_id_for_value(*v35, "com.apple.mach-o-executable");
        if (v286 != -2)
          CFDictionarySetValue(v180, (const void *)(v286 & 0x7FFFFFFF), (const void *)0x6A);
        v287 = db_create_id_for_value(*v35, "com.apple.x11-mach-o-executable");
        if (v287 != -2)
          CFDictionarySetValue(v180, (const void *)(v287 & 0x7FFFFFFF), (const void *)0x6B);
        v288 = db_create_id_for_value(*v35, "public.object-code");
        if (v288 != -2)
          CFDictionarySetValue(v180, (const void *)(v288 & 0x7FFFFFFF), (const void *)0x6C);
        v289 = db_create_id_for_value(*v35, "com.microsoft.windows-executable");
        if (v289 != -2)
          CFDictionarySetValue(v180, (const void *)(v289 & 0x7FFFFFFF), (const void *)0x6D);
        v290 = db_create_id_for_value(*v35, "com.microsoft.windows-dynamic-link-library");
        if (v290 != -2)
          CFDictionarySetValue(v180, (const void *)(v290 & 0x7FFFFFFF), (const void *)0x6E);
        v291 = db_create_id_for_value(*v35, "com.sun.java-archive");
        if (v291 != -2)
          CFDictionarySetValue(v180, (const void *)(v291 & 0x7FFFFFFF), (const void *)0x6F);
        v292 = db_create_id_for_value(*v35, "com.sun.web-application-archive");
        if (v292 != -2)
          CFDictionarySetValue(v180, (const void *)(v292 & 0x7FFFFFFF), (const void *)0x70);
        v293 = db_create_id_for_value(*v35, "com.apple.xcode.plugindata");
        if (v293 != -2)
          CFDictionarySetValue(v180, (const void *)(v293 & 0x7FFFFFFF), (const void *)0x71);
        v294 = db_create_id_for_value(*v35, "com.apple.dt.playground");
        if (v294 != -2)
          CFDictionarySetValue(v180, (const void *)(v294 & 0x7FFFFFFF), (const void *)0x72);
        v295 = db_create_id_for_value(*v35, "com.apple.iwork.numbers.sffnumbers");
        if (v295 != -2)
          CFDictionarySetValue(v180, (const void *)(v295 & 0x7FFFFFFF), (const void *)0x73);
        v296 = db_create_id_for_value(*v35, "com.apple.iwork.numbers.numbers");
        if (v296 != -2)
          CFDictionarySetValue(v180, (const void *)(v296 & 0x7FFFFFFF), (const void *)0x74);
        v297 = db_create_id_for_value(*v35, "com.apple.iwork.numbers.template");
        if (v297 != -2)
          CFDictionarySetValue(v180, (const void *)(v297 & 0x7FFFFFFF), (const void *)0x75);
        v298 = db_create_id_for_value(*v35, "com.microsoft.excel.xls");
        if (v298 != -2)
          CFDictionarySetValue(v180, (const void *)(v298 & 0x7FFFFFFF), (const void *)0x76);
        v299 = db_create_id_for_value(*v35, "org.openxmlformats.spreadsheetml.sheet");
        if (v299 != -2)
          CFDictionarySetValue(v180, (const void *)(v299 & 0x7FFFFFFF), (const void *)0x77);
        v300 = db_create_id_for_value(*v35, "public.spreadsheet");
        if (v300 != -2)
          CFDictionarySetValue(v180, (const void *)(v300 & 0x7FFFFFFF), (const void *)0x78);
        v301 = db_create_id_for_value(*v35, "public.xml");
        if (v301 != -2)
          CFDictionarySetValue(v180, (const void *)(v301 & 0x7FFFFFFF), (const void *)0x79);
        v302 = db_create_id_for_value(*v35, "com.apple.log");
        if (v302 != -2)
          CFDictionarySetValue(v180, (const void *)(v302 & 0x7FFFFFFF), (const void *)0x7A);
        v303 = db_create_id_for_value(*v35, "com.apple.crashreport");
        if (v303 != -2)
          CFDictionarySetValue(v180, (const void *)(v303 & 0x7FFFFFFF), (const void *)0x7B);
        v304 = db_create_id_for_value(*v35, "com.apple.spinreport");
        if (v304 != -2)
          CFDictionarySetValue(v180, (const void *)(v304 & 0x7FFFFFFF), (const void *)0x7C);
        v305 = db_create_id_for_value(*v35, "com.apple.panicreport");
        if (v305 != -2)
          CFDictionarySetValue(v180, (const void *)(v305 & 0x7FFFFFFF), (const void *)0x7D);
        v306 = db_create_id_for_value(*v35, "com.apple.shutdownstall");
        if (v306 != -2)
          CFDictionarySetValue(v180, (const void *)(v306 & 0x7FFFFFFF), (const void *)0x7E);
        v307 = db_create_id_for_value(*v35, "com.apple.hangreport");
        if (v307 != -2)
          CFDictionarySetValue(v180, (const void *)(v307 & 0x7FFFFFFF), (const void *)0x7F);
        v308 = db_create_id_for_value(*v35, "public.json");
        if (v308 != -2)
          CFDictionarySetValue(v180, (const void *)(v308 & 0x7FFFFFFF), (const void *)0x80);
        v309 = db_create_id_for_value(*v35, "public.log");
        if (v309 != -2)
          CFDictionarySetValue(v180, (const void *)(v309 & 0x7FFFFFFF), (const void *)0x81);
        v310 = db_create_id_for_value(*v35, "public.content");
        if (v310 != -2)
          CFDictionarySetValue(v180, (const void *)(v310 & 0x7FFFFFFF), (const void *)0x82);
        v311 = db_create_id_for_value(*v35, "com.microsoft.excel.sheet.binary.macroenabled");
        if (v311 != -2)
          CFDictionarySetValue(v180, (const void *)(v311 & 0x7FFFFFFF), (const void *)0x83);
        v312 = db_create_id_for_value(*v35, "org.openxmlformats.spreadsheetml.sheet.macroenabled");
        if (v312 != -2)
          CFDictionarySetValue(v180, (const void *)(v312 & 0x7FFFFFFF), (const void *)0x84);
        v313 = db_create_id_for_value(*v35, "com.apple.protected-mpeg-4-audio-b");
        if (v313 != -2)
          CFDictionarySetValue(v180, (const void *)(v313 & 0x7FFFFFFF), (const void *)0x85);
        v314 = db_create_id_for_value(*v35, "com.audible.aa-audiobook");
        if (v314 != -2)
          CFDictionarySetValue(v180, (const void *)(v314 & 0x7FFFFFFF), (const void *)0x86);
        v315 = db_create_id_for_value(*v35, "com.audible.aax-audiobook");
        if (v315 != -2)
          CFDictionarySetValue(v180, (const void *)(v315 & 0x7FFFFFFF), (const void *)0x87);
        v316 = db_create_id_for_value(*v35, "com.apple.tips");
        if (v316 != -2)
          CFDictionarySetValue(v180, (const void *)(v316 & 0x7FFFFFFF), (const void *)0x88);
        v317 = db_create_id_for_value(*v35, "com.apple.helpviewer");
        if (v317 != -2)
          CFDictionarySetValue(v180, (const void *)(v317 & 0x7FFFFFFF), (const void *)0x89);
        v318 = db_create_id_for_value(*v35, "com.apple.help.topic");
        if (v318 != -2)
          CFDictionarySetValue(v180, (const void *)(v318 & 0x7FFFFFFF), (const void *)0x8A);
        *(_QWORD *)(a1 + 6608) = CFDictionaryCreateCopy(v179, v180);
        CFRelease(v180);
      }
      v319 = "kMDItemPhysicalSize";
    }
    *(_DWORD *)(a1 + 2012) = db_create_id_for_field(*(_DWORD **)(a1 + 1184), v319, 0x300u, 7);
    id_for_field = db_create_id_for_field(*(_DWORD **)(a1 + 1184), "kMDItemWhereFroms", 0x220u, 11);
  }
  *(_DWORD *)(a1 + 2028) = id_for_field;
  v321 = *(int **)(a1 + 1184);
  if (*v321 != 1685287992)
  {
    v349 = *__error();
    v350 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v350, OS_LOG_TYPE_ERROR))
    {
      v351 = *v321;
      *(_DWORD *)buf = 136315650;
      v374 = "db_create_static_strings";
      v375 = 1024;
      v376 = 436;
      v377 = 1024;
      v378 = v351;
      _os_log_error_impl(&dword_1B8270000, v350, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v349;
    v352 = __si_assert_copy_extra_268();
    v342 = v352;
    v353 = "";
    if (v352)
      v353 = v352;
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 436, v353);
    goto LABEL_633;
  }
  v322 = v321[201];
  *(_WORD *)buf = 18959;
  v321[234] = _get_id_for_string((unint64_t)v321, 0, "kMDItemLanguages", 16, ((v322 >> 3) & 1) == 0, buf);
  v323 = v321[201];
  if ((v323 & 4) != 0)
    v324 = 17167;
  else
    v324 = -15601;
  *(_WORD *)buf = v324;
  v321[235] = _get_id_for_string((unint64_t)v321, 0, "kMDItemKind", 11, ((v323 >> 3) & 1) == 0, buf);
  v325 = v321[201];
  if ((v325 & 4) != 0)
    v326 = 17163;
  else
    v326 = -15605;
  *(_WORD *)buf = v326;
  v321[236] = _get_id_for_string((unint64_t)v321, 0, "kMDItemDisplayName", 18, ((v325 >> 3) & 1) == 0, buf);
  v327 = v321[201];
  if ((v327 & 4) != 0)
    v328 = 779;
  else
    v328 = -31989;
  *(_WORD *)buf = v328;
  v321[237] = _get_id_for_string((unint64_t)v321, 0, "kMDItemKeywords", 15, ((v327 >> 3) & 1) == 0, buf);
  v329 = v321[201];
  if ((v329 & 4) != 0)
    v330 = 779;
  else
    v330 = -31989;
  *(_WORD *)buf = v330;
  v321[238] = _get_id_for_string((unint64_t)v321, 0, "com_apple_system_prefs_keywords", 31, ((v329 >> 3) & 1) == 0, buf);
  v331 = v321[201];
  if ((v331 & 4) != 0)
    v332 = 783;
  else
    v332 = -31985;
  *(_WORD *)buf = v332;
  v321[239] = _get_id_for_string((unint64_t)v321, 0, "kMDItemKeywords", 15, ((v331 >> 3) & 1) == 0, buf);
  v333 = v321[201];
  if ((v333 & 4) != 0)
    v334 = 783;
  else
    v334 = -31985;
  *(_WORD *)buf = v334;
  v321[240] = _get_id_for_string((unint64_t)v321, 0, "com_apple_system_prefs_keywords", 31, ((v333 >> 3) & 1) == 0, buf);
  *(_DWORD *)(a1 + 2016) = db_create_id_for_field(*(_DWORD **)(a1 + 1184), "kMDItemDisplayName", 0x12A0u, 11);
  *(_DWORD *)(a1 + 2020) = db_create_id_for_field(*(_DWORD **)(a1 + 1184), "kMDItemLanguages", 0x330u, 11);
  *(_DWORD *)(a1 + 2036) = db_create_id_for_field(*(_DWORD **)(a1 + 1184), "kMDItemRecipientEmailAddresses", 0x220u, 11);
  *(_DWORD *)(a1 + 2040) = db_create_id_for_field(*(_DWORD **)(a1 + 1184), "kMDItemPrimaryRecipientEmailAddresses", 0x4320u, 11);
  *(_DWORD *)(a1 + 2044) = db_create_id_for_field(*(_DWORD **)(a1 + 1184), "kMDItemAdditionalRecipientEmailAddresses", 0x4320u, 11);
  *(_DWORD *)(a1 + 2048) = db_create_id_for_field(*(_DWORD **)(a1 + 1184), "kMDItemHiddenAdditionalRecipientEmailAddresses", 0x4320u, 11);
  *(_DWORD *)(a1 + 2052) = db_create_id_for_field(*(_DWORD **)(a1 + 1184), "_kMDItemDisplayNameWithExtensions", 0x228u, 11);
  v335 = *(_QWORD *)&threadData[18 * v368 + 2];
  v336 = v367;
  v337 = v335 + 320 * v367;
  *(_DWORD *)(v337 + 312) = v354;
  v338 = *(void (**)(_QWORD))(v337 + 232);
  if (v338)
    v338(*(_QWORD *)(v335 + 320 * v336 + 288));
  dropThreadId(v368, 0, v355);
  v16 = (CFAllocatorRef *)MEMORY[0x1E0C9AE00];
LABEL_619:
  v339 = *v16;
  *(_QWORD *)(a1 + 1800) = CFBagCreateMutable(*v16, 64, MEMORY[0x1E0C9B388]);
  *(_QWORD *)(a1 + 1808) = CFDictionaryCreateMutable(v339, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  return pthread_mutex_init((pthread_mutex_t *)(a1 + 1816), 0);
}

const void *SICopyProperty(uint64_t a1, const void *a2)
{
  const __CFDictionary *v4;
  const void *Value;
  const void *v6;

  if (a1 && *(_QWORD *)(a1 + 1184))
  {
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 1504));
    v4 = *(const __CFDictionary **)(a1 + 1496);
    if (!v4)
    {
      if (!si_create_propertydict(a1, 0, 0))
      {
        v6 = 0;
LABEL_10:
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1504));
        return v6;
      }
      v4 = *(const __CFDictionary **)(a1 + 1496);
    }
    Value = CFDictionaryGetValue(v4, a2);
    v6 = Value;
    if (Value)
      CFRetain(Value);
    goto LABEL_10;
  }
  return 0;
}

void si_getsizes(uint64_t a1, int a2)
{
  _DWORD *indexmetadata;
  unsigned int v5;
  int v6;
  unint64_t v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  void (*v13)(_QWORD);
  _DWORD *v14;
  int v15;
  NSObject *v16;
  char v17;
  int v18;
  NSObject *v19;
  BOOL v20;
  int v21;
  NSObject *v22;
  uint64_t v23;
  size_t v24;
  int v25;
  NSObject *v26;
  uint64_t v27;
  size_t v28;
  uint64_t v29;
  uint64_t v30;
  void (*v31)(_QWORD);
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  __int128 v35;
  uint64_t v36;
  int v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  __int128 v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  NSObject *v47;
  NSObject *log;
  int v49;
  int v50;
  __int128 v51;
  __int128 v52;
  unsigned int v53;
  unsigned int v54;
  unsigned int v55;
  unsigned int v56;
  unint64_t v57;
  void *__src;
  uint8_t buf[4];
  _BYTE v60[14];
  uint64_t v61;

  v61 = *MEMORY[0x1E0C80C00];
  if (!*(_QWORD *)(a1 + 1184))
    return;
  indexmetadata = si_create_indexmetadata(a1, 1);
  if (!indexmetadata)
  {
    v18 = *__error();
    v19 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)v60 = "si_getsizes";
      *(_WORD *)&v60[8] = 1024;
      *(_DWORD *)&v60[10] = 1227;
      _os_log_error_impl(&dword_1B8270000, v19, OS_LOG_TYPE_ERROR, "%s:%d: Failed to get metadata dbo", buf, 0x12u);
    }
    *__error() = v18;
    v20 = 0;
    goto LABEL_36;
  }
  v57 = 0;
  __src = 0;
  do
  {
    v5 = __ldxr(exceptionSequenceNum);
    v6 = v5 + 1;
  }
  while (__stxr(v5 + 1, exceptionSequenceNum));
  v7 = setThreadIdAndInfo(-1, (__int128 *)sSDBExceptionCallbacks, *(_QWORD *)(a1 + 1184), 0x40000000, v6);
  v55 = HIDWORD(v7);
  v56 = v7;
  v53 = v9;
  v54 = v8;
  v10 = *(_QWORD *)&threadData[18 * v7 + 2];
  v11 = v10 + 320 * HIDWORD(v7);
  *(_BYTE *)(v11 + 216) = 0;
  v12 = *(_DWORD *)(v11 + 312);
  v13 = *(void (**)(_QWORD))(v11 + 224);
  if (v13)
    v13(*(_QWORD *)(v10 + 320 * HIDWORD(v7) + 288));
  if (!_setjmp((int *)v11))
  {
    if (db_get_field(*(int **)(a1 + 1184), (uint64_t)indexmetadata, "kMDStoreAccumulatedSizes", &v57, &__src))
    {
      v21 = *__error();
      v22 = _SILogForLogForCategory(7);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)v60 = "si_getsizes";
        *(_WORD *)&v60[8] = 1024;
        *(_DWORD *)&v60[10] = 1200;
        _os_log_error_impl(&dword_1B8270000, v22, OS_LOG_TYPE_ERROR, "%s:%d: Failed to get kMDStoreAccumulatedSizes", buf, 0x12u);
      }
      *__error() = v21;
    }
    else
    {
      if (*(_BYTE *)(a1 + 2072))
        v23 = 256;
      else
        v23 = 22;
      v24 = *(unsigned int *)(v57 + 8);
      if (v24 <= 8 * (int)v23)
      {
        memcpy((void *)(a1 + 7040), __src, v24);
        v32 = 0;
        v33 = v23 - 1;
        v34 = a1 + 7048;
        *(_QWORD *)&v35 = 67109376;
        v36 = dword_1EF19FCA8;
        v37 = 0;
        do
        {
          v38 = v37;
          v39 = v36;
          if ((int)v36 >= 5)
          {
            v52 = v35;
            v50 = *__error();
            log = _SILogForLogForCategory(7);
            if (os_log_type_enabled(log, OS_LOG_TYPE_DEFAULT))
            {
              v40 = *(_QWORD *)(v34 + 8 * v32);
              *(_DWORD *)buf = v52;
              *(_DWORD *)v60 = v32 + 1;
              *(_WORD *)&v60[4] = 2048;
              *(_QWORD *)&v60[6] = v40;
              _os_log_impl(&dword_1B8270000, log, OS_LOG_TYPE_DEFAULT, "Size %d: %lld", buf, 0x12u);
            }
            *__error() = v50;
            v39 = dword_1EF19FCA8;
            v35 = v52;
          }
          v36 = v39;
          if (*(uint64_t *)(v34 + 8 * v32) < 0)
            v37 = 1;
          else
            v37 = v38;
          ++v32;
          v17 = v37;
        }
        while (v33 != v32);
LABEL_23:
        if (db_get_field(*(int **)(a1 + 1184), (uint64_t)indexmetadata, "kMDStoreAccumulatedCounts", &v57, &__src))
        {
          v25 = *__error();
          v26 = _SILogForLogForCategory(7);
          if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315394;
            *(_QWORD *)v60 = "si_getsizes";
            *(_WORD *)&v60[8] = 1024;
            *(_DWORD *)&v60[10] = 1221;
            _os_log_error_impl(&dword_1B8270000, v26, OS_LOG_TYPE_ERROR, "%s:%d: Failed to get kMDStoreAccumulatedCounts", buf, 0x12u);
          }
          *__error() = v25;
        }
        else
        {
          if (*(_BYTE *)(a1 + 2072))
            v27 = 256;
          else
            v27 = 22;
          v28 = *(unsigned int *)(v57 + 8);
          if (v28 <= 4 * (int)v27)
          {
            memcpy((void *)(a1 + 9088), __src, v28);
            v41 = v27 - 1;
            v42 = 0;
            *(_QWORD *)&v43 = 67109376;
            v44 = dword_1EF19FCA8;
            do
            {
              v45 = v44;
              if ((int)v44 >= 5)
              {
                v51 = v43;
                v49 = *__error();
                v47 = _SILogForLogForCategory(7);
                if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
                {
                  v46 = *(_DWORD *)(a1 + 9092 + 4 * v42);
                  *(_DWORD *)buf = v51;
                  *(_DWORD *)v60 = v42 + 1;
                  *(_WORD *)&v60[4] = 1024;
                  *(_DWORD *)&v60[6] = v46;
                  _os_log_impl(&dword_1B8270000, v47, OS_LOG_TYPE_DEFAULT, "Count %d: %d", buf, 0xEu);
                }
                *__error() = v49;
                v45 = dword_1EF19FCA8;
                v43 = v51;
              }
              v44 = v45;
              ++v42;
            }
            while (v41 != v42);
            goto LABEL_32;
          }
        }
        v17 = 1;
LABEL_32:
        v29 = *(_QWORD *)&threadData[18 * v56 + 2];
        v30 = v29 + 320 * v55;
        *(_DWORD *)(v30 + 312) = v12;
        v31 = *(void (**)(_QWORD))(v30 + 232);
        if (v31)
          v31(*(_QWORD *)(v29 + 320 * v55 + 288));
        dropThreadId(v56, 0, v6);
        goto LABEL_35;
      }
    }
    v17 = 1;
    goto LABEL_23;
  }
  v14 = (_DWORD *)(v11 + 312);
  v15 = *__error();
  v16 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136315394;
    *(_QWORD *)v60 = "si_getsizes";
    *(_WORD *)&v60[8] = 1024;
    *(_DWORD *)&v60[10] = 1225;
    _os_log_error_impl(&dword_1B8270000, v16, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
  }
  *__error() = v15;
  *v14 = v12;
  CIOnThreadCleanUpReset(v53);
  dropThreadId(v56, 1, v6);
  CICleanUpReset(v56, v54);
  v17 = 0;
LABEL_35:
  v20 = (v17 & 1) == 0;
LABEL_36:
  free(indexmetadata);
  if (a2)
  {
    if (!v20)
      _SIRecomputeSizesWithCallback(a1, 0, &__block_literal_global_6728);
  }
}

void si_inflateLeakedRemapping(uint64_t a1, char a2, uint64_t a3, __CFArray *a4)
{
  _QWORD *v8;
  _QWORD *v9;
  unint64_t v10;
  _QWORD *v11;
  unint64_t v12;

  v8 = (_QWORD *)CIDecodeRemappingMetadataWithIndex(*(_DWORD *)(a1 + 32), 0, a3);
  if (v8)
  {
    v9 = v8;
    CFArrayAppendValue(a4, v8);
    if ((a2 & 1) == 0)
    {
      v10 = ContentIndexRemappingNextDocId(v9, &v12);
      v11 = malloc_type_malloc(0x18uLL, 0x20040960023A9uLL);
      *v11 = a1;
      v11[1] = si_indexForDocId(a1, v10);
      v11[2] = CFRetain(v9);
      if (v11[1])
        si_enqueue_work(*(_QWORD *)(a1 + 1056), (uint64_t)si_remapForIndex, (uint64_t)v11);
      else
        free(v11);
    }
    CFRelease(v9);
    *(_QWORD *)(a1 + 2384) = a3 + 1;
  }
}

void si_populateClientStates(uint64_t a1)
{
  const __CFDictionary *v2;
  CFIndex Count;
  size_t v4;
  char *v5;
  uint64_t v6;
  const char *v7;
  const __CFString *v8;
  uint64_t v9;
  CFStringRef v10;
  __CFDictionary *clientstates_dict;
  const char *v12;
  const __CFAllocator *v13;
  CFStringRef v14;
  CFDataRef v15;
  const char *v16;
  CFDataRef v17;
  CFDataRef v18;
  uint64_t v19;
  CFStringRef v20;
  CFAllocatorRef v21;
  void *v22;
  unint64_t v23;
  const char *v24;
  int v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)(a1 + 1184))
  {
    if (*(_BYTE *)(a1 + 2072))
    {
      v2 = *(const __CFDictionary **)(a1 + 2088);
      if (v2)
      {
        Count = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 2088));
        v19 = (uint64_t)&v19;
        MEMORY[0x1E0C80A78](Count);
        v5 = (char *)&v19 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
        bzero(v5, v4);
        CFDictionaryGetKeysAndValues(v2, (const void **)v5, 0);
        if (Count >= 1)
        {
          v6 = 0;
          v21 = (CFAllocatorRef)*MEMORY[0x1E0C9AE00];
          v7 = "_kMDItemStateInfo_";
          do
          {
            v8 = *(const __CFString **)&v5[8 * v6];
            v22 = 0;
            if (CFStringCompare(v8, CFSTR("com.apple.searchd"), 1uLL)
              && !si_get_object_for_identifier_createParentDBO(a1, CFSTR("com.apple.searchd"), v8, 0, 0, 0, &v22, 0))
            {
              v9 = (uint64_t)v22;
              v25 = 0;
              v23 = 0;
              v24 = 0;
              if (!db_get_field(*(int **)(a1 + 1184), (uint64_t)v22, "_kMDItemExternalID", &v23, &v24))
              {
                v10 = CFStringCreateWithCString(v21, v24, 0x8000100u);
                if (v10)
                {
                  v20 = v10;
                  clientstates_dict = (__CFDictionary *)si_get_clientstates_dict(a1, v10);
                  while (db_next_field(*(_DWORD **)(a1 + 1184), v9, 0, &v25, (uint64_t *)&v24, &v23) == 35)
                  {
                    if (*(_WORD *)v23 == 14)
                    {
                      v12 = v24;
                      if (!strncmp(v7, v24, 0x11uLL))
                      {
                        v13 = v21;
                        v14 = CFStringCreateWithCString(v21, v12, 0x8000100u);
                        v15 = CFDataCreate(v13, (const UInt8 *)(v23 + 13), *(unsigned int *)(v23 + 8));
                        v16 = v7;
                        v17 = v15;
                        CFDictionarySetValue(clientstates_dict, v14, v15);
                        v18 = v17;
                        v7 = v16;
                        CFRelease(v18);
                        CFRelease(v14);
                      }
                    }
                  }
                  CFRelease(v20);
                }
              }
              free(v22);
            }
            ++v6;
          }
          while (v6 != Count);
        }
      }
    }
  }
}

void si_repair_index_file_tree(_DWORD *a1, int a2)
{
  int v3;
  uint64_t v4;
  BOOL v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  _DWORD *LiveIndex;
  _QWORD v15[5];
  char *v16;

  v3 = a1[2];
  v4 = *(_QWORD *)a1;
  v15[0] = MEMORY[0x1E0C809B0];
  v15[1] = 0x40000000;
  v15[2] = __si_repair_index_file_tree_block_invoke;
  v15[3] = &__block_descriptor_tmp_910;
  v15[4] = v4;
  if (!a2)
  {
    if ((*(_BYTE *)(v4 + 828) & 1) != 0)
      return;
    if (*(_BYTE *)(v4 + 2072))
      v5 = 0;
    else
      v5 = (v3 & 1) == 0;
    if (!v5)
    {
      v6 = *(_QWORD *)(v4 + 6624);
      if (v6)
        freeReverseDirStore(v6);
      *(_QWORD *)(v4 + 6624) = createReverseStore(*(_DWORD *)(v4 + 32), "tmp.", v15);
    }
    v7 = *(_QWORD *)(v4 + 1392);
    v8 = *(_QWORD *)(v4 + 1384);
    if (v7 && *(_DWORD *)(v7 + 8))
    {
      v9 = 0;
      do
        ContentIndexResetDirStore(*(_QWORD *)(*(_QWORD *)v7 + 8 * v9++));
      while (v9 < *(unsigned int *)(v7 + 8));
    }
    if (v8 && *(_DWORD *)(v8 + 8))
    {
      v10 = 0;
      do
        ContentIndexResetDirStore(*(_QWORD *)(*(_QWORD *)v8 + 8 * v10++));
      while (v10 < *(unsigned int *)(v8 + 8));
    }
    v11 = SIUINT64SetCreate();
    db_apply(*(int **)(v4 + 1184), (uint64_t (*)(uint64_t, _QWORD, uint64_t))gather_parented_items, v11);
    if (*(_BYTE *)(v4 + 2072))
      v12 = reset_parented_items;
    else
      v12 = reparent_parented_items;
    SIValueSet<unsigned long long>::_SIValueSetInnerIterate(v11 + 56, *(_QWORD *)(v11 + 16), *(_DWORD *)(v11 + 24), (uint64_t)v12, v4, 1024);
    CFRelease((CFTypeRef)v11);
    if (*(_BYTE *)(v4 + 2072) || (v3 & 1) != 0)
    {
      v13 = *(_QWORD *)(v4 + 6624);
      v16 = 0;
      asprintf(&v16, "%sreverseDirectoryStore", "");
      fd_rename(*(_QWORD *)(v13 + 216), v16);
      free(v16);
    }
    si_getLiveIndex(*(_QWORD *)(v4 + 1384));
    LiveIndex = si_getLiveIndex(*(_QWORD *)(v4 + 1384));
    _CIFlushCache((uint64_t)LiveIndex, 1, 0, 0, (uint64_t)&__block_literal_global_914);
    _SIIssueFullMergeWithGroup((_QWORD *)v4, 0);
    si_scheduler_resume(*(_QWORD *)(v4 + 872), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 31384);
  }
  free(a1);
}

BOOL si_check_version_property(uint64_t a1, const void *a2)
{
  const __CFNumber *v2;
  const __CFNumber *v3;
  CFTypeID TypeID;
  uint64_t valuePtr;

  v2 = (const __CFNumber *)SICopyProperty(a1, a2);
  if (v2)
  {
    v3 = v2;
    TypeID = CFNumberGetTypeID();
    if (TypeID == CFGetTypeID(v3))
    {
      valuePtr = 0;
      CFNumberGetValue(v3, kCFNumberCFIndexType, &valuePtr);
      CFRelease(v3);
      return valuePtr != 5;
    }
    CFRelease(v3);
  }
  return 1;
}

uint64_t si_playbackJournal(uint64_t a1, uint64_t a2)
{
  off_t v2;
  off_t v3;
  _DWORD *v4;
  unsigned int *v6;
  uint64_t v7;
  unsigned int *v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  unsigned int *v14;
  off_t st_size;
  uint64_t v16;
  off_t v17;
  off_t v18;
  char *v19;
  int v20;
  uint64_t v22;
  off_t v23;
  off_t v24;
  uint64_t v25;
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD *v34;
  unsigned int v35;
  uint64_t v36;
  unsigned int *v37;
  unsigned int v38;
  int v39;
  NSObject *v40;
  uint64_t v41;
  unsigned int v42;
  unsigned int *v43;
  unsigned int v44;
  off_t v46;
  _DWORD *v47;
  int __fd;
  int64_t v49;
  stat v50;
  uint64_t v51;
  uint8_t buf[32];
  __int16 v53;
  off_t v54;
  uint64_t v55;

  v4 = (_DWORD *)a2;
  v55 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 2072))
  {
    v6 = (unsigned int *)malloc_type_calloc(1uLL, 0x78uLL, 0x10F004029A00669uLL);
    v7 = (uint64_t)v6;
    if (v6)
    {
      *((_QWORD *)v6 + 2) = -1;
      atomic_store(1u, v6);
      if (v4)
      {
        v8 = v4 + 8;
        do
          v9 = __ldxr(v8);
        while (__stxr(v9 + 1, v8));
      }
      *((_QWORD *)v6 + 1) = v4;
      *((_QWORD *)v6 + 3) = fd_lseek(v4, 0, 2);
      v10 = a1;
      v11 = v7;
    }
    else
    {
      v10 = a1;
      v11 = 0;
    }
    v33 = preparseMobileJournal(v10, v11);
    si_sync_ctx_create_with_defer_fd(a1, 0);
    do
      v35 = __ldaxr(journalsEnqueued);
    while (__stlxr(v35 + 1, journalsEnqueued));
    v36 = v34[11];
    if (v36 <= v33 + 1)
      v36 = v33 + 1;
    v34[11] = v36;
    if (v4)
    {
      v37 = v4 + 8;
      do
        v38 = __ldxr(v37);
      while (__stxr(v38 + 1, v37));
    }
    v34[8] = v4;
    v34[5] = si_playbackSyncFinished;
    v34[6] = v7;
    si_enqueue_work_with_qos(*(_QWORD *)(a1 + 1096), 9, (uint64_t)si_sync_index_delayed0, (uint64_t)v34);
    return v33;
  }
  v51 = 0;
  v12 = _fd_acquire_fd(a2, &v51);
  if (v12 < 0)
  {
    v16 = 0;
    st_size = 0;
    goto LABEL_76;
  }
  v13 = v12;
  v47 = v4;
  v14 = (unsigned int *)malloc_type_malloc(0x100000uLL, 0x501261E4uLL);
  memset(&v50, 0, sizeof(v50));
  __fd = v13;
  fstat(v13, &v50);
  if (v50.st_size >= 0x100000uLL)
    st_size = 0x100000;
  else
    st_size = v50.st_size;
  if (!st_size)
  {
    v2 = 0;
    v3 = 0;
    v16 = 0;
    goto LABEL_75;
  }
  v16 = 0;
  v3 = 0;
  v17 = 0;
  v49 = 0x100000;
  do
  {
    if (pread(__fd, v14, st_size, v17) < 1 || (v3 = st_size + v17, v17 + 12 > st_size + v17))
    {
      st_size = 0;
      v2 = v17;
      break;
    }
    v18 = v17;
    v46 = v17;
    while (1)
    {
      v19 = (char *)v14 + v18 - v17;
      v20 = *(_DWORD *)v19;
      if (*(_DWORD *)v19 == -262275347 || v20 == -267518227)
        break;
      if (v20 == -266469651)
        goto LABEL_28;
      if (v20 != -263323923)
      {
        if (v20 != -265421075)
        {
          v2 = v18;
          st_size = 1;
          goto LABEL_75;
        }
LABEL_28:
        v25 = *((unsigned int *)v19 + 1);
        v2 = v25 + 12 + v18;
        if (v2 > v50.st_size || v25 + 12 > v49)
          goto LABEL_73;
        if (v2 > v3)
          goto LABEL_56;
        v27 = *((unsigned int *)v19 + 2);
        if (v25 != 8 * v27)
          goto LABEL_73;
        memset(buf, 0, sizeof(buf));
        if ((_DWORD)v27)
        {
          v28 = (uint64_t *)(v19 + 12);
          do
          {
            if ((pushMove(buf, *v28) & 1) == 0)
            {
              flushPlaybackPossibleMoves(a1, (uint64_t)buf, v20 == -266469651);
              pushMove(buf, *v28);
            }
            ++v28;
            --v27;
          }
          while (v27);
        }
        flushPlaybackPossibleMoves(a1, (uint64_t)buf, v20 == -266469651);
        if (*(_QWORD *)buf)
          munmap(*(void **)buf, 16 * *MEMORY[0x1E0C85AD8]);
        goto LABEL_43;
      }
      v29 = *((unsigned int *)v19 + 1);
      v2 = v29 + 12 + v18;
      if (v2 > v50.st_size || v29 + 12 > v49)
        goto LABEL_73;
      if (v2 > v3)
        goto LABEL_56;
      if ((_DWORD)v29 != 16 || *((_DWORD *)v19 + 2) != 2)
      {
LABEL_73:
        v2 = v18;
        st_size = 0;
        goto LABEL_75;
      }
      v31 = *(_QWORD *)(v19 + 12);
      if (v31 >= 3)
      {
        v32 = *(_QWORD *)(v19 + 20);
        if (v32 >= 3)
          SITransferAttributes(a1, v31, v32, 0, 0, 0);
      }
LABEL_43:
      ++v16;
      v18 = v2;
      if (v2 + 12 > v3)
        goto LABEL_57;
    }
    v22 = *((unsigned int *)v19 + 1);
    v23 = v18 + 12;
    v24 = v18 + 12 + v22;
    if (v24 <= v3)
    {
      si_playbackRecord(a1);
      v2 = v23 + *((unsigned int *)v19 + 1);
      goto LABEL_43;
    }
    if (v24 > v50.st_size)
      goto LABEL_73;
    if (v22 + 12 > v49)
    {
      v14 = (unsigned int *)malloc_type_realloc(v14, v22 + 12, 0x416530D2uLL);
      v49 = malloc_size(v14);
      pread(__fd, v14, v49, v18);
      si_playbackRecord(a1);
      v2 = v23 + v14[1];
      v17 = v18;
      goto LABEL_43;
    }
LABEL_56:
    v2 = v18;
LABEL_57:
    if (v2 == v46)
    {
      st_size = 0;
      v2 = v46;
      break;
    }
    if (v49 >= (unint64_t)(v50.st_size - v2))
      st_size = v50.st_size - v2;
    else
      st_size = v49;
    v17 = v2;
  }
  while (st_size);
LABEL_75:
  free(v14);
  v4 = v47;
  _fd_release_fd(v47, __fd, 0, v51);
LABEL_76:
  v39 = *__error();
  v40 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134218752;
    *(_QWORD *)&buf[4] = v16;
    *(_WORD *)&buf[12] = 2048;
    *(_QWORD *)&buf[14] = st_size;
    *(_WORD *)&buf[22] = 2048;
    *(_QWORD *)&buf[24] = v2;
    v53 = 2048;
    v54 = v3;
    _os_log_impl(&dword_1B8270000, v40, OS_LOG_TYPE_DEFAULT, "Played back %ld records (skipped %ld), read %lld/%lld bytes", buf, 0x2Au);
  }
  *__error() = v39;
  si_sync_ctx_create_with_defer_fd(a1, 0);
  do
    v42 = __ldaxr(journalsEnqueued);
  while (__stlxr(v42 + 1, journalsEnqueued));
  if (v4)
  {
    v43 = v4 + 8;
    do
      v44 = __ldxr(v43);
    while (__stxr(v44 + 1, v43));
  }
  *(_QWORD *)(v41 + 64) = v4;
  si_enqueue_work_with_qos(*(_QWORD *)(a1 + 1096), 9, (uint64_t)si_sync_index_delayed0, v41);
  return -1;
}

CFPropertyListRef si_read_clientstates_file(uint64_t a1)
{
  char *v1;
  char *v2;
  uint64_t v3;
  size_t v4;
  const UInt8 *v5;
  UInt8 *v6;
  const __CFAllocator *v7;
  const __CFData *v8;
  const __CFData *v9;
  CFPropertyListRef v10;
  int v11;
  NSObject *v12;
  int v13;
  NSObject *v14;
  int *v16;
  char *v17;
  int *v18;
  char *v19;
  int v20;
  const char *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  char *v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)(a1 + 2072))
    return 0;
  v1 = (char *)fd_create_protected(*(_DWORD *)(a1 + 32), "clientstatesmetafile", 0x20000000, 3u);
  if (v1)
  {
    v2 = v1;
    v3 = fd_lseek(v1, 0, 2);
    if (v3)
    {
      v4 = v3;
      v5 = (const UInt8 *)fd_mmap((uint64_t)v2);
      if (v5 != (const UInt8 *)-1)
      {
        v6 = (UInt8 *)v5;
        v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        v8 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v5, v4);
        if (v8)
        {
          v9 = v8;
          v10 = CFPropertyListCreateWithData(v7, v8, 0, 0, 0);
          CFRelease(v9);
        }
        else
        {
          v10 = 0;
        }
        munmap(v6, v4);
        fd_release(v2);
        return v10;
      }
      v13 = *__error();
      v14 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        v18 = __error();
        v19 = strerror(*v18);
        v20 = 136315650;
        v21 = "si_read_clientstates_file";
        v22 = 1024;
        v23 = 4796;
        v24 = 2080;
        v25 = v19;
        _os_log_error_impl(&dword_1B8270000, v14, OS_LOG_TYPE_ERROR, "%s:%d: si_read_clientstates_file: mmap failed: %s", (uint8_t *)&v20, 0x1Cu);
      }
      *__error() = v13;
      fd_release(v2);
      return 0;
    }
  }
  v11 = *__error();
  v12 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    v16 = __error();
    v17 = strerror(*v16);
    v20 = 136315650;
    v21 = "si_read_clientstates_file";
    v22 = 1024;
    v23 = 4802;
    v24 = 2080;
    v25 = v17;
    _os_log_error_impl(&dword_1B8270000, v12, OS_LOG_TYPE_ERROR, "%s:%d: si_read_clientstates_file: open client state meta file failed: %s", (uint8_t *)&v20, 0x1Cu);
  }
  v10 = 0;
  *__error() = v11;
  return v10;
}

void SIReleaseJournalAssertion(uint64_t a1, const __CFString *Value)
{
  char *v4;
  char *v5;
  int v6;
  const char *CStringPtr;
  char *v8;
  char *v9;

  if (a1)
  {
    v4 = (char *)fd_create_protected(*(_DWORD *)(a1 + 32), "assertedJournalAttr.1", 0x20000000, 2u);
    if (v4)
    {
      v5 = v4;
      fd_drop_assertion((uint64_t)v4);
      fd_release(v5);
    }
    if (Value
      || (pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 80)),
          Value = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 72), CFSTR("journalName")),
          pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 80)),
          Value))
    {
      v6 = *(_DWORD *)(a1 + 32);
      CStringPtr = CFStringGetCStringPtr(Value, 0x8000100u);
      v8 = (char *)fd_create_protected(v6, CStringPtr, 0x20000000, 2u);
      if (v8)
      {
        v9 = v8;
        fd_drop_assertion((uint64_t)v8);
        fd_release(v9);
      }
    }
  }
}

void resumeHoldQueue(dispatch_object_t object)
{
  if (object)
    dispatch_resume(object);
}

uint64_t preparseMobileJournal(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  unsigned int v6;
  int v7;
  unint64_t v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  void (*v14)(_QWORD);
  _DWORD *v15;
  int v16;
  NSObject *v17;
  uint64_t v18;
  void *v19;
  __int128 v21;
  __int128 v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  void *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unsigned int v39;
  unint64_t v40;
  unint64_t VInt64;
  unint64_t v42;
  unint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unsigned int v46;
  int64_t v47;
  unint64_t v48;
  unint64_t v49;
  int64_t v51;
  uint64_t v52;
  const void *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  int v65;
  NSObject *v66;
  unint64_t v67;
  int64_t v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t v72;
  uint64_t v73;
  const char *v74;
  size_t v75;
  size_t v76;
  CFStringRef v77;
  CFStringRef v78;
  const __CFString *v79;
  const __CFString *v80;
  void *v81;
  uint64_t v82;
  uint64_t v83;
  int v84;
  unint64_t v85;
  uint64_t v86;
  const char *v87;
  size_t v88;
  size_t v89;
  CFStringRef v90;
  uint64_t v91;
  unint64_t v92;
  int v93;
  NSObject *v94;
  int v95;
  NSObject *v96;
  unint64_t v97;
  int v98;
  NSObject *v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  unint64_t v104;
  unint64_t v105;
  const void *v106;
  unint64_t v107;
  int v108;
  NSObject *v109;
  __CFDictionary *clientstates_dict;
  __CFDictionary *v111;
  CFDataRef v112;
  __CFDictionary *v113;
  CFDataRef v114;
  uint64_t v115;
  unint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  unint64_t v121;
  NSObject *v122;
  uint64_t v124;
  NSObject *v125;
  int v126;
  NSObject *v127;
  uint64_t v129;
  uint64_t v130;
  unint64_t v131;
  uint64_t *v132;
  unsigned int v133;
  uint64_t *v134;
  uint64_t v135;
  uint64_t v136;
  _QWORD *v137;
  uint64_t v138;
  unsigned int *v139;
  unsigned int v140;
  const __CFSet *v141;
  CFIndex Count;
  uint64_t v143;
  const void **v144;
  size_t v145;
  uint64_t i;
  CFTypeRef v147;
  int v148;
  NSObject *v149;
  uint64_t v150;
  unsigned int v151;
  uint64_t v152;
  void (*v153)(_QWORD);
  unint64_t v154;
  uint64_t v155;
  unint64_t v156;
  uint64_t v157;
  uint64_t v158;
  unint64_t v159;
  uint64_t v160;
  unint64_t v161;
  unint64_t v162;
  int64_t v163;
  unint64_t v164;
  uint64_t v165;
  __int128 v166;
  __int128 v167;
  __int128 v168;
  uint64_t v169;
  __int128 v170;
  uint64_t v171;
  uint64_t v172;
  __int128 v173;
  int v174;
  CFStringEncoding v175;
  int v176;
  uint64_t v177;
  uint64_t v178;
  CFAllocatorRef v179;
  unint64_t v180;
  __CFSet *Mutable;
  unint64_t v182;
  uint64_t v183;
  uint64_t v184;
  int v185;
  int v186;
  __int128 v187;
  uint64_t v188;
  __int128 v189;
  uint64_t v190;
  unint64_t v191;
  unsigned int v192;
  unsigned int v193;
  unsigned int v194;
  unsigned int v195;
  unsigned int v196;
  unsigned int v197;
  unsigned int v198;
  unsigned int v199;
  _QWORD v200[2];
  uint8_t buf[80];
  uint64_t v202;

  v202 = *MEMORY[0x1E0C80C00];
  v183 = *(_QWORD *)(a1 + 2136);
  v4 = *(_QWORD *)(a2 + 24);
  v182 = v4;
  v179 = (CFAllocatorRef)*MEMORY[0x1E0C9AE00];
  Mutable = CFSetCreateMutable(v179, 0, MEMORY[0x1E0C9B3B0]);
  v200[0] = a1;
  v200[1] = a2;
  v5 = os_transaction_create();
  do
  {
    v6 = __ldxr(exceptionSequenceNum);
    v7 = v6 + 1;
  }
  while (__stxr(v6 + 1, exceptionSequenceNum));
  v8 = setThreadIdAndInfo(-1, (__int128 *)sJournalExceptionCallbacks, (uint64_t)v200, 0x40000000, v7);
  v198 = HIDWORD(v8);
  v199 = v8;
  v196 = v10;
  v197 = v9;
  v11 = *(_QWORD *)&threadData[18 * v8 + 2];
  v12 = v11 + 320 * HIDWORD(v8);
  *(_BYTE *)(v12 + 216) = 0;
  v13 = *(_DWORD *)(v12 + 312);
  v14 = *(void (**)(_QWORD))(v12 + 224);
  if (v14)
    v14(*(_QWORD *)(v11 + 320 * HIDWORD(v8) + 288));
  v195 = v199;
  v194 = v198;
  v193 = v197;
  v192 = v196;
  if (_setjmp((int *)v12))
  {
    v15 = (_DWORD *)(v12 + 312);
    v16 = *__error();
    v17 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "preparseMobileJournal";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 5164;
      _os_log_error_impl(&dword_1B8270000, v17, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
    }
    *__error() = v16;
    *v15 = v13;
    CIOnThreadCleanUpReset(v192);
    dropThreadId(v195, 1, v7);
    CICleanUpReset(v195, v193);
    v18 = -1;
    v19 = (void *)v5;
    if (!v5)
      return v18;
LABEL_9:
    os_release(v19);
    return v18;
  }
  if (!v182 || (si_mobile_journal_map_activate((int *)a2), v178 = *(_QWORD *)(a2 + 16), v178 == -1))
  {
    v18 = -1;
    v30 = (void *)v5;
    goto LABEL_173;
  }
  v185 = v13;
  v184 = v5;
  v186 = v7;
  if (v4 <= 0xB)
  {
    v23 = (uint64_t *)malloc_type_malloc(0x10uLL, 0x20040A4A59CD2uLL);
    v24 = 0;
    v25 = v23;
    v26 = -1;
    v27 = -1;
    v28 = 0;
    v29 = 0;
    goto LABEL_163;
  }
  v176 = -263323923;
  v31 = -1;
  v175 = 134217984;
  v174 = -264372499;
  *(_QWORD *)&v21 = 136316418;
  v173 = v21;
  v172 = 4030594797;
  *(_QWORD *)&v21 = 136315906;
  v170 = v21;
  *(_QWORD *)&v21 = 136316930;
  *(_QWORD *)&v22 = 136316930;
  v168 = v22;
  v167 = v21;
  *(_QWORD *)&v21 = 136316418;
  v166 = v21;
  v32 = -1;
  v33 = 0;
  v34 = 0;
  v35 = 0;
  v180 = v4;
  while (2)
  {
    v36 = v33;
    v171 = v35;
    v169 = v31;
    v164 = v34;
    v37 = v178 + v34;
    v38 = v178 + v34;
    v39 = *(_DWORD *)(v178 + v34);
    v191 = 0;
    HIDWORD(v40) = v39 + 264306963;
    LODWORD(v40) = v39 + 264306963;
    switch((v40 >> 20))
    {
      case 0u:
        VInt64 = v2_readVInt64(v37 + 12, (uint64_t *)&v191);
        if (v32 == -1)
          v42 = VInt64;
        else
          v42 = v32;
        v43 = VInt64;
        v44 = v42;
        goto LABEL_25;
      case 1u:
        v45 = v37 + 32;
        v46 = v176;
        goto LABEL_50;
      case 2u:
        v45 = v37 + 18;
        v46 = -261161235;
        goto LABEL_50;
      case 4u:
        v45 = v37 + 32;
        v46 = -262275347;
LABEL_50:
        v67 = v2_readVInt64(v45, (uint64_t *)&v191);
        if (v32 == -1)
          v32 = v67;
        v47 = v67;
        goto LABEL_53;
      default:
        v46 = v39;
        v43 = 0;
        v44 = v32;
        v47 = 0;
        if (v39 == v174)
        {
LABEL_25:
          v32 = v44;
          v48 = *(unsigned int *)(v38 + 4);
          v49 = v48 + v164 + 12;
          if (v48 > 0xFFFFFFF3 || v4 < v49)
          {
            v126 = *__error();
            v127 = _SILogForLogForCategory(0);
            if (os_log_type_enabled(v127, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136316418;
              *(_QWORD *)&buf[4] = "preparseMobileJournal";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = 4972;
              *(_WORD *)&buf[18] = 2048;
              *(_QWORD *)&buf[20] = 4030594797;
              *(_WORD *)&buf[28] = 2048;
              *(_QWORD *)&buf[30] = v48;
              *(_WORD *)&buf[38] = 2048;
              *(_QWORD *)&buf[40] = v164;
              *(_WORD *)&buf[48] = 2048;
              *(_QWORD *)&buf[50] = v182;
              _os_log_error_impl(&dword_1B8270000, v127, OS_LOG_TYPE_ERROR, "%s:%d: Invalid journal entry, magic:0x%08lx, size:%ld, pos:%ld, end:%ld", buf, 0x3Au);
            }
            goto LABEL_159;
          }
          v51 = v43;
          if (v48 > v191)
          {
            memset(buf, 0, 24);
            _MDPlistGetRootPlistObjectFromBytes();
            v189 = *(_OWORD *)buf;
            v190 = *(_QWORD *)&buf[16];
            if (_MDPlistArrayGetCount())
            {
              v189 = 0uLL;
              v190 = 0;
              _MDPlistArrayGetPlistObjectAtIndex();
              v187 = 0u;
              v188 = 0;
              v52 = _MDPlistContainerCopyObject();
              if (v52)
              {
                v53 = (const void *)v52;
                v54 = v169;
                if (v51 && v169 && v51 < v169)
                {
                  v55 = v36 + 1;
                  v56 = v171;
                }
                else
                {
                  do
                    v57 = __ldxr(&gEnqueuedSize);
                  while (__stxr(v57 + v48, &gEnqueuedSize));
                  if (v169 <= v51)
                    v58 = v51;
                  else
                    v58 = v169;
                  CFSetAddValue(Mutable, v53);
                  v54 = v58;
                  v56 = v171 + 1;
                  v55 = v36;
                }
                v59 = v55;
                v60 = v56;
                v61 = v54;
                CFRelease(v53);
                v62 = v59;
                v63 = v60;
                v64 = v61;
                goto LABEL_149;
              }
            }
          }
          v65 = *__error();
          v66 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = v173;
            *(_QWORD *)&buf[4] = "preparseMobileJournal";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 4990;
            *(_WORD *)&buf[18] = 2048;
            *(_QWORD *)&buf[20] = v172;
            *(_WORD *)&buf[28] = 2048;
            *(_QWORD *)&buf[30] = v48;
            *(_WORD *)&buf[38] = 2048;
            *(_QWORD *)&buf[40] = v164;
            *(_WORD *)&buf[48] = 2048;
            *(_QWORD *)&buf[50] = v182;
            _os_log_error_impl(&dword_1B8270000, v66, OS_LOG_TYPE_ERROR, "%s:%d: Invalid journal entry - nil bundleID, magic:0x%08lx, size:%ld, pos:%ld, end:%ld", buf, 0x3Au);
          }
          *__error() = v65;
          v64 = v169;
          if (v51 && v169 && v51 < v169)
          {
            v62 = v36 + 1;
LABEL_100:
            v63 = v171;
            v4 = v180;
            goto LABEL_149;
          }
          v4 = v180;
          do
            v92 = __ldxr(&gEnqueuedSize);
          while (__stxr(v92 + v48, &gEnqueuedSize));
          if (v169 <= v51)
            v64 = v51;
          v63 = v171 + 1;
          goto LABEL_95;
        }
LABEL_53:
        v68 = v47;
        v69 = v32;
        if ((v46 & 0xFFEFFFFF) == 0xF04DFEED)
        {
          v165 = v32;
          v70 = *(unsigned int *)(v38 + 4);
          if ((v70 + 12) < 0x20 || v4 < v164 + (v70 + 12))
          {
            v126 = *__error();
            v122 = _SILogForLogForCategory(0);
            if (os_log_type_enabled(v122, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136316418;
              *(_QWORD *)&buf[4] = "preparseMobileJournal";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = 5015;
              *(_WORD *)&buf[18] = 2048;
              *(_QWORD *)&buf[20] = v46;
              *(_WORD *)&buf[28] = 2048;
              *(_QWORD *)&buf[30] = v70;
              *(_WORD *)&buf[38] = 2048;
              *(_QWORD *)&buf[40] = v164;
              *(_WORD *)&buf[48] = 2048;
              *(_QWORD *)&buf[50] = v182;
              _os_log_error_impl(&dword_1B8270000, v122, OS_LOG_TYPE_ERROR, "%s:%d: Invalid journal entry, magic:0x%08lx, size:%ld, pos:%ld, end:%ld", buf, 0x3Au);
            }
            v32 = v165;
            goto LABEL_159;
          }
          v163 = v47;
          v177 = v36;
          v162 = v164 + (v70 + 12);
          v72 = v70 - 20 - v191;
          if (v70 - 20 > v191)
          {
            v156 = v70 - 20;
            v154 = *(unsigned __int16 *)(v38 + 12);
            v73 = v154 & 0x3FF;
            v155 = v37 + 32;
            v74 = (const char *)(v37 + 32 + v191);
            v75 = strnlen(v74, v70 - 20 - v191);
            v76 = v75;
            if (v75 == v72 || v75 + 1 != v73)
            {
              v93 = *__error();
              v94 = _SILogForLogForCategory(0);
              if (os_log_type_enabled(v94, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = v167;
                *(_QWORD *)&buf[4] = "preparseMobileJournal";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = 5032;
                *(_WORD *)&buf[18] = 2048;
                *(_QWORD *)&buf[20] = v46;
                *(_WORD *)&buf[28] = 2048;
                *(_QWORD *)&buf[30] = v70;
                *(_WORD *)&buf[38] = 2048;
                *(_QWORD *)&buf[40] = v164;
                *(_WORD *)&buf[48] = 2048;
                *(_QWORD *)&buf[50] = v182;
                *(_WORD *)&buf[58] = 2048;
                *(_QWORD *)&buf[60] = v76;
                *(_WORD *)&buf[68] = 2048;
                *(_QWORD *)&buf[70] = v154 & 0x3FF;
                _os_log_error_impl(&dword_1B8270000, v94, OS_LOG_TYPE_ERROR, "%s:%d: Invalid journal entry, magic:0x%08lx, size:%ld, pos:%ld, end:%ld, len:%ld(%ld)", buf, 0x4Eu);
              }
              *__error() = v93;
            }
            else
            {
              v77 = CFStringCreateWithCString(v179, v74, v175);
              if (v77)
              {
                v78 = v77;
                if ((*(_WORD *)(v38 + 14) & 0x7FFF) != 0)
                {
                  v79 = CFStringCreateWithCString(v179, &v74[v73 + (v154 >> 10)], v175);
                  if (v79)
                  {
                    v80 = v79;
                    if (CFStringHasPrefix(v79, CFSTR("_kMDItemStateInfo_")))
                      v81 = (void *)CFRetain(v80);
                    else
                      v81 = (void *)CFStringCreateWithFormat(v179, 0, CFSTR("_kMDItemStateInfo_%@"), v80);
                    v106 = v81;
                    v107 = *(unsigned int *)(v38 + 28);
                    if (v156 >= v107)
                    {
                      clientstates_dict = (__CFDictionary *)si_get_clientstates_dict(a1, v78);
                      v111 = clientstates_dict;
                      if ((_DWORD)v107)
                      {
                        v112 = CFDataCreate(v179, (const UInt8 *)(v155 + v156 - v107), v107);
                        if (v112)
                        {
                          v113 = v111;
                          v114 = v112;
                          CFDictionarySetValue(v113, v106, v112);
                          CFRelease(v114);
                        }
                      }
                      else
                      {
                        CFDictionaryRemoveValue(clientstates_dict, v106);
                      }
                    }
                    else
                    {
                      v108 = *__error();
                      v109 = _SILogForLogForCategory(0);
                      if (os_log_type_enabled(v109, OS_LOG_TYPE_ERROR))
                      {
                        *(_DWORD *)buf = v170;
                        *(_QWORD *)&buf[4] = "preparseMobileJournal";
                        *(_WORD *)&buf[12] = 1024;
                        *(_DWORD *)&buf[14] = 5067;
                        *(_WORD *)&buf[18] = 2048;
                        *(_QWORD *)&buf[20] = v107;
                        *(_WORD *)&buf[28] = 2048;
                        *(_QWORD *)&buf[30] = v156;
                        _os_log_error_impl(&dword_1B8270000, v109, OS_LOG_TYPE_ERROR, "%s:%d: Invalid client state size:%ld > size:%ld", buf, 0x26u);
                      }
                      *__error() = v108;
                    }
                    CFRelease(v106);
                    CFRelease(v80);
                  }
                }
                v100 = v169;
                if (v163 && v169 && v163 < v169)
                {
                  v115 = v177 + 1;
                  v101 = v171;
                  v4 = v180;
                }
                else
                {
                  if (v169 <= v163)
                    v100 = v163;
                  v101 = v171 + 1;
                  v4 = v180;
                  do
                    v116 = __ldxr(&gEnqueuedSize);
                  while (__stxr(v116 + v70, &gEnqueuedSize));
                  CFSetAddValue(Mutable, v78);
                  v115 = v177;
                }
                v117 = v115;
                CFRelease(v78);
                v32 = v165;
                v49 = v162;
                v62 = v117;
                goto LABEL_148;
              }
            }
          }
          v95 = *__error();
          v96 = _SILogForLogForCategory(0);
          v36 = v177;
          if (os_log_type_enabled(v96, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = v166;
            *(_QWORD *)&buf[4] = "preparseMobileJournal";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 5039;
            *(_WORD *)&buf[18] = 2048;
            *(_QWORD *)&buf[20] = v46;
            *(_WORD *)&buf[28] = 2048;
            *(_QWORD *)&buf[30] = v70;
            *(_WORD *)&buf[38] = 2048;
            *(_QWORD *)&buf[40] = v164;
            *(_WORD *)&buf[48] = 2048;
            *(_QWORD *)&buf[50] = v182;
            _os_log_error_impl(&dword_1B8270000, v96, OS_LOG_TYPE_ERROR, "%s:%d: Invalid journal entry - nil bundleID, magic:0x%08lx, size:%ld, pos:%ld, end:%ld", buf, 0x3Au);
          }
          *__error() = v95;
          v4 = v180;
          v64 = v169;
          if (!v163 || !v169 || v163 >= v169)
          {
            if (v169 <= v163)
              v64 = v163;
            v63 = v171 + 1;
            do
              v97 = __ldxr(&gEnqueuedSize);
            while (__stxr(v97 + v70, &gEnqueuedSize));
            v32 = v165;
            v49 = v162;
LABEL_95:
            v62 = v36;
            goto LABEL_149;
          }
          v62 = v36 + 1;
          v32 = v165;
          v49 = v162;
          v63 = v171;
LABEL_149:
          v31 = v64;
          v35 = v63;
          v33 = v62;
          v34 = v49;
          v118 = v64;
          v27 = v32;
          v119 = v63;
          v120 = v62;
          v121 = v49;
          if (v49 + 12 > v4)
            goto LABEL_161;
          continue;
        }
        if (v46 != -261161235)
        {
          v129 = v32;
          goto LABEL_160;
        }
        v82 = *(unsigned int *)(v38 + 4);
        if ((v82 + 12) >= 0x12 && v4 >= v164 + (v82 + 12))
        {
          v49 = v164 + (v82 + 12);
          v83 = *(unsigned __int16 *)(v38 + 12);
          v84 = *(unsigned __int16 *)(v38 + 12);
          v85 = v82 - 20 - v191;
          if (v82 - 20 <= v191)
          {
            v90 = 0;
            v91 = v171;
            v64 = v169;
          }
          else
          {
            if (!v84)
            {
              v64 = v169;
              if (v47 && v169 && v47 < v169)
              {
                v62 = v36 + 1;
                v32 = v69;
                goto LABEL_100;
              }
              if (v169 <= v47)
                v64 = v47;
              v63 = v171 + 1;
              v4 = v180;
              do
                v105 = __ldxr(&gEnqueuedSize);
              while (__stxr(v105 + v82, &gEnqueuedSize));
              v32 = v69;
              goto LABEL_95;
            }
            v161 = v164 + (v82 + 12);
            v163 = v47;
            v165 = v69;
            v86 = v83;
            v87 = (const char *)(v37 + v191 + 18);
            v88 = strnlen(v87, v82 - 20 - v191);
            v89 = v88;
            if (v88 == v85 || v88 + 1 != v86)
            {
              v98 = *__error();
              v99 = _SILogForLogForCategory(0);
              if (os_log_type_enabled(v99, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = v168;
                *(_QWORD *)&buf[4] = "preparseMobileJournal";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = 5112;
                *(_WORD *)&buf[18] = 2048;
                *(_QWORD *)&buf[20] = 4033806061;
                *(_WORD *)&buf[28] = 2048;
                *(_QWORD *)&buf[30] = v82;
                *(_WORD *)&buf[38] = 2048;
                *(_QWORD *)&buf[40] = v164;
                *(_WORD *)&buf[48] = 2048;
                *(_QWORD *)&buf[50] = v182;
                *(_WORD *)&buf[58] = 2048;
                *(_QWORD *)&buf[60] = v89;
                *(_WORD *)&buf[68] = 2048;
                *(_QWORD *)&buf[70] = v86;
                _os_log_error_impl(&dword_1B8270000, v99, OS_LOG_TYPE_ERROR, "%s:%d: Invalid journal entry, magic:0x%08lx, size:%ld, pos:%ld, end:%ld, len:%ld(%ld)", buf, 0x4Eu);
              }
              v90 = 0;
              *__error() = v98;
            }
            else
            {
              v90 = CFStringCreateWithCString(v179, v87, v175);
            }
            v91 = v171;
            v64 = v169;
            v69 = v165;
            v68 = v163;
            v49 = v161;
          }
          v4 = v180;
          if (!v90 && v84)
          {
            v62 = v36 + 1;
            v32 = v69;
LABEL_108:
            v63 = v91;
            goto LABEL_149;
          }
          if (v68 && v64 && v68 < v64)
          {
            v32 = v69;
            v62 = v36 + 1;
            v100 = v64;
            v101 = v91;
            v102 = v62;
            if (v90)
              goto LABEL_121;
            goto LABEL_108;
          }
          v103 = v36;
          if (v64 <= v68)
            v100 = v68;
          else
            v100 = v64;
          v101 = v91 + 1;
          do
            v104 = __ldxr(&gEnqueuedSize);
          while (__stxr(v104 + v82, &gEnqueuedSize));
          v32 = v69;
          if (v90)
          {
            CFSetAddValue(Mutable, v90);
            v102 = v103;
LABEL_121:
            v103 = v102;
            CFRelease(v90);
          }
          v62 = v103;
LABEL_148:
          v63 = v101;
          v64 = v100;
          goto LABEL_149;
        }
        v124 = v69;
        v126 = *__error();
        v125 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v125, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136316418;
          *(_QWORD *)&buf[4] = "preparseMobileJournal";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 5096;
          *(_WORD *)&buf[18] = 2048;
          *(_QWORD *)&buf[20] = 4033806061;
          *(_WORD *)&buf[28] = 2048;
          *(_QWORD *)&buf[30] = v82;
          *(_WORD *)&buf[38] = 2048;
          *(_QWORD *)&buf[40] = v164;
          *(_WORD *)&buf[48] = 2048;
          *(_QWORD *)&buf[50] = v182;
          _os_log_error_impl(&dword_1B8270000, v125, OS_LOG_TYPE_ERROR, "%s:%d: Invalid journal entry, magic:0x%08lx, size:%ld, pos:%ld, end:%ld", buf, 0x3Au);
        }
        v32 = v124;
LABEL_159:
        *__error() = v126;
        v129 = v32;
LABEL_160:
        v119 = v171;
        v27 = v129;
        v121 = v164;
        v120 = v36;
        v118 = v169;
LABEL_161:
        v130 = v120;
        v131 = v121;
        v132 = (uint64_t *)malloc_type_malloc(0x10uLL, 0x20040A4A59CD2uLL);
        if (a2)
        {
          v25 = v132;
          v26 = v118;
          v24 = v119;
          v28 = v130;
          v29 = v131;
          do
LABEL_163:
            v133 = __ldaxr((unsigned int *)a2);
          while (__stlxr(v133 + 1, (unsigned int *)a2));
          v134 = v25;
          v135 = v24;
        }
        else
        {
          v134 = v132;
          v26 = v118;
          v135 = v119;
          v28 = v130;
          v29 = v131;
        }
        v159 = v29;
        v158 = v28;
        v157 = v135;
        v136 = v26;
        v160 = v27;
        v137 = (_QWORD *)a2;
        v138 = (uint64_t)v134;
        *v134 = a1;
        v134[1] = (uint64_t)v137;
        v139 = (unsigned int *)(a1 + 6888);
        do
          v140 = __ldaxr(v139);
        while (__stlxr(v140 + 1, v139));
        si_mobile_journal_map_deactivate(v137);
        si_enqueue_barrier_with_qos(*(_QWORD *)(a1 + 1048), 0, (uint64_t)playBackMobileJournal, v138);
        v141 = Mutable;
        Count = CFSetGetCount(Mutable);
        MEMORY[0x1E0C80A78](Count);
        v144 = (const void **)((char *)&v154 - v143);
        bzero((char *)&v154 - v143, v145);
        CFSetGetValues(v141, v144);
        if (Count >= 1)
        {
          for (i = 0; i != Count; ++i)
          {
            *(_QWORD *)buf = 0;
            *(_QWORD *)buf = malloc_type_malloc(0x10uLL, 0xA0040AFF93C70uLL);
            **(_QWORD **)buf = a1;
            v147 = CFRetain(v144[i]);
            *(_QWORD *)(*(_QWORD *)buf + 8) = v147;
            si_enqueue_work_bulk_with_qos(*(_QWORD *)(a1 + 1048), 0, (uint64_t)dummy_routine, (uint64_t)buf, (uint64_t)v144[i], i == 0);
          }
        }
        CFRelease(Mutable);
        si_enqueue_work_with_qos(*(_QWORD *)(a1 + 1048), 0, (uint64_t)endTransaction, v184);
        v148 = *__error();
        v149 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v149, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 134219520;
          *(_QWORD *)&buf[4] = v157;
          *(_WORD *)&buf[12] = 2048;
          *(_QWORD *)&buf[14] = v158;
          *(_WORD *)&buf[22] = 2048;
          *(_QWORD *)&buf[24] = v159;
          *(_WORD *)&buf[32] = 2048;
          *(_QWORD *)&buf[34] = v182;
          *(_WORD *)&buf[42] = 2048;
          *(_QWORD *)&buf[44] = v183;
          *(_WORD *)&buf[52] = 2048;
          *(_QWORD *)&buf[54] = v160;
          *(_WORD *)&buf[62] = 2048;
          *(_QWORD *)&buf[64] = v136;
          _os_log_impl(&dword_1B8270000, v149, OS_LOG_TYPE_DEFAULT, "Played back %ld records (skipped %ld), read %lld/%lld bytes, consumedJournalSerialNumber:%lld, minReplaySerialNumber:%lld, maxReplaySerialNumber:%lld", buf, 0x48u);
        }
        *__error() = v148;
        v30 = 0;
        v18 = v136;
        v7 = v186;
        v13 = v185;
LABEL_173:
        v150 = *(_QWORD *)&threadData[18 * v195 + 2];
        v151 = v194;
        v152 = v150 + 320 * v194;
        *(_DWORD *)(v152 + 312) = v13;
        v153 = *(void (**)(_QWORD))(v152 + 232);
        if (v153)
          v153(*(_QWORD *)(v150 + 320 * v151 + 288));
        dropThreadId(v195, 0, v7);
        v19 = v30;
        if (v30)
          goto LABEL_9;
        return v18;
    }
  }
}

void si_playbackSyncFinished(uint64_t a1, int a2)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  unsigned int v5;

  if (a1)
  {
    if (a2)
    {
      *(_BYTE *)(a1 + 109) = 1;
      if (*(_QWORD *)(a1 + 8))
      {
        v2 = *(_QWORD *)(a1 + 80);
        if (v2)
        {
          if ((*(_WORD *)(v2 + 60) & 0x100) != 0)
            *(_WORD *)(v2 + 60) &= ~0x100u;
        }
      }
      v3 = *(_QWORD *)(a1 + 80);
      if (v3 && (*(_WORD *)(v3 + 60) & 0x100) != 0)
        *(_WORD *)(v3 + 60) &= ~0x100u;
    }
    do
    {
      v4 = __ldaxr((unsigned int *)a1);
      v5 = v4 - 1;
    }
    while (__stlxr(v5, (unsigned int *)a1));
    if (!v5)
      _si_mobile_journal_finalize(a1, 1);
  }
}

void si_playbackRecord(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  int v3;
  CFIndex v4;
  int v5;
  uint64_t v6;
  CFIndex v7;
  _QWORD *v8;
  const void **v9;
  const void *v10;
  uint64_t v11;
  const __CFAllocator *v12;
  uint64_t v13;
  const void *v14;
  const __CFArray *v15;
  CFIndex v16;
  const void *ValueAtIndex;
  const void **v18;
  char *v19;
  char *v20;
  const char *v21;
  uint64_t v22;
  CFArrayRef v23;
  char *v24;
  const char *v25;
  uint64_t v26;
  _QWORD v27[1024];
  _QWORD v28[1026];
  CFRange v29;

  v1 = MEMORY[0x1E0C80A78](a1);
  v28[1024] = *MEMORY[0x1E0C80C00];
  v4 = *(unsigned int *)(v2 + 8);
  if (8 * v4 > (unint64_t)*(unsigned int *)(v2 + 4))
    return;
  v5 = v3;
  v26 = v1;
  v6 = v2 + 12;
  bzero(v28, 0x2000uLL);
  bzero(v27, 0x2000uLL);
  v7 = (v4 + 1);
  if (v7 >= 0x401)
  {
    v8 = malloc_type_malloc(8 * (v4 + 1), 0x100004000313F17uLL);
    v9 = (const void **)malloc_type_malloc(8 * (v4 + 1), 0xC0040B8AA526DuLL);
    v10 = (const void *)*MEMORY[0x1E0C9B0D0];
    *v9 = (const void *)*MEMORY[0x1E0C9B0D0];
    goto LABEL_5;
  }
  v10 = (const void *)*MEMORY[0x1E0C9B0D0];
  v27[0] = *MEMORY[0x1E0C9B0D0];
  v9 = (const void **)v27;
  v8 = v28;
  if ((_DWORD)v4)
  {
LABEL_5:
    v11 = 0;
    do
    {
      v8[v11 + 1] = *(_QWORD *)(v6 + 8 * v11);
      ++v11;
    }
    while (v4 != v11);
  }
  *v8 = 0;
  v12 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v13 = _MDPlistBytesCreate();
  if (v13)
  {
    v14 = (const void *)v13;
    v15 = (const __CFArray *)_MDPlistBytesCopyPlistAtIndex();
    CFRelease(v14);
    if (v15)
    {
      v29.location = 0;
      v29.length = v4;
      CFArrayGetValues(v15, v29, v9 + 1);
      v16 = 0;
      while (v16 < CFArrayGetCount(v15))
      {
        ValueAtIndex = CFArrayGetValueAtIndex(v15, v16);
        v18 = &v9[v16++];
        if (ValueAtIndex != v18[1])
        {
          v19 = __si_assert_copy_extra_521(-1);
          v20 = v19;
          v21 = "";
          if (v19)
            v21 = v19;
          __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 3435, "CFArrayGetValueAtIndex(inValues,i) == valueArray[i+1]", v21);
          goto LABEL_15;
        }
      }
      if (*v9 != v10)
      {
        v24 = __si_assert_copy_extra_521(-1);
        v20 = v24;
        v25 = "";
        if (v24)
          v25 = v24;
        __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 3438, "valueArray[0]==kCFNull", v25);
LABEL_15:
        free(v20);
        if (__valid_fs(-1))
          v22 = 2989;
        else
          v22 = 3072;
        *(_DWORD *)v22 = -559038737;
        abort();
      }
      v23 = CFArrayCreate(v12, v9, v7, MEMORY[0x1E0C9B378]);
      SIBulkSetAttributes(v26, (uint64_t)v8, 0, v7, (uint64_t)v23, 0, 0, 65540, v5, 0, 0, 0, 0);
      CFRelease(v15);
      CFRelease(v23);
    }
  }
  if (v8 != v28)
    free(v8);
  if (v9 != v27)
    free(v9);
}

void flushPlaybackPossibleMoves(uint64_t a1, uint64_t a2, int a3)
{
  _QWORD *v4;
  size_t v5;
  _QWORD *v6;
  size_t v7;
  _QWORD *v8;

  v4 = *(_QWORD **)a2;
  v5 = *(_QWORD *)(a2 + 16);
  if (a3)
  {
    v6 = 0;
    v7 = 0;
  }
  else
  {
    v6 = *(_QWORD **)a2;
    v7 = v5;
    v4 = 0;
    v5 = 0;
  }
  SIPossibleMovesBulk(a1, v6, v7, v4, v5);
  v8 = *(_QWORD **)a2;
  *v8 = 0;
  v8[1] = 0;
  *(_QWORD *)(a2 + 16) = 0;
}

void SITransferAttributes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6)
{
  char *v12;
  char *JournalFd;
  uint64_t v14;
  int v15;
  NSObject *v16;
  os_log_type_t v17;
  _QWORD *v18;
  int v19;
  NSObject *v20;
  os_log_type_t v21;
  int v22;
  NSObject *v23;
  int v24;
  NSObject *v25;
  int v26;
  uint8_t buf[4];
  uint64_t v28;
  __int16 v29;
  uint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  if (a4 && a2 >= 3 && a3 >= 3)
  {
    v12 = (char *)malloc_type_malloc(0x1CuLL, 0x4DA26647uLL);
    *(_QWORD *)(v12 + 12) = a2;
    *(_QWORD *)(v12 + 20) = a3;
    *(_QWORD *)v12 = 0x10F04DFEEDLL;
    *((_DWORD *)v12 + 2) = 2;
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 1632));
    JournalFd = getJournalFd(a1, 0, 0);
    v14 = fd_write((uint64_t)JournalFd, (uint64_t)v12, 0x1CuLL);
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1632));
    if (v14 == -1)
    {
      v26 = *__error();
      v15 = *__error();
      v16 = _SILogForLogForCategory(4);
      v17 = 2 * (dword_1EF19FC9C < 4);
      if (os_log_type_enabled(v16, v17))
      {
        *(_DWORD *)buf = 67109120;
        LODWORD(v28) = v26;
        _os_log_impl(&dword_1B8270000, v16, v17, "Error writing to log file: %d", buf, 8u);
      }
      *__error() = v15;
    }
    free(v12);
  }
  if (*(_QWORD *)(a1 + 1048))
  {
    v18 = malloc_type_calloc(1uLL, 0x30uLL, 0x10A004032120C31uLL);
    if (dword_1EF19FC9C >= 5)
    {
      v22 = *__error();
      v23 = _SILogForLogForCategory(4);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1B8270000, v23, OS_LOG_TYPE_DEFAULT, "Do attribute transfer.", buf, 2u);
      }
      *__error() = v22;
    }
    *v18 = a1;
    v18[1] = a3;
    v18[2] = a2;
    v18[3] = a4;
    v18[4] = a5;
    *((_BYTE *)v18 + 40) = a6;
    v19 = *__error();
    v20 = _SILogForLogForCategory(4);
    v21 = 2 * (dword_1EF19FC9C < 4);
    if (os_log_type_enabled(v20, v21))
    {
      *(_DWORD *)buf = 134218240;
      v28 = a3;
      v29 = 2048;
      v30 = a2;
      _os_log_impl(&dword_1B8270000, v20, v21, "SITransferAttributes from %lld to %lld", buf, 0x16u);
    }
    *__error() = v19;
    si_enqueue_barrier(*(_QWORD *)(a1 + 1048), (uint64_t)transferAttributes, (uint64_t)v18);
    if (dword_1EF19FC9C >= 5)
    {
      v24 = *__error();
      v25 = _SILogForLogForCategory(4);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1B8270000, v25, OS_LOG_TYPE_DEFAULT, "Leave.", buf, 2u);
      }
      *__error() = v24;
    }
  }
}

void SIPossibleMovesBulk(uint64_t a1, const void *a2, size_t a3, const void *a4, size_t a5)
{
  void *v10;
  void *v11;

  if (*(_QWORD *)(a1 + 6624))
  {
    if (*(_QWORD *)(a1 + 1048))
    {
      v10 = malloc_type_malloc(0x28uLL, 0x1030040626A9454uLL);
      *((_QWORD *)v10 + 2) = a3;
      *((_QWORD *)v10 + 4) = a5;
      *((_QWORD *)v10 + 3) = malloc_type_malloc(a5, 0x44DC41uLL);
      v11 = malloc_type_malloc(a3, 0x221A8F9AuLL);
      *(_QWORD *)v10 = a1;
      *((_QWORD *)v10 + 1) = v11;
      memcpy(*((void **)v10 + 3), a4, a5);
      memcpy(*((void **)v10 + 1), a2, a3);
      si_enqueue_barrier_with_qos(*(_QWORD *)(a1 + 1048), 9, (uint64_t)possibleMoves, (uint64_t)v10);
    }
  }
}

void possibleMoves(uint64_t a1, char a2)
{
  double Current;
  _QWORD *v4;
  _QWORD *v5;
  unint64_t v6;
  unint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;

  if ((a2 & 1) == 0)
  {
    Current = CFAbsoluteTimeGetCurrent();
    v4 = malloc_type_calloc(1uLL, 0x30uLL, 0x70C99647uLL);
    *(_WORD *)v4 = 257;
    v4[1] = *(_QWORD *)a1;
    v4[2] = 2;
    *((_DWORD *)v4 + 6) = 0;
    if (*(uint64_t *)(a1 + 16) >= 1)
    {
      v5 = *(_QWORD **)(a1 + 8);
      do
      {
        if (!v5[1])
          break;
        v6 = 0;
        v4[5] = *v5;
        do
        {
          v4[4] = v5[v6 + 2];
          innerMoveFiles((unint64_t)v4);
          ++v6;
          v7 = v5[1];
        }
        while (v6 < v7);
        v5 += v7 + 2;
      }
      while ((unint64_t)v5 < *(_QWORD *)(a1 + 8) + *(_QWORD *)(a1 + 16));
    }
    if (*(uint64_t *)(a1 + 32) >= 1)
    {
      v8 = *(_QWORD **)(a1 + 24);
      v9 = v8;
      do
      {
        v10 = v9[1];
        v4[5] = *v9;
        if (v10)
        {
          v11 = 0;
          do
          {
            v4[4] = v9[v11 + 2];
            moveDirectoriesInner((uint64_t)v4);
            ++v11;
            v12 = v9[1];
          }
          while (v11 < v12);
          v8 = *(_QWORD **)(a1 + 24);
        }
        else
        {
          v12 = 0;
        }
        v9 += v12 + 2;
      }
      while (v9 < (_QWORD *)((char *)v8 + *(_QWORD *)(a1 + 32)));
    }
    free(v4);
    bumpWorkTime(*(_QWORD *)a1, Current);
  }
  free(*(void **)(a1 + 8));
  free(*(void **)(a1 + 24));
  free((void *)a1);
}

unint64_t innerMoveFiles(unint64_t result)
{
  unint64_t v1;
  unsigned int v2;
  unint64_t v3;
  uint64_t v4;
  char *v5;
  char *v6;
  const char *v7;
  uint64_t v8;

  v1 = result;
  v2 = 0;
  v4 = *(_QWORD *)(result + 8);
  v3 = *(_QWORD *)(result + 16);
  while (v3 > v2)
  {
    result = processOneFile(v4);
    v2 = result;
    v3 = *(_QWORD *)(v1 + 16);
    if (v3 < result)
    {
      v5 = __si_assert_copy_extra_521(-1);
      v6 = v5;
      v7 = "";
      if (v5)
        v7 = v5;
      __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 28762, "i<=ctx->count", v7);
      free(v6);
      if (__valid_fs(-1))
        v8 = 2989;
      else
        v8 = 3072;
      *(_DWORD *)v8 = -559038737;
      abort();
    }
  }
  return result;
}

void moveDirectoriesInner(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  _QWORD *v6;
  int *v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t (*v11)(uint64_t);
  uint64_t v12;
  BOOL v13;
  uint64_t v14;
  void (*v15)(_QWORD, unint64_t, _QWORD);
  unint64_t v16;
  int Path;
  uint64_t v18;
  _QWORD *v19;
  int v20;
  NSObject *v21;
  int *v22;
  NSObject *v23;
  os_log_type_t v24;
  uint64_t v25;
  _QWORD *v26;
  int v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t *v39;
  uint64_t v40;
  uint64_t v41;
  int v43;
  int v44;
  uint64_t v45;
  unint64_t v46;
  const __CFSet *v47;
  uint64_t v48;
  unint64_t v49;
  const __CFSet *v50;
  int v51;
  unint64_t *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  _DWORD *LiveIndex;
  unint64_t v57;
  int updated;
  int v59;
  int v60;
  NSObject *v61;
  unsigned int v62;
  int v63;
  int v64;
  BOOL HasContent;
  int v66;
  NSObject *v67;
  int v68;
  NSObject *v69;
  int v70;
  NSObject *v71;
  int v72;
  NSObject *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  int v77;
  const void *v78;
  uint64_t i;
  char *v80;
  char *v81;
  const char *v82;
  uint64_t v83;
  char *v84;
  const char *v85;
  uint64_t v86;
  uint64_t v87;
  unint64_t *v88;
  int v89;
  int v90;
  uint64_t v91;
  uint64_t v92;
  void *v93;
  int buf;
  _DWORD buf_4[11];
  __int16 v96;
  uint64_t v97;
  __int16 v98;
  int v99;
  uint64_t __dst;
  _QWORD v101[512];
  unint64_t v102;
  uint64_t v103;
  __int128 v104;
  uint64_t v105;
  uint64_t v106;

  v1 = MEMORY[0x1E0C80A78](a1);
  v2 = v1;
  v106 = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(v1 + 8);
  if (*(_BYTE *)(v1 + 2))
  {
    if (!*(_QWORD *)(v1 + 16))
    {
      v78 = (const void *)SIUINT64SetCreate();
      for (i = *(_QWORD *)(v3 + 6616); i; i = *(_QWORD *)(v3 + 6616))
      {
        *(_QWORD *)(v3 + 6616) = 0;
        v102 = 0x10000;
        v104 = 0u;
        v105 = 0;
        v103 = v3;
        *(_QWORD *)&v104 = 1;
        __dst = v3;
        v101[0] = v78;
        v101[1] = &v102;
        SIValueSet<unsigned long long>::_SIValueSetInnerIterate(i + 56, *(_QWORD *)(i + 16), *(_DWORD *)(i + 24), (uint64_t)fixupOne, (uint64_t)&__dst, 128);
        CFRelease((CFTypeRef)i);
      }
      CFRelease(v78);
      return;
    }
    v4 = *(_QWORD *)(v3 + 6616);
    if (!v4)
    {
      v4 = SIUINT64SetCreate();
      *(_QWORD *)(v3 + 6616) = v4;
    }
  }
  else
  {
    v4 = 0;
  }
  if (*(_QWORD *)(v2 + 16))
  {
    v5 = 0;
    v92 = *(_QWORD *)(v3 + 1384);
    v6 = &v103;
    v88 = (unint64_t *)(v4 + 16);
    v7 = (int *)&unk_1EF19F000;
    v91 = v4;
    v87 = *(_QWORD *)(v3 + 1392);
    while (1)
    {
      v8 = *(_QWORD *)(v2 + 8 * v5 + 32);
      v9 = *(unsigned __int8 *)(v2 + 1);
      bzero(&v102, 0x1008uLL);
      bzero(&__dst, 0x1008uLL);
      if (!v8)
      {
        if (v7[809] >= 5)
        {
          v70 = *__error();
          v71 = _SILogForLogForCategory(6);
          if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT))
          {
            buf = 134217984;
            *(_QWORD *)buf_4 = 0;
            _os_log_impl(&dword_1B8270000, v71, OS_LOG_TYPE_DEFAULT, "Move for bad oid: %lld", (uint8_t *)&buf, 0xCu);
          }
          *__error() = v70;
          v4 = v91;
        }
        goto LABEL_19;
      }
      v10 = *(_QWORD *)(v3 + 1416);
      v11 = *(uint64_t (**)(uint64_t))(v10 + 128);
      if (!v11 || ((v12 = v11(v10), v12 != v8) ? (v13 = (unint64_t)(v12 + 1) > 1) : (v13 = 0), !v13))
      {
        if (v7[809] >= 5)
        {
          v68 = *__error();
          v69 = _SILogForLogForCategory(6);
          if (os_log_type_enabled(v69, OS_LOG_TYPE_DEFAULT))
          {
            buf = 134217984;
            *(_QWORD *)buf_4 = v8;
            _os_log_impl(&dword_1B8270000, v69, OS_LOG_TYPE_DEFAULT, "No parent for oid: %lld", (uint8_t *)&buf, 0xCu);
          }
          *__error() = v68;
          v4 = v91;
        }
        if ((*(_DWORD *)(v3 + 6584) & 6) != 4)
        {
          v14 = *(_QWORD *)(v3 + 2360);
          v15 = *(void (**)(_QWORD, unint64_t, _QWORD))(v14 + 128);
          if (v15)
            v15(*(_QWORD *)(v14 + 136), v8, 0);
        }
        goto LABEL_19;
      }
      v16 = v12;
      Path = directoryStoreWriterGetPath(*(_QWORD *)(v3 + 6624), v8, (uint64_t)v6);
      if (dword_1EF19FC9C >= 5)
      {
        v90 = Path;
        v72 = *__error();
        v73 = _SILogForLogForCategory(4);
        if (os_log_type_enabled(v73, OS_LOG_TYPE_DEFAULT))
        {
          buf = 134218240;
          *(_QWORD *)buf_4 = v8;
          LOWORD(buf_4[2]) = 2048;
          *(_QWORD *)((char *)&buf_4[2] + 2) = v16;
          _os_log_impl(&dword_1B8270000, v73, OS_LOG_TYPE_DEFAULT, "oid: %lld moved to parent oid: %lld", (uint8_t *)&buf, 0x16u);
        }
        *__error() = v72;
        Path = v90;
        v4 = v91;
        v7 = (_DWORD *)&unk_1EF19F000;
        if (!v90)
        {
LABEL_107:
          processOneChildlessDirectory(v3);
          goto LABEL_19;
        }
      }
      else if (!Path)
      {
        goto LABEL_107;
      }
      v18 = v103;
      if (v103 != v16)
        break;
      v19 = v6;
      v20 = *__error();
      v21 = _SILogForLogForCategory(6);
      v22 = v7;
      v23 = v21;
      v24 = 2 * (v22[809] < 4);
      if (os_log_type_enabled(v21, v24))
      {
        buf = 134218240;
        *(_QWORD *)buf_4 = v16;
        LOWORD(buf_4[2]) = 2048;
        *(_QWORD *)((char *)&buf_4[2] + 2) = v8;
        _os_log_impl(&dword_1B8270000, v23, v24, "parent %lld unchanged for %lld", (uint8_t *)&buf, 0x16u);
      }
      *__error() = v20;
      v4 = v91;
      v6 = v19;
LABEL_27:
      v7 = (_DWORD *)&unk_1EF19F000;
LABEL_19:
      v5 += v9 + 1;
      if (v5 >= *(_QWORD *)(v2 + 16))
        return;
    }
    v25 = v4;
    if (v4)
    {
      v26 = v6;
      v27 = Path;
      SIValueSet<unsigned long long>::SIValueSetInsert(v88, v16);
      Path = v27;
      v6 = v26;
      v18 = v103;
    }
    if (v18 == v16)
    {
      v102 = v8;
      if (Path >= 1)
        memcpy(&__dst, v6, 8 * Path);
      si_perform_livequeries_directory_updates(v3);
      v4 = v25;
      goto LABEL_19;
    }
    v89 = Path;
    buf = 0;
    __dst = v16;
    v28 = *(_QWORD *)(v3 + 6624);
    if (v16 == 2)
    {
      directoryStoreSetParentForMove(v28, v8, 2);
      v29 = 1;
      v4 = v25;
      v30 = v87;
      goto LABEL_60;
    }
    v31 = directoryStoreWriterGetPath(v28, v16, (uint64_t)v101);
    v4 = v25;
    if (v31)
    {
      v32 = __dst;
      v7 = (_DWORD *)&unk_1EF19F000;
      v30 = v87;
      if (__dst == v8)
        goto LABEL_57;
      if (v31 >= 1)
      {
        v33 = (v31 + 1) - 1;
        v34 = v33;
        v35 = v101;
        do
        {
          v37 = *v35++;
          v36 = v37;
          if (v8 == v37 || __dst == v36)
            goto LABEL_57;
          --v34;
        }
        while (v34);
        v39 = v101;
        while (1)
        {
          v41 = *v39++;
          v40 = v41;
          if (v8 == v41 || __dst == v40)
            break;
          if (!--v33)
            goto LABEL_53;
        }
        v80 = __si_assert_copy_extra_521(-1);
        v81 = v80;
        v82 = "";
        if (v80)
          v82 = v80;
        __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 28941, "!(sourceOid==destPath[i] || destPath[0] == destPath[i])", v82);
LABEL_115:
        free(v81);
        if (__valid_fs(-1))
          v83 = 2989;
        else
          v83 = 3072;
        *(_DWORD *)v83 = -559038737;
        abort();
      }
    }
    else
    {
      SIPersistentIDStoreGetOidPathForOid(*(_QWORD *)(v3 + 1416), v16, (uint64_t)v101, 0, &buf);
      v31 = 0;
      v32 = __dst;
      v7 = (_DWORD *)&unk_1EF19F000;
      v30 = v87;
      if (__dst == v8)
        goto LABEL_57;
LABEL_53:
      if (!v31 && buf)
      {
        v43 = si_directoryStoreEnsurePath(v3);
        if (v43 == -1)
        {
LABEL_57:
          _SIResolveDirectory(v3, v8, *(unsigned int *)(v2 + 24));
          goto LABEL_19;
        }
        v44 = v43;
        v32 = __dst;
        goto LABEL_59;
      }
    }
    v44 = v31;
LABEL_59:
    directoryStoreSetParentForMove(*(_QWORD *)(v3 + 6624), v8, v32);
    v29 = v44 + 1;
LABEL_60:
    v86 = (uint64_t)v6;
    v102 = v8;
    v45 = *(_QWORD *)(v3 + 6632);
    if (v45)
      directoryOverlayMoveDirectory(v45, v89 + 1, (uint64_t *)&v102, v29, &__dst);
    if (*(_DWORD *)(v30 + 8))
    {
      v46 = 0;
      do
      {
        v47 = *(const __CFSet **)(v3 + 6640);
        if (!v47 || !CFSetContainsValue(v47, (const void *)*(int *)(*(_QWORD *)(*(_QWORD *)v30 + 8 * v46) + 48)))
          _CIMoveDirectory(*(_QWORD *)(*(_QWORD *)v30 + 8 * v46), v89 + 1, (uint64_t *)&v102, v29, (uint64_t)&__dst);
        ++v46;
      }
      while (v46 < *(unsigned int *)(v30 + 8));
    }
    v48 = v92;
    if (*(_DWORD *)(v92 + 8))
    {
      v49 = 0;
      do
      {
        v50 = *(const __CFSet **)(v3 + 6640);
        if (!v50
          || (v51 = CFSetContainsValue(v50, (const void *)*(int *)(*(_QWORD *)(*(_QWORD *)v48 + 8 * v49) + 48)),
              v48 = v92,
              !v51))
        {
          _CIMoveDirectory(*(_QWORD *)(*(_QWORD *)v48 + 8 * v49), v89 + 1, (uint64_t *)&v102, v29, (uint64_t)&__dst);
          v48 = v92;
        }
        ++v49;
      }
      while (v49 < *(unsigned int *)(v48 + 8));
    }
    si_perform_livequeries_directory_updates(v3);
    v93 = 0;
    v6 = (_QWORD *)v86;
    if (!db_get_obj_callback(*(int **)(v3 + 1184), v8, &v93, 0, *(_QWORD *)(v3 + 2368), 0))
    {
      v52 = (unint64_t *)v93;
      v53 = *((_QWORD *)v93 + 3);
      if (v53 == v103 || (unint64_t)(v53 + 1) < 2)
      {
        v54 = 0;
      }
      else
      {
        v66 = *__error();
        v67 = _SILogForLogForCategory(6);
        if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
        {
          v74 = *(_QWORD *)v93;
          v75 = *((_QWORD *)v93 + 3);
          v76 = *((_QWORD *)v93 + 4);
          v77 = *((_DWORD *)v93 + 11);
          buf = 136316674;
          *(_QWORD *)buf_4 = "moveDirectoriesInner";
          LOWORD(buf_4[2]) = 1024;
          *(_DWORD *)((char *)&buf_4[2] + 2) = 29011;
          HIWORD(buf_4[3]) = 2048;
          *(_QWORD *)&buf_4[4] = v75;
          LOWORD(buf_4[6]) = 2048;
          *(_QWORD *)((char *)&buf_4[6] + 2) = v74;
          HIWORD(buf_4[8]) = 2048;
          *(_QWORD *)&buf_4[9] = v103;
          v96 = 2048;
          v97 = v76;
          v98 = 1024;
          v99 = v77;
          _os_log_error_impl(&dword_1B8270000, v67, OS_LOG_TYPE_ERROR, "%s:%d: Got parent %lld for %lld. Expected %lld (doc %llu)(%d)", (uint8_t *)&buf, 0x40u);
        }
        *__error() = v66;
        v52 = (unint64_t *)v93;
        v54 = *((_QWORD *)v93 + 3);
      }
      v55 = __dst;
      v52[3] = __dst;
      if (v55 != directoryStoreGetParent(*(_QWORD *)(v3 + 6624), *v52))
      {
        v84 = __si_assert_copy_extra_521(-1);
        v81 = v84;
        v85 = "";
        if (v84)
          v85 = v84;
        __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 29024, "dbo->parent_oid == directoryStoreGetParent(ref->dirStore, dbo->oid)", v85);
        goto LABEL_115;
      }
      v102 = *(_QWORD *)v93;
      if (v54)
        v103 = v54;
      LiveIndex = si_getLiveIndex(*(_QWORD *)(v3 + 1384));
      if (v93
        && *(_QWORD *)(v3 + 1144)
        && (v57 = *((_QWORD *)v93 + 4)) != 0
        && v57 > *(_QWORD *)(v3 + 1304)
        && v57 <= *(_QWORD *)(v3 + 1312))
      {
        handleMovingContent(v3, (uint64_t)LiveIndex, (unint64_t *)v93, v29, &__dst);
      }
      else
      {
        ContentIndexUpdatePath((uint64_t)LiveIndex, *((_QWORD *)v93 + 4), v29, (uint64_t)&__dst, v89 - 1, v86);
        updated = db_update_obj(*(int **)(v3 + 1184), (uint64_t)v93, 10);
        if (updated)
        {
          v59 = updated;
          v60 = *__error();
          v61 = _SILogForLogForCategory(7);
          if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
          {
            buf = 136315650;
            *(_QWORD *)buf_4 = "moveDirectoriesInner";
            LOWORD(buf_4[2]) = 1024;
            *(_DWORD *)((char *)&buf_4[2] + 2) = 29040;
            HIWORD(buf_4[3]) = 1024;
            buf_4[4] = v59;
            _os_log_error_impl(&dword_1B8270000, v61, OS_LOG_TYPE_ERROR, "%s:%d: Write error %d updating parent", (uint8_t *)&buf, 0x18u);
          }
          *__error() = v60;
        }
      }
      v62 = *((_DWORD *)v93 + 10);
      if ((v62 & 0x20) != 0)
        v63 = 5;
      else
        v63 = 4;
      v64 = v63 | (v62 >> 5) & 2;
      HasContent = objectHasContent(*(int **)(v3 + 1184), (uint64_t)v93);
      buf = 0;
      memset(&buf_4[3], 0, 24);
      buf_4[0] = v29;
      *(_QWORD *)&buf_4[1] = &__dst;
      LOBYTE(buf_4[3]) = HasContent;
      buf_4[4] = v64;
      si_perform_livequeries_updates(v3);
      free(v93);
      v4 = v91;
    }
    goto LABEL_27;
  }
}

uint64_t fixupOne(unint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  unint64_t v6;
  unint64_t v7;

  if (a2)
  {
    v4 = a2;
    do
    {
      v7 = *a1++;
      v6 = v7;
      if ((SIUINT64SetContainsValue(*(_QWORD *)(a3 + 8), v7) & 1) == 0)
      {
        SIValueSet<unsigned long long>::SIValueSetInsert((unint64_t *)(*(_QWORD *)(a3 + 8) + 16), v6);
        *(_QWORD *)(*(_QWORD *)(a3 + 16) + 32) = v6;
        moveDirectoriesInner();
      }
      --v4;
    }
    while (v4);
  }
  return 0;
}

void _SIResolveDirectory(uint64_t a1, uint64_t a2, int a3)
{
  int v6;
  NSObject *v7;
  _QWORD *v8;
  int v9;
  const char *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  uint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)(a1 + 6624) && *(_QWORD *)(a1 + 1048))
  {
    if (a3 < 1001)
    {
      v8 = malloc_type_calloc(1uLL, 0x28uLL, 0xB809A55uLL);
      v8[1] = a1;
      v8[2] = 1;
      *((_DWORD *)v8 + 6) = a3 + 1;
      v8[4] = a2;
      si_enqueue_barrier(*(_QWORD *)(a1 + 1048), (uint64_t)moveDirectories, (uint64_t)v8);
    }
    else
    {
      v6 = *__error();
      v7 = _SILogForLogForCategory(6);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        v9 = 136315650;
        v10 = "_SIResolveDirectory";
        v11 = 1024;
        v12 = 29322;
        v13 = 2048;
        v14 = a2;
        _os_log_error_impl(&dword_1B8270000, v7, OS_LOG_TYPE_ERROR, "%s:%d: move dropped %llx retry count exceeded", (uint8_t *)&v9, 0x1Cu);
      }
      *__error() = v6;
    }
  }
}

uint64_t si_directoryStoreEnsurePath(uint64_t a1)
{
  uint64_t v1;
  _DWORD *v2;
  _DWORD *v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t *v8;
  uint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  int64_t Parent;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  const char *v19;
  const char *v20;
  int v21;
  NSObject *v22;
  const char *v23;
  NSObject *v24;
  uint32_t v25;
  uint64_t v26;
  const char *v27;
  const char *v28;
  int v29;
  NSObject *v30;
  uint64_t v31;
  NSObject *v32;
  uint64_t v33;
  NSObject *v35;
  unsigned int v37;
  char v38;
  uint64_t v39;
  uint8_t buf[4];
  unint64_t v41;
  __int16 v42;
  uint64_t v43;
  __int16 v44;
  const char *v45;
  _QWORD __dst[513];

  v1 = MEMORY[0x1E0C80A78](a1);
  v3 = v2;
  v5 = v4;
  v7 = v6;
  v9 = v8;
  v11 = v10;
  v12 = v1;
  __dst[512] = *MEMORY[0x1E0C80C00];
  v39 = 0;
  *v2 = 0;
  Parent = directoryStoreWriterGetParent(*(_QWORD *)(v1 + 6624), v10);
  v38 = 0;
  v14 = directoryStoreEnsurePath(*(_QWORD *)(v12 + 6624), v11, v9, v7, v5, &v38, &v39, &v37);
  v15 = v14;
  if ((_DWORD)v14 != -1)
  {
    if (v39)
      v16 = v39 == v11;
    else
      v16 = 1;
    if (v16)
      return v15;
    if ((int)v14 < 1)
      goto LABEL_16;
    v17 = 0;
    while (v9[v17] != v39)
    {
      if (v14 == ++v17)
        return v15;
    }
    if ((_DWORD)v17)
    {
      bzero(__dst, 0x1000uLL);
      if ((int)v15 - (int)v17 < 1)
      {
        v18 = 0;
      }
      else
      {
        memcpy(__dst, &v9[v17], 8 * (v15 - v17));
        v18 = __dst[0];
      }
      v26 = ((v17 << 32) - 0x100000000) >> 32;
      v27 = processOneChildlessDirectory(v12);
      if (v27)
      {
        if (dword_1EF19FCA4 >= 5)
        {
          v28 = v27;
          v29 = *__error();
          v30 = _SILogForLogForCategory(6);
          if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
          {
            v31 = v9[v26];
            *(_DWORD *)buf = 134218498;
            v41 = v31;
            v42 = 2048;
            v43 = v18;
            v44 = 2080;
            v45 = v28;
            _os_log_impl(&dword_1B8270000, v30, OS_LOG_TYPE_DEFAULT, "Skipped fix up; item %lld, new parent %lld %s",
              buf,
              0x20u);
          }
          *__error() = v29;
        }
        return v15;
      }
      if (dword_1EF19FCA4 < 5)
        return v15;
      v21 = *__error();
      v32 = _SILogForLogForCategory(6);
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
      {
        v33 = v9[v26];
        *(_DWORD *)buf = 134218240;
        v41 = v33;
        v42 = 2048;
        v43 = v18;
        v23 = "Fixed up (formerly) childless item %lld, new parent %lld";
        v24 = v32;
LABEL_35:
        v25 = 22;
        goto LABEL_36;
      }
    }
    else
    {
LABEL_16:
      if (Parent)
        return v15;
      bzero(__dst, 0x1000uLL);
      __memcpy_chk();
      v19 = processOneChildlessDirectory(v12);
      if (v19)
      {
        if (dword_1EF19FCA4 < 5)
          return v15;
        v20 = v19;
        v21 = *__error();
        v22 = _SILogForLogForCategory(6);
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 134218498;
          v41 = v11;
          v42 = 2048;
          v43 = __dst[0];
          v44 = 2080;
          v45 = v20;
          v23 = "Skipped fix up; item %lld, new parent %lld %s";
          v24 = v22;
          v25 = 32;
LABEL_36:
          _os_log_impl(&dword_1B8270000, v24, OS_LOG_TYPE_DEFAULT, v23, buf, v25);
        }
      }
      else
      {
        if (dword_1EF19FCA4 < 5)
          return v15;
        v21 = *__error();
        v35 = _SILogForLogForCategory(6);
        if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 134218240;
          v41 = v11;
          v42 = 2048;
          v43 = __dst[0];
          v23 = "Fixed up (formerly) childless item %lld, new parent %lld";
          v24 = v35;
          goto LABEL_35;
        }
      }
    }
    *__error() = v21;
    return v15;
  }
  if (!v38)
    *v3 = 22;
  return v15;
}

void handleMovingContent(uint64_t a1, uint64_t a2, unint64_t *a3, uint64_t a4, const void *a5)
{
  const __CFAllocator *v10;
  __CFDictionary *v11;
  char *v12;
  int v13;
  int v14;
  off_t v15;
  size_t v16;
  void *v17;
  void *v18;
  CFStringRef v19;
  CFStringRef v20;
  unint64_t v21;
  uint64_t v22;
  int v23;
  int v24;
  int updated;
  int v26;
  int v27;
  NSObject *v28;
  unint64_t v29;
  uint8_t buf[4];
  const char *v31;
  __int16 v32;
  int v33;
  __int16 v34;
  int v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v10 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v11 = decodeDBOToDictionary(*(int **)(a1 + 1184), (uint64_t)a3, 0, 0, 2, *(_DWORD *)(a1 + 2028), *(_DWORD *)(a1 + 2060), 0, 0, (CFAllocatorRef)*MEMORY[0x1E0C9AE00]);
  if (!objectHasContent(*(int **)(a1 + 1184), (uint64_t)a3))
    goto LABEL_9;
  bzero(buf, 0x400uLL);
  v12 = si_cache_relative_path_for_oid(*a3, "txt", (char *)buf, *(unsigned __int8 *)(a1 + 2072));
  if (!v12 || (v13 = openat(*(_DWORD *)(a1 + 32), v12, 0), v13 == -1))
  {
LABEL_19:
    (*(void (**)(_QWORD, unint64_t, _QWORD, _QWORD))(*(_QWORD *)(a1 + 2360) + 16))(*(_QWORD *)(*(_QWORD *)(a1 + 2360) + 136), *a3, 0, 0);
    goto LABEL_20;
  }
  v14 = v13;
  fcntl(v13, 48, 1);
  fcntl(v14, 76, 1);
  v15 = lseek(v14, 0, 2);
  if (v15 < 1 || (v16 = v15, (v17 = malloc_type_zone_malloc((malloc_zone_t *)indexingZone, v15, 0x337DD3B5uLL)) == 0))
  {
LABEL_18:
    close(v14);
    goto LABEL_19;
  }
  v18 = v17;
  if (v16 != pread(v14, v17, v16, 0)
    || (v19 = CFStringCreateWithBytesNoCopy(v10, (const UInt8 *)v18, v16, 0x8000100u, 1u, (CFAllocatorRef)*MEMORY[0x1E0C9AE10])) == 0)
  {
    free(v18);
    goto LABEL_18;
  }
  v20 = v19;
  CFDictionarySetValue(v11, 0, v19);
  CFRelease(v20);
  close(v14);
LABEL_9:
  v29 = 0;
  v21 = a3[4];
  v22 = si_indexForDocId(a1, v21);
  if (v22)
    v23 = _CIDelete(v22, v21, *a3, 1);
  else
    v23 = 15;
  v24 = _CIUpdateContent(a2, a4, a5, 0, 0, *a3, v23, 0, 0.0, v11, 0, (uint64_t *)&v29, 5u, 0, (*(_DWORD *)(a1 + 6584) >> 19) & 3, (uint64_t (*)(uint64_t))lowDiskSpaceCallback, a1, 0, 0,
          *(_QWORD *)(a1 + 2464),
          0,
          0);
  a3[4] = v29;
  if (!v24)
  {
    updated = db_update_obj(*(int **)(a1 + 1184), (uint64_t)a3, 0);
    if (updated)
    {
      v26 = updated;
      v27 = *__error();
      v28 = _SILogForLogForCategory(7);
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315650;
        v31 = "handleMovingContent";
        v32 = 1024;
        v33 = 28394;
        v34 = 1024;
        v35 = v26;
        _os_log_error_impl(&dword_1B8270000, v28, OS_LOG_TYPE_ERROR, "%s:%d: Write error %d updating parent", buf, 0x18u);
      }
      *__error() = v27;
    }
  }
LABEL_20:
  CFRelease(v11);
}

const char *processOneChildlessDirectory(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  int *v4;
  int *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  const char *v13;
  uint64_t v14;
  uint64_t Path;
  const char *v18;
  const char *v19;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v27;
  unint64_t v28;
  int v29;
  int v30;
  uint64_t v31;
  char *v32;
  char *v33;
  const char *v34;
  int v35;
  uint64_t v36;
  uint64_t *v37;
  uint64_t v38;
  _DWORD *LiveIndex;
  unint64_t v40;
  int updated;
  int v42;
  int v43;
  NSObject *v44;
  unsigned int v45;
  int v46;
  int v47;
  BOOL HasContent;
  unint64_t *v49;
  char *v50;
  const char *v51;
  uint64_t v52;
  char *v53;
  char *v54;
  const char *v55;
  uint64_t v56;
  uint64_t v57;
  unsigned int v58;
  void *v59;
  uint8_t buf[4];
  const char *v61;
  __int16 v62;
  int v63;
  __int16 v64;
  int v65;
  __int128 v66;
  __int128 v67;
  uint64_t v68;
  unint64_t v69;
  _QWORD v70[513];

  v1 = MEMORY[0x1E0C80A78](a1);
  v3 = v2;
  v5 = v4;
  v7 = v6;
  v9 = v8;
  v11 = v10;
  v12 = v1;
  v70[512] = *MEMORY[0x1E0C80C00];
  v59 = 0;
  v13 = 0;
  if (!db_get_obj_callback(*(int **)(v1 + 1184), v10, &v59, 0, *(_QWORD *)(v1 + 2368), 0))
  {
    bzero(&v69, 0x1008uLL);
    if (v9 == -1 || !v7)
    {
      if (v9 == -1)
      {
        v14 = *((_QWORD *)v59 + 3);
        goto LABEL_20;
      }
    }
    else
    {
      SIValueSet<unsigned long long>::SIValueSetInsert((unint64_t *)(v7 + 16), v9);
    }
    v14 = *((_QWORD *)v59 + 3);
    if (v14 != v9 && v14 != 0)
    {
      if (v14 <= 1 && v14 != -1)
      {
        v53 = __si_assert_copy_extra_521(*(_DWORD *)(v12 + 48));
        v54 = v53;
        v55 = "";
        if (v53)
          v55 = v53;
        __message_assert("%s:%u: failed assertion '%s' %s Got parent id %lld for oid %lld", "SpotlightIndex.c", 28567, "dbo->parent_oid>=2 || dbo->parent_oid==-1", v55, *((_QWORD *)v59 + 3), *(_QWORD *)v59);
        free(v54);
        if (__valid_fs(*(_DWORD *)(v12 + 48)))
          v56 = 2989;
        else
          v56 = 3072;
        *(_DWORD *)v56 = -559038737;
        abort();
      }
      bzero(&v66, 0x1008uLL);
      v58 = 0;
      if (*(_BYTE *)(v12 + 2072))
      {
        Path = directoryStoreGetPath(*(_QWORD *)(v12 + 6624), v9, (uint64_t)v70);
        v58 = Path;
      }
      else
      {
        v57 = v3;
        if (SIPersistentIDStoreGetOidPathForOid(*(_QWORD *)(v12 + 1416), v9, (uint64_t)v70, 0, &v58))
        {
          *v5 = *__error();
          v13 = "failed";
LABEL_32:
          free(v59);
          return v13;
        }
        Path = v58;
      }
      v69 = v9;
      if (v9 == v11)
        goto LABEL_18;
      v21 = (Path + 1);
      if (v21 >= 2)
      {
        v22 = v70;
        v23 = v21 - 1;
        do
        {
          v25 = *v22++;
          v24 = v25;
          if (v25 == v11 || v24 == v9)
            goto LABEL_18;
        }
        while (--v23);
      }
      v27 = v59;
      v28 = *((_QWORD *)v59 + 3);
      if (v28 == -1)
      {
        v30 = 0;
        *(_QWORD *)&v66 = 0;
      }
      else
      {
        v29 = directoryStoreGetPath(*(_QWORD *)(v12 + 6624), v28, (uint64_t)&v66 + 8);
        v30 = v29 + 1;
        v27 = v59;
        v31 = *((_QWORD *)v59 + 3);
        *(_QWORD *)&v66 = v31;
        if ((v29 & 0x80000000) == 0 && v31 <= 1)
        {
          v32 = __si_assert_copy_extra_521(-1);
          v33 = v32;
          v34 = "";
          if (v32)
            v34 = v32;
          __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 28618, "sourcePath[0]>=2", v34);
          goto LABEL_77;
        }
      }
      v27[3] = v9;
      if (v21 >= 2)
      {
        v35 = si_directoryStoreEnsurePath(v12, v9, v70, Path, *v27, v7, v5, v3, v57);
        v21 = v35 + 1;
        if ((v35 & 0x80000000) == 0)
        {
          v36 = (v35 + 1);
          v37 = (uint64_t *)&v69;
          while (1)
          {
            v38 = *v37++;
            if (v38 <= 1)
              break;
            if (!--v36)
              goto LABEL_56;
          }
          v50 = __si_assert_copy_extra_521(-1);
          v33 = v50;
          v51 = "";
          if (v50)
            v51 = v50;
          __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 28630, "destPath[i]>=2", v51);
LABEL_77:
          free(v33);
          if (__valid_fs(-1))
            v52 = 2989;
          else
            v52 = 3072;
          *(_DWORD *)v52 = -559038737;
          abort();
        }
LABEL_56:
        if (v35 < -1)
        {
LABEL_18:
          v18 = 0;
LABEL_29:
          if (v18)
            v13 = v18;
          else
            v13 = "failed";
          goto LABEL_32;
        }
      }
      LiveIndex = si_getLiveIndex(*(_QWORD *)(v12 + 1384));
      if (!v59
        || !*(_QWORD *)(v12 + 1144)
        || (v40 = *((_QWORD *)v59 + 4)) == 0
        || v40 <= *(_QWORD *)(v12 + 1304)
        || v40 > *(_QWORD *)(v12 + 1312))
      {
        ContentIndexUpdatePath((uint64_t)LiveIndex, *((_QWORD *)v59 + 4), v21, (uint64_t)&v69, v30, (uint64_t)&v66);
        updated = db_update_obj(*(int **)(v12 + 1184), (uint64_t)v59, 10);
        if (updated)
        {
          v42 = updated;
          v43 = *__error();
          v44 = _SILogForLogForCategory(7);
          if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315650;
            v61 = "processOneChildlessDirectory";
            v62 = 1024;
            v63 = 28647;
            v64 = 1024;
            v65 = v42;
            _os_log_error_impl(&dword_1B8270000, v44, OS_LOG_TYPE_ERROR, "%s:%d: Write error %d updating parent", buf, 0x18u);
          }
          *__error() = v43;
        }
        v45 = *((_DWORD *)v59 + 10);
        if ((v45 & 0x20) != 0)
          v46 = 5;
        else
          v46 = 4;
        v47 = v46 | (v45 >> 5) & 2;
        HasContent = objectHasContent(*(int **)(v12 + 1184), (uint64_t)v59);
        v66 = 0u;
        v67 = 0u;
        v68 = 0;
        DWORD1(v66) = v21 & ~(v21 >> 63);
        if (v21 <= 0)
          v49 = 0;
        else
          v49 = &v69;
        *((_QWORD *)&v66 + 1) = v49;
        LOBYTE(v67) = HasContent;
        DWORD1(v67) = v47;
        si_perform_livequeries_updates(v12);
        v13 = 0;
        goto LABEL_32;
      }
      handleMovingContent(v12, (uint64_t)LiveIndex, (unint64_t *)v59, v21, &v69);
      goto LABEL_18;
    }
LABEL_20:
    v19 = "parent===1";
    if (v9 != -1)
      v19 = 0;
    if (v14 == v9)
      v19 = "dbo->parent_oid == parent";
    if (v14)
      v18 = v19;
    else
      v18 = "dbo->parent_oid==0";
    if (!v18)
      v18 = "Unknown";
    goto LABEL_29;
  }
  return v13;
}

void moveDirectories(void *a1, int a2)
{
  if (!a2)
    moveDirectoriesInner((uint64_t)a1);
  free(a1);
}

unint64_t processOneFile(uint64_t a1)
{
  uint64_t v1;
  int v2;
  unsigned int v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unsigned int v9;
  int v10;
  unint64_t v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  void (*v17)(_QWORD);
  int v18;
  NSObject *v19;
  unint64_t v20;
  int v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t (*v25)(void);
  void *v26;
  uint64_t v27;
  uint64_t v28;
  _QWORD *v29;
  unint64_t v30;
  int Path;
  uint64_t v32;
  int v33;
  uint64_t v34;
  int v35;
  uint64_t *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v41;
  int v42;
  uint64_t v43;
  _DWORD *LiveIndex;
  unint64_t v45;
  int updated;
  int v47;
  int v48;
  NSObject *v49;
  unsigned int v50;
  int v51;
  int v52;
  BOOL HasContent;
  _BYTE *v54;
  uint64_t v55;
  unsigned int v56;
  uint64_t v57;
  void (*v58)(_QWORD);
  unint64_t v59;
  unint64_t v60;
  unint64_t result;
  char *v62;
  char *v63;
  const char *v64;
  char *v65;
  const char *v66;
  char *v67;
  const char *v68;
  int v69;
  uint64_t v70;
  NSObject *v71;
  char *v72;
  char *v73;
  const char *v74;
  char *v75;
  char *v76;
  const char *v77;
  uint64_t v78;
  int v79;
  int v80;
  int v81;
  int v82;
  void *v83;
  unint64_t v84;
  unsigned int v85;
  unsigned int v86;
  unint64_t v87;
  unsigned int v88;
  unsigned int v89;
  uint8_t buf[4];
  const char *v91;
  __int16 v92;
  int v93;
  __int16 v94;
  int v95;
  __int128 v96;
  __int128 v97;
  uint64_t v98;
  _BYTE v99[12];
  __int16 v100;
  uint64_t v101;
  uint64_t v102;

  v1 = MEMORY[0x1E0C80A78](a1);
  v80 = v2;
  v4 = v3;
  v6 = v5;
  v7 = v1;
  v102 = *MEMORY[0x1E0C80C00];
  v8 = v3 + 1;
  do
  {
    v9 = __ldxr(exceptionSequenceNum);
    v10 = v9 + 1;
  }
  while (__stxr(v9 + 1, exceptionSequenceNum));
  v11 = setThreadIdAndInfo(*(_DWORD *)(v1 + 32), sFdExceptionCallbacks, 0, 1, v10);
  v88 = HIDWORD(v11);
  v89 = v11;
  v87 = __PAIR64__(v12, v13);
  v14 = *(_QWORD *)&threadData[18 * v11 + 2];
  v15 = v14 + 320 * HIDWORD(v11);
  *(_BYTE *)(v15 + 216) = 0;
  v16 = *(_DWORD *)(v15 + 312);
  v17 = *(void (**)(_QWORD))(v15 + 224);
  if (v17)
    v17(*(_QWORD *)(v14 + 320 * HIDWORD(v11) + 288));
  v86 = v89;
  v85 = v88;
  v84 = v87;
  if (_setjmp((int *)v15))
  {
    v18 = *__error();
    v19 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v99 = 136315394;
      *(_QWORD *)&v99[4] = "processOneFile";
      v100 = 1024;
      LODWORD(v101) = 28546;
      _os_log_error_impl(&dword_1B8270000, v19, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", v99, 0x12u);
    }
    *__error() = v18;
    *(_DWORD *)(v15 + 312) = v16;
    CIOnThreadCleanUpReset(v84);
    dropThreadId(v86, 1, v10);
    CICleanUpReset(v86, HIDWORD(v84));
    v20 = v8;
    v21 = 0;
    goto LABEL_63;
  }
  if (*(unsigned __int8 *)(v6 + 1) + (unint64_t)v8 > *(_QWORD *)(v6 + 16))
  {
    v67 = __si_assert_copy_extra_521(-1);
    v63 = v67;
    v68 = "";
    if (v67)
      v68 = v67;
    __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 28420, "i+advanceLen<=ctx->count", v68);
    goto LABEL_76;
  }
  v81 = *(unsigned __int8 *)(v6 + 1);
  v22 = *(_QWORD *)(v6 + 8 * v4 + 32);
  v23 = v8;
  v83 = 0;
  if (!db_get_obj_callback(*(int **)(v7 + 1184), v22, &v83, 0, *(_QWORD *)(v7 + 2368), 0))
  {
    if (!*(_BYTE *)v6 || !*(_BYTE *)(v6 + 1) || (v24 = *(_QWORD *)(v6 + 8 * v8 + 32)) == 0)
    {
      v25 = *(uint64_t (**)(void))(*(_QWORD *)(v7 + 1416) + 128);
      if (v25)
        v24 = v25();
      else
        v24 = -1;
    }
    if (dword_1EF19FC9C >= 5)
    {
      v79 = *__error();
      v71 = _SILogForLogForCategory(4);
      if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)v99 = 134218240;
        *(_QWORD *)&v99[4] = v22;
        v100 = 2048;
        v101 = v24;
        _os_log_impl(&dword_1B8270000, v71, OS_LOG_TYPE_DEFAULT, "oid: %lld moved to parent oid: %lld (file)", v99, 0x16u);
      }
      *__error() = v79;
    }
    bzero(v99, 0x1008uLL);
    v26 = v83;
    if (v24 == -1)
      goto LABEL_59;
    v27 = *((_QWORD *)v83 + 3);
    if (v27 == v24 || !v27)
      goto LABEL_59;
    if (v27 <= 1 && v27 != -1)
    {
      v72 = __si_assert_copy_extra_521(*(_DWORD *)(v7 + 48));
      v73 = v72;
      v74 = "";
      if (v72)
        v74 = v72;
      __message_assert("%s:%u: failed assertion '%s' %s Got parent id %lld for oid %lld", "SpotlightIndex.c", 28435, "dbo->parent_oid>=2 || dbo->parent_oid==-1", v74, *((_QWORD *)v83 + 3), *(_QWORD *)v83);
      free(v73);
      v69 = *(_DWORD *)(v7 + 48);
LABEL_77:
      if (__valid_fs(v69))
        v70 = 2989;
      else
        v70 = 3072;
      *(_DWORD *)v70 = -559038737;
      abort();
    }
    bzero(&v96, 0x1008uLL);
    v82 = 0;
    if (SIPersistentIDStoreGetOidPathForOid(*(_QWORD *)(v7 + 1416), v24, (uint64_t)&v99[8], 0, &v82))
      v28 = 0;
    else
      v28 = (v82 + 1);
    *(_QWORD *)v99 = v24;
    v29 = v83;
    v30 = *((_QWORD *)v83 + 3);
    if (v30 == -1)
    {
      v33 = 0;
      *(_QWORD *)&v96 = 0;
      v34 = v24;
    }
    else
    {
      Path = directoryStoreGetPath(*(_QWORD *)(v7 + 6624), v30, (uint64_t)&v96 + 8);
      v29 = v83;
      v32 = *((_QWORD *)v83 + 3);
      *(_QWORD *)&v96 = v32;
      if ((Path & 0x80000000) == 0 && v32 < 2)
      {
        v75 = __si_assert_copy_extra_521(-1);
        v76 = v75;
        v77 = "";
        if (v75)
          v77 = v75;
        __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 28456, "sourcePath[0]>=2", v77);
        free(v76);
        if (__valid_fs(-1))
          v78 = 2989;
        else
          v78 = 3072;
        *(_DWORD *)v78 = -559038737;
        abort();
      }
      v33 = Path + 1;
      v34 = *(_QWORD *)v99;
    }
    v29[3] = v24;
    if (v34 != v22)
    {
      v35 = v33;
      if (v28 < 2)
      {
        v42 = v33;
        v43 = v28;
LABEL_44:
        LiveIndex = si_getLiveIndex(*(_QWORD *)(v7 + 1384));
        if (!v83
          || !*(_QWORD *)(v7 + 1144)
          || (v45 = *((_QWORD *)v83 + 4)) == 0
          || v45 <= *(_QWORD *)(v7 + 1304)
          || v45 > *(_QWORD *)(v7 + 1312))
        {
          ContentIndexUpdatePath((uint64_t)LiveIndex, *((_QWORD *)v83 + 4), v43, (uint64_t)v99, v42, (uint64_t)&v96);
          updated = db_update_obj(*(int **)(v7 + 1184), (uint64_t)v83, 10);
          if (updated)
          {
            v47 = updated;
            v48 = *__error();
            v49 = _SILogForLogForCategory(7);
            if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136315650;
              v91 = "processOneFile";
              v92 = 1024;
              v93 = 28499;
              v94 = 1024;
              v95 = v47;
              _os_log_error_impl(&dword_1B8270000, v49, OS_LOG_TYPE_ERROR, "%s:%d: Write error %d updating parent", buf, 0x18u);
            }
            *__error() = v48;
          }
          v50 = *((_DWORD *)v83 + 10);
          if ((v50 & 0x20) != 0)
            v51 = 5;
          else
            v51 = 4;
          v52 = v51 | (v50 >> 5) & 2;
          HasContent = objectHasContent(*(int **)(v7 + 1184), (uint64_t)v83);
          v54 = 0;
          v96 = 0u;
          v97 = 0u;
          v98 = 0;
          DWORD1(v96) = v43;
          if (v43)
            v54 = v99;
          *((_QWORD *)&v96 + 1) = v54;
          LOBYTE(v97) = HasContent;
          DWORD1(v97) = v52;
          si_perform_livequeries_updates(v7);
          v26 = v83;
          goto LABEL_59;
        }
        handleMovingContent(v7, (uint64_t)LiveIndex, (unint64_t *)v83, v43, v99);
LABEL_33:
        v26 = v83;
LABEL_59:
        free(v26);
        v23 = v8;
        goto LABEL_60;
      }
      v36 = (uint64_t *)&v99[8];
      v37 = v28 - 1;
      while (1)
      {
        v39 = *v36++;
        v38 = v39;
        if (v22 == v39 || v34 == v38)
          break;
        if (!--v37)
        {
          v41 = si_directoryStoreEnsurePath(v7);
          if (v41 < -1)
            break;
          v42 = v35;
          v43 = (v41 + 1);
          goto LABEL_44;
        }
      }
    }
    _SIResolveDirectory(v7, v22, v80);
    goto LABEL_33;
  }
LABEL_60:
  v55 = *(_QWORD *)&threadData[18 * v86 + 2];
  v56 = v85;
  v57 = v55 + 320 * v85;
  *(_DWORD *)(v57 + 312) = v16;
  v58 = *(void (**)(_QWORD))(v57 + 232);
  if (v58)
    v58(*(_QWORD *)(v55 + 320 * v56 + 288));
  dropThreadId(v86, 0, v10);
  v20 = v23;
  v21 = v81;
LABEL_63:
  v59 = v20;
  v60 = *(_QWORD *)(v6 + 16);
  if (v60 < v59)
  {
    v62 = __si_assert_copy_extra_521(-1);
    v63 = v62;
    v64 = "";
    if (v62)
      v64 = v62;
    __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 28547, "i<=ctx->count", v64);
    goto LABEL_76;
  }
  result = (v21 + v8);
  if (v60 < result)
  {
    v65 = __si_assert_copy_extra_521(-1);
    v63 = v65;
    v66 = "";
    if (v65)
      v66 = v65;
    __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 28550, "i<=ctx->count", v66);
LABEL_76:
    free(v63);
    v69 = -1;
    goto LABEL_77;
  }
  return result;
}

uint64_t SIBulkSetAttributes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, void (*a10)(uint64_t, _QWORD), uint64_t a11, uint64_t a12, int a13)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  size_t v16;
  const __CFArray *v17;
  const __CFArray *v18;
  const void *v19;
  int v20;
  void (*v21)(uint64_t, _QWORD);
  int v22;
  NSObject *v23;
  int v25;
  const __CFArray *v26;
  const __CFArray *v27;
  int64_t v28;
  uint64_t v29;
  uint64_t v30;
  __int128 v31;
  int v32;
  uint64_t v33;
  int v34;
  NSObject *v35;
  uint64_t v36;
  unsigned int v37;
  uint64_t v38;
  int v39;
  const void *v40;
  uint64_t v41;
  char *v42;
  uint64_t v43;
  const void *ValueAtIndex;
  const void *v45;
  const void *v46;
  int64_t v47;
  uint64_t *v48;
  __CFArray *Mutable;
  uint64_t v50;
  char *v51;
  const void *MutableUsingMalloc;
  unsigned int ByteVectorCount;
  _DWORD *v54;
  int v55;
  uint64_t v56;
  _QWORD *v57;
  _DWORD *v58;
  const void *ByteVector;
  unsigned int v60;
  uint64_t *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  void *v65;
  char *JournalFd;
  uint64_t v67;
  int v68;
  int v69;
  NSObject *v70;
  os_log_type_t v71;
  int v72;
  int v73;
  _QWORD *v74;
  CFAbsoluteTime *v75;
  char *v76;
  size_t v77;
  CFTypeRef v78;
  uint64_t v79;
  int v80;
  int v81;
  CFAbsoluteTime *v82;
  uint64_t v83;
  CFTypeID v84;
  CFDictionaryRef v85;
  CFNumberRef v86;
  uint64_t v87;
  int v88;
  __CFArray *Value;
  CFMutableArrayRef v90;
  int v91;
  NSObject *v92;
  uint64_t v93;
  int v94;
  void *v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  NSObject *v99;
  uint64_t *v100;
  uint64_t v101;
  qos_class_t v102;
  _QWORD *v103;
  _QWORD *v104;
  char *__base;
  const __CFAllocator *allocator;
  uint64_t v107;
  pthread_mutex_t *v108;
  pthread_mutex_t *v109;
  CFTypeRef cf;
  uint64_t v111;
  uint8_t *v112;
  size_t __nela[2];
  size_t __nel;
  uint8_t buf[4096];
  _BYTE block[24];
  void *v117;
  uint64_t v118;
  uint64_t v119;
  void *v120;
  size_t v121;
  uint64_t v122;

  v13 = MEMORY[0x1E0C80A78](a1);
  v21 = a10;
  v122 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(v13 + 1280))
  {
    v22 = *__error();
    v23 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1B8270000, v23, OS_LOG_TYPE_DEFAULT, "SIBulkSetAttributes failed: index is read-only", buf, 2u);
    }
    *__error() = v22;
    if (a10)
      a10(a11, 1);
    return 0;
  }
  v25 = v20;
  v26 = v18;
  v27 = v17;
  v28 = v16;
  v29 = v14;
  v30 = v13;
  cf = v19;
  v111 = v15;
  __base = (char *)malloc_type_calloc(v16, 0x28uLL, 0x1060040A1774B36uLL);
  v104 = malloc_type_calloc(v28, 8uLL, 0x100004000313F17uLL);
  bzero(buf, 0x1000uLL);
  v107 = v30;
  if (v28 <= 4096)
  {
    if (v28 <= 1)
    {
      v112 = buf;
      __memset_chk();
      v72 = 0;
      goto LABEL_51;
    }
    v112 = buf;
  }
  else
  {
    v112 = (uint8_t *)malloc_type_malloc(v28, 0x7F640AA7uLL);
  }
  v32 = gSILogLevels[0];
  v33 = 1;
  *(_QWORD *)&v31 = 134217984;
  v108 = (pthread_mutex_t *)v28;
  do
  {
    if (v32 >= 5)
    {
      *(_OWORD *)__nela = v31;
      v34 = *__error();
      v35 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
      {
        v36 = *(_QWORD *)(v29 + 8 * v33);
        *(_DWORD *)block = __nela[0];
        *(_QWORD *)&block[4] = v36;
        _os_log_impl(&dword_1B8270000, v35, OS_LOG_TYPE_DEFAULT, "Enqueue attribute change %llx.", block, 0xCu);
      }
      *__error() = v34;
      v32 = gSILogLevels[0];
      v28 = (int64_t)v108;
      v31 = *(_OWORD *)__nela;
    }
    ++v33;
  }
  while (v28 != v33);
  v37 = v25;
  bzero(v112, v28);
  v38 = 0;
  v39 = 0;
  v40 = (const void *)*MEMORY[0x1E0C9B0D0];
  __nel = v28 - 1;
  v41 = v111;
  v42 = __base + 16;
  do
  {
    *((_QWORD *)v42 - 2) = *(_QWORD *)(v29 + 8 + 8 * v38);
    if (v41)
      v43 = *(_QWORD *)(v111 + 8 + 8 * v38);
    else
      v43 = 0;
    *((_QWORD *)v42 - 1) = v43;
    if (v27)
      ValueAtIndex = CFArrayGetValueAtIndex(v27, v38 + 1);
    else
      ValueAtIndex = 0;
    *(_QWORD *)v42 = ValueAtIndex;
    if (v26)
      v45 = CFArrayGetValueAtIndex(v26, v38 + 1);
    else
      v45 = 0;
    v41 = v111;
    if (v45 == v40)
      v46 = 0;
    else
      v46 = v45;
    *((_QWORD *)v42 + 1) = v46;
    v42[16] = v112[v38] != 0;
    v39 += (v112[v38++] == 0) & (v37 >> 4);
    v42 += 40;
  }
  while (__nel != v38);
  if (!v39)
  {
    v72 = 1;
    v21 = a10;
    v30 = v107;
    v28 = (int64_t)v108;
    v25 = v37;
LABEL_51:
    __nel = v28 - 1;
    goto LABEL_52;
  }
  v47 = v28 - 1;
  v48 = (uint64_t *)malloc_type_malloc(8 * __nel, 0x100004000313F17uLL);
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], __nel, 0);
  v50 = 0;
  v51 = __base + 16;
  v25 = v37;
  do
  {
    if (!v51[16])
    {
      CFArrayAppendValue(Mutable, *(const void **)v51);
      v48[v50++] = *((_QWORD *)v51 - 2);
    }
    v51 += 40;
    --v47;
  }
  while (v47);
  v21 = a10;
  if (v50)
  {
    MutableUsingMalloc = (const void *)_MDPlistBytesCreateMutableUsingMalloc();
    _MDPlistBytesAppendPlist();
    ByteVectorCount = _MDPlistBytesGetByteVectorCount();
    v54 = malloc_type_malloc(8 * v50 + ByteVectorCount + 12, 0xD83AEECCuLL);
    if (a9 == 12)
      v55 = -262275347;
    else
      v55 = -267518227;
    v56 = (uint64_t)v54;
    *v54 = v55;
    v57 = v54 + 3;
    v58 = &v54[2 * v50 + 3];
    ByteVector = (const void *)_MDPlistBytesGetByteVector();
    v60 = _MDPlistBytesGetByteVectorCount();
    memcpy(v58, ByteVector, v60);
    if (v50 >= 1)
    {
      v61 = v48;
      v62 = v50;
      do
      {
        v63 = *v61++;
        *v57++ = v63;
        --v62;
      }
      while (v62);
    }
    v64 = _MDPlistBytesGetByteVectorCount() + 8 * (_DWORD)v50;
    *(_DWORD *)(v56 + 4) = v64;
    *(_DWORD *)(v56 + 8) = v50;
    v65 = (void *)v56;
    pthread_mutex_lock((pthread_mutex_t *)(v107 + 1632));
    JournalFd = getJournalFd(v107, 0, 0);
    v67 = fd_write((uint64_t)JournalFd, v56, v64 + 12);
    pthread_mutex_unlock((pthread_mutex_t *)(v107 + 1632));
    v21 = a10;
    if (v67 == -1)
    {
      v68 = *__error();
      v69 = *__error();
      v70 = _SILogForLogForCategory(4);
      v71 = 2 * (dword_1EF19FC9C < 4);
      if (os_log_type_enabled(v70, v71))
      {
        *(_DWORD *)block = 67109120;
        *(_DWORD *)&block[4] = v68;
        _os_log_impl(&dword_1B8270000, v70, v71, "Error writing to log file: %d", block, 8u);
      }
      *__error() = v69;
    }
    CFRelease(MutableUsingMalloc);
    free(v65);
  }
  free(v48);
  CFRelease(Mutable);
  v72 = 1;
  v30 = v107;
  v28 = (int64_t)v108;
LABEL_52:
  if (v28 >= 3 && (v25 & 1) == 0)
    qsort(__base, __nel, 0x28uLL, (int (__cdecl *)(const void *, const void *))OIDAttrPairCmp);
  v73 = v25;
  v103 = malloc_type_calloc(1uLL, 80 * __nel + 24, 0x5D730ED8uLL);
  v103[2] = __nel;
  if (v72)
  {
    allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v109 = (pthread_mutex_t *)(v30 + 1816);
    v74 = v104;
    v75 = (CFAbsoluteTime *)(v103 + 12);
    v76 = __base + 16;
    v77 = __nel;
    while (1)
    {
      v78 = cf;
      if (cf)
        v78 = CFRetain(cf);
      *((_QWORD *)v75 - 4) = v78;
      *((_QWORD *)v75 - 9) = v30;
      v79 = *((_QWORD *)v76 - 2);
      v80 = v76[16];
      if (!v79)
        goto LABEL_62;
      if (v76[16])
        break;
      v81 = 0;
LABEL_64:
      *((_QWORD *)v75 - 6) = v79;
      v82 = v75 - 6;
      *((_DWORD *)v82 + 6) = v81 | v73;
      *((_DWORD *)v82 + 7) = a9;
      v82[1] = *((CFAbsoluteTime *)v76 - 1);
      if (v80)
        v79 = 0;
      *v74 = v79;
      *((_QWORD *)v75 - 2) = a12;
      v83 = *((_QWORD *)v76 + 1);
      if (v83)
        CFRetain(*((CFTypeRef *)v76 + 1));
      *((_QWORD *)v75 - 7) = v83;
      *((_DWORD *)v75 - 2) = a13;
      *v75 = CFAbsoluteTimeGetCurrent();
      if ((v73 & 0x80) != 0)
      {
        if (!*(_QWORD *)v76)
          goto LABEL_73;
        if (CFDictionaryGetCount(*(CFDictionaryRef *)v76) <= 1)
        {
          *(_QWORD *)v76 = 0;
          goto LABEL_73;
        }
        if (!*(_QWORD *)v76)
LABEL_73:
          *((_DWORD *)v75 - 6) |= 0x100u;
        if (!*(_QWORD *)(v30 + 6880) || (*(_BYTE *)(v30 + 6584) & 0x10) != 0)
        {
          *((_DWORD *)v75 - 6) |= 4u;
        }
        else if (a13 == -1)
        {
          *((_DWORD *)v75 - 2) = 1;
        }
        if (dword_1EF19FC9C >= 5)
        {
          v91 = *__error();
          v92 = _SILogForLogForCategory(4);
          if (os_log_type_enabled(v92, OS_LOG_TYPE_DEFAULT))
          {
            v93 = *((_QWORD *)v75 - 6);
            v94 = *((_DWORD *)v75 - 6);
            *(_DWORD *)block = 134218240;
            *(_QWORD *)&block[4] = v93;
            *(_WORD *)&block[12] = 1024;
            *(_DWORD *)&block[14] = v94;
            _os_log_impl(&dword_1B8270000, v92, OS_LOG_TYPE_DEFAULT, "PUSH REPAIR oid: %lld, f:%x", block, 0x12u);
          }
          *__error() = v91;
          v30 = v107;
        }
      }
      if (*(_QWORD *)v76)
      {
        v84 = CFGetTypeID(*(CFTypeRef *)v76);
        if (v84 == CFDictionaryGetTypeID())
        {
          v85 = *(CFDictionaryRef *)v76;
          if (*(_QWORD *)v76)
            CFRetain(*(CFTypeRef *)v76);
          *((_QWORD *)v75 - 8) = v85;
        }
      }
      if (a9 == 7 || !*((_QWORD *)v75 - 8))
        goto LABEL_98;
      v86 = CFNumberCreate(allocator, kCFNumberLongLongType, v75 - 6);
      v87 = v30;
      v88 = *((_DWORD *)v75 - 6);
      pthread_mutex_lock(v109);
      if (CFBagGetValue(*(CFBagRef *)(v87 + 1800), v86))
      {
        Value = (__CFArray *)CFDictionaryGetValue(*(CFDictionaryRef *)(v87 + 1808), v86);
        v90 = Value;
        if ((v88 & 1) == 0)
        {
          if (!Value)
          {
            v90 = CFArrayCreateMutable(allocator, 0, MEMORY[0x1E0C9B378]);
            CFDictionarySetValue(*(CFMutableDictionaryRef *)(v107 + 1808), v86, v90);
            CFRelease(v90);
          }
          CFArrayAppendValue(v90, *((const void **)v75 - 8));
          goto LABEL_97;
        }
        if (Value)
          CFArrayRemoveAllValues(Value);
      }
      else if ((v88 & 1) == 0)
      {
        goto LABEL_97;
      }
      CFBagSetValue(*(CFMutableBagRef *)(v107 + 1800), v86);
LABEL_97:
      pthread_mutex_unlock(v109);
      CFRelease(v86);
      v30 = v107;
LABEL_98:
      v75 += 10;
      v76 += 40;
      ++v74;
      if (!--v77)
        goto LABEL_103;
    }
    v80 = 1;
LABEL_62:
    v81 = 2;
    goto LABEL_64;
  }
LABEL_103:
  if ((v73 & 1) != 0 || !a12)
  {
    v96 = (uint64_t)v103;
    v95 = v104;
    v97 = a11;
    *v103 = v21;
    v103[1] = a11;
    v21 = 0;
  }
  else
  {
    v96 = (uint64_t)v103;
    v95 = v104;
    v97 = a11;
  }
  v98 = *(_QWORD *)(v30 + 1048);
  v99 = *(NSObject **)(v98 + 8);
  *(_QWORD *)block = MEMORY[0x1E0C809B0];
  *(_QWORD *)&block[8] = 0x40000000;
  *(_QWORD *)&block[16] = __si_push_queue_block_invoke;
  v117 = &__block_descriptor_tmp_38_1076;
  v118 = v98;
  v119 = a12;
  v120 = v95;
  v121 = __nel;
  dispatch_sync(v99, block);
  if (a9 == 10 || (v73 & 0x801) == 0)
  {
    v100 = (uint64_t *)(v30 + 1048);
    if (a13 && *(_DWORD *)(v30 + 6928) != a13)
      *(_DWORD *)(v30 + 6928) = a13;
  }
  else
  {
    if (a13 && *(_DWORD *)(v30 + 6928) != a13)
      *(_DWORD *)(v30 + 6928) = a13;
    v100 = (uint64_t *)(v30 + 1152);
  }
  v101 = *v100;
  v102 = qos_class_self();
  si_enqueue_barrier_with_qos(v101, v102, (uint64_t)setAttributesBulk, v96);
  if (v21)
    v21(v97, 0);
  free(__base);
  free(v95);
  if (v112 != buf)
    free(v112);
  return 1;
}

uint64_t OIDAttrPairCmp(_QWORD *a1, _QWORD *a2)
{
  unsigned int v2;

  if (*a1 >= *a2)
    v2 = 0;
  else
    v2 = -1;
  if (*a1 > *a2)
    return 1;
  else
    return v2;
}

void setAttributesBulk(_QWORD *a1, uint64_t a2)
{
  unint64_t v4;
  size_t v5;
  double Current;
  dispatch_group_t v7;
  NSObject *v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int *v17;
  int *v18;
  double v19;
  CFAbsoluteTime v20;
  int v21;
  NSObject *v22;
  os_log_type_t v23;
  uint64_t v24;
  int v25;
  NSObject *v26;
  uint64_t v27;
  int v28;
  NSObject *v29;
  const char *v30;
  _QWORD v31[7];
  int v32;
  char v33;
  _BYTE buf[12];
  __int16 v35;
  size_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v4 = gCPUCount;
  if (a1[2] < (unint64_t)gCPUCount)
    v4 = a1[2];
  if (v4 >= 0x10)
    v5 = 16;
  else
    v5 = v4;
  if (dword_1EF19FC9C >= 5)
  {
    v25 = *__error();
    v26 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      v27 = a1[2];
      *(_DWORD *)buf = 134218240;
      *(_QWORD *)&buf[4] = v27;
      v35 = 2048;
      v36 = v5;
      _os_log_impl(&dword_1B8270000, v26, OS_LOG_TYPE_DEFAULT, "Begin setattr with %ld items on %ld threads", buf, 0x16u);
    }
    *__error() = v25;
  }
  Current = CFAbsoluteTimeGetCurrent();
  v7 = dispatch_group_create();
  v8 = v7;
  if (!(_DWORD)a2 && v5 > 1)
  {
    *(_QWORD *)buf = 0;
    v9 = a1[3];
    v10 = *(_DWORD *)(v9 + 32);
    v31[0] = MEMORY[0x1E0C809B0];
    v31[1] = 0x40000000;
    v31[2] = __setAttributesBulk_block_invoke;
    v31[3] = &__block_descriptor_tmp_1459;
    v32 = v10;
    v31[4] = buf;
    v31[5] = a1;
    v31[6] = v7;
    v33 = 0;
    dispatch_apply(v5, 0, v31);
    v11 = v9;
    goto LABEL_18;
  }
  v12 = a1[2];
  if ((_DWORD)a2)
  {
    v13 = 0;
    if (!v12)
      goto LABEL_17;
LABEL_15:
    v14 = 0;
    v15 = (uint64_t)(a1 + 3);
    do
    {
      _setAttributes(v15);
      ++v14;
      v15 += 80;
    }
    while (v14 < a1[2]);
    goto LABEL_17;
  }
  if (v12)
  {
    v13 = a1[3];
    goto LABEL_15;
  }
  v13 = 0;
LABEL_17:
  v11 = v13;
LABEL_18:
  bumpWorkTime(v11, Current);
  if (dword_1EF19FC9C >= 5)
  {
    v28 = *__error();
    v29 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      v30 = "Canceled";
      if (!(_DWORD)a2)
        v30 = "Complete";
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = v30;
      _os_log_impl(&dword_1B8270000, v29, OS_LOG_TYPE_DEFAULT, "%s setattr", buf, 0xCu);
    }
    *__error() = v28;
  }
  if (*a1)
    ((void (*)(_QWORD, uint64_t))*a1)(a1[1], a2);
  if (!(_DWORD)a2)
  {
    if (a1[2])
    {
      v16 = a1[3];
      if (!*(_BYTE *)(v16 + 2072) && !*(_BYTE *)(v16 + 1480))
      {
        v17 = **(int ***)(v16 + 1048);
        do
        {
          v18 = v17;
          v17 = *(int **)v17;
        }
        while (v17);
        if (v18[28] <= 1)
        {
          v19 = *(double *)(v16 + 1472);
          v20 = CFAbsoluteTimeGetCurrent();
          *(CFAbsoluteTime *)(v16 + 1472) = v20;
          if (v20 - v19 >= 0.9)
          {
            *(_BYTE *)(v16 + 1480) = 1;
            v21 = *__error();
            v22 = _SILogForLogForCategory(11);
            v23 = 2 * (dword_1EF19FCB8 < 4);
            if (os_log_type_enabled(v22, v23))
            {
              *(_WORD *)buf = 0;
              _os_log_impl(&dword_1B8270000, v22, v23, "Index going idle; sync immediately", buf, 2u);
            }
            *__error() = v21;
            si_sync_ctx_create_with_defer_fd(v16, 0);
            *(_BYTE *)(v24 + 139) = 1;
            si_enqueue_work_with_qos(*(_QWORD *)(v16 + 1096), 9, (uint64_t)si_sync_index_delayed0, v24);
          }
        }
      }
    }
  }
  dispatch_group_wait(v8, 0xFFFFFFFFFFFFFFFFLL);
  dispatch_release(v8);
  free(a1);
}

void _setAttributes(uint64_t a1)
{
  uint64_t v1;
  __int128 v2;
  int v3;
  int v4;
  NSObject *v5;
  NSObject *v6;
  int v7;
  int v8;
  uint64_t v9;
  BOOL v10;
  int v11;
  NSObject *v12;
  unint64_t v13;
  int v14;
  unint64_t *v15;
  unsigned int v16;
  int v17;
  int v18;
  BOOL v19;
  _BOOL4 v20;
  int v21;
  int v22;
  const __CFDictionary *v23;
  const void *v24;
  CFTypeID v25;
  _BOOL4 v26;
  unint64_t v27;
  _DWORD *v28;
  uint64_t v29;
  uint64_t v30;
  char v31;
  uint64_t v33;
  unsigned int v34;
  unsigned int v35;
  _BOOL4 v36;
  unsigned int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  unsigned int v42;
  unsigned int v43;
  uint64_t v44;
  int v45;
  int v46;
  NSObject *v47;
  const __CFDictionary *v48;
  const __CFString *Value;
  _BOOL4 v50;
  BOOL v51;
  int v52;
  NSObject *v53;
  os_log_type_t v54;
  unint64_t v55;
  const __CFDictionary *v56;
  uint64_t v57;
  const __CFAllocator *v58;
  CFNumberRef v59;
  uint64_t v60;
  pthread_mutex_t *v61;
  const __CFArray *v62;
  const __CFArray *v63;
  CFMutableDictionaryRef Mutable;
  unint64_t v65;
  CFIndex Count;
  unint64_t v67;
  const __CFDictionary *ValueAtIndex;
  _DWORD *v69;
  int v70;
  _DWORD *LiveIndex;
  _DWORD *SyncIndex;
  int v73;
  NSObject *v74;
  _DWORD *v75;
  NSObject *v76;
  _DWORD *v77;
  os_log_type_t v78;
  int v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  qos_class_t v83;
  int v84;
  NSObject *v85;
  os_log_type_t v86;
  int v87;
  int v90;
  int v91;
  unint64_t v92;
  _BYTE *v93;
  int *v94;
  uint64_t obj_callback;
  int v96;
  int v97;
  NSObject *v98;
  int v99;
  NSObject *v100;
  os_log_type_t v101;
  int v102;
  const __CFAllocator *v103;
  CFIndex v104;
  CFDictionaryRef v105;
  char *v106;
  char *v107;
  char *v108;
  int v109;
  char *v110;
  const void **v111;
  const void **v112;
  int v113;
  char *v114;
  int v115;
  int v116;
  unsigned __int8 **v117;
  int *v118;
  unsigned int v119;
  uint64_t v120;
  const __CFDictionary *v121;
  int v122;
  NSObject *v123;
  const __CFDictionary *v124;
  char v125;
  CFStringRef v126;
  BOOL v127;
  CFDictionaryRef v128;
  CFTypeID v129;
  CFTypeID TypeID;
  int v131;
  NSObject *v132;
  os_log_type_t v133;
  unint64_t v134;
  char *v135;
  unsigned int v136;
  int v137;
  uint64_t v138;
  BOOL v139;
  unint64_t v140;
  uint64_t v141;
  char v142;
  __CFDictionary *v143;
  int v144;
  unint64_t v145;
  int field_by_id;
  uint64_t v147;
  uint64_t *v148;
  BOOL v149;
  _BOOL4 v150;
  int v151;
  _BOOL4 v152;
  uint64_t *obj;
  unsigned int v155;
  int *v156;
  const __CFDictionary *v157;
  unsigned __int8 v158;
  const void *v159;
  _DWORD *v160;
  uint64_t v161;
  _DWORD *v162;
  _BOOL4 v163;
  int v164;
  int v165;
  _BOOL4 v166;
  BOOL v167;
  uint64_t v168;
  CFAbsoluteTime v169;
  int *v170;
  CFTypeID v171;
  double Current;
  int v173;
  const char *v174;
  int *v175;
  CFTypeID v176;
  double v177;
  int v178;
  const char *v179;
  int *v180;
  CFTypeID v181;
  CFTypeID v182;
  double v183;
  int *v184;
  CFDateRef v185;
  uint64_t v186;
  double v187;
  const char *v188;
  char *v189;
  double v190;
  int *v191;
  int field;
  NSObject *v193;
  _DWORD *v194;
  os_log_type_t v195;
  int *v196;
  unsigned int v197;
  __n128 v198;
  int v199;
  NSObject *v200;
  _BOOL4 v201;
  NSObject *v202;
  _BOOL4 v203;
  char v204;
  char v205;
  const __CFString *v206;
  const __CFString *v207;
  CFTypeID v208;
  unsigned int v209;
  unsigned int v210;
  CFStringRef v211;
  unint64_t v212;
  uint64_t v213;
  int v214;
  const __CFAllocator *v215;
  uint64_t v216;
  int v217;
  int v218;
  unsigned int v219;
  int v220;
  int v221;
  unsigned int v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  int v226;
  int OidPathForOid;
  int v228;
  NSObject *v229;
  int v230;
  char v231;
  int v232;
  NSObject *v233;
  os_log_type_t v234;
  char v235;
  _QWORD *v236;
  _DWORD *v237;
  int v238;
  NSObject *v239;
  os_log_type_t v240;
  unsigned int *v241;
  int v242;
  unsigned int v243;
  uint64_t v244;
  uint64_t v245;
  NSObject *v246;
  const void *v247;
  const void *v248;
  const void *v249;
  unsigned __int8 *v250;
  int v251;
  int v252;
  NSObject *v253;
  os_log_type_t v254;
  _QWORD *v255;
  int v256;
  _OWORD *v257;
  __int128 v258;
  __int128 v259;
  __int128 v260;
  uint64_t v261;
  uint64_t (*v262)(_QWORD, const char *, uint64_t, const char *);
  const void *v263;
  int v264;
  NSObject *v265;
  CFAbsoluteTime v267;
  int v268;
  NSObject *v269;
  unint64_t v270;
  int v271;
  uint64_t v272;
  int v273;
  CFTypeID v274;
  int v275;
  NSObject *v276;
  int v277;
  NSObject *v278;
  unint64_t v280;
  char *v281;
  char *v282;
  const char *v283;
  uint64_t v284;
  int v285;
  NSObject *v286;
  unint64_t v287;
  int v288;
  NSObject *v289;
  unint64_t v290;
  int v291;
  NSObject *v292;
  char *v294;
  char *v295;
  const __CFAllocator *v296;
  int v297;
  char *v298;
  const char *v299;
  uint64_t v300;
  int v301;
  NSObject *v302;
  unint64_t v303;
  unsigned int v304;
  int v305;
  NSObject *v306;
  const char *v307;
  const char *v308;
  unsigned __int8 v309[736];
  char v310[8];
  CFAllocatorRef allocator;
  unint64_t v312[511];
  int v313;
  void *v314;
  _BYTE *v315;
  const void **v316;
  const __CFAllocator *v317;
  uint64_t v318;
  NSObject *v319;
  char *v320;
  uint64_t v321;
  uint64_t v322;
  CFDictionaryRef v323;
  int v324;
  int v325;
  CFDictionaryRef v326;
  _BOOL4 v327;
  __int128 v328;
  __int128 v329;
  __CFDictionary *v330;
  unint64_t v331;
  unint64_t *v332;
  int *v333;
  unsigned int v334;
  const __CFDictionary *v335;
  unint64_t v336;
  int v337;
  unsigned int v338;
  _QWORD *v339;
  uint64_t v340;
  int v341;
  uint64_t v342;
  int v343;
  uint64_t *v344;
  int v345;
  _BYTE v346[12];
  __int16 v347;
  int v348;
  __int16 v349;
  uint64_t v350;
  __int16 v351;
  int v352;
  __int16 v353;
  int v354;
  __int16 v355;
  int v356;
  unint64_t v357[4];
  unsigned __int8 **v358;
  uint64_t v359;
  uint64_t v360;
  _QWORD *v361;
  unsigned __int8 *v362;
  unsigned __int8 **v363;
  uint64_t v364;
  unint64_t v365;
  char *v366;
  __int128 v367;
  __int128 v368;
  unint64_t v369;
  __int128 v370;
  __int128 v371;
  __int128 v372;
  __int128 v373;
  CFStringRef v374[6];
  __int128 v375;
  __int128 v376;
  __int128 v377;
  __int128 v378;
  __int128 v379;
  __int128 v380;
  __int128 v381;
  __int128 v382;
  __int128 v383;
  __int128 v384;
  __int128 v385;
  __int128 v386;
  __int128 v387;
  __int128 v388;
  __int128 v389;
  uint64_t v390;
  CFRange v391;

  v1 = MEMORY[0x1E0C80A78](a1);
  v4 = v3;
  v6 = v5;
  v8 = v7;
  v9 = v1;
  v390 = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)(v1 + 56))
    v10 = dword_1EF19FC98 < 5;
  else
    v10 = 1;
  if (!v10)
  {
    v264 = *__error();
    v265 = _SILogForLogForCategory(3);
    if (os_log_type_enabled(v265, OS_LOG_TYPE_DEFAULT))
    {
      v267 = CFAbsoluteTimeGetCurrent() - *(double *)(v9 + 72);
      LODWORD(v357[0]) = 134217984;
      *(CFAbsoluteTime *)((char *)v357 + 4) = v267;
      _os_log_impl(&dword_1B8270000, v265, OS_LOG_TYPE_DEFAULT, "Set attributes waited for %f seconds", (uint8_t *)v357, 0xCu);
    }
    *__error() = v264;
  }
  if (!v4)
  {
    v345 = 0;
    v14 = dword_1EF19FC9C;
    if (dword_1EF19FC9C >= 5)
    {
      v268 = *__error();
      v269 = _SILogForLogForCategory(4);
      if (os_log_type_enabled(v269, OS_LOG_TYPE_DEFAULT))
      {
        v270 = *(_QWORD *)(v9 + 24);
        v271 = *(_DWORD *)(v9 + 52);
        LODWORD(v357[0]) = 134218496;
        *(unint64_t *)((char *)v357 + 4) = v270;
        WORD2(v357[1]) = 1024;
        *(_DWORD *)((char *)&v357[1] + 6) = v271;
        WORD1(v357[2]) = 1024;
        HIDWORD(v357[2]) = v271;
        _os_log_impl(&dword_1B8270000, v269, OS_LOG_TYPE_DEFAULT, "_setAttributes oid: %lld source: %d options: 0x%x", (uint8_t *)v357, 0x18u);
      }
      *__error() = v268;
      v14 = dword_1EF19FC9C;
    }
    v325 = v8;
    v15 = (unint64_t *)(v9 + 24);
    v16 = *(_DWORD *)(v9 + 48);
    v17 = v16 & 1;
    if (*(_QWORD *)(v9 + 24))
      v18 = (v16 >> 1) & 1;
    else
      v18 = 1;
    v19 = v18 != 1 || v14 < 5;
    LODWORD(v331) = *(_DWORD *)(v9 + 48);
    if (!v19)
    {
      v277 = *__error();
      v278 = _SILogForLogForCategory(4);
      if (os_log_type_enabled(v278, OS_LOG_TYPE_DEFAULT))
      {
        v280 = *v15;
        LODWORD(v357[0]) = 134217984;
        *(unint64_t *)((char *)v357 + 4) = v280;
        _os_log_impl(&dword_1B8270000, v278, OS_LOG_TYPE_DEFAULT, "Dummy coming in oid: %lld", (uint8_t *)v357, 0xCu);
      }
      *__error() = v277;
      v16 = *(_DWORD *)(v9 + 48);
    }
    v327 = v17 == 0;
    LODWORD(v332) = v16 & 0x100;
    v20 = (_DWORD)v332 == 0;
    v319 = v6;
    if ((v16 & 0x100) == 0 && v17)
      v20 = (v16 & 0x24) != 0;
    v21 = *(_DWORD *)(v9 + 64);
    v22 = v16;
    if ((v18 & 1) == 0)
    {
      v23 = *(const __CFDictionary **)(v9 + 16);
      v22 = v16;
      if (v23)
      {
        if (CFDictionaryGetValue(v23, CFSTR("_kMDItemDeleted")))
          v22 = v16 | 0x8000;
        else
          v22 = v16;
      }
    }
    if ((v22 & 0x18000) == 0x10000)
    {
      bzero(v357, 0x400uLL);
      if (!(*(uint64_t (**)(void))(*(_QWORD *)(*(_QWORD *)v9 + 1416) + 40))())
        v22 |= 0x8000u;
    }
    v334 = v16;
    LODWORD(v330) = v22;
    if ((v22 & 0x8000) != 0)
    {
      v27 = *v15;
      if (*v15)
      {
        v28 = &unk_1EF19F000;
        if (dword_1EF19FC9C >= 5)
        {
          v285 = *__error();
          v286 = _SILogForLogForCategory(4);
          if (os_log_type_enabled(v286, OS_LOG_TYPE_DEFAULT))
          {
            v287 = *v15;
            LODWORD(v357[0]) = 134217984;
            *(unint64_t *)((char *)v357 + 4) = v287;
            _os_log_impl(&dword_1B8270000, v286, OS_LOG_TYPE_DEFAULT, "deleting oid: %lld", (uint8_t *)v357, 0xCu);
          }
          *__error() = v285;
          v27 = *v15;
        }
        LOBYTE(v357[0]) = 0;
        v29 = *(_QWORD *)v9;
        _si_delete_attributes_inner(*(_QWORD *)v9, v27, 0, 0, 1u, 0, v357);
        si_finish_text_store_deletions(v29);
        if (LOBYTE(v357[0]))
          notify_post("com.apple.spotlight.SyndicatedContentDeleted");
        v26 = 1;
LABEL_42:
        v30 = *(_QWORD *)v9;
        v31 = !v20;
        if (*(_BYTE *)(*(_QWORD *)v9 + 2072))
          v31 = 1;
        if ((v31 & 1) == 0 && dword_1EF19FCBC >= 4 && !v26)
        {
          bzero(v357, 0x400uLL);
          v33 = (*(uint64_t (**)(void))(*(_QWORD *)(v30 + 1416) + 40))();
          if (v33)
          {
            v312[510] = v33;
            CFLog();
          }
        }
        if (v17)
        {
          v34 = v334;
          if (*(_QWORD *)(v9 + 8) == *MEMORY[0x1E0C9B0D0])
          {
            v281 = __si_assert_copy_extra_521(*(_DWORD *)(*(_QWORD *)v9 + 32));
            v282 = v281;
            v283 = "";
            if (v281)
              v283 = v281;
            __message_assert("%s:%u: failed assertion '%s' %s src: %d id: %d oid: %lld parent: %lld options: %x extra: %p", "SpotlightIndex.c", 23023, "(CFTypeRef)ctx->attrdict!=(CFTypeRef)kCFNull", v283, *(_DWORD *)(v9 + 52), *(_DWORD *)(v9 + 64), *(_QWORD *)(v9 + 24), *(_QWORD *)(v9 + 32), *(_DWORD *)(v9 + 48), *(const void **)(v9 + 16));
            free(v282);
            if (__valid_fs(*(_DWORD *)(*(_QWORD *)v9 + 32)))
              v284 = 2989;
            else
              v284 = 3072;
            *(_DWORD *)v284 = -559038737;
            abort();
          }
          if (((unsigned __int16)v330 & 0x400) != 0)
          {
            LOBYTE(v37) = 0;
            v36 = 0;
          }
          else
          {
            v35 = (unsigned __int16)v330 & 0x200;
            v36 = v35 == 0;
            v37 = v35 >> 9;
          }
        }
        else
        {
          LOBYTE(v37) = 0;
          v36 = 0;
          v34 = v334;
        }
        if ((v34 & 0x40) != 0)
          v38 = 4;
        else
          v38 = 6;
        if ((v34 & 0xC0) == 0)
          v38 = 7;
        if ((v34 & 0x1C0) == 0)
        {
          v38 = 5;
          v39 = 5;
          v40 = 5;
          if ((v34 & 0x20) != 0 || !v17)
            goto LABEL_64;
          v50 = (v34 & 0x1000) == 0;
          v51 = !v20 || !v50;
          v38 = v20 && v50 ? 1 : 9;
          v39 = v20 && v50 ? 2 : 9;
          v40 = v51 ? 9 : 3;
          if (((v20 | ((unsigned __int16)(v34 & 0x1000) >> 12)) & 1) != 0)
            goto LABEL_64;
          v38 = ((int)(v34 << 18) >> 31) & 5;
        }
        v39 = v38;
        v40 = v38;
LABEL_64:
        v341 = v17;
        if ((v37 & 1) != 0)
          v41 = v38;
        else
          v41 = v40;
        LODWORD(v318) = v36;
        if (v36)
          v42 = v39;
        else
          v42 = v41;
        v43 = *(_DWORD *)(v9 + 52);
        if (v43 - 10 >= 3)
          v44 = v42;
        else
          v44 = v43;
        v45 = v43 - 10 < 3 || v20;
        v337 = v45;
        if (!*(_BYTE *)(*(_QWORD *)v9 + 2072) && (_DWORD)v44 != v43)
        {
          v46 = *__error();
          v47 = _SILogForLogForCategory(4);
          if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
          {
            v116 = *(_DWORD *)(v9 + 52);
            v117 = *(unsigned __int8 ***)(v9 + 24);
            LODWORD(v357[0]) = 136316418;
            *(unint64_t *)((char *)v357 + 4) = (unint64_t)"_setAttributes";
            WORD2(v357[1]) = 1024;
            *(_DWORD *)((char *)&v357[1] + 6) = 23074;
            WORD1(v357[2]) = 1024;
            HIDWORD(v357[2]) = v116;
            LOWORD(v357[3]) = 1024;
            *(_DWORD *)((char *)&v357[3] + 2) = v44;
            HIWORD(v357[3]) = 2048;
            v358 = v117;
            LOWORD(v359) = 1024;
            *(_DWORD *)((char *)&v359 + 2) = (_DWORD)v330;
            _os_log_error_impl(&dword_1B8270000, v47, OS_LOG_TYPE_ERROR, "%s:%d: ctx->source: %d != source: %d oid: %lld options: %x", (uint8_t *)v357, 0x2Eu);
          }
          *__error() = v46;
          LOBYTE(v34) = v334;
        }
        v338 = v34 & 0x80;
        if (!v26)
        {
          v48 = *(const __CFDictionary **)(v9 + 8);
          if (v48)
          {
            bzero(v357, 0x400uLL);
            bzero(&v369, 0x400uLL);
            bzero(&v362, 0x400uLL);
            Value = (const __CFString *)CFDictionaryGetValue(v48, CFSTR(":MD:kMDItemPath"));
            if (Value && CFStringGetCString(Value, (char *)&v369, 1024, 0x8000100u))
              snprintf((char *)v357, 0x400uLL, "processing oid: %lld source: %d %s", *v15, v44, (const char *)&v369);
            else
              snprintf((char *)v357, 0x400uLL, "processing oid: %lld source: %d", *v15, v44);
            snprintf((char *)&v362, 0x400uLL, "processing oid: %lld source: %d", *v15, v44);
            _si_set_error_str((const char *)v357);
            _si_set_rebuild_reason((const char *)&v362, 0);
          }
        }
        LODWORD(v333) = v26;
        v342 = *(_QWORD *)v9;
        if ((v338 >> 7) | (v332 >> 8))
        {
          v52 = *__error();
          v53 = _SILogForLogForCategory(4);
          v54 = 2 * (dword_1EF19FC9C < 4);
          if (os_log_type_enabled(v53, v54))
          {
            v55 = *v15;
            LODWORD(v357[0]) = 134218496;
            *(unint64_t *)((char *)v357 + 4) = v55;
            WORD2(v357[1]) = 1024;
            *(_DWORD *)((char *)&v357[1] + 6) = (_DWORD)v330;
            WORD1(v357[2]) = 1024;
            HIDWORD(v357[2]) = v21;
            _os_log_impl(&dword_1B8270000, v53, v54, "DEQUEUE oid: %lld, o: %x t: %d", (uint8_t *)v357, 0x18u);
          }
          *__error() = v52;
        }
        v339 = (_QWORD *)(v9 + 24);
        v340 = v44;
        v326 = *(CFDictionaryRef *)(v9 + 8);
        v56 = *(const __CFDictionary **)(v9 + 16);
        v57 = *(_QWORD *)(v9 + 32);
        v336 = *(_QWORD *)(v9 + 24);
        v322 = *(_QWORD *)(v9 + 40);
        v323 = v56;
        v321 = v57;
        if (v341)
        {
          v58 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
          v59 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberLongLongType, v339);
          v60 = v342;
          v61 = (pthread_mutex_t *)(v342 + 1816);
          pthread_mutex_lock((pthread_mutex_t *)(v342 + 1816));
          if (MEMORY[0x1BCCAF3F0](*(_QWORD *)(v342 + 1800), v59) < 2)
          {
            v63 = (const __CFArray *)CFDictionaryGetValue(*(CFDictionaryRef *)(v342 + 1808), v59);
            v62 = v63;
            if (v63)
            {
              CFRetain(v63);
              CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v342 + 1808), v59);
            }
          }
          else if (dword_1EF19FC9C >= 5)
          {
            v288 = *__error();
            v289 = _SILogForLogForCategory(4);
            if (os_log_type_enabled(v289, OS_LOG_TYPE_DEFAULT))
            {
              v290 = *v339;
              LODWORD(v357[0]) = 134217984;
              *(unint64_t *)((char *)v357 + 4) = v290;
              _os_log_impl(&dword_1B8270000, v289, OS_LOG_TYPE_DEFAULT, "Duplicate in flight oid: %lld", (uint8_t *)v357, 0xCu);
            }
            v62 = 0;
            *__error() = v288;
            LODWORD(v333) = 1;
            v28 = &unk_1EF19F000;
            v60 = v342;
          }
          else
          {
            v62 = 0;
            LODWORD(v333) = 1;
          }
          CFBagRemoveValue(*(CFMutableBagRef *)(v60 + 1800), v59);
          pthread_mutex_unlock(v61);
          CFRelease(v59);
          if (v62)
          {
            Mutable = CFDictionaryCreateMutable(v58, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
            v65 = *(_QWORD *)(v9 + 8);
            v335 = Mutable;
            v357[0] = (unint64_t)Mutable;
            v357[1] = v65;
            Count = CFArrayGetCount(v62);
            if (Count >= 1)
            {
              v67 = Count + 1;
              do
              {
                ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v62, v67 - 2);
                CFDictionaryApplyFunction(ValueAtIndex, (CFDictionaryApplierFunction)preProcessInFlight, v357);
                --v67;
              }
              while (v67 > 1);
            }
            v320 = (char *)CFDictionaryGetCount(v335);
            if (!v320)
            {
              CFRelease(v335);
              v335 = 0;
            }
            CFRelease(v62);
          }
          else
          {
            v335 = 0;
            v320 = 0;
          }
        }
        else
        {
          v335 = 0;
          v320 = 0;
          v60 = v342;
        }
        v69 = 0;
        v324 = v331 & 0x4800;
        if ((_DWORD)v340 == 4)
          v70 = 1;
        else
          v70 = v337;
        *(_QWORD *)&v2 = 67109376;
        v328 = v2;
        *(_QWORD *)&v2 = 67109120;
        v329 = v2;
        do
        {
          if (v70)
            LiveIndex = si_getLiveIndex(*(_QWORD *)(v60 + 1384));
          else
            LiveIndex = si_getSyncIndex(v60, v21);
          SyncIndex = LiveIndex;
          if (v21 < 1)
            goto LABEL_146;
          v21 &= ~(v21 >> 31);
          if (v21 > LiveIndex[8] && !*((_BYTE *)LiveIndex + 36))
          {
            v73 = *__error();
            v74 = _SILogForLogForCategory(4);
            v75 = v28;
            v76 = v74;
            v77 = v75;
            v78 = v75[807] < 3;
            if (os_log_type_enabled(v74, v78))
            {
              v79 = SyncIndex[8];
              v357[0] = __PAIR64__(v21, v328);
              LOWORD(v357[1]) = 1024;
              *(_DWORD *)((char *)&v357[1] + 2) = v79;
              _os_log_impl(&dword_1B8270000, v76, v78, "*warn* Unexpected transaction id %d. Expected %d. Attempting repair", (uint8_t *)v357, 0xEu);
            }
            *__error() = v73;
            v60 = v342;
            si_sync_ctx_create_with_defer_fd(v342, 0);
            v81 = v80;
            *(_DWORD *)(v80 + 80) = v21 - 1;
            v82 = *(_QWORD *)(v60 + 1048);
            v83 = qos_class_self();
            si_enqueue_barrier_with_qos(v82, v83, (uint64_t)si_initialIndexingEndedQueueOnFlush, v81);
            v84 = *__error();
            v85 = _SILogForLogForCategory(4);
            v86 = v77[807] < 3;
            if (os_log_type_enabled(v85, v86))
            {
              v357[0] = __PAIR64__(si_getSyncIndex(v60, v21)[8], v329);
              _os_log_impl(&dword_1B8270000, v85, v86, "*warn* Transaction id is now %d", (uint8_t *)v357, 8u);
            }
            *__error() = v84;
            SyncIndex = si_getSyncIndex(v60, v21);
            v28 = v77;
          }
          v87 = SyncIndex[8];
          if (v21 <= v87 || SyncIndex == v69 || SyncIndex == 0)
            break;
          v69 = SyncIndex;
        }
        while (!*((_BYTE *)SyncIndex + 36));
        v10 = v21 < v87;
        v90 = v337;
        if (!v10)
          v90 = 1;
        if (((v327 | v90) & 1) != 0)
        {
LABEL_146:
          v91 = (int)v333;
        }
        else
        {
          v91 = (int)v333;
          if (!*((_BYTE *)SyncIndex + 36))
          {
            if (*(_DWORD *)(v60 + 2424) < v21 && v336 != -1)
            {
              *(_DWORD *)(v60 + 2424) = v21;
              v99 = *__error();
              v100 = _SILogForLogForCategory(4);
              v101 = v28[807] < 3;
              if (os_log_type_enabled(v100, v101))
              {
                v102 = SyncIndex[8];
                LODWORD(v357[0]) = 67109632;
                HIDWORD(v357[0]) = v21;
                LOWORD(v357[1]) = 1024;
                *(_DWORD *)((char *)&v357[1] + 2) = v102;
                HIWORD(v357[1]) = 2048;
                v357[2] = v336;
                _os_log_impl(&dword_1B8270000, v100, v101, "*warn* Items's transaction id %d is too low for the current index %d. Discarding oid %llx.", (uint8_t *)v357, 0x18u);
              }
              *__error() = v99;
            }
            v92 = v336;
            goto LABEL_163;
          }
        }
        v92 = v336;
        if (!v91)
        {
          if (!v336)
          {
            if ((int)v28[807] < 5)
            {
LABEL_469:
              LOBYTE(v97) = 1;
              goto LABEL_470;
            }
            v97 = *__error();
            v98 = _SILogForLogForCategory(4);
            if (os_log_type_enabled(v98, OS_LOG_TYPE_DEFAULT))
            {
              LODWORD(v357[0]) = 134217984;
              *(unint64_t *)((char *)v357 + 4) = 0;
              _os_log_impl(&dword_1B8270000, v98, OS_LOG_TYPE_DEFAULT, "oid is zero: %lld", (uint8_t *)v357, 0xCu);
            }
            *__error() = v97;
            LOBYTE(v97) = 1;
            v60 = v342;
            v92 = v336;
LABEL_470:
            if (v338 && !*v339)
            {
              v232 = *__error();
              v233 = _SILogForLogForCategory(4);
              v234 = 2 * (v28[807] < 4);
              if (os_log_type_enabled(v233, v234))
              {
                LOWORD(v357[0]) = 0;
                _os_log_impl(&dword_1B8270000, v233, v234, "All recovery items processed", (uint8_t *)v357, 2u);
              }
              *__error() = v232;
              *(_BYTE *)(v60 + 6892) = 1;
              v92 = v336;
            }
            if (SyncIndex)
              v235 = v97;
            else
              v235 = 1;
            v236 = v339;
            if ((v235 & 1) == 0)
            {
              v237 = si_getLiveIndex(*(_QWORD *)(*(_QWORD *)v9 + 1384));
              _CIUpdateContent((uint64_t)v237, 0, 0, 0, 0, 0, 0, 0, 0.0, 0, 0, 0, v340, 0, (*(_DWORD *)(v342 + 6584) >> 19) & 3, (uint64_t (*)(uint64_t))lowDiskSpaceCallback, v342, 0, 0,
                *(_QWORD *)(v342 + 2464),
                v325,
                0);
              if (v92)
              {
                v238 = *__error();
                v239 = _SILogForLogForCategory(4);
                v240 = 2 * (v28[807] < 4);
                if (os_log_type_enabled(v239, v240))
                {
                  LODWORD(v357[0]) = 134217984;
                  *(unint64_t *)((char *)v357 + 4) = v92;
                  _os_log_impl(&dword_1B8270000, v239, v240, "Dummy for oid %lld", (uint8_t *)v357, 0xCu);
                }
                *__error() = v238;
              }
            }
            v241 = (unsigned int *)(v342 + 1484);
            v242 = *(_DWORD *)(v342 + 1484);
            while (1)
            {
              v243 = __ldxr(v241);
              if (v243 != v242)
                break;
              if (!__stxr(0, v241))
                goto LABEL_488;
            }
            __clrex();
LABEL_488:
            if (v335)
              CFRelease(v335);
            _si_set_error_str(0);
            v244 = *(_QWORD *)(v9 + 56);
            if (v244)
            {
              v245 = *(_QWORD *)(v342 + 1048);
              v246 = *(NSObject **)(v245 + 8);
              v357[0] = MEMORY[0x1E0C809B0];
              v357[1] = 0x40000000;
              v357[2] = (unint64_t)__si_pop_queue_block_invoke;
              v357[3] = (unint64_t)&__block_descriptor_tmp_39_1079;
              v358 = (unsigned __int8 **)v245;
              v359 = v244;
              v360 = 1;
              v361 = v236;
              dispatch_sync(v246, v357);
            }
            goto LABEL_492;
          }
          v93 = (char *)SyncIndex + 15163;
          v94 = *(int **)(v60 + 1184);
          v344 = 0;
          obj_callback = db_get_obj_callback(v94, v336, (void **)&v344, 0x10000, *(_QWORD *)(v60 + 2368), 0);
          v96 = obj_callback;
          if ((_DWORD)obj_callback)
          {
            if ((_DWORD)obj_callback == 9)
            {
              v97 = 0;
              v92 = v336;
              goto LABEL_461;
            }
          }
          else
          {
            obj_callback = (uint64_t)db_validate_obj(v94);
          }
          MEMORY[0x1E0C80A78](obj_callback);
          bzero(v312, 0x1000uLL);
          v103 = _SIStackAllocatorCreate(v312, 4096, indexingZone);
          if (v326)
            v104 = CFDictionaryGetCount(v326);
          else
            v104 = 0;
          v315 = (char *)SyncIndex + 15163;
          v105 = v323;
          v333 = v94;
          if (v323)
            v105 = (CFDictionaryRef)CFDictionaryGetCount(v323);
          v106 = &v320[v104 + (_QWORD)v105];
          v107 = v106 + 4;
          v317 = v103;
          v108 = (char *)CFAllocatorAllocate(v103, 16 * (uint64_t)&v106[(_QWORD)(v106 + 4)] + 656, 16 * (uint64_t)&v106[(_QWORD)(v106 + 4)] + 656);
          v109 = 0;
          v388 = 0u;
          v389 = 0u;
          v110 = v106 + 27;
          v386 = 0u;
          v387 = 0u;
          v316 = (const void **)&v108[8 * (_QWORD)(v106 + 27)];
          v111 = &v316[(_QWORD)(v106 + 27)];
          v384 = 0u;
          v385 = 0u;
          v112 = &v111[(_QWORD)v106];
          v383 = 0u;
          v382 = 0u;
          v381 = 0u;
          v380 = 0u;
          v379 = 0u;
          v378 = 0u;
          v377 = 0u;
          v376 = 0u;
          v375 = 0u;
          memset(v374, 0, sizeof(v374));
          v373 = 0u;
          v372 = 0u;
          v369 = 0xFFF0000000000000;
          v371 = 0u;
          v370 = 0u;
          v113 = ((_DWORD)v340 == 10) | (2 * v341);
          LODWORD(v371) = v113;
          LODWORD(v328) = v96;
          if (v96)
          {
            v60 = v342;
            goto LABEL_188;
          }
          v114 = v108;
          v60 = v342;
          if (!v344)
          {
LABEL_176:
            v108 = v114;
            goto LABEL_188;
          }
          if ((*(_BYTE *)(v342 + 6584) & 0x10) == 0)
          {
LABEL_175:
            v109 = 0;
            goto LABEL_176;
          }
          if (objectIsMarker(*(int **)(v342 + 1184), (uint64_t)v344))
            goto LABEL_186;
          if (v326)
          {
            if (CFDictionaryContainsKey(v326, CFSTR(":MD:_kMDItemBackupMoveMarker")))
              goto LABEL_186;
            v115 = CFDictionaryContainsKey(v326, CFSTR(":MD:_kMDItemBackupMoveMarker"));
            if (!v323 || v115)
            {
LABEL_510:
              v113 = v371;
              if (!v115)
                goto LABEL_175;
              goto LABEL_187;
            }
          }
          else
          {
            v109 = (int)v323;
            if (!v323)
            {
              v113 = v371;
              goto LABEL_176;
            }
          }
          if (!CFDictionaryContainsKey(v323, CFSTR(":MD:_kMDItemBackupMoveMarker")))
          {
            v115 = CFDictionaryContainsKey(v323, CFSTR(":MD:_kMDItemBackupMoveMarker"));
            goto LABEL_510;
          }
LABEL_186:
          v113 = v371;
LABEL_187:
          v108 = v114;
          v109 = 128;
LABEL_188:
          v118 = v333;
          v119 = v113 & 0xFFFFFE7F | v109 | (*(unsigned __int8 *)(v60 + 2072) << 8) | 0x1000;
          v314 = v108;
          *(_QWORD *)&v375 = v108;
          *((_QWORD *)&v375 + 1) = v316;
          *((_QWORD *)&v376 + 1) = v110;
          *(_QWORD *)&v378 = v111;
          *((_QWORD *)&v378 + 1) = v112;
          *((_QWORD *)&v379 + 1) = v107;
          LODWORD(v371) = v119;
          DWORD2(v387) = -1;
          DWORD2(v388) = -1;
          v120 = v321;
          v121 = v323;
          if (v344)
          {
            LOBYTE(v343) = 0;
            v357[0] = 0;
            v362 = 0;
            if (db_get_field(v333, (uint64_t)v344, "_kMDItemGroupId", v357, &v362))
            {
              if (!si_getGroupFromDBO(v60, (uint64_t)v344, &v343) && (int)v28[807] >= 5)
              {
                v122 = *__error();
                v123 = _SILogForLogForCategory(4);
                if (os_log_type_enabled(v123, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)v346 = 0;
                  _os_log_impl(&dword_1B8270000, v123, OS_LOG_TYPE_DEFAULT, "Couldn't get the group id.", v346, 2u);
                }
                *__error() = v122;
                v60 = v342;
                v121 = v323;
                v118 = v333;
              }
            }
            else if (*(_DWORD *)(v357[0] + 8) == 1)
            {
              LOBYTE(v343) = *v362;
            }
            if ((v343 & 0xF7) == 2)
              LODWORD(v371) = v371 | 0x400;
          }
          if ((unint64_t)v326 | (unint64_t)v121)
          {
            if (v335)
            {
              v124 = v335;
              CFDictionaryApplyFunction(v335, (CFDictionaryApplierFunction)preProcess, &v369);
              CFRelease(v124);
            }
            if (v121)
              CFDictionaryApplyFunction(v121, (CFDictionaryApplierFunction)preProcess, &v369);
            *((_QWORD *)&v383 + 1) = v121;
            if (v326)
              CFDictionaryApplyFunction(v326, (CFDictionaryApplierFunction)preProcess, &v369);
            postPreprocess((uint64_t)&v369, 0);
            handleUserTags((uint64_t)&v369);
            if ((_QWORD)v384)
            {
              if (SyncIndex)
              {
                if (v340 <= 3)
                {
                  ContentIndexUpdateTimeStamp(SyncIndex, v384, v318, v337);
                  if ((unint64_t)v384 > *(_QWORD *)(v60 + 2408))
                    *(_QWORD *)(v60 + 2408) = v384;
                }
              }
            }
            if ((_QWORD)v372)
            {
              InsertPreProcessContextAddAttr((uint64_t)&v369, CFSTR("_kTimeMachineOldestSnapshot"), (CFTypeRef)v372, 0);
              *(_QWORD *)&v372 = 0;
            }
            if (*((_QWORD *)&v371 + 1))
            {
              InsertPreProcessContextAddAttr((uint64_t)&v369, CFSTR("_kTimeMachineNewestSnapshot"), *((CFTypeRef *)&v371 + 1), 0);
              *((_QWORD *)&v371 + 1) = 0;
            }
            v125 = v371;
            if ((v371 & 0x10) != 0 && (_QWORD)v376)
            {
              v125 = v371 & 0xEF;
              LODWORD(v371) = v371 & 0xFFFFFFEF;
            }
            if ((v125 & 0x20) != 0)
            {
              if (v374[0])
              {
                if (!CFDictionaryGetValue(v326, CFSTR("_kMDItemSnippet")))
                {
                  v126 = SICreateStringByRemovingWhitespaceFromTextContent(v317, v374[0], 300);
                  if (v126)
                    InsertPreProcessContextAddAttr((uint64_t)&v369, CFSTR("_kMDItemSnippet"), v126, 0);
                }
              }
            }
            v335 = 0;
            if (*((_QWORD *)&v389 + 1))
              v127 = v120 == 0;
            else
              v127 = 1;
            if (!v127)
              v120 = *((_QWORD *)&v389 + 1);
          }
          if (v344)
          {
            if (!(_QWORD)v377 && (v331 & 0x800) != 0 && !v341)
            {
              v357[0] = 0;
              v362 = 0;
              if (!db_get_field(v118, (uint64_t)v344, "_kMDItemUserTags", v357, &v362))
              {
                v128 = _decodeSDBField((unint64_t)v118, (unsigned __int16 *)v357[0], v362, 0, 0, 0, 0, (CFAllocatorRef)*MEMORY[0x1E0C9AE00]);
                v129 = CFGetTypeID(v128);
                if (v129 == CFStringGetTypeID() || (TypeID = CFArrayGetTypeID(), TypeID == CFGetTypeID(v128)))
                {
                  *(_QWORD *)&v377 = CFSTR(":EA:_kMDItemUserTags");
                  *((_QWORD *)&v377 + 1) = v128;
                  handleUserTags((uint64_t)&v369);
                }
                else
                {
                  CFRelease(v128);
                }
              }
            }
          }
          if ((v371 & 4) != 0 && !v341)
          {
            v131 = *__error();
            v132 = _SILogForLogForCategory(0);
            v133 = 2 * (gSILogLevels[0] < 4);
            if (os_log_type_enabled(v132, v133))
            {
              LOWORD(v357[0]) = 0;
              _os_log_impl(&dword_1B8270000, v132, v133, "Dictionary claims the importer was the origin, but trail tells us it was not. Treating as normal setAttr call.", (uint8_t *)v357, 2u);
            }
            *__error() = v131;
          }
          v134 = v373;
          if ((_QWORD)v373)
            CFRetain((CFTypeRef)v373);
          v135 = (char *)*((_QWORD *)&v373 + 1);
          if (*((_QWORD *)&v373 + 1))
            CFRetain(*((CFTypeRef *)&v373 + 1));
          v320 = v135;
          v331 = v134;
          if (dword_1EF19FCA4 >= 5)
          {
            v291 = *__error();
            v292 = _SILogForLogForCategory(6);
            if (os_log_type_enabled(v292, OS_LOG_TYPE_DEFAULT))
            {
              LODWORD(v357[0]) = 138412546;
              *(unint64_t *)((char *)v357 + 4) = (unint64_t)v320;
              WORD2(v357[1]) = 2112;
              *(unint64_t *)((char *)&v357[1] + 6) = v331;
              _os_log_impl(&dword_1B8270000, v292, OS_LOG_TYPE_DEFAULT, "%@ = %@", (uint8_t *)v357, 0x16u);
            }
            *__error() = v291;
            v60 = v342;
            v118 = v333;
          }
          if (!(_QWORD)v370 && v341)
            LODWORD(v371) = v371 & 0xFFFFFFEF;
          if (*(_BYTE *)(*(_QWORD *)v9 + 2072))
          {
            v136 = v330 | 0x200;
          }
          else
          {
            v137 = v341;
            if (v324)
              v137 = 1;
            if (v137)
              v136 = v330 | 0x200;
            else
              v136 = v330;
          }
          LODWORD(v321) = v136;
          if (!v322 || (v138 = *(_QWORD *)(v322 + 56)) == 0)
            v138 = gDefaultSchema;
          v139 = (_DWORD)v328 != 0;
          if (!(_DWORD)v328)
          {
            if (v344)
            {
              if (!v341)
              {
                if (*(_QWORD *)(v60 + 1144))
                {
                  v140 = v344[4];
                  if (v140)
                  {
                    if (v140 > *(_QWORD *)(v60 + 1304)
                      && v140 <= *(_QWORD *)(v60 + 1312)
                      && objectHasContent(v118, (uint64_t)v344)
                      && (v371 & 0x20) == 0)
                    {
                      v141 = *v344;
                      free(v344);
                      v344 = 0;
                      cleanupPreProcContext(&v369);
                      if (v314)
                        CFAllocatorDeallocate(v317, v314);
                      v92 = v336;
                      if (!(_QWORD)v376)
                      {
                        v257 = malloc_type_malloc(0x50uLL, 0x10E0040BFFD03D2uLL);
                        *v257 = *(_OWORD *)v9;
                        v258 = *(_OWORD *)(v9 + 64);
                        v260 = *(_OWORD *)(v9 + 16);
                        v259 = *(_OWORD *)(v9 + 32);
                        v257[3] = *(_OWORD *)(v9 + 48);
                        v257[4] = v258;
                        v257[1] = v260;
                        v257[2] = v259;
                        *(_OWORD *)(v9 + 48) = 0u;
                        *(_OWORD *)(v9 + 64) = 0u;
                        *(_OWORD *)(v9 + 16) = 0u;
                        *(_OWORD *)(v9 + 32) = 0u;
                        *(_OWORD *)v9 = 0u;
                        si_enqueue_work(*(_QWORD *)(v60 + 1144), (uint64_t)setAttributes, (uint64_t)v257);
                        return;
                      }
                      (*(void (**)(_QWORD, uint64_t, _QWORD, _QWORD))(*(_QWORD *)(v60 + 2360) + 16))(*(_QWORD *)(*(_QWORD *)(v60 + 2360) + 136), v141, 0, 0);
                      goto LABEL_164;
                    }
                  }
                }
              }
            }
          }
          if (v341)
            v142 = 1;
          else
            v142 = v139;
          if ((v142 & 1) == 0
            && v374[0] != (CFStringRef)*MEMORY[0x1E0C9B0D0]
            && (objectHasContent(v118, (uint64_t)v344) || (*(_BYTE *)(v60 + 6584) & 0x10) != 0))
          {
            v143 = decodeDBOToDictionary(v118, (uint64_t)v344, 0, 0x2000, 2, *(_DWORD *)(v60 + 2028), *(_DWORD *)(v60 + 2060), 0, 0, v317);
          }
          else
          {
            v143 = 0;
          }
          v144 = 0;
          v330 = v143;
          v318 = 0;
          if ((_DWORD)v328)
          {
            v145 = v336;
          }
          else
          {
            v145 = v336;
            if (v344)
            {
              v357[0] = *(unsigned int *)(v60 + 2012);
              v362 = 0;
              *(_QWORD *)v346 = 0;
              field_by_id = db_get_field_by_id(v118, (uint64_t)v344, (int *)v357, (unint64_t *)&v362, (unint64_t *)v346);
              v147 = 0;
              if (!field_by_id)
                v147 = **(_QWORD **)v346;
              v318 = v147;
              LODWORD(v357[0]) = *(_DWORD *)(v60 + 2008);
              if (db_get_field_by_id(v118, (uint64_t)v344, (int *)v357, (unint64_t *)&v362, (unint64_t *)v346))v144 = 0;
              else
                v144 = **(_BYTE **)v346;
            }
          }
          v313 = v144;
          si_indexDeleteDeferredItemsIfItemIncluded(v60, v145);
          *(_QWORD *)&v328 = v344;
          if (v344)
          {
            v148 = v344;
            v344 = (uint64_t *)db_copy_obj((unsigned int *)v344, 1024);
            db_validate_obj(v118);
            free(v148);
            v149 = (_DWORD)v340 == 10 && v324 == 0;
            v150 = v327;
            if (v149)
              v150 = 0;
            if (v150)
            {
              v151 = candidateForReimport(v60, (uint64_t *)&v344);
              v152 = 0;
            }
            else
            {
              if (v341)
              {
                v155 = db_delete_fields_with_flags(v118, (uint64_t)v344);
                v152 = v155 == 0;
                if (v155 && dword_1EF19FCA8 >= 5)
                {
                  v304 = v155;
                  v305 = *__error();
                  v306 = _SILogForLogForCategory(7);
                  if (os_log_type_enabled(v306, OS_LOG_TYPE_DEFAULT))
                  {
                    v357[0] = __PAIR64__(v304, v329);
                    _os_log_impl(&dword_1B8270000, v306, OS_LOG_TYPE_DEFAULT, "Deleting importer fields failed, rc:%d", (uint8_t *)v357, 8u);
                  }
                  *__error() = v305;
                  v60 = v342;
                }
                if (!v374[0])
                  InsertPreProcessContextAddAttr((uint64_t)&v369, CFSTR("_kMDItemTextContentIndexExists"), (CFTypeRef)*MEMORY[0x1E0C9AE40], 0);
              }
              else
              {
                v152 = 0;
              }
              v151 = 0;
            }
          }
          else
          {
            obj = (uint64_t *)db_create_obj((uint64_t)v118, 1024, 0);
            v152 = 0;
            v51 = (_DWORD)v340 == 10;
            v344 = obj;
            *obj = v145;
            v151 = (!v51 || v324 != 0) && v327;
          }
          if ((v371 & 8) != 0)
            *((_DWORD *)v344 + 10) |= 2u;
          LODWORD(v329) = v151;
          if ((_DWORD)v332)
          {
            v159 = (const void *)v331;
            if (*(_QWORD *)(v9 + 8))
            {
              v294 = __si_assert_copy_extra_521(-1);
              v295 = v294;
              v296 = (const __CFAllocator *)"";
              if (v294)
                v296 = (const __CFAllocator *)v294;
              *(_QWORD *)v310 = "ctx->attrdict==((void *)0)";
              allocator = v296;
              v297 = 23694;
              goto LABEL_560;
            }
            v362 = 0;
            v363 = &v362;
            v364 = 0x2000000000;
            LOBYTE(v365) = 0;
            v160 = *(_DWORD **)(v60 + 6880);
            v93 = v315;
            if (v160)
            {
              *(_QWORD *)v346 = 0;
              if (!db_get_obj(v160, *v344, (void **)v346, 0))
              {
                v161 = *(_QWORD *)v346;
                *((_DWORD *)v344 + 10) = *(_DWORD *)(*(_QWORD *)v346 + 40);
                *((_BYTE *)v363 + 24) = 1;
                v162 = *(_DWORD **)(v60 + 6880);
                v357[0] = MEMORY[0x1E0C809B0];
                v357[1] = 0x40000000;
                v357[2] = (unint64_t)__si_addRecoveryAttributes_block_invoke;
                v357[3] = (unint64_t)&unk_1E6E34CA0;
                v358 = &v362;
                v359 = v60;
                v360 = (uint64_t)&v344;
                v361 = (_QWORD *)v161;
                _enumerate_dbo(v162, v161, 0, (uint64_t)v357);
                free(*(void **)v346);
              }
              v163 = *((_BYTE *)v363 + 24) != 0;
            }
            else
            {
              v163 = 0;
            }
            _Block_object_dispose(&v362, 8);
            v164 = v152 || v163;
            v165 = 1;
LABEL_393:
            v92 = v336;
            if (!v163 || !v164)
            {
              if ((int)v28[807] < 5)
              {
                v97 = 0;
                v215 = v317;
LABEL_453:
                if (v320)
                  CFRelease(v320);
                if (v159)
                  CFRelease(v159);
                cleanupPreProcContext(&v369);
                if (v330)
                  CFRelease(v330);
                if (v314)
                  CFAllocatorDeallocate(v215, v314);
LABEL_461:
                if (v344)
                {
                  free(v344);
                  v344 = 0;
                }
                if (SyncIndex)
                  v230 = v97;
                else
                  v230 = 0;
                if (v230 == 1)
                {
                  v231 = atomic_load(SyncIndex + 7);
                  if ((v231 & 2) == 0 && !*v93)
                  {
                    if (v93[1229])
                    {
                      v250 = (unsigned __int8 *)(v60 + 1448);
                      do
                        v251 = __ldaxr(v250);
                      while (__stlxr(v251 | 2, v250));
                      if (!v251)
                      {
                        v252 = *__error();
                        v253 = _SILogForLogForCategory(4);
                        v254 = 2 * (v28[807] < 4);
                        if (os_log_type_enabled(v253, v254))
                        {
                          LOWORD(v357[0]) = 0;
                          _os_log_impl(&dword_1B8270000, v253, v254, "Schedule index flush.", (uint8_t *)v357, 2u);
                        }
                        *__error() = v252;
                        v255 = malloc_type_calloc(1uLL, 0x60uLL, 0x10B0040E0DE4348uLL);
                        *v255 = v60;
                        v255[1] = SyncIndex;
                        v256 = SyncIndex[12];
                        *((_DWORD *)v255 + 4) = 2;
                        *((_DWORD *)v255 + 5) = v256;
                        si_indexDeleteDeferredItems(v60);
                        v255[5] = copyHoldQueue(*v255);
                        if (!v255[9] && !*((_DWORD *)v255 + 12))
                        {
                          v261 = *(_QWORD *)(v60 + 2360);
                          if (v261)
                          {
                            v262 = *(uint64_t (**)(_QWORD, const char *, uint64_t, const char *))(v261 + 64);
                            if (v262)
                              *((_DWORD *)v255 + 12) = v262(*(_QWORD *)(v261 + 136), "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 23855, "void _setAttributes(si_set_attr_ctx *, _Bool, dispatch_group_t, Boolean)");
                          }
                        }
                        si_enqueue_work(*(_QWORD *)(v60 + 1040), (uint64_t)_flushCache, (uint64_t)v255);
                      }
                    }
                  }
                  goto LABEL_469;
                }
                goto LABEL_470;
              }
              v301 = *__error();
              v302 = _SILogForLogForCategory(4);
              if (os_log_type_enabled(v302, OS_LOG_TYPE_DEFAULT))
              {
                v303 = *v339;
                LODWORD(v357[0]) = 134217984;
                *(unint64_t *)((char *)v357 + 4) = v303;
                _os_log_impl(&dword_1B8270000, v302, OS_LOG_TYPE_DEFAULT, "No write back for %lld", (uint8_t *)v357, 0xCu);
              }
              v97 = 0;
              *__error() = v301;
              v60 = v342;
              v92 = v336;
              v93 = v315;
              v215 = v317;
              goto LABEL_452;
            }
            LODWORD(v332) = v165;
            v204 = atomic_load(SyncIndex + 7);
            if ((v204 & 3) == 0 && !*v93)
            {
              v205 = v334;
              if ((v371 & 0x40) == 0)
              {
                if (v374[0])
                {
                  v206 = (const __CFString *)CFDictionaryGetValue(v326, CFSTR("kMDItemContentType"));
                  if (v206)
                  {
                    v207 = v206;
                    v208 = CFStringGetTypeID();
                    v321 = v120;
                    v51 = v208 == CFGetTypeID(v207);
                    v93 = v315;
                    v120 = v321;
                    if (v51)
                    {
                      if (CFEqual(v207, CFSTR("public.plain-text"))
                        || CFEqual(v207, CFSTR("public.data"))
                        || CFStringHasPrefix(v207, CFSTR("dyn.")))
                      {
                        goto LABEL_405;
                      }
                      if (v323)
                        v263 = CFDictionaryGetValue(v323, CFSTR("kMDItemContentTypeTree"));
                      else
                        v263 = 0;
                      if (v326 && !v263)
                        v263 = CFDictionaryGetValue(v326, CFSTR("kMDItemContentTypeTree"));
                      if (v263)
                      {
                        v274 = CFArrayGetTypeID();
                        v51 = v274 == CFGetTypeID(v263);
                        v93 = v315;
                        v120 = v321;
                        if (v51)
                        {
                          v391.length = CFArrayGetCount((CFArrayRef)v263);
                          v391.location = 0;
                          if (CFArrayContainsValue((CFArrayRef)v263, v391, CFSTR("public.plain-text")))
LABEL_405:
                            LODWORD(v371) = v371 | 0x40;
                        }
                      }
                    }
                  }
                }
              }
              v209 = 0;
              v210 = v371;
              v211 = v374[0];
              if ((v205 & 0x40) != 0)
              {
                v212 = v331;
                v213 = v328;
                v214 = v329;
              }
              else
              {
                v212 = v331;
                v213 = v328;
                v214 = v329;
                if ((v371 & 0x1000) != 0 && !v374[0])
                {
                  if ((*(_BYTE *)(v9 + 49) & 1) != 0)
                    v209 = 1;
                  else
                    v209 = v327 & (v371 >> 4);
                }
              }
              v216 = v344[3];
              if (v120)
              {
                v344[3] = v120;
                v210 = v371;
              }
              v215 = v317;
              v367 = *(_OWORD *)&v374[1];
              if (v337)
                v217 = ((*(_DWORD *)(v60 + 1276) > 83) << 10) | 2;
              else
                v217 = (*(_DWORD *)(v60 + 1276) > 83) << 10;
              v218 = v217 | (4 * v341);
              if (v324)
                v218 |= 0x10u;
              v219 = v210 >> 3;
              v220 = (2 * v210) & 0xA0 | (((v210 >> 3) & 1) << 6) | v218;
              if (v209)
                v221 = v220 | 0x100;
              else
                v221 = v220;
              v222 = v221 | v219 & 0x200;
              if (!v213)
                v222 |= 0x800u;
              v362 = *(unsigned __int8 **)(v9 + 8);
              v363 = (unsigned __int8 **)v211;
              if (v214)
                v222 |= 0x1000u;
              if ((_DWORD)v332)
                v222 |= 0x2000u;
              if (v325)
                v223 = v222 | 0x4000;
              else
                v223 = v222;
              v364 = (uint64_t)v374[5];
              v365 = v212;
              v366 = v320;
              v368 = *(_OWORD *)&v374[3];
              v224 = si_writeBackAndIndexWithLiveQueryToggle(v60, (uint64_t)SyncIndex, (uint64_t)&v362, (uint64_t)v330, v216, (uint64_t)&v344, v340, v223, v322, *(_DWORD *)(v9 + 64), v318, v313, v345, SHIDWORD(v386), v319);
              if ((_DWORD)v224 != 89)
              {
                v225 = v224;
                if ((_DWORD)v224)
                {
                  if ((_DWORD)v224 != -3)
                  {
                    v226 = v224;
                    if (!*(_BYTE *)(v60 + 2072))
                    {
                      bzero(v357, 0x1000uLL);
                      v343 = 0;
                      OidPathForOid = SIPersistentIDStoreGetOidPathForOid(*(_QWORD *)(v60 + 1416), *v339, (uint64_t)v357, 1, &v343);
                      v226 = OidPathForOid | v343 ? OidPathForOid : 2;
                      if (_setAttributes__COUNT_ >= 1)
                      {
                        --_setAttributes__COUNT_;
                        v228 = *__error();
                        v229 = _SILogForLogForCategory(0);
                        if (os_log_type_enabled(v229, OS_LOG_TYPE_ERROR))
                        {
                          v272 = *(_QWORD *)(v9 + 24);
                          v273 = *(_DWORD *)(v9 + 48);
                          *(_DWORD *)v346 = 136316418;
                          *(_QWORD *)&v346[4] = "_setAttributes";
                          v347 = 1024;
                          v348 = 23795;
                          v349 = 2048;
                          v350 = v272;
                          v351 = 1024;
                          v352 = v273;
                          v353 = 1024;
                          v354 = v225;
                          v355 = 1024;
                          v356 = v226;
                          _os_log_error_impl(&dword_1B8270000, v229, OS_LOG_TYPE_ERROR, "%s:%d: Couldn't update index oid: %lld options: %x updateErr: %d resolveErr: %d", v346, 0x2Eu);
                        }
                        *__error() = v228;
                        v92 = v336;
                        v93 = v315;
                      }
                    }
                    if (v226 != 2 && v226 != 22)
                      si_makeUnavailable(v60, v225, 2 * ((_DWORD)v225 != 22), 16, (uint64_t)"set attributes err");
                    v97 = 0;
                    goto LABEL_452;
                  }
                  if (!*(_BYTE *)(v60 + 2458))
                  {
                    *(_BYTE *)(v60 + 2458) = 1;
                    _SIConsistencyCheck(v60);
                  }
                }
              }
              db_validate_obj(v333);
              v97 = 1;
LABEL_452:
              v159 = (const void *)v331;
              goto LABEL_453;
            }
            v298 = __si_assert_copy_extra_521(-1);
            v295 = v298;
            v299 = "";
            if (v298)
              v299 = v298;
            v307 = "ContentIndexWritable(content_index)";
            v308 = v299;
            v297 = 23702;
LABEL_560:
            __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", v297, v307, v308);
            free(v295);
            if (__valid_fs(-1))
              v300 = 2989;
            else
              v300 = 3072;
            *(_DWORD *)v300 = -559038737;
            abort();
          }
          if ((_QWORD)v379)
          {
            v156 = v333;
            setDatastoreLocalizedAttributes((uint64_t)v333, (int)&v344, (const void **)v378, *((uint64_t *)&v378 + 1), v379, v138, 0, v341, v324 != 0);
            db_validate_obj(v156);
            v152 = 1;
          }
          if ((_QWORD)v376)
          {
            v157 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)v375, v316, v376, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
            if (v341)
              v158 = 1;
            else
              v158 = *(_DWORD *)(v9 + 52) == 12;
            v166 = setDatastoreAttributes((uint64_t)v333, (uint64_t)&v344, v157, v321, v138, 0, v158, v324 != 0);
            v167 = v166;
            if (v157)
            {
              CFRelease(v157);
              v152 = 1;
              if (v167)
                goto LABEL_330;
LABEL_374:
              v163 = 0;
              goto LABEL_375;
            }
            v152 = 1;
            if (!v166)
              goto LABEL_374;
          }
LABEL_330:
          v168 = v370;
          if ((_QWORD)v370)
          {
            v169 = *(double *)&v369;
            v152 = 1;
            v170 = v333;
          }
          else
          {
            if ((BYTE1(v371) & 8) == 0)
              goto LABEL_335;
            v169 = *(double *)&v369;
            v152 = 1;
            v170 = v333;
            v168 = 0;
          }
          markItemAsUsedForField(v170, (uint64_t *)&v344, "kMDItemLastUsedDate", "kMDItemUsedDates", v168, 1, 1, 0, v169);
LABEL_335:
          if ((_QWORD)v387)
          {
            memset(v357, 0, sizeof(v357));
            v171 = CFStringGetTypeID();
            if (v171 == CFGetTypeID((CFTypeRef)v387)
              && CFStringGetCString((CFStringRef)v387, (char *)v357, 32, 0x8000100u))
            {
              Current = CFAbsoluteTimeGetCurrent();
              v173 = DWORD2(v387);
              v174 = (const char *)v357;
              v175 = v333;
            }
            else
            {
              Current = 0.0;
              v175 = v333;
              v174 = 0;
              v173 = 0;
            }
            updateItemRecentEngagementData(v175, (uint64_t *)&v344, v174, v173, "_kMDItemRecentAppSearchEngagementQueries", "_kMDItemRecentAppSearchEngagementDates", "_kMDItemRecentAppSearchEngagementRenderPositions", 1, Current);
            v152 = 1;
          }
          if ((_QWORD)v388)
          {
            memset(v357, 0, sizeof(v357));
            v176 = CFStringGetTypeID();
            if (v176 == CFGetTypeID((CFTypeRef)v388)
              && CFStringGetCString((CFStringRef)v388, (char *)v357, 32, 0x8000100u))
            {
              v177 = CFAbsoluteTimeGetCurrent();
              v178 = DWORD2(v388);
              v179 = (const char *)v357;
              v180 = v333;
            }
            else
            {
              v177 = 0.0;
              v180 = v333;
              v179 = 0;
              v178 = 0;
            }
            updateItemRecentSpotlightEngagementData(v180, (uint64_t *)&v344, v179, v178, v177);
            v152 = 1;
          }
          if ((_QWORD)v389)
          {
            v181 = CFDateGetTypeID();
            v182 = CFGetTypeID((CFTypeRef)v389);
            v183 = 0.0;
            if (v181 == v182)
              v183 = MEMORY[0x1BCCAF690](v389, 0.0);
            updateItemRecentOutOfSpotlightEngagementData(v333, (uint64_t *)&v344, v183);
            v152 = 1;
          }
          if ((_QWORD)v385)
          {
            v184 = v333;
            v345 = markItemAsUsedForField(v333, (uint64_t *)&v344, "_kMDItemInterestingDate", 0, v385, 0, 0, 0x2108u, 0.0);
            v185 = SICopyRoundedDate();
            markItemAsUsedForField(v184, (uint64_t *)&v344, "kMDItemInterestingDate_Ranking", 0, (uint64_t)v185, 0, 0, 0x100u, 0.0);
            CFRelease(v185);
            v152 = 1;
          }
          else
          {
            v186 = *((_QWORD *)&v384 + 1);
            if (*((_QWORD *)&v384 + 1))
              v186 = CFNumberGetValue(*((CFNumberRef *)&v384 + 1), kCFNumberSInt32Type, &v345);
          }
          v187 = *((double *)&v382 + 1);
          if (*(double *)&v382 == 0.0 && *((double *)&v382 + 1) == 0.0 && *(double *)&v383 == 0.0)
          {
            v163 = 1;
LABEL_375:
            v165 = 1;
            v93 = v315;
            v159 = (const void *)v331;
LABEL_389:
            if (v159)
              v203 = v163;
            else
              v203 = 0;
            v164 = v203 || v152;
            goto LABEL_393;
          }
          v321 = v120;
          v332 = v312;
          v188 = "_kMDItemAppEngagementData";
          if (*((double *)&v382 + 1) == 0.0)
            v187 = *(double *)&v383;
          else
            v188 = "_kMDItemEngagementData";
          if (*(double *)&v382 == 0.0)
            v189 = (char *)v188;
          else
            v189 = "_kMDItemRenderData";
          if (*(double *)&v382 == 0.0)
            v190 = v187;
          else
            v190 = *(double *)&v382;
          v362 = 0;
          *(_QWORD *)v346 = 0;
          MEMORY[0x1E0C80A78](v186);
          bzero(v309, 0x2E3uLL);
          v191 = v333;
          db_validate_obj(v333);
          if (*v344)
          {
            field = db_get_field(v191, (uint64_t)v344, v189, (unint64_t *)v346, &v362);
            if (field)
            {
              LODWORD(v316) = *__error();
              v193 = _SILogForLogForCategory(4);
              v194 = v28;
              v195 = 2 * (v28[807] < 4);
              if (os_log_type_enabled(v193, v195))
              {
                LOWORD(v357[0]) = 0;
                _os_log_impl(&dword_1B8270000, v193, v195, "db didn't find any existing values", (uint8_t *)v357, 2u);
              }
              v196 = __error();
              v197 = 0;
              *v196 = (int)v316;
              v28 = v194;
              v60 = v342;
            }
            else
            {
              v197 = *(_DWORD *)(*(_QWORD *)v346 + 8);
            }
            v343 = 0;
            if ((markItemAsRenderedOrEngaged((uint64_t)v309, (uint64_t)v362, v197, &v343, field == 0, v190) & 1) == 0)
            {
              v199 = *__error();
              v202 = _SILogForLogForCategory(4);
              if (os_log_type_enabled(v202, OS_LOG_TYPE_ERROR))
              {
                LODWORD(v357[0]) = 136315394;
                *(unint64_t *)((char *)v357 + 4) = (unint64_t)"_setAttributes";
                WORD2(v357[1]) = 1024;
                *(_DWORD *)((char *)&v357[1] + 6) = 23673;
                _os_log_error_impl(&dword_1B8270000, v202, OS_LOG_TYPE_ERROR, "%s:%d: marking item as rendered/engaged failed", (uint8_t *)v357, 0x12u);
              }
              v120 = v321;
              v93 = v315;
              goto LABEL_385;
            }
            if (db_add_field(v333, (_DWORD **)&v344, 1u, v189, 0, 0, 14, v309, v198, v343))
            {
              v199 = *__error();
              v200 = _SILogForLogForCategory(4);
              v201 = os_log_type_enabled(v200, OS_LOG_TYPE_ERROR);
              v93 = v315;
              if (v201)
              {
                LODWORD(v357[0]) = 136315394;
                *(unint64_t *)((char *)v357 + 4) = (unint64_t)"_setAttributes";
                WORD2(v357[1]) = 1024;
                *(_DWORD *)((char *)&v357[1] + 6) = 23681;
                _os_log_error_impl(&dword_1B8270000, v200, OS_LOG_TYPE_ERROR, "%s:%d: db get field failed in counts code", (uint8_t *)v357, 0x12u);
              }
              v120 = v321;
LABEL_385:
              v159 = (const void *)v331;
              *__error() = v199;
LABEL_388:
              v165 = 0;
              v163 = 1;
              goto LABEL_389;
            }
            v152 = 1;
          }
          v120 = v321;
          v93 = v315;
          v159 = (const void *)v331;
          goto LABEL_388;
        }
LABEL_163:
        if ((int)v28[807] >= 5)
        {
          v275 = *__error();
          v276 = _SILogForLogForCategory(4);
          if (os_log_type_enabled(v276, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(v357[0]) = 134217984;
            *(unint64_t *)((char *)v357 + 4) = v92;
            _os_log_impl(&dword_1B8270000, v276, OS_LOG_TYPE_DEFAULT, "isDummy oid: %lld", (uint8_t *)v357, 0xCu);
          }
          LOBYTE(v97) = 0;
          *__error() = v275;
          goto LABEL_470;
        }
LABEL_164:
        LOBYTE(v97) = 0;
        goto LABEL_470;
      }
    }
    else if ((v18 & 1) == 0)
    {
      v24 = *(const void **)(v9 + 8);
      if (v24)
      {
        v25 = CFGetTypeID(v24);
        v26 = v25 != CFDictionaryGetTypeID();
      }
      else
      {
        v26 = 0;
      }
      goto LABEL_41;
    }
    v26 = 1;
LABEL_41:
    v28 = &unk_1EF19F000;
    goto LABEL_42;
  }
  if (dword_1EF19FC9C >= 5)
  {
    v11 = *__error();
    v12 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      v13 = *(_QWORD *)(v9 + 24);
      LODWORD(v357[0]) = 134217984;
      *(unint64_t *)((char *)v357 + 4) = v13;
      _os_log_impl(&dword_1B8270000, v12, OS_LOG_TYPE_DEFAULT, "Canceled oid: %lld", (uint8_t *)v357, 0xCu);
    }
    *__error() = v11;
  }
LABEL_492:
  v247 = *(const void **)(v9 + 40);
  if (v247)
    CFRelease(v247);
  *(_QWORD *)(v9 + 40) = 0;
  v248 = *(const void **)(v9 + 8);
  if (v248)
    CFRelease(v248);
  *(_QWORD *)(v9 + 8) = 0;
  v249 = *(const void **)(v9 + 16);
  if (v249)
    CFRelease(v249);
  *(_QWORD *)(v9 + 16) = 0;
}

uint64_t __setAttributesBulk_block_invoke(uint64_t a1)
{
  unsigned int v2;
  int v3;
  unint64_t v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  void (*v10)(_QWORD);
  int v11;
  NSObject *v12;
  unint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void (*v22)(_QWORD);
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  unsigned int v26;
  uint8_t buf[4];
  const char *v28;
  __int16 v29;
  int v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  makeThreadId();
  do
  {
    v2 = __ldxr(exceptionSequenceNum);
    v3 = v2 + 1;
  }
  while (__stxr(v2 + 1, exceptionSequenceNum));
  v4 = setThreadIdAndInfo(*(_DWORD *)(a1 + 56), sFdExceptionCallbacks, 0, 1, v3);
  v25 = HIDWORD(v4);
  v26 = v4;
  v23 = v6;
  v24 = v5;
  v7 = *(_QWORD *)&threadData[18 * v4 + 2];
  v8 = v7 + 320 * HIDWORD(v4);
  *(_BYTE *)(v8 + 216) = 0;
  v9 = *(_DWORD *)(v8 + 312);
  v10 = *(void (**)(_QWORD))(v8 + 224);
  if (v10)
    v10(*(_QWORD *)(v7 + 320 * HIDWORD(v4) + 288));
  if (_setjmp((int *)v8))
  {
    v11 = *__error();
    v12 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v28 = "setAttributesBulk_block_invoke";
      v29 = 1024;
      v30 = 23960;
      _os_log_error_impl(&dword_1B8270000, v12, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
    }
    *__error() = v11;
    *(_DWORD *)(v8 + 312) = v9;
    CIOnThreadCleanUpReset(v23);
    dropThreadId(v26, 1, v3);
    return CICleanUpReset(v26, v24);
  }
  else
  {
    v14 = *(unint64_t **)(a1 + 32);
    do
      v15 = __ldxr(v14);
    while (__stxr(v15 + 1, v14));
    v16 = *(_QWORD *)(a1 + 40);
    if (v15 < *(_QWORD *)(v16 + 16))
    {
      v17 = v15;
      do
      {
        _setAttributes(v16 + 80 * v17 + 24);
        v18 = *(unint64_t **)(a1 + 32);
        do
          v19 = __ldxr(v18);
        while (__stxr(v19 + 1, v18));
        v17 = v19;
        v16 = *(_QWORD *)(a1 + 40);
      }
      while (v19 < *(_QWORD *)(v16 + 16));
    }
    v20 = *(_QWORD *)&threadData[18 * v26 + 2];
    v21 = v20 + 320 * v25;
    *(_DWORD *)(v21 + 312) = v9;
    v22 = *(void (**)(_QWORD))(v21 + 232);
    if (v22)
      v22(*(_QWORD *)(v20 + 320 * v25 + 288));
    return dropThreadId(v26, 0, v3);
  }
}

void preProcessInFlight(void *key, const void *a2, CFDictionaryRef *a3)
{
  const __CFDictionary *v6;
  const void *Value;
  const void *v8;
  CFTypeID v9;
  CFTypeID v10;
  CFIndex Count;
  CFIndex v12;
  CFIndex v13;
  CFIndex v14;
  __CFArray *MutableCopy;
  const __CFAllocator *v16;
  const void *ValueAtIndex;
  __CFArray *v18;
  __CFArray *v19;
  CFRange v20;
  CFRange v21;

  if (CFDictionaryGetValue(*a3, key))
    return;
  v6 = a3[1];
  if (!v6)
    return;
  Value = CFDictionaryGetValue(v6, key);
  if (!Value)
    goto LABEL_21;
  v8 = Value;
  if (CFEqual(Value, a2))
    return;
  v9 = CFGetTypeID(v8);
  if (v9 != CFArrayGetTypeID())
    goto LABEL_21;
  v10 = CFGetTypeID(a2);
  if (v10 == CFArrayGetTypeID())
  {
    Count = CFArrayGetCount((CFArrayRef)v8);
    v12 = CFArrayGetCount((CFArrayRef)a2);
    if (v12 >= 1)
    {
      v13 = v12;
      v14 = 0;
      MutableCopy = 0;
      v16 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a2, v14);
        v20.location = 0;
        v20.length = Count;
        if (CFArrayGetFirstIndexOfValue((CFArrayRef)v8, v20, ValueAtIndex) == -1)
        {
          if (!MutableCopy)
            MutableCopy = CFArrayCreateMutableCopy(v16, 0, (CFArrayRef)v8);
          CFArrayAppendValue(MutableCopy, ValueAtIndex);
        }
        ++v14;
      }
      while (v13 != v14);
      if (MutableCopy)
      {
        CFDictionarySetValue(*a3, key, MutableCopy);
        v18 = MutableCopy;
LABEL_20:
        CFRelease(v18);
        return;
      }
    }
    return;
  }
  if ((const void *)*MEMORY[0x1E0C9B0D0] == a2)
  {
LABEL_21:
    CFDictionarySetValue(*a3, key, a2);
    return;
  }
  v21.length = CFArrayGetCount((CFArrayRef)v8);
  v21.location = 0;
  if (CFArrayGetFirstIndexOfValue((CFArrayRef)v8, v21, a2) == -1)
  {
    v19 = CFArrayCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, (CFArrayRef)v8);
    CFArrayAppendValue(v19, a2);
    CFDictionarySetValue(*a3, key, v19);
    v18 = v19;
    goto LABEL_20;
  }
}

BOOL objectIsMarker(int *a1, uint64_t a2)
{
  unint64_t v3;
  _BYTE *v4;

  v3 = 0;
  v4 = 0;
  return !db_get_field(a1, a2, "_kMDItemBackupMoveMarker", &v3, &v4) && *v4 != 0;
}

void _SIConsistencyCheck(uint64_t a1)
{
  uint64_t v2;

  if (a1 && *(_QWORD *)(a1 + 1184))
  {
    v2 = *(_QWORD *)(a1 + 1056);
    if (v2)
      si_enqueue_work_with_qos(v2, 9, (uint64_t)si_consistencyCheck, a1);
  }
}

void setAttributes(uint64_t *a1, uint64_t a2)
{
  double Current;
  NSObject *v5;

  Current = CFAbsoluteTimeGetCurrent();
  v5 = dispatch_group_create();
  _setAttributes(a1, 0, v5, a2);
  if (!(_DWORD)a2)
    bumpWorkTime(*a1, Current);
  dispatch_group_wait(v5, 0xFFFFFFFFFFFFFFFFLL);
  dispatch_release(v5);
  free(a1);
}

void si_consistencyCheck(uint64_t a1, int a2)
{
  const __CFArray *v3;

  if (!a2)
  {
    v3 = *(const __CFArray **)(a1 + 2368);
    if (v3 && CFArrayGetCount(v3))
      si_enqueue_work_with_qos(*(_QWORD *)(a1 + 1056), 9, (uint64_t)_si_consistencyCheckAfterCompact, a1);
    else
      _si_consistencyCheck(a1);
  }
}

void _si_consistencyCheckAfterCompact(uint64_t a1, int a2)
{
  const __CFArray *v3;
  int v4;
  int v5;
  int v6;
  NSObject *v7;
  os_log_type_t v8;
  BOOL v9;
  _BYTE *v10;
  uint8_t buf[4];
  _BYTE *v12;
  _BYTE v13[1024];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (!a2)
  {
    v3 = *(const __CFArray **)(a1 + 2368);
    if (v3 && CFArrayGetCount(v3))
    {
      bzero(v13, 0x400uLL);
      v4 = fcntl(*(_DWORD *)(a1 + 32), 50, v13);
      v5 = v13[0];
      v6 = *__error();
      v7 = _SILogForLogForCategory(7);
      v8 = dword_1EF19FCA8 < 3;
      if (os_log_type_enabled(v7, (os_log_type_t)(dword_1EF19FCA8 < 3)))
      {
        if (v5)
          v9 = v4 < 0;
        else
          v9 = 1;
        if (v9)
          v10 = 0;
        else
          v10 = v13;
        *(_DWORD *)buf = 136315138;
        v12 = v10;
        _os_log_impl(&dword_1B8270000, v7, v8, "*warn* Skipping consistency check for %s", buf, 0xCu);
      }
      *__error() = v6;
    }
    else
    {
      _si_consistencyCheck(a1);
    }
  }
}

void _si_consistencyCheck(uint64_t a1)
{
  int v2;
  BOOL v3;
  _BYTE *v4;
  unsigned int *v5;
  unsigned int v6;
  unsigned int v7;
  int v8;
  NSObject *v9;
  os_log_type_t v10;
  int v11;
  int v12;
  int v13;
  NSObject *v14;
  os_log_type_t v15;
  CFStringRef v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint8_t buf[4];
  _BYTE *v22;
  __int16 v23;
  int v24;
  __int16 v25;
  int v26;
  __int16 v27;
  int v28;
  __int16 v29;
  int v30;
  _BYTE v31[1024];
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  bzero(v31, 0x400uLL);
  v2 = fcntl(*(_DWORD *)(a1 + 32), 50, v31);
  if (v31[0])
    v3 = v2 < 0;
  else
    v3 = 1;
  if (v3)
    v4 = 0;
  else
    v4 = v31;
  v19 = 0;
  v20 = 0;
  v17 = a1;
  v18 = 0;
  si_scheduler_suspend(*(_QWORD *)(a1 + 864));
  si_scheduler_suspend(*(_QWORD *)(a1 + 872));
  si_scheduler_suspend(*(_QWORD *)(a1 + 864));
  v5 = (unsigned int *)(a1 + 1452);
  do
    v6 = __ldaxr(v5);
  while (__stlxr(v6 + 1, v5));
  si_scheduler_suspend(*(_QWORD *)(a1 + 872));
  do
    v7 = __ldaxr(v5);
  while (__stlxr(v7 - 1, v5));
  v8 = *__error();
  v9 = _SILogForLogForCategory(7);
  v10 = dword_1EF19FCA8 < 3;
  if (os_log_type_enabled(v9, (os_log_type_t)(dword_1EF19FCA8 < 3)))
  {
    *(_DWORD *)buf = 136315138;
    v22 = v4;
    _os_log_impl(&dword_1B8270000, v9, v10, "*warn* Starting internal consistency check for %s", buf, 0xCu);
  }
  *__error() = v8;
  *(_DWORD *)buf = 0;
  if (fd_setDir(*(unsigned int *)(a1 + 32), (int *)buf))
  {
    disableProcMon();
    v11 = db_apply(*(int **)(a1 + 1184), (uint64_t (*)(uint64_t, _QWORD, uint64_t))check_consistency, (uint64_t)&v17);
    enableProcMon();
    v12 = *(_DWORD *)buf;
    MEMORY[0x1BCCB1484](*(unsigned int *)buf);
    if ((v12 & 0x80000000) == 0)
      close(v12);
  }
  else
  {
    v11 = -1;
  }
  v13 = *__error();
  v14 = _SILogForLogForCategory(7);
  v15 = dword_1EF19FCA8 < 3;
  if (os_log_type_enabled(v14, (os_log_type_t)(dword_1EF19FCA8 < 3)))
  {
    *(_DWORD *)buf = 136316162;
    v22 = v4;
    v23 = 1024;
    v24 = v18;
    v25 = 1024;
    v26 = HIDWORD(v19);
    v27 = 1024;
    v28 = v19 + HIDWORD(v18);
    v29 = 1024;
    v30 = v20;
    _os_log_impl(&dword_1B8270000, v14, v15, "*warn* Finished internal consistency check for %s. Checks: %d Missing:%d Inconsistent:%d Missing deletes:%d", buf, 0x24u);
  }
  *__error() = v13;
  si_scheduler_resume(*(_QWORD *)(a1 + 864), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 16371);
  si_scheduler_resume(*(_QWORD *)(a1 + 872), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 16372);
  si_scheduler_resume(*(_QWORD *)(a1 + 872), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 16373);
  si_scheduler_resume(*(_QWORD *)(a1 + 864), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 16374);
  if (!v11)
  {
    SISetProperty(a1, CFSTR("kSIRepairedIndex"), (const void *)*MEMORY[0x1E0C9AE50]);
    v16 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const char *)sysVersionCStr, 0x8000100u);
    SISetProperty(a1, CFSTR("kSIConsistencyCheck"), v16);
    CFRelease(v16);
  }
}

uint64_t check_consistency(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5;
  char v6;
  uint64_t v7;
  unint64_t v8;
  char v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  NSObject *v17;
  os_log_type_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  NSObject *v25;
  os_log_type_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  NSObject *v31;
  uint64_t v32;
  const char *v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  NSObject *v37;
  os_log_type_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  NSObject *v44;
  uint64_t v45;
  int v46;
  uint64_t v47;
  __int16 v48;
  uint64_t v49;
  __int16 v50;
  uint64_t v51;
  __int16 v52;
  uint64_t v53;
  char v54[1024];
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  v5 = *(_QWORD *)a3;
  v6 = db_corespotlight_store(a1);
  ++*(_DWORD *)(a3 + 8);
  if (*(_BYTE *)(v5 + 2432))
    return 0;
  v8 = a2[4];
  if (v8 + 1 < 2)
    return 1;
  v10 = v6;
  bzero(v54, 0x400uLL);
  v11 = si_indexForDocId(v5, v8);
  if (v11)
  {
    v12 = _CIGetOIDForDocId(v11, v8, 0);
    if (v12 == *a2)
      return 1;
    v13 = v12;
    if (v12)
    {
      if ((v10 & 1) == 0)
      {
        v14 = (*(uint64_t (**)(void))(*(_QWORD *)(v5 + 1416) + 40))();
        if (v14)
        {
          v15 = v14;
          v16 = *__error();
          v17 = _SILogForLogForCategory(7);
          v18 = 2 * (dword_1EF19FCA8 < 4);
          if (os_log_type_enabled(v17, v18))
          {
            v19 = *a2;
            v20 = a2[4];
            v46 = 134218754;
            v47 = v19;
            v48 = 2048;
            v49 = v13;
            v50 = 2048;
            v51 = v20;
            v52 = 2080;
            v53 = v15;
            _os_log_impl(&dword_1B8270000, v17, v18, "Index/sdb inconsistency for (sdb)oid %lld; index has oid %lld. doc id: %lld. path: %s",
              (uint8_t *)&v46,
              0x2Au);
          }
          *__error() = v16;
          v21 = *a2;
          v7 = 1;
          (*(void (**)(_QWORD, uint64_t, uint64_t, _QWORD))(*(_QWORD *)(v5 + 2360) + 16))(*(_QWORD *)(*(_QWORD *)(v5 + 2360) + 136), v21, 1, 0);
          ++*(_DWORD *)(a3 + 12);
          return v7;
        }
      }
      ++*(_DWORD *)(a3 + 24);
      if (dword_1EF19FCA8 < 5)
      {
LABEL_23:
        _SIDeleteAttributes(v5, *a2);
        return 1;
      }
      v30 = *__error();
      v31 = _SILogForLogForCategory(7);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
      {
        v42 = *a2;
        v46 = 134217984;
        v47 = v42;
        v33 = "delete attributes consistancy 2 oid: %lld";
        goto LABEL_33;
      }
      goto LABEL_34;
    }
    if ((v10 & 1) != 0 || (v34 = (*(uint64_t (**)(void))(*(_QWORD *)(v5 + 1416) + 40))()) == 0)
    {
      if (dword_1EF19FCA8 >= 5)
      {
        v43 = *__error();
        v44 = _SILogForLogForCategory(7);
        if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
        {
          v45 = *a2;
          v46 = 134217984;
          v47 = v45;
          _os_log_impl(&dword_1B8270000, v44, OS_LOG_TYPE_DEFAULT, "delete attributes consistancy oid: %lld", (uint8_t *)&v46, 0xCu);
        }
        *__error() = v43;
      }
      _SIDeleteAttributes(v5, *a2);
      ++*(_DWORD *)(a3 + 24);
      return 1;
    }
    v35 = v34;
    v36 = *__error();
    v37 = _SILogForLogForCategory(7);
    v38 = 2 * (dword_1EF19FCA8 < 4);
    if (os_log_type_enabled(v37, v38))
    {
      v39 = *a2;
      v40 = a2[4];
      v46 = 134218754;
      v47 = v39;
      v48 = 2048;
      v49 = 0;
      v50 = 2048;
      v51 = v40;
      v52 = 2080;
      v53 = v35;
      _os_log_impl(&dword_1B8270000, v37, v38, "Index/sdb inconsistency for (sdb)oid %lld; index has oid %lld. doc id: %lld. path: %s",
        (uint8_t *)&v46,
        0x2Au);
    }
    *__error() = v36;
    ++*(_DWORD *)(a3 + 20);
    v41 = *a2;
    v7 = 1;
    (*(void (**)(_QWORD, uint64_t, uint64_t, _QWORD))(*(_QWORD *)(v5 + 2360) + 16))(*(_QWORD *)(*(_QWORD *)(v5 + 2360) + 136), v41, 1, 0);
  }
  else
  {
    if ((v10 & 1) != 0 || (v22 = (*(uint64_t (**)(void))(*(_QWORD *)(v5 + 1416) + 40))()) == 0)
    {
      ++*(_DWORD *)(a3 + 24);
      if (dword_1EF19FCA8 < 5)
        goto LABEL_23;
      v30 = *__error();
      v31 = _SILogForLogForCategory(7);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
      {
        v32 = *a2;
        v46 = 134217984;
        v47 = v32;
        v33 = "delete attributes consistancy 3 oid: %lld";
LABEL_33:
        _os_log_impl(&dword_1B8270000, v31, OS_LOG_TYPE_DEFAULT, v33, (uint8_t *)&v46, 0xCu);
      }
LABEL_34:
      *__error() = v30;
      goto LABEL_23;
    }
    v23 = v22;
    v24 = *__error();
    v25 = _SILogForLogForCategory(7);
    v26 = 2 * (dword_1EF19FCA8 < 4);
    if (os_log_type_enabled(v25, v26))
    {
      v27 = *a2;
      v28 = a2[4];
      v46 = 134218498;
      v47 = v27;
      v48 = 2048;
      v49 = v28;
      v50 = 2080;
      v51 = v23;
      _os_log_impl(&dword_1B8270000, v25, v26, "Index/sdb inconsistency; wrong doc id for oid %lld; has %lld. path:%s",
        (uint8_t *)&v46,
        0x20u);
    }
    *__error() = v24;
    v29 = *a2;
    v7 = 1;
    (*(void (**)(_QWORD, uint64_t, uint64_t, _QWORD))(*(_QWORD *)(v5 + 2360) + 16))(*(_QWORD *)(*(_QWORD *)(v5 + 2360) + 136), v29, 1, 0);
    ++*(_DWORD *)(a3 + 16);
  }
  return v7;
}

void _SIDeleteAttributes(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;

  if (a2)
  {
    if (*(_QWORD *)(a1 + 1048))
    {
      v4 = malloc_type_calloc(1uLL, 0x50uLL, 0x10E0040BFFD03D2uLL);
      v4[3] = a2;
      *v4 = a1;
      *((_DWORD *)v4 + 12) = 0;
      si_enqueue_barrier(*(_QWORD *)(a1 + 1048), (uint64_t)si_delete_attributes, (uint64_t)v4);
    }
  }
}

void si_delete_attributes(uint64_t *a1, int a2)
{
  uint64_t v3;
  char *v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t Mutable;
  int v9;
  char v10;
  unsigned int v11;

  if (!a2)
  {
    v3 = *a1;
    v11 = 0;
    if (fd_setDir(*(unsigned int *)(v3 + 32), (int *)&v11))
    {
      v10 = 0;
      if (*(_BYTE *)(v3 + 2072))
        v4 = &v10;
      else
        v4 = 0;
      v5 = a1[3];
      if (*((_DWORD *)a1 + 12))
      {
        v6 = *(_QWORD *)(v3 + 288);
        if (!v6)
        {
          os_unfair_lock_lock((os_unfair_lock_t)(v3 + 280));
          if (!*(_QWORD *)(v3 + 288))
          {
            v7 = *(_QWORD *)(v3 + 296);
            if (v7)
            {
              *(_QWORD *)(v3 + 288) = v7;
              *(_QWORD *)(v3 + 296) = 0;
            }
            else
            {
              Mutable = RLEOIDArrayCreateMutable((const __CFAllocator *)*MEMORY[0x1E0C9AE00]);
              __dmb(0xBu);
              *(_QWORD *)(v3 + 288) = Mutable;
            }
          }
          os_unfair_lock_unlock((os_unfair_lock_t)(v3 + 280));
          v6 = *(_QWORD *)(v3 + 288);
        }
        _si_delete_attributes_inner(v3, v5, 0, 0, 0, v6, v4);
        si_finish_text_store_deletions(v3);
        si_indexDeleteDeferredItemsIfReady(v3);
      }
      else
      {
        _si_delete_attributes_inner(v3, a1[3], 0, 0, 0, 0, v4);
        si_finish_text_store_deletions(v3);
      }
      if (v10)
        notify_post("com.apple.spotlight.SyndicatedContentDeleted");
      v9 = v11;
      MEMORY[0x1BCCB1484](v11);
      if ((v9 & 0x80000000) == 0)
        close(v9);
    }
  }
  free(a1);
}

void dummy_routine(CFTypeRef *a1, int a2)
{
  CFTypeRef v3;
  uint64_t v4;
  NSObject *v5;
  _QWORD v6[8];
  _QWORD v7[2];

  v7[1] = *MEMORY[0x1E0C80C00];
  if (!a2)
  {
    v7[0] = 0;
    v3 = a1[1];
    v4 = *((_QWORD *)*a1 + 131);
    v5 = *(NSObject **)(v4 + 8);
    v6[0] = MEMORY[0x1E0C809B0];
    v6[1] = 0x40000000;
    v6[2] = __si_pop_queue_block_invoke;
    v6[3] = &__block_descriptor_tmp_39_1079;
    v6[4] = v4;
    v6[5] = v3;
    v6[6] = 1;
    v6[7] = v7;
    dispatch_sync(v5, v6);
  }
  CFRelease(a1[1]);
  free(a1);
}

void __si_repair_index_file_tree_block_invoke(uint64_t a1, const void *a2)
{
  si_collect_block(*(_QWORD *)(a1 + 32), a2);
}

uint64_t gather_parented_items(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  if (a2[3])
    SIValueSet<unsigned long long>::SIValueSetInsert((unint64_t *)(a3 + 16), *a2);
  return 1;
}

uint64_t reparent_parented_items(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  _DWORD *v7;
  unint64_t v8;
  void *v9;
  _DWORD *LiveIndex;
  int v12;
  void *v13;
  int64_t v14[513];

  v1 = MEMORY[0x1E0C80A78](a1);
  v14[512] = *MEMORY[0x1E0C80C00];
  if (v2)
  {
    v4 = v3;
    v5 = v2;
    v6 = (unint64_t *)v1;
    v7 = *(_DWORD **)(v3 + 1184);
    do
    {
      v8 = *v6++;
      v13 = 0;
      if (!db_get_obj(v7, v8, &v13, 0))
      {
        v9 = v13;
        if (*((_QWORD *)v13 + 3))
        {
          bzero(v14, 0x1000uLL);
          LiveIndex = si_getLiveIndex(*(_QWORD *)(v4 + 1384));
          v12 = 0;
          computePathFS(v4, (unint64_t *)v13, v14, (unsigned int *)&v12);
          si_updateIndexForPathRepair(v4, (uint64_t)LiveIndex, (uint64_t)v13, (uint64_t)v14, v12);
          v9 = v13;
        }
        free(v9);
      }
      --v5;
    }
    while (v5);
  }
  return 0;
}

uint64_t reset_parented_items(unint64_t *a1, uint64_t a2, unint64_t a3)
{
  int *v6;
  unint64_t cs_orphan_oid;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  void *v11;
  int updated;
  int v13;
  int v14;
  NSObject *v15;
  _DWORD *LiveIndex;
  void *v18;
  _BYTE buf[18];
  __int16 v20;
  int v21;
  __int16 v22;
  unint64_t v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v6 = *(int **)(a3 + 1184);
  cs_orphan_oid = si_get_cs_orphan_oid(a3);
  if (a2)
  {
    v8 = cs_orphan_oid;
    do
    {
      v10 = *a1++;
      v9 = v10;
      v18 = 0;
      if (!db_get_obj(v6, v10, &v18, 0))
      {
        v11 = v18;
        if (*((_QWORD *)v18 + 3) == v8
          || (*((_QWORD *)v18 + 3) = v8, (updated = db_update_obj(v6, (uint64_t)v11, 9)) == 0))
        {
          *(_QWORD *)buf = v8;
          *(_QWORD *)&buf[8] = 2;
          LiveIndex = si_getLiveIndex(*(_QWORD *)(a3 + 1384));
          si_updateIndexForPathRepair(a3, (uint64_t)LiveIndex, (uint64_t)v18, (uint64_t)buf, 2);
        }
        else
        {
          v13 = updated;
          v14 = *__error();
          v15 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315906;
            *(_QWORD *)&buf[4] = "reset_parented_items";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 31281;
            v20 = 1024;
            v21 = v13;
            v22 = 2048;
            v23 = v9;
            _os_log_error_impl(&dword_1B8270000, v15, OS_LOG_TYPE_ERROR, "%s:%d: updateErr err %d (%lld)", buf, 0x22u);
          }
          *__error() = v14;
        }
        free(v18);
      }
      --a2;
    }
    while (a2);
  }
  return 0;
}

void _SIIssueFullMergeWithGroup(_QWORD *a1, NSObject *a2)
{
  char *v4;
  uint64_t v5;
  uint64_t (*v6)(_QWORD, const char *, uint64_t, const char *);

  if (a1 && a1[131])
  {
    v4 = (char *)malloc_type_calloc(1uLL, 0x460uLL, 0x1070040C187FD8AuLL);
    *(_QWORD *)v4 = a1;
    v4[16] = 0;
    *(_WORD *)(v4 + 1041) = 257;
    v4[1043] = 1;
    *((_DWORD *)v4 + 274) = 4;
    *((_QWORD *)v4 + 131) = "void _SIIssueFullMergeWithGroup(SIRef, dispatch_group_t)";
    __strlcpy_chk();
    if (!*((_QWORD *)v4 + 136) && !*((_DWORD *)v4 + 266))
    {
      v5 = a1[295];
      if (v5)
      {
        v6 = *(uint64_t (**)(_QWORD, const char *, uint64_t, const char *))(v5 + 64);
        if (v6)
          *((_DWORD *)v4 + 266) = v6(*(_QWORD *)(v5 + 136), "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 20797, "void _SIIssueFullMergeWithGroup(SIRef, dispatch_group_t)");
      }
    }
    if (a2)
    {
      dispatch_retain(a2);
      dispatch_group_enter(a2);
    }
    *((_QWORD *)v4 + 139) = a2;
    si_enqueue_barrier_with_qos(a1[144], 5, (uint64_t)_SIContinueIssueMerge0, (uint64_t)v4);
  }
}

void _SIContinueIssueMerge0(uint64_t a1, int a2)
{
  uint64_t v3;

  v3 = a1;
  if (!a2)
  {
    si_enqueue_barrier_with_qos(*(_QWORD *)(*(_QWORD *)a1 + 1048), 5, (uint64_t)_SIContinueIssueMerge, a1);
    v3 = 0;
  }
  si_merge_ctx_free(v3, a2 != 0);
}

void _SIContinueIssueMerge(uint64_t a1, int a2)
{
  uint64_t v3;

  v3 = a1;
  if (!a2)
  {
    si_enqueue_work_with_qos(*(_QWORD *)(*(_QWORD *)a1 + 1040), 5, (uint64_t)_SIContinueIssueMerge2, a1);
    v3 = 0;
  }
  si_merge_ctx_free(v3, a2 != 0);
}

void _SIContinueIssueMerge2(uint64_t a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  int v10;
  int v11;
  uint64_t v12;
  BOOL v13;
  int v14;
  int v15;
  NSObject *v16;
  os_log_type_t v17;
  const char *v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  char v22;
  int v23;
  uint64_t *v24;
  unsigned int v25;
  unsigned int v26;
  BOOL v27;
  _BOOL4 v28;
  BOOL v29;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  BOOL v34;
  char *v35;
  uint64_t v36;
  int v37;
  _xpc_activity_s *v38;
  uint64_t v39;
  BOOL v40;
  uint64_t v41;
  BOOL v42;
  unsigned int v45;
  unsigned int v46;
  uint64_t v47;
  char v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  unint64_t v56;
  int v57;
  NSObject *v58;
  os_log_type_t v59;
  int v60;
  NSObject *v61;
  os_log_type_t v62;
  unsigned int v63;
  BOOL v64;
  unsigned int v65;
  int v66;
  NSObject *v67;
  os_log_type_t v68;
  uint64_t v69;
  void (*v70)(uint64_t, BOOL, const __CFString *, _QWORD *);
  uint64_t v71;
  char *v72;
  char *v73;
  const char *v74;
  uint64_t v75;
  uint64_t v76;
  _QWORD v77[6];
  uint8_t v78[16];
  uint8_t v79[4];
  __int128 buf;
  uint64_t v81;
  void *v82;
  uint64_t v83;

  v83 = *MEMORY[0x1E0C80C00];
  if (a2)
    goto LABEL_2;
  v4 = *(_QWORD *)a1;
  v5 = 1384;
  if (!*(_BYTE *)(a1 + 16))
    v5 = 1392;
  v6 = *(_QWORD *)(v4 + v5);
  v7 = *(unsigned int *)(v6 + 8);
  v8 = *(unsigned __int8 *)(v4 + 2440);
  if (*(_BYTE *)(a1 + 1042))
    *(_BYTE *)(v4 + 2440) = 0;
  v9 = *(_QWORD *)(a1 + 1072);
  v10 = gSISystemOnBattery;
  v11 = fullVaccuumNeeded(v4, gSISystemOnBattery != 0);
  if ((v11 & 1) != 0 || !v10 || *(_BYTE *)(v4 + 2456))
  {
    if (!v11)
    {
      v14 = 0;
      goto LABEL_27;
    }
    goto LABEL_12;
  }
  v37 = fullVaccuumNeeded(v4, 0);
  v14 = 0;
  if (v37)
  {
    v38 = *(_xpc_activity_s **)(a1 + 1072);
    if (v38 && *(_QWORD *)(a1 + 1080) && xpc_activity_should_defer(v38))
    {
      v76 = v9;
      **(_BYTE **)(a1 + 1080) = 1;
      *(_BYTE *)(v4 + 2456) = 1;
      LODWORD(buf) = -1;
      v39 = *(unsigned int *)(v4 + 32);
      v40 = (_DWORD)v39 == -1 || (fd_setDir(v39, (int *)&buf) & 1) == 0;
      v60 = *__error();
      v61 = _SILogForLogForCategory(12);
      v62 = 2 * (dword_1EF19FCBC < 4);
      if (os_log_type_enabled(v61, v62))
      {
        *(_WORD *)v79 = 0;
        _os_log_impl(&dword_1B8270000, v61, v62, "defer vacuum", v79, 2u);
      }
      *__error() = v60;
      if (!v40)
        fd_resetDir(buf);
    }
    else
    {
      if (v9)
      {
LABEL_12:
        v76 = v9;
        *(_DWORD *)v79 = -1;
        v12 = *(unsigned int *)(v4 + 32);
        v13 = (_DWORD)v12 == -1 || (fd_setDir(v12, (int *)v79) & 1) == 0;
        v15 = *__error();
        v16 = _SILogForLogForCategory(12);
        v17 = 2 * (dword_1EF19FCBC < 4);
        if (os_log_type_enabled(v16, v17))
        {
          if (gSISystemOnBattery)
            v18 = " (on battery)";
          else
            v18 = "";
          LODWORD(buf) = 136315138;
          *(_QWORD *)((char *)&buf + 4) = v18;
          _os_log_impl(&dword_1B8270000, v16, v17, "Vacuum needed%s", (uint8_t *)&buf, 0xCu);
        }
        *__error() = v15;
        if (!v13)
        {
          v19 = *(_DWORD *)v79;
          MEMORY[0x1BCCB1484](*(unsigned int *)v79);
          if ((v19 & 0x80000000) == 0)
            close(v19);
        }
        v14 = 1;
        goto LABEL_26;
      }
      v76 = 0;
      *(_BYTE *)(v4 + 2456) = 1;
      LODWORD(buf) = -1;
      v41 = *(unsigned int *)(v4 + 32);
      v42 = (_DWORD)v41 == -1 || (fd_setDir(v41, (int *)&buf) & 1) == 0;
      v57 = *__error();
      v58 = _SILogForLogForCategory(12);
      v59 = 2 * (dword_1EF19FCBC < 4);
      if (os_log_type_enabled(v58, v59))
      {
        *(_WORD *)v79 = 0;
        _os_log_impl(&dword_1B8270000, v58, v59, "Vacuum scheduled", v79, 2u);
      }
      *__error() = v57;
      if (!v42)
        fd_resetDir(buf);
      (*(void (**)(_QWORD, uint64_t, const __CFString *, void *))(*(_QWORD *)(v4 + 2360) + 80))(*(_QWORD *)(*(_QWORD *)(v4 + 2360) + 136), 1, CFSTR("Merge"), &__block_literal_global_1432);
    }
    v14 = 0;
LABEL_26:
    v9 = v76;
  }
LABEL_27:
  if (!*(_BYTE *)(a1 + 1042) || ((*(_BYTE *)(a1 + 1043) == 0) & ~v14) == 0)
  {
    while (1)
    {
      v20 = v7;
      if (!v7)
        break;
      v21 = *(_QWORD *)(*(_QWORD *)v6 + 8 * v7 - 8);
      v22 = atomic_load((unsigned int *)(v21 + 28));
      if ((v22 & 3) == 0)
      {
        --v7;
        if (!*(_BYTE *)(v21 + 15163))
          continue;
      }
      v23 = v20;
      goto LABEL_54;
    }
    v23 = 0;
LABEL_54:
    si_sync_ctx_create_with_defer_fd(v4, 0);
    v36 = (uint64_t)v35;
    v35[96] = 1;
    if (!*(_BYTE *)(*(_QWORD *)v35 + 2072) && !*(_BYTE *)(*(_QWORD *)v35 + 2437))
      attachJournal(v35);
    syncIndex(v36, 0);
    if (v20)
    {
      *(_DWORD *)(a1 + 12) = v23;
      *(_DWORD *)(a1 + 8) = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v6 + 8 * (*(_DWORD *)(v6 + 8) - v23))
                                      + 48);
      si_enqueue_work(*(_QWORD *)(v4 + 1056), (uint64_t)si_mergeIndex, a1);
      return;
    }
    goto LABEL_2;
  }
  if (v8)
    goto LABEL_2;
  v24 = *(uint64_t **)(v4 + 1384);
  if (!v24)
    goto LABEL_2;
  v25 = count_IndexSet(*(_QWORD *)(v4 + 1384), *((_DWORD *)v24 + 2) - 1, 0);
  if (!v25)
    goto LABEL_2;
  v26 = v25;
  if (!*(_BYTE *)(v4 + 2457))
  {
    v27 = v25 == 4 && v9 == 0;
    v28 = v27;
    v29 = gSISystemOnBattery && v25 == 6;
    if (v29 || v28)
    {
      *(_QWORD *)&buf = 0;
      *((_QWORD *)&buf + 1) = &buf;
      v81 = 0x2000000000;
      v82 = 0;
      v82 = malloc_type_malloc(0x460uLL, 0x1070040C187FD8AuLL);
      v31 = *((_QWORD *)&buf + 1);
      memcpy(*(void **)(*((_QWORD *)&buf + 1) + 24), (const void *)a1, 0x460uLL);
      v32 = *(_QWORD *)(v31 + 24);
      *(_DWORD *)(v32 + 1064) = 0;
      *(_QWORD *)(v32 + 1080) = 0;
      *(_QWORD *)(v32 + 1088) = 0;
      *(_QWORD *)(v32 + 1072) = 0;
      *(_QWORD *)(*(_QWORD *)(v31 + 24) + 1056) = 0;
      *(_QWORD *)(*(_QWORD *)(v31 + 24) + 1112) = 0;
      *(_BYTE *)(*(_QWORD *)(v31 + 24) + 1100) = v26 != 4;
      *(_DWORD *)v79 = -1;
      v33 = *(unsigned int *)(v4 + 32);
      v34 = (_DWORD)v33 == -1 || (fd_setDir(v33, (int *)v79) & 1) == 0;
      v66 = *__error();
      v67 = _SILogForLogForCategory(12);
      v68 = 2 * (dword_1EF19FCBC < 4);
      if (os_log_type_enabled(v67, v68))
      {
        *(_WORD *)v78 = 0;
        _os_log_impl(&dword_1B8270000, v67, v68, "Merge(2) scheduled", v78, 2u);
      }
      *__error() = v66;
      if (!v34)
        fd_resetDir(*(int *)v79);
      *(_BYTE *)(v4 + 2457) = 1;
      v69 = *(_QWORD *)(v4 + 2360);
      v70 = *(void (**)(uint64_t, BOOL, const __CFString *, _QWORD *))(v69 + 80);
      v71 = *(_QWORD *)(v69 + 136);
      v77[0] = MEMORY[0x1E0C809B0];
      v77[1] = 0x40000000;
      v77[2] = ___SIContinueIssueMerge2_block_invoke_1436;
      v77[3] = &unk_1E6E2E2C0;
      v77[4] = &buf;
      v77[5] = v4;
      v70(v71, v26 != 4, CFSTR("Merge(2)"), v77);
      _Block_object_dispose(&buf, 8);
      goto LABEL_2;
    }
  }
  if ((v25 < 4 || v9 == 0) && (v25 < 6 || gSISystemOnBattery != 0))
    goto LABEL_2;
  *(_BYTE *)(v4 + 2457) = 0;
  v45 = *((_DWORD *)v24 + 2);
  do
  {
    v46 = v45;
    if (v45 <= *((_DWORD *)v24 + 2) - v25)
      break;
    v47 = *(_QWORD *)(*v24 + 8 * --v45);
    v48 = atomic_load((unsigned int *)(v47 + 28));
    if ((v48 & 3) != 0)
      break;
  }
  while (!*(_BYTE *)(v47 + 15163));
  if (v46 < 5)
  {
LABEL_2:
    si_merge_ctx_free(a1, a2 != 0);
    return;
  }
  v49 = *((_DWORD *)v24 + 2) - v25;
  if (v49 >= v46)
  {
    v51 = 0;
    v56 = 0;
  }
  else
  {
    v50 = 0;
    v51 = 0;
    v52 = *v24;
    do
    {
      v53 = *(_QWORD *)(v52 + 8 * v49);
      v54 = atomic_load((unsigned int *)(v53 + 12));
      v50 += v54;
      LODWORD(v54) = *(_DWORD *)(v53 + 60);
      v55 = *(_QWORD *)(v53 + 72);
      if (v54 >= 2)
        v54 = v54;
      else
        v54 = 0;
      v52 = *v24;
      v51 = v55 + v51 + v54 - *(_QWORD *)(*(_QWORD *)(*v24 + 8 * v49++) + 72);
    }
    while (v46 != v49);
    v56 = 4 * v50;
  }
  *(_BYTE *)(a1 + 1042) = 0;
  *(_DWORD *)(a1 + 12) = v46;
  *(_BYTE *)(a1 + 16) = 1;
  __strlcpy_chk();
  *(_BYTE *)(a1 + 1041) = v56 > v51;
  v63 = *((_DWORD *)v24 + 2);
  v64 = v63 >= v26;
  v65 = v63 - v26;
  if (!v64)
  {
    v72 = __si_assert_copy_extra_521(-1);
    v73 = v72;
    v74 = "";
    if (v72)
      v74 = v72;
    __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 20737, "indexCount <= indexSet->indexCount", v74);
    free(v73);
    if (__valid_fs(-1))
      v75 = 2989;
    else
      v75 = 3072;
    *(_DWORD *)v75 = -559038737;
    abort();
  }
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(*(_QWORD *)(*v24 + 8 * v65) + 48);
  si_enqueue_work_with_qos(*(_QWORD *)(v4 + 1056), 5, (uint64_t)si_mergeIndex, a1);
}

uint64_t fullVaccuumNeeded(uint64_t a1, int a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  BOOL v7;
  int v8;
  NSObject *v9;
  os_log_type_t v10;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint8_t buf[4];
  unint64_t v17;
  __int16 v18;
  uint64_t v19;
  __int16 v20;
  uint64_t v21;
  __int16 v22;
  uint64_t v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v14 = 0;
  v15 = 0;
  v12 = 0;
  v13 = 0;
  itemCounts(*(uint64_t **)(a1 + 1392), &v15, &v13);
  itemCounts(*(uint64_t **)(a1 + 1384), &v14, &v12);
  v4 = v13;
  v5 = v15;
  if (a2)
  {
    if (3 * v15 >= 4 * v13)
      return 0;
    v6 = v14;
    if (v15 <= 5 * v14)
      return 0;
  }
  else
  {
    v6 = v14;
    v7 = v15 < 2 * v13 && v15 > 4 * v14;
    if (!v7 && v14 + v15 >= 2 * (v12 + v13))
      return 0;
  }
  v8 = *__error();
  v9 = _SILogForLogForCategory(0);
  v10 = 2 * (gSILogLevels[0] < 4);
  if (os_log_type_enabled(v9, v10))
  {
    *(_DWORD *)buf = 134218752;
    v17 = v5;
    v18 = 2048;
    v19 = v6;
    v20 = 2048;
    v21 = v4;
    v22 = 2048;
    v23 = v12;
    _os_log_impl(&dword_1B8270000, v9, v10, "full vacuum needed - count: %lld, live count: %lld, delete count: %lld, live delete count: %lld", buf, 0x2Au);
  }
  *__error() = v8;
  return 1;
}

uint64_t si_sync_index_vaccuum_if_needed(uint64_t result, char a2, void *a3, uint64_t a4, NSObject *a5)
{
  uint64_t v5;
  uint64_t v10;
  uint64_t v11;

  if (result)
  {
    v5 = result;
    if (*(_QWORD *)(result + 1184) && *(_QWORD *)(result + 1040) && *(_QWORD *)(result + 1048))
    {
      si_sync_ctx_create_with_defer_fd(result, 0);
      v11 = v10;
      *(_BYTE *)(v10 + 136) = a2;
      si_power_info_init(v10 + 104, a3, a4, a5);
      si_enqueue_barrier_with_qos(*(_QWORD *)(v5 + 1152), 9, (uint64_t)si_sync_index_delayed_if_dirty0, v11);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void si_sync_index_delayed_if_dirty0(uint64_t a1, int a2)
{
  uint64_t v3;

  v3 = a1;
  if (!a2)
  {
    si_enqueue_barrier_with_qos(*(_QWORD *)(*(_QWORD *)a1 + 1048), 9, (uint64_t)si_sync_index_delayed_if_dirty, a1);
    v3 = 0;
  }
  si_sync_ctx_free(v3, a2 != 0);
}

void si_sync_index_delayed_if_dirty(uint64_t a1, int a2)
{
  char *v4;
  uint64_t v5;
  __int128 v6;
  uint64_t v7;
  uint64_t (*v8)(_QWORD, const char *, uint64_t, const char *);
  int v9;
  uint64_t v10;
  int *v11;

  if (!a2)
  {
    v4 = (char *)malloc_type_calloc(1uLL, 0x460uLL, 0x1070040C187FD8AuLL);
    v5 = *(_QWORD *)a1;
    *((_QWORD *)v4 + 131) = "void si_sync_index_delayed_if_dirty(si_sync_ctx *, Boolean)";
    *(_QWORD *)v4 = v5;
    v4[16] = 0;
    *(_WORD *)(v4 + 1041) = 257;
    v4[1043] = 0;
    *((_DWORD *)v4 + 274) = 1;
    v4[1100] = *(_BYTE *)(a1 + 136);
    v6 = *(_OWORD *)(a1 + 120);
    *(_OWORD *)(v4 + 1064) = *(_OWORD *)(a1 + 104);
    *(_OWORD *)(v4 + 1080) = v6;
    *(_DWORD *)(a1 + 104) = 0;
    *(_QWORD *)(a1 + 120) = 0;
    *(_QWORD *)(a1 + 128) = 0;
    *(_QWORD *)(a1 + 112) = 0;
    v7 = *(_QWORD *)(v5 + 2360);
    if (v7)
    {
      v8 = *(uint64_t (**)(_QWORD, const char *, uint64_t, const char *))(v7 + 64);
      if (v8)
        *(_DWORD *)(a1 + 104) = v8(*(_QWORD *)(v7 + 136), "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 2484, "void si_sync_index_delayed_if_dirty(si_sync_ctx *, Boolean)");
    }
    __strlcpy_chk();
    si_enqueue_barrier_with_qos(*(_QWORD *)(*(_QWORD *)a1 + 1152), 9, (uint64_t)_SIContinueIssueMerge0, (uint64_t)v4);
    v9 = _CIListsClean(*(_QWORD *)(*(_QWORD *)a1 + 1392), *(_QWORD *)(*(_QWORD *)a1 + 1384));
    v10 = *(_QWORD *)a1;
    if (!v9)
      goto LABEL_9;
    v11 = *(int **)(v10 + 1184);
    if (!v11)
      goto LABEL_9;
    if (db_is_dirty(v11))
    {
      v10 = *(_QWORD *)a1;
LABEL_9:
      si_enqueue_work_with_qos(*(_QWORD *)(v10 + 1096), 9, (uint64_t)si_sync_index_delayed0, a1);
      a1 = 0;
    }
  }
  si_sync_ctx_free(a1, a2 != 0);
}

uint64_t *itemCounts(uint64_t *result, _QWORD *a2, _QWORD *a3)
{
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (*((_DWORD *)result + 2))
  {
    v3 = 0;
    v4 = 0;
    v5 = 0;
    v6 = *result;
    do
    {
      v7 = *(_QWORD *)(v6 + 8 * v3);
      v8 = atomic_load((unsigned int *)(v7 + 12));
      v4 += v8;
      LODWORD(v8) = *(_DWORD *)(v7 + 60);
      v9 = *(_QWORD *)(v7 + 72);
      if (v8 >= 2)
        v8 = v8;
      else
        v8 = 0;
      v6 = *result;
      v5 = v9 + v5 + v8 - *(_QWORD *)(*(_QWORD *)(*result + 8 * v3++) + 72);
    }
    while (v3 < *((unsigned int *)result + 2));
  }
  else
  {
    v5 = 0;
    v4 = 0;
  }
  *a2 += v5;
  *a3 += v4;
  return result;
}

uint64_t retain_scheduler(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  unsigned int *v3;
  unsigned int v4;

  result = a2;
  if (a2)
  {
    v3 = (unsigned int *)(a2 + 80);
    do
      v4 = __ldaxr(v3);
    while (__stlxr(v4 + 1, v3));
  }
  return result;
}

void release_scheduler(uint64_t a1, uint64_t a2)
{
  NSObject *v3;
  NSObject *v4;
  unsigned int *v5;
  unsigned int v6;
  unsigned int v7;
  _QWORD v8[6];

  v3 = dispatch_group_create();
  si_scheduler_stop(a2, (uint64_t)v3);
  dispatch_group_wait(v3, 0xFFFFFFFFFFFFFFFFLL);
  dispatch_release(v3);
  v4 = *(NSObject **)(a2 + 32);
  v8[0] = MEMORY[0x1E0C809B0];
  v8[1] = 0x40000000;
  v8[2] = __si_scheduler_drain_block_invoke;
  v8[3] = &__block_descriptor_tmp_8_987;
  v8[4] = a2;
  v8[5] = 0;
  dispatch_sync(v4, v8);
  v5 = (unsigned int *)(a2 + 80);
  do
  {
    v6 = __ldaxr(v5);
    v7 = v6 - 1;
  }
  while (__stlxr(v7, v5));
  if (!v7)
    _si_scheduler_destroy(a2);
}

uint64_t query_node_unique_set_value_callback_retain(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  unsigned int *v3;
  unsigned int v4;

  result = a2;
  v3 = (unsigned int *)(a2 + 72);
  do
    v4 = __ldxr(v3);
  while (__stxr(v4 + 1, v3));
  return result;
}

void query_node_unique_set_value_callback_release(uint64_t a1, uint64_t a2)
{
  query_node_unique_set_release(a2);
}

void updateUsedBites(int a1, CFNumberRef number, __CFBitVector *a3)
{
  unint64_t valuePtr;

  valuePtr = 0;
  CFNumberGetValue(number, kCFNumberLongType, &valuePtr);
  if (valuePtr <= 0xFE)
    CFBitVectorSetBitAtIndex(a3, valuePtr, 1u);
}

uint64_t dbGCUnmap(int a1, void *a2, size_t a3)
{
  return munmap(a2, a3);
}

void dbGCFree(int a1, void *a2)
{
  free(a2);
}

void ___si_init_localized_terms_block_invoke(uint64_t a1, const void *a2)
{
  si_collect_block(*(_QWORD *)(a1 + 32), a2);
}

uint64_t store_stream_read_vint32_566(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  uint64_t v9;
  int v10;
  char v11;
  uint64_t v12;
  int v13;
  int v14;
  int v16;
  int v17;
  char __dst;

  v2 = *(_QWORD *)(a1 + 40);
  if ((unint64_t)(*(_QWORD *)(a1 + 32) - v2) < 6)
  {
    v17 = 0;
    LODWORD(v5) = 0;
    __dst = 0;
    while (store_stream_read_bytes_567((unsigned int *)a1, &__dst, 1uLL) == 1)
    {
      v5 = ((__dst & 0x7F) << v17) | v5;
      v17 += 7;
      if ((__dst & 0x80) == 0)
        return v5;
    }
    return 0;
  }
  else
  {
    v3 = *(_QWORD *)(a1 + 48);
    v4 = v2 + 1;
    v5 = *(unsigned __int8 *)(v3 + v2);
    if ((*(char *)(v3 + v2) & 0x80000000) == 0)
    {
      v6 = v2 + 1;
LABEL_11:
      *(_QWORD *)(a1 + 40) = v6;
      return v5;
    }
    v6 = v2 + 2;
    v7 = *(char *)(v3 + v4);
    v8 = *(unsigned __int8 *)(v3 + v4);
    if ((v7 & 0x80000000) == 0)
    {
      v5 = v5 & 0x7F | (v8 << 7);
      goto LABEL_11;
    }
    v9 = v2 + 3;
    v10 = *(char *)(v3 + v6);
    v11 = v10;
    if ((v10 & 0x80000000) == 0)
    {
      v12 = ((v8 & 0x7F) << 7) | (v10 << 14) | (v5 & 0x7F);
      v6 = v9;
LABEL_10:
      v5 = v12;
      goto LABEL_11;
    }
    v6 = v2 + 4;
    v13 = *(char *)(v3 + v9);
    v14 = *(unsigned __int8 *)(v3 + v9);
    if ((v13 & 0x80000000) == 0)
    {
      v12 = ((v11 & 0x7F) << 14) | (v14 << 21) | ((v8 & 0x7F) << 7) | (v5 & 0x7F);
      goto LABEL_10;
    }
    v16 = *(char *)(v3 + v6);
    *(_QWORD *)(a1 + 40) = v2 + 5;
    if (v16 < 0)
    {
      return ((v14 & 0x7F) << 21) | (v16 << 28) | ((v11 & 0x7F) << 14) | ((v8 & 0x7F) << 7) | (v5 & 0x7F);
    }
    else
    {
      v5 = 0;
      *(_DWORD *)(a1 + 16) = 22;
    }
  }
  return v5;
}

uint64_t store_stream_read_bytes_567(unsigned int *a1, char *__dst, size_t __n)
{
  size_t v6;
  uint64_t v7;
  uint64_t v8;
  size_t v9;
  uint64_t v11;
  unint64_t v12;

  v6 = *((_QWORD *)a1 + 4);
  v7 = *((_QWORD *)a1 + 5);
  if (v7 + __n > v6)
  {
    v8 = 0;
    v11 = *((_QWORD *)a1 + 5);
    while (1)
    {
      v9 = v6 - v11;
      if (v6 != v11)
      {
        memcpy(__dst, (const void *)(*((_QWORD *)a1 + 6) + v11), v6 - v11);
        v6 = *((_QWORD *)a1 + 4);
        *((_QWORD *)a1 + 5) += v9;
      }
      v12 = prot_pread(*a1, *((void **)a1 + 6), v6, *((_QWORD *)a1 + 3));
      if (v12 == -1)
        break;
      v6 = v12;
      *((_QWORD *)a1 + 4) = v12;
      *((_QWORD *)a1 + 5) = 0;
      *((_QWORD *)a1 + 3) += v12;
      if (!v12)
        return v9 + v8;
      v7 = 0;
      v11 = 0;
      __dst += v9;
      __n -= v9;
      v8 += v9;
      if (__n <= v12)
        goto LABEL_3;
    }
    v9 = 0;
    a1[4] = *__error();
  }
  else
  {
    v8 = 0;
LABEL_3:
    memcpy(__dst, (const void *)(*((_QWORD *)a1 + 6) + v7), __n);
    *((_QWORD *)a1 + 5) += __n;
    v9 = __n;
  }
  return v9 + v8;
}

void ___si_init_localized_terms_block_invoke_885(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  uint8_t *RawLocalizedUniquedField;
  uint8_t *v6;
  const __CFAllocator *v7;
  CFDictionaryRef v8;
  CFDictionaryRef v9;
  int v10;
  NSObject *v11;
  os_log_type_t v12;
  CFTypeID v13;
  __CFDictionary *Mutable;
  char *field_name_for_id;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int id_for_field;
  int v24;
  NSObject *v25;
  uint64_t v26;
  CFDataRef v27;
  int v28;
  NSObject *v29;
  os_log_type_t v30;
  int v31;
  uint8_t buf[4];
  _BYTE v33[14];
  __int16 v34;
  int v35;
  uint8_t v36[4];
  unsigned int v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v4 = *(_QWORD *)(a1 + 32);
    bzero(v36, 0x400uLL);
    RawLocalizedUniquedField = (uint8_t *)getRawLocalizedUniquedField(*(_QWORD *)(v4 + 1184), a2, v36, 0);
    if (RawLocalizedUniquedField)
    {
      v6 = RawLocalizedUniquedField;
      v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v8 = _decodeSDBField(*(_QWORD *)(v4 + 1184), (unsigned __int16 *)v6, v6 + 13, 0, 0, 0, 0, (CFAllocatorRef)*MEMORY[0x1E0C9AE00]);
      if (v8)
      {
        v9 = v8;
        v10 = *__error();
        v11 = _SILogForLogForCategory(0);
        v12 = 2 * (gSILogLevels[0] < 4);
        if (os_log_type_enabled(v11, v12))
        {
          *(_DWORD *)buf = 67109378;
          *(_DWORD *)v33 = a2;
          *(_WORD *)&v33[4] = 2112;
          *(_QWORD *)&v33[6] = v9;
          _os_log_impl(&dword_1B8270000, v11, v12, "new loc field(%d): %@", buf, 0x12u);
        }
        *__error() = v10;
        v13 = CFGetTypeID(v9);
        if (v13 == CFDictionaryGetTypeID() && CFDictionaryGetCount(v9))
        {
          Mutable = CFDictionaryCreateMutable(v7, 0, 0, MEMORY[0x1E0C9B3A0]);
          field_name_for_id = (char *)db_get_field_name_for_id(*(int **)(v4 + 1184), *((_DWORD *)v6 + 1));
          if (field_name_for_id)
          {
            id_for_field = db_get_id_for_field(*(int **)(v4 + 1184), field_name_for_id);
            CFDictionaryAddValue(Mutable, (const void *)(id_for_field | ((unint64_t)(*((_WORD *)v6 + 1) & 0x100) << 23)), v9);
            TermUpdateSetAddDocumentInfo(*(_QWORD *)(v4 + 6648), (*(_DWORD *)(v4 + 6584) >> 19) & 3, a2, 0, Mutable, 0, 0, 5, 0);
            CFRelease(Mutable);
          }
          else
          {
            si_analytics_log_6700(0, v16, v17, v18, v19, v20, v21, v22, *((_DWORD *)v6 + 1));
            v24 = *__error();
            v25 = _SILogForLogForCategory(7);
            if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
            {
              v31 = *((_DWORD *)v6 + 1);
              *(_DWORD *)buf = 136315650;
              *(_QWORD *)v33 = "si_handle_new_unique_localized_field";
              *(_WORD *)&v33[8] = 1024;
              *(_DWORD *)&v33[10] = 536;
              v34 = 1024;
              v35 = v31;
              _os_log_error_impl(&dword_1B8270000, v25, OS_LOG_TYPE_ERROR, "%s:%d: No field name for field id %d", buf, 0x18u);
            }
            *__error() = v24;
          }
        }
        CFRelease(v9);
      }
      if (v6 != v36)
        free(v6);
    }
  }
  v26 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v26 + 6872))
  {
    uuid_generate_random((unsigned __int8 *)(v26 + 6856));
    v27 = CFDataCreate(0, (const UInt8 *)(*(_QWORD *)(a1 + 32) + 6856), 16);
    SISetProperty(*(_QWORD *)(a1 + 32), CFSTR("database.localizedtermsuuid"), v27);
    CFRelease(v27);
    v28 = *__error();
    v29 = _SILogForLogForCategory(0);
    v30 = 2 * (gSILogLevels[0] < 4);
    if (os_log_type_enabled(v29, v30))
    {
      *(_DWORD *)v36 = 67109120;
      v37 = a2;
      _os_log_impl(&dword_1B8270000, v29, v30, "new loc term %d", v36, 8u);
    }
    *__error() = v28;
    *(_BYTE *)(*(_QWORD *)(a1 + 32) + 6872) = 1;
  }
}

dispatch_semaphore_t freeQueueSetup()
{
  NSObject *v0;
  dispatch_semaphore_t result;

  v0 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_BACKGROUND, 0);
  freeQueue = (uint64_t)dispatch_queue_create("com.apple.spotlight.index.free", v0);
  result = dispatch_semaphore_create(16);
  freeSemaphore = (uint64_t)result;
  return result;
}

void __registerForGameModeChange_block_invoke()
{
  NSObject *v0;

  v0 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  sGameModeNotificationQueue = (uint64_t)dispatch_queue_create("com.apple.spotlight.CoreSpotlight.gm", v0);
  notify_register_check("com.apple.system.console_mode_changed", &registerForGameModeChange__gameModeNotifyToken);
  notify_register_dispatch("com.apple.system.console_mode_changed", &registerForGameModeChange__gameModeNotifyToken, (dispatch_queue_t)sGameModeNotificationQueue, &__block_literal_global_878);
  dispatch_async((dispatch_queue_t)sGameModeNotificationQueue, &__block_literal_global_880);
}

uint64_t __registerForGameModeChange_block_invoke_3()
{
  return checkGameModeAndSuspendResume(registerForGameModeChange__gameModeNotifyToken);
}

uint64_t checkGameModeAndSuspendResume(int a1)
{
  uint64_t state64;

  state64 = 0;
  notify_get_state(a1, &state64);
  pthread_mutex_lock(&sGameModeMutex);
  sInGameMode = state64 != 0;
  if (!state64)
    pthread_cond_broadcast(&sGameModeCond);
  return pthread_mutex_unlock(&sGameModeMutex);
}

uint64_t __registerForGameModeChange_block_invoke_2(uint64_t a1, int a2)
{
  return checkGameModeAndSuspendResume(a2);
}

uint64_t __si_set_vector_store_block_invoke(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  BOOL v9;
  uint64_t v10;
  uint64_t v11;

  v3 = *(_QWORD *)(a1 + 32);
  a2[1793] = v3;
  v4 = (_QWORD *)a2[612];
  if (v4)
  {
    v4[18] = v3;
    v5 = (_QWORD *)v4[11];
    v6 = v4 + 12;
    if (v5 != v4 + 12)
    {
      do
      {
        (*(void (**)(_QWORD, uint64_t))(*(_QWORD *)v5[5] + 288))(v5[5], v3);
        v7 = (_QWORD *)v5[1];
        if (v7)
        {
          do
          {
            v8 = v7;
            v7 = (_QWORD *)*v7;
          }
          while (v7);
        }
        else
        {
          do
          {
            v8 = (_QWORD *)v5[2];
            v9 = *v8 == (_QWORD)v5;
            v5 = v8;
          }
          while (!v9);
        }
        v5 = v8;
      }
      while (v8 != v6);
    }
  }
  v10 = a2[1794];
  if (v10)
    TermUpdateSetSetVectorStore(*(_QWORD **)(v10 + 80), v3);
  v11 = a2[1795];
  if (v11)
    TermUpdateSetSetVectorStore(*(_QWORD **)(v11 + 80), v3);
  return 1;
}

uint64_t _onceInitTuning()
{
  size_t v1;
  uint64_t v2;
  int v3[2];
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  v2 = 1;
  *(_QWORD *)v3 = 0x1900000006;
  v1 = 4;
  sysctl(v3, 2u, &v2, &v1, 0, 0);
  gCPUCount = v2;
  return pthread_mutex_unlock(&_onceInitTuning_prefLock);
}

uint64_t check_touch_file(uint64_t result, const char *a2, uint64_t a3)
{
  int v4;

  if ((result & 0x80000000) == 0 && a2)
  {
    result = openat(result, a2, 0x8000);
    if ((_DWORD)result != -1)
    {
      v4 = result;
      (*(void (**)(uint64_t))(a3 + 16))(a3);
      return close(v4);
    }
  }
  return result;
}

void si_read_index_state(uint64_t a1)
{
  uint64_t v1;
  int v2;
  int v3;
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  ssize_t v9;
  ssize_t v10;
  int v11;
  int v12;
  NSObject *v13;
  int v14;
  NSObject *v15;
  int v16;
  int v17;
  NSObject *v18;
  int v19;
  NSObject *v20;
  os_log_type_t v21;
  const char *v22;
  NSObject *v23;
  int v24;
  NSObject *v25;
  os_log_type_t v26;
  int v27;
  NSObject *v28;
  int *v29;
  char *v30;
  unsigned __int16 v31;
  uint8_t buf[4];
  const char *v33;
  __int16 v34;
  _BYTE v35[14];
  __int16 v36;
  int v37;
  __int16 v38;
  ssize_t v39;
  __int16 v40;
  int v41;
  _DWORD __src[1026];
  uint64_t v43;

  v1 = MEMORY[0x1E0C80A78](a1);
  v43 = *MEMORY[0x1E0C80C00];
  v7 = x_openat(*(_DWORD *)(v1 + 32), "tmp.spotlight.state", 0, v2, v3, v4, v5, v6, v31);
  if ((_DWORD)v7 == -1)
  {
    v11 = *__error();
    if (v11 == 2)
    {
      v24 = *__error();
      v25 = _SILogForLogForCategory(11);
      v26 = 2 * (dword_1EF19FCB8 < 4);
      if (os_log_type_enabled(v25, v26))
      {
        __src[0] = 134218240;
        *(_QWORD *)&__src[1] = v1;
        LOWORD(__src[3]) = 1024;
        *(_DWORD *)((char *)&__src[3] + 2) = 2;
        _os_log_impl(&dword_1B8270000, v25, v26, "%p open index state error:%d", (uint8_t *)__src, 0x12u);
      }
      *__error() = v24;
    }
    else if (v11 == 92)
    {
      v12 = *__error();
      v13 = _SILogForLogForCategory(11);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        __src[0] = 136316162;
        *(_QWORD *)&__src[1] = "si_read_index_state";
        LOWORD(__src[3]) = 1024;
        *(_DWORD *)((char *)&__src[3] + 2) = 29819;
        HIWORD(__src[4]) = 2048;
        *(_QWORD *)&__src[5] = v1;
        LOWORD(__src[7]) = 1024;
        *(_DWORD *)((char *)&__src[7] + 2) = 92;
        HIWORD(__src[8]) = 2080;
        *(_QWORD *)&__src[9] = strerror(92);
        _os_log_error_impl(&dword_1B8270000, v13, OS_LOG_TYPE_ERROR, "%s:%d: %p open index state error:%d (%s); removing the file.",
          (uint8_t *)__src,
          0x2Cu);
      }
      *__error() = v12;
      if (unlinkat(*(_DWORD *)(v1 + 32), "tmp.spotlight.state", 0))
      {
        v14 = *__error();
        v15 = _SILogForLogForCategory(11);
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        {
          v29 = __error();
          v30 = strerror(*v29);
          __src[0] = 136315650;
          *(_QWORD *)&__src[1] = "si_read_index_state";
          LOWORD(__src[3]) = 1024;
          *(_DWORD *)((char *)&__src[3] + 2) = 29821;
          HIWORD(__src[4]) = 2080;
          *(_QWORD *)&__src[5] = v30;
          _os_log_error_impl(&dword_1B8270000, v15, OS_LOG_TYPE_ERROR, "%s:%d: Error removing tmp.spotlight.state: %s\n", (uint8_t *)__src, 0x1Cu);
        }
        *__error() = v14;
      }
    }
    else
    {
      v27 = *__error();
      v28 = _SILogForLogForCategory(11);
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      {
        __src[0] = 136315906;
        *(_QWORD *)&__src[1] = "si_read_index_state";
        LOWORD(__src[3]) = 1024;
        *(_DWORD *)((char *)&__src[3] + 2) = 29826;
        HIWORD(__src[4]) = 2048;
        *(_QWORD *)&__src[5] = v1;
        LOWORD(__src[7]) = 1024;
        *(_DWORD *)((char *)&__src[7] + 2) = v11;
        _os_log_error_impl(&dword_1B8270000, v28, OS_LOG_TYPE_ERROR, "%s:%d: %p open index state error:%d", (uint8_t *)__src, 0x22u);
      }
      *__error() = v27;
    }
  }
  else
  {
    v8 = v7;
    if (*(_BYTE *)(v1 + 2072))
      fcntl(v7, 64, 3);
    bzero(__src, 0x1000uLL);
    v9 = prot_pread(v8, __src, 0x1000uLL, 0);
    v10 = v9;
    if (v9 == -1)
    {
      v16 = *__error();
    }
    else
    {
      if (v9 == 4096)
      {
        close(v8);
LABEL_20:
        if (LOBYTE(__src[0]) == 1)
        {
          memcpy((void *)(v1 + 2480), __src, 0x1000uLL);
          v19 = *__error();
          v20 = _SILogForLogForCategory(11);
          v21 = 2 * (dword_1EF19FCB8 < 4);
          if (os_log_type_enabled(v20, v21))
          {
            if ((BYTE1(__src[0]) - 1) > 3u)
              v22 = "unknown";
            else
              v22 = off_1E6E2E448[(BYTE1(__src[0]) - 1)];
            *(_DWORD *)buf = 134218242;
            v33 = (const char *)v1;
            v34 = 2080;
            *(_QWORD *)v35 = v22;
            _os_log_impl(&dword_1B8270000, v20, v21, "%p read state:%s", buf, 0x16u);
          }
        }
        else
        {
          v19 = *__error();
          v23 = _SILogForLogForCategory(11);
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315906;
            v33 = "si_read_index_state";
            v34 = 1024;
            *(_DWORD *)v35 = 29846;
            *(_WORD *)&v35[4] = 2048;
            *(_QWORD *)&v35[6] = v1;
            v36 = 1024;
            v37 = LOBYTE(__src[0]);
            _os_log_error_impl(&dword_1B8270000, v23, OS_LOG_TYPE_ERROR, "%s:%d: %p invalid version:%d", buf, 0x22u);
          }
        }
        *__error() = v19;
        _si_dump_index_state(v1, 4);
        return;
      }
      v16 = 22;
    }
    v17 = *__error();
    v18 = _SILogForLogForCategory(11);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136316418;
      v33 = "si_read_index_state";
      v34 = 1024;
      *(_DWORD *)v35 = 29839;
      *(_WORD *)&v35[4] = 2048;
      *(_QWORD *)&v35[6] = v1;
      v36 = 1024;
      v37 = v8;
      v38 = 2048;
      v39 = v10;
      v40 = 1024;
      v41 = v16;
      _os_log_error_impl(&dword_1B8270000, v18, OS_LOG_TYPE_ERROR, "%s:%d: %p read index state fd:%d rs:%ld error:%d", buf, 0x32u);
    }
    *__error() = v17;
    close(v8);
    if (!v16)
      goto LABEL_20;
  }
}

uint64_t _SIOpenIndexFilesWithState(uint64_t a1, int a2, unsigned int a3, int a4, char a5, _BYTE *a6, _QWORD *a7, uint64_t a8, _DWORD *a9)
{
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  unsigned int v17;
  int v18;
  int *v19;
  int v20;
  int v21;
  int v22;
  NSObject *v23;
  int v24;
  int *v25;
  int v26;
  NSObject *v27;
  char v29;
  int v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  char v35;
  int v36;
  NSObject *v37;
  int updated;
  int v39;
  int v40;
  NSObject *v41;
  uint64_t v42;
  int v43;
  uint64_t v44;
  char v45;
  int v46;
  NSObject *v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  int v51;
  NSObject *v52;
  int v53;
  NSObject *v54;
  int v55;
  uint64_t v56;
  uint64_t v57;
  const __CFNumber *v58;
  const __CFNumber *v59;
  CFTypeID v60;
  uint64_t v61;
  int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  int v67;
  int v68;
  int v69;
  int v70;
  int v71;
  NSObject *v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  int v76;
  int v77;
  uint64_t v78;
  uint64_t v79;
  int v80;
  int v81;
  int v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  int *v88;
  int v89;
  int v90;
  NSObject *v91;
  int v92;
  int v93;
  int v94;
  NSObject *v95;
  os_log_type_t v96;
  uint64_t v97;
  int v98;
  BOOL v99;
  char *v100;
  void *v101;
  int v102;
  NSObject *v103;
  NSObject *v104;
  const char *v105;
  NSObject *v106;
  NSObject *v107;
  NSObject *v108;
  int v109;
  int v110;
  NSObject *v111;
  NSObject *v112;
  _BOOL4 v113;
  int *v114;
  uint64_t v115;
  uint64_t v116;
  _BYTE *v117;
  int v118;
  uint64_t v119;
  uint64_t v120;
  int v121;
  uint64_t v122;
  uint64_t v123;
  int v124;
  uint64_t v125;
  uint64_t v126;
  int v127;
  uint64_t v128;
  uint64_t v129;
  int v130;
  uint64_t v131;
  uint64_t v132;
  int v133;
  const char *v134;
  NSObject *v135;
  uint32_t v136;
  uint64_t datastore_with_ctx;
  const __CFNumber *v138;
  const __CFNumber *v139;
  CFTypeID v140;
  int v141;
  NSObject *v142;
  os_log_type_t v143;
  int v144;
  int v145;
  int v146;
  int v147;
  int v148;
  int v149;
  int v150;
  NSObject *v151;
  os_log_type_t v152;
  int v153;
  int v154;
  NSObject *v155;
  int v157;
  int v158;
  int v159;
  NSObject *v160;
  int v161;
  NSObject *v162;
  __int128 v163;
  __int128 v164;
  __int128 v165;
  int v166;
  NSObject *v167;
  os_log_type_t v168;
  uint64_t v169;
  char v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  int v174;
  int v175;
  NSObject *v176;
  os_log_type_t v177;
  int v178;
  int v179;
  int v180;
  int v181;
  NSObject *v182;
  os_log_type_t v183;
  char v184;
  uint64_t v185;
  int v186;
  BOOL v187;
  char *v188;
  void *v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  int v193;
  int v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  int v198;
  int v199;
  int v200;
  int v201;
  NSObject *v202;
  const char *v203;
  int v204;
  int v205;
  int v206;
  int v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  int *vector_store;
  NSObject *v213;
  os_log_type_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  int v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  int v226;
  int v227;
  int *v228;
  uint64_t v229;
  uint64_t New;
  int v231;
  int v232;
  int v233;
  int v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t *v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t *v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  unsigned __int8 *v245;
  uint64_t *v246;
  char v247;
  int v248;
  uint64_t v249;
  uint64_t *v250;
  unsigned __int8 *v251;
  char v252;
  int v253;
  uint64_t v254;
  char *v255;
  char *v256;
  const char *v257;
  char *v258;
  const char *v259;
  char *v260;
  const char *v261;
  uint64_t v262;
  char *v263;
  char *v264;
  const char *v265;
  char *v266;
  const char *v267;
  char *v268;
  const char *v269;
  uint64_t v270;
  char *v271;
  const char *v272;
  char *v273;
  const char *v274;
  uint64_t v275;
  _QWORD *v276;
  unsigned int v277;
  int v278;
  unsigned __int8 *v279;
  int v280;
  int *v281;
  int v282;
  uint64_t v288;
  char *v289;
  uint64_t v290;
  unsigned int v291;
  _QWORD v292[5];
  _QWORD v293[5];
  _QWORD v294[5];
  _QWORD v295[5];
  _QWORD v296[5];
  _QWORD v297[5];
  uint64_t v298;
  __int128 v299;
  __int128 v300;
  __int128 v301;
  __int128 v302;
  __int128 v303;
  __int128 v304;
  uint64_t v305;
  uint64_t v306;
  __int128 v307;
  __int128 v308;
  uint64_t v309;
  unsigned __int8 v310;
  __int128 v311;
  CFTypeRef cf;
  void *v313;
  uint64_t v314;
  _QWORD v315[5];
  int v316;
  uint64_t v317;
  uint8_t *v318;
  uint64_t v319;
  __int128 v320;
  uint8_t v321[24];
  uint8_t buf[4];
  const char *v323;
  __int16 v324;
  __int128 v325;
  char *v326;
  char __dst[4];
  _BYTE v328[10];
  _BYTE v329[14];
  __int16 v330;
  int v331;
  __int16 v332;
  int v333;
  uint64_t v334;

  v10 = a1;
  v334 = *MEMORY[0x1E0C80C00];
  *a6 = 0;
  *a7 = 0;
  v315[0] = MEMORY[0x1E0C809B0];
  v315[1] = 0x40000000;
  v315[2] = ___SIOpenIndexFilesWithState_block_invoke;
  v315[3] = &__block_descriptor_tmp_722;
  v315[4] = a1;
  v289 = (char *)(a1 + 6944);
  v11 = *(unsigned __int16 *)(a1 + 2484);
  v290 = *(unsigned __int16 *)(a1 + 2486);
  if (a4)
    v12 = 48;
  else
    v12 = 16;
  if (a3)
    v12 |= 0x40u;
  if (*(_BYTE *)(a1 + 2073))
    v12 |= 0x400u;
  if (*(_BYTE *)(a1 + 6944))
    v13 = 0;
  else
    v13 = *(unsigned __int16 *)(a1 + 2484);
  v14 = (*(_DWORD *)(a1 + 6584) >> 7) & 0x800 | v12;
  if (*(_BYTE *)(a1 + 6944))
    v14 |= 0x1000u;
  v15 = *(unsigned __int8 *)(a1 + 2072);
  v314 = 0;
  v313 = 0;
  v311 = 0uLL;
  cf = 0;
  if (v15)
    v16 = 111;
  else
    v16 = 95;
  if (v15)
    v17 = 114;
  else
    v17 = 102;
  if (v15)
    v18 = v14 | 0x100;
  else
    v18 = v14;
  v19 = (int *)(a1 + 1192);
  v20 = CIMetaInfoRead(a1 + 1192, v15);
  if (v20)
  {
    v21 = v20;
    v22 = *__error();
    v23 = _SILogForLogForCategory(11);
    if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
LABEL_24:
      *__error() = v22;
      goto LABEL_25;
    }
    *(_DWORD *)__dst = 136315906;
    *(_QWORD *)v328 = "_SIOpenIndexFilesWithState";
    *(_WORD *)&v328[8] = 1024;
    *(_DWORD *)v329 = 9927;
    *(_WORD *)&v329[4] = 2048;
    *(_QWORD *)&v329[6] = v10;
    v330 = 1024;
    v331 = v21;
    v134 = "%s:%d: %p CIMetaInfoRead err:%d";
    goto LABEL_237;
  }
  v280 = v15;
  v291 = v16;
  v281 = v19;
  v277 = a3;
  v278 = v18;
  v288 = v13;
  if (*(_DWORD *)(v10 + 1236) > 0x31u || *(_DWORD *)(v10 + 1244) > 0x31u)
  {
    v26 = *__error();
    v27 = _SILogForLogForCategory(11);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      v157 = *(_DWORD *)(v10 + 1236);
      v158 = *(_DWORD *)(v10 + 1244);
      *(_DWORD *)__dst = 136316162;
      *(_QWORD *)v328 = "_SIOpenIndexFilesWithState";
      *(_WORD *)&v328[8] = 1024;
      *(_DWORD *)v329 = 9931;
      *(_WORD *)&v329[4] = 2048;
      *(_QWORD *)&v329[6] = v10;
      v330 = 1024;
      v331 = v157;
      v332 = 1024;
      v333 = v158;
      _os_log_error_impl(&dword_1B8270000, v27, OS_LOG_TYPE_ERROR, "%s:%d: %p Too many live indexes %d/%d", (uint8_t *)__dst, 0x28u);
    }
    *__error() = v26;
    v24 = -1;
    goto LABEL_37;
  }
  v29 = 0;
  if (v15)
    v30 = 75777;
  else
    v30 = 10241;
  v282 = v30;
  v276 = (_QWORD *)(v10 + 2408);
  v275 = v11;
  v279 = (unsigned __int8 *)(v10 + 2488);
  v31 = v10 + 2488 + v11;
  while (2)
  {
    v32 = *(unsigned __int8 *)(v10 + 2482);
    if (!*(_BYTE *)(v10 + 2482))
      v32 = *(unsigned __int8 *)(v10 + 2481);
    v33 = *(unsigned int *)(v10 + 32);
    v316 = 0;
    bzero(&__dst[2], 0x3FEuLL);
    strcpy(__dst, ".");
    strlcat(__dst, "store.db", 0x400uLL);
    v310 = 0;
    v34 = v288;
    switch(v32)
    {
      case 1:
        v35 = v29;
        v36 = *__error();
        v37 = _SILogForLogForCategory(7);
        if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_1B8270000, v37, OS_LOG_TYPE_DEFAULT, "Restore sdb from shadow", buf, 2u);
        }
        *__error() = v36;
        updated = update_db_header(v33);
        if ((updated & 0xFFFFFFFD) != 0)
        {
          v39 = updated;
          v40 = *__error();
          v41 = _SILogForLogForCategory(7);
          if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 67109120;
            LODWORD(v323) = v39;
            _os_log_impl(&dword_1B8270000, v41, OS_LOG_TYPE_DEFAULT, "Failed to update header err:%d", buf, 8u);
          }
LABEL_81:
          *__error() = v40;
          v34 = v288;
          goto LABEL_82;
        }
        v45 = copyFileFallback(v33, "store.db", v33, __dst, &v316, 1, 1);
        v46 = *__error();
        if ((v45 & 1) == 0)
        {
          if (v46)
            v39 = v46;
          else
            v39 = -1;
          v40 = *__error();
          v52 = _SILogForLogForCategory(7);
          if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315906;
            v323 = "db2_update_datastore_state";
            v324 = 1024;
            LODWORD(v325) = 6778;
            WORD2(v325) = 2080;
            *(_QWORD *)((char *)&v325 + 6) = "store.db";
            HIWORD(v325) = 2080;
            v326 = __dst;
            _os_log_error_impl(&dword_1B8270000, v52, OS_LOG_TYPE_ERROR, "%s:%d: Failed to copyfile for recovery %s->%s", buf, 0x26u);
          }
          goto LABEL_81;
        }
        v47 = _SILogForLogForCategory(7);
        if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_1B8270000, v47, OS_LOG_TYPE_DEFAULT, "Restore data_map from shadow", buf, 2u);
        }
        *__error() = v46;
        bzero(buf, 0x400uLL);
        snprintf((char *)buf, 0x400uLL, "%sStr-%d.map", "db", 1);
        v317 = v33;
        v318 = buf;
        v319 = 0x8400000002;
        v320 = 0u;
        memset(v321, 0, sizeof(v321));
        v48 = data_map32_init_with_ctx((uint64_t)&v317);
        if (v48)
        {
          v49 = v48;
          v50 = *(_DWORD *)(v48 + 216);
          switch(v50)
          {
            case -270471200:
              _data_map_ext_commit(v48);
              break;
            case 1684300900:
              _data_map64_commit(v48);
              break;
            case 842150450:
              _data_map32_commit(v48, 1);
              break;
          }
          data_map_destroy(v49);
        }
        bzero(buf, 0x400uLL);
        snprintf((char *)buf, 0x400uLL, "%sStr-%d.map", "db", 2);
        v319 = 0x8400000000;
        v317 = v33;
        v318 = buf;
        v320 = 0u;
        memset(v321, 0, sizeof(v321));
        v119 = data_map32_init_with_ctx((uint64_t)&v317);
        if (v119)
        {
          v120 = v119;
          v121 = *(_DWORD *)(v119 + 216);
          switch(v121)
          {
            case -270471200:
              _data_map_ext_commit(v119);
              break;
            case 1684300900:
              _data_map64_commit(v119);
              break;
            case 842150450:
              _data_map32_commit(v119, 1);
              break;
          }
          data_map_destroy(v120);
        }
        bzero(buf, 0x400uLL);
        snprintf((char *)buf, 0x400uLL, "%sStr-%d.map", "db", 3);
        v319 = 0x8400000000;
        v317 = v33;
        v318 = buf;
        v320 = 0u;
        memset(v321, 0, sizeof(v321));
        v122 = data_map32_init_with_ctx((uint64_t)&v317);
        if (v122)
        {
          v123 = v122;
          v124 = *(_DWORD *)(v122 + 216);
          switch(v124)
          {
            case -270471200:
              _data_map_ext_commit(v122);
              break;
            case 1684300900:
              _data_map64_commit(v122);
              break;
            case 842150450:
              _data_map32_commit(v122, 1);
              break;
          }
          data_map_destroy(v123);
        }
        bzero(buf, 0x400uLL);
        snprintf((char *)buf, 0x400uLL, "%sStr-%d.map", "db", 4);
        v319 = 0x8400000000;
        v317 = v33;
        v318 = buf;
        v320 = 0u;
        memset(v321, 0, sizeof(v321));
        v125 = data_map32_init_with_ctx((uint64_t)&v317);
        if (v125)
        {
          v126 = v125;
          v127 = *(_DWORD *)(v125 + 216);
          switch(v127)
          {
            case -270471200:
              _data_map_ext_commit(v125);
              break;
            case 1684300900:
              _data_map64_commit(v125);
              break;
            case 842150450:
              _data_map32_commit(v125, 1);
              break;
          }
          data_map_destroy(v126);
        }
        bzero(buf, 0x400uLL);
        snprintf((char *)buf, 0x400uLL, "%sStr-%d.map", "db", 5);
        v319 = 0x8400000000;
        v317 = v33;
        v318 = buf;
        v320 = 0u;
        memset(v321, 0, sizeof(v321));
        v128 = data_map32_init_with_ctx((uint64_t)&v317);
        if (v128)
        {
          v129 = v128;
          v130 = *(_DWORD *)(v128 + 216);
          switch(v130)
          {
            case -270471200:
              _data_map_ext_commit(v128);
              break;
            case 1684300900:
              _data_map64_commit(v128);
              break;
            case 842150450:
              _data_map32_commit(v128, 1);
              break;
          }
          data_map_destroy(v129);
        }
        bzero(buf, 0x400uLL);
        snprintf((char *)buf, 0x400uLL, "%sStr-%d.map", "db", 6);
        v317 = v33;
        v318 = buf;
        v319 = 0xC400000004;
        v320 = 0u;
        memset(v321, 0, sizeof(v321));
        v131 = data_map_ext_init_with_ctx((uint64_t)&v317);
        if (v131)
        {
          v132 = v131;
          v133 = *(_DWORD *)(v131 + 216);
          switch(v133)
          {
            case -270471200:
              _data_map_ext_commit(v131);
              break;
            case 1684300900:
              _data_map64_commit(v131);
              break;
            case 842150450:
              _data_map32_commit(v131, 1);
              break;
          }
          data_map_destroy(v132);
        }
        v39 = update_db_header(v33);
        v34 = v288;
        if (v39)
          goto LABEL_82;
        goto LABEL_59;
      case 2:
        v35 = v29;
        v39 = update_db_header(v33);
        if (v39)
          goto LABEL_82;
        v43 = 2;
        goto LABEL_62;
      case 3:
        v35 = v29;
        v39 = update_db_header(v33);
        if (v39)
          goto LABEL_82;
        if ((copyFileFallback(v33, __dst, v33, "store.db", &v316, 1, 1) & 1) != 0)
        {
          v42 = v33;
LABEL_58:
          v39 = update_db_header(v42);
          if (v39)
            goto LABEL_82;
LABEL_59:
          v43 = 4;
LABEL_62:
          v310 = v43;
          v29 = v35;
LABEL_64:
          v44 = v290;
LABEL_86:
          if (v43 != *(unsigned __int8 *)(v10 + 2482))
          {
            *(_BYTE *)(v10 + 2482) = v43;
            v55 = si_write_index_state(v10, 0, 0);
            if (v55)
            {
              v161 = v55;
              v22 = *__error();
              v23 = _SILogForLogForCategory(11);
              if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
                goto LABEL_24;
              *(_DWORD *)__dst = 136315906;
              *(_QWORD *)v328 = "_SIOpenIndexFilesWithState";
              *(_WORD *)&v328[8] = 1024;
              *(_DWORD *)v329 = 9946;
              *(_WORD *)&v329[4] = 2048;
              *(_QWORD *)&v329[6] = v10;
              v330 = 1024;
              v331 = v161;
              v134 = "%s:%d: %p si_write_index_state err:%d";
LABEL_237:
              v135 = v23;
              v136 = 34;
LABEL_238:
              _os_log_error_impl(&dword_1B8270000, v135, OS_LOG_TYPE_ERROR, v134, (uint8_t *)__dst, v136);
              goto LABEL_24;
            }
          }
          v307 = 0u;
          v308 = 0u;
          v309 = 0;
          LODWORD(v307) = *(_DWORD *)(v10 + 32);
          *((_QWORD *)&v307 + 1) = "store.db";
          *(_QWORD *)&v308 = __PAIR64__(*(_DWORD *)(v10 + 60), v282);
          if (SIIsAppleInternal_onceToken != -1)
            dispatch_once(&SIIsAppleInternal_onceToken, &__block_literal_global_4644);
          v56 = v10 + 2192;
          if (!SIIsAppleInternal_internal)
            v56 = 0;
          *((_QWORD *)&v308 + 1) = v56;
          LOBYTE(v309) = 0;
          if (*(_BYTE *)(v10 + 2481) != 2)
          {
            datastore_with_ctx = db2_get_datastore_with_ctx((unsigned int *)&v307);
            *(_QWORD *)(v10 + 1184) = datastore_with_ctx;
            if (!datastore_with_ctx)
              goto LABEL_25;
            *(_DWORD *)__dst = 0;
            v138 = (const __CFNumber *)SICopyProperty(v10, CFSTR("kSINextIndexId"));
            if (v138)
            {
              v139 = v138;
              v140 = CFGetTypeID(v138);
              if (v140 == CFNumberGetTypeID())
                CFNumberGetValue(v139, kCFNumberSInt32Type, __dst);
              CFRelease(v139);
            }
            if (*(_DWORD *)__dst > *(_DWORD *)(v10 + 1456))
              *(_DWORD *)(v10 + 1456) = *(_DWORD *)__dst;
            db_datastore_set_bg_assertion_flag(*(_QWORD *)(v10 + 1184), *v289);
            if (!v277)
              goto LABEL_297;
            if (*(_BYTE *)(v10 + 2483) == 2 && (_si_dump_index_state(v10, 2), *(_BYTE *)(v10 + 2483) == 2))
            {
              v263 = __si_assert_copy_extra_521(-1);
              v264 = v263;
              v265 = "";
              if (v263)
                v265 = v263;
              __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 10208, "s->directory_state!=kSIIndexStateFastFlush", v265);
            }
            else
            {
              v141 = *__error();
              v142 = _SILogForLogForCategory(6);
              v143 = 2 * (dword_1EF19FCA4 < 4);
              if (os_log_type_enabled(v142, v143))
              {
                v144 = *(unsigned __int8 *)(v10 + 2483);
                v145 = *(unsigned __int8 *)(v10 + 2481);
                if (*(_BYTE *)(v10 + 2483))
                  v146 = *(unsigned __int8 *)(v10 + 2483);
                else
                  v146 = *(unsigned __int8 *)(v10 + 2481);
                *(_DWORD *)__dst = 67109632;
                *(_DWORD *)v328 = v146;
                *(_WORD *)&v328[4] = 1024;
                *(_DWORD *)&v328[6] = v144;
                *(_WORD *)v329 = 1024;
                *(_DWORD *)&v329[2] = v145;
                _os_log_impl(&dword_1B8270000, v142, v143, "Update reverse store with state: %d (%d, %d)", (uint8_t *)__dst, 0x14u);
              }
              *__error() = v141;
              v147 = *(unsigned __int8 *)(v10 + 2483);
              if (!*(_BYTE *)(v10 + 2483))
                v147 = *(unsigned __int8 *)(v10 + 2481);
              v148 = reverseStoreUpdateState(*(unsigned int *)(v10 + 32), v147, &v310);
              v149 = v148;
              LODWORD(v34) = v288;
              if (v280 && v148 == 2)
              {
                v150 = *__error();
                v151 = _SILogForLogForCategory(6);
                if (os_log_type_enabled(v151, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)__dst = 136315394;
                  *(_QWORD *)v328 = "_SIOpenIndexFilesWithState";
                  *(_WORD *)&v328[8] = 1024;
                  *(_DWORD *)v329 = 10215;
                  _os_log_error_impl(&dword_1B8270000, v151, OS_LOG_TYPE_ERROR, "%s:%d: Ignoring missing path store", (uint8_t *)__dst, 0x12u);
                }
                *__error() = v150;
                *(_QWORD *)(v10 + 6624) = createReverseStore(*(_DWORD *)(v10 + 32), "", v315);
                goto LABEL_297;
              }
              if (v148)
              {
                v22 = *__error();
                v162 = _SILogForLogForCategory(11);
                if (!os_log_type_enabled(v162, OS_LOG_TYPE_ERROR))
                  goto LABEL_24;
                *(_DWORD *)__dst = 136315650;
                *(_QWORD *)v328 = "_SIOpenIndexFilesWithState";
                *(_WORD *)&v328[8] = 1024;
                *(_DWORD *)v329 = 10220;
                *(_WORD *)&v329[4] = 1024;
                *(_DWORD *)&v329[6] = v149;
                v134 = "%s:%d: reverseStoreUpdateState err:%d";
                goto LABEL_276;
              }
              v174 = v310;
              if (v310 != *(unsigned __int8 *)(v10 + 2483))
              {
                v175 = *__error();
                v176 = _SILogForLogForCategory(6);
                v177 = 2 * (dword_1EF19FCA4 < 4);
                if (os_log_type_enabled(v176, v177))
                {
                  *(_DWORD *)__dst = 67109120;
                  *(_DWORD *)v328 = v174;
                  _os_log_impl(&dword_1B8270000, v176, v177, "Got reverse store with state: %d", (uint8_t *)__dst, 8u);
                }
                *__error() = v175;
                *(_BYTE *)(v10 + 2483) = v174;
                v178 = si_write_index_state(v10, 0, 0);
                if (v178)
                {
                  v179 = v178;
                  v22 = *__error();
                  v162 = _SILogForLogForCategory(11);
                  if (!os_log_type_enabled(v162, OS_LOG_TYPE_ERROR))
                    goto LABEL_24;
                  *(_DWORD *)__dst = 136315650;
                  *(_QWORD *)v328 = "_SIOpenIndexFilesWithState";
                  *(_WORD *)&v328[8] = 1024;
                  *(_DWORD *)v329 = 10228;
                  *(_WORD *)&v329[4] = 1024;
                  *(_DWORD *)&v329[6] = v179;
                  v134 = "%s:%d: si_write_index_state err:%d";
LABEL_276:
                  v135 = v162;
                  v136 = 24;
                  goto LABEL_238;
                }
              }
              v317 = 0;
              v180 = check_crash_state(*(_DWORD *)(v10 + 32), 0, a5, &v317, 2);
              bzero(__dst, 0x400uLL);
              v181 = *__error();
              v182 = _SILogForLogForCategory(0);
              v183 = 2 * (gSILogLevels[0] < 4);
              if (os_log_type_enabled(v182, v183))
              {
                v184 = v29;
                v185 = v317;
                v186 = fcntl(*(_DWORD *)(v10 + 32), 50, __dst);
                if (__dst[0])
                  v187 = v186 < 0;
                else
                  v187 = 1;
                if (v187)
                  v188 = 0;
                else
                  v188 = __dst;
                *(_DWORD *)buf = 134218242;
                v323 = (const char *)v185;
                v29 = v184;
                v324 = 2080;
                *(_QWORD *)&v325 = v188;
                _os_log_impl(&dword_1B8270000, v182, v183, "rs last_crash_delta: %ld for %s", buf, 0x16u);
              }
              *__error() = v181;
              v189 = openReverseStore(*(_DWORD *)(v10 + 32), v180 != 0, 0, 0, *(_DWORD **)(v10 + 6592), &v311, v315);
              *(_QWORD *)(v10 + 6624) = v189;
              if (!v189)
                *a9 |= 1u;
              v44 = v290;
              LODWORD(v34) = v288;
LABEL_297:
              updateMetaInfoForState(v281, v34, v44);
              if ((_DWORD)v34)
              {
                v190 = 0;
                while (1)
                {
                  v191 = v10 + v190;
                  v192 = *(unsigned __int8 *)(v10 + v190 + 2488);
                  if (!*(_BYTE *)(v10 + v190 + 2488))
                    v192 = *(unsigned __int8 *)(v10 + 2481);
                  v193 = ContentIndexUpdateState(*(unsigned int *)(v10 + 32), *(unsigned int *)(v10 + 1276), v291, v17, v277, 0, v190, v192, &v310);
                  if (v193)
                  {
                    v200 = v193;
                    v201 = *__error();
                    v202 = _SILogForLogForCategory(11);
                    if (!os_log_type_enabled(v202, OS_LOG_TYPE_ERROR))
                      goto LABEL_323;
                    *(_DWORD *)__dst = 136315906;
                    *(_QWORD *)v328 = "_SIOpenIndexFilesWithState";
                    *(_WORD *)&v328[8] = 1024;
                    *(_DWORD *)v329 = 10266;
                    *(_WORD *)&v329[4] = 2048;
                    *(_QWORD *)&v329[6] = v10;
                    v330 = 1024;
                    v331 = v200;
                    v203 = "%s:%d: %p ContentIndexUpdateState err:%d";
                    goto LABEL_322;
                  }
                  if (*(unsigned __int8 *)(v191 + 2488) != v310)
                  {
                    *(_BYTE *)(v191 + 2488) = v310;
                    v194 = si_write_index_state(v10, 0, 0);
                    if (v194)
                      break;
                  }
                  if (v288 == ++v190)
                    goto LABEL_305;
                }
                v205 = v194;
                v201 = *__error();
                v202 = _SILogForLogForCategory(11);
                if (!os_log_type_enabled(v202, OS_LOG_TYPE_ERROR))
                  goto LABEL_323;
                *(_DWORD *)__dst = 136315906;
                *(_QWORD *)v328 = "_SIOpenIndexFilesWithState";
                *(_WORD *)&v328[8] = 1024;
                *(_DWORD *)v329 = 10273;
                *(_WORD *)&v329[4] = 2048;
                *(_QWORD *)&v329[6] = v10;
                v330 = 1024;
                v331 = v205;
                v203 = "%s:%d: %p si_write_index_state err:%d";
LABEL_322:
                _os_log_error_impl(&dword_1B8270000, v202, OS_LOG_TYPE_ERROR, v203, (uint8_t *)__dst, 0x22u);
LABEL_323:
                *__error() = v201;
              }
              else
              {
LABEL_305:
                if ((_DWORD)v44)
                {
                  v195 = 0;
                  v196 = v275 + v10 + 2488;
                  while (1)
                  {
                    v197 = *(unsigned __int8 *)(v196 + v195);
                    if (!*(_BYTE *)(v196 + v195))
                      v197 = *(unsigned __int8 *)(v10 + 2481);
                    v198 = ContentIndexUpdateState(*(unsigned int *)(v10 + 32), *(unsigned int *)(v10 + 1276), v291, v17, v277, 1, v195, v197, &v310);
                    if (v198)
                    {
                      v204 = v198;
                      v201 = *__error();
                      v202 = _SILogForLogForCategory(11);
                      if (!os_log_type_enabled(v202, OS_LOG_TYPE_ERROR))
                        goto LABEL_323;
                      *(_DWORD *)__dst = 136315906;
                      *(_QWORD *)v328 = "_SIOpenIndexFilesWithState";
                      *(_WORD *)&v328[8] = 1024;
                      *(_DWORD *)v329 = 10283;
                      *(_WORD *)&v329[4] = 2048;
                      *(_QWORD *)&v329[6] = v10;
                      v330 = 1024;
                      v331 = v204;
                      v203 = "%s:%d: %p ContentIndexUpdateState err:%d";
                      goto LABEL_322;
                    }
                    if (*(unsigned __int8 *)(v196 + v195) != v310)
                    {
                      *(_BYTE *)(v196 + v195) = v310;
                      v199 = si_write_index_state(v10, 0, 0);
                      if (v199)
                        break;
                    }
                    if (v44 == ++v195)
                      goto LABEL_324;
                  }
                  v206 = v199;
                  v201 = *__error();
                  v202 = _SILogForLogForCategory(11);
                  if (!os_log_type_enabled(v202, OS_LOG_TYPE_ERROR))
                    goto LABEL_323;
                  *(_DWORD *)__dst = 136315906;
                  *(_QWORD *)v328 = "_SIOpenIndexFilesWithState";
                  *(_WORD *)&v328[8] = 1024;
                  *(_DWORD *)v329 = 10290;
                  *(_WORD *)&v329[4] = 2048;
                  *(_QWORD *)&v329[6] = v10;
                  v330 = 1024;
                  v331 = v206;
                  v203 = "%s:%d: %p si_write_index_state err:%d";
                  goto LABEL_322;
                }
              }
LABEL_324:
              v170 = v29;
              v207 = *(_DWORD *)(v10 + 1456);
              v208 = v10;
              v173 = MEMORY[0x1E0C809B0];
              v295[0] = MEMORY[0x1E0C809B0];
              v295[1] = 0x40000000;
              v295[2] = ___SIOpenIndexFilesWithState_block_invoke_730;
              v295[3] = &__block_descriptor_tmp_731;
              v295[4] = v208;
              _si_next_index_id((os_unfair_lock_s *)v208, (*(_DWORD *)(*(_QWORD *)(v208 + 1384) + 8) + *(_DWORD *)(*(_QWORD *)(v208 + 1392) + 8)), 0, 1);
              v294[0] = v173;
              v294[1] = 0x40000000;
              v294[2] = ___SIOpenIndexFilesWithState_block_invoke_2_732;
              v294[3] = &__block_descriptor_tmp_733;
              v294[4] = v208;
              v209 = *(_QWORD *)(v208 + 1392);
              v210 = *(_QWORD *)(v208 + 1384);
              v211 = *(_QWORD *)(v208 + 6592);
              v172 = v208;
              vector_store = *(int **)(v208 + 1184);
              if (vector_store)
                vector_store = (int *)db_get_vector_store(vector_store);
              v24 = ContentIndexOpenBulk((uint64_t)v281, a8, v209, v210, v278 | 6u, v211, (uint64_t)v276, (uint64_t)a7, (uint64_t)vector_store, (uint64_t)v295, v294);
              if (v24 < 0)
              {
                v10 = v208;
                *(_DWORD *)(v208 + 1456) = v207;
                __error();
                goto LABEL_26;
              }
              v166 = *__error();
              v213 = _SILogForLogForCategory(11);
              v214 = 2 * (dword_1EF19FCB8 < 4);
              if (os_log_type_enabled(v213, v214))
              {
                v215 = *(_QWORD *)(v208 + 2408);
                *(_DWORD *)__dst = 134218240;
                *(_QWORD *)v328 = v208;
                *(_WORD *)&v328[8] = 2048;
                *(_QWORD *)v329 = v215;
                _os_log_impl(&dword_1B8270000, v213, v214, "opened index %p with recovery time is %llu)", (uint8_t *)__dst, 0x16u);
              }
              v171 = v288;
LABEL_330:
              *__error() = v166;
              if ((a2 == 1) | v170 & 1)
                v24 = 2;
              v216 = v172;
              v217 = *(_QWORD *)(v172 + 1384);
              v218 = v290;
              if (!*(_DWORD *)(v217 + 8))
              {
                v219 = *(_QWORD *)(v172 + 1392);
                v220 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v219 + 8 * (*(_DWORD *)(v219 + 8) - 1)) + 32);
                v293[0] = v173;
                v293[1] = 0x40000000;
                v293[2] = ___SIOpenIndexFilesWithState_block_invoke_734;
                v293[3] = &__block_descriptor_tmp_735;
                v293[4] = v172;
                v221 = *(unsigned int *)(v172 + 32);
                v222 = *(_QWORD *)(*(_QWORD *)v219 + 8 * (*(_DWORD *)(v219 + 8) - 1));
                LODWORD(v223) = *(_DWORD *)(v222 + 60);
                v224 = *(_QWORD *)(v222 + 72);
                if (v223 >= 2)
                  v223 = v223;
                else
                  v223 = 0;
                v225 = v224 + v223;
                if (v220)
                  v226 = v220 + 1;
                else
                  v226 = 2;
                v227 = *(_DWORD *)(v216 + 1276);
                v228 = *(int **)(v216 + 1184);
                if (v228)
                  v229 = db_get_vector_store(v228);
                else
                  v229 = 0;
                v292[0] = v173;
                v292[1] = 0x40000000;
                v292[2] = ___SIOpenIndexFilesWithState_block_invoke_2_738;
                v292[3] = &__block_descriptor_tmp_739;
                v292[4] = v216;
                New = ContentIndexCreateNew(v221, CFSTR("live.0."), v225, v226, v278, 1, v227, v229, (uint64_t)v292, v293);
                v217 = *(_QWORD *)(v216 + 1384);
                if (New)
                {
                  ContentIndexListAppend(v217, New);
                  v217 = *(_QWORD *)(v216 + 1384);
                }
                v218 = v290;
                v171 = v288;
              }
              v231 = *(_DWORD *)(v217 + 8);
              if (!v231)
                goto LABEL_359;
              v232 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v217 + 8 * (v231 - 1)) + 4);
              if (!db_uses_stringmap(*(_QWORD *)(v216 + 1184)))
                goto LABEL_353;
              if ((v232 - 95) < 4)
              {
                ContentIndexListsApply(*(_QWORD *)(v216 + 1392), *(_QWORD *)(v216 + 1384), (uint64_t)*(&off_1E6E2E468 + (v232 - 95)));
                goto LABEL_353;
              }
              if ((db_corespotlight_store(*(_QWORD *)(v216 + 1184)) & 1) != 0
                || (v232 - 99) < 2
                || v232 == 102)
              {
LABEL_353:
                v233 = *(_DWORD *)(*(_QWORD *)(**(_QWORD **)(v216 + 1384)
                                             + 8 * (*(_DWORD *)(*(_QWORD *)(v216 + 1384) + 8) - 1))
                                 + 4);
                if (!db_uses_stringmap(*(_QWORD *)(v216 + 1184)))
                  goto LABEL_359;
                if ((v233 - 95) < 4)
                {
                  ContentIndexListsApply(*(_QWORD *)(v216 + 1392), *(_QWORD *)(v216 + 1384), (uint64_t)*(&off_1E6E2E488 + (v233 - 95)));
                  goto LABEL_359;
                }
                if ((db_corespotlight_store(*(_QWORD *)(v216 + 1184)) & 1) != 0
                  || (v233 - 99) < 2
                  || v233 == 102)
                {
LABEL_359:
                  v234 = *(unsigned __int8 *)(v216 + 2482) == 4;
                  if (*(_BYTE *)(v216 + 2482) == 4 && v277)
                    v234 = *(unsigned __int8 *)(v216 + 2483) == 4;
                  if (v24)
                  {
                    if (v24 == 2)
                    {
                      v235 = *(_QWORD *)(v216 + 1392);
                      v236 = *(unsigned int *)(v235 + 8);
                      if ((_DWORD)v236)
                      {
                        v237 = *(uint64_t **)v235;
                        do
                        {
                          v238 = *v237++;
                          *(_BYTE *)(v238 + 15161) = 4;
                          --v236;
                        }
                        while (v236);
                      }
                      v239 = *(_QWORD *)(v216 + 1384);
                      v240 = *(unsigned int *)(v239 + 8);
                      if ((_DWORD)v240)
                      {
                        v241 = *(uint64_t **)v239;
                        do
                        {
                          v242 = *v241++;
                          *(_BYTE *)(v242 + 15161) = 4;
                          --v240;
                        }
                        while (v240);
                      }
                    }
LABEL_379:
                    if (v234 && *(_BYTE *)(v216 + 2481) != 4)
                    {
                      *(_BYTE *)(v216 + 2481) = 4;
                      si_write_index_state(v216, 0, 0);
                    }
                    goto LABEL_37;
                  }
                  v243 = *(_QWORD *)(v216 + 1392);
                  if ((_DWORD)v171 == *(_DWORD *)(v243 + 8))
                  {
                    v244 = *(_QWORD *)(v216 + 1384);
                    v245 = v279;
                    if (*(_DWORD *)(v244 + 8) == (_DWORD)v218)
                    {
                      if ((_DWORD)v171)
                      {
                        v246 = *(uint64_t **)v243;
                        do
                        {
                          v248 = *v245++;
                          v247 = v248;
                          v234 = (v248 == 4) & v234;
                          v249 = *v246++;
                          *(_BYTE *)(v249 + 15161) = v247;
                          --v171;
                        }
                        while (v171);
                      }
                      if ((_DWORD)v218)
                      {
                        v250 = *(uint64_t **)v244;
                        v251 = (unsigned __int8 *)(v275 + v216 + 2488);
                        do
                        {
                          v253 = *v251++;
                          v252 = v253;
                          v234 = (v253 == 4) & v234;
                          v254 = *v250++;
                          *(_BYTE *)(v254 + 15161) = v252;
                          --v218;
                        }
                        while (v218);
                      }
                      goto LABEL_379;
                    }
                    v268 = __si_assert_copy_extra_521(-1);
                    v264 = v268;
                    v269 = "";
                    if (v268)
                      v269 = v268;
                    __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 10393, "liveCount == newIndex->liveSet->indexCount", v269);
                  }
                  else
                  {
                    v266 = __si_assert_copy_extra_521(-1);
                    v264 = v266;
                    v267 = "";
                    if (v266)
                      v267 = v266;
                    __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 10392, "scanCount == newIndex->syncSet->indexCount", v267);
                  }
                }
                else
                {
                  v273 = __si_assert_copy_extra_521(-1);
                  v264 = v273;
                  v274 = "";
                  if (v273)
                    v274 = v273;
                  __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 10373, "db_corespotlight_store(newIndex->store) || version == 99 || version == 100 || version == 102", v274);
                }
              }
              else
              {
                v271 = __si_assert_copy_extra_521(-1);
                v264 = v271;
                v272 = "";
                if (v271)
                  v272 = v271;
                __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 10355, "db_corespotlight_store(newIndex->store) || version == 99 || version == 100 || version == 102", v272);
              }
            }
            free(v264);
            if (__valid_fs(-1))
              v270 = 2989;
            else
              v270 = 3072;
            *(_DWORD *)v270 = -559038737;
            abort();
          }
          if ((v29 & 1) != 0)
          {
            v255 = __si_assert_copy_extra_521(-1);
            v256 = v255;
            v257 = "";
            if (v255)
              v257 = v255;
            __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 9963, "!fast_flush_failed", v257);
LABEL_391:
            free(v256);
            if (__valid_fs(-1))
              v262 = 2989;
            else
              v262 = 3072;
            *(_DWORD *)v262 = -559038737;
            abort();
          }
          v57 = db2_get_datastore_with_ctx((unsigned int *)&v307);
          *(_QWORD *)(v10 + 1184) = v57;
          if (!v57)
          {
            v68 = 0;
            goto LABEL_169;
          }
          *(_DWORD *)__dst = 0;
          v58 = (const __CFNumber *)SICopyProperty(v10, CFSTR("kSINextIndexId"));
          if (v58)
          {
            v59 = v58;
            v60 = CFGetTypeID(v58);
            if (v60 == CFNumberGetTypeID())
              CFNumberGetValue(v59, kCFNumberSInt32Type, __dst);
            CFRelease(v59);
          }
          if (*(_DWORD *)__dst > *(_DWORD *)(v10 + 1456))
            *(_DWORD *)(v10 + 1456) = *(_DWORD *)__dst;
          db_datastore_set_bg_assertion_flag(*(_QWORD *)(v10 + 1184), *v289);
          if (*(_BYTE *)(v10 + 2482) == 2)
          {
            v67 = db_restore_dirty_chunk_info(*(_DWORD *)(v10 + 32), (uint64_t)&v313, v61, v62, v63, v64, v65, v66);
            if (v67)
              goto LABEL_103;
            db_set_dirty_chunks(*(_QWORD *)(v10 + 1184), (uint64_t)v313, v314, SHIDWORD(v314));
            v313 = 0;
          }
          if (v277)
          {
            v69 = *(unsigned __int8 *)(v10 + 2483);
            if (!*(_BYTE *)(v10 + 2483))
              v69 = *(unsigned __int8 *)(v10 + 2481);
            v70 = reverseStoreUpdateState(*(unsigned int *)(v10 + 32), v69, &v310);
            v68 = v70;
            if (v15 && v70 == 2)
            {
              v71 = *__error();
              v72 = _SILogForLogForCategory(6);
              if (os_log_type_enabled(v72, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)__dst = 136315394;
                *(_QWORD *)v328 = "_SIOpenIndexFilesWithState";
                *(_WORD *)&v328[8] = 1024;
                *(_DWORD *)v329 = 10008;
                _os_log_error_impl(&dword_1B8270000, v72, OS_LOG_TYPE_ERROR, "%s:%d: Ignoring missing path store", (uint8_t *)__dst, 0x12u);
              }
              *__error() = v71;
              *(_QWORD *)(v10 + 6624) = createReverseStore(*(_DWORD *)(v10 + 32), "", v315);
            }
            else
            {
              if (v70)
                goto LABEL_169;
              v92 = v310;
              if (v310 != *(unsigned __int8 *)(v10 + 2483))
              {
                *(_BYTE *)(v10 + 2483) = v310;
                v67 = si_write_index_state(v10, 0, 0);
                if (v67)
                  goto LABEL_103;
                v92 = *(unsigned __int8 *)(v10 + 2483);
              }
              if (v92 == 2)
              {
                v67 = reverseStoreRestoreDirtyBitmap(*(_DWORD *)(v10 + 32), (uint64_t)&v311);
                if (v67)
                {
LABEL_103:
                  v68 = v67;
LABEL_169:
                  v24 = -1;
                  goto LABEL_170;
                }
              }
              v317 = 0;
              v93 = check_crash_state(*(_DWORD *)(v10 + 32), 0, a5, &v317, 2);
              bzero(__dst, 0x400uLL);
              v94 = *__error();
              v95 = _SILogForLogForCategory(0);
              v96 = 2 * (gSILogLevels[0] < 4);
              if (os_log_type_enabled(v95, v96))
              {
                v97 = v317;
                v98 = fcntl(*(_DWORD *)(v10 + 32), 50, __dst);
                if (__dst[0])
                  v99 = v98 < 0;
                else
                  v99 = 1;
                *(_DWORD *)buf = 134218242;
                v100 = __dst;
                if (v99)
                  v100 = 0;
                v323 = (const char *)v97;
                v44 = v290;
                v324 = 2080;
                *(_QWORD *)&v325 = v100;
                _os_log_impl(&dword_1B8270000, v95, v96, "rs last_crash_delta: %ld for %s", buf, 0x16u);
              }
              *__error() = v94;
              v101 = openReverseStore(*(_DWORD *)(v10 + 32), v93 != 0, 0, 0, *(_DWORD **)(v10 + 6592), &v311, v315);
              *(_QWORD *)(v10 + 6624) = v101;
              if (cf)
              {
                CFRelease(cf);
                cf = 0;
                v101 = *(void **)(v10 + 6624);
              }
              v34 = v288;
              v311 = 0uLL;
              if (!v101)
                *a9 |= 1u;
            }
          }
          updateMetaInfoForState(v281, v34, v44);
          if ((_DWORD)v34)
          {
            v73 = 0;
            while (1)
            {
              v74 = v10 + v73;
              v75 = *(unsigned __int8 *)(v10 + v73 + 2488);
              if (!*(_BYTE *)(v10 + v73 + 2488))
                v75 = *(unsigned __int8 *)(v10 + 2481);
              v76 = ContentIndexUpdateState(*(unsigned int *)(v10 + 32), *(unsigned int *)(v10 + 1276), v291, v17, v277, 0, v73, v75, &v310);
              if (v76)
              {
                v68 = v76;
                v102 = *__error();
                v103 = _SILogForLogForCategory(11);
                if (!os_log_type_enabled(v103, OS_LOG_TYPE_ERROR))
                  goto LABEL_168;
                *(_DWORD *)__dst = 136315906;
                *(_QWORD *)v328 = "_SIOpenIndexFilesWithState";
                *(_WORD *)&v328[8] = 1024;
                *(_DWORD *)v329 = 10058;
                *(_WORD *)&v329[4] = 2048;
                *(_QWORD *)&v329[6] = v10;
                v330 = 1024;
                v331 = v68;
                v104 = v103;
                v105 = "%s:%d: %p ContentIndexUpdateState err:%d";
                goto LABEL_167;
              }
              if (*(unsigned __int8 *)(v74 + 2488) != v310)
              {
                *(_BYTE *)(v74 + 2488) = v310;
                v77 = si_write_index_state(v10, 0, 0);
                if (v77)
                  break;
              }
              if (v34 == ++v73)
                goto LABEL_122;
            }
            v68 = v77;
            v102 = *__error();
            v107 = _SILogForLogForCategory(11);
            if (!os_log_type_enabled(v107, OS_LOG_TYPE_ERROR))
              goto LABEL_168;
            *(_DWORD *)__dst = 136315906;
            *(_QWORD *)v328 = "_SIOpenIndexFilesWithState";
            *(_WORD *)&v328[8] = 1024;
            *(_DWORD *)v329 = 10065;
            *(_WORD *)&v329[4] = 2048;
            *(_QWORD *)&v329[6] = v10;
            v330 = 1024;
            v331 = v68;
            v104 = v107;
            v105 = "%s:%d: %p si_write_index_state err:%d";
            goto LABEL_167;
          }
LABEL_122:
          if ((_DWORD)v44)
          {
            v78 = 0;
            while (1)
            {
              v79 = *(unsigned __int8 *)(v31 + v78);
              if (!*(_BYTE *)(v31 + v78))
                v79 = *(unsigned __int8 *)(v10 + 2481);
              v80 = ContentIndexUpdateState(*(unsigned int *)(v10 + 32), *(unsigned int *)(v10 + 1276), v291, v17, v277, 1, v78, v79, &v310);
              if (v80)
              {
                v68 = v80;
                v102 = *__error();
                v106 = _SILogForLogForCategory(11);
                if (!os_log_type_enabled(v106, OS_LOG_TYPE_ERROR))
                  goto LABEL_168;
                *(_DWORD *)__dst = 136315906;
                *(_QWORD *)v328 = "_SIOpenIndexFilesWithState";
                *(_WORD *)&v328[8] = 1024;
                *(_DWORD *)v329 = 10075;
                *(_WORD *)&v329[4] = 2048;
                *(_QWORD *)&v329[6] = v10;
                v330 = 1024;
                v331 = v68;
                v104 = v106;
                v105 = "%s:%d: %p ContentIndexUpdateState err:%d";
                goto LABEL_167;
              }
              if (*(unsigned __int8 *)(v31 + v78) != v310)
              {
                *(_BYTE *)(v31 + v78) = v310;
                v81 = si_write_index_state(v10, 0, 0);
                if (v81)
                  break;
              }
              if (v44 == ++v78)
                goto LABEL_130;
            }
            v68 = v81;
            v102 = *__error();
            v108 = _SILogForLogForCategory(11);
            if (!os_log_type_enabled(v108, OS_LOG_TYPE_ERROR))
              goto LABEL_168;
            *(_DWORD *)__dst = 136315906;
            *(_QWORD *)v328 = "_SIOpenIndexFilesWithState";
            *(_WORD *)&v328[8] = 1024;
            *(_DWORD *)v329 = 10082;
            *(_WORD *)&v329[4] = 2048;
            *(_QWORD *)&v329[6] = v10;
            v330 = 1024;
            v331 = v68;
            v104 = v108;
            v105 = "%s:%d: %p si_write_index_state err:%d";
LABEL_167:
            _os_log_error_impl(&dword_1B8270000, v104, OS_LOG_TYPE_ERROR, v105, (uint8_t *)__dst, 0x22u);
LABEL_168:
            *__error() = v102;
            goto LABEL_169;
          }
LABEL_130:
          if (!*(_DWORD *)(v10 + 1224))
            *(_DWORD *)(v10 + 1224) = 1;
          v306 = 0;
          v299 = 0u;
          v300 = 0u;
          v301 = 0u;
          v302 = 0u;
          v303 = 0u;
          v304 = 0u;
          v305 = 0;
          v298 = 0;
          v82 = *(_DWORD *)(v10 + 1456);
          v297[1] = 0x40000000;
          v297[2] = ___SIOpenIndexFilesWithState_block_invoke_724;
          v297[3] = &__block_descriptor_tmp_725;
          v297[4] = v10;
          v83 = (*(_DWORD *)(*(_QWORD *)(v10 + 1384) + 8) + *(_DWORD *)(*(_QWORD *)(v10 + 1392) + 8));
          v84 = MEMORY[0x1E0C809B0];
          v297[0] = MEMORY[0x1E0C809B0];
          _si_next_index_id((os_unfair_lock_s *)v10, v83, 0, 1);
          v296[0] = v84;
          v296[1] = 0x40000000;
          v296[2] = ___SIOpenIndexFilesWithState_block_invoke_2;
          v296[3] = &__block_descriptor_tmp_726;
          v296[4] = v10;
          v85 = *(_QWORD *)(v10 + 1392);
          v86 = *(_QWORD *)(v10 + 1384);
          v87 = *(_QWORD *)(v10 + 6592);
          v88 = *(int **)(v10 + 1184);
          if (v88)
            v88 = (int *)db_get_vector_store(v88);
          v24 = ContentIndexOpenBulk((uint64_t)v281, (uint64_t)&v299, v85, v86, v278 | 2u, v87, (uint64_t)&v298, (uint64_t)&v306, (uint64_t)v88, (uint64_t)v297, v296);
          if ((v24 & 0x80000000) == 0)
          {
            v163 = v304;
            *(_OWORD *)(a8 + 64) = v303;
            *(_OWORD *)(a8 + 80) = v163;
            *(_QWORD *)(a8 + 96) = v305;
            v164 = v300;
            *(_OWORD *)a8 = v299;
            *(_OWORD *)(a8 + 16) = v164;
            v165 = v302;
            *(_OWORD *)(a8 + 32) = v301;
            *(_OWORD *)(a8 + 48) = v165;
            *a7 = v306;
            *v276 = v298;
            v166 = *__error();
            v167 = _SILogForLogForCategory(11);
            v168 = 2 * (dword_1EF19FCB8 < 4);
            if (os_log_type_enabled(v167, v168))
            {
              v169 = *(_QWORD *)(v10 + 2408);
              *(_DWORD *)__dst = 134218240;
              *(_QWORD *)v328 = v10;
              *(_WORD *)&v328[8] = 2048;
              *(_QWORD *)v329 = v169;
              _os_log_impl(&dword_1B8270000, v167, v168, "opened SIRef:%p from fast flush with recovery time %llu", (uint8_t *)__dst, 0x16u);
            }
            v170 = 0;
            v171 = v288;
            v172 = v10;
            v173 = MEMORY[0x1E0C809B0];
            goto LABEL_330;
          }
          *(_DWORD *)(v10 + 1456) = v82;
          v89 = *__error();
          if (v89)
            v68 = v89;
          else
            v68 = -1;
          v90 = *__error();
          v91 = _SILogForLogForCategory(11);
          if (os_log_type_enabled(v91, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)__dst = 136315906;
            *(_QWORD *)v328 = "_SIOpenIndexFilesWithState";
            *(_WORD *)&v328[8] = 1024;
            *(_DWORD *)v329 = 10118;
            *(_WORD *)&v329[4] = 2048;
            *(_QWORD *)&v329[6] = v10;
            v330 = 1024;
            v331 = v24;
            _os_log_error_impl(&dword_1B8270000, v91, OS_LOG_TYPE_ERROR, "%s:%d: %p ContentIndexOpenBulk err:%d", (uint8_t *)__dst, 0x22u);
          }
          *__error() = v90;
          if (v24 == -2)
            goto LABEL_26;
LABEL_170:
          v109 = **(_DWORD **)(v10 + 6592);
          v110 = *__error();
          v111 = _SILogForLogForCategory(11);
          v112 = v111;
          if (v109)
          {
            v152 = 2 * (dword_1EF19FCB8 < 4);
            if (os_log_type_enabled(v111, v152))
            {
              *(_DWORD *)__dst = 134218240;
              *(_QWORD *)v328 = v10;
              *(_WORD *)&v328[8] = 1024;
              *(_DWORD *)v329 = v68;
              _os_log_impl(&dword_1B8270000, v112, v152, "%p open from fast flush canceled:%d", (uint8_t *)__dst, 0x12u);
            }
            *__error() = v110;
            if (v68)
              goto LABEL_26;
            goto LABEL_37;
          }
          v113 = dword_1EF19FCB8 < 3;
          if (os_log_type_enabled(v111, (os_log_type_t)(dword_1EF19FCB8 < 3)))
          {
            *(_DWORD *)__dst = 134218240;
            *(_QWORD *)v328 = v10;
            *(_WORD *)&v328[8] = 1024;
            *(_DWORD *)v329 = v68;
            _os_log_impl(&dword_1B8270000, v112, (os_log_type_t)v113, "*warn* %p open from fast flush failed:%d", (uint8_t *)__dst, 0x12u);
          }
          *__error() = v110;
          v114 = *(int **)(v10 + 1184);
          if (v114)
          {
            db_release_datastore_no_sync(v114);
            *(_QWORD *)(v10 + 1184) = 0;
          }
          v115 = *(_QWORD *)(v10 + 6624);
          if (v115)
          {
            freeReverseDirStore(v115);
            *(_QWORD *)(v10 + 6624) = 0;
          }
          if (*(_DWORD *)(*(_QWORD *)(v10 + 1392) + 8))
          {
            v258 = __si_assert_copy_extra_521(-1);
            v256 = v258;
            v259 = "";
            if (v258)
              v259 = v258;
            __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 10152, "newIndex->syncSet->indexCount==0", v259);
            goto LABEL_391;
          }
          if (*(_DWORD *)(*(_QWORD *)(v10 + 1384) + 8))
          {
            v260 = __si_assert_copy_extra_521(-1);
            v256 = v260;
            v261 = "";
            if (v260)
              v261 = v260;
            __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 10153, "newIndex->liveSet->indexCount==0", v261);
            goto LABEL_391;
          }
          *(_BYTE *)(v10 + 2481) = 1;
          if (*(_BYTE *)(v10 + 2482) != 4)
            *(_BYTE *)(v10 + 2482) = 1;
          if (v277 && *(_BYTE *)(v10 + 2483) != 4)
            *(_BYTE *)(v10 + 2483) = 1;
          v116 = *(unsigned __int16 *)(v10 + 2484) + *(unsigned __int16 *)(v10 + 2486);
          if ((_DWORD)v116)
          {
            v117 = (_BYTE *)(v10 + 2488);
            do
            {
              if (*v117 != 4)
                *v117 = 1;
              ++v117;
              --v116;
            }
            while (v116);
          }
          v118 = si_write_index_state(v10, 0, 0);
          v29 = 1;
          if (v118)
          {
            v153 = v118;
            v154 = *__error();
            v155 = _SILogForLogForCategory(11);
            if (os_log_type_enabled(v155, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)__dst = 136315906;
              *(_QWORD *)v328 = "_SIOpenIndexFilesWithState";
              *(_WORD *)&v328[8] = 1024;
              *(_DWORD *)v329 = 10173;
              *(_WORD *)&v329[4] = 2048;
              *(_QWORD *)&v329[6] = v10;
              v330 = 1024;
              v331 = v153;
              _os_log_error_impl(&dword_1B8270000, v155, OS_LOG_TYPE_ERROR, "%s:%d: %p si_write_index_state err:%d", (uint8_t *)__dst, 0x22u);
            }
            *__error() = v154;
            goto LABEL_26;
          }
          continue;
        }
        v51 = *__error();
        if (v51)
          v39 = v51;
        else
          v39 = -1;
LABEL_82:
        v53 = *__error();
        v54 = _SILogForLogForCategory(7);
        if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315906;
          v323 = "db2_update_datastore_state";
          v324 = 1024;
          LODWORD(v325) = 6889;
          WORD2(v325) = 1024;
          *(_DWORD *)((char *)&v325 + 6) = v32;
          WORD5(v325) = 1024;
          HIDWORD(v325) = v39;
          _os_log_error_impl(&dword_1B8270000, v54, OS_LOG_TYPE_ERROR, "%s:%d: update state (%d) failed err:%d", buf, 0x1Eu);
        }
        *__error() = v53;
        if (!v39)
        {
          v43 = 0;
          v44 = v290;
          v29 = v35;
          goto LABEL_86;
        }
        v159 = *__error();
        v160 = _SILogForLogForCategory(11);
        if (os_log_type_enabled(v160, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)__dst = 136315906;
          *(_QWORD *)v328 = "_SIOpenIndexFilesWithState";
          *(_WORD *)&v328[8] = 1024;
          *(_DWORD *)v329 = 9939;
          *(_WORD *)&v329[4] = 2048;
          *(_QWORD *)&v329[6] = v10;
          v330 = 1024;
          v331 = v39;
          _os_log_error_impl(&dword_1B8270000, v160, OS_LOG_TYPE_ERROR, "%s:%d: %p db_update_datastore_state err:%d", (uint8_t *)__dst, 0x22u);
        }
        *__error() = v159;
LABEL_25:
        v24 = -1;
LABEL_26:
        v25 = *(int **)(v10 + 1184);
        if (v25)
        {
          if (v24 != -2 && !**(_DWORD **)(v10 + 6592) && !*v289)
            *a6 = 1;
          db_release_datastore_no_sync(v25);
          *(_QWORD *)(v10 + 1184) = 0;
        }
LABEL_37:
        if (cf)
        {
          CFRelease(cf);
          cf = 0;
        }
        v311 = 0uLL;
        free(v313);
        if (v24 < 0)
          return 0xFFFFFFFFLL;
        else
          return v24;
      case 4:
        v35 = v29;
        v42 = v33;
        goto LABEL_58;
      default:
        v43 = 0;
        goto LABEL_64;
    }
  }
}

uint64_t handleDirStoreOverlay(uint64_t a1)
{
  char *v2;
  char *v3;
  int v4;
  int v5;
  __CFSet *i;
  unsigned int vint32_566;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t *v16;
  size_t v17;
  uint64_t v18;
  size_t v19;
  uint64_t v20;
  uint64_t v21;
  char v22;
  BOOL v23;
  int v24;
  char *v25;
  size_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _BYTE *v30;
  size_t v31;
  uint64_t v32;
  size_t v33;
  uint64_t v34;
  uint64_t v35;
  char v36;
  char *v37;
  size_t v38;
  size_t v39;
  unint64_t v40;
  int *v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t v44;
  unint64_t v45;
  unsigned int v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  _BYTE v52[12];
  unsigned int v53;
  size_t v54;
  size_t v55;
  size_t v56;
  size_t v57;
  char *v58;
  char *p_dst;
  off_t v60;
  char *v61;
  unint64_t v62;
  _BYTE *v63;
  stat v64;
  uint64_t v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  char __dst;
  uint64_t v71;

  v71 = *MEMORY[0x1E0C80C00];
  v2 = (char *)fd_create_protected(*(_DWORD *)(a1 + 32), "dirStore.overlay", 0, 0);
  if (!v2)
    return 0;
  v3 = v2;
  v68 = 0u;
  v69 = 0u;
  v66 = 0u;
  v67 = 0u;
  v65 = 0;
  v4 = _fd_acquire_fd((uint64_t)v2, &v65);
  memset(&v64, 0, sizeof(v64));
  v5 = fstat(v4, &v64);
  if (v5 == -1 || !v64.st_size)
  {
    if (v5 == -1)
      v11 = 0xFFFFFFFFLL;
    else
      v11 = 0;
    _fd_release_fd(v3, v4, 0, v65);
    goto LABEL_89;
  }
  _fd_release_fd(v3, v4, 0, v65);
  if (!store_stream_init((uint64_t)&v66, v3, 0))
  {
    v11 = 0xFFFFFFFFLL;
LABEL_89:
    fd_release(v3);
    return v11;
  }
  for (i = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0);
        ;
        CFSetAddValue(i, (const void *)*(int *)(*(_QWORD *)(*(_QWORD *)v8 + 8 * (vint32_566 - 1)) + 48)))
  {
    vint32_566 = store_stream_read_vint32_566((uint64_t)&v66);
    if (!vint32_566)
      break;
    v8 = *(_QWORD *)(a1 + 1392);
    if (vint32_566 > *(_DWORD *)(v8 + 8))
    {
LABEL_91:
      v11 = 0xFFFFFFFFLL;
      goto LABEL_92;
    }
  }
  while (1)
  {
    v10 = store_stream_read_vint32_566((uint64_t)&v66);
    if (!v10)
      break;
    v9 = *(_QWORD *)(a1 + 1384);
    if (v10 > *(_DWORD *)(v9 + 8))
      goto LABEL_91;
    CFSetAddValue(i, (const void *)*(int *)(*(_QWORD *)(*(_QWORD *)v9 + 8 * (v10 - 1)) + 48));
  }
  v11 = v67;
  if (!(_DWORD)v67)
  {
    v58 = v3;
    v12 = 0;
    while (1)
    {
      v13 = store_stream_read_vint32_566((uint64_t)&v66);
      v14 = v13;
      if (!(_DWORD)v13 || (int)v13 > 512)
        break;
      MEMORY[0x1E0C80A78](v13);
      v16 = (uint64_t *)&v52[-v15];
      bzero(&v52[-v15], v17);
      v63 = v52;
      if (v14 >= 1)
      {
        v18 = 0;
        v19 = *((_QWORD *)&v68 + 1);
        do
        {
          if ((unint64_t)v68 - v19 < 0xB)
          {
            v24 = 0;
            v21 = 0;
            __dst = 0;
            v61 = (char *)v69;
            while (1)
            {
              if (v19 + 1 > (unint64_t)v68)
              {
                v57 = v68;
                v62 = 0;
                LODWORD(v55) = v66;
                p_dst = &__dst;
                v60 = *((_QWORD *)&v67 + 1);
                v26 = 1;
                while (1)
                {
                  v56 = v57 - v19;
                  if (v57 != v19)
                    memcpy(p_dst, &v61[v19], v56);
                  v27 = prot_pread(v55, v61, v57, v60);
                  if (v27 == -1)
                  {
                    v19 = v57;
                    *(_QWORD *)&v68 = v57;
                    *((_QWORD *)&v68 + 1) = v57;
                    *((_QWORD *)&v67 + 1) = v60;
                    v26 = 0;
                    LODWORD(v67) = *__error();
                    goto LABEL_30;
                  }
                  v60 += v27;
                  v19 = 0;
                  if (!v27)
                    break;
                  p_dst += v56;
                  v26 -= v56;
                  v62 += v56;
                  v57 = v27;
                  if (v26 <= v27)
                  {
                    v19 = 0;
                    *((_QWORD *)&v67 + 1) = v60;
                    *(_QWORD *)&v68 = v27;
                    v25 = p_dst;
                    goto LABEL_29;
                  }
                }
                v68 = 0uLL;
                *((_QWORD *)&v67 + 1) = v60;
                v26 = v56;
              }
              else
              {
                v62 = 0;
                v25 = &__dst;
                v26 = 1;
LABEL_29:
                memcpy(v25, &v61[v19], v26);
                v19 += v26;
                *((_QWORD *)&v68 + 1) = v19;
              }
LABEL_30:
              if (v26 + v62 != 1)
                break;
              v21 |= (unint64_t)(__dst & 0x7F) << v24;
              v24 += 7;
              if ((__dst & 0x80) == 0)
                goto LABEL_24;
            }
            v21 = 0;
          }
          else
          {
            v20 = 0;
            v21 = 0;
            do
            {
              v22 = *(_BYTE *)(v69 + v19++);
              v21 |= (unint64_t)(v22 & 0x7F) << v20;
              if ((v22 & 0x80) == 0)
                break;
              v23 = v20 == 63;
              v20 += 7;
            }
            while (!v23);
            *((_QWORD *)&v68 + 1) = v19;
          }
LABEL_24:
          v16[v18++] = v21;
        }
        while (v18 != v14);
      }
      v28 = store_stream_read_vint32_566((uint64_t)&v66);
      v12 = v28;
      if ((int)v28 >= 513)
        break;
      MEMORY[0x1E0C80A78](v28);
      v30 = &v52[-v29];
      bzero(&v52[-v29], v31);
      if (v12 >= 1)
      {
        v32 = 0;
        v33 = *((_QWORD *)&v68 + 1);
        do
        {
          if ((unint64_t)v68 - v33 < 0xB)
          {
            v60 = 0;
            v35 = 0;
            __dst = 0;
            p_dst = (char *)v69;
            while (1)
            {
              if (v33 + 1 > (unint64_t)v68)
              {
                v55 = v68;
                v61 = 0;
                v53 = v66;
                v56 = (size_t)&__dst;
                v57 = *((_QWORD *)&v67 + 1);
                v62 = 1;
                while (1)
                {
                  v54 = v55 - v33;
                  if (v55 != v33)
                    memcpy((void *)v56, &p_dst[v33], v54);
                  v40 = prot_pread(v53, p_dst, v55, v57);
                  if (v40 == -1)
                  {
                    v33 = v55;
                    *(_QWORD *)&v68 = v55;
                    *((_QWORD *)&v68 + 1) = v55;
                    *((_QWORD *)&v67 + 1) = v57;
                    v41 = __error();
                    v39 = 0;
                    LODWORD(v67) = *v41;
                    goto LABEL_59;
                  }
                  v57 += v40;
                  v33 = 0;
                  if (!v40)
                    break;
                  v56 += v54;
                  v61 += v54;
                  v55 = v40;
                  v62 -= v54;
                  if (v62 <= v40)
                  {
                    v33 = 0;
                    *((_QWORD *)&v67 + 1) = v57;
                    *(_QWORD *)&v68 = v40;
                    v37 = (char *)v56;
                    v38 = v62;
                    goto LABEL_58;
                  }
                }
                v68 = 0uLL;
                *((_QWORD *)&v67 + 1) = v57;
                v39 = v54;
              }
              else
              {
                v61 = 0;
                v37 = &__dst;
                v38 = 1;
LABEL_58:
                v62 = v38;
                memcpy(v37, &p_dst[v33], v38);
                v39 = v62;
                v33 += v62;
                *((_QWORD *)&v68 + 1) = v33;
              }
LABEL_59:
              if (&v61[v39] != (char *)1)
                break;
              v35 |= (unint64_t)(__dst & 0x7F) << v60;
              v60 = (v60 + 7);
              if ((__dst & 0x80) == 0)
                goto LABEL_53;
            }
            v35 = 0;
          }
          else
          {
            v34 = 0;
            v35 = 0;
            do
            {
              v36 = *(_BYTE *)(v69 + v33++);
              v35 |= (unint64_t)(v36 & 0x7F) << v34;
              if ((v36 & 0x80) == 0)
                break;
              v23 = v34 == 63;
              v34 += 7;
            }
            while (!v23);
            *((_QWORD *)&v68 + 1) = v33;
          }
LABEL_53:
          *(_QWORD *)&v30[8 * v32++] = v35;
        }
        while (v32 != v12);
      }
      v42 = *(_QWORD *)(a1 + 1392);
      if (*(_DWORD *)(v42 + 8))
      {
        v43 = 0;
        do
        {
          if (CFSetContainsValue(i, (const void *)*(int *)(*(_QWORD *)(*(_QWORD *)v42 + 8 * v43) + 48)))
            _CIMoveDirectory(*(_QWORD *)(**(_QWORD **)(a1 + 1392) + 8 * v43), v14, v16, v12, (uint64_t)v30);
          ++v43;
          v42 = *(_QWORD *)(a1 + 1392);
        }
        while (v43 < *(unsigned int *)(v42 + 8));
      }
      v44 = *(_QWORD *)(a1 + 1384);
      if (*(_DWORD *)(v44 + 8))
      {
        v45 = 0;
        do
        {
          if (CFSetContainsValue(i, (const void *)*(int *)(*(_QWORD *)(*(_QWORD *)v44 + 8 * v45) + 48)))
            _CIMoveDirectory(*(_QWORD *)(**(_QWORD **)(a1 + 1384) + 8 * v45), v14, v16, v12, (uint64_t)v30);
          ++v45;
          v44 = *(_QWORD *)(a1 + 1384);
        }
        while (v45 < *(unsigned int *)(v44 + 8));
      }
    }
    v47 = v67;
    store_stream_destroy((uint64_t)&v66);
    if (v14 > 512 || v12 > 512 || v47)
    {
      v48 = *(_QWORD *)(a1 + 1392);
      if (*(_DWORD *)(v48 + 8))
      {
        v49 = 0;
        do
        {
          if (CFSetContainsValue(i, (const void *)*(int *)(*(_QWORD *)(*(_QWORD *)v48 + 8 * v49) + 48)))
            _CIMakeInvalid(*(_QWORD *)(**(_QWORD **)(a1 + 1392) + 8 * v49));
          ++v49;
          v48 = *(_QWORD *)(a1 + 1392);
        }
        while (v49 < *(unsigned int *)(v48 + 8));
      }
      v50 = *(_QWORD *)(a1 + 1384);
      v3 = v58;
      if (*(_DWORD *)(v50 + 8))
      {
        v51 = 0;
        do
        {
          if (CFSetContainsValue(i, (const void *)*(int *)(*(_QWORD *)(*(_QWORD *)v50 + 8 * v51) + 48)))
            _CIMakeInvalid(*(_QWORD *)(**(_QWORD **)(a1 + 1384) + 8 * v51));
          ++v51;
          v50 = *(_QWORD *)(a1 + 1384);
        }
        while (v51 < *(unsigned int *)(v50 + 8));
      }
      if (v47)
        v11 = v47;
      else
        v11 = 0xFFFFFFFFLL;
    }
    else
    {
      v11 = 0;
      v3 = v58;
    }
  }
LABEL_92:
  fd_release(v3);
  if (i)
    CFRelease(i);
  return v11;
}

uint64_t handleIndexRepair(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  int v7;
  int *v8;
  _QWORD *v9;
  unsigned __int8 v10;
  void *v12;
  int *v13;
  _DWORD *v14;
  unsigned int v15;
  int v16;
  unint64_t v17;
  unsigned int v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  void (*v23)(_QWORD);
  _DWORD *v24;
  int v25;
  NSObject *v26;
  unsigned int v27;
  uint64_t v28;
  void *v29;
  uint64_t v30;
  int *v31;
  unsigned int v32;
  uint64_t v33;
  unsigned int v34;
  uint64_t v35;
  void (*v36)(_QWORD);
  const __CFNumber *v37;
  const __CFNumber *v38;
  tm *v39;
  int v40;
  NSObject *v41;
  os_log_type_t v42;
  const void *v43;
  uint64_t v44;
  int v45;
  int v46;
  uint64_t v47;
  char v48;
  int v49;
  int v50;
  NSObject *v51;
  int v52;
  char *v53;
  char *v54;
  const char *v55;
  time_t v56;
  unint64_t v57;
  unsigned int v58;
  unsigned int v59;
  unint64_t v60;
  char v61;
  _QWORD v62[2];
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  void *v67;
  int *v68;
  uint8_t buf[4];
  uint64_t v70;
  __int16 v71;
  _QWORD *v72;
  __int16 v73;
  uint64_t v74;
  __int16 v75;
  int v76;
  __int16 v77;
  uint64_t v78;
  _QWORD valuePtr[4];
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  uint64_t v94;

  v94 = *MEMORY[0x1E0C80C00];
  if (!*(_QWORD *)(a2 + 40) || !(*(_QWORD *)(a1 + 2408) | a3))
    return 0;
  v5 = *(_QWORD *)(a2 + 40);
  v6 = *(_QWORD *)(a1 + 2408);
  v62[0] = v6;
  v62[1] = a3;
  v63 = 0;
  v64 = v5;
  v65 = *(_QWORD *)(a2 + 136);
  v66 = 0;
  if (*(_BYTE *)(a1 + 2072))
  {
    v7 = *(_DWORD *)(a1 + 32);
    v8 = *(int **)(a1 + 1184);
    v9 = malloc_type_calloc(1uLL, 0x38uLL, 0x1060040EBC759B4uLL);
    if (fcntl(v7, 63) == 1)
      v10 = 2;
    else
      v10 = 0;
    *v9 = fd_create_protected(v7, "journalRepair.1", 536872450, v10);
    v9[1] = v8;
    *((_DWORD *)v9 + 4) = db_get_id_for_field(v8, "_kMDItemGroupId");
    *((_DWORD *)v9 + 5) = db_get_id_for_field(v8, "_kMDItemBundleID");
    *((_DWORD *)v9 + 6) = db_get_id_for_field(v8, "_kMDItemExternalID");
    v6 = *(_QWORD *)(a1 + 2408);
    v12 = v9;
  }
  else
  {
    v12 = 0;
  }
  v13 = *(int **)(a1 + 1184);
  v67 = v12;
  v68 = v13;
  if (v6)
  {
    if (a3)
    {
      v14 = db_clear_docids_setup(v13);
      v61 = 0;
      do
      {
        v15 = __ldxr(exceptionSequenceNum);
        v16 = v15 + 1;
      }
      while (__stxr(v15 + 1, exceptionSequenceNum));
      v17 = setThreadIdAndInfo(-1, sAssertExceptionCallbacks, 0, 0, v16);
      LODWORD(v56) = HIDWORD(v17);
      *(_DWORD *)buf = v17;
      v60 = __PAIR64__(v18, v19);
      v20 = *(_QWORD *)&threadData[18 * v17 + 2];
      v21 = v20 + 320 * HIDWORD(v17);
      v22 = *(_DWORD *)(v21 + 312);
      v23 = *(void (**)(_QWORD))(v21 + 224);
      if (v23)
        v23(*(_QWORD *)(v20 + 320 * HIDWORD(v17) + 288));
      v59 = *(_DWORD *)buf;
      v58 = v56;
      v57 = v60;
      if (_setjmp((int *)v21))
      {
        v24 = (_DWORD *)(v21 + 312);
        v25 = *__error();
        v26 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        {
          LODWORD(valuePtr[0]) = 136315394;
          *(_QWORD *)((char *)valuePtr + 4) = "handleIndexRepair";
          WORD2(valuePtr[1]) = 1024;
          *(_DWORD *)((char *)&valuePtr[1] + 6) = 10557;
          _os_log_error_impl(&dword_1B8270000, v26, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", (uint8_t *)valuePtr, 0x12u);
        }
        *__error() = v25;
        *v24 = v22;
        CIOnThreadCleanUpReset(v57);
        dropThreadId(v59, 1, v16);
        CICleanUpReset(v59, HIDWORD(v57));
        v27 = 0;
      }
      else
      {
        db_set_host(*(int **)(a1 + 1184), a1);
        v31 = *(int **)(a1 + 1184);
        if (*v31 != 1685287992)
        {
          v50 = *__error();
          v51 = _SILogForLogForCategory(4);
          if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
          {
            v52 = *v31;
            LODWORD(valuePtr[0]) = 136315650;
            *(_QWORD *)((char *)valuePtr + 4) = "db_clear_docids";
            WORD2(valuePtr[1]) = 1024;
            *(_DWORD *)((char *)&valuePtr[1] + 6) = 414;
            WORD1(valuePtr[2]) = 1024;
            HIDWORD(valuePtr[2]) = v52;
            _os_log_error_impl(&dword_1B8270000, v51, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", (uint8_t *)valuePtr, 0x18u);
          }
          *__error() = v50;
          v53 = __si_assert_copy_extra_268();
          v54 = v53;
          if (v53)
            v55 = v53;
          else
            v55 = "";
          __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 414, v55);
          free(v54);
          MEMORY[0xBAD] = -559038737;
          abort();
        }
        v32 = db2_clear_docids(*(_QWORD *)(a1 + 1184), v14, *(_DWORD **)(a1 + 6592), 1, (unsigned int (*)(_DWORD *, uint64_t))clear_docid_match_new, (uint64_t)v62);
        v61 = 1;
        v33 = *(_QWORD *)&threadData[18 * v59 + 2];
        v34 = v58;
        v35 = v33 + 320 * v58;
        *(_DWORD *)(v35 + 312) = v22;
        v36 = *(void (**)(_QWORD))(v35 + 232);
        if (v36)
          v36(*(_QWORD *)(v33 + 320 * v34 + 288));
        dropThreadId(v59, 0, v16);
        v27 = v32;
      }
      if (v61)
        v30 = v27;
      else
        v30 = 0xFFFFFFFFLL;
      db_clear_docids_cleanup(*(int **)(a1 + 1184), v14);
    }
    else
    {
      v30 = 0;
    }
    v37 = (const __CFNumber *)SICopyProperty(a1, CFSTR("database.recoverscantime"));
    if (v37)
    {
      v38 = v37;
      valuePtr[0] = 0;
      if (CFNumberGetValue(v37, kCFNumberSInt64Type, valuePtr) && valuePtr[0] > *(_QWORD *)(a1 + 2408))
        *(_QWORD *)(a1 + 2408) = valuePtr[0];
      CFRelease(v38);
    }
    v92 = 0u;
    v93 = 0u;
    v90 = 0u;
    v91 = 0u;
    v88 = 0u;
    v89 = 0u;
    v86 = 0u;
    v87 = 0u;
    v84 = 0u;
    v85 = 0u;
    v82 = 0u;
    v83 = 0u;
    v80 = 0u;
    v81 = 0u;
    memset(valuePtr, 0, sizeof(valuePtr));
    v56 = *(_QWORD *)(a1 + 2408);
    v39 = localtime(&v56);
    strftime((char *)valuePtr, 0x100uLL, "%F %T", v39);
    v40 = *__error();
    v41 = _SILogForLogForCategory(11);
    v42 = 2 * (dword_1EF19FCB8 < 4);
    if (os_log_type_enabled(v41, v42))
    {
      *(_DWORD *)buf = 134219010;
      v70 = a1;
      v71 = 2080;
      v72 = valuePtr;
      v73 = 2048;
      v74 = a3;
      v75 = 1024;
      v76 = HIDWORD(v66);
      v77 = 2048;
      v78 = v63;
      _os_log_impl(&dword_1B8270000, v41, v42, "%p repair - catchup scan time stamp: %s, base: %ld, repair count: %d, remair max: %ld", buf, 0x30u);
    }
    *__error() = v40;
    v29 = v67;
    v28 = v30;
    if (!v67)
      goto LABEL_44;
    goto LABEL_39;
  }
  v28 = -*(char *)(a1 + 2072);
  v29 = v12;
  if (v12)
  {
LABEL_39:
    *(_QWORD *)(a1 + 6952) = *(_QWORD *)v29;
    if (*((_QWORD *)v29 + 5))
    {
      _MDPlistContainerEndArray();
      _MDPlistContainerEndArray();
      _MDPlistContainerEndContainer();
      mobile_journal_plist(*(_DWORD **)v29, 0, 0, *((_QWORD *)v29 + 5), 0, 0);
      CFRelease(*((CFTypeRef *)v29 + 5));
    }
    v43 = (const void *)*((_QWORD *)v29 + 4);
    if (v43)
      CFRelease(v43);
    free(v29);
  }
LABEL_44:
  if (!(_DWORD)v28)
  {
    v44 = *(_QWORD *)(a1 + 1384);
    if (v44)
    {
      v45 = HIDWORD(v66);
      v46 = *(_DWORD *)(v44 + 8);
      if (!v46
        || (v47 = *(_QWORD *)(*(_QWORD *)v44 + 8 * (v46 - 1)),
            v48 = atomic_load((unsigned int *)(v47 + 28)),
            (v48 & 3) != 0)
        || *(_BYTE *)(v47 + 15163))
      {
        new_live_index(a1, 0, v63 + 1);
        v44 = *(_QWORD *)(a1 + 1384);
      }
      if (v45 && v44)
      {
        v49 = *(_DWORD *)(v44 + 8);
        if (v49)
          ContentIndexSetEmergency(*(int **)(*(_QWORD *)v44 + 8 * (v49 - 1)), 1);
      }
    }
  }
  return v28;
}

void si_handle_tmp_files(uint64_t a1, int a2, int a3, __CFArray **a4, __CFArray **a5)
{
  int v10;
  DIR *v11;
  DIR *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  dirent *v17;
  dirent *v18;
  const std::__fs::filesystem::path *d_name;
  int d_type;
  BOOL v21;
  int v22;
  uint64_t d_namlen;
  int v24;
  int v25;
  NSObject *v26;
  os_log_type_t v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  char *i;
  uint64_t v36;
  const void *v37;
  __CFArray *Mutable;
  uint64_t v39;
  uint64_t v40;
  NSObject *v41;
  os_log_type_t v42;
  NSObject *v43;
  std::error_code *v44;
  int v45;
  int v46;
  NSObject *v47;
  int v48;
  unint64_t v49;
  int64_t v50;
  int64_t v51;
  int v52;
  int v53;
  int v54;
  DIR *v55;
  DIR *v56;
  char v57;
  dirent *v58;
  const char *v59;
  int v60;
  BOOL v61;
  NSObject *v62;
  os_log_type_t v63;
  BOOL v64;
  int v65;
  size_t v66;
  int v67;
  size_t v68;
  const __CFAllocator *v69;
  const __CFURL *v70;
  const __CFURL *v71;
  const __CFURL *PathComponent;
  const __CFURL *v73;
  const __CFString *v74;
  const __CFString *v75;
  xpc_object_t v76;
  xpc_object_t v77;
  int v78;
  NSObject *v79;
  int v80;
  NSObject *v81;
  char *v82;
  char *v83;
  const char *v84;
  uint64_t v85;
  int v86;
  int v87;
  int v88;
  const __CFAllocator *allocator;
  NSObject *allocatora;
  int64_t v91;
  int v92;
  unint64_t v93;
  int64_t v94;
  int64_t v95;
  int64_t v96;
  __CFArray **v97;
  unsigned int v98;
  uint8_t v99[4];
  const char *v100;
  __int16 v101;
  _BYTE v102[10];
  __int16 v103;
  const std::__fs::filesystem::path *v104;
  __int16 v105;
  stat *v106;
  stat buf[7];
  uint64_t v108;

  v108 = *MEMORY[0x1E0C80C00];
  if (_os_feature_enabled_impl())
    v10 = _os_feature_enabled_impl();
  else
    v10 = 1;
  v98 = 0;
  if (fd_setDir(a1, (int *)&v98))
  {
    v11 = opendir(".");
    if (v11)
    {
      v12 = v11;
      v88 = a2;
      v96 = 0;
      v97 = a5;
      v91 = 0;
      v93 = 0;
      v94 = 0;
      v13 = 0;
      v14 = 0;
      allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      while (1)
      {
        while (1)
        {
          while (1)
          {
            v15 = v14;
            v16 = v13;
            v17 = readdir(v12);
            if (!v17)
            {
              closedir(v12);
              v50 = v91;
              v49 = v93;
              v51 = v94;
              goto LABEL_62;
            }
            v18 = v17;
            d_name = (const std::__fs::filesystem::path *)v17->d_name;
            v13 = v16;
            v14 = v15;
            if (v17->d_name[0] != 46)
            {
              d_type = v17->d_type;
              v21 = d_type == 4 || d_type == 10;
              v13 = v16;
              v14 = v15;
              if (!v21)
                break;
            }
          }
          if (strncmp(v17->d_name, "tmp.", 4uLL))
            break;
          v28 = strncmp((const char *)d_name, "tmp.SnowLeopard", 0xFuLL);
          v13 = v16;
          v14 = v15;
          if (v28)
          {
            v29 = strncmp((const char *)d_name, "tmp.Cab", 7uLL);
            v13 = v16;
            v14 = v15;
            if (v29)
            {
              v30 = strncmp((const char *)d_name, "tmp.Glow", 8uLL);
              v13 = v16;
              v14 = v15;
              if (v30)
              {
                v31 = strncmp((const char *)d_name, "tmp.Star", 8uLL);
                v13 = v16;
                v14 = v15;
                if (v31)
                {
                  v32 = strncmp((const char *)d_name, "tmp.Lion", 8uLL);
                  v13 = v16;
                  v14 = v15;
                  if (v32)
                  {
                    v33 = strncmp((const char *)d_name, "tmp.spotlight", 0xDuLL);
                    v13 = v16;
                    v14 = v15;
                    if (v33)
                    {
                      v34 = strncmp((const char *)d_name, "tmp.store.recovery", 0x12uLL);
                      v13 = v16;
                      v14 = v15;
                      if (v34)
                      {
                        if (v88 && !strncmp((const char *)d_name, "tmp.journals.", 0xDuLL))
                        {
                          for (i = &v18->d_name[13]; *i; ++i)
                          {
                            if (*i == 46)
                            {
                              if (!i[1])
                                break;
                              bzero(buf, 0x400uLL);
                              __strcpy_chk();
                              v40 = i - (char *)d_name - 4;
                              if (*((_BYTE *)&buf[0].st_dev + v40) != 46)
                              {
                                v82 = __si_assert_copy_extra_521(-1);
                                v83 = v82;
                                v84 = "";
                                if (v82)
                                  v84 = v82;
                                __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 9766, "new_path[ptr-direntry->d_name-4]=='.'", v84);
                                free(v83);
                                if (__valid_fs(-1))
                                  v85 = 2989;
                                else
                                  v85 = 3072;
                                *(_DWORD *)v85 = -559038737;
                                abort();
                              }
                              *((_BYTE *)&buf[0].st_dev + v40) = 47;
                              v87 = *__error();
                              v41 = _SILogForLogForCategory(0);
                              v42 = 2 * (gSILogLevels[0] < 4);
                              v43 = v41;
                              if (os_log_type_enabled(v41, v42))
                              {
                                *(_DWORD *)v99 = 136315394;
                                v100 = (const char *)d_name;
                                v101 = 2080;
                                *(_QWORD *)v102 = buf;
                                _os_log_impl(&dword_1B8270000, v43, v42, "renaming: %s to %s", v99, 0x16u);
                              }
                              *__error() = v87;
                              rename(d_name, (const std::__fs::filesystem::path *)buf, v44);
                              if (v45)
                              {
                                v46 = *__error();
                                v47 = _SILogForLogForCategory(0);
                                if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
                                {
                                  v48 = *__error();
                                  *(_DWORD *)v99 = 136316162;
                                  v100 = "si_handle_tmp_files";
                                  v101 = 1024;
                                  *(_DWORD *)v102 = 9772;
                                  *(_WORD *)&v102[4] = 1024;
                                  *(_DWORD *)&v102[6] = v48;
                                  v103 = 2080;
                                  v104 = d_name;
                                  v105 = 2080;
                                  v106 = buf;
                                  _os_log_error_impl(&dword_1B8270000, v47, OS_LOG_TYPE_ERROR, "%s:%d: move error:%d, %s to %s", v99, 0x2Cu);
                                }
                                *__error() = v46;
                              }
                              goto LABEL_49;
                            }
                          }
                        }
LABEL_21:
                        v86 = v10;
                        v25 = *__error();
                        v26 = _SILogForLogForCategory(10);
                        v27 = 2 * (dword_1EF19FCB4 < 4);
                        if (os_log_type_enabled(v26, v27))
                        {
                          buf[0].st_dev = 136315138;
                          *(_QWORD *)&buf[0].st_mode = d_name;
                          _os_log_impl(&dword_1B8270000, v26, v27, "unlink (%s)", (uint8_t *)buf, 0xCu);
                        }
                        *__error() = v25;
                        unlink((const char *)d_name);
                        v13 = v16;
                        v14 = v15;
                        v10 = v86;
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (a4 && !strncmp((const char *)d_name, "journalAttr.", 0xCuLL))
          break;
        if (v97 && !strncmp((const char *)d_name, "deferAttr.", 0xAuLL))
        {
          *(_QWORD *)&buf[0].st_dev = 0;
          v39 = strtoll(&v18->d_name[10], (char **)buf, 0);
          if (v39 < 2)
            goto LABEL_49;
          v37 = (const void *)v39;
          Mutable = *v97;
          if (!*v97)
          {
            Mutable = CFArrayCreateMutable(allocator, 0, 0);
            *v97 = Mutable;
          }
          goto LABEL_48;
        }
        v22 = strncmp((const char *)d_name, "skg_", 4uLL);
        d_namlen = v18->d_namlen;
        if (v22)
        {
          v13 = v16;
          v14 = v15;
          if (d_namlen >= 0xD)
          {
            v24 = strncmp((const char *)d_name + d_namlen - 13, "topK.mdplistc", 0xDuLL);
            v13 = v16;
            v14 = v15;
            if (!v24)
              goto LABEL_21;
          }
        }
        else
        {
          v13 = 1;
          v14 = 1;
          if ((_DWORD)d_namlen != 4)
          {
            memset(buf, 0, 144);
            if (!stat((const char *)d_name, buf))
            {
              if (!strncmp((const char *)d_name, "skg_deleteAttr.", 0xFuLL))
              {
                v93 += buf[0].st_size;
                ++v94;
              }
              else if (!strncmp((const char *)d_name, "skg_knowledgeEntry.", 0x13uLL))
              {
                v91 += buf[0].st_size;
                ++v96;
              }
            }
LABEL_49:
            v13 = v16;
            v14 = v15;
          }
        }
      }
      *(_QWORD *)&buf[0].st_dev = 0;
      v36 = strtoll(&v18->d_name[12], (char **)buf, 0);
      if (v36 < 2)
        goto LABEL_49;
      v37 = (const void *)v36;
      Mutable = *a4;
      if (!*a4)
      {
        Mutable = CFArrayCreateMutable(allocator, 0, 0);
        *a4 = Mutable;
      }
LABEL_48:
      CFArrayAppendValue(Mutable, v37);
      goto LABEL_49;
    }
    v49 = 0;
    v50 = 0;
    v51 = 0;
    v96 = 0;
    LOBYTE(v15) = 0;
LABEL_62:
    v53 = v98;
    MEMORY[0x1BCCB1484](v98);
    if ((v53 & 0x80000000) == 0)
      close(v53);
    v52 = v15 & 1;
  }
  else
  {
    v49 = 0;
    v50 = 0;
    v51 = 0;
    v96 = 0;
    v52 = 0;
  }
  if (v49 > 0x3B9ACA00)
    v54 = 1;
  else
    v54 = a3;
  if ((_os_feature_enabled_impl() ^ 1 | v54 | v52) == 1)
  {
    *(_DWORD *)v99 = 0;
    if (fd_setDir(a1, (int *)v99))
    {
      v55 = opendir(".");
      if (v55)
      {
        v56 = v55;
        v95 = v51;
        v57 = 0;
        while (1)
        {
          v58 = readdir(v56);
          if (!v58)
            break;
          v59 = v58->d_name;
          if (v58->d_name[0] != 46)
          {
            v60 = v58->d_type;
            v61 = v60 == 4 || v60 == 10;
            if (!v61
              && !strncmp(v58->d_name, "skg_", 4uLL)
              && (!strncmp(v59, "skg_deleteAttr.", 0xFuLL) || !strncmp(v59, "skg_knowledgeEntry.", 0x13uLL)))
            {
              v92 = *__error();
              v62 = _SILogForLogForCategory(10);
              v63 = 2 * (dword_1EF19FCB4 < 4);
              allocatora = v62;
              if (os_log_type_enabled(v62, v63))
              {
                buf[0].st_dev = 136315138;
                *(_QWORD *)&buf[0].st_mode = v59;
                _os_log_impl(&dword_1B8270000, allocatora, v63, "unlink (%s)", (uint8_t *)buf, 0xCu);
              }
              *__error() = v92;
              unlink(v59);
              v57 = 1;
            }
          }
        }
        closedir(v56);
        v51 = v95;
      }
      else
      {
        v57 = 0;
      }
      v65 = *(_DWORD *)v99;
      MEMORY[0x1BCCB1484](*(unsigned int *)v99);
      if ((v65 & 0x80000000) == 0)
        close(v65);
      v64 = (v57 & 1) == 0;
    }
    else
    {
      v64 = 1;
    }
    bzero(buf, 0x400uLL);
    if ((fcntl(a1, 50, buf) & 0x80000000) == 0 && LOBYTE(buf[0].st_dev))
    {
      v66 = strlen((const char *)buf);
      snprintf((char *)buf + v66, 1024 - v66, "/%s", "skg_");
      v67 = open((const char *)buf, 1793, 384);
      if ((v67 & 0x80000000) == 0)
      {
        close(v67);
        if (!v64)
        {
          bzero(buf, 0x400uLL);
          if ((fcntl(a1, 50, buf) & 0x80000000) == 0)
          {
            if (LOBYTE(buf[0].st_dev))
            {
              v68 = strlen((const char *)buf);
              v69 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
              v70 = CFURLCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const UInt8 *)buf, v68, 0x8000100u, 0);
              if (v70)
              {
                v71 = v70;
                PathComponent = CFURLCreateCopyDeletingLastPathComponent(v69, v70);
                if (PathComponent)
                {
                  v73 = PathComponent;
                  v74 = CFURLCopyLastPathComponent(PathComponent);
                  if (v74)
                  {
                    v75 = v74;
                    v76 = dictionaryFromPurgeEvent(v74, v96, v50);
                    analytics_send_event();
                    xpc_release(v76);
                    v77 = dictionaryFromPurgeEvent(v75, v51, v49);
                    analytics_send_event();
                    xpc_release(v77);
                    CFRelease(v75);
                  }
                  CFRelease(v73);
                }
                CFRelease(v71);
              }
            }
          }
        }
        return;
      }
      v78 = *__error();
      v79 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v79, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v99 = 136315394;
        v100 = "si_purge_journal_files";
        v101 = 1024;
        *(_DWORD *)v102 = 9667;
        _os_log_error_impl(&dword_1B8270000, v79, OS_LOG_TYPE_ERROR, "%s:%d: write skg marker error", v99, 0x12u);
      }
      *__error() = v78;
    }
    v80 = *__error();
    v81 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v81, OS_LOG_TYPE_ERROR))
    {
      buf[0].st_dev = 136315394;
      *(_QWORD *)&buf[0].st_mode = "si_handle_tmp_files";
      WORD2(buf[0].st_ino) = 1024;
      *(_DWORD *)((char *)&buf[0].st_ino + 6) = 9829;
      _os_log_error_impl(&dword_1B8270000, v81, OS_LOG_TYPE_ERROR, "%s:%d: unable to purge skg files", (uint8_t *)buf, 0x12u);
    }
    *__error() = v80;
  }
}

uint64_t __exist_precheck_touch_file_block_invoke(uint64_t result)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = 1;
  return result;
}

int *dump_filesystem_meta(int a1)
{
  int v2;
  int v3;
  DIR *v4;
  DIR *v5;
  NSObject *v6;
  dirent *v7;
  char *d_name;
  blksize_t st_blksize;
  off_t st_size;
  __darwin_time_t tv_sec;
  __darwin_time_t v12;
  __darwin_time_t v13;
  int *result;
  int v15;
  NSObject *v16;
  os_log_type_t v17;
  int v18;
  int v19;
  NSObject *v20;
  os_log_type_t v21;
  int v22;
  time_t v23;
  int st_mode;
  __uint32_t st_flags;
  uint8_t buf[4];
  int v27;
  __int16 v28;
  char *v29;
  __int16 v30;
  off_t v31;
  __int16 v32;
  blksize_t v33;
  __int16 v34;
  int v35;
  __int16 v36;
  __uint32_t v37;
  __int16 v38;
  __darwin_time_t v39;
  __int16 v40;
  char *v41;
  __int16 v42;
  __darwin_time_t v43;
  __int16 v44;
  char *v45;
  __int16 v46;
  __darwin_time_t v47;
  __int16 v48;
  char *v49;
  stat v50;
  char __str[16];
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  uint64_t v59;

  v59 = *MEMORY[0x1E0C80C00];
  v57 = 0u;
  v58 = 0u;
  v55 = 0u;
  v56 = 0u;
  v53 = 0u;
  v54 = 0u;
  *(_OWORD *)__str = 0u;
  v52 = 0u;
  v2 = openat(a1, ".", 0);
  if (v2 == -1)
  {
    v15 = *__error();
    v16 = _SILogForLogForCategory(0);
    v17 = gSILogLevels[0] < 3;
    if (os_log_type_enabled(v16, (os_log_type_t)(gSILogLevels[0] < 3)))
    {
      v18 = *__error();
      v50.st_dev = 67109376;
      *(_DWORD *)&v50.st_mode = a1;
      LOWORD(v50.st_ino) = 1024;
      *(_DWORD *)((char *)&v50.st_ino + 2) = v18;
      _os_log_impl(&dword_1B8270000, v16, v17, "*warn* openat(%d): %d", (uint8_t *)&v50, 0xEu);
    }
    result = __error();
    *result = v15;
  }
  else
  {
    v3 = v2;
    v4 = fdopendir(v2);
    if (v4)
    {
      v5 = v4;
      v23 = time(0);
      v6 = MEMORY[0x1E0C81028];
      while (1)
      {
        v7 = readdir(v5);
        if (!v7)
          break;
        if (v7->d_type == 8)
        {
          d_name = v7->d_name;
          memset(&v50, 0, sizeof(v50));
          if (!fstatat(a1, v7->d_name, &v50, 32) && os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
          {
            st_blksize = v50.st_blksize;
            st_mode = v50.st_mode;
            st_flags = v50.st_flags;
            st_size = v50.st_size;
            tv_sec = v50.st_atimespec.tv_sec;
            prettyStr(v23 - v50.st_atimespec.tv_sec, __str);
            v12 = v50.st_mtimespec.tv_sec;
            prettyStr(v23 - v50.st_mtimespec.tv_sec, __str);
            v13 = v50.st_ctimespec.tv_sec;
            prettyStr(v23 - v50.st_ctimespec.tv_sec, __str);
            *(_DWORD *)buf = 67111938;
            v27 = a1;
            v28 = 2080;
            v29 = d_name;
            v30 = 2048;
            v31 = st_size;
            v32 = 1024;
            v33 = st_blksize;
            v34 = 1024;
            v35 = st_mode;
            v36 = 1024;
            v37 = st_flags;
            v38 = 2048;
            v39 = tv_sec;
            v40 = 2080;
            v41 = __str;
            v42 = 2048;
            v43 = v12;
            v44 = 2080;
            v45 = __str;
            v46 = 2048;
            v47 = v13;
            v48 = 2080;
            v49 = __str;
            _os_log_impl(&dword_1B8270000, v6, OS_LOG_TYPE_DEFAULT, "[fsmeta %d] %s sz:%llu bs:%d md:%d fl:%d at:%lus(%s ago) mt:%lus(%s ago) ct:%lus(%s ago)", buf, 0x6Au);
          }
        }
      }
      return (int *)closedir(v5);
    }
    else
    {
      v19 = *__error();
      v20 = _SILogForLogForCategory(0);
      v21 = gSILogLevels[0] < 3;
      if (os_log_type_enabled(v20, (os_log_type_t)(gSILogLevels[0] < 3)))
      {
        v22 = *__error();
        v50.st_dev = 67109376;
        *(_DWORD *)&v50.st_mode = v3;
        LOWORD(v50.st_ino) = 1024;
        *(_DWORD *)((char *)&v50.st_ino + 2) = v22;
        _os_log_impl(&dword_1B8270000, v20, v21, "*warn* fdopendir(%d): %d", (uint8_t *)&v50, 0xEu);
      }
      *__error() = v19;
      return (int *)close(v3);
    }
  }
  return result;
}

uint64_t si_validate_db(uint64_t a1)
{
  unsigned int v2;
  int v3;
  unint64_t v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  void (*v10)(_QWORD);
  int v11;
  NSObject *v12;
  uint64_t v13;
  const char *field_name_for_id;
  const char *v15;
  int v16;
  NSObject *v17;
  uint64_t v18;
  uint64_t v19;
  void (*v20)(_QWORD);
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  uint8_t buf[4];
  const char *v27;
  __int16 v28;
  int v29;
  __int16 v30;
  const char *v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  do
  {
    v2 = __ldxr(exceptionSequenceNum);
    v3 = v2 + 1;
  }
  while (__stxr(v2 + 1, exceptionSequenceNum));
  v4 = setThreadIdAndInfo(-1, (__int128 *)sSDBExceptionCallbacks, *(_QWORD *)(a1 + 1184), 0x40000000, v3);
  v24 = HIDWORD(v4);
  v25 = v4;
  v22 = v6;
  v23 = v5;
  v7 = *(_QWORD *)&threadData[18 * v4 + 2];
  v8 = v7 + 320 * HIDWORD(v4);
  *(_BYTE *)(v8 + 216) = 0;
  v9 = *(_DWORD *)(v8 + 312);
  v10 = *(void (**)(_QWORD))(v8 + 224);
  if (v10)
    v10(*(_QWORD *)(v7 + 320 * HIDWORD(v4) + 288));
  if (_setjmp((int *)v8))
  {
    v11 = *__error();
    v12 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v27 = "si_validate_db";
      v28 = 1024;
      v29 = 932;
      _os_log_error_impl(&dword_1B8270000, v12, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
    }
    *__error() = v11;
    *(_DWORD *)(v8 + 312) = v9;
    CIOnThreadCleanUpReset(v22);
    v13 = 1;
    dropThreadId(v25, 1, v3);
    CICleanUpReset(v25, v23);
  }
  else
  {
    field_name_for_id = (const char *)db_get_field_name_for_id(*(int **)(a1 + 1184), 1);
    v15 = field_name_for_id;
    if (field_name_for_id && !strncmp(field_name_for_id, "_kMDXXXX___DUMMY", 0x10uLL))
    {
      v13 = 1;
    }
    else
    {
      v16 = *__error();
      v17 = _SILogForLogForCategory(7);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315650;
        v27 = "si_validate_db";
        v28 = 1024;
        v29 = 929;
        v30 = 2080;
        v31 = v15;
        _os_log_error_impl(&dword_1B8270000, v17, OS_LOG_TYPE_ERROR, "%s:%d: Entry 1 in the name table is %s (should be dummy field name)", buf, 0x1Cu);
      }
      v13 = 0;
      *__error() = v16;
    }
    v18 = *(_QWORD *)&threadData[18 * v25 + 2];
    v19 = v18 + 320 * v24;
    *(_DWORD *)(v19 + 312) = v9;
    v20 = *(void (**)(_QWORD))(v19 + 232);
    if (v20)
      v20(*(_QWORD *)(v18 + 320 * v24 + 288));
    dropThreadId(v25, 0, v3);
  }
  return v13;
}

int *disableWritingForAllButLastOfRunsOfTransaction(int *result)
{
  int *v1;
  unint64_t v2;
  uint64_t v3;
  int **v4;
  int v5;
  NSObject *v6;
  os_log_type_t v7;
  int v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char v12;
  uint8_t buf[4];
  int v14;
  uint64_t v15;

  v1 = result;
  v15 = *MEMORY[0x1E0C80C00];
  v2 = result[2];
  if (v2 >= 2)
  {
    v3 = 0;
    do
    {
      v4 = (int **)(*(_QWORD *)v1 + 8 * v3);
      result = *v4;
      if ((*v4)[8] == v4[1][8])
      {
        _CIDisableUpdates((uint64_t)result);
        v5 = *__error();
        v6 = _SILogForLogForCategory(0);
        v7 = 2 * (gSILogLevels[0] < 4);
        if (os_log_type_enabled(v6, v7))
        {
          v8 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v1 + 8 * v3) + 32);
          *(_DWORD *)buf = 67109120;
          v14 = v8;
          _os_log_impl(&dword_1B8270000, v6, v7, "Disable updates for index in transaction %d", buf, 8u);
        }
        result = __error();
        *result = v5;
        v2 = v1[2];
      }
      v9 = v3 + 2;
      ++v3;
    }
    while (v9 < v2);
  }
  v1[4] = -1;
  if (v2)
  {
    v10 = 0;
    while (1)
    {
      v11 = *(_QWORD *)(*(_QWORD *)v1 + 8 * v10);
      v12 = atomic_load((unsigned int *)(v11 + 28));
      if ((v12 & 3) == 0 && !*(_BYTE *)(v11 + 15163))
        break;
      if (++v10 >= (unint64_t)v1[2])
        return result;
    }
    v1[4] = v10;
  }
  return result;
}

uint64_t indexSetGetNotCompactCount(uint64_t a1)
{
  uint64_t v1;
  uint64_t result;
  unint64_t v4;
  uint64_t v5;
  char v6;
  uint64_t v7;
  char v8;
  _BOOL4 v9;

  v1 = *(unsigned int *)(a1 + 8);
  if ((int)v1 < 1)
    return 0;
  result = 0;
  v4 = v1 + 1;
  do
  {
    v5 = (v4 - 2);
    v6 = atomic_load((unsigned int *)(*(_QWORD *)(*(_QWORD *)a1 + 8 * v5) + 28));
    if ((v6 & 4) != 0)
      break;
    v7 = *(_QWORD *)(*(_QWORD *)a1 + 8 * v5);
    v8 = atomic_load((unsigned int *)(v7 + 28));
    v9 = (v8 & 3) == 0 && *(_BYTE *)(v7 + 15163) == 0;
    result = result + !v9;
    --v4;
  }
  while (v4 > 1);
  return result;
}

uint64_t indexSetGetNotMergedCount(uint64_t *a1)
{
  uint64_t v1;
  uint64_t result;
  uint64_t v4;
  unsigned int i;
  uint64_t v6;
  char v7;

  v1 = *((unsigned int *)a1 + 2);
  if ((int)v1 < 1)
    return 0;
  result = 0;
  v4 = *a1;
  for (i = v1 - 1; ; --i)
  {
    v6 = *(_QWORD *)(v4 + 8 * i);
    v7 = atomic_load((unsigned int *)(v6 + 28));
    if ((v7 & 3) == 0 && !*(_BYTE *)(v6 + 15163))
      break;
    v4 = *a1;
    if (*(int *)(*(_QWORD *)(*a1 + 8 * i) + 44) > 2)
      break;
    result = (result + 1);
    if ((_DWORD)v1 == (_DWORD)result)
      return v1;
  }
  return result;
}

uint64_t indexSetGetLiveCount(uint64_t a1, int a2)
{
  uint64_t result;
  unsigned int v4;

  if (a2 - 1 < 1)
    return 0;
  result = 0;
  v4 = a2 - 2;
  while (*(_DWORD *)(*(_QWORD *)(a1 + 8 * (a2 - 1)) + 32) == *(_DWORD *)(*(_QWORD *)(a1 + 8 * v4)
                                                                                          + 32))
  {
    result = (result + 1);
    if (--v4 == -1)
      return (a2 - 1);
  }
  return result;
}

void holdAndIssueMerge(uint64_t a1, int a2, uint64_t a3, char a4)
{
  _BYTE *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t (*v11)(_QWORD, const char *, uint64_t, const char *);

  v8 = malloc_type_calloc(1uLL, 0x460uLL, 0x1070040C187FD8AuLL);
  v8[1042] = 0;
  *((_QWORD *)v8 + 132) = copyHoldQueue(a1);
  *(_QWORD *)v8 = a1;
  v9 = *(_QWORD *)(*(_QWORD *)a3 + 8 * (*(_DWORD *)(a3 + 8) - a2));
  v8[16] = a4;
  *((_DWORD *)v8 + 2) = *(_DWORD *)(v9 + 48);
  *((_DWORD *)v8 + 3) = a2;
  v8[1041] = 0;
  *((_QWORD *)v8 + 131) = "void holdAndIssueMerge(SIRef, int32_t, SIIndexSetRef, _Bool, _Bool)";
  *((_DWORD *)v8 + 274) = 7;
  v8[1100] = 0;
  if (!*((_QWORD *)v8 + 136) && !*((_DWORD *)v8 + 266))
  {
    v10 = *(_QWORD *)(a1 + 2360);
    if (v10)
    {
      v11 = *(uint64_t (**)(_QWORD, const char *, uint64_t, const char *))(v10 + 64);
      if (v11)
        *((_DWORD *)v8 + 266) = v11(*(_QWORD *)(v10 + 136), "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 9593, "void holdAndIssueMerge(SIRef, int32_t, SIIndexSetRef, _Bool, _Bool)");
    }
  }
  __strlcpy_chk();
  si_enqueue_work(*(_QWORD *)(a1 + 1056), (uint64_t)si_mergeIndex, (uint64_t)v8);
}

void compactReadOnlyIndexes(uint64_t a1, char a2)
{
  _BYTE *v4;

  v4 = malloc_type_calloc(1uLL, 0x460uLL, 0x1070040C187FD8AuLL);
  v4[16] = a2;
  *(_QWORD *)v4 = a1;
  si_enqueue_barrier_with_qos(*(_QWORD *)(a1 + 1048), 9, (uint64_t)si_compactReadOnlyIndexes1, (uint64_t)v4);
}

uint64_t indexSetGetWritableCount(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  char v5;
  _BOOL4 v6;

  v1 = *(unsigned int *)(a1 + 8);
  if ((int)v1 < 1)
    return 0;
  LODWORD(v2) = 0;
  v3 = v1 + 1;
  do
  {
    v4 = *(_QWORD *)(*(_QWORD *)a1 + 8 * (v3 - 2));
    v5 = atomic_load((unsigned int *)(v4 + 28));
    v6 = (v5 & 3) == 0 && *(unsigned __int8 *)(v4 + 15163) == 0;
    v2 = (v2 + v6);
    --v3;
  }
  while (v3 > 1);
  return v2;
}

void si_compactReadOnlyIndexes1(uint64_t a1, int a2)
{
  uint64_t v3;

  v3 = a1;
  if (!a2)
  {
    si_enqueue_work_with_qos(*(_QWORD *)(*(_QWORD *)a1 + 1040), 9, (uint64_t)si_compactReadOnlyIndexes2, a1);
    v3 = 0;
  }
  si_merge_ctx_free(v3, a2 != 0);
}

void si_compactReadOnlyIndexes2(uint64_t *a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  char *v5;
  uint64_t v6;

  v3 = (uint64_t)a1;
  if (!a2)
  {
    v4 = *a1;
    si_sync_ctx_create_with_defer_fd(*a1, 0);
    v6 = (uint64_t)v5;
    v5[96] = 1;
    if (!*(_BYTE *)(*(_QWORD *)v5 + 2437) && !*(_BYTE *)(*(_QWORD *)v3 + 2072))
      attachJournal(v5);
    syncIndex(v6, 0);
    si_enqueue_work(*(_QWORD *)(v4 + 1056), (uint64_t)si_compactReadOnlyIndexes3, v3);
    v3 = 0;
  }
  si_merge_ctx_free(v3, a2 != 0);
}

void si_compactReadOnlyIndexes3(uint64_t a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  unsigned int v8;
  uint64_t v9;

  if (!a2)
  {
    v4 = *(_QWORD *)a1;
    v8 = 0;
    if (fd_setDir(*(unsigned int *)(v4 + 32), (int *)&v8))
    {
      v5 = 1384;
      if (!*(_BYTE *)(a1 + 16))
        v5 = 1392;
      v6 = *(_QWORD *)(v4 + v5);
      v9 = v4;
      __checkIndexSetDocIdOrder(v4, (uint64_t *)v6);
      if (*(_DWORD *)(v6 + 8))
        CompactIndexes(v4, 0, 0, (_QWORD *)v6);
      v7 = v8;
      MEMORY[0x1BCCB1484](v8);
      if ((v7 & 0x80000000) == 0)
        close(v7);
    }
  }
  si_merge_ctx_free(a1, a2 != 0);
}

char *prettyStr(uint64_t a1, char *__str)
{
  if (a1 <= 86399)
  {
    if (a1 % 86400 < 3600)
    {
      if (a1 % 86400 % 3600 < 60)
        snprintf(__str, 0x80uLL, "%lds");
      else
        snprintf(__str, 0x80uLL, "%ld:%ld");
    }
    else
    {
      snprintf(__str, 0x80uLL, "%ld:%ld:%ld");
    }
  }
  else
  {
    snprintf(__str, 0x80uLL, "%ldd%ld:%ld:%ld");
  }
  return __str;
}

int *__totalDiskSpaceSize_block_invoke()
{
  int *result;
  int v1;
  NSObject *v2;
  os_log_type_t v3;
  int v4;
  _DWORD v5[4];
  statfs v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  bzero(&v6, 0x878uLL);
  result = (int *)statfs("/", &v6);
  if ((_DWORD)result)
  {
    v1 = *__error();
    v2 = _SILogForLogForCategory(0);
    v3 = gSILogLevels[0] < 3;
    if (os_log_type_enabled(v2, (os_log_type_t)(gSILogLevels[0] < 3)))
    {
      v4 = *__error();
      v5[0] = 67109120;
      v5[1] = v4;
      _os_log_impl(&dword_1B8270000, v2, v3, "*warn* Failed to get total disk space size. err=%d", (uint8_t *)v5, 8u);
    }
    result = __error();
    *result = v1;
  }
  else
  {
    gTotalDiskSpaceSize = v6.f_blocks * v6.f_bsize;
  }
  return result;
}

xpc_object_t dictionaryFromPurgeEvent(const __CFString *a1, int64_t a2, int64_t a3)
{
  xpc_object_t empty;
  char buffer[1024];
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  bzero(buffer, 0x400uLL);
  empty = xpc_dictionary_create_empty();
  if (CFStringGetCString(a1, buffer, 1024, 0x8000100u))
    xpc_dictionary_set_string(empty, "indexId", buffer);
  xpc_dictionary_set_int64(empty, "itemcount", a2);
  xpc_dictionary_set_int64(empty, "indexingtime", 0);
  xpc_dictionary_set_int64(empty, "aggregatedatasize", a3);
  return empty;
}

uint64_t clear_docid_match_new(uint64_t a1, uint64_t a2)
{
  unint64_t v3;
  uint64_t v5;
  const __CFAllocator *v6;
  CFDictionaryRef v7;
  const __CFString *v8;
  const __CFString *v9;
  const void *v10;
  _DWORD *v11;
  CFDictionaryRef v12;
  CFDictionaryRef v13;
  _QWORD v14[6];
  int v15[2];
  _QWORD v16[2];

  v16[1] = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(a1 + 32);
  if (v3 > *(_QWORD *)(a2 + 16))
  {
    *(_QWORD *)(a2 + 16) = v3;
    v3 = *(_QWORD *)(a1 + 32);
  }
  if (v3 < *(_QWORD *)(a2 + 8))
    return 0;
  ++*(_DWORD *)(a2 + 44);
  v5 = *(_QWORD *)(a2 + 48);
  if (v5)
  {
    v16[0] = *(unsigned int *)(v5 + 20);
    *(_QWORD *)v15 = 0;
    if (!db_get_field_by_id(*(int **)(v5 + 8), a1, (int *)v16, (unint64_t *)v15, 0))
    {
      v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v7 = _decodeSDBField(*(_QWORD *)(v5 + 8), *(unsigned __int16 **)v15, (unsigned __int8 *)(*(_QWORD *)v15 + 13), 0, 0, 0, 0, (CFAllocatorRef)*MEMORY[0x1E0C9AE00]);
      if (v7)
      {
        v8 = (const __CFString *)v7;
        v9 = *(const __CFString **)(v5 + 32);
        if (!v9 || *(_DWORD *)(v5 + 48) > 0x40u || CFStringCompare(v9, v8, 0))
        {
          if (*(_QWORD *)(v5 + 40))
          {
            _MDPlistContainerEndArray();
            _MDPlistContainerEndArray();
            _MDPlistContainerEndContainer();
            mobile_journal_plist(*(_DWORD **)v5, 0, *(_DWORD *)(v5 + 48), *(_QWORD *)(v5 + 40), 0, 0);
            CFRelease(*(CFTypeRef *)(v5 + 40));
            *(_QWORD *)(v5 + 40) = 0;
          }
          v10 = *(const void **)(v5 + 32);
          if (v10)
            CFRelease(v10);
          *(_QWORD *)(v5 + 32) = CFRetain(v8);
          *(_DWORD *)(v5 + 48) = 0;
          *(_QWORD *)(v5 + 40) = _MDPlistContainerCreateMutable();
          _MDPlistContainerBeginContainer();
          _MDPlistContainerBeginArray();
          _MDPlistContainerAddObject();
          _MDPlistContainerBeginArray();
        }
        LODWORD(v16[0]) = *(_DWORD *)(v5 + 24);
        if (!db_get_field_by_id(*(int **)(v5 + 8), a1, (int *)v16, (unint64_t *)v15, 0))
        {
          v12 = _decodeSDBField(*(_QWORD *)(v5 + 8), *(unsigned __int16 **)v15, (unsigned __int8 *)(*(_QWORD *)v15 + 13), 0, 0, 0, 0, v6);
          if (v12)
          {
            v13 = v12;
            if (objectHasContent(*(int **)(v5 + 8), a1))
            {
              _MDPlistContainerBeginDictionary();
              _MDPlistContainerAddCString();
              _MDPlistContainerAddObject();
              _MDPlistContainerAddCString();
              _MDPlistContainerAddObject();
              _MDPlistContainerAddCString();
              _MDPlistContainerAddBooleanValue();
              _MDPlistContainerEndDictionary();
              ++*(_DWORD *)(v5 + 48);
              CFRelease(v13);
              goto LABEL_18;
            }
            CFRelease(v13);
          }
        }
        _MDPlistContainerBeginDictionary();
        v11 = *(_DWORD **)(v5 + 8);
        v14[0] = MEMORY[0x1E0C809B0];
        v14[1] = 0x40000000;
        v14[2] = __RepairJournalWrite_block_invoke;
        v14[3] = &__block_descriptor_tmp_752;
        v14[4] = v5;
        v14[5] = a1;
        _enumerate_dbo(v11, a1, 0, (uint64_t)v14);
        _MDPlistContainerEndDictionary();
        ++*(_DWORD *)(v5 + 48);
LABEL_18:
        CFRelease(v8);
      }
    }
  }
  return 1;
}

int *updateMetaInfoForState(int *result, int a2, int a3)
{
  int *v5;
  int v6;
  NSObject *v7;
  os_log_type_t v8;
  int v9;
  int v10;
  NSObject *v11;
  os_log_type_t v12;
  int v13;
  int v14;
  NSObject *v15;
  os_log_type_t v16;
  int v17;
  int v18;
  NSObject *v19;
  os_log_type_t v20;
  int v21;
  int v22;
  int v23;
  __int16 v24;
  int v25;
  uint64_t v26;

  v5 = result;
  v26 = *MEMORY[0x1E0C80C00];
  if (result[10] != a2)
  {
    v6 = *__error();
    v7 = _SILogForLogForCategory(11);
    v8 = dword_1EF19FCB8 < 3;
    if (os_log_type_enabled(v7, (os_log_type_t)(dword_1EF19FCB8 < 3)))
    {
      v9 = v5[10];
      v22 = 67109376;
      v23 = a2;
      v24 = 1024;
      v25 = v9;
      _os_log_impl(&dword_1B8270000, v7, v8, "*warn* clean scan count mis-match expected:%d got %d", (uint8_t *)&v22, 0xEu);
    }
    result = __error();
    *result = v6;
    v5[10] = a2;
  }
  if (v5[12] != a2)
  {
    v10 = *__error();
    v11 = _SILogForLogForCategory(11);
    v12 = dword_1EF19FCB8 < 3;
    if (os_log_type_enabled(v11, (os_log_type_t)(dword_1EF19FCB8 < 3)))
    {
      v13 = v5[12];
      v22 = 67109376;
      v23 = a2;
      v24 = 1024;
      v25 = v13;
      _os_log_impl(&dword_1B8270000, v11, v12, "*warn* shadow scan count mis-match expected:%d got %d", (uint8_t *)&v22, 0xEu);
    }
    result = __error();
    *result = v10;
    v5[12] = a2;
  }
  if (v5[11] != a3)
  {
    v14 = *__error();
    v15 = _SILogForLogForCategory(11);
    v16 = dword_1EF19FCB8 < 3;
    if (os_log_type_enabled(v15, (os_log_type_t)(dword_1EF19FCB8 < 3)))
    {
      v17 = v5[11];
      v22 = 67109376;
      v23 = a3;
      v24 = 1024;
      v25 = v17;
      _os_log_impl(&dword_1B8270000, v15, v16, "*warn* clean live count mis-match expected:%d got %d", (uint8_t *)&v22, 0xEu);
    }
    result = __error();
    *result = v14;
    v5[11] = a3;
  }
  if (v5[13] != a3)
  {
    v18 = *__error();
    v19 = _SILogForLogForCategory(11);
    v20 = dword_1EF19FCB8 < 3;
    if (os_log_type_enabled(v19, (os_log_type_t)(dword_1EF19FCB8 < 3)))
    {
      v21 = v5[13];
      v22 = 67109376;
      v23 = a3;
      v24 = 1024;
      v25 = v21;
      _os_log_impl(&dword_1B8270000, v19, v20, "*warn* shadow live count mis-match expected:%d got %d", (uint8_t *)&v22, 0xEu);
    }
    result = __error();
    *result = v18;
    v5[13] = a3;
  }
  return result;
}

uint64_t SIOpenJWLIndex(int a1, _QWORD *a2, uint64_t a3)
{
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  NSObject *v10;
  uint64_t result;
  const __CFDictionary *clientstates_file;
  const __CFNumber *Value;
  const __CFNumber *v14;
  const __CFNumber *v15;
  const __CFNumber *v16;
  const __CFString *v17;
  const __CFString *v18;
  const __CFUUID *v19;
  const __CFString *v20;
  const __CFString *v21;
  int v22;
  const char *CStringPtr;
  int v24;
  int v25;
  int v26;
  const char *v27;
  _QWORD *v28;
  int v29;
  NSObject *v30;
  int v31;
  NSObject *v32;
  const char *v33;
  NSObject *v34;
  NSObject *v35;
  uint32_t v36;
  int v37;
  int *v38;
  char *v39;
  int v40;
  NSObject *v41;
  int *v42;
  char *v43;
  int v44;
  NSObject *v45;
  int v46;
  NSObject *v47;
  int v48;
  NSObject *v49;
  uint64_t i;
  uint64_t v51;
  uint64_t v52;
  int v53;
  BOOL v54;
  const char *v55;
  _QWORD *v56;
  void **v57;
  void *root_scheduler;
  _QWORD *v59;
  NSObject *v60;
  dispatch_queue_t v61;
  int v62;
  const char *v63;
  const char *v64;
  int *v65;
  char *v66;
  char *v67;
  char *v68;
  const char *v69;
  uint64_t v70;
  char *v71;
  char *v72;
  const char *v73;
  uint64_t v74;
  int valuePtr[256];
  uint8_t buf[48];
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  _BYTE v88[31];
  uint64_t v89;

  v89 = *MEMORY[0x1E0C80C00];
  v6 = malloc_type_calloc(1uLL, 0x2780uLL, 0x10F0040E1D49570uLL);
  *v6 = 0xC0DE10DE10DEC0DELL;
  v7 = guarded_dup(a1);
  v6[4] = v7;
  v6[5] = v8;
  if ((_DWORD)v7 == -1 || MEMORY[0x1BCCB1484]())
  {
    v9 = *__error();
    v10 = _SILogForLogForCategory(11);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      v37 = *((_DWORD *)v6 + 8);
      v38 = __error();
      v39 = strerror(*v38);
      v40 = *__error();
      *(_DWORD *)buf = 136316418;
      *(_QWORD *)&buf[4] = "SIOpenJWLIndex";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 12412;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v37;
      *(_WORD *)&buf[24] = 1024;
      *(_DWORD *)&buf[26] = a1;
      *(_WORD *)&buf[30] = 2080;
      *(_QWORD *)&buf[32] = v39;
      *(_WORD *)&buf[40] = 1024;
      *(_DWORD *)&buf[42] = v40;
      _os_log_error_impl(&dword_1B8270000, v10, OS_LOG_TYPE_ERROR, "%s:%d: Unable to set jwl index fd: %d (dirfd: %d), err: %s(%d)", buf, 0x2Eu);
    }
    *__error() = v9;
    free(v6);
    return 0xFFFFFFFFLL;
  }
  pthread_rwlock_init((pthread_rwlock_t *)(v6 + 10), 0);
  pthread_mutex_init((pthread_mutex_t *)(v6 + 204), 0);
  *((_DWORD *)v6 + 15) = 2 * a3;
  *((_OWORD *)v6 + 145) = 0u;
  *((_DWORD *)v6 + 1741) = 1;
  *((_BYTE *)v6 + 2072) = 1;
  *((_DWORD *)v6 + 1743) = 1;
  clientstates_file = (const __CFDictionary *)si_read_clientstates_file((uint64_t)v6);
  v6[9] = clientstates_file;
  if (clientstates_file)
  {
    Value = (const __CFNumber *)CFDictionaryGetValue(clientstates_file, CFSTR("version"));
    if (Value)
    {
      valuePtr[0] = 0;
      CFNumberGetValue(Value, kCFNumberIntType, valuePtr);
      if (valuePtr[0] != 1)
      {
        v31 = *__error();
        v34 = _SILogForLogForCategory(11);
        if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315906;
          *(_QWORD *)&buf[4] = "si_validate_and_read_clientstate";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 12334;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = valuePtr[0];
          *(_WORD *)&buf[24] = 1024;
          *(_DWORD *)&buf[26] = 1;
          v33 = "%s:%d: si_validate_and_read_clientstate: version mismatch %d != %d";
          v35 = v34;
          v36 = 30;
LABEL_48:
          _os_log_error_impl(&dword_1B8270000, v35, OS_LOG_TYPE_ERROR, v33, buf, v36);
          goto LABEL_49;
        }
        goto LABEL_49;
      }
      v14 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v6[9], CFSTR("journalSerialNumber"));
      if (v14)
      {
        *(_QWORD *)valuePtr = 0;
        CFNumberGetValue(v14, kCFNumberSInt64Type, valuePtr);
        if (*(uint64_t *)valuePtr <= 0)
        {
          v31 = *__error();
          v41 = _SILogForLogForCategory(11);
          if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315650;
            *(_QWORD *)&buf[4] = "si_validate_and_read_clientstate";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 12347;
            *(_WORD *)&buf[18] = 2048;
            *(_QWORD *)&buf[20] = *(_QWORD *)valuePtr;
            v33 = "%s:%d: si_validate_and_read_clientstate: invalid journal sno %lld";
LABEL_35:
            v35 = v41;
            v36 = 28;
            goto LABEL_48;
          }
          goto LABEL_49;
        }
        v6[266] = *(_QWORD *)valuePtr;
        v15 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v6[9], CFSTR("syncCount"));
        if (v15)
        {
          valuePtr[0] = 0;
          CFNumberGetValue(v15, kCFNumberIntType, valuePtr);
          if (valuePtr[0] <= 0)
          {
            v31 = *__error();
            v45 = _SILogForLogForCategory(11);
            if (!os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
              goto LABEL_49;
            *(_DWORD *)buf = 136315650;
            *(_QWORD *)&buf[4] = "si_validate_and_read_clientstate";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 12361;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = valuePtr[0];
            v33 = "%s:%d: si_validate_and_read_clientstate: invalid synccount %d";
            goto LABEL_44;
          }
          *((_DWORD *)v6 + 586) = valuePtr[0];
          v16 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)v6[9], CFSTR("deferSyncCount"));
          if (v16)
          {
            valuePtr[0] = 0;
            CFNumberGetValue(v16, kCFNumberIntType, valuePtr);
            if (valuePtr[0] > 0)
            {
              *((_DWORD *)v6 + 587) = valuePtr[0];
              v17 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)v6[9], CFSTR("cookie"));
              if (v17)
              {
                v18 = v17;
                v19 = CFUUIDCreateFromString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v17);
                v6[180] = v19;
                if (v19)
                {
                  *((CFUUIDBytes *)v6 + 89) = CFUUIDGetUUIDBytes(v19);
                  pthread_mutex_init((pthread_mutex_t *)(v6 + 165), 0);
                  *((_DWORD *)v6 + 15) = *((_DWORD *)v6 + 15) & 1 | (2 * a3);
                  _SIChangeProtectionClassForFilesInDirectory(*((_DWORD *)v6 + 8), a3);
                  *((_DWORD *)v6 + 15) &= ~1u;
                  v20 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)v6[9], CFSTR("journalName"));
                  v21 = v20;
                  if (v20)
                  {
                    v22 = *((_DWORD *)v6 + 8);
                    CStringPtr = CFStringGetCStringPtr(v20, 0x8000100u);
                    v24 = openat(v22, CStringPtr, 536870922);
                    if (v24 == -1)
                    {
                      v48 = *__error();
                      v49 = _SILogForLogForCategory(0);
                      if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
                      {
                        v64 = CFStringGetCStringPtr(v21, 0x8000100u);
                        v65 = __error();
                        v66 = strerror(*v65);
                        *(_DWORD *)buf = 136315906;
                        *(_QWORD *)&buf[4] = "SIOpenJWLIndex";
                        *(_WORD *)&buf[12] = 1024;
                        *(_DWORD *)&buf[14] = 12460;
                        *(_WORD *)&buf[18] = 2080;
                        *(_QWORD *)&buf[20] = v64;
                        *(_WORD *)&buf[28] = 2080;
                        *(_QWORD *)&buf[30] = v66;
                        _os_log_error_impl(&dword_1B8270000, v49, OS_LOG_TYPE_ERROR, "%s:%d: Unable to open journal %s err: %s", buf, 0x26u);
                      }
                      *__error() = v48;
                    }
                    else
                    {
                      v25 = v24;
                      v26 = *((_DWORD *)v6 + 8);
                      v27 = CFStringGetCStringPtr(v21, 0x8000100u);
                      v28 = fd_create_protected(v26, v27, 536870922, 2u);
                      close(v25);
                      if (v28)
                      {
                        v6[290] = v28;
                        _fd_acquire_fd((uint64_t)v28, buf);
                        if (*((_BYTE *)v6 + 2072)
                          && (*((_BYTE *)v6 + 829) & 0x10) == 0
                          && _os_feature_enabled_impl())
                        {
                          _os_feature_enabled_impl();
                        }
                        v6[263] = si_mobile_journal_create((uint64_t)v6);
                      }
                    }
                  }
                  if (!v6[263])
                  {
                    memset(v88, 0, sizeof(v88));
                    v87 = 0u;
                    v86 = 0u;
                    v85 = 0u;
                    v84 = 0u;
                    v83 = 0u;
                    v82 = 0u;
                    v81 = 0u;
                    v80 = 0u;
                    v79 = 0u;
                    v78 = 0u;
                    v77 = 0u;
                    v62 = *((_DWORD *)v6 + 587) - 1;
                    memset(buf, 0, sizeof(buf));
                    __sprintf_chk((char *)buf, 0, 0xFFuLL, "%s%d", "deferAttr.", v62);
                    if (v21)
                    {
                      v63 = CFStringGetCStringPtr(v21, 0x8000100u);
                      if (!strcmp(v63, (const char *)buf))
                        *((_DWORD *)v6 + 1742) = 1;
                    }
                  }
                  for (i = 0; i != 336; i += 56)
                  {
                    bzero(buf, 0x450uLL);
                    v51 = *(int *)((char *)&free_scheduler_settings + i + 48);
                    v52 = *(int *)((char *)&free_scheduler_settings + i + 52);
                    if ((_DWORD)v51 == 11)
                    {
                      bzero(valuePtr, 0x400uLL);
                      v53 = fcntl(*((_DWORD *)v6 + 8), 50, valuePtr);
                      if (LOBYTE(valuePtr[0]))
                        v54 = v53 < 0;
                      else
                        v54 = 1;
                      if (v54)
                        v55 = 0;
                      else
                        v55 = (const char *)valuePtr;
                      snprintf((char *)buf, 0x450uLL, "%s scheduler for jwl index at %s", *(const char **)((char *)&free_scheduler_settings + i + 40), v55);
                      if (v6[119])
                      {
                        v67 = __si_assert_copy_extra_521(-1);
                        v68 = v67;
                        v69 = "";
                        if (v67)
                          v69 = v67;
                        __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 12498, "newIndex->workqueues.schedulers[schedId]==0", v69);
                        free(v68);
                        if (__valid_fs(-1))
                          v70 = 2989;
                        else
                          v70 = 3072;
                        *(_DWORD *)v70 = -559038737;
                        abort();
                      }
                      v56 = &v6[v52];
                      if (v56[126])
                      {
                        v71 = __si_assert_copy_extra_521(-1);
                        v72 = v71;
                        v73 = "";
                        if (v71)
                          v73 = v71;
                        __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 12499, "newIndex->workqueues.queues[queueId]==0", v73);
                        free(v72);
                        if (__valid_fs(-1))
                          v74 = 2989;
                        else
                          v74 = 3072;
                        *(_DWORD *)v74 = -559038737;
                        abort();
                      }
                      v57 = (void **)(v56 + 126);
                      root_scheduler = si_create_root_scheduler((uint64_t)buf);
                      v6[119] = root_scheduler;
                      *v57 = si_create_child_queue((uint64_t)root_scheduler);
                    }
                    else
                    {
                      v6[v51 + 108] = 0;
                      v6[v52 + 126] = 0;
                    }
                  }
                  if (SIIsAppleInternal_onceToken != -1)
                    dispatch_once(&SIIsAppleInternal_onceToken, &__block_literal_global_4644);
                  if (SIIsAppleInternal_internal)
                  {
                    v59 = fd_create_protected(*((_DWORD *)v6 + 8), "activityJournal.1", 536871433, 3u);
                    si_activity_journal_init((uint64_t)(v6 + 274), v59);
                    fd_mark_purgable((_DWORD *)v6[274]);
                  }
                  v60 = dispatch_queue_attr_make_with_qos_class(MEMORY[0x1E0C80D50], QOS_CLASS_BACKGROUND, 0);
                  v61 = dispatch_queue_create("com.apple.spotlight.index.journal.toc", v60);
                  result = 0;
                  v6[147] = v61;
                  *a2 = v6;
                  return result;
                }
                v31 = *__error();
                v41 = _SILogForLogForCategory(11);
                if (!os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
                  goto LABEL_49;
                *(_DWORD *)buf = 136315650;
                *(_QWORD *)&buf[4] = "si_validate_and_read_clientstate";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = 12388;
                *(_WORD *)&buf[18] = 2112;
                *(_QWORD *)&buf[20] = v18;
                v33 = "%s:%d: si_validate_and_read_clientstate: invalid cookie %@";
                goto LABEL_35;
              }
              v31 = *__error();
              v32 = _SILogForLogForCategory(11);
              if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136315394;
                *(_QWORD *)&buf[4] = "si_validate_and_read_clientstate";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = 12393;
                v33 = "%s:%d: si_validate_and_read_clientstate: cookie not found";
                goto LABEL_47;
              }
LABEL_49:
              *__error() = v31;
              v46 = *__error();
              v47 = _SILogForLogForCategory(11);
              if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136315394;
                *(_QWORD *)&buf[4] = "SIOpenJWLIndex";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = 12438;
                _os_log_error_impl(&dword_1B8270000, v47, OS_LOG_TYPE_ERROR, "%s:%d: Invalid client state file, can't open jwlindex", buf, 0x12u);
              }
              *__error() = v46;
              pthread_mutex_destroy((pthread_mutex_t *)(v6 + 204));
              pthread_rwlock_destroy((pthread_rwlock_t *)(v6 + 10));
              free(v6);
              return 4294967293;
            }
            v31 = *__error();
            v45 = _SILogForLogForCategory(11);
            if (!os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
              goto LABEL_49;
            *(_DWORD *)buf = 136315650;
            *(_QWORD *)&buf[4] = "si_validate_and_read_clientstate";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 12375;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = valuePtr[0];
            v33 = "%s:%d: si_validate_and_read_clientstate: invalid defersynccount %d";
LABEL_44:
            v35 = v45;
            v36 = 24;
            goto LABEL_48;
          }
          v31 = *__error();
          v32 = _SILogForLogForCategory(11);
          if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
            goto LABEL_49;
          *(_DWORD *)buf = 136315394;
          *(_QWORD *)&buf[4] = "si_validate_and_read_clientstate";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 12380;
          v33 = "%s:%d: si_validate_and_read_clientstate: defersynccount not found";
        }
        else
        {
          v31 = *__error();
          v32 = _SILogForLogForCategory(11);
          if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
            goto LABEL_49;
          *(_DWORD *)buf = 136315394;
          *(_QWORD *)&buf[4] = "si_validate_and_read_clientstate";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 12366;
          v33 = "%s:%d: si_validate_and_read_clientstate: synccount not found";
        }
      }
      else
      {
        v31 = *__error();
        v32 = _SILogForLogForCategory(11);
        if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
          goto LABEL_49;
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)&buf[4] = "si_validate_and_read_clientstate";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 12352;
        v33 = "%s:%d: si_validate_and_read_clientstate: journal sno not found";
      }
    }
    else
    {
      v31 = *__error();
      v32 = _SILogForLogForCategory(11);
      if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
        goto LABEL_49;
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "si_validate_and_read_clientstate";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 12338;
      v33 = "%s:%d: si_validate_and_read_clientstate: version not found";
    }
LABEL_47:
    v35 = v32;
    v36 = 18;
    goto LABEL_48;
  }
  v29 = *__error();
  v30 = _SILogForLogForCategory(11);
  if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
  {
    v42 = __error();
    v43 = strerror(*v42);
    v44 = *__error();
    *(_DWORD *)buf = 136315906;
    *(_QWORD *)&buf[4] = "SIOpenJWLIndex";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 12429;
    *(_WORD *)&buf[18] = 2080;
    *(_QWORD *)&buf[20] = v43;
    *(_WORD *)&buf[28] = 1024;
    *(_DWORD *)&buf[30] = v44;
    _os_log_error_impl(&dword_1B8270000, v30, OS_LOG_TYPE_ERROR, "%s:%d: Unable to read client state file, err: %s(%d)", buf, 0x22u);
  }
  *__error() = v29;
  pthread_mutex_destroy((pthread_mutex_t *)(v6 + 204));
  pthread_rwlock_destroy((pthread_rwlock_t *)(v6 + 10));
  free(v6);
  return 4294967294;
}

DIR *_SIChangeProtectionClassForFilesInDirectory(int a1, uint64_t a2)
{
  DIR *result;
  size_t v5;
  DIR *v6;
  size_t v7;
  dirent *v8;
  dirent *v9;
  int d_type;
  char *d_name;
  uint64_t d_namlen;
  uint64_t v14;
  int v15;
  int v16;
  char __s[1024];
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  bzero(__s, 0x400uLL);
  result = (DIR *)fcntl(a1, 50, __s);
  if ((result & 0x80000000) == 0)
  {
    if (__s[0])
    {
      v5 = strlen(__s);
      result = opendir(__s);
      if (result)
      {
        v6 = result;
        if (fcntl(a1, 63) != (_DWORD)a2)
          fcntl(a1, 64, a2);
        v7 = v5 - 1023;
        while (1)
        {
          v8 = readdir(v6);
          if (!v8)
            break;
          v9 = v8;
          d_type = v8->d_type;
          if (d_type == 8 || d_type == 4)
          {
            d_name = v8->d_name;
            if (strcmp(v8->d_name, "."))
            {
              if (strcmp(v9->d_name, ".."))
              {
                d_namlen = v9->d_namlen;
                if (v7 + d_namlen >= 0xFFFFFFFFFFFFFC00)
                {
                  v14 = a2;
                  if ((a2 - 1) <= 1)
                  {
                    if (!strcmp("tmp.spotlight.state", d_name)
                      || !strncmp("clientstatesmetafile", d_name, 0x15uLL)
                      || !strncmp("activityJournal.", d_name, 0x10uLL)
                      || !strncmp("tmp.store.recovery.", d_name, 0x13uLL)
                      || !strncmp("store.updates", d_name, 0xDuLL)
                      || strstr(d_name, "indexHead")
                      || strstr(d_name, "indexState")
                      || strstr(d_name, "indexBigDates")
                      || strstr(d_name, "indexScores")
                      || strstr(d_name, "indexGroups")
                      || strstr(d_name, "indexIds")
                      || strstr(d_name, "indexPositionTable")
                      || strstr(d_name, "indexPositions")
                      || strstr(d_name, "indexPostings")
                      || strstr(d_name, "indexTermIds")
                      || strstr(d_name, "directoryStoreFile")
                      || strstr(d_name, "shadowIndexGroups")
                      || strstr(d_name, "shadowIndexHead")
                      || strstr(d_name, "shadowIndexPositionTable")
                      || strstr(d_name, "shadowIndexTermIds")
                      || strstr(d_name, "bgassertions")
                      || !strncmp("remapping", d_name, 9uLL)
                      || !strncmp("dbStr", d_name, 5uLL) && !strstr(d_name, ".data"))
                    {
                      v14 = 3;
                    }
                    else if (d_namlen < 4 || (v14 = 3, strncmp(&d_name[d_namlen - 3], "toc", 3uLL)))
                    {
                      if (strstr(d_name, "journalAttr.")
                        || strstr(d_name, "assertedJournalAttr.1")
                        || strstr(d_name, "deferattr."))
                      {
                        v14 = 2;
                      }
                      else if (strstr(d_name, "journalRepair."))
                      {
                        v14 = 2;
                      }
                      else
                      {
                        v14 = a2;
                      }
                    }
                  }
                  v15 = openat(v6->__dd_fd, d_name, 0x8000);
                  if (v15 != -1)
                  {
                    v16 = v15;
                    if (fcntl(v15, 63) != (_DWORD)v14)
                      fcntl(v16, 64, v14);
                    close(v16);
                  }
                }
              }
            }
          }
        }
        return (DIR *)closedir(v6);
      }
    }
  }
  return result;
}

DIR *_SISetProtectionClass(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 60) = *(_DWORD *)(a1 + 60) & 1 | (2 * a2);
  return _SIChangeProtectionClassForFilesInDirectory(*(_DWORD *)(a1 + 32), a2);
}

uint64_t _SISetPriority(uint64_t result, int a2)
{
  *(_DWORD *)(result + 60) = *(_DWORD *)(result + 60) & 0xFFFFFFFE | a2;
  return result;
}

void SICloseJWLIndex(uint64_t a1)
{
  double Current;
  uint64_t v3;
  unsigned int *v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int *v10;
  unsigned int v11;
  unsigned int v12;
  char *v13;
  char *v14;
  char *v15;
  const void *v16;
  const void *v17;
  int v18[4];

  if (a1)
  {
    si_scheduler_boost_and_forget(*(_QWORD *)(a1 + 952));
    Current = CFAbsoluteTimeGetCurrent();
    _SIShutdownIndexSchedulers(a1, 0, 0, Current);
    v3 = *(_QWORD *)(a1 + 952);
    if (v3)
    {
      v4 = (unsigned int *)(v3 + 80);
      do
      {
        v5 = __ldaxr(v4);
        v6 = v5 - 1;
      }
      while (__stlxr(v6, v4));
      if (!v6)
        _si_scheduler_destroy(v3);
    }
    v7 = *(unsigned int **)(a1 + 2104);
    if (v7)
    {
      do
      {
        v8 = __ldaxr(v7);
        v9 = v8 - 1;
      }
      while (__stlxr(v9, v7));
      if (!v9)
        _si_mobile_journal_finalize((uint64_t)v7, 1);
    }
    v10 = *(unsigned int **)(a1 + 2112);
    if (v10)
    {
      do
      {
        v11 = __ldaxr(v10);
        v12 = v11 - 1;
      }
      while (__stlxr(v12, v10));
      if (!v12)
        _si_mobile_journal_finalize((uint64_t)v10, 1);
    }
    v13 = *(char **)(a1 + 2320);
    if (v13)
      fd_release(v13);
    v14 = *(char **)(a1 + 2328);
    if (v14)
      fd_release(v14);
    if (SIIsAppleInternal_onceToken != -1)
      dispatch_once(&SIIsAppleInternal_onceToken, &__block_literal_global_4644);
    if (SIIsAppleInternal_internal)
    {
      SIActivityJournalClose((os_unfair_lock_s *)(a1 + 2192));
      v15 = *(char **)(a1 + 2192);
      *(_QWORD *)(a1 + 2192) = 0;
      if (v15)
        fd_release(v15);
    }
    dispatch_release(*(dispatch_object_t *)(a1 + 1176));
    v16 = *(const void **)(a1 + 72);
    if (v16)
      CFRelease(v16);
    *(_QWORD *)(a1 + 72) = 0;
    v17 = *(const void **)(a1 + 1440);
    if (v17)
      CFRelease(v17);
    *(_QWORD *)(a1 + 1440) = 0;
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 1632));
    pthread_rwlock_destroy((pthread_rwlock_t *)(a1 + 80));
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 1320));
    *(_OWORD *)v18 = *(_OWORD *)(a1 + 32);
    *(_DWORD *)(a1 + 32) = -1;
    if (v18[0] != -1)
    {
      if (*(_QWORD *)&v18[2])
        guarded_close_np();
      else
        close(v18[0]);
    }
    free((void *)a1);
  }
}

uint64_t SIOpenIndex(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, _QWORD *a6, __int128 *a7, uint64_t a8, uint64_t a9, _DWORD *a10)
{
  unsigned int v16;
  int v17;
  unint64_t v18;
  unsigned int v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  void (*v24)(_QWORD);
  int v25;
  NSObject *v26;
  uint64_t v27;
  int **v28;
  double Current;
  uint64_t v30;
  void (*v31)(_QWORD);
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  __int128 v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  int v40;
  _BOOL4 v41;
  _BOOL4 v42;
  char v43;
  int v44;
  int v45;
  char v46;
  int v47;
  NSObject *v48;
  os_log_type_t v49;
  void *v50;
  int v51;
  uint64_t v52;
  const void *v53;
  const void *v54;
  uint64_t v55;
  unsigned int v56;
  unsigned int v57;
  unsigned int v58;
  uint64_t v59;
  int v60;
  uint64_t v61;
  uint64_t v62;
  void (*v63)(_QWORD);
  uint64_t v65;
  uint64_t v66;
  void (*v68)(_QWORD);
  uint64_t *v70;
  __int128 v71;
  uint64_t v72;
  unsigned int v73;
  unsigned int v74;
  unsigned int v75;
  unsigned int v76;
  unsigned int v77;
  char v78;
  _BYTE buf[32];
  uint64_t v80;
  uint8_t v81[32];
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  uint64_t v86;
  uint64_t v87;

  v87 = *MEMORY[0x1E0C80C00];
  makeThreadId();
  v66 = a3;
  if (freeQueueOnce[0] != -1)
    dispatch_once(freeQueueOnce, &__block_literal_global_570);
  v70 = (uint64_t *)a1;
  do
  {
    v16 = __ldxr(exceptionSequenceNum);
    v17 = v16 + 1;
  }
  while (__stxr(v16 + 1, exceptionSequenceNum));
  v18 = setThreadIdAndInfo(a2, sFdExceptionCallbacks, 0, 1, v17);
  v75 = HIDWORD(v18);
  v76 = v18;
  v73 = v20;
  v74 = v19;
  v21 = *(_QWORD *)&threadData[18 * v18 + 2];
  v22 = v21 + 320 * HIDWORD(v18);
  *(_BYTE *)(v22 + 216) = 0;
  v23 = *(_DWORD *)(v22 + 312);
  v24 = *(void (**)(_QWORD))(v22 + 224);
  if (v24)
    v24(*(_QWORD *)(v21 + 320 * HIDWORD(v18) + 288));
  if (_setjmp((int *)v22))
  {
    v25 = *__error();
    v26 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v81 = 136315394;
      *(_QWORD *)&v81[4] = "SIOpenIndex";
      *(_WORD *)&v81[12] = 1024;
      *(_DWORD *)&v81[14] = 12581;
      _os_log_error_impl(&dword_1B8270000, v26, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", v81, 0x12u);
    }
    *__error() = v25;
    *(_DWORD *)(v22 + 312) = v23;
    CIOnThreadCleanUpReset(v73);
    dropThreadId(v76, 1, v17);
    CICleanUpReset(v76, v74);
    v27 = 0xFFFFFFFFLL;
    v28 = (int **)a1;
    goto LABEL_74;
  }
  v71 = *a7;
  v72 = *((_QWORD *)a7 + 2);
  Current = CFAbsoluteTimeGetCurrent();
  v30 = a8;
  if (a8)
  {
    v31 = *(void (**)(_QWORD))(a8 + 24);
    *(_QWORD *)(a8 + 24) = 0;
  }
  else
  {
    v31 = 0;
  }
  v28 = (int **)a1;
  v78 = 0;
  if (a6)
  {
    v86 = 0;
    v84 = 0u;
    v85 = 0u;
    v82 = 0u;
    v83 = 0u;
    memset(v81, 0, sizeof(v81));
    *(_OWORD *)buf = v71;
    *(_QWORD *)&buf[16] = v72;
    v32 = _SIOpenIndex(a1, a2, v66, a4, a5, (uint64_t)v81, (uint64_t)buf, a8, a9, &v78, a10);
    v68 = v31;
    if ((v32 & 0x80000000) != 0)
    {
      v40 = *__error();
      if (!v40)
        v40 = -1;
      v41 = v78 != 0;
      v42 = v40 == 28;
      if (v41 && v42)
        v43 = 0;
      else
        v43 = v78;
      v78 = v43;
      if (v41 && v42)
        v38 = 28;
      else
        v38 = v40;
    }
    else
    {
      v33 = *((_QWORD *)&v83 + 1);
      a6[8] = v83;
      v34 = *(_QWORD *)&v81[8];
      v35 = *(_OWORD *)&v81[16];
      a6[6] = *(_QWORD *)v81;
      a6[7] = *((_QWORD *)&v35 + 1);
      v36 = *((_QWORD *)&v82 + 1);
      a6[4] = v82;
      a6[5] = v33;
      v37 = v86;
      a6[2] = v84;
      a6[3] = v34;
      *a6 = v35;
      a6[1] = v36;
      a6[11] = v37;
      v38 = -1;
    }
    v44 = v17;
    v77 = -1;
    if ((_DWORD)a2 == -1 || (fd_setDir(a2, (int *)&v77) & 1) == 0)
    {
      v45 = v23;
      v46 = 1;
    }
    else
    {
      v45 = v23;
      v46 = 0;
    }
    v47 = *__error();
    v48 = _SILogForLogForCategory(11);
    v49 = 2 * (dword_1EF19FCB8 < 4);
    if (os_log_type_enabled(v48, v49))
    {
      if (__si_error_str_key)
        v50 = pthread_getspecific(__si_error_str_key);
      else
        v50 = 0;
      *(_DWORD *)buf = 134218498;
      *(_QWORD *)&buf[4] = v70;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v32;
      *(_WORD *)&buf[18] = 2080;
      *(_QWORD *)&buf[20] = v50;
      _os_log_impl(&dword_1B8270000, v48, v49, "%p _SIOpenIndex: %d %s", buf, 0x1Cu);
    }
    *__error() = v47;
    if ((v46 & 1) == 0)
    {
      v51 = v77;
      MEMORY[0x1BCCB1484](v77);
      if ((v51 & 0x80000000) == 0)
        close(v51);
    }
    v39 = v32;
    v23 = v45;
    v17 = v44;
    v30 = a8;
    v31 = v68;
    if (a8)
      goto LABEL_40;
  }
  else
  {
    v38 = -1;
    v39 = 4294967294;
    if (a8)
LABEL_40:
      *(_QWORD *)(v30 + 24) = v31;
  }
  if ((v39 & 0x80000000) == 0)
  {
    if ((a5 & 0xC) == 0)
    {
      v52 = *v70;
      if (*v70)
      {
        v53 = SICopyProperty(*v70, CFSTR("kSIRepairSizes"));
        if (!v53)
        {
          if ((*(_DWORD *)(v52 + 6584) & 0x180000) != 0x100000)
          {
            v54 = SICopyProperty(v52, CFSTR("kSIConsistencyCheck"));
            if (!v54)
              goto LABEL_55;
            CFRelease(v54);
          }
          si_repair_sizes(v52);
          goto LABEL_55;
        }
        CFRelease(v53);
      }
    }
LABEL_55:
    bumpWorkTime(*v70, Current);
    if ((_DWORD)v39 != 1 && *(_BYTE *)(*v70 + 2072))
    {
      v55 = *(_QWORD *)(*v70 + 1384);
      v56 = *(_DWORD *)(v55 + 8);
      if (v56 >= 2)
      {
        v57 = count_IndexSet(v55, v56 - 2, 1);
        analytics_send_event_lazy();
        if (v57 <= 3 && (v57 != 3 || gSISystemOnBattery))
        {
          if (v57 == 3)
          {
            v65 = *(_QWORD *)(*v70 + 2360);
            if (v65)
            {
              if (*(_QWORD *)(v65 + 80))
              {
                *(_QWORD *)v81 = MEMORY[0x1E0C809B0];
                *(_QWORD *)&v81[8] = 0x40000000;
                *(_QWORD *)&v81[16] = __OpenIndex_block_invoke_3;
                *(_QWORD *)&v81[24] = &__block_descriptor_tmp_831;
                *(_QWORD *)&v82 = 3;
                analytics_send_event_lazy();
                (*(void (**)(_QWORD, _QWORD, const __CFString *, void *))(*(_QWORD *)(*v70 + 2360) + 80))(*(_QWORD *)(*(_QWORD *)(*v70 + 2360) + 136), 0, CFSTR("IndexOpenCompact"), &__block_literal_global_835);
              }
            }
          }
        }
        else
        {
          *(_QWORD *)v81 = MEMORY[0x1E0C809B0];
          *(_QWORD *)&v81[8] = 0x40000000;
          *(_QWORD *)&v81[16] = __OpenIndex_block_invoke_2;
          *(_QWORD *)&v81[24] = &__block_descriptor_tmp_829;
          *(_QWORD *)&v82 = v57;
          analytics_send_event_lazy();
          setupAndIssueMergeCleanup(*v70, *(_QWORD *)(**(_QWORD **)(*v70 + 1384)+ 8 * (*(_DWORD *)(*(_QWORD *)(*v70 + 1384) + 8) - 2)), 0);
        }
        v58 = count_UncompactedIndexSet(*(_QWORD *)(*v70 + 1384), *(_DWORD *)(*(_QWORD *)(*v70 + 1384) + 8) - 2);
        if (v58)
        {
          if (gSISystemOnBattery && (v59 = *(_QWORD *)(*v70 + 2360)) != 0 && *(_QWORD *)(v59 + 80))
          {
            *(_QWORD *)buf = MEMORY[0x1E0C809B0];
            *(_QWORD *)&buf[8] = 0x40000000;
            *(_QWORD *)&buf[16] = __OpenIndex_block_invoke_5;
            *(_QWORD *)&buf[24] = &__block_descriptor_tmp_837;
            v80 = v58;
            analytics_send_event_lazy();
            (*(void (**)(_QWORD, _QWORD, const __CFString *, void *))(*(_QWORD *)(*v70 + 2360) + 80))(*(_QWORD *)(*(_QWORD *)(*v70 + 2360) + 136), 0, CFSTR("IndexOpenCompact"), &__block_literal_global_839);
          }
          else
          {
            *(_QWORD *)buf = MEMORY[0x1E0C809B0];
            *(_QWORD *)&buf[8] = 0x40000000;
            *(_QWORD *)&buf[16] = __OpenIndex_block_invoke_8;
            *(_QWORD *)&buf[24] = &__block_descriptor_tmp_843;
            v80 = v58;
            analytics_send_event_lazy();
            setupAndIssueMergeCleanup(*v70, *(_QWORD *)(**(_QWORD **)(*v70 + 1384)+ 8 * (*(_DWORD *)(*(_QWORD *)(*v70 + 1384) + 8) - 2)), 0);
          }
        }
      }
      v60 = CleanupWritableIndexes(*(_QWORD *)(*v70 + 1384));
      if ((CleanupWritableIndexes(*(_QWORD *)(*v70 + 1392)) & 1) != 0 || v60)
        SISyncIndex(*v70);
    }
    goto LABEL_71;
  }
  if ((_DWORD)v39 == -1 && v31)
  {
    v31(v30);
LABEL_50:
    *__error() = v38;
    goto LABEL_71;
  }
  if ((_DWORD)v39 == -1)
    goto LABEL_50;
LABEL_71:
  v61 = *(_QWORD *)&threadData[18 * v76 + 2];
  v62 = v61 + 320 * v75;
  *(_DWORD *)(v62 + 312) = v23;
  v63 = *(void (**)(_QWORD))(v62 + 232);
  if (v63)
    v63(*(_QWORD *)(v61 + 320 * v75 + 288));
  dropThreadId(v76, 0, v17);
  v27 = v39;
LABEL_74:
  _si_log_indexes(*v28);
  return v27;
}

uint64_t si_repair_sizes(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  unsigned int v3;
  int v4;
  unint64_t v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  void (*v11)(_QWORD);
  int v12;
  int v13;
  NSObject *v14;
  NSObject *v15;
  const __CFAllocator *v16;
  const void *Mutable;
  const void *v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  CFStringRef v23;
  int v24;
  NSObject *v25;
  uint64_t v26;
  unsigned int v27;
  uint64_t v28;
  void (*v29)(_QWORD);
  int v30;
  _QWORD v31[8];
  _QWORD v32[4];
  unint64_t v33;
  unsigned int v34;
  unsigned int v35;
  unint64_t v36;
  unsigned int v37;
  unsigned int v38;
  unsigned int v39;
  uint8_t v40[4];
  unint64_t v41;
  __int16 v42;
  unint64_t v43;
  _BYTE buf[24];
  uint64_t v45;
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)(result + 1184))
  {
    v1 = result;
    if (!*(_BYTE *)(result + 1280))
    {
      v2 = *(_QWORD *)(result + 2360);
      if (v2)
      {
        if (*(_QWORD *)(v2 + 40))
        {
          v39 = 0;
          result = fd_setDir(*(unsigned int *)(result + 32), (int *)&v39);
          if ((_DWORD)result)
          {
            do
            {
              v3 = __ldxr(exceptionSequenceNum);
              v4 = v3 + 1;
            }
            while (__stxr(v3 + 1, exceptionSequenceNum));
            v5 = setThreadIdAndInfo(*(_DWORD *)(v1 + 32), sFdExceptionCallbacks, 0, 1, v4);
            v37 = HIDWORD(v5);
            v38 = v5;
            v36 = __PAIR64__(v6, v7);
            v8 = *(_QWORD *)&threadData[18 * v5 + 2];
            v9 = v8 + 320 * HIDWORD(v5);
            *(_BYTE *)(v9 + 216) = 0;
            v10 = *(_DWORD *)(v9 + 312);
            v11 = *(void (**)(_QWORD))(v9 + 224);
            if (v11)
              v11(*(_QWORD *)(v8 + 320 * HIDWORD(v5) + 288));
            v35 = v38;
            v34 = v37;
            v33 = v36;
            v12 = _setjmp((int *)v9);
            v13 = *__error();
            if (v12)
            {
              v14 = _SILogForLogForCategory(0);
              if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136315394;
                *(_QWORD *)&buf[4] = "si_repair_sizes";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = 16667;
                _os_log_error_impl(&dword_1B8270000, v14, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
              }
              *__error() = v13;
              *(_DWORD *)(v9 + 312) = v10;
              CIOnThreadCleanUpReset(v33);
              dropThreadId(v35, 1, v4);
              CICleanUpReset(v35, HIDWORD(v33));
            }
            else
            {
              v15 = _SILogForLogForCategory(4);
              if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)buf = 0;
                _os_log_impl(&dword_1B8270000, v15, OS_LOG_TYPE_DEFAULT, "Gathering size data for repair", buf, 2u);
              }
              *__error() = v13;
              v16 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
              Mutable = (const void *)RLEOIDArrayCreateMutable((const __CFAllocator *)*MEMORY[0x1E0C9AE00]);
              v18 = (const void *)RLEOIDArrayCreateMutable(v16);
              *(_QWORD *)buf = 0;
              *(_QWORD *)&buf[8] = buf;
              *(_QWORD *)&buf[16] = 0x2000000000;
              v45 = 0;
              v32[0] = 0;
              v32[1] = v32;
              v32[2] = 0x2000000000;
              v32[3] = 0;
              v19 = *(_QWORD *)(v1 + 1392);
              v20 = *(_QWORD *)(v1 + 1384);
              v31[0] = MEMORY[0x1E0C809B0];
              v31[1] = 0x40000000;
              v31[2] = __si_repair_sizes_block_invoke;
              v31[3] = &unk_1E6E2D888;
              v31[6] = Mutable;
              v31[7] = v18;
              v31[4] = v32;
              v31[5] = buf;
              ContentIndexListsApply(v19, v20, (uint64_t)v31);
              v21 = si_repair_size_for_oids(v1);
              CFRelease(v18);
              v22 = si_repair_size_for_oids(v1);
              CFRelease(Mutable);
              v23 = CFStringCreateWithCString(v16, (const char *)sysVersionCStr, 0x8000100u);
              si_set_property(v1, CFSTR("kSIRepairSizes"), v23, 1, 0);
              CFRelease(v23);
              v24 = *__error();
              v25 = _SILogForLogForCategory(4);
              if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)v40 = 134218240;
                v41 = v21;
                v42 = 2048;
                v43 = v22;
                _os_log_impl(&dword_1B8270000, v25, OS_LOG_TYPE_DEFAULT, "Gathering size data for repair (%lld, %lld)", v40, 0x16u);
              }
              *__error() = v24;
              v26 = *(_QWORD *)&threadData[18 * v35 + 2];
              v27 = v34;
              v28 = v26 + 320 * v34;
              *(_DWORD *)(v28 + 312) = v10;
              v29 = *(void (**)(_QWORD))(v28 + 232);
              if (v29)
                v29(*(_QWORD *)(v26 + 320 * v27 + 288));
              dropThreadId(v35, 0, v4);
              _Block_object_dispose(v32, 8);
              _Block_object_dispose(buf, 8);
            }
            v30 = v39;
            result = MEMORY[0x1BCCB1484](v39);
            if ((v30 & 0x80000000) == 0)
              return close(v30);
          }
        }
      }
    }
  }
  return result;
}

void setupAndIssueMergeCleanup(uint64_t a1, int a2, NSObject *a3)
{
  BOOL v6;
  uint64_t *v7;
  int v8;
  BOOL v9;
  int v10;
  unsigned int v11;
  int v12;
  unsigned int v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  char v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  char v25;
  char v26;
  uint64_t v27;
  unsigned int v28;
  BOOL v29;
  int v30;
  unsigned int v31;
  char *v32;
  _DWORD *v33;
  uint64_t v34;
  uint64_t (*v35)(_QWORD, const char *, uint64_t, const char *);
  int v36;
  int v37;

  v36 = a2;
  v37 = 0;
  v6 = si_needsVaccuum(*(uint64_t **)(a1 + 1384), &v36, &v37);
  v7 = *(uint64_t **)(a1 + 1384);
  v8 = *((_DWORD *)v7 + 2);
  if (!v8)
    return;
  v9 = v6;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = v8 - 1;
  v16 = 8 * (v8 - 1);
  while (1)
  {
    v17 = *(_QWORD *)(*v7 + v16);
    if (*(_DWORD *)(v17 + 48) != a2)
    {
      v17 = v14;
      goto LABEL_8;
    }
    v18 = atomic_load((unsigned int *)(v17 + 28));
    if ((v18 & 3) == 0 && !*(_BYTE *)(v17 + 15163))
      break;
    v12 = *(_DWORD *)(v17 + 32);
    v10 = 1;
    v13 = v15;
    v11 = v15;
    v14 = *(_QWORD *)(*v7 + v16);
LABEL_8:
    v16 -= 8;
    if (--v15 == -1)
    {
      if (!v10)
        return;
      goto LABEL_10;
    }
  }
  v13 = v15;
  v11 = v15;
  if (!v10)
    return;
LABEL_10:
  v19 = *((unsigned int *)v7 + 2);
  v20 = *v7;
  if ((_DWORD)v19)
  {
    while (1)
    {
      v21 = (v19 - 1);
      if (*(_DWORD *)(*(_QWORD *)(v20 + 8 * v21) + 32) == v12)
        break;
      --v19;
      if (!v21)
        goto LABEL_25;
    }
    v22 = 0;
    v23 = 1;
    v13 = v19;
    while (v19 + v22)
    {
      v24 = *(_QWORD *)(*v7 + 8 * (v19 + v22 - 1));
      if (*(_DWORD *)(v24 + 32) == v12
        || *(_DWORD *)(v24 + 44) == *(_DWORD *)(v17 + 44)
        || (v25 = atomic_load((unsigned int *)(v24 + 28)), (v25 & 4) == 0))
      {
        ++v23;
        v13 = v19 - 1 + v22;
      }
      v26 = atomic_load((unsigned int *)(v24 + 28));
      if ((v26 & 3) == 0 && !*(_BYTE *)(v24 + 15163))
        break;
      --v22;
    }
    if (v23)
    {
      v20 = *v7;
      goto LABEL_25;
    }
  }
  else
  {
LABEL_25:
    v27 = *(_QWORD *)(v20 + 8 * v13);
    v28 = v11 + 1;
    if (v27)
      v29 = v28 == v13;
    else
      v29 = 1;
    if (!v29)
    {
      v30 = *(_DWORD *)(v27 + 48);
      v31 = v28 - v13;
      v32 = (char *)malloc_type_calloc(1uLL, 0x460uLL, 0x1070040C187FD8AuLL);
      *(_QWORD *)v32 = a1;
      v32[16] = 1;
      v32[1041] = v9;
      *((_DWORD *)v32 + 2) = v30;
      *((_DWORD *)v32 + 3) = v31;
      v32[1042] = 0;
      *((_QWORD *)v32 + 131) = "void setupAndIssueMergeCleanup(SIRef, int32_t, _Bool, xpc_activity_t, _Bool *, dispatch_group_t)";
      *((_DWORD *)v32 + 274) = 9;
      v32[1100] = 1;
      __strlcpy_chk();
      v33 = v32 + 1064;
      si_power_info_init((uint64_t)(v32 + 1064), 0, 0, a3);
      if (!*((_QWORD *)v32 + 136) && !*v33)
      {
        v34 = *(_QWORD *)(a1 + 2360);
        if (v34)
        {
          v35 = *(uint64_t (**)(_QWORD, const char *, uint64_t, const char *))(v34 + 64);
          if (v35)
            *v33 = v35(*(_QWORD *)(v34 + 136), "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 8632, "void setupAndIssueMergeCleanup(SIRef, int32_t, _Bool, xpc_activity_t, _Bool *, dispatch_group_t)");
        }
      }
      si_enqueue_work(*(_QWORD *)(a1 + 1056), (uint64_t)si_mergeIndex, (uint64_t)v32);
    }
  }
}

uint64_t count_UncompactedIndexSet(uint64_t a1, unsigned int a2)
{
  unsigned int v2;
  unsigned int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  char v7;
  char v8;

  v2 = *(_DWORD *)(a1 + 8);
  if (v2 <= a2)
    return 0;
  v3 = 0;
  if ((a2 & 0x80000000) == 0)
  {
    v4 = 1;
    v5 = a2;
    do
    {
      v6 = *(_QWORD *)(*(_QWORD *)a1 + 8 * v5);
      v7 = atomic_load((unsigned int *)(v6 + 28));
      if ((v7 & 3) == 0 && !*(_BYTE *)(v6 + 15163))
        break;
      v8 = atomic_load((unsigned int *)(*(_QWORD *)(*(_QWORD *)a1 + 8 * v5) + 28));
      if ((v8 & 4) == 0)
        v3 = v4;
      ++v4;
    }
    while (v5-- > 0);
    v2 = *(_DWORD *)(a1 + 8);
  }
  if (v2 >= v3)
    return v3;
  else
    return v2;
}

uint64_t CleanupWritableIndexes(uint64_t a1)
{
  uint64_t v2;
  char v3;
  uint64_t v4;
  char v5;
  unint64_t v6;

  if (*(_DWORD *)(a1 + 8) < 2u)
  {
    v3 = 0;
  }
  else
  {
    v2 = 0;
    v3 = 0;
    do
    {
      v4 = *(_QWORD *)(*(_QWORD *)a1 + 8 * v2);
      v5 = atomic_load((unsigned int *)(v4 + 28));
      if ((v5 & 3) == 0 && !*(_BYTE *)(v4 + 15163))
      {
        _CIDisableUpdates(*(_QWORD *)(*(_QWORD *)a1 + 8 * v2));
        v3 = 1;
      }
      v6 = v2 + 2;
      ++v2;
    }
    while (v6 < *(unsigned int *)(a1 + 8));
  }
  return v3 & 1;
}

uint64_t __si_repair_sizes_block_invoke(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  int v5;
  unint64_t v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  void (*v12)(_QWORD);
  int v13;
  NSObject *v14;
  int v15;
  NSObject *v16;
  os_log_type_t v17;
  uint64_t v18;
  uint64_t v19;
  char v20;
  int v21;
  uint64_t i;
  int v23;
  unsigned int v24;
  BOOL v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  void (*v30)(_QWORD);
  uint64_t v32;
  int v33;
  unsigned int v34;
  unsigned int v35;
  unsigned int v36;
  unsigned int v37;
  uint8_t buf[4];
  const char *v39;
  __int16 v40;
  int v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a2 + 8))
  {
    do
    {
      v4 = __ldxr(exceptionSequenceNum);
      v5 = v4 + 1;
    }
    while (__stxr(v4 + 1, exceptionSequenceNum));
    v6 = setThreadIdAndInfo(-1, (__int128 *)sIndexExceptionCallbacks, a2, 0, v5);
    v36 = HIDWORD(v6);
    v37 = v6;
    v34 = v8;
    v35 = v7;
    v9 = *(_QWORD *)&threadData[18 * v6 + 2];
    v10 = v9 + 320 * HIDWORD(v6);
    *(_BYTE *)(v10 + 216) = 0;
    v11 = *(_DWORD *)(v10 + 312);
    v12 = *(void (**)(_QWORD))(v10 + 224);
    if (v12)
      v12(*(_QWORD *)(v9 + 320 * HIDWORD(v6) + 288));
    if (_setjmp((int *)v10))
    {
      v13 = *__error();
      v14 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        v39 = "si_repair_sizes_block_invoke";
        v40 = 1024;
        v41 = 16651;
        _os_log_error_impl(&dword_1B8270000, v14, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
      }
      *__error() = v13;
      *(_DWORD *)(v10 + 312) = v11;
      CIOnThreadCleanUpReset(v34);
      dropThreadId(v37, 1, v5);
      CICleanUpReset(v37, v35);
    }
    else
    {
      v33 = v11;
      v18 = *(_QWORD *)(a2 + 14392);
      if (v18)
      {
        v32 = *(_QWORD *)(a2 + 14368);
        if (v32)
        {
          v19 = *(unsigned int *)(a2 + 60);
          if (v19 >= 2)
          {
            v20 = 6;
            v21 = *(unsigned __int8 *)(a2 + 37);
            for (i = 1; i != v19; ++i)
            {
              if (v21)
                v23 = *(unsigned __int8 *)(v18 + i);
              else
                v23 = (*(_DWORD *)(v18 + (((3435973837u * (unint64_t)i) >> 32) & 0xFFFFFFFC)) >> (v20 - 30 * (i / 5))) & 0x3F;
              v24 = v23 & 0xFFFFFFDF;
              if (v24)
              {
                v25 = v24 == 17;
                v26 = 56;
                if (v25)
                {
                  v26 = 48;
                  v27 = 32;
                }
                else
                {
                  v27 = 40;
                }
                SIValueSet<unsigned long long>::SIValueSetInsert((unint64_t *)(*(_QWORD *)(a1 + v26) + 216), *(_QWORD *)(v32 + 8 * i));
                ++*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + v27) + 8) + 24);
              }
              v20 += 6;
            }
          }
        }
      }
      v28 = *(_QWORD *)&threadData[18 * v37 + 2];
      v29 = v28 + 320 * v36;
      *(_DWORD *)(v29 + 312) = v33;
      v30 = *(void (**)(_QWORD))(v29 + 232);
      if (v30)
        v30(*(_QWORD *)(v28 + 320 * v36 + 288));
      dropThreadId(v37, 0, v5);
    }
  }
  else
  {
    v15 = *__error();
    v16 = _SILogForLogForCategory(0);
    v17 = 2 * (gSILogLevels[0] < 4);
    if (os_log_type_enabled(v16, v17))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1B8270000, v16, v17, "Skipping because index is shut down", buf, 2u);
    }
    *__error() = v15;
  }
  return 1;
}

unint64_t si_repair_size_for_oids(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  _BYTE v14[8192];
  uint64_t v15;

  v1 = MEMORY[0x1E0C80A78](a1);
  v15 = *MEMORY[0x1E0C80C00];
  if (!v2)
    return 0;
  v4 = v3;
  v5 = *(_QWORD *)(v1 + 2360);
  v6 = RLEOIDIteratorCreate(v2);
  bzero(v14, 0x2000uLL);
  v7 = 0;
  do
  {
    v8 = RLEOIDIteratorNext((_BYTE **)v6, (uint64_t)v14, 1024);
    if (!v8)
      break;
    v9 = v8;
    v10 = (uint64_t *)v14;
    v11 = v8;
    do
    {
      v12 = *v10++;
      (*(void (**)(_QWORD, uint64_t, uint64_t, uint64_t))(v5 + 40))(*(_QWORD *)(v5 + 136), v12, 3, 1);
      --v11;
    }
    while (v11);
    v7 += v9;
  }
  while (v7 <= v4);
  RLEOIDIteratorDestroy(v6);
  return v7;
}

void SICalculateSize(uint64_t a1, void (*a2)(uint64_t, _QWORD), uint64_t a3)
{
  uint64_t v4;
  _QWORD *v6;

  v4 = *(_QWORD *)(a1 + 1016);
  if (v4)
  {
    v6 = malloc_type_malloc(0x18uLL, 0xA00402214FCE6uLL);
    v6[2] = a3;
    *v6 = a1;
    v6[1] = a2;
    si_enqueue_work(v4, (uint64_t)si_get_size, (uint64_t)v6);
  }
  else
  {
    a2(a3, 0);
  }
}

void si_get_size(_QWORD *a1, int a2)
{
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v14;
  int *v15;
  off_t v16;
  int v17;
  NSObject *v18;
  gid_t v19;
  char *v20;
  char *v21;
  const char *v22;
  stat v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v3 = 0;
    goto LABEL_25;
  }
  v4 = (_QWORD *)*a1;
  v5 = *(_QWORD *)(*a1 + 1392);
  v6 = *(_QWORD *)(*a1 + 1384);
  if (v5 && *(int *)(v5 + 8) >= 1)
  {
    v7 = 0;
    v3 = 0;
    do
      v3 += index_calculate_size(*(_QWORD *)(*(_QWORD *)v5 + 8 * v7++), 6);
    while (v7 < *(int *)(v5 + 8));
    if (!v6)
      goto LABEL_13;
  }
  else
  {
    v3 = 0;
    if (!v6)
      goto LABEL_13;
  }
  if (*(int *)(v6 + 8) >= 1)
  {
    v8 = 0;
    do
      v3 += index_calculate_size(*(_QWORD *)(*(_QWORD *)v6 + 8 * v8++), 6);
    while (v8 < *(int *)(v6 + 8));
  }
LABEL_13:
  v9 = v4[148];
  if (v9)
  {
    if (*(_DWORD *)v9 != 1685287992)
    {
      v17 = *__error();
      v18 = _SILogForLogForCategory(4);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        v19 = *(_DWORD *)v9;
        v23.st_dev = 136315650;
        *(_QWORD *)&v23.st_mode = "db_get_size";
        WORD2(v23.st_ino) = 1024;
        *(_DWORD *)((char *)&v23.st_ino + 6) = 258;
        HIWORD(v23.st_uid) = 1024;
        v23.st_gid = v19;
        _os_log_error_impl(&dword_1B8270000, v18, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", (uint8_t *)&v23, 0x18u);
      }
      *__error() = v17;
      v20 = __si_assert_copy_extra_268();
      v21 = v20;
      if (v20)
        v22 = v20;
      else
        v22 = "";
      __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 258, v22);
      free(v21);
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    memset(&v23, 0, sizeof(v23));
    v10 = *(_QWORD *)(v9 + 848);
    if (!v10)
      goto LABEL_23;
    while (1)
    {
      v11 = fstatat(*(_DWORD *)(v10 + 44), *(const char **)(v10 + 72), &v23, 2048);
      v12 = g_prot_error_callback;
      if (v11 != -1 || g_prot_error_callback == 0)
        break;
      v14 = *(unsigned int *)(v10 + 40);
      v15 = __error();
      if (((*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t))(v12 + 16))(v12, v14, *v15, 8) & 1) == 0)
        goto LABEL_23;
    }
    if (!v11)
      v16 = 2 * v23.st_size;
    else
LABEL_23:
      v16 = 0;
    v3 += v16;
  }
LABEL_25:
  ((void (*)(_QWORD, uint64_t))a1[1])(a1[2], v3);
  free(a1);
}

uint64_t doFastFlushIndex(uint64_t a1)
{
  int v2;
  int8x16_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  CFNumberRef v7;
  CFNumberRef v8;
  pthread_mutex_t *v9;
  unsigned int v10;
  int v11;
  unint64_t v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  void (*v17)(_QWORD);
  _DWORD *v18;
  int v19;
  NSObject *v20;
  unsigned int v21;
  int v22;
  unint64_t v23;
  unsigned int v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  void (*v28)(_QWORD);
  int v29;
  NSObject *v30;
  uint64_t v31;
  void (*v32)(_QWORD);
  uint64_t v33;
  int v34;
  uint64_t v35;
  void (*v36)(_QWORD);
  int v37;
  NSObject *v38;
  uint64_t v39;
  uint64_t v40;
  void (*v41)(_QWORD);
  uint64_t v42;
  uint64_t v43;
  void (*v44)(_QWORD);
  int v45;
  int v47;
  int v48;
  unsigned int v49;
  unsigned int v50;
  unsigned int v51;
  unsigned int v52;
  unsigned int v53;
  unsigned int v54;
  unsigned int v55;
  unsigned int v56;
  unsigned int v57;
  uint64_t valuePtr;
  int8x16_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  _BYTE buf[32];
  __int128 v67;
  __int128 v68;
  int8x16_t *v69;
  uint64_t v70;

  v70 = *MEMORY[0x1E0C80C00];
  v2 = getiopolicy_np(0, 1);
  setiopolicy_np(0, 1, 1);
  v63 = 1;
  v3 = *(int8x16_t **)(a1 + 2360);
  v59 = vextq_s8(*v3, *v3, 8uLL);
  v4 = *(_QWORD *)(a1 + 1184);
  v60 = v3[8].i64[1];
  v61 = v4;
  v5 = *(_QWORD *)(a1 + 1392);
  v62 = a1;
  v64 = v5;
  v6 = *(_QWORD *)(a1 + 1384);
  v65 = v6;
  valuePtr = 0;
  valuePtr = *(_QWORD *)(a1 + 2136);
  v7 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt64Type, &valuePtr);
  if (v7)
  {
    v8 = v7;
    si_set_property(a1, CFSTR("ConsumedJournalSerialNumber"), v7, 1, 0);
    CFRelease(v8);
  }
  v9 = (pthread_mutex_t *)(a1 + 1568);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1568));
  v57 = 0;
  if (fd_setDir(*(unsigned int *)(a1 + 32), (int *)&v57))
  {
    do
    {
      v10 = __ldxr(exceptionSequenceNum);
      v11 = v10 + 1;
    }
    while (__stxr(v10 + 1, exceptionSequenceNum));
    v12 = setThreadIdAndInfo(*(_DWORD *)(a1 + 32), sFdExceptionCallbacks, 0, 1, v11);
    v55 = HIDWORD(v12);
    v56 = v12;
    v53 = v14;
    v54 = v13;
    v15 = *(_QWORD *)&threadData[18 * v12 + 2];
    v16 = v15 + 320 * HIDWORD(v12);
    *(_BYTE *)(v16 + 216) = 0;
    v48 = *(_DWORD *)(v16 + 312);
    v17 = *(void (**)(_QWORD))(v16 + 224);
    if (v17)
      v17(*(_QWORD *)(v15 + 320 * HIDWORD(v12) + 288));
    if (_setjmp((int *)v16))
    {
      v18 = (_DWORD *)(v16 + 312);
      v19 = *__error();
      v20 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)&buf[4] = "doFastFlushIndex";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 1992;
        _os_log_error_impl(&dword_1B8270000, v20, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
      }
      *__error() = v19;
      *v18 = v48;
      CIOnThreadCleanUpReset(v53);
      dropThreadId(v56, 1, v11);
      CICleanUpReset(v56, v54);
    }
    else
    {
      do
      {
        v21 = __ldxr(exceptionSequenceNum);
        v22 = v21 + 1;
      }
      while (__stxr(v21 + 1, exceptionSequenceNum));
      v23 = setThreadIdAndInfo(-1, (__int128 *)sSDBExceptionCallbacks, *(_QWORD *)(a1 + 1184), 0x40000000, v22);
      v51 = HIDWORD(v23);
      v52 = v23;
      v49 = v25;
      v50 = v24;
      v26 = *(_QWORD *)&threadData[18 * v23 + 2];
      v27 = v26 + 320 * HIDWORD(v23);
      *(_BYTE *)(v27 + 216) = 0;
      v47 = *(_DWORD *)(v27 + 312);
      v28 = *(void (**)(_QWORD))(v27 + 224);
      if (v28)
        v28(*(_QWORD *)(v26 + 320 * HIDWORD(v23) + 288));
      if (_setjmp((int *)v27))
      {
        v29 = *__error();
        v30 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315394;
          *(_QWORD *)&buf[4] = "doFastFlushIndex";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 1991;
          _os_log_error_impl(&dword_1B8270000, v30, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
        }
        *__error() = v29;
        *(_DWORD *)(v27 + 312) = v47;
        CIOnThreadCleanUpReset(v49);
        dropThreadId(v52, 1, v22);
        CICleanUpReset(v52, v50);
      }
      else
      {
        _si_store_propery_cache(a1, 0, 1);
        si_storesizes(a1, 0);
        v31 = *(_QWORD *)(a1 + 2360);
        if (v31)
        {
          v32 = *(void (**)(_QWORD))(v31 + 48);
          if (v32)
            v32(*(_QWORD *)(v31 + 136));
        }
        v33 = *(_QWORD *)(a1 + 6592);
        *(_OWORD *)buf = xmmword_1E6E2DC80;
        *(_OWORD *)&buf[16] = *(_OWORD *)&off_1E6E2DC90;
        v67 = xmmword_1E6E2DCA0;
        v68 = *(_OWORD *)off_1E6E2DCB0;
        v69 = &v59;
        v34 = _ContentIndexSyncIndexBulk(a1 + 1192, v5, v6, 4, (uint64_t)buf, v33, 0, 0);
        v35 = *(_QWORD *)(a1 + 2360);
        if (v35)
        {
          v36 = *(void (**)(_QWORD))(v35 + 56);
          if (v36)
            v36(*(_QWORD *)(v35 + 136));
        }
        if (v34)
        {
          v37 = *__error();
          v38 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315650;
            *(_QWORD *)&buf[4] = "doFastFlushIndex";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 1989;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v34;
            _os_log_error_impl(&dword_1B8270000, v38, OS_LOG_TYPE_ERROR, "%s:%d: ContentIndexSyncIndexBulk err:%d", buf, 0x18u);
          }
          *__error() = v37;
        }
        v39 = *(_QWORD *)&threadData[18 * v52 + 2];
        v40 = v39 + 320 * v51;
        *(_DWORD *)(v40 + 312) = v47;
        v41 = *(void (**)(_QWORD))(v40 + 232);
        if (v41)
          v41(*(_QWORD *)(v39 + 320 * v51 + 288));
        dropThreadId(v52, 0, v22);
      }
      v42 = *(_QWORD *)&threadData[18 * v56 + 2];
      v43 = v42 + 320 * v55;
      *(_DWORD *)(v43 + 312) = v48;
      v44 = *(void (**)(_QWORD))(v43 + 232);
      if (v44)
        v44(*(_QWORD *)(v42 + 320 * v55 + 288));
      dropThreadId(v56, 0, v11);
    }
    v45 = v57;
    MEMORY[0x1BCCB1484](v57);
    if ((v45 & 0x80000000) == 0)
      close(v45);
  }
  pthread_mutex_unlock(v9);
  return setiopolicy_np(0, 1, v2);
}

void si_setstorecookie(uint64_t a1, CFTypeRef cf)
{
  const void *v4;
  const __CFUUID *v5;
  _DWORD *indexmetadata;
  uint64_t v7;
  unsigned int v8;
  int v9;
  unint64_t v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  void (*v16)(_QWORD);
  int v17;
  NSObject *v18;
  void *v19;
  __n128 v20;
  BOOL v21;
  int updated;
  int v23;
  NSObject *v24;
  os_log_type_t v25;
  uint64_t v26;
  uint64_t v27;
  void (*v28)(_QWORD);
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  unsigned int v32;
  unint64_t v33;
  _QWORD *v34;
  void *v35;
  uint8_t buf[4];
  const char *v37;
  __int16 v38;
  int v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  v4 = *(const void **)(a1 + 1440);
  if (!v4 || !CFEqual(v4, cf))
  {
    v5 = (const __CFUUID *)CFRetain(cf);
    *(_QWORD *)(a1 + 1440) = v5;
    *(CFUUIDBytes *)(a1 + 1424) = CFUUIDGetUUIDBytes(v5);
    if (*(_QWORD *)(a1 + 1184))
    {
      if (!*(_BYTE *)(a1 + 1280))
      {
        indexmetadata = si_create_indexmetadata(a1, 1);
        v35 = indexmetadata;
        if (indexmetadata)
        {
          v7 = (uint64_t)indexmetadata;
          v33 = 0;
          v34 = 0;
          do
          {
            v8 = __ldxr(exceptionSequenceNum);
            v9 = v8 + 1;
          }
          while (__stxr(v8 + 1, exceptionSequenceNum));
          v10 = setThreadIdAndInfo(-1, (__int128 *)sSDBExceptionCallbacks, *(_QWORD *)(a1 + 1184), 0x40000000, v9);
          v31 = HIDWORD(v10);
          v32 = v10;
          v29 = v12;
          v30 = v11;
          v13 = *(_QWORD *)&threadData[18 * v10 + 2];
          v14 = v13 + 320 * HIDWORD(v10);
          *(_BYTE *)(v14 + 216) = 0;
          v15 = *(_DWORD *)(v14 + 312);
          v16 = *(void (**)(_QWORD))(v14 + 224);
          if (v16)
            v16(*(_QWORD *)(v13 + 320 * HIDWORD(v10) + 288));
          if (_setjmp((int *)v14))
          {
            v17 = *__error();
            v18 = _SILogForLogForCategory(0);
            if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136315394;
              v37 = "si_setstorecookie";
              v38 = 1024;
              v39 = 1266;
              _os_log_error_impl(&dword_1B8270000, v18, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
            }
            *__error() = v17;
            *(_DWORD *)(v14 + 312) = v15;
            CIOnThreadCleanUpReset(v29);
            dropThreadId(v32, 1, v9);
            CICleanUpReset(v32, v30);
            v19 = (void *)v7;
          }
          else
          {
            if (db_get_field(*(int **)(a1 + 1184), v7, "kMDStoreUUID", &v33, &v34)
              || *(_DWORD *)(v33 + 8) != 16
              || (*(_QWORD *)(a1 + 1424) == *v34 ? (v21 = *(_QWORD *)(a1 + 1432) == v34[1]) : (v21 = 0), !v21))
            {
              updated = db_add_field(*(int **)(a1 + 1184), (_DWORD **)&v35, 1u, "kMDStoreUUID", 0, 0x108u, 14, (unsigned __int8 *)(a1 + 1424), v20, 16);
              if (updated || (updated = db_update_obj(*(int **)(a1 + 1184), (uint64_t)v35, 12)) != 0)
              {
                v23 = *__error();
                v24 = _SILogForLogForCategory(7);
                v25 = dword_1EF19FCA8 < 3;
                if (os_log_type_enabled(v24, (os_log_type_t)(dword_1EF19FCA8 < 3)))
                {
                  *(_DWORD *)buf = 67109120;
                  LODWORD(v37) = updated;
                  _os_log_impl(&dword_1B8270000, v24, v25, "*warn* Failed setting store cookie (%d)", buf, 8u);
                }
                *__error() = v23;
              }
              else
              {
                db_dirty_datastore(*(int **)(a1 + 1184));
              }
            }
            v26 = *(_QWORD *)&threadData[18 * v32 + 2];
            v27 = v26 + 320 * v31;
            *(_DWORD *)(v27 + 312) = v15;
            v28 = *(void (**)(_QWORD))(v27 + 232);
            if (v28)
              v28(*(_QWORD *)(v26 + 320 * v31 + 288));
            dropThreadId(v32, 0, v9);
            v19 = v35;
          }
          free(v19);
        }
      }
    }
  }
}

BOOL SIHasPersistentStoreCookie(uint64_t a1)
{
  return *(_QWORD *)(a1 + 1184) != 0;
}

uint64_t SIProcessTerminating()
{
  CFIndex Count;
  uint64_t v3;
  size_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  void *child_queue;
  uint64_t v10;
  _QWORD v11[2];

  v11[1] = *MEMORY[0x1E0C80C00];
  while (!__ldxr((unsigned int *)&gTerminating))
  {
    if (!__stxr(1u, (unsigned int *)&gTerminating))
      goto LABEL_6;
  }
  __clrex();
LABEL_6:
  gProcessTerminating = 1;
  pthread_mutex_lock(&schlock);
  if (!gShutdownGroup)
  {
    gShutdownGroup = (uint64_t)dispatch_group_create();
    if (global_schedulers[0])
    {
      Count = CFDictionaryGetCount((CFDictionaryRef)global_schedulers[0]);
      if (Count)
      {
        v3 = Count;
        v4 = 8 * Count;
        MEMORY[0x1E0C80A78](Count);
        v5 = (_QWORD *)((char *)v11 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0));
        bzero(v5, v4);
        MEMORY[0x1E0C80A78](v6);
        v7 = v5;
        bzero(v5, v4);
        CFDictionaryGetKeysAndValues((CFDictionaryRef)global_schedulers[0], (const void **)v5, (const void **)v5);
        if (v3 >= 1)
        {
          do
          {
            dispatch_group_enter((dispatch_group_t)gShutdownGroup);
            v8 = *v7++;
            child_queue = si_create_child_queue(v8);
            v10 = *v5++;
            si_enqueue_work_with_qos((uint64_t)child_queue, 25, (uint64_t)si_spindle_shutdown, v10);
            --v3;
          }
          while (v3);
        }
      }
    }
  }
  return pthread_mutex_unlock(&schlock);
}

void si_spindle_shutdown(uint64_t a1, int a2)
{
  CFIndex Count;
  size_t v4;
  char *v5;
  uint64_t v6;
  int64_t v7;
  uint64_t v8;
  void *v9;
  _QWORD v10[2];

  v10[1] = *MEMORY[0x1E0C80C00];
  if (a2)
    goto LABEL_2;
  pthread_mutex_lock(&schlock);
  if (!gAllIndexes)
  {
    pthread_mutex_unlock(&schlock);
    goto LABEL_2;
  }
  Count = CFSetGetCount((CFSetRef)gAllIndexes);
  MEMORY[0x1E0C80A78](Count);
  v5 = (char *)v10 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v5, v4);
  CFSetGetValues((CFSetRef)gAllIndexes, (const void **)v5);
  if (Count < 1)
  {
    v7 = 0;
  }
  else
  {
    v6 = 0;
    v7 = 0;
    do
    {
      v8 = *(_QWORD *)&v5[8 * v6];
      if (*(_DWORD *)(v8 + 1404) == a1)
      {
        *(_QWORD *)&v5[8 * v7] = v8;
        CFSetRemoveValue((CFMutableSetRef)gAllIndexes, *(const void **)&v5[8 * v6]);
        ++v7;
      }
      ++v6;
    }
    while (Count != v6);
    if (v7)
    {
      v9 = malloc_type_malloc(8 * v7, 0x80040B8603338uLL);
      memcpy(v9, v5, 8 * v7);
      goto LABEL_16;
    }
  }
  v9 = 0;
LABEL_16:
  pthread_mutex_unlock(&schlock);
  if (v9)
  {
    _SIShutdownIndexBulk((int *)v9, v7);
    free(v9);
  }
LABEL_2:
  if (gShutdownGroup)
    dispatch_group_leave((dispatch_group_t)gShutdownGroup);
}

int *_SIShutdownIndexBulk(int *result, int64_t a2)
{
  int64_t v2;
  uint64_t *v3;
  uint64_t v4;
  int v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  size_t v13;
  double Current;
  int v15;
  NSObject *v16;
  os_log_type_t v17;
  char *v18;
  uint64_t *v19;
  char *v20;
  uint64_t i;
  uint64_t v22;
  int v23;
  NSObject *v24;
  os_log_type_t v25;
  CFAbsoluteTime v26;
  __int128 v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  int v32;
  unint64_t v33;
  unsigned int v34;
  unsigned int v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  void (*v39)(_QWORD);
  int v40;
  NSObject *v41;
  uint64_t v42;
  uint64_t v43;
  unsigned int v44;
  uint64_t v45;
  void (*v46)(_QWORD);
  int v47;
  int v48;
  NSObject *v49;
  os_log_type_t v50;
  int v51;
  NSObject *v52;
  os_log_type_t v53;
  CFAbsoluteTime v54;
  __int128 v55;
  int v56;
  NSObject *v57;
  CFAbsoluteTime v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t *v62;
  unsigned int v63;
  int v64;
  unint64_t v65;
  unsigned int v66;
  unsigned int v67;
  uint64_t v68;
  uint64_t v69;
  int v70;
  void (*v71)(_QWORD);
  int v72;
  NSObject *v73;
  uint64_t v74;
  unsigned int v75;
  uint64_t v76;
  void (*v77)(_QWORD);
  uint64_t v78;
  int v79;
  NSObject *v80;
  os_log_type_t v81;
  CFAbsoluteTime v82;
  __int128 v83;
  int v84;
  NSObject *v85;
  os_log_type_t v86;
  CFAbsoluteTime v87;
  uint64_t v88;
  uint64_t v89;
  unsigned int v90;
  int v91;
  unint64_t v92;
  unsigned int v93;
  int v94;
  uint64_t v95;
  uint64_t v96;
  int v97;
  void (*v98)(_QWORD);
  int v99;
  NSObject *v100;
  uint64_t v101;
  unsigned int v102;
  uint64_t v103;
  void (*v104)(_QWORD);
  int v105;
  NSObject *v106;
  os_log_type_t v107;
  CFAbsoluteTime v108;
  _DWORD *v109;
  uint64_t *v110;
  char *v111;
  int64_t v112;
  uint64_t v113;
  void (*v114)(uint64_t, _BYTE *);
  uint64_t v115;
  __int128 v116;
  __int128 v117;
  __int128 v118;
  uint64_t *v119;
  int64_t v120;
  int v121;
  NSObject *v122;
  os_log_type_t v123;
  CFAbsoluteTime v124;
  _DWORD *v125;
  _DWORD *v126;
  uint64_t v127;
  BOOL v128;
  CFAbsoluteTime v129;
  char *v130;
  char *v131;
  const char *v132;
  uint64_t v133;
  __int128 v134;
  unsigned int v135;
  unsigned int v136;
  __int128 v137;
  __int128 v138;
  unsigned int v139;
  unsigned int v140;
  unsigned int v141;
  unsigned int v142;
  char *v143;
  char *v144;
  char *v145;
  uint64_t *v146;
  char *v147;
  int v148;
  __int128 *v149;
  unint64_t v150;
  unsigned int v151;
  unsigned int v152;
  unint64_t v153;
  unsigned int v154;
  unsigned int v155;
  uint64_t v156;
  _QWORD block[9];
  int v158;
  _BYTE buf[32];
  __int128 v160;
  __int128 v161;
  __int128 v162;
  __int128 v163;
  uint64_t v164;
  uint64_t v165;

  v165 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v2 = a2;
    v3 = (uint64_t *)result;
    v149 = &v134;
    v4 = *(_QWORD *)result;
    v5 = *(_DWORD *)(*(_QWORD *)result + 1404);
    v148 = v5;
    v6 = *(_DWORD *)(v4 + 6584);
    v7 = MEMORY[0x1E0C80A78](result);
    v9 = (char *)&v134 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0);
    v10 = MEMORY[0x1E0C80A78](v7);
    MEMORY[0x1E0C80A78](v10);
    v12 = (char *)&v134 - v11;
    bzero(v9, v13);
    bzero((char *)&v134 - ((8 * v2 + 15) & 0xFFFFFFFFFFFFFFF0), 8 * v2);
    v144 = v12;
    bzero(v12, 104 * v2);
    Current = CFAbsoluteTimeGetCurrent();
    v15 = *__error();
    v16 = _SILogForLogForCategory(11);
    v17 = 2 * (dword_1EF19FCB8 < 4);
    if (os_log_type_enabled(v16, v17))
    {
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)&buf[4] = v148;
      *(_WORD *)&buf[8] = 1024;
      *(_DWORD *)&buf[10] = v2;
      _os_log_impl(&dword_1B8270000, v16, v17, "shut down starting for spindle:%d count:%d", buf, 0xEu);
    }
    v18 = v9;
    v19 = (uint64_t *)((char *)&v134 - ((8 * v2 + 15) & 0xFFFFFFFFFFFFFFF0));
    v20 = v144;
    *__error() = v15;
    if ((v6 & 0x40000) != 0)
    {
      v47 = v148;
      if (!exc_pthread_key[0])
        pthread_key_create(exc_pthread_key, 0);
      block[0] = MEMORY[0x1E0C809B0];
      block[1] = 0x40000000;
      block[2] = ___SIShutdownIndexBulk_block_invoke;
      block[3] = &__block_descriptor_tmp_929;
      v158 = v47;
      block[4] = v3;
      block[5] = (char *)&v134 - ((8 * v2 + 15) & 0xFFFFFFFFFFFFFFF0);
      block[6] = v20;
      block[7] = v2;
      block[8] = v18;
      dispatch_apply(v2, 0, block);
      v48 = *__error();
      v49 = _SILogForLogForCategory(11);
      v50 = 2 * (dword_1EF19FCB8 < 4);
      if (!os_log_type_enabled(v49, v50))
        goto LABEL_104;
    }
    else
    {
      if (v2 >= 1)
      {
        for (i = 0; i != v2; ++i)
        {
          if (v5 != *(_DWORD *)(*v3 + 1404))
          {
            v130 = __si_assert_copy_extra_521(-1);
            v131 = v130;
            v132 = "";
            if (v130)
              v132 = v130;
            __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 14750, "indexSpindleId==si_indices[0]->indexSpindleId", v132);
            free(v131);
            if (__valid_fs(-1))
              v133 = 2989;
            else
              v133 = 3072;
            *(_DWORD *)v133 = -559038737;
            abort();
          }
          v22 = v3[i];
          if (!*(_BYTE *)(v22 + 1280))
            v19[i] = (uint64_t)_SIShutdownSetup(v22);
        }
      }
      v145 = v20;
      v23 = *__error();
      v24 = _SILogForLogForCategory(11);
      v25 = 2 * (dword_1EF19FCB8 < 4);
      if (os_log_type_enabled(v24, v25))
      {
        v26 = CFAbsoluteTimeGetCurrent();
        *(_DWORD *)buf = 67109376;
        *(_DWORD *)&buf[4] = v148;
        *(_WORD *)&buf[8] = 2048;
        *(double *)&buf[10] = v26 - Current;
        _os_log_impl(&dword_1B8270000, v24, v25, "shutdown setup complete for spindle:%d after %f seconds.", buf, 0x12u);
      }
      v147 = v18;
      *__error() = v23;
      v146 = (uint64_t *)((char *)&v134 - ((8 * v2 + 15) & 0xFFFFFFFFFFFFFFF0));
      if (v2 < 1)
      {
        v42 = 0;
      }
      else
      {
        v28 = 0;
        v141 = 72;
        v139 = 320;
        *(_QWORD *)&v27 = 136315394;
        v137 = v27;
        v29 = 0;
        do
        {
          v30 = v19[v28];
          if (v30)
          {
            v156 = 0;
            do
            {
              v31 = __ldxr(exceptionSequenceNum);
              v32 = v31 + 1;
            }
            while (__stxr(v31 + 1, exceptionSequenceNum));
            v155 = 0;
            v154 = 0;
            v153 = 0;
            v33 = setThreadIdAndInfo(*(_DWORD *)(v3[v28] + 32), sFdExceptionCallbacks, 0, 1, v32);
            v154 = HIDWORD(v33);
            v155 = v33;
            v153 = __PAIR64__(v34, v35);
            v36 = *(_QWORD *)((char *)&threadData[2] + v33 * (unint64_t)v141);
            v37 = v36 + HIDWORD(v33) * (unint64_t)v139;
            *(_BYTE *)(v37 + 216) = 0;
            v38 = *(_DWORD *)(v37 + 312);
            v39 = *(void (**)(_QWORD))(v37 + 224);
            if (v39)
              v39(*(_QWORD *)(v36 + 320 * HIDWORD(v33) + 288));
            v152 = v155;
            v151 = v154;
            v150 = v153;
            if (_setjmp((int *)v37))
            {
              v40 = *__error();
              v41 = _SILogForLogForCategory(0);
              if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = v137;
                *(_QWORD *)&buf[4] = "_SIShutdownIndexBulk";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = 14763;
                _os_log_error_impl(&dword_1B8270000, v41, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
              }
              *__error() = v40;
              *(_DWORD *)(v37 + 312) = v38;
              CIOnThreadCleanUpReset(v150);
              dropThreadId(v152, 1, v32);
              CICleanUpReset(v152, HIDWORD(v150));
              v19 = v146;
            }
            else
            {
              _CISyncContextSync(v30, &v156);
              v43 = *(_QWORD *)&threadData[18 * v152 + 2];
              v44 = v151;
              v45 = v43 + 320 * v151;
              *(_DWORD *)(v45 + 312) = v38;
              v46 = *(void (**)(_QWORD))(v45 + 232);
              if (v46)
                v46(*(_QWORD *)(v43 + 320 * v44 + 288));
              dropThreadId(v152, 0, v32);
            }
            if (v29)
              v42 = v29;
            else
              v42 = v156;
          }
          else
          {
            v42 = v29;
          }
          ++v28;
          v29 = v42;
        }
        while (v28 != v2);
      }
      v51 = *__error();
      v52 = _SILogForLogForCategory(11);
      v53 = 2 * (dword_1EF19FCB8 < 4);
      if (os_log_type_enabled(v52, v53))
      {
        v54 = CFAbsoluteTimeGetCurrent();
        *(_DWORD *)buf = 67109376;
        *(_DWORD *)&buf[4] = v148;
        *(_WORD *)&buf[8] = 2048;
        *(double *)&buf[10] = v54 - Current;
        _os_log_impl(&dword_1B8270000, v52, v53, "shutdown sync complete for spindle:%d after %f seconds.", buf, 0x12u);
      }
      *__error() = v51;
      if (v42)
      {
        fd_sync(v42, 1);
        v56 = *__error();
        v57 = _SILogForLogForCategory(11);
        if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
        {
          v58 = CFAbsoluteTimeGetCurrent();
          *(_DWORD *)buf = 67109376;
          *(_DWORD *)&buf[4] = v148;
          *(_WORD *)&buf[8] = 2048;
          *(double *)&buf[10] = v58 - Current;
          _os_log_impl(&dword_1B8270000, v57, OS_LOG_TYPE_DEFAULT, "shutdown sync-fsync for spindle:%d after %f seconds.", buf, 0x12u);
        }
        *__error() = v56;
      }
      if (v2 < 1)
      {
        v78 = 0;
      }
      else
      {
        v143 = &v144[104 * v2];
        v142 = 72;
        v140 = 320;
        *(_QWORD *)&v55 = 136315394;
        v138 = v55;
        v59 = 0;
        v60 = 0;
        do
        {
          v61 = v60;
          v62 = (uint64_t *)v19[v60];
          if (v62)
          {
            v156 = 0;
            do
            {
              v63 = __ldxr(exceptionSequenceNum);
              v64 = v63 + 1;
            }
            while (__stxr(v63 + 1, exceptionSequenceNum));
            v155 = 0;
            v154 = 0;
            v153 = 0;
            v65 = setThreadIdAndInfo(*(_DWORD *)(v3[v61] + 32), sFdExceptionCallbacks, 0, 1, v64);
            v154 = HIDWORD(v65);
            v155 = v65;
            v153 = __PAIR64__(v66, v67);
            v68 = *(_QWORD *)((char *)&threadData[2] + v65 * (unint64_t)v142);
            v69 = v68 + HIDWORD(v65) * (unint64_t)v140;
            *(_BYTE *)(v69 + 216) = 0;
            v70 = *(_DWORD *)(v69 + 312);
            v71 = *(void (**)(_QWORD))(v69 + 224);
            if (v71)
              v71(*(_QWORD *)(v68 + 320 * HIDWORD(v65) + 288));
            v152 = v155;
            v151 = v154;
            v150 = v153;
            if (_setjmp((int *)v69))
            {
              v72 = *__error();
              v73 = _SILogForLogForCategory(0);
              if (os_log_type_enabled(v73, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = v138;
                *(_QWORD *)&buf[4] = "_SIShutdownIndexBulk";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = 14779;
                _os_log_error_impl(&dword_1B8270000, v73, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
              }
              *__error() = v72;
              *(_DWORD *)(v69 + 312) = v70;
              CIOnThreadCleanUpReset(v150);
              dropThreadId(v152, 1, v64);
              CICleanUpReset(v152, HIDWORD(v150));
            }
            else
            {
              _CISyncContextCommitData(v62, &v156, (uint64_t)v143);
              v74 = *(_QWORD *)&threadData[18 * v152 + 2];
              v75 = v151;
              v76 = v74 + 320 * v151;
              *(_DWORD *)(v76 + 312) = v70;
              v77 = *(void (**)(_QWORD))(v76 + 232);
              if (v77)
                v77(*(_QWORD *)(v74 + 320 * v75 + 288));
              dropThreadId(v152, 0, v64);
            }
            v19 = v146;
            if (!v59)
              v59 = v156;
          }
          v60 = v61 + 1;
          v78 = v59;
        }
        while (v60 != v2);
      }
      v79 = *__error();
      v80 = _SILogForLogForCategory(11);
      v81 = 2 * (dword_1EF19FCB8 < 4);
      if (os_log_type_enabled(v80, v81))
      {
        v82 = CFAbsoluteTimeGetCurrent();
        *(_DWORD *)buf = 67109376;
        *(_DWORD *)&buf[4] = v148;
        *(_WORD *)&buf[8] = 2048;
        *(double *)&buf[10] = v82 - Current;
        _os_log_impl(&dword_1B8270000, v80, v81, "shutdown commit data complete for spindle:%d after %f seconds.", buf, 0x12u);
      }
      *__error() = v79;
      if (v78)
      {
        fd_sync(v78, 1);
        v84 = *__error();
        v85 = _SILogForLogForCategory(11);
        v86 = 2 * (dword_1EF19FCB8 < 4);
        if (os_log_type_enabled(v85, v86))
        {
          v87 = CFAbsoluteTimeGetCurrent();
          *(_DWORD *)buf = 67109376;
          *(_DWORD *)&buf[4] = v148;
          *(_WORD *)&buf[8] = 2048;
          *(double *)&buf[10] = v87 - Current;
          _os_log_impl(&dword_1B8270000, v85, v86, "shutdown commit-fsync for spindle:%d after %f seconds.", buf, 0x12u);
        }
        *__error() = v84;
      }
      if (v2 >= 1)
      {
        v88 = 0;
        v136 = 72;
        v135 = 320;
        *(_QWORD *)&v83 = 136315394;
        v134 = v83;
        do
        {
          v89 = v19[v88];
          if (v89)
          {
            do
            {
              v90 = __ldxr(exceptionSequenceNum);
              v91 = v90 + 1;
            }
            while (__stxr(v90 + 1, exceptionSequenceNum));
            LODWORD(v156) = 0;
            v155 = 0;
            v154 = 0;
            HIDWORD(v153) = 0;
            v92 = setThreadIdAndInfo(*(_DWORD *)(v3[v88] + 32), sFdExceptionCallbacks, 0, 1, v91);
            v155 = HIDWORD(v92);
            LODWORD(v156) = v92;
            v154 = v93;
            HIDWORD(v153) = v94;
            v95 = *(_QWORD *)((char *)&threadData[2] + v92 * (unint64_t)v136);
            v96 = v95 + HIDWORD(v92) * (unint64_t)v135;
            *(_BYTE *)(v96 + 216) = 0;
            v97 = *(_DWORD *)(v96 + 312);
            v98 = *(void (**)(_QWORD))(v96 + 224);
            if (v98)
              v98(*(_QWORD *)(v95 + 320 * HIDWORD(v92) + 288));
            LODWORD(v153) = v156;
            v152 = v155;
            v151 = v154;
            HIDWORD(v150) = HIDWORD(v153);
            if (_setjmp((int *)v96))
            {
              v99 = *__error();
              v100 = _SILogForLogForCategory(0);
              if (os_log_type_enabled(v100, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = v134;
                *(_QWORD *)&buf[4] = "_SIShutdownIndexBulk";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = 14794;
                _os_log_error_impl(&dword_1B8270000, v100, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
              }
              *__error() = v99;
              *(_DWORD *)(v96 + 312) = v97;
              CIOnThreadCleanUpReset(HIDWORD(v150));
              dropThreadId(v153, 1, v91);
              CICleanUpReset(v153, v151);
              v19 = v146;
            }
            else
            {
              _CISyncContextCommitHeader(v89);
              v101 = *(_QWORD *)&threadData[18 * v153 + 2];
              v102 = v152;
              v103 = v101 + 320 * v152;
              *(_DWORD *)(v103 + 312) = v97;
              v104 = *(void (**)(_QWORD))(v103 + 232);
              if (v104)
                v104(*(_QWORD *)(v101 + 320 * v102 + 288));
              dropThreadId(v153, 0, v91);
            }
          }
          ++v88;
        }
        while (v88 != v2);
      }
      v105 = *__error();
      v106 = _SILogForLogForCategory(11);
      v107 = 2 * (dword_1EF19FCB8 < 4);
      if (os_log_type_enabled(v106, v107))
      {
        v108 = CFAbsoluteTimeGetCurrent();
        *(_DWORD *)buf = 67109376;
        *(_DWORD *)&buf[4] = v148;
        *(_WORD *)&buf[8] = 2048;
        *(double *)&buf[10] = v108 - Current;
        _os_log_impl(&dword_1B8270000, v106, v107, "shutdown commit header complete for spindle:%d after %f seconds.", buf, 0x12u);
      }
      *__error() = v105;
      v109 = v147;
      if (v2 >= 1)
      {
        v110 = v19;
        v111 = v145;
        v112 = v2;
        do
        {
          v113 = *v110;
          if (*v110)
          {
            if (!*(_DWORD *)(v113 + 168))
            {
              v114 = *(void (**)(uint64_t, _BYTE *))(v113 + 72);
              if (v114)
              {
                if (CIDocCountsNonEmpty(v111))
                {
                  v115 = *(_QWORD *)(v113 + 80);
                  v116 = *((_OWORD *)v111 + 5);
                  v162 = *((_OWORD *)v111 + 4);
                  v163 = v116;
                  v164 = *((_QWORD *)v111 + 12);
                  v117 = *((_OWORD *)v111 + 1);
                  *(_OWORD *)buf = *(_OWORD *)v111;
                  *(_OWORD *)&buf[16] = v117;
                  v118 = *((_OWORD *)v111 + 3);
                  v160 = *((_OWORD *)v111 + 2);
                  v161 = v118;
                  v114(v115, buf);
                }
              }
            }
          }
          v111 += 104;
          ++v110;
          --v112;
        }
        while (v112);
        v119 = v146;
        v120 = v2;
        v109 = v147;
        do
        {
          if (*v119)
            _CISyncContextDestroy(*v119);
          ++v119;
          --v120;
        }
        while (v120);
      }
      v121 = *__error();
      v122 = _SILogForLogForCategory(11);
      v123 = 2 * (dword_1EF19FCB8 < 4);
      if (os_log_type_enabled(v122, v123))
      {
        v124 = CFAbsoluteTimeGetCurrent();
        *(_DWORD *)buf = 67109376;
        *(_DWORD *)&buf[4] = v148;
        *(_WORD *)&buf[8] = 2048;
        *(double *)&buf[10] = v124 - Current;
        _os_log_impl(&dword_1B8270000, v122, v123, "shut down complete for spindle:%d after %f seconds.", buf, 0x12u);
      }
      *__error() = v121;
      if (v2 >= 1)
      {
        v125 = v109;
        do
        {
          v126 = v125;
          v127 = *v3++;
          _SIShutdownComplete(v127);
          *v126 = 0;
          v125 = v126 + 1;
          --v2;
        }
        while (v2);
      }
      v48 = *__error();
      v49 = _SILogForLogForCategory(11);
      v50 = 2 * (dword_1EF19FCB8 < 4);
      v128 = os_log_type_enabled(v49, v50);
      v47 = v148;
      if (!v128)
        goto LABEL_104;
    }
    v129 = CFAbsoluteTimeGetCurrent();
    *(_DWORD *)buf = 67109376;
    *(_DWORD *)&buf[4] = v47;
    *(_WORD *)&buf[8] = 2048;
    *(double *)&buf[10] = v129 - Current;
    _os_log_impl(&dword_1B8270000, v49, v50, "shut down complete for spindle:%d after %f seconds.", buf, 0x12u);
LABEL_104:
    result = __error();
    *result = v48;
  }
  return result;
}

_QWORD *_SIShutdownSetup(uint64_t a1)
{
  int v2;
  BOOL v3;
  _BYTE *v4;
  int v5;
  NSObject *v6;
  os_log_type_t v7;
  int v8;
  double Current;
  CFAbsoluteTime v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  _QWORD *v15;
  int v16;
  NSObject *v17;
  os_log_type_t v18;
  int v19;
  int8x16_t *v20;
  unsigned int v21;
  int v22;
  unint64_t v23;
  unsigned int v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  void (*v29)(_QWORD);
  int v30;
  NSObject *v31;
  int v32;
  int v33;
  NSObject *v34;
  int v35;
  _QWORD *v36;
  uint64_t v37;
  char *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  NSObject *v44;
  os_log_type_t v45;
  CFAbsoluteTime v46;
  uint64_t v47;
  uint64_t v48;
  void (*v49)(_QWORD);
  int8x16_t v51;
  unsigned int v52;
  unsigned int v53;
  unsigned int v54;
  unsigned int v55;
  unsigned int v56;
  _QWORD v57[2];
  uint64_t (*v58)(uint64_t, uint64_t);
  void *v59;
  uint64_t *v60;
  uint64_t v61;
  uint64_t *v62;
  uint64_t v63;
  char v64;
  _BYTE v65[1024];
  _BYTE buf[48];
  __int128 v67;
  char *v68;
  uint64_t v69;

  v69 = *MEMORY[0x1E0C80C00];
  if (a1 && sContactsIndex == a1)
    sContactsIndex = 0;
  bzero(v65, 0x400uLL);
  v2 = fcntl(*(_DWORD *)(a1 + 32), 50, v65);
  if (v65[0])
    v3 = v2 < 0;
  else
    v3 = 1;
  if (v3)
    v4 = 0;
  else
    v4 = v65;
  v5 = *__error();
  v6 = _SILogForLogForCategory(0);
  v7 = 2 * (gSILogLevels[0] < 4);
  if (os_log_type_enabled(v6, v7))
  {
    v8 = *(_DWORD *)(a1 + 32);
    *(_DWORD *)buf = 67109378;
    *(_DWORD *)&buf[4] = v8;
    *(_WORD *)&buf[8] = 2080;
    *(_QWORD *)&buf[10] = v4;
    _os_log_impl(&dword_1B8270000, v6, v7, "Index shut down starting for index at %d %s.", buf, 0x12u);
  }
  *__error() = v5;
  Current = CFAbsoluteTimeGetCurrent();
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 2224));
  v10 = CFAbsoluteTimeGetCurrent();
  activityJournalWriteVInt64(a1 + 2192, 35, (unint64_t)v10);
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 2224));
  *(_DWORD *)(a1 + 2428) = 1;
  v61 = 0;
  v62 = &v61;
  v63 = 0x2000000000;
  v64 = 0;
  v11 = *(_QWORD *)(a1 + 1392);
  v12 = *(_QWORD *)(a1 + 1384);
  v57[0] = MEMORY[0x1E0C809B0];
  v57[1] = 0x40000000;
  v58 = ___SIShutdownSetup_block_invoke;
  v59 = &unk_1E6E2DC60;
  v60 = &v61;
  if (v11 && *(_DWORD *)(v11 + 8))
  {
    v13 = 0;
    while (((unsigned int (*)(_QWORD *, _QWORD, _QWORD))v58)(v57, *(_QWORD *)(*(_QWORD *)v11 + 8 * v13), 0))
    {
      if (++v13 >= (unint64_t)*(unsigned int *)(v11 + 8))
        goto LABEL_17;
    }
  }
  else
  {
LABEL_17:
    if (v12 && *(_DWORD *)(v12 + 8))
    {
      v14 = 0;
      do
      {
        if (!((unsigned int (*)(_QWORD *, _QWORD, uint64_t))v58)(v57, *(_QWORD *)(*(_QWORD *)v12 + 8 * v14), 1))break;
        ++v14;
      }
      while (v14 < *(unsigned int *)(v12 + 8));
    }
  }
  if (*((_BYTE *)v62 + 24))
    goto LABEL_23;
  si_scheduler_boost_and_forget(*(_QWORD *)(a1 + 944));
  si_scheduler_boost_and_forget(*(_QWORD *)(a1 + 864));
  si_scheduler_boost_and_forget(*(_QWORD *)(a1 + 872));
  si_scheduler_boost_and_forget(*(_QWORD *)(a1 + 896));
  si_scheduler_boost_and_forget(*(_QWORD *)(a1 + 912));
  si_scheduler_boost_and_forget(*(_QWORD *)(a1 + 888));
  _SIShutdownIndexSchedulers(a1, 1, 1, Current);
  si_cancel_activectx((void *)a1);
  *(_DWORD *)(a1 + 2420) = 1;
  if (*(_BYTE *)(a1 + 2481) == 4)
  {
    v16 = *__error();
    v17 = _SILogForLogForCategory(11);
    v18 = 2 * (dword_1EF19FCB8 < 4);
    if (os_log_type_enabled(v17, v18))
    {
      v19 = *(_DWORD *)(a1 + 32);
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)&buf[4] = v19;
      *(_WORD *)&buf[8] = 1024;
      *(_DWORD *)&buf[10] = 4;
      _os_log_impl(&dword_1B8270000, v17, v18, "shutdown %d clean %x", buf, 0xEu);
    }
    v15 = 0;
    *__error() = v16;
    goto LABEL_57;
  }
  v20 = (int8x16_t *)(a1 + 1384);
  v56 = 0;
  if (!*(_QWORD *)(a1 + 1184) && !*(_QWORD *)(a1 + 1392) && !v20->i64[0])
  {
LABEL_23:
    v15 = 0;
    goto LABEL_57;
  }
  if (fd_setDir(*(unsigned int *)(a1 + 32), (int *)&v56))
  {
    do
    {
      v21 = __ldxr(exceptionSequenceNum);
      v22 = v21 + 1;
    }
    while (__stxr(v21 + 1, exceptionSequenceNum));
    v23 = setThreadIdAndInfo(*(_DWORD *)(a1 + 32), sFdExceptionCallbacks, 0, 1, v22);
    v54 = HIDWORD(v23);
    v55 = v23;
    v52 = v25;
    v53 = v24;
    v26 = *(_QWORD *)&threadData[18 * v23 + 2];
    v27 = v26 + 320 * HIDWORD(v23);
    *(_BYTE *)(v27 + 216) = 0;
    v28 = *(_DWORD *)(v27 + 312);
    v29 = *(void (**)(_QWORD))(v27 + 224);
    if (v29)
      v29(*(_QWORD *)(v26 + 320 * HIDWORD(v23) + 288));
    if (_setjmp((int *)v27))
    {
      v30 = *__error();
      v31 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)&buf[4] = "_SIShutdownSetup";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 14911;
        _os_log_error_impl(&dword_1B8270000, v31, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
      }
      *__error() = v30;
      *(_DWORD *)(v27 + 312) = v28;
      CIOnThreadCleanUpReset(v52);
      dropThreadId(v55, 1, v22);
      CICleanUpReset(v55, v53);
      goto LABEL_23;
    }
    if (*(_QWORD *)(a1 + 1184))
    {
      _si_store_propery_cache(a1, 0, 0);
      si_storesizes(a1, 0);
    }
    v35 = v56;
    MEMORY[0x1BCCB1484](v56);
    if ((v35 & 0x80000000) == 0)
      close(v35);
    if (*(_BYTE *)(a1 + 1280))
    {
      v36 = 0;
    }
    else
    {
      v37 = *(_QWORD *)(a1 + 1184);
      v51 = *v20;
      v38 = (char *)malloc_type_malloc(0x40uLL, 0x10A0040BD50C579uLL);
      *(_QWORD *)v38 = 0;
      *((_QWORD *)v38 + 1) = 0;
      *((_QWORD *)v38 + 2) = 0;
      *((_QWORD *)v38 + 3) = v37;
      *((_QWORD *)v38 + 4) = a1;
      *((_WORD *)v38 + 20) = 257;
      *(_DWORD *)(v38 + 42) = 0;
      *((_WORD *)v38 + 23) = 0;
      *((int8x16_t *)v38 + 3) = vextq_s8(v51, v51, 8uLL);
      v39 = *(_QWORD *)(a1 + 1392);
      do
      {
        do
        {
          v40 = v39;
          v41 = *(_QWORD *)(a1 + 1384);
          __dmb(0xBu);
          v39 = *(_QWORD *)(a1 + 1392);
        }
        while (v40 != v39);
        v39 = *(_QWORD *)(a1 + 1392);
      }
      while (v41 != v20->i64[0]);
      v42 = *(_QWORD *)(a1 + 6592);
      *(_OWORD *)buf = xmmword_1E6E2DC80;
      *(_OWORD *)&buf[16] = *(_OWORD *)&off_1E6E2DC90;
      *(_OWORD *)&buf[32] = xmmword_1E6E2DCA0;
      v67 = *(_OWORD *)off_1E6E2DCB0;
      v68 = v38;
      v36 = _CISyncContextCreate(a1 + 1192, v40, v41, 2, (uint64_t)buf, v42, 0, 0);
    }
    v43 = *__error();
    v44 = _SILogForLogForCategory(0);
    v45 = 2 * (gSILogLevels[0] < 4);
    if (os_log_type_enabled(v44, v45))
    {
      v46 = CFAbsoluteTimeGetCurrent();
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = v4;
      *(_WORD *)&buf[12] = 2048;
      *(double *)&buf[14] = v46 - Current;
      _os_log_impl(&dword_1B8270000, v44, v45, "Index closed for %s after %f seconds.", buf, 0x16u);
    }
    *__error() = v43;
    v47 = *(_QWORD *)&threadData[18 * v55 + 2];
    v48 = v47 + 320 * v54;
    *(_DWORD *)(v48 + 312) = v28;
    v49 = *(void (**)(_QWORD))(v48 + 232);
    if (v49)
      v49(*(_QWORD *)(v47 + 320 * v54 + 288));
    dropThreadId(v55, 0, v22);
    v15 = v36;
  }
  else
  {
    v32 = *__error();
    v33 = *__error();
    v34 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = "_SIShutdownSetup";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 14914;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v32;
      *(_WORD *)&buf[24] = 2080;
      *(_QWORD *)&buf[26] = v4;
      _os_log_error_impl(&dword_1B8270000, v34, OS_LOG_TYPE_ERROR, "%s:%d: setDir 1 error %d (%s)", buf, 0x22u);
    }
    v15 = 0;
    *__error() = v33;
  }
LABEL_57:
  _Block_object_dispose(&v61, 8);
  return v15;
}

uint64_t _SIShutdownComplete(uint64_t a1)
{
  if (a1 && sContactsIndex == a1)
    sContactsIndex = 0;
  si_cancel_activectx((void *)a1);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1880));
  if (!*(_DWORD *)(a1 + 2416))
  {
    *(_DWORD *)(a1 + 2416) = 1;
    pthread_cond_signal((pthread_cond_t *)(a1 + 1944));
  }
  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1880));
}

_DWORD *SIWaitForAllIndexShutdown()
{
  _DWORD *result;
  double Current;
  int v2;
  NSObject *v3;
  NSObject *v4;
  dispatch_time_t v5;
  intptr_t v6;
  int v7;
  NSObject *v8;
  _BOOL4 v9;
  CFAbsoluteTime v10;
  int v11;
  double v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  result = (_DWORD *)SIProcessTerminating();
  if (gShutdownGroup)
  {
    Current = CFAbsoluteTimeGetCurrent();
    v2 = *__error();
    v3 = _SILogForLogForCategory(11);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v11) = 0;
      _os_log_impl(&dword_1B8270000, v3, OS_LOG_TYPE_DEFAULT, "SIWaitForAllIndexShutdown start", (uint8_t *)&v11, 2u);
    }
    *__error() = v2;
    v4 = gShutdownGroup;
    v5 = dispatch_time(0, 30000000000);
    v6 = dispatch_group_wait(v4, v5);
    v7 = *__error();
    v8 = _SILogForLogForCategory(11);
    v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
    if (v6)
    {
      if (v9)
      {
        LOWORD(v11) = 0;
        _os_log_impl(&dword_1B8270000, v8, OS_LOG_TYPE_DEFAULT, "SIWaitForAllIndexShutdown timeout", (uint8_t *)&v11, 2u);
      }
      *__error() = v7;
      _exit(1);
    }
    if (v9)
    {
      v10 = CFAbsoluteTimeGetCurrent();
      v11 = 134217984;
      v12 = v10 - Current;
      _os_log_impl(&dword_1B8270000, v8, OS_LOG_TYPE_DEFAULT, "SIWaitForAllIndexShutdown complete after %f", (uint8_t *)&v11, 0xCu);
    }
    result = __error();
    *result = v7;
  }
  return result;
}

void SICloseIndex(_QWORD *a1)
{
  int v2;
  NSObject *v3;
  os_log_type_t v4;
  uint64_t i;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  const void *v14;
  const void *v15;
  const void *v16;
  const void *v17;
  const void *v18;
  const void *v19;
  const void *v20;
  int *v21;
  int *v22;
  uint64_t v23;
  const void *v24;
  const void *v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  const void *v36;
  const void *v37;
  const void *v38;
  const void *v39;
  const void *v40;
  const void *v41;
  const void *v42;
  const void *v43;
  _QWORD *v44;
  uint64_t j;
  uint64_t v46;
  unsigned int *v47;
  unsigned int v48;
  unsigned int v49;
  uint64_t v50;
  const void *v51;
  uint64_t v52;
  void (*v53)(void);
  const void *v54;
  const void *v55;
  void **v56;
  uint64_t v57;
  uint64_t v58;
  NSObject *global_queue;
  uint64_t v60;
  _QWORD block[5];
  uint8_t buf[16];
  __int128 v63;
  __int128 v64;
  __int128 v65;
  uint64_t v66;

  v66 = *MEMORY[0x1E0C80C00];
  v2 = *__error();
  v3 = _SILogForLogForCategory(11);
  v4 = 2 * (dword_1EF19FCB8 < 4);
  if (os_log_type_enabled(v3, v4))
  {
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = gTerminating;
    _os_log_impl(&dword_1B8270000, v3, v4, "SICloseIndex, terminating:%d", buf, 8u);
  }
  *__error() = v2;
  if (gTerminating)
  {
    *((_DWORD *)a1 + 605) = 1;
    *(_DWORD *)a1[824] = -1;
  }
  _SICloseIndex((uint64_t)a1, 1);
  si_cancel_activectx(a1);
  dispatch_sync((dispatch_queue_t)freeQueue, &__block_literal_global_937);
  for (i = 104; i != 108; ++i)
    dispatch_release((dispatch_object_t)a1[i]);
  dispatch_release((dispatch_object_t)a1[147]);
  if ((*((_BYTE *)a1 + 828) & 8) != 0)
  {
    if (*((_DWORD *)a1 + 605))
      return;
LABEL_13:
    v7 = a1[8];
    if (v7)
    {
      a1[8] = 0;
      *(_BYTE *)(v7 + 97) = 1;
      if (*(_QWORD *)v7)
      {
        dispatch_source_cancel(*(dispatch_source_t *)v7);
        dispatch_resume(*(dispatch_object_t *)v7);
        dispatch_release(*(dispatch_object_t *)v7);
        dispatch_sync(*(dispatch_queue_t *)(v7 + 8), &__block_literal_global_2696);
        dispatch_release(*(dispatch_object_t *)(v7 + 8));
      }
      free((void *)v7);
    }
    v8 = a1[174];
    v9 = a1[173];
    if (v8)
    {
      LODWORD(v10) = *(_DWORD *)(v8 + 8);
      if ((_DWORD)v10)
      {
        v11 = 0;
        do
        {
          freeIndex(*(_QWORD *)(*(_QWORD *)v8 + 8 * v11++));
          v10 = *(unsigned int *)(v8 + 8);
        }
        while (v11 < v10);
      }
      if (!v9)
        goto LABEL_29;
    }
    else if (!v9)
    {
      goto LABEL_32;
    }
    LODWORD(v12) = *(_DWORD *)(v9 + 8);
    if ((_DWORD)v12)
    {
      v13 = 0;
      do
      {
        freeIndex(*(_QWORD *)(*(_QWORD *)v9 + 8 * v13++));
        v12 = *(unsigned int *)(v9 + 8);
      }
      while (v13 < v12);
    }
    if (!v8)
      goto LABEL_31;
    LODWORD(v10) = *(_DWORD *)(v8 + 8);
LABEL_29:
    bzero(*(void **)v8, 8 * v10);
    *(_DWORD *)(v8 + 8) = 0;
    *(_DWORD *)(v8 + 16) = -1;
    if (v9)
    {
      LODWORD(v12) = *(_DWORD *)(v9 + 8);
LABEL_31:
      bzero(*(void **)v9, 8 * v12);
      *(_DWORD *)(v9 + 8) = 0;
      *(_DWORD *)(v9 + 16) = -1;
    }
LABEL_32:
    v14 = (const void *)a1[225];
    if (v14)
    {
      CFRelease(v14);
      CFRelease((CFTypeRef)a1[226]);
      pthread_mutex_destroy((pthread_mutex_t *)(a1 + 227));
    }
    v15 = (const void *)a1[213];
    if (v15)
      CFRelease(v15);
    v16 = (const void *)a1[827];
    if (v16)
      CFRelease(v16);
    v17 = (const void *)a1[177];
    if (v17)
      CFRelease(v17);
    v18 = (const void *)a1[222];
    if (v18)
      CFRelease(v18);
    v19 = (const void *)a1[223];
    if (v19)
      CFRelease(v19);
    if (!*((_BYTE *)a1 + 2072))
    {
      v20 = (const void *)a1[826];
      if (v20)
        CFRelease(v20);
      a1[826] = 0;
    }
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 214));
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 165));
    ContentIndexListFree((void **)a1[174]);
    ContentIndexListFree((void **)a1[173]);
    v21 = (int *)a1[860];
    if (v21)
      db_release_datastore_no_sync(v21);
    v22 = (int *)a1[148];
    if (v22)
      db_release_datastore_no_sync(v22);
    v23 = a1[828];
    if (v23)
      freeReverseDirStore(v23);
    v24 = (const void *)a1[261];
    if (v24)
      CFRelease(v24);
    a1[261] = 0;
    v25 = (const void *)a1[262];
    if (v25)
      CFRelease(v25);
    a1[262] = 0;
    v26 = *((_OWORD *)a1 + 22);
    *(_OWORD *)buf = *((_OWORD *)a1 + 21);
    v63 = v26;
    v27 = *((_OWORD *)a1 + 24);
    v64 = *((_OWORD *)a1 + 23);
    v65 = v27;
    releaseCommDates((uint64_t)buf);
    v28 = *((_OWORD *)a1 + 26);
    *(_OWORD *)buf = *((_OWORD *)a1 + 25);
    v63 = v28;
    v29 = *((_OWORD *)a1 + 28);
    v64 = *((_OWORD *)a1 + 27);
    v65 = v29;
    releaseCommDates((uint64_t)buf);
    v30 = *((_OWORD *)a1 + 30);
    *(_OWORD *)buf = *((_OWORD *)a1 + 29);
    v63 = v30;
    v31 = *((_OWORD *)a1 + 32);
    v64 = *((_OWORD *)a1 + 31);
    v65 = v31;
    releaseCommDates((uint64_t)buf);
    v32 = *((_OWORD *)a1 + 34);
    *(_OWORD *)buf = *((_OWORD *)a1 + 33);
    v63 = v32;
    v33 = *((_OWORD *)a1 + 36);
    v64 = *((_OWORD *)a1 + 35);
    v65 = v33;
    releaseCommDates((uint64_t)buf);
    v34 = *((_OWORD *)a1 + 38);
    *(_OWORD *)buf = *((_OWORD *)a1 + 37);
    v63 = v34;
    v35 = *((_OWORD *)a1 + 40);
    v64 = *((_OWORD *)a1 + 39);
    v65 = v35;
    releaseCommDates((uint64_t)buf);
    v36 = (const void *)a1[82];
    if (v36)
      CFRelease(v36);
    a1[82] = 0;
    v37 = (const void *)a1[36];
    if (v37)
      CFRelease(v37);
    a1[36] = 0;
    v38 = (const void *)a1[37];
    if (v38)
      CFRelease(v38);
    a1[37] = 0;
    v39 = (const void *)a1[39];
    if (v39)
      CFRelease(v39);
    a1[39] = 0;
    v40 = (const void *)a1[40];
    if (v40)
      CFRelease(v40);
    a1[40] = 0;
    v41 = (const void *)a1[9];
    if (v41)
      CFRelease(v41);
    a1[9] = 0;
    v42 = (const void *)a1[180];
    if (v42)
      CFRelease(v42);
    a1[180] = 0;
    v43 = (const void *)a1[83];
    if (v43)
      CFRelease(v43);
    a1[83] = 0;
    v44 = (_QWORD *)a1[131];
    if (v44 && !*v44)
    {
      si_workqueue_drain(a1[131]);
      si_workqueue_destroy((uint64_t)v44);
    }
    for (j = 0; j != 18; ++j)
    {
      v46 = a1[j + 108];
      if (v46)
      {
        v47 = (unsigned int *)(v46 + 80);
        do
        {
          v48 = __ldaxr(v47);
          v49 = v48 - 1;
        }
        while (__stlxr(v49, v47));
        if (!v49)
          _si_scheduler_destroy(v46);
      }
    }
    v50 = *((unsigned int *)a1 + 351);
    v51 = (const void *)a1[187];
    if (v51)
      CFRelease(v51);
    v52 = a1[295];
    if (v52)
    {
      v53 = *(void (**)(void))(v52 + 24);
      if (v53)
        v53();
    }
    v54 = (const void *)a1[296];
    if (v54)
      CFRelease(v54);
    a1[296] = 0;
    si_deleteExhaustedRemappings((uint64_t)a1, (CFArrayRef)a1[297]);
    a1[297] = 0;
    v55 = (const void *)a1[825];
    if (v55)
      CFRelease(v55);
    a1[825] = 0;
    v56 = (void **)a1[281];
    if (v56)
    {
      free(*v56);
      free(v56[1]);
      free(v56);
    }
    v57 = a1[831];
    if (v57)
      TermUpdateSetRelease(v57);
    pthread_rwlock_destroy((pthread_rwlock_t *)(a1 + 832));
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 235));
    pthread_cond_destroy((pthread_cond_t *)(a1 + 243));
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 188));
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 196));
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 204));
    pthread_mutex_destroy((pthread_mutex_t *)a1 + 109);
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 282));
    free((void *)a1[865]);
    doc_store_close((DocStore *)a1[162]);
    a1[162] = 0;
    if (_os_feature_enabled_impl() && *((_BYTE *)a1 + 2072))
    {
      MDTrieClose();
      a1[161] = 0;
    }
    si_cancel_activectx(a1);
    *a1 = 0;
    if (gFlushSuspendOnceToken != -1)
      dispatch_once(&gFlushSuspendOnceToken, &__block_literal_global_939);
    v58 = MEMORY[0x1E0C809B0];
    *(_QWORD *)buf = MEMORY[0x1E0C809B0];
    *(_QWORD *)&buf[8] = 0x40000000;
    *(_QWORD *)&v63 = ___SIFreeIndex_block_invoke_3;
    *((_QWORD *)&v63 + 1) = &__block_descriptor_tmp_941;
    *(_QWORD *)&v64 = a1;
    dispatch_async((dispatch_queue_t)gFlushSuspendQueue, buf);
    global_queue = dispatch_get_global_queue(-32768, 0);
    block[0] = v58;
    block[1] = 0x40000000;
    block[2] = ___SIFreeIndex_block_invoke_4;
    block[3] = &__block_descriptor_tmp_942;
    block[4] = v50;
    dispatch_async(global_queue, block);
    CIPurgeTokenizers();
    v60 = 240;
    do
    {
      slab_cleanup((void **)v60);
      v60 = (v60 + 1);
    }
    while ((_DWORD)v60 != 255);
    return;
  }
  pthread_mutex_lock(&schlock);
  v6 = *((_DWORD *)a1 + 605);
  if (gAllIndexes)
    CFSetRemoveValue((CFMutableSetRef)gAllIndexes, a1);
  pthread_mutex_unlock(&schlock);
  if (!v6)
    goto LABEL_13;
}

CFDictionaryRef SICopyProperties(uint64_t a1)
{
  pthread_mutex_t *v2;
  const __CFDictionary *v3;
  CFDictionaryRef Copy;

  if (!*(_QWORD *)(a1 + 1184))
    return 0;
  v2 = (pthread_mutex_t *)(a1 + 1504);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1504));
  v3 = *(const __CFDictionary **)(a1 + 1496);
  if (!v3)
  {
    if (!si_create_propertydict(a1, 0, 0))
    {
      Copy = 0;
      goto LABEL_6;
    }
    v3 = *(const __CFDictionary **)(a1 + 1496);
  }
  Copy = CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v3);
LABEL_6:
  pthread_mutex_unlock(v2);
  return Copy;
}

uint64_t SIGetIndexVersion(uint64_t result)
{
  if (result)
    return *(unsigned int *)(result + 6932);
  return result;
}

uint64_t SIGetObjectCount(uint64_t a1)
{
  uint64_t v1;

  if (a1 && (v1 = *(_QWORD *)(a1 + 1184)) != 0)
    return db_get_object_count(v1);
  else
    return -1;
}

uint64_t SISyncIndexForLikelyShutdown(uint64_t result)
{
  if (result)
  {
    if (*(_QWORD *)(result + 1184)
      && *(_QWORD *)(result + 1040)
      && *(_QWORD *)(result + 1048)
      && *(_QWORD *)(result + 1152))
    {
      si_enqueue_barrier_with_qos(*(_QWORD *)(result + 1096), 9, (uint64_t)si_flush_index_for_likely_shutdown_delayed0, result);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void si_flush_index_for_likely_shutdown_delayed0(uint64_t a1, int a2)
{
  if (!a2)
    si_enqueue_barrier_with_qos(*(_QWORD *)(a1 + 1152), 9, (uint64_t)si_flush_index_for_likely_shutdown_delayed1, a1);
}

void si_flush_index_for_likely_shutdown_delayed1(uint64_t a1, int a2)
{
  if (!a2)
    si_enqueue_barrier_with_qos(*(_QWORD *)(a1 + 1048), 9, (uint64_t)si_flush_index_for_likely_shutdown_delayed, a1);
}

void si_flush_index_for_likely_shutdown_delayed(uint64_t a1, int a2)
{
  if (!a2)
    si_enqueue_work_with_qos(*(_QWORD *)(a1 + 1040), 9, (uint64_t)fastFlushIndex, a1);
}

void fastFlushIndex(uint64_t a1, int a2)
{
  void *v3;

  if (!a2)
  {
    v3 = (void *)os_transaction_create();
    doFastFlushIndex(a1);
    os_release(v3);
  }
}

void _SIGetAllOids(uint64_t a1, void (*a2)(uint64_t, _QWORD, uint64_t), uint64_t a3)
{
  _QWORD *v5;

  if (a1 && *(_QWORD *)(a1 + 1184))
  {
    v5 = malloc_type_malloc(0x18uLL, 0xA00402214FCE6uLL);
    v5[2] = a3;
    *v5 = a1;
    v5[1] = a2;
    si_enqueue_work(*(_QWORD *)(a1 + 1040), (uint64_t)si_gatherOids, (uint64_t)v5);
  }
  else
  {
    a2(a3, 0, 1);
  }
}

void si_gatherOids(_QWORD **a1, int a2)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t Mutable;
  unint64_t v7;
  unint64_t v8;
  int v9;
  unsigned int v10;

  if (a2)
  {
    ((void (*)(_QWORD *, _QWORD, uint64_t))a1[1])(a1[2], 0, 1);
  }
  else
  {
    v3 = *a1;
    v4 = (*a1)[173];
    v5 = (*a1)[174];
    Mutable = RLEOIDArrayCreateMutable((const __CFAllocator *)*MEMORY[0x1E0C9AE00]);
    v10 = 0;
    if (fd_setDir(*((unsigned int *)v3 + 8), (int *)&v10))
    {
      if (*(_DWORD *)(v5 + 8))
      {
        v7 = 0;
        do
          _CIAddOids(*(_QWORD *)(*(_QWORD *)v5 + 8 * v7++), Mutable);
        while (v7 < *(unsigned int *)(v5 + 8));
      }
      if (*(_DWORD *)(v4 + 8))
      {
        v8 = 0;
        do
          _CIAddOids(*(_QWORD *)(*(_QWORD *)v4 + 8 * v8++), Mutable);
        while (v8 < *(unsigned int *)(v4 + 8));
      }
      v9 = v10;
      MEMORY[0x1BCCB1484](v10);
      if ((v9 & 0x80000000) == 0)
        close(v9);
    }
    ((void (*)(_QWORD *, uint64_t, uint64_t))a1[1])(a1[2], Mutable, 0);
  }
  free(a1);
}

void _SICheckIndexForDuplicateOids(uint64_t a1)
{
  uint64_t v2;

  if (a1 && *(_QWORD *)(a1 + 1184))
  {
    v2 = *(_QWORD *)(a1 + 1056);
    if (v2)
      si_enqueue_work_with_qos(v2, 9, (uint64_t)si_checkDuplicateOids, a1);
  }
}

void si_checkDuplicateOids(uint64_t a1, int a2)
{
  const __CFArray *v3;

  if (!a2)
  {
    v3 = *(const __CFArray **)(a1 + 2368);
    if (v3 && CFArrayGetCount(v3))
      si_enqueue_work_with_qos(*(_QWORD *)(a1 + 1056), 9, (uint64_t)_si_checkDuplicateOidsAfterCompact, a1);
    else
      _si_checkDuplicateOids(a1);
  }
}

void _si_checkDuplicateOidsAfterCompact(uint64_t a1, int a2)
{
  const __CFArray *v3;
  int v4;
  int v5;
  int v6;
  NSObject *v7;
  os_log_type_t v8;
  BOOL v9;
  _BYTE *v10;
  uint8_t buf[4];
  _BYTE *v12;
  _BYTE v13[1024];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (!a2)
  {
    v3 = *(const __CFArray **)(a1 + 2368);
    if (v3 && CFArrayGetCount(v3))
    {
      bzero(v13, 0x400uLL);
      v4 = fcntl(*(_DWORD *)(a1 + 32), 50, v13);
      v5 = v13[0];
      v6 = *__error();
      v7 = _SILogForLogForCategory(7);
      v8 = dword_1EF19FCA8 < 3;
      if (os_log_type_enabled(v7, (os_log_type_t)(dword_1EF19FCA8 < 3)))
      {
        if (v5)
          v9 = v4 < 0;
        else
          v9 = 1;
        if (v9)
          v10 = 0;
        else
          v10 = v13;
        *(_DWORD *)buf = 136315138;
        v12 = v10;
        _os_log_impl(&dword_1B8270000, v7, v8, "*warn* Skipping duplicate oid check for %s", buf, 0xCu);
      }
      *__error() = v6;
    }
    else
    {
      _si_checkDuplicateOids(a1);
    }
  }
}

void _si_checkDuplicateOids(uint64_t a1)
{
  int v2;
  BOOL v3;
  _BYTE *v4;
  unsigned int *v5;
  unsigned int v6;
  unsigned int v7;
  int v8;
  NSObject *v9;
  os_log_type_t v10;
  const __CFAllocator *v11;
  const void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int v21;
  NSObject *v22;
  os_log_type_t v23;
  uint64_t v24;
  CFStringRef v25;
  _QWORD v26[2];
  uint64_t (*v27)(uint64_t, uint64_t);
  void *v28;
  __int128 *p_buf;
  const void *v30;
  uint8_t v31[4];
  _BYTE *v32;
  __int16 v33;
  int v34;
  __int128 buf;
  uint64_t v36;
  uint64_t v37;
  _BYTE v38[1024];
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  bzero(v38, 0x400uLL);
  v2 = fcntl(*(_DWORD *)(a1 + 32), 50, v38);
  if (v38[0])
    v3 = v2 < 0;
  else
    v3 = 1;
  if (v3)
    v4 = 0;
  else
    v4 = v38;
  si_scheduler_suspend(*(_QWORD *)(a1 + 864));
  v5 = (unsigned int *)(a1 + 1452);
  do
    v6 = __ldaxr(v5);
  while (__stlxr(v6 + 1, v5));
  si_scheduler_suspend(*(_QWORD *)(a1 + 872));
  do
    v7 = __ldaxr(v5);
  while (__stlxr(v7 - 1, v5));
  v8 = *__error();
  v9 = _SILogForLogForCategory(7);
  v10 = dword_1EF19FCA8 < 3;
  if (os_log_type_enabled(v9, (os_log_type_t)(dword_1EF19FCA8 < 3)))
  {
    LODWORD(buf) = 136315138;
    *(_QWORD *)((char *)&buf + 4) = v4;
    _os_log_impl(&dword_1B8270000, v9, v10, "*warn* Starting duplicate oid check for %s", (uint8_t *)&buf, 0xCu);
  }
  *__error() = v8;
  v11 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v12 = (const void *)SIUINT64SetCreate();
  *(_QWORD *)&buf = 0;
  *((_QWORD *)&buf + 1) = &buf;
  v36 = 0x2000000000;
  v37 = 0;
  v13 = *(_QWORD *)(a1 + 1392);
  v14 = *(_QWORD *)(a1 + 1384);
  v26[0] = MEMORY[0x1E0C809B0];
  v26[1] = 0x40000000;
  v27 = ___si_checkDuplicateOids_block_invoke;
  v28 = &unk_1E6E2DF70;
  p_buf = &buf;
  v30 = v12;
  if (v14)
  {
    v15 = *(unsigned int *)(v14 + 8);
    while ((int)v15 >= 1)
    {
      v16 = v15 - 1;
      v17 = ((uint64_t (*)(_QWORD *, _QWORD, uint64_t))v27)(v26, *(_QWORD *)(*(_QWORD *)v14 + 8 * v15 - 8), 1);
      v15 = v16;
      if (!v17)
        goto LABEL_22;
    }
  }
  if (v13)
  {
    v18 = *(unsigned int *)(v13 + 8);
    do
    {
      if ((int)v18 < 1)
        break;
      v19 = v18 - 1;
      v20 = ((uint64_t (*)(_QWORD *, _QWORD, _QWORD))v27)(v26, *(_QWORD *)(*(_QWORD *)v13 + 8 * v18 - 8), 0);
      v18 = v19;
    }
    while (v20);
  }
LABEL_22:
  CFRelease(v12);
  v21 = *__error();
  v22 = _SILogForLogForCategory(7);
  v23 = dword_1EF19FCA8 < 3;
  if (os_log_type_enabled(v22, (os_log_type_t)(dword_1EF19FCA8 < 3)))
  {
    v24 = *(_QWORD *)(*((_QWORD *)&buf + 1) + 24);
    *(_DWORD *)v31 = 136315394;
    v32 = v4;
    v33 = 1024;
    v34 = v24;
    _os_log_impl(&dword_1B8270000, v22, v23, "*warn* Finished duplicate oid check for %s. Missing deletes:%d", v31, 0x12u);
  }
  *__error() = v21;
  si_scheduler_resume(*(_QWORD *)(a1 + 864), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 16436);
  si_scheduler_resume(*(_QWORD *)(a1 + 872), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 16437);
  v25 = CFStringCreateWithCString(v11, (const char *)sysVersionCStr, 0x8000100u);
  SISetProperty(a1, CFSTR("kIndexCheckDupOids"), v25);
  CFRelease(v25);
  _Block_object_dispose(&buf, 8);
}

uint64_t ___si_checkDuplicateOids_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += _CIDeleteDuplicates(a2, *(_QWORD *)(a1 + 40));
  return 1;
}

uint64_t _SIIssueRecovery(uint64_t result)
{
  uint64_t v1;
  int v2;
  NSObject *v3;
  int v4;
  uint8_t buf[4];
  _BYTE *v6;
  _BYTE v7[1024];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (result)
  {
    v1 = result;
    if (*(_QWORD *)(result + 1184))
    {
      bzero(v7, 0x400uLL);
      result = fcntl(*(_DWORD *)(v1 + 32), 50, v7);
      if ((result & 0x80000000) == 0)
      {
        if (v7[0])
        {
          v2 = *__error();
          v3 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315138;
            v6 = v7;
            _os_log_impl(&dword_1B8270000, v3, OS_LOG_TYPE_DEFAULT, "Recovery issued for %s", buf, 0xCu);
          }
          *__error() = v2;
          *(_DWORD *)buf = 0;
          result = fd_setDir(*(unsigned int *)(v1 + 32), (int *)buf);
          if ((_DWORD)result)
          {
            unlink("indexState");
            si_makeUnavailable(v1, 22, 2, 10, (uint64_t)"recovery");
            v4 = *(_DWORD *)buf;
            result = MEMORY[0x1BCCB1484](*(unsigned int *)buf);
            if ((v4 & 0x80000000) == 0)
              return close(v4);
          }
        }
      }
    }
  }
  return result;
}

int *_SISetQueryBehavior(uint64_t a1)
{
  int v1;
  int v2;
  NSObject *v3;
  int *result;
  _DWORD v5[2];
  __int16 v6;
  int v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v1 = gSIQueryBehavior;
  gSIQueryBehavior = a1;
  v2 = *__error();
  v3 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v5[0] = 67109376;
    v5[1] = v1;
    v6 = 1024;
    v7 = gSIQueryBehavior;
    _os_log_impl(&dword_1B8270000, v3, OS_LOG_TYPE_DEFAULT, "_SISetQueryBehavior from %d to %d", (uint8_t *)v5, 0xEu);
  }
  result = __error();
  *result = v2;
  return result;
}

void si_cacheCleanup(_QWORD *a1, int a2)
{
  uint64_t v3;
  uint64_t walk;
  char *v5;
  int v6;
  _QWORD v7[7];
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  char v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (!a2)
  {
    v3 = *a1;
    walk = a1[2];
    if (!walk)
    {
      bzero(&v10, 0x400uLL);
      if (fcntl(*(_DWORD *)(v3 + 32), 50, &v10) < 0 || !(_BYTE)v10)
      {
        walk = a1[2];
        if (!walk)
          goto LABEL_11;
      }
      else
      {
        __strlcat_chk();
        v8 = xmmword_1B862C880;
        v9 = 0;
        fsi_attr_size((uint64_t)&v8);
        walk = fsi_create_walk((uint64_t)&v10);
        a1[2] = walk;
        if (!walk)
          goto LABEL_11;
      }
    }
    if (!**(_DWORD **)(v3 + 6592))
    {
      v10 = 0;
      v11 = &v10;
      v12 = 0x2000000000;
      v13 = 0;
      v7[0] = MEMORY[0x1E0C809B0];
      v7[1] = 0x40000000;
      v7[2] = __si_cacheCleanup_block_invoke;
      v7[3] = &unk_1E6E2DF98;
      v7[5] = v3;
      v7[6] = a1;
      v7[4] = &v10;
      if (fsi_iterate_f(walk, (uint64_t)v7))
      {
        _Block_object_dispose(&v10, 8);
      }
      else
      {
        v6 = *((unsigned __int8 *)v11 + 24);
        _Block_object_dispose(&v10, 8);
        if (v6)
        {
          si_enqueue_work(*(_QWORD *)(*a1 + 1056), (uint64_t)si_cacheCleanup, (uint64_t)a1);
          return;
        }
      }
    }
  }
LABEL_11:
  v5 = (char *)a1[2];
  if (v5)
    fsi_close(v5);
  free(a1);
}

uint64_t __si_cacheCleanup_block_invoke(_QWORD *a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  int v9;
  unsigned int v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  BOOL v16;
  int v17;
  NSObject *v18;
  os_log_type_t v19;
  uint64_t v20;
  int v21;
  const char *v22;
  int v23;
  NSObject *v24;
  os_log_type_t v25;
  uint64_t v26;
  uint64_t v27;
  stat v28;
  char *__endptr;
  uint8_t v30[4];
  uint64_t v31;
  uint8_t buf[4];
  uint64_t v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  if (**(_DWORD **)(a1[5] + 6592) | a4)
    return 1;
  v7 = a1[6];
  v8 = *(int *)(v7 + 8);
  ++*(_QWORD *)(v7 + 8 * v8 + 24);
  v9 = *(_DWORD *)(a3 + 4);
  if (!v9)
  {
    if ((_DWORD)v8 == 4)
    {
      __endptr = 0;
      v11 = strtoll(*(const char **)(a3 + 32), &__endptr, 0);
      v12 = __endptr;
      if (__endptr != *(char **)(a3 + 32))
      {
        v13 = v11;
        if (v11)
        {
          if (!strcmp(__endptr, ".txt") || strcmp(v12, ".tmp"))
          {
            bzero(buf, 0x400uLL);
            v14 = *(_QWORD *)(a1[5] + 1416);
            if (!*(_BYTE *)(v14 + 240))
            {
              v22 = (const char *)(*(uint64_t (**)(uint64_t, uint64_t, uint8_t *, _QWORD))(v14 + 48))(v14, v13, buf, 0);
              if (v22)
              {
                memset(&v28, 0, sizeof(v28));
                if (stat(v22, &v28) == -1 && *__error() == 2)
                {
                  v23 = *__error();
                  v24 = _SILogForLogForCategory(0);
                  v25 = 2 * (gSILogLevels[0] < 4);
                  if (os_log_type_enabled(v24, v25))
                  {
                    v26 = *(_QWORD *)(a3 + 16);
                    *(_DWORD *)v30 = 136315138;
                    v31 = v26;
                    _os_log_impl(&dword_1B8270000, v24, v25, "deleting stale cache file%s", v30, 0xCu);
                  }
                  *__error() = v23;
                  if (!unlink(*(const char **)(a3 + 16)))
                  {
                    v27 = a1[6] + 8 * *(int *)(a1[6] + 8);
                    --*(_QWORD *)(v27 + 24);
                  }
                }
              }
            }
          }
        }
      }
    }
    return 0;
  }
  if (v9 != 2)
  {
    if (v9 == 1)
    {
      v10 = v8 + 1;
      *(_DWORD *)(v7 + 8) = v8 + 1;
      if ((int)v8 < 1 || v10 <= 4 && strlen(*(const char **)(a3 + 32)) == 4)
      {
        result = 0;
      }
      else
      {
        *(_BYTE *)(v7 + 64) = 1;
        result = 2;
      }
      *(_QWORD *)(v7 + 8 * (int)v10 + 24) = 0;
      return result;
    }
    return 0;
  }
  v16 = (int)v8 >= 2 && *(_BYTE *)(v7 + 64) == 0;
  if (v16 && *(_QWORD *)(v7 + 8 * v8 + 24) == 1)
  {
    v17 = *__error();
    v18 = _SILogForLogForCategory(0);
    v19 = 2 * (gSILogLevels[0] < 4);
    if (os_log_type_enabled(v18, v19))
    {
      v20 = *(_QWORD *)(a3 + 16);
      *(_DWORD *)buf = 136315138;
      v33 = v20;
      _os_log_impl(&dword_1B8270000, v18, v19, "deleting stale cache folder%s", buf, 0xCu);
    }
    *__error() = v17;
    v21 = rmdir(*(const char **)(a3 + 16));
    v7 = a1[6];
    LODWORD(v8) = *(_DWORD *)(v7 + 8);
    if (!v21)
      --*(_QWORD *)(v7 + 8 * ((int)v8 - 1) + 24);
  }
  result = 0;
  *(_BYTE *)(v7 + 64) = 0;
  *(_DWORD *)(v7 + 8) = v8 - 1;
  if ((_DWORD)v8 == 4)
  {
    do
    {
      *(_DWORD *)(a2 + 3400) = 1;
      a2 = *(_QWORD *)(a2 + 8608);
    }
    while (a2);
    result = 0;
    *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) = 1;
  }
  return result;
}

void _SIIssueSizeRepair(uint64_t a1)
{
  if (a1)
  {
    if (*(_QWORD *)(a1 + 1184))
      si_enqueue_barrier(*(_QWORD *)(a1 + 1048), (uint64_t)si_sizeRepair, a1);
  }
}

uint64_t si_sizeRepair(uint64_t result, int a2)
{
  if (!a2 && *(_QWORD *)(result + 1184) && !*(_BYTE *)(result + 1280))
    return si_set_property(result, CFSTR("kSIRepairSizes"), (const void *)*MEMORY[0x1E0C9B0D0], 1, 1);
  return result;
}

uint64_t SISyncIndexVaccuumIfNeeded(uint64_t a1)
{
  return si_sync_index_vaccuum_if_needed(a1, 0, 0, 0, 0);
}

_DWORD *_SIOpenIndexFilesForMerge(_DWORD *result)
{
  _DWORD *v1;
  uint64_t v2;
  _DWORD *v3;
  int v4;
  _DWORD *v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  int v13;
  NSObject *v14;
  int v15;
  char *v16;
  char *v17;
  const char *v18;
  _BYTE buf[12];
  __int16 v20;
  int v21;
  __int16 v22;
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (result)
  {
    v1 = result;
    v2 = *((_QWORD *)result + 148);
    if (*(_DWORD *)v2 != 1685287992)
    {
      v13 = *__error();
      v14 = _SILogForLogForCategory(4);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        v15 = *(_DWORD *)v2;
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = "db_ensure_open_files";
        v20 = 1024;
        v21 = 276;
        v22 = 1024;
        v23 = v15;
        _os_log_error_impl(&dword_1B8270000, v14, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
      }
      *__error() = v13;
      v16 = __si_assert_copy_extra_268();
      v17 = v16;
      if (v16)
        v18 = v16;
      else
        v18 = "";
      __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 276, v18);
      free(v17);
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    if (db_read_lock(v2 + 584))
      sdb2_die(v2, "Multiple threads entering in sdb!", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 15288);
    v3 = *(_DWORD **)(v2 + 848);
    *(_QWORD *)buf = 0;
    v4 = _fd_acquire_fd((uint64_t)v3, buf);
    if (v4 != -1)
    {
      v3[17] = 1;
      _fd_release_fd(v3, v4, 0, *(uint64_t *)buf);
    }
    v5 = *(_DWORD **)(v2 + 840);
    *(_QWORD *)buf = 0;
    v6 = _fd_acquire_fd((uint64_t)v5, buf);
    if (v6 != -1)
    {
      v5[17] = 1;
      _fd_release_fd(v5, v6, 0, *(uint64_t *)buf);
    }
    v7 = pthread_mutex_lock((pthread_mutex_t *)(v2 + 584));
    v8 = *(_DWORD *)(v2 + 780) - 1;
    *(_DWORD *)(v2 + 780) = v8;
    if (!v8)
      db_rwlock_wakeup(v2 + 584, 0, 0);
    result = (_DWORD *)pthread_mutex_unlock((pthread_mutex_t *)(v2 + 584));
    if (v7)
      sdb2_die(v2, "Multiple threads in sdb! (leaving)", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 15291);
    v9 = *((_QWORD *)v1 + 174);
    v10 = *((_QWORD *)v1 + 173);
    if (*(_DWORD *)(v9 + 8))
    {
      v11 = 0;
      do
        result = _CIEnsureOpenFiles(*(_QWORD *)(*(_QWORD *)v9 + 8 * v11++));
      while (v11 < *(unsigned int *)(v9 + 8));
    }
    if (*(_DWORD *)(v10 + 8))
    {
      v12 = 0;
      do
        result = _CIEnsureOpenFiles(*(_QWORD *)(*(_QWORD *)v10 + 8 * v12++));
      while (v12 < *(unsigned int *)(v10 + 8));
    }
  }
  return result;
}

uint64_t _SICooldownIndexFilesForMerge(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  uint64_t **v7;
  uint64_t **v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  NSObject *v22;
  int v23;
  char *v24;
  char *v25;
  const char *v26;
  uint8_t buf[4];
  const char *v28;
  __int16 v29;
  int v30;
  __int16 v31;
  int v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  if (result)
  {
    v1 = result;
    v2 = *(_QWORD *)(result + 1184);
    if (*(_DWORD *)v2 != 1685287992)
    {
      v21 = *__error();
      v22 = _SILogForLogForCategory(4);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        v23 = *(_DWORD *)v2;
        *(_DWORD *)buf = 136315650;
        v28 = "db_cooldown_files";
        v29 = 1024;
        v30 = 277;
        v31 = 1024;
        v32 = v23;
        _os_log_error_impl(&dword_1B8270000, v22, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
      }
      *__error() = v21;
      v24 = __si_assert_copy_extra_268();
      v25 = v24;
      if (v24)
        v26 = v24;
      else
        v26 = "";
      __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 277, v26);
      free(v25);
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    if (db_read_lock(v2 + 584))
      sdb2_die(v2, "Multiple threads entering in sdb!", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 15296);
    v3 = *(_QWORD *)(v2 + 848);
    if (v3)
      *(_DWORD *)(v3 + 68) = 0;
    v4 = *(_QWORD *)(v2 + 840);
    if (v4)
      *(_DWORD *)(v4 + 68) = 0;
    v5 = pthread_mutex_lock((pthread_mutex_t *)(v2 + 584));
    v6 = *(_DWORD *)(v2 + 780) - 1;
    *(_DWORD *)(v2 + 780) = v6;
    if (!v6)
      db_rwlock_wakeup(v2 + 584, 0, 0);
    result = pthread_mutex_unlock((pthread_mutex_t *)(v2 + 584));
    if (v5)
      sdb2_die(v2, "Multiple threads in sdb! (leaving)", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 15299);
    v7 = *(uint64_t ***)(v1 + 1392);
    v8 = *(uint64_t ***)(v1 + 1384);
    v9 = *((unsigned int *)v7 + 2);
    if ((_DWORD)v9)
    {
      v10 = *v7;
      do
      {
        v11 = *v10;
        v12 = *(_QWORD *)(*v10 + 4656);
        if (v12)
          *(_DWORD *)(v12 + 68) = 0;
        v13 = *(_QWORD *)(v11 + 200);
        if (v13)
          *(_DWORD *)(v13 + 68) = 0;
        v14 = *(_QWORD *)(v11 + 464);
        if (v14)
          *(_DWORD *)(v14 + 68) = 0;
        ++v10;
        --v9;
      }
      while (v9);
    }
    v15 = *((unsigned int *)v8 + 2);
    if ((_DWORD)v15)
    {
      v16 = *v8;
      do
      {
        v17 = *v16;
        v18 = *(_QWORD *)(*v16 + 4656);
        if (v18)
          *(_DWORD *)(v18 + 68) = 0;
        v19 = *(_QWORD *)(v17 + 200);
        if (v19)
          *(_DWORD *)(v19 + 68) = 0;
        v20 = *(_QWORD *)(v17 + 464);
        if (v20)
          *(_DWORD *)(v20 + 68) = 0;
        ++v16;
        --v15;
      }
      while (v15);
    }
  }
  return result;
}

uint64_t _SIFlushAndSyncIndex(uint64_t a1)
{
  int8x16_t *v2;
  uint64_t v3;
  unsigned int v4;
  int v5;
  unint64_t v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  void (*v12)(_QWORD);
  _DWORD *v13;
  int v14;
  NSObject *v15;
  uint64_t v16;
  void (*v17)(uint64_t, _QWORD);
  CFNumberRef v18;
  CFNumberRef v19;
  uint64_t v20;
  void (*v21)(_QWORD);
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  void (*v29)(_QWORD);
  uint64_t v30;
  uint64_t v31;
  unsigned int v32;
  uint64_t v33;
  void (*v34)(_QWORD);
  int v35;
  int v37;
  NSObject *v38;
  int v39;
  NSObject *v40;
  uint64_t v41;
  unint64_t v42;
  unsigned int v43;
  unsigned int v44;
  unint64_t v45;
  unsigned int v46;
  unsigned int v47;
  unsigned int v48;
  int8x16_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  int8x16_t v54;
  _BYTE buf[32];
  __int128 v56;
  __int128 v57;
  int8x16_t *v58;
  uint64_t v59;

  v59 = *MEMORY[0x1E0C80C00];
  v53 = 0;
  v2 = *(int8x16_t **)(a1 + 2360);
  v49 = vextq_s8(*v2, *v2, 8uLL);
  v3 = *(_QWORD *)(a1 + 1184);
  v50 = v2[8].i64[1];
  v51 = v3;
  v52 = a1;
  v54 = vextq_s8(*(int8x16_t *)(a1 + 1384), *(int8x16_t *)(a1 + 1384), 8uLL);
  makeThreadId();
  if (gSILogLevels[0] >= 5)
  {
    v37 = *__error();
    v38 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1B8270000, v38, OS_LOG_TYPE_DEFAULT, "Starting forced sync!", buf, 2u);
    }
    *__error() = v37;
  }
  v48 = 0;
  if (fd_setDir(*(unsigned int *)(a1 + 32), (int *)&v48))
  {
    do
    {
      v4 = __ldxr(exceptionSequenceNum);
      v5 = v4 + 1;
    }
    while (__stxr(v4 + 1, exceptionSequenceNum));
    v6 = setThreadIdAndInfo(-1, (__int128 *)sSDBExceptionCallbacks, *(_QWORD *)(a1 + 1184), 0x40000000, v5);
    v46 = HIDWORD(v6);
    v47 = v6;
    v45 = __PAIR64__(v7, v8);
    v9 = *(_QWORD *)&threadData[18 * v6 + 2];
    v10 = v9 + 320 * HIDWORD(v6);
    *(_BYTE *)(v10 + 216) = 0;
    v11 = *(_DWORD *)(v10 + 312);
    v12 = *(void (**)(_QWORD))(v10 + 224);
    if (v12)
      v12(*(_QWORD *)(v9 + 320 * HIDWORD(v6) + 288));
    v44 = v47;
    v43 = v46;
    v42 = v45;
    if (_setjmp((int *)v10))
    {
      v13 = (_DWORD *)(v10 + 312);
      v14 = *__error();
      v15 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)&buf[4] = "_SIFlushAndSyncIndex";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 16852;
        _os_log_error_impl(&dword_1B8270000, v15, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
      }
      *__error() = v14;
      *v13 = v11;
      CIOnThreadCleanUpReset(v42);
      dropThreadId(v44, 1, v5);
      CICleanUpReset(v44, HIDWORD(v42));
    }
    else
    {
      v16 = *(_QWORD *)(a1 + 1416);
      if (v16)
      {
        v17 = *(void (**)(uint64_t, _QWORD))(v16 + 88);
        if (v17)
        {
          if (!*(_BYTE *)(v16 + 240))
            v17(v16, *(_QWORD *)(v16 + 24));
        }
      }
      v41 = 0;
      v41 = *(_QWORD *)(a1 + 2136);
      v18 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt64Type, &v41);
      if (v18)
      {
        v19 = v18;
        si_set_property(a1, CFSTR("ConsumedJournalSerialNumber"), v18, 1, 0);
        CFRelease(v19);
      }
      v20 = *(_QWORD *)(a1 + 2360);
      if (v20)
      {
        v21 = *(void (**)(_QWORD))(v20 + 48);
        if (v21)
          v21(*(_QWORD *)(v20 + 136));
      }
      v22 = *(_QWORD *)(a1 + 1392);
      v23 = *(_QWORD *)(a1 + 1384);
      v24 = *(_QWORD *)(a1 + 6592);
      *(_OWORD *)buf = xmmword_1E6E2DC80;
      *(_OWORD *)&buf[16] = *(_OWORD *)&off_1E6E2DC90;
      v56 = xmmword_1E6E2DCA0;
      v57 = *(_OWORD *)off_1E6E2DCB0;
      v58 = &v49;
      v25 = _ContentIndexSyncIndexBulk(a1 + 1192, v22, v23, 0, (uint64_t)buf, v24, (uint64_t)lowDiskSpaceCallback, a1);
      v26 = v25;
      v27 = v25;
      v28 = *(_QWORD *)(a1 + 2360);
      if (v28)
      {
        v29 = *(void (**)(_QWORD))(v28 + 56);
        if (v29)
          v29(*(_QWORD *)(v28 + 136));
      }
      if ((_DWORD)v27 && v26 != 89)
      {
        if (v26 == 28)
          v30 = 1;
        else
          v30 = 2;
        si_makeUnavailable(a1, v27, v30, 12, (uint64_t)"flush err");
      }
      v31 = *(_QWORD *)&threadData[18 * v44 + 2];
      v32 = v43;
      v33 = v31 + 320 * v43;
      *(_DWORD *)(v33 + 312) = v11;
      v34 = *(void (**)(_QWORD))(v33 + 232);
      if (v34)
        v34(*(_QWORD *)(v31 + 320 * v32 + 288));
      dropThreadId(v44, 0, v5);
    }
    v35 = v48;
    MEMORY[0x1BCCB1484](v48);
    if ((v35 & 0x80000000) == 0)
      close(v35);
  }
  if (gSILogLevels[0] >= 5)
  {
    v39 = *__error();
    v40 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1B8270000, v40, OS_LOG_TYPE_DEFAULT, "Finished forced sync!", buf, 2u);
    }
    *__error() = v39;
  }
  return 1;
}

void SIBulkDeleteAttributes(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  pthread_mutex_t *v6;
  const __CFAllocator *v7;
  uint64_t v8;
  unint64_t *v9;
  CFNumberRef v10;
  const void *Value;
  const void *v12;
  CFAbsoluteTime Current;
  CFAbsoluteTime *v14;

  v6 = (pthread_mutex_t *)(a1 + 1816);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1816));
  v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (a3 >= 1)
  {
    v8 = 1;
    v9 = a2;
    do
    {
      v10 = CFNumberCreate(v7, kCFNumberLongLongType, v9);
      Value = CFBagGetValue(*(CFBagRef *)(a1 + 1800), v10);
      CFRelease(v10);
      if (v8 >= a3)
        break;
      ++v8;
      ++v9;
    }
    while (!Value);
  }
  pthread_mutex_unlock(v6);
  v12 = (const void *)RLEOIDArrayCreate(v7, a2, a3);
  Current = CFAbsoluteTimeGetCurrent();
  _SIBulkDeleteAttributes(a1, (uint64_t)v12, a3, (uint64_t)Current);
  if (*(_QWORD *)(a1 + 1152))
  {
    v14 = (CFAbsoluteTime *)malloc_type_malloc(0x20uLL, 0x10600405FCA77C1uLL);
    *(_QWORD *)v14 = a1;
    *((_QWORD *)v14 + 1) = v12;
    v14[3] = CFAbsoluteTimeGetCurrent();
    si_enqueue_barrier(*(_QWORD *)(a1 + 1152), (uint64_t)_SIBulkDeleteAttributesHeld, (uint64_t)v14);
  }
  else if (v12)
  {
    CFRelease(v12);
  }
}

void _SIBulkDeleteAttributes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  void *v11;
  _QWORD *v12;
  uint64_t v13;

  if (a2 && *(_QWORD *)(a1 + 1048))
  {
    if (RLEOIDArrayIsEmpty(a2))
    {
      v8 = gSISystemInDarkWake;
      v9 = time(0) - a4;
      si_message_trace_darkwake(0, a1, (uint64_t)"PermissionCache", v8, (uint64_t)"Validate", (uint64_t)"Permission cache in dark wake", v9);
    }
    else
    {
      v10 = malloc_type_calloc(1uLL, 0x80uLL, 0x10300406AF0F2FAuLL);
      *v10 = a1;
      v11 = malloc_type_malloc(0x2000uLL, 0x100004000313F17uLL);
      v10[6] = 1024;
      v10[1] = v11;
      v10[2] = -1;
      v12 = RLEOIDIteratorCreate(a2);
      v10[8] = v12;
      v13 = RLEOIDIteratorNext((_BYTE **)v12, v10[1], v10[6]);
      *((_BYTE *)v10 + 104) = 0;
      v10[4] = a3;
      v10[5] = v13;
      v10[14] = a4;
      *((_BYTE *)v10 + 120) = 0;
      si_enqueue_work(*(_QWORD *)(a1 + 1048), (uint64_t)si_bulk_delete_attributes, (uint64_t)v10);
    }
  }
}

void _SIBulkDeleteAttributesHeld(uint64_t a1, char a2)
{
  if ((a2 & 1) == 0)
    _SIBulkDeleteAttributes(*(_QWORD *)a1, *(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16), (uint64_t)*(double *)(a1 + 24));
  CFRelease(*(CFTypeRef *)(a1 + 8));
  free((void *)a1);
}

void si_bulk_delete_attributes(uint64_t a1, int a2)
{
  double Current;
  uint64_t v5;
  uint64_t v6;
  int64_t v7;
  int v8;
  NSObject *v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  _QWORD *v13;
  int v14;
  NSObject *v15;
  os_log_type_t v16;
  uint64_t v17;
  _QWORD *v18;
  int *v19;
  uint64_t v20;
  uint64_t v21;
  const char *v22;
  time_t v23;
  uint64_t *v24;
  int v25;
  NSObject *v26;
  uint64_t v27;
  uint64_t v28;
  unsigned int v29;
  uint8_t buf[4];
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  if (!a2)
  {
    Current = CFAbsoluteTimeGetCurrent();
    v5 = *(_QWORD *)a1;
    if (*(_QWORD *)(a1 + 16) == -1)
      *(_QWORD *)(a1 + 16) = SIGetLargestOid(*(_QWORD *)a1);
    if (!*(_QWORD *)(a1 + 112))
      *(_QWORD *)(a1 + 112) = time(0);
    v29 = 0;
    if (fd_setDir(*(unsigned int *)(v5 + 32), (int *)&v29))
    {
      if (*(_QWORD *)(a1 + 40))
      {
        v6 = 0;
        while (1)
        {
          v7 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * v6);
          if (v7 > *(_QWORD *)(a1 + 16))
            break;
          if (dword_1EF19FC9C >= 5)
          {
            v8 = *__error();
            v9 = _SILogForLogForCategory(4);
            if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
            {
              v10 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * v6);
              *(_DWORD *)buf = 134217984;
              v31 = v10;
              _os_log_impl(&dword_1B8270000, v9, OS_LOG_TYPE_DEFAULT, "Delete (bulk) oid: %lld", buf, 0xCu);
            }
            *__error() = v8;
            v7 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * v6);
          }
          buf[0] = 0;
          _si_delete_attributes_inner(v5, v7, 1u, 0, 0, 0, buf);
          si_finish_text_store_deletions(v5);
          if (buf[0])
            notify_post("com.apple.spotlight.SyndicatedContentDeleted");
          ++*(_QWORD *)(a1 + 56);
          if ((unint64_t)++v6 >= *(_QWORD *)(a1 + 40))
            goto LABEL_18;
        }
        if (gSILogLevels[0] >= 5)
        {
          v25 = *__error();
          v26 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
          {
            v27 = *(_QWORD *)(a1 + 16);
            v28 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * v6);
            *(_DWORD *)buf = 134218240;
            v31 = v28;
            v32 = 2048;
            v33 = v27;
            _os_log_impl(&dword_1B8270000, v26, OS_LOG_TYPE_DEFAULT, "oid: %lld > max_oid: %lld", buf, 0x16u);
          }
          *__error() = v25;
        }
        fd_resetDir(v29);
        *(_QWORD *)(a1 + 40) = 0;
        goto LABEL_30;
      }
LABEL_18:
      v11 = v29;
      MEMORY[0x1BCCB1484](v29);
      if ((v11 & 0x80000000) == 0)
        close(v11);
    }
    v12 = RLEOIDIteratorNext(*(_BYTE ***)(a1 + 64), *(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 48));
    *(_QWORD *)(a1 + 40) = v12;
    if (v12)
    {
      v13 = *(_QWORD **)(a1 + 8);
      if (*(_QWORD *)(a1 + 24) < *v13 && *(_QWORD *)(a1 + 56) < *(_QWORD *)(a1 + 32))
      {
        *(_QWORD *)(a1 + 24) = v13[v12 - 1];
        si_enqueue_barrier(*(_QWORD *)(v5 + 1048), (uint64_t)si_bulk_delete_attributes, a1);
        a1 = 0;
LABEL_34:
        bumpWorkTime(v5, Current);
        goto LABEL_35;
      }
    }
    if (*(_QWORD *)(a1 + 56) >= 0x401uLL)
    {
      v14 = *__error();
      v15 = _SILogForLogForCategory(0);
      v16 = 2 * (gSILogLevels[0] < 4);
      if (os_log_type_enabled(v15, v16))
      {
        v17 = *(_QWORD *)(a1 + 40);
        *(_DWORD *)buf = 67109120;
        LODWORD(v31) = v17;
        _os_log_impl(&dword_1B8270000, v15, v16, "%d missing items, cleaninup up cache.", buf, 8u);
      }
      *__error() = v14;
      if (v5 && *(_QWORD *)(v5 + 1184))
      {
        v18 = malloc_type_calloc(1uLL, 0x48uLL, 0x1020040A82CC6CDuLL);
        *v18 = v5;
        si_enqueue_work(*(_QWORD *)(v5 + 1056), (uint64_t)si_cacheCleanup, (uint64_t)v18);
      }
    }
LABEL_30:
    v19 = (int *)*(unsigned __int8 *)(a1 + 104);
    v20 = *(_QWORD *)a1;
    v21 = gSISystemInDarkWake;
    if (*(_BYTE *)(a1 + 120))
      v22 = "Initial";
    else
      v22 = "Validate";
    v23 = time(0);
    si_message_trace_darkwake(v19, v20, (uint64_t)"PermissionCache", v21, (uint64_t)v22, (uint64_t)"Permission cache in dark wake", v23 - *(_QWORD *)(a1 + 112));
    goto LABEL_34;
  }
LABEL_35:
  if (a1)
  {
    si_power_info_cleanup(a1 + 72, *(_QWORD *)a1, a2 != 0);
    v24 = *(uint64_t **)(a1 + 64);
    if (v24)
      RLEOIDIteratorDestroy(v24);
    free(*(void **)(a1 + 8));
    free((void *)a1);
  }
}

uint64_t SIGetLargestOid(uint64_t a1)
{
  unsigned int v2;
  int v3;
  unint64_t v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  void (*v10)(_QWORD);
  int v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void (*v19)(_QWORD);
  uint64_t v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  uint8_t buf[4];
  const char *v26;
  __int16 v27;
  int v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  if (!*(_QWORD *)(a1 + 1184))
    return -1;
  makeThreadId();
  do
  {
    v2 = __ldxr(exceptionSequenceNum);
    v3 = v2 + 1;
  }
  while (__stxr(v2 + 1, exceptionSequenceNum));
  v4 = setThreadIdAndInfo(*(_DWORD *)(a1 + 32), sFdExceptionCallbacks, 0, 1, v3);
  v23 = HIDWORD(v4);
  v24 = v4;
  v21 = v6;
  v22 = v5;
  v7 = *(_QWORD *)&threadData[18 * v4 + 2];
  v8 = v7 + 320 * HIDWORD(v4);
  *(_BYTE *)(v8 + 216) = 0;
  v9 = *(_DWORD *)(v8 + 312);
  v10 = *(void (**)(_QWORD))(v8 + 224);
  if (v10)
    v10(*(_QWORD *)(v7 + 320 * HIDWORD(v4) + 288));
  if (_setjmp((int *)v8))
  {
    v11 = *__error();
    v12 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v26 = "SIGetLargestOid";
      v27 = 1024;
      v28 = 20387;
      _os_log_error_impl(&dword_1B8270000, v12, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
    }
    *__error() = v11;
    *(_DWORD *)(v8 + 312) = v9;
    CIOnThreadCleanUpReset(v21);
    dropThreadId(v24, 1, v3);
    CICleanUpReset(v24, v22);
    return -1;
  }
  else
  {
    v15 = db_datastore_largest_oid(*(_QWORD *)(a1 + 1184));
    v16 = *(_QWORD *)(a1 + 6880);
    v13 = v15;
    if (v16)
    {
      v20 = db_datastore_largest_oid(v16);
      if (v15 <= v20)
        v13 = v20;
      else
        v13 = v15;
    }
    v17 = *(_QWORD *)&threadData[18 * v24 + 2];
    v18 = v17 + 320 * v23;
    *(_DWORD *)(v18 + 312) = v9;
    v19 = *(void (**)(_QWORD))(v18 + 232);
    if (v19)
      v19(*(_QWORD *)(v17 + 320 * v23 + 288));
    dropThreadId(v24, 0, v3);
  }
  return v13;
}

uint64_t SISerializeCacheData(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  int v7;
  unsigned int v8;
  unint64_t v9;
  signed int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  _DWORD *v18;
  unsigned int v19;
  _QWORD *v20;
  unsigned int v21;
  _BYTE *v22;
  unint64_t v24;
  _DWORD *v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unsigned int v29;
  unint64_t v30;
  int v31;
  unsigned int v32;
  unsigned int v33;
  uint8_t *v34;
  uint8_t *v35;
  uint64_t v36;
  uint8_t *v37;
  size_t v38;
  unint64_t v39;
  uint64_t v40;
  int *v41;
  BOOL v42;
  unint64_t v43;
  uint8_t *v44;
  uint64_t v45;
  uint64_t v46;
  size_t v47;
  uint64_t v48;
  uint8_t *v49;
  size_t v50;
  unint64_t v51;
  uint64_t v52;
  int *v53;
  int v54;
  int32x2_t v55;
  int v57;
  NSObject *v58;
  int v59;
  char *v60;
  char *v61;
  const char *v62;
  uint64_t v63;
  _BYTE *v64;
  _DWORD *v65;
  uint64_t v66;
  _QWORD *v67;
  uint8_t buf[12];
  __int16 v69;
  int v70;
  __int16 v71;
  int v72;
  uint64_t v73;

  v1 = MEMORY[0x1E0C80A78](a1);
  v73 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(v1 + 1184);
  if (!v4)
    return 0;
  if (*(_DWORD *)v4 != 1685287992)
  {
    v57 = *__error();
    v58 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
    {
      v59 = *(_DWORD *)v4;
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "db_serialize_cache";
      v69 = 1024;
      v70 = 491;
      v71 = 1024;
      v72 = v59;
      _os_log_error_impl(&dword_1B8270000, v58, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
    }
    *__error() = v57;
    v60 = __si_assert_copy_extra_268();
    v61 = v60;
    if (v60)
      v62 = v60;
    else
      v62 = "";
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 491, v62);
    free(v61);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  v5 = v3;
  v6 = v2;
  v7 = pthread_mutex_lock((pthread_mutex_t *)(v4 + 584));
  HIDWORD(v9) = qos_class_self() - 9;
  LODWORD(v9) = HIDWORD(v9);
  v8 = v9 >> 2;
  if (v8 > 6)
    v10 = 0;
  else
    v10 = dword_1B8630ED0[v8];
  if (*(_QWORD *)(v4 + 768))
    goto LABEL_16;
  if (!*(_DWORD *)(v4 + 780) && !*(_BYTE *)(v4 + 796))
    goto LABEL_55;
  v12 = v10 <= 5 ? 5 : v10;
  v13 = (uint64_t *)(v4 + 16 * v10 + 664);
  v14 = v12 - v10 + 1;
  while (--v14)
  {
    v15 = *v13;
    v13 += 2;
    if (v15)
      goto LABEL_16;
  }
  if (*(_QWORD *)(v4 + 16 * v10 + 648) && !*(_DWORD *)(v4 + 784))
LABEL_16:
    db_rwlock_wait(v4 + 584, v10, 5);
  else
LABEL_55:
    *(int32x2_t *)(v4 + 780) = vadd_s32(*(int32x2_t *)(v4 + 780), (int32x2_t)0x100000001);
  v67 = v5;
  pthread_mutex_unlock((pthread_mutex_t *)(v4 + 584));
  if (v7)
    sdb2_die(v4, "Multiple threads entering in sdb!", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 15251);
  v16 = *(_QWORD *)(v4 + 928);
  bzero(&buf[8], 0xFF9uLL);
  *(_QWORD *)buf = 3401903581;
  if (v16)
  {
    v17 = atomic_load((unsigned int *)(v16 + 248));
    v18 = malloc_type_calloc(0x10uLL, v17 + 1, 0xC4611BB6uLL);
    v19 = atomic_load((unsigned int *)(v16 + 248));
    v20 = malloc_type_malloc(8 * (v19 + 1), 0x80040B8603338uLL);
    v21 = atomic_load((unsigned int *)(v16 + 248));
    v22 = malloc_type_malloc(2 * (v21 + 1), 0x1000040BDFB0063uLL);
    if (atomic_load((unsigned int *)(v16 + 248)))
    {
      v24 = 0;
      v25 = v18;
      do
      {
        *(_QWORD *)v25 = *(_QWORD *)v16;
        v25[2] = v24;
        v20[v24++] = v25;
        v26 = atomic_load((unsigned int *)(v16 + 248));
        v25 += 4;
      }
      while (v24 < v26);
    }
    atomic_load((unsigned int *)(v16 + 248));
    if (cache_get_info_for_keys() || (v29 = atomic_load((unsigned int *)(v16 + 248))) == 0)
    {
      v27 = 0;
      v28 = 8;
    }
    else
    {
      v30 = 0;
      v31 = 0;
      v27 = 0;
      v28 = 8;
      do
      {
        if (v22[2 * v30])
        {
          v32 = v30 - v31;
          v33 = v32 >> 28;
          if (v32 >> 28)
          {
            v35 = &buf[v28];
            *v35 = v32 | 0x80;
            v35[1] = (v32 >> 7) | 0x80;
            v35[2] = (v32 >> 14) | 0x80;
            v28 += 4;
            v35[3] = (v32 >> 21) | 0x80;
          }
          else if ((v32 & 0xFE00000) != 0)
          {
            v34 = &buf[v28];
            *v34 = v32 | 0x80;
            v34[1] = (v32 >> 7) | 0x80;
            v28 += 3;
            v34[2] = (v32 >> 14) | 0x80;
            v33 = (v32 & 0xFE00000) >> 21;
          }
          else if ((v32 & 0x1FC000) != 0)
          {
            v44 = &buf[v28];
            *v44 = v32 | 0x80;
            v28 += 2;
            v44[1] = (v32 >> 7) | 0x80;
            v33 = (v32 & 0x1FC000) >> 14;
          }
          else if ((v32 & 0x3F80) != 0)
          {
            buf[v28++] = v32 | 0x80;
            v33 = (unsigned __int16)(v32 & 0x3F80) >> 7;
          }
          else
          {
            LOBYTE(v33) = v32;
          }
          buf[v28++] = v33;
          if (v28 < 4092)
          {
            v31 = v30;
          }
          else
          {
            v64 = v22;
            v65 = v18;
            v36 = 0;
LABEL_34:
            v66 = 0;
            v63 = v36;
            v37 = &buf[v36];
            v38 = v28;
            while (1)
            {
              while (1)
              {
                v39 = write(v6, v37, v38);
                if ((v39 & 0x8000000000000000) == 0)
                  break;
                v40 = g_prot_error_callback;
                if (g_prot_error_callback)
                {
                  v41 = __error();
                  if (((*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t))(v40 + 16))(v40, v6, *v41, 6) & 1) != 0)continue;
                }
                v27 = -1;
                goto LABEL_57;
              }
              v27 = v39 + v66;
              v42 = v38 > v39;
              v38 -= v39;
              if (!v42)
                break;
              v66 += v39;
              v37 += v39;
            }
            if (v27 == -1)
            {
LABEL_57:
              v22 = v64;
              v18 = v65;
              break;
            }
            v36 = v27 + v63;
            *v67 += v27;
            v28 -= v27;
            if (v28)
              goto LABEL_34;
            v31 = v30;
            v22 = v64;
            v18 = v65;
          }
        }
        ++v30;
        v43 = atomic_load((unsigned int *)(v16 + 248));
      }
      while (v30 < v43);
    }
    v45 = v27;
    free(v18);
    free(v20);
    free(v22);
    if (v45 == -1)
      goto LABEL_71;
  }
  else
  {
    v28 = 8;
  }
  v46 = 0;
  v47 = v28 + 1;
  buf[v28] = 0;
  while (1)
  {
    v48 = 0;
    v49 = &buf[v46];
    v50 = v47;
    while (1)
    {
      while (1)
      {
        v51 = write(v6, v49, v50);
        if ((v51 & 0x8000000000000000) == 0)
          break;
        v52 = g_prot_error_callback;
        if (g_prot_error_callback)
        {
          v53 = __error();
          if (((*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t))(v52 + 16))(v52, v6, *v53, 6) & 1) != 0)continue;
        }
        goto LABEL_71;
      }
      v48 += v51;
      v42 = v50 > v51;
      v50 -= v51;
      if (!v42)
        break;
      v49 += v51;
    }
    if (v48 == -1)
      break;
    v11 = 0;
    v46 += v48;
    *v67 += v48;
    v47 -= v48;
    if (!v47)
      goto LABEL_72;
  }
LABEL_71:
  v11 = 0xFFFFFFFFLL;
LABEL_72:
  v54 = pthread_mutex_lock((pthread_mutex_t *)(v4 + 584));
  v55 = vadd_s32(*(int32x2_t *)(v4 + 780), (int32x2_t)-1);
  *(int32x2_t *)(v4 + 780) = v55;
  if (!v55.i32[0])
    db_rwlock_wakeup(v4 + 584, 0, 0);
  pthread_mutex_unlock((pthread_mutex_t *)(v4 + 584));
  if (v54)
    sdb2_die(v4, "Multiple threads in sdb! (leaving)", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 15253);
  return v11;
}

uint64_t SIRestoreCacheData(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  off_t *v3;
  off_t *v4;
  uint64_t v5;
  _DWORD *v6;
  off_t v7;
  unint64_t v8;
  uint64_t v9;
  int *v11;
  unint64_t v12;
  uint64_t v13;
  int v14;
  NSObject *v15;
  off_t v16;
  const char *v17;
  NSObject *v18;
  uint32_t v19;
  uint64_t v20;
  _DWORD *v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  int v29;
  uint64_t v30;
  int v31;
  int v32;
  uint64_t v33;
  int v34;
  int v35;
  uint64_t v36;
  int v37;
  int v38;
  unsigned int v39;
  _BOOL4 v40;
  off_t v42;
  ssize_t v43;
  uint64_t v44;
  int *v46;
  NSObject *v47;
  NSObject *v48;
  os_log_type_t v49;
  char *v51;
  char *v52;
  const char *v53;
  _QWORD v54[2];
  void (*v55)(uint64_t, void *);
  void *v56;
  uint64_t v57;
  _QWORD v58[5];
  _QWORD v59[7];
  _QWORD __buf[1024];
  uint8_t buf[4];
  uint64_t v62;
  _BYTE v63[40];
  _DWORD *v64;
  uint64_t v65;
  uint64_t v66;

  v1 = MEMORY[0x1E0C80A78](a1);
  v4 = v3;
  v5 = v2;
  v66 = *MEMORY[0x1E0C80C00];
  v6 = *(_DWORD **)(v1 + 1184);
  if (v6)
  {
    v54[0] = MEMORY[0x1E0C809B0];
    v54[1] = 0x40000000;
    v55 = __SIRestoreCacheData_block_invoke;
    v56 = &__block_descriptor_tmp_408;
    v57 = v1;
    if (*v6 != 1685287992)
    {
      v51 = __si_assert_copy_extra_268();
      v52 = v51;
      if (v51)
        v53 = v51;
      else
        v53 = "";
      __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 490, v53);
      free(v52);
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    v58[0] = MEMORY[0x1E0C809B0];
    v58[1] = 0x40000000;
    v58[2] = __db2_deserialize_cache_block_invoke;
    v58[3] = &__block_descriptor_tmp_100;
    v58[4] = v6;
    bzero(__buf, 0x2000uLL);
    v7 = *v4;
    while (1)
    {
      v8 = pread(v5, __buf, 0x2000uLL, v7);
      v9 = g_prot_error_callback;
      if (v8 != -1 || g_prot_error_callback == 0)
        break;
      v11 = __error();
      if (((*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t))(v9 + 16))(v9, v5, *v11, 4) & 1) == 0)
      {
        v12 = -1;
        goto LABEL_16;
      }
    }
    v12 = v8;
    if (v8 <= 7)
    {
      v14 = *__error();
      v15 = _SILogForLogForCategory(7);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        v16 = *v4;
        *(_DWORD *)v63 = 136315906;
        *(_QWORD *)&v63[4] = "page_cache_deserialize_entries";
        *(_WORD *)&v63[12] = 1024;
        *(_DWORD *)&v63[14] = 1537;
        *(_WORD *)&v63[18] = 2048;
        *(_QWORD *)&v63[20] = v12;
        *(_WORD *)&v63[28] = 2048;
        *(_QWORD *)&v63[30] = v16;
        v17 = "%s:%d: Unexpected EOF in page cache preload; got %ld bytes at offset %lld";
        v18 = v15;
        v19 = 38;
LABEL_58:
        _os_log_error_impl(&dword_1B8270000, v18, OS_LOG_TYPE_ERROR, v17, v63, v19);
        goto LABEL_50;
      }
      goto LABEL_50;
    }
LABEL_16:
    v20 = __buf[0];
    if (__buf[0] != 3401903581)
    {
      v14 = *__error();
      v47 = _SILogForLogForCategory(7);
      if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v63 = 136315650;
        *(_QWORD *)&v63[4] = "page_cache_deserialize_entries";
        *(_WORD *)&v63[12] = 1024;
        *(_DWORD *)&v63[14] = 1543;
        *(_WORD *)&v63[18] = 2048;
        *(_QWORD *)&v63[20] = v20;
        v17 = "%s:%d: Missing signature in page cache preload %llx";
        v18 = v47;
        v19 = 28;
        goto LABEL_58;
      }
LABEL_50:
      v13 = 0xFFFFFFFFLL;
      goto LABEL_54;
    }
    v21 = malloc_type_malloc(0x4000uLL, 0x100004052888210uLL);
    v22 = 0;
    v23 = 0;
    v24 = 0;
    v25 = 8;
    v26 = MEMORY[0x1E0C809B0];
    while (1)
    {
      v27 = v25 + 1;
      v28 = *((unsigned __int8 *)__buf + v25);
      if (*((char *)__buf + v25) < 0)
      {
        v30 = v25 + 2;
        v31 = *((char *)__buf + v27);
        v32 = *((unsigned __int8 *)__buf + v27);
        if (v31 < 0)
        {
          v33 = v25 + 3;
          v34 = *((char *)__buf + v30);
          v35 = *((unsigned __int8 *)__buf + v30);
          if (v34 < 0)
          {
            v36 = v25 + 4;
            v37 = *((char *)__buf + v33);
            v38 = *((unsigned __int8 *)__buf + v33);
            if (v37 < 0)
            {
              v25 += 5;
              v39 = *((unsigned __int8 *)__buf + v36);
              v29 = (v39 >> 7) ^ 1;
              v28 = ((v38 & 0x7F) << 21) | (v39 << 28) | ((v35 & 0x7F) << 14) | ((v32 & 0x7F) << 7) | v28 & 0x7F;
            }
            else
            {
              v29 = 0;
              v25 += 4;
              v28 = ((v35 & 0x7F) << 14) | (v38 << 21) | ((v32 & 0x7F) << 7) | v28 & 0x7F;
            }
          }
          else
          {
            v29 = 0;
            v25 += 3;
            v28 = ((v32 & 0x7F) << 7) | (v35 << 14) | v28 & 0x7F;
          }
        }
        else
        {
          v29 = 0;
          v28 = v28 & 0x7F | (v32 << 7);
          v25 += 2;
        }
      }
      else
      {
        v29 = 0;
        ++v25;
      }
      v40 = v29 == 0;
      if (!v28 || v29 != 0)
        break;
      v22 += v28;
      v21[v24] = v22;
      if (v24 == 4095)
      {
        *(_QWORD *)v63 = v26;
        *(_QWORD *)&v63[8] = 0x40000000;
        *(_QWORD *)&v63[16] = __page_cache_deserialize_entries_block_invoke;
        *(_QWORD *)&v63[24] = &unk_1E6E37F10;
        *(_QWORD *)&v63[32] = v58;
        v64 = v21;
        v65 = 4096;
        v55((uint64_t)v54, v63);
        v21 = malloc_type_malloc(0x4000uLL, 0x100004052888210uLL);
        v24 = 0;
      }
      else
      {
        ++v24;
      }
      ++v23;
      if (v25 + 5 >= v12)
      {
        v42 = *v4 + v25;
        *v4 = v42;
        while (1)
        {
          v43 = pread(v5, __buf, 0x2000uLL, v42);
          v44 = g_prot_error_callback;
          if (v43 != -1 || g_prot_error_callback == 0)
            break;
          v46 = __error();
          if (((*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t))(v44 + 16))(v44, v5, *v46, 4) & 1) == 0)
          {
            v12 = -1;
            goto LABEL_44;
          }
        }
        v12 = v43;
LABEL_44:
        v25 = 0;
        v26 = MEMORY[0x1E0C809B0];
        if (!v12)
        {
          v40 = 1;
          break;
        }
      }
    }
    v13 = (v40 - 1);
    if (v24 && v40)
    {
      v59[0] = v26;
      v59[1] = 0x40000000;
      v59[2] = __page_cache_deserialize_entries_block_invoke_2;
      v59[3] = &unk_1E6E37F38;
      v59[4] = v58;
      v59[5] = v21;
      v59[6] = v24;
      v55((uint64_t)v54, v59);
    }
    else
    {
      free(v21);
    }
    *v4 += v25;
    v14 = *__error();
    v48 = _SILogForLogForCategory(7);
    v49 = 2 * (dword_1EF19FCA8 < 4);
    if (os_log_type_enabled(v48, v49))
    {
      *(_DWORD *)buf = 134217984;
      v62 = v23;
      _os_log_impl(&dword_1B8270000, v48, v49, "Pre-loaded %ld cache pages", buf, 0xCu);
    }
LABEL_54:
    *__error() = v14;
  }
  else
  {
    LOBYTE(__buf[0]) = 0;
    if (prot_pread(v2, __buf, 1uLL, *v3) == 1 && (++*v4, !LOBYTE(__buf[0])))
      return 0;
    else
      return 96;
  }
  return v13;
}

void runBlock(void (**a1)(_QWORD, _QWORD), int a2)
{
  ((void (**)(_QWORD, BOOL))a1)[2](a1, a2 != 0);
  _Block_release(a1);
}

uint64_t _SIGetRecoverTimeStamp(uint64_t a1)
{
  time_t v1;
  tm *v3;
  int v4;
  NSObject *v5;
  os_log_type_t v6;
  time_t v8;
  uint8_t buf[4];
  char *v10;
  char v11[16];
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v1 = *(_QWORD *)(a1 + 2408);
  if (!v1)
    return 0;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  v18 = 0u;
  v16 = 0u;
  v17 = 0u;
  v14 = 0u;
  v15 = 0u;
  v12 = 0u;
  v13 = 0u;
  *(_OWORD *)v11 = 0u;
  v8 = v1;
  v3 = localtime(&v8);
  strftime(v11, 0x100uLL, "%F %T", v3);
  v4 = *__error();
  v5 = _SILogForLogForCategory(0);
  v6 = 2 * (gSILogLevels[0] < 4);
  if (os_log_type_enabled(v5, v6))
  {
    *(_DWORD *)buf = 136315138;
    v10 = v11;
    _os_log_impl(&dword_1B8270000, v5, v6, "time stamp%s", buf, 0xCu);
  }
  *__error() = v4;
  return *(_QWORD *)(a1 + 2408);
}

uint64_t SISetAttributes(uint64_t a1, uint64_t a2, const void *a3, const void *a4)
{
  _QWORD *v8;
  CFTypeRef v9;
  int v11;
  NSObject *v12;
  int v13;
  NSObject *v14;
  uint8_t v15[16];
  uint8_t buf[16];

  v8 = malloc_type_calloc(1uLL, 0x50uLL, 0x10E0040BFFD03D2uLL);
  if (dword_1EF19FC9C >= 5)
  {
    v11 = *__error();
    v12 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1B8270000, v12, OS_LOG_TYPE_DEFAULT, "Do attribute change.", buf, 2u);
    }
    *__error() = v11;
  }
  v8[3] = a2;
  v8[1] = CFRetain(a3);
  if (a4)
    v9 = CFRetain(a4);
  else
    v9 = 0;
  v8[5] = v9;
  *v8 = a1;
  *((_DWORD *)v8 + 13) = 7;
  si_enqueue_barrier(*(_QWORD *)(a1 + 1048), (uint64_t)setAttributes, (uint64_t)v8);
  if (dword_1EF19FC9C >= 5)
  {
    v13 = *__error();
    v14 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v15 = 0;
      _os_log_impl(&dword_1B8270000, v14, OS_LOG_TYPE_DEFAULT, "Leave.", v15, 2u);
    }
    *__error() = v13;
  }
  return 1;
}

void SIIndexingFullyCaughtUp(uint64_t a1)
{
  _QWORD *v2;

  if (*(_QWORD *)(a1 + 1152))
  {
    v2 = malloc_type_calloc(1uLL, 0x50uLL, 0x10E0040BFFD03D2uLL);
    *v2 = a1;
    si_enqueue_barrier(*(_QWORD *)(a1 + 1152), (uint64_t)setIndexingCaughtUp0, (uint64_t)v2);
  }
}

void setIndexingCaughtUp0(void *a1, int a2)
{
  if (a2)
    free(a1);
  else
    si_enqueue_barrier(*(_QWORD *)(*(_QWORD *)a1 + 1048), (uint64_t)setIndexingCaughtUp, (uint64_t)a1);
}

void setIndexingCaughtUp(uint64_t *a1, int a2)
{
  uint64_t v3;
  uint64_t v4;

  if (!a2)
  {
    v3 = *a1;
    *(_BYTE *)(v3 + 2459) = 1;
    v4 = db_shrink_cache(*(_QWORD *)(v3 + 1184));
    if ((_DWORD)v4)
      si_makeUnavailable(*a1, v4, 0, 13, (uint64_t)"Failure in db_shrink_cache at setIndexingCaughtUp");
  }
  free(a1);
}

uint64_t SIDeleteCSAttributes(uint64_t a1, const void *a2, CFArrayRef theArray, void (*a4)(_QWORD, _QWORD), uint64_t a5)
{
  CFIndex Count;
  uint64_t v11;
  const __CFAllocator *v12;
  CFIndex v13;
  const __CFArray *Mutable;
  CFIndex v15;
  const CFDictionaryKeyCallBacks *v16;
  const CFDictionaryValueCallBacks *v17;
  __CFDictionary *v18;
  const void *ValueAtIndex;
  int v20;
  uint64_t v21;
  void (*v23)(_QWORD, _QWORD);
  uint64_t v24;
  CFIndex capacity;
  uint64_t v26;

  Count = CFArrayGetCount(theArray);
  v11 = Count;
  v12 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (Count >= 65000)
    v13 = 65000;
  else
    v13 = Count;
  capacity = v13;
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v13, MEMORY[0x1E0C9B378]);
  if (v11 < 1)
  {
LABEL_13:
    v21 = SISetCSAttributes(a1, a2, Mutable, 0x8000, a4, a5);
  }
  else
  {
    v26 = a1;
    v23 = a4;
    v24 = a5;
    v15 = 0;
    v16 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E0C9B390];
    v17 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E0C9B3A0];
    do
    {
      while (1)
      {
        v18 = CFDictionaryCreateMutable(v12, 4, v16, v17);
        ValueAtIndex = CFArrayGetValueAtIndex(theArray, v15);
        CFDictionarySetValue(v18, CFSTR("_kMDItemExternalID"), ValueAtIndex);
        CFArrayAppendValue(Mutable, v18);
        CFRelease(v18);
        if (CFArrayGetCount(Mutable) >= 65000)
          break;
        if (++v15 >= v11)
          goto LABEL_12;
      }
      v20 = SISetCSAttributes(v26, a2, Mutable, 0x8000, (void (*)(_QWORD, _QWORD))noop, 0);
      CFRelease(Mutable);
      Mutable = CFArrayCreateMutable(v12, capacity, MEMORY[0x1E0C9B378]);
      if (!v20)
        break;
      ++v15;
    }
    while (v15 < v11);
    if (v20)
    {
LABEL_12:
      a4 = v23;
      a5 = v24;
      a1 = v26;
      goto LABEL_13;
    }
    v21 = 0;
  }
  CFRelease(Mutable);
  return v21;
}

uint64_t SISetCSAttributes(uint64_t a1, const void *a2, CFArrayRef theArray, int a4, void (*a5)(_QWORD, _QWORD), uint64_t a6)
{
  int v7;
  NSObject *v8;
  CFIndex Count;
  uint64_t v15;
  CFTypeID TypeID;
  CFTypeID v17;
  CFIndex v18;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v20;
  const void *Value;
  CFTypeID v22;
  const void *Mutable;
  char *JournalFd;
  char *v25;
  uint64_t v26;
  unsigned int v27;
  unsigned int v28;
  NSObject *v29;
  int *v30;
  uint64_t result;
  int v32;
  NSObject *v33;
  unsigned int v34;
  unint64_t *v35;
  BOOL v36;
  uint64_t v37;
  const char *v38;
  _QWORD *v39;
  unint64_t v40;
  uint64_t v41;
  int v42;
  NSObject *v43;
  os_log_type_t v44;
  uint64_t (*v45)();
  unsigned int v46;
  unsigned int v47;
  void (*v48)(_QWORD, _QWORD);
  uint64_t v49;
  const char *v50;
  _QWORD *v51;
  uint8_t buf[4];
  const char *v53;
  __int16 v54;
  _BYTE v55[14];
  __int16 v56;
  int v57;
  __int16 v58;
  CFArrayRef v59;
  uint64_t v60;

  v60 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 1280))
  {
    v7 = *__error();
    v8 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134217984;
      v53 = (const char *)a1;
      _os_log_impl(&dword_1B8270000, v8, OS_LOG_TYPE_DEFAULT, "Can't set attributes because the index is read-only. ref:%p", buf, 0xCu);
    }
LABEL_27:
    v30 = __error();
    result = 0;
    *v30 = v7;
    return result;
  }
  Count = CFArrayGetCount(theArray);
  if (Count)
  {
    v15 = Count;
    v48 = a5;
    v49 = a6;
    TypeID = CFDictionaryGetTypeID();
    v17 = CFStringGetTypeID();
    if (v15 >= 1)
    {
      a5 = (void (*)(_QWORD, _QWORD))v17;
      v18 = 0;
      while (1)
      {
        ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, v18);
        v20 = ValueAtIndex;
        if (!ValueAtIndex)
          break;
        if (CFGetTypeID(ValueAtIndex) != TypeID)
          break;
        Value = CFDictionaryGetValue(v20, CFSTR("_kMDItemExternalID"));
        if (!Value || (void (*)(_QWORD, _QWORD))CFGetTypeID(Value) != a5)
          break;
        if (v15 == ++v18)
          goto LABEL_12;
      }
      v7 = *__error();
      v29 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315650;
        v53 = "SISetCSAttributes";
        v54 = 1024;
        *(_DWORD *)v55 = 18905;
        *(_WORD *)&v55[4] = 2112;
        *(_QWORD *)&v55[6] = v20;
        _os_log_error_impl(&dword_1B8270000, v29, OS_LOG_TYPE_ERROR, "%s:%d: bad object %@", buf, 0x1Cu);
      }
      goto LABEL_27;
    }
LABEL_12:
    if (!a2 || (v22 = CFStringGetTypeID(), v22 != CFGetTypeID(a2)))
    {
      v32 = *__error();
      v33 = _SILogForLogForCategory(10);
      a5 = v48;
      if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136316162;
        v53 = "mobile_journal";
        v54 = 1024;
        *(_DWORD *)v55 = 18394;
        *(_WORD *)&v55[4] = 2048;
        *(_QWORD *)&v55[6] = a2;
        v56 = 1024;
        v57 = a4;
        v58 = 2112;
        v59 = theArray;
        _os_log_error_impl(&dword_1B8270000, v33, OS_LOG_TYPE_ERROR, "%s:%d: missing bundle %p 0x%x %@", buf, 0x2Cu);
      }
      *__error() = v32;
      goto LABEL_32;
    }
    Mutable = (const void *)_MDPlistContainerCreateMutable();
    _MDPlistContainerBeginContainer();
    _MDPlistContainerBeginArray();
    _MDPlistContainerAddObject();
    _MDPlistContainerAddObject();
    _MDPlistContainerEndArray();
    _MDPlistContainerEndContainer();
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 1632));
    JournalFd = getJournalFd(a1, 0, 0);
    if (!JournalFd)
    {
      v26 = 0;
      v36 = 0;
LABEL_42:
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1632));
      CFRelease(Mutable);
      if (v36)
      {
        v38 = v50;
        v37 = (uint64_t)v51;
        v39 = si_mobile_set_attr_ctx_create(a1, a2);
        v51 = v39;
        v39[1] = v26;
        v39[2] = v37;
        v39[3] = v38;
        *((_BYTE *)v39 + 32) = a5 != 0;
        *(_DWORD *)((char *)v39 + 33) = 0;
        *((_DWORD *)v39 + 9) = 0;
        do
        {
          v40 = __ldxr(&gEnqueuedSize);
          v41 = (uint64_t)&v38[v40];
        }
        while (__stxr((unint64_t)&v38[v40], &gEnqueuedSize));
        a5 = v48;
        a6 = v49;
        if (v48 && v41 >= 0x40000)
        {
          v42 = *__error();
          v43 = _SILogForLogForCategory(0);
          v44 = 2 * (gSILogLevels[0] < 4);
          if (os_log_type_enabled(v43, v44))
          {
            *(_DWORD *)buf = 134218240;
            v53 = v38;
            v54 = 2048;
            *(_QWORD *)v55 = v41;
            _os_log_impl(&dword_1B8270000, v43, v44, "#index too much enqueued (%ld); defer callback for work unit of %ld",
              buf,
              0x16u);
          }
          *__error() = v42;
          v39[5] = v48;
          v39[6] = v49;
          a5 = 0;
        }
        *((CFAbsoluteTime *)v39 + 8) = CFAbsoluteTimeGetCurrent();
        v45 = si_backtrace_routine_resolve(*v39, (const __CFString *)v39[9], (uint64_t (*)())setCSAttributes1, v39, &v51);
        si_enqueue_barrier_with_qos(*(_QWORD *)(a1 + 1048), 9, (uint64_t)v45, (uint64_t)v51);
        goto LABEL_51;
      }
      a5 = v48;
      if (v26)
      {
        do
        {
          v46 = __ldaxr((unsigned int *)v26);
          v47 = v46 - 1;
        }
        while (__stlxr(v47, (unsigned int *)v26));
        if (!v47)
          _si_mobile_journal_finalize(v26, 1);
      }
LABEL_32:
      result = 0;
      a6 = v49;
      if (!a5)
        return result;
      goto LABEL_52;
    }
    v25 = JournalFd;
    v26 = *(_QWORD *)(a1 + 2104);
    if (v26)
    {
      if (*(char **)(v26 + 8) == JournalFd)
      {
        do
LABEL_35:
          v34 = __ldaxr((unsigned int *)v26);
        while (__stlxr(v34 + 1, (unsigned int *)v26));
LABEL_36:
        v35 = (unint64_t *)(a1 + 2128);
        do
          a5 = (void (*)(_QWORD, _QWORD))__ldxr(v35);
        while (__stxr((unint64_t)a5 + 1, v35));
        if (si_clientstatesandmeta_update(a1, (uint64_t)a5 + 1, 0))
        {
          v50 = 0;
          v51 = 0;
          v36 = mobile_journal_plist(v25, (unint64_t)a5, a4, (uint64_t)Mutable, (uint64_t *)&v51, &v50) == 0;
        }
        else
        {
          v36 = 0;
        }
        goto LABEL_42;
      }
      do
      {
        v27 = __ldaxr((unsigned int *)v26);
        v28 = v27 - 1;
      }
      while (__stlxr(v28, (unsigned int *)v26));
      if (!v28)
        _si_mobile_journal_finalize(v26, 1);
      *(_QWORD *)(a1 + 2104) = 0;
    }
    if (*(_BYTE *)(a1 + 2072) && (*(_BYTE *)(a1 + 829) & 0x10) == 0 && _os_feature_enabled_impl())
      _os_feature_enabled_impl();
    v26 = si_mobile_journal_create(a1);
    *(_QWORD *)(a1 + 2104) = v26;
    if (!v26)
      goto LABEL_36;
    goto LABEL_35;
  }
LABEL_51:
  result = 1;
  if (!a5)
    return result;
LABEL_52:
  if ((_DWORD)result)
  {
    a5(a6, 0);
    return 1;
  }
  return result;
}

uint64_t __mobile_journal_transfer_paths_block_invoke(uint64_t a1, char *__s1)
{
  uint64_t result;

  result = strncmp(__s1, "skg_", 4uLL);
  if (!(_DWORD)result)
  {
    result = renameat(*(_DWORD *)(a1 + 40), __s1, *(_DWORD *)(a1 + 44), __s1);
    if ((_DWORD)result)
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = 1;
  }
  return result;
}

uint64_t __get_files_for_directory_block_invoke(uint64_t a1, uint64_t a2, int *a3, int a4)
{
  int v5;

  if (**(_DWORD **)(a1 + 40))
    return 1;
  if (a4)
    return 2;
  v5 = a3[1];
  if (v5 == 1)
  {
    if (!*(_BYTE *)(a1 + 48) && *a3 > 0)
      return 2;
  }
  else if (!v5)
  {
    (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  }
  return 0;
}

uint64_t SIGetCSAttributes(uint64_t a1, const void *a2, const void *a3, const void *a4, const void *a5, int a6, const void *a7)
{
  CFAbsoluteTime *v14;
  uint64_t v15;
  qos_class_t v16;

  v14 = (CFAbsoluteTime *)malloc_type_calloc(1uLL, 0x40uLL, 0x10E0040D1AEC469uLL);
  *(_QWORD *)v14 = a1;
  *((_QWORD *)v14 + 1) = CFRetain(a2);
  *((_QWORD *)v14 + 2) = CFRetain(a3);
  *((_QWORD *)v14 + 3) = CFRetain(a4);
  v14[4] = CFAbsoluteTimeGetCurrent();
  if (a5)
    CFRetain(a5);
  *((_QWORD *)v14 + 5) = a5;
  *((_DWORD *)v14 + 12) = a6;
  *((_QWORD *)v14 + 7) = _Block_copy(a7);
  v15 = *(_QWORD *)(a1 + 1080);
  v16 = qos_class_self();
  si_enqueue_work_with_qos(v15, v16, (uint64_t)si_getCSAttr, (uint64_t)v14);
  return 0;
}

uint64_t SIGetCacheFd(uint64_t a1, const void *a2)
{
  _QWORD *v4;
  uint64_t v5;
  qos_class_t v6;

  v4 = malloc_type_calloc(1uLL, 0x10uLL, 0xA0040AFF93C70uLL);
  *v4 = a1;
  v4[1] = _Block_copy(a2);
  v5 = *(_QWORD *)(a1 + 1080);
  v6 = qos_class_self();
  si_enqueue_work_with_qos(v5, v6, (uint64_t)si_getCacheFd, (uint64_t)v4);
  return 0;
}

uint64_t SIGetCacheEntry(uint64_t a1, const void *a2, const void *a3, const void *a4)
{
  _QWORD *v8;
  uint64_t v9;
  qos_class_t v10;

  v8 = malloc_type_calloc(1uLL, 0x20uLL, 0xE0040C8AD4411uLL);
  *v8 = a1;
  v8[1] = CFRetain(a2);
  v8[2] = CFRetain(a3);
  v8[3] = _Block_copy(a4);
  v9 = *(_QWORD *)(a1 + 1080);
  v10 = qos_class_self();
  si_enqueue_work_with_qos(v9, v10, (uint64_t)si_getCacheEntry, (uint64_t)v8);
  return 0;
}

uint64_t SISetCacheEntry(uint64_t a1, const void *a2)
{
  int v3;
  NSObject *v4;
  uint64_t v5;
  _QWORD *v7;
  int v9;
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 1280))
  {
    v3 = *__error();
    v4 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 134217984;
      v10 = a1;
      _os_log_impl(&dword_1B8270000, v4, OS_LOG_TYPE_DEFAULT, "Can't set cache entry because the index is read-only. ref:%p", (uint8_t *)&v9, 0xCu);
    }
    v5 = 0;
    *__error() = v3;
  }
  else
  {
    v5 = 1;
    v7 = malloc_type_calloc(1uLL, 0x10uLL, 0x60040FAFB2B2FuLL);
    *v7 = a1;
    v7[1] = CFRetain(a2);
    si_enqueue_work_with_qos(*(_QWORD *)(a1 + 1048), 9, (uint64_t)si_setCacheEntry, (uint64_t)v7);
  }
  return v5;
}

uint64_t SIDeleteCacheEntry(uint64_t a1, const void *a2)
{
  int v3;
  NSObject *v4;
  int *v5;
  uint64_t result;
  _QWORD *v8;
  int v9;
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 1280))
  {
    v3 = *__error();
    v4 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      v9 = 134217984;
      v10 = a1;
      _os_log_impl(&dword_1B8270000, v4, OS_LOG_TYPE_DEFAULT, "Can't delete cache entry because the index is read-only. ref:%p", (uint8_t *)&v9, 0xCu);
    }
    v5 = __error();
    result = 0;
    *v5 = v3;
  }
  else
  {
    v8 = malloc_type_calloc(1uLL, 0x18uLL, 0x60040149E097CuLL);
    *v8 = a1;
    if (a2)
      v8[2] = CFRetain(a2);
    si_enqueue_work_with_qos(*(_QWORD *)(a1 + 1048), 9, (uint64_t)si_deleteCacheEntry, (uint64_t)v8);
    return 1;
  }
  return result;
}

uint64_t SICloseCache(uint64_t a1)
{
  _QWORD *v2;

  v2 = malloc_type_calloc(1uLL, 0x10uLL, 0x60040FAFB2B2FuLL);
  *v2 = a1;
  si_enqueue_work_with_qos(*(_QWORD *)(a1 + 1048), 9, (uint64_t)si_closeCache, (uint64_t)v2);
  return 1;
}

uint64_t SIHoldAssertion(uint64_t a1, int a2, double a3)
{
  uint64_t v3;
  int v4;
  NSObject *v5;
  char *v8;
  double v9;
  char *v10;
  size_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  NSObject *v19;
  int v20;
  NSObject *v21;
  int v22;
  int v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int *v33;
  char *v34;
  int v35;
  int *v36;
  char *v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  int v41;
  char v42;
  BOOL v43;
  char v44;
  BOOL v45;
  char v46;
  char *JournalFd;
  int v48;
  char v49;
  int v51;
  int v52;
  NSObject *v53;
  int *v54;
  char *v55;
  int v56;
  const char *v57;
  uint8_t *v58;
  size_t v59;
  uint64_t v60;
  int *v61;
  char *v62;
  int v63;
  int *v64;
  char *v65;
  int v66;
  int v68;
  NSObject *v69;
  int v70;
  char *v71;
  char *v72;
  const char *v73;
  _QWORD v74[2];
  BOOL (*v75)(double *, uint64_t *);
  void *v76;
  uint64_t *v77;
  double v78;
  char *v79;
  uint64_t v80;
  uint64_t *v81;
  uint64_t v82;
  char v83;
  uint8_t v84[4];
  const char *v85;
  __int16 v86;
  int v87;
  __int16 v88;
  char *v89;
  __int16 v90;
  int v91;
  uint8_t v92[64];
  uint8_t buf[1032];
  uint64_t v94;

  v3 = a1;
  v94 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return v3;
  if (!*(_BYTE *)(a1 + 1280))
  {
    v80 = 0;
    v81 = &v80;
    v82 = 0x2000000000;
    v83 = 1;
    v8 = 0;
    v9 = CFAbsoluteTimeGetCurrent() + a3;
    if (a2)
    {
      v10 = (char *)fd_create_protected(*(_DWORD *)(v3 + 32), "bgassertions", 536872449, 3u);
      if (!v10)
      {
        v18 = *__error();
        v19 = _SILogForLogForCategory(10);
        if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        {
          v33 = __error();
          v34 = strerror(*v33);
          v35 = *__error();
          *(_DWORD *)buf = 136315906;
          *(_QWORD *)&buf[4] = "SIHoldAssertion";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 19077;
          *(_WORD *)&buf[18] = 2080;
          *(_QWORD *)&buf[20] = v34;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = v35;
          _os_log_error_impl(&dword_1B8270000, v19, OS_LOG_TYPE_ERROR, "%s:%d: Unable to create bg assertion touch file: %s(%d)", buf, 0x22u);
        }
        v3 = 0;
        *__error() = v18;
        goto LABEL_90;
      }
      v8 = v10;
      memset(buf, 0, 55);
      __sprintf_chk((char *)buf, 0, 0x37uLL, "%d$F$", (int)v9);
      v11 = strlen((const char *)buf);
      v12 = fd_write((uint64_t)v8, (uint64_t)buf, v11);
      if (v12 != strlen((const char *)buf))
      {
        v20 = *__error();
        v21 = _SILogForLogForCategory(10);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        {
          v36 = __error();
          v37 = strerror(*v36);
          v38 = *__error();
          *(_DWORD *)v92 = 136315906;
          *(_QWORD *)&v92[4] = "SIHoldAssertion";
          *(_WORD *)&v92[12] = 1024;
          *(_DWORD *)&v92[14] = 19083;
          *(_WORD *)&v92[18] = 2080;
          *(_QWORD *)&v92[20] = v37;
          *(_WORD *)&v92[28] = 1024;
          *(_DWORD *)&v92[30] = v38;
          _os_log_error_impl(&dword_1B8270000, v21, OS_LOG_TYPE_ERROR, "%s:%d: bg assertion touch file write error: %s(%d)", v92, 0x22u);
        }
        *__error() = v20;
        fd_release(v8);
        goto LABEL_89;
      }
    }
    v13 = *(_QWORD *)(v3 + 1384);
    v74[0] = MEMORY[0x1E0C809B0];
    v74[1] = 0x40000000;
    v75 = __SIHoldAssertion_block_invoke;
    v76 = &unk_1E6E2CE88;
    v78 = a3;
    v79 = v8;
    v77 = &v80;
    if (v13 && *(_DWORD *)(v13 + 8))
    {
      v14 = 0;
      do
      {
        if (!((unsigned int (*)(_QWORD *, _QWORD, uint64_t))v75)(v74, *(_QWORD *)(*(_QWORD *)v13 + 8 * v14), 1))break;
        ++v14;
      }
      while (v14 < *(unsigned int *)(v13 + 8));
    }
    if (!*((_BYTE *)v81 + 24))
      goto LABEL_71;
    v15 = *(_QWORD *)(v3 + 1184);
    if (*(_DWORD *)v15 != 1685287992)
    {
      v68 = *__error();
      v69 = _SILogForLogForCategory(4);
      if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
      {
        v70 = *(_DWORD *)v15;
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = "db_datastore_hold_assertion";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 239;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v70;
        _os_log_error_impl(&dword_1B8270000, v69, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
      }
      *__error() = v68;
      v71 = __si_assert_copy_extra_268();
      v72 = v71;
      if (v71)
        v73 = v71;
      else
        v73 = "";
      __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 239, v73);
      free(v72);
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    if (db_read_lock(v15 + 584))
      sdb2_die(v15, "Multiple threads entering in sdb!", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 14959);
    if ((fd_hold_assertion(*(_QWORD *)(v15 + 848), (uint64_t)v8, a3) & 0x80000000) != 0)
    {
      v22 = pthread_mutex_lock((pthread_mutex_t *)(v15 + 584));
      v23 = *(_DWORD *)(v15 + 780) - 1;
      *(_DWORD *)(v15 + 780) = v23;
      if (!v23)
        db_rwlock_wakeup(v15 + 584, 0, 0);
      pthread_mutex_unlock((pthread_mutex_t *)(v15 + 584));
      if (v22)
        sdb2_die(v15, "Multiple threads in sdb! (leaving)", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 14962);
    }
    else if ((fd_hold_assertion(*(_QWORD *)(v15 + 840), (uint64_t)v8, a3) & 0x80000000) != 0)
    {
      v22 = pthread_mutex_lock((pthread_mutex_t *)(v15 + 584));
      v24 = *(_DWORD *)(v15 + 780) - 1;
      *(_DWORD *)(v15 + 780) = v24;
      if (!v24)
        db_rwlock_wakeup(v15 + 584, 0, 0);
      pthread_mutex_unlock((pthread_mutex_t *)(v15 + 584));
      if (v22)
        sdb2_die(v15, "Multiple threads in sdb! (leaving)", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 14967);
    }
    else
    {
      v16 = *(_QWORD *)(v15 + 880);
      v17 = *(_DWORD *)(v16 + 216) == -270471200 ? 0 : *(_QWORD *)(v16 + 272);
      if ((fd_hold_assertion(v17, (uint64_t)v8, a3) & 0x80000000) != 0)
        goto LABEL_59;
      v25 = *(_QWORD *)(v15 + 888);
      v26 = *(_DWORD *)(v25 + 216) == -270471200 ? 0 : *(_QWORD *)(v25 + 272);
      if ((fd_hold_assertion(v26, (uint64_t)v8, a3) & 0x80000000) != 0)
        goto LABEL_59;
      v27 = *(_QWORD *)(v15 + 896);
      v28 = *(_DWORD *)(v27 + 216) == -270471200 ? 0 : *(_QWORD *)(v27 + 272);
      if ((fd_hold_assertion(v28, (uint64_t)v8, a3) & 0x80000000) != 0
        || ((v29 = *(_QWORD *)(v15 + 904), *(_DWORD *)(v29 + 216) == -270471200)
          ? (v30 = 0)
          : (v30 = *(_QWORD *)(v29 + 272)),
            (fd_hold_assertion(v30, (uint64_t)v8, a3) & 0x80000000) != 0
         || ((v31 = *(_QWORD *)(v15 + 912), *(_DWORD *)(v31 + 216) == -270471200)
           ? (v32 = 0)
           : (v32 = *(_QWORD *)(v31 + 272)),
             (fd_hold_assertion(v32, (uint64_t)v8, a3) & 0x80000000) != 0
          || ((v39 = *(_QWORD *)(v15 + 920), *(_DWORD *)(v39 + 216) == -270471200)
            ? (v40 = 0)
            : (v40 = *(_QWORD *)(v39 + 272)),
              (fd_hold_assertion(v40, (uint64_t)v8, a3) & 0x80000000) != 0))))
      {
LABEL_59:
        v22 = pthread_mutex_lock((pthread_mutex_t *)(v15 + 584));
        v41 = *(_DWORD *)(v15 + 780) - 1;
        *(_DWORD *)(v15 + 780) = v41;
        if (!v41)
          db_rwlock_wakeup(v15 + 584, 0, 0);
        pthread_mutex_unlock((pthread_mutex_t *)(v15 + 584));
        if (v22)
          sdb2_die(v15, "Multiple threads in sdb! (leaving)", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 14973);
      }
      else
      {
        LOBYTE(v22) = 1;
        *(_BYTE *)(v15 + 988) = 1;
        if (db_read_unlock(v15 + 584))
          sdb2_die(v15, "Multiple threads in sdb! (leaving)", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 14980);
      }
    }
    v42 = v81[3] & v22;
    *((_BYTE *)v81 + 24) = v42;
    if ((v42 & 1) == 0)
      goto LABEL_71;
    v43 = _SICreateFdAndHoldAssertion(*(_DWORD *)(v3 + 32), (uint64_t)v8, "dirStore.overlay", a3);
    v44 = v81[3] & v43;
    *((_BYTE *)v81 + 24) = v44;
    if ((v44 & 1) == 0)
      goto LABEL_71;
    v45 = _SICreateFdAndHoldAssertion(*(_DWORD *)(v3 + 32), (uint64_t)v8, "tmp.spotlight.loc", a3);
    v46 = v81[3] & v45;
    *((_BYTE *)v81 + 24) = v46;
    if ((v46 & 1) != 0
      && (JournalFd = getJournalFd(v3, 0, 0),
          v48 = fd_hold_assertion((uint64_t)JournalFd, (uint64_t)v8, a3),
          v49 = v81[3] & (v48 >= 0),
          *((_BYTE *)v81 + 24) = v49,
          (v49 & 1) != 0))
    {
      *(_DWORD *)(v3 + 6960) = 0;
      bzero(buf, 0x400uLL);
      fd_name((uint64_t)JournalFd, (char *)buf, 0x400uLL);
      if (*(_QWORD *)buf == 0x416C616E72756F6ALL && *(_DWORD *)&buf[8] == 779252852)
      {
        *(_QWORD *)v92 = 0;
        v51 = strtoll((const char *)&buf[12], (char **)v92, 0);
        *(_DWORD *)(v3 + 6960) = v51;
      }
      else
      {
        v51 = *(_DWORD *)(v3 + 6960);
      }
      if (v51 <= 0)
        goto LABEL_88;
      if (v8)
      {
        if (fd_lseek(v8, 0, 0))
        {
          v52 = *__error();
          v53 = _SILogForLogForCategory(10);
          if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
          {
            v54 = __error();
            v55 = strerror(*v54);
            v56 = *__error();
            *(_DWORD *)v92 = 136315906;
            *(_QWORD *)&v92[4] = "SIHoldAssertion";
            *(_WORD *)&v92[12] = 1024;
            *(_DWORD *)&v92[14] = 19147;
            *(_WORD *)&v92[18] = 2080;
            *(_QWORD *)&v92[20] = v55;
            *(_WORD *)&v92[28] = 1024;
            *(_DWORD *)&v92[30] = v56;
            v57 = "%s:%d: bg assertion touch file lseek error: %s(%d)";
            v58 = v92;
LABEL_86:
            _os_log_error_impl(&dword_1B8270000, v53, OS_LOG_TYPE_ERROR, v57, v58, 0x22u);
          }
LABEL_87:
          *__error() = v52;
LABEL_88:
          fd_release(v8);
          SIDropAssertion(v3);
LABEL_89:
          v3 = 0;
          goto LABEL_90;
        }
        memset(v92, 0, 55);
        __sprintf_chk((char *)v92, 0, 0x37uLL, "%d$S$", (int)v9);
        v59 = strlen((const char *)v92);
        v60 = fd_write((uint64_t)v8, (uint64_t)v92, v59);
        if (v60 != strlen((const char *)v92))
        {
          v52 = *__error();
          v53 = _SILogForLogForCategory(10);
          if (!os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
            goto LABEL_87;
          v64 = __error();
          v65 = strerror(*v64);
          v66 = *__error();
          *(_DWORD *)v84 = 136315906;
          v85 = "SIHoldAssertion";
          v86 = 1024;
          v87 = 19155;
          v88 = 2080;
          v89 = v65;
          v90 = 1024;
          v91 = v66;
          v57 = "%s:%d: bg assertion touch file write error: %s(%d)";
          goto LABEL_85;
        }
        if (fd_sync((uint64_t)v8, 1))
        {
          v52 = *__error();
          v53 = _SILogForLogForCategory(10);
          if (!os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
            goto LABEL_87;
          v61 = __error();
          v62 = strerror(*v61);
          v63 = *__error();
          *(_DWORD *)v84 = 136315906;
          v85 = "SIHoldAssertion";
          v86 = 1024;
          v87 = 19162;
          v88 = 2080;
          v89 = v62;
          v90 = 1024;
          v91 = v63;
          v57 = "%s:%d: bg assertion touch file fsync error: %s(%d)";
LABEL_85:
          v58 = v84;
          goto LABEL_86;
        }
        fd_release(v8);
      }
    }
    else
    {
LABEL_71:
      fd_release(v8);
      SIDropAssertion(v3);
    }
    v3 = *((unsigned __int8 *)v81 + 24);
LABEL_90:
    _Block_object_dispose(&v80, 8);
    return v3;
  }
  v4 = *__error();
  v5 = _SILogForLogForCategory(10);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 134217984;
    *(_QWORD *)&buf[4] = v3;
    _os_log_impl(&dword_1B8270000, v5, OS_LOG_TYPE_DEFAULT, "Can't hold assertions because the index is read-only. ref:%p", buf, 0xCu);
  }
  v3 = 0;
  *__error() = v4;
  return v3;
}

uint64_t SIDropAssertion(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  int v25;
  int v26;
  BOOL v27;
  BOOL v28;
  char *JournalFd;
  int v30;
  int v32;
  NSObject *v33;
  int v34;
  char *v35;
  char *v36;
  const char *v37;
  int v38;
  int v39;
  _QWORD v40[2];
  uint64_t (*v41)(uint64_t, uint64_t *);
  void *v42;
  uint64_t *v43;
  uint64_t v44;
  uint64_t *v45;
  uint64_t v46;
  char v47;
  uint8_t buf[4];
  const char *v49;
  __int16 v50;
  int v51;
  __int16 v52;
  int v53;
  uint64_t v54;

  v1 = a1;
  v54 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v44 = 0;
    v45 = &v44;
    v46 = 0x2000000000;
    v47 = 0;
    v47 = SIDeleteBgAssertionFile(a1);
    v2 = *(_QWORD *)(v1 + 1384);
    v40[0] = MEMORY[0x1E0C809B0];
    v40[1] = 0x40000000;
    v41 = __SIDropAssertion_block_invoke;
    v42 = &unk_1E6E2CEB0;
    v43 = &v44;
    if (v2 && *(_DWORD *)(v2 + 8))
    {
      v3 = 0;
      do
      {
        if (!((unsigned int (*)(_QWORD *, _QWORD, uint64_t))v41)(v40, *(_QWORD *)(*(_QWORD *)v2 + 8 * v3), 1))break;
        ++v3;
      }
      while (v3 < *(unsigned int *)(v2 + 8));
    }
    v4 = *(_QWORD *)(v1 + 1184);
    if (*(_DWORD *)v4 != 1685287992)
    {
      v32 = *__error();
      v33 = _SILogForLogForCategory(4);
      if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
      {
        v34 = *(_DWORD *)v4;
        *(_DWORD *)buf = 136315650;
        v49 = "db_datastore_drop_assertion";
        v50 = 1024;
        v51 = 240;
        v52 = 1024;
        v53 = v34;
        _os_log_error_impl(&dword_1B8270000, v33, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
      }
      *__error() = v32;
      v35 = __si_assert_copy_extra_268();
      v36 = v35;
      if (v35)
        v37 = v35;
      else
        v37 = "";
      __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 240, v37);
      free(v36);
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    if (db_read_lock(v4 + 584))
      sdb2_die(v4, "Multiple threads entering in sdb!", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 14988);
    *(_BYTE *)(v4 + 988) = 0;
    v5 = fd_drop_assertion(*(_QWORD *)(v4 + 848));
    v6 = fd_drop_assertion(*(_QWORD *)(v4 + 840));
    v7 = *(_QWORD *)(v4 + 880);
    v39 = v6;
    if (*(_DWORD *)(v7 + 216) == -270471200)
      v8 = 0;
    else
      v8 = *(_QWORD *)(v7 + 272);
    v9 = fd_drop_assertion(v8);
    v10 = *(_QWORD *)(v4 + 888);
    v38 = v9;
    if (*(_DWORD *)(v10 + 216) == -270471200)
      v11 = 0;
    else
      v11 = *(_QWORD *)(v10 + 272);
    v12 = fd_drop_assertion(v11);
    v13 = *(_QWORD *)(v4 + 896);
    if (*(_DWORD *)(v13 + 216) == -270471200)
      v14 = 0;
    else
      v14 = *(_QWORD *)(v13 + 272);
    v15 = fd_drop_assertion(v14);
    v16 = *(_QWORD *)(v4 + 904);
    if (*(_DWORD *)(v16 + 216) == -270471200)
      v17 = 0;
    else
      v17 = *(_QWORD *)(v16 + 272);
    v18 = fd_drop_assertion(v17);
    v19 = *(_QWORD *)(v4 + 912);
    if (*(_DWORD *)(v19 + 216) == -270471200)
      v20 = 0;
    else
      v20 = *(_QWORD *)(v19 + 272);
    v21 = fd_drop_assertion(v20);
    v22 = *(_QWORD *)(v4 + 920);
    if (*(_DWORD *)(v22 + 216) == -270471200)
      v23 = 0;
    else
      v23 = *(_QWORD *)(v22 + 272);
    v24 = fd_drop_assertion(v23);
    v25 = pthread_mutex_lock((pthread_mutex_t *)(v4 + 584));
    v26 = *(_DWORD *)(v4 + 780) - 1;
    *(_DWORD *)(v4 + 780) = v26;
    if (!v26)
      db_rwlock_wakeup(v4 + 584, 0, 0);
    pthread_mutex_unlock((pthread_mutex_t *)(v4 + 584));
    if (v25)
      sdb2_die(v4, "Multiple threads in sdb! (leaving)", "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/core-db/serial-db2/sdb2.c", 15000);
    *((_BYTE *)v45 + 24) &= (v39 | v5 | v38 | v12 | v15 | v18 | v21 | v24) >= 0;
    v27 = _SICreateFdAndDropAssertion(*(_DWORD *)(v1 + 32), "dirStore.overlay");
    *((_BYTE *)v45 + 24) &= v27;
    v28 = _SICreateFdAndDropAssertion(*(_DWORD *)(v1 + 32), "tmp.spotlight.loc");
    *((_BYTE *)v45 + 24) &= v28;
    JournalFd = getJournalFd(v1, 0, 0);
    v30 = fd_drop_assertion((uint64_t)JournalFd);
    v1 = (_BYTE)v45[3] & (v30 >= 0);
    *((_BYTE *)v45 + 24) &= v30 >= 0;
    _Block_object_dispose(&v44, 8);
  }
  return v1;
}

BOOL _SICreateFdAndHoldAssertion(int a1, uint64_t a2, const char *a3, double a4)
{
  char *v7;
  char *v8;
  int v9;
  _BOOL8 v10;
  int v11;
  NSObject *v12;
  int v13;
  NSObject *v14;
  int v16;
  int *v17;
  char *v18;
  int v19;
  int *v20;
  char *v21;
  uint64_t v22;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  int v26;
  __int16 v27;
  _BYTE v28[14];
  __int16 v29;
  _DWORD v30[7];

  *(_QWORD *)&v30[5] = *MEMORY[0x1E0C80C00];
  v7 = (char *)fd_create_protected(a1, a3, 514, 0);
  if (v7)
  {
    v8 = v7;
    v22 = 0;
    v9 = _fd_acquire_fd((uint64_t)v7, &v22);
    if (v9 < 0)
    {
      v13 = *__error();
      v14 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        v19 = *__error();
        v20 = __error();
        v21 = strerror(*v20);
        *(_DWORD *)buf = 136316418;
        v24 = "_SICreateFdAndHoldAssertion";
        v25 = 1024;
        v26 = 19023;
        v27 = 1024;
        *(_DWORD *)v28 = v9;
        *(_WORD *)&v28[4] = 2080;
        *(_QWORD *)&v28[6] = a3;
        v29 = 1024;
        v30[0] = v19;
        LOWORD(v30[1]) = 2080;
        *(_QWORD *)((char *)&v30[1] + 2) = v21;
        _os_log_error_impl(&dword_1B8270000, v14, OS_LOG_TYPE_ERROR, "%s:%d: fd = %d for %s file: %d(%s)", buf, 0x32u);
      }
      v10 = 0;
      *__error() = v13;
    }
    else
    {
      v10 = (int)fd_hold_assertion((uint64_t)v8, a2, a4) >= 0;
      _fd_release_fd(v8, v9, 0, v22);
    }
    fd_release(v8);
  }
  else
  {
    v11 = *__error();
    v12 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      v16 = *__error();
      v17 = __error();
      v18 = strerror(*v17);
      *(_DWORD *)buf = 136316162;
      v24 = "_SICreateFdAndHoldAssertion";
      v25 = 1024;
      v26 = 19011;
      v27 = 2080;
      *(_QWORD *)v28 = a3;
      *(_WORD *)&v28[8] = 1024;
      *(_DWORD *)&v28[10] = v16;
      v29 = 2080;
      *(_QWORD *)v30 = v18;
      _os_log_error_impl(&dword_1B8270000, v12, OS_LOG_TYPE_ERROR, "%s:%d: Unable to get fdptr for %s file: %d(%s)", buf, 0x2Cu);
    }
    v10 = 0;
    *__error() = v11;
  }
  return v10;
}

uint64_t SIDeleteBgAssertionFile(uint64_t a1)
{
  char *v1;
  char *v2;
  uint64_t v3;
  int v4;
  NSObject *v5;
  os_log_type_t v6;
  int *v7;
  char *v8;
  int v9;
  int v10;
  NSObject *v11;
  os_log_type_t v12;
  int *v13;
  char *v14;
  int v15;
  int v17;
  char *v18;
  __int16 v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0;
  v1 = (char *)fd_create_protected(*(_DWORD *)(a1 + 32), "bgassertions", 536870914, 0);
  if (v1)
  {
    v2 = v1;
    if ((_fd_unlink_with_origin((uint64_t)v1, 0) & 0x80000000) != 0)
    {
      v10 = *__error();
      v11 = _SILogForLogForCategory(10);
      v12 = dword_1EF19FCB4 < 3;
      if (os_log_type_enabled(v11, (os_log_type_t)(dword_1EF19FCB4 < 3)))
      {
        v13 = __error();
        v14 = strerror(*v13);
        v15 = *__error();
        v17 = 136315394;
        v18 = v14;
        v19 = 1024;
        v20 = v15;
        _os_log_impl(&dword_1B8270000, v11, v12, "*warn* Unable to delete bg assertion touch file: %s(%d)", (uint8_t *)&v17, 0x12u);
      }
      v3 = 0;
      *__error() = v10;
    }
    else
    {
      v3 = 1;
    }
    fd_release(v2);
  }
  else
  {
    v4 = *__error();
    v5 = _SILogForLogForCategory(10);
    v6 = dword_1EF19FCB4 < 3;
    if (os_log_type_enabled(v5, (os_log_type_t)(dword_1EF19FCB4 < 3)))
    {
      v7 = __error();
      v8 = strerror(*v7);
      v9 = *__error();
      v17 = 136315394;
      v18 = v8;
      v19 = 1024;
      v20 = v9;
      _os_log_impl(&dword_1B8270000, v5, v6, "*warn* Unable to open bg assertion touch file: %s(%d)", (uint8_t *)&v17, 0x12u);
    }
    v3 = 0;
    *__error() = v4;
  }
  return v3;
}

BOOL _SICreateFdAndDropAssertion(int a1, const char *a2)
{
  char *v3;
  char *v4;
  int v5;
  _BOOL8 v6;
  int v7;
  NSObject *v8;
  int v9;
  NSObject *v10;
  int v12;
  int *v13;
  char *v14;
  int v15;
  int *v16;
  char *v17;
  uint64_t v18;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  int v22;
  __int16 v23;
  _BYTE v24[14];
  __int16 v25;
  _DWORD v26[7];

  *(_QWORD *)&v26[5] = *MEMORY[0x1E0C80C00];
  v3 = (char *)fd_create_protected(a1, a2, 2, 0);
  if (v3)
  {
    v4 = v3;
    v18 = 0;
    v5 = _fd_acquire_fd((uint64_t)v3, &v18);
    if (v5 < 0)
    {
      v9 = *__error();
      v10 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        v15 = *__error();
        v16 = __error();
        v17 = strerror(*v16);
        *(_DWORD *)buf = 136316418;
        v20 = "_SICreateFdAndDropAssertion";
        v21 = 1024;
        v22 = 19049;
        v23 = 1024;
        *(_DWORD *)v24 = v5;
        *(_WORD *)&v24[4] = 2080;
        *(_QWORD *)&v24[6] = a2;
        v25 = 1024;
        v26[0] = v15;
        LOWORD(v26[1]) = 2080;
        *(_QWORD *)((char *)&v26[1] + 2) = v17;
        _os_log_error_impl(&dword_1B8270000, v10, OS_LOG_TYPE_ERROR, "%s:%d: fd = %d for %s file: %d(%s)", buf, 0x32u);
      }
      v6 = 0;
      *__error() = v9;
    }
    else
    {
      v6 = (int)fd_drop_assertion((uint64_t)v4) >= 0;
      _fd_release_fd(v4, v5, 0, v18);
    }
    fd_release(v4);
  }
  else
  {
    v7 = *__error();
    v8 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      v12 = *__error();
      v13 = __error();
      v14 = strerror(*v13);
      *(_DWORD *)buf = 136316162;
      v20 = "_SICreateFdAndDropAssertion";
      v21 = 1024;
      v22 = 19036;
      v23 = 2080;
      *(_QWORD *)v24 = a2;
      *(_WORD *)&v24[8] = 1024;
      *(_DWORD *)&v24[10] = v12;
      v25 = 2080;
      *(_QWORD *)v26 = v14;
      _os_log_error_impl(&dword_1B8270000, v8, OS_LOG_TYPE_ERROR, "%s:%d: Unable to get fdptr for %s file: %d(%s)", buf, 0x2Cu);
    }
    v6 = 0;
    *__error() = v7;
  }
  return v6;
}

uint64_t SISetBgAssertionFlag(uint64_t result, char a2)
{
  if (result)
  {
    *(_BYTE *)(result + 6944) = a2;
    result = *(_QWORD *)(result + 1184);
    if (result)
      return db_datastore_set_bg_assertion_flag(result, a2);
  }
  return result;
}

uint64_t _SISetAssertedJournalNum(uint64_t result, int a2)
{
  if (result)
    *(_DWORD *)(result + 6960) = a2;
  return result;
}

uint64_t SISetLockedJournalingState(uint64_t result, int a2)
{
  if (result)
    *(_DWORD *)(result + 6964) = a2;
  return result;
}

void SICreateAssertedJournalFile(uint64_t a1)
{
  char *v1;
  char *v2;
  int v3;
  NSObject *v4;
  int v5;
  int *v6;
  char *v7;
  int v8;
  const char *v9;
  __int16 v10;
  int v11;
  __int16 v12;
  int v13;
  __int16 v14;
  char *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v1 = (char *)fd_create_protected(*(_DWORD *)(a1 + 32), "assertedJournalAttr.1", 536872458, 2u);
    if (v1)
    {
      v2 = v1;
      fd_hold_assertion((uint64_t)v1, 0, 36000.0);
      fd_release(v2);
    }
    else
    {
      v3 = *__error();
      v4 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        v5 = *__error();
        v6 = __error();
        v7 = strerror(*v6);
        v8 = 136315906;
        v9 = "SICreateAssertedJournalFile";
        v10 = 1024;
        v11 = 19238;
        v12 = 1024;
        v13 = v5;
        v14 = 2080;
        v15 = v7;
        _os_log_error_impl(&dword_1B8270000, v4, OS_LOG_TYPE_ERROR, "%s:%d: SICreateAssertedJournalFile: Unable to open asserted journal file %d(%s)", (uint8_t *)&v8, 0x22u);
      }
      *__error() = v3;
    }
  }
}

uint64_t SIGetLockedJournalingState(uint64_t result)
{
  if (result)
    return *(unsigned int *)(result + 6964);
  return result;
}

uint64_t SIIsLockedIndexingMode(uint64_t result)
{
  if (result)
    return (*(unsigned __int8 *)(result + 830) >> 2) & 1;
  return result;
}

void _SIValidateActivityJournal(uint64_t a1)
{
  int v2;
  int v3;
  uint64_t v4;
  _BYTE v5[1024];
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    bzero(v5, 0x400uLL);
    v4 = 0;
    v2 = _fd_acquire_fd(*(_QWORD *)(a1 + 2192), &v4);
    if (v2 != -1)
    {
      v3 = v2;
      if (fcntl(v2, 50, v5) < 0 || !v5[0])
        _fd_release_fd(*(_DWORD **)(a1 + 2192), v3, 0, v4);
      else
        _SIActivityJournalGetOIDs((uint64_t)v5);
    }
  }
}

uint64_t _SIValidateVectors(uint64_t result, int a2)
{
  int *v2;
  uint64_t v4;
  int v5;
  int v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  int v13;
  int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  _QWORD *bucket_entry;
  _QWORD *v19;
  unsigned int v20;
  _QWORD *v21;
  _QWORD *v22;
  int v23;
  int v24;
  const char *v25;
  unsigned int v26;
  unsigned int v27;
  unsigned int v28;
  uint64_t v29;
  unsigned int *v30;
  int v31;
  NSObject *v32;
  unsigned __int16 *v33;
  unsigned int v34;
  unsigned int v35;
  _DWORD *v36;
  _DWORD *v37;
  unsigned int v38;
  _DWORD *v39;
  _DWORD *v40;
  int v41;
  int v42;
  int v43;
  char *v44;
  int v45;
  NSObject *v46;
  int v47;
  NSObject *v48;
  int v49;
  NSObject *v50;
  uint64_t v51;
  char *v52;
  const char *v53;
  uint8_t *v54;
  NSObject *v55;
  uint32_t v56;
  uint64_t v57;
  size_t v58;
  NSObject *v59;
  int v60;
  NSObject *v61;
  const char *v62;
  NSObject *v63;
  uint32_t v64;
  unsigned int *v65;
  char v66;
  int v67;
  NSObject *v68;
  int v69;
  NSObject *v70;
  _BOOL4 v71;
  const char *v72;
  NSObject *v73;
  uint32_t v74;
  int v75;
  NSObject *v76;
  NSObject *v77;
  _BOOL4 v78;
  uint64_t v79;
  int *v80;
  int v81;
  NSObject *v82;
  NSObject *v83;
  _BOOL4 v84;
  int v85;
  const char *v86;
  NSObject *v87;
  uint32_t v88;
  int *v89;
  int v90;
  NSObject *v91;
  NSObject *v92;
  _BOOL4 v93;
  int v94;
  int v95;
  NSObject *v96;
  uint64_t *v97;
  uint64_t *v98;
  int v99;
  NSObject *v100;
  int v101;
  NSObject *v102;
  _BOOL4 v103;
  uint64_t v104;
  const char *v105;
  int v106;
  NSObject *v107;
  _BOOL4 v108;
  uint64_t v109;
  NSObject *v110;
  uint32_t v111;
  char *v112;
  uint64_t v113;
  uint64_t v114;
  char *v115;
  char *v116;
  uint64_t v117;
  uint64_t v118;
  int v119;
  NSObject *v120;
  int v121;
  char *v122;
  char *v123;
  const char *v124;
  uint64_t v125;
  const void *v126;
  uint64_t v127;
  unsigned __int16 *v128;
  char v129;
  _BYTE v130[18];
  __int16 v131;
  char *v132;
  __int16 v133;
  uint64_t v134;
  __int16 v135;
  uint64_t v136;
  __int16 v137;
  uint64_t v138;
  __int16 v139;
  uint8_t *v140;
  uint8_t buf[64];
  __int128 v142;
  __int128 v143;
  __int128 v144;
  __int128 v145;
  __int128 v146;
  __int128 v147;
  __int128 v148;
  __int128 v149;
  uint64_t v150;
  uint8_t v151[64];
  __int128 v152;
  __int128 v153;
  __int128 v154;
  __int128 v155;
  __int128 v156;
  __int128 v157;
  __int128 v158;
  __int128 v159;
  __int128 v160;
  __int128 v161;
  __int128 v162;
  __int128 v163;
  uint64_t v164;

  v164 = *MEMORY[0x1E0C80C00];
  if (!result)
    return result;
  v2 = *(int **)(result + 1184);
  if (!v2)
    return result;
  if (*v2 != 1685287992)
  {
    v119 = *__error();
    v120 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v120, OS_LOG_TYPE_ERROR))
    {
      v121 = *v2;
      *(_DWORD *)v151 = 136315650;
      *(_QWORD *)&v151[4] = "db_datastore_validate_vectors";
      *(_WORD *)&v151[12] = 1024;
      *(_DWORD *)&v151[14] = 238;
      *(_WORD *)&v151[18] = 1024;
      *(_DWORD *)&v151[20] = v121;
      _os_log_error_impl(&dword_1B8270000, v120, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", v151, 0x18u);
    }
    *__error() = v119;
    v122 = __si_assert_copy_extra_268();
    v123 = v122;
    if (v122)
      v124 = v122;
    else
      v124 = "";
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 238, v124);
    free(v123);
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  v4 = *((_QWORD *)v2 + 115);
  if (!v4)
    goto LABEL_55;
  v5 = *(_DWORD *)(v4 + 216);
  if (v5 == 1684300900)
  {
    if (*(_DWORD *)(v4 + 4568))
      goto LABEL_52;
    result = _data_map64_rdlock(*((_QWORD *)v2 + 115));
    if (!(_DWORD)result)
    {
      v7 = *(_QWORD *)(v4 + 288);
      v6 = 1;
      if (!v7)
      {
LABEL_169:
        result = _data_map64_unlock(v4);
        goto LABEL_56;
      }
      v8 = 0;
      v9 = 0;
      v10 = 0;
      v125 = *(unsigned int *)(v4 + 220);
      while (1)
      {
        *(_QWORD *)v130 = 0;
        *(_QWORD *)&v130[8] = 0;
        LOBYTE(v127) = 0;
        data_entry_restore(v4 + 272, v9, v7, (unsigned int *)v130, &v127);
        if ((_BYTE)v127)
        {
          v162 = 0u;
          v163 = 0u;
          v160 = 0u;
          v161 = 0u;
          v158 = 0u;
          v159 = 0u;
          v156 = 0u;
          v157 = 0u;
          v154 = 0u;
          v155 = 0u;
          v152 = 0u;
          v153 = 0u;
          memset(v151, 0, sizeof(v151));
          v45 = *__error();
          v46 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
          {
            v112 = fd_name(*(_QWORD *)(v4 + 240), (char *)v151, 0x100uLL);
            v113 = *(_QWORD *)(v4 + 288);
            *(_DWORD *)buf = 136316418;
            *(_QWORD *)&buf[4] = "_data_map64_get_data_entry";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 375;
            *(_WORD *)&buf[18] = 2080;
            *(_QWORD *)&buf[20] = v112;
            *(_WORD *)&buf[28] = 2048;
            *(_QWORD *)&buf[30] = v9;
            *(_WORD *)&buf[38] = 2048;
            *(_QWORD *)&buf[40] = v113;
            *(_WORD *)&buf[48] = 2048;
            *(_QWORD *)&buf[50] = *(unsigned int *)v130;
            _os_log_error_impl(&dword_1B8270000, v46, OS_LOG_TYPE_ERROR, "%s:%d: data_entry_restore failure: %s off: 0x%lx end: 0x%lx sz: 0x%lx", buf, 0x3Au);
          }
          *__error() = v45;
          if (a2 < 0)
          {
            v95 = *__error();
            v96 = _SILogForLogForCategory(0);
            if (os_log_type_enabled(v96, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)v151 = 136315394;
              *(_QWORD *)&v151[4] = "_data_map64_validate";
              *(_WORD *)&v151[12] = 1024;
              *(_DWORD *)&v151[14] = 662;
              _os_log_error_impl(&dword_1B8270000, v96, OS_LOG_TYPE_ERROR, "%s:%d: entry exceeds storage", v151, 0x12u);
            }
            *__error() = v95;
          }
          else
          {
            dprintf(a2, "entry exceeds storage\n");
          }
          goto LABEL_168;
        }
        if (*(_QWORD *)(v4 + 4496) <= v10)
          break;
        v11 = *(_QWORD *)(v4 + 4440);
        v12 = (uint64_t *)(v11 + v8);
        if (!v11)
        {
          if ((a2 & 0x80000000) == 0)
          {
LABEL_105:
            dprintf(a2, "Error mismatch offset ids\n");
            dprintf(a2, "offset not found for %lld offset 0x%llx %s\n");
            goto LABEL_168;
          }
          goto LABEL_115;
        }
        if (*v12 == 1)
        {
          if ((*(_WORD *)v130 & 0x3F80) != 0)
            v13 = 2;
          else
            v13 = 1;
          if ((*(_DWORD *)v130 & 0x1FC000) != 0)
            v13 = 3;
          if ((*(_DWORD *)v130 & 0xFE00000) != 0)
            v13 = 4;
          if (*(_DWORD *)v130 >> 28)
            v14 = 5;
          else
            v14 = v13;
          v15 = v14 + *(_DWORD *)v130;
        }
        else
        {
          if (*v12 != v9)
          {
            if ((a2 & 0x80000000) == 0)
            {
              dprintf(a2, "Error mismatch offset ids\n");
              dprintf(a2, "sid: %lld so: %lld oo:%lld %s\n");
              goto LABEL_168;
            }
            v66 = 0;
LABEL_116:
            v67 = *__error();
            v68 = _SILogForLogForCategory(0);
            if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)v151 = 136315394;
              *(_QWORD *)&v151[4] = "_data_map64_validate";
              *(_WORD *)&v151[12] = 1024;
              *(_DWORD *)&v151[14] = 677;
              _os_log_error_impl(&dword_1B8270000, v68, OS_LOG_TYPE_ERROR, "%s:%d: Error mismatch offset ids ", v151, 0x12u);
            }
            *__error() = v67;
            v69 = *__error();
            v70 = _SILogForLogForCategory(0);
            v71 = os_log_type_enabled(v70, OS_LOG_TYPE_ERROR);
            if ((v66 & 1) != 0)
            {
              if (v71)
              {
                *(_DWORD *)v151 = 136316162;
                *(_QWORD *)&v151[4] = "_data_map64_validate";
                *(_WORD *)&v151[12] = 1024;
                *(_DWORD *)&v151[14] = 687;
                *(_WORD *)&v151[18] = 2048;
                *(_QWORD *)&v151[20] = v10;
                *(_WORD *)&v151[28] = 2048;
                *(_QWORD *)&v151[30] = v9;
                *(_WORD *)&v151[38] = 2080;
                *(_QWORD *)&v151[40] = *(_QWORD *)&v130[8];
                v72 = "%s:%d: offset not found for %lld offset 0x%llx %s";
                v73 = v70;
                v74 = 48;
                goto LABEL_194;
              }
            }
            else if (v71)
            {
              v118 = *v12;
              *(_DWORD *)v151 = 136316418;
              *(_QWORD *)&v151[4] = "_data_map64_validate";
              *(_WORD *)&v151[12] = 1024;
              *(_DWORD *)&v151[14] = 682;
              *(_WORD *)&v151[18] = 2048;
              *(_QWORD *)&v151[20] = v10;
              *(_WORD *)&v151[28] = 2048;
              *(_QWORD *)&v151[30] = v9;
              *(_WORD *)&v151[38] = 2048;
              *(_QWORD *)&v151[40] = v118;
              *(_WORD *)&v151[48] = 2080;
              *(_QWORD *)&v151[50] = *(_QWORD *)&v130[8];
              v72 = "%s:%d: sid: %lld so: %lld oo:%lld %s";
              v73 = v70;
              v74 = 58;
LABEL_194:
              _os_log_error_impl(&dword_1B8270000, v73, OS_LOG_TYPE_ERROR, v72, v151, v74);
            }
            *__error() = v69;
            goto LABEL_168;
          }
          if (v10)
          {
            v16 = *(_DWORD *)v130;
            v126 = *(const void **)&v130[8];
            v17 = commonHash(*(_DWORD *)v130 - (int)v125, *(_QWORD *)&v130[8] + v125);
            bucket_entry = (_QWORD *)_data_map64_get_bucket_entry((uint64_t *)v4, v17, v10, 0, 0);
            v19 = bucket_entry;
            if (!bucket_entry)
            {
              if ((a2 & 0x80000000) == 0)
              {
                dprintf(a2, "Error mismatch hash ids\n");
                goto LABEL_165;
              }
              v97 = 0;
              goto LABEL_172;
            }
            if (v10 != *bucket_entry)
            {
              v97 = bucket_entry;
              if ((a2 & 0x80000000) == 0)
              {
                dprintf(a2, "Error mismatch hash ids\n");
                dprintf(a2, "sid: %llu hid: %lld offset: %lld %s\n");
                goto LABEL_168;
              }
LABEL_172:
              v99 = *__error();
              v100 = _SILogForLogForCategory(0);
              if (os_log_type_enabled(v100, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)v151 = 136315394;
                *(_QWORD *)&v151[4] = "_data_map64_validate";
                *(_WORD *)&v151[12] = 1024;
                *(_DWORD *)&v151[14] = 707;
                _os_log_error_impl(&dword_1B8270000, v100, OS_LOG_TYPE_ERROR, "%s:%d: Error mismatch hash ids ", v151, 0x12u);
              }
              *__error() = v99;
              v101 = *__error();
              v102 = _SILogForLogForCategory(0);
              v103 = os_log_type_enabled(v102, OS_LOG_TYPE_ERROR);
              if (v19)
              {
                if (v103)
                {
                  v104 = *v97;
                  *(_DWORD *)v151 = 136316418;
                  *(_QWORD *)&v151[4] = "_data_map64_validate";
                  *(_WORD *)&v151[12] = 1024;
                  *(_DWORD *)&v151[14] = 712;
                  *(_WORD *)&v151[18] = 2048;
                  *(_QWORD *)&v151[20] = v10;
                  *(_WORD *)&v151[28] = 2048;
                  *(_QWORD *)&v151[30] = v104;
                  *(_WORD *)&v151[38] = 2048;
                  *(_QWORD *)&v151[40] = v9;
                  *(_WORD *)&v151[48] = 2080;
                  *(_QWORD *)&v151[50] = v126;
                  v105 = "%s:%d: sid: %llu hid: %lld offset: %lld %s";
                  goto LABEL_183;
                }
                goto LABEL_190;
              }
              if (!v103)
                goto LABEL_190;
              *(_DWORD *)v151 = 136316162;
              *(_QWORD *)&v151[4] = "_data_map64_validate";
              *(_WORD *)&v151[12] = 1024;
              *(_DWORD *)&v151[14] = 717;
              *(_WORD *)&v151[18] = 2048;
              *(_QWORD *)&v151[20] = v10;
              *(_WORD *)&v151[28] = 2048;
              *(_QWORD *)&v151[30] = v9;
              *(_WORD *)&v151[38] = 2080;
              *(_QWORD *)&v151[40] = v126;
              v105 = "%s:%d: hash entry not found for %lld offset 0x%llx %s";
LABEL_188:
              v110 = v102;
              v111 = 48;
              goto LABEL_189;
            }
            v20 = commonHash(v16 - *(_DWORD *)(v4 + 220), (uint64_t)v126 + *(unsigned int *)(v4 + 220));
            v21 = (_QWORD *)_data_map64_get_bucket_entry((uint64_t *)v4, v20, 0, v126, v16);
            v22 = v21;
            if (!v21)
            {
              if (a2 < 0)
              {
                v98 = 0;
                goto LABEL_178;
              }
              dprintf(a2, "Error mismatch hash\n");
LABEL_165:
              dprintf(a2, "hash entry not found for %lld offset 0x%llx %s\n");
LABEL_168:
              v6 = 0;
              goto LABEL_169;
            }
            if (v10 != *v21)
            {
              v98 = v21;
              if ((a2 & 0x80000000) == 0)
              {
                dprintf(a2, "Error mismatch hash\n");
                dprintf(a2, "sid: %llu hid: %llu offset: %llu ** %s **\n");
                goto LABEL_168;
              }
LABEL_178:
              v106 = *__error();
              v107 = _SILogForLogForCategory(0);
              if (os_log_type_enabled(v107, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)v151 = 136315394;
                *(_QWORD *)&v151[4] = "_data_map64_validate";
                *(_WORD *)&v151[12] = 1024;
                *(_DWORD *)&v151[14] = 729;
                _os_log_error_impl(&dword_1B8270000, v107, OS_LOG_TYPE_ERROR, "%s:%d: Error mismatch hash ", v151, 0x12u);
              }
              *__error() = v106;
              v101 = *__error();
              v102 = _SILogForLogForCategory(0);
              v108 = os_log_type_enabled(v102, OS_LOG_TYPE_ERROR);
              if (v22)
              {
                if (v108)
                {
                  v109 = *v98;
                  *(_DWORD *)v151 = 136316418;
                  *(_QWORD *)&v151[4] = "_data_map64_validate";
                  *(_WORD *)&v151[12] = 1024;
                  *(_DWORD *)&v151[14] = 734;
                  *(_WORD *)&v151[18] = 2048;
                  *(_QWORD *)&v151[20] = v10;
                  *(_WORD *)&v151[28] = 2048;
                  *(_QWORD *)&v151[30] = v109;
                  *(_WORD *)&v151[38] = 2048;
                  *(_QWORD *)&v151[40] = v9;
                  *(_WORD *)&v151[48] = 2080;
                  *(_QWORD *)&v151[50] = v126;
                  v105 = "%s:%d: sid: %llu hid: %llu offset: %llu %s";
LABEL_183:
                  v110 = v102;
                  v111 = 58;
LABEL_189:
                  _os_log_error_impl(&dword_1B8270000, v110, OS_LOG_TYPE_ERROR, v105, v151, v111);
                }
LABEL_190:
                *__error() = v101;
                goto LABEL_168;
              }
              if (!v108)
                goto LABEL_190;
              *(_DWORD *)v151 = 136316162;
              *(_QWORD *)&v151[4] = "_data_map64_validate";
              *(_WORD *)&v151[12] = 1024;
              *(_DWORD *)&v151[14] = 739;
              *(_WORD *)&v151[18] = 2048;
              *(_QWORD *)&v151[20] = v10;
              *(_WORD *)&v151[28] = 2048;
              *(_QWORD *)&v151[30] = v9;
              *(_WORD *)&v151[38] = 2080;
              *(_QWORD *)&v151[40] = v126;
              v105 = "%s:%d: hash entry not found for %lld offset 0x%llx %s";
              goto LABEL_188;
            }
          }
          else
          {
            v16 = *(_DWORD *)v130;
          }
          if ((v16 & 0x3F80) != 0)
            v23 = 2;
          else
            v23 = 1;
          if ((v16 & 0x1FC000) != 0)
            v23 = 3;
          if ((v16 & 0xFE00000) != 0)
            v23 = 4;
          if (v16 >> 28)
            v24 = 5;
          else
            v24 = v23;
          v15 = v24 + v16;
        }
        v9 += v15;
        ++v10;
        v7 = *(_QWORD *)(v4 + 288);
        v8 += 16;
        if (v9 >= v7)
        {
          v6 = 1;
          goto LABEL_169;
        }
      }
      v162 = 0u;
      v163 = 0u;
      v160 = 0u;
      v161 = 0u;
      v158 = 0u;
      v159 = 0u;
      v156 = 0u;
      v157 = 0u;
      v154 = 0u;
      v155 = 0u;
      v152 = 0u;
      v153 = 0u;
      memset(v151, 0, sizeof(v151));
      v47 = *__error();
      v48 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
      {
        v114 = *(_QWORD *)(v4 + 4496);
        v115 = fd_name(*(_QWORD *)(v4 + 240), (char *)v151, 0x100uLL);
        *(_DWORD *)buf = 136316418;
        *(_QWORD *)&buf[4] = "_data_map64_get_offset_entry";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 362;
        *(_WORD *)&buf[18] = 2048;
        *(_QWORD *)&buf[20] = v10;
        *(_WORD *)&buf[28] = 2048;
        *(_QWORD *)&buf[30] = v114;
        *(_WORD *)&buf[38] = 2048;
        *(_QWORD *)&buf[40] = v4;
        *(_WORD *)&buf[48] = 2080;
        *(_QWORD *)&buf[50] = v115;
        _os_log_error_impl(&dword_1B8270000, v48, OS_LOG_TYPE_ERROR, "%s:%d: invalid data id %lld max %lld %p %s", buf, 0x3Au);
      }
      *__error() = v47;
      if ((a2 & 0x80000000) == 0)
        goto LABEL_105;
      v12 = 0;
LABEL_115:
      v66 = 1;
      goto LABEL_116;
    }
    goto LABEL_55;
  }
  if (v5 != 842150450)
  {
    if (v5 == -270471200)
    {
      if (!*(_DWORD *)(v4 + 464))
      {
        result = _data_map_ext_rdlock(*((_QWORD *)v2 + 115));
        if (!(_DWORD)result)
        {
          result = _data_map_ext_unlock(v4);
          v6 = 1;
          goto LABEL_56;
        }
        goto LABEL_55;
      }
LABEL_52:
      if ((a2 & 0x80000000) == 0)
      {
        dprintf(a2, "datamap is invalid\n");
        v25 = "failed";
        return dprintf(a2, "db_datastore_validate_vectors: %s\n", v25);
      }
      return result;
    }
    goto LABEL_55;
  }
  if (*(_DWORD *)(v4 + 440))
    goto LABEL_52;
  result = _data_map32_rdlock(*((_QWORD *)v2 + 115));
  if ((_DWORD)result)
  {
LABEL_55:
    v6 = 0;
    goto LABEL_56;
  }
  v26 = *(_DWORD *)(v4 + 296);
  v6 = 1;
  if (!v26)
    goto LABEL_158;
  v27 = 0;
  v28 = 0;
  v29 = *(unsigned int *)(v4 + 220);
  while (1)
  {
    v127 = 0;
    v128 = 0;
    if (*(_DWORD *)(v4 + 364) <= v28)
    {
      v162 = 0u;
      v163 = 0u;
      v160 = 0u;
      v161 = 0u;
      v158 = 0u;
      v159 = 0u;
      v156 = 0u;
      v157 = 0u;
      v154 = 0u;
      v155 = 0u;
      v152 = 0u;
      v153 = 0u;
      memset(v151, 0, sizeof(v151));
      v31 = *__error();
      v32 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      {
        v43 = *(_DWORD *)(v4 + 364);
        v44 = fd_name(*(_QWORD *)(v4 + 240), (char *)v151, 0x100uLL);
        *(_DWORD *)buf = 136316418;
        *(_QWORD *)&buf[4] = "_data_map32_get_offset_entry";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 421;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v28;
        *(_WORD *)&buf[24] = 1024;
        *(_DWORD *)&buf[26] = v43;
        *(_WORD *)&buf[30] = 2048;
        *(_QWORD *)&buf[32] = v4;
        *(_WORD *)&buf[40] = 2080;
        *(_QWORD *)&buf[42] = v44;
        _os_log_error_impl(&dword_1B8270000, v32, OS_LOG_TYPE_ERROR, "%s:%d: invalid data id %d max %d %p %s", buf, 0x32u);
      }
      v30 = 0;
      *__error() = v31;
      v26 = *(_DWORD *)(v4 + 296);
    }
    else
    {
      v30 = (unsigned int *)(*(_QWORD *)(v4 + 320) + 4 * v28);
    }
    v129 = 0;
    if (v26 <= v27)
    {
      v162 = 0u;
      v163 = 0u;
      v160 = 0u;
      v161 = 0u;
      v158 = 0u;
      v159 = 0u;
      v156 = 0u;
      v157 = 0u;
      v154 = 0u;
      v155 = 0u;
      v152 = 0u;
      v153 = 0u;
      memset(v151, 0, sizeof(v151));
      v49 = *__error();
      v50 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
      {
LABEL_112:
        *__error() = v49;
        v60 = *__error();
        v61 = _SILogForLogForCategory(0);
        if (!os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
          goto LABEL_156;
        *(_DWORD *)v151 = 136315394;
        *(_QWORD *)&v151[4] = "_data_map32_validate";
        *(_WORD *)&v151[12] = 1024;
        *(_DWORD *)&v151[14] = 759;
        v62 = "%s:%d: entry exceeds storage";
        v63 = v61;
        v64 = 18;
        goto LABEL_155;
      }
      v51 = *(unsigned int *)(v4 + 296);
      v52 = fd_name(*(_QWORD *)(v4 + 240), (char *)v151, 0x100uLL);
      *(_DWORD *)buf = 136316418;
      *(_QWORD *)&buf[4] = "_data_map32_get_data_entry";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 445;
      *(_WORD *)&buf[18] = 2048;
      *(_QWORD *)&buf[20] = v27;
      *(_WORD *)&buf[28] = 2048;
      *(_QWORD *)&buf[30] = v51;
      *(_WORD *)&buf[38] = 2048;
      *(_QWORD *)&buf[40] = v4;
      *(_WORD *)&buf[48] = 2080;
      *(_QWORD *)&buf[50] = v52;
      v53 = "%s:%d: invalid data offset 0x%lx 0x%lx %p %s";
      v54 = buf;
      v55 = v50;
      v56 = 58;
LABEL_192:
      _os_log_error_impl(&dword_1B8270000, v55, OS_LOG_TYPE_ERROR, v53, v54, v56);
      goto LABEL_112;
    }
    data_entry_restore_12001(*(_QWORD *)(v4 + 288), v27, v26, (uint64_t)&v127, &v129);
    if (v129)
    {
      v57 = 0;
      v150 = 0;
      v148 = 0u;
      v149 = 0u;
      v146 = 0u;
      v147 = 0u;
      v144 = 0u;
      v145 = 0u;
      v142 = 0u;
      v143 = 0u;
      memset(buf, 0, sizeof(buf));
      do
      {
        if ((unint64_t)v27 + v57 >= *(unsigned int *)(v4 + 296))
          break;
        v58 = strlen((const char *)buf);
        sprintf((char *)&buf[v58], "%d ", *(unsigned __int8 *)(*(_QWORD *)(v4 + 288) + v27 + v57++));
      }
      while (v57 != 5);
      v162 = 0u;
      v163 = 0u;
      v160 = 0u;
      v161 = 0u;
      v158 = 0u;
      v159 = 0u;
      v156 = 0u;
      v157 = 0u;
      v154 = 0u;
      v155 = 0u;
      v152 = 0u;
      v153 = 0u;
      memset(v151, 0, sizeof(v151));
      v49 = *__error();
      v59 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
        goto LABEL_112;
      v116 = fd_name(*(_QWORD *)(v4 + 240), (char *)v151, 0x100uLL);
      v117 = *(unsigned int *)(v4 + 296);
      *(_DWORD *)v130 = 136316674;
      *(_QWORD *)&v130[4] = "_data_map32_get_data_entry";
      *(_WORD *)&v130[12] = 1024;
      *(_DWORD *)&v130[14] = 441;
      v131 = 2080;
      v132 = v116;
      v133 = 2048;
      v134 = v27;
      v135 = 2048;
      v136 = v117;
      v137 = 2048;
      v138 = v127;
      v139 = 2080;
      v140 = buf;
      v53 = "%s:%d: data_entry_restore failure: %s off: 0x%lx end: 0x%lx sz: 0x%lx sz bytes: %s";
      v54 = v130;
      v55 = v59;
      v56 = 68;
      goto LABEL_192;
    }
    if (!v30)
      break;
    if (*v30 != v27)
    {
      v65 = v30;
      goto LABEL_122;
    }
    if (v28)
    {
      v34 = v127;
      v33 = v128;
      if (*(_BYTE *)(v4 + 436))
        v35 = LegacyHash((unsigned __int16 *)((char *)v128 + v29), (v127 - v29));
      else
        v35 = commonHash((int)v127 - (int)v29, (uint64_t)v128 + v29);
      v36 = (_DWORD *)_data_map32_get_bucket_entry(v4, v35, v28, 0, 0);
      v37 = v36;
      if (!v36)
      {
        v80 = 0;
        goto LABEL_135;
      }
      if (v28 != *v36)
      {
        v80 = v36;
LABEL_135:
        v81 = *__error();
        v82 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v82, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)v151 = 136315394;
          *(_QWORD *)&v151[4] = "_data_map32_validate";
          *(_WORD *)&v151[12] = 1024;
          *(_DWORD *)&v151[14] = 786;
          _os_log_error_impl(&dword_1B8270000, v82, OS_LOG_TYPE_ERROR, "%s:%d: Error mismatch hash ids ", v151, 0x12u);
        }
        *__error() = v81;
        v60 = *__error();
        v83 = _SILogForLogForCategory(0);
        v84 = os_log_type_enabled(v83, OS_LOG_TYPE_ERROR);
        if (v37)
        {
          if (v84)
          {
            v85 = *v80;
            *(_DWORD *)v151 = 136316418;
            *(_QWORD *)&v151[4] = "_data_map32_validate";
            *(_WORD *)&v151[12] = 1024;
            *(_DWORD *)&v151[14] = 788;
            *(_WORD *)&v151[18] = 1024;
            *(_DWORD *)&v151[20] = v28;
            *(_WORD *)&v151[24] = 1024;
            *(_DWORD *)&v151[26] = v85;
            *(_WORD *)&v151[30] = 2048;
            *(_QWORD *)&v151[32] = v27;
            *(_WORD *)&v151[40] = 2080;
            *(_QWORD *)&v151[42] = v33;
            v86 = "%s:%d: sid: %d hid: %d offset: %ld %s";
            v87 = v83;
            v88 = 50;
            goto LABEL_196;
          }
        }
        else if (v84)
        {
          *(_DWORD *)v151 = 136316162;
          *(_QWORD *)&v151[4] = "_data_map32_validate";
          *(_WORD *)&v151[12] = 1024;
          *(_DWORD *)&v151[14] = 790;
          *(_WORD *)&v151[18] = 1024;
          *(_DWORD *)&v151[20] = v28;
          *(_WORD *)&v151[24] = 2048;
          *(_QWORD *)&v151[26] = v27;
          *(_WORD *)&v151[34] = 2080;
          *(_QWORD *)&v151[36] = v33;
          v86 = "%s:%d: hash entry not found for %d offset 0x%lx %s";
          v87 = v83;
          v88 = 44;
LABEL_196:
          _os_log_error_impl(&dword_1B8270000, v87, OS_LOG_TYPE_ERROR, v86, v151, v88);
        }
        v6 = 0;
        goto LABEL_157;
      }
      if (*(_BYTE *)(v4 + 436))
        v38 = LegacyHash(v33, v34);
      else
        v38 = commonHash(v34, (uint64_t)v33);
      v39 = (_DWORD *)_data_map32_get_bucket_entry(v4, v38, 0, v33, v34);
      v40 = v39;
      if (!v39)
      {
        v89 = 0;
        goto LABEL_142;
      }
      if (v28 != *v39)
      {
        v89 = v39;
LABEL_142:
        v90 = *__error();
        v91 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v91, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)v151 = 136315394;
          *(_QWORD *)&v151[4] = "_data_map32_validate";
          *(_WORD *)&v151[12] = 1024;
          *(_DWORD *)&v151[14] = 800;
          _os_log_error_impl(&dword_1B8270000, v91, OS_LOG_TYPE_ERROR, "%s:%d: Error mismatch hash ", v151, 0x12u);
        }
        *__error() = v90;
        v60 = *__error();
        v92 = _SILogForLogForCategory(0);
        v93 = os_log_type_enabled(v92, OS_LOG_TYPE_ERROR);
        if (v40)
        {
          if (!v93)
            goto LABEL_156;
          v94 = *v89;
          *(_DWORD *)v151 = 136316418;
          *(_QWORD *)&v151[4] = "_data_map32_validate";
          *(_WORD *)&v151[12] = 1024;
          *(_DWORD *)&v151[14] = 802;
          *(_WORD *)&v151[18] = 1024;
          *(_DWORD *)&v151[20] = v28;
          *(_WORD *)&v151[24] = 1024;
          *(_DWORD *)&v151[26] = v94;
          *(_WORD *)&v151[30] = 2048;
          *(_QWORD *)&v151[32] = v27;
          *(_WORD *)&v151[40] = 2080;
          *(_QWORD *)&v151[42] = v33;
          v62 = "%s:%d: sid: %d hid: %d offset: %ld %s";
          v63 = v92;
          v64 = 50;
          goto LABEL_155;
        }
        if (!v93)
          goto LABEL_156;
        *(_DWORD *)v151 = 136316162;
        *(_QWORD *)&v151[4] = "_data_map32_validate";
        *(_WORD *)&v151[12] = 1024;
        *(_DWORD *)&v151[14] = 804;
        *(_WORD *)&v151[18] = 1024;
        *(_DWORD *)&v151[20] = v28;
        *(_WORD *)&v151[24] = 2048;
        *(_QWORD *)&v151[26] = v27;
        *(_WORD *)&v151[34] = 2080;
        *(_QWORD *)&v151[36] = v33;
        v62 = "%s:%d: hash entry not found for %d offset 0x%lx %s";
        v63 = v92;
LABEL_154:
        v64 = 44;
        goto LABEL_155;
      }
    }
    else
    {
      v34 = v127;
    }
    if ((v34 & 0x3F80) != 0)
      v41 = 2;
    else
      v41 = 1;
    if ((v34 & 0x1FC000) != 0)
      v41 = 3;
    if ((v34 & 0xFE00000) != 0)
      v41 = 4;
    if (v34 >> 28)
      v42 = 5;
    else
      v42 = v41;
    v27 += v34 + v42;
    ++v28;
    v26 = *(_DWORD *)(v4 + 296);
    if (v27 >= v26)
    {
      v6 = 1;
      goto LABEL_158;
    }
  }
  v65 = 0;
LABEL_122:
  v75 = *__error();
  v76 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v76, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)v151 = 136315394;
    *(_QWORD *)&v151[4] = "_data_map32_validate";
    *(_WORD *)&v151[12] = 1024;
    *(_DWORD *)&v151[14] = 772;
    _os_log_error_impl(&dword_1B8270000, v76, OS_LOG_TYPE_ERROR, "%s:%d: Error mismatch offset ids ", v151, 0x12u);
  }
  *__error() = v75;
  v60 = *__error();
  v77 = _SILogForLogForCategory(0);
  v78 = os_log_type_enabled(v77, OS_LOG_TYPE_ERROR);
  if (!v30)
  {
    if (!v78)
      goto LABEL_156;
    *(_DWORD *)v151 = 136316162;
    *(_QWORD *)&v151[4] = "_data_map32_validate";
    *(_WORD *)&v151[12] = 1024;
    *(_DWORD *)&v151[14] = 776;
    *(_WORD *)&v151[18] = 1024;
    *(_DWORD *)&v151[20] = v28;
    *(_WORD *)&v151[24] = 2048;
    *(_QWORD *)&v151[26] = v27;
    *(_WORD *)&v151[34] = 2080;
    *(_QWORD *)&v151[36] = v128;
    v62 = "%s:%d: offset not found for %d offset 0x%lx %s";
    v63 = v77;
    goto LABEL_154;
  }
  if (!v78)
    goto LABEL_156;
  v79 = *v65;
  *(_DWORD *)v151 = 136316418;
  *(_QWORD *)&v151[4] = "_data_map32_validate";
  *(_WORD *)&v151[12] = 1024;
  *(_DWORD *)&v151[14] = 774;
  *(_WORD *)&v151[18] = 1024;
  *(_DWORD *)&v151[20] = v28;
  *(_WORD *)&v151[24] = 2048;
  *(_QWORD *)&v151[26] = v27;
  *(_WORD *)&v151[34] = 2048;
  *(_QWORD *)&v151[36] = v79;
  *(_WORD *)&v151[44] = 2080;
  *(_QWORD *)&v151[46] = v128;
  v62 = "%s:%d: sid: %d so: %ld oo:%ld %s";
  v63 = v77;
  v64 = 54;
LABEL_155:
  _os_log_error_impl(&dword_1B8270000, v63, OS_LOG_TYPE_ERROR, v62, v151, v64);
LABEL_156:
  v6 = 1;
LABEL_157:
  *__error() = v60;
LABEL_158:
  result = _data_map32_unlock(v4);
LABEL_56:
  if ((a2 & 0x80000000) == 0)
  {
    v25 = "failed";
    if (v6)
      v25 = "success";
    return dprintf(a2, "db_datastore_validate_vectors: %s\n", v25);
  }
  return result;
}

uint64_t SIGetAttributes(uint64_t a1, unint64_t a2, uint64_t a3, const __CFArray *a4)
{
  const void *Mutable;
  char *v8;
  uint64_t v9;
  int *v10;
  const char **v11;
  const char *v12;
  const char *v13;
  const char **v14;
  char **v15;
  NSObject *v16;
  const char *v17;
  uint64_t v18;
  int v20;
  NSObject *v21;
  int v22;
  CFIndex v23;
  size_t v24;
  char *v25;
  const char *v26;
  unsigned int *v27;
  void *v28;
  uint8_t buf[4];
  unint64_t v30;
  __int16 v31;
  unint64_t v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v24 = 0;
  v25 = 0;
  v23 = 0;
  SIFlattenArrayToCStringVector(a4, &v25, &v24, &v23);
  Mutable = (const void *)_MDPlistBytesCreateMutable();
  _MDPlistBytesBeginPlist();
  _MDPlistBytesBeginArray();
  v8 = v25;
  v9 = v23;
  _MDPlistBytesAddNull();
  v10 = *(int **)(a1 + 1184);
  if (v10)
  {
    v28 = 0;
    if (v9 < 1 || db_get_obj(v10, a2, &v28, 0))
    {
      if (dword_1EF19FCA0 >= 5)
      {
        v20 = *__error();
        v21 = _SILogForLogForCategory(5);
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 134217984;
          v30 = a2;
          _os_log_impl(&dword_1B8270000, v21, OS_LOG_TYPE_DEFAULT, "No dbo for %llx", buf, 0xCu);
        }
        *__error() = v20;
      }
      _MDPlistBytesAddNull();
    }
    else
    {
      _MDPlistBytesBeginArray();
      v11 = (const char **)v8;
      do
      {
        v26 = 0;
        v27 = 0;
        if (db_get_field(v10, (uint64_t)v28, (char *)*v11, (unint64_t *)&v27, &v26))
        {
          v12 = *v11;
          v13 = (const char *)strlen(*v11);
          v14 = CannedFieldTable::in_word_set((CannedFieldTable *)*v11, v13);
          if (!v14
            || (((uint64_t (*)(uint64_t, const char *, uint64_t, unint64_t, void *, _QWORD, _QWORD, _QWORD, void *, const void *))v14[1])(a1, v12, a3, a2, v28, 0, 0, 0, &__block_literal_global_84, Mutable) & 1) == 0)
          {
            if (dword_1EF19FCA0 >= 5)
            {
              v22 = *__error();
              v16 = _SILogForLogForCategory(5);
              if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
              {
                v17 = *v11;
                *(_DWORD *)buf = 136315394;
                v30 = (unint64_t)v17;
                v31 = 2048;
                v32 = a2;
                _os_log_impl(&dword_1B8270000, v16, OS_LOG_TYPE_DEFAULT, "No attribute %s for %llx", buf, 0x16u);
              }
              *__error() = v22;
            }
            _MDPlistBytesAddNull();
          }
        }
        else
        {
          if (a3)
            v15 = *(char ***)(a3 + 120);
          else
            v15 = 0;
          MDPlistBytesAddSDBFieldLocalized((uint64_t)Mutable, v10, v27, v26, v15, 0, 1);
        }
        ++v11;
        --v9;
      }
      while (v9);
      _MDPlistBytesEndArray();
      free(v28);
    }
  }
  _MDPlistBytesEndArray();
  _MDPlistBytesEndPlist();
  v18 = _MDPlistBytesCopyPlistAtIndex();
  if (Mutable)
    CFRelease(Mutable);
  free(v8);
  return v18;
}

CFTypeID __isAppleInternalInstall_block_invoke()
{
  CFTypeID result;
  const void *v1;
  CFTypeID v2;
  BOOL v3;

  result = MGCopyAnswer();
  if (result
    && (v1 = (const void *)result, v2 = CFGetTypeID((CFTypeRef)result), result = CFStringGetTypeID(), v2 == result))
  {
    result = CFEqual(v1, CFSTR("Internal"));
    v3 = (_DWORD)result != 0;
  }
  else
  {
    v3 = 0;
  }
  isAppleInternalInstall_isInternalInstall = v3;
  return result;
}

os_signpost_id_t SIExecuteQueryWithResultsCallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  const __CFArray *v8;
  os_signpost_id_t v9;
  void *values;

  values = a5;
  v8 = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)&values, 1, 0);
  v9 = SIExecuteQueryWithResultsCallbackForTags(a1, a2, a3, 0, v8);
  CFRelease(v8);
  return v9;
}

os_signpost_id_t SIExecuteQuery(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  return SIExecuteQueryWithResultsCallback(a1, a2, a3, (uint64_t)a4, a4);
}

char *SIBulkGetAttributeNames(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, uint64_t a5, uint64_t a6, int a7)
{
  char *v13;
  _QWORD *v14;
  uint64_t v15;
  unsigned int *v16;
  unsigned int v17;
  CFTypeRef v18;
  NSObject *Log;
  NSObject *v21;
  qos_class_t v22;
  int v23;
  int v24;
  uint64_t v25;
  __int16 v26;
  qos_class_t v27;
  __int16 v28;
  int v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v13 = (char *)malloc_type_calloc(1uLL, 0x70uLL, 0x10200408DCF1539uLL);
  atomic_store(2u, (unsigned int *)v13);
  pthread_mutex_init((pthread_mutex_t *)(v13 + 48), 0);
  *((_DWORD *)v13 + 8) = 3;
  v14 = malloc_type_calloc(1uLL, 0x38uLL, 0x1030040115CFCBFuLL);
  v15 = (uint64_t)v14;
  *v14 = a1;
  v16 = (unsigned int *)(a5 + 8);
  do
    v17 = __ldaxr(v16);
  while (__stlxr(v17 + 1, v16));
  v14[3] = a5;
  v14[4] = v13;
  if (a4)
    v18 = CFRetain(a4);
  else
    v18 = 0;
  *(_QWORD *)(v15 + 40) = v18;
  *(_QWORD *)(v15 + 8) = a2;
  *(_QWORD *)(v15 + 16) = a3;
  if ((a7 & 0x100000) == 0)
  {
    if ((a7 & 0x400000) == 0)
      goto LABEL_8;
LABEL_13:
    *(_BYTE *)(v15 + 48) |= 2u;
    if ((a7 & 0x200000) == 0)
      goto LABEL_10;
    goto LABEL_9;
  }
  *(_BYTE *)(v15 + 48) |= 4u;
  if ((a7 & 0x400000) != 0)
    goto LABEL_13;
LABEL_8:
  if ((a7 & 0x200000) != 0)
LABEL_9:
    *(_BYTE *)(v15 + 48) |= 1u;
LABEL_10:
  Log = _MDPerf_QueryLog();
  if ((unint64_t)(v13 + 1) >= 2)
  {
    v21 = Log;
    if (os_signpost_enabled(Log))
    {
      v22 = qos_class_self();
      v23 = *((_DWORD *)v13 + 8);
      v24 = 134218496;
      v25 = 0;
      v26 = 1024;
      v27 = v22;
      v28 = 1024;
      v29 = v23;
      _os_signpost_emit_with_name_impl(&dword_1B8270000, v21, OS_SIGNPOST_INTERVAL_BEGIN, (os_signpost_id_t)v13, "Job", "QueryId=%{signpost.description:attribute}lld CurrentQoS=%{signpost.description:attribute}x JobType=%{signpost.description:attribute}d", (uint8_t *)&v24, 0x18u);
    }
  }
  si_enqueue_routine(a1, (uint64_t)v13, (uint64_t (*)(uint64_t, uint64_t))si_getAttrNamesBulk, v15, 9u);
  return v13;
}

char *SIBulkGetAttributes(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, const void *a5, uint64_t a6, uint64_t a7, unsigned int a8)
{
  char *v16;
  void *v17;
  unsigned int *v18;
  unsigned int v19;
  CFTypeRef v20;
  char v21;
  __CFArray *v22;
  __CFArray *v23;
  _BOOL4 v24;
  uint64_t v25;
  uint64_t v26;
  NSObject *Log;
  uint64_t v28;
  uint64_t v29;
  int v30;
  NSObject *v31;
  os_log_type_t v32;
  NSObject *v34;
  qos_class_t v35;
  int v36;
  int v37;
  uint64_t v38;
  __int16 v39;
  qos_class_t v40;
  __int16 v41;
  int v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  v16 = (char *)malloc_type_calloc(1uLL, 0x70uLL, 0x10200408DCF1539uLL);
  atomic_store(2u, (unsigned int *)v16);
  pthread_mutex_init((pthread_mutex_t *)(v16 + 48), 0);
  *((_DWORD *)v16 + 8) = 2;
  v17 = malloc_type_calloc(1uLL, 0x48uLL, 0x10700402C59DD4BuLL);
  *(_QWORD *)v17 = a1;
  *((_QWORD *)v17 + 1) = CFRetain(a5);
  v18 = (unsigned int *)(a6 + 8);
  do
    v19 = __ldaxr(v18);
  while (__stlxr(v19 + 1, v18));
  *((_QWORD *)v17 + 4) = a6;
  *((_QWORD *)v17 + 5) = v16;
  if (a4)
    v20 = CFRetain(a4);
  else
    v20 = 0;
  *((_QWORD *)v17 + 6) = v20;
  *((_QWORD *)v17 + 2) = a2;
  *((_QWORD *)v17 + 3) = a3;
  *((CFAbsoluteTime *)v17 + 7) = CFAbsoluteTimeGetCurrent();
  v21 = *((_BYTE *)v17 + 64) & 0xF7;
  if ((a8 & 0x100000) != 0)
    v21 = *((_BYTE *)v17 + 64) & 0xF3 | 4;
  *((_BYTE *)v17 + 64) = (a8 >> 21) & 3 | v21;
  if (*(_DWORD *)(a1 + 1276) == 102)
  {
    v22 = si_attrs_remapping_copy(*((const __CFArray **)v17 + 1), (*(_DWORD *)(a1 + 6584) >> 6) & 1);
    if (v22)
    {
      v23 = v22;
      CFRelease(*((CFTypeRef *)v17 + 1));
      *((_QWORD *)v17 + 1) = v23;
    }
  }
  v24 = a3 != 0;
  if (a3)
    v25 = a3 - 1;
  else
    v25 = 0;
  v26 = a2 + 8 * v24;
  Log = _MDPerf_QueryLog();
  if ((unint64_t)(v16 + 1) >= 2)
  {
    v34 = Log;
    if (os_signpost_enabled(Log))
    {
      v35 = qos_class_self();
      v36 = *((_DWORD *)v16 + 8);
      v37 = 134218496;
      v38 = 0;
      v39 = 1024;
      v40 = v35;
      v41 = 1024;
      v42 = v36;
      _os_signpost_emit_with_name_impl(&dword_1B8270000, v34, OS_SIGNPOST_INTERVAL_BEGIN, (os_signpost_id_t)v16, "Job", "QueryId=%{signpost.description:attribute}lld CurrentQoS=%{signpost.description:attribute}x JobType=%{signpost.description:attribute}d", (uint8_t *)&v37, 0x18u);
    }
  }
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1320));
  v28 = *(_QWORD *)(a1 + 1144);
  if (v28 && si_peek_queue(v28, a7, v26, v25))
  {
    si_enqueue_barrier_routine(a1, (uint64_t)v16, (uint64_t (*)(uint64_t, uint64_t))si_enqueue_getAttrBulk, (uint64_t)v17, 0x11u);
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1320));
  }
  else
  {
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1320));
    v29 = *(_QWORD *)(a1 + 1048);
    if (!v29 || !si_peek_queue(v29, a7, v26, v25))
    {
      si_enqueue_routine(a1, (uint64_t)v16, (uint64_t (*)(uint64_t, uint64_t))si_getAttrBulk, (uint64_t)v17, 9u);
      return v16;
    }
    si_enqueue_barrier_routine(a1, (uint64_t)v16, (uint64_t (*)(uint64_t, uint64_t))si_enqueue_getAttrBulk, (uint64_t)v17, 5u);
  }
  v30 = *__error();
  v31 = _SILogForLogForCategory(0);
  v32 = 2 * (gSILogLevels[0] < 4);
  if (os_log_type_enabled(v31, v32))
  {
    LOWORD(v37) = 0;
    _os_log_impl(&dword_1B8270000, v31, v32, "Stalled getAttr because task had pending sets", (uint8_t *)&v37, 2u);
  }
  *__error() = v30;
  return v16;
}

void si_enqueue_getAttrBulk(uint64_t *a1, int a2)
{
  if (a2)
    si_getAttrBulk((uint64_t)a1, a2);
  else
    si_enqueue_routine(*a1, a1[5], (uint64_t (*)(uint64_t, uint64_t))si_getAttrBulk, (uint64_t)a1, 9u);
}

void _SIStartPreheatScheduler(uint64_t a1)
{
  int v2;
  NSObject *v3;
  os_log_type_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)(a1 + 2448))
  {
    v2 = *__error();
    v3 = _SILogForLogForCategory(3);
    v4 = 2 * (dword_1EF19FC98 < 4);
    if (os_log_type_enabled(v3, v4))
    {
      v5 = *(_QWORD *)(a1 + 896);
      v6 = 134217984;
      v7 = v5;
      _os_log_impl(&dword_1B8270000, v3, v4, "_SIStartPreheatScheduler for %p", (uint8_t *)&v6, 0xCu);
    }
    *__error() = v2;
    awakenPreheat(a1);
  }
}

int *SIInitialIndexingStarted(uint64_t a1)
{
  int v2;
  NSObject *v3;
  os_log_type_t v4;
  int v5;
  BOOL v6;
  _BYTE *v7;
  int *result;
  uint8_t buf[4];
  _BYTE *v10;
  _BYTE v11[1024];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  bzero(v11, 0x400uLL);
  *(_BYTE *)(a1 + 2436) = 1;
  v2 = *__error();
  v3 = _SILogForLogForCategory(0);
  v4 = 2 * (gSILogLevels[0] < 4);
  if (os_log_type_enabled(v3, v4))
  {
    v5 = fcntl(*(_DWORD *)(a1 + 48), 50, v11);
    if (v11[0])
      v6 = v5 < 0;
    else
      v6 = 1;
    if (v6)
      v7 = 0;
    else
      v7 = v11;
    *(_DWORD *)buf = 136315138;
    v10 = v7;
    _os_log_impl(&dword_1B8270000, v3, v4, "Started initial indexing of %s", buf, 0xCu);
  }
  result = __error();
  *result = v2;
  return result;
}

uint64_t SIGetMaxTransactionID(uint64_t a1)
{
  int v2;
  uint64_t v3;
  unsigned int v4;
  int v5;
  unint64_t v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  void (*v12)(_QWORD);
  int v13;
  NSObject *v14;
  uint64_t v15;
  int v16;
  NSObject *v17;
  os_log_type_t v18;
  _QWORD *v20;
  uint64_t *v21;
  uint64_t v22;
  int v23;
  int v24;
  int v25;
  int v26;
  NSObject *v27;
  os_log_type_t v28;
  uint64_t v29;
  uint64_t v30;
  void (*v31)(_QWORD);
  int v32;
  int v33;
  uint64_t v34;
  int v35;
  unsigned int v36;
  unsigned int v37;
  unsigned int v38;
  unsigned int v39;
  unsigned int v40;
  uint8_t buf[4];
  const char *v42;
  __int16 v43;
  uint64_t v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  makeThreadId();
  if (a1 && *(_QWORD *)(a1 + 1048))
  {
    v40 = 0;
    v2 = fd_setDir(*(unsigned int *)(a1 + 32), (int *)&v40);
    v3 = 0;
    if (!v2)
      return v3;
    do
    {
      v4 = __ldxr(exceptionSequenceNum);
      v5 = v4 + 1;
    }
    while (__stxr(v4 + 1, exceptionSequenceNum));
    v6 = setThreadIdAndInfo(*(_DWORD *)(a1 + 32), sFdExceptionCallbacks, 0, 1, v5);
    v38 = HIDWORD(v6);
    v39 = v6;
    v36 = v8;
    v37 = v7;
    v9 = *(_QWORD *)&threadData[18 * v6 + 2];
    v10 = v9 + 320 * HIDWORD(v6);
    *(_BYTE *)(v10 + 216) = 0;
    v11 = *(_DWORD *)(v10 + 312);
    v12 = *(void (**)(_QWORD))(v10 + 224);
    if (v12)
      v12(*(_QWORD *)(v9 + 320 * HIDWORD(v6) + 288));
    if (_setjmp((int *)v10))
    {
      v13 = *__error();
      v14 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        v42 = "SIGetMaxTransactionID";
        v43 = 1024;
        LODWORD(v44) = 19810;
        _os_log_error_impl(&dword_1B8270000, v14, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
      }
      *__error() = v13;
      *(_DWORD *)(v10 + 312) = v11;
      CIOnThreadCleanUpReset(v36);
      dropThreadId(v39, 1, v5);
      CICleanUpReset(v39, v37);
      v15 = 0;
LABEL_27:
      v32 = v40;
      MEMORY[0x1BCCB1484](v40);
      if ((v32 & 0x80000000) == 0)
        close(v32);
      return v15;
    }
    v20 = *(_QWORD **)(a1 + 1392);
    if (!v20 || !*v20 || (v21 = *(uint64_t **)(a1 + 1384)) == 0 || (v22 = *v21) == 0)
    {
      v26 = *__error();
      v27 = _SILogForLogForCategory(0);
      v28 = gSILogLevels[0] < 3;
      if (os_log_type_enabled(v27, (os_log_type_t)(gSILogLevels[0] < 3)))
      {
        *(_DWORD *)buf = 136315138;
        v42 = "int32_t SIGetMaxTransactionID(SIRef)";
        _os_log_impl(&dword_1B8270000, v27, v28, "*warn* %s called on fs-only index", buf, 0xCu);
      }
      *__error() = v26;
      v15 = 0;
      goto LABEL_24;
    }
    v23 = *((_DWORD *)v21 + 2);
    if (v23)
    {
      v24 = *((_DWORD *)v21 + 2);
      if (*(_QWORD *)(v22 + 8 * (v23 - 1)))
      {
        v25 = *((_DWORD *)v21 + 2);
LABEL_35:
        if (v24 != 1 || *(_QWORD *)(*(_QWORD *)v22 + 72))
        {
          v15 = *(unsigned int *)(*(_QWORD *)(v22 + 8 * (v25 - 1)) + 32);
LABEL_24:
          v29 = *(_QWORD *)&threadData[18 * v39 + 2];
          v30 = v29 + 320 * v38;
          *(_DWORD *)(v30 + 312) = v11;
          v31 = *(void (**)(_QWORD))(v30 + 232);
          if (v31)
            v31(*(_QWORD *)(v29 + 320 * v38 + 288));
          dropThreadId(v39, 0, v5);
          goto LABEL_27;
        }
      }
      else
      {
        v33 = *((_DWORD *)v21 + 2);
        while (v33 != 1)
        {
          v34 = *(_QWORD *)(v22 + 8 * (v33 - 2));
          v35 = --v33;
          if (v34)
          {
            v24 = v35;
            *((_DWORD *)v21 + 2) = v35;
            v25 = v35;
            goto LABEL_35;
          }
        }
        *((_DWORD *)v21 + 2) = 0;
      }
    }
    v15 = 1;
    goto LABEL_24;
  }
  v16 = *__error();
  v17 = _SILogForLogForCategory(0);
  v18 = gSILogLevels[0] < 3;
  if (os_log_type_enabled(v17, (os_log_type_t)(gSILogLevels[0] < 3)))
  {
    *(_DWORD *)buf = 136315394;
    v42 = "int32_t SIGetMaxTransactionID(SIRef)";
    v43 = 2048;
    v44 = a1;
    _os_log_impl(&dword_1B8270000, v17, v18, "*warn* %s called on fs-only or null index %p", buf, 0x16u);
  }
  *__error() = v16;
  return 0;
}

uint64_t SISetTransactionCount(uint64_t a1, int a2, uint64_t a3)
{
  int v6;
  _QWORD *v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  int v11;
  _QWORD *v12;
  uint64_t v13;
  int v14;
  int v15;
  NSObject *v16;
  BOOL v17;
  int v19;
  NSObject *v20;
  os_log_type_t v21;
  int v22;
  const char *v23;
  __int16 v24;
  int v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  makeThreadId();
  if (*(_QWORD *)(a1 + 1056) && *(_QWORD *)(a1 + 1048))
  {
    if (a2 == -1)
    {
      *(_DWORD *)(a1 + 6876) = 1;
    }
    else
    {
      v6 = *(_DWORD *)(a1 + 6876);
      if (v6 >= a2)
        v6 = a2;
      *(_DWORD *)(a1 + 6876) = v6;
      if (a2 == 1)
      {
        if (a3 && *(_QWORD *)(a1 + 6880))
          *(_BYTE *)(a1 + 6893) = 1;
        if (*(_DWORD *)(*(_QWORD *)(a1 + 1392) + 8) == 1 && *(_DWORD *)(*(_QWORD *)(a1 + 1384) + 8) == 1)
        {
          v7 = malloc_type_malloc(0x10uLL, 0x1020040EDED9539uLL);
          *v7 = a1;
          v7[1] = a3;
          v8 = *(_QWORD *)(a1 + 1056);
          v9 = si_set_transactioncount_0;
LABEL_29:
          si_enqueue_work(v8, (uint64_t)v9, (uint64_t)v7);
        }
      }
      else if (a2 >= 2)
      {
        v10 = *(_QWORD *)(a1 + 1384);
        v11 = *(_DWORD *)(v10 + 8);
        if (v11 == 1)
        {
          v12 = malloc_type_malloc(0x10uLL, 0x1020040EDED9539uLL);
          *v12 = a1;
          v12[1] = a3;
          si_enqueue_work(*(_QWORD *)(a1 + 1056), (uint64_t)si_set_transactioncount_0, (uint64_t)v12);
          v11 = *(_DWORD *)(v10 + 8);
        }
        if (v11)
        {
          v13 = 0;
          while (1)
          {
            v14 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v10 + 8 * v13) + 32);
            if (v14 == a2)
              break;
            if (v14 > a2)
              return 0xFFFFFFFFLL;
            if (v11 == ++v13)
              goto LABEL_27;
          }
          if (v11 - 1 > v13)
            return 0xFFFFFFFFLL;
LABEL_27:
          if (*(_QWORD *)(a1 + 1056))
          {
            v17 = v14 == a2;
            v7 = malloc_type_malloc(0x20uLL, 0x102004077D6F10EuLL);
            *((_BYTE *)v7 + 8) = v17;
            v7[2] = a3;
            *v7 = a1;
            *((_DWORD *)v7 + 6) = a2;
            v8 = *(_QWORD *)(a1 + 1056);
            v9 = si_prepareForTransaction;
            goto LABEL_29;
          }
          v19 = *__error();
          v20 = _SILogForLogForCategory(0);
          v21 = 2 * (gSILogLevels[0] < 4);
          if (os_log_type_enabled(v20, v21))
          {
            LOWORD(v22) = 0;
            _os_log_impl(&dword_1B8270000, v20, v21, "Not supported for read only index", (uint8_t *)&v22, 2u);
          }
          *__error() = v19;
        }
        else
        {
          v15 = *__error();
          v16 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
          {
            v22 = 136315394;
            v23 = "SISetTransactionCount";
            v24 = 1024;
            v25 = 19967;
            _os_log_error_impl(&dword_1B8270000, v16, OS_LOG_TYPE_ERROR, "%s:%d: No live index", (uint8_t *)&v22, 0x12u);
          }
          *__error() = v15;
        }
      }
    }
  }
  return 0xFFFFFFFFLL;
}

void si_prepareForTransaction(void *a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  void **v7;

  if (!a2)
  {
    v3 = *(_QWORD *)a1;
    v4 = *(_QWORD *)(*(_QWORD *)a1 + 1384);
    v5 = count_IndexSetForWriting(v4, *(_DWORD *)(v4 + 8) - 1);
    v6 = *(_QWORD *)(*(_QWORD *)v4 + 8 * (*(_DWORD *)(v4 + 8) - 1));
    if (v5 < 0xF)
    {
      if (!*(_BYTE *)(v6 + 36))
      {
        v7 = (void **)ContentIndexListClone((__int128 *)v4);
        if (!*((_BYTE *)a1 + 8) && prepareForTransaction(v3, (uint64_t)v7, 0, *((_DWORD *)a1 + 6))
          || prepareForTransaction(v3, (uint64_t)v7, *((_QWORD *)a1 + 2), *((_DWORD *)a1 + 6) + 1))
        {
          ContentIndexListFree(v7);
        }
        else
        {
          si_swapIndexSet((int *)v3, v4, (unint64_t)v7, (unint64_t *)(v3 + 1384));
        }
      }
    }
    else
    {
      ContentIndexSetEmergency((int *)v6, 1);
    }
  }
  free(a1);
}

uint64_t prepareForTransaction(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  const __CFString *v8;
  int v9;
  int v10;
  __int16 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  int *v20;
  uint64_t vector_store;
  uint64_t New;
  uint64_t v23;
  _DWORD *v24;
  unsigned int v25;
  int v26;
  NSObject *v27;
  int v29;
  NSObject *v30;
  _DWORD *v31;
  unsigned int v32;
  _QWORD aBlock[6];
  _QWORD v34[5];
  _QWORD v35[5];
  uint8_t buf[4];
  const char *v37;
  __int16 v38;
  int v39;
  __int16 v40;
  const __CFString *v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  v8 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("live.%d."), *(unsigned int *)(a2 + 8));
  v9 = ((*(_DWORD *)(a1 + 828) & 1) << 6) ^ 0x50;
  if (*(_BYTE *)(a1 + 2072))
    v9 |= 0x100u;
  if (*(_BYTE *)(a1 + 2073))
    v9 |= 0x400u;
  v10 = v9 | (*(_DWORD *)(a1 + 6584) >> 7) & 0x800;
  if (*(_BYTE *)(a1 + 6944))
    v11 = v10 | 0x1000;
  else
    v11 = v10;
  v12 = MEMORY[0x1E0C809B0];
  v35[0] = MEMORY[0x1E0C809B0];
  v35[1] = 0x40000000;
  v35[2] = __prepareForTransaction_block_invoke;
  v35[3] = &__block_descriptor_tmp_1410;
  v35[4] = a1;
  v13 = *(unsigned int *)(a1 + 32);
  v14 = *(_QWORD *)(*(_QWORD *)a2 + 8 * (*(_DWORD *)(a2 + 8) - 1));
  LODWORD(v15) = *(_DWORD *)(v14 + 60);
  v16 = *(_QWORD *)(v14 + 72);
  if (v15 >= 2)
    v15 = v15;
  else
    v15 = 0;
  v17 = a3 + 1025;
  v18 = a3 + 1025 + v16 + v15;
  v19 = *(_DWORD *)(a1 + 1276);
  v20 = *(int **)(a1 + 1184);
  if (v20)
    vector_store = db_get_vector_store(v20);
  else
    vector_store = 0;
  v34[0] = v12;
  v34[1] = 0x40000000;
  v34[2] = __prepareForTransaction_block_invoke_2;
  v34[3] = &__block_descriptor_tmp_1411;
  v34[4] = a1;
  New = ContentIndexCreateNew(v13, v8, v18, a4, v11, 1, v19, vector_store, (uint64_t)v34, v35);
  if (New)
  {
    v23 = New;
    v24 = *(_DWORD **)(*(_QWORD *)a2 + 8 * (*(_DWORD *)(a2 + 8) - 1));
    v25 = v24[15];
    if (v25 < 2)
      v25 = 0;
    _ContentIndexSetPayloadMaxCount(v24, v17 + v24[18] + v25, 19842);
    CFRelease(v8);
    v26 = *__error();
    v27 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315650;
      v37 = "prepareForTransaction";
      v38 = 1024;
      v39 = 19847;
      v40 = 1024;
      LODWORD(v41) = a4;
      _os_log_error_impl(&dword_1B8270000, v27, OS_LOG_TYPE_ERROR, "%s:%d: Prepare for transaction %d", buf, 0x18u);
    }
    *__error() = v26;
    aBlock[0] = v12;
    aBlock[1] = 0x40000000;
    aBlock[2] = __prepareForTransaction_block_invoke_1412;
    aBlock[3] = &__block_descriptor_tmp_1413;
    aBlock[4] = a1;
    aBlock[5] = v23;
    ContentIndexSetDirtyCallback(v23, aBlock);
    *(_BYTE *)(v23 + 15161) = 4;
    ContentIndexListAppend(a2, v23);
    return 0;
  }
  else
  {
    v29 = *__error();
    v30 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315650;
      v37 = "prepareForTransaction";
      v38 = 1024;
      v39 = 19840;
      v40 = 2112;
      v41 = v8;
      _os_log_error_impl(&dword_1B8270000, v30, OS_LOG_TYPE_ERROR, "%s:%d: Could not create new live index %@", buf, 0x1Cu);
    }
    *__error() = v29;
    v31 = *(_DWORD **)(*(_QWORD *)a2 + 8 * (*(_DWORD *)(a2 + 8) - 1));
    v32 = v31[15];
    if (v32 < 2)
      v32 = 0;
    _ContentIndexSetPayloadMaxCount(v31, v17 + v31[18] + v32, 19842);
    CFRelease(v8);
    return 0xFFFFFFFFLL;
  }
}

void __prepareForTransaction_block_invoke(uint64_t a1, const void *a2)
{
  si_collect_block(*(_QWORD *)(a1 + 32), a2);
}

uint64_t __prepareForTransaction_block_invoke_2(uint64_t a1, uint64_t a2)
{
  return _si_next_index_id(*(os_unfair_lock_s **)(a1 + 32), a2, 1, 0);
}

uint64_t __prepareForTransaction_block_invoke_1412(uint64_t a1)
{
  return si_set_obj_state(*(os_unfair_lock_s **)(a1 + 32), *(_QWORD *)(a1 + 40));
}

void delayed_op_prop2(uint64_t a1, int a2)
{
  void *v3;

  if (a2)
  {
    (*(void (**)(_QWORD))(a1 + 16))(*(_QWORD *)a1);
    free((void *)a1);
  }
  else
  {
    if (*(_DWORD *)(a1 + 24) == 3)
      v3 = delayed_op_final;
    else
      v3 = delayed_op_prop3;
    si_enqueue_work_for_job(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 1040), (uint64_t)v3, a1, 0);
  }
}

void delayed_op_prop3(uint64_t a1, int a2)
{
  void *v3;

  if (a2)
  {
    (*(void (**)(_QWORD))(a1 + 16))(*(_QWORD *)a1);
    free((void *)a1);
  }
  else
  {
    if (*(_DWORD *)(a1 + 24) == 4)
      v3 = delayed_op_final;
    else
      v3 = delayed_op_prop4;
    si_enqueue_work_for_job(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 1056), (uint64_t)v3, a1, 0);
  }
}

void delayed_op_prop4(_QWORD *a1, int a2)
{
  uint64_t v3;

  if (!a2 && (v3 = a1[1], (*(_BYTE *)(v3 + 6584) & 0x10) != 0))
  {
    si_enqueue_work_for_job(*(_QWORD *)(v3 + 1088), (uint64_t)delayed_op_final, (uint64_t)a1, 0);
  }
  else
  {
    ((void (*)(_QWORD))a1[2])(*a1);
    free(a1);
  }
}

void _SIScheduleDiskOperation(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;

  v4 = *(_QWORD *)(a1 + 1072);
  if (a2)
    si_enqueue_work_with_qos(v4, a2, a3, a4);
  else
    si_enqueue_work(v4, a3, a4);
}

void _SIScheduleOperation(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;

  v4 = *(_QWORD *)(a1 + 1104);
  if (a2)
    si_enqueue_work_with_qos(v4, a2, a3, a4);
  else
    si_enqueue_work(v4, a3, a4);
}

void _SIScheduleOperationPostIndexUpdate(uint64_t a1, int a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v5;
  uint64_t v6;

  if (a1)
  {
    if (a5)
    {
      v5 = 17;
      if (!*(_QWORD *)(a1 + 1144))
        v5 = 5;
    }
    else
    {
      v5 = 5;
    }
    v6 = *(_QWORD *)(a1 + 8 * v5 + 1008);
    if (v6)
    {
      if (a2)
        si_enqueue_barrier_with_qos(v6, a2, a3, a4);
      else
        si_enqueue_barrier(v6, a3, a4);
    }
  }
}

void _SIIssueFullMerge(_QWORD *a1)
{
  _SIIssueFullMergeWithGroup(a1, 0);
}

void _SIIssueMerge(_QWORD *a1, int a2)
{
  char *v4;
  uint64_t v5;
  uint64_t (*v6)(_QWORD, const char *, uint64_t, const char *);

  if (a1[130])
  {
    v4 = (char *)malloc_type_calloc(1uLL, 0x460uLL, 0x1070040C187FD8AuLL);
    *(_QWORD *)v4 = a1;
    v4[16] = a2 != 0;
    *(_WORD *)(v4 + 1041) = 0;
    *((_QWORD *)v4 + 131) = "void _SIIssueMerge(SIRef, int)";
    *((_DWORD *)v4 + 274) = 4;
    __strlcpy_chk();
    if (!*((_QWORD *)v4 + 136) && !*((_DWORD *)v4 + 266))
    {
      v5 = a1[295];
      if (v5)
      {
        v6 = *(uint64_t (**)(_QWORD, const char *, uint64_t, const char *))(v5 + 64);
        if (v6)
          *((_DWORD *)v4 + 266) = v6(*(_QWORD *)(v5 + 136), "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 20823, "void _SIIssueMerge(SIRef, int)");
      }
    }
    si_enqueue_barrier_with_qos(a1[144], 5, (uint64_t)_SIContinueIssueMerge0, (uint64_t)v4);
  }
}

void _SIIssueCompact(uint64_t a1, int a2)
{
  if (*(_QWORD *)(a1 + 1040))
    compactReadOnlyIndexes(a1, a2 != 0);
}

void si_merge_for_badness(uint64_t a1, char a2)
{
  _QWORD *v4;
  uint64_t v5;
  void (*v6)(uint64_t, _QWORD, const __CFString *, _QWORD *);
  uint64_t v7;
  _QWORD v8[5];

  if (*(_QWORD *)(a1 + 1152))
  {
    if ((a2 & 1) != 0
      || *(_BYTE *)(a1 + 2457)
      || (v5 = *(_QWORD *)(a1 + 2360),
          (v6 = *(void (**)(uint64_t, _QWORD, const __CFString *, _QWORD *))(v5 + 80)) == 0))
    {
      v4 = malloc_type_malloc(0x20uLL, 0x102004092C98459uLL);
      *v4 = a1;
      v4[1] = 0;
      *((_BYTE *)v4 + 16) = a2;
      v4[3] = 0;
      si_enqueue_barrier_with_qos(*(_QWORD *)(a1 + 1152), 5, (uint64_t)_si_merge_for_badness_on_hold_queue, (uint64_t)v4);
    }
    else
    {
      *(_BYTE *)(a1 + 2457) = 1;
      v7 = *(_QWORD *)(v5 + 136);
      v8[0] = MEMORY[0x1E0C809B0];
      v8[1] = 0x40000000;
      v8[2] = __si_merge_for_badness_block_invoke;
      v8[3] = &__block_descriptor_tmp_427;
      v8[4] = a1;
      v6(v7, 0, CFSTR("MergeForBadness"), v8);
    }
  }
}

void __si_merge_for_badness_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, NSObject *a5)
{
  uint64_t v8;
  BOOL v9;
  int v10;
  NSObject *v11;
  os_log_type_t v12;
  int v13;
  _QWORD *v14;
  uint8_t v15[12];
  unsigned int v16;

  if (a2 && *(_BYTE *)(a2 + 2457))
  {
    *(_BYTE *)(a2 + 2457) = 0;
    v16 = -1;
    v8 = *(unsigned int *)(*(_QWORD *)(a1 + 32) + 32);
    v9 = (_DWORD)v8 == -1 || (fd_setDir(v8, (int *)&v16) & 1) == 0;
    v10 = *__error();
    v11 = _SILogForLogForCategory(12);
    v12 = 2 * (dword_1EF19FCBC < 4);
    if (os_log_type_enabled(v11, v12))
    {
      *(_WORD *)v15 = 0;
      _os_log_impl(&dword_1B8270000, v11, v12, "MergeForBadness started", v15, 2u);
    }
    *__error() = v10;
    if (!v9)
    {
      v13 = v16;
      MEMORY[0x1BCCB1484](v16);
      if ((v13 & 0x80000000) == 0)
        close(v13);
    }
    v14 = malloc_type_malloc(0x20uLL, 0x102004092C98459uLL);
    *v14 = a2;
    v14[1] = a5;
    *((_BYTE *)v14 + 16) = 0;
    dispatch_retain(a5);
    dispatch_group_enter(a5);
    v14[3] = 0;
    si_enqueue_barrier_with_qos(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 1152), 5, (uint64_t)_si_merge_for_badness_on_hold_queue, (uint64_t)v14);
  }
}

void _si_merge_for_badness_on_hold_queue(unsigned int **a1, int a2)
{
  if (a2)
    si_merge_for_badness_ctx_free(a1);
  else
    si_scheduler_async_suspend_and_enqueue(*((_QWORD *)*a1 + 109), *((_QWORD *)*a1 + 130), (uint64_t)_si_merge_for_badness_on_flush_queue, (uint64_t)a1, a1 + 3);
}

void _si_merge_for_badness_on_flush_queue(unsigned int **a1, int a2)
{
  unsigned int *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  unsigned int *v12;
  _QWORD v13[2];
  uint64_t (*v14)(uint64_t, uint64_t, char);
  void *v15;
  unsigned int *v16;

  if (a2)
  {
    si_merge_for_badness_ctx_free(a1);
  }
  else
  {
    v3 = *a1;
    v4 = *((_QWORD *)*a1 + 174);
    v5 = *((_QWORD *)*a1 + 173);
    v13[0] = MEMORY[0x1E0C809B0];
    v13[1] = 0x40000000;
    v14 = ___si_merge_for_badness_on_flush_queue_block_invoke;
    v15 = &__block_descriptor_tmp_1440;
    v16 = v3;
    if (v5)
    {
      v6 = *(unsigned int *)(v5 + 8);
      while ((int)v6 >= 1)
      {
        v7 = v6 - 1;
        v8 = v14((uint64_t)v13, *(_QWORD *)(*(_QWORD *)v5 + 8 * v6 - 8), 1);
        v6 = v7;
        if (!v8)
          goto LABEL_12;
      }
    }
    if (v4)
    {
      v9 = *(unsigned int *)(v4 + 8);
      do
      {
        if ((int)v9 < 1)
          break;
        v10 = v9 - 1;
        v11 = v14((uint64_t)v13, *(_QWORD *)(*(_QWORD *)v4 + 8 * v9 - 8), 0);
        v9 = v10;
      }
      while (v11);
    }
LABEL_12:
    v12 = a1[3];
    if (v12)
    {
      si_scheduler_resume_with_token(v12);
      a1[3] = 0;
    }
    si_enqueue_work(*((_QWORD *)v3 + 132), (uint64_t)_si_merge_for_badness_on_compact_queue, (uint64_t)a1);
  }
}

void si_merge_for_badness_ctx_free(void *a1)
{
  unsigned int *v2;
  NSObject *v3;

  if (a1)
  {
    v2 = (unsigned int *)*((_QWORD *)a1 + 3);
    if (v2)
      si_scheduler_resume_with_token(v2);
    v3 = *((_QWORD *)a1 + 1);
    if (v3)
    {
      dispatch_group_leave(v3);
      dispatch_release(*((dispatch_object_t *)a1 + 1));
    }
    free(a1);
  }
}

uint64_t ___si_merge_for_badness_on_flush_queue_block_invoke(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v5;
  char v6;
  _QWORD *v7;

  v5 = *(_QWORD *)(a1 + 32);
  if (*(_BYTE *)(a2 + 16440) || *(_BYTE *)(a2 + 15166))
  {
    v6 = atomic_load((unsigned int *)(a2 + 28));
    if ((v6 & 3) == 0 && !*(_BYTE *)(a2 + 15163))
    {
      v7 = malloc_type_calloc(1uLL, 0x60uLL, 0x10B0040E0DE4348uLL);
      *v7 = v5;
      v7[1] = a2;
      *((_DWORD *)v7 + 5) = *(_DWORD *)(a2 + 48);
      *((_BYTE *)v7 + 80) = a3;
      *((_BYTE *)v7 + 83) = 1;
      _swapIndex(v7, 0);
    }
  }
  return 1;
}

void _si_merge_for_badness_on_compact_queue(_QWORD *a1, int a2)
{
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  _DWORD *v12;
  int v13;
  NSObject *v14;
  uint64_t v15;
  uint64_t (*v16)(_QWORD, const char *, uint64_t, const char *);
  _QWORD v17[2];
  uint64_t (*v18)(_QWORD *, _BYTE *, int);
  void *v19;
  uint64_t *v20;
  uint64_t *v21;
  uint64_t *v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  char v27;
  uint64_t v28;
  uint64_t *v29;
  uint64_t v30;
  char v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  uint64_t *v37;
  uint64_t v38;
  uint64_t v39;
  uint8_t buf[4];
  const char *v41;
  __int16 v42;
  int v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  if (!a2)
  {
    v3 = (_QWORD *)*a1;
    v36 = 0;
    v37 = &v36;
    v38 = 0x2000000000;
    v39 = 0;
    v32 = 0;
    v33 = &v32;
    v34 = 0x2000000000;
    v35 = 0;
    v28 = 0;
    v29 = &v28;
    v30 = 0x2000000000;
    v31 = 0;
    v24 = 0;
    v25 = &v24;
    v26 = 0x2000000000;
    v27 = 0;
    v4 = v3[174];
    v5 = v3[173];
    v17[0] = MEMORY[0x1E0C809B0];
    v17[1] = 0x40000000;
    v18 = ___si_merge_for_badness_on_compact_queue_block_invoke;
    v19 = &unk_1E6E2E308;
    v20 = &v36;
    v21 = &v32;
    v22 = &v28;
    v23 = &v24;
    if (v5)
    {
      v6 = *(unsigned int *)(v5 + 8);
      while ((int)v6 >= 1)
      {
        v7 = v6 - 1;
        v8 = v18(v17, *(_BYTE **)(*(_QWORD *)v5 + 8 * v6 - 8), 1);
        v6 = v7;
        if (!v8)
          goto LABEL_11;
      }
    }
    if (v4)
    {
      v9 = *(unsigned int *)(v4 + 8);
      do
      {
        if ((int)v9 < 1)
          break;
        v10 = v9 - 1;
        v11 = v18(v17, *(_BYTE **)(*(_QWORD *)v4 + 8 * v9 - 8), 0);
        v9 = v10;
      }
      while (v11);
    }
LABEL_11:
    if (v37[3])
    {
      if (*((_BYTE *)v25 + 24) || !*((_BYTE *)v29 + 24) || (transfer_live_indexes((uint64_t)v3) & 1) != 0)
      {
        v12 = malloc_type_calloc(1uLL, 0x460uLL, 0x1070040C187FD8AuLL);
        v12[2] = *(_DWORD *)(v37[3] + 48);
        v12[3] = *((_DWORD *)v33 + 6);
        *((_BYTE *)v12 + 1042) = 0;
        *(_QWORD *)v12 = v3;
        *((_BYTE *)v12 + 16) = *((_BYTE *)v25 + 24);
        *((_BYTE *)v12 + 1041) = 0;
        *((_QWORD *)v12 + 131) = "void _si_merge_for_badness_on_compact_queue(void *, Boolean)";
        v12[274] = 8;
        *((_QWORD *)v12 + 139) = a1[1];
        a1[1] = 0;
        __strlcpy_chk();
        if (!*((_QWORD *)v12 + 136) && !v12[266])
        {
          v15 = v3[295];
          if (v15)
          {
            v16 = *(uint64_t (**)(_QWORD, const char *, uint64_t, const char *))(v15 + 64);
            if (v16)
              v12[266] = v16(*(_QWORD *)(v15 + 136), "/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 20909, "void _si_merge_for_badness_on_compact_queue(void *, Boolean)");
          }
        }
        si_mergeIndex((uint64_t *)v12, 0);
        si_merge_for_badness(v3, *((unsigned __int8 *)a1 + 16));
      }
      else
      {
        v13 = *__error();
        v14 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315394;
          v41 = "_si_merge_for_badness_on_compact_queue";
          v42 = 1024;
          v43 = 20891;
          _os_log_error_impl(&dword_1B8270000, v14, OS_LOG_TYPE_ERROR, "%s:%d: transfer_live_indexes failed", buf, 0x12u);
        }
        *__error() = v13;
      }
    }
    _Block_object_dispose(&v24, 8);
    _Block_object_dispose(&v28, 8);
    _Block_object_dispose(&v32, 8);
    _Block_object_dispose(&v36, 8);
  }
  si_merge_for_badness_ctx_free(a1);
}

uint64_t ___si_merge_for_badness_on_compact_queue_block_invoke(_QWORD *a1, _BYTE *a2, int a3)
{
  uint64_t v3;

  if ((a2[16440] || a2[15166]) && !a2[15167])
  {
    v3 = 1;
    a2[15167] = 1;
    *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = a2;
    ++*(_DWORD *)(*(_QWORD *)(a1[5] + 8) + 24);
    if (a3)
      *(_BYTE *)(*(_QWORD *)(a1[6] + 8) + 24) = 1;
  }
  else if (*(_DWORD *)(*(_QWORD *)(a1[5] + 8) + 24))
  {
    v3 = 0;
    *(_BYTE *)(*(_QWORD *)(a1[7] + 8) + 24) = a3;
    *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = a2;
    ++*(_DWORD *)(*(_QWORD *)(a1[5] + 8) + 24);
  }
  else
  {
    return 1;
  }
  return v3;
}

void _SIIssueVerify(uint64_t a1, int a2)
{
  _DWORD *v4;
  uint64_t v5;
  void *v6;

  v4 = malloc_type_malloc(0x10uLL, 0x10200403A5D3213uLL);
  *(_QWORD *)v4 = a1;
  v4[2] = a2;
  v5 = 1080;
  if (*(_BYTE *)(a1 + 1280))
  {
    v6 = si_verify;
  }
  else
  {
    v5 = 1048;
    v6 = si_verify0;
  }
  si_enqueue_work(*(_QWORD *)(a1 + v5), (uint64_t)v6, (uint64_t)v4);
}

void si_verify0(void *a1, int a2)
{
  if (a2)
    free(a1);
  else
    si_enqueue_work(*(_QWORD *)(*(_QWORD *)a1 + 1056), (uint64_t)si_verify, (uint64_t)a1);
}

void si_verify(uint64_t *a1, int a2)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t (*v5)(_QWORD, const char *);
  uint64_t v6;
  int v7;
  int v8;
  NSObject *v9;
  os_log_type_t v10;
  int v11;
  BOOL v12;
  const char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  unint64_t v23;
  uint64_t i;
  int v25;
  unint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  uint64_t *v30;
  uint64_t v31;
  int v32;
  NSObject *v33;
  int v34;
  uint64_t v35;
  void (*v36)(_QWORD, uint64_t, BOOL);
  int v37;
  BOOL v38;
  uint64_t v39;
  _BYTE *v40;
  uint64_t v41;
  int v42;
  int v43;
  uint64_t v44;
  uint64_t *v45;
  uint64_t **v46;
  unsigned int v47;
  uint8_t buf[4];
  const char *v49;
  __int16 v50;
  int v51;
  __int16 v52;
  _BYTE *v53;
  __int16 v54;
  int v55;
  __int16 v56;
  int v57;
  __int16 v58;
  int v59;
  __int16 v60;
  int v61;
  __int16 v62;
  int v63;
  _BYTE v64[1024];
  uint64_t v65;

  v2 = a1;
  v65 = *MEMORY[0x1E0C80C00];
  if (!a2)
  {
    v3 = *a1;
    bzero(v64, 0x400uLL);
    v4 = *(_QWORD *)(v3 + 2360);
    v5 = *(uint64_t (**)(_QWORD, const char *))(v4 + 96);
    if (v5)
      v6 = v5(*(_QWORD *)(v4 + 136), "com.apple.spotlightindex.verify");
    else
      v6 = 0;
    si_scheduler_suspend(*(_QWORD *)(v3 + 864));
    v47 = 0;
    v7 = 0;
    if (fd_setDir(*(unsigned int *)(v3 + 32), (int *)&v47))
    {
      v44 = v6;
      v45 = v2;
      v8 = *__error();
      v9 = _SILogForLogForCategory(0);
      v10 = 2 * (gSILogLevels[0] < 4);
      if (os_log_type_enabled(v9, v10))
      {
        v11 = fcntl(*(_DWORD *)(v3 + 32), 50, v64);
        if (v64[0])
          v12 = v11 < 0;
        else
          v12 = 1;
        if (v12)
          v13 = 0;
        else
          v13 = v64;
        *(_DWORD *)buf = 136315138;
        v49 = v13;
        _os_log_impl(&dword_1B8270000, v9, v10, "verifying %s", buf, 0xCu);
      }
      *__error() = v8;
      v14 = *(_QWORD *)(v3 + 1392);
      v15 = *(_QWORD *)(v3 + 1384);
      if (v14)
        v16 = *(unsigned int *)(v14 + 8);
      else
        v16 = 0;
      v46 = *(uint64_t ***)(v3 + 1384);
      if (v15)
        v17 = *(unsigned int *)(v15 + 8);
      else
        v17 = 0;
      *(_QWORD *)(v3 + 1248) = 0;
      v18 = (unint64_t *)(v3 + 1256);
      *(_QWORD *)(v3 + 1256) = -1;
      *(_QWORD *)(v3 + 1264) = -1;
      *(_DWORD *)(v3 + 1272) = 0;
      if (v16)
      {
        v19 = 0;
        while (1)
        {
          v20 = *(_QWORD *)(*(_QWORD *)v14 + v19);
          v21 = ContentIndexVerifyIndex(v20);
          if (atomic_load((unsigned int *)(v20 + 15152)))
            break;
          if (v21)
          {
LABEL_39:
            _CIMakeInvalid(v20);
            if (v16)
            {
              v28 = *(uint64_t **)v14;
              do
              {
                v29 = *v28++;
                *(_BYTE *)(v29 + 8) = 0;
                --v16;
              }
              while (v16);
            }
            if (v17)
            {
              v30 = *v46;
              do
              {
                v31 = *v30++;
                *(_BYTE *)(v31 + 8) = 0;
                --v17;
              }
              while (v17);
            }
            *(_DWORD *)(v3 + 1272) = -2;
            v32 = *__error();
            v33 = _SILogForLogForCategory(0);
            if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
            {
              v37 = fcntl(*(_DWORD *)(v3 + 32), 50, v64);
              if (v64[0])
                v38 = v37 < 0;
              else
                v38 = 1;
              v39 = *(_QWORD *)(v3 + 1256);
              if (v38)
                v40 = 0;
              else
                v40 = v64;
              v41 = *(_QWORD *)(v3 + 1264);
              v42 = *(_DWORD *)(v3 + 1248);
              v43 = *(_DWORD *)(v3 + 1252);
              *(_DWORD *)buf = 136316930;
              v49 = "si_verify";
              v50 = 1024;
              v51 = 21037;
              v52 = 2080;
              v53 = v40;
              v54 = 1024;
              v55 = -2;
              v56 = 1024;
              v57 = v39;
              v58 = 1024;
              v59 = v41;
              v60 = 1024;
              v61 = v42;
              v62 = 1024;
              v63 = v43;
              _os_log_error_impl(&dword_1B8270000, v33, OS_LOG_TYPE_ERROR, "%s:%d: verify index: %s, err: %d, (%d %d) , (%d, %d)", buf, 0x3Au);
            }
            *__error() = v32;
            v7 = -2;
            if (!*(_BYTE *)(v3 + 1280))
              si_makeUnavailable(v3, 4294967294, 2, 15, (uint64_t)"verify err");
            goto LABEL_48;
          }
          v23 = *(_QWORD *)(v20 + 16288);
          if (v23 >= *(_QWORD *)(v20 + 16296))
            v23 = *(_QWORD *)(v20 + 16296);
          if (v23 > *v18)
            *v18 = v23;
          ++*(_DWORD *)(v3 + 1248);
          v19 += 8;
          if (8 * v16 == v19)
            goto LABEL_29;
        }
      }
      else
      {
LABEL_29:
        if (v17)
        {
          for (i = 0; i != v17; ++i)
          {
            v20 = (*v46)[i];
            v25 = ContentIndexVerifyIndex(v20);
            if (atomic_load((unsigned int *)(v20 + 15152)))
              break;
            if (v25)
              goto LABEL_39;
            v27 = *(_QWORD *)(v20 + 16288);
            if (v27 >= *(_QWORD *)(v20 + 16296))
              v27 = *(_QWORD *)(v20 + 16296);
            if (v27 > *v18)
              *(_QWORD *)(v3 + 1264) = v27;
            ++*(_DWORD *)(v3 + 1252);
          }
        }
      }
      v7 = 0;
LABEL_48:
      v6 = v44;
      v2 = v45;
      v34 = v47;
      MEMORY[0x1BCCB1484](v47);
      if ((v34 & 0x80000000) == 0)
        close(v34);
    }
    si_scheduler_resume(*(_QWORD *)(v3 + 864), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 21052);
    v35 = *(_QWORD *)(v3 + 2360);
    v36 = *(void (**)(_QWORD, uint64_t, BOOL))(v35 + 104);
    if (v36)
      v36(*(_QWORD *)(v35 + 136), v6, v7 != 0);
  }
  free(v2);
}

void _SICleanupStrings(uint64_t a1, void *a2, NSObject *a3, _BYTE *a4, int a5)
{
  uint64_t v10;
  uint64_t v11;
  void *v12;
  xpc_object_t v13;

  if (!**(_DWORD **)(a1 + 6592) && (!a4 || !*a4))
  {
    si_sync_ctx_create_with_defer_fd(a1, 0);
    v11 = v10;
    *(_QWORD *)(v10 + 40) = si_syncFinishedForCleanup;
    v12 = malloc_type_calloc(1uLL, 0x30uLL, 0x1030040DF2DC81EuLL);
    *(_QWORD *)v12 = a1;
    *((_QWORD *)v12 + 3) = a4;
    *((_DWORD *)v12 + 8) = a5;
    if (a2)
      v13 = xpc_retain(a2);
    else
      v13 = 0;
    *((_QWORD *)v12 + 1) = v13;
    if (a3)
    {
      *((_QWORD *)v12 + 2) = a3;
      dispatch_retain(a3);
      dispatch_group_enter(*((dispatch_group_t *)v12 + 2));
    }
    *(_QWORD *)(v11 + 48) = v12;
    si_enqueue_work_with_qos(*(_QWORD *)(a1 + 1096), 9, (uint64_t)si_sync_index_delayed0, v11);
  }
}

void si_syncFinishedForCleanup(_QWORD *a1, int a2)
{
  _DWORD *v2;
  uint64_t v3;
  _DWORD *v4;
  void *v5;
  int *v6;
  int v7;
  NSObject *v8;
  int v9;
  char *v10;
  char *v11;
  const char *v12;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  int v18;
  uint64_t v19;

  v2 = a1;
  v19 = *MEMORY[0x1E0C80C00];
  if (!a2)
  {
    v3 = *a1;
    if (*a1)
    {
      v4 = *(_DWORD **)(v3 + 1184);
      if (v4)
      {
        if (*v4 != 1685287992)
        {
          v6 = *(int **)(v3 + 1184);
          v7 = *__error();
          v8 = _SILogForLogForCategory(4);
          if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
          {
            v9 = *v6;
            *(_DWORD *)buf = 136315650;
            v14 = "db_garbage_collect_strings";
            v15 = 1024;
            v16 = 440;
            v17 = 1024;
            v18 = v9;
            _os_log_error_impl(&dword_1B8270000, v8, OS_LOG_TYPE_ERROR, "%s:%d: unexpected db signature %x", buf, 0x18u);
          }
          *__error() = v7;
          v10 = __si_assert_copy_extra_268();
          v11 = v10;
          if (v10)
            v12 = v10;
          else
            v12 = "";
          __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 440, v12);
          free(v11);
          MEMORY[0xBAD] = -559038737;
          abort();
        }
        v5 = db2_garbage_collect_strings((uint64_t)v4, v2[8] & 1, *(_DWORD **)(v3 + 6592));
        *((_QWORD *)v2 + 5) = v5;
        if (v5)
        {
          si_enqueue_work_with_qos(*(_QWORD *)(v3 + 1056), 9, (uint64_t)si_CleanupCommit, (uint64_t)v2);
          v2 = 0;
        }
      }
    }
  }
  si_cleanup_strings_ctx_free(v2);
}

void si_CleanupCommit(_BYTE **a1, int a2)
{
  _BYTE *v3;
  uint64_t v4;
  uint64_t i;
  unsigned int v6;
  int v7;
  unint64_t v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  void (*v14)(_QWORD);
  int v15;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  void (*v19)(_QWORD);
  _BYTE *v20;
  uint64_t j;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  uint8_t buf[4];
  const char *v27;
  __int16 v28;
  int v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  if (!a2)
  {
    v3 = *a1;
    if (*a1)
    {
      if (*((_QWORD *)v3 + 148))
      {
        v4 = *((_QWORD *)v3 + 148);
        if (!**((_DWORD **)v3 + 824))
        {
          for (i = 0; i != 144; i += 8)
          {
            if (i != 80)
              si_scheduler_suspend(*(_QWORD *)&v3[i + 864]);
          }
          v4 = *((_QWORD *)v3 + 148);
        }
        do
        {
          v6 = __ldxr(exceptionSequenceNum);
          v7 = v6 + 1;
        }
        while (__stxr(v6 + 1, exceptionSequenceNum));
        v8 = setThreadIdAndInfo(-1, (__int128 *)sSDBExceptionCallbacks, v4, 0x40000000, v7);
        v24 = HIDWORD(v8);
        v25 = v8;
        v22 = v10;
        v23 = v9;
        v11 = *(_QWORD *)&threadData[18 * v8 + 2];
        v12 = v11 + 320 * HIDWORD(v8);
        *(_BYTE *)(v12 + 216) = 0;
        v13 = *(_DWORD *)(v12 + 312);
        v14 = *(void (**)(_QWORD))(v12 + 224);
        if (v14)
          v14(*(_QWORD *)(v11 + 320 * HIDWORD(v8) + 288));
        if (_setjmp((int *)v12))
        {
          v15 = *__error();
          v16 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315394;
            v27 = "si_CleanupCommit";
            v28 = 1024;
            v29 = 21164;
            _os_log_error_impl(&dword_1B8270000, v16, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
          }
          *__error() = v15;
          *(_DWORD *)(v12 + 312) = v13;
          CIOnThreadCleanUpReset(v22);
          dropThreadId(v25, 1, v7);
          CICleanUpReset(v25, v23);
        }
        else
        {
          db_garbage_collect_strings_commit(*((_QWORD *)v3 + 148), a1[5], 0);
          v17 = *(_QWORD *)&threadData[18 * v25 + 2];
          v18 = v17 + 320 * v24;
          *(_DWORD *)(v18 + 312) = v13;
          v19 = *(void (**)(_QWORD))(v18 + 232);
          if (v19)
            v19(*(_QWORD *)(v17 + 320 * v24 + 288));
          dropThreadId(v25, 0, v7);
        }
        v20 = v3 + 1000;
        for (j = 0; j != -144; j -= 8)
        {
          if (j != -56)
            si_scheduler_resume(*(_QWORD *)&v20[j], (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 21147);
        }
      }
    }
  }
  si_cleanup_strings_ctx_free(a1);
}

void si_cleanup_strings_ctx_free(void *a1)
{
  NSObject *v2;
  void *v3;

  if (a1)
  {
    v2 = *((_QWORD *)a1 + 2);
    if (v2)
    {
      dispatch_group_leave(v2);
      dispatch_release(*((dispatch_object_t *)a1 + 2));
    }
    v3 = (void *)*((_QWORD *)a1 + 1);
    if (v3)
      xpc_release(v3);
    free(a1);
  }
}

void _SIIssueDefrag(uint64_t a1)
{
  uint64_t v2;

  if (!**(_DWORD **)(a1 + 6592))
  {
    si_sync_ctx_create_with_defer_fd(a1, 0);
    *(_BYTE *)(v2 + 138) = 1;
    *(_BYTE *)(v2 + 96) = 1;
    si_enqueue_work_with_qos(*(_QWORD *)(a1 + 1096), 9, (uint64_t)si_sync_index_delayed0, v2);
  }
}

void _SIIssueFlush(uint64_t a1, int a2)
{
  _QWORD *v4;
  _DWORD *LiveIndex;
  int v6;

  v4 = malloc_type_calloc(1uLL, 0x60uLL, 0x10B0040E0DE4348uLL);
  *v4 = a1;
  if (a2)
    LiveIndex = si_getLiveIndex(*(_QWORD *)(a1 + 1384));
  else
    LiveIndex = si_getSyncIndex(a1, 0);
  v4[1] = LiveIndex;
  v6 = LiveIndex[12];
  *((_DWORD *)v4 + 4) = 2;
  *((_DWORD *)v4 + 5) = v6;
  si_enqueue_work(*(_QWORD *)(a1 + 1040), (uint64_t)_flushCache, (uint64_t)v4);
}

uint64_t SICrashStringInit(uint64_t result, int a2)
{
  gSICrashBuffer = result;
  gSICrashBufferSize = a2;
  return result;
}

uint64_t SISetPowerState(uint64_t result)
{
  gSISystemOnBattery = result & 1;
  gSISystemInDarkWake = (result & 2) != 0;
  return result;
}

uint64_t _SISetTurboMode(uint64_t result)
{
  gTurboMode = result;
  return result;
}

__CFDictionary *_SICopyPropertyIDMap(uint64_t a1)
{
  int *v2;
  int field_id_limit;
  int v4;
  const __CFAllocator *v5;
  __CFDictionary *Mutable;
  int i;
  uint64_t field_name_for_id;
  const char *v9;
  CFNumberRef v10;
  CFStringRef v11;
  uint64_t valuePtr;

  if (!a1)
    return 0;
  v2 = *(int **)(a1 + 1184);
  if (!v2)
    return 0;
  field_id_limit = db_get_field_id_limit(v2);
  if (field_id_limit < 1)
    return 0;
  v4 = field_id_limit;
  v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], field_id_limit, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (v4 != 1)
  {
    for (i = 1; i != v4; ++i)
    {
      field_name_for_id = db_get_field_name_for_id(*(int **)(a1 + 1184), i);
      if (field_name_for_id)
      {
        v9 = (const char *)field_name_for_id;
        valuePtr = i | (*(unsigned __int8 *)(field_name_for_id - 2) << 28);
        v10 = CFNumberCreate(v5, kCFNumberSInt64Type, &valuePtr);
        v11 = CFStringCreateWithCString(v5, v9, 0x8000100u);
        CFDictionaryAddValue(Mutable, v10, v11);
        CFRelease(v11);
        CFRelease(v10);
      }
    }
  }
  return Mutable;
}

uint64_t _SITermIndexIterate(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t result;
  unint64_t v6;
  int v7;
  _DWORD v8[2];
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD v12[2605];

  v1 = MEMORY[0x1E0C80A78](a1);
  v3 = v2;
  v12[2604] = *MEMORY[0x1E0C80C00];
  result = GetContentIndex(v1, v4);
  if (result)
  {
    v6 = result + 88;
    v7 = *(_DWORD *)(result + 4664);
    v8[0] = 0;
    v9 = result + 4960;
    v8[1] = v7;
    v10 = result + 9672;
    v11 = v3;
    bzero(v12, 0x5160uLL);
    return _dumpTrie(v6, 0, v8, v12, (uint64_t)iterateTermsCallback, (uint64_t)v8);
  }
  return result;
}

uint64_t GetContentIndex(uint64_t a1, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  uint64_t v7;
  BOOL v8;

  v2 = 0;
  if (a1 && (a2 & 0x8000000000000000) == 0)
  {
    v3 = *(_QWORD *)(a1 + 1392);
    if (v3)
    {
      v4 = *(unsigned int *)(v3 + 8);
      if ((_DWORD)v4)
      {
        v5 = a2 >= v4;
        v6 = a2 - v4;
        if (v5)
        {
          a2 = v6;
        }
        else
        {
          v2 = *(_QWORD *)(*(_QWORD *)v3 + 8 * a2);
          if (v2)
            return v2;
        }
      }
    }
    v2 = *(_QWORD *)(a1 + 1384);
    if (v2)
    {
      v7 = *(unsigned int *)(v2 + 8);
      if ((_DWORD)v7)
        v8 = (uint64_t)a2 < v7;
      else
        v8 = 0;
      if (v8)
        return *(_QWORD *)(*(_QWORD *)v2 + 8 * a2);
      else
        return 0;
    }
  }
  return v2;
}

uint64_t _SIReverseStoreIterate(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  unsigned int v4;
  int v5;
  unint64_t v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  void (*v12)(_QWORD);
  int v13;
  NSObject *v14;
  uint64_t v15;
  uint64_t v16;
  void (*v17)(_QWORD);
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  uint8_t buf[4];
  const char *v23;
  __int16 v24;
  int v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)(result + 6624))
  {
    v3 = result;
    do
    {
      v4 = __ldxr(exceptionSequenceNum);
      v5 = v4 + 1;
    }
    while (__stxr(v4 + 1, exceptionSequenceNum));
    v6 = setThreadIdAndInfo(-1, sAssertExceptionCallbacks, 0, 0, v5);
    v20 = HIDWORD(v6);
    v21 = v6;
    v18 = v8;
    v19 = v7;
    v9 = *(_QWORD *)&threadData[18 * v6 + 2];
    v10 = v9 + 320 * HIDWORD(v6);
    v11 = *(_DWORD *)(v10 + 312);
    v12 = *(void (**)(_QWORD))(v10 + 224);
    if (v12)
      v12(*(_QWORD *)(v9 + 320 * HIDWORD(v6) + 288));
    if (_setjmp((int *)v10))
    {
      v13 = *__error();
      v14 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        v23 = "_SIReverseStoreIterate";
        v24 = 1024;
        v25 = 21411;
        _os_log_error_impl(&dword_1B8270000, v14, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
      }
      *__error() = v13;
      *(_DWORD *)(v10 + 312) = v11;
      CIOnThreadCleanUpReset(v18);
      dropThreadId(v21, 1, v5);
      return CICleanUpReset(v21, v19);
    }
    else
    {
      _reverseStoreIterate(*(_QWORD *)(v3 + 6624), a2);
      v15 = *(_QWORD *)&threadData[18 * v21 + 2];
      v16 = v15 + 320 * v20;
      *(_DWORD *)(v16 + 312) = v11;
      v17 = *(void (**)(_QWORD))(v16 + 232);
      if (v17)
        v17(*(_QWORD *)(v15 + 320 * v20 + 288));
      return dropThreadId(v21, 0, v5);
    }
  }
  return result;
}

uint64_t _SIDirectoryStoreIterate(uint64_t a1, unint64_t a2)
{
  uint64_t result;
  uint64_t v3;
  unsigned int v4;
  int v5;
  unint64_t v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  void (*v12)(_QWORD);
  int v13;
  NSObject *v14;
  uint64_t v15;
  uint64_t v16;
  void (*v17)(_QWORD);
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  uint8_t buf[4];
  const char *v23;
  __int16 v24;
  int v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  result = GetContentIndex(a1, a2);
  if (result)
  {
    v3 = *(_QWORD *)(result + 4904);
    if (v3)
    {
      do
      {
        v4 = __ldxr(exceptionSequenceNum);
        v5 = v4 + 1;
      }
      while (__stxr(v4 + 1, exceptionSequenceNum));
      v6 = setThreadIdAndInfo(-1, sAssertExceptionCallbacks, 0, 0, v5);
      v20 = HIDWORD(v6);
      v21 = v6;
      v18 = v8;
      v19 = v7;
      v9 = *(_QWORD *)&threadData[18 * v6 + 2];
      v10 = v9 + 320 * HIDWORD(v6);
      v11 = *(_DWORD *)(v10 + 312);
      v12 = *(void (**)(_QWORD))(v10 + 224);
      if (v12)
        v12(*(_QWORD *)(v9 + 320 * HIDWORD(v6) + 288));
      if (_setjmp((int *)v10))
      {
        v13 = *__error();
        v14 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315394;
          v23 = "_SIDirectoryStoreIterate";
          v24 = 1024;
          v25 = 21429;
          _os_log_error_impl(&dword_1B8270000, v14, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
        }
        *__error() = v13;
        *(_DWORD *)(v10 + 312) = v11;
        CIOnThreadCleanUpReset(v18);
        dropThreadId(v21, 1, v5);
        return CICleanUpReset(v21, v19);
      }
      else
      {
        dumpDirectoryStore(v3);
        v15 = *(_QWORD *)&threadData[18 * v21 + 2];
        v16 = v15 + 320 * v20;
        *(_DWORD *)(v16 + 312) = v11;
        v17 = *(void (**)(_QWORD))(v16 + 232);
        if (v17)
          v17(*(_QWORD *)(v15 + 320 * v20 + 288));
        return dropThreadId(v21, 0, v5);
      }
    }
  }
  return result;
}

uint64_t _SIGetIndexCount(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  if (result)
  {
    v1 = result;
    v2 = *(_QWORD *)(result + 1392);
    if (v2)
      result = *(unsigned int *)(v2 + 8);
    else
      result = 0;
    v3 = *(_QWORD *)(v1 + 1384);
    if (v3)
      result += *(unsigned int *)(v3 + 8);
  }
  return result;
}

unint64_t _SIGetMissingParentOID(unint64_t result)
{
  unint64_t v1;
  unint64_t v2;
  unint64_t v3;
  unsigned int v4;
  int v5;
  unint64_t v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  void (*v12)(_QWORD);
  int v13;
  NSObject *v14;
  unint64_t cs_orphan_oid;
  uint64_t v17;
  uint64_t v18;
  void (*v19)(_QWORD);
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  _BYTE buf[12];
  __int16 v25;
  int v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  if (result)
  {
    v1 = result;
    if (*(_BYTE *)(result + 2072))
    {
      v2 = atomic_load((unint64_t *)(result + 2080));
      result = v2;
      if (!v2)
      {
        v3 = si_compute_oid_for_identifier(CFSTR("com.apple.searchd"), CFSTR("com.apple.spotlight.missingparent"));
        makeThreadId();
        do
        {
          v4 = __ldxr(exceptionSequenceNum);
          v5 = v4 + 1;
        }
        while (__stxr(v4 + 1, exceptionSequenceNum));
        v6 = setThreadIdAndInfo(-1, sAssertExceptionCallbacks, 0, 0, v5);
        v22 = HIDWORD(v6);
        v23 = v6;
        v20 = v8;
        v21 = v7;
        v9 = *(_QWORD *)&threadData[18 * v6 + 2];
        v10 = v9 + 320 * HIDWORD(v6);
        v11 = *(_DWORD *)(v10 + 312);
        v12 = *(void (**)(_QWORD))(v10 + 224);
        if (v12)
          v12(*(_QWORD *)(v9 + 320 * HIDWORD(v6) + 288));
        if (_setjmp((int *)v10))
        {
          v13 = *__error();
          v14 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315394;
            *(_QWORD *)&buf[4] = "_SIGetMissingParentOID";
            v25 = 1024;
            v26 = 21465;
            _os_log_error_impl(&dword_1B8270000, v14, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
          }
          *__error() = v13;
          *(_DWORD *)(v10 + 312) = v11;
          CIOnThreadCleanUpReset(v20);
          dropThreadId(v23, 1, v5);
          CICleanUpReset(v23, v21);
          return 0;
        }
        else
        {
          cs_orphan_oid = 0;
          *(_QWORD *)buf = 0;
          if (!db_get_obj_callback(*(int **)(v1 + 1184), v3, (void **)buf, 1, *(_QWORD *)(v1 + 2368), 0))
          {
            free(*(void **)buf);
            cs_orphan_oid = si_get_cs_orphan_oid(v1);
          }
          v17 = *(_QWORD *)&threadData[18 * v23 + 2];
          v18 = v17 + 320 * v22;
          *(_DWORD *)(v18 + 312) = v11;
          v19 = *(void (**)(_QWORD))(v18 + 232);
          if (v19)
            v19(*(_QWORD *)(v17 + 320 * v22 + 288));
          dropThreadId(v23, 0, v5);
          return cs_orphan_oid;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t si_compute_oid_for_identifier(const __CFString *a1, const __CFString *a2)
{
  char *v4;
  char *v5;
  int v6;
  uint64_t v7;
  uint64_t v9;
  char v10;
  uint64_t v11;
  char v12;
  _OWORD v13[8];
  char v14[1024];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  bzero(v14, 0x400uLL);
  v12 = 0;
  v11 = 0;
  if (a2)
    v4 = fasterUTF8String(a2, &v11, v14, 1024, &v12);
  else
    v4 = "";
  memset(v13, 0, sizeof(v13));
  v10 = 0;
  v9 = 0;
  if (a1)
  {
    v5 = fasterUTF8String(a1, &v9, (char *)v13, 128, &v10);
    v6 = v9;
  }
  else
  {
    v6 = 0;
    v5 = "";
  }
  v7 = si_compute_oid_for_identifier_bundle_id(v4, v11, (uint64_t)v5, v6);
  if (v12)
    free(v4);
  if (v10)
    free(v5);
  return v7;
}

__CFString *_SISchedulerCopyDump(_QWORD *a1)
{
  __CFString *Mutable;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  uint64_t i;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t block;
  uint64_t v15;
  void *v16;
  void *v17;
  uint64_t *v18;
  __CFString *v19;
  __CFString *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  uint64_t *v27;
  uint64_t v28;
  int v29;

  if (!a1)
    return 0;
  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0);
  CFStringAppend(Mutable, CFSTR("Scheduler state:\n"));
  CFStringAppend(Mutable, CFSTR("<<<<<<<<\n"));
  v3 = 0;
  v4 = MEMORY[0x1E0C809B0];
  do
  {
    v5 = a1[v3 + 108];
    if (v5)
    {
      v6 = *(NSObject **)(v5 + 32);
      block = v4;
      v15 = 0x40000000;
      v16 = __si_scheduler_dump_block_invoke;
      v17 = &__block_descriptor_tmp_36;
      v18 = (uint64_t *)v5;
      v19 = Mutable;
      dispatch_sync(v6, &block);
    }
    ++v3;
  }
  while (v3 != 18);
  for (i = 0; i != 20; ++i)
    si_workqueue_dump((uint64_t *)a1[i + 126], Mutable);
  CFStringAppend(Mutable, CFSTR(">>>>>>>>\n"));
  v8 = a1[174];
  v9 = a1[173];
  v10 = a1[148];
  CFStringAppend(Mutable, CFSTR("===== VectorIndex begin =====\n"));
  v26 = 0;
  v27 = &v26;
  v28 = 0x2000000000;
  v29 = 0;
  v22 = 0;
  v23 = &v22;
  v24 = 0x2000000000;
  v25 = 0;
  block = v4;
  v15 = 0x40000000;
  v16 = __ContentIndexListDumpVectorIndex_block_invoke;
  v17 = &unk_1E6E35DC0;
  v20 = Mutable;
  v21 = v10;
  v18 = &v26;
  v19 = (__CFString *)&v22;
  if (v8 && *(_DWORD *)(v8 + 8))
  {
    v11 = 0;
    while (((unsigned int (*)(uint64_t *, _QWORD, _QWORD))v16)(&block, *(_QWORD *)(*(_QWORD *)v8 + 8 * v11), 0))
    {
      if (++v11 >= (unint64_t)*(unsigned int *)(v8 + 8))
        goto LABEL_13;
    }
  }
  else
  {
LABEL_13:
    if (v9 && *(_DWORD *)(v9 + 8))
    {
      v12 = 0;
      do
      {
        if (!((unsigned int (*)(uint64_t *, _QWORD, uint64_t))v16)(&block, *(_QWORD *)(*(_QWORD *)v9 + 8 * v12), 1))break;
        ++v12;
      }
      while (v12 < *(unsigned int *)(v9 + 8));
    }
  }
  CFStringAppendFormat(Mutable, 0, CFSTR("===== VectorIndex Total %u vectors in %u generations =====\n"), *((unsigned int *)v27 + 6), *((unsigned int *)v23 + 6), block, v15);
  _Block_object_dispose(&v22, 8);
  _Block_object_dispose(&v26, 8);
  return Mutable;
}

void _SIIssueSchedulerDump(_QWORD *a1)
{
  __CFString *v1;
  int v2;
  NSObject *v3;
  int v4;
  const char *v5;
  __int16 v6;
  int v7;
  __int16 v8;
  __CFString *v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v1 = _SISchedulerCopyDump(a1);
    v2 = *__error();
    v3 = _SILogForLogForCategory(3);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      v4 = 136315650;
      v5 = "_SIIssueSchedulerDump";
      v6 = 1024;
      v7 = 21711;
      v8 = 2112;
      v9 = v1;
      _os_log_error_impl(&dword_1B8270000, v3, OS_LOG_TYPE_ERROR, "%s:%d: %@", (uint8_t *)&v4, 0x1Cu);
    }
    *__error() = v2;
    CFRelease(v1);
  }
}

uint64_t _SIIssueLiveQueryDump(uint64_t a1)
{
  if (a1)
    return si_dump_livequeries(a1);
  return a1;
}

uint64_t _SIMinimizeDiskSpace(uint64_t a1)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  _DWORD *v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;

  if (!a1)
    return 0;
  pthread_mutex_lock(&mergeMutex);
  v2 = *(unsigned __int8 *)(a1 + 2434);
  v3 = *(_DWORD *)(a1 + 2428);
  *(_DWORD *)(a1 + 2428) = v3 + 1;
  if ((_DWORD)v2)
  {
    do
      pthread_cond_wait(&mergeCond, &mergeMutex);
    while (*(_BYTE *)(a1 + 2434));
    --*(_DWORD *)(a1 + 2428);
    pthread_mutex_unlock(&mergeMutex);
    return v2;
  }
  *(_DWORD *)(a1 + 2428) = v3;
  pthread_mutex_unlock(&mergeMutex);
  if (!*(_QWORD *)(a1 + 1384))
    return 0;
  v4 = *(_QWORD *)(a1 + 944);
  if (!v4)
    return 0;
  si_scheduler_suspend(v4);
  v5 = *(_QWORD *)(a1 + 1384);
  v6 = *(unsigned int *)(v5 + 8);
  if ((int)v6 < 1)
    goto LABEL_20;
  v7 = 0;
  v8 = 0;
  v9 = -1;
  do
  {
    v10 = v6 - 1;
    v11 = *(_DWORD **)(*(_QWORD *)v5 + 8 * (v6 - 1));
    LODWORD(v12) = v11[15];
    if (v12 >= 2)
      v12 = v12;
    else
      v12 = 0;
    v7 += v12;
    if ((int)v11[11] <= 1)
    {
      v13 = v6 - 1;
      v14 = atomic_load(v11 + 3);
      v8 += v14;
      if (v7 < 2 * v8)
        v9 = v13;
    }
    v6 = v10;
  }
  while ((unint64_t)(v10 + 1) > 1);
  if (v9 < 1)
  {
LABEL_20:
    si_scheduler_resume(*(_QWORD *)(a1 + 944), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 21759);
  }
  else
  {
    v15 = *(_QWORD *)(*(_QWORD *)v5 + 8 * v9);
    si_scheduler_resume(*(_QWORD *)(a1 + 944), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 21754);
    si_recycleForBadIndex(a1, v15, (uint64_t)"low disk space");
    return 0xFFFFFFFFLL;
  }
  return v2;
}

void _SISetMeEmailAddresses(CFSetRef theSet)
{
  CFSetRef Copy;
  const void *v2;

  Copy = CFSetCreateCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], theSet);
  os_unfair_lock_lock(&sSIMeEmailAddressesLock);
  v2 = (const void *)sSIMeEmailAddresses;
  sSIMeEmailAddresses = (uint64_t)Copy;
  os_unfair_lock_unlock(&sSIMeEmailAddressesLock);
  if (v2)
    CFRelease(v2);
}

void _SISetKnownContactEmailMapping(CFDictionaryRef theDict)
{
  CFMutableDictionaryRef MutableCopy;
  const void *v2;

  if (theDict)
    MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, theDict);
  else
    MutableCopy = 0;
  os_unfair_lock_lock((os_unfair_lock_t)&sEmailAddressMappingLock);
  v2 = (const void *)sKnownEmailAdresses;
  sKnownEmailAdresses = (uint64_t)MutableCopy;
  os_unfair_lock_unlock((os_unfair_lock_t)&sEmailAddressMappingLock);
  if (v2)
    CFRelease(v2);
}

void _SISetKnownContactCounts(CFDictionaryRef theDict)
{
  CFMutableDictionaryRef MutableCopy;
  const void *v2;

  if (theDict)
    MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, theDict);
  else
    MutableCopy = 0;
  os_unfair_lock_lock((os_unfair_lock_t)&sContactCountsLock);
  v2 = (const void *)sKnownContactCounts;
  sKnownContactCounts = (uint64_t)MutableCopy;
  os_unfair_lock_unlock((os_unfair_lock_t)&sContactCountsLock);
  if (v2)
    CFRelease(v2);
}

__CFArray *_SICreateContactMailCounts(const void *a1)
{
  __CFArray *Mutable;
  const void *Value;
  const void *v5;
  const __CFArray *v6;
  const __CFArray *v7;

  Mutable = 0;
  if (a1)
  {
    if (sKnownEmailAdresses && sKnownContactCounts != 0)
    {
      os_unfair_lock_lock((os_unfair_lock_t)&sEmailAddressMappingLock);
      Value = CFDictionaryGetValue((CFDictionaryRef)sKnownEmailAdresses, a1);
      if (Value)
      {
        v5 = Value;
        CFRetain(Value);
        os_unfair_lock_unlock((os_unfair_lock_t)&sEmailAddressMappingLock);
        os_unfair_lock_lock((os_unfair_lock_t)&sContactCountsLock);
        v6 = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)sKnownContactCounts, v5);
        v7 = v6;
        if (v6)
          CFRetain(v6);
        os_unfair_lock_unlock((os_unfair_lock_t)&sContactCountsLock);
        Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 8, MEMORY[0x1E0C9B378]);
        initCountsArray_block_invoke(Mutable, 8);
        readFromAllCountsArray_block_invoke_3(v7, Mutable, 8, 8);
        CFRelease(v5);
        if (v7)
          CFRelease(v7);
      }
      else
      {
        os_unfair_lock_unlock((os_unfair_lock_t)&sEmailAddressMappingLock);
        return 0;
      }
    }
  }
  return Mutable;
}

__CFArray *_SICreateContactSMSCounts(const void *a1)
{
  __CFArray *Mutable;
  const __CFArray *Value;
  const __CFArray *v4;

  Mutable = 0;
  if (a1 && sKnownContactCounts)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&sContactCountsLock);
    Value = (const __CFArray *)CFDictionaryGetValue((CFDictionaryRef)sKnownContactCounts, a1);
    v4 = Value;
    if (Value)
      CFRetain(Value);
    os_unfair_lock_unlock((os_unfair_lock_t)&sContactCountsLock);
    Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 8, MEMORY[0x1E0C9B378]);
    initCountsArray_block_invoke(Mutable, 8);
    readFromAllCountsArray_block_invoke_3(v4, Mutable, 16, 8);
    if (v4)
      CFRelease(v4);
  }
  return Mutable;
}

void *_SISetCoreSpotlightCopyBundleRemapCallback(void *result)
{
  sSICoreSpotlightCopyBundleRemapCallback = result;
  return result;
}

uint64_t _SISetContactsIndex(uint64_t result)
{
  sContactsIndex = result;
  return result;
}

uint64_t SISetAccumulatedWorkBoundaryCrossCallback(uint64_t result, uint64_t (*a2)(uint64_t, double), uint64_t a3, double a4, double a5)
{
  double v5;

  *(_QWORD *)(result + 2168) = a3;
  *(double *)(result + 2176) = a4;
  *(double *)(result + 2184) = a5;
  *(_QWORD *)(result + 2160) = a2;
  if (a2)
  {
    v5 = *(double *)(result + 2152);
    if (v5 >= a4 || v5 > a5)
      return a2(a3, v5);
  }
  return result;
}

uint64_t SIMoveDirectories(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  char *v15;
  char *v16;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  NSObject *v21;
  int v22;
  NSObject *v23;
  uint8_t v24[16];
  uint8_t buf[16];

  if (a1 && *(_QWORD *)(a1 + 6624) && *(_QWORD *)(a1 + 1048))
  {
    if ((a3 & 7) != 0)
    {
      v15 = __si_assert_copy_extra_521(-1);
      v16 = v15;
      v17 = "";
      if (v15)
        v17 = v15;
      __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 29341, "(count & 0x7) == 0", v17);
      free(v16);
      if (__valid_fs(-1))
        v18 = 2989;
      else
        v18 = 3072;
      *(_DWORD *)v18 = -559038737;
      abort();
    }
    if (dword_1EF19FC9C >= 5)
    {
      v19 = a3;
      v20 = *__error();
      v21 = _SILogForLogForCategory(4);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1B8270000, v21, OS_LOG_TYPE_DEFAULT, "Do directory move.", buf, 2u);
      }
      *__error() = v20;
      a3 = v19;
    }
    v5 = 0;
    v6 = 0;
    v7 = a3 / 8;
    while (v7 > v6)
    {
      v8 = a2 + 8 * v6;
      if (*(_QWORD *)v8)
        ++v5;
      v6 += *(_DWORD *)(v8 + 8) + 2;
      if (v7 < v6)
        return 0;
    }
    if (v5)
    {
      v9 = (uint64_t *)malloc_type_calloc(1uLL, 8 * v5 + 32, 0x8754149AuLL);
      v10 = (uint64_t)v9;
      v11 = 0;
      v9[1] = a1;
      while (v7 > v11)
      {
        v12 = *(_QWORD *)(a2 + 8 * v11);
        if (v12)
        {
          v13 = v9[2];
          v9[2] = v13 + 1;
          v9[v13 + 4] = v12;
        }
        v11 += *(_QWORD *)(a2 + 8 * (v11 + 1)) + 2;
        if (v7 < v11)
        {
          free(v9);
          return 0;
        }
      }
      journalMoves(a1, v9[2], v9 + 4, 0);
      si_enqueue_barrier(*(_QWORD *)(a1 + 1048), (uint64_t)moveDirectories, v10);
    }
    if (dword_1EF19FC9C >= 5)
    {
      v22 = *__error();
      v23 = _SILogForLogForCategory(4);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)v24 = 0;
        _os_log_impl(&dword_1B8270000, v23, OS_LOG_TYPE_DEFAULT, "Leave.", v24, 2u);
      }
      *__error() = v22;
    }
  }
  return 1;
}

void journalMoves(uint64_t a1, uint64_t a2, uint64_t *a3, int a4)
{
  int v8;
  _DWORD *v9;
  void *v10;
  int v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  pthread_mutex_t *v15;
  char *JournalFd;
  uint64_t v17;
  int v18;
  int v19;
  NSObject *v20;
  os_log_type_t v21;
  _DWORD v22[2];
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v8 = 8 * a2;
    v9 = malloc_type_malloc(8 * a2 + 12, 0x825C498EuLL);
    v10 = v9;
    if (a4)
      v11 = -265421075;
    else
      v11 = -266469651;
    *v9 = v11;
    v12 = v9 + 3;
    if (a2 >= 1)
    {
      v13 = a2;
      do
      {
        v14 = *a3++;
        *v12++ = v14;
        --v13;
      }
      while (v13);
    }
    v9[1] = v8;
    v9[2] = a2;
    v15 = (pthread_mutex_t *)(a1 + 1632);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 1632));
    JournalFd = getJournalFd(a1, 0, 0);
    v17 = fd_write((uint64_t)JournalFd, (uint64_t)v10, (v8 & 0xFFFFFFF8) + 12);
    pthread_mutex_unlock(v15);
    if (v17 == -1)
    {
      v18 = *__error();
      v19 = *__error();
      v20 = _SILogForLogForCategory(4);
      v21 = 2 * (dword_1EF19FC9C < 4);
      if (os_log_type_enabled(v20, v21))
      {
        v22[0] = 67109120;
        v22[1] = v18;
        _os_log_impl(&dword_1B8270000, v20, v21, "Error writing to log file: %d", (uint8_t *)v22, 8u);
      }
      *__error() = v19;
    }
    free(v10);
  }
}

uint64_t SIMoveFiles(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  char *v17;
  const char *v18;
  uint64_t v19;
  char *v20;
  char *v21;
  const char *v22;
  uint64_t v23;
  int v24;
  NSObject *v25;
  int v26;
  NSObject *v27;
  uint8_t v28[16];
  uint8_t buf[16];

  if (*(_QWORD *)(a1 + 6624) && *(_QWORD *)(a1 + 1048))
  {
    if ((a3 & 7) != 0)
    {
      v20 = __si_assert_copy_extra_521(-1);
      v21 = v20;
      v22 = "";
      if (v20)
        v22 = v20;
      __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 29391, "(count & 0x7) == 0", v22);
      free(v21);
      if (__valid_fs(-1))
        v23 = 2989;
      else
        v23 = 3072;
      *(_DWORD *)v23 = -559038737;
      abort();
    }
    if (dword_1EF19FC9C >= 5)
    {
      v24 = *__error();
      v25 = _SILogForLogForCategory(4);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1B8270000, v25, OS_LOG_TYPE_DEFAULT, "Do directory move.", buf, 2u);
      }
      *__error() = v24;
    }
    v6 = 0;
    v7 = 0;
    v8 = a3 / 8;
    while (v8 > v7)
    {
      v9 = a2 + 8 * v7;
      if (*(_QWORD *)v9)
        ++v6;
      v7 += *(_DWORD *)(v9 + 8) + 2;
      if (v8 < v7)
        return 0;
    }
    if (v6)
    {
      v11 = malloc_type_calloc(1uLL, 8 * v6 + 32, 0x6ABABD6AuLL);
      v12 = (uint64_t)v11;
      v13 = 0;
      v11[1] = a1;
      while (v8 > v13)
      {
        v14 = *(_QWORD *)(a2 + 8 * v13);
        if (v14)
        {
          v15 = v11[2];
          v11[2] = v15 + 1;
          v11[v15 + 4] = v14;
        }
        v13 += *(_QWORD *)(a2 + 8 * (v13 + 1)) + 2;
        if (v8 < v13)
        {
          v16 = __si_assert_copy_extra_521(-1);
          v17 = v16;
          v18 = "";
          if (v16)
            v18 = v16;
          __message_assert("%s:%u: failed assertion '%s' %s ", "SpotlightIndex.c", 29418, "i<=count/8", v18);
          free(v17);
          if (__valid_fs(-1))
            v19 = 2989;
          else
            v19 = 3072;
          *(_DWORD *)v19 = -559038737;
          abort();
        }
      }
      journalMoves(a1, v11[2], v11 + 4, 1);
      si_enqueue_barrier(*(_QWORD *)(a1 + 1048), (uint64_t)moveFiles, v12);
    }
    if (dword_1EF19FC9C >= 5)
    {
      v26 = *__error();
      v27 = _SILogForLogForCategory(4);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)v28 = 0;
        _os_log_impl(&dword_1B8270000, v27, OS_LOG_TYPE_DEFAULT, "Leave.", v28, 2u);
      }
      *__error() = v26;
    }
  }
  return 1;
}

void moveFiles(_QWORD *a1, int a2)
{
  double Current;

  if (!a2)
  {
    Current = CFAbsoluteTimeGetCurrent();
    innerMoveFiles((unint64_t)a1);
    bumpWorkTime(a1[1], Current);
  }
  free(a1);
}

BOOL SISupportsFastScoping(uint64_t a1)
{
  return *(_QWORD *)(a1 + 1184) && *(_QWORD *)(a1 + 6624) != 0;
}

CFDictionaryRef __isEntitledForAttribute_block_invoke()
{
  CFDictionaryRef result;
  void *values[60];
  const void *__dst[61];

  __dst[60] = *(const void **)MEMORY[0x1E0C80C00];
  memcpy(__dst, off_1E6E2CF78, 0x1E0uLL);
  memcpy(values, &unk_1B862C690, sizeof(values));
  result = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], __dst, (const void **)values, 60, &kCStringDictionaryKeyCallBacks, &kIntDictionaryValueCallBacks);
  isEntitledForAttribute_attributeEntitlementMapping = (uint64_t)result;
  return result;
}

__CFArray *SICopyCorrections(uint64_t a1, const __CFString *a2)
{
  CFMutableStringRef MutableCopy;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  int v11;
  unint64_t v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  void (*v18)(_QWORD);
  int v19;
  NSObject *v20;
  __CFArray *v21;
  int v23;
  NSObject *v24;
  _BOOL8 v25;
  size_t v26;
  unsigned int v27;
  __CFArray *Mutable;
  unsigned int v29;
  uint64_t data;
  CFIndex v31;
  unsigned int *v32;
  unsigned int *v33;
  CFIndex v34;
  unsigned int *v35;
  const char *v36;
  CFStringRef v37;
  CFStringRef v38;
  uint64_t v39;
  uint64_t v40;
  void (*v41)(_QWORD);
  unsigned int v42;
  unsigned int v43;
  unsigned int v44;
  unsigned int v45;
  _QWORD v46[2];
  char v47;
  uint8_t v48[4];
  const char *v49;
  __int16 v50;
  int v51;
  uint64_t v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  uint8_t buf[4];
  unsigned __int16 v61[514];
  uint64_t v62;

  v62 = *MEMORY[0x1E0C80C00];
  makeThreadId();
  if (a1)
  {
    bzero(buf, 0x404uLL);
    MutableCopy = CFStringCreateMutableCopy(0, 1024, a2);
    CFStringNormalize(MutableCopy, kCFStringNormalizationFormC);
    CFStringLowercase(MutableCopy, 0);
    v47 = 0;
    v59 = 0u;
    v58 = 0u;
    v57 = 0u;
    v56 = 0u;
    v54 = 0u;
    v55 = 0u;
    v53 = 0u;
    v46[0] = 5;
    v46[1] = &v52;
    v52 = *(_QWORD *)(a1 + 288);
    v5 = *(unsigned int *)(a1 + 312);
    *(_QWORD *)&v54 = *(_QWORD *)(a1 + 320);
    *((_QWORD *)&v54 + 1) = v5;
    *(_QWORD *)&v55 = *(_QWORD *)(a1 + 304);
    v6 = *(unsigned int *)(a1 + 348);
    v7 = *(_QWORD *)(a1 + 336);
    *((_QWORD *)&v55 + 1) = *(_QWORD *)(a1 + 352);
    *(_QWORD *)&v56 = v6;
    v8 = *(_QWORD *)(a1 + 224);
    v9 = *(unsigned int *)(a1 + 232);
    *((_QWORD *)&v56 + 1) = v7;
    *(_QWORD *)&v57 = v8;
    *((_QWORD *)&v57 + 1) = v9;
    *(_QWORD *)&v58 = *(_QWORD *)(a1 + 240);
    *((_QWORD *)&v58 + 1) = -1;
    v53 = 0uLL;
    do
    {
      v10 = __ldxr(exceptionSequenceNum);
      v11 = v10 + 1;
    }
    while (__stxr(v10 + 1, exceptionSequenceNum));
    v12 = setThreadIdAndInfo(-1, (__int128 *)sMappingExceptionCallbacks, (uint64_t)v46, 0, v11);
    v44 = HIDWORD(v12);
    v45 = v12;
    v42 = v14;
    v43 = v13;
    v15 = *(_QWORD *)&threadData[18 * v12 + 2];
    v16 = v15 + 320 * HIDWORD(v12);
    *(_BYTE *)(v16 + 216) = 0;
    v17 = *(_DWORD *)(v16 + 312);
    v18 = *(void (**)(_QWORD))(v16 + 224);
    if (v18)
      v18(*(_QWORD *)(v15 + 320 * HIDWORD(v12) + 288));
    if (_setjmp((int *)v16))
    {
      v19 = *__error();
      v20 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v48 = 136315394;
        v49 = "SICopyCorrections";
        v50 = 1024;
        v51 = 30235;
        _os_log_error_impl(&dword_1B8270000, v20, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", v48, 0x12u);
      }
      *__error() = v19;
      *(_DWORD *)(v16 + 312) = v17;
      CIOnThreadCleanUpReset(v42);
      dropThreadId(v45, 1, v11);
      CICleanUpReset(v45, v43);
    }
    else
    {
      if (CFStringGetCString(MutableCopy, (char *)v61, 1024, 0x8000100u)
        && (*(_DWORD *)buf = 0,
            v26 = strlen((const char *)v61),
            (v27 = data_map32_id_get_with_key_noextra(a1, v61, v26 + 1)) != 0))
      {
        Mutable = 0;
        v29 = *(_DWORD *)(data_map32_get_data(a1, v27, 0) - 4);
        if (v29)
        {
          Mutable = 0;
          data = data_map32_get_data(a1, v29, 0);
          v31 = *(unsigned int *)(data - 4);
          if ((v31 - 257) >= 0xFFFFFF00)
          {
            v32 = (unsigned int *)data;
            Mutable = CFArrayCreateMutable(0, v31, MEMORY[0x1E0C9B378]);
            v33 = v32;
            v34 = v31;
            do
            {
              v35 = v33 + 1;
              v36 = (const char *)data_map32_get_data(a1, *v33, 0);
              if (v36)
              {
                v37 = CFStringCreateWithCString(0, v36, 0x8000100u);
                if (v37)
                {
                  v38 = v37;
                  CFArrayAppendValue(Mutable, v37);
                  CFRelease(v38);
                }
              }
              v33 = v35;
              --v34;
            }
            while (v34);
            v47 = 1;
          }
        }
      }
      else
      {
        Mutable = 0;
      }
      v39 = *(_QWORD *)&threadData[18 * v45 + 2];
      v40 = v39 + 320 * v44;
      *(_DWORD *)(v40 + 312) = v17;
      v41 = *(void (**)(_QWORD))(v40 + 232);
      if (v41)
        v41(*(_QWORD *)(v39 + 320 * v44 + 288));
      dropThreadId(v45, 0, v11);
      if (Mutable)
      {
        if (v47)
        {
          v21 = Mutable;
          goto LABEL_11;
        }
        CFRelease(Mutable);
      }
    }
    v21 = 0;
LABEL_11:
    CFRelease(MutableCopy);
    return v21;
  }
  v23 = *__error();
  v24 = _SILogForLogForCategory(10);
  v25 = dword_1EF19FCB4 < 3;
  if (os_log_type_enabled(v24, (os_log_type_t)(dword_1EF19FCB4 < 3)))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1B8270000, v24, (os_log_type_t)v25, "*warn* invalid corrections commit", buf, 2u);
  }
  *__error() = v23;
  return 0;
}

void SICorrectionCommit(uint64_t a1)
{
  int v2;
  uint64_t v3;
  int v4;
  char *v5;
  const char *v6;
  size_t v7;
  char *v8;
  unsigned __int8 v9;
  char *v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  NSObject *v16;
  os_log_type_t v17;
  uint64_t v18;
  char *v19;
  __int128 *v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  unsigned __int8 v24;
  _QWORD *v25;
  unsigned int *v26;
  uint8_t v27[1024];
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v2 = *(unsigned __int8 *)(a1 + 438);
    if (!_data_map32_commit(a1, 0))
    {
      v3 = *(_QWORD *)(a1 + 240);
      if (v3)
      {
        v4 = *(_DWORD *)(v3 + 44);
        if (v4 != -1)
        {
          bzero(v27, 0x400uLL);
          v5 = fd_name(v3, (char *)v27, 0x400uLL);
          if (v5)
          {
            v6 = v5;
            v7 = strlen(v5);
            if (v7 >= 8)
            {
              v8 = (char *)&v6[v7 - 7];
              if (!strcmp(v8, ".header"))
              {
                strcpy(v8, ".map");
                v9 = v2 ? 3 : 0;
                v10 = (char *)fd_create_protected(v4, v6, 1538, v9);
                if (v10)
                {
                  v11 = v10;
                  v12 = (*(unsigned int *)(a1 + 344) + 103) & 0x1FFFFFFF8;
                  v13 = (*(unsigned int *)(a1 + 316) + v12 + 15) & 0x3FFFFFFF8;
                  v14 = (*(unsigned int *)(a1 + 296) + v13 + 15) & 0x7FFFFFFF8;
                  if (fd_truncate((uint64_t)v10, v14) || (v18 = fd_mmap((uint64_t)v11), v18 == -1))
                  {
                    _fd_unlink_with_origin((uint64_t)v11, 0);
                    fd_release(v11);
                  }
                  else
                  {
                    v19 = (char *)v18;
                    v20 = *(__int128 **)(a1 + 264);
                    v21 = *v20;
                    v22 = v20[1];
                    v23 = v20[2];
                    *(_QWORD *)(v18 + 48) = *((_QWORD *)v20 + 6);
                    *(_OWORD *)(v18 + 16) = v22;
                    *(_OWORD *)(v18 + 32) = v23;
                    *(_OWORD *)v18 = v21;
                    *(_DWORD *)(v18 + 56) = 13;
                    *(_DWORD *)(v18 + 60) = v14;
                    *(_DWORD *)(v18 + 64) = 88;
                    *(_DWORD *)(v18 + 68) = v12;
                    *(_DWORD *)(v18 + 72) = v13;
                    memcpy((void *)(v18 + 88), *(const void **)(a1 + 352), *(unsigned int *)(a1 + 344));
                    memcpy(&v19[v12], *(const void **)(a1 + 320), *(unsigned int *)(a1 + 316));
                    memcpy(&v19[v13], *(const void **)(a1 + 288), *(unsigned int *)(a1 + 296));
                    msync(v19, v14, 16);
                    munmap(v19, v14);
                    fd_release(v11);
                    free(*(void **)(a1 + 264));
                    *(_QWORD *)(a1 + 264) = 0;
                    _fd_unlink_with_origin(*(_QWORD *)(a1 + 240), 0);
                    fd_release(*(char **)(a1 + 240));
                    *(_QWORD *)(a1 + 240) = 0;
                    munmap(*(void **)(a1 + 352), *(unsigned int *)(a1 + 348));
                    *(_QWORD *)(a1 + 352) = -1;
                    _fd_unlink_with_origin(*(_QWORD *)(a1 + 336), 0);
                    fd_release(*(char **)(a1 + 336));
                    *(_QWORD *)(a1 + 336) = 0;
                    munmap(*(void **)(a1 + 320), *(unsigned int *)(a1 + 312));
                    *(_QWORD *)(a1 + 320) = -1;
                    _fd_unlink_with_origin(*(_QWORD *)(a1 + 304), 0);
                    fd_release(*(char **)(a1 + 304));
                    *(_QWORD *)(a1 + 304) = 0;
                    munmap(*(void **)(a1 + 288), *(unsigned int *)(a1 + 280));
                    *(_QWORD *)(a1 + 288) = -1;
                    _fd_unlink_with_origin(*(_QWORD *)(a1 + 272), 0);
                    fd_release(*(char **)(a1 + 272));
                    *(_QWORD *)(a1 + 272) = 0;
                    if (*(_BYTE *)(a1 + 438))
                      v24 = 3;
                    else
                      v24 = 0;
                    v25 = fd_create_protected(v4, v6, 1, v24);
                    *(_QWORD *)(a1 + 240) = v25;
                    v26 = (unsigned int *)fd_mmap((uint64_t)v25);
                    if (v26 != (unsigned int *)-1)
                    {
                      *(_QWORD *)(a1 + 224) = v26;
                      *(_QWORD *)(a1 + 264) = v26;
                      *(_QWORD *)(a1 + 352) = (char *)v26 + v26[16];
                      *(_QWORD *)(a1 + 320) = (char *)v26 + v26[17];
                      *(_QWORD *)(a1 + 288) = (char *)v26 + v26[18];
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  else
  {
    v15 = *__error();
    v16 = _SILogForLogForCategory(10);
    v17 = dword_1EF19FCB4 < 3;
    if (os_log_type_enabled(v16, (os_log_type_t)(dword_1EF19FCB4 < 3)))
    {
      *(_WORD *)v27 = 0;
      _os_log_impl(&dword_1B8270000, v16, v17, "*warn* invalid corrections commit", v27, 2u);
    }
    *__error() = v15;
  }
}

void SICorrectionDestory(uint64_t a1)
{
  if (a1)
    data_map32_destroy(a1);
}

uint64_t SICorrectionCreate(const __CFString *a1, int a2, int a3)
{
  int v6;
  __int128 v8;
  _BYTE v9[24];
  __int128 v10;
  int v11;
  int v12;
  char buffer[1032];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  bzero(buffer, 0x400uLL);
  if (!CFStringGetCString(a1, buffer, 1024, 0x8000100u))
    strcpy(buffer, "default_corrections");
  v8 = 0u;
  *(_OWORD *)v9 = 0u;
  if (a3)
    v6 = 9;
  else
    v6 = 10;
  v12 = (unsigned __int128)0 >> 96;
  LODWORD(v8) = a2;
  *((_QWORD *)&v8 + 1) = buffer;
  *(_DWORD *)v9 = 4;
  *(_DWORD *)&v9[4] = v6;
  *(_OWORD *)&v9[8] = 0uLL;
  v10 = 0uLL;
  v11 = 0;
  return data_map32_init_with_ctx((uint64_t)&v8);
}

void SIAddCorrection(uint64_t a1, CFStringRef theString, const __CFArray *a3)
{
  CFMutableStringRef MutableCopy;
  CFIndex Count;
  unsigned int v7;
  CFIndex v8;
  const __CFString *ValueAtIndex;
  int v10;
  NSObject *v11;
  os_log_type_t v12;
  size_t v13;
  int data_id;
  int v15;
  NSObject *v16;
  os_log_type_t v17;
  int v18;
  NSObject *v19;
  os_log_type_t v20;
  size_t v21;
  uint8_t v22[1040];
  uint8_t buf[4];
  CFMutableStringRef v24;
  int v25;
  char v26[1024];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    v15 = *__error();
    v16 = _SILogForLogForCategory(10);
    v17 = dword_1EF19FCB4 < 3;
    if (os_log_type_enabled(v16, (os_log_type_t)(dword_1EF19FCB4 < 3)))
    {
      *(_WORD *)v22 = 0;
      _os_log_impl(&dword_1B8270000, v16, v17, "*warn* no correction dict passed", v22, 2u);
    }
    *__error() = v15;
    return;
  }
  MutableCopy = CFStringCreateMutableCopy(0, 1024, theString);
  CFStringNormalize(MutableCopy, kCFStringNormalizationFormC);
  CFStringLowercase(MutableCopy, 0);
  bzero(v22, 0x404uLL);
  Count = CFArrayGetCount(a3);
  bzero(&v25, 0x404uLL);
  if (Count < 1)
  {
    v7 = 0;
    goto LABEL_20;
  }
  v7 = 0;
  v8 = 0;
  while (1)
  {
    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a3, v8);
    if (CFStringGetLength(ValueAtIndex) >= 1025)
    {
      v10 = *__error();
      v11 = _SILogForLogForCategory(10);
      v12 = dword_1EF19FCB4 < 3;
      if (os_log_type_enabled(v11, (os_log_type_t)(dword_1EF19FCB4 < 3)))
      {
        *(_DWORD *)buf = 138412290;
        v24 = MutableCopy;
        _os_log_impl(&dword_1B8270000, v11, v12, "*warn* exceeded max for %@", buf, 0xCu);
      }
      *__error() = v10;
      goto LABEL_11;
    }
    v25 = 0;
    if (CFStringGetCString(ValueAtIndex, v26, 1024, 0x8000100u))
      break;
LABEL_11:
    if (Count == ++v8)
      goto LABEL_20;
  }
  v13 = strlen(v26);
  data_id = _data_map32_get_data_id(a1, *(_DWORD *)(a1 + 220), (char *)&v25, v13 + 5, 1);
  if (v7 != 256)
  {
    *(_DWORD *)&v22[4 * v7++ + 4] = data_id;
    *(_DWORD *)v22 = v7;
    goto LABEL_11;
  }
  v18 = *__error();
  v19 = _SILogForLogForCategory(10);
  v20 = dword_1EF19FCB4 < 3;
  if (os_log_type_enabled(v19, (os_log_type_t)(dword_1EF19FCB4 < 3)))
  {
    *(_DWORD *)buf = 138412290;
    v24 = MutableCopy;
    _os_log_impl(&dword_1B8270000, v19, v20, "*warn* correctDict exceeded max for %@", buf, 0xCu);
  }
  *__error() = v18;
  v7 = 256;
LABEL_20:
  v25 = _data_map32_get_data_id(a1, *(_DWORD *)(a1 + 220), (char *)v22, 4 * v7 + 4, 1);
  CFStringGetCString(MutableCopy, v26, 1024, 0x8000100u);
  v21 = strlen(v26);
  _data_map32_get_data_id(a1, *(_DWORD *)(a1 + 220), (char *)&v25, v21 + 5, 1);
  CFRelease(MutableCopy);
}

uint64_t _SIGetLastUsedDate(int a1, char *path, _OWORD *a3)
{
  ssize_t v4;
  uint64_t result;
  __int128 v6;
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (!a3)
    goto LABEL_9;
  v6 = 0uLL;
  v7 = 0;
  if (a1 != -1)
  {
    v4 = fgetxattr(a1, "com.apple.lastuseddate#PS", &v6, 0x18uLL, 0, 0);
    if (v4 < 0)
      return 0xFFFFFFFFLL;
    goto LABEL_7;
  }
  if (!path)
  {
LABEL_9:
    *__error() = 22;
    return 0xFFFFFFFFLL;
  }
  v4 = getxattr(path, "com.apple.lastuseddate#PS", &v6, 0x18uLL, 0, 0);
  if ((v4 & 0x8000000000000000) == 0)
  {
LABEL_7:
    if (v4 == 16)
    {
      result = 0;
      *a3 = v6;
      return result;
    }
    goto LABEL_9;
  }
  return 0xFFFFFFFFLL;
}

uint64_t _SISetLastUsedDate(int a1, char *path, __int128 *a3)
{
  __int128 v4;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  if (!a3)
    goto LABEL_6;
  v4 = *a3;
  if (a1 != -1)
    return fsetxattr(a1, "com.apple.lastuseddate#PS", &v4, 0x10uLL, 0, 0);
  if (path)
    return setxattr(path, "com.apple.lastuseddate#PS", &v4, 0x10uLL, 0, 0);
LABEL_6:
  *__error() = 22;
  return 0xFFFFFFFFLL;
}

void *_SISetCoreSpotlightRelatedItemCallback(void *result)
{
  sCSRelatedItemCallback = result;
  return result;
}

DIR *_SITemporarilyChangeProtectionClass(uint64_t a1, uint64_t a2)
{
  return _SIChangeProtectionClassForFilesInDirectory(*(_DWORD *)(a1 + 32), a2);
}

uint64_t _SIPriority(uint64_t a1)
{
  return *(_DWORD *)(a1 + 60) & 1;
}

CFDictionaryRef _SIUserCopyUserFSCriteriaForQuery(char *a1)
{
  _QWORD *query_node_with_ann;
  _QWORD *v2;
  void *v3;
  void *v4;
  uint64_t v5;
  void *v6;
  CFIndex v7;
  void *v8;
  CFDictionaryRef v9;
  const void *v10;
  _QWORD v12[7];
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  char v24;
  void *values[3];
  void *keys;
  uint64_t v27;
  uint64_t (*v28)(uint64_t);
  void *v29;
  _QWORD *v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0;
  query_node_with_ann = db_make_query_node_with_ann(a1, 0);
  if (!query_node_with_ann)
    return 0;
  v2 = query_node_with_ann;
  v21 = 0;
  v22 = &v21;
  v23 = 0x2000000000;
  v24 = 1;
  v17 = 0;
  v18 = &v17;
  v19 = 0x2000000000;
  v20 = 0;
  v13 = 0;
  v14 = &v13;
  v15 = 0x2000000000;
  v3 = (void *)MEMORY[0x1E0C809B0];
  v16 = 0;
  v12[0] = MEMORY[0x1E0C809B0];
  v12[1] = 0x40000000;
  v12[2] = ___SIUserCopyUserFSCriteriaForQuery_block_invoke;
  v12[3] = &unk_1E6E2D188;
  v12[4] = &v21;
  v12[5] = &v13;
  v12[6] = &v17;
  keys = (void *)MEMORY[0x1E0C809B0];
  v27 = 0x40000000;
  v28 = __db_query_tree_apply_block_block_invoke;
  v29 = &unk_1E6E377F8;
  v30 = v12;
  db_query_tree_apply_block_with_meta(query_node_with_ann, (uint64_t)&keys, 0);
  if (*((_BYTE *)v22 + 24) && ((v4 = (void *)v14[3]) != 0 || v18[3]))
  {
    v5 = 0;
    keys = 0;
    v27 = 0;
    v28 = 0;
    memset(values, 0, sizeof(values));
    v6 = (void *)*MEMORY[0x1E0C9AE50];
    if (v4 == (void *)*MEMORY[0x1E0C9AE50])
    {
      keys = CFSTR("kMDItemIsTrashed");
      values[0] = v4;
      v5 = 1;
    }
    *(&keys + v5) = CFSTR("LISearchObjTypeReturnAll");
    v7 = v5 + 1;
    values[v5] = v6;
    v8 = (void *)v18[3];
    if (v8)
    {
      *(&keys + v7) = CFSTR("LISearchFileNameContains");
      values[v7] = v8;
      v7 = v5 | 2;
    }
    v9 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)&keys, (const void **)values, v7, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  }
  else
  {
    v9 = 0;
  }
  v10 = (const void *)v18[3];
  if (v10)
    CFRelease(v10);
  keys = v3;
  v27 = 0x40000000;
  v28 = __db_query_tree_apply_block_block_invoke;
  v29 = &unk_1E6E377F8;
  v30 = &__block_literal_global_143;
  db_query_tree_apply_block_with_meta(v2, (uint64_t)&keys, 0);
  _Block_object_dispose(&v13, 8);
  _Block_object_dispose(&v17, 8);
  _Block_object_dispose(&v21, 8);
  return v9;
}

uint64_t SIIndexIsLowLatency(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 6586) >> 2) & 1;
}

void SIFixupPaths(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  _QWORD *v6;

  if (*(_QWORD *)(a1 + 1056))
  {
    v6 = malloc_type_malloc(0x10uLL, 0x60040FAFB2B2FuLL);
    *v6 = a1;
    v6[1] = RLEOIDArrayCreate((const __CFAllocator *)*MEMORY[0x1E0C9AE00], a2, a3);
    si_enqueue_work(*(_QWORD *)(a1 + 1056), (uint64_t)fixupOrphanItems, (uint64_t)v6);
  }
}

void SIFetchTopKTerms(uint64_t a1, void (**a2)(_QWORD, _QWORD))
{
  _QWORD *v4;

  if (a1 && *(_QWORD *)(a1 + 1080))
  {
    v4 = malloc_type_malloc(0x10uLL, 0xA0040AFF93C70uLL);
    *v4 = a1;
    v4[1] = _Block_copy(a2);
    si_enqueue_work(*(_QWORD *)(a1 + 1080), (uint64_t)get_topK, (uint64_t)v4);
  }
  else
  {
    a2[2](a2, 0);
  }
}

void get_topK(const void **a1, int a2)
{
  unsigned int v3;
  int v4;
  unint64_t v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  void (*v11)(_QWORD);
  _DWORD *v12;
  int v13;
  NSObject *v14;
  uint64_t v15;
  uint64_t v16;
  void (*v17)(_QWORD);
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  _QWORD v22[2];
  _QWORD v23[3];
  uint8_t buf[4];
  const char *v25;
  __int16 v26;
  int v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    (*((void (**)(void))a1[1] + 2))();
  }
  else
  {
    v23[0] = _MDPlistContainerGetBytes();
    v23[1] = _MDPlistContainerGetLength();
    v23[2] = 0;
    v22[0] = 1;
    v22[1] = v23;
    do
    {
      v3 = __ldxr(exceptionSequenceNum);
      v4 = v3 + 1;
    }
    while (__stxr(v3 + 1, exceptionSequenceNum));
    v5 = setThreadIdAndInfo(-1, (__int128 *)sMappingExceptionCallbacks, (uint64_t)v22, 0, v4);
    v20 = HIDWORD(v5);
    v21 = v5;
    v18 = v7;
    v19 = v6;
    v8 = *(_QWORD *)&threadData[18 * v5 + 2];
    v9 = v8 + 320 * HIDWORD(v5);
    *(_BYTE *)(v9 + 216) = 0;
    v10 = *(_DWORD *)(v9 + 312);
    v11 = *(void (**)(_QWORD))(v9 + 224);
    if (v11)
      v11(*(_QWORD *)(v8 + 320 * HIDWORD(v5) + 288));
    if (_setjmp((int *)v9))
    {
      v12 = (_DWORD *)(v9 + 312);
      v13 = *__error();
      v14 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        v25 = "get_topK";
        v26 = 1024;
        v27 = 30663;
        _os_log_error_impl(&dword_1B8270000, v14, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
      }
      *__error() = v13;
      *v12 = v10;
      CIOnThreadCleanUpReset(v18);
      dropThreadId(v21, 1, v4);
      CICleanUpReset(v21, v19);
    }
    else
    {
      (*((void (**)(void))a1[1] + 2))();
      v15 = *(_QWORD *)&threadData[18 * v21 + 2];
      v16 = v15 + 320 * v20;
      *(_DWORD *)(v16 + 312) = v10;
      v17 = *(void (**)(_QWORD))(v16 + 232);
      if (v17)
        v17(*(_QWORD *)(v15 + 320 * v20 + 288));
      dropThreadId(v21, 0, v4);
    }
  }
  _Block_release(a1[1]);
  free(a1);
}

void _SITransferBundles(uint64_t a1, uint64_t a2, const __CFArray *a3, int a4, const void *a5)
{
  CFIndex Count;
  _QWORD *v11;
  CFIndex i;
  const __CFString *ValueAtIndex;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  unsigned int *v19;
  int v20;
  uint8_t v21[1032];
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v21 = 0;
    _os_log_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "### transfer start", v21, 2u);
  }
  if (a3)
    Count = CFArrayGetCount(a3);
  else
    Count = 0;
  v11 = malloc_type_calloc(1uLL, 4 * Count + 84, 0xEAE76A8DuLL);
  *v11 = a1;
  v11[1] = a2;
  *((_DWORD *)v11 + 6) = a4;
  if (a5)
    v11[4] = _Block_copy(a5);
  if (Count)
  {
    if (Count >= 1)
    {
      for (i = 0; i != Count; ++i)
      {
        bzero(v21, 0x400uLL);
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a3, i);
        if (CFStringGetCString(ValueAtIndex, (char *)v21, 1024, 0x8000100u))
        {
          v14 = strlen((const char *)v21);
          v15 = bundleIdHash((uint64_t)v21, v14 + 1);
          v16 = *((unsigned int *)v11 + 18);
          *((_DWORD *)v11 + 18) = v16 + 1;
          *((_DWORD *)v11 + v16 + 19) = v15;
        }
      }
    }
    v17 = *((unsigned int *)v11 + 18);
    if ((a4 & 2) == 0 && (_DWORD)v17)
    {
      v18 = bundleIdHash((uint64_t)"com.com.apple.searchd", 21);
      *((_DWORD *)v11 + 18) = v17 + 1;
      *((_DWORD *)v11 + v17 + 19) = v18;
      LODWORD(v17) = v17 + 1;
    }
  }
  else
  {
    LODWORD(v17) = *((_DWORD *)v11 + 18);
  }
  if (a1 != a2 && a1 && (_DWORD)v17 && *(_BYTE *)(a1 + 2072) && *(_QWORD *)(a1 + 1040))
  {
    v11[2] = *(_QWORD *)(a1 + 1184);
    if ((a4 & 4) == 0)
    {
      *((_DWORD *)v11 + 7) = 0;
      si_enqueue_work(*(_QWORD *)(a1 + 1040), (uint64_t)si_transferBundleItems, (uint64_t)v11);
      return;
    }
    *((_DWORD *)v11 + 7) = 18;
    v19 = (unsigned int *)v11;
    v20 = 0;
  }
  else
  {
    *((_DWORD *)v11 + 12) = 22;
    v19 = (unsigned int *)v11;
    v20 = 1;
  }
  si_transferBundleItems(v19, v20);
}

void si_transferBundleItems(unsigned int *a1, int a2)
{
  int v3;
  _DWORD *v4;
  uint64_t i;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  int v9;
  unint64_t v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  void (*v16)(_QWORD);
  _DWORD *v17;
  int v18;
  NSObject *v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(_QWORD);
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t j;
  BOOL v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  const void *v33;
  const void *v34;
  unsigned int v35;
  unsigned int v36;
  unsigned int v37;
  unsigned int v38;
  char v39;
  uint8_t buf[4];
  _BYTE v41[14];
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v3 = a1[12];
    if (!v3)
    {
      a1[12] = 89;
      v3 = 89;
    }
  }
  else
  {
    v39 = 0;
    v4 = db_clear_docids_setup(*((int **)a1 + 2));
    for (i = 0; i != 18; ++i)
    {
      if (i != a1[7])
        si_scheduler_suspend(*(_QWORD *)(*(_QWORD *)a1 + 8 * i + 864));
    }
    if (*((_QWORD *)a1 + 1))
    {
      v6 = 864;
      do
      {
        v7 = v6;
        si_scheduler_suspend(*(_QWORD *)(*((_QWORD *)a1 + 1) + v6));
        v6 = v7 + 8;
      }
      while (v7 != 1000);
    }
    do
    {
      v8 = __ldxr(exceptionSequenceNum);
      v9 = v8 + 1;
    }
    while (__stxr(v8 + 1, exceptionSequenceNum));
    v10 = setThreadIdAndInfo(-1, sAssertExceptionCallbacks, 0, 0, v9);
    v37 = HIDWORD(v10);
    v38 = v10;
    v35 = v12;
    v36 = v11;
    v13 = *(_QWORD *)&threadData[18 * v10 + 2];
    v14 = v13 + 320 * HIDWORD(v10);
    v15 = *(_DWORD *)(v14 + 312);
    v16 = *(void (**)(_QWORD))(v14 + 224);
    if (v16)
      v16(*(_QWORD *)(v13 + 320 * HIDWORD(v10) + 288));
    if (_setjmp((int *)v14))
    {
      v17 = (_DWORD *)(v14 + 312);
      v18 = *__error();
      v19 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)v41 = "si_transferBundleItems";
        *(_WORD *)&v41[8] = 1024;
        *(_DWORD *)&v41[10] = 30911;
        _os_log_error_impl(&dword_1B8270000, v19, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
      }
      *__error() = v18;
      *v17 = v15;
      CIOnThreadCleanUpReset(v35);
      dropThreadId(v38, 1, v9);
      CICleanUpReset(v38, v36);
      v20 = 0;
    }
    else
    {
      v21 = db_clear_docids_matching_bundles(*((_DWORD **)a1 + 2), v4, *(_DWORD **)(*(_QWORD *)a1 + 6592), a1 + 19, a1[18], (unsigned int (*)(void *, uint64_t))transfer_bundles_match, (uint64_t)a1);
      v39 = 1;
      v22 = *(_QWORD *)&threadData[18 * v38 + 2];
      v23 = v22 + 320 * v37;
      *(_DWORD *)(v23 + 312) = v15;
      v24 = *(void (**)(_QWORD))(v23 + 232);
      if (v24)
        v24(*(_QWORD *)(v22 + 320 * v37 + 288));
      dropThreadId(v38, 0, v9);
      v20 = v21;
    }
    if (v39)
      v25 = v20;
    else
      v25 = -1;
    transfer_index_if_needed((uint64_t)a1, 0);
    db_clear_docids_cleanup(*((int **)a1 + 2), v4);
    if (*((_QWORD *)a1 + 1))
    {
      v26 = 1000;
      do
      {
        v27 = v26;
        si_scheduler_resume(*(_QWORD *)(*((_QWORD *)a1 + 1) + v26), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 30925);
        v26 = v27 - 8;
      }
      while (v27 != 864);
    }
    for (j = 125; j != 107; --j)
    {
      if (j - 108 != a1[7])
        si_scheduler_resume(*(_QWORD *)(*(_QWORD *)a1 + 8 * j), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 30934);
    }
    if (a1[12])
      v29 = 1;
    else
      v29 = v25 == 0;
    v30 = a1[12];
    if (!v29)
    {
      a1[12] = v25;
      v30 = v25;
    }
    v3 = v30;
  }
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
  {
    v31 = *((_QWORD *)a1 + 5);
    *(_DWORD *)buf = 67109376;
    *(_DWORD *)v41 = v3;
    *(_WORD *)&v41[4] = 2048;
    *(_QWORD *)&v41[6] = v31;
    _os_log_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "### transfer complete res:%d matches:%lu", buf, 0x12u);
  }
  v32 = *((_QWORD *)a1 + 4);
  if (v32)
  {
    (*(void (**)(uint64_t, _QWORD))(v32 + 16))(v32, a1[12]);
    _Block_release(*((const void **)a1 + 4));
  }
  v33 = (const void *)*((_QWORD *)a1 + 7);
  if (v33)
    CFRelease(v33);
  v34 = (const void *)*((_QWORD *)a1 + 8);
  if (v34)
    CFRelease(v34);
  free(a1);
}

uint64_t transfer_bundles_match(uint64_t *a1, uint64_t a2)
{
  unint64_t v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  BOOL v10;
  __CFDictionary *v11;
  const __CFDictionary *v12;
  uint64_t v13;
  CFIndex Count;
  CFTypeRef *v15;
  uint64_t v16;
  CFTypeRef *v17;
  CFTypeRef v18;
  CFTypeID v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  _BYTE buf[12];
  __int16 v28;
  uint64_t v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v4 = HIDWORD(*a1);
  v5 = *(_DWORD *)(a2 + 72);
  if ((*(_BYTE *)(a2 + 24) & 2) == 0 && *(_DWORD *)(a2 + 4 * --v5 + 76) == (_DWORD)v4)
    LODWORD(v4) = *a1;
  if (!v5)
    return 0;
  v6 = 0;
  v7 = 4 * v5;
  while ((_DWORD)v4 != *(_DWORD *)(a2 + v6 + 76))
  {
    v6 += 4;
    if (v7 == v6)
      return 0;
  }
  v25 = 0;
  v26 = 0;
  if (db_get_field(*(int **)(a2 + 16), (uint64_t)a1, "_kMDItemExternalID", &v26, &v25)
    || (*(_QWORD *)buf = 0, db_get_field(*(int **)(a2 + 16), (uint64_t)a1, "_kMDItemBundleID", &v26, buf))
    || ((*(_WORD *)(v26 + 2) & 0x10) != 0
      ? (v10 = db_get_string_for_id(*(int **)(a2 + 16), *(_DWORD *)(v26 + 13)) != 0)
      : (v10 = 1),
        !v25 || !v10))
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
    {
      v13 = *a1;
      *(_DWORD *)buf = 134217984;
      *(_QWORD *)&buf[4] = v13;
      _os_log_error_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "### transfer oid: 0x%llx - could not resolve bundle and identifier", buf, 0xCu);
    }
    return 0;
  }
  ++*(_QWORD *)(a2 + 40);
  v11 = decodeDBOToDictionary(*(int **)(a2 + 16), (uint64_t)a1, 0, 0, 0, 0, 0, 0, 2, (CFAllocatorRef)*MEMORY[0x1E0C9AE00]);
  v12 = v11;
  if (*(_QWORD *)(a2 + 8))
  {
    transfer_index_if_needed(a2, v11);
  }
  else
  {
    Count = CFDictionaryGetCount(v11);
    MEMORY[0x1E0C80A78](Count);
    v15 = (CFTypeRef *)((char *)&v25 - ((8 * Count + 15) & 0xFFFFFFFFFFFFFFF0));
    bzero(v15, 8 * Count);
    MEMORY[0x1E0C80A78](v16);
    v17 = v15;
    bzero(v15, 8 * Count);
    CFDictionaryGetKeysAndValues(v12, v15, v15);
    if (Count >= 1)
    {
      do
      {
        v18 = *v15;
        if (!CFEqual(*v15, CFSTR("_kMDItemBundleID")) && !CFEqual(v18, CFSTR("_kMDItemExternalID")))
        {
          v19 = CFGetTypeID(*v17);
          if (v19 != CFArrayGetTypeID())
            CFDictionaryGetTypeID();
        }
        ++v17;
        ++v15;
        --Count;
      }
      while (Count);
    }
  }
  CFRelease(v12);
  if ((*(_BYTE *)(a2 + 24) & 1) != 0)
    return 0;
  v20 = a1[4];
  if (!v20)
    return 1;
  v21 = si_indexForDocId(*(_QWORD *)a2, a1[4]);
  if (!v21)
    return 1;
  v22 = v21;
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
  {
    v23 = *a1;
    *(_DWORD *)buf = 134218240;
    *(_QWORD *)&buf[4] = v23;
    v28 = 2048;
    v29 = v20;
    _os_log_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "### index delete oid: 0x%llx did: 0x%llx", buf, 0x16u);
    v20 = a1[4];
  }
  v24 = *a1;
  v8 = 1;
  _CIDelete(v22, v20, v24, 1);
  return v8;
}

void transfer_index_if_needed(uint64_t a1, CFDictionaryRef theDict)
{
  const void *Value;
  _QWORD *v5;
  int v6;
  uint64_t v7;
  int i;
  uint64_t v9;
  _QWORD *v10;
  _DWORD *LiveIndex;
  int v12;
  uint64_t v13;
  const void *v14;
  CFIndex Count;
  CFTypeRef *v16;
  uint64_t v17;
  CFTypeRef *v18;
  CFTypeRef v19;
  __int128 v20;
  uint64_t v21;
  _BYTE v22[31];
  char v23;
  uint8_t buf[24];
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  if (!theDict)
  {
    v5 = (_QWORD *)(a1 + 64);
    if (!*(_QWORD *)(a1 + 64))
      return;
    Value = 0;
    goto LABEL_9;
  }
  Value = CFDictionaryGetValue(theDict, CFSTR("_kMDItemBundleID"));
  v5 = (_QWORD *)(a1 + 64);
  if (!*(_QWORD *)(a1 + 64))
    goto LABEL_22;
  if (!Value || *(int *)(a1 + 52) > 512 || !CFEqual(*(CFTypeRef *)(a1 + 56), Value))
  {
LABEL_9:
    _MDPlistContainerAddNullValue();
    _MDPlistContainerEndArray();
    _MDPlistContainerEndContainer();
    v6 = *(_DWORD *)(a1 + 52);
    if (v6)
    {
      v7 = *(_QWORD *)(a1 + 56);
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412546;
        *(_QWORD *)&buf[4] = v7;
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v6;
        _os_log_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "### transfering %@ %d items", buf, 0x12u);
        v6 = *(_DWORD *)(a1 + 52);
      }
      if (v6 >= 1)
      {
        for (i = 0; i < v6; ++i)
        {
          memset(buf, 0, sizeof(buf));
          _MDPlistGetRootPlistObjectFromPlist();
          v9 = *(_QWORD *)(a1 + 8);
          v20 = *(_OWORD *)buf;
          v21 = *(_QWORD *)&buf[16];
          _MDPlistArrayGetPlistObjectAtIndex();
          v21 = 0;
          v20 = 0u;
          if (processOneCS(v9, -1, v7, 0, 0, (uint64_t)v22, (uint64_t)&v20, 0, 0, 0, 0, 0, 0, &v23))
          {
            v10 = malloc_type_calloc(1uLL, 0x60uLL, 0x10B0040E0DE4348uLL);
            *v10 = *(_QWORD *)(a1 + 8);
            LiveIndex = si_getLiveIndex(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 1384));
            v10[1] = LiveIndex;
            v12 = LiveIndex[12];
            *((_DWORD *)v10 + 4) = 2;
            *((_DWORD *)v10 + 5) = v12;
            _flushCache(v10, 0);
          }
          v6 = *(_DWORD *)(a1 + 52);
        }
      }
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
      {
        v13 = *(_QWORD *)(a1 + 56);
        *(_DWORD *)buf = 138412546;
        *(_QWORD *)&buf[4] = v13;
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v6;
        _os_log_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "### transferred %@ %d items", buf, 0x12u);
      }
    }
    v14 = *(const void **)(a1 + 56);
    if (v14)
    {
      CFRelease(v14);
      *(_QWORD *)(a1 + 56) = 0;
    }
    CFRelease(*(CFTypeRef *)(a1 + 64));
    *(_QWORD *)(a1 + 64) = 0;
    *(_DWORD *)(a1 + 52) = 0;
LABEL_22:
    if (!Value)
      return;
  }
  Count = CFDictionaryGetCount(theDict);
  MEMORY[0x1E0C80A78](Count);
  v16 = (CFTypeRef *)((char *)&v20 - ((8 * Count + 15) & 0xFFFFFFFFFFFFFFF0));
  bzero(v16, 8 * Count);
  MEMORY[0x1E0C80A78](v17);
  v18 = v16;
  bzero(v16, 8 * Count);
  CFDictionaryGetKeysAndValues(theDict, v16, v16);
  if (!*v5)
  {
    *(_QWORD *)(a1 + 64) = _MDPlistContainerCreateMutable();
    _MDPlistContainerBeginContainer();
    _MDPlistContainerBeginArray();
    *(_QWORD *)(a1 + 56) = CFRetain(Value);
  }
  if (CFDictionaryGetValue(theDict, CFSTR("_kMDItemExternalID")))
  {
    _MDPlistContainerBeginDictionary();
    if (Count >= 1)
    {
      do
      {
        v19 = *v16;
        if (!CFEqual(*v16, CFSTR("kMDItemAttributeChangeDate"))
          && !CFEqual(v19, CFSTR("_kMDItemProtectionClass"))
          && !CFEqual(v19, CFSTR("_kMDItemGroupId"))
          && !CFEqual(v19, CFSTR("_kMDItemTransfered")))
        {
          _MDPlistContainerAddObject();
          _MDPlistContainerAddObject();
        }
        ++v18;
        ++v16;
        --Count;
      }
      while (Count);
    }
    _MDPlistContainerAddObject();
    _MDPlistContainerAddBooleanValue();
    _MDPlistContainerEndDictionary();
    ++*(_DWORD *)(a1 + 52);
  }
}

void _SIDeleteBundles(uint64_t a1, const __CFArray *a2, unsigned int a3, const void *a4)
{
  CFIndex Count;
  unsigned int *v9;
  CFIndex i;
  const __CFString *ValueAtIndex;
  int v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  unsigned int *v17;
  int v18;
  uint8_t v19[1032];
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v19 = 0;
    _os_log_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "### delete bundles journal start", v19, 2u);
  }
  if (a2)
    Count = CFArrayGetCount(a2);
  else
    Count = 0;
  v9 = (unsigned int *)malloc_type_calloc(1uLL, 4 * Count + 52, 0xF51331F6uLL);
  *(_QWORD *)v9 = a1;
  v9[4] = a3;
  if (a4)
    *((_QWORD *)v9 + 3) = _Block_copy(a4);
  if (Count)
  {
    if (Count >= 1)
    {
      for (i = 0; i != Count; ++i)
      {
        bzero(v19, 0x400uLL);
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a2, i);
        if (CFStringGetCString(ValueAtIndex, (char *)v19, 1024, 0x8000100u))
        {
          v12 = strlen((const char *)v19);
          v13 = bundleIdHash((uint64_t)v19, v12 + 1);
          v14 = v9[11];
          v9[11] = v14 + 1;
          v9[v14 + 12] = v13;
        }
      }
    }
    v15 = v9[11];
    if ((a3 & 2) == 0 && (_DWORD)v15)
    {
      v16 = bundleIdHash((uint64_t)"com.com.apple.searchd", 21);
      v9[11] = v15 + 1;
      v9[v15 + 12] = v16;
      LODWORD(v15) = v15 + 1;
    }
    if (!a1)
      goto LABEL_25;
  }
  else
  {
    LODWORD(v15) = v9[11];
    if (!a1)
    {
LABEL_25:
      v9[10] = 22;
      v9[5] = 18;
      v17 = v9;
      v18 = 1;
      goto LABEL_26;
    }
  }
  if (!(_DWORD)v15 || !*(_BYTE *)(a1 + 2072) || !*(_QWORD *)(a1 + 1040))
    goto LABEL_25;
  *((_QWORD *)v9 + 1) = *(_QWORD *)(a1 + 1184);
  if ((a3 & 4) == 0)
  {
    v9[5] = 0;
    si_enqueue_work(*(_QWORD *)(a1 + 1040), (uint64_t)si_deleteBundleItems, (uint64_t)v9);
    return;
  }
  v9[5] = 18;
  v17 = v9;
  v18 = 0;
LABEL_26:
  si_deleteBundleItems(v17, v18);
}

void si_deleteBundleItems(unsigned int *a1, int a2)
{
  int v3;
  _DWORD *v4;
  uint64_t i;
  unsigned int v6;
  int v7;
  unint64_t v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  void (*v14)(_QWORD);
  _DWORD *v15;
  int v16;
  NSObject *v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  void (*v21)(_QWORD);
  uint64_t j;
  int v23;
  BOOL v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  char v32;
  uint8_t buf[4];
  _BYTE v34[14];
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    v3 = a1[10];
    if (!v3)
    {
      a1[10] = 89;
      v3 = 89;
    }
  }
  else
  {
    v32 = 0;
    v4 = db_clear_docids_setup(*((int **)a1 + 1));
    for (i = 0; i != 18; ++i)
    {
      if (i != a1[5])
        si_scheduler_suspend(*(_QWORD *)(*(_QWORD *)a1 + 8 * i + 864));
    }
    do
    {
      v6 = __ldxr(exceptionSequenceNum);
      v7 = v6 + 1;
    }
    while (__stxr(v6 + 1, exceptionSequenceNum));
    v8 = setThreadIdAndInfo(-1, sAssertExceptionCallbacks, 0, 0, v7);
    v30 = HIDWORD(v8);
    v31 = v8;
    v28 = v10;
    v29 = v9;
    v11 = *(_QWORD *)&threadData[18 * v8 + 2];
    v12 = v11 + 320 * HIDWORD(v8);
    v13 = *(_DWORD *)(v12 + 312);
    v14 = *(void (**)(_QWORD))(v12 + 224);
    if (v14)
      v14(*(_QWORD *)(v11 + 320 * HIDWORD(v8) + 288));
    if (_setjmp((int *)v12))
    {
      v15 = (_DWORD *)(v12 + 312);
      v16 = *__error();
      v17 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)v34 = "si_deleteBundleItems";
        *(_WORD *)&v34[8] = 1024;
        *(_DWORD *)&v34[10] = 31098;
        _os_log_error_impl(&dword_1B8270000, v17, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
      }
      *__error() = v16;
      *v15 = v13;
      CIOnThreadCleanUpReset(v28);
      dropThreadId(v31, 1, v7);
      CICleanUpReset(v31, v29);
      v18 = 0;
    }
    else
    {
      v18 = db_clear_docids_matching_bundles(*((_DWORD **)a1 + 1), v4, *(_DWORD **)(*(_QWORD *)a1 + 6592), a1 + 12, a1[11], (unsigned int (*)(void *, uint64_t))delete_bundles_match, (uint64_t)a1);
      v32 = 1;
      v19 = *(_QWORD *)&threadData[18 * v31 + 2];
      v20 = v19 + 320 * v30;
      *(_DWORD *)(v20 + 312) = v13;
      v21 = *(void (**)(_QWORD))(v20 + 232);
      if (v21)
        v21(*(_QWORD *)(v19 + 320 * v30 + 288));
      dropThreadId(v31, 0, v7);
    }
    db_clear_docids_cleanup(*((int **)a1 + 1), v4);
    for (j = 125; j != 107; --j)
    {
      if (j - 108 != a1[5])
        si_scheduler_resume(*(_QWORD *)(*(_QWORD *)a1 + 8 * j), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SpotlightIndex.c", 31110);
    }
    if (v32)
      v23 = v18;
    else
      v23 = -1;
    if (a1[10])
      v24 = 1;
    else
      v24 = v23 == 0;
    v25 = a1[10];
    if (!v24)
    {
      a1[10] = v23;
      v25 = v23;
    }
    v3 = v25;
  }
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
  {
    v26 = *((_QWORD *)a1 + 4);
    *(_DWORD *)buf = 67109376;
    *(_DWORD *)v34 = v3;
    *(_WORD *)&v34[4] = 2048;
    *(_QWORD *)&v34[6] = v26;
    _os_log_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "### delete bundles complete res:%d matches:%lu", buf, 0x12u);
  }
  v27 = *((_QWORD *)a1 + 3);
  if (v27)
  {
    (*(void (**)(uint64_t, _QWORD))(v27 + 16))(v27, a1[10]);
    _Block_release(*((const void **)a1 + 3));
  }
  free(a1);
}

uint64_t delete_bundles_match(uint64_t *a1, uint64_t a2)
{
  unint64_t v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t string_for_id;
  int v9;
  _BOOL4 v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v20;
  unint64_t v21;
  _BYTE buf[12];
  __int16 v23;
  uint64_t v24;
  __int16 v25;
  uint64_t v26;
  __int16 v27;
  uint64_t v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v4 = HIDWORD(*a1);
  v5 = *(_DWORD *)(a2 + 44);
  if ((*(_BYTE *)(a2 + 16) & 2) == 0 && *(_DWORD *)(a2 + 4 * --v5 + 48) == (_DWORD)v4)
    LODWORD(v4) = *a1;
  if (!v5)
    return 0;
  v6 = 0;
  v7 = 4 * v5;
  while ((_DWORD)v4 != *(_DWORD *)(a2 + v6 + 48))
  {
    v6 += 4;
    if (v7 == v6)
      return 0;
  }
  v20 = 0;
  v21 = 0;
  string_for_id = 0;
  if (!db_get_field(*(int **)(a2 + 8), (uint64_t)a1, "_kMDItemExternalID", &v21, &v20))
  {
    *(_QWORD *)buf = 0;
    string_for_id = 0;
    if (!db_get_field(*(int **)(a2 + 8), (uint64_t)a1, "_kMDItemBundleID", &v21, buf))
    {
      if ((*(_WORD *)(v21 + 2) & 0x10) != 0)
        string_for_id = db_get_string_for_id(*(int **)(a2 + 8), *(_DWORD *)(v21 + 13));
      else
        string_for_id = v21 + 13;
    }
  }
  ++*(_QWORD *)(a2 + 32);
  v9 = *(_DWORD *)(a2 + 16);
  v10 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT);
  if ((v9 & 1) != 0)
  {
    if (v10)
    {
      v17 = *a1;
      v18 = a1[4];
      *(_DWORD *)buf = 134218754;
      *(_QWORD *)&buf[4] = v17;
      v23 = 2048;
      v24 = v18;
      v25 = 2080;
      v26 = string_for_id;
      v27 = 2080;
      v28 = v20;
      _os_log_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "### delete oid: 0x%llx did: 0x%llx %s %s", buf, 0x2Au);
    }
    return 0;
  }
  if (v10)
  {
    v11 = *a1;
    v12 = a1[4];
    *(_DWORD *)buf = 134218754;
    *(_QWORD *)&buf[4] = v11;
    v23 = 2048;
    v24 = v12;
    v25 = 2080;
    v26 = string_for_id;
    v27 = 2080;
    v28 = v20;
    _os_log_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "### delete oid: 0x%llx did: 0x%llx %s %s", buf, 0x2Au);
  }
  v13 = a1[4];
  if (!v13)
    return 1;
  v14 = si_indexForDocId(*(_QWORD *)a2, a1[4]);
  if (!v14)
    return 1;
  v15 = *a1;
  v16 = 1;
  _CIDelete(v14, v13, v15, 1);
  return v16;
}

uint64_t unicode_combinable(unsigned int a1)
{
  int v1;

  if (a1 < 0x300)
    return 0;
  v1 = __CFUniCharCombiningBitmap[(unint64_t)a1 >> 8];
  if (!__CFUniCharCombiningBitmap[(unint64_t)a1 >> 8])
    return 0;
  if (v1 == 255)
    return 1;
  return (__CFUniCharCombiningBitmap[(a1 >> 3) + 256 + 32 * v1 - 32] >> (a1 & 7)) & 1;
}

uint64_t unicode_recursive_decompose(unsigned int a1, _WORD *a2)
{
  _WORD *v2;
  unsigned __int16 *v3;
  unsigned __int16 *v4;
  uint64_t v5;
  unsigned __int16 *v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned __int16 *v11;
  uint64_t result;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _OWORD *v16;
  __int128 *v17;
  uint64_t v18;
  __int128 v19;
  __int16 v20;
  __int16 v21;

  v2 = a2;
  if ((unsigned __int16)(a1 + 1201) < 0x571u)
  {
LABEL_7:
    v8 = 0;
  }
  else
  {
    v3 = (unsigned __int16 *)&__CFUniCharDecompositionTable;
    v4 = (unsigned __int16 *)&unk_1B862F5C4;
    while (1)
    {
      while (1)
      {
        v5 = ((char *)v4 - (char *)v3) >> 3;
        v6 = &v3[2 * v5];
        v7 = *v6;
        if (v7 <= a1)
          break;
        v4 = v6 - 2;
        if (v3 > v6 - 2)
          goto LABEL_7;
      }
      if (v7 >= a1)
        break;
      v3 = v6 + 2;
      if (v6 + 2 > v4)
        goto LABEL_7;
    }
    v8 = v3[2 * v5 + 1];
  }
  v9 = (v8 >> 12) & 7;
  v21 = v8 & 0xFFF;
  v10 = v9 - 1;
  if (v9 == 1)
    v11 = (unsigned __int16 *)&v21;
  else
    v11 = (unsigned __int16 *)((char *)&__CFUniCharMultipleDecompositionTable + 2 * (v8 & 0xFFF));
  if ((v8 & 0x8000) != 0)
  {
    result = unicode_recursive_decompose(*v11, a2);
    if (!(_DWORD)result)
      return result;
    ++v11;
    v2 += result;
    v9 = v10;
    result = result + v10;
    if (!v10)
      return result;
  }
  else
  {
    result = v9;
    if (!v9)
      return result;
  }
  if (v9 < 0x10)
    goto LABEL_24;
  if ((unint64_t)((char *)v2 - (char *)v11) < 0x20)
  {
    v9 = -1;
    goto LABEL_24;
  }
  v13 = v9;
  v14 = v9 & 0xFFFFFFF0;
  v15 = 2 * v14;
  v9 = ~(_DWORD)v14;
  v16 = v2 + 8;
  v17 = (__int128 *)(v11 + 8);
  v18 = v14;
  do
  {
    v19 = *v17;
    *(v16 - 1) = *(v17 - 1);
    *v16 = v19;
    v16 += 2;
    v17 += 2;
    v18 -= 16;
  }
  while (v18);
  if (v14 != v13)
  {
    v11 = (unsigned __int16 *)((char *)v11 + v15);
    v2 = (_WORD *)((char *)v2 + v15);
    do
    {
LABEL_24:
      v20 = *v11++;
      *v2++ = v20;
      --v9;
    }
    while (v9);
  }
  return result;
}

uint64_t utf8_decodestr(unsigned __int8 *a1, unint64_t a2, _WORD *a3, _QWORD *a4, uint64_t a5, _DWORD *a6, char a7)
{
  unint64_t v10;
  unint64_t v11;
  _WORD *v12;
  unsigned __int8 *v13;
  unint64_t v14;
  unsigned int v15;
  unsigned int v16;
  unint64_t v17;
  BOOL v18;
  int v19;
  int v20;
  int v21;
  int v22;
  unsigned int v23;
  unsigned int v24;
  _WORD *v25;
  __int16 v26;
  int v27;
  int v28;
  int v29;
  uint64_t result;
  int v31;
  unsigned __int16 v32;
  __int16 v33;
  int v34;
  uint64_t v35;
  _WORD *v36;
  unsigned int v37;
  unsigned int v38;
  _WORD *v39;
  _QWORD v40[3];

  v40[2] = *MEMORY[0x1E0C80C00];
  *a6 = 0;
  if (!a2)
  {
    result = 0;
    v12 = a3;
    goto LABEL_62;
  }
  v10 = a2;
  v11 = (unint64_t)a3 + a5;
  v12 = a3;
  v13 = a1;
  while (1)
  {
    v15 = *v13++;
    v14 = v15;
    if (!v15)
    {
LABEL_57:
      result = 0;
      goto LABEL_62;
    }
    --v10;
    if ((v14 & 0x80) == 0)
    {
      if ((unint64_t)v12 >= v11)
        goto LABEL_59;
LABEL_6:
      v16 = bswap32(v14) >> 16;
      if ((a7 & 1) != 0)
        LOWORD(v14) = v16;
      *v12++ = v14;
      goto LABEL_9;
    }
    v17 = utf_extrabytes[v14 >> 3];
    v18 = v10 >= v17;
    v10 -= v17;
    if (!v18)
      goto LABEL_58;
    if ((_DWORD)v17 != 3)
      break;
    v20 = *v13;
    if ((v20 & 0xC0) != 0x80
      || (v21 = a1[2], (v21 & 0xC0) != 0x80)
      || (v22 = a1[3], (v22 & 0xC0) != 0x80)
      || (v23 = v22 + (((v20 << 6) + ((_DWORD)v14 << 12) + v21) << 6) - 63512704, v23 >> 20))
    {
LABEL_58:
      result = 22;
      goto LABEL_62;
    }
    v24 = (v23 >> 10) - 10240;
    if ((a7 & 1) != 0)
    {
      *v12 = bswap32(v24) >> 16;
      v25 = v12 + 1;
      if ((unint64_t)(v12 + 1) >= v11)
      {
LABEL_61:
        result = 63;
        v12 = v25;
        goto LABEL_62;
      }
      v26 = __rev16(v23 & 0x3FF | 0xDC00);
    }
    else
    {
      *v12 = v24;
      v25 = v12 + 1;
      if ((unint64_t)(v12 + 1) >= v11)
        goto LABEL_61;
      v26 = v23 & 0x3FF | 0xDC00;
    }
    v13 = a1 + 4;
    v12[1] = v26;
    v12 += 2;
LABEL_9:
    a1 = v13;
    if (!v10)
      goto LABEL_57;
  }
  if ((_DWORD)v17 == 2)
  {
    v27 = *v13;
    if ((v27 & 0xC0) != 0x80)
      goto LABEL_58;
    v28 = a1[2];
    if ((v28 & 0xC0) != 0x80)
      goto LABEL_58;
    v29 = (v27 << 6) + ((_DWORD)v14 << 12) + v28;
    LODWORD(v14) = v29 - 925824;
    if ((v29 - 925824) < 0x800)
      goto LABEL_58;
    v13 = a1 + 3;
    if (v14 >> 11 >= 0x1B)
    {
      result = 22;
      if (v14 < 0xE000 || (v29 & 0x3FFFFE) == 0xF207E)
        goto LABEL_62;
    }
  }
  else
  {
    if ((_DWORD)v17 != 1)
      goto LABEL_58;
    v19 = *v13;
    if ((v19 & 0xC0) != 0x80)
      goto LABEL_58;
    LODWORD(v14) = v19 + ((_DWORD)v14 << 6) - 12416;
    if (v14 < 0x80)
      goto LABEL_58;
    v13 = a1 + 2;
  }
  if ((a7 & 4) == 0
    || (unsigned __int16)v14 < 0xC0u
    || (v31 = __CFUniCharDecomposableBitmap[BYTE1(v14)]) == 0
    || v31 != 255
    && ((__CFUniCharDecomposableBitmap[(v14 >> 3) + 256 + 32 * v31 - 32] >> (v14 & 7)) & 1) == 0)
  {
    if ((_DWORD)v14 == 9216)
      LODWORD(v14) = 0;
    if ((unint64_t)v12 >= v11)
    {
LABEL_59:
      result = 63;
      goto LABEL_62;
    }
    goto LABEL_6;
  }
  v40[0] = 0;
  v40[1] = 0;
  v32 = v14 + 21504;
  if ((unsigned __int16)(v14 + 21504) > 0x2BA4u)
  {
    v34 = unicode_recursive_decompose((unsigned __int16)v14, v40);
    if (v34 >= 1)
      goto LABEL_50;
    goto LABEL_9;
  }
  v33 = (unsigned __int16)(v14 + 21504) % 0x1Cu;
  LOWORD(v40[0]) = ((28533 * v32) >> 24) | 0x1100;
  WORD1(v40[0]) = v32 % 0x24Cu / 0x1C + 4449;
  if (v32 % 0x1Cu)
  {
    WORD2(v40[0]) = v33 + 4519;
    v34 = 3;
  }
  else
  {
    v34 = 2;
  }
LABEL_50:
  v35 = 0;
  while (1)
  {
    v36 = &v12[v35];
    v37 = *(unsigned __int16 *)((char *)v40 + v35 * 2);
    v38 = bswap32(v37) >> 16;
    if ((a7 & 1) != 0)
      LOWORD(v37) = v38;
    *v36 = v37;
    v39 = v36 + 1;
    if ((unint64_t)v39 >= v11)
      break;
    if (v34 == ++v35)
    {
      v12 = (_WORD *)((char *)v12 + v35 * 2);
      goto LABEL_9;
    }
  }
  result = 63;
  v12 = v39;
LABEL_62:
  *a4 = (char *)v12 - (char *)a3;
  return result;
}

uint64_t map_case(uint64_t a1)
{
  uint64_t v1;
  unsigned __int8 *v2;
  unsigned __int16 *v3;
  int __key;

  v1 = a1;
  if (a1 > 0x7F)
  {
    if ((unsigned __int16)(a1 + 223) < 0x3Au || a1 < 0x587 || (unsigned __int16)(a1 - 7680) <= 0x6E9u)
    {
      __key = (unsigned __int16)a1;
      v3 = (unsigned __int16 *)bsearch(&__key, &case_mapping_table, 0x57AuLL, 4uLL, (int (__cdecl *)(const void *, const void *))case_cmp);
      if (v3)
        return v3[1];
    }
  }
  else
  {
    if ((a1 - 97) > 0x19)
      v2 = (unsigned __int8 *)tolower_map;
    else
      v2 = toupper_map;
    return v2[a1];
  }
  return v1;
}

uint64_t case_cmp(unsigned __int16 *a1, unsigned __int16 *a2)
{
  return *a1 - *a2;
}

uint64_t _SICrashStateDump(const char *a1, FILE *a2)
{
  int v3;
  int v4;
  int v5;
  char v6;
  char *v7;
  char *v8;
  ssize_t v9;
  uint64_t i;
  uint64_t v11;
  const void *v12;
  uint64_t v13;
  size_t v14;
  size_t v15;
  void *v16;
  void *v17;
  int v18;
  char *v19;
  uint64_t v20;
  size_t v21;
  void *v22;
  char *v23;
  tm *v24;
  tm *v25;
  tm *v27;
  double v28;
  tm *v29;
  tm *v30;
  _BOOL4 v31;
  time_t v32;
  int v33;
  FILE *v34;
  int v35;
  time_t v36;
  uint64_t v37;
  const void *v38;
  int v39;
  time_t v40;
  time_t v41;
  size_t size;
  time_t v43;
  time_t v44;
  int v45;
  time_t v46[3];
  __int16 v47;
  char v48[8];
  uint64_t v49;
  uint64_t v50;
  __int16 v51;
  uint64_t v52;

  v52 = *MEMORY[0x1E0C80C00];
  v45 = 0;
  v43 = 0;
  v44 = -1;
  v41 = -1;
  size = 0;
  v40 = 0;
  v3 = open(a1, 256);
  if (v3 == -1)
  {
    __error();
    fprintf(a2, "Failed to open file %s. errno = %d\n");
    return 0xFFFFFFFFLL;
  }
  else
  {
    v4 = v3;
    v5 = 0;
    v35 = 0;
    v36 = -1;
    v32 = -1;
    v34 = a2;
    v33 = v3;
    while (read(v4, &v45, 4uLL) == 4)
    {
      if (v45 == 1127364148)
      {
        v6 = 1;
      }
      else
      {
        if (v45 != 875967043)
        {
          fprintf(a2, "Invalid crash file. magic=0x%x\n");
          return 0xFFFFFFFFLL;
        }
        v6 = 0;
        v45 = 1127364148;
      }
      if (read(v4, &size, 8uLL) != 8)
      {
        fprintf(a2, "Invalid header. len=%ld\n");
        return 0xFFFFFFFFLL;
      }
      v7 = (char *)malloc_type_malloc(size, 0xA4F8FEEBuLL);
      if (!v7)
      {
        fwrite("Malloc failed\n", 0xEuLL, 1uLL, a2);
        return 4294967294;
      }
      v8 = v7;
      v9 = read(v4, v7, size);
      if (v9 != size)
      {
        fprintf(a2, "Read failed. len=%ld\n");
LABEL_31:
        free(v8);
        return 4294967294;
      }
      if (v9 <= 5)
      {
        fprintf(a2, "Read failed: len=%ld<6\n");
        goto LABEL_31;
      }
      v39 = v5;
      if ((v6 & 1) == 0)
      {
        for (i = 0; i != 48; i += 16)
          *(int8x16_t *)&v8[i] = vrev64q_s8(*(int8x16_t *)&v8[i]);
      }
      v8[v9 - 1] = 0;
      v11 = *(_QWORD *)v8;
      v12 = (const void *)*((_QWORD *)v8 + 1);
      v13 = *((_QWORD *)v8 + 2);
      v46[0] = *((_QWORD *)v8 + 3);
      v15 = *((_QWORD *)v8 + 4);
      v14 = *((_QWORD *)v8 + 5);
      v16 = malloc_type_malloc(v15, 0xD464FEB2uLL);
      v17 = malloc_type_malloc(v14, 0x1CB9FE96uLL);
      v19 = v8 + 48;
      v18 = v8[48];
      v37 = v13;
      v38 = v12;
      if (v18 == 43)
      {
        v19 = v8 + 49;
        ++v35;
        v40 = v46[0];
        if (v32 == -1)
        {
          v41 = v46[0];
          v20 = -49;
          v32 = v46[0];
        }
        else
        {
          v20 = -49;
        }
      }
      else
      {
        v20 = -48;
      }
      v21 = v20 - (v14 + v15) + size;
      v22 = malloc_type_malloc(v21, 0xE4B289A5uLL);
      memcpy(v16, v19, v15);
      v23 = &v19[v15];
      memcpy(v17, v23, v14);
      memcpy(v22, &v23[v14], v21);
      v43 = v46[0];
      if (v36 == -1)
      {
        v44 = v46[0];
        v36 = v46[0];
      }
      v5 = v39 + 1;
      *(_QWORD *)v48 = 0;
      v49 = 0;
      v51 = 0;
      v50 = 0;
      v24 = localtime(v46);
      strftime(v48, 0x1AuLL, "%Y-%m-%d %H:%M:%S%z", v24);
      v31 = v18 == 43;
      a2 = v34;
      fprintf(v34, "[%16s] crashed pc:0x%08lx, addr:%p, sig:0x%08lx, compact:%d, build:%s, spotlight_version:%s, path:%s\n", v48, v11, v38, v37, v31, (const char *)v16, (const char *)v17, (const char *)v22);
      free(v16);
      free(v17);
      free(v22);
      free(v8);
      v4 = v33;
    }
    if (v5)
    {
      *(_QWORD *)v48 = 0;
      v49 = 0;
      v51 = 0;
      v50 = 0;
      v25 = localtime(&v43);
      strftime(v48, 0x1AuLL, "%Y-%m-%d %H:%M:%S%z", v25);
      if (v5 == 1)
      {
        fprintf(a2, "Detected crash at %s\n");
      }
      else
      {
        memset(v46, 0, sizeof(v46));
        v47 = 0;
        v27 = localtime(&v44);
        strftime((char *)v46, 0x1AuLL, "%Y-%m-%d %H:%M:%S%z", v27);
        if (v43 <= v44)
          v28 = 1.79769313e308;
        else
          v28 = (double)(24 * v5) * 3600.0 / (double)(v43 - v44);
        fprintf(a2, "Detected %d crashes from %s to %s in total. crash rate %.2f/day\n", v5, (const char *)v46, v48, v28);
        if (v35 >= 1)
        {
          v29 = localtime(&v40);
          strftime(v48, 0x1AuLL, "%Y-%m-%d %H:%M:%S%z", v29);
          if (v35 == 1)
          {
            fprintf(a2, "Detected compact crash at %s\n");
          }
          else
          {
            v30 = localtime(&v41);
            strftime((char *)v46, 0x1AuLL, "%Y-%m-%d %H:%M:%S%z", v30);
            fprintf(a2, "Detected %d compact crashes from %s to %s in total. compact crash rate %.2f/day\n");
          }
        }
      }
    }
    else
    {
      fwrite("No crash detected\n", 0x12uLL, 1uLL, a2);
    }
    close(v4);
    return 0;
  }
}

void ScopeLogger::ScopeLogger(ScopeLogger *this, const char *a2)
{
  int v4;
  NSObject *v5;
  os_log_type_t v6;
  timespec v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)this = a2;
  v4 = *__error();
  v5 = _SILogForLogForCategory(8);
  v6 = 2 * (dword_1EF19FCAC < 4);
  if (os_log_type_enabled(v5, v6))
  {
    LODWORD(v7.tv_sec) = 136315138;
    *(__darwin_time_t *)((char *)&v7.tv_sec + 4) = (__darwin_time_t)a2;
    _os_log_impl(&dword_1B8270000, v5, v6, "%s entry", (uint8_t *)&v7, 0xCu);
  }
  *__error() = v4;
  v7.tv_sec = 0;
  v7.tv_nsec = 0;
  clock_gettime(_CLOCK_REALTIME, &v7);
  *((_QWORD *)this + 1) = v7.tv_nsec + 1000000000 * v7.tv_sec;
}

void DocStore::DocStore(DocStore *this, int a2)
{
  char *v3;
  uint64_t v4;
  std::__shared_weak_count *v5;
  unint64_t *p_shared_owners;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  std::__shared_weak_count *v10;
  unint64_t *v11;
  std::__shared_weak_count *v12;
  unint64_t v13;
  unint64_t *p_shared_weak_owners;
  unint64_t v15;
  unint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  std::__shared_weak_count *v22;
  unint64_t *v23;
  unint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t (***v27)();
  uint64_t v28;
  char *v29;
  uint64_t v30;
  std::__shared_weak_count *v31;
  unint64_t *v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  std::__shared_weak_count *v36;
  unint64_t *v37;
  std::__shared_weak_count *v38;
  unint64_t v39;
  unint64_t *v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t *v43;
  unint64_t v44;
  unint64_t v45;
  uint64_t v46;
  uint64_t v47;
  std::__shared_weak_count *v48;
  unint64_t *v49;
  unint64_t v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t (***v53)();
  uint64_t v54;
  char *v55;
  uint64_t v56;
  std::__shared_weak_count *v57;
  unint64_t *v58;
  uint64_t v59;
  unint64_t v60;
  unint64_t v61;
  std::__shared_weak_count *v62;
  unint64_t *v63;
  std::__shared_weak_count *v64;
  unint64_t v65;
  unint64_t *v66;
  unint64_t v67;
  unint64_t v68;
  unint64_t *v69;
  unint64_t v70;
  unint64_t v71;
  uint64_t v72;
  uint64_t v73;
  std::__shared_weak_count *v74;
  unint64_t *v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t (***v79)();
  uint64_t v80;
  uint64_t (**v81)();
  uint64_t v82;
  std::__shared_weak_count *v83;
  uint64_t (***v84)();
  uint64_t v85;

  v85 = *MEMORY[0x1E0C80C00];
  *(_DWORD *)this = a2;
  *((_DWORD *)this + 1) = -1;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *((_QWORD *)this + 5) = 850045863;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_QWORD *)this + 14) = 0;
  *((_QWORD *)this + 15) = 1;
  *((_QWORD *)this + 16) = 0;
  v3 = (char *)this + 128;
  *((_QWORD *)this + 17) = 0;
  v4 = operator new();
  v5 = (std::__shared_weak_count *)operator new(0x20uLL);
  v5->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v5->__shared_owners_;
  v5->__shared_weak_owners_ = 0;
  v5->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6E2ACC0;
  v5[1].__vftable = (std::__shared_weak_count_vtbl *)&off_1E6E2A988;
  if (analytics::XpcActivityScheduler::getInstance(void)::t != -1)
    dispatch_once(&analytics::XpcActivityScheduler::getInstance(void)::t, &__block_literal_global_1487);
  v7 = analytics::XpcActivityScheduler::getInstance(void)::instance;
  *(_QWORD *)v4 = &off_1E6E2AA28;
  *(_QWORD *)(v4 + 8) = 0;
  *(_QWORD *)(v4 + 16) = 0;
  *(_QWORD *)(v4 + 24) = 10;
  *(_QWORD *)(v4 + 32) = v5 + 1;
  *(_QWORD *)(v4 + 40) = v5;
  do
    v8 = __ldxr(p_shared_owners);
  while (__stxr(v8 + 1, p_shared_owners));
  *(_QWORD *)(v4 + 48) = v7;
  *(_OWORD *)(v4 + 56) = 0u;
  *(_OWORD *)(v4 + 72) = 0u;
  *(_QWORD *)(v4 + 88) = 850045863;
  *(_OWORD *)(v4 + 96) = 0u;
  *(_OWORD *)(v4 + 112) = 0u;
  *(_OWORD *)(v4 + 128) = 0u;
  *(_QWORD *)(v4 + 144) = 0;
  do
    v9 = __ldaxr(p_shared_owners);
  while (__stlxr(v9 - 1, p_shared_owners));
  if (!v9)
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  *((_QWORD *)this + 16) = v4;
  v10 = (std::__shared_weak_count *)operator new();
  v10->__shared_owners_ = 0;
  v11 = (unint64_t *)&v10->__shared_owners_;
  v10->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6E2ADD8;
  v10->__shared_weak_owners_ = 0;
  v10[1].__vftable = (std::__shared_weak_count_vtbl *)v4;
  *((_QWORD *)this + 17) = v10;
  v12 = *(std::__shared_weak_count **)(v4 + 16);
  if (v12)
  {
    if (v12->__shared_owners_ != -1)
      goto LABEL_22;
    do
      v13 = __ldxr(v11);
    while (__stxr(v13 + 1, v11));
    p_shared_weak_owners = (unint64_t *)&v10->__shared_weak_owners_;
    do
      v15 = __ldxr(p_shared_weak_owners);
    while (__stxr(v15 + 1, p_shared_weak_owners));
    *(_QWORD *)(v4 + 8) = v4;
    *(_QWORD *)(v4 + 16) = v10;
    std::__shared_weak_count::__release_weak(v12);
  }
  else
  {
    do
      v16 = __ldxr(v11);
    while (__stxr(v16 + 1, v11));
    v17 = (unint64_t *)&v10->__shared_weak_owners_;
    do
      v18 = __ldxr(v17);
    while (__stxr(v18 + 1, v17));
    *(_QWORD *)(v4 + 8) = v4;
    *(_QWORD *)(v4 + 16) = v10;
  }
  do
    v19 = __ldaxr(v11);
  while (__stlxr(v19 - 1, v11));
  if (!v19)
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
LABEL_22:
  v20 = *(_QWORD *)v3;
  v21 = *(_QWORD *)(*(_QWORD *)v3 + 8);
  v22 = *(std::__shared_weak_count **)(*(_QWORD *)v3 + 16);
  if (v22)
  {
    v23 = (unint64_t *)&v22->__shared_weak_owners_;
    do
      v24 = __ldxr(v23);
    while (__stxr(v24 + 1, v23));
    v25 = *(_QWORD *)(v20 + 48);
    do
      v26 = __ldxr(v23);
    while (__stxr(v26 + 1, v23));
  }
  else
  {
    v25 = *(_QWORD *)(v20 + 48);
  }
  v81 = &off_1E6E2ABC0;
  v82 = v21;
  v83 = v22;
  v84 = &v81;
  (*(void (**)(uint64_t, uint64_t (***)()))(*(_QWORD *)v25 + 16))(v25, &v81);
  v27 = v84;
  if (v84 == &v81)
  {
    v28 = 4;
    v27 = &v81;
  }
  else
  {
    if (!v84)
      goto LABEL_34;
    v28 = 5;
  }
  (*v27)[v28]();
LABEL_34:
  if (v22)
    std::__shared_weak_count::__release_weak(v22);
  *((_QWORD *)this + 18) = 0;
  *((_QWORD *)this + 19) = 0;
  v29 = (char *)this + 144;
  v30 = operator new();
  v31 = (std::__shared_weak_count *)operator new(0x20uLL);
  v31->__shared_owners_ = 0;
  v32 = (unint64_t *)&v31->__shared_owners_;
  v31->__shared_weak_owners_ = 0;
  v31->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6E2ACF8;
  v31[1].__vftable = (std::__shared_weak_count_vtbl *)&off_1E6E2A9B0;
  if (analytics::XpcActivityScheduler::getInstance(void)::t != -1)
    dispatch_once(&analytics::XpcActivityScheduler::getInstance(void)::t, &__block_literal_global_1487);
  v33 = analytics::XpcActivityScheduler::getInstance(void)::instance;
  *(_QWORD *)v30 = &off_1E6E2AA50;
  *(_QWORD *)(v30 + 8) = 0;
  *(_QWORD *)(v30 + 16) = 0;
  *(_QWORD *)(v30 + 24) = 10;
  *(_QWORD *)(v30 + 32) = v31 + 1;
  *(_QWORD *)(v30 + 40) = v31;
  do
    v34 = __ldxr(v32);
  while (__stxr(v34 + 1, v32));
  *(_QWORD *)(v30 + 48) = v33;
  *(_OWORD *)(v30 + 56) = 0u;
  *(_OWORD *)(v30 + 72) = 0u;
  *(_QWORD *)(v30 + 88) = 850045863;
  *(_OWORD *)(v30 + 96) = 0u;
  *(_OWORD *)(v30 + 112) = 0u;
  *(_OWORD *)(v30 + 128) = 0u;
  *(_QWORD *)(v30 + 144) = 0;
  do
    v35 = __ldaxr(v32);
  while (__stlxr(v35 - 1, v32));
  if (!v35)
  {
    ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
    std::__shared_weak_count::__release_weak(v31);
  }
  *((_QWORD *)this + 18) = v30;
  v36 = (std::__shared_weak_count *)operator new();
  v36->__shared_owners_ = 0;
  v37 = (unint64_t *)&v36->__shared_owners_;
  v36->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6E2AE10;
  v36->__shared_weak_owners_ = 0;
  v36[1].__vftable = (std::__shared_weak_count_vtbl *)v30;
  *((_QWORD *)this + 19) = v36;
  v38 = *(std::__shared_weak_count **)(v30 + 16);
  if (v38)
  {
    if (v38->__shared_owners_ != -1)
      goto LABEL_57;
    do
      v39 = __ldxr(v37);
    while (__stxr(v39 + 1, v37));
    v40 = (unint64_t *)&v36->__shared_weak_owners_;
    do
      v41 = __ldxr(v40);
    while (__stxr(v41 + 1, v40));
    *(_QWORD *)(v30 + 8) = v30;
    *(_QWORD *)(v30 + 16) = v36;
    std::__shared_weak_count::__release_weak(v38);
  }
  else
  {
    do
      v42 = __ldxr(v37);
    while (__stxr(v42 + 1, v37));
    v43 = (unint64_t *)&v36->__shared_weak_owners_;
    do
      v44 = __ldxr(v43);
    while (__stxr(v44 + 1, v43));
    *(_QWORD *)(v30 + 8) = v30;
    *(_QWORD *)(v30 + 16) = v36;
  }
  do
    v45 = __ldaxr(v37);
  while (__stlxr(v45 - 1, v37));
  if (!v45)
  {
    ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
    std::__shared_weak_count::__release_weak(v36);
  }
LABEL_57:
  v46 = *(_QWORD *)v29;
  v47 = *(_QWORD *)(*(_QWORD *)v29 + 8);
  v48 = *(std::__shared_weak_count **)(*(_QWORD *)v29 + 16);
  if (v48)
  {
    v49 = (unint64_t *)&v48->__shared_weak_owners_;
    do
      v50 = __ldxr(v49);
    while (__stxr(v50 + 1, v49));
    v51 = *(_QWORD *)(v46 + 48);
    do
      v52 = __ldxr(v49);
    while (__stxr(v52 + 1, v49));
  }
  else
  {
    v51 = *(_QWORD *)(v46 + 48);
  }
  v81 = &off_1E6E2AC08;
  v82 = v47;
  v83 = v48;
  v84 = &v81;
  (*(void (**)(uint64_t, uint64_t (***)()))(*(_QWORD *)v51 + 16))(v51, &v81);
  v53 = v84;
  if (v84 == &v81)
  {
    v54 = 4;
    v53 = &v81;
  }
  else
  {
    if (!v84)
      goto LABEL_69;
    v54 = 5;
  }
  (*v53)[v54]();
LABEL_69:
  if (v48)
    std::__shared_weak_count::__release_weak(v48);
  *((_QWORD *)this + 20) = 0;
  *((_QWORD *)this + 21) = 0;
  v55 = (char *)this + 160;
  v56 = operator new();
  v57 = (std::__shared_weak_count *)operator new(0x20uLL);
  v57->__shared_owners_ = 0;
  v58 = (unint64_t *)&v57->__shared_owners_;
  v57->__shared_weak_owners_ = 0;
  v57->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6E2AC50;
  v57[1].__vftable = (std::__shared_weak_count_vtbl *)&off_1E6E2A938;
  if (analytics::XpcActivityScheduler::getInstance(void)::t != -1)
    dispatch_once(&analytics::XpcActivityScheduler::getInstance(void)::t, &__block_literal_global_1487);
  v59 = analytics::XpcActivityScheduler::getInstance(void)::instance;
  *(_QWORD *)v56 = &off_1E6E2AA00;
  *(_QWORD *)(v56 + 8) = 0;
  *(_QWORD *)(v56 + 16) = 0;
  *(_QWORD *)(v56 + 24) = 10;
  *(_QWORD *)(v56 + 32) = v57 + 1;
  *(_QWORD *)(v56 + 40) = v57;
  do
    v60 = __ldxr(v58);
  while (__stxr(v60 + 1, v58));
  *(_QWORD *)(v56 + 48) = v59;
  *(_OWORD *)(v56 + 56) = 0u;
  *(_OWORD *)(v56 + 72) = 0u;
  *(_QWORD *)(v56 + 88) = 850045863;
  *(_OWORD *)(v56 + 96) = 0u;
  *(_OWORD *)(v56 + 112) = 0u;
  *(_OWORD *)(v56 + 128) = 0u;
  *(_QWORD *)(v56 + 144) = 0;
  do
    v61 = __ldaxr(v58);
  while (__stlxr(v61 - 1, v58));
  if (!v61)
  {
    ((void (*)(std::__shared_weak_count *))v57->__on_zero_shared)(v57);
    std::__shared_weak_count::__release_weak(v57);
  }
  *((_QWORD *)this + 20) = v56;
  v62 = (std::__shared_weak_count *)operator new();
  v62->__shared_owners_ = 0;
  v63 = (unint64_t *)&v62->__shared_owners_;
  v62->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6E2ADA0;
  v62->__shared_weak_owners_ = 0;
  v62[1].__vftable = (std::__shared_weak_count_vtbl *)v56;
  *((_QWORD *)this + 21) = v62;
  v64 = *(std::__shared_weak_count **)(v56 + 16);
  if (v64)
  {
    if (v64->__shared_owners_ != -1)
      goto LABEL_92;
    do
      v65 = __ldxr(v63);
    while (__stxr(v65 + 1, v63));
    v66 = (unint64_t *)&v62->__shared_weak_owners_;
    do
      v67 = __ldxr(v66);
    while (__stxr(v67 + 1, v66));
    *(_QWORD *)(v56 + 8) = v56;
    *(_QWORD *)(v56 + 16) = v62;
    std::__shared_weak_count::__release_weak(v64);
  }
  else
  {
    do
      v68 = __ldxr(v63);
    while (__stxr(v68 + 1, v63));
    v69 = (unint64_t *)&v62->__shared_weak_owners_;
    do
      v70 = __ldxr(v69);
    while (__stxr(v70 + 1, v69));
    *(_QWORD *)(v56 + 8) = v56;
    *(_QWORD *)(v56 + 16) = v62;
  }
  do
    v71 = __ldaxr(v63);
  while (__stlxr(v71 - 1, v63));
  if (!v71)
  {
    ((void (*)(std::__shared_weak_count *))v62->__on_zero_shared)(v62);
    std::__shared_weak_count::__release_weak(v62);
  }
LABEL_92:
  v72 = *(_QWORD *)v55;
  v73 = *(_QWORD *)(*(_QWORD *)v55 + 8);
  v74 = *(std::__shared_weak_count **)(*(_QWORD *)v55 + 16);
  if (v74)
  {
    v75 = (unint64_t *)&v74->__shared_weak_owners_;
    do
      v76 = __ldxr(v75);
    while (__stxr(v76 + 1, v75));
    v77 = *(_QWORD *)(v72 + 48);
    do
      v78 = __ldxr(v75);
    while (__stxr(v78 + 1, v75));
  }
  else
  {
    v77 = *(_QWORD *)(v72 + 48);
  }
  v81 = &off_1E6E2AB78;
  v82 = v73;
  v83 = v74;
  v84 = &v81;
  (*(void (**)(uint64_t, uint64_t (***)()))(*(_QWORD *)v77 + 16))(v77, &v81);
  v79 = v84;
  if (v84 == &v81)
  {
    v80 = 4;
    v79 = &v81;
  }
  else
  {
    if (!v84)
      goto LABEL_104;
    v80 = 5;
  }
  (*v79)[v80]();
LABEL_104:
  if (v74)
    std::__shared_weak_count::__release_weak(v74);
  *((_DWORD *)this + 44) = -1;
  *((_QWORD *)this + 23) = 0;
}

void DocStore::~DocStore(DocStore *this)
{
  _QWORD *v2;
  void *v3;
  void *v4;
  void *v5;
  int v6;
  uint64_t v7;
  int v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *v13;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;

  v2 = (_QWORD *)*((_QWORD *)this + 1);
  if (v2)
  {
    v3 = (void *)v2[7];
    if (v3)
    {
      v2[8] = v3;
      operator delete(v3);
    }
    v4 = (void *)v2[4];
    if (v4)
    {
      v2[5] = v4;
      operator delete(v4);
    }
    v5 = (void *)v2[1];
    if (v5)
    {
      v2[2] = v5;
      operator delete(v5);
    }
    MEMORY[0x1BCCB06A4](v2, 0x1010C40CE421770);
  }
  v6 = *((_DWORD *)this + 1);
  if ((v6 & 0x80000000) == 0)
    close(v6);
  v7 = *((_QWORD *)this + 23);
  if (v7)
  {
    FileBackedBloomMap::unmap(*((FileBackedBloomMap **)this + 23));
    MEMORY[0x1BCCB06A4](v7, 0x1010C4095F1AE09);
  }
  v8 = *((_DWORD *)this + 44);
  if ((v8 & 0x80000000) == 0)
    close(v8);
  v9 = (std::__shared_weak_count *)*((_QWORD *)this + 21);
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v11 = __ldaxr(p_shared_owners);
    while (__stlxr(v11 - 1, p_shared_owners));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  v12 = (std::__shared_weak_count *)*((_QWORD *)this + 19);
  if (v12)
  {
    v13 = (unint64_t *)&v12->__shared_owners_;
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  v15 = (std::__shared_weak_count *)*((_QWORD *)this + 17);
  if (v15)
  {
    v16 = (unint64_t *)&v15->__shared_owners_;
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  std::mutex::~mutex((std::mutex *)((char *)this + 40));
  v18 = *((_QWORD *)this + 2);
  if (v18)
  {
    v19 = *((_QWORD *)this + 3);
    v20 = (void *)*((_QWORD *)this + 2);
    if (v19 != v18)
    {
      do
      {
        if (*(char *)(v19 - 9) < 0)
          operator delete(*(void **)(v19 - 32));
        v19 -= 32;
      }
      while (v19 != v18);
      v20 = (void *)*((_QWORD *)this + 2);
    }
    *((_QWORD *)this + 3) = v18;
    operator delete(v20);
  }
}

void ScopeLogger::~ScopeLogger(ScopeLogger *this)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  NSObject *v5;
  os_log_type_t v6;
  uint64_t v7;
  double v8;
  _BYTE v9[22];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)v9 = 0;
  *(_QWORD *)&v9[8] = 0;
  clock_gettime(_CLOCK_REALTIME, (timespec *)v9);
  v2 = *(_QWORD *)v9;
  v3 = *(_QWORD *)&v9[8];
  v4 = *__error();
  v5 = _SILogForLogForCategory(8);
  v6 = 2 * (dword_1EF19FCAC < 4);
  if (os_log_type_enabled(v5, v6))
  {
    v7 = *(_QWORD *)this;
    v8 = (double)(unint64_t)(v3 + 1000000000 * v2 - *((_QWORD *)this + 1)) * 0.000001;
    *(_DWORD *)v9 = 136315394;
    *(_QWORD *)&v9[4] = v7;
    *(_WORD *)&v9[12] = 2048;
    *(double *)&v9[14] = v8;
    _os_log_impl(&dword_1B8270000, v5, v6, "%s exit; call took %.6fms", v9, 0x16u);
  }
  *__error() = v4;
}

int *DocStore::init_file_backed_bloom_map(int *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  FileBackedBloomMap *v4;
  int v5;
  int v6;
  NSObject *v7;
  os_log_type_t v8;
  const char *v9;
  int v10;
  int v11;
  char *v12;
  char path[16];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  if (!*((_QWORD *)this + 23))
  {
    v1 = (uint64_t)this;
    strcpy(path, "tmp.XXXXXX");
    v2 = mkstempsat_np(*this, path, 0);
    if ((v2 & 0x80000000) != 0)
    {
      v10 = *__error();
      v6 = *__error();
      v7 = _SILogForLogForCategory(8);
      v8 = dword_1EF19FCAC < 3;
      if (os_log_type_enabled(v7, (os_log_type_t)(dword_1EF19FCAC < 3)))
      {
        v11 = 136315138;
        v12 = strerror(v10);
        v9 = "*warn* init_file_backed_bloom_map: mkstempsat_np: %s";
        goto LABEL_9;
      }
LABEL_10:
      this = __error();
      *this = v6;
      return this;
    }
    v3 = v2;
    unlinkat(*(_DWORD *)v1, path, 0);
    *(_DWORD *)(v1 + 176) = v3;
    *(_QWORD *)(v1 + 184) = 0;
    v4 = (FileBackedBloomMap *)operator new();
    *(_DWORD *)v4 = v3;
    *((_QWORD *)v4 + 2) = 0;
    *((_QWORD *)v4 + 3) = 0;
    *((_QWORD *)v4 + 1) = 0;
    *((_QWORD *)v4 + 4) = 0xA0000CCCCLL;
    if (_fd_ftruncate(v3, 0))
    {
      this = __error();
      v5 = -*this;
      if (*this)
        goto LABEL_5;
    }
    else
    {
      this = (int *)FileBackedBloomMap::grow(v4);
      v5 = (int)this;
      if ((_DWORD)this)
      {
LABEL_5:
        v6 = *__error();
        v7 = _SILogForLogForCategory(8);
        v8 = dword_1EF19FCAC < 3;
        if (os_log_type_enabled(v7, (os_log_type_t)(dword_1EF19FCAC < 3)))
        {
          v11 = 136315138;
          v12 = strerror(-v5);
          v9 = "*warn* init_file_backed_bloom_map: map_create: %s";
LABEL_9:
          _os_log_impl(&dword_1B8270000, v7, v8, v9, (uint8_t *)&v11, 0xCu);
          goto LABEL_10;
        }
        goto LABEL_10;
      }
    }
    *(_QWORD *)(v1 + 184) = v4;
  }
  return this;
}

uint64_t std::__throw_bad_optional_access[abi:nn180100]()
{
  std::__libcpp_verbose_abort("bad_optional_access was thrown in -fno-exceptions mode");
  return std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *,false>();
}

void std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *,false>(__n128 *a1, __n128 *a2, uint64_t a3, char a4)
{
  unint64_t *v8;
  unint64_t *v9;
  __n128 *v10;
  uint64_t v11;
  unint64_t v12;
  __n128 *v13;
  uint64_t v14;
  _QWORD *v15;
  __n128 v16;
  unint64_t v17;
  __n128 v18;
  __n128 v19;
  __n128 *v20;
  __n128 *v21;
  __n128 *v22;
  __n128 *v23;
  __n128 v24;
  unint64_t v25;
  unint64_t v26;
  __int8 *v27;
  __n128 v28;
  __n128 v29;
  BOOL v30;
  __n128 v31;
  __n128 *v32;
  _BOOL4 v33;
  __n128 *v34;
  __n128 v35;
  __n128 v36;
  __n128 v37;
  __int8 *v38;
  __n128 v39;
  __n128 v40;
  __n128 v41;
  __n128 v42;
  __n128 v43;
  __n128 *v44;
  BOOL v46;
  uint64_t v47;
  __n128 *v48;
  __n128 *v49;
  __n128 v50;
  uint64_t v51;
  char *v52;
  uint64_t v53;
  __n128 v54;
  int64_t v55;
  int64_t v56;
  int64_t v57;
  uint64_t v58;
  char *v59;
  unint64_t *v60;
  __n128 v61;
  unint64_t *v62;
  __int128 v63;
  uint64_t v64;
  uint64_t v65;
  __n128 v66;
  int64_t v67;
  __n128 *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  __n128 v76;
  __n128 v77;
  unint64_t v78;
  uint64_t v79;
  int64_t v80;
  unint64_t v81;
  char *v82;
  __n128 v83;
  uint64_t v84;
  __int128 v85;
  __n128 v86;
  uint64_t v87;
  BOOL v88;
  __n128 *v89;
  __n128 v90;
  __n128 *v91;
  __n128 *v92;
  BOOL v93;
  __n128 v94;
  unint64_t v95;
  __n128 *v96;
  unsigned __int8 v97;
  __n128 *v98;
  __n128 v99;
  unint64_t v100;
  __n128 v101;
  unint64_t v102;
  uint64_t v103;

  v103 = *MEMORY[0x1E0C80C00];
LABEL_2:
  v8 = &a2[-2].n128_u64[1];
  v96 = a2 - 3;
  v98 = a2;
  v9 = &a2[-5].n128_u64[1];
  v10 = a1;
  while (2)
  {
    a1 = v10;
    v11 = (char *)a2 - (char *)v10;
    v12 = 0xAAAAAAAAAAAAAAABLL * (v11 >> 3);
    switch(v12)
    {
      case 0uLL:
      case 1uLL:
        return;
      case 2uLL:
        if (std::less<std::string>::operator()[abi:nn180100](v8, a1))
        {
          v41 = *a1;
          v100 = a1[1].n128_u64[0];
          v99 = v41;
          v42 = *(__n128 *)v8;
          a1[1].n128_u64[0] = v8[2];
          *a1 = v42;
          v43 = v99;
          v8[2] = v100;
          *(__n128 *)v8 = v43;
        }
        return;
      case 3uLL:
        std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(a1, &a1[1].n128_u64[1], v8);
        return;
      case 4uLL:
        std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(a1, &a1[1].n128_u64[1], (__n128 *)a1[3].n128_u64, v8);
        return;
      case 5uLL:
        std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(a1, &a1[1].n128_u64[1], (__n128 *)a1[3].n128_u64, &a1[4].n128_u64[1], v8);
        return;
      default:
        if (v11 <= 575)
        {
          v44 = (__n128 *)((char *)a1 + 24);
          v46 = a1 == a2 || v44 == a2;
          if ((a4 & 1) != 0)
          {
            if (!v46)
            {
              v47 = 0;
              v48 = a1;
              do
              {
                v49 = v48;
                v48 = v44;
                if (std::less<std::string>::operator()[abi:nn180100](v44, v49))
                {
                  v50 = *v48;
                  v100 = v48[1].n128_u64[0];
                  v99 = v50;
                  v48->n128_u64[1] = 0;
                  v48[1].n128_u64[0] = 0;
                  v48->n128_u64[0] = 0;
                  v51 = v47;
                  while (1)
                  {
                    v52 = (char *)a1 + v51;
                    *(__n128 *)(v52 + 24) = *(__n128 *)((char *)a1 + v51);
                    *((_QWORD *)v52 + 5) = *(unint64_t *)((char *)a1[1].n128_u64 + v51);
                    v52[23] = 0;
                    *v52 = 0;
                    if (!v51)
                      break;
                    v51 -= 24;
                    if (!std::less<std::string>::operator()[abi:nn180100](&v99, (unint64_t *)((char *)a1->n128_u64 + v51)))
                    {
                      v53 = (uint64_t)&a1[1].n128_i64[1] + v51;
                      goto LABEL_82;
                    }
                  }
                  v53 = (uint64_t)a1;
LABEL_82:
                  v54 = v99;
                  *(_QWORD *)(v53 + 16) = v100;
                  *(__n128 *)v53 = v54;
                }
                v44 = (__n128 *)((char *)v48 + 24);
                v47 += 24;
              }
              while (&v48[1].n128_i8[8] != (__int8 *)a2);
            }
          }
          else if (!v46)
          {
            do
            {
              v89 = a1;
              a1 = v44;
              if (std::less<std::string>::operator()[abi:nn180100](v44, v89))
              {
                v90 = *a1;
                v100 = a1[1].n128_u64[0];
                v99 = v90;
                a1->n128_u64[1] = 0;
                a1[1].n128_u64[0] = 0;
                a1->n128_u64[0] = 0;
                v91 = a1;
                do
                {
                  v92 = (__n128 *)((char *)v91 - 24);
                  *v91 = *(__n128 *)((char *)v91 - 24);
                  v91[1].n128_u64[0] = v91[-1].n128_u64[1];
                  v91[-1].n128_u8[15] = 0;
                  v91[-2].n128_u8[8] = 0;
                  v93 = std::less<std::string>::operator()[abi:nn180100](&v99, (__n128 *)v91[-3].n128_u64);
                  v91 = v92;
                }
                while (v93);
                v94 = v99;
                v92[1].n128_u64[0] = v100;
                *v92 = v94;
              }
              v44 = (__n128 *)((char *)a1 + 24);
            }
            while (&a1[1].n128_i8[8] != (__int8 *)a2);
          }
          return;
        }
        if (!a3)
        {
          if (a1 != a2)
          {
            v55 = (v12 - 2) >> 1;
            v56 = v55;
            do
            {
              v57 = v56;
              if (v55 >= v56)
              {
                v58 = (2 * v56) | 1;
                v59 = (char *)a1 + 24 * v58;
                if (2 * v56 + 2 < (uint64_t)v12
                  && std::less<std::string>::operator()[abi:nn180100](&a1->n128_u64[3 * v58], (_QWORD *)v59 + 3))
                {
                  v59 += 24;
                  v58 = 2 * v57 + 2;
                }
                v60 = &a1->n128_u64[3 * v57];
                a2 = v98;
                if (!std::less<std::string>::operator()[abi:nn180100](v59, v60))
                {
                  v61 = *(__n128 *)v60;
                  v100 = v60[2];
                  v99 = v61;
                  v60[1] = 0;
                  v60[2] = 0;
                  *v60 = 0;
                  do
                  {
                    v62 = (unint64_t *)v59;
                    v63 = *(_OWORD *)v59;
                    v60[2] = *((_QWORD *)v59 + 2);
                    *(_OWORD *)v60 = v63;
                    v59[23] = 0;
                    *v59 = 0;
                    if (v55 < v58)
                      break;
                    v64 = (2 * v58) | 1;
                    v59 = (char *)a1 + 24 * v64;
                    v65 = 2 * v58 + 2;
                    if (v65 < (uint64_t)v12
                      && std::less<std::string>::operator()[abi:nn180100](&a1->n128_u64[3 * v64], (_QWORD *)v59 + 3))
                    {
                      v59 += 24;
                      v64 = v65;
                    }
                    v60 = v62;
                    v58 = v64;
                  }
                  while (!std::less<std::string>::operator()[abi:nn180100](v59, &v99));
                  v66 = v99;
                  v62[2] = v100;
                  *(__n128 *)v62 = v66;
                  a2 = v98;
                }
              }
              v56 = v57 - 1;
            }
            while (v57);
            v67 = v11 / 0x18uLL;
            do
            {
              v68 = a2;
              v69 = 0;
              v95 = a1->n128_u64[0];
              v101.n128_u64[0] = a1->n128_u64[1];
              *(unint64_t *)((char *)v101.n128_u64 + 7) = *(unint64_t *)((char *)&a1->n128_u64[1] + 7);
              v97 = a1[1].n128_u8[7];
              a1->n128_u64[1] = 0;
              a1[1].n128_u64[0] = 0;
              a1->n128_u64[0] = 0;
              v70 = v67 - 2;
              if (v67 < 2)
                v70 = v67 - 1;
              v71 = v70 >> 1;
              v72 = (uint64_t)a1;
              do
              {
                v73 = v72 + 24 * v69 + 24;
                v74 = 2 * v69;
                v69 = (2 * v69) | 1;
                v75 = v74 + 2;
                if (v74 + 2 < v67
                  && std::less<std::string>::operator()[abi:nn180100]((_QWORD *)v73, (_QWORD *)(v73 + 24)))
                {
                  v73 += 24;
                  v69 = v75;
                }
                if (*(char *)(v72 + 23) < 0)
                  operator delete(*(void **)v72);
                v76 = *(__n128 *)v73;
                *(_QWORD *)(v72 + 16) = *(_QWORD *)(v73 + 16);
                *(__n128 *)v72 = v76;
                *(_BYTE *)(v73 + 23) = 0;
                *(_BYTE *)v73 = 0;
                v72 = v73;
              }
              while (v69 <= v71);
              a2 = (__n128 *)((char *)v68 - 24);
              if ((__int8 *)v73 == &v68[-2].n128_i8[8])
              {
                *(_QWORD *)v73 = v95;
                v87 = *(uint64_t *)((char *)v101.n128_i64 + 7);
                *(_QWORD *)(v73 + 8) = v101.n128_u64[0];
                *(_QWORD *)(v73 + 15) = v87;
                *(_BYTE *)(v73 + 23) = v97;
                v80 = v67 - 1;
              }
              else
              {
                v77 = *a2;
                *(_QWORD *)(v73 + 16) = v68[-1].n128_u64[1];
                *(__n128 *)v73 = v77;
                v68[-2].n128_u64[1] = v95;
                v78 = v101.n128_u64[0];
                *(unint64_t *)((char *)v68[-1].n128_u64 + 7) = *(unint64_t *)((char *)v101.n128_u64 + 7);
                v68[-1].n128_u64[0] = v78;
                v68[-1].n128_u8[15] = v97;
                v79 = v73 - (_QWORD)a1 + 24;
                v80 = v67 - 1;
                if (v79 >= 25)
                {
                  v81 = (unint64_t)(-2 - 0x5555555555555555 * (v79 >> 3)) >> 1;
                  v82 = (char *)a1 + 24 * v81;
                  if (std::less<std::string>::operator()[abi:nn180100](v82, (_QWORD *)v73))
                  {
                    v83 = *(__n128 *)v73;
                    v100 = *(_QWORD *)(v73 + 16);
                    v99 = v83;
                    *(_QWORD *)(v73 + 8) = 0;
                    *(_QWORD *)(v73 + 16) = 0;
                    *(_QWORD *)v73 = 0;
                    do
                    {
                      v84 = (uint64_t)v82;
                      v85 = *(_OWORD *)v82;
                      *(_QWORD *)(v73 + 16) = *((_QWORD *)v82 + 2);
                      *(_OWORD *)v73 = v85;
                      v82[23] = 0;
                      *v82 = 0;
                      if (!v81)
                        break;
                      v81 = (v81 - 1) >> 1;
                      v82 = (char *)a1 + 24 * v81;
                      v73 = v84;
                    }
                    while (std::less<std::string>::operator()[abi:nn180100](v82, &v99));
                    v86 = v99;
                    *(_QWORD *)(v84 + 16) = v100;
                    *(__n128 *)v84 = v86;
                  }
                }
              }
              v88 = v67 <= 2;
              v67 = v80;
            }
            while (!v88);
          }
          return;
        }
        v13 = (__n128 *)((char *)a1 + 24 * (v12 >> 1));
        if ((unint64_t)v11 < 0xC01)
        {
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(&a1->n128_u64[3 * (v12 >> 1)], a1, v8);
        }
        else
        {
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(a1, &a1->n128_u64[3 * (v12 >> 1)], v8);
          v14 = 3 * (v12 >> 1);
          v15 = (_QWORD *)&a1[-1] + 3 * (v12 >> 1) - 1;
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(&a1[1].n128_u64[1], v15, v96);
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>((__n128 *)a1[3].n128_u64, &a1[1].n128_u64[v14 + 1], v9);
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(v15, v13, &a1[1].n128_u64[v14 + 1]);
          v16 = *a1;
          v100 = a1[1].n128_u64[0];
          v99 = v16;
          v17 = v13[1].n128_u64[0];
          *a1 = *v13;
          a1[1].n128_u64[0] = v17;
          v18 = v99;
          v13[1].n128_u64[0] = v100;
          *v13 = v18;
        }
        --a3;
        a2 = v98;
        if ((a4 & 1) == 0 && !std::less<std::string>::operator()[abi:nn180100](&a1[-2].n128_u64[1], a1))
        {
          v31 = *a1;
          v102 = a1[1].n128_u64[0];
          v101 = v31;
          a1->n128_u64[1] = 0;
          a1[1].n128_u64[0] = 0;
          a1->n128_u64[0] = 0;
          if (std::less<std::string>::operator()[abi:nn180100](&v101, v8))
          {
            v10 = a1;
            do
              v10 = (__n128 *)((char *)v10 + 24);
            while (!std::less<std::string>::operator()[abi:nn180100](&v101, v10));
          }
          else
          {
            v32 = (__n128 *)((char *)a1 + 24);
            do
            {
              v10 = v32;
              if (v32 >= v98)
                break;
              v33 = std::less<std::string>::operator()[abi:nn180100](&v101, v32);
              v32 = (__n128 *)((char *)v10 + 24);
            }
            while (!v33);
          }
          v34 = v98;
          if (v10 < v98)
          {
            v34 = v98;
            do
              v34 = (__n128 *)((char *)v34 - 24);
            while (std::less<std::string>::operator()[abi:nn180100](&v101, v34));
          }
          while (v10 < v34)
          {
            v35 = *v10;
            v100 = v10[1].n128_u64[0];
            v99 = v35;
            v36 = *v34;
            v10[1].n128_u64[0] = v34[1].n128_u64[0];
            *v10 = v36;
            v37 = v99;
            v34[1].n128_u64[0] = v100;
            *v34 = v37;
            do
              v10 = (__n128 *)((char *)v10 + 24);
            while (!std::less<std::string>::operator()[abi:nn180100](&v101, v10));
            do
              v34 = (__n128 *)((char *)v34 - 24);
            while (std::less<std::string>::operator()[abi:nn180100](&v101, v34));
          }
          v38 = &v10[-2].n128_i8[8];
          if (&v10[-2].n128_i8[8] == (__int8 *)a1)
          {
            if (v10[-1].n128_i8[15] < 0)
              operator delete((void *)a1->n128_u64[0]);
          }
          else
          {
            if (a1[1].n128_i8[7] < 0)
              operator delete((void *)a1->n128_u64[0]);
            v39 = *(__n128 *)v38;
            a1[1].n128_u64[0] = v10[-1].n128_u64[1];
            *a1 = v39;
            v10[-1].n128_u8[15] = 0;
            v10[-2].n128_u8[8] = 0;
          }
          a4 = 0;
          v40 = v101;
          v10[-1].n128_u64[1] = v102;
          *(__n128 *)v38 = v40;
          continue;
        }
        v19 = *a1;
        v102 = a1[1].n128_u64[0];
        v101 = v19;
        a1->n128_u64[1] = 0;
        a1[1].n128_u64[0] = 0;
        a1->n128_u64[0] = 0;
        v20 = a1;
        do
        {
          v21 = v20;
          v20 = (__n128 *)((char *)v20 + 24);
        }
        while (std::less<std::string>::operator()[abi:nn180100](v20, &v101));
        v22 = v98;
        if (v21 == a1)
        {
          v22 = v98;
          do
          {
            if (v20 >= v22)
              break;
            v22 = (__n128 *)((char *)v22 - 24);
          }
          while (!std::less<std::string>::operator()[abi:nn180100](v22, &v101));
        }
        else
        {
          do
            v22 = (__n128 *)((char *)v22 - 24);
          while (!std::less<std::string>::operator()[abi:nn180100](v22, &v101));
        }
        if (v20 >= v22)
        {
          v10 = v20;
        }
        else
        {
          v23 = v22;
          v10 = v20;
          do
          {
            v99 = *v10;
            v24 = v99;
            v100 = v10[1].n128_u64[0];
            v25 = v100;
            v26 = v23[1].n128_u64[0];
            *v10 = *v23;
            v10[1].n128_u64[0] = v26;
            v23[1].n128_u64[0] = v25;
            *v23 = v24;
            do
              v10 = (__n128 *)((char *)v10 + 24);
            while (std::less<std::string>::operator()[abi:nn180100](v10, &v101));
            do
              v23 = (__n128 *)((char *)v23 - 24);
            while (!std::less<std::string>::operator()[abi:nn180100](v23, &v101));
          }
          while (v10 < v23);
        }
        v27 = &v10[-2].n128_i8[8];
        if (&v10[-2].n128_i8[8] == (__int8 *)a1)
        {
          if (v10[-1].n128_i8[15] < 0)
            operator delete((void *)a1->n128_u64[0]);
        }
        else
        {
          if (a1[1].n128_i8[7] < 0)
            operator delete((void *)a1->n128_u64[0]);
          v28 = *(__n128 *)v27;
          a1[1].n128_u64[0] = v10[-1].n128_u64[1];
          *a1 = v28;
          v10[-1].n128_u8[15] = 0;
          v10[-2].n128_u8[8] = 0;
        }
        v29 = v101;
        v10[-1].n128_u64[1] = v102;
        *(__n128 *)v27 = v29;
        if (v20 < v22)
        {
LABEL_36:
          std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *,false>(a1, &v10[-2].n128_i8[8], a3, a4 & 1);
          a4 = 0;
          continue;
        }
        v30 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(a1, (__n128 *)((char *)v10 - 24));
        if (!std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(v10, v98))
        {
          if (v30)
            continue;
          goto LABEL_36;
        }
        a2 = (__n128 *)((char *)v10 - 24);
        if (!v30)
          goto LABEL_2;
        return;
    }
  }
}

void std::__introsort<std::_ClassicAlgPolicy,DocStore::load(analytics::OpenEvent *,BOOL)::{lambda(DocStore::ColdShardDescriptor const&,DocStore::ColdShardDescriptor const&)#1} &,DocStore::ColdShardDescriptor*,false>(uint64_t *a1, const void **a2, uint64_t a3, char a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const void **v11;
  uint64_t v12;
  uint64_t v13;
  __int16 v14;
  __int128 v15;
  uint64_t v16;
  int v17;
  int v18;
  size_t v19;
  uint64_t *v20;
  size_t v21;
  const void *v22;
  size_t v23;
  int v24;
  BOOL v25;
  uint64_t v26;
  __int128 v27;
  __int16 v28;
  size_t v29;
  __int128 *v30;
  int v31;
  size_t v32;
  const void *v33;
  size_t v34;
  int v35;
  BOOL v36;
  unint64_t v37;
  int v38;
  size_t v39;
  const void *v40;
  size_t v41;
  int v42;
  BOOL v43;
  uint64_t *v44;
  int v45;
  size_t v46;
  const void *v47;
  size_t v48;
  int v49;
  BOOL v50;
  uint64_t *v51;
  uint64_t *v52;
  size_t v53;
  size_t v54;
  const void *v55;
  size_t v56;
  int v57;
  BOOL v58;
  uint64_t *v59;
  size_t v60;
  size_t v61;
  const void *v62;
  size_t v63;
  int v64;
  _BOOL4 v65;
  void **v66;
  __int128 v67;
  __int128 v68;
  BOOL v69;
  __int128 v70;
  __int16 v71;
  int v72;
  size_t v73;
  __int128 *v74;
  size_t v75;
  const void **v76;
  size_t v77;
  int v78;
  BOOL v79;
  const void **v80;
  int v81;
  size_t v82;
  const void *v83;
  size_t v84;
  int v85;
  BOOL v86;
  uint64_t *v87;
  int v88;
  size_t v89;
  const void *v90;
  size_t v91;
  int v92;
  BOOL v93;
  uint64_t *v94;
  int v95;
  size_t v96;
  const void *v97;
  size_t v98;
  int v99;
  BOOL v100;
  uint64_t *v101;
  size_t v102;
  size_t v103;
  const void *v104;
  size_t v105;
  int v106;
  _BOOL4 v107;
  uint64_t *v108;
  size_t v109;
  size_t v110;
  const void *v111;
  size_t v112;
  int v113;
  BOOL v114;
  void **v115;
  __int128 v116;
  __int128 v117;
  const void *v118;
  uint64_t v119;
  const void *v120;
  int v121;
  int v122;
  size_t v123;
  const void *v124;
  size_t v125;
  const void *v126;
  size_t v127;
  int v128;
  _BOOL4 v129;
  const void **v130;
  uint64_t v131;
  const void **v132;
  const void **v133;
  int v134;
  int v135;
  size_t v136;
  const void **v137;
  size_t v138;
  const void *v139;
  size_t v140;
  int v141;
  _BOOL4 v142;
  const void **v143;
  __int128 v144;
  size_t v145;
  __int128 *v146;
  uint64_t v147;
  uint64_t v148;
  void **v149;
  int v150;
  size_t v151;
  const void *v152;
  size_t v153;
  int v154;
  BOOL v155;
  uint64_t v156;
  __int128 v157;
  int64_t v158;
  int64_t v159;
  int64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  char v164;
  char v165;
  size_t v166;
  const void *v167;
  size_t v168;
  const void *v169;
  size_t v170;
  int v171;
  _BOOL4 v172;
  const void *v173;
  uint64_t v174;
  int v175;
  int v176;
  size_t v177;
  const void *v178;
  size_t v179;
  const void *v180;
  size_t v181;
  int v182;
  BOOL v183;
  __int128 v184;
  uint64_t v185;
  __int128 v186;
  uint64_t v187;
  int v188;
  const void *v189;
  int v190;
  const void *v191;
  size_t v192;
  const void *v193;
  uint64_t v194;
  size_t v195;
  const void *v196;
  size_t v197;
  int v198;
  BOOL v199;
  _BOOL4 v200;
  BOOL v201;
  const void *v202;
  int v203;
  size_t v204;
  const void *v205;
  size_t v206;
  __int128 *v207;
  size_t v208;
  int v209;
  _BOOL4 v210;
  __int128 v211;
  uint64_t v212;
  const void **v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  int v219;
  int v220;
  size_t v221;
  const void *v222;
  size_t v223;
  const void *v224;
  size_t v225;
  int v226;
  _BOOL4 v227;
  __int128 v228;
  void **v229;
  int v230;
  __int128 v231;
  uint64_t v232;
  unint64_t v233;
  unint64_t v234;
  int v235;
  int v236;
  size_t v237;
  const void *v238;
  size_t v239;
  const void *v240;
  size_t v241;
  int v242;
  _BOOL4 v243;
  __int128 v244;
  size_t v245;
  __int128 *v246;
  uint64_t v247;
  __int128 v248;
  int v249;
  size_t v250;
  const void *v251;
  size_t v252;
  int v253;
  BOOL v254;
  __int128 v255;
  const void *v257;
  _WORD *v258;
  uint64_t v259;
  int v260;
  int v261;
  size_t v262;
  const void *v263;
  size_t v264;
  const void *v265;
  size_t v266;
  int v267;
  _BOOL4 v268;
  __int128 v269;
  size_t v270;
  __int128 *v271;
  _WORD *v272;
  void **v273;
  _WORD *v274;
  _WORD *v275;
  int v276;
  _WORD *v277;
  const void *v278;
  size_t v279;
  const void *v280;
  size_t v281;
  int v282;
  BOOL v283;
  __int128 v284;
  uint64_t v285;
  uint64_t *v286;
  uint64_t *v287;
  const void *v288;
  const void **v289;
  const void *v290;
  __int16 v291;
  const void **v292;
  int64_t v293;
  uint64_t v294;
  uint64_t v295;
  int64_t v297;
  char v298;
  const void **v299;
  const void **v300;
  _BYTE v301[15];
  __int128 v302;
  uint64_t v303;
  uint64_t v304;
  uint64_t v305;

  v305 = *MEMORY[0x1E0C80C00];
LABEL_2:
  v7 = (uint64_t)a1;
  v289 = (const void **)(a1 + 8);
  v292 = (const void **)(a1 + 4);
  v286 = a1 - 4;
  v287 = a1 + 1;
  while (2)
  {
    v8 = (uint64_t)a2 - v7;
    v9 = ((uint64_t)a2 - v7) >> 5;
    switch(v9)
    {
      case 0:
      case 1:
        return;
      case 2:
        v120 = *(a2 - 4);
        v119 = (uint64_t)(a2 - 4);
        v118 = v120;
        v121 = *(char *)(v7 + 23);
        v122 = *(char *)(v119 + 23);
        if (v122 >= 0)
          v123 = *(unsigned __int8 *)(v119 + 23);
        else
          v123 = *(_QWORD *)(v119 + 8);
        if (v122 >= 0)
          v124 = (const void *)v119;
        else
          v124 = v118;
        if (v121 >= 0)
          v125 = *(unsigned __int8 *)(v7 + 23);
        else
          v125 = *(_QWORD *)(v7 + 8);
        if (v121 >= 0)
          v126 = (const void *)v7;
        else
          v126 = *(const void **)v7;
        if (v125 >= v123)
          v127 = v123;
        else
          v127 = v125;
        v128 = memcmp(v124, v126, v127);
        v129 = v123 < v125;
        if (v128)
          v129 = v128 < 0;
        if (v129)
          std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<DocStore::ColdShardDescriptor *&,DocStore::ColdShardDescriptor *&>((uint64_t *)v7, v119);
        return;
      case 3:
        std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,DocStore::load(analytics::OpenEvent *,BOOL)::{lambda(DocStore::ColdShardDescriptor const&,DocStore::ColdShardDescriptor const&)#1} &,DocStore::ColdShardDescriptor*>((const void **)v7, v7 + 32, (uint64_t)(a2 - 4));
        return;
      case 4:
        std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,DocStore::load(analytics::OpenEvent *,BOOL)::{lambda(DocStore::ColdShardDescriptor const&,DocStore::ColdShardDescriptor const&)#1} &,DocStore::ColdShardDescriptor*>(v7, v7 + 32, v7 + 64, (uint64_t)(a2 - 4));
        return;
      case 5:
        std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,DocStore::load(analytics::OpenEvent *,BOOL)::{lambda(DocStore::ColdShardDescriptor const&,DocStore::ColdShardDescriptor const&)#1} &,DocStore::ColdShardDescriptor*>(v7, v7 + 32, v7 + 64, v7 + 96, (uint64_t)(a2 - 4));
        return;
      default:
        if (v8 > 767)
        {
          v299 = a2;
          if (!a3)
          {
            if ((const void **)v7 != a2)
            {
              v158 = (unint64_t)(v9 - 2) >> 1;
              v159 = v158;
              v285 = (uint64_t)a2 - v7;
              v295 = v7;
              v297 = v158;
              do
              {
                v160 = v159;
                if (v8 >= 64 && v158 >= v159)
                {
                  v293 = v159;
                  v161 = (2 * v159) | 1;
                  v162 = v7 + 32 * v161;
                  v163 = 2 * v159 + 2;
                  if (v163 >= v9)
                  {
                    v173 = *(const void **)v162;
                  }
                  else
                  {
                    v164 = *(_BYTE *)(v162 + 55);
                    v165 = *(_BYTE *)(v162 + 23);
                    v288 = *(const void **)(v162 + 32);
                    v290 = *(const void **)v162;
                    if (v165 >= 0)
                      v166 = *(unsigned __int8 *)(v162 + 23);
                    else
                      v166 = *(_QWORD *)(v162 + 8);
                    if (v165 >= 0)
                      v167 = (const void *)(v7 + 32 * v161);
                    else
                      v167 = *(const void **)v162;
                    if (v164 >= 0)
                      v168 = *(unsigned __int8 *)(v162 + 55);
                    else
                      v168 = *(_QWORD *)(v162 + 40);
                    if (v164 >= 0)
                      v169 = (const void *)(v162 + 32);
                    else
                      v169 = *(const void **)(v162 + 32);
                    if (v168 >= v166)
                      v170 = v166;
                    else
                      v170 = v168;
                    v171 = memcmp(v167, v169, v170);
                    v172 = v166 < v168;
                    if (v171)
                      v172 = v171 < 0;
                    v201 = !v172;
                    v173 = v290;
                    if (!v201)
                    {
                      v173 = v288;
                      v162 += 32;
                      v161 = v163;
                    }
                  }
                  v160 = v293;
                  v174 = v7 + 32 * v293;
                  v175 = *(char *)(v174 + 23);
                  v176 = *(char *)(v162 + 23);
                  if (v176 >= 0)
                    v177 = *(unsigned __int8 *)(v162 + 23);
                  else
                    v177 = *(_QWORD *)(v162 + 8);
                  if (v176 >= 0)
                    v178 = (const void *)v162;
                  else
                    v178 = v173;
                  if (v175 >= 0)
                    v179 = *(unsigned __int8 *)(v174 + 23);
                  else
                    v179 = *(_QWORD *)(v174 + 8);
                  if (v175 >= 0)
                    v180 = (const void *)(v7 + 32 * v293);
                  else
                    v180 = *(const void **)v174;
                  if (v179 >= v177)
                    v181 = v177;
                  else
                    v181 = v179;
                  v182 = memcmp(v178, v180, v181);
                  v183 = v177 < v179;
                  if (v182)
                    v183 = v182 < 0;
                  v8 = v285;
                  if (!v183)
                  {
                    v304 = 0;
                    v184 = *(_OWORD *)v174;
                    v303 = *(_QWORD *)(v174 + 16);
                    v302 = v184;
                    *(_QWORD *)(v174 + 8) = 0;
                    *(_QWORD *)(v174 + 16) = 0;
                    *(_QWORD *)v174 = 0;
                    LOWORD(v304) = *(_WORD *)(v7 + 32 * v293 + 24);
                    do
                    {
                      v185 = v162;
                      if (*(char *)(v174 + 23) < 0)
                        operator delete(*(void **)v174);
                      v186 = *(_OWORD *)v162;
                      *(_QWORD *)(v174 + 16) = *(_QWORD *)(v162 + 16);
                      *(_OWORD *)v174 = v186;
                      *(_BYTE *)(v162 + 23) = 0;
                      *(_BYTE *)v162 = 0;
                      *(_WORD *)(v174 + 24) = *(_WORD *)(v162 + 24);
                      if (v158 < v161)
                        break;
                      v187 = (2 * v161) | 1;
                      v162 = v7 + 32 * v187;
                      v161 = 2 * v161 + 2;
                      if (v161 >= v9)
                      {
                        v202 = *(const void **)v162;
                        v161 = v187;
                      }
                      else
                      {
                        v188 = *(char *)(v162 + 55);
                        v189 = *(const void **)(v162 + 32);
                        v190 = *(char *)(v162 + 23);
                        v191 = *(const void **)v162;
                        if (v190 >= 0)
                          v192 = *(unsigned __int8 *)(v162 + 23);
                        else
                          v192 = *(_QWORD *)(v162 + 8);
                        if (v190 >= 0)
                          v193 = (const void *)(v7 + 32 * v187);
                        else
                          v193 = *(const void **)v162;
                        v194 = v9;
                        if (v188 >= 0)
                          v195 = *(unsigned __int8 *)(v162 + 55);
                        else
                          v195 = *(_QWORD *)(v162 + 40);
                        if (v188 >= 0)
                          v196 = (const void *)(v162 + 32);
                        else
                          v196 = *(const void **)(v162 + 32);
                        if (v195 >= v192)
                          v197 = v192;
                        else
                          v197 = v195;
                        v198 = memcmp(v193, v196, v197);
                        v199 = v192 >= v195;
                        v9 = v194;
                        v200 = !v199;
                        if (v198)
                          v200 = v198 < 0;
                        v201 = !v200;
                        v202 = v200 ? v189 : v191;
                        v7 = v295;
                        v158 = v297;
                        if (v201)
                          v161 = v187;
                        else
                          v162 += 32;
                      }
                      v203 = *(char *)(v162 + 23);
                      if (v203 >= 0)
                        v204 = *(unsigned __int8 *)(v162 + 23);
                      else
                        v204 = *(_QWORD *)(v162 + 8);
                      if (v203 >= 0)
                        v205 = (const void *)v162;
                      else
                        v205 = v202;
                      if (v303 >= 0)
                        v206 = HIBYTE(v303);
                      else
                        v206 = *((_QWORD *)&v302 + 1);
                      if (v303 >= 0)
                        v207 = &v302;
                      else
                        v207 = (__int128 *)v302;
                      if (v206 >= v204)
                        v208 = v204;
                      else
                        v208 = v206;
                      v209 = memcmp(v205, v207, v208);
                      v210 = v204 < v206;
                      if (v209)
                        v210 = v209 < 0;
                      v174 = v185;
                    }
                    while (!v210);
                    if (*(char *)(v185 + 23) < 0)
                      operator delete(*(void **)v185);
                    v211 = v302;
                    *(_QWORD *)(v185 + 16) = v303;
                    *(_OWORD *)v185 = v211;
                    *(_WORD *)(v185 + 24) = v304;
                    v8 = v285;
                    v160 = v293;
                  }
                }
                v159 = v160 - 1;
              }
              while (v160);
              v212 = (unint64_t)v8 >> 5;
              v213 = v299;
              do
              {
                if (v212 >= 2)
                {
                  v300 = v213;
                  v214 = 0;
                  v294 = *(_QWORD *)v7;
                  *(_QWORD *)v301 = *(_QWORD *)(v7 + 8);
                  *(_QWORD *)&v301[7] = *(_QWORD *)(v7 + 15);
                  v298 = *(_BYTE *)(v7 + 23);
                  *(_QWORD *)(v7 + 8) = 0;
                  *(_QWORD *)(v7 + 16) = 0;
                  *(_QWORD *)v7 = 0;
                  v291 = *(_WORD *)(v7 + 24);
                  v215 = v7;
                  do
                  {
                    v216 = v215 + 32 * v214 + 32;
                    v217 = 2 * v214;
                    v214 = (2 * v214) | 1;
                    v218 = v217 + 2;
                    if (v217 + 2 < v212)
                    {
                      v219 = *(char *)(v216 + 55);
                      v220 = *(char *)(v216 + 23);
                      if (v220 >= 0)
                        v221 = *(unsigned __int8 *)(v216 + 23);
                      else
                        v221 = *(_QWORD *)(v216 + 8);
                      if (v220 >= 0)
                        v222 = (const void *)v216;
                      else
                        v222 = *(const void **)v216;
                      if (v219 >= 0)
                        v223 = *(unsigned __int8 *)(v216 + 55);
                      else
                        v223 = *(_QWORD *)(v216 + 40);
                      if (v219 >= 0)
                        v224 = (const void *)(v216 + 32);
                      else
                        v224 = *(const void **)(v216 + 32);
                      if (v223 >= v221)
                        v225 = v221;
                      else
                        v225 = v223;
                      v226 = memcmp(v222, v224, v225);
                      v227 = v221 < v223;
                      if (v226)
                        v227 = v226 < 0;
                      if (v227)
                      {
                        v216 += 32;
                        v214 = v218;
                      }
                    }
                    if (*(char *)(v215 + 23) < 0)
                      operator delete(*(void **)v215);
                    v228 = *(_OWORD *)v216;
                    *(_QWORD *)(v215 + 16) = *(_QWORD *)(v216 + 16);
                    *(_OWORD *)v215 = v228;
                    *(_BYTE *)(v216 + 23) = 0;
                    *(_BYTE *)v216 = 0;
                    *(_WORD *)(v215 + 24) = *(_WORD *)(v216 + 24);
                    v215 = v216;
                  }
                  while (v214 <= (uint64_t)((unint64_t)(v212 - 2) >> 1));
                  v213 = v300;
                  v229 = (void **)(v300 - 4);
                  v230 = *(char *)(v216 + 23);
                  if ((const void **)v216 == v300 - 4)
                  {
                    if (v230 < 0)
                      operator delete(*(void **)v216);
                    *(_QWORD *)v216 = v294;
                    *(_QWORD *)(v216 + 8) = *(_QWORD *)v301;
                    *(_QWORD *)(v216 + 15) = *(_QWORD *)&v301[7];
                    *(_BYTE *)(v216 + 23) = v298;
                    *(_WORD *)(v216 + 24) = v291;
                  }
                  else
                  {
                    if (v230 < 0)
                      operator delete(*(void **)v216);
                    v231 = *(_OWORD *)v229;
                    *(_QWORD *)(v216 + 16) = *(v300 - 2);
                    *(_OWORD *)v216 = v231;
                    *((_BYTE *)v300 - 9) = 0;
                    *((_BYTE *)v300 - 32) = 0;
                    *(_WORD *)(v216 + 24) = *((_WORD *)v300 - 4);
                    if (*((char *)v300 - 9) < 0)
                      operator delete(*v229);
                    *(v300 - 4) = (const void *)v294;
                    *(const void **)((char *)v300 - 17) = *(const void **)&v301[7];
                    *(v300 - 3) = *(const void **)v301;
                    *((_BYTE *)v300 - 9) = v298;
                    *((_WORD *)v300 - 4) = v291;
                    v232 = v216 + 32 - v7;
                    if (v232 >= 33)
                    {
                      v233 = (unint64_t)((v232 >> 5) - 2) >> 1;
                      v234 = v7 + 32 * v233;
                      v235 = *(char *)(v216 + 23);
                      v236 = *(char *)(v234 + 23);
                      if (v236 >= 0)
                        v237 = *(unsigned __int8 *)(v234 + 23);
                      else
                        v237 = *(_QWORD *)(v234 + 8);
                      if (v236 >= 0)
                        v238 = (const void *)(v7 + 32 * v233);
                      else
                        v238 = *(const void **)v234;
                      if (v235 >= 0)
                        v239 = *(unsigned __int8 *)(v216 + 23);
                      else
                        v239 = *(_QWORD *)(v216 + 8);
                      if (v235 >= 0)
                        v240 = (const void *)v216;
                      else
                        v240 = *(const void **)v216;
                      if (v239 >= v237)
                        v241 = v237;
                      else
                        v241 = v239;
                      v242 = memcmp(v238, v240, v241);
                      v243 = v237 < v239;
                      if (v242)
                        v243 = v242 < 0;
                      if (v243)
                      {
                        v304 = 0;
                        v244 = *(_OWORD *)v216;
                        v303 = *(_QWORD *)(v216 + 16);
                        v302 = v244;
                        *(_QWORD *)(v216 + 8) = 0;
                        *(_QWORD *)(v216 + 16) = 0;
                        *(_QWORD *)v216 = 0;
                        LOWORD(v304) = *(_WORD *)(v216 + 24);
                        if (v303 >= 0)
                          v245 = HIBYTE(v303);
                        else
                          v245 = *((_QWORD *)&v302 + 1);
                        if (v303 >= 0)
                          v246 = &v302;
                        else
                          v246 = (__int128 *)v302;
                        do
                        {
                          v247 = v234;
                          if (*(char *)(v216 + 23) < 0)
                            operator delete(*(void **)v216);
                          v248 = *(_OWORD *)v234;
                          *(_QWORD *)(v216 + 16) = *(_QWORD *)(v234 + 16);
                          *(_OWORD *)v216 = v248;
                          *(_BYTE *)(v234 + 23) = 0;
                          *(_BYTE *)v234 = 0;
                          *(_WORD *)(v216 + 24) = *(_WORD *)(v234 + 24);
                          if (!v233)
                            break;
                          v233 = (v233 - 1) >> 1;
                          v234 = v7 + 32 * v233;
                          v249 = *(char *)(v234 + 23);
                          if (v249 >= 0)
                            v250 = *(unsigned __int8 *)(v234 + 23);
                          else
                            v250 = *(_QWORD *)(v234 + 8);
                          if (v249 >= 0)
                            v251 = (const void *)(v7 + 32 * v233);
                          else
                            v251 = *(const void **)v234;
                          if (v245 >= v250)
                            v252 = v250;
                          else
                            v252 = v245;
                          v253 = memcmp(v251, v246, v252);
                          v254 = v250 < v245;
                          if (v253)
                            v254 = v253 < 0;
                          v216 = v247;
                        }
                        while (v254);
                        if (*(char *)(v247 + 23) < 0)
                          operator delete(*(void **)v247);
                        v255 = v302;
                        *(_QWORD *)(v247 + 16) = v303;
                        *(_OWORD *)v247 = v255;
                        *(_WORD *)(v247 + 24) = v304;
                      }
                    }
                  }
                }
                v213 -= 4;
              }
              while ((unint64_t)v212-- > 2);
            }
            return;
          }
          v10 = v7 + 32 * ((unint64_t)v9 >> 1);
          v11 = a2 - 4;
          if ((unint64_t)v8 <= 0x1000)
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,DocStore::load(analytics::OpenEvent *,BOOL)::{lambda(DocStore::ColdShardDescriptor const&,DocStore::ColdShardDescriptor const&)#1} &,DocStore::ColdShardDescriptor*>((const void **)v10, v7, (uint64_t)(a2 - 4));
          }
          else
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,DocStore::load(analytics::OpenEvent *,BOOL)::{lambda(DocStore::ColdShardDescriptor const&,DocStore::ColdShardDescriptor const&)#1} &,DocStore::ColdShardDescriptor*>((const void **)v7, v10, (uint64_t)(a2 - 4));
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,DocStore::load(analytics::OpenEvent *,BOOL)::{lambda(DocStore::ColdShardDescriptor const&,DocStore::ColdShardDescriptor const&)#1} &,DocStore::ColdShardDescriptor*>(v292, v10 - 32, (uint64_t)(a2 - 8));
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,DocStore::load(analytics::OpenEvent *,BOOL)::{lambda(DocStore::ColdShardDescriptor const&,DocStore::ColdShardDescriptor const&)#1} &,DocStore::ColdShardDescriptor*>(v289, v10 + 32, (uint64_t)(a2 - 12));
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,DocStore::load(analytics::OpenEvent *,BOOL)::{lambda(DocStore::ColdShardDescriptor const&,DocStore::ColdShardDescriptor const&)#1} &,DocStore::ColdShardDescriptor*>((const void **)(v10 - 32), v10, v10 + 32);
            v12 = *(_QWORD *)v7;
            v13 = *v287;
            *(_QWORD *)((char *)&v302 + 7) = *(uint64_t *)((char *)v287 + 7);
            *(_QWORD *)&v302 = v13;
            LOBYTE(v13) = *(_BYTE *)(v7 + 23);
            *(_QWORD *)(v7 + 8) = 0;
            *(_QWORD *)(v7 + 16) = 0;
            *(_QWORD *)v7 = 0;
            v14 = *(_WORD *)(v7 + 24);
            v15 = *(_OWORD *)v10;
            *(_QWORD *)(v7 + 16) = *(_QWORD *)(v10 + 16);
            *(_OWORD *)v7 = v15;
            *(_BYTE *)(v10 + 23) = 0;
            *(_WORD *)(v7 + 24) = *(_WORD *)(v10 + 24);
            *(_QWORD *)v10 = v12;
            v16 = v302;
            *(_QWORD *)(v10 + 15) = *(_QWORD *)((char *)&v302 + 7);
            *(_QWORD *)(v10 + 8) = v16;
            *(_BYTE *)(v10 + 23) = v13;
            *(_WORD *)(v10 + 24) = v14;
          }
          --a3;
          if ((a4 & 1) != 0)
            goto LABEL_28;
          v17 = *(char *)(v7 + 23);
          v18 = *(char *)(v7 - 9);
          if (v18 >= 0)
            v19 = *(unsigned __int8 *)(v7 - 9);
          else
            v19 = *(_QWORD *)(v7 - 24);
          if (v18 >= 0)
            v20 = v286;
          else
            v20 = *(uint64_t **)(v7 - 32);
          if (v17 >= 0)
            v21 = *(unsigned __int8 *)(v7 + 23);
          else
            v21 = *(_QWORD *)(v7 + 8);
          if (v17 >= 0)
            v22 = (const void *)v7;
          else
            v22 = *(const void **)v7;
          if (v21 >= v19)
            v23 = v19;
          else
            v23 = v21;
          v24 = memcmp(v20, v22, v23);
          v25 = v19 < v21;
          if (v24)
            v25 = v24 < 0;
          if (v25)
          {
LABEL_28:
            v26 = 0;
            v304 = 0;
            v27 = *(_OWORD *)v7;
            v303 = *(_QWORD *)(v7 + 16);
            v302 = v27;
            *(_QWORD *)(v7 + 8) = 0;
            *(_QWORD *)(v7 + 16) = 0;
            *(_QWORD *)v7 = 0;
            v28 = *(_WORD *)(v7 + 24);
            LOWORD(v304) = v28;
            if (v303 >= 0)
              v29 = HIBYTE(v303);
            else
              v29 = *((_QWORD *)&v302 + 1);
            if (v303 >= 0)
              v30 = &v302;
            else
              v30 = (__int128 *)v302;
            do
            {
              v31 = *(char *)(v7 + v26 + 55);
              if (v31 >= 0)
                v32 = *(unsigned __int8 *)(v7 + v26 + 55);
              else
                v32 = *(_QWORD *)(v7 + v26 + 40);
              if (v31 >= 0)
                v33 = (const void *)(v7 + v26 + 32);
              else
                v33 = *(const void **)(v7 + v26 + 32);
              if (v29 >= v32)
                v34 = v32;
              else
                v34 = v29;
              v35 = memcmp(v33, v30, v34);
              v36 = v32 < v29;
              if (v35)
                v36 = v35 < 0;
              v26 += 32;
            }
            while (v36);
            v37 = v7 + v26;
            if (v7 + v26 - 32 == v7)
            {
              while (1)
              {
                v44 = (uint64_t *)(v11 + 4);
                if (v37 >= (unint64_t)(v11 + 4))
                  break;
                v45 = *((char *)v11 + 23);
                if (v45 >= 0)
                  v46 = *((unsigned __int8 *)v11 + 23);
                else
                  v46 = (size_t)v11[1];
                if (v45 >= 0)
                  v47 = v11;
                else
                  v47 = *v11;
                if (v29 >= v46)
                  v48 = v46;
                else
                  v48 = v29;
                v49 = memcmp(v47, v30, v48);
                v50 = v46 < v29;
                if (v49)
                  v50 = v49 < 0;
                v11 -= 4;
                if (v50)
                  goto LABEL_73;
              }
            }
            else
            {
              do
              {
                v38 = *((char *)v11 + 23);
                if (v38 >= 0)
                  v39 = *((unsigned __int8 *)v11 + 23);
                else
                  v39 = (size_t)v11[1];
                if (v38 >= 0)
                  v40 = v11;
                else
                  v40 = *v11;
                if (v29 >= v39)
                  v41 = v39;
                else
                  v41 = v29;
                v42 = memcmp(v40, v30, v41);
                v43 = v39 < v29;
                if (v42)
                  v43 = v42 < 0;
                v11 -= 4;
              }
              while (!v43);
LABEL_73:
              v44 = (uint64_t *)(v11 + 4);
            }
            a1 = (uint64_t *)v37;
            if (v37 < (unint64_t)v44)
            {
              v51 = v44;
              do
              {
                std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<DocStore::ColdShardDescriptor *&,DocStore::ColdShardDescriptor *&>(a1, (uint64_t)v51);
                v52 = a1 + 4;
                do
                {
                  a1 = v52;
                  v53 = *((unsigned __int8 *)v52 + 23);
                  if ((v53 & 0x80u) == 0)
                    v54 = v53;
                  else
                    v54 = a1[1];
                  if ((v53 & 0x80u) == 0)
                    v55 = a1;
                  else
                    v55 = (const void *)*a1;
                  if (v29 >= v54)
                    v56 = v54;
                  else
                    v56 = v29;
                  v57 = memcmp(v55, v30, v56);
                  v58 = v57 < 0;
                  if (!v57)
                    v58 = v54 < v29;
                  v52 = a1 + 4;
                }
                while (v58);
                v59 = v51 - 4;
                do
                {
                  v51 = v59;
                  v60 = *((unsigned __int8 *)v59 + 23);
                  if ((v60 & 0x80u) == 0)
                    v61 = v60;
                  else
                    v61 = v51[1];
                  if ((v60 & 0x80u) == 0)
                    v62 = v51;
                  else
                    v62 = (const void *)*v51;
                  if (v29 >= v61)
                    v63 = v61;
                  else
                    v63 = v29;
                  v64 = memcmp(v62, v30, v63);
                  v65 = v64 < 0;
                  if (!v64)
                    v65 = v61 < v29;
                  v59 = v51 - 4;
                }
                while (!v65);
              }
              while (a1 < v51);
            }
            v66 = (void **)(a1 - 4);
            if (a1 - 4 != (uint64_t *)v7)
            {
              if (*(char *)(v7 + 23) < 0)
                operator delete(*(void **)v7);
              v67 = *(_OWORD *)v66;
              *(_QWORD *)(v7 + 16) = *(a1 - 2);
              *(_OWORD *)v7 = v67;
              *((_BYTE *)a1 - 9) = 0;
              *((_BYTE *)a1 - 32) = 0;
              *(_WORD *)(v7 + 24) = *((_WORD *)a1 - 4);
            }
            if (*((char *)a1 - 9) < 0)
              operator delete(*v66);
            v68 = v302;
            *(a1 - 2) = v303;
            *(_OWORD *)v66 = v68;
            *((_WORD *)a1 - 4) = v28;
            a2 = v299;
            if (v37 >= (unint64_t)v44)
            {
              v69 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,DocStore::load(analytics::OpenEvent *,BOOL)::{lambda(DocStore::ColdShardDescriptor const&,DocStore::ColdShardDescriptor const&)#1} &,DocStore::ColdShardDescriptor*>(v7, (const void **)a1 - 4);
              if (std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,DocStore::load(analytics::OpenEvent *,BOOL)::{lambda(DocStore::ColdShardDescriptor const&,DocStore::ColdShardDescriptor const&)#1} &,DocStore::ColdShardDescriptor*>((uint64_t)a1, v299))
              {
                a2 = (const void **)(a1 - 4);
                if (!v69)
                  continue;
                return;
              }
              if (v69)
                goto LABEL_2;
            }
            std::__introsort<std::_ClassicAlgPolicy,DocStore::load(analytics::OpenEvent *,BOOL)::{lambda(DocStore::ColdShardDescriptor const&,DocStore::ColdShardDescriptor const&)#1} &,DocStore::ColdShardDescriptor*,false>(v7, a1 - 4, a3, a4 & 1);
            a4 = 0;
            goto LABEL_2;
          }
          v304 = 0;
          v70 = *(_OWORD *)v7;
          v303 = *(_QWORD *)(v7 + 16);
          v302 = v70;
          *(_QWORD *)(v7 + 8) = 0;
          *(_QWORD *)(v7 + 16) = 0;
          *(_QWORD *)v7 = 0;
          v71 = *(_WORD *)(v7 + 24);
          LOWORD(v304) = v71;
          v72 = *((char *)a2 - 9);
          if (v303 >= 0)
            v73 = HIBYTE(v303);
          else
            v73 = *((_QWORD *)&v302 + 1);
          if (v303 >= 0)
            v74 = &v302;
          else
            v74 = (__int128 *)v302;
          if (v72 >= 0)
            v75 = *((unsigned __int8 *)a2 - 9);
          else
            v75 = (size_t)*(a2 - 3);
          if (v72 >= 0)
            v76 = a2 - 4;
          else
            v76 = (const void **)*(a2 - 4);
          if (v75 >= v73)
            v77 = v73;
          else
            v77 = v75;
          v78 = memcmp(v74, v76, v77);
          v79 = v73 < v75;
          if (v78)
            v79 = v78 < 0;
          if (v79)
          {
            v80 = (const void **)(v7 + 32);
            do
            {
              v81 = *((char *)v80 + 23);
              if (v81 >= 0)
                v82 = *((unsigned __int8 *)v80 + 23);
              else
                v82 = (size_t)v80[1];
              if (v81 >= 0)
                v83 = v80;
              else
                v83 = *v80;
              if (v82 >= v73)
                v84 = v73;
              else
                v84 = v82;
              v85 = memcmp(v74, v83, v84);
              v86 = v73 < v82;
              if (v85)
                v86 = v85 < 0;
              v80 += 4;
            }
            while (!v86);
            a1 = (uint64_t *)(v80 - 4);
          }
          else
          {
            v87 = (uint64_t *)(v7 + 32);
            do
            {
              a1 = v87;
              if (v87 >= (uint64_t *)a2)
                break;
              v88 = *((char *)v87 + 23);
              if (v88 >= 0)
                v89 = *((unsigned __int8 *)v87 + 23);
              else
                v89 = v87[1];
              if (v88 >= 0)
                v90 = v87;
              else
                v90 = (const void *)*v87;
              if (v89 >= v73)
                v91 = v73;
              else
                v91 = v89;
              v92 = memcmp(v74, v90, v91);
              v93 = v92 < 0;
              if (!v92)
                v93 = v73 < v89;
              v87 = a1 + 4;
            }
            while (!v93);
          }
          v94 = (uint64_t *)a2;
          if (a1 < (uint64_t *)a2)
          {
            do
            {
              v95 = *((char *)v11 + 23);
              if (v95 >= 0)
                v96 = *((unsigned __int8 *)v11 + 23);
              else
                v96 = (size_t)v11[1];
              if (v95 >= 0)
                v97 = v11;
              else
                v97 = *v11;
              if (v96 >= v73)
                v98 = v73;
              else
                v98 = v96;
              v99 = memcmp(v74, v97, v98);
              v100 = v73 < v96;
              if (v99)
                v100 = v99 < 0;
              v11 -= 4;
            }
            while (v100);
            v94 = (uint64_t *)(v11 + 4);
          }
          while (a1 < v94)
          {
            std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<DocStore::ColdShardDescriptor *&,DocStore::ColdShardDescriptor *&>(a1, (uint64_t)v94);
            v101 = a1 + 4;
            do
            {
              a1 = v101;
              v102 = *((unsigned __int8 *)v101 + 23);
              if ((v102 & 0x80u) == 0)
                v103 = v102;
              else
                v103 = a1[1];
              if ((v102 & 0x80u) == 0)
                v104 = a1;
              else
                v104 = (const void *)*a1;
              if (v103 >= v73)
                v105 = v73;
              else
                v105 = v103;
              v106 = memcmp(v74, v104, v105);
              v107 = v106 < 0;
              if (!v106)
                v107 = v73 < v103;
              v101 = a1 + 4;
            }
            while (!v107);
            v108 = v94 - 4;
            do
            {
              v94 = v108;
              v109 = *((unsigned __int8 *)v108 + 23);
              if ((v109 & 0x80u) == 0)
                v110 = v109;
              else
                v110 = v94[1];
              if ((v109 & 0x80u) == 0)
                v111 = v94;
              else
                v111 = (const void *)*v94;
              if (v110 >= v73)
                v112 = v73;
              else
                v112 = v110;
              v113 = memcmp(v74, v111, v112);
              v114 = v113 < 0;
              if (!v113)
                v114 = v73 < v110;
              v108 = v94 - 4;
            }
            while (v114);
          }
          v115 = (void **)(a1 - 4);
          if (a1 - 4 != (uint64_t *)v7)
          {
            if (*(char *)(v7 + 23) < 0)
              operator delete(*(void **)v7);
            v116 = *(_OWORD *)v115;
            *(_QWORD *)(v7 + 16) = *(a1 - 2);
            *(_OWORD *)v7 = v116;
            *((_BYTE *)a1 - 9) = 0;
            *((_BYTE *)a1 - 32) = 0;
            *(_WORD *)(v7 + 24) = *((_WORD *)a1 - 4);
          }
          if (*((char *)a1 - 9) < 0)
            operator delete(*v115);
          a4 = 0;
          v117 = v302;
          *(a1 - 2) = v303;
          *(_OWORD *)v115 = v117;
          *((_WORD *)a1 - 4) = v71;
          goto LABEL_2;
        }
        if ((a4 & 1) != 0)
        {
          if ((const void **)v7 != a2)
          {
            v130 = (const void **)(v7 + 32);
            if ((const void **)(v7 + 32) != a2)
            {
              v131 = 0;
              v132 = (const void **)v7;
              do
              {
                v133 = v130;
                v134 = *((char *)v132 + 23);
                v135 = *((char *)v132 + 55);
                if (v135 >= 0)
                  v136 = *((unsigned __int8 *)v132 + 55);
                else
                  v136 = (size_t)v132[5];
                if (v135 >= 0)
                  v137 = v130;
                else
                  v137 = (const void **)v132[4];
                if (v134 >= 0)
                  v138 = *((unsigned __int8 *)v132 + 23);
                else
                  v138 = (size_t)v132[1];
                if (v134 >= 0)
                  v139 = v132;
                else
                  v139 = *v132;
                if (v138 >= v136)
                  v140 = v136;
                else
                  v140 = v138;
                v141 = memcmp(v137, v139, v140);
                v142 = v136 < v138;
                if (v141)
                  v142 = v141 < 0;
                if (v142)
                {
                  v143 = a2;
                  v304 = 0;
                  v144 = *(_OWORD *)v133;
                  v303 = (uint64_t)v133[2];
                  v302 = v144;
                  v133[1] = 0;
                  v133[2] = 0;
                  *v133 = 0;
                  LOWORD(v304) = *((_WORD *)v132 + 28);
                  if (v303 >= 0)
                    v145 = HIBYTE(v303);
                  else
                    v145 = *((_QWORD *)&v302 + 1);
                  if (v303 >= 0)
                    v146 = &v302;
                  else
                    v146 = (__int128 *)v302;
                  v147 = v131;
                  while (1)
                  {
                    v148 = v7 + v147;
                    v149 = (void **)(v7 + v147 + 32);
                    if (*(char *)(v7 + v147 + 55) < 0)
                      operator delete(*v149);
                    *(_OWORD *)v149 = *(_OWORD *)v148;
                    *(_QWORD *)(v7 + v147 + 48) = *(_QWORD *)(v148 + 16);
                    *(_BYTE *)(v148 + 23) = 0;
                    *(_BYTE *)v148 = 0;
                    *(_WORD *)(v148 + 56) = *(_WORD *)(v148 + 24);
                    if (!v147)
                      break;
                    v150 = *(char *)(v7 + v147 - 9);
                    if (v150 >= 0)
                      v151 = *(unsigned __int8 *)(v7 + v147 - 9);
                    else
                      v151 = *(_QWORD *)(v7 + v147 - 24);
                    if (v150 >= 0)
                      v152 = (const void *)(v7 + v147 - 32);
                    else
                      v152 = *(const void **)(v7 + v147 - 32);
                    if (v151 >= v145)
                      v153 = v145;
                    else
                      v153 = v151;
                    v154 = memcmp(v146, v152, v153);
                    v155 = v145 < v151;
                    if (v154)
                      v155 = v154 < 0;
                    v147 -= 32;
                    if (!v155)
                    {
                      v156 = v7 + v147 + 32;
                      goto LABEL_278;
                    }
                  }
                  v156 = v7;
LABEL_278:
                  a2 = v143;
                  if (*(char *)(v156 + 23) < 0)
                    operator delete(*(void **)v156);
                  v157 = v302;
                  *(_QWORD *)(v156 + 16) = v303;
                  *(_OWORD *)v156 = v157;
                  *(_WORD *)(v156 + 24) = v304;
                }
                v130 = v133 + 4;
                v131 += 32;
                v132 = v133;
              }
              while (v133 + 4 != a2);
            }
          }
        }
        else if ((const void **)v7 != a2)
        {
          v257 = (const void *)(v7 + 32);
          if ((const void **)(v7 + 32) != a2)
          {
            v258 = (_WORD *)(v7 + 56);
            do
            {
              v259 = (uint64_t)v257;
              v260 = *(char *)(v7 + 23);
              v261 = *(char *)(v7 + 55);
              if (v261 >= 0)
                v262 = *(unsigned __int8 *)(v7 + 55);
              else
                v262 = *(_QWORD *)(v7 + 40);
              if (v261 >= 0)
                v263 = v257;
              else
                v263 = *(const void **)(v7 + 32);
              if (v260 >= 0)
                v264 = *(unsigned __int8 *)(v7 + 23);
              else
                v264 = *(_QWORD *)(v7 + 8);
              if (v260 >= 0)
                v265 = (const void *)v7;
              else
                v265 = *(const void **)v7;
              if (v264 >= v262)
                v266 = v262;
              else
                v266 = v264;
              v267 = memcmp(v263, v265, v266);
              v268 = v262 < v264;
              if (v267)
                v268 = v267 < 0;
              if (v268)
              {
                v304 = 0;
                v269 = *(_OWORD *)v259;
                v303 = *(_QWORD *)(v259 + 16);
                v302 = v269;
                *(_QWORD *)(v259 + 8) = 0;
                *(_QWORD *)(v259 + 16) = 0;
                *(_QWORD *)v259 = 0;
                LOWORD(v304) = *(_WORD *)(v7 + 56);
                if (v303 >= 0)
                  v270 = HIBYTE(v303);
                else
                  v270 = *((_QWORD *)&v302 + 1);
                if (v303 >= 0)
                  v271 = &v302;
                else
                  v271 = (__int128 *)v302;
                v272 = v258;
                do
                {
                  v273 = (void **)(v272 - 12);
                  if (*((char *)v272 - 1) < 0)
                    operator delete(*v273);
                  *(_OWORD *)v273 = *(_OWORD *)(v272 - 28);
                  *((_QWORD *)v272 - 1) = *((_QWORD *)v272 - 5);
                  *((_BYTE *)v272 - 33) = 0;
                  *((_BYTE *)v272 - 56) = 0;
                  v274 = v272 - 28;
                  v275 = v272 - 16;
                  *v272 = *(v272 - 16);
                  v276 = *((char *)v272 - 65);
                  v277 = v272 - 44;
                  v278 = (const void *)*((_QWORD *)v272 - 11);
                  if (v276 >= 0)
                    v279 = *((unsigned __int8 *)v272 - 65);
                  else
                    v279 = *((_QWORD *)v272 - 10);
                  if (v276 >= 0)
                    v280 = v277;
                  else
                    v280 = v278;
                  if (v279 >= v270)
                    v281 = v270;
                  else
                    v281 = v279;
                  v282 = memcmp(v271, v280, v281);
                  v283 = v270 < v279;
                  if (v282)
                    v283 = v282 < 0;
                  v272 = v275;
                }
                while (v283);
                if (*((char *)v274 + 23) < 0)
                  operator delete(*(void **)v274);
                v284 = v302;
                *((_QWORD *)v274 + 2) = v303;
                *(_OWORD *)v274 = v284;
                v274[12] = v304;
              }
              v257 = (const void *)(v259 + 32);
              v258 += 16;
              v7 = v259;
            }
            while ((const void **)(v259 + 32) != a2);
          }
        }
        return;
    }
  }
}

uint64_t DocStore::do_cool_hot_shard(DocStore *this)
{
  int v2;
  NSObject *v3;
  os_log_type_t v4;
  int v5;
  uint64_t v6;
  std::chrono::steady_clock::time_point v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  uint64_t v10;
  unint64_t v11;
  int v12;
  NSObject *v13;
  os_log_type_t v14;
  char *v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int v21;
  uint64_t v22;
  __n128 v23;
  int v24;
  NSObject *v25;
  os_log_type_t v26;
  char *v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  NSObject *v34;
  NSObject *v35;
  os_log_type_t v36;
  char *v37;
  int v38;
  int v39;
  unsigned int shard_file;
  int v41;
  NSObject *v42;
  os_log_type_t v43;
  void **v44;
  uint64_t v45;
  uint64_t v46;
  void **v47;
  uint64_t v48;
  FILE **v49;
  int v50;
  NSObject *v51;
  os_log_type_t v52;
  char *v53;
  int v54;
  int v55;
  NSObject *v56;
  NSObject *v57;
  int v58;
  os_log_type_t v59;
  char *v60;
  void *v61;
  void *v62;
  _BYTE *v63;
  unint64_t v64;
  unint64_t v65;
  FILE *v66;
  const char *ErrorName;
  int v68;
  uint64_t v69;
  int v70;
  NSObject *v71;
  os_log_type_t v72;
  char *v73;
  void *v74;
  std::chrono::steady_clock::time_point v75;
  float v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v80;
  __int128 v81;
  FILE **v82;
  const void *v83;
  unint64_t v84;
  off_t file_size;
  int v86;
  os_log_type_t v87;
  void **v88;
  _QWORD *v89;
  uint64_t i;
  char v91;
  size_t iov_len;
  _BYTE *iov_base;
  const char *v94;
  const char *v95;
  int v96;
  int *v97;
  int v98;
  NSObject *v99;
  os_log_type_t v100;
  void **v101;
  void *v102;
  char *v103;
  void **v104;
  int v105;
  NSObject *v106;
  os_log_type_t v107;
  void **v108;
  __int16 v109;
  unint64_t CDict;
  uint64_t CCtx;
  unint64_t v112;
  unint64_t v113;
  FILE *v114;
  const char *v115;
  FILE *v116;
  int *v117;
  char *v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  int v122;
  NSObject *v123;
  os_log_type_t v124;
  void **v125;
  void *v126;
  uint64_t v127;
  uint64_t v128;
  CachingHotShard *v129;
  void **v130;
  NSObject *v131;
  int v132;
  int __errnum;
  std::__shared_weak_count *v134;
  std::__shared_weak_count *v135;
  unsigned int v136;
  int v137;
  std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep rep;
  iovec v139;
  uint64_t v140;
  _QWORD v141[6];
  unsigned int v142;
  void *__p[2];
  uint64_t v144;
  _QWORD v145[6];
  uint64_t v146;
  _BYTE buf[32];
  __int128 v148;
  __int128 v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;

  v153 = *MEMORY[0x1E0C80C00];
  v2 = *__error();
  v3 = _SILogForLogForCategory(8);
  v4 = 2 * (dword_1EF19FCAC < 4);
  if (os_log_type_enabled(v3, v4))
  {
    v5 = *((_DWORD *)this + 1);
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v5;
    _os_log_impl(&dword_1B8270000, v3, v4, "do_cool_hot_shard called with hotfd %d", buf, 8u);
  }
  *__error() = v2;
  v6 = operator new();
  *(_OWORD *)v6 = 0u;
  *(_OWORD *)(v6 + 16) = 0u;
  *(_OWORD *)(v6 + 32) = 0u;
  *(_OWORD *)(v6 + 48) = 0u;
  *(_QWORD *)(v6 + 64) = 0;
  v7.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  v8 = (std::__shared_weak_count *)operator new(0x20uLL);
  v8->__shared_owners_ = 0;
  p_shared_owners = (unint64_t *)&v8->__shared_owners_;
  v8->__shared_weak_owners_ = 0;
  v8[1].__vftable = (std::__shared_weak_count_vtbl *)&off_1E6E2A960;
  v10 = (uint64_t)&v8[1];
  v8->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6E2AC88;
  *(_QWORD *)(v6 + 16) = *((_QWORD *)this + 13);
  v11 = *((_QWORD *)this + 15);
  *(_QWORD *)(v6 + 32) = *((_QWORD *)this + 14);
  *(_BYTE *)(v6 + 24) = 1;
  *(_BYTE *)(v6 + 40) = 1;
  if (v11 >= 5)
  {
    fprintf((FILE *)*MEMORY[0x1E0C80C10], "invalid compression type %lld\n", v11);
LABEL_5:
    v12 = *__error();
    v13 = _SILogForLogForCategory(8);
    v14 = dword_1EF19FCAC < 3;
    if (os_log_type_enabled(v13, (os_log_type_t)(dword_1EF19FCAC < 3)))
    {
      v15 = strerror(12);
      *(_DWORD *)buf = 136315138;
      *(_QWORD *)&buf[4] = v15;
      _os_log_impl(&dword_1B8270000, v13, v14, "*warn* do_cool_hot_shard: cold_shard_create_build_context: %s", buf, 0xCu);
    }
    *__error() = v12;
    v16 = 4294967284;
    *(_DWORD *)(v6 + 4) = -12;
    *(_BYTE *)(v6 + 8) = 1;
    *(_WORD *)v6 = 256;
    goto LABEL_77;
  }
  v17 = *(_DWORD *)this;
  v18 = operator new();
  *(_QWORD *)v18 = v11;
  *(_OWORD *)(v18 + 8) = 0u;
  *(_OWORD *)(v18 + 24) = 0u;
  *(_OWORD *)(v18 + 40) = 0u;
  *(_OWORD *)(v18 + 56) = 0u;
  *(_OWORD *)(v18 + 72) = 0u;
  *(_OWORD *)(v18 + 88) = 0u;
  if (v11 == 2)
  {
    v19 = operator new();
    *(_QWORD *)(v19 + 8) = 0;
    *(_BYTE *)(v19 + 16) = 0;
    *(_OWORD *)(v19 + 24) = 0u;
    *(_OWORD *)(v19 + 40) = 0u;
    *(_OWORD *)(v19 + 56) = 0u;
    *(_OWORD *)(v19 + 72) = 0u;
    strcpy(buf, "tmp.XXXXXX");
    v20 = mkstempsat_np(v17, buf, 0);
    *(_DWORD *)v19 = v20;
    if (v20 < 0)
    {
      perror("mkstempsat_np");
      MEMORY[0x1BCCB06A4](v19, 0x1032C4009156773);
      *(_QWORD *)(v18 + 96) = 0;
      fwrite("zstd_dict_compress_create_context failed\n", 0x29uLL, 1uLL, (FILE *)*MEMORY[0x1E0C80C10]);
      MEMORY[0x1BCCB06A4](v18, 0x1032C40CD500400);
      goto LABEL_5;
    }
    unlinkat(v17, buf, 0);
    *(_QWORD *)(v18 + 96) = v19;
  }
  v146 = 0;
  v21 = *((_DWORD *)this + 1);
  v145[0] = MEMORY[0x1E0C809B0];
  v145[1] = 0x40000000;
  v145[2] = ___ZN8DocStore17do_cool_hot_shardEv_block_invoke;
  v145[3] = &__block_descriptor_tmp_641;
  v145[4] = &v146;
  v145[5] = v18;
  *(_QWORD *)buf = MEMORY[0x1E0C809B0];
  *(_QWORD *)&buf[8] = 0x40000000;
  *(_QWORD *)&buf[16] = __hot_shard_iterate_block_invoke;
  *(_QWORD *)&buf[24] = &unk_1E6E34E90;
  *(_QWORD *)&v148 = v145;
  v22 = hot_shard_for_each_region(v21, (uint64_t)buf);
  if (!(_DWORD)v22)
  {
    v28 = *(_QWORD *)(v18 + 16);
    v29 = *(_QWORD *)(v18 + 24);
    v30 = 126 - 2 * __clz((uint64_t)(v29 - v28) >> 5);
    if (v29 == v28)
      v31 = 0;
    else
      v31 = v30;
    std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,DocMeta *,false>(v28, v29, v31, 1, v23);
    v32 = *(_QWORD *)v18;
    if (*(_QWORD *)v18 > 4uLL)
    {
      fprintf((FILE *)*MEMORY[0x1E0C80C10], "logic error:  unknown compression type %llx\n", *(_QWORD *)v18);
      abort();
    }
    rep = v7.__d_.__rep_;
    if (v32 != 2)
      goto LABEL_20;
    v48 = *(_QWORD *)(v18 + 96);
    v49 = (FILE **)MEMORY[0x1E0C80C10];
    if (*(_BYTE *)(v48 + 16))
    {
      v16 = 4294967274;
      goto LABEL_142;
    }
    v61 = mmap(0, *(_QWORD *)(v48 + 8), 1, 1, *(_DWORD *)v48, 0);
    if (v61 == (void *)-1)
    {
      *(_BYTE *)(v48 + 16) = 1;
      v16 = -*__error();
      goto LABEL_141;
    }
    v62 = v61;
    memset(buf, 0, 24);
    std::string::resize((std::string *)buf, 0x10000uLL, 0);
    if (buf[23] >= 0)
      v63 = buf;
    else
      v63 = *(_BYTE **)buf;
    if (buf[23] >= 0)
      v64 = buf[23];
    else
      v64 = *(_QWORD *)&buf[8];
    v65 = ZDICT_trainFromBuffer(v63, v64, (uint64_t)v62, *(uint64_t **)(v48 + 24), (*(_QWORD *)(v48 + 32) - *(_QWORD *)(v48 + 24)) >> 3);
    if (ZDICT_isError(v65))
    {
      v66 = (FILE *)*MEMORY[0x1E0C80C10];
      ErrorName = ZDICT_getErrorName(v65);
      fprintf(v66, "ZDICT_trainFromBuffer: %s\n", ErrorName);
      v16 = 4294967291;
      goto LABEL_139;
    }
    std::string::resize((std::string *)buf, v65, 0);
    v80 = *(_QWORD *)(v48 + 64);
    v81 = *(_OWORD *)(v48 + 48);
    *(_OWORD *)(v48 + 48) = *(_OWORD *)buf;
    *(_QWORD *)(v48 + 64) = *(_QWORD *)&buf[16];
    *(_OWORD *)buf = v81;
    *(_QWORD *)&buf[16] = v80;
    if (munmap(v62, *(_QWORD *)(v48 + 8)))
      perror("munmap");
    v82 = (FILE **)MEMORY[0x1E0C80C10];
    if (*(char *)(v48 + 71) < 0)
    {
      v83 = *(const void **)(v48 + 48);
      v84 = *(_QWORD *)(v48 + 56);
    }
    else
    {
      v83 = (const void *)(v48 + 48);
      v84 = *(unsigned __int8 *)(v48 + 71);
    }
    CDict = ZSTD_createCDict(v83, v84, 9);
    *(_QWORD *)(v48 + 72) = CDict;
    if (CDict && (CCtx = ZSTD_createCCtx(), (*(_QWORD *)(v48 + 80) = CCtx) != 0))
    {
      ZSTD_CCtx_refCDict(CCtx, *(_QWORD *)(v48 + 72));
      v113 = v112;
      if (!ZDICT_isError(v112))
      {
        v16 = 0;
LABEL_139:
        if ((buf[23] & 0x80000000) != 0)
          operator delete(*(void **)buf);
LABEL_141:
        v49 = (FILE **)MEMORY[0x1E0C80C10];
        if (!(_DWORD)v16)
        {
          v119 = *(_QWORD *)(v18 + 96);
          if (*(char *)(v119 + 71) < 0)
          {
            v120 = *(_QWORD *)(v119 + 48);
            v121 = *(_QWORD *)(v119 + 56);
          }
          else
          {
            v120 = v119 + 48;
            v121 = *(unsigned __int8 *)(v119 + 71);
          }
          MEMORY[0x1BCCB03BC](v18 + 48, v120, v121);
LABEL_20:
          v16 = 0;
          goto LABEL_21;
        }
LABEL_142:
        v116 = *v49;
        v117 = __error();
        v118 = strerror(-*v117);
        fprintf(v116, "zstd_dict_compress_train: %s\n", v118);
LABEL_21:
        v33 = *__error();
        v34 = _SILogForLogForCategory(8);
        v35 = v34;
        if ((_DWORD)v16)
        {
          v36 = dword_1EF19FCAC < 3;
          if (os_log_type_enabled(v34, (os_log_type_t)(dword_1EF19FCAC < 3)))
          {
            v37 = strerror(-(int)v16);
            *(_DWORD *)buf = 136315138;
            *(_QWORD *)&buf[4] = v37;
            _os_log_impl(&dword_1B8270000, v35, v36, "*warn* do_cool_hot_shard: cold_shard_complete_first_pass: %s", buf, 0xCu);
          }
          *__error() = v33;
          *(_DWORD *)(v6 + 4) = v16;
          *(_BYTE *)(v6 + 8) = 1;
          *(_WORD *)v6 = 256;
          v7.__d_.__rep_ = rep;
          goto LABEL_70;
        }
        v38 = (2 * (dword_1EF19FCAC < 4));
        if (os_log_type_enabled(v34, (os_log_type_t)(2 * (dword_1EF19FCAC < 4))))
        {
          *(_DWORD *)buf = 134217984;
          *(_QWORD *)&buf[4] = v146;
          _os_log_impl(&dword_1B8270000, v35, (os_log_type_t)v38, "completed first pass of hot shard cooling; found %lld docs",
            buf,
            0xCu);
        }
        *__error() = v33;
        __p[0] = 0;
        __p[1] = 0;
        v144 = 0;
        v39 = *(_DWORD *)this;
        std::string::basic_string[abi:nn180100]<0>(buf, "tmp.");
        if ((buf[23] & 0x80000000) != 0)
          operator delete(*(void **)buf);
        v41 = *__error();
        if ((shard_file & 0x80000000) != 0)
        {
          v16 = -v41;
          v50 = *__error();
          v51 = _SILogForLogForCategory(8);
          v52 = dword_1EF19FCAC < 3;
          if (os_log_type_enabled(v51, (os_log_type_t)(dword_1EF19FCAC < 3)))
          {
            v53 = strerror(v41);
            *(_DWORD *)buf = 136315138;
            *(_QWORD *)&buf[4] = v53;
            _os_log_impl(&dword_1B8270000, v51, v52, "*warn* do_cool_hot_shard: create_shard_file: %s", buf, 0xCu);
          }
          *__error() = v50;
          *(_DWORD *)(v6 + 4) = v16;
          *(_BYTE *)(v6 + 8) = 1;
          *(_WORD *)v6 = (v41 == 0) | 0x100;
        }
        else
        {
          v136 = shard_file;
          v42 = _SILogForLogForCategory(8);
          v43 = 2 * (dword_1EF19FCAC < 4);
          if (os_log_type_enabled(v42, v43))
          {
            v44 = __p;
            if (v144 < 0)
              v44 = (void **)__p[0];
            *(_DWORD *)buf = 136315138;
            *(_QWORD *)&buf[4] = v44;
            _os_log_impl(&dword_1B8270000, v42, v43, "creating cold shard in %s", buf, 0xCu);
          }
          *__error() = v41;
          v148 = 0u;
          v149 = 0u;
          memset(buf, 0, sizeof(buf));
          v45 = *(_QWORD *)v18;
          v150 = 0;
          v151 = v45;
          v152 = 1;
          v139.iov_base = buf;
          v139.iov_len = 88;
          v46 = writevall(v136, &v139, 1);
          if ((_DWORD)v46)
          {
            v16 = v46;
            if (v144 >= 0)
              v47 = __p;
            else
              v47 = (void **)__p[0];
          }
          else
          {
            v139.iov_base = 0;
            v54 = *((_DWORD *)this + 1);
            v141[0] = MEMORY[0x1E0C809B0];
            v141[1] = 0x40000000;
            v141[2] = ___ZN8DocStore17do_cool_hot_shardEv_block_invoke_22;
            v141[3] = &__block_descriptor_tmp_23_647;
            v142 = v136;
            v141[4] = &v139;
            v141[5] = v18;
            *(_QWORD *)buf = MEMORY[0x1E0C809B0];
            *(_QWORD *)&buf[8] = 0x40000000;
            *(_QWORD *)&buf[16] = __hot_shard_iterate_block_invoke;
            *(_QWORD *)&buf[24] = &unk_1E6E34E90;
            *(_QWORD *)&v148 = v141;
            v16 = hot_shard_for_each_region(v54, (uint64_t)buf);
            v55 = *__error();
            v56 = _SILogForLogForCategory(8);
            v57 = v56;
            if ((_DWORD)v16)
            {
              v58 = v55;
              v59 = dword_1EF19FCAC < 3;
              if (os_log_type_enabled(v56, (os_log_type_t)(dword_1EF19FCAC < 3)))
              {
                v60 = strerror(-(int)v16);
                *(_DWORD *)buf = 136315138;
                *(_QWORD *)&buf[4] = v60;
                _os_log_impl(&dword_1B8270000, v57, v59, "*warn* do_cool_hot_shard: hot_shard_iterate: %s", buf, 0xCu);
              }
              *__error() = v58;
            }
            else
            {
              v68 = (2 * (dword_1EF19FCAC < 4));
              if (os_log_type_enabled(v56, (os_log_type_t)(2 * (dword_1EF19FCAC < 4))))
              {
                *(_DWORD *)buf = 134217984;
                *(_QWORD *)&buf[4] = v139.iov_base;
                _os_log_impl(&dword_1B8270000, v57, (os_log_type_t)v68, "completed second pass of hot shard cooling; found %lld docs",
                  buf,
                  0xCu);
              }
              *__error() = v55;
              v69 = cold_shard_finish_file(v136, (uint64_t *)v18);
              if (!(_DWORD)v69)
              {
                file_size = get_file_size(v136);
                if (file_size >= 1)
                {
                  *(_BYTE *)(v6 + 56) = 1;
                  *(_QWORD *)(v6 + 48) = file_size;
                }
                close(v136);
                v86 = *__error();
                v16 = _SILogForLogForCategory(8);
                v87 = 2 * (dword_1EF19FCAC < 4);
                if (os_log_type_enabled((os_log_t)v16, v87))
                {
                  v88 = __p;
                  if (v144 < 0)
                    v88 = (void **)__p[0];
                  *(_DWORD *)buf = 136315138;
                  *(_QWORD *)&buf[4] = v88;
                  _os_log_impl(&dword_1B8270000, (os_log_t)v16, v87, "created cold shard in %s\n", buf, 0xCu);
                }
                v137 = 0;
                *__error() = v86;
                v139.iov_base = 0;
                v139.iov_len = 0;
                v140 = 0;
                v134 = v8;
                v135 = v8 + 1;
                while (1)
                {
                  v89 = std::string::basic_string[abi:nn180100]<0>(buf, "cold.");
                  if ((buf[23] & 0x80000000) != 0)
                    operator delete(*(void **)buf);
                  for (i = -1; i != -7; --i)
                  {
                    v91 = aAbcdefghijklmn[rand() % 62];
                    iov_len = HIBYTE(v140);
                    if (v140 >= 0)
                    {
                      iov_base = &v139;
                    }
                    else
                    {
                      iov_len = v139.iov_len;
                      iov_base = v139.iov_base;
                    }
                    iov_base[iov_len + i] = v91;
                  }
                  v94 = v144 >= 0 ? (const char *)__p : (const char *)__p[0];
                  v95 = v140 >= 0 ? (const char *)&v139 : (const char *)v139.iov_base;
                  v96 = renameatx_np(*(_DWORD *)this, v94, *(_DWORD *)this, v95, 4u);
                  v97 = __error();
                  v98 = *v97;
                  if (!v96)
                    break;
                  v8 = v134;
                  v10 = (uint64_t)v135;
                  if (v98 == 4)
                  {
                    v7.__d_.__rep_ = rep;
                  }
                  else
                  {
                    v7.__d_.__rep_ = rep;
                    if (v98 != 17)
                    {
                      __errnum = *v97;
                      v132 = *__error();
                      v99 = _SILogForLogForCategory(8);
                      v100 = dword_1EF19FCAC < 3;
                      v131 = v99;
                      if (os_log_type_enabled(v99, (os_log_type_t)(dword_1EF19FCAC < 3)))
                      {
                        v101 = __p;
                        if (v144 < 0)
                          v101 = (void **)__p[0];
                        v130 = v101;
                        if (v140 >= 0)
                          v102 = &v139;
                        else
                          v102 = v139.iov_base;
                        v103 = strerror(__errnum);
                        *(_DWORD *)buf = 136315650;
                        *(_QWORD *)&buf[4] = v130;
                        *(_WORD *)&buf[12] = 2080;
                        *(_QWORD *)&buf[14] = v102;
                        v7.__d_.__rep_ = rep;
                        *(_WORD *)&buf[22] = 2080;
                        *(_QWORD *)&buf[24] = v103;
                        _os_log_impl(&dword_1B8270000, v131, v100, "*warn* do_cool_hot_shard: renameatx_np(%s, %s): %s", buf, 0x20u);
                      }
                      v16 = -__errnum;
                      *__error() = v132;
                      if (v144 >= 0)
                        v104 = __p;
                      else
                        v104 = (void **)__p[0];
                      unlinkat(*(_DWORD *)this, (const char *)v104, 0);
                      v98 = __errnum;
                      *(_DWORD *)(v6 + 4) = v16;
                      *(_BYTE *)(v6 + 8) = 1;
                      *(_WORD *)v6 = (__errnum == 0) | 0x100;
                    }
                  }
                  if (v98 != 17 && v98 != 4)
                    goto LABEL_165;
                  if (++v137 == 8)
                  {
                    v105 = *__error();
                    v106 = _SILogForLogForCategory(8);
                    v107 = dword_1EF19FCAC < 3;
                    if (os_log_type_enabled(v106, (os_log_type_t)(dword_1EF19FCAC < 3)))
                    {
                      *(_WORD *)buf = 0;
                      _os_log_impl(&dword_1B8270000, v106, v107, "*warn* do_cool_hot_shard: renameatx_np repeatedly failed; returning EAGAIN",
                        buf,
                        2u);
                    }
                    *__error() = v105;
                    if (v144 >= 0)
                      v108 = __p;
                    else
                      v108 = (void **)__p[0];
                    unlinkat(*(_DWORD *)this, (const char *)v108, 0);
                    v109 = 256;
                    v16 = 4294967261;
                    goto LABEL_164;
                  }
                }
                v122 = *v97;
                v123 = _SILogForLogForCategory(8);
                v124 = 2 * (dword_1EF19FCAC < 4);
                v8 = v134;
                v10 = (uint64_t)v135;
                if (os_log_type_enabled(v123, v124))
                {
                  v125 = __p;
                  if (v144 < 0)
                    v125 = (void **)__p[0];
                  v126 = &v139;
                  if (v140 < 0)
                    v126 = v139.iov_base;
                  *(_DWORD *)buf = 136315394;
                  *(_QWORD *)&buf[4] = v125;
                  *(_WORD *)&buf[12] = 2080;
                  *(_QWORD *)&buf[14] = v126;
                  _os_log_impl(&dword_1B8270000, v123, v124, "renamed cold shard from %s to %s\n", buf, 0x16u);
                }
                *__error() = v122;
                fsync(*(_DWORD *)this);
                v127 = *((_QWORD *)this + 1);
                if (v127)
                {
                  *(_QWORD *)(v127 + 16) = *(_QWORD *)(v127 + 8);
                  *(_QWORD *)(v127 + 40) = *(_QWORD *)(v127 + 32);
                  *(_QWORD *)(v127 + 64) = *(_QWORD *)(v127 + 56);
                  *(_DWORD *)v127 = -1;
                }
                v128 = *((unsigned int *)this + 1);
                ftruncate(*((_DWORD *)this + 1), 8);
                hot_shard_update_logical_size(v128);
                *((_QWORD *)this + 13) = 0;
                *((_QWORD *)this + 14) = 0;
                v129 = (CachingHotShard *)*((_QWORD *)this + 1);
                v7.__d_.__rep_ = rep;
                if (v129)
                  CachingHotShard::Bind(v129, *((_DWORD *)this + 1));
                if (SHIBYTE(v140) < 0)
                {
                  std::string::__init_copy_ctor_external((std::string *)buf, (const std::string::value_type *)v139.iov_base, v139.iov_len);
                }
                else
                {
                  *(iovec *)buf = v139;
                  *(_QWORD *)&buf[16] = v140;
                }
                *(_WORD *)&buf[24] = 0;
                std::vector<DocStore::ColdShardDescriptor>::push_back[abi:nn180100]((_QWORD *)this + 2, (__int128 *)buf);
                if ((buf[23] & 0x80000000) != 0)
                  operator delete(*(void **)buf);
                DocStore::MarkDocPurgeableTillN((uint64_t)this);
                v16 = 0;
                v109 = 257;
LABEL_164:
                *(_DWORD *)(v6 + 4) = v16;
                *(_BYTE *)(v6 + 8) = 1;
                *(_WORD *)v6 = v109;
LABEL_165:
                if (SHIBYTE(v140) < 0)
                  operator delete(v139.iov_base);
                goto LABEL_68;
              }
              v16 = v69;
              v70 = *__error();
              v71 = _SILogForLogForCategory(8);
              v72 = dword_1EF19FCAC < 3;
              if (os_log_type_enabled(v71, (os_log_type_t)(dword_1EF19FCAC < 3)))
              {
                v73 = strerror(-(int)v16);
                *(_DWORD *)buf = 136315138;
                *(_QWORD *)&buf[4] = v73;
                _os_log_impl(&dword_1B8270000, v71, v72, "*warn* do_cool_hot_shard: cold_shard_finish_file: %s", buf, 0xCu);
              }
              *__error() = v70;
            }
            if (v144 >= 0)
              v47 = __p;
            else
              v47 = (void **)__p[0];
          }
          unlinkat(*(_DWORD *)this, (const char *)v47, 0);
          *(_DWORD *)(v6 + 4) = v16;
          *(_BYTE *)(v6 + 8) = 1;
          *(_WORD *)v6 = 256;
          close(v136);
        }
        v7.__d_.__rep_ = rep;
LABEL_68:
        if (SHIBYTE(v144) < 0)
          operator delete(__p[0]);
        goto LABEL_70;
      }
      v114 = *v82;
      v115 = ZDICT_getErrorName(v113);
      fprintf(v114, "ZSTD_CCtx_refCDict: %s\n", v115);
    }
    else
    {
      *(_BYTE *)(v48 + 16) = 1;
    }
    v16 = 4294967284;
    goto LABEL_139;
  }
  v16 = v22;
  v24 = *__error();
  v25 = _SILogForLogForCategory(8);
  v26 = dword_1EF19FCAC < 3;
  if (os_log_type_enabled(v25, (os_log_type_t)(dword_1EF19FCAC < 3)))
  {
    v27 = strerror(-(int)v16);
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)&buf[4] = v27;
    _os_log_impl(&dword_1B8270000, v25, v26, "*warn* do_cool_hot_shard: hot_shard_iterate: %s", buf, 0xCu);
  }
  *__error() = v24;
  *(_DWORD *)(v6 + 4) = v16;
  *(_BYTE *)(v6 + 8) = 1;
  *(_WORD *)v6 = 256;
LABEL_70:
  if (*(char *)(v18 + 95) < 0)
    operator delete(*(void **)(v18 + 72));
  if (*(char *)(v18 + 71) < 0)
    operator delete(*(void **)(v18 + 48));
  v74 = *(void **)(v18 + 16);
  if (v74)
  {
    *(_QWORD *)(v18 + 24) = v74;
    operator delete(v74);
  }
  MEMORY[0x1BCCB06A4](v18, 0x1032C40CD500400);
LABEL_77:
  v75.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  *(_BYTE *)(v6 + 68) = 1;
  v76 = (double)(v75.__d_.__rep_ - v7.__d_.__rep_) * 0.00001;
  *(float *)(v6 + 64) = v76;
  *(_QWORD *)buf = v6;
  v77 = *(_QWORD *)buf;
  *(_QWORD *)buf = 0;
  if (v77)
    MEMORY[0x1BCCB06A4](v77, 0x1000C4073594BB7);
  do
    v78 = __ldaxr(p_shared_owners);
  while (__stlxr(v78 - 1, p_shared_owners));
  if (!v78)
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
  return v16;
}

uint64_t DocStore::add_cold_shard_to_bloom_filter(DocStore *this, int a2)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  NSObject *v10;
  os_log_type_t v11;
  char *v12;
  const char *v13;
  int v14;
  uint64_t v15;
  uint64_t document_index;
  char *v17;
  std::string *p_p;
  std::string::size_type size;
  char *v20;
  _QWORD v22[5];
  int v23;
  std::string __p;
  int v25[2];
  uint8_t buf[4];
  uint64_t v27;
  __int16 v28;
  char *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v4 = *((_QWORD *)this + 2) + 32 * a2;
  if (*(char *)(v4 + 23) < 0)
    v4 = *(_QWORD *)v4;
  *(_QWORD *)v25 = 0;
  memset(&__p, 0, sizeof(__p));
  v5 = openat(*(_DWORD *)this, (const char *)v4, 0);
  v6 = v5;
  if ((v5 & 0x80000000) != 0)
  {
    v14 = *__error();
    v8 = -v14;
    v9 = *__error();
    v10 = _SILogForLogForCategory(8);
    v11 = dword_1EF19FCAC < 3;
    if (os_log_type_enabled(v10, (os_log_type_t)(dword_1EF19FCAC < 3)))
    {
      *(_DWORD *)buf = 136315394;
      v27 = v4;
      v28 = 2080;
      v29 = strerror(v14);
      v13 = "*warn* add_cold_shard_to_bloom_filter:  open(%s): %s";
      goto LABEL_21;
    }
LABEL_22:
    *__error() = v9;
    v15 = *(_QWORD *)v25;
    goto LABEL_23;
  }
  cold_shard_create_search_context_for_fd(v5, (uint64_t *)v25);
  if ((_DWORD)v7)
  {
    v8 = v7;
    v9 = *__error();
    v10 = _SILogForLogForCategory(8);
    v11 = dword_1EF19FCAC < 3;
    if (os_log_type_enabled(v10, (os_log_type_t)(dword_1EF19FCAC < 3)))
    {
      v12 = strerror(-(int)v8);
      *(_DWORD *)buf = 136315394;
      v27 = v4;
      v28 = 2080;
      v29 = v12;
      v13 = "*warn* add_cold_shard_to_bloom_filter:  create_search_context_for_fd(%s): %s";
LABEL_21:
      _os_log_impl(&dword_1B8270000, v10, v11, v13, buf, 0x16u);
      goto LABEL_22;
    }
    goto LABEL_22;
  }
  v15 = *(_QWORD *)v25;
  document_index = cold_shard_get_document_index(*(uint64_t *)v25, &__p);
  if ((_DWORD)document_index)
  {
    v8 = document_index;
    v9 = *__error();
    v10 = _SILogForLogForCategory(8);
    v11 = dword_1EF19FCAC < 3;
    if (os_log_type_enabled(v10, (os_log_type_t)(dword_1EF19FCAC < 3)))
    {
      v17 = strerror(-(int)v8);
      *(_DWORD *)buf = 136315394;
      v27 = v4;
      v28 = 2080;
      v29 = v17;
      v13 = "*warn* add_cold_shard_to_bloom_filter:  get_document_index(%s): %s";
      goto LABEL_21;
    }
    goto LABEL_22;
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  else
    size = __p.__r_.__value_.__l.__size_;
  v22[0] = MEMORY[0x1E0C809B0];
  v22[1] = 0x40000000;
  v22[2] = ___ZN8DocStore30add_cold_shard_to_bloom_filterEi_block_invoke;
  v22[3] = &__block_descriptor_tmp_27;
  v22[4] = this;
  v23 = a2;
  v8 = cold_shard_document_index_iterate((unsigned __int8 *)p_p, size, (uint64_t)v22);
  if ((_DWORD)v8)
  {
    v9 = *__error();
    v10 = _SILogForLogForCategory(8);
    v11 = dword_1EF19FCAC < 3;
    if (os_log_type_enabled(v10, (os_log_type_t)(dword_1EF19FCAC < 3)))
    {
      v20 = strerror(-(int)v8);
      *(_DWORD *)buf = 136315394;
      v27 = v4;
      v28 = 2080;
      v29 = v20;
      v13 = "*warn* add_cold_shard_to_bloom_filter:  document_index_iterate(%s): %s";
      goto LABEL_21;
    }
    goto LABEL_22;
  }
LABEL_23:
  if (v15)
    MEMORY[0x1BCCB06A4](v15, 0x1000C4034A301B9);
  if ((v6 & 0x80000000) == 0)
    close(v6);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  return v8;
}

uint64_t DocStore::create(DocStore *this)
{
  int v2;
  NSObject *v3;
  os_log_type_t v4;
  int v5;
  int v6;
  uint64_t shard_file;
  int v8;
  int v9;
  int v10;
  NSObject *v11;
  os_log_type_t v12;
  int v13;
  int v14;
  void **v15;
  CachingHotShard *v16;
  uint64_t v17;
  int v18;
  NSObject *v19;
  int v20;
  NSObject *v21;
  NSObject *v22;
  os_log_type_t v23;
  char *v24;
  int *v25;
  int v26;
  int v27;
  int v28;
  void **v29;
  int v31;
  int v32;
  void **v33;
  int v34;
  void *__p[2];
  uint64_t v36;
  uint64_t v37;
  _BYTE buf[24];
  __int16 v39;
  int v40;
  __int16 v41;
  void **v42;
  __int16 v43;
  int v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  v2 = *__error();
  v3 = _SILogForLogForCategory(8);
  v4 = 2 * (dword_1EF19FCAC < 4);
  if (os_log_type_enabled(v3, v4))
  {
    v5 = *(_DWORD *)this;
    *(_DWORD *)buf = 67109120;
    *(_DWORD *)&buf[4] = v5;
    _os_log_impl(&dword_1B8270000, v3, v4, "Calling create for fd %d", buf, 8u);
  }
  *__error() = v2;
  DocStore::init_file_backed_bloom_map((int *)this);
  __p[0] = 0;
  __p[1] = 0;
  v36 = 0;
  v6 = *(_DWORD *)this;
  std::string::basic_string[abi:nn180100]<0>(buf, "hot.");
  *((_DWORD *)this + 1) = shard_file;
  if ((buf[23] & 0x80000000) != 0)
  {
    operator delete(*(void **)buf);
    shard_file = *((unsigned int *)this + 1);
    if ((shard_file & 0x80000000) == 0)
      goto LABEL_5;
  }
  else if ((shard_file & 0x80000000) == 0)
  {
LABEL_5:
    v37 = 8;
    *(_QWORD *)buf = &v37;
    *(_QWORD *)&buf[8] = 8;
    v8 = pwritevall(shard_file, buf, 1, 0);
    if (v8)
    {
      v9 = v8;
      v10 = *__error();
      v11 = _SILogForLogForCategory(8);
      v12 = 2 * (dword_1EF19FCAC < 4);
      if (os_log_type_enabled(v11, v12))
      {
        v13 = *(_DWORD *)this;
        v14 = *((_DWORD *)this + 1);
        v15 = __p;
        if (v36 < 0)
          v15 = (void **)__p[0];
        *(_DWORD *)buf = 67109890;
        *(_DWORD *)&buf[4] = v13;
        *(_WORD *)&buf[8] = 1024;
        *(_DWORD *)&buf[10] = v14;
        *(_WORD *)&buf[14] = 2080;
        *(_QWORD *)&buf[16] = v15;
        v39 = 1024;
        v40 = v9;
        _os_log_impl(&dword_1B8270000, v11, v12, "Error calling hot_shard_init for fd %d, hotfd %d, filename '%s': %d", buf, 0x1Eu);
      }
      *__error() = v10;
    }
    caching_hot_shard_alloc((uint64_t *)this + 1);
    v16 = (CachingHotShard *)*((_QWORD *)this + 1);
    if (v16)
      v17 = CachingHotShard::Bind(v16, *((_DWORD *)this + 1));
    else
      v17 = 4294967282;
    v20 = *__error();
    v21 = _SILogForLogForCategory(8);
    v22 = v21;
    if ((_DWORD)v17)
    {
      v23 = dword_1EF19FCAC < 3;
      if (os_log_type_enabled(v21, (os_log_type_t)(dword_1EF19FCAC < 3)))
      {
        v24 = strerror(-(int)v17);
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)&buf[4] = v24;
        _os_log_impl(&dword_1B8270000, v22, v23, "*warn* caching_hot_shard_bind: %s", buf, 0xCu);
      }
      v25 = __error();
    }
    else
    {
      v26 = (2 * (dword_1EF19FCAC < 4));
      if (os_log_type_enabled(v21, (os_log_type_t)(2 * (dword_1EF19FCAC < 4))))
      {
        v27 = *(_DWORD *)this;
        v28 = *((_DWORD *)this + 1);
        v29 = __p;
        if (v36 < 0)
          v29 = (void **)__p[0];
        *(_DWORD *)buf = 67109634;
        *(_DWORD *)&buf[4] = v27;
        *(_WORD *)&buf[8] = 1024;
        *(_DWORD *)&buf[10] = v28;
        *(_WORD *)&buf[14] = 2080;
        *(_QWORD *)&buf[16] = v29;
        _os_log_impl(&dword_1B8270000, v22, (os_log_type_t)v26, "Created hotshard for fd %d, hotfd %d, filename '%s'", buf, 0x18u);
      }
      v25 = __error();
      v17 = 0;
    }
    *v25 = v20;
    goto LABEL_27;
  }
  v18 = *__error();
  v19 = _SILogForLogForCategory(8);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    v32 = *(_DWORD *)this;
    v31 = *((_DWORD *)this + 1);
    if (v36 >= 0)
      v33 = __p;
    else
      v33 = (void **)__p[0];
    v34 = *__error();
    *(_DWORD *)buf = 136316418;
    *(_QWORD *)&buf[4] = "create";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 333;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = v32;
    v39 = 1024;
    v40 = v31;
    v41 = 2080;
    v42 = v33;
    v43 = 1024;
    v44 = v34;
    _os_log_error_impl(&dword_1B8270000, v19, OS_LOG_TYPE_ERROR, "%s:%d: Error calling mkstempsat_np for fd %d, hotfd %d, filename '%s': %d", buf, 0x2Eu);
  }
  *__error() = v18;
  v17 = -*__error();
LABEL_27:
  if (SHIBYTE(v36) < 0)
    operator delete(__p[0]);
  return v17;
}

uint64_t `anonymous namespace'::create_shard_file(int a1, uint64_t a2, uint64_t a3)
{
  char *v3;

  v3 = (char *)a3;
  if (v3[23] < 0)
    v3 = *(char **)v3;
  return mkstempsat_np(a1, v3, 0);
}

void `anonymous namespace'::create_shard_filename(uint64_t a1, uint64_t a2)
{
  std::chrono::system_clock::time_point v4;
  int v5;
  const std::string::value_type *v6;
  std::string::size_type v7;
  std::string *v8;
  std::string::size_type v9;
  std::string *v10;
  std::string::size_type v11;
  char v12;
  uint64_t v13;
  std::string v14;
  std::string v15;
  _QWORD v16[3];

  v16[2] = *MEMORY[0x1E0C80C00];
  v4.__d_.__rep_ = std::chrono::system_clock::now().__d_.__rep_;
  std::to_string(&v14, v4.__d_.__rep_);
  v5 = *(char *)(a1 + 23);
  if (v5 >= 0)
    v6 = (const std::string::value_type *)a1;
  else
    v6 = *(const std::string::value_type **)a1;
  if (v5 >= 0)
    v7 = *(unsigned __int8 *)(a1 + 23);
  else
    v7 = *(_QWORD *)(a1 + 8);
  v8 = std::string::insert(&v14, 0, v6, v7);
  v9 = v8->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v15.__r_.__value_.__l.__data_ = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
  v15.__r_.__value_.__r.__words[2] = v9;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  v10 = std::string::append(&v15, ".XXXXXX");
  v11 = v10->__r_.__value_.__r.__words[0];
  v16[0] = v10->__r_.__value_.__l.__size_;
  *(_QWORD *)((char *)v16 + 7) = *(std::string::size_type *)((char *)&v10->__r_.__value_.__r.__words[1] + 7);
  v12 = HIBYTE(v10->__r_.__value_.__r.__words[2]);
  v10->__r_.__value_.__l.__size_ = 0;
  v10->__r_.__value_.__r.__words[2] = 0;
  v10->__r_.__value_.__r.__words[0] = 0;
  if (*(char *)(a2 + 23) < 0)
    operator delete(*(void **)a2);
  v13 = v16[0];
  *(_QWORD *)a2 = v11;
  *(_QWORD *)(a2 + 8) = v13;
  *(_QWORD *)(a2 + 15) = *(_QWORD *)((char *)v16 + 7);
  *(_BYTE *)(a2 + 23) = v12;
  if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v15.__r_.__value_.__l.__data_);
  if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v14.__r_.__value_.__l.__data_);
}

uint64_t ___ZN8DocStore30add_cold_shard_to_bloom_filterEi_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  NSObject *v4;
  os_log_type_t v5;
  int v7;
  char *v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)(*(_QWORD *)(a1 + 32) + 184))
  {
    v2 = FileBackedBloomMap::Update(*(FileBackedBloomMap **)(*(_QWORD *)(a1 + 32) + 184), a2, *(int *)(a1 + 40));
    if (!(_DWORD)v2)
      return v2;
  }
  else
  {
    v2 = 4294967282;
  }
  v3 = *__error();
  v4 = _SILogForLogForCategory(8);
  v5 = dword_1EF19FCAC < 3;
  if (os_log_type_enabled(v4, (os_log_type_t)(dword_1EF19FCAC < 3)))
  {
    v7 = 136315138;
    v8 = strerror(-(int)v2);
    _os_log_impl(&dword_1B8270000, v4, v5, "*warn* add_cold_shard_to_bloom_filter:  file_backed_bloom_map_update: %s", (uint8_t *)&v7, 0xCu);
  }
  *__error() = v3;
  return v2;
}

uint64_t ___ZN8DocStore17do_cool_hot_shardEv_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, size_t a5)
{
  _QWORD *v8;
  unint64_t v9;
  char *v10;
  _QWORD *v11;
  char *v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  char *v17;
  char *v18;
  __int128 v19;
  uint64_t v20;
  _QWORD *v22;
  unint64_t v23;
  char *v24;
  _QWORD *v25;
  char *v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  BOOL v30;
  unint64_t v31;
  uint64_t v32;
  size_t *v33;
  unint64_t v34;
  size_t v35;
  int v36;
  NSObject *v37;
  os_log_type_t v38;
  char *v39;
  iovec buf;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  ++**(_QWORD **)(a1 + 32);
  v8 = *(_QWORD **)(a1 + 40);
  v8[1] += a5;
  v10 = (char *)v8[3];
  v9 = v8[4];
  if ((unint64_t)v10 >= v9)
  {
    v12 = (char *)v8[2];
    v13 = (v10 - v12) >> 5;
    v14 = v13 + 1;
    if ((unint64_t)(v13 + 1) >> 59)
      goto LABEL_41;
    v15 = v9 - (_QWORD)v12;
    if (v15 >> 4 > v14)
      v14 = v15 >> 4;
    if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFE0)
      v16 = 0x7FFFFFFFFFFFFFFLL;
    else
      v16 = v14;
    if (v16)
    {
      if (v16 >> 59)
        std::__throw_bad_array_new_length[abi:nn180100]();
      v17 = (char *)operator new(32 * v16);
    }
    else
    {
      v17 = 0;
    }
    v18 = &v17[32 * v13];
    *((_QWORD *)v18 + 1) = 0;
    *((_QWORD *)v18 + 2) = 0;
    *(_QWORD *)v18 = a2;
    *((_WORD *)v18 + 12) = 0;
    v11 = v18 + 32;
    if (v10 != v12)
    {
      do
      {
        v19 = *((_OWORD *)v10 - 2);
        *(_OWORD *)(v18 - 22) = *(_OWORD *)(v10 - 22);
        *((_OWORD *)v18 - 2) = v19;
        v18 -= 32;
        v10 -= 32;
      }
      while (v10 != v12);
      v10 = (char *)v8[2];
    }
    v8[2] = v18;
    v8[3] = v11;
    v8[4] = &v17[32 * v16];
    if (v10)
      operator delete(v10);
  }
  else
  {
    *((_QWORD *)v10 + 1) = 0;
    *((_QWORD *)v10 + 2) = 0;
    *(_QWORD *)v10 = a2;
    v11 = v10 + 32;
    *((_WORD *)v10 + 12) = 0;
  }
  v8[3] = v11;
  if (*v8 > 4uLL)
  {
    fprintf((FILE *)*MEMORY[0x1E0C80C10], "logic error:  unknown compression type %llx\n", *v8);
    abort();
  }
  if (*v8 != 2)
    return 0;
  v22 = (_QWORD *)v8[12];
  v22[1] += a5;
  v24 = (char *)v22[4];
  v23 = v22[5];
  if ((unint64_t)v24 >= v23)
  {
    v26 = (char *)v22[3];
    v27 = (v24 - v26) >> 3;
    v28 = v27 + 1;
    if (!((unint64_t)(v27 + 1) >> 61))
    {
      v29 = v23 - (_QWORD)v26;
      if (v29 >> 2 > v28)
        v28 = v29 >> 2;
      v30 = (unint64_t)v29 >= 0x7FFFFFFFFFFFFFF8;
      v31 = 0x1FFFFFFFFFFFFFFFLL;
      if (!v30)
        v31 = v28;
      if (v31)
      {
        v31 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v31);
        v26 = (char *)v22[3];
        v24 = (char *)v22[4];
      }
      else
      {
        v32 = 0;
      }
      v33 = (size_t *)(v31 + 8 * v27);
      v34 = v31 + 8 * v32;
      *v33 = a5;
      v25 = v33 + 1;
      while (v24 != v26)
      {
        v35 = *((_QWORD *)v24 - 1);
        v24 -= 8;
        *--v33 = v35;
      }
      v22[3] = v33;
      v22[4] = v25;
      v22[5] = v34;
      if (v26)
        operator delete(v26);
      goto LABEL_37;
    }
LABEL_41:
    abort();
  }
  *(_QWORD *)v24 = a5;
  v25 = v24 + 8;
LABEL_37:
  v22[4] = v25;
  buf.iov_base = a4;
  buf.iov_len = a5;
  v20 = writevall(*(unsigned int *)v22, &buf, 1);
  if ((_DWORD)v20)
  {
    v36 = *__error();
    v37 = _SILogForLogForCategory(8);
    v38 = dword_1EF19FCAC < 3;
    if (os_log_type_enabled(v37, (os_log_type_t)(dword_1EF19FCAC < 3)))
    {
      v39 = strerror(-(int)v20);
      LODWORD(buf.iov_base) = 136315138;
      *(void **)((char *)&buf.iov_base + 4) = v39;
      _os_log_impl(&dword_1B8270000, v37, v38, "*warn* do_cool_hot_shard: cold_shard_first_pass_update_for_document: %s", (uint8_t *)&buf, 0xCu);
    }
    *__error() = v36;
  }
  return v20;
}

uint64_t ___ZN8DocStore17do_cool_hot_shardEv_block_invoke_22(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _BOOL4 v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  size_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  const char *v24;
  uint64_t v25;
  FILE **v26;
  unint64_t v27;
  FILE *v28;
  const char *ErrorName;
  unint64_t v30;
  unint64_t v31;
  const char *v32;
  FILE *v33;
  const char *v34;
  FILE *v35;
  char *v36;
  int v37;
  NSObject *v38;
  os_log_type_t v39;
  char *v40;
  iovec *v42;
  std::string::size_type __n[2];
  __int128 v44;
  uint64_t v45;
  iovec __s[4096];
  uint64_t v47;

  v1 = MEMORY[0x1E0C80A78](a1);
  v5 = v4;
  v6 = v3;
  v47 = *MEMORY[0x1E0C80C00];
  ++**(_QWORD **)(v1 + 32);
  v7 = *(_QWORD *)(v1 + 40);
  v9 = *(_QWORD *)(v7 + 16);
  v8 = *(_QWORD *)(v7 + 24);
  if (v8 != v9)
  {
    v10 = (v8 - v9) >> 5;
    do
    {
      v11 = v10 >> 1;
      v12 = v9 + 32 * (v10 >> 1);
      v13 = *(_QWORD *)v12 < v2;
      if (*(_QWORD *)v12 == v2)
        v13 = *(_BYTE *)(v12 + 24) != 0;
      v14 = v12 + 32;
      v10 += ~(v10 >> 1);
      if (v13)
        v9 = v14;
      else
        v10 = v11;
    }
    while (v10);
  }
  if (v9 == v8)
    __assert_rtn("cold_shard_second_pass_update_for_document", "ColdShard.cc", 200, "doc_meta != ctx->doc_metas.end()");
  v15 = *(unsigned int *)(v1 + 48);
  *(_BYTE *)(v9 + 24) = 1;
  if (v9 + 32 != v8 && *(_QWORD *)(v9 + 32) == v2)
    return 0;
  v17 = (void *)(v7 + 72);
  v16 = 4294967194;
  switch(*(_QWORD *)v7)
  {
    case 0:
      MEMORY[0x1BCCB03BC](v7 + 72, v3, v4);
      goto LABEL_15;
    case 1:
      if (*(char *)(v7 + 95) < 0)
      {
        **(_BYTE **)(v7 + 72) = 0;
        *(_QWORD *)(v7 + 80) = 0;
      }
      else
      {
        *(_BYTE *)(v7 + 72) = 0;
        *(_BYTE *)(v7 + 95) = 0;
      }
      v21 = cctx;
      if (!cctx)
      {
        zstd_compress_init();
        v21 = cctx;
      }
      bzero(__s, 0x10000uLL);
      *(_QWORD *)&v44 = v6;
      *((_QWORD *)&v44 + 1) = v5;
      v45 = 0;
      v42 = __s;
      *(_OWORD *)__n = xmmword_1B8631BD0;
      ZSTD_CCtx_reset(v21, 1);
      v23 = v22;
      if (ZDICT_isError(v22))
      {
        v24 = "ZSTD_CCtx_reset: %s\n";
      }
      else
      {
        ZSTD_initCStream(cctx, 9);
        v23 = v27;
        if (ZDICT_isError(v27))
        {
          v24 = "ZSTD_initCStream: %s\n";
        }
        else
        {
          v24 = "ZSTD_compressStream2: %s\n";
          while (1)
          {
            v23 = ZSTD_compressStream2(cctx, (uint64_t *)&v42, &v44, 2u);
            if (ZDICT_isError(v23))
              break;
            if (__n[1])
            {
              std::string::append((std::string *)(v7 + 72), (const std::string::value_type *)__s, __n[1]);
              __n[1] = 0;
            }
            if (!v23 && v45 == *((_QWORD *)&v44 + 1))
              goto LABEL_15;
          }
        }
      }
      v28 = (FILE *)*MEMORY[0x1E0C80C10];
      ErrorName = ZDICT_getErrorName(v23);
      fprintf(v28, v24, ErrorName);
      v16 = 4294967284;
      goto LABEL_60;
    case 2:
      if (*(char *)(v7 + 95) < 0)
      {
        **(_BYTE **)(v7 + 72) = 0;
        *(_QWORD *)(v7 + 80) = 0;
      }
      else
      {
        *(_BYTE *)(v7 + 72) = 0;
        *(_BYTE *)(v7 + 95) = 0;
      }
      v25 = *(_QWORD *)(v7 + 96);
      v26 = (FILE **)MEMORY[0x1E0C80C10];
      if (*(_BYTE *)(v25 + 16))
      {
        v16 = 4294967274;
LABEL_59:
        v35 = *v26;
        v36 = strerror(-(int)v16);
        fprintf(v35, "zstd_dict_compress_do: %s\n", v36);
        goto LABEL_60;
      }
      bzero(__s, 0x10000uLL);
      *(_QWORD *)&v44 = v6;
      *((_QWORD *)&v44 + 1) = v5;
      v45 = 0;
      v42 = __s;
      *(_OWORD *)__n = xmmword_1B8631BD0;
      ZSTD_CCtx_reset(*(_QWORD *)(v25 + 80), 1);
      v31 = v30;
      if (ZDICT_isError(v30))
      {
        v16 = 4294967284;
        v32 = "ZSTD_CCtx_reset: %s\n";
LABEL_58:
        v33 = *v26;
        v34 = ZDICT_getErrorName(v31);
        fprintf(v33, v32, v34);
        goto LABEL_59;
      }
      v32 = "ZSTD_compressStream2: %s\n";
      do
      {
        v31 = ZSTD_compressStream2(*(_QWORD *)(v25 + 80), (uint64_t *)&v42, &v44, 2u);
        if (ZDICT_isError(v31))
        {
          v16 = 4294967274;
          goto LABEL_58;
        }
        if (__n[1])
        {
          std::string::append((std::string *)(v7 + 72), (const std::string::value_type *)__s, __n[1]);
          __n[1] = 0;
        }
      }
      while (v31 || v45 != *((_QWORD *)&v44 + 1));
LABEL_15:
      if (*(char *)(v7 + 95) < 0)
        v18 = *(_QWORD *)(v7 + 80);
      else
        v18 = *(unsigned __int8 *)(v7 + 95);
      *(_QWORD *)(v9 + 16) = v18;
      *(_BYTE *)(v9 + 25) = 1;
      v19 = *(_QWORD *)(v7 + 40);
      *(_QWORD *)(v9 + 8) = v19;
      if (*(char *)(v7 + 95) < 0)
      {
        v17 = *(void **)(v7 + 72);
        v20 = *(_QWORD *)(v7 + 80);
      }
      else
      {
        v20 = *(unsigned __int8 *)(v7 + 95);
      }
      *(_QWORD *)(v7 + 40) = v19 + v20;
      __s[0].iov_base = v17;
      __s[0].iov_len = v20;
      v16 = writevall(v15, __s, 1);
      if ((_DWORD)v16)
      {
LABEL_60:
        v37 = *__error();
        v38 = _SILogForLogForCategory(8);
        v39 = dword_1EF19FCAC < 3;
        if (os_log_type_enabled(v38, (os_log_type_t)(dword_1EF19FCAC < 3)))
        {
          v40 = strerror(-(int)v16);
          LODWORD(__s[0].iov_base) = 136315138;
          *(void **)((char *)&__s[0].iov_base + 4) = v40;
          _os_log_impl(&dword_1B8270000, v38, v39, "*warn* do_cool_hot_shard: cold_shard_second_pass_update_for_document: %s", (uint8_t *)__s, 0xCu);
        }
        *__error() = v37;
      }
      return v16;
    case 3:
      if (*(char *)(v7 + 95) < 0)
      {
        **(_BYTE **)(v7 + 72) = 0;
        *(_QWORD *)(v7 + 80) = 0;
      }
      else
      {
        *(_BYTE *)(v7 + 72) = 0;
        *(_BYTE *)(v7 + 95) = 0;
      }
      goto LABEL_60;
    case 4:
      goto LABEL_60;
    default:
      fprintf((FILE *)*MEMORY[0x1E0C80C10], "logic error:  unknown compression type %llx\n", *(_QWORD *)v7);
      abort();
  }
}

_QWORD *std::vector<DocStore::ColdShardDescriptor>::push_back[abi:nn180100](_QWORD *result, __int128 *a2)
{
  char **v3;
  _QWORD *v4;
  unint64_t v5;
  unint64_t v6;
  __int128 v7;
  char *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  char *v19;
  __int128 v20;
  int64x2_t v21;
  char *v22;
  uint64_t v23;
  int64x2_t v24;
  char *v25;
  _QWORD *v26;

  v3 = (char **)result;
  v4 = result + 2;
  v5 = result[2];
  v6 = result[1];
  if (v6 >= v5)
  {
    v9 = (uint64_t)(v6 - *result) >> 5;
    v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 59)
      abort();
    v11 = v5 - *result;
    if (v11 >> 4 > v10)
      v10 = v11 >> 4;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFE0)
      v12 = 0x7FFFFFFFFFFFFFFLL;
    else
      v12 = v10;
    v26 = v4;
    v13 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<std::pair<std::string,_freeTextCandidate *>>>(v12);
    v15 = &v13[32 * v9];
    v16 = *((_QWORD *)a2 + 2);
    *(_OWORD *)v15 = *a2;
    *((_QWORD *)v15 + 2) = v16;
    *((_QWORD *)a2 + 1) = 0;
    *((_QWORD *)a2 + 2) = 0;
    *(_QWORD *)a2 = 0;
    *((_WORD *)v15 + 12) = *((_WORD *)a2 + 12);
    v18 = *v3;
    v17 = (unint64_t)v3[1];
    if ((char *)v17 == *v3)
    {
      v21 = vdupq_n_s64(v17);
      v19 = &v13[32 * v9];
    }
    else
    {
      v19 = &v13[32 * v9];
      do
      {
        v20 = *(_OWORD *)(v17 - 32);
        *((_QWORD *)v19 - 2) = *(_QWORD *)(v17 - 16);
        *((_OWORD *)v19 - 2) = v20;
        *(_QWORD *)(v17 - 24) = 0;
        *(_QWORD *)(v17 - 16) = 0;
        *(_QWORD *)(v17 - 32) = 0;
        *((_WORD *)v19 - 4) = *(_WORD *)(v17 - 8);
        v19 -= 32;
        v17 -= 32;
      }
      while ((char *)v17 != v18);
      v21 = *(int64x2_t *)v3;
    }
    v8 = v15 + 32;
    *v3 = v19;
    v3[1] = v15 + 32;
    v24 = v21;
    v22 = v3[2];
    v3[2] = &v13[32 * v14];
    v25 = v22;
    v23 = v21.i64[0];
    result = (_QWORD *)std::__split_buffer<std::pair<std::string,_freeTextCandidate *>>::~__split_buffer((uint64_t)&v23);
  }
  else
  {
    v7 = *a2;
    *(_QWORD *)(v6 + 16) = *((_QWORD *)a2 + 2);
    *(_OWORD *)v6 = v7;
    *((_QWORD *)a2 + 1) = 0;
    *((_QWORD *)a2 + 2) = 0;
    *(_QWORD *)a2 = 0;
    *(_WORD *)(v6 + 24) = *((_WORD *)a2 + 12);
    v8 = (char *)(v6 + 32);
  }
  v3[1] = v8;
  return result;
}

uint64_t DocStore::MarkDocPurgeableTillN(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  int v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  int v10;
  int v11;
  uint8_t v12[16];
  uint64_t v13;
  uint64_t v14;

  v1 = *(_QWORD *)(this + 24) - *(_QWORD *)(this + 16);
  if (v1 >= 1)
  {
    v2 = this;
    v3 = 0;
    v4 = (unint64_t)v1 >> 5;
    v5 = *(_QWORD *)(this + 104);
    v6 = v4 + 1;
    v7 = 32 * v4 - 32;
    v8 = MEMORY[0x1E0C81028];
    do
    {
      v9 = *(_QWORD *)(v2 + 16) + v7;
      if (*(char *)(v9 + 23) < 0)
        v9 = *(_QWORD *)v9;
      this = openat(*(_DWORD *)v2, (const char *)v9, 0);
      if ((this & 0x80000000) == 0)
      {
        v10 = this;
        v14 = 0;
        cold_shard_create_search_context_for_fd(this, &v14);
        if (!v11)
          v5 += *(_QWORD *)(v14 + 48);
        v3 |= v5 > 0x5005;
        if ((v3 & 1) != 0)
        {
          v13 = 65541;
          if (ffsctl(v10, 0xC0084A44uLL, &v13, 0))
          {
            if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)v12 = 0;
              _os_log_error_impl(&dword_1B8270000, v8, OS_LOG_TYPE_ERROR, "TextStore - error: could not mark resource directory purgeable", v12, 2u);
            }
          }
          else if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
          {
            *(_WORD *)v12 = 0;
            _os_log_impl(&dword_1B8270000, v8, OS_LOG_TYPE_INFO, "TextStore - marked resources purgeable", v12, 2u);
          }
        }
        close(v10);
        this = v14;
        if (v14)
          this = MEMORY[0x1BCCB06A4](v14, 0x1000C4034A301B9);
      }
      --v6;
      v7 -= 32;
    }
    while (v6 > 1);
  }
  return this;
}

void std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<DocStore::ColdShardDescriptor *&,DocStore::ColdShardDescriptor *&>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  char v4;
  __int16 v5;
  uint64_t v6;
  _BYTE v7[15];

  v3 = *a1;
  *(_QWORD *)v7 = a1[1];
  *(_QWORD *)&v7[7] = *(uint64_t *)((char *)a1 + 15);
  v4 = *((_BYTE *)a1 + 23);
  a1[1] = 0;
  a1[2] = 0;
  *a1 = 0;
  v5 = *((_WORD *)a1 + 12);
  v6 = *(_QWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  a1[2] = v6;
  *(_BYTE *)(a2 + 23) = 0;
  *(_BYTE *)a2 = 0;
  *((_WORD *)a1 + 12) = *(_WORD *)(a2 + 24);
  if (*(char *)(a2 + 23) < 0)
    operator delete(*(void **)a2);
  *(_QWORD *)a2 = v3;
  *(_QWORD *)(a2 + 8) = *(_QWORD *)v7;
  *(_QWORD *)(a2 + 15) = *(_QWORD *)&v7[7];
  *(_BYTE *)(a2 + 23) = v4;
  *(_WORD *)(a2 + 24) = v5;
}

void std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,DocStore::load(analytics::OpenEvent *,BOOL)::{lambda(DocStore::ColdShardDescriptor const&,DocStore::ColdShardDescriptor const&)#1} &,DocStore::ColdShardDescriptor*>(const void **a1, uint64_t a2, uint64_t a3)
{
  int v6;
  int v7;
  size_t v8;
  const void *v9;
  size_t v10;
  const void *v11;
  size_t v12;
  int v13;
  BOOL v14;
  int v15;
  size_t v16;
  const void *v17;
  size_t v18;
  int v19;
  _BOOL4 v20;
  uint64_t *v21;
  int v22;
  int v23;
  size_t v24;
  const void *v25;
  size_t v26;
  const void *v27;
  size_t v28;
  int v29;
  _BOOL4 v30;
  uint64_t v31;
  int v32;
  int v33;
  size_t v34;
  const void *v35;
  size_t v36;
  const void *v37;
  size_t v38;
  int v39;
  _BOOL4 v40;

  v6 = *((char *)a1 + 23);
  v7 = *(char *)(a2 + 23);
  if (v7 >= 0)
    v8 = *(unsigned __int8 *)(a2 + 23);
  else
    v8 = *(_QWORD *)(a2 + 8);
  if (v7 >= 0)
    v9 = (const void *)a2;
  else
    v9 = *(const void **)a2;
  if (v6 >= 0)
    v10 = *((unsigned __int8 *)a1 + 23);
  else
    v10 = (size_t)a1[1];
  if (v6 >= 0)
    v11 = a1;
  else
    v11 = *a1;
  if (v10 >= v8)
    v12 = v8;
  else
    v12 = v10;
  v13 = memcmp(v9, v11, v12);
  if (v13)
    v14 = v13 < 0;
  else
    v14 = v8 < v10;
  v15 = *(char *)(a3 + 23);
  if (v15 >= 0)
    v16 = *(unsigned __int8 *)(a3 + 23);
  else
    v16 = *(_QWORD *)(a3 + 8);
  if (v15 >= 0)
    v17 = (const void *)a3;
  else
    v17 = *(const void **)a3;
  if (v8 >= v16)
    v18 = v16;
  else
    v18 = v8;
  v19 = memcmp(v17, v9, v18);
  v20 = v16 < v8;
  if (v19)
    v20 = v19 < 0;
  if (v14)
  {
    v21 = (uint64_t *)a1;
    if (v20)
    {
LABEL_51:
      v31 = a3;
LABEL_72:
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<DocStore::ColdShardDescriptor *&,DocStore::ColdShardDescriptor *&>(v21, v31);
      return;
    }
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<DocStore::ColdShardDescriptor *&,DocStore::ColdShardDescriptor *&>((uint64_t *)a1, a2);
    v22 = *(char *)(a2 + 23);
    v23 = *(char *)(a3 + 23);
    if (v23 >= 0)
      v24 = *(unsigned __int8 *)(a3 + 23);
    else
      v24 = *(_QWORD *)(a3 + 8);
    if (v23 >= 0)
      v25 = (const void *)a3;
    else
      v25 = *(const void **)a3;
    if (v22 >= 0)
      v26 = *(unsigned __int8 *)(a2 + 23);
    else
      v26 = *(_QWORD *)(a2 + 8);
    if (v22 >= 0)
      v27 = (const void *)a2;
    else
      v27 = *(const void **)a2;
    if (v26 >= v24)
      v28 = v24;
    else
      v28 = v26;
    v29 = memcmp(v25, v27, v28);
    v30 = v24 < v26;
    if (v29)
      v30 = v29 < 0;
    if (v30)
    {
      v21 = (uint64_t *)a2;
      goto LABEL_51;
    }
  }
  else if (v20)
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<DocStore::ColdShardDescriptor *&,DocStore::ColdShardDescriptor *&>((uint64_t *)a2, a3);
    v32 = *((char *)a1 + 23);
    v33 = *(char *)(a2 + 23);
    if (v33 >= 0)
      v34 = *(unsigned __int8 *)(a2 + 23);
    else
      v34 = *(_QWORD *)(a2 + 8);
    if (v33 >= 0)
      v35 = (const void *)a2;
    else
      v35 = *(const void **)a2;
    if (v32 >= 0)
      v36 = *((unsigned __int8 *)a1 + 23);
    else
      v36 = (size_t)a1[1];
    if (v32 >= 0)
      v37 = a1;
    else
      v37 = *a1;
    if (v36 >= v34)
      v38 = v34;
    else
      v38 = v36;
    v39 = memcmp(v35, v37, v38);
    v40 = v34 < v36;
    if (v39)
      v40 = v39 < 0;
    if (v40)
    {
      v21 = (uint64_t *)a1;
      v31 = a2;
      goto LABEL_72;
    }
  }
}

void std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,DocStore::load(analytics::OpenEvent *,BOOL)::{lambda(DocStore::ColdShardDescriptor const&,DocStore::ColdShardDescriptor const&)#1} &,DocStore::ColdShardDescriptor*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v8;
  int v9;
  size_t v10;
  const void *v11;
  size_t v12;
  const void *v13;
  size_t v14;
  int v15;
  _BOOL4 v16;
  int v17;
  int v18;
  size_t v19;
  const void *v20;
  size_t v21;
  const void *v22;
  size_t v23;
  int v24;
  _BOOL4 v25;
  int v26;
  int v27;
  size_t v28;
  const void *v29;
  size_t v30;
  const void *v31;
  size_t v32;
  int v33;
  _BOOL4 v34;

  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,DocStore::load(analytics::OpenEvent *,BOOL)::{lambda(DocStore::ColdShardDescriptor const&,DocStore::ColdShardDescriptor const&)#1} &,DocStore::ColdShardDescriptor*>((const void **)a1, a2, a3);
  v8 = *(char *)(a3 + 23);
  v9 = *(char *)(a4 + 23);
  if (v9 >= 0)
    v10 = *(unsigned __int8 *)(a4 + 23);
  else
    v10 = *(_QWORD *)(a4 + 8);
  if (v9 >= 0)
    v11 = (const void *)a4;
  else
    v11 = *(const void **)a4;
  if (v8 >= 0)
    v12 = *(unsigned __int8 *)(a3 + 23);
  else
    v12 = *(_QWORD *)(a3 + 8);
  if (v8 >= 0)
    v13 = (const void *)a3;
  else
    v13 = *(const void **)a3;
  if (v12 >= v10)
    v14 = v10;
  else
    v14 = v12;
  v15 = memcmp(v11, v13, v14);
  v16 = v10 < v12;
  if (v15)
    v16 = v15 < 0;
  if (v16)
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<DocStore::ColdShardDescriptor *&,DocStore::ColdShardDescriptor *&>((uint64_t *)a3, a4);
    v17 = *(char *)(a2 + 23);
    v18 = *(char *)(a3 + 23);
    if (v18 >= 0)
      v19 = *(unsigned __int8 *)(a3 + 23);
    else
      v19 = *(_QWORD *)(a3 + 8);
    if (v18 >= 0)
      v20 = (const void *)a3;
    else
      v20 = *(const void **)a3;
    if (v17 >= 0)
      v21 = *(unsigned __int8 *)(a2 + 23);
    else
      v21 = *(_QWORD *)(a2 + 8);
    if (v17 >= 0)
      v22 = (const void *)a2;
    else
      v22 = *(const void **)a2;
    if (v21 >= v19)
      v23 = v19;
    else
      v23 = v21;
    v24 = memcmp(v20, v22, v23);
    v25 = v19 < v21;
    if (v24)
      v25 = v24 < 0;
    if (v25)
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<DocStore::ColdShardDescriptor *&,DocStore::ColdShardDescriptor *&>((uint64_t *)a2, a3);
      v26 = *(char *)(a1 + 23);
      v27 = *(char *)(a2 + 23);
      if (v27 >= 0)
        v28 = *(unsigned __int8 *)(a2 + 23);
      else
        v28 = *(_QWORD *)(a2 + 8);
      if (v27 >= 0)
        v29 = (const void *)a2;
      else
        v29 = *(const void **)a2;
      if (v26 >= 0)
        v30 = *(unsigned __int8 *)(a1 + 23);
      else
        v30 = *(_QWORD *)(a1 + 8);
      if (v26 >= 0)
        v31 = (const void *)a1;
      else
        v31 = *(const void **)a1;
      if (v30 >= v28)
        v32 = v28;
      else
        v32 = v30;
      v33 = memcmp(v29, v31, v32);
      v34 = v28 < v30;
      if (v33)
        v34 = v33 < 0;
      if (v34)
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<DocStore::ColdShardDescriptor *&,DocStore::ColdShardDescriptor *&>((uint64_t *)a1, a2);
    }
  }
}

void std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,DocStore::load(analytics::OpenEvent *,BOOL)::{lambda(DocStore::ColdShardDescriptor const&,DocStore::ColdShardDescriptor const&)#1} &,DocStore::ColdShardDescriptor*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v10;
  int v11;
  size_t v12;
  const void *v13;
  size_t v14;
  const void *v15;
  size_t v16;
  int v17;
  _BOOL4 v18;
  int v19;
  int v20;
  size_t v21;
  const void *v22;
  size_t v23;
  const void *v24;
  size_t v25;
  int v26;
  _BOOL4 v27;
  int v28;
  int v29;
  size_t v30;
  const void *v31;
  size_t v32;
  const void *v33;
  size_t v34;
  int v35;
  _BOOL4 v36;
  int v37;
  int v38;
  size_t v39;
  const void *v40;
  size_t v41;
  const void *v42;
  size_t v43;
  int v44;
  _BOOL4 v45;

  std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,DocStore::load(analytics::OpenEvent *,BOOL)::{lambda(DocStore::ColdShardDescriptor const&,DocStore::ColdShardDescriptor const&)#1} &,DocStore::ColdShardDescriptor*>(a1, a2, a3, a4);
  v10 = *(char *)(a4 + 23);
  v11 = *(char *)(a5 + 23);
  if (v11 >= 0)
    v12 = *(unsigned __int8 *)(a5 + 23);
  else
    v12 = *(_QWORD *)(a5 + 8);
  if (v11 >= 0)
    v13 = (const void *)a5;
  else
    v13 = *(const void **)a5;
  if (v10 >= 0)
    v14 = *(unsigned __int8 *)(a4 + 23);
  else
    v14 = *(_QWORD *)(a4 + 8);
  if (v10 >= 0)
    v15 = (const void *)a4;
  else
    v15 = *(const void **)a4;
  if (v14 >= v12)
    v16 = v12;
  else
    v16 = v14;
  v17 = memcmp(v13, v15, v16);
  v18 = v12 < v14;
  if (v17)
    v18 = v17 < 0;
  if (v18)
  {
    std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<DocStore::ColdShardDescriptor *&,DocStore::ColdShardDescriptor *&>((uint64_t *)a4, a5);
    v19 = *(char *)(a3 + 23);
    v20 = *(char *)(a4 + 23);
    if (v20 >= 0)
      v21 = *(unsigned __int8 *)(a4 + 23);
    else
      v21 = *(_QWORD *)(a4 + 8);
    if (v20 >= 0)
      v22 = (const void *)a4;
    else
      v22 = *(const void **)a4;
    if (v19 >= 0)
      v23 = *(unsigned __int8 *)(a3 + 23);
    else
      v23 = *(_QWORD *)(a3 + 8);
    if (v19 >= 0)
      v24 = (const void *)a3;
    else
      v24 = *(const void **)a3;
    if (v23 >= v21)
      v25 = v21;
    else
      v25 = v23;
    v26 = memcmp(v22, v24, v25);
    v27 = v21 < v23;
    if (v26)
      v27 = v26 < 0;
    if (v27)
    {
      std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<DocStore::ColdShardDescriptor *&,DocStore::ColdShardDescriptor *&>((uint64_t *)a3, a4);
      v28 = *(char *)(a2 + 23);
      v29 = *(char *)(a3 + 23);
      if (v29 >= 0)
        v30 = *(unsigned __int8 *)(a3 + 23);
      else
        v30 = *(_QWORD *)(a3 + 8);
      if (v29 >= 0)
        v31 = (const void *)a3;
      else
        v31 = *(const void **)a3;
      if (v28 >= 0)
        v32 = *(unsigned __int8 *)(a2 + 23);
      else
        v32 = *(_QWORD *)(a2 + 8);
      if (v28 >= 0)
        v33 = (const void *)a2;
      else
        v33 = *(const void **)a2;
      if (v32 >= v30)
        v34 = v30;
      else
        v34 = v32;
      v35 = memcmp(v31, v33, v34);
      v36 = v30 < v32;
      if (v35)
        v36 = v35 < 0;
      if (v36)
      {
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<DocStore::ColdShardDescriptor *&,DocStore::ColdShardDescriptor *&>((uint64_t *)a2, a3);
        v37 = *(char *)(a1 + 23);
        v38 = *(char *)(a2 + 23);
        if (v38 >= 0)
          v39 = *(unsigned __int8 *)(a2 + 23);
        else
          v39 = *(_QWORD *)(a2 + 8);
        if (v38 >= 0)
          v40 = (const void *)a2;
        else
          v40 = *(const void **)a2;
        if (v37 >= 0)
          v41 = *(unsigned __int8 *)(a1 + 23);
        else
          v41 = *(_QWORD *)(a1 + 8);
        if (v37 >= 0)
          v42 = (const void *)a1;
        else
          v42 = *(const void **)a1;
        if (v41 >= v39)
          v43 = v39;
        else
          v43 = v41;
        v44 = memcmp(v40, v42, v43);
        v45 = v39 < v41;
        if (v44)
          v45 = v44 < 0;
        if (v45)
          std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<DocStore::ColdShardDescriptor *&,DocStore::ColdShardDescriptor *&>((uint64_t *)a1, a2);
      }
    }
  }
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,DocStore::load(analytics::OpenEvent *,BOOL)::{lambda(DocStore::ColdShardDescriptor const&,DocStore::ColdShardDescriptor const&)#1} &,DocStore::ColdShardDescriptor*>(uint64_t a1, const void **a2)
{
  uint64_t v4;
  _BOOL8 result;
  uint64_t v6;
  int v7;
  int v8;
  size_t v9;
  const void **v10;
  size_t v11;
  const void *v12;
  size_t v13;
  int v14;
  _BOOL4 v15;
  const void **v16;
  const void **v17;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  size_t v22;
  const void *v23;
  size_t v24;
  const void *v25;
  size_t v26;
  int v27;
  _BOOL4 v28;
  uint64_t v29;
  uint64_t v30;
  void **v31;
  int v32;
  size_t v33;
  __int128 *v34;
  size_t v35;
  const void *v36;
  size_t v37;
  int v38;
  BOOL v39;
  uint64_t v40;
  __int128 v41;
  const void *v42;
  uint64_t v43;

  v4 = ((uint64_t)a2 - a1) >> 5;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = (uint64_t)(a2 - 4);
      v7 = *(char *)(a1 + 23);
      v8 = *((char *)a2 - 9);
      if (v8 >= 0)
        v9 = *((unsigned __int8 *)a2 - 9);
      else
        v9 = (size_t)*(a2 - 3);
      if (v8 >= 0)
        v10 = a2 - 4;
      else
        v10 = (const void **)*(a2 - 4);
      if (v7 >= 0)
        v11 = *(unsigned __int8 *)(a1 + 23);
      else
        v11 = *(_QWORD *)(a1 + 8);
      if (v7 >= 0)
        v12 = (const void *)a1;
      else
        v12 = *(const void **)a1;
      if (v11 >= v9)
        v13 = v9;
      else
        v13 = v11;
      v14 = memcmp(v10, v12, v13);
      v15 = v9 < v11;
      if (v14)
        v15 = v14 < 0;
      if (v15)
        std::_IterOps<std::_ClassicAlgPolicy>::iter_swap[abi:nn180100]<DocStore::ColdShardDescriptor *&,DocStore::ColdShardDescriptor *&>((uint64_t *)a1, v6);
      return 1;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,DocStore::load(analytics::OpenEvent *,BOOL)::{lambda(DocStore::ColdShardDescriptor const&,DocStore::ColdShardDescriptor const&)#1} &,DocStore::ColdShardDescriptor*>((const void **)a1, a1 + 32, (uint64_t)(a2 - 4));
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,DocStore::load(analytics::OpenEvent *,BOOL)::{lambda(DocStore::ColdShardDescriptor const&,DocStore::ColdShardDescriptor const&)#1} &,DocStore::ColdShardDescriptor*>(a1, a1 + 32, a1 + 64, (uint64_t)(a2 - 4));
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,DocStore::load(analytics::OpenEvent *,BOOL)::{lambda(DocStore::ColdShardDescriptor const&,DocStore::ColdShardDescriptor const&)#1} &,DocStore::ColdShardDescriptor*>(a1, a1 + 32, a1 + 64, a1 + 96, (uint64_t)(a2 - 4));
      return 1;
    default:
      v16 = (const void **)(a1 + 64);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,DocStore::load(analytics::OpenEvent *,BOOL)::{lambda(DocStore::ColdShardDescriptor const&,DocStore::ColdShardDescriptor const&)#1} &,DocStore::ColdShardDescriptor*>((const void **)a1, a1 + 32, a1 + 64);
      v17 = (const void **)(a1 + 96);
      if ((const void **)(a1 + 96) == a2)
        return 1;
      v18 = 0;
      v19 = 0;
      break;
  }
  while (1)
  {
    v20 = *((char *)v16 + 23);
    v21 = *((char *)v17 + 23);
    if (v21 >= 0)
      v22 = *((unsigned __int8 *)v17 + 23);
    else
      v22 = (size_t)v17[1];
    if (v21 >= 0)
      v23 = v17;
    else
      v23 = *v17;
    if (v20 >= 0)
      v24 = *((unsigned __int8 *)v16 + 23);
    else
      v24 = (size_t)v16[1];
    if (v20 >= 0)
      v25 = v16;
    else
      v25 = *v16;
    if (v24 >= v22)
      v26 = v22;
    else
      v26 = v24;
    v27 = memcmp(v23, v25, v26);
    v28 = v22 < v24;
    if (v27)
      v28 = v27 < 0;
    if (v28)
    {
      v41 = *(_OWORD *)v17;
      v42 = v17[2];
      v43 = 0;
      *v17 = 0;
      v17[1] = 0;
      v17[2] = 0;
      LOWORD(v43) = *((_WORD *)v17 + 12);
      v29 = v18;
      while (1)
      {
        v30 = a1 + v29;
        v31 = (void **)(a1 + v29 + 96);
        if (*(char *)(a1 + v29 + 119) < 0)
          operator delete(*v31);
        *(_OWORD *)v31 = *(_OWORD *)(v30 + 64);
        *(_QWORD *)(a1 + v29 + 112) = *(_QWORD *)(v30 + 80);
        *(_BYTE *)(v30 + 87) = 0;
        *(_BYTE *)(v30 + 64) = 0;
        *(_WORD *)(v30 + 120) = *(_WORD *)(v30 + 88);
        if (v29 == -64)
          break;
        v32 = *(char *)(a1 + v29 + 55);
        if (SHIBYTE(v42) >= 0)
          v33 = HIBYTE(v42);
        else
          v33 = *((_QWORD *)&v41 + 1);
        if (SHIBYTE(v42) >= 0)
          v34 = &v41;
        else
          v34 = (__int128 *)v41;
        if (v32 >= 0)
          v35 = *(unsigned __int8 *)(a1 + v29 + 55);
        else
          v35 = *(_QWORD *)(a1 + v29 + 40);
        if (v32 >= 0)
          v36 = (const void *)(a1 + v29 + 32);
        else
          v36 = *(const void **)(a1 + v29 + 32);
        if (v35 >= v33)
          v37 = v33;
        else
          v37 = v35;
        v38 = memcmp(v34, v36, v37);
        v39 = v33 < v35;
        if (v38)
          v39 = v38 < 0;
        v29 -= 32;
        if (!v39)
        {
          v40 = a1 + v29 + 96;
          goto LABEL_65;
        }
      }
      v40 = a1;
LABEL_65:
      if (*(char *)(v40 + 23) < 0)
        operator delete(*(void **)v40);
      *(_OWORD *)v40 = v41;
      *(_QWORD *)(v40 + 16) = v42;
      *(_WORD *)(v40 + 24) = v43;
      if (++v19 == 8)
        return v17 + 4 == a2;
    }
    v16 = v17;
    v18 += 32;
    v17 += 4;
    if (v17 == a2)
      return 1;
  }
}

BOOL std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  BOOL v6;
  _BOOL8 result;
  uint64_t v8;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  __int128 v18;
  uint64_t v19;
  uint64_t v20;

  v6 = std::less<std::string>::operator()[abi:nn180100](a2, a1);
  result = std::less<std::string>::operator()[abi:nn180100](a3, a2);
  if (v6)
  {
    if (result)
    {
      v8 = a1[2];
      v9 = *(_OWORD *)a1;
      v10 = a3[2];
      *(_OWORD *)a1 = *(_OWORD *)a3;
      a1[2] = v10;
    }
    else
    {
      v17 = a1[2];
      v18 = *(_OWORD *)a1;
      v19 = a2[2];
      *(_OWORD *)a1 = *(_OWORD *)a2;
      a1[2] = v19;
      *(_OWORD *)a2 = v18;
      a2[2] = v17;
      result = std::less<std::string>::operator()[abi:nn180100](a3, a2);
      if (!result)
        return result;
      v8 = a2[2];
      v9 = *(_OWORD *)a2;
      v20 = a3[2];
      *(_OWORD *)a2 = *(_OWORD *)a3;
      a2[2] = v20;
    }
    *(_OWORD *)a3 = v9;
    a3[2] = v8;
  }
  else if (result)
  {
    v11 = a2[2];
    v12 = *(_OWORD *)a2;
    v13 = a3[2];
    *(_OWORD *)a2 = *(_OWORD *)a3;
    a2[2] = v13;
    *(_OWORD *)a3 = v12;
    a3[2] = v11;
    result = std::less<std::string>::operator()[abi:nn180100](a2, a1);
    if (result)
    {
      v14 = a1[2];
      v15 = *(_OWORD *)a1;
      v16 = a2[2];
      *(_OWORD *)a1 = *(_OWORD *)a2;
      a1[2] = v16;
      *(_OWORD *)a2 = v15;
      a2[2] = v14;
    }
  }
  return result;
}

__n128 std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(__n128 *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4)
{
  __n128 result;
  uint64_t v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  __int128 v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;

  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(a1, a2, a3);
  if (std::less<std::string>::operator()[abi:nn180100](a4, a3))
  {
    v9 = a3[2];
    v10 = *(_OWORD *)a3;
    v11 = a4[2];
    *(_OWORD *)a3 = *(_OWORD *)a4;
    a3[2] = v11;
    *(_OWORD *)a4 = v10;
    a4[2] = v9;
    if (std::less<std::string>::operator()[abi:nn180100](a3, a2))
    {
      v12 = a2[2];
      v13 = *(_OWORD *)a2;
      v14 = a3[2];
      *(_OWORD *)a2 = *(_OWORD *)a3;
      a2[2] = v14;
      *(_OWORD *)a3 = v13;
      a3[2] = v12;
      if (std::less<std::string>::operator()[abi:nn180100](a2, a1))
      {
        v15 = a1[1].n128_u64[0];
        result = *a1;
        v16 = a2[2];
        *a1 = *(__n128 *)a2;
        a1[1].n128_u64[0] = v16;
        *(__n128 *)a2 = result;
        a2[2] = v15;
      }
    }
  }
  return result;
}

__n128 std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(__n128 *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5)
{
  __n128 result;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;
  __int128 v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;

  std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(a1, a2, a3, a4);
  if (std::less<std::string>::operator()[abi:nn180100](a5, a4))
  {
    v11 = a4[2];
    v12 = *(_OWORD *)a4;
    v13 = a5[2];
    *(_OWORD *)a4 = *(_OWORD *)a5;
    a4[2] = v13;
    *(_OWORD *)a5 = v12;
    a5[2] = v11;
    if (std::less<std::string>::operator()[abi:nn180100](a4, a3))
    {
      v14 = a3[2];
      v15 = *(_OWORD *)a3;
      v16 = a4[2];
      *(_OWORD *)a3 = *(_OWORD *)a4;
      a3[2] = v16;
      *(_OWORD *)a4 = v15;
      a4[2] = v14;
      if (std::less<std::string>::operator()[abi:nn180100](a3, a2))
      {
        v17 = a2[2];
        v18 = *(_OWORD *)a2;
        v19 = a3[2];
        *(_OWORD *)a2 = *(_OWORD *)a3;
        a2[2] = v19;
        *(_OWORD *)a3 = v18;
        a3[2] = v17;
        if (std::less<std::string>::operator()[abi:nn180100](a2, a1))
        {
          v20 = a1[1].n128_u64[0];
          result = *a1;
          v21 = a2[2];
          *a1 = *(__n128 *)a2;
          a1[1].n128_u64[0] = v21;
          *(__n128 *)a2 = result;
          a2[2] = v20;
        }
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(__n128 *a1, __n128 *a2)
{
  unint64_t v4;
  _BOOL8 result;
  __n128 *v6;
  unint64_t v7;
  __n128 v8;
  unint64_t v9;
  __n128 *v10;
  unint64_t *v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  __int128 v17;
  unint64_t v18;

  v4 = 0xAAAAAAAAAAAAAAABLL * (((char *)a2 - (char *)a1) >> 3);
  result = 1;
  switch(v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      v6 = (__n128 *)((char *)a2 - 24);
      if (std::less<std::string>::operator()[abi:nn180100](&a2[-2].n128_u64[1], a1))
      {
        v7 = a1[1].n128_u64[0];
        v8 = *a1;
        v9 = v6[1].n128_u64[0];
        *a1 = *v6;
        a1[1].n128_u64[0] = v9;
        *v6 = v8;
        v6[1].n128_u64[0] = v7;
      }
      return 1;
    case 3uLL:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(a1, &a1[1].n128_u64[1], &a2[-2].n128_u64[1]);
      return 1;
    case 4uLL:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(a1, &a1[1].n128_u64[1], (__n128 *)a1[3].n128_u64, &a2[-2].n128_u64[1]);
      return 1;
    case 5uLL:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(a1, &a1[1].n128_u64[1], (__n128 *)a1[3].n128_u64, &a1[4].n128_u64[1], &a2[-2].n128_u64[1]);
      return 1;
    default:
      v10 = a1 + 3;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::string *>(a1, &a1[1].n128_u64[1], (__n128 *)a1[3].n128_u64);
      v11 = &a1[4].n128_u64[1];
      if (&a1[4].n128_i8[8] == (__int8 *)a2)
        return 1;
      v12 = 0;
      v13 = 0;
      break;
  }
  while (1)
  {
    if (std::less<std::string>::operator()[abi:nn180100](v11, v10))
    {
      v17 = *(_OWORD *)v11;
      v18 = v11[2];
      v11[1] = 0;
      v11[2] = 0;
      *v11 = 0;
      v14 = v12;
      while (1)
      {
        v15 = (char *)a1 + v14;
        *(__n128 *)(v15 + 72) = *(__n128 *)((char *)a1 + v14 + 48);
        *((_QWORD *)v15 + 11) = *(unint64_t *)((char *)a1[4].n128_u64 + v14);
        v15[71] = 0;
        v15[48] = 0;
        if (v14 == -48)
          break;
        v14 -= 24;
        if (!std::less<std::string>::operator()[abi:nn180100](&v17, (_QWORD *)v15 + 3))
        {
          v16 = (uint64_t)&a1[4].n128_i64[1] + v14;
          goto LABEL_12;
        }
      }
      v16 = (uint64_t)a1;
LABEL_12:
      *(_OWORD *)v16 = v17;
      *(_QWORD *)(v16 + 16) = v18;
      if (++v13 == 8)
        return v11 + 3 == (unint64_t *)a2;
    }
    v10 = (__n128 *)v11;
    v12 += 24;
    v11 += 3;
    if (v11 == (unint64_t *)a2)
      return 1;
  }
}

void std::__shared_ptr_pointer<analytics::SampledLogger<analytics::DeleteEvent> *,std::shared_ptr<analytics::SampledLogger<analytics::DeleteEvent>>::__shared_ptr_default_delete<analytics::SampledLogger<analytics::DeleteEvent>,analytics::SampledLogger<analytics::DeleteEvent>>,std::allocator<analytics::SampledLogger<analytics::DeleteEvent>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BCCB06A4);
}

uint64_t std::__shared_ptr_pointer<analytics::SampledLogger<analytics::DeleteEvent> *,std::shared_ptr<analytics::SampledLogger<analytics::DeleteEvent>>::__shared_ptr_default_delete<analytics::SampledLogger<analytics::DeleteEvent>,analytics::SampledLogger<analytics::DeleteEvent>>,std::allocator<analytics::SampledLogger<analytics::DeleteEvent>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void std::__shared_ptr_pointer<analytics::SampledLogger<analytics::PutEvent> *,std::shared_ptr<analytics::SampledLogger<analytics::PutEvent>>::__shared_ptr_default_delete<analytics::SampledLogger<analytics::PutEvent>,analytics::SampledLogger<analytics::PutEvent>>,std::allocator<analytics::SampledLogger<analytics::PutEvent>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BCCB06A4);
}

uint64_t std::__shared_ptr_pointer<analytics::SampledLogger<analytics::PutEvent> *,std::shared_ptr<analytics::SampledLogger<analytics::PutEvent>>::__shared_ptr_default_delete<analytics::SampledLogger<analytics::PutEvent>,analytics::SampledLogger<analytics::PutEvent>>,std::allocator<analytics::SampledLogger<analytics::PutEvent>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void std::__shared_ptr_pointer<analytics::SampledLogger<analytics::GetEvent> *,std::shared_ptr<analytics::SampledLogger<analytics::GetEvent>>::__shared_ptr_default_delete<analytics::SampledLogger<analytics::GetEvent>,analytics::SampledLogger<analytics::GetEvent>>,std::allocator<analytics::SampledLogger<analytics::GetEvent>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BCCB06A4);
}

uint64_t std::__shared_ptr_pointer<analytics::SampledLogger<analytics::GetEvent> *,std::shared_ptr<analytics::SampledLogger<analytics::GetEvent>>::__shared_ptr_default_delete<analytics::SampledLogger<analytics::GetEvent>,analytics::SampledLogger<analytics::GetEvent>>,std::allocator<analytics::SampledLogger<analytics::GetEvent>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void doc_store_close(DocStore *a1)
{
  _QWORD v2[2];
  char __str[16];
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v33 = 0u;
  v34 = 0u;
  v31 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  v17 = 0u;
  v18 = 0u;
  v15 = 0u;
  v16 = 0u;
  v13 = 0u;
  v14 = 0u;
  v11 = 0u;
  v12 = 0u;
  v9 = 0u;
  v10 = 0u;
  v7 = 0u;
  v8 = 0u;
  v5 = 0u;
  v6 = 0u;
  *(_OWORD *)__str = 0u;
  v4 = 0u;
  snprintf(__str, 0x200uLL, "doc_store_close(%p)", a1);
  v2[0] = 0;
  v2[1] = 0;
  ScopeLogger::ScopeLogger((ScopeLogger *)v2, __str);
  if (a1)
  {
    DocStore::~DocStore(a1);
    MEMORY[0x1BCCB06A4]();
  }
  ScopeLogger::~ScopeLogger((ScopeLogger *)v2);
}

uint64_t doc_store_get_document(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned int DocumentsBulk;
  unsigned int v9;
  uint64_t v10;
  int v11;
  NSObject *v12;
  os_log_type_t v13;
  _QWORD v15[2];
  int v16;
  uint64_t v17;
  char __str[16];
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  _BYTE buf[24];
  void *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  int *v55;
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  v48 = 0u;
  v49 = 0u;
  v46 = 0u;
  v47 = 0u;
  v44 = 0u;
  v45 = 0u;
  v42 = 0u;
  v43 = 0u;
  v40 = 0u;
  v41 = 0u;
  v38 = 0u;
  v39 = 0u;
  v36 = 0u;
  v37 = 0u;
  v34 = 0u;
  v35 = 0u;
  v32 = 0u;
  v33 = 0u;
  v30 = 0u;
  v31 = 0u;
  v28 = 0u;
  v29 = 0u;
  v26 = 0u;
  v27 = 0u;
  v24 = 0u;
  v25 = 0u;
  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  v21 = 0u;
  *(_OWORD *)__str = 0u;
  v19 = 0u;
  snprintf(__str, 0x200uLL, "doc_store_get_document(%p, %lld, %zd)", a1, a2, 0x3E8uLL);
  v15[0] = 0;
  v15[1] = 0;
  ScopeLogger::ScopeLogger((ScopeLogger *)v15, __str);
  if (a1)
  {
    v17 = a2;
    v16 = 0;
    *(_QWORD *)buf = MEMORY[0x1E0C809B0];
    *(_QWORD *)&buf[8] = 0x40000000;
    *(_QWORD *)&buf[16] = ___ZN8DocStore11GetDocumentExmPcPm_block_invoke;
    v51 = &__block_descriptor_tmp_29;
    v52 = 1000;
    v53 = a3;
    v54 = a4;
    v55 = &v16;
    DocumentsBulk = DocStore::GetDocumentsBulk((uint64_t)a1);
    if (v16)
      v9 = 0;
    else
      v9 = -2;
    if (DocumentsBulk)
      v10 = DocumentsBulk;
    else
      v10 = v9;
    v11 = *__error();
    v12 = _SILogForLogForCategory(8);
    v13 = 2 * (dword_1EF19FCAC < 4);
    if (os_log_type_enabled(v12, v13))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "doc_store_get_document";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v10;
      _os_log_impl(&dword_1B8270000, v12, v13, "%s returns %d\n", buf, 0x12u);
    }
    *__error() = v11;
  }
  else
  {
    v10 = 4294967282;
  }
  ScopeLogger::~ScopeLogger((ScopeLogger *)v15);
  return v10;
}

uint64_t ___ZN8DocStore11GetDocumentExmPcPm_block_invoke(uint64_t a1, int a2, void *__src, size_t a4)
{
  void *v5;
  size_t v6;
  size_t v7;
  _DWORD *v8;

  v6 = *(_QWORD *)(a1 + 32);
  v5 = *(void **)(a1 + 40);
  if (v6 >= a4)
    v7 = a4;
  else
    v7 = v6;
  memcpy(v5, __src, v7);
  v8 = *(_DWORD **)(a1 + 56);
  **(_QWORD **)(a1 + 48) = v7;
  *v8 = 1;
  return 0;
}

uint64_t DocStore::GetDocumentsBulk(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t *v3;
  unint64_t *v4;
  uint64_t v5;
  std::mutex *v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  uint64_t v11;
  std::chrono::steady_clock::time_point v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  std::__shared_weak_count *v23;
  off_t v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  uint8x8_t v28;
  unint64_t v29;
  _QWORD **v30;
  _QWORD *i;
  unint64_t v32;
  float v33;
  _BOOL8 v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  void *v38;
  uint64_t v39;
  _QWORD **v40;
  unint64_t v41;
  uint8x8_t v42;
  uint8x8_t v43;
  std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v44;
  _QWORD *j;
  unint64_t v46;
  uint64_t v47;
  _QWORD *v48;
  unint64_t v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t v55;
  char *v56;
  _QWORD *v57;
  uint64_t v58;
  _QWORD *v59;
  uint64_t v60;
  unint64_t v61;
  FileBackedBloomMap *v62;
  char *v63;
  _BYTE *v64;
  uint64_t v65;
  char v66;
  uint64_t v67;
  uint64_t v68;
  _QWORD *v70;
  _QWORD *v71;
  void *v72;
  double v73;
  float v74;
  uint64_t v75;
  unint64_t *v76;
  unint64_t v77;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  int v82;
  unsigned int v83;
  __n128 v84;
  std::string::size_type *v85;
  unsigned int document_index;
  std::string::size_type size;
  std::string *v88;
  _QWORD *v89;
  char *v90;
  char *v91;
  unint64_t v92;
  std::string::size_type v93;
  std::string *v94;
  unint64_t v95;
  uint64_t v96;
  unint64_t v97;
  uint64_t v98;
  uint64_t v99;
  unint64_t v100;
  unsigned int v101;
  char v102;
  uint64_t v103;
  unint64_t v104;
  unint64_t v105;
  uint64_t v106;
  char *v107;
  char *v108;
  uint64_t v109;
  uint64_t v110;
  std::string::size_type *v111;
  off_t file_size;
  unint64_t v113;
  __int128 *v114;
  __int128 *v115;
  uint64_t v116;
  uint64_t v117;
  __int128 *v118;
  uint64_t v119;
  unint64_t v120;
  unint64_t v121;
  uint64_t v122;
  unint64_t v123;
  __int128 *v124;
  unint64_t v125;
  uint64_t v126;
  std::string *v127;
  std::string::size_type v128;
  unint64_t v129;
  void **v130;
  unsigned int v131;
  char *v132;
  char *v133;
  std::string *v134;
  uint64_t v135;
  off_t v136;
  unsigned int v137;
  std::string *v138;
  std::string::size_type v139;
  std::string::size_type v140;
  std::string *v141;
  std::string *v142;
  std::string::size_type v143;
  uint64_t v144;
  unint64_t v145;
  unint64_t v146;
  const char *v147;
  uint64_t v148;
  unint64_t inited;
  const char *v150;
  FILE *v151;
  const char *ErrorName;
  int v153;
  unint64_t Dictionary;
  FILE *v155;
  const char *v156;
  std::string *v157;
  std::string::size_type v158;
  unint64_t v159;
  int v160;
  std::string *v161;
  unint64_t v162;
  off_t v163;
  const void *v164;
  std::string::size_type *v165;
  void **v166;
  __int128 v167;
  int v168;
  int v169;
  uint64_t v170;
  unsigned __int8 **v171;
  uint64_t v172;
  std::__shared_weak_count *v173;
  std::mutex *v174;
  uint64_t v175;
  char *v176;
  char *v177;
  uint64_t v178;
  std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep rep;
  unsigned __int8 *v180;
  _QWORD *v181;
  _QWORD v182[2];
  uint64_t (*v183)(_QWORD *, unint64_t);
  void *v184;
  uint64_t v185;
  __int128 *v186;
  uint64_t v187;
  std::string v188;
  std::string::size_type *v189;
  __int128 v190;
  __int128 v191;
  uint64_t v192;
  _QWORD v193[2];
  std::string v194;
  std::string v195;
  char *v196[3];
  char *v197[3];
  std::string::__raw *v198;
  std::string::__raw **v199;
  uint64_t v200;
  int v201;
  std::string v202;
  std::string v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t (*v206)(_QWORD *, uint64_t, unint64_t, uint64_t);
  void *v207;
  std::string::__raw **v208;
  off_t v209;
  void *v210[8189];

  v1 = MEMORY[0x1E0C80A78](a1);
  v170 = v2;
  v4 = v3;
  v5 = v1;
  v210[8186] = *(void **)MEMORY[0x1E0C80C00];
  v6 = (std::mutex *)(v1 + 40);
  std::mutex::lock((std::mutex *)(v1 + 40));
  v8 = *(_QWORD *)(v5 + 128);
  v7 = *(std::__shared_weak_count **)(v5 + 136);
  v181 = (_QWORD *)v5;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v10 = __ldxr(p_shared_owners);
    while (__stxr(v10 + 1, p_shared_owners));
  }
  v11 = operator new();
  *(_OWORD *)v11 = 0u;
  *(_OWORD *)(v11 + 16) = 0u;
  *(_OWORD *)(v11 + 32) = 0u;
  *(_OWORD *)(v11 + 48) = 0u;
  *(_QWORD *)(v11 + 64) = 0;
  v12.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  rep = v12.__d_.__rep_;
  if (v7)
  {
    v13 = (unint64_t *)&v7->__shared_owners_;
    do
      v14 = __ldxr(v13);
    while (__stxr(v14 + 1, v13));
    do
      v15 = __ldaxr(v13);
    while (__stlxr(v15 - 1, v13));
    if (!v15)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  if (!*(_BYTE *)(v11 + 24))
    *(_BYTE *)(v11 + 24) = 1;
  *(_QWORD *)(v11 + 16) = 1;
  if (!*(_BYTE *)(v11 + 40))
    *(_BYTE *)(v11 + 40) = 1;
  *(_QWORD *)(v11 + 32) = 0;
  v192 = 1065353216;
  v190 = 0u;
  v191 = 0u;
  v16 = (_QWORD *)v181[1];
  if (v16)
  {
    v17 = *(unsigned int *)v16;
    if ((_DWORD)v17 != -1)
    {
      v18 = *v4;
      bzero(&v204, 0x2000uLL);
      v19 = v16[1];
      v20 = v16[2] - v19;
      if ((int)(v20 >> 3) >= 1)
      {
        v21 = 0;
        v22 = (v20 >> 3);
        while (*(_QWORD *)(v19 + 8 * v21) != v18)
        {
          if (v22 == ++v21)
            goto LABEL_27;
        }
        v23 = v7;
        v24 = *(_QWORD *)(v16[4] + 8 * v21);
        if (*(_QWORD *)(v16[7] + 8 * v21) >= 0x2000uLL)
          v25 = 0x2000;
        else
          v25 = *(_QWORD *)(v16[7] + 8 * v21);
        v198 = (std::string::__raw *)&v204;
        v199 = (std::string::__raw **)v25;
        v12.__d_.__rep_ = preadvall(v17, (uint64_t)&v198, v24);
        if (LODWORD(v12.__d_.__rep_))
        {
          v7 = v23;
        }
        else
        {
          v12.__d_.__rep_ = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t *, uint64_t))(v170 + 16))(v170, v18, &v204, v25);
          v7 = v23;
          if (!LODWORD(v12.__d_.__rep_))
            goto LABEL_101;
        }
      }
    }
  }
LABEL_27:
  v26 = *v4;
  v27 = *((_QWORD *)&v190 + 1);
  if (*((_QWORD *)&v190 + 1))
  {
    v28 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v190 + 8));
    v28.i16[0] = vaddlv_u8(v28);
    if (v28.u32[0] > 1uLL)
    {
      v29 = *v4;
      if (v26 >= *((_QWORD *)&v190 + 1))
        v29 = v26 % *((_QWORD *)&v190 + 1);
    }
    else
    {
      v29 = (*((_QWORD *)&v190 + 1) - 1) & v26;
    }
    v30 = *(_QWORD ***)(v190 + 8 * v29);
    if (v30)
    {
      for (i = *v30; i; i = (_QWORD *)*i)
      {
        v32 = i[1];
        if (v32 == v26)
        {
          if (i[2] == v26)
            goto LABEL_100;
        }
        else
        {
          if (v28.u32[0] > 1uLL)
          {
            if (v32 >= *((_QWORD *)&v190 + 1))
              v32 %= *((_QWORD *)&v190 + 1);
          }
          else
          {
            v32 &= *((_QWORD *)&v190 + 1) - 1;
          }
          if (v32 != v29)
            break;
        }
      }
    }
  }
  else
  {
    v29 = 0;
  }
  v12.__d_.__rep_ = (std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep)operator new(0x20uLL);
  i = (_QWORD *)v12.__d_.__rep_;
  *(_QWORD *)v12.__d_.__rep_ = 0;
  *(_QWORD *)(v12.__d_.__rep_ + 8) = v26;
  *(_QWORD *)(v12.__d_.__rep_ + 16) = v26;
  *(_QWORD *)(v12.__d_.__rep_ + 24) = 0;
  v33 = (float)(unint64_t)(*((_QWORD *)&v191 + 1) + 1);
  if (!v27 || (float)(*(float *)&v192 * (float)v27) < v33)
  {
    v34 = 1;
    if (v27 >= 3)
      v34 = (v27 & (v27 - 1)) != 0;
    v35 = v34 | (2 * v27);
    v36 = vcvtps_u32_f32(v33 / *(float *)&v192);
    if (v35 <= v36)
      v37 = v36;
    else
      v37 = v35;
    if (v37 == 1)
    {
      v37 = 2;
    }
    else if ((v37 & (v37 - 1)) != 0)
    {
      v12.__d_.__rep_ = std::__next_prime(v37);
      v37 = v12.__d_.__rep_;
      v27 = *((_QWORD *)&v190 + 1);
    }
    if (v37 > v27)
      goto LABEL_56;
    if (v37 < v27)
    {
      v12.__d_.__rep_ = vcvtps_u32_f32((float)*((unint64_t *)&v191 + 1) / *(float *)&v192);
      if (v27 < 3 || (v43 = (uint8x8_t)vcnt_s8((int8x8_t)v27), v43.i16[0] = vaddlv_u8(v43), v43.u32[0] > 1uLL))
      {
        v12.__d_.__rep_ = std::__next_prime(v12.__d_.__rep_);
      }
      else
      {
        v44 = 1 << -(char)__clz(v12.__d_.__rep_ - 1);
        if ((unint64_t)v12.__d_.__rep_ >= 2)
          v12.__d_.__rep_ = v44;
      }
      if (v37 <= v12.__d_.__rep_)
        v37 = v12.__d_.__rep_;
      if (v37 >= v27)
      {
        v27 = *((_QWORD *)&v190 + 1);
      }
      else
      {
        if (v37)
        {
LABEL_56:
          if (v37 >> 61)
            std::__throw_bad_array_new_length[abi:nn180100]();
          v38 = operator new(8 * v37);
          v12.__d_.__rep_ = v190;
          *(_QWORD *)&v190 = v38;
          if (v12.__d_.__rep_)
            operator delete((void *)v12.__d_.__rep_);
          v39 = 0;
          *((_QWORD *)&v190 + 1) = v37;
          do
            *(_QWORD *)(v190 + 8 * v39++) = 0;
          while (v37 != v39);
          v40 = (_QWORD **)v191;
          if ((_QWORD)v191)
          {
            v41 = *(_QWORD *)(v191 + 8);
            v42 = (uint8x8_t)vcnt_s8((int8x8_t)v37);
            v42.i16[0] = vaddlv_u8(v42);
            if (v42.u32[0] > 1uLL)
            {
              if (v41 >= v37)
                v41 %= v37;
            }
            else
            {
              v41 &= v37 - 1;
            }
            *(_QWORD *)(v190 + 8 * v41) = &v191;
            for (j = *v40; j; v41 = v46)
            {
              v46 = j[1];
              if (v42.u32[0] > 1uLL)
              {
                if (v46 >= v37)
                  v46 %= v37;
              }
              else
              {
                v46 &= v37 - 1;
              }
              if (v46 != v41)
              {
                if (!*(_QWORD *)(v190 + 8 * v46))
                {
                  *(_QWORD *)(v190 + 8 * v46) = v40;
                  goto LABEL_81;
                }
                *v40 = (_QWORD *)*j;
                *j = **(_QWORD **)(v190 + 8 * v46);
                **(_QWORD **)(v190 + 8 * v46) = j;
                j = v40;
              }
              v46 = v41;
LABEL_81:
              v40 = (_QWORD **)j;
              j = (_QWORD *)*j;
            }
          }
          v27 = v37;
          goto LABEL_85;
        }
        v12.__d_.__rep_ = v190;
        *(_QWORD *)&v190 = 0;
        if (v12.__d_.__rep_)
          operator delete((void *)v12.__d_.__rep_);
        v27 = 0;
        *((_QWORD *)&v190 + 1) = 0;
      }
    }
LABEL_85:
    if ((v27 & (v27 - 1)) != 0)
    {
      if (v26 >= v27)
        v29 = v26 % v27;
      else
        v29 = v26;
    }
    else
    {
      v29 = (v27 - 1) & v26;
    }
  }
  v47 = v190;
  v48 = *(_QWORD **)(v190 + 8 * v29);
  if (v48)
  {
    *i = *v48;
  }
  else
  {
    *i = v191;
    *(_QWORD *)&v191 = i;
    *(_QWORD *)(v47 + 8 * v29) = &v191;
    if (!*i)
      goto LABEL_99;
    v49 = *(_QWORD *)(*i + 8);
    if ((v27 & (v27 - 1)) != 0)
    {
      if (v49 >= v27)
        v49 %= v27;
    }
    else
    {
      v49 &= v27 - 1;
    }
    v48 = (_QWORD *)(v190 + 8 * v49);
  }
  *v48 = i;
LABEL_99:
  ++*((_QWORD *)&v191 + 1);
LABEL_100:
  ++i[3];
LABEL_101:
  v50 = v181[3] - v181[2];
  if (v50)
  {
    v173 = v7;
    v174 = v6;
    v51 = v8;
    v171 = (unsigned __int8 **)&v161;
    v52 = (v50 >> 5) + 7;
    v53 = v52 >> 3;
    v54 = MEMORY[0x1E0C80A78](v12.__d_.__rep_);
    MEMORY[0x1E0C80A78](v54);
    v56 = (char *)&v161 - v55;
    bzero((char *)&v161 - v55, v52 >> 3);
    v180 = (unsigned __int8 *)&v161 - (((v52 >> 3) + 15) & 0x3FFFFFFFFFFFFFF0);
    bzero(v180, v52 >> 3);
    v57 = (_QWORD *)v191;
    if ((_QWORD)v191)
    {
      v58 = (v52 >> 3);
      v59 = v181;
      do
      {
        v60 = v57[2];
        v61 = (unint64_t)(((uint64_t)(v59[3] - v59[2]) >> 5) + 7) >> 3;
        memset(v56, 255, v61);
        v62 = (FileBackedBloomMap *)v59[23];
        if (v62)
          FileBackedBloomMap::CalcMayContainBitset(v62, v60, (unsigned __int8 *)v56, v61);
        v63 = v56;
        v64 = v180;
        v65 = v58;
        if ((int)v53 >= 1)
        {
          do
          {
            v66 = *v63++;
            *v64++ |= v66;
            --v65;
          }
          while (v65);
        }
        v57 = (_QWORD *)*v57;
      }
      while (v57);
    }
    v172 = v51;
    if (!*(_BYTE *)(v11 + 56))
      *(_BYTE *)(v11 + 56) = 1;
    v175 = v11;
    *(_QWORD *)(v11 + 48) = 0;
    v67 = v181[3] - v181[2];
    v68 = 0;
    if (v67 >= 32 && *((_QWORD *)&v191 + 1) != 0)
    {
      v79 = (unint64_t)v67 >> 5;
      v166 = v210;
      v167 = xmmword_1B8631BD0;
      do
      {
        v80 = v181[2] + 32 * (v79 - 1);
        if (!*(_BYTE *)(v80 + 25)
          && (!*(_BYTE *)(v80 + 24) || ((v180[((int)v79 - 1) / 8] >> ((v79 - 1) & 7)) & 1) != 0))
        {
          if (*(char *)(v80 + 23) < 0)
            v80 = *(_QWORD *)v80;
          v81 = openat(*(_DWORD *)v181, (const char *)v80, 0, v161);
          if ((v81 & 0x80000000) == 0)
          {
            v82 = v81;
            v189 = 0;
            v84.n128_f64[0] = cold_shard_create_search_context_for_fd(v81, (uint64_t *)&v189);
            v85 = v189;
            if (v83)
            {
              document_index = v83;
              if (!v189)
                goto LABEL_141;
              goto LABEL_140;
            }
            memset(&v188, 0, sizeof(v188));
            std::string::resize(&v188, *v189, 0);
            size = HIBYTE(v188.__r_.__value_.__r.__words[2]);
            if ((v188.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
              v88 = &v188;
            else
              v88 = (std::string *)v188.__r_.__value_.__r.__words[0];
            if ((v188.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
              size = v188.__r_.__value_.__l.__size_;
            v204 = (uint64_t)v88;
            v205 = size;
            document_index = preadvall(*((unsigned int *)v85 + 22), (uint64_t)&v204, v85[1]);
            if (document_index)
              goto LABEL_319;
            v168 = v82;
            v169 = v68;
            v89 = (_QWORD *)v191;
            if (!(_QWORD)v191)
            {
              v90 = 0;
              goto LABEL_315;
            }
            v90 = 0;
            v91 = 0;
            v92 = 0;
            while (1)
            {
              v93 = HIBYTE(v188.__r_.__value_.__r.__words[2]);
              if ((v188.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                v94 = &v188;
              else
                v94 = (std::string *)v188.__r_.__value_.__r.__words[0];
              if ((v188.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
                v93 = v188.__r_.__value_.__l.__size_;
              v95 = v89[2];
              if (!v93)
                goto LABEL_166;
              v96 = 8 * v93;
              v97 = ((v95 * (unsigned __int128)0xA90FCCCF9BBD10F3) >> 64) % (unint64_t)v96;
              if (((v94->__r_.__value_.__s.__data_[v97 >> 3] >> (v97 & 7)) & 1) != 0)
              {
                v98 = 1;
                do
                {
                  if (v98 == 16)
                    goto LABEL_166;
                  v99 = v98;
                  v100 = (((unint64_t)bloom_filter_hash_moduli[v98] * (unsigned __int128)v95) >> 64)
                       % (unint64_t)v96;
                  v101 = v94->__r_.__value_.__s.__data_[v100 >> 3];
                  v102 = v100 & 7;
                  v98 = v99 + 1;
                }
                while (((v101 >> v102) & 1) != 0);
                if ((unint64_t)(v99 - 1) >= 0xF)
                {
LABEL_166:
                  if ((unint64_t)v91 >= v92)
                  {
                    v103 = (v91 - v90) >> 3;
                    v104 = v103 + 1;
                    if ((unint64_t)(v103 + 1) >> 61)
LABEL_335:
                      abort();
                    if ((uint64_t)(v92 - (_QWORD)v90) >> 2 > v104)
                      v104 = (uint64_t)(v92 - (_QWORD)v90) >> 2;
                    if (v92 - (unint64_t)v90 >= 0x7FFFFFFFFFFFFFF8)
                      v105 = 0x1FFFFFFFFFFFFFFFLL;
                    else
                      v105 = v104;
                    if (v105)
                      v105 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v105);
                    else
                      v106 = 0;
                    v107 = (char *)(v105 + 8 * v103);
                    *(_QWORD *)v107 = v95;
                    v108 = v107 + 8;
                    while (v91 != v90)
                    {
                      v109 = *((_QWORD *)v91 - 1);
                      v91 -= 8;
                      *((_QWORD *)v107 - 1) = v109;
                      v107 -= 8;
                    }
                    v92 = v105 + 8 * v106;
                    if (v90)
                      operator delete(v90);
                    v90 = v107;
                    v91 = v108;
                  }
                  else
                  {
                    *(_QWORD *)v91 = v95;
                    v91 += 8;
                  }
                }
              }
              v89 = (_QWORD *)*v89;
              if (!v89)
              {
                v110 = v91 - v90;
                if (!v110)
                  goto LABEL_315;
                v111 = v189;
                v182[0] = MEMORY[0x1E0C809B0];
                v182[1] = 0x40000000;
                v183 = ___ZN8DocStore16GetDocumentsBulkEiPKxU13block_pointerFixPKcmE_block_invoke;
                v184 = &unk_1E6E2E530;
                v186 = &v190;
                v185 = v170;
                v187 = v175;
                memset(v197, 0, sizeof(v197));
                memset(v196, 0, sizeof(v196));
                std::vector<unsigned long long>::resize(v197, v110 >> 3);
                v178 = v110 >> 3;
                std::vector<unsigned long long>::resize(v196, v110 >> 3);
                v176 = v196[0];
                v177 = v197[0];
                file_size = get_file_size(*((_DWORD *)v111 + 22));
                if (file_size < 0)
                {
                  document_index = file_size;
                }
                else
                {
                  v164 = (const void *)v110;
                  v165 = v111;
                  v198 = 0;
                  v199 = &v198;
                  v200 = 0x2000000000;
                  v201 = 0;
                  v163 = file_size;
                  if (v110 < 1)
                  {
                    v118 = 0;
                    v115 = 0;
                  }
                  else
                  {
                    v113 = 0;
                    v114 = 0;
                    v115 = 0;
                    v116 = 0;
                    do
                    {
                      v117 = *(_QWORD *)&v90[8 * v116];
                      if ((unint64_t)v114 >= v113)
                      {
                        v119 = v114 - v115;
                        v120 = v119 + 1;
                        if ((unint64_t)(v119 + 1) >> 60)
                          goto LABEL_335;
                        if ((uint64_t)(v113 - (_QWORD)v115) >> 3 > v120)
                          v120 = (uint64_t)(v113 - (_QWORD)v115) >> 3;
                        if (v113 - (unint64_t)v115 >= 0x7FFFFFFFFFFFFFF0)
                          v121 = 0xFFFFFFFFFFFFFFFLL;
                        else
                          v121 = v120;
                        if (v121)
                          v121 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<CFRange>>(v121);
                        else
                          v122 = 0;
                        v123 = v121 + 16 * v119;
                        *(_QWORD *)v123 = v117;
                        *(_DWORD *)(v123 + 8) = v116;
                        if (v114 == v115)
                        {
                          v115 = (__int128 *)(v121 + 16 * v119);
                        }
                        else
                        {
                          v124 = (__int128 *)(v121 + 16 * v119);
                          do
                            *--v124 = *--v114;
                          while (v114 != v115);
                          v114 = v115;
                          v115 = v124;
                        }
                        v113 = v121 + 16 * v122;
                        v118 = (__int128 *)(v123 + 16);
                        if (v114)
                          operator delete(v114);
                      }
                      else
                      {
                        *(_QWORD *)v114 = v117;
                        *((_DWORD *)v114 + 2) = v116;
                        v118 = v114 + 1;
                      }
                      *(_QWORD *)&v176[8 * v116] = -1;
                      *(_QWORD *)&v177[8 * v116++] = -1;
                      v114 = v118;
                    }
                    while (v116 != v178);
                  }
                  v162 = v118 - v115;
                  v125 = 126 - 2 * __clz(v162);
                  if (v118 == v115)
                    v126 = 0;
                  else
                    v126 = v125;
                  std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<long long,int> *,false>((uint64_t)v115, (unint64_t)v118, v126, 1);
                  memset(&v203, 0, sizeof(v203));
                  v111 = v165;
                  document_index = cold_shard_get_document_index((uint64_t)v165, &v203);
                  if (!document_index)
                  {
                    v127 = &v203;
                    if ((v203.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
                      v127 = (std::string *)v203.__r_.__value_.__r.__words[0];
                    v161 = v127;
                    if ((v203.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      v128 = HIBYTE(v203.__r_.__value_.__r.__words[2]);
                    else
                      v128 = v203.__r_.__value_.__l.__size_;
                    v204 = MEMORY[0x1E0C809B0];
                    v205 = 1174405120;
                    v206 = __cold_shard_do_document_index_lookups_block_invoke;
                    v207 = &unk_1E6E30838;
                    v129 = v162;
                    v209 = v163;
                    v130 = v166;
                    v166[1] = 0;
                    v130[2] = 0;
                    *v130 = 0;
                    std::vector<std::pair<long long,int>>::__init_with_size[abi:nn180100]<std::pair<long long,int>*,std::pair<long long,int>*>(v130, v115, v118, v129);
                    v208 = &v198;
                    v210[3] = v177;
                    v210[4] = v176;
                    v131 = cold_shard_document_index_iterate((unsigned __int8 *)v161, v128, (uint64_t)&v204);
                    if (v131 == 1)
                      document_index = 0;
                    else
                      document_index = v131;
                    if (v210[0])
                    {
                      v210[1] = v210[0];
                      operator delete(v210[0]);
                    }
                  }
                  if (SHIBYTE(v203.__r_.__value_.__r.__words[2]) < 0)
                    operator delete(v203.__r_.__value_.__l.__data_);
                  _Block_object_dispose(&v198, 8);
                  v110 = (uint64_t)v164;
                  if (v115)
                    operator delete(v115);
                }
                if (document_index)
                  goto LABEL_310;
                memset(&v195, 0, sizeof(v195));
                memset(&v194, 0, sizeof(v194));
                if (v110 < 1)
                {
LABEL_304:
                  document_index = 0;
                  goto LABEL_306;
                }
                v132 = 0;
                v177 = v197[0];
                v165 = v111;
                while (1)
                {
                  if (*(_QWORD *)&v177[8 * (_QWORD)v132] != -1)
                  {
                    v133 = v196[0];
                    std::string::resize(&v195, *(_QWORD *)&v196[0][8 * (_QWORD)v132], 0);
                    if ((v195.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      v134 = &v195;
                    else
                      v134 = (std::string *)v195.__r_.__value_.__r.__words[0];
                    v135 = *(_QWORD *)&v133[8 * (_QWORD)v132];
                    v193[0] = v134;
                    v193[1] = v135;
                    v136 = *(_QWORD *)&v177[8 * (_QWORD)v132] + v111[8];
                    v176 = v132;
                    *(_QWORD *)&v177[8 * (_QWORD)v132] = v136;
                    v137 = preadvall(*((unsigned int *)v111 + 22), (uint64_t)v193, v136);
                    if (v137)
                      goto LABEL_305;
                    if ((v195.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      v138 = &v195;
                    else
                      v138 = (std::string *)v195.__r_.__value_.__r.__words[0];
                    if ((v195.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                      v139 = HIBYTE(v195.__r_.__value_.__r.__words[2]);
                    else
                      v139 = v195.__r_.__value_.__l.__size_;
                    document_index = -102;
                    switch(v111[9])
                    {
                      case 0uLL:
                        MEMORY[0x1BCCB03BC](&v194, v138, v139);
                        goto LABEL_283;
                      case 1uLL:
                        if (SHIBYTE(v194.__r_.__value_.__r.__words[2]) < 0)
                        {
                          *v194.__r_.__value_.__l.__data_ = 0;
                          v194.__r_.__value_.__l.__size_ = 0;
                        }
                        else
                        {
                          v194.__r_.__value_.__s.__data_[0] = 0;
                          *((_BYTE *)&v194.__r_.__value_.__s + 23) = 0;
                        }
                        v148 = dctx;
                        if (!dctx)
                        {
                          zstd_compress_init();
                          v148 = dctx;
                        }
                        bzero(&v204, 0x10000uLL);
                        v198 = (std::string::__raw *)v138;
                        v199 = (std::string::__raw **)v139;
                        v200 = 0;
                        v203.__r_.__value_.__r.__words[0] = (std::string::size_type)&v204;
                        *(_OWORD *)&v203.__r_.__value_.__r.__words[1] = v167;
                        inited = ZSTD_initDStream(v148);
                        if (ZDICT_isError(inited))
                        {
                          document_index = -12;
                          v150 = "ZSTD_initDStream: %s\n";
                          goto LABEL_264;
                        }
                        while (1)
                        {
                          inited = ZSTD_decompressStream(dctx, (uint64_t *)&v203, (uint64_t *)&v198);
                          if (ZDICT_isError(inited))
                            break;
                          std::string::append(&v194, (const std::string::value_type *)&v204, v203.__r_.__value_.__r.__words[2]);
                          v203.__r_.__value_.__r.__words[2] = 0;
                          if (!inited && (std::string::__raw **)v200 == v199)
                          {
                            document_index = 0;
                            goto LABEL_273;
                          }
                        }
                        if (v139)
                        {
                          while (1)
                          {
                            v153 = v138->__r_.__value_.__s.__data_[0];
                            v138 = (std::string *)((char *)v138 + 1);
                            if (v153)
                              break;
                            if (!--v139)
                              goto LABEL_272;
                          }
                          document_index = -22;
                          v150 = "ZSTD_decompressStream: %s\n";
LABEL_264:
                          v151 = (FILE *)*MEMORY[0x1E0C80C10];
                          ErrorName = ZDICT_getErrorName(inited);
                          fprintf(v151, v150, ErrorName);
                          goto LABEL_273;
                        }
LABEL_272:
                        document_index = -2;
LABEL_273:
                        v111 = v165;
                        goto LABEL_280;
                      case 2uLL:
                        memset(&v202, 0, sizeof(v202));
                        std::string::resize(&v202, v111[2], 0);
                        v140 = HIBYTE(v202.__r_.__value_.__r.__words[2]);
                        v141 = &v202;
                        if ((v202.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
                        {
                          v140 = v202.__r_.__value_.__l.__size_;
                          v141 = (std::string *)v202.__r_.__value_.__r.__words[0];
                        }
                        v204 = (uint64_t)v141;
                        v205 = v140;
                        document_index = preadvall(*((unsigned int *)v111 + 22), (uint64_t)&v204, v111[3]);
                        if (document_index)
                          goto LABEL_278;
                        v142 = &v202;
                        if ((v202.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
                          v142 = (std::string *)v202.__r_.__value_.__r.__words[0];
                        v164 = v142;
                        if ((v202.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
                          v143 = HIBYTE(v202.__r_.__value_.__r.__words[2]);
                        else
                          v143 = v202.__r_.__value_.__l.__size_;
                        v144 = dctx;
                        if (!dctx)
                        {
                          zstd_compress_init();
                          v144 = dctx;
                        }
                        bzero(&v204, 0x10000uLL);
                        v198 = (std::string::__raw *)v138;
                        v199 = (std::string::__raw **)v139;
                        v200 = 0;
                        v203.__r_.__value_.__r.__words[0] = (std::string::size_type)&v204;
                        *(_OWORD *)&v203.__r_.__value_.__r.__words[1] = v167;
                        v145 = ZSTD_initDStream(v144);
                        if (ZDICT_isError(v145))
                        {
                          v146 = v145;
                          document_index = -12;
                          v147 = "ZSTD_initDStream: %s\n";
LABEL_276:
                          v111 = v165;
                          goto LABEL_277;
                        }
                        Dictionary = ZSTD_DCtx_loadDictionary(dctx, v164, v143);
                        if (ZDICT_isError(Dictionary))
                        {
                          v146 = Dictionary;
                          document_index = -22;
                          v147 = "ZSTD_DCtx_loadDictionary: %s\n";
                          goto LABEL_276;
                        }
                        v111 = v165;
                        while (1)
                        {
                          v159 = ZSTD_decompressStream(dctx, (uint64_t *)&v203, (uint64_t *)&v198);
                          if (ZDICT_isError(v159))
                            break;
                          std::string::append(&v194, (const std::string::value_type *)&v204, v203.__r_.__value_.__r.__words[2]);
                          v203.__r_.__value_.__r.__words[2] = 0;
                          if (!v159 && (std::string::__raw **)v200 == v199)
                            goto LABEL_302;
                        }
                        if (v139)
                        {
                          while (1)
                          {
                            v160 = v138->__r_.__value_.__s.__data_[0];
                            v138 = (std::string *)((char *)v138 + 1);
                            if (v160)
                              break;
                            if (!--v139)
                              goto LABEL_302;
                          }
                          v146 = v159;
                          document_index = -22;
                          v147 = "ZSTD_decompressStream: %s\n";
LABEL_277:
                          v155 = (FILE *)*MEMORY[0x1E0C80C10];
                          v156 = ZDICT_getErrorName(v146);
                          fprintf(v155, v147, v156);
                          goto LABEL_278;
                        }
LABEL_302:
                        document_index = 0;
LABEL_278:
                        if (SHIBYTE(v202.__r_.__value_.__r.__words[2]) < 0)
                          operator delete(v202.__r_.__value_.__l.__data_);
LABEL_280:
                        if (document_index != -22 && document_index != -2)
                        {
                          if (document_index)
                            goto LABEL_306;
LABEL_283:
                          v157 = (v194.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
                               ? &v194
                               : (std::string *)v194.__r_.__value_.__r.__words[0];
                          v158 = (v194.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
                               ? HIBYTE(v194.__r_.__value_.__r.__words[2])
                               : v194.__r_.__value_.__l.__size_;
                          v137 = ((uint64_t (*)(_QWORD *, _QWORD, std::string *, std::string::size_type))v183)(v182, *(_QWORD *)&v90[8 * (_QWORD)v176], v157, v158);
                          if (v137)
                          {
LABEL_305:
                            document_index = v137;
LABEL_306:
                            if (SHIBYTE(v194.__r_.__value_.__r.__words[2]) < 0)
                              operator delete(v194.__r_.__value_.__l.__data_);
                            if (SHIBYTE(v195.__r_.__value_.__r.__words[2]) < 0)
                              operator delete(v195.__r_.__value_.__l.__data_);
LABEL_310:
                            if (v196[0])
                              operator delete(v196[0]);
                            if (v197[0])
                              operator delete(v197[0]);
                            if (!document_index)
LABEL_315:
                              document_index = 0;
                            if (v90)
                              operator delete(v90);
                            v82 = v168;
                            LODWORD(v68) = v169;
LABEL_319:
                            if (SHIBYTE(v188.__r_.__value_.__r.__words[2]) < 0)
                              operator delete(v188.__r_.__value_.__l.__data_);
                            v85 = v189;
                            if (!v189)
                            {
LABEL_141:
                              close(v82);
                              if (document_index)
                                v68 = document_index;
                              else
                                v68 = v68;
                              goto LABEL_144;
                            }
LABEL_140:
                            MEMORY[0x1BCCB06A4](v85, 0x1000C4034A301B9, v84);
                            goto LABEL_141;
                          }
                        }
                        v132 = v176;
                        break;
                      case 3uLL:
                        if (SHIBYTE(v194.__r_.__value_.__r.__words[2]) < 0)
                        {
                          *v194.__r_.__value_.__l.__data_ = 0;
                          v194.__r_.__value_.__l.__size_ = 0;
                        }
                        else
                        {
                          v194.__r_.__value_.__s.__data_[0] = 0;
                          *((_BYTE *)&v194.__r_.__value_.__s + 23) = 0;
                        }
                        goto LABEL_306;
                      case 4uLL:
                        goto LABEL_306;
                      default:
                        fprintf((FILE *)*MEMORY[0x1E0C80C10], "logic error:  unknown compression type %llx\n", v111[9]);
                        abort();
                    }
                  }
                  if (++v132 == (char *)v178)
                    goto LABEL_304;
                }
              }
            }
          }
        }
LABEL_144:
        if (v79 < 2)
          break;
        --v79;
      }
      while (*((_QWORD *)&v191 + 1));
    }
    v8 = v172;
    v7 = v173;
    v6 = v174;
    v11 = v175;
  }
  else
  {
    v68 = 0;
  }
  *(_DWORD *)(v11 + 4) = v68;
  *(_BYTE *)(v11 + 8) = 1;
  *(_WORD *)v11 = ((_DWORD)v68 == 0) | 0x100;
  v70 = (_QWORD *)v191;
  if ((_QWORD)v191)
  {
    do
    {
      v71 = (_QWORD *)*v70;
      operator delete(v70);
      v70 = v71;
    }
    while (v71);
  }
  v72 = (void *)v190;
  *(_QWORD *)&v190 = 0;
  if (v72)
    operator delete(v72);
  v73 = (double)(std::chrono::steady_clock::now().__d_.__rep_ - rep) * 0.00001;
  if (!*(_BYTE *)(v11 + 68))
    *(_BYTE *)(v11 + 68) = 1;
  v74 = v73;
  *(float *)(v11 + 64) = v74;
  v204 = v11;
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v8 + 16))(v8, &v204);
  v75 = v204;
  v204 = 0;
  if (v75)
    MEMORY[0x1BCCB06A4](v75, 0x1000C4073594BB7);
  if (v7)
  {
    v76 = (unint64_t *)&v7->__shared_owners_;
    do
      v77 = __ldaxr(v76);
    while (__stlxr(v77 - 1, v76));
    if (!v77)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  std::mutex::unlock(v6);
  return v68;
}

uint64_t ___ZN8DocStore16GetDocumentsBulkEiPKxU13block_pointerFixPKcmE_block_invoke(_QWORD *a1, unint64_t a2)
{
  uint64_t *v3;
  int8x8_t v4;
  uint8x8_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t **v8;
  uint64_t *v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t *v13;
  uint64_t *v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;

  v3 = (uint64_t *)a1[5];
  v4 = (int8x8_t)v3[1];
  if (v4)
  {
    v5 = (uint8x8_t)vcnt_s8(v4);
    v5.i16[0] = vaddlv_u8(v5);
    if (v5.u32[0] > 1uLL)
    {
      v6 = a2;
      if (*(_QWORD *)&v4 <= a2)
        v6 = a2 % *(_QWORD *)&v4;
    }
    else
    {
      v6 = (*(_QWORD *)&v4 - 1) & a2;
    }
    v7 = *v3;
    v8 = *(uint64_t ***)(*v3 + 8 * v6);
    if (v8)
    {
      v9 = *v8;
      if (*v8)
      {
        v10 = *(_QWORD *)&v4 - 1;
        do
        {
          v11 = v9[1];
          if (v11 == a2)
          {
            if (v9[2] == a2)
            {
              if (v5.u32[0] > 1uLL)
              {
                v12 = a2;
                if (*(_QWORD *)&v4 <= a2)
                  v12 = a2 % *(_QWORD *)&v4;
              }
              else
              {
                v12 = v10 & a2;
              }
              v13 = *(uint64_t **)(v7 + 8 * v12);
              do
              {
                v14 = v13;
                v13 = (uint64_t *)*v13;
              }
              while (v13 != v9);
              if (v14 == v3 + 2)
                goto LABEL_36;
              v15 = v14[1];
              if (v5.u32[0] > 1uLL)
              {
                if (v15 >= *(_QWORD *)&v4)
                  v15 %= *(_QWORD *)&v4;
              }
              else
              {
                v15 &= v10;
              }
              if (v15 != v12)
              {
LABEL_36:
                if (!*v9)
                  goto LABEL_37;
                v16 = *(_QWORD *)(*v9 + 8);
                if (v5.u32[0] > 1uLL)
                {
                  if (v16 >= *(_QWORD *)&v4)
                    v16 %= *(_QWORD *)&v4;
                }
                else
                {
                  v16 &= v10;
                }
                if (v16 != v12)
LABEL_37:
                  *(_QWORD *)(v7 + 8 * v12) = 0;
              }
              v17 = *v9;
              if (*v9)
              {
                v18 = *(_QWORD *)(v17 + 8);
                if (v5.u32[0] > 1uLL)
                {
                  if (v18 >= *(_QWORD *)&v4)
                    v18 %= *(_QWORD *)&v4;
                }
                else
                {
                  v18 &= v10;
                }
                if (v18 != v12)
                {
                  *(_QWORD *)(*v3 + 8 * v18) = v14;
                  v17 = *v9;
                }
              }
              *v14 = v17;
              *v9 = 0;
              --v3[3];
              operator delete(v9);
              break;
            }
          }
          else
          {
            if (v5.u32[0] > 1uLL)
            {
              if (v11 >= *(_QWORD *)&v4)
                v11 %= *(_QWORD *)&v4;
            }
            else
            {
              v11 &= v10;
            }
            if (v11 != v6)
              break;
          }
          v9 = (uint64_t *)*v9;
        }
        while (v9);
      }
    }
  }
  (*(void (**)(void))(a1[4] + 16))();
  v19 = a1[6];
  if (*(_BYTE *)(v19 + 56))
  {
    ++*(_QWORD *)(v19 + 48);
    return 0;
  }
  else
  {
    v21 = std::__throw_bad_optional_access[abi:nn180100]();
    return DocStore::PutDocument(v21, v22, v23, v24);
  }
}

uint64_t DocStore::PutDocument(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;
  uint64_t v9;
  std::chrono::steady_clock::time_point v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  char *v15;
  size_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  const unint64_t *v22;
  __int128 v23;
  FileBackedBloomMap *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t *v27;
  uint64_t v28;
  int v29;
  int v30;
  int v31;
  uint64_t *v32;
  int v33;
  int v34;
  int v35;
  NSObject *v36;
  BOOL v37;
  char *v38;
  NSObject *v39;
  os_log_type_t v40;
  const char *v41;
  NSObject *v42;
  BOOL v43;
  uint64_t **v44;
  int *v45;
  char *v46;
  uint32_t v47;
  NSObject *v48;
  BOOL v49;
  char *v50;
  char *v51;
  CachingHotShard *v52;
  uint64_t v53;
  uint64_t v54;
  __int16 v55;
  unint64_t v56;
  unint64_t v57;
  double v58;
  float v59;
  uint64_t v60;
  std::__shared_weak_count *v61;
  unint64_t *v62;
  unint64_t v63;
  uint64_t v65;
  int v66;
  NSObject *v67;
  os_log_type_t v68;
  char *v69;
  uint64_t v70;
  __int128 v71;
  __int128 v72;
  __int128 *v73;
  uint64_t v74;
  char *v75;
  std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep rep;
  uint64_t v77;
  std::__shared_weak_count *v78;
  std::mutex *v79;
  char *v80;
  int64x2_t v81[2];
  char v82[8];
  _BYTE v83[9];
  _BYTE buf[12];
  __int16 v85;
  char *v86;
  uint64_t v87;

  v74 = a3;
  v87 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v83[1] = a2;
  v83[0] = 0;
  v79 = (std::mutex *)(a1 + 40);
  std::mutex::lock((std::mutex *)(a1 + 40));
  v6 = *(std::__shared_weak_count **)(a1 + 152);
  v77 = *(_QWORD *)(a1 + 144);
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v8 = __ldxr(p_shared_owners);
    while (__stxr(v8 + 1, p_shared_owners));
  }
  v9 = operator new();
  *(_OWORD *)v9 = 0u;
  *(_OWORD *)(v9 + 16) = 0u;
  *(_QWORD *)(v9 + 32) = 0;
  v10.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  rep = v10.__d_.__rep_;
  if (v6)
  {
    v11 = (unint64_t *)&v6->__shared_owners_;
    do
      v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
    do
      v13 = __ldaxr(v11);
    while (__stlxr(v13 - 1, v11));
    if (!v13)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  v78 = v6;
  if (!*(_BYTE *)(v9 + 24))
    *(_BYTE *)(v9 + 24) = 1;
  v73 = &v71;
  v75 = a4;
  *(_QWORD *)(v9 + 16) = a4;
  MEMORY[0x1E0C80A78](v10.__d_.__rep_);
  v15 = (char *)&v71 - v14;
  bzero((char *)&v71 - v14, v16);
  v17 = *(_QWORD *)&v83[1];
  v19 = *(_QWORD *)(a1 + 16);
  v18 = *(_QWORD *)(a1 + 24);
  v20 = v18 - v19;
  v21 = (unint64_t)(((v18 - v19) >> 5) + 7) >> 3;
  memset(v15, 255, v21);
  v24 = *(FileBackedBloomMap **)(a1 + 184);
  if (v24)
  {
    FileBackedBloomMap::CalcMayContainBitset(v24, v17, (unsigned __int8 *)v15, v21);
    v19 = *(_QWORD *)(a1 + 16);
    v18 = *(_QWORD *)(a1 + 24);
    v20 = v18 - v19;
  }
  if ((int)(v20 >> 5) >= 1)
  {
    v25 = 0;
    v26 = 0;
    *(_QWORD *)&v23 = 136315394;
    v72 = v23;
    *(_QWORD *)&v23 = 136315138;
    v71 = v23;
    while (1)
    {
      v27 = (uint64_t *)(v19 + v25);
      if (!*(_BYTE *)(v19 + v25 + 25)
        && (!*((_BYTE *)v27 + 24) || ((v15[v26 >> 3] >> (v26 & 7)) & 1) != 0))
      {
        break;
      }
LABEL_42:
      ++v26;
      v25 += 32;
      if (v26 >= (int)((unint64_t)(v18 - v19) >> 5))
        goto LABEL_43;
    }
    *(_QWORD *)v82 = 0;
    if (*(char *)(v19 + v25 + 23) < 0)
      v27 = (uint64_t *)*v27;
    v28 = openat(*(_DWORD *)a1, (const char *)v27, 536870914, (_QWORD)v71, *((_QWORD *)&v71 + 1));
    v29 = v28;
    if ((v28 & 0x80000000) != 0)
    {
      v35 = *__error();
      v42 = _SILogForLogForCategory(8);
      v43 = dword_1EF19FCAC < 3;
      if (os_log_type_enabled(v42, (os_log_type_t)(dword_1EF19FCAC < 3)))
      {
        v44 = (uint64_t **)(*(_QWORD *)(a1 + 16) + v25);
        if (*((char *)v44 + 23) < 0)
          v44 = (uint64_t **)*v44;
        v45 = __error();
        v46 = strerror(*v45);
        *(_DWORD *)buf = v72;
        *(_QWORD *)&buf[4] = v44;
        v85 = 2080;
        v86 = v46;
        v39 = v42;
        v40 = v43;
        v41 = "*warn* PutDocument: failed to open cold shard %s: %s";
        v47 = 22;
        goto LABEL_34;
      }
    }
    else
    {
      cold_shard_create_search_context_for_fd(v28, (uint64_t *)v82);
      if (v30 == -2)
      {
LABEL_36:
        v32 = *(uint64_t **)v82;
        goto LABEL_37;
      }
      v31 = v30;
      if (!v30)
      {
        memset(v81, 0, sizeof(v81));
        v32 = *(uint64_t **)v82;
        v33 = cold_shard_delete_docs(*(uint64_t **)v82, 1uLL, &v83[1], v81);
        if (!v33)
        {
LABEL_37:
          if (v32)
            MEMORY[0x1BCCB06A4](v32, 0x1000C4034A301B9);
          if ((v29 & 0x80000000) == 0)
            close(v29);
          v19 = *(_QWORD *)(a1 + 16);
          v18 = *(_QWORD *)(a1 + 24);
          goto LABEL_42;
        }
        v34 = v33;
        v35 = *__error();
        v36 = _SILogForLogForCategory(8);
        v37 = dword_1EF19FCAC < 3;
        if (!os_log_type_enabled(v36, (os_log_type_t)(dword_1EF19FCAC < 3)))
          goto LABEL_35;
        v38 = strerror(-v34);
        *(_DWORD *)buf = v71;
        *(_QWORD *)&buf[4] = v38;
        v39 = v36;
        v40 = v37;
        v41 = "*warn* PutDocument: cold_shard_delete_docs failed deleting old version: %s\n";
        goto LABEL_33;
      }
      v35 = *__error();
      v48 = _SILogForLogForCategory(8);
      v49 = dword_1EF19FCAC < 3;
      if (os_log_type_enabled(v48, (os_log_type_t)(dword_1EF19FCAC < 3)))
      {
        v50 = strerror(-v31);
        *(_DWORD *)buf = v71;
        *(_QWORD *)&buf[4] = v50;
        v39 = v48;
        v40 = v49;
        v41 = "*warn* PutDocument: cold_shard_create_search_context_for_fd: %s\n";
LABEL_33:
        v47 = 12;
LABEL_34:
        _os_log_impl(&dword_1B8270000, v39, v40, v41, buf, v47);
      }
    }
LABEL_35:
    *__error() = v35;
    goto LABEL_36;
  }
LABEL_43:
  v51 = v75;
  *(_QWORD *)v82 = v74;
  v80 = v75;
  v52 = *(CachingHotShard **)(a1 + 8);
  if (v52)
  {
    v53 = CachingHotShard::WriteDocs(v52, (int)&v83[1], (const uint64_t *)v83, v82, (const char **)&v80, v22);
    if ((_DWORD)v53)
    {
      v54 = v53;
LABEL_46:
      v55 = 256;
      goto LABEL_52;
    }
    v56 = (unint64_t)&v51[*(_QWORD *)(a1 + 112)];
    v57 = *(_QWORD *)(a1 + 104) + 1;
    *(_QWORD *)(a1 + 104) = v57;
    *(_QWORD *)(a1 + 112) = v56;
    if (v57 <= 0x1000 && v56 < 0xBC614F)
      goto LABEL_50;
    v65 = DocStore::do_cool_hot_shard((DocStore *)a1);
    if ((_DWORD)v65)
    {
      v54 = v65;
      v66 = *__error();
      v67 = _SILogForLogForCategory(8);
      v68 = dword_1EF19FCAC < 3;
      if (os_log_type_enabled(v67, (os_log_type_t)(dword_1EF19FCAC < 3)))
      {
        v69 = strerror(-(int)v54);
        *(_DWORD *)buf = 136315138;
        *(_QWORD *)&buf[4] = v69;
        _os_log_impl(&dword_1B8270000, v67, v68, "*warn* do_cool_hot_shard: %s\n", buf, 0xCu);
      }
      *__error() = v66;
      goto LABEL_46;
    }
    v70 = *(_QWORD *)(a1 + 24);
    if (*(_BYTE *)(v70 - 8)
      || DocStore::add_cold_shard_to_bloom_filter((DocStore *)a1, ((unint64_t)(v70 - *(_QWORD *)(a1 + 16)) >> 5) - 1))
    {
LABEL_50:
      v54 = 0;
    }
    else
    {
      v54 = 0;
      *(_BYTE *)(*(_QWORD *)(a1 + 24) - 8) = 1;
    }
    v55 = 257;
  }
  else
  {
    v55 = 256;
    v54 = 4294967282;
  }
LABEL_52:
  *(_DWORD *)(v9 + 4) = v54;
  *(_BYTE *)(v9 + 8) = 1;
  *(_WORD *)v9 = v55;
  v58 = (double)(std::chrono::steady_clock::now().__d_.__rep_ - rep) * 0.00001;
  if (!*(_BYTE *)(v9 + 36))
    *(_BYTE *)(v9 + 36) = 1;
  v59 = v58;
  *(float *)(v9 + 32) = v59;
  *(_QWORD *)buf = v9;
  (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)v77 + 16))(v77, buf);
  v60 = *(_QWORD *)buf;
  *(_QWORD *)buf = 0;
  if (v60)
    MEMORY[0x1BCCB06A4](v60, 0x1000C4022EED179);
  v61 = v78;
  if (v78)
  {
    v62 = (unint64_t *)&v78->__shared_owners_;
    do
      v63 = __ldaxr(v62);
    while (__stlxr(v63 - 1, v62));
    if (!v63)
    {
      ((void (*)(std::__shared_weak_count *))v61->__on_zero_shared)(v61);
      std::__shared_weak_count::__release_weak(v61);
    }
  }
  std::mutex::unlock(v79);
  return v54;
}

uint64_t DocStore::DeleteDocumentsBulk(DocStore *this, uint64_t a2, unint64_t *a3)
{
  std::mutex *v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  NSObject *v14;
  os_log_type_t v15;
  char *v16;
  uint64_t v17;
  _OWORD v19[2];
  uint8_t buf[8];
  _QWORD v21[3];

  v21[2] = *MEMORY[0x1E0C80C00];
  v6 = (std::mutex *)((char *)this + 40);
  std::mutex::lock((std::mutex *)((char *)this + 40));
  memset(v19, 0, sizeof(v19));
  v7 = (std::__shared_weak_count *)*((_QWORD *)this + 21);
  *(_QWORD *)buf = *((_QWORD *)this + 20);
  v21[0] = v7;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldxr(p_shared_owners);
    while (__stxr(v9 + 1, p_shared_owners));
    analytics::ScopedLogger<analytics::DeleteEvent>::ScopedLogger((std::chrono::steady_clock::time_point *)v19, (std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep *)buf);
    do
      v10 = __ldaxr(p_shared_owners);
    while (__stlxr(v10 - 1, p_shared_owners));
    if (!v10)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  else
  {
    analytics::ScopedLogger<analytics::DeleteEvent>::ScopedLogger((std::chrono::steady_clock::time_point *)v19, (std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep *)buf);
  }
  v11 = *(_QWORD *)&v19[0];
  if (!*(_BYTE *)(*(_QWORD *)&v19[0] + 24))
    *(_BYTE *)(*(_QWORD *)&v19[0] + 24) = 1;
  *(_QWORD *)(v11 + 16) = (int)a2;
  if (!*(_BYTE *)(v11 + 40))
    *(_BYTE *)(v11 + 40) = 1;
  *(_QWORD *)(v11 + 32) = 0;
  if (!*(_BYTE *)(v11 + 56))
    *(_BYTE *)(v11 + 56) = 1;
  *(_QWORD *)(v11 + 48) = 0;
  v12 = DocStore::do_delete_bulk((uint64_t)this, a3, a2, v11);
  if ((_DWORD)v12)
  {
    v13 = *__error();
    v14 = _SILogForLogForCategory(8);
    v15 = dword_1EF19FCAC < 3;
    if (os_log_type_enabled(v14, (os_log_type_t)(dword_1EF19FCAC < 3)))
    {
      v16 = strerror(-(int)v12);
      *(_DWORD *)buf = 67109378;
      *(_DWORD *)&buf[4] = a2;
      LOWORD(v21[0]) = 2080;
      *(_QWORD *)((char *)v21 + 2) = v16;
      _os_log_impl(&dword_1B8270000, v14, v15, "*warn* DeleteDocumentsBulk(%d): %s", buf, 0x12u);
    }
    *__error() = v13;
  }
  v17 = *(_QWORD *)&v19[0];
  *(_DWORD *)(*(_QWORD *)&v19[0] + 4) = v12;
  *(_BYTE *)(v17 + 8) = 1;
  **(_WORD **)&v19[0] = ((_DWORD)v12 == 0) | 0x100;
  analytics::ScopedLogger<analytics::DeleteEvent>::~ScopedLogger(v19);
  std::mutex::unlock(v6);
  return v12;
}

uint64_t DocStore::do_delete_bulk(uint64_t a1, unint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  CachingHotShard *v8;
  int v9;
  uint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  char *v28;
  __int128 v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  FileBackedBloomMap *v35;
  char *v36;
  _BYTE *v37;
  uint64_t v38;
  char v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t v44;
  const char *v45;
  uint64_t v46;
  const char *v47;
  uint64_t v48;
  int v49;
  int v50;
  int v51;
  int v52;
  NSObject *v53;
  os_log_type_t v54;
  char *v55;
  uint64_t v56;
  int v57;
  NSObject *v58;
  os_log_type_t v59;
  char *v60;
  int v61;
  NSObject *v62;
  os_log_type_t v63;
  char *v64;
  int v65;
  uint64_t v66;
  __int128 v68;
  unint64_t v69;
  __int128 *v70;
  int v71;
  __int128 v72;
  uint64_t v73;
  unsigned int v74;
  int64x2_t v75;
  __int128 v76;
  uint64_t v77;
  _OWORD v78[2];
  uint64_t v79;
  _BYTE buf[24];
  void *v81;
  _QWORD v82[6];
  int v83;
  uint64_t v84;

  v7 = a1;
  v84 = *MEMORY[0x1E0C80C00];
  v8 = *(CachingHotShard **)(a1 + 8);
  if (v8)
  {
    v9 = *(_DWORD *)v8;
    v79 = 1065353216;
    memset(v78, 0, sizeof(v78));
    v77 = 0;
    if ((int)a3 >= 1)
    {
      v10 = a3;
      v11 = a2;
      do
      {
        v12 = *v11++;
        std::__hash_table<long long,std::hash<long long>,std::equal_to<long long>,std::allocator<long long>>::__emplace_unique_key_args<long long,long long const&>((uint64_t)v78, v12, v12);
        --v10;
      }
      while (v10);
    }
    *(_QWORD *)buf = MEMORY[0x1E0C809B0];
    *(_QWORD *)&buf[8] = 1174405120;
    *(_QWORD *)&buf[16] = __hot_shard_delete_docs_block_invoke;
    v81 = &__block_descriptor_tmp_3_6983;
    std::unordered_set<long long>::unordered_set((uint64_t)v82, (uint64_t)v78);
    v83 = v9;
    v82[5] = &v77;
    v13 = hot_shard_for_each_region(v9, (uint64_t)buf);
    std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::~__hash_table((uint64_t)v82);
    a1 = std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::~__hash_table((uint64_t)v78);
    if ((_DWORD)v13)
    {
      v14 = *(_DWORD *)v8;
      *((_QWORD *)v8 + 2) = *((_QWORD *)v8 + 1);
      *((_QWORD *)v8 + 5) = *((_QWORD *)v8 + 4);
      *((_QWORD *)v8 + 8) = *((_QWORD *)v8 + 7);
      *(_DWORD *)v8 = -1;
      a1 = CachingHotShard::Bind(v8, v14);
    }
    else
    {
      if ((int)a3 >= 1)
      {
        v15 = 0;
        v16 = *((_QWORD *)v8 + 1);
        v17 = *((_QWORD *)v8 + 2);
        do
        {
          if ((int)((unint64_t)(v17 - v16) >> 3) >= 1)
          {
            v18 = 0;
            while (*(_QWORD *)(v16 + 8 * v18) != a2[v15])
            {
              if (((unint64_t)(v17 - v16) >> 3) == ++v18)
                goto LABEL_16;
            }
            v19 = *(_QWORD *)(v17 - 8);
            v17 -= 8;
            *(_QWORD *)(v16 + 8 * v18) = v19;
            *((_QWORD *)v8 + 2) = v17;
            v20 = *((_QWORD *)v8 + 5);
            *(_QWORD *)(*((_QWORD *)v8 + 4) + 8 * v18) = *(_QWORD *)(v20 - 8);
            *((_QWORD *)v8 + 5) = v20 - 8;
            v21 = *((_QWORD *)v8 + 8);
            *(_QWORD *)(*((_QWORD *)v8 + 7) + 8 * v18) = *(_QWORD *)(v21 - 8);
            *((_QWORD *)v8 + 8) = v21 - 8;
          }
LABEL_16:
          ++v15;
        }
        while (v15 != a3);
      }
      v13 = 0;
    }
  }
  else
  {
    v13 = 4294967282;
  }
  v22 = *(_QWORD *)(v7 + 24) - *(_QWORD *)(v7 + 16);
  if (v22)
  {
    v74 = v13;
    v73 = a4;
    v70 = &v68;
    v23 = (v22 >> 5) + 7;
    v24 = v23 >> 3;
    v25 = MEMORY[0x1E0C80A78](a1);
    v26 = (char *)&v68 - (((v23 >> 3) + 15) & 0x3FFFFFFFFFFFFFF0);
    MEMORY[0x1E0C80A78](v25);
    v28 = (char *)&v68 - v27;
    bzero((char *)&v68 - v27, v23 >> 3);
    bzero(v26, v23 >> 3);
    *(_QWORD *)&v72 = a3;
    if ((int)a3 >= 1)
    {
      v30 = 0;
      v31 = (v23 >> 3);
      v32 = v72;
      do
      {
        v33 = a2[v30];
        v34 = (unint64_t)(((uint64_t)(*(_QWORD *)(v7 + 24) - *(_QWORD *)(v7 + 16)) >> 5) + 7) >> 3;
        memset(v28, 255, v34);
        v35 = *(FileBackedBloomMap **)(v7 + 184);
        if (v35)
          FileBackedBloomMap::CalcMayContainBitset(v35, v33, (unsigned __int8 *)v28, v34);
        v36 = v28;
        v37 = v26;
        v38 = v31;
        if ((int)v24 >= 1)
        {
          do
          {
            v39 = *v36++;
            *v37++ |= v39;
            --v38;
          }
          while (v38);
        }
        ++v30;
      }
      while (v30 != v32);
    }
    v40 = *(_QWORD *)(v7 + 24) - *(_QWORD *)(v7 + 16);
    if (v40 >= 1)
    {
      v41 = (unint64_t)v40 >> 5;
      v69 = (int)v72;
      v42 = 32 * v41 - 32;
      *(_QWORD *)&v29 = 136315394;
      v68 = v29;
      *(_QWORD *)&v29 = 136315138;
      v72 = v29;
      while (1)
      {
        v43 = v41 - 1;
        v44 = *(_QWORD *)(v7 + 16);
        v45 = (const char *)(v44 + v42);
        if (!*(_BYTE *)(v44 + v42 + 25) && (!v45[24] || ((v26[v43 >> 3] >> ((v41 - 1) & 7)) & 1) != 0))
          break;
LABEL_53:
        v42 -= 32;
        v41 = v43;
        if (v43 + 1 <= 1)
          goto LABEL_58;
      }
      v46 = v44 + v42;
      v47 = (const char *)(v44 + v42);
      if (*(char *)(v44 + v42 + 23) < 0)
        v47 = *(const char **)v45;
      v48 = openat(*(_DWORD *)v7, v47, 2, (_QWORD)v68, *((_QWORD *)&v68 + 1));
      if ((v48 & 0x80000000) != 0)
      {
        v57 = *__error();
        if (v57 != 2)
        {
          v71 = *__error();
          v58 = _SILogForLogForCategory(8);
          v59 = dword_1EF19FCAC < 3;
          if (os_log_type_enabled(v58, (os_log_type_t)(dword_1EF19FCAC < 3)))
          {
            if (*(char *)(v46 + 23) < 0)
              v45 = *(const char **)v45;
            v60 = strerror(v57);
            *(_DWORD *)buf = v68;
            *(_QWORD *)&buf[4] = v45;
            *(_WORD *)&buf[12] = 2080;
            *(_QWORD *)&buf[14] = v60;
            _os_log_impl(&dword_1B8270000, v58, v59, "*warn* open(%s, RDWR): %s\n", buf, 0x16u);
          }
          *__error() = v71;
        }
        goto LABEL_53;
      }
      v49 = v48;
      *(_QWORD *)&v78[0] = 0;
      cold_shard_create_search_context_for_fd(v48, (uint64_t *)v78);
      if (v50)
      {
        v51 = v50;
        v52 = *__error();
        v53 = _SILogForLogForCategory(8);
        v54 = dword_1EF19FCAC < 3;
        if (os_log_type_enabled(v53, (os_log_type_t)(dword_1EF19FCAC < 3)))
        {
          v55 = strerror(-v51);
          *(_DWORD *)buf = v72;
          *(_QWORD *)&buf[4] = v55;
          _os_log_impl(&dword_1B8270000, v53, v54, "*warn* cold_shard_create_search_context_for_fd: %s\n", buf, 0xCu);
        }
        *__error() = v52;
        v56 = *(_QWORD *)&v78[0];
        if (!*(_QWORD *)&v78[0])
          goto LABEL_50;
      }
      else
      {
        v76 = 0u;
        v75 = 0u;
        v56 = *(_QWORD *)&v78[0];
        v61 = cold_shard_delete_docs(*(uint64_t **)&v78[0], v69, a2, &v75);
        if (v61)
        {
          v51 = v61;
          v71 = *__error();
          v62 = _SILogForLogForCategory(8);
          v63 = dword_1EF19FCAC < 3;
          if (os_log_type_enabled(v62, (os_log_type_t)(dword_1EF19FCAC < 3)))
          {
            v64 = strerror(-v51);
            *(_DWORD *)buf = v72;
            *(_QWORD *)&buf[4] = v64;
            _os_log_impl(&dword_1B8270000, v62, v63, "*warn* cold_shard_delete_docs: %s\n", buf, 0xCu);
          }
          *__error() = v71;
          if (!v56)
            goto LABEL_50;
        }
        else
        {
          if (!*(_BYTE *)(v73 + 56))
            goto LABEL_65;
          v66 = *((_QWORD *)&v76 + 1);
          *(_QWORD *)(v73 + 48) += v76;
          DocStore::doColdShardCompaction((int *)v7, v43, v66);
          v51 = 0;
          if (!v56)
            goto LABEL_50;
        }
      }
      MEMORY[0x1BCCB06A4](v56, 0x1000C4034A301B9);
LABEL_50:
      close(v49);
      v65 = v74;
      if (v51)
        v65 = v51;
      v74 = v65;
      goto LABEL_53;
    }
LABEL_58:
    a4 = v73;
    v13 = v74;
  }
  if (!*(_BYTE *)(a4 + 24))
    goto LABEL_65;
  if (*(_DWORD *)(a4 + 16) == -1)
  {
    if (*(_BYTE *)(a4 + 40) && *(_BYTE *)(a4 + 56))
    {
      *(_QWORD *)(a4 + 16) = *(_QWORD *)(a4 + 48) + *(_QWORD *)(a4 + 32);
      return v13;
    }
LABEL_65:
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  return v13;
}

int *DocStore::doColdShardCompaction(int *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  int v4;
  int v5;
  NSObject *v6;
  os_log_type_t v7;
  int v8;
  uint64_t v9;
  __int16 v10;
  char *v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (!a3)
  {
    v3 = *((_QWORD *)result + 2) + 32 * a2;
    *(_BYTE *)(v3 + 25) = 1;
    if (*(char *)(v3 + 23) < 0)
      v3 = *(_QWORD *)v3;
    result = (int *)unlink((const char *)v3);
    if ((_DWORD)result)
    {
      result = __error();
      v4 = *result;
      if (*result != 2)
      {
        v5 = *__error();
        v6 = _SILogForLogForCategory(8);
        v7 = dword_1EF19FCAC < 3;
        if (os_log_type_enabled(v6, (os_log_type_t)(dword_1EF19FCAC < 3)))
        {
          v8 = 136315394;
          v9 = v3;
          v10 = 2080;
          v11 = strerror(v4);
          _os_log_impl(&dword_1B8270000, v6, v7, "*warn* unlink(%s): %s", (uint8_t *)&v8, 0x16u);
        }
        result = __error();
        *result = v5;
      }
    }
  }
  return result;
}

void std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v6;
  uint8x8_t v7;
  unint64_t v8;
  _QWORD *v9;
  _QWORD *i;
  unint64_t v11;
  _QWORD *v12;
  float v13;
  float v14;
  _BOOL8 v15;
  unint64_t v16;
  unint64_t v17;
  size_t v18;
  uint64_t v19;
  _QWORD *v20;
  unint64_t v21;

  v6 = *(_QWORD *)(a1 + 8);
  if (v6)
  {
    v7 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      v8 = a2;
      if (v6 <= a2)
        v8 = a2 % v6;
    }
    else
    {
      v8 = (v6 - 1) & a2;
    }
    v9 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v8);
    if (v9)
    {
      for (i = (_QWORD *)*v9; i; i = (_QWORD *)*i)
      {
        v11 = i[1];
        if (v11 == a2)
        {
          if (i[2] == a2)
            return;
        }
        else
        {
          if (v7.u32[0] > 1uLL)
          {
            if (v11 >= v6)
              v11 %= v6;
          }
          else
          {
            v11 &= v6 - 1;
          }
          if (v11 != v8)
            break;
        }
      }
    }
  }
  else
  {
    v8 = 0;
  }
  v12 = operator new(0x18uLL);
  *v12 = 0;
  v12[1] = a2;
  v12[2] = a3;
  v13 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v14 = *(float *)(a1 + 32);
  if (!v6 || (float)(v14 * (float)v6) < v13)
  {
    v15 = 1;
    if (v6 >= 3)
      v15 = (v6 & (v6 - 1)) != 0;
    v16 = v15 | (2 * v6);
    v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17)
      v18 = v17;
    else
      v18 = v16;
    std::__hash_table<std::__hash_value_type<std::string,int>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,int>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,int>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,int>>>::__rehash<true>(a1, v18);
    v6 = *(_QWORD *)(a1 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v6 <= a2)
        v8 = a2 % v6;
      else
        v8 = a2;
    }
    else
    {
      v8 = (v6 - 1) & a2;
    }
  }
  v19 = *(_QWORD *)a1;
  v20 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v8);
  if (v20)
  {
    *v12 = *v20;
LABEL_38:
    *v20 = v12;
    goto LABEL_39;
  }
  *v12 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v12;
  *(_QWORD *)(v19 + 8 * v8) = a1 + 16;
  if (*v12)
  {
    v21 = *(_QWORD *)(*v12 + 8);
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v21 >= v6)
        v21 %= v6;
    }
    else
    {
      v21 &= v6 - 1;
    }
    v20 = (_QWORD *)(*(_QWORD *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
}

void sub_1B83FA874(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(uint64_t a1, unint64_t a2, unint64_t a3)
{
  uint8x8_t v3;
  unint64_t v4;
  _QWORD *v5;
  _QWORD *result;
  unint64_t v7;

  if (!a2)
    return 0;
  v3 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    v4 = a3;
    if (a3 >= a2)
      v4 = a3 % a2;
  }
  else
  {
    v4 = (a2 - 1) & a3;
  }
  v5 = *(_QWORD **)(a1 + 8 * v4);
  if (!v5)
    return 0;
  result = (_QWORD *)*v5;
  if (*v5)
  {
    do
    {
      v7 = result[1];
      if (v7 == a3)
      {
        if (result[2] == a3)
          return result;
      }
      else
      {
        if (v3.u32[0] > 1uLL)
        {
          if (v7 >= a2)
            v7 %= a2;
        }
        else
        {
          v7 &= a2 - 1;
        }
        if (v7 != v4)
          return 0;
      }
      result = (_QWORD *)*result;
    }
    while (result);
  }
  return result;
}

uint64_t tt_transition_for_state(_QWORD *a1, uint64_t a2, unsigned __int16 a3, _QWORD *a4, _BYTE *a5)
{
  int8x8_t v5;
  unint64_t v6;
  uint8x8_t v7;
  uint64_t v8;
  uint64_t **v9;
  uint64_t *i;
  unint64_t v11;
  unsigned int v12;
  char v14;

  v5 = (int8x8_t)a1[1];
  if (v5)
  {
    v6 = 196613 * a3 + HIBYTE(a3) + 6291469 * a2;
    v7 = (uint8x8_t)vcnt_s8(v5);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      v8 = 196613 * a3 + HIBYTE(a3) + 6291469 * a2;
      if (v6 >= *(_QWORD *)&v5)
        v8 = v6 % *(_QWORD *)&v5;
    }
    else
    {
      v8 = v6 & (*(_QWORD *)&v5 - 1);
    }
    v9 = *(uint64_t ***)(*a1 + 8 * v8);
    if (v9)
    {
      for (i = *v9; i; i = (uint64_t *)*i)
      {
        v11 = i[1];
        if (v11 == v6)
        {
          v12 = *((unsigned __int16 *)i + 12);
          if (HIBYTE(a3) == v12 >> 8 && (~(-1 << SHIBYTE(a3)) & (v12 ^ a3)) == 0 && i[2] == a2)
          {
            v14 = *((_BYTE *)i + 40);
            *a4 = i[4];
            *a5 = v14;
            return 1;
          }
        }
        else
        {
          if (v7.u32[0] > 1uLL)
          {
            if (v11 >= *(_QWORD *)&v5)
              v11 %= *(_QWORD *)&v5;
          }
          else
          {
            v11 &= *(_QWORD *)&v5 - 1;
          }
          if (v11 != v8)
            return 0;
        }
      }
    }
  }
  return 0;
}

char *cStringRetainCallback(int a1, char *__s1)
{
  return strdup(__s1);
}

void cStringReleaseCallback(int a1, void *a2)
{
  free(a2);
}

BOOL hasTrailingAsterisk(_BOOL8 result)
{
  const __CFString *v1;
  CFIndex Length;
  CFIndex v3;
  CFIndex i;
  int CharacterAtIndex;
  int v6;

  if (result)
  {
    v1 = (const __CFString *)result;
    Length = CFStringGetLength((CFStringRef)result);
    v3 = Length - 1;
    if (CFStringGetCharacterAtIndex(v1, Length - 1) == 42
      && (Length == 1 || CFStringGetCharacterAtIndex(v1, Length - 2) != 92))
    {
      return 1;
    }
    else if (Length < 1)
    {
      return 0;
    }
    else
    {
      for (i = 0; i < Length; ++i)
      {
        CharacterAtIndex = CFStringGetCharacterAtIndex(v1, i);
        if (i < v3 && CharacterAtIndex == 92)
        {
          result = 0;
          ++i;
        }
        else
        {
          v6 = CFStringGetCharacterAtIndex(v1, i);
          result = i == v3 && v6 == 42;
        }
      }
    }
  }
  return result;
}

void utf8QueryString(const __CFString **a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v7;
  uint64_t v8;
  const std::string::value_type *v9;
  CFIndex Length;
  CFIndex v11;
  const __CFString *v12;
  CFIndex v13;
  const __CFString *v14;
  const __CFString **v15;
  CFIndex usedBufLen;
  CFRange v17;

  v7 = 0;
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  v8 = a3 - 1;
  if (a4)
    v9 = ", ";
  else
    v9 = " ";
  do
  {
    Length = CFStringGetLength(*(CFStringRef *)(a2 + 8 * v7));
    v11 = Length;
    if (*((char *)a1 + 23) >= 0)
      v12 = (const __CFString *)*((unsigned __int8 *)a1 + 23);
    else
      v12 = a1[1];
    v13 = 3 * Length + 1;
    std::string::resize((std::string *)a1, (std::string::size_type)v12 + v13, 0);
    v14 = *(const __CFString **)(a2 + 8 * v7);
    if (*((char *)a1 + 23) >= 0)
      v15 = a1;
    else
      v15 = (const __CFString **)*a1;
    usedBufLen = 0;
    v17.location = 0;
    v17.length = v11;
    CFStringGetBytes(v14, v17, 0x8000100u, 0, 0, (UInt8 *)v12 + (_QWORD)v15, v13, &usedBufLen);
    std::string::resize((std::string *)a1, (std::string::size_type)v12 + usedBufLen, 0);
    if (usedBufLen)
    {
      if (v7 < v8)
        std::string::append((std::string *)a1, v9);
    }
    ++v7;
  }
  while (a3 != v7);
}

_QWORD *makeOrNode(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v4;
  int v5;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t (*v10)(uint64_t);
  void *v11;
  void *v12;

  v2 = a2;
  if (a1)
  {
    if (a2)
    {
      v4 = *(unsigned __int16 *)(a1 + 40);
      if (v4 == 16)
      {
LABEL_6:
        v8 = MEMORY[0x1E0C809B0];
        v9 = 0x40000000;
        v10 = __db_query_tree_apply_block_block_invoke;
        v11 = &unk_1E6E377F8;
        v12 = &__block_literal_global_143;
        db_query_tree_apply_block_with_meta((_QWORD *)a1, (uint64_t)&v8, 0);
        return (_QWORD *)v2;
      }
      v5 = *(unsigned __int16 *)(a2 + 40);
      if (v5 != 16)
      {
        if (v5 == 32)
          goto LABEL_6;
        if (v4 != 32)
        {
          v7 = malloc_type_calloc(1uLL, 0x48uLL, 0x10E0040D742DA1DuLL);
          *v7 = a1;
          v7[1] = v2;
          *((_WORD *)v7 + 20) = 1;
          return v7;
        }
      }
      v8 = MEMORY[0x1E0C809B0];
      v9 = 0x40000000;
      v10 = __db_query_tree_apply_block_block_invoke;
      v11 = &unk_1E6E377F8;
      v12 = &__block_literal_global_143;
      db_query_tree_apply_block_with_meta((_QWORD *)a2, (uint64_t)&v8, 0);
    }
    return (_QWORD *)a1;
  }
  return (_QWORD *)v2;
}

_QWORD *makeAndNode(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v4;
  int v5;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t (*v10)(uint64_t);
  void *v11;
  void *v12;

  v2 = a2;
  if (a1)
  {
    if (a2)
    {
      v4 = *(unsigned __int16 *)(a1 + 40);
      if (v4 == 32)
      {
LABEL_6:
        v8 = MEMORY[0x1E0C809B0];
        v9 = 0x40000000;
        v10 = __db_query_tree_apply_block_block_invoke;
        v11 = &unk_1E6E377F8;
        v12 = &__block_literal_global_143;
        db_query_tree_apply_block_with_meta((_QWORD *)a1, (uint64_t)&v8, 0);
        return (_QWORD *)v2;
      }
      v5 = *(unsigned __int16 *)(a2 + 40);
      if (v5 != 32)
      {
        if (v5 == 16)
          goto LABEL_6;
        if (v4 != 16)
        {
          v7 = malloc_type_calloc(1uLL, 0x48uLL, 0x10E0040D742DA1DuLL);
          *v7 = a1;
          v7[1] = v2;
          *((_WORD *)v7 + 20) = 2;
          return v7;
        }
      }
      v8 = MEMORY[0x1E0C809B0];
      v9 = 0x40000000;
      v10 = __db_query_tree_apply_block_block_invoke;
      v11 = &unk_1E6E377F8;
      v12 = &__block_literal_global_143;
      db_query_tree_apply_block_with_meta((_QWORD *)a2, (uint64_t)&v8, 0);
    }
    return (_QWORD *)a1;
  }
  return (_QWORD *)v2;
}

const char *createQueryNode(const char *result, char *__s, uint64_t a3, int a4, int a5, float a6, float a7)
{
  const char *v13;
  size_t v14;
  _DWORD *v15;
  char *v16;
  char *v17;
  char *v18;
  char *v19;

  if (result)
  {
    v13 = result;
    if (__s)
      v14 = strlen(__s);
    else
      v14 = 0;
    v15 = malloc_type_calloc(1uLL, 0x130uLL, 0x10B20407DF6C093uLL);
    *(_QWORD *)v15 = strdup(v13);
    v15[6] = a4;
    *((_QWORD *)v15 + 4) = a3;
    if (a5 < 1)
    {
      if (a5 == -1)
      {
        v19 = (char *)operator new[]();
        v18 = strcpy(v19, __s);
        *(_WORD *)&v18[v14] = 42;
      }
      else
      {
        v18 = strdup(__s);
      }
      *((_QWORD *)v15 + 9) = v18;
    }
    else
    {
      v16 = (char *)operator new[]();
      v17 = strcpy(v16, __s);
      *(_WORD *)&v17[v14] = 42;
      *((_QWORD *)v15 + 9) = v17;
      v15[15] = a5;
    }
    if ((*((_BYTE *)v15 + 34) & 0x80) != 0)
      *((_BYTE *)v15 + 28) = 70;
    *((float *)v15 + 13) = a6;
    *((float *)v15 + 14) = a7;
    result = (const char *)malloc_type_calloc(1uLL, 0x48uLL, 0x10E0040D742DA1DuLL);
    *((_WORD *)result + 20) = 4;
    *((_QWORD *)result + 2) = v15;
  }
  return result;
}

const char *createQueryNodeForPhotosMediaType(int a1, int a2)
{
  float v2;
  int v3;

  if (a2)
  {
    v2 = 1.1755e-38;
    if ((a1 & 1) != 0)
      v3 = 1;
    else
      v3 = 5;
  }
  else
  {
    if (a1)
      v3 = 1;
    else
      v3 = 5;
    v2 = 0.0;
  }
  return createQueryNode("kMDItemPhotosMediaTypes", "*", 0, v3, 0, v2, 0.0);
}

_QWORD *makeRetrievalNodeFromQueryString(char *a1)
{
  _QWORD *query_node_with_ann;
  _QWORD v3[5];

  query_node_with_ann = db_make_query_node_with_ann(a1, 0);
  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 0x40000000;
  v3[2] = __db_query_tree_apply_block_block_invoke;
  v3[3] = &unk_1E6E377F8;
  v3[4] = &__block_literal_global_766;
  db_query_tree_apply_block_with_meta(query_node_with_ann, (uint64_t)v3, 0);
  return query_node_with_ann;
}

uint64_t ___Z32makeRetrievalNodeFromQueryStringPKc_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v3;

  result = a2;
  if (a2)
  {
    v3 = *(_QWORD *)(a2 + 16);
    if (v3)
    {
      *(_DWORD *)(v3 + 52) = 0;
      *(_DWORD *)(v3 + 56) = 0;
    }
  }
  return result;
}

const char *queryNodeForToken(char *a1, _QWORD *a2, uint64_t a3, _BYTE *a4)
{
  size_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  char *v12;
  unsigned __int8 *v13;
  float *v14;
  float v15;
  _QWORD *v16;
  int v17;
  uint64_t *v18;
  char *v19;
  _QWORD *v20;
  int v21;
  void *QueryNode;
  float v23;
  int v24;
  const char *v25;
  _QWORD *(*v26)(uint64_t, uint64_t);
  uint64_t *v28;
  _QWORD *v29;
  int v30;
  char *v31;
  int v32;
  unsigned __int8 *v33;
  const char *v34;
  uint64_t v36;
  _QWORD *v37;
  void *__p[2];
  char v39;

  if (!a1)
    return 0;
  v8 = strlen(a1);
  v9 = 0;
  if (!a4 || !v8)
    return (const char *)v9;
  v10 = *(_DWORD *)(a3 + 40);
  if (!v10 && v8 >= 4)
  {
    if (*(_BYTE *)(a3 + 45) || a4[17] || a4[12])
      v10 = 0;
    else
      v10 = 2 * a4[13];
  }
  v11 = *(_QWORD *)(a3 + 16);
  if (*(char *)(v11 + 23) < 0)
  {
    if (!*(_QWORD *)(v11 + 8))
      goto LABEL_27;
    v12 = *(char **)v11;
    goto LABEL_15;
  }
  v12 = *(char **)(a3 + 16);
  if (*(_BYTE *)(v11 + 23))
  {
LABEL_15:
    if (!a4[12])
    {
      v15 = 0.0;
      if (v10)
      {
LABEL_21:
        v16 = *(_QWORD **)(a3 + 32);
        std::string::basic_string[abi:nn180100]<0>(__p, v12);
        if (std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::find<std::string>(v16, (uint64_t)__p))
        {
          v17 = v10;
        }
        else
        {
          v17 = 0;
        }
        if (v39 < 0)
          operator delete(__p[0]);
        return createQueryNode(v12, a1, *(_QWORD *)a3, *(_DWORD *)(a3 + 24), v17, v15 * *(float *)(a3 + 8), v15 * *(float *)(a3 + 12));
      }
LABEL_53:
      v17 = 0;
      return createQueryNode(v12, a1, *(_QWORD *)a3, *(_DWORD *)(a3 + 24), v17, v15 * *(float *)(a3 + 8), v15 * *(float *)(a3 + 12));
    }
    if (!*(_BYTE *)(a3 + 46) || strcmp(v12, "kMDItemTextContent"))
    {
      v13 = std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::find<std::string>(a2, v11);
      v14 = (float *)(v13 + 40);
      if (!v13)
        v14 = (float *)&defaultAttributeScore;
      v15 = *v14 + *v14;
      if (v10)
        goto LABEL_21;
      goto LABEL_53;
    }
    return 0;
  }
LABEL_27:
  v37 = a2;
  v18 = (uint64_t *)a2[2];
  if (v18)
  {
    v9 = 0;
    do
    {
      v19 = (char *)(v18 + 2);
      if (*((char *)v18 + 39) < 0)
        v19 = *(char **)v19;
      if (!a4[12] || !*(_BYTE *)(a3 + 46) || strcmp(v19, "kMDItemTextContent"))
      {
        if (v10)
        {
          v20 = *(_QWORD **)(a3 + 32);
          std::string::basic_string[abi:nn180100]<0>(__p, v19);
          if (std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::find<std::string>(v20, (uint64_t)__p))
          {
            v21 = v10;
          }
          else
          {
            v21 = 0;
          }
          if (v39 < 0)
            operator delete(__p[0]);
        }
        else
        {
          v21 = 0;
        }
        QueryNode = (void *)createQueryNode(v19, a1, *(_QWORD *)a3, *(_DWORD *)(a3 + 24), v21, *((float *)v18 + 10) * *(float *)(a3 + 8), *((float *)v18 + 10) * *(float *)(a3 + 12));
        if (a4[20] && !strcmp(v19, "kMDItemTextContent"))
        {
          if (a4[12])
          {
            v23 = 1.1755e-38;
            v24 = 1;
          }
          else
          {
            v23 = 0.0;
            v24 = 5;
          }
          v25 = createQueryNode("_kMDItemBundleID", "com.apple.mobilesafari", 0, v24, 0, 0.0, v23);
          QueryNode = makeAndNode((uint64_t)QueryNode, (uint64_t)v25);
        }
        v26 = makeAndNode;
        if (!*(_BYTE *)(a3 + 28))
          v26 = makeOrNode;
        v9 = (uint64_t)v26(v9, (uint64_t)QueryNode);
      }
      v18 = (uint64_t *)*v18;
    }
    while (v18);
  }
  else
  {
    v9 = 0;
  }
  if (!a4[12] && v10)
  {
    v28 = *(uint64_t **)(*(_QWORD *)(a3 + 32) + 16);
    if (v28)
    {
      v29 = 0;
      v36 = *(_QWORD *)a3;
      v30 = *(_DWORD *)(a3 + 24);
      do
      {
        v31 = (char *)(v28 + 2);
        if (*((char *)v28 + 39) < 0)
          v31 = *(char **)v31;
        if (*((_DWORD *)v28 + 10))
          v32 = *((_DWORD *)v28 + 10);
        else
          v32 = v10;
        if (strcmp(v31, "kMDItemTextContent"))
        {
          std::string::basic_string[abi:nn180100]<0>(__p, v31);
          v33 = std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::find<std::string>(v37, (uint64_t)__p);
          if (v39 < 0)
            operator delete(__p[0]);
          if (!v33 && v10 >= 1 && v32 >= 1)
          {
            v34 = createQueryNode(v31, a1, v36, v30, v32, 0.0, 0.0);
            v29 = makeOrNode((uint64_t)v29, (uint64_t)v34);
          }
        }
        v28 = (uint64_t *)*v28;
      }
      while (v28);
    }
    else
    {
      v29 = 0;
    }
    return (const char *)makeOrNode(v9, (uint64_t)v29);
  }
  return (const char *)v9;
}

uint64_t normalizeQueryNode(uint64_t a1)
{
  uint64_t v2;
  int v3;
  _QWORD v5[4];
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t (*v9)(uint64_t);
  void *v10;
  _QWORD *v11;

  v2 = MEMORY[0x1E0C809B0];
  v7 = MEMORY[0x1E0C809B0];
  v8 = 0x40000000;
  v9 = __db_query_tree_apply_block_block_invoke;
  v10 = &unk_1E6E377F8;
  v11 = &__block_literal_global_9_774;
  db_query_tree_apply_block_with_meta((_QWORD *)a1, (uint64_t)&v7, (uint64_t)&__block_literal_global_12);
  v3 = *(_DWORD *)(a1 + 64);
  v5[0] = v2;
  v5[1] = 0x40000000;
  v5[2] = ___Z18normalizeQueryNodeP10query_node_block_invoke_3;
  v5[3] = &__block_descriptor_tmp_13_775;
  v6 = v3;
  v7 = v2;
  v8 = 0x40000000;
  v9 = __db_query_tree_apply_block_block_invoke;
  v10 = &unk_1E6E377F8;
  v11 = v5;
  return db_query_tree_apply_block_with_meta((_QWORD *)a1, (uint64_t)&v7, 0);
}

uint64_t ___Z18normalizeQueryNodeP10query_node_block_invoke_3(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  float v3;
  float v4;

  if (a2)
  {
    v2 = *(_QWORD *)(a2 + 16);
    if (v2)
    {
      v3 = *(float *)(v2 + 52);
      if (v3 > 1.1755e-38)
        *(float *)(v2 + 52) = v3 / *(float *)(a1 + 32);
      v4 = *(float *)(v2 + 56);
      if (v4 > 1.1755e-38)
        *(float *)(v2 + 56) = v4 / *(float *)(a1 + 32);
    }
  }
  *(_DWORD *)(a2 + 64) = 0;
  return a2;
}

uint64_t ___Z18normalizeQueryNodeP10query_node_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;
  int v5;
  float v6;
  float v7;
  float v8;
  _QWORD v9[5];

  result = a2;
  if (a2 && a3 && a4)
  {
    *(_QWORD *)a2 = a3;
    *(_QWORD *)(a2 + 8) = a4;
    v5 = *(unsigned __int16 *)(a2 + 40);
    if (v5 == 2)
    {
      v7 = *(float *)(a3 + 64);
      v6 = 0.0;
      if (v7 != 0.0)
      {
        v8 = *(float *)(a4 + 64);
        if (v8 != 0.0)
          v6 = v7 + v8;
      }
    }
    else
    {
      if (v5 != 1)
        return result;
      v6 = *(float *)(a3 + 64);
      if (v6 <= *(float *)(a4 + 64))
        v6 = *(float *)(a4 + 64);
    }
    *(float *)(a2 + 64) = v6;
  }
  else if (a2)
  {
    v9[0] = MEMORY[0x1E0C809B0];
    v9[1] = 0x40000000;
    v9[2] = __db_query_tree_apply_block_block_invoke;
    v9[3] = &unk_1E6E377F8;
    v9[4] = &__block_literal_global_143;
    db_query_tree_apply_block_with_meta((_QWORD *)a2, (uint64_t)v9, 0);
    return 0;
  }
  return result;
}

uint64_t ___Z18normalizeQueryNodeP10query_node_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v3;
  float v4;

  result = a2;
  if (a2)
  {
    v3 = *(_QWORD *)(a2 + 16);
    if (v3)
    {
      v4 = *(float *)(v3 + 52);
      if (v4 <= *(float *)(v3 + 56))
        v4 = *(float *)(v3 + 56);
      *(float *)(a2 + 64) = v4;
    }
  }
  return result;
}

BOOL isOptionalSpecialChar(UniChar a1)
{
  const __CFCharacterSet *Predefined;
  _BOOL8 v3;
  const __CFCharacterSet *v4;
  const __CFCharacterSet *v5;

  Predefined = CFCharacterSetGetPredefined(kCFCharacterSetWhitespaceAndNewline);
  v3 = 1;
  if (!CFCharacterSetIsCharacterMember(Predefined, a1))
  {
    v4 = CFCharacterSetGetPredefined(kCFCharacterSetControl);
    if (!CFCharacterSetIsCharacterMember(v4, a1))
    {
      v5 = CFCharacterSetCreateWithCharactersInString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], CFSTR(",;:.!_"));
      v3 = CFCharacterSetIsCharacterMember(v5, a1) != 0;
      CFRelease(v5);
    }
  }
  return v3;
}

BOOL hasTrailingOptionalSpecialChar(const __CFString *a1)
{
  CFIndex Length;
  UniChar CharacterAtIndex;

  if (!a1 || !CFStringGetLength(a1))
    return 0;
  Length = CFStringGetLength(a1);
  CharacterAtIndex = CFStringGetCharacterAtIndex(a1, Length - 1);
  return isOptionalSpecialChar(CharacterAtIndex);
}

BOOL hasOnlyOptionalSpecialChar(const __CFString *a1)
{
  CFIndex Length;
  CFIndex v3;
  CFIndex v4;
  UniChar CharacterAtIndex;
  _BOOL8 result;

  if (!a1)
    return 1;
  Length = CFStringGetLength(a1);
  v3 = Length - 1;
  if (Length < 1)
    return 1;
  v4 = 0;
  do
  {
    CharacterAtIndex = CFStringGetCharacterAtIndex(a1, v4);
    result = isOptionalSpecialChar(CharacterAtIndex);
    if (!result)
      break;
  }
  while (v3 != v4++);
  return result;
}

BOOL isOptionalWord(char *a1)
{
  unsigned __int8 v2;
  _BOOL8 v3;
  std::string __p;

  {
    OptionalWords(void)::optionalWords = 0u;
    *(_OWORD *)algn_1EF1ACDA8 = 0u;
    dword_1EF1ACDB8 = 1065353216;
    __cxa_atexit((void (*)(void *))std::unordered_set<std::string>::~unordered_set[abi:nn180100], &OptionalWords(void)::optionalWords, &dword_1B8270000);
  }
  if (OptionalWords(void)::onceToken[0] != -1)
    dispatch_once(OptionalWords(void)::onceToken, &__block_literal_global_22);
  if (!qword_1EF1ACDB0)
    return 0;
  if (isLowerStr(a1))
    return std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(OptionalWords(void)::optionalWords, *((unint64_t *)&OptionalWords(void)::optionalWords + 1), (uint64_t)a1) != 0;
  toLowerCase(&__p, a1);
  v3 = std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(OptionalWords(void)::optionalWords, *((unint64_t *)&OptionalWords(void)::optionalWords + 1), (uint64_t)&__p) != 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  return v3;
}

BOOL isLowerStr(char *a1)
{
  uint64_t v1;
  char *v2;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  int v6;
  _BOOL8 result;
  BOOL v8;

  v1 = a1[23];
  if ((v1 & 0x80u) == 0)
    v2 = a1;
  else
    v2 = *(char **)a1;
  if ((v1 & 0x80u) != 0)
    v1 = *((_QWORD *)a1 + 1);
  if (!v1)
    return 1;
  v3 = v1 - 1;
  v4 = MEMORY[0x1E0C80978];
  do
  {
    v5 = *v2;
    if ((v5 & 0x80000000) != 0)
      v6 = __maskrune(v5, 0x1000uLL);
    else
      v6 = *(_DWORD *)(v4 + 4 * v5 + 60) & 0x1000;
    result = v6 != 0;
    ++v2;
    if (v6)
      v8 = v3 == 0;
    else
      v8 = 1;
    --v3;
  }
  while (!v8);
  return result;
}

unsigned __int8 *std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(uint64_t a1, unint64_t a2, uint64_t a3)
{
  int v6;
  uint64_t *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint8x8_t v11;
  unint64_t v12;
  unint64_t v13;
  unsigned __int8 **v14;
  unsigned __int8 *i;
  unint64_t v16;

  v6 = *(char *)(a3 + 23);
  if (v6 >= 0)
    v7 = (uint64_t *)a3;
  else
    v7 = *(uint64_t **)a3;
  if (v6 >= 0)
    v8 = *(unsigned __int8 *)(a3 + 23);
  else
    v8 = *(_QWORD *)(a3 + 8);
  v9 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v7, v8);
  if (!a2)
    return 0;
  v10 = v9;
  v11 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
  v11.i16[0] = vaddlv_u8(v11);
  v12 = v11.u32[0];
  if (v11.u32[0] > 1uLL)
  {
    v13 = v9;
    if (v9 >= a2)
      v13 = v9 % a2;
  }
  else
  {
    v13 = (a2 - 1) & v9;
  }
  v14 = *(unsigned __int8 ***)(a1 + 8 * v13);
  if (!v14)
    return 0;
  for (i = *v14; i; i = *(unsigned __int8 **)i)
  {
    v16 = *((_QWORD *)i + 1);
    if (v10 == v16)
    {
      if (std::equal_to<std::string>::operator()[abi:nn180100](i + 16, (unsigned __int8 *)a3))
        return i;
    }
    else
    {
      if (v12 > 1)
      {
        if (v16 >= a2)
          v16 %= a2;
      }
      else
      {
        v16 &= a2 - 1;
      }
      if (v16 != v13)
        return 0;
    }
  }
  return i;
}

void toLowerCase(std::string *a1, char *a2)
{
  char *v2;
  std::string::size_type v4;
  uint64_t v5;
  uint64_t v6;
  __darwin_ct_rune_t v7;
  std::string::value_type v8;

  v2 = a2;
  a1->__r_.__value_.__r.__words[0] = 0;
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  if (a2[23] >= 0)
    v4 = a2[23];
  else
    v4 = *((_QWORD *)a2 + 1);
  std::string::reserve(a1, v4);
  v5 = *((_QWORD *)v2 + 1);
  if (v2[23] >= 0)
  {
    v6 = v2[23];
  }
  else
  {
    v2 = *(char **)v2;
    v6 = v5;
  }
  for (; v6; --v6)
  {
    v7 = *v2++;
    v8 = __tolower(v7);
    std::string::push_back(a1, v8);
  }
}

void ___ZL13OptionalWordsv_block_invoke()
{
  CFLocaleRef v0;
  CFLocaleRef v1;
  const __CFString *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t i;
  uint64_t j;
  uint64_t v7;
  const __CFString *v8;
  const __CFString *v9;
  std::string __str[6];
  _QWORD v11[3];
  _QWORD v12[3];
  _QWORD v13[3];
  _QWORD v14[3];
  _QWORD v15[3];
  std::string v16;
  _QWORD v17[3];
  _QWORD v18[3];
  std::string v19;
  _QWORD v20[3];
  _QWORD v21[3];
  std::string v22;
  uint64_t v23[3];
  uint64_t v24[3];
  uint64_t v25[3];
  uint64_t v26[3];
  uint64_t v27[3];
  uint64_t v28[3];
  uint64_t v29[3];
  uint64_t v30[3];
  uint64_t v31[3];
  uint64_t v32[3];
  uint64_t v33[3];
  uint64_t v34[3];
  std::string v35;

  v35.__r_.__value_.__r.__words[0] = *MEMORY[0x1E0C80C00];
  v0 = CFLocaleCopyCurrent();
  if (v0)
  {
    v1 = v0;
    v2 = (const __CFString *)MEMORY[0x1BCCAF7B0]();
    if (CFStringHasPrefix(v2, CFSTR("en")))
    {
      std::string::basic_string[abi:nn180100]<0>(__str, "to");
      std::string::basic_string[abi:nn180100]<0>(v11, "with");
      std::string::basic_string[abi:nn180100]<0>(v12, "in");
      std::string::basic_string[abi:nn180100]<0>(v13, "and");
      std::string::basic_string[abi:nn180100]<0>(v14, "or");
      std::string::basic_string[abi:nn180100]<0>(v15, "on");
      std::string::basic_string[abi:nn180100]<0>(&v16, "of");
      std::string::basic_string[abi:nn180100]<0>(v17, "at");
      std::string::basic_string[abi:nn180100]<0>(v18, "am");
      std::string::basic_string[abi:nn180100]<0>(&v19, "is");
      std::string::basic_string[abi:nn180100]<0>(v20, "are");
      std::string::basic_string[abi:nn180100]<0>(v21, "was");
      std::string::basic_string[abi:nn180100]<0>(&v22, "were");
      std::string::basic_string[abi:nn180100]<0>(v23, "be");
      std::string::basic_string[abi:nn180100]<0>(v24, "a");
      std::string::basic_string[abi:nn180100]<0>(v25, "an");
      std::string::basic_string[abi:nn180100]<0>(v26, "the");
      std::string::basic_string[abi:nn180100]<0>(v27, "by");
      std::string::basic_string[abi:nn180100]<0>(v28, "for");
      std::string::basic_string[abi:nn180100]<0>(v29, "from");
      std::string::basic_string[abi:nn180100]<0>(v30, "off");
      std::string::basic_string[abi:nn180100]<0>(v31, "so");
      std::string::basic_string[abi:nn180100]<0>(v32, "as");
      std::string::basic_string[abi:nn180100]<0>(v33, "during");
      std::string::basic_string[abi:nn180100]<0>(v34, "under");
      std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__assign_unique<std::string const*>((uint64_t)&OptionalWords(void)::optionalWords, __str, &v35);
      v3 = 25;
      do
      {
        if (SHIBYTE(__str[v3 - 1].__r_.__value_.__r.__words[2]) < 0)
          operator delete(__str[v3 - 1].__r_.__value_.__l.__data_);
        --v3;
      }
      while (v3 * 24);
    }
    else if (CFStringHasPrefix(v2, CFSTR("fr")))
    {
      std::string::basic_string[abi:nn180100]<0>(__str, "à");
      std::string::basic_string[abi:nn180100]<0>(v11, "avec");
      std::string::basic_string[abi:nn180100]<0>(v12, "en");
      std::string::basic_string[abi:nn180100]<0>(v13, "dans");
      std::string::basic_string[abi:nn180100]<0>(v14, "a");
      std::string::basic_string[abi:nn180100]<0>(v15, "et");
      std::string::basic_string[abi:nn180100]<0>(&v16, "de");
      std::string::basic_string[abi:nn180100]<0>(v17, "au");
      std::string::basic_string[abi:nn180100]<0>(v18, "un");
      std::string::basic_string[abi:nn180100]<0>(&v19, "le");
      std::string::basic_string[abi:nn180100]<0>(v20, "la");
      std::string::basic_string[abi:nn180100]<0>(v21, "pendant");
      std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__assign_unique<std::string const*>((uint64_t)&OptionalWords(void)::optionalWords, __str, &v22);
      v4 = 12;
      do
      {
        if (SHIBYTE(__str[v4 - 1].__r_.__value_.__r.__words[2]) < 0)
          operator delete(__str[v4 - 1].__r_.__value_.__l.__data_);
        --v4;
      }
      while (v4 * 24);
    }
    else if (CFStringHasPrefix(v2, CFSTR("ja")))
    {
      std::string::basic_string[abi:nn180100]<0>(__str, "から");
      std::string::basic_string[abi:nn180100]<0>(v11, "で");
      std::string::basic_string[abi:nn180100]<0>(v12, "と");
      std::string::basic_string[abi:nn180100]<0>(v13, "に");
      std::string::basic_string[abi:nn180100]<0>(v14, "の");
      std::string::basic_string[abi:nn180100]<0>(v15, "へ");
      std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__assign_unique<std::string const*>((uint64_t)&OptionalWords(void)::optionalWords, __str, &v16);
      for (i = 0; i != -18; i -= 3)
      {
        if (SHIBYTE(v15[i + 2]) < 0)
          operator delete((void *)v15[i]);
      }
    }
    else if (CFStringHasPrefix(v2, CFSTR("zh")))
    {
      std::string::basic_string[abi:nn180100]<0>(__str, "与");
      std::string::basic_string[abi:nn180100]<0>(v11, "从");
      std::string::basic_string[abi:nn180100]<0>(v12, "到");
      std::string::basic_string[abi:nn180100]<0>(v13, "同");
      std::string::basic_string[abi:nn180100]<0>(v14, "和");
      std::string::basic_string[abi:nn180100]<0>(v15, "在");
      std::string::basic_string[abi:nn180100]<0>(&v16, "或");
      std::string::basic_string[abi:nn180100]<0>(v17, "的");
      std::string::basic_string[abi:nn180100]<0>(v18, "里");
      std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__assign_unique<std::string const*>((uint64_t)&OptionalWords(void)::optionalWords, __str, &v19);
      for (j = 0; j != -27; j -= 3)
      {
        if (SHIBYTE(v18[j + 2]) < 0)
          operator delete((void *)v18[j]);
      }
    }
    else if (CFStringHasPrefix(v2, CFSTR("de")))
    {
      std::string::basic_string[abi:nn180100]<0>(__str, "an");
      std::string::basic_string[abi:nn180100]<0>(v11, "in");
      std::string::basic_string[abi:nn180100]<0>(v12, "von");
      std::string::basic_string[abi:nn180100]<0>(v13, "nach");
      std::string::basic_string[abi:nn180100]<0>(v14, "mit");
      std::string::basic_string[abi:nn180100]<0>(v15, "und");
      std::string::basic_string[abi:nn180100]<0>(&v16, "oder");
      std::string::basic_string[abi:nn180100]<0>(v17, "bin");
      std::string::basic_string[abi:nn180100]<0>(v18, "bist");
      std::string::basic_string[abi:nn180100]<0>(&v19, "seit");
      std::string::basic_string[abi:nn180100]<0>(v20, "ist");
      std::string::basic_string[abi:nn180100]<0>(v21, "sind");
      std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__assign_unique<std::string const*>((uint64_t)&OptionalWords(void)::optionalWords, __str, &v22);
      v7 = 12;
      do
      {
        if (SHIBYTE(__str[v7 - 1].__r_.__value_.__r.__words[2]) < 0)
          operator delete(__str[v7 - 1].__r_.__value_.__l.__data_);
        --v7;
      }
      while (v7 * 24);
    }
    else
    {
      v8 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("%@"), CFSTR("com.apple.metadata.SpotlightLinguistics"));
      if (v8)
      {
        v9 = v8;
        if (CFBundleGetBundleWithIdentifier(v8))
          populateStopWords(v2);
        CFRelease(v9);
      }
    }
    CFRelease(v1);
  }
}

void std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__assign_unique<std::string const*>(uint64_t a1, std::string *__str, std::string *a3)
{
  std::string *v3;
  const std::string *v4;
  uint64_t v6;
  uint64_t i;
  void **v8;
  BOOL v9;
  void **v10;
  int v11;
  uint64_t *v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint8x8_t v17;
  unint64_t v18;
  unint64_t v19;
  unsigned __int8 **v20;
  unsigned __int8 *j;
  unint64_t v22;
  float v23;
  float v24;
  _BOOL8 v25;
  unint64_t v26;
  unint64_t v27;
  size_t v28;
  uint8x8_t v29;
  void **v30;
  unint64_t v31;
  uint64_t v32;
  void **__p;

  v3 = a3;
  v4 = __str;
  v6 = *(_QWORD *)(a1 + 8);
  if (!v6)
    goto LABEL_60;
  for (i = 0; i != v6; ++i)
    *(_QWORD *)(*(_QWORD *)a1 + 8 * i) = 0;
  v8 = *(void ***)(a1 + 16);
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  if (v8)
    v9 = __str == a3;
  else
    v9 = 1;
  if (v9)
  {
    v10 = v8;
    goto LABEL_58;
  }
  v32 = a1 + 16;
  while (1)
  {
    std::string::operator=((std::string *)(v8 + 2), v4);
    __p = (void **)*v8;
    v11 = *((char *)v8 + 39);
    if (v11 >= 0)
      v12 = (uint64_t *)(v8 + 2);
    else
      v12 = (uint64_t *)v8[2];
    if (v11 >= 0)
      v13 = *((unsigned __int8 *)v8 + 39);
    else
      v13 = (unint64_t)v8[3];
    v14 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v12, v13);
    v15 = v14;
    v8[1] = (void *)v14;
    v16 = *(_QWORD *)(a1 + 8);
    if (v16)
    {
      v17 = (uint8x8_t)vcnt_s8((int8x8_t)v16);
      v17.i16[0] = vaddlv_u8(v17);
      v18 = v17.u32[0];
      if (v17.u32[0] > 1uLL)
      {
        v19 = v14;
        if (v16 <= v14)
          v19 = v14 % v16;
      }
      else
      {
        v19 = (v16 - 1) & v14;
      }
      v20 = *(unsigned __int8 ***)(*(_QWORD *)a1 + 8 * v19);
      if (v20)
      {
        for (j = *v20; j; j = *(unsigned __int8 **)j)
        {
          v22 = *((_QWORD *)j + 1);
          if (v22 == v15)
          {
            if (std::equal_to<std::string>::operator()[abi:nn180100](j + 16, (unsigned __int8 *)v8 + 16))
              goto LABEL_54;
          }
          else
          {
            if (v18 > 1)
            {
              if (v22 >= v16)
                v22 %= v16;
            }
            else
            {
              v22 &= v16 - 1;
            }
            if (v22 != v19)
              break;
          }
        }
      }
    }
    v23 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
    v24 = *(float *)(a1 + 32);
    if (!v16 || (float)(v24 * (float)v16) < v23)
    {
      v25 = (v16 & (v16 - 1)) != 0;
      if (v16 < 3)
        v25 = 1;
      v26 = v25 | (2 * v16);
      v27 = vcvtps_u32_f32(v23 / v24);
      if (v26 <= v27)
        v28 = v27;
      else
        v28 = v26;
      std::__hash_table<std::__hash_value_type<std::string,int>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,int>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,int>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,int>>>::__rehash<true>(a1, v28);
      v16 = *(_QWORD *)(a1 + 8);
      v15 = (unint64_t)v8[1];
    }
    v29 = (uint8x8_t)vcnt_s8((int8x8_t)v16);
    v29.i16[0] = vaddlv_u8(v29);
    if (v29.u32[0] > 1uLL)
    {
      if (v15 >= v16)
        v15 %= v16;
    }
    else
    {
      v15 &= v16 - 1;
    }
    v30 = *(void ***)(*(_QWORD *)a1 + 8 * v15);
    if (v30)
    {
      *v8 = *v30;
LABEL_52:
      *v30 = v8;
      goto LABEL_53;
    }
    *v8 = *(void **)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v8;
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v15) = v32;
    if (*v8)
    {
      v31 = *((_QWORD *)*v8 + 1);
      if (v29.u32[0] > 1uLL)
      {
        if (v31 >= v16)
          v31 %= v16;
      }
      else
      {
        v31 &= v16 - 1;
      }
      v30 = (void **)(*(_QWORD *)a1 + 8 * v31);
      goto LABEL_52;
    }
LABEL_53:
    ++*(_QWORD *)(a1 + 24);
LABEL_54:
    ++v4;
    v10 = __p;
    if (!__p)
      break;
    v8 = __p;
    v3 = a3;
    if (v4 == a3)
      goto LABEL_58;
  }
  v3 = a3;
LABEL_58:
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__deallocate_node(v10);
LABEL_60:
  while (v4 != v3)
  {
    std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string const&>(a1, (uint64_t)v4, (uint64_t)v4);
    ++v4;
  }
}

void populateStopWords(const __CFString *a1)
{
  uint64_t v2;
  const void *v3;
  const __CFDictionary *v4;
  const __CFDictionary *v5;
  CFStringRef v6;
  const __CFString *Value;
  const __CFArray *ArrayBySeparatingStrings;
  const __CFArray *v9;
  CFIndex Count;
  CFIndex v11;
  CFIndex i;
  const __CFString *ValueAtIndex;
  char *CStringPtr;
  void *__p[2];
  char v16;
  int v17;
  int v18;
  int v19;
  int v20;
  CFRange v21;

  v19 = -1;
  v20 = -1;
  v17 = 0;
  v18 = -1;
  if (CFBundleGetLocalizationInfoForLocalization())
  {
    v2 = CFBundleCopyLocalizationForLocalizationInfo();
    if (v2)
    {
      v3 = (const void *)v2;
      v4 = (const __CFDictionary *)CFBundleCopyLocalizedStringTableForLocalization();
      if (v4)
      {
        v5 = v4;
        if (CFDictionaryGetCount(v4)
          || (v21.location = 0,
              v21.length = 2,
              v6 = CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a1, v21),
              CFRelease(v5),
              v5 = (const __CFDictionary *)CFBundleCopyLocalizedStringTableForLocalization(),
              CFRelease(v6),
              v5))
        {
          Value = (const __CFString *)CFDictionaryGetValue(v5, CFSTR("STOPWORDS_SHORT"));
          if (Value)
          {
            ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings((CFAllocatorRef)*MEMORY[0x1E0C9AE00], Value, CFSTR(" | "));
            if (ArrayBySeparatingStrings)
            {
              v9 = ArrayBySeparatingStrings;
              Count = CFArrayGetCount(ArrayBySeparatingStrings);
              if (Count >= 1)
              {
                v11 = Count;
                for (i = 0; i != v11; ++i)
                {
                  ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v9, i);
                  CStringPtr = (char *)CFStringGetCStringPtr(ValueAtIndex, 0x8000100u);
                  if (CStringPtr)
                  {
                    std::string::basic_string[abi:nn180100]<0>(__p, CStringPtr);
                    std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__emplace_unique_key_args<std::string,std::string>((uint64_t)&OptionalWords(void)::optionalWords, (uint64_t)__p, (uint64_t)__p);
                    if (v16 < 0)
                      operator delete(__p[0]);
                  }
                }
              }
              CFRelease(v9);
            }
          }
          CFRelease(v5);
        }
      }
      CFRelease(v3);
    }
  }
}

BOOL isRelationWord(char *a1)
{
  unsigned __int8 v2;
  _BOOL8 v3;
  std::string __p;

  {
    RelationWords(void)::relationWords = 0u;
    unk_1EF1AE1C0 = 0u;
    dword_1EF1AE1D0 = 1065353216;
    __cxa_atexit((void (*)(void *))std::unordered_set<std::string>::~unordered_set[abi:nn180100], &RelationWords(void)::relationWords, &dword_1B8270000);
  }
  if (RelationWords(void)::onceToken != -1)
    dispatch_once(&RelationWords(void)::onceToken, &__block_literal_global_106);
  if (!qword_1EF1AE1C8)
    return 0;
  if (isLowerStr(a1))
    return std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(RelationWords(void)::relationWords, *((unint64_t *)&RelationWords(void)::relationWords + 1), (uint64_t)a1) != 0;
  toLowerCase(&__p, a1);
  v3 = std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(RelationWords(void)::relationWords, *((unint64_t *)&RelationWords(void)::relationWords + 1), (uint64_t)&__p) != 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  return v3;
}

void ___ZL13RelationWordsv_block_invoke()
{
  CFLocaleRef v0;
  CFLocaleRef v1;
  const __CFString *v2;
  uint64_t v3;
  std::string v4;
  _QWORD v5[3];
  _QWORD v6[3];
  _QWORD v7[3];
  _QWORD v8[3];
  _QWORD v9[3];
  _QWORD v10[3];
  _QWORD v11[3];
  _QWORD v12[3];
  _QWORD v13[3];
  _QWORD v14[3];
  _QWORD v15[3];
  _QWORD v16[3];
  _QWORD v17[3];
  _QWORD v18[3];
  _QWORD v19[3];
  _QWORD v20[3];
  _QWORD v21[3];
  _QWORD v22[3];
  _QWORD v23[3];
  _QWORD v24[3];
  _QWORD v25[3];
  _QWORD v26[3];
  _QWORD v27[3];
  _QWORD v28[3];
  _QWORD v29[3];
  _QWORD v30[3];
  _QWORD v31[3];
  _QWORD v32[3];
  _QWORD v33[3];
  _QWORD v34[3];
  _QWORD v35[3];
  _QWORD v36[3];
  _QWORD v37[3];
  _QWORD v38[3];
  _QWORD v39[3];
  _QWORD v40[3];
  _QWORD v41[3];
  _QWORD v42[3];
  _QWORD v43[3];
  _QWORD v44[3];
  _QWORD v45[3];
  _QWORD v46[3];
  _QWORD v47[3];
  _QWORD v48[3];
  _QWORD v49[3];
  _QWORD v50[3];
  std::string v51;

  v51.__r_.__value_.__r.__words[0] = *MEMORY[0x1E0C80C00];
  v0 = CFLocaleCopyCurrent();
  if (v0)
  {
    v1 = v0;
    v2 = (const __CFString *)MEMORY[0x1BCCAF7B0]();
    if (CFStringHasPrefix(v2, CFSTR("en")))
    {
      std::string::basic_string[abi:nn180100]<0>(&v4, "mother");
      std::string::basic_string[abi:nn180100]<0>(v5, "mothers");
      std::string::basic_string[abi:nn180100]<0>(v6, "mom");
      std::string::basic_string[abi:nn180100]<0>(v7, "moms");
      std::string::basic_string[abi:nn180100]<0>(v8, "mama");
      std::string::basic_string[abi:nn180100]<0>(v9, "mommy");
      std::string::basic_string[abi:nn180100]<0>(v10, "mommies");
      std::string::basic_string[abi:nn180100]<0>(v11, "mum");
      std::string::basic_string[abi:nn180100]<0>(v12, "father");
      std::string::basic_string[abi:nn180100]<0>(v13, "fathers");
      std::string::basic_string[abi:nn180100]<0>(v14, "dad");
      std::string::basic_string[abi:nn180100]<0>(v15, "dads");
      std::string::basic_string[abi:nn180100]<0>(v16, "papa");
      std::string::basic_string[abi:nn180100]<0>(v17, "daddy");
      std::string::basic_string[abi:nn180100]<0>(v18, "daddies");
      std::string::basic_string[abi:nn180100]<0>(v19, "brother");
      std::string::basic_string[abi:nn180100]<0>(v20, "brothers");
      std::string::basic_string[abi:nn180100]<0>(v21, "sister");
      std::string::basic_string[abi:nn180100]<0>(v22, "sisters");
      std::string::basic_string[abi:nn180100]<0>(v23, "sibling");
      std::string::basic_string[abi:nn180100]<0>(v24, "siblings");
      std::string::basic_string[abi:nn180100]<0>(v25, "parent");
      std::string::basic_string[abi:nn180100]<0>(v26, "parents");
      std::string::basic_string[abi:nn180100]<0>(v27, "family");
      std::string::basic_string[abi:nn180100]<0>(v28, "relatives");
      std::string::basic_string[abi:nn180100]<0>(v29, "kin");
      std::string::basic_string[abi:nn180100]<0>(v30, "friend");
      std::string::basic_string[abi:nn180100]<0>(v31, "friends");
      std::string::basic_string[abi:nn180100]<0>(v32, "partner");
      std::string::basic_string[abi:nn180100]<0>(v33, "partnersspouse");
      std::string::basic_string[abi:nn180100]<0>(v34, "spouses");
      std::string::basic_string[abi:nn180100]<0>(v35, "coworker");
      std::string::basic_string[abi:nn180100]<0>(v36, "coworkers");
      std::string::basic_string[abi:nn180100]<0>(v37, "colleague");
      std::string::basic_string[abi:nn180100]<0>(v38, "colleagues");
      std::string::basic_string[abi:nn180100]<0>(v39, "alumni");
      std::string::basic_string[abi:nn180100]<0>(v40, "alum");
      std::string::basic_string[abi:nn180100]<0>(v41, "child");
      std::string::basic_string[abi:nn180100]<0>(v42, "children");
      std::string::basic_string[abi:nn180100]<0>(v43, "baby");
      std::string::basic_string[abi:nn180100]<0>(v44, "babies");
      std::string::basic_string[abi:nn180100]<0>(v45, "kid");
      std::string::basic_string[abi:nn180100]<0>(v46, "kids");
      std::string::basic_string[abi:nn180100]<0>(v47, "son");
      std::string::basic_string[abi:nn180100]<0>(v48, "sons");
      std::string::basic_string[abi:nn180100]<0>(v49, "daughter");
      std::string::basic_string[abi:nn180100]<0>(v50, "daughters");
      std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__assign_unique<std::string const*>((uint64_t)&RelationWords(void)::relationWords, &v4, &v51);
      v3 = 1128;
      do
      {
        if (v4.__r_.__value_.__s.__data_[v3 - 1] < 0)
          operator delete(*(void **)((char *)&v4.__r_.__value_.__l + v3 - 24));
        v3 -= 24;
      }
      while (v3);
    }
    CFRelease(v1);
  }
}

BOOL isPhotosAttribute(uint64_t a1)
{
  unsigned __int8 v2;

  {
    PhotosAttributes(void)::_photosAttributes = 0u;
    unk_1EF1AD078 = 0u;
    dword_1EF1AD088 = 1065353216;
    __cxa_atexit((void (*)(void *))std::unordered_set<std::string>::~unordered_set[abi:nn180100], &PhotosAttributes(void)::_photosAttributes, &dword_1B8270000);
  }
  if (PhotosAttributes(void)::onceToken != -1)
    dispatch_once(&PhotosAttributes(void)::onceToken, &__block_literal_global_155);
  return std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::find<std::string>(PhotosAttributes(void)::_photosAttributes, *((unint64_t *)&PhotosAttributes(void)::_photosAttributes + 1), a1) != 0;
}

void ___ZL16PhotosAttributesv_block_invoke()
{
  uint64_t v0;
  std::string v1;
  _QWORD v2[3];
  _QWORD v3[3];
  _QWORD v4[3];
  _QWORD v5[3];
  _QWORD v6[3];
  _QWORD v7[3];
  _QWORD v8[3];
  _QWORD v9[3];
  _QWORD v10[3];
  _QWORD v11[3];
  _QWORD v12[3];
  _QWORD v13[3];
  _QWORD v14[3];
  _QWORD v15[3];
  std::string v16;

  v16.__r_.__value_.__r.__words[0] = *MEMORY[0x1E0C80C00];
  std::string::basic_string[abi:nn180100]<0>(&v1, "kMDItemPhotosBusinessCategories");
  std::string::basic_string[abi:nn180100]<0>(v2, "kMDItemPhotosBusinessNames");
  std::string::basic_string[abi:nn180100]<0>(v3, "kMDItemPhotosEventCategories");
  std::string::basic_string[abi:nn180100]<0>(v4, "kMDItemPhotosEventNames");
  std::string::basic_string[abi:nn180100]<0>(v5, "kMDItemPhotosEventPerformers");
  std::string::basic_string[abi:nn180100]<0>(v6, "kMDItemPhotosHolidays");
  std::string::basic_string[abi:nn180100]<0>(v7, "kMDItemPhotosKeywords");
  std::string::basic_string[abi:nn180100]<0>(v8, "kMDItemPhotosLocationKeywords");
  std::string::basic_string[abi:nn180100]<0>(v9, "kMDItemPhotosMeanings");
  std::string::basic_string[abi:nn180100]<0>(v10, "kMDItemPhotosMediaTypes");
  std::string::basic_string[abi:nn180100]<0>(v11, "kMDItemPhotosMemoryTitle");
  std::string::basic_string[abi:nn180100]<0>(v12, "kMDItemPhotosPeopleNames");
  std::string::basic_string[abi:nn180100]<0>(v13, "kMDItemPhotosSceneClassificationLabels");
  std::string::basic_string[abi:nn180100]<0>(v14, "kMDItemPhotosSceneClassificationSynonyms");
  std::string::basic_string[abi:nn180100]<0>(v15, "kMDItemPhotosSeasons");
  std::__hash_table<std::string,std::hash<std::string>,std::equal_to<std::string>,std::allocator<std::string>>::__assign_unique<std::string const*>((uint64_t)&PhotosAttributes(void)::_photosAttributes, &v1, &v16);
  v0 = 360;
  do
  {
    if (v1.__r_.__value_.__s.__data_[v0 - 1] < 0)
      operator delete(*(void **)((char *)&v1.__r_.__value_.__l + v0 - 24));
    v0 -= 24;
  }
  while (v0);
}

uint64_t is_tokenizable_searchable_string_field(const char *a1)
{
  uint64_t result;
  __int128 v2;
  uint64_t v3;
  __int128 v4;
  uint64_t v5;
  __int128 v6;
  uint64_t v7;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  result = gDefaultSchema;
  if (gDefaultSchema)
  {
    v6 = 0uLL;
    v7 = 0;
    _MDPlistContainerGetPlistObjectAtKeyArray();
    v8 = 0uLL;
    v9 = 0;
    v4 = 0uLL;
    v5 = 0;
    result = _MDPlistDictionaryGetPlistObjectForKey();
    if ((_DWORD)result)
    {
      v2 = v8;
      v3 = v9;
      result = attrsKeyValueMatchesString((uint64_t)&v2, (uint64_t)"type", 4, "CFString", 8);
      if ((_DWORD)result)
      {
        if ((attrsKeyValueEnabled() & 1) != 0 || (attrsKeyValueEnabled() & 1) != 0)
          return 0;
        else
          return attrsKeyValueEnabled() ^ 1;
      }
    }
  }
  return result;
}

void *CreateQueryTokens(const __CFString *a1, int a2)
{
  void *v4;
  const __CFAllocator *v5;
  const CFArrayCallBacks *v6;
  CFLocaleRef v7;
  _QWORD *v8;
  CFNumberRef v9;
  CFNumberRef v10;
  uint64_t v12;
  CFIndex Length;

  v4 = malloc_type_calloc(1uLL, 0x20uLL, 0x20040DC1BFBCFuLL);
  v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v6 = (const CFArrayCallBacks *)MEMORY[0x1E0C9B378];
  *(_QWORD *)v4 = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
  *((_QWORD *)v4 + 1) = CFArrayCreateMutable(v5, 0, v6);
  *((_QWORD *)v4 + 2) = CFArrayCreateMutable(v5, 0, v6);
  if (a2)
  {
    v7 = CFLocaleCopyCurrent();
    MEMORY[0x1BCCAF7B0]();
    v8 = CITokenizerCreate(3);
    *((_QWORD *)v4 + 3) = v8;
    CITokenizerGetQueryTokensWithOptions((uint64_t)v8);
    CFRelease(v7);
    CITokenizerDispose(v8);
    *((_QWORD *)v4 + 3) = 0;
  }
  else
  {
    v12 = 0;
    Length = CFStringGetLength(a1);
    v9 = CFNumberCreate(v5, kCFNumberCFIndexType, &v12);
    CFArrayAppendValue(*((CFMutableArrayRef *)v4 + 1), v9);
    CFRelease(v9);
    v10 = CFNumberCreate(v5, kCFNumberCFIndexType, &Length);
    CFArrayAppendValue(*((CFMutableArrayRef *)v4 + 2), v10);
    CFRelease(v10);
    CFArrayAppendValue(*(CFMutableArrayRef *)v4, a1);
  }
  return v4;
}

void QueryTokensCallback(unsigned __int16 *a1, uint64_t a2, void *a3)
{
  CFIndex v6;
  const __CFAllocator *v7;
  CFStringRef v8;
  CFNumberRef v9;
  CFNumberRef v10;
  CFIndex numBytes[2];
  UInt8 bytes[1044];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    bzero(bytes, 0x414uLL);
    numBytes[0] = 0;
    if (!utf8_encodestr(a1, 2 * a2, bytes, numBytes, 1043))
    {
      v6 = numBytes[0];
      if (numBytes[0])
      {
        bytes[numBytes[0]] = 0;
        v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        v8 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E0C9AE00], bytes, v6, 0x8000100u, 0);
        *(_OWORD *)numBytes = *(_OWORD *)(*((_QWORD *)a3 + 3) + 88);
        v9 = CFNumberCreate(v7, kCFNumberCFIndexType, numBytes);
        CFArrayAppendValue(*((CFMutableArrayRef *)a3 + 1), v9);
        CFRelease(v9);
        v10 = CFNumberCreate(v7, kCFNumberCFIndexType, &numBytes[1]);
        CFArrayAppendValue(*((CFMutableArrayRef *)a3 + 2), v10);
        CFRelease(v10);
        CFArrayAppendValue(*(CFMutableArrayRef *)a3, v8);
        CFRelease(v8);
      }
    }
  }
}

void freeQueryTokensContext(CFTypeRef *a1)
{
  if (a1)
  {
    CFRelease(*a1);
    CFRelease(a1[1]);
    CFRelease(a1[2]);
    free(a1);
  }
}

uint64_t getRangeAtIndex(const __CFArray *a1, const __CFArray *a2, CFIndex idx)
{
  const void *ValueAtIndex;
  CFTypeID v6;
  const void *v7;
  CFTypeID v8;
  uint64_t v10;
  uint64_t valuePtr;

  ValueAtIndex = CFArrayGetValueAtIndex(a1, idx);
  v6 = CFGetTypeID(ValueAtIndex);
  if (v6 != CFNumberGetTypeID())
    return -1;
  v7 = CFArrayGetValueAtIndex(a2, idx);
  v8 = CFGetTypeID(v7);
  if (v8 != CFNumberGetTypeID())
    return -1;
  valuePtr = 0;
  if (!CFNumberGetValue((CFNumberRef)ValueAtIndex, kCFNumberCFIndexType, &valuePtr))
    return -1;
  v10 = 0;
  if (CFNumberGetValue((CFNumberRef)v7, kCFNumberCFIndexType, &v10))
    return valuePtr;
  else
    return -1;
}

uint64_t store_stream_init(uint64_t a1, _DWORD *a2, char a3)
{
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t inited;
  uint64_t v11;

  v11 = 0;
  v6 = _fd_acquire_fd((uint64_t)a2, &v11);
  v7 = v6;
  v8 = v11;
  inited = store_stream_init_fd(a1, v6, v11, 0, a3);
  if ((inited & 1) != 0)
    *(_QWORD *)(a1 + 56) = a2;
  else
    _fd_release_fd(a2, v7, 0, v8);
  return inited;
}

void store_stream_destroy(uint64_t a1)
{
  void *v2;
  _DWORD *v3;

  v2 = *(void **)(a1 + 48);
  if (v2)
  {
    free(v2);
    *(_QWORD *)(a1 + 48) = 0;
    *(_QWORD *)(a1 + 32) = 0;
    if (*(_DWORD *)a1 != -1)
    {
      v3 = *(_DWORD **)(a1 + 56);
      if (v3)
      {
        _fd_release_fd(v3, *(_DWORD *)a1, 0, *(_QWORD *)(a1 + 8));
        *(_DWORD *)a1 = -1;
      }
    }
    *(_QWORD *)(a1 + 56) = 0;
  }
}

void work_fun_inner(char *a1)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  _QWORD *v5;
  int8x16_t v6;
  uint64_t v7;
  NSObject *v8;
  const char *v9;
  unsigned int v10;
  int v11;
  unint64_t v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  void (*v18)(_QWORD);
  _DWORD *v19;
  int v20;
  NSObject *v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int v24;
  uint64_t v25;
  void (*v26)(_QWORD);
  _BYTE *v27;
  uint64_t v28;
  uint64_t v29;
  NSObject *v30;
  uint64_t v31;
  unsigned int *v32;
  unsigned int v33;
  NSObject *v34;
  NSObject *v35;
  int v36;
  NSObject *v37;
  int v38;
  NSObject *v39;
  qos_class_t v40;
  dispatch_queue_t current_queue;
  char *v42;
  char *v43;
  const char *v44;
  uint64_t v45;
  NSObject *v46;
  NSObject *v47;
  uint64_t v48;
  _QWORD v49[5];
  _QWORD v50[5];
  _QWORD v51[9];
  unint64_t v52;
  unsigned int v53;
  unsigned int v54;
  unint64_t v55;
  unsigned int v56;
  unsigned int v57;
  _QWORD block[9];
  _BYTE buf[12];
  __int16 v60;
  int v61;
  uint8_t v62[8];
  __int128 v63;
  char v64;
  uint64_t v65;

  v65 = *MEMORY[0x1E0C80C00];
  if (dword_1EF19FCC0 >= 5)
  {
    v36 = *__error();
    v37 = _SILogForLogForCategory(13);
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)v62 = 67109376;
      *(_DWORD *)&v62[4] = qos_class_self();
      LOWORD(v63) = 2048;
      *(_QWORD *)((char *)&v63 + 2) = a1;
      _os_log_impl(&dword_1B8270000, v37, OS_LOG_TYPE_DEFAULT, "QOS work_fun: %d %p", v62, 0x12u);
    }
    *__error() = v36;
  }
  if (dword_1EF19FC98 >= 5)
  {
    v38 = *__error();
    v39 = _SILogForLogForCategory(3);
    if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
    {
      v40 = qos_class_self();
      current_queue = dispatch_get_current_queue();
      *(_DWORD *)v62 = 67109378;
      *(_DWORD *)&v62[4] = v40;
      LOWORD(v63) = 2112;
      *(_QWORD *)((char *)&v63 + 2) = current_queue;
      _os_log_impl(&dword_1B8270000, v39, OS_LOG_TYPE_DEFAULT, "qos: 0x%x %@", v62, 0x12u);
    }
    *__error() = v38;
  }
  v2 = *(_QWORD *)a1;
  v3 = (_QWORD *)*((_QWORD *)a1 + 1);
  v4 = *(_QWORD *)a1;
  v5 = (_QWORD *)*((_QWORD *)a1 + 2);
  *(_QWORD *)v62 = 0;
  *(_QWORD *)&v63 = v62;
  *((_QWORD *)&v63 + 1) = 0x2000000000;
  v64 = 0;
  v6 = veorq_s8(*(int8x16_t *)(a1 + 24), *(int8x16_t *)(a1 + 40));
  if (*((_QWORD *)a1 + 7) != veor_s8(*(int8x8_t *)v6.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v6, v6, 8uLL)))
  {
    v42 = __si_assert_copy_extra_521(*((_DWORD *)v5 + 10));
    v43 = v42;
    v44 = "";
    if (v42)
      v44 = v42;
    __message_assert("%s:%u: failed assertion '%s' %s Bad CRC on work unit. %p %p %p %p %p %p", "SIScheduler.c", 223, "cu->u.crc==compute_workunit_crc(cu->u)", v44, (const void *)v4, v3, v5, *((const void **)a1 + 4), *((const void **)a1 + 5), *((const void **)a1 + 3));
    free(v43);
    if (__valid_fs(*((_DWORD *)v5 + 10)))
      v45 = 2989;
    else
      v45 = 3072;
    *(_DWORD *)v45 = -559038737;
    abort();
  }
  v48 = v2;
  makeThreadId();
  if (v3 && v3 == (_QWORD *)*v5)
  {
    v7 = *v3;
    v8 = v3[4];
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __work_fun_inner_block_invoke;
    block[3] = &unk_1E6E2EA28;
    block[4] = v62;
    block[5] = v3;
    block[6] = v5;
    block[7] = v7;
    block[8] = v4;
    dispatch_sync(v8, block);
  }
  else
  {
    *(_BYTE *)(v63 + 24) = 0;
  }
  v9 = (const char *)v5[6];
  if (v9)
    set_crash_info(v9);
  do
  {
    v10 = __ldxr(exceptionSequenceNum);
    v11 = v10 + 1;
  }
  while (__stxr(v10 + 1, exceptionSequenceNum));
  v12 = setThreadIdAndInfo(*((_DWORD *)v5 + 10), sFdExceptionCallbacks, 0, 1, v11);
  v56 = HIDWORD(v12);
  v57 = v12;
  v55 = __PAIR64__(v13, v14);
  v15 = *(_QWORD *)&threadData[18 * v12 + 2];
  v16 = v15 + 320 * HIDWORD(v12);
  *(_BYTE *)(v16 + 216) = 0;
  v17 = *(_DWORD *)(v16 + 312);
  v18 = *(void (**)(_QWORD))(v16 + 224);
  if (v18)
    v18(*(_QWORD *)(v15 + 320 * HIDWORD(v12) + 288));
  v54 = v57;
  v53 = v56;
  v52 = v55;
  if (_setjmp((int *)v16))
  {
    v19 = (_DWORD *)(v16 + 312);
    v20 = *__error();
    v21 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "work_fun_inner";
      v60 = 1024;
      v61 = 257;
      _os_log_error_impl(&dword_1B8270000, v21, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
    }
    *__error() = v20;
    *v19 = v17;
    CIOnThreadCleanUpReset(v52);
    dropThreadId(v54, 1, v11);
    CICleanUpReset(v54, HIDWORD(v52));
  }
  else
  {
    if (!*(_BYTE *)(v63 + 24) || (v22 = *((_QWORD *)a1 + 5)) != 0 && *(_DWORD *)(v22 + 36))
      (*((void (**)(_QWORD, uint64_t))a1 + 3))(*((_QWORD *)a1 + 4), 1);
    else
      (*(void (**)(uint64_t, _QWORD, _QWORD))(v4 + 128))(v4, *((_QWORD *)a1 + 3), *((_QWORD *)a1 + 4));
    v23 = *(_QWORD *)&threadData[18 * v54 + 2];
    v24 = v53;
    v25 = v23 + 320 * v53;
    *(_DWORD *)(v25 + 312) = v17;
    v26 = *(void (**)(_QWORD))(v25 + 232);
    if (v26)
      v26(*(_QWORD *)(v23 + 320 * v24 + 288));
    dropThreadId(v54, 0, v11);
  }
  v27 = pthread_getspecific(__THREAD_STR_DATA_KEY);
  if (v27)
    *v27 = 0;
  v28 = *((_QWORD *)a1 + 5);
  if (v28)
    si_release_qid(v28);
  if (v3)
  {
    v29 = MEMORY[0x1E0C809B0];
    v51[2] = __work_fun_inner_block_invoke_49;
    v51[3] = &unk_1E6E2EA50;
    v51[4] = v62;
    v51[5] = v5;
    v30 = *(NSObject **)(v4 + 32);
    v51[0] = MEMORY[0x1E0C809B0];
    v51[1] = 0x40000000;
    v51[6] = v3;
    v51[7] = v4;
    v51[8] = 0;
    dispatch_sync(v30, v51);
    *(_QWORD *)buf = 0;
    v31 = 0;
    if ((_QWORD *)*v5 == v3)
    {
      if (*((_DWORD *)v3 + 29) == 1
        && *((unsigned __int8 *)v3 + 72) < *((_DWORD *)v3 + 42)
        && (*((_DWORD *)v3 + 26) || v3[15]))
      {
        pthread_mutex_lock((pthread_mutex_t *)v3[1]);
        *((_DWORD *)v3 + 42) = 0;
        si_scheduler_do_suspend((uint64_t)v3, buf);
        pthread_mutex_unlock((pthread_mutex_t *)v3[1]);
        v46 = v5[2];
        dispatch_retain(v46);
        dispatch_suspend(v46);
        v47 = v3[17];
        v50[0] = v29;
        v50[1] = 0x40000000;
        v50[2] = __work_fun_inner_block_invoke_2;
        v50[3] = &__block_descriptor_tmp_51;
        v50[4] = v46;
        dispatch_async(v47, v50);
        v31 = *(_QWORD *)buf;
      }
      else
      {
        v31 = 0;
      }
    }
    si_scheduler_trigger_tokens(v31);
  }
  else if (!v4)
  {
    goto LABEL_40;
  }
  v32 = (unsigned int *)(v48 + 112);
  do
    v33 = __ldxr(v32);
  while (__stxr(v33 - 1, v32));
LABEL_40:
  if (a1[64])
  {
    v34 = v5[2];
    dispatch_suspend(v34);
    v35 = *(NSObject **)(v4 + 136);
    v49[0] = MEMORY[0x1E0C809B0];
    v49[1] = 0x40000000;
    v49[2] = __work_fun_inner_block_invoke_3;
    v49[3] = &__block_descriptor_tmp_52;
    v49[4] = v34;
    dispatch_async(v35, v49);
  }
  free(a1);
  _Block_object_dispose(v62, 8);
}

_QWORD *__work_fun_inner_block_invoke(_QWORD *result)
{
  uint64_t v1;
  BOOL v2;
  uint64_t v3;

  v1 = result[5];
  v2 = !*(_DWORD *)(v1 + 88) && !*(_BYTE *)(v1 + 48) && *(_DWORD *)(result[6] + 36) == 0;
  *(_BYTE *)(*(_QWORD *)(result[4] + 8) + 24) = v2;
  if (*(_BYTE *)(*(_QWORD *)(result[4] + 8) + 24))
  {
    ++*(_DWORD *)(v1 + 96);
    v3 = result[7];
    if (v3)
      *(_QWORD *)(v3 + 24) = v1;
    ++*(_DWORD *)(result[8] + 96);
  }
  return result;
}

void __work_fun_inner_block_invoke_49(_QWORD *a1)
{
  _QWORD *v1;
  uint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;

  v1 = (_QWORD *)a1[5];
  --v1[8];
  if (*(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24))
  {
    v3 = a1[6];
    if (v3 == *v1)
    {
      v4 = *(_DWORD *)(v3 + 96) - 1;
      *(_DWORD *)(v3 + 96) = v4;
      if (!v4)
      {
        v5 = *(_QWORD *)(v3 + 40);
        if (v5)
        {
          (*(void (**)(void))(v5 + 16))();
          _Block_release(*(const void **)(a1[6] + 40));
          *(_QWORD *)(a1[6] + 40) = 0;
        }
      }
    }
    v6 = a1[7];
    v7 = a1[8];
    v8 = *(_DWORD *)(v6 + 96) - 1;
    *(_DWORD *)(v6 + 96) = v8;
    if (v7)
    {
      *(_QWORD *)(v7 + 24) = 0;
      v6 = a1[7];
      v8 = *(_DWORD *)(v6 + 96);
    }
    if (!v8)
    {
      v9 = *(_QWORD *)(v6 + 40);
      if (v9)
      {
        (*(void (**)(void))(v9 + 16))();
        _Block_release(*(const void **)(a1[7] + 40));
        *(_QWORD *)(a1[7] + 40) = 0;
      }
    }
  }
}

void __work_fun_inner_block_invoke_2(uint64_t a1)
{
  dispatch_resume(*(dispatch_object_t *)(a1 + 32));
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
}

void __work_fun_inner_block_invoke_3(uint64_t a1)
{
  dispatch_resume(*(dispatch_object_t *)(a1 + 32));
}

void si_enqueue_barrier(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_BYTE *)(a1 + 32))
    si_enqueue_barrier_with_qos(a1, *(unsigned __int8 *)(a1 + 24), a2, a3);
  else
    si_enqueue_barrier_for_job(a1, a2, a3, 0);
}

uint64_t __enqueue_barrier_block_invoke(uint64_t a1)
{
  return work_fun(*(_QWORD *)(a1 + 32));
}

void __enqueue_work_block_invoke(uint64_t a1)
{
  work_fun(*(char **)(a1 + 32));
}

void si_enqueue_block(uint64_t a1, void *aBlock)
{
  int v3;
  void *v4;
  void *v5;

  if (*(_BYTE *)(a1 + 32))
  {
    v3 = *(unsigned __int8 *)(a1 + 24);
    v4 = _Block_copy(aBlock);
    si_enqueue_work_with_qos(a1, v3, (uint64_t)_si_run_block, (uint64_t)v4);
  }
  else
  {
    v5 = _Block_copy(aBlock);
    si_enqueue_work_for_job(a1, (uint64_t)_si_run_block, (uint64_t)v5, 0);
  }
}

void _si_run_block(void (**a1)(void))
{
  a1[2]();
  _Block_release(a1);
}

void si_enqueue_cleanup_if_busy(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  _QWORD *v3;
  NSObject *v4;
  _QWORD block[7];

  v2 = *(_QWORD **)a1;
  if (*(_QWORD *)a1)
  {
    do
    {
      v3 = v2;
      v2 = (_QWORD *)*v2;
    }
    while (v2);
  }
  else
  {
    v3 = 0;
  }
  v4 = *(NSObject **)(a1 + 8);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __si_enqueue_cleanup_if_busy_block_invoke;
  block[3] = &__block_descriptor_tmp_5;
  block[4] = a2;
  block[5] = a1;
  block[6] = v3;
  dispatch_sync(v4, block);
}

void __si_enqueue_cleanup_if_busy_block_invoke(_QWORD *a1)
{
  unsigned int *v2;
  unsigned int v3;
  _QWORD *v4;

  v2 = (unsigned int *)a1[4];
  do
    v3 = __ldaxr(v2);
  while (__stlxr(v3 + 1, v2));
  v4 = malloc_type_malloc(0x20uLL, 0x20040DC1BFBCFuLL);
  v4[1] = a1[5];
  v4[2] = *(_QWORD *)a1[5];
  v4[3] = a1[6];
  *v4 = a1[4];
  dispatch_barrier_async_f(*(dispatch_queue_t *)(a1[5] + 16), v4, (dispatch_function_t)si_collect);
}

void si_collect(void **a1)
{
  si_collect_inner(a1);
  free(a1);
}

void si_collect_inner(void **a1)
{
  unsigned int *v2;
  unsigned int v3;
  unsigned int v4;
  _BOOL4 v5;
  _QWORD *v6;
  _QWORD *v7;
  void *v8;
  uint64_t v9;
  NSObject *v10;
  _BOOL8 v11;
  void *v12;
  NSObject *v13;
  int v14;
  NSObject *v15;
  void *v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  char v20;
  __int128 block;
  void *v22;
  void *v23;
  int8x16_t v24;
  _QWORD *v25;
  uint64_t v26;
  void *v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v2 = (unsigned int *)*a1;
  do
  {
    v3 = __ldaxr(v2);
    v4 = v3 - 1;
  }
  while (__stlxr(v4, v2));
  if (!v4)
  {
    v5 = 0;
    v7 = a1[1];
    v6 = a1[2];
    v8 = a1[3];
    v17 = 0;
    v18 = &v17;
    v19 = 0x2000000000;
    v20 = 0;
    if (v6 && v7)
    {
      if (v6 == (_QWORD *)*v7)
      {
        v9 = *v6;
        v10 = v6[4];
        *(_QWORD *)&block = MEMORY[0x1E0C809B0];
        *((_QWORD *)&block + 1) = 0x40000000;
        v22 = __preRun_block_invoke;
        v23 = &unk_1E6E2EB38;
        v24.i64[0] = (uint64_t)&v17;
        v24.i64[1] = (uint64_t)a1;
        v25 = v6;
        v26 = v9;
        v27 = v8;
        dispatch_sync(v10, &block);
        v5 = *((_BYTE *)v18 + 24) != 0;
      }
      else
      {
        v5 = 0;
      }
    }
    _Block_object_dispose(&v17, 8);
    v11 = !v5;
    (*((void (**)(_QWORD, _QWORD, _QWORD, _BOOL8))*a1 + 4))(*((_QWORD *)*a1 + 1), *((_QWORD *)*a1 + 2), *((_QWORD *)*a1 + 3), v11);
    if (!v11)
    {
      v12 = a1[3];
      v13 = *((_QWORD *)v12 + 4);
      *(_QWORD *)&block = MEMORY[0x1E0C809B0];
      *((_QWORD *)&block + 1) = 0x40000000;
      v22 = __postRun_block_invoke;
      v23 = &__block_descriptor_tmp_72_966;
      v24 = vextq_s8(*(int8x16_t *)(a1 + 1), *(int8x16_t *)(a1 + 1), 8uLL);
      v25 = v12;
      dispatch_sync(v13, &block);
    }
    if (gSILogLevels[0] >= 5)
    {
      v14 = *__error();
      v15 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        v16 = *a1;
        LODWORD(block) = 134217984;
        *(_QWORD *)((char *)&block + 4) = v16;
        _os_log_impl(&dword_1B8270000, v15, OS_LOG_TYPE_DEFAULT, "Freeing %p", (uint8_t *)&block, 0xCu);
      }
      *__error() = v14;
    }
    free(*a1);
  }
}

_QWORD *__preRun_block_invoke(_QWORD *result)
{
  uint64_t v1;
  uint64_t v2;
  BOOL v3;
  uint64_t v4;
  uint64_t v5;

  v1 = result[5];
  v2 = *(_QWORD *)(v1 + 16);
  v3 = !*(_DWORD *)(v2 + 88) && !*(_BYTE *)(v2 + 48) && *(_DWORD *)(*(_QWORD *)(v1 + 8) + 36) == 0;
  *(_BYTE *)(*(_QWORD *)(result[4] + 8) + 24) = v3;
  if (*(_BYTE *)(*(_QWORD *)(result[4] + 8) + 24))
  {
    v4 = result[6];
    v5 = result[7];
    ++*(_DWORD *)(v4 + 96);
    if (v5)
      *(_QWORD *)(v5 + 24) = v4;
    ++*(_DWORD *)(result[8] + 96);
  }
  return result;
}

void __postRun_block_invoke(uint64_t a1)
{
  uint64_t *v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;

  v2 = *(uint64_t **)(a1 + 32);
  if (v2)
    v3 = *v2;
  else
    v3 = 0;
  if (v2 == **(uint64_t ***)(a1 + 40))
  {
    v4 = *((_DWORD *)v2 + 24) - 1;
    *((_DWORD *)v2 + 24) = v4;
    if (!v4)
    {
      v5 = v2[5];
      if (v5)
      {
        (*(void (**)(void))(v5 + 16))();
        _Block_release(*(const void **)(*(_QWORD *)(a1 + 32) + 40));
        *(_QWORD *)(*(_QWORD *)(a1 + 32) + 40) = 0;
      }
    }
  }
  v6 = *(_QWORD *)(a1 + 48);
  v7 = *(_DWORD *)(v6 + 96) - 1;
  *(_DWORD *)(v6 + 96) = v7;
  if (v3)
  {
    *(_QWORD *)(v3 + 24) = 0;
    v6 = *(_QWORD *)(a1 + 48);
    v7 = *(_DWORD *)(v6 + 96);
  }
  if (!v7)
  {
    v8 = *(_QWORD *)(v6 + 40);
    if (v8)
    {
      (*(void (**)(void))(v8 + 16))();
      _Block_release(*(const void **)(*(_QWORD *)(a1 + 48) + 40));
      *(_QWORD *)(*(_QWORD *)(a1 + 48) + 40) = 0;
    }
  }
}

void si_workqueue_drain(uint64_t a1)
{
  uint64_t v2;
  dispatch_block_t v3;

  v2 = *(_QWORD *)a1;
  if (v2)
    si_scheduler_remove_workqueue(v2, (_QWORD *)a1);
  v3 = dispatch_block_create_with_qos_class(DISPATCH_BLOCK_ENFORCE_QOS_CLASS, QOS_CLASS_UTILITY, 0, &__block_literal_global_974);
  dispatch_async(*(dispatch_queue_t *)(a1 + 16), v3);
  _Block_release(v3);
}

void si_scheduler_remove_workqueue(uint64_t a1, _QWORD *a2)
{
  NSObject *v3;
  _QWORD block[5];

  if (*a2 == a1)
  {
    v3 = *(NSObject **)(a1 + 32);
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 0x40000000;
    block[2] = __si_scheduler_remove_workqueue_block_invoke;
    block[3] = &__block_descriptor_tmp_13_976;
    block[4] = a1;
    dispatch_sync(v3, block);
    *a2 = 0;
  }
}

uint64_t __si_scheduler_remove_workqueue_block_invoke(uint64_t result)
{
  unsigned int *v1;
  unsigned int v2;

  v1 = (unsigned int *)(*(_QWORD *)(result + 32) + 84);
  do
    v2 = __ldaxr(v1);
  while (__stlxr(v2 - 1, v1));
  return result;
}

void si_scheduler_drain_locked(uint64_t a1, dispatch_group_t group)
{
  int *v4;
  unsigned int *v5;
  unsigned int v6;
  NSObject *v7;
  _QWORD v8[6];

  if (a1)
  {
    v4 = *(int **)a1;
    if (v4)
      si_scheduler_remove_scheduler(v4, (int **)a1);
    v5 = (unsigned int *)(a1 + 80);
    do
      v6 = __ldaxr(v5);
    while (__stlxr(v6 + 1, v5));
    if (group)
    {
      dispatch_group_enter(group);
      dispatch_retain(group);
    }
    v7 = *(NSObject **)(a1 + 136);
    v8[0] = MEMORY[0x1E0C809B0];
    v8[1] = 0x40000000;
    v8[2] = __si_scheduler_drain_locked_block_invoke;
    v8[3] = &__block_descriptor_tmp_7;
    v8[4] = a1;
    v8[5] = group;
    dispatch_barrier_async(v7, v8);
  }
}

int *si_scheduler_remove_scheduler(int *result, int **a2)
{
  int *v3;
  unsigned int *v4;
  unsigned int v5;
  unsigned int *v6;
  unsigned int v7;
  unsigned int v8;
  int v9;
  NSObject *v10;
  int *v11;
  uint64_t v12;
  char *v13;
  char *v14;
  const char *v15;
  uint64_t v16;
  uint8_t buf[4];
  int *v18;
  __int16 v19;
  uint64_t v20;
  uint64_t v21;

  v3 = result;
  v21 = *MEMORY[0x1E0C80C00];
  if (dword_1EF19FC98 >= 5)
  {
    v9 = *__error();
    v10 = _SILogForLogForCategory(3);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      v11 = a2[8];
      v12 = *((_QWORD *)v3 + 8);
      *(_DWORD *)buf = 136315394;
      v18 = v11;
      v19 = 2080;
      v20 = v12;
      _os_log_impl(&dword_1B8270000, v10, OS_LOG_TYPE_DEFAULT, "Remove scheduler %s from %s", buf, 0x16u);
    }
    result = __error();
    *result = v9;
  }
  if (*a2 != v3)
  {
    v13 = __si_assert_copy_extra_521(-1);
    v14 = v13;
    v15 = "";
    if (v13)
      v15 = v13;
    __message_assert("%s:%u: failed assertion '%s' %s ", "SIScheduler.c", 895, "child->parent==scheduler", v15);
    free(v14);
    if (__valid_fs(-1))
      v16 = 2989;
    else
      v16 = 3072;
    *(_DWORD *)v16 = -559038737;
    abort();
  }
  v4 = (unsigned int *)(v3 + 21);
  do
    v5 = __ldaxr(v4);
  while (__stlxr(v5 - 1, v4));
  *a2 = 0;
  a2[1] = 0;
  v6 = (unsigned int *)(v3 + 20);
  a2[2] = 0;
  do
  {
    v7 = __ldaxr(v6);
    v8 = v7 - 1;
  }
  while (__stlxr(v8, v6));
  if (!v8)
    return (int *)_si_scheduler_destroy(v3);
  return result;
}

void __si_scheduler_drain_locked_block_invoke(uint64_t a1)
{
  uint64_t v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;
  NSObject *v6;

  v2 = *(_QWORD *)(a1 + 32);
  if (v2)
  {
    v3 = (unsigned int *)(v2 + 80);
    do
    {
      v4 = __ldaxr(v3);
      v5 = v4 - 1;
    }
    while (__stlxr(v5, v3));
    if (!v5)
      _si_scheduler_destroy(v2);
  }
  v6 = *(NSObject **)(a1 + 40);
  if (v6)
  {
    dispatch_group_leave(v6);
    dispatch_release(*(dispatch_object_t *)(a1 + 40));
  }
}

void _si_scheduler_destroy(uint64_t a1)
{
  int *v2;
  pthread_mutex_t *v3;
  pthread_cond_t *v4;
  uint64_t v5;
  uint64_t v6;

  v2 = *(int **)a1;
  if (v2)
    si_scheduler_remove_scheduler(v2, (int **)a1);
  free(*(void **)(a1 + 64));
  dispatch_activate(*(dispatch_object_t *)(a1 + 136));
  dispatch_release(*(dispatch_object_t *)(a1 + 136));
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
  if (*(_BYTE *)(a1 + 49))
  {
    v3 = *(pthread_mutex_t **)(a1 + 8);
    if (v3)
    {
      pthread_mutex_destroy(v3);
      free(*(void **)(a1 + 8));
    }
    v4 = *(pthread_cond_t **)(a1 + 16);
    if (v4)
    {
      pthread_cond_destroy(v4);
      free(*(void **)(a1 + 16));
    }
  }
  v5 = *(_QWORD *)(a1 + 120);
  if (v5)
  {
    do
    {
      *(_BYTE *)(v5 + 4) = 0;
      v6 = *(_QWORD *)(v5 + 16);
      *(_QWORD *)(v5 + 8) = 0;
      release_token((unsigned int *)v5);
      v5 = v6;
    }
    while (v6);
  }
  free((void *)a1);
}

void __si_scheduler_drain_block_invoke(uint64_t a1)
{
  si_scheduler_drain_locked(*(_QWORD *)(a1 + 32), *(dispatch_group_t *)(a1 + 40));
}

uint64_t __si_scheduler_remove_and_destroy_block_invoke(uint64_t result)
{
  unsigned int *v1;
  unsigned int v2;

  v1 = (unsigned int *)(*(_QWORD *)(result + 32) + 84);
  do
    v2 = __ldaxr(v1);
  while (__stlxr(v2 - 1, v1));
  return result;
}

void __si_scheduler_remove_and_destroy_block_invoke_2(uint64_t a1)
{
  _QWORD *v2;

  v2 = *(_QWORD **)(a1 + 32);
  if (*v2 == *(_QWORD *)(a1 + 40))
  {
    *v2 = 0;
    si_workqueue_destroy(*(_QWORD *)(a1 + 32));
  }
  else
  {
    si_workqueue_destroy((uint64_t)v2);
  }
}

void si_workqueue_destroy(uint64_t a1)
{
  const void *v2;

  if (a1)
  {
    v2 = *(const void **)(a1 + 72);
    if (v2)
      CFRelease(v2);
    dispatch_barrier_async(*(dispatch_queue_t *)(a1 + 16), &__block_literal_global_33_994);
    dispatch_release(*(dispatch_object_t *)(a1 + 16));
    dispatch_assert_queue_not_V2(*(dispatch_queue_t *)(a1 + 8));
    dispatch_barrier_sync(*(dispatch_queue_t *)(a1 + 8), &__block_literal_global_35);
    dispatch_release(*(dispatch_object_t *)(a1 + 8));
    free(*(void **)(a1 + 48));
    free((void *)a1);
  }
}

_DWORD *si_create_scheduler(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  NSObject *v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  char *v10;
  char *v11;
  NSObject *v12;
  _DWORD *v13;
  NSObject *initially_inactive;
  NSObject *v15;
  NSObject *AttrFromPolicy;
  NSObject *v17;
  int v18;
  NSObject *v19;
  os_log_type_t v20;
  uint64_t v21;
  uint64_t v22;
  uint8_t buf[4];
  int v25;
  __int16 v26;
  unsigned int v27;
  __int16 v28;
  uint64_t v29;
  __int16 v30;
  uint64_t v31;
  char __str[4096];
  uint64_t v33;

  v1 = MEMORY[0x1E0C80A78](a1);
  v3 = v2;
  v5 = v4;
  v7 = v6;
  v9 = v8;
  v11 = v10;
  v12 = v1;
  v33 = *MEMORY[0x1E0C80C00];
  v13 = malloc_type_calloc(1uLL, 0xC0uLL, 0x10B0040A868EC2DuLL);
  v13[29] = v9;
  bzero(__str, 0x1000uLL);
  snprintf(__str, 0x1000uLL, "MQ: %s", v11);
  *((_BYTE *)v13 + 50) = v5;
  if (v12)
    initially_inactive = dispatch_queue_attr_make_initially_inactive(0);
  else
    initially_inactive = makeAttrFromPolicy(v7, v5, 0);
  *((_QWORD *)v13 + 4) = dispatch_queue_create_with_target_V2(__str, initially_inactive, v12);
  if (!v3)
  {
    AttrFromPolicy = makeAttrFromPolicy(v7, v5, v9 > 1);
    *((_QWORD *)v13 + 17) = dispatch_queue_create_with_target_V2(v11, AttrFromPolicy, 0);
    *((_QWORD *)v13 + 9) = v7;
    if (v9 < 2)
      goto LABEL_10;
    goto LABEL_8;
  }
  if (v9 >= 2)
  {
    v15 = dispatch_queue_attr_make_initially_inactive(MEMORY[0x1E0C80D50]);
    *((_QWORD *)v13 + 17) = dispatch_queue_create_with_target_V2(v11, v15, v3);
    *((_QWORD *)v13 + 9) = v7;
LABEL_8:
    dispatch_queue_set_width();
    goto LABEL_10;
  }
  v17 = dispatch_queue_attr_make_initially_inactive(0);
  *((_QWORD *)v13 + 17) = dispatch_queue_create_with_target_V2(v11, v17, v3);
  *((_QWORD *)v13 + 9) = v7;
LABEL_10:
  *((_QWORD *)v13 + 8) = strdup(v11);
  atomic_store(1u, v13 + 20);
  v13[47] = si_pc_priority_from_string(v11);
  v18 = *__error();
  v19 = _SILogForLogForCategory(3);
  v20 = 2 * (dword_1EF19FC98 < 4);
  if (os_log_type_enabled(v19, v20))
  {
    v21 = *((_QWORD *)v13 + 4);
    v22 = *((_QWORD *)v13 + 17);
    *(_DWORD *)buf = 67109890;
    v25 = v7;
    v26 = 1024;
    v27 = (v7 >> 8) & 0xF;
    v28 = 2112;
    v29 = v21;
    v30 = 2112;
    v31 = v22;
    _os_log_impl(&dword_1B8270000, v19, v20, "Scheduler qos: 0x%x relative_priority: %d %@ %@", buf, 0x22u);
  }
  *__error() = v18;
  return v13;
}

void __si_create_child_scheduler_block_invoke(uint64_t a1)
{
  unsigned int v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  int v7;
  NSObject *v8;
  os_log_type_t v9;
  unsigned int v10;
  _DWORD v11[2];
  __int16 v12;
  unsigned int v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v2 = atomic_load((unsigned int *)(*(_QWORD *)(a1 + 32) + 84));
  v3 = (unsigned int *)(*(_QWORD *)(a1 + 32) + 84);
  do
    v4 = __ldaxr(v3);
  while (__stlxr(v4 + 1, v3));
  **(_QWORD **)(a1 + 40) = *(_QWORD *)(a1 + 32);
  dispatch_activate(*(dispatch_object_t *)(*(_QWORD *)(a1 + 40) + 136));
  v5 = v2 + 1;
  v6 = atomic_load((unsigned int *)(*(_QWORD *)(a1 + 32) + 84));
  if (v2 + 1 != v6)
  {
    v7 = *__error();
    v8 = _SILogForLogForCategory(3);
    v9 = 2 * (dword_1EF19FC98 < 4);
    if (os_log_type_enabled(v8, v9))
    {
      v10 = atomic_load((unsigned int *)(*(_QWORD *)(a1 + 32) + 84));
      v11[0] = 67109376;
      v11[1] = v5;
      v12 = 1024;
      v13 = v10;
      _os_log_impl(&dword_1B8270000, v8, v9, "%d != %d\n", (uint8_t *)v11, 0xEu);
    }
    *__error() = v7;
  }
}

dispatch_queue_attr_t makeAttrFromPolicy(unsigned int a1, int a2, int a3)
{
  NSObject *v5;
  dispatch_queue_attr_t result;
  NSObject *v7;

  if (a3)
    v5 = MEMORY[0x1E0C80D50];
  else
    v5 = 0;
  result = dispatch_queue_attr_make_initially_inactive(v5);
  if (a2)
  {
    if ((_BYTE)a1)
    {
      v7 = dispatch_queue_attr_make_with_overcommit();
      return dispatch_queue_attr_make_with_qos_class(v7, (dispatch_qos_class_t)a1, -((a1 >> 8) & 0xF));
    }
  }
  return result;
}

uint64_t si_pc_priority_from_string(char *a1)
{
  if (strstr(a1, "Priority/"))
    return 7;
  if (strstr(a1, "NSFileProtectionComplete/"))
    return 2;
  if (strstr(a1, "NSFileProtectionCompleteUnlessOpen/"))
    return 4;
  if (strstr(a1, "NSFileProtectionCompleteWhenUserInactive/"))
    return 14;
  if (strstr(a1, "NSFileProtectionCompleteUntilFirstUserAuthentication/"))
    return 6;
  return 4294967294;
}

void *si_create_child_queue(uint64_t a1)
{
  uint64_t v1;
  char v2;
  char v3;
  uint64_t v4;
  void *v5;
  NSObject *v6;
  NSObject *initially_inactive;
  int v8;
  NSObject *v9;
  os_log_type_t v10;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  _QWORD block[7];
  uint8_t buf[4];
  int v19;
  __int16 v20;
  int v21;
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  uint64_t v25;
  char __str[4096];
  uint64_t v27;

  v1 = MEMORY[0x1E0C80A78](a1);
  v3 = v2;
  v4 = v1;
  v27 = *MEMORY[0x1E0C80C00];
  bzero(__str, 0x1000uLL);
  v5 = malloc_type_malloc(0x50uLL, 0x103004026821411uLL);
  *(_OWORD *)v5 = 0u;
  *((_OWORD *)v5 + 1) = 0u;
  *((_OWORD *)v5 + 2) = 0u;
  *((_OWORD *)v5 + 3) = 0u;
  *((_OWORD *)v5 + 4) = 0u;
  *((_DWORD *)v5 + 10) = -1;
  *((_QWORD *)v5 + 3) = *(_QWORD *)(v4 + 72);
  *((_BYTE *)v5 + 32) = *(_BYTE *)(v4 + 50);
  *((_BYTE *)v5 + 33) = (v3 & 0x10) != 0;
  snprintf(__str, 0x1000uLL, "com.apple.metadata.spotlightindex.mq.%s", *(const char **)(v4 + 64));
  *((_QWORD *)v5 + 1) = dispatch_queue_create_with_target_V2(__str, 0, *(dispatch_queue_t *)(v4 + 32));
  if (*(_DWORD *)(v4 + 116) < 2u)
    v6 = 0;
  else
    v6 = MEMORY[0x1E0C80D50];
  initially_inactive = dispatch_queue_attr_make_initially_inactive(v6);
  snprintf(__str, 0x1000uLL, "com.apple.metadata.spotlightindex.%s", *(const char **)(v4 + 64));
  *((_QWORD *)v5 + 2) = dispatch_queue_create_with_target_V2(__str, initially_inactive, *(dispatch_queue_t *)(v4 + 136));
  if (*(_DWORD *)(v4 + 116) >= 2u)
    dispatch_queue_set_width();
  v8 = *__error();
  v9 = _SILogForLogForCategory(3);
  v10 = 2 * (dword_1EF19FC98 < 4);
  if (os_log_type_enabled(v9, v10))
  {
    v11 = *(_DWORD *)(v4 + 72);
    v12 = (*(_DWORD *)(v4 + 72) >> 8) & 0xF;
    v13 = *((_QWORD *)v5 + 1);
    v14 = *((_QWORD *)v5 + 2);
    *(_DWORD *)buf = 67109890;
    v19 = v11;
    v20 = 1024;
    v21 = v12;
    v22 = 2112;
    v23 = v13;
    v24 = 2112;
    v25 = v14;
    _os_log_impl(&dword_1B8270000, v9, v10, "Workqueue qos: 0x%x relative_priority: %d %@ %@", buf, 0x22u);
  }
  *__error() = v8;
  if ((v3 & 2) != 0)
    dispatch_suspend(*((dispatch_object_t *)v5 + 2));
  v15 = *(NSObject **)(v4 + 32);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __si_create_child_queue_block_invoke;
  block[3] = &__block_descriptor_tmp_19_1019;
  block[4] = v4;
  block[5] = 2;
  block[6] = v5;
  dispatch_sync(v15, block);
  return v5;
}

void __si_create_child_queue_block_invoke(uint64_t a1)
{
  unsigned int v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  int v7;
  NSObject *v8;
  os_log_type_t v9;
  unsigned int v10;
  _DWORD v11[2];
  __int16 v12;
  unsigned int v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v2 = atomic_load((unsigned int *)(*(_QWORD *)(a1 + 32) + 84));
  v3 = (unsigned int *)(*(_QWORD *)(a1 + 32) + 84);
  do
    v4 = __ldaxr(v3);
  while (__stlxr(v4 + 1, v3));
  **(_QWORD **)(a1 + 48) = *(_QWORD *)(a1 + 32);
  dispatch_activate(*(dispatch_object_t *)(*(_QWORD *)(a1 + 48) + 16));
  v5 = v2 + 1;
  v6 = atomic_load((unsigned int *)(*(_QWORD *)(a1 + 32) + 84));
  if (v2 + 1 != v6)
  {
    v7 = *__error();
    v8 = _SILogForLogForCategory(3);
    v9 = 2 * (dword_1EF19FC98 < 4);
    if (os_log_type_enabled(v8, v9))
    {
      v10 = atomic_load((unsigned int *)(*(_QWORD *)(a1 + 32) + 84));
      v11[0] = 67109376;
      v11[1] = v5;
      v12 = 1024;
      v13 = v10;
      _os_log_impl(&dword_1B8270000, v8, v9, "%d != %d\n", (uint8_t *)v11, 0xEu);
    }
    *__error() = v7;
  }
}

void *si_create_root_scheduler(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  char *v10;
  void *scheduler;
  NSObject *AttrFromPolicy;
  NSObject *inactive;
  int v14;
  NSObject *v15;
  os_log_type_t v16;
  uint64_t v17;
  uint64_t v18;
  uint8_t buf[4];
  int v21;
  __int16 v22;
  unsigned int v23;
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  uint64_t v27;
  char __str[4096];
  uint64_t v29;

  v1 = MEMORY[0x1E0C80A78](a1);
  v3 = v2;
  v5 = v4;
  v7 = v6;
  v9 = v8;
  v10 = (char *)v1;
  v29 = *MEMORY[0x1E0C80C00];
  if (v8 < 2)
  {
    scheduler = malloc_type_calloc(1uLL, 0xC0uLL, 0x10B0040A868EC2DuLL);
    *((_DWORD *)scheduler + 29) = v9;
    bzero(__str, 0x1000uLL);
    snprintf(__str, 0x1000uLL, "MQ: %s", v10);
    *((_BYTE *)scheduler + 50) = v5;
    AttrFromPolicy = makeAttrFromPolicy(v7, v5, 0);
    *((_QWORD *)scheduler + 4) = dispatch_queue_create_with_target_V2(__str, AttrFromPolicy, 0);
    inactive = dispatch_workloop_create_inactive(v10);
    *((_QWORD *)scheduler + 17) = inactive;
    dispatch_workloop_set_autorelease_frequency(inactive, DISPATCH_AUTORELEASE_FREQUENCY_NEVER);
    *((_QWORD *)scheduler + 9) = v7;
    *((_QWORD *)scheduler + 8) = strdup(v10);
    atomic_store(1u, (unsigned int *)scheduler + 20);
    *((_DWORD *)scheduler + 47) = si_pc_priority_from_string(v10);
    v14 = *__error();
    v15 = _SILogForLogForCategory(3);
    v16 = 2 * (dword_1EF19FC98 < 4);
    if (os_log_type_enabled(v15, v16))
    {
      v17 = *((_QWORD *)scheduler + 4);
      v18 = *((_QWORD *)scheduler + 17);
      *(_DWORD *)buf = 67109890;
      v21 = v7;
      v22 = 1024;
      v23 = (v7 >> 8) & 0xF;
      v24 = 2112;
      v25 = v17;
      v26 = 2112;
      v27 = v18;
      _os_log_impl(&dword_1B8270000, v15, v16, "Scheduler qos: 0x%x relative_priority: %d %@ %@", buf, 0x22u);
    }
    *__error() = v14;
  }
  else
  {
    scheduler = si_create_scheduler(0);
  }
  *((_DWORD *)scheduler + 29) = v9;
  *((_QWORD *)scheduler + 9) = v7;
  *((_QWORD *)scheduler + 1) = malloc_type_calloc(1uLL, 0x40uLL, 0x1000040FA0F61DDuLL);
  *((_QWORD *)scheduler + 2) = malloc_type_calloc(1uLL, 0x30uLL, 0x1000040EED21634uLL);
  pthread_mutex_init(*((pthread_mutex_t **)scheduler + 1), 0);
  pthread_cond_init(*((pthread_cond_t **)scheduler + 2), 0);
  *((_BYTE *)scheduler + 49) = 1;
  dispatch_queue_set_specific(*((dispatch_queue_t *)scheduler + 17), "kSISchedulerQOSClass", (void *)v7, 0);
  *((_QWORD *)scheduler + 16) = v3;
  dispatch_activate(*((dispatch_object_t *)scheduler + 4));
  dispatch_activate(*((dispatch_object_t *)scheduler + 17));
  return scheduler;
}

uint64_t si_scheduler_wait_on_suspend_token(uint64_t a1)
{
  unsigned int v2;
  uint64_t v3;
  _BOOL8 v4;

  if (!a1 || !*(_QWORD *)(a1 + 8))
    return 1;
  do
    v2 = __ldaxr((unsigned int *)a1);
  while (__stlxr(v2 + 1, (unsigned int *)a1));
  v3 = *(_QWORD *)(a1 + 8);
  pthread_mutex_lock(*(pthread_mutex_t **)(v3 + 8));
  while (!*(_BYTE *)(a1 + 4) && !*(_BYTE *)(a1 + 5))
    pthread_cond_wait(*(pthread_cond_t **)(v3 + 16), *(pthread_mutex_t **)(v3 + 8));
  v4 = *(_BYTE *)(a1 + 5) == 0;
  pthread_mutex_unlock(*(pthread_mutex_t **)(v3 + 8));
  release_token((unsigned int *)a1);
  return v4;
}

void si_scheduler_async_suspend_and_enqueue(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int **a5)
{
  unsigned int *v10;
  int v11;
  uint64_t v12;

  *a5 = 0;
  if (a1 && !*(_DWORD *)(a1 + 88))
  {
    v10 = (unsigned int *)malloc_type_calloc(1uLL, 0x30uLL, 0x10A0040B618E767uLL);
    atomic_store(2u, v10);
    *((_QWORD *)v10 + 1) = a1;
    *((_QWORD *)v10 + 4) = a3;
    *((_QWORD *)v10 + 5) = a4;
    *((_QWORD *)v10 + 3) = a2;
    *a5 = v10;
    pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 8));
    v11 = *(_DWORD *)(a1 + 100);
    if (v11)
    {
      *(_DWORD *)(a1 + 100) = v11 + 1;
      *((_BYTE *)v10 + 4) = 1;
    }
    else
    {
      v12 = *(_QWORD *)(a1 + 120);
      *((_QWORD *)v10 + 2) = v12;
      *(_QWORD *)(a1 + 120) = v10;
      if (!v12 && !*(_DWORD *)(a1 + 104))
        _scheduler_suspension_locked(a1);
      v10 = 0;
    }
    pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 8));
    si_scheduler_trigger_tokens((uint64_t)v10);
  }
}

uint64_t __si_scheduler_set_stopped_block_invoke(uint64_t result)
{
  *(_BYTE *)(*(_QWORD *)(result + 32) + 48) = 1;
  return result;
}

void si_scheduler_stop(uint64_t a1, uint64_t a2)
{
  unsigned int *v3;
  unsigned int v4;
  NSObject *v5;
  unsigned int v6;
  unsigned int v7;
  _QWORD v8[6];

  if (a1)
  {
    v3 = (unsigned int *)(a1 + 80);
    do
      v4 = __ldaxr(v3);
    while (__stlxr(v4 + 1, v3));
    *(_BYTE *)(a1 + 48) = 1;
    v5 = *(NSObject **)(a1 + 32);
    v8[0] = MEMORY[0x1E0C809B0];
    v8[1] = 0x40000000;
    v8[2] = __si_scheduler_stop_block_invoke;
    v8[3] = &__block_descriptor_tmp_28_1042;
    v8[4] = a1;
    v8[5] = a2;
    dispatch_sync(v5, v8);
    do
    {
      v6 = __ldaxr(v3);
      v7 = v6 - 1;
    }
    while (__stlxr(v7, v3));
    if (!v7)
      _si_scheduler_destroy(a1);
  }
}

pthread_mutex_t *__si_scheduler_stop_block_invoke(uint64_t a1)
{
  uint64_t v2;
  pthread_mutex_t *result;
  uint64_t v4;
  int v5;
  uint64_t v6;
  pthread_override_s *v7;
  uint64_t v8;
  uint64_t v9;
  pthread_override_s *v10;
  uint64_t v11;
  int v12;
  NSObject *v13;
  uint64_t v14;
  char *v15;
  char *v16;
  const char *v17;
  char *v18;
  const char *v19;
  uint64_t v20;
  _QWORD aBlock[4];
  __int128 v22;
  uint8_t buf[4];
  uint64_t v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 32);
  *(_BYTE *)(v2 + 48) = 1;
  result = *(pthread_mutex_t **)(v2 + 8);
  if (!result)
  {
    if (*(_BYTE *)(v2 + 51) || !*(_DWORD *)(v2 + 100))
      goto LABEL_17;
    v15 = __si_assert_copy_extra_521(-1);
    v16 = v15;
    v17 = "";
    if (v15)
      v17 = v15;
    __message_assert("%s:%u: failed assertion '%s' %s ", "SIScheduler.c", 1574, "scheduler->force_resumed == 1 || scheduler->suspended==0", v17);
    goto LABEL_28;
  }
  pthread_mutex_lock(result);
  v4 = *(_QWORD *)(a1 + 32);
  if (*(_DWORD *)(v4 + 100) && !*(_BYTE *)(v4 + 51))
  {
    v5 = *(_DWORD *)(v4 + 96);
    if (!v5 || v5 == *(_DWORD *)(v4 + 108))
    {
      *(_BYTE *)(v4 + 51) = 1;
      *(_DWORD *)(v4 + 100) = 0x7FFFFFFF;
      *(_QWORD *)(v4 + 160) = 0;
      v6 = *(_QWORD *)(a1 + 32);
      v7 = *(pthread_override_s **)(v6 + 176);
      if (v7)
      {
        pthread_override_qos_class_end_np(v7);
        v6 = *(_QWORD *)(a1 + 32);
      }
      *(_QWORD *)(v6 + 176) = 0;
      v8 = *(_QWORD *)(a1 + 32);
      *(_DWORD *)(v8 + 184) = 0;
      dispatch_resume(*(dispatch_object_t *)(v8 + 136));
      pthread_cond_broadcast(*(pthread_cond_t **)(*(_QWORD *)(a1 + 32) + 16));
      v4 = *(_QWORD *)(a1 + 32);
      goto LABEL_9;
    }
    v18 = __si_assert_copy_extra_521(-1);
    v16 = v18;
    v19 = "";
    if (v18)
      v19 = v18;
    __message_assert("%s:%u: failed assertion '%s' %s ", "SIScheduler.c", 1550, "scheduler->running==0 || scheduler->running==scheduler->voluntary_suspended", v19);
LABEL_28:
    free(v16);
    if (__valid_fs(-1))
      v20 = 2989;
    else
      v20 = 3072;
    *(_DWORD *)v20 = -559038737;
    abort();
  }
LABEL_9:
  if (*(_DWORD *)(v4 + 108) && !*(_BYTE *)(v4 + 51))
  {
    *(_BYTE *)(v4 + 51) = 1;
    *(_DWORD *)(v4 + 100) = 0x7FFFFFFF;
    *(_QWORD *)(v4 + 160) = 0;
    v9 = *(_QWORD *)(a1 + 32);
    v10 = *(pthread_override_s **)(v9 + 176);
    if (v10)
    {
      pthread_override_qos_class_end_np(v10);
      v9 = *(_QWORD *)(a1 + 32);
    }
    *(_QWORD *)(v9 + 176) = 0;
    v11 = *(_QWORD *)(a1 + 32);
    *(_DWORD *)(v11 + 184) = 0;
    pthread_cond_broadcast(*(pthread_cond_t **)(v11 + 16));
    v4 = *(_QWORD *)(a1 + 32);
  }
  result = (pthread_mutex_t *)pthread_mutex_unlock(*(pthread_mutex_t **)(v4 + 8));
  v2 = *(_QWORD *)(a1 + 32);
LABEL_17:
  if (*(_DWORD *)(v2 + 96))
  {
    v12 = *__error();
    v13 = _SILogForLogForCategory(3);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      v14 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 64);
      *(_DWORD *)buf = 136315138;
      v24 = v14;
      _os_log_impl(&dword_1B8270000, v13, OS_LOG_TYPE_DEFAULT, "Issue stop for %s\n", buf, 0xCu);
    }
    *__error() = v12;
    dispatch_group_enter(*(dispatch_group_t *)(a1 + 40));
    dispatch_retain(*(dispatch_object_t *)(a1 + 40));
    aBlock[0] = MEMORY[0x1E0C809B0];
    aBlock[1] = 0x40000000;
    aBlock[2] = __si_scheduler_stop_block_invoke_26;
    aBlock[3] = &__block_descriptor_tmp_27_1046;
    v22 = *(_OWORD *)(a1 + 32);
    result = (pthread_mutex_t *)_Block_copy(aBlock);
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 40) = result;
  }
  return result;
}

int *__si_scheduler_stop_block_invoke_26(uint64_t a1)
{
  int v2;
  NSObject *v3;
  uint64_t v4;
  int *result;
  int v6;
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  *(_DWORD *)(*(_QWORD *)(a1 + 32) + 88) = 1;
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
  dispatch_release(*(dispatch_object_t *)(a1 + 40));
  v2 = *__error();
  v3 = _SILogForLogForCategory(3);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 64);
    v6 = 136315138;
    v7 = v4;
    _os_log_impl(&dword_1B8270000, v3, OS_LOG_TYPE_DEFAULT, "Stopped %s\n", (uint8_t *)&v6, 0xCu);
  }
  result = __error();
  *result = v2;
  return result;
}

void si_scheduler_boost_and_forget(uint64_t a1)
{
  dispatch_block_t v2;
  int v3;
  NSObject *v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (dword_1EF19FC98 >= 5)
    {
      v3 = *__error();
      v4 = _SILogForLogForCategory(3);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        v5 = *(_QWORD *)(a1 + 136);
        v6 = 138412290;
        v7 = v5;
        _os_log_impl(&dword_1B8270000, v4, OS_LOG_TYPE_DEFAULT, "boosting %@", (uint8_t *)&v6, 0xCu);
      }
      *__error() = v3;
    }
    v2 = dispatch_block_create_with_qos_class(DISPATCH_BLOCK_ENFORCE_QOS_CLASS, QOS_CLASS_USER_INITIATED, 0, &__block_literal_global_31);
    dispatch_async(*(dispatch_queue_t *)(a1 + 136), v2);
    _Block_release(v2);
  }
}

uint64_t __si_scheduler_dump_block_invoke(uint64_t a1)
{
  return _si_scheduler_dump(*(uint64_t **)(a1 + 32), 0, *(__CFString **)(a1 + 40));
}

uint64_t _si_scheduler_dump(uint64_t *a1, int a2, __CFString *a3)
{
  size_t v6;
  const char *v7;
  uint64_t *v8;
  const char *v9;
  const char *v10;
  uint64_t result;
  _QWORD v12[2];

  v12[1] = *MEMORY[0x1E0C80C00];
  v6 = (a2 + 1);
  MEMORY[0x1E0C80A78](a1);
  bzero((char *)v12 - ((v6 + 15) & 0x1FFFFFFF0), v6);
  memset((char *)v12 - ((v6 + 15) & 0x1FFFFFFF0), 9, a2);
  *((_BYTE *)v12 + a2 - ((v6 + 15) & 0x1FFFFFFF0)) = 0;
  v7 = "Yes";
  v8 = a1;
  while (!*((_DWORD *)v8 + 25))
  {
    v8 = (uint64_t *)*v8;
    if (!v8)
    {
      v7 = "No";
      break;
    }
  }
  v9 = "YES";
  if (*((_BYTE *)a1 + 48))
    v10 = "YES";
  else
    v10 = "NO";
  if (!*((_DWORD *)a1 + 22))
    v9 = "NO";
  CFStringAppendFormat(a3, 0, CFSTR("%sScheduler %p %s dq:%p parent:%p; %d suspensions suspended:%s (stop waiting: %s stopped: %s)\n"),
    (char *)v12 - ((v6 + 15) & 0x1FFFFFFF0),
    a1,
    a1[8],
    a1[17],
    *a1,
    *((unsigned int *)a1 + 25),
    v7,
    v10,
    v9);
  result = *a1;
  if (*a1)
    return _si_scheduler_dump(result, v6, a3);
  return result;
}

uint64_t *si_workqueue_dump(uint64_t *result, __CFString *a2)
{
  uint64_t **v3;
  uint64_t v4;
  CFMutableStringRef v5;
  _BYTE v6[16];

  if (result)
  {
    v3 = (uint64_t **)result;
    v4 = MEMORY[0x1E0C80A78](result);
    v6[0] = 0;
    CFStringAppendFormat(v5, 0, CFSTR("%sWork queue %p; dq: %p %ld items enqueued\n"),
      v6,
      v4,
      *(_QWORD *)(v4 + 16),
      *(_QWORD *)(v4 + 64));
    result = *v3;
    if (*v3)
      return (uint64_t *)_si_scheduler_dump(result, 1, a2);
  }
  return result;
}

void __si_push_queue_block_invoke(uint64_t a1)
{
  si_push_tag_locked(*(_QWORD *)(a1 + 32), *(void **)(a1 + 40), *(const void ***)(a1 + 48), *(_QWORD *)(a1 + 56));
}

uint64_t si_peek_queue(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  NSObject *v4;
  uint64_t v5;
  _QWORD block[9];
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  char v11;

  v8 = 0;
  v9 = &v8;
  v10 = 0x2000000000;
  v11 = 0;
  v4 = *(NSObject **)(a1 + 8);
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __si_peek_queue_block_invoke;
  block[3] = &unk_1E6E2E9B8;
  block[6] = a1;
  block[7] = a4;
  block[4] = &v8;
  block[5] = a2;
  block[8] = a3;
  dispatch_sync(v4, block);
  v5 = *((unsigned __int8 *)v9 + 24);
  _Block_object_dispose(&v8, 8);
  return v5;
}

const __CFDictionary *__si_peek_queue_block_invoke(uint64_t a1)
{
  const __CFDictionary *result;
  const __CFBag *v3;
  uint64_t v4;
  int v5;
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  __int16 v11;
  uint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  if (dword_1EF19FC9C >= 5)
  {
    v5 = *__error();
    v6 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      v7 = *(_QWORD *)(a1 + 40);
      v8 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 72);
      v9 = 134218240;
      v10 = v7;
      v11 = 2048;
      v12 = v8;
      _os_log_impl(&dword_1B8270000, v6, OS_LOG_TYPE_DEFAULT, "Peek for %p to %p", (uint8_t *)&v9, 0x16u);
    }
    *__error() = v5;
  }
  result = *(const __CFDictionary **)(*(_QWORD *)(a1 + 48) + 72);
  if (result)
  {
    result = (const __CFDictionary *)CFDictionaryGetValue(result, *(const void **)(a1 + 40));
    if (result)
    {
      if (*(_QWORD *)(a1 + 56))
      {
        v3 = result;
        v4 = 0;
        while (1)
        {
          result = (const __CFDictionary *)CFBagContainsValue(v3, *(const void **)(*(_QWORD *)(a1 + 64) + 8 * v4));
          if ((_DWORD)result)
            break;
          if ((unint64_t)++v4 >= *(_QWORD *)(a1 + 56))
            return result;
        }
      }
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
    }
  }
  return result;
}

uint64_t __si_peek_queue_for_tags_block_invoke(uint64_t result)
{
  uint64_t v1;
  uint64_t v3;
  uint64_t v4;
  const void *ValueAtIndex;
  const char *v6;
  NSObject *v7;
  const char *v8;
  const char *v9;
  uint64_t v10;
  uint32_t v11;
  BOOL v12;
  const char *v13;
  int v14;
  NSObject *v15;
  const void *v16;
  uint64_t v17;
  const char *label;
  uint64_t v19;
  uint64_t v20;
  NSObject *log;
  NSObject *loga;
  NSObject *logb;
  int v24;
  uint8_t buf[4];
  const void *v26;
  __int16 v27;
  const char *v28;
  __int16 v29;
  uint64_t v30;
  uint64_t v31;

  v1 = result;
  v31 = *MEMORY[0x1E0C80C00];
  if (dword_1EF19FC90 >= 5)
  {
    v14 = *__error();
    v15 = _SILogForLogForCategory(1);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      v16 = *(const void **)(v1 + 40);
      v17 = *(_QWORD *)(v1 + 48);
      label = dispatch_queue_get_label(*(dispatch_queue_t *)(v17 + 16));
      v19 = *(_QWORD *)(v17 + 72);
      *(_DWORD *)buf = 134218498;
      v26 = v16;
      v27 = 2080;
      v28 = label;
      v29 = 2048;
      v30 = v19;
      _os_log_impl(&dword_1B8270000, v15, OS_LOG_TYPE_DEFAULT, "Peek for  %p on queue %s with tagbag %p", buf, 0x20u);
    }
    result = (uint64_t)__error();
    *(_DWORD *)result = v14;
  }
  if (*(_QWORD *)(*(_QWORD *)(v1 + 48) + 72))
  {
    result = CFArrayGetCount(*(CFArrayRef *)(v1 + 40));
    if (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v1 + 32) + 8) + 24) && result >= 1)
    {
      v3 = result;
      v4 = 1;
      do
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(v1 + 40), v4 - 1);
        result = (uint64_t)CFDictionaryGetValue(*(CFDictionaryRef *)(*(_QWORD *)(v1 + 48) + 72), ValueAtIndex);
        if (result)
        {
          result = MEMORY[0x1BCCAF3E4]();
          if (result)
          {
            *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v1 + 32) + 8) + 24) = 1;
            if (dword_1EF19FC90 >= 5)
            {
              v24 = *__error();
              log = _SILogForLogForCategory(1);
              if (os_log_type_enabled(log, OS_LOG_TYPE_DEFAULT))
              {
                v6 = dispatch_queue_get_label(*(dispatch_queue_t *)(*(_QWORD *)(v1 + 48) + 16));
                *(_DWORD *)buf = 134218242;
                v26 = ValueAtIndex;
                v27 = 2080;
                v28 = v6;
                v7 = log;
                v8 = "Found oid bag for %p on queue %s";
                goto LABEL_25;
              }
              goto LABEL_27;
            }
          }
          else if (dword_1EF19FC90 >= 5)
          {
            v24 = *__error();
            logb = _SILogForLogForCategory(1);
            if (os_log_type_enabled(logb, OS_LOG_TYPE_DEFAULT))
            {
              v13 = dispatch_queue_get_label(*(dispatch_queue_t *)(*(_QWORD *)(v1 + 48) + 16));
              *(_DWORD *)buf = 134218242;
              v26 = ValueAtIndex;
              v27 = 2080;
              v28 = v13;
              v7 = logb;
              v8 = "Empty oid bag for %p on queue %s";
LABEL_25:
              v11 = 22;
LABEL_26:
              _os_log_impl(&dword_1B8270000, v7, OS_LOG_TYPE_DEFAULT, v8, buf, v11);
            }
            goto LABEL_27;
          }
        }
        else if (dword_1EF19FC90 >= 5)
        {
          v24 = *__error();
          loga = _SILogForLogForCategory(1);
          if (os_log_type_enabled(loga, OS_LOG_TYPE_DEFAULT))
          {
            v20 = *(_QWORD *)(v1 + 48);
            v9 = dispatch_queue_get_label(*(dispatch_queue_t *)(v20 + 16));
            v7 = loga;
            v10 = *(_QWORD *)(v20 + 72);
            *(_DWORD *)buf = 134218498;
            v26 = ValueAtIndex;
            v27 = 2080;
            v28 = v9;
            v29 = 2048;
            v30 = v10;
            v8 = "No oid bag for %p on queue %s with tags %p";
            v11 = 32;
            goto LABEL_26;
          }
LABEL_27:
          result = (uint64_t)__error();
          *(_DWORD *)result = v24;
        }
        if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v1 + 32) + 8) + 24))
          v12 = 0;
        else
          v12 = v4 < v3;
        ++v4;
      }
      while (v12);
    }
  }
  return result;
}

uint64_t si_dequeue_wait_locked(uint64_t a1, float a2)
{
  int v2;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t result;
  int v8;
  unsigned int v9;
  uint64_t v10;
  int v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  timeval v30;
  timespec v31;

  v2 = *(_DWORD *)(a1 + 120);
  if ((-v2 & *(_DWORD *)(a1 + 128)) != 0
    || (v4 = v2 - 1, v5 = *(unsigned int *)(a1 + 124), (v5 & ~v4) != 0))
  {
    v12 = __si_assert_copy_extra_268();
    __message_assert_272((uint64_t)v12, v13, v14, v15, v16, v17, v18, v19, (char)"SISimpleQueue.c");
    free(v12);
    if (__valid_fs(-1))
      v20 = 2989;
    else
      v20 = 3072;
    *(_DWORD *)v20 = -559038737;
    abort();
  }
  v31.tv_sec = 0;
  v31.tv_nsec = 0;
  v6 = *(_QWORD *)(a1 + 136);
  result = *(_QWORD *)(v6 + 8 * v5);
  if (!result)
  {
    v9 = (a2 * 1000000000.0);
    v30.tv_sec = 0;
    *(_QWORD *)&v30.tv_usec = 0;
    gettimeofday(&v30, 0);
    v10 = v9 % 0x3B9ACA00 + 1000 * v30.tv_usec;
    v31.tv_sec = v30.tv_sec + v9 / 0x3B9ACA00uLL;
    v31.tv_nsec = v10;
    if (v10 >= 1000000000)
    {
      v31.tv_sec = v30.tv_sec + v9 / 0x3B9ACA00uLL + 1;
      v31.tv_nsec = v10 - 1000000000;
    }
    while (1)
    {
      v6 = *(_QWORD *)(a1 + 136);
      v5 = *(unsigned int *)(a1 + 124);
      result = *(_QWORD *)(v6 + 8 * v5);
      if (result)
        break;
      ++*(_DWORD *)(a1 + 132);
      v11 = pthread_cond_timedwait((pthread_cond_t *)(a1 + 72), (pthread_mutex_t *)(a1 + 8), &v31);
      --*(_DWORD *)(a1 + 132);
      if (v11)
      {
        v6 = *(_QWORD *)(a1 + 136);
        v5 = *(unsigned int *)(a1 + 124);
        result = *(_QWORD *)(v6 + 8 * v5);
        if (result)
          break;
        return result;
      }
    }
  }
  *(_QWORD *)(v6 + 8 * v5) = 0;
  v8 = *(_DWORD *)(a1 + 120);
  *(_DWORD *)(a1 + 124) = (v8 - 1) & (v5 + 1);
  if ((-v8 & *(_DWORD *)(a1 + 128)) != 0)
  {
    v21 = __si_assert_copy_extra_268();
    __message_assert_272((uint64_t)v21, v22, v23, v24, v25, v26, v27, v28, (char)"SISimpleQueue.c");
    free(v21);
    if (__valid_fs(-1))
      v29 = 2989;
    else
      v29 = 3072;
    *(_DWORD *)v29 = -559038737;
    abort();
  }
  return result;
}

uint64_t SIResultQueueGetEnqueuedSize(_QWORD *a1)
{
  uint64_t v2;

  pthread_mutex_lock((pthread_mutex_t *)(*a1 + 8));
  v2 = a1[9];
  pthread_mutex_unlock((pthread_mutex_t *)(*a1 + 8));
  return v2;
}

uint64_t SIResultQueueRetain(uint64_t result)
{
  unsigned int *v1;
  unsigned int v2;

  v1 = (unsigned int *)(result + 8);
  do
    v2 = __ldaxr(v1);
  while (__stlxr(v2 + 1, v1));
  return result;
}

BOOL SIResultQueueNoWakeupTrigger(uint64_t a1)
{
  return *(_QWORD *)(a1 + 48) == 0;
}

uint64_t SIWaitResults(uint64_t *a1, float a2)
{
  uint64_t v3;
  pthread_mutex_t *v4;

  v3 = *a1;
  v4 = (pthread_mutex_t *)(*a1 + 8);
  pthread_mutex_lock(v4);
  si_dequeue_wait_locked(v3, a2);
  return pthread_mutex_unlock(v4);
}

double SIResultQueueGetLastPollTime(uint64_t a1)
{
  return *(double *)(a1 + 64);
}

void *SISetQueryCSFieldNameCallback(void *result)
{
  sSIQueryCSFieldNameCallback = result;
  return result;
}

void incompleteRomajiKanaData(uint64_t a1)
{
  unsigned __int8 v1;
  uint64_t v2;
  unint64_t i;
  uint64_t j;
  uint64_t k;
  uint64_t m;
  uint64_t n;
  uint64_t ii;
  uint64_t jj;
  uint64_t kk;
  uint64_t mm;
  uint64_t nn;
  uint64_t i1;
  uint64_t i2;
  uint64_t i3;
  uint64_t i4;
  uint64_t i5;
  uint64_t i6;
  uint64_t i7;
  uint64_t i8;
  uint64_t i9;
  uint64_t i10;
  uint64_t i11;
  uint64_t i12;
  uint64_t i13;
  uint64_t i14;
  uint64_t i15;
  uint64_t i16;
  uint64_t i17;
  uint64_t i18;
  uint64_t i19;
  uint64_t i20;
  uint64_t i21;
  uint64_t i22;
  uint64_t i23;
  uint64_t i24;
  uint64_t i25;
  uint64_t i26;
  uint64_t i27;
  uint64_t i28;
  uint64_t i29;
  uint64_t i30;
  uint64_t i31;
  uint64_t i32;
  uint64_t i33;
  uint64_t i34;
  __int128 *v47[3];
  void *__p[2];
  char v49;
  __int128 *v50[3];
  void *v51[2];
  char v52;
  __int128 *v53[3];
  void *v54[2];
  char v55;
  __int128 *v56[3];
  void *v57[2];
  char v58;
  __int128 *v59[3];
  void *v60[2];
  char v61;
  __int128 *v62[3];
  void *v63[2];
  char v64;
  __int128 *v65[3];
  void *v66[2];
  char v67;
  __int128 *v68[3];
  void *v69[2];
  char v70;
  __int128 *v71[3];
  void *v72[2];
  char v73;
  __int128 *v74[3];
  void *v75[2];
  char v76;
  __int128 *v77[3];
  void *v78[2];
  char v79;
  __int128 *v80[3];
  void *v81[2];
  char v82;
  __int128 *v83[3];
  void *v84[2];
  char v85;
  __int128 *v86[3];
  void *v87[2];
  char v88;
  __int128 *v89[3];
  void *v90[2];
  char v91;
  __int128 *v92[3];
  void *v93[2];
  char v94;
  __int128 *v95[3];
  void *v96[2];
  char v97;
  __int128 *v98[3];
  void *v99[2];
  char v100;
  __int128 *v101[3];
  void *v102[2];
  char v103;
  __int128 *v104[3];
  void *v105[2];
  char v106;
  __int128 *v107[3];
  void *v108[2];
  char v109;
  __int128 *v110[3];
  void *v111[2];
  char v112;
  __int128 *v113[3];
  void *v114[2];
  char v115;
  __int128 *v116[3];
  void *v117[2];
  char v118;
  __int128 *v119[3];
  void *v120[2];
  char v121;
  __int128 *v122[3];
  void *v123[2];
  char v124;
  __int128 *v125[3];
  void *v126[2];
  char v127;
  __int128 *v128[3];
  void *v129[2];
  char v130;
  __int128 *v131[3];
  void *v132[2];
  char v133;
  __int128 *v134[3];
  void *v135[2];
  char v136;
  __int128 *v137[3];
  void *v138[2];
  char v139;
  __int128 *v140[3];
  void *v141[2];
  char v142;
  __int128 *v143[3];
  void *v144[2];
  char v145;
  __int128 *v146[3];
  void *v147[2];
  char v148;
  __int128 *v149[3];
  void *v150[2];
  char v151;
  __int128 *v152[3];
  void *v153[2];
  char v154;
  __int128 *v155[3];
  void *v156[2];
  char v157;
  __int128 *v158[3];
  void *v159[2];
  char v160;
  __int128 *v161[3];
  void *v162[2];
  char v163;
  __int128 *v164[3];
  void *v165[2];
  char v166;
  __int128 *v167[3];
  void *v168[2];
  char v169;
  __int128 *v170[3];
  void *v171[2];
  char v172;
  __int128 *v173[3];
  void *v174[2];
  char v175;
  __int128 *v176[3];
  void *v177[2];
  char v178;
  __int128 *v179[3];
  void *v180[2];
  char v181;
  __int128 *v182[3];
  void *v183[2];
  char v184;
  __int128 *v185[3];
  void *v186[2];
  char v187;
  __int128 *v188[3];
  void *v189[2];
  char v190;
  __int128 *v191[3];
  void *v192[2];
  char v193;
  __int128 *v194[3];
  void *v195[2];
  char v196;
  __int128 *v197[3];
  void *v198[2];
  char v199;
  __int128 *v200[3];
  void *v201[2];
  char v202;
  __int128 *v203[3];
  void *v204[2];
  char v205;
  __int128 *v206[3];
  void *v207[2];
  char v208;
  __int128 *v209[3];
  void *v210[2];
  char v211;
  __int128 *v212[3];
  void *v213[2];
  char v214;
  __int128 *v215[3];
  void *v216[2];
  char v217;
  __int128 **v218;
  __int128 v219;
  _QWORD v220[3];
  _QWORD v221[3];
  _QWORD v222[3];
  _QWORD v223[3];
  __int128 v224;
  _QWORD v225[3];
  _QWORD v226[3];
  _QWORD v227[3];
  _QWORD v228[3];
  _QWORD v229[3];
  __int128 v230;
  _QWORD v231[3];
  _QWORD v232[3];
  _QWORD v233[3];
  _QWORD v234[3];
  _QWORD v235[3];
  __int128 v236;
  _QWORD v237[3];
  _QWORD v238[3];
  _QWORD v239[3];
  void *v240[3];
  void *v241[2];
  char v242;
  void *v243[2];
  char v244;
  void *v245[2];
  char v246;
  __int128 v247;
  _QWORD v248[3];
  _QWORD v249[3];
  _QWORD v250[3];
  _QWORD v251[3];
  _QWORD v252[3];
  _QWORD v253[3];
  _QWORD v254[3];
  _QWORD v255[3];
  _QWORD v256[3];
  __int128 v257;
  _QWORD v258[3];
  __int128 v259;
  _QWORD v260[3];
  _QWORD v261[3];
  __int128 v262;
  _QWORD v263[3];
  _QWORD v264[3];
  _QWORD v265[3];
  _QWORD v266[3];
  void *v267[3];
  void *v268[2];
  char v269;
  __int128 v270;
  _QWORD v271[3];
  __int128 v272;
  _QWORD v273[3];
  _QWORD v274[3];
  _QWORD v275[3];
  void *v276[3];
  void *v277[2];
  char v278;
  void *v279[2];
  char v280;
  __int128 v281;
  _QWORD v282[3];
  _QWORD v283[3];
  _QWORD v284[3];
  __int128 v285;
  _QWORD v286[3];
  _QWORD v287[3];
  _QWORD v288[3];
  _QWORD v289[3];
  _QWORD v290[3];
  __int128 v291;
  _QWORD v292[3];
  _QWORD v293[3];
  _QWORD v294[3];
  void *v295[3];
  void *v296[2];
  char v297;
  __int128 v298;
  _QWORD v299[3];
  _QWORD v300[3];
  _QWORD v301[3];
  _QWORD v302[3];
  _QWORD v303[3];
  __int128 v304;
  _QWORD v305[3];
  _QWORD v306[3];
  _QWORD v307[3];
  _QWORD v308[3];
  __int128 v309;
  _QWORD v310[3];
  _QWORD v311[3];
  _QWORD v312[3];
  _QWORD v313[3];
  _QWORD v314[3];
  __int128 v315;
  _QWORD v316[3];
  _QWORD v317[3];
  _QWORD v318[3];
  void *v319[3];
  void *v320[2];
  char v321;
  __int128 v322;
  _QWORD v323[3];
  _QWORD v324[3];
  _QWORD v325[3];
  _QWORD v326[3];
  __int128 v327;
  _QWORD v328[3];
  _QWORD v329[3];
  _QWORD v330[3];
  _QWORD v331[3];
  _QWORD v332[3];
  __int128 v333;
  _QWORD v334[3];
  _QWORD v335[3];
  _QWORD v336[3];
  _QWORD v337[3];
  __int128 v338;
  _QWORD v339[3];
  _QWORD v340[3];
  _QWORD v341[3];
  _QWORD v342[3];
  _QWORD v343[3];
  _QWORD v344[3];
  __int128 v345;
  _QWORD v346[3];
  _QWORD v347[3];
  _QWORD v348[3];
  _QWORD v349[3];
  __int128 v350;
  _QWORD v351[3];
  _QWORD v352[3];
  _QWORD v353[3];
  _QWORD v354[3];
  _QWORD v355[3];
  __int128 v356;
  _QWORD v357[3];
  _QWORD v358[3];
  _QWORD v359[3];
  void *v360[3];
  void *v361[2];
  char v362;
  void *v363[2];
  char v364;
  __int128 v365;
  _QWORD v366[3];
  _QWORD v367[3];
  _QWORD v368[3];
  _QWORD v369[3];
  _QWORD v370[3];
  _QWORD v371[3];
  _QWORD v372[3];
  _QWORD v373[3];
  _QWORD v374[3];
  __int128 v375;
  _QWORD v376[3];
  _QWORD v377[3];
  _QWORD v378[3];
  _QWORD v379[3];
  __int128 v380;
  _QWORD v381[3];
  _QWORD v382[3];
  _QWORD v383[3];
  _QWORD v384[3];
  __int128 v385;
  _QWORD v386[3];
  _QWORD v387[3];
  _QWORD v388[3];
  _QWORD v389[3];
  _QWORD v390[3];
  __int128 v391;
  _QWORD v392[3];
  _QWORD v393[3];
  _QWORD v394[3];
  _QWORD v395[3];
  __int128 v396;
  _QWORD v397[3];
  __int128 v398;
  _QWORD v399[3];
  _QWORD v400[3];
  _QWORD v401[3];
  _QWORD v402[3];
  __int128 v403;
  _QWORD v404[3];
  _QWORD v405[3];
  _QWORD v406[3];
  _QWORD v407[3];
  __int128 v408;
  _QWORD v409[3];
  _QWORD v410[3];
  _QWORD v411[3];
  _QWORD v412[3];
  _QWORD v413[3];
  __int128 v414;
  _QWORD v415[3];
  _QWORD v416[3];
  _QWORD v417[3];
  _QWORD v418[3];
  __int128 v419;
  _QWORD v420[3];
  _QWORD v421[3];
  _QWORD v422[3];
  _QWORD v423[3];
  __int128 v424;
  _QWORD v425[3];
  _QWORD v426[3];
  _QWORD v427[3];
  _QWORD v428[3];
  void *v429[3];
  void *v430[2];
  char v431;
  void *v432[2];
  char v433;
  __int128 v434;
  _QWORD v435[3];
  _QWORD v436[3];
  _QWORD v437[3];
  void *v438[3];
  void *v439[2];
  char v440;
  __int128 v441;
  _QWORD v442[3];
  _QWORD v443[3];
  _QWORD v444[3];
  _QWORD v445[3];
  __int128 v446;
  _QWORD v447[3];
  _QWORD v448[3];
  _QWORD v449[3];
  _QWORD v450[3];
  _QWORD v451[3];
  __int128 v452;
  _QWORD v453[3];
  _QWORD v454[3];
  _QWORD v455[3];
  void *v456[3];
  void *v457[2];
  char v458;
  __int128 v459;
  _QWORD v460[3];
  _QWORD v461[3];
  _QWORD v462[3];
  _QWORD v463[3];
  _QWORD v464[3];
  _QWORD v465[3];
  __int128 v466;
  _QWORD v467[3];
  _QWORD v468[3];
  _QWORD v469[3];
  _QWORD v470[3];
  __int128 v471;
  _QWORD v472[3];
  _QWORD v473[3];
  _QWORD v474[3];
  _QWORD v475[3];
  _QWORD v476[3];
  std::string v477[2];
  std::string v478[2];
  std::string v479[2];
  std::string v480[2];
  std::string v481[2];
  std::string v482[2];
  std::string v483[2];
  std::string v484[2];
  std::string v485[2];
  std::string v486[2];
  std::string v487[2];
  std::string v488[2];
  std::string v489[2];
  std::string v490[2];
  std::string v491[2];
  std::string v492[2];
  std::string v493[2];
  std::string v494[2];
  std::string v495[2];
  std::string v496[2];
  std::string v497[2];
  std::string v498[2];
  std::string v499[2];
  std::string v500[2];
  std::string v501[2];
  std::string v502[2];
  std::string v503[2];
  std::string v504[2];
  std::string v505[2];
  std::string v506[2];
  std::string v507[2];
  std::string v508[2];
  std::string v509[2];
  std::string v510[2];
  std::string v511[2];
  std::string v512[2];
  std::string v513[2];
  std::string v514[2];
  std::string v515[2];
  std::string v516[2];
  std::string v517[2];
  std::string v518[2];
  std::string v519[2];
  std::string v520[2];
  std::string v521[2];
  std::string v522[2];
  std::string v523[2];
  std::string v524[2];
  std::string v525[2];
  std::string v526[2];
  std::string v527[2];
  std::string v528[2];
  std::string v529[2];
  std::string v530[2];
  std::string v531[2];
  std::string v532[2];
  std::string v533[2];
  uint64_t v534;

  MEMORY[0x1E0C80A78](a1);
  v534 = *MEMORY[0x1E0C80C00];
  {
    std::string::basic_string[abi:nn180100]<0>(v216, "b");
    std::string::basic_string[abi:nn180100]<0>(&v471, "っ");
    std::string::basic_string[abi:nn180100]<0>(v472, "ば");
    std::string::basic_string[abi:nn180100]<0>(v473, "び");
    std::string::basic_string[abi:nn180100]<0>(v474, "ぶ");
    std::string::basic_string[abi:nn180100]<0>(v475, "べ");
    std::string::basic_string[abi:nn180100]<0>(v476, "ぼ");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v215, &v471, 6uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v477, (__int128 *)v216, v215);
    std::string::basic_string[abi:nn180100]<0>(v213, "by");
    std::string::basic_string[abi:nn180100]<0>(&v466, "びゃ");
    std::string::basic_string[abi:nn180100]<0>(v467, "びぃ");
    std::string::basic_string[abi:nn180100]<0>(v468, "びゅ");
    std::string::basic_string[abi:nn180100]<0>(v469, "びぇ");
    std::string::basic_string[abi:nn180100]<0>(v470, "びょ");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v212, &v466, 5uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v478, (__int128 *)v213, v212);
    std::string::basic_string[abi:nn180100]<0>(v210, "c");
    std::string::basic_string[abi:nn180100]<0>(&v459, "っ");
    std::string::basic_string[abi:nn180100]<0>(v460, "か");
    std::string::basic_string[abi:nn180100]<0>(v461, "し");
    std::string::basic_string[abi:nn180100]<0>(v462, "く");
    std::string::basic_string[abi:nn180100]<0>(v463, "せ");
    std::string::basic_string[abi:nn180100]<0>(v464, "こ");
    std::string::basic_string[abi:nn180100]<0>(v465, "ち");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v209, &v459, 7uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v479, (__int128 *)v210, v209);
    std::string::basic_string[abi:nn180100]<0>(v207, "ch");
    std::string::basic_string[abi:nn180100]<0>(v457, "ち");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v206, (__int128 *)v457, 1uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v480, (__int128 *)v207, v206);
    std::string::basic_string[abi:nn180100]<0>(v204, "cy");
    std::string::basic_string[abi:nn180100]<0>(&v452, "ちゃ");
    std::string::basic_string[abi:nn180100]<0>(v453, "ちぃ");
    std::string::basic_string[abi:nn180100]<0>(v454, "ちゅ");
    std::string::basic_string[abi:nn180100]<0>(v455, "ちぇ");
    std::string::basic_string[abi:nn180100]<0>(v456, "ちょ");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v203, &v452, 5uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v481, (__int128 *)v204, v203);
    std::string::basic_string[abi:nn180100]<0>(v201, "d");
    std::string::basic_string[abi:nn180100]<0>(&v446, "っ");
    std::string::basic_string[abi:nn180100]<0>(v447, "だ");
    std::string::basic_string[abi:nn180100]<0>(v448, "ぢ");
    std::string::basic_string[abi:nn180100]<0>(v449, "づ");
    std::string::basic_string[abi:nn180100]<0>(v450, "で");
    std::string::basic_string[abi:nn180100]<0>(v451, "ど");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v200, &v446, 6uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v482, (__int128 *)v201, v200);
    std::string::basic_string[abi:nn180100]<0>(v198, "dh");
    std::string::basic_string[abi:nn180100]<0>(&v441, "でゃ");
    std::string::basic_string[abi:nn180100]<0>(v442, "でぃ");
    std::string::basic_string[abi:nn180100]<0>(v443, "でゅ");
    std::string::basic_string[abi:nn180100]<0>(v444, "でぇ");
    std::string::basic_string[abi:nn180100]<0>(v445, "でょ");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v197, &v441, 5uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v483, (__int128 *)v198, v197);
    std::string::basic_string[abi:nn180100]<0>(v195, "dw");
    std::string::basic_string[abi:nn180100]<0>(v439, "どぅ");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v194, (__int128 *)v439, 1uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v484, (__int128 *)v195, v194);
    std::string::basic_string[abi:nn180100]<0>(v192, "dy");
    std::string::basic_string[abi:nn180100]<0>(&v434, "ぢゃ");
    std::string::basic_string[abi:nn180100]<0>(v435, "ぢぃ");
    std::string::basic_string[abi:nn180100]<0>(v436, "ぢゅ");
    std::string::basic_string[abi:nn180100]<0>(v437, "ぢぇ");
    std::string::basic_string[abi:nn180100]<0>(v438, "ぢょ");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v191, &v434, 5uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v485, (__int128 *)v192, v191);
    std::string::basic_string[abi:nn180100]<0>(v189, "f");
    std::string::basic_string[abi:nn180100]<0>(v432, "ふ");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v188, (__int128 *)v432, 1uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v486, (__int128 *)v189, v188);
    std::string::basic_string[abi:nn180100]<0>(v186, "fy");
    std::string::basic_string[abi:nn180100]<0>(v430, "ふゅ");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v185, (__int128 *)v430, 1uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v487, (__int128 *)v186, v185);
    std::string::basic_string[abi:nn180100]<0>(v183, "g");
    std::string::basic_string[abi:nn180100]<0>(&v424, "っ");
    std::string::basic_string[abi:nn180100]<0>(v425, "が");
    std::string::basic_string[abi:nn180100]<0>(v426, "ぎ");
    std::string::basic_string[abi:nn180100]<0>(v427, "ぐ");
    std::string::basic_string[abi:nn180100]<0>(v428, "げ");
    std::string::basic_string[abi:nn180100]<0>(v429, "ご");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v182, &v424, 6uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v488, (__int128 *)v183, v182);
    std::string::basic_string[abi:nn180100]<0>(v180, "gw");
    std::string::basic_string[abi:nn180100]<0>(&v419, "ぐぁ");
    std::string::basic_string[abi:nn180100]<0>(v420, "ぐぃ");
    std::string::basic_string[abi:nn180100]<0>(v421, "ぐぅ");
    std::string::basic_string[abi:nn180100]<0>(v422, "ぐぇ");
    std::string::basic_string[abi:nn180100]<0>(v423, "ぐぉ");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v179, &v419, 5uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v489, (__int128 *)v180, v179);
    std::string::basic_string[abi:nn180100]<0>(v177, "gy");
    std::string::basic_string[abi:nn180100]<0>(&v414, "ぎゃ");
    std::string::basic_string[abi:nn180100]<0>(v415, "ぎぃ");
    std::string::basic_string[abi:nn180100]<0>(v416, "ぎゅ");
    std::string::basic_string[abi:nn180100]<0>(v417, "ぎぇ");
    std::string::basic_string[abi:nn180100]<0>(v418, "ぎょ");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v176, &v414, 5uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v490, (__int128 *)v177, v176);
    std::string::basic_string[abi:nn180100]<0>(v174, "h");
    std::string::basic_string[abi:nn180100]<0>(&v408, "っ");
    std::string::basic_string[abi:nn180100]<0>(v409, "は");
    std::string::basic_string[abi:nn180100]<0>(v410, "ひ");
    std::string::basic_string[abi:nn180100]<0>(v411, "ふ");
    std::string::basic_string[abi:nn180100]<0>(v412, "へ");
    std::string::basic_string[abi:nn180100]<0>(v413, "ほ");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v173, &v408, 6uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v491, (__int128 *)v174, v173);
    std::string::basic_string[abi:nn180100]<0>(v171, "hw");
    std::string::basic_string[abi:nn180100]<0>(&v403, "ふぁ");
    std::string::basic_string[abi:nn180100]<0>(v404, "ふぃ");
    std::string::basic_string[abi:nn180100]<0>(v405, "ふぇ");
    std::string::basic_string[abi:nn180100]<0>(v406, "ふぉ");
    std::string::basic_string[abi:nn180100]<0>(v407, "ふゅ");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v170, &v403, 5uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v492, (__int128 *)v171, v170);
    std::string::basic_string[abi:nn180100]<0>(v168, "hy");
    std::string::basic_string[abi:nn180100]<0>(&v398, "ひゃ");
    std::string::basic_string[abi:nn180100]<0>(v399, "ひぃ");
    std::string::basic_string[abi:nn180100]<0>(v400, "ひゅ");
    std::string::basic_string[abi:nn180100]<0>(v401, "ひぇ");
    std::string::basic_string[abi:nn180100]<0>(v402, "ひょ");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v167, &v398, 5uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v493, (__int128 *)v168, v167);
    std::string::basic_string[abi:nn180100]<0>(v165, "j");
    std::string::basic_string[abi:nn180100]<0>(&v396, "っ");
    std::string::basic_string[abi:nn180100]<0>(v397, "じ");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v164, &v396, 2uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v494, (__int128 *)v165, v164);
    std::string::basic_string[abi:nn180100]<0>(v162, "jy");
    std::string::basic_string[abi:nn180100]<0>(&v391, "じゃ");
    std::string::basic_string[abi:nn180100]<0>(v392, "じぃ");
    std::string::basic_string[abi:nn180100]<0>(v393, "じゅ");
    std::string::basic_string[abi:nn180100]<0>(v394, "じぇ");
    std::string::basic_string[abi:nn180100]<0>(v395, "じょ");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v161, &v391, 5uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v495, (__int128 *)v162, v161);
    std::string::basic_string[abi:nn180100]<0>(v159, "k");
    std::string::basic_string[abi:nn180100]<0>(&v385, "っ");
    std::string::basic_string[abi:nn180100]<0>(v386, "か");
    std::string::basic_string[abi:nn180100]<0>(v387, "き");
    std::string::basic_string[abi:nn180100]<0>(v388, "く");
    std::string::basic_string[abi:nn180100]<0>(v389, "け");
    std::string::basic_string[abi:nn180100]<0>(v390, "こ");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v158, &v385, 6uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v496, (__int128 *)v159, v158);
    std::string::basic_string[abi:nn180100]<0>(v156, "kw");
    std::string::basic_string[abi:nn180100]<0>(&v380, "くぁ");
    std::string::basic_string[abi:nn180100]<0>(v381, "くぃ");
    std::string::basic_string[abi:nn180100]<0>(v382, "くぅ");
    std::string::basic_string[abi:nn180100]<0>(v383, "くぇ");
    std::string::basic_string[abi:nn180100]<0>(v384, "くぉ");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v155, &v380, 5uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v497, (__int128 *)v156, v155);
    std::string::basic_string[abi:nn180100]<0>(v153, "ky");
    std::string::basic_string[abi:nn180100]<0>(&v375, "きゃ");
    std::string::basic_string[abi:nn180100]<0>(v376, "きぃ");
    std::string::basic_string[abi:nn180100]<0>(v377, "きゅ");
    std::string::basic_string[abi:nn180100]<0>(v378, "きぇ");
    std::string::basic_string[abi:nn180100]<0>(v379, "きょ");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v152, &v375, 5uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v498, (__int128 *)v153, v152);
    std::string::basic_string[abi:nn180100]<0>(v150, "l");
    std::string::basic_string[abi:nn180100]<0>(&v365, "っ");
    std::string::basic_string[abi:nn180100]<0>(v366, "ぁ");
    std::string::basic_string[abi:nn180100]<0>(v367, "ぃ");
    std::string::basic_string[abi:nn180100]<0>(v368, "ぅ");
    std::string::basic_string[abi:nn180100]<0>(v369, "ぇ");
    std::string::basic_string[abi:nn180100]<0>(v370, "ぉ");
    std::string::basic_string[abi:nn180100]<0>(v371, "ゃ");
    std::string::basic_string[abi:nn180100]<0>(v372, "ゅ");
    std::string::basic_string[abi:nn180100]<0>(v373, "ょ");
    std::string::basic_string[abi:nn180100]<0>(v374, "ゎ");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v149, &v365, 0xAuLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v499, (__int128 *)v150, v149);
    std::string::basic_string[abi:nn180100]<0>(v147, "lt");
    std::string::basic_string[abi:nn180100]<0>(v363, "っ");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v146, (__int128 *)v363, 1uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v500, (__int128 *)v147, v146);
    std::string::basic_string[abi:nn180100]<0>(v144, "lw");
    std::string::basic_string[abi:nn180100]<0>(v361, "ゎ");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v143, (__int128 *)v361, 1uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v501, (__int128 *)v144, v143);
    std::string::basic_string[abi:nn180100]<0>(v141, "ly");
    std::string::basic_string[abi:nn180100]<0>(&v356, "ゃ");
    std::string::basic_string[abi:nn180100]<0>(v357, "ぃ");
    std::string::basic_string[abi:nn180100]<0>(v358, "ゅ");
    std::string::basic_string[abi:nn180100]<0>(v359, "ぇ");
    std::string::basic_string[abi:nn180100]<0>(v360, "ょ");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v140, &v356, 5uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v502, (__int128 *)v141, v140);
    std::string::basic_string[abi:nn180100]<0>(v138, "m");
    std::string::basic_string[abi:nn180100]<0>(&v350, "っ");
    std::string::basic_string[abi:nn180100]<0>(v351, "ま");
    std::string::basic_string[abi:nn180100]<0>(v352, "み");
    std::string::basic_string[abi:nn180100]<0>(v353, "む");
    std::string::basic_string[abi:nn180100]<0>(v354, "め");
    std::string::basic_string[abi:nn180100]<0>(v355, "も");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v137, &v350, 6uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v503, (__int128 *)v138, v137);
    std::string::basic_string[abi:nn180100]<0>(v135, "my");
    std::string::basic_string[abi:nn180100]<0>(&v345, "みゃ");
    std::string::basic_string[abi:nn180100]<0>(v346, "みぃ");
    std::string::basic_string[abi:nn180100]<0>(v347, "みゅ");
    std::string::basic_string[abi:nn180100]<0>(v348, "みぇ");
    std::string::basic_string[abi:nn180100]<0>(v349, "みょ");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v134, &v345, 5uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v504, (__int128 *)v135, v134);
    std::string::basic_string[abi:nn180100]<0>(v132, "n");
    std::string::basic_string[abi:nn180100]<0>(&v338, "っ");
    std::string::basic_string[abi:nn180100]<0>(v339, "な");
    std::string::basic_string[abi:nn180100]<0>(v340, "に");
    std::string::basic_string[abi:nn180100]<0>(v341, "ぬ");
    std::string::basic_string[abi:nn180100]<0>(v342, "ね");
    std::string::basic_string[abi:nn180100]<0>(v343, "の");
    std::string::basic_string[abi:nn180100]<0>(v344, "ん");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v131, &v338, 7uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v505, (__int128 *)v132, v131);
    std::string::basic_string[abi:nn180100]<0>(v129, "ny");
    std::string::basic_string[abi:nn180100]<0>(&v333, "にゃ");
    std::string::basic_string[abi:nn180100]<0>(v334, "にぃ");
    std::string::basic_string[abi:nn180100]<0>(v335, "にゅ");
    std::string::basic_string[abi:nn180100]<0>(v336, "にぇ");
    std::string::basic_string[abi:nn180100]<0>(v337, "にょ");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v128, &v333, 5uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v506, (__int128 *)v129, v128);
    std::string::basic_string[abi:nn180100]<0>(v126, "p");
    std::string::basic_string[abi:nn180100]<0>(&v327, "っ");
    std::string::basic_string[abi:nn180100]<0>(v328, "ぱ");
    std::string::basic_string[abi:nn180100]<0>(v329, "ぴ");
    std::string::basic_string[abi:nn180100]<0>(v330, "ぷ");
    std::string::basic_string[abi:nn180100]<0>(v331, "ぺ");
    std::string::basic_string[abi:nn180100]<0>(v332, "ぽ");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v125, &v327, 6uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v507, (__int128 *)v126, v125);
    std::string::basic_string[abi:nn180100]<0>(v123, "py");
    std::string::basic_string[abi:nn180100]<0>(&v322, "ぴゃ");
    std::string::basic_string[abi:nn180100]<0>(v323, "ぴぃ");
    std::string::basic_string[abi:nn180100]<0>(v324, "ぴゅ");
    std::string::basic_string[abi:nn180100]<0>(v325, "ぴぇ");
    std::string::basic_string[abi:nn180100]<0>(v326, "ぴょ");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v122, &v322, 5uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v508, (__int128 *)v123, v122);
    std::string::basic_string[abi:nn180100]<0>(v120, "q");
    std::string::basic_string[abi:nn180100]<0>(v320, "く");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v119, (__int128 *)v320, 1uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v509, (__int128 *)v120, v119);
    std::string::basic_string[abi:nn180100]<0>(v117, "qy");
    std::string::basic_string[abi:nn180100]<0>(&v315, "くゃ");
    std::string::basic_string[abi:nn180100]<0>(v316, "くぃ");
    std::string::basic_string[abi:nn180100]<0>(v317, "くゅ");
    std::string::basic_string[abi:nn180100]<0>(v318, "くぇ");
    std::string::basic_string[abi:nn180100]<0>(v319, "くょ");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v116, &v315, 5uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v510, (__int128 *)v117, v116);
    std::string::basic_string[abi:nn180100]<0>(v114, "r");
    std::string::basic_string[abi:nn180100]<0>(&v309, "っ");
    std::string::basic_string[abi:nn180100]<0>(v310, "ら");
    std::string::basic_string[abi:nn180100]<0>(v311, "り");
    std::string::basic_string[abi:nn180100]<0>(v312, "る");
    std::string::basic_string[abi:nn180100]<0>(v313, "れ");
    std::string::basic_string[abi:nn180100]<0>(v314, "ろ");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v113, &v309, 6uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v511, (__int128 *)v114, v113);
    std::string::basic_string[abi:nn180100]<0>(v111, "ry");
    std::string::basic_string[abi:nn180100]<0>(&v304, "りゃ");
    std::string::basic_string[abi:nn180100]<0>(v305, "りぃ");
    std::string::basic_string[abi:nn180100]<0>(v306, "りゅ");
    std::string::basic_string[abi:nn180100]<0>(v307, "りぇ");
    std::string::basic_string[abi:nn180100]<0>(v308, "りょ");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v110, &v304, 5uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v512, (__int128 *)v111, v110);
    std::string::basic_string[abi:nn180100]<0>(v108, "s");
    std::string::basic_string[abi:nn180100]<0>(&v298, "っ");
    std::string::basic_string[abi:nn180100]<0>(v299, "さ");
    std::string::basic_string[abi:nn180100]<0>(v300, "し");
    std::string::basic_string[abi:nn180100]<0>(v301, "す");
    std::string::basic_string[abi:nn180100]<0>(v302, "せ");
    std::string::basic_string[abi:nn180100]<0>(v303, "そ");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v107, &v298, 6uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v513, (__int128 *)v108, v107);
    std::string::basic_string[abi:nn180100]<0>(v105, "sh");
    std::string::basic_string[abi:nn180100]<0>(v296, "し");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v104, (__int128 *)v296, 1uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v514, (__int128 *)v105, v104);
    std::string::basic_string[abi:nn180100]<0>(v102, "sy");
    std::string::basic_string[abi:nn180100]<0>(&v291, "しゃ");
    std::string::basic_string[abi:nn180100]<0>(v292, "しぃ");
    std::string::basic_string[abi:nn180100]<0>(v293, "しゅ");
    std::string::basic_string[abi:nn180100]<0>(v294, "しぇ");
    std::string::basic_string[abi:nn180100]<0>(v295, "しょ");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v101, &v291, 5uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v515, (__int128 *)v102, v101);
    std::string::basic_string[abi:nn180100]<0>(v99, "t");
    std::string::basic_string[abi:nn180100]<0>(&v285, "っ");
    std::string::basic_string[abi:nn180100]<0>(v286, "た");
    std::string::basic_string[abi:nn180100]<0>(v287, "ち");
    std::string::basic_string[abi:nn180100]<0>(v288, "つ");
    std::string::basic_string[abi:nn180100]<0>(v289, "て");
    std::string::basic_string[abi:nn180100]<0>(v290, "と");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v98, &v285, 6uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v516, (__int128 *)v99, v98);
    std::string::basic_string[abi:nn180100]<0>(v96, "th");
    std::string::basic_string[abi:nn180100]<0>(&v281, "てゃてぃ");
    std::string::basic_string[abi:nn180100]<0>(v282, "てゅ");
    std::string::basic_string[abi:nn180100]<0>(v283, "てぇ");
    std::string::basic_string[abi:nn180100]<0>(v284, "てょ");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v95, &v281, 4uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v517, (__int128 *)v96, v95);
    std::string::basic_string[abi:nn180100]<0>(v93, "ts");
    std::string::basic_string[abi:nn180100]<0>(v279, "つ");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v92, (__int128 *)v279, 1uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v518, (__int128 *)v93, v92);
    std::string::basic_string[abi:nn180100]<0>(v90, "tw");
    std::string::basic_string[abi:nn180100]<0>(v277, "とぅ");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v89, (__int128 *)v277, 1uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v519, (__int128 *)v90, v89);
    std::string::basic_string[abi:nn180100]<0>(v87, "ty");
    std::string::basic_string[abi:nn180100]<0>(&v272, "ちゃ");
    std::string::basic_string[abi:nn180100]<0>(v273, "ちぃ");
    std::string::basic_string[abi:nn180100]<0>(v274, "ちゅ");
    std::string::basic_string[abi:nn180100]<0>(v275, "ちぇ");
    std::string::basic_string[abi:nn180100]<0>(v276, "ちょ");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v86, &v272, 5uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v520, (__int128 *)v87, v86);
    std::string::basic_string[abi:nn180100]<0>(v84, "v");
    std::string::basic_string[abi:nn180100]<0>(&v270, "っ");
    std::string::basic_string[abi:nn180100]<0>(v271, "ゔ");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v83, &v270, 2uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v521, (__int128 *)v84, v83);
    std::string::basic_string[abi:nn180100]<0>(v81, "vy");
    std::string::basic_string[abi:nn180100]<0>(v268, "ゔゅ");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v80, (__int128 *)v268, 1uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v522, (__int128 *)v81, v80);
    std::string::basic_string[abi:nn180100]<0>(v78, "w");
    std::string::basic_string[abi:nn180100]<0>(&v262, "っ");
    std::string::basic_string[abi:nn180100]<0>(v263, "わ");
    std::string::basic_string[abi:nn180100]<0>(v264, "う");
    std::string::basic_string[abi:nn180100]<0>(v265, "を");
    std::string::basic_string[abi:nn180100]<0>(v266, "ゐ");
    std::string::basic_string[abi:nn180100]<0>(v267, "ゑ");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v77, &v262, 6uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v523, (__int128 *)v78, v77);
    std::string::basic_string[abi:nn180100]<0>(v75, "wh");
    std::string::basic_string[abi:nn180100]<0>(&v259, "うぃ");
    std::string::basic_string[abi:nn180100]<0>(v260, "うぇ");
    std::string::basic_string[abi:nn180100]<0>(v261, "うぉ");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v74, &v259, 3uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v524, (__int128 *)v75, v74);
    std::string::basic_string[abi:nn180100]<0>(v72, "wy");
    std::string::basic_string[abi:nn180100]<0>(&v257, "ゐ");
    std::string::basic_string[abi:nn180100]<0>(v258, "ゑ");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v71, &v257, 2uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v525, (__int128 *)v72, v71);
    std::string::basic_string[abi:nn180100]<0>(v69, "x");
    std::string::basic_string[abi:nn180100]<0>(&v247, "っ");
    std::string::basic_string[abi:nn180100]<0>(v248, "ぁ");
    std::string::basic_string[abi:nn180100]<0>(v249, "ぃ");
    std::string::basic_string[abi:nn180100]<0>(v250, "ぅ");
    std::string::basic_string[abi:nn180100]<0>(v251, "ぇ");
    std::string::basic_string[abi:nn180100]<0>(v252, "ぉ");
    std::string::basic_string[abi:nn180100]<0>(v253, "ゃ");
    std::string::basic_string[abi:nn180100]<0>(v254, "ゅ");
    std::string::basic_string[abi:nn180100]<0>(v255, "ょ");
    std::string::basic_string[abi:nn180100]<0>(v256, "ゎ");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v68, &v247, 0xAuLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v526, (__int128 *)v69, v68);
    std::string::basic_string[abi:nn180100]<0>(v66, "xt");
    std::string::basic_string[abi:nn180100]<0>(v245, "っ");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v65, (__int128 *)v245, 1uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v527, (__int128 *)v66, v65);
    std::string::basic_string[abi:nn180100]<0>(v63, "xts");
    std::string::basic_string[abi:nn180100]<0>(v243, "っ");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v62, (__int128 *)v243, 1uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v528, (__int128 *)v63, v62);
    std::string::basic_string[abi:nn180100]<0>(v60, "xw");
    std::string::basic_string[abi:nn180100]<0>(v241, "ゎ");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v59, (__int128 *)v241, 1uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v529, (__int128 *)v60, v59);
    std::string::basic_string[abi:nn180100]<0>(v57, "xy");
    std::string::basic_string[abi:nn180100]<0>(&v236, "ゃ");
    std::string::basic_string[abi:nn180100]<0>(v237, "ぃ");
    std::string::basic_string[abi:nn180100]<0>(v238, "ゅ");
    std::string::basic_string[abi:nn180100]<0>(v239, "ぇ");
    std::string::basic_string[abi:nn180100]<0>(v240, "ょ");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v56, &v236, 5uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v530, (__int128 *)v57, v56);
    std::string::basic_string[abi:nn180100]<0>(v54, "y");
    std::string::basic_string[abi:nn180100]<0>(&v230, "っ");
    std::string::basic_string[abi:nn180100]<0>(v231, "や");
    std::string::basic_string[abi:nn180100]<0>(v232, "い");
    std::string::basic_string[abi:nn180100]<0>(v233, "ゆ");
    std::string::basic_string[abi:nn180100]<0>(v234, "いぇ");
    std::string::basic_string[abi:nn180100]<0>(v235, "よ");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v53, &v230, 6uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v531, (__int128 *)v54, v53);
    std::string::basic_string[abi:nn180100]<0>(v51, "z");
    std::string::basic_string[abi:nn180100]<0>(&v224, "っ");
    std::string::basic_string[abi:nn180100]<0>(v225, "ざ");
    std::string::basic_string[abi:nn180100]<0>(v226, "じ");
    std::string::basic_string[abi:nn180100]<0>(v227, "ず");
    std::string::basic_string[abi:nn180100]<0>(v228, "ぜ");
    std::string::basic_string[abi:nn180100]<0>(v229, "ぞ");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v50, &v224, 6uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v532, (__int128 *)v51, v50);
    std::string::basic_string[abi:nn180100]<0>(__p, "zy");
    std::string::basic_string[abi:nn180100]<0>(&v219, "じゃ");
    std::string::basic_string[abi:nn180100]<0>(v220, "じぃ");
    std::string::basic_string[abi:nn180100]<0>(v221, "じゅ");
    std::string::basic_string[abi:nn180100]<0>(v222, "じぇ");
    std::string::basic_string[abi:nn180100]<0>(v223, "じょ");
    std::vector<std::string>::vector[abi:nn180100]((uint64_t)v47, &v219, 5uLL);
    std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(v533, (__int128 *)__p, v47);
    v2 = 0;
    incompleteRomajiKanaData(void)::data = 0u;
    *(_OWORD *)&qword_1EF1AE210 = 0u;
    dword_1EF1AE220 = 1065353216;
    do
    {
      std::__hash_table<std::__hash_value_type<std::string,std::vector<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::string>>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,std::vector<std::string>> const&>((uint64_t)&v477[v2], (uint64_t)&v477[v2]);
      v2 += 2;
    }
    while (v2 != 114);
    for (i = 2688; i != -48; i -= 48)
      std::pair<std::string const,std::vector<std::string>>::~pair((uint64_t)&v477[i / 0x18]);
    v218 = v47;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v218);
    for (j = 0; j != -15; j -= 3)
    {
      if (SHIBYTE(v223[j + 2]) < 0)
        operator delete((void *)v223[j]);
    }
    if (v49 < 0)
      operator delete(__p[0]);
    *(_QWORD *)&v219 = v50;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v219);
    for (k = 0; k != -18; k -= 3)
    {
      if (SHIBYTE(v229[k + 2]) < 0)
        operator delete((void *)v229[k]);
    }
    if (v52 < 0)
      operator delete(v51[0]);
    *(_QWORD *)&v224 = v53;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v224);
    for (m = 0; m != -18; m -= 3)
    {
      if (SHIBYTE(v235[m + 2]) < 0)
        operator delete((void *)v235[m]);
    }
    if (v55 < 0)
      operator delete(v54[0]);
    *(_QWORD *)&v230 = v56;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v230);
    for (n = 0; n != -15; n -= 3)
    {
      if (SHIBYTE(v240[n + 2]) < 0)
        operator delete(v240[n]);
    }
    if (v58 < 0)
      operator delete(v57[0]);
    *(_QWORD *)&v230 = v59;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v230);
    if (v242 < 0)
      operator delete(v241[0]);
    if (v61 < 0)
      operator delete(v60[0]);
    *(_QWORD *)&v230 = v62;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v230);
    if (v244 < 0)
      operator delete(v243[0]);
    if (v64 < 0)
      operator delete(v63[0]);
    *(_QWORD *)&v230 = v65;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v230);
    if (v246 < 0)
      operator delete(v245[0]);
    if (v67 < 0)
      operator delete(v66[0]);
    *(_QWORD *)&v230 = v68;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v230);
    for (ii = 0; ii != -30; ii -= 3)
    {
      if (SHIBYTE(v256[ii + 2]) < 0)
        operator delete((void *)v256[ii]);
    }
    if (v70 < 0)
      operator delete(v69[0]);
    *(_QWORD *)&v247 = v71;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v247);
    for (jj = 0; jj != -6; jj -= 3)
    {
      if (SHIBYTE(v258[jj + 2]) < 0)
        operator delete((void *)v258[jj]);
    }
    if (v73 < 0)
      operator delete(v72[0]);
    *(_QWORD *)&v247 = v74;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v247);
    for (kk = 0; kk != -9; kk -= 3)
    {
      if (SHIBYTE(v261[kk + 2]) < 0)
        operator delete((void *)v261[kk]);
    }
    if (v76 < 0)
      operator delete(v75[0]);
    *(_QWORD *)&v247 = v77;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v247);
    for (mm = 0; mm != -18; mm -= 3)
    {
      if (SHIBYTE(v267[mm + 2]) < 0)
        operator delete(v267[mm]);
    }
    if (v79 < 0)
      operator delete(v78[0]);
    *(_QWORD *)&v247 = v80;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v247);
    if (v269 < 0)
      operator delete(v268[0]);
    if (v82 < 0)
      operator delete(v81[0]);
    *(_QWORD *)&v247 = v83;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v247);
    for (nn = 0; nn != -6; nn -= 3)
    {
      if (SHIBYTE(v271[nn + 2]) < 0)
        operator delete((void *)v271[nn]);
    }
    if (v85 < 0)
      operator delete(v84[0]);
    *(_QWORD *)&v247 = v86;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v247);
    for (i1 = 0; i1 != -15; i1 -= 3)
    {
      if (SHIBYTE(v276[i1 + 2]) < 0)
        operator delete(v276[i1]);
    }
    if (v88 < 0)
      operator delete(v87[0]);
    *(_QWORD *)&v247 = v89;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v247);
    if (v278 < 0)
      operator delete(v277[0]);
    if (v91 < 0)
      operator delete(v90[0]);
    *(_QWORD *)&v247 = v92;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v247);
    if (v280 < 0)
      operator delete(v279[0]);
    if (v94 < 0)
      operator delete(v93[0]);
    *(_QWORD *)&v247 = v95;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v247);
    for (i2 = 0; i2 != -12; i2 -= 3)
    {
      if (SHIBYTE(v284[i2 + 2]) < 0)
        operator delete((void *)v284[i2]);
    }
    if (v97 < 0)
      operator delete(v96[0]);
    *(_QWORD *)&v247 = v98;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v247);
    for (i3 = 0; i3 != -18; i3 -= 3)
    {
      if (SHIBYTE(v290[i3 + 2]) < 0)
        operator delete((void *)v290[i3]);
    }
    if (v100 < 0)
      operator delete(v99[0]);
    *(_QWORD *)&v247 = v101;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v247);
    for (i4 = 0; i4 != -15; i4 -= 3)
    {
      if (SHIBYTE(v295[i4 + 2]) < 0)
        operator delete(v295[i4]);
    }
    if (v103 < 0)
      operator delete(v102[0]);
    *(_QWORD *)&v247 = v104;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v247);
    if (v297 < 0)
      operator delete(v296[0]);
    if (v106 < 0)
      operator delete(v105[0]);
    *(_QWORD *)&v247 = v107;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v247);
    for (i5 = 0; i5 != -18; i5 -= 3)
    {
      if (SHIBYTE(v303[i5 + 2]) < 0)
        operator delete((void *)v303[i5]);
    }
    if (v109 < 0)
      operator delete(v108[0]);
    *(_QWORD *)&v247 = v110;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v247);
    for (i6 = 0; i6 != -15; i6 -= 3)
    {
      if (SHIBYTE(v308[i6 + 2]) < 0)
        operator delete((void *)v308[i6]);
    }
    if (v112 < 0)
      operator delete(v111[0]);
    *(_QWORD *)&v247 = v113;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v247);
    for (i7 = 0; i7 != -18; i7 -= 3)
    {
      if (SHIBYTE(v314[i7 + 2]) < 0)
        operator delete((void *)v314[i7]);
    }
    if (v115 < 0)
      operator delete(v114[0]);
    *(_QWORD *)&v247 = v116;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v247);
    for (i8 = 0; i8 != -15; i8 -= 3)
    {
      if (SHIBYTE(v319[i8 + 2]) < 0)
        operator delete(v319[i8]);
    }
    if (v118 < 0)
      operator delete(v117[0]);
    *(_QWORD *)&v247 = v119;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v247);
    if (v321 < 0)
      operator delete(v320[0]);
    if (v121 < 0)
      operator delete(v120[0]);
    *(_QWORD *)&v247 = v122;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v247);
    for (i9 = 0; i9 != -15; i9 -= 3)
    {
      if (SHIBYTE(v326[i9 + 2]) < 0)
        operator delete((void *)v326[i9]);
    }
    if (v124 < 0)
      operator delete(v123[0]);
    *(_QWORD *)&v247 = v125;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v247);
    for (i10 = 0; i10 != -18; i10 -= 3)
    {
      if (SHIBYTE(v332[i10 + 2]) < 0)
        operator delete((void *)v332[i10]);
    }
    if (v127 < 0)
      operator delete(v126[0]);
    *(_QWORD *)&v247 = v128;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v247);
    for (i11 = 0; i11 != -15; i11 -= 3)
    {
      if (SHIBYTE(v337[i11 + 2]) < 0)
        operator delete((void *)v337[i11]);
    }
    if (v130 < 0)
      operator delete(v129[0]);
    *(_QWORD *)&v247 = v131;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v247);
    for (i12 = 0; i12 != -21; i12 -= 3)
    {
      if (SHIBYTE(v344[i12 + 2]) < 0)
        operator delete((void *)v344[i12]);
    }
    if (v133 < 0)
      operator delete(v132[0]);
    *(_QWORD *)&v247 = v134;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v247);
    for (i13 = 0; i13 != -15; i13 -= 3)
    {
      if (SHIBYTE(v349[i13 + 2]) < 0)
        operator delete((void *)v349[i13]);
    }
    if (v136 < 0)
      operator delete(v135[0]);
    *(_QWORD *)&v247 = v137;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v247);
    for (i14 = 0; i14 != -18; i14 -= 3)
    {
      if (SHIBYTE(v355[i14 + 2]) < 0)
        operator delete((void *)v355[i14]);
    }
    if (v139 < 0)
      operator delete(v138[0]);
    *(_QWORD *)&v247 = v140;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v247);
    for (i15 = 0; i15 != -15; i15 -= 3)
    {
      if (SHIBYTE(v360[i15 + 2]) < 0)
        operator delete(v360[i15]);
    }
    if (v142 < 0)
      operator delete(v141[0]);
    *(_QWORD *)&v247 = v143;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v247);
    if (v362 < 0)
      operator delete(v361[0]);
    if (v145 < 0)
      operator delete(v144[0]);
    *(_QWORD *)&v247 = v146;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v247);
    if (v364 < 0)
      operator delete(v363[0]);
    if (v148 < 0)
      operator delete(v147[0]);
    *(_QWORD *)&v247 = v149;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v247);
    for (i16 = 0; i16 != -30; i16 -= 3)
    {
      if (SHIBYTE(v374[i16 + 2]) < 0)
        operator delete((void *)v374[i16]);
    }
    if (v151 < 0)
      operator delete(v150[0]);
    *(_QWORD *)&v365 = v152;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v365);
    for (i17 = 0; i17 != -15; i17 -= 3)
    {
      if (SHIBYTE(v379[i17 + 2]) < 0)
        operator delete((void *)v379[i17]);
    }
    if (v154 < 0)
      operator delete(v153[0]);
    *(_QWORD *)&v365 = v155;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v365);
    for (i18 = 0; i18 != -15; i18 -= 3)
    {
      if (SHIBYTE(v384[i18 + 2]) < 0)
        operator delete((void *)v384[i18]);
    }
    if (v157 < 0)
      operator delete(v156[0]);
    *(_QWORD *)&v365 = v158;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v365);
    for (i19 = 0; i19 != -18; i19 -= 3)
    {
      if (SHIBYTE(v390[i19 + 2]) < 0)
        operator delete((void *)v390[i19]);
    }
    if (v160 < 0)
      operator delete(v159[0]);
    *(_QWORD *)&v365 = v161;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v365);
    for (i20 = 0; i20 != -15; i20 -= 3)
    {
      if (SHIBYTE(v395[i20 + 2]) < 0)
        operator delete((void *)v395[i20]);
    }
    if (v163 < 0)
      operator delete(v162[0]);
    *(_QWORD *)&v365 = v164;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v365);
    for (i21 = 0; i21 != -6; i21 -= 3)
    {
      if (SHIBYTE(v397[i21 + 2]) < 0)
        operator delete((void *)v397[i21]);
    }
    if (v166 < 0)
      operator delete(v165[0]);
    *(_QWORD *)&v365 = v167;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v365);
    for (i22 = 0; i22 != -15; i22 -= 3)
    {
      if (SHIBYTE(v402[i22 + 2]) < 0)
        operator delete((void *)v402[i22]);
    }
    if (v169 < 0)
      operator delete(v168[0]);
    *(_QWORD *)&v365 = v170;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v365);
    for (i23 = 0; i23 != -15; i23 -= 3)
    {
      if (SHIBYTE(v407[i23 + 2]) < 0)
        operator delete((void *)v407[i23]);
    }
    if (v172 < 0)
      operator delete(v171[0]);
    *(_QWORD *)&v365 = v173;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v365);
    for (i24 = 0; i24 != -18; i24 -= 3)
    {
      if (SHIBYTE(v413[i24 + 2]) < 0)
        operator delete((void *)v413[i24]);
    }
    if (v175 < 0)
      operator delete(v174[0]);
    *(_QWORD *)&v365 = v176;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v365);
    for (i25 = 0; i25 != -15; i25 -= 3)
    {
      if (SHIBYTE(v418[i25 + 2]) < 0)
        operator delete((void *)v418[i25]);
    }
    if (v178 < 0)
      operator delete(v177[0]);
    *(_QWORD *)&v365 = v179;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v365);
    for (i26 = 0; i26 != -15; i26 -= 3)
    {
      if (SHIBYTE(v423[i26 + 2]) < 0)
        operator delete((void *)v423[i26]);
    }
    if (v181 < 0)
      operator delete(v180[0]);
    *(_QWORD *)&v365 = v182;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v365);
    for (i27 = 0; i27 != -18; i27 -= 3)
    {
      if (SHIBYTE(v429[i27 + 2]) < 0)
        operator delete(v429[i27]);
    }
    if (v184 < 0)
      operator delete(v183[0]);
    *(_QWORD *)&v365 = v185;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v365);
    if (v431 < 0)
      operator delete(v430[0]);
    if (v187 < 0)
      operator delete(v186[0]);
    *(_QWORD *)&v365 = v188;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v365);
    if (v433 < 0)
      operator delete(v432[0]);
    if (v190 < 0)
      operator delete(v189[0]);
    *(_QWORD *)&v365 = v191;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v365);
    for (i28 = 0; i28 != -15; i28 -= 3)
    {
      if (SHIBYTE(v438[i28 + 2]) < 0)
        operator delete(v438[i28]);
    }
    if (v193 < 0)
      operator delete(v192[0]);
    *(_QWORD *)&v365 = v194;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v365);
    if (v440 < 0)
      operator delete(v439[0]);
    if (v196 < 0)
      operator delete(v195[0]);
    *(_QWORD *)&v365 = v197;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v365);
    for (i29 = 0; i29 != -15; i29 -= 3)
    {
      if (SHIBYTE(v445[i29 + 2]) < 0)
        operator delete((void *)v445[i29]);
    }
    if (v199 < 0)
      operator delete(v198[0]);
    *(_QWORD *)&v365 = v200;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v365);
    for (i30 = 0; i30 != -18; i30 -= 3)
    {
      if (SHIBYTE(v451[i30 + 2]) < 0)
        operator delete((void *)v451[i30]);
    }
    if (v202 < 0)
      operator delete(v201[0]);
    *(_QWORD *)&v365 = v203;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v365);
    for (i31 = 0; i31 != -15; i31 -= 3)
    {
      if (SHIBYTE(v456[i31 + 2]) < 0)
        operator delete(v456[i31]);
    }
    if (v205 < 0)
      operator delete(v204[0]);
    *(_QWORD *)&v365 = v206;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v365);
    if (v458 < 0)
      operator delete(v457[0]);
    if (v208 < 0)
      operator delete(v207[0]);
    *(_QWORD *)&v365 = v209;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v365);
    for (i32 = 0; i32 != -21; i32 -= 3)
    {
      if (SHIBYTE(v465[i32 + 2]) < 0)
        operator delete((void *)v465[i32]);
    }
    if (v211 < 0)
      operator delete(v210[0]);
    *(_QWORD *)&v365 = v212;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v365);
    for (i33 = 0; i33 != -15; i33 -= 3)
    {
      if (SHIBYTE(v470[i33 + 2]) < 0)
        operator delete((void *)v470[i33]);
    }
    if (v214 < 0)
      operator delete(v213[0]);
    *(_QWORD *)&v365 = v215;
    std::vector<std::string>::__destroy_vector::operator()[abi:nn180100]((void ***)&v365);
    for (i34 = 0; i34 != -18; i34 -= 3)
    {
      if (SHIBYTE(v476[i34 + 2]) < 0)
        operator delete((void *)v476[i34]);
    }
    if (v217 < 0)
      operator delete(v216[0]);
    __cxa_atexit((void (*)(void *))std::unordered_map<std::string,std::vector<std::string>>::~unordered_map[abi:nn180100], &incompleteRomajiKanaData(void)::data, &dword_1B8270000);
  }
}

uint64_t std::vector<std::string>::vector[abi:nn180100](uint64_t a1, __int128 *a2, unint64_t a3)
{
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  if (a3)
  {
    std::vector<std::string>::__vallocate[abi:nn180100]((_QWORD *)a1, a3);
    *(_QWORD *)(a1 + 8) = std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<std::string>,std::string const*,std::string const*,std::string*>(a2, (__int128 *)((char *)a2 + 24 * a3), *(std::string **)(a1 + 8));
  }
  return a1;
}

std::string *std::pair<std::string const,std::vector<std::string>>::pair[abi:nn180100]<true,0>(std::string *this, __int128 *a2, __int128 **a3)
{
  __int128 v5;

  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v5 = *a2;
    this->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v5;
  }
  this[1].__r_.__value_.__l.__size_ = 0;
  this[1].__r_.__value_.__r.__words[2] = 0;
  this[1].__r_.__value_.__r.__words[0] = 0;
  std::vector<std::string>::__init_with_size[abi:nn180100]<std::string*,std::string*>(this[1].__r_.__value_.__r.__words, *a3, a3[1], 0xAAAAAAAAAAAAAAABLL * (((char *)a3[1] - (char *)*a3) >> 3));
  return this;
}

void std::__hash_table<std::__hash_value_type<std::string,std::vector<std::string>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<std::string>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<std::string>>>>::__emplace_unique_key_args<std::string,std::pair<std::string const,std::vector<std::string>> const&>(uint64_t a1, uint64_t a2)
{
  unsigned __int8 *v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint8x8_t v9;
  unint64_t v10;
  unint64_t v11;
  unsigned __int8 **v12;
  unsigned __int8 *i;
  unint64_t v14;
  _QWORD *v15;
  std::string *v16;
  float v17;
  _BOOL8 v18;
  unint64_t v19;
  unint64_t v20;
  int8x8_t prime;
  void *v22;
  void *v23;
  uint64_t v24;
  _QWORD **v25;
  unint64_t v26;
  uint8x8_t v27;
  unint64_t v28;
  uint8x8_t v29;
  uint64_t v30;
  _QWORD *j;
  unint64_t v32;
  uint64_t v33;
  _QWORD *v34;
  uint64_t v35;
  unint64_t v36;
  void *v37;

  v3 = (unsigned __int8 *)a1;
  v4 = *(_QWORD *)(a1 + 8);
  if (*(char *)(a1 + 23) >= 0)
  {
    v5 = *(unsigned __int8 *)(a1 + 23);
  }
  else
  {
    a1 = *(_QWORD *)a1;
    v5 = v4;
  }
  v6 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t *)a1, v5);
  v7 = v6;
  v8 = *((_QWORD *)&incompleteRomajiKanaData(void)::data + 1);
  if (*((_QWORD *)&incompleteRomajiKanaData(void)::data + 1))
  {
    v9 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&incompleteRomajiKanaData(void)::data + 8));
    v9.i16[0] = vaddlv_u8(v9);
    v10 = v9.u32[0];
    if (v9.u32[0] > 1uLL)
    {
      v11 = v6;
      if (v6 >= *((_QWORD *)&incompleteRomajiKanaData(void)::data + 1))
        v11 = v6 % *((_QWORD *)&incompleteRomajiKanaData(void)::data + 1);
    }
    else
    {
      v11 = (*((_QWORD *)&incompleteRomajiKanaData(void)::data + 1) - 1) & v6;
    }
    v12 = *(unsigned __int8 ***)(incompleteRomajiKanaData(void)::data + 8 * v11);
    if (v12)
    {
      for (i = *v12; i; i = *(unsigned __int8 **)i)
      {
        v14 = *((_QWORD *)i + 1);
        if (v14 == v7)
        {
          if (std::equal_to<std::string>::operator()[abi:nn180100](i + 16, v3))
            return;
        }
        else
        {
          if (v10 > 1)
          {
            if (v14 >= v8)
              v14 %= v8;
          }
          else
          {
            v14 &= v8 - 1;
          }
          if (v14 != v11)
            break;
        }
      }
    }
  }
  else
  {
    v11 = 0;
  }
  v15 = operator new(0x40uLL);
  *v15 = 0;
  v15[1] = v7;
  v16 = (std::string *)(v15 + 2);
  if (*(char *)(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v16, *(const std::string::value_type **)a2, *(_QWORD *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)&v16->__r_.__value_.__l.__data_ = *(_OWORD *)a2;
    v15[4] = *(_QWORD *)(a2 + 16);
  }
  v15[5] = 0;
  v15[6] = 0;
  v15[7] = 0;
  std::vector<std::string>::__init_with_size[abi:nn180100]<std::string*,std::string*>(v15 + 5, *(__int128 **)(a2 + 24), *(__int128 **)(a2 + 32), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a2 + 32) - *(_QWORD *)(a2 + 24)) >> 3));
  v17 = (float)(unint64_t)(qword_1EF1AE218 + 1);
  if (!v8 || (float)(*(float *)&dword_1EF1AE220 * (float)v8) < v17)
  {
    v18 = 1;
    if (v8 >= 3)
      v18 = (v8 & (v8 - 1)) != 0;
    v19 = v18 | (2 * v8);
    v20 = vcvtps_u32_f32(v17 / *(float *)&dword_1EF1AE220);
    if (v19 <= v20)
      prime = (int8x8_t)v20;
    else
      prime = (int8x8_t)v19;
    if (*(_QWORD *)&prime == 1)
    {
      prime = (int8x8_t)2;
    }
    else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
    {
      prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
    }
    v8 = *((_QWORD *)&incompleteRomajiKanaData(void)::data + 1);
    if (*(_QWORD *)&prime > *((_QWORD *)&incompleteRomajiKanaData(void)::data + 1))
      goto LABEL_36;
    if (*(_QWORD *)&prime < *((_QWORD *)&incompleteRomajiKanaData(void)::data + 1))
    {
      v28 = vcvtps_u32_f32((float)(unint64_t)qword_1EF1AE218 / *(float *)&dword_1EF1AE220);
      if (*((_QWORD *)&incompleteRomajiKanaData(void)::data + 1) < 3uLL
        || (v29 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&incompleteRomajiKanaData(void)::data + 8)),
            v29.i16[0] = vaddlv_u8(v29),
            v29.u32[0] > 1uLL))
      {
        v28 = std::__next_prime(v28);
      }
      else
      {
        v30 = 1 << -(char)__clz(v28 - 1);
        if (v28 >= 2)
          v28 = v30;
      }
      if (*(_QWORD *)&prime <= v28)
        prime = (int8x8_t)v28;
      if (*(_QWORD *)&prime >= v8)
      {
        v8 = *((_QWORD *)&incompleteRomajiKanaData(void)::data + 1);
      }
      else
      {
        if (prime)
        {
LABEL_36:
          if (*(_QWORD *)&prime >> 61)
            std::__throw_bad_array_new_length[abi:nn180100]();
          v22 = operator new(8 * *(_QWORD *)&prime);
          v23 = (void *)incompleteRomajiKanaData(void)::data;
          *(_QWORD *)&incompleteRomajiKanaData(void)::data = v22;
          if (v23)
            operator delete(v23);
          v24 = 0;
          *((int8x8_t *)&incompleteRomajiKanaData(void)::data + 1) = prime;
          do
            *(_QWORD *)(incompleteRomajiKanaData(void)::data + 8 * v24++) = 0;
          while (*(_QWORD *)&prime != v24);
          v25 = (_QWORD **)qword_1EF1AE210;
          if (qword_1EF1AE210)
          {
            v26 = *(_QWORD *)(qword_1EF1AE210 + 8);
            v27 = (uint8x8_t)vcnt_s8(prime);
            v27.i16[0] = vaddlv_u8(v27);
            if (v27.u32[0] > 1uLL)
            {
              if (v26 >= *(_QWORD *)&prime)
                v26 %= *(_QWORD *)&prime;
            }
            else
            {
              v26 &= *(_QWORD *)&prime - 1;
            }
            *(_QWORD *)(incompleteRomajiKanaData(void)::data + 8 * v26) = &qword_1EF1AE210;
            for (j = *v25; j; v26 = v32)
            {
              v32 = j[1];
              if (v27.u32[0] > 1uLL)
              {
                if (v32 >= *(_QWORD *)&prime)
                  v32 %= *(_QWORD *)&prime;
              }
              else
              {
                v32 &= *(_QWORD *)&prime - 1;
              }
              if (v32 != v26)
              {
                if (!*(_QWORD *)(incompleteRomajiKanaData(void)::data + 8 * v32))
                {
                  *(_QWORD *)(incompleteRomajiKanaData(void)::data + 8 * v32) = v25;
                  goto LABEL_61;
                }
                *v25 = (_QWORD *)*j;
                *j = **(_QWORD **)(incompleteRomajiKanaData(void)::data + 8 * v32);
                **(_QWORD **)(incompleteRomajiKanaData(void)::data + 8 * v32) = j;
                j = v25;
              }
              v32 = v26;
LABEL_61:
              v25 = (_QWORD **)j;
              j = (_QWORD *)*j;
            }
          }
          v8 = (unint64_t)prime;
          goto LABEL_65;
        }
        v37 = (void *)incompleteRomajiKanaData(void)::data;
        *(_QWORD *)&incompleteRomajiKanaData(void)::data = 0;
        if (v37)
          operator delete(v37);
        v8 = 0;
        *((_QWORD *)&incompleteRomajiKanaData(void)::data + 1) = 0;
      }
    }
LABEL_65:
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8)
        v11 = v7 % v8;
      else
        v11 = v7;
    }
    else
    {
      v11 = (v8 - 1) & v7;
    }
  }
  v33 = incompleteRomajiKanaData(void)::data;
  v34 = *(_QWORD **)(incompleteRomajiKanaData(void)::data + 8 * v11);
  if (v34)
  {
    *v15 = *v34;
LABEL_78:
    *v34 = v15;
    goto LABEL_79;
  }
  v35 = qword_1EF1AE210;
  *v15 = qword_1EF1AE210;
  qword_1EF1AE210 = (uint64_t)v15;
  *(_QWORD *)(v33 + 8 * v11) = &qword_1EF1AE210;
  if (v35)
  {
    v36 = *(_QWORD *)(v35 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v36 >= v8)
        v36 %= v8;
    }
    else
    {
      v36 &= v8 - 1;
    }
    v34 = (_QWORD *)(incompleteRomajiKanaData(void)::data + 8 * v36);
    goto LABEL_78;
  }
LABEL_79:
  ++qword_1EF1AE218;
}

uint64_t std::pair<std::string const,std::vector<std::string>>::~pair(uint64_t a1)
{
  void **v3;

  v3 = (void **)(a1 + 24);
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v3);
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t std::unordered_map<std::string,std::vector<std::string>>::~unordered_map[abi:nn180100](uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;

  v2 = *(_QWORD **)(a1 + 16);
  if (v2)
  {
    do
    {
      v3 = (_QWORD *)*v2;
      std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::vector<std::string>>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v4)
    operator delete(v4);
  return a1;
}

void std::__destroy_at[abi:nn180100]<std::pair<std::string const,std::vector<std::string>>,0>(uint64_t a1)
{
  void **v2;

  v2 = (void **)(a1 + 24);
  std::vector<std::string>::__destroy_vector::operator()[abi:nn180100](&v2);
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

std::string *std::__uninitialized_allocator_copy[abi:nn180100]<std::allocator<std::string>,std::string const*,std::string const*,std::string*>(__int128 *a1, __int128 *a2, std::string *this)
{
  __int128 *v5;
  __int128 v6;

  if (a1 != a2)
  {
    v5 = a1;
    do
    {
      if (*((char *)v5 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)v5, *((_QWORD *)v5 + 1));
      }
      else
      {
        v6 = *v5;
        this->__r_.__value_.__r.__words[2] = *((_QWORD *)v5 + 2);
        *(_OWORD *)&this->__r_.__value_.__l.__data_ = v6;
      }
      v5 = (__int128 *)((char *)v5 + 24);
      ++this;
    }
    while (v5 != a2);
  }
  return this;
}

__n128 SICompletionModelProcessUTF8String(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _OWORD *a6, uint64_t a7, UErrorCode a8, const char *a9, int a10, const char *a11, unsigned __int8 a12, uint64_t a13)
{
  __int128 v13;
  __int128 v14;
  __n128 result;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  _OWORD v25[5];

  if (a1)
  {
    if ((*(_BYTE *)(a1 + 4) & 1) != 0)
    {
      v18 = a6[3];
      v25[2] = a6[2];
      v25[3] = v18;
      v25[4] = a6[4];
      v19 = a6[1];
      v25[0] = *a6;
      v25[1] = v19;
      insertLegacyNGramsFromUTF8StringWithPatternAndLock(a1, a2, a3, a4, a5, (uint64_t)v25, a13, a7, a10, a11, a12, (os_unfair_lock_s *)(a1 + 48));
    }
    else
    {
      v13 = a6[3];
      v22 = a6[2];
      v23 = v13;
      v24 = a6[4];
      v14 = a6[1];
      v20 = *a6;
      v21 = v14;
      generateCompletionsFromUTF8StringWithPatternAndLock(a1, a2, a3, a4, a5, (uint64_t)&v20, a13, a7, a8, a9, a10, a11, a12, (os_unfair_lock_s *)(a1 + 48));
    }
  }
  else
  {
    v16 = a6[3];
    v22 = a6[2];
    v23 = v16;
    v24 = a6[4];
    v17 = a6[1];
    v20 = *a6;
    v21 = v17;
    generateCompletionsFromUTF8StringWithPatternAndLock(0, a2, a3, a4, a5, (uint64_t)&v20, a13, a7, a8, a9, a10, a11, a12, 0);
  }
  return result;
}

void insertLegacyNGramsFromUTF8StringWithPatternAndLock(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, const char *a10, unsigned __int8 a11, os_unfair_lock_s *a12)
{
  uint64_t v12;
  const char **v13;
  uint64_t v14;
  uint64_t v15;
  _OWORD *v16;
  _OWORD *v17;
  unint64_t v18;
  unint64_t v19;
  const char *v20;
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  const char *v25;
  _BOOL4 v26;
  unsigned int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  _BOOL4 v35;
  unsigned __int8 v36;
  int v37;
  int32_t v38;
  const __CFString *v39;
  CFIndex Length;
  uint64_t v41;
  UInt8 *v42;
  size_t v43;
  const char *v44;
  __int128 v45;
  __int128 v46;
  unsigned __int8 *v47;
  unsigned __int8 *v48;
  const char *v49;
  int32_t v50;
  int32_t v51;
  CFStringRef v52;
  CFStringRef v53;
  uint64_t v54;
  const __CFString *v55;
  unsigned int v56;
  int v57;
  uint64_t v58;
  int v59;
  uint64_t v60;
  unint64_t v61;
  CFIndex v62;
  uint64_t v63;
  unint64_t v64;
  CFIndex *v65;
  CFIndex v66;
  uint64_t v67;
  uint64_t v68;
  unsigned __int8 *v69;
  int v70;
  const char *v71;
  int v72;
  NSObject *v73;
  uint64_t v75;
  const char *v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  size_t v80;
  const char *v81;
  unint64_t v82;
  CFStringRef v83;
  int v84;
  unsigned __int8 *v85;
  _QWORD v86[2];
  uint64_t v87;
  int v88;
  _QWORD v89[3];
  CFIndex MaximumSizeForEncoding;
  __int16 v91;
  _BYTE v92[22];
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  int v97;
  uint64_t v98;
  uint64_t v99;
  const __CFString *v100;
  const char *v101;
  int32_t v102[2];
  uint64_t v103;
  UChar v104[300];
  _BYTE v105[900];
  _WORD v106[306];
  _QWORD v107[3];
  uint64_t v108;
  uint64_t *v109;
  _WORD *v110;
  _BYTE *v111;
  __int128 v112;
  __int128 v113;
  uint64_t v114;
  CFRange v115;

  v12 = MEMORY[0x1E0C80A78](a1);
  v77 = v14;
  v79 = v15;
  v17 = v16;
  v19 = v18;
  v21 = v20;
  v22 = (uint64_t)v13;
  v75 = v23;
  v24 = v12;
  v25 = a10;
  v114 = *MEMORY[0x1E0C80C00];
  v26 = v13 && *v13 && strlen(*v13) > 3;
  v78 = v24;
  v27 = *(_DWORD *)(v24 + 4);
  v28 = v26 | ((v27 & 0x20) >> 5);
  if ((v27 & 0x80) == 0)
    v28 = (v27 >> 5) & 1;
  if (a9)
    v28 = 0;
  v82 = v19;
  if (v19 > 0x12C)
    v29 = 1;
  else
    v29 = v28;
  v80 = strlen(*(const char **)v22);
  v86[1] = 0;
  v87 = 0;
  v30 = completionPossibleMatch((_QWORD *)v22, (uint64_t)a10, (uint64_t)v21, a11);
  LODWORD(v83) = v29;
  if ((v30 & 1) != 0)
    v31 = 0;
  else
    v31 = splitPossibleMatch(v22);
  v32 = 48;
  if (a11)
    v32 = 64;
  v33 = *(_QWORD *)(v22 + v32);
  v86[0] = v33;
  v84 = a11;
  if (a10)
  {
    if (!strncmp("ja", a10, 2uLL))
    {
      v35 = 0;
      v34 = 1;
    }
    else
    {
      v34 = 0;
      v35 = strncmp("zh", a10, 2uLL) == 0;
    }
  }
  else
  {
    v34 = 0;
    v35 = 0;
  }
  v81 = v21;
  if (((v30 | v84) & 1) != 0 || *(_QWORD *)(v22 + 32) > 1uLL)
  {
    v36 = 0;
    if (!v33)
      return;
  }
  else
  {
    v36 = v34 | v35;
    if ((v34 | v35 | v31) != 1 || !v33)
      return;
  }
  v76 = a10;
  if (dword_1EF19FCC4 > 4)
  {
    v72 = *__error();
    v73 = _SILogForLogForCategory(14);
    if (os_log_type_enabled(v73, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(MaximumSizeForEncoding) = 67109378;
      HIDWORD(MaximumSizeForEncoding) = a9;
      v91 = 2080;
      *(_QWORD *)v92 = v81;
      _os_log_impl(&dword_1B8270000, v73, OS_LOG_TYPE_DEFAULT, "extracting field id %d: '%s'", (uint8_t *)&MaximumSizeForEncoding, 0x12u);
    }
    *__error() = v72;
    v25 = v76;
  }
  v85 = v105;
  if ((int)v80 >= 4)
  {
    v38 = 300;
    v37 = (int)v83;
    if (!v25)
      goto LABEL_42;
  }
  else
  {
    v37 = (int)v83;
    if (v82 - v87 <= 0x14)
    {
      v38 = 300;
    }
    else
    {
      v37 = 1;
      v38 = 20;
    }
    if (!v25)
      goto LABEL_42;
  }
  v39 = *(const __CFString **)(v22 + 88);
  if (v39)
  {
    LODWORD(v83) = v37;
    Length = CFStringGetLength(v39);
    MaximumSizeForEncoding = 0;
    MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
    MEMORY[0x1E0C80A78](MaximumSizeForEncoding);
    v42 = (UInt8 *)&v75 - v41;
    bzero((char *)&v75 - v41, v43);
    v115.location = 0;
    v115.length = Length;
    CFStringGetBytes(*(CFStringRef *)(v22 + 88), v115, 0x8000100u, 0x2Du, 0, v42, MaximumSizeForEncoding, &MaximumSizeForEncoding);
    v42[MaximumSizeForEncoding] = 0;
    v44 = (const char *)v42;
    v25 = v76;
    if (strcmp(v76, v44))
    {
      CFRelease(*(CFTypeRef *)(v22 + 88));
      *(_QWORD *)(v22 + 88) = 0;
      *(_QWORD *)(v22 + 88) = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v25, 0x600u);
    }
    LOBYTE(v37) = (_BYTE)v83;
  }
  else
  {
    *(_QWORD *)(v22 + 88) = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v25, 0x600u);
  }
LABEL_42:
  bzero(&MaximumSizeForEncoding, 0x1BA0uLL);
  LOBYTE(MaximumSizeForEncoding) = v37;
  BYTE1(MaximumSizeForEncoding) = v84;
  v45 = v17[3];
  v94 = v17[2];
  v95 = v45;
  v96 = v17[4];
  v46 = v17[1];
  *(_OWORD *)&v92[6] = *v17;
  v93 = v46;
  v97 = a9;
  v98 = v79;
  v99 = v78;
  v100 = *(const __CFString **)(v22 + 88);
  v101 = v25;
  v47 = v85;
  v85[1504] = v36;
  v48 = v47;
  v47[1505] = v34;
  v88 = 0;
  v102[0] = 0;
  if ((v34 & 1) == 0)
  {
    v49 = v81;
    goto LABEL_54;
  }
  bzero(v107, 0x258uLL);
  LODWORD(v89[0]) = 0;
  v49 = v81;
  u_strFromUTF8((UChar *)v107, v38, (int32_t *)v89, v81, v82, (UErrorCode *)&v88);
  if (v88 == 15)
  {
    v88 = 0;
    LODWORD(v89[0]) = v38;
  }
  else if (!LODWORD(v89[0]))
  {
    goto LABEL_48;
  }
  unorm2_getNFCInstance();
  if (v88 > 0)
  {
LABEL_48:
    v50 = v102[0];
    if (!v102[0])
      goto LABEL_54;
    goto LABEL_57;
  }
  v88 = 0;
  v51 = unorm2_normalize();
  if (v88 == 15)
    v50 = v38;
  else
    v50 = v51;
  v102[0] = v50;
  v88 = 0;
  if (!v50)
  {
LABEL_54:
    u_strFromUTF8(v104, v38, v102, v49, v82, (UErrorCode *)&v88);
    if (v88 == 15)
    {
      v102[0] = v38;
      v88 = 0;
      v50 = v38;
    }
    else
    {
      v50 = v102[0];
      if (!v102[0])
        return;
    }
  }
LABEL_57:
  v52 = CFStringCreateWithCharactersNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v104, v50, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
  if (v52)
  {
    v53 = v52;
    v112 = 0u;
    v113 = 0u;
    v54 = v75;
    v107[0] = v75;
    v107[1] = v104;
    v107[2] = &v104[v102[0]];
    v108 = (unsigned __int16)v38;
    v109 = &v103;
    v110 = 0;
    v111 = 0;
    *(_QWORD *)&v112 = 0;
    DWORD2(v112) = 0;
    BYTE8(v113) = v34;
    if (v48[1504])
    {
      *(_QWORD *)&v112 = v105;
      v111 = v105;
      v110 = v106;
      *(_QWORD *)&v113 = &v106[1];
      WORD4(v112) = 300;
    }
    v55 = v100;
    CITokenizerSetLocale(v75, v100, 0);
    v89[0] = tokenrangescallback;
    v89[1] = 0;
    v89[2] = v107;
    CITokenizerGetTokensNew(v54, (uint64_t)v53, (uint64_t)v55, *(_DWORD *)(v54 + 32) & 0x18, (uint64_t)getPreTokenizerCallback, (uint64_t)getTokensWrapper, (uint64_t)getSubTokensWrapper, 0, (uint64_t)v89);
    v56 = WORD1(v108);
    v57 = v48[1504];
    v83 = v53;
    if (v57)
    {
      v106[301] = WORD5(v112);
      *v111 = 0;
      v58 = v111 - (_BYTE *)&MaximumSizeForEncoding - 5560;
      v59 = v84;
      v60 = v77;
    }
    else
    {
      v60 = v77;
      if (WORD1(v108))
      {
        v61 = 0;
        v62 = 0;
        v82 = WORD1(v108);
        v63 = 2 * WORD1(v108);
        v64 = 901;
        do
        {
          v65 = &MaximumSizeForEncoding + v61;
          v66 = v65[18];
          if (v66 > v62)
          {
            v67 = _utf16_to_utf8(&v104[v62], v66 - v62, v48, v64, v34);
            v64 -= v67;
            v48 += v67;
            v66 = v65[18];
          }
          v68 = _utf16_to_utf8(&v104[v66], v65[19], v48, v64, v34);
          v106[v61 / 2 + 1] = (_WORD)v48 - (_WORD)v85;
          v62 = v65[19] + v65[18];
          v64 -= v68;
          v48 += v68;
          v61 += 2;
        }
        while (v63 != v61);
        v60 = v77;
        v69 = v85;
        v56 = v82;
      }
      else
      {
        v69 = v48;
      }
      *v48 = 0;
      LODWORD(v58) = (_DWORD)v48 - (_DWORD)v69;
      v59 = v84;
      v48 = v69;
    }
    v102[1] = v58;
    CFRelease(v83);
    if (v56)
    {
      if (v59)
        v70 = 4;
      else
        v70 = v48[1504] == 0;
      if ((handlePatterns((unsigned __int8 *)&MaximumSizeForEncoding, v56, 1u, (uint64_t)v105, (uint64_t)v86, v70, v60, a12) & 1) == 0&& *(_QWORD *)(v22 + 32) >= 2uLL&& (v59 & 1) == 0&& (int)v80 >= 4)
      {
        v71 = *(const char **)(v22 + 8);
        if (v71)
        {
          if (strcmp(*(const char **)v22, v71))
          {
            if (splitPossibleMatch(v22))
              handlePatterns((unsigned __int8 *)&MaximumSizeForEncoding, v56, *(unsigned __int16 *)(v22 + 32), *(_QWORD *)(v22 + 40), *(_QWORD *)(v22 + 80), 2, v60, a12);
          }
        }
      }
    }
  }
}

void generateCompletionsFromUTF8StringWithPatternAndLock(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, UErrorCode a9, const char *a10, int a11, const char *a12, unsigned __int8 a13, os_unfair_lock_s *a14)
{
  uint64_t v14;
  const char **v15;
  double v16;
  double v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const __CFString *v21;
  _OWORD *v22;
  _OWORD *v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  BOOL v30;
  int v31;
  int v32;
  _BOOL4 v33;
  _BOOL4 v34;
  _BOOL4 v35;
  _BOOL4 v36;
  _BOOL4 v37;
  _BOOL4 v38;
  int v39;
  uint64_t v40;
  _BOOL4 v41;
  int v42;
  const __CFString *v43;
  CFIndex Length;
  CFIndex MaximumSizeForEncoding;
  uint64_t v46;
  UInt8 *v47;
  size_t v48;
  __int128 v49;
  __int128 v50;
  const char *v51;
  int32_t v52;
  int v53;
  int32_t v54;
  CFStringRef v55;
  CFStringRef v56;
  uint64_t v57;
  _BOOL4 v58;
  _BOOL4 v59;
  BOOL (*v60)(const unsigned __int16 *, uint64_t, uint64_t, _QWORD *);
  BOOL (*v61)(const unsigned __int16 *, CFRange *, unint64_t *, uint64_t, _QWORD *);
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  _QWORD *v66;
  uint64_t v67;
  unint64_t v68;
  unsigned __int8 *v69;
  CFIndex v70;
  CFIndex *v71;
  uint64_t v72;
  CFIndex v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  int v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  int v82;
  NSObject *v83;
  uint64_t v84;
  uint64_t v85;
  _BOOL4 v86;
  _BOOL4 v87;
  _BOOL4 v88;
  _BOOL4 v89;
  _BOOL4 v90;
  uint64_t v91;
  _BOOL4 v92;
  _BOOL4 v93;
  int v94;
  uint64_t v95;
  int v96;
  const char *v97;
  uint64_t v98;
  CFStringRef v99;
  _QWORD v100[3];
  int v101;
  int32_t v102;
  int v103;
  CFIndex v104;
  __int16 v105;
  _BYTE v106[22];
  __int128 v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  int v111;
  CFStringRef v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  const char *v116;
  int32_t v117;
  unsigned int v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  unsigned __int16 v122[301];
  unsigned __int8 v123[5721];
  unsigned __int8 v124;
  _QWORD v125[5];
  __int128 v126;
  __int128 v127;
  uint64_t v128;
  CFRange v129;

  v14 = MEMORY[0x1E0C80A78](a1);
  v17 = v16;
  v19 = v18;
  v98 = v20;
  v99 = v21;
  v23 = v22;
  v25 = v24;
  v27 = v26;
  v28 = (uint64_t)v15;
  v29 = v14;
  v128 = *MEMORY[0x1E0C80C00];
  v30 = v15 && *v15 && strlen(*v15) > 3;
  v31 = strcmp(a10, "com.apple.mobileslideshow");
  if (!v29)
    goto LABEL_8;
  v32 = *(_DWORD *)(v29 + 4);
  if ((v32 & 0x80) != 0)
  {
    if ((v32 & 0x1000) != 0)
    {
      if ((v32 & 0x2000) == 0)
        goto LABEL_11;
    }
    else if (!v30)
    {
LABEL_11:
      v34 = 0;
      v35 = 0;
      v36 = 0;
      v37 = 0;
      v38 = 0;
      v33 = a11 == 3;
      goto LABEL_24;
    }
    v34 = 0;
    v38 = a11 == 0;
    v33 = a11 == 5;
    v35 = a11 == 6;
    v36 = a11 == 1;
    v37 = a11 > 7;
    if (v31)
    {
      v36 = 0;
      v37 = 0;
    }
    goto LABEL_24;
  }
  if ((v32 & 0x1000) == 0)
  {
LABEL_8:
    v33 = 0;
    v34 = 0;
    v35 = 0;
    v36 = 0;
    v37 = 0;
    v38 = 0;
    goto LABEL_24;
  }
  if ((v32 & 0x2000) != 0)
    v33 = a11 == 6;
  else
    v33 = a11 == 3;
  if ((v32 & 0x2000) != 0)
    v34 = a11 == 7;
  else
    v34 = a11 == 4;
  v35 = 0;
  v36 = 0;
  v37 = 0;
  v38 = (v32 & 0x2000) != 0 && a11 == 0;
LABEL_24:
  if (v25 > 0x12C)
    v38 = 1;
  if (v36 || v31 || v37)
  {
    v92 = v37;
    v93 = v36;
    v87 = v38;
    v88 = v35;
    v89 = v33;
    v90 = v34;
    v95 = v29;
    v91 = v19;
    v100[1] = 0;
    v100[2] = 0;
    v96 = completionPossibleMatch((_QWORD *)v28, (uint64_t)a12, v27, a13);
    v97 = (const char *)v27;
    if ((v96 & 1) != 0)
      v39 = 0;
    else
      v39 = splitPossibleMatch(v28);
    v40 = 48;
    if (a13)
      v40 = 64;
    v100[0] = *(_QWORD *)(v28 + v40);
    if (v100[0])
    {
      if (a12)
      {
        if (!strncmp("ja", a12, 2uLL))
        {
          v41 = 0;
          v94 = 1;
        }
        else
        {
          v94 = 0;
          v41 = strncmp("zh", a12, 2uLL) == 0;
        }
      }
      else
      {
        v94 = 0;
        v41 = 0;
      }
      if (((v96 | a13) & 1) != 0 || *(_QWORD *)(v28 + 32) > 1uLL)
      {
        v42 = 0;
      }
      else
      {
        v42 = v94 | v41;
        if ((v94 | v41 | v39) != 1)
          return;
      }
      v86 = v41;
      if (dword_1EF19FCC4 >= 5)
      {
        LODWORD(v85) = v42;
        v82 = *__error();
        v83 = _SILogForLogForCategory(14);
        if (os_log_type_enabled(v83, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(v104) = 67109378;
          HIDWORD(v104) = a11;
          v105 = 2080;
          *(_QWORD *)v106 = v97;
          _os_log_impl(&dword_1B8270000, v83, OS_LOG_TYPE_DEFAULT, "extracting field id %d: '%s'", (uint8_t *)&v104, 0x12u);
        }
        *__error() = v82;
        v42 = v85;
        if (!a12)
        {
LABEL_52:
          bzero(&v104, 0x4860uLL);
          LOBYTE(v104) = a13;
          v49 = v23[3];
          v108 = v23[2];
          v109 = v49;
          v110 = v23[4];
          v50 = v23[1];
          *(_OWORD *)&v106[6] = *v23;
          v107 = v50;
          v111 = a11;
          v112 = v99;
          v113 = v95;
          v115 = *(_QWORD *)(v28 + 88);
          v116 = a12;
          v123[5720] = v42;
          v124 = v94;
          if (normalizeSourceString(StringTokenizerPhrasesInfo *,unsigned char *,unsigned long,unsigned long,BOOL)::onceToken != -1)
            dispatch_once(&normalizeSourceString(StringTokenizerPhrasesInfo *,unsigned char *,unsigned long,unsigned long,BOOL)::onceToken, &__block_literal_global_1364);
          v51 = v97;
          v103 = 0;
          v117 = 0;
          bzero(v125, 0x258uLL);
          v102 = 0;
          v52 = 300;
          u_strFromUTF8((UChar *)v125, 300, &v102, v51, v25, (UErrorCode *)&v103);
          if (v103 == 15)
          {
            v102 = 300;
            v103 = 0;
          }
          else
          {
            v52 = v102;
            if (!v102)
            {
              v52 = v117;
              goto LABEL_66;
            }
          }
          v101 = 0;
          if (normalizeSourceString(StringTokenizerPhrasesInfo *,unsigned char *,unsigned long,unsigned long,BOOL)::norm2
            && ((v94 & 1) != 0 || (v53 = unorm2_quickCheck(), v52 = v102, v53 != 1)))
          {
            v54 = unorm2_normalize();
            if (v103 == 15)
              v52 = 300;
            else
              v52 = v54;
          }
          else
          {
            memcpy(v122, v125, 2 * v52);
            v122[v52] = 0;
          }
          v117 = v52;
LABEL_66:
          if (!v52)
            return;
          v55 = CFStringCreateWithCharactersNoCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v122, v52, (CFAllocatorRef)*MEMORY[0x1E0C9AE20]);
          if (!v55)
            return;
          v56 = v55;
          v126 = 0u;
          v127 = 0u;
          v57 = v98;
          v125[0] = v98;
          v125[1] = v122;
          v125[2] = &v122[v117];
          v125[3] = &v120;
          LOWORD(v126) = 300;
          v125[4] = &v121;
          *(_QWORD *)&v127 = &v119;
          v58 = SIStringContainsNewlineCharacters((uint64_t)v122, v117);
          v59 = v58;
          if (v58)
            v60 = 0;
          else
            v60 = GetTokenCallback;
          if (v58)
            v61 = GetSentenceCallback;
          else
            v61 = 0;
          v99 = v56;
          CITokenizerGetTokensNew(v57, (uint64_t)v56, v115, 4, 0, (uint64_t)v60, 0, (uint64_t)v61, (uint64_t)v125);
          v62 = WORD1(v126);
          if (v59)
          {
            v63 = WORD4(v127);
          }
          else
          {
            v63 = WORD4(v127);
            if (*((uint64_t *)&v126 + 1) < WORD1(v126))
            {
              v65 = WORD2(v126);
              v64 = (uint64_t)v97;
              if (WORD2(v126))
              {
                v66 = (_QWORD *)(v127 + 16 * WORD4(v127));
                *v66 = *((_QWORD *)&v126 + 1);
                v66[1] = v65;
                v63 = (v63 + 1);
                WORD4(v127) = v63;
              }
              goto LABEL_80;
            }
          }
          v64 = (uint64_t)v97;
LABEL_80:
          v85 = v63;
          if ((_DWORD)v62)
          {
            v98 = v62;
            if (v120)
            {
              v67 = _utf16_to_utf8(v122, v120, v123, 0x385uLL, v124);
              v68 = 901 - v67;
              v69 = &v123[v67];
            }
            else
            {
              v68 = 901;
              v69 = v123;
            }
            v70 = 0;
            v71 = &v104;
            v72 = v98;
            do
            {
              if (v70)
              {
                v73 = v71[621];
                if (v73 > v70)
                {
                  v74 = _utf16_to_utf8(&v122[v70], v73 - v70, v69, v68, v124);
                  v68 -= v74;
                  v69 += v74;
                }
              }
              v75 = _utf16_to_utf8(&v122[v71[621]], v71[622], v69, v68, v124);
              v70 = v71[622] + v71[621];
              v71[1712] = v69 - v123;
              v71[1713] = v75;
              v68 -= v75;
              v69 += v75;
              v71 += 2;
              --v72;
            }
            while (v72);
            v64 = (uint64_t)v97;
            LODWORD(v62) = v98;
          }
          else
          {
            v69 = v123;
          }
          *v69 = 0;
          v118 = (_DWORD)v69 - v123;
          CFRelease(v99);
          if ((_DWORD)v62)
          {
            if (v93 || v92)
            {
              if ((unsigned __int16)v85 == 1)
              {
                v76 = v95;
                if (v95)
                  v76 = *(_QWORD *)(v95 + 32);
                v114 = v76;
                insertPatternsForText((uint64_t)&v104, v62, (uint64_t)v123, (uint64_t)v100, a9, v91, a14);
              }
            }
            else
            {
              if (v88)
                v77 = 8;
              else
                v77 = 7;
              if (v89 || v90 || v88)
              {
                v78 = v95;
                if (v95)
                  v78 = *(_QWORD *)(v95 + 24);
                v114 = v78;
                handlePatternsForTextWithScore((uint64_t)&v104, v62, (uint64_t)v123, (uint64_t)v100, v77, (UErrorCode)v17, v91, a14);
              }
              else
              {
                v79 = v91;
                v80 = v95;
                if (v95)
                  v81 = *(_QWORD *)(v95 + 24);
                else
                  v81 = 0;
                v114 = v81;
                if ((v96 & 1) != 0)
                {
                  if (tokenPossibleMatch(v28, (uint64_t)a12, v64, v94 | v86))addCrossFieldOidWithLock(v80, v79, a14);
                  handlePatternsForPhrases((uint64_t)&v104, v62, (unsigned __int16)v85, (uint64_t)v123, (uint64_t)v100, v87, a9, v79, a14);
                }
                else
                {
                  handleCrossFieldPatterns((const char **)v28, (uint64_t)&v104, v62, (unsigned __int16)v85, a9, v91, a14);
                }
              }
            }
          }
          return;
        }
      }
      else if (!a12)
      {
        goto LABEL_52;
      }
      v43 = *(const __CFString **)(v28 + 88);
      if (v43)
      {
        LODWORD(v85) = v42;
        Length = CFStringGetLength(v43);
        v104 = 0;
        MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
        v84 = (uint64_t)&v84;
        v104 = MaximumSizeForEncoding;
        MEMORY[0x1E0C80A78](MaximumSizeForEncoding);
        v47 = (UInt8 *)&v84 - v46;
        bzero((char *)&v84 - v46, v48);
        v129.location = 0;
        v129.length = Length;
        CFStringGetBytes(*(CFStringRef *)(v28 + 88), v129, 0x8000100u, 0x2Du, 0, v47, v104, &v104);
        v47[v104] = 0;
        if (strcmp(a12, (const char *)v47))
        {
          CFRelease(*(CFTypeRef *)(v28 + 88));
          *(_QWORD *)(v28 + 88) = 0;
          *(_QWORD *)(v28 + 88) = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a12, 0x600u);
        }
        LOBYTE(v42) = v85;
      }
      else
      {
        *(_QWORD *)(v28 + 88) = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a12, 0x600u);
      }
      goto LABEL_52;
    }
  }
}

uint64_t completionPossibleMatch(_QWORD *a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4;
  uint64_t v6;

  if (a4)
    v4 = 8;
  else
    v4 = 6;
  if (*a1)
  {
    if (a1[v4])
      return icu_search_match();
    os_unfair_lock_lock((os_unfair_lock_t)&s_search_context_unfair_lock);
    if (a1[v4])
    {
      os_unfair_lock_unlock((os_unfair_lock_t)&s_search_context_unfair_lock);
      return icu_search_match();
    }
    v6 = icu_search_context_create();
    __dmb(0xBu);
    a1[v4] = v6;
    os_unfair_lock_unlock((os_unfair_lock_t)&s_search_context_unfair_lock);
    if (v6)
      return icu_search_match();
  }
  return 0;
}

uint64_t splitPossibleMatch(uint64_t a1)
{
  uint64_t v2;

  if (*(_QWORD *)(a1 + 8))
  {
    if (*(_QWORD *)(a1 + 72))
      return icu_search_match();
    os_unfair_lock_lock((os_unfair_lock_t)&s_search_context_unfair_lock);
    if (*(_QWORD *)(a1 + 72))
    {
      os_unfair_lock_unlock((os_unfair_lock_t)&s_search_context_unfair_lock);
      return icu_search_match();
    }
    v2 = icu_search_context_create();
    __dmb(0xBu);
    *(_QWORD *)(a1 + 72) = v2;
    os_unfair_lock_unlock((os_unfair_lock_t)&s_search_context_unfair_lock);
    if (v2)
      return icu_search_match();
  }
  return 0;
}

BOOL GetTokenCallback(const unsigned __int16 *a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t i;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  __int16 v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  int IsValidPhraseToken;
  uint64_t v22;
  uint64_t v23;
  _QWORD *v24;

  v5 = a4[1];
  if (v5 <= (unint64_t)a1 && (unint64_t)&a1[a2] <= a4[2])
  {
    v6 = (uint64_t)((uint64_t)a1 - v5) >> 1;
    if ((a3 & 0x10) != 0)
    {
      if (a2 >= 1)
      {
        for (i = 0; i != a2; i = v18 + 1)
        {
          v12 = 0;
          while (a1[i + v12] != 45)
          {
            ++v12;
            if (!(i - a2 + v12))
            {
              v10 = 0;
              v9 = a2 - i;
              v7 = *((unsigned __int16 *)a4 + 21);
              v8 = (uint64_t *)(a4[3] + 16 * v7);
              *v8 = v6;
              goto LABEL_15;
            }
          }
          v13 = *((unsigned __int16 *)a4 + 21);
          v15 = a4[3];
          v14 = a4[4];
          v16 = *((_WORD *)a4 + 22);
          if (v12)
          {
            v17 = (uint64_t *)(v15 + 16 * v13);
            *v17 = v6;
            v17[1] = v12;
            *(_QWORD *)(v14 + 8 * v13) = 0;
            LOWORD(v13) = v13 + 1;
            ++v16;
          }
          v18 = i + v12;
          v19 = v6 + v12;
          v20 = (uint64_t *)(v15 + 16 * (unsigned __int16)v13);
          *v20 = v19;
          v20[1] = 1;
          *(_QWORD *)(v14 + 8 * (unsigned __int16)v13) = 32;
          *((_WORD *)a4 + 21) = v13 + 1;
          *((_WORD *)a4 + 22) = v16 + 1;
          v6 = v19 + 1;
        }
      }
    }
    else
    {
      v7 = *((unsigned __int16 *)a4 + 21);
      v8 = (uint64_t *)(a4[3] + 16 * v7);
      *v8 = v6;
      v9 = a2;
      v10 = a3;
LABEL_15:
      v8[1] = v9;
      *(_QWORD *)(a4[4] + 8 * v7) = v10;
      *((_WORD *)a4 + 21) = v7 + 1;
      ++*((_WORD *)a4 + 22);
    }
    if (!*((_BYTE *)a4 + 66))
    {
      IsValidPhraseToken = SILanguageModelIsValidPhraseToken();
      v22 = *((unsigned __int16 *)a4 + 22);
      if (IsValidPhraseToken)
      {
        if (v22 <= 0x7C)
          return *((unsigned __int16 *)a4 + 21) >= *((unsigned __int16 *)a4 + 20)
              || *((unsigned __int16 *)a4 + 32) > 0x12Bu;
      }
      else if (!*((_WORD *)a4 + 22))
      {
LABEL_22:
        a4[6] = *((unsigned __int16 *)a4 + 21);
        *((_WORD *)a4 + 22) = 0;
        return *((unsigned __int16 *)a4 + 21) >= *((unsigned __int16 *)a4 + 20)
            || *((unsigned __int16 *)a4 + 32) > 0x12Bu;
      }
      v23 = *((unsigned __int16 *)a4 + 32);
      v24 = (_QWORD *)(a4[7] + 16 * v23);
      *v24 = a4[6];
      v24[1] = v22;
      *((_WORD *)a4 + 32) = v23 + 1;
      goto LABEL_22;
    }
  }
  return *((unsigned __int16 *)a4 + 21) >= *((unsigned __int16 *)a4 + 20)
      || *((unsigned __int16 *)a4 + 32) > 0x12Bu;
}

BOOL GetSentenceCallback(const unsigned __int16 *a1, CFRange *a2, unint64_t *a3, uint64_t a4, _QWORD *a5)
{
  uint64_t v10;
  CFRange *v11;
  uint64_t length;
  CFIndex location;
  unint64_t v14;
  uint64_t v15;
  CFIndex *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  CFIndex v20;
  CFIndex v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  __int16 v25;
  CFIndex *v26;
  uint64_t v27;
  CFIndex v28;
  _QWORD *v29;
  uint64_t v30;
  int IsValidPhraseToken;
  uint64_t v32;
  uint64_t v33;
  _QWORD *v34;
  uint64_t v35;
  uint64_t v36;
  _QWORD *v37;

  if (a4 < 1)
  {
LABEL_24:
    if (!*((_BYTE *)a5 + 66))
    {
      v35 = *((unsigned __int16 *)a5 + 22);
      if (*((_WORD *)a5 + 22))
      {
        v36 = *((unsigned __int16 *)a5 + 32);
        v37 = (_QWORD *)(a5[7] + 16 * v36);
        *v37 = a5[6];
        v37[1] = v35;
        *((_WORD *)a5 + 32) = v36 + 1;
        a5[6] = *((unsigned __int16 *)a5 + 21);
        *((_WORD *)a5 + 22) = 0;
      }
    }
    if (*((unsigned __int16 *)a5 + 21) < *((unsigned __int16 *)a5 + 20))
      return *((unsigned __int16 *)a5 + 32) > 0x12Bu;
  }
  else
  {
    v10 = 0;
    while (1)
    {
      v11 = &a2[v10];
      location = v11->location;
      length = v11->length;
      v14 = a3[v10];
      if ((v14 & 0x10) != 0)
      {
        if (length >= 1)
        {
          v19 = 0;
          v20 = v11->location;
          do
          {
            v21 = 0;
            while (a1[v19 + v21] != 45)
            {
              ++v21;
              if (!(v19 - length + v21))
              {
                v18 = 0;
                v17 = length - v19;
                v15 = *((unsigned __int16 *)a5 + 21);
                v16 = (CFIndex *)(a5[3] + 16 * v15);
                *v16 = v20;
                goto LABEL_15;
              }
            }
            v22 = *((unsigned __int16 *)a5 + 21);
            v24 = a5[3];
            v23 = a5[4];
            v25 = *((_WORD *)a5 + 22);
            if (v21)
            {
              v26 = (CFIndex *)(v24 + 16 * v22);
              *v26 = v20;
              v26[1] = v21;
              *(_QWORD *)(v23 + 8 * v22) = 0;
              LOWORD(v22) = v22 + 1;
              ++v25;
            }
            v27 = v19 + v21;
            v28 = v21 + v20;
            v29 = (_QWORD *)(v24 + 16 * (unsigned __int16)v22);
            *v29 = v28;
            v29[1] = 1;
            *(_QWORD *)(v23 + 8 * (unsigned __int16)v22) = 32;
            *((_WORD *)a5 + 21) = v22 + 1;
            *((_WORD *)a5 + 22) = v25 + 1;
            v20 = v28 + 1;
            v19 = v27 + 1;
          }
          while (v19 != length);
        }
      }
      else
      {
        v15 = *((unsigned __int16 *)a5 + 21);
        v16 = (CFIndex *)(a5[3] + 16 * v15);
        *v16 = location;
        v17 = length;
        v18 = v14;
LABEL_15:
        v16[1] = v17;
        *(_QWORD *)(a5[4] + 8 * v15) = v18;
        *((_WORD *)a5 + 21) = v15 + 1;
        ++*((_WORD *)a5 + 22);
      }
      if (*((_BYTE *)a5 + 66))
      {
        LODWORD(v30) = *((unsigned __int16 *)a5 + 21);
      }
      else
      {
        IsValidPhraseToken = SILanguageModelIsValidPhraseToken();
        v32 = *((unsigned __int16 *)a5 + 22);
        v30 = *((unsigned __int16 *)a5 + 21);
        if (!IsValidPhraseToken || v32 >= 0x7D)
        {
          v33 = *((unsigned __int16 *)a5 + 32);
          v34 = (_QWORD *)(a5[7] + 16 * v33);
          *v34 = a5[6];
          v34[1] = v32;
          *((_WORD *)a5 + 32) = v33 + 1;
          a5[6] = v30;
          *((_WORD *)a5 + 22) = 0;
        }
      }
      if (v30 >= *((unsigned __int16 *)a5 + 20) || *((unsigned __int16 *)a5 + 32) >= 0x12Cu)
        break;
      if (++v10 == a4)
        goto LABEL_24;
    }
  }
  return 1;
}

uint64_t _utf16_to_utf8(unsigned __int16 *a1, uint64_t a2, unsigned __int8 *a3, unint64_t a4, int a5)
{
  unsigned __int8 *v6;
  unsigned __int8 *v7;
  const unsigned __int16 *v8;
  const unsigned __int16 *v9;
  unsigned int v10;
  unsigned int v11;
  int v12;
  unsigned int v13;
  const unsigned __int16 *v14;
  const unsigned __int16 *v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  unsigned int v19;
  uint64_t v20;

  if (a5)
  {
    v20 = 0;
    if (utf8_encodestr(a1, 2 * a2, a3, &v20, a4))
      return 0;
    else
      return v20;
  }
  else
  {
    v6 = a3;
    if (a4 >= 4 * a2)
    {
      if (a2 >= 1)
      {
        v6 = a3;
        v14 = a1;
        v15 = &a1[a2];
        do
        {
          v17 = *v14++;
          v16 = v17;
          if (v17 > 0x7F)
          {
            if (v16 > 0x7FF)
            {
              if ((v16 & 0xF800) == 0xD800)
              {
                if ((v16 & 0x400) == 0 && v14 < v15)
                {
                  v18 = *v14;
                  if ((v18 & 0xFC00) == 0xDC00)
                  {
                    v14 = a1 + 2;
                    v19 = v18 + (v16 << 10) - 56613888;
                    *v6 = (v19 >> 18) | 0xF0;
                    v6[1] = (v19 >> 12) & 0x3F | 0x80;
                    v6[2] = (v19 >> 6) & 0x3F | 0x80;
                    v6[3] = v18 & 0x3F | 0x80;
                    v6 += 4;
                  }
                }
              }
              else
              {
                *v6 = (v16 >> 12) | 0xE0;
                v6[1] = (v16 >> 6) & 0x3F | 0x80;
                v6[2] = v16 & 0x3F | 0x80;
                v6 += 3;
              }
            }
            else
            {
              *v6 = (v16 >> 6) | 0xC0;
              v6[1] = v16 & 0x3F | 0x80;
              v6 += 2;
            }
          }
          else
          {
            *v6++ = v16;
          }
          a1 = (unsigned __int16 *)v14;
        }
        while (v14 < v15);
      }
    }
    else if (a2 >= 1)
    {
      v7 = &a3[a4];
      v6 = a3;
      v8 = a1;
      v9 = &a1[a2];
      do
      {
        v11 = *v8++;
        v10 = v11;
        if (v11 > 0x7F)
        {
          if (v10 > 0x7FF)
          {
            if ((v10 & 0xF800) == 0xD800)
            {
              if ((v10 & 0x400) == 0 && v8 < v9)
              {
                v12 = *v8;
                if ((v12 & 0xFC00) == 0xDC00)
                {
                  if (v6 + 3 >= v7)
                    return v6 - a3;
                  v8 = a1 + 2;
                  v13 = v12 + (v10 << 10) - 56613888;
                  *v6 = (v13 >> 18) | 0xF0;
                  v6[1] = (v13 >> 12) & 0x3F | 0x80;
                  v6[2] = (v13 >> 6) & 0x3F | 0x80;
                  v6[3] = v12 & 0x3F | 0x80;
                  v6 += 4;
                }
              }
            }
            else
            {
              if (v6 + 2 >= v7)
                return v6 - a3;
              *v6 = (v10 >> 12) | 0xE0;
              v6[1] = (v10 >> 6) & 0x3F | 0x80;
              v6[2] = v10 & 0x3F | 0x80;
              v6 += 3;
            }
          }
          else
          {
            if (v6 + 1 >= v7)
              return v6 - a3;
            *v6 = (v10 >> 6) | 0xC0;
            v6[1] = v10 & 0x3F | 0x80;
            v6 += 2;
          }
        }
        else
        {
          if (v6 >= v7)
            return v6 - a3;
          *v6++ = v10;
        }
        a1 = (unsigned __int16 *)v8;
      }
      while (v8 < v9);
    }
    return v6 - a3;
  }
}

void insertPatternsForText(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, UErrorCode a5, uint64_t a6, os_unfair_lock_s *a7)
{
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  unsigned int v14;
  BOOL v15;
  uint64_t v16;
  CFLocaleRef v18;
  CFLocaleRef v19;
  CFTypeRef v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t *v23;
  size_t v24;
  uint64_t v25;
  unsigned __int8 v26;
  char v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t *v37;
  BOOL v38;
  uint64_t v39;
  char v40;
  double v41;
  uint64_t v42;
  int v43;
  __n128 v44;
  __n128 v45;
  uint64_t v46;
  uint64_t v47;
  CFTypeRef v48;
  __int16 v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  __int128 v53[5];
  uint64_t v54;

  v54 = *MEMORY[0x1E0C80C00];
  if (a4 && *(_QWORD *)(a1 + 120))
  {
    v11 = a1 + 12192;
    v12 = (_QWORD *)(a1 + 4976);
    v13 = a2;
    while (1)
    {
      if (*v12 == 1)
      {
        v14 = *(unsigned __int16 *)(v11 + 2 * *(v12 - 1)) - 38;
        v15 = v14 > 0x39;
        v16 = (1 << v14) & 0x2000000000000A1;
        if (!v15 && v16 != 0)
          break;
      }
      v12 += 2;
      if (!--v13)
      {
        if (lazySearchContextAtIndex(a3, a4, *(_QWORD *)(a1 + 136), 0))
        {
          v18 = CFLocaleCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], *(CFLocaleIdentifier *)(a1 + 128));
          if (v18)
          {
            v19 = v18;
            v20 = CFRetain(v18);
            if (v20)
            {
              v21 = *(_QWORD *)(a1 + 160);
              v47 = *(_QWORD *)(a1 + 152);
              v48 = v20;
              v51 = 0;
              v52 = 0;
              v22 = icu_search_match();
              if ((_DWORD)v22
                && v21 <= 13
                && (uint64_t)(*(_QWORD *)(a1 + 4968 + 16 * (v47 + v21) - 16)
                           - *(_QWORD *)(a1 + 4968)
                           + *(_QWORD *)(a1 + 4968 + 16 * (v47 + v21) - 8)) <= 29)
              {
                v46 = (uint64_t)&v46;
                MEMORY[0x1E0C80A78](v22);
                v23 = &v46 - 4 * v21;
                bzero(v23, v24);
                if (v21 < 1)
                {
                  v28 = 0;
                  v26 = 0;
                }
                else
                {
                  v25 = 0;
                  v26 = 0;
                  v27 = 0;
                  v28 = 0;
                  v29 = v47 - v21 + 1;
                  v30 = a1 + 8 * v47 + 9784;
                  v31 = (uint64_t *)(a1 + 16 * v47 + 4976);
                  do
                  {
                    v32 = *(v31 - 1);
                    if (v25)
                    {
                      v33 = *(v31 - 2) + *(v31 - 3);
                      if (v32 > v33)
                      {
                        v34 = &v23[2 * v28];
                        *v34 = v11 + 2 * v33;
                        *((_DWORD *)v34 + 2) = v32 - v33;
                        *((_BYTE *)v34 + 12) = 1;
                        ++v28;
                        ++v27;
                      }
                    }
                    v35 = *(_QWORD *)(v30 + 8 * v25);
                    v36 = v11 + 2 * v32;
                    v37 = &v23[2 * v28];
                    v38 = (v35 & 0x800) != 0 || v35 == 0;
                    v39 = *v31;
                    v31 += 2;
                    *v37 = v36;
                    *((_DWORD *)v37 + 2) = v39;
                    v40 = !v38;
                    *((_BYTE *)v37 + 12) = v40;
                    ++v28;
                    if (!(v29 + v25))
                      v26 = v27 + v25;
                    ++v25;
                  }
                  while (v25 != v21);
                }
                v50 = 0;
                v49 = 0;
                v41 = (*(double (**)(void))(*(_QWORD *)(a1 + 104) + 16))();
                os_unfair_lock_lock(a7);
                if (v28)
                {
                  v42 = *(_QWORD *)(a1 + 120);
                  v43 = *(_DWORD *)(a1 + 96);
                  v44 = *(__n128 *)(a1 + 64);
                  v53[2] = *(_OWORD *)(a1 + 48);
                  v53[3] = (__int128)v44;
                  v53[4] = *(_OWORD *)(a1 + 80);
                  v45 = *(__n128 *)(a1 + 32);
                  v53[0] = *(_OWORD *)(a1 + 16);
                  v44.n128_u64[1] = *((_QWORD *)&v53[0] + 1);
                  v53[1] = (__int128)v45;
                  v44.n128_u64[0] = 1.0;
                  v45.n128_f64[0] = v41;
                  word_trie_s::insert((uint64_t *)(v42 + 16), (uint64_t)v23, v28, v53, a6, a5, v43, 3, v45, v44, v50, v49, HIBYTE(v49), 6, 0, v26, 0);
                }
                os_unfair_lock_unlock(a7);
              }
              CFRelease(v19);
              CFRelease(v48);
            }
          }
        }
        return;
      }
    }
  }
}

void handlePatternsForTextWithScore(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, int a5, UErrorCode a6, uint64_t a7, os_unfair_lock_s *a8)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  size_t v20;
  uint64_t v21;
  unsigned __int8 v22;
  char v23;
  unint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t *v31;
  BOOL v32;
  uint64_t v33;
  char v34;
  double v35;
  uint64_t v36;
  int v37;
  __n128 v38;
  __n128 v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t *v42;
  __int16 v43;
  int v44;
  uint64_t v45;
  uint64_t v46;
  __int128 v47[5];
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  if (a4)
  {
    if (*(_QWORD *)(a1 + 120))
    {
      if (lazySearchContextAtIndex(a3, a4, *(_QWORD *)(a1 + 136), 0))
      {
        v14 = *(_QWORD *)(a1 + 152);
        v45 = 0;
        v46 = 0;
        v15 = icu_search_match();
        if (a2 <= 0xD)
        {
          if ((_DWORD)v15)
          {
            v16 = a2;
            v17 = a1 + 4968 + 16 * (a2 + v14);
            if ((uint64_t)(*(_QWORD *)(v17 - 16) - *(_QWORD *)(a1 + 4968) + *(_QWORD *)(v17 - 8)) <= 29)
            {
              v41 = a7;
              v42 = &v40;
              v18 = a1 + 12192;
              MEMORY[0x1E0C80A78](v15);
              v19 = &v40 - 4 * a2;
              bzero(&v40 - 4 * v16, v20);
              v21 = 0;
              v22 = 0;
              v23 = 0;
              v24 = 0;
              v25 = (uint64_t *)(a1 + 16 * v14 + 4976);
              do
              {
                v26 = *(v25 - 1);
                if (v21)
                {
                  v27 = *(v25 - 2) + *(v25 - 3);
                  if (v26 > v27)
                  {
                    v28 = &v19[2 * v24];
                    *v28 = v18 + 2 * v27;
                    *((_DWORD *)v28 + 2) = v26 - v27;
                    *((_BYTE *)v28 + 12) = 1;
                    ++v24;
                    ++v23;
                  }
                }
                v29 = *(_QWORD *)(a1 + 8 * v14 + 9784 + 8 * v21);
                v30 = v18 + 2 * v26;
                v31 = &v19[2 * v24];
                v32 = (v29 & 0x800) != 0 || v29 == 0;
                v33 = *v25;
                v25 += 2;
                *v31 = v30;
                *((_DWORD *)v31 + 2) = v33;
                v34 = !v32;
                *((_BYTE *)v31 + 12) = v34;
                ++v24;
                if (v16 + ~v14 == v21)
                  v22 = v23 + v21;
                ++v21;
              }
              while (v16 != v21);
              v44 = 0;
              v43 = 0;
              v35 = (*(double (**)(void))(*(_QWORD *)(a1 + 104) + 16))();
              os_unfair_lock_lock(a8);
              if (v24)
              {
                v36 = *(_QWORD *)(a1 + 120);
                v37 = *(_DWORD *)(a1 + 96);
                v38 = *(__n128 *)(a1 + 64);
                v47[2] = *(_OWORD *)(a1 + 48);
                v47[3] = (__int128)v38;
                v47[4] = *(_OWORD *)(a1 + 80);
                v39 = *(__n128 *)(a1 + 32);
                v47[0] = *(_OWORD *)(a1 + 16);
                v38.n128_u64[1] = *((_QWORD *)&v47[0] + 1);
                v47[1] = (__int128)v39;
                v38.n128_u64[0] = 0;
                v39.n128_f64[0] = v35;
                word_trie_s::insert((uint64_t *)(v36 + 16), (uint64_t)(&v40 - 4 * v16), v24, v47, v41, a6, v37, 3, v39, v38, v44, v43, HIBYTE(v43), a5, 0, v22, 0);
              }
              os_unfair_lock_unlock(a8);
            }
          }
        }
      }
    }
  }
}

void handleCrossFieldPatterns(const char **a1, uint64_t a2, unsigned int a3, unsigned int a4, UErrorCode a5, uint64_t a6, os_unfair_lock_s *a7)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v15;
  CFLocaleRef v16;
  CFLocaleRef v17;
  uint64_t v18;
  const void *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  const char *v25;
  size_t v26;
  uint64_t v27;
  const void *v28;
  os_unfair_lock_s *v29;
  uint64_t v30;
  uint64_t v31;
  _BYTE *v32;
  size_t v33;
  uint64_t v34;
  _BYTE *v35;
  uint64_t v36;
  _QWORD *v37;
  size_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t *v41;
  unint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  _QWORD *v46;
  uint64_t v47;
  _QWORD *v48;
  uint64_t v49;
  double v50;
  __int128 v51;
  __n128 v52;
  __n128 v53;
  int v54;
  int v55;
  uint64_t *v56;
  _BYTE v57[12];
  UErrorCode v58;
  uint64_t v59;
  const __CFLocale *v60;
  const char **v61;
  os_unfair_lock_s *v62;
  uint64_t v63;
  unsigned int v64;
  uint64_t v65;
  _BYTE *v66;
  __int16 v67;
  int v68;
  __int16 v69;
  int v70;
  _QWORD v71[9];
  uint64_t v72;
  uint64_t *v73;
  uint64_t v74;
  int v75;
  uint64_t v76;
  uint64_t *v77;
  uint64_t v78;
  __n128 (*v79)(uint64_t, uint64_t);
  uint64_t (*v80)();
  __int128 v81;
  uint64_t v82;
  uint64_t *v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  _BYTE *v89;
  uint64_t v90;
  uint64_t v91;
  __int128 v92[4];
  __int128 v93;
  uint64_t v94;

  v94 = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)(a2 + 120))
  {
    v9 = a2 + 9784;
    v10 = a2 + 13696;
    v11 = *(_QWORD *)(a2 + 112);
    v12 = a2 + 12794;
    v61 = a1;
    v62 = a7;
    v65 = a2 + 12192;
    v66 = (_BYTE *)(a2 + 4968);
    v64 = a4;
    if (v11)
      v15 = *(_QWORD *)(v11 + 8);
    else
      v15 = 0;
    v16 = CFLocaleCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], *(CFLocaleIdentifier *)(a2 + 128));
    v86 = v12;
    v87 = v10;
    v17 = v16;
    v88 = v65;
    v89 = v66;
    v90 = v9;
    v91 = a3;
    v18 = SILanguageModelCopyLocale();
    v19 = (const void *)v18;
    if (v18)
    {
      v63 = a2;
      v58 = a5;
      v59 = a6;
      v82 = 0;
      v83 = &v82;
      v84 = 0x2000000000;
      v85 = 0;
      v76 = 0;
      v77 = &v76;
      v78 = 0x3802000000;
      v79 = __Block_byref_object_copy_;
      v80 = __Block_byref_object_dispose_;
      v81 = xmmword_1B8631BE0;
      v72 = 0;
      v73 = &v72;
      v74 = 0x2000000000;
      v75 = 0;
      if (v64)
      {
        v60 = v17;
        v20 = v18;
        v21 = v64;
        v22 = (uint64_t *)(v63 + 160);
        do
        {
          v23 = *(v22 - 1);
          v24 = *v22;
          v87 = v10 + 16 * v23;
          v89 = &v66[16 * v23];
          v90 = v9 + 8 * v23;
          v91 = v24;
          v71[0] = MEMORY[0x1E0C809B0];
          v71[1] = 0x40000000;
          v71[2] = ___ZL24handleCrossFieldPatternsP23si_completion_pattern_sP26StringTokenizerPhrasesInfotjbbjxP16os_unfair_lock_s_block_invoke;
          v71[3] = &unk_1E6E2EBC0;
          v71[4] = &v82;
          v71[5] = &v76;
          v71[7] = v23;
          v71[8] = v24;
          v71[6] = &v72;
          MEMORY[0x1BCCAFD68](v15, v20, &v86, v71);
          v22 += 2;
          --v21;
        }
        while (v21);
        v17 = v60;
        v19 = (const void *)v20;
        if (v77[5] != -1 && (unint64_t)(v77[6] - 2) <= 0xB)
        {
          v25 = *v61;
          v26 = strlen(*v61);
          v27 = (_DWORD)v26 ? (int)(v26 - (v25[(int)v26 - 1] == 42)) : 0;
          v29 = v62;
          do
          {
            v30 = v27;
            if (!v27)
              break;
            --v27;
          }
          while (v25[v30 - 1] == 32);
          v70 = v30 + 1;
          MEMORY[0x1E0C80A78](v26);
          v32 = &v57[-v31];
          bzero(&v57[-v31], v33);
          v34 = UTF16FromUTF8();
          if (v34)
          {
            v35 = (_BYTE *)v34;
            v66 = v57;
            MEMORY[0x1E0C80A78](v34);
            v37 = &v57[-((v36 + 47) & 0xFFFFFFFFFFFFFFE0)];
            bzero(v37, v38);
            *v37 = v35;
            *((_DWORD *)v37 + 2) = v70;
            *((_BYTE *)v37 + 12) = 0;
            v69 = 32;
            v37[2] = &v69;
            *((_DWORD *)v37 + 6) = 1;
            *((_BYTE *)v37 + 28) = 1;
            v39 = v77[6];
            if (v39 < 1)
            {
              v42 = 2;
            }
            else
            {
              v40 = 0;
              v41 = (uint64_t *)(v63 + 16 * v77[5] + 4976);
              v42 = 2;
              v43 = v65;
              do
              {
                v44 = *(v41 - 1);
                if (v40)
                {
                  v45 = *(v41 - 2) + *(v41 - 3);
                  if (v44 > v45)
                  {
                    v46 = &v37[2 * v42];
                    *v46 = v43 + 2 * v45;
                    *((_DWORD *)v46 + 2) = v44 - v45;
                    *((_BYTE *)v46 + 12) = 1;
                    ++v42;
                  }
                }
                v47 = *v41;
                v41 += 2;
                v48 = &v37[2 * v42];
                *v48 = v43 + 2 * v44;
                *((_DWORD *)v48 + 2) = v47;
                *((_BYTE *)v48 + 12) = 1;
                ++v42;
                ++v40;
              }
              while (v39 != v40);
            }
            BYTE4(v37[2 * v42 - 1]) = 0;
            v68 = 0;
            v67 = 0;
            v49 = v63;
            v50 = (*(double (**)(void))(*(_QWORD *)(v63 + 104) + 16))();
            os_unfair_lock_lock(v29);
            if (v42)
            {
              v51 = *(_OWORD *)(v49 + 16);
              v92[1] = *(_OWORD *)(v49 + 32);
              v52 = *(__n128 *)(v49 + 64);
              v92[2] = *(_OWORD *)(v49 + 48);
              v92[3] = (__int128)v52;
              v93 = *(_OWORD *)(v49 + 80);
              v53.n128_u64[1] = *((_QWORD *)&v93 + 1);
              v52.n128_u64[0] = v83[3];
              v54 = *((_DWORD *)v73 + 6);
              v55 = *(_DWORD *)(v49 + 96);
              v56 = (uint64_t *)(*(_QWORD *)(v49 + 120) + 16);
              v92[0] = v51;
              v53.n128_f64[0] = v50;
              word_trie_s::insert(v56, (uint64_t)v37, v42, v92, v59, v58, v55, v54, v53, v52, v68, v67, HIBYTE(v67), 3, v70, 0, 0);
            }
            os_unfair_lock_unlock(v29);
            if (v35 != v32)
              free(v35);
          }
        }
      }
      _Block_object_dispose(&v72, 8);
      _Block_object_dispose(&v76, 8);
      _Block_object_dispose(&v82, 8);
      v28 = v19;
      if (!v17)
        goto LABEL_34;
    }
    else
    {
      v28 = 0;
      if (!v17)
      {
LABEL_34:
        if (v19)
          CFRelease(v28);
        return;
      }
    }
    CFRelease(v17);
    goto LABEL_34;
  }
}

uint64_t tokenPossibleMatch(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  const char *v6;
  size_t v7;
  char *v8;
  size_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  _QWORD v14[2];

  v14[1] = *MEMORY[0x1E0C80C00];
  v6 = *(const char **)a1;
  v7 = strlen(*(const char **)a1);
  v8 = (char *)v14 - ((MEMORY[0x1E0C80A78](v7) + 17) & 0xFFFFFFFFFFFFFFF0);
  bzero(v8, v9);
  memcpy(v8, v6, v7);
  if (v7 && (v10 = v7 - 1, v8[v7 - 1] == 42))
  {
    if ((a4 & 1) == 0)
    {
      if (v7 == 2)
      {
        v10 = 1;
      }
      else if (v8[v7 - 2] != 32)
      {
        v8[v10] = 32;
        v10 = v7;
      }
    }
    v11 = &v8[v10];
  }
  else
  {
    v11 = &v8[v7];
    if ((a4 & 1) == 0)
      *v11++ = 32;
  }
  *v11 = 0;
  if (!*(_QWORD *)(a1 + 56))
  {
    os_unfair_lock_lock((os_unfair_lock_t)&s_search_context_unfair_lock);
    if (*(_QWORD *)(a1 + 56))
    {
      os_unfair_lock_unlock((os_unfair_lock_t)&s_search_context_unfair_lock);
    }
    else
    {
      v12 = icu_search_context_create();
      __dmb(0xBu);
      *(_QWORD *)(a1 + 56) = v12;
      os_unfair_lock_unlock((os_unfair_lock_t)&s_search_context_unfair_lock);
      if (!v12)
        return 0;
    }
  }
  return icu_search_match();
}

void addCrossFieldOidWithLock(uint64_t a1, uint64_t a2, os_unfair_lock_s *a3)
{
  const __CFAllocator *v5;
  CFNumberRef v6;
  CFNumberRef v7;
  __CFSet *Mutable;
  uint64_t valuePtr;

  valuePtr = a2;
  if (a1)
  {
    v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v6 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt64Type, &valuePtr);
    if (v6)
    {
      v7 = v6;
      os_unfair_lock_lock(a3);
      Mutable = *(__CFSet **)(a1 + 40);
      if (Mutable
        || (Mutable = CFSetCreateMutable(v5, 0, MEMORY[0x1E0C9B3B0]), (*(_QWORD *)(a1 + 40) = Mutable) != 0))
      {
        CFSetAddValue(Mutable, v7);
      }
      os_unfair_lock_unlock(a3);
      CFRelease(v7);
    }
  }
}

void handlePatternsForPhrases(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t a5, int a6, UErrorCode a7, uint64_t a8, os_unfair_lock_s *a9)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t *v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v31;
  _QWORD *v32;
  uint64_t v33;
  uint64_t v35;
  CFTypeRef v38;
  uint64_t v39;
  uint64_t KeyPhraseAtIndex;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  size_t v45;
  uint64_t v46;
  unsigned __int8 v47;
  char v48;
  uint64_t v49;
  unint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t *v53;
  unint64_t v54;
  _QWORD *v55;
  uint64_t v56;
  uint64_t v57;
  _QWORD *v58;
  uint64_t v59;
  uint64_t v60;
  unsigned __int16 *v61;
  _QWORD *v62;
  BOOL v64;
  _BYTE *v65;
  int v66;
  uint64_t v67;
  double v68;
  __n128 v69;
  uint64_t v70;
  int v71;
  __int128 v72;
  __n128 v73;
  uint64_t v74;
  uint64_t v75;
  _QWORD v76[2];
  _QWORD *v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  __int128 *v81;
  UErrorCode v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  os_unfair_lock_t v86;
  __int128 v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  unint64_t v91;
  CFLocaleRef v92;
  uint64_t v93;
  unint64_t v94;
  CFTypeRef v95;
  uint64_t v96;
  int v98;
  __int16 v99;
  int v100;
  int v101;
  uint64_t v102;
  uint64_t v103;
  unint64_t v104;
  unint64_t v105;
  uint64_t v106;
  uint64_t v107;
  __int128 v108;
  unint64_t v109;
  uint64_t v110;
  uint64_t v111;
  __int128 v112;
  __n128 v113;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  uint64_t v117;

  v117 = *MEMORY[0x1E0C80C00];
  if (a5)
  {
    if (*(_QWORD *)(a1 + 120))
    {
      v98 = a6;
      if (lazySearchContextAtIndex(a4, a5, *(_QWORD *)(a1 + 136), 0))
      {
        v83 = a8;
        v86 = a9;
        v94 = a1 + 12192;
        v91 = a1 + 4968;
        v90 = a1 + 9784;
        v14 = a1 + 13696;
        v15 = *(_QWORD *)(a1 + 112);
        v93 = a1 + 12794;
        v82 = a7;
        if (v15)
          v89 = *(_QWORD *)(v15 + 8);
        else
          v89 = 0;
        v92 = CFLocaleCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], *(CFLocaleIdentifier *)(a1 + 128));
        v16 = 0;
        v95 = 0;
        v17 = 0;
        v18 = 0;
        v84 = a1;
        v19 = a1 + 160;
        v20 = *(_QWORD *)(a1 + 160);
        v21 = *(_QWORD *)(a1 + 152);
        v81 = (__int128 *)(a1 + 16);
        v85 = a1 + 13720;
        v87 = xmmword_1B8631BE0;
        v80 = a1 + 9784;
        v79 = a1 + 4976;
        v96 = a2;
        v22 = a3;
        v23 = v93;
        v88 = v19;
        do
        {
          v110 = 0;
          v111 = 0;
          if (!icu_search_match() || v98 && v20 >= 2 && v20 + v21 >= v96)
            break;
          v16 += v111;
          if (v17 < v22)
          {
            v24 = v110 + v16;
            v25 = (uint64_t *)(v19 + 16 * v17);
            v26 = v94;
            while (1)
            {
              v21 = *(v25 - 1);
              if (v21 < v18)
                ++v18;
              else
                v18 = *(v25 - 1);
              v27 = *(_QWORD *)(v14 + 16 * v21);
              if (v16 >= v27)
              {
                v20 = *v25;
                v28 = *v25 + v21;
                if (v24 <= *(_QWORD *)(v14 + 16 * v28 - 8) + *(_QWORD *)(v14 + 16 * v28 - 16))
                  break;
              }
              ++v17;
              v25 += 2;
              if (v22 == v17)
                goto LABEL_87;
            }
            v29 = *(_QWORD *)(v14 + 16 * v21 + 8) + v27;
            if (v27 < v16 && v29 < v16)
            {
              v31 = v96;
              if (v18 + 1 > v96)
                v31 = v18 + 1;
              if (v18 == v31 - 1)
              {
LABEL_36:
                v18 = v31;
              }
              else
              {
                v32 = (_QWORD *)(v85 + 16 * v18++);
                while (1)
                {
                  v33 = *(v32 - 1);
                  v29 = *v32 + v33;
                  if (v33 >= v16 || v29 >= v16)
                    break;
                  v32 += 2;
                  if (v31 == ++v18)
                    goto LABEL_36;
                }
              }
            }
            if (v29 >= v24)
              v35 = v18;
            else
              v35 = v18 + 1;
            if (v35 >= v28 || v18 >= v96 || v35 >= v96)
              break;
            v38 = v95;
            if (!v95)
            {
              *(_QWORD *)&v112 = v23;
              *((_QWORD *)&v112 + 1) = v14;
              v113.n128_u64[0] = v94;
              v113.n128_u64[1] = v91;
              *(_QWORD *)&v114 = v90;
              *((_QWORD *)&v114 + 1) = v96;
              v39 = SILanguageModelCopyLocale();
              v26 = v94;
              v38 = (CFTypeRef)v39;
              if (!v39)
              {
                v95 = 0;
                break;
              }
            }
            v109 = 0;
            v108 = v87;
            v102 = v23;
            v103 = v14 + 16 * v21;
            v104 = v26;
            v105 = v91 + 16 * v21;
            v106 = v90 + 8 * v21;
            v107 = v20;
            v101 = 0;
            v95 = v38;
            KeyPhraseAtIndex = SILanguageModelGetKeyPhraseAtIndex();
            if (KeyPhraseAtIndex != -1)
            {
              v42 = v41;
              if (v41 <= 13)
              {
                v43 = KeyPhraseAtIndex + v21;
                v44 = KeyPhraseAtIndex + v21 + v41;
                if (v35 < v44
                  && v18 >= v43
                  && (uint64_t)(*(_QWORD *)(v91 + 16 * v44 - 16)
                             - *(_QWORD *)(v91 + 16 * v43)
                             + *(_QWORD *)(v91 + 16 * v44 - 8)) <= 29)
                {
                  v78 = v35;
                  v76[1] = v76;
                  MEMORY[0x1E0C80A78](KeyPhraseAtIndex);
                  v77 = &v76[-4 * v42];
                  bzero(v77, v45);
                  if (v42 < 1)
                  {
                    v50 = 0;
                    v47 = 0;
                  }
                  else
                  {
                    v46 = 0;
                    v47 = 0;
                    v48 = 0;
                    v49 = v43;
                    v50 = 0;
                    v51 = v78 - v49;
                    v52 = v80 + 8 * v49;
                    v53 = (uint64_t *)(v79 + 16 * v49);
                    v54 = v94;
                    v55 = v77;
                    do
                    {
                      v56 = *(v53 - 1);
                      if (v46)
                      {
                        v57 = *(v53 - 2) + *(v53 - 3);
                        if (v56 > v57)
                        {
                          v58 = &v55[2 * v50];
                          *v58 = v54 + 2 * v57;
                          *((_DWORD *)v58 + 2) = v56 - v57;
                          *((_BYTE *)v58 + 12) = 1;
                          ++v50;
                          ++v48;
                        }
                      }
                      v59 = *v53;
                      v60 = *(_QWORD *)(v52 + 8 * v46);
                      v61 = (unsigned __int16 *)(v54 + 2 * v56);
                      v62 = &v55[2 * v50];
                      *v62 = v61;
                      *((_DWORD *)v62 + 2) = v59;
                      v64 = (v60 & 0x800) == 0 && v60 != 0;
                      *((_BYTE *)v62 + 12) = v64;
                      v65 = (char *)v62 + 12;
                      if (v59 == 1)
                      {
                        v66 = *v61;
                        if (v66 == 45 || v66 == 38)
                          *v65 = 1;
                      }
                      ++v50;
                      if (v51 == v46)
                        v47 = v48 + v46;
                      ++v46;
                      v53 += 2;
                    }
                    while (v42 != v46);
                  }
                  v100 = 0;
                  v99 = 0;
                  v67 = v84;
                  v68 = (*(double (**)(void))(*(_QWORD *)(v84 + 104) + 16))();
                  os_unfair_lock_lock(v86);
                  if (v50)
                  {
                    v69.n128_u64[0] = v109;
                    v70 = *(_QWORD *)(v67 + 120);
                    v71 = *(_DWORD *)(v67 + 96);
                    v72 = v81[3];
                    v114 = v81[2];
                    v115 = v72;
                    v116 = v81[4];
                    v73 = (__n128)v81[1];
                    v112 = *v81;
                    v113 = v73;
                    v73.n128_f64[0] = v68;
                    word_trie_s::insert((uint64_t *)(v70 + 16), (uint64_t)v77, v50, &v112, v83, v82, v71, v101, v73, v69, v100, v99, HIBYTE(v99), 1, 0, v47, 0);
                  }
                  os_unfair_lock_unlock(v86);
                  v35 = v78;
                }
              }
            }
            if ((_QWORD)v108 == -1)
            {
              v74 = v35 + 1;
              if (v35 + 1 >= v96)
                v75 = v35;
              else
                v75 = v35 + 1;
            }
            else
            {
              v74 = v108 + v21 + *((_QWORD *)&v108 + 1);
              v75 = v74 - (v74 == v96);
            }
            v23 = v93;
            if (v74 >= v28)
              ++v17;
            v16 = *(_QWORD *)(v14 + 16 * v75);
            v19 = v88;
          }
        }
        while (v17 < v22);
LABEL_87:
        if (v92)
          CFRelease(v92);
        if (v95)
          CFRelease(v95);
      }
    }
  }
}

uint64_t lazySearchContextAtIndex(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;

  if (!*(_QWORD *)(a1 + 8 * a4))
    return 0;
  v6 = *(_QWORD *)(a2 + 8 * a4);
  if (!v6)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&s_search_context_unfair_lock);
    v6 = *(_QWORD *)(a2 + 8 * a4);
    if (!v6)
    {
      v6 = icu_search_context_create();
      __dmb(0xBu);
      *(_QWORD *)(a2 + 8 * a4) = v6;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&s_search_context_unfair_lock);
  }
  return v6;
}

__n128 __Block_byref_object_copy_(uint64_t a1, uint64_t a2)
{
  __n128 result;

  result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 40) = result;
  return result;
}

uint64_t ___ZL21normalizeSourceStringP26StringTokenizerPhrasesInfoPhmmb_block_invoke()
{
  uint64_t result;

  result = unorm2_getNFCInstance();
  normalizeSourceString(StringTokenizerPhrasesInfo *,unsigned char *,unsigned long,unsigned long,BOOL)::norm2 = result;
  return result;
}

uint64_t tokenrangescallback(unsigned __int16 *a1, uint64_t a2, char a3, _QWORD *a4)
{
  uint64_t v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  size_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  int8x16_t v18;
  int8x16_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v25;
  unsigned int v26;
  unint64_t v27;
  uint64_t *v28;
  _QWORD v29[2];

  v29[1] = *MEMORY[0x1E0C80C00];
  v7 = a4[9];
  if ((a3 & 1) != 0)
  {
    if (v7)
    {
      if (*((unsigned __int16 *)a4 + 33) < *((unsigned __int16 *)a4 + 32))
      {
        MEMORY[0x1E0C80A78](a1);
        v9 = (char *)v29 - ((v8 + 16) & 0xFFFFFFFFFFFFFFF0);
        bzero(v9, (6 * a2) | 1);
        v10 = _utf16_to_utf8(a1, a2, (unsigned __int8 *)v9, (6 * a2) | 1, *((unsigned __int8 *)a4 + 80));
        if (v10)
        {
          v11 = v10;
          v9[v10] = 0;
          v13 = *(_QWORD *)(*a4 + 88);
          v12 = *(_QWORD *)(*a4 + 96);
          printf("[%d,%d] %s\n", v13, v12, v9);
          v14 = (void *)a4[6];
          if (v14)
          {
            if ((unint64_t)v14 + v11 < a4[5])
            {
              v15 = *(unsigned __int16 *)(a4[1] + 2 * v13);
              if (v15 >> 8 >= 0x11 && ((v15 & 0xFF00) == 0x1100 || (v15 - 11904) >> 7 < 0x197 || v15 - 65376 <= 0x4F))
              {
                v16 = a4[4];
                v17 = *((unsigned __int16 *)a4 + 13);
                *((_WORD *)a4 + 13) = v17 + 1;
                v18.i64[0] = v13;
                v18.i64[1] = v12;
                v19.i64[0] = 0xFFFFFFFFLL;
                v19.i64[1] = 0xFFFFFFFFLL;
                *(int8x16_t *)(v16 + 16 * v17) = vandq_s8(v18, v19);
                memcpy(v14, v9, v11);
                v20 = a4[6];
                v21 = v20 - *((_DWORD *)a4 + 14);
                v22 = a4[9];
                v23 = *((unsigned __int16 *)a4 + 33);
                *((_WORD *)a4 + 33) = v23 + 1;
                *(_WORD *)(v22 + 2 * v23) = v21;
                a4[6] = v20 + v11;
              }
            }
          }
        }
      }
    }
  }
  else if (!v7)
  {
    v25 = *((unsigned __int16 *)a4 + 13);
    v26 = *((unsigned __int16 *)a4 + 12);
    if (v25 >= v26)
      return 1;
    v27 = a4[1];
    if (v27 <= (unint64_t)a1 && (unint64_t)&a1[a2] <= a4[2])
    {
      v28 = (uint64_t *)(a4[4] + 16 * v25);
      LODWORD(v25) = v25 + 1;
      *((_WORD *)a4 + 13) = v25;
      *v28 = (uint64_t)((uint64_t)a1 - v27) >> 1;
      v28[1] = a2;
    }
    if (v25 >= v26)
      return 1;
  }
  return 0;
}

uint64_t handlePatterns(unsigned __int8 *a1, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, os_unfair_lock_s *a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned __int16 v12;
  unsigned __int16 v13;
  unsigned __int8 *v14;
  unsigned __int8 *v15;
  int v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  int v20;
  int v21;
  int v22;
  unint64_t v23;
  int v24;
  unsigned __int8 *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _OWORD *v29;
  _OWORD *v30;
  int v31;
  BOOL v32;
  char v33;
  double v34;
  __n128 v35;
  __n128 v36;
  unint64_t v37;
  int v38;
  uint64_t v39;
  unsigned __int16 v40;
  uint64_t *v42;
  __int128 *v43;
  unsigned __int8 *v46;
  char v47;
  unint64_t v48;
  char v49;
  __int128 v54[5];
  _OWORD v55[14];
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  if (a3 && (v9 = *((_QWORD *)a1 + 14)) != 0 && (v10 = *(_QWORD *)(v9 + 16)) != 0)
  {
    v47 = 0;
    v11 = 0;
    v12 = 0;
    v13 = 0;
    v49 = 0;
    v14 = a1 + 6462;
    v15 = a1 + 4960;
    v16 = a2 - *a1;
    v42 = (uint64_t *)(v10 + 16);
    v43 = (__int128 *)(a1 + 16);
    v46 = a1 + 152;
    v48 = a3;
    while (a2 > v13)
    {
      v17 = v13;
      v18 = *(unsigned __int16 *)&v14[2 * v13];
      lazySearchContextAtIndex(a4, a5, *((_QWORD *)a1 + 16), v11);
      if ((icu_search_match() & 1) != 0)
      {
        while (1)
        {
          v19 = *(unsigned __int16 *)&v14[2 * v17];
          if (v18 <= v19)
            break;
          if (a2 == ++v17)
          {
            LOWORD(v17) = a2;
            goto LABEL_14;
          }
        }
        v49 |= v18 < v19;
LABEL_14:
        if (!v11)
          v12 = v17;
        if (v11 + 1 >= v48)
        {
          v21 = v49 & 1;
          v22 = v12 - v21;
          memset(v55, 0, sizeof(v55));
          if (v16 > (unsigned __int16)(v12 - v21))
          {
            v23 = 0;
            v24 = (unsigned __int16)(v12 - v21);
            v25 = &v46[16 * (unsigned __int16)v22];
            do
            {
              if (v22 == v24)
              {
                v26 = *((_QWORD *)v25 - 1);
              }
              else
              {
                if (v23 - 13 < 0xFFFFFFFFFFFFFFF1)
                  goto LABEL_34;
                v27 = *((_QWORD *)v25 - 3);
                v28 = *((_QWORD *)v25 - 2);
                v29 = &v55[v23];
                *(_QWORD *)v29 = &v15[2 * v27 + 2 * v28];
                v26 = *((_QWORD *)v25 - 1);
                *((_DWORD *)v29 + 2) = v26 - (v28 + v27);
                ++v23;
                *((_BYTE *)v29 + 12) = 1;
              }
              v30 = &v55[v23];
              *(_QWORD *)v30 = &v15[2 * v26];
              v31 = *(_DWORD *)v25;
              *((_DWORD *)v30 + 2) = *(_DWORD *)v25;
              *((_BYTE *)v30 + 12) = 0;
              if (v23)
                v32 = v31 <= 20;
              else
                v32 = 1;
              v33 = !v32;
              if (v31 > 40 || (v33 & 1) != 0)
                goto LABEL_35;
              ++v23;
              ++v24;
              v25 += 16;
            }
            while (v16 > v24);
            if (!v23)
              goto LABEL_35;
LABEL_34:
            v34 = (*(double (**)(void))(*((_QWORD *)a1 + 13) + 16))();
            os_unfair_lock_lock(a8);
            v35 = (__n128)v43[3];
            v54[2] = v43[2];
            v54[3] = (__int128)v35;
            v54[4] = v43[4];
            v36 = (__n128)v43[1];
            v54[0] = *v43;
            v35.n128_u64[1] = *((_QWORD *)&v54[0] + 1);
            v54[1] = (__int128)v36;
            v35.n128_u64[0] = 0;
            v36.n128_f64[0] = v34;
            word_trie_s::insert(v42, (uint64_t)v55, v23, v54, a7, U_ZERO_ERROR, *((_DWORD *)a1 + 24), 0, v36, v35, 0, 0, 0, a6, 0, 0, 0);
            os_unfair_lock_unlock(a8);
            v47 = 1;
          }
LABEL_35:
          v37 = v11 + 2;
          if (a2 > (unsigned __int16)(v12 + 1))
            v38 = 0;
          else
            v38 = 2;
          if (a2 > (unsigned __int16)(v12 + 1))
            v39 = 0;
          else
            v39 = v11 + 2;
          if (a2 > (unsigned __int16)(v12 + 1))
            v40 = v12 + 2;
          else
            v40 = v17;
          if (v37 >= v48)
            v20 = v38;
          else
            v20 = 2;
          if (v37 >= v48)
            v11 = v39;
          else
            v11 += 2;
          if (v37 < v48)
          {
            v13 = v17;
          }
          else
          {
            ++v12;
            v13 = v40;
          }
        }
        else
        {
          v13 = v17 + 1;
          v20 = 3;
          ++v11;
        }
      }
      else
      {
        if (a6 || v11)
          return v47 & 1;
        ++v13;
        v20 = 3;
      }
      if (v20 == 2)
        return v47 & 1;
    }
  }
  else
  {
    v47 = 0;
  }
  return v47 & 1;
}

double pqinit_CompletionItem_s(uint64_t a1)
{
  _OWORD *v2;
  double result;

  *(_OWORD *)(a1 + 8) = xmmword_1B8631BF0;
  v2 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 0x1DC0uLL, 0x6085D6BuLL);
  if (!v2)
    _log_fault_for_malloc_failure();
  *(_QWORD *)a1 = v2;
  result = 0.0;
  v2[12] = 0u;
  v2[13] = 0u;
  v2[10] = 0u;
  v2[11] = 0u;
  v2[8] = 0u;
  v2[9] = 0u;
  v2[6] = 0u;
  v2[7] = 0u;
  v2[4] = 0u;
  v2[5] = 0u;
  v2[2] = 0u;
  v2[3] = 0u;
  *v2 = 0u;
  v2[1] = 0u;
  return result;
}

void pqdispose_CompletionItem_s(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  if (*(uint64_t *)(a1 + 16) >= 2)
  {
    v2 = 1;
    v3 = 368;
    do
    {
      CFRelease(*(CFTypeRef *)(*(_QWORD *)a1 + v3));
      ++v2;
      v3 += 224;
    }
    while (*(_QWORD *)(a1 + 16) > v2);
  }
  free(*(void **)a1);
}

void GetCompletionItemWeight(_QWORD *a1)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  double v5;
  double v6;
  double v7;
  uint64_t v8;
  long double v9;

  if (a1)
  {
    v3 = a1[8];
    v2 = a1[9];
    if (a1[4] + 1 == a1[1])
      v4 = 1;
    else
      v4 = a1[4] + 1 - a1[1];
    if (v2)
      log((double)v2);
    log((double)v3);
    v5 = (double)(unint64_t)a1[3];
    v6 = *(double *)&qword_1EDBBD490;
    if (*(double *)&qword_1EDBBD490 >= v5)
    {
      log((double)(unint64_t)a1[3]);
    }
    else
    {
      log(*(long double *)&qword_1EDBBD490);
      log(v5 - v6);
    }
    v7 = *(double *)&xmmword_1EDBBD4B8;
    if (*(double *)&xmmword_1EDBBD4B8 >= (double)v4)
    {
      if (v4 >= 0)
        v8 = v4;
      else
        v8 = v4 + 1;
      log((double)((v8 >> 1) + 1));
    }
    else
    {
      log(*(double *)&xmmword_1EDBBD4B8 * 0.5 + 1.0);
      log(((double)v4 - v7) * 0.5 + 1.0);
    }
    v9 = 157680000.0;
    if (*((double *)a1 + 5) > 0.0)
      v9 = *((double *)a1 + 5);
    log(v9);
  }
}

void SICompletionModelEnumerateCompletions(uint64_t a1)
{
  uint64_t v1;
  const char *v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  const char *v8;
  uint64_t v9;
  uint64_t v10;
  char v11;
  uint64_t v12;
  char *v13;
  char *v14;
  char v15;
  char v16;
  int v17;
  char *v18;
  char v19;
  int v20;
  int v21;
  uint64_t v22;
  char *v23;
  char *v24;
  char v25;
  char v26;
  int v27;
  char *v28;
  char v29;
  int v30;
  int v31;
  uint64_t v32;
  int v33;
  NSObject *v34;
  os_log_type_t v35;
  int v36;
  const __CFAllocator *v37;
  const __CFString *v38;
  CFMutableStringRef v39;
  CFIndex v40;
  const UniChar *v41;
  const UniChar *v42;
  uint64_t v43;
  char *v44;
  uint64_t v45;
  char *v46;
  char *v47;
  char v48;
  char v49;
  int v50;
  char *v51;
  char v52;
  int v53;
  int v54;
  uint64_t v55;
  int v56;
  NSObject *v57;
  os_log_type_t v58;
  const __CFAllocator *v59;
  const __CFString *v60;
  CFMutableStringRef MutableCopy;
  CFIndex Length;
  const UniChar *CharactersPtr;
  const UniChar *v64;
  uint64_t v65;
  char *v66;
  uint64_t v67;
  uint64_t v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  const void *v76;
  double v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  double v83;
  uint64_t v84;
  double v85;
  __int128 *v87;
  __int128 *v88;
  uint64_t v94;
  uint64_t v95;
  BOOL v96;
  uint64_t v99;
  int v100;
  NSObject *v101;
  os_log_type_t v102;
  int v103;
  const __CFString *v104;
  CFMutableStringRef v105;
  CFIndex v106;
  const UniChar *v107;
  const UniChar *v108;
  uint64_t v109;
  char *v110;
  uint64_t v111;
  unint64_t v112;
  uint64_t v113;
  uint64_t v114;
  unint64_t v115;
  uint64_t v116;
  uint64_t v117;
  const CFSetCallBacks *v118;
  const __CFAllocator *v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  __int128 v123;
  __int128 v124;
  __int128 v125;
  __int128 v126;
  __int128 v127;
  __int128 v128;
  _OWORD *v129;
  double v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  double v136;
  uint64_t v137;
  double v138;
  BOOL v139;
  __int128 *v140;
  __int128 *v141;
  uint64_t v144;
  uint64_t v145;
  const void *v148;
  __CFSet *v149;
  __int128 v150;
  unsigned int v151;
  _QWORD *v152;
  __int128 v153;
  __int128 v154;
  __int128 v155;
  __int128 v156;
  __int128 v157;
  CFTypeRef v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  __int128 v162;
  __int128 v163;
  __int128 v164;
  __int128 v165;
  __int128 v166;
  __int128 v167;
  _OWORD *v168;
  double v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  double v175;
  uint64_t v176;
  double v177;
  BOOL v178;
  __int128 *v179;
  __int128 *v180;
  uint64_t v183;
  uint64_t v184;
  const __CFString *v187;
  __CFSet *v188;
  __int128 v189;
  unsigned int v190;
  _QWORD *v191;
  __int128 v192;
  __int128 v193;
  __int128 v194;
  __int128 v195;
  __int128 v196;
  CFStringRef Copy;
  unsigned int v198;
  unsigned int v199;
  unsigned int v200;
  uint64_t v201;
  unsigned int v202;
  uint64_t v203;
  uint64_t v204;
  _OWORD *v205;
  __int128 v206;
  __int128 v207;
  __int128 v208;
  __int128 v209;
  __int128 v210;
  __int128 v211;
  __int128 v212;
  const void *v213;
  uint64_t v214;
  char *v215;
  _OWORD *v216;
  __int128 v217;
  __int128 v218;
  __int128 v219;
  __int128 v220;
  __int128 v221;
  __int128 v222;
  __int128 v223;
  const void *v224;
  unsigned int v225;
  int v226;
  NSObject *v227;
  int v228;
  NSObject *v229;
  int v230;
  NSObject *v231;
  _QWORD v232[2];
  unsigned int v233;
  unsigned int v234;
  _QWORD *v235;
  _QWORD *v236;
  char *v237;
  CFAllocatorRef v238;
  unsigned int v239;
  uint64_t v240;
  unsigned int v241;
  const __CFSet *v242;
  const __CFSet *Mutable;
  uint64_t v244;
  char *v245;
  __int128 v246;
  __int128 v247;
  __int128 v248;
  __int128 v249;
  __int128 v250;
  uint64_t v251;
  __int128 v252;
  uint64_t v253;
  __int128 v254;
  uint64_t v255;
  __int128 v256;
  uint64_t v257;
  char v258;
  __int128 v259;
  __int128 v260;
  __int128 v261;
  __int128 v262;
  __int128 v263;
  __int128 v264;
  __int128 v265;
  __int128 v266;
  __int128 v267;
  __int128 v268;
  __int128 v269;
  __int128 v270;
  __int128 v271;
  __int128 v272;
  uint64_t v273;
  __int128 v274;
  __int128 v275;
  __int128 v276;
  __int128 v277;
  __int128 v278;
  __int128 v279;
  __int128 v280;
  __int128 v281;
  __int128 v282;
  __int128 v283;
  __int128 v284;
  __int128 v285;
  uint64_t v286;
  __int128 v287;
  __int128 v288;
  __int128 v289;
  __int128 v290;
  __int128 v291;
  __int128 v292;
  __int128 v293;
  __int128 v294;
  __int128 v295;
  __int128 v296;
  __int128 v297;
  __int128 v298;
  uint64_t v299;
  _OWORD v300[2];
  __int128 v301;
  __int128 v302;
  __int128 v303;
  __int128 v304;
  __int128 v305;
  __int128 v306;
  __int128 v307;
  __int128 v308;
  __int128 v309;
  __int128 v310;
  __int128 v311;
  __int128 v312;
  uint64_t v313;

  v1 = MEMORY[0x1E0C80A78](a1);
  *(_QWORD *)&v246 = v6;
  v313 = *MEMORY[0x1E0C80C00];
  if (!v1 || !v5)
    return;
  v7 = v4;
  v8 = v2;
  v9 = v1;
  v244 = v5;
  v10 = 200;
  if (v4 < 0xC8)
    v10 = v4;
  v240 = v10;
  v11 = *(_BYTE *)(v1 + 4);
  *((_QWORD *)&v246 + 1) = v3;
  if ((v11 & 1) != 0)
  {
    v256 = 0uLL;
    v257 = 0;
    pqinit_CompletionItem_s((uint64_t)&v256);
    v22 = *(_QWORD *)(v9 + 16);
    v23 = strdup(v8);
    v24 = v23;
    v25 = 0;
    v26 = 0;
    v27 = 0;
    v28 = v23;
    while (1)
    {
      v29 = v25;
      v31 = *v28++;
      v30 = v31;
      if (v31 == 92)
      {
        v25 = 1;
        if ((v29 & 1) != 0)
          goto LABEL_17;
      }
      else
      {
        if (!v30)
        {
          if (!((v27 == 0) | v26 & 1))
          {
            v55 = v27 - 1;
            if (v23[v55] == 42)
              v23[v55] = 0;
          }
          v23[v27] = 0;
          v56 = *__error();
          v57 = _SILogForLogForCategory(1);
          v58 = 2 * (dword_1EF19FC90 < 4);
          if (os_log_type_enabled(v57, v58))
          {
            LODWORD(v300[0]) = 134217984;
            *(_QWORD *)((char *)v300 + 4) = v7;
            _os_log_impl(&dword_1B8270000, v57, v58, "Completion v1 count:%llu", (uint8_t *)v300, 0xCu);
          }
          *__error() = v56;
          if (dword_1EF19FC90 >= 5)
          {
            v228 = *__error();
            v229 = _SILogForLogForCategory(1);
            if (os_log_type_enabled(v229, OS_LOG_TYPE_DEFAULT))
            {
              LODWORD(v300[0]) = 136315394;
              *(_QWORD *)((char *)v300 + 4) = v24;
              WORD6(v300[0]) = 2080;
              *(_QWORD *)((char *)v300 + 14) = v8;
              _os_log_impl(&dword_1B8270000, v229, OS_LOG_TYPE_DEFAULT, "Creating unescaped string %s with from %s", (uint8_t *)v300, 0x16u);
            }
            *__error() = v228;
          }
          v59 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
          v60 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v24, 0x8000100u);
          MutableCopy = CFStringCreateMutableCopy(v59, 0, v60);
          CFRelease(v60);
          CFStringLowercase(MutableCopy, 0);
          Length = CFStringGetLength(MutableCopy);
          CharactersPtr = CFStringGetCharactersPtr(MutableCopy);
          if (v22)
          {
            v64 = CharactersPtr;
            bzero(&v274, 0x1180uLL);
            v65 = -4480;
            do
            {
              v66 = (char *)&v274 + v65;
              *((_QWORD *)v66 + 584) = 0;
              *((_OWORD *)v66 + 291) = 0uLL;
              *((_OWORD *)v66 + 290) = 0uLL;
              *((_OWORD *)v66 + 289) = 0uLL;
              *((_OWORD *)v66 + 288) = 0uLL;
              *((_OWORD *)v66 + 287) = 0uLL;
              *((_OWORD *)v66 + 286) = 0uLL;
              *((_OWORD *)v66 + 285) = 0uLL;
              *((_OWORD *)v66 + 284) = 0uLL;
              *((_OWORD *)v66 + 283) = 0uLL;
              *((_OWORD *)v66 + 282) = 0uLL;
              *((_OWORD *)v66 + 281) = 0uLL;
              *((_OWORD *)v66 + 280) = 0uLL;
              *((_QWORD *)v66 + 585) = 0xFFEFFFFFFFFFFFFFLL;
              *((_OWORD *)v66 + 293) = 0uLL;
              v65 += 224;
            }
            while (v65);
            v264 = 0u;
            v265 = 0u;
            v262 = 0u;
            v263 = 0u;
            v261 = 0u;
            v248 = 0u;
            v249 = 0u;
            v247 = 0x3FF0000000000000uLL;
            *(_QWORD *)((char *)&v248 + 7) = 0;
            *(_QWORD *)&v249 = &v261;
            *(_QWORD *)&v250 = v246;
            *(_QWORD *)&v287 = MEMORY[0x1E0C809B0];
            *((_QWORD *)&v287 + 1) = 0x40000000;
            *(_QWORD *)&v288 = ___ZL24update_completions_queueP16_CompletionModelP13si_wordtrie_sPKcS4_myP23PQueue_CompletionItem_s_block_invoke;
            *((_QWORD *)&v288 + 1) = &__block_descriptor_tmp_14_1381;
            *(_QWORD *)&v289 = Length;
            *((_QWORD *)&v289 + 1) = v9;
            v290 = v246;
            *(_QWORD *)&v291 = v7;
            *((_QWORD *)&v291 + 1) = &v274;
            *(_QWORD *)&v292 = v64;
            *((_QWORD *)&v292 + 1) = &v256;
            *(_QWORD *)&v293 = v24;
            *((_QWORD *)&v293 + 1) = MutableCopy;
            bzero(v300, 0x1400uLL);
            word_trie_s::iterateFragments(v22 + 16, (uint64_t)v300, 0, 0, &v247, (uint64_t)&v287, 0, 0);
          }
          CFRelease(MutableCopy);
          free(v24);
          LOBYTE(v260) = 0;
LABEL_49:
          v67 = v257;
          if (v257 == 1)
            goto LABEL_72;
          v68 = v256;
          v69 = *(_OWORD *)(v256 + 400);
          v309 = *(_OWORD *)(v256 + 384);
          v310 = v69;
          v70 = *(_OWORD *)(v256 + 432);
          v311 = *(_OWORD *)(v256 + 416);
          v312 = v70;
          v71 = *(_OWORD *)(v256 + 336);
          v305 = *(_OWORD *)(v256 + 320);
          v306 = v71;
          v72 = *(_OWORD *)(v256 + 368);
          v307 = *(_OWORD *)(v256 + 352);
          v308 = v72;
          v73 = *(_OWORD *)(v256 + 272);
          v301 = *(_OWORD *)(v256 + 256);
          v302 = v73;
          v74 = *(_OWORD *)(v256 + 304);
          v303 = *(_OWORD *)(v256 + 288);
          v304 = v74;
          v75 = *(_OWORD *)(v256 + 240);
          v300[0] = *(_OWORD *)(v256 + 224);
          v300[1] = v75;
          v76 = (const void *)(v256 + 224 * (v257 - 1));
          v270 = *((_OWORD *)v76 + 9);
          v271 = *((_OWORD *)v76 + 10);
          v272 = *((_OWORD *)v76 + 11);
          v273 = *((_QWORD *)v76 + 24);
          v266 = *((_OWORD *)v76 + 5);
          v267 = *((_OWORD *)v76 + 6);
          v268 = *((_OWORD *)v76 + 7);
          v269 = *((_OWORD *)v76 + 8);
          v262 = *((_OWORD *)v76 + 1);
          v263 = *((_OWORD *)v76 + 2);
          v264 = *((_OWORD *)v76 + 3);
          v265 = *((_OWORD *)v76 + 4);
          v261 = *(_OWORD *)v76;
          v77 = *((double *)v76 + 25);
          v252 = *((_OWORD *)v76 + 13);
          memmove((void *)(v256 + 224), v76, 0xC8uLL);
          *(double *)(v68 + 424) = v77;
          *(_OWORD *)(v68 + 432) = v252;
          v257 = v67 - 1;
          v78 = *((uint64_t *)&v256 + 1) >> 1;
          v284 = v271;
          v285 = v272;
          v286 = v273;
          v280 = v267;
          v281 = v268;
          v282 = v269;
          v283 = v270;
          v276 = v263;
          v277 = v264;
          v278 = v265;
          v279 = v266;
          v79 = 1;
          v80 = 2;
          v81 = 3;
          v274 = v261;
          v275 = v262;
          while (1)
          {
            v82 = v256 + 224 * v80;
            v83 = *(double *)(v82 + 200);
            v247 = *(_OWORD *)(v82 + 208);
            v84 = v256 + 224 * v81;
            v296 = *(_OWORD *)(v84 + 144);
            v297 = *(_OWORD *)(v84 + 160);
            v298 = *(_OWORD *)(v84 + 176);
            v299 = *(_QWORD *)(v84 + 192);
            v292 = *(_OWORD *)(v84 + 80);
            v293 = *(_OWORD *)(v84 + 96);
            v294 = *(_OWORD *)(v84 + 112);
            v295 = *(_OWORD *)(v84 + 128);
            v288 = *(_OWORD *)(v84 + 16);
            v289 = *(_OWORD *)(v84 + 32);
            v290 = *(_OWORD *)(v84 + 48);
            v291 = *(_OWORD *)(v84 + 64);
            v287 = *(_OWORD *)v84;
            v85 = *(double *)(v84 + 200);
            v254 = *(_OWORD *)(v84 + 208);
            if (v81 >= v67)
            {
              v297 = xmmword_1B8628510;
              v298 = unk_1B8628520;
              v299 = 0;
              v293 = xmmword_1B86284D0;
              v294 = unk_1B86284E0;
              v296 = unk_1B8628500;
              v295 = xmmword_1B86284F0;
              v289 = xmmword_1B8628490;
              v290 = unk_1B86284A0;
              v292 = unk_1B86284C0;
              v291 = xmmword_1B86284B0;
              v288 = unk_1B8628480;
              v287 = max_CompletionItem_s;
              v254 = xmmword_1B8628540;
              if (v80 >= v67)
                goto LABEL_69;
              v85 = 1.79769313e308;
            }
            if (v83 >= v77)
            {
              if (v85 >= v77)
              {
                _X8 = v256 + 448 * v79;
                __asm { PRFM            #1, [X8] }
LABEL_69:
                (*(void (**)(uint64_t, _OWORD *, __int128 *))(v244 + 16))(v244, v300, &v260);
                if ((_QWORD)v308)
                  CFRelease((CFTypeRef)v308);
                if ((_BYTE)v260)
                {
LABEL_72:
                  pqdispose_CompletionItem_s((uint64_t)&v256);
                  return;
                }
                goto LABEL_49;
              }
              v88 = &v254;
              v87 = &v287;
            }
            else
            {
              _NF = v85 < v83;
              if (v85 >= v83)
                v87 = (__int128 *)(v256 + 224 * v80);
              else
                v87 = &v287;
              if (v85 < v83)
              {
                v88 = &v254;
              }
              else
              {
                v85 = v83;
                v88 = &v247;
              }
              if (!_NF)
                v81 = v80;
            }
            v270 = v87[9];
            v271 = v87[10];
            v272 = v87[11];
            v273 = *((_QWORD *)v87 + 24);
            v266 = v87[5];
            v267 = v87[6];
            v268 = v87[7];
            v269 = v87[8];
            v262 = v87[1];
            v263 = v87[2];
            v264 = v87[3];
            v265 = v87[4];
            v261 = *v87;
            _X11 = v256 + 448 * v81;
            __asm { PRFM            #1, [X11] }
            if (v81 != v79)
            {
              v80 = 2 * v81;
              v94 = v256 + 224 * v81;
              *(_OWORD *)(v94 + 144) = v283;
              *(_OWORD *)(v94 + 160) = v284;
              *(_OWORD *)(v94 + 176) = v285;
              *(_QWORD *)(v94 + 192) = v286;
              *(_OWORD *)(v94 + 80) = v279;
              *(_OWORD *)(v94 + 96) = v280;
              *(_OWORD *)(v94 + 112) = v281;
              *(_OWORD *)(v94 + 128) = v282;
              *(_OWORD *)(v94 + 16) = v275;
              *(_OWORD *)(v94 + 32) = v276;
              *(_OWORD *)(v94 + 48) = v277;
              *(_OWORD *)(v94 + 64) = v278;
              *(_OWORD *)v94 = v274;
              *(double *)(v94 + 200) = v77;
              *(_OWORD *)(v94 + 208) = v252;
              v95 = v256 + 224 * v79;
              v79 = v81;
              *(_OWORD *)v95 = v261;
              *(_OWORD *)(v95 + 144) = v270;
              *(_OWORD *)(v95 + 160) = v271;
              *(_OWORD *)(v95 + 176) = v272;
              *(_QWORD *)(v95 + 192) = v273;
              *(_OWORD *)(v95 + 80) = v266;
              *(_OWORD *)(v95 + 96) = v267;
              *(_OWORD *)(v95 + 112) = v268;
              *(_OWORD *)(v95 + 128) = v269;
              *(_OWORD *)(v95 + 16) = v262;
              *(_OWORD *)(v95 + 32) = v263;
              *(_OWORD *)(v95 + 48) = v264;
              *(_OWORD *)(v95 + 64) = v265;
              *(double *)(v95 + 200) = v85;
              *(_OWORD *)(v95 + 208) = *v88;
              v271 = v284;
              v272 = v285;
              v273 = v286;
              v267 = v280;
              v268 = v281;
              v269 = v282;
              v270 = v283;
              v263 = v276;
              v264 = v277;
              v265 = v278;
              v266 = v279;
              v261 = v274;
              v262 = v275;
              v96 = v81 < v78;
              v81 = (2 * v81) | 1;
              if (v96)
                continue;
            }
            goto LABEL_69;
          }
        }
LABEL_17:
        v25 = 0;
        v23[v27++] = v30;
        v26 = v29;
      }
    }
  }
  v254 = 0uLL;
  v255 = 0;
  pqinit_CompletionItem_s((uint64_t)&v254);
  v252 = 0uLL;
  v253 = 0;
  pqinit_CompletionItem_s((uint64_t)&v252);
  v12 = *(_QWORD *)(v9 + 24);
  v13 = strdup(v8);
  v14 = v13;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = v13;
  while (1)
  {
    v19 = v15;
    v21 = *v18++;
    v20 = v21;
    if (v21 != 92)
      break;
    v15 = 1;
    if ((v19 & 1) != 0)
    {
LABEL_11:
      v15 = 0;
      v13[v17++] = v20;
      v16 = v19;
    }
  }
  if (v20)
    goto LABEL_11;
  if (!((v17 == 0) | v16 & 1))
  {
    v32 = v17 - 1;
    if (v13[v32] == 42)
      v13[v32] = 0;
  }
  v13[v17] = 0;
  v33 = *__error();
  v34 = _SILogForLogForCategory(1);
  v35 = 2 * (dword_1EF19FC90 < 4);
  if (os_log_type_enabled(v34, v35))
  {
    v36 = *(_DWORD *)(v9 + 4);
    LODWORD(v300[0]) = 67109376;
    DWORD1(v300[0]) = v36;
    WORD4(v300[0]) = 2048;
    *(_QWORD *)((char *)v300 + 10) = v240;
    _os_log_impl(&dword_1B8270000, v34, v35, "Completion v2 options: 0x%x count:%llu", (uint8_t *)v300, 0x12u);
  }
  *__error() = v33;
  if (dword_1EF19FC90 >= 5)
  {
    v226 = *__error();
    v227 = _SILogForLogForCategory(1);
    if (os_log_type_enabled(v227, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v300[0]) = 136315394;
      *(_QWORD *)((char *)v300 + 4) = v14;
      WORD6(v300[0]) = 2080;
      *(_QWORD *)((char *)v300 + 14) = v8;
      _os_log_impl(&dword_1B8270000, v227, OS_LOG_TYPE_DEFAULT, "Creating unescaped string %s with from %s", (uint8_t *)v300, 0x16u);
    }
    *__error() = v226;
  }
  v37 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v38 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v14, 0x8000100u);
  v238 = v37;
  v39 = CFStringCreateMutableCopy(v37, 0, v38);
  CFRelease(v38);
  CFStringLowercase(v39, 0);
  v40 = CFStringGetLength(v39);
  v41 = CFStringGetCharactersPtr(v39);
  if (v12)
  {
    v42 = v41;
    bzero(&v274, 0x1180uLL);
    v43 = -4480;
    do
    {
      v44 = (char *)&v274 + v43;
      *((_QWORD *)v44 + 584) = 0;
      *((_OWORD *)v44 + 291) = 0uLL;
      *((_OWORD *)v44 + 290) = 0uLL;
      *((_OWORD *)v44 + 289) = 0uLL;
      *((_OWORD *)v44 + 288) = 0uLL;
      *((_OWORD *)v44 + 287) = 0uLL;
      *((_OWORD *)v44 + 286) = 0uLL;
      *((_OWORD *)v44 + 285) = 0uLL;
      *((_OWORD *)v44 + 284) = 0uLL;
      *((_OWORD *)v44 + 283) = 0uLL;
      *((_OWORD *)v44 + 282) = 0uLL;
      *((_OWORD *)v44 + 281) = 0uLL;
      *((_OWORD *)v44 + 280) = 0uLL;
      *((_QWORD *)v44 + 585) = 0xFFEFFFFFFFFFFFFFLL;
      *((_OWORD *)v44 + 293) = 0uLL;
      v43 += 224;
    }
    while (v43);
    v264 = 0u;
    v265 = 0u;
    v262 = 0u;
    v263 = 0u;
    v261 = 0u;
    v248 = 0u;
    v249 = 0u;
    v247 = 0x3FF0000000000000uLL;
    *(_QWORD *)((char *)&v248 + 7) = 0;
    *(_QWORD *)&v249 = &v261;
    *(_QWORD *)&v250 = v246;
    *(_QWORD *)&v256 = 0;
    *((_QWORD *)&v256 + 1) = &v256;
    v257 = 0x2000000000;
    v258 = 0;
    if ((_QWORD)v246 && (!strncmp("ja", (const char *)v246, 2uLL) || !strncmp("zh", (const char *)v246, 2uLL)))
      v258 = 1;
    *(_QWORD *)&v287 = MEMORY[0x1E0C809B0];
    *((_QWORD *)&v287 + 1) = 0x40000000;
    *(_QWORD *)&v288 = ___ZL27update_completions_queue_v2P16_CompletionModelP13si_wordtrie_sPKcS4_myP23PQueue_CompletionItem_s_block_invoke;
    *((_QWORD *)&v288 + 1) = &unk_1E6E2EC28;
    *((_QWORD *)&v289 + 1) = v9;
    *(_QWORD *)&v289 = &v256;
    *(_QWORD *)&v290 = *((_QWORD *)&v246 + 1);
    *((_QWORD *)&v290 + 1) = v40;
    *(_QWORD *)&v291 = v240;
    *((_QWORD *)&v291 + 1) = &v274;
    *(_QWORD *)&v292 = v42;
    *((_QWORD *)&v292 + 1) = &v254;
    *(_QWORD *)&v293 = v14;
    bzero(v300, 0x1400uLL);
    word_trie_s::iterateFragments(v12 + 16, (uint64_t)v300, 0, 0, &v247, (uint64_t)&v287, 0, 0);
    _Block_object_dispose(&v256, 8);
  }
  CFRelease(v39);
  free(v14);
  v45 = *(_QWORD *)(v9 + 32);
  v46 = strdup(v8);
  v47 = v46;
  v48 = 0;
  v49 = 0;
  v50 = 0;
  v51 = v46;
  while (2)
  {
    while (2)
    {
      v52 = v48;
      v54 = *v51++;
      v53 = v54;
      if (v54 == 92)
      {
        v48 = 1;
        if ((v52 & 1) == 0)
          continue;
        goto LABEL_37;
      }
      break;
    }
    if (v53)
    {
LABEL_37:
      v48 = 0;
      v46[v50++] = v53;
      v49 = v52;
      continue;
    }
    break;
  }
  if (!((v50 == 0) | v49 & 1))
  {
    v99 = v50 - 1;
    if (v46[v99] == 42)
      v46[v99] = 0;
  }
  v46[v50] = 0;
  v100 = *__error();
  v101 = _SILogForLogForCategory(1);
  v102 = 2 * (dword_1EF19FC90 < 4);
  if (os_log_type_enabled(v101, v102))
  {
    v103 = *(_DWORD *)(v9 + 4);
    LODWORD(v300[0]) = 67109376;
    DWORD1(v300[0]) = v103;
    WORD4(v300[0]) = 2048;
    *(_QWORD *)((char *)v300 + 10) = v240;
    _os_log_impl(&dword_1B8270000, v101, v102, "Completion v3 options: 0x%x count:%llu", (uint8_t *)v300, 0x12u);
  }
  *__error() = v100;
  if (dword_1EF19FC90 >= 5)
  {
    v230 = *__error();
    v231 = _SILogForLogForCategory(1);
    if (os_log_type_enabled(v231, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v300[0]) = 136315394;
      *(_QWORD *)((char *)v300 + 4) = v47;
      WORD6(v300[0]) = 2080;
      *(_QWORD *)((char *)v300 + 14) = v8;
      _os_log_impl(&dword_1B8270000, v231, OS_LOG_TYPE_DEFAULT, "Creating unescaped string %s with from %s", (uint8_t *)v300, 0x16u);
    }
    *__error() = v230;
  }
  v104 = CFStringCreateWithCString(v238, v47, 0x8000100u);
  v105 = CFStringCreateMutableCopy(v238, 0, v104);
  CFRelease(v104);
  CFStringLowercase(v105, 0);
  v106 = CFStringGetLength(v105);
  v107 = CFStringGetCharactersPtr(v105);
  if (v45)
  {
    v108 = v107;
    bzero(&v274, 0x1180uLL);
    v109 = -4480;
    do
    {
      v110 = (char *)&v274 + v109;
      *((_QWORD *)v110 + 584) = 0;
      *((_OWORD *)v110 + 291) = 0uLL;
      *((_OWORD *)v110 + 290) = 0uLL;
      *((_OWORD *)v110 + 289) = 0uLL;
      *((_OWORD *)v110 + 288) = 0uLL;
      *((_OWORD *)v110 + 287) = 0uLL;
      *((_OWORD *)v110 + 286) = 0uLL;
      *((_OWORD *)v110 + 285) = 0uLL;
      *((_OWORD *)v110 + 284) = 0uLL;
      *((_OWORD *)v110 + 283) = 0uLL;
      *((_OWORD *)v110 + 282) = 0uLL;
      *((_OWORD *)v110 + 281) = 0uLL;
      *((_OWORD *)v110 + 280) = 0uLL;
      *((_QWORD *)v110 + 585) = 0xFFEFFFFFFFFFFFFFLL;
      *((_OWORD *)v110 + 293) = 0uLL;
      v109 += 224;
    }
    while (v109);
    v264 = 0u;
    v265 = 0u;
    v262 = 0u;
    v263 = 0u;
    v261 = 0u;
    v248 = 0u;
    v249 = 0u;
    v247 = 0x3FF0000000000000uLL;
    *(_QWORD *)((char *)&v248 + 7) = 0;
    *(_QWORD *)&v249 = &v261;
    *(_QWORD *)&v250 = v246;
    *(_QWORD *)&v287 = MEMORY[0x1E0C809B0];
    *((_QWORD *)&v287 + 1) = 0x40000000;
    *(_QWORD *)&v288 = ___ZL27update_completions_queue_v3P16_CompletionModelP13si_wordtrie_sPKcS4_myP23PQueue_CompletionItem_s_block_invoke;
    *((_QWORD *)&v288 + 1) = &__block_descriptor_tmp_28_1387;
    *(_QWORD *)&v289 = v106;
    *((_QWORD *)&v289 + 1) = *((_QWORD *)&v246 + 1);
    *(_QWORD *)&v290 = v240;
    *((_QWORD *)&v290 + 1) = &v274;
    *(_QWORD *)&v291 = v108;
    *((_QWORD *)&v291 + 1) = &v252;
    *(_QWORD *)&v292 = v47;
    bzero(v300, 0x1400uLL);
    word_trie_s::iterateFragments(v45 + 16, (uint64_t)v300, 0, 0, &v247, (uint64_t)&v287, 0, 0);
  }
  CFRelease(v105);
  free(v47);
  v232[1] = v232;
  v111 = v240;
  v112 = 224 * v240;
  MEMORY[0x1E0C80A78](v113);
  v235 = &v232[v112 / 0xFFFFFFFFFFFFFFF8];
  bzero(&v232[v112 / 0xFFFFFFFFFFFFFFF8], 224 * v111);
  MEMORY[0x1E0C80A78](v114);
  v115 = (8 * v111 + 15) & 0xFFFFFFFFFFFFFFF0;
  v245 = (char *)v232 - v115;
  bzero((char *)v232 - v115, 8 * v111);
  MEMORY[0x1E0C80A78](v116);
  v236 = &v232[v112 / 0xFFFFFFFFFFFFFFF8];
  bzero(&v232[v112 / 0xFFFFFFFFFFFFFFF8], 224 * v111);
  MEMORY[0x1E0C80A78](v117);
  v237 = (char *)v232 - v115;
  bzero((char *)v232 - v115, 8 * v111);
  v118 = (const CFSetCallBacks *)MEMORY[0x1E0C9B3B0];
  v119 = v238;
  Mutable = CFSetCreateMutable(v238, 0, MEMORY[0x1E0C9B3B0]);
  v242 = CFSetCreateMutable(v119, 0, v118);
  v234 = ((double)v111 * 0.5);
  v120 = v255;
  v121 = v255 - 1;
  if (v255 == 1)
  {
    v239 = 0;
    goto LABEL_112;
  }
  v239 = 0;
  while (2)
  {
    v122 = v254;
    v123 = *(_OWORD *)(v254 + 336);
    v267 = *(_OWORD *)(v254 + 320);
    v268 = v123;
    v269 = *(_OWORD *)(v254 + 352);
    v124 = *(_OWORD *)(v254 + 272);
    v263 = *(_OWORD *)(v254 + 256);
    v264 = v124;
    v125 = *(_OWORD *)(v254 + 304);
    v265 = *(_OWORD *)(v254 + 288);
    v266 = v125;
    v126 = *(_OWORD *)(v254 + 240);
    v261 = *(_OWORD *)(v254 + 224);
    v262 = v126;
    *((_QWORD *)&v246 + 1) = *(_QWORD *)(v254 + 368);
    v127 = *(_OWORD *)(v254 + 392);
    v128 = *(_OWORD *)(v254 + 424);
    v249 = *(_OWORD *)(v254 + 408);
    v250 = v128;
    v251 = *(_QWORD *)(v254 + 440);
    v247 = *(_OWORD *)(v254 + 376);
    v248 = v127;
    v129 = (_OWORD *)(v254 + 224 * v121);
    v296 = v129[9];
    v297 = v129[10];
    v298 = v129[11];
    v299 = *((_QWORD *)v129 + 24);
    v292 = v129[5];
    v293 = v129[6];
    v294 = v129[7];
    v295 = v129[8];
    v288 = v129[1];
    v289 = v129[2];
    v290 = v129[3];
    v291 = v129[4];
    v287 = *v129;
    v130 = *((double *)v129 + 25);
    v259 = v129[13];
    memmove((void *)(v254 + 224), v129, 0xC8uLL);
    *(double *)(v122 + 424) = v130;
    *(_OWORD *)(v122 + 432) = v129[13];
    v255 = v121;
    v131 = *((uint64_t *)&v254 + 1) >> 1;
    v309 = v297;
    v310 = v298;
    *(_QWORD *)&v311 = v299;
    v305 = v293;
    v306 = v294;
    v308 = v296;
    v307 = v295;
    v301 = v289;
    v302 = v290;
    v304 = v292;
    v303 = v291;
    v132 = 1;
    v133 = 2;
    v134 = 3;
    v300[1] = v288;
    v300[0] = v287;
    while (2)
    {
      v135 = v254 + 224 * v133;
      v136 = *(double *)(v135 + 200);
      v256 = *(_OWORD *)(v135 + 208);
      v137 = v254 + 224 * v134;
      v283 = *(_OWORD *)(v137 + 144);
      v284 = *(_OWORD *)(v137 + 160);
      v285 = *(_OWORD *)(v137 + 176);
      v286 = *(_QWORD *)(v137 + 192);
      v279 = *(_OWORD *)(v137 + 80);
      v280 = *(_OWORD *)(v137 + 96);
      v281 = *(_OWORD *)(v137 + 112);
      v282 = *(_OWORD *)(v137 + 128);
      v275 = *(_OWORD *)(v137 + 16);
      v276 = *(_OWORD *)(v137 + 32);
      v277 = *(_OWORD *)(v137 + 48);
      v278 = *(_OWORD *)(v137 + 64);
      v274 = *(_OWORD *)v137;
      v138 = *(double *)(v137 + 200);
      v260 = *(_OWORD *)(v137 + 208);
      if (v134 >= v120)
      {
        v284 = xmmword_1B8628510;
        v285 = unk_1B8628520;
        v286 = 0;
        v280 = xmmword_1B86284D0;
        v281 = unk_1B86284E0;
        v282 = xmmword_1B86284F0;
        v283 = unk_1B8628500;
        v276 = xmmword_1B8628490;
        v277 = unk_1B86284A0;
        v278 = xmmword_1B86284B0;
        v279 = unk_1B86284C0;
        v274 = max_CompletionItem_s;
        v275 = unk_1B8628480;
        v260 = xmmword_1B8628540;
        if (v133 >= v120)
          goto LABEL_104;
        v138 = 1.79769313e308;
      }
      if (v136 < v130)
      {
        v139 = v138 < v136;
        if (v138 >= v136)
          v140 = (__int128 *)(v254 + 224 * v133);
        else
          v140 = &v274;
        if (v138 < v136)
        {
          v141 = &v260;
        }
        else
        {
          v138 = v136;
          v141 = &v256;
        }
        if (!v139)
          v134 = v133;
LABEL_96:
        v296 = v140[9];
        v297 = v140[10];
        v298 = v140[11];
        v299 = *((_QWORD *)v140 + 24);
        v292 = v140[5];
        v293 = v140[6];
        v294 = v140[7];
        v295 = v140[8];
        v288 = v140[1];
        v289 = v140[2];
        v290 = v140[3];
        v291 = v140[4];
        v287 = *v140;
        _X11 = v254 + 448 * v134;
        __asm { PRFM            #1, [X11] }
        if (v134 == v132)
          goto LABEL_104;
        v133 = 2 * v134;
        v144 = v254 + 224 * v134;
        *(_OWORD *)(v144 + 144) = v308;
        *(_OWORD *)(v144 + 160) = v309;
        *(_OWORD *)(v144 + 176) = v310;
        *(_QWORD *)(v144 + 192) = v311;
        *(_OWORD *)(v144 + 80) = v304;
        *(_OWORD *)(v144 + 96) = v305;
        *(_OWORD *)(v144 + 112) = v306;
        *(_OWORD *)(v144 + 128) = v307;
        *(_OWORD *)(v144 + 16) = v300[1];
        *(_OWORD *)(v144 + 32) = v301;
        *(_OWORD *)(v144 + 48) = v302;
        *(_OWORD *)(v144 + 64) = v303;
        *(_OWORD *)v144 = v300[0];
        *(double *)(v144 + 200) = v130;
        *(_OWORD *)(v144 + 208) = v259;
        v145 = v254 + 224 * v132;
        v132 = v134;
        *(_OWORD *)v145 = v287;
        *(_OWORD *)(v145 + 144) = v296;
        *(_OWORD *)(v145 + 160) = v297;
        *(_OWORD *)(v145 + 176) = v298;
        *(_QWORD *)(v145 + 192) = v299;
        *(_OWORD *)(v145 + 80) = v292;
        *(_OWORD *)(v145 + 96) = v293;
        *(_OWORD *)(v145 + 112) = v294;
        *(_OWORD *)(v145 + 128) = v295;
        *(_OWORD *)(v145 + 16) = v288;
        *(_OWORD *)(v145 + 32) = v289;
        *(_OWORD *)(v145 + 48) = v290;
        *(_OWORD *)(v145 + 64) = v291;
        *(double *)(v145 + 200) = v138;
        *(_OWORD *)(v145 + 208) = *v141;
        v297 = v309;
        v298 = v310;
        v299 = v311;
        v293 = v305;
        v294 = v306;
        v296 = v308;
        v295 = v307;
        v289 = v301;
        v290 = v302;
        v292 = v304;
        v291 = v303;
        v288 = v300[1];
        v287 = v300[0];
        v96 = v134 < v131;
        v134 = (2 * v134) | 1;
        if (!v96)
          goto LABEL_104;
        continue;
      }
      break;
    }
    if (v138 < v130)
    {
      v141 = &v260;
      v140 = &v274;
      goto LABEL_96;
    }
    _X8 = v254 + 448 * v132;
    __asm { PRFM            #1, [X8] }
LABEL_104:
    v148 = (const void *)*((_QWORD *)&v246 + 1);
    if (*((_QWORD *)&v246 + 1))
    {
      v149 = Mutable;
      if (!contains_similar_string(*((const __CFString **)&v246 + 1), Mutable, (const char *)v246)
        && !CFSetContainsValue(v149, v148))
      {
        v150 = v268;
        v151 = v239;
        v152 = &v235[28 * v239];
        *((_OWORD *)v152 + 6) = v267;
        *((_OWORD *)v152 + 7) = v150;
        *((_OWORD *)v152 + 8) = v269;
        v153 = v264;
        *((_OWORD *)v152 + 2) = v263;
        *((_OWORD *)v152 + 3) = v153;
        v154 = v266;
        *((_OWORD *)v152 + 4) = v265;
        *((_OWORD *)v152 + 5) = v154;
        v155 = v262;
        *(_OWORD *)v152 = v261;
        *((_OWORD *)v152 + 1) = v155;
        v156 = v247;
        *(_OWORD *)(v152 + 21) = v248;
        v157 = v250;
        *(_OWORD *)(v152 + 23) = v249;
        *(_OWORD *)(v152 + 25) = v157;
        v152[18] = v148;
        v152[27] = v251;
        *(_OWORD *)(v152 + 19) = v156;
        v158 = CFRetain(v148);
        *(_QWORD *)&v245[8 * v151] = v158;
        CFSetAddValue(v149, v148);
        v239 = v151 + 1;
      }
      CFRelease(v148);
    }
    v120 = v255;
    v121 = v255 - 1;
    if (v255 != 1)
      continue;
    break;
  }
LABEL_112:
  v233 = v240 - v234;
  v159 = v253;
  v160 = v253 - 1;
  if (v253 == 1)
  {
    v241 = 0;
    goto LABEL_141;
  }
  v241 = 0;
  while (2)
  {
    v161 = v252;
    v162 = *(_OWORD *)(v252 + 336);
    v267 = *(_OWORD *)(v252 + 320);
    v268 = v162;
    v269 = *(_OWORD *)(v252 + 352);
    v163 = *(_OWORD *)(v252 + 272);
    v263 = *(_OWORD *)(v252 + 256);
    v264 = v163;
    v164 = *(_OWORD *)(v252 + 304);
    v265 = *(_OWORD *)(v252 + 288);
    v266 = v164;
    v165 = *(_OWORD *)(v252 + 240);
    v261 = *(_OWORD *)(v252 + 224);
    v262 = v165;
    *((_QWORD *)&v246 + 1) = *(_QWORD *)(v252 + 368);
    v166 = *(_OWORD *)(v252 + 392);
    v167 = *(_OWORD *)(v252 + 424);
    v249 = *(_OWORD *)(v252 + 408);
    v250 = v167;
    v251 = *(_QWORD *)(v252 + 440);
    v247 = *(_OWORD *)(v252 + 376);
    v248 = v166;
    v168 = (_OWORD *)(v252 + 224 * v160);
    v296 = v168[9];
    v297 = v168[10];
    v298 = v168[11];
    v299 = *((_QWORD *)v168 + 24);
    v292 = v168[5];
    v293 = v168[6];
    v294 = v168[7];
    v295 = v168[8];
    v288 = v168[1];
    v289 = v168[2];
    v290 = v168[3];
    v291 = v168[4];
    v287 = *v168;
    v169 = *((double *)v168 + 25);
    v259 = v168[13];
    memmove((void *)(v252 + 224), v168, 0xC8uLL);
    *(double *)(v161 + 424) = v169;
    *(_OWORD *)(v161 + 432) = v168[13];
    v253 = v160;
    v170 = *((uint64_t *)&v252 + 1) >> 1;
    v309 = v297;
    v310 = v298;
    *(_QWORD *)&v311 = v299;
    v305 = v293;
    v306 = v294;
    v308 = v296;
    v307 = v295;
    v301 = v289;
    v302 = v290;
    v304 = v292;
    v303 = v291;
    v171 = 1;
    v172 = 2;
    v173 = 3;
    v300[1] = v288;
    v300[0] = v287;
    while (2)
    {
      v174 = v252 + 224 * v172;
      v175 = *(double *)(v174 + 200);
      v256 = *(_OWORD *)(v174 + 208);
      v176 = v252 + 224 * v173;
      v283 = *(_OWORD *)(v176 + 144);
      v284 = *(_OWORD *)(v176 + 160);
      v285 = *(_OWORD *)(v176 + 176);
      v286 = *(_QWORD *)(v176 + 192);
      v279 = *(_OWORD *)(v176 + 80);
      v280 = *(_OWORD *)(v176 + 96);
      v281 = *(_OWORD *)(v176 + 112);
      v282 = *(_OWORD *)(v176 + 128);
      v275 = *(_OWORD *)(v176 + 16);
      v276 = *(_OWORD *)(v176 + 32);
      v277 = *(_OWORD *)(v176 + 48);
      v278 = *(_OWORD *)(v176 + 64);
      v274 = *(_OWORD *)v176;
      v177 = *(double *)(v176 + 200);
      v260 = *(_OWORD *)(v176 + 208);
      if (v173 >= v159)
      {
        v284 = xmmword_1B8628510;
        v285 = unk_1B8628520;
        v286 = 0;
        v280 = xmmword_1B86284D0;
        v281 = unk_1B86284E0;
        v282 = xmmword_1B86284F0;
        v283 = unk_1B8628500;
        v276 = xmmword_1B8628490;
        v277 = unk_1B86284A0;
        v278 = xmmword_1B86284B0;
        v279 = unk_1B86284C0;
        v274 = max_CompletionItem_s;
        v275 = unk_1B8628480;
        v260 = xmmword_1B8628540;
        if (v172 >= v159)
          goto LABEL_133;
        v177 = 1.79769313e308;
      }
      if (v175 < v169)
      {
        v178 = v177 < v175;
        if (v177 >= v175)
          v179 = (__int128 *)(v252 + 224 * v172);
        else
          v179 = &v274;
        if (v177 < v175)
        {
          v180 = &v260;
        }
        else
        {
          v177 = v175;
          v180 = &v256;
        }
        if (!v178)
          v173 = v172;
LABEL_125:
        v296 = v179[9];
        v297 = v179[10];
        v298 = v179[11];
        v299 = *((_QWORD *)v179 + 24);
        v292 = v179[5];
        v293 = v179[6];
        v294 = v179[7];
        v295 = v179[8];
        v288 = v179[1];
        v289 = v179[2];
        v290 = v179[3];
        v291 = v179[4];
        v287 = *v179;
        _X11 = v252 + 448 * v173;
        __asm { PRFM            #1, [X11] }
        if (v173 == v171)
          goto LABEL_133;
        v172 = 2 * v173;
        v183 = v252 + 224 * v173;
        *(_OWORD *)(v183 + 144) = v308;
        *(_OWORD *)(v183 + 160) = v309;
        *(_OWORD *)(v183 + 176) = v310;
        *(_QWORD *)(v183 + 192) = v311;
        *(_OWORD *)(v183 + 80) = v304;
        *(_OWORD *)(v183 + 96) = v305;
        *(_OWORD *)(v183 + 112) = v306;
        *(_OWORD *)(v183 + 128) = v307;
        *(_OWORD *)(v183 + 16) = v300[1];
        *(_OWORD *)(v183 + 32) = v301;
        *(_OWORD *)(v183 + 48) = v302;
        *(_OWORD *)(v183 + 64) = v303;
        *(_OWORD *)v183 = v300[0];
        *(double *)(v183 + 200) = v169;
        *(_OWORD *)(v183 + 208) = v259;
        v184 = v252 + 224 * v171;
        v171 = v173;
        *(_OWORD *)v184 = v287;
        *(_OWORD *)(v184 + 144) = v296;
        *(_OWORD *)(v184 + 160) = v297;
        *(_OWORD *)(v184 + 176) = v298;
        *(_QWORD *)(v184 + 192) = v299;
        *(_OWORD *)(v184 + 80) = v292;
        *(_OWORD *)(v184 + 96) = v293;
        *(_OWORD *)(v184 + 112) = v294;
        *(_OWORD *)(v184 + 128) = v295;
        *(_OWORD *)(v184 + 16) = v288;
        *(_OWORD *)(v184 + 32) = v289;
        *(_OWORD *)(v184 + 48) = v290;
        *(_OWORD *)(v184 + 64) = v291;
        *(double *)(v184 + 200) = v177;
        *(_OWORD *)(v184 + 208) = *v180;
        v297 = v309;
        v298 = v310;
        v299 = v311;
        v293 = v305;
        v294 = v306;
        v296 = v308;
        v295 = v307;
        v289 = v301;
        v290 = v302;
        v292 = v304;
        v291 = v303;
        v288 = v300[1];
        v287 = v300[0];
        v96 = v173 < v170;
        v173 = (2 * v173) | 1;
        if (!v96)
          goto LABEL_133;
        continue;
      }
      break;
    }
    if (v177 < v169)
    {
      v180 = &v260;
      v179 = &v274;
      goto LABEL_125;
    }
    _X8 = v252 + 448 * v171;
    __asm { PRFM            #1, [X8] }
LABEL_133:
    v187 = (const __CFString *)*((_QWORD *)&v246 + 1);
    if (*((_QWORD *)&v246 + 1))
    {
      v188 = v242;
      if (!contains_similar_string(*((const __CFString **)&v246 + 1), v242, (const char *)v246)
        && !CFSetContainsValue(v188, v187))
      {
        v189 = v268;
        v190 = v241;
        v191 = &v236[28 * v241];
        *((_OWORD *)v191 + 6) = v267;
        *((_OWORD *)v191 + 7) = v189;
        *((_OWORD *)v191 + 8) = v269;
        v192 = v264;
        *((_OWORD *)v191 + 2) = v263;
        *((_OWORD *)v191 + 3) = v192;
        v193 = v266;
        *((_OWORD *)v191 + 4) = v265;
        *((_OWORD *)v191 + 5) = v193;
        v194 = v262;
        *(_OWORD *)v191 = v261;
        *((_OWORD *)v191 + 1) = v194;
        v195 = v247;
        *(_OWORD *)(v191 + 21) = v248;
        v196 = v250;
        *(_OWORD *)(v191 + 23) = v249;
        *(_OWORD *)(v191 + 25) = v196;
        v191[18] = v187;
        v191[27] = v251;
        *(_OWORD *)(v191 + 19) = v195;
        Copy = CFStringCreateCopy(v238, v187);
        *(_QWORD *)&v237[8 * v190] = Copy;
        CFSetAddValue(v188, v187);
        v241 = v190 + 1;
      }
      CFRelease(v187);
    }
    v159 = v253;
    v160 = v253 - 1;
    if (v253 != 1)
      continue;
    break;
  }
LABEL_141:
  if (v239 >= v234)
    v198 = v234;
  else
    v198 = v239;
  if (v241 >= v233)
    v199 = v233;
  else
    v199 = v241;
  if (v199 + v198 >= v240)
  {
    v201 = v244;
  }
  else
  {
    v200 = v241 - v233;
    if (v241 < v233)
      v200 = 0;
    v201 = v244;
    if (v239 <= v234 || v241 > v233)
    {
      if (v241 > v233 && v239 <= v234)
      {
        v225 = v199 + v200;
        if (v225 >= v240)
          v199 = v240;
        else
          v199 = v225;
      }
    }
    else
    {
      v202 = v239 - v234;
      if (v239 < v234)
        v202 = 0;
      v198 += v202;
      if (v198 >= v240)
        v198 = v240;
    }
  }
  LOBYTE(v274) = 0;
  v203 = v239 - 1;
  if ((int)(v239 - 1) >= 0)
  {
    v204 = v198;
    v205 = &v235[28 * v203];
    do
    {
      v206 = v205[11];
      v309 = v205[10];
      v310 = v206;
      v207 = v205[13];
      v311 = v205[12];
      v312 = v207;
      v208 = v205[7];
      v305 = v205[6];
      v306 = v208;
      v209 = v205[9];
      v307 = v205[8];
      v308 = v209;
      v210 = v205[3];
      v301 = v205[2];
      v302 = v210;
      v211 = v205[5];
      v303 = v205[4];
      v304 = v211;
      v212 = v205[1];
      v300[0] = *v205;
      v300[1] = v212;
      v213 = *(const void **)&v245[8 * v203];
      *(_QWORD *)&v308 = v213;
      if (!(_BYTE)v274 && v204 != v203)
        (*(void (**)(uint64_t, _OWORD *, __int128 *))(v201 + 16))(v201, v300, &v274);
      if (v213)
        CFRelease(v213);
      v205 -= 14;
      v96 = v203-- <= 0;
    }
    while (!v96);
  }
  v214 = v241 - 1;
  v215 = v237;
  if ((int)(v241 - 1) >= 0)
  {
    v216 = &v236[28 * v214];
    do
    {
      v217 = v216[11];
      v309 = v216[10];
      v310 = v217;
      v218 = v216[13];
      v311 = v216[12];
      v312 = v218;
      v219 = v216[7];
      v305 = v216[6];
      v306 = v219;
      v220 = v216[9];
      v307 = v216[8];
      v308 = v220;
      v221 = v216[3];
      v301 = v216[2];
      v302 = v221;
      v222 = v216[5];
      v303 = v216[4];
      v304 = v222;
      v223 = v216[1];
      v300[0] = *v216;
      v300[1] = v223;
      v224 = *(const void **)&v215[8 * v214];
      *(_QWORD *)&v308 = v224;
      if (!(_BYTE)v274 && v199 != v214)
        (*(void (**)(uint64_t, _OWORD *, __int128 *))(v201 + 16))(v201, v300, &v274);
      if (v224)
        CFRelease(v224);
      v216 -= 14;
      v96 = v214-- <= 0;
    }
    while (!v96);
  }
  CFRelease(Mutable);
  CFRelease(v242);
  pqdispose_CompletionItem_s((uint64_t)&v254);
  pqdispose_CompletionItem_s((uint64_t)&v252);
}

void ___ZL24update_completions_queueP16_CompletionModelP13si_wordtrie_sPKcS4_myP23PQueue_CompletionItem_s_block_invoke(_QWORD *a1, SIModelManager *a2, SIModelManager *a3, unint64_t a4, __int128 *a5, uint64_t a6, int a7, int a8, double a9, double a10, double a11, int a12, int a13, int a14, __int16 a15, char a16, unsigned int a17, unsigned __int8 a18, uint64_t a19, uint64_t a20)
{
  unint64_t v28;
  uint64_t *v29;
  SIModelManager *v30;
  uint64_t v31;
  unsigned __int8 v32;
  SIModelManager *v33;
  SIModelManager *v34;
  double v35;
  double v36;
  uint64_t v37;
  unsigned int v38;
  double v39;
  _QWORD *v40;
  char *v41;
  int v42;
  SIModelManager *v43;
  unint64_t v44;
  uint64_t v45;
  float v46;
  double v47;
  unint64_t v48;
  unint64_t v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  double v54;
  double v55;
  long double v56;
  float v57;
  float v58;
  float v59;
  float v60;
  double v61;
  double v62;
  double v63;
  double v64;
  unint64_t v65;
  float v66;
  double v67;
  long double v68;
  double v69;
  float v70;
  float v71;
  double v72;
  double v73;
  double v74;
  float v75;
  uint64_t v76;
  double v77;
  double v78;
  uint64_t v79;
  _QWORD *v80;
  double v81;
  double v82;
  double v83;
  double v84;
  double v85;
  double v86;
  double v87;
  double v88;
  double v89;
  double v90;
  double v91;
  double v92;
  double v93;
  double v94;
  double v95;
  double v96;
  double v97;
  double v98;
  int v99;
  int v100;
  NSObject *v101;
  os_log_type_t v102;
  double v103;
  double v104;
  double v105;
  double v106;
  BOOL v107;
  double v108;
  unint64_t v109;
  double v110;
  double v111;
  double v112;
  double v113;
  double v114;
  double v115;
  double v116;
  uint64_t v117;
  double v118;
  double v119;
  double v120;
  double v121;
  uint64_t v122;
  uint64_t v123;
  double v124;
  double v125;
  uint64_t v126;
  double v127;
  unint64_t v128;
  _OWORD *v129;
  __int128 v130;
  __int128 v131;
  __int128 v132;
  __int128 v133;
  __int128 v134;
  __int128 v135;
  __int128 v136;
  __int128 v137;
  __int128 v138;
  __int128 v139;
  uint64_t v140;
  const void *v141;
  size_t v142;
  uint64_t v143;
  uint64_t *v144;
  uint64_t v145;
  double *v146;
  double v147;
  uint64_t v148;
  double v149;
  uint64_t v150;
  double v151;
  int v152;
  NSObject *v153;
  os_log_type_t v154;
  BOOL v155;
  uint64_t v156;
  uint64_t v157;
  int v158;
  NSObject *v159;
  os_log_type_t v160;
  uint64_t v161;
  double v162;
  int v163;
  NSObject *v164;
  os_log_type_t v165;
  uint64_t v166;
  __CFString *v167;
  int v168;
  NSObject *v169;
  os_log_type_t v170;
  uint64_t v171;
  int v172;
  NSObject *v173;
  os_log_type_t v174;
  void **v175;
  char *v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  float v185;
  double v186;
  double v187;
  double v188;
  unint64_t v189;
  double v190;
  float v191;
  double v192;
  double v193;
  float v194;
  double v195;
  double v196;
  uint64_t v197;
  _QWORD *v198;
  unsigned __int8 v199;
  double v200;
  uint64_t v201;
  int v203;
  _OWORD v205[14];
  __int128 v206;
  __int128 v207;
  __int128 v208;
  __int128 v209;
  __int128 v210;
  __int128 v211;
  __int128 v212;
  __int128 v213;
  __int128 v214;
  __int128 v215;
  _OWORD v216[2];
  __int128 v217;
  __int128 v218;
  uint8_t buf[4];
  double v220;
  __int16 v221;
  _BYTE v222[20];
  double v223;
  _BYTE v224[10];
  __int16 v225;
  _BYTE v226[18];
  __int16 v227;
  double v228;
  __int16 v229;
  double v230;
  __int16 v231;
  double v232;
  __int16 v233;
  uint64_t v234;
  __int16 v235;
  double v236;
  __int16 v237;
  double v238;
  __int16 v239;
  unint64_t v240;
  __int16 v241;
  uint64_t v242;
  __int16 v243;
  SIModelManager *v244;
  __int16 v245;
  double v246;
  __int16 v247;
  unint64_t v248;
  __int16 v249;
  unint64_t v250;
  __int16 v251;
  int v252;
  __int16 v253;
  double v254;
  uint64_t v255;

  v255 = *MEMORY[0x1E0C80C00];
  v28 = 0;
  if (a3)
  {
    v29 = (uint64_t *)((char *)a2 + 8);
    v30 = a3;
    do
    {
      v31 = *v29;
      v29 += 2;
      v28 += v31;
      v30 = (SIModelManager *)((char *)v30 - 1);
    }
    while (v30);
  }
  if (a17 && v28 <= a1[4])
    return;
  v32 = a18;
  if (a17 == 2)
  {
    if (v28 < a18)
      return;
    v32 = 0;
  }
  v199 = v32;
  v33 = *(SIModelManager **)(a20 + 16);
  v35 = _hasPunctuation(a2, (unint64_t)a3, a20, 1);
  v36 = v35;
  if ((unint64_t)a3 <= 1 && v35 != 0.0)
    return;
  v37 = a1[5];
  if (v37)
    LODWORD(v37) = *(_DWORD *)(v37 + 4);
  v38 = (v37 >> 1) & 1;
  if ((unint64_t)(a6 - 1) >= 0xFFFFFFFFFFFFFFFELL)
    LOBYTE(v38) = 0;
  if ((v38 & 1) != 0 || v35 == 0.0)
    return;
  v197 = (uint64_t)a2;
  v198 = a1;
  if (v33 == a3)
  {
    v39 = *(double *)(a20 + 8);
    v40 = a1;
  }
  else
  {
    v40 = a1;
    v41 = (char *)a1[6];
    SIModelManager::getInstance(v34);
    SIModelManager::getPhraseScore(v197, v41, a3, (char *)(a20 + 40));
    *(double *)(a20 + 8) = v39;
  }
  v42 = a7;
  v190 = a11;
  v43 = (SIModelManager *)v40[7];
  v44 = v40[8];
  if ((SIModelManager *)((char *)a3 + 1) == v43)
    v45 = 1;
  else
    v45 = (SIModelManager *)((char *)a3 + 1) - v43;
  v46 = (float)a13;
  v47 = *(double *)&qword_1EF19FE30;
  v48 = *(_QWORD *)a5;
  v49 = *((_QWORD *)a5 + 1);
  v217 = 0u;
  v218 = 0u;
  memset(v216, 0, sizeof(v216));
  v214 = 0u;
  v215 = 0u;
  v212 = 0u;
  v213 = 0u;
  v210 = 0u;
  v211 = 0u;
  v209 = 0u;
  v206 = 0u;
  *(_QWORD *)&v207 = 0;
  *((_QWORD *)&v207 + 1) = v28;
  *(_QWORD *)&v208 = a3;
  v196 = a9;
  *((double *)&v208 + 1) = a9;
  v51 = *a5;
  v50 = a5[1];
  v52 = a5[2];
  v53 = a5[4];
  v213 = a5[3];
  v214 = v53;
  v211 = v50;
  v212 = v52;
  v210 = v51;
  *((_QWORD *)&v215 + 1) = __PAIR64__(a8, a7);
  LODWORD(v216[0]) = a12;
  *(_OWORD *)((char *)v216 + 4) = 0uLL;
  v195 = v39;
  *((double *)&v216[1] + 1) = v39;
  v54 = 0.0;
  v55 = *(double *)&s_completion_weights;
  if (v49)
  {
    v56 = log((double)v49);
    v46 = (float)a13;
    v42 = a7;
    v54 = v56 * 18.9648897;
  }
  v57 = (float)v42;
  v58 = (float)a8;
  v59 = (float)a12;
  v191 = v46 + 1.0;
  v60 = v47;
  v61 = v54 + (double)v48;
  v187 = (double)v48;
  v62 = log((double)v48);
  v186 = v62;
  if (v61 == 0.0)
    v62 = 0.0;
  v63 = *(double *)&qword_1EF19FDF8;
  v64 = *(double *)&qword_1EF19FDF0 * v62 + ((double)a7 + (double)v44) / (double)v44 * v55;
  v65 = (unint64_t)*(double *)&qword_1EF19FE60;
  v189 = v48;
  if (v28 <= (unint64_t)*(double *)&qword_1EF19FE60)
  {
    v69 = log((double)v28) * (v63 + v63);
  }
  else
  {
    v66 = v60;
    v67 = (double)v65;
    v193 = log((double)v65);
    v68 = (double)v28 - v67;
    v60 = v66;
    v58 = (float)a8;
    v59 = (float)a12;
    v69 = log(v68) * *(double *)&qword_1EF19FE38 + v193 * v63;
  }
  v194 = v57 / v58;
  v70 = v57 / v59;
  v71 = v57 / (float)v44;
  v72 = v60;
  v73 = v64 + v69;
  v74 = *(double *)&qword_1EF19FE00 * 1.5;
  v75 = 1.0 / v191;
  v76 = v45 - (uint64_t)*(double *)&qword_1EF19FE68;
  if (v45 <= (uint64_t)*(double *)&qword_1EF19FE68)
  {
    if (v45 >= 0)
      v79 = v45;
    else
      v79 = v45 + 1;
    v78 = log((double)((v79 >> 1) + 1)) * v74;
  }
  else
  {
    v77 = log((double)(uint64_t)*(double *)&qword_1EF19FE68 * 0.5 + 1.0);
    v78 = log((double)v76 * 0.5 + 1.0) * *(double *)&qword_1EF19FE50 + v77 * v74;
  }
  v80 = v198;
  v81 = v73 + v78;
  v82 = *(double *)&qword_1EF19FE08;
  if (v194 <= 0.25)
    v82 = 0.0;
  v83 = v81 + v82;
  if (v70 <= 0.25)
    v84 = 0.0;
  else
    v84 = dbl_1EF19FE10;
  v85 = v83 + v84;
  v192 = v71;
  v86 = *(double *)&qword_1EF19FE18;
  if (v71 >= 0.1)
    v86 = 0.0;
  v87 = v75;
  v88 = v85 + v86 + v195 * unk_1EF19FE20 + v75 * *(double *)&qword_1EF19FE28;
  if (!(_BYTE)a15)
    v72 = 0.0;
  v89 = v72 + v88;
  v90 = *(double *)&qword_1EF19FE40;
  if (!a16)
    v90 = 0.0;
  v91 = v90 + v89;
  if (HIBYTE(a15))
    v92 = dbl_1EF19FE48;
  else
    v92 = 0.0;
  v93 = v92 + v91 + 0.0;
  v94 = *(double *)&qword_1EF19FE58;
  v95 = 157680000.0;
  if (v196 > 0.0)
    v95 = v196;
  v96 = log(v95);
  *(_QWORD *)&v218 = __PAIR64__(a17, LODWORD(v75));
  BYTE8(v218) = v199;
  *(_WORD *)((char *)&v218 + 9) = a15;
  BYTE11(v218) = a16;
  v97 = v93 - v94 * v96 + -1.0 / v36;
  *((double *)&v217 + 1) = v97;
  switch(a17)
  {
    case 2u:
      v98 = -1000000.0;
      break;
    case 3u:
      v98 = -100000000.0;
      break;
    case 4u:
      v98 = -1.0e10;
      break;
    default:
      v99 = HIBYTE(a15);
      goto LABEL_60;
  }
  v99 = HIBYTE(a15);
  v97 = v97 + v98;
  *((double *)&v217 + 1) = v97;
LABEL_60:
  v100 = *__error();
  v101 = _SILogForLogForCategory(1);
  v102 = 2 * (dword_1EF19FC90 < 4);
  if (os_log_type_enabled(v101, v102))
  {
    v200 = v72;
    v103 = (double)(unint64_t)v198[8];
    v104 = *(double *)&s_completion_weights;
    v105 = 0.0;
    if (v49)
      v105 = log((double)v49) * 18.9648897;
    v106 = ((double)a7 + v103) / v103;
    v107 = v105 + v187 == 0.0;
    v108 = v186;
    if (v107)
      v108 = 0.0;
    v188 = v108;
    v109 = (unint64_t)*(double *)&qword_1EF19FE60;
    v110 = (double)(unint64_t)v198[4];
    v111 = *(double *)&qword_1EF19FDF8;
    v185 = v70;
    if (v28 <= (unint64_t)*(double *)&qword_1EF19FE60)
    {
      v114 = (v111 + v111) * log((double)v28 - v110);
    }
    else
    {
      v112 = (double)v109;
      v113 = log((double)v109 - v110);
      v114 = log((double)v28 - v112) * *(double *)&qword_1EF19FE38 + v113 * v111;
    }
    v115 = v104 * v106;
    v116 = *(double *)&qword_1EF19FE00 * 1.5;
    v117 = v45 - (uint64_t)*(double *)&qword_1EF19FE68;
    if (v45 <= (uint64_t)*(double *)&qword_1EF19FE68)
    {
      if (v45 >= 0)
        v122 = v45;
      else
        v122 = v45 + 1;
      v121 = log((double)((v122 >> 1) + 1)) * v116;
    }
    else
    {
      v118 = v96;
      v119 = v115;
      v120 = log((double)(uint64_t)*(double *)&qword_1EF19FE68 * 0.5 + 1.0);
      v121 = log((double)v117 * 0.5 + 1.0) * *(double *)&qword_1EF19FE50 + v120 * v116;
      v115 = v119;
      v96 = v118;
    }
    v80 = v198;
    v123 = qword_1EF19FE08;
    v124 = dbl_1EF19FE10;
    if (v194 <= 0.25)
      v123 = 0;
    if (v185 <= 0.25)
      v124 = 0.0;
    v125 = *(double *)&qword_1EF19FE18;
    if (v192 >= 0.1)
      v125 = 0.0;
    v126 = qword_1EF19FE40;
    v127 = dbl_1EF19FE48;
    if (!a16)
      v126 = 0;
    if (!v99)
      v127 = 0.0;
    *(_DWORD *)buf = 134223104;
    v220 = v115;
    v221 = 2048;
    *(double *)v222 = v188;
    *(_WORD *)&v222[8] = 2048;
    *(double *)&v222[10] = v114;
    *(_WORD *)&v222[18] = 2048;
    v223 = v121;
    *(_WORD *)v224 = 2048;
    *(_QWORD *)&v224[2] = v123;
    v225 = 2048;
    *(double *)v226 = v124;
    *(_WORD *)&v226[8] = 2048;
    *(double *)&v226[10] = v125;
    v227 = 2048;
    v228 = v195 * unk_1EF19FE20;
    v229 = 2048;
    v230 = *(double *)&qword_1EF19FE28 * v87;
    v231 = 2048;
    v232 = v200;
    v233 = 2048;
    v234 = v126;
    v235 = 2048;
    v236 = v127;
    v237 = 2048;
    v238 = v96 * *(double *)&qword_1EF19FE58;
    v239 = 2048;
    v240 = v28;
    v241 = 2048;
    v242 = v45;
    v243 = 2048;
    v244 = a3;
    v245 = 2048;
    v246 = v196;
    v247 = 2048;
    v248 = v49;
    v249 = 2048;
    v250 = v189;
    v251 = 1024;
    v252 = a7;
    v253 = 2048;
    v254 = v97;
    _os_log_impl(&dword_1B8270000, v101, v102, " weight_F:%g score_F:%g len_F:%g fragment_F:%g wf1_F:%g wf2_F:%g wf3_F:%g phrase_F:%g field_F:%g thread_F:%g shortcut_F:%g used_F:%g age_F:%g\nlen:%ld scoringFragmentCount:%ld fragmentCount:%ld age:%f score:(%llu, %llu) weight:%d computed score:(%g)", buf, 0xD0u);
  }
  *__error() = v100;
  v128 = a4;
  if (a4 >= 0x14)
  {
    v176 = __si_assert_copy_extra_268();
    __message_assert_272((uint64_t)v176, v177, v178, v179, v180, v181, v182, v183, (char)"SICompletions.cpp");
    free(v176);
    if (__valid_fs(-1))
      v184 = 2989;
    else
      v184 = 3072;
    *(_DWORD *)v184 = -559038737;
    abort();
  }
  v129 = (_OWORD *)(v80[9] + 224 * a4);
  v130 = v207;
  *v129 = v206;
  v129[1] = v130;
  v131 = v208;
  v132 = v209;
  v133 = v211;
  v129[4] = v210;
  v129[5] = v133;
  v129[2] = v131;
  v129[3] = v132;
  v134 = v212;
  v135 = v213;
  v136 = v215;
  v129[8] = v214;
  v129[9] = v136;
  v129[6] = v134;
  v129[7] = v135;
  v137 = v216[0];
  v138 = v216[1];
  v139 = v218;
  v129[12] = v217;
  v129[13] = v139;
  v129[10] = v137;
  v129[11] = v138;
  v140 = v197;
  if (v190 == 1.79769313e308)
  {
    if (a3 == (SIModelManager *)1)
    {
      v141 = (const void *)v80[10];
      if (v141)
      {
        v142 = v80[4];
        if (v142 == *(_QWORD *)(v197 + 8) && !memcmp(v141, *(const void **)v197, v142))
          *(_QWORD *)(v80[9] + 224 * a4 + 200) = 0xFFEFFFFFFFFFFFFFLL;
      }
    }
    return;
  }
  if (v190 == -1.79769313e308)
  {
    v143 = v80[9] + 224 * a4;
    *(_OWORD *)(v143 + 384) = 0u;
    *(_OWORD *)(v143 + 400) = 0u;
    *(_OWORD *)(v143 + 352) = 0u;
    *(_OWORD *)(v143 + 368) = 0u;
    *(_OWORD *)(v143 + 320) = 0u;
    *(_OWORD *)(v143 + 336) = 0u;
    *(_OWORD *)(v143 + 288) = 0u;
    *(_OWORD *)(v143 + 304) = 0u;
    *(_OWORD *)(v143 + 256) = 0u;
    *(_OWORD *)(v143 + 272) = 0u;
    *(_OWORD *)(v143 + 224) = 0u;
    *(_OWORD *)(v143 + 240) = 0u;
    *(_QWORD *)(v143 + 416) = 0;
    *(_QWORD *)(v143 + 424) = 0xFFEFFFFFFFFFFFFFLL;
    *(_QWORD *)(v143 + 432) = 0;
    *(_QWORD *)(v143 + 440) = 0;
  }
  v144 = (uint64_t *)v80[11];
  if (v144[2] >= 22)
  {
    v145 = *v144;
    if (v145)
      v146 = (double *)(v145 + 224);
    else
      v146 = (double *)&empty_CompletionItem_s;
    v147 = v146[25];
    if (v147 > *((double *)&v217 + 1))
      return;
    v149 = v146[3];
    v148 = *((_QWORD *)v146 + 4);
    v150 = *((_QWORD *)v146 + 5);
    v151 = v146[9];
    v201 = *((_QWORD *)v146 + 8);
    v203 = *((_DWORD *)v146 + 38);
    v152 = *__error();
    v153 = _SILogForLogForCategory(1);
    v154 = 2 * (dword_1EF19FC90 < 4);
    if (os_log_type_enabled(v153, v154))
    {
      *(_DWORD *)buf = 134219520;
      v220 = v149;
      v221 = 2048;
      *(_QWORD *)v222 = v148;
      *(_WORD *)&v222[8] = 2048;
      *(_QWORD *)&v222[10] = v150;
      *(_WORD *)&v222[18] = 2048;
      v223 = v151;
      *(_WORD *)v224 = 2048;
      *(_QWORD *)&v224[2] = v201;
      v225 = 1024;
      *(_DWORD *)v226 = v203;
      *(_WORD *)&v226[4] = 2048;
      *(double *)&v226[6] = v147;
      _os_log_impl(&dword_1B8270000, v153, v154, "Pop: %ld %ld %f (%llu,%llu) %d (%g)", buf, 0x44u);
    }
    *__error() = v152;
    v140 = v197;
    v128 = a4;
  }
  if (v128 <= 1)
  {
    v155 = 0;
    v162 = *((double *)&v217 + 1);
  }
  else
  {
    v155 = 1;
    v156 = 424;
    v157 = 1;
    while (1)
    {
      v158 = *__error();
      v159 = _SILogForLogForCategory(1);
      v160 = 2 * (dword_1EF19FC90 < 4);
      if (os_log_type_enabled(v159, v160))
      {
        v161 = *(_QWORD *)(v80[9] + v156);
        *(_QWORD *)&v222[10] = *((_QWORD *)&v217 + 1);
        v162 = *((double *)&v217 + 1);
        *(_DWORD *)buf = 134218496;
        v220 = *(double *)&v157;
        v221 = 2048;
        *(_QWORD *)v222 = v161;
        *(_WORD *)&v222[8] = 2048;
        _os_log_impl(&dword_1B8270000, v159, v160, "Comparing to parent at %ld (%g) %g", buf, 0x20u);
      }
      else
      {
        v162 = *((double *)&v217 + 1);
      }
      *__error() = v158;
      if (*(double *)(v80[9] + v156) > v162)
        break;
      v155 = ++v157 < a4;
      v156 += 224;
      if (a4 == v157)
      {
        v155 = 0;
        goto LABEL_116;
      }
    }
    v163 = *__error();
    v164 = _SILogForLogForCategory(1);
    v165 = 2 * (dword_1EF19FC90 < 4);
    if (os_log_type_enabled(v164, v165))
    {
      v166 = *(_QWORD *)(v80[9] + 224 * v157 + 200);
      *(_DWORD *)buf = 134218496;
      v220 = *(double *)&v157;
      v221 = 2048;
      *(_QWORD *)v222 = v166;
      *(_WORD *)&v222[8] = 2048;
      *(double *)&v222[10] = v162;
      _os_log_impl(&dword_1B8270000, v164, v165, "Dropping weak child %ld (%g) %g", buf, 0x20u);
    }
    *__error() = v163;
LABEL_116:
    v140 = v197;
  }
  if (v162 <= v190)
  {
    v172 = *__error();
    v173 = _SILogForLogForCategory(1);
    v174 = 2 * (dword_1EF19FC90 < 4);
    if (os_log_type_enabled(v173, v174))
    {
      *(_DWORD *)buf = 134218240;
      v220 = v190;
      v221 = 2048;
      *(double *)v222 = v162;
      _os_log_impl(&dword_1B8270000, v173, v174, "Dropping weak parent (%g) %g", buf, 0x16u);
    }
    *__error() = v172;
  }
  else if (!v155)
  {
    *(double *)&v167 = COERCE_DOUBLE(_CreateCFStringFromFragments((const char *)v80[12], (_BYTE *)&v218 + 8, v140, (uint64_t)a3, v28));
    v168 = *__error();
    v169 = _SILogForLogForCategory(1);
    v170 = 2 * (dword_1EF19FC90 < 4);
    if (os_log_type_enabled(v169, v170))
    {
      v171 = v80[12];
      *(_DWORD *)buf = 138413570;
      v220 = *(double *)&v167;
      v221 = 1024;
      *(_DWORD *)v222 = DWORD1(v218);
      *(_WORD *)&v222[4] = 2080;
      *(_QWORD *)&v222[6] = v171;
      *(_WORD *)&v222[14] = 1024;
      *(_DWORD *)&v222[16] = BYTE8(v218);
      LOWORD(v223) = 1024;
      *(_DWORD *)((char *)&v223 + 2) = DWORD2(v215);
      HIWORD(v223) = 2048;
      *(_QWORD *)v224 = *((_QWORD *)&v217 + 1);
      _os_log_impl(&dword_1B8270000, v169, v170, "Creating suggestion string %@, type %d, with completion %s length:%d weight:%d score:%g", buf, 0x32u);
    }
    *__error() = v168;
    if (*(double *)&v167 != 0.0)
    {
      if (CFEqual(v167, (CFTypeRef)v80[13]))
      {
        CFRelease(v167);
      }
      else
      {
        *(_QWORD *)&v215 = v167;
        v175 = (void **)v80[11];
        v205[10] = v216[0];
        v205[11] = v216[1];
        v205[12] = v217;
        v205[13] = v218;
        v205[6] = v212;
        v205[7] = v213;
        v205[2] = v208;
        v205[3] = v209;
        v205[4] = v210;
        v205[5] = v211;
        v205[0] = v206;
        v205[1] = v207;
        v205[8] = v214;
        v205[9] = v215;
        pqpush_CompletionItem_s(v175, (uint64_t)v205);
      }
    }
  }
}

double ___ZL27update_completions_queue_v2P16_CompletionModelP13si_wordtrie_sPKcS4_myP23PQueue_CompletionItem_s_block_invoke(uint64_t a1, SIModelManager *a2, unint64_t a3, unint64_t a4, __int128 *a5, uint64_t a6, unsigned int a7, unsigned int a8, double a9, double a10, double a11, int a12, int a13, int a14, __int16 a15, char a16, int a17, unsigned __int8 a18, unsigned __int8 a19, uint64_t a20,uint64_t a21)
{
  unsigned __int8 v30;
  unint64_t v31;
  uint64_t *v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  size_t *v37;
  __n128 v38;
  uint64_t v39;
  double v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  _OWORD *v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  uint64_t v59;
  const void *v60;
  CFNumberRef v61;
  CFNumberRef v62;
  const __CFSet *v63;
  CFNumberRef v64;
  uint64_t v66;
  uint64_t *v67;
  uint64_t v68;
  double *v69;
  double v70;
  double v71;
  NSObject *v72;
  os_log_type_t v73;
  uint64_t v74;
  int v75;
  NSObject *v76;
  os_log_type_t v77;
  __CFString *CFStringFromCrossFieldFragments;
  __CFString *v79;
  int v80;
  NSObject *v81;
  os_log_type_t v82;
  uint64_t v83;
  void **v84;
  char *v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  int v98;
  int v99;
  unint64_t v100;
  SIModelManager *v101;
  SIModelManager *v102;
  int v103;
  int v104;
  _OWORD v105[14];
  __int128 valuePtr;
  __int128 v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  __int128 v111;
  __int128 v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  _OWORD v116[2];
  __int128 v117;
  __int128 v118;
  uint8_t buf[4];
  double v120;
  __int16 v121;
  _BYTE v122[20];
  uint64_t v123;
  _BYTE v124[10];
  __int16 v125;
  int v126;
  __int16 v127;
  double v128;
  uint64_t v129;

  v30 = a18;
  v129 = *MEMORY[0x1E0C80C00];
  v31 = 0;
  if (a3)
  {
    v32 = (uint64_t *)((char *)a2 + 8);
    v33 = a3;
    do
    {
      v34 = *v32;
      v32 += 2;
      v31 += v34;
      --v33;
    }
    while (v33);
  }
  v35 = *(_QWORD *)(a1 + 40);
  if (!v35)
  {
    if (a17 == 3)
      return -1.79769313e308;
    goto LABEL_14;
  }
  v36 = *(_DWORD *)(v35 + 4);
  if (a19 && (v36 & 4) != 0 && *(_QWORD *)(a1 + 48) != a19)
    return -1.79769313e308;
  if (a17 != 3)
  {
LABEL_14:
    v37 = (size_t *)(a1 + 56);
    if (a17 && v31 < *(_QWORD *)(a1 + 56))
      return -1.79769313e308;
    if (a17 == 2)
    {
      if (v31 < a18)
        return -1.79769313e308;
      v100 = a4;
      v103 = 0;
      v30 = 0;
    }
    else
    {
      v100 = a4;
      v103 = 0;
    }
    goto LABEL_20;
  }
  if ((v36 & 8) == 0)
    return -1.79769313e308;
  if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    if (a3 < 3)
      return -1.79769313e308;
  }
  else if (a3 < 5)
  {
    return -1.79769313e308;
  }
  v100 = a4;
  v102 = a2;
  *(_QWORD *)&valuePtr = a6;
  if (!*(_QWORD *)(v35 + 40))
    return -1.79769313e308;
  v61 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt64Type, &valuePtr);
  if (!v61)
    return -1.79769313e308;
  v62 = v61;
  v63 = *(const __CFSet **)(v35 + 40);
  v64 = v62;
  v104 = CFSetContainsValue(v63, v62);
  CFRelease(v64);
  if (!v104)
    return -1.79769313e308;
  v37 = (size_t *)(a1 + 56);
  if (v31 < *(_QWORD *)(a1 + 56))
    return -1.79769313e308;
  v103 = 1;
  a2 = v102;
LABEL_20:
  v101 = a2;
  v38.n128_f64[0] = _hasPunctuation(a2, a3, a21, 0);
  if (a3 <= 1 && v38.n128_f64[0] != 0.0 && v31 == *v37)
    return -1.79769313e308;
  if ((v103 & 1) == 0)
  {
    v39 = *(_QWORD *)(a1 + 40);
    if (v39)
    {
      if ((unint64_t)(a6 - 1) <= 0xFFFFFFFFFFFFFFFDLL && (*(_DWORD *)(v39 + 4) & 2) != 0)
        return -1.79769313e308;
    }
  }
  if (a14 < 2)
  {
    a10 = 0.0;
    if (v38.n128_f64[0] != 0.0)
      goto LABEL_32;
    return -1.79769313e308;
  }
  v40 = -1.79769313e308;
  if (fabs(a10) <= fabs(*(double *)&xmmword_1EDBBD538) && v38.n128_f64[0] != 0.0)
  {
LABEL_32:
    v117 = 0u;
    v118 = 0u;
    memset(v116, 0, sizeof(v116));
    v109 = 0u;
    v110 = 0u;
    v41 = *a5;
    v42 = a5[1];
    v111 = 0u;
    v112 = 0u;
    *((double *)&v108 + 1) = a9;
    *(double *)&v109 = a10;
    v44 = a5[2];
    v43 = a5[3];
    v113 = 0u;
    v114 = 0u;
    v110 = v41;
    v114 = a5[4];
    v115 = 0u;
    v45 = *(_QWORD *)(a1 + 48);
    *(_QWORD *)&valuePtr = *(_QWORD *)(a1 + 56);
    *((_QWORD *)&valuePtr + 1) = v45;
    *(_QWORD *)&v107 = *(_QWORD *)(a1 + 64);
    *((_QWORD *)&v107 + 1) = v31;
    *(_QWORD *)&v108 = a3;
    v112 = v44;
    v113 = v43;
    v111 = v42;
    *((_QWORD *)&v115 + 1) = __PAIR64__(a8, a7);
    LODWORD(v116[0]) = a12;
    *(_OWORD *)((char *)v116 + 4) = 0uLL;
    *(_QWORD *)&v117 = v38.n128_u64[0];
    v38.n128_f32[0] = 1.0 / (float)((float)a13 + 1.0);
    *(float *)&v118 = v38.n128_f32[0];
    DWORD1(v118) = a17;
    BYTE8(v118) = v30;
    *(_WORD *)((char *)&v118 + 9) = a15;
    BYTE11(v118) = a16;
    BYTE12(v118) = (unint64_t)(a6 - 1) < 0xFFFFFFFFFFFFFFFELL;
    update_item_bundle_ids((uint64_t)&valuePtr, a20, v38);
    GetCompletionItemWeight(&valuePtr);
    *((_QWORD *)&v117 + 1) = v46;
    v47 = v100;
    if (v100 >= 0x14)
    {
      v85 = __si_assert_copy_extra_268();
      __message_assert_272((uint64_t)v85, v86, v87, v88, v89, v90, v91, v92, (char)"SICompletions.cpp");
      free(v85);
      if (__valid_fs(-1))
        v93 = 2989;
      else
        v93 = 3072;
      *(_DWORD *)v93 = -559038737;
      abort();
    }
    v48 = (_OWORD *)(*(_QWORD *)(a1 + 72) + 224 * v100);
    v49 = v107;
    *v48 = valuePtr;
    v48[1] = v49;
    v50 = v108;
    v51 = v109;
    v52 = v111;
    v48[4] = v110;
    v48[5] = v52;
    v48[2] = v50;
    v48[3] = v51;
    v53 = v112;
    v54 = v113;
    v55 = v115;
    v48[8] = v114;
    v48[9] = v55;
    v48[6] = v53;
    v48[7] = v54;
    v56 = v116[0];
    v57 = v116[1];
    v58 = v118;
    v48[12] = v117;
    v48[13] = v58;
    v48[10] = v56;
    v48[11] = v57;
    v59 = (uint64_t)v101;
    if (a11 == 1.79769313e308)
    {
      if (a3 == 1)
      {
        v60 = *(const void **)(a1 + 80);
        if (v60)
        {
          if (*v37 == *((_QWORD *)v101 + 1) && !memcmp(v60, *(const void **)v101, *v37))
          {
            *(_QWORD *)(*(_QWORD *)(a1 + 72) + 224 * v100 + 200) = 0xFFEFFFFFFFFFFFFFLL;
            return -1.79769313e308;
          }
        }
      }
      return *((double *)&v117 + 1);
    }
    if (a11 == -1.79769313e308)
    {
      v66 = *(_QWORD *)(a1 + 72) + 224 * v100;
      *(_OWORD *)(v66 + 384) = 0u;
      *(_OWORD *)(v66 + 400) = 0u;
      *(_OWORD *)(v66 + 352) = 0u;
      *(_OWORD *)(v66 + 368) = 0u;
      *(_OWORD *)(v66 + 320) = 0u;
      *(_OWORD *)(v66 + 336) = 0u;
      *(_OWORD *)(v66 + 288) = 0u;
      *(_OWORD *)(v66 + 304) = 0u;
      *(_OWORD *)(v66 + 256) = 0u;
      *(_OWORD *)(v66 + 272) = 0u;
      *(_OWORD *)(v66 + 224) = 0u;
      *(_OWORD *)(v66 + 240) = 0u;
      *(_QWORD *)(v66 + 416) = 0;
      *(_QWORD *)(v66 + 424) = 0xFFEFFFFFFFFFFFFFLL;
      *(_QWORD *)(v66 + 432) = 0;
      *(_QWORD *)(v66 + 440) = 0;
    }
    v67 = *(uint64_t **)(a1 + 88);
    if (v67[2] >= 22)
    {
      v68 = *v67;
      if (v68)
        v69 = (double *)(v68 + 224);
      else
        v69 = (double *)&empty_CompletionItem_s;
      v70 = v69[25];
      if (v70 > *((double *)&v117 + 1))
        return *((double *)&v117 + 1);
      v71 = v69[3];
      v94 = *((_QWORD *)v69 + 4);
      v95 = *((_QWORD *)v69 + 5);
      v96 = *((_QWORD *)v69 + 9);
      v97 = *((_QWORD *)v69 + 8);
      v98 = *((_DWORD *)v69 + 38);
      v99 = *__error();
      v72 = _SILogForLogForCategory(1);
      v73 = 2 * (dword_1EF19FC90 < 4);
      if (os_log_type_enabled(v72, v73))
      {
        *(_DWORD *)buf = 134219520;
        v120 = v71;
        v121 = 2048;
        *(_QWORD *)v122 = v94;
        *(_WORD *)&v122[8] = 2048;
        *(_QWORD *)&v122[10] = v95;
        *(_WORD *)&v122[18] = 2048;
        v123 = v96;
        *(_WORD *)v124 = 2048;
        *(_QWORD *)&v124[2] = v97;
        v125 = 1024;
        v126 = v98;
        v127 = 2048;
        v128 = v70;
        _os_log_impl(&dword_1B8270000, v72, v73, "Pop: %ld %ld %f (%llu,%llu) %d (%g)", buf, 0x44u);
      }
      *__error() = v99;
      v47 = v100;
      v59 = (uint64_t)v101;
    }
    if (a14 < 2
      || a11 == -1.79769313e308
      || v47 > 0x12
      || (v74 = *(_QWORD *)(a1 + 72), *(double *)(v74 + 224 * (v47 + 1) + 200) == -1.79769313e308)
      || *(double *)(v74 + 224 * (v47 + 1) + 48) != *(double *)&v109)
    {
      if (v103)
        CFStringFromCrossFieldFragments = _CreateCFStringFromCrossFieldFragments(SBYTE8(v118), v59, a3, v31);
      else
        CFStringFromCrossFieldFragments = _CreateCFStringFromFragments(*(const char **)(a1 + 96), (_BYTE *)&v118 + 8, v59, a3, v31);
      v79 = CFStringFromCrossFieldFragments;
      v80 = *__error();
      v81 = _SILogForLogForCategory(1);
      v82 = 2 * (dword_1EF19FC90 < 4);
      if (os_log_type_enabled(v81, v82))
      {
        v83 = *(_QWORD *)(a1 + 96);
        *(_DWORD *)buf = 138413570;
        v120 = *(double *)&v79;
        v121 = 1024;
        *(_DWORD *)v122 = DWORD1(v118);
        *(_WORD *)&v122[4] = 2080;
        *(_QWORD *)&v122[6] = v83;
        *(_WORD *)&v122[14] = 1024;
        *(_DWORD *)&v122[16] = BYTE8(v118);
        LOWORD(v123) = 1024;
        *(_DWORD *)((char *)&v123 + 2) = DWORD2(v115);
        HIWORD(v123) = 2048;
        *(_QWORD *)v124 = *((_QWORD *)&v117 + 1);
        _os_log_impl(&dword_1B8270000, v81, v82, "Creating suggestion string %@, type %d, with completion %s length:%d weight:%d score:%g", buf, 0x32u);
      }
      *__error() = v80;
      if (*(double *)&v79 != 0.0)
      {
        *(_QWORD *)&v115 = v79;
        v84 = *(void ***)(a1 + 88);
        v105[10] = v116[0];
        v105[11] = v116[1];
        v105[12] = v117;
        v105[13] = v118;
        v105[6] = v112;
        v105[7] = v113;
        v105[2] = v108;
        v105[3] = v109;
        v105[4] = v110;
        v105[5] = v111;
        v105[0] = valuePtr;
        v105[1] = v107;
        v105[8] = v114;
        v105[9] = v115;
        pqpush_CompletionItem_s(v84, (uint64_t)v105);
      }
    }
    else
    {
      v75 = *__error();
      v76 = _SILogForLogForCategory(1);
      v77 = 2 * (dword_1EF19FC90 < 4);
      if (os_log_type_enabled(v76, v77))
      {
        *(_DWORD *)buf = 134218240;
        v120 = a11;
        v121 = 2048;
        *(_QWORD *)v122 = *((_QWORD *)&v117 + 1);
        _os_log_impl(&dword_1B8270000, v76, v77, "Dropping dangling parent (%g) %g", buf, 0x16u);
      }
      *__error() = v75;
    }
    return *((double *)&v117 + 1);
  }
  return v40;
}

void ___ZL27update_completions_queue_v3P16_CompletionModelP13si_wordtrie_sPKcS4_myP23PQueue_CompletionItem_s_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, __n128 *a5, uint64_t a6, unsigned int a7, unsigned int a8, double a9, double a10, double a11, int a12, int a13, int a14, __int16 a15, char a16, int a17, char a18, uint64_t a19)
{
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  uint64_t v27;
  __n128 v28;
  __n128 v29;
  double v30;
  __n128 v31;
  __n128 v32;
  uint64_t v33;
  _OWORD *v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __n128 v38;
  __n128 v39;
  __n128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  const void *v45;
  size_t v46;
  uint64_t v47;
  uint64_t *v48;
  uint64_t v49;
  double *v50;
  double v51;
  uint64_t v52;
  NSObject *v53;
  os_log_type_t v54;
  uint64_t v55;
  int v56;
  NSObject *v57;
  os_log_type_t v58;
  __CFString *CFStringFromFragments;
  int v60;
  NSObject *v61;
  os_log_type_t v62;
  uint64_t v63;
  void **v64;
  uint64_t v65;
  unint64_t v66;
  unint64_t v67;
  uint64_t v68;
  size_t v69;
  _OWORD *v70;
  _OWORD *v71;
  char *v72;
  char *v73;
  unint64_t v74;
  char *v75;
  char *v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  char *v87;
  BOOL v88;
  char *v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  int v102;
  int v103;
  __int128 v104;
  __int128 v105;
  __int128 v106;
  __int128 v107;
  __n128 v108;
  __n128 v109;
  __n128 v110;
  __n128 v111;
  __n128 v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  __int128 v117;
  __int128 v118;
  __int128 v119;
  __int128 v120;
  __int128 v121;
  __n128 v122;
  __n128 v123;
  __n128 v124;
  __n128 v125;
  __n128 v126;
  __int128 v127;
  _OWORD v128[2];
  __int128 v129;
  __int128 v130;
  _BYTE buf[80];
  __int128 v132;
  __int128 v133;
  __int128 v134;
  __int128 v135;
  __int128 v136;
  __int128 v137;
  __int128 v138;
  __int128 v139;
  __int128 v140;
  uint64_t v141;

  v141 = *MEMORY[0x1E0C80C00];
  v24 = 0;
  if (a3)
  {
    v25 = (uint64_t *)(a2 + 8);
    v26 = a3;
    do
    {
      v27 = *v25;
      v25 += 2;
      v24 += v27;
      --v26;
    }
    while (v26);
  }
  v129 = 0u;
  v130 = 0u;
  memset(v128, 0, sizeof(v128));
  v121 = 0u;
  v122 = 0u;
  v118 = *(_OWORD *)(a1 + 32);
  v28 = *a5;
  v29 = a5[1];
  v123 = 0u;
  v124 = 0u;
  *((double *)&v120 + 1) = a9;
  v30 = 0.0;
  if (a14 > 1)
    v30 = a10;
  *(double *)&v121 = v30;
  v32 = a5[2];
  v31 = a5[3];
  v125 = 0uLL;
  v126 = 0uLL;
  v122 = v28;
  v123 = v29;
  v126 = a5[4];
  v127 = 0uLL;
  *(_QWORD *)&v119 = *(_QWORD *)(a1 + 48);
  *((_QWORD *)&v119 + 1) = v24;
  *(_QWORD *)&v120 = a3;
  v124 = v32;
  v125 = v31;
  *((_QWORD *)&v127 + 1) = __PAIR64__(a8, a7);
  LODWORD(v128[0]) = a12;
  *(_OWORD *)((char *)v128 + 4) = 0uLL;
  *(_QWORD *)&v129 = 0x3FF0000000000000;
  v31.n128_f32[0] = 1.0 / (float)((float)a13 + 1.0);
  *(float *)&v130 = v31.n128_f32[0];
  DWORD1(v130) = a17;
  BYTE8(v130) = a18;
  *(_WORD *)((char *)&v130 + 9) = a15;
  BYTE11(v130) = a16;
  BYTE12(v130) = (unint64_t)(a6 - 1) < 0xFFFFFFFFFFFFFFFELL;
  update_item_bundle_ids((uint64_t)&v118, a19, v31);
  GetCompletionItemWeight(&v118);
  *((_QWORD *)&v129 + 1) = v33;
  if (a4 > 0x13)
  {
    v89 = __si_assert_copy_extra_268();
    __message_assert_272((uint64_t)v89, v90, v91, v92, v93, v94, v95, v96, (char)"SICompletions.cpp");
    free(v89);
    if (__valid_fs(-1))
      v97 = 2989;
    else
      v97 = 3072;
    *(_DWORD *)v97 = -559038737;
    abort();
  }
  v34 = (_OWORD *)(*(_QWORD *)(a1 + 56) + 224 * a4);
  v35 = v119;
  *v34 = v118;
  v34[1] = v35;
  v36 = v120;
  v37 = v121;
  v38 = v123;
  v34[4] = v122;
  v34[5] = v38;
  v34[2] = v36;
  v34[3] = v37;
  v39 = v124;
  v40 = v125;
  v41 = v127;
  v34[8] = v126;
  v34[9] = v41;
  v34[6] = v39;
  v34[7] = v40;
  v42 = v128[0];
  v43 = v128[1];
  v44 = v130;
  v34[12] = v129;
  v34[13] = v44;
  v34[10] = v42;
  v34[11] = v43;
  if (a11 == 1.79769313e308)
  {
    if (a3 == 1)
    {
      v45 = *(const void **)(a1 + 64);
      if (v45)
      {
        v46 = *(_QWORD *)(a1 + 32);
        if (v46 == *(_QWORD *)(a2 + 8) && !memcmp(v45, *(const void **)a2, v46))
          *(_QWORD *)(*(_QWORD *)(a1 + 56) + 224 * a4 + 200) = 0xFFEFFFFFFFFFFFFFLL;
      }
    }
    return;
  }
  if (a11 == -1.79769313e308)
  {
    v47 = *(_QWORD *)(a1 + 56) + 224 * a4;
    *(_OWORD *)(v47 + 384) = 0u;
    *(_OWORD *)(v47 + 400) = 0u;
    *(_OWORD *)(v47 + 352) = 0u;
    *(_OWORD *)(v47 + 368) = 0u;
    *(_OWORD *)(v47 + 320) = 0u;
    *(_OWORD *)(v47 + 336) = 0u;
    *(_OWORD *)(v47 + 288) = 0u;
    *(_OWORD *)(v47 + 304) = 0u;
    *(_OWORD *)(v47 + 256) = 0u;
    *(_OWORD *)(v47 + 272) = 0u;
    *(_OWORD *)(v47 + 224) = 0u;
    *(_OWORD *)(v47 + 240) = 0u;
    *(_QWORD *)(v47 + 416) = 0;
    *(_QWORD *)(v47 + 424) = 0xFFEFFFFFFFFFFFFFLL;
    *(_QWORD *)(v47 + 432) = 0;
    *(_QWORD *)(v47 + 440) = 0;
  }
  v48 = *(uint64_t **)(a1 + 72);
  if (v48[2] >= 22)
  {
    v49 = *v48;
    if (v49)
      v50 = (double *)(v49 + 224);
    else
      v50 = (double *)&empty_CompletionItem_s;
    v51 = v50[25];
    if (v51 > *((double *)&v129 + 1))
      return;
    v52 = *((_QWORD *)v50 + 3);
    v98 = *((_QWORD *)v50 + 4);
    v99 = *((_QWORD *)v50 + 5);
    v100 = *((_QWORD *)v50 + 9);
    v101 = *((_QWORD *)v50 + 8);
    v102 = *((_DWORD *)v50 + 38);
    v103 = *__error();
    v53 = _SILogForLogForCategory(1);
    v54 = 2 * (dword_1EF19FC90 < 4);
    if (os_log_type_enabled(v53, v54))
    {
      *(_DWORD *)buf = 134219520;
      *(_QWORD *)&buf[4] = v52;
      *(_WORD *)&buf[12] = 2048;
      *(_QWORD *)&buf[14] = v98;
      *(_WORD *)&buf[22] = 2048;
      *(_QWORD *)&buf[24] = v99;
      *(_WORD *)&buf[32] = 2048;
      *(_QWORD *)&buf[34] = v100;
      *(_WORD *)&buf[42] = 2048;
      *(_QWORD *)&buf[44] = v101;
      *(_WORD *)&buf[52] = 1024;
      *(_DWORD *)&buf[54] = v102;
      *(_WORD *)&buf[58] = 2048;
      *(double *)&buf[60] = v51;
      _os_log_impl(&dword_1B8270000, v53, v54, "Pop: %ld %ld %f (%llu,%llu) %d (%g)", buf, 0x44u);
    }
    *__error() = v103;
  }
  if (a11 == -1.79769313e308
    || a4 > 0x12
    || (v55 = *(_QWORD *)(a1 + 56), *(double *)(v55 + 224 * (a4 + 1) + 200) == -1.79769313e308)
    || *(double *)(v55 + 224 * (a4 + 1) + 48) != *(double *)&v121)
  {
    CFStringFromFragments = _CreateCFStringFromFragments(*(const char **)(a1 + 80), (_BYTE *)&v130 + 8, a2, a3, v24);
    v60 = *__error();
    v61 = _SILogForLogForCategory(1);
    v62 = 2 * (dword_1EF19FC90 < 4);
    if (os_log_type_enabled(v61, v62))
    {
      v63 = *(_QWORD *)(a1 + 80);
      *(_DWORD *)buf = 138413570;
      *(_QWORD *)&buf[4] = CFStringFromFragments;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = DWORD1(v130);
      *(_WORD *)&buf[18] = 2080;
      *(_QWORD *)&buf[20] = v63;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = BYTE8(v130);
      *(_WORD *)&buf[34] = 1024;
      *(_DWORD *)&buf[36] = DWORD2(v127);
      *(_WORD *)&buf[40] = 2048;
      *(_QWORD *)&buf[42] = *((_QWORD *)&v129 + 1);
      _os_log_impl(&dword_1B8270000, v61, v62, "Creating suggestion string %@, type %d, with completion %s length:%d weight:%d score:%g", buf, 0x32u);
    }
    *__error() = v60;
    if (CFStringFromFragments)
    {
      *(_QWORD *)&v127 = CFStringFromFragments;
      v64 = *(void ***)(a1 + 72);
      v114 = v128[0];
      v115 = v128[1];
      v116 = v129;
      v117 = v130;
      v110 = v124;
      v111 = v125;
      v106 = v120;
      v107 = v121;
      v108 = v122;
      v109 = v123;
      v104 = v118;
      v105 = v119;
      v65 = (uint64_t)v64[1];
      v66 = (unint64_t)v64[2];
      v67 = v66;
      v112 = v126;
      v113 = v127;
      if ((uint64_t)(v66 + 2) >= v65)
      {
        v68 = 2 * v65;
        if (v65 < 4)
          v68 = 4;
        v64[1] = (void *)v68;
        v69 = 224 * v68 + 448;
        if (*v64)
          v70 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, *v64, v69, 0xECA6AA46uLL);
        else
          v70 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v69, 0x8DDAA030uLL);
        v71 = v70;
        if (!v70)
          _log_fault_for_malloc_failure();
        *v64 = v71;
        v71[12] = 0u;
        v71[13] = 0u;
        v71[10] = 0u;
        v71[11] = 0u;
        v71[8] = 0u;
        v71[9] = 0u;
        v71[6] = 0u;
        v71[7] = 0u;
        v71[4] = 0u;
        v71[5] = 0u;
        v71[2] = 0u;
        v71[3] = 0u;
        *v71 = 0u;
        v71[1] = 0u;
        v67 = (unint64_t)v64[2];
      }
      v64[2] = (void *)(v67 + 1);
      v72 = (char *)*v64 + 224 * v66;
      *((_OWORD *)v72 + 10) = v114;
      *((_OWORD *)v72 + 11) = v115;
      *((_OWORD *)v72 + 12) = v116;
      *((_OWORD *)v72 + 13) = v117;
      *((__n128 *)v72 + 6) = v110;
      *((__n128 *)v72 + 7) = v111;
      *((__n128 *)v72 + 8) = v112;
      *((_OWORD *)v72 + 9) = v113;
      *((_OWORD *)v72 + 2) = v106;
      *((_OWORD *)v72 + 3) = v107;
      *((__n128 *)v72 + 4) = v108;
      *((__n128 *)v72 + 5) = v109;
      *(_OWORD *)v72 = v104;
      *((_OWORD *)v72 + 1) = v105;
      if ((uint64_t)v66 >= 2)
      {
        do
        {
          v73 = (char *)*v64;
          v74 = v66 >> 1;
          if (*((double *)*v64 + 28 * v66 + 25) > *((double *)*v64 + 28 * (v66 >> 1) + 25))
            break;
          v75 = &v73[224 * v66];
          v137 = *((_OWORD *)v75 + 10);
          v138 = *((_OWORD *)v75 + 11);
          v139 = *((_OWORD *)v75 + 12);
          v140 = *((_OWORD *)v75 + 13);
          v133 = *((_OWORD *)v75 + 6);
          v134 = *((_OWORD *)v75 + 7);
          v135 = *((_OWORD *)v75 + 8);
          v136 = *((_OWORD *)v75 + 9);
          *(_OWORD *)&buf[32] = *((_OWORD *)v75 + 2);
          *(_OWORD *)&buf[48] = *((_OWORD *)v75 + 3);
          *(_OWORD *)&buf[64] = *((_OWORD *)v75 + 4);
          v132 = *((_OWORD *)v75 + 5);
          *(_OWORD *)buf = *(_OWORD *)v75;
          *(_OWORD *)&buf[16] = *((_OWORD *)v75 + 1);
          v76 = &v73[224 * v74];
          v77 = *((_OWORD *)v76 + 1);
          *(_OWORD *)v75 = *(_OWORD *)v76;
          *((_OWORD *)v75 + 1) = v77;
          v78 = *((_OWORD *)v76 + 2);
          v79 = *((_OWORD *)v76 + 3);
          v80 = *((_OWORD *)v76 + 5);
          *((_OWORD *)v75 + 4) = *((_OWORD *)v76 + 4);
          *((_OWORD *)v75 + 5) = v80;
          *((_OWORD *)v75 + 2) = v78;
          *((_OWORD *)v75 + 3) = v79;
          v81 = *((_OWORD *)v76 + 6);
          v82 = *((_OWORD *)v76 + 7);
          v83 = *((_OWORD *)v76 + 9);
          *((_OWORD *)v75 + 8) = *((_OWORD *)v76 + 8);
          *((_OWORD *)v75 + 9) = v83;
          *((_OWORD *)v75 + 6) = v81;
          *((_OWORD *)v75 + 7) = v82;
          v84 = *((_OWORD *)v76 + 10);
          v85 = *((_OWORD *)v76 + 11);
          v86 = *((_OWORD *)v76 + 13);
          *((_OWORD *)v75 + 12) = *((_OWORD *)v76 + 12);
          *((_OWORD *)v75 + 13) = v86;
          *((_OWORD *)v75 + 10) = v84;
          *((_OWORD *)v75 + 11) = v85;
          v87 = (char *)*v64 + 224 * v74;
          *((_OWORD *)v87 + 10) = v137;
          *((_OWORD *)v87 + 11) = v138;
          *((_OWORD *)v87 + 12) = v139;
          *((_OWORD *)v87 + 13) = v140;
          *((_OWORD *)v87 + 6) = v133;
          *((_OWORD *)v87 + 7) = v134;
          *((_OWORD *)v87 + 8) = v135;
          *((_OWORD *)v87 + 9) = v136;
          *((_OWORD *)v87 + 2) = *(_OWORD *)&buf[32];
          *((_OWORD *)v87 + 3) = *(_OWORD *)&buf[48];
          *((_OWORD *)v87 + 4) = *(_OWORD *)&buf[64];
          *((_OWORD *)v87 + 5) = v132;
          *(_OWORD *)v87 = *(_OWORD *)buf;
          *((_OWORD *)v87 + 1) = *(_OWORD *)&buf[16];
          v88 = v66 > 3;
          v66 >>= 1;
        }
        while (v88);
      }
    }
  }
  else
  {
    v56 = *__error();
    v57 = _SILogForLogForCategory(1);
    v58 = 2 * (dword_1EF19FC90 < 4);
    if (os_log_type_enabled(v57, v58))
    {
      *(_DWORD *)buf = 134218240;
      *(double *)&buf[4] = a11;
      *(_WORD *)&buf[12] = 2048;
      *(_QWORD *)&buf[14] = *((_QWORD *)&v129 + 1);
      _os_log_impl(&dword_1B8270000, v57, v58, "Dropping dangling parent (%g) %g", buf, 0x16u);
    }
    *__error() = v56;
  }
}

BOOL contains_similar_string(const __CFString *a1, CFSetRef theSet, const char *a3)
{
  CFIndex Count;
  uint64_t v6;
  CFIndex Length;
  CFIndex MaximumSizeForEncoding;
  uint64_t v9;
  UInt8 *v10;
  uint64_t v11;
  size_t v12;
  char *v13;
  uint64_t v14;
  BOOL v15;
  const __CFString *v16;
  CFIndex v17;
  unint64_t v18;
  CFIndex v19;
  uint64_t v20;
  UInt8 *v21;
  int v22;
  NSObject *v23;
  os_log_type_t v24;
  uint64_t v26;
  CFIndex v27;
  CFIndex v28[2];
  _QWORD buf[4];
  CFRange v30;
  CFRange v31;

  buf[3] = *MEMORY[0x1E0C80C00];
  if (!theSet || (Count = CFSetGetCount(theSet)) == 0)
    return 0;
  v6 = Count;
  Length = CFStringGetLength(a1);
  v28[0] = Length;
  MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
  v26 = (uint64_t)&v26;
  MEMORY[0x1E0C80A78](MaximumSizeForEncoding);
  v10 = (UInt8 *)&v26 - v9;
  bzero((char *)&v26 - v9, MaximumSizeForEncoding);
  v30.location = 0;
  v30.length = Length;
  CFStringGetBytes(a1, v30, 0x8000100u, 0x2Du, 0, v10, MaximumSizeForEncoding, v28);
  v10[v28[0]] = 0;
  v11 = icu_search_context_create();
  MEMORY[0x1E0C80A78](v11);
  v13 = (char *)&v26 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v13, v12);
  CFSetGetValues(theSet, (const void **)v13);
  if (v6 < 1)
  {
    v15 = 0;
    goto LABEL_19;
  }
  v14 = 0;
  v15 = 1;
  while (1)
  {
    v16 = *(const __CFString **)&v13[8 * v14];
    v27 = 0;
    v17 = CFStringGetLength(v16);
    v27 = v17;
    v18 = v17 - v28[0];
    if (v17 - v28[0] < 0)
      v18 = v28[0] - v17;
    if (v18 > 3)
      goto LABEL_12;
    if (v17 != v28[0])
      break;
    if (CFStringCompare(v16, a1, 0))
    {
      v17 = v27;
      break;
    }
LABEL_12:
    v15 = ++v14 < v6;
    if (v6 == v14)
      goto LABEL_19;
  }
  v19 = CFStringGetMaximumSizeForEncoding(v17, 0x8000100u);
  MEMORY[0x1E0C80A78](v19);
  v21 = (UInt8 *)&v26 - v20;
  bzero((char *)&v26 - v20, v19);
  v31.length = v27;
  v31.location = 0;
  CFStringGetBytes(v16, v31, 0x8000100u, 0x2Du, 0, v21, v19, &v27);
  v21[v27] = 0;
  v28[1] = 0;
  buf[0] = 0;
  if (!icu_search_match())
    goto LABEL_12;
  v22 = *__error();
  v23 = _SILogForLogForCategory(1);
  v24 = 2 * (dword_1EF19FC90 < 4);
  if (os_log_type_enabled(v23, v24))
  {
    LODWORD(buf[0]) = 134217984;
    *(_QWORD *)((char *)buf + 4) = v27;
    _os_log_impl(&dword_1B8270000, v23, v24, "Dropping similar completion of length %ld", (uint8_t *)buf, 0xCu);
  }
  *__error() = v22;
LABEL_19:
  icu_ctx_release();
  return v15;
}

void update_item_bundle_ids(uint64_t a1, uint64_t a2, __n128 a3)
{
  int v3;
  __n128 *v4;
  char *v5;
  __n128 *v6;
  char *v7;
  unsigned __int32 v8;
  unint64_t v9;
  unint64_t v10;
  char *v11;
  char *v12;
  __n128 *v13;
  __int32 v14;
  __n128 v15;
  __n128 v16;
  unint64_t v17;
  uint64_t v18;
  _DWORD *v19;
  uint64_t v20;
  uint64_t v21;
  __n128 *v22;
  BOOL v23;
  int v24;
  __n128 v26;
  __n128 v27;
  __n128 v28;
  __n128 v29;
  __n128 v30;

  if (a2)
  {
    v3 = *(_DWORD *)(a2 + 24);
    if (v3 >= 3)
      v3 = 3;
    v24 = v3;
    *(_DWORD *)(a1 + 164) = v3;
    v4 = *(__n128 **)(a2 + 16);
    if (v4)
    {
      v5 = 0;
      v6 = 0;
      v7 = 0;
      do
      {
        v8 = v4[1].n128_u32[0];
        v28 = v4[4];
        v29 = v4[5];
        v30 = v4[6];
        v26 = v4[2];
        v27 = v4[3];
        if (v6 >= (__n128 *)v7)
        {
          v9 = 0xAAAAAAAAAAAAAAABLL * (((char *)v6 - v5) >> 5) + 1;
          if (v9 > 0x2AAAAAAAAAAAAAALL)
            abort();
          if (0x5555555555555556 * ((v7 - v5) >> 5) > v9)
            v9 = 0x5555555555555556 * ((v7 - v5) >> 5);
          if (0xAAAAAAAAAAAAAAABLL * ((v7 - v5) >> 5) >= 0x155555555555555)
            v10 = 0x2AAAAAAAAAAAAAALL;
          else
            v10 = v9;
          if (v10)
          {
            if (v10 > 0x2AAAAAAAAAAAAAALL)
              std::__throw_bad_array_new_length[abi:nn180100]();
            v11 = (char *)operator new(96 * v10);
          }
          else
          {
            v11 = 0;
          }
          v12 = &v11[32 * (((char *)v6 - v5) >> 5)];
          *(_DWORD *)v12 = v8;
          *((__n128 *)v12 + 3) = v28;
          *((__n128 *)v12 + 4) = v29;
          *((__n128 *)v12 + 5) = v30;
          a3 = v27;
          *((__n128 *)v12 + 1) = v26;
          *((__n128 *)v12 + 2) = v27;
          v13 = (__n128 *)v12;
          while (v6 != (__n128 *)v5)
          {
            v14 = v6[-6].n128_i32[0];
            v6 -= 6;
            v13[-6].n128_u32[0] = v14;
            v13 -= 6;
            v13[1] = v6[1];
            a3 = v6[2];
            v15 = v6[3];
            v16 = v6[5];
            v13[4] = v6[4];
            v13[5] = v16;
            v13[2] = a3;
            v13[3] = v15;
          }
          v7 = &v11[96 * v10];
          v6 = (__n128 *)(v12 + 96);
          if (v5)
            operator delete(v5);
          v5 = (char *)v13;
        }
        else
        {
          v6->n128_u32[0] = v8;
          v6[1] = v26;
          a3 = v27;
          v6[4] = v29;
          v6[5] = v30;
          v6[2] = v27;
          v6[3] = v28;
          v6 += 6;
        }
        v4 = (__n128 *)v4->n128_u64[0];
      }
      while (v4);
    }
    else
    {
      v6 = 0;
      v5 = 0;
    }
    v17 = 126 - 2 * __clz(0xAAAAAAAAAAAAAAABLL * (((char *)v6 - v5) >> 5));
    if (v6 == (__n128 *)v5)
      v18 = 0;
    else
      v18 = v17;
    std::__introsort<std::_ClassicAlgPolicy,SIWordTrieFragmentGetBundleIDs::$_0 &,std::pair<unsigned int,ci_rankingbits_wrapped_s> *,false>((int *)v5, (int *)v6, v18, 1, a3);
    if (v6 != (__n128 *)v5)
    {
      v19 = (_DWORD *)(a1 + 168);
      if (v24 <= 1)
        v20 = 1;
      else
        v20 = v24;
      v21 = v20 - 1;
      v22 = (__n128 *)(v5 + 96);
      do
      {
        *v19++ = v22[-6].n128_u32[0];
        if (!v21)
          break;
        --v21;
        v23 = v22 == v6;
        v22 += 6;
      }
      while (!v23);
    }
    if (v5)
      operator delete(v5);
  }
}

__CFString *_CreateCFStringFromFragments(const char *a1, _BYTE *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unsigned int v9;
  __CFString *Mutable;
  __CFString *v11;
  char v12;
  CFIndex *v13;

  if (a2)
    v9 = *a2;
  else
    v9 = 0;
  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a5 + v9 + 1);
  v11 = Mutable;
  if (v9)
  {
    v12 = a1[v9];
    a1[v9] = 0;
    CFStringAppendCString(Mutable, a1, 0x8000100u);
    a1[v9] = v12;
    *a2 = CFStringGetLength(v11);
  }
  if (a4)
  {
    v13 = (CFIndex *)(a3 + 8);
    do
    {
      CFStringAppendCharacters(v11, (const UniChar *)*(v13 - 1), *v13);
      v13 += 2;
      --a4;
    }
    while (a4);
  }
  return v11;
}

double _hasPunctuation(SIModelManager *IsCharacterMember, unint64_t a2, uint64_t a3, int a4)
{
  double v4;
  SIModelManager *v8;
  int v9;
  uint64_t v10;
  SIModelManager *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  const __CFCharacterSet *v15;
  BOOL v16;
  unsigned __int16 *v17;
  char v18;
  char v19;
  unsigned __int16 *v20;
  BOOL v21;
  int v22;
  uint64_t i;
  uint64_t v24;
  char v25;
  char v26;
  const __CFCharacterSet *v27;
  double v28;
  UniChar *v29;
  unsigned __int16 *v30;
  UniChar v31;
  char *v32;
  const char *v33;

  v4 = 0.0;
  if (!a2)
    return v4;
  v8 = IsCharacterMember;
  if (_hasPunctuation(SIWordTrieFragment *,unsigned long,cachedInfo *,BOOL)::onceToken != -1)
    dispatch_once(&_hasPunctuation(SIWordTrieFragment *,unsigned long,cachedInfo *,BOOL)::onceToken, &__block_literal_global_16);
  v9 = *(_DWORD *)(a3 + 24);
  if (v9 < 0)
    return v4;
  if (*(_QWORD *)(a3 + 16) == a2)
  {
    if (!v9)
      return *(double *)a3;
    return v4;
  }
  *(_QWORD *)(a3 + 16) = a2;
  if (*(_BYTE *)(a3 + 30))
  {
LABEL_9:
    *(_BYTE *)(a3 + 30) = 1;
    *(_QWORD *)a3 = 0;
    return v4;
  }
  v10 = (uint64_t)v8 + 16 * a2;
  v11 = *(SIModelManager **)(v10 - 16);
  v13 = *(_QWORD *)(v10 - 8);
  v12 = v10 - 16;
  if (!v13)
  {
    v17 = 0;
    v18 = *(_BYTE *)(a3 + 29) != 0;
    v19 = *(_BYTE *)(a3 + 28) != 0;
    goto LABEL_40;
  }
  v14 = 0;
  v15 = (const __CFCharacterSet *)_hasPunctuation(SIWordTrieFragment *,unsigned long,cachedInfo *,BOOL)::newLineAndTabs;
  v16 = 1;
  do
  {
    IsCharacterMember = (SIModelManager *)CFCharacterSetIsCharacterMember(v15, *((_WORD *)v11 + v14));
    if ((_DWORD)IsCharacterMember)
      break;
    v16 = ++v14 < v13;
  }
  while (v13 != v14);
  if (v16)
    goto LABEL_9;
  v11 = *(SIModelManager **)v12;
  v17 = *(unsigned __int16 **)(v12 + 8);
  v9 = *(_DWORD *)(a3 + 24);
  if (v9 < 0)
  {
    v26 = 0;
    goto LABEL_43;
  }
  v18 = *(_BYTE *)(a3 + 29) != 0;
  v19 = *(_BYTE *)(a3 + 28) != 0;
  if (!v17)
  {
LABEL_40:
    *(_BYTE *)(a3 + 29) = v18 & 1;
    *(_BYTE *)(a3 + 28) = v19 & 1;
    *(_DWORD *)(a3 + 24) = v9;
    v25 = (v18 | v19) ^ 1;
    if (v9)
      v26 = 0;
    else
      v26 = v25;
    goto LABEL_43;
  }
  v20 = 0;
  while (1)
  {
    v21 = v20 == (unsigned __int16 *)((char *)v17 - 1) || v20 == 0;
    v22 = *((unsigned __int16 *)v11 + (_QWORD)v20);
    if (!v21 || v22 != 39)
      break;
    v18 ^= 1u;
LABEL_37:
    v20 = (unsigned __int16 *)((char *)v20 + 1);
    if (v20 == v17)
      goto LABEL_40;
  }
  if (v22 == 34)
  {
    v19 ^= 1u;
    goto LABEL_37;
  }
  for (i = 0; i != 11; ++i)
  {
    if ((unsigned __int16)asc_1B8630570[i] == v22)
    {
      *(_WORD *)(*(_QWORD *)(a3 + 32) + 2 * v9++) = word_1B8630586[i];
      goto LABEL_37;
    }
  }
  if (v9 && *(unsigned __int16 *)(*(_QWORD *)(a3 + 32) + 2 * (v9 - 1)) == v22)
  {
    --v9;
    goto LABEL_37;
  }
  v24 = 0;
  while ((unsigned __int16)word_1B8630586[v24] != v22)
  {
    if (++v24 == 11)
      goto LABEL_37;
  }
  v26 = 0;
  *(_BYTE *)(a3 + 29) = v18 & 1;
  *(_BYTE *)(a3 + 28) = v19 & 1;
  *(_DWORD *)(a3 + 24) = -1;
LABEL_43:
  v4 = *(double *)a3;
  if (v17)
  {
    v27 = (const __CFCharacterSet *)_hasPunctuation(SIWordTrieFragment *,unsigned long,cachedInfo *,BOOL)::characterSet;
    v28 = 1.0;
    v29 = (UniChar *)v11;
    v30 = v17;
    do
    {
      v31 = *v29++;
      if (CFCharacterSetIsCharacterMember(v27, v31))
        v28 = v28 * 0.1;
      v30 = (unsigned __int16 *)((char *)v30 - 1);
    }
    while (v30);
    v4 = v4 * v28;
    IsCharacterMember = (SIModelManager *)CFCharacterSetIsCharacterMember((CFCharacterSetRef)_hasPunctuation(SIWordTrieFragment *,unsigned long,cachedInfo *,BOOL)::whiteSpaceAndPunctuation, *((_WORD *)v11 + (_QWORD)v17 - 1));
    if ((_DWORD)IsCharacterMember)
      v4 = v4 * 0.01;
  }
  if (a2 >= 2)
    *(double *)a3 = v4;
  if (a4)
  {
    v32 = *(char **)(a3 + 48);
    SIModelManager::getInstance(IsCharacterMember);
    if (SIModelManager::isStopword(v11, v17, v32, v33))
      v4 = v4 * 0.01;
  }
  if (a2 <= 1)
    *(double *)a3 = v4;
  if ((v26 & 1) == 0)
    return 0.0;
  return v4;
}

__CFString *_CreateCFStringFromCrossFieldFragments(char a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __CFString *Mutable;
  CFCharacterSetRef Predefined;
  const __CFCharacterSet *v9;
  uint64_t v10;
  char v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;

  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a4 + 1);
  Predefined = CFCharacterSetGetPredefined(kCFCharacterSetWhitespace);
  if (a3)
  {
    v9 = Predefined;
    v10 = 0;
    v11 = 1;
    do
    {
      if (a1)
      {
        a1 -= *(_BYTE *)(a2 + 16 * v10 + 8);
      }
      else
      {
        if ((v11 & 1) != 0 && (v12 = a2 + 16 * v10, v14 = *(_QWORD *)(v12 + 8), v13 = (_QWORD *)(v12 + 8), v14))
        {
          v15 = 0;
          do
          {
            if (!CFCharacterSetIsCharacterMember(v9, *(_WORD *)(*(_QWORD *)(a2 + 16 * v10) + 2 * v15)))
              break;
            ++v15;
          }
          while (v15 != *v13);
        }
        else
        {
          v15 = 0;
        }
        CFStringAppendCharacters(Mutable, (const UniChar *)(*(_QWORD *)(a2 + 16 * v10) + 2 * v15), *(_QWORD *)(a2 + 16 * v10 + 8) - v15);
        a1 = 0;
        v11 = 0;
      }
      ++v10;
    }
    while (v10 != a3);
  }
  return Mutable;
}

__n128 pqpush_CompletionItem_s(void **a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  size_t v8;
  _OWORD *v9;
  _OWORD *v10;
  uint64_t v11;
  __n128 result;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  char *v22;
  unint64_t v23;
  __n128 *v24;
  __n128 *v25;
  __n128 v26;
  __n128 v27;
  __n128 v28;
  __n128 v29;
  __n128 v30;
  __n128 v31;
  __n128 v32;
  __n128 v33;
  __n128 v34;
  __n128 v35;
  __n128 *v36;
  BOOL v37;
  __n128 v38;
  __n128 v39;
  __n128 v40;
  __n128 v41;
  __n128 v42;
  __n128 v43;
  __n128 v44;
  __n128 v45;
  __n128 v46;
  __n128 v47;
  __n128 v48;
  __n128 v49;
  __n128 v50;
  __n128 v51;

  v4 = (uint64_t)a1[1];
  v5 = (unint64_t)a1[2];
  v6 = v5;
  if ((uint64_t)(v5 + 2) >= v4)
  {
    v7 = 2 * v4;
    if (v4 < 4)
      v7 = 4;
    a1[1] = (void *)v7;
    v8 = 224 * v7 + 448;
    if (*a1)
      v9 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, *a1, v8, 0xECA6AA46uLL);
    else
      v9 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v8, 0x8DDAA030uLL);
    v10 = v9;
    if (!v9)
      _log_fault_for_malloc_failure();
    *a1 = v10;
    v10[12] = 0u;
    v10[13] = 0u;
    v10[10] = 0u;
    v10[11] = 0u;
    v10[8] = 0u;
    v10[9] = 0u;
    v10[6] = 0u;
    v10[7] = 0u;
    v10[4] = 0u;
    v10[5] = 0u;
    v10[2] = 0u;
    v10[3] = 0u;
    *v10 = 0u;
    v10[1] = 0u;
    v6 = (unint64_t)a1[2];
  }
  a1[2] = (void *)(v6 + 1);
  v11 = (uint64_t)*a1 + 224 * v5;
  result = *(__n128 *)(a2 + 16);
  *(_OWORD *)v11 = *(_OWORD *)a2;
  v13 = *(_OWORD *)(a2 + 32);
  v14 = *(_OWORD *)(a2 + 48);
  v15 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(v11 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(v11 + 80) = v15;
  *(_OWORD *)(v11 + 32) = v13;
  *(_OWORD *)(v11 + 48) = v14;
  v16 = *(_OWORD *)(a2 + 96);
  v17 = *(_OWORD *)(a2 + 112);
  v18 = *(_OWORD *)(a2 + 144);
  *(_OWORD *)(v11 + 128) = *(_OWORD *)(a2 + 128);
  *(_OWORD *)(v11 + 144) = v18;
  *(_OWORD *)(v11 + 96) = v16;
  *(_OWORD *)(v11 + 112) = v17;
  v19 = *(_OWORD *)(a2 + 160);
  v20 = *(_OWORD *)(a2 + 176);
  v21 = *(_OWORD *)(a2 + 208);
  *(_OWORD *)(v11 + 192) = *(_OWORD *)(a2 + 192);
  *(_OWORD *)(v11 + 208) = v21;
  *(_OWORD *)(v11 + 160) = v19;
  *(_OWORD *)(v11 + 176) = v20;
  *(__n128 *)(v11 + 16) = result;
  if ((uint64_t)v5 >= 2)
  {
    do
    {
      v22 = (char *)*a1;
      result.n128_u64[0] = *((_QWORD *)*a1 + 28 * v5 + 25);
      v23 = v5 >> 1;
      if (result.n128_f64[0] > *((double *)*a1 + 28 * (v5 >> 1) + 25))
        break;
      v24 = (__n128 *)&v22[224 * v5];
      v48 = v24[10];
      v49 = v24[11];
      v50 = v24[12];
      v51 = v24[13];
      v44 = v24[6];
      v45 = v24[7];
      v46 = v24[8];
      v47 = v24[9];
      v40 = v24[2];
      v41 = v24[3];
      v42 = v24[4];
      v43 = v24[5];
      v38 = *v24;
      v39 = v24[1];
      v25 = (__n128 *)&v22[224 * v23];
      v26 = v25[1];
      *v24 = *v25;
      v24[1] = v26;
      v27 = v25[2];
      v28 = v25[3];
      v29 = v25[5];
      v24[4] = v25[4];
      v24[5] = v29;
      v24[2] = v27;
      v24[3] = v28;
      v30 = v25[6];
      v31 = v25[7];
      v32 = v25[9];
      v24[8] = v25[8];
      v24[9] = v32;
      v24[6] = v30;
      v24[7] = v31;
      v33 = v25[10];
      v34 = v25[11];
      v35 = v25[13];
      v24[12] = v25[12];
      v24[13] = v35;
      v24[10] = v33;
      v24[11] = v34;
      v36 = (__n128 *)((char *)*a1 + 224 * v23);
      v36[10] = v48;
      v36[11] = v49;
      v36[12] = v50;
      v36[13] = v51;
      v36[6] = v44;
      v36[7] = v45;
      v36[8] = v46;
      v36[9] = v47;
      v36[2] = v40;
      v36[3] = v41;
      v36[4] = v42;
      v36[5] = v43;
      result = v38;
      *v36 = v38;
      v36[1] = v39;
      v37 = v5 > 3;
      v5 >>= 1;
    }
    while (v37);
  }
  return result;
}

void ___ZL15_hasPunctuationP18SIWordTrieFragmentmP10cachedInfob_block_invoke()
{
  const __CFCharacterSet *Predefined;
  const __CFCharacterSet *v1;
  const __CFAllocator *v2;
  __CFCharacterSet *MutableCopy;
  const __CFCharacterSet *v4;
  const __CFCharacterSet *v5;
  __CFCharacterSet *v6;
  const __CFCharacterSet *v7;
  const __CFCharacterSet *v8;
  __CFCharacterSet *v9;
  const __CFCharacterSet *v10;

  Predefined = CFCharacterSetGetPredefined(kCFCharacterSetAlphaNumeric);
  v1 = CFCharacterSetGetPredefined(kCFCharacterSetWhitespace);
  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  _hasPunctuation(SIWordTrieFragment *,unsigned long,cachedInfo *,BOOL)::openParen = (uint64_t)CFCharacterSetCreateWithCharactersInString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], CFSTR("[(<\"“‘"));
  _hasPunctuation(SIWordTrieFragment *,unsigned long,cachedInfo *,BOOL)::closeParen = (uint64_t)CFCharacterSetCreateWithCharactersInString(v2, CFSTR("])>\"”’"));
  MutableCopy = CFCharacterSetCreateMutableCopy(v2, Predefined);
  CFCharacterSetUnion(MutableCopy, v1);
  CFCharacterSetInvert(MutableCopy);
  CFCharacterSetUnion(MutableCopy, (CFCharacterSetRef)_hasPunctuation(SIWordTrieFragment *,unsigned long,cachedInfo *,BOOL)::openParen);
  CFCharacterSetUnion(MutableCopy, (CFCharacterSetRef)_hasPunctuation(SIWordTrieFragment *,unsigned long,cachedInfo *,BOOL)::closeParen);
  _hasPunctuation(SIWordTrieFragment *,unsigned long,cachedInfo *,BOOL)::characterSet = (uint64_t)CFCharacterSetCreateCopy(v2, MutableCopy);
  CFRelease(MutableCopy);
  v4 = CFCharacterSetCreateWithCharactersInString(v2, CFSTR("\t"));
  v5 = CFCharacterSetGetPredefined(kCFCharacterSetNewline);
  v6 = CFCharacterSetCreateMutableCopy(v2, v5);
  CFCharacterSetUnion(v6, v4);
  _hasPunctuation(SIWordTrieFragment *,unsigned long,cachedInfo *,BOOL)::newLineAndTabs = (uint64_t)CFCharacterSetCreateCopy(v2, v6);
  CFRelease(v4);
  CFRelease(v6);
  v7 = CFCharacterSetCreateWithCharactersInString(v2, CFSTR("-"));
  v8 = CFCharacterSetGetPredefined(kCFCharacterSetWhitespaceAndNewline);
  v9 = CFCharacterSetCreateMutableCopy(v2, v8);
  CFCharacterSetUnion(v9, v7);
  v10 = CFCharacterSetGetPredefined(kCFCharacterSetPunctuation);
  CFCharacterSetUnion(v9, v10);
  _hasPunctuation(SIWordTrieFragment *,unsigned long,cachedInfo *,BOOL)::whiteSpaceAndPunctuation = (uint64_t)v9;
  CFRelease(v7);
}

uint64_t `anonymous namespace'::stokencallback(_anonymous_namespace_ *this, const unsigned __int16 *a2, uint64_t a3, uint64_t *a4, void *a5)
{
  void *v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  size_t v12;
  void *v13;
  uint64_t v14;
  size_t v15;
  uint64_t v17;
  _BYTE __src[1024];
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v8 = (void *)a4[3];
  if (v8)
  {
    v9 = a4[1];
    if (v9 != *a4)
      goto LABEL_8;
    v10 = 2 * v9;
  }
  else
  {
    v10 = 4;
  }
  *a4 = v10;
  v11 = malloc_type_realloc(v8, 8 * v10, 0x50040EE9192B6uLL);
  v8 = v11;
  if (!a4[3])
    a4[1] = 0;
  a4[3] = (uint64_t)v11;
LABEL_8:
  bzero(__src, 0x400uLL);
  v17 = 0;
  if (!utf8_encodestr((unsigned __int16 *)this, 2 * (_QWORD)a2, __src, &v17, 1024))
  {
    v12 = v17 + 1;
    v13 = malloc_type_malloc(v17 + 1, 0x443BC30FuLL);
    memcpy(v13, __src, v12);
    v14 = a4[1];
    *((_QWORD *)v8 + v14) = v13;
    v15 = a4[2] + v12;
    a4[1] = v14 + 1;
    a4[2] = v15;
  }
  return 0;
}

uint64_t SISetCompletionRankingWeights(uint64_t result)
{
  const __CFArray *v1;
  __int128 *p_src;
  CFTypeID TypeID;
  CFIndex v4;
  const __CFArray *ValueAtIndex;
  uint64_t v6;
  int v7;
  NSObject *v8;
  CFTypeID v9;
  int v10;
  NSObject *v11;
  BOOL v12;
  const char *v13;
  NSObject *v14;
  os_log_type_t v15;
  int v16;
  NSObject *v17;
  os_log_type_t v18;
  CFTypeID v19;
  CFIndex v20;
  __int128 *i;
  const __CFArray *v22;
  NSObject *v23;
  BOOL v24;
  int v25;
  CFIndex v26;
  __int16 v27;
  const __CFArray *v28;
  __int128 __src;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  if (!result)
    return result;
  v1 = (const __CFArray *)result;
  result = CFArrayGetCount((CFArrayRef)result);
  if (result == 32)
  {
    v43 = 0u;
    v44 = 0u;
    v41 = 0u;
    v42 = 0u;
    v39 = 0u;
    v40 = 0u;
    v37 = 0u;
    v38 = 0u;
    v35 = 0u;
    v36 = 0u;
    v33 = 0u;
    v34 = 0u;
    v31 = 0u;
    v32 = 0u;
    __src = 0u;
    v30 = 0u;
    p_src = &__src;
    TypeID = CFNumberGetTypeID();
    v4 = 0;
    while (1)
    {
      ValueAtIndex = (const __CFArray *)CFArrayGetValueAtIndex(v1, v4);
      if (CFGetTypeID(ValueAtIndex) != TypeID)
      {
        v10 = *__error();
        v11 = _SILogForLogForCategory(1);
        v12 = dword_1EF19FC90 < 3;
        if (!os_log_type_enabled(v11, (os_log_type_t)(dword_1EF19FC90 < 3)))
          goto LABEL_34;
        v25 = 134218242;
        v26 = v4;
        v27 = 2112;
        v28 = ValueAtIndex;
        v13 = "*warn* Non-numeric in factor array at index %ld: %@";
        goto LABEL_19;
      }
      result = CFNumberGetValue(ValueAtIndex, kCFNumberDoubleType, p_src);
      if (!(_DWORD)result)
        break;
      ++v4;
      p_src = (__int128 *)((char *)p_src + 8);
      if (v4 == 32)
      {
        xmmword_1EDBBD538 = v41;
        *(_OWORD *)&qword_1EDBBD548 = v42;
        xmmword_1EDBBD558 = v43;
        unk_1EDBBD568 = v44;
        xmmword_1EDBBD4F8 = v37;
        *(_OWORD *)&qword_1EDBBD508 = v38;
        xmmword_1EDBBD518 = v39;
        *(_OWORD *)&qword_1EDBBD528 = v40;
        xmmword_1EDBBD4B8 = v33;
        *(_OWORD *)&qword_1EDBBD4C8 = v34;
        xmmword_1EDBBD4D8 = v35;
        *(_OWORD *)&qword_1EDBBD4E8 = v36;
        ranking_factor_weights = __src;
        *(_OWORD *)&qword_1EDBBD488 = v30;
        xmmword_1EDBBD498 = v31;
        unk_1EDBBD4A8 = v32;
        return result;
      }
    }
    v10 = *__error();
    v11 = _SILogForLogForCategory(1);
    v12 = dword_1EF19FC90 < 3;
    if (!os_log_type_enabled(v11, (os_log_type_t)(dword_1EF19FC90 < 3)))
      goto LABEL_34;
    v25 = 134218242;
    v26 = v4;
    v27 = 2112;
    v28 = ValueAtIndex;
    v13 = "*warn* Bad value in factor array at index %ld: %@";
LABEL_19:
    v14 = v11;
    v15 = v12;
  }
  else
  {
    v6 = result;
    *(_QWORD *)&v37 = 0;
    v35 = 0u;
    v36 = 0u;
    v33 = 0u;
    v34 = 0u;
    v31 = 0u;
    v32 = 0u;
    __src = 0u;
    v30 = 0u;
    if (result >= 18)
    {
      if (dword_1EF19FCC0 >= 5)
      {
        v7 = *__error();
        v8 = _SILogForLogForCategory(13);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          v25 = 134218242;
          v26 = v6;
          v27 = 2112;
          v28 = v1;
          _os_log_impl(&dword_1B8270000, v8, OS_LOG_TYPE_DEFAULT, "completion weight array too large (%ld): %@", (uint8_t *)&v25, 0x16u);
        }
        result = (uint64_t)__error();
        *(_DWORD *)result = v7;
      }
      return result;
    }
    if (result == 17)
    {
      v9 = CFNumberGetTypeID();
    }
    else
    {
      v16 = *__error();
      v17 = _SILogForLogForCategory(1);
      v18 = dword_1EF19FC90 < 3;
      if (os_log_type_enabled(v17, (os_log_type_t)(dword_1EF19FC90 < 3)))
      {
        v25 = 134218242;
        v26 = v6;
        v27 = 2112;
        v28 = v1;
        _os_log_impl(&dword_1B8270000, v17, v18, "*warn* completion weight array incomplete (%ld): %@", (uint8_t *)&v25, 0x16u);
      }
      *__error() = v16;
      v9 = CFNumberGetTypeID();
      if (v6 < 1)
        return (uint64_t)memcpy(&s_completion_weights, &__src, 8 * v6);
    }
    v19 = v9;
    v20 = 0;
    for (i = &__src; ; i = (__int128 *)((char *)i + 8))
    {
      v22 = (const __CFArray *)CFArrayGetValueAtIndex(v1, v20);
      if (CFGetTypeID(v22) != v19)
      {
        v10 = *__error();
        v23 = _SILogForLogForCategory(1);
        v24 = dword_1EF19FC90 < 3;
        if (!os_log_type_enabled(v23, (os_log_type_t)(dword_1EF19FC90 < 3)))
          goto LABEL_34;
        v25 = 134218242;
        v26 = v20;
        v27 = 2112;
        v28 = v22;
        v13 = "*warn* Non-numeric in weight array at index %ld: %@";
        goto LABEL_32;
      }
      if (!CFNumberGetValue(v22, kCFNumberDoubleType, i))
        break;
      if (v6 == ++v20)
        return (uint64_t)memcpy(&s_completion_weights, &__src, 8 * v6);
    }
    v10 = *__error();
    v23 = _SILogForLogForCategory(1);
    v24 = dword_1EF19FC90 < 3;
    if (!os_log_type_enabled(v23, (os_log_type_t)(dword_1EF19FC90 < 3)))
      goto LABEL_34;
    v25 = 134218242;
    v26 = v20;
    v27 = 2112;
    v28 = v22;
    v13 = "*warn* Bad value in weight array at index %ld: %@";
LABEL_32:
    v14 = v23;
    v15 = v24;
  }
  _os_log_impl(&dword_1B8270000, v14, v15, v13, (uint8_t *)&v25, 0x16u);
LABEL_34:
  result = (uint64_t)__error();
  *(_DWORD *)result = v10;
  return result;
}

uint64_t SIGetCompletionOptionsFromRankingWeights()
{
  unsigned int v0;

  if (unk_1EDBBD568 == 1.0)
    v0 = (2 * (*((double *)&xmmword_1EDBBD558 + 1) == 1.0)) | 4;
  else
    v0 = 2 * (*((double *)&xmmword_1EDBBD558 + 1) == 1.0);
  if (*(double *)&qword_1EDBBD570 == 1.0)
    return v0 | 8;
  else
    return v0;
}

uint64_t si_enqueue_barrier_routine(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t), uint64_t a4, unsigned int a5)
{
  pthread_mutex_t *v9;

  v9 = (pthread_mutex_t *)(a2 + 48);
  pthread_mutex_lock((pthread_mutex_t *)(a2 + 48));
  if (*(_DWORD *)(a2 + 36))
  {
    pthread_mutex_unlock(v9);
    return a3(a4, 1);
  }
  else
  {
    si_enqueue_barrier_for_job(*(_QWORD *)(a1 + 8 * a5 + 1008), (uint64_t)a3, a4, a2);
    return pthread_mutex_unlock(v9);
  }
}

uint64_t preadvall(uint64_t __fd, uint64_t a2, off_t a3)
{
  size_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  int v10;
  uint64_t v11;

  while (1)
  {
    v6 = *(_QWORD *)(a2 + 8);
    if (!v6)
      return 0;
    v7 = pread(__fd, *(void **)a2, v6, a3);
    if ((v7 & 0x8000000000000000) != 0)
      break;
    if (!v7)
      return 4294967274;
    v8 = *(_QWORD *)(a2 + 8);
    v9 = v7 - v8;
    if (v7 >= v8)
    {
      if (v7 == v8)
        return 0;
      v10 = 0;
      v8 = *(_QWORD *)(a2 + 24);
      a2 += 16;
    }
    else
    {
      v10 = 1;
      v9 = v7;
    }
    a3 += v7;
    *(_QWORD *)a2 += v9;
    *(_QWORD *)(a2 + 8) = v8 - v9;
LABEL_13:
    if (!v10)
      return 0;
  }
  v11 = *__error();
  if ((_DWORD)v11 == 4
    || g_prot_error_callback
    && ((*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(g_prot_error_callback + 16))(g_prot_error_callback, __fd, v11, 16) & 1) != 0)
  {
    v10 = 1;
    goto LABEL_13;
  }
  return -(int)v11;
}

uint64_t pwritevall(uint64_t __fd, _QWORD *a2, int a3, off_t a4)
{
  int v5;
  unint64_t v8;
  _QWORD *v9;
  unint64_t v10;
  BOOL v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;

  if (!a3)
    return 0;
  v5 = a3;
  while (1)
  {
    v8 = pwrite(__fd, (const void *)*a2, a2[1], a4);
    if ((v8 & 0x8000000000000000) == 0)
    {
      a4 += v8;
      v9 = &a2[2 * (v5 - 1) + 2];
      while (1)
      {
        v10 = a2[1];
        v11 = v8 >= v10;
        v12 = v8 - v10;
        if (!v11)
          break;
        a2 += 2;
        v8 = v12;
        if (!--v5)
        {
          if (!v12)
            goto LABEL_10;
          goto LABEL_9;
        }
      }
      v9 = a2;
      v12 = v8;
      if (v8)
      {
LABEL_9:
        v13 = *v9 + v12;
        v14 = v9[1] - v12;
        *v9 = v13;
        v9[1] = v14;
      }
LABEL_10:
      a2 = v9;
      goto LABEL_14;
    }
    v15 = *__error();
    if ((_DWORD)v15 != 4
      && (!g_prot_error_callback
       || ((*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(g_prot_error_callback + 16))(g_prot_error_callback, __fd, v15, 17) & 1) == 0))
    {
      return -(int)v15;
    }
LABEL_14:
    if (!v5)
      return 0;
  }
}

uint64_t writevall(uint64_t a1, iovec *a2, int a3)
{
  int v3;
  unint64_t v6;
  iovec *v7;
  size_t iov_len;
  BOOL v9;
  unint64_t v10;
  BOOL v11;
  uint64_t v12;
  char *v13;
  size_t v14;

  if (!a3)
    return 0;
  v3 = a3;
  do
  {
    while (1)
    {
      v6 = writev(a1, a2, v3);
      if ((v6 & 0x8000000000000000) != 0)
        break;
      v7 = &a2[(v3 - 1) + 1];
      while (1)
      {
        iov_len = a2->iov_len;
        v9 = v6 >= iov_len;
        v10 = v6 - iov_len;
        if (!v9)
          break;
        ++a2;
        v6 = v10;
        v11 = v3 == 1;
        v3 = 1;
        if (v11)
        {
          v3 = 0;
          if (!v10)
            goto LABEL_17;
          goto LABEL_16;
        }
      }
      v7 = a2;
      v10 = v6;
      if (!v6)
        goto LABEL_17;
LABEL_16:
      v13 = (char *)v7->iov_base + v10;
      v14 = v7->iov_len - v10;
      v7->iov_base = v13;
      v7->iov_len = v14;
LABEL_17:
      a2 = v7;
      if (!v3)
        return 0;
    }
    v12 = *__error();
  }
  while ((_DWORD)v12 == 4
       || g_prot_error_callback
       && ((*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(g_prot_error_callback + 16))(g_prot_error_callback, a1, v12, 18) & 1) != 0);
  return -(int)v12;
}

off_t get_file_size(int a1)
{
  stat v2;

  memset(&v2, 0, sizeof(v2));
  if (fstat(a1, &v2))
    return -(uint64_t)*__error();
  else
    return v2.st_size;
}

void SIModelManager::~SIModelManager(SIModelManager **this)
{
  SIModelManager **v2;
  SIModelManager *v3;
  uint64_t v4;
  SIModelManager *v5;
  SIModelManager **v6;
  BOOL v7;
  SIModelManager *v8;
  uint64_t v9;
  SIModelManager *v10;
  SIModelManager *v11;

  v2 = this + 1;
  v3 = *this;
  if (*this != (SIModelManager *)(this + 1))
  {
    do
    {
      v4 = *((_QWORD *)v3 + 7);
      if (v4)
        data_map_destroy(v4);
      v5 = (SIModelManager *)*((_QWORD *)v3 + 1);
      if (v5)
      {
        do
        {
          v6 = (SIModelManager **)v5;
          v5 = *(SIModelManager **)v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          v6 = (SIModelManager **)*((_QWORD *)v3 + 2);
          v7 = *v6 == v3;
          v3 = (SIModelManager *)v6;
        }
        while (!v7);
      }
      v3 = (SIModelManager *)v6;
    }
    while (v6 != v2);
  }
  v8 = this[3];
  if (v8 != (SIModelManager *)(this + 4))
  {
    do
    {
      v9 = *((_QWORD *)v8 + 7);
      if (v9)
        data_map_destroy(v9);
      v10 = (SIModelManager *)*((_QWORD *)v8 + 1);
      if (v10)
      {
        do
        {
          v11 = v10;
          v10 = *(SIModelManager **)v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          v11 = (SIModelManager *)*((_QWORD *)v8 + 2);
          v7 = *(_QWORD *)v11 == (_QWORD)v8;
          v8 = v11;
        }
        while (!v7);
      }
      v8 = v11;
    }
    while (v11 != (SIModelManager *)(this + 4));
  }
  std::__tree<std::string>::destroy((char *)this[4]);
  std::__tree<std::string>::destroy((char *)this[1]);
}

void SIModelManager::loadDictionaryForLanguage(SIModelManager *this, const char *a2)
{
  int v2;
  const __CFString *v4;
  const __CFString *v5;
  CFIndex Length;
  CFIndex MaximumSizeForEncoding;
  CFIndex v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t **v11;
  double v12;
  unint64_t extra_with_key;
  BOOL v14;
  BOOL v15;
  double v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  BOOL v22;
  BOOL v23;
  double v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  NSObject *v32;
  void *__p[2];
  uint64_t v34;
  __int128 v35;
  __int128 v36;
  uint64_t v37;
  _OWORD v38[4];
  char buffer[1032];
  uint64_t v40;

  v2 = (int)a2;
  v40 = *MEMORY[0x1E0C80C00];
  bzero(buffer, 0x400uLL);
  v4 = (const __CFString *)CFPreferencesCopyAppValue(CFSTR("RootDirectory"), CFSTR("com.apple.spotlight"));
  if (v4)
  {
    v5 = v4;
    Length = CFStringGetLength(v4);
    MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
    if (MaximumSizeForEncoding >= 1024)
      v8 = 1024;
    else
      v8 = MaximumSizeForEncoding;
    CFStringGetCString(v5, buffer, v8, 0x8000100u);
    CFRelease(v5);
  }
  else
  {
    if (dword_1EF19FC90 >= 5)
    {
      v31 = *__error();
      v32 = _SILogForLogForCategory(1);
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(__p[0]) = 0;
        _os_log_impl(&dword_1B8270000, v32, OS_LOG_TYPE_DEFAULT, "No RootDirectory set for Suggestions", (uint8_t *)__p, 2u);
      }
      *__error() = v31;
    }
    strcpy(buffer, "/var/mobile/Library/Caches/com.apple.parsecd");
  }
  memset(v38, 0, sizeof(v38));
  if (v2)
    strcpy((char *)v38, "spotlight_stopword");
  else
    strcpy((char *)v38, "spotlight_phrase_dictionary");
  __p[0] = (void *)open(buffer, 0);
  __p[1] = v38;
  v34 = 0xA00000004;
  v35 = 0u;
  v36 = 0u;
  v37 = 0;
  v9 = data_map32_init_with_ctx((uint64_t)__p);
  if (v9)
  {
    v10 = (uint64_t *)v9;
    if ((v2 & 1) != 0)
    {
      std::string::basic_string[abi:nn180100]<0>(__p, (char *)this);
      v11 = (uint64_t **)&SIModelManager::getInstance(void)::instance;
    }
    else
    {
      v12 = *(double *)&xmmword_1EF1AE270;
      LOBYTE(__p[0]) = 0;
      extra_with_key = data_map_get_extra_with_key(v9, (uint64_t)&kPhraseDefaultScore, 0x12uLL, __p);
      if ((_DWORD)extra_with_key)
        v14 = HIDWORD(extra_with_key) == 4;
      else
        v14 = 0;
      v15 = !v14 || LOBYTE(__p[0]) == 0;
      v16 = (double)extra_with_key;
      if (v15)
        v16 = v12;
      *(double *)&xmmword_1EF1AE270 = v16;
      LOBYTE(__p[0]) = 0;
      v17 = data_map_get_extra_with_key((uint64_t)v10, (uint64_t)&kPhraseStopwordScore, 0xCuLL, __p);
      if (LOBYTE(__p[0]) && (v17 & 0xFFFFFFFF00000000) == 0x400000000 && (_DWORD)v17)
        *((double *)&xmmword_1EF1AE270 + 1) = 1.0 / (double)v17;
      LOBYTE(__p[0]) = 0;
      v18 = data_map_get_extra_with_key((uint64_t)v10, (uint64_t)&kPhraseIncompleteScore, 0x18uLL, __p);
      if (LOBYTE(__p[0]) && (v18 & 0xFFFFFFFF00000000) == 0x400000000 && (_DWORD)v18)
        *(double *)&qword_1EF1AE280 = 1.0 / (double)v18;
      LOBYTE(__p[0]) = 0;
      v19 = data_map_get_extra_with_key((uint64_t)v10, (uint64_t)&kPhraseDiscountedScore, 0x14uLL, __p);
      if (LOBYTE(__p[0]) && (v19 & 0xFFFFFFFF00000000) == 0x400000000 && (_DWORD)v19)
        *(double *)&qword_1EF1AE288 = 1.0 / (double)v19;
      v20 = qword_1EF1AE290;
      LOBYTE(__p[0]) = 0;
      v21 = data_map_get_extra_with_key((uint64_t)v10, (uint64_t)&kTotal, 0xEuLL, __p);
      if ((_DWORD)v21)
        v22 = HIDWORD(v21) == 4;
      else
        v22 = 0;
      v23 = !v22 || LOBYTE(__p[0]) == 0;
      v24 = (double)v21;
      if (v23)
        v24 = *(double *)&v20;
      qword_1EF1AE290 = *(_QWORD *)&v24;
      LOBYTE(__p[0]) = 0;
      v25 = data_map_get_extra_with_key((uint64_t)v10, (uint64_t)&k1gramSize, 0xEuLL, __p);
      if (LOBYTE(__p[0]) && (v25 & 0xFFFFFFFF00000000) == 0x400000000 && (_DWORD)v25)
        *(double *)&xmmword_1EF1AE2A0 = 1.0 / (double)v25;
      LOBYTE(__p[0]) = 0;
      v26 = data_map_get_extra_with_key((uint64_t)v10, (uint64_t)&k2gramSize, 0xEuLL, __p);
      if (LOBYTE(__p[0]) && (v26 & 0xFFFFFFFF00000000) == 0x400000000 && (_DWORD)v26)
        *((double *)&xmmword_1EF1AE2A0 + 1) = 1.0 / (double)v26;
      LOBYTE(__p[0]) = 0;
      v27 = data_map_get_extra_with_key((uint64_t)v10, (uint64_t)&k3gramSize, 0xEuLL, __p);
      if (LOBYTE(__p[0]) && (v27 & 0xFFFFFFFF00000000) == 0x400000000 && (_DWORD)v27)
        *(double *)&qword_1EF1AE2B0 = 1.0 / (double)v27;
      LOBYTE(__p[0]) = 0;
      v28 = data_map_get_extra_with_key((uint64_t)v10, (uint64_t)&k4gramSize, 0xEuLL, __p);
      if (LOBYTE(__p[0]) && (v28 & 0xFFFFFFFF00000000) == 0x400000000 && (_DWORD)v28)
        *(double *)&qword_1EF1AE2B8 = 1.0 / (double)v28;
      LOBYTE(__p[0]) = 0;
      v29 = data_map_get_extra_with_key((uint64_t)v10, (uint64_t)&kNgramSize, 0xEuLL, __p);
      if (LOBYTE(__p[0]) && (v29 & 0xFFFFFFFF00000000) == 0x400000000 && (_DWORD)v29)
        *(double *)&qword_1EF1AE2C0 = 1.0 / (double)v29;
      LOBYTE(__p[0]) = 0;
      v30 = data_map_get_extra_with_key((uint64_t)v10, (uint64_t)&kNotUseLog, 0xCuLL, __p);
      if (LOBYTE(__p[0]) && (v30 & 0xFFFFFFFF00000000) == 0x400000000 && (_DWORD)v30)
        byte_1EF1AE298 = 0;
      std::string::basic_string[abi:nn180100]<0>(__p, (char *)this);
      v11 = (uint64_t **)&unk_1EF1AE258;
    }
    std::__tree<std::__value_type<std::string,data_map_s *>,std::__map_value_compare<std::string,std::__value_type<std::string,data_map_s *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,data_map_s *>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(v11, __p, (uint64_t)__p)[7] = v10;
    if (SHIBYTE(v34) < 0)
      operator delete(__p[0]);
  }
}

uint64_t **std::__tree<std::__value_type<std::string,data_map_s *>,std::__map_value_compare<std::string,std::__value_type<std::string,data_map_s *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,data_map_s *>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(uint64_t **a1, _QWORD *a2, uint64_t a3)
{
  uint64_t *v5;
  uint64_t **v6;
  _QWORD *v8;
  uint64_t **v9;
  uint64_t *v10;
  uint64_t *v11;
  uint64_t *v12;
  uint64_t *v13;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v6 = (uint64_t **)v5;
        v8 = v5 + 4;
        if (!std::less<std::string>::operator()[abi:nn180100](a2, v5 + 4))
          break;
        v5 = *v6;
        v9 = v6;
        if (!*v6)
          goto LABEL_9;
      }
      if (!std::less<std::string>::operator()[abi:nn180100](v8, a2))
        break;
      v9 = v6 + 1;
      v5 = v6[1];
      if (!v5)
        goto LABEL_9;
    }
  }
  else
  {
    v9 = a1 + 1;
LABEL_9:
    v10 = (uint64_t *)v6;
    v6 = (uint64_t **)operator new(0x40uLL);
    *((_OWORD *)v6 + 2) = *(_OWORD *)a3;
    v11 = *(uint64_t **)(a3 + 16);
    *(_QWORD *)a3 = 0;
    *(_QWORD *)(a3 + 8) = 0;
    *(_QWORD *)(a3 + 16) = 0;
    v6[6] = v11;
    v6[7] = 0;
    *v6 = 0;
    v6[1] = 0;
    v6[2] = v10;
    *v9 = (uint64_t *)v6;
    v12 = (uint64_t *)**a1;
    v13 = (uint64_t *)v6;
    if (v12)
    {
      *a1 = v12;
      v13 = *v9;
    }
    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(a1[1], v13);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v6;
}

BOOL SIModelManager::isStopword(SIModelManager *this, unsigned __int16 *a2, char *__s, const char *a4)
{
  uint64_t *v7;
  uint64_t *v8;
  unint64_t extra_with_key;
  BOOL v10;
  double v11;
  void *__p[2];
  char v15;

  if (!a2)
    return 0;
  std::string::basic_string[abi:nn180100]<0>(__p, __s);
  v7 = std::__tree<std::__value_type<std::string,data_map_s *>,std::__map_value_compare<std::string,std::__value_type<std::string,data_map_s *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,data_map_s *>>>::find<std::string>((uint64_t)&SIModelManager::getInstance(void)::instance, __p);
  if (v15 < 0)
    operator delete(__p[0]);
  if (v7 == &qword_1EF1AE248)
    SIModelManager::loadDictionaryForLanguage((SIModelManager *)__s, (const char *)1);
  std::string::basic_string[abi:nn180100]<0>(__p, __s);
  v8 = std::__tree<std::__value_type<std::string,data_map_s *>,std::__map_value_compare<std::string,std::__value_type<std::string,data_map_s *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,data_map_s *>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)&SIModelManager::getInstance(void)::instance, __p, (uint64_t)__p)[7];
  if (v15 < 0)
  {
    operator delete(__p[0]);
    if (v8)
      goto LABEL_8;
    return 0;
  }
  if (!v8)
    return 0;
LABEL_8:
  LOBYTE(__p[0]) = 0;
  extra_with_key = data_map_get_extra_with_key((uint64_t)v8, (uint64_t)this, 2 * (_QWORD)a2, __p);
  if ((_DWORD)extra_with_key)
    v10 = HIDWORD(extra_with_key) == 4;
  else
    v10 = 0;
  v11 = (double)extra_with_key;
  if (!v10 || LOBYTE(__p[0]) == 0)
    v11 = 0.0;
  return v11 == 1.0;
}

_QWORD *std::__tree<std::__value_type<std::string,data_map_s *>,std::__map_value_compare<std::string,std::__value_type<std::string,data_map_s *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,data_map_s *>>>::find<std::string>(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v5;
  _BOOL4 v6;
  _QWORD *v7;

  v2 = (_QWORD *)(a1 + 8);
  v3 = *(_QWORD **)(a1 + 8);
  if (!v3)
    return v2;
  v5 = (_QWORD *)(a1 + 8);
  do
  {
    v6 = std::less<std::string>::operator()[abi:nn180100](v3 + 4, a2);
    v7 = v3 + 1;
    if (!v6)
    {
      v7 = v3;
      v5 = v3;
    }
    v3 = (_QWORD *)*v7;
  }
  while (*v7);
  if (v5 == v2 || std::less<std::string>::operator()[abi:nn180100](a2, v5 + 4))
    return v2;
  return v5;
}

double SIModelManager::getScore(SIModelManager *this, long double a2)
{
  uint64_t *v3;
  double v4;
  int v5;
  double v6;

  v3 = (uint64_t *)&xmmword_1EF1AE2A0;
  if ((unint64_t)this - 1 < 2)
    goto LABEL_8;
  if ((unint64_t)this - 3 < 2)
  {
    v3 = (uint64_t *)&xmmword_1EF1AE2A0 + 1;
LABEL_8:
    v4 = *(double *)v3;
    goto LABEL_9;
  }
  if ((unint64_t)this - 5 < 2)
  {
    v3 = &qword_1EF1AE2B0;
    goto LABEL_8;
  }
  if ((unint64_t)this - 7 <= 1)
  {
    v3 = &qword_1EF1AE2B8;
    goto LABEL_8;
  }
  v4 = *(double *)&qword_1EF1AE2C0;
LABEL_9:
  v5 = byte_1EF1AE298;
  v6 = log(a2);
  if (!v5)
    v6 = a2;
  return v4 * v6;
}

void SIModelManager::getPhraseScore(uint64_t a1, char *__s, SIModelManager *a3, char *a4)
{
  uint64_t v8;
  _BOOL4 isStopword;
  uint64_t *v10;
  uint64_t **v11;
  uint64_t v12;
  int v13;
  int *v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  char *v18;
  size_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  __int16 *v24;
  char *v25;
  __int16 v26;
  size_t v27;
  double v28;
  double v29;
  unint64_t extra_with_key;
  BOOL v31;
  BOOL v32;
  double v33;
  void *v35[2];
  char v36;
  char v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  if ((unint64_t)a3 >= 2)
  {
    if (SIModelManager::isStopword(*(SIModelManager **)(a1 + 16 * (_QWORD)a3 - 16), *(unsigned __int16 **)(a1 + 16 * (_QWORD)a3 - 8), __s, a4))
    {
      v8 = qword_1EF1AE280;
LABEL_23:
      SIModelManager::getScore(a3, *(long double *)&v8);
      return;
    }
LABEL_21:
    if (*a4)
      goto LABEL_22;
    goto LABEL_6;
  }
  if (a3 != (SIModelManager *)1)
    goto LABEL_21;
  isStopword = SIModelManager::isStopword(*(SIModelManager **)a1, *(unsigned __int16 **)(a1 + 8), __s, a4);
  *a4 = isStopword;
  if (isStopword)
  {
LABEL_22:
    v8 = qword_1EF1AE288;
    goto LABEL_23;
  }
LABEL_6:
  std::string::basic_string[abi:nn180100]<0>(v35, __s);
  v10 = std::__tree<std::__value_type<std::string,data_map_s *>,std::__map_value_compare<std::string,std::__value_type<std::string,data_map_s *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,data_map_s *>>>::find<std::string>((uint64_t)&qword_1EF1AE258, v35);
  if (v36 < 0)
    operator delete(v35[0]);
  if (v10 == &qword_1EF1AE260)
    SIModelManager::loadDictionaryForLanguage((SIModelManager *)__s, 0);
  std::string::basic_string[abi:nn180100]<0>(v35, __s);
  v11 = std::__tree<std::__value_type<std::string,data_map_s *>,std::__map_value_compare<std::string,std::__value_type<std::string,data_map_s *>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,data_map_s *>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(&qword_1EF1AE258, v35, (uint64_t)v35);
  v12 = (uint64_t)v11[7];
  if (v36 < 0)
  {
    operator delete(v35[0]);
    if (v12)
      goto LABEL_12;
LABEL_25:
    SIModelManager::getScore(a3, *(double *)&qword_1EF1AE290 / *(double *)&xmmword_1EF1AE270);
    return;
  }
  if (!v12)
    goto LABEL_25;
LABEL_12:
  if ((int)a3 <= 0)
  {
    v27 = 0;
    v18 = &v37;
  }
  else
  {
    v13 = 0;
    v14 = (int *)(a1 + 8);
    v15 = a3;
    do
    {
      v16 = *v14;
      v14 += 4;
      v13 += v16;
      --v15;
    }
    while (v15);
    MEMORY[0x1E0C80A78](v11);
    v18 = (char *)&v35[-1] - v17;
    bzero((char *)&v35[-1] - v17, v19);
    v20 = 0;
    v21 = 0;
    do
    {
      v22 = *(_QWORD *)(a1 + 16 * v20 + 8);
      if ((int)v22 >= 1)
      {
        v23 = *(_QWORD *)(a1 + 16 * v20 + 8);
        v24 = *(__int16 **)(a1 + 16 * v20);
        v25 = &v18[2 * v21];
        do
        {
          v26 = *v24++;
          *(_WORD *)v25 = v26;
          v25 += 2;
          --v23;
        }
        while (v23);
      }
      v21 += v22;
      ++v20;
    }
    while (v20 != a3);
    v27 = 2 * v13;
  }
  v28 = *(double *)&qword_1EF1AE290;
  v29 = *(double *)&xmmword_1EF1AE270;
  LOBYTE(v35[0]) = 0;
  extra_with_key = data_map_get_extra_with_key(v12, (uint64_t)v18, v27, v35);
  if ((_DWORD)extra_with_key)
    v31 = HIDWORD(extra_with_key) == 4;
  else
    v31 = 0;
  v32 = !v31 || LOBYTE(v35[0]) == 0;
  v33 = (double)extra_with_key;
  if (v32)
    v33 = v29;
  SIModelManager::getScore(a3, v28 / v33);
}

void SIModelManager::getInstance(SIModelManager *this)
{
  unsigned __int8 v1;

  if ((v1 & 1) == 0)
  {
    {
      qword_1EF1AE248 = 0;
      SIModelManager::getInstance(void)::instance = (uint64_t)&qword_1EF1AE248;
      qword_1EF1AE268 = 0;
      qword_1EF1AE260 = 0;
      qword_1EF1AE250 = 0;
      unk_1EF1AE258 = &qword_1EF1AE260;
      xmmword_1EF1AE270 = xmmword_1B8631C00;
      *(int64x2_t *)&qword_1EF1AE280 = vdupq_n_s64(0x3E7AD7F29ABCAF48uLL);
      qword_1EF1AE290 = 0x3FF0000000000000;
      byte_1EF1AE298 = 1;
      __asm { FMOV            V0.2D, #1.0 }
      xmmword_1EF1AE2A0 = _Q0;
      *(_OWORD *)&qword_1EF1AE2B0 = xmmword_1B8631C10;
      qword_1EF1AE2C0 = 0x3FD0000000000000;
      __cxa_atexit((void (*)(void *))SIModelManager::~SIModelManager, &SIModelManager::getInstance(void)::instance, &dword_1B8270000);
    }
  }
}

void analytics::SampledLogger<analytics::GetEvent>::~SampledLogger(uint64_t a1)
{
  analytics::SampledLogger<analytics::GetEvent>::~SampledLogger(a1);
  JUMPOUT(0x1BCCB06A4);
}

void analytics::SampledLogger<analytics::GetEvent>::logEvent(uint64_t a1, uint64_t *a2)
{
  std::mutex *v4;
  uint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  char *v19;
  char *v20;
  uint64_t v21;
  _QWORD *v22;
  _QWORD *v23;
  uint64_t v24;
  int64x2_t v25;
  _QWORD *v26;
  _QWORD *v27;
  uint64_t v28;
  uint64_t v29;

  v4 = (std::mutex *)(a1 + 88);
  std::mutex::lock((std::mutex *)(a1 + 88));
  v5 = *(_QWORD *)(a1 + 56);
  v6 = *(_QWORD **)(a1 + 64);
  v7 = ((uint64_t)v6 - v5) >> 3;
  if (v7 >= *(_QWORD *)(a1 + 24))
  {
    ++*(_QWORD *)(a1 + 80);
    v11 = (unint64_t)rand() % *(_QWORD *)(a1 + 80);
    v12 = *(_QWORD *)(a1 + 56);
    if (v11 < (*(_QWORD *)(a1 + 64) - v12) >> 3)
    {
      v13 = *a2;
      *a2 = 0;
      v14 = *(_QWORD *)(v12 + 8 * v11);
      *(_QWORD *)(v12 + 8 * v11) = v13;
      if (v14)
        MEMORY[0x1BCCB06A4](v14, 0x1000C4073594BB7);
    }
  }
  else
  {
    v8 = *(_QWORD *)(a1 + 72);
    if ((unint64_t)v6 >= v8)
    {
      if ((v7 + 1) >> 61)
        abort();
      v15 = v8 - v5;
      v16 = v15 >> 2;
      if (v15 >> 2 <= v7 + 1)
        v16 = v7 + 1;
      if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8)
        v17 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v17 = v16;
      if (v17)
      {
        if (v17 >> 61)
          std::__throw_bad_array_new_length[abi:nn180100]();
        v18 = (char *)operator new(8 * v17);
      }
      else
      {
        v18 = 0;
      }
      v19 = &v18[8 * v7];
      v20 = &v18[8 * v17];
      v21 = *a2;
      *a2 = 0;
      *(_QWORD *)v19 = v21;
      v10 = v19 + 8;
      v23 = *(_QWORD **)(a1 + 56);
      v22 = *(_QWORD **)(a1 + 64);
      if (v22 == v23)
      {
        v25 = vdupq_n_s64((unint64_t)v22);
      }
      else
      {
        do
        {
          v24 = *--v22;
          *v22 = 0;
          *((_QWORD *)v19 - 1) = v24;
          v19 -= 8;
        }
        while (v22 != v23);
        v25 = *(int64x2_t *)(a1 + 56);
      }
      *(_QWORD *)(a1 + 56) = v19;
      *(_QWORD *)(a1 + 64) = v10;
      *(_QWORD *)(a1 + 72) = v20;
      v27 = (_QWORD *)v25.i64[1];
      v26 = (_QWORD *)v25.i64[0];
      while (v27 != v26)
      {
        v29 = *--v27;
        v28 = v29;
        *v27 = 0;
        if (v29)
          MEMORY[0x1BCCB06A4](v28, 0x1000C4073594BB7);
      }
      if (v26)
        operator delete(v26);
    }
    else
    {
      v9 = *a2;
      *a2 = 0;
      *v6 = v9;
      v10 = v6 + 1;
    }
    *(_QWORD *)(a1 + 64) = v10;
  }
  std::mutex::unlock(v4);
}

uint64_t analytics::SampledLogger<analytics::GetEvent>::~SampledLogger(uint64_t a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  std::__shared_weak_count *v5;
  void **v7;

  *(_QWORD *)a1 = &off_1E6E2AA28;
  std::mutex::~mutex((std::mutex *)(a1 + 88));
  v7 = (void **)(a1 + 56);
  std::vector<std::unique_ptr<analytics::GetEvent>>::__destroy_vector::operator()[abi:nn180100](&v7);
  v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
    std::__shared_weak_count::__release_weak(v5);
  return a1;
}

void std::vector<std::unique_ptr<analytics::GetEvent>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<std::unique_ptr<analytics::GetEvent>>::__base_destruct_at_end[abi:nn180100]((uint64_t)v2, *v2);
    operator delete(**a1);
  }
}

uint64_t std::vector<std::unique_ptr<analytics::GetEvent>>::__base_destruct_at_end[abi:nn180100](uint64_t result, _QWORD *a2)
{
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;

  v3 = result;
  v4 = *(_QWORD **)(result + 8);
  while (v4 != a2)
  {
    v5 = *--v4;
    result = v5;
    *v4 = 0;
    if (v5)
      result = MEMORY[0x1BCCB06A4](result, 0x1000C4073594BB7);
  }
  *(_QWORD *)(v3 + 8) = a2;
  return result;
}

void analytics::SampledLogger<analytics::PutEvent>::~SampledLogger(uint64_t a1)
{
  analytics::SampledLogger<analytics::PutEvent>::~SampledLogger(a1);
  JUMPOUT(0x1BCCB06A4);
}

void analytics::SampledLogger<analytics::PutEvent>::logEvent(uint64_t a1, uint64_t *a2)
{
  std::mutex *v4;
  uint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  char *v19;
  char *v20;
  uint64_t v21;
  _QWORD *v22;
  _QWORD *v23;
  uint64_t v24;
  int64x2_t v25;
  _QWORD *v26;
  _QWORD *v27;
  uint64_t v28;
  uint64_t v29;

  v4 = (std::mutex *)(a1 + 88);
  std::mutex::lock((std::mutex *)(a1 + 88));
  v5 = *(_QWORD *)(a1 + 56);
  v6 = *(_QWORD **)(a1 + 64);
  v7 = ((uint64_t)v6 - v5) >> 3;
  if (v7 >= *(_QWORD *)(a1 + 24))
  {
    ++*(_QWORD *)(a1 + 80);
    v11 = (unint64_t)rand() % *(_QWORD *)(a1 + 80);
    v12 = *(_QWORD *)(a1 + 56);
    if (v11 < (*(_QWORD *)(a1 + 64) - v12) >> 3)
    {
      v13 = *a2;
      *a2 = 0;
      v14 = *(_QWORD *)(v12 + 8 * v11);
      *(_QWORD *)(v12 + 8 * v11) = v13;
      if (v14)
        MEMORY[0x1BCCB06A4](v14, 0x1000C4022EED179);
    }
  }
  else
  {
    v8 = *(_QWORD *)(a1 + 72);
    if ((unint64_t)v6 >= v8)
    {
      if ((v7 + 1) >> 61)
        abort();
      v15 = v8 - v5;
      v16 = v15 >> 2;
      if (v15 >> 2 <= v7 + 1)
        v16 = v7 + 1;
      if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8)
        v17 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v17 = v16;
      if (v17)
      {
        if (v17 >> 61)
          std::__throw_bad_array_new_length[abi:nn180100]();
        v18 = (char *)operator new(8 * v17);
      }
      else
      {
        v18 = 0;
      }
      v19 = &v18[8 * v7];
      v20 = &v18[8 * v17];
      v21 = *a2;
      *a2 = 0;
      *(_QWORD *)v19 = v21;
      v10 = v19 + 8;
      v23 = *(_QWORD **)(a1 + 56);
      v22 = *(_QWORD **)(a1 + 64);
      if (v22 == v23)
      {
        v25 = vdupq_n_s64((unint64_t)v22);
      }
      else
      {
        do
        {
          v24 = *--v22;
          *v22 = 0;
          *((_QWORD *)v19 - 1) = v24;
          v19 -= 8;
        }
        while (v22 != v23);
        v25 = *(int64x2_t *)(a1 + 56);
      }
      *(_QWORD *)(a1 + 56) = v19;
      *(_QWORD *)(a1 + 64) = v10;
      *(_QWORD *)(a1 + 72) = v20;
      v27 = (_QWORD *)v25.i64[1];
      v26 = (_QWORD *)v25.i64[0];
      while (v27 != v26)
      {
        v29 = *--v27;
        v28 = v29;
        *v27 = 0;
        if (v29)
          MEMORY[0x1BCCB06A4](v28, 0x1000C4022EED179);
      }
      if (v26)
        operator delete(v26);
    }
    else
    {
      v9 = *a2;
      *a2 = 0;
      *v6 = v9;
      v10 = v6 + 1;
    }
    *(_QWORD *)(a1 + 64) = v10;
  }
  std::mutex::unlock(v4);
}

uint64_t analytics::SampledLogger<analytics::PutEvent>::~SampledLogger(uint64_t a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  std::__shared_weak_count *v5;
  void **v7;

  *(_QWORD *)a1 = &off_1E6E2AA50;
  std::mutex::~mutex((std::mutex *)(a1 + 88));
  v7 = (void **)(a1 + 56);
  std::vector<std::unique_ptr<analytics::PutEvent>>::__destroy_vector::operator()[abi:nn180100](&v7);
  v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  v5 = *(std::__shared_weak_count **)(a1 + 16);
  if (v5)
    std::__shared_weak_count::__release_weak(v5);
  return a1;
}

void std::vector<std::unique_ptr<analytics::PutEvent>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<std::unique_ptr<analytics::PutEvent>>::__base_destruct_at_end[abi:nn180100]((uint64_t)v2, *v2);
    operator delete(**a1);
  }
}

uint64_t std::vector<std::unique_ptr<analytics::PutEvent>>::__base_destruct_at_end[abi:nn180100](uint64_t result, _QWORD *a2)
{
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;

  v3 = result;
  v4 = *(_QWORD **)(result + 8);
  while (v4 != a2)
  {
    v5 = *--v4;
    result = v5;
    *v4 = 0;
    if (v5)
      result = MEMORY[0x1BCCB06A4](result, 0x1000C4022EED179);
  }
  *(_QWORD *)(v3 + 8) = a2;
  return result;
}

void analytics::SampledLogger<analytics::DeleteEvent>::~SampledLogger(uint64_t a1)
{
  analytics::SampledLogger<analytics::DeleteEvent>::~SampledLogger(a1);
  JUMPOUT(0x1BCCB06A4);
}

void analytics::SampledLogger<analytics::DeleteEvent>::logEvent(uint64_t a1, uint64_t *a2)
{
  std::mutex *v4;
  uint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  char *v19;
  char *v20;
  uint64_t v21;
  _QWORD *v22;
  _QWORD *v23;
  uint64_t v24;
  int64x2_t v25;
  _QWORD *v26;
  _QWORD *v27;
  uint64_t v28;
  uint64_t v29;

  v4 = (std::mutex *)(a1 + 88);
  std::mutex::lock((std::mutex *)(a1 + 88));
  v5 = *(_QWORD *)(a1 + 56);
  v6 = *(_QWORD **)(a1 + 64);
  v7 = ((uint64_t)v6 - v5) >> 3;
  if (v7 >= *(_QWORD *)(a1 + 24))
  {
    ++*(_QWORD *)(a1 + 80);
    v11 = (unint64_t)rand() % *(_QWORD *)(a1 + 80);
    v12 = *(_QWORD *)(a1 + 56);
    if (v11 < (*(_QWORD *)(a1 + 64) - v12) >> 3)
    {
      v13 = *a2;
      *a2 = 0;
      v14 = *(_QWORD *)(v12 + 8 * v11);
      *(_QWORD *)(v12 + 8 * v11) = v13;
      if (v14)
        MEMORY[0x1BCCB06A4](v14, 0x1000C4073594BB7);
    }
  }
  else
  {
    v8 = *(_QWORD *)(a1 + 72);
    if ((unint64_t)v6 >= v8)
    {
      if ((v7 + 1) >> 61)
        abort();
      v15 = v8 - v5;
      v16 = v15 >> 2;
      if (v15 >> 2 <= v7 + 1)
        v16 = v7 + 1;
      if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8)
        v17 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v17 = v16;
      if (v17)
      {
        if (v17 >> 61)
          std::__throw_bad_array_new_length[abi:nn180100]();
        v18 = (char *)operator new(8 * v17);
      }
      else
      {
        v18 = 0;
      }
      v19 = &v18[8 * v7];
      v20 = &v18[8 * v17];
      v21 = *a2;
      *a2 = 0;
      *(_QWORD *)v19 = v21;
      v10 = v19 + 8;
      v23 = *(_QWORD **)(a1 + 56);
      v22 = *(_QWORD **)(a1 + 64);
      if (v22 == v23)
      {
        v25 = vdupq_n_s64((unint64_t)v22);
      }
      else
      {
        do
        {
          v24 = *--v22;
          *v22 = 0;
          *((_QWORD *)v19 - 1) = v24;
          v19 -= 8;
        }
        while (v22 != v23);
        v25 = *(int64x2_t *)(a1 + 56);
      }
      *(_QWORD *)(a1 + 56) = v19;
      *(_QWORD *)(a1 + 64) = v10;
      *(_QWORD *)(a1 + 72) = v20;
      v27 = (_QWORD *)v25.i64[1];
      v26 = (_QWORD *)v25.i64[0];
      while (v27 != v26)
      {
        v29 = *--v27;
        v28 = v29;
        *v27 = 0;
        if (v29)
          MEMORY[0x1BCCB06A4](v28, 0x1000C4073594BB7);
      }
      if (v26)
        operator delete(v26);
    }
    else
    {
      v9 = *a2;
      *a2 = 0;
      *v6 = v9;
      v10 = v6 + 1;
    }
    *(_QWORD *)(a1 + 64) = v10;
  }
  std::mutex::unlock(v4);
}

uint64_t analytics::SampledLogger<analytics::DeleteEvent>::~SampledLogger(uint64_t a1)
{
  std::__shared_weak_count *v2;
  void **v4;

  *(_QWORD *)a1 = &off_1E6E2AA00;
  std::mutex::~mutex((std::mutex *)(a1 + 88));
  v4 = (void **)(a1 + 56);
  std::vector<std::unique_ptr<analytics::GetEvent>>::__destroy_vector::operator()[abi:nn180100](&v4);
  std::shared_ptr<analytics::EventLogger<analytics::DeleteEvent>>::~shared_ptr[abi:nn180100](a1 + 32);
  v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  return a1;
}

uint64_t std::shared_ptr<analytics::EventLogger<analytics::DeleteEvent>>::~shared_ptr[abi:nn180100](uint64_t a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;

  v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  return a1;
}

void analytics::XpcActivityScheduler::~XpcActivityScheduler(analytics::XpcActivityScheduler *this)
{
  std::mutex *v1;
  void **v2;

  *(_QWORD *)this = &off_1E6E2AA78;
  v1 = (std::mutex *)((char *)this + 16);
  v2 = (void **)((char *)this + 80);
  std::vector<std::function<void ()(void)>>::__destroy_vector::operator()[abi:nn180100](&v2);
  std::mutex::~mutex(v1);
}

{
  std::mutex *v1;
  void **v2;

  *(_QWORD *)this = &off_1E6E2AA78;
  v1 = (std::mutex *)((char *)this + 16);
  v2 = (void **)((char *)this + 80);
  std::vector<std::function<void ()(void)>>::__destroy_vector::operator()[abi:nn180100](&v2);
  std::mutex::~mutex(v1);
  JUMPOUT(0x1BCCB06A4);
}

void analytics::XpcActivityScheduler::start(uint64_t a1, _QWORD *a2)
{
  std::mutex *v4;
  unint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  _QWORD *v15;
  char *v16;
  char *v17;
  char *v18;
  unint64_t v19;
  uint64_t v20;
  char *v21;
  char *v22;
  char *v23;
  char *v24;
  uint64_t v25;
  _QWORD block[5];

  v4 = (std::mutex *)(a1 + 16);
  std::mutex::lock((std::mutex *)(a1 + 16));
  v6 = *(_QWORD *)(a1 + 88);
  v5 = *(_QWORD *)(a1 + 96);
  if (v6 < v5)
  {
    v7 = (_QWORD *)a2[3];
    if (v7)
    {
      if (v7 == a2)
      {
        *(_QWORD *)(v6 + 24) = v6;
        (*(void (**)(_QWORD, unint64_t))(*(_QWORD *)a2[3] + 24))(a2[3], v6);
      }
      else
      {
        *(_QWORD *)(v6 + 24) = v7;
        a2[3] = 0;
      }
    }
    else
    {
      *(_QWORD *)(v6 + 24) = 0;
    }
    v16 = (char *)(v6 + 32);
    goto LABEL_41;
  }
  v8 = *(_QWORD *)(a1 + 80);
  v9 = (uint64_t)(v6 - v8) >> 5;
  v10 = v9 + 1;
  if ((unint64_t)(v9 + 1) >> 59)
    abort();
  v11 = v5 - v8;
  if (v11 >> 4 > v10)
    v10 = v11 >> 4;
  if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFE0)
    v12 = 0x7FFFFFFFFFFFFFFLL;
  else
    v12 = v10;
  if (v12)
  {
    if (v12 >> 59)
      std::__throw_bad_array_new_length[abi:nn180100]();
    v13 = (char *)operator new(32 * v12);
  }
  else
  {
    v13 = 0;
  }
  v14 = &v13[32 * v9];
  v15 = (_QWORD *)a2[3];
  if (v15)
  {
    if (v15 == a2)
    {
      *((_QWORD *)v14 + 3) = v14;
      (*(void (**)(_QWORD *, char *))(*a2 + 24))(a2, v14);
      v8 = *(_QWORD *)(a1 + 80);
      v6 = *(_QWORD *)(a1 + 88);
    }
    else
    {
      *((_QWORD *)v14 + 3) = v15;
      a2[3] = 0;
    }
  }
  else
  {
    *((_QWORD *)v14 + 3) = 0;
  }
  v17 = &v13[32 * v12];
  v16 = v14 + 32;
  if (v6 == v8)
  {
    v18 = v14;
  }
  else
  {
    do
    {
      v18 = v14 - 32;
      v19 = v6 - 32;
      v20 = *(_QWORD *)(v6 - 8);
      if (v20)
      {
        if (v19 == v20)
        {
          *((_QWORD *)v14 - 1) = v18;
          (*(void (**)(_QWORD, char *))(**(_QWORD **)(v6 - 8) + 24))(*(_QWORD *)(v6 - 8), v14 - 32);
        }
        else
        {
          *((_QWORD *)v14 - 1) = v20;
          *(_QWORD *)(v6 - 8) = 0;
        }
      }
      else
      {
        *((_QWORD *)v14 - 1) = 0;
      }
      v6 -= 32;
      v14 -= 32;
    }
    while (v19 != v8);
  }
  v22 = *(char **)(a1 + 80);
  v21 = *(char **)(a1 + 88);
  *(_QWORD *)(a1 + 80) = v18;
  *(_QWORD *)(a1 + 88) = v16;
  *(_QWORD *)(a1 + 96) = v17;
  if (v21 != v22)
  {
    while (1)
    {
      v23 = v21 - 32;
      v24 = (char *)*((_QWORD *)v21 - 1);
      if (v21 - 32 == v24)
        break;
      if (v24)
      {
        v25 = 5;
LABEL_37:
        (*(void (**)(void))(*(_QWORD *)v24 + 8 * v25))();
      }
      v21 = v23;
      if (v23 == v22)
        goto LABEL_39;
    }
    v24 = v21 - 32;
    v25 = 4;
    goto LABEL_37;
  }
LABEL_39:
  if (v22)
    operator delete(v22);
LABEL_41:
  *(_QWORD *)(a1 + 88) = v16;
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = ___ZN9analytics20XpcActivityScheduler23registerXpcActivityOnceEv_block_invoke;
  block[3] = &__block_descriptor_tmp_20;
  block[4] = a1;
  if (analytics::XpcActivityScheduler::registerXpcActivityOnce(void)::onceToken != -1)
    dispatch_once(&analytics::XpcActivityScheduler::registerXpcActivityOnce(void)::onceToken, block);
  std::mutex::unlock(v4);
}

void ___ZN9analytics20XpcActivityScheduler23registerXpcActivityOnceEv_block_invoke(uint64_t a1)
{
  uint64_t v1;
  xpc_object_t v2;
  void (*v3)(const char *, xpc_object_t, _QWORD *);
  _QWORD v4[5];

  v1 = *(_QWORD *)(a1 + 32);
  v2 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_BOOL(v2, (const char *)*MEMORY[0x1E0C80898], 1);
  xpc_dictionary_set_int64(v2, (const char *)*MEMORY[0x1E0C80760], *MEMORY[0x1E0C807C0]);
  xpc_dictionary_set_int64(v2, (const char *)*MEMORY[0x1E0C80790], *MEMORY[0x1E0C807E0]);
  v3 = *(void (**)(const char *, xpc_object_t, _QWORD *))(v1 + 8);
  v4[0] = MEMORY[0x1E0C809B0];
  v4[1] = 0x40000000;
  v4[2] = ___ZN9analytics20XpcActivityScheduler23registerXpcActivityOnceEv_block_invoke_2;
  v4[3] = &__block_descriptor_tmp_19_1478;
  v4[4] = v1;
  v3("com.apple.spotlight.textstore.Analytics", v2, v4);
  xpc_release(v2);
}

void ___ZN9analytics20XpcActivityScheduler23registerXpcActivityOnceEv_block_invoke_2(uint64_t a1)
{
  uint64_t v1;
  std::mutex *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  void ***v6;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = (std::mutex *)(v1 + 16);
  std::mutex::lock((std::mutex *)(v1 + 16));
  v3 = *(_QWORD *)(v1 + 80);
  v4 = *(_QWORD *)(v1 + 88);
  while (1)
  {
    if (v3 == v4)
    {
      std::mutex::unlock(v2);
      return;
    }
    v5 = *(_QWORD *)(v3 + 24);
    if (!v5)
      break;
    (*(void (**)(uint64_t))(*(_QWORD *)v5 + 48))(v5);
    v3 += 32;
  }
  std::__throw_bad_function_call[abi:nn180100]();
  std::vector<std::function<void ()(void)>>::__destroy_vector::operator()[abi:nn180100](v6);
}

void std::vector<std::function<void ()(void)>>::__destroy_vector::operator()[abi:nn180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  char *v6;
  char *v7;
  uint64_t v8;

  v1 = *a1;
  v2 = (char *)**a1;
  if (!v2)
    return;
  v4 = (char *)v1[1];
  v5 = **a1;
  if (v4 == v2)
    goto LABEL_10;
  do
  {
    v6 = v4 - 32;
    v7 = (char *)*((_QWORD *)v4 - 1);
    if (v4 - 32 == v7)
    {
      v7 = v4 - 32;
      v8 = 4;
    }
    else
    {
      if (!v7)
        goto LABEL_8;
      v8 = 5;
    }
    (*(void (**)(void))(*(_QWORD *)v7 + 8 * v8))();
LABEL_8:
    v4 = v6;
  }
  while (v6 != v2);
  v5 = **a1;
LABEL_10:
  v1[1] = v2;
  operator delete(v5);
}

_QWORD *std::__function::__func<analytics::SampledLogger<analytics::GetEvent>::startAsync(void)::{lambda(void)#1},std::allocator<analytics::SampledLogger<analytics::GetEvent>::startAsync(void)::{lambda(void)#1}>,void ()(void)>::~__func(_QWORD *a1)
{
  std::__shared_weak_count *v2;

  *a1 = &off_1E6E2ABC0;
  v2 = (std::__shared_weak_count *)a1[2];
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  return a1;
}

void std::__function::__func<analytics::SampledLogger<analytics::GetEvent>::startAsync(void)::{lambda(void)#1},std::allocator<analytics::SampledLogger<analytics::GetEvent>::startAsync(void)::{lambda(void)#1}>,void ()(void)>::~__func(_QWORD *a1)
{
  std::__shared_weak_count *v1;

  *a1 = &off_1E6E2ABC0;
  v1 = (std::__shared_weak_count *)a1[2];
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
  JUMPOUT(0x1BCCB06A4);
}

_QWORD *std::__function::__func<analytics::SampledLogger<analytics::GetEvent>::startAsync(void)::{lambda(void)#1},std::allocator<analytics::SampledLogger<analytics::GetEvent>::startAsync(void)::{lambda(void)#1}>,void ()(void)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;

  result = operator new(0x18uLL);
  v4 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16);
  *result = &off_1E6E2ABC0;
  result[1] = v4;
  result[2] = v3;
  if (v3)
  {
    v5 = (unint64_t *)(v3 + 16);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  return result;
}

uint64_t std::__function::__func<analytics::SampledLogger<analytics::GetEvent>::startAsync(void)::{lambda(void)#1},std::allocator<analytics::SampledLogger<analytics::GetEvent>::startAsync(void)::{lambda(void)#1}>,void ()(void)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;

  v3 = *(_QWORD *)(result + 8);
  v2 = *(_QWORD *)(result + 16);
  *a2 = &off_1E6E2ABC0;
  a2[1] = v3;
  a2[2] = v2;
  if (v2)
  {
    v4 = (unint64_t *)(v2 + 16);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  return result;
}

void std::__function::__func<analytics::SampledLogger<analytics::GetEvent>::startAsync(void)::{lambda(void)#1},std::allocator<analytics::SampledLogger<analytics::GetEvent>::startAsync(void)::{lambda(void)#1}>,void ()(void)>::destroy(uint64_t a1)
{
  std::__shared_weak_count *v1;

  v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
}

void std::__function::__func<analytics::SampledLogger<analytics::GetEvent>::startAsync(void)::{lambda(void)#1},std::allocator<analytics::SampledLogger<analytics::GetEvent>::startAsync(void)::{lambda(void)#1}>,void ()(void)>::destroy_deallocate(_QWORD *__p)
{
  std::__shared_weak_count *v2;

  v2 = (std::__shared_weak_count *)__p[2];
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  operator delete(__p);
}

void std::__function::__func<analytics::SampledLogger<analytics::GetEvent>::startAsync(void)::{lambda(void)#1},std::allocator<analytics::SampledLogger<analytics::GetEvent>::startAsync(void)::{lambda(void)#1}>,void ()(void)>::operator()(uint64_t a1)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  uint64_t *i;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  __int128 v12;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;
  void **v16;

  v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      v4 = v3;
      v5 = *(_QWORD *)(a1 + 8);
      if (v5)
      {
        std::mutex::lock((std::mutex *)(v5 + 88));
        v14 = *(_OWORD *)(v5 + 56);
        v12 = v14;
        v15 = *(_QWORD *)(v5 + 72);
        *(_OWORD *)(v5 + 72) = 0u;
        *(_OWORD *)(v5 + 56) = 0u;
        std::mutex::unlock((std::mutex *)(v5 + 88));
        for (i = (uint64_t *)v12; i != *((uint64_t **)&v12 + 1); ++i)
        {
          v7 = *(_QWORD *)(v5 + 32);
          v8 = *i;
          *i = 0;
          v13 = v8;
          (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v7 + 16))(v7, &v13);
          v9 = v13;
          v13 = 0;
          if (v9)
            MEMORY[0x1BCCB06A4](v9, 0x1000C4073594BB7);
        }
        v16 = (void **)&v14;
        std::vector<std::unique_ptr<analytics::GetEvent>>::__destroy_vector::operator()[abi:nn180100](&v16);
      }
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v11 = __ldaxr(p_shared_owners);
      while (__stlxr(v11 - 1, p_shared_owners));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

double ___ZN9analytics20XpcActivityScheduler11getInstanceEv_block_invoke()
{
  uint64_t v0;
  uint64_t v1;
  double result;

  v0 = operator new();
  v1 = MEMORY[0x1E0C85D98];
  *(_QWORD *)v0 = &off_1E6E2AA78;
  *(_QWORD *)(v0 + 8) = v1;
  *(_QWORD *)(v0 + 16) = 850045863;
  result = 0.0;
  *(_OWORD *)(v0 + 24) = 0u;
  *(_OWORD *)(v0 + 40) = 0u;
  *(_OWORD *)(v0 + 56) = 0u;
  *(_OWORD *)(v0 + 72) = 0u;
  *(_OWORD *)(v0 + 88) = 0u;
  analytics::XpcActivityScheduler::getInstance(void)::instance = v0;
  return result;
}

void analytics::`anonymous namespace'::CoreAnalyticsLogger<analytics::GetEvent>::~CoreAnalyticsLogger()
{
  JUMPOUT(0x1BCCB06A4);
}

void analytics::`anonymous namespace'::CoreAnalyticsLogger<analytics::GetEvent>::logEvent(uint64_t a1, std::__shared_weak_count_vtbl **a2)
{
  std::__shared_weak_count *v3;
  std::__shared_weak_count_vtbl *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  int v7;
  int v8;
  NSObject *v9;
  os_log_type_t v10;
  _BOOL4 v11;
  const char *v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  uint8_t buf[4];
  const char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (*a2)
  {
    v3 = (std::__shared_weak_count *)operator new();
    v4 = *a2;
    v3->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6E2AE80;
    v3->__shared_owners_ = 0;
    v3->__shared_weak_owners_ = 0;
    v3[1].__vftable = v4;
  }
  else
  {
    v3 = 0;
  }
  *a2 = 0;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  v7 = analytics_send_event_lazy();
  v8 = *__error();
  v9 = _SILogForLogForCategory(8);
  v10 = 2 * (dword_1EF19FCAC < 4);
  v11 = os_log_type_enabled(v9, v10);
  if (v7)
  {
    if (v11)
    {
      *(_DWORD *)buf = 136315138;
      v18 = "com.apple.spotlight.textstore.Get";
      v12 = "successfully logged event: %s";
LABEL_12:
      _os_log_impl(&dword_1B8270000, v9, v10, v12, buf, 0xCu);
    }
  }
  else if (v11)
  {
    *(_DWORD *)buf = 136315138;
    v18 = "com.apple.spotlight.textstore.Get";
    v12 = "event logging disabled: %s";
    goto LABEL_12;
  }
  *__error() = v8;
  if (v3)
  {
    v13 = (unint64_t *)&v3->__shared_owners_;
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  if (v3)
  {
    v15 = (unint64_t *)&v3->__shared_owners_;
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

xpc_object_t ___ZN9analytics12_GLOBAL__N_119CoreAnalyticsLoggerINS_8GetEventEE8logEventENSt3__110unique_ptrIS2_NS4_14default_deleteIS2_EEEE_block_invoke(uint64_t a1)
{
  unsigned __int8 *v1;
  char *v2;
  char *v3;
  int v4;
  xpc_object_t v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  char *v13;
  char *v14;
  uint64_t v15;
  xpc_object_t v16;
  xpc_object_t v17;
  char *v18;
  char *v19;
  char *v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  char *v28;
  char *v29;
  char *v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  char *v36;
  uint64_t v37;
  xpc_object_t v38;
  xpc_object_t v39;
  char *v40;
  char *v41;
  char *v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  char *v48;
  uint64_t v49;
  char *v50;
  char *v51;
  char *v52;
  uint64_t v53;
  unint64_t v54;
  uint64_t v55;
  unint64_t v56;
  uint64_t v57;
  char *v58;
  uint64_t v59;
  xpc_object_t v60;
  xpc_object_t v61;
  char *v62;
  char *v63;
  char *v64;
  uint64_t v65;
  unint64_t v66;
  uint64_t v67;
  unint64_t v68;
  uint64_t v69;
  char *v70;
  uint64_t v71;
  char *v72;
  char *v73;
  char *v74;
  uint64_t v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  char *v80;
  uint64_t v81;
  xpc_object_t v82;
  xpc_object_t v83;
  char *v84;
  char *v85;
  char *v86;
  uint64_t v87;
  unint64_t v88;
  uint64_t v89;
  unint64_t v90;
  uint64_t v91;
  char *v92;
  uint64_t v93;
  char *v94;
  char *v95;
  char *v96;
  uint64_t v97;
  unint64_t v98;
  uint64_t v99;
  unint64_t v100;
  uint64_t v101;
  char *v102;
  uint64_t v103;
  xpc_object_t v104;
  xpc_object_t v105;
  char *v106;
  char *v107;
  char *v108;
  uint64_t v109;
  unint64_t v110;
  uint64_t v111;
  unint64_t v112;
  uint64_t v113;
  char *v114;
  uint64_t v115;
  xpc_object_t v116;
  void *__p;
  char *v119;
  char *v120;
  void *v121;
  char *v122;
  char *v123;

  v1 = *(unsigned __int8 **)(a1 + 32);
  v121 = 0;
  v122 = 0;
  v123 = 0;
  __p = 0;
  v119 = 0;
  v120 = 0;
  if (v1[1])
  {
    v2 = (char *)operator new(8uLL);
    *(_QWORD *)v2 = "success";
    v3 = v2 + 8;
    v122 = v2 + 8;
    v123 = v2 + 8;
    v4 = *v1;
    v121 = v2;
    v5 = xpc_BOOL_create(v4 != 0);
    v6 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(1uLL);
    *(_QWORD *)v6 = v5;
    __p = v6;
    v119 = v6 + 8;
    v120 = &v6[8 * v7];
  }
  else
  {
    v2 = 0;
    v3 = 0;
  }
  if (v1[8])
  {
    v8 = v3 - v2;
    v9 = (v3 - v2) >> 3;
    v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 61)
      goto LABEL_177;
    if (v8 >> 2 > v10)
      v10 = v8 >> 2;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    if (v11)
      v11 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v11);
    else
      v12 = 0;
    v13 = (char *)(v11 + 8 * v9);
    *(_QWORD *)v13 = "error_code";
    v14 = v13 + 8;
    if (v3 != v2)
    {
      do
      {
        v15 = *((_QWORD *)v3 - 1);
        v3 -= 8;
        *((_QWORD *)v13 - 1) = v15;
        v13 -= 8;
      }
      while (v3 != v2);
      v2 = (char *)v121;
    }
    v121 = v13;
    v123 = (char *)(v11 + 8 * v12);
    if (v2)
      operator delete(v2);
    v122 = v14;
    v16 = xpc_int64_create(*((int *)v1 + 1));
    v17 = v16;
    v18 = v119;
    if (v119 >= v120)
    {
      v20 = (char *)__p;
      v21 = (v119 - (_BYTE *)__p) >> 3;
      v22 = v21 + 1;
      if ((unint64_t)(v21 + 1) >> 61)
        goto LABEL_177;
      v23 = v120 - (_BYTE *)__p;
      if ((v120 - (_BYTE *)__p) >> 2 > v22)
        v22 = v23 >> 2;
      if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8)
        v24 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v24 = v22;
      if (v24)
        v24 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v24);
      else
        v25 = 0;
      v26 = (char *)(v24 + 8 * v21);
      *(_QWORD *)v26 = v17;
      v19 = v26 + 8;
      if (v18 != v20)
      {
        do
        {
          v27 = *((_QWORD *)v18 - 1);
          v18 -= 8;
          *((_QWORD *)v26 - 1) = v27;
          v26 -= 8;
        }
        while (v18 != v20);
        v18 = (char *)__p;
      }
      __p = v26;
      v120 = (char *)(v24 + 8 * v25);
      if (v18)
        operator delete(v18);
    }
    else
    {
      *(_QWORD *)v119 = v16;
      v19 = v18 + 8;
    }
    v119 = v19;
  }
  if (v1[24])
  {
    v28 = v122;
    if (v122 >= v123)
    {
      v30 = (char *)v121;
      v31 = (v122 - (_BYTE *)v121) >> 3;
      v32 = v31 + 1;
      if ((unint64_t)(v31 + 1) >> 61)
        goto LABEL_177;
      v33 = v123 - (_BYTE *)v121;
      if ((v123 - (_BYTE *)v121) >> 2 > v32)
        v32 = v33 >> 2;
      if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFF8)
        v34 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v34 = v32;
      if (v34)
        v34 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v34);
      else
        v35 = 0;
      v36 = (char *)(v34 + 8 * v31);
      *(_QWORD *)v36 = "requested_doc_count";
      v29 = v36 + 8;
      if (v28 != v30)
      {
        do
        {
          v37 = *((_QWORD *)v28 - 1);
          v28 -= 8;
          *((_QWORD *)v36 - 1) = v37;
          v36 -= 8;
        }
        while (v28 != v30);
        v28 = (char *)v121;
      }
      v121 = v36;
      v123 = (char *)(v34 + 8 * v35);
      if (v28)
        operator delete(v28);
    }
    else
    {
      *(_QWORD *)v122 = "requested_doc_count";
      v29 = v28 + 8;
    }
    v122 = v29;
    v38 = xpc_int64_create(*((_QWORD *)v1 + 2));
    v39 = v38;
    v40 = v119;
    if (v119 >= v120)
    {
      v42 = (char *)__p;
      v43 = (v119 - (_BYTE *)__p) >> 3;
      v44 = v43 + 1;
      if ((unint64_t)(v43 + 1) >> 61)
        goto LABEL_177;
      v45 = v120 - (_BYTE *)__p;
      if ((v120 - (_BYTE *)__p) >> 2 > v44)
        v44 = v45 >> 2;
      if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFF8)
        v46 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v46 = v44;
      if (v46)
        v46 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v46);
      else
        v47 = 0;
      v48 = (char *)(v46 + 8 * v43);
      *(_QWORD *)v48 = v39;
      v41 = v48 + 8;
      if (v40 != v42)
      {
        do
        {
          v49 = *((_QWORD *)v40 - 1);
          v40 -= 8;
          *((_QWORD *)v48 - 1) = v49;
          v48 -= 8;
        }
        while (v40 != v42);
        v40 = (char *)__p;
      }
      __p = v48;
      v120 = (char *)(v46 + 8 * v47);
      if (v40)
        operator delete(v40);
    }
    else
    {
      *(_QWORD *)v119 = v38;
      v41 = v40 + 8;
    }
    v119 = v41;
  }
  if (v1[40])
  {
    v50 = v122;
    if (v122 >= v123)
    {
      v52 = (char *)v121;
      v53 = (v122 - (_BYTE *)v121) >> 3;
      v54 = v53 + 1;
      if ((unint64_t)(v53 + 1) >> 61)
        goto LABEL_177;
      v55 = v123 - (_BYTE *)v121;
      if ((v123 - (_BYTE *)v121) >> 2 > v54)
        v54 = v55 >> 2;
      if ((unint64_t)v55 >= 0x7FFFFFFFFFFFFFF8)
        v56 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v56 = v54;
      if (v56)
        v56 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v56);
      else
        v57 = 0;
      v58 = (char *)(v56 + 8 * v53);
      *(_QWORD *)v58 = "hot_shard_doc_count";
      v51 = v58 + 8;
      if (v50 != v52)
      {
        do
        {
          v59 = *((_QWORD *)v50 - 1);
          v50 -= 8;
          *((_QWORD *)v58 - 1) = v59;
          v58 -= 8;
        }
        while (v50 != v52);
        v50 = (char *)v121;
      }
      v121 = v58;
      v123 = (char *)(v56 + 8 * v57);
      if (v50)
        operator delete(v50);
    }
    else
    {
      *(_QWORD *)v122 = "hot_shard_doc_count";
      v51 = v50 + 8;
    }
    v122 = v51;
    v60 = xpc_int64_create(*((_QWORD *)v1 + 4));
    v61 = v60;
    v62 = v119;
    if (v119 >= v120)
    {
      v64 = (char *)__p;
      v65 = (v119 - (_BYTE *)__p) >> 3;
      v66 = v65 + 1;
      if ((unint64_t)(v65 + 1) >> 61)
        goto LABEL_177;
      v67 = v120 - (_BYTE *)__p;
      if ((v120 - (_BYTE *)__p) >> 2 > v66)
        v66 = v67 >> 2;
      if ((unint64_t)v67 >= 0x7FFFFFFFFFFFFFF8)
        v68 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v68 = v66;
      if (v68)
        v68 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v68);
      else
        v69 = 0;
      v70 = (char *)(v68 + 8 * v65);
      *(_QWORD *)v70 = v61;
      v63 = v70 + 8;
      if (v62 != v64)
      {
        do
        {
          v71 = *((_QWORD *)v62 - 1);
          v62 -= 8;
          *((_QWORD *)v70 - 1) = v71;
          v70 -= 8;
        }
        while (v62 != v64);
        v62 = (char *)__p;
      }
      __p = v70;
      v120 = (char *)(v68 + 8 * v69);
      if (v62)
        operator delete(v62);
    }
    else
    {
      *(_QWORD *)v119 = v60;
      v63 = v62 + 8;
    }
    v119 = v63;
  }
  if (v1[56])
  {
    v72 = v122;
    if (v122 >= v123)
    {
      v74 = (char *)v121;
      v75 = (v122 - (_BYTE *)v121) >> 3;
      v76 = v75 + 1;
      if ((unint64_t)(v75 + 1) >> 61)
        goto LABEL_177;
      v77 = v123 - (_BYTE *)v121;
      if ((v123 - (_BYTE *)v121) >> 2 > v76)
        v76 = v77 >> 2;
      if ((unint64_t)v77 >= 0x7FFFFFFFFFFFFFF8)
        v78 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v78 = v76;
      if (v78)
        v78 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v78);
      else
        v79 = 0;
      v80 = (char *)(v78 + 8 * v75);
      *(_QWORD *)v80 = "cold_shard_doc_count";
      v73 = v80 + 8;
      if (v72 != v74)
      {
        do
        {
          v81 = *((_QWORD *)v72 - 1);
          v72 -= 8;
          *((_QWORD *)v80 - 1) = v81;
          v80 -= 8;
        }
        while (v72 != v74);
        v72 = (char *)v121;
      }
      v121 = v80;
      v123 = (char *)(v78 + 8 * v79);
      if (v72)
        operator delete(v72);
    }
    else
    {
      *(_QWORD *)v122 = "cold_shard_doc_count";
      v73 = v72 + 8;
    }
    v122 = v73;
    v82 = xpc_int64_create(*((_QWORD *)v1 + 6));
    v83 = v82;
    v84 = v119;
    if (v119 >= v120)
    {
      v86 = (char *)__p;
      v87 = (v119 - (_BYTE *)__p) >> 3;
      v88 = v87 + 1;
      if ((unint64_t)(v87 + 1) >> 61)
        goto LABEL_177;
      v89 = v120 - (_BYTE *)__p;
      if ((v120 - (_BYTE *)__p) >> 2 > v88)
        v88 = v89 >> 2;
      if ((unint64_t)v89 >= 0x7FFFFFFFFFFFFFF8)
        v90 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v90 = v88;
      if (v90)
        v90 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v90);
      else
        v91 = 0;
      v92 = (char *)(v90 + 8 * v87);
      *(_QWORD *)v92 = v83;
      v85 = v92 + 8;
      if (v84 != v86)
      {
        do
        {
          v93 = *((_QWORD *)v84 - 1);
          v84 -= 8;
          *((_QWORD *)v92 - 1) = v93;
          v92 -= 8;
        }
        while (v84 != v86);
        v84 = (char *)__p;
      }
      __p = v92;
      v120 = (char *)(v90 + 8 * v91);
      if (v84)
        operator delete(v84);
    }
    else
    {
      *(_QWORD *)v119 = v82;
      v85 = v84 + 8;
    }
    v119 = v85;
  }
  if (!v1[68])
    goto LABEL_172;
  v94 = v122;
  if (v122 >= v123)
  {
    v96 = (char *)v121;
    v97 = (v122 - (_BYTE *)v121) >> 3;
    v98 = v97 + 1;
    if ((unint64_t)(v97 + 1) >> 61)
      goto LABEL_177;
    v99 = v123 - (_BYTE *)v121;
    if ((v123 - (_BYTE *)v121) >> 2 > v98)
      v98 = v99 >> 2;
    if ((unint64_t)v99 >= 0x7FFFFFFFFFFFFFF8)
      v100 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v100 = v98;
    if (v100)
      v100 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v100);
    else
      v101 = 0;
    v102 = (char *)(v100 + 8 * v97);
    *(_QWORD *)v102 = "elapsed_ms";
    v95 = v102 + 8;
    if (v94 != v96)
    {
      do
      {
        v103 = *((_QWORD *)v94 - 1);
        v94 -= 8;
        *((_QWORD *)v102 - 1) = v103;
        v102 -= 8;
      }
      while (v94 != v96);
      v94 = (char *)v121;
    }
    v121 = v102;
    v123 = (char *)(v100 + 8 * v101);
    if (v94)
      operator delete(v94);
  }
  else
  {
    *(_QWORD *)v122 = "elapsed_ms";
    v95 = v94 + 8;
  }
  v122 = v95;
  v104 = xpc_double_create(*((float *)v1 + 16));
  v105 = v104;
  v106 = v119;
  if (v119 >= v120)
  {
    v108 = (char *)__p;
    v109 = (v119 - (_BYTE *)__p) >> 3;
    v110 = v109 + 1;
    if (!((unint64_t)(v109 + 1) >> 61))
    {
      v111 = v120 - (_BYTE *)__p;
      if ((v120 - (_BYTE *)__p) >> 2 > v110)
        v110 = v111 >> 2;
      if ((unint64_t)v111 >= 0x7FFFFFFFFFFFFFF8)
        v112 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v112 = v110;
      if (v112)
        v112 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v112);
      else
        v113 = 0;
      v114 = (char *)(v112 + 8 * v109);
      *(_QWORD *)v114 = v105;
      v107 = v114 + 8;
      if (v106 != v108)
      {
        do
        {
          v115 = *((_QWORD *)v106 - 1);
          v106 -= 8;
          *((_QWORD *)v114 - 1) = v115;
          v114 -= 8;
        }
        while (v106 != v108);
        v106 = (char *)__p;
      }
      __p = v114;
      v120 = (char *)(v112 + 8 * v113);
      if (v106)
        operator delete(v106);
      goto LABEL_171;
    }
LABEL_177:
    abort();
  }
  *(_QWORD *)v119 = v104;
  v107 = v106 + 8;
LABEL_171:
  v119 = v107;
LABEL_172:
  if (__p)
    operator delete(__p);
  if (v121)
    operator delete(v121);
  return v116;
}

uint64_t __copy_helper_block_8_32c47_ZTSNSt3__110shared_ptrIN9analytics8GetEventEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void __destroy_helper_block_8_32c47_ZTSNSt3__110shared_ptrIN9analytics8GetEventEEE(uint64_t a1)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v3;

  v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

xpc_object_t analytics::`anonymous namespace'::to_dictionary(uint64_t a1, xpc_object_t **a2)
{
  const char *const *v4;
  size_t v6;
  xpc_object_t *v7;
  xpc_object_t v9;
  void **v10;
  void **v11;
  void *v12;

  v4 = *(const char *const **)a1;
  v6 = (uint64_t)(*(_QWORD *)(a1 + 8) - (_QWORD)v4) >> 3;
  v7 = *a2;
  if (v6 != a2[1] - v7)
    __assert_rtn("to_dictionary", "Analytics.cpp", 22, "keys.size() == values.size()");
  v9 = xpc_dictionary_create(v4, v7, v6);
  v10 = *a2;
  v11 = a2[1];
  if (*a2 != v11)
  {
    do
    {
      v12 = *v10++;
      xpc_release(v12);
    }
    while (v10 != v11);
    v10 = *a2;
  }
  *(_QWORD *)(a1 + 8) = *(_QWORD *)a1;
  a2[1] = v10;
  return v9;
}

void std::__shared_ptr_pointer<analytics::GetEvent  *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BCCB06A4);
}

uint64_t std::__shared_ptr_pointer<analytics::GetEvent  *>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    JUMPOUT(0x1BCCB06A4);
  return result;
}

void std::__shared_ptr_emplace<analytics::`anonymous namespace'::CoreAnalyticsLogger<analytics::GetEvent>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6E2ACC0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<analytics::`anonymous namespace'::CoreAnalyticsLogger<analytics::GetEvent>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6E2ACC0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BCCB06A4);
}

uint64_t std::__shared_ptr_emplace<analytics::`anonymous namespace'::CoreAnalyticsLogger<analytics::GetEvent>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

_QWORD *std::__function::__func<analytics::SampledLogger<analytics::PutEvent>::startAsync(void)::{lambda(void)#1},std::allocator<analytics::SampledLogger<analytics::PutEvent>::startAsync(void)::{lambda(void)#1}>,void ()(void)>::~__func(_QWORD *a1)
{
  std::__shared_weak_count *v2;

  *a1 = &off_1E6E2AC08;
  v2 = (std::__shared_weak_count *)a1[2];
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  return a1;
}

void std::__function::__func<analytics::SampledLogger<analytics::PutEvent>::startAsync(void)::{lambda(void)#1},std::allocator<analytics::SampledLogger<analytics::PutEvent>::startAsync(void)::{lambda(void)#1}>,void ()(void)>::~__func(_QWORD *a1)
{
  std::__shared_weak_count *v1;

  *a1 = &off_1E6E2AC08;
  v1 = (std::__shared_weak_count *)a1[2];
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
  JUMPOUT(0x1BCCB06A4);
}

_QWORD *std::__function::__func<analytics::SampledLogger<analytics::PutEvent>::startAsync(void)::{lambda(void)#1},std::allocator<analytics::SampledLogger<analytics::PutEvent>::startAsync(void)::{lambda(void)#1}>,void ()(void)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;

  result = operator new(0x18uLL);
  v4 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16);
  *result = &off_1E6E2AC08;
  result[1] = v4;
  result[2] = v3;
  if (v3)
  {
    v5 = (unint64_t *)(v3 + 16);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  return result;
}

uint64_t std::__function::__func<analytics::SampledLogger<analytics::PutEvent>::startAsync(void)::{lambda(void)#1},std::allocator<analytics::SampledLogger<analytics::PutEvent>::startAsync(void)::{lambda(void)#1}>,void ()(void)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;

  v3 = *(_QWORD *)(result + 8);
  v2 = *(_QWORD *)(result + 16);
  *a2 = &off_1E6E2AC08;
  a2[1] = v3;
  a2[2] = v2;
  if (v2)
  {
    v4 = (unint64_t *)(v2 + 16);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  return result;
}

void std::__function::__func<analytics::SampledLogger<analytics::PutEvent>::startAsync(void)::{lambda(void)#1},std::allocator<analytics::SampledLogger<analytics::PutEvent>::startAsync(void)::{lambda(void)#1}>,void ()(void)>::destroy(uint64_t a1)
{
  std::__shared_weak_count *v1;

  v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
}

void std::__function::__func<analytics::SampledLogger<analytics::PutEvent>::startAsync(void)::{lambda(void)#1},std::allocator<analytics::SampledLogger<analytics::PutEvent>::startAsync(void)::{lambda(void)#1}>,void ()(void)>::destroy_deallocate(_QWORD *__p)
{
  std::__shared_weak_count *v2;

  v2 = (std::__shared_weak_count *)__p[2];
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  operator delete(__p);
}

void std::__function::__func<analytics::SampledLogger<analytics::PutEvent>::startAsync(void)::{lambda(void)#1},std::allocator<analytics::SampledLogger<analytics::PutEvent>::startAsync(void)::{lambda(void)#1}>,void ()(void)>::operator()(uint64_t a1)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  uint64_t *i;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  __int128 v12;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;
  void **v16;

  v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      v4 = v3;
      v5 = *(_QWORD *)(a1 + 8);
      if (v5)
      {
        std::mutex::lock((std::mutex *)(v5 + 88));
        v14 = *(_OWORD *)(v5 + 56);
        v12 = v14;
        v15 = *(_QWORD *)(v5 + 72);
        *(_OWORD *)(v5 + 72) = 0u;
        *(_OWORD *)(v5 + 56) = 0u;
        std::mutex::unlock((std::mutex *)(v5 + 88));
        for (i = (uint64_t *)v12; i != *((uint64_t **)&v12 + 1); ++i)
        {
          v7 = *(_QWORD *)(v5 + 32);
          v8 = *i;
          *i = 0;
          v13 = v8;
          (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v7 + 16))(v7, &v13);
          v9 = v13;
          v13 = 0;
          if (v9)
            MEMORY[0x1BCCB06A4](v9, 0x1000C4022EED179);
        }
        v16 = (void **)&v14;
        std::vector<std::unique_ptr<analytics::PutEvent>>::__destroy_vector::operator()[abi:nn180100](&v16);
      }
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v11 = __ldaxr(p_shared_owners);
      while (__stlxr(v11 - 1, p_shared_owners));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

void analytics::`anonymous namespace'::CoreAnalyticsLogger<analytics::PutEvent>::~CoreAnalyticsLogger()
{
  JUMPOUT(0x1BCCB06A4);
}

void analytics::`anonymous namespace'::CoreAnalyticsLogger<analytics::PutEvent>::logEvent(uint64_t a1, std::__shared_weak_count_vtbl **a2)
{
  std::__shared_weak_count *v3;
  std::__shared_weak_count_vtbl *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  int v7;
  int v8;
  NSObject *v9;
  os_log_type_t v10;
  _BOOL4 v11;
  const char *v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  uint8_t buf[4];
  const char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (*a2)
  {
    v3 = (std::__shared_weak_count *)operator new();
    v4 = *a2;
    v3->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6E2AEB8;
    v3->__shared_owners_ = 0;
    v3->__shared_weak_owners_ = 0;
    v3[1].__vftable = v4;
  }
  else
  {
    v3 = 0;
  }
  *a2 = 0;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  v7 = analytics_send_event_lazy();
  v8 = *__error();
  v9 = _SILogForLogForCategory(8);
  v10 = 2 * (dword_1EF19FCAC < 4);
  v11 = os_log_type_enabled(v9, v10);
  if (v7)
  {
    if (v11)
    {
      *(_DWORD *)buf = 136315138;
      v18 = "com.apple.spotlight.textstore.Put";
      v12 = "successfully logged event: %s";
LABEL_12:
      _os_log_impl(&dword_1B8270000, v9, v10, v12, buf, 0xCu);
    }
  }
  else if (v11)
  {
    *(_DWORD *)buf = 136315138;
    v18 = "com.apple.spotlight.textstore.Put";
    v12 = "event logging disabled: %s";
    goto LABEL_12;
  }
  *__error() = v8;
  if (v3)
  {
    v13 = (unint64_t *)&v3->__shared_owners_;
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  if (v3)
  {
    v15 = (unint64_t *)&v3->__shared_owners_;
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

xpc_object_t ___ZN9analytics12_GLOBAL__N_119CoreAnalyticsLoggerINS_8PutEventEE8logEventENSt3__110unique_ptrIS2_NS4_14default_deleteIS2_EEEE_block_invoke(uint64_t a1)
{
  unsigned __int8 *v1;
  char *v2;
  char *v3;
  int v4;
  xpc_object_t v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  char *v13;
  char *v14;
  uint64_t v15;
  xpc_object_t v16;
  xpc_object_t v17;
  char *v18;
  char *v19;
  char *v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  char *v28;
  char *v29;
  char *v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  char *v36;
  uint64_t v37;
  xpc_object_t v38;
  xpc_object_t v39;
  char *v40;
  char *v41;
  char *v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  char *v48;
  uint64_t v49;
  char *v50;
  char *v51;
  char *v52;
  uint64_t v53;
  unint64_t v54;
  uint64_t v55;
  unint64_t v56;
  uint64_t v57;
  char *v58;
  uint64_t v59;
  xpc_object_t v60;
  xpc_object_t v61;
  char *v62;
  char *v63;
  char *v64;
  uint64_t v65;
  unint64_t v66;
  uint64_t v67;
  unint64_t v68;
  uint64_t v69;
  char *v70;
  uint64_t v71;
  xpc_object_t v72;
  void *__p;
  char *v75;
  char *v76;
  void *v77;
  char *v78;
  char *v79;

  v1 = *(unsigned __int8 **)(a1 + 32);
  v77 = 0;
  v78 = 0;
  v79 = 0;
  __p = 0;
  v75 = 0;
  v76 = 0;
  if (v1[1])
  {
    v2 = (char *)operator new(8uLL);
    *(_QWORD *)v2 = "success";
    v3 = v2 + 8;
    v78 = v2 + 8;
    v79 = v2 + 8;
    v4 = *v1;
    v77 = v2;
    v5 = xpc_BOOL_create(v4 != 0);
    v6 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(1uLL);
    *(_QWORD *)v6 = v5;
    __p = v6;
    v75 = v6 + 8;
    v76 = &v6[8 * v7];
  }
  else
  {
    v2 = 0;
    v3 = 0;
  }
  if (v1[8])
  {
    v8 = v3 - v2;
    v9 = (v3 - v2) >> 3;
    v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 61)
      goto LABEL_109;
    if (v8 >> 2 > v10)
      v10 = v8 >> 2;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    if (v11)
      v11 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v11);
    else
      v12 = 0;
    v13 = (char *)(v11 + 8 * v9);
    *(_QWORD *)v13 = "error_code";
    v14 = v13 + 8;
    if (v3 != v2)
    {
      do
      {
        v15 = *((_QWORD *)v3 - 1);
        v3 -= 8;
        *((_QWORD *)v13 - 1) = v15;
        v13 -= 8;
      }
      while (v3 != v2);
      v2 = (char *)v77;
    }
    v77 = v13;
    v79 = (char *)(v11 + 8 * v12);
    if (v2)
      operator delete(v2);
    v78 = v14;
    v16 = xpc_int64_create(*((int *)v1 + 1));
    v17 = v16;
    v18 = v75;
    if (v75 >= v76)
    {
      v20 = (char *)__p;
      v21 = (v75 - (_BYTE *)__p) >> 3;
      v22 = v21 + 1;
      if ((unint64_t)(v21 + 1) >> 61)
        goto LABEL_109;
      v23 = v76 - (_BYTE *)__p;
      if ((v76 - (_BYTE *)__p) >> 2 > v22)
        v22 = v23 >> 2;
      if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8)
        v24 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v24 = v22;
      if (v24)
        v24 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v24);
      else
        v25 = 0;
      v26 = (char *)(v24 + 8 * v21);
      *(_QWORD *)v26 = v17;
      v19 = v26 + 8;
      if (v18 != v20)
      {
        do
        {
          v27 = *((_QWORD *)v18 - 1);
          v18 -= 8;
          *((_QWORD *)v26 - 1) = v27;
          v26 -= 8;
        }
        while (v18 != v20);
        v18 = (char *)__p;
      }
      __p = v26;
      v76 = (char *)(v24 + 8 * v25);
      if (v18)
        operator delete(v18);
    }
    else
    {
      *(_QWORD *)v75 = v16;
      v19 = v18 + 8;
    }
    v75 = v19;
  }
  if (v1[24])
  {
    v28 = v78;
    if (v78 >= v79)
    {
      v30 = (char *)v77;
      v31 = (v78 - (_BYTE *)v77) >> 3;
      v32 = v31 + 1;
      if ((unint64_t)(v31 + 1) >> 61)
        goto LABEL_109;
      v33 = v79 - (_BYTE *)v77;
      if ((v79 - (_BYTE *)v77) >> 2 > v32)
        v32 = v33 >> 2;
      if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFF8)
        v34 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v34 = v32;
      if (v34)
        v34 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v34);
      else
        v35 = 0;
      v36 = (char *)(v34 + 8 * v31);
      *(_QWORD *)v36 = "doc_size";
      v29 = v36 + 8;
      if (v28 != v30)
      {
        do
        {
          v37 = *((_QWORD *)v28 - 1);
          v28 -= 8;
          *((_QWORD *)v36 - 1) = v37;
          v36 -= 8;
        }
        while (v28 != v30);
        v28 = (char *)v77;
      }
      v77 = v36;
      v79 = (char *)(v34 + 8 * v35);
      if (v28)
        operator delete(v28);
    }
    else
    {
      *(_QWORD *)v78 = "doc_size";
      v29 = v28 + 8;
    }
    v78 = v29;
    v38 = xpc_int64_create(*((_QWORD *)v1 + 2));
    v39 = v38;
    v40 = v75;
    if (v75 >= v76)
    {
      v42 = (char *)__p;
      v43 = (v75 - (_BYTE *)__p) >> 3;
      v44 = v43 + 1;
      if ((unint64_t)(v43 + 1) >> 61)
        goto LABEL_109;
      v45 = v76 - (_BYTE *)__p;
      if ((v76 - (_BYTE *)__p) >> 2 > v44)
        v44 = v45 >> 2;
      if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFF8)
        v46 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v46 = v44;
      if (v46)
        v46 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v46);
      else
        v47 = 0;
      v48 = (char *)(v46 + 8 * v43);
      *(_QWORD *)v48 = v39;
      v41 = v48 + 8;
      if (v40 != v42)
      {
        do
        {
          v49 = *((_QWORD *)v40 - 1);
          v40 -= 8;
          *((_QWORD *)v48 - 1) = v49;
          v48 -= 8;
        }
        while (v40 != v42);
        v40 = (char *)__p;
      }
      __p = v48;
      v76 = (char *)(v46 + 8 * v47);
      if (v40)
        operator delete(v40);
    }
    else
    {
      *(_QWORD *)v75 = v38;
      v41 = v40 + 8;
    }
    v75 = v41;
  }
  if (!v1[36])
    goto LABEL_104;
  v50 = v78;
  if (v78 >= v79)
  {
    v52 = (char *)v77;
    v53 = (v78 - (_BYTE *)v77) >> 3;
    v54 = v53 + 1;
    if ((unint64_t)(v53 + 1) >> 61)
      goto LABEL_109;
    v55 = v79 - (_BYTE *)v77;
    if ((v79 - (_BYTE *)v77) >> 2 > v54)
      v54 = v55 >> 2;
    if ((unint64_t)v55 >= 0x7FFFFFFFFFFFFFF8)
      v56 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v56 = v54;
    if (v56)
      v56 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v56);
    else
      v57 = 0;
    v58 = (char *)(v56 + 8 * v53);
    *(_QWORD *)v58 = "elapsed_ms";
    v51 = v58 + 8;
    if (v50 != v52)
    {
      do
      {
        v59 = *((_QWORD *)v50 - 1);
        v50 -= 8;
        *((_QWORD *)v58 - 1) = v59;
        v58 -= 8;
      }
      while (v50 != v52);
      v50 = (char *)v77;
    }
    v77 = v58;
    v79 = (char *)(v56 + 8 * v57);
    if (v50)
      operator delete(v50);
  }
  else
  {
    *(_QWORD *)v78 = "elapsed_ms";
    v51 = v50 + 8;
  }
  v78 = v51;
  v60 = xpc_double_create(*((float *)v1 + 8));
  v61 = v60;
  v62 = v75;
  if (v75 >= v76)
  {
    v64 = (char *)__p;
    v65 = (v75 - (_BYTE *)__p) >> 3;
    v66 = v65 + 1;
    if (!((unint64_t)(v65 + 1) >> 61))
    {
      v67 = v76 - (_BYTE *)__p;
      if ((v76 - (_BYTE *)__p) >> 2 > v66)
        v66 = v67 >> 2;
      if ((unint64_t)v67 >= 0x7FFFFFFFFFFFFFF8)
        v68 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v68 = v66;
      if (v68)
        v68 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v68);
      else
        v69 = 0;
      v70 = (char *)(v68 + 8 * v65);
      *(_QWORD *)v70 = v61;
      v63 = v70 + 8;
      if (v62 != v64)
      {
        do
        {
          v71 = *((_QWORD *)v62 - 1);
          v62 -= 8;
          *((_QWORD *)v70 - 1) = v71;
          v70 -= 8;
        }
        while (v62 != v64);
        v62 = (char *)__p;
      }
      __p = v70;
      v76 = (char *)(v68 + 8 * v69);
      if (v62)
        operator delete(v62);
      goto LABEL_103;
    }
LABEL_109:
    abort();
  }
  *(_QWORD *)v75 = v60;
  v63 = v62 + 8;
LABEL_103:
  v75 = v63;
LABEL_104:
  if (__p)
    operator delete(__p);
  if (v77)
    operator delete(v77);
  return v72;
}

