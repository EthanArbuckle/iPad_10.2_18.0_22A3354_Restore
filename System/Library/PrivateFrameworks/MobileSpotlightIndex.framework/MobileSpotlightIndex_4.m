uint64_t __copy_helper_block_8_32c47_ZTSNSt3__110shared_ptrIN9analytics8PutEventEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void __destroy_helper_block_8_32c47_ZTSNSt3__110shared_ptrIN9analytics8PutEventEEE(uint64_t a1)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v3;

  v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

void std::__shared_ptr_pointer<analytics::PutEvent  *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BCCB06A4);
}

uint64_t std::__shared_ptr_pointer<analytics::PutEvent  *>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    JUMPOUT(0x1BCCB06A4);
  return result;
}

void std::__shared_ptr_emplace<analytics::`anonymous namespace'::CoreAnalyticsLogger<analytics::PutEvent>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6E2ACF8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<analytics::`anonymous namespace'::CoreAnalyticsLogger<analytics::PutEvent>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6E2ACF8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BCCB06A4);
}

uint64_t std::__shared_ptr_emplace<analytics::`anonymous namespace'::CoreAnalyticsLogger<analytics::PutEvent>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

_QWORD *std::__function::__func<analytics::SampledLogger<analytics::DeleteEvent>::startAsync(void)::{lambda(void)#1},std::allocator<analytics::SampledLogger<analytics::DeleteEvent>::startAsync(void)::{lambda(void)#1}>,void ()(void)>::~__func(_QWORD *a1)
{
  std::__shared_weak_count *v2;

  *a1 = &off_1E6E2AB78;
  v2 = (std::__shared_weak_count *)a1[2];
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  return a1;
}

void std::__function::__func<analytics::SampledLogger<analytics::DeleteEvent>::startAsync(void)::{lambda(void)#1},std::allocator<analytics::SampledLogger<analytics::DeleteEvent>::startAsync(void)::{lambda(void)#1}>,void ()(void)>::~__func(_QWORD *a1)
{
  std::__shared_weak_count *v1;

  *a1 = &off_1E6E2AB78;
  v1 = (std::__shared_weak_count *)a1[2];
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
  JUMPOUT(0x1BCCB06A4);
}

_QWORD *std::__function::__func<analytics::SampledLogger<analytics::DeleteEvent>::startAsync(void)::{lambda(void)#1},std::allocator<analytics::SampledLogger<analytics::DeleteEvent>::startAsync(void)::{lambda(void)#1}>,void ()(void)>::__clone(uint64_t a1)
{
  _QWORD *result;
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;

  result = operator new(0x18uLL);
  v4 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16);
  *result = &off_1E6E2AB78;
  result[1] = v4;
  result[2] = v3;
  if (v3)
  {
    v5 = (unint64_t *)(v3 + 16);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  return result;
}

uint64_t std::__function::__func<analytics::SampledLogger<analytics::DeleteEvent>::startAsync(void)::{lambda(void)#1},std::allocator<analytics::SampledLogger<analytics::DeleteEvent>::startAsync(void)::{lambda(void)#1}>,void ()(void)>::__clone(uint64_t result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t *v4;
  unint64_t v5;

  v3 = *(_QWORD *)(result + 8);
  v2 = *(_QWORD *)(result + 16);
  *a2 = &off_1E6E2AB78;
  a2[1] = v3;
  a2[2] = v2;
  if (v2)
  {
    v4 = (unint64_t *)(v2 + 16);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  return result;
}

void std::__function::__func<analytics::SampledLogger<analytics::DeleteEvent>::startAsync(void)::{lambda(void)#1},std::allocator<analytics::SampledLogger<analytics::DeleteEvent>::startAsync(void)::{lambda(void)#1}>,void ()(void)>::destroy(uint64_t a1)
{
  std::__shared_weak_count *v1;

  v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1)
    std::__shared_weak_count::__release_weak(v1);
}

void std::__function::__func<analytics::SampledLogger<analytics::DeleteEvent>::startAsync(void)::{lambda(void)#1},std::allocator<analytics::SampledLogger<analytics::DeleteEvent>::startAsync(void)::{lambda(void)#1}>,void ()(void)>::destroy_deallocate(_QWORD *__p)
{
  std::__shared_weak_count *v2;

  v2 = (std::__shared_weak_count *)__p[2];
  if (v2)
    std::__shared_weak_count::__release_weak(v2);
  operator delete(__p);
}

void std::__function::__func<analytics::SampledLogger<analytics::DeleteEvent>::startAsync(void)::{lambda(void)#1},std::allocator<analytics::SampledLogger<analytics::DeleteEvent>::startAsync(void)::{lambda(void)#1}>,void ()(void)>::operator()(uint64_t a1)
{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  uint64_t *i;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  __int128 v12;
  uint64_t v13;
  __int128 v14;
  uint64_t v15;
  void **v16;

  v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      v4 = v3;
      v5 = *(_QWORD *)(a1 + 8);
      if (v5)
      {
        std::mutex::lock((std::mutex *)(v5 + 88));
        v14 = *(_OWORD *)(v5 + 56);
        v12 = v14;
        v15 = *(_QWORD *)(v5 + 72);
        *(_OWORD *)(v5 + 72) = 0u;
        *(_OWORD *)(v5 + 56) = 0u;
        std::mutex::unlock((std::mutex *)(v5 + 88));
        for (i = (uint64_t *)v12; i != *((uint64_t **)&v12 + 1); ++i)
        {
          v7 = *(_QWORD *)(v5 + 32);
          v8 = *i;
          *i = 0;
          v13 = v8;
          (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v7 + 16))(v7, &v13);
          v9 = v13;
          v13 = 0;
          if (v9)
            MEMORY[0x1BCCB06A4](v9, 0x1000C4073594BB7);
        }
        v16 = (void **)&v14;
        std::vector<std::unique_ptr<analytics::GetEvent>>::__destroy_vector::operator()[abi:nn180100](&v16);
      }
      p_shared_owners = (unint64_t *)&v4->__shared_owners_;
      do
        v11 = __ldaxr(p_shared_owners);
      while (__stlxr(v11 - 1, p_shared_owners));
      if (!v11)
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

void analytics::`anonymous namespace'::CoreAnalyticsLogger<analytics::DeleteEvent>::~CoreAnalyticsLogger()
{
  JUMPOUT(0x1BCCB06A4);
}

void analytics::`anonymous namespace'::CoreAnalyticsLogger<analytics::DeleteEvent>::logEvent(uint64_t a1, std::__shared_weak_count_vtbl **a2)
{
  std::__shared_weak_count *v3;
  std::__shared_weak_count_vtbl *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  int v7;
  int v8;
  NSObject *v9;
  os_log_type_t v10;
  _BOOL4 v11;
  const char *v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  uint8_t buf[4];
  const char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (*a2)
  {
    v3 = (std::__shared_weak_count *)operator new();
    v4 = *a2;
    v3->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6E2AD68;
    v3->__shared_owners_ = 0;
    v3->__shared_weak_owners_ = 0;
    v3[1].__vftable = v4;
  }
  else
  {
    v3 = 0;
  }
  *a2 = 0;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  v7 = analytics_send_event_lazy();
  v8 = *__error();
  v9 = _SILogForLogForCategory(8);
  v10 = 2 * (dword_1EF19FCAC < 4);
  v11 = os_log_type_enabled(v9, v10);
  if (v7)
  {
    if (v11)
    {
      *(_DWORD *)buf = 136315138;
      v18 = "com.apple.spotlight.textstore.Delete";
      v12 = "successfully logged event: %s";
LABEL_12:
      _os_log_impl(&dword_1B8270000, v9, v10, v12, buf, 0xCu);
    }
  }
  else if (v11)
  {
    *(_DWORD *)buf = 136315138;
    v18 = "com.apple.spotlight.textstore.Delete";
    v12 = "event logging disabled: %s";
    goto LABEL_12;
  }
  *__error() = v8;
  if (v3)
  {
    v13 = (unint64_t *)&v3->__shared_owners_;
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  if (v3)
  {
    v15 = (unint64_t *)&v3->__shared_owners_;
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

xpc_object_t ___ZN9analytics12_GLOBAL__N_119CoreAnalyticsLoggerINS_11DeleteEventEE8logEventENSt3__110unique_ptrIS2_NS4_14default_deleteIS2_EEEE_block_invoke(uint64_t a1)
{
  unsigned __int8 *v1;
  char *v2;
  char *v3;
  int v4;
  xpc_object_t v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  char *v13;
  char *v14;
  uint64_t v15;
  xpc_object_t v16;
  xpc_object_t v17;
  char *v18;
  char *v19;
  char *v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  char *v28;
  char *v29;
  char *v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  char *v36;
  uint64_t v37;
  xpc_object_t v38;
  xpc_object_t v39;
  char *v40;
  char *v41;
  char *v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  char *v48;
  uint64_t v49;
  char *v50;
  char *v51;
  char *v52;
  uint64_t v53;
  unint64_t v54;
  uint64_t v55;
  unint64_t v56;
  uint64_t v57;
  char *v58;
  uint64_t v59;
  xpc_object_t v60;
  xpc_object_t v61;
  char *v62;
  char *v63;
  char *v64;
  uint64_t v65;
  unint64_t v66;
  uint64_t v67;
  unint64_t v68;
  uint64_t v69;
  char *v70;
  uint64_t v71;
  char *v72;
  char *v73;
  char *v74;
  uint64_t v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  char *v80;
  uint64_t v81;
  xpc_object_t v82;
  xpc_object_t v83;
  char *v84;
  char *v85;
  char *v86;
  uint64_t v87;
  unint64_t v88;
  uint64_t v89;
  unint64_t v90;
  uint64_t v91;
  char *v92;
  uint64_t v93;
  char *v94;
  char *v95;
  char *v96;
  uint64_t v97;
  unint64_t v98;
  uint64_t v99;
  unint64_t v100;
  uint64_t v101;
  char *v102;
  uint64_t v103;
  xpc_object_t v104;
  xpc_object_t v105;
  char *v106;
  char *v107;
  char *v108;
  uint64_t v109;
  unint64_t v110;
  uint64_t v111;
  unint64_t v112;
  uint64_t v113;
  char *v114;
  uint64_t v115;
  xpc_object_t v116;
  void *__p;
  char *v119;
  char *v120;
  void *v121;
  char *v122;
  char *v123;

  v1 = *(unsigned __int8 **)(a1 + 32);
  v121 = 0;
  v122 = 0;
  v123 = 0;
  __p = 0;
  v119 = 0;
  v120 = 0;
  if (v1[1])
  {
    v2 = (char *)operator new(8uLL);
    *(_QWORD *)v2 = "success";
    v3 = v2 + 8;
    v122 = v2 + 8;
    v123 = v2 + 8;
    v4 = *v1;
    v121 = v2;
    v5 = xpc_BOOL_create(v4 != 0);
    v6 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(1uLL);
    *(_QWORD *)v6 = v5;
    __p = v6;
    v119 = v6 + 8;
    v120 = &v6[8 * v7];
  }
  else
  {
    v2 = 0;
    v3 = 0;
  }
  if (v1[8])
  {
    v8 = v3 - v2;
    v9 = (v3 - v2) >> 3;
    v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 61)
      goto LABEL_177;
    if (v8 >> 2 > v10)
      v10 = v8 >> 2;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    if (v11)
      v11 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v11);
    else
      v12 = 0;
    v13 = (char *)(v11 + 8 * v9);
    *(_QWORD *)v13 = "error_code";
    v14 = v13 + 8;
    if (v3 != v2)
    {
      do
      {
        v15 = *((_QWORD *)v3 - 1);
        v3 -= 8;
        *((_QWORD *)v13 - 1) = v15;
        v13 -= 8;
      }
      while (v3 != v2);
      v2 = (char *)v121;
    }
    v121 = v13;
    v123 = (char *)(v11 + 8 * v12);
    if (v2)
      operator delete(v2);
    v122 = v14;
    v16 = xpc_int64_create(*((int *)v1 + 1));
    v17 = v16;
    v18 = v119;
    if (v119 >= v120)
    {
      v20 = (char *)__p;
      v21 = (v119 - (_BYTE *)__p) >> 3;
      v22 = v21 + 1;
      if ((unint64_t)(v21 + 1) >> 61)
        goto LABEL_177;
      v23 = v120 - (_BYTE *)__p;
      if ((v120 - (_BYTE *)__p) >> 2 > v22)
        v22 = v23 >> 2;
      if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8)
        v24 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v24 = v22;
      if (v24)
        v24 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v24);
      else
        v25 = 0;
      v26 = (char *)(v24 + 8 * v21);
      *(_QWORD *)v26 = v17;
      v19 = v26 + 8;
      if (v18 != v20)
      {
        do
        {
          v27 = *((_QWORD *)v18 - 1);
          v18 -= 8;
          *((_QWORD *)v26 - 1) = v27;
          v26 -= 8;
        }
        while (v18 != v20);
        v18 = (char *)__p;
      }
      __p = v26;
      v120 = (char *)(v24 + 8 * v25);
      if (v18)
        operator delete(v18);
    }
    else
    {
      *(_QWORD *)v119 = v16;
      v19 = v18 + 8;
    }
    v119 = v19;
  }
  if (v1[24])
  {
    v28 = v122;
    if (v122 >= v123)
    {
      v30 = (char *)v121;
      v31 = (v122 - (_BYTE *)v121) >> 3;
      v32 = v31 + 1;
      if ((unint64_t)(v31 + 1) >> 61)
        goto LABEL_177;
      v33 = v123 - (_BYTE *)v121;
      if ((v123 - (_BYTE *)v121) >> 2 > v32)
        v32 = v33 >> 2;
      if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFF8)
        v34 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v34 = v32;
      if (v34)
        v34 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v34);
      else
        v35 = 0;
      v36 = (char *)(v34 + 8 * v31);
      *(_QWORD *)v36 = "requested_doc_count";
      v29 = v36 + 8;
      if (v28 != v30)
      {
        do
        {
          v37 = *((_QWORD *)v28 - 1);
          v28 -= 8;
          *((_QWORD *)v36 - 1) = v37;
          v36 -= 8;
        }
        while (v28 != v30);
        v28 = (char *)v121;
      }
      v121 = v36;
      v123 = (char *)(v34 + 8 * v35);
      if (v28)
        operator delete(v28);
    }
    else
    {
      *(_QWORD *)v122 = "requested_doc_count";
      v29 = v28 + 8;
    }
    v122 = v29;
    v38 = xpc_int64_create(*((_QWORD *)v1 + 2));
    v39 = v38;
    v40 = v119;
    if (v119 >= v120)
    {
      v42 = (char *)__p;
      v43 = (v119 - (_BYTE *)__p) >> 3;
      v44 = v43 + 1;
      if ((unint64_t)(v43 + 1) >> 61)
        goto LABEL_177;
      v45 = v120 - (_BYTE *)__p;
      if ((v120 - (_BYTE *)__p) >> 2 > v44)
        v44 = v45 >> 2;
      if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFF8)
        v46 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v46 = v44;
      if (v46)
        v46 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v46);
      else
        v47 = 0;
      v48 = (char *)(v46 + 8 * v43);
      *(_QWORD *)v48 = v39;
      v41 = v48 + 8;
      if (v40 != v42)
      {
        do
        {
          v49 = *((_QWORD *)v40 - 1);
          v40 -= 8;
          *((_QWORD *)v48 - 1) = v49;
          v48 -= 8;
        }
        while (v40 != v42);
        v40 = (char *)__p;
      }
      __p = v48;
      v120 = (char *)(v46 + 8 * v47);
      if (v40)
        operator delete(v40);
    }
    else
    {
      *(_QWORD *)v119 = v38;
      v41 = v40 + 8;
    }
    v119 = v41;
  }
  if (v1[40])
  {
    v50 = v122;
    if (v122 >= v123)
    {
      v52 = (char *)v121;
      v53 = (v122 - (_BYTE *)v121) >> 3;
      v54 = v53 + 1;
      if ((unint64_t)(v53 + 1) >> 61)
        goto LABEL_177;
      v55 = v123 - (_BYTE *)v121;
      if ((v123 - (_BYTE *)v121) >> 2 > v54)
        v54 = v55 >> 2;
      if ((unint64_t)v55 >= 0x7FFFFFFFFFFFFFF8)
        v56 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v56 = v54;
      if (v56)
        v56 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v56);
      else
        v57 = 0;
      v58 = (char *)(v56 + 8 * v53);
      *(_QWORD *)v58 = "hot_shard_doc_count";
      v51 = v58 + 8;
      if (v50 != v52)
      {
        do
        {
          v59 = *((_QWORD *)v50 - 1);
          v50 -= 8;
          *((_QWORD *)v58 - 1) = v59;
          v58 -= 8;
        }
        while (v50 != v52);
        v50 = (char *)v121;
      }
      v121 = v58;
      v123 = (char *)(v56 + 8 * v57);
      if (v50)
        operator delete(v50);
    }
    else
    {
      *(_QWORD *)v122 = "hot_shard_doc_count";
      v51 = v50 + 8;
    }
    v122 = v51;
    v60 = xpc_int64_create(*((_QWORD *)v1 + 4));
    v61 = v60;
    v62 = v119;
    if (v119 >= v120)
    {
      v64 = (char *)__p;
      v65 = (v119 - (_BYTE *)__p) >> 3;
      v66 = v65 + 1;
      if ((unint64_t)(v65 + 1) >> 61)
        goto LABEL_177;
      v67 = v120 - (_BYTE *)__p;
      if ((v120 - (_BYTE *)__p) >> 2 > v66)
        v66 = v67 >> 2;
      if ((unint64_t)v67 >= 0x7FFFFFFFFFFFFFF8)
        v68 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v68 = v66;
      if (v68)
        v68 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v68);
      else
        v69 = 0;
      v70 = (char *)(v68 + 8 * v65);
      *(_QWORD *)v70 = v61;
      v63 = v70 + 8;
      if (v62 != v64)
      {
        do
        {
          v71 = *((_QWORD *)v62 - 1);
          v62 -= 8;
          *((_QWORD *)v70 - 1) = v71;
          v70 -= 8;
        }
        while (v62 != v64);
        v62 = (char *)__p;
      }
      __p = v70;
      v120 = (char *)(v68 + 8 * v69);
      if (v62)
        operator delete(v62);
    }
    else
    {
      *(_QWORD *)v119 = v60;
      v63 = v62 + 8;
    }
    v119 = v63;
  }
  if (v1[56])
  {
    v72 = v122;
    if (v122 >= v123)
    {
      v74 = (char *)v121;
      v75 = (v122 - (_BYTE *)v121) >> 3;
      v76 = v75 + 1;
      if ((unint64_t)(v75 + 1) >> 61)
        goto LABEL_177;
      v77 = v123 - (_BYTE *)v121;
      if ((v123 - (_BYTE *)v121) >> 2 > v76)
        v76 = v77 >> 2;
      if ((unint64_t)v77 >= 0x7FFFFFFFFFFFFFF8)
        v78 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v78 = v76;
      if (v78)
        v78 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v78);
      else
        v79 = 0;
      v80 = (char *)(v78 + 8 * v75);
      *(_QWORD *)v80 = "cold_shard_doc_count";
      v73 = v80 + 8;
      if (v72 != v74)
      {
        do
        {
          v81 = *((_QWORD *)v72 - 1);
          v72 -= 8;
          *((_QWORD *)v80 - 1) = v81;
          v80 -= 8;
        }
        while (v72 != v74);
        v72 = (char *)v121;
      }
      v121 = v80;
      v123 = (char *)(v78 + 8 * v79);
      if (v72)
        operator delete(v72);
    }
    else
    {
      *(_QWORD *)v122 = "cold_shard_doc_count";
      v73 = v72 + 8;
    }
    v122 = v73;
    v82 = xpc_int64_create(*((_QWORD *)v1 + 6));
    v83 = v82;
    v84 = v119;
    if (v119 >= v120)
    {
      v86 = (char *)__p;
      v87 = (v119 - (_BYTE *)__p) >> 3;
      v88 = v87 + 1;
      if ((unint64_t)(v87 + 1) >> 61)
        goto LABEL_177;
      v89 = v120 - (_BYTE *)__p;
      if ((v120 - (_BYTE *)__p) >> 2 > v88)
        v88 = v89 >> 2;
      if ((unint64_t)v89 >= 0x7FFFFFFFFFFFFFF8)
        v90 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v90 = v88;
      if (v90)
        v90 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v90);
      else
        v91 = 0;
      v92 = (char *)(v90 + 8 * v87);
      *(_QWORD *)v92 = v83;
      v85 = v92 + 8;
      if (v84 != v86)
      {
        do
        {
          v93 = *((_QWORD *)v84 - 1);
          v84 -= 8;
          *((_QWORD *)v92 - 1) = v93;
          v92 -= 8;
        }
        while (v84 != v86);
        v84 = (char *)__p;
      }
      __p = v92;
      v120 = (char *)(v90 + 8 * v91);
      if (v84)
        operator delete(v84);
    }
    else
    {
      *(_QWORD *)v119 = v82;
      v85 = v84 + 8;
    }
    v119 = v85;
  }
  if (!v1[68])
    goto LABEL_172;
  v94 = v122;
  if (v122 >= v123)
  {
    v96 = (char *)v121;
    v97 = (v122 - (_BYTE *)v121) >> 3;
    v98 = v97 + 1;
    if ((unint64_t)(v97 + 1) >> 61)
      goto LABEL_177;
    v99 = v123 - (_BYTE *)v121;
    if ((v123 - (_BYTE *)v121) >> 2 > v98)
      v98 = v99 >> 2;
    if ((unint64_t)v99 >= 0x7FFFFFFFFFFFFFF8)
      v100 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v100 = v98;
    if (v100)
      v100 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v100);
    else
      v101 = 0;
    v102 = (char *)(v100 + 8 * v97);
    *(_QWORD *)v102 = "elapsed_ms";
    v95 = v102 + 8;
    if (v94 != v96)
    {
      do
      {
        v103 = *((_QWORD *)v94 - 1);
        v94 -= 8;
        *((_QWORD *)v102 - 1) = v103;
        v102 -= 8;
      }
      while (v94 != v96);
      v94 = (char *)v121;
    }
    v121 = v102;
    v123 = (char *)(v100 + 8 * v101);
    if (v94)
      operator delete(v94);
  }
  else
  {
    *(_QWORD *)v122 = "elapsed_ms";
    v95 = v94 + 8;
  }
  v122 = v95;
  v104 = xpc_double_create(*((float *)v1 + 16));
  v105 = v104;
  v106 = v119;
  if (v119 >= v120)
  {
    v108 = (char *)__p;
    v109 = (v119 - (_BYTE *)__p) >> 3;
    v110 = v109 + 1;
    if (!((unint64_t)(v109 + 1) >> 61))
    {
      v111 = v120 - (_BYTE *)__p;
      if ((v120 - (_BYTE *)__p) >> 2 > v110)
        v110 = v111 >> 2;
      if ((unint64_t)v111 >= 0x7FFFFFFFFFFFFFF8)
        v112 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v112 = v110;
      if (v112)
        v112 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v112);
      else
        v113 = 0;
      v114 = (char *)(v112 + 8 * v109);
      *(_QWORD *)v114 = v105;
      v107 = v114 + 8;
      if (v106 != v108)
      {
        do
        {
          v115 = *((_QWORD *)v106 - 1);
          v106 -= 8;
          *((_QWORD *)v114 - 1) = v115;
          v114 -= 8;
        }
        while (v106 != v108);
        v106 = (char *)__p;
      }
      __p = v114;
      v120 = (char *)(v112 + 8 * v113);
      if (v106)
        operator delete(v106);
      goto LABEL_171;
    }
LABEL_177:
    abort();
  }
  *(_QWORD *)v119 = v104;
  v107 = v106 + 8;
LABEL_171:
  v119 = v107;
LABEL_172:
  if (__p)
    operator delete(__p);
  if (v121)
    operator delete(v121);
  return v116;
}

uint64_t __copy_helper_block_8_32c51_ZTSNSt3__110shared_ptrIN9analytics11DeleteEventEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void __destroy_helper_block_8_32c51_ZTSNSt3__110shared_ptrIN9analytics11DeleteEventEEE(uint64_t a1)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v3;

  v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

void std::__shared_ptr_pointer<analytics::DeleteEvent  *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BCCB06A4);
}

uint64_t std::__shared_ptr_pointer<analytics::DeleteEvent  *>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    JUMPOUT(0x1BCCB06A4);
  return result;
}

void std::__shared_ptr_emplace<analytics::`anonymous namespace'::CoreAnalyticsLogger<analytics::DeleteEvent>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6E2AC50;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<analytics::`anonymous namespace'::CoreAnalyticsLogger<analytics::DeleteEvent>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6E2AC50;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BCCB06A4);
}

uint64_t std::__shared_ptr_emplace<analytics::`anonymous namespace'::CoreAnalyticsLogger<analytics::DeleteEvent>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

void analytics::`anonymous namespace'::CoreAnalyticsLogger<analytics::OpenEvent>::~CoreAnalyticsLogger()
{
  JUMPOUT(0x1BCCB06A4);
}

void analytics::`anonymous namespace'::CoreAnalyticsLogger<analytics::OpenEvent>::logEvent(uint64_t a1, std::__shared_weak_count_vtbl **a2)
{
  std::__shared_weak_count *v3;
  std::__shared_weak_count_vtbl *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  int v7;
  int v8;
  NSObject *v9;
  os_log_type_t v10;
  _BOOL4 v11;
  const char *v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  uint8_t buf[4];
  const char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (*a2)
  {
    v3 = (std::__shared_weak_count *)operator new();
    v4 = *a2;
    v3->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6E2AEF0;
    v3->__shared_owners_ = 0;
    v3->__shared_weak_owners_ = 0;
    v3[1].__vftable = v4;
  }
  else
  {
    v3 = 0;
  }
  *a2 = 0;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  v7 = analytics_send_event_lazy();
  v8 = *__error();
  v9 = _SILogForLogForCategory(8);
  v10 = 2 * (dword_1EF19FCAC < 4);
  v11 = os_log_type_enabled(v9, v10);
  if (v7)
  {
    if (v11)
    {
      *(_DWORD *)buf = 136315138;
      v18 = "com.apple.spotlight.textstore.Open";
      v12 = "successfully logged event: %s";
LABEL_12:
      _os_log_impl(&dword_1B8270000, v9, v10, v12, buf, 0xCu);
    }
  }
  else if (v11)
  {
    *(_DWORD *)buf = 136315138;
    v18 = "com.apple.spotlight.textstore.Open";
    v12 = "event logging disabled: %s";
    goto LABEL_12;
  }
  *__error() = v8;
  if (v3)
  {
    v13 = (unint64_t *)&v3->__shared_owners_;
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  if (v3)
  {
    v15 = (unint64_t *)&v3->__shared_owners_;
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

xpc_object_t ___ZN9analytics12_GLOBAL__N_119CoreAnalyticsLoggerINS_9OpenEventEE8logEventENSt3__110unique_ptrIS2_NS4_14default_deleteIS2_EEEE_block_invoke(uint64_t a1)
{
  int *v1;
  char *v2;
  int v3;
  const char *v4;
  const char *v5;
  xpc_object_t v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  uint64_t v13;
  char *v14;
  char *v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  char *v20;
  unint64_t v21;
  char *v22;
  char *v23;
  uint64_t v24;
  xpc_object_t v25;
  xpc_object_t v26;
  char *v27;
  char *v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;
  uint64_t v32;
  char *v33;
  unint64_t v34;
  char *v35;
  char *v36;
  uint64_t v37;
  char *v38;
  char *v39;
  uint64_t v40;
  unint64_t v41;
  unint64_t v42;
  uint64_t v43;
  char *v44;
  unint64_t v45;
  char *v46;
  char *v47;
  uint64_t v48;
  xpc_object_t v49;
  xpc_object_t v50;
  char *v51;
  char *v52;
  uint64_t v53;
  unint64_t v54;
  unint64_t v55;
  uint64_t v56;
  char *v57;
  unint64_t v58;
  char *v59;
  char *v60;
  uint64_t v61;
  char *v62;
  char *v63;
  uint64_t v64;
  unint64_t v65;
  unint64_t v66;
  uint64_t v67;
  char *v68;
  unint64_t v69;
  char *v70;
  char *v71;
  uint64_t v72;
  xpc_object_t v73;
  xpc_object_t v74;
  char *v75;
  char *v76;
  uint64_t v77;
  unint64_t v78;
  unint64_t v79;
  uint64_t v80;
  char *v81;
  unint64_t v82;
  char *v83;
  char *v84;
  uint64_t v85;
  char *v86;
  char *v87;
  uint64_t v88;
  unint64_t v89;
  unint64_t v90;
  uint64_t v91;
  char *v92;
  unint64_t v93;
  char *v94;
  char *v95;
  uint64_t v96;
  xpc_object_t v97;
  xpc_object_t v98;
  char *v99;
  char *v100;
  uint64_t v101;
  unint64_t v102;
  unint64_t v103;
  uint64_t v104;
  char *v105;
  unint64_t v106;
  char *v107;
  char *v108;
  uint64_t v109;
  char *v110;
  char *v111;
  uint64_t v112;
  unint64_t v113;
  unint64_t v114;
  uint64_t v115;
  char *v116;
  unint64_t v117;
  char *v118;
  char *v119;
  uint64_t v120;
  xpc_object_t v121;
  xpc_object_t v122;
  char *v123;
  char *v124;
  uint64_t v125;
  unint64_t v126;
  unint64_t v127;
  uint64_t v128;
  char *v129;
  unint64_t v130;
  char *v131;
  char *v132;
  uint64_t v133;
  char *v134;
  char *v135;
  uint64_t v136;
  unint64_t v137;
  unint64_t v138;
  uint64_t v139;
  char *v140;
  unint64_t v141;
  char *v142;
  char *v143;
  uint64_t v144;
  xpc_object_t v145;
  xpc_object_t v146;
  char *v147;
  char *v148;
  uint64_t v149;
  unint64_t v150;
  unint64_t v151;
  uint64_t v152;
  char *v153;
  unint64_t v154;
  char *v155;
  char *v156;
  uint64_t v157;
  char *v158;
  char *v159;
  uint64_t v160;
  unint64_t v161;
  unint64_t v162;
  uint64_t v163;
  char *v164;
  unint64_t v165;
  char *v166;
  char *v167;
  uint64_t v168;
  xpc_object_t v169;
  xpc_object_t v170;
  char *v171;
  char *v172;
  uint64_t v173;
  unint64_t v174;
  unint64_t v175;
  uint64_t v176;
  char *v177;
  unint64_t v178;
  char *v179;
  char *v180;
  uint64_t v181;
  char *v182;
  char *v183;
  uint64_t v184;
  unint64_t v185;
  unint64_t v186;
  uint64_t v187;
  char *v188;
  unint64_t v189;
  char *v190;
  char *v191;
  uint64_t v192;
  xpc_object_t v193;
  xpc_object_t v194;
  char *v195;
  char *v196;
  uint64_t v197;
  unint64_t v198;
  unint64_t v199;
  uint64_t v200;
  char *v201;
  unint64_t v202;
  char *v203;
  char *v204;
  uint64_t v205;
  xpc_object_t v206;
  void *v208;
  char *v209;
  unint64_t v210;
  void *__p;
  char *v212;
  char *v213;

  v1 = *(int **)(a1 + 32);
  __p = 0;
  v212 = 0;
  v213 = 0;
  v208 = 0;
  v209 = 0;
  v210 = 0;
  if (*((_BYTE *)v1 + 4))
  {
    v2 = (char *)operator new(8uLL);
    *(_QWORD *)v2 = "open_type";
    __p = v2;
    v213 = v2 + 8;
    v3 = *v1;
    v212 = v2 + 8;
    v4 = "load";
    if (v3 != 1)
      v4 = 0;
    if (v3)
      v5 = v4;
    else
      v5 = "create";
    v6 = xpc_string_create(v5);
    v7 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(1uLL);
    v9 = &v7[8 * v8];
    *(_QWORD *)v7 = v6;
    v10 = v7 + 8;
    v12 = (char *)v208;
    v11 = v209;
    if (v209 != v208)
    {
      do
      {
        v13 = *((_QWORD *)v11 - 1);
        v11 -= 8;
        *((_QWORD *)v7 - 1) = v13;
        v7 -= 8;
      }
      while (v11 != v12);
      v11 = (char *)v208;
    }
    v208 = v7;
    v210 = (unint64_t)v9;
    if (v11)
      operator delete(v11);
    v209 = v10;
  }
  if (*((_BYTE *)v1 + 9))
  {
    v14 = v212;
    if (v212 >= v213)
    {
      v16 = (v212 - (_BYTE *)__p) >> 3;
      if ((unint64_t)(v16 + 1) >> 61)
        goto LABEL_290;
      v17 = (v213 - (_BYTE *)__p) >> 2;
      if (v17 <= v16 + 1)
        v17 = v16 + 1;
      if ((unint64_t)(v213 - (_BYTE *)__p) >= 0x7FFFFFFFFFFFFFF8)
        v18 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v18 = v17;
      if (v18)
        v18 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v18);
      else
        v19 = 0;
      v20 = (char *)(v18 + 8 * v16);
      v21 = v18 + 8 * v19;
      *(_QWORD *)v20 = "success";
      v15 = v20 + 8;
      v23 = (char *)__p;
      v22 = v212;
      if (v212 != __p)
      {
        do
        {
          v24 = *((_QWORD *)v22 - 1);
          v22 -= 8;
          *((_QWORD *)v20 - 1) = v24;
          v20 -= 8;
        }
        while (v22 != v23);
        v22 = (char *)__p;
      }
      __p = v20;
      v213 = (char *)v21;
      if (v22)
        operator delete(v22);
    }
    else
    {
      *(_QWORD *)v212 = "success";
      v15 = v14 + 8;
    }
    v212 = v15;
    v25 = xpc_BOOL_create(*((_BYTE *)v1 + 8));
    v26 = v25;
    v27 = v209;
    if ((unint64_t)v209 >= v210)
    {
      v29 = (v209 - (_BYTE *)v208) >> 3;
      if ((unint64_t)(v29 + 1) >> 61)
        goto LABEL_290;
      v30 = (uint64_t)(v210 - (_QWORD)v208) >> 2;
      if (v30 <= v29 + 1)
        v30 = v29 + 1;
      if (v210 - (unint64_t)v208 >= 0x7FFFFFFFFFFFFFF8)
        v31 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v31 = v30;
      if (v31)
        v31 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v31);
      else
        v32 = 0;
      v33 = (char *)(v31 + 8 * v29);
      v34 = v31 + 8 * v32;
      *(_QWORD *)v33 = v26;
      v28 = v33 + 8;
      v36 = (char *)v208;
      v35 = v209;
      if (v209 != v208)
      {
        do
        {
          v37 = *((_QWORD *)v35 - 1);
          v35 -= 8;
          *((_QWORD *)v33 - 1) = v37;
          v33 -= 8;
        }
        while (v35 != v36);
        v35 = (char *)v208;
      }
      v208 = v33;
      v210 = v34;
      if (v35)
        operator delete(v35);
    }
    else
    {
      *(_QWORD *)v209 = v25;
      v28 = v27 + 8;
    }
    v209 = v28;
  }
  if (*((_BYTE *)v1 + 16))
  {
    v38 = v212;
    if (v212 >= v213)
    {
      v40 = (v212 - (_BYTE *)__p) >> 3;
      if ((unint64_t)(v40 + 1) >> 61)
        goto LABEL_290;
      v41 = (v213 - (_BYTE *)__p) >> 2;
      if (v41 <= v40 + 1)
        v41 = v40 + 1;
      if ((unint64_t)(v213 - (_BYTE *)__p) >= 0x7FFFFFFFFFFFFFF8)
        v42 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v42 = v41;
      if (v42)
        v42 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v42);
      else
        v43 = 0;
      v44 = (char *)(v42 + 8 * v40);
      v45 = v42 + 8 * v43;
      *(_QWORD *)v44 = "error_code";
      v39 = v44 + 8;
      v47 = (char *)__p;
      v46 = v212;
      if (v212 != __p)
      {
        do
        {
          v48 = *((_QWORD *)v46 - 1);
          v46 -= 8;
          *((_QWORD *)v44 - 1) = v48;
          v44 -= 8;
        }
        while (v46 != v47);
        v46 = (char *)__p;
      }
      __p = v44;
      v213 = (char *)v45;
      if (v46)
        operator delete(v46);
    }
    else
    {
      *(_QWORD *)v212 = "error_code";
      v39 = v38 + 8;
    }
    v212 = v39;
    v49 = xpc_int64_create(v1[3]);
    v50 = v49;
    v51 = v209;
    if ((unint64_t)v209 >= v210)
    {
      v53 = (v209 - (_BYTE *)v208) >> 3;
      if ((unint64_t)(v53 + 1) >> 61)
        goto LABEL_290;
      v54 = (uint64_t)(v210 - (_QWORD)v208) >> 2;
      if (v54 <= v53 + 1)
        v54 = v53 + 1;
      if (v210 - (unint64_t)v208 >= 0x7FFFFFFFFFFFFFF8)
        v55 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v55 = v54;
      if (v55)
        v55 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v55);
      else
        v56 = 0;
      v57 = (char *)(v55 + 8 * v53);
      v58 = v55 + 8 * v56;
      *(_QWORD *)v57 = v50;
      v52 = v57 + 8;
      v60 = (char *)v208;
      v59 = v209;
      if (v209 != v208)
      {
        do
        {
          v61 = *((_QWORD *)v59 - 1);
          v59 -= 8;
          *((_QWORD *)v57 - 1) = v61;
          v57 -= 8;
        }
        while (v59 != v60);
        v59 = (char *)v208;
      }
      v208 = v57;
      v210 = v58;
      if (v59)
        operator delete(v59);
    }
    else
    {
      *(_QWORD *)v209 = v49;
      v52 = v51 + 8;
    }
    v209 = v52;
  }
  if (*((_BYTE *)v1 + 32))
  {
    v62 = v212;
    if (v212 >= v213)
    {
      v64 = (v212 - (_BYTE *)__p) >> 3;
      if ((unint64_t)(v64 + 1) >> 61)
        goto LABEL_290;
      v65 = (v213 - (_BYTE *)__p) >> 2;
      if (v65 <= v64 + 1)
        v65 = v64 + 1;
      if ((unint64_t)(v213 - (_BYTE *)__p) >= 0x7FFFFFFFFFFFFFF8)
        v66 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v66 = v65;
      if (v66)
        v66 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v66);
      else
        v67 = 0;
      v68 = (char *)(v66 + 8 * v64);
      v69 = v66 + 8 * v67;
      *(_QWORD *)v68 = "hot_shard_size";
      v63 = v68 + 8;
      v71 = (char *)__p;
      v70 = v212;
      if (v212 != __p)
      {
        do
        {
          v72 = *((_QWORD *)v70 - 1);
          v70 -= 8;
          *((_QWORD *)v68 - 1) = v72;
          v68 -= 8;
        }
        while (v70 != v71);
        v70 = (char *)__p;
      }
      __p = v68;
      v213 = (char *)v69;
      if (v70)
        operator delete(v70);
    }
    else
    {
      *(_QWORD *)v212 = "hot_shard_size";
      v63 = v62 + 8;
    }
    v212 = v63;
    v73 = xpc_int64_create(*((_QWORD *)v1 + 3));
    v74 = v73;
    v75 = v209;
    if ((unint64_t)v209 >= v210)
    {
      v77 = (v209 - (_BYTE *)v208) >> 3;
      if ((unint64_t)(v77 + 1) >> 61)
        goto LABEL_290;
      v78 = (uint64_t)(v210 - (_QWORD)v208) >> 2;
      if (v78 <= v77 + 1)
        v78 = v77 + 1;
      if (v210 - (unint64_t)v208 >= 0x7FFFFFFFFFFFFFF8)
        v79 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v79 = v78;
      if (v79)
        v79 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v79);
      else
        v80 = 0;
      v81 = (char *)(v79 + 8 * v77);
      v82 = v79 + 8 * v80;
      *(_QWORD *)v81 = v74;
      v76 = v81 + 8;
      v84 = (char *)v208;
      v83 = v209;
      if (v209 != v208)
      {
        do
        {
          v85 = *((_QWORD *)v83 - 1);
          v83 -= 8;
          *((_QWORD *)v81 - 1) = v85;
          v81 -= 8;
        }
        while (v83 != v84);
        v83 = (char *)v208;
      }
      v208 = v81;
      v210 = v82;
      if (v83)
        operator delete(v83);
    }
    else
    {
      *(_QWORD *)v209 = v73;
      v76 = v75 + 8;
    }
    v209 = v76;
  }
  if (*((_BYTE *)v1 + 48))
  {
    v86 = v212;
    if (v212 >= v213)
    {
      v88 = (v212 - (_BYTE *)__p) >> 3;
      if ((unint64_t)(v88 + 1) >> 61)
        goto LABEL_290;
      v89 = (v213 - (_BYTE *)__p) >> 2;
      if (v89 <= v88 + 1)
        v89 = v88 + 1;
      if ((unint64_t)(v213 - (_BYTE *)__p) >= 0x7FFFFFFFFFFFFFF8)
        v90 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v90 = v89;
      if (v90)
        v90 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v90);
      else
        v91 = 0;
      v92 = (char *)(v90 + 8 * v88);
      v93 = v90 + 8 * v91;
      *(_QWORD *)v92 = "cold_shard_file_count";
      v87 = v92 + 8;
      v95 = (char *)__p;
      v94 = v212;
      if (v212 != __p)
      {
        do
        {
          v96 = *((_QWORD *)v94 - 1);
          v94 -= 8;
          *((_QWORD *)v92 - 1) = v96;
          v92 -= 8;
        }
        while (v94 != v95);
        v94 = (char *)__p;
      }
      __p = v92;
      v213 = (char *)v93;
      if (v94)
        operator delete(v94);
    }
    else
    {
      *(_QWORD *)v212 = "cold_shard_file_count";
      v87 = v86 + 8;
    }
    v212 = v87;
    v97 = xpc_int64_create(*((_QWORD *)v1 + 5));
    v98 = v97;
    v99 = v209;
    if ((unint64_t)v209 >= v210)
    {
      v101 = (v209 - (_BYTE *)v208) >> 3;
      if ((unint64_t)(v101 + 1) >> 61)
        goto LABEL_290;
      v102 = (uint64_t)(v210 - (_QWORD)v208) >> 2;
      if (v102 <= v101 + 1)
        v102 = v101 + 1;
      if (v210 - (unint64_t)v208 >= 0x7FFFFFFFFFFFFFF8)
        v103 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v103 = v102;
      if (v103)
        v103 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v103);
      else
        v104 = 0;
      v105 = (char *)(v103 + 8 * v101);
      v106 = v103 + 8 * v104;
      *(_QWORD *)v105 = v98;
      v100 = v105 + 8;
      v108 = (char *)v208;
      v107 = v209;
      if (v209 != v208)
      {
        do
        {
          v109 = *((_QWORD *)v107 - 1);
          v107 -= 8;
          *((_QWORD *)v105 - 1) = v109;
          v105 -= 8;
        }
        while (v107 != v108);
        v107 = (char *)v208;
      }
      v208 = v105;
      v210 = v106;
      if (v107)
        operator delete(v107);
    }
    else
    {
      *(_QWORD *)v209 = v97;
      v100 = v99 + 8;
    }
    v209 = v100;
  }
  if (*((_BYTE *)v1 + 64))
  {
    v110 = v212;
    if (v212 >= v213)
    {
      v112 = (v212 - (_BYTE *)__p) >> 3;
      if ((unint64_t)(v112 + 1) >> 61)
        goto LABEL_290;
      v113 = (v213 - (_BYTE *)__p) >> 2;
      if (v113 <= v112 + 1)
        v113 = v112 + 1;
      if ((unint64_t)(v213 - (_BYTE *)__p) >= 0x7FFFFFFFFFFFFFF8)
        v114 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v114 = v113;
      if (v114)
        v114 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v114);
      else
        v115 = 0;
      v116 = (char *)(v114 + 8 * v112);
      v117 = v114 + 8 * v115;
      *(_QWORD *)v116 = "cold_shard_total_size";
      v111 = v116 + 8;
      v119 = (char *)__p;
      v118 = v212;
      if (v212 != __p)
      {
        do
        {
          v120 = *((_QWORD *)v118 - 1);
          v118 -= 8;
          *((_QWORD *)v116 - 1) = v120;
          v116 -= 8;
        }
        while (v118 != v119);
        v118 = (char *)__p;
      }
      __p = v116;
      v213 = (char *)v117;
      if (v118)
        operator delete(v118);
    }
    else
    {
      *(_QWORD *)v212 = "cold_shard_total_size";
      v111 = v110 + 8;
    }
    v212 = v111;
    v121 = xpc_int64_create(*((_QWORD *)v1 + 7));
    v122 = v121;
    v123 = v209;
    if ((unint64_t)v209 >= v210)
    {
      v125 = (v209 - (_BYTE *)v208) >> 3;
      if ((unint64_t)(v125 + 1) >> 61)
        goto LABEL_290;
      v126 = (uint64_t)(v210 - (_QWORD)v208) >> 2;
      if (v126 <= v125 + 1)
        v126 = v125 + 1;
      if (v210 - (unint64_t)v208 >= 0x7FFFFFFFFFFFFFF8)
        v127 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v127 = v126;
      if (v127)
        v127 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v127);
      else
        v128 = 0;
      v129 = (char *)(v127 + 8 * v125);
      v130 = v127 + 8 * v128;
      *(_QWORD *)v129 = v122;
      v124 = v129 + 8;
      v132 = (char *)v208;
      v131 = v209;
      if (v209 != v208)
      {
        do
        {
          v133 = *((_QWORD *)v131 - 1);
          v131 -= 8;
          *((_QWORD *)v129 - 1) = v133;
          v129 -= 8;
        }
        while (v131 != v132);
        v131 = (char *)v208;
      }
      v208 = v129;
      v210 = v130;
      if (v131)
        operator delete(v131);
    }
    else
    {
      *(_QWORD *)v209 = v121;
      v124 = v123 + 8;
    }
    v209 = v124;
  }
  if (*((_BYTE *)v1 + 76))
  {
    v134 = v212;
    if (v212 >= v213)
    {
      v136 = (v212 - (_BYTE *)__p) >> 3;
      if ((unint64_t)(v136 + 1) >> 61)
        goto LABEL_290;
      v137 = (v213 - (_BYTE *)__p) >> 2;
      if (v137 <= v136 + 1)
        v137 = v136 + 1;
      if ((unint64_t)(v213 - (_BYTE *)__p) >= 0x7FFFFFFFFFFFFFF8)
        v138 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v138 = v137;
      if (v138)
        v138 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v138);
      else
        v139 = 0;
      v140 = (char *)(v138 + 8 * v136);
      v141 = v138 + 8 * v139;
      *(_QWORD *)v140 = "elapsed_ms";
      v135 = v140 + 8;
      v143 = (char *)__p;
      v142 = v212;
      if (v212 != __p)
      {
        do
        {
          v144 = *((_QWORD *)v142 - 1);
          v142 -= 8;
          *((_QWORD *)v140 - 1) = v144;
          v140 -= 8;
        }
        while (v142 != v143);
        v142 = (char *)__p;
      }
      __p = v140;
      v213 = (char *)v141;
      if (v142)
        operator delete(v142);
    }
    else
    {
      *(_QWORD *)v212 = "elapsed_ms";
      v135 = v134 + 8;
    }
    v212 = v135;
    v145 = xpc_double_create(*((float *)v1 + 18));
    v146 = v145;
    v147 = v209;
    if ((unint64_t)v209 >= v210)
    {
      v149 = (v209 - (_BYTE *)v208) >> 3;
      if ((unint64_t)(v149 + 1) >> 61)
        goto LABEL_290;
      v150 = (uint64_t)(v210 - (_QWORD)v208) >> 2;
      if (v150 <= v149 + 1)
        v150 = v149 + 1;
      if (v210 - (unint64_t)v208 >= 0x7FFFFFFFFFFFFFF8)
        v151 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v151 = v150;
      if (v151)
        v151 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v151);
      else
        v152 = 0;
      v153 = (char *)(v151 + 8 * v149);
      v154 = v151 + 8 * v152;
      *(_QWORD *)v153 = v146;
      v148 = v153 + 8;
      v156 = (char *)v208;
      v155 = v209;
      if (v209 != v208)
      {
        do
        {
          v157 = *((_QWORD *)v155 - 1);
          v155 -= 8;
          *((_QWORD *)v153 - 1) = v157;
          v153 -= 8;
        }
        while (v155 != v156);
        v155 = (char *)v208;
      }
      v208 = v153;
      v210 = v154;
      if (v155)
        operator delete(v155);
    }
    else
    {
      *(_QWORD *)v209 = v145;
      v148 = v147 + 8;
    }
    v209 = v148;
  }
  if (*((_BYTE *)v1 + 88))
  {
    v158 = v212;
    if (v212 >= v213)
    {
      v160 = (v212 - (_BYTE *)__p) >> 3;
      if ((unint64_t)(v160 + 1) >> 61)
        goto LABEL_290;
      v161 = (v213 - (_BYTE *)__p) >> 2;
      if (v161 <= v160 + 1)
        v161 = v160 + 1;
      if ((unint64_t)(v213 - (_BYTE *)__p) >= 0x7FFFFFFFFFFFFFF8)
        v162 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v162 = v161;
      if (v162)
        v162 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v162);
      else
        v163 = 0;
      v164 = (char *)(v162 + 8 * v160);
      v165 = v162 + 8 * v163;
      *(_QWORD *)v164 = "extra_hot_shard_corrupt_count";
      v159 = v164 + 8;
      v167 = (char *)__p;
      v166 = v212;
      if (v212 != __p)
      {
        do
        {
          v168 = *((_QWORD *)v166 - 1);
          v166 -= 8;
          *((_QWORD *)v164 - 1) = v168;
          v164 -= 8;
        }
        while (v166 != v167);
        v166 = (char *)__p;
      }
      __p = v164;
      v213 = (char *)v165;
      if (v166)
        operator delete(v166);
    }
    else
    {
      *(_QWORD *)v212 = "extra_hot_shard_corrupt_count";
      v159 = v158 + 8;
    }
    v212 = v159;
    v169 = xpc_int64_create(*((_QWORD *)v1 + 10));
    v170 = v169;
    v171 = v209;
    if ((unint64_t)v209 >= v210)
    {
      v173 = (v209 - (_BYTE *)v208) >> 3;
      if ((unint64_t)(v173 + 1) >> 61)
        goto LABEL_290;
      v174 = (uint64_t)(v210 - (_QWORD)v208) >> 2;
      if (v174 <= v173 + 1)
        v174 = v173 + 1;
      if (v210 - (unint64_t)v208 >= 0x7FFFFFFFFFFFFFF8)
        v175 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v175 = v174;
      if (v175)
        v175 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v175);
      else
        v176 = 0;
      v177 = (char *)(v175 + 8 * v173);
      v178 = v175 + 8 * v176;
      *(_QWORD *)v177 = v170;
      v172 = v177 + 8;
      v180 = (char *)v208;
      v179 = v209;
      if (v209 != v208)
      {
        do
        {
          v181 = *((_QWORD *)v179 - 1);
          v179 -= 8;
          *((_QWORD *)v177 - 1) = v181;
          v177 -= 8;
        }
        while (v179 != v180);
        v179 = (char *)v208;
      }
      v208 = v177;
      v210 = v178;
      if (v179)
        operator delete(v179);
    }
    else
    {
      *(_QWORD *)v209 = v169;
      v172 = v171 + 8;
    }
    v209 = v172;
  }
  if (!*((_BYTE *)v1 + 104))
    goto LABEL_285;
  v182 = v212;
  if (v212 >= v213)
  {
    v184 = (v212 - (_BYTE *)__p) >> 3;
    if ((unint64_t)(v184 + 1) >> 61)
      goto LABEL_290;
    v185 = (v213 - (_BYTE *)__p) >> 2;
    if (v185 <= v184 + 1)
      v185 = v184 + 1;
    if ((unint64_t)(v213 - (_BYTE *)__p) >= 0x7FFFFFFFFFFFFFF8)
      v186 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v186 = v185;
    if (v186)
      v186 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v186);
    else
      v187 = 0;
    v188 = (char *)(v186 + 8 * v184);
    v189 = v186 + 8 * v187;
    *(_QWORD *)v188 = "extra_hot_shard_cooled_count";
    v183 = v188 + 8;
    v191 = (char *)__p;
    v190 = v212;
    if (v212 != __p)
    {
      do
      {
        v192 = *((_QWORD *)v190 - 1);
        v190 -= 8;
        *((_QWORD *)v188 - 1) = v192;
        v188 -= 8;
      }
      while (v190 != v191);
      v190 = (char *)__p;
    }
    __p = v188;
    v213 = (char *)v189;
    if (v190)
      operator delete(v190);
  }
  else
  {
    *(_QWORD *)v212 = "extra_hot_shard_cooled_count";
    v183 = v182 + 8;
  }
  v212 = v183;
  v193 = xpc_int64_create(*((_QWORD *)v1 + 12));
  v194 = v193;
  v195 = v209;
  if ((unint64_t)v209 >= v210)
  {
    v197 = (v209 - (_BYTE *)v208) >> 3;
    if (!((unint64_t)(v197 + 1) >> 61))
    {
      v198 = (uint64_t)(v210 - (_QWORD)v208) >> 2;
      if (v198 <= v197 + 1)
        v198 = v197 + 1;
      if (v210 - (unint64_t)v208 >= 0x7FFFFFFFFFFFFFF8)
        v199 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v199 = v198;
      if (v199)
        v199 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v199);
      else
        v200 = 0;
      v201 = (char *)(v199 + 8 * v197);
      v202 = v199 + 8 * v200;
      *(_QWORD *)v201 = v194;
      v196 = v201 + 8;
      v204 = (char *)v208;
      v203 = v209;
      if (v209 != v208)
      {
        do
        {
          v205 = *((_QWORD *)v203 - 1);
          v203 -= 8;
          *((_QWORD *)v201 - 1) = v205;
          v201 -= 8;
        }
        while (v203 != v204);
        v203 = (char *)v208;
      }
      v208 = v201;
      v210 = v202;
      if (v203)
        operator delete(v203);
      goto LABEL_284;
    }
LABEL_290:
    abort();
  }
  *(_QWORD *)v209 = v193;
  v196 = v195 + 8;
LABEL_284:
  v209 = v196;
LABEL_285:
  if (v208)
    operator delete(v208);
  if (__p)
    operator delete(__p);
  return v206;
}

uint64_t __copy_helper_block_8_32c48_ZTSNSt3__110shared_ptrIN9analytics9OpenEventEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void __destroy_helper_block_8_32c48_ZTSNSt3__110shared_ptrIN9analytics9OpenEventEEE(uint64_t a1)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v3;

  v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

void std::__shared_ptr_pointer<analytics::OpenEvent  *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BCCB06A4);
}

uint64_t std::__shared_ptr_pointer<analytics::OpenEvent  *>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    JUMPOUT(0x1BCCB06A4);
  return result;
}

void std::__shared_ptr_emplace<analytics::`anonymous namespace'::CoreAnalyticsLogger<analytics::OpenEvent>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6E2AD30;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<analytics::`anonymous namespace'::CoreAnalyticsLogger<analytics::OpenEvent>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6E2AD30;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BCCB06A4);
}

uint64_t std::__shared_ptr_emplace<analytics::`anonymous namespace'::CoreAnalyticsLogger<analytics::OpenEvent>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

std::chrono::steady_clock::time_point *analytics::ScopedLogger<analytics::OpenEvent>::ScopedLogger(std::chrono::steady_clock::time_point *a1)
{
  _OWORD *v2;
  _QWORD *v3;

  v2 = (_OWORD *)operator new();
  *v2 = 0u;
  v2[1] = 0u;
  v2[2] = 0u;
  v2[3] = 0u;
  v2[4] = 0u;
  v2[5] = 0u;
  v2[6] = 0u;
  a1->__d_.__rep_ = (std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep)v2;
  a1[1].__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  v3 = operator new(0x20uLL);
  v3[1] = 0;
  v3[2] = 0;
  *v3 = &off_1E6E2AD30;
  a1[3].__d_.__rep_ = (std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep)v3;
  v3[3] = &off_1E6E2A9D8;
  a1[2].__d_.__rep_ = (std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep)(v3 + 3);
  return a1;
}

_QWORD *analytics::ScopedLogger<analytics::OpenEvent>::~ScopedLogger(_QWORD *a1)
{
  std::chrono::steady_clock::time_point v2;
  uint64_t v3;
  double v4;
  float v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  std::__shared_weak_count *v9;
  unint64_t *p_shared_owners;
  unint64_t v11;
  uint64_t v12;
  uint64_t v14;

  v2.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  v3 = *a1;
  v4 = (double)(v2.__d_.__rep_ - a1[1]) * 0.00001;
  if (!*(_BYTE *)(*a1 + 76))
    *(_BYTE *)(v3 + 76) = 1;
  v5 = v4;
  *(float *)(v3 + 72) = v5;
  v6 = a1[2];
  v7 = *a1;
  *a1 = 0;
  v14 = v7;
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v6 + 16))(v6, &v14);
  v8 = v14;
  v14 = 0;
  if (v8)
    MEMORY[0x1BCCB06A4](v8, 0x1000C4027064493);
  v9 = (std::__shared_weak_count *)a1[3];
  if (v9)
  {
    p_shared_owners = (unint64_t *)&v9->__shared_owners_;
    do
      v11 = __ldaxr(p_shared_owners);
    while (__stlxr(v11 - 1, p_shared_owners));
    if (!v11)
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  v12 = *a1;
  *a1 = 0;
  if (v12)
    MEMORY[0x1BCCB06A4](v12, 0x1000C4027064493);
  return a1;
}

void analytics::`anonymous namespace'::CoreAnalyticsLogger<analytics::HotShardCoolDownEvent>::~CoreAnalyticsLogger()
{
  JUMPOUT(0x1BCCB06A4);
}

void analytics::`anonymous namespace'::CoreAnalyticsLogger<analytics::HotShardCoolDownEvent>::logEvent(uint64_t a1, std::__shared_weak_count_vtbl **a2)
{
  std::__shared_weak_count *v3;
  std::__shared_weak_count_vtbl *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  int v7;
  int v8;
  NSObject *v9;
  os_log_type_t v10;
  _BOOL4 v11;
  const char *v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  uint8_t buf[4];
  const char *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  if (*a2)
  {
    v3 = (std::__shared_weak_count *)operator new();
    v4 = *a2;
    v3->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6E2AE48;
    v3->__shared_owners_ = 0;
    v3->__shared_weak_owners_ = 0;
    v3[1].__vftable = v4;
  }
  else
  {
    v3 = 0;
  }
  *a2 = 0;
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  v7 = analytics_send_event_lazy();
  v8 = *__error();
  v9 = _SILogForLogForCategory(8);
  v10 = 2 * (dword_1EF19FCAC < 4);
  v11 = os_log_type_enabled(v9, v10);
  if (v7)
  {
    if (v11)
    {
      *(_DWORD *)buf = 136315138;
      v18 = "com.apple.spotlight.textstore.HotShardCoolDown";
      v12 = "successfully logged event: %s";
LABEL_12:
      _os_log_impl(&dword_1B8270000, v9, v10, v12, buf, 0xCu);
    }
  }
  else if (v11)
  {
    *(_DWORD *)buf = 136315138;
    v18 = "com.apple.spotlight.textstore.HotShardCoolDown";
    v12 = "event logging disabled: %s";
    goto LABEL_12;
  }
  *__error() = v8;
  if (v3)
  {
    v13 = (unint64_t *)&v3->__shared_owners_;
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 - 1, v13));
    if (!v14)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  if (v3)
  {
    v15 = (unint64_t *)&v3->__shared_owners_;
    do
      v16 = __ldaxr(v15);
    while (__stlxr(v16 - 1, v15));
    if (!v16)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

xpc_object_t ___ZN9analytics12_GLOBAL__N_119CoreAnalyticsLoggerINS_21HotShardCoolDownEventEE8logEventENSt3__110unique_ptrIS2_NS4_14default_deleteIS2_EEEE_block_invoke(uint64_t a1)
{
  unsigned __int8 *v1;
  char *v2;
  char *v3;
  int v4;
  xpc_object_t v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  char *v13;
  char *v14;
  uint64_t v15;
  xpc_object_t v16;
  xpc_object_t v17;
  char *v18;
  char *v19;
  char *v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  char *v28;
  char *v29;
  char *v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  char *v36;
  uint64_t v37;
  xpc_object_t v38;
  xpc_object_t v39;
  char *v40;
  char *v41;
  char *v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  char *v48;
  uint64_t v49;
  char *v50;
  char *v51;
  char *v52;
  uint64_t v53;
  unint64_t v54;
  uint64_t v55;
  unint64_t v56;
  uint64_t v57;
  char *v58;
  uint64_t v59;
  xpc_object_t v60;
  xpc_object_t v61;
  char *v62;
  char *v63;
  char *v64;
  uint64_t v65;
  unint64_t v66;
  uint64_t v67;
  unint64_t v68;
  uint64_t v69;
  char *v70;
  uint64_t v71;
  char *v72;
  char *v73;
  char *v74;
  uint64_t v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  char *v80;
  uint64_t v81;
  xpc_object_t v82;
  xpc_object_t v83;
  char *v84;
  char *v85;
  char *v86;
  uint64_t v87;
  unint64_t v88;
  uint64_t v89;
  unint64_t v90;
  uint64_t v91;
  char *v92;
  uint64_t v93;
  char *v94;
  char *v95;
  char *v96;
  uint64_t v97;
  unint64_t v98;
  uint64_t v99;
  unint64_t v100;
  uint64_t v101;
  char *v102;
  uint64_t v103;
  xpc_object_t v104;
  xpc_object_t v105;
  char *v106;
  char *v107;
  char *v108;
  uint64_t v109;
  unint64_t v110;
  uint64_t v111;
  unint64_t v112;
  uint64_t v113;
  char *v114;
  uint64_t v115;
  xpc_object_t v116;
  void *__p;
  char *v119;
  char *v120;
  void *v121;
  char *v122;
  char *v123;

  v1 = *(unsigned __int8 **)(a1 + 32);
  v121 = 0;
  v122 = 0;
  v123 = 0;
  __p = 0;
  v119 = 0;
  v120 = 0;
  if (v1[1])
  {
    v2 = (char *)operator new(8uLL);
    *(_QWORD *)v2 = "success";
    v3 = v2 + 8;
    v122 = v2 + 8;
    v123 = v2 + 8;
    v4 = *v1;
    v121 = v2;
    v5 = xpc_BOOL_create(v4 != 0);
    v6 = (char *)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(1uLL);
    *(_QWORD *)v6 = v5;
    __p = v6;
    v119 = v6 + 8;
    v120 = &v6[8 * v7];
  }
  else
  {
    v2 = 0;
    v3 = 0;
  }
  if (v1[8])
  {
    v8 = v3 - v2;
    v9 = (v3 - v2) >> 3;
    v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 61)
      goto LABEL_177;
    if (v8 >> 2 > v10)
      v10 = v8 >> 2;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    if (v11)
      v11 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v11);
    else
      v12 = 0;
    v13 = (char *)(v11 + 8 * v9);
    *(_QWORD *)v13 = "error_code";
    v14 = v13 + 8;
    if (v3 != v2)
    {
      do
      {
        v15 = *((_QWORD *)v3 - 1);
        v3 -= 8;
        *((_QWORD *)v13 - 1) = v15;
        v13 -= 8;
      }
      while (v3 != v2);
      v2 = (char *)v121;
    }
    v121 = v13;
    v123 = (char *)(v11 + 8 * v12);
    if (v2)
      operator delete(v2);
    v122 = v14;
    v16 = xpc_int64_create(*((int *)v1 + 1));
    v17 = v16;
    v18 = v119;
    if (v119 >= v120)
    {
      v20 = (char *)__p;
      v21 = (v119 - (_BYTE *)__p) >> 3;
      v22 = v21 + 1;
      if ((unint64_t)(v21 + 1) >> 61)
        goto LABEL_177;
      v23 = v120 - (_BYTE *)__p;
      if ((v120 - (_BYTE *)__p) >> 2 > v22)
        v22 = v23 >> 2;
      if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8)
        v24 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v24 = v22;
      if (v24)
        v24 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v24);
      else
        v25 = 0;
      v26 = (char *)(v24 + 8 * v21);
      *(_QWORD *)v26 = v17;
      v19 = v26 + 8;
      if (v18 != v20)
      {
        do
        {
          v27 = *((_QWORD *)v18 - 1);
          v18 -= 8;
          *((_QWORD *)v26 - 1) = v27;
          v26 -= 8;
        }
        while (v18 != v20);
        v18 = (char *)__p;
      }
      __p = v26;
      v120 = (char *)(v24 + 8 * v25);
      if (v18)
        operator delete(v18);
    }
    else
    {
      *(_QWORD *)v119 = v16;
      v19 = v18 + 8;
    }
    v119 = v19;
  }
  if (v1[24])
  {
    v28 = v122;
    if (v122 >= v123)
    {
      v30 = (char *)v121;
      v31 = (v122 - (_BYTE *)v121) >> 3;
      v32 = v31 + 1;
      if ((unint64_t)(v31 + 1) >> 61)
        goto LABEL_177;
      v33 = v123 - (_BYTE *)v121;
      if ((v123 - (_BYTE *)v121) >> 2 > v32)
        v32 = v33 >> 2;
      if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFF8)
        v34 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v34 = v32;
      if (v34)
        v34 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v34);
      else
        v35 = 0;
      v36 = (char *)(v34 + 8 * v31);
      *(_QWORD *)v36 = "hot_shard_doc_count";
      v29 = v36 + 8;
      if (v28 != v30)
      {
        do
        {
          v37 = *((_QWORD *)v28 - 1);
          v28 -= 8;
          *((_QWORD *)v36 - 1) = v37;
          v36 -= 8;
        }
        while (v28 != v30);
        v28 = (char *)v121;
      }
      v121 = v36;
      v123 = (char *)(v34 + 8 * v35);
      if (v28)
        operator delete(v28);
    }
    else
    {
      *(_QWORD *)v122 = "hot_shard_doc_count";
      v29 = v28 + 8;
    }
    v122 = v29;
    v38 = xpc_int64_create(*((_QWORD *)v1 + 2));
    v39 = v38;
    v40 = v119;
    if (v119 >= v120)
    {
      v42 = (char *)__p;
      v43 = (v119 - (_BYTE *)__p) >> 3;
      v44 = v43 + 1;
      if ((unint64_t)(v43 + 1) >> 61)
        goto LABEL_177;
      v45 = v120 - (_BYTE *)__p;
      if ((v120 - (_BYTE *)__p) >> 2 > v44)
        v44 = v45 >> 2;
      if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFF8)
        v46 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v46 = v44;
      if (v46)
        v46 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v46);
      else
        v47 = 0;
      v48 = (char *)(v46 + 8 * v43);
      *(_QWORD *)v48 = v39;
      v41 = v48 + 8;
      if (v40 != v42)
      {
        do
        {
          v49 = *((_QWORD *)v40 - 1);
          v40 -= 8;
          *((_QWORD *)v48 - 1) = v49;
          v48 -= 8;
        }
        while (v40 != v42);
        v40 = (char *)__p;
      }
      __p = v48;
      v120 = (char *)(v46 + 8 * v47);
      if (v40)
        operator delete(v40);
    }
    else
    {
      *(_QWORD *)v119 = v38;
      v41 = v40 + 8;
    }
    v119 = v41;
  }
  if (v1[40])
  {
    v50 = v122;
    if (v122 >= v123)
    {
      v52 = (char *)v121;
      v53 = (v122 - (_BYTE *)v121) >> 3;
      v54 = v53 + 1;
      if ((unint64_t)(v53 + 1) >> 61)
        goto LABEL_177;
      v55 = v123 - (_BYTE *)v121;
      if ((v123 - (_BYTE *)v121) >> 2 > v54)
        v54 = v55 >> 2;
      if ((unint64_t)v55 >= 0x7FFFFFFFFFFFFFF8)
        v56 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v56 = v54;
      if (v56)
        v56 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v56);
      else
        v57 = 0;
      v58 = (char *)(v56 + 8 * v53);
      *(_QWORD *)v58 = "hot_shard_size";
      v51 = v58 + 8;
      if (v50 != v52)
      {
        do
        {
          v59 = *((_QWORD *)v50 - 1);
          v50 -= 8;
          *((_QWORD *)v58 - 1) = v59;
          v58 -= 8;
        }
        while (v50 != v52);
        v50 = (char *)v121;
      }
      v121 = v58;
      v123 = (char *)(v56 + 8 * v57);
      if (v50)
        operator delete(v50);
    }
    else
    {
      *(_QWORD *)v122 = "hot_shard_size";
      v51 = v50 + 8;
    }
    v122 = v51;
    v60 = xpc_int64_create(*((_QWORD *)v1 + 4));
    v61 = v60;
    v62 = v119;
    if (v119 >= v120)
    {
      v64 = (char *)__p;
      v65 = (v119 - (_BYTE *)__p) >> 3;
      v66 = v65 + 1;
      if ((unint64_t)(v65 + 1) >> 61)
        goto LABEL_177;
      v67 = v120 - (_BYTE *)__p;
      if ((v120 - (_BYTE *)__p) >> 2 > v66)
        v66 = v67 >> 2;
      if ((unint64_t)v67 >= 0x7FFFFFFFFFFFFFF8)
        v68 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v68 = v66;
      if (v68)
        v68 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v68);
      else
        v69 = 0;
      v70 = (char *)(v68 + 8 * v65);
      *(_QWORD *)v70 = v61;
      v63 = v70 + 8;
      if (v62 != v64)
      {
        do
        {
          v71 = *((_QWORD *)v62 - 1);
          v62 -= 8;
          *((_QWORD *)v70 - 1) = v71;
          v70 -= 8;
        }
        while (v62 != v64);
        v62 = (char *)__p;
      }
      __p = v70;
      v120 = (char *)(v68 + 8 * v69);
      if (v62)
        operator delete(v62);
    }
    else
    {
      *(_QWORD *)v119 = v60;
      v63 = v62 + 8;
    }
    v119 = v63;
  }
  if (v1[56])
  {
    v72 = v122;
    if (v122 >= v123)
    {
      v74 = (char *)v121;
      v75 = (v122 - (_BYTE *)v121) >> 3;
      v76 = v75 + 1;
      if ((unint64_t)(v75 + 1) >> 61)
        goto LABEL_177;
      v77 = v123 - (_BYTE *)v121;
      if ((v123 - (_BYTE *)v121) >> 2 > v76)
        v76 = v77 >> 2;
      if ((unint64_t)v77 >= 0x7FFFFFFFFFFFFFF8)
        v78 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v78 = v76;
      if (v78)
        v78 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v78);
      else
        v79 = 0;
      v80 = (char *)(v78 + 8 * v75);
      *(_QWORD *)v80 = "cold_shard_size";
      v73 = v80 + 8;
      if (v72 != v74)
      {
        do
        {
          v81 = *((_QWORD *)v72 - 1);
          v72 -= 8;
          *((_QWORD *)v80 - 1) = v81;
          v80 -= 8;
        }
        while (v72 != v74);
        v72 = (char *)v121;
      }
      v121 = v80;
      v123 = (char *)(v78 + 8 * v79);
      if (v72)
        operator delete(v72);
    }
    else
    {
      *(_QWORD *)v122 = "cold_shard_size";
      v73 = v72 + 8;
    }
    v122 = v73;
    v82 = xpc_int64_create(*((_QWORD *)v1 + 6));
    v83 = v82;
    v84 = v119;
    if (v119 >= v120)
    {
      v86 = (char *)__p;
      v87 = (v119 - (_BYTE *)__p) >> 3;
      v88 = v87 + 1;
      if ((unint64_t)(v87 + 1) >> 61)
        goto LABEL_177;
      v89 = v120 - (_BYTE *)__p;
      if ((v120 - (_BYTE *)__p) >> 2 > v88)
        v88 = v89 >> 2;
      if ((unint64_t)v89 >= 0x7FFFFFFFFFFFFFF8)
        v90 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v90 = v88;
      if (v90)
        v90 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v90);
      else
        v91 = 0;
      v92 = (char *)(v90 + 8 * v87);
      *(_QWORD *)v92 = v83;
      v85 = v92 + 8;
      if (v84 != v86)
      {
        do
        {
          v93 = *((_QWORD *)v84 - 1);
          v84 -= 8;
          *((_QWORD *)v92 - 1) = v93;
          v92 -= 8;
        }
        while (v84 != v86);
        v84 = (char *)__p;
      }
      __p = v92;
      v120 = (char *)(v90 + 8 * v91);
      if (v84)
        operator delete(v84);
    }
    else
    {
      *(_QWORD *)v119 = v82;
      v85 = v84 + 8;
    }
    v119 = v85;
  }
  if (!v1[68])
    goto LABEL_172;
  v94 = v122;
  if (v122 >= v123)
  {
    v96 = (char *)v121;
    v97 = (v122 - (_BYTE *)v121) >> 3;
    v98 = v97 + 1;
    if ((unint64_t)(v97 + 1) >> 61)
      goto LABEL_177;
    v99 = v123 - (_BYTE *)v121;
    if ((v123 - (_BYTE *)v121) >> 2 > v98)
      v98 = v99 >> 2;
    if ((unint64_t)v99 >= 0x7FFFFFFFFFFFFFF8)
      v100 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v100 = v98;
    if (v100)
      v100 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v100);
    else
      v101 = 0;
    v102 = (char *)(v100 + 8 * v97);
    *(_QWORD *)v102 = "elapsed_ms";
    v95 = v102 + 8;
    if (v94 != v96)
    {
      do
      {
        v103 = *((_QWORD *)v94 - 1);
        v94 -= 8;
        *((_QWORD *)v102 - 1) = v103;
        v102 -= 8;
      }
      while (v94 != v96);
      v94 = (char *)v121;
    }
    v121 = v102;
    v123 = (char *)(v100 + 8 * v101);
    if (v94)
      operator delete(v94);
  }
  else
  {
    *(_QWORD *)v122 = "elapsed_ms";
    v95 = v94 + 8;
  }
  v122 = v95;
  v104 = xpc_double_create(*((float *)v1 + 16));
  v105 = v104;
  v106 = v119;
  if (v119 >= v120)
  {
    v108 = (char *)__p;
    v109 = (v119 - (_BYTE *)__p) >> 3;
    v110 = v109 + 1;
    if (!((unint64_t)(v109 + 1) >> 61))
    {
      v111 = v120 - (_BYTE *)__p;
      if ((v120 - (_BYTE *)__p) >> 2 > v110)
        v110 = v111 >> 2;
      if ((unint64_t)v111 >= 0x7FFFFFFFFFFFFFF8)
        v112 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v112 = v110;
      if (v112)
        v112 = (unint64_t)std::__allocate_at_least[abi:nn180100]<std::allocator<unsigned long>>(v112);
      else
        v113 = 0;
      v114 = (char *)(v112 + 8 * v109);
      *(_QWORD *)v114 = v105;
      v107 = v114 + 8;
      if (v106 != v108)
      {
        do
        {
          v115 = *((_QWORD *)v106 - 1);
          v106 -= 8;
          *((_QWORD *)v114 - 1) = v115;
          v114 -= 8;
        }
        while (v106 != v108);
        v106 = (char *)__p;
      }
      __p = v114;
      v120 = (char *)(v112 + 8 * v113);
      if (v106)
        operator delete(v106);
      goto LABEL_171;
    }
LABEL_177:
    abort();
  }
  *(_QWORD *)v119 = v104;
  v107 = v106 + 8;
LABEL_171:
  v119 = v107;
LABEL_172:
  if (__p)
    operator delete(__p);
  if (v121)
    operator delete(v121);
  return v116;
}

uint64_t __copy_helper_block_8_32c61_ZTSNSt3__110shared_ptrIN9analytics21HotShardCoolDownEventEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(result + 32) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(result + 40) = v2;
  if (v2)
  {
    v3 = (unint64_t *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  return result;
}

void __destroy_helper_block_8_32c61_ZTSNSt3__110shared_ptrIN9analytics21HotShardCoolDownEventEEE(uint64_t a1)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v3;

  v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

void std::__shared_ptr_pointer<analytics::HotShardCoolDownEvent  *>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BCCB06A4);
}

uint64_t std::__shared_ptr_pointer<analytics::HotShardCoolDownEvent  *>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    JUMPOUT(0x1BCCB06A4);
  return result;
}

void std::__shared_ptr_emplace<analytics::`anonymous namespace'::CoreAnalyticsLogger<analytics::HotShardCoolDownEvent>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6E2AC88;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<analytics::`anonymous namespace'::CoreAnalyticsLogger<analytics::HotShardCoolDownEvent>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&off_1E6E2AC88;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1BCCB06A4);
}

uint64_t std::__shared_ptr_emplace<analytics::`anonymous namespace'::CoreAnalyticsLogger<analytics::HotShardCoolDownEvent>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

std::chrono::steady_clock::time_point *analytics::ScopedLogger<analytics::DeleteEvent>::ScopedLogger(std::chrono::steady_clock::time_point *a1, std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep *a2)
{
  uint64_t v4;
  std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v5;
  unint64_t *v6;
  unint64_t v7;

  v4 = operator new();
  *(_OWORD *)v4 = 0u;
  *(_OWORD *)(v4 + 16) = 0u;
  *(_OWORD *)(v4 + 32) = 0u;
  *(_OWORD *)(v4 + 48) = 0u;
  *(_QWORD *)(v4 + 64) = 0;
  a1->__d_.__rep_ = v4;
  a1[1].__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  v5 = a2[1];
  a1[2].__d_.__rep_ = *a2;
  a1[3].__d_.__rep_ = v5;
  if (v5)
  {
    v6 = (unint64_t *)(v5 + 8);
    do
      v7 = __ldxr(v6);
    while (__stxr(v7 + 1, v6));
  }
  return a1;
}

_QWORD *analytics::ScopedLogger<analytics::DeleteEvent>::~ScopedLogger(_QWORD *a1)
{
  std::chrono::steady_clock::time_point v2;
  uint64_t v3;
  double v4;
  float v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;

  v2.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  v3 = *a1;
  v4 = (double)(v2.__d_.__rep_ - a1[1]) * 0.00001;
  if (!*(_BYTE *)(*a1 + 68))
    *(_BYTE *)(v3 + 68) = 1;
  v5 = v4;
  *(float *)(v3 + 64) = v5;
  v6 = a1[2];
  v7 = *a1;
  *a1 = 0;
  v11 = v7;
  (*(void (**)(uint64_t, uint64_t *))(*(_QWORD *)v6 + 16))(v6, &v11);
  v8 = v11;
  v11 = 0;
  if (v8)
    MEMORY[0x1BCCB06A4](v8, 0x1000C4073594BB7);
  std::shared_ptr<analytics::EventLogger<analytics::DeleteEvent>>::~shared_ptr[abi:nn180100]((uint64_t)(a1 + 2));
  v9 = *a1;
  *a1 = 0;
  if (v9)
    MEMORY[0x1BCCB06A4](v9, 0x1000C4073594BB7);
  return a1;
}

uint64_t SISetLogging(uint64_t result, int a2)
{
  if (result <= 0x14)
    gSILogLevels[result] = a2;
  return result;
}

uint64_t _SILogForLogForCategory(int a1)
{
  if (_SILogForLogForCategory_onceToken[0] != -1)
    dispatch_once(_SILogForLogForCategory_onceToken, &__block_literal_global_1629);
  return gSILogArray[a1];
}

BOOL trie_level_info_eq(uint64_t a1, uint64_t a2)
{
  size_t v2;

  if (*(_QWORD *)(a1 + 24) == *(_QWORD *)(a2 + 24)
    && *(_DWORD *)(a1 + 32) == *(_DWORD *)(a2 + 32)
    && *(_DWORD *)a1 == *(_DWORD *)a2
    && *(_DWORD *)(a1 + 4) == *(_DWORD *)(a2 + 4)
    && (v2 = *(int *)(a1 + 16), (_DWORD)v2 == *(_DWORD *)(a2 + 16)))
  {
    return memcmp(*(const void **)(a1 + 8), *(const void **)(a2 + 8), v2) == 0;
  }
  else
  {
    return 0;
  }
}

uint64_t trie_level_info_hash(uint64_t a1)
{
  int v1;
  int v2;
  int v3;
  unsigned int v4;
  unsigned __int8 *v5;
  int v6;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  unint64_t v11;
  int v12;
  int v14;
  int v15;
  unint64_t v16;
  int v17;
  unsigned int v18;

  v1 = *(_DWORD *)(a1 + 16);
  v2 = ((16 * *(_DWORD *)(a1 + 4)) | (*(_DWORD *)a1 << 6)) ^ *(_DWORD *)(a1 + 24) ^ *(_DWORD *)(a1 + 32);
  if (v1 >= 0)
    v3 = *(_DWORD *)(a1 + 16);
  else
    v3 = v1 + 3;
  v4 = v2 ^ 0x971E137B;
  v5 = (unsigned __int8 *)(*(_QWORD *)(a1 + 8) + (int)(v3 & 0xFFFFFFFC));
  if ((v1 + 3) >= 7)
  {
    v8 = -(v3 >> 2);
    v9 = -1789642873;
    v10 = 718793509;
    do
    {
      v9 = 5 * v9 + 2071795100;
      v10 = 5 * v10 + 1808688022;
      HIDWORD(v11) = v9 * *(_DWORD *)&v5[4 * v8];
      LODWORD(v11) = HIDWORD(v11);
      v12 = (v11 >> 21) * v10;
      HIDWORD(v11) = v4;
      LODWORD(v11) = v4;
      v4 = v12 ^ (5 * (v11 >> 19) + 1390208809);
    }
    while (!__CFADD__(v8++, 1));
    v7 = 5 * v9 + 2071795100;
    v6 = 5 * v10 + 1808688022;
  }
  else
  {
    v6 = 1107688271;
    v7 = 1713515327;
  }
  v14 = 0;
  v15 = v1 & 3;
  switch(v15)
  {
    case 1:
      goto LABEL_15;
    case 2:
LABEL_14:
      v14 |= v5[1] << 8;
LABEL_15:
      HIDWORD(v16) = (v14 ^ *v5) * v7;
      LODWORD(v16) = HIDWORD(v16);
      v17 = (v16 >> 21) * v6;
      HIDWORD(v16) = v4;
      LODWORD(v16) = v4;
      v4 = v17 ^ (5 * (v16 >> 19) + 1390208809);
      break;
    case 3:
      v14 = v5[2] << 16;
      goto LABEL_14;
  }
  v18 = -1028477387 * ((-2048144789 * (v4 ^ v1)) ^ ((-2048144789 * (v4 ^ v1)) >> 13));
  return v2 ^ HIWORD(v18) ^ v18;
}

uint64_t bt_changePrefix(uint64_t a1, const char *a2, const char *a3, int a4)
{
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  std::error_code *v11;
  std::error_code *v12;
  std::error_code *v13;
  stat v14;
  std::__fs::filesystem::path __from;
  std::__fs::filesystem::path __str[42];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  bzero(__str, 0x400uLL);
  snprintf((char *)__str, 0x400uLL, "%s%s", a3, "indexDirectory");
  fd_rename(*(_QWORD *)(a1 + 4568), (const char *)__str);
  snprintf((char *)__str, 0x400uLL, "%s%s", a3, "indexCompactDirectory");
  fd_rename(*(_QWORD *)(a1 + 112), (const char *)__str);
  snprintf((char *)__str, 0x400uLL, "%s%s", a3, "indexArrays");
  result = fd_rename(*(_QWORD *)(a1 + 376), (const char *)__str);
  if (a4)
  {
    bzero(&__from, 0x400uLL);
    v9 = *(unsigned int *)(a1 + 152);
    memset(&v14, 0, sizeof(v14));
    result = fstat(v9, &v14);
    if (!(_DWORD)result)
    {
      v10 = open(".", 4);
      result = MEMORY[0x1BCCB1484](v9);
      if ((_DWORD)result)
      {
        if ((v10 & 0x80000000) != 0)
          return result;
      }
      else
      {
        snprintf((char *)&__from, 0x400uLL, "%s%s", a2, "shadowIndexArrays");
        snprintf((char *)__str, 0x400uLL, "%s%s", a3, "shadowIndexArrays");
        rename(&__from, __str, v11);
        snprintf((char *)&__from, 0x400uLL, "%s%s", a2, "shadowIndexDirectory");
        snprintf((char *)__str, 0x400uLL, "%s%s", a3, "shadowIndexDirectory");
        rename(&__from, __str, v12);
        snprintf((char *)&__from, 0x400uLL, "%s%s", a2, "shadowIndexCompactDirectory");
        snprintf((char *)__str, 0x400uLL, "%s%s", a3, "shadowIndexCompactDirectory");
        rename(&__from, __str, v13);
        result = MEMORY[0x1BCCB1484](v10);
        if ((v10 & 0x80000000) != 0)
          return result;
      }
      return close(v10);
    }
  }
  return result;
}

uint64_t bt_openTrie(uint64_t a1, int a2, const char *a3, int a4, int a5, int a6, int a7, void *a8)
{
  const __CFAllocator *v15;
  __CFBitVector *Mutable;
  _BOOL4 v17;
  int v18;
  int v19;
  const char *v20;
  _QWORD *v21;
  _QWORD *v22;
  int v23;
  uint64_t v24;
  uint64_t v26;
  int *v27;
  _QWORD *v28;
  const char *v29;
  _QWORD *v30;
  uint64_t v31;
  const char *v32;
  char *v33;
  char *v34;
  int v35;
  uint64_t v36;
  uint64_t v38;
  int *v39;
  int v40;
  NSObject *v41;
  int v42;
  const char *v43;
  off_t v44;
  NSObject *v45;
  int v46;
  int v47;
  NSObject *v48;
  uint32_t v49;
  int v50;
  int v51;
  void *v52;
  int v53;
  NSObject *v54;
  int v55;
  NSObject *v56;
  int v57;
  void *v58;
  uint64_t result;
  int v60;
  uint64_t v61;
  void *v62;
  off_t v63;
  NSObject *v64;
  uint64_t v65;
  uint64_t v66;
  const char *v67;
  NSObject *v68;
  uint32_t v69;
  NSObject *v70;
  int v71;
  const char *v72;
  int v73;
  int v74;
  NSObject *v75;
  off_t v76;
  int v77;
  NSObject *v78;
  int v79;
  uint64_t v80;
  int v81;
  int v82;
  const char *v83;
  off_t v84;
  NSObject *v85;
  uint64_t v86;
  uint64_t v87;
  const char *v88;
  int v89;
  char *v90;
  char *v91;
  const char *v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  const char *v96;
  char *v97;
  char *v98;
  const char *v99;
  int v100;
  stat v102;
  uint8_t buf[4];
  const char *v104;
  __int16 v105;
  int v106;
  __int16 v107;
  _BYTE v108[28];
  _BYTE v109[10];
  __int16 v110;
  const char *v111;
  char __str[1024];
  uint64_t v113;

  v113 = *MEMORY[0x1E0C80C00];
  *(_DWORD *)(a1 + 4576) = a4;
  *(_DWORD *)(a1 + 152) = a2;
  if (!*(_QWORD *)(a1 + 4536))
  {
    v15 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    *(_OWORD *)(a1 + 4528) = xmmword_1B8631C20;
    Mutable = CFBitVectorCreateMutable(v15, 0x2000);
    *(_QWORD *)(a1 + 4544) = Mutable;
    CFBitVectorSetCount(Mutable, 0x2000);
    if (!*(_QWORD *)(a1 + 4544))
    {
      v90 = __si_assert_copy_extra_1644(0);
      v91 = v90;
      v92 = "";
      if (v90)
        v92 = v90;
      __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 47, "bv->_cfbv", v92);
      free(v91);
      if (__valid_fs(-1))
        v93 = 2989;
      else
        v93 = 3072;
      *(_DWORD *)v93 = -559038737;
      abort();
    }
  }
  v17 = 0;
  if (a5)
    v18 = 0;
  else
    v18 = 514;
  if (a6)
  {
    if ((a5 & 1) == 0)
    {
      v97 = __si_assert_copy_extra_1644(0);
      v98 = v97;
      v99 = "";
      if (v97)
        v99 = v97;
      __message_assert("%s:%u: failed assertion '%s' %s ", "BurstTrie.c", 520, "0", v99);
      free(v98);
      if (__valid_fs(-1))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
    v17 = a4 == 0;
  }
  memset(&v102, 0, sizeof(v102));
  bzero(__str, 0x400uLL);
  v19 = *(_DWORD *)(a1 + 148);
  v20 = "indexDirectory";
  if (v19)
  {
    if (v17)
      v20 = "shadowIndexDirectory";
    snprintf(__str, 0x400uLL, "%s%s", a3, v20);
    v21 = fd_create_protected(a2, __str, v18, 0);
    *(_QWORD *)(a1 + 4568) = v21;
    if (v21)
    {
      v22 = v21;
      v100 = v19;
      while (1)
      {
        v23 = fstatat(*((_DWORD *)v22 + 11), (const char *)v22[9], &v102, 2048);
        v24 = g_prot_error_callback;
        if (v23 != -1 || g_prot_error_callback == 0)
          break;
        v26 = *((unsigned int *)v22 + 10);
        v27 = __error();
        if (((*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t))(v24 + 16))(v24, v26, *v27, 8) & 1) == 0)goto LABEL_49;
      }
      if (v23 != -1)
      {
        v44 = 1028 * *(unsigned int *)(a1 + 148);
        if (v102.st_size > v44 || v102.st_size < 1028 * *(unsigned int *)(a1 + 144))
        {
          v40 = *__error();
          v45 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
          {
            v46 = *(_DWORD *)(a1 + 148);
            v47 = 1028 * *(_DWORD *)(a1 + 144);
            *(_DWORD *)buf = 136316418;
            v104 = "bt_openTrie";
            v105 = 1024;
            v106 = 590;
            v107 = 1024;
            *(_DWORD *)v108 = v102.st_size;
            *(_WORD *)&v108[4] = 1024;
            *(_DWORD *)&v108[6] = v47;
            *(_WORD *)&v108[10] = 1024;
            *(_DWORD *)&v108[12] = 1028 * v46;
            *(_WORD *)&v108[16] = 2080;
            *(_QWORD *)&v108[18] = __str;
            v43 = "%s:%d: FAT: bad file size:%d (expected %d - %d) %s";
            v48 = v45;
            v49 = 46;
LABEL_83:
            _os_log_error_impl(&dword_1B8270000, v48, OS_LOG_TYPE_ERROR, v43, buf, v49);
          }
LABEL_84:
          v34 = 0;
          v31 = 0;
LABEL_85:
          *__error() = v40;
          goto LABEL_86;
        }
        if ((a5 & 1) != 0 || fd_truncate(*(_QWORD *)(a1 + 4568), v44) != -1)
        {
          v19 = v100;
          if (*(_QWORD *)(a1 + 8))
            goto LABEL_29;
          v52 = (void *)fd_mmap(*(_QWORD *)(a1 + 4568));
          *(_QWORD *)(a1 + 8) = v52;
          if (v52 == (void *)-1)
          {
            v40 = *__error();
            v41 = _SILogForLogForCategory(0);
            if (!os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
              goto LABEL_84;
            v79 = *__error();
            v80 = 1028 * *(unsigned int *)(a1 + 148);
            *(_DWORD *)buf = 136315906;
            v104 = "bt_openTrie";
            v105 = 1024;
            v106 = 603;
            v107 = 1024;
            *(_DWORD *)v108 = v79;
            *(_WORD *)&v108[4] = 2048;
            *(_QWORD *)&v108[6] = v80;
            v43 = "%s:%d: fd_mmap err: %d, %ld";
            goto LABEL_82;
          }
          if (!a5)
          {
            v18 = 514;
            goto LABEL_29;
          }
LABEL_55:
          madvise(v52, 1028 * *(unsigned int *)(a1 + 148), 2);
          v18 = 0;
          goto LABEL_29;
        }
        v40 = *__error();
        v54 = _SILogForLogForCategory(0);
        if (!os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
          goto LABEL_84;
        v73 = *__error();
        *(_DWORD *)buf = 136315650;
        v104 = "bt_openTrie";
        v105 = 1024;
        v106 = 596;
        v107 = 1024;
        *(_DWORD *)v108 = v73;
        v43 = "%s:%d: ftruncate err: %d";
LABEL_60:
        v48 = v54;
        v49 = 24;
        goto LABEL_83;
      }
LABEL_49:
      v40 = *__error();
      v41 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
        goto LABEL_84;
      v50 = *__error();
      *(_DWORD *)buf = 136315906;
      v104 = "bt_openTrie";
      v105 = 1024;
      v106 = 582;
      v107 = 1024;
      *(_DWORD *)v108 = v50;
      *(_WORD *)&v108[4] = 2080;
      *(_QWORD *)&v108[6] = __str;
      v43 = "%s:%d: fstat err:%d %s";
    }
    else
    {
      v40 = *__error();
      v41 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
        goto LABEL_84;
      v42 = *__error();
      *(_DWORD *)buf = 136315906;
      v104 = "bt_openTrie";
      v105 = 1024;
      v106 = 577;
      v107 = 2080;
      *(_QWORD *)v108 = __str;
      *(_WORD *)&v108[8] = 1024;
      *(_DWORD *)&v108[10] = v42;
      v43 = "%s:%d: open %s err: %d";
    }
LABEL_82:
    v48 = v41;
    v49 = 34;
    goto LABEL_83;
  }
  *(_DWORD *)a1 = 11;
  if (a5)
    v18 = 0;
  else
    v18 = 1538;
  *(_QWORD *)(a1 + 144) = 0x800000001;
  if (v17)
    v20 = "shadowIndexDirectory";
  snprintf(__str, 0x400uLL, "%s%s", a3, v20);
  v28 = fd_create_protected(a2, __str, v18, 0);
  *(_QWORD *)(a1 + 4568) = v28;
  if (!v28)
  {
    v40 = *__error();
    v41 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
      goto LABEL_84;
    v51 = *__error();
    *(_DWORD *)buf = 136315906;
    v104 = "bt_openTrie";
    v105 = 1024;
    v106 = 546;
    v107 = 2080;
    *(_QWORD *)v108 = __str;
    *(_WORD *)&v108[8] = 1024;
    *(_DWORD *)&v108[10] = v51;
    v43 = "%s:%d: open %s err: %d";
    goto LABEL_82;
  }
  if ((a5 & 1) == 0 && fd_truncate((uint64_t)v28, 1028 * *(unsigned int *)(a1 + 148)) == -1)
  {
    v40 = *__error();
    v54 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
      goto LABEL_84;
    v55 = *__error();
    *(_DWORD *)buf = 136315650;
    v104 = "bt_openTrie";
    v105 = 1024;
    v106 = 552;
    v107 = 1024;
    *(_DWORD *)v108 = v55;
    v43 = "%s:%d: ftruncate err: %d";
    goto LABEL_60;
  }
  if (*(_QWORD *)(a1 + 8))
    goto LABEL_29;
  v52 = (void *)fd_mmap(*(_QWORD *)(a1 + 4568));
  *(_QWORD *)(a1 + 8) = v52;
  if (v52 == (void *)-1)
  {
    v40 = *__error();
    v41 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
      goto LABEL_84;
    v60 = *__error();
    v61 = 1028 * *(unsigned int *)(a1 + 148);
    *(_DWORD *)buf = 136315906;
    v104 = "bt_openTrie";
    v105 = 1024;
    v106 = 561;
    v107 = 1024;
    *(_DWORD *)v108 = v60;
    *(_WORD *)&v108[4] = 2048;
    *(_QWORD *)&v108[6] = v61;
    v43 = "%s:%d: fd_mmap err: %d, %ld";
    goto LABEL_82;
  }
  if ((a5 & 1) != 0)
    goto LABEL_55;
  bzero(v52, 0x808uLL);
  v18 = 1538;
LABEL_29:
  v29 = "indexCompactDirectory";
  if (v17)
    v29 = "shadowIndexCompactDirectory";
  snprintf(__str, 0x400uLL, "%s%s", a3, v29);
  v30 = fd_create_protected(a2, __str, v18, 0);
  if (!v30)
  {
    v40 = *__error();
    v41 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
      goto LABEL_84;
    v53 = *__error();
    *(_DWORD *)buf = 136315906;
    v104 = "bt_openTrie";
    v105 = 1024;
    v106 = 616;
    v107 = 2080;
    *(_QWORD *)v108 = __str;
    *(_WORD *)&v108[8] = 1024;
    *(_DWORD *)&v108[10] = v53;
    v43 = "%s:%d: open %s err: %d";
    goto LABEL_82;
  }
  v31 = (uint64_t)v30;
  v32 = "indexArrays";
  if (v17)
    v32 = "shadowIndexArrays";
  snprintf(__str, 0x400uLL, "%s%s", a3, v32);
  v33 = (char *)fd_create_protected(a2, __str, v18, 0);
  if (!v33)
  {
    v40 = *__error();
    v56 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
    {
      v81 = *__error();
      *(_DWORD *)buf = 136315906;
      v104 = "bt_openTrie";
      v105 = 1024;
      v106 = 626;
      v107 = 2080;
      *(_QWORD *)v108 = __str;
      *(_WORD *)&v108[8] = 1024;
      *(_DWORD *)&v108[10] = v81;
      _os_log_error_impl(&dword_1B8270000, v56, OS_LOG_TYPE_ERROR, "%s:%d: open %s err: %d", buf, 0x22u);
    }
    v34 = 0;
    goto LABEL_85;
  }
  v34 = v33;
  if (v19)
  {
    while (1)
    {
      v35 = fstatat(*(_DWORD *)(v31 + 44), *(const char **)(v31 + 72), &v102, 2048);
      v36 = g_prot_error_callback;
      if (v35 != -1 || g_prot_error_callback == 0)
        break;
      v38 = *(unsigned int *)(v31 + 40);
      v39 = __error();
      if (((*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t))(v36 + 16))(v36, v38, *v39, 8) & 1) == 0)
        goto LABEL_95;
    }
    if (v35 == -1)
    {
LABEL_95:
      v40 = *__error();
      v70 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v70, OS_LOG_TYPE_ERROR))
        goto LABEL_85;
      v71 = *__error();
      v72 = "indexCompactDirectory";
      if (v17)
        v72 = "shadowIndexCompactDirectory";
      *(_DWORD *)buf = 136316162;
      v104 = "bt_openTrie";
      v105 = 1024;
      v106 = 636;
      v107 = 1024;
      *(_DWORD *)v108 = v71;
      *(_WORD *)&v108[4] = 2080;
      *(_QWORD *)&v108[6] = a3;
      *(_WORD *)&v108[14] = 2080;
      *(_QWORD *)&v108[16] = v72;
      v67 = "%s:%d: fstat err:%d %s%s";
    }
    else
    {
      if (v102.st_size > *(_QWORD *)(a1 + 40)
        || (v63 = *(_QWORD *)(a1 + 32), v102.st_size < v63) && (unint64_t)v63 >= 9)
      {
        v40 = *__error();
        v64 = _SILogForLogForCategory(0);
        if (!os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
          goto LABEL_85;
        v65 = *(_QWORD *)(a1 + 32);
        v66 = *(_QWORD *)(a1 + 40);
        *(_DWORD *)buf = 136316674;
        v104 = "bt_openTrie";
        v105 = 1024;
        v106 = 640;
        v107 = 1024;
        *(_DWORD *)v108 = v102.st_size;
        *(_WORD *)&v108[4] = 1024;
        *(_DWORD *)&v108[6] = v65;
        *(_WORD *)&v108[10] = 1024;
        *(_DWORD *)&v108[12] = v66;
        *(_WORD *)&v108[16] = 2080;
        *(_QWORD *)&v108[18] = a3;
        *(_WORD *)&v108[26] = 2080;
        *(_QWORD *)v109 = "indexCompactDirectory";
        v67 = "%s:%d: COMP: bad file size:%d (expected %d - %d) %s%s";
        v68 = v64;
        v69 = 56;
        goto LABEL_100;
      }
      if (fd_stat((uint64_t)v34, &v102) != -1)
      {
        v76 = *(_QWORD *)(a1 + 384);
        if (v102.st_size > v76 && !((unint64_t)(v102.st_size - v76) >> 17))
        {
          v77 = *__error();
          v78 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v78, OS_LOG_TYPE_ERROR))
          {
            v95 = *(_QWORD *)(a1 + 384);
            v94 = *(_QWORD *)(a1 + 392);
            v96 = "indexArrays";
            if (v17)
              v96 = "shadowIndexArrays";
            *(_DWORD *)buf = 136316674;
            v104 = "bt_openTrie";
            v105 = 1024;
            v106 = 651;
            v107 = 2048;
            *(_QWORD *)v108 = v102.st_size;
            *(_WORD *)&v108[8] = 2048;
            *(_QWORD *)&v108[10] = v94;
            *(_WORD *)&v108[18] = 2048;
            *(_QWORD *)&v108[20] = v95;
            *(_WORD *)v109 = 2080;
            *(_QWORD *)&v109[2] = a3;
            v110 = 2080;
            v111 = v96;
            _os_log_error_impl(&dword_1B8270000, v78, OS_LOG_TYPE_ERROR, "%s:%d: FLAT: file size:%lld (expected %lld - %lld) %s%s", buf, 0x44u);
          }
          *__error() = v77;
          goto LABEL_113;
        }
        if (v102.st_size <= v76)
        {
          v84 = *(_QWORD *)(a1 + 392);
          if (v102.st_size >= v84 || v84 < 65)
          {
LABEL_113:
            if (a5)
              v57 = 2;
            else
              v57 = 0;
            *(_QWORD *)(a1 + 112) = v31;
            goto LABEL_74;
          }
        }
        v40 = *__error();
        v85 = _SILogForLogForCategory(0);
        if (!os_log_type_enabled(v85, OS_LOG_TYPE_ERROR))
          goto LABEL_85;
        v87 = *(_QWORD *)(a1 + 384);
        v86 = *(_QWORD *)(a1 + 392);
        v88 = "indexArrays";
        if (v17)
          v88 = "shadowIndexArrays";
        *(_DWORD *)buf = 136316674;
        v104 = "bt_openTrie";
        v105 = 1024;
        v106 = 653;
        v107 = 2048;
        *(_QWORD *)v108 = v102.st_size;
        *(_WORD *)&v108[8] = 2048;
        *(_QWORD *)&v108[10] = v86;
        *(_WORD *)&v108[18] = 2048;
        *(_QWORD *)&v108[20] = v87;
        *(_WORD *)v109 = 2080;
        *(_QWORD *)&v109[2] = a3;
        v110 = 2080;
        v111 = v88;
        v67 = "%s:%d: FLAT: bad file size:%lld (expected %lld - %lld) %s%s";
        v68 = v85;
        v69 = 68;
LABEL_100:
        _os_log_error_impl(&dword_1B8270000, v68, OS_LOG_TYPE_ERROR, v67, buf, v69);
        goto LABEL_85;
      }
      v40 = *__error();
      v70 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v70, OS_LOG_TYPE_ERROR))
        goto LABEL_85;
      v82 = *__error();
      v83 = "indexArrays";
      if (v17)
        v83 = "shadowIndexArrays";
      *(_DWORD *)buf = 136316162;
      v104 = "bt_openTrie";
      v105 = 1024;
      v106 = 645;
      v107 = 1024;
      *(_DWORD *)v108 = v82;
      *(_WORD *)&v108[4] = 2080;
      *(_QWORD *)&v108[6] = a3;
      *(_WORD *)&v108[14] = 2080;
      *(_QWORD *)&v108[16] = v83;
      v67 = "%s:%d: fstat err:%d %s%s";
    }
    v68 = v70;
    v69 = 44;
    goto LABEL_100;
  }
  *(_BYTE *)(a1 + 4580) = 1;
  if (a5)
    v57 = 2;
  else
    v57 = 0;
  *(_QWORD *)(a1 + 112) = v31;
  *(_DWORD *)(a1 + 24) = 38;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 32) = xmmword_1B8631C30;
  *(_OWORD *)(a1 + 48) = 0u;
LABEL_74:
  *(_DWORD *)(a1 + 120) = v57;
  *(_BYTE *)(a1 + 124) = 0;
  if ((unint64_t)(*(_QWORD *)(a1 + 16) + 1) <= 1)
  {
    v58 = (void *)fd_mmap(v31);
    *(_QWORD *)(a1 + 16) = v58;
    madvise(v58, *(_QWORD *)(a1 + 40), *(_DWORD *)(a1 + 120));
  }
  if ((a5 & 1) == 0 && fd_truncate(*(_QWORD *)(a1 + 112), *(_QWORD *)(a1 + 40)) == -1)
  {
    v74 = *__error();
    v75 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v75, OS_LOG_TYPE_ERROR))
    {
      v89 = *__error();
      *(_DWORD *)buf = 136315650;
      v104 = "initMF";
      v105 = 1024;
      v106 = 151;
      v107 = 1024;
      *(_DWORD *)v108 = v89;
      _os_log_error_impl(&dword_1B8270000, v75, OS_LOG_TYPE_ERROR, "%s:%d: ftruncate err: %d", buf, 0x18u);
    }
    v31 = 0;
    *__error() = v74;
  }
  else
  {
    if (storageInit(a1 + 160, 0x10000, 0x40uLL, (uint64_t)v34, v19 == 0, 2, a5, a7, a8))
      return 1;
    v34 = 0;
    v31 = 0;
  }
LABEL_86:
  fd_release((char *)v31);
  fd_release(v34);
  v62 = *(void **)(a1 + 8);
  if ((unint64_t)v62 + 1 >= 2)
    munmap(v62, 1028 * *(unsigned int *)(a1 + 148));
  result = 0;
  *(_QWORD *)(a1 + 8) = 0;
  return result;
}

char *__si_assert_copy_extra_1644(_DWORD *a1)
{
  int v2;
  int v3;
  char *v4;
  int v5;
  int v6;
  char *v7;
  const char *v8;
  const char *v9;
  char *v11;
  char v12[1024];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  bzero(v12, 0x400uLL);
  if (!a1
    || (v11 = 0, v2 = _fd_acquire_fd((uint64_t)a1, &v11), v2 == -1)
    || (v3 = v2,
        v4 = v12,
        v5 = fcntl(v2, 50, v12),
        v6 = v12[0],
        _fd_release_fd(a1, v3, 0, (uint64_t)v11),
        v5 < 0)
    || !v6)
  {
    v7 = getcwd(v12, 0x400uLL);
    if (v7)
      v4 = v7;
    else
      v4 = "";
  }
  v11 = 0;
  v8 = (const char *)pthread_getspecific(__THREAD_STR_DATA_KEY);
  if (v8)
    v9 = v8;
  else
    v9 = "";
  asprintf(&v11, "%s %s", v4, v9);
  return v11;
}

uint64_t bt_recoverTrie(uint64_t a1, const char *a2, _DWORD *a3)
{
  uint64_t v6;
  int v7;
  NSObject *v8;
  char v10[1024];
  char __str[1024];
  stat v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  bzero(__str, 0x400uLL);
  bzero(v10, 0x400uLL);
  snprintf(__str, 0x400uLL, "%s%s", a2, "indexDirectory");
  snprintf(v10, 0x400uLL, "%s%s", a2, "shadowIndexDirectory");
  memset(&v12, 0, sizeof(v12));
  if ((fstatat(a1, __str, &v12, 0) || v12.st_mode != 256) && (copyFileFallback(a1, v10, a1, __str, a3, 1, 1) & 1) == 0)
  {
    if (!*a3)
    {
      v7 = *__error();
      v8 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        v12.st_dev = 136315650;
        *(_QWORD *)&v12.st_mode = "bt_recoverTrie";
        WORD2(v12.st_ino) = 1024;
        *(_DWORD *)((char *)&v12.st_ino + 6) = 692;
        HIWORD(v12.st_uid) = 2080;
        *(_QWORD *)&v12.st_gid = __str;
        goto LABEL_23;
      }
LABEL_20:
      v6 = 0;
      *__error() = v7;
      return v6;
    }
    return 0;
  }
  snprintf(__str, 0x400uLL, "%s%s", a2, "indexCompactDirectory");
  snprintf(v10, 0x400uLL, "%s%s", a2, "shadowIndexCompactDirectory");
  memset(&v12, 0, sizeof(v12));
  if ((fstatat(a1, __str, &v12, 0) || v12.st_mode != 256) && (copyFileFallback(a1, v10, a1, __str, a3, 1, 1) & 1) == 0)
  {
    if (!*a3)
    {
      v7 = *__error();
      v8 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        v12.st_dev = 136315650;
        *(_QWORD *)&v12.st_mode = "bt_recoverTrie";
        WORD2(v12.st_ino) = 1024;
        *(_DWORD *)((char *)&v12.st_ino + 6) = 698;
        HIWORD(v12.st_uid) = 2080;
        *(_QWORD *)&v12.st_gid = __str;
        goto LABEL_23;
      }
      goto LABEL_20;
    }
    return 0;
  }
  snprintf(__str, 0x400uLL, "%s%s", a2, "indexArrays");
  snprintf(v10, 0x400uLL, "%s%s", a2, "shadowIndexArrays");
  memset(&v12, 0, sizeof(v12));
  if (fstatat(a1, __str, &v12, 0) || v12.st_mode != 256)
  {
    v6 = 1;
    if ((copyFileFallback(a1, v10, a1, __str, a3, 1, 1) & 1) != 0)
      return v6;
    if (!*a3)
    {
      v7 = *__error();
      v8 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        v12.st_dev = 136315650;
        *(_QWORD *)&v12.st_mode = "bt_recoverTrie";
        WORD2(v12.st_ino) = 1024;
        *(_DWORD *)((char *)&v12.st_ino + 6) = 704;
        HIWORD(v12.st_uid) = 2080;
        *(_QWORD *)&v12.st_gid = __str;
LABEL_23:
        _os_log_error_impl(&dword_1B8270000, v8, OS_LOG_TYPE_ERROR, "%s:%d: Could not recover %s", (uint8_t *)&v12, 0x1Cu);
        goto LABEL_20;
      }
      goto LABEL_20;
    }
    return 0;
  }
  return 1;
}

uint64_t bt_syncTrie(uint64_t a1)
{
  double Current;
  _DWORD *v3;
  uint64_t v4;
  int v5;
  _DWORD *v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  _DWORD *v10;
  uint64_t v11;
  int v12;
  int v13;
  NSObject *v14;
  os_log_type_t v15;
  float v16;
  _BYTE v18[24];
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  Current = CFAbsoluteTimeGetCurrent();
  if (*(_QWORD *)(a1 + 4568))
  {
    msync(*(void **)(a1 + 8), 1028 * (*(_DWORD *)(a1 + 144) + 1), 16);
    v3 = *(_DWORD **)(a1 + 4568);
    *(_QWORD *)v18 = 0;
    v4 = _fd_acquire_fd((uint64_t)v3, v18);
    if ((_DWORD)v4 != -1)
    {
      v5 = v4;
      prot_fsync(v4, 0);
      _fd_release_fd(v3, v5, 0, *(uint64_t *)v18);
    }
  }
  msync(*(void **)(a1 + 16), *(_QWORD *)(a1 + 40), 16);
  v6 = *(_DWORD **)(a1 + 112);
  *(_QWORD *)v18 = 0;
  v7 = _fd_acquire_fd((uint64_t)v6, v18);
  if ((_DWORD)v7 != -1)
  {
    v8 = v7;
    prot_fsync(v7, 0);
    _fd_release_fd(v6, v8, 0, *(uint64_t *)v18);
  }
  v9 = storageSyncPages(a1 + 160, a1 + 4528, 0x20000uLL);
  if (!(_DWORD)v9)
  {
    v10 = *(_DWORD **)(a1 + 376);
    if (v10)
    {
      *(_QWORD *)v18 = 0;
      v11 = _fd_acquire_fd((uint64_t)v10, v18);
      if ((_DWORD)v11 != -1)
      {
        v12 = v11;
        prot_fsync(v11, 0);
        _fd_release_fd(v10, v12, 0, *(uint64_t *)v18);
      }
    }
    v13 = *__error();
    v14 = _SILogForLogForCategory(10);
    v15 = 2 * (dword_1EF19FCB4 < 4);
    if (os_log_type_enabled(v14, v15))
    {
      v16 = CFAbsoluteTimeGetCurrent() - Current;
      *(_DWORD *)v18 = 134217984;
      *(double *)&v18[4] = v16;
      _os_log_impl(&dword_1B8270000, v14, v15, "syncTrie took %f seconds", v18, 0xCu);
    }
    *__error() = v13;
  }
  return v9;
}

uint64_t bt_freeTrie(uint64_t a1)
{
  void *v2;
  const void *v3;

  fd_release(*(char **)(a1 + 4568));
  *(_QWORD *)(a1 + 4568) = 0;
  v2 = *(void **)(a1 + 8);
  if ((unint64_t)v2 + 1 >= 2)
  {
    munmap(v2, 1028 * *(unsigned int *)(a1 + 148));
    *(_QWORD *)(a1 + 8) = 0;
  }
  closeMF(a1 + 16);
  storageClose(a1 + 160);
  v3 = *(const void **)(a1 + 4544);
  if (v3)
  {
    CFRelease(v3);
    *(_QWORD *)(a1 + 4544) = 0;
  }
  *(_OWORD *)(a1 + 4528) = 0u;
  return db_rwlock_destroy((pthread_mutex_t *)(a1 + 4592));
}

uint64_t insertFromBurst(_QWORD *a1, uint64_t a2, unsigned __int8 *a3, uint64_t a4, uint64_t a5, uint64_t a6, unint64_t a7)
{
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  unsigned int v17;
  unint64_t v18;
  BOOL v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int *v23;
  char v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  int v28;
  unsigned int v29;
  BOOL v30;
  int v31;
  unsigned int v33;
  unsigned int v34;
  char v35;
  int v36;
  NSObject *v37;
  os_log_type_t v38;
  unint64_t v39;
  uint64_t v40;
  _DWORD *v41;
  unint64_t v42;
  uint64_t v43;
  unint64_t v44;
  unint64_t v45;
  uint8x8_t v46;
  uint8x8_t v47;
  uint8x8_t v48;
  uint8x8_t v49;
  uint64_t v50;
  unsigned int v51;
  unsigned int v52;
  unint64_t v53;
  BOOL v54;
  unint64_t v55;
  unint64_t v56;
  int v57;
  unint64_t v58;
  uint64_t v59;
  char v60;
  unsigned int v61;
  unsigned int v62;
  unsigned int v63;
  int v64;
  unsigned int v65;
  BOOL v66;
  int v67;
  int v69;
  char v70;
  _DWORD *v71;
  unint64_t v72;
  unint64_t v73;
  uint64_t v74;
  uint8_t *v75;
  unint64_t v76;
  unint64_t v77;
  unint64_t v78;
  unint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint8_t *v82;
  unint64_t v83;
  unint64_t v84;
  unint64_t v85;
  unint64_t v86;
  int v87;
  unint64_t v88;
  __int16 v89;
  char *v90;
  char *v91;
  char *v92;
  char *v93;
  int *v94;
  int v95;
  uint64_t v96;
  uint64_t v97;
  unint64_t v98;
  unint64_t v99;
  uint64_t v100;
  uint64_t v101;
  char v102;
  unsigned int v103;
  uint64_t v104;
  int8x8_t *v105;
  unsigned int v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  unsigned int v110;
  uint8x8_t v111;
  uint8x8_t v112;
  uint8x8_t v113;
  uint8x8_t v114;
  uint64_t v115;
  uint64_t v116;
  _QWORD *v117;
  const void *v118;
  int v119;
  unint64_t v120;
  int v121;
  int *v122;
  unint64_t v125;
  int v126;
  int *v127;
  uint8_t *v128;
  uint64_t v129;
  char *v130;
  char *v131;
  const char *v132;
  char *v133;
  const char *v134;
  char *v135;
  char *v136;
  const char *v137;
  char *v138;
  const char *v139;
  char *v140;
  const char *v141;
  uint64_t v142;
  char *v143;
  char *v144;
  const char *v145;
  unint64_t v146;
  uint64_t v147;
  unsigned int v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v152;
  unint64_t *v153;
  char v154;
  uint64_t v155;
  uint64_t v156;
  int v157;
  uint8_t buf[16];
  __int128 v159;
  __int128 v160;
  __int128 v161;
  __int128 v162;
  __int128 v163;
  __int128 v164;
  __int128 v165;
  __int128 v166;
  __int128 v167;
  __int128 v168;
  __int128 v169;
  uint64_t v170;

  v170 = *MEMORY[0x1E0C80C00];
  v155 = a7;
  if (!a3)
    return a7;
  if (*(_DWORD *)(a2 + 4))
    return 0;
  if (!HIDWORD(a7))
  {
    if ((unint64_t)a7 << 6 >= a1[49])
    {
      v130 = __si_assert_copy_extra_1644(0);
      v131 = v130;
      v132 = "";
      if (v130)
        v132 = v130;
      __message_assert("%s:%u: failed assertion '%s' %s ", "BurstTrie.c", 1088, "flatStoreGetOffset(ptr) < storageGetCount(&t->flatStore)", v132);
LABEL_177:
      free(v131);
      if (__valid_fs(-1))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
    if (appendStringFlat((uint64_t)a1, a2, a7, a4, a3, a5, a6, (unint64_t *)&v155))
    {
      if (!*(_DWORD *)(a2 + 4))
      {
        v155 = burst2(a1, a2, v155);
        if (!*(_DWORD *)(a2 + 4))
        {
          v36 = *__error();
          v37 = _SILogForLogForCategory(10);
          v38 = 2 * (dword_1EF19FCB4 < 4);
          if (os_log_type_enabled(v37, v38))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_1B8270000, v37, v38, "Re-burst!", buf, 2u);
          }
          *__error() = v36;
          return insertFromBurst(a1, a2, a3, a4, a5, a6, v155);
        }
      }
    }
    return v155;
  }
  if (HIDWORD(a7) != 1)
  {
    if (HIDWORD(a7) != 3)
    {
      v143 = __si_assert_copy_extra_1644(0);
      v144 = v143;
      if (v143)
        v145 = v143;
      else
        v145 = "";
      __message_assert("%s:%u: Unexpected code path %s ", "BurstTrie.c", 1100, v145);
      free(v144);
      goto LABEL_190;
    }
    if ((_DWORD)a4)
    {
      v156 = 0;
      v14 = a7;
      v15 = *(_DWORD *)(a1[1] + 1028 * a7 + 4 * *a3 + 4);
      LODWORD(v16) = v15 >> 1;
      v17 = v15 >> 3;
      v18 = (unint64_t)(v15 & 7) << 32;
      if ((v15 & 3) == 1)
      {
        v18 = 0x100000000;
        v17 = v15 >> 2;
      }
      v19 = (v15 & 1) == 0;
      if ((v15 & 1) != 0)
        v20 = v18;
      else
        v20 = 0;
      if (v19)
        v16 = v16;
      else
        v16 = v17;
      v156 = v20 | v16;
      if ((_DWORD)v16)
      {
        v21 = insertFromBurst(a1, a2, a3 + 1, (a4 - 1), a5, a6, v20 | v16);
        v156 = v21;
        v22 = a1[1] + 1028 * v14 + 4 * *a3;
        v25 = *(_DWORD *)(v22 + 4);
        v23 = (unsigned int *)(v22 + 4);
        v24 = v25;
        v26 = v25 >> 1;
        v27 = v25 >> 3;
        v28 = v25 & 7;
        v29 = v25 >> 2;
        if ((v25 & 3) == 1)
        {
          v28 = 1;
          v27 = v29;
        }
        v30 = (v24 & 1) == 0;
        if ((v24 & 1) != 0)
          v31 = v28;
        else
          v31 = 0;
        if (!v30)
          v26 = v27;
        if (v26 == (_DWORD)v21 && v31 == HIDWORD(v21))
          return v155;
        v33 = HIDWORD(v21) | (8 * v21);
        if (!HIDWORD(v21))
          v33 = 2 * v21;
        if (HIDWORD(v21) == 1)
          v34 = (4 * v21) | 1;
        else
          v34 = v33;
        if ((v34 & 3) == 1)
          v35 = 2;
        else
          v35 = 3;
        if ((v34 & 1) == 0)
          v35 = 1;
        if (v34 >> v35 != (_DWORD)v21)
          goto LABEL_174;
        goto LABEL_85;
      }
      if (*(_DWORD *)a2)
      {
        v153 = (unint64_t *)(a2 + 2148);
        v85 = *(_QWORD *)(a2 + 2148);
        v168 = 0u;
        v169 = 0u;
        v166 = 0u;
        v167 = 0u;
        v165 = 0u;
        v163 = 0u;
        v164 = 0u;
        v161 = 0u;
        v162 = 0u;
        v159 = 0u;
        v160 = 0u;
        *(_OWORD *)buf = 0u;
        v157 = 0;
        v86 = flatStoreNewBlockForCompact((uint64_t)(a1 + 20), v85, (uint64_t)buf, &v157);
        if (v157)
          dirtyStorageOffsets((uint64_t)(a1 + 20), (unint64_t *)buf, v157);
        v156 = v86;
        *v153 = v86;
        if (v86)
        {
LABEL_104:
          appendStringFlat((uint64_t)a1, a2, v86, a4 - 1, a3 + 1, a5, a6, (unint64_t *)&v156);
          if (!*(_DWORD *)(a2 + 4))
            goto LABEL_120;
          goto LABEL_155;
        }
      }
      else
      {
        v86 = trieNewFlatStoreBlock((uint64_t)a1, (int)a4 - 1);
        v156 = v86;
        if (v86)
          goto LABEL_104;
      }
      v94 = __error();
      v95 = *v94;
      *(_DWORD *)(a2 + 4) = *v94;
      if (!v95)
      {
LABEL_120:
        v96 = a1[1] + 1028 * v14 + 4 * *a3;
        *(_DWORD *)(v96 + 4) = ptrD(v156);
        return v155;
      }
LABEL_155:
      LODWORD(v156) = 0;
      return v156;
    }
    v71 = (_DWORD *)(a1[1] + 1028 * a7);
    if (!*v71)
    {
      if (*(_DWORD *)a2 != 1)
      {
        *v71 = a5;
        return a7;
      }
      v148 = a7;
      v72 = *(_QWORD *)(a2 + 2148);
      v168 = 0u;
      v169 = 0u;
      v166 = 0u;
      v167 = 0u;
      v165 = 0u;
      v163 = 0u;
      v164 = 0u;
      v161 = 0u;
      v162 = 0u;
      v159 = 0u;
      v160 = 0u;
      *(_OWORD *)buf = 0u;
      v157 = 0;
      v147 = (uint64_t)(a1 + 20);
      v73 = flatStoreNewBlockForCompact((uint64_t)(a1 + 20), v72, (uint64_t)buf, &v157);
      v74 = v157;
      if (v157 >= 1)
      {
        v75 = buf;
        do
        {
          v77 = *(_QWORD *)v75;
          v75 += 8;
          v76 = v77;
          bit_vector_set_2851((uint64_t)(a1 + 566), (v77 >> 17));
          if ((v77 >> 17) != (v77 + 8) >> 17)
            bit_vector_set_2851((uint64_t)(a1 + 566), (v76 >> 17) + 1);
          --v74;
        }
        while (v74);
      }
      *(_DWORD *)(a2 + 2148) = v73;
      *(_DWORD *)(a2 + 2152) = 0;
      if ((_DWORD)v73)
      {
        *(_OWORD *)buf = 0u;
        *(_QWORD *)&v159 = a5;
        *((_QWORD *)&v159 + 1) = a6;
        v90 = storageResolvePtr(v147, v73 << 6, 8uLL, 1);
        v91 = storageResolvePtr(v147, v73 << 6, 64 << v90[2], 1);
        *(_OWORD *)(a2 + 1084) = 0u;
        *(_WORD *)v91 = FlatStorePageEntryWrite2((uint64_t)v91, (unsigned int *)buf, (uint64_t *)(a2 + 1084));
        *(_DWORD *)(a1[1] + 1028 * v148) = 0;
        if ((v73 & 0x80000000) == 0)
        {
          *(_DWORD *)(a1[1] + 1028 * v148) = 2 * v73;
LABEL_116:
          *(_DWORD *)(a2 + 36) = 0;
          *(_DWORD *)(a2 + 24) = 0;
          return a7;
        }
        goto LABEL_174;
      }
      goto LABEL_117;
    }
    v135 = __si_assert_copy_extra_1644(0);
    v136 = v135;
    v137 = "";
    if (v135)
      v137 = v135;
    __message_assert("%s:%u: failed assertion '%s' %s ", "BurstTrie.c", 874, "getNum(t->baseFat[s].termInfo.termId.ptr)==0", v137);
LABEL_189:
    free(v136);
    if (!__valid_fs(-1))
    {
      v142 = 3072;
LABEL_192:
      *(_DWORD *)v142 = -559038737;
      abort();
    }
LABEL_190:
    v142 = 2989;
    goto LABEL_192;
  }
  v39 = a7;
  v40 = mgetBase((uint64_t)a1, a7);
  v41 = (_DWORD *)v40;
  if (!(_DWORD)a4)
  {
    if (!*(_DWORD *)v40)
    {
      if (*(_DWORD *)a2 != 1)
      {
        *(_DWORD *)v40 = a5;
        return a7;
      }
      v78 = *(_QWORD *)(a2 + 2148);
      v168 = 0u;
      v169 = 0u;
      v166 = 0u;
      v167 = 0u;
      v165 = 0u;
      v163 = 0u;
      v164 = 0u;
      v161 = 0u;
      v162 = 0u;
      v159 = 0u;
      v160 = 0u;
      *(_OWORD *)buf = 0u;
      v157 = 0;
      v149 = (uint64_t)(a1 + 20);
      v152 = a6;
      v79 = flatStoreNewBlockForCompact((uint64_t)(a1 + 20), v78, (uint64_t)buf, &v157);
      v80 = v157;
      if (v157 >= 1)
      {
        v81 = (uint64_t)(a1 + 566);
        v82 = buf;
        do
        {
          v84 = *(_QWORD *)v82;
          v82 += 8;
          v83 = v84;
          bit_vector_set_2851(v81, (v84 >> 17));
          if ((v84 >> 17) != (v84 + 8) >> 17)
            bit_vector_set_2851(v81, (v83 >> 17) + 1);
          --v80;
        }
        while (v80);
      }
      *(_DWORD *)(a2 + 2148) = v79;
      *(_DWORD *)(a2 + 2152) = 0;
      if ((_DWORD)v79)
      {
        *(_OWORD *)buf = 0u;
        *(_QWORD *)&v159 = a5;
        *((_QWORD *)&v159 + 1) = v152;
        v92 = storageResolvePtr(v149, v79 << 6, 8uLL, 1);
        v93 = storageResolvePtr(v149, v79 << 6, 64 << v92[2], 1);
        *(_OWORD *)(a2 + 1084) = 0u;
        *(_WORD *)v93 = FlatStorePageEntryWrite2((uint64_t)v93, (unsigned int *)buf, (uint64_t *)(a2 + 1084));
        *v41 = 0;
        if ((v79 & 0x80000000) == 0)
        {
          *v41 = 2 * v79;
          goto LABEL_116;
        }
LABEL_174:
        v133 = __si_assert_copy_extra_1644(0);
        v131 = v133;
        v134 = "";
        if (v133)
          v134 = v133;
        __message_assert("%s:%u: failed assertion '%s' %s ", "BurstTrie.h", 81, "ptrM(newptr).next == ptr.next", v134);
        goto LABEL_177;
      }
LABEL_117:
      *(_DWORD *)(a2 + 4) = *__error();
      return 0;
    }
    v138 = __si_assert_copy_extra_1644(0);
    v136 = v138;
    v139 = "";
    if (v138)
      v139 = v138;
    __message_assert("%s:%u: failed assertion '%s' %s ", "BurstTrie.c", 934, "getNum(b->termInfo.termId.ptr)==0", v139);
    goto LABEL_189;
  }
  v42 = *a3;
  if (((*(_DWORD *)(v40 + ((v42 >> 3) & 0x1C) + 4) >> v42) & 1) != 0)
  {
    v43 = 0;
    v44 = v40 + 4;
    v45 = v42 >> 6;
    if ((v42 >> 6) != 1)
    {
      if ((_DWORD)v45 != 2)
      {
        if ((_DWORD)v45 != 3)
        {
LABEL_55:
          v49 = (uint8x8_t)vcnt_s8((int8x8_t)(*(_QWORD *)(v44 + 8 * v45) & ~(-1 << v42)));
          v49.i16[0] = vaddlv_u8(v49);
          v50 = v49.u32[0] + v43;
          v51 = *(_DWORD *)(v40 + 4 * v50 + 38);
          LODWORD(v44) = v51 >> 1;
          v52 = v51 >> 3;
          v53 = (unint64_t)(v51 & 7) << 32;
          if ((v51 & 3) == 1)
          {
            v53 = 0x100000000;
            v52 = v51 >> 2;
          }
          v54 = (v51 & 1) == 0;
          if ((v51 & 1) != 0)
            v55 = v53;
          else
            v55 = 0;
          if (v54)
            v44 = v44;
          else
            v44 = v52;
          v56 = insertFromBurst(a1, a2, a3 + 1, (a4 - 1), a5, a6, v55 | v44);
          v57 = v56;
          if (!(_DWORD)v56)
            return v155;
          v58 = HIDWORD(v56);
          v59 = mgetBase((uint64_t)a1, v39) + 4 * v50;
          v61 = *(_DWORD *)(v59 + 38);
          v23 = (unsigned int *)(v59 + 38);
          v60 = v61;
          v62 = v61 >> 1;
          v63 = v61 >> 3;
          v64 = v61 & 7;
          v65 = v61 >> 2;
          if ((v61 & 3) == 1)
          {
            v64 = 1;
            v63 = v65;
          }
          v66 = (v60 & 1) == 0;
          if ((v60 & 1) != 0)
            v67 = v64;
          else
            v67 = 0;
          if (!v66)
            v62 = v63;
          if (v67 == (_DWORD)v58 && v62 == v57)
            return v155;
          v34 = (4 * v57) | 1;
          v69 = v58 | (8 * v57);
          if (!(_DWORD)v58)
            v69 = 2 * v57;
          if ((_DWORD)v58 != 1)
            v34 = v69;
          if ((v34 & 3) == 1)
            v70 = 2;
          else
            v70 = 3;
          if ((v34 & 1) == 0)
            v70 = 1;
          if (v34 >> v70 == v57)
          {
LABEL_85:
            *v23 = v34;
            return v155;
          }
          v140 = __si_assert_copy_extra_1644(0);
          v136 = v140;
          v141 = "";
          if (v140)
            v141 = v140;
          __message_assert("%s:%u: failed assertion '%s' %s ", "BurstTrie.h", 81, "ptrM(newptr).next == ptr.next", v141);
          goto LABEL_189;
        }
        v46 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v40 + 20));
        v46.i16[0] = vaddlv_u8(v46);
        v43 = v46.u32[0];
      }
      v47 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v40 + 12));
      v47.i16[0] = vaddlv_u8(v47);
      v43 += v47.u32[0];
    }
    v48 = (uint8x8_t)vcnt_s8(*(int8x8_t *)v44);
    v48.i16[0] = vaddlv_u8(v48);
    v43 += v48.u32[0];
    goto LABEL_55;
  }
  v87 = *(unsigned __int8 *)(v40 + 36);
  HIDWORD(v88) = v87;
  LODWORD(v88) = v87 - 4;
  v89 = 16;
  switch((v88 >> 2))
  {
    case 0u:
      v89 = 8;
      goto LABEL_122;
    case 1u:
      goto LABEL_122;
    case 3u:
      v89 = 32;
LABEL_122:
      v150 = *(unsigned __int8 *)(v40 + 36);
      v154 = v89;
      v97 = (4 * v89 + 41) & 0x1E8;
      v98 = mmalloc((4 * v89 + 41) & 0x1E8, (uint64_t)(a1 + 2), *(uint64_t (**)(uint64_t))(a2 + 2160), *(_QWORD *)(a2 + 2168));
      if (v98)
      {
        v146 = v98;
        v99 = v98 >> 2;
        v100 = mgetBase((uint64_t)a1, v98 >> 2);
        if (v97 >= 0x20)
        {
          v101 = v97 - 8;
          *(_OWORD *)v100 = 0u;
          *(_OWORD *)(v100 + 16) = 0u;
          v102 = v154;
          if (v97 != 40)
          {
            *(_OWORD *)(v100 + 32) = 0uLL;
            *(_OWORD *)(v100 + 48) = 0uLL;
            if (v97 != 72)
            {
              *(_OWORD *)(v100 + 64) = 0uLL;
              *(_OWORD *)(v100 + 80) = 0uLL;
              if (v97 != 104)
              {
                *(_OWORD *)(v100 + 96) = 0uLL;
                *(_OWORD *)(v100 + 112) = 0uLL;
                if (v97 != 136)
                {
                  *(_OWORD *)(v100 + 128) = 0uLL;
                  *(_OWORD *)(v100 + 144) = 0uLL;
                }
              }
            }
          }
        }
        else
        {
          v101 = 0;
          v102 = v154;
        }
        v116 = v101 - v97;
        v117 = (_QWORD *)(v100 + v101);
        do
        {
          *v117++ = 0;
          v116 += 8;
        }
        while (v116);
        *(_BYTE *)(v100 + 37) = v102;
        LODWORD(v155) = v99;
        if ((_DWORD)v99)
        {
          v41 = (_DWORD *)mgetBase((uint64_t)a1, (v146 >> 2));
          v118 = (const void *)mgetBase((uint64_t)a1, a7);
          memcpy(v41, v118, 4 * v150 + 38);
          *((_BYTE *)v41 + 37) = v154;
          mfree((4 * a7), (4 * (_WORD)v150 + 41) & 0x7FC, a1 + 2);
          LODWORD(v42) = *a3;
LABEL_147:
          v119 = set_follows((uint64_t)v41, v42);
          if (*(_DWORD *)a2)
          {
            v120 = trieNewFlatStoreBlockForCompact((uint64_t)a1, *(_QWORD *)(a2 + 2148));
            *(_QWORD *)(a2 + 2148) = v120;
          }
          else
          {
            v120 = trieNewFlatStoreBlock((uint64_t)a1, (int)a4 - 1);
          }
          v156 = v120;
          if (v120)
          {
            appendStringFlat((uint64_t)a1, a2, v120, a4 - 1, a3 + 1, a5, a6, (unint64_t *)&v156);
            v121 = *(_DWORD *)(a2 + 4);
          }
          else
          {
            v122 = __error();
            v121 = *v122;
            *(_DWORD *)(a2 + 4) = *v122;
          }
          if (!v121)
          {
            *(_DWORD *)((char *)&v41[v119 + 9] + 2) = ptrD(v156);
            return v155;
          }
          goto LABEL_155;
        }
      }
      else
      {
        LODWORD(v155) = 0;
      }
LABEL_149:
      *(_DWORD *)(a2 + 4) = *__error();
      return v155;
    case 7u:
      v103 = newbaseFat((uint64_t)a1, *(uint64_t (**)(uint64_t))(a2 + 2160), *(_QWORD *)(a2 + 2168));
      v155 = v103 | 0x300000000;
      if (!v103)
        goto LABEL_149;
      v104 = 0;
      v105 = (int8x8_t *)(v41 + 1);
      v106 = v103;
      v107 = 1028 * v103 + 4;
      break;
    default:
      goto LABEL_147;
  }
  do
  {
    if (((v41[(v104 >> 5) + 1] >> v104) & 1) == 0)
    {
      v108 = a1[1];
      *(_DWORD *)(v108 + v107 + 4 * v104) = 0;
      goto LABEL_129;
    }
    v109 = 0;
    v110 = v104 >> 6;
    if (v104 >> 6 == 1)
      goto LABEL_136;
    if (v110 == 2)
      goto LABEL_135;
    if (v110 == 3)
    {
      v111 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v41 + 5));
      v111.i16[0] = vaddlv_u8(v111);
      v109 = v111.u32[0];
LABEL_135:
      v112 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v41 + 3));
      v112.i16[0] = vaddlv_u8(v112);
      v109 += v112.u32[0];
LABEL_136:
      v113 = (uint8x8_t)vcnt_s8(*v105);
      v113.i16[0] = vaddlv_u8(v113);
      v109 += v113.u32[0];
    }
    v114 = (uint8x8_t)vcnt_s8((int8x8_t)(*(_QWORD *)&v105[v110] & ~(-1 << v104)));
    v114.i16[0] = vaddlv_u8(v114);
    v115 = v114.u32[0] + v109;
    v108 = a1[1];
    *(_DWORD *)(v108 + v107 + 4 * v104) = *(_DWORD *)((char *)&v41[v115 + 9] + 2);
LABEL_129:
    ++v104;
  }
  while (v104 != 256);
  *(_DWORD *)(v108 + 1028 * v103) = *v41;
  if (*(_DWORD *)a2)
  {
    v125 = trieNewFlatStoreBlockForCompact((uint64_t)a1, *(_QWORD *)(a2 + 2148));
    *(_QWORD *)(a2 + 2148) = v125;
  }
  else
  {
    v125 = trieNewFlatStoreBlock((uint64_t)a1, (int)a4 - 1);
  }
  *(_QWORD *)buf = v125;
  if (v125)
  {
    appendStringFlat((uint64_t)a1, a2, v125, a4 - 1, a3 + 1, a5, a6, (unint64_t *)buf);
    v126 = *(_DWORD *)(a2 + 4);
  }
  else
  {
    v127 = __error();
    v126 = *v127;
    *(_DWORD *)(a2 + 4) = *v127;
  }
  if (v126)
  {
    *(_DWORD *)buf = 0;
    v128 = buf;
  }
  else
  {
    v129 = a1[1] + 1028 * v106 + 4 * *a3;
    *(_DWORD *)(v129 + 4) = ptrD(*(uint64_t *)buf);
    mfree((4 * a7), (4 * (_WORD)v87 + 41) & 0x7FC, a1 + 2);
    v128 = (uint8_t *)&v155;
  }
  return *(_QWORD *)v128;
}

uint64_t FlatStorePageEntryWrite2(uint64_t a1, unsigned int *a2, uint64_t *a3)
{
  _BYTE *v5;
  unsigned int v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  _BYTE *v10;
  _BYTE *v11;
  _BYTE *v12;
  _BYTE *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;

  v5 = (_BYTE *)(a1 + 8);
  v6 = *a2;
  if (*a2 > 0x7F)
  {
    if (v6 >> 14)
    {
      if (v6 >> 21)
      {
        if (v6 >> 28)
        {
          *(_BYTE *)(a1 + 8) = -16;
          *(_DWORD *)(a1 + 9) = v6;
          v7 = 5;
        }
        else
        {
          *(_BYTE *)(a1 + 8) = HIBYTE(v6) | 0xE0;
          *(_BYTE *)(a1 + 9) = BYTE2(v6);
          *(_BYTE *)(a1 + 10) = BYTE1(v6);
          *(_BYTE *)(a1 + 11) = v6;
          v7 = 4;
        }
      }
      else
      {
        *(_BYTE *)(a1 + 8) = BYTE2(v6) | 0xC0;
        *(_BYTE *)(a1 + 9) = BYTE1(v6);
        *(_BYTE *)(a1 + 10) = v6;
        v7 = 3;
      }
    }
    else
    {
      *(_BYTE *)(a1 + 8) = BYTE1(v6) | 0x80;
      *(_BYTE *)(a1 + 9) = v6;
      v7 = 2;
    }
  }
  else
  {
    *v5 = v6;
    v7 = 1;
  }
  v8 = a2[1];
  if (v8 <= 0x7F)
  {
    v9 = v7 + 1;
    v5[v7] = v8;
    if (!*a2)
      goto LABEL_26;
LABEL_23:
    v14 = 0;
    do
    {
      *(_BYTE *)(v9 + a1 + 8 + v14) = *(_BYTE *)(*((_QWORD *)a2 + 1) + v14);
      ++v14;
    }
    while (v14 < *a2);
    v9 += v14;
    goto LABEL_26;
  }
  if (v8 >> 14)
  {
    if (v8 >> 21)
    {
      if (v8 >> 28)
      {
        v13 = &v5[v7];
        *v13 = -16;
        *(_DWORD *)(v13 + 1) = v8;
        v9 = v7 + 5;
        if (!*a2)
          goto LABEL_26;
        goto LABEL_23;
      }
      v12 = &v5[v7];
      *v12 = HIBYTE(v8) | 0xE0;
      v12[1] = BYTE2(v8);
      v12[2] = BYTE1(v8);
      v9 = v7 + 4;
      v12[3] = v8;
      if (*a2)
        goto LABEL_23;
    }
    else
    {
      v11 = &v5[v7];
      *v11 = BYTE2(v8) | 0xC0;
      v11[1] = BYTE1(v8);
      v9 = v7 + 3;
      v11[2] = v8;
      if (*a2)
        goto LABEL_23;
    }
  }
  else
  {
    v10 = &v5[v7];
    *v10 = BYTE1(v8) | 0x80;
    v9 = v7 + 2;
    v10[1] = v8;
    if (*a2)
      goto LABEL_23;
  }
LABEL_26:
  v15 = *((_QWORD *)a2 + 2);
  v16 = *a3;
  *a3 = v15;
  v17 = v2_writeVInt64(a1 + 8, v9, v15 - v16);
  v18 = *((_QWORD *)a2 + 3);
  if (v18)
  {
    v19 = a3[1];
    a3[1] = v18;
    v20 = v18 - v19;
  }
  else
  {
    v20 = 0;
  }
  return v2_writeVInt64((uint64_t)v5, v17, v20);
}

uint64_t trieNewFlatStoreBlock(uint64_t a1, int a2)
{
  int v3;
  unsigned int v4;
  unint64_t v5;
  unint64_t v6;
  char *v7;
  char v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t v14;
  unsigned int v16;
  _OWORD v17[12];
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v16 = 0;
  v3 = 64;
  do
  {
    v4 = v3;
    v3 *= 2;
  }
  while (v4 < a2 + 23);
  memset(v17, 0, sizeof(v17));
  v5 = storageAllocOffset(a1 + 160, v4, (uint64_t)v17, (int *)&v16);
  if (v5)
  {
    v6 = v5;
    v7 = storageResolvePtr(a1 + 160, v5, v4, 1);
    *(_WORD *)v7 = 0;
    v8 = __clz(__rbit32(v4 >> 6));
    if (!v4)
      v8 = -1;
    v7[2] = v8;
    v9 = (v6 >> 6);
  }
  else
  {
    v9 = 0;
  }
  v10 = v16;
  if ((int)v16 >= 1)
  {
    v11 = a1 + 4528;
    v12 = (unint64_t *)v17;
    do
    {
      v14 = *v12++;
      v13 = v14;
      bit_vector_set_2851(v11, (v14 >> 17));
      if ((v14 >> 17) != (v14 + 8) >> 17)
        bit_vector_set_2851(v11, (v13 >> 17) + 1);
      --v10;
    }
    while (v10);
  }
  return v9;
}

uint64_t ptrD(uint64_t a1)
{
  int v1;
  unsigned int v2;
  uint64_t result;
  char v4;
  char *v5;
  char *v6;
  const char *v7;

  v1 = a1;
  v2 = HIDWORD(a1) | (8 * a1);
  if (!HIDWORD(a1))
    v2 = 2 * a1;
  if (HIDWORD(a1) == 1)
    result = (4 * (_DWORD)a1) | 1u;
  else
    result = v2;
  if ((result & 3) == 1)
    v4 = 2;
  else
    v4 = 3;
  if ((result & 1) == 0)
    v4 = 1;
  if (result >> v4 != v1)
  {
    v5 = __si_assert_copy_extra_1644(0);
    v6 = v5;
    v7 = "";
    if (v5)
      v7 = v5;
    __message_assert("%s:%u: failed assertion '%s' %s ", "BurstTrie.h", 81, "ptrM(newptr).next == ptr.next", v7);
    free(v6);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  return result;
}

uint64_t newbaseFat(uint64_t a1, uint64_t (*a2)(uint64_t), uint64_t a3)
{
  unint64_t v5;
  uint64_t v6;
  unint64_t v8;

  v5 = *(unsigned int *)(a1 + 148);
  v6 = (*(_DWORD *)(a1 + 144) + 1);
  if (v6 < v5)
    goto LABEL_5;
  v8 = 0;
  if (!expandUnsafeMapNew((void **)(a1 + 8), *(_QWORD *)(a1 + 4568), v5, 0x404uLL, &v8, a2, a3))
  {
    *(_DWORD *)(a1 + 148) = v8;
LABEL_5:
    *(_DWORD *)(a1 + 144) = v6;
    return v6;
  }
  v6 = 0;
  *__error() = -1;
  return v6;
}

unint64_t trieNewFlatStoreBlockForCompact(uint64_t a1, unint64_t a2)
{
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t v7;
  unint64_t v8;
  unsigned int v10;
  _OWORD v11[12];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  memset(v11, 0, sizeof(v11));
  v10 = 0;
  v3 = flatStoreNewBlockForCompact(a1 + 160, a2, (uint64_t)v11, (int *)&v10);
  v4 = v10;
  if ((int)v10 >= 1)
  {
    v5 = a1 + 4528;
    v6 = (unint64_t *)v11;
    do
    {
      v8 = *v6++;
      v7 = v8;
      bit_vector_set_2851(v5, (v8 >> 17));
      if ((v8 >> 17) != (v8 + 8) >> 17)
        bit_vector_set_2851(v5, (v7 >> 17) + 1);
      --v4;
    }
    while (v4);
  }
  return v3;
}

uint64_t set_follows(uint64_t a1, unsigned int a2)
{
  __int32 v3;
  uint64_t v4;
  int8x8_t *v5;
  unsigned int v6;
  uint8x8_t v7;
  uint8x8_t v8;
  uint8x8_t v9;
  uint8x8_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  BOOL v15;
  uint64_t v16;
  int *v17;
  _DWORD *v18;
  int v19;
  unsigned __int8 v20;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  _OWORD *v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  char *v29;
  char *v30;
  const char *v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;

  v3 = 0;
  v4 = *(unsigned __int8 *)(a1 + 36);
  v5 = (int8x8_t *)(a1 + 4);
  *(_DWORD *)(a1 + 4 + 4 * (a2 >> 5)) |= 1 << a2;
  v6 = a2 >> 6;
  if (a2 >> 6 != 1)
  {
    if (v6 != 2)
    {
      if (v6 != 3)
        goto LABEL_7;
      v7 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(a1 + 20));
      v7.i16[0] = vaddlv_u8(v7);
      v3 = v7.i32[0];
    }
    v8 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(a1 + 12));
    v8.i16[0] = vaddlv_u8(v8);
    v3 += v8.i32[0];
  }
  v9 = (uint8x8_t)vcnt_s8(*v5);
  v9.i16[0] = vaddlv_u8(v9);
  v3 += v9.i32[0];
LABEL_7:
  v10 = (uint8x8_t)vcnt_s8((int8x8_t)(*(_QWORD *)&v5[v6] & ~(-1 << a2)));
  v10.i16[0] = vaddlv_u8(v10);
  v11 = (v3 + v10.i32[0]);
  if (v11 >= v4)
    goto LABEL_17;
  v12 = (~(_DWORD)v11 + v4);
  if (v12 < 0x2B
    || ((v13 = 4 * v4 + a1, v14 = 4 * (v4 - 1) + a1, v13 + 38 - 4 * v12 <= (unint64_t)(v13 + 38))
      ? (v15 = v14 + 38 - 4 * v12 > (unint64_t)(v14 + 38))
      : (v15 = 1),
        v15 || (unint64_t)(v14 - v13) < 0x20))
  {
    v16 = v4;
    goto LABEL_15;
  }
  v22 = v12 + 1;
  v23 = (v12 + 1) & 0x1FFFFFFF8;
  v24 = v4 + 0xFFFFFFFFLL;
  v25 = (_OWORD *)(4 * v4 + a1 + 26);
  v26 = v23;
  do
  {
    v27 = a1 + 4 * v24;
    v28 = *(_OWORD *)(v27 + 26);
    *(v25 - 1) = *(_OWORD *)(v27 + 10);
    *v25 = v28;
    v24 -= 8;
    v25 -= 2;
    v26 -= 8;
  }
  while (v26);
  if (v22 != v23)
  {
    v16 = v4 - v23;
LABEL_15:
    v17 = (int *)(a1 + 4 * (v16 - 1) + 38);
    v18 = (_DWORD *)(a1 + 4 * v16 + 38);
    do
    {
      v19 = *v17--;
      *v18-- = v19;
      LODWORD(v16) = v16 - 1;
    }
    while (v11 < v16);
  }
LABEL_17:
  v20 = v4 + 1;
  *(_BYTE *)(a1 + 36) = v20;
  if (*(unsigned __int8 *)(a1 + 37) < v20)
  {
    if ((__native_fs() & 1) == 0)
    {
      v32 = __si_assert_copy_extra_1644(0);
      si_analytics_log_1684((uint64_t)v32, v33, v34, v35, v36, v37, v38, v39, (char)"BurstTrie.c");
      free(v32);
      MEMORY[0xB00] = -559038737;
      abort();
    }
    if (*(unsigned __int8 *)(a1 + 37) < *(unsigned __int8 *)(a1 + 36))
    {
      v29 = __si_assert_copy_extra_1644(0);
      v30 = v29;
      v31 = "";
      if (v29)
        v31 = v29;
      __message_assert("%s:%u: failed assertion '%s' %s %d < %d", "BurstTrie.c", 327, "t->size>=t->count", v31, *(unsigned __int8 *)(a1 + 37), *(unsigned __int8 *)(a1 + 36));
      free(v30);
      if (__valid_fs(-1))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
  }
  return v11;
}

unint64_t burst2(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  int *v12;
  char *v14;
  char *v15;
  const char *v16;
  __int128 v17;

  if (*(_DWORD *)(a2 + 4))
  {
    v4 = 0;
    v5 = a3 & 0xFFFFFFFF00000000;
  }
  else
  {
    v8 = mmalloc(0x38u, a1 + 16, *(uint64_t (**)(uint64_t))(a2 + 2160), *(_QWORD *)(a2 + 2168));
    if (v8
      && (v9 = v8,
          v10 = mgetBase(a1, v8 >> 2),
          *(_OWORD *)(v10 + 16) = 0u,
          *(_OWORD *)(v10 + 32) = 0u,
          *(_OWORD *)v10 = 0u,
          *(_QWORD *)(v10 + 48) = 0,
          *(_BYTE *)(v10 + 37) = 4,
          (v9 & 0x3FFFFFFFCLL) != 0))
    {
      if (HIDWORD(a3))
      {
        v14 = __si_assert_copy_extra_1644(0);
        v15 = v14;
        v16 = "";
        if (v14)
          v16 = v14;
        __message_assert("%s:%u: failed assertion '%s' %s ", "BurstTrie.c", 3573, "oldPtr.kind == FLAT", v16);
        free(v15);
        if (__valid_fs(-1))
        {
          MEMORY[0xBAD] = -559038737;
          abort();
        }
        MEMORY[0xC00] = -559038737;
        abort();
      }
      v17 = *(_OWORD *)(a2 + 1084);
      v11 = burstFlat(a1, (int *)a2, a3, (v9 >> 2) | 0x100000000);
      v5 = v11 & 0xFFFFFFFF00000000;
      *(_OWORD *)(a2 + 1084) = v17;
      v4 = v11;
    }
    else
    {
      v12 = __error();
      v4 = 0;
      *(_DWORD *)(a2 + 4) = *v12;
      v5 = 0x100000000;
    }
  }
  return v5 | v4;
}

void si_analytics_log_1684(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  xpc_object_t v9;
  xpc_object_t v10;
  char *string[2];
  xpc_object_t values;
  _BYTE keys[24];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  string[0] = 0;
  string[1] = &a9;
  vasprintf(string, "%s:%u: failed assertion '%s' %s %d < %d", &a9);
  SISetCrashCStr(string[0]);
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)keys = 136315138;
    *(char **)&keys[4] = string[0];
    _os_log_fault_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "%s", keys, 0xCu);
  }
  *(_QWORD *)keys = "crash_string";
  v9 = xpc_string_create(string[0]);
  values = v9;
  v10 = xpc_dictionary_create((const char *const *)keys, &values, 1uLL);
  analytics_send_event();
  xpc_release(v10);
  xpc_release(v9);
  free(string[0]);
}

uint64_t bt_shadowTrie(uint64_t a1, const char *a2, int a3, _DWORD *a4)
{
  _BYTE *v4;
  BOOL v5;
  char v7;
  CFNumberRef v10;
  int v11;
  double Current;
  char v13;
  int v14;
  NSObject *v15;
  os_log_type_t v16;
  float v17;
  double v18;
  char v19;
  int v20;
  NSObject *v21;
  os_log_type_t v22;
  float v23;
  uint64_t v24;
  CFIndex v25;
  uint64_t v26;
  uint64_t result;
  double v28;
  _QWORD *v29;
  uint64_t v30;
  int v31;
  int v32;
  void *v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  int v39;
  NSObject *v40;
  os_log_type_t v41;
  float v42;
  unsigned int v43;
  int v44;
  NSObject *v45;
  NSObject *v46;
  int v47;
  NSObject *v48;
  double v49;
  _QWORD *v50;
  char *v51;
  unint64_t v52;
  uint64_t v53;
  int v54;
  NSObject *v55;
  os_log_type_t v56;
  float v57;
  double v58;
  _QWORD *v59;
  int v60;
  int v61;
  uint64_t v62;
  void *v63;
  void *v64;
  size_t v65;
  _DWORD *v66;
  unsigned int v67;
  unsigned int v68;
  unsigned int v69;
  uint64_t v70;
  unsigned int v71;
  unsigned int v72;
  int v73;
  NSObject *v74;
  const char *v75;
  NSObject *v76;
  int v77;
  NSObject *v78;
  uint64_t v79;
  CFIndex v80;
  CFIndex v81;
  uint64_t v82;
  CFIndex v83;
  NSObject *v84;
  NSObject *v85;
  uint64_t v86;
  char *v87;
  CFIndex v88;
  char *v89;
  CFIndex v90;
  int v91;
  NSObject *v92;
  os_log_type_t v93;
  float v94;
  NSObject *v95;
  const char *v96;
  char *v97;
  char *v98;
  const char *v99;
  uint64_t v100;
  CFIndex *v101;
  unsigned int v102;
  unsigned int __fd;
  void *__buf;
  uint64_t v105;
  uint64_t v106;
  char v107[1024];
  _BYTE buf[12];
  __int16 v109;
  int v110;
  __int16 v111;
  _BYTE v112[18];
  char __str[16];
  __int128 v114;
  __int128 v115;
  __int128 v116;
  __int128 v117;
  __int128 v118;
  __int128 v119;
  __int128 v120;
  __int128 v121;
  __int128 v122;
  __int128 v123;
  __int128 v124;
  __int128 v125;
  __int128 v126;
  __int128 v127;
  __int128 v128;
  __int128 v129;
  __int128 v130;
  __int128 v131;
  __int128 v132;
  __int128 v133;
  __int128 v134;
  __int128 v135;
  __int128 v136;
  __int128 v137;
  _BYTE valuePtr[12];
  __int16 v139;
  int v140;
  __int16 v141;
  unsigned int v142;
  __int16 v143;
  char *v144;
  uint64_t v145;

  v145 = *MEMORY[0x1E0C80C00];
  v4 = (_BYTE *)(a1 + 4580);
  if (*(_BYTE *)(a1 + 4580))
    v5 = 0;
  else
    v5 = a3 == 0;
  if (v5)
    return 0;
  v7 = a3;
  *(_DWORD *)valuePtr = *(_DWORD *)(a1 + 152);
  v10 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberIntType, valuePtr);
  pthread_mutex_lock(&registeredFdsLock);
  if (registeredCloneFds)
  {
    v11 = CFSetContainsValue((CFSetRef)registeredCloneFds, v10);
    pthread_mutex_unlock(&registeredFdsLock);
    CFRelease(v10);
    if (v11)
    {
      bzero(valuePtr, 0x400uLL);
      bzero(__str, 0x400uLL);
      Current = CFAbsoluteTimeGetCurrent();
      snprintf(valuePtr, 0x400uLL, "%s%s", a2, "indexCompactDirectory");
      snprintf(__str, 0x400uLL, "%s%s", a2, "shadowIndexCompactDirectory");
      v13 = copyFileFallback(*(unsigned int *)(a1 + 152), valuePtr, *(_DWORD *)(a1 + 152), __str, a4, 1, 1);
      v14 = *__error();
      if ((v13 & 1) != 0)
      {
        v15 = _SILogForLogForCategory(10);
        v16 = 2 * (dword_1EF19FCB4 < 4);
        if (os_log_type_enabled(v15, v16))
        {
          v17 = CFAbsoluteTimeGetCurrent() - Current;
          *(_DWORD *)buf = 134217984;
          *(double *)&buf[4] = v17;
          _os_log_impl(&dword_1B8270000, v15, v16, "shadowIndexCompactDirectory took %f seconds", buf, 0xCu);
        }
        *__error() = v14;
        v18 = CFAbsoluteTimeGetCurrent();
        snprintf(valuePtr, 0x400uLL, "%s%s", a2, "indexDirectory");
        snprintf(__str, 0x400uLL, "%s%s", a2, "shadowIndexDirectory");
        v19 = copyFileFallback(*(unsigned int *)(a1 + 152), valuePtr, *(_DWORD *)(a1 + 152), __str, a4, 1, 1);
        v20 = *__error();
        if ((v19 & 1) != 0)
        {
          v21 = _SILogForLogForCategory(10);
          v22 = 2 * (dword_1EF19FCB4 < 4);
          if (os_log_type_enabled(v21, v22))
          {
            v23 = CFAbsoluteTimeGetCurrent() - v18;
            *(_DWORD *)buf = 134217984;
            *(double *)&buf[4] = v23;
            _os_log_impl(&dword_1B8270000, v21, v22, "shadowIndexDirectory took %f seconds", buf, 0xCu);
          }
          *__error() = v20;
          CFAbsoluteTimeGetCurrent();
          snprintf(valuePtr, 0x400uLL, "%s%s", a2, "indexArrays");
          snprintf(__str, 0x400uLL, "%s%s", a2, "shadowIndexArrays");
          if ((copyFileFallback(*(unsigned int *)(a1 + 152), valuePtr, *(_DWORD *)(a1 + 152), __str, a4, 1, 1) & 1) != 0)
          {
            v24 = *(_QWORD *)(a1 + 4528);
            if (v24 >= 1)
            {
              v25 = 0;
              v26 = a1 + 4528;
              do
                bit_vector_set_1700(v26, v25++, 0);
              while (v24 != v25);
            }
LABEL_17:
            result = 0;
            *v4 = 0;
            return result;
          }
          if (*__error() == 1)
            goto LABEL_53;
          v47 = *__error();
          v48 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315906;
            *(_QWORD *)&buf[4] = "bt_shadowTrie";
            v109 = 1024;
            v110 = 1893;
            v111 = 2080;
            *(_QWORD *)v112 = valuePtr;
            *(_WORD *)&v112[8] = 2080;
            *(_QWORD *)&v112[10] = __str;
            goto LABEL_74;
          }
LABEL_75:
          *__error() = v47;
          return 0xFFFFFFFFLL;
        }
        if (v20 == 1)
        {
LABEL_53:
          bzero(v107, 0x400uLL);
          CFAbsoluteTimeGetCurrent();
          goto LABEL_54;
        }
        v47 = *__error();
        v48 = _SILogForLogForCategory(0);
        if (!os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
          goto LABEL_75;
        *(_DWORD *)buf = 136315906;
        *(_QWORD *)&buf[4] = "bt_shadowTrie";
        v109 = 1024;
        v110 = 1878;
        v111 = 2080;
        *(_QWORD *)v112 = valuePtr;
        *(_WORD *)&v112[8] = 2080;
        *(_QWORD *)&v112[10] = __str;
LABEL_74:
        _os_log_error_impl(&dword_1B8270000, v48, OS_LOG_TYPE_ERROR, "%s:%d: copyFile error, src: %s, dst: %s", buf, 0x26u);
        goto LABEL_75;
      }
      if (v14 != 1)
      {
        v47 = *__error();
        v48 = _SILogForLogForCategory(0);
        if (!os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
          goto LABEL_75;
        *(_DWORD *)buf = 136315906;
        *(_QWORD *)&buf[4] = "bt_shadowTrie";
        v109 = 1024;
        v110 = 1862;
        v111 = 2080;
        *(_QWORD *)v112 = valuePtr;
        *(_WORD *)&v112[8] = 2080;
        *(_QWORD *)&v112[10] = __str;
        goto LABEL_74;
      }
    }
  }
  else
  {
    pthread_mutex_unlock(&registeredFdsLock);
    CFRelease(v10);
  }
  bzero(v107, 0x400uLL);
  v28 = CFAbsoluteTimeGetCurrent();
  snprintf(v107, 0x400uLL, "%s%s", a2, "shadowIndexCompactDirectory");
  v29 = fd_create_protected(*(_DWORD *)(a1 + 152), v107, 1538, 0);
  if (!v29)
  {
    v43 = *__error();
    v44 = *__error();
    v45 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)valuePtr = 136315906;
      *(_QWORD *)&valuePtr[4] = "bt_shadowTrie";
      v139 = 1024;
      v140 = 1918;
      v141 = 1024;
      v142 = v43;
      v143 = 2080;
      v144 = v107;
      goto LABEL_83;
    }
LABEL_37:
    v30 = 0;
    goto LABEL_39;
  }
  v30 = (uint64_t)v29;
  *(_QWORD *)valuePtr = 0;
  v31 = _fd_acquire_fd((uint64_t)v29, valuePtr);
  if (v31 != -1)
  {
    v32 = v31;
    *(_WORD *)(v30 + 56) |= 1u;
    fcntl(v31, 48, 1);
    fcntl(v32, 76, *(_WORD *)(v30 + 56) & 1);
    _fd_release_fd((_DWORD *)v30, v32, 0, *(uint64_t *)valuePtr);
  }
  if (__THREAD_SLOT_KEY)
  {
    v33 = pthread_getspecific(__THREAD_SLOT_KEY);
    if (v33)
      goto LABEL_26;
  }
  else
  {
    makeThreadId();
    v33 = pthread_getspecific(__THREAD_SLOT_KEY);
    if (v33)
    {
LABEL_26:
      if ((unint64_t)v33 < 0x801)
        goto LABEL_27;
    }
  }
  makeThreadId();
  v33 = pthread_getspecific(__THREAD_SLOT_KEY);
LABEL_27:
  v34 = (uint64_t)v33 - 1;
  v35 = CICleanUpPush((uint64_t)v33 - 1, (uint64_t)fd_release, v30);
  v36 = fd_pwrite(v30, *(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 32), 0);
  CICleanUpClearItem(v34, v35);
  CICleanUpPop(v34);
  if (v36 == -1)
  {
    v43 = *__error();
    v44 = *__error();
    v46 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
      goto LABEL_39;
    *(_DWORD *)valuePtr = 136315906;
    *(_QWORD *)&valuePtr[4] = "bt_shadowTrie";
    v139 = 1024;
    v140 = 1931;
    v141 = 1024;
    v142 = v43;
    v143 = 2080;
    v144 = v107;
    goto LABEL_99;
  }
  *(_QWORD *)valuePtr = 0;
  v37 = _fd_acquire_fd(v30, valuePtr);
  if ((_DWORD)v37 != -1)
  {
    v38 = v37;
    prot_fsync(v37, 0);
    _fd_release_fd((_DWORD *)v30, v38, 0, *(uint64_t *)valuePtr);
  }
  fd_release((char *)v30);
  v39 = *__error();
  v40 = _SILogForLogForCategory(10);
  v41 = 2 * (dword_1EF19FCB4 < 4);
  if (os_log_type_enabled(v40, v41))
  {
    v42 = CFAbsoluteTimeGetCurrent() - v28;
    *(_DWORD *)valuePtr = 134217984;
    *(double *)&valuePtr[4] = v42;
    _os_log_impl(&dword_1B8270000, v40, v41, "shadowIndexCompactDirectory took %f seconds", valuePtr, 0xCu);
  }
  *__error() = v39;
  if (*a4 == 1 || *a4 == -1 && (v7 & 1) != 0)
    return 89;
  v49 = CFAbsoluteTimeGetCurrent();
  snprintf(v107, 0x400uLL, "%s%s", a2, "shadowIndexDirectory");
  v50 = fd_create_protected(*(_DWORD *)(a1 + 152), v107, 1538, 0);
  if (!v50)
  {
    v43 = *__error();
    v44 = *__error();
    v45 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)valuePtr = 136315906;
      *(_QWORD *)&valuePtr[4] = "bt_shadowTrie";
      v139 = 1024;
      v140 = 1954;
      v141 = 1024;
      v142 = v43;
      v143 = 2080;
      v144 = v107;
LABEL_83:
      _os_log_error_impl(&dword_1B8270000, v45, OS_LOG_TYPE_ERROR, "%s:%d: open err: %d, %s", valuePtr, 0x22u);
      goto LABEL_37;
    }
    goto LABEL_37;
  }
  v30 = (uint64_t)v50;
  fd_no_cache((uint64_t)v50);
  v51 = CICleanUpThreadLoc();
  v52 = CICleanUpPush((uint64_t)v51, (uint64_t)fd_release, v30);
  v53 = fd_pwrite(v30, *(_QWORD *)(a1 + 8), 1028 * (*(_DWORD *)(a1 + 144) + 1), 0);
  CICleanUpClearItem((uint64_t)v51, v52);
  CICleanUpPop((uint64_t)v51);
  if (v53 != -1)
  {
    fd_sync(v30, 0);
    fd_release((char *)v30);
    v54 = *__error();
    v55 = _SILogForLogForCategory(10);
    v56 = 2 * (dword_1EF19FCB4 < 4);
    if (os_log_type_enabled(v55, v56))
    {
      v57 = CFAbsoluteTimeGetCurrent() - v49;
      *(_DWORD *)valuePtr = 134217984;
      *(double *)&valuePtr[4] = v57;
      _os_log_impl(&dword_1B8270000, v55, v56, "shadowIndexDirectory took %f seconds", valuePtr, 0xCu);
    }
    *__error() = v54;
LABEL_54:
    v137 = 0u;
    v136 = 0u;
    v135 = 0u;
    v134 = 0u;
    v133 = 0u;
    v132 = 0u;
    v131 = 0u;
    v130 = 0u;
    v129 = 0u;
    v128 = 0u;
    v127 = 0u;
    v126 = 0u;
    v125 = 0u;
    v124 = 0u;
    v123 = 0u;
    v122 = 0u;
    v121 = 0u;
    v120 = 0u;
    v119 = 0u;
    v118 = 0u;
    v117 = 0u;
    v116 = 0u;
    v115 = 0u;
    v114 = 0u;
    *(_OWORD *)__str = 0u;
    bzero(valuePtr, 0x400uLL);
    v105 = 0;
    v106 = 0;
    v58 = CFAbsoluteTimeGetCurrent();
    snprintf(valuePtr, 0x400uLL, "%s%s", a2, "shadowIndexArrays");
    v59 = fd_create_protected(*(_DWORD *)(a1 + 152), valuePtr, 514, 0);
    *(_QWORD *)buf = 0;
    v60 = _fd_acquire_fd((uint64_t)v59, buf);
    if (v60 == -1)
    {
      if (!v59)
      {
        v72 = *__error();
        v73 = *__error();
        v76 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v76, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315906;
          *(_QWORD *)&buf[4] = "shadowFlatStore";
          v109 = 1024;
          v110 = 1711;
          v111 = 1024;
          *(_DWORD *)v112 = v72;
          *(_WORD *)&v112[4] = 2080;
          *(_QWORD *)&v112[6] = valuePtr;
          _os_log_error_impl(&dword_1B8270000, v76, OS_LOG_TYPE_ERROR, "%s:%d: open err: %d, %s", buf, 0x22u);
        }
        v64 = 0;
        goto LABEL_90;
      }
    }
    else
    {
      v61 = v60;
      *((_WORD *)v59 + 28) |= 1u;
      fcntl(v60, 48, 1);
      fcntl(v61, 76, v59[7] & 1);
      _fd_release_fd(v59, v61, 0, *(uint64_t *)buf);
    }
    v62 = (*(_DWORD *)(a1 + 392) + 0x1FFFF) >> 17;
    if ((v7 & 1) == 0 && v62 >= *(_QWORD *)(a1 + 4528))
      v62 = *(_QWORD *)(a1 + 4528);
    v63 = malloc_type_malloc(0x20000uLL, 0xE5FF5B7CuLL);
    if (!v63)
    {
      v97 = __si_assert_copy_extra_1644(0);
      v98 = v97;
      v99 = "";
      if (v97)
        v99 = v97;
      __message_assert("%s:%u: failed assertion '%s' %s ", "BurstTrie.c", 1725, "readBuffer", v99);
      free(v98);
      if (__valid_fs(-1))
        v100 = 2989;
      else
        v100 = 3072;
      *(_DWORD *)v100 = -559038737;
      abort();
    }
    v64 = v63;
    v65 = *(_QWORD *)(a1 + 392);
    v66 = *(_DWORD **)(a1 + 376);
    if (v65 >> 17)
    {
      v67 = _fd_acquire_fd((uint64_t)v66, &v105);
      if (v67 != -1)
      {
        v68 = v67;
        v69 = _fd_acquire_fd((uint64_t)v59, &v106);
        if (v69 != -1)
        {
          v102 = v69;
          __fd = v68;
          if (v62 < 1)
          {
LABEL_151:
            _fd_release_fd(*(_DWORD **)(a1 + 376), __fd, 0, v105);
            _fd_release_fd(v59, v102, 0, v106);
            goto LABEL_152;
          }
          v101 = (CFIndex *)(a1 + 4528);
          __buf = v64;
          if ((v7 & 1) != 0)
          {
            v70 = 0;
            v71 = 0;
            while (v71 != 100)
            {
LABEL_100:
              *(_DWORD *)&__str[4 * v71++] = v70;
              if (++v70 == v62)
                goto LABEL_132;
            }
            v79 = 0;
            while (*a4 != 1 && *a4 != -1)
            {
              v80 = *(unsigned int *)&__str[v79];
              if (prot_pread(__fd, __buf, 0x20000uLL, v80 << 17) == -1)
                goto LABEL_126;
              if (*a4 == 1 || *a4 == -1)
                break;
              if (prot_pwrite_guarded(v102, (uint64_t)&v106, (uint64_t)__buf, 0x20000uLL, v80 << 17) == -1)
                goto LABEL_129;
              bit_vector_set_1700((uint64_t)v101, v80, 0);
              v79 += 4;
              if (v79 == 400)
              {
                v71 = 0;
                v64 = __buf;
                goto LABEL_100;
              }
            }
LABEL_124:
            v72 = 89;
            v64 = __buf;
          }
          else
          {
            v81 = 0;
            v71 = 0;
            do
            {
              if (v71 == 100)
              {
                v82 = 0;
                while (*a4 != 1)
                {
                  v83 = *(unsigned int *)&__str[v82];
                  if (prot_pread(v68, __buf, 0x20000uLL, v83 << 17) == -1)
                  {
LABEL_126:
                    v72 = *__error();
                    v73 = *__error();
                    v84 = _SILogForLogForCategory(0);
                    v77 = v102;
                    if (os_log_type_enabled(v84, OS_LOG_TYPE_ERROR))
                    {
                      *(_DWORD *)buf = 136315650;
                      *(_QWORD *)&buf[4] = "shadowFlatStore";
                      v109 = 1024;
                      v110 = 1761;
                      v111 = 1024;
                      *(_DWORD *)v112 = v72;
                      _os_log_error_impl(&dword_1B8270000, v84, OS_LOG_TYPE_ERROR, "%s:%d: read err: %d", buf, 0x18u);
                    }
                    v64 = __buf;
                    v68 = __fd;
                    goto LABEL_91;
                  }
                  if (*a4 == 1)
                    goto LABEL_124;
                  if (prot_pwrite_guarded(v102, (uint64_t)&v106, (uint64_t)__buf, 0x20000uLL, v83 << 17) == -1)
                  {
LABEL_129:
                    v72 = *__error();
                    v73 = *__error();
                    v85 = _SILogForLogForCategory(0);
                    v68 = __fd;
                    if (os_log_type_enabled(v85, OS_LOG_TYPE_ERROR))
                    {
                      *(_DWORD *)buf = 136315650;
                      *(_QWORD *)&buf[4] = "shadowFlatStore";
                      v109 = 1024;
                      v110 = 1770;
                      v111 = 1024;
                      *(_DWORD *)v112 = v72;
                      _os_log_error_impl(&dword_1B8270000, v85, OS_LOG_TYPE_ERROR, "%s:%d: pwrite err: %d", buf, 0x18u);
                    }
                    v64 = __buf;
                    v77 = v102;
                    goto LABEL_91;
                  }
                  bit_vector_set_1700((uint64_t)v101, v83, 0);
                  v82 += 4;
                  if (v82 == 400)
                  {
                    v71 = 0;
                    v64 = __buf;
                    goto LABEL_121;
                  }
                }
                goto LABEL_124;
              }
LABEL_121:
              if (*v101 > v81 && CFBitVectorGetBitAtIndex(*(CFBitVectorRef *)(a1 + 4544), v81))
                *(_DWORD *)&__str[4 * v71++] = v81;
              ++v81;
            }
            while (v81 != v62);
LABEL_132:
            if (!v71)
              goto LABEL_151;
            v86 = v71;
            if ((v7 & 1) == 0)
            {
              v89 = __str;
              while (1)
              {
                if (*a4 == 1)
                  goto LABEL_158;
                v90 = *(unsigned int *)v89;
                if (prot_pread(__fd, v64, 0x20000uLL, v90 << 17) == -1)
                  break;
                if (*a4 == 1)
                  goto LABEL_158;
                if (prot_pwrite_guarded(v102, (uint64_t)&v106, (uint64_t)v64, 0x20000uLL, v90 << 17) == -1)
                {
LABEL_161:
                  v72 = *__error();
                  v73 = *__error();
                  v95 = _SILogForLogForCategory(0);
                  if (!os_log_type_enabled(v95, OS_LOG_TYPE_ERROR))
                    goto LABEL_162;
                  *(_DWORD *)buf = 136315650;
                  *(_QWORD *)&buf[4] = "shadowFlatStore";
                  v109 = 1024;
                  v110 = 1808;
                  v111 = 1024;
                  *(_DWORD *)v112 = v72;
                  v96 = "%s:%d: pwrite err: %d";
                  goto LABEL_170;
                }
                bit_vector_set_1700((uint64_t)v101, v90, 0);
                v89 += 4;
                if (!--v86)
                  goto LABEL_151;
              }
LABEL_159:
              v72 = *__error();
              v73 = *__error();
              v95 = _SILogForLogForCategory(0);
              if (!os_log_type_enabled(v95, OS_LOG_TYPE_ERROR))
              {
LABEL_162:
                v64 = __buf;
                v77 = v102;
                v68 = __fd;
                goto LABEL_91;
              }
              *(_DWORD *)buf = 136315650;
              *(_QWORD *)&buf[4] = "shadowFlatStore";
              v109 = 1024;
              v110 = 1799;
              v111 = 1024;
              *(_DWORD *)v112 = v72;
              v96 = "%s:%d: pread err: %d";
LABEL_170:
              _os_log_error_impl(&dword_1B8270000, v95, OS_LOG_TYPE_ERROR, v96, buf, 0x18u);
              goto LABEL_162;
            }
            v87 = __str;
            while (*a4 != 1 && *a4 != -1)
            {
              v88 = *(unsigned int *)v87;
              if (prot_pread(__fd, v64, 0x20000uLL, v88 << 17) == -1)
                goto LABEL_159;
              if (*a4 == 1 || *a4 == -1)
                break;
              if (prot_pwrite_guarded(v102, (uint64_t)&v106, (uint64_t)v64, 0x20000uLL, v88 << 17) == -1)
                goto LABEL_161;
              bit_vector_set_1700((uint64_t)v101, v88, 0);
              v87 += 4;
              if (!--v86)
                goto LABEL_151;
            }
LABEL_158:
            v72 = 89;
          }
          v77 = v102;
          v68 = __fd;
LABEL_92:
          free(v64);
          _fd_release_fd(*(_DWORD **)(a1 + 376), v68, 0, v105);
          _fd_release_fd(v59, v77, 0, v106);
          fd_release((char *)v59);
          if (v72)
            return v72;
          else
            return 0xFFFFFFFFLL;
        }
        v72 = *__error();
        v73 = *__error();
        v78 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v78, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          *(_QWORD *)&buf[4] = "shadowFlatStore";
          v109 = 1024;
          v110 = 1748;
          v111 = 1024;
          *(_DWORD *)v112 = v72;
          _os_log_error_impl(&dword_1B8270000, v78, OS_LOG_TYPE_ERROR, "%s:%d: fd_open err: %d", buf, 0x18u);
        }
        v77 = -1;
LABEL_91:
        *__error() = v73;
        goto LABEL_92;
      }
      v72 = *__error();
      v73 = *__error();
      v74 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v74, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = "shadowFlatStore";
        v109 = 1024;
        v110 = 1742;
        v111 = 1024;
        *(_DWORD *)v112 = v72;
        v75 = "%s:%d: fd_open err: %d";
        goto LABEL_89;
      }
    }
    else
    {
      if (fd_pread(v66, v64, v65, 0) != -1)
      {
        if (fd_pwrite((uint64_t)v59, (uint64_t)v64, *(_QWORD *)(a1 + 392), 0) != -1)
        {
          bit_vector_set_1700(a1 + 4528, 0, 0);
LABEL_152:
          free(v64);
          fd_truncate((uint64_t)v59, *(_QWORD *)(a1 + 384));
          fd_sync((uint64_t)v59, 0);
          fd_release((char *)v59);
          v91 = *__error();
          v92 = _SILogForLogForCategory(10);
          v93 = 2 * (dword_1EF19FCB4 < 4);
          if (os_log_type_enabled(v92, v93))
          {
            v94 = CFAbsoluteTimeGetCurrent() - v58;
            *(_DWORD *)buf = 134217984;
            *(double *)&buf[4] = v94;
            _os_log_impl(&dword_1B8270000, v92, v93, "shadowIndexArrays took %f seconds", buf, 0xCu);
          }
          *__error() = v91;
          if (*a4 != 1 && (*a4 != -1 || (v7 & 1) == 0))
            goto LABEL_17;
          v64 = 0;
          v59 = 0;
          v72 = 89;
          v77 = -1;
          v68 = -1;
          goto LABEL_92;
        }
        v72 = *__error();
        v73 = *__error();
        v74 = _SILogForLogForCategory(0);
        if (!os_log_type_enabled(v74, OS_LOG_TYPE_ERROR))
          goto LABEL_90;
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = "shadowFlatStore";
        v109 = 1024;
        v110 = 1734;
        v111 = 1024;
        *(_DWORD *)v112 = v72;
        v75 = "%s:%d: pwrite err: %d";
        goto LABEL_89;
      }
      v72 = *__error();
      v73 = *__error();
      v74 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v74, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = "shadowFlatStore";
        v109 = 1024;
        v110 = 1729;
        v111 = 1024;
        *(_DWORD *)v112 = v72;
        v75 = "%s:%d: read err: %d";
LABEL_89:
        _os_log_error_impl(&dword_1B8270000, v74, OS_LOG_TYPE_ERROR, v75, buf, 0x18u);
      }
    }
LABEL_90:
    v77 = -1;
    v68 = -1;
    goto LABEL_91;
  }
  v43 = *__error();
  v44 = *__error();
  v46 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)valuePtr = 136315906;
    *(_QWORD *)&valuePtr[4] = "bt_shadowTrie";
    v139 = 1024;
    v140 = 1967;
    v141 = 1024;
    v142 = v43;
    v143 = 2080;
    v144 = v107;
LABEL_99:
    _os_log_error_impl(&dword_1B8270000, v46, OS_LOG_TYPE_ERROR, "%s:%d: write err: %d, %s", valuePtr, 0x22u);
  }
LABEL_39:
  *__error() = v44;
  fd_release((char *)v30);
  if (v43)
    return v43;
  else
    return 0xFFFFFFFFLL;
}

void bit_vector_set_1700(uint64_t a1, CFIndex idx, CFBit value)
{
  CFIndex v6;
  char *v7;
  char *v8;
  const char *v9;
  CFIndex v10;
  char *v11;
  const char *v12;
  const __CFBitVector *v13;
  const __CFAllocator *v14;
  __CFBitVector *MutableCopy;
  __CFBitVector *v16;
  const void *v17;
  char *v18;
  const char *v19;

  if (idx < 0)
  {
    v7 = __si_assert_copy_extra_1644(0);
    v8 = v7;
    v9 = "";
    if (v7)
      v9 = v7;
    __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 129, "bitIndex >= 0", v9);
LABEL_9:
    free(v8);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v6 = *(_QWORD *)(a1 + 8);
  if (v6 > idx)
    goto LABEL_3;
  if (v6)
    v10 = *(_QWORD *)(a1 + 8);
  else
    v10 = 32;
  while (1)
  {
    v10 *= 2;
    if (v10 > idx)
      break;
    if (v10 <= v6)
    {
      v11 = __si_assert_copy_extra_1644(0);
      v8 = v11;
      v12 = "";
      if (v11)
        v12 = v11;
      __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 111, "newCapacity > bv->capacity", v12);
      goto LABEL_9;
    }
  }
  v13 = *(const __CFBitVector **)(a1 + 16);
  v14 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (v13)
    MutableCopy = CFBitVectorCreateMutableCopy(v14, v10, v13);
  else
    MutableCopy = CFBitVectorCreateMutable(v14, v10);
  v16 = MutableCopy;
  if (!MutableCopy)
  {
    v18 = __si_assert_copy_extra_1644(0);
    v8 = v18;
    v19 = "";
    if (v18)
      v19 = v18;
    __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 115, "newBV", v19);
    goto LABEL_9;
  }
  CFBitVectorSetCount(MutableCopy, v10);
  v17 = *(const void **)(a1 + 16);
  if (v17)
    CFRelease(v17);
  *(_QWORD *)(a1 + 8) = v10;
  *(_QWORD *)(a1 + 16) = v16;
LABEL_3:
  if (*(_QWORD *)a1 <= idx)
    *(_QWORD *)a1 = idx + 1;
  CFBitVectorSetBitAtIndex(*(CFMutableBitVectorRef *)(a1 + 16), idx, value);
}

uint64_t mergeEntry(uint64_t a1, _DWORD *a2, unsigned int a3, unsigned __int8 *a4, int a5, _DWORD *a6, unint64_t a7)
{
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  int8x8_t *v18;
  unint64_t v19;
  uint8x8_t v20;
  uint8x8_t v21;
  uint8x8_t v22;
  uint8x8_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  unsigned int *v27;
  unsigned int v28;
  unsigned __int8 *v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  int v33;
  unsigned int v35;
  unsigned int v36;
  int v37;
  int v38;
  unsigned int v40;
  unsigned int v41;
  char v42;
  int v43;
  unint64_t v44;
  unint64_t v45;
  uint64_t v46;
  unsigned int *v47;
  char v48;
  unsigned int v49;
  unsigned int v50;
  unsigned int v51;
  int v52;
  unsigned int v53;
  BOOL v54;
  int v55;
  unsigned int v57;
  unsigned int v58;
  char v59;
  uint64_t v60;
  char v61;
  _DWORD *v62;
  unsigned int v63;
  unsigned int v64;
  unsigned int v65;
  int v66;
  unsigned int v67;
  BOOL v68;
  int v69;
  char *v71;
  char *v72;
  const char *v73;
  char *v74;
  const char *v75;
  char *v76;
  char *v77;
  const char *v78;
  unint64_t v79;
  uint64_t v80;

  v14 = a3;
  v15 = mgetBase(a1, a3);
  if (!a5)
  {
    v33 = *(_DWORD *)v15;
    if (!*(_DWORD *)v15)
    {
      v33 = a2[2];
      *(_DWORD *)v15 = v33;
      if (!*a2)
        a2[2] = v33 + 1;
    }
    *a6 = v33;
    return a7;
  }
  v16 = *a4;
  if (!*a4)
  {
    v71 = __si_assert_copy_extra_1644(0);
    v72 = v71;
    v73 = "";
    if (v71)
      v73 = v71;
    __message_assert("%s:%u: failed assertion '%s' %s ", "BurstTrie.c", 1551, "*string", v73);
LABEL_92:
    free(v72);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  if (((*(_DWORD *)(v15 + ((v16 >> 3) & 0x1C) + 4) >> v16) & 1) != 0)
  {
    v17 = 0;
    v18 = (int8x8_t *)(v15 + 4);
    v19 = v16 >> 6;
    if ((v16 >> 6) != 1)
    {
      if ((_DWORD)v19 != 2)
      {
        if ((_DWORD)v19 != 3)
          goto LABEL_10;
        v20 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v15 + 20));
        v20.i16[0] = vaddlv_u8(v20);
        v17 = v20.u32[0];
      }
      v21 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v15 + 12));
      v21.i16[0] = vaddlv_u8(v21);
      v17 += v21.u32[0];
    }
    v22 = (uint8x8_t)vcnt_s8(*v18);
    v22.i16[0] = vaddlv_u8(v22);
    v17 += v22.u32[0];
LABEL_10:
    v23 = (uint8x8_t)vcnt_s8((int8x8_t)(*(_QWORD *)&v18[v19] & ~(-1 << v16)));
    v23.i16[0] = vaddlv_u8(v23);
    v24 = v23.u32[0] + v17;
    v25 = v15 + 4 * v24;
    v28 = *(_DWORD *)(v25 + 38);
    v27 = (unsigned int *)(v25 + 38);
    v26 = v28;
    if ((v28 & 1) == 0)
    {
      v79 = v26 >> 1;
      goto LABEL_12;
    }
    if ((v26 & 3) != 1)
    {
      v79 = (v26 >> 3) | ((unint64_t)(v26 & 7) << 32);
      v43 = v26 & 7;
      if (!v43)
      {
LABEL_12:
        v29 = a4 + 1;
        v30 = (a5 - 1);
        if (mergeEntryFlat(a1))
        {
          v31 = v79;
          if (a2[1])
            return v31;
          v31 = burst2(a1, (uint64_t)a2, v79);
          if (a2[1])
            return v31;
          v32 = HIDWORD(v31) == 1 ? mergeEntry(a1, a2) : bt_mergeEntry(a1, a2, v31, a6, v29, v30);
          v31 = v32;
          v80 = v32;
          if (a2[1])
            return v31;
          v60 = mgetBase(a1, v14) + 4 * v24;
          v63 = *(_DWORD *)(v60 + 38);
          v62 = (_DWORD *)(v60 + 38);
          v61 = v63;
          v64 = v63 >> 1;
          v65 = v63 >> 3;
          v66 = v63 & 7;
          v67 = v63 >> 2;
          if ((v63 & 3) == 1)
          {
            v66 = 1;
            v65 = v67;
          }
          v68 = (v61 & 1) == 0;
          if ((v61 & 1) != 0)
            v69 = v66;
          else
            v69 = 0;
          if (!v68)
            v64 = v65;
          if ((_DWORD)v80 != v64 || HIDWORD(v80) != v69)
            *v62 = ptrD(v80);
          return a7;
        }
        v35 = *v27 >> 1;
        v36 = *v27 >> 3;
        v37 = *v27 & 7;
        if ((*v27 & 3) == 1)
        {
          v37 = 1;
          v36 = *v27 >> 2;
        }
        if ((*v27 & 1) != 0)
          v38 = v37;
        else
          v38 = 0;
        if ((*v27 & 1) != 0)
          v35 = v36;
        if ((_DWORD)v79 != v35 || HIDWORD(v79) != v38)
        {
          v40 = (4 * v79) | 1;
          v41 = HIDWORD(v79) | (8 * v79);
          if (!HIDWORD(v79))
            v41 = 2 * v79;
          if (HIDWORD(v79) != 1)
            v40 = v41;
          if ((v40 & 3) == 1)
            v42 = 2;
          else
            v42 = 3;
          if ((v40 & 1) == 0)
            v42 = 1;
          if (v40 >> v42 == (_DWORD)v79)
          {
            *v27 = v40;
            return a7;
          }
          goto LABEL_95;
        }
        return a7;
      }
      if (v43 != 1)
      {
        if (v43 != 3)
        {
          v76 = __si_assert_copy_extra_1644(0);
          v77 = v76;
          if (v76)
            v78 = v76;
          else
            v78 = "";
          __message_assert("%s:%u: Unexpected code path %s ", "BurstTrie.c", 1635, v78);
          free(v77);
          MEMORY[0xBAD] = -559038737;
          abort();
        }
        mergeEntryFat(a1, a2);
        return a7;
      }
    }
    v44 = mergeEntry(a1, a2);
    v31 = v44;
    if (a2[1])
      return v31;
    v45 = HIDWORD(v44);
    v46 = mgetBase(a1, v14) + 4 * v24;
    v49 = *(_DWORD *)(v46 + 38);
    v47 = (unsigned int *)(v46 + 38);
    v48 = v49;
    v50 = v49 >> 1;
    v51 = v49 >> 3;
    v52 = v49 & 7;
    v53 = v49 >> 2;
    if ((v49 & 3) == 1)
    {
      v52 = 1;
      v51 = v53;
    }
    v54 = (v48 & 1) == 0;
    if ((v48 & 1) != 0)
      v55 = v52;
    else
      v55 = 0;
    if (!v54)
      v50 = v51;
    if (v50 != (_DWORD)v31 || v55 != (_DWORD)v45)
    {
      v57 = (4 * v31) | 1;
      v58 = v45 | (8 * v31);
      if (!(_DWORD)v45)
        v58 = 2 * v31;
      if ((_DWORD)v45 != 1)
        v57 = v58;
      if ((v57 & 3) == 1)
        v59 = 2;
      else
        v59 = 3;
      if ((v57 & 1) == 0)
        v59 = 1;
      if (v57 >> v59 == (_DWORD)v31)
      {
        *v47 = v57;
        return a7;
      }
LABEL_95:
      v74 = __si_assert_copy_extra_1644(0);
      v72 = v74;
      v75 = "";
      if (v74)
        v75 = v74;
      __message_assert("%s:%u: failed assertion '%s' %s ", "BurstTrie.h", 81, "ptrM(newptr).next == ptr.next", v75);
      goto LABEL_92;
    }
    return a7;
  }
  return _mergeEntryNoFollows(a1, (uint64_t)a2, a3, a4, a5, (uint64_t)a6, a7);
}

uint64_t _mergeEntryNoFollows(uint64_t a1, uint64_t a2, unsigned int a3, unsigned __int8 *a4, int a5, uint64_t a6, unint64_t a7)
{
  unsigned int v12;
  uint64_t v13;
  unsigned int v14;
  unint64_t v15;
  __int16 v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t (*v27)(uint64_t);
  int v28;
  uint64_t v29;
  _QWORD *v30;
  _BYTE *v31;
  const void *v32;
  uint64_t v33;
  unsigned int v34;
  unsigned int v35;
  BOOL v36;
  unsigned int v37;
  unsigned int v38;
  _BOOL4 v40;
  int v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unint64_t *v45;
  unint64_t v46;
  unint64_t v47;
  uint64_t v48;
  unint64_t *v49;
  unint64_t v50;
  unint64_t v51;
  char *v52;
  char *v53;
  const char *v54;
  int v55;
  unsigned int v56;
  unint64_t v57;
  unint64_t v58;
  char *v59;
  char v60;
  uint64_t v61;
  unsigned int v62;
  unsigned int v63;
  char v64;
  uint64_t v65;
  unint64_t *v66;
  unint64_t v67;
  unint64_t v68;
  uint64_t v70;
  int8x8_t *v71;
  unsigned int v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  unsigned int v76;
  uint8x8_t v77;
  uint8x8_t v78;
  uint8x8_t v79;
  uint8x8_t v80;
  uint64_t v81;
  unint64_t *v82;
  unint64_t v83;
  unint64_t v84;
  uint64_t v85;
  unint64_t *v86;
  unint64_t v87;
  unint64_t v88;
  char *v89;
  char *v90;
  const char *v91;
  int v92;
  unsigned int v93;
  unint64_t v94;
  unint64_t v95;
  char *v96;
  char v97;
  uint64_t v98;
  uint64_t v99;
  char *v100;
  const char *v101;
  char *v102;
  const char *v103;
  char *v104;
  const char *v105;
  uint64_t v106;
  unsigned int v107;
  uint64_t v108;
  uint64_t v109;
  unsigned int v110;
  unsigned int v111;
  unsigned int v112;
  unint64_t v113;
  unsigned __int8 *v114;
  uint64_t v116;
  int v117;
  __int128 v118;
  __int128 v119;
  __int128 v120;
  __int128 v121;
  __int128 v122;
  __int128 v123;
  __int128 v124;
  __int128 v125;
  __int128 v126;
  __int128 v127;
  __int128 v128;
  __int128 v129;
  uint64_t v130;

  v130 = *MEMORY[0x1E0C80C00];
  v12 = a7;
  v113 = HIDWORD(a7);
  v13 = mgetBase(a1, a3);
  v14 = *(unsigned __int8 *)(v13 + 36);
  if (*(unsigned __int8 *)(v13 + 37) != v14)
  {
LABEL_37:
    v109 = mgetBase(a1, v12);
    v107 = set_follows(v109, *a4);
    if (*(_DWORD *)a2)
    {
      v44 = a2;
      v45 = (unint64_t *)(a2 + 2148);
      v46 = *(_QWORD *)(a2 + 2148);
      v128 = 0u;
      v129 = 0u;
      v126 = 0u;
      v127 = 0u;
      v124 = 0u;
      v125 = 0u;
      v122 = 0u;
      v123 = 0u;
      v120 = 0u;
      v121 = 0u;
      v118 = 0u;
      v119 = 0u;
      v117 = 0;
      v47 = flatStoreNewBlockForCompact(a1 + 160, v46, (uint64_t)&v118, &v117);
      v48 = v117;
      if (v117 >= 1)
      {
        v49 = (unint64_t *)&v118;
        do
        {
          v51 = *v49++;
          v50 = v51;
          bit_vector_set_2851(a1 + 4528, (v51 >> 17));
          if ((v51 >> 17) != (v51 + 8) >> 17)
            bit_vector_set_2851(a1 + 4528, (v50 >> 17) + 1);
          --v48;
        }
        while (v48);
      }
      v116 = v47;
      *v45 = v47;
      if (v47)
      {
LABEL_44:
        if ((mergeEntryFlat(a1) & 1) != 0)
        {
          if (*(_DWORD *)(v44 + 4))
            return v116;
          v52 = __si_assert_copy_extra_1644(0);
          v53 = v52;
          v54 = "";
          if (v52)
            v54 = v52;
          __message_assert("%s:%u: failed assertion '%s' %s ", "BurstTrie.c", 1511, "ms->err", v54);
LABEL_124:
          free(v53);
          if (__valid_fs(-1))
            v106 = 2989;
          else
            v106 = 3072;
          *(_DWORD *)v106 = -559038737;
          abort();
        }
        v62 = HIDWORD(v116) | (8 * v116);
        if (!HIDWORD(v116))
          v62 = 2 * v116;
        if (HIDWORD(v116) == 1)
          v63 = (4 * v116) | 1;
        else
          v63 = v62;
        if ((v63 & 3) == 1)
          v64 = 2;
        else
          v64 = 3;
        if ((v63 & 1) == 0)
          v64 = 1;
        if (v63 >> v64 != (_DWORD)v116)
        {
          v102 = __si_assert_copy_extra_1644(0);
          v53 = v102;
          v103 = "";
          if (v102)
            v103 = v102;
          __message_assert("%s:%u: failed assertion '%s' %s ", "BurstTrie.h", 81, "ptrM(newptr).next == ptr.next", v103);
          goto LABEL_124;
        }
        *(_DWORD *)(v109 + 4 * v107 + 38) = v63;
        LODWORD(v116) = v12;
LABEL_67:
        HIDWORD(v116) = v113;
        return v116;
      }
    }
    else
    {
      v128 = 0u;
      v129 = 0u;
      v126 = 0u;
      v127 = 0u;
      v124 = 0u;
      v125 = 0u;
      v122 = 0u;
      v123 = 0u;
      v120 = 0u;
      v121 = 0u;
      v118 = 0u;
      v119 = 0u;
      v55 = 64;
      v117 = 0;
      do
      {
        v56 = v55;
        v55 *= 2;
      }
      while (v56 < a5 + 22);
      v57 = storageAllocOffset(a1 + 160, v56, (uint64_t)&v118, &v117);
      if (v57)
      {
        v58 = v57;
        v44 = a2;
        v59 = storageResolvePtr(a1 + 160, v57, v56, 1);
        *(_WORD *)v59 = 0;
        v60 = __clz(__rbit32(v56 >> 6));
        if (!v56)
          v60 = -1;
        v59[2] = v60;
        v61 = (v58 >> 6);
      }
      else
      {
        v44 = a2;
        v61 = 0;
      }
      v65 = v117;
      if (v117 >= 1)
      {
        v66 = (unint64_t *)&v118;
        do
        {
          v68 = *v66++;
          v67 = v68;
          bit_vector_set_2851(a1 + 4528, (v68 >> 17));
          if ((v68 >> 17) != (v68 + 8) >> 17)
            bit_vector_set_2851(a1 + 4528, (v67 >> 17) + 1);
          --v65;
        }
        while (v65);
      }
      v116 = v61;
      if (v61)
        goto LABEL_44;
    }
    *(_DWORD *)(v44 + 4) = *__error();
    return v116;
  }
  HIDWORD(v15) = *(unsigned __int8 *)(v13 + 36);
  LODWORD(v15) = v14 - 4;
  v16 = 16;
  switch((v15 >> 2))
  {
    case 0u:
      v16 = 8;
      goto LABEL_5;
    case 1u:
      goto LABEL_5;
    case 3u:
      v16 = 32;
LABEL_5:
      if (v12 != a3)
      {
        v100 = __si_assert_copy_extra_1644(0);
        v53 = v100;
        v101 = "";
        if (v100)
          v101 = v100;
        __message_assert("%s:%u: failed assertion '%s' %s ", "BurstTrie.c", 1413, "old==s", v101);
        goto LABEL_124;
      }
      v17 = (4 * v16 + 41) & 0x1E8;
      v18 = mmalloc((4 * v16 + 41) & 0x1E8, a1 + 16, *(uint64_t (**)(uint64_t))(a2 + 2160), *(_QWORD *)(a2 + 2168));
      if (!v18)
        goto LABEL_31;
      v19 = v18;
      v20 = v18 >> 2;
      v21 = mgetBase(a1, v18 >> 2);
      if (v17 >= 0x20)
      {
        v22 = v17 - 8;
        *(_OWORD *)v21 = 0u;
        *(_OWORD *)(v21 + 16) = 0u;
        if (v17 != 40)
        {
          *(_OWORD *)(v21 + 32) = 0uLL;
          *(_OWORD *)(v21 + 48) = 0uLL;
          if (v17 != 72)
          {
            *(_OWORD *)(v21 + 64) = 0uLL;
            *(_OWORD *)(v21 + 80) = 0uLL;
            if (v17 != 104)
            {
              *(_OWORD *)(v21 + 96) = 0uLL;
              *(_OWORD *)(v21 + 112) = 0uLL;
              if (v17 != 136)
              {
                *(_OWORD *)(v21 + 128) = 0uLL;
                *(_OWORD *)(v21 + 144) = 0uLL;
              }
            }
          }
        }
      }
      else
      {
        v22 = 0;
      }
      v29 = v22 - v17;
      v30 = (_QWORD *)(v21 + v22);
      do
      {
        *v30++ = 0;
        v29 += 8;
      }
      while (v29);
      *(_BYTE *)(v21 + 37) = v16;
      if (!(_DWORD)v20)
      {
LABEL_31:
        *(_DWORD *)(a2 + 4) = *__error();
        LODWORD(v116) = 0;
        goto LABEL_67;
      }
      v111 = v20;
      v31 = (_BYTE *)mgetBase(a1, (v19 >> 2));
      v32 = (const void *)mgetBase(a1, a7);
      memcpy(v31, v32, 4 * v14 + 38);
      v31[37] = v16;
      v33 = (4 * a7) & 0xFFFFFFFC;
      v34 = (4 * (_WORD)v14 + 41) & 0x7FC;
      v35 = *(_DWORD *)(a1 + 24);
      v36 = v34 >= v35;
      v37 = v34 - v35;
      if (v37 != 0 && v36)
      {
        v38 = __clz(v37);
        v40 = (v37 & (v37 - 1)) != 0 || v37 == 0;
        v41 = v40 - v38 + 28;
      }
      else
      {
        v41 = 0;
      }
      v12 = v111;
      if (v33 + (8 << v41) == *(_QWORD *)(a1 + 32))
      {
        *(_QWORD *)(a1 + 32) = 4 * (int)a7;
      }
      else
      {
        v42 = *(_QWORD *)(a1 + 16);
        if (*(_DWORD *)(a1 + 128) < v41)
          *(_DWORD *)(a1 + 128) = v41;
        v43 = a1 + 4 * v41;
        *(_DWORD *)(v42 + v33) = *(_DWORD *)(v43 + 48);
        *(_DWORD *)(v43 + 48) = 4 * a7;
      }
      goto LABEL_37;
    case 7u:
      if (v12 != a3)
      {
        v104 = __si_assert_copy_extra_1644(0);
        v53 = v104;
        v105 = "";
        if (v104)
          v105 = v104;
        __message_assert("%s:%u: failed assertion '%s' %s ", "BurstTrie.c", 1434, "old==s", v105);
        goto LABEL_124;
      }
      v23 = v13;
      v24 = *(unsigned int *)(a1 + 148);
      v25 = *(_DWORD *)(a1 + 144) + 1;
      if (v25 < v24)
        goto LABEL_78;
      v26 = *(_QWORD *)(a2 + 2168);
      v27 = *(uint64_t (**)(uint64_t))(a2 + 2160);
      *(_QWORD *)&v118 = 0;
      v28 = expandUnsafeMapNew((void **)(a1 + 8), *(_QWORD *)(a1 + 4568), v24, 0x404uLL, (unint64_t *)&v118, v27, v26);
      if (v28)
      {
        *__error() = v28;
        goto LABEL_13;
      }
      *(_DWORD *)(a1 + 148) = v118;
LABEL_78:
      *(_DWORD *)(a1 + 144) = v25;
      if (!v25)
      {
LABEL_13:
        *(_DWORD *)(a2 + 4) = *__error();
        return 0x300000000;
      }
      v70 = 0;
      v71 = (int8x8_t *)(v23 + 4);
      v72 = v25;
      v73 = 1028 * v25 + 4;
      break;
    default:
      goto LABEL_37;
  }
  do
  {
    if (((*(_DWORD *)(v23 + 4 * (v70 >> 5) + 4) >> v70) & 1) == 0)
    {
      v74 = *(_QWORD *)(a1 + 8);
      *(_DWORD *)(v74 + v73 + 4 * v70) = 0;
      goto LABEL_81;
    }
    v75 = 0;
    v76 = v70 >> 6;
    if (v70 >> 6 == 1)
      goto LABEL_88;
    if (v76 == 2)
      goto LABEL_87;
    if (v76 == 3)
    {
      v77 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v23 + 20));
      v77.i16[0] = vaddlv_u8(v77);
      v75 = v77.u32[0];
LABEL_87:
      v78 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v23 + 12));
      v78.i16[0] = vaddlv_u8(v78);
      v75 += v78.u32[0];
LABEL_88:
      v79 = (uint8x8_t)vcnt_s8(*v71);
      v79.i16[0] = vaddlv_u8(v79);
      v75 += v79.u32[0];
    }
    v80 = (uint8x8_t)vcnt_s8((int8x8_t)(*(_QWORD *)&v71[v76] & ~(-1 << v70)));
    v80.i16[0] = vaddlv_u8(v80);
    v81 = v80.u32[0] + v75;
    v74 = *(_QWORD *)(a1 + 8);
    *(_DWORD *)(v74 + v73 + 4 * v70) = *(_DWORD *)(v23 + 4 * v81 + 38);
LABEL_81:
    ++v70;
  }
  while (v70 != 256);
  *(_DWORD *)(v74 + 1028 * v25) = *(_DWORD *)v23;
  if (*(_DWORD *)a2)
  {
    v108 = a2;
    v110 = v25;
    v112 = v25;
    v114 = a4;
    v82 = (unint64_t *)(a2 + 2148);
    v83 = *(_QWORD *)(a2 + 2148);
    v128 = 0u;
    v129 = 0u;
    v126 = 0u;
    v127 = 0u;
    v124 = 0u;
    v125 = 0u;
    v122 = 0u;
    v123 = 0u;
    v120 = 0u;
    v121 = 0u;
    v118 = 0u;
    v119 = 0u;
    v117 = 0;
    v84 = flatStoreNewBlockForCompact(a1 + 160, v83, (uint64_t)&v118, &v117);
    v85 = v117;
    if (v117 >= 1)
    {
      v86 = (unint64_t *)&v118;
      do
      {
        v88 = *v86++;
        v87 = v88;
        bit_vector_set_2851(a1 + 4528, (v88 >> 17));
        if ((v88 >> 17) != (v88 + 8) >> 17)
          bit_vector_set_2851(a1 + 4528, (v87 >> 17) + 1);
        --v85;
      }
      while (v85);
    }
    v116 = v84;
    *v82 = v84;
    a2 = v108;
    v72 = v110;
    a4 = v114;
    v25 = v112;
    if (v84)
      goto LABEL_97;
LABEL_114:
    *(_DWORD *)(a2 + 4) = *__error();
  }
  else
  {
    v128 = 0u;
    v129 = 0u;
    v126 = 0u;
    v127 = 0u;
    v124 = 0u;
    v125 = 0u;
    v122 = 0u;
    v123 = 0u;
    v120 = 0u;
    v121 = 0u;
    v118 = 0u;
    v119 = 0u;
    v92 = 64;
    v117 = 0;
    do
    {
      v93 = v92;
      v92 *= 2;
    }
    while (v93 < a5 + 22);
    v94 = storageAllocOffset(a1 + 160, v93, (uint64_t)&v118, &v117);
    if (v94)
    {
      v95 = v94;
      v96 = storageResolvePtr(a1 + 160, v94, v93, 1);
      *(_WORD *)v96 = 0;
      v97 = __clz(__rbit32(v93 >> 6));
      if (!v93)
        v97 = -1;
      v96[2] = v97;
      v98 = (v95 >> 6);
    }
    else
    {
      v98 = 0;
    }
    if (v117)
      dirtyStorageOffsets(a1 + 160, (unint64_t *)&v118, v117);
    v116 = v98;
    if (!v98)
      goto LABEL_114;
LABEL_97:
    if ((mergeEntryFlat(a1) & 1) != 0)
    {
      if (!*(_DWORD *)(a2 + 4))
      {
        v89 = __si_assert_copy_extra_1644(0);
        v90 = v89;
        v91 = "";
        if (v89)
          v91 = v89;
        __message_assert("%s:%u: failed assertion '%s' %s ", "BurstTrie.c", 1475, "ms->err", v91);
        free(v90);
        if (__valid_fs(-1))
        {
          MEMORY[0xBAD] = -559038737;
          abort();
        }
        MEMORY[0xC00] = -559038737;
        abort();
      }
    }
    else
    {
      v99 = *(_QWORD *)(a1 + 8) + 1028 * v72 + 4 * *a4;
      *(_DWORD *)(v99 + 4) = ptrD(v116);
      mfree((4 * a7), (4 * (_WORD)v14 + 41) & 0x7FC, (uint64_t *)(a1 + 16));
      return v25 | 0x300000000;
    }
  }
  return v116;
}

uint64_t bt_mergeSet(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, _QWORD *a7, unsigned int *a8, unsigned __int8 a9, uint64_t a10, uint64_t a11)
{
  unsigned int v15;
  double Current;
  int v17;
  NSObject *v18;
  _DWORD *v19;
  os_log_type_t v20;
  void *v21;
  uint64_t v22;
  _QWORD *v23;
  unsigned int v24;
  unint64_t v25;
  signed int v26;
  unsigned int v27;
  unint64_t v28;
  _QWORD *v29;
  char *v30;
  char *v31;
  __int128 *v32;
  unsigned int *v33;
  BOOL v34;
  uint64_t v36;
  int v37;
  NSObject *v38;
  os_log_type_t v39;
  uint64_t v41;
  uint64_t v42;
  double v43;
  uint64_t v44;
  int v45;
  NSObject *v46;
  os_log_type_t v47;
  CFAbsoluteTime v48;
  uint64_t v49;
  double v50;
  uint64_t v51;
  unsigned int v52;
  unsigned int v53;
  _DWORD *v54;
  unsigned int *v55;
  unint64_t Offset;
  size_t v57;
  uint64_t v58;
  __int128 *v59;
  size_t v60;
  int v61;
  NSObject *v62;
  os_log_type_t v63;
  double v64;
  int v65;
  NSObject *v66;
  os_log_type_t v67;
  double v68;
  int v69;
  NSObject *v70;
  os_log_type_t v71;
  float v72;
  int v73;
  NSObject *v74;
  os_log_type_t v75;
  float v76;
  uint64_t v78;
  __int128 *v79;
  unsigned int v80;
  __int128 v81;
  int v82;
  NSObject *v83;
  os_log_type_t v84;
  CFAbsoluteTime v85;
  double v86;
  uint64_t v87;
  unsigned int v88;
  BOOL v89;
  char *v90;
  unint64_t v91;
  unint64_t v92;
  unint64_t v93;
  BOOL v94;
  BOOL v95;
  char *v97;
  unint64_t v98;
  unsigned int *v99;
  unsigned int v100;
  unsigned int *v101;
  unsigned int v102;
  BOOL v103;
  int v104;
  NSObject *v105;
  os_log_type_t v106;
  uint64_t v107;
  uint64_t *v108;
  uint64_t v109;
  void *v110;
  _QWORD *v111;
  _QWORD *v112;
  _QWORD *v113;
  _QWORD *v114;
  uint64_t v115;
  std::__shared_weak_count *v116;
  unint64_t *p_shared_owners;
  unint64_t v118;
  int v119;
  int v120;
  int v121;
  int v122;
  int v123;
  int v124;
  uint8_t *v125;
  size_t v126;
  size_t v127;
  _DWORD *v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  int v132;
  NSObject *v133;
  uint64_t v134;
  _BYTE *v135;
  _DWORD *v136;
  int v137;
  std::__shared_weak_count *v138;
  unint64_t *v139;
  unint64_t v140;
  unint64_t *v141;
  unint64_t v142;
  _QWORD *v143;
  _QWORD *v144;
  unsigned int *v145;
  unint64_t v146;
  unsigned int v147;
  int v148;
  NSObject *v149;
  os_log_type_t v150;
  unsigned int v151;
  uint64_t v152;
  _QWORD *v153;
  _QWORD *v154;
  unsigned int v155;
  BOOL v156;
  unsigned int v157;
  uint64_t v158;
  unsigned int v159;
  unsigned int v160;
  int v161;
  NSObject *v162;
  os_log_type_t v163;
  CFAbsoluteTime v164;
  double v165;
  uint64_t v166;
  uint64_t v167;
  int v168;
  NSObject *v169;
  double v170;
  int v171;
  NSObject *v172;
  os_log_type_t v173;
  uint64_t v174;
  uint64_t v175;
  unint64_t v176;
  uint64_t v177;
  unint64_t v178;
  double v179;
  unsigned int v180;
  unsigned int v181;
  unsigned int v182;
  _QWORD *v183;
  uint64_t v184;
  unint64_t v185;
  int v186;
  unsigned int *v187;
  unsigned int *v188;
  _BYTE *v189;
  _DWORD *v190;
  _BYTE *v191;
  unsigned int v192;
  unsigned int v193;
  unsigned int v194;
  unsigned int v195;
  uint64_t sig;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  unint64_t v201;
  unsigned int v202;
  uint64_t v203;
  uint64_t v204;
  BOOL v205;
  unsigned int v206;
  char *v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  char *v211;
  unsigned int *v212;
  unsigned int v213;
  int64_t v214;
  char *v215;
  uint64_t v216;
  uint64_t v217;
  int v218;
  unint64_t v219;
  unint64_t v220;
  uint64_t v221;
  int v222;
  unint64_t v223;
  int64_t v225;
  const void *v226;
  int64_t v227;
  unint64_t v228;
  int v229;
  NSObject *v230;
  os_log_type_t v231;
  float v232;
  uint64_t v233;
  uint64_t v234;
  unint64_t v235;
  uint64_t v236;
  int v237;
  int v238;
  NSObject *v239;
  unint64_t v240;
  double v241;
  int v242;
  NSObject *v243;
  uint64_t v244;
  unsigned int v245;
  int v246;
  NSObject *v247;
  unint64_t v248;
  float v249;
  uint64_t v250;
  char *v251;
  unsigned int *v252;
  char *v253;
  size_t v254;
  int v255;
  uint64_t v256;
  unint64_t v257;
  BOOL v258;
  _QWORD *v259;
  _QWORD *v260;
  uint64_t v261;
  uint64_t v262;
  uint64_t v263;
  uint64_t v266;
  uint64_t v267;
  unsigned int *v268;
  unint64_t v269;
  _QWORD *v271;
  uint64_t v272;
  _BYTE *v273;
  int v275;
  unsigned int (*v276)(uint64_t);
  unint64_t v277;
  pthread_mutex_t *v278;
  pthread_mutex_t *v279;
  int v280;
  int v281;
  _QWORD *v282;
  char *__base;
  int __basea;
  unsigned int *v285;
  unint64_t v286;
  unint64_t v287;
  uint64_t v288;
  _DWORD __n[5];
  void *__src[2];
  void *__p[2];
  char v292;
  uint64_t v293;
  std::__shared_weak_count *v294;
  int *v295[4];
  __int128 v296;
  _BYTE v297[2120];
  uint64_t v298;
  uint64_t v299;
  _BYTE v300[12];
  char v301;
  uint8_t buf[32];
  __int128 v303;
  uint64_t v304;

  v304 = *MEMORY[0x1E0C80C00];
  bzero(v297, 0x848uLL);
  v266 = a3;
  v15 = *(_DWORD *)(a3 + 4448);
  v296 = 0u;
  v298 = a10;
  v299 = a11;
  *(_OWORD *)&v297[1044] = 0u;
  v295[0] = (int *)a1;
  v295[1] = 0;
  v295[3] = 0;
  v295[2] = (int *)v15;
  ++generation;
  Current = CFAbsoluteTimeGetCurrent();
  v17 = *__error();
  v18 = _SILogForLogForCategory(10);
  v19 = &unk_1EF19F000;
  v20 = 2 * (dword_1EF19FCB4 < 4);
  if (os_log_type_enabled(v18, v20))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1B8270000, v18, v20, "Merge update set ... ", buf, 2u);
  }
  *__error() = v17;
  currentSet = (uint64_t)a7;
  currentCount = 0;
  if (__THREAD_SLOT_KEY)
  {
    v21 = pthread_getspecific(__THREAD_SLOT_KEY);
    if (v21)
      goto LABEL_5;
  }
  else
  {
    makeThreadId();
    v21 = pthread_getspecific(__THREAD_SLOT_KEY);
    if (v21)
    {
LABEL_5:
      if ((unint64_t)v21 < 0x801)
        goto LABEL_6;
    }
  }
  makeThreadId();
  v21 = pthread_getspecific(__THREAD_SLOT_KEY);
LABEL_6:
  v273 = (_BYTE *)(a1 + 4580);
  v22 = (uint64_t)v21 - 1;
  v23 = malloc_type_zone_calloc((malloc_zone_t *)indexingZone, 1uLL, 0x38uLL, 0x10A0040FEFBC11AuLL);
  *v23 = a1;
  v23[1] = a7;
  v282 = v23;
  CIOnThreadCleanUpPush(v22, (uint64_t)TrieMergeCleanup, (uint64_t)v23);
  HIDWORD(v25) = qos_class_self() - 9;
  LODWORD(v25) = HIDWORD(v25);
  v24 = v25 >> 2;
  if (v24 > 6)
    v26 = 0;
  else
    v26 = dword_1B8630ED0[v24];
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 4592));
  if (*(_QWORD *)(a1 + 4776) || *(_DWORD *)(a1 + 4788) || *(_BYTE *)(a1 + 4804))
    goto LABEL_12;
  if (v26 > 5)
  {
LABEL_115:
    *(_QWORD *)(a1 + 4776) = pthread_self();
    *(_BYTE *)(a1 + 4804) = 1;
    goto LABEL_13;
  }
  if (!*(_QWORD *)(a1 + 16 * v26 + 4656))
  {
    v107 = v26 - 1;
    v108 = (uint64_t *)(a1 + 16 * v26 + 4672);
    while (v107 != 4)
    {
      v109 = *v108;
      v108 += 2;
      ++v107;
      if (v109)
      {
        if (v107 <= 4)
          goto LABEL_12;
        goto LABEL_115;
      }
    }
    goto LABEL_115;
  }
LABEL_12:
  db_rwlock_wait(a1 + 4592, v26, 3);
LABEL_13:
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 4592));
  *((_BYTE *)v282 + 49) = 1;
  db_read_lock((uint64_t)(a7 + 38));
  *((_BYTE *)v282 + 48) = 1;
  v272 = a7[75];
  v276 = (unsigned int (*)(uint64_t))a7[74];
  v27 = atomic_load((unsigned int *)(a7[3] + 16));
  v263 = a1;
  if (!v27 && !a7[10] && !a7[6])
  {
    v36 = 0;
    goto LABEL_57;
  }
  v278 = (pthread_mutex_t *)(a1 + 4592);
  v261 = a2;
  v271 = a7;
  v28 = atomic_load((unsigned int *)(a7[3] + 16));
  v29 = malloc_type_zone_malloc((malloc_zone_t *)indexingZone, 8 * (v28 + 1), 0x2004093837F09uLL);
  v282[2] = v29;
  v30 = (char *)malloc_type_zone_malloc((malloc_zone_t *)indexingZone, 16 * (v28 + 1), 0x1000040451B5BE8uLL);
  v282[3] = v30;
  v31 = v30;
  v32 = (__int128 *)malloc_type_zone_malloc((malloc_zone_t *)indexingZone, 16 * (v28 + 1), 0x1000040451B5BE8uLL);
  v282[5] = v32;
  v33 = (unsigned int *)malloc_type_zone_calloc((malloc_zone_t *)indexingZone, v28 + 1, 0x18uLL, 0x10200409F4E64B8uLL);
  v282[4] = v33;
  if (v29)
    v34 = v31 == 0;
  else
    v34 = 1;
  if (v34 || v33 == 0)
  {
    v36 = 0xFFFFFFFFLL;
    goto LABEL_57;
  }
  v268 = v33;
  __base = v31;
  v262 = v22;
  v37 = *__error();
  v38 = _SILogForLogForCategory(10);
  v39 = 2 * (dword_1EF19FCB4 < 4);
  if (os_log_type_enabled(v38, v39))
  {
    *(_DWORD *)buf = 134217984;
    *(_QWORD *)&buf[4] = v28;
    _os_log_impl(&dword_1B8270000, v38, v39, "Merge %lu terms", buf, 0xCu);
  }
  *__error() = v37;
  v41 = v272;
  v42 = a1 + 4592;
  if (v276(v272) == -1)
  {
    v61 = *__error();
    v62 = _SILogForLogForCategory(10);
    v63 = 2 * (dword_1EF19FCB4 < 4);
    if (os_log_type_enabled(v62, v63))
    {
      *(_WORD *)buf = 0;
LABEL_54:
      _os_log_impl(&dword_1B8270000, v62, v63, "Merge Canceled", buf, 2u);
    }
LABEL_55:
    *__error() = v61;
    v36 = 89;
    goto LABEL_56;
  }
  v43 = CFAbsoluteTimeGetCurrent();
  v44 = v271[3];
  *(_QWORD *)&__n[1] = 0;
  *(_QWORD *)&__n[3] = &__n[1];
  LODWORD(__src[1]) = 0;
  __src[0] = (void *)0x2000000000;
  *(_QWORD *)buf = MEMORY[0x1E0C809B0];
  *(_QWORD *)&buf[8] = 0x40000000;
  *(_QWORD *)&buf[16] = ___hashTableIterate_block_invoke;
  *(_QWORD *)&buf[24] = &unk_1E6E2F4D0;
  *(_QWORD *)&v303 = &__n[1];
  *((_QWORD *)&v303 + 1) = v29;
  _TermTrieWalkFatWithOptions(v44 + 32, 0, 1, 0, (uint64_t)buf, 0, 0);
  _Block_object_dispose(&__n[1], 8);
  v45 = *__error();
  v46 = _SILogForLogForCategory(10);
  v47 = 2 * (dword_1EF19FCB4 < 4);
  if (os_log_type_enabled(v46, v47))
  {
    v48 = CFAbsoluteTimeGetCurrent();
    *(_DWORD *)buf = 134217984;
    *(double *)&buf[4] = v48 - v43;
    _os_log_impl(&dword_1B8270000, v46, v47, "Copied term data: %f seconds", buf, 0xCu);
  }
  *__error() = v45;
  if (v276(v272) == -1)
  {
    v61 = *__error();
    v62 = _SILogForLogForCategory(10);
    v63 = 2 * (dword_1EF19FCB4 < 4);
    if (os_log_type_enabled(v62, v63))
    {
      *(_WORD *)buf = 0;
      goto LABEL_54;
    }
    goto LABEL_55;
  }
  v49 = *(_QWORD *)v266;
  v257 = *(_QWORD *)(v266 + 8);
  v50 = CFAbsoluteTimeGetCurrent();
  __n[0] = 0;
  if ((_DWORD)v28)
  {
    LODWORD(v51) = 0;
    v52 = 0;
    v53 = 0;
    v54 = __base;
    do
    {
      while (1)
      {
        v55 = &v54[4 * v53];
        *v55 = v51;
        Offset = bt_getOffset(a1, *(unsigned __int16 *)(v29[v51] + 16), v29[v51] + 18, __n);
        *((_QWORD *)v55 + 1) = Offset;
        v51 = (v51 + 1);
        if (!(_DWORD)Offset)
          break;
        if (v51 < v28)
        {
          v57 = __n[0];
          while (1)
          {
            v58 = v29[v51];
            if (v57 >= *(unsigned __int16 *)(v58 + 16)
              || memcmp((const void *)(v29[*v55] + 18), (const void *)(v58 + 18), v57))
            {
              break;
            }
            if (v28 == ++v51)
            {
              LODWORD(v51) = v28;
              break;
            }
          }
          v54 = __base;
        }
        v54[4 * v53++ + 1] = v51;
        if (v51 >= v28)
          goto LABEL_47;
      }
      v59 = &v32[v52];
      *(_DWORD *)v59 = *v55;
      *((_DWORD *)v59 + 2) = 0;
      if (v51 < v28)
      {
        while (!bt_getOffset(a1, *(unsigned __int16 *)(v29[v51] + 16), v29[v51] + 18, __n))
        {
          if (v28 == ++v51)
          {
            LODWORD(v51) = v28;
            break;
          }
        }
      }
      DWORD1(v32[v52++]) = v51;
    }
    while (v51 < v28);
LABEL_47:
    if (v53 > v28)
    {
LABEL_312:
      v251 = __si_assert_copy_extra_1644(0);
      goto LABEL_313;
    }
    v42 = a1 + 4592;
    v41 = v272;
    if (v52 > v28)
    {
LABEL_92:
      v251 = __si_assert_copy_extra_1644(0);
      goto LABEL_318;
    }
    v60 = v53;
  }
  else
  {
    v53 = 0;
    v52 = 0;
    v60 = 0;
    v54 = __base;
  }
  if (v52 + v53 > v28)
    goto LABEL_312;
  v256 = v49;
  qsort(v54, v60, 0x10uLL, (int (__cdecl *)(const void *, const void *))mergeRangeCompare);
  if (v52)
  {
    v78 = v52;
    v79 = v32;
    do
    {
      v80 = v53 + 1;
      v81 = *v79++;
      *(_OWORD *)&v54[4 * v53++] = v81;
      --v78;
    }
    while (v78);
  }
  else
  {
    v80 = v53;
  }
  v282[5] = 0;
  free(v32);
  v82 = *__error();
  v83 = _SILogForLogForCategory(10);
  v84 = 2 * (dword_1EF19FCB4 < 4);
  if (os_log_type_enabled(v83, v84))
  {
    v85 = CFAbsoluteTimeGetCurrent();
    *(_DWORD *)buf = 134217984;
    *(double *)&buf[4] = v85 - v50;
    _os_log_impl(&dword_1B8270000, v83, v84, "Computed ranges: %f seconds", buf, 0xCu);
  }
  *__error() = v82;
  if (v276(v41) == -1)
  {
    v104 = *__error();
    v105 = _SILogForLogForCategory(10);
    v19 = &unk_1EF19F000;
    v106 = 2 * (dword_1EF19FCB4 < 4);
    v22 = v262;
    if (os_log_type_enabled(v105, v106))
    {
      *(_WORD *)buf = 0;
LABEL_107:
      _os_log_impl(&dword_1B8270000, v105, v106, "Merge Canceled", buf, 2u);
    }
LABEL_108:
    *__error() = v104;
    v36 = 89;
    goto LABEL_57;
  }
  v86 = CFAbsoluteTimeGetCurrent();
  db_upgrade_lock(v42);
  if (v80)
  {
    v87 = 0;
    v280 = 0;
    v88 = 0;
    v89 = 1;
    while (1)
    {
      v258 = v89;
      pthread_mutex_lock(v278);
      *(_BYTE *)(a1 + 4804) = 1;
      db_rwlock_wakeup((uint64_t)v278, 1, 1);
      pthread_mutex_unlock(v278);
      if (v87)
      {
        v90 = &__base[16 * v87];
        v91 = *((_QWORD *)v90 + 1);
        v92 = (unint64_t)v91 << 6;
        if (HIDWORD(v91))
          v92 = 0;
        v93 = *((_QWORD *)v90 - 1);
        v94 = (unint64_t)v93 << 6 > v92 && HIDWORD(v93) == 0;
        v95 = v94 || (_DWORD)v93 == 0;
        if (v95 && v91 != 0)
          goto LABEL_92;
      }
      db_upgrade_lock((uint64_t)v278);
      v97 = &__base[16 * v87];
      v98 = *(unsigned int *)v97;
      v100 = *((_DWORD *)v97 + 1);
      v99 = (unsigned int *)(v97 + 4);
      if (v98 < v100)
        break;
LABEL_78:
      v89 = ++v87 < (unint64_t)v80;
      if (v87 == v80)
      {
        v258 = 0;
        goto LABEL_118;
      }
    }
    v101 = &v268[6 * v98 + 2];
    while (1)
    {
      v102 = bt_mergeCallback(*(unsigned __int16 *)(v29[v98] + 16), (void *)(v29[v98] + 18), v295);
      if (!v102)
        break;
      if (v102 > v88)
        v88 = v102;
      *(v101 - 2) = v102;
      *(_QWORD *)v101 = v29[v98];
      if (*(_DWORD *)(a1 + 4584))
        v103 = v280 <= 9999;
      else
        v103 = 0;
      if (v103)
        v280 += db_writer_yield_lock((uint64_t)v278);
      ++v98;
      v101 += 6;
      if (v98 >= *v99)
        goto LABEL_78;
    }
  }
  else
  {
    v258 = 0;
    v88 = 0;
    v280 = 0;
  }
LABEL_118:
  v110 = __base;
  v282[4] = 0;
  v285 = v268;
  v286 = v28;
  v287 = v28;
  v288 = v88;
  if (a5)
    directoryStoreMergeUpdateSet(a5, v271 + 6, (uint64_t)&v285);
  if (a6)
  {
    v111 = _os_feature_enabled_impl() ? (_QWORD *)v271[10] : 0;
    v260 = v111;
    v114 = (_QWORD *)*v111;
    v113 = v111 + 1;
    v112 = v114;
    if (v114 != v113)
    {
      v259 = v113;
      while (1)
      {
        v115 = v112[5];
        v116 = (std::__shared_weak_count *)v112[6];
        if (v116)
        {
          p_shared_owners = (unint64_t *)&v116->__shared_owners_;
          do
            v118 = __ldxr(p_shared_owners);
          while (__stxr(v118 + 1, p_shared_owners));
        }
        v293 = 0;
        v294 = 0;
        v119 = *(_DWORD *)(v115 + 12);
        if (v119 == 512)
          v120 = 1;
        else
          v120 = 3;
        if (v119 == 768)
          v120 = 2;
        if (v119 == 256)
          v121 = 0;
        else
          v121 = v120;
        v122 = *(_DWORD *)(v115 + 16);
        if (v122 == 2)
          v123 = 1;
        else
          v123 = 3;
        if (v122 == 4)
          v124 = 0;
        else
          v124 = v123;
        IVFVectorIndex_s::getOrCreateVectorIndex(&v293, a6 + 8, *(unsigned int *)(v115 + 8), *(unsigned __int16 *)(v115 + 20), v121, v124, *(unsigned __int8 *)(v115 + 22));
        *(_OWORD *)&__n[1] = 0uLL;
        __src[0] = 0;
        (*(void (**)(uint8_t *__return_ptr, uint64_t, uint64_t))(*(_QWORD *)v293 + 312))(buf, v293, a6 + 40);
        if ((buf[23] & 0x80u) == 0)
          v125 = buf;
        else
          v125 = *(uint8_t **)buf;
        v126 = strlen((const char *)v125);
        if (v126 >= 0x7FFFFFFFFFFFFFF8)
          abort();
        v127 = v126;
        if (v126 >= 0x17)
          break;
        HIBYTE(__src[0]) = v126;
        v128 = &__n[1];
        if (v126)
          goto LABEL_154;
LABEL_155:
        *((_BYTE *)v128 + v127) = 0;
        if ((char)buf[23] < 0)
          operator delete(*(void **)buf);
        v131 = v293;
        (*(void (**)(uint64_t, uint64_t, _QWORD *, unsigned int **))(*(_QWORD *)v293 + 96))(v293, v115, v271 + 11, &v285);
        v132 = *__error();
        v133 = _SILogForLogForCategory(16);
        if (os_log_type_enabled(v133, OS_LOG_TYPE_DEFAULT))
        {
          v134 = a6 + 64;
          if (*(char *)(a6 + 87) < 0)
            v134 = *(_QWORD *)(a6 + 64);
          v292 = 3;
          LODWORD(__p[0]) = 4085052;
          (*(void (**)(_BYTE *__return_ptr, uint64_t, void **))(*(_QWORD *)v115 + 312))(v300, v115, __p);
          if (v301 >= 0)
            v135 = v300;
          else
            v135 = *(_BYTE **)v300;
          if (SHIBYTE(__src[0]) >= 0)
            v136 = &__n[1];
          else
            v136 = *(_DWORD **)&__n[1];
          v137 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v131 + 16))(v131);
          *(_DWORD *)buf = 136316162;
          *(_QWORD *)&buf[4] = v134;
          *(_WORD *)&buf[12] = 2048;
          *(_QWORD *)&buf[14] = v260;
          *(_WORD *)&buf[22] = 2080;
          *(_QWORD *)&buf[24] = v135;
          LOWORD(v303) = 2080;
          *(_QWORD *)((char *)&v303 + 2) = v136;
          WORD5(v303) = 1024;
          HIDWORD(v303) = v137;
          _os_log_impl(&dword_1B8270000, v133, OS_LOG_TYPE_DEFAULT, "[%s] mergeUpdateSet %p %s to %s total %u", buf, 0x30u);
          if (v301 < 0)
            operator delete(*(void **)v300);
          v113 = v259;
          if (v292 < 0)
            operator delete(__p[0]);
        }
        *__error() = v132;
        if (SHIBYTE(__src[0]) < 0)
          operator delete(*(void **)&__n[1]);
        v138 = v294;
        v110 = __base;
        if (v294)
        {
          v139 = (unint64_t *)&v294->__shared_owners_;
          do
            v140 = __ldaxr(v139);
          while (__stlxr(v140 - 1, v139));
          if (!v140)
          {
            ((void (*)(std::__shared_weak_count *))v138->__on_zero_shared)(v138);
            std::__shared_weak_count::__release_weak(v138);
          }
        }
        if (!v116)
          goto LABEL_181;
        v141 = (unint64_t *)&v116->__shared_owners_;
        do
          v142 = __ldaxr(v141);
        while (__stlxr(v142 - 1, v141));
        if (!v142)
        {
          ((void (*)(std::__shared_weak_count *))v116->__on_zero_shared)(v116);
          std::__shared_weak_count::__release_weak(v116);
          v143 = (_QWORD *)v112[1];
          if (!v143)
          {
            do
            {
LABEL_185:
              v144 = (_QWORD *)v112[2];
              v34 = *v144 == (_QWORD)v112;
              v112 = v144;
            }
            while (!v34);
            goto LABEL_126;
          }
        }
        else
        {
LABEL_181:
          v143 = (_QWORD *)v112[1];
          if (!v143)
            goto LABEL_185;
        }
        do
        {
          v144 = v143;
          v143 = (_QWORD *)*v143;
        }
        while (v143);
LABEL_126:
        v112 = v144;
        if (v144 == v113)
          goto LABEL_188;
      }
      v129 = (v126 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v126 | 7) != 0x17)
        v129 = v126 | 7;
      v130 = v129 + 1;
      v128 = operator new(v129 + 1);
      *(_QWORD *)&__n[3] = v127;
      __src[0] = (void *)(v130 | 0x8000000000000000);
      *(_QWORD *)&__n[1] = v128;
LABEL_154:
      memmove(v128, v125, v127);
      goto LABEL_155;
    }
  }
LABEL_188:
  v145 = v285;
  v146 = v286;
  v282[4] = v285;
  v147 = v288;
  if (v280)
  {
    v148 = *__error();
    v149 = _SILogForLogForCategory(10);
    v150 = 2 * (dword_1EF19FCB4 < 4);
    if (os_log_type_enabled(v149, v150))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = v280;
      _os_log_impl(&dword_1B8270000, v149, v150, "Flush yielded %d times.", buf, 8u);
    }
    *__error() = v148;
    v110 = __base;
  }
  if (v258)
  {
    v36 = 0xFFFFFFFFLL;
    v19 = (_DWORD *)&unk_1EF19F000;
    goto LABEL_56;
  }
  v22 = v262;
  if (a8)
  {
    if (v80 <= 0x200)
      v151 = 0;
    else
      v151 = v80;
    *a8 = v151;
  }
  v152 = v266 + 40;
  v282[3] = 0;
  free(v110);
  v153 = (_QWORD *)v271[29];
  v19 = &unk_1EF19F000;
  if (v153)
  {
    do
    {
      v154 = (_QWORD *)*v153;
      madvise(v153, v153[2] - (_QWORD)v153, 4);
      v153 = v154;
    }
    while (v154);
  }
  v155 = *(_DWORD *)(v266 + 4448);
  v156 = v147 >= v155;
  v157 = v147 - v155;
  if (!v156 || (v36 = termIdStoreAllocBulk(v152, v157 + 1), !(_DWORD)v36))
  {
    v158 = a4 + 40;
    v159 = *(_DWORD *)(a4 + 4448);
    v156 = v147 >= v159;
    v160 = v147 - v159;
    if (!v156 || (v36 = termIdStoreAllocBulk(a4 + 40, v160 + 1), !(_DWORD)v36))
    {
      *(_QWORD *)&v145[6 * v146 + 2] = *(_QWORD *)&v145[6 * v146 - 4];
      db_downgrade_lock(v278);
      v282[2] = 0;
      free(v29);
      storageDeactivateAll((int *)(v263 + 160), 0);
      storageUnmap(v263 + 160);
      db_write_unlock((uint64_t)v278);
      *((_BYTE *)v282 + 49) = 0;
      v161 = *__error();
      v162 = _SILogForLogForCategory(10);
      v163 = 2 * (dword_1EF19FCB4 < 4);
      if (os_log_type_enabled(v162, v163))
      {
        v164 = CFAbsoluteTimeGetCurrent();
        *(_DWORD *)buf = 134217984;
        *(double *)&buf[4] = v164 - v86;
        _os_log_impl(&dword_1B8270000, v162, v163, "Merged terms: %f seconds", buf, 0xCu);
      }
      *__error() = v161;
      if (v276(v272) != -1)
      {
        _qsort_termids((uint64_t)v145, v146 - 1);
        v165 = CFAbsoluteTimeGetCurrent();
        v166 = atomic_load((unsigned int *)v271 + 25);
        v167 = compressPostings(v266, v166, v271[11], v271[1], v146, (uint64_t)v145, *((unsigned int *)v271 + 4), a10, a11);
        v22 = v262;
        if ((_DWORD)v167)
        {
          v36 = v167;
          v168 = *__error();
          v169 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v169, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315650;
            *(_QWORD *)&buf[4] = "TrieMergeUpdates";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 2869;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v36;
            _os_log_error_impl(&dword_1B8270000, v169, OS_LOG_TYPE_ERROR, "%s:%d: compressPostings err:%d", buf, 0x18u);
          }
          *__error() = v168;
          goto LABEL_57;
        }
        storageUnmap(v152);
        v170 = CFAbsoluteTimeGetCurrent() - v165;
        *(double *)&TrieMergeUpdates_postingsCompressionTime = *(double *)&TrieMergeUpdates_postingsCompressionTime
                                                             + v170;
        v171 = *__error();
        v172 = _SILogForLogForCategory(10);
        v173 = 2 * (dword_1EF19FCB4 < 4);
        if (os_log_type_enabled(v172, v173))
        {
          *(_DWORD *)buf = 134218240;
          *(double *)&buf[4] = v170;
          *(_WORD *)&buf[12] = 2048;
          *(_QWORD *)&buf[14] = TrieMergeUpdates_postingsCompressionTime;
          _os_log_impl(&dword_1B8270000, v172, v173, "Compressed postings data: %f seconds %f total", buf, 0x16u);
        }
        *__error() = v171;
        __p[0] = 0;
        v174 = _fd_acquire_fd(*(_QWORD *)(v266 + 4480), __p);
        v175 = v174;
        v176 = *(_QWORD *)(v266 + 8);
        v177 = v257 - v176;
        if (v257 <= v176)
        {
          sync_invalidate_fd(v174, v256, *(_QWORD *)v266 - v256);
          v176 = *(_QWORD *)(v266 + 8);
          v177 = *(_QWORD *)(v266 + 24) - v176;
        }
        sync_invalidate_fd(v175, v176, v177);
        fsync(v175);
        _fd_release_fd(*(_DWORD **)(v266 + 4480), v175, 0, (uint64_t)__p[0]);
        if (!v146)
          goto LABEL_298;
        v178 = *(_QWORD *)(a4 + 8);
        v267 = *(_QWORD *)a4;
        v179 = CFAbsoluteTimeGetCurrent();
        v180 = *v145;
        if (*v145 <= v145[6 * v146 - 6])
          v180 = v145[6 * v146 - 6];
        v181 = *(_DWORD *)(a4 + 4448);
        v156 = v180 >= v181;
        v182 = v180 - v181;
        if (v156)
        {
          v36 = termIdStoreAllocBulk(v158, v182 + 1);
          if ((_DWORD)v36)
          {
LABEL_56:
            v22 = v262;
            goto LABEL_57;
          }
        }
        v269 = v178;
        *(_QWORD *)&v303 = 0;
        memset(buf, 0, sizeof(buf));
        v183 = (_QWORD *)a4;
        PayloadWriteBufferInit(buf, (_DWORD *)a4);
        v184 = *(_QWORD *)(a4 + 8);
        *(_OWORD *)&__n[1] = 0u;
        *(_OWORD *)__src = 0u;
        ci_position_run_init((uint64_t)&__n[1]);
        if ((_QWORD)v303)
          goto LABEL_293;
        v185 = 0;
        v281 = 0;
        v186 = 0;
        v187 = (unsigned int *)v271;
        v279 = (pthread_mutex_t *)(v271 + 30);
        while (1)
        {
          v188 = &v145[6 * v185];
          v191 = (_BYTE *)*((_QWORD *)v188 + 1);
          v190 = v188 + 2;
          v189 = v191;
          if ((*v191 & 1) == 0)
          {
            v192 = *((_DWORD *)v189 + 3);
            if (v192)
              break;
          }
          v204 = 0;
          ++v185;
LABEL_284:
          if (v185 >= v146 || v204)
          {
LABEL_291:
            if (v186)
              PayloadWritePulseHeader((int *)buf, v183, v184 - v183[1], v281);
LABEL_293:
            free(*(void **)buf);
            free(__src[1]);
            v229 = *__error();
            v230 = _SILogForLogForCategory(10);
            v231 = 2 * (v19[813] < 4);
            if (os_log_type_enabled(v230, v231))
            {
              v232 = CFAbsoluteTimeGetCurrent() - v179;
              *(_DWORD *)v300 = 134217984;
              *(double *)&v300[4] = v232;
              _os_log_impl(&dword_1B8270000, v230, v231, "flush positions %f", v300, 0xCu);
            }
            *__error() = v229;
            *(_QWORD *)v300 = 0;
            v233 = _fd_acquire_fd(v183[560], v300);
            v234 = v233;
            v235 = v183[1];
            v236 = v269 - v235;
            if (v269 <= v235)
            {
              sync_invalidate_fd(v233, v267, *v183 - v267);
              v235 = v183[1];
              v236 = v183[3] - v235;
            }
            sync_invalidate_fd(v234, v235, v236);
            fsync(v234);
            _fd_release_fd((_DWORD *)v183[560], v234, 0, *(uint64_t *)v300);
            v36 = v303;
            if (!(_DWORD)v303)
            {
LABEL_298:
              storageUnmap(v158);
              v237 = _fd_acquire_fd(*(_QWORD *)(a4 + 4480), __p);
              fsync(v237);
              _fd_release_fd(*(_DWORD **)(a4 + 4480), v237, 0, (uint64_t)__p[0]);
              v36 = 0;
            }
            goto LABEL_56;
          }
        }
        v193 = atomic_load(v187 + 62);
        if (v192 >= v193)
          goto LABEL_291;
        __basea = v186;
        v194 = *(_DWORD *)(*(_QWORD *)v190 + 12);
        v195 = atomic_load(v187 + 62);
        if (v194 >= v195)
        {
          v252 = v187;
          v251 = __si_assert_copy_extra_1644(0);
          atomic_load(v252 + 62);
          __message_assert("%s:%u: failed assertion '%s' %s termId: %d next_term_id: %d");
          goto LABEL_314;
        }
        sig = v279->__sig;
        v197 = *(_QWORD *)v190;
        v198 = v145[6 * v185];
        v199 = *(unsigned int *)(v197 + 12);
        v277 = 8 * v198;
        v200 = *(_QWORD *)storageResolvePtr(v158, 8 * v198, 8uLL, 1);
        __n[1] = 0;
        v300[0] = 0;
        v201 = v185 + 1;
        v202 = v281;
        if (v185 + 1 < v146)
        {
          v203 = (uint64_t)&v145[6 * v185 + 8];
          do
          {
            if ((**(_BYTE **)v203 & 1) == 0 && *(_DWORD *)(*(_QWORD *)v203 + 12))
            {
              v202 = v145[6 * v201];
              goto LABEL_240;
            }
            ++v201;
            v203 += 24;
          }
          while (v146 != v201);
          v201 = v146;
        }
LABEL_240:
        v205 = v201 == v146;
        if (v201 == v146)
          v202 = v198;
        v206 = v198 - v202;
        if ((_DWORD)v198 != v202)
          v205 = 0;
        if (v198 <= v202 && !v205)
        {
          v251 = __si_assert_copy_extra_1644(0);
          __message_assert("%s:%u: failed assertion '%s' %s termId: %d prevTermId: %d j: %ld count: %ld", "BurstTrie.c");
LABEL_319:
          free(v251);
          if (__valid_fs(-1))
          {
            MEMORY[0xBAD] = -559038737;
            abort();
          }
          MEMORY[0xC00] = -559038737;
          abort();
        }
        v207 = (char *)__src[1];
        if (v206 > 0x7F)
        {
          if (v206 >> 14)
          {
            if (v206 >> 21)
            {
              if (v206 >> 28)
              {
                *(_BYTE *)__src[1] = -16;
                *(_DWORD *)(v207 + 1) = v206;
                v208 = 5;
              }
              else
              {
                *(_BYTE *)__src[1] = HIBYTE(v206) | 0xE0;
                v207[1] = BYTE2(v206);
                v207[2] = BYTE1(v206);
                v207[3] = v206;
                v208 = 4;
              }
            }
            else
            {
              *(_BYTE *)__src[1] = BYTE2(v206) | 0xC0;
              v207[1] = BYTE1(v206);
              v207[2] = v206;
              v208 = 3;
            }
          }
          else
          {
            *(_BYTE *)__src[1] = BYTE1(v206) | 0x80;
            v207[1] = v206;
            v208 = 2;
          }
        }
        else
        {
          *(_BYTE *)__src[1] = v206;
          v208 = 1;
        }
        v275 = v198;
        v209 = v208;
        if (v200)
          v209 = v2_writeVInt64((uint64_t)v207, v208, (2 * v200) | 1);
        v210 = sig + 32 * v199;
        v211 = (char *)v2_writeVInt64((uint64_t)v207, v209, 2 * *(_QWORD *)(v210 + 16));
        __src[0] = v211;
        if (!*(_DWORD *)v210 && !*(_DWORD *)(v210 + 4))
        {
          if (*(_QWORD *)(v210 + 16))
          {
            v253 = v211 + 1;
            v254 = *(_QWORD *)&__n[3];
            while ((unint64_t)v253 >= v254)
            {
              v254 *= 2;
              v207 = (char *)malloc_type_realloc(v207, v254, 0x485463EBuLL);
              if (!v207)
              {
                v251 = __si_assert_copy_extra_1644(0);
                goto LABEL_318;
              }
            }
            v255 = v300[0];
            v251 = __si_assert_copy_extra_1644(0);
            if (v255)
            {
LABEL_318:
              __message_assert("%s:%u: failed assertion '%s' %s ");
              goto LABEL_319;
            }
          }
          else
          {
            v251 = __si_assert_copy_extra_1644(0);
          }
LABEL_313:
          __message_assert("%s:%u: failed assertion '%s' %s ");
          goto LABEL_314;
        }
        v281 = v202;
        v212 = (unsigned int *)v271 + 67;
        v213 = atomic_load((unsigned int *)v271 + 67);
        CIBuildPositionRun((uint64_t)v279, v261, v210, (uint64_t)&__n[1], a9);
        atomic_store(v213, v212);
        v214 = (int64_t)__src[0];
        v215 = (char *)__src[0] + 21;
        v216 = *(_QWORD *)(a4 + 8);
        v19 = (_DWORD *)&unk_1EF19F000;
        if ((char *)__src[0] + 21 <= (void *)(v216 - *(_QWORD *)a4) || (_QWORD)v303)
        {
          v221 = *(_QWORD *)&buf[24];
          v183 = (_QWORD *)a4;
        }
        else
        {
          v183 = (_QWORD *)a4;
          if (!__basea || (PayloadWritePulseHeader((int *)buf, (_QWORD *)a4, v184 - v216, v275), (v217 = v303) == 0))
          {
            v218 = growPayloadData(a4);
            v217 = v218;
            *(_QWORD *)&v303 = v218;
          }
          __basea = 0;
          v184 = *(_QWORD *)(a4 + 8);
          v219 = v184 - *(_QWORD *)a4;
          v220 = *(_QWORD *)&buf[8];
          v221 = (v184 - *(_DWORD *)a4);
          if (v219 >= *(_QWORD *)&buf[8])
            v221 = *(_QWORD *)&buf[8];
          *(_QWORD *)&buf[16] = v221;
          *(_QWORD *)&buf[24] = v221;
          if ((unint64_t)v215 <= v219)
          {
            v216 = v184;
            if (v221 >= 2)
              goto LABEL_279;
            goto LABEL_288;
          }
          v216 = v184;
          if (!v217)
          {
            do
            {
              v222 = growPayloadData(a4);
              v184 = *(_QWORD *)(a4 + 8);
              v223 = v184 - *(_QWORD *)a4;
            }
            while ((unint64_t)v215 > v223 && v222 == 0);
            __basea = 0;
            if (v223 >= v220)
              v221 = v220;
            else
              v221 = (v184 - *(_DWORD *)a4);
            *(_QWORD *)&buf[16] = v221;
            *(_QWORD *)&buf[24] = v221;
            *(_QWORD *)&v303 = v222;
            v216 = v184;
            if (v221 < 2)
              goto LABEL_288;
LABEL_279:
            v183[1] = v216 - 1;
            v225 = v221 - 1;
            *(_QWORD *)&buf[24] = v225;
            *(_BYTE *)(*(_QWORD *)buf + v225) = v300[0];
LABEL_280:
            v226 = __src[1];
            v103 = v225 <= v214;
            v227 = v225 - v214;
            if (v103)
            {
              _PayloadWriteData((int *)buf, v183, (char *)__src[1], v214);
            }
            else
            {
              v183[1] -= v214;
              *(_QWORD *)&buf[24] = v227;
              memcpy((void *)(*(_QWORD *)buf + v227), v226, v214);
            }
            v228 = v183[1] + v208;
            if (v228 >> 62)
            {
              v251 = __si_assert_copy_extra_1644(0);
              __message_assert("%s:%u: failed assertion '%s' %s write invalid offset %llu");
LABEL_314:
              free(v251);
              if (__valid_fs(-1))
                v250 = 2989;
              else
                v250 = 3072;
              *(_DWORD *)v250 = -559038737;
              abort();
            }
            v186 = __basea + 1;
            bit_vector_set_1700(a4 + 4456, v277 / *MEMORY[0x1E0C85AD8], 1u);
            *(_QWORD *)storageResolvePtr(a4 + 40, v277, 8uLL, 1) = v228;
            v204 = v303;
            v185 = v201;
            v158 = a4 + 40;
            v187 = (unsigned int *)v271;
            goto LABEL_284;
          }
        }
        if (v221 >= 2)
          goto LABEL_279;
LABEL_288:
        _PayloadWriteData((int *)buf, v183, v300, 1);
        v225 = *(_QWORD *)&buf[24];
        goto LABEL_280;
      }
      v104 = *__error();
      v105 = _SILogForLogForCategory(10);
      v106 = 2 * (dword_1EF19FCB4 < 4);
      v22 = v262;
      if (os_log_type_enabled(v105, v106))
      {
        *(_WORD *)buf = 0;
        goto LABEL_107;
      }
      goto LABEL_108;
    }
  }
LABEL_57:
  CIOnThreadCleanUpPop(v22);
  ++thingCount;
  if (!(_DWORD)v36)
  {
    *v273 = 1;
    v64 = CFAbsoluteTimeGetCurrent();
    v65 = *__error();
    v66 = _SILogForLogForCategory(10);
    v67 = 2 * (v19[813] < 4);
    if (os_log_type_enabled(v66, v67))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1B8270000, v66, v67, "Done", buf, 2u);
    }
    v68 = v64 - Current;
    *__error() = v65;
    v69 = *__error();
    v70 = _SILogForLogForCategory(10);
    v71 = 2 * (v19[813] < 4);
    if (os_log_type_enabled(v70, v71))
    {
      v72 = v68;
      *(_DWORD *)buf = 134217984;
      *(double *)&buf[4] = v72;
      _os_log_impl(&dword_1B8270000, v70, v71, "Merge took %f seconds", buf, 0xCu);
    }
    *__error() = v69;
    *(double *)&bt_mergeSet_accTime = *(double *)&bt_mergeSet_accTime + v68;
    v73 = *__error();
    v74 = _SILogForLogForCategory(10);
    v75 = 2 * (v19[813] < 4);
    if (os_log_type_enabled(v74, v75))
    {
      v76 = *(double *)&bt_mergeSet_accTime;
      *(_DWORD *)buf = 134217984;
      *(double *)&buf[4] = v76;
      _os_log_impl(&dword_1B8270000, v74, v75, "Total merge time: %f seconds", buf, 0xCu);
    }
    *__error() = v73;
    if (gSILogLevels[0] >= 5)
    {
      v238 = *__error();
      v239 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v239, OS_LOG_TYPE_DEFAULT))
      {
        v240 = *(_QWORD *)(v263 + 32);
        v241 = (double)v240 * 100.0 / (double)*(unint64_t *)(v263 + 40);
        *(_DWORD *)buf = 134218240;
        *(_QWORD *)&buf[4] = v240 >> 10;
        *(_WORD *)&buf[12] = 2048;
        *(double *)&buf[14] = v241;
        _os_log_impl(&dword_1B8270000, v239, OS_LOG_TYPE_DEFAULT, "Mapped Bases: %luKB (%f%% used)", buf, 0x16u);
      }
      *__error() = v238;
      if (gSILogLevels[0] >= 5)
      {
        v242 = *__error();
        v243 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v243, OS_LOG_TYPE_DEFAULT))
        {
          v245 = *(_DWORD *)(v263 + 144);
          v244 = *(unsigned int *)(v263 + 148);
          *(_DWORD *)buf = 134218496;
          *(_QWORD *)&buf[4] = ((unint64_t)(257 * v244) >> 8) & 0x3FFFFFFFFFFFFFLL;
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v245;
          *(_WORD *)&buf[18] = 2048;
          *(double *)&buf[20] = (double)v245 * 100.0 / (double)v244;
          _os_log_impl(&dword_1B8270000, v243, OS_LOG_TYPE_DEFAULT, "Sparse Bases: %luKB for %d entries (%f%% used)", buf, 0x1Cu);
        }
        *__error() = v242;
        if (gSILogLevels[0] >= 5)
        {
          v246 = *__error();
          v247 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v247, OS_LOG_TYPE_DEFAULT))
          {
            v248 = *(_QWORD *)(v263 + 384);
            v249 = (double)*(unint64_t *)(v263 + 392) * 100.0 / (double)v248;
            *(_DWORD *)buf = 134218240;
            *(_QWORD *)&buf[4] = v248 >> 10;
            *(_WORD *)&buf[12] = 2048;
            *(double *)&buf[14] = v249;
            _os_log_impl(&dword_1B8270000, v247, OS_LOG_TYPE_DEFAULT, "String arrays: %lluKB %f%% used", buf, 0x16u);
          }
          *__error() = v246;
        }
      }
    }
  }
  return v36;
}

int *_PayloadWriteData(int *result, _QWORD *a2, char *a3, int64_t a4)
{
  int *v5;
  char *v6;
  int64_t v7;
  int64_t v9;
  size_t v10;
  size_t v11;
  char *v12;
  char *v13;
  const char *v14;

  v5 = result;
  v6 = &a3[a4];
  if (a4)
  {
    v7 = a4;
    do
    {
      if (*((_QWORD *)v5 + 4))
        break;
      v9 = *((_QWORD *)v5 + 3);
      if (v7 >= v9)
        v10 = *((_QWORD *)v5 + 3);
      else
        v10 = v7;
      a2[1] -= v10;
      v11 = v9 - v10;
      *((_QWORD *)v5 + 3) = v11;
      v6 -= v10;
      result = (int *)memcpy((void *)(*(_QWORD *)v5 + v11), v6, v10);
      if (!*((_QWORD *)v5 + 3))
        result = PayloadWriteBufferWrite(v5, a2);
      v7 -= v10;
    }
    while (v7);
  }
  if (v6 != a3 && !*((_QWORD *)v5 + 4))
  {
    v12 = __si_assert_copy_extra_1644(0);
    v13 = v12;
    v14 = "";
    if (v12)
      v14 = v12;
    __message_assert("%s:%u: failed assertion '%s' %s ", "JHPayload.h", 146, "src == ptr || wb->err", v14);
    free(v13);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  return result;
}

uint64_t ___qsort_termids_block_invoke(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  unsigned int v3;

  if (*a3 == *a2)
    v3 = 0;
  else
    v3 = -1;
  if (*a3 > *a2)
    return 1;
  else
    return v3;
}

void findMatchRangeChars(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char v11;
  uint64_t v12;
  unint64_t v13;
  int8x8_t *v14;
  uint64_t v15;
  unsigned int v16;
  uint8x8_t v17;
  uint8x8_t v18;
  uint8x8_t v19;
  uint8x8_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  BOOL v25;
  uint64_t v26;

  if (HIDWORD(a2) == 1)
  {
    v10 = mgetBase(*(_QWORD *)(a1 + 8), a2);
    v11 = *(_BYTE *)(v10 + 36);
    if (!v11)
      return;
    v12 = v10;
    v13 = 0;
    v14 = (int8x8_t *)(v10 + 4);
    while (((*(_DWORD *)(v12 + 4 * (v13 >> 5) + 4) >> v13) & 1) == 0)
    {
LABEL_31:
      if (v11)
      {
        if (v13++ < 0xFF)
          continue;
      }
      return;
    }
    v15 = 0;
    v16 = v13 >> 6;
    if (v13 >> 6 != 1)
    {
      if (v16 != 2)
      {
        if (v16 != 3)
        {
LABEL_23:
          v20 = (uint8x8_t)vcnt_s8((int8x8_t)(*(_QWORD *)&v14[v16] & ~(-1 << v13)));
          v20.i16[0] = vaddlv_u8(v20);
          v21 = *(unsigned int *)(v12 + 4 * (v20.u32[0] + v15) + 38);
          v22 = v21 >> 1;
          v23 = v21 >> 3;
          v24 = (v21 & 7) << 32;
          if ((v21 & 3) == 1)
          {
            v24 = 0x100000000;
            v23 = v21 >> 2;
          }
          v25 = (v21 & 1) == 0;
          if ((v21 & 1) != 0)
            v26 = v24;
          else
            v26 = 0;
          if (!v25)
            v22 = v23;
          _findMatchRangeChars(a1, v26 | v22, tcmr[v13]);
          --v11;
          goto LABEL_31;
        }
        v17 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v12 + 20));
        v17.i16[0] = vaddlv_u8(v17);
        v15 = v17.u32[0];
      }
      v18 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v12 + 12));
      v18.i16[0] = vaddlv_u8(v18);
      v15 += v18.u32[0];
    }
    v19 = (uint8x8_t)vcnt_s8(*v14);
    v19.i16[0] = vaddlv_u8(v19);
    v15 += v19.u32[0];
    goto LABEL_23;
  }
  if (HIDWORD(a2) == 3)
  {
    v3 = 0;
    v4 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8) + 1028 * a2 + 4;
    do
    {
      v5 = *(unsigned int *)(v4 + 4 * v3);
      v6 = v5 >> 1;
      v7 = v5 >> 3;
      v8 = (v5 & 7) << 32;
      if ((v5 & 3) == 1)
      {
        v8 = 0x100000000;
        v7 = v5 >> 2;
      }
      if ((v5 & 1) != 0)
        v9 = v8;
      else
        v9 = 0;
      if ((*(_DWORD *)(v4 + 4 * v3) & 1) != 0)
        v6 = v7;
      if (v6)
        _findMatchRangeChars(a1, v9 | v6, tcmr[v3]);
      ++v3;
    }
    while (v3 != 256);
  }
}

void findMatchTermWildcard(uint64_t a1, unint64_t a2, unsigned int a3, int a4)
{
  unsigned int v6;
  unint64_t v8;
  uint64_t v9;
  _DWORD *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  unsigned __int8 **v16;
  int v17;
  uint64_t v18;
  unsigned __int8 *v19;
  int v20;
  uint64_t v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  _BYTE *v32;
  _BYTE *v33;
  char v34;
  int8x8_t *v35;
  unint64_t v36;
  int v37;
  int v38;
  int v39;
  unsigned int v40;
  uint64_t v41;
  uint64_t v42;
  unsigned __int8 *v43;
  char v44;
  int v45;
  int v46;
  char *v47;
  char *v48;
  const char *v49;
  int v50;
  int v51;
  int v52;
  unsigned int v53;
  char *v54;
  char *v55;
  const char *v56;
  _DWORD *v57;
  char *v58;
  char *v59;
  const char *v60;
  int v61;
  int v62;
  int v63;
  unsigned int v64;
  int v65;
  int v66;
  int v67;
  int v68;
  char *v69;
  char *v70;
  const char *v71;
  uint64_t v72;
  uint64_t v73;
  unsigned int v74;
  uint8x8_t v75;
  uint8x8_t v76;
  uint8x8_t v77;
  uint8x8_t v78;
  unint64_t v79;
  unint64_t v80;
  unint64_t v81;
  uint64_t v82;
  BOOL v83;
  uint64_t v84;

  v6 = a2;
  v8 = HIDWORD(a2);
  if (!a4)
    goto LABEL_31;
  if (HIDWORD(a2) != 1)
  {
    if (HIDWORD(a2) != 3)
    {
      if (*(_DWORD *)(a1 + 48) != 1)
        goto LABEL_31;
      LODWORD(v13) = 0;
      goto LABEL_15;
    }
    v9 = *(_QWORD *)(a1 + 8);
    if ((unint64_t)a2 < *(_QWORD *)(a1 + 64))
    {
      v10 = (_DWORD *)(*(_QWORD *)(v9 + 8) + 1028 * a2);
      goto LABEL_8;
    }
    v54 = __si_assert_copy_extra_1644(*(_DWORD **)(v9 + 4568));
    v55 = v54;
    v56 = "";
    if (v54)
      v56 = v54;
    __message_assert("%s:%u: failed assertion '%s' %s next: %d, max: %d", "BurstTrie.c", 4518, "ptr.next < ctx->trie_fat_max", v56, v6, *(_QWORD *)(a1 + 64));
    free(v55);
    v57 = *(_DWORD **)(*(_QWORD *)(a1 + 8) + 4568);
LABEL_106:
    if (__valid_fsp(v57))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v11 = *(_QWORD *)(a1 + 72);
  v12 = *(_QWORD *)(a1 + 8);
  if (a2 >= v11)
  {
    v58 = __si_assert_copy_extra_1644(*(_DWORD **)(v12 + 112));
    v59 = v58;
    v60 = "";
    if (v58)
      v60 = v58;
    __message_assert("%s:%u: failed assertion '%s' %s next: %d, max: %d", "BurstTrie.c", 4521, "ptr.next < ctx->trie_max", v60, v6, *(_QWORD *)(a1 + 64));
    free(v59);
    v57 = *(_DWORD **)(*(_QWORD *)(a1 + 8) + 112);
    goto LABEL_106;
  }
  v10 = (_DWORD *)mgetBase(v12, a2);
LABEL_8:
  v13 = *v10;
  if (*(_DWORD *)(a1 + 48) == 1)
  {
    if ((v13 & 1) != 0)
    {
      if ((*v10 & 3) == 1)
      {
        v14 = v13 >> 2;
        v15 = 0x100000000;
        if (!(v13 >> 2))
          goto LABEL_31;
      }
      else
      {
        v14 = v13 >> 3;
        v15 = (unint64_t)(v13 & 7) << 32;
        if (!(v13 >> 3))
          goto LABEL_31;
      }
LABEL_16:
      findAddFlatBucket(a1, v15 | v14, 0, 0, 0, 0);
      goto LABEL_31;
    }
LABEL_15:
    v15 = 0;
    v14 = v13 >> 1;
    if (!(v13 >> 1))
      goto LABEL_31;
    goto LABEL_16;
  }
  if ((_DWORD)v13)
  {
    v16 = *(unsigned __int8 ***)(a1 + 1240);
    v17 = *((_DWORD *)v16 + 4);
    if ((v17 & 0x610) == 0 && !**(_BYTE **)a1)
    {
      if ((v17 & 4) != 0)
      {
        v37 = *(unsigned __int8 *)(a1 + 88);
        if ((v37 - 2) > 2 || v37 != **v16)
          goto LABEL_31;
        v38 = termNumberCompare((_BYTE *)(a1 + 88), *v16);
        if ((v17 & 0x20) != 0)
        {
          if (v38 < 0)
            goto LABEL_31;
        }
        else if (v38 < 1)
        {
          goto LABEL_31;
        }
        v39 = termNumberCompare((_BYTE *)(a1 + 88), v16[1]);
        if ((v17 & 0x40) != 0)
        {
          if (v39 > 0)
            goto LABEL_31;
        }
        else if ((v39 & 0x80000000) == 0)
        {
          goto LABEL_31;
        }
      }
      else if ((v17 & 0x8000) != 0 || **v16 != 42 || (*v16)[1])
      {
        v18 = (uint64_t)v16[4];
        v19 = v16[5];
        if (v18)
        {
          if (v19)
            goto LABEL_26;
          if (!localizedFieldTermMatch(v18, *((_DWORD *)v16 + 5), (unsigned __int8 *)(a1 + 88), *(_DWORD *)(a1 + 1140), *((_DWORD *)v16 + 4)))goto LABEL_31;
LABEL_72:
          v40 = *(_DWORD *)(a1 + 1140);
          v41 = a1;
          v42 = v13;
          v43 = (unsigned __int8 *)(a1 + 88);
          v44 = 1;
LABEL_81:
          findHandleMatch(v41, v42, 0, v43, v40, v44);
          goto LABEL_31;
        }
        if (v19)
        {
LABEL_26:
          if (*(_BYTE *)(a1 + 88) != 1)
          {
            v20 = termPropertyID((unsigned __int8 *)(a1 + 88), *(_DWORD *)(a1 + 1140));
            v21 = 0;
            goto LABEL_118;
          }
          v20 = *(unsigned __int8 *)(a1 + 89);
          if (v20 == 2)
          {
            v20 = *(unsigned __int8 *)(a1 + 90);
            if ((*(char *)(a1 + 90) & 0x80000000) == 0)
            {
              v21 = 3;
              goto LABEL_118;
            }
            v45 = *(unsigned __int8 *)(a1 + 91);
            if ((*(char *)(a1 + 91) & 0x80000000) == 0)
            {
              v20 = v20 & 0x7F | (v45 << 7);
              v21 = 4;
              goto LABEL_118;
            }
            v50 = *(unsigned __int8 *)(a1 + 92);
            if ((*(char *)(a1 + 92) & 0x80000000) == 0)
            {
              v51 = ((v45 & 0x7F) << 7) | (v50 << 14);
LABEL_116:
              v53 = v51 & 0xFFFFFF80 | v20 & 0x7F;
              v21 = 5;
              goto LABEL_117;
            }
            v61 = *(unsigned __int8 *)(a1 + 93);
            if ((*(char *)(a1 + 93) & 0x80000000) == 0)
            {
              v53 = ((v50 & 0x7F) << 14) | (v61 << 21) | ((v45 & 0x7F) << 7) | v20 & 0x7F;
              v21 = 6;
              goto LABEL_117;
            }
            v65 = *(char *)(a1 + 94);
            if ((v65 & 0x80000000) == 0)
            {
              v66 = ((v61 & 0x7F) << 21) | (v65 << 28) | ((v50 & 0x7F) << 14) | ((v45 & 0x7F) << 7) | v20 & 0x7F;
              v21 = 7;
              v20 = v66;
              goto LABEL_118;
            }
          }
          else
          {
            if ((v20 & 0x80) == 0)
            {
              v21 = 2;
              goto LABEL_118;
            }
            v46 = *(unsigned __int8 *)(a1 + 90);
            if ((*(char *)(a1 + 90) & 0x80000000) == 0)
            {
              v20 = v20 & 0x7F | (v46 << 7);
              v21 = 3;
              goto LABEL_118;
            }
            v52 = *(unsigned __int8 *)(a1 + 91);
            if ((*(char *)(a1 + 91) & 0x80000000) == 0)
            {
              v53 = ((v46 & 0x7F) << 7) | (v52 << 14) | v20 & 0x7F;
              v21 = 4;
LABEL_117:
              v20 = v53;
              goto LABEL_118;
            }
            v62 = *(unsigned __int8 *)(a1 + 92);
            if ((*(char *)(a1 + 92) & 0x80000000) == 0)
            {
              v51 = ((v52 & 0x7F) << 14) | (v62 << 21) | ((v46 & 0x7F) << 7);
              goto LABEL_116;
            }
            v67 = *(char *)(a1 + 93);
            if ((v67 & 0x80000000) == 0)
            {
              v68 = ((v62 & 0x7F) << 21) | (v67 << 28) | ((v52 & 0x7F) << 14) | ((v46 & 0x7F) << 7) | v20 & 0x7F;
              v21 = 6;
              v20 = v68;
LABEL_118:
              if (*((_DWORD *)v16 + 5) == v20)
              {
                v63 = *(_DWORD *)(a1 + 1140) - v21;
                while (v63 >= 1)
                {
                  v64 = *(unsigned __int8 *)(a1 + v21 - 1 + v63 + 88);
                  if (v64 > 5)
                  {
                    if (!__findTermIDsContextMatchPatternsRegExMatch())
                      goto LABEL_31;
                    goto LABEL_72;
                  }
                  --v63;
                  if ((v64 & 0xFFFFFFFD) != 1)
                    goto LABEL_31;
                }
              }
              goto LABEL_31;
            }
          }
          v69 = __si_assert_copy_extra_1644(0);
          v70 = v69;
          v71 = "";
          if (v69)
            v71 = v69;
          __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t", "VIntUtils.h", 341, "(b4 & 0x80) == 0", v71);
          free(v70);
          if (__valid_fs(-1))
            v72 = 2989;
          else
            v72 = 3072;
          *(_DWORD *)v72 = -559038737;
          abort();
        }
        if (*((_DWORD *)v16 + 5) == 1
          && termPropertyID((unsigned __int8 *)(a1 + 88), *(_DWORD *)(a1 + 1140)) != 1
          || !termMatch((unsigned __int8 *)(a1 + 88), *(_DWORD *)(a1 + 1140), *v16, *((_DWORD *)v16 + 6)))
        {
          goto LABEL_31;
        }
      }
      else if (!termFieldMatch(*((_DWORD *)v16 + 5), (unsigned __int8 *)(a1 + 88), *(_DWORD *)(a1 + 1140), *((_DWORD *)v16 + 4)))
      {
        goto LABEL_31;
      }
      if ((v17 & 0x8000) != 0)
        goto LABEL_31;
      v43 = (unsigned __int8 *)(a1 + 88);
      v40 = *(_DWORD *)(a1 + 1140);
      v41 = a1;
      v42 = v13;
      v44 = 0;
      goto LABEL_81;
    }
  }
LABEL_31:
  if ((_DWORD)v8 != 1)
  {
    if ((_DWORD)v8 == 3)
    {
      v22 = v6;
      v23 = v6 | 0x300000000;
      v24 = a3;
      v25 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8) + 1028 * v22 + 4;
      do
      {
        v26 = *(unsigned int *)(v25 + 4 * v24);
        v27 = v26 >> 1;
        v28 = v26 >> 3;
        v29 = (v26 & 7) << 32;
        if ((v26 & 3) == 1)
        {
          v29 = 0x100000000;
          v28 = v26 >> 2;
        }
        if ((v26 & 1) != 0)
          v30 = v29;
        else
          v30 = 0;
        if ((*(_DWORD *)(v25 + 4 * v24) & 1) != 0)
          v27 = v28;
        if (v27)
          _findMatchTermWildcard(a1, v23, v30 | v27, tcmr[v24], a4);
        ++v24;
      }
      while (v24 != 256);
    }
    return;
  }
  v31 = v6;
  v32 = (_BYTE *)mgetBase(*(_QWORD *)(a1 + 8), v6);
  if (a3)
  {
    v47 = __si_assert_copy_extra_1644(0);
    v48 = v47;
    v49 = "";
    if (v47)
      v49 = v47;
    __message_assert("%s:%u: failed assertion '%s' %s ", "BurstTrie.c", 4561, "ch_start==0", v49);
    free(v48);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v33 = v32;
  v34 = v32[36];
  v35 = (int8x8_t *)(v32 + 4);
  if (v32[4])
  {
    v36 = 0;
  }
  else if (v32[5])
  {
    v36 = 8u;
  }
  else if (v32[6])
  {
    v36 = 0x10u;
  }
  else if (v32[7])
  {
    v36 = 0x18u;
  }
  else if (v32[8])
  {
    v36 = 0x20u;
  }
  else if (v32[9])
  {
    v36 = 0x28u;
  }
  else if (v32[10])
  {
    v36 = 0x30u;
  }
  else if (v32[11])
  {
    v36 = 0x38u;
  }
  else if (v32[12])
  {
    v36 = 0x40u;
  }
  else if (v32[13])
  {
    v36 = 0x48u;
  }
  else if (v32[14])
  {
    v36 = 0x50u;
  }
  else if (v32[15])
  {
    v36 = 0x58u;
  }
  else if (v32[16])
  {
    v36 = 0x60u;
  }
  else if (v32[17])
  {
    v36 = 0x68u;
  }
  else if (v32[18])
  {
    v36 = 0x70u;
  }
  else if (v32[19])
  {
    v36 = 0x78u;
  }
  else if (v32[20])
  {
    v36 = 0x80u;
  }
  else if (v32[21])
  {
    v36 = 0x88u;
  }
  else if (v32[22])
  {
    v36 = 0x90u;
  }
  else if (v32[23])
  {
    v36 = 0x98u;
  }
  else if (v32[24])
  {
    v36 = 0xA0u;
  }
  else if (v32[25])
  {
    v36 = 0xA8u;
  }
  else if (v32[26])
  {
    v36 = 0xB0u;
  }
  else if (v32[27])
  {
    v36 = 0xB8u;
  }
  else if (v32[28])
  {
    v36 = 0xC0u;
  }
  else if (v32[29])
  {
    v36 = 0xC8u;
  }
  else if (v32[30])
  {
    v36 = 0xD0u;
  }
  else if (v32[31])
  {
    v36 = 0xD8u;
  }
  else if (v32[32])
  {
    v36 = 0xE0u;
  }
  else if (v32[33])
  {
    v36 = 0xE8u;
  }
  else if (v32[34])
  {
    v36 = 0xF0u;
  }
  else
  {
    if (!v32[35])
      return;
    v36 = 0xF8u;
  }
  if (v32[36])
  {
    while (((*(_DWORD *)&v33[4 * (v36 >> 5) + 4] >> v36) & 1) == 0)
    {
LABEL_196:
      if (v34)
      {
        if (v36++ < 0xFF)
          continue;
      }
      return;
    }
    v73 = 0;
    v74 = v36 >> 6;
    if (v36 >> 6 != 1)
    {
      if (v74 != 2)
      {
        if (v74 != 3)
        {
LABEL_188:
          v78 = (uint8x8_t)vcnt_s8((int8x8_t)(*(_QWORD *)&v35[v74] & ~(-1 << v36)));
          v78.i16[0] = vaddlv_u8(v78);
          v79 = *(unsigned int *)&v33[4 * v78.u32[0] + 38 + 4 * v73];
          v80 = v79 >> 1;
          v81 = v79 >> 3;
          v82 = (v79 & 7) << 32;
          if ((v79 & 3) == 1)
          {
            v82 = 0x100000000;
            v81 = v79 >> 2;
          }
          v83 = (v79 & 1) == 0;
          if ((v79 & 1) != 0)
            v84 = v82;
          else
            v84 = 0;
          if (!v83)
            v80 = v81;
          _findMatchTermWildcard(a1, v31 | 0x100000000, v84 | v80, tcmr[v36], a4);
          --v34;
          goto LABEL_196;
        }
        v75 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v33 + 20));
        v75.i16[0] = vaddlv_u8(v75);
        v73 = v75.u32[0];
      }
      v76 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v33 + 12));
      v76.i16[0] = vaddlv_u8(v76);
      v73 += v76.u32[0];
    }
    v77 = (uint8x8_t)vcnt_s8(*v35);
    v77.i16[0] = vaddlv_u8(v77);
    v73 += v77.u32[0];
    goto LABEL_188;
  }
}

void trie_level_list_insert_with_state(int *a1, uint64_t a2, void *a3, unsigned int a4, uint64_t a5, uint64_t a6)
{
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  _DWORD *v24;
  uint64_t v25;
  _QWORD value[5];

  value[0] = a2;
  value[1] = a3;
  value[3] = a5;
  value[2] = a4;
  value[4] = a6;
  if (CFSetContainsValue(*((CFSetRef *)a1 + 2), value))
  {
    free(a3);
    return;
  }
  LODWORD(v12) = a1[1];
  if ((int)v12 >= *a1)
  {
    CFSetRemoveAllValues(*((CFMutableSetRef *)a1 + 2));
    v13 = 2 * *a1;
    *a1 = v13;
    *((_QWORD *)a1 + 1) = malloc_type_realloc(*((void **)a1 + 1), 40 * v13, 0x1010040796FF4C2uLL);
    LODWORD(v12) = a1[1];
    if ((int)v12 >= 1)
    {
      v14 = 0;
      v15 = 0;
      do
      {
        CFSetAddValue(*((CFMutableSetRef *)a1 + 2), (const void *)(*((_QWORD *)a1 + 1) + v14));
        ++v15;
        v12 = a1[1];
        v14 += 40;
      }
      while (v15 < v12);
    }
    v16 = *a1;
    if ((int)v12 < (int)v16)
    {
      v17 = *((_QWORD *)a1 + 1);
      v18 = (int)v12;
      v19 = v16 - (int)v12;
      if (v19 > 1)
      {
        v20 = v19 & 0xFFFFFFFFFFFFFFFELL;
        v21 = v17 + 40 * (int)v12 + 48;
        v22 = v19 & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          *(_QWORD *)(v21 - 40) = 0;
          *(_QWORD *)v21 = 0;
          *(_DWORD *)(v21 - 32) = 0;
          *(_DWORD *)(v21 + 8) = 0;
          v21 += 80;
          v22 -= 2;
        }
        while (v22);
        if (v19 == v20)
          goto LABEL_15;
        v18 = v20 + (int)v12;
      }
      v23 = v16 - v18;
      v24 = (_DWORD *)(v17 + 40 * v18 + 16);
      do
      {
        *((_QWORD *)v24 - 1) = 0;
        *v24 = 0;
        v24 += 10;
        --v23;
      }
      while (v23);
    }
  }
LABEL_15:
  *(_QWORD *)(*((_QWORD *)a1 + 1) + 40 * (int)v12) = a2;
  free(*(void **)(*((_QWORD *)a1 + 1) + 40 * a1[1] + 8));
  v25 = *((_QWORD *)a1 + 1) + 40 * a1[1];
  *(_QWORD *)(v25 + 8) = a3;
  *(_DWORD *)(v25 + 16) = a4;
  *(_QWORD *)(v25 + 24) = a5;
  *(_QWORD *)(v25 + 32) = a6;
  CFSetAddValue(*((CFMutableSetRef *)a1 + 2), (const void *)(*((_QWORD *)a1 + 1) + 40 * a1[1]++));
}

void __trie_resolve_fuzzy_transition_block_invoke(uint64_t a1, unint64_t a2, _BYTE *a3, int a4)
{
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 1272) = a1 + 64;
  findAddFlatBucket(*(_QWORD *)(a1 + 32), a2, *(_BYTE **)(a1 + 48), *(int *)(a1 + 56), a3, a4);
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 1272) = 0;
}

void __trie_resolve_fuzzy_transition_block_invoke_2(uint64_t a1, unint64_t a2, uint64_t a3, const void *a4, int a5)
{
  size_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  __int128 v14;

  v10 = (*(_DWORD *)(a1 + 48) + a5);
  v11 = (char *)malloc_type_zone_malloc((malloc_zone_t *)queryZone, (v10 + 1), 0x6085D6BuLL);
  if (!v11 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    LOWORD(v14) = 0;
    _os_log_fault_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "allocation function returned null", (uint8_t *)&v14, 2u);
  }
  memcpy(v11, *(const void **)(a1 + 40), *(int *)(a1 + 48));
  memcpy(&v11[*(int *)(a1 + 48)], a4, a5);
  v11[v10] = 0;
  if (a3)
  {
    v12 = la_new_state_from_state_with_char_at_index(*(_QWORD *)(*(_QWORD *)(a1 + 88) + 1264), *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64), (*(_BYTE *)(a3 + 16) + *(_QWORD *)(a1 + 64)));
    *(_QWORD *)&v14 = v12;
    *((_QWORD *)&v14 + 1) = v13;
    if (!v12)
      goto LABEL_10;
  }
  else
  {
    v14 = *(_OWORD *)(a1 + 72);
    v12 = v14;
    if (!(_QWORD)v14)
    {
LABEL_10:
      free(v11);
      return;
    }
  }
  if (!HIDWORD(a2))
  {
    *(_QWORD *)(*(_QWORD *)(a1 + 88) + 1272) = &v14;
    findAddFlatBucket(*(_QWORD *)(a1 + 88), a2, v11, v10, 0, 0);
    *(_QWORD *)(*(_QWORD *)(a1 + 88) + 1272) = 0;
    goto LABEL_10;
  }
  trie_level_list_insert_with_state(*(int **)(a1 + 96), a2, v11, v10, v12, *((uint64_t *)&v14 + 1));
}

unint64_t _trie_resolve_sub_trie(unint64_t result, unint64_t a2, char **a3, uint64_t a4, uint64_t a5, char a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;

  v8 = a2;
  if (!(_DWORD)a2)
    return result;
  if (!a3 || !*((_BYTE *)a3 + 18))
    return (*(uint64_t (**)(uint64_t, unint64_t, char **, uint64_t, uint64_t))(a8 + 16))(a8, a2, a3, a4, a5);
  v16 = result;
  if (*((unsigned __int8 *)a3 + 16) != 255)
    result = (*(uint64_t (**)(uint64_t, unint64_t, char **, uint64_t, uint64_t))(a8 + 16))(a8, a2, a3, a4, a5);
  if (!HIDWORD(a2))
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a7 + 16))(a7, v8, a4, a5);
  if ((a6 & 1) != 0)
  {
    if (!*((_BYTE *)a3 + 18) || (**a3 & 0x80000000) == 0)
    {
      v17 = 0;
      v18 = 0;
      v19 = (int)a5;
      v20 = (a5 + 1);
      do
      {
        result = trieGetRawChild(v16, a2, v17);
        *(_BYTE *)(a4 + v19) = tcmr[v17];
        if (v18 < *((unsigned __int8 *)a3 + 18) && v17 == (*a3)[v18])
        {
          if ((_DWORD)result)
            result = _trie_resolve_sub_trie(v16);
          ++v18;
        }
        else if ((_DWORD)result)
        {
          result = (*(uint64_t (**)(uint64_t, unint64_t, _QWORD, uint64_t, uint64_t))(a8 + 16))(a8, result, 0, a4, v20);
        }
        ++v17;
      }
      while (v17 != 128);
      return result;
    }
  }
  else if (!*((_BYTE *)a3 + 18))
  {
    return result;
  }
  v21 = 0;
  do
  {
    v22 = (*a3)[v21];
    result = trieGetRawChild(v16, a2, (*a3)[v21]);
    if ((_DWORD)result)
    {
      *(_BYTE *)(a4 + (int)a5) = tcmr[v22];
      result = _trie_resolve_sub_trie(v16);
    }
    ++v21;
  }
  while (v21 < *((unsigned __int8 *)a3 + 18));
  return result;
}

void _trie_resolve_combining(uint64_t a1, __int128 *a2, int *a3)
{
  unsigned int v6;
  __int128 v7;
  BOOL v8;
  __int128 v9;
  unsigned int v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  unsigned int v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;
  uint64_t v24;
  __int128 v25;
  uint64_t v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  uint64_t v32;
  __int128 v33;
  uint64_t v34;
  uint64_t v35;
  __int128 v36;
  __int128 v37;
  uint64_t v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  uint64_t v42;
  int v43;
  uint64_t v44;

  v44 = 0;
  v43 = 204;
  if (_trie_resolve_string(*(_QWORD *)(a1 + 8), *(_QWORD *)a2, (uint64_t)&v43, 1, &v44))
  {
    if (HIDWORD(v44))
    {
      v6 = 128;
      do
      {
        BYTE1(v43) = v6;
        v7 = a2[1];
        v40 = *a2;
        v41 = v7;
        v42 = *((_QWORD *)a2 + 4);
        trie_resolve_sub_string(a1, (uint64_t)&v40, &v43, 2, a3);
        v8 = v6++ >= 0xBF;
      }
      while (!v8);
    }
    else
    {
      v9 = a2[1];
      v40 = *a2;
      v41 = v9;
      v42 = *((_QWORD *)a2 + 4);
      trie_resolve_sub_string(a1, (uint64_t)&v40, &v43, 1, a3);
    }
  }
  LOBYTE(v43) = -51;
  if (_trie_resolve_string(*(_QWORD *)(a1 + 8), *(_QWORD *)a2, (uint64_t)&v43, 1, &v44))
  {
    if (HIDWORD(v44))
    {
      v10 = 128;
      do
      {
        BYTE1(v43) = v10;
        v11 = a2[1];
        v40 = *a2;
        v41 = v11;
        v42 = *((_QWORD *)a2 + 4);
        trie_resolve_sub_string(a1, (uint64_t)&v40, &v43, 2, a3);
        v8 = v10++ >= 0xDF;
      }
      while (!v8);
    }
    else
    {
      v12 = a2[1];
      v40 = *a2;
      v41 = v12;
      v42 = *((_QWORD *)a2 + 4);
      trie_resolve_sub_string(a1, (uint64_t)&v40, &v43, 1, a3);
    }
  }
  LOBYTE(v43) = 45;
  v13 = a2[1];
  v40 = *a2;
  v41 = v13;
  v42 = *((_QWORD *)a2 + 4);
  trie_resolve_sub_string(a1, (uint64_t)&v40, &v43, 1, a3);
  LOWORD(v43) = -32542;
  BYTE2(v43) = -112;
  v14 = a2[1];
  v40 = *a2;
  v41 = v14;
  v42 = *((_QWORD *)a2 + 4);
  trie_resolve_sub_string(a1, (uint64_t)&v40, &v43, 3, a3);
  LOBYTE(v43) = -42;
  if (_trie_resolve_string(*(_QWORD *)(a1 + 8), *(_QWORD *)a2, (uint64_t)&v43, 1, &v44))
  {
    if (HIDWORD(v44))
    {
      v15 = 145;
      do
      {
        BYTE1(v43) = v15;
        v16 = a2[1];
        v40 = *a2;
        v41 = v16;
        v42 = *((_QWORD *)a2 + 4);
        trie_resolve_sub_string(a1, (uint64_t)&v40, &v43, 2, a3);
        v8 = v15++ >= 0xBF;
      }
      while (!v8);
    }
    else
    {
      v17 = a2[1];
      v40 = *a2;
      v41 = v17;
      v42 = *((_QWORD *)a2 + 4);
      trie_resolve_sub_string(a1, (uint64_t)&v40, &v43, 1, a3);
    }
  }
  LOBYTE(v43) = -41;
  if (_trie_resolve_string(*(_QWORD *)(a1 + 8), *(_QWORD *)a2, (uint64_t)&v43, 1, &v44))
  {
    if (HIDWORD(v44))
    {
      BYTE1(v43) = 0x80;
      v18 = a2[1];
      v40 = *a2;
      v41 = v18;
      v42 = *((_QWORD *)a2 + 4);
      trie_resolve_sub_string(a1, (uint64_t)&v40, &v43, 2, a3);
      BYTE1(v43) = -127;
      v19 = a2[1];
      v40 = *a2;
      v41 = v19;
      v42 = *((_QWORD *)a2 + 4);
      trie_resolve_sub_string(a1, (uint64_t)&v40, &v43, 2, a3);
      BYTE1(v43) = -126;
      v20 = a2[1];
      v40 = *a2;
      v41 = v20;
      v42 = *((_QWORD *)a2 + 4);
      trie_resolve_sub_string(a1, (uint64_t)&v40, &v43, 2, a3);
      BYTE1(v43) = -125;
      v21 = a2[1];
      v40 = *a2;
      v41 = v21;
      v42 = *((_QWORD *)a2 + 4);
      trie_resolve_sub_string(a1, (uint64_t)&v40, &v43, 2, a3);
      BYTE1(v43) = -124;
      v22 = a2[1];
      v40 = *a2;
      v41 = v22;
      v42 = *((_QWORD *)a2 + 4);
      v23 = a1;
      v24 = 2;
    }
    else
    {
      v25 = a2[1];
      v40 = *a2;
      v41 = v25;
      v42 = *((_QWORD *)a2 + 4);
      v23 = a1;
      v24 = 1;
    }
    trie_resolve_sub_string(v23, (uint64_t)&v40, &v43, v24, a3);
  }
  LOWORD(v43) = -32029;
  v26 = _trie_resolve_string(*(_QWORD *)(a1 + 8), *(_QWORD *)a2, (uint64_t)&v43, 2, &v44);
  if ((_DWORD)v26)
  {
    v27 = v26;
    if (HIDWORD(v44))
    {
      if ((_DWORD)v26 != 2)
        goto LABEL_33;
      BYTE2(v43) = -103;
      v28 = a2[1];
      v40 = *a2;
      v41 = v28;
      v42 = *((_QWORD *)a2 + 4);
      trie_resolve_sub_string(a1, (uint64_t)&v40, &v43, 3, a3);
      BYTE2(v43) = -102;
      v29 = a2[1];
      v40 = *a2;
      v41 = v29;
      v42 = *((_QWORD *)a2 + 4);
      trie_resolve_sub_string(a1, (uint64_t)&v40, &v43, 3, a3);
      BYTE2(v43) = -101;
      v30 = a2[1];
      v40 = *a2;
      v41 = v30;
      v42 = *((_QWORD *)a2 + 4);
      trie_resolve_sub_string(a1, (uint64_t)&v40, &v43, 3, a3);
      BYTE2(v43) = -100;
      v31 = a2[1];
      v40 = *a2;
      v41 = v31;
      v42 = *((_QWORD *)a2 + 4);
      v32 = a1;
      v27 = 3;
    }
    else
    {
      v33 = a2[1];
      v40 = *a2;
      v41 = v33;
      v42 = *((_QWORD *)a2 + 4);
      v32 = a1;
    }
    trie_resolve_sub_string(v32, (uint64_t)&v40, &v43, v27, a3);
  }
LABEL_33:
  LOWORD(v43) = -16657;
  v34 = _trie_resolve_string(*(_QWORD *)(a1 + 8), *(_QWORD *)a2, (uint64_t)&v43, 2, &v44);
  if (!(_DWORD)v34)
    return;
  v35 = v34;
  if (HIDWORD(v44))
  {
    if ((_DWORD)v34 != 2)
      return;
    BYTE2(v43) = -98;
    v36 = a2[1];
    v40 = *a2;
    v41 = v36;
    v42 = *((_QWORD *)a2 + 4);
    trie_resolve_sub_string(a1, (uint64_t)&v40, &v43, 3, a3);
    BYTE2(v43) = -97;
    v37 = a2[1];
    v40 = *a2;
    v41 = v37;
    v42 = *((_QWORD *)a2 + 4);
    v38 = a1;
    v35 = 3;
  }
  else
  {
    v39 = a2[1];
    v40 = *a2;
    v41 = v39;
    v42 = *((_QWORD *)a2 + 4);
    v38 = a1;
  }
  trie_resolve_sub_string(v38, (uint64_t)&v40, &v43, v35, a3);
}

void trie_resolve_sub_string(uint64_t a1, uint64_t a2, _BYTE *a3, uint64_t a4, int *a5)
{
  int v6;
  int v10;
  uint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  const char *v15;
  uint64_t v16;
  uint8_t buf[16];

  v6 = a4;
  v16 = 0;
  v10 = _trie_resolve_string(*(_QWORD *)(a1 + 8), *(_QWORD *)a2, (uint64_t)a3, a4, &v16);
  if (v10)
  {
    if (HIDWORD(v16))
    {
      if (v10 != v6)
      {
        v13 = __si_assert_copy_extra_1644(0);
        v14 = v13;
        v15 = "";
        if (v13)
          v15 = v13;
        __message_assert("%s:%u: failed assertion '%s' %s ", "BurstTrie.c", 5433, "str_len==resolve_len", v15);
        free(v14);
        if (__valid_fs(-1))
        {
          MEMORY[0xBAD] = -559038737;
          abort();
        }
        MEMORY[0xC00] = -559038737;
        abort();
      }
      v11 = *(int *)(a2 + 16) + (uint64_t)v6;
      if ((int)v11 <= 4094)
      {
        v12 = (char *)malloc_type_zone_malloc((malloc_zone_t *)queryZone, v11 + 1, 0x6085D6BuLL);
        if (!v12 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_fault_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "allocation function returned null", buf, 2u);
        }
        memcpy(v12, *(const void **)(a2 + 8), *(int *)(a2 + 16));
        memcpy(&v12[*(int *)(a2 + 16)], a3, v6);
        v12[*(int *)(a2 + 16) + (uint64_t)v6] = 0;
        trie_level_list_insert_with_state(a5, v16, v12, *(_DWORD *)(a2 + 16) + v6, *(_QWORD *)(a2 + 24), *(_QWORD *)(a2 + 32));
      }
    }
    else
    {
      findAddFlatBucket(a1, v16, *(_BYTE **)(a2 + 8), *(int *)(a2 + 16), a3, v10);
    }
  }
}

void _trie_resolve_sub_string_ignore_diacritics(uint64_t a1, __int128 *a2, unsigned __int8 *a3, int a4, int *a5, _BYTE *a6, int a7)
{
  uint64_t v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  _BYTE *v20;
  size_t v21;
  size_t v22;
  unint64_t v23;
  uint64_t v24;
  _BYTE *v25;
  unint64_t v26;
  __int128 v27;
  unsigned int v28;
  __int128 v29;
  BOOL v30;
  unsigned int v31;
  __int128 v32;
  int v33;
  __int128 v34;
  size_t v35;
  size_t v36;
  __int128 v37;
  unsigned int v38;
  __int128 v39;
  uint64_t v40;
  unint64_t v41;
  __int128 v42;
  unint64_t v43;
  __int128 v44;
  unint64_t v45;
  __int128 v46;
  unint64_t v47;
  __int128 v48;
  __int128 v49;
  unint64_t v50;
  _BYTE *v51;
  unint64_t v52;
  __int128 v53;
  __int128 v54;
  uint64_t v55;
  unint64_t v56;

  if (!a4)
    return;
  v14 = utf8_byte_length_noerror(unsigned char)::utf8_len_table[(unint64_t)*a3 >> 4];
  v56 = 0;
  v15 = _trie_resolve_string(*(_QWORD *)(a1 + 8), *(_QWORD *)a2, (uint64_t)a3, v14, &v56);
  if (!v15)
    return;
  v16 = v15;
  memcpy(&a6[a7], a3, v15);
  v17 = v16 + (uint64_t)a7;
  if (!HIDWORD(v56))
  {
    v20 = (_BYTE *)*((_QWORD *)a2 + 1);
    v21 = *((int *)a2 + 4);
    v22 = (int)v17;
    v23 = v56;
    v24 = a1;
    v25 = a6;
    goto LABEL_11;
  }
  if (v16 != (_DWORD)v14)
    return;
  if (a4 == (_DWORD)v14)
  {
    v18 = *((int *)a2 + 4) + (uint64_t)(int)v17;
    if ((int)v18 <= 4094)
    {
      v19 = (char *)malloc_type_zone_malloc((malloc_zone_t *)queryZone, v18 + 1, 0x6085D6BuLL);
      if (!v19)
        _log_fault_for_malloc_failure();
      memcpy(v19, *((const void **)a2 + 1), *((int *)a2 + 4));
      memcpy(&v19[*((int *)a2 + 4)], a6, (int)v17);
      v19[*((int *)a2 + 4) + (uint64_t)(int)v17] = 0;
      trie_level_list_insert_with_state(a5, v56, v19, *((_DWORD *)a2 + 4) + v17, 0, 0);
    }
    return;
  }
  v26 = v56;
  *(_QWORD *)a2 = v56;
  v27 = a2[1];
  v53 = *a2;
  v54 = v27;
  v55 = *((_QWORD *)a2 + 4);
  _trie_resolve_sub_string_ignore_diacritics(a1, &v53);
  v52 = 0;
  a6[v17] = -52;
  v50 = v26;
  v51 = &a6[v17];
  if (_trie_resolve_string(*(_QWORD *)(a1 + 8), v26, (uint64_t)&a6[v17], 1, &v52))
  {
    if (HIDWORD(v52))
    {
      v28 = 128;
      do
      {
        a6[(int)v17 + 1] = v28;
        if (_trie_resolve_string(*(_QWORD *)(a1 + 8), v52, (uint64_t)(v51 + 1), 1, &v52))
        {
          if (HIDWORD(v52))
          {
            *(_QWORD *)a2 = v52;
            v29 = a2[1];
            v53 = *a2;
            v54 = v29;
            v55 = *((_QWORD *)a2 + 4);
            _trie_resolve_sub_string_ignore_diacritics(a1, &v53);
          }
          else
          {
            findAddFlatBucket(a1, v52, *((_BYTE **)a2 + 1), *((int *)a2 + 4), a6, (int)v17 + 2);
          }
        }
        v30 = v28++ >= 0xBF;
      }
      while (!v30);
    }
    else
    {
      findAddFlatBucket(a1, v52, *((_BYTE **)a2 + 1), *((int *)a2 + 4), a6, (int)v17 + 1);
    }
  }
  *v51 = -51;
  if (_trie_resolve_string(*(_QWORD *)(a1 + 8), v50, (uint64_t)v51, 1, &v52))
  {
    if (HIDWORD(v52))
    {
      v31 = 128;
      do
      {
        a6[(int)v17 + 1] = v31;
        if (_trie_resolve_string(*(_QWORD *)(a1 + 8), v52, (uint64_t)(v51 + 1), 1, &v52))
        {
          if (HIDWORD(v52))
          {
            *(_QWORD *)a2 = v52;
            v32 = a2[1];
            v53 = *a2;
            v54 = v32;
            v55 = *((_QWORD *)a2 + 4);
            _trie_resolve_sub_string_ignore_diacritics(a1, &v53);
          }
          else
          {
            findAddFlatBucket(a1, v52, *((_BYTE **)a2 + 1), *((int *)a2 + 4), a6, (int)v17 + 2);
          }
        }
        v30 = v31++ >= 0xDF;
      }
      while (!v30);
    }
    else
    {
      findAddFlatBucket(a1, v52, *((_BYTE **)a2 + 1), *((int *)a2 + 4), a6, (int)v17 + 1);
    }
  }
  *v51 = 45;
  if (_trie_resolve_string(*(_QWORD *)(a1 + 8), v50, (uint64_t)v51, 1, &v52))
  {
    if (HIDWORD(v52))
    {
      *(_QWORD *)a2 = v52;
      v33 = v17 + 1;
      v34 = a2[1];
      v53 = *a2;
      v54 = v34;
      v55 = *((_QWORD *)a2 + 4);
      _trie_resolve_sub_string_ignore_diacritics(a1, &v53);
    }
    else
    {
      v33 = v17 + 1;
      findAddFlatBucket(a1, v52, *((_BYTE **)a2 + 1), *((int *)a2 + 4), a6, (int)v17 + 1);
    }
  }
  else
  {
    v33 = v17 + 1;
  }
  *v51 = -30;
  v35 = v33;
  a6[v33] = 0x80;
  v36 = (int)v17 + 2;
  a6[v36] = -112;
  if (_trie_resolve_string(*(_QWORD *)(a1 + 8), v50, (uint64_t)v51, 3, &v52))
  {
    if (HIDWORD(v52))
    {
      *(_QWORD *)a2 = v52;
      v37 = a2[1];
      v53 = *a2;
      v54 = v37;
      v55 = *((_QWORD *)a2 + 4);
      _trie_resolve_sub_string_ignore_diacritics(a1, &v53);
    }
    else
    {
      findAddFlatBucket(a1, v52, *((_BYTE **)a2 + 1), *((int *)a2 + 4), a6, v35);
    }
  }
  *v51 = -42;
  if (_trie_resolve_string(*(_QWORD *)(a1 + 8), v50, (uint64_t)v51, 1, &v52))
  {
    if (HIDWORD(v52))
    {
      v38 = 145;
      do
      {
        a6[v35] = v38;
        if (_trie_resolve_string(*(_QWORD *)(a1 + 8), v52, (uint64_t)(v51 + 1), 1, &v52))
        {
          if (HIDWORD(v52))
          {
            *(_QWORD *)a2 = v52;
            v39 = a2[1];
            v53 = *a2;
            v54 = v39;
            v55 = *((_QWORD *)a2 + 4);
            _trie_resolve_sub_string_ignore_diacritics(a1, &v53);
          }
          else
          {
            findAddFlatBucket(a1, v52, *((_BYTE **)a2 + 1), *((int *)a2 + 4), a6, v36);
          }
        }
        v30 = v38++ >= 0xBF;
      }
      while (!v30);
    }
    else
    {
      findAddFlatBucket(a1, v52, *((_BYTE **)a2 + 1), *((int *)a2 + 4), a6, v35);
    }
  }
  *v51 = -41;
  if (_trie_resolve_string(*(_QWORD *)(a1 + 8), v50, (uint64_t)v51, 1, &v52))
  {
    if (HIDWORD(v52))
    {
      v40 = (uint64_t)(v51 + 1);
      a6[v35] = 0x80;
      if (_trie_resolve_string(*(_QWORD *)(a1 + 8), v52, (uint64_t)(v51 + 1), 1, &v52))
      {
        if (HIDWORD(v52))
        {
          v41 = v52;
          *(_QWORD *)a2 = v52;
          v42 = a2[1];
          v53 = *a2;
          v54 = v42;
          v55 = *((_QWORD *)a2 + 4);
          _trie_resolve_sub_string_ignore_diacritics(a1, &v53);
        }
        else
        {
          v41 = v52;
          findAddFlatBucket(a1, v52, *((_BYTE **)a2 + 1), *((int *)a2 + 4), a6, v36);
        }
      }
      else
      {
        v41 = v52;
      }
      a6[v35] = -127;
      if (_trie_resolve_string(*(_QWORD *)(a1 + 8), v41, v40, 1, &v52))
      {
        if (HIDWORD(v52))
        {
          v43 = v52;
          *(_QWORD *)a2 = v52;
          v44 = a2[1];
          v53 = *a2;
          v54 = v44;
          v55 = *((_QWORD *)a2 + 4);
          _trie_resolve_sub_string_ignore_diacritics(a1, &v53);
        }
        else
        {
          v43 = v52;
          findAddFlatBucket(a1, v52, *((_BYTE **)a2 + 1), *((int *)a2 + 4), a6, v36);
        }
      }
      else
      {
        v43 = v52;
      }
      a6[v35] = -126;
      if (_trie_resolve_string(*(_QWORD *)(a1 + 8), v43, v40, 1, &v52))
      {
        if (HIDWORD(v52))
        {
          v45 = v52;
          *(_QWORD *)a2 = v52;
          v46 = a2[1];
          v53 = *a2;
          v54 = v46;
          v55 = *((_QWORD *)a2 + 4);
          _trie_resolve_sub_string_ignore_diacritics(a1, &v53);
        }
        else
        {
          v45 = v52;
          findAddFlatBucket(a1, v52, *((_BYTE **)a2 + 1), *((int *)a2 + 4), a6, v36);
        }
      }
      else
      {
        v45 = v52;
      }
      a6[v35] = -125;
      if (_trie_resolve_string(*(_QWORD *)(a1 + 8), v45, v40, 1, &v52))
      {
        if (HIDWORD(v52))
        {
          v47 = v52;
          *(_QWORD *)a2 = v52;
          v48 = a2[1];
          v53 = *a2;
          v54 = v48;
          v55 = *((_QWORD *)a2 + 4);
          _trie_resolve_sub_string_ignore_diacritics(a1, &v53);
        }
        else
        {
          v47 = v52;
          findAddFlatBucket(a1, v52, *((_BYTE **)a2 + 1), *((int *)a2 + 4), a6, v36);
        }
      }
      else
      {
        v47 = v52;
      }
      a6[v35] = -124;
      if (!_trie_resolve_string(*(_QWORD *)(a1 + 8), v47, v40, 1, &v52))
        return;
      if (HIDWORD(v52))
      {
        *(_QWORD *)a2 = v52;
        v49 = a2[1];
        v53 = *a2;
        v54 = v49;
        v55 = *((_QWORD *)a2 + 4);
        _trie_resolve_sub_string_ignore_diacritics(a1, &v53);
        return;
      }
      v20 = (_BYTE *)*((_QWORD *)a2 + 1);
      v21 = *((int *)a2 + 4);
      v23 = v52;
      v24 = a1;
      v25 = a6;
      v22 = v36;
    }
    else
    {
      v20 = (_BYTE *)*((_QWORD *)a2 + 1);
      v21 = *((int *)a2 + 4);
      v23 = v52;
      v24 = a1;
      v25 = a6;
      v22 = v35;
    }
LABEL_11:
    findAddFlatBucket(v24, v23, v20, v21, v25, v22);
  }
}

double oq_force_meta(uint64_t a1)
{
  double result;
  char *v3;
  char *v4;
  const char *v5;

  if (!*(_BYTE *)a1)
  {
    if (*(_QWORD *)(a1 + 32))
    {
      v3 = __si_assert_copy_extra_1644(0);
      v4 = v3;
      v5 = "";
      if (v3)
        v5 = v3;
      __message_assert("%s:%u: failed assertion '%s' %s ", "OQueue.h", 452, "queue->just_offsets.count == 0", v5);
      free(v4);
      if (__valid_fs(-1))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
    free(*(void **)(a1 + 16));
    *(_BYTE *)a1 = 1;
    result = 0.0;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_OWORD *)(a1 + 32) = 0u;
    *(_OWORD *)(a1 + 44) = 0u;
    *(_QWORD *)(a1 + 64) = 0xFFFFFFFFLL;
    *(_DWORD *)(a1 + 8) = 0;
  }
  return result;
}

_DWORD *___bt_findBulk_block_invoke(_DWORD *result, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  _DWORD *v5;
  unsigned int v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  _QWORD *v13;
  unint64_t v14;
  unint64_t v15;
  _DWORD *v16;
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v21;
  int *v22;
  uint64_t v23;
  unint64_t v24;
  _QWORD *v25;
  unint64_t v26;
  unint64_t v27;
  _DWORD *v28;
  int v29;
  int v30;
  uint64_t v31;
  uint64_t v33;
  int *v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;

  v2 = *((_QWORD *)result + 4);
  v3 = *(unsigned int *)(v2 + 1176);
  if (v3 < result[10])
  {
    v5 = result;
    v6 = v3 + 1;
    *(_DWORD *)(v2 + 1176) = v3 + 1;
    v7 = (8 * **(unsigned int **)(*(_QWORD *)(v2 + 40) + 8 * v3)) & 0x7FFFFFFC0;
    if (v6 >= result[10])
    {
      LODWORD(v9) = 0x10000;
    }
    else
    {
      v8 = 0;
      v9 = 0x10000;
      do
      {
        v10 = (8 * **(unsigned int **)(*(_QWORD *)(v2 + 40) + 8 * v6)) & 0x7FFFFFFC0;
        if (v10 <= v7 + v9)
        {
          v9 = v10 - v7 + 0x10000;
        }
        else
        {
          v11 = *a2;
          v12 = v7 >> *(_BYTE *)(*a2 + 256);
          if (v12 < *(int *)(*a2 + 240)
            && (v13 = *(_QWORD **)(v11 + 8 * v12 + 264)) != 0
            && (v14 = v13[2], v14 <= v7)
            && (v15 = (int)v9 + v7, v13[3] >= v15)
            && *(_QWORD *)(v11 + 224) >= v15)
          {
            madvise((void *)(v13[1] + v7 - v14), (int)v9, 3);
          }
          else
          {
            v35 = v7;
            v36 = v9;
            v16 = *(_DWORD **)(v11 + 216);
            v37 = 0;
            v17 = _fd_acquire_fd((uint64_t)v16, &v37);
            do
            {
              v18 = fcntl(v17, 44, &v35);
              v19 = g_prot_error_callback;
              if (v18 != -1 || g_prot_error_callback == 0)
                break;
              v21 = v16[10];
              v22 = __error();
            }
            while (((*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t))(v19 + 16))(v19, v21, *v22, 12) & 1) != 0);
            _fd_release_fd(v16, v17, 0, v37);
          }
          v8 += v9;
          v2 = *((_QWORD *)v5 + 4);
          v9 = 0x10000;
          v7 = v10;
        }
        v6 = *(_DWORD *)(v2 + 1176) + 1;
        *(_DWORD *)(v2 + 1176) = v6;
      }
      while (v6 < v5[10] && v8 < 0x70000);
    }
    v23 = *a2;
    v24 = v7 >> *(_BYTE *)(*a2 + 256);
    if (v24 < *(int *)(*a2 + 240)
      && (v25 = *(_QWORD **)(v23 + 8 * v24 + 264)) != 0
      && (v26 = v25[2], v26 <= v7)
      && (v27 = (int)v9 + v7, v25[3] >= v27)
      && *(_QWORD *)(v23 + 224) >= v27)
    {
      return (_DWORD *)madvise((void *)(v25[1] + v7 - v26), (int)v9, 3);
    }
    else
    {
      v35 = v7;
      v36 = v9;
      v28 = *(_DWORD **)(v23 + 216);
      v37 = 0;
      v29 = _fd_acquire_fd((uint64_t)v28, &v37);
      do
      {
        v30 = fcntl(v29, 44, &v35);
        v31 = g_prot_error_callback;
        if (v30 != -1 || g_prot_error_callback == 0)
          break;
        v33 = v28[10];
        v34 = __error();
      }
      while (((*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t))(v31 + 16))(v31, v33, *v34, 12) & 1) != 0);
      return _fd_release_fd(v28, v29, 0, v37);
    }
  }
  return result;
}

void ___bt_findBulk_block_invoke_80(uint64_t a1, const char *a2)
{
  _QWORD *v3;
  uint64_t v4;
  size_t v5;
  BOOL v6;
  _DWORD *v7;
  void *v8;
  NSObject *v9;
  unint64_t v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  size_t v14;
  BOOL v15;
  unsigned int *v16;
  void *v17;
  unint64_t v18;
  unint64_t v19;
  void *v20;
  uint64_t v21;
  unint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int v28;
  unsigned int v29;
  int v30;
  unint64_t v31;
  unsigned int v32;
  unsigned int v33;
  uint64_t v34;
  uint64_t v35;
  void (*v36)(_QWORD);
  int v37;
  NSObject *v38;
  void *v39;
  void *v40;
  uint64_t v41;
  _DWORD *v42;
  unsigned int *v43;
  unsigned int v44;
  unsigned int *v45;
  unsigned int v46;
  int v47;
  unint64_t v48;
  unint64_t v49;
  unsigned int v50;
  unsigned int v51;
  uint64_t v52;
  uint64_t v53;
  void (*v54)(_QWORD);
  _DWORD *v55;
  int v56;
  NSObject *v57;
  int v58;
  void *v59;
  void *v60;
  uint64_t v61;
  _DWORD *v62;
  unsigned int *v63;
  unsigned int v64;
  int v65;
  NSObject *v66;
  os_log_type_t v67;
  unsigned int v68;
  int v69;
  unint64_t v70;
  unint64_t v71;
  unsigned int v72;
  unsigned int v73;
  uint64_t v74;
  uint64_t v75;
  void (*v76)(_QWORD);
  _DWORD *v77;
  int v78;
  NSObject *v79;
  int v80;
  void *v81;
  void *v82;
  uint64_t v83;
  _DWORD *v84;
  unsigned int *v85;
  unsigned int v86;
  unint64_t v87;
  uint64_t v88;
  uint64_t v89;
  const char *v90;
  const char *v91;
  _BYTE *v92;
  int v93;
  uint64_t v94;
  uint64_t v95;
  const char *v96;
  uint64_t v97;
  int *v98;
  int v99;
  _DWORD *v100;
  _DWORD *v101;
  const void *v102;
  unsigned int *v103;
  unint64_t v104;
  int v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  _DWORD *v112;
  int v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t ptr;
  unsigned __int16 *v118;
  int v119;
  NSObject *v120;
  uint64_t *v121;
  unint64_t v122;
  unsigned int v123;
  uint64_t v124;
  size_t v125;
  unint64_t v126;
  uint64_t v127;
  size_t v128;
  int v129;
  size_t v130;
  unint64_t v131;
  unint64_t v132;
  uint64_t v133;
  uint64_t v134;
  unsigned int v135;
  unsigned int v136;
  uint64_t v137;
  BOOL v138;
  uint64_t v139;
  unsigned int v140;
  int v141;
  uint64_t v142;
  int v143;
  uint64_t v144;
  unint64_t v145;
  const char *v146;
  unsigned int v147;
  unint64_t VInt64_1804;
  unsigned int v149;
  unint64_t v150;
  unsigned int v151;
  int v152;
  unint64_t v153;
  unsigned int v154;
  unsigned __int8 *v155;
  _BYTE *v156;
  int v157;
  uint64_t v158;
  uint64_t v159;
  unsigned __int8 **v160;
  uint64_t v161;
  uint64_t v162;
  int v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  int v167;
  char v168;
  int v169;
  uint64_t v170;
  int v171;
  unsigned __int8 *v172;
  unsigned __int8 *v173;
  unsigned int v174;
  unsigned int v175;
  unsigned int v176;
  unsigned int v177;
  BOOL v178;
  BOOL v179;
  uint64_t v180;
  unsigned int v181;
  size_t v182;
  __int16 v183;
  int v184;
  unsigned __int8 *v185;
  unsigned __int8 *v186;
  int v187;
  unsigned int v188;
  unsigned __int8 *v189;
  int v190;
  char v191;
  unsigned __int8 *v192;
  unsigned __int8 *v193;
  char v194;
  unsigned __int8 *v195;
  int v196;
  unsigned __int8 *v197;
  unsigned __int8 *v198;
  unsigned int v199;
  unsigned int v200;
  unsigned int v201;
  unsigned int v202;
  BOOL v203;
  BOOL v204;
  BOOL v205;
  BOOL v206;
  unsigned int v207;
  unsigned __int8 *v208;
  unsigned int v209;
  _BOOL4 v210;
  BOOL v211;
  unsigned __int8 *v212;
  unsigned __int8 *v213;
  unsigned int v214;
  unsigned int v215;
  _BOOL4 v216;
  unsigned int v217;
  unsigned int v218;
  BOOL v219;
  int v220;
  size_t v221;
  unsigned __int8 *v222;
  char TermIDsContextMatchPatternsReg;
  size_t v224;
  int v225;
  size_t v226;
  __int16 v227;
  int v228;
  unsigned __int8 *v229;
  unsigned __int8 *v230;
  unsigned int v231;
  unsigned int v232;
  BOOL v233;
  unsigned int v234;
  unsigned int v235;
  BOOL v236;
  size_t v237;
  int v238;
  unsigned __int8 *v239;
  unsigned __int8 *v240;
  size_t v241;
  __int16 v242;
  int v243;
  char v244;
  int v245;
  int v246;
  uint64_t v247;
  int v248;
  uint64_t v249;
  int v250;
  unsigned int v251;
  int v252;
  int v253;
  int v254;
  int v255;
  int v256;
  int v257;
  int v258;
  int v259;
  int v260;
  int v261;
  int v262;
  unint64_t v263;
  int v264;
  NSObject *v265;
  uint64_t v266;
  int v267;
  NSObject *v268;
  uint64_t v269;
  uint64_t v270;
  void (*v271)(_QWORD);
  int v272;
  NSObject *v273;
  os_log_type_t v274;
  uint64_t v275;
  uint64_t v276;
  void (*v277)(_QWORD);
  uint64_t v278;
  uint64_t v279;
  void (*v280)(_QWORD);
  unsigned int *v281;
  unsigned int v282;
  unsigned int v283;
  uint64_t i;
  unsigned int *v285;
  uint64_t v286;
  _QWORD *v287;
  unsigned int v288;
  unsigned int v289;
  void *v290;
  char *v291;
  char *v292;
  char *v293;
  const char *v294;
  int v295;
  NSObject *v296;
  uint64_t v297;
  uint64_t v298;
  char v299;
  int *v300;
  uint64_t v301;
  size_t v302;
  uint64_t v303;
  unint64_t v304;
  uint64_t v305;
  int v306;
  const char *v307;
  int v308;
  char *v309;
  char *v310;
  char *v311;
  char *v312;
  char *v313;
  unsigned __int8 *v314;
  unsigned __int8 *v315;
  _DWORD *v316;
  _QWORD *v317;
  _QWORD *v318;
  unsigned __int8 ***v319;
  _DWORD *v320;
  _DWORD *v321;
  uint64_t *v322;
  _BYTE *v323;
  unint64_t v324;
  int v325;
  int v326;
  _BYTE *v327;
  uint64_t v328;
  int v329;
  int v330;
  uint64_t *v331;
  uint64_t *v332;
  uint64_t v333;
  int v334;
  int v336;
  _QWORD *v337;
  _QWORD *v338;
  unsigned int v339;
  unsigned int v340;
  unsigned int v341;
  unsigned int v342;
  unsigned int v343;
  unsigned int v344;
  unsigned int v345;
  unsigned int v346;
  char v347;
  _BYTE v348[12];
  __int16 v349;
  int v350;
  __int16 v351;
  unint64_t v352;
  __int16 v353;
  unint64_t v354;
  __int16 v355;
  unint64_t v356;
  uint8_t buf[4];
  const char *v358;
  _BYTE v359[12];
  __int128 v360;
  unint64_t v361;
  uint64_t v362;

  v362 = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8 * (_QWORD)a2) < (unint64_t)*(unsigned int *)(a1 + 112)
    && !*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24))
  {
    makeThreadId();
    v3 = *(_QWORD **)(a1 + 72);
    v338 = (_QWORD *)a1;
    v333 = *(_QWORD *)(a1 + 64);
    memcpy((void *)(v333 + 1296 * (_QWORD)a2), v3, 0x510uLL);
    v332 = (uint64_t *)(v333 + 1296 * (_QWORD)a2 + 1160);
    if (*v332)
    {
      v4 = v333 + 1296 * (_QWORD)a2;
      v5 = *(unsigned int *)(v4 + 1152);
      if (v5 >> 14)
        v6 = 0;
      else
        v6 = 8 * v5 > *MEMORY[0x1E0C85AD8];
      if (v6)
        ++sTotal;
      v7 = (_DWORD *)(v4 + 1152);
      v8 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, v5, 8uLL, 0x31F9A007uLL);
      if (!v8 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_fault_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "allocation function returned null", buf, 2u);
      }
      *v332 = (uint64_t)v8;
      if (*v7)
      {
        v9 = MEMORY[0x1E0C81028];
        v10 = 0;
        do
        {
          v12 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 0x48uLL, 0x6085D6BuLL);
          if (!v12 && os_log_type_enabled(v9, OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_fault_impl(&dword_1B8270000, v9, OS_LOG_TYPE_FAULT, "allocation function returned null", buf, 2u);
          }
          *(_QWORD *)(*v332 + 8 * v10) = v12;
          v11 = *(_QWORD *)(*v332 + 8 * v10);
          *(_BYTE *)v11 = 0;
          *(_OWORD *)(v11 + 44) = 0u;
          *(_OWORD *)(v11 + 16) = 0u;
          *(_OWORD *)(v11 + 32) = 0u;
          *(_QWORD *)(v11 + 64) = 0xFFFFFFFFLL;
          *(_DWORD *)(v11 + 8) = 0;
          ++v10;
        }
        while (v10 < *v7);
      }
    }
    v331 = (uint64_t *)(v333 + 1296 * (_QWORD)a2 + 1168);
    if (*v331)
    {
      v13 = v333 + 1296 * (_QWORD)a2;
      v14 = *(unsigned int *)(v13 + 1152);
      if (v14 >> 14)
        v15 = 0;
      else
        v15 = 8 * v14 > *MEMORY[0x1E0C85AD8];
      if (v15)
        ++sTotal;
      v16 = (unsigned int *)(v13 + 1152);
      v17 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, v14, 8uLL, 0x31F9A007uLL);
      if (!v17 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_fault_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "allocation function returned null", buf, 2u);
      }
      *v331 = (uint64_t)v17;
      v18 = *v16;
      if ((_DWORD)v18)
      {
        v19 = 0;
        do
        {
          v22 = v18;
          if (*(_QWORD *)(v3[146] + 8 * v19))
          {
            if (*MEMORY[0x1E0C85AD8] <= 0x47uLL)
              ++sTotal;
            v20 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x48uLL, 0x31F9A007uLL);
            if (!v20 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_fault_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "allocation function returned null", buf, 2u);
            }
            *(_QWORD *)(*v331 + 8 * v19) = v20;
            v21 = *(_QWORD *)(*v331 + 8 * v19);
            *(_BYTE *)v21 = 0;
            *(_OWORD *)(v21 + 44) = 0u;
            *(_OWORD *)(v21 + 16) = 0u;
            *(_OWORD *)(v21 + 32) = 0u;
            *(_QWORD *)(v21 + 64) = 0xFFFFFFFFLL;
            *(_DWORD *)(v21 + 8) = 0;
            v22 = *v16;
          }
          ++v19;
          v18 = v22;
        }
        while (v19 < v22);
      }
    }
    v347 = 0;
    v23 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 0x18uLL, 0x6085D6BuLL);
    v24 = v338;
    if (v23)
    {
      v25 = v338[10] + 160;
      v26 = (uint64_t)v23;
    }
    else
    {
      if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_fault_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "allocation function returned null", buf, 2u);
      }
      v25 = v338[10] + 160;
      v26 = 0;
    }
    storage_reader_init(v25, v26);
    v27 = v338[12];
    if (v27 && !*(_BYTE *)(v27 + 8))
    {
      v65 = *__error();
      v66 = _SILogForLogForCategory(0);
      v67 = 2 * (gSILogLevels[0] < 4);
      if (os_log_type_enabled(v66, v67))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1B8270000, v66, v67, "Skipping because index is shut down", buf, 2u);
      }
      *__error() = v65;
      v45 = (unsigned int *)v23[1];
      if (!v45)
        goto LABEL_346;
LABEL_332:
      v281 = v45 + 2;
      do
      {
        v282 = __ldaxr(v281);
        v283 = v282 - 1;
      }
      while (__stlxr(v283, v281));
      if (!v283)
      {
        for (i = 0; i != 512; ++i)
        {
          v285 = &v45[2 * i];
          v286 = *((_QWORD *)v285 + 72);
          if (v286)
          {
            v287 = v285 + 144;
            do
            {
              v288 = __ldaxr((unsigned int *)v286);
              v289 = v288 - 1;
            }
            while (__stlxr(v289, (unsigned int *)v286));
            if (!v289)
            {
              v290 = *(void **)(v286 + 8);
              if (v290)
                munmap(v290, *(_QWORD *)(v286 + 24) - *(_QWORD *)(v286 + 16));
              free((void *)v286);
            }
            *v287 = 0;
          }
        }
        OSAtomicEnqueue(&availableReaders, v45, 0);
      }
LABEL_346:
      free(v23);
      if (!v347)
        *(_BYTE *)(*(_QWORD *)(v24[6] + 8) + 24) = 1;
      return;
    }
    v327 = (_BYTE *)(v333 + 1296 * (_QWORD)a2 + 88);
    v328 = *(_QWORD *)(v338[7] + 8 * (_QWORD)a2);
    v28 = *(_QWORD *)(v338[11] + 8 * (_QWORD)a2) - v328;
    do
    {
      v29 = __ldxr(exceptionSequenceNum);
      v30 = v29 + 1;
    }
    while (__stxr(v29 + 1, exceptionSequenceNum));
    v31 = setThreadIdAndInfo(-1, (__int128 *)sIndexExceptionCallbacks, v27, 0, v30);
    v345 = HIDWORD(v31);
    v346 = v31;
    v343 = v33;
    v344 = v32;
    v34 = *(_QWORD *)&threadData[18 * v31 + 2];
    v35 = v34 + 320 * HIDWORD(v31);
    *(_BYTE *)(v35 + 216) = 0;
    v334 = *(_DWORD *)(v35 + 312);
    v36 = *(void (**)(_QWORD))(v35 + 224);
    if (v36)
      v36(*(_QWORD *)(v34 + 320 * HIDWORD(v31) + 288));
    if (_setjmp((int *)v35))
    {
      v37 = *__error();
      v38 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        v358 = "_bt_findBulk_block_invoke";
        *(_WORD *)v359 = 1024;
        *(_DWORD *)&v359[2] = 4041;
        _os_log_error_impl(&dword_1B8270000, v38, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
      }
      *__error() = v37;
      *(_DWORD *)(v35 + 312) = v334;
      if (__THREAD_SLOT_KEY)
      {
        v39 = pthread_getspecific(__THREAD_SLOT_KEY);
        if (v39)
          goto LABEL_55;
      }
      else
      {
        makeThreadId();
        v39 = pthread_getspecific(__THREAD_SLOT_KEY);
        if (v39)
        {
LABEL_55:
          v40 = v39;
          if ((unint64_t)v39 < 0x801)
            goto LABEL_56;
        }
      }
      makeThreadId();
      v40 = pthread_getspecific(__THREAD_SLOT_KEY);
LABEL_56:
      v41 = (uint64_t)v40 - 1;
      v42 = &threadData[18 * ((uint64_t)v40 - 1)];
      v44 = v42[14];
      v43 = v42 + 14;
      if (v44 > v343)
      {
        do
          CIOnThreadCleanUpPop(v41);
        while (*v43 > v343);
      }
      dropThreadId(v346, 1, v30);
      CICleanUpReset(v346, v344);
      v45 = (unsigned int *)v23[1];
      if (!v45)
        goto LABEL_346;
      goto LABEL_332;
    }
    do
    {
      v46 = __ldxr(exceptionSequenceNum);
      v47 = v46 + 1;
    }
    while (__stxr(v46 + 1, exceptionSequenceNum));
    v48 = setThreadIdAndInfo(-1, sAssertExceptionCallbacks, 0, 0, v47);
    v49 = v48;
    v342 = v50;
    v341 = v51;
    v52 = *(_QWORD *)&threadData[18 * v48 + 2];
    v53 = v52 + 320 * HIDWORD(v48);
    v329 = *(_DWORD *)(v53 + 312);
    v54 = *(void (**)(_QWORD))(v53 + 224);
    if (v54)
      v54(*(_QWORD *)(v52 + 320 * HIDWORD(v48) + 288));
    v330 = v47;
    if (_setjmp((int *)v53))
    {
      v55 = (_DWORD *)(v53 + 312);
      v56 = *__error();
      v57 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        v358 = "_bt_findBulk_block_invoke";
        *(_WORD *)v359 = 1024;
        *(_DWORD *)&v359[2] = 4040;
        _os_log_error_impl(&dword_1B8270000, v57, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
      }
      *__error() = v56;
      *v55 = v329;
      v58 = v334;
      if (__THREAD_SLOT_KEY)
      {
        v59 = pthread_getspecific(__THREAD_SLOT_KEY);
        if (!v59)
          goto LABEL_360;
      }
      else
      {
        makeThreadId();
        v59 = pthread_getspecific(__THREAD_SLOT_KEY);
        if (!v59)
          goto LABEL_360;
      }
      v60 = v59;
      if ((unint64_t)v59 < 0x801)
      {
LABEL_69:
        v61 = (uint64_t)v60 - 1;
        v62 = &threadData[18 * ((uint64_t)v60 - 1)];
        v64 = v62[14];
        v63 = v62 + 14;
        if (v64 > v341)
        {
          do
            CIOnThreadCleanUpPop(v61);
          while (*v63 > v341);
        }
        dropThreadId(v49, 1, v47);
        CICleanUpReset(v49, v342);
        goto LABEL_329;
      }
LABEL_360:
      makeThreadId();
      v60 = pthread_getspecific(__THREAD_SLOT_KEY);
      goto LABEL_69;
    }
    if (v23 && !*((_BYTE *)v23 + 16))
    {
      v272 = *__error();
      v273 = _SILogForLogForCategory(0);
      v274 = 2 * (gSILogLevels[0] < 4);
      v80 = v329;
      if (os_log_type_enabled(v273, v274))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1B8270000, v273, v274, "Skipping because index is shut down", buf, 2u);
      }
      *__error() = v272;
      v58 = v334;
      goto LABEL_326;
    }
    do
    {
      v68 = __ldxr(exceptionSequenceNum);
      v69 = v68 + 1;
    }
    while (__stxr(v68 + 1, exceptionSequenceNum));
    v70 = setThreadIdAndInfo(-1, sStorageReaderExceptionCallbacks, (uint64_t)v23, 0, v69);
    v71 = v70;
    v340 = v72;
    v339 = v73;
    v74 = *(_QWORD *)&threadData[18 * v70 + 2];
    v75 = v74 + 320 * HIDWORD(v70);
    v325 = *(_DWORD *)(v75 + 312);
    v76 = *(void (**)(_QWORD))(v75 + 224);
    if (v76)
      v76(*(_QWORD *)(v74 + 320 * HIDWORD(v70) + 288));
    v326 = v69;
    if (_setjmp((int *)v75))
    {
      v77 = (_DWORD *)(v75 + 312);
      v78 = *__error();
      v79 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v79, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        v358 = "_bt_findBulk_block_invoke";
        *(_WORD *)v359 = 1024;
        *(_DWORD *)&v359[2] = 4039;
        _os_log_error_impl(&dword_1B8270000, v79, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
      }
      *__error() = v78;
      *v77 = v325;
      v58 = v334;
      v47 = v330;
      v80 = v329;
      if (__THREAD_SLOT_KEY)
      {
        v81 = pthread_getspecific(__THREAD_SLOT_KEY);
        if (!v81)
          goto LABEL_363;
      }
      else
      {
        makeThreadId();
        v81 = pthread_getspecific(__THREAD_SLOT_KEY);
        if (!v81)
          goto LABEL_363;
      }
      v82 = v81;
      if ((unint64_t)v81 < 0x801)
      {
LABEL_87:
        v83 = (uint64_t)v82 - 1;
        v84 = &threadData[18 * ((uint64_t)v82 - 1)];
        v86 = v84[14];
        v85 = v84 + 14;
        if (v86 > v339)
        {
          do
            CIOnThreadCleanUpPop(v83);
          while (*v85 > v339);
        }
        dropThreadId(v71, 1, v326);
        CICleanUpReset(v71, v340);
LABEL_326:
        v275 = *(_QWORD *)&threadData[18 * v49 + 2];
        v276 = v275 + 320 * HIDWORD(v49);
        *(_DWORD *)(v276 + 312) = v80;
        v277 = *(void (**)(_QWORD))(v276 + 232);
        if (v277)
          v277(*(_QWORD *)(v275 + 320 * HIDWORD(v49) + 288));
        dropThreadId(v49, 0, v47);
LABEL_329:
        v278 = *(_QWORD *)&threadData[18 * v346 + 2];
        v279 = v278 + 320 * v345;
        *(_DWORD *)(v279 + 312) = v58;
        v280 = *(void (**)(_QWORD))(v279 + 232);
        if (v280)
          v280(*(_QWORD *)(v278 + 320 * v345 + 288));
        dropThreadId(v346, 0, v30);
        v45 = (unsigned int *)v23[1];
        if (!v45)
          goto LABEL_346;
        goto LABEL_332;
      }
LABEL_363:
      makeThreadId();
      v82 = pthread_getspecific(__THREAD_SLOT_KEY);
      goto LABEL_87;
    }
    v337 = v23;
    if (dword_1EF19FC90 >= 5)
    {
      v295 = *__error();
      v296 = _SILogForLogForCategory(1);
      if (os_log_type_enabled(v296, OS_LOG_TYPE_DEFAULT))
      {
        v297 = *(_QWORD *)(v338[7] + 8 * (_QWORD)a2);
        v298 = *(_QWORD *)(v338[11] + 8 * (_QWORD)a2);
        *(_DWORD *)buf = 134218496;
        v358 = a2;
        *(_WORD *)v359 = 2048;
        *(_QWORD *)&v359[2] = v297;
        *(_WORD *)&v359[10] = 2048;
        *(_QWORD *)&v360 = v298;
        _os_log_impl(&dword_1B8270000, v296, OS_LOG_TYPE_DEFAULT, "Applier %lu starting at %lu ending at %lu", buf, 0x20u);
      }
      *__error() = v295;
      v24 = v338;
    }
    v87 = v28;
    v88 = v333 + 1296 * (_QWORD)a2;
    if (!v28)
    {
LABEL_320:
      v347 = 1;
      v269 = *(_QWORD *)&threadData[18 * v71 + 2];
      v270 = v269 + 320 * HIDWORD(v71);
      *(_DWORD *)(v270 + 312) = v325;
      v271 = *(void (**)(_QWORD))(v270 + 232);
      if (v271)
        v271(*(_QWORD *)(v269 + 320 * HIDWORD(v71) + 288));
      dropThreadId(v71, 0, v326);
      v58 = v334;
      v47 = v330;
      v80 = v329;
      goto LABEL_326;
    }
    v89 = v333 + 1296 * (_QWORD)a2;
    v322 = (uint64_t *)(v89 + 1144);
    v323 = (_BYTE *)(v89 + 1289);
    v321 = (_DWORD *)(v89 + 48);
    v300 = (int *)(v89 + 1140);
    v320 = (_DWORD *)(v89 + 1152);
    v318 = (_QWORD *)(v89 + 1248);
    v319 = (unsigned __int8 ***)(v89 + 1240);
    v316 = (_DWORD *)(v89 + 1280);
    v317 = (_QWORD *)(v89 + 1256);
    v314 = (unsigned __int8 *)(v89 + 89);
    v315 = (unsigned __int8 *)(v89 + 89);
    v312 = (char *)(v89 + 91);
    v313 = (char *)(v89 + 90);
    v310 = (char *)(v89 + 93);
    v311 = (char *)(v89 + 92);
    v309 = (char *)(v89 + 94);
    v90 = 0;
    v336 = v30;
    v324 = v28;
    while (1)
    {
      v91 = v90;
      v92 = (_BYTE *)v24[13];
      v93 = *v92;
      if (!*v92)
        break;
LABEL_312:
      v266 = v24[5];
      if (v266)
        (*(void (**)(uint64_t, _QWORD *))(v266 + 16))(v266, v23);
      v90 = v91 + 1;
      if ((unint64_t)(v91 + 1) >= v87 || v93)
        goto LABEL_320;
    }
    v308 = *v92;
    v94 = *((unsigned int *)v24 + 29);
    v95 = v24[4];
    v307 = v91;
    v96 = &v91[v328];
    v97 = 8 * (_QWORD)&v91[v328];
    v98 = *(int **)(*(_QWORD *)(v88 + 40) + v97);
    v99 = *v98;
    v306 = v98[1];
    v100 = v98 + 3;
    v101 = v98 + 2;
    if ((v99 & 3) != 0)
      v102 = v100;
    else
      v102 = v101;
    memcpy(v327, v102, v306);
    v327[v306 + 1] = 0;
    v103 = *(unsigned int **)(*(_QWORD *)(v88 + 40) + v97);
    v104 = (unint64_t)*v103 >> 3;
    if (dword_1EF19FC90 >= 5)
    {
      v267 = *__error();
      v268 = _SILogForLogForCategory(1);
      if (os_log_type_enabled(v268, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134218754;
        v358 = v307;
        *(_WORD *)v359 = 1024;
        *(_DWORD *)&v359[2] = v104;
        *(_WORD *)&v359[6] = 1024;
        *(_DWORD *)&v359[8] = v306;
        LOWORD(v360) = 2080;
        *(_QWORD *)((char *)&v360 + 2) = v333 + 1296 * (_QWORD)a2 + 88;
        _os_log_impl(&dword_1B8270000, v268, OS_LOG_TYPE_DEFAULT, "bucket[%ld] %x %d %s\n", buf, 0x22u);
      }
      *__error() = v267;
      v105 = **(_DWORD **)(*(_QWORD *)(v88 + 40) + 8 * (_QWORD)v96);
      v106 = *(_QWORD *)(*(_QWORD *)(v88 + 40) + 8 * (_QWORD)v96);
      v23 = v337;
    }
    else
    {
      v105 = *v103;
      v106 = *(_QWORD *)(*(_QWORD *)(v88 + 40) + v97);
    }
    v107 = *(unsigned int *)(v106 + 4);
    v108 = v106 + 12;
    v109 = v106 + 8;
    if ((v105 & 3) != 0)
      v110 = v108;
    else
      v110 = v109;
    v111 = v110 + v107 + 1;
    v112 = v320;
    if (*v323 && (_DWORD)v94)
    {
      v113 = -1;
      v114 = 0;
      v115 = 0;
      do
      {
        if ((*(_BYTE *)(*v322 + v115 + 16) & 4) == 0 && **(_BYTE **)(*v322 + v115) == 42)
        {
          v116 = v114 >> 3;
          if (v113 == -1)
          {
            if (((*(unsigned __int8 *)(v111 + v116) >> (v114 & 7)) & 1) == 0)
              break;
            v113 = v114;
          }
          else
          {
            *(_BYTE *)(v111 + v116) |= 1 << (v114 & 7);
          }
        }
        ++v114;
        v115 += 64;
      }
      while (v94 != v114);
    }
    v305 = v111;
    ptr = storage_reader_get_ptr(*v23, v23[1], v104 << 6, 8uLL);
    if (ptr == -1
      || (v118 = (unsigned __int16 *)storage_reader_get_ptr(*v23, v23[1], v104 << 6, 64 << *(_BYTE *)(ptr + 2)),
          (unint64_t)v118 + 1 <= 1))
    {
      v119 = *__error();
      v120 = _SILogForLogForCategory(0);
      v24 = v338;
      v30 = v336;
      if (os_log_type_enabled(v120, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        v358 = "match_function";
        *(_WORD *)v359 = 1024;
        *(_DWORD *)&v359[2] = 3841;
        _os_log_error_impl(&dword_1B8270000, v120, OS_LOG_TYPE_ERROR, "%s:%d: can't resolve flat store page", buf, 0x12u);
      }
      *__error() = v119;
      goto LABEL_311;
    }
    v304 = v104 << 6;
    v360 = 0uLL;
    v121 = v322;
    *(_DWORD *)buf = *v321;
    v358 = 0;
    memset(v359, 0, sizeof(v359));
    v123 = *v118;
    v122 = v123;
    *(_QWORD *)&v360 = v118 + 4;
    v361 = v123;
    v124 = v305;
    if (v123)
    {
      v303 = v95;
      v125 = 0;
      v126 = 0;
      v127 = 0;
      while (1)
      {
        v133 = v360;
        v134 = v127 + 1;
        v135 = *(unsigned __int8 *)(v360 + v127);
        if (*(char *)(v360 + v127) < 0)
        {
          if (v135 > 0xBF)
          {
            if (v135 > 0xDF)
            {
              if (v135 > 0xEF)
              {
                v136 = *(_DWORD *)(v360 + v134);
                v137 = v127 + 5;
              }
              else
              {
                v136 = ((v135 & 0xF) << 24) | (*(unsigned __int8 *)(v360 + v134) << 16) | (*(unsigned __int8 *)(v127 + v360 + 2) << 8) | *(unsigned __int8 *)(v127 + v360 + 3);
                v137 = v127 + 4;
              }
            }
            else
            {
              v136 = ((v135 & 0x1F) << 16) | (*(unsigned __int8 *)(v360 + v134) << 8) | *(unsigned __int8 *)(v127 + v360 + 2);
              v137 = v127 + 3;
            }
          }
          else
          {
            v137 = v127 + 2;
            v136 = *(unsigned __int8 *)(v360 + v134) | ((v135 & 0x3F) << 8);
          }
        }
        else
        {
          v136 = *(unsigned __int8 *)(v360 + v127);
          v137 = v127 + 1;
        }
        if (v136)
          v138 = 1;
        else
          v138 = v137 == 1;
        if (!v138)
        {
          v292 = __si_assert_copy_extra_1644(0);
          v293 = v292;
          v294 = "";
          if (v292)
            v294 = v292;
          __message_assert("%s:%u: failed assertion '%s' %s %d, %ld", "FlatStore.h", 431, "entry->len > 0 || iter->pageCursor == v2_vInt32Size(0)", v294, 0, v137);
          free(v293);
          if (__valid_fs(-1))
          {
            MEMORY[0xBAD] = -559038737;
            abort();
          }
          MEMORY[0xC00] = -559038737;
          abort();
        }
        v139 = v137 + 1;
        v140 = *(unsigned __int8 *)(v360 + v137);
        if (*(char *)(v360 + v137) < 0)
        {
          if (v140 > 0xBF)
          {
            if (v140 > 0xDF)
            {
              if (v140 > 0xEF)
              {
                v143 = *(_DWORD *)(v360 + v139);
                v142 = v137 + 5;
              }
              else
              {
                v143 = ((v140 & 0xF) << 24) | (*(unsigned __int8 *)(v360 + v139) << 16) | (*(unsigned __int8 *)(v137 + v360 + 2) << 8) | *(unsigned __int8 *)(v137 + v360 + 3);
                v142 = v137 + 4;
              }
            }
            else
            {
              v143 = ((v140 & 0x1F) << 16) | (*(unsigned __int8 *)(v360 + v139) << 8) | *(unsigned __int8 *)(v137 + v360 + 2);
              v142 = v137 + 3;
            }
          }
          else
          {
            v143 = *(unsigned __int8 *)(v360 + v139) | ((v140 & 0x3F) << 8);
            v142 = v137 + 2;
          }
          v141 = v143;
        }
        else
        {
          v141 = *(unsigned __int8 *)(v360 + v137);
          v142 = v139;
        }
        v144 = v136;
        v145 = v142 + v136;
        v132 = v145;
        *((_QWORD *)&v360 + 1) = v145;
        if (v145 > v122)
          break;
        if (*(_DWORD *)buf)
        {
          v146 = v358;
          v358 = &v146[v2_readVInt64_1804(v360, (uint64_t *)&v360 + 1)];
          v126 = (unint64_t)v358 >> 32;
          v147 = v358;
          VInt64_1804 = v2_readVInt64_1804(v360, (uint64_t *)&v360 + 1);
          if (VInt64_1804)
          {
            *(_QWORD *)v359 += VInt64_1804;
            v125 = *(_QWORD *)v359;
            v149 = v147;
          }
          else
          {
            v149 = v147;
            v125 = 0;
          }
          v88 = v333 + 1296 * (_QWORD)a2;
          v121 = v322;
          v112 = v320;
          v124 = v305;
        }
        else
        {
          v150 = v145 + 1;
          v151 = *(unsigned __int8 *)(v360 + v145);
          if (*(char *)(v360 + v145) < 0)
          {
            if (v151 > 0xBF)
            {
              if (v151 > 0xDF)
              {
                if (v151 > 0xEF)
                {
                  v152 = *(_DWORD *)(v360 + v150);
                  v153 = v145 + 5;
                }
                else
                {
                  v152 = ((v151 & 0xF) << 24) | (*(unsigned __int8 *)(v360 + v150) << 16) | (*(unsigned __int8 *)(v145 + v360 + 2) << 8) | *(unsigned __int8 *)(v145 + v360 + 3);
                  v153 = v145 + 4;
                }
              }
              else
              {
                v152 = ((v151 & 0x1F) << 16) | (*(unsigned __int8 *)(v360 + v150) << 8) | *(unsigned __int8 *)(v145 + v360 + 2);
                v153 = v145 + 3;
              }
            }
            else
            {
              v153 = v145 + 2;
              v152 = *(unsigned __int8 *)(v360 + v150) | ((v151 & 0x3F) << 8);
            }
            v150 = v153;
          }
          else
          {
            v152 = *(unsigned __int8 *)(v360 + v145);
          }
          *((_QWORD *)&v360 + 1) = v150;
          v149 = v152;
        }
        v132 = *((_QWORD *)&v360 + 1);
        if (*((_QWORD *)&v360 + 1) > v361)
        {
          v291 = __si_assert_copy_extra_1644(0);
          __message_assert("%s:%u: failed assertion '%s' %s ");
          goto LABEL_350;
        }
        v154 = v136 + v306 + v141;
        if (v154 > 0x413)
        {
          v131 = v361;
          goto LABEL_305;
        }
        v130 = v125;
        if (v136)
        {
          v155 = (unsigned __int8 *)(v133 + v142);
          v156 = &v327[v306 + v141];
          do
          {
            v157 = *v155++;
            *v156++ = tcmr[v157];
            --v144;
          }
          while (v144);
        }
        v327[v154] = 0;
        *v300 = v154;
        if (v303)
        {
          v128 = v125;
          v129 = (*(uint64_t (**)(void))(v303 + 16))();
          v130 = v128;
          v124 = v305;
          v121 = v322;
          v23 = v337;
          if (!v129)
            goto LABEL_310;
        }
        else
        {
          v23 = v337;
          if (*v112)
          {
            v158 = 0;
            v301 = v149 | (v126 << 32);
            v302 = v125;
            while (1)
            {
              if (((*(unsigned __int8 *)(v124 + (v158 >> 3)) >> (v158 & 7)) & 1) == 0)
                goto LABEL_171;
              v159 = *v121;
              v160 = (unsigned __int8 **)(*v121 + (v158 << 6));
              *v319 = v160;
              v161 = *v332;
              if (*v332)
                v161 = *(_QWORD *)(v161 + 8 * v158);
              *v318 = v161;
              v162 = *v331;
              if (*v331)
                v162 = *(_QWORD *)(v162 + 8 * v158);
              *v317 = v162;
              ++*v316;
              v163 = *(_DWORD *)(v159 + (v158 << 6) + 16);
              if ((v163 & 0x610) != 0 || **(_BYTE **)v88)
                goto LABEL_171;
              if ((v163 & 4) != 0)
                break;
              if ((v163 & 0x8000) == 0 && **v160 == 42 && !(*v160)[1])
              {
                v237 = v130;
                v238 = *(_DWORD *)(v159 + (v158 << 6) + 16);
                v239 = termFieldMatch(*(_DWORD *)(v159 + (v158 << 6) + 20), v327, *v300, v238);
                LOWORD(v163) = v238;
                v130 = v237;
                v124 = v305;
                v121 = v322;
                if (!v239)
                  goto LABEL_171;
                goto LABEL_264;
              }
              v164 = v159 + (v158 << 6);
              v166 = *(_QWORD *)(v164 + 32);
              v165 = *(_QWORD *)(v164 + 40);
              if (!v166)
              {
                if (v165)
                {
LABEL_185:
                  if (*v327 != 1)
                  {
                    v224 = v130;
                    v225 = termPropertyID(v327, *v300);
                    v130 = v224;
                    v124 = v305;
                    v121 = v322;
                    v170 = 0;
                    v169 = v225;
                    goto LABEL_271;
                  }
                  v167 = *v314;
                  if (v167 == 2)
                  {
                    v168 = *v313;
                    if ((*v313 & 0x80000000) == 0)
                    {
                      v169 = *v313;
                      v170 = 3;
                      goto LABEL_271;
                    }
                    v245 = *v312;
                    if ((*v312 & 0x80000000) == 0)
                    {
                      v246 = v168 & 0x7F | (v245 << 7);
                      v247 = 4;
                      goto LABEL_270;
                    }
                    v252 = *v311;
                    if ((*v311 & 0x80000000) == 0)
                    {
                      v169 = ((v245 & 0x7F) << 7) | (v252 << 14) | v168 & 0x7F;
                      v170 = 5;
                      goto LABEL_271;
                    }
                    v255 = *v310;
                    if ((*v310 & 0x80000000) == 0)
                    {
                      v256 = ((v252 & 0x7F) << 14) | (v255 << 21) | ((v245 & 0x7F) << 7) | v168 & 0x7F;
                      v170 = 6;
                      goto LABEL_291;
                    }
                    v258 = *v309;
                    if (v258 < 0)
                      goto LABEL_367;
                    v259 = ((v255 & 0x7F) << 21) | (v258 << 28) | ((v252 & 0x7F) << 14) | ((v245 & 0x7F) << 7) | v168 & 0x7F;
                    v170 = 7;
LABEL_296:
                    v169 = v259;
                  }
                  else
                  {
                    if ((v167 & 0x80) == 0)
                    {
                      v169 = *v314;
                      v170 = 2;
                      goto LABEL_271;
                    }
                    v248 = *v313;
                    if (*v313 < 0)
                    {
                      v253 = *v312;
                      if (*v312 < 0)
                      {
                        v257 = *v311;
                        if (*v311 < 0)
                        {
                          v260 = *v310;
                          if (v260 < 0)
                          {
LABEL_367:
                            v291 = __si_assert_copy_extra_1644(0);
                            __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t");
LABEL_350:
                            free(v291);
                            if (__valid_fs(-1))
                            {
                              MEMORY[0xBAD] = -559038737;
                              abort();
                            }
                            MEMORY[0xC00] = -559038737;
                            abort();
                          }
                          v259 = ((v257 & 0x7F) << 21) | (v260 << 28) | ((v253 & 0x7F) << 14) | ((v248 & 0x7F) << 7) | v167 & 0x7F;
                          v170 = 6;
                          goto LABEL_296;
                        }
                        v256 = ((v253 & 0x7F) << 14) | (v257 << 21) | ((v248 & 0x7F) << 7) | v167 & 0x7F;
                        v170 = 5;
LABEL_291:
                        v169 = v256;
                      }
                      else
                      {
                        v169 = ((v248 & 0x7F) << 7) | (v253 << 14) | v167 & 0x7F;
                        v170 = 4;
                      }
                    }
                    else
                    {
                      v246 = v167 & 0x7F | (v248 << 7);
                      v247 = 3;
LABEL_270:
                      v249 = v247;
                      v169 = v246;
                      v170 = v249;
                    }
                  }
LABEL_271:
                  if (*(_DWORD *)(v159 + (v158 << 6) + 20) == v169)
                  {
                    v250 = *v300 - v170;
                    while (v250 >= 1)
                    {
                      v251 = *(unsigned __int8 *)(v333 + 1296 * (_QWORD)a2 + v170 - 1 + v250 + 88);
                      if (v251 > 5)
                      {
                        v221 = v130;
                        TermIDsContextMatchPatternsReg = __findTermIDsContextMatchPatternsRegExMatch();
                        goto LABEL_278;
                      }
                      --v250;
                      if ((v251 & 0xFFFFFFFD) != 1)
                        goto LABEL_171;
                    }
                  }
                  goto LABEL_171;
                }
                v180 = v159 + (v158 << 6);
                v181 = *v300;
                if (*(_DWORD *)(v180 + 20) == 1)
                {
                  v182 = v130;
                  v183 = v163;
                  v184 = termPropertyID(v327, v181);
                  v130 = v182;
                  v124 = v305;
                  v121 = v322;
                  if (v184 != 1)
                    goto LABEL_171;
                  LOWORD(v163) = v183;
                  v181 = *v300;
                }
                v185 = *v160;
                v186 = *v160;
                v187 = *(_DWORD *)(v180 + 24);
                v188 = **v160;
                if (v188 > 4)
                {
                  if (v188 == 42)
                  {
                    v226 = v130;
                    v227 = v163;
                    v299 = *(_DWORD *)(v180 + 24);
                    v228 = termPropertyID(v327, v181);
                    LOBYTE(v187) = v299;
                    LOWORD(v163) = v227;
                    v130 = v226;
                    v124 = v305;
                    v121 = v322;
                    v197 = (unsigned __int8 *)(v333 + 1296 * (_QWORD)a2 + 88);
                    if (v228 == 2)
                      goto LABEL_171;
                  }
                  else
                  {
                    v197 = (unsigned __int8 *)(v333 + 1296 * (_QWORD)a2 + 88);
                  }
                }
                else
                {
                  if (v188 != *v327)
                    goto LABEL_171;
                  v189 = v185 + 1;
                  v190 = v185[1];
                  if (v190 != *v314)
                    goto LABEL_171;
                  v191 = v190;
                  v192 = v189;
                  v193 = (unsigned __int8 *)v313;
                  if (v190 == 2)
                  {
                    v196 = v186[2];
                    v195 = v186 + 2;
                    v194 = v196;
                    if (v196 != *v313)
                      goto LABEL_171;
                    v191 = v194;
                    v192 = v195;
                    v193 = (unsigned __int8 *)v312;
                  }
                  v186 = v192 + 1;
                  if (v191 < 0)
                  {
                    v254 = *v186;
                    if (v254 != *v193)
                      goto LABEL_171;
                    v186 = v192 + 2;
                    if ((char)v254 < 0)
                    {
                      v261 = *v186;
                      if (v261 != v193[1])
                        goto LABEL_171;
                      if ((char)v261 < 0)
                      {
                        v262 = (char)v192[3];
                        if (v262 < 0 || v193[2] != v262)
                          goto LABEL_171;
                        v197 = v193 + 3;
                        v186 = v192 + 4;
                      }
                      else
                      {
                        v197 = v193 + 2;
                        v186 = v192 + 3;
                      }
                    }
                    else
                    {
                      v197 = v193 + 1;
                    }
                  }
                  else
                  {
                    v197 = v193;
                  }
                }
                v240 = v186;
                v241 = v130;
                v242 = v163;
                v243 = matche(v240, v197, v187, 0, 0);
                LOWORD(v163) = v242;
                v130 = v241;
                v124 = v305;
                v121 = v322;
                if (v243 != 1)
                  goto LABEL_171;
                goto LABEL_264;
              }
              if (v165)
                goto LABEL_185;
              v221 = v130;
              v222 = termFieldMatch(*(_DWORD *)(v159 + (v158 << 6) + 20), v327, *v300, *(_DWORD *)(v159 + (v158 << 6) + 16));
              v130 = v221;
              v124 = v305;
              v121 = v322;
              if (v222)
              {
                *(_QWORD *)v348 = 0;
                TermIDsContextMatchPatternsReg = icu_search_match();
LABEL_278:
                v130 = v221;
                v124 = v305;
                v121 = v322;
                if ((TermIDsContextMatchPatternsReg & 1) != 0)
                {
                  v244 = 1;
LABEL_170:
                  findHandleMatch(v88, v301, v302, v327, *v300, v244);
                  v121 = v322;
                  v124 = v305;
                  v130 = v221;
                }
              }
LABEL_171:
              if (++v158 >= (unint64_t)*v112)
                goto LABEL_120;
            }
            v171 = *v327;
            if ((v171 - 2) > 2 || v171 != **v160)
              goto LABEL_171;
            v172 = *v160 + 1;
            if ((v163 & 0x20) != 0)
            {
              v198 = v315;
              do
              {
                v200 = *v198++;
                v199 = v200;
                v202 = *v172++;
                v201 = v202;
                if (v199)
                  v203 = v199 == v201;
                else
                  v203 = 0;
              }
              while (v203);
              v204 = v201 != 0;
              v205 = v199 < v201;
              if (v199)
                v206 = v205;
              else
                v206 = v204;
              if (v206)
                goto LABEL_171;
            }
            else
            {
              v173 = v315;
              do
              {
                v175 = *v173++;
                v174 = v175;
                v177 = *v172++;
                v176 = v177;
                if (v174)
                  v178 = v174 == v176;
                else
                  v178 = 0;
              }
              while (v178);
              if (v174)
                v179 = v174 >= v176;
              else
                v179 = 0;
              if (!v179)
                goto LABEL_171;
            }
            v207 = *v327;
            v208 = *(unsigned __int8 **)(v159 + (v158 << 6) + 8);
            v209 = *v208;
            v210 = v171 == 0;
            v211 = v171 != v209 || v171 == 0;
            if ((v163 & 0x40) != 0)
            {
              if (!v211)
              {
                v229 = v208 + 1;
                v230 = v315;
                do
                {
                  v232 = *v230++;
                  v231 = v232;
                  v233 = v232 == 0;
                  v235 = *v229++;
                  v234 = v235;
                  if (v231)
                    v236 = v231 == v234;
                  else
                    v236 = 0;
                }
                while (v236);
                v209 = v234;
                v207 = v231;
                LOBYTE(v210) = v233;
              }
              if (v207 >= v209 && !v210)
                goto LABEL_171;
            }
            else
            {
              if (!v211)
              {
                v212 = v208 + 1;
                v213 = v315;
                do
                {
                  v215 = *v213++;
                  v214 = v215;
                  v216 = v215 == 0;
                  v218 = *v212++;
                  v217 = v218;
                  if (v214)
                    v219 = v214 == v217;
                  else
                    v219 = 0;
                }
                while (v219);
                v209 = v217;
                v207 = v214;
                v210 = v216;
              }
              if (v209)
                v220 = -1;
              else
                v220 = 0;
              if (!v210)
                v220 = (v207 < v209) << 31;
              if ((v220 & 0x80000000) == 0)
                goto LABEL_171;
            }
LABEL_264:
            if ((v163 & 0x8000) != 0)
              goto LABEL_171;
            v221 = v130;
            v244 = 0;
            goto LABEL_170;
          }
        }
LABEL_120:
        v127 = *((_QWORD *)&v360 + 1);
        v122 = v361;
        v131 = v361;
        v132 = *((_QWORD *)&v360 + 1);
        v125 = v130;
        if (*((_QWORD *)&v360 + 1) >= v361)
          goto LABEL_306;
      }
      v131 = v122;
LABEL_305:
      v23 = v337;
LABEL_306:
      if (v132 != v131)
      {
        v263 = v132;
        v264 = *__error();
        v265 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v265, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)v348 = 136316162;
          *(_QWORD *)&v348[4] = "match_function";
          v349 = 1024;
          v350 = 3879;
          v351 = 2048;
          v352 = v304;
          v353 = 2048;
          v354 = v263;
          v355 = 2048;
          v356 = v131;
          _os_log_error_impl(&dword_1B8270000, v265, OS_LOG_TYPE_ERROR, "%s:%d: invalid flat store page (0x%llx). cursor(%ld) != end(%ld)", v348, 0x30u);
        }
        *__error() = v264;
      }
    }
LABEL_310:
    v24 = v338;
    v30 = v336;
LABEL_311:
    v87 = v324;
    v93 = v308;
    v91 = v307;
    goto LABEL_312;
  }
}

unint64_t v2_readVInt64_1804(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  unint64_t result;
  unint64_t v7;
  unsigned __int8 *v8;
  unint64_t v9;
  unsigned __int8 *v10;

  v3 = *a2;
  v4 = *a2 + 1;
  v5 = *(char *)(a1 + *a2);
  result = *(unsigned __int8 *)(a1 + *a2);
  if (v5 < 0)
  {
    if (v5 > 0xBFu)
    {
      if (v5 > 0xDFu)
      {
        if (v5 > 0xEFu)
        {
          if (v5 > 0xF7u)
          {
            if (v5 > 0xFBu)
            {
              if (v5 > 0xFDu)
              {
                if (v5 == 255)
                {
                  result = *(_QWORD *)(a1 + v4);
                  *a2 = v3 + 9;
                }
                else
                {
                  v9 = (unint64_t)*(unsigned __int8 *)(a1 + v4) << 48;
                  v10 = (unsigned __int8 *)(v3 + a1);
                  result = v9 | ((unint64_t)v10[2] << 40) | ((unint64_t)v10[3] << 32) | ((unint64_t)v10[4] << 24) | ((unint64_t)v10[5] << 16) | ((unint64_t)v10[6] << 8) | v10[7];
                  *a2 = v3 + 8;
                }
              }
              else
              {
                v7 = ((result & 1) << 48) | ((unint64_t)*(unsigned __int8 *)(a1 + v4) << 40);
                v8 = (unsigned __int8 *)(v3 + a1);
                result = v7 | ((unint64_t)v8[2] << 32) | ((unint64_t)v8[3] << 24) | ((unint64_t)v8[4] << 16) | ((unint64_t)v8[5] << 8) | v8[6];
                *a2 = v3 + 7;
              }
            }
            else
            {
              result = ((result & 3) << 40) | ((unint64_t)*(unsigned __int8 *)(a1 + v4) << 32) | ((unint64_t)*(unsigned __int8 *)(v3 + a1 + 2) << 24) | ((unint64_t)*(unsigned __int8 *)(v3 + a1 + 3) << 16) | ((unint64_t)*(unsigned __int8 *)(v3 + a1 + 4) << 8) | *(unsigned __int8 *)(v3 + a1 + 5);
              *a2 = v3 + 6;
            }
          }
          else
          {
            result = ((result & 7) << 32) | ((unint64_t)*(unsigned __int8 *)(a1 + v4) << 24) | ((unint64_t)*(unsigned __int8 *)(v3 + a1 + 2) << 16) | ((unint64_t)*(unsigned __int8 *)(v3 + a1 + 3) << 8) | *(unsigned __int8 *)(v3 + a1 + 4);
            *a2 = v3 + 5;
          }
        }
        else
        {
          result = ((result & 0xF) << 24) | ((unint64_t)*(unsigned __int8 *)(a1 + v4) << 16) | ((unint64_t)*(unsigned __int8 *)(v3 + a1 + 2) << 8) | *(unsigned __int8 *)(v3 + a1 + 3);
          *a2 = v3 + 4;
        }
      }
      else
      {
        result = ((result & 0x1F) << 16) | ((unint64_t)*(unsigned __int8 *)(a1 + v4) << 8) | *(unsigned __int8 *)(v3 + a1 + 2);
        *a2 = v3 + 3;
      }
    }
    else
    {
      result = *(unsigned __int8 *)(a1 + v4) | ((result & 0x3F) << 8);
      *a2 = v3 + 2;
    }
  }
  else
  {
    *a2 = v4;
  }
  return result;
}

uint64_t termPropertyID(unsigned __int8 *a1, unsigned int a2)
{
  uint64_t result;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  char *v9;
  char *v10;
  const char *v11;
  uint64_t v12;
  unsigned __int8 *v13;
  unsigned __int8 *v14;
  int v15;
  unsigned __int8 *v16;
  int v17;
  char *v19;
  unsigned int v20;
  int v21;
  char *v22;
  char *v23;
  const char *v24;

  if (a2 < 2)
    return 0;
  if (*a1 > 3u)
  {
    v13 = &a1[a2];
    v14 = v13 - 6;
    if (a2 < 6)
      v14 = a1 + 1;
    v15 = (char)*(v13 - 1);
    if (v15 < 0)
      return 0;
    v17 = *(v13 - 2);
    v16 = v13 - 2;
    if (v17 == 1 && v15 == 3)
      v19 = (char *)(v16 - 1);
    else
      v19 = (char *)v16;
    if (v19 <= (char *)v14)
    {
LABEL_27:
      if (*v19 != 1)
        return 0;
    }
    else
    {
      while (*v19 < 0)
      {
        if (--v19 <= (char *)v14)
        {
          v19 = (char *)v14;
          goto LABEL_27;
        }
      }
      if (*v19 != 1)
        return 0;
    }
    result = v19[1];
    if (v19[1] < 0)
    {
      v5 = v19[2];
      if (v19[2] < 0)
      {
        v6 = v19[3];
        if (v19[3] < 0)
        {
          v7 = v19[4];
          if (v19[4] < 0)
          {
            v8 = v19[5];
            if (v8 < 0)
            {
              v22 = __si_assert_copy_extra_1644(0);
              v23 = v22;
              v24 = "";
              if (v22)
                v24 = v22;
              __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t", "VIntUtils.h", 341, "(b4 & 0x80) == 0", v24);
              free(v23);
              if (__valid_fs(-1))
              {
                MEMORY[0xBAD] = -559038737;
                abort();
              }
              MEMORY[0xC00] = -559038737;
              abort();
            }
            goto LABEL_38;
          }
LABEL_36:
          v21 = ((v6 & 0x7F) << 14) | (v7 << 21);
LABEL_39:
          v20 = v21 & 0xFFFFC07F | ((v5 & 0x7F) << 7);
          return v20 & 0xFFFFFF80 | result & 0x7F;
        }
LABEL_34:
        v20 = ((v5 & 0x7F) << 7) | (v6 << 14);
        return v20 & 0xFFFFFF80 | result & 0x7F;
      }
      return result & 0x7F | (v5 << 7);
    }
  }
  else
  {
    v4 = (char)a1[1];
    result = a1[1];
    if (v4 < 0)
    {
      v5 = a1[2];
      if ((char)a1[2] < 0)
      {
        v6 = a1[3];
        if ((char)a1[3] < 0)
        {
          v7 = a1[4];
          if ((char)a1[4] < 0)
          {
            v8 = (char)a1[5];
            if (v8 < 0)
            {
              v9 = __si_assert_copy_extra_1644(0);
              v10 = v9;
              v11 = "";
              if (v9)
                v11 = v9;
              __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t", "VIntUtils.h", 341, "(b4 & 0x80) == 0", v11);
              free(v10);
              if (__valid_fs(-1))
                v12 = 2989;
              else
                v12 = 3072;
              *(_DWORD *)v12 = -559038737;
              abort();
            }
LABEL_38:
            v21 = ((v7 & 0x7F) << 21) | (v8 << 28) | ((v6 & 0x7F) << 14);
            goto LABEL_39;
          }
          goto LABEL_36;
        }
        goto LABEL_34;
      }
      return result & 0x7F | (v5 << 7);
    }
  }
  return result;
}

uint64_t __findTermIDsContextMatchPatternsRegExMatch()
{
  return icu_regex_find();
}

void findMatchTermExpansion(uint64_t a1, unsigned int a2, _BYTE *a3)
{
  uint64_t v5;
  _BYTE *v6;
  int v7;
  uint64_t v8;
  unint64_t Child;
  uint64_t v10;
  uint64_t v11;

  v5 = 0;
  v6 = a3 + 1;
  LOBYTE(v7) = *a3;
  v8 = *(_QWORD *)(a1 + 52);
  while (1)
  {
    Child = trieGetChild(*(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 52), v7);
    if (!(_DWORD)Child)
      break;
    *(_QWORD *)(a1 + 52) = Child;
    v10 = *(unsigned int *)(a1 + 1140);
    *(_DWORD *)(a1 + 1140) = v10 + 1;
    v11 = a1 + 88;
    *(_BYTE *)(v11 + v10) = v7;
    *(_BYTE *)(v11 + *(unsigned int *)(a1 + 1140)) = 0;
    if (!HIDWORD(Child))
    {
      LODWORD(v5) = v5 + 1;
      findAddFlatBucket(a1, Child, 0, 0, 0, 0);
      break;
    }
    v7 = v6[v5++];
    if (!v7)
    {
      *(_QWORD *)(a1 + 1224) += a2;
      findMatchTerm(a1, 0);
      *(_QWORD *)(a1 + 1224) -= a2;
      break;
    }
  }
  *(_DWORD *)(a1 + 1140) -= v5;
  *(_QWORD *)(a1 + 52) = v8;
}

void findMatchIgnoringDiacritics(uint64_t a1, uint64_t a2)
{
  unint64_t Child;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unsigned __int8 v11;
  unsigned int v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  char *v21;
  char *v22;
  const char *v23;
  _DWORD *v24;
  unsigned __int8 v25;
  unsigned int v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unsigned __int8 v37;
  unsigned int v38;
  unint64_t v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  unint64_t v49;
  char *v50;
  char *v51;
  const char *v52;

  Child = trieGetChild(*(_QWORD *)(a1 + 8), a2, 0xCCu);
  v5 = Child;
  if ((_DWORD)Child)
  {
    v6 = *(unsigned int *)(a1 + 1140);
    *(_DWORD *)(a1 + 1140) = v6 + 1;
    *(_BYTE *)(a1 + v6 + 88) = -52;
    switch(HIDWORD(Child))
    {
      case 3:
        if (*(_QWORD *)(a1 + 64) > (unint64_t)Child)
          goto LABEL_33;
        v21 = __si_assert_copy_extra_1644(*(_DWORD **)(*(_QWORD *)(a1 + 8) + 4568));
        v22 = v21;
        v23 = "";
        if (v21)
          v23 = v21;
        __message_assert("%s:%u: failed assertion '%s' %s next: %d, max: %d", "BurstTrie.c", 4608, "child.next < ctx->trie_fat_max", v23, v5, *(_QWORD *)(a1 + 64));
        free(v22);
        v24 = *(_DWORD **)(*(_QWORD *)(a1 + 8) + 4568);
        break;
      case 1:
        if (*(_QWORD *)(a1 + 72) > (unint64_t)Child)
          goto LABEL_33;
        v50 = __si_assert_copy_extra_1644(*(_DWORD **)(*(_QWORD *)(a1 + 8) + 112));
        v51 = v50;
        v52 = "";
        if (v50)
          v52 = v50;
        __message_assert("%s:%u: failed assertion '%s' %s next: %d, max: %d", "BurstTrie.c", 4610, "child.next < ctx->trie_max", v52, v5, *(_QWORD *)(a1 + 64));
        free(v51);
        v24 = *(_DWORD **)(*(_QWORD *)(a1 + 8) + 112);
        break;
      case 0:
        findAddFlatBucket(a1, Child, 0, 0, 0, 0);
LABEL_6:
        --*(_DWORD *)(a1 + 1140);
        goto LABEL_7;
      default:
LABEL_33:
        v25 = 0x80;
        do
        {
          v26 = v25;
          v27 = trieGetChild(*(_QWORD *)(a1 + 8), v5, v25);
          if ((_DWORD)v27)
          {
            v28 = *(unsigned int *)(a1 + 1140);
            *(_DWORD *)(a1 + 1140) = v28 + 1;
            *(_BYTE *)(a1 + v28 + 88) = v25;
            if (HIDWORD(v27))
            {
              *(_QWORD *)(a1 + 52) = v27;
              findMatchTerm(a1, 0);
              *(_QWORD *)(a1 + 52) = a2;
            }
            else
            {
              findAddFlatBucket(a1, v27, 0, 0, 0, 0);
            }
            --*(_DWORD *)(a1 + 1140);
          }
          ++v25;
        }
        while (v26 < 0xBF);
        goto LABEL_6;
    }
    if (__valid_fsp(v24))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
LABEL_7:
  v7 = trieGetChild(*(_QWORD *)(a1 + 8), a2, 0xCDu);
  if ((_DWORD)v7)
  {
    v8 = v7;
    v9 = *(unsigned int *)(a1 + 1140);
    *(_DWORD *)(a1 + 1140) = v9 + 1;
    *(_BYTE *)(a1 + v9 + 88) = -51;
    if (HIDWORD(v7))
    {
      v11 = 0x80;
      do
      {
        v12 = v11;
        v13 = trieGetChild(*(_QWORD *)(a1 + 8), v8, v11);
        if ((_DWORD)v13)
        {
          v14 = *(unsigned int *)(a1 + 1140);
          *(_DWORD *)(a1 + 1140) = v14 + 1;
          *(_BYTE *)(a1 + v14 + 88) = v11;
          if (HIDWORD(v13))
          {
            *(_QWORD *)(a1 + 52) = v13;
            findMatchTerm(a1, 0);
            *(_QWORD *)(a1 + 52) = a2;
          }
          else
          {
            findAddFlatBucket(a1, v13, 0, 0, 0, 0);
          }
          --*(_DWORD *)(a1 + 1140);
        }
        ++v11;
      }
      while (v12 < 0xDF);
    }
    else
    {
      findAddFlatBucket(a1, v7, 0, 0, 0, 0);
    }
    --*(_DWORD *)(a1 + 1140);
  }
  v10 = trieGetChild(*(_QWORD *)(a1 + 8), a2, 0x2Du);
  if ((_DWORD)v10)
  {
    if (HIDWORD(v10))
    {
      v15 = *(unsigned int *)(a1 + 1140);
      *(_DWORD *)(a1 + 1140) = v15 + 1;
      *(_BYTE *)(a1 + v15 + 88) = 45;
      findMatchTerm(a1, 0);
      --*(_DWORD *)(a1 + 1140);
    }
    else
    {
      findAddFlatBucket(a1, v10, 0, 0, 0, 0);
    }
  }
  v16 = trieGetChild(*(_QWORD *)(a1 + 8), a2, 0xE2u);
  if ((_DWORD)v16)
  {
    v17 = *(unsigned int *)(a1 + 1140);
    *(_DWORD *)(a1 + 1140) = v17 + 1;
    *(_BYTE *)(a1 + v17 + 88) = -30;
    if (HIDWORD(v16))
    {
      v19 = trieGetChild(*(_QWORD *)(a1 + 8), v16, 0x80u);
      v18 = *(unsigned int *)(a1 + 1140);
      if ((_DWORD)v19)
      {
        *(_DWORD *)(a1 + 1140) = v18 + 1;
        *(_BYTE *)(a1 + v18 + 88) = 0x80;
        if (HIDWORD(v19))
        {
          v29 = trieGetChild(*(_QWORD *)(a1 + 8), v19, 0x90u);
          v20 = *(unsigned int *)(a1 + 1140);
          if ((_DWORD)v29)
          {
            *(_DWORD *)(a1 + 1140) = v20 + 1;
            *(_BYTE *)(a1 + v20 + 88) = -112;
            if (HIDWORD(v29))
            {
              *(_QWORD *)(a1 + 52) = v29;
              findMatchTerm(a1, 0);
              *(_QWORD *)(a1 + 52) = a2;
            }
            else
            {
              findAddFlatBucket(a1, v29, 0, 0, 0, 0);
            }
            LODWORD(v20) = *(_DWORD *)(a1 + 1140) - 1;
          }
        }
        else
        {
          findAddFlatBucket(a1, v19, 0, 0, 0, 0);
          LODWORD(v20) = *(_DWORD *)(a1 + 1140);
        }
        LODWORD(v18) = v20 - 1;
      }
    }
    else
    {
      findAddFlatBucket(a1, v16, 0, 0, 0, 0);
      LODWORD(v18) = *(_DWORD *)(a1 + 1140);
    }
    *(_DWORD *)(a1 + 1140) = v18 - 1;
  }
  v30 = trieGetChild(*(_QWORD *)(a1 + 8), a2, 0xD6u);
  if ((_DWORD)v30)
  {
    v31 = v30;
    v32 = *(unsigned int *)(a1 + 1140);
    *(_DWORD *)(a1 + 1140) = v32 + 1;
    *(_BYTE *)(a1 + v32 + 88) = -42;
    if (HIDWORD(v30))
    {
      v37 = -111;
      do
      {
        v38 = v37;
        v39 = trieGetChild(*(_QWORD *)(a1 + 8), v31, v37);
        if ((_DWORD)v39)
        {
          v40 = *(unsigned int *)(a1 + 1140);
          *(_DWORD *)(a1 + 1140) = v40 + 1;
          *(_BYTE *)(a1 + v40 + 88) = v37;
          if (HIDWORD(v39))
          {
            *(_QWORD *)(a1 + 52) = v39;
            findMatchTerm(a1, 0);
            *(_QWORD *)(a1 + 52) = a2;
          }
          else
          {
            findAddFlatBucket(a1, v39, 0, 0, 0, 0);
          }
          --*(_DWORD *)(a1 + 1140);
        }
        ++v37;
      }
      while (v38 < 0xBF);
    }
    else
    {
      findAddFlatBucket(a1, v30, 0, 0, 0, 0);
    }
    --*(_DWORD *)(a1 + 1140);
  }
  v33 = trieGetChild(*(_QWORD *)(a1 + 8), a2, 0xD7u);
  if ((_DWORD)v33)
  {
    v34 = v33;
    v35 = *(unsigned int *)(a1 + 1140);
    *(_DWORD *)(a1 + 1140) = v35 + 1;
    *(_BYTE *)(a1 + v35 + 88) = -41;
    if (HIDWORD(v33))
    {
      v41 = trieGetChild(*(_QWORD *)(a1 + 8), v33, 0x80u);
      if ((_DWORD)v41)
      {
        v42 = *(unsigned int *)(a1 + 1140);
        *(_DWORD *)(a1 + 1140) = v42 + 1;
        *(_BYTE *)(a1 + v42 + 88) = 0x80;
        if (HIDWORD(v41))
        {
          *(_QWORD *)(a1 + 52) = v41;
          findMatchTerm(a1, 0);
          *(_QWORD *)(a1 + 52) = a2;
        }
        else
        {
          findAddFlatBucket(a1, v41, 0, 0, 0, 0);
        }
        --*(_DWORD *)(a1 + 1140);
      }
      v43 = trieGetChild(*(_QWORD *)(a1 + 8), v34, 0x81u);
      if ((_DWORD)v43)
      {
        v44 = *(unsigned int *)(a1 + 1140);
        *(_DWORD *)(a1 + 1140) = v44 + 1;
        *(_BYTE *)(a1 + v44 + 88) = -127;
        if (HIDWORD(v43))
        {
          *(_QWORD *)(a1 + 52) = v43;
          findMatchTerm(a1, 0);
          *(_QWORD *)(a1 + 52) = a2;
        }
        else
        {
          findAddFlatBucket(a1, v43, 0, 0, 0, 0);
        }
        --*(_DWORD *)(a1 + 1140);
      }
      v45 = trieGetChild(*(_QWORD *)(a1 + 8), v34, 0x82u);
      if ((_DWORD)v45)
      {
        v46 = *(unsigned int *)(a1 + 1140);
        *(_DWORD *)(a1 + 1140) = v46 + 1;
        *(_BYTE *)(a1 + v46 + 88) = -126;
        if (HIDWORD(v45))
        {
          *(_QWORD *)(a1 + 52) = v45;
          findMatchTerm(a1, 0);
          *(_QWORD *)(a1 + 52) = a2;
        }
        else
        {
          findAddFlatBucket(a1, v45, 0, 0, 0, 0);
        }
        --*(_DWORD *)(a1 + 1140);
      }
      v47 = trieGetChild(*(_QWORD *)(a1 + 8), v34, 0x83u);
      if ((_DWORD)v47)
      {
        v48 = *(unsigned int *)(a1 + 1140);
        *(_DWORD *)(a1 + 1140) = v48 + 1;
        *(_BYTE *)(a1 + v48 + 88) = -125;
        if (HIDWORD(v47))
        {
          *(_QWORD *)(a1 + 52) = v47;
          findMatchTerm(a1, 0);
          *(_QWORD *)(a1 + 52) = a2;
        }
        else
        {
          findAddFlatBucket(a1, v47, 0, 0, 0, 0);
        }
        --*(_DWORD *)(a1 + 1140);
      }
      v49 = trieGetChild(*(_QWORD *)(a1 + 8), v34, 0x84u);
      v36 = *(unsigned int *)(a1 + 1140);
      if ((_DWORD)v49)
      {
        *(_DWORD *)(a1 + 1140) = v36 + 1;
        *(_BYTE *)(a1 + v36 + 88) = -124;
        if (HIDWORD(v49))
        {
          *(_QWORD *)(a1 + 52) = v49;
          findMatchTerm(a1, 0);
          *(_QWORD *)(a1 + 52) = a2;
        }
        else
        {
          findAddFlatBucket(a1, v49, 0, 0, 0, 0);
        }
        LODWORD(v36) = *(_DWORD *)(a1 + 1140) - 1;
      }
    }
    else
    {
      findAddFlatBucket(a1, v33, 0, 0, 0, 0);
      LODWORD(v36) = *(_DWORD *)(a1 + 1140);
    }
    *(_DWORD *)(a1 + 1140) = v36 - 1;
  }
}

void findMatchTermChar(uint64_t a1, uint64_t a2, unsigned int a3)
{
  char v3;
  unint64_t Child;
  uint64_t v7;
  uint64_t v8;

  v3 = a3;
  Child = trieGetChild(*(_QWORD *)(a1 + 8), a2, a3);
  if ((_DWORD)Child)
  {
    v7 = *(unsigned int *)(a1 + 1140);
    *(_DWORD *)(a1 + 1140) = v7 + 1;
    v8 = a1 + 88;
    *(_BYTE *)(v8 + v7) = v3;
    *(_BYTE *)(v8 + *(unsigned int *)(a1 + 1140)) = 0;
    ++*(_QWORD *)(a1 + 1224);
    if (HIDWORD(Child))
    {
      *(_QWORD *)(a1 + 52) = Child;
      findMatchTerm(a1, 0);
      *(_QWORD *)(a1 + 52) = a2;
    }
    else
    {
      findAddFlatBucket(a1, Child, 0, 0, 0, 0);
    }
    --*(_QWORD *)(a1 + 1224);
    --*(_DWORD *)(a1 + 1140);
  }
}

void oqpush(uint64_t a1, uint64_t a2, size_t size)
{
  uint64_t v5;
  char *v6;
  char *v7;
  const char *v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  size_t v13;
  void *v14;
  uint64_t v15;
  char *v16;
  const char *v17;
  char *v18;
  uint8_t buf[16];

  if (*(_BYTE *)a1)
  {
    v16 = __si_assert_copy_extra_1644(0);
    v7 = v16;
    v17 = "";
    if (v16)
      v17 = v16;
    __message_assert("%s:%u: failed assertion '%s' %s ", "OQueue.h", 327, "!oqueue->has_meta", v17);
LABEL_26:
    free(v7);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  if (!*(_DWORD *)(a1 + 56))
  {
    v10 = *(_QWORD *)(a1 + 24);
    v5 = *(_QWORD *)(a1 + 32);
    if (v5 < v10)
      goto LABEL_18;
    v11 = 2 * v10;
    if (!v10)
      v11 = 4;
    *(_QWORD *)(a1 + 24) = v11;
    v12 = *(void **)(a1 + 16);
    v13 = 8 * v11;
    if (v12)
    {
      v14 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, v12, v13, 0xECA6AA46uLL);
      if (!v14)
      {
LABEL_15:
        if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_fault_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "allocation function returned null", buf, 2u);
        }
      }
    }
    else
    {
      v14 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v13, 0x8DDAA030uLL);
      if (!v14)
        goto LABEL_15;
    }
    *(_QWORD *)(a1 + 16) = v14;
    v5 = *(_QWORD *)(a1 + 32);
    goto LABEL_18;
  }
  if (*(_QWORD *)(a1 + 64) < (a2 & 0x3FFFFFFFFFFFFFFFuLL))
  {
    v18 = __si_assert_copy_extra_1644(0);
    v7 = v18;
    v8 = "";
    if (v18)
      v8 = v18;
    v9 = "!queue->split || queue->splitPoint >= offset_t_GET_VALUE(value)";
    goto LABEL_25;
  }
  v5 = *(_QWORD *)(a1 + 32);
  if (v5 >= *(_QWORD *)(a1 + 24))
  {
    v6 = __si_assert_copy_extra_1644(0);
    v7 = v6;
    v8 = "";
    if (v6)
      v8 = v6;
    v9 = "!queue->split";
LABEL_25:
    __message_assert("%s:%u: failed assertion '%s' %s ", "OQueue.h", 247, v9, v8);
    goto LABEL_26;
  }
LABEL_18:
  v15 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 32) = v5 + 1;
  *(_QWORD *)(v15 + 8 * v5) = a2;
}

unint64_t trieGetRawChild(uint64_t a1, uint64_t a2, unsigned int a3)
{
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  int8x8_t *v7;
  unsigned int v8;
  uint8x8_t v9;
  uint8x8_t v10;
  uint8x8_t v11;
  uint8x8_t v12;
  uint64_t v13;
  unsigned int v14;
  unint64_t v15;
  BOOL v16;
  unint64_t v17;

  if (HIDWORD(a2) == 1)
  {
    v5 = mgetBase(a1, a2);
    if (((*(_DWORD *)(v5 + 4 * (a3 >> 5) + 4) >> a3) & 1) == 0)
      return 0;
    v6 = 0;
    v7 = (int8x8_t *)(v5 + 4);
    v8 = a3 >> 6;
    if (a3 >> 6 != 1)
    {
      if (v8 != 2)
      {
        if (v8 != 3)
        {
LABEL_11:
          v12 = (uint8x8_t)vcnt_s8((int8x8_t)(*(_QWORD *)&v7[v8] & ~(-1 << a3)));
          v12.i16[0] = vaddlv_u8(v12);
          v4 = *(_DWORD *)(v5 + 4 * (v12.u32[0] + v6) + 38);
          goto LABEL_12;
        }
        v9 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v5 + 20));
        v9.i16[0] = vaddlv_u8(v9);
        v6 = v9.u32[0];
      }
      v10 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v5 + 12));
      v10.i16[0] = vaddlv_u8(v10);
      v6 += v10.u32[0];
    }
    v11 = (uint8x8_t)vcnt_s8(*v7);
    v11.i16[0] = vaddlv_u8(v11);
    v6 += v11.u32[0];
    goto LABEL_11;
  }
  if (HIDWORD(a2) != 3)
    return 0;
  v4 = *(_DWORD *)(*(_QWORD *)(a1 + 8) + 1028 * a2 + 4 * a3 + 4);
LABEL_12:
  LODWORD(v13) = v4 >> 1;
  v14 = v4 >> 3;
  v15 = (unint64_t)(v4 & 7) << 32;
  if ((v4 & 3) == 1)
  {
    v15 = 0x100000000;
    v14 = v4 >> 2;
  }
  v16 = (v4 & 1) == 0;
  if ((v4 & 1) != 0)
    v17 = v15;
  else
    v17 = 0;
  if (v16)
    v13 = v13;
  else
    v13 = v14;
  return v17 | v13;
}

unsigned __int8 *localizedFieldTermMatch(uint64_t a1, int a2, unsigned __int8 *a3, int a4, int a5)
{
  unsigned __int8 *result;

  result = termFieldMatch(a2, a3, a4, a5);
  if (result)
    return (unsigned __int8 *)icu_search_match();
  return result;
}

BOOL termMatch(unsigned __int8 *a1, unsigned int a2, unsigned __int8 *a3, unsigned __int8 a4)
{
  unsigned __int8 *v5;
  unsigned __int8 *v6;
  unsigned int v7;
  unsigned __int8 *v8;
  int v9;
  _BOOL8 result;
  int v11;
  int v12;
  int v13;

  v5 = a3;
  v6 = a1;
  v7 = *a3;
  if (v7 > 4)
  {
    if (v7 != 42 || termPropertyID(a1, a2) != 2)
      return matche(v5, v6, a4, 0, 0) == 1;
    return 0;
  }
  if (v7 != *a1)
    return 0;
  v8 = a3 + 1;
  v9 = a3[1];
  if (v9 != a1[1])
    return 0;
  if (v9 != 2)
  {
    v6 = a1 + 2;
    v5 = a3 + 2;
    if ((v9 & 0x80) != 0)
      goto LABEL_12;
    return matche(v5, v6, a4, 0, 0) == 1;
  }
  if (a3[2] != a1[2])
    return 0;
  v6 = a1 + 3;
  v8 = a3 + 2;
  v5 = a3 + 3;
  if ((a3[2] & 0x80) == 0)
    return matche(v5, v6, a4, 0, 0) == 1;
LABEL_12:
  v11 = *v5;
  if (v11 != *v6)
    return 0;
  v5 = v8 + 2;
  if (((char)v11 & 0x80000000) == 0)
    return matche(v5, ++v6, a4, 0, 0) == 1;
  v12 = *v5;
  if (v12 != v6[1])
    return 0;
  if (((char)v12 & 0x80000000) == 0)
  {
    v6 += 2;
    v5 = v8 + 3;
    return matche(v5, v6, a4, 0, 0) == 1;
  }
  result = 0;
  v13 = (char)v8[3];
  if ((v13 & 0x80000000) == 0 && v6[2] == v13)
  {
    v6 += 3;
    v5 = v8 + 4;
    return matche(v5, v6, a4, 0, 0) == 1;
  }
  return result;
}

uint64_t termNumberCompare(_BYTE *a1, unsigned __int8 *a2)
{
  unsigned int v2;
  _BOOL4 v3;
  unsigned int v4;
  BOOL v5;
  unsigned __int8 *v6;
  unsigned __int8 *v7;
  unsigned int v8;
  unsigned int v9;
  BOOL v10;
  unsigned int v11;
  unsigned int v12;

  v2 = *a1;
  v3 = *a1 == 0;
  v4 = *a2;
  if (*a1)
    v5 = v2 == v4;
  else
    v5 = 0;
  if (v5)
  {
    v6 = a2 + 1;
    v7 = a1 + 1;
    do
    {
      v8 = *v7++;
      v2 = v8;
      v3 = v8 == 0;
      v9 = *v6++;
      v4 = v9;
      if (v2)
        v10 = v2 == v4;
      else
        v10 = 0;
    }
    while (v10);
  }
  if (v4)
    v11 = -1;
  else
    v11 = 0;
  if (v2 < v4)
    v12 = -1;
  else
    v12 = 1;
  if (v3)
    return v11;
  else
    return v12;
}

void _findMatchTermWildcard(uint64_t a1, uint64_t a2, uint64_t a3, char a4, int a5)
{
  uint64_t v6;
  uint64_t v7;
  char *v9;
  char *v10;
  const char *v11;

  v6 = *(unsigned int *)(a1 + 1140);
  if (v6 >= 0x414)
  {
    v9 = __si_assert_copy_extra_1644(*(_DWORD **)(*(_QWORD *)(a1 + 8) + 4568));
    v10 = v9;
    v11 = "";
    if (v9)
      v11 = v9;
    __message_assert("%s:%u: failed assertion '%s' %s max depth exceeded: %d", "BurstTrie.c", 4493, "ctx->stringLen<CI_UTF8CHARS_BUFFER_SIZE", v11, *(_DWORD *)(a1 + 1140));
    free(v10);
    if (__valid_fsp(*(_DWORD **)(*(_QWORD *)(a1 + 8) + 4568)))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  *(_DWORD *)(a1 + 1140) = v6 + 1;
  v7 = a1 + 88;
  *(_BYTE *)(v7 + v6) = a4;
  *(_BYTE *)(v7 + *(unsigned int *)(a1 + 1140)) = 0;
  if (HIDWORD(a3))
  {
    *(_QWORD *)(a1 + 52) = a3;
    if (a5)
      findMatchTermWildcard(a1, *(_QWORD *)(a1 + 52), 0, 1);
    else
      findMatchTerm(a1, 0);
    *(_QWORD *)(a1 + 52) = a2;
  }
  else
  {
    findAddFlatBucket(a1, a3, 0, 0, 0, 0);
  }
  --*(_DWORD *)(a1 + 1140);
}

void _findMatchRangeChars(uint64_t a1, uint64_t a2, unsigned __int8 a3)
{
  uint64_t v5;
  uint64_t v6;
  unsigned __int8 *v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  unsigned int *v17;
  unint64_t v18;
  uint64_t v19;
  unsigned int v20;
  int v21;
  unsigned __int8 **v22;
  int v23;
  unsigned __int8 *v24;
  int v25;
  _BOOL4 v26;
  int v27;
  BOOL v28;
  unsigned int v29;
  unsigned int v30;
  BOOL v31;
  unsigned __int8 *v32;
  unsigned __int8 *v33;
  unsigned int v34;
  unsigned int v35;
  BOOL v36;
  unsigned int v37;
  _BOOL4 v38;
  unsigned __int8 *v39;
  unsigned __int8 *v40;
  unsigned int v41;
  unsigned int v42;
  BOOL v43;
  BOOL v44;
  unsigned __int8 *v45;
  unsigned int v46;
  BOOL v47;
  char v48;
  unsigned int v49;
  unsigned __int8 *v50;
  unsigned __int8 *v51;
  unsigned int v52;
  unsigned int v53;
  BOOL v54;
  int v55;
  int v56;
  int v57;
  unsigned __int8 *v58;
  unsigned __int8 *v59;
  unsigned int v60;
  unsigned int v61;
  BOOL v62;
  uint64_t v63;
  uint64_t v64;
  unsigned int v65;
  unint64_t v66;
  BOOL v67;
  unint64_t v68;
  uint64_t v69;
  unsigned __int8 *v70;
  int v71;
  uint64_t v72;
  int v73;
  int v74;
  unsigned int v75;
  uint64_t v76;
  uint64_t v77;
  unsigned __int8 *v78;
  char v79;
  char *v80;
  char *v81;
  const char *v82;
  _DWORD *v83;
  char *v84;
  char *v85;
  const char *v86;
  uint64_t v87;
  int v88;
  int v89;
  int v90;
  int v91;
  int v92;
  unsigned int v93;
  int v94;
  int v95;
  int v96;
  unsigned int v97;
  int v98;
  int v99;
  int v100;
  int v101;
  char *v102;
  char *v103;
  const char *v104;

  v5 = 0;
  v6 = *(unsigned int *)(a1 + 1140);
  *(_DWORD *)(a1 + 1140) = v6 + 1;
  v7 = (unsigned __int8 *)(a1 + 88);
  v7[v6] = a3;
  v7[*(unsigned int *)(a1 + 1140)] = 0;
  v8 = *(uint64_t **)(a1 + 1240);
  v10 = *v8;
  v9 = v8[1];
  do
  {
    v11 = *(unsigned __int8 *)(a1 + v5 + 88);
    if (!*(_BYTE *)(a1 + v5 + 88))
      break;
    v12 = *(unsigned __int8 *)(v10 + v5);
    if (!*(_BYTE *)(v10 + v5))
      break;
    if (v11 < v12)
      goto LABEL_95;
    ++v5;
  }
  while (v11 <= v12);
  v13 = 0;
  do
  {
    v14 = *(unsigned __int8 *)(a1 + v13 + 88);
    if (!*(_BYTE *)(a1 + v13 + 88))
      break;
    v15 = *(unsigned __int8 *)(v9 + v13);
    if (v14 > v15)
      goto LABEL_95;
    ++v13;
  }
  while (v14 >= v15);
  if (HIDWORD(a2) == 3)
  {
    v16 = *(_QWORD *)(a1 + 8);
    if ((unint64_t)a2 < *(_QWORD *)(a1 + 64))
    {
      v17 = (unsigned int *)(*(_QWORD *)(v16 + 8) + 1028 * a2);
      goto LABEL_18;
    }
    v80 = __si_assert_copy_extra_1644(*(_DWORD **)(v16 + 4568));
    v81 = v80;
    v82 = "";
    if (v80)
      v82 = v80;
    __message_assert("%s:%u: failed assertion '%s' %s next: %d, max: %d", "BurstTrie.c", 6103, "child.next < ctx->trie_fat_max", v82, a2, *(_QWORD *)(a1 + 64));
    free(v81);
    v83 = *(_DWORD **)(*(_QWORD *)(a1 + 8) + 4568);
LABEL_138:
    if (!__valid_fsp(v83))
    {
LABEL_169:
      v87 = 3072;
LABEL_170:
      *(_DWORD *)v87 = -559038737;
      abort();
    }
LABEL_139:
    v87 = 2989;
    goto LABEL_170;
  }
  if (HIDWORD(a2) == 1)
  {
    v18 = *(_QWORD *)(a1 + 72);
    v19 = *(_QWORD *)(a1 + 8);
    if (a2 < v18)
    {
      v17 = (unsigned int *)mgetBase(v19, a2);
LABEL_18:
      v20 = *v17;
      if (*(_DWORD *)(a1 + 48) != 1)
      {
        if (!v20)
          goto LABEL_94;
        v21 = 0;
LABEL_29:
        v22 = *(unsigned __int8 ***)(a1 + 1240);
        v23 = *((_DWORD *)v22 + 4);
        v24 = *v22;
        v25 = *(unsigned __int8 *)(a1 + 88);
        v26 = *(_BYTE *)(a1 + 88) == 0;
        v27 = **v22;
        v28 = v25 != v27 || *(_BYTE *)(a1 + 88) == 0;
        v29 = *(unsigned __int8 *)(a1 + 88);
        if ((v23 & 0x20) != 0)
        {
          v37 = *v24;
          v38 = *(_BYTE *)(a1 + 88) == 0;
          if (!v28)
          {
            v39 = v24 + 1;
            v40 = (unsigned __int8 *)(a1 + 89);
            do
            {
              v41 = *v40++;
              v29 = v41;
              v38 = v41 == 0;
              v42 = *v39++;
              v37 = v42;
              if (v29)
                v43 = v29 == v37;
              else
                v43 = 0;
            }
            while (v43);
          }
          v44 = v29 < v37;
          if (v38)
            v44 = v37 != 0;
          if (v44)
            goto LABEL_94;
        }
        else
        {
          v30 = *v24;
          v31 = *(_BYTE *)(a1 + 88) == 0;
          if (!v28)
          {
            v32 = v24 + 1;
            v33 = (unsigned __int8 *)(a1 + 89);
            do
            {
              v34 = *v33++;
              v29 = v34;
              v31 = v34 == 0;
              v35 = *v32++;
              v30 = v35;
              if (v29)
                v36 = v29 == v30;
              else
                v36 = 0;
            }
            while (v36);
          }
          if (v31 || v29 < v30)
            goto LABEL_94;
        }
        v45 = v22[1];
        v46 = *v45;
        if (*(_BYTE *)(a1 + 88))
          v47 = v25 == v46;
        else
          v47 = 0;
        v48 = !v47;
        v49 = *(unsigned __int8 *)(a1 + 88);
        if ((v23 & 0x40) != 0)
        {
          if ((v48 & 1) == 0)
          {
            v58 = v45 + 1;
            v59 = (unsigned __int8 *)(a1 + 89);
            do
            {
              v60 = *v59++;
              v49 = v60;
              LOBYTE(v26) = v60 == 0;
              v61 = *v58++;
              v46 = v61;
              if (v49)
                v62 = v49 == v46;
              else
                v62 = 0;
            }
            while (v62);
          }
          if (v49 >= v46 && !v26)
            goto LABEL_94;
        }
        else
        {
          if ((v48 & 1) == 0)
          {
            v50 = v45 + 1;
            v51 = (unsigned __int8 *)(a1 + 89);
            do
            {
              v52 = *v51++;
              v49 = v52;
              v26 = v52 == 0;
              v53 = *v50++;
              v46 = v53;
              if (v49)
                v54 = v49 == v46;
              else
                v54 = 0;
            }
            while (v54);
          }
          if (v46)
            v55 = -1;
          else
            v55 = 0;
          v56 = (v49 < v46) << 31;
          if (v26)
            v57 = v55;
          else
            v57 = v56;
          if ((v57 & 0x80000000) == 0)
            goto LABEL_94;
        }
        v63 = v20;
        if (v21)
        {
          LODWORD(v64) = v20 >> 1;
          v65 = v20 >> 3;
          v66 = (unint64_t)(v20 & 7) << 32;
          if ((v20 & 3) == 1)
          {
            v66 = 0x100000000;
            v65 = v20 >> 2;
          }
          v67 = (v20 & 1) == 0;
          if ((v20 & 1) != 0)
            v68 = v66;
          else
            v68 = 0;
          if (v67)
            v64 = v64;
          else
            v64 = v65;
          findAddFlatBucket(a1, v68 | v64, 0, 0, 0, 0);
          goto LABEL_94;
        }
        if ((v23 & 0x610) != 0 || **(_BYTE **)a1)
        {
LABEL_94:
          findMatchRangeChars(a1, a2);
          goto LABEL_95;
        }
        if ((v23 & 4) != 0)
        {
          if ((v25 - 2) > 2 || v25 != v27)
            goto LABEL_94;
          v73 = termNumberCompare(v7, *v22);
          if ((v23 & 0x20) != 0)
          {
            if (v73 < 0)
              goto LABEL_94;
          }
          else if (v73 < 1)
          {
            goto LABEL_94;
          }
          v74 = termNumberCompare(v7, v45);
          if ((v23 & 0x40) != 0)
          {
            if (v74 > 0)
              goto LABEL_94;
          }
          else if ((v74 & 0x80000000) == 0)
          {
            goto LABEL_94;
          }
        }
        else if ((v23 & 0x8000) != 0 || v27 != 42 || v24[1])
        {
          v69 = (uint64_t)v22[4];
          v70 = v22[5];
          if (v69)
          {
            if (v70)
              goto LABEL_102;
            if (!localizedFieldTermMatch(v69, *((_DWORD *)v22 + 5), v7, *(_DWORD *)(a1 + 1140), *((_DWORD *)v22 + 4)))goto LABEL_94;
LABEL_122:
            v75 = *(_DWORD *)(a1 + 1140);
            v76 = a1;
            v77 = v63;
            v78 = v7;
            v79 = 1;
LABEL_129:
            findHandleMatch(v76, v77, 0, v78, v75, v79);
            goto LABEL_94;
          }
          if (v70)
          {
LABEL_102:
            if (v25 != 1)
            {
              v71 = termPropertyID(v7, *(_DWORD *)(a1 + 1140));
              v72 = 0;
              goto LABEL_154;
            }
            v71 = *(unsigned __int8 *)(a1 + 89);
            if (v71 == 2)
            {
              v71 = *(unsigned __int8 *)(a1 + 90);
              if ((*(char *)(a1 + 90) & 0x80000000) == 0)
              {
                v72 = 3;
                goto LABEL_154;
              }
              v88 = *(unsigned __int8 *)(a1 + 91);
              if ((*(char *)(a1 + 91) & 0x80000000) == 0)
              {
                v71 = v71 & 0x7F | (v88 << 7);
                v72 = 4;
                goto LABEL_154;
              }
              v90 = *(unsigned __int8 *)(a1 + 92);
              if ((*(char *)(a1 + 92) & 0x80000000) == 0)
              {
                v91 = ((v88 & 0x7F) << 7) | (v90 << 14);
LABEL_152:
                v93 = v91 & 0xFFFFFF80 | v71 & 0x7F;
                v72 = 5;
                goto LABEL_153;
              }
              v94 = *(unsigned __int8 *)(a1 + 93);
              if ((*(char *)(a1 + 93) & 0x80000000) == 0)
              {
                v93 = ((v90 & 0x7F) << 14) | (v94 << 21) | ((v88 & 0x7F) << 7) | v71 & 0x7F;
                v72 = 6;
                goto LABEL_153;
              }
              v98 = *(char *)(a1 + 94);
              if ((v98 & 0x80000000) == 0)
              {
                v99 = ((v94 & 0x7F) << 21) | (v98 << 28) | ((v90 & 0x7F) << 14) | ((v88 & 0x7F) << 7) | v71 & 0x7F;
                v72 = 7;
                v71 = v99;
                goto LABEL_154;
              }
            }
            else
            {
              if ((v71 & 0x80) == 0)
              {
                v72 = 2;
                goto LABEL_154;
              }
              v89 = *(unsigned __int8 *)(a1 + 90);
              if ((*(char *)(a1 + 90) & 0x80000000) == 0)
              {
                v71 = v71 & 0x7F | (v89 << 7);
                v72 = 3;
                goto LABEL_154;
              }
              v92 = *(unsigned __int8 *)(a1 + 91);
              if ((*(char *)(a1 + 91) & 0x80000000) == 0)
              {
                v93 = ((v89 & 0x7F) << 7) | (v92 << 14) | v71 & 0x7F;
                v72 = 4;
LABEL_153:
                v71 = v93;
                goto LABEL_154;
              }
              v95 = *(unsigned __int8 *)(a1 + 92);
              if ((*(char *)(a1 + 92) & 0x80000000) == 0)
              {
                v91 = ((v92 & 0x7F) << 14) | (v95 << 21) | ((v89 & 0x7F) << 7);
                goto LABEL_152;
              }
              v100 = *(char *)(a1 + 93);
              if ((v100 & 0x80000000) == 0)
              {
                v101 = ((v95 & 0x7F) << 21) | (v100 << 28) | ((v92 & 0x7F) << 14) | ((v89 & 0x7F) << 7) | v71 & 0x7F;
                v72 = 6;
                v71 = v101;
LABEL_154:
                if (*((_DWORD *)v22 + 5) == v71)
                {
                  v96 = *(_DWORD *)(a1 + 1140) - v72;
                  while (v96 >= 1)
                  {
                    v97 = *(unsigned __int8 *)(a1 + v72 - 1 + v96 + 88);
                    if (v97 > 5)
                    {
                      if (!__findTermIDsContextMatchPatternsRegExMatch())
                        goto LABEL_94;
                      goto LABEL_122;
                    }
                    --v96;
                    if ((v97 & 0xFFFFFFFD) != 1)
                      goto LABEL_94;
                  }
                }
                goto LABEL_94;
              }
            }
            v102 = __si_assert_copy_extra_1644(0);
            v103 = v102;
            v104 = "";
            if (v102)
              v104 = v102;
            __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t", "VIntUtils.h", 341, "(b4 & 0x80) == 0", v104);
            free(v103);
            if (!__valid_fs(-1))
              goto LABEL_169;
            goto LABEL_139;
          }
          if (*((_DWORD *)v22 + 5) == 1)
          {
            if (termPropertyID(v7, *(_DWORD *)(a1 + 1140)) != 1)
              goto LABEL_94;
            v24 = *v22;
          }
          if (!termMatch(v7, *(_DWORD *)(a1 + 1140), v24, *((_DWORD *)v22 + 6)))
            goto LABEL_94;
        }
        else if (!termFieldMatch(*((_DWORD *)v22 + 5), v7, *(_DWORD *)(a1 + 1140), *((_DWORD *)v22 + 4)))
        {
          goto LABEL_94;
        }
        if ((v23 & 0x8000) != 0)
          goto LABEL_94;
        v75 = *(_DWORD *)(a1 + 1140);
        v76 = a1;
        v77 = v63;
        v78 = v7;
        v79 = 0;
        goto LABEL_129;
      }
      if ((v20 & 1) != 0)
      {
        if ((*v17 & 3) == 1)
        {
          if (!(v20 >> 2))
            goto LABEL_94;
        }
        else if (!(v20 >> 3))
        {
          goto LABEL_94;
        }
LABEL_26:
        v21 = 1;
        goto LABEL_29;
      }
LABEL_25:
      if (!(v20 >> 1))
        goto LABEL_94;
      goto LABEL_26;
    }
    v84 = __si_assert_copy_extra_1644(*(_DWORD **)(v19 + 112));
    v85 = v84;
    v86 = "";
    if (v84)
      v86 = v84;
    __message_assert("%s:%u: failed assertion '%s' %s next: %d, max: %d", "BurstTrie.c", 6106, "child.next < ctx->trie_max", v86, a2, *(_QWORD *)(a1 + 64));
    free(v85);
    v83 = *(_DWORD **)(*(_QWORD *)(a1 + 8) + 112);
    goto LABEL_138;
  }
  if (HIDWORD(a2))
  {
    if (*(_DWORD *)(a1 + 48) != 1)
      goto LABEL_94;
    v20 = 0;
    goto LABEL_25;
  }
  findAddFlatBucket(a1, a2, 0, 0, 0, 0);
LABEL_95:
  --*(_DWORD *)(a1 + 1140);
}

uint64_t _dumpTrie(unint64_t a1, int a2, _DWORD *a3, _QWORD *a4, uint64_t a5, uint64_t a6)
{
  void *v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  _QWORD *v17;
  unint64_t v18;
  void *v19;
  int v20;
  unsigned int v21;
  int v22;
  unint64_t v23;
  unsigned int v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  void (*v29)(_QWORD);
  int v30;
  NSObject *v31;
  void *v32;
  void *v33;
  uint64_t v34;
  _DWORD *v35;
  unsigned int *v36;
  unsigned int v37;
  unint64_t *v38;
  int v39;
  NSObject *v40;
  os_log_type_t v41;
  unint64_t *v42;
  uint64_t v43;
  uint64_t v44;
  void (*v45)(_QWORD);
  unint64_t v47;
  unsigned int v48;
  unsigned int v49;
  unsigned int v50;
  unsigned int v51;
  uint64_t v52;
  uint8_t buf[4];
  const char *v54;
  __int16 v55;
  int v56;
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  if (__THREAD_SLOT_KEY)
  {
    v12 = pthread_getspecific(__THREAD_SLOT_KEY);
    if (v12)
      goto LABEL_3;
  }
  else
  {
    makeThreadId();
    v12 = pthread_getspecific(__THREAD_SLOT_KEY);
    if (v12)
    {
LABEL_3:
      v13 = v12;
      if ((unint64_t)v12 < 0x801)
        goto LABEL_4;
    }
  }
  makeThreadId();
  v13 = pthread_getspecific(__THREAD_SLOT_KEY);
LABEL_4:
  v14 = (uint64_t)v13 - 1;
  v15 = (uint64_t)v13 - 1;
  v16 = threadData[18 * ((uint64_t)v13 - 1) + 8];
  db_read_lock(a1 + 4592);
  CIOnThreadCleanUpPush(v14, (uint64_t)si_dglock_rdunlock, a1 + 4592);
  v17 = a4;
  if (!a4)
  {
    v17 = malloc_type_malloc(0x5160uLL, 0x10A00408BF7D057uLL);
    CICleanUpPush(v15, (uint64_t)MEMORY[0x1E0C834A8], (uint64_t)v17);
  }
  v18 = v16;
  v19 = malloc_type_malloc(0x18uLL, 0x1020040F21E5318uLL);
  storage_reader_init(a1 + 160, (uint64_t)v19);
  CICleanUpPush(v15, (uint64_t)storage_reader_free, (uint64_t)v19);
  *v17 = v19;
  v17[1] = a5;
  v17[2] = a6;
  *((_DWORD *)v17 + 6) = 0;
  v20 = *(_DWORD *)(a1 + 4576);
  v52 = 0;
  if (!*((_QWORD *)v19 + 1))
  {
    if (a2)
      v38 = (unint64_t *)&v52;
    else
      v38 = (unint64_t *)*((_QWORD *)v19 + 1);
    dumpTrieFatData(a1, v20 == 1, 1u, 0, (uint64_t)(v17 + 2092), v38, a3, (uint64_t)v17);
    goto LABEL_34;
  }
  if (*((_BYTE *)v19 + 16))
  {
    v47 = v18;
    do
    {
      v21 = __ldxr(exceptionSequenceNum);
      v22 = v21 + 1;
    }
    while (__stxr(v21 + 1, exceptionSequenceNum));
    v23 = setThreadIdAndInfo(-1, sStorageReaderExceptionCallbacks, (uint64_t)v19, 0, v22);
    v50 = HIDWORD(v23);
    v51 = v23;
    v48 = v25;
    v49 = v24;
    v26 = *(_QWORD *)&threadData[18 * v23 + 2];
    v27 = v26 + 320 * HIDWORD(v23);
    v28 = *(_DWORD *)(v27 + 312);
    v29 = *(void (**)(_QWORD))(v27 + 224);
    if (v29)
      v29(*(_QWORD *)(v26 + 320 * HIDWORD(v23) + 288));
    if (_setjmp((int *)v27))
    {
      v30 = *__error();
      v31 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        v54 = "_dumpTrie";
        v55 = 1024;
        v56 = 3290;
        _os_log_error_impl(&dword_1B8270000, v31, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
      }
      *__error() = v30;
      *(_DWORD *)(v27 + 312) = v28;
      if (__THREAD_SLOT_KEY)
      {
        v32 = pthread_getspecific(__THREAD_SLOT_KEY);
        if (!v32)
          goto LABEL_38;
      }
      else
      {
        makeThreadId();
        v32 = pthread_getspecific(__THREAD_SLOT_KEY);
        if (!v32)
          goto LABEL_38;
      }
      v33 = v32;
      if ((unint64_t)v32 < 0x801)
      {
LABEL_18:
        v34 = (uint64_t)v33 - 1;
        v35 = &threadData[18 * ((uint64_t)v33 - 1)];
        v37 = v35[14];
        v36 = v35 + 14;
        if (v37 > v48)
        {
          do
            CIOnThreadCleanUpPop(v34);
          while (*v36 > v48);
        }
        dropThreadId(v51, 1, v22);
        CICleanUpReset(v51, v49);
        v18 = v47;
        goto LABEL_34;
      }
LABEL_38:
      makeThreadId();
      v33 = pthread_getspecific(__THREAD_SLOT_KEY);
      goto LABEL_18;
    }
    if (a2)
      v42 = (unint64_t *)&v52;
    else
      v42 = 0;
    dumpTrieFatData(a1, v20 == 1, 1u, 0, (uint64_t)(v17 + 2092), v42, a3, (uint64_t)v17);
    v43 = *(_QWORD *)&threadData[18 * v51 + 2];
    v44 = v43 + 320 * v50;
    *(_DWORD *)(v44 + 312) = v28;
    v45 = *(void (**)(_QWORD))(v44 + 232);
    if (v45)
      v45(*(_QWORD *)(v43 + 320 * v50 + 288));
    dropThreadId(v51, 0, v22);
  }
  else
  {
    v39 = *__error();
    v40 = _SILogForLogForCategory(0);
    v41 = 2 * (gSILogLevels[0] < 4);
    if (os_log_type_enabled(v40, v41))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1B8270000, v40, v41, "Skipping because index is shut down", buf, 2u);
    }
    *__error() = v39;
  }
LABEL_34:
  CIOnThreadCleanUpPop(v15);
  return CICleanUpReset(v15, v18);
}

unint64_t dumpTrieFatData(unint64_t result, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, unint64_t *a6, _DWORD *a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  unsigned int v14;
  uint64_t v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  unint64_t v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  int v23;
  BOOL v24;
  int v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  int v30;
  uint64_t i;
  _QWORD *v32;
  unint64_t v33;
  BOOL v34;
  unint64_t v35;
  unint64_t v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  int v40;
  uint64_t j;
  _QWORD *v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  char *v48;
  char *v49;
  const char *v50;
  char *v51;
  char *v52;
  const char *v53;
  unsigned int v54;
  unsigned int v55;
  unint64_t *v56;
  uint64_t v57;
  uint64_t *v58;
  unint64_t v59;
  unsigned int v60;
  uint64_t v61;

  v9 = result;
  if (*(_DWORD *)(result + 144) < a3)
  {
    v48 = __si_assert_copy_extra_1644(*(_DWORD **)(result + 4568));
    v49 = v48;
    v50 = "";
    if (v48)
      v50 = v48;
    __message_assert("%s:%u: failed assertion '%s' %s s: %d, c: %d", "BurstTrie.c", 3390, "s<=getNum(t->baseFatCount)", v50, a3, *(_DWORD *)(v9 + 144));
    free(v49);
    if (__valid_fsp(*(_DWORD **)(v9 + 4568)))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v10 = a8;
  v14 = a4;
  v15 = a2;
  v16 = a3;
  v17 = *(_DWORD *)(*(_QWORD *)(result + 8) + 1028 * a3);
  if ((_DWORD)a2)
  {
    if ((v17 & 1) != 0)
    {
      if ((*(_DWORD *)(*(_QWORD *)(result + 8) + 1028 * a3) & 3) == 1)
        goto LABEL_11;
      v18 = v17 >> 3;
      if ((v17 & 7) != 0)
        goto LABEL_11;
    }
    else
    {
      v18 = v17 >> 1;
    }
    if (v18)
      result = dumpFlatData(result, 1, *(uint64_t **)a8, v18, a4, a5, a7, *(void (**)(uint64_t, _BYTE *, _QWORD, _QWORD, uint64_t))(a8 + 8), *(_QWORD *)(a8 + 16));
  }
  else if (v17)
  {
    *(_BYTE *)(a5 + a4) = 0;
    result = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD))(a8 + 8))(a4, a5, *(unsigned int *)(*(_QWORD *)(result + 8) + 1028 * a3), 0, *(_QWORD *)(a8 + 16));
  }
LABEL_11:
  if (!*a7)
  {
    v19 = 0;
    v60 = v14 + 1;
    v61 = v14;
    v56 = a6;
    v57 = v10;
    v55 = v15;
    v54 = a3;
    do
    {
      v20 = *(_DWORD *)(*(_QWORD *)(v9 + 8) + 1028 * v16 + 4 * v19 + 4);
      v21 = v20 >> 1;
      v22 = v20 >> 3;
      v23 = v20 & 7;
      if ((v20 & 3) == 1)
      {
        v23 = 1;
        v22 = v20 >> 2;
      }
      v24 = (v20 & 1) == 0;
      if ((v20 & 1) != 0)
        v25 = v23;
      else
        v25 = 0;
      if (v24)
        v26 = v21;
      else
        v26 = v22;
      if (!(_DWORD)v26)
        goto LABEL_43;
      *(_BYTE *)(a5 + v61) = v19;
      if (v25)
      {
        if (v25 == 1)
        {
          result = dumpTrieData(v9, v15, v26, v60, a5, a6, a7, v10);
LABEL_43:
          if (*a7)
            return result;
          goto LABEL_44;
        }
        if (v25 != 3)
        {
          v51 = __si_assert_copy_extra_1644(0);
          v52 = v51;
          if (v51)
            v53 = v51;
          else
            v53 = "";
          __message_assert("%s:%u: Unexpected code path %s ", "BurstTrie.c", 3427, v53);
          free(v52);
          MEMORY[0xBAD] = -559038737;
          abort();
        }
        result = dumpTrieFatData(v9, v15, v26, v60, a5, a6, a7, v10);
        if (*a7)
          return result;
      }
      else
      {
        result = dumpFlatData(v9, v15, *(uint64_t **)v10, v26, v60, a5, a7, *(void (**)(uint64_t, _BYTE *, _QWORD, _QWORD, uint64_t))(v10 + 8), *(_QWORD *)(v10 + 16));
        if (!a6)
          goto LABEL_43;
        v27 = *a6;
        if (result <= *a6 || result - *a6 <= 0x10000)
          goto LABEL_43;
        v58 = *(uint64_t **)v10;
        v59 = result;
        v28 = result & ~*MEMORY[0x1E0C85AC0];
        v29 = *(_QWORD *)(*(_QWORD *)v10 + 8);
        if (v29)
        {
          v30 = *(_DWORD *)(v29 + 552);
          if (v30 >= 1)
          {
            for (i = 0; i < v30; ++i)
            {
              v32 = *(_QWORD **)(v29 + 576 + 8 * i);
              if (v32)
              {
                v33 = v32[2];
                v34 = v27 >= v33;
                v35 = v27 - v33;
                if (v34)
                {
                  v36 = v32[3];
                  v37 = v32[1];
                  if (v36 <= v28)
                    v38 = 0;
                  else
                    v38 = v35;
                  result = sync_invalidate_mapping((char *)(v37 + v38), v28 - v27);
                  v30 = *(_DWORD *)(v29 + 552);
                }
              }
            }
          }
        }
        v39 = *v58;
        if (*v58)
        {
          v40 = *(_DWORD *)(v39 + 240);
          if (v40 >= 1)
          {
            for (j = 0; j < v40; ++j)
            {
              v42 = *(_QWORD **)(v39 + 264 + 8 * j);
              if (v42)
              {
                v43 = v42[2];
                v34 = v27 >= v43;
                v44 = v27 - v43;
                if (v34)
                {
                  v45 = v42[3];
                  v46 = v42[1];
                  if (v45 <= v28)
                    v47 = 0;
                  else
                    v47 = v44;
                  result = sync_invalidate_mapping((char *)(v46 + v47), v28 - v27);
                  v40 = *(_DWORD *)(v39 + 240);
                }
              }
            }
          }
        }
        a6 = v56;
        v10 = v57;
        *v56 = v59 & ~*MEMORY[0x1E0C85AC0];
        v15 = v55;
        v16 = v54;
        if (*a7)
          return result;
      }
LABEL_44:
      v34 = v19++ >= 0xFF;
    }
    while (!v34);
  }
  return result;
}

unint64_t dumpTrieData(uint64_t a1, uint64_t a2, unsigned int a3, int a4, uint64_t a5, unint64_t *a6, _DWORD *a7, uint64_t a8)
{
  uint64_t v8;
  _DWORD *v9;
  unint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t result;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  int v19;
  uint64_t v20;
  unsigned int v21;
  int8x8_t *v22;
  uint8x8_t v23;
  uint8x8_t v24;
  uint8x8_t v25;
  uint8x8_t v26;
  unsigned int v27;
  int v28;
  int v29;
  unint64_t v30;
  unint64_t v31;
  uint64_t *v32;
  unint64_t v33;
  uint64_t v34;
  int v35;
  uint64_t i;
  _QWORD *v37;
  unint64_t v38;
  BOOL v39;
  unint64_t v40;
  unint64_t v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t v44;
  int v45;
  uint64_t j;
  _QWORD *v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v54;
  uint64_t v55;
  char *v56;
  char *v57;
  const char *v58;
  uint64_t v60;
  unsigned int v61;
  int v66;
  uint64_t v67;
  unsigned int v69;
  uint64_t v70;

  v8 = a8;
  v9 = a7;
  v10 = a6;
  v11 = a5;
  v12 = a2;
  v66 = 0;
  v60 = a8 + 16 * *(int *)(a8 + 24) + 32;
  v61 = a2;
  result = mgetBase(a1, a3);
LABEL_4:
  v16 = result;
  v17 = *(unsigned int *)result;
  if (!(_DWORD)v12)
  {
    if (*(_DWORD *)result)
      result = (*(uint64_t (**)(_QWORD, uint64_t, unint64_t, _QWORD, _QWORD))(v8 + 8))((v66 + a4), v11, v17, 0, *(_QWORD *)(v8 + 16));
    goto LABEL_13;
  }
  if ((v17 & 1) == 0)
  {
    v18 = v17 >> 1;
    goto LABEL_11;
  }
  if ((v17 & 3) != 1)
  {
    v18 = v17 >> 3;
    if ((v17 & 7) == 0)
    {
LABEL_11:
      if (v18)
        result = dumpFlatData(a1, 1, *(uint64_t **)v8, v18, v66 + a4, v11, v9, *(void (**)(uint64_t, _BYTE *, _QWORD, _QWORD, uint64_t))(v8 + 8), *(_QWORD *)(v8 + 16));
    }
  }
LABEL_13:
  v19 = 0;
  v67 = v66;
  if (*v9)
    goto LABEL_58;
LABEL_14:
  if (v19 > 255)
    goto LABEL_58;
  v70 = (v67 + a4);
  v69 = v70 + 1;
  v66 = v67 + 1;
  do
  {
    if (((*(_DWORD *)(v16 + 4 * (v19 >> 5) + 4) >> v19) & 1) == 0)
      goto LABEL_56;
    v20 = 0;
    v21 = v19 >> 6;
    if (v21 == 1)
    {
      v22 = (int8x8_t *)(v16 + 4);
    }
    else
    {
      v22 = (int8x8_t *)(v16 + 4);
      if (v21 != 2)
      {
        if (v21 != 3)
          goto LABEL_24;
        v23 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v16 + 20));
        v23.i16[0] = vaddlv_u8(v23);
        v20 = v23.u32[0];
      }
      v24 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v16 + 12));
      v24.i16[0] = vaddlv_u8(v24);
      v20 += v24.u32[0];
    }
    v25 = (uint8x8_t)vcnt_s8(*v22);
    v25.i16[0] = vaddlv_u8(v25);
    v20 += v25.u32[0];
LABEL_24:
    v26 = (uint8x8_t)vcnt_s8((int8x8_t)(*(_QWORD *)&v22[v21] & ~(-1 << v19)));
    v26.i16[0] = vaddlv_u8(v26);
    v27 = *(_DWORD *)(v16 + 4 * (v26.u32[0] + v20) + 38);
    if ((v27 & 1) != 0)
    {
      if ((v27 & 3) == 1)
      {
        LODWORD(v14) = v27 >> 2;
        *(_BYTE *)(v11 + v70) = v19;
      }
      else
      {
        v14 = v27 >> 3;
        *(_BYTE *)(v11 + v70) = v19;
        v28 = v27 & 7;
        if (!v28)
          goto LABEL_30;
        if (v28 == 3)
        {
          v29 = *(_DWORD *)(v8 + 24);
          *(_DWORD *)(v8 + 24) = v66 + v29;
          result = dumpTrieFatData(a1, v12, v14, v69, v11, v10, v9, v8);
          *(_DWORD *)(v8 + 24) = v29;
          goto LABEL_56;
        }
        if (v28 != 1)
        {
          v56 = __si_assert_copy_extra_1644(0);
          v57 = v56;
          if (v56)
            v58 = v56;
          else
            v58 = "";
          __message_assert("%s:%u: Unexpected code path %s ", "BurstTrie.c", 3529, v58);
          free(v57);
          MEMORY[0xBAD] = -559038737;
          abort();
        }
      }
      v15 = v60 + 16 * (int)v67;
      *(_DWORD *)(v15 + 8) = v19;
      *(_QWORD *)v15 = v16;
      result = mgetBase(a1, v14);
      goto LABEL_4;
    }
    LODWORD(v14) = v27 >> 1;
    *(_BYTE *)(v11 + v70) = v19;
LABEL_30:
    result = dumpFlatData(a1, v12, *(uint64_t **)v8, v14, v69, v11, v9, *(void (**)(uint64_t, _BYTE *, _QWORD, _QWORD, uint64_t))(v8 + 8), *(_QWORD *)(v8 + 16));
    if (v10)
    {
      v30 = result;
      v31 = *v10;
      if (result > *v10 && result - *v10 > 0x10000)
      {
        v32 = *(uint64_t **)v8;
        v33 = result & ~*MEMORY[0x1E0C85AC0];
        v34 = *(_QWORD *)(*(_QWORD *)v8 + 8);
        if (v34)
        {
          v35 = *(_DWORD *)(v34 + 552);
          if (v35 >= 1)
          {
            for (i = 0; i < v35; ++i)
            {
              v37 = *(_QWORD **)(v34 + 576 + 8 * i);
              if (v37)
              {
                v38 = v37[2];
                v39 = v31 >= v38;
                v40 = v31 - v38;
                if (v39)
                {
                  v41 = v37[3];
                  v42 = v37[1];
                  if (v41 <= v33)
                    v43 = 0;
                  else
                    v43 = v40;
                  result = sync_invalidate_mapping((char *)(v42 + v43), v33 - v31);
                  v35 = *(_DWORD *)(v34 + 552);
                }
              }
            }
          }
        }
        v44 = *v32;
        v12 = v61;
        if (v44)
        {
          v45 = *(_DWORD *)(v44 + 240);
          if (v45 >= 1)
          {
            for (j = 0; j < v45; ++j)
            {
              v47 = *(_QWORD **)(v44 + 264 + 8 * j);
              if (v47)
              {
                v48 = v47[2];
                v39 = v31 >= v48;
                v49 = v31 - v48;
                if (v39)
                {
                  v50 = v47[3];
                  v51 = v47[1];
                  if (v50 <= v33)
                    v52 = 0;
                  else
                    v52 = v49;
                  result = sync_invalidate_mapping((char *)(v51 + v52), v33 - v31);
                  v45 = *(_DWORD *)(v44 + 240);
                }
              }
            }
          }
        }
        v10 = a6;
        v9 = a7;
        *a6 = v30 & ~*MEMORY[0x1E0C85AC0];
        v8 = a8;
        v11 = a5;
      }
    }
LABEL_56:
    if (*v9)
      break;
  }
  while (v19++ < 255);
LABEL_58:
  while (1)
  {
    v54 = v67;
    if (!v67)
      return result;
    --v67;
    v55 = v60 + 16 * (v54 - 1);
    v19 = *(_DWORD *)(v55 + 8) + 1;
    v16 = *(_QWORD *)v55;
    if (!*v9)
      goto LABEL_14;
  }
}

uint64_t scanTrieFatData(uint64_t result, unsigned int a2, unint64_t a3, unint64_t a4, int *a5)
{
  uint64_t v6;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  int v15;
  BOOL v16;
  int v17;
  uint64_t v18;
  char *v20;
  char *v21;
  const char *v22;
  char *v23;
  char *v24;
  const char *v25;
  char *v26;
  char *v27;
  const char *v28;

  v6 = result;
  if (*(_DWORD *)(result + 144) < a2)
  {
    v23 = __si_assert_copy_extra_1644(*(_DWORD **)(result + 4568));
    v24 = v23;
    v25 = "";
    if (v23)
      v25 = v23;
    __message_assert("%s:%u: failed assertion '%s' %s s: %d, c: %d", "BurstTrie.c", 3215, "s<=getNum(t->baseFatCount)", v25, a2, *(_DWORD *)(v6 + 144));
    free(v24);
    if (__valid_fsp(*(_DWORD **)(v6 + 4568)))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v10 = 0;
  v11 = 1028 * a2 + 4;
  do
  {
    v12 = *(_DWORD *)(*(_QWORD *)(v6 + 8) + v11 + v10);
    v13 = v12 >> 1;
    v14 = v12 >> 3;
    v15 = v12 & 7;
    if ((v12 & 3) == 1)
    {
      v15 = 1;
      v14 = v12 >> 2;
    }
    v16 = (v12 & 1) == 0;
    if ((v12 & 1) != 0)
      v17 = v15;
    else
      v17 = 0;
    if (v16)
      v18 = v13;
    else
      v18 = v14;
    if ((_DWORD)v18)
    {
      if (v17)
      {
        if (v17 == 1)
        {
          result = scanTrieData(v6, v18, a3, a4, a5);
        }
        else
        {
          if (v17 != 3)
          {
            v26 = __si_assert_copy_extra_1644(0);
            v27 = v26;
            if (v26)
              v28 = v26;
            else
              v28 = "";
            __message_assert("%s:%u: Unexpected code path %s ", "BurstTrie.c", 3232, v28);
            free(v27);
            MEMORY[0xBAD] = -559038737;
            abort();
          }
          result = scanTrieFatData(v6, v18, a3, a4, a5);
        }
      }
      else if (v18 << 6 > a3 && v18 << 6 < a4)
      {
        v20 = __si_assert_copy_extra_1644(0);
        v21 = v20;
        v22 = "";
        if (v20)
          v22 = v20;
        __message_assert("%s:%u: failed assertion '%s' %s ", "BurstTrie.c", 3230, "!(offset>flatPagePtr && offset<flatPageEnd)", v22);
        free(v21);
        if (__valid_fs(-1))
        {
          MEMORY[0xBAD] = -559038737;
          abort();
        }
        MEMORY[0xC00] = -559038737;
        abort();
      }
    }
    v10 += 4;
  }
  while (v10 != 1024);
  return result;
}

uint64_t scanTrieData(uint64_t a1, unsigned int a2, unint64_t a3, unint64_t a4, int *a5)
{
  int v8;
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int8x8_t *v15;
  unint64_t v16;
  uint64_t v18;
  unsigned int v19;
  uint8x8_t v20;
  uint8x8_t v21;
  uint8x8_t v22;
  uint8x8_t v23;
  unsigned int v24;
  int v25;
  int v26;
  uint64_t v27;
  char *v28;
  char *v29;
  const char *v30;
  char *v31;
  char *v32;
  const char *v33;
  uint64_t v34;

  v8 = 0;
  v34 = (uint64_t)&a5[4 * *a5 + 2];
  result = mgetBase(a1, a2);
LABEL_4:
  v12 = result;
  v13 = 0;
  v14 = v8;
LABEL_5:
  v15 = (int8x8_t *)(v12 + 4);
  do
  {
    if (((*(_DWORD *)(v12 + 4 * (v13 >> 5) + 4) >> v13) & 1) == 0)
      goto LABEL_12;
    v18 = 0;
    v19 = v13 >> 6;
    if (v19 != 1)
    {
      if (v19 != 2)
      {
        if (v19 != 3)
          goto LABEL_20;
        v20 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v12 + 20));
        v20.i16[0] = vaddlv_u8(v20);
        v18 = v20.u32[0];
      }
      v21 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v12 + 12));
      v21.i16[0] = vaddlv_u8(v21);
      v18 += v21.u32[0];
    }
    v22 = (uint8x8_t)vcnt_s8(*v15);
    v22.i16[0] = vaddlv_u8(v22);
    v18 += v22.u32[0];
LABEL_20:
    v23 = (uint8x8_t)vcnt_s8((int8x8_t)(*(_QWORD *)&v15[v19] & ~(-1 << v13)));
    v23.i16[0] = vaddlv_u8(v23);
    v24 = *(_DWORD *)(v12 + 4 * (v23.u32[0] + v18) + 38);
    if ((v24 & 1) == 0)
    {
      LODWORD(v10) = v24 >> 1;
LABEL_7:
      v16 = (unint64_t)v10 << 6;
      if (v16 > a3 && v16 < a4)
      {
        v31 = __si_assert_copy_extra_1644(0);
        v32 = v31;
        v33 = "";
        if (v31)
          v33 = v31;
        __message_assert("%s:%u: failed assertion '%s' %s ", "BurstTrie.c", 3194, "!(offset>flatPagePtr && offset<flatPageEnd)", v33);
        free(v32);
        if (__valid_fs(-1))
        {
          MEMORY[0xBAD] = -559038737;
          abort();
        }
        MEMORY[0xC00] = -559038737;
        abort();
      }
      goto LABEL_12;
    }
    if ((v24 & 3) == 1)
    {
      LODWORD(v10) = v24 >> 2;
LABEL_3:
      v11 = v34 + 16 * (int)v14;
      *(_DWORD *)(v11 + 8) = v13;
      *(_QWORD *)v11 = v12;
      v8 = v14 + 1;
      result = mgetBase(a1, v10);
      goto LABEL_4;
    }
    v10 = v24 >> 3;
    v25 = v24 & 7;
    if (!v25)
      goto LABEL_7;
    if (v25 != 3)
    {
      if (v25 != 1)
      {
        v28 = __si_assert_copy_extra_1644(0);
        v29 = v28;
        if (v28)
          v30 = v28;
        else
          v30 = "";
        __message_assert("%s:%u: Unexpected code path %s ", "BurstTrie.c", 3196, v30);
        free(v29);
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      goto LABEL_3;
    }
    v26 = *a5;
    *a5 += v14 + 1;
    result = scanTrieFatData(a1, v10, a3, a4, a5);
    *a5 = v26;
LABEL_12:
    ++v13;
  }
  while (v13 != 256);
  while (v14)
  {
    --v14;
    v27 = v34 + 16 * v14;
    v13 = *(_DWORD *)(v27 + 8) + 1;
    v12 = *(_QWORD *)v27;
    if (v13 <= 255)
      goto LABEL_5;
  }
  return result;
}

uint64_t trieLastCompactTermOffset(uint64_t a1)
{
  int v2;
  unint64_t v3;
  int v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int *v18;
  int8x8_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unsigned int v23;
  unsigned int v24;
  int v25;
  int v26;
  unsigned int v27;
  unsigned int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  unsigned int v36;
  unsigned int v37;
  int v38;
  int v39;
  int v40;
  unsigned int v41;
  unsigned int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int8x8_t v48;
  __int32 v49;
  int8x8_t v50;
  __int32 v51;
  int8x8_t v52;
  __int32 v53;
  uint8x8_t v54;
  __int32 v55;
  unint64_t v56;
  unint64_t v57;
  unint64_t v58;
  uint64_t v59;
  BOOL v60;
  uint64_t v61;

  if (*(_DWORD *)(a1 + 4576) == 1)
  {
    v2 = 0;
    v3 = 1;
LABEL_3:
    v4 = v2 - 1;
    while (2)
    {
      if (v3 <= *(unsigned int *)(a1 + 144))
      {
        v5 = *(_QWORD *)(a1 + 8);
        v6 = *(unsigned int *)(v5 + 1028 * v3);
        v7 = v6 >> 1;
        v8 = v6 >> 3;
        v9 = v6 & 7;
        if ((v6 & 3) == 1)
        {
          v9 = 1;
          v8 = v6 >> 2;
        }
        if ((v6 & 1) != 0)
          v10 = v9;
        else
          v10 = 0;
        if ((*(_DWORD *)(v5 + 1028 * v3) & 1) != 0)
          v7 = v8;
        v11 = v5 + 1028 * v3;
        v12 = 1024;
        while (1)
        {
          v13 = *(unsigned int *)(v11 + v12);
          v14 = v13 >> 1;
          v15 = v13 >> 3;
          v16 = v13 & 7;
          if ((v13 & 3) == 1)
          {
            v16 = 1;
            v15 = v13 >> 2;
          }
          v17 = (v13 & 1) != 0 ? v16 : 0;
          v3 = (*(_DWORD *)(v11 + v12) & 1) != 0 ? v15 : v14;
          if (v3)
            break;
          v12 -= 4;
          if (!v12)
          {
            v17 = v10;
            v3 = v7;
            goto LABEL_50;
          }
        }
        switch(v17)
        {
          case 3:
            ++v2;
            ++v4;
            if (v2 != 1045)
              continue;
            break;
          case 0:
LABEL_50:
            v21 = v17 << 32;
            v22 = v3;
            return flatLastCompactTermOffset(a1, v21 | v22);
          case 1:
            while ((v4 + 2) <= 0x414)
            {
              v18 = (unsigned int *)mgetBase(a1, v3);
              v20 = *v18;
              if ((v20 & 1) != 0)
              {
                if ((v20 & 3) == 1)
                {
                  v22 = v20 >> 2;
                  v21 = 0x100000000;
                }
                else
                {
                  v22 = v20 >> 3;
                  v21 = (v20 & 7) << 32;
                }
              }
              else
              {
                v21 = 0;
                v22 = v20 >> 1;
              }
              v23 = v18[1];
              v24 = v18[2];
              v25 = v24 & v23;
              v26 = v24 ^ v23;
              v27 = v18[3];
              v28 = v18[4];
              v29 = v26 ^ v27;
              v30 = v26 & v27;
              v31 = v29 & v28;
              v32 = v29 & v28 | v30;
              v33 = v29 ^ v28;
              v34 = v31 & v25;
              v35 = v32 ^ v25;
              v36 = v18[5];
              v37 = v18[6];
              v38 = v33 ^ v36;
              v39 = (v33 ^ v36) & v37 | v33 & v36;
              v40 = v38 ^ v37;
              v41 = v18[7];
              v42 = v18[8];
              v43 = v40 ^ v41;
              v44 = (v40 ^ v41) & v42 | v40 & v41;
              v45 = v43 ^ v42;
              v46 = v39 ^ v35;
              v47 = (v44 & (v39 ^ v35) | v39 & v35) ^ v34;
              v19.i32[0] = v44 & v46 & v34;
              v48 = vcnt_s8(v19);
              v48.i16[0] = vaddlv_u8((uint8x8_t)v48);
              v49 = v48.i32[0];
              v48.i32[0] = v47;
              v50 = vcnt_s8(v48);
              v50.i16[0] = vaddlv_u8((uint8x8_t)v50);
              v51 = v50.i32[0];
              v50.i32[0] = v44 ^ v46;
              v52 = vcnt_s8(v50);
              v52.i16[0] = vaddlv_u8((uint8x8_t)v52);
              v53 = v52.i32[0];
              v52.i32[0] = v45;
              v54 = (uint8x8_t)vcnt_s8(v52);
              v54.i16[0] = vaddlv_u8(v54);
              v55 = v54.i32[0] + 2 * v53 + 8 * v49 + 4 * v51;
              if (!v55)
                return flatLastCompactTermOffset(a1, v21 | v22);
              v56 = *(unsigned int *)((char *)&v18[v55 - 1 + 9] + 2);
              v57 = v56 >> 1;
              v58 = v56 >> 3;
              v59 = v56 & 7;
              if ((v56 & 3) == 1)
              {
                v59 = 1;
                v58 = v56 >> 2;
              }
              v60 = (v56 & 1) == 0;
              v61 = (v56 & 1) != 0 ? v59 : 0;
              v3 = v60 ? v57 : v58;
              if (!v3)
                return flatLastCompactTermOffset(a1, v21 | v22);
              ++v4;
              if (v61 != 1)
              {
                if (!v61)
                {
                  v22 = v3;
                  v21 = 0;
                  return flatLastCompactTermOffset(a1, v21 | v22);
                }
                if (v61 == 3)
                {
                  v2 = v4 + 2;
                  if ((v4 + 2) <= 0x414)
                    goto LABEL_3;
                }
                return 0;
              }
            }
            break;
        }
      }
      break;
    }
  }
  return 0;
}

uint64_t ___bt_findTokens_block_invoke(_QWORD *a1, _DWORD *a2, unsigned int a3)
{
  int v6;
  unint64_t v7;
  size_t v8;
  void *v10;
  uint64_t result;
  int v12;
  uint8_t v13[16];

  v6 = *a2 - a2[2];
  v7 = *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24);
  if (*(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) + 1 >= v7)
  {
    v8 = 2 * v7;
    if (((v7 >> 13) & 0x7FFFFFFFFFFFLL) == 0 && 16 * v7 > *MEMORY[0x1E0C85AD8])
      ++sTotal;
    v10 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, v8, 8uLL, 0x31F9A007uLL);
    if (!v10 && os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)v13 = 0;
      _os_log_fault_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "allocation function returned null", v13, 2u);
    }
    memcpy(v10, *(const void **)(*(_QWORD *)(a1[6] + 8) + 24), 8 * *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24));
    if (*(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24) >= 0x21uLL)
      free(*(void **)(*(_QWORD *)(a1[6] + 8) + 24));
    *(_QWORD *)(*(_QWORD *)(a1[6] + 8) + 24) = v10;
    *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24) = v8;
  }
  result = TokenDataAddRange(a1[7], (unsigned __int16)v6 | ((unsigned __int16)a3 << 16));
  if ((_DWORD)result)
  {
    if (v6 + a3 < *(_DWORD *)(a1[7] + 20))
    {
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1[6] + 8) + 24) + (*(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) << 6)) = *(_QWORD *)a2 + a3;
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1[6] + 8) + 24)
                + (*(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) << 6)
                + 56) = a2[14] - a3;
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1[6] + 8) + 24)
                + (*(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) << 6)
                + 8) = *((_QWORD *)a2 + 1);
      v12 = a2[5];
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1[6] + 8) + 24)
                + (*(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) << 6)
                + 16) = a2[4];
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1[6] + 8) + 24)
                + ((*(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24))++ << 6)
                + 20) = v12;
    }
  }
  return result;
}

void ___bt_resolveTokens_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  int *v4;
  unsigned __int8 *v5;
  _DWORD *v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unsigned __int8 *v13;
  int v14;
  uint64_t v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unsigned __int8 *v26;
  int v27;
  unint64_t v28;
  int v29;
  int v30;
  int v31;
  int v32;
  unint64_t v33;
  unint64_t v34;
  int v35;
  unsigned __int8 *v36;
  BOOL v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  int8x8_t *v46;
  unint64_t v47;
  uint8x8_t v48;
  uint8x8_t v49;
  uint8x8_t v50;
  uint8x8_t v51;
  unint64_t v52;
  unint64_t v53;
  _DWORD *v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  uint64_t v58;
  uint64_t v59;
  char *v60;
  char *v61;
  const char *v62;
  uint64_t v64;
  unint64_t v65;

  if (*(_DWORD *)(a2 + 1152))
  {
    v3 = 0;
    while (1)
    {
      if (**(_BYTE **)a2)
        return;
      v4 = (int *)(*(_QWORD *)(a2 + 1144) + (v3 << 6));
      *(_QWORD *)(a2 + 1240) = v4;
      v5 = *(unsigned __int8 **)v4;
      *(_QWORD *)(a2 + 1224) = *(_QWORD *)v4;
      *(_QWORD *)(a2 + 1232) = v5;
      *(_DWORD *)(a2 + 1140) = 0;
      *(_BYTE *)(a2 + 88) = 0;
      v6 = *(_DWORD **)(a2 + 8);
      v7 = *v6;
      v8 = v7 >> 1;
      v9 = v7 >> 3;
      v10 = (v7 & 7) << 32;
      if ((v7 & 3) == 1)
      {
        v10 = 0x100000000;
        v9 = v7 >> 2;
      }
      if ((v7 & 1) != 0)
        v11 = v10;
      else
        v11 = 0;
      if ((*v6 & 1) != 0)
        v8 = v9;
      v12 = v11 | v8;
      *(_QWORD *)(a2 + 52) = v11 | v8;
      v13 = *(unsigned __int8 **)v4;
      if (*(_QWORD *)v4)
      {
        if (*v13 <= 3u)
          break;
      }
LABEL_30:
      v64 = *(_QWORD *)(a1 + 32);
      v65 = 0;
      v25 = v4[14];
      v26 = v13;
      if (v4[5] >= 7)
      {
        v26 = v13;
        if (*v13 == 1)
        {
          v27 = v13[1];
          if ((char)v13[1] < 0)
          {
            v29 = v13[2];
            if ((char)v13[2] < 0)
            {
              v30 = v13[3];
              if ((char)v13[3] < 0)
              {
                v31 = v13[4];
                if ((char)v13[4] < 0)
                {
                  v32 = (char)v13[5];
                  if (v32 < 0)
                    goto LABEL_113;
                  v28 = 6;
                  if ((((v31 & 0x7F) << 21) | (v32 << 28) | ((v30 & 0x7F) << 14) | ((v29 & 0x7F) << 7) | v27 & 0x7F) != 2)
                    goto LABEL_54;
                }
                else
                {
                  v28 = 5;
                  if ((((v30 & 0x7F) << 14) | (v31 << 21) | ((v29 & 0x7F) << 7) | v27 & 0x7F) != 2)
                    goto LABEL_54;
                }
              }
              else
              {
                v28 = 4;
                if ((((v29 & 0x7F) << 7) | (v30 << 14) | v27 & 0x7F) != 2)
                  goto LABEL_54;
              }
            }
            else
            {
              v28 = 3;
              if ((v27 & 0x7F | (v29 << 7)) != 2)
                goto LABEL_54;
            }
          }
          else
          {
            v28 = 2;
            if (v27 != 2)
              goto LABEL_54;
          }
          v33 = v28 + 1;
          if ((char)v13[v28] < 0)
          {
            v34 = v28 + 2;
            if ((char)v13[v33] < 0)
            {
              v33 = v28 + 3;
              if (((char)v13[v34] & 0x80000000) == 0)
                goto LABEL_51;
              v34 = v28 + 4;
              if ((char)v13[v33] < 0)
              {
                if ((char)v13[v34] < 0)
                {
LABEL_113:
                  v60 = __si_assert_copy_extra_1644(0);
                  v61 = v60;
                  v62 = "";
                  if (v60)
                    v62 = v60;
                  __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t", "VIntUtils.h", 341, "(b4 & 0x80) == 0", v62);
                  free(v61);
                  if (__valid_fs(-1))
                  {
                    MEMORY[0xBAD] = -559038737;
                    abort();
                  }
                  MEMORY[0xC00] = -559038737;
                  abort();
                }
                v28 += 5;
                goto LABEL_54;
              }
            }
            v28 = v34;
          }
          else
          {
LABEL_51:
            v28 = v33;
          }
LABEL_54:
          v26 = v13;
          if (v28 <= v25)
          {
            v35 = _trie_resolve_string((uint64_t)v6, v12, (uint64_t)v13, v28, &v65);
            v26 = v13;
            if (v35)
            {
              v26 = &v13[v35];
              if (HIDWORD(v65))
                *(_QWORD *)(a2 + 52) = v65;
              else
                findAddFlatBucket(a2, v65, v13, v35, 0, 0);
            }
          }
        }
      }
      v36 = &v13[v25];
      if (v13)
        v37 = v26 >= v36;
      else
        v37 = 1;
      if (v37)
        goto LABEL_3;
      while (2)
      {
        v38 = 0;
        v39 = utf8_byte_length_noerror(unsigned char)::utf8_len_table[(unint64_t)*v26 >> 4];
        v40 = *(_QWORD *)(a2 + 8);
        v41 = *(_QWORD *)(a2 + 52);
        v42 = HIDWORD(*(_QWORD *)(a2 + 52));
        while (v42 == 3)
        {
          v52 = *(unsigned int *)(*(_QWORD *)(v40 + 8) + 1028 * v41 + 4 * *((unsigned __int8 *)&tcm + v26[v38]) + 4);
          if ((v52 & 1) != 0)
          {
LABEL_75:
            if ((v52 & 3) == 1)
            {
              v41 = v52 >> 2;
              if (!(v52 >> 2))
                goto LABEL_3;
              v42 = 1;
            }
            else
            {
              v41 = v52 >> 3;
              if (!(v52 >> 3))
                goto LABEL_3;
              v42 = v52 & 7;
            }
            goto LABEL_64;
          }
LABEL_79:
          v41 = v52 >> 1;
          if (!(v52 >> 1))
            goto LABEL_3;
          v42 = 0;
LABEL_64:
          if (v39 == ++v38)
            goto LABEL_86;
        }
        if (v42 == 1)
        {
          v43 = mgetBase(v40, v41);
          v44 = *((unsigned __int8 *)&tcm + v26[v38]);
          if (((*(_DWORD *)(v43 + ((v44 >> 3) & 0x1C) + 4) >> v44) & 1) == 0)
            break;
          v45 = 0;
          v46 = (int8x8_t *)(v43 + 4);
          v47 = v44 >> 6;
          if ((v44 >> 6) == 1)
            goto LABEL_73;
          if ((_DWORD)v47 == 2)
            goto LABEL_72;
          if ((_DWORD)v47 == 3)
          {
            v48 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v43 + 20));
            v48.i16[0] = vaddlv_u8(v48);
            v45 = v48.u32[0];
LABEL_72:
            v49 = (uint8x8_t)vcnt_s8(*(int8x8_t *)(v43 + 12));
            v49.i16[0] = vaddlv_u8(v49);
            v45 += v49.u32[0];
LABEL_73:
            v50 = (uint8x8_t)vcnt_s8(*v46);
            v50.i16[0] = vaddlv_u8(v50);
            v45 += v50.u32[0];
          }
          v51 = (uint8x8_t)vcnt_s8((int8x8_t)(*(_QWORD *)&v46[v47] & ~(-1 << v44)));
          v51.i16[0] = vaddlv_u8(v51);
          v52 = *(unsigned int *)(v43 + 4 * (v51.u32[0] + v45) + 38);
          if ((v52 & 1) != 0)
            goto LABEL_75;
          goto LABEL_79;
        }
        if (v42 || !v41)
          break;
        LODWORD(v42) = 0;
        LODWORD(v39) = v38;
LABEL_86:
        v65 = __PAIR64__(v42, v41);
        if (!(_DWORD)v39)
          break;
        v26 += (int)v39;
        v53 = v65;
        *(_QWORD *)(a2 + 52) = v65;
        switch(HIDWORD(v53))
        {
          case 1:
            v54 = (_DWORD *)mgetBase(*(_QWORD *)(a2 + 8), v53);
LABEL_91:
            v55 = *v54;
            if (*(_DWORD *)(a2 + 48) == 1)
            {
              v56 = v55 >> 1;
              v57 = v55 >> 3;
              v58 = (v55 & 7) << 32;
              if ((v55 & 3) == 1)
              {
                v58 = 0x100000000;
                v57 = v55 >> 2;
              }
              if ((v55 & 1) != 0)
                v59 = v58;
              else
                v59 = 0;
              if ((*v54 & 1) != 0)
                v56 = v57;
              if (v56)
                findAddFlatBucket(a2, v59 | v56, v13, v26 - v13, 0, 0);
            }
            else if (v64 && *v54)
            {
              (*(void (**)(uint64_t, _QWORD, _QWORD))(v64 + 16))(v64, *(_QWORD *)(a2 + 1240), ((_DWORD)v26 - (_DWORD)v13));
            }
            if (v26 >= v36)
              break;
            continue;
          case 3:
            v54 = *(_DWORD **)(*(_QWORD *)(a2 + 8) + 8);
            goto LABEL_91;
          case 0:
            findAddFlatBucket(a2, v53, v13, v26 - v13, 0, 0);
            break;
        }
        break;
      }
LABEL_3:
      if (++v3 >= (unint64_t)*(unsigned int *)(a2 + 1152))
        return;
    }
    v14 = v13[1];
    if ((char)v13[1] < 0)
    {
      v16 = v13[2];
      if ((char)v13[2] < 0)
      {
        v17 = v13[3];
        if ((char)v13[3] < 0)
        {
          v19 = v13[4];
          if ((char)v13[4] < 0)
          {
            v21 = (char)v13[5];
            if (v21 < 0)
              goto LABEL_113;
            v22 = ((v19 & 0x7F) << 21) | (v21 << 28) | ((v17 & 0x7F) << 14) | ((v16 & 0x7F) << 7) | v14 & 0x7F;
            v15 = 6;
            v14 = v22;
          }
          else
          {
            v20 = ((v17 & 0x7F) << 14) | (v19 << 21) | ((v16 & 0x7F) << 7) | v14 & 0x7F;
            v15 = 5;
            v14 = v20;
          }
        }
        else
        {
          v18 = ((v16 & 0x7F) << 7) | (v17 << 14) | v14 & 0x7F;
          v15 = 4;
          v14 = v18;
        }
      }
      else
      {
        v14 = v14 & 0x7F | (v16 << 7);
        v15 = 3;
      }
    }
    else
    {
      v15 = 2;
    }
    if ((v14 - 1) > 5)
    {
LABEL_29:
      *(_QWORD *)(a2 + 1232) = &v5[v15];
      goto LABEL_30;
    }
    v23 = v15 + 1;
    if (((char)v13[v15] & 0x80000000) == 0)
    {
LABEL_26:
      v15 = v23;
      goto LABEL_29;
    }
    v24 = v15 + 2;
    if ((char)v13[v23] < 0)
    {
      v23 = v15 + 3;
      if (((char)v13[v24] & 0x80000000) == 0)
        goto LABEL_26;
      v24 = v15 + 4;
      if ((char)v13[v23] < 0)
      {
        if ((char)v13[v24] < 0)
          goto LABEL_113;
        v15 += 5;
        goto LABEL_29;
      }
    }
    v15 = v24;
    goto LABEL_29;
  }
}

BOOL ___bt_resolveTokens_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  int v7;
  unsigned __int8 *v8;
  uint64_t v9;
  unsigned int v10;
  _BYTE *v11;
  int v12;
  uint64_t v13;
  int v14;
  int v15;
  unsigned int v16;
  BOOL v17;
  uint64_t v18;
  BOOL v19;
  BOOL v20;
  unsigned __int8 *i;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  char v29;
  unint64_t v30;
  unint64_t v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  char *v36;
  char v37;
  uint64_t v38;
  uint64_t v39;
  unsigned __int8 *v40;
  unsigned __int8 *v41;
  unint64_t v42;
  unint64_t v43;
  uint64_t v44;
  int v45;
  unsigned __int8 v46;
  uint64_t v47;
  char *v48;
  unsigned __int8 *v49;
  int v50;
  int v51;
  unsigned int v52;
  _BOOL4 v53;
  uint64_t v54;
  uint64_t v55;
  char *v56;
  char *v57;
  unsigned int v58;
  int v59;
  int v60;
  char *v61;
  unsigned int v62;
  int v63;
  int v64;
  int v65;
  unsigned int v66;
  int v67;
  NSObject *v68;
  const char *v69;
  uint32_t v70;
  _BOOL4 v71;
  const char *v72;
  int v73;
  const char *v74;
  const char *v75;
  NSObject *v76;
  int v77;
  uint64_t v78;
  int v79;
  char v80;
  uint64_t v81;
  int v82;
  int v83;
  int v84;
  int v85;
  int v86;
  int v87;
  int v88;
  const char *v89;
  const char *v90;
  char *v92;
  char *v93;
  const char *v94;
  uint64_t v95;
  char *v96;
  char *v97;
  const char *v98;
  NSObject *log;
  NSObject *v100;
  NSObject *v101;
  int v102;
  int v103;
  unsigned int v104;
  unsigned int v105;
  int v106;
  int v108;
  int v109;
  unsigned __int8 *v110;
  unsigned __int8 *v111;
  char *v113;
  unint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint8_t buf[4];
  const char *v120;
  __int16 v121;
  _BYTE v122[28];
  char v123;
  unsigned __int8 v124;
  unsigned __int8 v125;
  unsigned __int8 v126;
  unsigned __int8 v127;
  unsigned __int8 v128;
  unsigned __int8 v129;
  uint64_t v130;

  v130 = *MEMORY[0x1E0C80C00];
  if (!*(_DWORD *)(a2 + 1152))
  {
    v7 = 0;
    return v7 > 0;
  }
  v3 = a3;
  v5 = a1;
  v6 = 0;
  v7 = 0;
  v8 = (unsigned __int8 *)(a2 + 88);
  v110 = (unsigned __int8 *)(a2 + 89);
  v111 = (unsigned __int8 *)(a2 + 88);
  while (2)
  {
    if (((*(unsigned __int8 *)(v3 + (v6 >> 3)) >> (v6 & 7)) & 1) == 0)
      goto LABEL_4;
    v9 = *(_QWORD *)(a2 + 1144);
    *(_QWORD *)(a2 + 1240) = v9 + (v6 << 6);
    ++*(_DWORD *)(a2 + 1280);
    v10 = *(_DWORD *)(a2 + 1140);
    if (v10 < 3)
      goto LABEL_3;
    v11 = *(_BYTE **)(v9 + (v6 << 6));
    v115 = *(unsigned int *)(a2 + 1140);
    v12 = termPropertyID(v8, v10);
    v13 = *(_QWORD *)(a2 + 1240);
    v14 = *(_DWORD *)(v13 + 20);
    if ((*(_BYTE *)(v13 + 19) & 4) == 0)
    {
      if (!v14)
      {
        v15 = v115;
        if (v12 == 2)
          goto LABEL_3;
        goto LABEL_19;
      }
      goto LABEL_12;
    }
    if (v14)
    {
LABEL_12:
      v15 = v115;
      if (v12 != 1)
        goto LABEL_3;
      v16 = v8[v115 - 1];
      v17 = v16 == 3;
      if (v16 > 3)
        goto LABEL_3;
      v18 = -2;
      if (!v17)
        v18 = -1;
      if (v8[v115 + v18] == 2)
        goto LABEL_3;
      goto LABEL_19;
    }
    v15 = v115;
    if (v12 != 2)
    {
LABEL_3:
      ++v7;
      goto LABEL_4;
    }
LABEL_19:
    v108 = v7;
    v109 = v7 + 1;
    v19 = 0;
    v20 = 0;
    v114 = v15 & 0xFFFFFFFFFFFFFFFELL;
    v118 = v15;
    v113 = &v123 + v15;
    for (i = v8; ; i += v38)
    {
      v22 = *v11;
      v23 = *v11 >> 4;
      if ((char)*v11 < 0)
      {
        v24 = utf8_byte_length(unsigned char)::utf8_len_table[v23];
        v25 = utf8_to_code_point(unsigned char const*)::utf8_first_char_mask[v24] & v22;
        if ((~(_BYTE)v23 & 0xC) != 0)
        {
          v22 &= utf8_to_code_point(unsigned char const*)::utf8_first_char_mask[v24];
        }
        else
        {
          if (v24 <= 2)
            v26 = 2;
          else
            v26 = utf8_byte_length(unsigned char)::utf8_len_table[v23];
          v27 = v26 - 1;
          v28 = v11 + 1;
          do
          {
            v29 = *v28++;
            v22 = v29 & 0x3F | (v25 << 6);
            v25 = v22;
            --v27;
          }
          while (v27);
        }
      }
      v30 = *i;
      v31 = v30 >> 4;
      if ((v30 & 0x80) != 0)
      {
        v32 = utf8_byte_length(unsigned char)::utf8_len_table[v31];
        v33 = utf8_to_code_point(unsigned char const*)::utf8_first_char_mask[v32] & v30;
        if ((~(v30 >> 4) & 0xC) != 0)
        {
          LODWORD(v30) = utf8_to_code_point(unsigned char const*)::utf8_first_char_mask[v32] & v30;
        }
        else
        {
          if (v32 <= 2)
            v34 = 2;
          else
            v34 = utf8_byte_length(unsigned char)::utf8_len_table[v31];
          v35 = v34 - 1;
          v36 = (char *)(i + 1);
          do
          {
            v37 = *v36++;
            LODWORD(v30) = v37 & 0x3F | (v33 << 6);
            v33 = v30;
            --v35;
          }
          while (v35);
        }
      }
      v38 = utf8_byte_length_noerror(unsigned char)::utf8_len_table[v31];
      v39 = utf8_byte_length_noerror(unsigned char)::utf8_len_table[v23];
      if (v30 < 2)
      {
        if (v19 && v22 != 0 && v22 - 12448 < 0x60 || v20 && v22 != 0 && v22 - 12352 < 0x60)
        {
          v7 = v109;
          goto LABEL_146;
        }
LABEL_46:
        v116 = utf8_byte_length_noerror(unsigned char)::utf8_len_table[v23];
        v117 = v38;
        if ((int)v118 > 1043)
        {
LABEL_117:
          (*(void (**)(void))(*(_QWORD *)(v5 + 32) + 16))();
          v39 = v116;
          v38 = v117;
          goto LABEL_118;
        }
        bzero(&v124, 0x415uLL);
        __memcpy_chk();
        if (!(_DWORD)v115)
        {
          v54 = 0;
          v51 = 0;
          v52 = 0;
          v53 = 0;
          *(&v124 + v118) = 0;
          goto LABEL_66;
        }
        v40 = v110;
        v41 = &v125;
        v42 = v114;
        if ((_DWORD)v115 == 1)
        {
          v43 = 0;
        }
        else
        {
          do
          {
            v44 = *(v40 - 1);
            v45 = *v40;
            v40 += 2;
            v46 = tcmn[v45];
            *(v41 - 1) = tcmn[v44];
            *v41 = v46;
            v41 += 2;
            v42 -= 2;
          }
          while (v42);
          v43 = v114;
          if (v114 == v118)
            goto LABEL_54;
        }
        v47 = v118 - v43;
        v48 = (char *)(&v124 + v43);
        v49 = &v8[v43];
        do
        {
          v50 = *v49++;
          *v48++ = tcmn[v50];
          --v47;
        }
        while (v47);
LABEL_54:
        *(&v124 + v118) = 0;
        if ((int)v118 >= 2)
        {
          v51 = v124;
          if (v124 - 2 < 3)
          {
            v52 = v125;
            if ((char)v125 < 0)
            {
              if ((char)v126 < 0)
              {
                if ((char)v127 < 0)
                {
                  if ((char)v128 < 0)
                  {
                    if ((char)v129 < 0)
                    {
                      v92 = __si_assert_copy_extra_268();
                      v93 = v92;
                      v94 = "";
                      if (v92)
                        v94 = v92;
                      __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t", "VIntUtils.h", 341, "(b4 & 0x80) == 0", v94);
                      free(v93);
                      if (__valid_fs(-1))
                        v95 = 2989;
                      else
                        v95 = 3072;
                      *(_DWORD *)v95 = -559038737;
                      abort();
                    }
                    v53 = 0;
                    v54 = 6;
                    v52 = ((v128 & 0x7F) << 21) | (v129 << 28) | ((v127 & 0x7F) << 14) | ((v126 & 0x7F) << 7) | v125 & 0x7F;
                  }
                  else
                  {
                    v53 = 0;
                    v54 = 5;
                    v52 = ((v127 & 0x7F) << 14) | (v128 << 21) | ((v126 & 0x7F) << 7) | v125 & 0x7F;
                  }
                }
                else
                {
                  v53 = 0;
                  v54 = 4;
                  v52 = ((v126 & 0x7F) << 7) | (v127 << 14) | v125 & 0x7F;
                }
              }
              else
              {
                v53 = 0;
                v52 = v125 & 0x7F | (v126 << 7);
                v54 = 3;
              }
            }
            else
            {
              v53 = 0;
              v54 = 2;
            }
            goto LABEL_66;
          }
          if (v124 == 1)
          {
            v53 = v125 == 2;
            if (v125 == 2)
              v55 = 2;
            else
              v55 = 1;
            v54 = v55 + 1;
            v52 = *(&v124 + v55);
            if ((char)*(&v124 + v55) < 0)
            {
              v78 = v55 + 2;
              v79 = (char)*(&v124 + v54);
              v80 = v79;
              if (v79 < 0)
              {
                v81 = v55 + 3;
                v82 = (char)*(&v124 + v78);
                v83 = *(&v124 + v78);
                if (v82 < 0)
                {
                  v54 = v55 | 4;
                  v84 = (char)*(&v124 + v81);
                  v85 = *(&v124 + v81);
                  if (v84 < 0)
                  {
                    v87 = (char)*(&v124 + v54);
                    if (v87 < 0)
                    {
                      v96 = __si_assert_copy_extra_268();
                      v97 = v96;
                      v98 = "";
                      if (v96)
                        v98 = v96;
                      __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t", "VIntUtils.h", 341, "(b4 & 0x80) == 0", v98);
                      free(v97);
                      if (__valid_fs(-1))
                      {
                        MEMORY[0xBAD] = -559038737;
                        abort();
                      }
                      MEMORY[0xC00] = -559038737;
                      abort();
                    }
                    v51 = 0;
                    v88 = v87;
                    v54 = v55 + 5;
                    v86 = ((v85 & 0x7F) << 21) | (v88 << 28) | ((v83 & 0x7F) << 14);
                  }
                  else
                  {
                    v51 = 0;
                    v86 = ((v83 & 0x7F) << 14) | (v85 << 21);
                  }
                  v52 = v86 & 0xFFFFC000 | ((v80 & 0x7F) << 7) | v52 & 0x7F;
                }
                else
                {
                  v51 = 0;
                  v54 = v55 + 3;
                  v52 = ((v80 & 0x7F) << 7) | (v83 << 14) | v52 & 0x7F;
                }
              }
              else
              {
                v51 = 0;
                v52 = v52 & 0x7F | (v79 << 7);
                v54 = v55 + 2;
              }
            }
            else
            {
              v51 = 0;
            }
            goto LABEL_66;
          }
        }
        v54 = 0;
        v51 = 0;
        v52 = 0;
        v53 = 0;
LABEL_66:
        v56 = (char *)(&v124 + v54);
        v57 = v113;
        v58 = *v113;
        if (v58 > 5)
          goto LABEL_78;
        if (v113 <= v56)
        {
          v63 = 0;
          if (v58 != 1)
          {
            v65 = 0;
            v64 = 0;
            if (!v52)
              goto LABEL_115;
            goto LABEL_79;
          }
          v59 = 1;
          v61 = v113;
          v64 = 0;
          goto LABEL_114;
        }
        v59 = v115 - v54;
        v60 = 1;
        v61 = v113;
        while (1)
        {
          v62 = *--v57;
          if (v62 > 5)
            break;
          ++v60;
          v61 = v57;
          if (v57 <= v56)
          {
            v61 = v56;
            goto LABEL_75;
          }
        }
        v59 = v60;
LABEL_75:
        if (*v61 != 1)
        {
LABEL_78:
          v63 = 0;
          v65 = 0;
          v64 = 0;
          if (!v52)
          {
LABEL_115:
            if (dword_1EF19FC90 < 5)
              goto LABEL_116;
            v102 = v64;
            v106 = *__error();
            log = _SILogForLogForCategory(1);
            if (os_log_type_enabled(log, OS_LOG_TYPE_DEFAULT))
            {
              v89 = "";
              v90 = "(0) ";
              if (!v65)
                v90 = "";
              *(_DWORD *)buf = 136315906;
              v120 = "match ";
              if (v102)
                v90 = "(2) ";
              v121 = 2080;
              if (v63)
                v89 = "[*] ";
              *(_QWORD *)v122 = v90;
              *(_WORD *)&v122[8] = 2080;
              *(_QWORD *)&v122[10] = v89;
              *(_WORD *)&v122[18] = 2080;
              *(_QWORD *)&v122[20] = v56;
              _os_log_impl(&dword_1B8270000, log, OS_LOG_TYPE_DEFAULT, "%s%s%s%s", buf, 0x2Au);
            }
            v67 = v106;
LABEL_141:
            *__error() = v67;
            goto LABEL_116;
          }
LABEL_79:
          if (v51)
          {
            if (dword_1EF19FC90 >= 5)
            {
              v103 = v51;
              v66 = v52;
              v67 = *__error();
              v100 = _SILogForLogForCategory(1);
              if (!os_log_type_enabled(v100, OS_LOG_TYPE_DEFAULT))
                goto LABEL_141;
              *(_DWORD *)buf = 136315906;
              v120 = "match ";
              v121 = 1024;
              *(_DWORD *)v122 = v66;
              *(_WORD *)&v122[4] = 1024;
              *(_DWORD *)&v122[6] = v103;
              *(_WORD *)&v122[10] = 2080;
              *(_QWORD *)&v122[12] = v56;
              v68 = v100;
              v69 = "%s(%d) [%d] %s";
              v70 = 34;
LABEL_100:
              _os_log_impl(&dword_1B8270000, v68, OS_LOG_TYPE_DEFAULT, v69, buf, v70);
              goto LABEL_141;
            }
          }
          else
          {
            v17 = v58 == 3;
            v71 = v58 == 3;
            v72 = "";
            if (v17)
            {
              v72 = "[f] ";
              v73 = 1;
            }
            else
            {
              v73 = v53;
            }
            v17 = !v53 || !v71;
            v74 = "[l] ";
            if (!v17)
              v74 = "[fl] ";
            if (v53)
              v75 = v74;
            else
              v75 = v72;
            if (v73 == 1)
            {
              if (dword_1EF19FC90 >= 5)
              {
                v104 = v52;
                v67 = *__error();
                v101 = _SILogForLogForCategory(1);
                if (!os_log_type_enabled(v101, OS_LOG_TYPE_DEFAULT))
                  goto LABEL_141;
                *(_DWORD *)buf = 136315906;
                v120 = "match ";
                v121 = 1024;
                *(_DWORD *)v122 = v104;
                *(_WORD *)&v122[4] = 2080;
                *(_QWORD *)&v122[6] = v75;
                *(_WORD *)&v122[14] = 2080;
                *(_QWORD *)&v122[16] = v56;
                v68 = v101;
                v69 = "%s(%d) %s%s";
                v70 = 38;
                goto LABEL_100;
              }
            }
            else if (dword_1EF19FC90 >= 5)
            {
              v105 = v52;
              v67 = *__error();
              v76 = _SILogForLogForCategory(1);
              if (!os_log_type_enabled(v76, OS_LOG_TYPE_DEFAULT))
                goto LABEL_141;
              *(_DWORD *)buf = 136315650;
              v120 = "match ";
              v121 = 1024;
              *(_DWORD *)v122 = v105;
              *(_WORD *)&v122[4] = 2080;
              *(_QWORD *)&v122[6] = v56;
              v68 = v76;
              v69 = "%s(%d) %s";
              v70 = 28;
              goto LABEL_100;
            }
          }
LABEL_116:
          v8 = v111;
          v5 = a1;
          goto LABEL_117;
        }
        if (v59 == 1)
        {
          v63 = 0;
          v64 = 0;
          goto LABEL_114;
        }
        v77 = v61[1];
        if ((v77 - 4) < 2)
        {
          v59 = 1;
        }
        else
        {
          v59 = 0;
          if (v77 != 1)
          {
            if (v77 == 2)
            {
              v59 = 0;
              v64 = 0;
              v63 = 1;
            }
            else
            {
              v63 = 0;
              v64 = 0;
            }
LABEL_114:
            v65 = v63;
            *v61 = 0;
            v63 = v59;
            if (!v52)
              goto LABEL_115;
            goto LABEL_79;
          }
        }
        v63 = 0;
        v64 = 1;
        goto LABEL_114;
      }
      if (!v22)
        break;
LABEL_118:
      if (!v22 || v22 != (_DWORD)v30)
        goto LABEL_144;
      v19 = v22 - 12448 < 0x60;
      v20 = v22 - 12352 < 0x60;
      v11 += v39;
    }
    if ((*(_BYTE *)(*(_QWORD *)(a2 + 1240) + 17) & 8) != 0)
      goto LABEL_46;
    v22 = 0;
LABEL_144:
    v7 = v108;
    if (v22 >= v30)
      v7 = v109;
LABEL_146:
    v3 = a3;
LABEL_4:
    if (++v6 < (unint64_t)*(unsigned int *)(a2 + 1152))
      continue;
    return v7 > 0;
  }
}

uint64_t __bt_findTokens_block_invoke(uint64_t a1, int a2)
{
  return TokenDataAddRange(*(_QWORD *)(a1 + 32), a2);
}

void si_fileProvidersPsid_destruct(uint64_t a1)
{
  free(*(void **)(a1 + 16));
}

uint64_t si_fileProvidersPsid_path_to_oid_path(uint64_t a1, char *__s)
{
  size_t v4;
  CFURLRef v5;
  CFURLRef v6;
  const __CFArray *v7;
  const __CFString *ValueAtIndex;
  const __CFString *v9;
  uint64_t v10;
  const void *v11;
  const __CFAllocator *v12;
  CFStringRef v13;
  CFStringRef v14;
  int v16;
  NSObject *v17;
  int v18;
  NSObject *v19;
  const __CFString *theString;
  uint8_t buf[4];
  char *v22;
  __int16 v23;
  char *v24;
  char v25[1024];
  char cStr[4];
  const char *CStringPtr;
  __int16 v28;
  const char *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  if (!__s)
    goto LABEL_14;
  if (*__s == 47)
  {
    v4 = strlen(__s);
    v5 = CFURLCreateFromFileSystemRepresentation((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const UInt8 *)__s, v4, 0);
    if (!v5)
      return 0;
    v6 = v5;
    v7 = (const __CFArray *)(*(uint64_t (**)(uint64_t, CFURLRef))(copyFPItemBlock + 16))(copyFPItemBlock, v5);
    CFRelease(v6);
    if (!v7)
      return 0;
    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v7, 0);
    v9 = (const __CFString *)CFArrayGetValueAtIndex(v7, 1);
    if (gSILogLevels[0] >= 5)
    {
      theString = v9;
      v18 = *__error();
      v19 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)cStr = 136315394;
        CStringPtr = CFStringGetCStringPtr(ValueAtIndex, 0x8000100u);
        v28 = 2080;
        v29 = CFStringGetCStringPtr(theString, 0x8000100u);
        _os_log_impl(&dword_1B8270000, v19, OS_LOG_TYPE_DEFAULT, "path_to_oid_path, bundleID: %s, uniqueID: %s", (uint8_t *)cStr, 0x16u);
      }
      *__error() = v18;
    }
    v10 = oidPathDepthFromBundleIDUniqueID(*(_QWORD *)(a1 + 16));
    v11 = v7;
    goto LABEL_13;
  }
  if (!strchr(__s, 58))
  {
LABEL_14:
    *__error() = 22;
    return 0xFFFFFFFFLL;
  }
  bzero(cStr, 0x400uLL);
  bzero(v25, 0x400uLL);
  __strncpy_chk();
  strlen(__s);
  __strncpy_chk();
  if (gSILogLevels[0] >= 5)
  {
    v16 = *__error();
    v17 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315394;
      v22 = cStr;
      v23 = 2080;
      v24 = v25;
      _os_log_impl(&dword_1B8270000, v17, OS_LOG_TYPE_DEFAULT, "specialPath_to_oid_path, bundleIDStr: %s, identifierStr: %s", buf, 0x16u);
    }
    *__error() = v16;
  }
  v12 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v13 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], cStr, 0x8000100u);
  v14 = CFStringCreateWithCString(v12, v25, 0x8000100u);
  v10 = oidPathDepthFromBundleIDUniqueID(*(_QWORD *)(a1 + 16));
  if (v13)
    CFRelease(v13);
  if (v14)
  {
    v11 = v14;
LABEL_13:
    CFRelease(v11);
  }
  return v10;
}

uint64_t si_fileProvidersPsid_close(uint64_t a1)
{
  uint64_t v1;
  uint64_t result;

  v1 = *(_QWORD *)(a1 + 16);
  result = *(unsigned int *)(v1 + 8);
  if ((result & 0x80000000) == 0)
  {
    result = close(result);
    *(_DWORD *)(v1 + 8) = -1;
  }
  return result;
}

uint64_t si_fileProvidersPsid_oid_to_parent(uint64_t a1, uint64_t a2, uint64_t a3, const __CFString *a4, const __CFString *a5, uint64_t a6, uint64_t a7)
{
  uint64_t *v11;
  int *v12;
  const __CFString *v13;
  const __CFString *v14;
  unint64_t v16;

  v11 = *(uint64_t **)(a1 + 16);
  v12 = __error();
  if (a4 && a6)
  {
    *v12 = 0;
    v13 = (const __CFString *)(*(uint64_t (**)(uint64_t, const __CFString *, const __CFString *, uint64_t, uint64_t))(copyFPItemParentBlock + 16))(copyFPItemParentBlock, a4, a5, a6, a7);
    v16 = -1;
    if (!v13)
      goto LABEL_9;
    v14 = v13;
    if (CFStringHasSuffix(v13, CFSTR("NSFileProviderRootContainerItemIdentifier")))
      v16 = 2;
    else
      si_get_object_for_identifier_createParentDBO(*v11, a4, v14, a5, 1, &v16, 0, 1u);
    CFRelease(v14);
    if (v16 == -1)
    {
LABEL_9:
      if (*__error() != 60)
        *__error() = 2;
    }
    return v16;
  }
  else
  {
    *v12 = 22;
    return -1;
  }
}

uint64_t si_fileProvidersPsid_oid_to_oid_path(uint64_t a1, uint64_t a2, _QWORD *a3, int a4, uint64_t a5, int *a6, const __CFString *a7, const __CFString *a8, uint64_t a9, uint64_t a10)
{
  const __CFArray *v17;
  const __CFArray *v18;
  CFIndex Count;
  CFIndex v20;
  int v21;
  uint64_t v22;
  CFIndex v24;
  const __CFString *ValueAtIndex;
  unint64_t v26;
  uint64_t *v27;
  unint64_t v28;
  char buffer[1024];
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  if (!a7 || !a9)
    goto LABEL_8;
  v17 = (const __CFArray *)(*(uint64_t (**)(uint64_t, const __CFString *, const __CFString *, uint64_t, uint64_t))(copyFPItemAllParentsBlock + 16))(copyFPItemAllParentsBlock, a7, a8, a9, a10);
  if (!v17)
  {
    if (*__error() == 60)
      return 0xFFFFFFFFLL;
LABEL_8:
    *__error() = 2;
    return 0xFFFFFFFFLL;
  }
  v18 = v17;
  Count = CFArrayGetCount(v17);
  if (Count < 0)
    goto LABEL_8;
  v20 = Count;
  if (a4)
  {
    *a3 = a2;
    v21 = 1;
  }
  else
  {
    v21 = 0;
  }
  bzero(buffer, 0x400uLL);
  v27 = *(uint64_t **)(a1 + 16);
  v28 = -1;
  if (v20)
  {
    v24 = 0;
    while (1)
    {
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v18, v24);
      if (!CFStringGetCString(ValueAtIndex, buffer, 1024, 0x8000100u))
        break;
      if (strstr(buffer, "NSFileProviderRootContainerItemIdentifier"))
      {
        v26 = 2;
      }
      else
      {
        si_get_object_for_identifier_createParentDBO(*v27, a7, ValueAtIndex, a8, 1, &v28, 0, 1u);
        v26 = v28;
      }
      a3[(v21 + v24++)] = v26;
      if (v20 == v24)
      {
        v22 = 0;
        v21 += v24;
        goto LABEL_22;
      }
    }
    *__error() = 2;
    v22 = 0xFFFFFFFFLL;
    v21 += v24;
  }
  else
  {
    v22 = 0;
  }
LABEL_22:
  *a6 = v21;
  CFRelease(v18);
  return v22;
}

uint64_t si_fileProvidersPsid_vet_path()
{
  return 1;
}

uint64_t oidPathDepthFromBundleIDUniqueID(uint64_t a1)
{
  const __CFString *v1;
  const __CFString *v2;
  unint64_t *v3;
  uint64_t *v4;
  uint64_t result;
  const __CFString *v6;
  unint64_t *v7;
  const __CFString *v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  BOOL v12;
  int Path;
  uint64_t v14;
  int v15;
  int64_t v16;
  uint64_t *v17;
  unint64_t v18;
  uint64_t v19;
  _BOOL4 v20;
  int v21;
  NSObject *v22;
  os_log_type_t v23;
  int v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  _BOOL4 v28;
  char *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t *v38;
  unint64_t v39;
  uint64_t *v40;
  uint64_t *v41;
  _QWORD __src[512];
  uint8_t buf[4];
  int v44;
  __int16 v45;
  int v46;
  __int16 v47;
  uint64_t v48;
  __int16 v49;
  unint64_t v50;
  __int16 v51;
  int64_t v52;
  uint64_t v53;

  v4 = (uint64_t *)MEMORY[0x1E0C80A78](a1);
  result = 0;
  v53 = *MEMORY[0x1E0C80C00];
  if (!v1)
    return result;
  v6 = v2;
  if (!v2)
    return result;
  v7 = v3;
  v8 = v1;
  v39 = -1;
  if (CFStringHasSuffix(v2, CFSTR("NSFileProviderRootContainerItemIdentifier")))
  {
    v9 = 2;
    v39 = 2;
  }
  else
  {
    si_get_object_for_identifier_createParentDBO(*v4, v8, v6, 0, 0, &v39, 0, 1u);
    si_indexDeleteDeferredItemsIfItemIncluded(*v4, v39);
    v9 = v39;
  }
  v10 = *v4;
  v11 = *(_QWORD *)(*v4 + 6624);
  if (v11)
    v12 = v9 == -1;
  else
    v12 = 1;
  if (v12)
    return 0;
  bzero(__src, 0x1000uLL);
  *v7 = v9;
  Path = directoryStoreGetPath(v11, v9, (uint64_t)__src);
  LODWORD(v14) = Path;
  if (!Path)
  {
    v41 = 0;
    if (db_get_obj(*(_DWORD **)(v10 + 1184), v39, (void **)&v41, 0))
      goto LABEL_18;
    v38 = v7;
    v15 = 0;
    v16 = 0;
    LODWORD(v14) = 0;
    v17 = v41;
    v18 = v41[3];
    while (1)
    {
      v40 = 0;
      if (db_get_obj(*(_DWORD **)(v10 + 1184), v18, (void **)&v40, 0))
      {
        free(v17);
        v17 = 0;
        if (!v16)
          goto LABEL_33;
      }
      else
      {
        v16 = v40[3];
        if (v18 != 2 && v16 <= 0)
        {
          v21 = *__error();
          v22 = _SILogForLogForCategory(4);
          v23 = 2 * (dword_1EF19FC9C < 4);
          if (os_log_type_enabled(v22, v23))
          {
            v24 = *__error();
            v25 = *v41;
            *(_DWORD *)buf = 67110144;
            v44 = v24;
            v45 = 1024;
            v46 = 250;
            v47 = 2048;
            v48 = v25;
            v49 = 2048;
            v50 = v18;
            v51 = 2048;
            v52 = v16;
            _os_log_impl(&dword_1B8270000, v22, v23, "lookupPathByDBO error:%d at:%d in_oid:%lld oid:%lld parent:%lld", buf, 0x2Cu);
          }
          *__error() = v21;
        }
        free(v17);
        v17 = v40;
        if (!v16)
        {
LABEL_33:
          v20 = 0;
          LODWORD(v14) = v15;
          if (v15)
            goto LABEL_38;
          goto LABEL_41;
        }
      }
      v19 = v15 + 1;
      __src[v15] = v16;
      if (v16 != 2)
      {
        v26 = directoryStoreWriterGetPath(*(_QWORD *)(v10 + 6624), v16, (uint64_t)&__src[v19]);
        v20 = v26 == 0;
        if (v26)
          LODWORD(v14) = v26 + v19;
        ++v15;
        if (!(_DWORD)v14)
          goto LABEL_41;
LABEL_38:
        v27 = 0;
        do
        {
          if ((uint64_t)__src[v27] <= 0)
          {
            v29 = __si_assert_copy_extra_268();
            __message_assert_1862((uint64_t)v29, v30, v31, v32, v33, v34, v35, v36, (char)"SIFileProvidersPSIDSupport.c");
            free(v29);
            if (__valid_fs(-1))
              v37 = 2989;
            else
              v37 = 3072;
            *(_DWORD *)v37 = -559038737;
            abort();
          }
          ++v27;
        }
        while (v14 != v27);
        goto LABEL_41;
      }
      v20 = 1;
      ++v15;
      LODWORD(v14) = v19;
      if ((_DWORD)v19)
        goto LABEL_38;
LABEL_41:
      v28 = v16 != 2 && v20;
      if (v28)
      {
        v18 = v16;
        if (v15 < 512)
          continue;
      }
      if (v17)
        free(v17);
      v7 = v38;
      if (!v28)
      {
        if (!(_DWORD)v14)
          return (v14 + 1);
        break;
      }
LABEL_18:
      LODWORD(v14) = 0;
      return (v14 + 1);
    }
  }
  if ((int)v14 >= 1)
    memcpy(v7 + 1, __src, 8 * v14);
  if (v7[(int)v14] != 2)
  {
    v14 = (int)v14 + 1;
    v7[v14] = 2;
  }
  return (v14 + 1);
}

void __message_assert_1862(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  xpc_object_t v9;
  xpc_object_t v10;
  char *string[2];
  xpc_object_t values;
  _BYTE keys[24];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  string[0] = 0;
  string[1] = &a9;
  vasprintf(string, "%s:%u: failed assertion '%s' %s Got parent[%d] with id %lld depth: %d", &a9);
  SISetCrashCStr(string[0]);
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)keys = 136315138;
    *(char **)&keys[4] = string[0];
    _os_log_error_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "%s", keys, 0xCu);
  }
  *(_QWORD *)keys = "crash_string";
  v9 = xpc_string_create(string[0]);
  values = v9;
  v10 = xpc_dictionary_create((const char *const *)keys, &values, 1uLL);
  analytics_send_event();
  xpc_release(v10);
  xpc_release(v9);
  free(string[0]);
}

uint64_t PRCreateQueryTree(_QWORD *a1, uint64_t a2, __CFString *a3, const __CFAttributedString *a4, _BOOL4 a5, char a6, uint64_t a7, const __CFArray *a8, const __CFDictionary *a9, uint64_t a10, const __CFArray *a11, _QWORD **a12, uint64_t a13, const __CFArray *a14)
{
  unsigned int v20;
  unsigned int v21;
  BOOL v22;
  _BOOL4 v23;
  unsigned int v24;
  _QWORD *v25;
  const __CFDictionary *v26;
  BOOL v27;
  uint64_t Count;
  __CFDictionary *Mutable;
  CFIndex i;
  void *ValueAtIndex;
  const __CFString *v32;
  const __CFString *v33;
  int v34;
  int v35;
  unsigned int v36;
  _QWORD *v37;
  uint64_t v38;
  _QWORD *v39;
  _QWORD *v41;
  _QWORD *v42;
  uint64_t v43;
  _QWORD *v45;
  _QWORD *v46;
  uint64_t v47;
  unsigned __int8 v48;
  uint64_t v49;
  unint64_t v50;
  unint64_t RankingAttributeScores;
  unsigned __int8 v52;
  _QWORD *v53;
  __CFString *v54;
  const char *v55;
  _QWORD *v56;
  _QWORD *v57;
  _QWORD *v58;
  _QWORD *tree_apply_block_with_meta;
  __int128 *IndexAttributeScores;
  __int128 *v61;
  unint64_t WildCardAllowedFields;
  _QWORD *v63;
  const __CFAttributedString *v64;
  __CFString *v65;
  const char *QueryNodeForPhotosMediaType;
  _QWORD *v67;
  _QWORD *v68;
  const char *QueryNode;
  _QWORD *v70;
  _QWORD *v71;
  uint64_t v74;
  unsigned __int16 v75;
  unsigned __int16 v76;
  BOOL v77;
  int v78;
  __int16 v79;
  BOOL v80;
  _DWORD v81[5];
  __CFDictionary *v82;
  _QWORD *v83;
  _QWORD *v84;
  uint64_t v85;
  void *v86;
  void *v87;
  uint64_t *v88;
  uint64_t *v89;
  unint64_t v90;
  __int128 *v91;
  unint64_t v92;
  _QWORD *v93;
  uint64_t v94;
  uint64_t (*v95)(uint64_t);
  void *v96;
  _QWORD *v97;

  v20 = bundleIDTypeMaskForBundleIDs(a11);
  v21 = v20;
  v22 = v20 == 0;
  v23 = v20 == 1024;
  if ((v20 | 0x400) == 0x400)
  {
    v24 = bundleIDTypeMaskForBundleIDs(a14);
    if (!v24)
    {
      v84 = (_QWORD *)MEMORY[0x1E0C809B0];
      v85 = 0x40000000;
      v86 = __db_query_tree_apply_block_block_invoke;
      v87 = &unk_1E6E377F8;
      v88 = (uint64_t *)&__block_literal_global_17_10736;
      return db_query_tree_apply_block_with_meta(a1, (uint64_t)&v84, (uint64_t)&__block_literal_global_20_10737);
    }
  }
  else
  {
    v24 = v20;
  }
  v26 = a9;
  v74 = a2;
  v75 = v24;
  v76 = 0;
  v77 = a5;
  v78 = 0;
  v79 = 0;
  v80 = (v24 & 8) != 0;
  memset(v81, 0, 12);
  *(_QWORD *)&v81[3] = a10;
  v82 = 0;
  if (v24 != 8)
  {
    v76 = v24 & 0x7F7;
    LOBYTE(v78) = a6;
    BYTE1(v78) = v22;
    if (v21)
      v27 = 0;
    else
      v27 = (v24 & 2) != 0;
    if (v24 < 3)
      v27 = 1;
    BYTE2(v78) = v27;
    HIBYTE(v78) = v23;
    if (a8)
    {
      LOBYTE(v79) = CFArrayGetCount(a8) > 0;
      HIBYTE(v79) = (v24 & 2) != 0;
      LOBYTE(v81[0]) = (v24 & 4) != 0;
      BYTE1(v81[0]) = 1;
      Count = CFArrayGetCount(a8);
      Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], Count, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      if (Count >= 1)
      {
        v71 = a1;
        for (i = 0; i != Count; ++i)
        {
          ValueAtIndex = (void *)CFArrayGetValueAtIndex(a8, i);
          v32 = (const __CFString *)objc_msgSend(ValueAtIndex, "originalToken");
          if (v32)
          {
            v33 = v32;
            if (CFStringGetLength(v32))
            {
              if (objc_msgSend((id)objc_msgSend(ValueAtIndex, "variations"), "count"))
                CFDictionarySetValue(Mutable, v33, (const void *)objc_msgSend(ValueAtIndex, "variations"));
            }
          }
        }
        a1 = v71;
      }
    }
    else
    {
      LOBYTE(v79) = 0;
      HIBYTE(v79) = (v24 & 2) != 0;
      LOBYTE(v81[0]) = (v24 & 4) != 0;
      BYTE1(v81[0]) = 1;
      Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    }
    v82 = Mutable;
    if (isQUEnabled_onceToken != -1)
      dispatch_once(&isQUEnabled_onceToken, &__block_literal_global_7880);
    if (isQUEnabled_quSupportedBundles)
      v34 = 2039;
    else
      v34 = 0;
    BYTE2(v81[0]) = (v34 & v24) != 0;
    v26 = a9;
    if (isLLMEnabled_onceToken[0] != -1)
    {
      dispatch_once(isLLMEnabled_onceToken, &__block_literal_global_5_7886);
      v26 = a9;
    }
    if (isLLMEnabled_llmSupportedBundles)
      v35 = 1024;
    else
      v35 = 0;
    v36 = (v35 & v24) >> 10;
    HIBYTE(v81[0]) = v36;
    *(_QWORD *)&v81[1] = a7;
    if (!v36 || !v23)
    {
      if (!a5)
      {
        if (a1 && db_count_query_tree(a1))
        {
          v57 = (_QWORD *)MEMORY[0x1E0C809B0];
          v84 = (_QWORD *)MEMORY[0x1E0C809B0];
          v85 = 0x40000000;
          v86 = __db_query_tree_apply_block_block_invoke;
          v87 = &unk_1E6E377F8;
          v88 = (uint64_t *)&__block_literal_global_17_10736;
          v58 = a1;
          tree_apply_block_with_meta = (_QWORD *)db_query_tree_apply_block_with_meta(a1, (uint64_t)&v84, (uint64_t)&__block_literal_global_20_10737);
          IndexAttributeScores = getIndexAttributeScores(v75);
          v61 = getIndexAttributeScores(v75);
          WildCardAllowedFields = getWildCardAllowedFields(v75);
          v84 = v57;
          v85 = 3221225472;
          v86 = ___ZL19pommesRetrievalTreeP10query_nodePK10__CFStringPK20__CFAttributedStringPK14__CFDictionaryP9PRContext_block_invoke;
          v87 = &__block_descriptor_64_e84__v16__0__query_node___query_node___query_node___query_piece_____v_v__vSIb8b1b1b1Qf_8l;
          v88 = (uint64_t *)WildCardAllowedFields;
          v89 = &v74;
          v90 = (unint64_t)v61;
          v91 = IndexAttributeScores;
          v93 = v57;
          v94 = 0x40000000;
          v95 = __db_query_tree_apply_block_block_invoke;
          v96 = &unk_1E6E377F8;
          v97 = &v84;
          v93 = (_QWORD *)db_query_tree_apply_block_with_meta(tree_apply_block_with_meta, (uint64_t)&v93, (uint64_t)&__block_literal_global_26);
          if (v93)
          {
            db_optimize_query_tree(&v93);
            v63 = v93;
            v65 = a3;
            v64 = a4;
            if (v80)
            {
              QueryNodeForPhotosMediaType = createQueryNodeForPhotosMediaType(0, v77);
              v63 = makeAndNode((uint64_t)v63, (uint64_t)QueryNodeForPhotosMediaType);
            }
            v67 = v58;
          }
          else
          {
            v63 = 0;
            v67 = v58;
            v65 = a3;
            v64 = a4;
          }
          v70 = pommesCustomTrees(v67, v65, v64, a9, (uint64_t)&v74);
          v37 = makeOrNode((uint64_t)v63, (uint64_t)v70);
        }
        else
        {
          v37 = 0;
        }
        v83 = v37;
        goto LABEL_33;
      }
      goto LABEL_48;
    }
    if (a5)
    {
LABEL_48:
      if (a1 && db_count_query_tree(a1))
      {
        v45 = (_QWORD *)MEMORY[0x1E0C809B0];
        v93 = (_QWORD *)MEMORY[0x1E0C809B0];
        v94 = 0x40000000;
        v95 = __db_query_tree_apply_block_block_invoke;
        v96 = &unk_1E6E377F8;
        v97 = &__block_literal_global_17_10736;
        v46 = (_QWORD *)db_query_tree_apply_block_with_meta(a1, (uint64_t)&v93, (uint64_t)&__block_literal_global_20_10737);
        v47 = v76;
        if ((v48 & 1) == 0
        {
          __cxa_atexit((void (*)(void *))MEMORY[0x1E0DE4AB8], &getStemmingRankingAttributeScores(PRBundleIDType)::mu, &dword_1B8270000);
        }
        if (!getStemmingRankingAttributeScores(PRBundleIDType)::ans[v76])
        {
          std::mutex::lock(&getStemmingRankingAttributeScores(PRBundleIDType)::mu);
          if (!getStemmingRankingAttributeScores(PRBundleIDType)::ans[v76])
          {
            v49 = operator new();
            *(_OWORD *)v49 = 0u;
            *(_OWORD *)(v49 + 16) = 0u;
            *(_DWORD *)(v49 + 32) = 1065353216;
            if ((v47 & 0x10) != 0)
            {
              CalendarRankingAttributeScores();
              std::unordered_map<std::string,float>::unordered_map((uint64_t)&v93, (uint64_t)&CalendarRankingAttributeScores(void)::_calendarAttributeScores);
              std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__node_handle_merge_unique[abi:nn180100]<std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>>(v49, &v93);
              std::__hash_table<std::__hash_value_type<std::string,int>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,int>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,int>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,int>>>::~__hash_table((uint64_t)&v93);
            }
            if ((v47 & 0x20) != 0)
            {
              MessagesRankingAttributeScores();
              std::unordered_map<std::string,float>::unordered_map((uint64_t)&v93, (uint64_t)&MessagesRankingAttributeScores(void)::_messagesAttributeScores);
              std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__node_handle_merge_unique[abi:nn180100]<std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>>(v49, &v93);
              std::__hash_table<std::__hash_value_type<std::string,int>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,int>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,int>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,int>>>::~__hash_table((uint64_t)&v93);
            }
            if ((v47 & 3) != 0)
            {
              MailRankingAttributeScores();
              std::unordered_map<std::string,float>::unordered_map((uint64_t)&v93, (uint64_t)&MailRankingAttributeScores(void)::_mailAttributeScores);
              std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__node_handle_merge_unique[abi:nn180100]<std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>>(v49, &v93);
              std::__hash_table<std::__hash_value_type<std::string,int>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,int>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,int>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,int>>>::~__hash_table((uint64_t)&v93);
            }
            if ((v47 & 4) != 0)
            {
              SafariRankingAttributeScores();
              std::unordered_map<std::string,float>::unordered_map((uint64_t)&v93, (uint64_t)&SafariRankingAttributeScores(void)::_safariAttributeScores);
              std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>::__node_handle_merge_unique[abi:nn180100]<std::__hash_table<std::__hash_value_type<std::string,float>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,float>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,float>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,float>>>>(v49, &v93);
              std::__hash_table<std::__hash_value_type<std::string,int>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,int>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,int>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,int>>>::~__hash_table((uint64_t)&v93);
            }
            atomic_store(v49, &getStemmingRankingAttributeScores(PRBundleIDType)::ans[v47]);
          }
          std::mutex::unlock(&getStemmingRankingAttributeScores(PRBundleIDType)::mu);
        }
        v50 = getStemmingRankingAttributeScores(PRBundleIDType)::ans[v47];
        RankingAttributeScores = getRankingAttributeScores(v76);
        if ((v52 & 1) == 0
        {
          MailRankingNameAttributeScores(void)::_mailAttributeScores = 0u;
          unk_1EDBBD978 = 0u;
          dword_1EDBBD988 = 1065353216;
          __cxa_atexit((void (*)(void *))std::unordered_map<std::string,float>::~unordered_map[abi:nn180100], &MailRankingNameAttributeScores(void)::_mailAttributeScores, &dword_1B8270000);
        }
        if (MailRankingNameAttributeScores(void)::onceToken != -1)
          dispatch_once(&MailRankingNameAttributeScores(void)::onceToken, &__block_literal_global_27);
        v84 = v45;
        v85 = 3221225472;
        v86 = ___ZL17pommesRankingTreeP10query_nodePK10__CFStringPK20__CFAttributedStringPK14__CFDictionaryP9PRContext_block_invoke;
        v87 = &__block_descriptor_72_e84__v16__0__query_node___query_node___query_node___query_piece_____v_v__vSIb8b1b1b1Qf_8l;
        v88 = &v74;
        v89 = (uint64_t *)RankingAttributeScores;
        v90 = getWildCardAllowedFields(v76);
        v91 = &MailRankingNameAttributeScores(void)::_mailAttributeScores;
        v92 = v50;
        v93 = v45;
        v94 = 0x40000000;
        v95 = __db_query_tree_apply_block_block_invoke;
        v96 = &unk_1E6E377F8;
        v97 = &v84;
        v93 = (_QWORD *)db_query_tree_apply_block_with_meta(v46, (uint64_t)&v93, (uint64_t)&__block_literal_global_6237);
        if (v93)
        {
          db_optimize_query_tree(&v93);
          v53 = v93;
          v54 = a3;
          if (v80)
          {
            v55 = createQueryNodeForPhotosMediaType(0, v77);
            v53 = makeAndNode((uint64_t)v53, (uint64_t)v55);
            v93 = v53;
          }
          v56 = a1;
          normalizeQueryNode((uint64_t)v53);
        }
        else
        {
          v53 = 0;
          v56 = a1;
          v54 = a3;
        }
        v68 = pommesCustomTrees(v56, v54, a4, a9, (uint64_t)&v74);
        v37 = makeOrNode((uint64_t)v53, (uint64_t)v68);
        v83 = v37;
        if (v37 && v75 == 2)
        {
          QueryNode = createQueryNode("_kMDItemHasEmailContentURL", "1", 0, 1, 0, 0.8, 1.0);
          v37 = makeAndNode((uint64_t)v37, (uint64_t)QueryNode);
          v83 = v37;
          normalizeQueryNode((uint64_t)v37);
        }
      }
      else
      {
        v37 = 0;
        v83 = 0;
      }
      goto LABEL_33;
    }
  }
  v37 = pommesCustomTrees(a1, a3, a4, v26, (uint64_t)&v74);
  v83 = v37;
LABEL_33:
  v38 = a13;
  if (a13 && !v77)
  {
    v39 = 0;
    v41 = (_QWORD *)MEMORY[0x1E0C809B0];
    do
    {
      v42 = *a12++;
      v84 = v41;
      v85 = 0x40000000;
      v86 = __db_query_tree_apply_block_block_invoke;
      v87 = &unk_1E6E377F8;
      v88 = (uint64_t *)&__block_literal_global_17_10736;
      v43 = db_query_tree_apply_block_with_meta(v42, (uint64_t)&v84, (uint64_t)&__block_literal_global_20_10737);
      v39 = makeAndNode((uint64_t)v39, v43);
      --v38;
    }
    while (v38);
    v37 = makeAndNode((uint64_t)v37, (uint64_t)v39);
    v83 = v37;
  }
  if (!v37)
  {
    v83 = malloc_type_calloc(1uLL, 0x48uLL, 0x10E0040D742DA1DuLL);
    *((_WORD *)v83 + 20) = 16;
  }
  db_optimize_query_tree(&v83);
  v25 = v83;
  if (v82)
    CFRelease(v82);
  return (uint64_t)v25;
}

void sub_1B842418C(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__hash_table<std::__hash_value_type<std::string,int>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,int>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,int>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,int>>>::~__hash_table(v1 - 144);
  std::mutex::unlock(&getStemmingRankingAttributeScores(PRBundleIDType)::mu);
  _Unwind_Resume(a1);
}

uint64_t pushMove(_QWORD *a1, uint64_t a2)
{
  char *v4;
  char **v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  char *v13;
  uint64_t v14;
  uint64_t v15;

  v4 = (char *)*a1;
  if (v4)
  {
    v5 = (char **)(a1 + 1);
    v6 = (_QWORD *)a1[1];
    v7 = a1 + 2;
    v8 = a1[2];
    if (v8)
    {
      v9 = a1[3];
      if (*v6 == -1)
      {
        if (v8 + 8 <= v9)
        {
          v15 = v6[1];
          v6[v15 + 2] = a2;
          v6[1] = v15 + 1;
          v14 = 8;
          goto LABEL_13;
        }
      }
      else if (v8 + 24 <= v9)
      {
        if (&v4[v8] != (char *)&v6[v6[1] + 2])
          __assert_rtn("pushMove", "MoveHolder.c", 26, "holder->count==0 || holder->count + holder->data == ((char*)current) + sizeof(PossibleFileMoves_t)+sizeof(oid_t)*current->count");
        goto LABEL_12;
      }
      return 0;
    }
    v11 = a1[3];
  }
  else
  {
    v10 = (_QWORD *)MEMORY[0x1E0C85AD8];
    v4 = (char *)mmap(0, 16 * *MEMORY[0x1E0C85AD8], 3, 4098, 0, 0);
    *a1 = v4;
    v11 = 16 * *v10;
    a1[3] = v11;
    a1[2] = 0;
    v7 = a1 + 2;
    a1[1] = v4;
    v5 = (char **)(a1 + 1);
  }
  if (v11 < 0x18)
    return 0;
  v8 = 0;
LABEL_12:
  v13 = &v4[v8];
  *v5 = v13;
  *((_QWORD *)v13 + 2) = a2;
  *(_OWORD *)v13 = xmmword_1B8631C90;
  v14 = 24;
LABEL_13:
  *v7 += v14;
  return 1;
}

uint64_t _CICreateNew(uint64_t a1, const __CFString *a2, uint64_t a3, int a4, __int16 a5, int a6, int a7, uint64_t a8, uint64_t a9, const void *a10)
{
  char *v18;
  uint64_t v19;
  uint64_t v20;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  char buffer;
  _BYTE v33[1031];

  *(_QWORD *)&v33[1023] = *MEMORY[0x1E0C80C00];
  bzero(v33, 0x3FFuLL);
  v31 = 0;
  buffer = 0;
  v18 = copyVolumeInfoStr(a1);
  if (CFStringGetFileSystemRepresentation(a2, &buffer, 1024))
  {
    v19 = createIndex(a1, &buffer, a3, (uint64_t)v18, a5, 0, a6, &v31, a7, a8, a9, a10);
    v20 = v19;
    if (v19)
    {
      *(_DWORD *)(v19 + 32) = a4;
      if (a3 && *(_QWORD *)(v19 + 72) != a3)
      {
        v22 = __si_assert_copy_extra_268();
        __message_assert_272((uint64_t)v22, v23, v24, v25, v26, v27, v28, v29, (char)"ContentIndex.c");
        free(v22);
        if (__valid_fs(-1))
          v30 = 2989;
        else
          v30 = 3072;
        *(_DWORD *)v30 = -559038737;
        abort();
      }
      if (g_fd_list)
        _fd_close_inactive(*(unsigned int *)(v19 + 56), (const char *)(v19 + 15168), 0, 0);
    }
  }
  else
  {
    v20 = 0;
  }
  free(v18);
  return v20;
}

uint64_t indexUpdateHeader(uint64_t a1)
{
  int v1;
  int v2;
  int v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  const char *v10;
  const char *v11;
  int v12;
  char *v13;
  char *v14;
  uint64_t v15;
  unsigned int v16;
  unsigned int v18;
  int v19;
  char v20[1024];
  uint64_t v21;

  v1 = MEMORY[0x1E0C80A78](a1);
  v3 = v2;
  v5 = v4;
  v7 = v6;
  v9 = v8;
  v11 = v10;
  v12 = v1;
  v21 = *MEMORY[0x1E0C80C00];
  bzero(v20, 0x400uLL);
  bzero(&v18, 0x1000uLL);
  snprintf(v20, 0x400uLL, "%sindexHead", v11);
  v13 = (char *)fd_create_protected(v12, v20, 536870914, 3u);
  v14 = v13;
  if (!v13 || fd_pread(v13, &v18, 0x1000uLL, 0) != 4096)
  {
LABEL_9:
    v16 = *__error();
    if (v16)
      v15 = v16;
    else
      v15 = 0xFFFFFFFFLL;
    goto LABEL_12;
  }
  if (v18 == v9 || (v15 = 22, v18 >= v7) && v18 <= v5)
  {
    if (v19 == v3 || (v18 = v9, v19 = v3, fd_pwrite((uint64_t)v14, (uint64_t)&v18, 0x1000uLL, 0) == 4096))
    {
      v15 = 0;
      goto LABEL_12;
    }
    goto LABEL_9;
  }
LABEL_12:
  fd_release(v14);
  return v15;
}

void _CIIndexSetRemoveAllValues(uint64_t a1)
{
  unint64_t v2;

  if (a1)
  {
    if (*(_DWORD *)(a1 + 8))
    {
      v2 = 0;
      do
      {
        freeIndex(*(_QWORD *)(*(_QWORD *)a1 + 8 * v2));
        *(_QWORD *)(*(_QWORD *)a1 + 8 * v2++) = 0;
      }
      while (v2 < *(unsigned int *)(a1 + 8));
    }
    *(_DWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 16) = -1;
  }
}

uint64_t _ContentIndexSyncIndexBulk(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int128 v8;
  __int128 v9;
  _QWORD *v10;
  int v11;
  BOOL v12;
  int v13;
  NSObject *v14;
  int v15;
  NSObject *v16;
  int v17;
  NSObject *v18;
  uint64_t v19;
  int v20;
  NSObject *v21;
  char v22;
  int v23;
  NSObject *v24;
  int v25;
  NSObject *v26;
  uint64_t (*v27)(uint64_t, _BYTE *);
  uint64_t v28;
  uint64_t v29;
  int v30;
  NSObject *v31;
  uint64_t v32;
  uint64_t (*v33)(uint64_t);
  uint64_t v34;
  uint64_t v35;
  uint64_t *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v40;
  int v41;
  NSObject *v42;
  int v43;
  const char *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unsigned int v49;
  uint64_t v50;
  int v51;
  NSObject *v52;
  int v53;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  NSObject *v59;
  NSObject *v60;
  uint32_t v61;
  int v62;
  int v63;
  uint64_t v64;
  void (*v65)(uint64_t);
  void (*v66)(uint64_t, _BYTE *);
  uint64_t v67;
  uint64_t (*v68)(uint64_t);
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  uint64_t v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  uint64_t v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  uint64_t v89;
  _BYTE buf[48];
  __int128 v91;
  __int128 v92;
  __int128 v93;
  uint64_t v94;
  uint64_t v95;

  v95 = *MEMORY[0x1E0C80C00];
  v8 = *(_OWORD *)(a5 + 48);
  *(_OWORD *)&buf[32] = *(_OWORD *)(a5 + 32);
  v91 = v8;
  *(_QWORD *)&v92 = *(_QWORD *)(a5 + 64);
  v9 = *(_OWORD *)(a5 + 16);
  *(_OWORD *)buf = *(_OWORD *)a5;
  *(_OWORD *)&buf[16] = v9;
  v10 = _CISyncContextCreate(a1, a2, a3, a4, (uint64_t)buf, a6, a7, a8);
  v11 = *((_DWORD *)v10 + 42);
  v12 = v11 != 0;
  if (v11)
  {
    v13 = *__error();
    v14 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      v53 = *((_DWORD *)v10 + 42);
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "_ContentIndexSyncIndexBulk";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 1577;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v53;
      _os_log_error_impl(&dword_1B8270000, v14, OS_LOG_TYPE_ERROR, "%s:%d: Sync context init error: %d", buf, 0x18u);
    }
    *__error() = v13;
  }
  _CISyncContextSync((uint64_t)v10, 0);
  if (!v11 && *((_DWORD *)v10 + 42))
  {
    v15 = *__error();
    v16 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      v54 = *((_DWORD *)v10 + 42);
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "_ContentIndexSyncIndexBulk";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 1585;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v54;
      _os_log_error_impl(&dword_1B8270000, v16, OS_LOG_TYPE_ERROR, "%s:%d: Sync sync error: %d", buf, 0x18u);
    }
    *__error() = v15;
    v12 = 1;
  }
  v75 = 0;
  v73 = 0u;
  v74 = 0u;
  v71 = 0u;
  v72 = 0u;
  v69 = 0u;
  v70 = 0u;
  _CISyncContextCommitData(v10, 0, (uint64_t)&v69);
  if (!v12 && *((_DWORD *)v10 + 42))
  {
    v17 = *__error();
    v18 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      v55 = *((_DWORD *)v10 + 42);
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "_ContentIndexSyncIndexBulk";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 1596;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v55;
      _os_log_error_impl(&dword_1B8270000, v18, OS_LOG_TYPE_ERROR, "%s:%d: Sync commit error: %d", buf, 0x18u);
    }
    *__error() = v17;
    v12 = 1;
  }
  _CISyncContextCommitHeader((uint64_t)v10);
  v19 = *((unsigned int *)v10 + 42);
  if (!v12 && (_DWORD)v19)
  {
    v20 = *__error();
    v21 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      v56 = *((_DWORD *)v10 + 42);
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "_ContentIndexSyncIndexBulk";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 1604;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v56;
      _os_log_error_impl(&dword_1B8270000, v21, OS_LOG_TYPE_ERROR, "%s:%d: Sync commit error: %d", buf, 0x18u);
    }
    *__error() = v20;
    v19 = *((unsigned int *)v10 + 42);
    v12 = 1;
  }
  if ((_DWORD)v19)
  {
LABEL_21:
    if ((_DWORD)v19)
      v22 = v12;
    else
      v22 = 1;
    if ((v22 & 1) == 0)
    {
      v23 = *__error();
      v24 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        v58 = *((_DWORD *)v10 + 42);
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = "_ContentIndexSyncIndexBulk";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 1618;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v58;
        _os_log_error_impl(&dword_1B8270000, v24, OS_LOG_TYPE_ERROR, "%s:%d: Sync retire error: %d", buf, 0x18u);
      }
      *__error() = v23;
      v19 = *((unsigned int *)v10 + 42);
      v12 = 1;
    }
    if ((_DWORD)v19)
      goto LABEL_29;
    goto LABEL_40;
  }
  v27 = (uint64_t (*)(uint64_t, _BYTE *))v10[9];
  if (v27 && CIDocCountsNonEmpty(&v69))
  {
    v28 = v10[10];
    v92 = v73;
    v93 = v74;
    v94 = v75;
    *(_OWORD *)buf = v69;
    *(_OWORD *)&buf[16] = v70;
    *(_OWORD *)&buf[32] = v71;
    v91 = v72;
    v29 = v27(v28, buf);
    if ((_DWORD)v29)
    {
      v19 = v29;
      v30 = *__error();
      v31 = _SILogForLogForCategory(11);
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315650;
        *(_QWORD *)&buf[4] = "_ContentIndexSyncIndexBulk";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 1612;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v19;
        _os_log_error_impl(&dword_1B8270000, v31, OS_LOG_TYPE_ERROR, "%s:%d: Got error %d passing sync counts to journals", buf, 0x18u);
      }
      *__error() = v30;
      *((_DWORD *)v10 + 42) = v19;
    }
    else
    {
      v19 = *((unsigned int *)v10 + 42);
    }
    goto LABEL_21;
  }
LABEL_40:
  if (!*((_BYTE *)v10 + 100))
  {
    v19 = 0;
    goto LABEL_46;
  }
  v32 = *((unsigned int *)v10 + 34);
  v33 = (uint64_t (*)(uint64_t))v10[6];
  v34 = v10[10];
  v65 = (void (*)(uint64_t))v10[8];
  v66 = (void (*)(uint64_t, _BYTE *))v10[9];
  v35 = v10[19];
  v36 = (uint64_t *)v10[18];
  v67 = *v10;
  v68 = (uint64_t (*)(uint64_t))v10[7];
  v37 = v10[16];
  v89 = 0;
  v87 = 0u;
  v88 = 0u;
  v85 = 0u;
  v86 = 0u;
  v83 = 0u;
  v84 = 0u;
  if (v33)
  {
    v38 = v33(v34);
    if ((_DWORD)v38)
    {
      v19 = v38;
      if ((_DWORD)v38 == 89)
      {
LABEL_44:
        v19 = 89;
        *((_DWORD *)v10 + 42) = 89;
        goto LABEL_29;
      }
      v41 = *__error();
      v42 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
        goto LABEL_54;
      v63 = *__error();
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = "indexShadowAndCommitBulk";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 1255;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v19;
      *(_WORD *)&buf[24] = 1024;
      *(_DWORD *)&buf[26] = v63;
      v44 = "%s:%d: preShadow error:%d %d";
LABEL_82:
      v60 = v42;
      v61 = 30;
      goto LABEL_83;
    }
  }
  v64 = v34;
  v19 = _indexShadowBulk(v32);
  if ((_DWORD)v19)
    goto LABEL_73;
  if (v68)
  {
    v40 = v68(v34);
    if ((_DWORD)v40)
    {
      v19 = v40;
      if ((_DWORD)v40 == 89)
        goto LABEL_44;
      v41 = *__error();
      v42 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
        goto LABEL_54;
      v43 = *__error();
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = "indexShadowAndCommitBulk";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 1272;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v19;
      *(_WORD *)&buf[24] = 1024;
      *(_DWORD *)&buf[26] = v43;
      v44 = "%s:%d: postShadow error:%d %d";
      goto LABEL_82;
    }
  }
  v80 = v87;
  v81 = v88;
  v82 = v89;
  v76 = v83;
  v77 = v84;
  v78 = v85;
  v79 = v86;
  if (!(_DWORD)v32)
  {
LABEL_64:
    if (v65)
      v65(v64);
    if (v66 && CIDocCountsNonEmpty(&v76))
    {
      v92 = v80;
      v93 = v81;
      v94 = v82;
      *(_OWORD *)buf = v76;
      *(_OWORD *)&buf[16] = v77;
      *(_OWORD *)&buf[32] = v78;
      v91 = v79;
      v66(v64, buf);
    }
    if (v67 && *(_QWORD *)(v67 + 8) && !*(_BYTE *)(v67 + 88))
    {
      ++*(_DWORD *)(v67 + 36);
      *(_QWORD *)(v67 + 48) = v37;
      v19 = _CIMetaInfoSync(v67, gTerminating == 0);
    }
    else
    {
      v19 = 0;
    }
    goto LABEL_73;
  }
  v45 = 0;
  v46 = 0;
  v47 = v32 << 12;
  while (1)
  {
    v48 = *v36;
    v49 = atomic_load((unsigned int *)(*v36 + 24));
    if (v49 != -1073623027)
      break;
LABEL_61:
    v45 += 4096;
    ++v36;
    if (v47 == v45)
    {
      if (v46)
        fd_sync(v46, 1);
      goto LABEL_64;
    }
  }
  v50 = indexCommitShadow(*v36, (_DWORD *)(v35 + (v45 & 0xFFFFF000)));
  if (!(_DWORD)v50)
  {
    v46 = *(_QWORD *)(v48 + 14432);
    goto LABEL_61;
  }
  v19 = v50;
  v41 = *__error();
  v59 = _SILogForLogForCategory(0);
  if (!os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
    goto LABEL_54;
  *(_DWORD *)buf = 136315906;
  *(_QWORD *)&buf[4] = "_indexCommitShadowBulk";
  *(_WORD *)&buf[12] = 1024;
  *(_DWORD *)&buf[14] = 1216;
  *(_WORD *)&buf[18] = 1024;
  *(_DWORD *)&buf[20] = v19;
  *(_WORD *)&buf[24] = 2080;
  *(_QWORD *)&buf[26] = v48 + 15168;
  v44 = "%s:%d: indexCommitShadow error: %d, %s";
  v60 = v59;
  v61 = 34;
LABEL_83:
  _os_log_error_impl(&dword_1B8270000, v60, OS_LOG_TYPE_ERROR, v44, buf, v61);
LABEL_54:
  *__error() = v41;
LABEL_73:
  *((_DWORD *)v10 + 42) = v19;
  if ((_DWORD)v19 && (_DWORD)v19 != 89)
  {
    v51 = *__error();
    v52 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
    {
      v62 = *((_DWORD *)v10 + 42);
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "_CISyncContextShadow";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 1561;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v62;
      _os_log_error_impl(&dword_1B8270000, v52, OS_LOG_TYPE_ERROR, "%s:%d: indexShadowAndCommitBulk error:%d", buf, 0x18u);
    }
    *__error() = v51;
    v19 = *((unsigned int *)v10 + 42);
  }
LABEL_29:
  if (!v12 && (_DWORD)v19)
  {
    v25 = *__error();
    v26 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      v57 = *((_DWORD *)v10 + 42);
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "_ContentIndexSyncIndexBulk";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 1628;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v57;
      _os_log_error_impl(&dword_1B8270000, v26, OS_LOG_TYPE_ERROR, "%s:%d: Sync shadow error: %d", buf, 0x18u);
    }
    *__error() = v25;
  }
LABEL_46:
  _CISyncContextDestroy((uint64_t)v10);
  return v19;
}

_QWORD *_CISyncContextCreate(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v14;
  int v15;
  _QWORD *v16;
  void *v17;
  uint64_t v18;
  __int128 v19;
  __int128 v20;
  int v21;

  if (a2)
  {
    v14 = *(_DWORD *)(a2 + 8);
    if (a3)
    {
LABEL_3:
      v15 = *(_DWORD *)(a3 + 8);
      goto LABEL_6;
    }
  }
  else
  {
    v14 = 0;
    if (a3)
      goto LABEL_3;
  }
  v15 = 0;
LABEL_6:
  v16 = malloc_type_calloc(1uLL, 0xB0uLL, 0x10B004080226B0FuLL);
  v17 = malloc_type_calloc((v15 + v14), 8uLL, 0x2004093837F09uLL);
  v16[18] = v17;
  *v16 = a1;
  *((_DWORD *)v16 + 2) = a4;
  v18 = *(_QWORD *)(a5 + 64);
  v20 = *(_OWORD *)(a5 + 32);
  v19 = *(_OWORD *)(a5 + 48);
  *((_OWORD *)v16 + 2) = *(_OWORD *)(a5 + 16);
  *((_OWORD *)v16 + 3) = v20;
  *((_OWORD *)v16 + 4) = v19;
  v16[10] = v18;
  *((_OWORD *)v16 + 1) = *(_OWORD *)a5;
  v16[11] = a6;
  v16[14] = a7;
  v16[15] = a8;
  *((_DWORD *)v16 + 32) = v14;
  *((_DWORD *)v16 + 33) = v15;
  v21 = GatherAndLockIndexes(a2, a3, (uint64_t)v17, (_DWORD *)v16 + 34);
  *((_DWORD *)v16 + 42) = v21;
  if (!v21)
  {
    v16[20] = malloc_type_calloc(*((unsigned int *)v16 + 34), 1uLL, 0x100004077774924uLL);
    v16[19] = malloc_type_calloc(*((unsigned int *)v16 + 34), 0x1000uLL, 0x376B23E8uLL);
  }
  return v16;
}

uint64_t _CISyncContextSync(uint64_t a1, _QWORD *a2)
{
  int v3;
  NSObject *v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t i;
  uint64_t v9;
  unsigned int v10;
  unint64_t v11;
  signed int v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int64x2_t v22;
  int64x2_t v23;
  int64x2_t v24;
  int64x2_t v25;
  int64x2_t v26;
  int64x2_t v27;
  int64x2_t **v28;
  uint64_t v29;
  int64x2_t *v30;
  int v31;
  NSObject *v32;
  int v33;
  int v34;
  const char *v35;
  NSObject *v36;
  uint32_t v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  void (*v46)(uint64_t);
  uint64_t v47;
  uint64_t (*v48)(uint64_t, uint64_t, _BYTE *);
  uint64_t v49;
  _BYTE buf[32];
  int64x2_t v51;
  int64x2_t v52;
  int64x2_t v53;
  int64x2_t v54;
  uint64_t v55;
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 168))
  {
    v3 = *__error();
    v4 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
LABEL_3:
      *__error() = v3;
      return *(unsigned int *)(a1 + 168);
    }
    v41 = *(_DWORD *)(a1 + 168);
    *(_DWORD *)buf = 136315650;
    *(_QWORD *)&buf[4] = "_CISyncContextSync";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 1384;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = v41;
    v35 = "%s:%d: pre-error:%d";
    goto LABEL_48;
  }
  v6 = *(unsigned int *)(a1 + 136);
  v46 = *(void (**)(uint64_t))(a1 + 16);
  v47 = *(_QWORD *)(a1 + 80);
  v48 = *(uint64_t (**)(uint64_t, uint64_t, _BYTE *))(a1 + 32);
  v7 = *(_QWORD *)(a1 + 144);
  if ((_DWORD)v6)
  {
    for (i = 0; i != v6; ++i)
    {
      v9 = *(_QWORD *)(v7 + 8 * i);
      pthread_mutex_lock((pthread_mutex_t *)(v9 + 14464));
      HIDWORD(v11) = qos_class_self() - 9;
      LODWORD(v11) = HIDWORD(v11);
      v10 = v11 >> 2;
      if (v10 > 6)
        v12 = 0;
      else
        v12 = dword_1B8630ED0[v10];
      if (*(_QWORD *)(v9 + 14648))
        goto LABEL_19;
      if (!*(_DWORD *)(v9 + 14660) && !*(_BYTE *)(v9 + 14676))
        goto LABEL_24;
      v13 = v12 <= 5 ? 5 : v12;
      v14 = (uint64_t *)(v9 + 16 * v12 + 14544);
      v15 = v13 - v12 + 1;
      while (--v15)
      {
        v16 = *v14;
        v14 += 2;
        if (v16)
          goto LABEL_19;
      }
      if (*(_QWORD *)(v9 + 16 * v12 + 14528) && !*(_DWORD *)(v9 + 14664))
LABEL_19:
        db_rwlock_wait(v9 + 14464, v12, 5);
      else
LABEL_24:
        *(int32x2_t *)(v9 + 14660) = vadd_s32(*(int32x2_t *)(v9 + 14660), (int32x2_t)0x100000001);
      pthread_mutex_unlock((pthread_mutex_t *)(v9 + 14464));
    }
  }
  *(_BYTE *)(a1 + 99) = 1;
  v17 = indexPrepareForSyncBulk(v6, v7, *(_DWORD **)(a1 + 88), *(_DWORD *)(a1 + 8), *(_QWORD *)(a1 + 112), *(_QWORD *)(a1 + 120));
  *(_DWORD *)(a1 + 168) = v17;
  if (v17 != 89)
  {
    if (v17)
    {
      v3 = *__error();
      v4 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        goto LABEL_3;
      v38 = *(_DWORD *)(a1 + 168);
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "_CISyncContextSync";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 1402;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v38;
      v35 = "%s:%d: indexPrepareForSyncBulk error:%d";
      goto LABEL_48;
    }
    if ((_DWORD)v6)
    {
      v18 = (uint64_t *)v7;
      v19 = v6;
      do
      {
        v20 = *v18++;
        db_read_lock(v20 + 4680);
        --v19;
      }
      while (v19);
    }
    *(_BYTE *)(a1 + 98) = 1;
    if (v46)
      v46(v47);
    *(_BYTE *)(a1 + 97) = 1;
    if (v48)
    {
      v21 = 0;
      v22 = 0uLL;
      v23 = 0uLL;
      v24 = 0uLL;
      v25 = 0uLL;
      v26 = 0uLL;
      v27 = 0uLL;
      if ((*(_BYTE *)(a1 + 8) & 6) == 0 && (_DWORD)v6)
      {
        v21 = 0;
        v28 = (int64x2_t **)v7;
        v29 = v6;
        do
        {
          v30 = *v28++;
          v25 = vaddq_s64(v30[934], v25);
          v22 = vaddq_s64(v30[931], v22);
          v24 = vaddq_s64(v30[933], v24);
          v23 = vaddq_s64(v30[932], v23);
          v26 = vaddq_s64(v30[935], v26);
          v27 = vaddq_s64(v30[936], v27);
          v21 += v30[937].i64[0];
          --v29;
        }
        while (v29);
      }
      *(int64x2_t *)buf = v22;
      *(int64x2_t *)&buf[16] = v23;
      v51 = v24;
      v52 = v25;
      v53 = v26;
      v54 = v27;
      v55 = v21;
      v31 = v48(v47, a1 + 104, buf);
      *(_DWORD *)(a1 + 168) = v31;
      if (v31)
      {
        if (v31 == 89)
          return *(unsigned int *)(a1 + 168);
        v3 = *__error();
        v32 = _SILogForLogForCategory(0);
        if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
          goto LABEL_3;
        v33 = *(_DWORD *)(a1 + 168);
        v34 = *__error();
        *(_DWORD *)buf = 136315906;
        *(_QWORD *)&buf[4] = "_CISyncContextSync";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 1431;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v33;
        *(_WORD *)&buf[24] = 1024;
        *(_DWORD *)&buf[26] = v34;
        v35 = "%s:%d: preSync error:%d %d";
        v36 = v32;
        v37 = 30;
        goto LABEL_49;
      }
    }
    v49 = 0;
    v39 = indexPerformSyncBulk(v6, v7, *(_DWORD **)(a1 + 88), *(_DWORD *)(a1 + 8), &v49);
    *(_DWORD *)(a1 + 168) = v39;
    if (v39)
    {
      if (v39 == 89)
        return *(unsigned int *)(a1 + 168);
      v3 = *__error();
      v4 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        goto LABEL_3;
      v40 = *(_DWORD *)(a1 + 168);
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "_CISyncContextSync";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 1442;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v40;
      v35 = "%s:%d: indexPerformSyncBulk error:%d";
LABEL_48:
      v36 = v4;
      v37 = 24;
LABEL_49:
      _os_log_error_impl(&dword_1B8270000, v36, OS_LOG_TYPE_ERROR, v35, buf, v37);
      goto LABEL_3;
    }
    if (a2)
    {
      *a2 = v49;
    }
    else if (v49)
    {
      fd_sync(v49, 1);
    }
    v42 = *(_DWORD *)(a1 + 8);
    if ((v42 & 4) == 0)
    {
      if ((v42 & 2) != 0 || !(_DWORD)v6)
      {
LABEL_60:
        if ((v42 & 2) == 0)
        {
          if (!gTerminating && !*(_DWORD *)(a1 + 168))
            *(_BYTE *)(a1 + 100) = 1;
          return *(unsigned int *)(a1 + 168);
        }
      }
      else
      {
        v43 = v6;
        v44 = v7;
        while (!*(_DWORD *)(*(_QWORD *)v44 + 15156))
        {
          v44 += 8;
          if (!--v43)
            goto LABEL_60;
        }
      }
      if ((_DWORD)v6)
      {
        do
        {
          if (!*(_DWORD *)(*(_QWORD *)v7 + 15156))
            *(_DWORD *)(*(_QWORD *)v7 + 15156) = 1;
          v7 += 8;
          --v6;
        }
        while (v6);
      }
      *(_DWORD *)(a1 + 168) = 0;
    }
  }
  return *(unsigned int *)(a1 + 168);
}

uint64_t _CISyncContextCommitData(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  int v4;
  NSObject *v5;
  uint64_t v9;
  uint64_t (*v10)(uint64_t, BOOL);
  uint64_t *v11;
  int v12;
  NSObject *v13;
  int v14;
  int v15;
  const char *v16;
  NSObject *v17;
  uint32_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  _BOOL4 v22;
  uint64_t v23;
  uint64_t v24;
  _BYTE *v25;
  uint64_t v26;
  unsigned int v27;
  char v28;
  char v29;
  unsigned int v30;
  int v31;
  uint64_t v32;
  int64x2_t v33;
  uint64_t v34;
  _DWORD *v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  int v39;
  int v40;
  NSObject *v41;
  int v42;
  NSObject *v43;
  int v44;
  int v45;
  char *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  char *v54;
  uint64_t v55;
  NSObject *log;
  int v57;
  uint64_t *v58;
  int v59;
  uint64_t v60;
  uint64_t v61;
  void *v62;
  _BYTE buf[12];
  __int16 v64;
  _BYTE v65[20];
  uint64_t v66;

  v66 = *MEMORY[0x1E0C80C00];
  if (*((_DWORD *)a1 + 42))
  {
    v4 = *__error();
    v5 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      goto LABEL_3;
    v45 = *((_DWORD *)a1 + 42);
    *(_DWORD *)buf = 136315650;
    *(_QWORD *)&buf[4] = "_CISyncContextCommitData";
    v64 = 1024;
    *(_DWORD *)v65 = 1491;
    *(_WORD *)&v65[4] = 1024;
    *(_DWORD *)&v65[6] = v45;
    v16 = "%s:%d: pre-error:%d";
LABEL_66:
    v17 = v5;
    v18 = 24;
    goto LABEL_67;
  }
  v9 = *((unsigned int *)a1 + 34);
  v10 = (uint64_t (*)(uint64_t, BOOL))a1[5];
  v11 = (uint64_t *)a1[18];
  if (v10)
  {
    v12 = v10(a1[10], (a1[1] & 6) != 0);
    *((_DWORD *)a1 + 42) = v12;
    if (v12)
    {
      if (v12 == 89)
        return *((unsigned int *)a1 + 42);
      v4 = *__error();
      v13 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        goto LABEL_3;
      v14 = *((_DWORD *)a1 + 42);
      v15 = *__error();
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = "_CISyncContextCommitData";
      v64 = 1024;
      *(_DWORD *)v65 = 1504;
      *(_WORD *)&v65[4] = 1024;
      *(_DWORD *)&v65[6] = v14;
      *(_WORD *)&v65[10] = 1024;
      *(_DWORD *)&v65[12] = v15;
      v16 = "%s:%d: postSync error:%d %d";
      v17 = v13;
      v18 = 30;
LABEL_67:
      _os_log_error_impl(&dword_1B8270000, v17, OS_LOG_TYPE_ERROR, v16, buf, v18);
      goto LABEL_3;
    }
  }
  v58 = a2;
  v19 = *((_DWORD *)a1 + 2);
  v20 = *a1;
  v21 = a1[16];
  if (*((_DWORD *)a1 + 26))
    v22 = 1;
  else
    v22 = (a1[1] & 6) == 0;
  v59 = v22;
  if (!(_DWORD)v9)
  {
    v24 = 0;
LABEL_56:
    if (v20 && v59 && *(_QWORD *)(v20 + 8) && !*(_BYTE *)(v20 + 88))
    {
      ++*(_DWORD *)(v20 + 32);
      *(_QWORD *)(v20 + 40) = v21;
      *((_BYTE *)a1 + 101) = 1;
    }
    *((_DWORD *)a1 + 42) = 0;
    if (v58)
    {
      *v58 = v24;
    }
    else if (v24)
    {
      fd_sync(v24, 1);
    }
    return *((unsigned int *)a1 + 42);
  }
  v23 = 0;
  v24 = 0;
  v25 = (_BYTE *)a1[20];
  v60 = a1[19];
  v61 = v9 << 12;
  while (1)
  {
    v26 = *v11;
    if ((v19 & 1) == 0)
    {
      v27 = atomic_load((unsigned int *)(v26 + 24));
      if (v27 == -1073623027)
      {
        if (!CIDocCountsNonEmpty((_QWORD *)(v26 + 14896)))
        {
          v28 = atomic_load((unsigned int *)(v26 + 28));
          if ((v28 & 1) == 0 || (v29 = atomic_load((unsigned int *)(v26 + 28)), (v29 & 2) != 0))
          {
            if (*v25)
            {
              v46 = __si_assert_copy_extra_268();
              v54 = v46;
              __message_assert_272((uint64_t)v46, v47, v48, v49, v50, v51, v52, v53, (char)"ContentIndex.c");
              free(v54);
              if (__valid_fs(-1))
                v55 = 2989;
              else
                v55 = 3072;
              *(_DWORD *)v55 = -559038737;
              abort();
            }
            goto LABEL_45;
          }
        }
      }
      else
      {
        v30 = atomic_load((unsigned int *)(v26 + 24));
        if ((v19 & 6) != 0 && v30 == 2)
          goto LABEL_45;
      }
    }
    if (v20)
    {
      *(_DWORD *)(v26 + 40) = *(_DWORD *)(v20 + 32) + 1;
      v59 = 1;
    }
    if (*(_BYTE *)(v26 + 15163))
      break;
    if (!*(_BYTE *)(v26 + 8))
      break;
    v31 = *(_DWORD *)(v26 + 15156);
    if (v31 == -1)
      break;
    v62 = (void *)(v60 + (v23 & 0xFFFFF000));
    if (dword_1EF19FCB4 >= 5)
    {
      v57 = *__error();
      log = _SILogForLogForCategory(10);
      if (os_log_type_enabled(log, OS_LOG_TYPE_DEFAULT))
      {
        v34 = *(_QWORD *)(v26 + 128);
        *(_DWORD *)buf = 134218242;
        *(_QWORD *)&buf[4] = v34;
        v64 = 2080;
        *(_QWORD *)v65 = v26 + 15168;
        _os_log_impl(&dword_1B8270000, log, OS_LOG_TYPE_DEFAULT, "bases.size: %ld (%s)", buf, 0x16u);
      }
      *__error() = v57;
      v31 = *(_DWORD *)(v26 + 15156);
      if ((v19 & 4) != 0)
        goto LABEL_37;
    }
    else if ((v19 & 4) != 0)
    {
      goto LABEL_37;
    }
    if (v31 != 1)
    {
      atomic_store(0xD00D0DD0, (unsigned int *)(v26 + 24));
      if (a3)
      {
        v32 = *(_QWORD *)(a3 + 40);
        *(_QWORD *)(a3 + 48) += *(_QWORD *)(v26 + 14944);
        *(int64x2_t *)(a3 + 24) = vaddq_s64(*(int64x2_t *)(a3 + 24), *(int64x2_t *)(v26 + 14920));
        *(_QWORD *)(a3 + 56) += *(_QWORD *)(v26 + 14952);
        *(int64x2_t *)a3 = vaddq_s64(*(int64x2_t *)a3, *(int64x2_t *)(v26 + 14896));
        *(_QWORD *)(a3 + 40) = v32 + *(_QWORD *)(v26 + 14936);
        *(_QWORD *)(a3 + 16) += *(_QWORD *)(v26 + 14912);
        v33 = *(int64x2_t *)(a3 + 80);
        *(int64x2_t *)(a3 + 64) = vaddq_s64(*(int64x2_t *)(a3 + 64), *(int64x2_t *)(v26 + 14960));
        *(int64x2_t *)(a3 + 80) = vaddq_s64(v33, *(int64x2_t *)(v26 + 14976));
        *(_QWORD *)(a3 + 96) += *(_QWORD *)(v26 + 14992);
        *(_QWORD *)(v26 + 14992) = 0;
        *(_OWORD *)(v26 + 14976) = 0u;
        *(_OWORD *)(v26 + 14960) = 0u;
        *(_OWORD *)(v26 + 14944) = 0u;
        *(_OWORD *)(v26 + 14928) = 0u;
        *(_OWORD *)(v26 + 14912) = 0u;
        *(_OWORD *)(v26 + 14896) = 0u;
      }
      goto LABEL_38;
    }
LABEL_37:
    atomic_store(2u, (unsigned int *)(v26 + 24));
LABEL_38:
    indexStoreToBuffer(v26, &v62);
    v35 = *(_DWORD **)(v26 + 14440);
    if (v35)
    {
      v36 = fd_pwrite(*(_QWORD *)(v26 + 14440), v60 + (v23 & 0xFFFFF000), 0x1000uLL, 0);
      if (v36 == -1)
      {
        v39 = *__error();
        if (v39)
          goto LABEL_51;
      }
      else
      {
        if (v36 != 4096)
          goto LABEL_50;
        *(_QWORD *)buf = 0;
        v37 = _fd_acquire_fd((uint64_t)v35, buf);
        if ((_DWORD)v37 != -1)
        {
          v38 = v37;
          prot_fsync(v37, 0);
          _fd_release_fd(v35, v38, 0, *(uint64_t *)buf);
        }
      }
    }
    *v25 |= 4u;
    v24 = *(_QWORD *)(v26 + 14432);
LABEL_45:
    v23 += 4096;
    ++v25;
    ++v11;
    if (v61 == v23)
      goto LABEL_56;
  }
  v40 = *__error();
  v41 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136315650;
    *(_QWORD *)&buf[4] = "indexCommitSync";
    v64 = 1024;
    *(_DWORD *)v65 = 2880;
    *(_WORD *)&v65[4] = 2080;
    *(_QWORD *)&v65[6] = v26 + 15168;
    _os_log_error_impl(&dword_1B8270000, v41, OS_LOG_TYPE_ERROR, "%s:%d: can't commit %s", buf, 0x1Cu);
  }
  *__error() = v40;
LABEL_50:
  v39 = -1;
LABEL_51:
  v42 = *__error();
  v43 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136315906;
    *(_QWORD *)&buf[4] = "indexCommitSyncBulk";
    v64 = 1024;
    *(_DWORD *)v65 = 1134;
    *(_WORD *)&v65[4] = 1024;
    *(_DWORD *)&v65[6] = v39;
    *(_WORD *)&v65[10] = 2080;
    *(_QWORD *)&v65[12] = v26 + 15168;
    _os_log_error_impl(&dword_1B8270000, v43, OS_LOG_TYPE_ERROR, "%s:%d: indexCommitSync error %d %s", buf, 0x22u);
  }
  *__error() = v42;
  *((_DWORD *)a1 + 42) = -1;
  v4 = *__error();
  v5 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    v44 = *((_DWORD *)a1 + 42);
    *(_DWORD *)buf = 136315650;
    *(_QWORD *)&buf[4] = "_CISyncContextCommitData";
    v64 = 1024;
    *(_DWORD *)v65 = 1515;
    *(_WORD *)&v65[4] = 1024;
    *(_DWORD *)&v65[6] = v44;
    v16 = "%s:%d: indexCommitSyncBulk error:%d";
    goto LABEL_66;
  }
LABEL_3:
  *__error() = v4;
  return *((unsigned int *)a1 + 42);
}

uint64_t _CISyncContextCommitHeader(uint64_t a1)
{
  int v2;
  NSObject *v3;
  uint64_t result;
  int v5;
  int v6;
  const char *v7;
  __int16 v8;
  int v9;
  __int16 v10;
  int v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 168))
  {
    v2 = *__error();
    v3 = _SILogForLogForCategory(11);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      v5 = *(_DWORD *)(a1 + 168);
      v6 = 136315650;
      v7 = "_CISyncContextCommitHeader";
      v8 = 1024;
      v9 = 1532;
      v10 = 1024;
      v11 = v5;
      _os_log_error_impl(&dword_1B8270000, v3, OS_LOG_TYPE_ERROR, "%s:%d: pre-error %d", (uint8_t *)&v6, 0x18u);
    }
    *__error() = v2;
    return *(unsigned int *)(a1 + 168);
  }
  else if (*(_BYTE *)(a1 + 101))
  {
    result = _CIMetaInfoSync(*(_QWORD *)a1, gTerminating == 0);
    *(_DWORD *)(a1 + 168) = result;
    *(_BYTE *)(a1 + 101) = 0;
  }
  else
  {
    return 0;
  }
  return result;
}

void _CISyncContextDestroy(uint64_t a1)
{
  int v2;
  uint64_t v3;
  void (*v4)(_QWORD);
  uint64_t v5;
  uint64_t v6;
  int v7;
  NSObject *v8;
  uint64_t v9;
  int v10;
  BOOL v11;
  uint64_t v12;
  uint64_t v13;
  int32x2_t v14;
  int v15;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  int v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v2 = *(_DWORD *)(a1 + 136);
    v3 = *(_QWORD *)(a1 + 144);
    if (*(_BYTE *)(a1 + 97))
    {
      v4 = *(void (**)(_QWORD))(a1 + 24);
      if (v4)
        v4(*(_QWORD *)(a1 + 80));
    }
    v5 = (v2 - 1);
    if (v2 - 1 >= 0)
    {
      v6 = (v2 - 1);
      do
      {
        if (!*(_DWORD *)(a1 + 168) && !*(_BYTE *)(*(_QWORD *)(v3 + 8 * v6) + 8))
        {
          v7 = *__error();
          v8 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315394;
            v17 = "_CISyncContextDestroy";
            v18 = 1024;
            v19 = 1335;
            _os_log_error_impl(&dword_1B8270000, v8, OS_LOG_TYPE_ERROR, "%s:%d: index invalid", buf, 0x12u);
          }
          *__error() = v7;
          *(_DWORD *)(a1 + 168) = -1;
        }
        if (*(_BYTE *)(a1 + 98))
        {
          v9 = *(_QWORD *)(v3 + 8 * v6);
          pthread_mutex_lock((pthread_mutex_t *)(v9 + 4680));
          v10 = *(_DWORD *)(v9 + 4876) - 1;
          *(_DWORD *)(v9 + 4876) = v10;
          if (!v10)
            db_rwlock_wakeup(v9 + 4680, 0, 0);
          pthread_mutex_unlock((pthread_mutex_t *)(v9 + 4680));
        }
        v11 = v6-- <= 0;
      }
      while (!v11);
      if (*(_BYTE *)(a1 + 99))
      {
        v12 = 8 * v5;
        do
        {
          v13 = *(_QWORD *)(v3 + v12) + 14464;
          pthread_mutex_lock((pthread_mutex_t *)v13);
          v14 = vadd_s32(*(int32x2_t *)(v13 + 196), (int32x2_t)-1);
          *(int32x2_t *)(v13 + 196) = v14;
          if (!v14.i32[0])
            db_rwlock_wakeup(v13, 0, 0);
          pthread_mutex_unlock((pthread_mutex_t *)v13);
          v12 -= 8;
        }
        while (v12 != -8);
      }
      v15 = *(_DWORD *)(a1 + 168);
      do
      {
        if (v15)
        {
          if (v15 != 89)
            *(_BYTE *)(*(_QWORD *)(v3 + 8 * v5) + 8) = 0;
        }
        pthread_mutex_unlock((pthread_mutex_t *)(*(_QWORD *)(v3 + 8 * v5) + 15080));
        v11 = v5-- <= 0;
      }
      while (!v11);
    }
    free(*(void **)(a1 + 144));
    free(*(void **)(a1 + 152));
    free(*(void **)(a1 + 160));
    free((void *)a1);
  }
}

uint64_t _indexShadowBulk(uint64_t a1)
{
  unsigned int v1;
  _DWORD *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _DWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  unsigned int v17;
  int v18;
  unint64_t v19;
  unsigned int v20;
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  void (*v25)(_QWORD);
  _DWORD *v26;
  uint64_t v27;
  int64x2_t v28;
  uint64_t v29;
  int v30;
  unsigned int v31;
  uint64_t v32;
  int v33;
  unsigned int v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  void (*v39)(_QWORD);
  uint64_t v40;
  uint64_t v41;
  int v42;
  NSObject *v43;
  os_log_type_t v44;
  _DWORD *v45;
  int v46;
  NSObject *v47;
  int v48;
  NSObject *v49;
  uint64_t v51;
  int v52;
  int v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  _DWORD *v58;
  uint64_t v59;
  unsigned int v60;
  unsigned int v61;
  unsigned int v62;
  unsigned int v63;
  void *v64;
  uint8_t buf[4];
  const char *v66;
  __int16 v67;
  int v68;
  __int16 v69;
  int v70;
  __int16 v71;
  uint64_t v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  uint64_t v79;
  uint64_t v80;

  v1 = MEMORY[0x1E0C80A78](a1);
  v51 = v5;
  v56 = v6;
  v57 = v7;
  v80 = *MEMORY[0x1E0C80C00];
  if (!v1)
    return 0;
  v8 = v4;
  v9 = v3;
  v10 = v2;
  v55 = v1;
  v11 = 0;
  v12 = 0;
  v58 = v2;
  while (1)
  {
    v54 = v11;
    v13 = *(_QWORD *)(v56 + 8 * v11);
    if (*v10 == 1)
      return 89;
    v14 = v12;
    if ((v9 & 1) == 0)
    {
      v15 = atomic_load((unsigned int *)(v13 + 24));
      if (v15 == -1073623027 && !*(_BYTE *)(v57 + v11) && !CIDocCountsNonEmpty((_QWORD *)(v13 + 14896)))
      {
        v41 = v14;
        goto LABEL_26;
      }
    }
    if (!*(_BYTE *)(v13 + 8))
      break;
    v16 = v13;
    v59 = v14;
    do
    {
      v17 = __ldxr(exceptionSequenceNum);
      v18 = v17 + 1;
    }
    while (__stxr(v17 + 1, exceptionSequenceNum));
    v19 = setThreadIdAndInfo(-1, (__int128 *)sIndexExceptionCallbacks, v13, 0, v18);
    v62 = HIDWORD(v19);
    v63 = v19;
    v60 = v21;
    v61 = v20;
    v22 = *(_QWORD *)&threadData[18 * v19 + 2];
    v23 = v22 + 320 * HIDWORD(v19);
    *(_BYTE *)(v23 + 216) = 0;
    v24 = *(_DWORD *)(v23 + 312);
    v25 = *(void (**)(_QWORD))(v23 + 224);
    if (v25)
      v25(*(_QWORD *)(v22 + 320 * HIDWORD(v19) + 288));
    if (_setjmp((int *)v23))
    {
      v45 = (_DWORD *)(v23 + 312);
      v46 = *__error();
      v47 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        v66 = "_indexShadowBulk";
        v67 = 1024;
        v68 = 1188;
        _os_log_error_impl(&dword_1B8270000, v47, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
      }
      *__error() = v46;
      *v45 = v24;
      CIOnThreadCleanUpReset(v60);
      dropThreadId(v63, 1, v18);
      CICleanUpReset(v63, v61);
      v40 = 0xFFFFFFFFLL;
LABEL_38:
      v14 = v59;
      goto LABEL_39;
    }
    v52 = v24;
    v53 = v18;
    v26 = (_DWORD *)(v51 + ((_DWORD)v11 << 12));
    if (v8)
    {
      v27 = *(_QWORD *)(v8 + 40);
      *(_QWORD *)(v8 + 48) += *(_QWORD *)(v13 + 14944);
      *(int64x2_t *)(v8 + 24) = vaddq_s64(*(int64x2_t *)(v8 + 24), *(int64x2_t *)(v13 + 14920));
      *(_QWORD *)(v8 + 56) += *(_QWORD *)(v13 + 14952);
      *(int64x2_t *)v8 = vaddq_s64(*(int64x2_t *)v8, *(int64x2_t *)(v13 + 14896));
      *(_QWORD *)(v8 + 40) = v27 + *(_QWORD *)(v13 + 14936);
      *(_QWORD *)(v8 + 16) += *(_QWORD *)(v13 + 14912);
      v28 = *(int64x2_t *)(v8 + 80);
      *(int64x2_t *)(v8 + 64) = vaddq_s64(*(int64x2_t *)(v8 + 64), *(int64x2_t *)(v13 + 14960));
      *(int64x2_t *)(v8 + 80) = vaddq_s64(v28, *(int64x2_t *)(v13 + 14976));
      *(_QWORD *)(v8 + 96) += *(_QWORD *)(v13 + 14992);
      *(_QWORD *)(v13 + 14992) = 0;
      *(_OWORD *)(v13 + 14976) = 0u;
      *(_OWORD *)(v13 + 14960) = 0u;
      *(_OWORD *)(v13 + 14944) = 0u;
      *(_OWORD *)(v13 + 14928) = 0u;
      *(_OWORD *)(v13 + 14912) = 0u;
      *(_OWORD *)(v13 + 14896) = 0u;
      v29 = v9;
      v30 = *(unsigned __int8 *)(v13 + 37);
      if (*(_BYTE *)(v13 + 37))
        v31 = 111;
      else
        v31 = 95;
      v32 = v13;
      if (*(_BYTE *)(v13 + 37))
        v33 = 114;
      else
        v33 = 102;
      bzero(buf, 0x4040uLL);
      v64 = v26;
      v34 = v33;
      v13 = v32;
      v35 = v30;
      v9 = v29;
      indexRestoreFromBuffer((uint64_t)buf, (unsigned int **)&v64, *(_DWORD *)(v16 + 4), v31, v34, 0, v35);
      v73 = 0u;
      v74 = 0u;
      v75 = 0u;
      v76 = 0u;
      v77 = 0u;
      v78 = 0u;
      v79 = 0;
      v64 = v26;
      indexStoreToBuffer((uint64_t)buf, &v64);
    }
    v10 = v58;
    v36 = indexShadowFiles(v16, v9, v26, v58);
    v37 = *(_QWORD *)&threadData[18 * v63 + 2];
    v38 = v37 + 320 * v62;
    *(_DWORD *)(v38 + 312) = v52;
    v39 = *(void (**)(_QWORD))(v38 + 232);
    if (v39)
      v39(*(_QWORD *)(v37 + 320 * v62 + 288));
    v40 = v36;
    dropThreadId(v63, 0, v53);
    if ((_DWORD)v36)
    {
      if ((_DWORD)v36 == 89)
        return v40;
      goto LABEL_38;
    }
    v41 = *(_QWORD *)(v16 + 14432);
LABEL_26:
    v11 = v54 + 1;
    v12 = v41;
    if (v54 + 1 == v55)
    {
      v40 = 0;
      goto LABEL_42;
    }
  }
  v42 = *__error();
  v43 = _SILogForLogForCategory(0);
  v44 = 2 * (gSILogLevels[0] < 4);
  if (os_log_type_enabled(v43, v44))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1B8270000, v43, v44, "Skipping because index is shut down", buf, 2u);
  }
  *__error() = v42;
  v40 = 0xFFFFFFFFLL;
LABEL_39:
  v48 = *__error();
  v49 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136315906;
    v66 = "_indexShadowBulk";
    v68 = 1191;
    v67 = 1024;
    v69 = 1024;
    v70 = v40;
    v71 = 2080;
    v72 = v13 + 15168;
    _os_log_error_impl(&dword_1B8270000, v49, OS_LOG_TYPE_ERROR, "%s:%d: indexShadowFiles error: %d, %s", buf, 0x22u);
  }
  *__error() = v48;
  v41 = v14;
  if ((_DWORD)v40)
    return v40;
LABEL_42:
  if (!v41)
    return v40;
  fd_sync(v41, 1);
  return 0;
}

uint64_t indexPrepareForSyncBulk(uint64_t result, uint64_t a2, _DWORD *a3, int a4, uint64_t a5, uint64_t a6)
{
  uint64_t v7;
  int v8;
  uint64_t v9;
  _DWORD *v10;
  int64x2_t *v11;
  char v12;
  unsigned int v13;
  _QWORD *v14;
  unsigned int v15;
  unsigned int v16;
  int v17;
  unint64_t v18;
  unsigned int v19;
  unsigned int v20;
  _DWORD *v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  void (*v25)(_QWORD);
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  void (*v30)(_QWORD);
  uint64_t v31;
  __int32 v32;
  unsigned int v33;
  int v34;
  NSObject *v35;
  uint64_t v36;
  char v37;
  uint64_t v38;
  uint64_t v39;
  int64x2_t v40;
  int64x2_t v41;
  int64x2_t v42;
  int64x2_t v43;
  int64x2_t v44;
  int v45;
  NSObject *v46;
  os_log_type_t v47;
  int v48;
  NSObject *v49;
  uint64_t v50;
  int v51;
  NSObject *v52;
  unsigned int v53;
  NSObject *log;
  uint64_t v55;
  int v56;
  unsigned int v61;
  unsigned int v62;
  unsigned int v63;
  unsigned int v64;
  uint8_t buf[4];
  const char *v66;
  __int16 v67;
  int v68;
  __int16 v69;
  _BYTE v70[14];
  uint64_t v71;

  v71 = *MEMORY[0x1E0C80C00];
  if (!(_DWORD)result)
    return result;
  v7 = 0;
  v8 = a4 & 6;
  v9 = result;
  v56 = v8;
  v10 = threadData;
  v55 = result;
  while (1)
  {
    v11 = *(int64x2_t **)(a2 + 8 * v7);
    v12 = atomic_load(&v11[1].u32[3]);
    if ((v12 & 2) != 0)
      goto LABEL_24;
    v13 = atomic_load(&v11[1].u32[2]);
    if (v13 == -1073623027)
    {
      v14 = (_QWORD *)v11[897].i64[0];
      if (v14
        && !(v14[21]
           + v14[18]
           + v14[15]
           + v14[19]
           + v14[22]
           + v14[16]
           + v14[20]
           + v14[23]
           + v14[17]
           + v14[24]
           + v14[25]
           + v14[26]
           + v14[27]))
      {
        goto LABEL_24;
      }
    }
    else
    {
      v15 = atomic_load(&v11[1].u32[2]);
      if (v15 == 2)
      {
        if (v56)
          goto LABEL_24;
      }
      else if (*a3 == 1)
      {
        return 89;
      }
    }
    if (!v11->i8[8])
      break;
    do
    {
      v16 = __ldxr(exceptionSequenceNum);
      v17 = v16 + 1;
    }
    while (__stxr(v16 + 1, exceptionSequenceNum));
    v18 = setThreadIdAndInfo(-1, (__int128 *)sIndexExceptionCallbacks, (uint64_t)v11, 0, v17);
    v63 = HIDWORD(v18);
    v64 = v18;
    v61 = v20;
    v62 = v19;
    v21 = v10;
    v22 = *(_QWORD *)&v10[18 * v18 + 2];
    v23 = v22 + 320 * HIDWORD(v18);
    *(_BYTE *)(v23 + 216) = 0;
    v24 = *(_DWORD *)(v23 + 312);
    v25 = *(void (**)(_QWORD))(v23 + 224);
    if (v25)
      v25(*(_QWORD *)(v22 + 320 * HIDWORD(v18) + 288));
    if (_setjmp((int *)v23))
    {
      v48 = *__error();
      v49 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        v66 = "indexPrepareForSyncBulk";
        v67 = 1024;
        v68 = 1042;
        _os_log_error_impl(&dword_1B8270000, v49, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
      }
      *__error() = v48;
      *(_DWORD *)(v23 + 312) = v24;
      CIOnThreadCleanUpReset(v61);
      dropThreadId(v64, 1, v17);
      CICleanUpReset(v64, v62);
      goto LABEL_52;
    }
    v26 = v11[897].i64[0];
    if (!v26)
      goto LABEL_20;
    v10 = v21;
    if (v11[947].i8[11])
      goto LABEL_19;
    if (v11->i8[8])
    {
      v32 = v11[947].i32[1];
      v26 = 4294967294;
      if (v32 != -1 && v32 != 1)
      {
        if (!a4)
        {
          atomic_load(&v11[1].u32[2]);
LABEL_35:
          ++v11[1019].i64[0];
          v33 = index_FlushCache((uint64_t)v11, 1, a5, a6, (uint64_t)&__block_literal_global_2368);
          if (!v33)
            goto LABEL_19;
          v53 = v33;
          v34 = *__error();
          v35 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315906;
            v66 = "indexPrepareForSync";
            v67 = 1024;
            v68 = 2753;
            v69 = 2080;
            *(_QWORD *)v70 = v11 + 948;
            *(_WORD *)&v70[8] = 1024;
            *(_DWORD *)&v70[10] = 2753;
            _os_log_error_impl(&dword_1B8270000, v35, OS_LOG_TYPE_ERROR, "%s:%d: %s marking invalid at %d", buf, 0x22u);
          }
          v36 = v53;
          goto LABEL_44;
        }
        if ((a4 & 2) != 0)
        {
          v11[947].i32[1] = 1;
        }
        else if ((a4 & 4) == 0)
        {
          goto LABEL_35;
        }
        v37 = atomic_load(&v11[1].u32[3]);
        if ((v37 & 2) != 0)
        {
LABEL_19:
          v26 = 0;
          goto LABEL_21;
        }
        v38 = v11[897].i64[0];
        v39 = v11[937].i64[0] + *(_QWORD *)(v38 + 216);
        v40 = *(int64x2_t *)(v38 + 120);
        v41 = *(int64x2_t *)(v38 + 136);
        v42 = *(int64x2_t *)(v38 + 152);
        v43 = *(int64x2_t *)(v38 + 184);
        v44 = *(int64x2_t *)(v38 + 200);
        v11[934] = vaddq_s64(v11[934], *(int64x2_t *)(v38 + 168));
        v11[931] = vaddq_s64(v11[931], v40);
        v11[933] = vaddq_s64(v11[933], v42);
        v11[932] = vaddq_s64(v11[932], v41);
        v11[935] = vaddq_s64(v11[935], v43);
        v11[936] = vaddq_s64(v11[936], v44);
        v11[937].i64[0] = v39;
        *(_QWORD *)(v38 + 216) = 0;
        *(_OWORD *)(v38 + 200) = 0u;
        *(_OWORD *)(v38 + 184) = 0u;
        *(_OWORD *)(v38 + 168) = 0u;
        *(_OWORD *)(v38 + 152) = 0u;
        *(_OWORD *)(v38 + 136) = 0u;
        *(_OWORD *)(v38 + 120) = 0u;
        v36 = indexFastFlush((uint64_t)v11, (_DWORD *)v11[897].i64[0]);
        if ((_DWORD)v36)
        {
          v34 = *__error();
          log = _SILogForLogForCategory(0);
          if (os_log_type_enabled(log, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315906;
            v66 = "indexPrepareForSync";
            v67 = 1024;
            v68 = 2779;
            v69 = 2080;
            *(_QWORD *)v70 = v11 + 948;
            *(_WORD *)&v70[8] = 1024;
            *(_DWORD *)&v70[10] = 2779;
            _os_log_error_impl(&dword_1B8270000, log, OS_LOG_TYPE_ERROR, "%s:%d: %s marking invalid at %d", buf, 0x22u);
          }
LABEL_44:
          *__error() = v34;
          v11->i8[8] = 0;
          v26 = v36;
LABEL_20:
          v10 = v21;
          goto LABEL_21;
        }
        v26 = v36;
      }
    }
    else
    {
      v26 = 4294967294;
    }
LABEL_21:
    v27 = v26;
    v28 = *(_QWORD *)&v10[18 * v64 + 2];
    v29 = v28 + 320 * v63;
    *(_DWORD *)(v29 + 312) = v24;
    v30 = *(void (**)(_QWORD))(v29 + 232);
    if (v30)
      v30(*(_QWORD *)(v28 + 320 * v63 + 288));
    dropThreadId(v64, 0, v17);
    v31 = v27;
    v9 = v55;
    if ((_DWORD)v27)
      goto LABEL_53;
LABEL_24:
    if (++v7 == v9)
      return 0;
  }
  v45 = *__error();
  v46 = _SILogForLogForCategory(0);
  v47 = 2 * (gSILogLevels[0] < 4);
  if (os_log_type_enabled(v46, v47))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1B8270000, v46, v47, "Skipping because index is shut down", buf, 2u);
  }
  *__error() = v45;
LABEL_52:
  v31 = 0xFFFFFFFFLL;
LABEL_53:
  v50 = v31;
  v51 = *__error();
  v52 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136315906;
    v66 = "indexPrepareForSyncBulk";
    v67 = 1024;
    v68 = 1044;
    v69 = 1024;
    *(_DWORD *)v70 = v50;
    *(_WORD *)&v70[4] = 2080;
    *(_QWORD *)&v70[6] = v11 + 948;
    _os_log_error_impl(&dword_1B8270000, v52, OS_LOG_TYPE_ERROR, "%s:%d: indexPrepareForSync error: %d, %s", buf, 0x22u);
  }
  *__error() = v51;
  return v50;
}

uint64_t indexPerformSyncBulk(unsigned int a1, uint64_t a2, _DWORD *a3, char a4, uint64_t *a5)
{
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  unsigned int v15;
  int v16;
  unint64_t v17;
  unsigned int v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  void (*v23)(_QWORD);
  uint64_t v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void (*v29)(_QWORD);
  uint64_t v30;
  uint64_t *v31;
  uint64_t v32;
  int v33;
  NSObject *v34;
  os_log_type_t v35;
  int v36;
  NSObject *v37;
  int v38;
  NSObject *v39;
  uint64_t v41;
  int v42;
  unsigned int v44;
  unsigned int v45;
  unsigned int v46;
  unsigned int v47;
  uint8_t buf[4];
  const char *v49;
  __int16 v50;
  int v51;
  __int16 v52;
  int v53;
  __int16 v54;
  uint64_t v55;
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0;
  v7 = 0;
  v8 = a4 & 6;
  v9 = a1;
  v10 = 0;
  v42 = v8;
  v41 = a1;
  while (1)
  {
    v11 = *(_QWORD *)(a2 + 8 * v7);
    if (*a3 == 1)
      return 89;
    v12 = atomic_load((unsigned int *)(v11 + 24));
    if (v12 != -1073623027)
    {
      v13 = atomic_load((unsigned int *)(v11 + 24));
      if (!v8 || v13 != 2)
        break;
    }
    v14 = v10;
LABEL_20:
    ++v7;
    v10 = v14;
    if (v7 == v9)
    {
      v30 = 0;
      v31 = a5;
      goto LABEL_35;
    }
  }
  if (!*(_BYTE *)(v11 + 8))
  {
    v33 = *__error();
    v34 = _SILogForLogForCategory(0);
    v35 = 2 * (gSILogLevels[0] < 4);
    if (os_log_type_enabled(v34, v35))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1B8270000, v34, v35, "Skipping because index is shut down", buf, 2u);
    }
    *__error() = v33;
    goto LABEL_31;
  }
  do
  {
    v15 = __ldxr(exceptionSequenceNum);
    v16 = v15 + 1;
  }
  while (__stxr(v15 + 1, exceptionSequenceNum));
  v17 = setThreadIdAndInfo(-1, (__int128 *)sIndexExceptionCallbacks, v11, 0, v16);
  v46 = HIDWORD(v17);
  v47 = v17;
  v44 = v19;
  v45 = v18;
  v20 = *(_QWORD *)&threadData[18 * v17 + 2];
  v21 = v20 + 320 * HIDWORD(v17);
  *(_BYTE *)(v21 + 216) = 0;
  v22 = *(_DWORD *)(v21 + 312);
  v23 = *(void (**)(_QWORD))(v21 + 224);
  if (v23)
    v23(*(_QWORD *)(v20 + 320 * HIDWORD(v17) + 288));
  if (_setjmp((int *)v21))
  {
    v36 = *__error();
    v37 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v49 = "indexPerformSyncBulk";
      v50 = 1024;
      v51 = 1079;
      _os_log_error_impl(&dword_1B8270000, v37, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
    }
    *__error() = v36;
    *(_DWORD *)(v21 + 312) = v22;
    CIOnThreadCleanUpReset(v44);
    dropThreadId(v47, 1, v16);
    CICleanUpReset(v47, v45);
LABEL_31:
    v32 = 4294967293;
    goto LABEL_32;
  }
  v24 = indexPerformSync(v11);
  v25 = v22;
  v26 = v24;
  v27 = *(_QWORD *)&threadData[18 * v47 + 2];
  v28 = v27 + 320 * v46;
  *(_DWORD *)(v28 + 312) = v25;
  v29 = *(void (**)(_QWORD))(v28 + 232);
  if (v29)
    v29(*(_QWORD *)(v27 + 320 * v46 + 288));
  v30 = v26;
  dropThreadId(v47, 0, v16);
  if (!(_DWORD)v26)
  {
    if (*(_QWORD *)(v11 + 14432))
      v14 = *(_QWORD *)(v11 + 14432);
    else
      v14 = v10;
    v8 = v42;
    v9 = v41;
    goto LABEL_20;
  }
  if ((_DWORD)v26 == 89)
    return v30;
  v32 = v26;
LABEL_32:
  v31 = a5;
  v38 = *__error();
  v39 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136315906;
    v49 = "indexPerformSyncBulk";
    v51 = 1082;
    v50 = 1024;
    v52 = 1024;
    v53 = v32;
    v54 = 2080;
    v55 = v11 + 15168;
    _os_log_error_impl(&dword_1B8270000, v39, OS_LOG_TYPE_ERROR, "%s:%d: indexPerformSync error: %d, %s", buf, 0x22u);
  }
  *__error() = v38;
  v14 = v10;
  v30 = v32;
  if ((_DWORD)v32)
    return v30;
LABEL_35:
  if (!v14)
    return v30;
  if (v31)
    *v31 = v14;
  else
    fd_sync(v14, 1);
  return 0;
}

uint64_t GatherAndLockIndexes(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  uint64_t v7;
  unint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v14;
  uint64_t v15;

  v14 = a3;
  v15 = 0;
  *a4 = 0;
  if (!a1)
  {
    if (!a2)
    {
      v9 = 0;
      goto LABEL_19;
    }
LABEL_9:
    if (*(_DWORD *)(a2 + 8))
    {
      v8 = 0;
      do
      {
        if ((gatherAndLockIndexCallback(*(_QWORD *)(*(_QWORD *)a2 + 8 * v8), (uint64_t)&v14) & 1) == 0)
          break;
        ++v8;
      }
      while (v8 < *(unsigned int *)(a2 + 8));
    }
    goto LABEL_13;
  }
  if (!*(_DWORD *)(a1 + 8))
  {
LABEL_6:
    if (!a2)
      goto LABEL_13;
    goto LABEL_9;
  }
  v7 = 0;
  while ((gatherAndLockIndexCallback(*(_QWORD *)(*(_QWORD *)a1 + 8 * v7), (uint64_t)&v14) & 1) != 0)
  {
    if (++v7 >= (unint64_t)*(unsigned int *)(a1 + 8))
      goto LABEL_6;
  }
LABEL_13:
  v9 = v15;
  v10 = HIDWORD(v15);
  if (!HIDWORD(v15))
  {
LABEL_19:
    v10 = 0;
    *a4 = v9;
    return v10;
  }
  if ((int)v15 - 1 >= 0)
  {
    v11 = v14;
    v12 = 8 * (v15 - 1);
    do
    {
      pthread_mutex_unlock((pthread_mutex_t *)(*(_QWORD *)(v11 + v12) + 15080));
      v12 -= 8;
    }
    while (v12 != -8);
  }
  return v10;
}

uint64_t gatherAndLockIndexCallback(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  int v5;
  int v6;
  NSObject *v7;
  int *v8;
  uint64_t v9;
  int v10;
  const char *v11;
  __int16 v12;
  int v13;
  __int16 v14;
  uint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)(a1 + 8))
  {
    v6 = *__error();
    v7 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      v10 = 136315650;
      v11 = "gatherAndLockIndexCallback";
      v12 = 1024;
      v13 = 972;
      v14 = 2080;
      v15 = a1 + 15168;
      _os_log_error_impl(&dword_1B8270000, v7, OS_LOG_TYPE_ERROR, "%s:%d: index invalid %s", (uint8_t *)&v10, 0x1Cu);
    }
    v8 = __error();
    result = 0;
    *v8 = v6;
    v5 = -1;
    goto LABEL_7;
  }
  if (*(_DWORD *)(a1 + 15156) == 1)
  {
    result = 0;
    v5 = 22;
LABEL_7:
    *(_DWORD *)(a2 + 12) = v5;
    return result;
  }
  if (!*(_BYTE *)(a1 + 15163))
  {
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 15080));
    v9 = *(unsigned int *)(a2 + 8);
    *(_QWORD *)(*(_QWORD *)a2 + 8 * v9) = a1;
    *(_DWORD *)(a2 + 8) = v9 + 1;
  }
  return 1;
}

_DWORD *_CIEnsureOpenFiles(uint64_t a1)
{
  _DWORD *result;
  uint64_t v3;

  fd_warmup(*(_DWORD **)(a1 + 4656));
  fd_warmup(*(_DWORD **)(a1 + 200));
  result = fd_warmup(*(_DWORD **)(a1 + 464));
  v3 = *(_QWORD *)(a1 + 4904);
  if (v3)
    return fd_warmup(*(_DWORD **)(v3 + 224));
  return result;
}

uint64_t _CIListsClean(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  char *v5;
  size_t v6;
  int v7;
  unsigned int v8;
  BOOL v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _BOOL4 v13;
  char v14;
  uint64_t v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  uint64_t v19;
  _OWORD v21[6];
  uint64_t v22;
  unsigned int v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v23 = 0;
  MEMORY[0x1E0C80A78](a1);
  v5 = (char *)v21 - v4;
  bzero((char *)v21 - v4, v6);
  v7 = GatherAndLockIndexes(a1, a2, (uint64_t)v5, &v23);
  v8 = v23;
  if (v7)
    v9 = 1;
  else
    v9 = v23 == 0;
  if (v9)
  {
    v10 = 1;
  }
  else
  {
    v11 = 0;
    while (1)
    {
      v12 = *(_QWORD *)&v5[8 * v11];
      v13 = CIDocCountsNonEmpty((_QWORD *)(v12 + 14896));
      if (v13)
      {
LABEL_12:
        v10 = !v13;
        goto LABEL_13;
      }
      v14 = atomic_load((unsigned int *)(v12 + 28));
      if ((v14 & 2) == 0)
      {
        v15 = *(_QWORD *)(v12 + 14352);
        if (v15)
        {
          v16 = *(_OWORD *)(v15 + 168);
          v17 = *(_OWORD *)(v15 + 200);
          v21[4] = *(_OWORD *)(v15 + 184);
          v21[5] = v17;
          v22 = *(_QWORD *)(v15 + 216);
          v18 = *(_OWORD *)(v15 + 136);
          v21[0] = *(_OWORD *)(v15 + 120);
          v21[1] = v18;
          v21[2] = *(_OWORD *)(v15 + 152);
          v21[3] = v16;
          if (CIDocCountsNonEmpty(v21))
            break;
        }
      }
      ++v11;
      v8 = v23;
      if (v11 >= v23)
        goto LABEL_12;
    }
    v10 = 0;
    v8 = v23;
  }
LABEL_13:
  if ((int)(v8 - 1) >= 0)
  {
    v19 = 8 * (v8 - 1);
    do
    {
      pthread_mutex_unlock((pthread_mutex_t *)(*(_QWORD *)&v5[v19] + 15080));
      v19 -= 8;
    }
    while (v19 != -8);
  }
  return v10;
}

uint64_t _CICompact(uint64_t a1, _OWORD *a2, char a3, _BYTE *a4)
{
  int v7;
  unsigned int v8;
  int v9;
  unint64_t v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  void (*v16)(_QWORD);
  int v17;
  NSObject *v18;
  int v19;
  NSObject *v20;
  os_log_type_t v21;
  uint64_t v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;
  void (*v26)(_QWORD);
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  _BYTE buf[32];
  char v33[1024];
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  if (a4)
    *a4 = 0;
  bzero(v33, 0x400uLL);
  if ((a3 & 1) == 0 || *(_BYTE *)(a1 + 37) || confstr(65537, v33, 0x400uLL) - 1 > 0x3FF)
    v7 = -1;
  else
    v7 = open(v33, 4);
  if (!*(_BYTE *)(a1 + 8))
  {
    v19 = *__error();
    v20 = _SILogForLogForCategory(0);
    v21 = 2 * (gSILogLevels[0] < 4);
    if (os_log_type_enabled(v20, v21))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1B8270000, v20, v21, "Skipping because index is shut down", buf, 2u);
    }
    *__error() = v19;
    goto LABEL_19;
  }
  do
  {
    v8 = __ldxr(exceptionSequenceNum);
    v9 = v8 + 1;
  }
  while (__stxr(v8 + 1, exceptionSequenceNum));
  v10 = setThreadIdAndInfo(-1, (__int128 *)sIndexExceptionCallbacks, a1, 0, v9);
  v30 = HIDWORD(v10);
  v31 = v10;
  v28 = v12;
  v29 = v11;
  v13 = *(_QWORD *)&threadData[18 * v10 + 2];
  v14 = v13 + 320 * HIDWORD(v10);
  *(_BYTE *)(v14 + 216) = 1;
  v15 = *(_DWORD *)(v14 + 312);
  v16 = *(void (**)(_QWORD))(v14 + 224);
  if (v16)
    v16(*(_QWORD *)(v13 + 320 * HIDWORD(v10) + 288));
  if (_setjmp((int *)v14))
  {
    v17 = *__error();
    v18 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "_CICompact";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 1720;
      _os_log_error_impl(&dword_1B8270000, v18, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
    }
    *__error() = v17;
    *(_DWORD *)(v14 + 312) = v15;
    CIOnThreadCleanUpReset(v28);
    dropThreadId(v31, 1, v9);
    CICleanUpReset(v31, v29);
LABEL_19:
    v22 = 0xFFFFFFFFLL;
    goto LABEL_23;
  }
  v23 = a2[1];
  *(_OWORD *)buf = *a2;
  *(_OWORD *)&buf[16] = v23;
  v22 = index_compact(a1);
  v24 = *(_QWORD *)&threadData[18 * v31 + 2];
  v25 = v24 + 320 * v30;
  *(_DWORD *)(v25 + 312) = v15;
  v26 = *(void (**)(_QWORD))(v25 + 232);
  if (v26)
    v26(*(_QWORD *)(v24 + 320 * v30 + 288));
  dropThreadId(v31, 0, v9);
LABEL_23:
  if (v7 != -1)
    close(v7);
  return v22;
}

uint64_t _CIMakeInvalid(uint64_t a1)
{
  uint64_t v2;
  int v3;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  stat v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v2 = a1 + 14680;
  _db_write_lock(a1 + 14680);
  v3 = *__error();
  v4 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    v8.st_dev = 136315906;
    *(_QWORD *)&v8.st_mode = "indexMakeInvalid";
    WORD2(v8.st_ino) = 1024;
    *(_DWORD *)((char *)&v8.st_ino + 6) = 2547;
    HIWORD(v8.st_uid) = 2080;
    *(_QWORD *)&v8.st_gid = a1 + 15168;
    *((_WORD *)&v8.st_rdev + 2) = 1024;
    *(dev_t *)((char *)&v8.st_rdev + 6) = 2547;
    _os_log_error_impl(&dword_1B8270000, v4, OS_LOG_TYPE_ERROR, "%s:%d: %s marking invalid at %d", (uint8_t *)&v8, 0x22u);
  }
  *__error() = v3;
  *(_BYTE *)(a1 + 8) = 0;
  v5 = *(unsigned int *)(a1 + 56);
  memset(&v8, 0, sizeof(v8));
  if (!fstat(v5, &v8))
  {
    v6 = open(".", 4);
    if (!MEMORY[0x1BCCB1484](v5))
    {
      bzero(&v8, 0x400uLL);
      snprintf((char *)&v8, 0x400uLL, "%s%s", (const char *)(a1 + 15168), "indexHead");
      unlink((const char *)&v8);
      snprintf((char *)&v8, 0x400uLL, "%s%s", (const char *)(a1 + 15168), "shadowIndexHead");
      unlink((const char *)&v8);
      MEMORY[0x1BCCB1484](v6);
    }
    if ((v6 & 0x80000000) == 0)
      close(v6);
  }
  return db_write_unlock(v2);
}

uint64_t ContentIndexVerifyIndex(uint64_t a1)
{
  unsigned int v2;
  int v3;
  unint64_t v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  void (*v10)(_QWORD);
  int v11;
  NSObject *v12;
  int v13;
  NSObject *v14;
  os_log_type_t v15;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void (*v20)(_QWORD);
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  uint8_t buf[4];
  const char *v26;
  __int16 v27;
  int v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)(a1 + 8))
  {
    v13 = *__error();
    v14 = _SILogForLogForCategory(0);
    v15 = 2 * (gSILogLevels[0] < 4);
    if (os_log_type_enabled(v14, v15))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1B8270000, v14, v15, "Skipping because index is shut down", buf, 2u);
    }
    *__error() = v13;
    return 0xFFFFFFFFLL;
  }
  do
  {
    v2 = __ldxr(exceptionSequenceNum);
    v3 = v2 + 1;
  }
  while (__stxr(v2 + 1, exceptionSequenceNum));
  v4 = setThreadIdAndInfo(-1, (__int128 *)sIndexExceptionCallbacks, a1, 0, v3);
  v23 = HIDWORD(v4);
  v24 = v4;
  v21 = v6;
  v22 = v5;
  v7 = *(_QWORD *)&threadData[18 * v4 + 2];
  v8 = v7 + 320 * HIDWORD(v4);
  *(_BYTE *)(v8 + 216) = 0;
  v9 = *(_DWORD *)(v8 + 312);
  v10 = *(void (**)(_QWORD))(v8 + 224);
  if (v10)
    v10(*(_QWORD *)(v7 + 320 * HIDWORD(v4) + 288));
  if (_setjmp((int *)v8))
  {
    v11 = *__error();
    v12 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v26 = "ContentIndexVerifyIndex";
      v27 = 1024;
      v28 = 1795;
      _os_log_error_impl(&dword_1B8270000, v12, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
    }
    *__error() = v11;
    *(_DWORD *)(v8 + 312) = v9;
    CIOnThreadCleanUpReset(v21);
    dropThreadId(v24, 1, v3);
    CICleanUpReset(v24, v22);
    return 0xFFFFFFFFLL;
  }
  v17 = index_verify(a1);
  v18 = *(_QWORD *)&threadData[18 * v24 + 2];
  v19 = v18 + 320 * v23;
  *(_DWORD *)(v19 + 312) = v9;
  v20 = *(void (**)(_QWORD))(v19 + 232);
  if (v20)
    v20(*(_QWORD *)(v18 + 320 * v23 + 288));
  dropThreadId(v24, 0, v3);
  return v17;
}

uint64_t iterateTermsCallback(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5)
{
  if (!*(_DWORD *)(a5 + 4))
  {
    storageResolvePtr(*(_QWORD *)(a5 + 8), 8 * a3, 8uLL, 1);
    storageResolvePtr(*(_QWORD *)(a5 + 16), 8 * a3, 8uLL, 1);
  }
  return (*(uint64_t (**)(void))(*(_QWORD *)(a5 + 24) + 16))();
}

int *_CIDisableUpdates(uint64_t a1)
{
  uint64_t v1;
  int v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  int v7;
  unint64_t v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  void (*v14)(_QWORD);
  int v15;
  NSObject *v16;
  int *result;
  int v18;
  NSObject *v19;
  os_log_type_t v20;
  unsigned int v21;
  unint64_t v22;
  signed int v23;
  unsigned int *v24;
  char v25;
  unsigned int v26;
  unsigned int v27;
  int v28;
  unsigned int v29;
  unsigned int v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  NSObject *v35;
  int v36;
  unsigned int v37;
  int v38;
  uint64_t v39;
  int v40;
  pthread_override_s *v41;
  char v42;
  uint64_t v43;
  uint64_t v44;
  void (*v45)(_QWORD);
  uint64_t v46;
  uint64_t *v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  NSObject *v51;
  int v53;
  unsigned int v54;
  unsigned int v55;
  unsigned int v56;
  unsigned int v57;
  uint64_t v58;
  uint8_t buf[4];
  const char *v60;
  _BYTE v61[6];
  __int16 v62;
  int v63;
  __int16 v64;
  unsigned int v65;
  __int16 v66;
  int v67;
  uint64_t v68;

  v1 = MEMORY[0x1E0C80A78](a1);
  v68 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(v1 + 8))
  {
    v3 = v2;
    v4 = v1;
    v5 = v1 + 14856;
    do
    {
      v6 = __ldxr(exceptionSequenceNum);
      v7 = v6 + 1;
    }
    while (__stxr(v6 + 1, exceptionSequenceNum));
    v8 = setThreadIdAndInfo(-1, (__int128 *)sIndexExceptionCallbacks, v1, 0, v7);
    v56 = HIDWORD(v8);
    v57 = v8;
    v54 = v10;
    v55 = v9;
    v11 = *(_QWORD *)&threadData[18 * v8 + 2];
    v12 = v11 + 320 * HIDWORD(v8);
    *(_BYTE *)(v12 + 216) = 0;
    v13 = *(_DWORD *)(v12 + 312);
    v14 = *(void (**)(_QWORD))(v12 + 224);
    if (v14)
      v14(*(_QWORD *)(v11 + 320 * HIDWORD(v8) + 288));
    if (_setjmp((int *)v12))
    {
      v15 = *__error();
      v16 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        v60 = "_CIDisableUpdates";
        *(_WORD *)v61 = 1024;
        *(_DWORD *)&v61[2] = 1996;
        _os_log_error_impl(&dword_1B8270000, v16, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
      }
      *__error() = v15;
      *(_DWORD *)(v12 + 312) = v13;
      CIOnThreadCleanUpReset(v54);
      dropThreadId(v57, 1, v7);
      return (int *)CICleanUpReset(v57, v55);
    }
    HIDWORD(v22) = qos_class_self() - 9;
    LODWORD(v22) = HIDWORD(v22);
    v21 = v22 >> 2;
    if (v21 > 6)
      v23 = 0;
    else
      v23 = dword_1B8630ED0[v21];
    pthread_mutex_lock((pthread_mutex_t *)(v4 + 14680));
    if (*(_QWORD *)(v4 + 14864) || *(_DWORD *)(v4 + 14876) || *(_BYTE *)(v5 + 36))
      goto LABEL_19;
    if (v23 <= 5)
    {
      if (*(_QWORD *)(v4 + 16 * v23 + 14744))
      {
LABEL_19:
        db_rwlock_wait(v4 + 14680, v23, 2);
LABEL_20:
        pthread_mutex_unlock((pthread_mutex_t *)(v4 + 14680));
        v24 = (unsigned int *)(v4 + 28);
        v25 = atomic_load((unsigned int *)(v4 + 28));
        if ((v25 & 1) != 0)
        {
          if (dword_1EF19FCB4 >= 5)
          {
            v34 = *__error();
            v35 = _SILogForLogForCategory(10);
            if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
            {
              v36 = *(_DWORD *)(v4 + 48);
              v37 = atomic_load((unsigned int *)(v4 + 28));
              v38 = *(_DWORD *)(v5 + 1540);
              *(_DWORD *)buf = 134219008;
              v60 = (const char *)v4;
              *(_WORD *)v61 = 1024;
              *(_DWORD *)&v61[2] = v36;
              v62 = 1024;
              v63 = v3;
              v64 = 1024;
              v65 = v37;
              v66 = 1024;
              v67 = v38;
              _os_log_impl(&dword_1B8270000, v35, OS_LOG_TYPE_DEFAULT, "skip index updates disable for %p (%d) from %d; flags 0x%x, disabled at %d",
                buf,
                0x24u);
            }
            *__error() = v34;
          }
        }
        else
        {
          if (dword_1EF19FCB4 >= 5)
          {
            v50 = *__error();
            v51 = _SILogForLogForCategory(10);
            if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
            {
              v53 = *(_DWORD *)(v4 + 48);
              *(_DWORD *)buf = 134218496;
              v60 = (const char *)v4;
              *(_WORD *)v61 = 1024;
              *(_DWORD *)&v61[2] = v53;
              v62 = 1024;
              v63 = v3;
              _os_log_impl(&dword_1B8270000, v51, OS_LOG_TYPE_DEFAULT, "index updates disabled for %p (%d) from %d", buf, 0x18u);
            }
            *__error() = v50;
          }
          do
            v26 = __ldaxr(v24);
          while (__stlxr(v26 | 1, v24));
          v27 = atomic_load((unsigned int *)(v4 + 24));
          bzero(buf, 0x1000uLL);
          atomic_store(v27, (unsigned int *)(v4 + 24));
          v28 = *(_DWORD *)(v4 + 4);
          v29 = atomic_load((unsigned int *)(v4 + 24));
          *(_DWORD *)buf = v28;
          LODWORD(v60) = v29;
          v30 = atomic_load((unsigned int *)(v4 + 28));
          v31 = *(_DWORD *)(v4 + 40);
          HIDWORD(v60) = v30;
          *(_DWORD *)v61 = v31;
          pthread_mutex_lock((pthread_mutex_t *)(v4 + 14680));
          *(_BYTE *)(v5 + 36) = 1;
          db_rwlock_wakeup(v4 + 14680, 1, 1);
          pthread_mutex_unlock((pthread_mutex_t *)(v4 + 14680));
          v32 = *(_QWORD *)(v4 + 14440);
          if (v32)
          {
            v33 = fd_pwrite(*(_QWORD *)(v4 + 14440), (uint64_t)buf, 0x10uLL, 0);
            if (v33 == 16)
            {
              v58 = 0;
              v39 = _fd_acquire_fd(v32, &v58);
              if ((_DWORD)v39 != -1)
              {
                v40 = v39;
                prot_fsync(v39, (*(_WORD *)(v32 + 56) & 8) == 0);
                _fd_release_fd((_DWORD *)v32, v40, 0, v58);
              }
            }
            else if (v33 == -1)
            {
              __error();
            }
          }
          *(_DWORD *)(v5 + 1540) = v3;
        }
        pthread_mutex_lock((pthread_mutex_t *)(v4 + 14680));
        *(_DWORD *)(v4 + 14884) = 0;
        v41 = *(pthread_override_s **)(v4 + 14856);
        *(_QWORD *)v5 = 0;
        *(_QWORD *)(v5 + 8) = 0;
        v42 = *(_DWORD *)(v4 + 14876) != 0;
        *(_BYTE *)(v5 + 36) = 0;
        db_rwlock_wakeup(v4 + 14680, v42, 0);
        pthread_mutex_unlock((pthread_mutex_t *)(v4 + 14680));
        if (v41)
          pthread_override_qos_class_end_np(v41);
        v43 = *(_QWORD *)&threadData[18 * v57 + 2];
        v44 = v43 + 320 * v56;
        *(_DWORD *)(v44 + 312) = v13;
        v45 = *(void (**)(_QWORD))(v44 + 232);
        if (v45)
          v45(*(_QWORD *)(v43 + 320 * v56 + 288));
        return (int *)dropThreadId(v57, 0, v7);
      }
      v46 = v23 - 1;
      v47 = (uint64_t *)(v4 + 16 * v23 + 14760);
      while (v46 != 4)
      {
        v48 = *v47;
        v47 += 2;
        v49 = ++v46;
        if (v48)
        {
          if (v49 <= 4)
            goto LABEL_19;
          break;
        }
      }
    }
    *(_QWORD *)(v4 + 14864) = pthread_self();
    goto LABEL_20;
  }
  v18 = *__error();
  v19 = _SILogForLogForCategory(0);
  v20 = 2 * (gSILogLevels[0] < 4);
  if (os_log_type_enabled(v19, v20))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1B8270000, v19, v20, "Skipping because index is shut down", buf, 2u);
  }
  result = __error();
  *result = v18;
  return result;
}

uint64_t _ContentIndexMergeIndexes(uint64_t **a1, unsigned int a2, uint64_t a3, uint64_t *a4, __int128 *a5)
{
  uint64_t v8;
  size_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t **v14;
  uint64_t **v15;
  uint64_t v16;
  uint64_t *v17;
  _DWORD *v18;
  void (*v19)(_QWORD);
  __int128 v20;
  __int128 v21;
  uint64_t v22;
  unsigned int *v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v27;
  uint64_t **v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  uint64_t v33;
  uint64_t v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  uint64_t v39;
  _QWORD v40[3];
  _QWORD v41[3];

  v27 = a3;
  v28 = a1;
  v41[1] = *MEMORY[0x1E0C80C00];
  v8 = a2;
  v9 = 8 * a2;
  MEMORY[0x1E0C80A78](a1);
  v11 = (char *)&v27 - v10;
  v12 = (uint64_t)CICleanUpThreadLoc();
  v13 = threadData[18 * v12 + 8];
  if (*(_QWORD *)a5)
    (*(void (**)(_QWORD))a5)(*((_QWORD *)a5 + 4));
  bzero(v11, v9);
  if (a2)
  {
    v14 = v28;
    v15 = (uint64_t **)v11;
    v16 = v8;
    do
    {
      v17 = *v14++;
      *v15++ = v17;
      v18 = IndexFdInfoCreate(v17, 0);
      CICleanUpPush(v12, (uint64_t)IndexFdInfoDispose, (uint64_t)v18);
      --v16;
    }
    while (v16);
  }
  v34 = 0;
  v19 = (void (*)(_QWORD))*((_QWORD *)a5 + 1);
  if (v19)
    v19(*((_QWORD *)a5 + 4));
  v20 = a5[1];
  v35 = *a5;
  v36 = v20;
  v21 = a5[3];
  v37 = a5[2];
  v38 = v21;
  v22 = mergeIndexData((uint64_t)v11);
  CICleanUpReset(v12, v13);
  if (v22)
  {
    if (g_fd_list)
      _fd_close_inactive(*(unsigned int *)(v22 + 56), (const char *)(v22 + 15168), 0, 0);
    if (a4)
      *a4 = CIRemappingCreateWithContext(*MEMORY[0x1E0C9AE00], *(_QWORD *)(v22 + 72), v34);
    v23 = (unsigned int *)(v22 + 28);
    v33 = 0;
    v31 = 0u;
    v32 = 0u;
    v30 = 0u;
    v29 = 0u;
    do
      v24 = __ldaxr(v23);
    while (__stlxr(v24 | 0x64, v23));
    _CIDisableUpdates(v22);
    v25 = (uint64_t)(*v28 + 1894);
    v37 = v31;
    v38 = v32;
    v39 = v33;
    v35 = v29;
    v36 = v30;
    v40[2] = 0;
    v41[0] = v22;
    v40[0] = v41;
    v40[1] = 0x100000001;
    _ContentIndexSyncIndexBulk(0, (uint64_t)v40, 0, 1, (uint64_t)&v35, v25, 0, 0);
    *(_DWORD *)(v22 + 16408) = *(_DWORD *)(v22 + 60);
  }
  return v22;
}

uint64_t _CIDeleteIndex(uint64_t a1, int a2)
{
  char v5[1024];
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  bzero(v5, 0x400uLL);
  __strlcpy_chk();
  return index_DeleteIndex(a1, *(unsigned int *)(a1 + 56), v5, a2);
}

BOOL _CIMergeDeletes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4;
  uint64_t v5;
  unint64_t v10;
  unint64_t v11;
  unsigned int v12;
  int v13;
  unint64_t v14;
  unsigned int v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  void (*v20)(_QWORD);
  int v21;
  NSObject *v22;
  int v23;
  NSObject *v24;
  os_log_type_t v25;
  _BOOL4 v26;
  uint64_t v28;
  int v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  void (*v33)(_QWORD);
  BOOL v34;
  unsigned int v35;
  unsigned int v36;
  unsigned int v37;
  unsigned int v38;
  char v39;
  char v40;
  uint8_t buf[4];
  const char *v42;
  __int16 v43;
  int v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a1 + 72);
  LODWORD(v5) = *(_DWORD *)(a1 + 60);
  if (v5 >= 2)
    v5 = v5;
  else
    v5 = 0;
  v40 = 0;
  v39 = 0;
  if (!*(_BYTE *)(a1 + 8))
  {
    v23 = *__error();
    v24 = _SILogForLogForCategory(0);
    v25 = 2 * (gSILogLevels[0] < 4);
    if (os_log_type_enabled(v24, v25))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1B8270000, v24, v25, "Skipping because index is shut down", buf, 2u);
    }
    *__error() = v23;
    goto LABEL_16;
  }
  v10 = v4;
  v11 = v4 + v5;
  do
  {
    v12 = __ldxr(exceptionSequenceNum);
    v13 = v12 + 1;
  }
  while (__stxr(v12 + 1, exceptionSequenceNum));
  v14 = setThreadIdAndInfo(-1, (__int128 *)sIndexExceptionCallbacks, a1, 0, v13);
  v37 = HIDWORD(v14);
  v38 = v14;
  v35 = v16;
  v36 = v15;
  v17 = *(_QWORD *)&threadData[18 * v14 + 2];
  v18 = v17 + 320 * HIDWORD(v14);
  *(_BYTE *)(v18 + 216) = 0;
  v19 = *(_DWORD *)(v18 + 312);
  v20 = *(void (**)(_QWORD))(v18 + 224);
  if (v20)
    v20(*(_QWORD *)(v17 + 320 * HIDWORD(v14) + 288));
  if (_setjmp((int *)v18))
  {
    v21 = *__error();
    v22 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v42 = "_CIMergeDeletes";
      v43 = 1024;
      v44 = 2280;
      _os_log_error_impl(&dword_1B8270000, v22, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
    }
    *__error() = v21;
    *(_DWORD *)(v18 + 312) = v19;
    CIOnThreadCleanUpReset(v35);
    dropThreadId(v38, 1, v13);
    CICleanUpReset(v38, v36);
LABEL_16:
    v26 = v40 == 0;
    return !v26;
  }
  if (a4 < 1)
  {
    v30 = 1;
  }
  else
  {
    v28 = 0;
    do
      v29 = _MergeDeletes(a1, *(_QWORD *)(a3 + 8 * v28++), a2, v10, v11, &v39);
    while (v28 < a4 && (v29 & 1) != 0);
    v30 = v29;
  }
  v40 = 1;
  v31 = *(_QWORD *)&threadData[18 * v38 + 2];
  v32 = v31 + 320 * v37;
  *(_DWORD *)(v32 + 312) = v19;
  v33 = *(void (**)(_QWORD))(v32 + 232);
  if (v33)
    v33(*(_QWORD *)(v31 + 320 * v37 + 288));
  dropThreadId(v38, 0, v13);
  if (v40)
    v34 = v30 == 0;
  else
    v34 = 1;
  v26 = v34;
  if (!v34 && v39)
  {
    _indexShadowGroups(a1, 1);
    v26 = 0;
  }
  return !v26;
}

uint64_t _MergeDeletes(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5, _BYTE *a6)
{
  unsigned int v12;
  int v13;
  unint64_t v14;
  unsigned int v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  void (*v20)(_QWORD);
  int v21;
  NSObject *v22;
  int v23;
  NSObject *v24;
  os_log_type_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _QWORD *v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  unint64_t v33;
  unint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unsigned int *v39;
  unint64_t v40;
  unsigned int v41;
  unsigned int v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  unint64_t v46;
  unsigned int v47;
  uint64_t v48;
  unsigned int v49;
  unint64_t v50;
  unsigned int v51;
  unint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  int v56;
  int v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  void (*v61)(_QWORD);
  char *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  char *v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  unsigned int v81;
  unsigned int v82;
  unsigned int v83;
  unsigned int v84;
  unsigned __int8 v85;
  uint8_t buf[4];
  const char *v87;
  __int16 v88;
  int v89;
  uint64_t v90;

  v90 = *MEMORY[0x1E0C80C00];
  v85 = 0;
  if (!*(_BYTE *)(a2 + 8))
  {
    v23 = *__error();
    v24 = _SILogForLogForCategory(0);
    v25 = 2 * (gSILogLevels[0] < 4);
    if (os_log_type_enabled(v24, v25))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1B8270000, v24, v25, "Skipping because index is shut down", buf, 2u);
    }
    *__error() = v23;
    return v85;
  }
  do
  {
    v12 = __ldxr(exceptionSequenceNum);
    v13 = v12 + 1;
  }
  while (__stxr(v12 + 1, exceptionSequenceNum));
  v14 = setThreadIdAndInfo(-1, (__int128 *)sIndexExceptionCallbacks, a2, 0, v13);
  v83 = HIDWORD(v14);
  v84 = v14;
  v81 = v16;
  v82 = v15;
  v17 = *(_QWORD *)&threadData[18 * v14 + 2];
  v18 = v17 + 320 * HIDWORD(v14);
  *(_BYTE *)(v18 + 216) = 0;
  v19 = *(_DWORD *)(v18 + 312);
  v20 = *(void (**)(_QWORD))(v18 + 224);
  if (v20)
    v20(*(_QWORD *)(v17 + 320 * HIDWORD(v14) + 288));
  if (_setjmp((int *)v18))
  {
    v21 = *__error();
    v22 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v87 = "_MergeDeletes";
      v88 = 1024;
      v89 = 2258;
      _os_log_error_impl(&dword_1B8270000, v22, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
    }
    *__error() = v21;
    *(_DWORD *)(v18 + 312) = v19;
    CIOnThreadCleanUpReset(v81);
    dropThreadId(v84, 1, v13);
    CICleanUpReset(v84, v82);
    return v85;
  }
  v26 = *(unsigned int *)(a2 + 60);
  if (v26 < 2)
    goto LABEL_50;
  v27 = *(_QWORD *)(a2 + 72);
  v28 = 1;
  v29 = (_QWORD *)MEMORY[0x1E0C85AD8];
  v30 = 0;
  do
  {
    v31 = v30;
    if (*(_BYTE *)(a2 + 37))
      v32 = *(unsigned __int8 *)(*(_QWORD *)(a2 + 14392) + v28);
    else
      v32 = (*(_DWORD *)(*(_QWORD *)(a2 + 14392) + 4 * (v28 / 5uLL)) >> (6 * (v28 % 5))) & 0x3F;
    if ((v32 & 0xFFFFFFDF) != 0)
      goto LABEL_18;
    v33 = v27 + v28;
    v34 = v27 + v28;
    if (a3 && (v35 = *(uint64_t **)(a3 + 16), v36 = *v35, *v35 >= 1))
    {
      v37 = 0;
      v38 = v35[1];
      v39 = (unsigned int *)(v38 + 8);
      while (1)
      {
        v40 = *((_QWORD *)v39 - 1);
        if (v33 > v40 && v40 + *v39 > v33)
          break;
        ++v37;
        v39 += 6;
        if (v36 == v37)
          goto LABEL_26;
      }
      v58 = *(unsigned int *)(*(_QWORD *)(v38 + 24 * v37 + 16) + 4 * (v33 - v40));
      if (!(_DWORD)v58)
        goto LABEL_18;
      v34 = *(_QWORD *)(a3 + 32) + v58;
      if (!v34)
        goto LABEL_18;
    }
    else
    {
LABEL_26:
      if (!v34)
        goto LABEL_18;
    }
    v41 = v34 - a4;
    if (v34 <= a4 || v34 > a5)
    {
LABEL_54:
      v63 = __si_assert_copy_extra_268();
      __message_assert_272((uint64_t)v63, v64, v65, v66, v67, v68, v69, v70, (char)"ContentIndex.c");
      free(v63);
      if (__valid_fs(-1))
        v71 = 2989;
      else
        v71 = 3072;
      *(_DWORD *)v71 = -559038737;
      abort();
    }
    v42 = v34 - a4;
    if (*(_BYTE *)(a1 + 37))
    {
      v43 = *(_QWORD *)(a1 + 14392);
      if ((*(_BYTE *)(v43 + v41) & 0xDF) != 0)
      {
        v44 = v41;
        *(_BYTE *)(v43 + v41) = 0;
        v45 = *(_QWORD *)(a1 + 14400);
        if (v45)
          *(_BYTE *)(v45 + v44 / (32 * *v29)) |= 1 << ((v44 / (4 * *v29)) & 7);
        v31 = 1;
      }
      goto LABEL_18;
    }
    v46 = v41 / 5uLL;
    v47 = 6 * (v41 % 5);
    v48 = *(_QWORD *)(a1 + 14392);
    v49 = *(_DWORD *)(v48 + 4 * v46);
    if (((v49 >> (6 * (v42 - 5 * v46))) & 0x1F) == 0)
      goto LABEL_18;
    v50 = v46;
    v51 = v49 & ~(63 << v47);
    if (!*(_QWORD *)(a1 + 14400))
    {
      *(_DWORD *)(v48 + 4 * v46) = v51;
LABEL_45:
      v57 = (v51 >> v47) & 0x3F;
      goto LABEL_46;
    }
    v52 = v46 / (8 * *v29);
    v53 = (v46 / *v29) & 7;
    *(_BYTE *)(*(_QWORD *)(a1 + 14400) + v52) |= 1 << v53;
    if (!*(_BYTE *)(*(_QWORD *)(a1 + 14400) + v52)
      || (v54 = v53 | (8 * (_DWORD)v52), *v29 * v54 > v46)
      || *v29 * (unint64_t)(v54 + 1) <= v46)
    {
      v72 = __si_assert_copy_extra_268();
      __message_assert_272((uint64_t)v72, v73, v74, v75, v76, v77, v78, v79, (char)"ContentIndex.c");
      free(v72);
      if (__valid_fs(-1))
        v80 = 2989;
      else
        v80 = 3072;
      *(_DWORD *)v80 = -559038737;
      abort();
    }
    v55 = *(_QWORD *)(a1 + 14392);
    v56 = *(unsigned __int8 *)(a1 + 37);
    *(_DWORD *)(v55 + 4 * v50) = v51;
    if (!v56)
      goto LABEL_45;
    v57 = *(unsigned __int8 *)(v55 + v42);
LABEL_46:
    if (v57)
      goto LABEL_54;
    v31 = 1;
LABEL_18:
    ++v28;
    v30 = v31;
  }
  while (v28 != v26);
  if (((a6 != 0) & v31) != 0)
    *a6 = 1;
LABEL_50:
  v85 = 1;
  v59 = *(_QWORD *)&threadData[18 * v84 + 2];
  v60 = v59 + 320 * v83;
  *(_DWORD *)(v60 + 312) = v19;
  v61 = *(void (**)(_QWORD))(v60 + 232);
  if (v61)
    v61(*(_QWORD *)(v59 + 320 * v83 + 288));
  dropThreadId(v84, 0, v13);
  return v85;
}

int *_CIUpdateGroupAndDate(uint64_t a1, unint64_t a2, int a3, int a4)
{
  char v5;
  unsigned int v9;
  int v10;
  unint64_t v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  void (*v17)(_QWORD);
  int v18;
  NSObject *v19;
  int *result;
  int v21;
  NSObject *v22;
  os_log_type_t v23;
  unint64_t v24;
  unsigned int v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  unsigned int v30;
  uint64_t v31;
  unsigned int v32;
  unsigned int v33;
  uint64_t *v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  int v41;
  uint64_t v42;
  uint64_t v43;
  void (*v44)(_QWORD);
  char *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  char *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unsigned int v63;
  unsigned int v64;
  unsigned int v65;
  unsigned int v66;
  uint8_t buf[4];
  const char *v68;
  __int16 v69;
  int v70;
  uint64_t v71;

  v71 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 8))
  {
    v5 = a3;
    do
    {
      v9 = __ldxr(exceptionSequenceNum);
      v10 = v9 + 1;
    }
    while (__stxr(v9 + 1, exceptionSequenceNum));
    v11 = setThreadIdAndInfo(-1, (__int128 *)sIndexExceptionCallbacks, a1, 0, v10);
    v65 = HIDWORD(v11);
    v66 = v11;
    v63 = v13;
    v64 = v12;
    v14 = *(_QWORD *)&threadData[18 * v11 + 2];
    v15 = v14 + 320 * HIDWORD(v11);
    *(_BYTE *)(v15 + 216) = 0;
    v16 = *(_DWORD *)(v15 + 312);
    v17 = *(void (**)(_QWORD))(v15 + 224);
    if (v17)
      v17(*(_QWORD *)(v14 + 320 * HIDWORD(v11) + 288));
    if (_setjmp((int *)v15))
    {
      v18 = *__error();
      v19 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        v68 = "_CIUpdateGroupAndDate";
        v69 = 1024;
        v70 = 2410;
        _os_log_error_impl(&dword_1B8270000, v19, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
      }
      *__error() = v18;
      *(_DWORD *)(v15 + 312) = v16;
      CIOnThreadCleanUpReset(v63);
      dropThreadId(v66, 1, v10);
      return (int *)CICleanUpReset(v66, v64);
    }
    if (!a2)
      goto LABEL_35;
    v24 = *(_QWORD *)(a1 + 72);
    v25 = a2 - v24;
    if (a2 <= v24 || v24 + *(unsigned int *)(a1 + 60) <= a2)
      goto LABEL_35;
    v26 = CICleanUpThreadLoc();
    _db_write_lock(a1 + 14464);
    CIOnThreadCleanUpPush((uint64_t)v26, (uint64_t)si_rwlock_wrunlock, a1 + 14464);
    if (a4)
    {
      v27 = *(_QWORD *)(a1 + 14376);
      if (v27)
        *(_DWORD *)(v27 + 4 * v25) = a4;
    }
    if (!a3)
      goto LABEL_34;
    if (*(_BYTE *)(a1 + 37))
    {
      if ((*(_BYTE *)(*(_QWORD *)(a1 + 14392) + v25) & 0xDF) != 0)
      {
        *(_BYTE *)(*(_QWORD *)(a1 + 14392) + v25) = a3;
        v28 = *(_QWORD *)(a1 + 14400);
        if (v28)
          *(_BYTE *)(v28 + v25 / (unint64_t)(32 * *MEMORY[0x1E0C85AD8])) |= 1 << ((v25
                                                                                          / (unint64_t)(4 * *MEMORY[0x1E0C85AD8])) & 7);
      }
      goto LABEL_34;
    }
    v29 = v25 / 5uLL;
    v30 = 6 * (v25 % 5);
    v31 = *(_QWORD *)(a1 + 14392);
    v32 = *(_DWORD *)(v31 + 4 * v29);
    if (((v32 >> (6 * (v25 % 5))) & 0x1F) == 0)
    {
LABEL_34:
      CIOnThreadCleanUpPop((uint64_t)v26);
LABEL_35:
      v42 = *(_QWORD *)&threadData[18 * v66 + 2];
      v43 = v42 + 320 * v65;
      *(_DWORD *)(v43 + 312) = v16;
      v44 = *(void (**)(_QWORD))(v43 + 232);
      if (v44)
        v44(*(_QWORD *)(v42 + 320 * v65 + 288));
      return (int *)dropThreadId(v66, 0, v10);
    }
    v33 = v32 & ~(63 << v30) | ((v5 & 0x3F) << v30);
    if (*(_QWORD *)(a1 + 14400))
    {
      v34 = (uint64_t *)MEMORY[0x1E0C85AD8];
      v35 = v29 / (8 * *MEMORY[0x1E0C85AD8]);
      v36 = (v29 / *MEMORY[0x1E0C85AD8]) & 7;
      *(_BYTE *)(*(_QWORD *)(a1 + 14400) + v35) |= 1 << v36;
      if (!*(_BYTE *)(*(_QWORD *)(a1 + 14400) + v35)
        || (v37 = *v34, v38 = v36 | (8 * (_DWORD)v35), v37 * v38 > v29)
        || v37 * (unint64_t)(v38 + 1) <= v29)
      {
        v54 = __si_assert_copy_extra_268();
        __message_assert_272((uint64_t)v54, v55, v56, v57, v58, v59, v60, v61, (char)"ContentIndex.c");
        free(v54);
        if (__valid_fs(-1))
          v62 = 2989;
        else
          v62 = 3072;
        *(_DWORD *)v62 = -559038737;
        abort();
      }
      v39 = *(_QWORD *)(a1 + 14392);
      v40 = *(unsigned __int8 *)(a1 + 37);
      *(_DWORD *)(v39 + 4 * (v25 / 5uLL)) = v33;
      if (v40)
      {
        v41 = *(unsigned __int8 *)(v39 + v25);
        goto LABEL_33;
      }
    }
    else
    {
      *(_DWORD *)(v31 + 4 * v29) = v33;
    }
    v41 = (v33 >> v30) & 0x3F;
LABEL_33:
    if (v41 != (v5 & 0x3F))
    {
      v45 = __si_assert_copy_extra_268();
      __message_assert_272((uint64_t)v45, v46, v47, v48, v49, v50, v51, v52, (char)"ContentIndex.c");
      free(v45);
      if (__valid_fs(-1))
        v53 = 2989;
      else
        v53 = 3072;
      *(_DWORD *)v53 = -559038737;
      abort();
    }
    goto LABEL_34;
  }
  v21 = *__error();
  v22 = _SILogForLogForCategory(0);
  v23 = 2 * (gSILogLevels[0] < 4);
  if (os_log_type_enabled(v22, v23))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1B8270000, v22, v23, "Skipping because index is shut down", buf, 2u);
  }
  result = __error();
  *result = v21;
  return result;
}

int *_CIReassign(uint64_t a1, uint64_t a2, const char *a3, const char *a4)
{
  _BYTE *v8;
  unsigned int v9;
  int v10;
  unint64_t v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  void (*v17)(_QWORD);
  int v18;
  NSObject *v19;
  int *result;
  int v21;
  NSObject *v22;
  os_log_type_t v23;
  int v24;
  NSObject *v25;
  int v26;
  BOOL v27;
  uint8_t *v28;
  const char *v29;
  pthread_key_t v30;
  void *v31;
  void *v32;
  uint64_t v33;
  unsigned int v34;
  unint64_t v35;
  signed int v36;
  unint64_t v37;
  unint64_t v38;
  int v39;
  NSObject *v40;
  const char *v41;
  int v43;
  NSObject *v44;
  os_log_type_t v45;
  uint64_t v46;
  uint64_t v47;
  void (*v48)(_QWORD);
  uint64_t v49;
  uint64_t *v50;
  uint64_t v51;
  uint64_t v52;
  int v53;
  BOOL v54;
  uint8_t *v55;
  int v56;
  int v57;
  NSObject *v58;
  unsigned int v59;
  unsigned int v60;
  unsigned int v61;
  unsigned int v62;
  uint8_t v63[4];
  const char *v64;
  __int16 v65;
  int v66;
  __int16 v67;
  uint8_t *v68;
  __int16 v69;
  uint64_t v70;
  uint8_t buf[4];
  const char *v72;
  __int16 v73;
  _BYTE v74[20];
  const char *v75;
  uint64_t v76;

  v76 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 8))
  {
    v8 = (_BYTE *)(a1 + 14676);
    do
    {
      v9 = __ldxr(exceptionSequenceNum);
      v10 = v9 + 1;
    }
    while (__stxr(v9 + 1, exceptionSequenceNum));
    v11 = setThreadIdAndInfo(-1, (__int128 *)sIndexExceptionCallbacks, a1, 0, v10);
    v61 = HIDWORD(v11);
    v62 = v11;
    v59 = v13;
    v60 = v12;
    v14 = *(_QWORD *)&threadData[18 * v11 + 2];
    v15 = v14 + 320 * HIDWORD(v11);
    *(_BYTE *)(v15 + 216) = 0;
    v16 = *(_DWORD *)(v15 + 312);
    v17 = *(void (**)(_QWORD))(v15 + 224);
    if (v17)
      v17(*(_QWORD *)(v14 + 320 * HIDWORD(v11) + 288));
    if (_setjmp((int *)v15))
    {
      v18 = *__error();
      v19 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        v72 = "_CIReassign";
        v73 = 1024;
        *(_DWORD *)v74 = 2495;
        _os_log_error_impl(&dword_1B8270000, v19, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
      }
      *__error() = v18;
      *(_DWORD *)(v15 + 312) = v16;
      CIOnThreadCleanUpReset(v59);
      dropThreadId(v62, 1, v10);
      return (int *)CICleanUpReset(v62, v60);
    }
    if (dword_1EF19FCB4 >= 5)
    {
      v57 = *__error();
      v58 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109120;
        LODWORD(v72) = a2;
        _os_log_impl(&dword_1B8270000, v58, OS_LOG_TYPE_DEFAULT, "reassign docId: %d", buf, 8u);
      }
      *__error() = v57;
    }
    if (!*(_BYTE *)(a1 + 8))
    {
      bzero(buf, 0x400uLL);
      if ((reassignDocument__COUNT_ & 1) == 0)
      {
        reassignDocument__COUNT_ = 1;
        v24 = *__error();
        v25 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        {
          v53 = fcntl(*(_DWORD *)(a1 + 56), 50, buf);
          if (buf[0])
            v54 = v53 < 0;
          else
            v54 = 1;
          *(_DWORD *)v63 = 136315906;
          v64 = "reassignDocument";
          v55 = (uint8_t *)"";
          if (!v54)
            v55 = buf;
          v65 = 1024;
          v66 = 4752;
          v67 = 2080;
          v68 = v55;
          v69 = 2080;
          v70 = a1 + 15168;
          v29 = "%s:%d: trying to delete from invalid index %s/%s";
          goto LABEL_72;
        }
LABEL_26:
        *__error() = v24;
      }
LABEL_56:
      v46 = *(_QWORD *)&threadData[18 * v62 + 2];
      v47 = v46 + 320 * v61;
      *(_DWORD *)(v47 + 312) = v16;
      v48 = *(void (**)(_QWORD))(v47 + 232);
      if (v48)
        v48(*(_QWORD *)(v46 + 320 * v61 + 288));
      return (int *)dropThreadId(v62, 0, v10);
    }
    if (v8[487])
    {
      bzero(buf, 0x400uLL);
      if ((reassignDocument__COUNT__49 & 1) == 0)
      {
        reassignDocument__COUNT__49 = 1;
        v24 = *__error();
        v25 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        {
          v26 = fcntl(*(_DWORD *)(a1 + 56), 50, buf);
          if (buf[0])
            v27 = v26 < 0;
          else
            v27 = 1;
          *(_DWORD *)v63 = 136315906;
          v64 = "reassignDocument";
          v28 = (uint8_t *)"";
          if (!v27)
            v28 = buf;
          v65 = 1024;
          v66 = 4758;
          v67 = 2080;
          v68 = v28;
          v69 = 2080;
          v70 = a1 + 15168;
          v29 = "%s:%d: trying to modify read only index %s/%s";
LABEL_72:
          _os_log_error_impl(&dword_1B8270000, v25, OS_LOG_TYPE_ERROR, v29, v63, 0x26u);
          goto LABEL_26;
        }
        goto LABEL_26;
      }
      goto LABEL_56;
    }
    v30 = __THREAD_SLOT_KEY;
    if (!__THREAD_SLOT_KEY)
    {
      makeThreadId();
      v30 = __THREAD_SLOT_KEY;
    }
    v31 = pthread_getspecific(v30);
    if (!v31 || (v32 = v31, (unint64_t)v31 >= 0x801))
    {
      makeThreadId();
      v32 = pthread_getspecific(__THREAD_SLOT_KEY);
    }
    v33 = (uint64_t)v32 - 1;
    HIDWORD(v35) = qos_class_self() - 9;
    LODWORD(v35) = HIDWORD(v35);
    v34 = v35 >> 2;
    if (v34 > 6)
      v36 = 0;
    else
      v36 = dword_1B8630ED0[v34];
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 14464));
    if (*(_QWORD *)(a1 + 14648) || *(_DWORD *)(a1 + 14660) || *v8)
      goto LABEL_37;
    if (v36 <= 5)
    {
      if (*(_QWORD *)(a1 + 16 * v36 + 14528))
      {
LABEL_37:
        db_rwlock_wait(a1 + 14464, v36, 2);
        goto LABEL_38;
      }
      v49 = v36 - 1;
      v50 = (uint64_t *)(a1 + 16 * v36 + 14544);
      while (v49 != 4)
      {
        v51 = *v50;
        v50 += 2;
        v52 = ++v49;
        if (v51)
        {
          if (v52 <= 4)
            goto LABEL_37;
          break;
        }
      }
    }
    *(_QWORD *)(a1 + 14648) = pthread_self();
LABEL_38:
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 14464));
    CIOnThreadCleanUpPush(v33, (uint64_t)si_rwlock_wrunlock_2447, a1 + 14464);
    v37 = a2 - *(_QWORD *)(a1 + 72);
    v38 = v37;
    if (v37 && v37 >= *(unsigned int *)(a1 + 60))
    {
      v39 = *__error();
      v40 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
      {
        v56 = *(_DWORD *)(a1 + 60);
        *(_DWORD *)buf = 136315906;
        v72 = "reassignDocument";
        v73 = 1024;
        *(_DWORD *)v74 = 4772;
        *(_WORD *)&v74[4] = 2048;
        *(_QWORD *)&v74[6] = v38;
        *(_WORD *)&v74[14] = 1024;
        *(_DWORD *)&v74[16] = v56;
        _os_log_error_impl(&dword_1B8270000, v40, OS_LOG_TYPE_ERROR, "%s:%d: reassignDocument error - docId (%lld) >= max (%d) ", buf, 0x22u);
      }
      *__error() = v39;
    }
    if ((_DWORD)v38 && *(_DWORD *)(a1 + 60) > v38)
    {
      v41 = *(const char **)(*(_QWORD *)(a1 + 14368) + 8 * v38);
      if (v41 == a3)
      {
        if (indexMarkDirty(a1))
          *(_QWORD *)(*(_QWORD *)(a1 + 14368) + 8 * v38) = a4;
      }
      else if (v41 != a4 && v41 != 0)
      {
        v43 = *__error();
        v44 = _SILogForLogForCategory(0);
        v45 = gSILogLevels[0] < 3;
        if (os_log_type_enabled(v44, (os_log_type_t)(gSILogLevels[0] < 3)))
        {
          *(_DWORD *)buf = 134218752;
          v72 = a3;
          v73 = 2048;
          *(_QWORD *)v74 = a4;
          *(_WORD *)&v74[8] = 2048;
          *(_QWORD *)&v74[10] = v38;
          *(_WORD *)&v74[18] = 2048;
          v75 = v41;
          _os_log_impl(&dword_1B8270000, v44, v45, "*warn* reassignDocument error: oid mismatch oldOid: %ld newOid: %ld docId: %ld idxOid: %ld", buf, 0x2Au);
        }
        *__error() = v43;
      }
    }
    CIOnThreadCleanUpPop(v33);
    goto LABEL_56;
  }
  v21 = *__error();
  v22 = _SILogForLogForCategory(0);
  v23 = 2 * (gSILogLevels[0] < 4);
  if (os_log_type_enabled(v22, v23))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1B8270000, v22, v23, "Skipping because index is shut down", buf, 2u);
  }
  result = __error();
  *result = v21;
  return result;
}

int *_CIRebaseDocId(uint64_t a1, uint64_t a2, int a3)
{
  unsigned int v6;
  int v7;
  unint64_t v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  void (*v14)(_QWORD);
  int v15;
  NSObject *v16;
  int *result;
  int v18;
  NSObject *v19;
  os_log_type_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void (*v25)(_QWORD);
  char *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unsigned int v35;
  unsigned int v36;
  unsigned int v37;
  unsigned int v38;
  uint8_t buf[4];
  const char *v40;
  __int16 v41;
  int v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 8))
  {
    do
    {
      v6 = __ldxr(exceptionSequenceNum);
      v7 = v6 + 1;
    }
    while (__stxr(v6 + 1, exceptionSequenceNum));
    v8 = setThreadIdAndInfo(-1, (__int128 *)sIndexExceptionCallbacks, a1, 0, v7);
    v37 = HIDWORD(v8);
    v38 = v8;
    v35 = v10;
    v36 = v9;
    v11 = *(_QWORD *)&threadData[18 * v8 + 2];
    v12 = v11 + 320 * HIDWORD(v8);
    *(_BYTE *)(v12 + 216) = 0;
    v13 = *(_DWORD *)(v12 + 312);
    v14 = *(void (**)(_QWORD))(v12 + 224);
    if (v14)
      v14(*(_QWORD *)(v11 + 320 * HIDWORD(v8) + 288));
    if (_setjmp((int *)v12))
    {
      v15 = *__error();
      v16 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        v40 = "_CIRebaseDocId";
        v41 = 1024;
        v42 = 2511;
        _os_log_error_impl(&dword_1B8270000, v16, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
      }
      *__error() = v15;
      *(_DWORD *)(v12 + 312) = v13;
      CIOnThreadCleanUpReset(v35);
      dropThreadId(v38, 1, v7);
      return (int *)CICleanUpReset(v38, v36);
    }
    else
    {
      if (*(_DWORD *)(a1 + 60) >= 2u)
      {
        v26 = __si_assert_copy_extra_268();
        __message_assert_272((uint64_t)v26, v27, v28, v29, v30, v31, v32, v33, (char)"ContentIndex.c");
        free(v26);
        if (__valid_fs(-1))
          v34 = 2989;
        else
          v34 = 3072;
        *(_DWORD *)v34 = -559038737;
        abort();
      }
      *(_QWORD *)(a1 + 72) = a2;
      *(_DWORD *)(a1 + 80) = a3;
      v21 = *(_QWORD *)(a1 + 14352);
      if (v21)
        *(_QWORD *)(v21 + 8) = a2;
      v22 = *(_QWORD *)(a1 + 14360);
      if (v22)
        *(_QWORD *)(v22 + 8) = a2;
      v23 = *(_QWORD *)&threadData[18 * v38 + 2];
      v24 = v23 + 320 * v37;
      *(_DWORD *)(v24 + 312) = v13;
      v25 = *(void (**)(_QWORD))(v24 + 232);
      if (v25)
        v25(*(_QWORD *)(v23 + 320 * v37 + 288));
      return (int *)dropThreadId(v38, 0, v7);
    }
  }
  else
  {
    v18 = *__error();
    v19 = _SILogForLogForCategory(0);
    v20 = 2 * (gSILogLevels[0] < 4);
    if (os_log_type_enabled(v19, v20))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1B8270000, v19, v20, "Skipping because index is shut down", buf, 2u);
    }
    result = __error();
    *result = v18;
  }
  return result;
}

uint64_t _CIDocIdForOID(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unsigned int v5;
  int v6;
  unint64_t v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  void (*v13)(_QWORD);
  int v14;
  NSObject *v15;
  int v16;
  NSObject *v17;
  os_log_type_t v18;
  uint64_t v20;
  char v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  void (*v27)(_QWORD);
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  uint8_t buf[4];
  const char *v33;
  __int16 v34;
  int v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)(a1 + 8))
  {
    v16 = *__error();
    v17 = _SILogForLogForCategory(0);
    v18 = 2 * (gSILogLevels[0] < 4);
    if (os_log_type_enabled(v17, v18))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1B8270000, v17, v18, "Skipping because index is shut down", buf, 2u);
    }
    *__error() = v16;
    return 0;
  }
  v4 = *(unsigned int *)(a1 + 60);
  do
  {
    v5 = __ldxr(exceptionSequenceNum);
    v6 = v5 + 1;
  }
  while (__stxr(v5 + 1, exceptionSequenceNum));
  v7 = setThreadIdAndInfo(-1, (__int128 *)sIndexExceptionCallbacks, a1, 0, v6);
  v30 = HIDWORD(v7);
  v31 = v7;
  v28 = v9;
  v29 = v8;
  v10 = *(_QWORD *)&threadData[18 * v7 + 2];
  v11 = v10 + 320 * HIDWORD(v7);
  *(_BYTE *)(v11 + 216) = 0;
  v12 = *(_DWORD *)(v11 + 312);
  v13 = *(void (**)(_QWORD))(v11 + 224);
  if (v13)
    v13(*(_QWORD *)(v10 + 320 * HIDWORD(v7) + 288));
  if (_setjmp((int *)v11))
  {
    v14 = *__error();
    v15 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v33 = "_CIDocIdForOID";
      v34 = 1024;
      v35 = 2565;
      _os_log_error_impl(&dword_1B8270000, v15, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
    }
    *__error() = v14;
    *(_DWORD *)(v11 + 312) = v12;
    CIOnThreadCleanUpReset(v28);
    dropThreadId(v31, 1, v6);
    CICleanUpReset(v31, v29);
    return 0;
  }
  v20 = a1 + 14464;
  db_read_lock(a1 + 14464);
  if ((int)v4 < 1)
  {
LABEL_22:
    v24 = 0;
  }
  else
  {
    v21 = 0;
    v22 = 0;
    while (1)
    {
      v23 = *(_BYTE *)(a1 + 37)
          ? *(unsigned __int8 *)(*(_QWORD *)(a1 + 14392) + v22)
          : (*(_DWORD *)(*(_QWORD *)(a1 + 14392)
                       + (((3435973837u * (unint64_t)v22) >> 32) & 0xFFFFFFFC)) >> (v21 - 30 * (v22 / 5))) & 0x3F;
      if ((v23 & 0xFFFFFFDF) != 0 && *(_QWORD *)(*(_QWORD *)(a1 + 14368) + 8 * v22) == a2)
        break;
      ++v22;
      v21 += 6;
      if (v4 == v22)
        goto LABEL_22;
    }
    v24 = *(_QWORD *)(a1 + 72) + v22;
  }
  db_read_unlock(v20);
  v25 = *(_QWORD *)&threadData[18 * v31 + 2];
  v26 = v25 + 320 * v30;
  *(_DWORD *)(v26 + 312) = v12;
  v27 = *(void (**)(_QWORD))(v26 + 232);
  if (v27)
    v27(*(_QWORD *)(v25 + 320 * v30 + 288));
  dropThreadId(v31, 0, v6);
  return v24;
}

uint64_t _CIDeleteDuplicates(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unsigned int v4;
  int v5;
  unint64_t v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  void (*v12)(_QWORD);
  int v13;
  _DWORD *v14;
  int v15;
  NSObject *v16;
  int v17;
  NSObject *v18;
  os_log_type_t v19;
  char v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char v25;
  unsigned int v26;
  uint64_t v27;
  unint64_t v28;
  int v29;
  unint64_t v30;
  int v31;
  NSObject *v32;
  os_log_type_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unsigned int v37;
  _QWORD *v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  int v44;
  int v45;
  uint64_t v46;
  unsigned int v47;
  uint64_t v48;
  void (*v49)(_QWORD);
  char *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  char *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  char v68;
  uint64_t v69;
  int v70;
  int v72;
  int v73;
  unsigned int v74;
  unint64_t v75;
  unsigned int v76;
  unsigned int v77;
  unint64_t v78;
  unsigned int v79;
  unsigned int v80;
  uint8_t buf[4];
  const char *v82;
  __int16 v83;
  int v84;
  uint64_t v85;

  v85 = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)(a1 + 8))
  {
    v17 = *__error();
    v18 = _SILogForLogForCategory(0);
    v19 = 2 * (gSILogLevels[0] < 4);
    if (os_log_type_enabled(v18, v19))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1B8270000, v18, v19, "Skipping because index is shut down", buf, 2u);
    }
    *__error() = v17;
    return 0;
  }
  v3 = *(unsigned int *)(a1 + 60);
  v70 = *(unsigned __int8 *)(a1 + 15163);
  do
  {
    v4 = __ldxr(exceptionSequenceNum);
    v5 = v4 + 1;
  }
  while (__stxr(v4 + 1, exceptionSequenceNum));
  v6 = setThreadIdAndInfo(-1, (__int128 *)sIndexExceptionCallbacks, a1, 0, v5);
  v79 = HIDWORD(v6);
  v80 = v6;
  v78 = __PAIR64__(v7, v8);
  v9 = *(_QWORD *)&threadData[18 * v6 + 2];
  v10 = v9 + 320 * HIDWORD(v6);
  *(_BYTE *)(v10 + 216) = 0;
  v11 = *(_DWORD *)(v10 + 312);
  v12 = *(void (**)(_QWORD))(v10 + 224);
  if (v12)
    v12(*(_QWORD *)(v9 + 320 * HIDWORD(v6) + 288));
  v13 = v5;
  v77 = v80;
  v76 = v79;
  v75 = v78;
  if (_setjmp((int *)v10))
  {
    v14 = (_DWORD *)(v10 + 312);
    v15 = *__error();
    v16 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v82 = "_CIDeleteDuplicates";
      v83 = 1024;
      v84 = 2625;
      _os_log_error_impl(&dword_1B8270000, v16, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
    }
    *__error() = v15;
    *v14 = v11;
    CIOnThreadCleanUpReset(v75);
    dropThreadId(v77, 1, v13);
    CICleanUpReset(v77, HIDWORD(v75));
    return 0;
  }
  v74 = 0;
  if (fd_setDir(*(unsigned int *)(a1 + 56), (int *)&v74))
  {
    v72 = v11;
    v73 = v5;
    if ((int)v3 >= 1)
    {
      v21 = 0;
      v22 = 0;
      v23 = a2;
      v24 = v3 + 1;
      v25 = 6 * v3 - 6;
      v26 = v3 - 1;
      while (1)
      {
        v27 = v24;
        v28 = v26 / 5uLL;
        if (*(_BYTE *)(a1 + 37))
          v29 = *(unsigned __int8 *)(*(_QWORD *)(a1 + 14392) + v26);
        else
          v29 = (*(_DWORD *)(*(_QWORD *)(a1 + 14392) + (((3435973837u * (unint64_t)v26) >> 32) & 0xFFFFFFFC)) >> (v25 - 30 * (v26 / 5))) & 0x3F;
        if ((v29 & 0xFFFFFFDF) != 0)
        {
          v68 = v25 - 30 * (v26 / 5);
          v69 = v27;
          v30 = *(_QWORD *)(*(_QWORD *)(a1 + 14368) + 8 * v26);
          if (SIUINT64SetContainsValue(v23, v30))
          {
            v31 = *__error();
            v32 = _SILogForLogForCategory(10);
            v33 = 2 * (dword_1EF19FCB4 < 4);
            if (os_log_type_enabled(v32, v33))
            {
              *(_DWORD *)buf = 134217984;
              v82 = (const char *)v30;
              _os_log_impl(&dword_1B8270000, v32, v33, "dup oid (%lld)", buf, 0xCu);
            }
            *__error() = v31;
            if (v70)
            {
              ++v22;
              v23 = a2;
            }
            else
            {
              v23 = a2;
              if ((v21 & 1) == 0)
                indexMarkDirty(a1);
              if (!*(_BYTE *)(a1 + 37))
              {
                v36 = *(_QWORD *)(a1 + 14392);
                v37 = *(_DWORD *)(v36 + 4 * v28) & ~(63 << v68);
                v38 = (_QWORD *)MEMORY[0x1E0C85AD8];
                if (*(_QWORD *)(a1 + 14400))
                {
                  v39 = v28 / (8 * *MEMORY[0x1E0C85AD8]);
                  v40 = (v28 / *MEMORY[0x1E0C85AD8]) & 7;
                  *(_BYTE *)(*(_QWORD *)(a1 + 14400) + v39) |= 1 << v40;
                  if (!*(_BYTE *)(*(_QWORD *)(a1 + 14400) + v39)
                    || (v41 = v40 | (8 * (_DWORD)v39), *v38 * v41 > v28)
                    || *v38 * (unint64_t)(v41 + 1) <= v28)
                  {
                    v59 = __si_assert_copy_extra_268();
                    __message_assert_272((uint64_t)v59, v60, v61, v62, v63, v64, v65, v66, (char)"ContentIndex.c");
                    free(v59);
                    if (__valid_fs(-1))
                      v67 = 2989;
                    else
                      v67 = 3072;
                    *(_DWORD *)v67 = -559038737;
                    abort();
                  }
                  v42 = *(_QWORD *)(a1 + 14392);
                  v43 = *(unsigned __int8 *)(a1 + 37);
                  *(_DWORD *)(v42 + 4 * v28) = v37;
                  if (v43)
                  {
                    v44 = *(unsigned __int8 *)(v42 + v26);
LABEL_44:
                    v27 = v69;
                    if (v44)
                    {
                      v50 = __si_assert_copy_extra_268();
                      __message_assert_272((uint64_t)v50, v51, v52, v53, v54, v55, v56, v57, (char)"ContentIndex.c");
                      free(v50);
                      if (__valid_fs(-1))
                        v58 = 2989;
                      else
                        v58 = 3072;
                      *(_DWORD *)v58 = -559038737;
                      abort();
                    }
                    v21 = 1;
                    ++v22;
                    goto LABEL_34;
                  }
                }
                else
                {
                  *(_DWORD *)(v36 + 4 * v28) = v37;
                }
                v44 = (v37 >> v68) & 0x3F;
                goto LABEL_44;
              }
              *(_BYTE *)(*(_QWORD *)(a1 + 14392) + v26) = 0;
              v34 = *(_QWORD *)(a1 + 14400);
              v21 = 1;
              if (v34)
                *(_BYTE *)(v34 + v26 / (unint64_t)(32 * *MEMORY[0x1E0C85AD8])) |= 1 << ((v26
                                                                                                / (unint64_t)(4 * *MEMORY[0x1E0C85AD8])) & 7);
              ++v22;
            }
          }
          else
          {
            SIValueSet<unsigned long long>::SIValueSetInsert((unint64_t *)(a2 + 16), v30);
          }
          v27 = v69;
        }
LABEL_34:
        v35 = v22;
        v24 = v27 - 1;
        v25 -= 6;
        --v26;
        if (v27 - 1 <= 1)
          goto LABEL_48;
      }
    }
    v35 = 0;
LABEL_48:
    v45 = v74;
    MEMORY[0x1BCCB1484](v74);
    v13 = v73;
    if ((v45 & 0x80000000) == 0)
      close(v45);
    v11 = v72;
  }
  else
  {
    v35 = 0;
  }
  v46 = *(_QWORD *)&threadData[18 * v77 + 2];
  v47 = v76;
  v48 = v46 + 320 * v76;
  *(_DWORD *)(v48 + 312) = v11;
  v49 = *(void (**)(_QWORD))(v48 + 232);
  if (v49)
    v49(*(_QWORD *)(v46 + 320 * v47 + 288));
  dropThreadId(v77, 0, v13);
  return v35;
}

void _CIFindTokens(uint64_t a1)
{
  uint64_t v1;
  _BYTE *v2;
  unsigned __int8 v3;
  unsigned __int8 v4;
  uint64_t *v5;
  uint64_t *v6;
  int *v7;
  int *v8;
  const char **v9;
  const char **v10;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int *v15;
  unsigned int *v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  int v20;
  unint64_t v21;
  unsigned int v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  void (*v27)(_QWORD);
  int v28;
  int v29;
  NSObject *v30;
  int v31;
  NSObject *v32;
  os_log_type_t v33;
  _DWORD *v34;
  _DWORD *v35;
  uint64_t v36;
  unsigned int v37;
  int v38;
  unsigned int v39;
  int v40;
  unsigned int v41;
  uint64_t v42;
  _BYTE *v43;
  uint64_t v44;
  unsigned int v45;
  _BYTE *v46;
  uint64_t *v47;
  unint64_t v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  uint64_t v53;
  unint64_t v54;
  unsigned int *v55;
  unsigned int *v56;
  unint64_t v57;
  uint64_t v58;
  uint64_t v59;
  void (*v60)(_QWORD);
  NSObject *log;
  int v62;
  unsigned __int8 v63;
  _DWORD *v64;
  _BYTE *v65;
  uint64_t *v66;
  int v67;
  int v68;
  unsigned int v69;
  unsigned int v70;
  unsigned int v71;
  unsigned int v72;
  _QWORD v73[8];
  uint64_t v74;
  uint64_t *v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t *v83;
  uint64_t v84;
  _BYTE *v85;
  _QWORD v86[5];
  _BYTE v87[2048];
  _BYTE buf[24];
  _QWORD v89[4];
  int v90;
  uint64_t v91;
  uint64_t v92;
  void (*v93)(uint64_t, uint64_t);
  void *v94;
  _QWORD *v95;
  uint64_t v96;

  v1 = MEMORY[0x1E0C80A78](a1);
  v65 = v2;
  v4 = v3;
  v6 = v5;
  v8 = v7;
  v10 = v9;
  v12 = v11;
  v13 = v1;
  v96 = *MEMORY[0x1E0C80C00];
  v14 = v1 + 14680;
  db_read_lock(v1 + 14680);
  v15 = *(unsigned int **)(v13 + 14352);
  v16 = *(unsigned int **)(v13 + 14360);
  if (v15)
  {
    do
      v17 = __ldaxr(v15);
    while (__stlxr(v17 + 1, v15));
  }
  if (v16)
  {
    do
      v18 = __ldaxr(v16);
    while (__stlxr(v18 + 1, v16));
  }
  db_read_unlock(v14);
  if (v15)
    _CITermUpdateSetFindTokens((uint64_t)v15);
  if (v16)
    _CITermUpdateSetFindTokens((uint64_t)v16);
  if (!*(_BYTE *)(v13 + 8))
  {
    v31 = *__error();
    v32 = _SILogForLogForCategory(0);
    v33 = 2 * (gSILogLevels[0] < 4);
    if (os_log_type_enabled(v32, v33))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1B8270000, v32, v33, "Skipping because index is shut down", buf, 2u);
    }
    *__error() = v31;
    if (v15)
      goto LABEL_22;
    goto LABEL_23;
  }
  v63 = v4;
  v66 = v6;
  do
  {
    v19 = __ldxr(exceptionSequenceNum);
    v20 = v19 + 1;
  }
  while (__stxr(v19 + 1, exceptionSequenceNum));
  v21 = setThreadIdAndInfo(-1, (__int128 *)sIndexExceptionCallbacks, v13, 0, v20);
  v71 = HIDWORD(v21);
  v72 = v21;
  v69 = v23;
  v70 = v22;
  v24 = *(_QWORD *)&threadData[18 * v21 + 2];
  v25 = v24 + 320 * HIDWORD(v21);
  *(_BYTE *)(v25 + 216) = 0;
  v26 = *(_DWORD *)(v25 + 312);
  v27 = *(void (**)(_QWORD))(v25 + 224);
  if (v27)
    v27(*(_QWORD *)(v24 + 320 * HIDWORD(v21) + 288));
  if (_setjmp((int *)v25))
  {
    v28 = v26;
    v29 = *__error();
    v30 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "_CIFindTokens";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 2816;
      _os_log_error_impl(&dword_1B8270000, v30, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
    }
    *__error() = v29;
    *(_DWORD *)(v25 + 312) = v28;
    CIOnThreadCleanUpReset(v69);
    dropThreadId(v72, 1, v20);
    CICleanUpReset(v72, v70);
    if (!v15)
      goto LABEL_23;
LABEL_22:
    TermUpdateSetRelease((uint64_t)v15);
    goto LABEL_23;
  }
  v34 = TokenDataCreate(*v10, *v8);
  if (v34)
  {
    v67 = v26;
    v68 = v20;
    v82 = 0;
    v83 = &v82;
    v84 = 0x2000000000;
    v35 = v34;
    v85 = v87;
    v78 = 0;
    v79 = &v78;
    v80 = 0x2000000000;
    v36 = 32;
    v81 = 32;
    v74 = 0;
    v75 = &v74;
    v76 = 0x2000000000;
    v77 = 0;
    bzero(v89, 0x7E8uLL);
    bzero(v87, 0x800uLL);
    v37 = v35[4];
    v38 = v35[5];
    v39 = v37 >> 1;
    if ((v37 & 1) != 0)
      v40 = 2056;
    else
      v40 = 8;
    v41 = v40 & 0xFBFFFFFF | ((v39 & 1) << 26);
    v64 = v35;
    v42 = *((_QWORD *)v35 + 1);
    v43 = buf;
    *(_QWORD *)buf = v42;
    *(_QWORD *)&buf[8] = v42;
    v90 = v38;
    v44 = MEMORY[0x1E0C809B0];
    *(_DWORD *)&buf[16] = v41;
    *(_DWORD *)&buf[20] = v12;
    v45 = 1;
    do
    {
      if (dword_1EF19FC90 >= 5)
      {
        v62 = *__error();
        log = _SILogForLogForCategory(1);
        if (os_log_type_enabled(log, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(v91) = 67109120;
          HIDWORD(v91) = v45;
          _os_log_impl(&dword_1B8270000, log, OS_LOG_TYPE_DEFAULT, "### trie processing - %d ###", (uint8_t *)&v91, 8u);
        }
        *__error() = v62;
      }
      v73[0] = v44;
      v73[1] = 0x40000000;
      v73[2] = ___bt_findTokens_block_invoke;
      v73[3] = &unk_1E6E2EF90;
      v73[4] = &v74;
      v73[5] = &v78;
      v73[6] = &v82;
      v73[7] = v64;
      v91 = v44;
      v92 = 0x40000000;
      v93 = ___bt_resolveTokens_block_invoke;
      v94 = &unk_1E6E2EFB8;
      v95 = v73;
      v86[0] = v44;
      v86[1] = 0x40000000;
      v86[2] = ___bt_resolveTokens_block_invoke_2;
      v86[3] = &unk_1E6E2EFE0;
      v86[4] = v73;
      _bt_findBulk(v13, v13 + 88, 0, 0, 0, v45, (uint64_t)v43, 0, 0, v65, (uint64_t)&v91, (uint64_t)v86, v63);
      v46 = (_BYTE *)v83[3];
      v83[3] = (uint64_t)v43;
      v47 = v79;
      v48 = v79[3];
      v79[3] = v36;
      v49 = v75[3];
      v75[3] = 0;
      v43 = v46;
      v36 = v48;
      v45 = v49;
    }
    while (v49);
    if (v48 >= 0x21)
    {
      free(v46);
      v47 = v79;
    }
    if ((unint64_t)v47[3] >= 0x21)
      free((void *)v83[3]);
    _Block_object_dispose(&v74, 8);
    _Block_object_dispose(&v78, 8);
    _Block_object_dispose(&v82, 8);
    if (v64[6])
    {
      v50 = *v66;
      if (!*v66)
      {
        *v66 = (uint64_t)v64;
        goto LABEL_48;
      }
      *(_QWORD *)buf = v44;
      *(_QWORD *)&buf[8] = 0x40000000;
      *(_QWORD *)&buf[16] = __bt_findTokens_block_invoke;
      v89[0] = &__block_descriptor_tmp_1848;
      v89[1] = v50;
      v52 = (int)v64[10];
      v51 = (int)v64[11];
      if ((int)v51 < (int)v52)
      {
        v53 = *((_QWORD *)v64 + 4);
        v54 = v53 + v52;
        v55 = (unsigned int *)(v53 + v51);
        do
        {
          v56 = v55 + 1;
          v57 = v51 & 0xFFFFFFFF00000000 | *v55;
          (*(void (**)(_BYTE *))&buf[16])(buf);
          v51 = v57;
          v55 = v56;
        }
        while ((unint64_t)v56 < v54);
      }
    }
    free(*((void **)v64 + 1));
    free(*((void **)v64 + 4));
    free(v64);
LABEL_48:
    v26 = v67;
    v20 = v68;
  }
  v58 = *(_QWORD *)&threadData[18 * v72 + 2];
  v59 = v58 + 320 * v71;
  *(_DWORD *)(v59 + 312) = v26;
  v60 = *(void (**)(_QWORD))(v59 + 232);
  if (v60)
    v60(*(_QWORD *)(v58 + 320 * v71 + 288));
  dropThreadId(v72, 0, v20);
  if (v15)
    goto LABEL_22;
LABEL_23:
  if (v16)
    TermUpdateSetRelease((uint64_t)v16);
}

uint64_t _CIGetDocIDInfo(uint64_t a1, uint64_t a2, unsigned int *a3, _DWORD *a4, unint64_t a5, unint64_t a6, int a7)
{
  unint64_t v7;
  unsigned int v13;
  int v14;
  unint64_t v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  void (*v21)(_QWORD);
  int v22;
  NSObject *v23;
  int v24;
  NSObject *v25;
  os_log_type_t v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  void (*v34)(_QWORD);
  char *v36;
  unsigned int v38;
  unsigned int v39;
  unsigned int v40;
  unsigned int v41;
  unsigned __int8 v42;
  uint8_t buf[4];
  const char *v44;
  __int16 v45;
  int v46;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  v7 = a2 - *(_QWORD *)(a1 + 72);
  v42 = 0;
  if (v7 >= *(unsigned int *)(a1 + 60))
    return v42;
  if (*(_BYTE *)(a1 + 8))
  {
    do
    {
      v13 = __ldxr(exceptionSequenceNum);
      v14 = v13 + 1;
    }
    while (__stxr(v13 + 1, exceptionSequenceNum));
    v15 = setThreadIdAndInfo(-1, (__int128 *)sIndexExceptionCallbacks, a1, 0, v14);
    v40 = HIDWORD(v15);
    v41 = v15;
    v38 = v17;
    v39 = v16;
    v18 = *(_QWORD *)&threadData[18 * v15 + 2];
    v19 = v18 + 320 * HIDWORD(v15);
    *(_BYTE *)(v19 + 216) = 0;
    v20 = *(_DWORD *)(v19 + 312);
    v21 = *(void (**)(_QWORD))(v19 + 224);
    if (v21)
      v21(*(_QWORD *)(v18 + 320 * HIDWORD(v15) + 288));
    if (_setjmp((int *)v19))
    {
      v22 = *__error();
      v23 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        v44 = "_CIGetDocIDInfo";
        v45 = 1024;
        v46 = 3077;
        _os_log_error_impl(&dword_1B8270000, v23, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
      }
      *__error() = v22;
      *(_DWORD *)(v19 + 312) = v20;
      CIOnThreadCleanUpReset(v38);
      dropThreadId(v41, 1, v14);
      CICleanUpReset(v41, v39);
      return v42;
    }
    if (a7)
    {
      v36 = CICleanUpThreadLoc();
      db_read_lock(a1 + 14464);
      CIOnThreadCleanUpPush((uint64_t)v36, (uint64_t)si_rwlock_rdunlock, a1 + 14464);
      v27 = (uint64_t)v36;
    }
    else
    {
      v27 = 0;
    }
    if (a3)
    {
      if (*(_BYTE *)(a1 + 37))
        v28 = *(unsigned __int8 *)(*(_QWORD *)(a1 + 14392) + v7);
      else
        v28 = (*(_DWORD *)(*(_QWORD *)(a1 + 14392) + 4 * (v7 / 5uLL)) >> (6 * (v7 % 5))) & 0x3F;
      *a3 = v28 & 0xFFFFFFDF;
    }
    if (a4)
    {
      v29 = *(_QWORD *)(a1 + 14376);
      if (v29)
        LODWORD(v29) = *(_DWORD *)(v29 + 4 * v7);
      *a4 = v29;
    }
    if (!(a5 | a6))
      goto LABEL_36;
    v30 = *(_QWORD *)(a1 + 14384);
    if (v30)
    {
      if (a5)
        *(_DWORD *)a5 = *(_DWORD *)(v30 + 8 * v7);
      if (!a6)
        goto LABEL_36;
      v31 = *(_DWORD *)(v30 + 8 * v7 + 4);
    }
    else
    {
      if (a5)
        *(_DWORD *)a5 = 0;
      if (!a6)
        goto LABEL_36;
      v31 = 0;
    }
    *(_DWORD *)a6 = v31;
LABEL_36:
    if (a7)
      CIOnThreadCleanUpPop(v27);
    v42 = 1;
    v32 = *(_QWORD *)&threadData[18 * v41 + 2];
    v33 = v32 + 320 * v40;
    *(_DWORD *)(v33 + 312) = v20;
    v34 = *(void (**)(_QWORD))(v33 + 232);
    if (v34)
      v34(*(_QWORD *)(v32 + 320 * v40 + 288));
    dropThreadId(v41, 0, v14);
    return v42;
  }
  v24 = *__error();
  v25 = _SILogForLogForCategory(0);
  v26 = 2 * (gSILogLevels[0] < 4);
  if (os_log_type_enabled(v25, v26))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1B8270000, v25, v26, "Skipping because index is shut down", buf, 2u);
  }
  *__error() = v24;
  return v42;
}

uint64_t _CIGetGroupForDocId(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unsigned int v4;
  int v5;
  unint64_t v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  void (*v12)(_QWORD);
  int v13;
  NSObject *v14;
  int v15;
  NSObject *v16;
  os_log_type_t v17;
  char *v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(_QWORD);
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  unsigned int v28;
  uint8_t buf[4];
  const char *v30;
  __int16 v31;
  int v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v2 = a2 - *(_QWORD *)(a1 + 72);
  if (v2 >= *(unsigned int *)(a1 + 60))
    return 0;
  if (!*(_BYTE *)(a1 + 8))
  {
    v15 = *__error();
    v16 = _SILogForLogForCategory(0);
    v17 = 2 * (gSILogLevels[0] < 4);
    if (os_log_type_enabled(v16, v17))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1B8270000, v16, v17, "Skipping because index is shut down", buf, 2u);
    }
    *__error() = v15;
    return 0;
  }
  do
  {
    v4 = __ldxr(exceptionSequenceNum);
    v5 = v4 + 1;
  }
  while (__stxr(v4 + 1, exceptionSequenceNum));
  v6 = setThreadIdAndInfo(-1, (__int128 *)sIndexExceptionCallbacks, a1, 0, v5);
  v27 = HIDWORD(v6);
  v28 = v6;
  v25 = v8;
  v26 = v7;
  v9 = *(_QWORD *)&threadData[18 * v6 + 2];
  v10 = v9 + 320 * HIDWORD(v6);
  *(_BYTE *)(v10 + 216) = 0;
  v11 = *(_DWORD *)(v10 + 312);
  v12 = *(void (**)(_QWORD))(v10 + 224);
  if (v12)
    v12(*(_QWORD *)(v9 + 320 * HIDWORD(v6) + 288));
  if (_setjmp((int *)v10))
  {
    v13 = *__error();
    v14 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v30 = "_CIGetGroupForDocId";
      v31 = 1024;
      v32 = 3103;
      _os_log_error_impl(&dword_1B8270000, v14, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
    }
    *__error() = v13;
    *(_DWORD *)(v10 + 312) = v11;
    CIOnThreadCleanUpReset(v25);
    dropThreadId(v28, 1, v5);
    CICleanUpReset(v28, v26);
    return 0;
  }
  v19 = CICleanUpThreadLoc();
  db_read_lock(a1 + 14464);
  CIOnThreadCleanUpPush((uint64_t)v19, (uint64_t)si_rwlock_rdunlock, a1 + 14464);
  if (*(_BYTE *)(a1 + 37))
    v20 = *(unsigned __int8 *)(*(_QWORD *)(a1 + 14392) + v2);
  else
    v20 = (*(_DWORD *)(*(_QWORD *)(a1 + 14392) + 4 * (v2 / 5uLL)) >> (6 * (v2 % 5))) & 0x3F;
  v21 = v20 & 0xFFFFFFDF;
  CIOnThreadCleanUpPop((uint64_t)v19);
  v22 = *(_QWORD *)&threadData[18 * v28 + 2];
  v23 = v22 + 320 * v27;
  *(_DWORD *)(v23 + 312) = v11;
  v24 = *(void (**)(_QWORD))(v23 + 232);
  if (v24)
    v24(*(_QWORD *)(v22 + 320 * v27 + 288));
  dropThreadId(v28, 0, v5);
  return v21;
}

uint64_t _CIGetRankingSecondsForDocId(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unsigned int v4;
  int v5;
  unint64_t v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  void (*v12)(_QWORD);
  int v13;
  NSObject *v14;
  int v15;
  NSObject *v16;
  os_log_type_t v17;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void (*v23)(_QWORD);
  unsigned int v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  uint8_t buf[4];
  const char *v29;
  __int16 v30;
  int v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v2 = a2 - *(_QWORD *)(a1 + 72);
  if (v2 >= *(unsigned int *)(a1 + 60))
    return 0;
  if (!*(_BYTE *)(a1 + 8))
  {
    v15 = *__error();
    v16 = _SILogForLogForCategory(0);
    v17 = 2 * (gSILogLevels[0] < 4);
    if (os_log_type_enabled(v16, v17))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1B8270000, v16, v17, "Skipping because index is shut down", buf, 2u);
    }
    *__error() = v15;
    return 0;
  }
  do
  {
    v4 = __ldxr(exceptionSequenceNum);
    v5 = v4 + 1;
  }
  while (__stxr(v4 + 1, exceptionSequenceNum));
  v6 = setThreadIdAndInfo(-1, (__int128 *)sIndexExceptionCallbacks, a1, 0, v5);
  v26 = HIDWORD(v6);
  v27 = v6;
  v24 = v8;
  v25 = v7;
  v9 = *(_QWORD *)&threadData[18 * v6 + 2];
  v10 = v9 + 320 * HIDWORD(v6);
  *(_BYTE *)(v10 + 216) = 0;
  v11 = *(_DWORD *)(v10 + 312);
  v12 = *(void (**)(_QWORD))(v10 + 224);
  if (v12)
    v12(*(_QWORD *)(v9 + 320 * HIDWORD(v6) + 288));
  if (_setjmp((int *)v10))
  {
    v13 = *__error();
    v14 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v29 = "_CIGetRankingSecondsForDocId";
      v30 = 1024;
      v31 = 3121;
      _os_log_error_impl(&dword_1B8270000, v14, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
    }
    *__error() = v13;
    *(_DWORD *)(v10 + 312) = v11;
    CIOnThreadCleanUpReset(v24);
    dropThreadId(v27, 1, v5);
    CICleanUpReset(v27, v25);
    return 0;
  }
  v19 = *(_QWORD *)(a1 + 14376);
  if (v19)
    v20 = *(unsigned int *)(v19 + 4 * v2);
  else
    v20 = 0;
  v21 = *(_QWORD *)&threadData[18 * v27 + 2];
  v22 = v21 + 320 * v26;
  *(_DWORD *)(v22 + 312) = v11;
  v23 = *(void (**)(_QWORD))(v22 + 232);
  if (v23)
    v23(*(_QWORD *)(v21 + 320 * v26 + 288));
  dropThreadId(v27, 0, v5);
  return v20;
}

void _CIAddOids(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  int v5;
  unint64_t v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  void (*v12)(_QWORD);
  int v13;
  NSObject *v14;
  int v15;
  NSObject *v16;
  os_log_type_t v17;
  void *v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  _QWORD *v23;
  uint64_t v24;
  char v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  _QWORD *v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  void (*v35)(_QWORD);
  unsigned int v36;
  unsigned int v37;
  unsigned int v38;
  unsigned int v39;
  uint8_t buf[4];
  const char *v41;
  __int16 v42;
  int v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)(a1 + 8))
  {
    v15 = *__error();
    v16 = _SILogForLogForCategory(0);
    v17 = 2 * (gSILogLevels[0] < 4);
    if (os_log_type_enabled(v16, v17))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1B8270000, v16, v17, "Skipping because index is shut down", buf, 2u);
    }
    *__error() = v15;
    goto LABEL_12;
  }
  do
  {
    v4 = __ldxr(exceptionSequenceNum);
    v5 = v4 + 1;
  }
  while (__stxr(v4 + 1, exceptionSequenceNum));
  v6 = setThreadIdAndInfo(-1, (__int128 *)sIndexExceptionCallbacks, a1, 0, v5);
  v38 = HIDWORD(v6);
  v39 = v6;
  v36 = v8;
  v37 = v7;
  v9 = *(_QWORD *)&threadData[18 * v6 + 2];
  v10 = v9 + 320 * HIDWORD(v6);
  *(_BYTE *)(v10 + 216) = 0;
  v11 = *(_DWORD *)(v10 + 312);
  v12 = *(void (**)(_QWORD))(v10 + 224);
  if (v12)
    v12(*(_QWORD *)(v9 + 320 * HIDWORD(v6) + 288));
  if (_setjmp((int *)v10))
  {
    v13 = *__error();
    v14 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v41 = "_CIAddOids";
      v42 = 1024;
      v43 = 3170;
      _os_log_error_impl(&dword_1B8270000, v14, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
    }
    *__error() = v13;
    *(_DWORD *)(v10 + 312) = v11;
    CIOnThreadCleanUpReset(v36);
    dropThreadId(v39, 1, v5);
    CICleanUpReset(v39, v37);
LABEL_12:
    v18 = 0;
    goto LABEL_34;
  }
  v19 = CICleanUpThreadLoc();
  db_read_lock(a1 + 14464);
  CIOnThreadCleanUpPush((uint64_t)v19, (uint64_t)si_rwlock_rdunlock, a1 + 14464);
  v20 = *(int *)(a1 + 60);
  if ((_DWORD)v20)
  {
    v21 = *(unsigned int *)(a1 + 60);
    v22 = *(_DWORD *)(a1 + 60);
    v23 = malloc_type_malloc(8 * v20, 0x100004000313F17uLL);
    if (v22 >= 2)
    {
      v24 = *(_QWORD *)(a1 + 14368);
      v25 = 6;
      v26 = 1;
      v27 = 0;
      do
      {
        v28 = *(_QWORD *)(v24 + 8 * v26);
        v23[(int)v27] = v28;
        if (v28)
        {
          if (*(_BYTE *)(a1 + 37))
            LOBYTE(v29) = *(_BYTE *)(*(_QWORD *)(a1 + 14392) + v26);
          else
            v29 = (*(_DWORD *)(*(_QWORD *)(a1 + 14392)
                             + (((3435973837u * (unint64_t)v26) >> 32) & 0xFFFFFFFC)) >> (v25 - 30 * (v26 / 5))) & 0x3F;
          if ((v29 & 0xDF) != 0)
            v30 = (v27 + 1);
          else
            v30 = v27;
        }
        else
        {
          v30 = v27;
        }
        ++v26;
        v25 += 6;
        v27 = v30;
      }
      while (v21 != v26);
      v31 = v23;
      v32 = v30;
      goto LABEL_29;
    }
    v31 = v23;
  }
  else
  {
    v31 = 0;
  }
  v32 = 0;
LABEL_29:
  CIOnThreadCleanUpPop((uint64_t)v19);
  v33 = *(_QWORD *)&threadData[18 * v39 + 2];
  v34 = v33 + 320 * v38;
  *(_DWORD *)(v34 + 312) = v11;
  v35 = *(void (**)(_QWORD))(v34 + 232);
  if (v35)
    v35(*(_QWORD *)(v33 + 320 * v38 + 288));
  dropThreadId(v39, 0, v5);
  if ((_DWORD)v20)
  {
    qsort_oids((uint64_t)v31, v32);
    RLEOIDArrayAddSortedOids(a2, v31, v32);
  }
  v18 = v31;
LABEL_34:
  free(v18);
}

int *_CIDeleteByOidsBulk(uint64_t a1, uint64_t a2)
{
  unsigned int v4;
  int v5;
  unint64_t v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  void (*v12)(_QWORD);
  int v13;
  NSObject *v14;
  int *result;
  int v16;
  NSObject *v17;
  os_log_type_t v18;
  char *v19;
  uint64_t v20;
  char v21;
  unint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  unsigned int v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  void (*v37)(_QWORD);
  char *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  char *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  unsigned int v57;
  unsigned int v58;
  unsigned int v59;
  unsigned int v60;
  uint8_t buf[4];
  const char *v62;
  __int16 v63;
  int v64;
  uint64_t v65;

  v65 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 8))
  {
    do
    {
      v4 = __ldxr(exceptionSequenceNum);
      v5 = v4 + 1;
    }
    while (__stxr(v4 + 1, exceptionSequenceNum));
    v6 = setThreadIdAndInfo(-1, (__int128 *)sIndexExceptionCallbacks, a1, 0, v5);
    v59 = HIDWORD(v6);
    v60 = v6;
    v57 = v8;
    v58 = v7;
    v9 = *(_QWORD *)&threadData[18 * v6 + 2];
    v10 = v9 + 320 * HIDWORD(v6);
    *(_BYTE *)(v10 + 216) = 0;
    v11 = *(_DWORD *)(v10 + 312);
    v12 = *(void (**)(_QWORD))(v10 + 224);
    if (v12)
      v12(*(_QWORD *)(v9 + 320 * HIDWORD(v6) + 288));
    if (_setjmp((int *)v10))
    {
      v13 = *__error();
      v14 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        v62 = "_CIDeleteByOidsBulk";
        v63 = 1024;
        v64 = 3203;
        _os_log_error_impl(&dword_1B8270000, v14, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
      }
      *__error() = v13;
      *(_DWORD *)(v10 + 312) = v11;
      CIOnThreadCleanUpReset(v57);
      dropThreadId(v60, 1, v5);
      return (int *)CICleanUpReset(v60, v58);
    }
    v19 = CICleanUpThreadLoc();
    _db_write_lock(a1 + 14464);
    v56 = (uint64_t)v19;
    CIOnThreadCleanUpPush((uint64_t)v19, (uint64_t)si_rwlock_wrunlock, a1 + 14464);
    v20 = *(unsigned int *)(a1 + 60);
    if ((int)v20 >= 2)
    {
      v21 = 6;
      v22 = 1;
      v23 = (_QWORD *)MEMORY[0x1E0C85AD8];
      do
      {
        if (RLEOIDArrayContainsOid_locked(a2, *(_QWORD *)(*(_QWORD *)(a1 + 14368) + 8 * v22)))
        {
          if (!*(_BYTE *)(a1 + 37))
          {
            v25 = v22 / 5uLL;
            v26 = *(_QWORD *)(a1 + 14392);
            v27 = v25;
            v28 = *(_DWORD *)(v26 + 4 * v25) & ~(63 << (v21 - 30 * (v22 / 5)));
            if (*(_QWORD *)(a1 + 14400))
            {
              v29 = v25 / (8 * *v23);
              v30 = (v25 / *v23) & 7;
              *(_BYTE *)(*(_QWORD *)(a1 + 14400) + v29) |= 1 << v30;
              if (!*(_BYTE *)(*(_QWORD *)(a1 + 14400) + v29)
                || (v31 = v30 | (8 * (_DWORD)v29), *v23 * v31 > v25)
                || *v23 * (unint64_t)(v31 + 1) <= v25)
              {
                v47 = __si_assert_copy_extra_268();
                __message_assert_272((uint64_t)v47, v48, v49, v50, v51, v52, v53, v54, (char)"ContentIndex.c");
                free(v47);
                if (__valid_fs(-1))
                  v55 = 2989;
                else
                  v55 = 3072;
                *(_DWORD *)v55 = -559038737;
                abort();
              }
              v32 = *(_QWORD *)(a1 + 14392);
              v33 = *(unsigned __int8 *)(a1 + 37);
              *(_DWORD *)(v32 + 4 * v27) = v28;
              if (v33)
              {
                v34 = *(unsigned __int8 *)(v32 + v22);
                goto LABEL_26;
              }
            }
            else
            {
              *(_DWORD *)(v26 + 4 * v25) = v28;
            }
            v34 = (v28 >> (v21 - 30 * (v22 / 5))) & 0x3F;
LABEL_26:
            if (v34)
            {
              v38 = __si_assert_copy_extra_268();
              __message_assert_272((uint64_t)v38, v39, v40, v41, v42, v43, v44, v45, (char)"ContentIndex.c");
              free(v38);
              if (__valid_fs(-1))
                v46 = 2989;
              else
                v46 = 3072;
              *(_DWORD *)v46 = -559038737;
              abort();
            }
            goto LABEL_27;
          }
          *(_BYTE *)(*(_QWORD *)(a1 + 14392) + v22) = 0;
          v24 = *(_QWORD *)(a1 + 14400);
          if (v24)
            *(_BYTE *)(v24 + v22 / (32 * *v23)) |= 1 << ((v22 / (4 * *v23)) & 7);
        }
LABEL_27:
        ++v22;
        v21 += 6;
      }
      while (v20 != v22);
    }
    CIOnThreadCleanUpPop(v56);
    v35 = *(_QWORD *)&threadData[18 * v60 + 2];
    v36 = v35 + 320 * v59;
    *(_DWORD *)(v36 + 312) = v11;
    v37 = *(void (**)(_QWORD))(v36 + 232);
    if (v37)
      v37(*(_QWORD *)(v35 + 320 * v59 + 288));
    return (int *)dropThreadId(v60, 0, v5);
  }
  else
  {
    v16 = *__error();
    v17 = _SILogForLogForCategory(0);
    v18 = 2 * (gSILogLevels[0] < 4);
    if (os_log_type_enabled(v17, v18))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1B8270000, v17, v18, "Skipping because index is shut down", buf, 2u);
    }
    result = __error();
    *result = v16;
  }
  return result;
}

uint64_t _CIMoveDirectory(uint64_t a1, int a2, uint64_t *a3, int a4, uint64_t a5)
{
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  int v15;
  unint64_t v16;
  unsigned int v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  void (*v22)(_QWORD);
  int v23;
  NSObject *v24;
  int v25;
  NSObject *v26;
  os_log_type_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  void (*v32)(_QWORD);
  uint64_t result;
  uint64_t v34;
  uint64_t v35;
  unsigned int v36;
  unsigned int v37;
  unsigned int v38;
  unsigned int v39;
  uint8_t buf[4];
  const char *v41;
  __int16 v42;
  int v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  v10 = *(unsigned __int8 *)(a1 + 15163);
  indexMarkDirty(a1);
  v11 = a1 + 4680;
  _db_write_lock(a1 + 4680);
  if (!v10)
  {
    _db_write_lock(a1 + 14680);
    v12 = *(_QWORD *)(a1 + 14352);
    if (v12)
      _TermUpdateSetLock(v12, 1);
    v13 = *(_QWORD *)(a1 + 14360);
    if (v13)
      _TermUpdateSetLock(v13, 1);
  }
  if (*(_BYTE *)(a1 + 8))
  {
    do
    {
      v14 = __ldxr(exceptionSequenceNum);
      v15 = v14 + 1;
    }
    while (__stxr(v14 + 1, exceptionSequenceNum));
    v16 = setThreadIdAndInfo(-1, (__int128 *)sIndexExceptionCallbacks, a1, 0, v15);
    v38 = HIDWORD(v16);
    v39 = v16;
    v36 = v18;
    v37 = v17;
    v19 = *(_QWORD *)&threadData[18 * v16 + 2];
    v20 = v19 + 320 * HIDWORD(v16);
    *(_BYTE *)(v20 + 216) = 0;
    v21 = *(_DWORD *)(v20 + 312);
    v22 = *(void (**)(_QWORD))(v20 + 224);
    if (v22)
      v22(*(_QWORD *)(v19 + 320 * HIDWORD(v16) + 288));
    if (_setjmp((int *)v20))
    {
      v23 = *__error();
      v24 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        v41 = "_CIMoveDirectory";
        v42 = 1024;
        v43 = 3286;
        _os_log_error_impl(&dword_1B8270000, v24, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
      }
      *__error() = v23;
      *(_DWORD *)(v20 + 312) = v21;
      CIOnThreadCleanUpReset(v36);
      dropThreadId(v39, 1, v15);
      CICleanUpReset(v39, v37);
    }
    else
    {
      if (!v10)
      {
        v28 = *(_QWORD *)(a1 + 14352);
        if (v28)
          moveDirectory((uint64_t *)(v28 + 48), a2, a3, a4, a5);
        v29 = *(_QWORD *)(a1 + 14360);
        if (v29)
          moveDirectory((uint64_t *)(v29 + 48), a2, a3, a4, a5);
      }
      directoryStoreMoveDirectory(*(_QWORD *)(a1 + 4904), a2, (unint64_t *)a3, a4, a5);
      v30 = *(_QWORD *)&threadData[18 * v39 + 2];
      v31 = v30 + 320 * v38;
      *(_DWORD *)(v31 + 312) = v21;
      v32 = *(void (**)(_QWORD))(v31 + 232);
      if (v32)
        v32(*(_QWORD *)(v30 + 320 * v38 + 288));
      dropThreadId(v39, 0, v15);
    }
    v11 = a1 + 4680;
  }
  else
  {
    v25 = *__error();
    v26 = _SILogForLogForCategory(0);
    v27 = 2 * (gSILogLevels[0] < 4);
    if (os_log_type_enabled(v26, v27))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1B8270000, v26, v27, "Skipping because index is shut down", buf, 2u);
    }
    *__error() = v25;
  }
  result = db_write_unlock(v11);
  if (!v10)
  {
    v34 = *(_QWORD *)(a1 + 14352);
    if (v34)
      _TermUpdateSetUnlock(v34);
    v35 = *(_QWORD *)(a1 + 14360);
    if (v35)
      _TermUpdateSetUnlock(v35);
    return db_write_unlock(a1 + 14680);
  }
  return result;
}

BOOL _CICreateFdAndHoldAssertion(uint64_t a1, uint64_t a2, const char *a3, double a4)
{
  uint64_t v8;
  char *v9;
  char *v10;
  int v11;
  _BOOL8 v12;
  int v13;
  NSObject *v14;
  int v15;
  NSObject *v16;
  int v18;
  int *v19;
  char *v20;
  int v21;
  int *v22;
  char *v23;
  uint64_t v24;
  uint8_t buf[4];
  const char *v26;
  __int16 v27;
  int v28;
  __int16 v29;
  _BYTE v30[24];
  __int16 v31;
  _QWORD v32[3];
  char __str[1024];
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  bzero(__str, 0x400uLL);
  v8 = a1 + 15168;
  snprintf(__str, 0x400uLL, "%s%s", (const char *)(a1 + 15168), a3);
  v9 = (char *)fd_create_protected(*(_DWORD *)(a1 + 56), __str, 514, 0);
  if (v9)
  {
    v10 = v9;
    v24 = 0;
    v11 = _fd_acquire_fd((uint64_t)v9, &v24);
    if (v11 < 0)
    {
      v15 = *__error();
      v16 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        v21 = *__error();
        v22 = __error();
        v23 = strerror(*v22);
        *(_DWORD *)buf = 136316674;
        v26 = "_CICreateFdAndHoldAssertion";
        v27 = 1024;
        v28 = 3316;
        v29 = 1024;
        *(_DWORD *)v30 = v11;
        *(_WORD *)&v30[4] = 2080;
        *(_QWORD *)&v30[6] = v8;
        *(_WORD *)&v30[14] = 2080;
        *(_QWORD *)&v30[16] = a3;
        v31 = 1024;
        LODWORD(v32[0]) = v21;
        WORD2(v32[0]) = 2080;
        *(_QWORD *)((char *)v32 + 6) = v23;
        _os_log_error_impl(&dword_1B8270000, v16, OS_LOG_TYPE_ERROR, "%s:%d: fd = %d for %s%s file: %d(%s)", buf, 0x3Cu);
      }
      v12 = 0;
      *__error() = v15;
    }
    else
    {
      v12 = (int)fd_hold_assertion((uint64_t)v10, a2, a4) >= 0;
      _fd_release_fd(v10, v11, 0, v24);
    }
    fd_release(v10);
  }
  else
  {
    v13 = *__error();
    v14 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      v18 = *__error();
      v19 = __error();
      v20 = strerror(*v19);
      *(_DWORD *)buf = 136316418;
      v26 = "_CICreateFdAndHoldAssertion";
      v27 = 1024;
      v28 = 3303;
      v29 = 2080;
      *(_QWORD *)v30 = v8;
      *(_WORD *)&v30[8] = 2080;
      *(_QWORD *)&v30[10] = a3;
      *(_WORD *)&v30[18] = 1024;
      *(_DWORD *)&v30[20] = v18;
      v31 = 2080;
      v32[0] = v20;
      _os_log_error_impl(&dword_1B8270000, v14, OS_LOG_TYPE_ERROR, "%s:%d: Unable to get fdptr for %s%s file: %d(%s)", buf, 0x36u);
    }
    v12 = 0;
    *__error() = v13;
  }
  return v12;
}

BOOL _CICreateFdAndDropAssertion(uint64_t a1, const char *a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  int v7;
  _BOOL8 v8;
  int v9;
  NSObject *v10;
  int v11;
  NSObject *v12;
  int v14;
  int *v15;
  char *v16;
  int v17;
  int *v18;
  char *v19;
  uint64_t v20;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  int v24;
  __int16 v25;
  _BYTE v26[24];
  __int16 v27;
  _QWORD v28[3];
  char __str[1024];
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  bzero(__str, 0x400uLL);
  v4 = a1 + 15168;
  snprintf(__str, 0x400uLL, "%s%s", (const char *)(a1 + 15168), a2);
  v5 = (char *)fd_create_protected(*(_DWORD *)(a1 + 56), __str, 2, 0);
  if (v5)
  {
    v6 = v5;
    v20 = 0;
    v7 = _fd_acquire_fd((uint64_t)v5, &v20);
    if (v7 < 0)
    {
      v11 = *__error();
      v12 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        v17 = *__error();
        v18 = __error();
        v19 = strerror(*v18);
        *(_DWORD *)buf = 136316674;
        v22 = "_CICreateFdAndDropAssertion";
        v23 = 1024;
        v24 = 3344;
        v25 = 1024;
        *(_DWORD *)v26 = v7;
        *(_WORD *)&v26[4] = 2080;
        *(_QWORD *)&v26[6] = v4;
        *(_WORD *)&v26[14] = 2080;
        *(_QWORD *)&v26[16] = a2;
        v27 = 1024;
        LODWORD(v28[0]) = v17;
        WORD2(v28[0]) = 2080;
        *(_QWORD *)((char *)v28 + 6) = v19;
        _os_log_error_impl(&dword_1B8270000, v12, OS_LOG_TYPE_ERROR, "%s:%d: fd = %d for %s%s file: %d(%s)", buf, 0x3Cu);
      }
      v8 = 0;
      *__error() = v11;
    }
    else
    {
      v8 = (int)fd_drop_assertion((uint64_t)v6) >= 0;
      _fd_release_fd(v6, v7, 0, v20);
    }
    fd_release(v6);
  }
  else
  {
    v9 = *__error();
    v10 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      v14 = *__error();
      v15 = __error();
      v16 = strerror(*v15);
      *(_DWORD *)buf = 136316418;
      v22 = "_CICreateFdAndDropAssertion";
      v23 = 1024;
      v24 = 3331;
      v25 = 2080;
      *(_QWORD *)v26 = v4;
      *(_WORD *)&v26[8] = 2080;
      *(_QWORD *)&v26[10] = a2;
      *(_WORD *)&v26[18] = 1024;
      *(_DWORD *)&v26[20] = v14;
      v27 = 2080;
      v28[0] = v16;
      _os_log_error_impl(&dword_1B8270000, v10, OS_LOG_TYPE_ERROR, "%s:%d: Unable to get fdptr for %s%s file: %d(%s)", buf, 0x36u);
    }
    v8 = 0;
    *__error() = v9;
  }
  return v8;
}

uint64_t expandMap(uint64_t a1, size_t a2, void **a3, uint64_t (*a4)(uint64_t), uint64_t a5)
{
  uint64_t v10;
  int v11;
  int v12;
  NSObject *v13;
  int v14;
  NSObject *v15;
  int v17;
  int v18;
  const char *v19;
  __int16 v20;
  int v21;
  __int16 v22;
  int v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v10 = fd_mmap(a1);
  *a3 = (void *)v10;
  if (v10 == -1)
  {
    v14 = *__error();
    v15 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      v17 = *__error();
      v18 = 136315650;
      v19 = "expandMap";
      v20 = 1024;
      v21 = 29;
      v22 = 1024;
      v23 = v17;
      _os_log_error_impl(&dword_1B8270000, v15, OS_LOG_TYPE_ERROR, "%s:%d: mmap err: %d", (uint8_t *)&v18, 0x18u);
    }
    *__error() = v14;
  }
  else
  {
    while (1)
    {
      if (fd_truncate(a1, a2) != -1)
        return 0;
      v11 = *__error();
      if (!a4 || v11 != 28)
        break;
      if ((a4(a5) & 1) == 0)
      {
        v11 = 28;
        break;
      }
    }
    v12 = *__error();
    v13 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      v18 = 136315650;
      v19 = "expandMap";
      v20 = 1024;
      v21 = 38;
      v22 = 1024;
      v23 = v11;
      _os_log_error_impl(&dword_1B8270000, v13, OS_LOG_TYPE_ERROR, "%s:%d: ftruncate err: %d", (uint8_t *)&v18, 0x18u);
    }
    *__error() = v12;
    munmap(*a3, a2);
    *a3 = (void *)-1;
  }
  return 0xFFFFFFFFLL;
}

uint64_t expandUnsafeMapNew(void **a1, uint64_t a2, unint64_t a3, unint64_t a4, unint64_t *a5, uint64_t (*a6)(uint64_t), uint64_t a7)
{
  unint64_t v14;
  size_t v15;
  unsigned int v16;
  unint64_t v17;
  uint64_t result;
  unint64_t v19;
  unint64_t v20;
  int v21;
  NSObject *v22;
  int v23;
  int v24;
  const char *v25;
  __int16 v26;
  int v27;
  __int16 v28;
  int v29;
  __int16 v30;
  int v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  if (a3 <= 8)
    v14 = 8;
  else
    v14 = a3;
  v15 = a4 * a3;
  msync(*a1, a4 * a3, 16);
  munmap(*a1, v15);
  *a1 = 0;
  *a5 = 0;
  if ((a3 & (a3 - 1)) == 0)
    goto LABEL_8;
  v16 = 2;
  do
  {
    v17 = v16;
    v16 *= 2;
  }
  while (v17 < a3);
  result = expandMap(a2, v17 * a4, a1, a6, a7);
  if (!(_DWORD)result)
  {
    *a5 = v17;
  }
  else
  {
LABEL_8:
    v19 = v14 + a3;
    while (1)
    {
      if (v19 > 0xFFFFFFFF / a4)
      {
        *__error() = 7;
        return 0xFFFFFFFFLL;
      }
      v20 = v19 * a4;
      result = expandMap(a2, v19 * a4, a1, a6, a7);
      if (!(_DWORD)result)
      {
        *a5 = v20 / a4;
        return result;
      }
      if (v14 <= 8)
        break;
      v19 = a3 + (v14 >> 1);
      v14 >>= 1;
    }
    v21 = *__error();
    v22 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      v23 = *__error();
      v24 = 136315906;
      v25 = "expandUnsafeMapNew";
      v26 = 1024;
      v27 = 82;
      v28 = 1024;
      v29 = v23;
      v30 = 1024;
      v31 = -1;
      _os_log_error_impl(&dword_1B8270000, v22, OS_LOG_TYPE_ERROR, "%s:%d: expandUnsafeMap errno: %d err: %d", (uint8_t *)&v24, 0x1Eu);
    }
    *__error() = v21;
    return 0xFFFFFFFFLL;
  }
  return result;
}

unint64_t flatStoreNewBlockForCompact(uint64_t a1, unint64_t a2, uint64_t a3, int *a4)
{
  unint64_t v7;
  char *v8;
  unint64_t result;
  unint64_t v10;
  char *v11;

  if ((_DWORD)a2)
  {
    v7 = HIDWORD(a2) ? 0 : (unint64_t)a2 << 6;
    if (v7 < *(_QWORD *)(a1 + 232))
    {
      v8 = storageResolvePtr(a1, v7, 8uLL, 1);
      *(_QWORD *)(a1 + 232) = v7 + ((*(unsigned __int16 *)storageResolvePtr(a1, v7, 64 << v8[2], 1) + 71) & 0x1FFC0);
    }
  }
  result = storageAllocOffset(a1, 0x10000u, a3, a4);
  if (result)
  {
    v10 = result;
    v11 = storageResolvePtr(a1, result, 0x10000uLL, 1);
    *(_WORD *)v11 = 0;
    v11[2] = 10;
    return (v10 >> 6);
  }
  return result;
}

BOOL isExFat(int a1)
{
  _BOOL8 result;
  statfs v4;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  bzero(&v4, 0x878uLL);
  result = 0;
  if (!fstatfs(a1, &v4) && *(_DWORD *)v4.f_fstypename == 1634105445 && *(unsigned __int16 *)&v4.f_fstypename[4] == 116)
    return 1;
  return result;
}

void si_analytics_log_2064(char *a1, ...)
{
  void *v1[2];
  uint8_t buf[4];
  void *v3;
  uint64_t v4;
  va_list va;

  va_start(va, a1);
  v4 = *MEMORY[0x1E0C80C00];
  v1[0] = 0;
  va_copy((va_list)&v1[1], va);
  vasprintf((char **)v1, a1, va);
  SISetCrashCStr((const char *)v1[0]);
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)buf = 136315138;
    v3 = v1[0];
    _os_log_fault_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "%s", buf, 0xCu);
  }
  free(v1[0]);
}

uint64_t FlatStorePageEntryWrite2_2088(uint64_t a1, unsigned int *a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  _BYTE *v9;
  _BYTE *v10;
  _BYTE *v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;
  _BYTE *v15;
  _BYTE *v16;
  _BYTE *v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;

  v6 = a1 + 8;
  v7 = *a2;
  if (*a2 > 0x7F)
  {
    if (v7 >> 14)
    {
      if (v7 >> 21)
      {
        if (v7 >> 28)
        {
          v12 = v6 + a4;
          *(_BYTE *)v12 = -16;
          *(_DWORD *)(v12 + 1) = v7;
          v8 = a4 + 5;
        }
        else
        {
          v11 = (_BYTE *)(v6 + a4);
          *v11 = HIBYTE(v7) | 0xE0;
          v11[1] = BYTE2(v7);
          v11[2] = BYTE1(v7);
          v8 = a4 + 4;
          v11[3] = v7;
        }
      }
      else
      {
        v10 = (_BYTE *)(v6 + a4);
        *v10 = BYTE2(v7) | 0xC0;
        v10[1] = BYTE1(v7);
        v8 = a4 + 3;
        v10[2] = v7;
      }
    }
    else
    {
      v9 = (_BYTE *)(v6 + a4);
      *v9 = BYTE1(v7) | 0x80;
      v8 = a4 + 2;
      v9[1] = v7;
    }
  }
  else
  {
    v8 = a4 + 1;
    *(_BYTE *)(v6 + a4) = v7;
  }
  v13 = a2[1];
  if (v13 <= 0x7F)
  {
    v14 = v8 + 1;
    *(_BYTE *)(v6 + v8) = v13;
    if (!*a2)
      goto LABEL_26;
LABEL_23:
    v19 = 0;
    do
    {
      *(_BYTE *)(v14 + a1 + 8 + v19) = *(_BYTE *)(*((_QWORD *)a2 + 1) + v19);
      ++v19;
    }
    while (v19 < *a2);
    v14 += v19;
    goto LABEL_26;
  }
  if (v13 >> 14)
  {
    if (v13 >> 21)
    {
      if (v13 >> 28)
      {
        v18 = v6 + v8;
        *(_BYTE *)v18 = -16;
        *(_DWORD *)(v18 + 1) = v13;
        v14 = v8 + 5;
        if (!*a2)
          goto LABEL_26;
        goto LABEL_23;
      }
      v17 = (_BYTE *)(v6 + v8);
      *v17 = HIBYTE(v13) | 0xE0;
      v17[1] = BYTE2(v13);
      v17[2] = BYTE1(v13);
      v14 = v8 + 4;
      v17[3] = v13;
      if (*a2)
        goto LABEL_23;
    }
    else
    {
      v16 = (_BYTE *)(v6 + v8);
      *v16 = BYTE2(v13) | 0xC0;
      v16[1] = BYTE1(v13);
      v14 = v8 + 3;
      v16[2] = v13;
      if (*a2)
        goto LABEL_23;
    }
  }
  else
  {
    v15 = (_BYTE *)(v6 + v8);
    *v15 = BYTE1(v13) | 0x80;
    v14 = v8 + 2;
    v15[1] = v13;
    if (*a2)
      goto LABEL_23;
  }
LABEL_26:
  v20 = *((_QWORD *)a2 + 2);
  v21 = *a3;
  *a3 = v20;
  v22 = v2_writeVInt64(a1 + 8, v14, v20 - v21);
  v23 = *((_QWORD *)a2 + 3);
  if (v23)
  {
    v24 = a3[1];
    a3[1] = v23;
    v25 = v23 - v24;
  }
  else
  {
    v25 = 0;
  }
  return v2_writeVInt64(v6, v22, v25);
}

BOOL _checkFlatPage(unsigned __int16 *a1, unsigned int a2, int a3)
{
  unsigned int v5;
  unsigned int v6;
  int v7;
  NSObject *v8;
  int *v9;
  _BOOL8 result;
  unsigned __int16 *v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  int v25;
  NSObject *v26;
  int *v27;
  int v28;
  NSObject *v29;
  int *v30;
  int v31;
  const char *v32;
  __int16 v33;
  int v34;
  __int16 v35;
  unsigned int v36;
  __int16 v37;
  unsigned __int16 *v38;
  __int16 v39;
  unsigned int v40;
  __int16 v41;
  unsigned int v42;
  __int16 v43;
  unsigned int v44;
  __int16 v45;
  unsigned int v46;
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  v5 = *a1;
  if (a3)
    v6 = a2;
  else
    v6 = *a1;
  if (v5 < a2)
  {
    v7 = *__error();
    v8 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      v31 = 136316162;
      v32 = "_checkFlatPage";
      v33 = 1024;
      v34 = 188;
      v35 = 1024;
      v36 = a2;
      v37 = 2048;
      v38 = a1 + 4;
      v39 = 1024;
      v40 = v5;
      _os_log_error_impl(&dword_1B8270000, v8, OS_LOG_TYPE_ERROR, "%s:%d: invalid offset %d, %p (%d)", (uint8_t *)&v31, 0x28u);
    }
    v9 = __error();
    result = 0;
    *v9 = v7;
    return result;
  }
  v11 = a1 + 4;
  v12 = a2;
  while (1)
  {
    if (v12 >= v6)
      return v12 == v6;
    v13 = v12;
    v14 = v12;
    v15 = v12 + 1;
    v16 = *((unsigned __int8 *)v11 + v14);
    if (*((char *)v11 + v14) < 0)
    {
      if (v16 > 0xBF)
      {
        if (v16 > 0xDF)
        {
          if (v16 > 0xEF)
          {
            v16 = *(_DWORD *)((char *)v11 + v15);
            LODWORD(v15) = v14 + 5;
          }
          else
          {
            v16 = ((v16 & 0xF) << 24) | (*((unsigned __int8 *)v11 + v15) << 16) | (*((unsigned __int8 *)v11 + v14 + 2) << 8) | *((unsigned __int8 *)v11 + v14 + 3);
            LODWORD(v15) = v14 + 4;
          }
        }
        else
        {
          v16 = ((v16 & 0x1F) << 16) | (*((unsigned __int8 *)v11 + v15) << 8) | *((unsigned __int8 *)v11 + v14 + 2);
          LODWORD(v15) = v14 + 3;
        }
      }
      else
      {
        v17 = *((unsigned __int8 *)v11 + v15) | ((v16 & 0x3F) << 8);
        LODWORD(v15) = v14 + 2;
        v16 = v17;
      }
    }
    v18 = v15;
    v19 = v15 + 1;
    v20 = *((unsigned __int8 *)v11 + v18);
    if ((*((char *)v11 + v18) & 0x80000000) == 0)
      break;
    if (v20 > 0xBF)
    {
      if (v20 > 0xDF)
      {
        if (v20 <= 0xEF)
        {
          v20 = ((v20 & 0xF) << 24) | (*((unsigned __int8 *)v11 + v19) << 16) | (*((unsigned __int8 *)v11 + v18 + 2) << 8) | *((unsigned __int8 *)v11 + v18 + 3);
          LODWORD(v19) = v18 + 4;
          break;
        }
        v20 = *(_DWORD *)((char *)v11 + v19);
        LODWORD(v19) = v18 + 5;
        if (v13)
          goto LABEL_30;
      }
      else
      {
        v20 = ((v20 & 0x1F) << 16) | (*((unsigned __int8 *)v11 + v19) << 8) | *((unsigned __int8 *)v11 + v18 + 2);
        LODWORD(v19) = v18 + 3;
        if (v13)
          goto LABEL_30;
      }
    }
    else
    {
      v21 = *((unsigned __int8 *)v11 + v19) | ((v20 & 0x3F) << 8);
      LODWORD(v19) = v18 + 2;
      v20 = v21;
      if (v13)
        goto LABEL_30;
    }
LABEL_31:
    v22 = v16 + v19;
    if (v22 >= v5)
    {
      v28 = *__error();
      v29 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      {
LABEL_49:
        v30 = __error();
        result = 0;
        *v30 = v28;
        return result;
      }
      v31 = 136316930;
      v32 = "_checkFlatPage";
      v33 = 1024;
      v34 = 211;
      v35 = 1024;
      v36 = a2;
      v37 = 2048;
      v38 = v11;
      v39 = 1024;
      v40 = v5;
      v41 = 1024;
      v42 = v13;
      v43 = 1024;
      v44 = v16;
      v45 = 1024;
      v46 = v20;
LABEL_51:
      _os_log_error_impl(&dword_1B8270000, v29, OS_LOG_TYPE_ERROR, "%s:%d: invalid offset %d, %p (%d) s:%d l1:%d l2:%d", (uint8_t *)&v31, 0x3Au);
      goto LABEL_49;
    }
    if (*((char *)v11 + v22) < 0)
    {
      v23 = *((unsigned __int8 *)v11 + v22);
      if (v23 > 0xBF)
      {
        v24 = v22 + 5;
        if (v23 <= 0xEF)
          v24 = v22 + 4;
        v12 = v22 + 3;
        if (v23 > 0xDF)
          v12 = v24;
      }
      else
      {
        v12 = v22 + 2;
      }
    }
    else
    {
      v12 = v22 + 1;
    }
    if (v12 > v5)
    {
      v28 = *__error();
      v29 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
        goto LABEL_49;
      v31 = 136316930;
      v32 = "_checkFlatPage";
      v33 = 1024;
      v34 = 220;
      v35 = 1024;
      v36 = a2;
      v37 = 2048;
      v38 = v11;
      v39 = 1024;
      v40 = v5;
      v41 = 1024;
      v42 = v13;
      v43 = 1024;
      v44 = v16;
      v45 = 1024;
      v46 = v20;
      goto LABEL_51;
    }
  }
  if (!v13)
    goto LABEL_31;
LABEL_30:
  if (v16)
    goto LABEL_31;
  v25 = *__error();
  v26 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
  {
    v31 = 136316930;
    v32 = "_checkFlatPage";
    v33 = 1024;
    v34 = 205;
    v35 = 1024;
    v36 = a2;
    v37 = 2048;
    v38 = v11;
    v39 = 1024;
    v40 = v5;
    v41 = 1024;
    v42 = v13;
    v43 = 1024;
    v44 = 0;
    v45 = 1024;
    v46 = v20;
    _os_log_error_impl(&dword_1B8270000, v26, OS_LOG_TYPE_ERROR, "%s:%d: invalid offset %d, %p (%d) s:%d l1:%d l2:%d", (uint8_t *)&v31, 0x3Au);
  }
  v27 = __error();
  result = 0;
  *v27 = v25;
  return result;
}

uint64_t appendStringFlat(uint64_t a1, uint64_t a2, unint64_t a3, unsigned int a4, unsigned __int8 *a5, uint64_t a6, uint64_t a7, unint64_t *a8)
{
  uint64_t v15;
  unint64_t v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;
  char v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  unsigned int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  unint64_t v32;
  int v33;
  int v34;
  uint64_t v35;
  BOOL v36;
  unint64_t v37;
  int v38;
  unsigned int v39;
  uint64_t result;
  unint64_t v41;
  uint64_t v42;
  _QWORD *v43;
  unint64_t v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  char *v48;
  _DWORD *v49;
  int v50;
  int v51;
  int v52;
  __int16 v53;
  __int16 v54;
  uint64_t v55;
  unint64_t v56;
  uint64_t v57;
  _QWORD *v58;
  unint64_t v59;
  unint64_t v60;
  uint64_t v61;
  uint64_t v62;
  char *v63;
  char *v64;
  const char *v65;
  char *v66;
  char *v67;
  const char *v68;
  char *v69;
  const char *v70;
  uint64_t v71;
  uint64_t v72;
  unsigned int v74;
  int v75;
  unsigned __int8 *v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  statfs v80;
  uint64_t v81;

  v81 = *MEMORY[0x1E0C80C00];
  v15 = a1 + 160;
  if (HIDWORD(a3))
    v16 = 0;
  else
    v16 = (unint64_t)a3 << 6;
  v17 = storageResolvePtr(a1 + 160, v16, 8uLL, 1);
  v72 = v15;
  v18 = storageResolvePtr(v15, v16, 64 << v17[2], 1);
  if (v16 >= *(_QWORD *)(a1 + 392))
  {
    v63 = __si_assert_copy_extra_1644(*(_DWORD **)(a1 + 376));
    v64 = v63;
    v65 = "";
    if (v63)
      v65 = v63;
    __message_assert("%s:%u: failed assertion '%s' %s flat store", "FlatStore.c", 562, "flatStoreGetOffset(info) < storageGetCount(store)", v65);
    free(v64);
    if (!__valid_fsp(*(_DWORD **)(a1 + 376)))
    {
LABEL_161:
      MEMORY[0xC00] = -559038737;
      abort();
    }
LABEL_156:
    MEMORY[0xBAD] = -559038737;
    abort();
  }
  v19 = v18;
  v20 = *(unsigned __int16 *)v18;
  v21 = v18[2];
  v74 = a4;
  v75 = 0;
  v77 = a6;
  v78 = a7;
  if ((_DWORD)v20)
  {
    v22 = *(_DWORD *)(a2 + 1100);
    if (v22 >= a4)
      v23 = a4;
    else
      v23 = v22;
    if ((_DWORD)v23)
    {
      v24 = 0;
      while (*(unsigned __int8 *)(a2 + 1104 + v24) == a5[v24])
      {
        if (v23 == ++v24)
          goto LABEL_16;
      }
      LODWORD(v23) = v24;
    }
LABEL_16:
    v25 = a4 - v23;
    v74 = a4 - v23;
    v75 = v23;
    if (a4 == (_DWORD)v23)
    {
      v66 = __si_assert_copy_extra_1644(0);
      v67 = v66;
      v68 = "";
      if (v66)
        v68 = v66;
      __message_assert("%s:%u: failed assertion '%s' %s ", "FlatStore.c", 573, "entry.len", v68);
LABEL_160:
      free(v67);
      if (!__valid_fs(-1))
        goto LABEL_161;
      goto LABEL_156;
    }
  }
  else
  {
    LODWORD(v23) = 0;
    *(_OWORD *)(a2 + 1084) = 0u;
    v25 = a4;
  }
  v26 = (64 << v21) - 8;
  v76 = &a5[v23];
  if (*(_DWORD *)a2)
  {
    if (v25 >= 0x80)
    {
      if (v25 >= 0x4000)
      {
        if (v25 >= 0x200000)
        {
          if (v25 >> 28)
            v27 = 5;
          else
            v27 = 4;
        }
        else
        {
          v27 = 3;
        }
      }
      else
      {
        v27 = 2;
      }
    }
    else
    {
      v27 = 1;
    }
    if (v23 >= 0x80)
    {
      if (v23 >= 0x4000)
      {
        if (v23 >= 0x200000)
        {
          if (v23 >> 28)
            v31 = 5;
          else
            v31 = 4;
        }
        else
        {
          v31 = 3;
        }
      }
      else
      {
        v31 = 2;
      }
    }
    else
    {
      v31 = 1;
    }
    v32 = a6 - *(_QWORD *)(a2 + 1084);
    if (v32 >= 0x80)
    {
      if (v32 >= 0x4000)
      {
        if (v32 >= 0x200000)
        {
          if (v32 >> 28)
          {
            if (v32 >> 35)
            {
              if (v32 >> 42)
              {
                if (v32 >> 49)
                {
                  if (HIBYTE(v32))
                    v33 = 9;
                  else
                    v33 = 8;
                }
                else
                {
                  v33 = 7;
                }
              }
              else
              {
                v33 = 6;
              }
            }
            else
            {
              v33 = 5;
            }
          }
          else
          {
            v33 = 4;
          }
        }
        else
        {
          v33 = 3;
        }
      }
      else
      {
        v33 = 2;
      }
    }
    else
    {
      v33 = 1;
    }
    v35 = *(_QWORD *)(a2 + 1092);
    if (v35)
      v36 = a7 == 0;
    else
      v36 = 1;
    if (v36)
      v35 = 0;
    v37 = a7 - v35;
    if (v37 >= 0x80)
    {
      if (v37 >= 0x4000)
      {
        if (v37 >= 0x200000)
        {
          if (v37 >> 28)
          {
            if (v37 >> 35)
            {
              if (v37 >> 42)
              {
                if (v37 >> 49)
                {
                  if (HIBYTE(v37))
                    v38 = 9;
                  else
                    v38 = 8;
                }
                else
                {
                  v38 = 7;
                }
              }
              else
              {
                v38 = 6;
              }
            }
            else
            {
              v38 = 5;
            }
          }
          else
          {
            v38 = 4;
          }
        }
        else
        {
          v38 = 3;
        }
      }
      else
      {
        v38 = 2;
      }
    }
    else
    {
      v38 = 1;
    }
    v34 = v27 + v25 + v31 + v33 + v38;
    goto LABEL_109;
  }
  if (v25 < 0x80)
  {
    v28 = 1;
    if (v23 < 0x80)
      goto LABEL_22;
LABEL_28:
    if (v23 >= 0x4000)
    {
      if (v23 >= 0x200000)
      {
        if (v23 >> 28)
          v29 = 5;
        else
          v29 = 4;
        if (a6 < 0x80)
          goto LABEL_23;
      }
      else
      {
        v29 = 3;
        if (a6 < 0x80)
          goto LABEL_23;
      }
    }
    else
    {
      v29 = 2;
      if (a6 < 0x80)
        goto LABEL_23;
    }
LABEL_30:
    if (a6 >= 0x4000)
    {
      if (a6 >= 0x200000)
      {
        if (a6 >> 28)
          v30 = 5;
        else
          v30 = 4;
      }
      else
      {
        v30 = 3;
      }
    }
    else
    {
      v30 = 2;
    }
    goto LABEL_75;
  }
  if (v25 >= 0x4000)
  {
    if (v25 >= 0x200000)
    {
      if (v25 >> 28)
        v28 = 5;
      else
        v28 = 4;
      if (v23 >= 0x80)
        goto LABEL_28;
    }
    else
    {
      v28 = 3;
      if (v23 >= 0x80)
        goto LABEL_28;
    }
  }
  else
  {
    v28 = 2;
    if (v23 >= 0x80)
      goto LABEL_28;
  }
LABEL_22:
  v29 = 1;
  if (a6 >= 0x80)
    goto LABEL_30;
LABEL_23:
  v30 = 1;
LABEL_75:
  v34 = v28 + v25 + v29 + v30;
LABEL_109:
  v39 = v34 + v20;
  if (v34 + (int)v20 > v26)
  {
    if (v26 > 0xFFF7)
      return 1;
    v41 = *(unsigned int *)(a1 + 400);
    v71 = 64 << v18[2];
    if ((int)v41 < 1)
    {
      v45 = -1;
    }
    else
    {
      v42 = 53;
      do
      {
        v43 = *(_QWORD **)(a1 + 8 * v42);
        if (v43
          && (v44 = v43[1], v44 + 1 >= 2)
          && v44 <= (unint64_t)v18
          && (v46 = v43[2], v44 - v46 + v43[3] > (unint64_t)v18))
        {
          v45 = (unint64_t)&v18[v46 - v44];
        }
        else
        {
          v45 = -1;
        }
        if (v42 - 52 >= v41)
          break;
        ++v42;
      }
      while (v45 == -1);
    }
    bit_vector_set_2851(a1 + 4528, (v45 >> 17));
    if ((v45 >> 17) != (v45 + v71) >> 17)
      bit_vector_set_2851(a1 + 4528, (v45 >> 17) + 1);
    if (!reallocBlock(a1, a3, v39, a8))
    {
      *(_DWORD *)(a2 + 4) = -1;
      return 1;
    }
    v47 = HIDWORD(*a8) ? 0 : (unint64_t)*a8 << 6;
    v48 = storageResolvePtr(v72, v47, 8uLL, 1);
    v19 = storageResolvePtr(v72, v47, 64 << v48[2], 1);
    if ((_DWORD)v20 != *(unsigned __int16 *)v19)
    {
      v49 = *(_DWORD **)(a1 + 4568);
      v79 = 0;
      v50 = _fd_acquire_fd((uint64_t)v49, &v79);
      if (v50 != -1)
      {
        v51 = v50;
        bzero(&v80, 0x878uLL);
        v52 = fstatfs(v51, &v80);
        _fd_release_fd(v49, v51, 0, v79);
        if (!v52)
        {
          v69 = __si_assert_copy_extra_1644(0);
          v67 = v69;
          v70 = "";
          if (v69)
            v70 = v69;
          __message_assert("%s:%u: failed assertion '%s' %s ", "FlatStore.c", 602, "(int)pageEnd==storePageEnd(page) || trie_unavailable(t)", v70);
          goto LABEL_160;
        }
      }
    }
  }
  if (*(_DWORD *)a2)
    v53 = FlatStorePageEntryWrite2_2088((uint64_t)v19, &v74, (uint64_t *)(a2 + 1084), v20);
  else
    v53 = FlatStorePageEntryWrite((uint64_t)v19, &v74, v20);
  v54 = v53;
  v55 = 64 << v19[2];
  v56 = *(unsigned int *)(a1 + 400);
  if ((int)v56 < 1)
  {
    v60 = -1;
  }
  else
  {
    v57 = 53;
    do
    {
      v58 = *(_QWORD **)(a1 + 8 * v57);
      if (v58
        && (v59 = v58[1], v59 + 1 >= 2)
        && v59 <= (unint64_t)v19
        && (v61 = v58[2], v59 - v61 + v58[3] > (unint64_t)v19))
      {
        v60 = (unint64_t)&v19[v61 - v59];
      }
      else
      {
        v60 = -1;
      }
      if (v57 - 52 >= v56)
        break;
      ++v57;
    }
    while (v60 == -1);
  }
  v62 = a1 + 4528;
  bit_vector_set_2851(v62, (v60 >> 17));
  if ((v60 >> 17) != (v60 + v55) >> 17)
    bit_vector_set_2851(v62, (v60 >> 17) + 1);
  *(_WORD *)v19 = v54;
  memcpy((void *)(a2 + 1104), a5, a4);
  result = 0;
  *(_DWORD *)(a2 + 1100) = a4;
  return result;
}

unint64_t burstFlat(uint64_t a1, int *a2, unsigned int a3, unint64_t a4)
{
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  size_t v11;
  uint64_t v12;
  unsigned __int16 *v13;
  unint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unsigned int v20;
  uint64_t v21;
  char *v23;
  char *v24;
  const char *v25;
  char *v26;
  const char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  unsigned __int16 *v36;
  uint64_t v37;
  uint64_t v38;
  __int128 v39;
  __int128 i;
  unsigned __int8 v41[1044];
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  v7 = a1 + 160;
  v8 = (unint64_t)a3 << 6;
  v9 = 64 << storageResolvePtr(a1 + 160, v8, 8uLL, 1)[2];
  v31 = v7;
  v10 = storageResolvePtr(v7, v8, v9, 1);
  v30 = *(unsigned __int16 *)v10;
  v11 = v30 + 8;
  MEMORY[0x1E0C80A78](v10);
  v13 = (unsigned __int16 *)((char *)&v28 - v12);
  bzero(v41, 0x414uLL);
  memcpy(v13, v10, v11);
  v29 = 64 << v10[2];
  v14 = *(unsigned int *)(a1 + 400);
  if ((int)v14 < 1)
  {
    v19 = -1;
  }
  else
  {
    v15 = 53;
    do
    {
      v16 = *(_QWORD **)(a1 + 8 * v15);
      if (v16
        && (v17 = v16[1], v17 + 1 >= 2)
        && v17 <= (unint64_t)v10
        && (v18 = v16[2], v17 - v18 + v16[3] > (unint64_t)v10))
      {
        v19 = (unint64_t)&v10[v18 - v17];
      }
      else
      {
        v19 = -1;
      }
      if (v15 - 52 >= v14)
        break;
      ++v15;
    }
    while (v19 == -1);
  }
  bit_vector_set_2851(a1 + 4528, (v19 >> 17));
  if ((v19 >> 17) != (v19 + v29) >> 17)
    bit_vector_set_2851(a1 + 4528, (v19 >> 17) + 1);
  storageFreeOffset(v31, v8, 64 << v10[2]);
  v32 = *a2;
  v33 = 0;
  v20 = *v13;
  v35 = 0;
  v36 = v13 + 4;
  v34 = 0;
  v37 = 0;
  v38 = v20;
  if (v20 != (_DWORD)v30)
  {
    v23 = __si_assert_copy_extra_1644(*(_DWORD **)(a1 + 376));
    v24 = v23;
    v25 = "";
    if (v23)
      v25 = v23;
    __message_assert("%s:%u: failed assertion '%s' %s flat store", "FlatStore.c", 731, "oldPageEnd == iter.pageEnd", v25);
LABEL_28:
    free(v24);
    if (__valid_fsp(*(_DWORD **)(a1 + 376)))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v39 = 0u;
  for (i = 0u;
        FlatStorePageIteratorGetNext((uint64_t)&v32, (uint64_t)&v39);
        a4 = insertFromBurst((_QWORD *)a1, (uint64_t)a2, v41, v21, i, *((uint64_t *)&i + 1), a4))
  {
    v21 = (v39 + DWORD1(v39));
    if (v21 > 0x413)
      break;
    memcpy(&v41[DWORD1(v39)], *((const void **)&v39 + 1), v39);
  }
  if (v37 != v38)
  {
    v26 = __si_assert_copy_extra_1644(*(_DWORD **)(a1 + 376));
    v24 = v26;
    v27 = "";
    if (v26)
      v27 = v26;
    __message_assert("%s:%u: failed assertion '%s' %s flat store", "FlatStore.c", 740, "iter.pageCursor==iter.pageEnd", v27);
    goto LABEL_28;
  }
  return a4;
}

uint64_t FlatStorePageIteratorGetNext(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t *v4;
  uint64_t v7;
  unint64_t v8;
  unsigned int v9;
  int v10;
  BOOL v11;
  unint64_t v12;
  unsigned int v13;
  int v14;
  unint64_t v15;
  uint64_t v17;
  unint64_t VInt64_1804;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unsigned int v22;
  int v23;
  char *v24;
  char *v25;
  const char *v26;
  char *v27;
  char *v28;
  const char *v29;

  v3 = *(_QWORD *)(a1 + 32);
  v2 = *(_QWORD *)(a1 + 40);
  v4 = (uint64_t *)(a1 + 32);
  if (v3 >= v2)
    return 0;
  v7 = *(_QWORD *)(a1 + 24);
  v8 = v3 + 1;
  v9 = *(unsigned __int8 *)(v7 + v3);
  if (*(char *)(v7 + v3) < 0)
  {
    if (v9 > 0xBF)
    {
      if (v9 > 0xDF)
      {
        if (v9 > 0xEF)
        {
          v9 = *(_DWORD *)(v7 + v8);
          v8 = v3 + 5;
        }
        else
        {
          v9 = ((v9 & 0xF) << 24) | (*(unsigned __int8 *)(v7 + v8) << 16) | (*(unsigned __int8 *)(v3 + v7 + 2) << 8) | *(unsigned __int8 *)(v3 + v7 + 3);
          v8 = v3 + 4;
        }
      }
      else
      {
        v9 = ((v9 & 0x1F) << 16) | (*(unsigned __int8 *)(v7 + v8) << 8) | *(unsigned __int8 *)(v3 + v7 + 2);
        v8 = v3 + 3;
      }
    }
    else
    {
      v10 = *(unsigned __int8 *)(v7 + v8) | ((v9 & 0x3F) << 8);
      v8 = v3 + 2;
      v9 = v10;
    }
  }
  *v4 = v8;
  *(_DWORD *)a2 = v9;
  if (v9)
    v11 = 1;
  else
    v11 = v8 == 1;
  if (!v11)
  {
    v24 = __si_assert_copy_extra_1644(0);
    v25 = v24;
    v26 = "";
    if (v24)
      v26 = v24;
    __message_assert("%s:%u: failed assertion '%s' %s %d, %ld", "FlatStore.h", 431, "entry->len > 0 || iter->pageCursor == v2_vInt32Size(0)", v26, *(_DWORD *)a2, *v4);
    free(v25);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v12 = v8 + 1;
  v13 = *(unsigned __int8 *)(v7 + v8);
  if (*(char *)(v7 + v8) < 0)
  {
    if (v13 > 0xBF)
    {
      if (v13 > 0xDF)
      {
        if (v13 > 0xEF)
        {
          v13 = *(_DWORD *)(v7 + v12);
          v12 = v8 + 5;
        }
        else
        {
          v13 = ((v13 & 0xF) << 24) | (*(unsigned __int8 *)(v7 + v12) << 16) | (*(unsigned __int8 *)(v8 + v7 + 2) << 8) | *(unsigned __int8 *)(v8 + v7 + 3);
          v12 = v8 + 4;
        }
      }
      else
      {
        v13 = ((v13 & 0x1F) << 16) | (*(unsigned __int8 *)(v7 + v12) << 8) | *(unsigned __int8 *)(v8 + v7 + 2);
        v12 = v8 + 3;
      }
    }
    else
    {
      v14 = *(unsigned __int8 *)(v7 + v12) | ((v13 & 0x3F) << 8);
      v12 = v8 + 2;
      v13 = v14;
    }
  }
  *(_DWORD *)(a2 + 4) = v13;
  *(_QWORD *)(a2 + 8) = v7 + v12;
  v15 = v12 + v9;
  *v4 = v15;
  if (v15 > v2)
    return 0;
  if (*(_DWORD *)a1)
  {
    v17 = *(_QWORD *)(a1 + 4);
    VInt64_1804 = v2_readVInt64_1804(v7, v4);
    *(_QWORD *)(a1 + 4) = VInt64_1804 + v17;
    *(_QWORD *)(a2 + 16) = VInt64_1804 + v17;
    v19 = v2_readVInt64_1804(*(_QWORD *)(a1 + 24), v4);
    if (v19)
    {
      v20 = *(_QWORD *)(a1 + 12) + v19;
      *(_QWORD *)(a1 + 12) = v20;
      *(_QWORD *)(a2 + 24) = v20;
    }
    else
    {
      *(_QWORD *)(a2 + 24) = 0;
    }
  }
  else
  {
    v21 = v15 + 1;
    v22 = *(unsigned __int8 *)(v7 + v15);
    if (*(char *)(v7 + v15) < 0)
    {
      if (v22 > 0xBF)
      {
        if (v22 > 0xDF)
        {
          if (v22 > 0xEF)
          {
            v22 = *(_DWORD *)(v7 + v21);
            v21 = v15 + 5;
          }
          else
          {
            v22 = ((v22 & 0xF) << 24) | (*(unsigned __int8 *)(v7 + v21) << 16) | (*(unsigned __int8 *)(v15 + v7 + 2) << 8) | *(unsigned __int8 *)(v15 + v7 + 3);
            v21 = v15 + 4;
          }
        }
        else
        {
          v22 = ((v22 & 0x1F) << 16) | (*(unsigned __int8 *)(v7 + v21) << 8) | *(unsigned __int8 *)(v15 + v7 + 2);
          v21 = v15 + 3;
        }
      }
      else
      {
        v23 = *(unsigned __int8 *)(v7 + v21) | ((v22 & 0x3F) << 8);
        v21 = v15 + 2;
        v22 = v23;
      }
    }
    *v4 = v21;
    *(_DWORD *)(a2 + 16) = v22;
  }
  if (*(_QWORD *)(a1 + 32) > *(_QWORD *)(a1 + 40))
  {
    v27 = __si_assert_copy_extra_1644(0);
    v28 = v27;
    v29 = "";
    if (v27)
      v29 = v27;
    __message_assert("%s:%u: failed assertion '%s' %s ", "FlatStore.h", 470, "iter->pageCursor <= iter->pageEnd", v29);
    free(v28);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  return 1;
}

unint64_t dumpFlatData(uint64_t a1, char a2, uint64_t *a3, unsigned int a4, int a5, uint64_t a6, _DWORD *a7, void (*a8)(uint64_t, _BYTE *, _QWORD, _QWORD, uint64_t), uint64_t a9)
{
  unint64_t v15;
  unsigned __int16 *ptr;
  unsigned int v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  unsigned __int16 *v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  BOOL v26;
  unint64_t result;
  char *v28;
  char *v29;
  const char *v30;
  uint64_t v31;
  char *v32;
  char *v33;
  const char *v34;
  char *v35;
  const char *v36;
  char *v37;
  char *v38;
  const char *v39;
  int v40;
  uint64_t v41;
  _BYTE v42[12];
  unsigned __int16 *v43;
  uint64_t v44;
  uint64_t v45;
  void *__src[2];
  __int128 v47;
  _BYTE v48[1044];
  uint64_t v49;

  v49 = *MEMORY[0x1E0C80C00];
  v15 = (unint64_t)a4 << 6;
  ptr = (unsigned __int16 *)storage_reader_get_ptr(*a3, a3[1], v15, 8uLL);
  if (ptr == (unsigned __int16 *)-1)
    goto LABEL_19;
  v17 = *ptr;
  v18 = *((unsigned __int8 *)ptr + 2);
  if ((a2 & 1) == 0 && v18 >= 0x1A)
  {
    v37 = __si_assert_copy_extra_1644(*(_DWORD **)(a1 + 376));
    v38 = v37;
    v39 = "";
    if (v37)
      v39 = v37;
    __message_assert("%s:%u: failed assertion '%s' %s flat store", "FlatStore.c", 770, "__builtin_popcount(pageSize+(uint32_t)sizeof(*page)) == 1", v39);
    free(v38);
    if (__valid_fsp(*(_DWORD **)(a1 + 376)))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v19 = ((64 << v18) - 8);
  if (v19 < v17)
  {
    v32 = __si_assert_copy_extra_1644(*(_DWORD **)(a1 + 376));
    v33 = v32;
    v34 = "";
    if (v32)
      v34 = v32;
    __message_assert("%s:%u: failed assertion '%s' %s flat store", "FlatStore.c", 771, "pageEnd <= pageSize", v34);
LABEL_31:
    free(v33);
    if (__valid_fsp(*(_DWORD **)(a1 + 376)))
    {
LABEL_32:
      v31 = 2989;
LABEL_33:
      *(_DWORD *)v31 = -559038737;
      abort();
    }
LABEL_24:
    v31 = 3072;
    goto LABEL_33;
  }
  v20 = storage_reader_get_ptr(*a3, a3[1], v15, v19 + 8);
  if (v20 == -1)
  {
LABEL_19:
    result = 0;
    *a7 = 1;
    return result;
  }
  v21 = (unsigned __int16 *)v20;
  bzero(v48, 0x414uLL);
  __memcpy_chk();
  *(_OWORD *)__src = 0u;
  v47 = 0u;
  *(_QWORD *)&v42[4] = 0;
  v22 = *(_DWORD *)(a1 + 4576);
  if ((a2 & 1) == 0)
  {
    if (!v22)
      goto LABEL_8;
LABEL_21:
    v28 = __si_assert_copy_extra_1644(0);
    v29 = v28;
    v30 = "";
    if (v28)
      v30 = v28;
    __message_assert("%s:%u: failed assertion '%s' %s ", "FlatStore.c", 787, "(!compacted && t->type==kTermInfoTypeId) || (compacted && t->type!=kTermInfoTypeId)", v30);
    free(v29);
    if (__valid_fs(-1))
      goto LABEL_32;
    goto LABEL_24;
  }
  if (!v22)
    goto LABEL_21;
LABEL_8:
  v23 = 0;
  v40 = *(_DWORD *)(a1 + 4576);
  *(_QWORD *)v42 = 0;
  v41 = 0;
  v24 = *v21;
  v43 = v21 + 4;
  v44 = 0;
  v45 = v24;
  if (!*a7)
  {
    do
    {
      if (!FlatStorePageIteratorGetNext((uint64_t)&v40, (uint64_t)__src))
        break;
      v25 = (HIDWORD(__src[0]) + a5 + LODWORD(__src[0]));
      if (v25 > 0x413)
        break;
      memcpy(&v48[a5 + HIDWORD(__src[0])], __src[1], LODWORD(__src[0]));
      v48[v25] = 0;
      a8(v25, v48, v47, *((_QWORD *)&v47 + 1), a9);
    }
    while (!*a7);
    v23 = v44;
    v24 = v45;
  }
  if (*a7)
    v26 = 1;
  else
    v26 = v23 == v24;
  if (!v26)
  {
    v35 = __si_assert_copy_extra_1644(*(_DWORD **)(a1 + 376));
    v33 = v35;
    v36 = "";
    if (v35)
      v36 = v35;
    __message_assert("%s:%u: failed assertion '%s' %s flat store", "FlatStore.c", 799, "*canceled || iter.pageCursor==iter.pageEnd", v36);
    goto LABEL_31;
  }
  return v15 + v17;
}

uint64_t flatLastCompactTermOffset(uint64_t a1, unint64_t a2)
{
  uint64_t v2;
  unint64_t v4;
  char *v5;
  unsigned int v6;
  uint64_t v7;
  char *v8;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  __int128 v18;
  __int128 v19;

  v2 = 0;
  if (!HIDWORD(a2) && (_DWORD)a2)
  {
    if (*(_DWORD *)(a1 + 4576) == 1
      && (v4 = (unint64_t)a2 << 6,
          v5 = storageResolvePtr(a1 + 160, v4, 8uLL, 1),
          (unint64_t)(v5 + 1) >= 2)
      && (v6 = *(unsigned __int16 *)v5,
          v7 = ((64 << v5[2]) - 8),
          v8 = storageResolvePtr(a1 + 160, v4, v7 + 8, 1),
          (unint64_t)(v8 + 1) >= 2)
      && v7 >= v6)
    {
      v2 = 0;
      v18 = 0u;
      v19 = 0u;
      v11 = *(_DWORD *)(a1 + 4576);
      v10 = *(unsigned __int16 *)v8;
      v12 = 0;
      v14 = 0;
      v15 = v8 + 8;
      v13 = 0;
      v16 = 0;
      v17 = v10;
      while (FlatStorePageIteratorGetNext((uint64_t)&v11, (uint64_t)&v18))
        v2 = v19;
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

uint64_t _indexMatchAddress(uint64_t result, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v9;
  uint64_t v10;
  const char *v11;
  unint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  char *v21;
  size_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  char *v32;
  size_t v33;
  unint64_t v34;
  uint64_t v35;
  _QWORD *v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  char *v42;
  size_t v43;
  uint64_t v44;
  uint64_t v45;
  char __str[16];
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  uint64_t v62;

  v62 = *MEMORY[0x1E0C80C00];
  if (result)
  {
    v3 = result;
    v4 = *(_QWORD *)(result + 14368);
    if (v4 + 1 >= 2 && v4 <= a2)
    {
      v9 = *(unsigned int *)(result + 64);
      if (v4 + 8 * v9 > a2)
      {
        v10 = *(_QWORD *)(result + 14408);
        v11 = "index docId array";
        goto LABEL_95;
      }
    }
    v4 = *(_QWORD *)(result + 14376);
    if (v4 + 1 >= 2 && v4 <= a2)
    {
      v9 = *(unsigned int *)(result + 64);
      if (v4 + 4 * v9 > a2)
      {
        v10 = *(_QWORD *)(result + 14416);
        v11 = "index date array";
        goto LABEL_95;
      }
    }
    v4 = *(_QWORD *)(result + 14384);
    if (v4 + 1 >= 2 && v4 <= a2)
    {
      v9 = *(unsigned int *)(result + 64);
      if (v4 + 8 * v9 > a2)
      {
        v10 = *(_QWORD *)(result + 14424);
        v11 = "index score array";
        goto LABEL_95;
      }
    }
    v4 = *(_QWORD *)(result + 14392);
    if (v4 + 1 >= 2 && v4 <= a2)
    {
      v9 = *(unsigned int *)(result + 64);
      if (!*(_BYTE *)(result + 37))
        v9 = (4 * v9 + 4) / 5uLL;
      if (v4 + v9 > a2)
      {
        v10 = *(_QWORD *)(result + 14432);
        v11 = "index group array";
        goto LABEL_95;
      }
    }
    v4 = *(_QWORD *)(result + 104);
    if (v4 + 1 >= 2 && v4 <= a2)
    {
      v9 = *(_QWORD *)(result + 128);
      if (v4 + v9 > a2)
      {
        v10 = *(_QWORD *)(result + 200);
        v11 = "bases";
        goto LABEL_95;
      }
    }
    v4 = *(_QWORD *)(result + 96);
    if (v4 + 1 >= 2 && v4 <= a2)
    {
      v9 = *(unsigned int *)(result + 236);
      if (v4 + 1028 * v9 > a2)
      {
        v10 = *(_QWORD *)(result + 4656);
        v11 = "fat bases";
LABEL_95:
        log_map_access_error(a2, v4, v9, (uint64_t)v11, v10);
        return 1;
      }
    }
    v12 = *(unsigned int *)(result + 488);
    if ((int)v12 >= 1)
    {
      v13 = 64;
      do
      {
        v14 = *(_QWORD **)(result + 8 * v13);
        if (v14 && (v15 = v14[1], v15 + 1 >= 2) && v15 <= a2 && (v17 = v14[2], v15 - v17 + v14[3] > a2))
          v16 = a2 - v15 + v17;
        else
          v16 = -1;
        if (v13 - 63 >= v12)
          break;
        ++v13;
      }
      while (v16 == -1);
      if (v16 != -1)
      {
        v60 = 0u;
        v61 = 0u;
        v58 = 0u;
        v59 = 0u;
        v56 = 0u;
        v57 = 0u;
        v54 = 0u;
        v55 = 0u;
        v52 = 0u;
        v53 = 0u;
        v50 = 0u;
        v51 = 0u;
        v48 = 0u;
        v49 = 0u;
        *(_OWORD *)__str = 0u;
        v47 = 0u;
        v18 = result + 15168;
        v19 = snprintf(__str, 0xFFuLL, "c:%d s:%lld", v12, *(_QWORD *)(result + 472));
        if (*(int *)(v3 + 488) >= 1 && v19 <= 0xFE)
        {
          v20 = 0;
          v21 = &__str[v19];
          v22 = 255 - v19;
          do
          {
            snprintf(v21, v22, "%d:(mem:%p so:%lld eo:%lld)", v20, *(const void **)(*(_QWORD *)(v3 + 512 + 8 * v20) + 8), *(_QWORD *)(*(_QWORD *)(v3 + 512 + 8 * v20) + 16), *(_QWORD *)(*(_QWORD *)(v3 + 512 + 8 * v20) + 24));
            ++v20;
          }
          while (v20 < *(int *)(v3 + 488));
        }
        v23 = *(_QWORD *)(v3 + 464);
        goto LABEL_89;
      }
    }
    v24 = *(unsigned int *)(result + 5200);
    if ((int)v24 >= 1)
    {
      v25 = 653;
      do
      {
        v26 = *(_QWORD **)(result + 8 * v25);
        if (v26 && (v27 = v26[1], v27 + 1 >= 2) && v27 <= a2 && (v29 = v26[2], v27 - v29 + v26[3] > a2))
          v28 = a2 - v27 + v29;
        else
          v28 = -1;
        if (v25 - 652 >= v24)
          break;
        ++v25;
      }
      while (v28 == -1);
      if (v28 != -1)
      {
        v60 = 0u;
        v61 = 0u;
        v58 = 0u;
        v59 = 0u;
        v56 = 0u;
        v57 = 0u;
        v54 = 0u;
        v55 = 0u;
        v52 = 0u;
        v53 = 0u;
        v50 = 0u;
        v51 = 0u;
        v48 = 0u;
        v49 = 0u;
        *(_OWORD *)__str = 0u;
        v47 = 0u;
        v18 = result + 15168;
        v30 = snprintf(__str, 0xFFuLL, "c:%d s:%lld", v24, *(_QWORD *)(result + 5184));
        if (*(int *)(v3 + 5200) >= 1 && v30 <= 0xFE)
        {
          v31 = 0;
          v32 = &__str[v30];
          v33 = 255 - v30;
          do
          {
            snprintf(v32, v33, "%d:(mem:%p so:%lld eo:%lld)", v31, *(const void **)(*(_QWORD *)(v3 + 5224 + 8 * v31) + 8), *(_QWORD *)(*(_QWORD *)(v3 + 5224 + 8 * v31) + 16), *(_QWORD *)(*(_QWORD *)(v3 + 5224 + 8 * v31) + 24));
            ++v31;
          }
          while (v31 < *(int *)(v3 + 5200));
        }
        v23 = *(_QWORD *)(v3 + 5176);
        goto LABEL_89;
      }
    }
    v34 = *(unsigned int *)(result + 9912);
    if ((int)v34 >= 1)
    {
      v35 = 1242;
      do
      {
        v36 = *(_QWORD **)(result + 8 * v35);
        if (v36 && (v37 = v36[1], v37 + 1 >= 2) && v37 <= a2 && (v38 = v36[2], v37 - v38 + v36[3] > a2))
          v39 = a2 - v37 + v38;
        else
          v39 = -1;
        if (v35 - 1241 >= v34)
          break;
        ++v35;
      }
      while (v39 == -1);
      if (v39 != -1)
      {
        v60 = 0u;
        v61 = 0u;
        v58 = 0u;
        v59 = 0u;
        v56 = 0u;
        v57 = 0u;
        v54 = 0u;
        v55 = 0u;
        v52 = 0u;
        v53 = 0u;
        v50 = 0u;
        v51 = 0u;
        v48 = 0u;
        v49 = 0u;
        *(_OWORD *)__str = 0u;
        v47 = 0u;
        v18 = result + 15168;
        v40 = snprintf(__str, 0xFFuLL, "c:%d s:%lld", v34, *(_QWORD *)(result + 9896));
        if (*(int *)(v3 + 9912) >= 1 && v40 <= 0xFE)
        {
          v41 = 0;
          v42 = &__str[v40];
          v43 = 255 - v40;
          do
          {
            snprintf(v42, v43, "%d:(mem:%p so:%lld eo:%lld)", v41, *(const void **)(*(_QWORD *)(v3 + 9936 + 8 * v41) + 8), *(_QWORD *)(*(_QWORD *)(v3 + 9936 + 8 * v41) + 16), *(_QWORD *)(*(_QWORD *)(v3 + 9936 + 8 * v41) + 24));
            ++v41;
          }
          while (v41 < *(int *)(v3 + 9912));
        }
        v23 = *(_QWORD *)(v3 + 9888);
        goto LABEL_89;
      }
    }
    v44 = *(_QWORD *)(result + 4904);
    if (v44 && _windowsAddressOffset(v44 + 224, a2) != -1)
    {
      v60 = 0u;
      v61 = 0u;
      v58 = 0u;
      v59 = 0u;
      v56 = 0u;
      v57 = 0u;
      v54 = 0u;
      v55 = 0u;
      v52 = 0u;
      v53 = 0u;
      v50 = 0u;
      v51 = 0u;
      v48 = 0u;
      v49 = 0u;
      v18 = v3 + 15168;
      *(_OWORD *)__str = 0u;
      v47 = 0u;
      storage_describe_windows(v44 + 8, __str);
      v23 = *(_QWORD *)(*(_QWORD *)(v3 + 4904) + 224);
LABEL_89:
      v45 = v18;
LABEL_90:
      log_map_access_error_mini(v45, a2, (uint64_t)__str, v23);
      return 1;
    }
    result = *(_QWORD *)(v3 + 4896);
    if (result)
    {
      result = vectorIndexValidAddress(result, a2);
      if ((_DWORD)result)
      {
        v45 = v3 + 15168;
        v60 = 0u;
        v61 = 0u;
        v58 = 0u;
        v59 = 0u;
        v56 = 0u;
        v57 = 0u;
        v54 = 0u;
        v55 = 0u;
        v52 = 0u;
        v53 = 0u;
        v50 = 0u;
        v51 = 0u;
        v48 = 0u;
        v49 = 0u;
        *(_OWORD *)__str = 0u;
        v47 = 0u;
        v23 = *(_QWORD *)(*(_QWORD *)(v3 + 4904) + 224);
        goto LABEL_90;
      }
    }
  }
  return result;
}

uint64_t _indexMarkInvalid(uint64_t result)
{
  if (result)
    *(_BYTE *)(result + 8) = 0;
  return result;
}

int *log_map_access_error(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v9;
  char *v10;
  int v11;
  int v12;
  NSObject *v13;
  int *result;
  stat v15;
  uint8_t buf[4];
  const char *v17;
  __int16 v18;
  int v19;
  __int16 v20;
  uint64_t v21;
  __int16 v22;
  char *v23;
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  uint64_t v27;
  __int16 v28;
  uint64_t v29;
  __int16 v30;
  int v31;
  __int16 v32;
  off_t st_size;
  __int16 v34;
  dev_t st_dev;
  __int16 v36;
  __darwin_ino64_t st_ino;
  _OWORD v38[16];
  uint64_t v39;

  v39 = *MEMORY[0x1E0C80C00];
  if (a5)
    v9 = *(_DWORD *)(a5 + 44);
  else
    v9 = -1;
  memset(&v15, 0, sizeof(v15));
  memset(v38, 0, sizeof(v38));
  v10 = fd_name(a5, (char *)v38, 0x100uLL);
  v11 = fstatat(v9, v10, &v15, 32);
  v12 = *__error();
  v13 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136317698;
    v17 = "log_map_access_error";
    v18 = 1024;
    v19 = 4817;
    v20 = 2080;
    v21 = a4;
    v22 = 2080;
    v23 = v10;
    v24 = 2048;
    v25 = a1;
    v26 = 2048;
    v27 = a2;
    v28 = 2048;
    v29 = a2 + a3;
    v30 = 1024;
    v31 = v11;
    v32 = 2048;
    st_size = v15.st_size;
    v34 = 1024;
    st_dev = v15.st_dev;
    v36 = 2048;
    st_ino = v15.st_ino;
    _os_log_error_impl(&dword_1B8270000, v13, OS_LOG_TYPE_ERROR, "%s:%d: Got exception on %s %s addr:%p start:%p map end:%p sres:%d file_size:%lld dev:%d ino:%lld", buf, 0x64u);
  }
  result = __error();
  *result = v12;
  return result;
}

int *log_map_access_error_mini(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v7;
  char *v8;
  int v9;
  int v10;
  NSObject *v11;
  int *result;
  stat v13;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  uint64_t v19;
  __int16 v20;
  char *v21;
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  int v27;
  __int16 v28;
  off_t st_size;
  __int16 v30;
  dev_t st_dev;
  __int16 v32;
  __darwin_ino64_t st_ino;
  _OWORD v34[16];
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  if (a4)
    v7 = *(_DWORD *)(a4 + 44);
  else
    v7 = -1;
  memset(&v13, 0, sizeof(v13));
  memset(v34, 0, sizeof(v34));
  v8 = fd_name(a4, (char *)v34, 0x100uLL);
  v9 = fstatat(v7, v8, &v13, 32);
  v10 = *__error();
  v11 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136317442;
    v15 = "log_map_access_error_mini";
    v16 = 1024;
    v17 = 4827;
    v18 = 2080;
    v19 = a1;
    v20 = 2080;
    v21 = v8;
    v22 = 2048;
    v23 = a2;
    v24 = 2080;
    v25 = a3;
    v26 = 1024;
    v27 = v9;
    v28 = 2048;
    st_size = v13.st_size;
    v30 = 1024;
    st_dev = v13.st_dev;
    v32 = 2048;
    st_ino = v13.st_ino;
    _os_log_error_impl(&dword_1B8270000, v11, OS_LOG_TYPE_ERROR, "%s:%d: Got exception on %s %s addr:%p %s sres:%d file_size:%lld dev:%d ino:%lld", buf, 0x5Au);
  }
  result = __error();
  *result = v10;
  return result;
}

char *__si_assert_copy_extra_2151(_DWORD *a1, int a2)
{
  int v4;
  int v5;
  char *v6;
  int v7;
  int v8;
  char *v9;
  const char *v10;
  const char *v11;
  char *v13;
  char v14[1024];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  bzero(v14, 0x400uLL);
  if (a1)
  {
    v13 = 0;
    v4 = _fd_acquire_fd((uint64_t)a1, &v13);
    if (v4 != -1)
    {
      v5 = v4;
      v6 = v14;
      v7 = fcntl(v4, 50, v14);
      v8 = v14[0];
      _fd_release_fd(a1, v5, 0, (uint64_t)v13);
      if ((v7 & 0x80000000) == 0)
      {
        if (v8)
          goto LABEL_12;
      }
    }
  }
  else if (a2 != -1)
  {
    v6 = v14;
    if ((fcntl(a2, 50, v14) & 0x80000000) == 0)
    {
      if (v14[0])
        goto LABEL_12;
    }
  }
  v9 = getcwd(v14, 0x400uLL);
  if (v9)
    v6 = v9;
  else
    v6 = "";
LABEL_12:
  v13 = 0;
  v10 = (const char *)pthread_getspecific(__THREAD_STR_DATA_KEY);
  if (v10)
    v11 = v10;
  else
    v11 = "";
  asprintf(&v13, "%s %s", v6, v11);
  return v13;
}

void bit_vector_set_bits(uint64_t a1, CFIndex a2, CFIndex a3)
{
  char *v6;
  char *v7;
  const char *v8;
  CFRange v9;

  if (a2 < 0)
  {
    v6 = __si_assert_copy_extra_2151(0, -1);
    v7 = v6;
    v8 = "";
    if (v6)
      v8 = v6;
    __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 151, "range.location >= 0", v8);
    free(v7);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  if (a3 >= 1)
  {
    bit_vector_internal_touch_for_set((CFIndex *)a1, a3 + a2 - 1);
    v9.location = a2;
    v9.length = a3;
    CFBitVectorSetBits(*(CFMutableBitVectorRef *)(a1 + 16), v9, 1u);
  }
}

void bit_vector_internal_touch_for_set(CFIndex *a1, CFIndex a2)
{
  CFIndex v4;
  CFIndex v5;
  char *v6;
  char *v7;
  const char *v8;
  const __CFBitVector *v9;
  const __CFAllocator *v10;
  __CFBitVector *MutableCopy;
  __CFBitVector *v12;
  const void *v13;
  char *v14;
  const char *v15;

  v4 = a1[1];
  if (v4 <= a2)
  {
    if (v4)
      v5 = a1[1];
    else
      v5 = 32;
    while (1)
    {
      v5 *= 2;
      if (v5 > a2)
        break;
      if (v5 <= v4)
      {
        v6 = __si_assert_copy_extra_2151(0, -1);
        v7 = v6;
        v8 = "";
        if (v6)
          v8 = v6;
        __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 111, "newCapacity > bv->capacity", v8);
        goto LABEL_13;
      }
    }
    v9 = (const __CFBitVector *)a1[2];
    v10 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    if (v9)
      MutableCopy = CFBitVectorCreateMutableCopy(v10, v5, v9);
    else
      MutableCopy = CFBitVectorCreateMutable(v10, v5);
    v12 = MutableCopy;
    if (!MutableCopy)
    {
      v14 = __si_assert_copy_extra_2151(0, -1);
      v7 = v14;
      v15 = "";
      if (v14)
        v15 = v14;
      __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 115, "newBV", v15);
LABEL_13:
      free(v7);
      if (__valid_fs(-1))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
    CFBitVectorSetCount(MutableCopy, v5);
    v13 = (const void *)a1[2];
    if (v13)
      CFRelease(v13);
    a1[1] = v5;
    a1[2] = (CFIndex)v12;
  }
  if (*a1 <= a2)
    *a1 = a2 + 1;
}

{
  CFIndex v4;
  CFIndex v5;
  char *v6;
  char *v7;
  const char *v8;
  const __CFBitVector *v9;
  const __CFAllocator *v10;
  __CFBitVector *MutableCopy;
  __CFBitVector *v12;
  const void *v13;
  char *v14;
  const char *v15;

  v4 = a1[1];
  if (v4 <= a2)
  {
    if (v4)
      v5 = a1[1];
    else
      v5 = 32;
    while (1)
    {
      v5 *= 2;
      if (v5 > a2)
        break;
      if (v5 <= v4)
      {
        v6 = __si_assert_copy_extra_268();
        v7 = v6;
        v8 = "";
        if (v6)
          v8 = v6;
        __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 111, "newCapacity > bv->capacity", v8);
        goto LABEL_13;
      }
    }
    v9 = (const __CFBitVector *)a1[2];
    v10 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    if (v9)
      MutableCopy = CFBitVectorCreateMutableCopy(v10, v5, v9);
    else
      MutableCopy = CFBitVectorCreateMutable(v10, v5);
    v12 = MutableCopy;
    if (!MutableCopy)
    {
      v14 = __si_assert_copy_extra_268();
      v7 = v14;
      v15 = "";
      if (v14)
        v15 = v14;
      __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 115, "newBV", v15);
LABEL_13:
      free(v7);
      if (__valid_fs(-1))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
    CFBitVectorSetCount(MutableCopy, v5);
    v13 = (const void *)a1[2];
    if (v13)
      CFRelease(v13);
    a1[1] = v5;
    a1[2] = (CFIndex)v12;
  }
  if (*a1 <= a2)
    *a1 = a2 + 1;
}

uint64_t store_stream_write_bytes_2184(uint64_t a1, char *__src, size_t __n)
{
  size_t v3;
  uint64_t v6;
  size_t v7;
  uint64_t result;
  size_t v9;

  v3 = __n;
  v7 = *(_QWORD *)(a1 + 32);
  v6 = *(_QWORD *)(a1 + 40);
  if (v6 + __n >= v7)
  {
    while (1)
    {
      v9 = v7 - v6;
      memcpy((void *)(*(_QWORD *)(a1 + 48) + v6), __src, v7 - v6);
      *(_QWORD *)(a1 + 40) += v9;
      result = store_stream_flush((unsigned int *)a1, 0);
      if ((_DWORD)result)
        break;
      __src += v9;
      v3 -= v9;
      v7 = *(_QWORD *)(a1 + 32);
      v6 = *(_QWORD *)(a1 + 40);
      if (v6 + v3 < v7)
        goto LABEL_2;
    }
  }
  else
  {
LABEL_2:
    result = (uint64_t)memcpy((void *)(*(_QWORD *)(a1 + 48) + v6), __src, v3);
    *(_QWORD *)(a1 + 40) += v3;
  }
  return result;
}

_QWORD *store_stream_write_vint32_2186(_QWORD *result, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  _BYTE *v5;
  _BYTE *v6;
  _BYTE *v7;
  size_t v8;
  _OWORD v9[2];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v2 = result[5];
  if ((unint64_t)(result[4] - v2) < 6)
  {
    memset(v9, 0, sizeof(v9));
    if (a2 >> 28)
    {
      LOBYTE(v9[0]) = a2 | 0x80;
      BYTE1(v9[0]) = (a2 >> 7) | 0x80;
      BYTE2(v9[0]) = (a2 >> 14) | 0x80;
      BYTE3(v9[0]) = (a2 >> 21) | 0x80;
      BYTE4(v9[0]) = a2 >> 28;
      v8 = 5;
    }
    else if ((a2 & 0xFE00000) != 0)
    {
      LOBYTE(v9[0]) = a2 | 0x80;
      BYTE1(v9[0]) = (a2 >> 7) | 0x80;
      BYTE2(v9[0]) = (a2 >> 14) | 0x80;
      BYTE3(v9[0]) = (a2 & 0xFE00000) >> 21;
      v8 = 4;
    }
    else if ((a2 & 0x1FC000) != 0)
    {
      LOBYTE(v9[0]) = a2 | 0x80;
      BYTE1(v9[0]) = (a2 >> 7) | 0x80;
      BYTE2(v9[0]) = (a2 & 0x1FC000) >> 14;
      v8 = 3;
    }
    else if ((a2 & 0x3F80) != 0)
    {
      LOBYTE(v9[0]) = a2 | 0x80;
      BYTE1(v9[0]) = (unsigned __int16)(a2 & 0x3F80) >> 7;
      v8 = 2;
    }
    else
    {
      LOBYTE(v9[0]) = a2;
      v8 = 1;
    }
    return (_QWORD *)store_stream_write_bytes_2184((uint64_t)result, (char *)v9, v8);
  }
  else
  {
    v3 = result[6];
    v4 = a2 >> 28;
    if (a2 >> 28)
    {
      v6 = (_BYTE *)(v3 + v2);
      *v6 = a2 | 0x80;
      v6[1] = (a2 >> 7) | 0x80;
      v6[2] = (a2 >> 14) | 0x80;
      v2 += 4;
      v6[3] = (a2 >> 21) | 0x80;
    }
    else if ((a2 & 0xFE00000) != 0)
    {
      v5 = (_BYTE *)(v3 + v2);
      *v5 = a2 | 0x80;
      v5[1] = (a2 >> 7) | 0x80;
      v2 += 3;
      v5[2] = (a2 >> 14) | 0x80;
      v4 = (a2 & 0xFE00000) >> 21;
    }
    else if ((a2 & 0x1FC000) != 0)
    {
      v7 = (_BYTE *)(v3 + v2);
      *v7 = a2 | 0x80;
      v2 += 2;
      v7[1] = (a2 >> 7) | 0x80;
      v4 = (a2 & 0x1FC000) >> 14;
    }
    else if ((a2 & 0x3F80) != 0)
    {
      *(_BYTE *)(v3 + v2++) = a2 | 0x80;
      v4 = (unsigned __int16)(a2 & 0x3F80) >> 7;
    }
    else
    {
      LOBYTE(v4) = a2;
    }
    *(_BYTE *)(v3 + v2) = v4;
    result[5] = v2 + 1;
  }
  return result;
}

void oqpush_2205(uint64_t a1, uint64_t a2, size_t size)
{
  uint64_t v5;
  char *v6;
  char *v7;
  const char *v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  size_t v13;
  void *v14;
  uint64_t v15;
  char *v16;
  const char *v17;
  char *v18;
  uint8_t buf[16];

  if (*(_BYTE *)a1)
  {
    v16 = __si_assert_copy_extra_2151(0, -1);
    v7 = v16;
    v17 = "";
    if (v16)
      v17 = v16;
    __message_assert("%s:%u: failed assertion '%s' %s ", "OQueue.h", 327, "!oqueue->has_meta", v17);
LABEL_26:
    free(v7);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  if (!*(_DWORD *)(a1 + 56))
  {
    v10 = *(_QWORD *)(a1 + 24);
    v5 = *(_QWORD *)(a1 + 32);
    if (v5 < v10)
      goto LABEL_18;
    v11 = 2 * v10;
    if (!v10)
      v11 = 4;
    *(_QWORD *)(a1 + 24) = v11;
    v12 = *(void **)(a1 + 16);
    v13 = 8 * v11;
    if (v12)
    {
      v14 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, v12, v13, 0xECA6AA46uLL);
      if (!v14)
      {
LABEL_15:
        if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_fault_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "allocation function returned null", buf, 2u);
        }
      }
    }
    else
    {
      v14 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v13, 0x8DDAA030uLL);
      if (!v14)
        goto LABEL_15;
    }
    *(_QWORD *)(a1 + 16) = v14;
    v5 = *(_QWORD *)(a1 + 32);
    goto LABEL_18;
  }
  if (*(_QWORD *)(a1 + 64) < (a2 & 0x3FFFFFFFFFFFFFFFuLL))
  {
    v18 = __si_assert_copy_extra_2151(0, -1);
    v7 = v18;
    v8 = "";
    if (v18)
      v8 = v18;
    v9 = "!queue->split || queue->splitPoint >= offset_t_GET_VALUE(value)";
    goto LABEL_25;
  }
  v5 = *(_QWORD *)(a1 + 32);
  if (v5 >= *(_QWORD *)(a1 + 24))
  {
    v6 = __si_assert_copy_extra_2151(0, -1);
    v7 = v6;
    v8 = "";
    if (v6)
      v8 = v6;
    v9 = "!queue->split";
LABEL_25:
    __message_assert("%s:%u: failed assertion '%s' %s ", "OQueue.h", 247, v9, v8);
    goto LABEL_26;
  }
LABEL_18:
  v15 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 32) = v5 + 1;
  *(_QWORD *)(v15 + 8 * v5) = a2;
}

float oq_meta_at_index(uint64_t a1, uint64_t a2)
{
  char *v3;
  char *v4;
  const char *v5;

  if (!*(_BYTE *)a1)
  {
    v3 = __si_assert_copy_extra_2151(0, -1);
    v4 = v3;
    v5 = "";
    if (v3)
      v5 = v3;
    __message_assert("%s:%u: failed assertion '%s' %s ", "OQueue.h", 318, "oqueue->has_meta", v5);
    free(v4);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  return *(float *)(*(_QWORD *)(a1 + 16) + 16 * a2 + 8);
}

uint64_t oq_set_offset_with_meta_at_index(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v4;
  char *v5;
  char *v6;
  const char *v7;

  if (!*(_BYTE *)result)
  {
    v5 = __si_assert_copy_extra_2151(0, -1);
    v6 = v5;
    v7 = "";
    if (v5)
      v7 = v5;
    __message_assert("%s:%u: failed assertion '%s' %s ", "OQueue.h", 467, "queue->has_meta", v7);
    free(v6);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v4 = (_QWORD *)(*(_QWORD *)(result + 16) + 16 * a2);
  *v4 = a3;
  v4[1] = a4;
  return result;
}

uint64_t oq_set_offset_at_index(uint64_t result, uint64_t a2, uint64_t a3)
{
  char *v3;
  char *v4;
  const char *v5;

  if (*(_BYTE *)result)
  {
    v3 = __si_assert_copy_extra_2151(0, -1);
    v4 = v3;
    v5 = "";
    if (v3)
      v5 = v3;
    __message_assert("%s:%u: failed assertion '%s' %s ", "OQueue.h", 461, "!queue->has_meta", v5);
    free(v4);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  *(_QWORD *)(*(_QWORD *)(result + 16) + 8 * a2) = a3;
  return result;
}

uint64_t index_DeleteIndex(uint64_t a1, uint64_t a2, const char *a3, int a4)
{
  int v8;
  NSObject *v9;
  int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v19;
  BOOL v20;
  char *v21;
  char *v22;
  char *v23;
  const char *v24;
  char __str[779];
  stat buf[7];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  bzero(__str, 0x400uLL);
  if (a1)
  {
    v8 = *__error();
    v9 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      v10 = *(_DWORD *)(a1 + 56);
      v11 = *(_DWORD *)(a1 + 48);
      buf[0].st_dev = 67109634;
      *(_DWORD *)&buf[0].st_mode = v10;
      LOWORD(buf[0].st_ino) = 1024;
      *(_DWORD *)((char *)&buf[0].st_ino + 2) = v11;
      HIWORD(buf[0].st_ino) = 2080;
      *(_QWORD *)&buf[0].st_uid = a1 + 15168;
      _os_log_impl(&dword_1B8270000, v9, OS_LOG_TYPE_DEFAULT, "### delete index [%d] %d %s", (uint8_t *)buf, 0x18u);
    }
    *__error() = v8;
    fd_zero_truncate(*(_QWORD *)(a1 + 4656));
    fd_zero_truncate(*(_QWORD *)(a1 + 200));
    fd_zero_truncate(*(_QWORD *)(a1 + 464));
    v12 = *(_QWORD *)(a1 + 5176);
    if (v12)
      fd_zero_truncate(v12);
    fd_zero_truncate(*(_QWORD *)(a1 + 9400));
    v13 = *(_QWORD *)(a1 + 9888);
    if (v13)
      fd_zero_truncate(v13);
    fd_zero_truncate(*(_QWORD *)(a1 + 14112));
    fd_zero_truncate(*(_QWORD *)(a1 + 14408));
    fd_zero_truncate(*(_QWORD *)(a1 + 14416));
    fd_zero_truncate(*(_QWORD *)(a1 + 14424));
    fd_zero_truncate(*(_QWORD *)(a1 + 14432));
    fd_zero_truncate(*(_QWORD *)(a1 + 14440));
    fd_zero_truncate(*(_QWORD *)(a1 + 14448));
    v14 = *(_QWORD *)(a1 + 4904);
    if (v14)
      fd_zero_truncate(*(_QWORD *)(v14 + 224));
    v15 = *(_QWORD *)(a1 + 4896);
    if (v15)
      truncateVectorIndex(v15);
    a2 = *(unsigned int *)(a1 + 56);
    if (a4)
      freeIndex(a1);
  }
  if ((_DWORD)a2 == -1)
  {
    v22 = __si_assert_copy_extra_2151(0, -1);
    v23 = v22;
    v24 = "";
    if (v22)
      v24 = v22;
    __message_assert("%s:%u: failed assertion '%s' %s ", "JHContentIndex.c", 1027, "parentDirFd!=-1", v24);
    free(v23);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  memset(buf, 0, 144);
  if (!fstat(a2, buf))
  {
    v16 = open(".", 4);
    if (MEMORY[0x1BCCB1484](a2))
    {
      if ((v16 & 0x80000000) != 0)
        goto LABEL_19;
      goto LABEL_18;
    }
    bzero(buf, 0x400uLL);
    snprintf((char *)buf, 0x400uLL, "%s%s", a3, "indexDirectory");
    unlink((const char *)buf);
    snprintf((char *)buf, 0x400uLL, "%s%s", a3, "indexCompactDirectory");
    unlink((const char *)buf);
    snprintf((char *)buf, 0x400uLL, "%s%s", a3, "indexPostings");
    unlink((const char *)buf);
    snprintf((char *)buf, 0x400uLL, "%s%s", a3, "indexPositions");
    unlink((const char *)buf);
    snprintf((char *)buf, 0x400uLL, "%s%s", a3, "indexArrays");
    unlink((const char *)buf);
    snprintf((char *)buf, 0x400uLL, "%s%s", a3, "indexTermIds");
    unlink((const char *)buf);
    snprintf((char *)buf, 0x400uLL, "%s%s", a3, "indexPositionTable");
    unlink((const char *)buf);
    MEMORY[0x1BCCB1484](v16);
    if ((v16 & 0x80000000) == 0)
LABEL_18:
      close(v16);
  }
LABEL_19:
  memset(buf, 0, 144);
  if (!fstat(a2, buf))
  {
    v17 = open(".", 4);
    if (MEMORY[0x1BCCB1484](a2))
    {
      if ((v17 & 0x80000000) == 0)
LABEL_22:
        close(v17);
    }
    else
    {
      snprintf(__str, 0x400uLL, "%s%s", a3, "indexHead");
      unlink(__str);
      snprintf(__str, 0x400uLL, "%s%s", a3, "indexId");
      unlink(__str);
      snprintf(__str, 0x400uLL, "%s%s", a3, "indexIds");
      unlink(__str);
      snprintf(__str, 0x400uLL, "%s%s", a3, "indexDates");
      unlink(__str);
      snprintf(__str, 0x400uLL, "%s%s", a3, "indexBigDates");
      unlink(__str);
      snprintf(__str, 0x400uLL, "%s%s", a3, "indexScores");
      unlink(__str);
      snprintf(__str, 0x400uLL, "%s%s", a3, "indexGroups");
      unlink(__str);
      snprintf(__str, 0x400uLL, "%s%s", a3, "indexUpdates");
      unlink(__str);
      snprintf(__str, 0x400uLL, "%s%s", a3, "topK.v2.mdplistc");
      unlink(__str);
      bzero(buf, 0x400uLL);
      snprintf((char *)buf, 0x400uLL, "%s%s", a3, "directoryStoreFile");
      unlink((const char *)buf);
      v19 = fcntl(a2, 50, __str);
      if (__str[0])
        v20 = v19 < 0;
      else
        v20 = 1;
      if (v20)
        v21 = 0;
      else
        v21 = __str;
      IVFVectorIndex_s::unlink((IVFVectorIndex_s *)v21, a3, 0);
      MEMORY[0x1BCCB1484](v17);
      if ((v17 & 0x80000000) == 0)
        goto LABEL_22;
    }
  }
  return index_DeleteShadow(a2, a3, 0);
}

void freeIndex(uint64_t a1)
{
  void *v2;
  unsigned int v3;
  size_t v4;
  void *v5;
  void *v6;
  void *v7;
  const void *v8;
  char *v9;
  int v10;
  int v11;
  void *v12;
  _QWORD *v13;
  const void *v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;
  const void *v19;

  if (a1)
  {
    v2 = *(void **)(a1 + 14392);
    if ((unint64_t)v2 + 1 >= 2)
    {
      v3 = *(_DWORD *)(a1 + 64);
      if (*(_BYTE *)(a1 + 37))
        v4 = v3;
      else
        v4 = (4 * v3 + 4) / 5;
      munmap(v2, v4);
      *(_QWORD *)(a1 + 14392) = 0;
    }
    free(*(void **)(a1 + 14400));
    *(_QWORD *)(a1 + 14400) = 0;
    fd_release(*(char **)(a1 + 14432));
    *(_QWORD *)(a1 + 14432) = 0;
    v5 = *(void **)(a1 + 14368);
    if (v5)
    {
      munmap(v5, 8 * *(unsigned int *)(a1 + 64));
      *(_QWORD *)(a1 + 14368) = 0;
    }
    v6 = *(void **)(a1 + 14376);
    if (v6)
    {
      munmap(v6, 4 * *(unsigned int *)(a1 + 64));
      *(_QWORD *)(a1 + 14376) = 0;
    }
    v7 = *(void **)(a1 + 14384);
    if (v7)
    {
      munmap(v7, 8 * *(unsigned int *)(a1 + 64));
      *(_QWORD *)(a1 + 14384) = 0;
    }
    v8 = *(const void **)(a1 + 14456);
    if (v8)
    {
      CFRelease(v8);
      *(_QWORD *)(a1 + 14456) = 0;
    }
    v9 = *(char **)(a1 + 14448);
    if (v9)
    {
      fd_release(v9);
      *(_QWORD *)(a1 + 14448) = 0;
    }
    fd_release(*(char **)(a1 + 14408));
    *(_QWORD *)(a1 + 14408) = 0;
    fd_release(*(char **)(a1 + 14416));
    *(_QWORD *)(a1 + 14416) = 0;
    fd_release(*(char **)(a1 + 14424));
    *(_QWORD *)(a1 + 14424) = 0;
    v10 = *(_DWORD *)(a1 + 9408);
    if (v10 != -1)
    {
      _fd_release_fd(*(_DWORD **)(a1 + 9400), v10, 0, *(_QWORD *)(a1 + 9416));
      *(_DWORD *)(a1 + 9408) = -1;
    }
    fd_release(*(char **)(a1 + 9400));
    *(_QWORD *)(a1 + 9400) = 0;
    storageClose(a1 + 4960);
    v11 = *(_DWORD *)(a1 + 14120);
    if (v11 != -1)
    {
      _fd_release_fd(*(_DWORD **)(a1 + 14112), v11, 0, *(_QWORD *)(a1 + 14128));
      *(_DWORD *)(a1 + 14120) = -1;
    }
    fd_release(*(char **)(a1 + 14112));
    *(_QWORD *)(a1 + 14112) = 0;
    storageClose(a1 + 9672);
    fd_release(*(char **)(a1 + 4656));
    *(_QWORD *)(a1 + 4656) = 0;
    v12 = *(void **)(a1 + 96);
    if ((unint64_t)v12 + 1 >= 2)
    {
      munmap(v12, 1028 * *(unsigned int *)(a1 + 236));
      *(_QWORD *)(a1 + 96) = 0;
    }
    closeMF(a1 + 104);
    storageClose(a1 + 248);
    fd_release(*(char **)(a1 + 14440));
    *(_QWORD *)(a1 + 14440) = 0;
    v13 = *(_QWORD **)(a1 + 4904);
    if (v13)
    {
      storageClose((uint64_t)(v13 + 1));
      v14 = (const void *)v13[549];
      if (v14)
        CFRelease(v14);
      free(v13);
      *(_QWORD *)(a1 + 4904) = 0;
    }
    v15 = *(_QWORD *)(a1 + 4896);
    if (v15)
    {
      IVFVectorIndex_s::~IVFVectorIndex_s((void **)(v15 + 8));
      MEMORY[0x1BCCB06A4](v15, 0x1032C4065068D8BLL);
      *(_QWORD *)(a1 + 4896) = 0;
    }
    freePayload(a1 + 4920);
    freePayload(a1 + 9632);
    bt_freeTrie(a1 + 88);
    v16 = *(_QWORD *)(a1 + 14352);
    if (v16)
    {
      TermUpdateSetRemoveFromAccounting(v16);
      TermUpdateSetRelease(*(_QWORD *)(a1 + 14352));
      do
        v17 = __ldaxr(gTermUpdateSetCount);
      while (__stlxr(v17 - 1, gTermUpdateSetCount));
    }
    v18 = *(_QWORD *)(a1 + 14360);
    if (v18)
      TermUpdateSetRelease(v18);
    db_rwlock_destroy((pthread_mutex_t *)(a1 + 14680));
    db_rwlock_destroy((pthread_mutex_t *)(a1 + 14464));
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 15016));
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 15080));
    dispatch_release(*(dispatch_object_t *)(a1 + 16424));
    free(*(void **)(a1 + 14400));
    *(_QWORD *)(a1 + 14400) = 0;
    v19 = *(const void **)(a1 + 15144);
    if (v19)
      _Block_release(v19);
    *(_QWORD *)(a1 + 15144) = 0;
    _Block_release(*(const void **)(a1 + 4912));
    free((void *)a1);
  }
}

uint64_t index_DeleteShadow(uint64_t a1, const char *a2, char a3)
{
  uint64_t v6;
  uint64_t result;
  uint64_t v8;
  int v9;
  BOOL v10;
  char *v11;
  char __str[1024];
  stat v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  bzero(__str, 0x400uLL);
  memset(&v13, 0, sizeof(v13));
  if (!fstat(a1, &v13))
  {
    v6 = open(".", 4);
    if (MEMORY[0x1BCCB1484](a1))
    {
      if ((v6 & 0x80000000) != 0)
        goto LABEL_5;
      goto LABEL_4;
    }
    bzero(&v13, 0x400uLL);
    snprintf((char *)&v13, 0x400uLL, "%s%s", a2, "shadowIndexDirectory");
    unlink((const char *)&v13);
    snprintf((char *)&v13, 0x400uLL, "%s%s", a2, "shadowIndexCompactDirectory");
    unlink((const char *)&v13);
    snprintf((char *)&v13, 0x400uLL, "%s%s", a2, "shadowIndexArrays");
    unlink((const char *)&v13);
    MEMORY[0x1BCCB1484](v6);
    if ((v6 & 0x80000000) == 0)
LABEL_4:
      close(v6);
  }
LABEL_5:
  memset(&v13, 0, sizeof(v13));
  result = fstat(a1, &v13);
  if ((_DWORD)result)
    return result;
  v8 = open(".", 4);
  result = MEMORY[0x1BCCB1484](a1);
  if ((_DWORD)result)
  {
    if ((v8 & 0x80000000) != 0)
      return result;
    return close(v8);
  }
  if ((a3 & 1) == 0)
  {
    snprintf(__str, 0x400uLL, "%s%s", a2, "shadowIndexHead");
    unlink(__str);
    snprintf(__str, 0x400uLL, "%s%s", a2, "shadowIndexGroups");
    unlink(__str);
    bzero(&v13, 0x400uLL);
    snprintf((char *)&v13, 0x400uLL, "%s%s.shadow", a2, "directoryStoreFile");
    unlink((const char *)&v13);
    v9 = fcntl(a1, 50, __str);
    if (__str[0])
      v10 = v9 < 0;
    else
      v10 = 1;
    if (v10)
      v11 = 0;
    else
      v11 = __str;
    IVFVectorIndex_s::unlink((IVFVectorIndex_s *)v11, a2, (const char *)1);
  }
  snprintf(__str, 0x400uLL, "%s%s", a2, "shadowIndexTermIds");
  unlink(__str);
  snprintf(__str, 0x400uLL, "%s%s", a2, "shadowIndexPositionTable");
  unlink(__str);
  result = MEMORY[0x1BCCB1484](v8);
  if ((v8 & 0x80000000) == 0)
    return close(v8);
  return result;
}

uint64_t createIndex(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, __int16 a5, char a6, int a7, int *a8, int a9, uint64_t a10, uint64_t a11, const void *a12)
{
  int v20;
  NSObject *v21;
  os_log_type_t v22;
  char *v23;
  uint64_t v24;
  unsigned int *v25;
  unsigned int v26;
  int v27;
  int v28;
  NSObject *v29;
  os_log_type_t v30;
  int v31;
  NSObject *v32;
  _QWORD *v34;
  _QWORD *v35;
  int v36;
  int v37;
  unsigned int v38;
  unint64_t v39;
  char *v40;
  char *v41;
  int v42;
  NSObject *v43;
  int v44;
  _QWORD *v45;
  off_t v46;
  _QWORD *v47;
  char *v48;
  unsigned int *v49;
  unsigned int v50;
  _OWORD *ForwardStore;
  int v52;
  NSObject *v53;
  int v54;
  int v55;
  BOOL *v57;
  char v58;
  uint8_t v59[32];
  statfs buf;
  char __str[1024];
  uint64_t v62;

  v62 = *MEMORY[0x1E0C80C00];
  bzero(__str, 0x400uLL);
  *a8 = -1;
  if (!a2)
    a2 = "";
  if ((a5 & 0x1000) != 0)
  {
    v28 = *__error();
    v29 = _SILogForLogForCategory(10);
    v30 = 2 * (dword_1EF19FCB4 < 4);
    if (os_log_type_enabled(v29, v30))
    {
      LOWORD(buf.f_bsize) = 0;
      _os_log_impl(&dword_1B8270000, v29, v30, "creating new index not allowed during locked indexing", (uint8_t *)&buf, 2u);
    }
    *__error() = v28;
    goto LABEL_67;
  }
  v58 = a6;
  v20 = *__error();
  v21 = _SILogForLogForCategory(10);
  v22 = 2 * (dword_1EF19FCB4 < 4);
  if (os_log_type_enabled(v21, v22))
  {
    buf.f_bsize = 136315138;
    *(_QWORD *)&buf.f_iosize = a2;
    _os_log_impl(&dword_1B8270000, v21, v22, "creating index at %s", (uint8_t *)&buf, 0xCu);
  }
  *__error() = v20;
  index_DeleteIndex(0, a1, a2, 1);
  v23 = (char *)malloc_type_calloc(1uLL, 0x4040uLL, 0x10F0040CEEE6884uLL);
  if (!v23)
  {
    *a8 = -1;
    goto LABEL_67;
  }
  v24 = (uint64_t)v23;
  v57 = (BOOL *)(v23 + 15162);
  initIndex((uint64_t)v23, a12);
  __strlcpy_chk();
  *(_DWORD *)(v24 + 4) = a9;
  if (a7 && (v58 & 1) == 0)
  {
    v25 = (unsigned int *)(v24 + 28);
    do
      v26 = __ldaxr(v25);
    while (__stlxr(v26 | 8, v25));
  }
  *(_QWORD *)(v24 + 72) = a3;
  *(_DWORD *)(v24 + 80) = 1410;
  if (a11)
    v27 = (*(uint64_t (**)(uint64_t, _QWORD))(a11 + 16))(a11, 0);
  else
    v27 = 0;
  *(_DWORD *)(v24 + 48) = v27;
  *(_DWORD *)(v24 + 56) = a1;
  __strlcpy_chk();
  __strlcpy_chk();
  *(_QWORD *)(v24 + 60) = 0x100000000001;
  *v57 = (a5 & 0x10) != 0;
  *(_BYTE *)(v24 + 37) = HIBYTE(a5) & 1;
  *(_BYTE *)(v24 + 38) = (a5 & 0x400) != 0;
  v57[1279] = 0;
  bzero(&buf, 0x878uLL);
  if (fstatfs(a1, &buf))
  {
    v31 = *__error();
    v32 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v59 = 136315650;
      *(_QWORD *)&v59[4] = "createIndex";
      *(_WORD *)&v59[12] = 1024;
      *(_DWORD *)&v59[14] = 1430;
      *(_WORD *)&v59[18] = 2080;
      *(_QWORD *)&v59[20] = a4;
      _os_log_error_impl(&dword_1B8270000, v32, OS_LOG_TYPE_ERROR, "%s:%d: Couldn't statfs parent directory: %s", v59, 0x1Cu);
    }
    *__error() = v31;
  }
  else if (*(_DWORD *)buf.f_fstypename == 1634105445 && *(unsigned __int16 *)&buf.f_fstypename[4] == 116)
  {
    v57[1279] = 1;
  }
  snprintf(__str, 0x400uLL, "%s%s", a2, "indexHead");
  v34 = open_index_file(a1, __str, 1538, 0, 0, 0, 0, 0, a8);
  *(_QWORD *)(v24 + 14440) = v34;
  if (!v34)
    goto LABEL_65;
  v35 = v34;
  *(_QWORD *)v59 = 0;
  v36 = _fd_acquire_fd((uint64_t)v34, v59);
  if (v36 != -1)
  {
    v37 = v36;
    *((_WORD *)v35 + 28) |= 1u;
    fcntl(v36, 48, 1);
    fcntl(v37, 76, v35[7] & 1);
    _fd_release_fd(v35, v37, 0, *(uint64_t *)v59);
  }
  v38 = *(_DWORD *)(v24 + 48);
  if (v38)
  {
    memset(v59, 0, sizeof(v59));
    if ((v38 & 0xF0000000) != 0)
    {
      v59[0] = v38 | 0x80;
      v59[1] = (v38 >> 7) | 0x80;
      v59[2] = (v38 >> 14) | 0x80;
      v59[3] = (v38 >> 21) | 0x80;
      v59[4] = (unint64_t)(v38 & 0xF0000000) >> 28;
      v39 = 5;
    }
    else if ((v38 & 0xFE00000) != 0)
    {
      v59[0] = v38 | 0x80;
      v59[1] = (v38 >> 7) | 0x80;
      v59[2] = (v38 >> 14) | 0x80;
      v59[3] = (unint64_t)(v38 & 0xFE00000) >> 21;
      v39 = 4;
    }
    else if ((*(_QWORD *)&v38 & 0x1FC000) != 0)
    {
      v59[0] = v38 | 0x80;
      v59[1] = (v38 >> 7) | 0x80;
      v59[2] = (*(_QWORD *)&v38 & 0x1FC000uLL) >> 14;
      v39 = 3;
    }
    else if ((v38 & 0x3F80) != 0)
    {
      v59[0] = v38 | 0x80;
      v59[1] = (unint64_t)(v38 & 0x3F80) >> 7;
      v39 = 2;
    }
    else
    {
      v59[0] = v38;
      v39 = 1;
    }
    snprintf(__str, 0x400uLL, "%s%s", a2, "indexId");
    v40 = (char *)open_index_file(a1, __str, 1538, 0, 0, 1, 0, 2, a8);
    if (v40)
    {
      v41 = v40;
      fd_pwrite((uint64_t)v40, (uint64_t)v59, v39, 0);
      fd_release(v41);
    }
  }
  v42 = *__error();
  v43 = _SILogForLogForCategory(10);
  if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
  {
    v44 = *(_DWORD *)(v24 + 48);
    *(_DWORD *)v59 = 67109378;
    *(_DWORD *)&v59[4] = v44;
    *(_WORD *)&v59[8] = 2080;
    *(_QWORD *)&v59[10] = __str;
    _os_log_impl(&dword_1B8270000, v43, OS_LOG_TYPE_DEFAULT, "create indexid %u %s", v59, 0x12u);
  }
  *__error() = v42;
  snprintf(__str, 0x400uLL, "%s%s", a2, "indexIds");
  v45 = open_index_file(a1, __str, 1538, 0x8000, 0, 1, (uint64_t *)(v24 + 14368), 3, a8);
  *(_QWORD *)(v24 + 14408) = v45;
  if (!v45)
    goto LABEL_65;
  v57[3] = 1;
  snprintf(__str, 0x400uLL, "%s%s", a2, "indexBigDates");
  *(_QWORD *)(v24 + 14416) = open_index_file(a1, __str, 1538, 0x4000, 0, 1, (uint64_t *)(v24 + 14376), 3, a8);
  if ((a5 & 0x100) != 0)
  {
    snprintf(__str, 0x400uLL, "%s%s", a2, "indexScores");
    *(_QWORD *)(v24 + 14424) = open_index_file(a1, __str, 1538, 0x8000, 0, 1, (uint64_t *)(v24 + 14384), 3, a8);
  }
  snprintf(__str, 0x400uLL, "%s%s", a2, "indexGroups");
  v46 = *(_BYTE *)(v24 + 37) ? 4096 : 3277;
  v47 = open_index_file(a1, __str, 1538, v46, 0, 1, (uint64_t *)(v24 + 14392), 3, a8);
  *(_QWORD *)(v24 + 14432) = v47;
  if (!v47)
    goto LABEL_65;
  if (!openPayload(v24 + 4920, *(_DWORD *)(v24 + 56), a2, "indexPostings", "indexTermIds", __str, 0, 0, v58 ^ 1u, *(_DWORD *)(v24 + 4), *(void **)(v24 + 4912)))goto LABEL_65;
  if (!openPayload(v24 + 9632, *(_DWORD *)(v24 + 56), a2, "indexPositions", "indexPositionTable", __str, 0, 0, v58 ^ 1u, *(_DWORD *)(v24 + 4), *(void **)(v24 + 4912)))goto LABEL_65;
  if (!bt_openTrie(v24 + 88, *(_DWORD *)(v24 + 56), a2, 0, 0, 0, *(_DWORD *)(v24 + 4), *(void **)(v24 + 4912)))goto LABEL_65;
  snprintf(__str, 0x400uLL, "%s%s", a2, "indexUpdates");
  v48 = (char *)fd_create_protected(a1, __str, 1538, 0);
  fd_release(v48);
  if ((a5 & 0x40) != 0)
  {
    v49 = (unsigned int *)(v24 + 28);
    do
      v50 = __ldaxr(v49);
    while (__stlxr(v50 | 0x80, v49));
    ForwardStore = createForwardStore(a1, a2, *(void **)(v24 + 4912));
    *(_QWORD *)(v24 + 4904) = ForwardStore;
    if (!ForwardStore)
    {
LABEL_65:
      if (!*a8)
        return v24;
      freeIndex(v24);
LABEL_67:
      index_DeleteIndex(0, a1, a2, 1);
      return 0;
    }
  }
  if (_os_feature_enabled_impl())
  {
    v52 = *__error();
    v53 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
    {
      v54 = *(_DWORD *)(v24 + 48);
      *(_DWORD *)v59 = 67109120;
      *(_DWORD *)&v59[4] = v54;
      _os_log_impl(&dword_1B8270000, v53, OS_LOG_TYPE_DEFAULT, "create vector index for indexid %d", v59, 8u);
    }
    *__error() = v52;
    v55 = *(_DWORD *)(v24 + 48);
    if (v55)
    {
      *(_QWORD *)(v24 + 4896) = createVectorIndex(a1, a2, a10, v55);
      *(_QWORD *)(v24 + 14344) = a10;
    }
  }
  *(_BYTE *)(v24 + 8) = 1;
  *a8 = 0;
  return v24;
}

void *initIndex(uint64_t a1, const void *a2)
{
  void *result;
  pthread_mutexattr_t v5;
  pthread_rwlockattr_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  *(_DWORD *)a1 = -1163003219;
  v5.__sig = 0;
  *(_QWORD *)v5.__opaque = 0;
  pthread_mutexattr_init(&v5);
  pthread_mutex_init((pthread_mutex_t *)(a1 + 15016), &v5);
  pthread_mutex_init((pthread_mutex_t *)(a1 + 15080), &v5);
  pthread_mutexattr_destroy(&v5);
  *(_DWORD *)(a1 + 16416) = 0;
  *(_QWORD *)(a1 + 16424) = dispatch_semaphore_create(0);
  *(_OWORD *)(a1 + 14680) = 0u;
  *(_OWORD *)(a1 + 14696) = 0u;
  *(_OWORD *)(a1 + 14712) = 0u;
  *(_OWORD *)(a1 + 14728) = 0u;
  *(_OWORD *)(a1 + 14744) = 0u;
  *(_OWORD *)(a1 + 14760) = 0u;
  *(_OWORD *)(a1 + 14776) = 0u;
  *(_OWORD *)(a1 + 14792) = 0u;
  *(_OWORD *)(a1 + 14808) = 0u;
  *(_OWORD *)(a1 + 14824) = 0u;
  *(_OWORD *)(a1 + 14840) = 0u;
  *(_OWORD *)(a1 + 14856) = 0u;
  *(_OWORD *)(a1 + 14872) = 0u;
  *(_QWORD *)(a1 + 14888) = 0;
  pthread_mutex_init((pthread_mutex_t *)(a1 + 14680), 0);
  *(_OWORD *)(a1 + 14464) = 0u;
  *(_OWORD *)(a1 + 14480) = 0u;
  *(_OWORD *)(a1 + 14496) = 0u;
  *(_OWORD *)(a1 + 14512) = 0u;
  *(_OWORD *)(a1 + 14528) = 0u;
  *(_OWORD *)(a1 + 14544) = 0u;
  *(_OWORD *)(a1 + 14560) = 0u;
  *(_OWORD *)(a1 + 14576) = 0u;
  *(_OWORD *)(a1 + 14592) = 0u;
  *(_OWORD *)(a1 + 14608) = 0u;
  *(_OWORD *)(a1 + 14624) = 0u;
  *(_OWORD *)(a1 + 14640) = 0u;
  *(_OWORD *)(a1 + 14656) = 0u;
  *(_QWORD *)(a1 + 14672) = 0;
  pthread_mutex_init((pthread_mutex_t *)(a1 + 14464), 0);
  *(_DWORD *)(a1 + 9408) = -1;
  memset(&v6, 0, sizeof(v6));
  pthread_rwlockattr_init(&v6);
  pthread_rwlock_init((pthread_rwlock_t *)(a1 + 9432), &v6);
  pthread_rwlockattr_destroy(&v6);
  *(_DWORD *)(a1 + 14120) = -1;
  memset(&v6, 0, sizeof(v6));
  pthread_rwlockattr_init(&v6);
  pthread_rwlock_init((pthread_rwlock_t *)(a1 + 14144), &v6);
  pthread_rwlockattr_destroy(&v6);
  *(_QWORD *)(a1 + 4888) = 0;
  *(_OWORD *)(a1 + 4872) = 0u;
  *(_OWORD *)(a1 + 4856) = 0u;
  *(_OWORD *)(a1 + 4840) = 0u;
  *(_OWORD *)(a1 + 4824) = 0u;
  *(_OWORD *)(a1 + 4808) = 0u;
  *(_OWORD *)(a1 + 4792) = 0u;
  *(_OWORD *)(a1 + 4776) = 0u;
  *(_OWORD *)(a1 + 4760) = 0u;
  *(_OWORD *)(a1 + 4744) = 0u;
  *(_OWORD *)(a1 + 4728) = 0u;
  *(_OWORD *)(a1 + 4712) = 0u;
  *(_OWORD *)(a1 + 4696) = 0u;
  *(_OWORD *)(a1 + 4680) = 0u;
  pthread_mutex_init((pthread_mutex_t *)(a1 + 4680), 0);
  result = _Block_copy(a2);
  *(_QWORD *)(a1 + 4912) = result;
  return result;
}

_QWORD *open_index_file(int a1, const char *a2, int a3, off_t a4, off_t a5, int a6, uint64_t *a7, uint64_t a8, int *a9)
{
  _QWORD *v14;
  int v15;
  uint64_t v16;
  uint64_t v18;
  int *v19;
  int v20;
  NSObject *v21;
  const char *v22;
  stat *v23;
  NSObject *v24;
  uint32_t v25;
  int v26;
  NSObject *v27;
  uint64_t v28;
  NSObject *v29;
  gid_t v30;
  gid_t v32;
  gid_t v33;
  int v34;
  const char *v35;
  __int16 v36;
  int v37;
  __int16 v38;
  int st_size;
  __int16 v40;
  int v41;
  __int16 v42;
  const char *v43;
  stat v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  v14 = fd_create_protected(a1, a2, a3 | (((a3 & 3) != 0) << 29), 3u);
  if (!v14)
  {
    *a9 = *__error();
    v26 = *__error();
    v27 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      v32 = *a9;
      v44.st_dev = 136315906;
      *(_QWORD *)&v44.st_mode = "open_index_file";
      WORD2(v44.st_ino) = 1024;
      *(_DWORD *)((char *)&v44.st_ino + 6) = 1290;
      HIWORD(v44.st_uid) = 1024;
      v44.st_gid = v32;
      LOWORD(v44.st_rdev) = 2080;
      *(_QWORD *)((char *)&v44.st_rdev + 2) = a2;
      _os_log_error_impl(&dword_1B8270000, v27, OS_LOG_TYPE_ERROR, "%s:%d: open file error: %d, %s\n", (uint8_t *)&v44, 0x22u);
    }
    *__error() = v26;
    goto LABEL_23;
  }
  if (a5)
  {
    memset(&v44, 0, sizeof(v44));
    do
    {
      v15 = fstatat(*((_DWORD *)v14 + 11), (const char *)v14[9], &v44, 2048);
      v16 = g_prot_error_callback;
      if (v15 != -1 || g_prot_error_callback == 0)
        break;
      v18 = *((unsigned int *)v14 + 10);
      v19 = __error();
    }
    while (((*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t))(v16 + 16))(v16, v18, *v19, 8) & 1) != 0);
    if (v44.st_size < a5)
    {
      *a9 = -1;
      v20 = *__error();
      v21 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        v34 = 136316162;
        v35 = "open_index_file";
        v36 = 1024;
        v37 = 1298;
        v38 = 1024;
        st_size = v44.st_size;
        v40 = 1024;
        v41 = a5;
        v42 = 2080;
        v43 = a2;
        v22 = "%s:%d: bad file size: %d, min size %d, %s\n";
        v23 = (stat *)&v34;
        v24 = v21;
        v25 = 40;
LABEL_27:
        _os_log_error_impl(&dword_1B8270000, v24, OS_LOG_TYPE_ERROR, v22, (uint8_t *)v23, v25);
      }
LABEL_22:
      *__error() = v20;
LABEL_23:
      fd_release((char *)v14);
      return 0;
    }
  }
  if (a7)
  {
    v28 = fd_mmap((uint64_t)v14);
    *a7 = v28;
    if (v28 == -1)
    {
      *a9 = *__error();
      v20 = *__error();
      v29 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
        goto LABEL_22;
      v33 = *a9;
      v44.st_dev = 136316162;
      *(_QWORD *)&v44.st_mode = "open_index_file";
      WORD2(v44.st_ino) = 1024;
      *(_DWORD *)((char *)&v44.st_ino + 6) = 1306;
      HIWORD(v44.st_uid) = 1024;
      v44.st_gid = v33;
      LOWORD(v44.st_rdev) = 2048;
      *(_QWORD *)((char *)&v44.st_rdev + 2) = a4;
      WORD1(v44.st_atimespec.tv_sec) = 2080;
      *(__darwin_time_t *)((char *)&v44.st_atimespec.tv_sec + 4) = (__darwin_time_t)a2;
      v22 = "%s:%d: map error: %d, size: %lld, %s";
      goto LABEL_26;
    }
  }
  if (a6 && fd_truncate((uint64_t)v14, a4) == -1)
  {
    *a9 = *__error();
    v20 = *__error();
    v29 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      goto LABEL_22;
    v30 = *a9;
    v44.st_dev = 136316162;
    *(_QWORD *)&v44.st_mode = "open_index_file";
    WORD2(v44.st_ino) = 1024;
    *(_DWORD *)((char *)&v44.st_ino + 6) = 1312;
    HIWORD(v44.st_uid) = 1024;
    v44.st_gid = v30;
    LOWORD(v44.st_rdev) = 2048;
    *(_QWORD *)((char *)&v44.st_rdev + 2) = a4;
    WORD1(v44.st_atimespec.tv_sec) = 2080;
    *(__darwin_time_t *)((char *)&v44.st_atimespec.tv_sec + 4) = (__darwin_time_t)a2;
    v22 = "%s:%d: ftruncate error: %d, size: %lld, %s";
LABEL_26:
    v23 = &v44;
    v24 = v29;
    v25 = 44;
    goto LABEL_27;
  }
  return v14;
}

uint64_t *storeVInt64(uint64_t *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64x2_t v4;
  int16x8_t v5;
  uint64x2_t v6;
  uint64x2_t v7;
  int16x8_t v8;
  uint64x2_t v9;
  int16x8_t v10;

  v2 = *result;
  if (HIDWORD(a2))
  {
    if ((a2 & 0x8000000000000000) != 0)
    {
      *(_BYTE *)v2 = a2 | 0x80;
      v6 = (uint64x2_t)vdupq_n_s64(a2);
      *(int8x8_t *)(v2 + 1) = vorr_s8(vmovn_s16(vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v6, (uint64x2_t)xmmword_1B8631BA0), (int32x4_t)vshlq_u64(v6, (uint64x2_t)xmmword_1B8631B90)), (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v6, (uint64x2_t)xmmword_1B8631CB0), (int32x4_t)vshlq_u64(v6, (uint64x2_t)xmmword_1B8631CA0)))), (int8x8_t)0x8080808080808080);
      *(_BYTE *)(v2 + 9) = 1;
      v3 = 10;
    }
    else if ((a2 & 0x7F00000000000000) != 0)
    {
      v4 = (uint64x2_t)vdupq_n_s64(a2);
      *(_BYTE *)v2 = a2 | 0x80;
      v5 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v4, (uint64x2_t)xmmword_1B8631BA0), (int32x4_t)vshlq_u64(v4, (uint64x2_t)xmmword_1B8631B90));
      v5.i64[0] = *(_QWORD *)&vmovn_s32((int32x4_t)v5) | 0x80008000800080;
      *(_DWORD *)(v2 + 1) = vmovn_s16(v5).u32[0];
      *(_BYTE *)(v2 + 5) = (a2 >> 35) | 0x80;
      *(_BYTE *)(v2 + 6) = (a2 >> 42) | 0x80;
      *(_BYTE *)(v2 + 7) = (a2 >> 49) | 0x80;
      *(_BYTE *)(v2 + 8) = (a2 & 0x7F00000000000000) >> 56;
      v3 = 9;
    }
    else if ((a2 & 0xFE000000000000) != 0)
    {
      *(_BYTE *)v2 = a2 | 0x80;
      v7 = (uint64x2_t)vdupq_n_s64(a2);
      v8 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v7, (uint64x2_t)xmmword_1B8631BA0), (int32x4_t)vshlq_u64(v7, (uint64x2_t)xmmword_1B8631B90));
      v8.i64[0] = *(_QWORD *)&vmovn_s32((int32x4_t)v8) | 0x80008000800080;
      *(_DWORD *)(v2 + 1) = vmovn_s16(v8).u32[0];
      *(_BYTE *)(v2 + 5) = (a2 >> 35) | 0x80;
      *(_BYTE *)(v2 + 6) = (a2 >> 42) | 0x80;
      *(_BYTE *)(v2 + 7) = (a2 & 0xFE000000000000) >> 49;
      v3 = 8;
    }
    else
    {
      *(_BYTE *)v2 = a2 | 0x80;
      v9 = (uint64x2_t)vdupq_n_s64(a2);
      v10 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v9, (uint64x2_t)xmmword_1B8631BA0), (int32x4_t)vshlq_u64(v9, (uint64x2_t)xmmword_1B8631B90));
      v10.i64[0] = *(_QWORD *)&vmovn_s32((int32x4_t)v10) | 0x80008000800080;
      *(_DWORD *)(v2 + 1) = vmovn_s16(v10).u32[0];
      if ((a2 & 0x1FC0000000000) != 0)
      {
        *(_BYTE *)(v2 + 5) = (a2 >> 35) | 0x80;
        *(_BYTE *)(v2 + 6) = (a2 & 0x1FC0000000000) >> 42;
        v3 = 7;
      }
      else
      {
        *(_BYTE *)(v2 + 5) = (a2 >> 35) & 0x7F;
        v3 = 6;
      }
    }
  }
  else if ((a2 & 0x7F0000000) != 0)
  {
    *(_BYTE *)v2 = a2 | 0x80;
    *(_BYTE *)(v2 + 1) = (a2 >> 7) | 0x80;
    *(_BYTE *)(v2 + 2) = (a2 >> 14) | 0x80;
    *(_BYTE *)(v2 + 3) = (a2 >> 21) | 0x80;
    *(_BYTE *)(v2 + 4) = (a2 & 0x7F0000000) >> 28;
    v3 = 5;
  }
  else if ((a2 & 0xFE00000) != 0)
  {
    *(_BYTE *)v2 = a2 | 0x80;
    *(_BYTE *)(v2 + 1) = (a2 >> 7) | 0x80;
    *(_BYTE *)(v2 + 2) = (a2 >> 14) | 0x80;
    *(_BYTE *)(v2 + 3) = (a2 & 0xFE00000) >> 21;
    v3 = 4;
  }
  else if ((a2 & 0x1FC000) != 0)
  {
    *(_BYTE *)v2 = a2 | 0x80;
    *(_BYTE *)(v2 + 1) = (a2 >> 7) | 0x80;
    *(_BYTE *)(v2 + 2) = (a2 & 0x1FC000) >> 14;
    v3 = 3;
  }
  else if ((a2 & 0x3F80) != 0)
  {
    *(_BYTE *)v2 = a2 | 0x80;
    *(_BYTE *)(v2 + 1) = (a2 & 0x3F80) >> 7;
    v3 = 2;
  }
  else
  {
    *(_BYTE *)v2 = a2;
    v3 = 1;
  }
  *result += v3;
  return result;
}

uint64_t openPayload(uint64_t a1, int a2, const char *a3, const char *a4, const char *a5, char *__str, int a7, char a8, unsigned __int8 a9, int a10, void *a11)
{
  char v12;
  int v18;
  char *v19;
  char *v20;
  uint64_t result;
  uint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t v26;
  int *v27;
  int v28;
  NSObject *v29;
  int *v30;
  _QWORD *v31;
  int v32;
  NSObject *v33;
  int v34;
  NSObject *v35;
  int *v36;
  int v37;
  NSObject *v38;
  int *v39;
  int v40;
  int v41;
  int v42;
  off_t st_size;
  uint64_t v44;
  const char *v45;
  const char *v46;
  stat v47;
  uint8_t v48[4];
  const char *v49;
  __int16 v50;
  int v51;
  __int16 v52;
  off_t v53;
  __int16 v54;
  uint64_t v55;
  __int16 v56;
  const char *v57;
  uint8_t buf[4];
  const char *v59;
  __int16 v60;
  int v61;
  __int16 v62;
  int v63;
  __int16 v64;
  char *v65;
  uint64_t v66;

  v12 = a7;
  v66 = *MEMORY[0x1E0C80C00];
  if (a7)
    v18 = 0;
  else
    v18 = 536871426;
  snprintf(__str, 0x400uLL, "%s%s", a3, a4);
  v19 = (char *)fd_create_protected(a2, __str, v18, 3u);
  if (v19)
  {
    v20 = v19;
    if ((a8 & 1) != 0)
    {
      result = initPayload(a1, (uint64_t)v19, 0, v12, a9, a10, a11);
      if ((_DWORD)result)
      {
        memset(&v47, 0, sizeof(v47));
        v22 = *(_QWORD *)(a1 + 4480);
        if (!v22)
          goto LABEL_26;
        while (1)
        {
          v23 = fstatat(*(_DWORD *)(v22 + 44), *(const char **)(v22 + 72), &v47, 2048);
          v24 = g_prot_error_callback;
          if (v23 != -1 || g_prot_error_callback == 0)
            break;
          v26 = *(unsigned int *)(v22 + 40);
          v27 = __error();
          if (((*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t))(v24 + 16))(v24, v26, *v27, 8) & 1) == 0)goto LABEL_26;
        }
        if (v23 == -1)
        {
LABEL_26:
          v37 = *__error();
          v38 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
          {
            v41 = *__error();
            *(_DWORD *)buf = 136315650;
            v59 = "openPayload";
            v60 = 1024;
            v61 = 1202;
            v62 = 1024;
            v63 = v41;
            _os_log_error_impl(&dword_1B8270000, v38, OS_LOG_TYPE_ERROR, "%s:%d: stat err: %d", buf, 0x18u);
          }
          v39 = __error();
          result = 0;
          *v39 = v37;
        }
        else if (v47.st_size >= *(_QWORD *)(a1 + 24))
        {
          return 1;
        }
        else
        {
          bzero(buf, 0x400uLL);
          v34 = *__error();
          v35 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
          {
            st_size = v47.st_size;
            v44 = *(_QWORD *)(a1 + 24);
            v45 = fd_realpath(*(_DWORD **)(a1 + 4480), buf);
            *(_DWORD *)v48 = 136316162;
            v49 = "openPayload";
            v46 = "";
            v50 = 1024;
            if (v45)
              v46 = v45;
            v51 = 1207;
            v52 = 2048;
            v53 = st_size;
            v54 = 2048;
            v55 = v44;
            v56 = 2080;
            v57 = v46;
            _os_log_error_impl(&dword_1B8270000, v35, OS_LOG_TYPE_ERROR, "%s:%d: bad file size: %lldd, min size %lldd, %s\n", v48, 0x30u);
          }
          v36 = __error();
          result = 0;
          *v36 = v34;
        }
      }
    }
    else
    {
      snprintf(__str, 0x400uLL, "%s%s", a3, a5);
      v31 = fd_create_protected(a2, __str, v18, 3u);
      if (v31)
      {
        return initPayload(a1, (uint64_t)v20, (uint64_t)v31, v12, a9, a10, a11);
      }
      else
      {
        v32 = *__error();
        v33 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
        {
          v42 = *__error();
          *(_DWORD *)buf = 136315906;
          v59 = "openPayload";
          v60 = 1024;
          v61 = 1189;
          v62 = 1024;
          v63 = v42;
          v64 = 2080;
          v65 = __str;
          _os_log_error_impl(&dword_1B8270000, v33, OS_LOG_TYPE_ERROR, "%s:%d: open err: %d, %s", buf, 0x22u);
        }
        *__error() = v32;
        fd_release(v20);
        return 0;
      }
    }
  }
  else
  {
    v28 = *__error();
    v29 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
    {
      v40 = *__error();
      *(_DWORD *)buf = 136315906;
      v59 = "openPayload";
      v60 = 1024;
      v61 = 1177;
      v62 = 1024;
      v63 = v40;
      v64 = 2080;
      v65 = __str;
      _os_log_error_impl(&dword_1B8270000, v29, OS_LOG_TYPE_ERROR, "%s:%d: open err: %d, %s", buf, 0x22u);
    }
    v30 = __error();
    result = 0;
    *v30 = v28;
  }
  return result;
}

uint64_t indexRestoreFromBuffer(uint64_t a1, unsigned int **a2, int a3, unsigned int a4, unsigned int a5, _BYTE *a6, int a7)
{
  unsigned int *v10;
  uint64_t result;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int *v16;
  uint64_t v17;
  char v18;
  BOOL v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unsigned int *v24;
  char v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unsigned int *v33;
  unsigned int *v34;
  char v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unsigned int *v39;
  char v40;
  unsigned int v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unsigned int *v46;
  char v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  unsigned int *v55;
  unsigned int *v56;
  char v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  unsigned int *v61;
  char v62;
  unsigned int v63;
  uint64_t v64;
  _BOOL4 v65;
  size_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  char v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  char v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  unsigned int *v80;
  unsigned int *v81;
  char v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  unsigned int *v86;
  char v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  unsigned int *v91;
  char v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  unsigned int *v96;
  char v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  unsigned int *v101;
  char v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  char *v106;
  char v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  unsigned int *v111;
  char v112;
  int64_t v113;
  unsigned int *v114;
  int64_t v115;
  unsigned int v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  char v120;
  uint64_t v121;
  char v122;
  BOOL v123;
  int64_t v124;
  _DWORD *v125;
  unsigned int *v126;
  int v127;
  int v128;
  _BOOL4 v129;
  BOOL v130;
  BOOL v131;
  int v133;
  NSObject *v134;
  int *v135;
  int v136;
  unint64_t v137;
  unint64_t v138;
  int v139;
  char __s[32];
  int v141;
  uint64_t v142;

  v142 = *MEMORY[0x1E0C80C00];
  v10 = *a2;
  result = indexRestoreHeaderFromBuffer((_DWORD *)a1, a2, a3, a4, a5, a6);
  if (!(_DWORD)result)
    return result;
  v12 = *(*a2)++;
  *(_DWORD *)(a1 + 52) = restoreVInt32_2264((char **)a2);
  *(_DWORD *)(a1 + 60) = restoreVInt32_2264((char **)a2);
  *(_DWORD *)(a1 + 64) = restoreVInt32_2264((char **)a2);
  *(_QWORD *)(a1 + 14896) = restoreVInt32_2264((char **)a2);
  *(_QWORD *)(a1 + 14904) = restoreVInt32_2264((char **)a2);
  if (*(_DWORD *)(a1 + 4) >= 0x57u)
  {
    *(_QWORD *)(a1 + 14912) = restoreVInt32_2264((char **)a2);
    *(_QWORD *)(a1 + 14968) = restoreVInt32_2264((char **)a2);
  }
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = *a2;
  do
  {
    v17 = v14 + 1;
    v18 = *((_BYTE *)v16 + v14);
    v15 |= (unint64_t)(v18 & 0x7F) << v13;
    if ((v18 & 0x80) == 0)
      break;
    v14 = v17;
    v19 = v13 == 63;
    v13 += 7;
  }
  while (!v19);
  *a2 = (unsigned int *)((char *)v16 + v17);
  *(_QWORD *)(a1 + 72) = v15;
  *(_DWORD *)(a1 + 80) = 5170;
  atomic_store(restoreVInt32_2264((char **)a2), (unsigned int *)(a1 + 12));
  *(_DWORD *)(a1 + 44) = restoreVInt32_2264((char **)a2);
  *(_QWORD *)(a1 + 16) = restoreVInt32_2264((char **)a2);
  *(_DWORD *)(a1 + 88) = restoreVInt32_2264((char **)a2);
  *(_DWORD *)(a1 + 232) = restoreVInt32_2264((char **)a2);
  v20 = restoreVInt32_2264((char **)a2);
  v21 = 0;
  v22 = 0;
  v23 = 0;
  *(_DWORD *)(a1 + 236) = v20;
  v24 = *a2;
  do
  {
    v25 = *((_BYTE *)v24 + v22++);
    v23 |= (unint64_t)(v25 & 0x7F) << v21;
    if ((v25 & 0x80) == 0)
      break;
    v19 = v21 == 63;
    v21 += 7;
  }
  while (!v19);
  v26 = 0;
  v27 = 0;
  v28 = 0;
  *a2 = (unsigned int *)((char *)v24 + v22);
  *(_QWORD *)(a1 + 4920) = v23;
  do
  {
    v29 = v27 + 1;
    v28 |= (unint64_t)(*((_BYTE *)v24 + v27 + v22) & 0x7F) << v26;
    if ((*((_BYTE *)v24 + v27 + v22) & 0x80) == 0)
      break;
    ++v27;
    v19 = v26 == 63;
    v26 += 7;
  }
  while (!v19);
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v33 = (unsigned int *)((char *)v24 + v22 + v29);
  *a2 = v33;
  *(_QWORD *)(a1 + 4928) = v28;
  *(_QWORD *)(a1 + 4936) = v28;
  v34 = v33;
  do
  {
    ++v31;
    v35 = *(_BYTE *)v34;
    v34 = (unsigned int *)((char *)v34 + 1);
    v32 |= (unint64_t)(v35 & 0x7F) << v30;
    if ((v35 & 0x80) == 0)
      break;
    v19 = v30 == 63;
    v30 += 7;
  }
  while (!v19);
  v36 = 0;
  v37 = 0;
  v38 = 0;
  v39 = (unsigned int *)((char *)v33 + v31);
  *a2 = v39;
  *(_QWORD *)(a1 + 4944) = v32;
  do
  {
    ++v37;
    v40 = *(_BYTE *)v34;
    v34 = (unsigned int *)((char *)v34 + 1);
    v38 |= (unint64_t)(v40 & 0x7F) << v36;
    if ((v40 & 0x80) == 0)
      break;
    v19 = v36 == 63;
    v36 += 7;
  }
  while (!v19);
  *a2 = (unsigned int *)((char *)v39 + v37);
  *(_QWORD *)(a1 + 4952) = v38;
  *(_DWORD *)(a1 + 32) = restoreVInt32_2264((char **)a2);
  *(_BYTE *)(a1 + 36) = restoreVInt32_2264((char **)a2) != 0;
  *(_DWORD *)(a1 + 9368) = restoreVInt32_8478((char **)a2);
  v41 = restoreVInt32_8478((char **)a2);
  v42 = 0;
  v43 = 0;
  v44 = 0;
  *(_DWORD *)(a1 + 9372) = v41;
  v45 = *(unsigned int *)(a1 + 9368);
  *(_QWORD *)(a1 + 5192) = 8 * v45;
  *(_QWORD *)(a1 + 5184) = 8 * v41;
  v46 = *a2;
  do
  {
    v47 = *((_BYTE *)v46 + v43++);
    v44 |= (unint64_t)(v47 & 0x7F) << v42;
    if ((v47 & 0x80) == 0)
      break;
    v19 = v42 == 63;
    v42 += 7;
  }
  while (!v19);
  v48 = 0;
  v49 = 0;
  v50 = 0;
  *a2 = (unsigned int *)((char *)v46 + v43);
  *(_QWORD *)(a1 + 9632) = v44;
  do
  {
    v51 = v49 + 1;
    v50 |= (unint64_t)(*((_BYTE *)v46 + v49 + v43) & 0x7F) << v48;
    if ((*((_BYTE *)v46 + v49 + v43) & 0x80) == 0)
      break;
    ++v49;
    v19 = v48 == 63;
    v48 += 7;
  }
  while (!v19);
  v52 = 0;
  v53 = 0;
  v54 = 0;
  v55 = (unsigned int *)((char *)v46 + v43 + v51);
  *a2 = v55;
  *(_QWORD *)(a1 + 9640) = v50;
  *(_QWORD *)(a1 + 9648) = v50;
  v56 = v55;
  do
  {
    ++v53;
    v57 = *(_BYTE *)v56;
    v56 = (unsigned int *)((char *)v56 + 1);
    v54 |= (unint64_t)(v57 & 0x7F) << v52;
    if ((v57 & 0x80) == 0)
      break;
    v19 = v52 == 63;
    v52 += 7;
  }
  while (!v19);
  v139 = a7;
  v58 = 0;
  v59 = 0;
  v60 = 0;
  v61 = (unsigned int *)((char *)v55 + v53);
  *a2 = v61;
  *(_QWORD *)(a1 + 9656) = v54;
  do
  {
    ++v59;
    v62 = *(_BYTE *)v56;
    v56 = (unsigned int *)((char *)v56 + 1);
    v60 |= (unint64_t)(v62 & 0x7F) << v58;
    if ((v62 & 0x80) == 0)
      break;
    v19 = v58 == 63;
    v58 += 7;
  }
  while (!v19);
  *a2 = (unsigned int *)((char *)v61 + v59);
  *(_QWORD *)(a1 + 9664) = v60;
  restoreVInt32_2264((char **)a2);
  restoreVInt32_2264((char **)a2);
  *(_DWORD *)(a1 + 14080) = restoreVInt32_8478((char **)a2);
  v63 = restoreVInt32_8478((char **)a2);
  *(_DWORD *)(a1 + 14084) = v63;
  v64 = *(unsigned int *)(a1 + 14080);
  *(_QWORD *)(a1 + 9904) = 8 * v64;
  *(_QWORD *)(a1 + 9896) = 8 * v63;
  *(_DWORD *)(a1 + 112) = restoreVInt32_2638((char **)a2);
  *(_QWORD *)(a1 + 120) = restoreVInt32_2638((char **)a2);
  *(_QWORD *)(a1 + 128) = restoreVInt32_2638((char **)a2);
  *(_DWORD *)(a1 + 136) = restoreVInt32_2638((char **)a2);
  *(_DWORD *)(a1 + 140) = restoreVInt32_2638((char **)a2);
  *(_DWORD *)(a1 + 144) = restoreVInt32_2638((char **)a2);
  *(_DWORD *)(a1 + 148) = restoreVInt32_2638((char **)a2);
  *(_DWORD *)(a1 + 152) = restoreVInt32_2638((char **)a2);
  *(_DWORD *)(a1 + 156) = restoreVInt32_2638((char **)a2);
  *(_DWORD *)(a1 + 160) = restoreVInt32_2638((char **)a2);
  *(_DWORD *)(a1 + 164) = restoreVInt32_2638((char **)a2);
  *(_DWORD *)(a1 + 168) = restoreVInt32_2638((char **)a2);
  *(_DWORD *)(a1 + 172) = restoreVInt32_2638((char **)a2);
  *(_DWORD *)(a1 + 176) = restoreVInt32_2638((char **)a2);
  *(_DWORD *)(a1 + 180) = restoreVInt32_2638((char **)a2);
  *(_DWORD *)(a1 + 184) = restoreVInt32_2638((char **)a2);
  *(_DWORD *)(a1 + 188) = restoreVInt32_2638((char **)a2);
  *(_DWORD *)(a1 + 192) = restoreVInt32_2638((char **)a2);
  *(_DWORD *)(a1 + 196) = restoreVInt32_2638((char **)a2);
  v137 = *(_QWORD *)(a1 + 120);
  v138 = *(_QWORD *)(a1 + 128);
  v65 = storageHeaderRestore(a1 + 248, (char **)a2);
  memset(__s, 0, sizeof(__s));
  __strlcpy_chk();
  *a2 = (unsigned int *)((char *)*a2 + strlen((const char *)(a1 + 16224)) + 1);
  __strlcpy_chk();
  *a2 = (unsigned int *)((char *)*a2 + strlen((const char *)(a1 + 16192)) + 1);
  __strlcpy_chk();
  *a2 = (unsigned int *)((char *)*a2 + strlen(__s) + 1);
  __strlcpy_chk();
  v66 = strlen((const char *)(a1 + 16256));
  v67 = 0;
  v68 = 0;
  v69 = 0;
  v70 = (uint64_t)*a2 + v66 + 1;
  *a2 = (unsigned int *)v70;
  do
  {
    v71 = *(_BYTE *)(v70 + v68++);
    v69 |= (unint64_t)(v71 & 0x7F) << v67;
    if ((v71 & 0x80) == 0)
      break;
    v19 = v67 == 63;
    v67 += 7;
  }
  while (!v19);
  v72 = 0;
  v73 = 0;
  v74 = 0;
  *a2 = (unsigned int *)(v70 + v68);
  *(_QWORD *)(a1 + 16288) = v69;
  do
  {
    v75 = v73 + 1;
    v76 = *(_BYTE *)(v70 + v73 + v68);
    v74 |= (unint64_t)(v76 & 0x7F) << v72;
    if ((v76 & 0x80) == 0)
      break;
    v73 = v75;
    v19 = v72 == 63;
    v72 += 7;
  }
  while (!v19);
  v77 = 0;
  v78 = 0;
  v79 = 0;
  v80 = (unsigned int *)(v70 + v68 + v75);
  *a2 = v80;
  *(_QWORD *)(a1 + 16312) = v74;
  v81 = v80;
  do
  {
    ++v78;
    v82 = *(_BYTE *)v81;
    v81 = (unsigned int *)((char *)v81 + 1);
    v79 |= (unint64_t)(v82 & 0x7F) << v77;
    if ((v82 & 0x80) == 0)
      break;
    v19 = v77 == 63;
    v77 += 7;
  }
  while (!v19);
  v83 = 0;
  v84 = 0;
  v85 = 0;
  v86 = (unsigned int *)((char *)v80 + v78);
  *a2 = v86;
  *(_QWORD *)(a1 + 16320) = v79;
  do
  {
    ++v84;
    v87 = *(_BYTE *)v81;
    v81 = (unsigned int *)((char *)v81 + 1);
    v85 |= (unint64_t)(v87 & 0x7F) << v83;
    if ((v87 & 0x80) == 0)
      break;
    v19 = v83 == 63;
    v83 += 7;
  }
  while (!v19);
  v88 = 0;
  v89 = 0;
  v90 = 0;
  v91 = (unsigned int *)((char *)v86 + v84);
  *a2 = v91;
  *(_QWORD *)(a1 + 16328) = v85;
  do
  {
    ++v89;
    v92 = *(_BYTE *)v81;
    v81 = (unsigned int *)((char *)v81 + 1);
    v90 |= (unint64_t)(v92 & 0x7F) << v88;
    if ((v92 & 0x80) == 0)
      break;
    v19 = v88 == 63;
    v88 += 7;
  }
  while (!v19);
  v93 = 0;
  v94 = 0;
  v95 = 0;
  v96 = (unsigned int *)((char *)v91 + v89);
  *a2 = v96;
  *(_QWORD *)(a1 + 16336) = v90;
  do
  {
    ++v94;
    v97 = *(_BYTE *)v81;
    v81 = (unsigned int *)((char *)v81 + 1);
    v95 |= (unint64_t)(v97 & 0x7F) << v93;
    if ((v97 & 0x80) == 0)
      break;
    v19 = v93 == 63;
    v93 += 7;
  }
  while (!v19);
  v98 = 0;
  v99 = 0;
  v100 = 0;
  v101 = (unsigned int *)((char *)v96 + v94);
  *a2 = v101;
  *(_QWORD *)(a1 + 16344) = v95;
  do
  {
    ++v99;
    v102 = *(_BYTE *)v81;
    v81 = (unsigned int *)((char *)v81 + 1);
    v100 |= (unint64_t)(v102 & 0x7F) << v98;
    if ((v102 & 0x80) == 0)
      break;
    v19 = v98 == 63;
    v98 += 7;
  }
  while (!v19);
  v103 = 0;
  v104 = 0;
  v105 = 0;
  v106 = (char *)v101 + v99;
  *a2 = (unsigned int *)((char *)v101 + v99);
  *(_QWORD *)(a1 + 16352) = v100;
  do
  {
    ++v104;
    v107 = *(_BYTE *)v81;
    v81 = (unsigned int *)((char *)v81 + 1);
    v105 |= (unint64_t)(v107 & 0x7F) << v103;
    if ((v107 & 0x80) == 0)
      break;
    v19 = v103 == 63;
    v103 += 7;
  }
  while (!v19);
  v108 = 0;
  v109 = 0;
  v110 = 0;
  v111 = (unsigned int *)&v106[v104];
  *a2 = v111;
  *(_QWORD *)(a1 + 16360) = v105;
  do
  {
    ++v109;
    v112 = *(_BYTE *)v81;
    v81 = (unsigned int *)((char *)v81 + 1);
    v110 |= (unint64_t)(v112 & 0x7F) << v108;
    if ((v112 & 0x80) == 0)
      break;
    v19 = v108 == 63;
    v108 += 7;
  }
  while (!v19);
  *a2 = (unsigned int *)((char *)v111 + v109);
  *(_QWORD *)(a1 + 16368) = v110;
  *(_QWORD *)(a1 + 16304) = v74;
  *(_QWORD *)(a1 + 14944) = v79;
  *(_QWORD *)(a1 + 14952) = v85;
  *(_QWORD *)(a1 + 14992) = v90;
  *(_QWORD *)(a1 + 14920) = v95;
  *(_QWORD *)(a1 + 14928) = v100;
  *(_QWORD *)(a1 + 14984) = v105;
  if (v110)
    v69 = v110;
  *(_QWORD *)(a1 + 16296) = v69;
  *(_QWORD *)(a1 + 14976) = *(_QWORD *)(a1 + 16376);
  v113 = (v12 - 4);
  v114 = *a2;
  v115 = (char *)*a2 - (char *)v10;
  if (v115 < v113)
  {
    v116 = *(_DWORD *)(a1 + 4);
    if (v139)
    {
      if (v116 >= 0x72)
      {
        v117 = 0;
        v118 = 0;
        v119 = 0;
        do
        {
          v120 = *((_BYTE *)v114 + v118++);
          v119 |= (unint64_t)(v120 & 0x7F) << v117;
          if ((v120 & 0x80) == 0)
            break;
          v19 = v117 == 63;
          v117 += 7;
        }
        while (!v19);
LABEL_91:
        v114 = (unsigned int *)((char *)v114 + v118);
        *(_QWORD *)(a1 + 0x4000) = v119;
        v115 = (char *)v114 - (char *)v10;
      }
    }
    else if (v116 >= 0x65)
    {
      v121 = 0;
      v118 = 0;
      v119 = 0;
      do
      {
        v122 = *((_BYTE *)v114 + v118++);
        v119 |= (unint64_t)(v122 & 0x7F) << v121;
        if ((v122 & 0x80) == 0)
          break;
        v19 = v121 == 63;
        v121 += 7;
      }
      while (!v19);
      goto LABEL_91;
    }
  }
  v123 = v113 <= v115;
  v124 = v113 - v115;
  if (v123)
    v124 = 0;
  v125 = (unsigned int *)((char *)v114 + v124);
  v128 = *v125;
  v126 = v125 + 1;
  v127 = v128;
  *a2 = v126;
  if (v12 == v128)
  {
    v129 = (char *)v126 - (char *)v10 == v12 && v65;
    v130 = v129 && v138 >= v137;
    v131 = v130 && v63 >= v64;
    if (v131 && v41 >= v45)
      return 1;
  }
  v133 = *__error();
  v134 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v134, OS_LOG_TYPE_ERROR))
  {
    v136 = *(_DWORD *)a2 - (_DWORD)v10;
    *(_DWORD *)__s = 136316162;
    *(_QWORD *)&__s[4] = "indexRestoreFromBuffer";
    *(_WORD *)&__s[12] = 1024;
    *(_DWORD *)&__s[14] = 5285;
    *(_WORD *)&__s[18] = 1024;
    *(_DWORD *)&__s[20] = v12;
    *(_WORD *)&__s[24] = 1024;
    *(_DWORD *)&__s[26] = v127;
    *(_WORD *)&__s[30] = 1024;
    v141 = v136;
    _os_log_error_impl(&dword_1B8270000, v134, OS_LOG_TYPE_ERROR, "%s:%d: invalid file (%d, %d, %d)\n", (uint8_t *)__s, 0x24u);
  }
  v135 = __error();
  result = 0;
  *v135 = v133;
  *(_DWORD *)(a1 + 4) = 0;
  return result;
}

uint64_t indexRestoreHeaderFromBuffer(_DWORD *a1, unsigned int **a2, int a3, unsigned int a4, unsigned int a5, _BYTE *a6)
{
  int v12;
  unsigned int v13;
  unsigned int *v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t result;
  int v19;
  NSObject *v20;
  int *v21;
  int v22;
  int v23;
  const char *v24;
  __int16 v25;
  int v26;
  __int16 v27;
  int v28;
  __int16 v29;
  int v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v12 = *(*a2)++;
  a1[1] = v12;
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
  {
    v23 = 67109120;
    LODWORD(v24) = v12;
    _os_log_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "Restored header version %d", (uint8_t *)&v23, 8u);
  }
  if (a3 < (int)a4 || a3 > (int)a5 || v12 == a3)
  {
    if (v12 == a3)
    {
LABEL_8:
      v14 = *a2;
      v15 = *(*a2)++;
      atomic_store(v15, a1 + 6);
      v16 = v14[1];
      *a2 = v14 + 2;
      atomic_store(v16, a1 + 7);
      v17 = v14[2];
      *a2 = v14 + 3;
      a1[10] = v17;
      return 1;
    }
  }
  else
  {
    v13 = a1[1];
    if (v13 >= a4 && v13 <= a5)
      goto LABEL_8;
  }
  if (a6)
    *a6 = 1;
  v19 = *__error();
  v20 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
  {
    v22 = a1[1];
    v23 = 136315906;
    v24 = "indexRestoreHeaderFromBuffer";
    v25 = 1024;
    v26 = 5143;
    v27 = 1024;
    v28 = v22;
    v29 = 1024;
    v30 = a3;
    _os_log_error_impl(&dword_1B8270000, v20, OS_LOG_TYPE_ERROR, "%s:%d: Invalid version (%d) expected (%d)", (uint8_t *)&v23, 0x1Eu);
  }
  v21 = __error();
  result = 0;
  *v21 = v19;
  return result;
}

uint64_t restoreVInt32_2264(char **a1)
{
  char *v1;
  uint64_t v2;
  uint64_t v3;
  int v4;
  int v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  char *v12;
  char *v13;
  const char *v14;

  v1 = *a1;
  v2 = **a1;
  if (**a1 < 0)
  {
    v4 = v1[1];
    if (v1[1] < 0)
    {
      v5 = v1[2];
      if (v1[2] < 0)
      {
        v7 = v1[3];
        if (v1[3] < 0)
        {
          v9 = v1[4];
          if (v9 < 0)
          {
            v12 = __si_assert_copy_extra_2151(0, -1);
            v13 = v12;
            v14 = "";
            if (v12)
              v14 = v12;
            __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t", "VIntUtils.h", 341, "(b4 & 0x80) == 0", v14);
            free(v13);
            if (__valid_fs(-1))
            {
              MEMORY[0xBAD] = -559038737;
              abort();
            }
            MEMORY[0xC00] = -559038737;
            abort();
          }
          v10 = ((v7 & 0x7F) << 21) | (v9 << 28) | ((v5 & 0x7F) << 14) | ((v4 & 0x7F) << 7) | (v2 & 0x7F);
          v3 = 5;
          v2 = v10;
        }
        else
        {
          v8 = ((v5 & 0x7F) << 14) | (v7 << 21) | ((v4 & 0x7F) << 7) | (v2 & 0x7F);
          v3 = 4;
          v2 = v8;
        }
      }
      else
      {
        v6 = ((v4 & 0x7F) << 7) | (v5 << 14) | (v2 & 0x7F);
        v3 = 3;
        v2 = v6;
      }
    }
    else
    {
      v2 = v2 & 0x7F | (v4 << 7);
      v3 = 2;
    }
  }
  else
  {
    v3 = 1;
  }
  *a1 = &v1[v3];
  return v2;
}

char *openIndex(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, _DWORD *a9, int a10, uint64_t a11, uint64_t a12, const void *a13)
{
  int v13;
  int *v14;
  int *v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  unsigned int v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  const char *v25;
  const char *v26;
  unsigned int v27;
  int v28;
  const char *v29;
  int v30;
  NSObject *v31;
  os_log_type_t v32;
  char *result;
  char *v34;
  uint64_t v35;
  BOOL *v36;
  unsigned int *v37;
  unsigned int v38;
  unsigned int v39;
  int v40;
  NSObject *v41;
  BOOL v42;
  int v43;
  _QWORD *v44;
  _QWORD *v45;
  int v46;
  int v47;
  char *v48;
  char *v49;
  stat *v50;
  int v51;
  uint64_t v52;
  char st_dev;
  uint64_t v54;
  unint64_t v55;
  int v56;
  int v57;
  int v58;
  _DWORD *v59;
  uint64_t v60;
  int v61;
  int v62;
  NSObject *v63;
  int v64;
  unsigned int v65;
  char v66;
  unsigned int v67;
  unsigned int v68;
  uint64_t v69;
  unint64_t v70;
  unint64_t v71;
  unint64_t v72;
  unint64_t v73;
  size_t v74;
  malloc_type_id_t v75;
  unsigned int v76;
  unsigned int v77;
  uint64_t v78;
  unint64_t v79;
  unint64_t v80;
  unint64_t v81;
  unint64_t v82;
  int v83;
  int v84;
  int v85;
  uint64_t v86;
  uint64_t v87;
  off_t v88;
  off_t v89;
  unsigned int v90;
  uint64_t v91;
  int v92;
  _QWORD *v93;
  uint64_t v94;
  off_t v95;
  _QWORD *v96;
  uint64_t v97;
  off_t v98;
  _QWORD *v99;
  unsigned int v100;
  unsigned int v101;
  unsigned int v102;
  int v103;
  _QWORD *v104;
  _QWORD *v105;
  unsigned int v106;
  unsigned int v107;
  unsigned int v108;
  int v109;
  NSObject *v110;
  int v111;
  NSObject *v112;
  char v113;
  off_t st_size;
  int32_t v115;
  unint64_t v116;
  unsigned int v117;
  unsigned int v118;
  uint64_t v119;
  uint64_t v120;
  int v121;
  void (*v122)(_QWORD);
  _DWORD *v123;
  int v124;
  NSObject *v125;
  uint64_t v126;
  int v127;
  NSObject *v128;
  os_log_type_t v129;
  uint64_t v130;
  unsigned int v131;
  uint64_t v132;
  void (*v133)(_QWORD);
  uint64_t v134;
  int v135;
  NSObject *v136;
  uint64_t v137;
  int v138;
  _BOOL4 v139;
  int v140;
  BOOL v141;
  IVFVectorIndex_s *v142;
  char v143;
  _QWORD *v144;
  uint64_t v145;
  void *v146;
  int32_t v147;
  unint64_t v148;
  unsigned int v149;
  unsigned int v150;
  uint64_t v151;
  uint64_t v152;
  int v153;
  void (*v154)(_QWORD);
  _DWORD *v155;
  int v156;
  NSObject *v157;
  uint64_t v158;
  unsigned int v159;
  uint64_t v160;
  void (*v161)(_QWORD);
  unint64_t v162;
  int32_t v163;
  unint64_t v164;
  int v165;
  int v166;
  uint64_t v167;
  uint64_t v168;
  int v169;
  void (*v170)(_QWORD);
  int v171;
  NSObject *v172;
  __darwin_ino64_t v173;
  unint64_t v174;
  unint64_t v175;
  unint64_t v176;
  uint64_t v177;
  NSObject *v178;
  NSObject *v179;
  os_log_type_t v180;
  int v181;
  uint64_t v182;
  unsigned int v183;
  uint64_t v184;
  void (*v185)(_QWORD);
  uint64_t v186;
  __int128 v187;
  __int128 v188;
  __int128 v189;
  __int128 v190;
  __int128 v191;
  char *v192;
  char *v193;
  int v194;
  int v195;
  uint64_t v196;
  int v197;
  uint64_t v198;
  int v199;
  NSObject *v200;
  gid_t v201;
  const char *v202;
  uint8_t *v203;
  int v204;
  char *v205;
  char *v206;
  const char *v207;
  int v208;
  uint64_t v209;
  int v210;
  NSObject *v211;
  int v212;
  NSObject *v213;
  int vint32_2297;
  int v215;
  _BOOL4 v216;
  CFIndex v217;
  char v218;
  unsigned int v219;
  unsigned int v220;
  uint64_t v221;
  UInt8 *v222;
  UInt8 *v223;
  CFBitVectorRef v224;
  const __CFBitVector *v225;
  CFIndex i;
  CFBit v227;
  CFBitVectorRef v228;
  const __CFBitVector *v229;
  CFIndex j;
  CFBit v231;
  CFBitVectorRef v232;
  const __CFBitVector *v233;
  CFIndex k;
  CFBit v235;
  CFBitVectorRef v236;
  const __CFBitVector *v237;
  CFIndex m;
  CFBit v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  unsigned int v243;
  uint64_t updated;
  const char *v245;
  uint64_t v246;
  int v247;
  NSObject *v248;
  char *v249;
  const char *v250;
  int v251;
  NSObject *v252;
  int v253;
  NSObject *v254;
  int v255;
  NSObject *v256;
  int v257;
  NSObject *v258;
  int v259;
  NSObject *v260;
  const char *v261;
  const char *v262;
  unint64_t v263;
  uint64_t CompactTermOffset;
  int v265;
  int32_t v266;
  unsigned int v267;
  CFIndex v268;
  CFIndex numBits;
  char v270;
  int v271;
  char *v272;
  int v273;
  int v274;
  int v275;
  unsigned int v276;
  BOOL *v277;
  unsigned int *v278;
  char *v279;
  int v280;
  uint64_t v281;
  int *v282;
  uint64_t v283;
  char v284;
  _QWORD v285[2];
  uint64_t v286;
  __int128 v287;
  unsigned int *v288;
  __int128 v289;
  __int128 v290;
  __int128 v291;
  __int128 v292;
  _BYTE v293[24];
  __int16 v294;
  char *v295;
  stat buf[28];
  _BYTE v297[12];
  __int16 v298;
  int v299;
  statfs v300;
  _DWORD v301[1024];
  char v302[1024];
  uint64_t v303;

  v13 = MEMORY[0x1E0C80A78](a1);
  v15 = v14;
  v17 = v16;
  v19 = v18;
  v280 = v20;
  v22 = v21;
  v24 = v23;
  v26 = v25;
  v273 = v13;
  v303 = *MEMORY[0x1E0C80C00];
  bzero(v302, 0x400uLL);
  bzero(v301, 0x1000uLL);
  *v15 = -1;
  v276 = v19;
  v274 = v19 & 0x100;
  if ((v19 & 0x100) != 0)
    v27 = 111;
  else
    v27 = 95;
  if ((v19 & 0x100) != 0)
    v28 = 114;
  else
    v28 = 102;
  v29 = "";
  v291 = 0u;
  v292 = 0u;
  if (v26)
    v29 = v26;
  v272 = (char *)v29;
  v289 = 0uLL;
  v290 = 0uLL;
  LODWORD(v289) = -1;
  v30 = *__error();
  v31 = _SILogForLogForCategory(10);
  v32 = 2 * (dword_1EF19FCB4 < 4);
  if (os_log_type_enabled(v31, v32))
  {
    buf[0].st_dev = 136315138;
    *(_QWORD *)&buf[0].st_mode = v272;
    _os_log_impl(&dword_1B8270000, v31, v32, "open index at %s", (uint8_t *)buf, 0xCu);
  }
  *__error() = v30;
  result = (char *)malloc_type_calloc(1uLL, 0x4040uLL, 0x10F0040CEEE6884uLL);
  if (!result)
  {
    *v15 = -1;
    return result;
  }
  v281 = v17;
  v267 = v28;
  v34 = result;
  v35 = (uint64_t)result;
  v36 = (BOOL *)(result + 15162);
  initIndex((uint64_t)result, a13);
  v279 = v34 + 15168;
  __strlcpy_chk();
  *(_QWORD *)(v35 + 72) = v24;
  *(_DWORD *)(v35 + 80) = 1792;
  *(_DWORD *)(v35 + 56) = v273;
  v277 = v36;
  v278 = (unsigned int *)v34;
  *v36 = (v276 & 0x10) != 0;
  *(_BYTE *)(v35 + 37) = BYTE1(v274);
  v37 = (unsigned int *)(v34 + 28);
  *(_BYTE *)(v35 + 38) = (v276 & 0x400) != 0;
  do
    v38 = __ldaxr(v37);
  while (__stlxr(v38 & 0xFFFFF7FF, v37));
  do
    v39 = __ldaxr(v37);
  while (__stlxr(v39 | 0x800, v37));
  v36[1279] = 0;
  bzero(&v300, 0x878uLL);
  if (fstatfs(v273, &v300))
  {
    v40 = *__error();
    v41 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
    {
      buf[0].st_dev = 136315650;
      *(_QWORD *)&buf[0].st_mode = "openIndex";
      WORD2(buf[0].st_ino) = 1024;
      *(_DWORD *)((char *)&buf[0].st_ino + 6) = 1809;
      HIWORD(buf[0].st_uid) = 2080;
      *(_QWORD *)&buf[0].st_gid = v22;
      _os_log_error_impl(&dword_1B8270000, v41, OS_LOG_TYPE_ERROR, "%s:%d: Couldn't statfs parent directory: %s", (uint8_t *)buf, 0x1Cu);
    }
    *__error() = v40;
  }
  else
  {
    v42 = *(_DWORD *)v300.f_fstypename == 1634105445 && *(unsigned __int16 *)&v300.f_fstypename[4] == 116;
    if (v42)
      v36[1279] = 1;
  }
  snprintf(v302, 0x400uLL, "%s%s", v272, "indexHead");
  if (v280)
    v43 = 0;
  else
    v43 = 2;
  v44 = open_index_file(v273, v302, v43, 4096, 4096, 0, 0, 0, v15);
  *(_QWORD *)(v35 + 14440) = v44;
  if (!v44)
  {
LABEL_315:
    if (*v15)
      goto LABEL_316;
    return (char *)v35;
  }
  v282 = v15;
  if ((v280 & 1) == 0)
  {
    v45 = v44;
    *(_QWORD *)&buf[0].st_dev = 0;
    v46 = _fd_acquire_fd((uint64_t)v44, buf);
    if (v46 != -1)
    {
      v47 = v46;
      *((_WORD *)v45 + 28) |= 1u;
      fcntl(v46, 48, 1);
      fcntl(v47, 76, v45[7] & 1);
      _fd_release_fd(v45, v47, 0, *(uint64_t *)&buf[0].st_dev);
    }
  }
  snprintf(v302, 0x400uLL, "%s%s", v272, "indexId");
  *(_DWORD *)v293 = -1;
  v48 = (char *)open_index_file(v273, v302, 0, 0, 0, 0, 0, 0, (int *)v293);
  if (v48)
  {
    v49 = v48;
    memset(buf, 0, 32);
    fd_pread(v48, buf, 0x20uLL, 0);
    v50 = buf;
    v51 = 0;
    v52 = 0;
    do
    {
      st_dev = v50->st_dev;
      v50 = (stat *)((char *)v50 + 1);
      v54 = v52;
      v55 = (unint64_t)(st_dev & 0x7F) << v52;
      v56 = v55 | v51;
      if ((st_dev & 0x80) == 0)
        break;
      v52 += 7;
      v51 |= v55;
    }
    while (v54 != 63);
    v57 = v56;
    fd_release(v49);
    v58 = v57;
  }
  else
  {
    v58 = 0;
  }
  *(_DWORD *)(v35 + 48) = v58;
  if (a12 && !v58 && (v280 & 1) == 0)
    *(_DWORD *)(v35 + 48) = (*(uint64_t (**)(uint64_t, _QWORD))(a12 + 16))(a12, 0);
  v59 = *(_DWORD **)(v35 + 14440);
  if (!v59)
    goto LABEL_54;
  v60 = fd_pread(v59, v301, 0x1000uLL, 0);
  if (v60 == 4096)
    goto LABEL_47;
  if (v60 == -1)
  {
    v61 = *__error();
    if (!v61)
    {
LABEL_47:
      v288 = v301;
      if (!indexRestoreFromBuffer(v35, &v288, a10, v27, v267, 0, v274 != 0))
        goto LABEL_314;
      v62 = *__error();
      v63 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
      {
        v64 = *(_DWORD *)(v35 + 48);
        buf[0].st_dev = 67109378;
        *(_DWORD *)&buf[0].st_mode = v64;
        LOWORD(buf[0].st_ino) = 2080;
        *(__darwin_ino64_t *)((char *)&buf[0].st_ino + 2) = (__darwin_ino64_t)v302;
        _os_log_impl(&dword_1B8270000, v63, OS_LOG_TYPE_DEFAULT, "open indexid %u at %s", (uint8_t *)buf, 0x12u);
      }
      *__error() = v62;
      if ((v276 & 0x400) == 0)
      {
        v65 = *(_DWORD *)(v35 + 4);
        if (v274)
        {
          if (v65 <= 0x70)
            goto LABEL_60;
        }
        else if (v65 != 98 && v65 < 0x64)
        {
          goto LABEL_60;
        }
      }
      *(_BYTE *)(v35 + 38) = 1;
LABEL_60:
      if (v280)
        v277[1] = 1;
      v66 = atomic_load((unsigned int *)v34 + 7);
      v67 = atomic_load((unsigned int *)v34 + 7);
      v68 = atomic_load((unsigned int *)v34 + 6);
      if (v68 == -1073623027)
      {
        v69 = *(unsigned int *)(v35 + 64);
        v70 = v69 + 3;
        v71 = (v69 + 4) / 5uLL;
        v72 = v70 >> 2;
        if (*(_BYTE *)(v35 + 37))
          v73 = v72;
        else
          v73 = v71;
        v74 = (8 * *MEMORY[0x1E0C85AD8] - 1 + v73) / (8 * *MEMORY[0x1E0C85AD8]);
        v75 = 2905813332;
LABEL_74:
        *(_QWORD *)(v35 + 14400) = malloc_type_calloc(1uLL, v74, v75);
        v83 = 1;
LABEL_75:
        v84 = 0;
LABEL_76:
        v275 = v83;
        v271 = v84;
        v85 = v43;
        snprintf(v302, 0x400uLL, "%s%s", v272, "indexIds");
        v86 = *(unsigned int *)(v35 + 60);
        v87 = *(unsigned int *)(v35 + 64);
        if (v86 >= 2)
          v88 = 8 * v86;
        else
          v88 = 0;
        if (v86 <= v87)
        {
          v89 = 8 * v87;
        }
        else
        {
          *(_DWORD *)(v35 + 64) = v86;
          v89 = 8 * v86;
        }
        v270 = v66;
        v90 = v66 & 2;
        if (v280)
          v91 = 1;
        else
          v91 = 3;
        v92 = v280 | (v90 >> 1);
        v93 = open_index_file(v273, v302, v43, v89, v88, v92 ^ 1u, (uint64_t *)v34 + 1796, v91, v282);
        *(_QWORD *)(v35 + 14408) = v93;
        if (!v93)
          goto LABEL_314;
        snprintf(v302, 0x400uLL, "%s%s", v272, "indexBigDates");
        v94 = *(unsigned int *)(v35 + 60);
        if (v94 >= 2)
          v95 = 4 * v94;
        else
          v95 = 0;
        v96 = open_index_file(v273, v302, v43, 4 * *(unsigned int *)(v35 + 64), v95, v92 ^ 1u, (uint64_t *)v34 + 1797, v91, v282);
        *(_QWORD *)(v35 + 14416) = v96;
        if (!v96)
          *(_QWORD *)(v35 + 14416) = open_index_file(v273, v302, 1538, 4 * *(unsigned int *)(v35 + 64), 0, 1, (uint64_t *)v34 + 1797, 3, v282);
        if (v274)
        {
          snprintf(v302, 0x400uLL, "%s%s", v272, "indexScores");
          v97 = *(unsigned int *)(v35 + 60);
          v98 = v97 >= 2 ? 8 * v97 : 0;
          v99 = open_index_file(v273, v302, v43, 8 * *(unsigned int *)(v35 + 64), v98, v280 ^ 1u, (uint64_t *)v34 + 1798, v91, v282);
          *(_QWORD *)(v35 + 14424) = v99;
          if (!v99)
            *(_QWORD *)(v35 + 14424) = open_index_file(v273, v302, 1538, 8 * *(unsigned int *)(v35 + 64), 0, 1, (uint64_t *)v34 + 1798, 3, v282);
        }
        snprintf(v302, 0x400uLL, "%s%s", v272, "indexGroups");
        v100 = *(_DWORD *)(v35 + 64);
        if (*(_BYTE *)(v35 + 37))
        {
          v101 = *(_DWORD *)(v35 + 60);
        }
        else
        {
          v100 = (4 * v100 + 4) / 5;
          v101 = (4 * *(_DWORD *)(v35 + 60) + 4) / 5u;
        }
        v103 = v273;
        v104 = open_index_file(v273, v302, v43, v100, v101, v92 ^ 1u, (uint64_t *)v34 + 1799, v91, v282);
        *(_QWORD *)(v35 + 14432) = v104;
        if (!v104
          || !openPayload((uint64_t)(v34 + 4920), *(_DWORD *)(v35 + 56), v272, "indexPostings", "indexTermIds", v302, v92, (v67 & 4) != 0, 1u, *(_DWORD *)(v35 + 4), *(void **)(v35 + 4912))|| !openPayload((uint64_t)(v34 + 9632), *(_DWORD *)(v35 + 56), v272, "indexPositions", "indexPositionTable", v302, v92,
                              (v67 & 4) != 0,
                              1u,
                              *(_DWORD *)(v35 + 4),
                              *(void **)(v35 + 4912))
          || !bt_openTrie((uint64_t)(v34 + 88), *(_DWORD *)(v35 + 56), v272, (v67 >> 2) & 1, v92, 0, *(_DWORD *)(v35 + 4), *(void **)(v35 + 4912)))
        {
          goto LABEL_314;
        }
        if ((v276 & 0x40) != 0)
        {
          v105 = openForwardStore(*(_DWORD *)(v35 + 56), v272, (v276 >> 14) & 1, v280, 0, *(void **)(v35 + 4912));
          *(_QWORD *)(v35 + 4904) = v105;
          if (v105)
          {
            do
              v106 = __ldaxr(v37);
            while (__stlxr(v106 | 0x80, v37));
          }
          else
          {
            v109 = *__error();
            v110 = _SILogForLogForCategory(10);
            if (os_log_type_enabled(v110, OS_LOG_TYPE_ERROR))
            {
              buf[0].st_dev = 136315394;
              *(_QWORD *)&buf[0].st_mode = "openIndex";
              WORD2(buf[0].st_ino) = 1024;
              *(_DWORD *)((char *)&buf[0].st_ino + 6) = 1934;
              _os_log_error_impl(&dword_1B8270000, v110, OS_LOG_TYPE_ERROR, "%s:%d: Failed to open path index", (uint8_t *)buf, 0x12u);
            }
            *__error() = v109;
            if (!v274)
              goto LABEL_314;
            *(_QWORD *)(v35 + 4904) = 0;
            v111 = *__error();
            v112 = _SILogForLogForCategory(10);
            if (os_log_type_enabled(v112, OS_LOG_TYPE_ERROR))
            {
              buf[0].st_dev = 136315394;
              *(_QWORD *)&buf[0].st_mode = "openIndex";
              WORD2(buf[0].st_ino) = 1024;
              *(_DWORD *)((char *)&buf[0].st_ino + 6) = 1937;
              _os_log_error_impl(&dword_1B8270000, v112, OS_LOG_TYPE_ERROR, "%s:%d: Ignoring failed dirstore open for corespotlight", (uint8_t *)buf, 0x12u);
            }
            *__error() = v111;
          }
        }
        if (*(_QWORD *)(v35 + 4904))
        {
          v113 = atomic_load(v37);
          if ((v113 & 0x24) == 4)
          {
            if (*(_DWORD *)(v35 + 44))
            {
              memset(buf, 0, 144);
              if (fd_stat(*(_QWORD *)(v35 + 9400), buf) != -1)
              {
                st_size = buf[0].st_size;
                if (buf[0].st_size >= 0x100000001uLL)
                {
                  v284 = 0;
                  *(_BYTE *)(v35 + 8) = 1;
                  v115 = OSAtomicIncrement32((int32_t *)exceptionSequenceNum);
                  *(_DWORD *)v297 = 0;
                  v116 = setThreadIdAndInfo(-1, (__int128 *)sIndexExceptionCallbacks, v35, 0, v115);
                  LODWORD(v285[0]) = HIDWORD(v116);
                  *(_DWORD *)v297 = v116;
                  *((_QWORD *)&v287 + 1) = __PAIR64__(v117, v118);
                  v119 = *(_QWORD *)&threadData[18 * v116 + 2];
                  v120 = v119 + 320 * HIDWORD(v116);
                  *(_BYTE *)(v120 + 216) = 0;
                  v121 = *(_DWORD *)(v120 + 312);
                  v122 = *(void (**)(_QWORD))(v120 + 224);
                  if (v122)
                    v122(*(_QWORD *)(v119 + 320 * HIDWORD(v116) + 288));
                  *(_QWORD *)&v287 = __PAIR64__(*(unsigned int *)v297, v285[0]);
                  v286 = *((_QWORD *)&v287 + 1);
                  if (_setjmp((int *)v120))
                  {
                    v123 = (_DWORD *)(v120 + 312);
                    v124 = *__error();
                    v125 = _SILogForLogForCategory(0);
                    if (os_log_type_enabled(v125, OS_LOG_TYPE_ERROR))
                    {
                      *(_DWORD *)v293 = 136315394;
                      *(_QWORD *)&v293[4] = "openIndex";
                      *(_WORD *)&v293[12] = 1024;
                      *(_DWORD *)&v293[14] = 1959;
                      _os_log_error_impl(&dword_1B8270000, v125, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", v293, 0x12u);
                    }
                    *__error() = v124;
                    *v123 = v121;
                    CIOnThreadCleanUpReset(v286);
                    dropThreadId(DWORD1(v287), 1, v115);
                    CICleanUpReset(DWORD1(v287), HIDWORD(v286));
                    v126 = 0;
                  }
                  else
                  {
                    CompactTermOffset = trieLastCompactTermOffset((uint64_t)(v278 + 22));
                    v127 = *__error();
                    v128 = _SILogForLogForCategory(10);
                    v129 = 2 * (dword_1EF19FCB4 < 4);
                    if (os_log_type_enabled(v128, v129))
                    {
                      *(_DWORD *)v293 = 134217984;
                      *(_QWORD *)&v293[4] = CompactTermOffset;
                      _os_log_impl(&dword_1B8270000, v128, v129, "last term offset: %llu", v293, 0xCu);
                    }
                    *__error() = v127;
                    v284 = 1;
                    v130 = *(_QWORD *)&threadData[18 * DWORD1(v287) + 2];
                    v131 = v287;
                    v132 = v130 + 320 * v287;
                    *(_DWORD *)(v132 + 312) = v121;
                    v133 = *(void (**)(_QWORD))(v132 + 232);
                    if (v133)
                      v133(*(_QWORD *)(v130 + 320 * v131 + 288));
                    dropThreadId(DWORD1(v287), 0, v115);
                    v126 = CompactTermOffset;
                  }
                  *(_BYTE *)(v35 + 8) = 0;
                  if (!v284)
                    goto LABEL_218;
                  v134 = *(_QWORD *)(v35 + 4904);
                  *(_QWORD *)(v134 + 4432) = v126;
                  *(_QWORD *)(v134 + 4440) = st_size;
                  v103 = v273;
                }
              }
            }
          }
        }
        if (_os_feature_enabled_impl())
        {
          v135 = *__error();
          v136 = _SILogForLogForCategory(10);
          v137 = v281;
          if (os_log_type_enabled(v136, OS_LOG_TYPE_DEFAULT))
          {
            v138 = *(_DWORD *)(v35 + 48);
            buf[0].st_dev = 67109120;
            *(_DWORD *)&buf[0].st_mode = v138;
            _os_log_impl(&dword_1B8270000, v136, OS_LOG_TYPE_DEFAULT, "open vector index for indexid %d", (uint8_t *)buf, 8u);
          }
          *__error() = v135;
          if (*(_DWORD *)(v35 + 48))
          {
            if ((v280 & 1) != 0)
            {
              v139 = 1;
            }
            else
            {
              v143 = atomic_load(v278 + 7);
              v139 = (v143 & 0x26) != 0;
            }
            *(_QWORD *)(v35 + 4896) = openVectorIndex(*(_DWORD *)(v35 + 56), v272, v139, a11, *(_DWORD *)(v35 + 48));
            *(_QWORD *)(v35 + 14344) = a11;
          }
        }
        else
        {
          bzero(buf, 0x400uLL);
          v140 = fcntl(v103, 50, buf);
          if (LOBYTE(buf[0].st_dev))
            v141 = v140 < 0;
          else
            v141 = 1;
          if (v141)
            v142 = 0;
          else
            v142 = (IVFVectorIndex_s *)buf;
          IVFVectorIndex_s::unlink(v142, v272, 0);
          v137 = v281;
        }
        if ((v276 & 0x1100) == 0x100)
        {
          snprintf(v302, 0x400uLL, "%s%s", v272, "topK.v2.mdplistc");
          v144 = fd_create_protected(v103, v302, 0, 0);
          *(_QWORD *)(v35 + 14448) = v144;
          if (v144)
          {
            memset(buf, 0, 144);
            if (fd_stat((uint64_t)v144, buf) != -1)
            {
              v145 = fd_mmap(*(_QWORD *)(v35 + 14448));
              if (v145 != -1)
              {
                v146 = (void *)v145;
                *(_QWORD *)v293 = v145;
                *(_QWORD *)&v293[8] = buf[0].st_size;
                *(_QWORD *)&v293[16] = 0;
                v285[0] = 1;
                v285[1] = v293;
                v147 = OSAtomicIncrement32((int32_t *)exceptionSequenceNum);
                v287 = 0uLL;
                v148 = setThreadIdAndInfo(-1, (__int128 *)sMappingExceptionCallbacks, (uint64_t)v285, 0, v147);
                *((_QWORD *)&v287 + 1) = __PAIR64__(v148, HIDWORD(v148));
                *(_QWORD *)&v287 = __PAIR64__(v149, v150);
                v151 = *(_QWORD *)&threadData[18 * v148 + 2];
                v152 = v151 + 320 * HIDWORD(v148);
                *(_BYTE *)(v152 + 216) = 0;
                v153 = *(_DWORD *)(v152 + 312);
                v154 = *(void (**)(_QWORD))(v152 + 224);
                if (v154)
                  v154(*(_QWORD *)(v151 + 320 * HIDWORD(v148) + 288));
                v286 = *((_QWORD *)&v287 + 1);
                v283 = v287;
                if (_setjmp((int *)v152))
                {
                  v155 = (_DWORD *)(v152 + 312);
                  v156 = *__error();
                  v157 = _SILogForLogForCategory(0);
                  if (os_log_type_enabled(v157, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)v297 = 136315394;
                    *(_QWORD *)&v297[4] = "openIndex";
                    v298 = 1024;
                    v299 = 2006;
                    _os_log_error_impl(&dword_1B8270000, v157, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", v297, 0x12u);
                  }
                  *__error() = v156;
                  *v155 = v153;
                  CIOnThreadCleanUpReset(v283);
                  dropThreadId(HIDWORD(v286), 1, v147);
                  CICleanUpReset(HIDWORD(v286), HIDWORD(v283));
                }
                else
                {
                  *(_QWORD *)(v35 + 14456) = _MDPlistContainerCreateWithBytes();
                  v158 = *(_QWORD *)&threadData[18 * HIDWORD(v286) + 2];
                  v159 = v286;
                  v160 = v158 + 320 * v286;
                  *(_DWORD *)(v160 + 312) = v153;
                  v161 = *(void (**)(_QWORD))(v160 + 232);
                  if (v161)
                    v161(*(_QWORD *)(v158 + 320 * v159 + 288));
                  dropThreadId(HIDWORD(v286), 0, v147);
                }
                v137 = v281;
                v103 = v273;
                if (!*(_QWORD *)(v35 + 14456))
                  munmap(v146, buf[0].st_size);
              }
            }
          }
        }
        v162 = *(_QWORD *)(v35 + 16304);
        if (!v162)
        {
LABEL_196:
          if ((v270 & 2) != 0)
            goto LABEL_197;
          snprintf(v302, 0x400uLL, "%s%s", v272, "indexUpdates");
          if ((v276 & 0x1000) != 0)
          {
            if (!v271)
              goto LABEL_223;
            v205 = __si_assert_copy_extra_2151(0, -1);
            v206 = v205;
            v207 = "";
            if (v205)
              v207 = v205;
            v261 = "!wasFastFlush";
            v262 = v207;
            v208 = 2056;
            goto LABEL_237;
          }
          v192 = (char *)fd_create_protected(v103, v302, v85, 0);
          if (!v192)
            goto LABEL_314;
          v193 = v192;
          v194 = store_stream_init((uint64_t)&v289, v192, 0);
          if (dword_1EF19FCB4 >= 5)
          {
            v210 = *__error();
            v211 = _SILogForLogForCategory(10);
            if (os_log_type_enabled(v211, OS_LOG_TYPE_DEFAULT))
            {
              buf[0].st_dev = 134217984;
              *(_QWORD *)&buf[0].st_mode = *((_QWORD *)&v290 + 1) - v291 + *((_QWORD *)&v291 + 1);
              _os_log_impl(&dword_1B8270000, v211, OS_LOG_TYPE_DEFAULT, "Post init at %lld", (uint8_t *)buf, 0xCu);
            }
            *__error() = v210;
          }
          if ((_DWORD)v290)
            v195 = 0;
          else
            v195 = v194;
          v137 = v281;
          if (v195 != 1)
            goto LABEL_313;
          v196 = v291;
          v197 = v271;
          if (!(_QWORD)v291)
            v197 = 0;
          if (v197 != 1)
            goto LABEL_313;
          if (dword_1EF19FCB4 >= 5)
          {
            v212 = *__error();
            v213 = _SILogForLogForCategory(10);
            if (os_log_type_enabled(v213, OS_LOG_TYPE_DEFAULT))
            {
              buf[0].st_dev = 134217984;
              *(_QWORD *)&buf[0].st_mode = *((_QWORD *)&v290 + 1) - v196 + *((_QWORD *)&v291 + 1);
              _os_log_impl(&dword_1B8270000, v213, OS_LOG_TYPE_DEFAULT, "At start %lld", (uint8_t *)buf, 0xCu);
            }
            *__error() = v212;
            if ((v276 & 0x40) == 0)
              goto LABEL_217;
          }
          else if ((v276 & 0x40) == 0)
          {
LABEL_217:
            v198 = 0;
            goto LABEL_248;
          }
          v198 = *(_QWORD *)(v35 + 4904) + 4376;
LABEL_248:
          vint32_2297 = store_stream_read_vint32_2297((uint64_t)&v289);
          v215 = vint32_2297;
          if (dword_1EF19FCB4 >= 5)
          {
            v247 = *__error();
            v248 = _SILogForLogForCategory(10);
            if (os_log_type_enabled(v248, OS_LOG_TYPE_DEFAULT))
            {
              buf[0].st_dev = 134217984;
              *(_QWORD *)&buf[0].st_mode = *((_QWORD *)&v290 + 1) - v291 + *((_QWORD *)&v291 + 1);
              _os_log_impl(&dword_1B8270000, v248, OS_LOG_TYPE_DEFAULT, "Post version at %lld", (uint8_t *)buf, 0xCu);
            }
            *__error() = v247;
            if (v215 != 2)
              goto LABEL_320;
          }
          else if (vint32_2297 != 2)
          {
            goto LABEL_320;
          }
          v216 = (a10 - 111) < 4;
          if (!v274)
            v216 = (a10 - 95) < 8;
          if (v216)
          {
            v217 = store_stream_read_vint32_2297((uint64_t)&v289);
            numBits = store_stream_read_vint32_2297((uint64_t)&v289);
            v268 = store_stream_read_vint32_2297((uint64_t)&v289);
            v218 = atomic_load(v37);
            if (v218 < 0)
              v219 = store_stream_read_vint32_2297((uint64_t)&v289);
            else
              v219 = 0;
            if (numBits <= v217)
              v220 = v217;
            else
              v220 = numBits;
            if (v220 <= v268)
              LODWORD(v221) = v268;
            else
              LODWORD(v221) = v220;
            if (v221 <= v219)
              v221 = v219;
            else
              v221 = v221;
            v222 = (UInt8 *)malloc_type_malloc((unint64_t)(v221 + 7) >> 3, 0x667CE084uLL);
            if (v222)
            {
              v223 = v222;
              if (dword_1EF19FCB4 >= 5)
              {
                v251 = *__error();
                v252 = _SILogForLogForCategory(10);
                if (os_log_type_enabled(v252, OS_LOG_TYPE_DEFAULT))
                {
                  buf[0].st_dev = 134217984;
                  *(_QWORD *)&buf[0].st_mode = *((_QWORD *)&v290 + 1) - v291 + *((_QWORD *)&v291 + 1);
                  _os_log_impl(&dword_1B8270000, v252, OS_LOG_TYPE_DEFAULT, "Pre-loop at %lld", (uint8_t *)buf, 0xCu);
                }
                *__error() = v251;
              }
              if (*a9)
                goto LABEL_312;
              if (store_stream_read_bytes_2300((unsigned int *)&v289, (char *)v223, (unint64_t)(v217 + 7) >> 3) == (unint64_t)(v217 + 7) >> 3)
              {
                v224 = CFBitVectorCreate(0, v223, v217);
                if (v224)
                {
                  v225 = v224;
                  if ((_DWORD)v217)
                  {
                    for (i = 0; i != v217; ++i)
                    {
                      v227 = CFBitVectorGetBitAtIndex(v225, i) != 0;
                      bit_vector_set_2301((uint64_t)(v278 + 2344), i, v227);
                    }
                  }
                  CFRelease(v225);
                  if (dword_1EF19FCB4 >= 5)
                  {
                    v253 = *__error();
                    v254 = _SILogForLogForCategory(10);
                    if (os_log_type_enabled(v254, OS_LOG_TYPE_DEFAULT))
                    {
                      buf[0].st_dev = 134217984;
                      *(_QWORD *)&buf[0].st_mode = *((_QWORD *)&v290 + 1) - v291 + *((_QWORD *)&v291 + 1);
                      _os_log_impl(&dword_1B8270000, v254, OS_LOG_TYPE_DEFAULT, "Post bv1 at %lld", (uint8_t *)buf, 0xCu);
                    }
                    *__error() = v253;
                  }
                  if (*a9)
                    goto LABEL_312;
                  if (store_stream_read_bytes_2300((unsigned int *)&v289, (char *)v223, (unint64_t)(numBits + 7) >> 3) == (unint64_t)(numBits + 7) >> 3)
                  {
                    v228 = CFBitVectorCreate(0, v223, numBits);
                    if (v228)
                    {
                      v229 = v228;
                      if ((_DWORD)numBits)
                      {
                        for (j = 0; j != numBits; ++j)
                        {
                          v231 = CFBitVectorGetBitAtIndex(v229, j) != 0;
                          bit_vector_set_2301((uint64_t)(v278 + 3522), j, v231);
                        }
                      }
                      CFRelease(v229);
                      if (dword_1EF19FCB4 >= 5)
                      {
                        v255 = *__error();
                        v256 = _SILogForLogForCategory(10);
                        if (os_log_type_enabled(v256, OS_LOG_TYPE_DEFAULT))
                        {
                          buf[0].st_dev = 134217984;
                          *(_QWORD *)&buf[0].st_mode = *((_QWORD *)&v290 + 1) - v291 + *((_QWORD *)&v291 + 1);
                          _os_log_impl(&dword_1B8270000, v256, OS_LOG_TYPE_DEFAULT, "Post bv2 at %lld", (uint8_t *)buf, 0xCu);
                        }
                        *__error() = v255;
                      }
                      if (*a9)
                        goto LABEL_312;
                      if (store_stream_read_bytes_2300((unsigned int *)&v289, (char *)v223, (unint64_t)(v268 + 7) >> 3) == (unint64_t)(v268 + 7) >> 3)
                      {
                        v232 = CFBitVectorCreate(0, v223, v268);
                        if (v232)
                        {
                          v233 = v232;
                          if ((_DWORD)v268)
                          {
                            for (k = 0; k != v268; ++k)
                            {
                              v235 = CFBitVectorGetBitAtIndex(v233, k) != 0;
                              bit_vector_set_2301((uint64_t)(v278 + 1154), k, v235);
                            }
                          }
                          CFRelease(v233);
                          if (dword_1EF19FCB4 >= 5)
                          {
                            v257 = *__error();
                            v258 = _SILogForLogForCategory(10);
                            if (os_log_type_enabled(v258, OS_LOG_TYPE_DEFAULT))
                            {
                              buf[0].st_dev = 134217984;
                              *(_QWORD *)&buf[0].st_mode = *((_QWORD *)&v290 + 1) - v291 + *((_QWORD *)&v291 + 1);
                              _os_log_impl(&dword_1B8270000, v258, OS_LOG_TYPE_DEFAULT, "Post bv3 at %lld", (uint8_t *)buf, 0xCu);
                            }
                            *__error() = v257;
                          }
                          if ((v276 & 0x40) == 0 || !*(_QWORD *)(v35 + 4904))
                            goto LABEL_297;
                          if (*a9)
                          {
LABEL_312:
                            free(v223);
                            v137 = v281;
LABEL_313:
                            store_stream_destroy((uint64_t)&v289);
                            fd_release(v193);
                            if ((_DWORD)v290)
                              goto LABEL_314;
LABEL_223:
                            if (*a9)
                              goto LABEL_314;
LABEL_197:
                            v186 = *(_QWORD *)(v35 + 14352);
                            if (v186)
                            {
                              if (*v277)
                                *(_QWORD *)(v186 + 608) = getPropertyStringCallback;
                              *(_QWORD *)(v186 + 280) = v278 + 3536;
                            }
                            *(_BYTE *)(v35 + 8) = 1;
                            if (((v275 | v280) & 1) != 0)
                            {
                              if (!v137)
                              {
LABEL_204:
                                *v282 = 0;
                                goto LABEL_314;
                              }
LABEL_203:
                              v187 = *(_OWORD *)(v35 + 14896);
                              v188 = *(_OWORD *)(v35 + 14928);
                              *(_OWORD *)(v137 + 16) = *(_OWORD *)(v35 + 14912);
                              *(_OWORD *)(v137 + 32) = v188;
                              *(_OWORD *)v137 = v187;
                              v189 = *(_OWORD *)(v35 + 14944);
                              v190 = *(_OWORD *)(v35 + 14960);
                              v191 = *(_OWORD *)(v35 + 14976);
                              *(_QWORD *)(v137 + 96) = *(_QWORD *)(v35 + 14992);
                              *(_OWORD *)(v137 + 64) = v190;
                              *(_OWORD *)(v137 + 80) = v191;
                              *(_OWORD *)(v137 + 48) = v189;
                              goto LABEL_204;
                            }
                            if (indexShadowFiles(v35, 1, v301, a9))
                            {
                              *v282 = -1;
                              v199 = *__error();
                              v200 = _SILogForLogForCategory(0);
                              if (!os_log_type_enabled(v200, OS_LOG_TYPE_ERROR))
                              {
LABEL_227:
                                *__error() = v199;
LABEL_228:
                                if (!*v282)
                                  return (char *)v35;
                                goto LABEL_316;
                              }
                              v201 = *v282;
                              buf[0].st_dev = 136315906;
                              *(_QWORD *)&buf[0].st_mode = "openIndex";
                              WORD2(buf[0].st_ino) = 1024;
                              *(_DWORD *)((char *)&buf[0].st_ino + 6) = 2244;
                              HIWORD(buf[0].st_uid) = 1024;
                              buf[0].st_gid = v201;
                              LOWORD(buf[0].st_rdev) = 2080;
                              *(_QWORD *)((char *)&buf[0].st_rdev + 2) = v279;
                              v202 = "%s:%d: index shadow err:%d at %s\n";
                              v203 = (uint8_t *)buf;
                            }
                            else
                            {
                              bzero(buf, 0x1000uLL);
                              *(_QWORD *)v297 = buf;
                              indexStoreToBuffer(v35, (void **)v297);
                              if (!indexCommitShadow(v35, buf))
                              {
                                fd_sync(*(_QWORD *)(v35 + 14432), 1);
                                if (!v137)
                                  goto LABEL_204;
                                goto LABEL_203;
                              }
                              *v282 = -1;
                              v199 = *__error();
                              v200 = _SILogForLogForCategory(0);
                              if (!os_log_type_enabled(v200, OS_LOG_TYPE_ERROR))
                                goto LABEL_227;
                              v204 = *v282;
                              *(_DWORD *)v293 = 136315906;
                              *(_QWORD *)&v293[4] = "openIndex";
                              *(_WORD *)&v293[12] = 1024;
                              *(_DWORD *)&v293[14] = 2253;
                              *(_WORD *)&v293[18] = 1024;
                              *(_DWORD *)&v293[20] = v204;
                              v294 = 2080;
                              v295 = v279;
                              v202 = "%s:%d: index commit shadow err:%d at %s\n";
                              v203 = v293;
                            }
                            _os_log_error_impl(&dword_1B8270000, v200, OS_LOG_TYPE_ERROR, v202, v203, 0x22u);
                            goto LABEL_227;
                          }
                          if (store_stream_read_bytes_2300((unsigned int *)&v289, (char *)v223, ((unint64_t)v219 + 7) >> 3) == ((unint64_t)v219 + 7) >> 3)
                          {
                            v236 = CFBitVectorCreate(0, v223, v219);
                            if (v236)
                            {
                              v237 = v236;
                              if (v219)
                              {
                                for (m = 0; m != v219; bit_vector_set_2301(v198, m++, v239))
                                  v239 = CFBitVectorGetBitAtIndex(v237, m) != 0;
                              }
                              **(_BYTE **)(v35 + 4904) = 1;
                              CFRelease(v237);
LABEL_297:
                              if (!*a9)
                              {
                                if (dword_1EF19FCB4 >= 5)
                                {
                                  v259 = *__error();
                                  v260 = _SILogForLogForCategory(10);
                                  if (os_log_type_enabled(v260, OS_LOG_TYPE_DEFAULT))
                                  {
                                    buf[0].st_dev = 134217984;
                                    *(_QWORD *)&buf[0].st_mode = *((_QWORD *)&v290 + 1) - v291 + *((_QWORD *)&v291 + 1);
                                    _os_log_impl(&dword_1B8270000, v260, OS_LOG_TYPE_DEFAULT, "Post bv4 at %lld", (uint8_t *)buf, 0xCu);
                                  }
                                  *__error() = v259;
                                }
                                v240 = 32 * *(unsigned __int8 *)(v35 + 38);
                                v241 = *(_QWORD *)(v35 + 72);
                                v242 = *(unsigned int *)(v35 + 60);
                                v243 = atomic_load(v278 + 7);
                                updated = TermUpdateSetRestore((uint64_t)&v289, (uint64_t)_indexProgress, v35, v241, v242, v240, v242, (v243 >> 3) & 1, *(_QWORD *)(v35 + 14344), *(_DWORD *)(v35 + 48), *(const void **)(v35 + 4912));
                                *(_QWORD *)(v35 + 14352) = updated;
                                if (!updated)
                                {
                                  v245 = (_DWORD)v290 == 22
                                       ? "invalid term update set"
                                       : "restoring term update set failed";
                                  _si_set_error_str(v245);
                                  if (!(_DWORD)v290)
                                    LODWORD(v290) = -1;
                                }
                                if (!(_DWORD)v217 && !(_DWORD)numBits && !(_DWORD)v268 && !v219)
                                {
                                  v246 = *(_QWORD *)(v35 + 14352);
                                  if (v246)
                                    atomic_load((unsigned int *)(*(_QWORD *)(v246 + 24) + 16));
                                }
                              }
                              goto LABEL_312;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              LODWORD(v290) = -1;
              goto LABEL_312;
            }
            v249 = __si_assert_copy_extra_2151(0, -1);
            v206 = v249;
            v250 = "";
            if (v249)
              v250 = v249;
            v261 = "bits";
            v262 = v250;
            v208 = 2111;
LABEL_237:
            __message_assert("%s:%u: failed assertion '%s' %s ", "JHContentIndex.c", v208, v261, v262);
            free(v206);
            if (__valid_fs(-1))
              v209 = 2989;
            else
              v209 = 3072;
            *(_DWORD *)v209 = -559038737;
            abort();
          }
LABEL_320:
          LODWORD(v290) = -1;
          store_stream_destroy((uint64_t)&v289);
          fd_release(v193);
          if (*v282)
            goto LABEL_316;
          return (char *)v35;
        }
        LOBYTE(v286) = 0;
        *(_BYTE *)(v35 + 8) = 1;
        v163 = OSAtomicIncrement32((int32_t *)exceptionSequenceNum);
        *(_DWORD *)v293 = 0;
        *(_DWORD *)v297 = 0;
        LODWORD(v285[0]) = 0;
        HIDWORD(v287) = 0;
        v164 = setThreadIdAndInfo(-1, (__int128 *)sIndexExceptionCallbacks, v35, 0, v163);
        *(_DWORD *)v297 = HIDWORD(v164);
        *(_DWORD *)v293 = v164;
        LODWORD(v285[0]) = v165;
        HIDWORD(v287) = v166;
        v167 = *(_QWORD *)&threadData[18 * v164 + 2];
        v168 = v167 + 320 * HIDWORD(v164);
        *(_BYTE *)(v168 + 216) = 0;
        v169 = *(_DWORD *)(v168 + 312);
        v170 = *(void (**)(_QWORD))(v168 + 224);
        if (v170)
          v170(*(_QWORD *)(v167 + 320 * HIDWORD(v164) + 288));
        v266 = v163;
        *(_QWORD *)((char *)&v287 + 4) = __PAIR64__(*(unsigned int *)v293, *(unsigned int *)v297);
        LODWORD(v287) = v285[0];
        HIDWORD(v286) = HIDWORD(v287);
        if (_setjmp((int *)v168))
        {
          v171 = *__error();
          v172 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v172, OS_LOG_TYPE_ERROR))
          {
            buf[0].st_dev = 136315394;
            *(_QWORD *)&buf[0].st_mode = "openIndex";
            WORD2(buf[0].st_ino) = 1024;
            *(_DWORD *)((char *)&buf[0].st_ino + 6) = 2040;
            _os_log_error_impl(&dword_1B8270000, v172, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", (uint8_t *)buf, 0x12u);
          }
          *__error() = v171;
          *(_DWORD *)(v168 + 312) = v169;
          CIOnThreadCleanUpReset(HIDWORD(v286));
          dropThreadId(DWORD2(v287), 1, v163);
          CICleanUpReset(DWORD2(v287), v287);
          goto LABEL_195;
        }
        v173 = **(_QWORD **)(v35 + 96);
        v174 = **(_QWORD **)(v35 + 104);
        v175 = 0;
        v176 = *(_QWORD *)storageResolvePtr((uint64_t)(v278 + 62), 0, 8uLL, 1);
        v177 = *(_QWORD *)(v35 + 4904);
        if (v177)
          v175 = *(_QWORD *)storageResolvePtr(v177 + 8, 0, 8uLL, 1);
        v263 = v174;
        v265 = *__error();
        v178 = _SILogForLogForCategory(10);
        v179 = v178;
        if (v173 > v162 || v174 > v162 || v176 > v162 || v175 > v162)
        {
          if (os_log_type_enabled(v178, OS_LOG_TYPE_ERROR))
          {
            buf[0].st_dev = 136316674;
            *(_QWORD *)&buf[0].st_mode = "openIndex";
            WORD2(buf[0].st_ino) = 1024;
            *(_DWORD *)((char *)&buf[0].st_ino + 6) = 2031;
            HIWORD(buf[0].st_uid) = 2048;
            *(_QWORD *)&buf[0].st_gid = v173;
            *((_WORD *)&buf[0].st_rdev + 2) = 2048;
            *(_QWORD *)((char *)&buf[0].st_rdev + 6) = v174;
            HIWORD(buf[0].st_atimespec.tv_sec) = 2048;
            buf[0].st_atimespec.tv_nsec = v176;
            LOWORD(buf[0].st_mtimespec.tv_sec) = 2048;
            *(__darwin_time_t *)((char *)&buf[0].st_mtimespec.tv_sec + 2) = v175;
            WORD1(buf[0].st_mtimespec.tv_nsec) = 2048;
            *(uint64_t *)((char *)&buf[0].st_mtimespec.tv_nsec + 4) = v162;
            _os_log_error_impl(&dword_1B8270000, v179, OS_LOG_TYPE_ERROR, "%s:%d: unexpected sync count %lld %lld %lld %lld, expected %lld", (uint8_t *)buf, 0x44u);
          }
          *__error() = v265;
          v42 = v173 == v174;
          v181 = v266;
          if (!v42 || v174 != v176 || v176 != v175 || v175 != v162 + 1)
            goto LABEL_192;
        }
        else
        {
          v180 = 2 * (dword_1EF19FCB4 < 4);
          if (os_log_type_enabled(v178, v180))
          {
            buf[0].st_dev = 134219008;
            *(_QWORD *)&buf[0].st_mode = v162;
            WORD2(buf[0].st_ino) = 2048;
            *(__darwin_ino64_t *)((char *)&buf[0].st_ino + 6) = v173;
            HIWORD(buf[0].st_gid) = 2048;
            *(_QWORD *)&buf[0].st_rdev = v263;
            LOWORD(buf[0].st_atimespec.tv_sec) = 2048;
            *(__darwin_time_t *)((char *)&buf[0].st_atimespec.tv_sec + 2) = v176;
            WORD1(buf[0].st_atimespec.tv_nsec) = 2048;
            *(uint64_t *)((char *)&buf[0].st_atimespec.tv_nsec + 4) = v175;
            _os_log_impl(&dword_1B8270000, v179, v180, "head:%lld fat:%lld compact:%lld flat:%lld dir:%lld", (uint8_t *)buf, 0x34u);
          }
          v181 = v266;
          *__error() = v265;
        }
        LOBYTE(v286) = 1;
LABEL_192:
        v182 = *(_QWORD *)&threadData[18 * DWORD2(v287) + 2];
        v183 = DWORD1(v287);
        v184 = v182 + 320 * DWORD1(v287);
        *(_DWORD *)(v184 + 312) = v169;
        v185 = *(void (**)(_QWORD))(v184 + 232);
        if (v185)
          v185(*(_QWORD *)(v182 + 320 * v183 + 288));
        dropThreadId(DWORD2(v287), 0, v181);
        v137 = v281;
LABEL_195:
        v103 = v273;
        *(_BYTE *)(v35 + 8) = 0;
        if ((_BYTE)v286)
          goto LABEL_196;
LABEL_218:
        *v282 = -1;
        goto LABEL_228;
      }
      v76 = atomic_load((unsigned int *)v34 + 6);
      if (v76 == 1)
      {
        v77 = *(_DWORD *)(v35 + 52);
        if (*(_DWORD *)(v35 + 60) > v77)
          *(_DWORD *)(v35 + 60) = v77 + 1;
        v78 = *(unsigned int *)(v35 + 64);
        v79 = v78 + 3;
        v80 = (v78 + 4) / 5uLL;
        v81 = v79 >> 2;
        if (*(_BYTE *)(v35 + 37))
          v82 = v81;
        else
          v82 = v80;
        v74 = (8 * *MEMORY[0x1E0C85AD8] - 1 + v82) / (8 * *MEMORY[0x1E0C85AD8]);
        v75 = 2763841841;
        goto LABEL_74;
      }
      v102 = atomic_load((unsigned int *)v34 + 6);
      if (v102 == -804450864)
      {
        v83 = 0;
        goto LABEL_75;
      }
      v107 = atomic_load((unsigned int *)v34 + 6);
      if (v107 == 2)
      {
        v84 = 1;
        v83 = 1;
        goto LABEL_76;
      }
      v108 = *(_DWORD *)(v35 + 52);
      if (*(_DWORD *)(v35 + 60) > v108)
      {
        *(_DWORD *)(v35 + 60) = v108 + 1;
        goto LABEL_228;
      }
LABEL_314:
      v15 = v282;
      goto LABEL_315;
    }
  }
  else
  {
LABEL_54:
    v61 = -1;
  }
  *v282 = v61;
  if (!*v282)
    return (char *)v35;
LABEL_316:
  freeIndex(v35);
  return 0;
}

uint64_t store_stream_read_vint32_2297(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  uint64_t v9;
  int v10;
  char v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  int v17;
  char __dst;

  v2 = *(_QWORD *)(a1 + 40);
  if ((unint64_t)(*(_QWORD *)(a1 + 32) - v2) < 6)
  {
    v17 = 0;
    LODWORD(v5) = 0;
    __dst = 0;
    while (store_stream_read_bytes_2300((unsigned int *)a1, &__dst, 1uLL) == 1)
    {
      v5 = ((__dst & 0x7F) << v17) | v5;
      v17 += 7;
      if ((__dst & 0x80) == 0)
        return v5;
    }
    return 0;
  }
  else
  {
    v3 = *(_QWORD *)(a1 + 48);
    v4 = v2 + 1;
    v5 = *(unsigned __int8 *)(v3 + v2);
    if (*(char *)(v3 + v2) < 0)
    {
      v6 = v2 + 2;
      v7 = *(char *)(v3 + v4);
      v8 = *(unsigned __int8 *)(v3 + v4);
      if (v7 < 0)
      {
        v9 = v2 + 3;
        v10 = *(char *)(v3 + v6);
        v11 = v10;
        if (v10 < 0)
        {
          v12 = v2 + 4;
          v13 = *(char *)(v3 + v9);
          v14 = *(unsigned __int8 *)(v3 + v9);
          if (v13 < 0)
          {
            v15 = *(char *)(v3 + v12);
            *(_QWORD *)(a1 + 40) = v2 + 5;
            if (v15 < 0)
            {
              return ((v14 & 0x7F) << 21) | (v15 << 28) | ((v11 & 0x7F) << 14) | ((v8 & 0x7F) << 7) | (v5 & 0x7F);
            }
            else
            {
              v5 = 0;
              *(_DWORD *)(a1 + 16) = 22;
            }
          }
          else
          {
            v5 = ((v11 & 0x7F) << 14) | (v14 << 21) | ((v8 & 0x7F) << 7) | (v5 & 0x7F);
            *(_QWORD *)(a1 + 40) = v12;
          }
        }
        else
        {
          v5 = ((v8 & 0x7F) << 7) | (v10 << 14) | (v5 & 0x7F);
          *(_QWORD *)(a1 + 40) = v9;
        }
      }
      else
      {
        v5 = v5 & 0x7F | (v8 << 7);
        *(_QWORD *)(a1 + 40) = v6;
      }
    }
    else
    {
      *(_QWORD *)(a1 + 40) = v4;
    }
  }
  return v5;
}

size_t store_stream_read_bytes_2300(unsigned int *a1, char *__dst, size_t __n)
{
  char *v4;
  size_t v6;
  uint64_t v7;
  size_t v8;
  size_t v9;
  unint64_t v11;
  void *v12;
  unint64_t v13;
  size_t __na;

  v4 = __dst;
  v6 = *((_QWORD *)a1 + 4);
  v7 = *((_QWORD *)a1 + 5);
  if (v7 + __n > v6)
  {
    v8 = v6 - v7;
    if (v6 != v7)
    {
      memcpy(__dst, (const void *)(*((_QWORD *)a1 + 6) + v7), v6 - v7);
      v6 = *((_QWORD *)a1 + 4);
      *((_QWORD *)a1 + 5) += v8;
    }
    v11 = prot_pread(*a1, *((void **)a1 + 6), v6, *((_QWORD *)a1 + 3));
    if (v11 == -1)
    {
      v8 = 0;
    }
    else
    {
      *((_QWORD *)a1 + 4) = v11;
      *((_QWORD *)a1 + 5) = 0;
      *((_QWORD *)a1 + 3) += v11;
      if (!v11)
      {
        v9 = 0;
        return v8 + v9;
      }
      v4 += v8;
      __n -= v8;
      if (__n <= v11)
      {
        v7 = 0;
        goto LABEL_3;
      }
      __na = v11;
      while (1)
      {
        memcpy(v4, *((const void **)a1 + 6), __na);
        v12 = (void *)*((_QWORD *)a1 + 6);
        *((_QWORD *)a1 + 5) += __na;
        v13 = prot_pread(*a1, v12, *((_QWORD *)a1 + 4), *((_QWORD *)a1 + 3));
        if (v13 == -1)
          break;
        *((_QWORD *)a1 + 4) = v13;
        *((_QWORD *)a1 + 5) = 0;
        *((_QWORD *)a1 + 3) += v13;
        if (!v13)
        {
          v9 = v8;
          v8 = __na;
          return v8 + v9;
        }
        v7 = 0;
        v4 += __na;
        __n -= __na;
        v8 += __na;
        __na = v13;
        if (__n <= v13)
          goto LABEL_3;
      }
    }
    a1[4] = *__error();
    v9 = v8;
    v8 = 0;
    return v8 + v9;
  }
  v8 = 0;
LABEL_3:
  memcpy(v4, (const void *)(*((_QWORD *)a1 + 6) + v7), __n);
  *((_QWORD *)a1 + 5) += __n;
  v9 = v8;
  v8 = __n;
  return v8 + v9;
}

void bit_vector_set_2301(uint64_t a1, CFIndex a2, CFBit a3)
{
  char *v6;
  char *v7;
  const char *v8;

  if (a2 < 0)
  {
    v6 = __si_assert_copy_extra_2151(0, -1);
    v7 = v6;
    v8 = "";
    if (v6)
      v8 = v6;
    __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 129, "bitIndex >= 0", v8);
    free(v7);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  bit_vector_internal_touch_for_set((CFIndex *)a1, a2);
  CFBitVectorSetBitAtIndex(*(CFMutableBitVectorRef *)(a1 + 16), a2, a3);
}

uint64_t indexShadowFiles(uint64_t a1, char a2, _DWORD *a3, _DWORD *a4)
{
  uint64_t v8;
  unsigned int *v9;
  char v10;
  char v11;
  uint64_t v12;
  unsigned int v13;
  int v14;
  char v15;
  _QWORD *v16;
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  double Current;
  char *v23;
  char *v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  unsigned int v28;
  uint64_t v29;
  unsigned int v31;
  int v32;
  NSObject *v33;
  const char *v34;
  int v35;
  NSObject *v36;
  int v38;
  NSObject *v39;
  int v40;
  NSObject *v41;
  const char *v42;
  NSObject *v43;
  uint32_t v44;
  NSObject *v45;
  int v46;
  NSObject *v47;
  os_log_type_t v48;
  float v49;
  double v50;
  char *v51;
  int v52;
  NSObject *v53;
  os_log_type_t v54;
  float v55;
  unsigned int v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  char v60;
  char *v61;
  char *v62;
  const char *v63;
  _BYTE buf[12];
  __int16 v65;
  int v66;
  __int16 v67;
  _BYTE v68[14];
  char __str[1024];
  uint64_t v70;

  v70 = *MEMORY[0x1E0C80C00];
  bzero(__str, 0x400uLL);
  if (*(_BYTE *)(a1 + 15163))
  {
    if ((indexShadowFiles__COUNT_ & 1) != 0)
    {
      v8 = 0;
LABEL_32:
      v26 = 22;
      goto LABEL_33;
    }
    indexShadowFiles__COUNT_ = 1;
    v32 = *__error();
    v33 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "indexShadowFiles";
      v65 = 1024;
      v66 = 3041;
      v67 = 2080;
      *(_QWORD *)v68 = a1 + 15168;
      v34 = "%s:%d: trying to modify read only index %s";
LABEL_45:
      _os_log_error_impl(&dword_1B8270000, v33, OS_LOG_TYPE_ERROR, v34, buf, 0x1Cu);
      goto LABEL_31;
    }
    goto LABEL_31;
  }
  if (!*(_BYTE *)(a1 + 8) || *(_DWORD *)(a1 + 15156) == -1)
  {
    v32 = *__error();
    v33 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "indexShadowFiles";
      v65 = 1024;
      v66 = 3050;
      v67 = 2080;
      *(_QWORD *)v68 = a1 + 15168;
      v34 = "%s:%d: can't shadow %s";
      goto LABEL_45;
    }
LABEL_31:
    v8 = 0;
    *__error() = v32;
    goto LABEL_32;
  }
  v9 = (unsigned int *)(a1 + 28);
  v10 = atomic_load((unsigned int *)(a1 + 28));
  if ((v10 & 1) == 0
    || (v11 = atomic_load(v9), (v11 & 2) != 0)
    || (v12 = *(_QWORD *)(a1 + 14352)) != 0 && (v13 = atomic_load((unsigned int *)(*(_QWORD *)(v12 + 24) + 16))) != 0)
  {
    v14 = 0;
  }
  else
  {
    do
      v27 = __ldaxr(v9);
    while (__stlxr(v27 | 2, v9));
    v28 = atomic_load((unsigned int *)(a1 + 28));
    a3[2] = v28;
    v29 = *(_QWORD *)(a1 + 14352);
    if (v29)
    {
      if (atomic_load((unsigned int *)(*(_QWORD *)(v29 + 24) + 16)))
      {
        v61 = __si_assert_copy_extra_2151(0, -1);
        v62 = v61;
        v63 = "";
        if (v61)
          v63 = v61;
        __message_assert("%s:%u: failed assertion '%s' %s ", "JHContentIndex.c", 3075, "0 == TermUpdateSetTermCount(cindex->_deltaSet)", v63);
        free(v62);
        if (__valid_fs(-1))
        {
          MEMORY[0xBAD] = -559038737;
          abort();
        }
        MEMORY[0xC00] = -559038737;
        abort();
      }
      _db_write_lock(a1 + 14680);
      TermUpdateSetRelease(*(_QWORD *)(a1 + 14352));
      do
        v31 = __ldaxr(gTermUpdateSetCount);
      while (__stlxr(v31 - 1, gTermUpdateSetCount));
      *(_QWORD *)(a1 + 14352) = 0;
      db_write_unlock(a1 + 14680);
    }
    v14 = 1;
  }
  v15 = atomic_load(v9);
  snprintf(__str, 0x400uLL, "%s%s", (const char *)(a1 + 15168), "shadowIndexHead");
  v16 = fd_create_protected(*(_DWORD *)(a1 + 56), __str, 536872450, 3u);
  if (!v16)
  {
    v26 = *__error();
    v38 = *__error();
    v39 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = "indexShadowFiles";
      v65 = 1024;
      v66 = 3094;
      v67 = 1024;
      *(_DWORD *)v68 = v26;
      *(_WORD *)&v68[4] = 2080;
      *(_QWORD *)&v68[6] = __str;
      _os_log_error_impl(&dword_1B8270000, v39, OS_LOG_TYPE_ERROR, "%s:%d: open err: %d, %s", buf, 0x22u);
    }
    v8 = 0;
    *__error() = v38;
    goto LABEL_33;
  }
  v8 = (uint64_t)v16;
  *(_QWORD *)buf = 0;
  v17 = _fd_acquire_fd((uint64_t)v16, buf);
  if (v17 != -1)
  {
    v18 = v17;
    *(_WORD *)(v8 + 56) |= 1u;
    fcntl(v17, 48, 1);
    fcntl(v18, 76, *(_WORD *)(v8 + 56) & 1);
    _fd_release_fd((_DWORD *)v8, v18, 0, *(uint64_t *)buf);
  }
  *a3 = 1;
  v19 = fd_pwrite(v8, (uint64_t)a3, 0x1000uLL, 0);
  *a3 = *(_DWORD *)(a1 + 4);
  if (v19 == -1)
  {
    v26 = *__error();
    v40 = *__error();
    v41 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315650;
      *(_QWORD *)&buf[4] = "indexShadowFiles";
      v65 = 1024;
      v66 = 3105;
      v67 = 1024;
      *(_DWORD *)v68 = v26;
      v42 = "%s:%d: write err: %d";
LABEL_43:
      v43 = v41;
      v44 = 24;
LABEL_49:
      _os_log_error_impl(&dword_1B8270000, v43, OS_LOG_TYPE_ERROR, v42, buf, v44);
      goto LABEL_75;
    }
    goto LABEL_75;
  }
  *(_QWORD *)buf = 0;
  v20 = _fd_acquire_fd(v8, buf);
  if ((_DWORD)v20 != -1)
  {
    v21 = v20;
    prot_fsync(v20, 0);
    _fd_release_fd((_DWORD *)v8, v21, 0, *(uint64_t *)buf);
  }
  if ((v15 & 2) != 0)
    goto LABEL_59;
  Current = CFAbsoluteTimeGetCurrent();
  snprintf(__str, 0x400uLL, "%s%s", (const char *)(a1 + 15168), "shadowIndexTermIds");
  v23 = (char *)fd_create_protected(*(_DWORD *)(a1 + 56), __str, 536871426, 3u);
  if (!v23)
  {
    v26 = *__error();
    v40 = *__error();
    v45 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = "indexShadowFiles";
      v65 = 1024;
      v66 = 3120;
      v67 = 1024;
      *(_DWORD *)v68 = v26;
      *(_WORD *)&v68[4] = 2080;
      *(_QWORD *)&v68[6] = __str;
      v42 = "%s:%d: open err: %d, %s";
LABEL_48:
      v43 = v45;
      v44 = 34;
      goto LABEL_49;
    }
LABEL_75:
    *__error() = v40;
    goto LABEL_33;
  }
  v24 = v23;
  fd_no_cache((uint64_t)v23);
  v25 = termIdStoreShadow(a1 + 4960, (uint64_t)v24, a2 & 1, a4);
  if (v25)
  {
LABEL_20:
    v26 = v25;
    fd_release(v24);
LABEL_33:
    v35 = *__error();
    v36 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      *(_QWORD *)&buf[4] = "indexShadowFiles";
      v65 = 1024;
      v66 = 3217;
      v67 = 2080;
      *(_QWORD *)v68 = a1 + 15168;
      *(_WORD *)&v68[8] = 1024;
      *(_DWORD *)&v68[10] = 3217;
      _os_log_error_impl(&dword_1B8270000, v36, OS_LOG_TYPE_ERROR, "%s:%d: %s marking invalid at %d", buf, 0x22u);
    }
    *__error() = v35;
    *(_BYTE *)(a1 + 8) = 0;
    fd_release((char *)v8);
    if (v26)
      return v26;
    else
      return 0xFFFFFFFFLL;
  }
  fd_sync((uint64_t)v24, 0);
  fd_release(v24);
  v46 = *__error();
  v47 = _SILogForLogForCategory(10);
  v48 = 2 * (dword_1EF19FCB4 < 4);
  if (os_log_type_enabled(v47, v48))
  {
    v49 = CFAbsoluteTimeGetCurrent() - Current;
    *(_DWORD *)buf = 134217984;
    *(double *)&buf[4] = v49;
    _os_log_impl(&dword_1B8270000, v47, v48, "shadowIndexTermIds took %f seconds", buf, 0xCu);
  }
  *__error() = v46;
  v50 = CFAbsoluteTimeGetCurrent();
  snprintf(__str, 0x400uLL, "%s%s", (const char *)(a1 + 15168), "shadowIndexPositionTable");
  v51 = (char *)fd_create_protected(*(_DWORD *)(a1 + 56), __str, 536871426, 3u);
  if (!v51)
  {
    v26 = *__error();
    v40 = *__error();
    v45 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
      goto LABEL_75;
    *(_DWORD *)buf = 136315906;
    *(_QWORD *)&buf[4] = "indexShadowFiles";
    v65 = 1024;
    v66 = 3141;
    v67 = 1024;
    *(_DWORD *)v68 = v26;
    *(_WORD *)&v68[4] = 2080;
    *(_QWORD *)&v68[6] = __str;
    v42 = "%s:%d: open err: %d, %s";
    goto LABEL_48;
  }
  v24 = v51;
  fd_no_cache((uint64_t)v51);
  v25 = termIdStoreShadow(a1 + 9672, (uint64_t)v24, a2 & 1, a4);
  if (v25)
    goto LABEL_20;
  fd_sync((uint64_t)v24, 0);
  fd_release(v24);
  v52 = *__error();
  v53 = _SILogForLogForCategory(10);
  v54 = 2 * (dword_1EF19FCB4 < 4);
  if (os_log_type_enabled(v53, v54))
  {
    v55 = CFAbsoluteTimeGetCurrent() - v50;
    *(_DWORD *)buf = 134217984;
    *(double *)&buf[4] = v55;
    _os_log_impl(&dword_1B8270000, v53, v54, "shadowIndexPositionTable took %f seconds", buf, 0xCu);
  }
  *__error() = v52;
  v56 = bt_shadowTrie(a1 + 88, (const char *)(a1 + 15168), a2 & 1, a4);
  if (v56)
  {
LABEL_62:
    v26 = v56;
    goto LABEL_33;
  }
  v57 = *(_QWORD *)(a1 + 4896);
  if (v57)
    shadowVectorIndex(v57, a2 & 1, (uint64_t)a4);
LABEL_59:
  v58 = *(_QWORD *)(a1 + 4904);
  if (v58)
    shadowForwardStore(v58, a2 & 1, a4);
  v56 = _indexShadowGroups(a1, 0);
  if (v56)
    goto LABEL_62;
  if (fd_pwrite(v8, (uint64_t)a3, 0x1000uLL, 0) == -1)
  {
    v26 = *__error();
    v40 = *__error();
    v41 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
      goto LABEL_75;
    *(_DWORD *)buf = 136315650;
    *(_QWORD *)&buf[4] = "indexShadowFiles";
    v65 = 1024;
    v66 = 3178;
    v67 = 1024;
    *(_DWORD *)v68 = v26;
    v42 = "%s:%d: write err: %d";
    goto LABEL_43;
  }
  fd_sync(v8, 0);
  if (v14)
  {
    fd_sync(v8, 1);
    if (_os_feature_enabled_impl())
    {
      v59 = *(_QWORD *)(a1 + 4896);
      if (v59)
        IVFVectorIndex_s::makeReadOnly((_QWORD *)(v59 + 8));
    }
    storageTruncateAndMakeReadOnly(a1 + 248);
    fd_truncate_and_make_readonly(*(_QWORD *)(a1 + 200), *(_QWORD *)(a1 + 120));
    fd_truncate_and_make_readonly(*(_QWORD *)(a1 + 4656), 1028 * (*(_DWORD *)(a1 + 232) + 1));
    fd_truncate(*(_QWORD *)(a1 + 14408), 8 * *(unsigned int *)(a1 + 60));
    fd_truncate(*(_QWORD *)(a1 + 14416), 4 * *(unsigned int *)(a1 + 60));
    fd_truncate(*(_QWORD *)(a1 + 14424), 8 * *(unsigned int *)(a1 + 60));
    v60 = atomic_load((unsigned int *)(a1 + 28));
    if ((v60 & 4) == 0)
    {
      storageTruncateAndMakeReadOnly(a1 + 4960);
      storageTruncateAndMakeReadOnly(a1 + 9672);
    }
    index_DeleteShadow(*(unsigned int *)(a1 + 56), (const char *)(a1 + 15168), 1);
  }
  fd_release((char *)v8);
  return 0;
}

uint64_t *indexStoreToBuffer(uint64_t a1, void **a2)
{
  void *v4;
  unsigned int *v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int *v8;
  _BYTE *v9;
  unsigned int v10;
  uint64_t v11;
  _BYTE *v12;
  unsigned int v13;
  uint64_t v14;
  _BYTE *v15;
  unsigned int v16;
  uint64_t v17;
  _BYTE *v18;
  uint64_t v19;
  uint64_t v20;
  _BYTE *v21;
  uint64_t v22;
  uint64_t v23;
  _BYTE *v24;
  uint64_t v25;
  uint64_t v26;
  _BYTE *v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int v30;
  _BYTE *v31;
  uint64_t v32;
  _BYTE *v33;
  unsigned int v34;
  uint64_t v35;
  _BYTE *v36;
  uint64_t v37;
  uint64_t v38;
  _BYTE *v39;
  unsigned int v40;
  uint64_t v41;
  _BYTE *v42;
  unsigned int v43;
  uint64_t v44;
  _BYTE *v45;
  unsigned int v46;
  uint64_t v47;
  unsigned int v48;
  _BYTE *v49;
  uint64_t v50;
  _BYTE *v51;
  _BYTE *v52;
  unsigned int v53;
  _BYTE *v54;
  uint64_t v55;
  _BYTE *v56;
  uint64_t v57;
  uint64_t v58;
  _BYTE *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  _BYTE *v63;
  uint64_t v64;
  unsigned int v65;
  int v66;
  char *v67;
  int v68;
  char *v69;
  int v70;
  char *v71;
  int v72;
  __int128 v73;
  unsigned int v74;
  uint64_t v75;
  unint64_t *v76;
  unint64_t v77;
  uint64_t *result;
  _DWORD *v79;
  unsigned int v80;
  char *v81;
  char *v82;
  const char *v83;
  char *v84;
  const char *v85;
  char *v86;
  const char *v87;
  char *v88;
  const char *v89;

  v4 = *a2;
  bzero(*a2, 0x1000uLL);
  v5 = (unsigned int *)*a2;
  *v5++ = *(_DWORD *)(a1 + 4);
  *a2 = v5;
  v6 = atomic_load((unsigned int *)(a1 + 24));
  *v5++ = v6;
  *a2 = v5;
  v7 = atomic_load((unsigned int *)(a1 + 28));
  v8 = v5;
  *v5 = v7;
  v5[1] = *(_DWORD *)(a1 + 40);
  v5[2] = 0;
  v9 = v5 + 3;
  *a2 = v9;
  v10 = *(_DWORD *)(a1 + 52);
  if (v10 >> 28)
  {
    *((_BYTE *)v8 + 12) = v10 | 0x80;
    *((_BYTE *)v8 + 13) = (v10 >> 7) | 0x80;
    *((_BYTE *)v8 + 14) = (v10 >> 14) | 0x80;
    *((_BYTE *)v8 + 15) = (v10 >> 21) | 0x80;
    *((_BYTE *)v8 + 16) = v10 >> 28;
    v11 = 5;
  }
  else if ((v10 & 0xFE00000) != 0)
  {
    *((_BYTE *)v8 + 12) = v10 | 0x80;
    *((_BYTE *)v8 + 13) = (v10 >> 7) | 0x80;
    *((_BYTE *)v8 + 14) = (v10 >> 14) | 0x80;
    *((_BYTE *)v8 + 15) = (v10 & 0xFE00000) >> 21;
    v11 = 4;
  }
  else if ((v10 & 0x1FC000) != 0)
  {
    *((_BYTE *)v8 + 12) = v10 | 0x80;
    *((_BYTE *)v8 + 13) = (v10 >> 7) | 0x80;
    *((_BYTE *)v8 + 14) = (v10 & 0x1FC000) >> 14;
    v11 = 3;
  }
  else if ((v10 & 0x3F80) != 0)
  {
    *((_BYTE *)v8 + 12) = v10 | 0x80;
    *((_BYTE *)v8 + 13) = (unsigned __int16)(v10 & 0x3F80) >> 7;
    v11 = 2;
  }
  else
  {
    *v9 = v10;
    v11 = 1;
  }
  v12 = (char *)*a2 + v11;
  *a2 = v12;
  v13 = *(_DWORD *)(a1 + 60);
  if (v13 >> 28)
  {
    *v12 = v13 | 0x80;
    v12[1] = (v13 >> 7) | 0x80;
    v12[2] = (v13 >> 14) | 0x80;
    v12[3] = (v13 >> 21) | 0x80;
    v12[4] = v13 >> 28;
    v14 = 5;
  }
  else if ((v13 & 0xFE00000) != 0)
  {
    *v12 = v13 | 0x80;
    v12[1] = (v13 >> 7) | 0x80;
    v12[2] = (v13 >> 14) | 0x80;
    v12[3] = (v13 & 0xFE00000) >> 21;
    v14 = 4;
  }
  else if ((v13 & 0x1FC000) != 0)
  {
    *v12 = v13 | 0x80;
    v12[1] = (v13 >> 7) | 0x80;
    v12[2] = (v13 & 0x1FC000) >> 14;
    v14 = 3;
  }
  else if ((v13 & 0x3F80) != 0)
  {
    *v12 = v13 | 0x80;
    v12[1] = (unsigned __int16)(v13 & 0x3F80) >> 7;
    v14 = 2;
  }
  else
  {
    *v12 = v13;
    v14 = 1;
  }
  v15 = (char *)*a2 + v14;
  *a2 = v15;
  v16 = *(_DWORD *)(a1 + 64);
  if (v16 >> 28)
  {
    *v15 = v16 | 0x80;
    v15[1] = (v16 >> 7) | 0x80;
    v15[2] = (v16 >> 14) | 0x80;
    v15[3] = (v16 >> 21) | 0x80;
    v15[4] = v16 >> 28;
    v17 = 5;
  }
  else if ((v16 & 0xFE00000) != 0)
  {
    *v15 = v16 | 0x80;
    v15[1] = (v16 >> 7) | 0x80;
    v15[2] = (v16 >> 14) | 0x80;
    v15[3] = (v16 & 0xFE00000) >> 21;
    v17 = 4;
  }
  else if ((v16 & 0x1FC000) != 0)
  {
    *v15 = v16 | 0x80;
    v15[1] = (v16 >> 7) | 0x80;
    v15[2] = (v16 & 0x1FC000) >> 14;
    v17 = 3;
  }
  else if ((v16 & 0x3F80) != 0)
  {
    *v15 = v16 | 0x80;
    v15[1] = (unsigned __int16)(v16 & 0x3F80) >> 7;
    v17 = 2;
  }
  else
  {
    *v15 = v16;
    v17 = 1;
  }
  v18 = (char *)*a2 + v17;
  *a2 = v18;
  v19 = *(_QWORD *)(a1 + 14896);
  if (v19 >> 28)
  {
    *v18 = v19 | 0x80;
    v18[1] = (v19 >> 7) | 0x80;
    v18[2] = (v19 >> 14) | 0x80;
    v18[3] = (v19 >> 21) | 0x80;
    v18[4] = v19 >> 28;
    v20 = 5;
  }
  else if ((v19 & 0xFE00000) != 0)
  {
    *v18 = v19 | 0x80;
    v18[1] = (v19 >> 7) | 0x80;
    v18[2] = (v19 >> 14) | 0x80;
    v18[3] = (v19 & 0xFE00000) >> 21;
    v20 = 4;
  }
  else if ((v19 & 0x1FC000) != 0)
  {
    *v18 = v19 | 0x80;
    v18[1] = (v19 >> 7) | 0x80;
    v18[2] = (v19 & 0x1FC000) >> 14;
    v20 = 3;
  }
  else if ((v19 & 0x3F80) != 0)
  {
    *v18 = v19 | 0x80;
    v18[1] = (unsigned __int16)(v19 & 0x3F80) >> 7;
    v20 = 2;
  }
  else
  {
    *v18 = v19;
    v20 = 1;
  }
  v21 = (char *)*a2 + v20;
  *a2 = v21;
  v22 = *(_QWORD *)(a1 + 14904);
  if (v22 >> 28)
  {
    *v21 = v22 | 0x80;
    v21[1] = (v22 >> 7) | 0x80;
    v21[2] = (v22 >> 14) | 0x80;
    v21[3] = (v22 >> 21) | 0x80;
    v21[4] = v22 >> 28;
    v23 = 5;
  }
  else if ((v22 & 0xFE00000) != 0)
  {
    *v21 = v22 | 0x80;
    v21[1] = (v22 >> 7) | 0x80;
    v21[2] = (v22 >> 14) | 0x80;
    v21[3] = (v22 & 0xFE00000) >> 21;
    v23 = 4;
  }
  else if ((v22 & 0x1FC000) != 0)
  {
    *v21 = v22 | 0x80;
    v21[1] = (v22 >> 7) | 0x80;
    v21[2] = (v22 & 0x1FC000) >> 14;
    v23 = 3;
  }
  else if ((v22 & 0x3F80) != 0)
  {
    *v21 = v22 | 0x80;
    v21[1] = (unsigned __int16)(v22 & 0x3F80) >> 7;
    v23 = 2;
  }
  else
  {
    *v21 = v22;
    v23 = 1;
  }
  v24 = (char *)*a2 + v23;
  *a2 = v24;
  if (*(_DWORD *)(a1 + 4) >= 0x57u)
  {
    v25 = *(_QWORD *)(a1 + 14912);
    if (v25 >> 28)
    {
      *v24 = v25 | 0x80;
      v24[1] = (v25 >> 7) | 0x80;
      v24[2] = (v25 >> 14) | 0x80;
      v24[3] = (v25 >> 21) | 0x80;
      v24[4] = v25 >> 28;
      v26 = 5;
    }
    else if ((v25 & 0xFE00000) != 0)
    {
      *v24 = v25 | 0x80;
      v24[1] = (v25 >> 7) | 0x80;
      v24[2] = (v25 >> 14) | 0x80;
      v24[3] = (v25 & 0xFE00000) >> 21;
      v26 = 4;
    }
    else if ((v25 & 0x1FC000) != 0)
    {
      *v24 = v25 | 0x80;
      v24[1] = (v25 >> 7) | 0x80;
      v24[2] = (v25 & 0x1FC000) >> 14;
      v26 = 3;
    }
    else if ((v25 & 0x3F80) != 0)
    {
      *v24 = v25 | 0x80;
      v24[1] = (unsigned __int16)(v25 & 0x3F80) >> 7;
      v26 = 2;
    }
    else
    {
      *v24 = v25;
      v26 = 1;
    }
    v27 = (char *)*a2 + v26;
    *a2 = v27;
    v28 = *(_QWORD *)(a1 + 14968);
    if (v28 >> 28)
    {
      *v27 = v28 | 0x80;
      v27[1] = (v28 >> 7) | 0x80;
      v27[2] = (v28 >> 14) | 0x80;
      v27[3] = (v28 >> 21) | 0x80;
      v27[4] = v28 >> 28;
      v29 = 5;
    }
    else if ((v28 & 0xFE00000) != 0)
    {
      *v27 = v28 | 0x80;
      v27[1] = (v28 >> 7) | 0x80;
      v27[2] = (v28 >> 14) | 0x80;
      v27[3] = (v28 & 0xFE00000) >> 21;
      v29 = 4;
    }
    else if ((v28 & 0x1FC000) != 0)
    {
      *v27 = v28 | 0x80;
      v27[1] = (v28 >> 7) | 0x80;
      v27[2] = (v28 & 0x1FC000) >> 14;
      v29 = 3;
    }
    else if ((v28 & 0x3F80) != 0)
    {
      *v27 = v28 | 0x80;
      v27[1] = (unsigned __int16)(v28 & 0x3F80) >> 7;
      v29 = 2;
    }
    else
    {
      *v27 = v28;
      v29 = 1;
    }
    *a2 = (char *)*a2 + v29;
  }
  storeVInt64((uint64_t *)a2, *(_QWORD *)(a1 + 72));
  v30 = atomic_load((unsigned int *)(a1 + 12));
  v31 = *a2;
  if (v30 >> 28)
  {
    *v31 = v30 | 0x80;
    v31[1] = (v30 >> 7) | 0x80;
    v31[2] = (v30 >> 14) | 0x80;
    v31[3] = (v30 >> 21) | 0x80;
    v31[4] = v30 >> 28;
    v32 = 5;
  }
  else if ((v30 & 0xFE00000) != 0)
  {
    *v31 = v30 | 0x80;
    v31[1] = (v30 >> 7) | 0x80;
    v31[2] = (v30 >> 14) | 0x80;
    v31[3] = (v30 & 0xFE00000) >> 21;
    v32 = 4;
  }
  else if ((v30 & 0x1FC000) != 0)
  {
    *v31 = v30 | 0x80;
    v31[1] = (v30 >> 7) | 0x80;
    v31[2] = (v30 & 0x1FC000) >> 14;
    v32 = 3;
  }
  else if ((v30 & 0x3F80) != 0)
  {
    *v31 = v30 | 0x80;
    v31[1] = (unsigned __int16)(v30 & 0x3F80) >> 7;
    v32 = 2;
  }
  else
  {
    *v31 = v30;
    v32 = 1;
  }
  v33 = (char *)*a2 + v32;
  *a2 = v33;
  v34 = *(_DWORD *)(a1 + 44);
  if (v34 >> 28)
  {
    *v33 = v34 | 0x80;
    v33[1] = (v34 >> 7) | 0x80;
    v33[2] = (v34 >> 14) | 0x80;
    v33[3] = (v34 >> 21) | 0x80;
    v33[4] = v34 >> 28;
    v35 = 5;
  }
  else if ((v34 & 0xFE00000) != 0)
  {
    *v33 = v34 | 0x80;
    v33[1] = (v34 >> 7) | 0x80;
    v33[2] = (v34 >> 14) | 0x80;
    v33[3] = (v34 & 0xFE00000) >> 21;
    v35 = 4;
  }
  else if ((v34 & 0x1FC000) != 0)
  {
    *v33 = v34 | 0x80;
    v33[1] = (v34 >> 7) | 0x80;
    v33[2] = (v34 & 0x1FC000) >> 14;
    v35 = 3;
  }
  else if ((v34 & 0x3F80) != 0)
  {
    *v33 = v34 | 0x80;
    v33[1] = (unsigned __int16)(v34 & 0x3F80) >> 7;
    v35 = 2;
  }
  else
  {
    *v33 = v34;
    v35 = 1;
  }
  v36 = (char *)*a2 + v35;
  *a2 = v36;
  v37 = *(_QWORD *)(a1 + 16);
  if (v37 >> 28)
  {
    *v36 = v37 | 0x80;
    v36[1] = (v37 >> 7) | 0x80;
    v36[2] = (v37 >> 14) | 0x80;
    v36[3] = (v37 >> 21) | 0x80;
    v36[4] = v37 >> 28;
    v38 = 5;
  }
  else if ((v37 & 0xFE00000) != 0)
  {
    *v36 = v37 | 0x80;
    v36[1] = (v37 >> 7) | 0x80;
    v36[2] = (v37 >> 14) | 0x80;
    v36[3] = (v37 & 0xFE00000) >> 21;
    v38 = 4;
  }
  else if ((v37 & 0x1FC000) != 0)
  {
    *v36 = v37 | 0x80;
    v36[1] = (v37 >> 7) | 0x80;
    v36[2] = (v37 & 0x1FC000) >> 14;
    v38 = 3;
  }
  else if ((v37 & 0x3F80) != 0)
  {
    *v36 = v37 | 0x80;
    v36[1] = (unsigned __int16)(v37 & 0x3F80) >> 7;
    v38 = 2;
  }
  else
  {
    *v36 = v37;
    v38 = 1;
  }
  v39 = (char *)*a2 + v38;
  *a2 = v39;
  v40 = *(_DWORD *)(a1 + 88);
  if (v40 >> 28)
  {
    *v39 = v40 | 0x80;
    v39[1] = (v40 >> 7) | 0x80;
    v39[2] = (v40 >> 14) | 0x80;
    v39[3] = (v40 >> 21) | 0x80;
    v39[4] = v40 >> 28;
    v41 = 5;
  }
  else if ((v40 & 0xFE00000) != 0)
  {
    *v39 = v40 | 0x80;
    v39[1] = (v40 >> 7) | 0x80;
    v39[2] = (v40 >> 14) | 0x80;
    v39[3] = (v40 & 0xFE00000) >> 21;
    v41 = 4;
  }
  else if ((v40 & 0x1FC000) != 0)
  {
    *v39 = v40 | 0x80;
    v39[1] = (v40 >> 7) | 0x80;
    v39[2] = (v40 & 0x1FC000) >> 14;
    v41 = 3;
  }
  else if ((v40 & 0x3F80) != 0)
  {
    *v39 = v40 | 0x80;
    v39[1] = (unsigned __int16)(v40 & 0x3F80) >> 7;
    v41 = 2;
  }
  else
  {
    *v39 = v40;
    v41 = 1;
  }
  v42 = (char *)*a2 + v41;
  *a2 = v42;
  v43 = *(_DWORD *)(a1 + 232);
  if (v43 >> 28)
  {
    *v42 = v43 | 0x80;
    v42[1] = (v43 >> 7) | 0x80;
    v42[2] = (v43 >> 14) | 0x80;
    v42[3] = (v43 >> 21) | 0x80;
    v42[4] = v43 >> 28;
    v44 = 5;
  }
  else if ((v43 & 0xFE00000) != 0)
  {
    *v42 = v43 | 0x80;
    v42[1] = (v43 >> 7) | 0x80;
    v42[2] = (v43 >> 14) | 0x80;
    v42[3] = (v43 & 0xFE00000) >> 21;
    v44 = 4;
  }
  else if ((v43 & 0x1FC000) != 0)
  {
    *v42 = v43 | 0x80;
    v42[1] = (v43 >> 7) | 0x80;
    v42[2] = (v43 & 0x1FC000) >> 14;
    v44 = 3;
  }
  else if ((v43 & 0x3F80) != 0)
  {
    *v42 = v43 | 0x80;
    v42[1] = (unsigned __int16)(v43 & 0x3F80) >> 7;
    v44 = 2;
  }
  else
  {
    *v42 = v43;
    v44 = 1;
  }
  v45 = (char *)*a2 + v44;
  *a2 = v45;
  v46 = *(_DWORD *)(a1 + 236);
  if (v46 >> 28)
  {
    *v45 = v46 | 0x80;
    v45[1] = (v46 >> 7) | 0x80;
    v45[2] = (v46 >> 14) | 0x80;
    v45[3] = (v46 >> 21) | 0x80;
    v45[4] = v46 >> 28;
    v47 = 5;
  }
  else if ((v46 & 0xFE00000) != 0)
  {
    *v45 = v46 | 0x80;
    v45[1] = (v46 >> 7) | 0x80;
    v45[2] = (v46 >> 14) | 0x80;
    v45[3] = (v46 & 0xFE00000) >> 21;
    v47 = 4;
  }
  else if ((v46 & 0x1FC000) != 0)
  {
    *v45 = v46 | 0x80;
    v45[1] = (v46 >> 7) | 0x80;
    v45[2] = (v46 & 0x1FC000) >> 14;
    v47 = 3;
  }
  else if ((v46 & 0x3F80) != 0)
  {
    *v45 = v46 | 0x80;
    v45[1] = (unsigned __int16)(v46 & 0x3F80) >> 7;
    v47 = 2;
  }
  else
  {
    *v45 = v46;
    v47 = 1;
  }
  *a2 = (char *)*a2 + v47;
  storeVInt64((uint64_t *)a2, *(_QWORD *)(a1 + 4920));
  storeVInt64((uint64_t *)a2, *(_QWORD *)(a1 + 4928));
  storeVInt64((uint64_t *)a2, *(_QWORD *)(a1 + 4944));
  storeVInt64((uint64_t *)a2, *(_QWORD *)(a1 + 4952));
  v48 = *(_DWORD *)(a1 + 32);
  v49 = *a2;
  if (v48 >> 28)
  {
    *v49 = v48 | 0x80;
    v49[1] = (v48 >> 7) | 0x80;
    v49[2] = (v48 >> 14) | 0x80;
    v49[3] = (v48 >> 21) | 0x80;
    v49[4] = v48 >> 28;
    v50 = 5;
  }
  else if ((v48 & 0xFE00000) != 0)
  {
    *v49 = v48 | 0x80;
    v49[1] = (v48 >> 7) | 0x80;
    v49[2] = (v48 >> 14) | 0x80;
    v49[3] = (v48 & 0xFE00000) >> 21;
    v50 = 4;
  }
  else if ((v48 & 0x1FC000) != 0)
  {
    *v49 = v48 | 0x80;
    v49[1] = (v48 >> 7) | 0x80;
    v49[2] = (v48 & 0x1FC000) >> 14;
    v50 = 3;
  }
  else if ((v48 & 0x3F80) != 0)
  {
    *v49 = v48 | 0x80;
    v49[1] = (unsigned __int16)(v48 & 0x3F80) >> 7;
    v50 = 2;
  }
  else
  {
    *v49 = v48;
    v50 = 1;
  }
  v51 = *a2;
  *a2 = (char *)*a2 + v50;
  v51[v50] = *(_BYTE *)(a1 + 36);
  *a2 = (char *)*a2 + 1;
  termIdStoreHeaderStore(a1 + 4960, (_BYTE **)a2);
  storeVInt64((uint64_t *)a2, *(_QWORD *)(a1 + 9632));
  storeVInt64((uint64_t *)a2, *(_QWORD *)(a1 + 9640));
  storeVInt64((uint64_t *)a2, *(_QWORD *)(a1 + 9656));
  storeVInt64((uint64_t *)a2, *(_QWORD *)(a1 + 9664));
  *(_BYTE *)*a2 = 0;
  v52 = (char *)*a2 + 1;
  *a2 = v52;
  *v52 = 0;
  *a2 = (char *)*a2 + 1;
  termIdStoreHeaderStore(a1 + 9672, (_BYTE **)a2);
  v53 = *(_DWORD *)(a1 + 112);
  v54 = *a2;
  if (v53 >> 28)
  {
    *v54 = v53 | 0x80;
    v54[1] = (v53 >> 7) | 0x80;
    v54[2] = (v53 >> 14) | 0x80;
    v54[3] = (v53 >> 21) | 0x80;
    v54[4] = v53 >> 28;
    v55 = 5;
  }
  else if ((v53 & 0xFE00000) != 0)
  {
    *v54 = v53 | 0x80;
    v54[1] = (v53 >> 7) | 0x80;
    v54[2] = (v53 >> 14) | 0x80;
    v54[3] = (v53 & 0xFE00000) >> 21;
    v55 = 4;
  }
  else if ((v53 & 0x1FC000) != 0)
  {
    *v54 = v53 | 0x80;
    v54[1] = (v53 >> 7) | 0x80;
    v54[2] = (v53 & 0x1FC000) >> 14;
    v55 = 3;
  }
  else if ((v53 & 0x3F80) != 0)
  {
    *v54 = v53 | 0x80;
    v54[1] = (unsigned __int16)(v53 & 0x3F80) >> 7;
    v55 = 2;
  }
  else
  {
    *v54 = v53;
    v55 = 1;
  }
  v56 = (char *)*a2 + v55;
  *a2 = v56;
  v57 = *(_QWORD *)(a1 + 120);
  if (v57 >> 28)
  {
    *v56 = v57 | 0x80;
    v56[1] = (v57 >> 7) | 0x80;
    v56[2] = (v57 >> 14) | 0x80;
    v56[3] = (v57 >> 21) | 0x80;
    v56[4] = v57 >> 28;
    v58 = 5;
  }
  else if ((v57 & 0xFE00000) != 0)
  {
    *v56 = v57 | 0x80;
    v56[1] = (v57 >> 7) | 0x80;
    v56[2] = (v57 >> 14) | 0x80;
    v56[3] = (v57 & 0xFE00000) >> 21;
    v58 = 4;
  }
  else if ((v57 & 0x1FC000) != 0)
  {
    *v56 = v57 | 0x80;
    v56[1] = (v57 >> 7) | 0x80;
    v56[2] = (v57 & 0x1FC000) >> 14;
    v58 = 3;
  }
  else if ((v57 & 0x3F80) != 0)
  {
    *v56 = v57 | 0x80;
    v56[1] = (unsigned __int16)(v57 & 0x3F80) >> 7;
    v58 = 2;
  }
  else
  {
    *v56 = v57;
    v58 = 1;
  }
  v59 = (char *)*a2 + v58;
  *a2 = v59;
  v60 = *(_QWORD *)(a1 + 128);
  if (v60 >> 28)
  {
    *v59 = v60 | 0x80;
    v59[1] = (v60 >> 7) | 0x80;
    v59[2] = (v60 >> 14) | 0x80;
    v59[3] = (v60 >> 21) | 0x80;
    v59[4] = v60 >> 28;
    v61 = 5;
  }
  else if ((v60 & 0xFE00000) != 0)
  {
    *v59 = v60 | 0x80;
    v59[1] = (v60 >> 7) | 0x80;
    v59[2] = (v60 >> 14) | 0x80;
    v59[3] = (v60 & 0xFE00000) >> 21;
    v61 = 4;
  }
  else if ((v60 & 0x1FC000) != 0)
  {
    *v59 = v60 | 0x80;
    v59[1] = (v60 >> 7) | 0x80;
    v59[2] = (v60 & 0x1FC000) >> 14;
    v61 = 3;
  }
  else if ((v60 & 0x3F80) != 0)
  {
    *v59 = v60 | 0x80;
    v59[1] = (unsigned __int16)(v60 & 0x3F80) >> 7;
    v61 = 2;
  }
  else
  {
    *v59 = v60;
    v61 = 1;
  }
  v62 = 0;
  v63 = (char *)*a2 + v61;
  *a2 = v63;
  do
  {
    v65 = *(_DWORD *)(a1 + 136 + v62);
    if (v65 >> 28)
    {
      *v63 = v65 | 0x80;
      v63[1] = (v65 >> 7) | 0x80;
      v63[2] = (v65 >> 14) | 0x80;
      v63[3] = (v65 >> 21) | 0x80;
      v63[4] = v65 >> 28;
      v64 = 5;
    }
    else if ((v65 & 0xFE00000) != 0)
    {
      *v63 = v65 | 0x80;
      v63[1] = (v65 >> 7) | 0x80;
      v63[2] = (v65 >> 14) | 0x80;
      v63[3] = (v65 & 0xFE00000) >> 21;
      v64 = 4;
    }
    else if ((v65 & 0x1FC000) != 0)
    {
      *v63 = v65 | 0x80;
      v63[1] = (v65 >> 7) | 0x80;
      v63[2] = (v65 & 0x1FC000) >> 14;
      v64 = 3;
    }
    else if ((v65 & 0x3F80) != 0)
    {
      *v63 = v65 | 0x80;
      v63[1] = (unsigned __int16)(v65 & 0x3F80) >> 7;
      v64 = 2;
    }
    else
    {
      *v63 = v65;
      v64 = 1;
    }
    v62 += 4;
    v63 = (char *)*a2 + v64;
    *a2 = v63;
  }
  while (v62 != 64);
  storageHeaderStore(a1 + 248, (uint64_t *)a2);
  strlcpy((char *)*a2, (const char *)(a1 + 16224), 0x20uLL);
  v66 = strlen((const char *)(a1 + 16224));
  if ((v66 & 0xFFFFFFE0) != 0)
  {
    v81 = __si_assert_copy_extra_2151(0, -1);
    v82 = v81;
    v83 = "";
    if (v81)
      v83 = v81;
    __message_assert("%s:%u: failed assertion '%s' %s ", "JHContentIndex.c", 5059, "len > 0 && len <= 32", v83);
LABEL_191:
    free(v82);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  v67 = (char *)*a2 + (v66 + 1);
  *a2 = v67;
  strlcpy(v67, (const char *)(a1 + 16192), 0x20uLL);
  v68 = strlen((const char *)(a1 + 16192));
  if ((v68 & 0xFFFFFFE0) != 0)
  {
    v84 = __si_assert_copy_extra_2151(0, -1);
    v82 = v84;
    v85 = "";
    if (v84)
      v85 = v84;
    __message_assert("%s:%u: failed assertion '%s' %s ", "JHContentIndex.c", 5065, "len > 0 && len <= 32", v85);
    goto LABEL_191;
  }
  v69 = (char *)*a2 + (v68 + 1);
  *a2 = v69;
  strlcpy(v69, (const char *)sysVersionCStr, 0x20uLL);
  v70 = strlen((const char *)sysVersionCStr);
  if ((v70 & 0xFFFFFFE0) != 0)
  {
    v86 = __si_assert_copy_extra_2151(0, -1);
    v82 = v86;
    v87 = "";
    if (v86)
      v87 = v86;
    __message_assert("%s:%u: failed assertion '%s' %s ", "JHContentIndex.c", 5071, "len > 0 && len <= 32", v87);
    goto LABEL_191;
  }
  v71 = (char *)*a2 + (v70 + 1);
  *a2 = v71;
  strlcpy(v71, (const char *)buildVersionCStr, 0x20uLL);
  v72 = strlen((const char *)buildVersionCStr);
  if ((v72 & 0xFFFFFFE0) != 0)
  {
    v88 = __si_assert_copy_extra_2151(0, -1);
    v82 = v88;
    v89 = "";
    if (v88)
      v89 = v88;
    __message_assert("%s:%u: failed assertion '%s' %s ", "JHContentIndex.c", 5077, "len > 0 && len <= 32", v89);
    goto LABEL_191;
  }
  *a2 = (char *)*a2 + (v72 + 1);
  storeVInt64((uint64_t *)a2, *(_QWORD *)(a1 + 16288));
  *(_QWORD *)(a1 + 16312) = *(_QWORD *)(a1 + 16304);
  *(_OWORD *)(a1 + 16320) = *(_OWORD *)(a1 + 14944);
  v73 = *(_OWORD *)(a1 + 14920);
  *(_QWORD *)(a1 + 16336) = *(_QWORD *)(a1 + 14992);
  *(_OWORD *)(a1 + 16344) = v73;
  *(_QWORD *)(a1 + 16360) = *(_QWORD *)(a1 + 14984);
  *(_QWORD *)(a1 + 16368) = *(_QWORD *)(a1 + 16296);
  *(_QWORD *)(a1 + 16376) = *(_QWORD *)(a1 + 14976);
  v74 = *(_DWORD *)(a1 + 4);
  if (!*(_BYTE *)(a1 + 37))
  {
    if (v74 >= 0x65)
      goto LABEL_88;
LABEL_90:
    v75 = 9;
    goto LABEL_91;
  }
  if (v74 <= 0x71)
    goto LABEL_90;
LABEL_88:
  *(_QWORD *)(a1 + 0x4000) = *(unsigned int *)(a1 + 48);
  v75 = 10;
LABEL_91:
  v76 = (unint64_t *)(a1 + 16312);
  do
  {
    v77 = *v76++;
    result = storeVInt64((uint64_t *)a2, v77);
    --v75;
  }
  while (v75);
  v79 = *a2;
  v80 = *a2 - (_DWORD)v4 + 4;
  *v79 = v80;
  *a2 = v79 + 1;
  v8[2] = v80;
  return result;
}

uint64_t indexCommitShadow(uint64_t a1, _DWORD *a2)
{
  unsigned int v4;
  unsigned int v5;
  _DWORD *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t result;
  char v11;
  char *v12;
  uint64_t v13;
  char __str[1024];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  bzero(__str, 0x400uLL);
  atomic_store(0xC001D00D, (unsigned int *)(a1 + 24));
  *a2 = *(_DWORD *)(a1 + 4);
  v4 = atomic_load((unsigned int *)(a1 + 24));
  a2[1] = v4;
  v5 = atomic_load((unsigned int *)(a1 + 28));
  a2[2] = v5;
  a2[3] = *(_DWORD *)(a1 + 40);
  v6 = *(_DWORD **)(a1 + 14440);
  if (v6)
  {
    v7 = fd_pwrite(*(_QWORD *)(a1 + 14440), (uint64_t)a2, 0x1000uLL, 0);
    if (v7 == -1)
    {
      result = *__error();
      if ((_DWORD)result)
        return result;
    }
    else
    {
      if (v7 != 4096)
        return 0xFFFFFFFFLL;
      v13 = 0;
      v8 = _fd_acquire_fd((uint64_t)v6, &v13);
      if ((_DWORD)v8 != -1)
      {
        v9 = v8;
        prot_fsync(v8, 0);
        _fd_release_fd(v6, v9, 0, v13);
      }
    }
  }
  v11 = atomic_load((unsigned int *)(a1 + 28));
  if ((v11 & 2) == 0)
  {
    snprintf(__str, 0x400uLL, "%s%s", (const char *)(a1 + 15168), "indexUpdates");
    unlinkat(*(_DWORD *)(a1 + 56), __str, 0);
    v12 = (char *)fd_create_protected(*(_DWORD *)(a1 + 56), __str, 536872450, 3u);
    fd_release(v12);
  }
  return 0;
}

uint64_t _indexShadowGroups(uint64_t a1, int a2)
{
  double Current;
  _QWORD *v5;
  uint64_t v6;
  int v7;
  int v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t *v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  off_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unsigned int v25;
  int v26;
  NSObject *v27;
  const char *v28;
  NSObject *v29;
  uint32_t v30;
  unsigned int v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  uint64_t v38;
  int v39;
  _BOOL4 v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  unint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  unint64_t v51;
  uint64_t v52;
  int *v53;
  uint64_t v54;
  BOOL v55;
  uint64_t v56;
  unint64_t v57;
  uint64_t v58;
  unint64_t v59;
  uint64_t v60;
  int *v61;
  uint64_t v62;
  int v63;
  NSObject *v64;
  os_log_type_t v65;
  float v66;
  int *v67;
  uint64_t result;
  NSObject *v69;
  int v70;
  int v71;
  uint64_t v72;
  unint64_t v73;
  unint64_t v74;
  uint64_t v75;
  uint64_t v76;
  unint64_t v77;
  uint64_t v78;
  uint64_t v79;
  _BYTE buf[12];
  __int16 v81;
  int v82;
  __int16 v83;
  int v84;
  __int16 v85;
  _BYTE v86[10];
  __int16 v87;
  char *v88;
  char __str[1024];
  uint64_t v90;

  v90 = *MEMORY[0x1E0C80C00];
  bzero(__str, 0x400uLL);
  Current = CFAbsoluteTimeGetCurrent();
  snprintf(__str, 0x400uLL, "%s%s", (const char *)(a1 + 15168), "shadowIndexGroups");
  v5 = fd_create_protected(*(_DWORD *)(a1 + 56), __str, 536871426, 3u);
  v6 = (uint64_t)v5;
  if (!v5)
  {
    v25 = *__error();
    v26 = *__error();
    v27 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      goto LABEL_82;
    *(_DWORD *)buf = 136315906;
    *(_QWORD *)&buf[4] = "_indexShadowGroups";
    v81 = 1024;
    v82 = 2931;
    v83 = 1024;
    v84 = v25;
    v85 = 2080;
    *(_QWORD *)v86 = __str;
    v28 = "%s:%d: open err: %d, %s";
    v29 = v27;
    v30 = 34;
    goto LABEL_87;
  }
  *(_QWORD *)buf = 0;
  v7 = _fd_acquire_fd((uint64_t)v5, buf);
  if (v7 != -1)
  {
    v8 = v7;
    *(_WORD *)(v6 + 56) |= 1u;
    fcntl(v7, 48, 1);
    fcntl(v8, 76, *(_WORD *)(v6 + 56) & 1);
    _fd_release_fd((_DWORD *)v6, v8, 0, *(uint64_t *)buf);
  }
  v9 = *(_QWORD *)(a1 + 14400);
  if (__THREAD_SLOT_KEY)
  {
    v10 = pthread_getspecific(__THREAD_SLOT_KEY);
    if (v10)
      goto LABEL_6;
  }
  else
  {
    makeThreadId();
    v10 = pthread_getspecific(__THREAD_SLOT_KEY);
    if (v10)
    {
LABEL_6:
      if ((unint64_t)v10 < 0x801)
        goto LABEL_7;
    }
  }
  makeThreadId();
  v10 = pthread_getspecific(__THREAD_SLOT_KEY);
LABEL_7:
  v11 = (uint64_t)v10 - 1;
  v12 = CICleanUpPush((uint64_t)v10 - 1, (uint64_t)fd_release, v6);
  if (!v9)
  {
    v31 = *(_DWORD *)(a1 + 60);
    if (*(_BYTE *)(a1 + 37))
      v32 = v31;
    else
      v32 = (4 * v31 + 4) / 5;
    v33 = fd_pwrite(v6, *(_QWORD *)(a1 + 14392), v32, 0);
    CICleanUpClearItem(v11, v12);
    CICleanUpPop(v11);
    if (v33 == v32)
    {
      v34 = *(unsigned int *)(a1 + 64);
      v35 = (v34 + 4) / 5uLL;
      v36 = (unint64_t)(v34 + 3) >> 2;
      if (*(_BYTE *)(a1 + 37))
        v37 = v36;
      else
        v37 = v35;
      *(_QWORD *)(a1 + 14400) = malloc_type_calloc(1uLL, (8 * *MEMORY[0x1E0C85AD8] - 1 + v37) / (8 * *MEMORY[0x1E0C85AD8]), 0xA8BC8D6EuLL);
      goto LABEL_28;
    }
    if (v33 == -1)
      v25 = *__error();
    else
      v25 = 0;
    v26 = *__error();
    v69 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
      goto LABEL_82;
    *(_DWORD *)buf = 136316418;
    *(_QWORD *)&buf[4] = "_indexShadowGroups";
    v81 = 1024;
    v82 = 2961;
    v83 = 1024;
    v84 = v32;
    v85 = 1024;
    *(_DWORD *)v86 = v33;
    *(_WORD *)&v86[4] = 1024;
    *(_DWORD *)&v86[6] = v25;
    v87 = 2080;
    v88 = __str;
    v28 = "%s:%d: write(%d) %d err: %d, %s";
LABEL_86:
    v29 = v69;
    v30 = 46;
LABEL_87:
    _os_log_error_impl(&dword_1B8270000, v29, OS_LOG_TYPE_ERROR, v28, buf, v30);
    goto LABEL_82;
  }
  v79 = 0;
  v13 = _fd_acquire_fd(v6, &v79);
  v14 = *(unsigned __int8 *)(a1 + 37);
  v15 = *(unsigned int *)(a1 + 60);
  v16 = (uint64_t *)MEMORY[0x1E0C85AD8];
  v17 = 8 * *MEMORY[0x1E0C85AD8];
  v18 = (v15 + 4) / 5uLL;
  if (*(_BYTE *)(a1 + 37))
    v18 = (unint64_t)(v15 + 3) >> 2;
  v19 = v17 - 1 + v18;
  if (v17 > v19)
  {
LABEL_11:
    if (v14)
      v20 = v15;
    else
      v20 = (4 * (int)v15 + 4) / 5u;
    _fd_ftruncate(v13, v20);
    _fd_release_fd((_DWORD *)v6, v13, 0, v79);
    CICleanUpClearItem(v11, v12);
    CICleanUpPop(v11);
    v21 = *(unsigned int *)(a1 + 60);
    v22 = (v21 + 4) / 5uLL;
    v23 = (unint64_t)(v21 + 3) >> 2;
    if (*(_BYTE *)(a1 + 37))
      v24 = v23;
    else
      v24 = v22;
    bzero(*(void **)(a1 + 14400), (8 * *v16 - 1 + v24) / (8 * *v16));
LABEL_28:
    *(_QWORD *)buf = 0;
    v38 = _fd_acquire_fd(v6, buf);
    if ((_DWORD)v38 != -1)
    {
      v39 = v38;
      if (a2)
        v40 = (*(_WORD *)(v6 + 56) & 8) == 0;
      else
        v40 = 0;
      prot_fsync(v38, v40);
      _fd_release_fd((_DWORD *)v6, v39, 0, *(uint64_t *)buf);
    }
    fd_release((char *)v6);
    v63 = *__error();
    v64 = _SILogForLogForCategory(10);
    v65 = 2 * (dword_1EF19FCB4 < 4);
    if (os_log_type_enabled(v64, v65))
    {
      v66 = CFAbsoluteTimeGetCurrent() - Current;
      *(_DWORD *)buf = 134217984;
      *(double *)&buf[4] = v66;
      _os_log_impl(&dword_1B8270000, v64, v65, "shadowIndexGroups took %f seconds", buf, 0xCu);
    }
    v67 = __error();
    result = 0;
    *v67 = v63;
    return result;
  }
  v72 = v11;
  v41 = 0;
  v78 = 4 * *MEMORY[0x1E0C85AD8];
  v73 = v19 / v17;
  v77 = v12;
  while (!*(_BYTE *)(*(_QWORD *)(a1 + 14400) + v41))
  {
LABEL_59:
    if (++v41 == v73)
    {
      v14 = *(unsigned __int8 *)(a1 + 37);
      LODWORD(v15) = *(_DWORD *)(a1 + 60);
      v11 = v72;
      goto LABEL_11;
    }
  }
  v42 = 0;
  v43 = 8 * v41;
  while (1)
  {
    if (((*(char *)(*(_QWORD *)(a1 + 14400) + v41) >> v42) & 1) == 0)
      goto LABEL_35;
    v44 = *v16;
    v45 = v43 + v42;
    v46 = (4 * v45 + 4) * *v16;
    v47 = *(unsigned int *)(a1 + 60);
    if (*(_BYTE *)(a1 + 37))
    {
      if (v46 < v47)
        break;
      goto LABEL_48;
    }
    v47 = (4 * v47 + 4) / 5uLL;
    if (v46 < v47)
      break;
LABEL_48:
    v56 = 4 * v44 * v45;
    v57 = v47 - v56;
    v58 = *(_QWORD *)(a1 + 14392) + v56;
    v74 = v47 - v56;
    v76 = 0;
    do
    {
      while (1)
      {
        v59 = guarded_pwrite_np();
        if ((v59 & 0x8000000000000000) != 0)
          break;
        v62 = v59 + v76;
        v55 = v57 > v59;
        v57 -= v59;
        if (!v55)
          goto LABEL_57;
        v76 += v59;
        v58 += v59;
        v56 += v59;
      }
      v60 = g_prot_error_callback;
      if (!g_prot_error_callback)
        break;
      v61 = __error();
    }
    while (((*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t))(v60 + 16))(v60, v13, *v61, 5) & 1) != 0);
    v62 = -1;
LABEL_57:
    v12 = v77;
    v43 = 8 * v41;
    v16 = (uint64_t *)MEMORY[0x1E0C85AD8];
    if (v62 != v74)
    {
      v70 = v62;
      if (v62 == -1)
        v25 = *__error();
      else
        v25 = 0;
      v26 = *__error();
      v69 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136316418;
        *(_QWORD *)&buf[4] = "_indexShadowGroups";
        v81 = 1024;
        v82 = 2994;
        v83 = 1024;
        v84 = v74;
        v85 = 1024;
        *(_DWORD *)v86 = v70;
        *(_WORD *)&v86[4] = 1024;
        *(_DWORD *)&v86[6] = v25;
        v87 = 2080;
        v88 = __str;
        v28 = "%s:%d: write(%d) %d err: %d, %s";
        goto LABEL_86;
      }
      goto LABEL_82;
    }
LABEL_35:
    if (++v42 == 8)
      goto LABEL_59;
  }
  v75 = 0;
  v48 = 4 * v44 * v45;
  v49 = *(_QWORD *)(a1 + 14392) + v48;
  v50 = v78;
  while (1)
  {
    while (1)
    {
      v51 = guarded_pwrite_np();
      if ((v51 & 0x8000000000000000) == 0)
        break;
      v52 = g_prot_error_callback;
      if (g_prot_error_callback)
      {
        v53 = __error();
        if (((*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t))(v52 + 16))(v52, v13, *v53, 5) & 1) != 0)continue;
      }
      goto LABEL_80;
    }
    v54 = v51 + v75;
    v55 = v50 > v51;
    v50 -= v51;
    if (!v55)
      break;
    v75 += v51;
    v49 += v51;
    v48 += v51;
  }
  v43 = 8 * v41;
  v12 = v77;
  v16 = (uint64_t *)MEMORY[0x1E0C85AD8];
  if (v54 == v78)
    goto LABEL_35;
  if (v54 != -1)
  {
    v71 = v51 + v75;
    v25 = 0;
    goto LABEL_81;
  }
LABEL_80:
  v25 = *__error();
  v71 = -1;
LABEL_81:
  v26 = *__error();
  v69 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136316418;
    *(_QWORD *)&buf[4] = "_indexShadowGroups";
    v81 = 1024;
    v82 = 2983;
    v83 = 1024;
    v84 = v78;
    v85 = 1024;
    *(_DWORD *)v86 = v71;
    *(_WORD *)&v86[4] = 1024;
    *(_DWORD *)&v86[6] = v25;
    v87 = 2080;
    v88 = __str;
    v28 = "%s:%d: write(%d) %d err: %d, %s";
    goto LABEL_86;
  }
LABEL_82:
  *__error() = v26;
  fd_release((char *)v6);
  if (v25)
    return v25;
  else
    return 0xFFFFFFFFLL;
}

uint64_t index_verify(uint64_t a1)
{
  uint64_t v1;
  _DWORD *v2;
  _DWORD *v3;
  __int16 v4;
  __int16 v5;
  uint64_t v6;
  int32_t v7;
  unint64_t v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  void (*v14)(_QWORD);
  int v15;
  int v16;
  NSObject *v17;
  void *v18;
  void *v19;
  uint64_t v20;
  _DWORD *v21;
  _DWORD *v22;
  unsigned int v23;
  uint64_t v24;
  NSObject *v25;
  os_log_type_t v26;
  uint64_t v27;
  char v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  _BOOL4 v35;
  int v36;
  NSObject *v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  int v41;
  uint64_t v42;
  NSObject *v43;
  const char *v44;
  uint64_t v45;
  unsigned int v46;
  uint64_t v47;
  void (*v48)(_QWORD);
  int v49;
  NSObject *v50;
  os_log_type_t v51;
  int v53;
  char *v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  _QWORD v59[3];
  unint64_t v60;
  unsigned int v61;
  unsigned int v62;
  unint64_t v63;
  unsigned int v64;
  unsigned int v65;
  uint8_t buf[4];
  const char *v67;
  __int16 v68;
  int v69;
  __int16 v70;
  uint64_t v71;
  __int16 v72;
  int v73;
  uint64_t v74;

  v1 = MEMORY[0x1E0C80A78](a1);
  v3 = v2;
  v5 = v4;
  v6 = v1;
  v74 = *MEMORY[0x1E0C80C00];
  v7 = OSAtomicIncrement32((int32_t *)exceptionSequenceNum);
  v8 = setThreadIdAndInfo(-1, sAssertExceptionCallbacks, 0, 0, v7);
  v64 = HIDWORD(v8);
  v65 = v8;
  v63 = __PAIR64__(v9, v10);
  v11 = *(_QWORD *)&threadData[18 * v8 + 2];
  v12 = v11 + 320 * HIDWORD(v8);
  v13 = *(_DWORD *)(v12 + 312);
  v14 = *(void (**)(_QWORD))(v12 + 224);
  if (v14)
    v14(*(_QWORD *)(v11 + 320 * HIDWORD(v8) + 288));
  v62 = v65;
  v61 = v64;
  v60 = v63;
  v15 = _setjmp((int *)v12);
  v16 = *__error();
  if (v15)
  {
    v17 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v67 = "index_verify";
      v68 = 1024;
      v69 = 2453;
      _os_log_error_impl(&dword_1B8270000, v17, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
    }
    *__error() = v16;
    *(_DWORD *)(v12 + 312) = v13;
    if (__THREAD_SLOT_KEY)
    {
      v18 = pthread_getspecific(__THREAD_SLOT_KEY);
      if (!v18)
        goto LABEL_63;
    }
    else
    {
      makeThreadId();
      v18 = pthread_getspecific(__THREAD_SLOT_KEY);
      if (!v18)
        goto LABEL_63;
    }
    v19 = v18;
    if ((unint64_t)v18 < 0x801)
    {
LABEL_9:
      v20 = (uint64_t)v19 - 1;
      v21 = &threadData[18 * ((uint64_t)v19 - 1)];
      v23 = v21[14];
      v22 = v21 + 14;
      if (v23 > v60)
      {
        do
          CIOnThreadCleanUpPop(v20);
        while (*v22 > v60);
      }
      dropThreadId(v62, 1, v7);
      CICleanUpReset(v62, HIDWORD(v60));
      v24 = 0xFFFFFFFFLL;
      goto LABEL_57;
    }
LABEL_63:
    makeThreadId();
    v19 = pthread_getspecific(__THREAD_SLOT_KEY);
    goto LABEL_9;
  }
  v25 = _SILogForLogForCategory(10);
  v26 = 2 * (dword_1EF19FCB4 < 4);
  if (os_log_type_enabled(v25, v26))
  {
    *(_DWORD *)buf = 136315138;
    v67 = (const char *)(v6 + 15168);
    _os_log_impl(&dword_1B8270000, v25, v26, "Validating %s", buf, 0xCu);
  }
  *__error() = v16;
  v57 = 0u;
  v58 = 0u;
  v55 = 0u;
  v56 = 0u;
  v59[0] = 0;
  v59[1] = v3;
  DWORD2(v56) = *(_DWORD *)(v6 + 9368);
  *(_QWORD *)&v58 = v6 + 4960;
  *((_QWORD *)&v58 + 1) = v6 + 9672;
  v27 = *(_QWORD *)(v6 + 9656);
  *(_QWORD *)&v57 = *(_QWORD *)(v6 + 4944);
  *((_QWORD *)&v57 + 1) = v27;
  LODWORD(v59[0]) = *(_DWORD *)(v6 + 4664);
  v28 = atomic_load((unsigned int *)(v6 + 28));
  if (v5 < 0 || (v28 & 2) == 0)
  {
    v30 = *(_DWORD *)(v6 + 4664);
    if (v30 == 1)
    {
      if ((v5 & 2) != 0)
      {
        v54 = 0;
        v35 = strtod((const char *)(v6 + 16192), &v54) > 425.0 && v54 != (char *)(v6 + 16192);
        bzero(buf, 0x5160uLL);
        _dumpTrie(v6 + 88, v35, (_DWORD *)v59 + 1, buf, (uint64_t)verifyTermsCallback, (uint64_t)&v55);
      }
    }
    else
    {
      if (v30)
      {
        v36 = *__error();
        v37 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
        {
          v53 = *(_DWORD *)(v6 + 4664);
          *(_DWORD *)buf = 136315906;
          v67 = "index_verify";
          v68 = 1024;
          v69 = 2426;
          v70 = 2080;
          v71 = v6 + 15168;
          v72 = 1024;
          v73 = v53;
          _os_log_error_impl(&dword_1B8270000, v37, OS_LOG_TYPE_ERROR, "%s:%d: %s invalid type %d", buf, 0x22u);
        }
        goto LABEL_53;
      }
      if ((v5 & 1) != 0)
      {
        bzero(buf, 0x5160uLL);
        _dumpTrie(v6 + 88, 1, (_DWORD *)v59 + 1, buf, (uint64_t)verifyTermsCallback, (uint64_t)&v55);
        if (*(int *)(v6 + 5200) >= 1)
        {
          v31 = 0;
          v32 = *(_DWORD *)(v6 + 5200);
          do
          {
            v33 = *(_QWORD *)(v6 + 5224 + 8 * v31);
            if (v33 && *(_QWORD *)(v33 + 8))
            {
              msync(*(void **)(v33 + 8), *(_QWORD *)(v33 + 24) - *(_QWORD *)(v33 + 16), 16);
              madvise(*(void **)(v33 + 8), *(_QWORD *)(v33 + 24) - *(_QWORD *)(v33 + 16), 4);
              v32 = *(_DWORD *)(v6 + 5200);
            }
            ++v31;
          }
          while (v31 < v32);
        }
        if (*(int *)(v6 + 9912) >= 1)
        {
          v38 = 0;
          v39 = *(_DWORD *)(v6 + 9912);
          do
          {
            v40 = *(_QWORD *)(v6 + 9936 + 8 * v38);
            if (v40 && *(_QWORD *)(v40 + 8))
            {
              msync(*(void **)(v40 + 8), *(_QWORD *)(v40 + 24) - *(_QWORD *)(v40 + 16), 16);
              madvise(*(void **)(v40 + 8), *(_QWORD *)(v40 + 24) - *(_QWORD *)(v40 + 16), 4);
              v39 = *(_DWORD *)(v6 + 9912);
            }
            ++v38;
          }
          while (v38 < v39);
        }
      }
    }
    v41 = HIDWORD(v59[0]);
    if (HIDWORD(v59[0]) && !*v3)
    {
      v36 = *__error();
      v43 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
        goto LABEL_53;
      *(_DWORD *)buf = 136315650;
      v67 = "index_verify";
      v68 = 1024;
      v69 = 2430;
      v70 = 2080;
      v71 = v6 + 15168;
      v44 = "%s:%d: %s error walking terms";
    }
    else
    {
      v42 = *(_QWORD *)(v6 + 4904);
      if (v42)
      {
        dumpDirectoryStore(v42);
        v41 = HIDWORD(v59[0]);
      }
      if (!v41 || *v3)
      {
        v29 = 0;
        goto LABEL_54;
      }
      v36 = *__error();
      v43 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
      {
LABEL_53:
        *__error() = v36;
        v29 = 0xFFFFFFFFLL;
        goto LABEL_54;
      }
      *(_DWORD *)buf = 136315650;
      v67 = "index_verify";
      v68 = 1024;
      v69 = 2446;
      v70 = 2080;
      v71 = v6 + 15168;
      v44 = "%s:%d: %s error walking directoyr store";
    }
    _os_log_error_impl(&dword_1B8270000, v43, OS_LOG_TYPE_ERROR, v44, buf, 0x1Cu);
    goto LABEL_53;
  }
  v29 = 0;
LABEL_54:
  v45 = *(_QWORD *)&threadData[18 * v62 + 2];
  v46 = v61;
  v47 = v45 + 320 * v61;
  *(_DWORD *)(v47 + 312) = v13;
  v48 = *(void (**)(_QWORD))(v47 + 232);
  if (v48)
    v48(*(_QWORD *)(v45 + 320 * v46 + 288));
  dropThreadId(v62, 0, v7);
  v24 = v29;
LABEL_57:
  v49 = *__error();
  v50 = _SILogForLogForCategory(10);
  v51 = 2 * (dword_1EF19FCB4 < 4);
  if (os_log_type_enabled(v50, v51))
  {
    *(_DWORD *)buf = 136315394;
    v67 = (const char *)(v6 + 15168);
    v68 = 1024;
    v69 = v24;
    _os_log_impl(&dword_1B8270000, v50, v51, "Validate %s complete %d", buf, 0x12u);
  }
  *__error() = v49;
  return v24;
}

_DWORD *verifyTermsCallback(_DWORD *result, uint64_t a2, unint64_t a3, unint64_t a4, uint64_t a5)
{
  int v6;
  int v7;
  NSObject *v8;
  const char *v9;
  NSObject *v10;
  uint32_t v11;
  unint64_t v12;
  unsigned int v14;
  unint64_t v15;
  NSObject *v16;
  int v17;
  NSObject *v18;
  int v19;
  NSObject *v20;
  uint64_t v21;
  const char *v22;
  NSObject *v23;
  uint64_t v24;
  int v25;
  const char *v26;
  __int16 v27;
  int v28;
  __int16 v29;
  _BYTE v30[10];
  uint64_t v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  if (**(_DWORD **)(a5 + 72))
    goto LABEL_21;
  v6 = (int)result;
  if (((_DWORD)result - 1044) <= 0xFFFFFBEC)
  {
    v7 = *__error();
    v8 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      v25 = 136315650;
      v26 = "verifyTermsCallback";
      v27 = 1024;
      v28 = 2324;
      v29 = 1024;
      *(_DWORD *)v30 = v6;
      v9 = "%s:%d: invalid term length: %d";
      v10 = v8;
      v11 = 24;
LABEL_26:
      _os_log_error_impl(&dword_1B8270000, v10, OS_LOG_TYPE_ERROR, v9, (uint8_t *)&v25, v11);
      goto LABEL_20;
    }
    goto LABEL_20;
  }
  v12 = a3;
  if (*(_DWORD *)(a5 + 64))
  {
    v14 = *(_DWORD *)a5 + 1;
    if (*(_DWORD *)a5 == -1)
    {
LABEL_19:
      v7 = *__error();
      v16 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        v19 = *(_DWORD *)(a5 + 24);
        v25 = 136315906;
        v26 = "verifyTermsCallback";
        v27 = 1024;
        v28 = 2353;
        v29 = 1024;
        *(_DWORD *)v30 = v14;
        *(_WORD *)&v30[4] = 1024;
        *(_DWORD *)&v30[6] = v19;
        v9 = "%s:%d: invalid termID: %d, max: %d";
        v10 = v16;
        v11 = 30;
        goto LABEL_26;
      }
LABEL_20:
      result = __error();
      *result = v7;
LABEL_21:
      *(_DWORD *)(a5 + 68) = 1;
      return result;
    }
  }
  else
  {
    v15 = *(_QWORD *)storageResolvePtr(*(_QWORD *)(a5 + 48), 8 * a3, 8uLL, 1);
    result = storageResolvePtr(*(_QWORD *)(a5 + 56), 8 * v12, 8uLL, 1);
    a4 = *(_QWORD *)result;
    v14 = v12;
    v12 = v15;
    if (!v14)
      goto LABEL_19;
  }
  if (v14 >= *(_DWORD *)(a5 + 24))
    goto LABEL_19;
  if (!v12 || v12 >= *(_QWORD *)(a5 + 32))
  {
    v17 = *__error();
    v18 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      v24 = *(_QWORD *)(a5 + 32);
      v25 = 136315906;
      v26 = "verifyTermsCallback";
      v27 = 1024;
      v28 = 2358;
      v29 = 2048;
      *(_QWORD *)v30 = v12;
      *(_WORD *)&v30[8] = 2048;
      v31 = v24;
      v22 = "%s:%d: invalid posting offset: %lld, max: %lld";
      v23 = v18;
      goto LABEL_30;
    }
LABEL_24:
    result = __error();
    *result = v17;
    goto LABEL_21;
  }
  if (v12 > *(_QWORD *)(a5 + 8))
    *(_QWORD *)(a5 + 8) = v12;
  if (a4 && a4 >= *(_QWORD *)(a5 + 40))
  {
    v17 = *__error();
    v20 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      v21 = *(_QWORD *)(a5 + 40);
      v25 = 136315906;
      v26 = "verifyTermsCallback";
      v27 = 1024;
      v28 = 2368;
      v29 = 2048;
      *(_QWORD *)v30 = a4;
      *(_WORD *)&v30[8] = 2048;
      v31 = v21;
      v22 = "%s:%d: invalid position offset: %lld, max: %lld";
      v23 = v20;
LABEL_30:
      _os_log_error_impl(&dword_1B8270000, v23, OS_LOG_TYPE_ERROR, v22, (uint8_t *)&v25, 0x26u);
      goto LABEL_24;
    }
    goto LABEL_24;
  }
  if (a4 > *(_QWORD *)(a5 + 16))
    *(_QWORD *)(a5 + 16) = a4;
  ++*(_DWORD *)a5;
  return result;
}

BOOL __index_verify_block_invoke(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  unsigned int v5;
  int v10;
  NSObject *v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  __int16 v15;
  int v16;
  __int16 v17;
  uint64_t v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v5 = a2 - 1;
  if (a2 >= 1 && gSILogLevels[0] >= 5)
  {
    v10 = *__error();
    v11 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      v12 = *(_QWORD *)(a3 + 8 * v5);
      v13 = 134218496;
      v14 = v12;
      v15 = 1024;
      v16 = a2;
      v17 = 2048;
      v18 = a4;
      _os_log_impl(&dword_1B8270000, v11, OS_LOG_TYPE_DEFAULT, "oid: %lld depth: %d offset: %llu ", (uint8_t *)&v13, 0x1Cu);
    }
    *__error() = v10;
  }
  return **(_DWORD **)(a1 + 32) != 0;
}

uint64_t indexPerformSync(uint64_t a1)
{
  uint64_t v1;
  int v2;
  int v3;
  uint64_t v4;
  _BYTE *v5;
  _BYTE *v6;
  uint64_t v7;
  unsigned int v8;
  size_t v9;
  _DWORD *v10;
  uint64_t v11;
  int v12;
  char v13;
  uint64_t result;
  unsigned int v15;
  int v16;
  void *v17;
  int v18;
  uint64_t v19;
  int v20;
  uint64_t *v21;
  uint64_t v22[513];

  v1 = MEMORY[0x1E0C80A78](a1);
  v3 = v2;
  v4 = v1;
  v22[512] = *MEMORY[0x1E0C80C00];
  v5 = (_BYTE *)(v1 + 15163);
  v6 = *(_BYTE **)(v1 + 4904);
  if (v6)
    flushForwardStore(v6, *(_QWORD *)(v4 + 16304));
  v7 = *(_QWORD *)(v4 + 4896);
  if (v7)
    IVFVectorIndex_s::flush((_QWORD *)(v7 + 8), *(_QWORD *)(v4 + 16304));
  if (*v5)
    return 0;
  v8 = *(_DWORD *)(v4 + 60);
  if (*(_BYTE *)(v4 + 37))
    v9 = v8;
  else
    v9 = (4 * v8 + 4) / 5;
  msync(*(void **)(v4 + 14392), v9, 16);
  v10 = *(_DWORD **)(v4 + 14432);
  v22[0] = 0;
  v11 = _fd_acquire_fd((uint64_t)v10, v22);
  if ((_DWORD)v11 != -1)
  {
    v12 = v11;
    prot_fsync(v11, 0);
    _fd_release_fd(v10, v12, 0, v22[0]);
  }
  v13 = atomic_load((unsigned int *)(v4 + 28));
  if ((v13 & 2) != 0)
    return 0;
  result = syncPayload(v4 + 4920);
  if (!(_DWORD)result)
  {
    result = syncPayload(v4 + 9632);
    if (!(_DWORD)result)
    {
      result = bt_syncTrie(v4 + 88);
      if (!(_DWORD)result)
      {
        v15 = msync(*(void **)(v4 + 14368), 8 * *(unsigned int *)(v4 + 60), 16);
        v16 = msync(*(void **)(v4 + 14376), 4 * *(unsigned int *)(v4 + 60), 16);
        if (v16)
          v15 = v16;
        v17 = *(void **)(v4 + 14384);
        if (v17)
        {
          v18 = msync(v17, 8 * *(unsigned int *)(v4 + 60), 16);
          if (v18)
            v15 = v18;
        }
        if (v5[2])
        {
          if (fd_sync(*(_QWORD *)(v4 + 14416), 0))
            v15 = *__error();
          v19 = *(_QWORD *)(v4 + 14424);
          if (v19 && fd_sync(v19, 0))
            v15 = *__error();
          if (fd_sync(*(_QWORD *)(v4 + 14408), 0))
            v15 = *__error();
          v5[2] = 0;
        }
        if (v3)
        {
          v20 = *(_DWORD *)(v4 + 60);
          if (v20)
          {
            *(_QWORD *)(v4 + 4936) = *(_QWORD *)(v4 + 4928);
            *(_QWORD *)(v4 + 9648) = *(_QWORD *)(v4 + 9640);
            *(_DWORD *)(v4 + 52) = v20 - 1;
          }
        }
        bzero(v22, 0x1000uLL);
        v21 = v22;
        indexStoreToBuffer(v4, (void **)&v21);
        LODWORD(result) = index_header_write(*(_QWORD *)(v4 + 14440), (uint64_t)v22);
        if ((_DWORD)result)
          return result;
        else
          return v15;
      }
    }
  }
  return result;
}

uint64_t index_header_write(uint64_t result, uint64_t a2)
{
  _DWORD *v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  uint64_t v6;

  if (result)
  {
    v2 = (_DWORD *)result;
    v3 = fd_pwrite(result, a2, 0x1000uLL, 0);
    if (v3 == 4096)
    {
      v6 = 0;
      v4 = _fd_acquire_fd((uint64_t)v2, &v6);
      if ((_DWORD)v4 != -1)
      {
        v5 = v4;
        prot_fsync(v4, 0);
        _fd_release_fd(v2, v5, 0, v6);
      }
      return 0;
    }
    else if (v3 == -1)
    {
      return *__error();
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t recoverIndex(uint64_t a1)
{
  uint64_t v1;
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  _DWORD *v10;
  _DWORD *v11;
  const char *v12;
  const char *v13;
  uint64_t v14;
  int v15;
  NSObject *v16;
  os_log_type_t v17;
  int v18;
  NSObject *v19;
  const char *v20;
  char *v21;
  int *v22;
  char *v23;
  int v24;
  NSObject *v25;
  os_log_type_t v26;
  uint64_t v27;
  char *v29;
  uint64_t v30;
  char v31;
  unsigned int v32;
  int v33;
  NSObject *v34;
  char *v35;
  uint64_t v36;
  char *v37;
  NSObject *v38;
  os_log_type_t v39;
  int v40;
  int v41;
  NSObject *v42;
  os_log_type_t v43;
  int v44;
  int v45;
  NSObject *v46;
  const char *v47;
  char *v48;
  int v49;
  int v50;
  NSObject *v51;
  const char *v52;
  NSObject *v53;
  int v54;
  int v55;
  int v56;
  NSObject *v57;
  NSObject *v58;
  uint32_t v59;
  int v60;
  NSObject *v61;
  int v62;
  int v63;
  uint64_t v64;
  unsigned int *v65;
  stat v66;
  char __str[4];
  const char *v68;
  __int16 v69;
  int v70;
  __int16 v71;
  const char *v72;
  __int16 v73;
  int v74;
  __int16 v75;
  int v76;
  uint8_t buf[4];
  const char *v78;
  __int16 v79;
  int v80;
  __int16 v81;
  const char *v82;
  unsigned int v83[4107];
  _DWORD v84[1024];
  char v85[1024];
  char v86[1024];
  uint64_t v87;

  v1 = MEMORY[0x1E0C80A78](a1);
  v3 = v2;
  v5 = v4;
  v7 = v6;
  v9 = v8;
  v11 = v10;
  v13 = v12;
  v14 = v1;
  v87 = *MEMORY[0x1E0C80C00];
  bzero(v86, 0x400uLL);
  bzero(v85, 0x400uLL);
  memset(&v66, 0, sizeof(v66));
  v15 = *__error();
  v16 = _SILogForLogForCategory(0);
  v17 = 2 * (gSILogLevels[0] < 4);
  if (os_log_type_enabled(v16, v17))
  {
    *(_DWORD *)buf = 136315138;
    v78 = v13;
    _os_log_impl(&dword_1B8270000, v16, v17, "recoverIndex: %s", buf, 0xCu);
  }
  *__error() = v15;
  bzero(v84, 0x1000uLL);
  v65 = v84;
  snprintf(v86, 0x400uLL, "%s%s", v13, "indexPostings");
  if (stat(v86, &v66))
  {
    v18 = *__error();
    v19 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315650;
      v78 = "recoverIndex";
      v79 = 1024;
      v80 = 3401;
      v81 = 2080;
      v82 = v13;
      v20 = "%s:%d: Unrecoverable error: Missing postings file (%s)";
LABEL_46:
      _os_log_error_impl(&dword_1B8270000, v19, OS_LOG_TYPE_ERROR, v20, buf, 0x1Cu);
      goto LABEL_8;
    }
    goto LABEL_8;
  }
  snprintf(v86, 0x400uLL, "%s%s", v13, "indexPositions");
  if (stat(v86, &v66))
  {
    v18 = *__error();
    v19 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315650;
      v78 = "recoverIndex";
      v79 = 1024;
      v80 = 3408;
      v81 = 2080;
      v82 = v13;
      v20 = "%s:%d: Unrecoverable error: Missing positions file (%s)";
      goto LABEL_46;
    }
LABEL_8:
    v21 = 0;
LABEL_9:
    v22 = __error();
    v23 = 0;
LABEL_10:
    *v22 = v18;
    goto LABEL_11;
  }
  snprintf(v85, 0x400uLL, "%s%s", v13, "shadowIndexHead");
  v29 = (char *)fd_create_protected(v14, v85, 536870914, 3u);
  if (!v29)
  {
    v18 = *__error();
    v38 = _SILogForLogForCategory(0);
    v39 = gSILogLevels[0] < 3;
    if (os_log_type_enabled(v38, (os_log_type_t)(gSILogLevels[0] < 3)))
    {
      v40 = *__error();
      *(_DWORD *)buf = 136315394;
      v78 = v13;
      v79 = 1024;
      v80 = v40;
      _os_log_impl(&dword_1B8270000, v38, v39, "*warn* Unrecoverable error: Missing shadow head file (%s) %d", buf, 0x12u);
    }
    goto LABEL_8;
  }
  v21 = v29;
  v30 = fd_pread(v29, v84, 0x1000uLL, 0);
  if (v30 != 4096)
  {
    v41 = v30;
    v18 = *__error();
    v42 = _SILogForLogForCategory(0);
    v43 = gSILogLevels[0] < 3;
    if (os_log_type_enabled(v42, (os_log_type_t)(gSILogLevels[0] < 3)))
    {
      v44 = *__error();
      *(_DWORD *)buf = 136315650;
      v78 = v13;
      v79 = 1024;
      v80 = v41;
      v81 = 1024;
      LODWORD(v82) = v44;
      _os_log_impl(&dword_1B8270000, v42, v43, "*warn* Unrecoverable error: Missing data in index head file (%s) %d %d", buf, 0x18u);
    }
    goto LABEL_9;
  }
  fd_release(v21);
  bzero(buf, 0x4040uLL);
  if ((indexRestoreHeaderFromBuffer(buf, &v65, v7, v5, v3, 0) & 1) == 0)
  {
    v45 = *__error();
    v46 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
      goto LABEL_44;
    *(_DWORD *)__str = 136315650;
    v68 = "recoverIndex";
    v69 = 1024;
    v70 = 3431;
    v71 = 2080;
    v72 = v13;
    v47 = "%s:%d: Unrecoverable error: Malformed index head file (%s)";
LABEL_71:
    v58 = v46;
    v59 = 28;
LABEL_72:
    _os_log_error_impl(&dword_1B8270000, v58, OS_LOG_TYPE_ERROR, v47, (uint8_t *)__str, v59);
    goto LABEL_44;
  }
  v31 = atomic_load(v83);
  if ((v31 & 2) != 0)
    goto LABEL_24;
  bzero(__str, 0x400uLL);
  snprintf(__str, 0x400uLL, "%s%s", v13, "indexDirectory");
  if (fstatat(v14, __str, &v66, 0) || v66.st_mode != 256)
  {
    v65 = v84;
    snprintf(v86, 0x400uLL, "%s%s", v13, "indexUpdates");
    unlinkat(v14, v86, 0);
    v48 = (char *)fd_create_protected(v14, v86, 536872450, 3u);
    v64 = 0;
    v49 = _fd_acquire_fd((uint64_t)v48, &v64);
    _fd_release_fd(v48, v49, 0, v64);
    fd_release(v48);
    if (v49 == -1)
    {
      v50 = *__error();
      v51 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__str = 136315650;
        v68 = "recoverIndex";
        v69 = 1024;
        v70 = 3462;
        v71 = 2080;
        v72 = v13;
        v52 = "%s:%d: Unrecoverable error: could not open update file (%s)";
        goto LABEL_76;
      }
    }
    else
    {
      snprintf(v86, 0x400uLL, "%s%s", v13, "indexTermIds");
      snprintf(v85, 0x400uLL, "%s%s", v13, "shadowIndexTermIds");
      if ((copyFileFallback(v14, v85, v14, v86, v11, 1, 1) & 1) != 0)
      {
        snprintf(v86, 0x400uLL, "%s%s", v13, "indexPositionTable");
        snprintf(v85, 0x400uLL, "%s%s", v13, "shadowIndexPositionTable");
        if ((copyFileFallback(v14, v85, v14, v86, v11, 1, 1) & 1) != 0)
        {
          if ((bt_recoverTrie(v14, v13, v11) & 1) != 0)
            goto LABEL_25;
          if (*v11)
            goto LABEL_78;
          v50 = *__error();
          v51 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)__str = 136315650;
            v68 = "recoverIndex";
            v69 = 1024;
            v70 = 3483;
            v71 = 2080;
            v72 = v13;
            v52 = "%s:%d: Unrecoverable error: could not recover term index (%s)";
LABEL_76:
            _os_log_error_impl(&dword_1B8270000, v51, OS_LOG_TYPE_ERROR, v52, (uint8_t *)__str, 0x1Cu);
          }
        }
        else
        {
          if (*v11)
            goto LABEL_78;
          v50 = *__error();
          v51 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)__str = 136315650;
            v68 = "recoverIndex";
            v69 = 1024;
            v70 = 3477;
            v71 = 2080;
            v72 = v13;
            v52 = "%s:%d: Unrecoverable error: could not recover term id file (positions) (%s)";
            goto LABEL_76;
          }
        }
      }
      else
      {
        if (*v11)
          goto LABEL_78;
        v50 = *__error();
        v51 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)__str = 136315650;
          v68 = "recoverIndex";
          v69 = 1024;
          v70 = 3469;
          v71 = 2080;
          v72 = v13;
          v52 = "%s:%d: Unrecoverable error: could not recover term id file (%s)";
          goto LABEL_76;
        }
      }
    }
    *__error() = v50;
    goto LABEL_78;
  }
  do
    v32 = __ldaxr(v83);
  while (__stlxr(v32 | 2, v83));
LABEL_24:
  v65 = v84;
LABEL_25:
  if (v9 && (recoverForwardStore(v14, v13, v11) & 1) == 0)
  {
    if (!*v11)
    {
      v45 = *__error();
      v46 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
        goto LABEL_44;
      *(_DWORD *)__str = 136315650;
      v68 = "recoverIndex";
      v69 = 1024;
      v70 = 3490;
      v71 = 2080;
      v72 = v13;
      v47 = "%s:%d: Unrecoverable error: could not recover path index (%s)";
      goto LABEL_71;
    }
  }
  else
  {
    if (_os_feature_enabled_impl() && !recoverVectorIndex(v14, v13, (uint64_t)v11) && !*v11)
    {
      v33 = *__error();
      v34 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__str = 136315650;
        v68 = "recoverIndex";
        v69 = 1024;
        v70 = 3498;
        v71 = 2080;
        v72 = v13;
        _os_log_error_impl(&dword_1B8270000, v34, OS_LOG_TYPE_ERROR, "%s:%d: error: could not recover vector index (%s)", (uint8_t *)__str, 0x1Cu);
      }
      *__error() = v33;
    }
    snprintf(v86, 0x400uLL, "%s%s", v13, "indexGroups");
    snprintf(v85, 0x400uLL, "%s%s", v13, "shadowIndexGroups");
    if ((copyFileFallback(v14, v85, v14, v86, v11, 1, 1) & 1) != 0)
    {
      snprintf(v86, 0x400uLL, "%s%s", v13, "indexHead");
      snprintf(v85, 0x400uLL, "%s%s", v13, "shadowIndexHead");
      v35 = (char *)fd_create_protected(v14, v85, 536870914, 0);
      if (v35)
      {
        v21 = v35;
        v36 = fd_pread(v35, v84, 0x1000uLL, 0);
        if (v36 != 4096)
        {
          v55 = v36;
          v56 = *__error();
          v57 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
          {
            v62 = *__error();
            *(_DWORD *)__str = 136316162;
            v68 = "recoverIndex";
            v69 = 1024;
            v70 = 3523;
            v71 = 2080;
            v72 = v13;
            v73 = 1024;
            v74 = v55;
            v75 = 1024;
            v76 = v62;
            _os_log_error_impl(&dword_1B8270000, v57, OS_LOG_TYPE_ERROR, "%s:%d: Unrecoverable error: could not read shadow head file (%s) %d, %d", (uint8_t *)__str, 0x28u);
          }
          v23 = 0;
          *__error() = v56;
          goto LABEL_11;
        }
        fd_release(v21);
        v84[0] = v7;
        v84[1] = 1;
        v37 = (char *)fd_create_protected(v14, v86, 536872450, 0);
        if (v37)
        {
          v23 = v37;
          if (fd_pwrite((uint64_t)v37, (uint64_t)v84, 0x1000uLL, 0) != -1)
          {
            v27 = 1;
            fd_sync((uint64_t)v23, 1);
            v21 = 0;
            goto LABEL_16;
          }
          v18 = *__error();
          v61 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
          {
            v63 = *__error();
            *(_DWORD *)__str = 136315906;
            v68 = "recoverIndex";
            v69 = 1024;
            v70 = 3538;
            v71 = 2080;
            v72 = v13;
            v73 = 1024;
            v74 = v63;
            _os_log_error_impl(&dword_1B8270000, v61, OS_LOG_TYPE_ERROR, "%s:%d: Unrecoverable error: could not write index head file (%s) %d", (uint8_t *)__str, 0x22u);
          }
          v22 = __error();
          v21 = 0;
          goto LABEL_10;
        }
        v45 = *__error();
        v53 = _SILogForLogForCategory(0);
        if (!os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
          goto LABEL_44;
        v60 = *__error();
        *(_DWORD *)__str = 136315906;
        v68 = "recoverIndex";
        v69 = 1024;
        v70 = 3534;
        v71 = 2080;
        v72 = v13;
        v73 = 1024;
        v74 = v60;
        v47 = "%s:%d: Unrecoverable error: could not open index head file (%s) %d";
        goto LABEL_81;
      }
      v45 = *__error();
      v53 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
      {
        v54 = *__error();
        *(_DWORD *)__str = 136315906;
        v68 = "recoverIndex";
        v69 = 1024;
        v70 = 3517;
        v71 = 2080;
        v72 = v13;
        v73 = 1024;
        v74 = v54;
        v47 = "%s:%d: Unrecoverable error: could not open shadow head file (%s) %d";
LABEL_81:
        v58 = v53;
        v59 = 34;
        goto LABEL_72;
      }
LABEL_44:
      v23 = 0;
      v21 = 0;
      *__error() = v45;
      goto LABEL_11;
    }
    if (!*v11)
    {
      v45 = *__error();
      v46 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
        goto LABEL_44;
      *(_DWORD *)__str = 136315650;
      v68 = "recoverIndex";
      v69 = 1024;
      v70 = 3507;
      v71 = 2080;
      v72 = v13;
      v47 = "%s:%d: Unrecoverable error: could not recover groups file (%s)";
      goto LABEL_71;
    }
  }
LABEL_78:
  v23 = 0;
  v21 = 0;
LABEL_11:
  if (*v11)
  {
    v24 = *__error();
    v25 = _SILogForLogForCategory(0);
    v26 = gSILogLevels[0] < 3;
    if (os_log_type_enabled(v25, (os_log_type_t)(gSILogLevels[0] < 3)))
    {
      *(_DWORD *)buf = 136315138;
      v78 = v13;
      _os_log_impl(&dword_1B8270000, v25, v26, "*warn* recover canceled (%s)", buf, 0xCu);
    }
    v27 = 0;
    *__error() = v24;
  }
  else
  {
    v27 = 0;
  }
LABEL_16:
  fd_release(v21);
  fd_release(v23);
  return v27;
}

uint64_t index_calculate_size(uint64_t a1, char a2)
{
  char v3;
  char v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  BOOL v14;
  unsigned int *v15;
  char v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int *v28;
  unsigned int v29;
  int v30;
  int v31;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  uint64_t v37;

  v3 = atomic_load((unsigned int *)(a1 + 28));
  v4 = atomic_load((unsigned int *)(a1 + 28));
  v5 = 4096;
  if ((a2 & 2) != 0)
    v5 = 0x2000;
  v6 = 64;
  if ((v3 & 4) != 0)
    v6 = 60;
  v7 = *(unsigned int *)(a1 + v6);
  if (*(_BYTE *)(a1 + 37))
  {
    v8 = v5 + v7;
    v9 = v7;
    if ((a2 & 2) == 0)
      goto LABEL_8;
    goto LABEL_7;
  }
  v9 = ((unint64_t)(4 * v7 + 4) * (unsigned __int128)0x3333333333333334uLL) >> 64;
  v8 = v9 + v5;
  if ((a2 & 2) != 0)
LABEL_7:
    v8 += v9;
LABEL_8:
  v10 = v8 + 8 * v7 + *(_QWORD *)(a1 + 4944);
  if ((v3 & 4) == 0)
  {
    v11 = 8 * *(unsigned int *)(a1 + 9372);
    v10 += v11;
    if ((a2 & 2) == 0)
      v11 = 0;
    v12 = v10 + v11;
    if ((v4 & 1) == 0)
      v10 = v12;
  }
  if ((a2 & 1) != 0)
    v10 += 28 * *(unsigned int *)(a1 + 9368);
  v13 = *(_QWORD *)(a1 + 9656) + v10;
  v14 = (a2 & 2) == 0;
  if ((v3 & 4) != 0)
  {
    v15 = (unsigned int *)(a1 + 232);
    v16 = v14 | v4;
  }
  else
  {
    v16 = v14 | v4;
    if ((v16 & 1) != 0)
      v17 = 0;
    else
      v17 = 8 * *(unsigned int *)(a1 + 14084);
    v13 += 8 * *(unsigned int *)(a1 + 14084) + v17;
    v15 = (unsigned int *)(a1 + 236);
  }
  v18 = 1028 * *v15 + 1028;
  v19 = 128;
  if ((v3 & 4) != 0)
    v19 = 120;
  v20 = 472;
  if ((v3 & 4) != 0)
    v20 = 480;
  v21 = *(_QWORD *)(a1 + v19);
  if ((v16 & 1) != 0)
    v22 = 0;
  else
    v22 = v18;
  if ((v16 & 1) != 0)
    v23 = 0;
  else
    v23 = v21;
  v24 = *(_QWORD *)(a1 + v20);
  if ((v16 & 1) != 0)
    v25 = 0;
  else
    v25 = v24;
  v26 = v21 + v18 + v22 + v24 + v25 + v13 + v23;
  v27 = *(_QWORD *)(a1 + 4904);
  if (v27)
  {
    v26 += *(_QWORD *)(v27 + 232);
    if ((v16 & 1) == 0)
      v26 += *(_QWORD *)(v27 + 240);
  }
  if ((a2 & 4) != 0 && (v3 & 4) == 0 && (v4 & 1) == 0)
  {
    db_read_lock(a1 + 14680);
    v28 = *(unsigned int **)(a1 + 14352);
    if (v28)
    {
      do
        v29 = __ldaxr(v28);
      while (__stlxr(v29 + 1, v28));
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 14680));
      v30 = *(_DWORD *)(a1 + 14876) - 1;
      *(_DWORD *)(a1 + 14876) = v30;
      if (!v30)
        db_rwlock_wakeup(a1 + 14680, 0, 0);
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 14680));
      v37 = 0;
      v35 = 0u;
      v36 = 0u;
      v33 = 0u;
      v34 = 0u;
      _TermUpdateSetGetStats((uint64_t)v28, (uint64_t)&v33, 0);
      TermUpdateSetRelease((uint64_t)v28);
      v26 += v33 + v34 + v35;
    }
    else
    {
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 14680));
      v31 = *(_DWORD *)(a1 + 14876) - 1;
      *(_DWORD *)(a1 + 14876) = v31;
      if (!v31)
        db_rwlock_wakeup(a1 + 14680, 0, 0);
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 14680));
    }
  }
  return v26;
}

BOOL indexClosing(uint64_t a1)
{
  unsigned int *v1;
  unsigned int v2;
  int v4;
  NSObject *v5;
  uint8_t v6[16];

  v1 = (unsigned int *)(a1 + 15152);
  do
    v2 = __ldaxr(v1);
  while (__stlxr(v2 | 1, v1));
  if (!v2)
  {
    *(CFAbsoluteTime *)(a1 + 15008) = CFAbsoluteTimeGetCurrent();
    if (gSILogLevels[0] >= 5)
    {
      v4 = *__error();
      v5 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)v6 = 0;
        _os_log_impl(&dword_1B8270000, v5, OS_LOG_TYPE_DEFAULT, "close requested\n", v6, 2u);
      }
      *__error() = v4;
    }
  }
  return v2 != 0;
}

uint64_t si_rwlock_wrunlock_2447(uint64_t a1)
{
  uint64_t v2;
  pthread_override_s *v3;
  char v4;

  v2 = pthread_mutex_lock((pthread_mutex_t *)a1);
  *(_DWORD *)(a1 + 204) = 0;
  v3 = *(pthread_override_s **)(a1 + 176);
  *(_QWORD *)(a1 + 176) = 0;
  *(_QWORD *)(a1 + 184) = 0;
  v4 = *(_DWORD *)(a1 + 196) != 0;
  *(_BYTE *)(a1 + 212) = 0;
  db_rwlock_wakeup(a1, v4, 0);
  pthread_mutex_unlock((pthread_mutex_t *)a1);
  if (v3)
    pthread_override_qos_class_end_np(v3);
  return v2;
}

uint64_t indexGrowDocumentPayloads(uint64_t a1, uint64_t (*a2)(uint64_t), uint64_t a3)
{
  unint64_t v6;
  uint64_t v7;
  int v8;
  NSObject *v9;
  uint64_t v10;
  size_t v11;
  size_t v12;
  size_t v13;
  size_t v14;
  size_t v15;
  int v16;
  NSObject *v17;
  void *v18;
  _QWORD *v19;
  unint64_t v20;
  char *v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  int v25;
  NSObject *v26;
  size_t v27;
  uint64_t v28;
  int v29;
  NSObject *v30;
  size_t v32;
  uint8_t buf[4];
  const char *v34;
  __int16 v35;
  int v36;
  __int16 v37;
  uint64_t v38;
  __int16 v39;
  int v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)(a1 + 8))
    return 0xFFFFFFFFLL;
  v32 = 0;
  v6 = *(unsigned int *)(a1 + 64);
  if (expandUnsafeMapNew((void **)(a1 + 14368), *(_QWORD *)(a1 + 14408), v6, 8uLL, &v32, a2, a3))
  {
    v7 = *__error();
    v8 = *__error();
    v9 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      v34 = "indexGrowDocumentPayloads";
      v35 = 1024;
      v36 = 4641;
      v37 = 2080;
      v38 = a1 + 15168;
      v39 = 1024;
      v40 = 4641;
      _os_log_error_impl(&dword_1B8270000, v9, OS_LOG_TYPE_ERROR, "%s:%d: %s marking invalid at %d", buf, 0x22u);
    }
    *__error() = v8;
    *(_BYTE *)(a1 + 8) = 0;
  }
  else
  {
    *(_BYTE *)(a1 + 15165) = 1;
    v10 = 4 * v6 + 4;
    v11 = ((unint64_t)v10 * (unsigned __int128)0x3333333333333334uLL) >> 64;
    if (*(_BYTE *)(a1 + 37))
      v12 = v6;
    else
      v12 = ((unint64_t)v10 * (unsigned __int128)0x3333333333333334uLL) >> 64;
    msync(*(void **)(a1 + 14392), v12, 16);
    if (*(_BYTE *)(a1 + 37))
      v13 = v6;
    else
      v13 = v11;
    munmap(*(void **)(a1 + 14392), v13);
    *(_QWORD *)(a1 + 14392) = -1;
    v14 = v32;
    v15 = v32;
    if (!*(_BYTE *)(a1 + 37))
      v15 = (4 * v32 + 4) / 5;
    if (expandMap(*(_QWORD *)(a1 + 14432), v15, (void **)(a1 + 14392), a2, a3))
    {
      v7 = *__error();
      v16 = *__error();
      v17 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315906;
        v34 = "indexGrowDocumentPayloads";
        v35 = 1024;
        v36 = 4633;
        v37 = 2080;
        v38 = a1 + 15168;
        v39 = 1024;
        v40 = 4633;
        _os_log_error_impl(&dword_1B8270000, v17, OS_LOG_TYPE_ERROR, "%s:%d: %s marking invalid at %d", buf, 0x22u);
      }
      *__error() = v16;
      *(_BYTE *)(a1 + 8) = 0;
      munmap(*(void **)(a1 + 14368), 8 * v14);
      *(_QWORD *)(a1 + 14368) = -1;
    }
    else
    {
      v18 = *(void **)(a1 + 14400);
      if (v18)
      {
        v19 = (_QWORD *)MEMORY[0x1E0C85AD8];
        if (*(_BYTE *)(a1 + 37))
          v20 = (v14 + 3) >> 2;
        else
          v20 = (v14 + 4) / 5;
        v21 = (char *)malloc_type_realloc(v18, (8 * *MEMORY[0x1E0C85AD8] - 1 + v20) / (8 * *MEMORY[0x1E0C85AD8]), 0xEC00ACFAuLL);
        *(_QWORD *)(a1 + 14400) = v21;
        v23 = ((v6 + 4) * (unsigned __int128)0x3333333333333334uLL) >> 64;
        if (*(_BYTE *)(a1 + 37))
          v24 = (v14 + 3) >> 2;
        else
          v24 = (v14 + 4) / 5;
        if (*(_BYTE *)(a1 + 37))
          v23 = (v6 + 3) >> 2;
        v22 = 8 * *v19;
        bzero(&v21[(v23 + v22 - 1) / v22], (v22 + v24 - 1) / v22 - (v23 + v22 - 1) / v22);
      }
      msync(*(void **)(a1 + 14376), 4 * v6, 16);
      munmap(*(void **)(a1 + 14376), 4 * v6);
      *(_QWORD *)(a1 + 14376) = -1;
      if (expandMap(*(_QWORD *)(a1 + 14416), 4 * v14, (void **)(a1 + 14376), a2, a3))
      {
        v7 = *__error();
        v25 = *__error();
        v26 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315906;
          v34 = "indexGrowDocumentPayloads";
          v35 = 1024;
          v36 = 4620;
          v37 = 2080;
          v38 = a1 + 15168;
          v39 = 1024;
          v40 = 4620;
          _os_log_error_impl(&dword_1B8270000, v26, OS_LOG_TYPE_ERROR, "%s:%d: %s marking invalid at %d", buf, 0x22u);
        }
        *__error() = v25;
        *(_BYTE *)(a1 + 8) = 0;
        munmap(*(void **)(a1 + 14368), 8 * v14);
        *(_QWORD *)(a1 + 14368) = -1;
        munmap(*(void **)(a1 + 14376), 4 * v14);
        *(_QWORD *)(a1 + 14376) = -1;
      }
      else
      {
        if (!*(_QWORD *)(a1 + 14424)
          || (v27 = 8 * v6,
              msync(*(void **)(a1 + 14384), v27, 16),
              munmap(*(void **)(a1 + 14384), v27),
              *(_QWORD *)(a1 + 14384) = -1,
              (v28 = *(_QWORD *)(a1 + 14424)) == 0)
          || !expandMap(v28, 8 * v14, (void **)(a1 + 14384), a2, a3))
        {
          v7 = 0;
          *(_DWORD *)(a1 + 64) = v14;
          return v7;
        }
        v7 = *__error();
        v29 = *__error();
        v30 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315906;
          v34 = "indexGrowDocumentPayloads";
          v35 = 1024;
          v36 = 4606;
          v37 = 2080;
          v38 = a1 + 15168;
          v39 = 1024;
          v40 = 4606;
          _os_log_error_impl(&dword_1B8270000, v30, OS_LOG_TYPE_ERROR, "%s:%d: %s marking invalid at %d", buf, 0x22u);
        }
        *__error() = v29;
        *(_BYTE *)(a1 + 8) = 0;
        munmap(*(void **)(a1 + 14368), 8 * v14);
        *(_QWORD *)(a1 + 14368) = -1;
        munmap(*(void **)(a1 + 14376), 4 * v14);
        *(_QWORD *)(a1 + 14376) = -1;
        munmap(*(void **)(a1 + 14384), 8 * v14);
        *(_QWORD *)(a1 + 14384) = -1;
      }
      if (!*(_BYTE *)(a1 + 37))
        v14 = (4 * v14 + 4) / 5;
      munmap(*(void **)(a1 + 14392), v14);
      *(_QWORD *)(a1 + 14392) = -1;
    }
  }
  return v7;
}

void mergeAttributesForNewEntryApplier(void *key, const void *a2, CFDictionaryRef *a3)
{
  const void *Value;
  CFTypeID v7;
  CFTypeID TypeID;
  __CFDictionary *v9;

  Value = CFDictionaryGetValue(*a3, key);
  if (!Value || Value != a2 && !CFEqual(Value, a2))
    CFSetSetValue(a3[1], (const void *)(key & 0x3FFFFFF));
  v7 = CFGetTypeID(a2);
  TypeID = CFNullGetTypeID();
  v9 = a3[2];
  if (v7 == TypeID)
    CFDictionaryRemoveValue(v9, key);
  else
    CFDictionarySetValue(v9, key, a2);
}

void attributeMergeInfoApplier(void *key, const void *a2, CFDictionaryRef *a3)
{
  const void *Value;
  CFTypeID v7;
  __CFDictionary *Mutable;
  const void *v9;
  const void *v10;
  __CFDictionary *v11;
  __CFDictionary *v12;

  Value = CFDictionaryGetValue(*a3, key);
  v7 = CFGetTypeID(a2);
  if (v7 == CFNullGetTypeID())
  {
    if (Value)
    {
      Mutable = a3[2];
      if (!Mutable)
      {
        Mutable = CFDictionaryCreateMutable(0, 0, 0, MEMORY[0x1E0C9B3A0]);
        a3[2] = Mutable;
      }
      v9 = key;
      v10 = Value;
LABEL_12:
      CFDictionarySetValue(Mutable, v9, v10);
      updateChangedAttributes(a3[4], (int)key, a2);
    }
  }
  else
  {
    if (!Value)
    {
      Mutable = a3[3];
      if (!Mutable)
      {
        Mutable = CFDictionaryCreateMutable(0, 0, 0, MEMORY[0x1E0C9B3A0]);
        a3[3] = Mutable;
      }
      v9 = key;
      v10 = a2;
      goto LABEL_12;
    }
    if (!CFEqual(a2, Value))
    {
      updateChangedAttributes(a3[4], (int)key, a2);
      v11 = a3[3];
      if (!v11)
      {
        v11 = CFDictionaryCreateMutable(0, 0, 0, MEMORY[0x1E0C9B3A0]);
        a3[3] = v11;
      }
      CFDictionarySetValue(v11, key, a2);
      v12 = a3[2];
      if (!v12)
      {
        v12 = CFDictionaryCreateMutable(0, 0, 0, MEMORY[0x1E0C9B3A0]);
        a3[2] = v12;
      }
      CFDictionarySetValue(v12, key, Value);
    }
  }
}

void attributeMergeInfoRemoveApplier(void *key, void *value, uint64_t a3)
{
  const __CFDictionary *v6;
  __CFDictionary *Mutable;

  v6 = *(const __CFDictionary **)(a3 + 8);
  if (!v6 || !CFDictionaryGetValue(v6, key))
  {
    Mutable = *(__CFDictionary **)(a3 + 16);
    if (!Mutable)
    {
      Mutable = CFDictionaryCreateMutable(0, 0, 0, MEMORY[0x1E0C9B3A0]);
      *(_QWORD *)(a3 + 16) = Mutable;
    }
    CFDictionarySetValue(Mutable, key, value);
  }
}

void attributeMergeInfoWildcardApplier(unint64_t key, const void *a2, uint64_t a3)
{
  __CFDictionary *Mutable;

  if ((key & 0x80000000) == 0 && !CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 8), (const void *)key))
  {
    Mutable = *(__CFDictionary **)(a3 + 16);
    if (!Mutable)
    {
      Mutable = CFDictionaryCreateMutable(0, 0, 0, MEMORY[0x1E0C9B3A0]);
      *(_QWORD *)(a3 + 16) = Mutable;
    }
    CFDictionarySetValue(Mutable, (const void *)(key | 0x40000000), a2);
  }
}

void updateChangedAttributes(__CFSet *a1, int a2, const void *a3)
{
  CFTypeID v6;
  const void *ValueAtIndex;

  if (a1)
  {
    CFSetAddValue(a1, (const void *)(a2 & 0x3FFFFFF));
    if (updateChangedAttributes_onceToken == -1)
    {
      if (a2 < 0)
        return;
    }
    else
    {
      dispatch_once(&updateChangedAttributes_onceToken, &__block_literal_global_108);
      if (a2 < 0)
        return;
    }
    v6 = CFGetTypeID(a3);
    if (v6 == updateChangedAttributes_arrayType && CFArrayGetCount((CFArrayRef)a3))
    {
      ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a3, 0);
      v6 = CFGetTypeID(ValueAtIndex);
    }
    if (v6 != updateChangedAttributes_dateType)
      CFSetAddValue(a1, (const void *)0x40000000);
  }
}

CFTypeID __updateChangedAttributes_block_invoke()
{
  CFTypeID result;

  updateChangedAttributes_dateType = CFDateGetTypeID();
  result = CFArrayGetTypeID();
  updateChangedAttributes_arrayType = result;
  return result;
}

uint64_t cleanUpTermUpdateMergeContext(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  pthread_mutex_t *v4;
  pthread_override_s *v5;
  char v6;
  void *v7;

  v2 = *a1;
  v1 = a1[1];
  v3 = *a1 + 14856;
  v4 = (pthread_mutex_t *)(*a1 + 14680);
  pthread_mutex_lock(v4);
  *(_DWORD *)(v2 + 14884) = 0;
  v5 = *(pthread_override_s **)(v2 + 14856);
  *(_OWORD *)v3 = 0u;
  v6 = *(_DWORD *)(v2 + 14876) != 0;
  *(_BYTE *)(v3 + 36) = 0;
  db_rwlock_wakeup((uint64_t)v4, v6, 0);
  pthread_mutex_unlock(v4);
  if (v5)
    pthread_override_qos_class_end_np(v5);
  dispatch_release(*(dispatch_object_t *)(*(_QWORD *)(v2 + 16432) + 40));
  v7 = *(void **)(v2 + 16432);
  *(_QWORD *)(v2 + 16432) = 0;
  os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 16416));
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(v2 + 16424));
  free(v7);
  TermUpdateSetRelease(v1);
  return 0;
}

void IndexFdInfoDispose(void *a1)
{
  int v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;

  if (a1)
  {
    v2 = *((_DWORD *)a1 + 2);
    if (v2 != -1)
      _fd_release_fd(*(_DWORD **)(*(_QWORD *)a1 + 14440), v2, 0, *((_QWORD *)a1 + 2));
    v3 = *((_DWORD *)a1 + 6);
    if (v3 != -1)
      _fd_release_fd(*(_DWORD **)(*(_QWORD *)a1 + 464), v3, 0, *((_QWORD *)a1 + 4));
    v4 = *((_DWORD *)a1 + 10);
    if (v4 != -1)
      _fd_release_fd(*(_DWORD **)(*(_QWORD *)a1 + 9400), v4, 0, *((_QWORD *)a1 + 6));
    v5 = *((_DWORD *)a1 + 14);
    if (v5 != -1)
      _fd_release_fd(*(_DWORD **)(*(_QWORD *)a1 + 5176), v5, 0, *((_QWORD *)a1 + 8));
    v6 = *((_DWORD *)a1 + 18);
    if (v6 != -1)
      _fd_release_fd(*(_DWORD **)(*(_QWORD *)a1 + 14112), v6, 0, *((_QWORD *)a1 + 10));
    v7 = *((_DWORD *)a1 + 22);
    if (v7 != -1)
      _fd_release_fd(*(_DWORD **)(*(_QWORD *)a1 + 9888), v7, 0, *((_QWORD *)a1 + 12));
    v8 = *((_DWORD *)a1 + 26);
    if (v8 != -1)
      _fd_release_fd(*(_DWORD **)(*(_QWORD *)a1 + 14432), v8, 0, *((_QWORD *)a1 + 14));
    v9 = *((_DWORD *)a1 + 30);
    if (v9 != -1)
      _fd_release_fd(*(_DWORD **)(*(_QWORD *)a1 + 14408), v9, 0, *((_QWORD *)a1 + 16));
    v10 = *((_DWORD *)a1 + 34);
    if (v10 != -1)
      _fd_release_fd(*(_DWORD **)(*(_QWORD *)a1 + 14416), v10, 0, *((_QWORD *)a1 + 18));
    v11 = *((_DWORD *)a1 + 38);
    if (v11 != -1)
      _fd_release_fd(*(_DWORD **)(*(_QWORD *)a1 + 14424), v11, 0, *((_QWORD *)a1 + 20));
    free(a1);
  }
}

_DWORD *IndexFdInfoCreate(uint64_t *a1, int a2)
{
  _DWORD *v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  int v15;

  v4 = malloc_type_malloc(0xA8uLL, 0x1020040A0A6502FuLL);
  *(_QWORD *)v4 = a1;
  v4[6] = -1;
  v4[10] = -1;
  v4[14] = -1;
  v4[18] = -1;
  v4[22] = -1;
  v4[26] = -1;
  v4[30] = -1;
  v4[34] = -1;
  v4[38] = -1;
  v5 = _fd_acquire_fd(a1[1805], (_QWORD *)v4 + 2);
  v4[2] = v5;
  if (v5 == -1)
    goto LABEL_14;
  v6 = _fd_acquire_fd(a1[58], (_QWORD *)v4 + 4);
  v4[6] = v6;
  if (v6 == -1)
    goto LABEL_14;
  v7 = _fd_acquire_fd(a1[1175], (_QWORD *)v4 + 6);
  v4[10] = v7;
  if (v7 == -1)
    goto LABEL_14;
  v8 = _fd_acquire_fd(a1[1764], (_QWORD *)v4 + 10);
  v4[18] = v8;
  if (v8 == -1)
    goto LABEL_14;
  if (a2)
  {
    v9 = _fd_acquire_fd(a1[647], (_QWORD *)v4 + 8);
    v4[14] = v9;
    if (v9 == -1 || (v10 = _fd_acquire_fd(a1[1236], (_QWORD *)v4 + 12), v4[22] = v10, v10 == -1))
    {
LABEL_14:
      IndexFdInfoDispose(v4);
      return 0;
    }
  }
  else
  {
    v11 = _fd_acquire_fd(a1[1804], (_QWORD *)v4 + 14);
    v4[26] = v11;
    if (v11 == -1)
      goto LABEL_14;
    v12 = _fd_acquire_fd(a1[1801], (_QWORD *)v4 + 16);
    v4[30] = v12;
    if (v12 == -1)
      goto LABEL_14;
    v13 = _fd_acquire_fd(a1[1802], (_QWORD *)v4 + 18);
    v4[34] = v13;
    if (v13 == -1)
      goto LABEL_14;
    v14 = a1[1803];
    if (v14)
    {
      v15 = _fd_acquire_fd(v14, (_QWORD *)v4 + 20);
      v4[38] = v15;
      if (v15 == -1)
        goto LABEL_14;
    }
  }
  return v4;
}

uint64_t index_compact(uint64_t a1)
{
  uint64_t v1;
  _BYTE *v2;
  _BYTE *v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int *v9;
  unsigned int v10;
  unsigned int *v11;
  unsigned int v12;
  char v14;
  char v15;
  int v16;
  NSObject *v17;
  const char *v18;
  int v19;
  NSObject *v20;
  int v21;
  int v22;
  double Current;
  uint64_t v24;
  int32_t v25;
  unint64_t v26;
  unsigned int v27;
  unsigned int v28;
  uint64_t v29;
  uint64_t v30;
  void (*v31)(_QWORD);
  uint64_t v32;
  _DWORD *v33;
  int v34;
  NSObject *v35;
  unsigned int v36;
  int v37;
  unsigned int v38;
  uint64_t v39;
  uint64_t v40;
  int v41;
  int v42;
  int v43;
  int v44;
  _QWORD *v45;
  unsigned int v46;
  int v47;
  int v48;
  char *v49;
  unsigned int v50;
  int v51;
  IVFVectorIndex_s *v52;
  int v53;
  BOOL v54;
  int v55;
  unsigned int v56;
  int v57;
  int v58;
  uint64_t v59;
  unsigned int v60;
  uint64_t v61;
  void (*v62)(_QWORD);
  int v63;
  NSObject *v64;
  os_log_type_t v65;
  float v66;
  int v67;
  uint64_t v68;
  _DWORD *v69;
  void (*v70)(_QWORD);
  double v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  unsigned int v75;
  int v76;
  NSObject *v77;
  os_log_type_t v78;
  float v79;
  char v81;
  _BOOL4 v82;
  uint64_t v83;
  char v84;
  unsigned int v85;
  unsigned int v86;
  int v87;
  NSObject *v88;
  uint64_t v89;
  char v90;
  unsigned int v91;
  unsigned int v92;
  const char *v93;
  double v94;
  uint64_t v95;
  unint64_t v96;
  unint64_t v97;
  unsigned int v98;
  unint64_t v99;
  uint64_t v101;
  __int128 v102;
  uint64_t v103;
  __int128 v104;
  unsigned int v105;
  int v106;
  NSObject *v107;
  os_log_type_t v108;
  float v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  off_t v114;
  off_t v115;
  unsigned int v116;
  unsigned int v117;
  char *v118;
  char *v119;
  _QWORD *v120;
  uint64_t v121;
  char *v122;
  uint64_t v123;
  std::error_code *v124;
  uint64_t v125;
  int v126;
  unsigned int v127;
  void (*v128)(_QWORD);
  int v129;
  NSObject *v130;
  int v131;
  int v132;
  NSObject *v133;
  int v134;
  int v135;
  NSObject *v136;
  int v137;
  int v138;
  unsigned int v139;
  char *v140;
  char *v141;
  const char *v142;
  uint64_t v143;
  char *v144;
  char *v145;
  const char *v146;
  unsigned int v147;
  uint64_t v148;
  int v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  void *v153;
  const char *v154;
  unsigned int *v155;
  uint64_t v156;
  unint64_t v157;
  int v158;
  int v159;
  unsigned int v160;
  uint64_t *v161;
  uint64_t v162;
  _QWORD v163[12];
  _QWORD v164[2];
  unint64_t v165;
  unsigned int v166;
  unsigned int v167;
  unsigned int v168;
  unsigned int v169;
  unsigned int v170;
  unsigned int v171;
  uint8_t buf[4];
  const char *v173;
  __int16 v174;
  int v175;
  __int16 v176;
  int v177;
  __int16 v178;
  std::__fs::filesystem::path *v179;
  uint64_t v180[512];
  __int128 v181[4096];
  _QWORD v182[3];
  _QWORD *v183;
  _QWORD *v184;
  _BYTE *v185;
  _BYTE *v186;
  unsigned int v187;
  _BYTE *v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  __int128 v192;
  __int128 v193;
  int v194;
  uint64_t v195;
  __int128 v196;
  _BYTE v197[216];
  uint64_t v198;
  int v199;
  _QWORD *ForwardStore;
  int *VectorIndexWithPrototype;
  _BYTE v202[4808];
  _QWORD v203[589];
  _QWORD v204[589];
  char v205[1024];
  std::__fs::filesystem::path v206[42];
  std::__fs::filesystem::path v207[42];
  uint64_t v208;

  v1 = MEMORY[0x1E0C80A78](a1);
  v3 = v2;
  v5 = v4;
  v7 = v6;
  v8 = v1;
  v208 = *MEMORY[0x1E0C80C00];
  bzero(v207, 0x400uLL);
  bzero(v206, 0x400uLL);
  bzero(v205, 0x400uLL);
  bzero(v197, 0x48E8uLL);
  v9 = (unsigned int *)(v8 + 28);
  v10 = atomic_load((unsigned int *)(v8 + 28));
  *v3 = 0;
  v11 = (unsigned int *)(v8 + 15152);
  v12 = atomic_load((unsigned int *)(v8 + 15152));
  if (v12 || ((*(uint64_t (**)(_QWORD))(v7 + 16))(*(_QWORD *)(v7 + 24)) & 1) != 0)
    return 0xFFFFFFFFLL;
  if (!*(_BYTE *)(v8 + 8))
  {
    v16 = *__error();
    v17 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      LODWORD(v181[0]) = 136315650;
      *(_QWORD *)((char *)v181 + 4) = "index_compact";
      WORD6(v181[0]) = 1024;
      *(_DWORD *)((char *)v181 + 14) = 5595;
      WORD1(v181[1]) = 2080;
      *(_QWORD *)((char *)&v181[1] + 4) = v8 + 15168;
      v18 = "%s:%d: invalid index: %s";
      goto LABEL_51;
    }
LABEL_10:
    *__error() = v16;
    return 0xFFFFFFFFLL;
  }
  v14 = atomic_load(v9);
  if ((v14 & 4) == 0)
  {
    v15 = atomic_load(v9);
    if ((v15 & 2) == 0)
    {
      v16 = *__error();
      v17 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        LODWORD(v181[0]) = 136315650;
        *(_QWORD *)((char *)v181 + 4) = "index_compact";
        WORD6(v181[0]) = 1024;
        *(_DWORD *)((char *)v181 + 14) = 5603;
        WORD1(v181[1]) = 2080;
        *(_QWORD *)((char *)&v181[1] + 4) = v8 + 15168;
        v18 = "%s:%d: cant compact writable index: %s";
LABEL_51:
        _os_log_error_impl(&dword_1B8270000, v17, OS_LOG_TYPE_ERROR, v18, (uint8_t *)v181, 0x1Cu);
        goto LABEL_10;
      }
      goto LABEL_10;
    }
    if (v5 == -1)
    {
      v21 = -1;
    }
    else if (preflight_compact(v8, v5))
    {
      v21 = v5;
    }
    else
    {
      v21 = -1;
    }
    v22 = v21;
    if (!preflight_compact(v8, *(_DWORD *)(v8 + 56)))
      return 0xFFFFFFFFLL;
    v149 = v22;
    v155 = (unsigned int *)(v8 + 28);
    Current = CFAbsoluteTimeGetCurrent();
    v24 = *(unsigned int *)(v8 + 56);
    ForwardStore = 0;
    _initPayload((char *)v203, 1);
    _initPayload((char *)v204, 1);
    bzero(v202, 0x12C8uLL);
    pthread_mutex_init((pthread_mutex_t *)&v202[4592], 0);
    bzero(&v202[160], 0x1138uLL);
    bzero(v197, 0x113CuLL);
    v25 = OSAtomicIncrement32((int32_t *)exceptionSequenceNum);
    v26 = setThreadIdAndInfo(-1, sExcCompactCallbacks, (uint64_t)v197, 0, v25);
    v170 = HIDWORD(v26);
    v171 = v26;
    v169 = v27;
    v168 = v28;
    v29 = *(_QWORD *)&threadData[18 * v26 + 2];
    v30 = v29 + 320 * HIDWORD(v26);
    v158 = *(_DWORD *)(v30 + 312);
    v31 = *(void (**)(_QWORD))(v30 + 224);
    if (v31)
      v31(*(_QWORD *)(v29 + 320 * HIDWORD(v26) + 288));
    v159 = v25;
    v167 = v171;
    v166 = v170;
    v165 = __PAIR64__(v169, v168);
    if (_setjmp((int *)v30))
    {
      v32 = v24;
      v33 = (_DWORD *)(v30 + 312);
      v34 = *__error();
      v35 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
      {
        LODWORD(v181[0]) = 136315394;
        *(_QWORD *)((char *)v181 + 4) = "index_compact";
        WORD6(v181[0]) = 1024;
        *(_DWORD *)((char *)v181 + 14) = 6114;
        _os_log_error_impl(&dword_1B8270000, v35, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", (uint8_t *)v181, 0x12u);
      }
      *__error() = v34;
      *v33 = v158;
      CIOnThreadCleanUpReset(v165);
      dropThreadId(v167, 1, v159);
      CICleanUpReset(v167, HIDWORD(v165));
      v36 = 0;
      v37 = 0;
LABEL_69:
      v63 = *__error();
      v64 = _SILogForLogForCategory(10);
      v65 = 2 * (dword_1EF19FCB4 < 4);
      if (os_log_type_enabled(v64, v65))
      {
        v66 = CFAbsoluteTimeGetCurrent() - Current;
        LODWORD(v181[0]) = 134218240;
        *(double *)((char *)v181 + 4) = v66;
        WORD6(v181[0]) = 1024;
        *(_DWORD *)((char *)v181 + 14) = v36;
        _os_log_impl(&dword_1B8270000, v64, v65, "index_compact time (%f) - %d", (uint8_t *)v181, 0x12u);
      }
      *__error() = v63;
      if (v36)
        v67 = 1;
      else
        v67 = v37;
      if (v67)
        v68 = v36;
      else
        v68 = 0xFFFFFFFFLL;
      if (v205[0])
        index_DeleteIndex(0, v32, v205, 1);
      return v68;
    }
    v38 = 0;
    v156 = (uint64_t)CICleanUpThreadLoc();
    v157 = threadData[18 * v156 + 8];
    v205[0] = 0;
    snprintf(v205, 0x400uLL, "tmp.%scmpt.", (const char *)(v8 + 15168));
    v160 = v24;
    if (!openPayload((uint64_t)v203, v24, v205, "indexPostings", "indexTermIds", (char *)v207, 0, 0, 0, *(_DWORD *)(v8 + 4), *(void **)(v8 + 4912))|| (v38 = 0, !openPayload((uint64_t)v204, v24, v205, "indexPositions", "indexPositionTable", (char *)v207,
                           0,
                           0,
                           0,
                           *(_DWORD *)(v8 + 4),
                           *(void **)(v8 + 4912))))
    {
      v47 = 0;
      goto LABEL_53;
    }
    v38 = 0;
    if (!bt_openTrie((uint64_t)v202, v24, v205, 1, 0, 0, *(_DWORD *)(v8 + 4), *(void **)(v8 + 4912)))
    {
      v47 = 0;
      goto LABEL_53;
    }
    if (*(_QWORD *)(v8 + 4904))
    {
      ForwardStore = createForwardStore(v24, v205, *(void **)(v8 + 4912));
      if (!ForwardStore)
      {
        v38 = 0;
        v47 = 0;
        goto LABEL_53;
      }
    }
    if (_os_feature_enabled_impl())
    {
      v39 = *(_QWORD *)(v8 + 4896);
      if (v39)
        VectorIndexWithPrototype = (int *)createVectorIndexWithPrototype(v24, v205, v39, *(_DWORD *)(v8 + 48));
    }
    snprintf((char *)v207, 0x400uLL, "%s%s", v205, "newTermIDMap");
    v40 = *(unsigned int *)(v8 + 9368);
    if (v40 <= 0x4000000)
      v41 = 0x8000000;
    else
      v41 = 0x10000000;
    if (v40 >= 0x2000001)
      v42 = v41;
    else
      v42 = 0x4000000;
    if (v40 >= 0x1000001)
      v43 = v42;
    else
      v43 = 0x2000000;
    if (v40 > 0x800000)
      v44 = v43;
    else
      v44 = 0x1000000;
    v147 = v44;
    v45 = fd_create_protected(v160, (const char *)v207, 536872450, 0);
    if (!uint32_map_init((uint64_t)v197, (uint64_t)v45, v40, v147, (v10 >> 9) & 1))
    {
      v47 = 1;
      v38 = 0;
      goto LABEL_53;
    }
    v46 = termIdStoreAllocBulk((uint64_t)&v203[5], v40);
    if (v46 || (v46 = termIdStoreAllocBulk((uint64_t)&v204[5], v40)) != 0)
    {
      v38 = v46;
      v47 = 1;
LABEL_53:
      v48 = v47;
      CICleanUpReset(v156, v157);
      v49 = 0;
      v50 = v38;
      v51 = v158;
      goto LABEL_54;
    }
    if (*(_QWORD *)v7)
      (*(void (**)(_QWORD))v7)(*(_QWORD *)(v7 + 24));
    v69 = IndexFdInfoCreate((uint64_t *)v8, 1);
    v70 = *(void (**)(_QWORD))(v7 + 8);
    if (v70)
      v70(*(_QWORD *)(v7 + 24));
    if (!v69)
    {
      v38 = 0;
      v47 = 1;
      goto LABEL_53;
    }
    CICleanUpPush(v156, (uint64_t)IndexFdInfoDispose, (uint64_t)v69);
    v71 = CFAbsoluteTimeGetCurrent();
    v164[0] = v197;
    v164[1] = 1;
    *v3 = 1;
    bzero(v181, 0x5160uLL);
    _dumpTrie(v8 + 88, 0, (_DWORD *)(v8 + 15152), v181, (uint64_t)reorderTermIdCallback, (uint64_t)v164);
    v72 = *(_QWORD *)(v8 + 4904);
    v73 = MEMORY[0x1E0C809B0];
    if (v72)
    {
      v163[6] = MEMORY[0x1E0C809B0];
      v163[7] = 0x40000000;
      v163[8] = __index_compact_block_invoke;
      v163[9] = &__block_descriptor_tmp_59;
      v163[10] = v164;
      v163[11] = v8;
      dumpDirectoryStore(v72);
    }
    v74 = *(_QWORD *)(v8 + 4896);
    if (v74)
    {
      v163[0] = v73;
      v163[1] = 0x40000000;
      v163[2] = __index_compact_block_invoke_2;
      v163[3] = &__block_descriptor_tmp_62_2499;
      v163[4] = v164;
      v163[5] = v8;
      dumpVectorIndex(v74, 0, (_DWORD *)(v8 + 15152), 0, (uint64_t)v163);
    }
    *v3 = 0;
    v75 = atomic_load(v11);
    if (v75 || ((*(uint64_t (**)(_QWORD))(v7 + 16))(*(_QWORD *)(v7 + 24)) & 1) != 0)
      goto LABEL_97;
    v76 = *__error();
    v77 = _SILogForLogForCategory(10);
    v78 = 2 * (dword_1EF19FCB4 < 4);
    if (os_log_type_enabled(v77, v78))
    {
      v79 = CFAbsoluteTimeGetCurrent() - v71;
      LODWORD(v181[0]) = 134217984;
      *(double *)((char *)v181 + 4) = v79;
      _os_log_impl(&dword_1B8270000, v77, v78, "computer new term ids time (%f)", (uint8_t *)v181, 0xCu);
    }
    *__error() = v76;
    if (atomic_load(v11))
      goto LABEL_97;
    v162 = 0;
    v81 = atomic_load(v155);
    v82 = (v81 & 0xC) == 8 && indexCopyDeleteDocIds(v8, 1, &v162) + 1 == *(_DWORD *)(v8 + 60);
    v83 = v162;
    CICleanUpPush(v156, (uint64_t)bit_vector_release, v162);
    *v3 = 1;
    v84 = atomic_load(v155);
    v85 = CICompactPayloads(v203, 1, v83, (uint64_t)v197, v8 + 4920, v205, v149, (v84 & 8) != 0, (_DWORD *)(v8 + 15152));
    *v3 = 0;
    if (v85
      || (v86 = atomic_load(v11)) != 0
      || !*(_BYTE *)(v8 + 8)
      || (*(unsigned int (**)(_QWORD))(v7 + 16))(*(_QWORD *)(v7 + 24)))
    {
      v38 = v85;
      v87 = *__error();
      v88 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v88, OS_LOG_TYPE_ERROR))
      {
        LODWORD(v181[0]) = 136315394;
        *(_QWORD *)((char *)v181 + 4) = "index_compact";
        WORD6(v181[0]) = 1024;
        *(_DWORD *)((char *)v181 + 14) = 5768;
        v93 = "%s:%d: Failed compacting postings";
        goto LABEL_116;
      }
    }
    else
    {
      if (v82
        || (*v3 = 1,
            v89 = v162,
            v90 = atomic_load((unsigned int *)(v8 + 28)),
            v91 = CICompactPayloads(v204, 2, v89, (uint64_t)v197, v8 + 9632, v205, v149, (v90 & 8) != 0, (_DWORD *)(v8 + 15152)), *v3 = 0, !v91))
      {
        v92 = atomic_load(v11);
        if (!v92 && *(_BYTE *)(v8 + 8) && !(*(unsigned int (**)(_QWORD))(v7 + 16))(*(_QWORD *)(v7 + 24)))
        {
          v94 = CFAbsoluteTimeGetCurrent();
          bzero(&v187, 0x890uLL);
          v182[0] = v8;
          v182[1] = v8 + 88;
          v153 = (void *)(v8 + 88);
          v182[2] = v202;
          v183 = v203;
          v184 = v204;
          v185 = v197;
          v186 = v3;
          bzero(v181, 0x10000uLL);
          fd_pread((_DWORD *)v204[560], v181, 0x10000uLL, 0);
          if (v40 >= 2)
          {
            v95 = 1;
            v96 = 8;
            v97 = 0;
            do
            {
              v148 = v95;
              v98 = atomic_load(v11);
              if (v98 || (*(unsigned int (**)(_QWORD))(v7 + 16))(*(_QWORD *)(v7 + 24)))
                break;
              v99 = *(_QWORD *)storageResolvePtr((uint64_t)&v204[5], v96, 8uLL, 1);
              if (v99)
              {
                if (v99 < v97 || v99 + 10 > v97 + 0x10000)
                {
                  v97 = v99 & ~*MEMORY[0x1E0C85AC0];
                  fd_pread((_DWORD *)v204[560], v181, 0x10000uLL, v97);
                }
                v180[0] = v99 - v97;
                if (!v2_readVInt32((uint64_t)v181, v180))
                {
                  v139 = 1;
                  do
                  {
                    if (uint32_map_get((uint64_t)v197, v139) == (_DWORD)v148)
                      goto LABEL_198;
                    ++v139;
                  }
                  while ((_DWORD)v40 != v139);
                  v139 = 0;
LABEL_198:
                  *v3 = 1;
                  v140 = __si_assert_copy_extra_2151((_DWORD *)v204[560], -1);
                  v141 = v140;
                  v142 = "";
                  if (v140)
                    v142 = v140;
                  __message_assert("%s:%u: failed assertion '%s' %s missing positions for term %d (%d)", "JHContentIndex.c", 5825, "false", v142, v148, v139);
                  free(v141);
                  if (__valid_fsp((_DWORD *)v204[560]))
                    v143 = 2989;
                  else
                    v143 = 3072;
                  *(_DWORD *)v143 = -559038737;
                  abort();
                }
              }
              v96 += 8;
              v95 = v148 + 1;
            }
            while (v40 != v148 + 1);
          }
          v188 = v202;
          v194 = 0;
          v192 = 0u;
          v196 = 0u;
          v189 = 1;
          v193 = 0u;
          v195 = 0;
          v190 = 0;
          v191 = 0;
          _dumpTrie((unint64_t)v153, 0, (_DWORD *)(v8 + 15152), 0, (uint64_t)compactTermsCallback, (uint64_t)v182);
          v101 = *(_QWORD *)(v8 + 4904);
          if (v101)
          {
            v102 = *(_OWORD *)(v7 + 16);
            v181[0] = *(_OWORD *)v7;
            v181[1] = v102;
            compactForwardDirectoryStore(v101);
          }
          v103 = *(_QWORD *)(v8 + 4896);
          if (v103)
          {
            v104 = *(_OWORD *)(v7 + 16);
            v181[0] = *(_OWORD *)v7;
            v181[1] = v104;
            compactVectorIndex(v103, (uint64_t)VectorIndexWithPrototype, (uint64_t)v185, (uint64_t)(v183 + 5), v181, (_DWORD *)(v8 + 15152));
          }
          v105 = atomic_load(v11);
          if (v105 || ((*(uint64_t (**)(_QWORD))(v7 + 16))(*(_QWORD *)(v7 + 24)) & 1) != 0 || HIDWORD(v189))
          {
LABEL_97:
            v38 = 0;
LABEL_98:
            v47 = 1;
            goto LABEL_53;
          }
          if (v199 - 1 < v187)
          {
            *v3 = 1;
            v144 = __si_assert_copy_extra_2151(*(_DWORD **)(v8 + 14440), -1);
            v145 = v144;
            v146 = "";
            if (v144)
              v146 = v144;
            __message_assert("%s:%u: failed assertion '%s' %s inconsistent term counts (%d %d)", "JHContentIndex.c", 5854, "false", v146, v187, v199 - 1);
            free(v145);
            if (__valid_fsp(*(_DWORD **)(v8 + 14440)))
            {
              MEMORY[0xBAD] = -559038737;
              abort();
            }
            MEMORY[0xC00] = -559038737;
            abort();
          }
          v106 = *__error();
          v107 = _SILogForLogForCategory(10);
          v108 = 2 * (dword_1EF19FCB4 < 4);
          if (os_log_type_enabled(v107, v108))
          {
            v109 = CFAbsoluteTimeGetCurrent() - v94;
            LODWORD(v181[0]) = 134217984;
            *(double *)((char *)v181 + 4) = v109;
            _os_log_impl(&dword_1B8270000, v107, v108, "compact_trie time (%f)", (uint8_t *)v181, 0xCu);
          }
          *__error() = v106;
          _fd_unlink_with_origin(v203[32], 0);
          termIdStoreDestroy((uint64_t)&v203[5]);
          _fd_unlink_with_origin(v204[32], 0);
          termIdStoreDestroy((uint64_t)&v204[5]);
          if (*(int *)&v202[400] >= 1)
          {
            v110 = 0;
            do
            {
              v111 = v110;
              storageWindowSync(*(_QWORD **)&v202[8 * v110 + 424], 0);
              v110 = v111 + 1;
            }
            while (v111 + 1 < *(int *)&v202[400]);
          }
          if (SLODWORD(v204[35]) >= 1)
          {
            v112 = 0;
            do
            {
              v113 = v112;
              storageWindowSync((_QWORD *)v204[v112 + 38], 0);
              v112 = v113 + 1;
            }
            while (v113 + 1 < SLODWORD(v204[35]));
          }
          bt_syncTrie((uint64_t)v202);
          v114 = v203[3];
          if (v203[3] == v203[4] && v203[1] == v203[3])
          {
            v203[1] = v203[0];
            v203[3] = v203[0];
            v114 = v203[0];
          }
          fd_truncate(v203[560], v114);
          fd_sync(v203[560], 0);
          v115 = v204[3];
          if (v204[3] == v204[4] && v204[1] == v204[3])
          {
            v204[1] = v204[0];
            v204[3] = v204[0];
            v115 = v204[0];
          }
          fd_truncate(v204[560], v115);
          fd_sync(v204[560], 0);
          storageTruncate((uint64_t *)&v202[160]);
          fd_truncate(*(uint64_t *)&v202[112], *(off_t *)&v202[32]);
          fd_truncate(*(uint64_t *)&v202[4568], 1028 * (*(_DWORD *)&v202[144] + 1));
          if (*(_QWORD *)v7)
            (*(void (**)(_QWORD))v7)(*(_QWORD *)(v7 + 24));
          v154 = (const char *)(v8 + 15168);
          CICleanUpReset(v156, v157);
          v152 = v8 + 14464;
          _db_write_lock(v8 + 14464);
          v150 = v8 + 4680;
          _db_write_lock(v8 + 4680);
          v151 = v8 + 14680;
          _db_write_lock(v8 + 14680);
          *(_BYTE *)(v8 + 4669) = 1;
          memcpy(v181, (const void *)v8, 0x4040uLL);
          memcpy((char *)&v181[5] + 8, v202, 0x12C8uLL);
          memcpy(&v181[602], v204, 0x1268uLL);
          memcpy((char *)&v181[307] + 8, v203, 0x1268uLL);
          bzero(v180, 0x1000uLL);
          v161 = 0;
          DWORD1(v181[0]) = *(_DWORD *)(v8 + 4);
          do
            v116 = __ldaxr((unsigned int *)&v181[1] + 3);
          while (__stlxr(v116 | 4, (unsigned int *)&v181[1] + 3));
          if (v82)
          {
            do
              v117 = __ldaxr((unsigned int *)&v181[1] + 3);
            while (__stlxr(v117 | 0x10, (unsigned int *)&v181[1] + 3));
          }
          atomic_store(0xC001D00D, (unsigned int *)&v181[1] + 2);
          v161 = v180;
          indexStoreToBuffer((uint64_t)v181, (void **)&v161);
          snprintf((char *)v207, 0x400uLL, "%s%s", v205, "shadowIndexHead");
          v118 = (char *)fd_create_protected(*(_DWORD *)(v8 + 56), (const char *)v207, 536872450, 0);
          if (v118)
          {
            v119 = v118;
            if (fd_pwrite((uint64_t)v118, (uint64_t)v180, 0x1000uLL, 0) == -1)
            {
              v132 = *__error();
              v133 = _SILogForLogForCategory(0);
              if (os_log_type_enabled(v133, OS_LOG_TYPE_ERROR))
              {
                v134 = *__error();
                *(_DWORD *)buf = 136315650;
                v173 = "index_compact";
                v174 = 1024;
                v175 = 5940;
                v176 = 1024;
                v177 = v134;
                _os_log_error_impl(&dword_1B8270000, v133, OS_LOG_TYPE_ERROR, "%s:%d: pwrite err: %d", buf, 0x18u);
              }
              goto LABEL_187;
            }
            fd_release(v119);
            snprintf((char *)v207, 0x400uLL, "%s%s", v205, "indexHead");
            v120 = fd_create_protected(v160, (const char *)v207, 536872450, 0);
            if (v120)
            {
              v121 = (uint64_t)v120;
              fd_no_cache((uint64_t)v120);
              if (fd_pwrite(v121, (uint64_t)v180, 0x1000uLL, 0) != -1)
              {
                fd_sync(v121, 1);
                snprintf((char *)v207, 0x400uLL, "%s%s", v154, "indexHead");
                fd_rename(v121, (const char *)v207);
                v122 = *(char **)(v8 + 14440);
                *(_QWORD *)(v8 + 14440) = v121;
                fd_release(v122);
                v123 = *(_QWORD *)(v8 + 14408);
                if (v123 && (*(_BYTE *)(v123 + 48) & 3) != 0)
                {
                  fd_truncate(v123, 8 * *(unsigned int *)(v8 + 60));
                  fd_make_readonly(*(_QWORD *)(v8 + 14408));
                }
                fd_make_readonly(*(_QWORD *)(v8 + 200));
                fd_make_readonly(*(_QWORD *)(v8 + 9400));
                _fd_unlink_with_origin(*(_QWORD *)(v8 + 5176), 0);
                storageClose(v8 + 4960);
                fd_make_readonly(*(_QWORD *)(v8 + 14112));
                _fd_unlink_with_origin(*(_QWORD *)(v8 + 9888), 0);
                storageClose(v8 + 9672);
                storageMakeReadOnly(v8 + 248);
                snprintf((char *)v207, 0x400uLL, "%s%s", v154, "indexPostings");
                fd_rename(v203[560], (const char *)v207);
                memcpy(v181, v203, 0x1268uLL);
                memcpy(v203, (const void *)(v8 + 4920), 0x11A0uLL);
                memcpy((void *)(v8 + 4920), v181, 0x11A0uLL);
                snprintf((char *)v207, 0x400uLL, "%s%s", v154, "indexPositions");
                fd_rename(v204[560], (const char *)v207);
                memcpy(v181, v204, 0x1268uLL);
                memcpy(v204, (const void *)(v8 + 9632), 0x11A0uLL);
                memcpy((void *)(v8 + 9632), v181, 0x11A0uLL);
                bt_changePrefix((uint64_t)v202, v205, v154, 0);
                memcpy(v181, v202, 0x12C8uLL);
                memcpy(v202, v153, 0x11F0uLL);
                memcpy(v153, v181, 0x11F0uLL);
                LODWORD(v181[0]) = 0;
                if (fd_setDir(*(unsigned int *)(v8 + 56), (int *)v181))
                {
                  snprintf((char *)v207, 0x400uLL, "%s%s", v154, "indexUpdates");
                  unlink((const char *)v207);
                  snprintf((char *)v207, 0x400uLL, "%s%s", v154, "shadowIndexHead");
                  snprintf((char *)v206, 0x400uLL, "%s%s", v205, "shadowIndexHead");
                  rename(v206, v207, v124);
                  if (*(_QWORD *)(v8 + 4904))
                  {
                    LODWORD(v180[0]) = 0;
                    shadowForwardStore((uint64_t)ForwardStore, 1, v180);
                    subvertForwardDirectoryStore(*(_QWORD **)(v8 + 4904), (uint64_t)ForwardStore);
                    *(_QWORD *)(v8 + 4904) = ForwardStore;
                    ForwardStore = 0;
                  }
                  v125 = *(_QWORD *)(v8 + 4896);
                  if (v125)
                  {
                    subvertVectorIndex(v125, (uint64_t)VectorIndexWithPrototype);
                    *(_QWORD *)(v8 + 4896) = VectorIndexWithPrototype;
                    VectorIndexWithPrototype = 0;
                  }
                  fd_resetDir(v181[0]);
                }
                if (v82)
                  v126 = 20;
                else
                  v126 = 4;
                do
                  v127 = __ldaxr(v155);
                while (__stlxr(v127 | v126, v155));
                v128 = *(void (**)(_QWORD))(v7 + 8);
                if (v128)
                  v128(*(_QWORD *)(v7 + 24));
                CICleanUpReset(v156, v157);
                db_write_unlock(v150);
                db_write_unlock(v152);
                db_write_unlock(v151);
                index_optimize_disk_space(v8);
                v56 = 0;
                if (g_fd_list)
                  _fd_close_inactive(*(unsigned int *)(v8 + 56), v154, 0, 0);
                v55 = 1;
                v51 = v158;
                v58 = v159;
                goto LABEL_65;
              }
              v135 = *__error();
              v136 = _SILogForLogForCategory(0);
              if (os_log_type_enabled(v136, OS_LOG_TYPE_ERROR))
              {
                v138 = *__error();
                *(_DWORD *)buf = 136315650;
                v173 = "index_compact";
                v174 = 1024;
                v175 = 5955;
                v176 = 1024;
                v177 = v138;
                _os_log_error_impl(&dword_1B8270000, v136, OS_LOG_TYPE_ERROR, "%s:%d: pwrite err: %d", buf, 0x18u);
              }
              v132 = v135;
              v119 = (char *)v121;
              goto LABEL_187;
            }
            v129 = *__error();
            v130 = _SILogForLogForCategory(0);
            if (!os_log_type_enabled(v130, OS_LOG_TYPE_ERROR))
            {
LABEL_186:
              v132 = v129;
              v119 = 0;
LABEL_187:
              *__error() = v132;
              CICleanUpReset(v156, v157);
              db_write_unlock(v150);
              db_write_unlock(v152);
              db_write_unlock(v151);
              v50 = 0;
              v48 = 1;
              v49 = v119;
              v51 = v158;
LABEL_54:
              fd_release(v49);
              fd_zero_truncate(*(uint64_t *)&v202[4568]);
              fd_zero_truncate(*(uint64_t *)&v202[112]);
              fd_zero_truncate(*(uint64_t *)&v202[376]);
              fd_zero_truncate(v203[32]);
              fd_zero_truncate(v203[560]);
              fd_zero_truncate(v204[32]);
              fd_zero_truncate(v204[560]);
              fd_zero_truncate(v198);
              if (ForwardStore)
              {
                fd_zero_truncate(ForwardStore[28]);
                freeForwardDirectoryStore(ForwardStore);
                ForwardStore = 0;
                unlinkDirectoryStore(v205);
                unlinkDirectoryStoreShadow(v205);
              }
              if (VectorIndexWithPrototype)
              {
                v52 = (IVFVectorIndex_s *)v207;
                v53 = fcntl(*VectorIndexWithPrototype, 50, v207);
                if (v207[0].__pn_.__r_.__value_.__s.__data_[0])
                  v54 = v53 < 0;
                else
                  v54 = 1;
                if (v54)
                  v52 = 0;
                truncateVectorIndex((uint64_t)VectorIndexWithPrototype);
                freeVectorIndex((uint64_t)VectorIndexWithPrototype);
                VectorIndexWithPrototype = 0;
                IVFVectorIndex_s::unlink(v52, v205, 0);
                IVFVectorIndex_s::unlink(v52, v205, (const char *)1);
                v55 = 0;
                v56 = v50;
                v57 = 0;
                v58 = v159;
                if ((v48 & 1) == 0)
                  goto LABEL_66;
              }
              else
              {
                v55 = 0;
                v56 = v50;
                v57 = 0;
                v58 = v159;
                if (!v48)
                {
LABEL_66:
                  storageClose((uint64_t)v197);
                  bt_freeTrie((uint64_t)v202);
                  freePayload((uint64_t)v204);
                  freePayload((uint64_t)v203);
                  v59 = *(_QWORD *)&threadData[18 * v167 + 2];
                  v60 = v166;
                  v61 = v59 + 320 * v166;
                  *(_DWORD *)(v61 + 312) = v51;
                  v62 = *(void (**)(_QWORD))(v61 + 232);
                  if (v62)
                    v62(*(_QWORD *)(v59 + 320 * v60 + 288));
                  dropThreadId(v167, 0, v58);
                  v37 = v57;
                  v36 = v50;
                  v32 = v160;
                  goto LABEL_69;
                }
              }
LABEL_65:
              v57 = v55;
              _fd_unlink_with_origin(v198, 0);
              v50 = v56;
              goto LABEL_66;
            }
            v137 = *__error();
            *(_DWORD *)buf = 136315906;
            v173 = "index_compact";
            v174 = 1024;
            v175 = 5950;
            v176 = 1024;
            v177 = v137;
            v178 = 2080;
            v179 = v207;
          }
          else
          {
            v129 = *__error();
            v130 = _SILogForLogForCategory(0);
            if (!os_log_type_enabled(v130, OS_LOG_TYPE_ERROR))
              goto LABEL_186;
            v131 = *__error();
            *(_DWORD *)buf = 136315906;
            v173 = "index_compact";
            v174 = 1024;
            v175 = 5936;
            v176 = 1024;
            v177 = v131;
            v178 = 2080;
            v179 = v207;
          }
          _os_log_error_impl(&dword_1B8270000, v130, OS_LOG_TYPE_ERROR, "%s:%d: open err: %d, %s", buf, 0x22u);
          goto LABEL_186;
        }
        v91 = 0;
      }
      v38 = v91;
      v87 = *__error();
      v88 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v88, OS_LOG_TYPE_ERROR))
      {
        LODWORD(v181[0]) = 136315394;
        *(_QWORD *)((char *)v181 + 4) = "index_compact";
        WORD6(v181[0]) = 1024;
        *(_DWORD *)((char *)v181 + 14) = 5781;
        v93 = "%s:%d: Failed compacting positions";
LABEL_116:
        _os_log_error_impl(&dword_1B8270000, v88, OS_LOG_TYPE_ERROR, v93, (uint8_t *)v181, 0x12u);
      }
    }
    *__error() = v87;
    goto LABEL_98;
  }
  v19 = *__error();
  v20 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
  {
    LODWORD(v181[0]) = 136315650;
    *(_QWORD *)((char *)v181 + 4) = "index_compact";
    WORD6(v181[0]) = 1024;
    *(_DWORD *)((char *)v181 + 14) = 5599;
    WORD1(v181[1]) = 2080;
    *(_QWORD *)((char *)&v181[1] + 4) = v8 + 15168;
    _os_log_error_impl(&dword_1B8270000, v20, OS_LOG_TYPE_ERROR, "%s:%d: index alreay compact: %s", (uint8_t *)v181, 0x1Cu);
  }
  *__error() = v19;
  return 0;
}

uint64_t preflight_compact(uint64_t a1, int a2)
{
  char v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int *v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  int v17;
  NSObject *v18;
  const char *v19;
  NSObject *v20;
  uint32_t v21;
  NSObject *v22;
  int *v23;
  uint64_t result;
  int v25;
  int v26;
  const char *v27;
  __int16 v28;
  int v29;
  __int16 v30;
  _BYTE v31[10];
  uint64_t v32;
  __int16 v33;
  uint64_t v34;
  statfs v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  bzero(&v35, 0x878uLL);
  v4 = atomic_load((unsigned int *)(a1 + 28));
  atomic_load((unsigned int *)(a1 + 28));
  v5 = 60;
  if ((v4 & 4) == 0)
    v5 = 64;
  v6 = *(unsigned int *)(a1 + v5);
  if (*(_BYTE *)(a1 + 37))
    v7 = v6;
  else
    v7 = ((unint64_t)(4 * v6 + 4) * (unsigned __int128)0x3333333333333334uLL) >> 64;
  v8 = v7 + 8 * v6 + *(_QWORD *)(a1 + 4944) + 4096;
  if ((v4 & 4) != 0)
  {
    v9 = *(_QWORD *)(a1 + 9656) + v8;
    v10 = (unsigned int *)(a1 + 232);
    v11 = (_QWORD *)(a1 + 120);
    v12 = (_QWORD *)(a1 + 480);
  }
  else
  {
    v9 = *(_QWORD *)(a1 + 9656) + v8 + 8 * *(unsigned int *)(a1 + 9372) + 8 * *(unsigned int *)(a1 + 14084);
    v10 = (unsigned int *)(a1 + 236);
    v11 = (_QWORD *)(a1 + 128);
    v12 = (_QWORD *)(a1 + 472);
  }
  v13 = *v11 + v9 + 1028 * *v10 + *v12 + 1028;
  v14 = *(_QWORD *)(a1 + 4904);
  if (v14)
    v13 += *(_QWORD *)(v14 + 232);
  if (fstatfs(a2, &v35) == -1)
  {
    v17 = *__error();
    v22 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      v25 = *__error();
      v26 = 136315906;
      v27 = "preflight_compact";
      v28 = 1024;
      v29 = 5381;
      v30 = 1024;
      *(_DWORD *)v31 = a2;
      *(_WORD *)&v31[4] = 1024;
      *(_DWORD *)&v31[6] = v25;
      v19 = "%s:%d: fstatfs(%d) err:%d";
      v20 = v22;
      v21 = 30;
      goto LABEL_22;
    }
LABEL_17:
    v23 = __error();
    result = 0;
    *v23 = v17;
    return result;
  }
  v15 = v35.f_bavail * v35.f_bsize;
  v16 = v13
      - *(_QWORD *)(a1 + 4944)
      - *(_QWORD *)(a1 + 9656)
      + 2 * (*(_QWORD *)(a1 + 4944) - *(_QWORD *)(a1 + 4928) + *(_QWORD *)(a1 + 4920))
      + 2 * (*(_QWORD *)(a1 + 9656) - *(_QWORD *)(a1 + 9640) + *(_QWORD *)(a1 + 9632));
  if (v16 <= v15)
    return 1;
  if (*(_DWORD *)(a1 + 56) == a2)
  {
    v17 = *__error();
    v18 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      v26 = 136316162;
      v27 = "preflight_compact";
      v28 = 1024;
      v29 = 5398;
      v30 = 2048;
      *(_QWORD *)v31 = v16;
      *(_WORD *)&v31[8] = 2048;
      v32 = v15;
      v33 = 2048;
      v34 = v35.f_blocks * v35.f_bsize;
      v19 = "%s:%d: not enought space to compact index - needed: %lld, avail: %lld, device: %lld";
      v20 = v18;
      v21 = 48;
LABEL_22:
      _os_log_error_impl(&dword_1B8270000, v20, OS_LOG_TYPE_ERROR, v19, (uint8_t *)&v26, v21);
      goto LABEL_17;
    }
    goto LABEL_17;
  }
  return 0;
}

char *reorderTermIdCallback(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t *a5)
{
  int v6;
  char *result;
  char *v9;
  char *v10;
  const char *v11;
  char *v12;
  char *v13;
  const char *v14;
  char *v15;
  const char *v16;
  uint64_t v17;
  char *v18;
  char *v19;
  const char *v20;

  v6 = *((_DWORD *)a5 + 2);
  *((_DWORD *)a5 + 2) = v6 + 1;
  if (!a3 || *(_DWORD *)(*a5 + 4408) <= a3)
  {
    v9 = __si_assert_copy_extra(0);
    v10 = v9;
    v11 = "";
    if (v9)
      v11 = v9;
    __message_assert("%s:%u: failed assertion '%s' %s ", "storage.c", 1530, "position && position < inMap->count", v11);
    goto LABEL_18;
  }
  if (*(_DWORD *)storageResolvePtr(*a5, 4 * a3, 4uLL, 1))
  {
    if ((__native_fs() & 1) == 0)
    {
      v18 = __si_assert_copy_extra_2151(0, -1);
      v19 = v18;
      v20 = "";
      if (v18)
        v20 = v18;
      si_analytics_log_2520("%s:%u: failed assertion '%s' %s duplicate term id (%d)", "JHContentIndex.c", 5364, "0 == uint32_map_get(ctx->newTermIds, termId)", v20, a3);
      free(v19);
      v17 = 2816;
LABEL_21:
      *(_DWORD *)v17 = -559038737;
      abort();
    }
    if (uint32_map_get(*a5, a3))
    {
      v12 = __si_assert_copy_extra_2151(0, -1);
      v13 = v12;
      v14 = "";
      if (v12)
        v14 = v12;
      __message_assert("%s:%u: failed assertion '%s' %s duplicate term id (%d)", "JHContentIndex.c", 5364, "0 == uint32_map_get(ctx->newTermIds, termId)", v14, a3);
      free(v13);
      if (__valid_fs(-1))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
  }
  if (*(_DWORD *)(*a5 + 4408) <= a3)
  {
    v15 = __si_assert_copy_extra(0);
    v10 = v15;
    v16 = "";
    if (v15)
      v16 = v15;
    __message_assert("%s:%u: failed assertion '%s' %s ", "storage.c", 1537, "position && position < inMap->count", v16);
LABEL_18:
    free(v10);
    if (__valid_fs(-1))
      v17 = 2989;
    else
      v17 = 3072;
    goto LABEL_21;
  }
  result = storageResolvePtr(*a5, 4 * a3, 4uLL, 1);
  *(_DWORD *)result = v6;
  return result;
}

BOOL __index_compact_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t *v7;
  int v8;
  unsigned int v9;
  char *v11;
  char *v12;
  const char *v13;
  uint64_t v14;
  char *v15;
  char *v16;
  const char *v17;

  if (a4)
  {
    if (!(_DWORD)a4 || (v6 = **(_QWORD **)(a1 + 32), *(_DWORD *)(v6 + 4408) <= a4))
    {
      v11 = __si_assert_copy_extra(0);
      v12 = v11;
      v13 = "";
      if (v11)
        v13 = v11;
      __message_assert("%s:%u: failed assertion '%s' %s ", "storage.c", 1530, "position && position < inMap->count", v13);
      free(v12);
      if (__valid_fs(-1))
        v14 = 2989;
      else
        v14 = 3072;
      *(_DWORD *)v14 = -559038737;
      abort();
    }
    if (*(_DWORD *)storageResolvePtr(v6, 4 * a4, 4uLL, 1))
    {
      si_analytics_log_2520("Duplicate term id %llu (file tree)", a4);
    }
    else
    {
      v7 = *(uint64_t **)(a1 + 32);
      v8 = *((_DWORD *)v7 + 2);
      *((_DWORD *)v7 + 2) = v8 + 1;
      if (*(_DWORD *)(*v7 + 4408) <= a4)
      {
        v15 = __si_assert_copy_extra(0);
        v16 = v15;
        v17 = "";
        if (v15)
          v17 = v15;
        __message_assert("%s:%u: failed assertion '%s' %s ", "storage.c", 1537, "position && position < inMap->count", v17);
        free(v16);
        if (__valid_fs(-1))
        {
          MEMORY[0xBAD] = -559038737;
          abort();
        }
        MEMORY[0xC00] = -559038737;
        abort();
      }
      *(_DWORD *)storageResolvePtr(*v7, 4 * a4, 4uLL, 1) = v8;
    }
  }
  v9 = atomic_load((unsigned int *)(*(_QWORD *)(a1 + 40) + 15152));
  return v9 != 0;
}

BOOL __index_compact_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t *v11;
  int v12;
  unsigned int v13;
  char *v15;
  char *v16;
  const char *v17;
  uint64_t v18;
  char *v19;
  char *v20;
  const char *v21;

  if (a8)
  {
    if (!(_DWORD)a8 || (v10 = **(_QWORD **)(a1 + 32), *(_DWORD *)(v10 + 4408) <= a8))
    {
      v15 = __si_assert_copy_extra(0);
      v16 = v15;
      v17 = "";
      if (v15)
        v17 = v15;
      __message_assert("%s:%u: failed assertion '%s' %s ", "storage.c", 1530, "position && position < inMap->count", v17);
      free(v16);
      if (__valid_fs(-1))
        v18 = 2989;
      else
        v18 = 3072;
      *(_DWORD *)v18 = -559038737;
      abort();
    }
    if (*(_DWORD *)storageResolvePtr(v10, 4 * a8, 4uLL, 1))
    {
      si_analytics_log_2520("Duplicate term id %llu (vector index)", a8);
    }
    else
    {
      v11 = *(uint64_t **)(a1 + 32);
      v12 = *((_DWORD *)v11 + 2);
      *((_DWORD *)v11 + 2) = v12 + 1;
      if (*(_DWORD *)(*v11 + 4408) <= a8)
      {
        v19 = __si_assert_copy_extra(0);
        v20 = v19;
        v21 = "";
        if (v19)
          v21 = v19;
        __message_assert("%s:%u: failed assertion '%s' %s ", "storage.c", 1537, "position && position < inMap->count", v21);
        free(v20);
        if (__valid_fs(-1))
        {
          MEMORY[0xBAD] = -559038737;
          abort();
        }
        MEMORY[0xC00] = -559038737;
        abort();
      }
      *(_DWORD *)storageResolvePtr(*v11, 4 * a8, 4uLL, 1) = v12;
    }
  }
  v13 = atomic_load((unsigned int *)(*(_QWORD *)(a1 + 40) + 15152));
  return v13 != 0;
}

void bit_vector_release(_QWORD *a1)
{
  const void *v2;

  if (a1)
  {
    v2 = (const void *)a1[2];
    if (v2)
      CFRelease(v2);
    free(a1);
  }
}

unsigned int *compactTermsCallback(unsigned int a1, unsigned __int8 *a2, unsigned int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7;
  unsigned int *result;
  unint64_t v10;
  char *v11;
  uint64_t v12;
  unsigned int v13;
  int v14;
  unsigned __int8 *v15;
  unsigned __int8 *v16;
  int v17;
  unsigned __int8 *v18;
  int v19;
  int v21;
  int v22;
  unsigned int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  char *v29;
  char *v30;
  const char *v31;
  uint64_t v32;
  int v33;
  _BYTE *v34;
  BOOL v35;
  char *v36;
  char *v37;
  const char *v38;
  const char *v39;
  char *v40;
  char *v41;
  const char *v42;
  char *v43;
  const char *v44;

  if (!a3 || (v7 = *(_QWORD *)(a5 + 40), *(_DWORD *)(v7 + 4408) <= a3))
  {
    v29 = __si_assert_copy_extra(0);
    v30 = v29;
    v31 = "";
    if (v29)
      v31 = v29;
    __message_assert("%s:%u: failed assertion '%s' %s ", "storage.c", 1530, "position && position < inMap->count", v31);
    goto LABEL_41;
  }
  result = (unsigned int *)storageResolvePtr(v7, 4 * a3, 4uLL, 1);
  if (*(_DWORD *)(a5 + 76))
    return result;
  v10 = 8 * *result;
  *(_QWORD *)(a5 + 80) = *(_QWORD *)storageResolvePtr(*(_QWORD *)(a5 + 24) + 40, v10, 8uLL, 1);
  v11 = storageResolvePtr(*(_QWORD *)(a5 + 32) + 40, v10, 8uLL, 1);
  v12 = *(_QWORD *)v11;
  *(_QWORD *)(a5 + 88) = *(_QWORD *)v11;
  if (a1 < 2 || !v12)
    goto LABEL_48;
  if (*a2 > 3u)
  {
    v15 = &a2[a1];
    v16 = v15 - 6;
    if (a1 < 6)
      v16 = a2 + 1;
    v17 = (char)*(v15 - 1);
    if ((v17 & 0x80000000) == 0)
    {
      v19 = *(v15 - 2);
      v18 = v15 - 2;
      if (v19 == 1 && v17 == 3)
        --v18;
      if (v18 <= v16)
      {
LABEL_22:
        if (*v18 == 1)
        {
LABEL_25:
          v13 = v18[1];
          if (((char)v18[1] & 0x80000000) == 0)
            goto LABEL_47;
          v21 = v18[2];
          if (((char)v18[2] & 0x80000000) == 0)
          {
            v13 = v13 & 0x7F | (v21 << 7);
            goto LABEL_47;
          }
          v25 = v18[3];
          if (((char)v18[3] & 0x80000000) == 0)
          {
            v23 = ((v21 & 0x7F) << 7) | (v25 << 14);
            goto LABEL_46;
          }
          v27 = v18[4];
          if (((char)v18[4] & 0x80000000) == 0)
          {
            v28 = ((v25 & 0x7F) << 14) | (v27 << 21);
LABEL_45:
            v23 = v28 & 0xFFFFC07F | ((v21 & 0x7F) << 7);
            goto LABEL_46;
          }
          v33 = (char)v18[5];
          if ((v33 & 0x80000000) == 0)
          {
            v28 = ((v27 & 0x7F) << 21) | (v33 << 28) | ((v25 & 0x7F) << 14);
            goto LABEL_45;
          }
          v43 = __si_assert_copy_extra_2151(0, -1);
          v30 = v43;
          v44 = "";
          if (v43)
            v44 = v43;
          __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t", "VIntUtils.h", 341, "(b4 & 0x80) == 0", v44);
LABEL_41:
          free(v30);
          if (__valid_fs(-1))
            v32 = 2989;
          else
            v32 = 3072;
          goto LABEL_53;
        }
      }
      else
      {
        while ((char)*v18 < 0)
        {
          if (--v18 <= v16)
          {
            v18 = v16;
            goto LABEL_22;
          }
        }
        if (*v18 == 1)
          goto LABEL_25;
      }
    }
LABEL_48:
    if (*(_QWORD *)(a5 + 80))
      goto LABEL_49;
    goto LABEL_55;
  }
  v13 = a2[1];
  if (((char)a2[1] & 0x80000000) == 0)
    goto LABEL_47;
  v14 = a2[2];
  if (((char)a2[2] & 0x80000000) == 0)
  {
    v13 = v13 & 0x7F | (v14 << 7);
    goto LABEL_47;
  }
  v22 = a2[3];
  if (((char)a2[3] & 0x80000000) == 0)
  {
    v23 = ((v14 & 0x7F) << 7) | (v22 << 14);
LABEL_46:
    v13 = v23 & 0xFFFFFF80 | v13 & 0x7F;
    goto LABEL_47;
  }
  v24 = a2[4];
  if ((char)a2[4] < 0)
  {
    v26 = (char)a2[5];
    if (v26 < 0)
    {
      v40 = __si_assert_copy_extra_2151(0, -1);
      v41 = v40;
      v42 = "";
      if (v40)
        v42 = v40;
      __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t", "VIntUtils.h", 341, "(b4 & 0x80) == 0", v42);
      free(v41);
      if (__valid_fs(-1))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
    v13 = ((v24 & 0x7F) << 21) | (v26 << 28) | ((v22 & 0x7F) << 14) | ((v14 & 0x7F) << 7) | v13 & 0x7F;
  }
  else
  {
    v13 = ((v22 & 0x7F) << 14) | (v24 << 21) | ((v14 & 0x7F) << 7) | v13 & 0x7F;
  }
LABEL_47:
  if (!v13)
    goto LABEL_48;
  *(_QWORD *)(a5 + 88) = 0;
  if (!*(_QWORD *)(a5 + 80))
  {
LABEL_55:
    v34 = *(_BYTE **)(a5 + 48);
    if (v34)
      *v34 = 1;
    v35 = __native_fsp(*(_DWORD **)(*(_QWORD *)(a5 + 8) + 376));
    v36 = __si_assert_copy_extra_2151(*(_DWORD **)(*(_QWORD *)(a5 + 8) + 376), -1);
    v37 = v36;
    v38 = "";
    if (v36)
      v38 = v36;
    v39 = (const char *)(*(_QWORD *)a5 + 16192);
    if (v35)
    {
      __message_assert("%s:%u: failed assertion '%s' %s no posting for term (%s %s)", "JHContentIndex.c", 5342, "0", v38, (const char *)(*(_QWORD *)a5 + 16224), v39);
      free(v37);
      if (__valid_fsp(*(_DWORD **)(*(_QWORD *)(a5 + 8) + 376)))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
    si_analytics_log_2520("%s:%u: failed assertion '%s' %s no posting for term (%s %s)", "JHContentIndex.c", 5342, "false", v38, (const char *)(*(_QWORD *)a5 + 16224), v39);
    free(v37);
    v32 = 2816;
LABEL_53:
    *(_DWORD *)v32 = -559038737;
    abort();
  }
LABEL_49:
  result = (unsigned int *)bt_mergeCallback((unsigned __int16)a1, a2, (int **)(a5 + 64));
  if ((_DWORD)result)
    ++*(_QWORD *)(a5 + 56);
  return result;
}

uint64_t v2_readVInt32(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  uint64_t result;

  v3 = *a2;
  v4 = *a2 + 1;
  v5 = *(char *)(a1 + *a2);
  result = *(unsigned __int8 *)(a1 + *a2);
  if (v5 < 0)
  {
    if (result > 0xBF)
    {
      if (result > 0xDF)
      {
        if (result > 0xEF)
        {
          result = *(unsigned int *)(a1 + v4);
          *a2 = v3 + 5;
        }
        else
        {
          result = ((result & 0xF) << 24) | (*(unsigned __int8 *)(a1 + v4) << 16) | (*(unsigned __int8 *)(v3 + a1 + 2) << 8) | *(unsigned __int8 *)(v3 + a1 + 3);
          *a2 = v3 + 4;
        }
      }
      else
      {
        result = ((result & 0x1F) << 16) | (*(unsigned __int8 *)(a1 + v4) << 8) | *(unsigned __int8 *)(v3 + a1 + 2);
        *a2 = v3 + 3;
      }
    }
    else
    {
      result = *(unsigned __int8 *)(a1 + v4) | ((result & 0x3F) << 8);
      *a2 = v3 + 2;
    }
  }
  else
  {
    *a2 = v4;
  }
  return result;
}

void index_optimize_disk_space(uint64_t a1)
{
  unsigned int *v3;
  __int16 v4;
  char v5;
  int v6;
  NSObject *v7;
  const char *v8;
  _BYTE *v9;
  _QWORD *v10;
  double Current;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  pthread_override_s *v15;
  char v16;
  pthread_override_s *v17;
  char v18;
  pthread_override_s *v19;
  char v20;
  int v21;
  NSObject *v22;
  os_log_type_t v23;
  float v24;
  uint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  char v28;
  stat v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  if (atomic_load((unsigned int *)(a1 + 15152)))
    return;
  if (!*(_BYTE *)(a1 + 8))
  {
    v6 = *__error();
    v7 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      v29.st_dev = 136315650;
      *(_QWORD *)&v29.st_mode = "index_optimize_disk_space";
      WORD2(v29.st_ino) = 1024;
      *(_DWORD *)((char *)&v29.st_ino + 6) = 6135;
      HIWORD(v29.st_uid) = 2080;
      *(_QWORD *)&v29.st_gid = a1 + 15168;
      v8 = "%s:%d: invalid index: %s";
      goto LABEL_30;
    }
LABEL_10:
    *__error() = v6;
    return;
  }
  v3 = (unsigned int *)(a1 + 28);
  v4 = atomic_load((unsigned int *)(a1 + 28));
  if ((v4 & 0x100) != 0)
  {
    v6 = *__error();
    v7 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      v29.st_dev = 136315650;
      *(_QWORD *)&v29.st_mode = "index_optimize_disk_space";
      WORD2(v29.st_ino) = 1024;
      *(_DWORD *)((char *)&v29.st_ino + 6) = 6139;
      HIWORD(v29.st_uid) = 2080;
      *(_QWORD *)&v29.st_gid = a1 + 15168;
      v8 = "%s:%d: index alreay compact: %s";
      goto LABEL_30;
    }
    goto LABEL_10;
  }
  v5 = atomic_load(v3);
  if ((v5 & 2) == 0)
  {
    v6 = *__error();
    v7 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      v29.st_dev = 136315650;
      *(_QWORD *)&v29.st_mode = "index_optimize_disk_space";
      WORD2(v29.st_ino) = 1024;
      *(_DWORD *)((char *)&v29.st_ino + 6) = 6143;
      HIWORD(v29.st_uid) = 2080;
      *(_QWORD *)&v29.st_gid = a1 + 15168;
      v8 = "%s:%d: cant optimize writable index: %s";
LABEL_30:
      _os_log_error_impl(&dword_1B8270000, v7, OS_LOG_TYPE_ERROR, v8, (uint8_t *)&v29, 0x1Cu);
      goto LABEL_10;
    }
    goto LABEL_10;
  }
  v9 = (_BYTE *)(a1 + 14676);
  v10 = (_QWORD *)(a1 + 4856);
  Current = CFAbsoluteTimeGetCurrent();
  v25 = 0;
  v26 = &v25;
  v27 = 0x2000000000;
  v28 = 0;
  v12 = *(unsigned int *)(a1 + 56);
  memset(&v29, 0, sizeof(v29));
  if (!fstat(v12, &v29))
  {
    v13 = open(".", 4);
    if (MEMORY[0x1BCCB1484](v12))
    {
      if ((v13 & 0x80000000) != 0)
        goto LABEL_18;
      goto LABEL_17;
    }
    _os_feature_enabled_impl();
    MEMORY[0x1BCCB1484](v13);
    if ((v13 & 0x80000000) == 0)
    {
LABEL_17:
      close(v13);
      goto LABEL_18;
    }
  }
  do
LABEL_18:
    v14 = __ldaxr(v3);
  while (__stlxr(v14 | 0x100, v3));
  if (*((_BYTE *)v26 + 24))
  {
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 4680));
    *(_DWORD *)(a1 + 4884) = 0;
    v15 = *(pthread_override_s **)(a1 + 4856);
    *v10 = 0;
    *(_QWORD *)(a1 + 4864) = 0;
    v16 = *(_DWORD *)(a1 + 4876) != 0;
    *(_BYTE *)(a1 + 4892) = 0;
    db_rwlock_wakeup(a1 + 4680, v16, 0);
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 4680));
    if (v15)
      pthread_override_qos_class_end_np(v15);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 14464));
    *(_DWORD *)(a1 + 14668) = 0;
    v17 = *(pthread_override_s **)(a1 + 14640);
    *(_QWORD *)(a1 + 14648) = 0;
    *(_QWORD *)(a1 + 14640) = 0;
    v18 = *(_DWORD *)(a1 + 14660) != 0;
    *v9 = 0;
    db_rwlock_wakeup(a1 + 14464, v18, 0);
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 14464));
    if (v17)
      pthread_override_qos_class_end_np(v17);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 14680));
    *(_DWORD *)(a1 + 14884) = 0;
    v19 = *(pthread_override_s **)(a1 + 14856);
    *(_QWORD *)(a1 + 14856) = 0;
    *(_QWORD *)(a1 + 14864) = 0;
    v20 = *(_DWORD *)(a1 + 14876) != 0;
    *(_BYTE *)(a1 + 14892) = 0;
    db_rwlock_wakeup(a1 + 14680, v20, 0);
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 14680));
    if (v19)
      pthread_override_qos_class_end_np(v19);
  }
  v21 = *__error();
  v22 = _SILogForLogForCategory(10);
  v23 = 2 * (dword_1EF19FCB4 < 4);
  if (os_log_type_enabled(v22, v23))
  {
    v24 = CFAbsoluteTimeGetCurrent() - Current;
    v29.st_dev = 134217984;
    *(double *)&v29.st_mode = v24;
    _os_log_impl(&dword_1B8270000, v22, v23, "index_optimize time (%f)", (uint8_t *)&v29, 0xCu);
  }
  *__error() = v21;
  _Block_object_dispose(&v25, 8);
}

void si_analytics_log_2520(char *a1, ...)
{
  xpc_object_t v1;
  xpc_object_t v2;
  char *string[2];
  xpc_object_t values;
  _BYTE keys[24];
  uint64_t v6;
  va_list va;

  va_start(va, a1);
  v6 = *MEMORY[0x1E0C80C00];
  string[0] = 0;
  va_copy((va_list)&string[1], va);
  vasprintf(string, a1, va);
  SISetCrashCStr(string[0]);
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)keys = 136315138;
    *(char **)&keys[4] = string[0];
    _os_log_fault_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "%s", keys, 0xCu);
  }
  *(_QWORD *)keys = "crash_string";
  v1 = xpc_string_create(string[0]);
  values = v1;
  v2 = xpc_dictionary_create((const char *const *)keys, &values, 1uLL);
  analytics_send_event();
  xpc_release(v2);
  xpc_release(v1);
  free(string[0]);
}

uint64_t _excCompactMatch(uint64_t a1, unint64_t a2)
{
  unint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  char *v21;
  size_t v22;
  uint64_t v23;
  const char *v24;
  unint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  char *v33;
  size_t v34;
  unint64_t v35;
  uint64_t v36;
  _QWORD *v37;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;
  int v41;
  uint64_t v42;
  char *v43;
  size_t v44;
  uint64_t v46;
  uint64_t v47;
  const char *v48;
  char __str[16];
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  uint64_t v65;

  v65 = *MEMORY[0x1E0C80C00];
  v4 = *(unsigned int *)(a1 + 240);
  if ((int)v4 >= 1)
  {
    v5 = 33;
    do
    {
      v6 = *(_QWORD **)(a1 + 8 * v5);
      if (v6 && (v7 = v6[1], v7 + 1 >= 2) && v7 <= a2 && (v9 = v6[2], v7 - v9 + v6[3] > a2))
        v8 = a2 - v7 + v9;
      else
        v8 = -1;
      if (v5 - 32 >= v4)
        break;
      ++v5;
    }
    while (v8 == -1);
    if (v8 != -1)
      return 1;
  }
  v10 = *(_QWORD *)(a1 + 4448);
  if (v10 + 1 >= 2 && v10 <= a2)
  {
    v46 = *(_QWORD *)(a1 + 4472);
    if (v10 + v46 > a2)
    {
      v47 = *(_QWORD *)(a1 + 4544);
      v48 = "bases";
LABEL_80:
      log_map_access_error(a2, v10, v46, (uint64_t)v48, v47);
      return 1;
    }
  }
  v10 = *(_QWORD *)(a1 + 4440);
  if (v10 + 1 >= 2 && v10 <= a2)
  {
    v46 = *(unsigned int *)(a1 + 4580);
    if (v10 + 1028 * v46 > a2)
    {
      v47 = *(_QWORD *)(a1 + 9000);
      v48 = "fat bases";
      goto LABEL_80;
    }
  }
  v13 = *(unsigned int *)(a1 + 4832);
  if ((int)v13 >= 1)
  {
    v14 = 607;
    do
    {
      v15 = *(_QWORD **)(a1 + 8 * v14);
      if (v15 && (v16 = v15[1], v16 + 1 >= 2) && v16 <= a2 && (v17 = v15[2], v16 - v17 + v15[3] > a2))
        v18 = a2 - v16 + v17;
      else
        v18 = -1;
      if (v14 - 606 >= v13)
        break;
      ++v14;
    }
    while (v18 == -1);
    if (v18 != -1)
    {
      v63 = 0u;
      v64 = 0u;
      v61 = 0u;
      v62 = 0u;
      v59 = 0u;
      v60 = 0u;
      v57 = 0u;
      v58 = 0u;
      v55 = 0u;
      v56 = 0u;
      v53 = 0u;
      v54 = 0u;
      v51 = 0u;
      v52 = 0u;
      *(_OWORD *)__str = 0u;
      v50 = 0u;
      v19 = snprintf(__str, 0xFFuLL, "c:%d s:%lld", v13, *(_QWORD *)(a1 + 4816));
      if (*(int *)(a1 + 4832) >= 1 && v19 <= 0xFE)
      {
        v20 = 0;
        v21 = &__str[v19];
        v22 = 255 - v19;
        do
        {
          snprintf(v21, v22, "%d:(mem:%p so:%lld eo:%lld)", v20, *(const void **)(*(_QWORD *)(a1 + 4856 + 8 * v20) + 8), *(_QWORD *)(*(_QWORD *)(a1 + 4856 + 8 * v20) + 16), *(_QWORD *)(*(_QWORD *)(a1 + 4856 + 8 * v20) + 24));
          ++v20;
        }
        while (v20 < *(int *)(a1 + 4832));
      }
      v23 = *(_QWORD *)(a1 + 4808);
      v24 = "flat\n";
LABEL_73:
      log_map_access_error_mini((uint64_t)v24, a2, (uint64_t)__str, v23);
      return 1;
    }
  }
  v25 = *(unsigned int *)(a1 + 9520);
  if ((int)v25 >= 1)
  {
    v26 = 1193;
    do
    {
      v27 = *(_QWORD **)(a1 + 8 * v26);
      if (v27 && (v28 = v27[1], v28 + 1 >= 2) && v28 <= a2 && (v30 = v27[2], v28 - v30 + v27[3] > a2))
        v29 = a2 - v28 + v30;
      else
        v29 = -1;
      if (v26 - 1192 >= v25)
        break;
      ++v26;
    }
    while (v29 == -1);
    if (v29 != -1)
    {
      v63 = 0u;
      v64 = 0u;
      v61 = 0u;
      v62 = 0u;
      v59 = 0u;
      v60 = 0u;
      v57 = 0u;
      v58 = 0u;
      v55 = 0u;
      v56 = 0u;
      v53 = 0u;
      v54 = 0u;
      v51 = 0u;
      v52 = 0u;
      *(_OWORD *)__str = 0u;
      v50 = 0u;
      v31 = snprintf(__str, 0xFFuLL, "c:%d s:%lld", v25, *(_QWORD *)(a1 + 9504));
      if (*(int *)(a1 + 9520) >= 1 && v31 <= 0xFE)
      {
        v32 = 0;
        v33 = &__str[v31];
        v34 = 255 - v31;
        do
        {
          snprintf(v33, v34, "%d:(mem:%p so:%lld eo:%lld)", v32, *(const void **)(*(_QWORD *)(a1 + 9544 + 8 * v32) + 8), *(_QWORD *)(*(_QWORD *)(a1 + 9544 + 8 * v32) + 16), *(_QWORD *)(*(_QWORD *)(a1 + 9544 + 8 * v32) + 24));
          ++v32;
        }
        while (v32 < *(int *)(a1 + 9520));
      }
      v23 = *(_QWORD *)(a1 + 9496);
      v24 = "termIdStore\n";
      goto LABEL_73;
    }
  }
  v35 = *(unsigned int *)(a1 + 14232);
  if ((int)v35 >= 1)
  {
    v36 = 1782;
    do
    {
      v37 = *(_QWORD **)(a1 + 8 * v36);
      if (v37 && (v38 = v37[1], v38 + 1 >= 2) && v38 <= a2 && (v40 = v37[2], v38 - v40 + v37[3] > a2))
        v39 = a2 - v38 + v40;
      else
        v39 = -1;
      if (v36 - 1781 >= v35)
        break;
      ++v36;
    }
    while (v39 == -1);
    if (v39 != -1)
    {
      v63 = 0u;
      v64 = 0u;
      v61 = 0u;
      v62 = 0u;
      v59 = 0u;
      v60 = 0u;
      v57 = 0u;
      v58 = 0u;
      v55 = 0u;
      v56 = 0u;
      v53 = 0u;
      v54 = 0u;
      v51 = 0u;
      v52 = 0u;
      *(_OWORD *)__str = 0u;
      v50 = 0u;
      v41 = snprintf(__str, 0xFFuLL, "c:%d s:%lld", v35, *(_QWORD *)(a1 + 14216));
      if (*(int *)(a1 + 14232) >= 1 && v41 <= 0xFE)
      {
        v42 = 0;
        v43 = &__str[v41];
        v44 = 255 - v41;
        do
        {
          snprintf(v43, v44, "%d:(mem:%p so:%lld eo:%lld)", v42, *(const void **)(*(_QWORD *)(a1 + 14256 + 8 * v42) + 8), *(_QWORD *)(*(_QWORD *)(a1 + 14256 + 8 * v42) + 16), *(_QWORD *)(*(_QWORD *)(a1 + 14256 + 8 * v42) + 24));
          ++v42;
        }
        while (v42 < *(int *)(a1 + 14232));
      }
      v23 = *(_QWORD *)(a1 + 14208);
      v24 = "positions header table\n";
      goto LABEL_73;
    }
  }
  return 0;
}

void _excCompactCleanup(uint64_t a1)
{
  _QWORD *v2;
  const void *v3;
  uint64_t v4;

  storageClose(a1);
  bt_freeTrie(a1 + 4432);
  freePayload(a1 + 13952);
  freePayload(a1 + 9240);
  v2 = *(_QWORD **)(a1 + 4416);
  if (v2)
  {
    storageClose((uint64_t)(v2 + 1));
    v3 = (const void *)v2[549];
    if (v3)
      CFRelease(v3);
    free(v2);
    *(_QWORD *)(a1 + 4416) = 0;
  }
  v4 = *(_QWORD *)(a1 + 4424);
  if (v4)
  {
    IVFVectorIndex_s::~IVFVectorIndex_s((void **)(v4 + 8));
    MEMORY[0x1BCCB06A4](v4, 0x1032C4065068D8BLL);
    *(_QWORD *)(a1 + 4424) = 0;
  }
}

void _initPayload(char *a1, int a2)
{
  pthread_rwlockattr_t v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    bzero(a1, 0x1268uLL);
    *((_DWORD *)a1 + 1122) = -1;
    memset(&v3, 0, sizeof(v3));
    pthread_rwlockattr_init(&v3);
    pthread_rwlock_init((pthread_rwlock_t *)(a1 + 4512), &v3);
    pthread_rwlockattr_destroy(&v3);
    bzero(a1 + 40, 0x1158uLL);
  }
  else
  {
    *((_DWORD *)a1 + 1122) = -1;
    memset(&v3, 0, sizeof(v3));
    pthread_rwlockattr_init(&v3);
    pthread_rwlock_init((pthread_rwlock_t *)(a1 + 4512), &v3);
    pthread_rwlockattr_destroy(&v3);
  }
}

uint64_t initPayload(uint64_t a1, uint64_t a2, uint64_t a3, char a4, int a5, int a6, void *a7)
{
  uint64_t v11;
  _BYTE *v13;
  int8x16_t *v14;
  off_t v15;
  int8x16_t *v16;
  uint64_t v17;
  int v18;
  char v19;
  uint64_t result;
  uint64_t v21;
  int v22;
  int v23;
  int v24;
  int v25;
  NSObject *v26;
  int v27;
  int *v28;
  int v29;
  _BYTE v30[12];
  __int16 v31;
  int v32;
  __int16 v33;
  int v34;
  uint64_t v35;

  v11 = a2;
  v35 = *MEMORY[0x1E0C80C00];
  v13 = (_BYTE *)(a1 + 4508);
  *(_QWORD *)(a1 + 4480) = a2;
  v14 = (int8x16_t *)(a1 + 40);
  *(_QWORD *)(a1 + 256) = a3;
  *(_BYTE *)(a1 + 4509) = a5;
  v15 = *(_QWORD *)(a1 + 24);
  if (v15)
  {
    if ((a4 & 1) != 0)
    {
LABEL_8:
      if (!a3)
        return 1;
      v16 = v14;
      v17 = a3;
      v18 = 0;
      v19 = a4;
      return termIDStoreInit(v16, v17, v18, v19, a6, a7);
    }
    if (a5)
    {
      if (v11)
      {
        *(_WORD *)(v11 + 56) |= 4u;
        v11 = *(_QWORD *)(a1 + 4480);
        v15 = *(_QWORD *)(a1 + 24);
      }
    }
    if (fd_truncate(v11, v15) != -1)
    {
      *v13 = 1;
      goto LABEL_8;
    }
    v25 = *__error();
    v26 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      v27 = *__error();
      *(_DWORD *)v30 = 136315650;
      *(_QWORD *)&v30[4] = "initPayload";
      v31 = 1024;
      v32 = 117;
      v33 = 1024;
      v34 = v27;
LABEL_28:
      _os_log_error_impl(&dword_1B8270000, v26, OS_LOG_TYPE_ERROR, "%s:%d: ftruncate err: %d", v30, 0x18u);
    }
  }
  else
  {
    if ((a4 & 1) != 0)
      return 0;
    if (a5 && v11)
    {
      *(_WORD *)(v11 + 56) |= 4u;
      v11 = *(_QWORD *)(a1 + 4480);
    }
    *(_QWORD *)v30 = 0;
    v21 = _fd_acquire_fd(v11, v30);
    if ((_DWORD)v21 != -1)
    {
      v22 = v21;
      v23 = _fd_ftruncate_guarded(v21, (uint64_t)v30, 0);
      v24 = *__error();
      *(_WORD *)(v11 + 56) &= ~2u;
      _fd_release_fd((_DWORD *)v11, v22, 0, *(uint64_t *)v30);
      if (v23 == -1)
        *__error() = v24;
    }
    if (fd_truncate(*(_QWORD *)(a1 + 4480), 4096) != -1)
    {
      *v13 = 1;
      *(_OWORD *)a1 = xmmword_1B8631CC0;
      *(int64x2_t *)(a1 + 24) = vdupq_n_s64(0x1000uLL);
      v16 = v14;
      v17 = a3;
      v18 = 1;
      v19 = 0;
      return termIDStoreInit(v16, v17, v18, v19, a6, a7);
    }
    v25 = *__error();
    v26 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      v29 = *__error();
      *(_DWORD *)v30 = 136315650;
      *(_QWORD *)&v30[4] = "initPayload";
      v31 = 1024;
      v32 = 101;
      v33 = 1024;
      v34 = v29;
      goto LABEL_28;
    }
  }
  v28 = __error();
  result = 0;
  *v28 = v25;
  return result;
}

uint64_t freePayload(uint64_t a1)
{
  int v2;
  NSObject *v3;
  os_log_type_t v4;
  unint64_t v5;
  double v6;
  int v7;
  const void *v8;
  int v10;
  unint64_t v11;
  __int16 v12;
  double v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v2 = *__error();
  v3 = _SILogForLogForCategory(10);
  v4 = 2 * (dword_1EF19FCB4 < 4);
  if (os_log_type_enabled(v3, v4))
  {
    v5 = *(_QWORD *)(a1 + 24);
    v6 = (double)(*(_QWORD *)a1 + v5 - *(_QWORD *)(a1 + 8)) * 100.0 / (double)v5;
    v10 = 134218240;
    v11 = v5 >> 10;
    v12 = 2048;
    v13 = v6;
    _os_log_impl(&dword_1B8270000, v3, v4, "Payloads: %lluKB %f", (uint8_t *)&v10, 0x16u);
  }
  *__error() = v2;
  v7 = *(_DWORD *)(a1 + 4488);
  if (v7 != -1)
  {
    _fd_release_fd(*(_DWORD **)(a1 + 4480), v7, 0, *(_QWORD *)(a1 + 4496));
    *(_DWORD *)(a1 + 4488) = -1;
  }
  fd_release(*(char **)(a1 + 4480));
  *(_QWORD *)(a1 + 4480) = 0;
  storageClose(a1 + 40);
  storageClose(a1 + 40);
  v8 = *(const void **)(a1 + 4472);
  if (v8)
  {
    CFRelease(v8);
    *(_QWORD *)(a1 + 4472) = 0;
  }
  *(_OWORD *)(a1 + 4456) = 0u;
  return pthread_rwlock_destroy((pthread_rwlock_t *)(a1 + 4512));
}

uint64_t syncPayload(uint64_t a1)
{
  _BYTE *v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  int v6;
  _BOOL4 v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  _DWORD *v13;
  uint64_t v14;
  int v15;
  uint64_t v17;

  v2 = (_BYTE *)(a1 + 4508);
  v3 = *(_QWORD *)(a1 + 4480);
  if (*(_BYTE *)(a1 + 4508))
  {
    v4 = *(unsigned __int8 *)(a1 + 4509);
    v17 = 0;
    v5 = _fd_acquire_fd(v3, &v17);
    if ((_DWORD)v5 != -1)
    {
      v6 = v5;
      v7 = v4 && (*(_WORD *)(v3 + 56) & 8) == 0;
      v11 = prot_fsync(v5, v7);
      _fd_release_fd((_DWORD *)v3, v6, 0, v17);
      if (v11 != -1)
      {
        *v2 = 0;
        goto LABEL_11;
      }
    }
    return *__error();
  }
  v17 = 0;
  v8 = _fd_acquire_fd(v3, &v17);
  if ((_DWORD)v8 == -1)
    return *__error();
  v9 = v8;
  v10 = prot_fsync(v8, 0);
  _fd_release_fd((_DWORD *)v3, v9, 0, v17);
  if (v10 == -1)
    return *__error();
LABEL_11:
  v12 = storageSyncPages(a1 + 40, a1 + 4456, *MEMORY[0x1E0C85AD8]);
  v13 = *(_DWORD **)(a1 + 256);
  if (v13)
  {
    v17 = 0;
    v14 = _fd_acquire_fd((uint64_t)v13, &v17);
    if ((_DWORD)v14 != -1)
    {
      v15 = v14;
      prot_fsync(v14, 0);
      _fd_release_fd(v13, v15, 0, v17);
    }
  }
  return v12;
}

uint64_t expandPayload(uint64_t a1, uint64_t (*a2)(uint64_t), uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t (*v8)(uint64_t);
  off_t v9;
  uint64_t v10;
  off_t v11;
  int v12;
  int v13;
  uint64_t v14;
  off_t v15;
  const char *v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  int *v20;
  uint64_t v21;
  uint64_t v22;
  off_t v23;
  int v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  const char *v29;
  unint64_t v30;
  uint64_t v31;
  int *v32;
  int v33;
  int v34;
  NSObject *v35;
  _DWORD *v37;
  int v38;
  const char *v39;
  int v40;
  int v41;
  BOOL v42;
  const char *v43;
  uint64_t v44;
  _BYTE buf[12];
  __int16 v48;
  int v49;
  __int16 v50;
  const char *v51;
  __int16 v52;
  uint64_t v53;
  __int16 v54;
  int v55;
  _BYTE v56[1024];
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a1 + 24);
  v5 = 2 * v4;
  *(_QWORD *)(a1 + 24) = 2 * v4;
  *(_QWORD *)a1 = v4;
  *(_QWORD *)(a1 + 8) = 2 * v4;
  v6 = (_QWORD *)(a1 + 4496);
  if (a2)
  {
    v7 = a3;
    v8 = a2;
    while (1)
    {
      v9 = *(_QWORD *)(a1 + 24);
      v10 = _fd_acquire_fd(*(_QWORD *)(a1 + 4480), v6);
      v11 = lseek(v10, 0, 2);
      if (v9 <= v11 || (v12 = ci_preallocate(v10, v9 - v11), v12 == -1))
      {
        v13 = fd_truncate(*(_QWORD *)(a1 + 4480), *(_QWORD *)(a1 + 24));
      }
      else
      {
        v13 = v12;
        v14 = 0;
        v15 = v9 - 1;
        v16 = "";
        v17 = 1;
        while (1)
        {
          while (1)
          {
            v18 = guarded_pwrite_np();
            if ((v18 & 0x8000000000000000) == 0)
              break;
            v19 = g_prot_error_callback;
            if (g_prot_error_callback)
            {
              v20 = __error();
              if (((*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t))(v19 + 16))(v19, v10, *v20, 5) & 1) != 0)continue;
            }
            v13 = -1;
            goto LABEL_15;
          }
          v14 += v18;
          v42 = v17 > v18;
          v17 -= v18;
          if (!v42)
            break;
          v16 += v18;
          v15 += v18;
        }
        if (v14 != 1)
          v13 = -1;
LABEL_15:
        v8 = a2;
        v7 = a3;
      }
      _fd_release_fd(*(_DWORD **)(a1 + 4480), v10, 0, *(_QWORD *)(a1 + 4496));
      if (v13 != -1)
        break;
      v21 = *__error();
      if ((_DWORD)v21 != 28)
        goto LABEL_37;
      if ((v8(v7) & 1) == 0)
      {
        v21 = 28;
        goto LABEL_37;
      }
    }
LABEL_35:
    v21 = 0;
    *(_BYTE *)(a1 + 4508) = 1;
    return v21;
  }
  v22 = _fd_acquire_fd(*(_QWORD *)(a1 + 4480), v6);
  v23 = lseek(v22, 0, 2);
  if (v5 <= v23 || (v24 = ci_preallocate(v22, v5 - v23), v24 == -1))
  {
    v33 = fd_truncate(*(_QWORD *)(a1 + 4480), *(_QWORD *)(a1 + 24));
  }
  else
  {
    v25 = v24;
    v26 = 0;
    v27 = v5 - 1;
    v28 = 1;
    v29 = "";
    while (1)
    {
      while (1)
      {
        v30 = guarded_pwrite_np();
        if ((v30 & 0x8000000000000000) == 0)
          break;
        v31 = g_prot_error_callback;
        if (g_prot_error_callback)
        {
          v32 = __error();
          if (((*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t))(v31 + 16))(v31, v22, *v32, 5) & 1) != 0)continue;
        }
        v33 = -1;
        goto LABEL_34;
      }
      v26 += v30;
      v42 = v28 > v30;
      v28 -= v30;
      if (!v42)
        break;
      v29 += v30;
      v27 += v30;
    }
    if (v26 == 1)
      v33 = v25;
    else
      v33 = -1;
  }
LABEL_34:
  _fd_release_fd(*(_DWORD **)(a1 + 4480), v22, 0, *(_QWORD *)(a1 + 4496));
  if (v33 != -1)
    goto LABEL_35;
  v21 = *__error();
LABEL_37:
  bzero(v56, 0x400uLL);
  v34 = *__error();
  v35 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
  {
    v37 = *(_DWORD **)(a1 + 4480);
    *(_QWORD *)buf = 0;
    v38 = _fd_acquire_fd((uint64_t)v37, buf);
    v39 = 0;
    if (v38 != -1)
    {
      v40 = v38;
      v39 = v56;
      v41 = fcntl(v38, 50, v56);
      if (v56[0])
        v42 = v41 < 0;
      else
        v42 = 1;
      if (v42)
        v39 = 0;
      _fd_release_fd(v37, v40, 0, *(uint64_t *)buf);
    }
    v43 = "";
    v44 = *(_QWORD *)(a1 + 24);
    if (v39)
      v43 = v39;
    *(_DWORD *)buf = 136316162;
    *(_QWORD *)&buf[4] = "expandPayload";
    v48 = 1024;
    v49 = 207;
    v50 = 2080;
    v51 = v43;
    v52 = 2048;
    v53 = v44;
    v54 = 1024;
    v55 = v21;
    _os_log_error_impl(&dword_1B8270000, v35, OS_LOG_TYPE_ERROR, "%s:%d: ftruncate(%s, %lld) err: %d", buf, 0x2Cu);
  }
  *__error() = v34;
  return v21;
}

int *_PayloadWriteData_2575(int *result, _QWORD *a2, char *a3, int64_t a4)
{
  int *v5;
  char *v6;
  int64_t v7;
  int64_t v9;
  size_t v10;
  size_t v11;
  char *v12;
  char *v13;
  const char *v14;

  v5 = result;
  v6 = &a3[a4];
  if (a4)
  {
    v7 = a4;
    do
    {
      if (*((_QWORD *)v5 + 4))
        break;
      v9 = *((_QWORD *)v5 + 3);
      if (v7 >= v9)
        v10 = *((_QWORD *)v5 + 3);
      else
        v10 = v7;
      a2[1] -= v10;
      v11 = v9 - v10;
      *((_QWORD *)v5 + 3) = v11;
      v6 -= v10;
      result = (int *)memcpy((void *)(*(_QWORD *)v5 + v11), v6, v10);
      if (!*((_QWORD *)v5 + 3))
        result = PayloadWriteBufferWrite(v5, a2);
      v7 -= v10;
    }
    while (v7);
  }
  if (v6 != a3 && !*((_QWORD *)v5 + 4))
  {
    v12 = __si_assert_copy_extra_268();
    v13 = v12;
    v14 = "";
    if (v12)
      v14 = v12;
    __message_assert("%s:%u: failed assertion '%s' %s ", "JHPayload.h", 146, "src == ptr || wb->err", v14);
    free(v13);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  return result;
}

uint64_t growPayloadData(uint64_t a1)
{
  uint64_t v1;
  uint64_t (*v2)(uint64_t);
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t i;
  uint64_t v8;
  _BYTE *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  int *v14;
  BOOL v15;
  char *v17;
  char *v18;
  const char *v19;
  uint64_t (*v20)(uint64_t);
  uint64_t v21;
  uint64_t v22;
  _BYTE v23[4096];
  uint64_t v24;

  v1 = MEMORY[0x1E0C80A78](a1);
  v20 = v2;
  v21 = v3;
  v4 = (uint64_t *)v1;
  v24 = *MEMORY[0x1E0C80C00];
  bzero(v23, 0x1000uLL);
  v5 = *v4;
  v6 = v4[1] - *v4;
  v22 = (uint64_t)v4;
  for (i = _fd_acquire_fd(v4[560], v4 + 562); v6; v6 -= v8)
  {
    if (v6 >= 0x1000)
      v8 = 4096;
    else
      v8 = v6;
    v9 = v23;
    v10 = v8;
    v11 = v5;
    do
    {
      while (1)
      {
        v12 = guarded_pwrite_np();
        if ((v12 & 0x8000000000000000) != 0)
          break;
        v15 = v10 > v12;
        v10 -= v12;
        if (!v15)
          goto LABEL_3;
        v9 += v12;
        v11 += v12;
      }
      v13 = g_prot_error_callback;
      if (!g_prot_error_callback)
        break;
      v14 = __error();
    }
    while (((*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t))(v13 + 16))(v13, i, *v14, 5) & 1) != 0);
LABEL_3:
    v5 += v8;
  }
  _fd_release_fd(*(_DWORD **)(v22 + 4480), i, 0, *(_QWORD *)(v22 + 4496));
  if (v5 != *(_QWORD *)(v22 + 8))
  {
    v17 = __si_assert_copy_extra_268();
    v18 = v17;
    v19 = "";
    if (v17)
      v19 = v17;
    __message_assert("%s:%u: failed assertion '%s' %s ", "JHPayload.c", 375, "pos == pd->payloadIndex", v19);
    free(v18);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  return expandPayload(v22, v20, v21);
}

void si_analytics_log_2584(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  void *v9[2];
  uint8_t buf[4];
  void *v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v9[0] = 0;
  v9[1] = &a9;
  vasprintf((char **)v9, "%u term ids out of range", &a9);
  SISetCrashCStr((const char *)v9[0]);
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)buf = 136315138;
    v11 = v9[0];
    _os_log_fault_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "%s", buf, 0xCu);
  }
  free(v9[0]);
}

uint64_t packUpdateLink(uint64_t a1, unint64_t a2, uint64_t a3, unsigned int a4)
{
  int v4;
  unint64_t v6;
  uint64_t v7;
  uint64x2_t v8;
  int32x2_t v9;
  uint64x2_t v10;
  int32x2_t v11;
  uint64x2_t v12;
  int16x8_t v13;
  uint64x2_t v14;
  int16x8_t v15;
  uint64_t v16;
  char v17;

  v4 = a3;
  v6 = 2 * a2;
  if ((a2 >> 31))
  {
    if ((v6 & 0x8000000000000000) != 0)
    {
      v10 = (uint64x2_t)vdupq_n_s64(v6);
      v11.i32[0] = 2 * a2;
      v11.i32[1] = v6 >> 7;
      *(int8x8_t *)(a1 + 20) = vorr_s8(vmovn_s16(vuzp1q_s16((int16x8_t)vmovn_hight_s64(v11, (int64x2_t)vshlq_u64(v10, (uint64x2_t)xmmword_1B8631B60)), (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v10, (uint64x2_t)xmmword_1B8631B70), (int32x4_t)vshlq_u64(v10, (uint64x2_t)xmmword_1B8631B80)))), (int8x8_t)0x8080808080808080);
      *(_BYTE *)(a1 + 28) = HIBYTE(v6) | 0x80;
      LOBYTE(v6) = 1;
      v7 = 29;
    }
    else if ((v6 & 0x7F00000000000000) != 0)
    {
      v8 = (uint64x2_t)vdupq_n_s64(v6);
      v9.i32[0] = 2 * a2;
      v9.i32[1] = v6 >> 7;
      *(int8x8_t *)(a1 + 20) = vorr_s8(vmovn_s16(vuzp1q_s16((int16x8_t)vmovn_hight_s64(v9, (int64x2_t)vshlq_u64(v8, (uint64x2_t)xmmword_1B8631B60)), (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v8, (uint64x2_t)xmmword_1B8631B70), (int32x4_t)vshlq_u64(v8, (uint64x2_t)xmmword_1B8631B80)))), (int8x8_t)0x8080808080808080);
      v6 = (v6 & 0x7F00000000000000) >> 56;
      v7 = 28;
    }
    else if ((v6 & 0xFE000000000000) != 0)
    {
      *(_BYTE *)(a1 + 20) = v6 | 0x80;
      v12 = (uint64x2_t)vdupq_n_s64(v6);
      v13 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v12, (uint64x2_t)xmmword_1B8631BA0), (int32x4_t)vshlq_u64(v12, (uint64x2_t)xmmword_1B8631B90));
      v13.i64[0] = *(_QWORD *)&vmovn_s32((int32x4_t)v13) | 0x80008000800080;
      *(_DWORD *)(a1 + 21) = vmovn_s16(v13).u32[0];
      *(_BYTE *)(a1 + 25) = (v6 >> 35) | 0x80;
      *(_BYTE *)(a1 + 26) = (v6 >> 42) | 0x80;
      v6 = (v6 & 0xFE000000000000) >> 49;
      v7 = 27;
    }
    else
    {
      *(_BYTE *)(a1 + 20) = v6 | 0x80;
      v14 = (uint64x2_t)vdupq_n_s64(v6);
      v15 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v14, (uint64x2_t)xmmword_1B8631BA0), (int32x4_t)vshlq_u64(v14, (uint64x2_t)xmmword_1B8631B90));
      v15.i64[0] = *(_QWORD *)&vmovn_s32((int32x4_t)v15) | 0x80008000800080;
      *(_DWORD *)(a1 + 21) = vmovn_s16(v15).u32[0];
      if ((v6 & 0x1FC0000000000) != 0)
      {
        *(_BYTE *)(a1 + 25) = (v6 >> 35) | 0x80;
        v6 = (v6 & 0x1FC0000000000) >> 42;
        v7 = 26;
      }
      else
      {
        v6 = (v6 >> 35) & 0x7F;
        v7 = 25;
      }
    }
  }
  else if ((v6 & 0x7F0000000) != 0)
  {
    *(_BYTE *)(a1 + 20) = v6 | 0x80;
    *(_BYTE *)(a1 + 21) = (v6 >> 7) | 0x80;
    *(_BYTE *)(a1 + 22) = (v6 >> 14) | 0x80;
    *(_BYTE *)(a1 + 23) = (v6 >> 21) | 0x80;
    v6 = (v6 & 0x7F0000000) >> 28;
    v7 = 24;
  }
  else if ((v6 & 0xFE00000) != 0)
  {
    *(_BYTE *)(a1 + 20) = v6 | 0x80;
    *(_BYTE *)(a1 + 21) = (v6 >> 7) | 0x80;
    *(_BYTE *)(a1 + 22) = (v6 >> 14) | 0x80;
    v6 = (v6 & 0xFE00000) >> 21;
    v7 = 23;
  }
  else if ((v6 & 0x1FC000) != 0)
  {
    *(_BYTE *)(a1 + 20) = v6 | 0x80;
    *(_BYTE *)(a1 + 21) = (v6 >> 7) | 0x80;
    v6 = (v6 & 0x1FC000) >> 14;
    v7 = 22;
  }
  else if ((v6 & 0x3F80) != 0)
  {
    *(_BYTE *)(a1 + 20) = v6 | 0x80;
    v6 = (v6 & 0x3F80) >> 7;
    v7 = 21;
  }
  else
  {
    v7 = 20;
  }
  *(_BYTE *)(a1 + v7) = v6;
  v16 = writeVInt64(a1, v7 + 1, 2 * __PAIR64__(a4, HIDWORD(a3)));
  *(_BYTE *)(a1 + v16) = 0;
  if (v4)
    v17 = 1;
  else
    v17 = 2;
  *(_BYTE *)(a1 + v16 + 1) = v17;
  return v16 + 2;
}

CFStringRef SICreateStringByRemovingWhitespaceFromTextContent(const __CFAllocator *a1, CFStringRef theString, CFIndex a3)
{
  CFStringRef result;
  uint64_t v7;
  const UniChar *CharactersPtr;
  const char *CStringPtr;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  UniChar v16;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  uint64_t v23;
  BOOL v24;
  BOOL v25;
  uint64_t v26;
  char *v27;
  size_t v28;
  int v29;
  char v30;
  CFIndex v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unsigned __int16 v37;
  char v38;
  CFIndex v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v46;
  uint64_t v47;
  const UniChar *v48;
  unsigned __int16 v49;
  uint64_t v50;
  uint64_t v51;
  CFStringRef v52;
  CFRange RangeOfComposedCharactersAtIndex;
  CFIndex v54;
  _QWORD v57[2];
  CFAllocatorRef v58;
  CFStringRef v59;
  _OWORD buffer[8];
  CFStringRef v61;
  const UniChar *v62;
  const char *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  CFRange v69;
  CFRange v70;
  CFRange v71;

  result = 0;
  v68 = *MEMORY[0x1E0C80C00];
  if (!theString)
    return result;
  if ((CFStringRef)*MEMORY[0x1E0C9B0D0] == theString)
    return result;
  result = (CFStringRef)CFStringGetLength(theString);
  if (!result)
    return result;
  v7 = (uint64_t)result;
  memset(buffer, 0, sizeof(buffer));
  v61 = theString;
  v64 = 0;
  v65 = (uint64_t)result;
  CharactersPtr = CFStringGetCharactersPtr(theString);
  CStringPtr = 0;
  v62 = CharactersPtr;
  if (!CharactersPtr)
    CStringPtr = CFStringGetCStringPtr(theString, 0x600u);
  v58 = a1;
  v66 = 0;
  v67 = 0;
  v63 = CStringPtr;
  v59 = theString;
  if (v7 < 1)
  {
    v12 = 0;
  }
  else
  {
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v13 = 64;
    while (1)
    {
      v14 = (unint64_t)v12 >= 4 ? 4 : v12;
      v15 = v65;
      if (v65 <= v12)
        break;
      if (v62)
      {
        v16 = v62[v12 + v64];
      }
      else if (v63)
      {
        v16 = v63[v64 + v12];
      }
      else
      {
        if (v67 <= v12 || v11 > v12)
        {
          v18 = v14 + v10;
          v19 = v13 - v14;
          v20 = v12 - v14;
          v21 = v20 + 64;
          if (v20 + 64 >= v65)
            v21 = v65;
          v66 = v20;
          v67 = v21;
          if (v65 >= v19)
            v15 = v19;
          v69.length = v15 + v18;
          v69.location = v20 + v64;
          CFStringGetCharacters(v61, v69, (UniChar *)buffer);
          v11 = v66;
        }
        v16 = *((_WORD *)buffer + v12 - v11);
      }
      v22 = v16;
      v23 = (1 << v16) & 0x100002600;
      v24 = v22 > 0x20 || v23 == 0;
      v25 = !v24 || v22 == 65532;
      if (!v25 && v22 != 160)
        break;
      ++v12;
      --v10;
      ++v13;
      if (v7 == v12)
      {
        v12 = v7;
        break;
      }
    }
  }
  MEMORY[0x1E0C80A78](CStringPtr);
  v27 = (char *)v57 - ((v26 + 21) & 0xFFFFFFFFFFFFFFF0);
  bzero(v27, v28);
  if (v12 >= v7)
    return 0;
  v57[1] = v57;
  v29 = 0;
  v30 = 0;
  v31 = 0;
  v32 = -v12;
  v33 = v12 + 64;
  do
  {
    if ((unint64_t)v12 >= 4)
      v34 = 4;
    else
      v34 = v12;
    if ((unint64_t)v12 >= 3)
      v35 = 3;
    else
      v35 = v12;
    v36 = v65;
    if (v65 <= v12)
    {
      v37 = 0;
LABEL_51:
      if (v29)
      {
        v39 = v31 + 1;
        *(_WORD *)&v27[2 * v31] = 8200;
        v38 = 0;
        if (v29 >= 2)
        {
          v29 = 0;
          v31 += 2;
          *(_WORD *)&v27[2 * v39] = 8200;
        }
        else
        {
          v29 = 0;
          ++v31;
        }
      }
      else
      {
        v38 = 0;
      }
      goto LABEL_86;
    }
    if (v62)
    {
      v37 = v62[v12 + v64];
    }
    else if (v63)
    {
      v37 = v63[v64 + v12];
    }
    else
    {
      if (v67 <= v12 || (v40 = v66, v66 > v12))
      {
        v41 = v34 + v32;
        v42 = v33 - v34;
        v43 = v12 - v34;
        v44 = v43 + 64;
        if (v43 + 64 >= v65)
          v44 = v65;
        v66 = v43;
        v67 = v44;
        if (v65 >= v42)
          v36 = v42;
        v70.length = v36 + v41;
        v70.location = v43 + v64;
        CFStringGetCharacters(v61, v70, (UniChar *)buffer);
        v40 = v66;
      }
      v37 = *((_WORD *)buffer + v12 - v40);
    }
    if (v37 > 0x1Fu)
    {
      if (v37 != 8204)
      {
        if (v37 != 160 && v37 != 32)
          goto LABEL_51;
LABEL_76:
        v38 = 1;
        if ((v30 & 1) != 0)
        {
          v30 = 1;
          goto LABEL_87;
        }
        v37 = 32;
LABEL_86:
        *(_WORD *)&v27[2 * v31++] = v37;
        v30 = v38;
        goto LABEL_87;
      }
      if (v30 & 1 | (v29 != 0))
        goto LABEL_87;
      v46 = v12 + 1;
      if (v12 + 1 >= v7)
      {
        v30 = 0;
        v29 = 0;
        goto LABEL_87;
      }
      v47 = v65;
      if (v65 <= v46)
      {
        v38 = 0;
        v29 = 0;
        v37 = 8204;
        goto LABEL_86;
      }
      if (v62)
      {
        v48 = &v62[v12 + v64];
      }
      else
      {
        if (v63)
        {
          v49 = v63[v64 + 1 + v12];
          goto LABEL_94;
        }
        if (v67 <= v46 || (v50 = v66, v66 > v46))
        {
          v51 = v12 - v35 + 64;
          if (v51 >= v65)
            v51 = v65;
          v66 = v12 - v35;
          v67 = v51;
          if (v65 >= v33 - v35)
            v47 = v33 - v35;
          v71.length = v47 + v35 + v32;
          v71.location = v12 - v35 + v64;
          CFStringGetCharacters(v61, v71, (UniChar *)buffer);
          v50 = v66;
        }
        v48 = (const UniChar *)buffer + v12 - v50;
      }
      v49 = v48[1];
LABEL_94:
      v38 = 0;
      if (v49 <= 0x20u && ((1 << v49) & 0x100002600) != 0 || v49 == 160 || v49 == 8204)
      {
        v30 = 0;
        v29 = 0;
        goto LABEL_87;
      }
      v37 = 8204;
      v29 = 0;
      goto LABEL_86;
    }
    if (v37 == 9)
      goto LABEL_76;
    if (v37 != 10 && v37 != 13)
      goto LABEL_51;
    v30 = 0;
    ++v29;
LABEL_87:
    if (++v12 >= v7)
      break;
    --v32;
    ++v33;
  }
  while (v31 < a3);
  if (v31 == v7)
  {
    v52 = v59;
    CFRetain(v59);
    return v52;
  }
  if (v12 < v7)
  {
    RangeOfComposedCharactersAtIndex = CFStringGetRangeOfComposedCharactersAtIndex(v59, v12 - 1);
    v54 = RangeOfComposedCharactersAtIndex.location - v12;
    if (RangeOfComposedCharactersAtIndex.location > v12
      || RangeOfComposedCharactersAtIndex.location < 0
      || RangeOfComposedCharactersAtIndex.length < 2)
    {
      v54 = 0;
    }
    v31 += v54;
  }
  if (v31 >= 1)
    return CFStringCreateWithCharacters(v58, (const UniChar *)v27, v31);
  return 0;
}

BOOL SIStringContainsNewlineCharacters(uint64_t a1, uint64_t a2)
{
  _BOOL8 result;
  uint64_t v5;
  BOOL v6;
  int v7;
  const __CFCharacterSet *Predefined;

  result = 0;
  if (a1 && a2)
  {
    if (a2 < 1)
    {
      return 0;
    }
    else
    {
      v5 = 0;
      v6 = 1;
      do
      {
        v7 = *(unsigned __int16 *)(a1 + 2 * v5);
        if (v7 == 9 || v7 == 8200)
          break;
        if (v7 == 12288)
          break;
        Predefined = CFCharacterSetGetPredefined(kCFCharacterSetNewline);
        if (CFCharacterSetIsCharacterMember(Predefined, *(_WORD *)(a1 + 2 * v5)))
          break;
        v6 = ++v5 < a2;
      }
      while (a2 != v5);
    }
    return v6;
  }
  return result;
}

__n128 L1RankQueuePop(__int128 *a1, __n128 **a2)
{
  __n128 *v2;
  __n128 result;
  __n128 *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  float v9;
  unsigned __int32 v10;
  float v11;
  unsigned __int32 v12;
  unsigned __int8 v13;
  unsigned __int8 v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  __n128 *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  float v27;
  int v28;
  float v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  __int128 v34;
  unsigned int v35;
  float v36;
  int v37;
  float v38;
  int v39;
  uint64_t v40;
  BOOL v42;
  __int128 *v43;
  int *v44;
  uint64_t *v45;
  __n128 *v51;
  unint64_t v52;
  uint64_t v53;
  unint64_t v54;
  BOOL v55;
  BOOL v57;
  BOOL v58;
  __int128 v61;
  __n128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  int v66;
  char v67;
  __int128 v68;
  __int128 v69;
  unsigned __int8 v70;
  __n128 v71;
  __n128 v72;
  int v73;
  char v74;
  __int128 v75;
  __int128 v76;
  unint64_t v77;
  unsigned __int16 v78;
  unint64_t v79;
  unsigned __int16 v80;
  uint64_t v81;
  __int16 v82;
  uint64_t v83;

  v83 = *MEMORY[0x1E0C80C00];
  v2 = a2[2];
  if (v2 != (__n128 *)1)
  {
    v4 = *a2;
    v63 = (__int128)(*a2)[7];
    v64 = (__int128)(*a2)[8];
    v65 = (__int128)(*a2)[9];
    v61 = (__int128)(*a2)[5];
    v62 = (*a2)[6];
    v5 = (uint64_t)&(*a2)[5 * (_QWORD)v2];
    v7 = *(_QWORD *)(v5 - 80);
    v6 = *(_QWORD *)(v5 - 72);
    v71 = *(__n128 *)(v5 - 64);
    v72 = *(__n128 *)(v5 - 48);
    v8 = *(_DWORD *)(v5 - 32);
    v9 = *(float *)(v5 - 28);
    v10 = *(_DWORD *)(v5 - 24);
    v11 = *(float *)(v5 - 20);
    v12 = *(_DWORD *)(v5 - 16);
    v13 = *(_BYTE *)(v5 - 12);
    v14 = *(_BYTE *)(v5 - 11);
    v15 = *(_QWORD *)(v5 - 10);
    LOWORD(v5) = *(_WORD *)(v5 - 2);
    v4[6] = v71;
    v4[7] = v72;
    v70 = v13;
    v80 = v5;
    v79 = v15;
    v4[5].n128_u64[0] = v7;
    v4[5].n128_u64[1] = v6;
    v4[8].n128_u32[0] = v8;
    v4[8].n128_f32[1] = v9;
    v4[8].n128_u32[2] = v10;
    v4[8].n128_f32[3] = v11;
    v4[9].n128_u8[4] = v13;
    v4[9].n128_u32[0] = v12;
    v4[9].n128_u8[5] = v14;
    v4[9].n128_u16[7] = v80;
    *(unint64_t *)((char *)v4[9].n128_u64 + 6) = v15;
    v17 = (uint64_t)a2[1];
    v16 = (uint64_t)a2[2];
    a2[2] = (__n128 *)(v16 - 1);
    v78 = v80;
    v18 = v17 >> 1;
    v19 = 3;
    v77 = v15;
    v20 = 2;
    v21 = 1;
    while (1)
    {
      v22 = *a2;
      v23 = (uint64_t)&(*a2)[5 * v20];
      v24 = *(_QWORD *)v23;
      v25 = *(_QWORD *)(v23 + 8);
      v26 = *(_DWORD *)(v23 + 48);
      v27 = *(float *)(v23 + 52);
      v28 = *(_DWORD *)(v23 + 56);
      v29 = *(float *)(v23 + 60);
      v30 = *(unsigned __int8 *)(v23 + 69);
      v31 = (uint64_t)&(*a2)[5 * v19];
      v32 = *(_QWORD *)v31;
      v33 = *(_QWORD *)(v31 + 8);
      v34 = *(_OWORD *)(v31 + 32);
      v75 = *(_OWORD *)(v31 + 16);
      v76 = v34;
      v35 = *(_DWORD *)(v31 + 48);
      v36 = *(float *)(v31 + 52);
      v37 = *(_DWORD *)(v31 + 56);
      v38 = *(float *)(v31 + 60);
      v73 = *(_DWORD *)(v31 + 64);
      v74 = *(_BYTE *)(v31 + 68);
      v39 = *(unsigned __int8 *)(v31 + 69);
      v40 = *(_QWORD *)(v31 + 70);
      v82 = *(_WORD *)(v31 + 78);
      v81 = v40;
      if (v19 >= v16)
      {
        v75 = xmmword_1B8628560;
        v76 = unk_1B8628570;
        v73 = 0;
        v74 = 0;
        v81 = 0;
        v82 = 0;
        if (v20 >= v16)
          goto LABEL_3;
        v35 = 0;
        v37 = 0;
        v39 = 0;
        v32 = -1;
        v38 = 0.0;
        v36 = 3.4028e38;
        v33 = -1;
        if (!v30)
        {
LABEL_12:
          if (__PAIR128__(v25, v24) < __PAIR128__(v6, v7))
            goto LABEL_24;
          if (v25 != v6 || v24 != v7)
          {
LABEL_47:
            if (!v39)
            {
              if (__PAIR128__(v33, v32) >= __PAIR128__(v6, v7))
              {
                v57 = v33 == v6 && v32 == v7;
                if (!v57 || v36 >= v9 && (v36 == v9 ? (v58 = v35 > v8) : (v58 = 0), !v58))
                {
LABEL_69:
                  _X8 = &v22[10 * v21];
                  __asm { PRFM            #1, [X8] }
                  goto LABEL_3;
                }
                LOBYTE(v30) = 0;
                v45 = &v81;
                v44 = &v73;
                v43 = &v75;
                v29 = v38;
                v28 = v37;
                v27 = v36;
                v26 = v35;
                v24 = v7;
                v25 = v6;
                goto LABEL_34;
              }
              goto LABEL_32;
            }
            if (v38 >= v11)
            {
              if (v38 != v11)
                goto LABEL_69;
              if (v36 >= v9 && (v36 != v9 || v35 <= v8))
                goto LABEL_69;
            }
            goto LABEL_30;
          }
          goto LABEL_18;
        }
      }
      else if (!v30)
      {
        goto LABEL_12;
      }
      if (v29 < v11)
        goto LABEL_24;
      if (v29 != v11)
        goto LABEL_47;
LABEL_18:
      if (v27 >= v9)
      {
        v42 = v27 == v9 && v26 > v8;
        if (!v42)
          goto LABEL_47;
      }
LABEL_24:
      v43 = (__int128 *)(v23 + 16);
      v44 = (int *)(v23 + 64);
      v45 = (uint64_t *)(v23 + 70);
      if (!v39)
      {
        if (__PAIR128__(v33, v32) >= __PAIR128__(v25, v24))
        {
          v55 = v33 == v25 && v32 == v24;
          if (!v55 || v36 >= v27 && (v36 != v27 || v35 <= v26))
            goto LABEL_35;
          LOBYTE(v30) = 0;
          v45 = &v81;
          v44 = &v73;
          v43 = &v75;
          v29 = v38;
          v28 = v37;
          v27 = v36;
          v26 = v35;
          goto LABEL_34;
        }
LABEL_32:
        LOBYTE(v30) = 0;
        v45 = &v81;
        v44 = &v73;
        v43 = &v75;
        goto LABEL_33;
      }
      if (v38 >= v29 && (v38 != v29 || v36 >= v27 && (v36 != v27 || v35 <= v26)))
        goto LABEL_35;
LABEL_30:
      v45 = &v81;
      v44 = &v73;
      v43 = &v75;
      LOBYTE(v30) = v39;
LABEL_33:
      v29 = v38;
      v28 = v37;
      v27 = v36;
      v26 = v35;
      v24 = v32;
      v25 = v33;
LABEL_34:
      v20 = v19;
LABEL_35:
      v68 = *v43;
      v69 = v43[1];
      v66 = *v44;
      v67 = *((_BYTE *)v44 + 4);
      v77 = *v45;
      v78 = *((_WORD *)v45 + 4);
      _X5 = &v22[10 * v20];
      __asm { PRFM            #1, [X5] }
      if (v20 != v21)
      {
        v51 = &v22[5 * v20];
        v51->n128_u64[0] = v7;
        v51->n128_u64[1] = v6;
        v51[1] = v71;
        v51[2] = v72;
        v51[3].n128_u32[0] = v8;
        v51[3].n128_f32[1] = v9;
        v51[3].n128_u32[2] = v10;
        v51[3].n128_f32[3] = v11;
        v51[4].n128_u32[0] = v12;
        v51[4].n128_u8[4] = v70;
        v51[4].n128_u8[5] = v14;
        v51[4].n128_u16[7] = v80;
        v52 = v79;
        *(unint64_t *)((char *)v51[4].n128_u64 + 6) = v79;
        v53 = (uint64_t)&(*a2)[5 * v21];
        *(_OWORD *)(v53 + 16) = v68;
        *(_OWORD *)(v53 + 32) = v69;
        *(float *)(v53 + 52) = v27;
        v21 = v20;
        v19 = (2 * v20) | 1;
        *(_QWORD *)v53 = v24;
        *(_QWORD *)(v53 + 8) = v25;
        *(_DWORD *)(v53 + 48) = v26;
        *(_DWORD *)(v53 + 56) = v28;
        *(float *)(v53 + 60) = v29;
        *(_DWORD *)(v53 + 64) = v66;
        *(_BYTE *)(v53 + 68) = v67;
        *(_BYTE *)(v53 + 69) = v30;
        v54 = v77;
        *(_WORD *)(v53 + 78) = v78;
        *(_QWORD *)(v53 + 70) = v54;
        v78 = v80;
        v77 = v52;
        v42 = v20 < v18;
        v20 *= 2;
        if (v42)
          continue;
      }
      goto LABEL_3;
    }
  }
  v63 = xmmword_1B86285C0;
  v64 = unk_1B86285D0;
  v65 = xmmword_1B86285E0;
  v61 = ZERO_RANKING_WRAPPED_BITS;
  v62 = *(__n128 *)algn_1B86285B0;
LABEL_3:
  a1[2] = v63;
  a1[3] = v64;
  a1[4] = v65;
  result = v62;
  *a1 = v61;
  a1[1] = (__int128)v62;
  return result;
}

uint64_t container_fetch_table_check_and_insert(_DWORD *a1, uint64_t a2)
{
  _DWORD *v2;
  float *v3;
  unint64_t v4;
  unint64_t v5;
  float v6;
  float v7;
  unint64_t v8;
  BOOL v9;
  float v10;
  float v11;
  BOOL v12;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;

  if (!*a1)
    return 0;
  v2 = &a1[36 * ((*(_DWORD *)(a2 + 56) - 1) % *a1)];
  v5 = *((_QWORD *)v2 + 2);
  v3 = (float *)(v2 + 4);
  v4 = v5;
  v6 = v3[13];
  v7 = *(float *)(a2 + 52);
  if (*((unsigned __int8 *)v3 + 69) | *(unsigned __int8 *)(a2 + 69))
  {
    v10 = v3[15];
    v11 = *(float *)(a2 + 60);
    v9 = v11 == v10;
    if (v11 > v10)
      goto LABEL_18;
  }
  else
  {
    v8 = *((_QWORD *)v3 + 1);
    if (__PAIR128__(v8, v4) < *(_OWORD *)a2)
      goto LABEL_18;
    v9 = *(_QWORD *)(a2 + 8) == v8 && *(_QWORD *)a2 == v4;
  }
  if (!v9 || v7 <= v6 && (v7 == v6 ? (v12 = *(_DWORD *)(a2 + 48) >= *((_DWORD *)v3 + 12)) : (v12 = 1), v12))
  {
    if (*((_DWORD *)v3 + 14))
      return 0;
  }
LABEL_18:
  *(_OWORD *)v3 = *(_OWORD *)a2;
  v14 = *(_OWORD *)(a2 + 16);
  v15 = *(_OWORD *)(a2 + 32);
  v16 = *(_OWORD *)(a2 + 64);
  *((_OWORD *)v3 + 3) = *(_OWORD *)(a2 + 48);
  *((_OWORD *)v3 + 4) = v16;
  *((_OWORD *)v3 + 1) = v14;
  *((_OWORD *)v3 + 2) = v15;
  v17 = *(_OWORD *)(a2 + 80);
  v18 = *(_OWORD *)(a2 + 96);
  v19 = *(_OWORD *)(a2 + 128);
  *((_OWORD *)v3 + 7) = *(_OWORD *)(a2 + 112);
  *((_OWORD *)v3 + 8) = v19;
  *((_OWORD *)v3 + 5) = v17;
  *((_OWORD *)v3 + 6) = v18;
  return 1;
}

_DWORD *container_fetch_table_create(unsigned int a1)
{
  _DWORD *v2;
  uint64_t v3;
  _OWORD *v4;

  v2 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 144 * a1 + 16, 0x6085D6BuLL);
  if (!v2)
    _log_fault_for_malloc_failure();
  *v2 = a1;
  if (a1)
  {
    v3 = a1;
    v4 = v2 + 4;
    do
    {
      v4[6] = xmmword_1B8630980;
      v4[7] = unk_1B8630990;
      v4[8] = xmmword_1B86309A0;
      v4[2] = xmmword_1B8630940;
      v4[3] = unk_1B8630950;
      v4[4] = xmmword_1B8630960;
      v4[5] = unk_1B8630970;
      *v4 = ZERO_FETCHINFO;
      v4[1] = *(_OWORD *)algn_1B8630930;
      v4 += 9;
      --v3;
    }
    while (v3);
  }
  return v2;
}

uint64_t container_fetch_table_q2_check_and_insert(_DWORD *a1, uint64_t a2)
{
  _DWORD *v2;
  float *v3;
  unint64_t v4;
  unint64_t v5;
  _DWORD *v6;
  BOOL v7;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;

  if (!*a1)
    return 0;
  v2 = &a1[36 * ((*(_DWORD *)(a2 + 56) - 1) % *a1)];
  v3 = (float *)(v2 + 4);
  v6 = v2 + 8;
  v5 = *((_QWORD *)v2 + 4);
  v4 = *((_QWORD *)v6 + 1);
  if (__PAIR128__(v4, v5) >= *(_OWORD *)(a2 + 16))
  {
    v7 = v4 == *(_QWORD *)(a2 + 24) && v5 == *(_QWORD *)(a2 + 16);
    if ((!v7 || v3[13] != *(float *)(a2 + 52) || *((_DWORD *)v3 + 12) <= *(_DWORD *)(a2 + 48)) && *((_DWORD *)v3 + 14))
      return 0;
  }
  *(_OWORD *)v3 = *(_OWORD *)a2;
  v9 = *(_OWORD *)(a2 + 16);
  v10 = *(_OWORD *)(a2 + 32);
  v11 = *(_OWORD *)(a2 + 64);
  *((_OWORD *)v3 + 3) = *(_OWORD *)(a2 + 48);
  *((_OWORD *)v3 + 4) = v11;
  *((_OWORD *)v3 + 1) = v9;
  *((_OWORD *)v3 + 2) = v10;
  v12 = *(_OWORD *)(a2 + 80);
  v13 = *(_OWORD *)(a2 + 96);
  v14 = *(_OWORD *)(a2 + 112);
  *((_BYTE *)v3 + 128) = *(_BYTE *)(a2 + 128);
  *((_OWORD *)v3 + 6) = v13;
  *((_OWORD *)v3 + 7) = v14;
  *((_OWORD *)v3 + 5) = v12;
  return 1;
}

_DWORD *container_fetch_table_q2_create(unsigned int a1)
{
  _DWORD *v2;
  uint64_t v3;
  _DWORD *v4;

  v2 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 144 * a1 + 16, 0x6085D6BuLL);
  if (!v2)
    _log_fault_for_malloc_failure();
  *v2 = a1;
  if (a1)
  {
    v3 = a1;
    v4 = v2 + 4;
    do
    {
      *((_BYTE *)v4 + 128) = 0;
      *((_OWORD *)v4 + 4) = xmmword_1B8628420;
      *((_OWORD *)v4 + 5) = unk_1B8628430;
      *((_OWORD *)v4 + 6) = xmmword_1B8628440;
      *((_OWORD *)v4 + 7) = unk_1B8628450;
      *(_OWORD *)v4 = ZERO_FETCHINFO_Q2;
      *((_OWORD *)v4 + 1) = *(_OWORD *)algn_1B86283F0;
      *((_OWORD *)v4 + 2) = xmmword_1B8628400;
      *((_OWORD *)v4 + 3) = unk_1B8628410;
      v4 += 36;
      --v3;
    }
    while (v3);
  }
  return v2;
}

void *closeMF(uint64_t a1)
{
  int v2;
  NSObject *v3;
  os_log_type_t v4;
  unint64_t v5;
  double v6;
  void *result;
  int v8;
  unint64_t v9;
  __int16 v10;
  double v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  fd_release(*(char **)(a1 + 96));
  *(_QWORD *)(a1 + 96) = 0;
  v2 = *__error();
  v3 = _SILogForLogForCategory(10);
  v4 = 2 * (dword_1EF19FCB4 < 4);
  if (os_log_type_enabled(v3, v4))
  {
    v5 = *(_QWORD *)(a1 + 24);
    v6 = (double)*(unint64_t *)(a1 + 16) * 100.0 / (double)v5;
    v8 = 134218240;
    v9 = v5 >> 10;
    v10 = 2048;
    v11 = v6;
    _os_log_impl(&dword_1B8270000, v3, v4, "Memsize: %luKB %f%% used", (uint8_t *)&v8, 0x16u);
  }
  *__error() = v2;
  result = *(void **)a1;
  if ((unint64_t)(*(_QWORD *)a1 + 1) >= 2)
  {
    result = (void *)munmap(result, *(_QWORD *)(a1 + 24));
    *(_QWORD *)a1 = 0;
  }
  return result;
}

uint64_t mfree(uint64_t result, unsigned int a2, uint64_t *a3)
{
  unsigned int v3;
  BOOL v4;
  unsigned int v5;
  unsigned int v6;
  _BOOL4 v8;
  int v9;
  uint64_t v10;
  uint64_t v11;

  v3 = *((_DWORD *)a3 + 2);
  v4 = a2 >= v3;
  v5 = a2 - v3;
  if (v5 != 0 && v4)
  {
    v6 = __clz(v5);
    v8 = (v5 & (v5 - 1)) != 0 || v5 == 0;
    v9 = v8 - v6 + 28;
  }
  else
  {
    v9 = 0;
  }
  if ((8 << v9) + result == a3[2])
  {
    a3[2] = (int)result;
  }
  else
  {
    v10 = *a3;
    if (*((_DWORD *)a3 + 28) < v9)
      *((_DWORD *)a3 + 28) = v9;
    v11 = (uint64_t)a3 + 4 * v9;
    *(_DWORD *)(v10 + result) = *(_DWORD *)(v11 + 32);
    *(_DWORD *)(v11 + 32) = result;
  }
  return result;
}

uint64_t mmalloc(unsigned int a1, uint64_t a2, uint64_t (*a3)(uint64_t), uint64_t a4)
{
  uint64_t v7;
  unsigned int v8;
  _BOOL4 v10;
  int v11;
  int v12;
  signed int v13;
  uint64_t v14;
  _DWORD *v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;
  unsigned int v19;
  unint64_t v20;
  char *v22;
  char *v23;
  const char *v24;
  uint64_t v25;
  size_t v26;
  size_t v27[2];

  v7 = *(unsigned int *)(a2 + 8);
  if (a1 <= v7)
  {
    v13 = 0;
  }
  else
  {
    v8 = __clz(a1 - v7);
    v10 = ((a1 - (_DWORD)v7) & (a1 - (_DWORD)v7 - 1)) != 0 || a1 == (_DWORD)v7;
    v11 = v10 - v8;
    if (v11 <= -31)
      v12 = 31;
    else
      v12 = 28;
    v13 = v12 + v11;
  }
  v14 = a2 + 4 * v13;
  v17 = *(_DWORD *)(v14 + 32);
  v15 = (_DWORD *)(v14 + 32);
  v16 = v17;
  if (v17)
  {
    v18 = *(_QWORD *)a2;
    *v15 = *(_DWORD *)(*(_QWORD *)a2 + v16);
    v27[1] = 0x2000;
    v27[0] = *(unsigned int *)(v18 + v16);
    fd_read_advise(*(_DWORD **)(a2 + 96), (uint64_t)v27);
  }
  else
  {
    v19 = takeBuddyPage((uint64_t *)a2, v13);
    if (v19)
    {
      return v19;
    }
    else
    {
      if (!*(_QWORD *)(a2 + 96))
      {
        v22 = __si_assert_copy_extra_268();
        v23 = v22;
        v24 = "";
        if (v22)
          v24 = v22;
        __message_assert("%s:%u: failed assertion '%s' %s NULL file reference", "MFMalloc.c", 311, "m->fdPtr", v24);
        free(v23);
        if (__valid_fs(-1))
          v25 = 2989;
        else
          v25 = 3072;
        *(_DWORD *)v25 = -559038737;
        abort();
      }
      v16 = *(_QWORD *)(a2 + 16);
      v20 = *(_QWORD *)(a2 + 24);
      if (v16 + v7 + (unint64_t)(16 << v13) + 8 >= v20)
      {
        while (1)
        {
          v27[0] = 0;
          if (expandUnsafeMapNew((void **)a2, *(_QWORD *)(a2 + 96), v20, 1uLL, v27, a3, a4))
            break;
          v26 = v27[0];
          *(_QWORD *)(a2 + 24) = v27[0];
          madvise(*(void **)a2, v26, *(_DWORD *)(a2 + 104));
          v16 = *(_QWORD *)(a2 + 16);
          v20 = *(_QWORD *)(a2 + 24);
          if (v16 + v7 + (unint64_t)(16 << v13) + 8 < v20)
            goto LABEL_19;
        }
        v16 = 0;
        *__error() = -1;
      }
      else
      {
LABEL_19:
        *(_QWORD *)(a2 + 16) = v7 + (8 << v13) + v16;
      }
    }
  }
  return v16;
}

uint64_t takeBuddyPage(uint64_t *a1, unsigned int a2)
{
  uint64_t result;
  _DWORD *v5;
  _DWORD *v6;
  int v7;
  uint64_t v8;
  unsigned int v9;

  if (a2 > 0xE)
    return 0;
  if (*((_DWORD *)a1 + 2) || *((_DWORD *)a1 + 28) <= a2)
    return 0;
  v5 = (_DWORD *)a1 + a2 + 9;
  v6 = (_DWORD *)a1 + a2 + 8;
  result = *v5;
  v7 = 8 << a2;
  if ((_DWORD)result)
  {
    v8 = *a1;
    *v5 = *(_DWORD *)(*a1 + result);
    v9 = result + v7;
    *v6 = result + v7;
LABEL_11:
    *(_DWORD *)(v8 + v9) = 0;
    return result;
  }
  result = takeBuddyPage(a1);
  if ((_DWORD)result)
  {
    v9 = result + v7;
    *v6 = result + v7;
    v8 = *a1;
    goto LABEL_11;
  }
  *((_DWORD *)a1 + 28) = a2;
  return result;
}

uint64_t restoreVInt32_2638(char **a1)
{
  char *v1;
  uint64_t v2;
  uint64_t v3;
  int v4;
  int v5;
  uint64_t v6;
  int v7;
  int v9;
  uint64_t v10;
  char *v11;
  char *v12;
  const char *v13;
  uint64_t v14;

  v1 = *a1;
  v2 = **a1;
  if ((**a1 & 0x80000000) == 0)
  {
    v3 = 1;
    goto LABEL_10;
  }
  v4 = v1[1];
  if ((v1[1] & 0x80000000) == 0)
  {
    v2 = v2 & 0x7F | (v4 << 7);
    v3 = 2;
    goto LABEL_10;
  }
  v5 = v1[2];
  if ((v1[2] & 0x80000000) == 0)
  {
    v6 = ((v4 & 0x7F) << 7) | (v5 << 14) | (v2 & 0x7F);
    v3 = 3;
LABEL_9:
    v2 = v6;
    goto LABEL_10;
  }
  v7 = v1[3];
  if ((v1[3] & 0x80000000) == 0)
  {
    v6 = ((v5 & 0x7F) << 14) | (v7 << 21) | ((v4 & 0x7F) << 7) | (v2 & 0x7F);
    v3 = 4;
    goto LABEL_9;
  }
  v9 = v1[4];
  if (v9 < 0)
  {
    v11 = __si_assert_copy_extra_268();
    v12 = v11;
    v13 = "";
    if (v11)
      v13 = v11;
    __message_assert("%s:%u: failed assertion '%s' %s readVInt32: exceeds max size for uint32_t", "VIntUtils.h", 341, "(b4 & 0x80) == 0", v13);
    free(v12);
    if (__valid_fs(-1))
      v14 = 2989;
    else
      v14 = 3072;
    *(_DWORD *)v14 = -559038737;
    abort();
  }
  v10 = ((v7 & 0x7F) << 21) | (v9 << 28) | ((v5 & 0x7F) << 14) | ((v4 & 0x7F) << 7) | (v2 & 0x7F);
  v3 = 5;
  v2 = v10;
LABEL_10:
  *a1 = &v1[v3];
  return v2;
}

void __si_indexingWatchdogInit_block_invoke(uint64_t a1)
{
  uint64_t v1;
  pid_t v3;
  thread_read_t *v4;
  mach_port_name_t v5;
  char v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  const __CFSet *v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  NSObject *v14;
  dispatch_time_t v15;
  unint64_t Current;
  int v17;
  NSObject *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  void (*v28[5])(_QWORD, _QWORD);
  size_t v29;
  int v30[2];
  int v31;
  pid_t v32;
  uint8_t buf[4];
  const char *v34;
  __int16 v35;
  int v36;
  __int16 v37;
  uint64_t v38;
  __int16 v39;
  uint64_t v40;
  __int16 v41;
  uint64_t v42;
  __int16 v43;
  uint64_t v44;
  __int16 v45;
  uint64_t v46;
  __int16 v47;
  uint64_t v48;
  __int16 v49;
  unint64_t v50;
  __int16 v51;
  int v52;
  uint64_t v53;

  v53 = *MEMORY[0x1E0C80C00];
  v1 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v1 + 97) && !*(_BYTE *)(v1 + 16))
  {
    if (SIIsAppleInternal_onceToken != -1)
      dispatch_once(&SIIsAppleInternal_onceToken, &__block_literal_global_4644);
    if (!SIIsAppleInternal_internal
      || (v3 = getpid(),
          bzero(buf, 0x288uLL),
          *(_QWORD *)v30 = 0xE00000001,
          v31 = 1,
          v32 = v3,
          v29 = 648,
          sysctl(v30, 4u, buf, &v29, 0, 0))
      || (v40 & 0x8000000) == 0)
    {
      v4 = (thread_read_t *)MEMORY[0x1BCCB104C]();
      v5 = v4;
      v28[0] = (void (*)(_QWORD, _QWORD))MEMORY[0x1E0C809B0];
      v28[1] = (void (*)(_QWORD, _QWORD))0x40000000;
      v28[2] = (void (*)(_QWORD, _QWORD))__si_indexingWatchdogInit_block_invoke_2;
      v28[3] = (void (*)(_QWORD, _QWORD))&__block_descriptor_tmp_2652;
      v28[4] = *(void (**)(_QWORD, _QWORD))(a1 + 40);
      v6 = _SISuspendThreadIfLocked(v4, v28);
      mach_port_deallocate(*MEMORY[0x1E0C83DA0], v5);
      v7 = *(_QWORD *)(a1 + 32);
      if (!*(_BYTE *)(v7 + 97) && !*(_BYTE *)(v7 + 16))
      {
        if (pthread_mutex_trylock((pthread_mutex_t *)(*(_QWORD *)(a1 + 40) + 1712)))
        {
          v8 = 4;
        }
        else
        {
          v9 = *(_QWORD *)(a1 + 40);
          v10 = *(const __CFSet **)(v9 + 1776);
          v8 = 4;
          if (v10)
          {
            if (CFSetGetCount(v10))
              v8 = 40;
            else
              v8 = 4;
            v9 = *(_QWORD *)(a1 + 40);
          }
          pthread_mutex_unlock((pthread_mutex_t *)(v9 + 1712));
        }
        if ((v6 & 1) != 0)
          goto LABEL_21;
        v11 = *(_QWORD *)(a1 + 32);
        v12 = *(_DWORD *)(v11 + 80);
        if (v12 < v8)
        {
          *(_DWORD *)(v11 + 80) = v12 + 1;
          logPLIndexingWatchdogEvent();
LABEL_21:
          v13 = *(_QWORD *)(a1 + 40);
          v14 = **(NSObject ***)(a1 + 32);
          v15 = dispatch_time(0, 1000000000 * *(_QWORD *)(*(_QWORD *)(v13 + 64) + 40));
          dispatch_source_set_timer(v14, v15, 0xFFFFFFFFFFFFFFFFLL, 0);
          return;
        }
        Current = (unint64_t)CFAbsoluteTimeGetCurrent();
        v17 = *__error();
        v18 = _SILogForLogForCategory(4);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          v19 = *(_QWORD *)(a1 + 32);
          v20 = *(_QWORD *)(v19 + 88);
          v21 = *(_QWORD *)(v19 + 40);
          v22 = *(_QWORD *)(v19 + 48);
          v23 = *(unsigned int *)(v19 + 72);
          v24 = *(unsigned int *)(v19 + 76);
          v25 = *(_QWORD *)(v19 + 104);
          LODWORD(v19) = *(_DWORD *)(v19 + 84);
          *(_DWORD *)buf = 136317442;
          v34 = "si_indexingWatchdogInit_block_invoke";
          v35 = 1024;
          v36 = 165;
          v37 = 2048;
          v38 = v20;
          v39 = 2048;
          v40 = v21;
          v41 = 2048;
          v42 = v22;
          v43 = 2048;
          v44 = v23;
          v45 = 2048;
          v46 = v24;
          v47 = 2048;
          v48 = v25;
          v49 = 2048;
          v50 = Current;
          v51 = 1024;
          v52 = v19;
          _os_log_error_impl(&dword_1B8270000, v18, OS_LOG_TYPE_ERROR, "%s:%d: Indexing watchdog fired, thread:%p delta:%llus, startTime:%.3f, itemCount:%lu, perItemCost:%lu resumeTime:%.3f endtime:%lld protectionClass:%u", buf, 0x5Eu);
        }
        *__error() = v17;
        logPLIndexingWatchdogEvent();
        tailSpinCollect(*(_QWORD *)(a1 + 32), (double)Current);
        v26 = abort_report_np();
        __si_indexingWatchdogInit_block_invoke_2(v26, v27);
      }
    }
  }
}

int *__si_indexingWatchdogInit_block_invoke_2(uint64_t a1, int a2)
{
  int v4;
  NSObject *v5;
  os_log_type_t v6;
  const char *v7;
  int v8;
  BOOL v9;
  _BYTE *v10;
  int *result;
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  _BYTE *v15;
  _BYTE v16[1024];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  bzero(v16, 0x400uLL);
  v4 = *__error();
  v5 = _SILogForLogForCategory(10);
  v6 = 2 * (dword_1EF19FCB4 < 4);
  if (os_log_type_enabled(v5, v6))
  {
    if (a2)
      v7 = "Suspend";
    else
      v7 = "Resume";
    v8 = fcntl(*(_DWORD *)(*(_QWORD *)(a1 + 32) + 32), 50, v16);
    if (v16[0])
      v9 = v8 < 0;
    else
      v9 = 1;
    if (v9)
      v10 = 0;
    else
      v10 = v16;
    *(_DWORD *)buf = 136315394;
    v13 = v7;
    v14 = 2080;
    v15 = v10;
    _os_log_impl(&dword_1B8270000, v5, v6, "%s watchdog for %s", buf, 0x16u);
  }
  result = __error();
  *result = v4;
  return result;
}

void logPLIndexingWatchdogEvent()
{
  CFDictionaryRef v0;
  void *values;
  void *keys[2];

  keys[1] = *(void **)MEMORY[0x1E0C80C00];
  if (PLShouldLogRegisteredEvent())
  {
    values = CFSTR("1");
    keys[0] = CFSTR("indexingWatchdogFired");
    v0 = CFDictionaryCreate(0, (const void **)keys, (const void **)&values, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    PLLogRegisteredEvent();
    CFRelease(v0);
  }
}

void tailSpinCollect(uint64_t a1, double a2)
{
  uint64_t v2;
  const __CFAllocator *v3;
  CFUUIDRef v4;
  const __CFString *v5;
  double valuePtr;
  double v7;
  uint8_t buf[4];
  uint64_t v9;
  void *values[10];
  void *keys[2];
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v7 = a2;
  v2 = a1 + 48;
  valuePtr = (a2 - *(double *)(a1 + 48)) * 1000.0;
  v3 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v4 = CFUUIDCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00]);
  v12 = *(_OWORD *)&off_1E6E2F190;
  v13 = xmmword_1E6E2F1A0;
  v14 = *(_OWORD *)&off_1E6E2F1B0;
  v15 = xmmword_1E6E2F1C0;
  *(_OWORD *)keys = xmmword_1E6E2F180;
  values[0] = CFNumberCreate(v3, kCFNumberDoubleType, &valuePtr);
  values[1] = CFNumberCreate(v3, kCFNumberSInt32Type, (const void *)(v2 + 24));
  values[2] = CFNumberCreate(v3, kCFNumberSInt64Type, (const void *)(v2 + 28));
  values[3] = CFNumberCreate(v3, kCFNumberSInt64Type, (const void *)(v2 + 32));
  values[4] = CFNumberCreate(v3, kCFNumberSInt64Type, (const void *)(v2 - 8));
  if (*(_QWORD *)(v2 - 16))
    v5 = *(const __CFString **)(v2 - 16);
  else
    v5 = CFSTR("unknown");
  values[5] = (void *)CFRetain(v5);
  values[6] = CFNumberCreate(v3, kCFNumberDoubleType, (const void *)v2);
  values[7] = CFNumberCreate(v3, kCFNumberDoubleType, (const void *)(v2 + 8));
  values[8] = CFNumberCreate(v3, kCFNumberDoubleType, (const void *)(v2 + 56));
  values[9] = CFNumberCreate(v3, kCFNumberDoubleType, &v7);
  CFRelease(v4);
  CFDictionaryCreate(v3, (const void **)keys, (const void **)values, 10, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (DRTailspinRequest())
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_debug_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEBUG, "DiagnosticPipeline tailspin request successful.", buf, 2u);
    }
  }
  else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 138412290;
    v9 = 0;
    _os_log_error_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_ERROR, "DiagnosticPipeline tailspin request failed with error: %@.", buf, 0xCu);
  }
}

void si_indexingWatchdogSuspend(uint64_t a1)
{
  os_unfair_lock_s *v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  CFAbsoluteTime Current;
  NSObject *v7;
  int v8;
  NSObject *v9;
  int v10;
  NSObject *v11;
  __int16 v12;
  uint64_t v13;
  __int16 v14;
  uint64_t v15;
  __int16 v16;
  CFAbsoluteTime v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v2 = (os_unfair_lock_s *)(a1 + 64);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 64));
    v3 = *(_DWORD *)(a1 + 68);
    *(_DWORD *)(a1 + 68) = v3 + 1;
    if (!v3)
    {
      v4 = *(_QWORD *)(a1 + 40);
      if (v4)
      {
        v5 = *(_QWORD *)(a1 + 48);
        Current = CFAbsoluteTimeGetCurrent();
        v7 = *(NSObject **)a1;
        v8 = *__error();
        v9 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          v10 = 134218752;
          v11 = v7;
          v12 = 2048;
          v13 = v4;
          v14 = 2048;
          v15 = v5;
          v16 = 2048;
          v17 = Current;
          _os_log_impl(&dword_1B8270000, v9, OS_LOG_TYPE_DEFAULT, "Suspending the indexing watchdog, timer:%p, delta:%llus, startTime:%.3f, suspendTime:%.3f", (uint8_t *)&v10, 0x2Au);
        }
        *__error() = v8;
        *(CFAbsoluteTime *)(a1 + 56) = Current;
        dispatch_suspend(v7);
      }
    }
    os_unfair_lock_unlock(v2);
  }
}

void si_indexingWatchdogResume(uint64_t a1)
{
  os_unfair_lock_s *v2;
  int v3;
  unint64_t v4;
  double v5;
  double v6;
  double v7;
  double v8;
  uint64_t v10;
  NSObject *v11;
  int v12;
  NSObject *v13;
  CFAbsoluteTime Current;
  dispatch_time_t v15;
  int v16;
  NSObject *v17;
  __int16 v18;
  uint64_t v19;
  __int16 v20;
  double v21;
  __int16 v22;
  double v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v2 = (os_unfair_lock_s *)(a1 + 64);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 64));
    v3 = *(_DWORD *)(a1 + 68) - 1;
    *(_DWORD *)(a1 + 68) = v3;
    if (!v3)
    {
      v4 = *(_QWORD *)(a1 + 40);
      if (v4)
      {
        v6 = *(double *)(a1 + 48);
        v5 = *(double *)(a1 + 56);
        v7 = v5 - v6;
        v8 = (double)v4;
        if (v6 <= v5 && v7 < v8)
          v4 = (unint64_t)(v8 - v7);
        if (v4 <= 0x3C)
          v10 = 60;
        else
          v10 = v4;
        v11 = *(NSObject **)a1;
        v12 = *__error();
        v13 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          v16 = 134218752;
          v17 = v11;
          v18 = 2048;
          v19 = v10;
          v20 = 2048;
          v21 = v6;
          v22 = 2048;
          v23 = v5;
          _os_log_impl(&dword_1B8270000, v13, OS_LOG_TYPE_DEFAULT, "Resuming the indexing watchdog, timer:%p, delta:%llus, startTime:%.3f, suspendTime:%.3f", (uint8_t *)&v16, 0x2Au);
        }
        *__error() = v12;
        *(_QWORD *)(a1 + 40) = v10;
        Current = CFAbsoluteTimeGetCurrent();
        *(CFAbsoluteTime *)(a1 + 48) = Current;
        *(CFAbsoluteTime *)(a1 + 104) = Current;
        *(_BYTE *)(a1 + 96) = 1;
        v15 = dispatch_time(0, 1000000000 * v10);
        dispatch_source_set_timer(v11, v15, 0xFFFFFFFFFFFFFFFFLL, 0);
        dispatch_resume(v11);
      }
    }
    os_unfair_lock_unlock(v2);
  }
}

void oqsort_offset_with_meta_t(uint64_t a1)
{
  qos_class_t v2;
  uint64_t v3;
  uint64_t v4;
  char *v5;
  char *v6;
  const char *v7;

  if (*(uint64_t *)(a1 + 24) >= 2)
  {
    v2 = qos_class_self();
    v3 = *(_QWORD *)(a1 + 8);
    v4 = *(_QWORD *)(a1 + 24);
    if (v2 < 0x12)
      _qsort_offset_with_meta_t(v3, 0, v4 - 1);
    else
      parallel_qsort_offset_with_meta_t(v3, v4);
  }
  if (*(_DWORD *)(a1 + 48))
  {
    v5 = __si_assert_copy_extra_268();
    v6 = v5;
    v7 = "";
    if (v5)
      v7 = v5;
    __message_assert(v5, "OQueue.c", 13, "!queue->split", v7);
    free(v6);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
}

void parallel_qsort_offset_with_meta_t(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  NSObject *v5;
  int v6;
  uint64_t v7;
  size_t v8;
  int v9[2];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (a2 > 2047)
  {
    v4 = OSAtomicDequeue(&qsort_cached_allocations, 0);
    if (!v4)
      v4 = malloc_type_malloc(0x40uLL, 0x102004053A8A26AuLL);
    v5 = dispatch_group_create();
    v4[3] = v5;
    v4[4] = 0;
    v4[1] = 0;
    v4[2] = a2 - 1;
    *v4 = a1;
    v6 = thread_count;
    if (!thread_count)
    {
      *(_QWORD *)v9 = 0x1900000006;
      v8 = 4;
      sysctl(v9, 2u, &thread_count, &v8, 0, 0);
      v6 = thread_count;
    }
    *((_DWORD *)v4 + 14) = v6;
    v4[5] = (uint64_t)sqrt((double)a2) / 2;
    if (!v6)
    {
      *(_QWORD *)v9 = 0x1900000006;
      v8 = 4;
      sysctl(v9, 2u, &thread_count, &v8, 0, 0);
      v6 = thread_count;
    }
    v7 = a2 / (2 * v6);
    if (v7 <= 0x8000)
    {
      v7 = 0x8000;
    }
    else if (!v6)
    {
      *(_QWORD *)v9 = 0x1900000006;
      v8 = 4;
      sysctl(v9, 2u, &thread_count, &v8, 0, 0);
      v7 = a2 / (2 * thread_count);
    }
    v4[6] = v7;
    if ((uint64_t)v4[5] <= 2047)
      v4[5] = 2048;
    _qsort_big_offset_with_meta_t(v4);
    dispatch_group_wait(v5, 0xFFFFFFFFFFFFFFFFLL);
    dispatch_release(v5);
  }
  else
  {
    _qsort_offset_with_meta_t(a1, 0, a2 - 1);
  }
}

void _qsort_offset_with_meta_t(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  BOOL v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  __int128 v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  char *v25;
  char *v26;
  const char *v27;

  v6 = malloc_type_malloc(0x800uLL, 0x1000040451B5BE8uLL);
  v6[1] = 0;
  *v6 = 0;
  v7 = 1;
  do
  {
    if (a3 > a2)
    {
      if (v7 <= 128)
        v9 = 128;
      else
        v9 = v7;
      v10 = &v6[2 * v7 + 1];
      while (a3 - a2 > 16)
      {
        v11 = _partition_offset_with_meta_t(a1, a2, a3);
        v12 = v11 - a2;
        if (v11 < a2)
        {
          v25 = __si_assert_copy_extra_268();
          v26 = v25;
          v27 = "";
          if (v25)
            v27 = v25;
          __message_assert(v25, "OQueue.c", 13, "q>=left", v27);
          free(v26);
          if (__valid_fs(-1))
          {
            MEMORY[0xBAD] = -559038737;
            abort();
          }
          MEMORY[0xC00] = -559038737;
          abort();
        }
        if (v9 == v7)
        {
          heapsort_b((void *)(a1 + 16 * a2), a3 - a2 + 1, 0x10uLL, &__block_literal_global_2734);
          v7 = v9;
          goto LABEL_3;
        }
        v13 = v12 <= a3 - v11;
        if (v12 <= a3 - v11)
          v14 = v11 - 1;
        else
          v14 = a3;
        if (v13)
          v15 = a2;
        else
          v15 = v11;
        if (v13)
          a2 = v11;
        else
          a3 = v11 - 1;
        *(v10 - 1) = v15;
        *v10 = v14;
        ++v7;
        v10 += 2;
        if (a3 <= a2)
          goto LABEL_3;
      }
      v16 = a1 + 24 + 16 * a2;
      v17 = a2;
      do
      {
        v18 = v17++;
        v19 = *(_OWORD *)(a1 + 16 * v17);
        v20 = *(_QWORD *)(a1 + 16 * v17) & 0x3FFFFFFFFFFFFFFFLL;
        v21 = *(_QWORD *)(a1 + 16 * v18);
        v22 = v17;
        if ((v21 & 0x3FFFFFFFFFFFFFFFuLL) > v20)
        {
          v23 = (_QWORD *)v16;
          do
          {
            v22 = v18;
            v24 = *(v23 - 2);
            *(v23 - 1) = v21;
            *v23 = v24;
            if (v22 <= a2)
              break;
            v21 = *(v23 - 5);
            v18 = v22 - 1;
            v23 -= 2;
          }
          while ((v21 & 0x3FFFFFFFFFFFFFFFuLL) > v20);
        }
        *(_OWORD *)(a1 + 16 * v22) = v19;
        v16 += 16;
      }
      while (v17 != a3);
    }
LABEL_3:
    --v7;
    v8 = &v6[2 * v7];
    a2 = *v8;
    a3 = v8[1];
  }
  while (v7);
  free(v6);
}

uint64_t _partition_offset_with_meta_t(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  unint64_t v8;
  _QWORD *v9;
  unint64_t v10;
  unint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  unint64_t v20;
  unint64_t v21;
  _QWORD *v22;
  unint64_t v23;
  _QWORD *v25;
  _QWORD *v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  _QWORD *v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  __int128 v35;
  uint64_t v36;
  __int128 *v37;
  __int128 *v38;
  __int128 v39;
  __int128 v40;
  unint64_t v41;
  __int128 v42;
  __int128 v43;

  v3 = a3 - a2;
  v4 = (_QWORD *)(a1 + 16 * a2);
  v5 = a3 - a2 + 2;
  if (a3 - a2 >= -1)
    v5 = v3 + 1;
  v6 = &v4[2 * (v5 >> 1)];
  v7 = (_QWORD *)(a1 + 16 * a3);
  if (v3 < 1024)
  {
    v22 = v6;
    v25 = (_QWORD *)(a1 + 16 * a3);
  }
  else
  {
    v8 = (unint64_t)(a3 - a2 + 1) >> 3;
    v9 = &v4[2 * v8];
    v10 = *v4 & 0x3FFFFFFFFFFFFFFFLL;
    v11 = *v9 & 0x3FFFFFFFFFFFFFFFLL;
    if (v10 != v11)
    {
      v12 = &v4[4 * v8];
      v13 = *v12 & 0x3FFFFFFFFFFFFFFFLL;
      if (v10 >= v13)
        v14 = &v4[4 * v8];
      else
        v14 = (_QWORD *)(a1 + 16 * a2);
      if (v11 > v13)
        v14 = &v4[2 * v8];
      if (v10 < v13)
        v4 += 4 * v8;
      if (v11 < v13)
        v4 = v9;
      if (v10 >= v11)
        v4 = v14;
      if (v13 == v10 || v13 == v11)
        v4 = v12;
    }
    v16 = 2 * v8;
    v17 = -(uint64_t)v8;
    v18 = 16 * v8;
    v19 = &v6[v18 / 0xFFFFFFFFFFFFFFF8];
    v20 = v6[v18 / 0xFFFFFFFFFFFFFFF8] & 0x3FFFFFFFFFFFFFFFLL;
    v21 = *v6 & 0x3FFFFFFFFFFFFFFFLL;
    if (v20 == v21)
    {
      v22 = &v6[v18 / 0xFFFFFFFFFFFFFFF8];
    }
    else
    {
      v22 = &v6[(unint64_t)v18 / 8];
      v23 = *v22 & 0x3FFFFFFFFFFFFFFFLL;
      if (v23 != v20 && v23 != v21)
      {
        if (v20 >= v21)
        {
          if (v20 < v23)
            v22 = v19;
          if (v21 > v23)
            v22 = v6;
        }
        else
        {
          if (v20 >= v23)
            v22 = v19;
          if (v21 < v23)
            v22 = v6;
        }
      }
    }
    v25 = &v7[-2 * v16];
    v26 = &v7[2 * v17];
    v27 = *v25 & 0x3FFFFFFFFFFFFFFFLL;
    v28 = *v26 & 0x3FFFFFFFFFFFFFFFLL;
    if (v27 != v28)
    {
      v29 = *v7 & 0x3FFFFFFFFFFFFFFFLL;
      if (v27 >= v29)
        v30 = (_QWORD *)(a1 + 16 * a3);
      else
        v30 = v25;
      if (v28 > v29)
        v30 = v26;
      if (v27 < v29)
        v25 = (_QWORD *)(a1 + 16 * a3);
      if (v28 < v29)
        v25 = v26;
      if (v27 >= v28)
        v25 = v30;
      if (v29 == v28)
        v25 = (_QWORD *)(a1 + 16 * a3);
      if (v29 == v27)
        v25 = (_QWORD *)(a1 + 16 * a3);
    }
  }
  v31 = *v4 & 0x3FFFFFFFFFFFFFFFLL;
  v32 = *v22 & 0x3FFFFFFFFFFFFFFFLL;
  if (v31 == v32)
  {
    v22 = v4;
  }
  else
  {
    v33 = *v25 & 0x3FFFFFFFFFFFFFFFLL;
    if (v33 == v31 || v33 == v32)
    {
      v22 = v25;
    }
    else if (v31 >= v32)
    {
      if (v32 <= v33)
      {
        if (v31 >= v33)
          v22 = v25;
        else
          v22 = v4;
      }
    }
    else if (v32 >= v33)
    {
      if (v31 >= v33)
        v22 = v4;
      else
        v22 = v25;
    }
  }
  v35 = *(_OWORD *)v22;
  *(_OWORD *)v22 = *(_OWORD *)v7;
  *(_OWORD *)v7 = v35;
  v36 = a3 - a2;
  if (a3 > a2)
  {
    v37 = (__int128 *)(a1 + 16 * a2);
    v39 = *v37;
    v38 = v37 + 1;
    v40 = v39;
    v41 = v35 & 0x3FFFFFFFFFFFFFFFLL;
    do
    {
      v42 = *v38;
      if (((unint64_t)v40 & 0x3FFFFFFFFFFFFFFFLL) <= v41)
      {
        *(v38 - 1) = *(_OWORD *)(a1 + 16 * a2);
        *(_OWORD *)(a1 + 16 * a2++) = v40;
      }
      ++v38;
      v40 = v42;
      --v36;
    }
    while (v36);
  }
  v43 = *(_OWORD *)(a1 + 16 * a2);
  *(_OWORD *)(a1 + 16 * a2) = *(_OWORD *)v7;
  *(_OWORD *)v7 = v43;
  return a2;
}

uint64_t ___qsort_offset_with_meta_t_block_invoke(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  unint64_t v3;
  unint64_t v4;
  BOOL v5;
  unsigned int v6;

  v3 = *a2 & 0x3FFFFFFFFFFFFFFFLL;
  v4 = *a3 & 0x3FFFFFFFFFFFFFFFLL;
  v5 = v3 > v4;
  if (v3 == v4)
    v6 = 0;
  else
    v6 = -1;
  if (v5)
    return 1;
  else
    return v6;
}

void _qsort_big_offset_with_meta_t(void *a1)
{
  uint64_t v1;
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  signed int v6;
  unint64_t i;
  qos_class_t v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v12;
  host_t v13;
  mach_error_t v14;
  unint64_t v15;
  NSObject *v16;
  qos_class_t v17;
  NSObject *global_queue;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _DWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  int v27;
  int v28;
  qos_class_t v29;
  NSObject *v30;
  char *v31;
  char *v32;
  const char *v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  _QWORD block[5];
  mach_msg_type_number_t host_info_outCnt;
  integer_t host_info_out[4];
  __int128 v41;
  __int128 v42;

  v1 = *((_QWORD *)a1 + 1);
  v2 = *((_QWORD *)a1 + 2);
  v3 = *((_QWORD *)a1 + 3);
  v4 = *((_QWORD *)a1 + 4);
  v5 = *((_QWORD *)a1 + 5);
  v36 = *((_QWORD *)a1 + 6);
  v37 = *(_QWORD *)a1;
  v6 = *((_DWORD *)a1 + 14);
  v35 = *((_DWORD *)a1 + 15);
  OSAtomicEnqueue(&qsort_cached_allocations, a1, 0);
  if (v2 > v1)
  {
    for (i = v4 + 1; ; ++i)
    {
      v10 = v2 - v1;
      if (v2 - v1 <= v5 || i > 9)
        break;
      if (v6 <= 1)
        v6 = 1;
      v12 = getSize_memSize;
      if (!getSize_memSize)
      {
        v41 = 0u;
        v42 = 0u;
        *(_OWORD *)host_info_out = 0u;
        v13 = MEMORY[0x1BCCB1010]();
        host_info_outCnt = 12;
        v14 = host_info(v13, 1, host_info_out, &host_info_outCnt);
        if (v14)
        {
          mach_error("flushsize", v14);
          exit(1);
        }
        v12 = *((_QWORD *)&v42 + 1);
        getSize_memSize = *((_QWORD *)&v42 + 1);
      }
      v15 = 3 * v12 / 5uLL;
      v16 = v3;
      if (16 * v10 > v15)
        v16 = dispatch_group_create();
      if (v10 <= v36 || 16 * v10 >= v15)
      {
        v19 = _partition_offset_with_meta_t(v37, v1, v2);
      }
      else
      {
        v17 = qos_class_self();
        global_queue = dispatch_get_global_queue(v17, 2uLL);
        v19 = _big_partition_offset_with_meta_t(v37, v1, v2, global_queue, v6);
      }
      v20 = v19;
      v21 = v19 - v1;
      if (v19 < v1)
      {
        v31 = __si_assert_copy_extra_268();
        v32 = v31;
        v33 = "";
        if (v31)
          v33 = v31;
        __message_assert(v31, "OQueue.c", 13, "q>=left", v33);
        free(v32);
        if (__valid_fs(-1))
          v34 = 2989;
        else
          v34 = 3072;
        *(_DWORD *)v34 = -559038737;
        abort();
      }
      v22 = OSAtomicDequeue(&qsort_cached_allocations, 0);
      if (!v22)
        v22 = malloc_type_malloc(0x40uLL, 0x102004053A8A26AuLL);
      *((_QWORD *)v22 + 4) = i;
      *((_QWORD *)v22 + 5) = v5;
      *((_QWORD *)v22 + 6) = v36;
      v23 = v2 - v20;
      if (v21 <= v2 - v20)
      {
        v24 = v20 - 1;
      }
      else
      {
        v23 = v20 - 1 - v1;
        v24 = v2;
      }
      if (v21 > v2 - v20)
        v25 = v20;
      else
        v25 = v1;
      if (v21 > v2 - v20)
        v2 = v20 - 1;
      else
        v1 = v20;
      *(_QWORD *)v22 = v37;
      *((_QWORD *)v22 + 1) = v25;
      v26 = (int)(float)((float)((float)(v23 + 1) * (float)v6) / (float)(v24 - v25 + 1));
      if (v26 <= 1)
        v27 = 1;
      else
        v27 = v26;
      if (v6 >= v26)
        v28 = v27;
      else
        v28 = 0;
      v22[14] = v6 - v28;
      v22[15] = v35;
      *((_QWORD *)v22 + 2) = v24;
      *((_QWORD *)v22 + 3) = v16;
      if (v16 == v3)
      {
        if (v6 >= v26)
          v6 = v27;
        v8 = qos_class_self();
        v9 = dispatch_get_global_queue(v8, 2uLL);
        dispatch_group_async_f(v3, v9, v22, (dispatch_function_t)_qsort_big_offset_with_meta_t);
      }
      else
      {
        v22[14] = v6;
        _qsort_big_offset_with_meta_t(v22);
        dispatch_group_wait(v16, 0xFFFFFFFFFFFFFFFFLL);
        dispatch_release(v16);
        v29 = qos_class_self();
        v30 = dispatch_get_global_queue(v29, 2uLL);
        block[0] = MEMORY[0x1E0C809B0];
        block[1] = 0x40000000;
        block[2] = ___qsort_big_offset_with_meta_t_block_invoke;
        block[3] = &__block_descriptor_tmp_2738;
        block[4] = v22;
        dispatch_async(v30, block);
      }
      if (v2 <= v1)
        return;
    }
    _qsort_offset_with_meta_t(v37, v1, v2);
  }
}

uint64_t _big_partition_offset_with_meta_t(uint64_t a1, uint64_t a2, uint64_t a3, NSObject *a4, unsigned int a5)
{
  uint64_t v7;
  BOOL v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  unint64_t v14;
  _QWORD *v15;
  unint64_t v16;
  unint64_t v17;
  _QWORD *v18;
  unint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  unint64_t v27;
  unint64_t v28;
  _QWORD *v29;
  unint64_t v30;
  _QWORD *v32;
  _QWORD *v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  _QWORD *v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;

  v7 = a3 - a2;
  v8 = __OFADD__(a3 - a2, 1);
  v9 = a3 - a2 + 1;
  v10 = (_QWORD *)(a1 + 16 * a2);
  v11 = v7 + 2;
  if (((v9 & 0x8000000000000000) != 0) == v8)
    v11 = v7 + 1;
  v12 = &v10[2 * (v11 >> 1)];
  v13 = (_QWORD *)(a1 + 16 * a3);
  if (v7 < 64)
  {
    v29 = &v10[2 * (v11 >> 1)];
    v18 = v10;
  }
  else
  {
    v14 = v9 >> 3;
    v15 = &v10[2 * (v9 >> 3)];
    v16 = *v10 & 0x3FFFFFFFFFFFFFFFLL;
    v17 = *v15 & 0x3FFFFFFFFFFFFFFFLL;
    v18 = v10;
    if (v16 != v17)
    {
      v18 = &v10[4 * v14];
      v19 = *v18 & 0x3FFFFFFFFFFFFFFFLL;
      if (v16 >= v19)
        v20 = &v10[4 * v14];
      else
        v20 = v10;
      if (v17 > v19)
        v20 = &v10[2 * (v9 >> 3)];
      if (v16 >= v19)
        v21 = v10;
      else
        v21 = &v10[4 * v14];
      if (v17 >= v19)
        v15 = v21;
      if (v16 >= v17)
        v15 = v20;
      if (v19 != v16 && v19 != v17)
        v18 = v15;
    }
    v23 = 2 * v14;
    v24 = -(uint64_t)v14;
    v25 = 16 * v14;
    v26 = &v12[v25 / 0xFFFFFFFFFFFFFFF8];
    v27 = v12[v25 / 0xFFFFFFFFFFFFFFF8] & 0x3FFFFFFFFFFFFFFFLL;
    v28 = *v12 & 0x3FFFFFFFFFFFFFFFLL;
    if (v27 == v28)
    {
      v29 = &v12[v25 / 0xFFFFFFFFFFFFFFF8];
    }
    else
    {
      v29 = &v12[(unint64_t)v25 / 8];
      v30 = *v29 & 0x3FFFFFFFFFFFFFFFLL;
      if (v30 != v27 && v30 != v28)
      {
        if (v27 >= v28)
        {
          if (v27 < v30)
            v29 = v26;
          if (v28 > v30)
            v29 = v12;
        }
        else
        {
          if (v27 >= v30)
            v29 = v26;
          if (v28 < v30)
            v29 = v12;
        }
      }
    }
    v32 = &v13[-2 * v23];
    v33 = &v13[2 * v24];
    v34 = *v32 & 0x3FFFFFFFFFFFFFFFLL;
    v35 = *v33 & 0x3FFFFFFFFFFFFFFFLL;
    if (v34 == v35)
    {
      v13 = v32;
    }
    else
    {
      v36 = *v13 & 0x3FFFFFFFFFFFFFFFLL;
      if (v34 >= v36)
        v37 = v13;
      else
        v37 = v32;
      if (v35 > v36)
        v37 = v33;
      if (v34 < v36)
        v32 = v13;
      if (v35 < v36)
        v32 = v33;
      if (v34 >= v35)
        v32 = v37;
      if (v36 == v35)
        v32 = v13;
      if (v36 != v34)
        v13 = v32;
    }
  }
  v38 = *v18 & 0x3FFFFFFFFFFFFFFFLL;
  v39 = *v29 & 0x3FFFFFFFFFFFFFFFLL;
  if (v38 == v39)
  {
    v29 = v18;
  }
  else
  {
    v40 = *v13 & 0x3FFFFFFFFFFFFFFFLL;
    if (v40 == v38 || v40 == v39)
    {
      v29 = v13;
    }
    else if (v38 >= v39)
    {
      if (v39 <= v40)
      {
        if (v38 >= v40)
          v29 = v13;
        else
          v29 = v18;
      }
    }
    else if (v39 >= v40)
    {
      if (v38 >= v40)
        v29 = v18;
      else
        v29 = v13;
    }
  }
  return parallel_partition_offset_with_meta_t(v10, v9, *v29 & 0x3FFFFFFFFFFFFFFFLL, a4, a5) + a2;
}

void ___qsort_big_offset_with_meta_t_block_invoke(uint64_t a1)
{
  madvise((void *)(**(_QWORD **)(a1 + 32) + 16 * *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8)), 16 * (*(_QWORD *)(*(_QWORD *)(a1 + 32) + 16) - *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8)), 4);
  OSAtomicEnqueue(&qsort_cached_allocations, *(void **)(a1 + 32), 0);
}

uint64_t parallel_partition_offset_with_meta_t(void *a1, uint64_t a2, uint64_t a3, NSObject *a4, unsigned int a5)
{
  int v5;
  size_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD v17[2];
  _QWORD context[10];

  v5 = a5;
  v17[1] = v17;
  context[9] = *MEMORY[0x1E0C80C00];
  context[6] = a1;
  v10 = 8 * a5;
  MEMORY[0x1E0C80A78](a1);
  v12 = (char *)v17 - v11;
  bzero((char *)v17 - v11, v10);
  v13 = (a2 / 0x4000) << 13;
  context[1] = v13;
  context[2] = a2;
  v14 = a2 - v13;
  context[4] = 0;
  context[5] = 0;
  context[7] = a3;
  context[8] = v12;
  if (v5 >= 1)
    memset(v12, 255, v10);
  v15 = v13 + 0x2000;
  if (v14 > v13 + 0x2000)
    v15 = a2 - v13;
  context[3] = v14 + ((v15 - v14 + 0x1FFF) & 0xFFFFFFFFFFFFE000);
  context[0] = 0;
  if (16 * a2 >= (unint64_t)(4 * *MEMORY[0x1E0C85AD8]))
    madvise(a1, 16 * a2, 3);
  if (a2 / 0x4000 < v5)
    v5 = a2 / 0x4000;
  dispatch_apply_f(v5, a4, context, (void (__cdecl *)(void *, size_t))partition_phase_offset_with_meta_t);
  return sequential_fixup_offset_with_meta_t((uint64_t)context, a2, v5);
}

unint64_t *partition_phase_offset_with_meta_t(unint64_t *result, uint64_t a2)
{
  unint64_t v2;
  int64_t v3;
  unint64_t v4;
  unint64_t v5;
  int64_t v6;
  unint64_t *v7;
  unint64_t v8;
  int64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  BOOL v13;
  uint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t *v29;
  uint64_t v30;
  uint64_t v31;
  __int128 v32;
  int v33;
  int64_t v35;
  unint64_t v36;
  int64_t v37;
  unint64_t v38;
  unint64_t v39;

  v2 = result[6];
  v3 = result[1];
  if ((uint64_t)*result >= v3)
    goto LABEL_5;
  do
    v4 = __ldxr(result);
  while (__stxr(v4 + 0x2000, result));
  if ((uint64_t)(v4 + 0x2000) > v3)
  {
    do
      v5 = __ldxr(result);
    while (__stxr(v5 - 0x2000, result));
LABEL_5:
    v4 = -1;
  }
  v6 = result[3];
  v7 = result + 2;
  if ((uint64_t)result[2] <= v6)
  {
LABEL_10:
    v11 = 0;
    if (v4 != -1)
    {
      v12 = 0;
      goto LABEL_21;
    }
    v9 = -1;
    v12 = 0;
LABEL_20:
    v4 = v9;
    goto LABEL_21;
  }
  do
  {
    v8 = __ldxr(v7);
    v9 = v8 - 0x2000;
  }
  while (__stxr(v8 - 0x2000, v7));
  if (v9 < v6)
  {
    do
      v10 = __ldxr(v7);
    while (__stxr(v10 + 0x2000, v7));
    goto LABEL_10;
  }
  v13 = v4 != -1;
  if (v8 != 0x1FFF && v4 != -1)
  {
    v11 = 0;
    v12 = 0;
    v21 = 0;
    v22 = 0;
    while (1)
    {
      v23 = v2 + 16 * v4;
      v24 = result[7];
      v25 = v2 + 16 * v9;
      while (1)
      {
        if (v22 < 0x2000)
        {
          v26 = (uint64_t *)(v23 + 16 * v22);
          while (1)
          {
            v27 = *v26;
            v26 += 2;
            if ((v27 & 0x3FFFFFFFFFFFFFFFuLL) > v24)
              break;
            if (++v22 == 0x2000)
            {
              v28 = 0x2000;
              if (v21 < 0x2000)
                goto LABEL_34;
              goto LABEL_38;
            }
          }
        }
        v28 = v22;
        if (v21 < 0x2000)
        {
LABEL_34:
          v29 = (uint64_t *)(v25 + 16 * v21);
          while (1)
          {
            v30 = *v29;
            v29 += 2;
            if ((v30 & 0x3FFFFFFFFFFFFFFFuLL) < v24)
              break;
            if (++v21 == 0x2000)
            {
              v22 = v28;
              goto LABEL_42;
            }
          }
        }
LABEL_38:
        v31 = v21;
        if (v28 == 0x2000 || v21 == 0x2000)
          break;
        v32 = *(_OWORD *)(v25 + 16 * v21);
        *(_OWORD *)(v25 + 16 * v21) = *(_OWORD *)(v23 + 16 * v28);
        *(_OWORD *)(v23 + 16 * v28) = v32;
        v22 = v28 + 1;
        ++v21;
        if (v28 > 8190 || v31 >= 0x1FFF)
          goto LABEL_42;
      }
      v22 = v28;
LABEL_42:
      v33 = v22 != 0x2000;
      if (v21 == 0x2000 && v22 == 0x2000)
        v33 = 2;
      if ((v33 & 1) != 0)
        goto LABEL_54;
      v35 = result[1];
      if ((uint64_t)*result >= v35)
        goto LABEL_52;
      do
        v4 = __ldxr(result);
      while (__stxr(v4 + 0x2000, result));
      if ((uint64_t)(v4 + 0x2000) > v35)
        break;
LABEL_53:
      v22 = 0;
      ++v12;
      if ((v33 - 1) > 1)
        goto LABEL_60;
LABEL_54:
      v37 = result[3];
      if ((uint64_t)result[2] > v37)
      {
        do
        {
          v38 = __ldxr(v7);
          v9 = v38 - 0x2000;
        }
        while (__stxr(v9, v7));
        if (v9 >= v37)
          goto LABEL_59;
        do
          v39 = __ldxr(v7);
        while (__stxr(v39 + 0x2000, v7));
      }
      v9 = -1;
LABEL_59:
      v21 = 0;
      ++v11;
LABEL_60:
      v13 = v4 != -1;
      if (v9 == -1 || v4 == -1)
        goto LABEL_19;
    }
    do
      v36 = __ldxr(result);
    while (__stxr(v36 - 0x2000, result));
LABEL_52:
    v4 = -1;
    goto LABEL_53;
  }
  v12 = 0;
  v11 = 0;
LABEL_19:
  if (!v13)
    goto LABEL_20;
LABEL_21:
  *(_QWORD *)(result[8] + 8 * a2) = v4;
  v15 = v12 << 13;
  v16 = result + 4;
  do
    v17 = __ldxr(v16);
  while (__stxr(v17 + v15, v16));
  v18 = v11 << 13;
  v19 = result + 5;
  do
    v20 = __ldxr(v19);
  while (__stxr(v20 + v18, v19));
  return result;
}

uint64_t sequential_fixup_offset_with_meta_t(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  __int128 v22;
  int v24;
  uint64_t v25;
  uint64_t v26;
  BOOL v27;
  uint64_t v28;
  unint64_t v29;
  void *v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t *v34;
  uint64_t v35;
  unint64_t v36;
  unint64_t v38;
  unint64_t v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  char *v52;
  char *v53;
  const char *v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t v57;
  uint64_t *v58;
  uint64_t v59;
  uint64_t *v60;
  uint64_t v61;
  __int128 v62;

  v6 = a3;
  qsort(*(void **)(a1 + 64), a3, 8uLL, (int (__cdecl *)(const void *, const void *))index_comp);
  v7 = *(_QWORD *)(a1 + 64);
  v8 = a3 - 1;
  v9 = 0;
  if (a3 < 1)
    goto LABEL_111;
  while (*(_QWORD *)(v7 + 8 * v9) == -1)
  {
    if (v6 == ++v9)
    {
      v9 = v6;
      break;
    }
  }
  if (a3 == 1)
  {
    v8 = 0;
    if (v9 >= 0)
      goto LABEL_46;
  }
  else
  {
LABEL_111:
    do
    {
      if (*(_QWORD *)(v7 + 8 * v8) != -1)
        break;
      --v8;
    }
    while (v8);
    if (v9 >= v8)
      goto LABEL_46;
  }
  v10 = 0;
  v11 = 0;
  do
  {
    v13 = *(_QWORD *)(a1 + 48);
    v12 = *(_QWORD *)(a1 + 56);
    v14 = v13 + 16 * *(_QWORD *)(v7 + 8 * v9);
    v15 = v13 + 16 * *(_QWORD *)(v7 + 8 * v8);
    while (1)
    {
      if (v10 < 0x2000)
      {
        v16 = (uint64_t *)(v14 + 16 * v10);
        while (1)
        {
          v17 = *v16;
          v16 += 2;
          if ((v17 & 0x3FFFFFFFFFFFFFFFuLL) > v12)
            break;
          if (++v10 == 0x2000)
          {
            v18 = 0x2000;
            if (v11 < 0x2000)
              goto LABEL_20;
            goto LABEL_24;
          }
        }
      }
      v18 = v10;
      if (v11 < 0x2000)
      {
LABEL_20:
        v19 = (uint64_t *)(v15 + 16 * v11);
        while (1)
        {
          v20 = *v19;
          v19 += 2;
          if ((v20 & 0x3FFFFFFFFFFFFFFFuLL) < v12)
            break;
          if (++v11 == 0x2000)
          {
            v10 = v18;
            goto LABEL_28;
          }
        }
      }
LABEL_24:
      v21 = v11;
      if (v18 == 0x2000 || v11 == 0x2000)
        break;
      v22 = *(_OWORD *)(v15 + 16 * v11);
      *(_OWORD *)(v15 + 16 * v11) = *(_OWORD *)(v14 + 16 * v18);
      *(_OWORD *)(v14 + 16 * v18) = v22;
      v10 = v18 + 1;
      ++v11;
      if (v18 > 8190 || v21 >= 0x1FFF)
        goto LABEL_28;
    }
    v10 = v18;
LABEL_28:
    if (v11 == 0x2000 && v10 == 0x2000)
      v24 = 2;
    else
      v24 = v10 != 0x2000;
    v7 = *(_QWORD *)(a1 + 64);
    if ((v24 & 1) == 0)
    {
      v25 = *(_QWORD *)(v7 + 8 * v9);
      if ((v25 & 0x8000000000000000) == 0 && v25 < *(_QWORD *)(a1 + 32))
      {
        *(_QWORD *)(v7 + 8 * v9) = -1;
        *(_QWORD *)(a1 + 32) += 0x2000;
      }
      v10 = 0;
      ++v9;
      if ((v24 - 1) > 1)
        continue;
    }
    v26 = *(_QWORD *)(v7 + 8 * v8);
    v27 = v26 >= a2 || v26 < a2 - *(_QWORD *)(a1 + 40);
    if (!v27)
    {
      *(_QWORD *)(v7 + 8 * v8) = -1;
      *(_QWORD *)(a1 + 40) += 0x2000;
    }
    v11 = 0;
    --v8;
  }
  while (v9 < v8);
LABEL_46:
  v29 = *(_QWORD *)(a1 + 32);
  v28 = *(_QWORD *)(a1 + 40);
  v30 = malloc_type_malloc(0x20000uLL, 0xDA5C7297uLL);
  if (a3 < 1)
  {
    v46 = *(_QWORD *)a1;
    v47 = *(_QWORD *)(a1 + 16) - 1;
  }
  else
  {
    v31 = 0;
    v32 = ~v28 + a2;
    v33 = a3;
    v34 = *(uint64_t **)(a1 + 64);
    v35 = 8 * a3;
    do
    {
      v36 = v34[v31];
      if (v36 != -1 && v32 <= v36)
        break;
      if (v36 != -1)
      {
        if (v29 <= v36)
          break;
        v38 = *(_QWORD *)(a1 + 32);
        if (v38 > v36)
        {
          v39 = 0;
          do
          {
            if (v34[v39 / 8] == v38)
            {
              v38 += 0x2000;
              *(_QWORD *)(a1 + 32) = v38;
            }
            v39 += 8;
          }
          while (v35 != v39);
          if ((int64_t)v38 >= *(_QWORD *)a1)
            break;
          memcpy(v30, (const void *)(*(_QWORD *)(a1 + 48) + 16 * v34[v31]), 0x20000uLL);
          memcpy((void *)(*(_QWORD *)(a1 + 48) + 16 * *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8 * v31)), (const void *)(*(_QWORD *)(a1 + 48) + 16 * *(_QWORD *)(a1 + 32)), 0x20000uLL);
          memcpy((void *)(*(_QWORD *)(a1 + 48) + 16 * *(_QWORD *)(a1 + 32)), v30, 0x20000uLL);
          v34 = *(uint64_t **)(a1 + 64);
          v34[v31] = *(_QWORD *)(a1 + 32);
          *(_QWORD *)(a1 + 32) += 0x2000;
        }
      }
      ++v31;
    }
    while (v31 != v33);
    v40 = v33;
    do
    {
      v41 = v34[(v40 - 1)];
      if (v29 > v41)
        break;
      if (v41 != -1)
      {
        if (v32 > v41)
          break;
        v42 = (v40 - 1);
        v43 = *(_QWORD *)(a1 + 40) + 0x2000;
        *(_QWORD *)(a1 + 40) = v43;
        v44 = v33 + 1;
        do
        {
          if (v34[(v44 - 2)] == a2 - v43)
          {
            v43 += 0x2000;
            *(_QWORD *)(a1 + 40) = v43;
          }
          --v44;
        }
        while (v44 > 1);
        if ((unint64_t)(a2 - v43) < *(_QWORD *)(a1 + 16))
          break;
        v45 = v42;
        memcpy(v30, (const void *)(*(_QWORD *)(a1 + 48) + 16 * v34[v42]), 0x20000uLL);
        memcpy((void *)(*(_QWORD *)(a1 + 48) + 16 * *(_QWORD *)(*(_QWORD *)(a1 + 64) + v45 * 8)), (const void *)(*(_QWORD *)(a1 + 48) + 16 * (a2 - *(_QWORD *)(a1 + 40))), 0x20000uLL);
        memcpy((void *)(*(_QWORD *)(a1 + 48) + 16 * (a2 - *(_QWORD *)(a1 + 40))), v30, 0x20000uLL);
        v34 = *(uint64_t **)(a1 + 64);
        v34[v45] = a2 - *(_QWORD *)(a1 + 40);
      }
      v27 = v40-- <= 1;
    }
    while (!v27);
    v46 = *(_QWORD *)a1;
    v47 = *(_QWORD *)(a1 + 16) - 1;
    do
    {
      v49 = *v34++;
      v48 = v49;
      if (v49 != -1)
      {
        if (v48 < v46)
          v46 = v48;
        v50 = v48 + 0x2000;
        v51 = v48 + 0x1FFF;
        if (v50 > v47)
          v47 = v51;
        if (v47 >= a2)
        {
          v52 = __si_assert_copy_extra_268();
          v53 = v52;
          v54 = "";
          if (v52)
            v54 = v52;
          __message_assert(v52, "OQueue.c", 13, "right < count", v54);
          free(v53);
          if (__valid_fs(-1))
          {
            MEMORY[0xBAD] = -559038737;
            abort();
          }
          MEMORY[0xC00] = -559038737;
          abort();
        }
      }
      --v33;
    }
    while (v33);
  }
  free(v30);
  if (v46 >= v47)
  {
    v55 = v46;
  }
  else
  {
    v55 = v46;
    do
    {
      v56 = *(_QWORD *)(a1 + 48);
      v57 = *(_QWORD *)(a1 + 56);
      v58 = (uint64_t *)(v56 + 16 * v46);
      while (1)
      {
        v59 = *v58;
        v58 += 2;
        if ((v59 & 0x3FFFFFFFFFFFFFFFuLL) >= v57)
          break;
        if (++v55 >= v47)
        {
          if (v47 <= v46 + 1)
            v55 = v46 + 1;
          else
            v55 = v47;
          goto LABEL_105;
        }
      }
      if (v55 < v47)
      {
        v60 = (uint64_t *)(v56 + 16 * v47);
        while (1)
        {
          v61 = *v60;
          v60 -= 2;
          if ((v61 & 0x3FFFFFFFFFFFFFFFuLL) <= v57)
            break;
          if (v55 >= --v47)
            goto LABEL_105;
        }
        v62 = *(_OWORD *)(v56 + 16 * v47);
        *(_OWORD *)(v56 + 16 * v47) = *(_OWORD *)(v56 + 16 * v55);
        *(_OWORD *)(*(_QWORD *)(a1 + 48) + 16 * v55++) = v62;
        --v47;
      }
      v46 = v55;
    }
    while (v55 < v47);
  }
LABEL_105:
  if ((*(_QWORD *)(*(_QWORD *)(a1 + 48) + 16 * v55) & 0x3FFFFFFFFFFFFFFFuLL) >= *(_QWORD *)(a1 + 56))
    return v55;
  else
    return v55 + 1;
}

uint64_t index_comp(_QWORD *a1, _QWORD *a2)
{
  unsigned int v2;

  if (*a1 >= *a2)
    v2 = 0;
  else
    v2 = -1;
  if (*a1 > *a2)
    return 1;
  else
    return v2;
}

{
  unsigned int v2;

  if (*a1 >= *a2)
    v2 = 0;
  else
    v2 = -1;
  if (*a1 > *a2)
    return 1;
  else
    return v2;
}

uint64_t _big_split_offset_with_meta_t(void *a1, uint64_t a2, uint64_t a3, NSObject *a4, signed int a5)
{
  uint64_t v5;

  v5 = a2 + 1;
  if (a5 >= 3)
  {
    while (v5 < (uint64_t)((unint64_t)a5 << 13))
    {
      if (a5-- <= 3)
      {
        a5 = 2;
        return parallel_partition_offset_with_meta_t(a1, v5, a3, a4, a5);
      }
    }
  }
  return parallel_partition_offset_with_meta_t(a1, v5, a3, a4, a5);
}

void *oqinit_offset_t(uint64_t a1, uint64_t a2)
{
  void *result;
  uint8_t v4[16];

  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 16) = a2;
  if (!a2)
  {
LABEL_5:
    result = 0;
    goto LABEL_6;
  }
  result = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 8 * a2, 0x6085D6BuLL);
  if (!result)
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)v4 = 0;
      _os_log_fault_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "allocation function returned null", v4, 2u);
    }
    goto LABEL_5;
  }
LABEL_6:
  *(_QWORD *)(a1 + 8) = result;
  *(_QWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = 0xFFFFFFFFLL;
  *(_DWORD *)a1 = 0;
  return result;
}

uint64_t ___qsort_offset_t_block_invoke(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  unint64_t v3;
  unint64_t v4;
  BOOL v5;
  unsigned int v6;

  v3 = *a2 & 0x3FFFFFFFFFFFFFFFLL;
  v4 = *a3 & 0x3FFFFFFFFFFFFFFFLL;
  v5 = v3 > v4;
  if (v3 == v4)
    v6 = 0;
  else
    v6 = -1;
  if (v5)
    return 1;
  else
    return v6;
}

void _qsort_big_offset_t(void *a1)
{
  uint64_t v1;
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  signed int v6;
  unint64_t i;
  qos_class_t v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v12;
  host_t v13;
  mach_error_t v14;
  unint64_t v15;
  NSObject *v16;
  qos_class_t v17;
  NSObject *global_queue;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _DWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  int v27;
  int v28;
  qos_class_t v29;
  NSObject *v30;
  char *v31;
  char *v32;
  const char *v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  _QWORD block[5];
  mach_msg_type_number_t host_info_outCnt;
  integer_t host_info_out[4];
  __int128 v41;
  __int128 v42;

  v1 = *((_QWORD *)a1 + 1);
  v2 = *((_QWORD *)a1 + 2);
  v3 = *((_QWORD *)a1 + 3);
  v4 = *((_QWORD *)a1 + 4);
  v5 = *((_QWORD *)a1 + 5);
  v36 = *((_QWORD *)a1 + 6);
  v37 = *(_QWORD *)a1;
  v6 = *((_DWORD *)a1 + 14);
  v35 = *((_DWORD *)a1 + 15);
  OSAtomicEnqueue(&qsort_cached_allocations, a1, 0);
  if (v2 > v1)
  {
    for (i = v4 + 1; ; ++i)
    {
      v10 = v2 - v1;
      if (v2 - v1 <= v5 || i > 9)
        break;
      if (v6 <= 1)
        v6 = 1;
      v12 = getSize_memSize;
      if (!getSize_memSize)
      {
        v41 = 0u;
        v42 = 0u;
        *(_OWORD *)host_info_out = 0u;
        v13 = MEMORY[0x1BCCB1010]();
        host_info_outCnt = 12;
        v14 = host_info(v13, 1, host_info_out, &host_info_outCnt);
        if (v14)
        {
          mach_error("flushsize", v14);
          exit(1);
        }
        v12 = *((_QWORD *)&v42 + 1);
        getSize_memSize = *((_QWORD *)&v42 + 1);
      }
      v15 = 3 * v12 / 5uLL;
      v16 = v3;
      if (8 * v10 > v15)
        v16 = dispatch_group_create();
      if (v10 <= v36 || 8 * v10 >= v15)
      {
        v19 = _partition_offset_t(v37, v1, v2);
      }
      else
      {
        v17 = qos_class_self();
        global_queue = dispatch_get_global_queue(v17, 2uLL);
        v19 = _big_partition_offset_t(v37, v1, v2, global_queue, v6);
      }
      v20 = v19;
      v21 = v19 - v1;
      if (v19 < v1)
      {
        v31 = __si_assert_copy_extra_268();
        v32 = v31;
        v33 = "";
        if (v31)
          v33 = v31;
        __message_assert(v31, "OQueue.c", 14, "q>=left", v33);
        free(v32);
        if (__valid_fs(-1))
          v34 = 2989;
        else
          v34 = 3072;
        *(_DWORD *)v34 = -559038737;
        abort();
      }
      v22 = OSAtomicDequeue(&qsort_cached_allocations, 0);
      if (!v22)
        v22 = malloc_type_malloc(0x40uLL, 0x10300409C00947AuLL);
      *((_QWORD *)v22 + 4) = i;
      *((_QWORD *)v22 + 5) = v5;
      *((_QWORD *)v22 + 6) = v36;
      v23 = v2 - v20;
      if (v21 <= v2 - v20)
      {
        v24 = v20 - 1;
      }
      else
      {
        v23 = v20 - 1 - v1;
        v24 = v2;
      }
      if (v21 > v2 - v20)
        v25 = v20;
      else
        v25 = v1;
      if (v21 > v2 - v20)
        v2 = v20 - 1;
      else
        v1 = v20;
      *(_QWORD *)v22 = v37;
      *((_QWORD *)v22 + 1) = v25;
      v26 = (int)(float)((float)((float)(v23 + 1) * (float)v6) / (float)(v24 - v25 + 1));
      if (v26 <= 1)
        v27 = 1;
      else
        v27 = v26;
      if (v6 >= v26)
        v28 = v27;
      else
        v28 = 0;
      v22[14] = v6 - v28;
      v22[15] = v35;
      *((_QWORD *)v22 + 2) = v24;
      *((_QWORD *)v22 + 3) = v16;
      if (v16 == v3)
      {
        if (v6 >= v26)
          v6 = v27;
        v8 = qos_class_self();
        v9 = dispatch_get_global_queue(v8, 2uLL);
        dispatch_group_async_f(v3, v9, v22, (dispatch_function_t)_qsort_big_offset_t);
      }
      else
      {
        v22[14] = v6;
        _qsort_big_offset_t(v22);
        dispatch_group_wait(v16, 0xFFFFFFFFFFFFFFFFLL);
        dispatch_release(v16);
        v29 = qos_class_self();
        v30 = dispatch_get_global_queue(v29, 2uLL);
        block[0] = MEMORY[0x1E0C809B0];
        block[1] = 0x40000000;
        block[2] = ___qsort_big_offset_t_block_invoke;
        block[3] = &__block_descriptor_tmp_23_2754;
        block[4] = v22;
        dispatch_async(v30, block);
      }
      if (v2 <= v1)
        return;
    }
    _qsort_offset_t(v37, v1, v2);
  }
}

uint64_t _big_partition_offset_t(uint64_t a1, uint64_t a2, uint64_t a3, NSObject *a4, unsigned int a5)
{
  uint64_t v7;
  BOOL v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  unint64_t v14;
  _QWORD *v15;
  unint64_t v16;
  unint64_t v17;
  _QWORD *v18;
  unint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  unint64_t v27;
  unint64_t v28;
  _QWORD *v29;
  unint64_t v30;
  _QWORD *v32;
  _QWORD *v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  _QWORD *v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;

  v7 = a3 - a2;
  v8 = __OFADD__(a3 - a2, 1);
  v9 = a3 - a2 + 1;
  v10 = (_QWORD *)(a1 + 8 * a2);
  v11 = v7 + 2;
  if (((v9 & 0x8000000000000000) != 0) == v8)
    v11 = v7 + 1;
  v12 = &v10[v11 >> 1];
  v13 = (_QWORD *)(a1 + 8 * a3);
  if (v7 < 64)
  {
    v29 = &v10[v11 >> 1];
    v18 = v10;
  }
  else
  {
    v14 = v9 >> 3;
    v15 = &v10[v9 >> 3];
    v16 = *v10 & 0x3FFFFFFFFFFFFFFFLL;
    v17 = *v15 & 0x3FFFFFFFFFFFFFFFLL;
    v18 = v10;
    if (v16 != v17)
    {
      v18 = &v10[2 * v14];
      v19 = *v18 & 0x3FFFFFFFFFFFFFFFLL;
      if (v16 >= v19)
        v20 = &v10[2 * v14];
      else
        v20 = v10;
      if (v17 > v19)
        v20 = &v10[v9 >> 3];
      if (v16 >= v19)
        v21 = v10;
      else
        v21 = &v10[2 * v14];
      if (v17 >= v19)
        v15 = v21;
      if (v16 >= v17)
        v15 = v20;
      if (v19 != v16 && v19 != v17)
        v18 = v15;
    }
    v23 = 2 * v14;
    v24 = -(uint64_t)v14;
    v25 = 8 * v14;
    v26 = &v12[v25 / 0xFFFFFFFFFFFFFFF8];
    v27 = v12[v25 / 0xFFFFFFFFFFFFFFF8] & 0x3FFFFFFFFFFFFFFFLL;
    v28 = *v12 & 0x3FFFFFFFFFFFFFFFLL;
    if (v27 == v28)
    {
      v29 = &v12[v25 / 0xFFFFFFFFFFFFFFF8];
    }
    else
    {
      v29 = &v12[(unint64_t)v25 / 8];
      v30 = *v29 & 0x3FFFFFFFFFFFFFFFLL;
      if (v30 != v27 && v30 != v28)
      {
        if (v27 >= v28)
        {
          if (v27 < v30)
            v29 = v26;
          if (v28 > v30)
            v29 = v12;
        }
        else
        {
          if (v27 >= v30)
            v29 = v26;
          if (v28 < v30)
            v29 = v12;
        }
      }
    }
    v32 = &v13[-v23];
    v33 = &v13[v24];
    v34 = *v32 & 0x3FFFFFFFFFFFFFFFLL;
    v35 = *v33 & 0x3FFFFFFFFFFFFFFFLL;
    if (v34 == v35)
    {
      v13 = v32;
    }
    else
    {
      v36 = *v13 & 0x3FFFFFFFFFFFFFFFLL;
      if (v34 >= v36)
        v37 = v13;
      else
        v37 = v32;
      if (v35 > v36)
        v37 = v33;
      if (v34 < v36)
        v32 = v13;
      if (v35 < v36)
        v32 = v33;
      if (v34 >= v35)
        v32 = v37;
      if (v36 == v35)
        v32 = v13;
      if (v36 != v34)
        v13 = v32;
    }
  }
  v38 = *v18 & 0x3FFFFFFFFFFFFFFFLL;
  v39 = *v29 & 0x3FFFFFFFFFFFFFFFLL;
  if (v38 == v39)
  {
    v29 = v18;
  }
  else
  {
    v40 = *v13 & 0x3FFFFFFFFFFFFFFFLL;
    if (v40 == v38 || v40 == v39)
    {
      v29 = v13;
    }
    else if (v38 >= v39)
    {
      if (v39 <= v40)
      {
        if (v38 >= v40)
          v29 = v13;
        else
          v29 = v18;
      }
    }
    else if (v39 >= v40)
    {
      if (v38 >= v40)
        v29 = v18;
      else
        v29 = v13;
    }
  }
  return parallel_partition_offset_t(v10, v9, *v29 & 0x3FFFFFFFFFFFFFFFLL, a4, a5) + a2;
}

void ___qsort_big_offset_t_block_invoke(uint64_t a1)
{
  madvise((void *)(**(_QWORD **)(a1 + 32) + 8 * *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8)), 8 * (*(_QWORD *)(*(_QWORD *)(a1 + 32) + 16) - *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8)), 4);
  OSAtomicEnqueue(&qsort_cached_allocations, *(void **)(a1 + 32), 0);
}

uint64_t parallel_partition_offset_t(void *a1, uint64_t a2, uint64_t a3, NSObject *a4, unsigned int a5)
{
  int v5;
  size_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD v17[2];
  _QWORD context[10];

  v5 = a5;
  v17[1] = v17;
  context[9] = *MEMORY[0x1E0C80C00];
  context[6] = a1;
  v10 = 8 * a5;
  MEMORY[0x1E0C80A78](a1);
  v12 = (char *)v17 - v11;
  bzero((char *)v17 - v11, v10);
  v13 = (a2 / 0x4000) << 13;
  context[1] = v13;
  context[2] = a2;
  v14 = a2 - v13;
  context[4] = 0;
  context[5] = 0;
  context[7] = a3;
  context[8] = v12;
  if (v5 >= 1)
    memset(v12, 255, v10);
  v15 = v13 + 0x2000;
  if (v14 > v13 + 0x2000)
    v15 = a2 - v13;
  context[3] = v14 + ((v15 - v14 + 0x1FFF) & 0xFFFFFFFFFFFFE000);
  context[0] = 0;
  if (8 * a2 >= (unint64_t)(4 * *MEMORY[0x1E0C85AD8]))
    madvise(a1, 8 * a2, 3);
  if (a2 / 0x4000 < v5)
    v5 = a2 / 0x4000;
  dispatch_apply_f(v5, a4, context, (void (__cdecl *)(void *, size_t))partition_phase_offset_t);
  return sequential_fixup_offset_t((uint64_t)context, a2, v5);
}

unint64_t *partition_phase_offset_t(unint64_t *result, uint64_t a2)
{
  unint64_t v2;
  int64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t *v6;
  int64_t v7;
  unint64_t v8;
  int64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  BOOL v13;
  unint64_t *v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;

  v2 = result[6];
  v3 = result[1];
  if ((uint64_t)*result >= v3)
    goto LABEL_5;
  do
    v4 = __ldxr(result);
  while (__stxr(v4 + 0x2000, result));
  if ((uint64_t)(v4 + 0x2000) > v3)
  {
    do
      v5 = __ldxr(result);
    while (__stxr(v5 - 0x2000, result));
LABEL_5:
    v4 = -1;
  }
  v7 = result[3];
  v6 = result + 2;
  if ((uint64_t)result[2] <= v7)
  {
LABEL_10:
    v11 = 0;
    if (v4 != -1)
    {
      v12 = 0;
      goto LABEL_21;
    }
    v9 = -1;
    v12 = 0;
LABEL_20:
    v4 = v9;
    goto LABEL_21;
  }
  do
  {
    v8 = __ldxr(v6);
    v9 = v8 - 0x2000;
  }
  while (__stxr(v8 - 0x2000, v6));
  if (v9 < v7)
  {
    do
      v10 = __ldxr(v6);
    while (__stxr(v10 + 0x2000, v6));
    goto LABEL_10;
  }
  v13 = v4 != -1;
  if (v8 != 0x1FFF && v4 != -1)
  {
    v11 = 0;
    v12 = 0;
    v20 = 0;
    v21 = 0;
    while (1)
    {
      v22 = v2 + 8 * v4;
      v23 = result[7];
      v24 = v2 + 8 * v9;
      while (1)
      {
        if (v21 < 0x2000)
        {
          while ((*(_QWORD *)(v22 + 8 * v21) & 0x3FFFFFFFFFFFFFFFuLL) <= v23)
          {
            if (++v21 == 0x2000)
            {
              v25 = 0x2000;
              if (v20 < 0x2000)
                goto LABEL_33;
              goto LABEL_36;
            }
          }
        }
        v25 = v21;
        if (v20 < 0x2000)
        {
LABEL_33:
          while ((*(_QWORD *)(v24 + 8 * v20) & 0x3FFFFFFFFFFFFFFFuLL) >= v23)
          {
            if (++v20 == 0x2000)
            {
              v21 = v25;
              goto LABEL_40;
            }
          }
        }
LABEL_36:
        v26 = v20;
        if (v25 == 0x2000 || v20 == 0x2000)
          break;
        v27 = *(_QWORD *)(v24 + 8 * v20);
        *(_QWORD *)(v24 + 8 * v20) = *(_QWORD *)(v22 + 8 * v25);
        *(_QWORD *)(v22 + 8 * v25) = v27;
        v21 = v25 + 1;
        ++v20;
        if (v25 > 8190 || v26 >= 0x1FFF)
          goto LABEL_40;
      }
      v21 = v25;
LABEL_40:
      v28 = v21 != 0x2000;
      if (v20 == 0x2000 && v21 == 0x2000)
        v28 = 2;
      if ((v28 & 1) != 0)
        goto LABEL_52;
      if ((uint64_t)*result >= v3)
        goto LABEL_50;
      do
        v4 = __ldxr(result);
      while (__stxr(v4 + 0x2000, result));
      if ((uint64_t)(v4 + 0x2000) > v3)
        break;
LABEL_51:
      v21 = 0;
      ++v12;
      if ((v28 - 1) > 1)
        goto LABEL_58;
LABEL_52:
      if ((uint64_t)*v6 > v7)
      {
        do
        {
          v31 = __ldxr(v6);
          v9 = v31 - 0x2000;
        }
        while (__stxr(v9, v6));
        if (v9 >= v7)
          goto LABEL_57;
        do
          v32 = __ldxr(v6);
        while (__stxr(v32 + 0x2000, v6));
      }
      v9 = -1;
LABEL_57:
      v20 = 0;
      ++v11;
LABEL_58:
      v13 = v4 != -1;
      if (v9 == -1 || v4 == -1)
        goto LABEL_19;
    }
    do
      v30 = __ldxr(result);
    while (__stxr(v30 - 0x2000, result));
LABEL_50:
    v4 = -1;
    goto LABEL_51;
  }
  v12 = 0;
  v11 = 0;
LABEL_19:
  if (!v13)
    goto LABEL_20;
LABEL_21:
  *(_QWORD *)(result[8] + 8 * a2) = v4;
  v15 = result + 4;
  do
    v16 = __ldxr(v15);
  while (__stxr(v16 + (v12 << 13), v15));
  v17 = v11 << 13;
  v18 = result + 5;
  do
    v19 = __ldxr(v18);
  while (__stxr(v19 + v17, v18));
  return result;
}

uint64_t sequential_fixup_offset_t(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v23;
  unint64_t v24;
  void *v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t *v29;
  uint64_t v30;
  unint64_t v31;
  BOOL v32;
  unint64_t v33;
  unint64_t v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  char *v47;
  char *v48;
  const char *v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  uint64_t v54;

  v6 = a3;
  qsort(*(void **)(a1 + 64), a3, 8uLL, (int (__cdecl *)(const void *, const void *))index_comp);
  v7 = *(_QWORD *)(a1 + 64);
  v8 = a3 - 1;
  v9 = 0;
  if (a3 < 1)
    goto LABEL_107;
  while (*(_QWORD *)(v7 + 8 * v9) == -1)
  {
    if (v6 == ++v9)
    {
      v9 = v6;
      break;
    }
  }
  if (a3 == 1)
  {
    v8 = 0;
    if (v9 < 0)
    {
LABEL_9:
      v10 = 0;
      v11 = 0;
      v12 = *(_QWORD *)(a1 + 48);
      while (1)
      {
        v13 = *(_QWORD *)(v7 + 8 * v9);
        v14 = v12 + 8 * v13;
        v15 = *(_QWORD *)(v7 + 8 * v8);
        v16 = v12 + 8 * v15;
        v17 = *(_QWORD *)(a1 + 56);
        while (1)
        {
          if (v10 < 0x2000)
          {
            while ((*(_QWORD *)(v14 + 8 * v10) & 0x3FFFFFFFFFFFFFFFuLL) <= v17)
            {
              if (++v10 == 0x2000)
              {
                v18 = 0x2000;
                if (v11 < 0x2000)
                  goto LABEL_18;
                goto LABEL_21;
              }
            }
          }
          v18 = v10;
          if (v11 < 0x2000)
          {
LABEL_18:
            while ((*(_QWORD *)(v16 + 8 * v11) & 0x3FFFFFFFFFFFFFFFuLL) >= v17)
            {
              if (++v11 == 0x2000)
              {
                v10 = v18;
                goto LABEL_25;
              }
            }
          }
LABEL_21:
          v19 = v11;
          if (v18 == 0x2000 || v11 == 0x2000)
            break;
          v20 = *(_QWORD *)(v16 + 8 * v11);
          *(_QWORD *)(v16 + 8 * v11) = *(_QWORD *)(v14 + 8 * v18);
          *(_QWORD *)(v14 + 8 * v18) = v20;
          v10 = v18 + 1;
          ++v11;
          if (v18 > 8190 || v19 >= 0x1FFF)
            goto LABEL_25;
        }
        v10 = v18;
LABEL_25:
        v21 = v10 != 0x2000;
        if (v11 == 0x2000 && v10 == 0x2000)
          v21 = 2;
        if ((v21 & 1) != 0)
          goto LABEL_36;
        if ((v13 & 0x8000000000000000) == 0 && v13 < *(_QWORD *)(a1 + 32))
        {
          *(_QWORD *)(v7 + 8 * v9) = -1;
          *(_QWORD *)(a1 + 32) += 0x2000;
        }
        ++v9;
        if ((v21 - 1) > 1)
        {
          v10 = 0;
          if (v9 >= v8)
            break;
        }
        else
        {
          v10 = 0;
          v15 = *(_QWORD *)(v7 + 8 * v8);
LABEL_36:
          if (v15 < a2 && v15 >= a2 - *(_QWORD *)(a1 + 40))
          {
            *(_QWORD *)(v7 + 8 * v8) = -1;
            *(_QWORD *)(a1 + 40) += 0x2000;
          }
          v11 = 0;
          if (v9 >= --v8)
            break;
        }
      }
    }
  }
  else
  {
LABEL_107:
    do
    {
      if (*(_QWORD *)(v7 + 8 * v8) != -1)
        break;
      --v8;
    }
    while (v8);
    if (v9 < v8)
      goto LABEL_9;
  }
  v24 = *(_QWORD *)(a1 + 32);
  v23 = *(_QWORD *)(a1 + 40);
  v25 = malloc_type_malloc(0x10000uLL, 0x3D422C00uLL);
  if (a3 < 1)
  {
    v41 = *(_QWORD *)a1;
    v42 = *(_QWORD *)(a1 + 16) - 1;
  }
  else
  {
    v26 = 0;
    v27 = ~v23 + a2;
    v28 = a3;
    v29 = *(uint64_t **)(a1 + 64);
    v30 = 8 * a3;
    do
    {
      v31 = v29[v26];
      v32 = v31 == -1 || v27 > v31;
      if (!v32)
        break;
      if (v31 != -1)
      {
        if (v24 <= v31)
          break;
        v33 = *(_QWORD *)(a1 + 32);
        if (v33 > v31)
        {
          v34 = 0;
          do
          {
            if (v29[v34 / 8] == v33)
            {
              v33 += 0x2000;
              *(_QWORD *)(a1 + 32) = v33;
            }
            v34 += 8;
          }
          while (v30 != v34);
          if ((int64_t)v33 >= *(_QWORD *)a1)
            break;
          memcpy(v25, (const void *)(*(_QWORD *)(a1 + 48) + 8 * v29[v26]), 0x10000uLL);
          memcpy((void *)(*(_QWORD *)(a1 + 48) + 8 * *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8 * v26)), (const void *)(*(_QWORD *)(a1 + 48) + 8 * *(_QWORD *)(a1 + 32)), 0x10000uLL);
          memcpy((void *)(*(_QWORD *)(a1 + 48) + 8 * *(_QWORD *)(a1 + 32)), v25, 0x10000uLL);
          v29 = *(uint64_t **)(a1 + 64);
          v29[v26] = *(_QWORD *)(a1 + 32);
          *(_QWORD *)(a1 + 32) += 0x2000;
        }
      }
      ++v26;
    }
    while (v26 != v28);
    v35 = v28;
    do
    {
      v36 = v29[(v35 - 1)];
      if (v24 > v36)
        break;
      if (v36 != -1)
      {
        if (v27 > v36)
          break;
        v37 = (v35 - 1);
        v38 = *(_QWORD *)(a1 + 40) + 0x2000;
        *(_QWORD *)(a1 + 40) = v38;
        v39 = v28 + 1;
        do
        {
          if (v29[(v39 - 2)] == a2 - v38)
          {
            v38 += 0x2000;
            *(_QWORD *)(a1 + 40) = v38;
          }
          --v39;
        }
        while (v39 > 1);
        if ((unint64_t)(a2 - v38) < *(_QWORD *)(a1 + 16))
          break;
        v40 = v37;
        memcpy(v25, (const void *)(*(_QWORD *)(a1 + 48) + 8 * v29[v37]), 0x10000uLL);
        memcpy((void *)(*(_QWORD *)(a1 + 48) + 8 * *(_QWORD *)(*(_QWORD *)(a1 + 64) + v40 * 8)), (const void *)(*(_QWORD *)(a1 + 48) + 8 * (a2 - *(_QWORD *)(a1 + 40))), 0x10000uLL);
        memcpy((void *)(*(_QWORD *)(a1 + 48) + 8 * (a2 - *(_QWORD *)(a1 + 40))), v25, 0x10000uLL);
        v29 = *(uint64_t **)(a1 + 64);
        v29[v40] = a2 - *(_QWORD *)(a1 + 40);
      }
      v32 = v35-- <= 1;
    }
    while (!v32);
    v41 = *(_QWORD *)a1;
    v42 = *(_QWORD *)(a1 + 16) - 1;
    do
    {
      v44 = *v29++;
      v43 = v44;
      if (v44 != -1)
      {
        if (v43 < v41)
          v41 = v43;
        v45 = v43 + 0x2000;
        v46 = v43 + 0x1FFF;
        if (v45 > v42)
          v42 = v46;
        if (v42 >= a2)
        {
          v47 = __si_assert_copy_extra_268();
          v48 = v47;
          v49 = "";
          if (v47)
            v49 = v47;
          __message_assert(v47, "OQueue.c", 14, "right < count", v49);
          free(v48);
          if (__valid_fs(-1))
          {
            MEMORY[0xBAD] = -559038737;
            abort();
          }
          MEMORY[0xC00] = -559038737;
          abort();
        }
      }
      --v28;
    }
    while (v28);
  }
  free(v25);
  v50 = *(_QWORD *)(a1 + 48);
  if (v41 >= v42)
  {
    v51 = v41;
  }
  else
  {
    v51 = v41;
    do
    {
      v52 = *(_QWORD *)(a1 + 56);
      while (1)
      {
        v53 = *(_QWORD *)(v50 + 8 * v51);
        if ((v53 & 0x3FFFFFFFFFFFFFFFuLL) >= v52)
          break;
        if (++v51 >= v42)
        {
          if (v42 <= v41 + 1)
            v51 = v41 + 1;
          else
            v51 = v42;
          goto LABEL_101;
        }
      }
      if (v51 < v42)
      {
        while (1)
        {
          v54 = *(_QWORD *)(v50 + 8 * v42);
          if ((v54 & 0x3FFFFFFFFFFFFFFFuLL) <= v52)
            break;
          if (v51 >= --v42)
            goto LABEL_101;
        }
        *(_QWORD *)(v50 + 8 * v42) = v53;
        *(_QWORD *)(v50 + 8 * v51++) = v54;
        --v42;
      }
      v41 = v51;
    }
    while (v51 < v42);
  }
LABEL_101:
  if ((*(_QWORD *)(v50 + 8 * v51) & 0x3FFFFFFFFFFFFFFFuLL) >= *(_QWORD *)(a1 + 56))
    return v51;
  else
    return v51 + 1;
}

uint64_t _big_split_offset_t(void *a1, uint64_t a2, uint64_t a3, NSObject *a4, signed int a5)
{
  uint64_t v5;

  v5 = a2 + 1;
  if (a5 >= 3)
  {
    while (v5 < (uint64_t)((unint64_t)a5 << 13))
    {
      if (a5-- <= 3)
      {
        a5 = 2;
        return parallel_partition_offset_t(a1, v5, a3, a4, a5);
      }
    }
  }
  return parallel_partition_offset_t(a1, v5, a3, a4, a5);
}

void oqdispose_JustPositionOffset_t(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  if (*(uint64_t *)(a1 + 24) >= 1)
  {
    v2 = 0;
    v3 = 8;
    do
    {
      CFRelease(*(CFTypeRef *)(*(_QWORD *)(a1 + 8) + v3));
      ++v2;
      v3 += 16;
    }
    while (v2 < *(_QWORD *)(a1 + 24));
  }
  if (*(_DWORD *)(a1 + 48))
  {
    v4 = *(_QWORD *)(a1 + 32);
    if (v4 < *(_QWORD *)(a1 + 40))
    {
      v5 = (16 * v4) | 8;
      do
      {
        CFRelease(*(CFTypeRef *)(*(_QWORD *)(a1 + 8) + v5));
        ++v4;
        v5 += 16;
      }
      while (v4 < *(_QWORD *)(a1 + 40));
    }
  }
  free(*(void **)(a1 + 8));
}

void parallel_qsort_JustPositionOffset_t(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  NSObject *v5;
  int v6;
  uint64_t v7;
  size_t v8;
  int v9[2];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (a2 > 2047)
  {
    v4 = OSAtomicDequeue(&qsort_cached_allocations, 0);
    if (!v4)
      v4 = malloc_type_malloc(0x40uLL, 0x102004053A8A26AuLL);
    v5 = dispatch_group_create();
    v4[3] = v5;
    v4[4] = 0;
    v4[1] = 0;
    v4[2] = a2 - 1;
    *v4 = a1;
    v6 = thread_count;
    if (!thread_count)
    {
      *(_QWORD *)v9 = 0x1900000006;
      v8 = 4;
      sysctl(v9, 2u, &thread_count, &v8, 0, 0);
      v6 = thread_count;
    }
    *((_DWORD *)v4 + 14) = v6;
    v4[5] = (uint64_t)sqrt((double)a2) / 2;
    if (!v6)
    {
      *(_QWORD *)v9 = 0x1900000006;
      v8 = 4;
      sysctl(v9, 2u, &thread_count, &v8, 0, 0);
      v6 = thread_count;
    }
    v7 = a2 / (2 * v6);
    if (v7 <= 0x8000)
    {
      v7 = 0x8000;
    }
    else if (!v6)
    {
      *(_QWORD *)v9 = 0x1900000006;
      v8 = 4;
      sysctl(v9, 2u, &thread_count, &v8, 0, 0);
      v7 = a2 / (2 * thread_count);
    }
    v4[6] = v7;
    if ((uint64_t)v4[5] <= 2047)
      v4[5] = 2048;
    _qsort_big_JustPositionOffset_t(v4);
    dispatch_group_wait(v5, 0xFFFFFFFFFFFFFFFFLL);
    dispatch_release(v5);
  }
  else
  {
    _qsort_JustPositionOffset_t(a1, 0, a2 - 1);
  }
}

void _qsort_JustPositionOffset_t(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  unint64_t v10;
  size_t v11;
  uint64x2_t *v12;
  uint64x2_t *v13;
  unint64_t *v14;
  size_t v15;
  uint64x2_t *v16;
  unint64_t v17;
  unint64_t v18;
  uint64x2_t *v19;
  unint64_t v20;
  BOOL v21;
  uint64x2_t *v22;
  uint64x2_t *v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  uint64x2_t v28;
  uint64x2_t v29;
  uint64x2_t *v30;
  uint64_t v31;
  uint64_t v32;
  uint64x2_t v33;
  __int128 v34;
  uint64_t v35;
  BOOL v36;
  uint64_t v37;
  uint64_t v38;
  _QWORD *v39;
  unint64_t *v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  uint64x2_t *v45;
  unint64_t *v46;
  unint64_t v47;
  unint64_t v48;
  unint64_t v49;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  __int128 v54;
  unint64_t v55;
  unint64_t v56;
  uint64_t v57;
  _QWORD *v58;
  uint64_t v59;
  char *v60;
  char *v61;
  const char *v62;

  v6 = malloc_type_malloc(0x800uLL, 0x1000040451B5BE8uLL);
  *v6 = 0;
  v6[1] = 0;
  v7 = 1;
  while (2)
  {
    if (a3 <= a2)
      goto LABEL_3;
    if (v7 <= 128)
      v9 = 128;
    else
      v9 = v7;
    while (1)
    {
      v10 = a3 - a2;
      if (a3 - a2 <= 16)
        break;
      v11 = v10 + 1;
      v12 = (uint64x2_t *)(a1 + 16 * a2);
      v13 = &v12[(v10 + 1) >> 1];
      v14 = (unint64_t *)(a1 + 16 * a3);
      if (v10 < 0x400)
      {
        v19 = (uint64x2_t *)(a1 + 16 * a2);
        v22 = v13;
LABEL_21:
        v23 = (uint64x2_t *)(a1 + 16 * a3);
        goto LABEL_22;
      }
      v15 = v11 >> 3;
      v16 = &v12[v11 >> 3];
      v17 = v12->i64[0];
      v18 = v16->i64[0];
      v19 = (uint64x2_t *)(a1 + 16 * a2);
      if (v12->i64[0] != v16->i64[0])
      {
        v20 = v12[2 * v15].u64[0];
        v21 = v20 == v17 || v20 == v18;
        v19 = &v12[2 * v15];
        if (!v21)
        {
          v19 = &v12[v11 >> 3];
          if (v17 >= v18)
          {
            if (v18 <= v20)
            {
              if (v17 >= v20)
                v19 = &v12[2 * v15];
              else
                v19 = (uint64x2_t *)(a1 + 16 * a2);
            }
          }
          else if (v18 >= v20)
          {
            if (v17 >= v20)
              v19 = (uint64x2_t *)(a1 + 16 * a2);
            else
              v19 = &v12[2 * v15];
          }
        }
      }
      v40 = (unint64_t *)&v13[-v15];
      v41 = *v40;
      v42 = v13->i64[0];
      if (*v40 == v13->i64[0])
      {
        v22 = &v13[-v15];
      }
      else
      {
        v22 = &v13[v15];
        v43 = v22->i64[0];
        if (v22->i64[0] != v41 && v43 != v42)
        {
          if (v41 >= v43)
            v45 = &v13[v15];
          else
            v45 = &v13[-v15];
          if (v42 > v43)
            v45 = v13;
          if (v41 >= v43)
            v22 = &v13[-v15];
          if (v42 < v43)
            v22 = v13;
          if (v41 >= v42)
            v22 = v45;
        }
      }
      v46 = &v14[-4 * v15];
      v23 = (uint64x2_t *)&v14[-2 * v15];
      v47 = *v46;
      v48 = v23->i64[0];
      if (*v46 == v23->i64[0])
      {
        v23 = (uint64x2_t *)v46;
      }
      else
      {
        v49 = *v14;
        if (*v14 == v47 || v49 == v48)
          goto LABEL_21;
        if (v47 >= v48)
        {
          if (v48 <= v49)
          {
            if (v47 >= v49)
              v23 = (uint64x2_t *)(a1 + 16 * a3);
            else
              v23 = (uint64x2_t *)v46;
          }
        }
        else if (v48 >= v49)
        {
          if (v47 >= v49)
            v23 = (uint64x2_t *)v46;
          else
            v23 = (uint64x2_t *)(a1 + 16 * a3);
        }
      }
LABEL_22:
      v24 = v19->i64[0];
      v25 = v22->i64[0];
      if (v19->i64[0] == v22->i64[0])
      {
        v22 = v19;
      }
      else
      {
        v26 = v23->i64[0];
        if (v23->i64[0] == v24 || v26 == v25)
        {
          v22 = v23;
        }
        else if (v24 >= v25)
        {
          if (v25 <= v26)
          {
            if (v24 >= v26)
              v22 = v23;
            else
              v22 = v19;
          }
        }
        else if (v25 >= v26)
        {
          if (v24 >= v26)
            v22 = v19;
          else
            v22 = v23;
        }
      }
      v28 = *v22;
      *v22 = *(uint64x2_t *)v14;
      *(uint64x2_t *)v14 = v28;
      v29 = *v12;
      v30 = (uint64x2_t *)(a1 + 16 + 16 * a2);
      v31 = a3;
      v32 = a2;
      do
      {
        v33 = *v30;
        if ((vmovn_s64((int64x2_t)vcgtq_u64(v29, v28)).u8[0] & 1) == 0)
        {
          v30[-1] = *(uint64x2_t *)(a1 + 16 * v32);
          *(uint64x2_t *)(a1 + 16 * v32++) = v29;
        }
        ++v30;
        --v31;
        v29 = v33;
      }
      while (a2 != v31);
      v34 = *(_OWORD *)(a1 + 16 * v32);
      *(_OWORD *)(a1 + 16 * v32) = *(_OWORD *)v14;
      *(_OWORD *)v14 = v34;
      v35 = v32 - a2;
      if (v32 < a2)
      {
        v60 = __si_assert_copy_extra_268();
        v61 = v60;
        v62 = "";
        if (v60)
          v62 = v60;
        __message_assert(v60, "OQueue.c", 16, "q>=left", v62);
        free(v61);
        if (__valid_fs(-1))
        {
          MEMORY[0xBAD] = -559038737;
          abort();
        }
        MEMORY[0xC00] = -559038737;
        abort();
      }
      if (v7 == v9)
      {
        heapsort_b(v12, v11, 0x10uLL, &__block_literal_global_29);
        v7 = v9;
        goto LABEL_3;
      }
      v36 = v35 <= a3 - v32;
      if (v35 <= a3 - v32)
        v37 = v32 - 1;
      else
        v37 = a3;
      if (v36)
        v38 = a2;
      else
        v38 = v32;
      if (v36)
        a2 = v32;
      else
        a3 = v32 - 1;
      v39 = &v6[2 * v7];
      *v39 = v38;
      v39[1] = v37;
      ++v7;
      if (a3 <= a2)
        goto LABEL_3;
    }
    v51 = a1 + 24 + 16 * a2;
    v52 = a2;
    do
    {
      v53 = v52++;
      v54 = *(_OWORD *)(a1 + 16 * v52);
      v55 = *(_QWORD *)(a1 + 16 * v53);
      v56 = *(_QWORD *)(a1 + 16 * v52);
      v57 = v52;
      if (v55 > v56)
      {
        v58 = (_QWORD *)v51;
        do
        {
          v57 = v53;
          v59 = *(v58 - 2);
          *(v58 - 1) = v55;
          *v58 = v59;
          if (v57 <= a2)
            break;
          v55 = *(v58 - 5);
          v53 = v57 - 1;
          v58 -= 2;
        }
        while (v55 > v56);
      }
      *(_OWORD *)(a1 + 16 * v57) = v54;
      v51 += 16;
    }
    while (v52 != a3);
LABEL_3:
    --v7;
    v8 = &v6[2 * v7];
    a2 = *v8;
    a3 = v8[1];
    if (v7)
      continue;
    break;
  }
  free(v6);
}

void _qsort_big_JustPositionOffset_t(void *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  unint64_t v5;
  signed int v6;
  qos_class_t v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v11;
  host_t v12;
  mach_error_t v13;
  unint64_t v14;
  NSObject *v15;
  qos_class_t v16;
  NSObject *global_queue;
  uint64_t v18;
  unint64_t v19;
  uint64x2_t *v20;
  unint64_t v21;
  uint64x2_t *v22;
  unint64_t *v23;
  unint64_t v24;
  uint64x2_t *v25;
  unint64_t v26;
  unint64_t v27;
  uint64x2_t *v28;
  unint64_t v29;
  uint64x2_t *v30;
  uint64x2_t *v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  uint64x2_t v35;
  uint64x2_t v36;
  uint64x2_t *v37;
  uint64x2_t v38;
  __int128 v39;
  uint64_t v40;
  _DWORD *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  int v46;
  int v47;
  qos_class_t v48;
  NSObject *v49;
  uint64_t v50;
  unint64_t *v51;
  unint64_t v52;
  unint64_t v53;
  uint64x2_t *v54;
  unint64_t v55;
  unint64_t *v56;
  unint64_t v57;
  unint64_t v58;
  unint64_t v59;
  char *v60;
  char *v61;
  const char *v62;
  uint64_t v63;
  int v64;
  uint64_t v65;
  uint64_t v66;
  _QWORD block[5];
  mach_msg_type_number_t host_info_outCnt;
  integer_t host_info_out[4];
  __int128 v70;
  __int128 v71;

  v1 = *(_QWORD *)a1;
  v2 = *((_QWORD *)a1 + 1);
  v3 = *((_QWORD *)a1 + 2);
  v4 = *((_QWORD *)a1 + 3);
  v5 = *((_QWORD *)a1 + 4);
  v65 = *((_QWORD *)a1 + 6);
  v66 = *((_QWORD *)a1 + 5);
  v6 = *((_DWORD *)a1 + 14);
  v64 = *((_DWORD *)a1 + 15);
  OSAtomicEnqueue(&qsort_cached_allocations, a1, 0);
  if (v3 > v2)
  {
    while (1)
    {
      ++v5;
      v9 = v3 - v2;
      if (v3 - v2 <= v66 || v5 > 9)
      {
        _qsort_JustPositionOffset_t(v1, v2, v3);
        return;
      }
      if (v6 <= 1)
        v6 = 1;
      v11 = getSize_memSize;
      if (!getSize_memSize)
      {
        v70 = 0u;
        v71 = 0u;
        *(_OWORD *)host_info_out = 0u;
        v12 = MEMORY[0x1BCCB1010]();
        host_info_outCnt = 12;
        v13 = host_info(v12, 1, host_info_out, &host_info_outCnt);
        if (v13)
        {
          mach_error("flushsize", v13);
          exit(1);
        }
        v11 = *((_QWORD *)&v71 + 1);
        getSize_memSize = *((_QWORD *)&v71 + 1);
      }
      v14 = 3 * v11 / 5uLL;
      v15 = v4;
      if (16 * v9 > v14)
        v15 = dispatch_group_create();
      if (v9 <= v65 || 16 * v9 >= v14)
        break;
      v16 = qos_class_self();
      global_queue = dispatch_get_global_queue(v16, 2uLL);
      v18 = _big_partition_JustPositionOffset_t(v1, v2, v3, global_queue, v6);
LABEL_51:
      v40 = v18 - v2;
      if (v18 < v2)
      {
        v60 = __si_assert_copy_extra_268();
        v61 = v60;
        v62 = "";
        if (v60)
          v62 = v60;
        __message_assert(v60, "OQueue.c", 16, "q>=left", v62);
        free(v61);
        if (__valid_fs(-1))
          v63 = 2989;
        else
          v63 = 3072;
        *(_DWORD *)v63 = -559038737;
        abort();
      }
      v41 = OSAtomicDequeue(&qsort_cached_allocations, 0);
      if (!v41)
        v41 = malloc_type_malloc(0x40uLL, 0x102004053A8A26AuLL);
      *((_QWORD *)v41 + 4) = v5;
      *((_QWORD *)v41 + 5) = v66;
      *((_QWORD *)v41 + 6) = v65;
      v42 = v3 - v18;
      if (v40 <= v3 - v18)
      {
        v43 = v18 - 1;
      }
      else
      {
        v42 = v18 - 1 - v2;
        v43 = v3;
      }
      if (v40 > v3 - v18)
        v44 = v18;
      else
        v44 = v2;
      if (v40 > v3 - v18)
        v3 = v18 - 1;
      else
        v2 = v18;
      *(_QWORD *)v41 = v1;
      *((_QWORD *)v41 + 1) = v44;
      v45 = (int)(float)((float)((float)(v42 + 1) * (float)v6) / (float)(v43 - v44 + 1));
      if (v45 <= 1)
        v46 = 1;
      else
        v46 = v45;
      if (v6 >= v45)
        v47 = v46;
      else
        v47 = 0;
      v41[14] = v6 - v47;
      v41[15] = v64;
      *((_QWORD *)v41 + 2) = v43;
      *((_QWORD *)v41 + 3) = v15;
      if (v15 == v4)
      {
        if (v6 >= v45)
          v6 = v46;
        v7 = qos_class_self();
        v8 = dispatch_get_global_queue(v7, 2uLL);
        dispatch_group_async_f(v4, v8, v41, (dispatch_function_t)_qsort_big_JustPositionOffset_t);
        if (v3 <= v2)
          return;
      }
      else
      {
        v41[14] = v6;
        _qsort_big_JustPositionOffset_t(v41);
        dispatch_group_wait(v15, 0xFFFFFFFFFFFFFFFFLL);
        dispatch_release(v15);
        v48 = qos_class_self();
        v49 = dispatch_get_global_queue(v48, 2uLL);
        block[0] = MEMORY[0x1E0C809B0];
        block[1] = 0x40000000;
        block[2] = ___qsort_big_JustPositionOffset_t_block_invoke;
        block[3] = &__block_descriptor_tmp_27_2757;
        block[4] = v41;
        dispatch_async(v49, block);
        if (v3 <= v2)
          return;
      }
    }
    v19 = v9 + 1;
    v20 = (uint64x2_t *)(v1 + 16 * v2);
    v21 = v9 + 2;
    if (v9 >= -1)
      v21 = v9 + 1;
    v22 = &v20[v21 >> 1];
    v23 = (unint64_t *)(v1 + 16 * v3);
    if (v9 < 1024)
    {
      v28 = (uint64x2_t *)(v1 + 16 * v2);
      v30 = v22;
    }
    else
    {
      v24 = v19 >> 3;
      v25 = &v20[v19 >> 3];
      v26 = v20->i64[0];
      v27 = v25->i64[0];
      v28 = (uint64x2_t *)(v1 + 16 * v2);
      if (v20->i64[0] != v25->i64[0])
      {
        v28 = &v20[2 * v24];
        v29 = v28->i64[0];
        if (v28->i64[0] != v26 && v29 != v27)
        {
          if (v26 >= v27)
          {
            if (v26 < v29)
              v28 = (uint64x2_t *)(v1 + 16 * v2);
            if (v27 > v29)
              v28 = v25;
          }
          else
          {
            if (v26 >= v29)
              v28 = (uint64x2_t *)(v1 + 16 * v2);
            if (v27 < v29)
              v28 = v25;
          }
        }
      }
      v50 = v24;
      v51 = (unint64_t *)&v22[-v24];
      v52 = *v51;
      v53 = v22->i64[0];
      if (*v51 == v22->i64[0])
      {
        v30 = &v22[-v24];
      }
      else
      {
        v54 = &v22[v50];
        v55 = v22[v24].u64[0];
        if (v55 == v52)
        {
          v30 = &v22[v50];
        }
        else
        {
          v30 = &v22[v50];
          if (v55 != v53)
          {
            v30 = v22;
            if (v52 >= v53)
            {
              if (v53 <= v55)
              {
                if (v52 >= v55)
                  v30 = v54;
                else
                  v30 = &v22[-v24];
              }
            }
            else if (v53 >= v55)
            {
              if (v52 >= v55)
                v30 = &v22[-v24];
              else
                v30 = v54;
            }
          }
        }
      }
      v56 = &v23[-4 * v24];
      v31 = (uint64x2_t *)&v23[-2 * v24];
      v57 = *v56;
      v58 = v31->i64[0];
      if (*v56 == v31->i64[0])
      {
        v31 = (uint64x2_t *)v56;
        goto LABEL_34;
      }
      v59 = *v23;
      if (*v23 != v57 && v59 != v58)
      {
        if (v57 >= v58)
        {
          if (v58 <= v59)
          {
            if (v57 >= v59)
              v31 = (uint64x2_t *)(v1 + 16 * v3);
            else
              v31 = (uint64x2_t *)v56;
          }
        }
        else if (v58 >= v59)
        {
          if (v57 >= v59)
            v31 = (uint64x2_t *)v56;
          else
            v31 = (uint64x2_t *)(v1 + 16 * v3);
        }
        goto LABEL_34;
      }
    }
    v31 = (uint64x2_t *)(v1 + 16 * v3);
LABEL_34:
    v32 = v28->i64[0];
    v33 = v30->i64[0];
    if (v28->i64[0] == v30->i64[0])
    {
      v30 = v28;
    }
    else
    {
      v34 = v31->i64[0];
      if (v31->i64[0] == v32 || v34 == v33)
      {
        v30 = v31;
      }
      else if (v32 >= v33)
      {
        if (v33 <= v34)
        {
          if (v32 >= v34)
            v30 = v31;
          else
            v30 = v28;
        }
      }
      else if (v33 >= v34)
      {
        if (v32 >= v34)
          v30 = v28;
        else
          v30 = v31;
      }
    }
    v35 = *v30;
    *v30 = *(uint64x2_t *)v23;
    *(uint64x2_t *)v23 = v35;
    v36 = *v20;
    v37 = (uint64x2_t *)(v1 + 16 + 16 * v2);
    v18 = v2;
    do
    {
      v38 = *v37;
      if ((vmovn_s64((int64x2_t)vcgtq_u64(v36, v35)).u8[0] & 1) == 0)
      {
        v37[-1] = *(uint64x2_t *)(v1 + 16 * v18);
        *(uint64x2_t *)(v1 + 16 * v18++) = v36;
      }
      ++v37;
      v36 = v38;
      --v9;
    }
    while (v9);
    v39 = *(_OWORD *)(v1 + 16 * v18);
    *(_OWORD *)(v1 + 16 * v18) = *(_OWORD *)v23;
    *(_OWORD *)v23 = v39;
    goto LABEL_51;
  }
}

uint64_t _big_partition_JustPositionOffset_t(uint64_t a1, uint64_t a2, uint64_t a3, NSObject *a4, unsigned int a5)
{
  uint64_t v7;
  BOOL v8;
  unint64_t v9;
  uint64_t *v10;
  unint64_t v11;
  uint64_t *v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t *v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t *v18;
  unint64_t v19;
  uint64_t *v20;
  uint64_t *v21;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t *v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t *v29;
  unint64_t v30;
  uint64_t *v32;
  unint64_t *v33;
  unint64_t *v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t *v38;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;

  v7 = a3 - a2;
  v8 = __OFADD__(a3 - a2, 1);
  v9 = a3 - a2 + 1;
  v10 = (uint64_t *)(a1 + 16 * a2);
  v11 = v7 + 2;
  if (((v9 & 0x8000000000000000) != 0) == v8)
    v11 = v7 + 1;
  v12 = &v10[2 * (v11 >> 1)];
  v13 = (unint64_t *)(a1 + 16 * a3);
  if (v7 < 64)
  {
    v29 = &v10[2 * (v11 >> 1)];
    v18 = v10;
  }
  else
  {
    v14 = v9 >> 3;
    v15 = &v10[2 * (v9 >> 3)];
    v16 = *v10;
    v17 = *v15;
    v18 = v10;
    if (*v10 != *v15)
    {
      v18 = &v10[4 * v14];
      v19 = *v18;
      if (v16 >= *v18)
        v20 = &v10[4 * v14];
      else
        v20 = v10;
      if (v17 > v19)
        v20 = &v10[2 * (v9 >> 3)];
      if (v16 >= v19)
        v21 = v10;
      else
        v21 = &v10[4 * v14];
      if (v17 >= v19)
        v15 = v21;
      if (v16 >= v17)
        v15 = v20;
      if (v19 != v16 && v19 != v17)
        v18 = v15;
    }
    v23 = 2 * v14;
    v24 = -(uint64_t)v14;
    v25 = 16 * v14;
    v26 = &v12[v25 / 0xFFFFFFFFFFFFFFF8];
    v27 = v12[v25 / 0xFFFFFFFFFFFFFFF8];
    v28 = *v12;
    if (v27 == *v12)
    {
      v29 = &v12[v25 / 0xFFFFFFFFFFFFFFF8];
    }
    else
    {
      v29 = &v12[(unint64_t)v25 / 8];
      v30 = *v29;
      if (*v29 != v27 && v30 != v28)
      {
        if (v27 >= v30)
          v32 = v29;
        else
          v32 = v26;
        if (v28 > v30)
          v32 = v12;
        if (v27 >= v30)
          v29 = v26;
        if (v28 < v30)
          v29 = v12;
        if (v27 >= v28)
          v29 = v32;
      }
    }
    v33 = &v13[-2 * v23];
    v34 = &v13[2 * v24];
    v35 = *v33;
    v36 = *v34;
    if (*v33 == *v34)
    {
      v13 = v33;
    }
    else
    {
      v37 = *v13;
      if (v35 >= *v13)
        v38 = v13;
      else
        v38 = v33;
      if (v36 > v37)
        v38 = v34;
      if (v35 < v37)
        v33 = v13;
      if (v36 < v37)
        v33 = v34;
      if (v35 >= v36)
        v33 = v38;
      if (v37 != v35 && v37 != v36)
        v13 = v33;
    }
  }
  v40 = *v18;
  v41 = *v29;
  if (*v18 == *v29)
  {
    v29 = v18;
  }
  else
  {
    v42 = *v13;
    if (*v13 == v40 || v42 == v41)
    {
      v29 = (uint64_t *)v13;
    }
    else if (v40 >= v41)
    {
      if (v41 <= v42)
      {
        if (v40 >= v42)
          v29 = (uint64_t *)v13;
        else
          v29 = v18;
      }
    }
    else if (v41 >= v42)
    {
      if (v40 >= v42)
        v29 = v18;
      else
        v29 = (uint64_t *)v13;
    }
  }
  return parallel_partition_JustPositionOffset_t(v10, v9, *v29, a4, a5) + a2;
}

uint64_t parallel_partition_JustPositionOffset_t(void *a1, uint64_t a2, uint64_t a3, NSObject *a4, unsigned int a5)
{
  int v5;
  size_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD v17[2];
  _QWORD context[10];

  v5 = a5;
  v17[1] = v17;
  context[9] = *MEMORY[0x1E0C80C00];
  context[6] = a1;
  v10 = 8 * a5;
  MEMORY[0x1E0C80A78](a1);
  v12 = (char *)v17 - v11;
  bzero((char *)v17 - v11, v10);
  v13 = (a2 / 0x4000) << 13;
  context[1] = v13;
  context[2] = a2;
  v14 = a2 - v13;
  context[4] = 0;
  context[5] = 0;
  context[7] = a3;
  context[8] = v12;
  if (v5 >= 1)
    memset(v12, 255, v10);
  v15 = v13 + 0x2000;
  if (v14 > v13 + 0x2000)
    v15 = a2 - v13;
  context[3] = v14 + ((v15 - v14 + 0x1FFF) & 0xFFFFFFFFFFFFE000);
  context[0] = 0;
  if (16 * a2 >= (unint64_t)(4 * *MEMORY[0x1E0C85AD8]))
    madvise(a1, 16 * a2, 3);
  if (a2 / 0x4000 < v5)
    v5 = a2 / 0x4000;
  dispatch_apply_f(v5, a4, context, (void (__cdecl *)(void *, size_t))partition_phase_JustPositionOffset_t);
  return sequential_fixup_JustPositionOffset_t((uint64_t)context, a2, v5);
}

unint64_t *partition_phase_JustPositionOffset_t(unint64_t *result, uint64_t a2)
{
  unint64_t v2;
  int64_t v3;
  unint64_t v4;
  unint64_t v5;
  int64_t v6;
  unint64_t *v7;
  unint64_t v8;
  int64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  BOOL v13;
  uint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t *v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t *v29;
  unint64_t v30;
  uint64_t v31;
  __int128 v32;
  int v33;
  int64_t v35;
  unint64_t v36;
  int64_t v37;
  unint64_t v38;
  unint64_t v39;

  v2 = result[6];
  v3 = result[1];
  if ((uint64_t)*result >= v3)
    goto LABEL_5;
  do
    v4 = __ldxr(result);
  while (__stxr(v4 + 0x2000, result));
  if ((uint64_t)(v4 + 0x2000) > v3)
  {
    do
      v5 = __ldxr(result);
    while (__stxr(v5 - 0x2000, result));
LABEL_5:
    v4 = -1;
  }
  v6 = result[3];
  v7 = result + 2;
  if ((uint64_t)result[2] <= v6)
  {
LABEL_10:
    v11 = 0;
    if (v4 != -1)
    {
      v12 = 0;
      goto LABEL_21;
    }
    v9 = -1;
    v12 = 0;
LABEL_20:
    v4 = v9;
    goto LABEL_21;
  }
  do
  {
    v8 = __ldxr(v7);
    v9 = v8 - 0x2000;
  }
  while (__stxr(v8 - 0x2000, v7));
  if (v9 < v6)
  {
    do
      v10 = __ldxr(v7);
    while (__stxr(v10 + 0x2000, v7));
    goto LABEL_10;
  }
  v13 = v4 != -1;
  if (v8 != 0x1FFF && v4 != -1)
  {
    v11 = 0;
    v12 = 0;
    v21 = 0;
    v22 = 0;
    while (1)
    {
      v23 = v2 + 16 * v4;
      v24 = result[7];
      v25 = v2 + 16 * v9;
      while (1)
      {
        if (v22 < 0x2000)
        {
          v26 = (unint64_t *)(v23 + 16 * v22);
          while (1)
          {
            v27 = *v26;
            v26 += 2;
            if (v27 > v24)
              break;
            if (++v22 == 0x2000)
            {
              v28 = 0x2000;
              if (v21 < 0x2000)
                goto LABEL_34;
              goto LABEL_38;
            }
          }
        }
        v28 = v22;
        if (v21 < 0x2000)
        {
LABEL_34:
          v29 = (unint64_t *)(v25 + 16 * v21);
          while (1)
          {
            v30 = *v29;
            v29 += 2;
            if (v30 < v24)
              break;
            if (++v21 == 0x2000)
            {
              v22 = v28;
              goto LABEL_42;
            }
          }
        }
LABEL_38:
        v31 = v21;
        if (v28 == 0x2000 || v21 == 0x2000)
          break;
        v32 = *(_OWORD *)(v25 + 16 * v21);
        *(_OWORD *)(v25 + 16 * v21) = *(_OWORD *)(v23 + 16 * v28);
        *(_OWORD *)(v23 + 16 * v28) = v32;
        v22 = v28 + 1;
        ++v21;
        if (v28 > 8190 || v31 >= 0x1FFF)
          goto LABEL_42;
      }
      v22 = v28;
LABEL_42:
      v33 = v22 != 0x2000;
      if (v21 == 0x2000 && v22 == 0x2000)
        v33 = 2;
      if ((v33 & 1) != 0)
        goto LABEL_54;
      v35 = result[1];
      if ((uint64_t)*result >= v35)
        goto LABEL_52;
      do
        v4 = __ldxr(result);
      while (__stxr(v4 + 0x2000, result));
      if ((uint64_t)(v4 + 0x2000) > v35)
        break;
LABEL_53:
      v22 = 0;
      ++v12;
      if ((v33 - 1) > 1)
        goto LABEL_60;
LABEL_54:
      v37 = result[3];
      if ((uint64_t)result[2] > v37)
      {
        do
        {
          v38 = __ldxr(v7);
          v9 = v38 - 0x2000;
        }
        while (__stxr(v9, v7));
        if (v9 >= v37)
          goto LABEL_59;
        do
          v39 = __ldxr(v7);
        while (__stxr(v39 + 0x2000, v7));
      }
      v9 = -1;
LABEL_59:
      v21 = 0;
      ++v11;
LABEL_60:
      v13 = v4 != -1;
      if (v9 == -1 || v4 == -1)
        goto LABEL_19;
    }
    do
      v36 = __ldxr(result);
    while (__stxr(v36 - 0x2000, result));
LABEL_52:
    v4 = -1;
    goto LABEL_53;
  }
  v12 = 0;
  v11 = 0;
LABEL_19:
  if (!v13)
    goto LABEL_20;
LABEL_21:
  *(_QWORD *)(result[8] + 8 * a2) = v4;
  v15 = v12 << 13;
  v16 = result + 4;
  do
    v17 = __ldxr(v16);
  while (__stxr(v17 + v15, v16));
  v18 = v11 << 13;
  v19 = result + 5;
  do
    v20 = __ldxr(v19);
  while (__stxr(v20 + v18, v19));
  return result;
}

uint64_t sequential_fixup_JustPositionOffset_t(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  uint64_t v21;
  __int128 v22;
  int v24;
  uint64_t v25;
  uint64_t v26;
  BOOL v27;
  uint64_t v28;
  unint64_t v29;
  void *v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  uint64_t *v34;
  uint64_t v35;
  unint64_t v36;
  unint64_t v38;
  unint64_t v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  char *v52;
  char *v53;
  const char *v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t v57;
  unint64_t *v58;
  unint64_t v59;
  unint64_t *v60;
  unint64_t v61;
  __int128 v62;

  v6 = a3;
  qsort(*(void **)(a1 + 64), a3, 8uLL, (int (__cdecl *)(const void *, const void *))index_comp);
  v7 = *(_QWORD *)(a1 + 64);
  v8 = a3 - 1;
  v9 = 0;
  if (a3 < 1)
    goto LABEL_111;
  while (*(_QWORD *)(v7 + 8 * v9) == -1)
  {
    if (v6 == ++v9)
    {
      v9 = v6;
      break;
    }
  }
  if (a3 == 1)
  {
    v8 = 0;
    if (v9 >= 0)
      goto LABEL_46;
  }
  else
  {
LABEL_111:
    do
    {
      if (*(_QWORD *)(v7 + 8 * v8) != -1)
        break;
      --v8;
    }
    while (v8);
    if (v9 >= v8)
      goto LABEL_46;
  }
  v10 = 0;
  v11 = 0;
  do
  {
    v13 = *(_QWORD *)(a1 + 48);
    v12 = *(_QWORD *)(a1 + 56);
    v14 = v13 + 16 * *(_QWORD *)(v7 + 8 * v9);
    v15 = v13 + 16 * *(_QWORD *)(v7 + 8 * v8);
    while (1)
    {
      if (v10 < 0x2000)
      {
        v16 = (unint64_t *)(v14 + 16 * v10);
        while (1)
        {
          v17 = *v16;
          v16 += 2;
          if (v17 > v12)
            break;
          if (++v10 == 0x2000)
          {
            v18 = 0x2000;
            if (v11 < 0x2000)
              goto LABEL_20;
            goto LABEL_24;
          }
        }
      }
      v18 = v10;
      if (v11 < 0x2000)
      {
LABEL_20:
        v19 = (unint64_t *)(v15 + 16 * v11);
        while (1)
        {
          v20 = *v19;
          v19 += 2;
          if (v20 < v12)
            break;
          if (++v11 == 0x2000)
          {
            v10 = v18;
            goto LABEL_28;
          }
        }
      }
LABEL_24:
      v21 = v11;
      if (v18 == 0x2000 || v11 == 0x2000)
        break;
      v22 = *(_OWORD *)(v15 + 16 * v11);
      *(_OWORD *)(v15 + 16 * v11) = *(_OWORD *)(v14 + 16 * v18);
      *(_OWORD *)(v14 + 16 * v18) = v22;
      v10 = v18 + 1;
      ++v11;
      if (v18 > 8190 || v21 >= 0x1FFF)
        goto LABEL_28;
    }
    v10 = v18;
LABEL_28:
    if (v11 == 0x2000 && v10 == 0x2000)
      v24 = 2;
    else
      v24 = v10 != 0x2000;
    v7 = *(_QWORD *)(a1 + 64);
    if ((v24 & 1) == 0)
    {
      v25 = *(_QWORD *)(v7 + 8 * v9);
      if ((v25 & 0x8000000000000000) == 0 && v25 < *(_QWORD *)(a1 + 32))
      {
        *(_QWORD *)(v7 + 8 * v9) = -1;
        *(_QWORD *)(a1 + 32) += 0x2000;
      }
      v10 = 0;
      ++v9;
      if ((v24 - 1) > 1)
        continue;
    }
    v26 = *(_QWORD *)(v7 + 8 * v8);
    v27 = v26 >= a2 || v26 < a2 - *(_QWORD *)(a1 + 40);
    if (!v27)
    {
      *(_QWORD *)(v7 + 8 * v8) = -1;
      *(_QWORD *)(a1 + 40) += 0x2000;
    }
    v11 = 0;
    --v8;
  }
  while (v9 < v8);
LABEL_46:
  v29 = *(_QWORD *)(a1 + 32);
  v28 = *(_QWORD *)(a1 + 40);
  v30 = malloc_type_malloc(0x20000uLL, 0xEF539176uLL);
  if (a3 < 1)
  {
    v46 = *(_QWORD *)a1;
    v47 = *(_QWORD *)(a1 + 16) - 1;
  }
  else
  {
    v31 = 0;
    v32 = ~v28 + a2;
    v33 = a3;
    v34 = *(uint64_t **)(a1 + 64);
    v35 = 8 * a3;
    do
    {
      v36 = v34[v31];
      if (v36 != -1 && v32 <= v36)
        break;
      if (v36 != -1)
      {
        if (v29 <= v36)
          break;
        v38 = *(_QWORD *)(a1 + 32);
        if (v38 > v36)
        {
          v39 = 0;
          do
          {
            if (v34[v39 / 8] == v38)
            {
              v38 += 0x2000;
              *(_QWORD *)(a1 + 32) = v38;
            }
            v39 += 8;
          }
          while (v35 != v39);
          if ((int64_t)v38 >= *(_QWORD *)a1)
            break;
          memcpy(v30, (const void *)(*(_QWORD *)(a1 + 48) + 16 * v34[v31]), 0x20000uLL);
          memcpy((void *)(*(_QWORD *)(a1 + 48) + 16 * *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8 * v31)), (const void *)(*(_QWORD *)(a1 + 48) + 16 * *(_QWORD *)(a1 + 32)), 0x20000uLL);
          memcpy((void *)(*(_QWORD *)(a1 + 48) + 16 * *(_QWORD *)(a1 + 32)), v30, 0x20000uLL);
          v34 = *(uint64_t **)(a1 + 64);
          v34[v31] = *(_QWORD *)(a1 + 32);
          *(_QWORD *)(a1 + 32) += 0x2000;
        }
      }
      ++v31;
    }
    while (v31 != v33);
    v40 = v33;
    do
    {
      v41 = v34[(v40 - 1)];
      if (v29 > v41)
        break;
      if (v41 != -1)
      {
        if (v32 > v41)
          break;
        v42 = (v40 - 1);
        v43 = *(_QWORD *)(a1 + 40) + 0x2000;
        *(_QWORD *)(a1 + 40) = v43;
        v44 = v33 + 1;
        do
        {
          if (v34[(v44 - 2)] == a2 - v43)
          {
            v43 += 0x2000;
            *(_QWORD *)(a1 + 40) = v43;
          }
          --v44;
        }
        while (v44 > 1);
        if ((unint64_t)(a2 - v43) < *(_QWORD *)(a1 + 16))
          break;
        v45 = v42;
        memcpy(v30, (const void *)(*(_QWORD *)(a1 + 48) + 16 * v34[v42]), 0x20000uLL);
        memcpy((void *)(*(_QWORD *)(a1 + 48) + 16 * *(_QWORD *)(*(_QWORD *)(a1 + 64) + v45 * 8)), (const void *)(*(_QWORD *)(a1 + 48) + 16 * (a2 - *(_QWORD *)(a1 + 40))), 0x20000uLL);
        memcpy((void *)(*(_QWORD *)(a1 + 48) + 16 * (a2 - *(_QWORD *)(a1 + 40))), v30, 0x20000uLL);
        v34 = *(uint64_t **)(a1 + 64);
        v34[v45] = a2 - *(_QWORD *)(a1 + 40);
      }
      v27 = v40-- <= 1;
    }
    while (!v27);
    v46 = *(_QWORD *)a1;
    v47 = *(_QWORD *)(a1 + 16) - 1;
    do
    {
      v49 = *v34++;
      v48 = v49;
      if (v49 != -1)
      {
        if (v48 < v46)
          v46 = v48;
        v50 = v48 + 0x2000;
        v51 = v48 + 0x1FFF;
        if (v50 > v47)
          v47 = v51;
        if (v47 >= a2)
        {
          v52 = __si_assert_copy_extra_268();
          v53 = v52;
          v54 = "";
          if (v52)
            v54 = v52;
          __message_assert(v52, "OQueue.c", 16, "right < count", v54);
          free(v53);
          if (__valid_fs(-1))
          {
            MEMORY[0xBAD] = -559038737;
            abort();
          }
          MEMORY[0xC00] = -559038737;
          abort();
        }
      }
      --v33;
    }
    while (v33);
  }
  free(v30);
  if (v46 >= v47)
  {
    v55 = v46;
  }
  else
  {
    v55 = v46;
    do
    {
      v56 = *(_QWORD *)(a1 + 48);
      v57 = *(_QWORD *)(a1 + 56);
      v58 = (unint64_t *)(v56 + 16 * v46);
      while (1)
      {
        v59 = *v58;
        v58 += 2;
        if (v59 >= v57)
          break;
        if (++v55 >= v47)
        {
          if (v47 <= v46 + 1)
            v55 = v46 + 1;
          else
            v55 = v47;
          goto LABEL_105;
        }
      }
      if (v55 < v47)
      {
        v60 = (unint64_t *)(v56 + 16 * v47);
        while (1)
        {
          v61 = *v60;
          v60 -= 2;
          if (v61 <= v57)
            break;
          if (v55 >= --v47)
            goto LABEL_105;
        }
        v62 = *(_OWORD *)(v56 + 16 * v47);
        *(_OWORD *)(v56 + 16 * v47) = *(_OWORD *)(v56 + 16 * v55);
        *(_OWORD *)(*(_QWORD *)(a1 + 48) + 16 * v55++) = v62;
        --v47;
      }
      v46 = v55;
    }
    while (v55 < v47);
  }
LABEL_105:
  if (*(_QWORD *)(*(_QWORD *)(a1 + 48) + 16 * v55) >= *(_QWORD *)(a1 + 56))
    return v55;
  else
    return v55 + 1;
}

uint64_t _big_split_JustPositionOffset_t(void *a1, uint64_t a2, uint64_t a3, NSObject *a4, signed int a5)
{
  uint64_t v5;

  v5 = a2 + 1;
  if (a5 >= 3)
  {
    while (v5 < (uint64_t)((unint64_t)a5 << 13))
    {
      if (a5-- <= 3)
      {
        a5 = 2;
        return parallel_partition_JustPositionOffset_t(a1, v5, a3, a4, a5);
      }
    }
  }
  return parallel_partition_JustPositionOffset_t(a1, v5, a3, a4, a5);
}

void oqdispose_PositionOffsetWithMeta_t(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  if (*(uint64_t *)(a1 + 24) >= 1)
  {
    v2 = 0;
    v3 = 8;
    do
    {
      CFRelease(*(CFTypeRef *)(*(_QWORD *)(a1 + 8) + v3));
      ++v2;
      v3 += 24;
    }
    while (v2 < *(_QWORD *)(a1 + 24));
  }
  if (*(_DWORD *)(a1 + 48))
  {
    v4 = *(_QWORD *)(a1 + 32);
    if (v4 < *(_QWORD *)(a1 + 40))
    {
      v5 = 24 * v4 + 8;
      do
      {
        CFRelease(*(CFTypeRef *)(*(_QWORD *)(a1 + 8) + v5));
        ++v4;
        v5 += 24;
      }
      while (v4 < *(_QWORD *)(a1 + 40));
    }
  }
  free(*(void **)(a1 + 8));
}

void parallel_qsort_PositionOffsetWithMeta_t(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  NSObject *v5;
  int v6;
  uint64_t v7;
  size_t v8;
  int v9[2];
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (a2 > 2047)
  {
    v4 = OSAtomicDequeue(&qsort_cached_allocations, 0);
    if (!v4)
      v4 = malloc_type_malloc(0x40uLL, 0x102004053A8A26AuLL);
    v5 = dispatch_group_create();
    v4[3] = v5;
    v4[4] = 0;
    v4[1] = 0;
    v4[2] = a2 - 1;
    *v4 = a1;
    v6 = thread_count;
    if (!thread_count)
    {
      *(_QWORD *)v9 = 0x1900000006;
      v8 = 4;
      sysctl(v9, 2u, &thread_count, &v8, 0, 0);
      v6 = thread_count;
    }
    *((_DWORD *)v4 + 14) = v6;
    v4[5] = (uint64_t)sqrt((double)a2) / 2;
    if (!v6)
    {
      *(_QWORD *)v9 = 0x1900000006;
      v8 = 4;
      sysctl(v9, 2u, &thread_count, &v8, 0, 0);
      v6 = thread_count;
    }
    v7 = a2 / (2 * v6);
    if (v7 <= 0x8000)
    {
      v7 = 0x8000;
    }
    else if (!v6)
    {
      *(_QWORD *)v9 = 0x1900000006;
      v8 = 4;
      sysctl(v9, 2u, &thread_count, &v8, 0, 0);
      v7 = a2 / (2 * thread_count);
    }
    v4[6] = v7;
    if ((uint64_t)v4[5] <= 2047)
      v4[5] = 2048;
    _qsort_big_PositionOffsetWithMeta_t(v4);
    dispatch_group_wait(v5, 0xFFFFFFFFFFFFFFFFLL);
    dispatch_release(v5);
  }
  else
  {
    _qsort_PositionOffsetWithMeta_t(a1, 0, a2 - 1);
  }
}

void _qsort_PositionOffsetWithMeta_t(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  BOOL v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  _OWORD *v24;
  char *v25;
  char *v26;
  const char *v27;
  __int128 v28;
  __int128 v29;

  v6 = malloc_type_malloc(0x800uLL, 0x1000040451B5BE8uLL);
  *v6 = 0;
  v6[1] = 0;
  v7 = 1;
  do
  {
    if (a3 > a2)
    {
      if (v7 <= 128)
        v9 = 128;
      else
        v9 = v7;
      v10 = &v6[2 * v7 + 1];
      while (a3 - a2 > 16)
      {
        v11 = _partition_PositionOffsetWithMeta_t(a1, a2, a3);
        v12 = v11 - a2;
        if (v11 < a2)
        {
          v25 = __si_assert_copy_extra_268();
          v26 = v25;
          v27 = "";
          if (v25)
            v27 = v25;
          __message_assert(v25, "OQueue.c", 17, "q>=left", v27);
          free(v26);
          if (__valid_fs(-1))
          {
            MEMORY[0xBAD] = -559038737;
            abort();
          }
          MEMORY[0xC00] = -559038737;
          abort();
        }
        if (v9 == v7)
        {
          heapsort_b((void *)(a1 + 24 * a2), a3 - a2 + 1, 0x18uLL, &__block_literal_global_33_2759);
          v7 = v9;
          goto LABEL_3;
        }
        v13 = v12 <= a3 - v11;
        if (v12 <= a3 - v11)
          v14 = v11 - 1;
        else
          v14 = a3;
        if (v13)
          v15 = a2;
        else
          v15 = v11;
        if (v13)
          a2 = v11;
        else
          a3 = v11 - 1;
        *(v10 - 1) = v15;
        *v10 = v14;
        ++v7;
        v10 += 2;
        if (a3 <= a2)
          goto LABEL_3;
      }
      v16 = a1 + 32 + 24 * a2;
      v17 = a2;
      do
      {
        v19 = v17++;
        v20 = a1 + 24 * v19;
        v21 = *(_QWORD *)(v20 + 24);
        v22 = *(_QWORD *)v20;
        v28 = *(_OWORD *)(v20 + 8);
        v29 = *(_OWORD *)(v20 + 32);
        v23 = v17;
        if (v22 > v21)
        {
          v24 = (_OWORD *)v16;
          do
          {
            v23 = v19;
            *((_QWORD *)v24 - 1) = v22;
            *v24 = v28;
            if (v19 <= a2)
              break;
            v22 = *((_QWORD *)v24 - 7);
            v28 = *(v24 - 3);
            v24 = (_OWORD *)((char *)v24 - 24);
            --v19;
          }
          while (v22 > v21);
        }
        v18 = a1 + 24 * v23;
        *(_QWORD *)v18 = v21;
        *(_OWORD *)(v18 + 8) = v29;
        v16 += 24;
      }
      while (v17 != a3);
    }
LABEL_3:
    --v7;
    v8 = &v6[2 * v7];
    a2 = *v8;
    a3 = v8[1];
  }
  while (v7);
  free(v6);
}

uint64_t _partition_PositionOffsetWithMeta_t(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t *v7;
  unint64_t *v8;
  unint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t *v15;
  uint64_t *v16;
  uint64_t v18;
  uint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  BOOL v25;
  uint64_t *v26;
  unint64_t *v27;
  unint64_t *v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t *v32;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v38;
  __int128 v39;
  unint64_t v40;
  uint64_t v41;
  _OWORD *v42;
  unint64_t v43;
  __int128 *v44;
  __int128 v45;
  __int128 *v46;
  unint64_t v47;
  __int128 v48;
  unint64_t v49;
  __int128 v51;
  __int128 v52;
  __int128 v53;

  v3 = a3 - a2;
  v4 = a3 - a2 + 1;
  v5 = (uint64_t *)(a1 + 24 * a2);
  v6 = a3 - a2 + 2;
  if (a3 - a2 >= -1)
    v6 = v3 + 1;
  v7 = &v5[3 * (v6 >> 1)];
  v8 = (unint64_t *)(a1 + 24 * a3);
  if (v3 < 1024)
  {
    v13 = (unint64_t *)(a1 + 24 * a2);
    v26 = v7;
    v27 = (unint64_t *)(a1 + 24 * a3);
  }
  else
  {
    v9 = v4 >> 3;
    v10 = (unint64_t *)&v5[3 * (v4 >> 3)];
    v11 = *v5;
    v12 = *v10;
    v13 = (unint64_t *)(a1 + 24 * a2);
    if (*v5 != *v10)
    {
      v13 = (unint64_t *)&v5[6 * v9];
      v14 = *v13;
      if (v11 >= *v13)
        v15 = &v5[6 * v9];
      else
        v15 = (uint64_t *)(a1 + 24 * a2);
      if (v12 > v14)
        v15 = (uint64_t *)v10;
      if (v11 >= v14)
        v16 = (uint64_t *)(a1 + 24 * a2);
      else
        v16 = &v5[6 * v9];
      if (v12 >= v14)
        v10 = (unint64_t *)v16;
      if (v11 >= v12)
        v10 = (unint64_t *)v15;
      if (v14 != v11 && v14 != v12)
        v13 = v10;
    }
    v18 = 2 * v9;
    v19 = -(uint64_t)v9;
    v20 = (unint64_t *)&v7[-3 * v9];
    v21 = *v20;
    v22 = *v7;
    if (*v20 == *v7)
    {
      v26 = &v7[-3 * v9];
    }
    else
    {
      v23 = (unint64_t *)&v7[3 * v9];
      v24 = *v23;
      v25 = *v23 == v21 || v24 == v22;
      v26 = &v7[3 * v9];
      if (!v25)
      {
        v26 = v7;
        if (v21 >= v22)
        {
          if (v22 <= v24)
          {
            if (v21 >= v24)
              v26 = (uint64_t *)v23;
            else
              v26 = (uint64_t *)v20;
          }
        }
        else if (v22 >= v24)
        {
          if (v21 >= v24)
            v26 = (uint64_t *)v20;
          else
            v26 = (uint64_t *)v23;
        }
      }
    }
    v27 = &v8[-3 * v18];
    v28 = &v8[3 * v19];
    v29 = *v27;
    v30 = *v28;
    if (*v27 != *v28)
    {
      v31 = *v8;
      if (v29 >= *v8)
        v32 = (unint64_t *)(a1 + 24 * a3);
      else
        v32 = v27;
      if (v30 > v31)
        v32 = v28;
      if (v29 < v31)
        v27 = (unint64_t *)(a1 + 24 * a3);
      if (v30 < v31)
        v27 = v28;
      if (v29 >= v30)
        v27 = v32;
      if (v31 == v29 || v31 == v30)
        v27 = (unint64_t *)(a1 + 24 * a3);
    }
  }
  v34 = *v13;
  v35 = *v26;
  if (*v13 == *v26)
  {
    v26 = (uint64_t *)v13;
  }
  else
  {
    v36 = *v27;
    if (*v27 == v34 || v36 == v35)
    {
      v26 = (uint64_t *)v27;
    }
    else if (v34 >= v35)
    {
      if (v35 <= v36)
      {
        if (v34 >= v36)
          v26 = (uint64_t *)v27;
        else
          v26 = (uint64_t *)v13;
      }
    }
    else if (v35 >= v36)
    {
      if (v34 >= v36)
        v26 = (uint64_t *)v13;
      else
        v26 = (uint64_t *)v27;
    }
  }
  v38 = *v26;
  v53 = *(_OWORD *)(v26 + 1);
  v39 = *(_OWORD *)v8;
  v26[2] = v8[2];
  *(_OWORD *)v26 = v39;
  *v8 = v38;
  *(_OWORD *)(v8 + 1) = v53;
  v40 = *v5;
  v52 = *(_OWORD *)(v5 + 1);
  v41 = a3 - a2;
  if (a3 > a2)
  {
    v42 = (_OWORD *)(a1 + 24 * a2 + 32);
    do
    {
      v43 = *((_QWORD *)v42 - 1);
      v51 = v52;
      v52 = *v42;
      if (v40 <= v38)
      {
        v44 = (__int128 *)(a1 + 24 * a2);
        v45 = *v44;
        *((_QWORD *)v42 - 2) = *((_QWORD *)v44 + 2);
        *(v42 - 2) = v45;
        *(_QWORD *)v44 = v40;
        *(__int128 *)((char *)v44 + 8) = v51;
        ++a2;
      }
      v42 = (_OWORD *)((char *)v42 + 24);
      v40 = v43;
      --v41;
    }
    while (v41);
  }
  v46 = (__int128 *)(a1 + 24 * a2);
  v47 = *((_QWORD *)v46 + 2);
  v48 = *v46;
  v49 = v8[2];
  *v46 = *(_OWORD *)v8;
  *((_QWORD *)v46 + 2) = v49;
  *(_OWORD *)v8 = v48;
  v8[2] = v47;
  return a2;
}

void _qsort_big_PositionOffsetWithMeta_t(void *a1)
{
  uint64_t v1;
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  signed int v6;
  unint64_t i;
  qos_class_t v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v12;
  host_t v13;
  mach_error_t v14;
  unint64_t v15;
  NSObject *v16;
  qos_class_t v17;
  NSObject *global_queue;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _DWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  int v27;
  int v28;
  qos_class_t v29;
  NSObject *v30;
  char *v31;
  char *v32;
  const char *v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  _QWORD block[5];
  mach_msg_type_number_t host_info_outCnt;
  integer_t host_info_out[4];
  __int128 v41;
  __int128 v42;

  v1 = *((_QWORD *)a1 + 1);
  v2 = *((_QWORD *)a1 + 2);
  v3 = *((_QWORD *)a1 + 3);
  v4 = *((_QWORD *)a1 + 4);
  v5 = *((_QWORD *)a1 + 5);
  v36 = *((_QWORD *)a1 + 6);
  v37 = *(_QWORD *)a1;
  v6 = *((_DWORD *)a1 + 14);
  v35 = *((_DWORD *)a1 + 15);
  OSAtomicEnqueue(&qsort_cached_allocations, a1, 0);
  if (v2 > v1)
  {
    for (i = v4 + 1; ; ++i)
    {
      v10 = v2 - v1;
      if (v2 - v1 <= v5 || i > 9)
        break;
      if (v6 <= 1)
        v6 = 1;
      v12 = getSize_memSize;
      if (!getSize_memSize)
      {
        v41 = 0u;
        v42 = 0u;
        *(_OWORD *)host_info_out = 0u;
        v13 = MEMORY[0x1BCCB1010]();
        host_info_outCnt = 12;
        v14 = host_info(v13, 1, host_info_out, &host_info_outCnt);
        if (v14)
        {
          mach_error("flushsize", v14);
          exit(1);
        }
        v12 = *((_QWORD *)&v42 + 1);
        getSize_memSize = *((_QWORD *)&v42 + 1);
      }
      v15 = 3 * v12 / 5uLL;
      v16 = v3;
      if (24 * v10 > v15)
        v16 = dispatch_group_create();
      if (v10 <= v36 || 24 * v10 >= v15)
      {
        v19 = _partition_PositionOffsetWithMeta_t(v37, v1, v2);
      }
      else
      {
        v17 = qos_class_self();
        global_queue = dispatch_get_global_queue(v17, 2uLL);
        v19 = _big_partition_PositionOffsetWithMeta_t(v37, v1, v2, global_queue, v6);
      }
      v20 = v19;
      v21 = v19 - v1;
      if (v19 < v1)
      {
        v31 = __si_assert_copy_extra_268();
        v32 = v31;
        v33 = "";
        if (v31)
          v33 = v31;
        __message_assert(v31, "OQueue.c", 17, "q>=left", v33);
        free(v32);
        if (__valid_fs(-1))
          v34 = 2989;
        else
          v34 = 3072;
        *(_DWORD *)v34 = -559038737;
        abort();
      }
      v22 = OSAtomicDequeue(&qsort_cached_allocations, 0);
      if (!v22)
        v22 = malloc_type_malloc(0x40uLL, 0x102004053A8A26AuLL);
      *((_QWORD *)v22 + 4) = i;
      *((_QWORD *)v22 + 5) = v5;
      *((_QWORD *)v22 + 6) = v36;
      v23 = v2 - v20;
      if (v21 <= v2 - v20)
      {
        v24 = v20 - 1;
      }
      else
      {
        v23 = v20 - 1 - v1;
        v24 = v2;
      }
      if (v21 > v2 - v20)
        v25 = v20;
      else
        v25 = v1;
      if (v21 > v2 - v20)
        v2 = v20 - 1;
      else
        v1 = v20;
      *(_QWORD *)v22 = v37;
      *((_QWORD *)v22 + 1) = v25;
      v26 = (int)(float)((float)((float)(v23 + 1) * (float)v6) / (float)(v24 - v25 + 1));
      if (v26 <= 1)
        v27 = 1;
      else
        v27 = v26;
      if (v6 >= v26)
        v28 = v27;
      else
        v28 = 0;
      v22[14] = v6 - v28;
      v22[15] = v35;
      *((_QWORD *)v22 + 2) = v24;
      *((_QWORD *)v22 + 3) = v16;
      if (v16 == v3)
      {
        if (v6 >= v26)
          v6 = v27;
        v8 = qos_class_self();
        v9 = dispatch_get_global_queue(v8, 2uLL);
        dispatch_group_async_f(v3, v9, v22, (dispatch_function_t)_qsort_big_PositionOffsetWithMeta_t);
      }
      else
      {
        v22[14] = v6;
        _qsort_big_PositionOffsetWithMeta_t(v22);
        dispatch_group_wait(v16, 0xFFFFFFFFFFFFFFFFLL);
        dispatch_release(v16);
        v29 = qos_class_self();
        v30 = dispatch_get_global_queue(v29, 2uLL);
        block[0] = MEMORY[0x1E0C809B0];
        block[1] = 0x40000000;
        block[2] = ___qsort_big_PositionOffsetWithMeta_t_block_invoke;
        block[3] = &__block_descriptor_tmp_31;
        block[4] = v22;
        dispatch_async(v30, block);
      }
      if (v2 <= v1)
        return;
    }
    _qsort_PositionOffsetWithMeta_t(v37, v1, v2);
  }
}

uint64_t _big_partition_PositionOffsetWithMeta_t(uint64_t a1, uint64_t a2, uint64_t a3, NSObject *a4, unsigned int a5)
{
  uint64_t v7;
  BOOL v8;
  unint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t *v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t *v18;
  unint64_t v19;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t *v27;
  unint64_t v28;
  BOOL v29;
  uint64_t *v30;
  unint64_t *v31;
  unint64_t *v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t *v36;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;

  v7 = a3 - a2;
  v8 = __OFADD__(a3 - a2, 1);
  v9 = a3 - a2 + 1;
  v10 = (uint64_t *)(a1 + 24 * a2);
  v11 = v7 + 2;
  if (((v9 & 0x8000000000000000) != 0) == v8)
    v11 = v7 + 1;
  v12 = &v10[3 * (v11 >> 1)];
  v13 = (unint64_t *)(a1 + 24 * a3);
  if (v7 < 64)
  {
    v30 = v12;
    v18 = v10;
  }
  else
  {
    v14 = v9 >> 3;
    v15 = (unint64_t *)&v10[3 * (v9 >> 3)];
    v16 = *v10;
    v17 = *v15;
    v18 = v10;
    if (*v10 != *v15)
    {
      v18 = &v10[6 * v14];
      v19 = *v18;
      if (*v18 != v16 && v19 != v17)
      {
        if (v16 >= v19)
          v21 = &v10[6 * v14];
        else
          v21 = v10;
        if (v17 > v19)
          v21 = &v10[3 * (v9 >> 3)];
        if (v16 >= v19)
          v18 = v10;
        if (v17 < v19)
          v18 = &v10[3 * (v9 >> 3)];
        if (v16 >= v17)
          v18 = v21;
      }
    }
    v22 = 2 * v14;
    v23 = -(uint64_t)v14;
    v24 = &v12[-3 * v14];
    v25 = *v24;
    v26 = *v12;
    if (*v24 == *v12)
    {
      v30 = &v12[-3 * v14];
    }
    else
    {
      v27 = &v12[3 * v14];
      v28 = *v27;
      v29 = *v27 == v25 || v28 == v26;
      v30 = &v12[3 * v14];
      if (!v29)
      {
        v30 = v12;
        if (v25 >= v26)
        {
          if (v26 <= v28)
          {
            if (v25 >= v28)
              v30 = v27;
            else
              v30 = v24;
          }
        }
        else if (v26 >= v28)
        {
          if (v25 >= v28)
            v30 = v24;
          else
            v30 = v27;
        }
      }
    }
    v31 = &v13[-3 * v22];
    v32 = &v13[3 * v23];
    v33 = *v31;
    v34 = *v32;
    if (*v31 == *v32)
    {
      v13 = v31;
    }
    else
    {
      v35 = *v13;
      if (v33 >= *v13)
        v36 = v13;
      else
        v36 = v31;
      if (v34 > v35)
        v36 = v32;
      if (v33 < v35)
        v31 = v13;
      if (v34 < v35)
        v31 = v32;
      if (v33 >= v34)
        v31 = v36;
      if (v35 != v33 && v35 != v34)
        v13 = v31;
    }
  }
  v38 = *v18;
  v39 = *v30;
  if (*v18 == *v30)
  {
    v30 = v18;
  }
  else
  {
    v40 = *v13;
    if (*v13 == v38 || v40 == v39)
    {
      v30 = (uint64_t *)v13;
    }
    else if (v38 >= v39)
    {
      if (v39 <= v40)
      {
        if (v38 >= v40)
          v30 = (uint64_t *)v13;
        else
          v30 = v18;
      }
    }
    else if (v39 >= v40)
    {
      if (v38 >= v40)
        v30 = v18;
      else
        v30 = (uint64_t *)v13;
    }
  }
  return parallel_partition_PositionOffsetWithMeta_t(v10, v9, *v30, a4, a5) + a2;
}

uint64_t parallel_partition_PositionOffsetWithMeta_t(void *a1, uint64_t a2, uint64_t a3, NSObject *a4, unsigned int a5)
{
  int v5;
  size_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD v17[2];
  _QWORD context[10];

  v5 = a5;
  v17[1] = v17;
  context[9] = *MEMORY[0x1E0C80C00];
  context[6] = a1;
  v10 = 8 * a5;
  MEMORY[0x1E0C80A78](a1);
  v12 = (char *)v17 - v11;
  bzero((char *)v17 - v11, v10);
  v13 = (a2 / 0x4000) << 13;
  context[1] = v13;
  context[2] = a2;
  v14 = a2 - v13;
  context[4] = 0;
  context[5] = 0;
  context[7] = a3;
  context[8] = v12;
  if (v5 >= 1)
    memset(v12, 255, v10);
  v15 = v13 + 0x2000;
  if (v14 > v13 + 0x2000)
    v15 = a2 - v13;
  context[3] = v14 + ((v15 - v14 + 0x1FFF) & 0xFFFFFFFFFFFFE000);
  context[0] = 0;
  if (24 * a2 >= (unint64_t)(4 * *MEMORY[0x1E0C85AD8]))
    madvise(a1, 24 * a2, 3);
  if (a2 / 0x4000 < v5)
    v5 = a2 / 0x4000;
  dispatch_apply_f(v5, a4, context, (void (__cdecl *)(void *, size_t))partition_phase_PositionOffsetWithMeta_t);
  return sequential_fixup_PositionOffsetWithMeta_t((uint64_t)context, a2, v5);
}

unint64_t *partition_phase_PositionOffsetWithMeta_t(unint64_t *result, uint64_t a2)
{
  unint64_t v2;
  int64_t v3;
  unint64_t v4;
  unint64_t v5;
  int64_t v6;
  unint64_t *v7;
  unint64_t v8;
  int64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  BOOL v13;
  uint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t *v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t *v29;
  unint64_t v30;
  uint64_t v31;
  __int128 *v32;
  uint64_t v33;
  __int128 v34;
  unint64_t v35;
  uint64_t v36;
  int v37;
  int64_t v39;
  unint64_t v40;
  int64_t v41;
  unint64_t v42;
  unint64_t v43;

  v2 = result[6];
  v3 = result[1];
  if ((uint64_t)*result >= v3)
    goto LABEL_5;
  do
    v4 = __ldxr(result);
  while (__stxr(v4 + 0x2000, result));
  if ((uint64_t)(v4 + 0x2000) > v3)
  {
    do
      v5 = __ldxr(result);
    while (__stxr(v5 - 0x2000, result));
LABEL_5:
    v4 = -1;
  }
  v6 = result[3];
  v7 = result + 2;
  if ((uint64_t)result[2] <= v6)
  {
LABEL_10:
    v11 = 0;
    if (v4 != -1)
    {
      v12 = 0;
      goto LABEL_21;
    }
    v9 = -1;
    v12 = 0;
LABEL_20:
    v4 = v9;
    goto LABEL_21;
  }
  do
  {
    v8 = __ldxr(v7);
    v9 = v8 - 0x2000;
  }
  while (__stxr(v8 - 0x2000, v7));
  if (v9 < v6)
  {
    do
      v10 = __ldxr(v7);
    while (__stxr(v10 + 0x2000, v7));
    goto LABEL_10;
  }
  v13 = v4 != -1;
  if (v8 != 0x1FFF && v4 != -1)
  {
    v11 = 0;
    v12 = 0;
    v21 = 0;
    v22 = 0;
    while (1)
    {
      v23 = v2 + 24 * v4;
      v24 = result[7];
      v25 = v2 + 24 * v9;
      while (1)
      {
        if (v22 < 0x2000)
        {
          v26 = (unint64_t *)(v23 + 24 * v22);
          while (1)
          {
            v27 = *v26;
            v26 += 3;
            if (v27 > v24)
              break;
            if (++v22 == 0x2000)
            {
              v28 = 0x2000;
              if (v21 < 0x2000)
                goto LABEL_34;
              goto LABEL_38;
            }
          }
        }
        v28 = v22;
        if (v21 < 0x2000)
        {
LABEL_34:
          v29 = (unint64_t *)(v25 + 24 * v21);
          while (1)
          {
            v30 = *v29;
            v29 += 3;
            if (v30 < v24)
              break;
            if (++v21 == 0x2000)
            {
              v22 = v28;
              goto LABEL_42;
            }
          }
        }
LABEL_38:
        v31 = v21;
        if (v28 == 0x2000 || v21 == 0x2000)
          break;
        v32 = (__int128 *)(v25 + 24 * v21);
        v33 = *((_QWORD *)v32 + 2);
        v34 = *v32;
        v35 = v23 + 24 * v28;
        v36 = *(_QWORD *)(v35 + 16);
        *v32 = *(_OWORD *)v35;
        *((_QWORD *)v32 + 2) = v36;
        *(_OWORD *)v35 = v34;
        *(_QWORD *)(v35 + 16) = v33;
        v22 = v28 + 1;
        v21 = v31 + 1;
        if (v28 > 8190 || v31 >= 0x1FFF)
          goto LABEL_42;
      }
      v22 = v28;
LABEL_42:
      v37 = v22 != 0x2000;
      if (v21 == 0x2000 && v22 == 0x2000)
        v37 = 2;
      if ((v37 & 1) != 0)
        goto LABEL_54;
      v39 = result[1];
      if ((uint64_t)*result >= v39)
        goto LABEL_52;
      do
        v4 = __ldxr(result);
      while (__stxr(v4 + 0x2000, result));
      if ((uint64_t)(v4 + 0x2000) > v39)
        break;
LABEL_53:
      v22 = 0;
      ++v12;
      if ((v37 - 1) > 1)
        goto LABEL_60;
LABEL_54:
      v41 = result[3];
      if ((uint64_t)result[2] > v41)
      {
        do
        {
          v42 = __ldxr(v7);
          v9 = v42 - 0x2000;
        }
        while (__stxr(v9, v7));
        if (v9 >= v41)
          goto LABEL_59;
        do
          v43 = __ldxr(v7);
        while (__stxr(v43 + 0x2000, v7));
      }
      v9 = -1;
LABEL_59:
      v21 = 0;
      ++v11;
LABEL_60:
      v13 = v4 != -1;
      if (v9 == -1 || v4 == -1)
        goto LABEL_19;
    }
    do
      v40 = __ldxr(result);
    while (__stxr(v40 - 0x2000, result));
LABEL_52:
    v4 = -1;
    goto LABEL_53;
  }
  v12 = 0;
  v11 = 0;
LABEL_19:
  if (!v13)
    goto LABEL_20;
LABEL_21:
  *(_QWORD *)(result[8] + 8 * a2) = v4;
  v15 = v12 << 13;
  v16 = result + 4;
  do
    v17 = __ldxr(v16);
  while (__stxr(v17 + v15, v16));
  v18 = v11 << 13;
  v19 = result + 5;
  do
    v20 = __ldxr(v19);
  while (__stxr(v20 + v18, v19));
  return result;
}

uint64_t sequential_fixup_PositionOffsetWithMeta_t(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  uint64_t v21;
  __int128 *v22;
  uint64_t v23;
  __int128 v24;
  __int128 *v25;
  uint64_t v26;
  int v28;
  uint64_t v29;
  uint64_t v30;
  BOOL v31;
  uint64_t v32;
  unint64_t v33;
  void *v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t *v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v42;
  unint64_t v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  char *v56;
  char *v57;
  const char *v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  unint64_t *v62;
  unint64_t *v63;
  unint64_t v64;
  __int128 v65;
  unint64_t v66;
  uint64_t v67;

  v6 = a3;
  qsort(*(void **)(a1 + 64), a3, 8uLL, (int (__cdecl *)(const void *, const void *))index_comp);
  v7 = *(_QWORD *)(a1 + 64);
  v8 = a3 - 1;
  v9 = 0;
  if (a3 < 1)
    goto LABEL_111;
  while (*(_QWORD *)(v7 + 8 * v9) == -1)
  {
    if (v6 == ++v9)
    {
      v9 = v6;
      break;
    }
  }
  if (a3 == 1)
  {
    v8 = 0;
    if (v9 >= 0)
      goto LABEL_46;
  }
  else
  {
LABEL_111:
    do
    {
      if (*(_QWORD *)(v7 + 8 * v8) != -1)
        break;
      --v8;
    }
    while (v8);
    if (v9 >= v8)
      goto LABEL_46;
  }
  v10 = 0;
  v11 = 0;
  do
  {
    v13 = *(_QWORD *)(a1 + 48);
    v12 = *(_QWORD *)(a1 + 56);
    v14 = v13 + 24 * *(_QWORD *)(v7 + 8 * v9);
    v15 = v13 + 24 * *(_QWORD *)(v7 + 8 * v8);
    while (1)
    {
      if (v11 < 0x2000)
      {
        v16 = (unint64_t *)(v14 + 24 * v11);
        while (1)
        {
          v17 = *v16;
          v16 += 3;
          if (v17 > v12)
            break;
          if (++v11 == 0x2000)
          {
            v18 = 0x2000;
            if (v10 < 0x2000)
              goto LABEL_20;
            goto LABEL_24;
          }
        }
      }
      v18 = v11;
      if (v10 < 0x2000)
      {
LABEL_20:
        v19 = (unint64_t *)(v15 + 24 * v10);
        while (1)
        {
          v20 = *v19;
          v19 += 3;
          if (v20 < v12)
            break;
          if (++v10 == 0x2000)
          {
            v11 = v18;
            goto LABEL_28;
          }
        }
      }
LABEL_24:
      v21 = v10;
      if (v18 == 0x2000 || v10 == 0x2000)
        break;
      v22 = (__int128 *)(v15 + 24 * v10);
      v23 = *((_QWORD *)v22 + 2);
      v24 = *v22;
      v25 = (__int128 *)(v14 + 24 * v18);
      v26 = *((_QWORD *)v25 + 2);
      *v22 = *v25;
      *((_QWORD *)v22 + 2) = v26;
      *v25 = v24;
      *((_QWORD *)v25 + 2) = v23;
      v11 = v18 + 1;
      v10 = v21 + 1;
      if (v18 > 8190 || v21 >= 0x1FFF)
        goto LABEL_28;
    }
    v11 = v18;
LABEL_28:
    if (v10 == 0x2000 && v11 == 0x2000)
      v28 = 2;
    else
      v28 = v11 != 0x2000;
    v7 = *(_QWORD *)(a1 + 64);
    if ((v28 & 1) == 0)
    {
      v29 = *(_QWORD *)(v7 + 8 * v9);
      if ((v29 & 0x8000000000000000) == 0 && v29 < *(_QWORD *)(a1 + 32))
      {
        *(_QWORD *)(v7 + 8 * v9) = -1;
        *(_QWORD *)(a1 + 32) += 0x2000;
      }
      v11 = 0;
      ++v9;
      if ((v28 - 1) > 1)
        continue;
    }
    v30 = *(_QWORD *)(v7 + 8 * v8);
    v31 = v30 >= a2 || v30 < a2 - *(_QWORD *)(a1 + 40);
    if (!v31)
    {
      *(_QWORD *)(v7 + 8 * v8) = -1;
      *(_QWORD *)(a1 + 40) += 0x2000;
    }
    v10 = 0;
    --v8;
  }
  while (v9 < v8);
LABEL_46:
  v33 = *(_QWORD *)(a1 + 32);
  v32 = *(_QWORD *)(a1 + 40);
  v34 = malloc_type_malloc(0x30000uLL, 0xFE790DC3uLL);
  if (a3 < 1)
  {
    v50 = *(_QWORD *)a1;
    v51 = *(_QWORD *)(a1 + 16) - 1;
  }
  else
  {
    v35 = 0;
    v36 = ~v32 + a2;
    v37 = a3;
    v38 = *(uint64_t **)(a1 + 64);
    v39 = 8 * a3;
    do
    {
      v40 = v38[v35];
      if (v40 != -1 && v36 <= v40)
        break;
      if (v40 != -1)
      {
        if (v33 <= v40)
          break;
        v42 = *(_QWORD *)(a1 + 32);
        if (v42 > v40)
        {
          v43 = 0;
          do
          {
            if (v38[v43 / 8] == v42)
            {
              v42 += 0x2000;
              *(_QWORD *)(a1 + 32) = v42;
            }
            v43 += 8;
          }
          while (v39 != v43);
          if ((int64_t)v42 >= *(_QWORD *)a1)
            break;
          memcpy(v34, (const void *)(*(_QWORD *)(a1 + 48) + 24 * v38[v35]), 0x30000uLL);
          memcpy((void *)(*(_QWORD *)(a1 + 48) + 24 * *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8 * v35)), (const void *)(*(_QWORD *)(a1 + 48) + 24 * *(_QWORD *)(a1 + 32)), 0x30000uLL);
          memcpy((void *)(*(_QWORD *)(a1 + 48) + 24 * *(_QWORD *)(a1 + 32)), v34, 0x30000uLL);
          v38 = *(uint64_t **)(a1 + 64);
          v38[v35] = *(_QWORD *)(a1 + 32);
          *(_QWORD *)(a1 + 32) += 0x2000;
        }
      }
      ++v35;
    }
    while (v35 != v37);
    v44 = v37;
    do
    {
      v45 = v38[(v44 - 1)];
      if (v33 > v45)
        break;
      if (v45 != -1)
      {
        if (v36 > v45)
          break;
        v46 = (v44 - 1);
        v47 = *(_QWORD *)(a1 + 40) + 0x2000;
        *(_QWORD *)(a1 + 40) = v47;
        v48 = v37 + 1;
        do
        {
          if (v38[(v48 - 2)] == a2 - v47)
          {
            v47 += 0x2000;
            *(_QWORD *)(a1 + 40) = v47;
          }
          --v48;
        }
        while (v48 > 1);
        if ((unint64_t)(a2 - v47) < *(_QWORD *)(a1 + 16))
          break;
        v49 = v46;
        memcpy(v34, (const void *)(*(_QWORD *)(a1 + 48) + 24 * v38[v46]), 0x30000uLL);
        memcpy((void *)(*(_QWORD *)(a1 + 48) + 24 * *(_QWORD *)(*(_QWORD *)(a1 + 64) + v49 * 8)), (const void *)(*(_QWORD *)(a1 + 48) + 24 * (a2 - *(_QWORD *)(a1 + 40))), 0x30000uLL);
        memcpy((void *)(*(_QWORD *)(a1 + 48) + 24 * (a2 - *(_QWORD *)(a1 + 40))), v34, 0x30000uLL);
        v38 = *(uint64_t **)(a1 + 64);
        v38[v49] = a2 - *(_QWORD *)(a1 + 40);
      }
      v31 = v44-- <= 1;
    }
    while (!v31);
    v50 = *(_QWORD *)a1;
    v51 = *(_QWORD *)(a1 + 16) - 1;
    do
    {
      v53 = *v38++;
      v52 = v53;
      if (v53 != -1)
      {
        if (v52 < v50)
          v50 = v52;
        v54 = v52 + 0x2000;
        v55 = v52 + 0x1FFF;
        if (v54 > v51)
          v51 = v55;
        if (v51 >= a2)
        {
          v56 = __si_assert_copy_extra_268();
          v57 = v56;
          v58 = "";
          if (v56)
            v58 = v56;
          __message_assert(v56, "OQueue.c", 17, "right < count", v58);
          free(v57);
          if (__valid_fs(-1))
          {
            MEMORY[0xBAD] = -559038737;
            abort();
          }
          MEMORY[0xC00] = -559038737;
          abort();
        }
      }
      --v37;
    }
    while (v37);
  }
  free(v34);
  if (v50 >= v51)
  {
    v59 = v50;
  }
  else
  {
    v59 = v50;
    do
    {
      v61 = *(_QWORD *)(a1 + 48);
      v60 = *(_QWORD *)(a1 + 56);
      v62 = (unint64_t *)(v61 + 24 * v50);
      while (*v62 < v60)
      {
        ++v59;
        v62 += 3;
        if (v59 >= v51)
        {
          if (v51 <= v50 + 1)
            v59 = v50 + 1;
          else
            v59 = v51;
          goto LABEL_105;
        }
      }
      if (v59 < v51)
      {
        v63 = (unint64_t *)(v61 + 24 * v51);
        while (*v63 > v60)
        {
          --v51;
          v63 -= 3;
          if (v59 >= v51)
            goto LABEL_105;
        }
        v64 = v63[2];
        v65 = *(_OWORD *)v63;
        v66 = v62[2];
        *(_OWORD *)v63 = *(_OWORD *)v62;
        v63[2] = v66;
        v67 = *(_QWORD *)(a1 + 48) + 24 * v59;
        *(_OWORD *)v67 = v65;
        *(_QWORD *)(v67 + 16) = v64;
        ++v59;
        --v51;
      }
      v50 = v59;
    }
    while (v59 < v51);
  }
LABEL_105:
  if (*(_QWORD *)(*(_QWORD *)(a1 + 48) + 24 * v59) >= *(_QWORD *)(a1 + 56))
    return v59;
  else
    return v59 + 1;
}

uint64_t _big_split_PositionOffsetWithMeta_t(void *a1, uint64_t a2, uint64_t a3, NSObject *a4, signed int a5)
{
  uint64_t v5;

  v5 = a2 + 1;
  if (a5 >= 3)
  {
    while (v5 < (uint64_t)((unint64_t)a5 << 13))
    {
      if (a5-- <= 3)
      {
        a5 = 2;
        return parallel_partition_PositionOffsetWithMeta_t(a1, v5, a3, a4, a5);
      }
    }
  }
  return parallel_partition_PositionOffsetWithMeta_t(a1, v5, a3, a4, a5);
}

void storage_reader_destroy(uint64_t a1)
{
  unsigned int *v1;

  v1 = *(unsigned int **)(a1 + 8);
  if (v1)
  {
    _release_read_window(&availableReaders, v1);
    *(_QWORD *)(a1 + 8) = 0;
  }
}

_QWORD *_storage_reader_match_address(_QWORD *result, unint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  if (result)
  {
    v2 = result[1];
    if (v2)
      v3 = v2 + 528;
    else
      v3 = *result + 216;
    return (_QWORD *)storage_windows_contains_address(v3, a2);
  }
  return result;
}

void _storage_reader_exception_cleanup(uint64_t a1)
{
  unsigned int *v2;

  if (a1)
  {
    v2 = *(unsigned int **)(a1 + 8);
    if (v2)
    {
      _release_read_window(&availableReaders, v2);
      *(_QWORD *)(a1 + 8) = 0;
    }
  }
}

BOOL _storage_match_address(uint64_t a1, unint64_t a2)
{
  return _windowsAddressOffset(a1 + 216, a2) != -1;
}

uint64_t _storage_exception_cleanup(uint64_t result)
{
  *(_BYTE *)(result + 4365) = 1;
  return result;
}

char *storageResolvePtr(uint64_t a1, unint64_t a2, unint64_t a3, int a4)
{
  unint64_t v6;
  unint64_t v9;
  unint64_t v11;
  _QWORD *v12;
  uint64_t *v13;
  char *result;
  __n128 v15;
  __n128 v16;
  char *v17;
  char *v18;
  const char *v19;
  char *v20;
  char *v21;
  char *v22;
  const char *v23;
  uint64_t v24;
  BOOL v25;
  int v26;
  char *v27;
  char *v28;
  const char *v29;
  uint64_t v30;

  v6 = *(_QWORD *)(a1 + 232);
  if (v6 <= a2)
  {
    v17 = __si_assert_copy_extra(*(_DWORD **)(a1 + 216));
    v18 = v17;
    v19 = "";
    if (v17)
      v19 = v17;
    __message_assert("%s:%u: failed assertion '%s' %s offset:%lld, free_region:%lld", "storage.c", 1419, "inOffset<inStorage->_windows._freeRegion", v19, a2, *(_QWORD *)(a1 + 232));
    v20 = v18;
LABEL_23:
    free(v20);
    if (__valid_fsp(*(_DWORD **)(a1 + 216)))
      v24 = 2989;
    else
      v24 = 3072;
    *(_DWORD *)v24 = -559038737;
    abort();
  }
  v9 = a3 + a2;
  if (a3 + a2 > v6 && a4 != 0)
  {
    v21 = __si_assert_copy_extra(*(_DWORD **)(a1 + 216));
    v22 = v21;
    v23 = "";
    if (v21)
      v23 = v21;
    __message_assert("%s:%u: failed assertion '%s' %s offset:%lld, size:%lld, free_region:%lld", "storage.c", 1420, "!check_size||inOffset+inSize<=inStorage->_windows._freeRegion", v23, a2, a3, *(_QWORD *)(a1 + 232));
    v20 = v22;
    goto LABEL_23;
  }
  v11 = a2 >> *(_BYTE *)(a1 + 256);
  if (v11 < *(int *)(a1 + 240))
  {
    v12 = *(_QWORD **)(a1 + 8 * v11 + 264);
    if (v12)
    {
      if (v12[2] <= a2 && v12[3] >= v9 && *(_QWORD *)(a1 + 224) >= v9 && !v12[1])
      {
        if (a2)
          v25 = 0;
        else
          v25 = a3 == 1;
        v26 = !v25;
        _windowsMapInit(a1 + 216, v26);
      }
    }
  }
  v13 = (uint64_t *)(a1 + 216);
  result = (char *)_windowsGetPtr((uint64_t)v13, a2, a3);
  if (!result)
    return _moveWindows(v13, a2, a3, a4, v15, v16);
  if (result == (char *)a2)
  {
    v27 = __si_assert_copy_extra(0);
    v28 = v27;
    v29 = "";
    if (v27)
      v29 = v27;
    __message_assert("%s:%u: failed assertion '%s' %s ", "storage.c", 1451, "(offset_t)(intptr_t)ptr !=inOffset", v29);
    free(v28);
    if (__valid_fs(-1))
      v30 = 2989;
    else
      v30 = 3072;
    *(_DWORD *)v30 = -559038737;
    abort();
  }
  return result;
}

void storageMakeReadOnly(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = a1;
  storageUnmap(a1);
  v2 = *(_QWORD *)(v1 + 216);
  v1 += 216;
  fd_make_readonly(v2);
  *(_DWORD *)(v1 + 4144) = 1;
  *(_BYTE *)(v1 + 28) = 1;
  _windowsMapInit(v1, 1);
}

uint64_t *storageHeaderStore(uint64_t a1, uint64_t *a2)
{
  unsigned int v4;
  _BYTE *v5;
  uint64_t v6;
  uint64_t *result;
  uint64_t i;
  unint64_t v9;
  char *v10;
  char *v11;
  const char *v12;
  uint64_t v13;

  v4 = *(_DWORD *)(a1 + 4);
  v5 = (_BYTE *)*a2;
  if (v4 >> 28)
  {
    *v5 = v4 | 0x80;
    v5[1] = (v4 >> 7) | 0x80;
    v5[2] = (v4 >> 14) | 0x80;
    v5[3] = (v4 >> 21) | 0x80;
    v5[4] = v4 >> 28;
    v6 = 5;
  }
  else if ((v4 & 0xFE00000) != 0)
  {
    *v5 = v4 | 0x80;
    v5[1] = (v4 >> 7) | 0x80;
    v5[2] = (v4 >> 14) | 0x80;
    v5[3] = (v4 & 0xFE00000) >> 21;
    v6 = 4;
  }
  else if ((v4 & 0x1FC000) != 0)
  {
    *v5 = v4 | 0x80;
    v5[1] = (v4 >> 7) | 0x80;
    v5[2] = (v4 & 0x1FC000) >> 14;
    v6 = 3;
  }
  else if ((v4 & 0x3F80) != 0)
  {
    *v5 = v4 | 0x80;
    v5[1] = (unsigned __int16)(v4 & 0x3F80) >> 7;
    v6 = 2;
  }
  else
  {
    *v5 = v4;
    v6 = 1;
  }
  *a2 += v6;
  storeVInt64(a2, *(_QWORD *)(a1 + 232));
  result = storeVInt64(a2, *(_QWORD *)(a1 + 224));
  for (i = 0; i != 128; i += 8)
  {
    v9 = *(_QWORD *)(a1 + 8 + i);
    if (v9)
    {
      if (v9 >= *(_QWORD *)(a1 + 232))
      {
        v10 = __si_assert_copy_extra(*(_DWORD **)(a1 + 216));
        v11 = v10;
        v12 = "";
        if (v10)
          v12 = v10;
        __message_assert("%s:%u: failed assertion '%s' %s offset: 0x%lld, freeRegion: 0x%lld", "storage.c", 192, "(head==0) || (head < storage->_windows._freeRegion)", v12, v9, *(_QWORD *)(a1 + 232));
        free(v11);
        if (__valid_fsp(*(_DWORD **)(a1 + 216)))
          v13 = 2989;
        else
          v13 = 3072;
        *(_DWORD *)v13 = -559038737;
        abort();
      }
      result = storeVInt64(a2, *(_QWORD *)(a1 + 8 + i));
    }
    else
    {
      *(_BYTE *)(*a2)++ = 0;
    }
  }
  return result;
}

BOOL storageHeaderRestore(uint64_t a1, char **a2)
{
  char *v4;
  int v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  int v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned __int8 v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned __int8 *v20;
  uint64_t v21;
  unsigned __int8 v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  unsigned __int8 v29;
  _BOOL8 result;
  int v31;
  NSObject *v32;
  int v33;
  NSObject *v34;
  int *v35;
  uint64_t v36;
  int v37;
  int v38;
  const char *v39;
  __int16 v40;
  int v41;
  __int16 v42;
  int v43;
  __int16 v44;
  unint64_t v45;
  __int16 v46;
  uint64_t v47;
  uint64_t v48;

  v48 = *MEMORY[0x1E0C80C00];
  bzero((void *)a1, 0x1138uLL);
  v4 = *a2;
  v5 = **a2;
  if (**a2 < 0)
  {
    v7 = v4[1];
    if (v4[1] < 0)
    {
      v8 = v4[2];
      if (v4[2] < 0)
      {
        v10 = v4[3];
        if (v4[3] < 0)
        {
          v37 = v4[4];
          v11 = v4 + 5;
          *a2 = v11;
          *(_DWORD *)(a1 + 4) = ((v10 & 0x7F) << 21) | (v37 << 28) | ((v8 & 0x7F) << 14) | ((v7 & 0x7F) << 7) | v5 & 0x7F;
          if ((v37 & 0x80000000) == 0)
            goto LABEL_31;
          goto LABEL_11;
        }
        v9 = ((v8 & 0x7F) << 14) | (v10 << 21) | ((v7 & 0x7F) << 7) | v5 & 0x7F;
        v6 = 4;
      }
      else
      {
        v9 = ((v7 & 0x7F) << 7) | (v8 << 14) | v5 & 0x7F;
        v6 = 3;
      }
      v5 = v9;
    }
    else
    {
      v5 = v5 & 0x7F | (v7 << 7);
      v6 = 2;
    }
  }
  else
  {
    v6 = 1;
  }
  v11 = &v4[v6];
  *a2 = v11;
  *(_DWORD *)(a1 + 4) = v5;
LABEL_11:
  v12 = 0;
  v13 = 0;
  v14 = 0;
  do
  {
    v15 = v11[v13++];
    v14 |= (unint64_t)(v15 & 0x7F) << v12;
    if ((v15 & 0x80) == 0)
      break;
    v16 = v12 == 63;
    v12 += 7;
  }
  while (!v16);
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v20 = (unsigned __int8 *)&v11[v13];
  *a2 = &v11[v13];
  *(_QWORD *)(a1 + 232) = v14;
  do
  {
    v21 = v18 + 1;
    v22 = v11[v18 + v13];
    v19 |= (unint64_t)(v22 & 0x7F) << v17;
    if ((v22 & 0x80) == 0)
      break;
    v18 = v21;
    v16 = v17 == 63;
    v17 += 7;
  }
  while (!v16);
  v23 = 0;
  v24 = (char *)&v20[v21];
  *a2 = (char *)&v20[v21];
  *(_QWORD *)(a1 + 224) = v19;
  while (1)
  {
    v25 = 0;
    v26 = 0;
    v27 = 0;
    do
    {
      v28 = v26 + 1;
      v29 = v24[v26];
      v27 |= (unint64_t)(v29 & 0x7F) << v25;
      if ((v29 & 0x80) == 0)
        break;
      v26 = v28;
      v16 = v25 == 63;
      v25 += 7;
    }
    while (!v16);
    v24 += v28;
    *a2 = v24;
    if (v27)
    {
      if (*(_QWORD *)(a1 + 232) <= v27)
        break;
    }
    *(_QWORD *)(a1 + 8 * v23++ + 8) = v27;
    if (v23 == 16)
      return *(_QWORD *)(a1 + 224) >= *(_QWORD *)(a1 + 232);
  }
  v31 = *__error();
  v32 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
  {
    v36 = *(_QWORD *)(a1 + 232);
    v38 = 136316162;
    v39 = "_storeageSetFreeListHead";
    v40 = 1024;
    v41 = 200;
    v42 = 1024;
    v43 = v23;
    v44 = 2048;
    v45 = v27;
    v46 = 2048;
    v47 = v36;
    _os_log_error_impl(&dword_1B8270000, v32, OS_LOG_TYPE_ERROR, "%s:%d: %d: offset(%lld) < freeRegion (%lld)", (uint8_t *)&v38, 0x2Cu);
  }
  *__error() = v31;
LABEL_31:
  v33 = *__error();
  v34 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
  {
    v38 = 136315394;
    v39 = "storageHeaderRestore";
    v40 = 1024;
    v41 = 357;
    _os_log_error_impl(&dword_1B8270000, v34, OS_LOG_TYPE_ERROR, "%s:%d: invalid storage data", (uint8_t *)&v38, 0x12u);
  }
  v35 = __error();
  result = 0;
  *v35 = v33;
  return result;
}

BOOL storageInit(uint64_t a1, off_t a2, unint64_t a3, uint64_t a4, int a5, int a6, char a7, int a8, void *aBlock)
{
  char v11;
  int v16;
  NSObject *v17;
  int *v18;
  _BOOL8 result;
  int v20;
  off_t st_size;
  void *v22;
  uint64_t v23;
  _OWORD *v24;
  unint64_t v25;
  stat v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  if (a4)
  {
    v11 = a5;
    *(_DWORD *)a1 = a8;
    if (a5)
    {
      *(_DWORD *)(a1 + 196) = 0;
      *(_OWORD *)(a1 + 180) = 0u;
      *(_OWORD *)(a1 + 164) = 0u;
      *(_OWORD *)(a1 + 148) = 0u;
      *(_OWORD *)(a1 + 132) = 0u;
      *(_OWORD *)(a1 + 116) = 0u;
      *(_OWORD *)(a1 + 100) = 0u;
      *(_OWORD *)(a1 + 84) = 0u;
      *(_OWORD *)(a1 + 68) = 0u;
      *(_OWORD *)(a1 + 52) = 0u;
      *(_OWORD *)(a1 + 36) = 0u;
      *(_OWORD *)(a1 + 20) = 0u;
      *(_OWORD *)(a1 + 4) = 0u;
    }
    else
    {
      memset(&v26, 0, sizeof(v26));
      v20 = fd_stat(a4, &v26);
      st_size = *(_QWORD *)(a1 + 224);
      if (!st_size)
      {
        st_size = v26.st_size;
        if (v20)
          st_size = a2;
        *(_DWORD *)(a1 + 4) = 0;
      }
      a2 = st_size;
    }
    *(_QWORD *)(a1 + 216) = a4;
    *(_BYTE *)(a1 + 244) = a7;
    *(_QWORD *)(a1 + 224) = a2;
    *(_DWORD *)(a1 + 240) = 1;
    *(_BYTE *)(a1 + 245) = 0;
    if (aBlock)
      v22 = _Block_copy(aBlock);
    else
      v22 = 0;
    *(_QWORD *)(a1 + 248) = v22;
    *(_BYTE *)(a1 + 256) = 26;
    bzero((void *)(a1 + 264), 0x1000uLL);
    if (!*(_QWORD *)(a1 + 232))
    {
      v23 = 8;
      if (a3 > 8)
        v23 = a3;
      *(_QWORD *)(a1 + 232) = v23;
    }
    *(_DWORD *)(a1 + 208) = a6;
    v24 = malloc_type_malloc(0xD0uLL, 0x1020040167D79A3uLL);
    *(_QWORD *)(a1 + 4400) = v24;
    *v24 = 0u;
    v24[1] = 0u;
    v24[2] = 0u;
    v24[3] = 0u;
    v24[4] = 0u;
    v24[5] = 0u;
    v24[6] = 0u;
    v24[7] = 0u;
    v24[8] = 0u;
    v24[9] = 0u;
    v24[10] = 0u;
    v24[11] = 0u;
    v24[12] = 0u;
    pthread_rwlock_init(*(pthread_rwlock_t **)(a1 + 4400), 0);
    *(_BYTE *)(a1 + 244) = a7;
    *(_BYTE *)(a1 + 246) = 0;
    *(_DWORD *)(a1 + 4392) = 0;
    _windowsMapInit(a1 + 216, 0);
    if ((v11 & 1) != 0)
    {
      if ((a7 & 1) != 0)
        return 1;
      fd_truncate(a4, 0);
      v25 = *(_QWORD *)(a1 + 224);
    }
    else
    {
      v25 = *(_QWORD *)(a1 + 224);
      if (*(_QWORD *)(a1 + 232) > v25)
        return 0;
      if ((a7 & 1) != 0)
        return 1;
    }
    return !fd_truncate(a4, v25);
  }
  v16 = *__error();
  v17 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
  {
    v26.st_dev = 136315394;
    *(_QWORD *)&v26.st_mode = "storageInit";
    WORD2(v26.st_ino) = 1024;
    *(_DWORD *)((char *)&v26.st_ino + 6) = 400;
    _os_log_error_impl(&dword_1B8270000, v17, OS_LOG_TYPE_ERROR, "%s:%d: storageInit - inFdPtr == NULL", (uint8_t *)&v26, 0x12u);
  }
  v18 = __error();
  result = 0;
  *v18 = v16;
  return result;
}

void storageClose(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t *v4;
  pthread_rwlock_t *v5;

  v2 = a1 + 216;
  if (*(int *)(a1 + 240) >= 1)
  {
    v3 = 0;
    v4 = (uint64_t *)(a1 + 264);
    do
    {
      storageWindowReleaseImmediate(v4);
      ++v3;
      ++v4;
    }
    while (v3 < *(int *)(a1 + 240));
  }
  storageWindowsClose(v2);
  v5 = *(pthread_rwlock_t **)(a1 + 4400);
  if (v5)
  {
    pthread_rwlock_wrlock(v5);
    _release_read_window(&availableReaders, *(unsigned int **)(*(_QWORD *)(a1 + 4400) + 200));
    pthread_rwlock_unlock(*(pthread_rwlock_t **)(a1 + 4400));
    pthread_rwlock_destroy(*(pthread_rwlock_t **)(a1 + 4400));
    free(*(void **)(a1 + 4400));
    *(_QWORD *)(a1 + 4400) = 0;
  }
  *(_BYTE *)(a1 + 4364) = 1;
}

uint64_t storageSyncPages(uint64_t a1, uint64_t a2, size_t a3)
{
  unint64_t v6;
  double Current;
  uint64_t v8;
  CFIndex v9;
  int v10;
  void *v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  int v16;
  NSObject *v17;
  int v18;
  NSObject *v19;
  os_log_type_t v20;
  float v21;
  const char *v23;
  int v24;
  const char *v25;
  __int16 v26;
  int v27;
  __int16 v28;
  int v29;
  __int16 v30;
  uint64_t v31;
  __int16 v32;
  int v33;
  __int16 v34;
  const char *v35;
  uint8_t buf[4];
  int v37;
  __int16 v38;
  int v39;
  __int16 v40;
  double v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  v6 = (a3 + *(_QWORD *)(a1 + 232) - 1) / a3;
  Current = CFAbsoluteTimeGetCurrent();
  if (!*(_BYTE *)(a1 + 244) && *(_BYTE *)(a1 + 246) && *(int *)(a1 + 240) >= 1)
  {
    v14 = 0;
    do
      storageWindowSync(*(_QWORD **)(a1 + 264 + 8 * v14++), 0);
    while (v14 < *(int *)(a1 + 240));
  }
  if (!(_DWORD)v6)
  {
    v10 = 0;
    v13 = 0;
    goto LABEL_26;
  }
  v8 = 0;
  v9 = 0;
  v10 = 0;
  while (1)
  {
    if (*(_QWORD *)a2 <= v9 || !CFBitVectorGetBitAtIndex(*(CFBitVectorRef *)(a2 + 16), v9))
    {
      v13 = 0;
      goto LABEL_14;
    }
    v11 = (void *)fd_mmap(*(_QWORD *)(a1 + 216));
    if (v11 == (void *)-1)
      break;
    v12 = v11;
    if (msync(v11, a3, 16))
      v13 = *__error();
    else
      v13 = 0;
    if (munmap(v12, a3))
      v13 = *__error();
    ++v10;
    if ((_DWORD)v13)
      goto LABEL_26;
LABEL_14:
    ++v9;
    v8 += a3;
    if (v9 >= (unint64_t)v6)
      goto LABEL_26;
  }
  v13 = *__error();
  bzero(buf, 0x400uLL);
  v15 = fd_realpath(*(_DWORD **)(a1 + 216), buf);
  if (!v15)
    v15 = fd_name(*(_QWORD *)(a1 + 216), (char *)buf, 0x400uLL);
  v16 = *__error();
  v17 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
  {
    v23 = "";
    v24 = 136316418;
    v25 = "storageSyncPages";
    v26 = 1024;
    if (v15)
      v23 = v15;
    v27 = 552;
    v28 = 1024;
    v29 = a3;
    v30 = 2048;
    v31 = v8;
    v32 = 1024;
    v33 = v13;
    v34 = 2080;
    v35 = v23;
    _os_log_error_impl(&dword_1B8270000, v17, OS_LOG_TYPE_ERROR, "%s:%d: mmap(%d, %lld) err:%d, %s", (uint8_t *)&v24, 0x32u);
  }
  *__error() = v16;
LABEL_26:
  v18 = *__error();
  v19 = _SILogForLogForCategory(10);
  v20 = 2 * (dword_1EF19FCB4 < 4);
  if (os_log_type_enabled(v19, v20))
  {
    v21 = CFAbsoluteTimeGetCurrent() - Current;
    *(_DWORD *)buf = 67109632;
    v37 = v6;
    v38 = 1024;
    v39 = v10;
    v40 = 2048;
    v41 = v21;
    _os_log_impl(&dword_1B8270000, v19, v20, "sync pages (%d, %d) took %f seconds", buf, 0x18u);
  }
  *__error() = v18;
  return v13;
}

uint64_t storageInvalidate(uint64_t result, unint64_t a2, uint64_t a3)
{
  int v3;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  unint64_t v11;
  BOOL v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;

  v3 = *(_DWORD *)(result + 240);
  if (v3 >= 1)
  {
    v6 = result;
    v7 = 0;
    v8 = a3 + a2;
    v9 = result + 264;
    do
    {
      v10 = *(_QWORD **)(v9 + 8 * v7);
      if (v10)
      {
        v11 = v10[2];
        v12 = a2 >= v11;
        v13 = a2 - v11;
        if (v12)
        {
          v14 = v10[3];
          v15 = v10[1];
          if (v14 <= v8)
            v16 = 0;
          else
            v16 = v13;
          result = sync_invalidate_mapping((char *)(v15 + v16), a3);
          v3 = *(_DWORD *)(v6 + 240);
        }
      }
      ++v7;
    }
    while (v7 < v3);
  }
  return result;
}

int *storageDeactivateAll(int *result, int a2)
{
  int *v3;
  uint64_t v4;
  int *v5;
  uint64_t v6;
  size_t v7;

  if (result[60] >= 1)
  {
    v3 = result;
    v4 = 0;
    v5 = result + 66;
    do
    {
      v6 = *(_QWORD *)&v5[2 * v4];
      if (v6)
      {
        result = *(int **)(v6 + 8);
        if (result)
        {
          v7 = *(_QWORD *)(v6 + 24) - *(_QWORD *)(v6 + 16);
          if (a2)
          {
            msync(result, v7, 16);
            result = (int *)madvise(*(void **)(v6 + 8), *(_QWORD *)(v6 + 24) - *(_QWORD *)(v6 + 16), 4);
          }
          else
          {
            result = (int *)msync(result, v7, 8);
          }
        }
      }
      ++v4;
    }
    while (v4 < v3[60]);
  }
  return result;
}

uint64_t storageAllocOffsetFromEnd(uint64_t a1, unsigned int a2)
{
  uint64_t v3;
  unsigned int v4;
  _BOOL4 v6;
  int v7;
  char v8;
  int v9;
  uint64_t result;
  unint64_t v11;

  v3 = *(int *)(a1 + 4);
  if (a2 <= v3)
  {
    v8 = 0;
  }
  else
  {
    v4 = __clz(a2 - v3);
    v6 = ((a2 - (_DWORD)v3) & (a2 - (_DWORD)v3 - 1)) != 0 || a2 == (_DWORD)v3;
    v7 = v6 - v4;
    if (v7 <= -29)
      v8 = 0;
    else
      v8 = v7 + 28;
  }
  v9 = 8 << v8;
  v11 = *(_QWORD *)(a1 + 224);
  result = *(_QWORD *)(a1 + 232);
  if (v3 + result + (16 << v8) + 8 < v11)
    goto LABEL_13;
  if (_storageExpand(a1, v9))
  {
    result = *(_QWORD *)(a1 + 232);
LABEL_13:
    *(_QWORD *)(a1 + 232) = v3 + v9 + result;
    return result;
  }
  return 0;
}

uint64_t storageTruncate(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  NSObject *v5;
  int v7;
  const char *v8;
  __int16 v9;
  int v10;
  __int16 v11;
  int v12;
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v2 = fd_truncate(a1[27], a1[29]);
  if ((_DWORD)v2 == -1)
  {
    v3 = *__error();
    v4 = *__error();
    v5 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v7 = 136315650;
      v8 = "storageTruncate";
      v9 = 1024;
      v10 = 835;
      v11 = 1024;
      v12 = v3;
      _os_log_error_impl(&dword_1B8270000, v5, OS_LOG_TYPE_ERROR, "%s:%d: ftruncate error %d", (uint8_t *)&v7, 0x18u);
    }
    *__error() = v4;
  }
  else
  {
    v3 = v2;
    a1[28] = a1[29];
  }
  return v3;
}

uint64_t storageTruncateAndMakeReadOnly(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;

  result = storageTruncate((uint64_t *)a1);
  if (!(_DWORD)result)
  {
    *(_BYTE *)(a1 + 244) = 1;
    v3 = *(unsigned int *)(a1 + 240);
    if ((int)v3 >= 1)
    {
      v4 = a1 + 264;
      do
      {
        if (*(_QWORD *)v4)
          *(_BYTE *)(*(_QWORD *)v4 + 40) = 1;
        v4 += 8;
        --v3;
      }
      while (v3);
    }
    return fd_make_readonly(*(_QWORD *)(a1 + 216));
  }
  return result;
}

unint64_t takeBuddyPage_2842(uint64_t a1, unsigned int a2)
{
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  char *v10;
  char *v11;
  unint64_t v12;
  char *v13;
  char *v14;
  const char *v15;
  char *v16;
  uint64_t v18;
  char *v19;
  char *v20;
  char *v21;
  const char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  NSObject *v27;
  uint64_t v28;
  char *v29;
  char *v30;
  const char *v31;
  uint64_t v32;
  uint8_t buf[4];
  const char *v34;
  __int16 v35;
  int v36;
  __int16 v37;
  unsigned int v38;
  __int16 v39;
  uint64_t v40;
  __int16 v41;
  uint64_t v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  if (a2 > 0x16 || *(_DWORD *)(a1 + 4) || *(_QWORD *)(a1 + 200) <= (unint64_t)a2)
    return 0;
  v4 = 8 << a2;
  v5 = a2 + 1;
  v6 = a1 + 8 * (a2 + 1);
  v9 = *(_QWORD *)(v6 + 8);
  v8 = (unint64_t *)(v6 + 8);
  v7 = v9;
  if (v9)
  {
    if (v7 >= *(_QWORD *)(a1 + 232))
    {
      v20 = __si_assert_copy_extra(*(_DWORD **)(a1 + 216));
      v21 = v20;
      v22 = "";
      if (v20)
        v22 = v20;
      __message_assert("%s:%u: failed assertion '%s' %s offset: 0x%lld, freeRegion: 0x%lld", "storage.c", 192, "(head==0) || (head < storage->_windows._freeRegion)", v22, v7, *(_QWORD *)(a1 + 232));
      free(v21);
      if (__valid_fsp(*(_DWORD **)(a1 + 216)))
        v23 = 2989;
      else
        v23 = 3072;
      *(_DWORD *)v23 = -559038737;
      abort();
    }
    v10 = storageResolvePtr(a1, v7, 8uLL, 1);
    if (v10)
    {
      v11 = v10;
      v12 = *(_QWORD *)v10;
      if (*(_QWORD *)v10 && *(_QWORD *)(a1 + 232) <= v12)
      {
        v25 = *(_QWORD *)v10;
        v26 = *__error();
        v27 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
        {
          v28 = *(_QWORD *)(a1 + 232);
          *(_DWORD *)buf = 136316162;
          v34 = "_storeageSetFreeListHead";
          v35 = 1024;
          v36 = 200;
          v37 = 1024;
          v38 = v5;
          v39 = 2048;
          v40 = v25;
          v41 = 2048;
          v42 = v28;
          _os_log_error_impl(&dword_1B8270000, v27, OS_LOG_TYPE_ERROR, "%s:%d: %d: offset(%lld) < freeRegion (%lld)", buf, 0x2Cu);
        }
        *__error() = v26;
        v29 = __si_assert_copy_extra(0);
        v30 = v29;
        v31 = "";
        if (v29)
          v31 = v29;
        __message_assert("%s:%u: failed assertion '%s' %s free idx %d offset %lld bs %d bl %lld", "storage.c", 633, "result", v31, a2, *(_QWORD *)v11, *(_DWORD *)(a1 + 4), *(_QWORD *)(a1 + 200));
        free(v30);
        if (__valid_fs(-1))
          v32 = 2989;
        else
          v32 = 3072;
        *(_DWORD *)v32 = -559038737;
        abort();
      }
      *v8 = v12;
      *(_QWORD *)v10 = 0;
      if ((_storeageSetFreeListHead(a1, a2, v7 + v4) & 1) == 0)
      {
        v13 = __si_assert_copy_extra(0);
        v14 = v13;
        v15 = "";
        if (v13)
          v15 = v13;
        __message_assert("%s:%u: failed assertion '%s' %s clear idx %d offset %lld bs %d bl %lld", "storage.c", 639, "result", v15, a2, *(_QWORD *)v11, *(_DWORD *)(a1 + 4), *(_QWORD *)(a1 + 200));
        v16 = v14;
LABEL_25:
        free(v16);
        if (__valid_fs(-1))
          v24 = 2989;
        else
          v24 = 3072;
        *(_DWORD *)v24 = -559038737;
        abort();
      }
      return v7;
    }
    v19 = __si_assert_copy_extra(0);
    __message_assert("%s:%u: failed assertion '%s' %s get node %lld idx %d bs %d bl %lld", "storage.c");
LABEL_24:
    v16 = v19;
    goto LABEL_25;
  }
  v18 = takeBuddyPage_2842(a1, a2 + 1);
  v7 = v18;
  if (!v18)
  {
    *(_QWORD *)(a1 + 200) = a2;
    return v7;
  }
  if ((_storeageSetFreeListHead(a1, a2, v18 + v4) & 1) == 0)
  {
    v19 = __si_assert_copy_extra(0);
    __message_assert("%s:%u: failed assertion '%s' %s free idx %d node %lld size %d bs %d bl %lld", "storage.c", 642);
    goto LABEL_24;
  }
  return v7;
}

void bit_vector_set_2851(uint64_t a1, CFIndex idx)
{
  CFIndex v4;
  CFIndex v5;
  char *v6;
  char *v7;
  const char *v8;
  uint64_t v9;
  const __CFBitVector *v10;
  const __CFAllocator *v11;
  __CFBitVector *MutableCopy;
  __CFBitVector *v13;
  const void *v14;
  char *v15;
  const char *v16;

  v4 = *(_QWORD *)(a1 + 8);
  if (v4 <= idx)
  {
    if (v4)
      v5 = *(_QWORD *)(a1 + 8);
    else
      v5 = 32;
    while (1)
    {
      v5 *= 2;
      if (v5 > idx)
        break;
      if (v5 <= v4)
      {
        v6 = __si_assert_copy_extra(0);
        v7 = v6;
        v8 = "";
        if (v6)
          v8 = v6;
        __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 111, "newCapacity > bv->capacity", v8);
        goto LABEL_13;
      }
    }
    v10 = *(const __CFBitVector **)(a1 + 16);
    v11 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    if (v10)
      MutableCopy = CFBitVectorCreateMutableCopy(v11, v5, v10);
    else
      MutableCopy = CFBitVectorCreateMutable(v11, v5);
    v13 = MutableCopy;
    if (!MutableCopy)
    {
      v15 = __si_assert_copy_extra(0);
      v7 = v15;
      v16 = "";
      if (v15)
        v16 = v15;
      __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 115, "newBV", v16);
LABEL_13:
      free(v7);
      if (__valid_fs(-1))
        v9 = 2989;
      else
        v9 = 3072;
      *(_DWORD *)v9 = -559038737;
      abort();
    }
    CFBitVectorSetCount(MutableCopy, v5);
    v14 = *(const void **)(a1 + 16);
    if (v14)
      CFRelease(v14);
    *(_QWORD *)(a1 + 8) = v5;
    *(_QWORD *)(a1 + 16) = v13;
  }
  if (*(_QWORD *)a1 <= idx)
    *(_QWORD *)a1 = idx + 1;
  CFBitVectorSetBitAtIndex(*(CFMutableBitVectorRef *)(a1 + 16), idx, 1u);
}

uint64_t freeListVerify(uint64_t a1, int a2)
{
  unint64_t v2;
  char v4;
  unint64_t v5;
  uint64_t result;
  int v7;
  NSObject *v8;
  unint64_t v9;
  const char *v10;
  NSObject *v11;
  uint32_t v12;
  NSObject *v13;
  int *v14;
  uint64_t v15;
  char *v16;
  char *v17;
  const char *v18;
  uint64_t v19;
  uint8_t buf[4];
  const char *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  unint64_t v25;
  __int16 v26;
  unint64_t v27;
  __int16 v28;
  uint64_t v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 8 * a2 + 8);
  if (v2)
  {
    if (v2 >= *(_QWORD *)(a1 + 232))
    {
      v16 = __si_assert_copy_extra(*(_DWORD **)(a1 + 216));
      v17 = v16;
      v18 = "";
      if (v16)
        v18 = v16;
      __message_assert("%s:%u: failed assertion '%s' %s offset: 0x%lld, freeRegion: 0x%lld", "storage.c", 192, "(head==0) || (head < storage->_windows._freeRegion)", v18, v2, *(_QWORD *)(a1 + 232));
      free(v17);
      if (__valid_fsp(*(_DWORD **)(a1 + 216)))
        v19 = 2989;
      else
        v19 = 3072;
      *(_DWORD *)v19 = -559038737;
      abort();
    }
    v4 = 0;
    v5 = *(_QWORD *)(a1 + 8 * a2 + 8);
    while (1)
    {
      result = (uint64_t)storageResolvePtr(a1, v5, 8uLL, 1);
      if (!result)
        return result;
      v5 = *(_QWORD *)result;
      if (*(_QWORD *)result >= *(_QWORD *)(a1 + 232))
        break;
      if ((v4 & 1) != 0)
      {
        v2 = *(_QWORD *)storageResolvePtr(a1, v2, 8uLL, 1);
        if (v2 == v5)
        {
          v7 = *__error();
          v13 = _SILogForLogForCategory(4);
          if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
            goto LABEL_13;
          v15 = *(_QWORD *)(a1 + 232);
          *(_DWORD *)buf = 136316162;
          v21 = "freeListVerify";
          v22 = 1024;
          v23 = 1102;
          v24 = 2048;
          v25 = v5;
          v26 = 2048;
          v27 = v5;
          v28 = 2048;
          v29 = v15;
          v10 = "%s:%d: Cycle in free-list: head:0x%llx, probe:0x%llx, freeRegion: 0x%llx";
          v11 = v13;
          v12 = 48;
          goto LABEL_16;
        }
      }
      ++v4;
      if (!v5)
        return 1;
    }
    v7 = *__error();
    v8 = _SILogForLogForCategory(4);
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
LABEL_13:
      v14 = __error();
      result = 0;
      *v14 = v7;
      return result;
    }
    v9 = *(_QWORD *)(a1 + 232);
    *(_DWORD *)buf = 136315906;
    v21 = "freeListVerify";
    v22 = 1024;
    v23 = 1094;
    v24 = 2048;
    v25 = v5;
    v26 = 2048;
    v27 = v9;
    v10 = "%s:%d: head:0x%llx, freeRegion: 0x%llx";
    v11 = v8;
    v12 = 38;
LABEL_16:
    _os_log_error_impl(&dword_1B8270000, v11, OS_LOG_TYPE_ERROR, v10, buf, v12);
    goto LABEL_13;
  }
  return 1;
}

void dirtyStoragePage(uint64_t a1, unint64_t a2)
{
  int v3;
  unint64_t v4;
  uint64_t v5;
  CFIndex v6;

  v3 = 64 << *(_BYTE *)(a2 + 2);
  v4 = _windowsAddressOffset(a1 + 216, a2);
  v5 = a1 + 4368;
  v6 = (v4 >> 17);
  bit_vector_set_2851(v5, v6);
  if (v6 != (v4 + v3) >> 17)
    bit_vector_set_2851(v5, (v4 >> 17) + 1);
}

char *storage_describe_windows(uint64_t a1, char *__str)
{
  int v4;
  uint64_t v5;
  char *v6;
  size_t v7;

  v4 = snprintf(__str, 0xFFuLL, "c:%d s:%lld", *(_DWORD *)(a1 + 240), *(_QWORD *)(a1 + 224));
  if (*(int *)(a1 + 240) >= 1 && v4 <= 0xFE)
  {
    v5 = 0;
    v6 = &__str[v4];
    v7 = 255 - v4;
    do
    {
      snprintf(v6, v7, "%d:(mem:%p so:%lld eo:%lld)", v5, *(const void **)(*(_QWORD *)(a1 + 264 + 8 * v5) + 8), *(_QWORD *)(*(_QWORD *)(a1 + 264 + 8 * v5) + 16), *(_QWORD *)(*(_QWORD *)(a1 + 264 + 8 * v5) + 24));
      ++v5;
    }
    while (v5 < *(int *)(a1 + 240));
  }
  return __str;
}

BOOL uint32_map_init(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  uint64_t v9;
  int v10;

  bzero((void *)a1, 0x1138uLL);
  *(_DWORD *)(a1 + 4408) = a3;
  v9 = 4 * a3;
  *(_QWORD *)(a1 + 224) = v9;
  *(_QWORD *)(a1 + 232) = v9;
  if (a5)
    v10 = 114;
  else
    v10 = 102;
  return storageInit(a1, 0, 4uLL, a2, 0, 0, 0, v10, 0);
}

uint64_t uint32_map_get(uint64_t a1, unsigned int a2)
{
  char *v3;
  char *v4;
  const char *v5;
  uint64_t v6;

  if (!a2 || *(_DWORD *)(a1 + 4408) <= a2)
  {
    v3 = __si_assert_copy_extra(0);
    v4 = v3;
    v5 = "";
    if (v3)
      v5 = v3;
    __message_assert("%s:%u: failed assertion '%s' %s ", "storage.c", 1530, "position && position < inMap->count", v5);
    free(v4);
    if (__valid_fs(-1))
      v6 = 2989;
    else
      v6 = 3072;
    *(_DWORD *)v6 = -559038737;
    abort();
  }
  return *(unsigned int *)storageResolvePtr(a1, 4 * a2, 4uLL, 1);
}

void __si_retain_service_connection_block_invoke(uint64_t a1)
{
  uint64_t v2;
  _xpc_connection_s *v3;
  const char *v4;
  NSObject *v5;
  uint64_t v6;
  _xpc_connection_s *mach_service;
  uint64_t v8;
  _QWORD v9[5];
  int v10;
  __int128 handler;
  void (*v12)(uint64_t, _xpc_connection_s *);
  void *v13;
  _QWORD *v14;
  NSObject *v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v2 = *(unsigned int *)(a1 + 48);
  v3 = (_xpc_connection_s *)gSIMachServicesNames_block_invoke_s_service_connections[v2];
  if (v3)
    goto LABEL_4;
  v4 = *(const char **)(a1 + 40);
  v5 = g_service_queues[v2];
  v6 = MEMORY[0x1E0C809B0];
  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 0x40000000;
  v9[2] = __si_retain_service_connection_block_invoke_2;
  v9[3] = &__block_descriptor_tmp_2906;
  v9[4] = v4;
  v10 = v2;
  mach_service = xpc_connection_create_mach_service(v4, v5, 0);
  if (mach_service)
  {
    v3 = mach_service;
    *(_QWORD *)&handler = v6;
    *((_QWORD *)&handler + 1) = 0x40000000;
    v12 = __si_xpc_setup_connection_block_invoke;
    v13 = &unk_1E6E2F408;
    v14 = v9;
    v15 = v5;
    xpc_connection_set_event_handler(mach_service, &handler);
    xpc_connection_activate(v3);
    gSIMachServicesNames_block_invoke_s_service_connections[*(unsigned int *)(a1 + 48)] = v3;
LABEL_4:
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = xpc_retain(v3);
    return;
  }
  gSIMachServicesNames_block_invoke_s_service_connections[*(unsigned int *)(a1 + 48)] = 0;
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
  {
    v8 = *(_QWORD *)(a1 + 40);
    LODWORD(handler) = 136315138;
    *(_QWORD *)((char *)&handler + 4) = v8;
    _os_log_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "### could not get client connection for %s", (uint8_t *)&handler, 0xCu);
  }
}

void __si_retain_service_connection_block_invoke_2(uint64_t a1)
{
  uint64_t v2;
  xpc_object_t v3;
  _xpc_connection_s *v4;
  int v5;
  uint64_t v6;
  __int16 v7;
  xpc_object_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
  {
    v2 = *(_QWORD *)(a1 + 32);
    v3 = gSIMachServicesNames_block_invoke_s_service_connections[*(unsigned int *)(a1 + 40)];
    v5 = 136315394;
    v6 = v2;
    v7 = 2048;
    v8 = v3;
    _os_log_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "### reset client connection %s %p", (uint8_t *)&v5, 0x16u);
  }
  v4 = (_xpc_connection_s *)gSIMachServicesNames_block_invoke_s_service_connections[*(unsigned int *)(a1 + 40)];
  if (v4)
  {
    xpc_connection_cancel(v4);
    xpc_release(gSIMachServicesNames_block_invoke_s_service_connections[*(unsigned int *)(a1 + 40)]);
    gSIMachServicesNames_block_invoke_s_service_connections[*(unsigned int *)(a1 + 40)] = 0;
  }
}

void __si_xpc_setup_connection_block_invoke(uint64_t a1, _xpc_connection_s *a2)
{
  uint64_t v4;
  int v5;
  _xpc_connection_s *v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  if (is_valid_xpc_type(0, a2, MEMORY[0x1E0C812E0]))
  {
    xpc_connection_set_target_queue(a2, *(dispatch_queue_t *)(a1 + 40));
    xpc_connection_set_event_handler(a2, &__block_literal_global_2910);
    xpc_connection_resume(a2);
  }
  else if (!is_valid_xpc_type(0, a2, MEMORY[0x1E0C812E0]) && MEMORY[0x1BCCB1B14](a2) == MEMORY[0x1E0C81310])
  {
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
      v5 = 134217984;
      v6 = a2;
      _os_log_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT, "### Connection error %p", (uint8_t *)&v5, 0xCu);
    }
    v4 = *(_QWORD *)(a1 + 32);
    if (v4)
      (*(void (**)(void))(v4 + 16))();
  }
}

BOOL is_valid_xpc_type(const char *a1, const _xpc_type_s *a2, const _xpc_type_s *a3)
{
  uint64_t v6;
  const _xpc_type_s *v7;
  NSObject *v8;
  const char *v9;
  uint32_t v10;
  const _xpc_type_s *v11;
  const _xpc_type_s *v12;
  _BOOL4 v13;
  int v15;
  const _xpc_type_s *v16;
  __int16 v17;
  const char *name;
  __int16 v19;
  const _xpc_type_s *v20;
  __int16 v21;
  const char *v22;
  uint64_t v23;

  v23 = *MEMORY[0x1E0C80C00];
  v6 = MEMORY[0x1BCCB1B14](a2);
  v7 = (const _xpc_type_s *)v6;
  if ((const _xpc_type_s *)v6 != a3)
  {
    if (v6 == MEMORY[0x1E0C81310])
    {
      v11 = (const _xpc_type_s *)MEMORY[0x1E0C81258];
      if (a2 == (const _xpc_type_s *)MEMORY[0x1E0C81258])
      {
        if (!os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
          return v7 == a3;
        v15 = 134218240;
        v16 = v11;
        v17 = 2048;
        name = a1;
        v8 = MEMORY[0x1E0C81028];
        v9 = "### Connection interrupted %p %p";
      }
      else
      {
        v12 = (const _xpc_type_s *)MEMORY[0x1E0C81260];
        v13 = os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT);
        if (a2 == v12)
        {
          if (!v13)
            return v7 == a3;
          v15 = 134218240;
          v16 = v12;
          v17 = 2048;
          name = a1;
          v8 = MEMORY[0x1E0C81028];
          v9 = "### Connection invalid %p %p";
        }
        else
        {
          if (!v13)
            return v7 == a3;
          v15 = 134218240;
          v16 = a2;
          v17 = 2048;
          name = a1;
          v8 = MEMORY[0x1E0C81028];
          v9 = "### Connection error %p %p";
        }
      }
      v10 = 22;
      goto LABEL_14;
    }
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_DEFAULT))
    {
      v15 = 134218754;
      v16 = v7;
      v17 = 2080;
      name = xpc_type_get_name(v7);
      v19 = 2048;
      v20 = a3;
      v21 = 2080;
      v22 = xpc_type_get_name(a3);
      v8 = MEMORY[0x1E0C81028];
      v9 = "### Connection type %p %s not %p %s";
      v10 = 42;
LABEL_14:
      _os_log_impl(&dword_1B8270000, v8, OS_LOG_TYPE_DEFAULT, v9, (uint8_t *)&v15, v10);
    }
  }
  return v7 == a3;
}

void __si_xpc_setup_connection_block_invoke_2(int a1, xpc_object_t xdict)
{
  _xpc_connection_s *remote_connection;
  NSObject *reply;
  NSObject *v5;

  remote_connection = xpc_dictionary_get_remote_connection(xdict);
  if (is_valid_xpc_type((const char *)remote_connection, (const _xpc_type_s *)xdict, MEMORY[0x1E0C812F8]))
  {
    xpc_dictionary_get_string(xdict, "command");
    if (remote_connection)
    {
      reply = xpc_dictionary_create_reply(xdict);
      if (reply)
      {
        v5 = reply;
        xpc_dictionary_set_int64(reply, "status", -1);
        xpc_connection_send_message(remote_connection, v5);
        dispatch_release(v5);
      }
    }
  }
}

uint64_t __si_xpc_send_msg_block_invoke(uint64_t a1, void *a2)
{
  int64_t int64;
  uint64_t result;

  if (is_valid_xpc_type(*(const char **)(a1 + 40), (const _xpc_type_s *)a2, MEMORY[0x1E0C812F8]))
    int64 = xpc_dictionary_get_int64(a2, "status");
  else
    int64 = -1;
  result = *(_QWORD *)(a1 + 32);
  if (result)
    return (*(uint64_t (**)(uint64_t, void *, int64_t))(result + 16))(result, a2, int64);
  return result;
}

uint64_t si_xpc_send_client_msg(void *a1, uint64_t a2)
{
  NSObject *v4;
  NSObject *v5;
  uint64_t v6;
  _xpc_connection_s *v7;
  BOOL v8;
  uint64_t v9;
  _QWORD block[6];
  int v12;
  char __str[16];
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v4 = qword_1EF1ACE98;
  if (!qword_1EF1ACE98)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&si_retain_service_connection_s_service_queue_lock);
    if (!qword_1EF1ACE98)
    {
      v27 = 0u;
      v28 = 0u;
      v25 = 0u;
      v26 = 0u;
      v23 = 0u;
      v24 = 0u;
      v21 = 0u;
      v22 = 0u;
      v19 = 0u;
      v20 = 0u;
      v18 = 0u;
      v16 = 0u;
      v17 = 0u;
      v14 = 0u;
      v15 = 0u;
      *(_OWORD *)__str = 0u;
      snprintf(__str, 0x100uLL, "%s.xpc.client.queue", "com.apple.spotlightknowledged");
      v5 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
      qword_1EF1ACE98 = (uint64_t)dispatch_queue_create(__str, v5);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&si_retain_service_connection_s_service_queue_lock);
    v4 = qword_1EF1ACE98;
    if (!qword_1EF1ACE98)
      return 0;
  }
  *(_QWORD *)__str = 0;
  *(_QWORD *)&__str[8] = __str;
  v14 = 0x2000000000uLL;
  v6 = MEMORY[0x1E0C809B0];
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = __si_retain_service_connection_block_invoke;
  block[3] = &unk_1E6E2F378;
  v12 = 3;
  block[4] = __str;
  block[5] = "com.apple.spotlightknowledged";
  dispatch_sync(v4, block);
  v7 = *(_xpc_connection_s **)(*(_QWORD *)&__str[8] + 24);
  _Block_object_dispose(__str, 8);
  if (!v7)
    return 0;
  if (qword_1EF1ACE98)
    v8 = a1 == 0;
  else
    v8 = 1;
  v9 = !v8;
  if (!v8)
  {
    *(_QWORD *)__str = v6;
    *(_QWORD *)&__str[8] = 0x40000000;
    *(_QWORD *)&v14 = __si_xpc_send_msg_block_invoke;
    *((_QWORD *)&v14 + 1) = &unk_1E6E2F3A0;
    *(_QWORD *)&v15 = a2;
    *((_QWORD *)&v15 + 1) = v7;
    xpc_connection_send_message_with_reply(v7, a1, (dispatch_queue_t)qword_1EF1ACE98, __str);
  }
  CFRelease(v7);
  return v9;
}

uint64_t _TermUpdateSetLock(uint64_t a1, int a2)
{
  pthread_mutex_t *v2;
  unsigned int v4;
  unint64_t v5;
  signed int v6;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;

  v2 = (pthread_mutex_t *)(a1 + 304);
  if (!a2)
    return db_read_lock(a1 + 304);
  HIDWORD(v5) = qos_class_self() - 9;
  LODWORD(v5) = HIDWORD(v5);
  v4 = v5 >> 2;
  if (v4 > 6)
    v6 = 0;
  else
    v6 = dword_1B8630ED0[v4];
  pthread_mutex_lock(v2);
  if (*(_QWORD *)(a1 + 488) || *(_DWORD *)(a1 + 500) || *(_BYTE *)(a1 + 516))
    goto LABEL_9;
  if (v6 > 5)
  {
LABEL_17:
    *(_QWORD *)(a1 + 488) = pthread_self();
    return pthread_mutex_unlock(v2);
  }
  if (!*(_QWORD *)(a1 + 16 * v6 + 368))
  {
    v8 = v6 - 1;
    v9 = (uint64_t *)(a1 + 16 * v6 + 384);
    while (v8 != 4)
    {
      v10 = *v9;
      v9 += 2;
      ++v8;
      if (v10)
      {
        if (v8 <= 4)
          goto LABEL_9;
        goto LABEL_17;
      }
    }
    goto LABEL_17;
  }
LABEL_9:
  db_rwlock_wait((uint64_t)v2, v6, 2);
  return pthread_mutex_unlock(v2);
}

uint64_t _TermUpdateSetUnlock(uint64_t a1)
{
  pthread_mutex_t *v2;
  pthread_override_s *v3;
  char v4;
  uint64_t result;

  v2 = (pthread_mutex_t *)(a1 + 304);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 304));
  *(_DWORD *)(a1 + 508) = 0;
  v3 = *(pthread_override_s **)(a1 + 480);
  *(_QWORD *)(a1 + 480) = 0;
  *(_QWORD *)(a1 + 488) = 0;
  v4 = *(_DWORD *)(a1 + 500) != 0;
  *(_BYTE *)(a1 + 516) = 0;
  db_rwlock_wakeup((uint64_t)v2, v4, 0);
  result = pthread_mutex_unlock(v2);
  if (v3)
    return pthread_override_qos_class_end_np(v3);
  return result;
}

_QWORD *TermUpdateSetSetVectorStore(_QWORD *result, uint64_t a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  BOOL v7;

  if (result)
  {
    result[6] = a2;
    v3 = (_QWORD *)*result;
    v4 = result + 1;
    if ((_QWORD *)*result != result + 1)
    {
      do
      {
        result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t))(*(_QWORD *)v3[5] + 288))(v3[5], a2);
        v5 = (_QWORD *)v3[1];
        if (v5)
        {
          do
          {
            v6 = v5;
            v5 = (_QWORD *)*v5;
          }
          while (v5);
        }
        else
        {
          do
          {
            v6 = (_QWORD *)v3[2];
            v7 = *v6 == (_QWORD)v3;
            v3 = v6;
          }
          while (!v7);
        }
        v3 = v6;
      }
      while (v6 != v4);
    }
  }
  return result;
}

uint64_t storeUpdateSetCallback(uint64_t a1, uint64_t *a2)
{
  size_t v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  size_t v8;
  size_t v9;

  v4 = *(unsigned __int16 *)(a1 + 16);
  v5 = (char *)(a1 + 18);
  ++*((_DWORD *)a2 + 8);
  store_stream_write_vint32_2186((_QWORD *)*a2, v4);
  v6 = *a2;
  while (1)
  {
    v8 = *(_QWORD *)(v6 + 32);
    v7 = *(_QWORD *)(v6 + 40);
    if (v7 + v4 < v8)
      break;
    v9 = v8 - v7;
    memcpy((void *)(*(_QWORD *)(v6 + 48) + v7), v5, v8 - v7);
    *(_QWORD *)(v6 + 40) += v9;
    if (store_stream_flush((unsigned int *)v6, 0))
      return CIWritePostings(*a2, a2[1], (uint64_t *)a2[2], (unsigned int *)a1, *(_DWORD *)(a1 + 12), *((_DWORD *)a2 + 9));
    v5 += v9;
    v4 -= v9;
  }
  memcpy((void *)(*(_QWORD *)(v6 + 48) + v7), v5, v4);
  *(_QWORD *)(v6 + 40) += v4;
  return CIWritePostings(*a2, a2[1], (uint64_t *)a2[2], (unsigned int *)a1, *(_DWORD *)(a1 + 12), *((_DWORD *)a2 + 9));
}

uint64_t ___hashTableIterate_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = (*(uint64_t (**)(uint64_t, _QWORD))(a1 + 40))(a2 + 16, *(_QWORD *)(a1 + 48));
  ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t TermUpdateSetRestore(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, __int16 a10, const void *a11)
{
  uint64_t v11;
  char v12;
  char v13;
  unsigned int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t (*v23)();
  uint64_t (*v24)();
  unsigned int *v25;
  double Current;
  char *v27;
  unsigned int vint32_2297;
  unsigned int v29;
  int v30;
  NSObject *v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  char v36;
  BOOL v37;
  unsigned int v38;
  unsigned int v39;
  unsigned int v40;
  unsigned int v41;
  int v42;
  unsigned int v43;
  unsigned int v44;
  size_t v45;
  void *v46;
  unint64_t v47;
  int v48;
  unsigned int *v49;
  unsigned int v50;
  unsigned int v51;
  size_t v52;
  size_t v53;
  size_t v54;
  char *v55;
  unint64_t v56;
  unsigned int v57;
  uint64_t v58;
  char v59;
  char *v60;
  uint64_t v61;
  char v62;
  uint64_t v63;
  _BYTE *v64;
  unsigned int v65;
  unint64_t v66;
  unsigned int v67;
  unint64_t v68;
  int v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  unint64_t v74;
  char v75;
  unint64_t v76;
  unint64_t v77;
  uint64_t v78;
  int v79;
  int v80;
  int v81;
  char *v82;
  unsigned int v83;
  unsigned int v84;
  uint64_t v85;
  uint64_t v86;
  void *v87;
  uint64_t *v88;
  uint64_t v89;
  uint64_t v90;
  _DWORD *v91;
  int v92;
  unint64_t v93;
  uint64_t v94;
  uint64_t v95;
  _QWORD *v96;
  unint64_t v97;
  int v98;
  int v99;
  uint64_t v100;
  uint64_t v101;
  int v102;
  uint64_t v103;
  size_t v104;
  uint64_t v105;
  size_t v106;
  _BYTE *v107;
  size_t v108;
  void *v109;
  off_t v110;
  _BYTE *v111;
  unint64_t v112;
  unsigned int v113;
  int v114;
  uint64_t v115;
  unint64_t VInt64_1804;
  unsigned int v117;
  uint64_t v118;
  uint64_t v119;
  unint64_t v120;
  unint64_t v121;
  int v122;
  unsigned int *v123;
  uint64_t v124;
  unsigned int v125;
  unsigned int v126;
  _DWORD *v127;
  char *v128;
  size_t v129;
  uint64_t v130;
  size_t v131;
  char *v132;
  size_t v133;
  size_t v134;
  uint64_t v135;
  char *v136;
  unsigned int *v137;
  unsigned int v138;
  int v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  unsigned int v143;
  int v144;
  unint64_t v145;
  size_t v146;
  size_t v147;
  void *v148;
  unint64_t v149;
  void *v150;
  size_t v151;
  unint64_t v152;
  size_t v153;
  off_t v154;
  size_t bytes_2300;
  char v156;
  char v157;
  void *v158;
  unint64_t v159;
  int v160;
  NSObject *v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  _QWORD *v165;
  _QWORD **v166;
  int vint32;
  int i;
  uint64_t v169;
  int v170;
  int v171;
  uint64_t v172;
  __int128 v173;
  uint64_t VectorIndexInstance;
  int v175;
  NSObject *v176;
  os_log_type_t v177;
  _BYTE *v178;
  uint64_t *v179;
  unint64_t v180;
  uint64_t **v181;
  uint64_t *v182;
  uint64_t **v183;
  unint64_t v184;
  uint64_t *v185;
  uint64_t v186;
  uint64_t *v187;
  std::__shared_weak_count *v188;
  unint64_t *p_shared_owners;
  unint64_t v190;
  int v191;
  NSObject *v192;
  unsigned int v193;
  const char *v194;
  NSObject *v195;
  uint32_t v196;
  NSObject *v197;
  int v198;
  NSObject *v199;
  os_log_type_t v200;
  int v201;
  NSObject *v202;
  os_log_type_t v203;
  unsigned int v204;
  int v205;
  unsigned int v206;
  CFAbsoluteTime v207;
  unint64_t v208;
  unint64_t v209;
  NSObject *v210;
  NSObject *v212;
  uint64_t v213;
  int v214;
  NSObject *v215;
  unsigned int v216;
  NSObject *v217;
  int v218;
  int v219;
  char *v220;
  char *v221;
  const char *v222;
  uint64_t v223;
  int v224;
  int v225;
  NSObject *v226;
  char *v227;
  const char *v228;
  char *v229;
  char *v230;
  const char *v231;
  char *v232;
  const char *v233;
  void *v234;
  off_t v235;
  unint64_t __n;
  size_t v237;
  size_t v238;
  unint64_t v239;
  uint64_t v240;
  char v241;
  uint64_t v242;
  unsigned int *v243;
  int v244;
  unsigned int v245;
  size_t v246;
  size_t v247;
  int v248;
  _QWORD *v249;
  unint64_t v250;
  unint64_t v251;
  unint64_t v252;
  unsigned int v253;
  int v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  uint64_t *v258;
  malloc_zone_t *v259;
  unsigned int v260;
  int v261;
  unsigned int v262;
  int v263;
  _OWORD *v264;
  void **v265;
  unsigned int v266;
  _QWORD **v267;
  uint64_t v268;
  char *v269;
  void *__p;
  char v271;
  _BYTE v272[32];
  int v273;
  _OWORD __dst[2];
  __int128 v275;
  __int128 v276;
  uint64_t v277;
  _BYTE v278[12];
  __int16 v279;
  int v280;
  char v281;
  uint8_t buf[4];
  uint64_t v283;
  __int16 v284;
  _BYTE *v285;
  uint64_t v286;

  v11 = MEMORY[0x1E0C80A78](a1);
  v13 = v12;
  v266 = v14;
  v16 = v15;
  v18 = v17;
  v20 = v19;
  v22 = v21;
  v24 = v23;
  v25 = (unsigned int *)v11;
  v286 = *MEMORY[0x1E0C80C00];
  Current = CFAbsoluteTimeGetCurrent();
  v27 = TermUpdateSetCreate(v24, v22, 0, 0, v16 | 4u, a9, a10, a11);
  vint32_2297 = store_stream_read_vint32_2297((uint64_t)v25);
  v29 = vint32_2297;
  if ((v13 & 1) != 0)
  {
    if (vint32_2297 != 11)
      goto LABEL_3;
  }
  else if (vint32_2297 - 7 >= 5)
  {
LABEL_3:
    v30 = *__error();
    v31 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
    {
      LODWORD(__dst[0]) = 136316162;
      *(_QWORD *)((char *)__dst + 4) = "TermUpdateSetRestore";
      WORD6(__dst[0]) = 1024;
      *(_DWORD *)((char *)__dst + 14) = 954;
      WORD1(__dst[1]) = 1024;
      DWORD1(__dst[1]) = v29;
      WORD4(__dst[1]) = 1024;
      *(_DWORD *)((char *)&__dst[1] + 10) = 8;
      HIWORD(__dst[1]) = 1024;
      LODWORD(v275) = 7;
      _os_log_error_impl(&dword_1B8270000, v31, OS_LOG_TYPE_ERROR, "%s:%d: invalid store version %d, expected %d or %d", (uint8_t *)__dst, 0x24u);
    }
    *__error() = v30;
    if (v27)
      goto LABEL_277;
    return 0;
  }
  v254 = store_stream_read_vint32_2297((uint64_t)v25);
  *((_DWORD *)v27 + 28) = store_stream_read_vint32_2297((uint64_t)v25);
  v33 = (uint64_t *)(v25 + 10);
  v32 = *((_QWORD *)v25 + 5);
  if ((unint64_t)(*((_QWORD *)v25 + 4) - v32) < 0xB)
  {
    v219 = 0;
    v35 = 0;
    LOBYTE(__dst[0]) = 0;
    while (store_stream_read_bytes_2300(v25, (char *)__dst, 1uLL) == 1)
    {
      v35 |= (unint64_t)(__dst[0] & 0x7F) << v219;
      v219 += 7;
      if ((__dst[0] & 0x80) == 0)
        goto LABEL_14;
    }
    v35 = 0;
  }
  else
  {
    v34 = 0;
    v35 = 0;
    do
    {
      v36 = *(_BYTE *)(*((_QWORD *)v25 + 6) + v32++);
      v35 |= (unint64_t)(v36 & 0x7F) << v34;
      if ((v36 & 0x80) == 0)
        break;
      v37 = v34 == 63;
      v34 += 7;
    }
    while (!v37);
    *v33 = v32;
  }
LABEL_14:
  *((_QWORD *)v27 + 1) = v35;
  *((_DWORD *)v27 + 4) = store_stream_read_vint32_2297((uint64_t)v25);
  v38 = store_stream_read_vint32_2297((uint64_t)v25);
  if (v29 < 9)
  {
    *((_QWORD *)v27 + 15) = v38;
    *((_QWORD *)v27 + 16) = store_stream_read_vint32_2297((uint64_t)v25);
    if (v29 == 8)
    {
      *((_QWORD *)v27 + 17) = store_stream_read_vint32_2297((uint64_t)v25);
      *((_QWORD *)v27 + 24) = store_stream_read_vint32_2297((uint64_t)v25);
    }
  }
  else
  {
    *((_QWORD *)v27 + 21) = v38;
    *((_QWORD *)v27 + 18) = store_stream_read_vint32_2297((uint64_t)v25);
    *((_QWORD *)v27 + 15) = store_stream_read_vint32_2297((uint64_t)v25);
    *((_QWORD *)v27 + 22) = store_stream_read_vint32_2297((uint64_t)v25);
    *((_QWORD *)v27 + 19) = store_stream_read_vint32_2297((uint64_t)v25);
    *((_QWORD *)v27 + 16) = store_stream_read_vint32_2297((uint64_t)v25);
    *((_QWORD *)v27 + 27) = store_stream_read_vint32_2297((uint64_t)v25);
    *((_QWORD *)v27 + 26) = store_stream_read_vint32_2297((uint64_t)v25);
    *((_QWORD *)v27 + 17) = store_stream_read_vint32_2297((uint64_t)v25);
    *((_QWORD *)v27 + 24) = store_stream_read_vint32_2297((uint64_t)v25);
    if (v29 != 9)
      *((_QWORD *)v27 + 25) = store_stream_read_vint32_2297((uint64_t)v25);
  }
  if (!*((_DWORD *)v27 + 28) && !*((_QWORD *)v27 + 1) && !*((_DWORD *)v27 + 4))
  {
    *((_QWORD *)v27 + 1) = v20;
    *((_DWORD *)v27 + 4) = v18;
  }
  v265 = (void **)(v27 + 88);
  if ((restoreDirStoreUpdateSet((unsigned int *)v27 + 22, (__int128 *)v27 + 3, v25) & 1) == 0)
  {
    v160 = *__error();
    v161 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v161, OS_LOG_TYPE_ERROR))
    {
      LODWORD(__dst[0]) = 136315394;
      *(_QWORD *)((char *)__dst + 4) = "TermUpdateSetRestore";
      WORD6(__dst[0]) = 1024;
      *(_DWORD *)((char *)__dst + 14) = 999;
      _os_log_error_impl(&dword_1B8270000, v161, OS_LOG_TYPE_ERROR, "%s:%d: Failed restoring update set for paths", (uint8_t *)__dst, 0x12u);
    }
    *__error() = v160;
    if (!v25[4])
      v25[4] = -1;
    goto LABEL_277;
  }
  bzero(__dst, 0x1000uLL);
  v258 = (uint64_t *)(v27 + 240);
  v243 = (unsigned int *)(v27 + 248);
  v39 = atomic_load((unsigned int *)v27 + 62);
  v40 = v39 + v254;
  v41 = *((_DWORD *)v27 + 63);
  if (v40 >= v41)
  {
    do
    {
      if (v41)
        v42 = 2 * v41;
      else
        v42 = 0x10000;
      *((_DWORD *)v27 + 63) = v42;
      v43 = atomic_load((unsigned int *)v27 + 62);
      v44 = v43 + v254;
      v41 = *((_DWORD *)v27 + 63);
    }
    while (v44 >= v41);
  }
  v45 = 32 * v41;
  v46 = mmap(0, v45, 3, 4098, -167772160, 0);
  *v258 = (uint64_t)v46;
  if (v46 == (void *)-1)
  {
    v232 = __si_assert_copy_extra_268();
    v230 = v232;
    v233 = "";
    if (v232)
      v233 = v232;
    __message_assert("%s:%u: failed assertion '%s' %s ", "TermUpdateSet.c", 1016, "kr == 0", v233);
LABEL_324:
    free(v230);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  do
    v47 = __ldxr(&qword_1EDBBE0A0);
  while (__stxr(v47 + v45, &qword_1EDBBE0A0));
  if (!v46)
  {
    v220 = __si_assert_copy_extra_268();
    v221 = v220;
    v222 = "";
    if (v220)
      v222 = v220;
    __message_assert("%s:%u: failed assertion '%s' %s ", "TermUpdateSet.c", 1018, "positions->node_table", v222);
    goto LABEL_306;
  }
  v269 = v27;
  if (!v254)
  {
LABEL_223:
    v162 = (uint64_t)v269;
    if (_os_feature_enabled_impl())
    {
      v163 = *((_QWORD *)v269 + 10);
      if (v163)
        freeVectorUpdates(v163);
      v164 = operator new();
      v165 = 0;
      *(_QWORD *)(v164 + 8) = 0;
      v166 = (_QWORD **)(v164 + 8);
      *(_QWORD *)(v164 + 16) = 0;
      *(_QWORD *)v164 = v164 + 8;
      *(_WORD *)(v164 + 24) = a10;
      v264 = (_OWORD *)(v164 + 24);
      *(_OWORD *)(v164 + 28) = xmmword_1B8631CE0;
      *(_QWORD *)(v164 + 48) = a9;
      v267 = (_QWORD **)(v164 + 8);
      v268 = v164;
      if (dword_1EF19FCCC >= 5)
      {
        v225 = *__error();
        v226 = _SILogForLogForCategory(16);
        if (os_log_type_enabled(v226, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)v272 = 134217984;
          *(_QWORD *)&v272[4] = v268;
          _os_log_impl(&dword_1B8270000, v226, OS_LOG_TYPE_DEFAULT, "Create <UpdateSet> %p", v272, 0xCu);
        }
        *__error() = v225;
        v166 = v267;
        v164 = v268;
        v165 = *v267;
        v162 = (uint64_t)v269;
      }
      std::__tree<std::__value_type<unsigned long long,std::shared_ptr<AnyVectorIndexInstance>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<AnyVectorIndexInstance>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<AnyVectorIndexInstance>>>>::destroy(v165);
      *(_QWORD *)(v164 + 8) = 0;
      *(_QWORD *)(v164 + 16) = 0;
      *(_QWORD *)v164 = v166;
      vint32 = store_stream_read_vint32((uint64_t)v25);
      v259 = malloc_default_zone();
      v261 = vint32;
      if (vint32)
      {
        for (i = 0; i != v261; ++i)
        {
          v169 = store_stream_read_vint32((uint64_t)v25);
          v170 = store_stream_read_vint32((uint64_t)v25);
          v171 = store_stream_read_vint32((uint64_t)v25);
          v172 = (unsigned __int16)store_stream_read_vint32((uint64_t)v25);
          if (v172 <= 3)
          {
            v198 = *__error();
            v199 = _SILogForLogForCategory(16);
            v200 = 2 * (dword_1EF19FCCC < 4);
            if (os_log_type_enabled(v199, v200))
            {
              *(_DWORD *)v278 = 134218240;
              *(_QWORD *)&v278[4] = v268;
              v279 = 1024;
              v280 = v172;
              _os_log_impl(&dword_1B8270000, v199, v200, "Restore <UpdateSet> %p that is not compatible vecVersion=%u", v278, 0x12u);
            }
            *__error() = v198;
            v164 = v268;
            std::__tree<std::__value_type<unsigned long long,std::shared_ptr<AnyVectorIndexInstance>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<AnyVectorIndexInstance>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<AnyVectorIndexInstance>>>>::destroy(*(_QWORD **)(v268 + 8));
            *(_QWORD *)(v268 + 8) = 0;
            *(_QWORD *)(v268 + 16) = 0;
            *(_QWORD *)v268 = v267;
            v162 = (uint64_t)v269;
            break;
          }
          v173 = v264[1];
          *(_OWORD *)v272 = *v264;
          *(_OWORD *)&v272[16] = v173;
          VectorIndexInstance = IVFVectorIndexen<vi_onefixedsize_memory_allocator,vi_memory_postings>::createVectorIndexInstance(v169, v172, v171, v170, v259, 0, (__int16 *)v272);
          (*(void (**)(uint64_t, void **, unsigned int *))(*(_QWORD *)VectorIndexInstance + 216))(VectorIndexInstance, v265, v25);
          v175 = *__error();
          v176 = _SILogForLogForCategory(16);
          v177 = 2 * (dword_1EF19FCCC < 4);
          if (os_log_type_enabled(v176, v177))
          {
            v271 = 3;
            LODWORD(__p) = 4085052;
            (*(void (**)(_BYTE *__return_ptr, uint64_t, void **))(*(_QWORD *)VectorIndexInstance + 312))(v278, VectorIndexInstance, &__p);
            v178 = v278;
            if (v281 < 0)
              v178 = *(_BYTE **)v278;
            *(_DWORD *)buf = 134218242;
            v283 = v268;
            v284 = 2080;
            v285 = v178;
            _os_log_impl(&dword_1B8270000, v176, v177, "restore <UpdateSet> %p %s", buf, 0x16u);
            if (v281 < 0)
            {
              operator delete(*(void **)v278);
              if (v271 < 0)
LABEL_253:
                operator delete(__p);
            }
            else if (v271 < 0)
            {
              goto LABEL_253;
            }
          }
          *__error() = v175;
          v179 = (uint64_t *)operator new();
          *v179 = (uint64_t)&off_1E6E30970;
          v179[1] = 0;
          v179[2] = 0;
          v179[3] = VectorIndexInstance;
          v180 = 2
               * (((unint64_t)(v170 & 3) << 48) | ((unint64_t)(v171 & 3) << 50) | (v172 << 32) | v169);
          v181 = v267;
          v182 = *v267;
          v183 = v267;
          v162 = (uint64_t)v269;
          if (*v267)
          {
            while (1)
            {
              while (1)
              {
                v181 = (uint64_t **)v182;
                v184 = v182[4];
                if (v180 >= v184)
                  break;
                v182 = *v181;
                v183 = v181;
                if (!*v181)
                  goto LABEL_243;
              }
              if (v184 >= v180)
                break;
              v182 = v181[1];
              if (!v182)
              {
                v183 = v181 + 1;
                goto LABEL_243;
              }
            }
            v164 = v268;
          }
          else
          {
LABEL_243:
            v185 = (uint64_t *)v181;
            v181 = (uint64_t **)operator new(0x38uLL);
            v181[5] = 0;
            v181[6] = 0;
            v181[4] = (uint64_t *)v180;
            *v181 = 0;
            v181[1] = 0;
            v181[2] = v185;
            *v183 = (uint64_t *)v181;
            v164 = v268;
            v186 = **(_QWORD **)v268;
            v187 = (uint64_t *)v181;
            if (v186)
            {
              *(_QWORD *)v268 = v186;
              v187 = *v183;
            }
            std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v268 + 8), v187);
            ++*(_QWORD *)(v268 + 16);
          }
          v188 = (std::__shared_weak_count *)v181[6];
          v181[5] = (uint64_t *)VectorIndexInstance;
          v181[6] = v179;
          if (v188)
          {
            p_shared_owners = (unint64_t *)&v188->__shared_owners_;
            do
              v190 = __ldaxr(p_shared_owners);
            while (__stlxr(v190 - 1, p_shared_owners));
            if (!v190)
            {
              ((void (*)(std::__shared_weak_count *))v188->__on_zero_shared)(v188);
              std::__shared_weak_count::__release_weak(v188);
            }
          }
        }
      }
      *(_QWORD *)(v162 + 80) = v164;
    }
    v201 = *__error();
    v202 = _SILogForLogForCategory(10);
    v203 = 2 * (dword_1EF19FCB4 < 4);
    if (os_log_type_enabled(v202, v203))
    {
      v204 = atomic_load((unsigned int *)(*(_QWORD *)(v162 + 24) + 16));
      v205 = *(_DWORD *)(v162 + 112);
      v206 = atomic_load((unsigned int *)(v162 + 100));
      v207 = CFAbsoluteTimeGetCurrent();
      LODWORD(__dst[0]) = 67109888;
      DWORD1(__dst[0]) = v204;
      WORD4(__dst[0]) = 1024;
      *(_DWORD *)((char *)__dst + 10) = v205;
      HIWORD(__dst[0]) = 1024;
      LODWORD(__dst[1]) = v206;
      WORD2(__dst[1]) = 2048;
      *(double *)((char *)&__dst[1] + 6) = v207 - Current;
      _os_log_impl(&dword_1B8270000, v202, v203, "Restore Update Set (t %d, d %d, p %d) took %f seconds", (uint8_t *)__dst, 0x1Eu);
    }
    *__error() = v201;
    if ((*(_BYTE *)(v162 + 616) & 2) != 0)
      return v162;
    v277 = 0;
    v275 = 0u;
    v276 = 0u;
    memset(__dst, 0, sizeof(__dst));
    _TermUpdateSetGetStats(v162, (uint64_t)__dst, 1);
    v208 = *(_QWORD *)&__dst[1] + v275 + *(_QWORD *)&__dst[0];
    if (v208 <= 0xFFFFFFFE)
    {
      do
        v209 = __ldaxr(&gTotalCurrentUsage);
      while (__stlxr(v209 + v208, &gTotalCurrentUsage));
      *(_QWORD *)(v162 + 224) = *(_QWORD *)&__dst[1] + v275 + *(_QWORD *)&__dst[0];
      return v162;
    }
    v227 = __si_assert_copy_extra_268();
    v221 = v227;
    v228 = "";
    if (v227)
      v228 = v227;
    __message_assert("%s:%u: failed assertion '%s' %s ", "TermUpdateSet.c", 1259, "(stats.positionInfoUsed+stats.postingInfoUsed+stats.termInfoUsed) < 4294967295U", v228);
LABEL_306:
    free(v221);
    if (__valid_fs(-1))
      v223 = 2989;
    else
      v223 = 3072;
    *(_DWORD *)v223 = -559038737;
    abort();
  }
  v48 = 0;
  v49 = (unsigned int *)(v27 + 100);
  v255 = 4 * (v29 != 11);
  while (1)
  {
    if (v25[4])
      goto LABEL_276;
    v244 = v48;
    v50 = store_stream_read_vint32_2297((uint64_t)v25);
    v51 = v50;
    if (v50 - 4097 <= 0xFFFFEFFF)
    {
      v191 = *__error();
      v217 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v217, OS_LOG_TYPE_ERROR))
        goto LABEL_275;
      *(_DWORD *)v272 = 136315650;
      *(_QWORD *)&v272[4] = "TermUpdateSetRestore";
      *(_WORD *)&v272[12] = 1024;
      *(_DWORD *)&v272[14] = 1030;
      *(_WORD *)&v272[18] = 1024;
      *(_DWORD *)&v272[20] = v51;
      v194 = "%s:%d: invalid termLen %d";
LABEL_301:
      v195 = v217;
LABEL_257:
      v196 = 24;
      goto LABEL_263;
    }
    v262 = v50;
    v52 = v50;
    v53 = *((_QWORD *)v25 + 4);
    v54 = *((_QWORD *)v25 + 5);
    if (v54 + v50 <= v53)
    {
      v55 = (char *)__dst;
      v56 = v50;
LABEL_38:
      memcpy(v55, (const void *)(*((_QWORD *)v25 + 6) + v54), v52);
      *((_QWORD *)v25 + 5) = v54 + v52;
      goto LABEL_39;
    }
    v56 = v50;
    v150 = (void *)*((_QWORD *)v25 + 6);
    v151 = v53 - v54;
    if (v53 != v54)
    {
      __memcpy_chk();
      *v33 = v53;
      v54 = v53;
    }
    v152 = prot_pread(*v25, v150, v54, *((_QWORD *)v25 + 3));
    if (v152 != -1)
    {
      v153 = v152;
      *((_QWORD *)v25 + 4) = v152;
      *((_QWORD *)v25 + 5) = 0;
      v154 = *((_QWORD *)v25 + 3) + v152;
      *((_QWORD *)v25 + 3) = v154;
      v57 = v262;
      if (!v152)
        goto LABEL_40;
      v55 = (char *)__dst + v151;
      v52 = v56 - v151;
      if (v52 <= v152)
      {
        v54 = 0;
        v33 = (uint64_t *)(v25 + 10);
        goto LABEL_38;
      }
      v33 = (uint64_t *)(v25 + 10);
      while (1)
      {
        v158 = (void *)*((_QWORD *)v25 + 6);
        memcpy(v55, v158, v153);
        *((_QWORD *)v25 + 5) = v153;
        v159 = prot_pread(*v25, v158, v153, v154);
        if (v159 == -1)
          break;
        *((_QWORD *)v25 + 4) = v159;
        *((_QWORD *)v25 + 5) = 0;
        v154 = *((_QWORD *)v25 + 3) + v159;
        *((_QWORD *)v25 + 3) = v154;
        if (!v159)
          goto LABEL_39;
        v54 = 0;
        v55 += v153;
        v52 -= v153;
        v153 = v159;
        if (v52 <= v159)
          goto LABEL_38;
      }
    }
    v25[4] = *__error();
LABEL_39:
    v57 = v262;
    if (!v262)
    {
      v59 = 1;
      goto LABEL_49;
    }
LABEL_40:
    if (v57 >= 2)
    {
      v58 = v56 & 0xFFFFFFFE;
      v60 = (char *)__dst + 1;
      v61 = v58;
      do
      {
        v62 = tcmr[*v60];
        *(v60 - 1) = tcmr[*(v60 - 1)];
        *v60 = v62;
        v60 += 2;
        v61 -= 2;
      }
      while (v61);
      if (v58 == v56)
        goto LABEL_48;
    }
    else
    {
      v58 = 0;
    }
    v63 = v56 - v58;
    v64 = (char *)__dst + v58;
    do
    {
      *v64 = tcmr[*v64];
      ++v64;
      --v63;
    }
    while (v63);
LABEL_48:
    v59 = 0;
LABEL_49:
    *((_BYTE *)__dst + v56) = 0;
    v65 = store_stream_read_vint32_2297((uint64_t)v25);
    v66 = *((_QWORD *)v25 + 4);
    v260 = v65;
    if (v66 < v65)
    {
      v191 = *__error();
      v210 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v210, OS_LOG_TYPE_ERROR))
        goto LABEL_275;
      v213 = *((_QWORD *)v25 + 4);
      *(_DWORD *)v272 = 136315906;
      *(_QWORD *)&v272[4] = "TermUpdateSetRestore";
      *(_WORD *)&v272[12] = 1024;
      *(_DWORD *)&v272[14] = 1045;
      *(_WORD *)&v272[18] = 1024;
      *(_DWORD *)&v272[20] = v260;
      *(_WORD *)&v272[24] = 1024;
      *(_DWORD *)&v272[26] = v213;
      v194 = "%s:%d: invalid  postingCount %u > %u";
      v195 = v210;
LABEL_283:
      v196 = 30;
      goto LABEL_263;
    }
    v67 = v65;
    if (v65)
    {
      v241 = v59;
      v68 = 0;
      v69 = 0;
      v70 = 0;
      v71 = 0;
      v256 = 0;
      v237 = v56 - 1;
      v239 = v56;
      while (1)
      {
        v72 = *((_QWORD *)v25 + 5);
        if ((unint64_t)(*((_QWORD *)v25 + 4) - v72) >= 0xB)
        {
          v73 = 0;
          v74 = 0;
          do
          {
            v75 = *(_BYTE *)(*((_QWORD *)v25 + 6) + v72++);
            v74 |= (unint64_t)(v75 & 0x7F) << v73;
            if ((v75 & 0x80) == 0)
              break;
            v37 = v73 == 63;
            v73 += 7;
          }
          while (!v37);
          *v33 = v72;
          if (v25[4])
            goto LABEL_254;
          goto LABEL_58;
        }
        v102 = 0;
        v74 = 0;
        v272[0] = 0;
        v251 = v68;
        while (1)
        {
          v104 = *((_QWORD *)v25 + 4);
          v103 = *((_QWORD *)v25 + 5);
          v105 = v70;
          if (v103 + 1 <= v104)
          {
            v106 = 0;
            v107 = v272;
            v108 = 1;
LABEL_99:
            memcpy(v107, (const void *)(*((_QWORD *)v25 + 6) + v103), v108);
            *((_QWORD *)v25 + 5) = v103 + v108;
            goto LABEL_100;
          }
          v109 = (void *)*((_QWORD *)v25 + 6);
          v246 = v104 - v103;
          if (v104 != v103)
          {
            __memcpy_chk();
            *((_QWORD *)v25 + 5) = v104;
          }
          __n = prot_pread(*v25, v109, v104, *((_QWORD *)v25 + 3));
          if (__n == -1)
          {
            v247 = 0;
LABEL_110:
            v25[4] = *__error();
            v106 = v247;
            v108 = 0;
            goto LABEL_100;
          }
          v110 = *((_QWORD *)v25 + 3) + __n;
          *((_QWORD *)v25 + 4) = __n;
          *((_QWORD *)v25 + 5) = 0;
          v235 = v110;
          *((_QWORD *)v25 + 3) = v110;
          if (__n)
          {
            v108 = 1 - v246;
            if (1 - v246 <= __n)
            {
              v103 = 0;
              v106 = v246;
              v107 = &v272[v246];
              goto LABEL_99;
            }
            v106 = v246;
            v107 = &v272[v246];
            while (1)
            {
              v247 = v106;
              v234 = (void *)*((_QWORD *)v25 + 6);
              v111 = v107;
              memcpy(v107, v234, __n);
              *((_QWORD *)v25 + 5) = __n;
              v112 = prot_pread(*v25, v234, __n, v235);
              if (v112 == -1)
                goto LABEL_110;
              *((_QWORD *)v25 + 4) = v112;
              *((_QWORD *)v25 + 5) = 0;
              v235 = *((_QWORD *)v25 + 3) + v112;
              *((_QWORD *)v25 + 3) = v235;
              if (!v112)
              {
                v106 = v247;
                v108 = __n;
                goto LABEL_100;
              }
              v103 = 0;
              v107 = &v111[__n];
              v108 -= __n;
              v106 = v247 + __n;
              __n = v112;
              if (v108 <= v112)
                goto LABEL_99;
            }
          }
          v106 = 0;
          v108 = v104 - v103;
LABEL_100:
          v68 = v251;
          v70 = v105;
          if (v108 + v106 != 1)
            break;
          v74 |= (unint64_t)(v272[0] & 0x7F) << v102;
          v102 += 7;
          if ((v272[0] & 0x80) == 0)
            goto LABEL_125;
        }
        v74 = 0;
LABEL_125:
        v67 = v260;
        if (v25[4])
        {
LABEL_254:
          v191 = *__error();
          v192 = _SILogForLogForCategory(0);
          if (!os_log_type_enabled(v192, OS_LOG_TYPE_ERROR))
            goto LABEL_275;
          v193 = v25[4];
          *(_DWORD *)v272 = 136315650;
          *(_QWORD *)&v272[4] = "TermUpdateSetRestore";
          *(_WORD *)&v272[12] = 1024;
          *(_DWORD *)&v272[14] = 1054;
          *(_WORD *)&v272[18] = 1024;
          *(_DWORD *)&v272[20] = v193;
          v194 = "%s:%d: storeStream error %d";
LABEL_256:
          v195 = v192;
          goto LABEL_257;
        }
LABEL_58:
        if (v68)
          v76 = v68 - (v74 >> 2);
        else
          v76 = v74 >> 2;
        if ((v74 & 1) != 0)
        {
          v80 = 1;
          if (v69)
            goto LABEL_63;
        }
        else
        {
          v77 = v68;
          v78 = v70;
          v79 = store_stream_read_vint32_2297((uint64_t)v25);
          v70 = v78;
          v68 = v77;
          v80 = v79;
          if (v69)
          {
LABEL_63:
            if ((v74 & 2) != 0)
              v81 = 2;
            else
              v81 = 1;
            v82 = v269;
            v83 = atomic_load((unsigned int *)v269 + 25);
            v84 = v83 + v81;
            v85 = *((unsigned int *)v82 + 24);
            if (v84 >= v85)
            {
              v113 = 2 * v85;
              if (!(_DWORD)v85)
                v113 = 0x4000;
              *((_DWORD *)v269 + 24) = v113;
              v252 = v68;
              v248 = v70;
              v114 = my_vm_reallocate(v265, 12 * v85, 12 * v113, 243, *((_QWORD *)v269 + 13));
              LODWORD(v70) = v248;
              v68 = v252;
              if (v114)
              {
                v229 = __si_assert_copy_extra_268();
                v230 = v229;
                v231 = "";
                if (v229)
                  v231 = v229;
                __message_assert("%s:%u: failed assertion '%s' %s ", "DocPosting.h", 250, "0 == kr", v231);
                goto LABEL_324;
              }
            }
            do
              v86 = __ldaxr(v49);
            while (__stlxr(v86 + v81, v49));
            if ((_DWORD)v70)
              v71 = (uint64_t)*v265 + 12 * v70;
            if ((_DWORD)v86)
            {
              v87 = *v265;
              *(_DWORD *)v71 = *(_DWORD *)v71 & 1 | (2 * v86);
              v71 = (uint64_t)v87 + 12 * v86;
              v70 = v86;
              goto LABEL_89;
            }
            *(_DWORD *)v71 &= 1u;
            v191 = *__error();
            v197 = _SILogForLogForCategory(0);
            if (!os_log_type_enabled(v197, OS_LOG_TYPE_ERROR))
              goto LABEL_275;
            *(_DWORD *)v272 = 136315394;
            *(_QWORD *)&v272[4] = "TermUpdateSetRestore";
            *(_WORD *)&v272[12] = 1024;
            *(_DWORD *)&v272[14] = 1098;
            v194 = "%s:%d: lastPosting==0";
LABEL_262:
            v195 = v197;
            v196 = 18;
LABEL_263:
            _os_log_error_impl(&dword_1B8270000, v195, OS_LOG_TYPE_ERROR, v194, v272, v196);
            goto LABEL_275;
          }
        }
        v88 = (uint64_t *)*((_QWORD *)v269 + 3);
        v89 = (uint64_t)(v88 + 2);
        v90 = *v88;
        v272[0] = 0;
        if (v90)
        {
          v245 = v70;
          v250 = v68;
          v91 = (_DWORD *)(v90 + 0x4000);
          v92 = *(_DWORD *)(v90 + 0x4000);
          if ((v92 & 0x80000000) == 0)
          {
            v71 = TermTrieResolve(v89);
            *(_QWORD *)v90 = v71;
            *v91 = 0x80000000;
            goto LABEL_75;
          }
          v71 = *(_QWORD *)v90;
          if ((v92 & 0x7FFFFFFF) != 0 || v262 != *(unsigned __int16 *)(v71 + 16))
          {
LABEL_85:
            v100 = TermTrieResolve(v89);
            v101 = v71;
            v71 = v100;
            v68 = v250;
            v70 = v245;
            if (*(_QWORD *)(v101 + 4) < *(_QWORD *)(v100 + 4))
            {
              *(_QWORD *)v90 = v100;
              *v91 = 0x80000000;
            }
            v67 = v260;
          }
          else
          {
            if ((v241 & 1) == 0)
            {
              v96 = v88 + 270;
              if (*(unsigned __int8 *)(v71 + 18) == *((unsigned __int8 *)v96 + LOBYTE(__dst[0])))
              {
                v97 = 0;
                v70 = v70;
                do
                {
                  if (v237 == v97)
                  {
                    v67 = v260;
                    goto LABEL_88;
                  }
                  v98 = *(unsigned __int8 *)(v71 + v97 + 19);
                  v99 = *((unsigned __int8 *)v96 + *((unsigned __int8 *)__dst + ++v97));
                }
                while (v98 == v99);
                if (v97 >= v239)
                  goto LABEL_75;
              }
              goto LABEL_85;
            }
LABEL_75:
            v67 = v260;
            v68 = v250;
            v70 = v245;
          }
        }
        else
        {
          v93 = v68;
          v94 = v70;
          v95 = TermTrieResolve(v89);
          v70 = v94;
          v68 = v93;
          v71 = v95;
        }
LABEL_88:
        *(_DWORD *)(v71 + 12) = 0;
        v256 = v71;
LABEL_89:
        *(_DWORD *)v71 &= 1u;
        if ((v74 & 2) != 0)
        {
          *(_DWORD *)v71 = 1;
          *(_QWORD *)(v71 + 8) = v74 >> 2;
        }
        else
        {
          if (v266 && v76 > v266)
          {
            v214 = *__error();
            v215 = _SILogForLogForCategory(0);
            if (os_log_type_enabled(v215, OS_LOG_TYPE_ERROR))
            {
              v224 = *((_DWORD *)v269 + 4);
              *(_DWORD *)v272 = 136316162;
              *(_QWORD *)&v272[4] = "TermUpdateSetRestore";
              *(_WORD *)&v272[12] = 1024;
              *(_DWORD *)&v272[14] = 1110;
              *(_WORD *)&v272[18] = 1024;
              *(_DWORD *)&v272[20] = v76;
              *(_WORD *)&v272[24] = 1024;
              *(_DWORD *)&v272[26] = v266;
              *(_WORD *)&v272[30] = 1024;
              v273 = v224;
              _os_log_error_impl(&dword_1B8270000, v215, OS_LOG_TYPE_ERROR, "%s:%d: invalid doc id %d exceeded (%d, %d)", v272, 0x24u);
            }
            *__error() = v214;
            v25[4] = 22;
            v27 = v269;
            if (v269)
              goto LABEL_277;
            return 0;
          }
          *(_DWORD *)v71 = 0;
          *(_DWORD *)(v71 + 8) = v76;
          v68 = v76;
        }
        *(_DWORD *)(v71 + 4) = v80;
        ++v69;
        v33 = (uint64_t *)(v25 + 10);
        if (v69 == v67)
        {
          v66 = *((_QWORD *)v25 + 4);
          v115 = v256;
          goto LABEL_128;
        }
      }
    }
    v115 = 0;
LABEL_128:
    if (v66 - *v33 < 0xA)
    {
      *(_WORD *)&v272[8] = 0;
      *(_QWORD *)v272 = 0;
      bytes_2300 = store_stream_read_bytes_2300(v25, v272, 1uLL);
      VInt64_1804 = 0;
      if (bytes_2300 == 1)
      {
        v156 = v2_vInt64DataSize(v272[0]);
        if (v156 == 1
          || store_stream_read_bytes_2300(v25, &v272[1], (v156 - 1)) == (v156 - 1))
        {
          *(_QWORD *)v278 = 0;
          VInt64_1804 = v2_readVInt64_1804((uint64_t)v272, (uint64_t *)v278);
        }
        else
        {
          VInt64_1804 = 0;
        }
        v33 = (uint64_t *)(v25 + 10);
      }
    }
    else
    {
      VInt64_1804 = v2_readVInt64_1804(*((_QWORD *)v25 + 6), v33);
    }
    if (VInt64_1804)
      break;
LABEL_192:
    v48 = v244 + 1;
    if (v244 + 1 == v254)
      goto LABEL_223;
  }
  if (!v115)
  {
    v191 = *__error();
    v197 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v197, OS_LOG_TYPE_ERROR))
      goto LABEL_275;
    *(_DWORD *)v272 = 136315394;
    *(_QWORD *)&v272[4] = "TermUpdateSetRestore";
    *(_WORD *)&v272[12] = 1024;
    *(_DWORD *)&v272[14] = 1125;
    v194 = "%s:%d: value==0";
    goto LABEL_262;
  }
  do
    v117 = __ldaxr(v243);
  while (__stlxr(v117 + 1, v243));
  *(_DWORD *)(v115 + 12) = v117;
  v118 = *v258;
  v242 = v117;
  v119 = *v258 + 32 * v117;
  *(_QWORD *)(v119 + 16) = VInt64_1804 >> 1;
  v249 = (_QWORD *)(v119 + 16);
  if (*((_QWORD *)v25 + 4) - *((_QWORD *)v25 + 5) < 0xAuLL)
  {
    *(_WORD *)&v272[8] = 0;
    *(_QWORD *)v272 = 0;
    v121 = 0;
    if (store_stream_read_bytes_2300(v25, v272, 1uLL) == 1)
    {
      v157 = v2_vInt64DataSize(v272[0]);
      if (v157 == 1
        || store_stream_read_bytes_2300(v25, &v272[1], (v157 - 1)) == (v157 - 1))
      {
        *(_QWORD *)v278 = 0;
        v121 = v2_readVInt64_1804((uint64_t)v272, (uint64_t *)v278);
      }
      else
      {
        v121 = 0;
      }
    }
    v33 = (uint64_t *)(v25 + 10);
    if (v121)
      goto LABEL_135;
    goto LABEL_192;
  }
  v120 = v2_readVInt64_1804(*((_QWORD *)v25 + 6), v33);
  LODWORD(v121) = v120;
  if (!v120)
    goto LABEL_192;
LABEL_135:
  v240 = v118;
  v122 = 0;
  v253 = 0;
  v123 = 0;
  v124 = 0;
  while (2)
  {
    v125 = positionInfoAlloc((uint64_t)v258, v121 + v255 + 8);
    if (!v125)
    {
      v191 = *__error();
      v197 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v197, OS_LOG_TYPE_ERROR))
        goto LABEL_275;
      *(_DWORD *)v272 = 136315394;
      *(_QWORD *)&v272[4] = "TermUpdateSetRestore";
      *(_WORD *)&v272[12] = 1024;
      *(_DWORD *)&v272[14] = 1165;
      v194 = "%s:%d: posPtrStart==0";
      goto LABEL_262;
    }
    v126 = v125;
    v257 = v124;
    v263 = v122;
    v127 = (_DWORD *)(*((_QWORD *)v269 + 32) + 8 * v125);
    *v127 = v121;
    v128 = (char *)(v127 + 1);
    v129 = *((_QWORD *)v25 + 4);
    v130 = *((_QWORD *)v25 + 5);
    if (v130 + (unint64_t)v121 <= v129)
    {
      v131 = 0;
      v132 = v128;
      v133 = v121;
      goto LABEL_139;
    }
    v131 = v129 - v130;
    if (v129 != v130)
    {
      memcpy(v128, (const void *)(*((_QWORD *)v25 + 6) + v130), v129 - v130);
      v129 = *((_QWORD *)v25 + 4);
      *((_QWORD *)v25 + 5) += v131;
    }
    v145 = prot_pread(*v25, *((void **)v25 + 6), v129, *((_QWORD *)v25 + 3));
    if (v145 == -1)
    {
      v131 = 0;
LABEL_172:
      v25[4] = *__error();
      v134 = v131;
      v131 = 0;
    }
    else
    {
      *((_QWORD *)v25 + 4) = v145;
      *((_QWORD *)v25 + 5) = 0;
      *((_QWORD *)v25 + 3) += v145;
      if (v145)
      {
        v132 = &v128[v131];
        v133 = v121 - v131;
        if (v133 > v145)
        {
          v238 = v145;
          while (1)
          {
            memcpy(v132, *((const void **)v25 + 6), v238);
            v148 = (void *)*((_QWORD *)v25 + 6);
            *((_QWORD *)v25 + 5) += v238;
            v149 = prot_pread(*v25, v148, *((_QWORD *)v25 + 4), *((_QWORD *)v25 + 3));
            if (v149 == -1)
            {
              v33 = (uint64_t *)(v25 + 10);
              goto LABEL_172;
            }
            *((_QWORD *)v25 + 4) = v149;
            *((_QWORD *)v25 + 5) = 0;
            *((_QWORD *)v25 + 3) += v149;
            if (!v149)
              break;
            v130 = 0;
            v132 += v238;
            v133 -= v238;
            v131 += v238;
            v238 = v149;
            if (v133 <= v149)
              goto LABEL_139;
          }
          v134 = v131;
          v131 = v238;
        }
        else
        {
          v130 = 0;
LABEL_139:
          memcpy(v132, (const void *)(*((_QWORD *)v25 + 6) + v130), v133);
          *((_QWORD *)v25 + 5) += v133;
          v134 = v131;
          v131 = v133;
        }
        v33 = (uint64_t *)(v25 + 10);
      }
      else
      {
        v134 = 0;
      }
    }
    if (v121 != v131 + v134)
    {
      v191 = *__error();
      v192 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v192, OS_LOG_TYPE_ERROR))
        goto LABEL_275;
      v216 = v25[4];
      *(_DWORD *)v272 = 136315650;
      *(_QWORD *)&v272[4] = "TermUpdateSetRestore";
      *(_WORD *)&v272[12] = 1024;
      *(_DWORD *)&v272[14] = 1175;
      *(_WORD *)&v272[18] = 1024;
      *(_DWORD *)&v272[20] = v216;
      v194 = "%s:%d: read error %d";
      goto LABEL_256;
    }
    v135 = (v121 - 1);
    if (v128[v135])
    {
      v191 = *__error();
      v217 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v217, OS_LOG_TYPE_ERROR))
        goto LABEL_275;
      v218 = v128[v135];
      *(_DWORD *)v272 = 136315650;
      *(_QWORD *)&v272[4] = "TermUpdateSetRestore";
      *(_WORD *)&v272[12] = 1024;
      *(_DWORD *)&v272[14] = 1183;
      *(_WORD *)&v272[18] = 1024;
      *(_DWORD *)&v272[20] = v218;
      v194 = "%s:%d: posStart[len-1]: %d";
      goto LABEL_301;
    }
    v136 = &v128[v121];
    *(_DWORD *)v136 = 0;
    v124 = *((_QWORD *)v269 + 32);
    if (v123)
    {
      v137 = (unsigned int *)((char *)v123 + v124 - v257);
      if (v257 == v124)
        v137 = v123;
      *v137 = v126;
    }
    else
    {
      v253 = v126;
    }
    v138 = v260;
    v139 = v263;
    v140 = *((_QWORD *)v25 + 5);
    if ((unint64_t)(*((_QWORD *)v25 + 4) - v140) < 6)
    {
      *(_WORD *)&v272[8] = 0;
      *(_QWORD *)v272 = 0;
      v146 = store_stream_read_bytes_2300(v25, v272, 1uLL);
      v143 = 0;
      if (v146 == 1)
      {
        if ((v272[0] & 0x80000000) == 0
          || (v272[0] >= 0xC0u
            ? (v272[0] >= 0xE0u
             ? (v272[0] < 0xF0u
              ? (v147 = 3)
              : (v147 = 4))
             : (v147 = 2))
            : (v147 = 1),
              v37 = store_stream_read_bytes_2300(v25, &v272[1], v147) == v147,
              v33 = (uint64_t *)(v25 + 10),
              v138 = v260,
              v139 = v263,
              v37))
        {
          *(_QWORD *)v278 = 0;
          v143 = v2_readVInt32((uint64_t)v272, (uint64_t *)v278);
        }
        else
        {
          v143 = 0;
        }
      }
    }
    else
    {
      v141 = *((_QWORD *)v25 + 6);
      v142 = v140 + 1;
      v143 = *(unsigned __int8 *)(v141 + v140);
      if (*(char *)(v141 + v140) < 0)
      {
        if (v143 > 0xBF)
        {
          if (v143 > 0xDF)
          {
            if (v143 > 0xEF)
            {
              v143 = *(_DWORD *)(v141 + v142);
              v142 = v140 + 5;
            }
            else
            {
              v143 = ((v143 & 0xF) << 24) | (*(unsigned __int8 *)(v141 + v142) << 16) | (*(unsigned __int8 *)(v140 + v141 + 2) << 8) | *(unsigned __int8 *)(v140 + v141 + 3);
              v142 = v140 + 4;
            }
          }
          else
          {
            v143 = ((v143 & 0x1F) << 16) | (*(unsigned __int8 *)(v141 + v142) << 8) | *(unsigned __int8 *)(v140 + v141 + 2);
            v142 = v140 + 3;
          }
        }
        else
        {
          v144 = *(unsigned __int8 *)(v141 + v142) | ((v143 & 0x3F) << 8);
          v142 = v140 + 2;
          v143 = v144;
        }
      }
      *v33 = v142;
    }
    if (v143)
    {
      if (v139 == v138)
      {
        v191 = *__error();
        v212 = _SILogForLogForCategory(0);
        if (!os_log_type_enabled(v212, OS_LOG_TYPE_ERROR))
          goto LABEL_275;
        *(_DWORD *)v272 = 136315906;
        *(_QWORD *)&v272[4] = "TermUpdateSetRestore";
        *(_WORD *)&v272[12] = 1024;
        *(_DWORD *)&v272[14] = 1230;
        *(_WORD *)&v272[18] = 1024;
        *(_DWORD *)&v272[20] = v138;
        *(_WORD *)&v272[24] = 1024;
        *(_DWORD *)&v272[26] = v138;
        v194 = "%s:%d: invalid position data %d %d";
        goto LABEL_294;
      }
      v122 = v139 + 1;
      v123 = (unsigned int *)v136;
      LODWORD(v121) = v143;
      continue;
    }
    break;
  }
  if (*v249 || v139 + 1 == v260)
  {
    *(_DWORD *)(v240 + 32 * v242 + 4) = v253;
    goto LABEL_192;
  }
  v191 = *__error();
  v212 = _SILogForLogForCategory(0);
  if (os_log_type_enabled(v212, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)v272 = 136315906;
    *(_QWORD *)&v272[4] = "TermUpdateSetRestore";
    *(_WORD *)&v272[12] = 1024;
    *(_DWORD *)&v272[14] = 1220;
    *(_WORD *)&v272[18] = 1024;
    *(_DWORD *)&v272[20] = v139 + 1;
    *(_WORD *)&v272[24] = 1024;
    *(_DWORD *)&v272[26] = v260;
    v194 = "%s:%d: invalid position data %d %d";
LABEL_294:
    v195 = v212;
    goto LABEL_283;
  }
LABEL_275:
  *__error() = v191;
LABEL_276:
  v27 = v269;
  if (v269)
LABEL_277:
    TermUpdateSetRelease((uint64_t)v27);
  return 0;
}

uint64_t v2_vInt64DataSize(unsigned int a1)
{
  char v1;
  char v2;
  char v3;
  char v4;
  char v5;
  char v6;
  unsigned __int8 v7;

  if (a1 == 255)
    v1 = 9;
  else
    v1 = 8;
  if (a1 >= 0xFE)
    v2 = v1;
  else
    v2 = 7;
  if (a1 >= 0xFC)
    v3 = v2;
  else
    v3 = 6;
  if (a1 >= 0xF8)
    v4 = v3;
  else
    v4 = 5;
  if (a1 >= 0xF0)
    v5 = v4;
  else
    v5 = 4;
  if (a1 >= 0xE0)
    v6 = v5;
  else
    v6 = 3;
  if (a1 >= 0xC0)
    v7 = v6;
  else
    v7 = 2;
  if ((a1 & 0x80) != 0)
    return v7;
  else
    return 1;
}

uint64_t positionInfoAlloc(uint64_t a1, unint64_t a2)
{
  unint64_t v3;
  unsigned int *v4;
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  unsigned int v9;
  char *v10;
  char *v11;
  const char *v12;

  v3 = a2 >> 3;
  if ((a2 & 7) != 0)
    LODWORD(v3) = v3 + 1;
  v4 = (unsigned int *)(a1 + 28);
  v5 = atomic_load((unsigned int *)(a1 + 28));
  do
    v6 = __ldaxr(v4);
  while (__stlxr(v6 + v3, v4));
  if (v5 + a2 > *(_QWORD *)(a1 + 48) + 0x8000)
  {
    *(_QWORD *)(a1 + 48) = ((v5 + a2) & 0xFFFFFFFFFFFC0000) + 0x40000;
    madvise((void *)((*(_QWORD *)(a1 + 16) + 8 * v5 + 8 * a2) & 0xFFFFFFFFFFFC0000), 0x40000uLL, 3);
  }
  while (1)
  {
    v7 = atomic_load((unsigned int *)(a1 + 28));
    v8 = *(unsigned int *)(a1 + 32);
    if (v7 < v8)
      break;
    v9 = 2 * v8;
    if (!(_DWORD)v8)
      v9 = 0x20000;
    *(_DWORD *)(a1 + 32) = v9;
    if (my_vm_reallocate((void **)(a1 + 16), 8 * v8, 8 * v9, 247, *(_QWORD *)(a1 + 56)))
    {
      v10 = __si_assert_copy_extra_268();
      v11 = v10;
      v12 = "";
      if (v10)
        v12 = v10;
      __message_assert("%s:%u: failed assertion '%s' %s ", "CIPositions.h", 130, "0 == kr", v12);
      free(v11);
      if (__valid_fs(-1))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
  }
  return v5;
}

uint64_t TermUpdateSetUpdateDocumentInfo(uint64_t a1, unsigned int a2, uint64_t a3, const __CFDictionary *a4, const __CFDictionary *a5, int a6, uint64_t a7, int a8, uint64_t a9, int a10, unsigned __int8 a11)
{
  unsigned int v17;
  unint64_t v18;
  signed int v19;
  _QWORD *v20;
  const __CFAllocator *v21;
  size_t *v22;
  uint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  void *v26;
  _QWORD *v27;
  _QWORD *v28;
  _QWORD *v29;
  pthread_override_s *v30;
  char v31;
  uint64_t v33;
  uint64_t *v34;
  uint64_t v35;
  char *v36;
  char *v37;
  const char *v38;
  void *v41;
  CFTypeRef cf;
  CFTypeRef Mutable;
  uint64_t v44;

  if (!a3)
  {
    v36 = __si_assert_copy_extra_268();
    v37 = v36;
    v38 = "";
    if (v36)
      v38 = v36;
    __message_assert("%s:%u: failed assertion '%s' %s Expected non-zero docID", "TermUpdateSet.c", 2275, "docID", v38);
    free(v37);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  poslock(*(pthread_rwlock_t **)(a1 + 280));
  HIDWORD(v18) = qos_class_self() - 9;
  LODWORD(v18) = HIDWORD(v18);
  v17 = v18 >> 2;
  if (v17 > 6)
    v19 = 0;
  else
    v19 = dword_1B8630ED0[v17];
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 304));
  if (*(_QWORD *)(a1 + 488) || *(_DWORD *)(a1 + 500) || *(_BYTE *)(a1 + 516))
    goto LABEL_8;
  if (v19 <= 5)
  {
    if (*(_QWORD *)(a1 + 16 * v19 + 368))
    {
LABEL_8:
      db_rwlock_wait(a1 + 304, v19, 2);
      goto LABEL_9;
    }
    v33 = v19 - 1;
    v34 = (uint64_t *)(a1 + 16 * v19 + 384);
    while (v33 != 4)
    {
      v35 = *v34;
      v34 += 2;
      ++v33;
      if (v35)
      {
        if (v33 <= 4)
          goto LABEL_8;
        break;
      }
    }
  }
  *(_QWORD *)(a1 + 488) = pthread_self();
LABEL_9:
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 304));
  ++*(_DWORD *)(a1 + 112);
  switch(a6)
  {
    case 0:
      v20 = (_QWORD *)(a1 + 128);
      goto LABEL_19;
    case 1:
      v20 = (_QWORD *)(a1 + 168);
      goto LABEL_19;
    case 2:
      v20 = (_QWORD *)(a1 + 144);
      goto LABEL_19;
    case 3:
      v20 = (_QWORD *)(a1 + 120);
      goto LABEL_19;
    case 6:
      v20 = (_QWORD *)(a1 + 136);
      goto LABEL_19;
    case 7:
      v20 = (_QWORD *)(a1 + 192);
      goto LABEL_19;
    case 9:
      v20 = (_QWORD *)(a1 + 200);
      goto LABEL_19;
    case 10:
      v20 = (_QWORD *)(a1 + 208);
      goto LABEL_19;
    case 11:
      v20 = (_QWORD *)(a1 + 216);
LABEL_19:
      ++*v20;
      break;
    default:
      break;
  }
  v44 = 0;
  v21 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  cf = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, &stringUnqBuffSetCallBacks);
  Mutable = CFSetCreateMutable(v21, 0, &stringUnqBuffSetCallBacks);
  v22 = (size_t *)MEMORY[0x1E0C85AD8];
  v23 = *MEMORY[0x1E0C85AD8];
  v24 = mmap(0, *MEMORY[0x1E0C85AD8], 3, 4098, 0, 0);
  if (v24 == (_QWORD *)-1)
  {
    v25 = 0;
  }
  else
  {
    v25 = v24;
    v26 = v24 + 3;
    *v25 = 0;
    v25[1] = v26;
    v25[2] = (char *)v25 + v23;
    madvise(v26, *v22, 3);
  }
  v41 = v25;
  v27 = CIRetainIndexingTokenizer(a2);
  if (a5)
    termUpdateSetProcessFields(a1, (uint64_t)&v41, (uint64_t)v27, a3, 0, a5, 2u, a11);
  if (a4)
    termUpdateSetProcessFields(a1, (uint64_t)&v41, (uint64_t)v27, a3, 0, a4, 1u, a11);
  termUpdateSetProcessWildCardFields(a1, a3, (CFSetRef)Mutable, 2);
  termUpdateSetProcessWildCardFields(a1, a3, (CFSetRef)cf, 1);
  CIReleaseIndexingTokenizer((uint64_t)v27);
  CFRelease(cf);
  CFRelease(Mutable);
  v28 = v41;
  if (v41)
  {
    do
    {
      v29 = (_QWORD *)*v28;
      munmap(v28, v28[2] - (_QWORD)v28);
      v28 = v29;
    }
    while (v29);
  }
  if (a8)
    doChildFile(a1 + 88, (_QWORD *)(a1 + 48), a8, a7, a3, 1);
  if (a10)
    doChildFile(a1 + 88, (_QWORD *)(a1 + 48), a10, a9, a3, 2);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 304));
  *(_DWORD *)(a1 + 508) = 0;
  v30 = *(pthread_override_s **)(a1 + 480);
  *(_QWORD *)(a1 + 480) = 0;
  *(_QWORD *)(a1 + 488) = 0;
  v31 = *(_DWORD *)(a1 + 500) != 0;
  *(_BYTE *)(a1 + 516) = 0;
  db_rwlock_wakeup(a1 + 304, v31, 0);
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 304));
  if (v30)
    pthread_override_qos_class_end_np(v30);
  return poswriteunlock(*(pthread_rwlock_t **)(a1 + 280));
}

CFIndex termUpdateSetProcessWildCardFields(uint64_t a1, uint64_t a2, CFSetRef theSet, int a4)
{
  CFIndex Count;
  uint64_t v9;
  const void **v10;
  size_t v11;
  CFIndex v12;
  unsigned __int8 *v13;
  _QWORD v15[2];

  v15[1] = *MEMORY[0x1E0C80C00];
  Count = CFSetGetCount(theSet);
  MEMORY[0x1E0C80A78](Count);
  v10 = (const void **)((char *)v15 - v9);
  bzero((char *)v15 - v9, v11);
  CFSetGetValues(theSet, v10);
  if (Count >= 1)
  {
    v12 = Count;
    do
    {
      v13 = (unsigned __int8 *)*v10++;
      pushPropertyTerm(a1, *(__int16 *)v13, v13 + 2, a2, 0, a4, 1);
      --v12;
    }
    while (v12);
  }
  return Count;
}

void termUpdateSetProcessSingleVector(uint64_t a1, CFDictionaryRef theDict, uint64_t a3, uint64_t a4, uint64_t a5)
{
  CFTypeID v10;
  CFTypeID v11;
  CFTypeID v12;
  unint64_t v13;
  uint64_t **v14;
  uint64_t v15;
  uint64_t v16;
  const UInt8 *BytePtr;
  const UInt8 *v18;
  uint64_t v19;
  uint64_t v20;
  std::__shared_weak_count *v21;
  unint64_t *p_shared_owners;
  unint64_t v23;
  char *v24;
  char *v25;
  const char *v26;
  unsigned __int16 v27;
  unsigned int valuePtr;
  uint64_t v29;
  CFNumberRef number;
  void *value;
  uint64_t *v32;
  std::__shared_weak_count *v33;

  number = 0;
  value = 0;
  if (CFDictionaryGetValueIfPresent(theDict, CFSTR("vec_data"), (const void **)&value)
    && CFDictionaryGetValueIfPresent(theDict, CFSTR("vec_id"), (const void **)&number))
  {
    v29 = 0;
    valuePtr = 0;
    CFNumberGetValue(number, kCFNumberSInt32Type, &valuePtr);
    if (CFDictionaryGetValueIfPresent(theDict, CFSTR("vec_dim"), (const void **)&number))
    {
      v10 = CFGetTypeID(number);
      if (v10 == CFNumberGetTypeID())
        CFNumberGetValue(number, kCFNumberSInt8Type, &v29);
    }
    if (CFDictionaryGetValueIfPresent(theDict, CFSTR("vec_format"), (const void **)&number))
    {
      v11 = CFGetTypeID(number);
      if (v11 == CFNumberGetTypeID())
        CFNumberGetValue(number, kCFNumberSInt8Type, (char *)&v29 + 4);
    }
    v27 = 0;
    if (CFDictionaryGetValueIfPresent(theDict, CFSTR("vec_version"), (const void **)&number))
    {
      v12 = CFGetTypeID(number);
      if (v12 == CFNumberGetTypeID())
        CFNumberGetValue(number, kCFNumberSInt16Type, &v27);
    }
    v13 = -1;
    if (v29 <= 2 && HIDWORD(v29) <= 2)
      v13 = (vector_dimension_vec_sizes_10743[v29]
                         * vector_size_elem_sizes_10742[HIDWORD(v29)]);
    if (v13 <= CFDataGetLength((CFDataRef)value))
    {
      v14 = *(uint64_t ***)(a1 + 80);
      v15 = v27;
      v16 = valuePtr;
      BytePtr = CFDataGetBytePtr((CFDataRef)value);
      if (!(_DWORD)v16)
      {
        v24 = __si_assert_copy_extra_268();
        v25 = v24;
        v26 = "";
        if (v24)
          v26 = v24;
        __message_assert("%s:%u: failed assertion '%s' %s ", "VectorIndex.cpp", 242, "vectorId > 0", v26);
        free(v25);
        if (__valid_fs(-1))
        {
          MEMORY[0xBAD] = -559038737;
          abort();
        }
        MEMORY[0xC00] = -559038737;
        abort();
      }
      v18 = BytePtr;
      v20 = v29;
      v19 = HIDWORD(v29);
      IVFVectorIndexUpdateSet::getOrCreateVectorIndex(&v32, v14, a5, v15, v29, SHIDWORD(v29));
      (*(void (**)(uint64_t *, uint64_t, uint64_t, const UInt8 *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*v32 + 64))(v32, a5, v16, v18, v20, v19, a3, a4, a1 + 88);
      v21 = v33;
      if (v33)
      {
        p_shared_owners = (unint64_t *)&v33->__shared_owners_;
        do
          v23 = __ldaxr(p_shared_owners);
        while (__stlxr(v23 - 1, p_shared_owners));
        if (!v23)
        {
          ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
          std::__shared_weak_count::__release_weak(v21);
        }
      }
    }
  }
}

uint64_t _getContentTokensCallback(char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  int v7;
  NSObject *v8;
  int v9;
  const char *v10;
  const char *v11;
  int v12;
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  int v17;
  __int16 v18;
  const char *v19;
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (a2 < 1)
    return getContentTokensCallback(a1, a2, 0, a4);
  v5 = 0;
  while (*(unsigned __int16 *)&a1[2 * v5] > 5u)
  {
    if (a2 == ++v5)
      return getContentTokensCallback(a1, a2, 0, a4);
  }
  if (_getContentTokensCallback_logCount <= 49)
  {
    ++_getContentTokensCallback_logCount;
    v7 = *__error();
    v8 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      v9 = *(unsigned __int16 *)&a1[2 * v5];
      v10 = (const char *)__si_error_str_key;
      if (__si_error_str_key)
        v10 = (const char *)pthread_getspecific(__si_error_str_key);
      v11 = "";
      v12 = 136315906;
      v13 = "_getContentTokensCallback";
      v14 = 1024;
      if (v10)
        v11 = v10;
      v15 = 1817;
      v16 = 1024;
      v17 = v9;
      v18 = 2080;
      v19 = v11;
      _os_log_error_impl(&dword_1B8270000, v8, OS_LOG_TYPE_ERROR, "%s:%d: invalid content token (%d) for %s", (uint8_t *)&v12, 0x22u);
    }
    *__error() = v7;
  }
  return 1;
}

uint64_t _getContentSubTokensCallback(char *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return getContentTokensCallback(a1, a2, 1, a4);
}

uint64_t _getContentRankedTokensCallback(unsigned __int16 *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t result;
  unsigned int v8;
  uint64_t v10;
  unint64_t v11;
  uint8_t *v12;
  uint64_t v13;
  size_t v14;
  size_t v15;
  uint8_t *v16;
  int v17;
  NSObject *v18;
  int v19;
  const char *v20;
  const char *v21;
  uint8_t buf[4];
  const char *v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int v27;
  __int16 v28;
  const char *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  if (a2 < 1)
  {
LABEL_5:
    result = 0;
    if (a2 <= 1044)
    {
      v8 = *(_DWORD *)(a4 + 32);
      if (v8 && v8 <= 5)
      {
        v10 = a2 + 3;
        MEMORY[0x1E0C80A78](0);
        v12 = &buf[-((v11 + 15) & 0xFFFFFFFFFFFFFFF0)];
        v14 = 2 * v13;
        if (v11 <= 2 * v13)
          v15 = 0;
        else
          v15 = 6;
        v16 = &v12[v14];
        bzero(&v12[v14], v15);
        memcpy(v12, a1, v14);
        *(_WORD *)v16 = 1;
        *((_WORD *)v16 + 1) = v8;
        *((_WORD *)v16 + 2) = 5;
        return getContentTokensCallback((char *)v12, v10, 0, a4);
      }
    }
  }
  else
  {
    v6 = 0;
    while (a1[v6] > 5u)
    {
      if (a2 == ++v6)
        goto LABEL_5;
    }
    if (_getContentRankedTokensCallback_logCount <= 49)
    {
      ++_getContentRankedTokensCallback_logCount;
      v17 = *__error();
      v18 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        v19 = a1[v6];
        v20 = (const char *)__si_error_str_key;
        if (__si_error_str_key)
          v20 = (const char *)pthread_getspecific(__si_error_str_key);
        v21 = "";
        *(_DWORD *)buf = 136315906;
        v23 = "_getContentRankedTokensCallback";
        v24 = 1024;
        if (v20)
          v21 = v20;
        v25 = 1843;
        v26 = 1024;
        v27 = v19;
        v28 = 2080;
        v29 = v21;
        _os_log_error_impl(&dword_1B8270000, v18, OS_LOG_TYPE_ERROR, "%s:%d: invalid content token (%d) for %s", buf, 0x22u);
      }
      *__error() = v17;
    }
    return 1;
  }
  return result;
}

uint64_t _getContentRankedSubTokensCallback(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;
  unsigned int v7;
  uint64_t v9;
  unint64_t v10;
  char *v11;
  uint64_t v12;
  size_t v13;
  size_t v14;
  char *v15;
  _QWORD v16[2];

  result = 0;
  v16[1] = *MEMORY[0x1E0C80C00];
  if (a2 <= 1044)
  {
    v7 = *(_DWORD *)(a4 + 32);
    if (v7 && v7 <= 5)
    {
      v9 = a2 + 3;
      MEMORY[0x1E0C80A78](0);
      v11 = (char *)v16 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
      v13 = 2 * v12;
      if (v10 <= 2 * v12)
        v14 = 0;
      else
        v14 = 6;
      v15 = &v11[v13];
      bzero(&v11[v13], v14);
      memcpy(v11, a1, v13);
      *(_WORD *)v15 = 1;
      *((_WORD *)v15 + 1) = v7;
      *((_WORD *)v15 + 2) = 5;
      return getContentTokensCallback(v11, v9, 1, a4);
    }
  }
  return result;
}

void pushPropertyTermForWildCard(_QWORD **a1, size_t a2, const void *a3, int a4)
{
  size_t v8;
  uint64_t v9;
  _WORD *v10;
  uint64_t v11;
  __CFSet *v12;
  _QWORD *v13;
  unint64_t i;
  unint64_t *v15;
  unint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t v19;
  _QWORD v20[2];

  v20[1] = *MEMORY[0x1E0C80C00];
  v8 = a2 + 2;
  MEMORY[0x1E0C80A78](a1);
  v10 = (_WORD *)((char *)v20 - ((v9 + 17) & 0xFFFFFFFFFFFFFFF0));
  bzero(v10, v8);
  *v10 = a2;
  memcpy(v10 + 1, a3, a2);
  v11 = 1;
  if (a4 == 2)
    v11 = 2;
  v12 = (__CFSet *)a1[v11];
  if (!CFSetContainsValue(v12, v10))
  {
    v13 = *a1;
LABEL_6:
    for (i = atomic_load(v13 + 1); i + v8 + 8 >= v13[2]; i = atomic_load(v15))
    {
      os_unfair_lock_lock((os_unfair_lock_t)&_slablock);
      v13 = *a1;
      v15 = *a1 + 1;
      v16 = atomic_load(v15);
      if (v16 + v8 + 8 >= v13[2])
      {
        i = (unint64_t)slab_new_slab(a1, v8, -1);
        os_unfair_lock_unlock((os_unfair_lock_t)&_slablock);
LABEL_14:
        madvise((void *)((i & 0xFFFFFFFFFFFC0000) + 0x40000), 0x40000uLL, 3);
        goto LABEL_15;
      }
      os_unfair_lock_unlock((os_unfair_lock_t)&_slablock);
    }
    v17 = v13 + 1;
    do
    {
      v18 = __ldaxr(v17);
      if (v18 != i)
      {
        __clrex();
        goto LABEL_6;
      }
    }
    while (__stlxr(i + v8, v17));
    v19 = atomic_load(v17);
    if ((v19 ^ i) >= 0x40000)
      goto LABEL_14;
LABEL_15:
    memcpy((void *)i, v10, v8);
    CFSetAddValue(v12, (const void *)i);
  }
}

uint64_t getContentTokensCallback(char *a1, uint64_t a2, int a3, uint64_t a4)
{
  int v5;
  void *v7;
  int v8;
  size_t v9;
  int v10;
  unsigned int v11;
  char *v12;
  int v13;
  int v14;
  uint64_t v15;
  int v16;
  int v17;
  unint64_t v18;
  int v19;
  unint64_t v20;
  int v21;
  unsigned int v22;
  int v23;
  int *v24;
  int v25;
  uint64_t v26;
  int *v27;
  int *v28;
  unsigned int *v29;
  unsigned int v30;
  unsigned int v31;
  int v32;
  unsigned int v33;
  BOOL v34;
  unsigned int v35;
  uint64_t v36;
  size_t v37;
  unsigned int v38;
  uint64_t v39;
  uint64_t v40;
  unsigned int *v41;
  uint64_t v42;
  int v43;
  char v44;
  uint64_t v45;
  int v46;
  unsigned int v47;
  int v48;
  uint64_t v49;
  _DWORD *v50;
  unsigned int **v51;
  unsigned int v53;
  unsigned int v54;
  uint64_t v55;
  unsigned int *v56;
  int v57;
  unsigned int v58;
  uint64_t v59;
  int v60;
  char *v61;
  char *v62;
  char *v63;
  char *v64;
  const char *v65;
  uint64_t v66;
  char *v67;
  char *v68;
  const char *v69;
  char *v70;
  const char *v71;
  uint64_t v72;
  uint64_t *v73;
  void *v74;
  int v75;
  unint64_t v76;
  char v77;
  unsigned int *v78[5];
  unsigned __int8 v79[1044];
  uint64_t v80;

  v5 = a3;
  v7 = a1;
  v80 = *MEMORY[0x1E0C80C00];
  if (a3)
    v8 = 2;
  else
    v8 = 0;
  v9 = 2 * a2;
  if ((a2 & 0x40000000) != 0)
    v10 = 2 * a2 + 3;
  else
    v10 = 2 * a2;
  v11 = v8 ^ 0x971E137B;
  v12 = &a1[v10 & 0xFFFFFFFC];
  if ((2 * a2 + 3) < 7)
  {
    v13 = 1107688271;
    v14 = 1713515327;
    if ((v9 & 2) == 0)
      goto LABEL_15;
LABEL_14:
    HIDWORD(v20) = *(unsigned __int16 *)v12 * v14;
    LODWORD(v20) = HIDWORD(v20);
    v21 = (v20 >> 21) * v13;
    HIDWORD(v20) = v11;
    LODWORD(v20) = v11;
    v11 = v21 ^ (5 * (v20 >> 19) + 1390208809);
    goto LABEL_15;
  }
  v15 = -(v10 >> 2);
  v16 = -1789642873;
  v17 = 718793509;
  do
  {
    v16 = 5 * v16 + 2071795100;
    v17 = 5 * v17 + 1808688022;
    HIDWORD(v18) = v16 * *(_DWORD *)&v12[4 * v15];
    LODWORD(v18) = HIDWORD(v18);
    v19 = (v18 >> 21) * v17;
    HIDWORD(v18) = v11;
    LODWORD(v18) = v11;
    v11 = v19 ^ (5 * (v18 >> 19) + 1390208809);
    v34 = __CFADD__(v15++, 1);
  }
  while (!v34);
  v14 = 5 * v16 + 2071795100;
  v13 = 5 * v17 + 1808688022;
  if ((v9 & 2) != 0)
    goto LABEL_14;
LABEL_15:
  bzero(v79, 0x414uLL);
  v22 = -1028477387 * ((-2048144789 * (v11 ^ v9)) ^ ((-2048144789 * (v11 ^ v9)) >> 13));
  v76 = v8 ^ HIWORD(v22) ^ v22;
  if (a2 > 16)
  {
    v26 = 0;
    v32 = 0;
  }
  else
  {
    v23 = v5;
    v24 = *(int **)(a4 + 8);
    v25 = *v24 + 1;
    *v24 = v25;
    v26 = (v8 ^ BYTE2(v22) ^ v22);
    if (v24[v26 + 3586] == (v8 ^ HIWORD(v22) ^ v22))
    {
      v27 = &v24[14 * v26];
      if ((v27[11] & 0xFFFFFF) == v8 && LOBYTE(v24[14 * v26 + 10]) == a2 && !memcmp(v7, v27 + 2, v9))
      {
        v24[14 * v26 + 12] = v25;
        if ((v23 & 1) != 0)
        {
          pushTermData(*(_QWORD *)a4, *(int **)&v24[14 * v26 + 14], *(unsigned int *)(a4 + 16), *(_DWORD *)(a4 + 20), 0, 0, 1u);
          return 0;
        }
        v54 = *(_DWORD *)(a4 + 16);
        if (!v54)
        {
          v63 = __si_assert_copy_extra_268();
          v64 = v63;
          v65 = "";
          if (v63)
            v65 = v63;
          __message_assert("%s:%u: failed assertion '%s' %s expected non-zero docID for term %s", "TermUpdateSet.c", 1684, "ctx->docID", v65, (const char *)(*(_QWORD *)(*(_QWORD *)(a4 + 8) + 56 * v26 + 56) + 18));
          free(v64);
          if (__valid_fs(-1))
            v66 = 2989;
          else
            v66 = 3072;
          *(_DWORD *)v66 = -559038737;
          abort();
        }
        v55 = *(_QWORD *)a4;
        v56 = *(unsigned int **)&v24[14 * v26 + 14];
        v57 = *(_DWORD *)(a4 + 20);
        v58 = *(_DWORD *)(a4 + 24) + 1;
        *(_DWORD *)(a4 + 24) = v58;
        if (pushContentTermData(v55, v56, v54, v57, v58, 0))
        {
          memset(v78, 0, 32);
          v59 = *(_QWORD *)(*(_QWORD *)(a4 + 8) + 56 * v26 + 56);
          v60 = decode_prefix((unsigned __int8 *)(v59 + 18), *(unsigned __int16 *)(v59 + 16), (unsigned __int8 *)v78);
          pushPrefixTerms(*(_QWORD *)a4, v60, (char *)v78, 1u, "\x01", *(unsigned int *)(a4 + 16), *(_DWORD *)(a4 + 20), 0, *(_DWORD *)(a4 + 32));
          return 0;
        }
        return 2;
      }
    }
    v28 = &v24[14 * v26];
    v31 = v28[12];
    v29 = (unsigned int *)(v28 + 12);
    v30 = v31;
    v32 = 1;
    if (v31 && v25 - v30 <= 0x400)
    {
      v33 = ((3 * (v25 - v30)) >> 2) + 1;
      v34 = v30 >= v33;
      v35 = v30 - v33;
      v32 = v35 == 0 || !v34;
      if (!v34)
        v35 = 0;
      *v29 = v35;
    }
    v5 = v23;
  }
  v78[0] = 0;
  v36 = utf8_encodestr((unsigned __int16 *)v7, v9, v79, v78, 1028);
  if ((_DWORD)v36)
    return 0;
  v75 = v32;
  v37 = (size_t)v78[0];
  v78[0] = 0;
  v38 = *(_DWORD *)(a4 + 16);
  if ((v5 & 1) == 0)
  {
    if (!v38)
    {
      v74 = v7;
      MEMORY[0x1E0C80A78](v36);
      v62 = (char *)&v72 - ((v37 + 16) & 0xFFFFFFFFFFFFFFF0);
      bzero(&v62[v37], v37 != -1);
      memcpy(v62, v79, v37);
      v62[v37] = 0;
      if (!*(_DWORD *)(a4 + 16))
      {
        v70 = __si_assert_copy_extra_268();
        v68 = v70;
        v71 = "";
        if (v70)
          v71 = v70;
        __message_assert("%s:%u: failed assertion '%s' %s expected non-zero docID for term %s", "TermUpdateSet.c", 1727, "ctx->docID", v71, (const char *)&v72 - ((v37 + 16) & 0xFFFFFFFFFFFFFFF0));
LABEL_79:
        free(v68);
        if (__valid_fs(-1))
        {
          MEMORY[0xBAD] = -559038737;
          abort();
        }
        MEMORY[0xC00] = -559038737;
        abort();
      }
      v38 = *(_DWORD *)(a4 + 16);
      v7 = v74;
    }
    v45 = *(_QWORD *)a4;
    v46 = *(_DWORD *)(a4 + 20);
    v47 = *(_DWORD *)(a4 + 24) + 1;
    *(_DWORD *)(a4 + 24) = v47;
    v48 = pushTerm(v45, v76, v37, (char *)v79, v38, v46, v47, v78);
    *(_DWORD *)(a4 + 28) += v48;
    if (!v75)
      goto LABEL_41;
    goto LABEL_40;
  }
  LODWORD(v74) = v5;
  if (v38)
    goto LABEL_33;
  v73 = &v72;
  MEMORY[0x1E0C80A78](v36);
  v61 = (char *)&v72 - ((v37 + 16) & 0xFFFFFFFFFFFFFFF0);
  bzero(&v61[v37], v37 != -1);
  v72 = (uint64_t)v61;
  memcpy(v61, v79, v37);
  v61[v37] = 0;
  if (!*(_DWORD *)(a4 + 16))
  {
    v67 = __si_assert_copy_extra_268();
    v68 = v67;
    v69 = "";
    if (v67)
      v69 = v67;
    __message_assert("%s:%u: failed assertion '%s' %s expected non-zero docID for term %s", "TermUpdateSet.c", 1737, "ctx->docID", v69, (const char *)v72);
    goto LABEL_79;
  }
  v38 = *(_DWORD *)(a4 + 16);
LABEL_33:
  v39 = *(_QWORD *)a4;
  v72 = v38;
  LODWORD(v73) = *(_DWORD *)(a4 + 20);
  v79[v37] = 1;
  v79[v37 + 1] = 2;
  v79[v37 + 2] = 0;
  v77 = 0;
  v40 = v39;
  v41 = (unsigned int *)pushTermTable(*(_QWORD *)(v39 + 24) + 16, **(_QWORD **)(v39 + 24), v76, v37 + 2, v79, 1, &v77);
  if (v77)
  {
    v41[2] = v38;
    v41[3] = 0;
    v41[1] = 1;
    LOBYTE(v5) = (_BYTE)v74;
LABEL_35:
    v42 = v40;
    goto LABEL_36;
  }
  if ((*(_BYTE *)v41 & 1) == 0)
  {
    v53 = v41[2];
    LOBYTE(v5) = (_BYTE)v74;
    if (v53 == v38)
      goto LABEL_50;
    if (v53 == (_DWORD)v73)
    {
      v41[1] = 1;
      v41[2] = v38;
      goto LABEL_35;
    }
LABEL_66:
    v42 = v40;
    addToExistingTermUpdateList(v40, v41, v72, 0, 1u);
LABEL_36:
    v43 = v75;
    if (v79[v37 - 1] == 5)
      v44 = v79[v37 - 2];
    else
      v44 = 0;
    pushPrefixTerms(v42, v37, (char *)v79, 1u, "\x01", v72, (int)v73, 0, v44);
    v48 = 0;
    if (v43)
      goto LABEL_40;
    goto LABEL_41;
  }
  LOBYTE(v5) = (_BYTE)v74;
  if (*((_QWORD *)v41 + 1) != v72)
    goto LABEL_66;
LABEL_50:
  v48 = 0;
  if (v75)
  {
LABEL_40:
    v49 = *(_QWORD *)(a4 + 8) + 56 * v26;
    *(_BYTE *)(v49 + 40) = a2;
    memcpy((void *)(v49 + 8), v7, v9);
    v50 = *(_DWORD **)(a4 + 8);
    v51 = (unsigned int **)&v50[14 * v26];
    *((_DWORD *)v51 + 12) = *v50;
    v51[7] = v78[0];
    v50[v26 + 3586] = v76;
  }
LABEL_41:
  if ((v5 & 1) != 0)
    return 0;
  if (!v48)
    return 2;
  return *(_DWORD *)(a4 + 28) > 0x20000u;
}

uint64_t pushContentTermData(uint64_t a1, unsigned int *__src, unsigned int a3, int a4, unsigned int a5, char a6)
{
  uint64_t *v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  int *v14;
  unsigned int *v15;
  unsigned int v17;
  uint64_t v18;
  unsigned int v19;
  int *v20;
  uint64_t result;
  int v22;
  unsigned int *v23;
  unsigned int v24;
  uint64_t v25;
  unsigned int v26;
  unsigned int v27;
  uint64_t v28;
  char *v29;
  char *v30;
  const char *v31;
  char *v32;
  uint64_t v33;
  unsigned int *v34;
  int v35;
  unsigned int v36;
  uint64_t v37;
  unsigned int v38;
  int *v39;
  uint64_t v40;
  uint64_t v41;
  unsigned int v42;
  char *v43;
  char *v44;
  const char *v45;
  int v46;
  unsigned int v47;
  int v48;
  uint64_t v49;
  int v50;
  int v51;
  uint64_t v52;
  const char *v53;
  const char *v54;
  uint64_t v55;
  uint64_t v56;
  unsigned int v57;
  uint64_t v58;
  char *v59;
  char *v60;
  const char *v61;
  char *v62;
  const char *v63;

  v10 = (uint64_t *)(a1 + 240);
  if ((a6 & 1) != 0)
  {
    v23 = (unsigned int *)(a1 + 248);
    v24 = atomic_load((unsigned int *)(a1 + 248));
    v25 = *(unsigned int *)(a1 + 252);
    if (v24 >= v25)
    {
      v26 = 2 * v25;
      if (!(_DWORD)v25)
        v26 = 0x10000;
      *(_DWORD *)(a1 + 252) = v26;
      if (my_vm_reallocate((void **)(a1 + 240), 32 * v25, 32 * v26, 246, *(_QWORD *)(a1 + 104)))
      {
        v59 = __si_assert_copy_extra_268();
        v60 = v59;
        v61 = "";
        if (v59)
          v61 = v59;
        __message_assert("%s:%u: failed assertion '%s' %s ", "TermUpdateSet.c", 3230, "0 == kr", v61);
        goto LABEL_48;
      }
    }
    do
      v27 = __ldaxr(v23);
    while (__stlxr(v27 + 1, v23));
    v28 = *v10 + 32 * v27;
    *(_DWORD *)v28 = a5;
    *(_QWORD *)(v28 + 16) = 0;
    *(_QWORD *)(v28 + 4) = 0x100000000;
    *(_DWORD *)(v28 + 24) = a3;
    __src[2] = a3;
    __src[3] = v27;
    result = 1;
    __src[1] = 1;
    LODWORD(v28) = atomic_load(v23);
    if (v27 >= v28)
    {
      v29 = __si_assert_copy_extra_268();
      v30 = v29;
      v31 = "";
      if (v29)
        v31 = v29;
      __message_assert("%s:%u: failed assertion '%s' %s ", "TermUpdateSet.c", 3243, "termUpdateList->termId < positions->next_term_id", v31);
      v32 = v30;
      goto LABEL_37;
    }
  }
  else
  {
    v11 = *v10;
    v12 = __src[2];
    v13 = __src[3];
    v14 = (int *)(*v10 + 32 * v13);
    if (v12 == a3)
    {
      ++__src[1];
      v15 = (unsigned int *)(a1 + 264);
      if (atomic_load((unsigned int *)(a1 + 264)))
      {
        v17 = atomic_load(v15);
        atomic_load(v15);
        v18 = *(_QWORD *)(a1 + 256);
        v19 = atomic_load(v15);
        atomic_store(*(_DWORD *)(v18 + 8 * v19 + 4), v15);
        if (v17)
        {
LABEL_5:
          v20 = (int *)(*(_QWORD *)(a1 + 256) + 8 * v17);
LABEL_8:
          if (*v14 < a5)
          {
            result = 0;
            v22 = v14[1];
            *v20 = *v14;
            v20[1] = v22;
            *v14 = a5;
            v14[1] = v17;
            ++*(_DWORD *)(v11 + 32 * v13 + 8);
            return result;
          }
          v43 = __si_assert_copy_extra_268();
          v44 = v43;
          if (v43)
            v45 = v43;
          else
            v45 = "";
          v46 = *(_DWORD *)(a1 + 272);
          v47 = atomic_load((unsigned int *)(a1 + 268));
          v48 = *v14;
          v49 = v11 + 32 * v13;
          v50 = *(_DWORD *)(v49 + 8);
          v51 = *(_DWORD *)(v49 + 24);
          v52 = *(_QWORD *)(v49 + 16);
          v53 = (const char *)__si_error_str_key;
          if (__si_error_str_key)
            v53 = (const char *)pthread_getspecific(__si_error_str_key);
          if (v53)
            v54 = v53;
          else
            v54 = "";
          __message_assert("%s:%u: failed assertion '%s' %s ref:%d sz:%d cnt:%d pos:%d pos_prev:%d freq:%d doc:%d off:%llx %s", "CIPositions.h", 207, "position > node->info.position", v45, v17, v46, v47, a5, v48, v50, v51, v52, v54);
          v32 = v44;
LABEL_37:
          free(v32);
          if (__valid_fs(-1))
            v55 = 2989;
          else
            v55 = 3072;
          *(_DWORD *)v55 = -559038737;
          abort();
        }
      }
      else
      {
        v17 = positionInfoAlloc(a1 + 240, 8uLL);
        if (v17)
          goto LABEL_5;
      }
      v20 = 0;
      goto LABEL_8;
    }
    if (v12 == a4)
    {
      v33 = v11 + 32 * v13;
      v35 = *(_DWORD *)(v33 + 8);
      v34 = (unsigned int *)(v33 + 8);
      if (v35)
      {
        __src[1] = 1;
        __src[2] = a3;
        v36 = *v34;
        if (*v34 < 2)
          goto LABEL_44;
        v37 = 0;
        v38 = 1;
        v39 = v14;
        while (1)
        {
          v40 = v39[1];
          if (!(_DWORD)v40)
            break;
          v41 = *(_QWORD *)(a1 + 256);
          v39 = (int *)(v41 + 8 * v40);
          v14[1] = v39[1];
          if (v37)
          {
            v42 = atomic_load((unsigned int *)(a1 + 264));
            *(_DWORD *)(v41 + 8 * v37 + 4) = v42;
            atomic_store(v37, (unsigned int *)(a1 + 264));
            v36 = *v34;
          }
          ++v38;
          v37 = v40;
          if (v38 >= v36)
          {
            v56 = *(_QWORD *)(a1 + 256);
            v57 = atomic_load((unsigned int *)(a1 + 264));
            *(_DWORD *)(v56 + 8 * v40 + 4) = v57;
            atomic_store(v40, (unsigned int *)(a1 + 264));
            goto LABEL_44;
          }
        }
        v62 = __si_assert_copy_extra_268();
        v60 = v62;
        v63 = "";
        if (v62)
          v63 = v62;
        __message_assert("%s:%u: failed assertion '%s' %s ", "TermUpdateSet.c", 3188, "info", v63);
LABEL_48:
        free(v60);
        if (__valid_fs(-1))
        {
          MEMORY[0xBAD] = -559038737;
          abort();
        }
        MEMORY[0xC00] = -559038737;
        abort();
      }
    }
    addToExistingTermUpdateList(a1, __src, a3, 0, 1u);
    if (*(_DWORD *)(v11 + 32 * v13 + 8))
      CIPositionNodeFinalizeDocument((uint64_t)v10);
LABEL_44:
    *v14 = a5;
    v58 = v11 + 32 * v13;
    result = 1;
    *(_DWORD *)(v58 + 8) = 1;
    *(_DWORD *)(v58 + 24) = a3;
  }
  return result;
}

uint64_t decode_prefix(unsigned __int8 *a1, unsigned int a2, unsigned __int8 *a3)
{
  unint64_t v4;
  uint64_t v5;
  unsigned __int8 *v6;
  _BYTE *v7;
  uint64_t v8;
  int v9;
  unsigned __int8 *v10;
  unsigned __int8 *v11;
  unsigned __int8 *v12;
  unint64_t v13;
  uint64_t v14;
  unsigned __int8 *v15;
  unsigned __int8 *v16;
  uint64_t v17;
  int v18;
  unsigned __int8 *v19;
  int v20;
  char *v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  unsigned __int8 *v26;
  char v27;
  BOOL v28;
  unint64_t v29;
  unsigned __int8 *v30;
  unsigned __int8 *v31;
  uint64_t v32;
  int v33;
  unint64_t v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  char *v39;
  char v40;
  unsigned int v41;
  unsigned int v42;
  unint64_t v44;
  unsigned __int8 *v45;
  unsigned __int8 *v46;
  uint64_t v47;
  int v48;
  uint64_t v49;
  unint64_t v50;
  uint64_t v51;
  char *v52;
  uint64_t v53;
  int v54;
  unint64_t v55;
  unint64_t v56;
  uint64_t v57;
  int v58;
  uint64_t v59;
  char *v60;
  char v61;
  BOOL v62;
  unsigned int v64;
  unsigned int v65;

  v4 = (unint64_t)tcmr[*a1] >> 4;
  v5 = utf8_byte_length(unsigned char)::utf8_len_table[v4];
  if ((v4 & 0xC) != 8)
  {
    v6 = a1;
    v7 = a3;
    v8 = v5;
    do
    {
      v9 = *v6++;
      *v7++ = tcmr[v9];
      --v8;
    }
    while (v8);
  }
  v10 = &a3[v5];
  if (v5 >= a2)
  {
    LODWORD(v21) = (_DWORD)a3 + v5;
    return ((_DWORD)v21 - (_DWORD)a3);
  }
  v11 = &a1[v5];
  v12 = &a1[a2];
  v13 = (unint64_t)tcmr[a1[v5]] >> 4;
  v14 = utf8_byte_length(unsigned char)::utf8_len_table[v13];
  if ((v13 & 0xC) != 8)
  {
    v15 = &a1[v5];
    v16 = &a3[v5];
    v17 = v14;
    do
    {
      v18 = *v15++;
      *v16++ = tcmr[v18];
      --v17;
    }
    while (v17);
  }
  v19 = &v11[v14];
  if (&v11[v14] >= v12)
    goto LABEL_70;
  v20 = (char)*v10;
  if ((v20 & 0x80000000) == 0)
    goto LABEL_10;
  v22 = utf8_byte_length(unsigned char)::utf8_len_table[(unint64_t)*v10 >> 4];
  v23 = (utf8_to_code_point(unsigned char const*)::utf8_first_char_mask[v22] & *v10);
  if ((~((unint64_t)*v10 >> 4) & 0xC) != 0)
    goto LABEL_24;
  v24 = v22 <= 2 ? 2 : utf8_byte_length(unsigned char)::utf8_len_table[(unint64_t)*v10 >> 4];
  v25 = v24 - 1;
  v26 = &a3[v5 + 1];
  do
  {
    v27 = *v26++;
    v23 = v27 & 0x3F | (v23 << 6);
    --v25;
  }
  while (v25);
  if (v23 < 0x10000)
  {
LABEL_24:
    v28 = (v23 - 12441) >= 4 && (v23 - 65438) >= 2;
    if (v28 && !unicode_combinable((unsigned __int16)v23))
      goto LABEL_10;
  }
  else
  {
    v41 = v23 - 917760;
    v42 = v23 - 127995;
    if (v41 >= 0xF0 && v42 > 4)
      goto LABEL_10;
  }
  v10 += v14;
  v29 = (unint64_t)tcmr[*v19] >> 4;
  v14 = utf8_byte_length(unsigned char)::utf8_len_table[v29];
  if ((v29 & 0xC) != 8)
  {
    v30 = v19;
    v31 = v10;
    v32 = v14;
    do
    {
      v33 = *v30++;
      *v31++ = tcmr[v33];
      --v32;
    }
    while (v32);
  }
  v19 += v14;
  if (v19 >= v12)
    goto LABEL_70;
  LOBYTE(v20) = *v10;
LABEL_10:
  if (v20 != 45)
  {
    if (v20 == 239)
    {
      if (v10[1] != 188 || v10[2] != 189)
        goto LABEL_54;
    }
    else if (v20 != 226 || v10[1] != 128 || (v10[2] & 0xFE) != 0x90)
    {
      goto LABEL_54;
    }
  }
  v34 = *a3;
  if ((char)*a3 < 0)
  {
    v35 = utf8_byte_length(unsigned char)::utf8_len_table[v34 >> 4];
    v36 = utf8_to_code_point(unsigned char const*)::utf8_first_char_mask[v35] & v34;
    if ((~(v34 >> 4) & 0xC) != 0)
    {
      LODWORD(v34) = utf8_to_code_point(unsigned char const*)::utf8_first_char_mask[v35] & v34;
    }
    else
    {
      if (v35 <= 2)
        v37 = 2;
      else
        v37 = utf8_byte_length(unsigned char)::utf8_len_table[v34 >> 4];
      v38 = v37 - 1;
      v39 = (char *)(a3 + 1);
      do
      {
        v40 = *v39++;
        LODWORD(v34) = v40 & 0x3F | (v36 << 6);
        v36 = v34;
        --v38;
      }
      while (v38);
    }
  }
  if (((1 << u_charType(v34)) & 0xE3E) != 0)
  {
    v10 += v14;
    v44 = (unint64_t)tcmr[*v19] >> 4;
    v14 = utf8_byte_length(unsigned char)::utf8_len_table[v44];
    if ((v44 & 0xC) != 8)
    {
      v45 = v19;
      v46 = v10;
      v47 = v14;
      do
      {
        v48 = *v45++;
        *v46++ = tcmr[v48];
        --v47;
      }
      while (v47);
    }
    v19 += v14;
    if (v19 >= v12)
    {
LABEL_70:
      LODWORD(v21) = (_DWORD)v10 + v14;
      return ((_DWORD)v21 - (_DWORD)a3);
    }
  }
LABEL_54:
  v49 = v14;
  v21 = (char *)&v10[v14];
  v50 = (unint64_t)tcmr[*v19] >> 4;
  v51 = utf8_byte_length(unsigned char)::utf8_len_table[v50];
  if ((v50 & 0xC) != 8)
  {
    v52 = v21;
    v53 = v51;
    do
    {
      v54 = *v19++;
      *v52++ = tcmr[v54];
      --v53;
    }
    while (v53);
  }
  if (*v21 < 0)
  {
    v55 = *v21;
    v56 = v55 >> 4;
    v57 = utf8_byte_length(unsigned char)::utf8_len_table[v55 >> 4];
    v58 = v55 & utf8_to_code_point(unsigned char const*)::utf8_first_char_mask[v57];
    if ((~(_BYTE)v56 & 0xC) != 0)
      goto LABEL_65;
    v57 = v57 <= 2 ? 2 : v57;
    v59 = v57 - 1;
    v60 = (char *)&v10[v49 + 1];
    do
    {
      v61 = *v60++;
      v58 = v61 & 0x3F | (v58 << 6);
      --v59;
    }
    while (v59);
    if (v58 < 0x10000)
    {
LABEL_65:
      v62 = (v58 - 12441) >= 4 && (v58 - 65438) >= 2;
      if (v62 && !unicode_combinable((unsigned __int16)v58))
        return ((_DWORD)v21 - (_DWORD)a3);
LABEL_69:
      LODWORD(v21) = (_DWORD)v21 + v51;
      return ((_DWORD)v21 - (_DWORD)a3);
    }
    v64 = v58 - 917760;
    v65 = v58 - 127995;
    if (v64 < 0xF0 || v65 <= 4)
      goto LABEL_69;
  }
  return ((_DWORD)v21 - (_DWORD)a3);
}

uint64_t pushTerm(uint64_t a1, unint64_t a2, size_t a3, char *a4, unsigned int a5, int a6, unsigned int a7, unsigned int **a8)
{
  unsigned int *v15;
  uint64_t v16;
  char v17;
  char *v19;
  char *v20;
  char *v21;
  const char *v22;
  uint64_t v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (!a5)
  {
    MEMORY[0x1E0C80A78](a1);
    v19 = (char *)&v23 - ((a3 + 16) & 0xFFFFFFFFFFFFFFF0);
    v19[a3] = 0;
    memcpy(v19, a4, a3);
    v19[a3] = 0;
    v20 = __si_assert_copy_extra_268();
    v21 = v20;
    v22 = "";
    if (v20)
      v22 = v20;
    __message_assert("%s:%u: failed assertion '%s' %s expected non-zero docID for term %s", "TermUpdateSet.c", 3478, "docID", v22, v19);
    free(v21);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  HIBYTE(v23) = 0;
  v15 = (unsigned int *)pushTermTable(*(_QWORD *)(a1 + 24) + 16, **(_QWORD **)(a1 + 24), a2, a3, (unsigned __int8 *)a4, 1, (_BYTE *)&v23 + 7);
  v16 = pushContentTermData(a1, v15, a5, a6, a7, SHIBYTE(v23));
  if ((_DWORD)v16)
  {
    if (a4[a3 - 1] == 5)
      v17 = a4[a3 - 2];
    else
      v17 = 0;
    pushPrefixTerms(a1, a3, a4, 1u, "\x01", a5, a6, 0, v17);
  }
  *a8 = v15;
  return v16;
}

void pushPrefixTermsForWildCard(_QWORD **a1, uint64_t a2, char *a3, unsigned int a4, const void *a5, int a6)
{
  uint64_t v6;
  unsigned __int8 *v11;
  size_t v12;
  char *v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  unsigned __int8 *v20;
  char v21;
  BOOL v22;
  int64_t v23;
  size_t v24;
  uint64_t v25;
  char *v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  unsigned __int8 *v33;
  char v34;
  BOOL v35;
  size_t v36;
  size_t v37;
  unsigned int v38;
  unsigned int v39;
  unsigned int v41;
  unsigned int v42;
  _BYTE __dst[32];
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  v6 = utf8_byte_length(unsigned char)::utf8_len_table[(unint64_t)*a3 >> 4];
  if (v6 > a2)
    return;
  v11 = (unsigned __int8 *)&a3[a2];
  v12 = a4;
  v13 = &a3[v6];
  if (v6 < a2 && *v13 < 0)
  {
    v14 = *v13;
    v15 = v14 >> 4;
    v16 = utf8_byte_length(unsigned char)::utf8_len_table[v14 >> 4];
    v17 = v14 & utf8_to_code_point(unsigned char const*)::utf8_first_char_mask[v16];
    if ((~(_BYTE)v15 & 0xC) != 0)
      goto LABEL_11;
    v18 = v16 <= 2 ? 2 : v16;
    v19 = v18 - 1;
    v20 = (unsigned __int8 *)&a3[v6 + 1];
    do
    {
      v21 = *v20++;
      v17 = v21 & 0x3F | (v17 << 6);
      --v19;
    }
    while (v19);
    if (v17 < 0x10000)
    {
LABEL_11:
      v22 = (v17 - 12441) >= 4 && (v17 - 65438) >= 2;
      if (v22 && !unicode_combinable((unsigned __int16)v17))
        goto LABEL_16;
LABEL_15:
      v13 += v16;
      goto LABEL_16;
    }
    v38 = v17 - 917760;
    v39 = v17 - 127995;
    if (v38 < 0xF0 || v39 <= 4)
      goto LABEL_15;
  }
LABEL_16:
  v23 = v13 - a3;
  if ((unint64_t)(v13 - a3) <= 0x1F)
    v24 = 32 - (v13 - a3);
  else
    v24 = 0;
  bzero(&__dst[v23], v24);
  memcpy(__dst, a3, v13 - a3);
  memcpy(&__dst[v23], a5, v12);
  pushPropertyTermForWildCard(a1, v23 + v12, __dst, a6);
  v25 = utf8_byte_length(unsigned char)::utf8_len_table[(unint64_t)*v13 >> 4];
  v26 = &v13[v25];
  if (&v13[v25] <= (char *)v11)
  {
    if (&v13[v25] < (char *)v11 && *v26 < 0)
    {
      v27 = *v26;
      v28 = v27 >> 4;
      v29 = utf8_byte_length(unsigned char)::utf8_len_table[v27 >> 4];
      v30 = v27 & utf8_to_code_point(unsigned char const*)::utf8_first_char_mask[v29];
      if ((~(_BYTE)v28 & 0xC) != 0)
        goto LABEL_29;
      v31 = v29 <= 2 ? 2 : v29;
      v32 = v31 - 1;
      v33 = (unsigned __int8 *)&v13[v25 + 1];
      do
      {
        v34 = *v33++;
        v30 = v34 & 0x3F | (v30 << 6);
        --v32;
      }
      while (v32);
      if (v30 < 0x10000)
      {
LABEL_29:
        v35 = (v30 - 12441) >= 4 && (v30 - 65438) >= 2;
        if (v35 && !unicode_combinable((unsigned __int16)v30))
          goto LABEL_34;
      }
      else
      {
        v41 = v30 - 917760;
        v42 = v30 - 127995;
        if (v41 >= 0xF0 && v42 >= 5)
          goto LABEL_34;
      }
      v26 += v29;
    }
LABEL_34:
    v36 = v26 - a3;
    if (v36 <= 0x1F)
      v37 = 32 - v36;
    else
      v37 = 0;
    bzero(&__dst[v36], v37);
    memcpy(__dst, a3, v36);
    memcpy(&__dst[v36], a5, v12);
    pushPropertyTermForWildCard(a1, v36 + v12, __dst, a6);
  }
}

CFTypeID __termUpdateSetProcessVector_block_invoke()
{
  CFTypeID result;

  termUpdateSetProcessVector_sArrayTypeID = CFArrayGetTypeID();
  result = CFDictionaryGetTypeID();
  termUpdateSetProcessVector_sDictionaryTypeID = result;
  return result;
}

BOOL stringUnqBuffEqualCallback(unsigned __int16 *a1, unsigned __int16 *a2)
{
  int v2;

  v2 = *a1;
  return v2 == *a2 && memcmp(a1 + 1, a2 + 1, (__int16)v2) == 0;
}

uint64_t stringUnqBuffHashCallback(__int16 *a1)
{
  int v1;
  unsigned int v2;
  unsigned __int8 *v3;
  int v4;
  int v5;
  uint64_t v6;
  int v7;
  int v8;
  unint64_t v9;
  int v10;
  int v12;
  int v13;
  unint64_t v14;
  int v15;
  unsigned int v16;

  v1 = -1759636613;
  v2 = *a1;
  v3 = (unsigned __int8 *)a1 + (int)((__int16)(*a1 + ((v2 >> 29) & 3)) & 0xFFFFFFFC) + 2;
  if (v2 + 3 >= 7)
  {
    v6 = -((__int16)(v2 + ((v2 >> 29) & 3)) >> 2);
    v7 = -1789642873;
    v8 = 718793509;
    do
    {
      v7 = 5 * v7 + 2071795100;
      v8 = 5 * v8 + 1808688022;
      HIDWORD(v9) = v7 * *(_DWORD *)&v3[4 * v6];
      LODWORD(v9) = HIDWORD(v9);
      v10 = (v9 >> 21) * v8;
      HIDWORD(v9) = v1;
      LODWORD(v9) = v1;
      v1 = v10 ^ (5 * (v9 >> 19) + 1390208809);
    }
    while (!__CFADD__(v6++, 1));
    v5 = 5 * v7 + 2071795100;
    v4 = 5 * v8 + 1808688022;
  }
  else
  {
    v4 = 1107688271;
    v5 = 1713515327;
  }
  v12 = 0;
  v13 = v2 & 3;
  switch(v13)
  {
    case 1:
      goto LABEL_12;
    case 2:
LABEL_11:
      v12 |= *((unsigned __int8 *)a1 + (int)((__int16)(*a1 + ((*a1 >> 29) & 3)) & 0xFFFFFFFC) + 3) << 8;
LABEL_12:
      HIDWORD(v14) = (v12 ^ *v3) * v5;
      LODWORD(v14) = HIDWORD(v14);
      v15 = (v14 >> 21) * v4;
      HIDWORD(v14) = v1;
      LODWORD(v14) = v1;
      v1 = v15 ^ (5 * (v14 >> 19) + 1390208809);
      break;
    case 3:
      v12 = *((unsigned __int8 *)a1 + (int)((__int16)(*a1 + ((*a1 >> 29) & 3)) & 0xFFFFFFFC) + 4) << 16;
      goto LABEL_11;
  }
  v16 = (-2048144789 * (v1 ^ v2)) ^ ((-2048144789 * (v1 ^ v2)) >> 13);
  return ((53 * v16) ^ ((-1028477387 * v16) >> 16));
}

uint64_t termUpdateSetApplier(uint64_t a1, uint64_t (**a2)(void))
{
  char *v3;
  char *v4;
  const char *v5;

  if (*(unsigned __int16 *)(a1 + 16) >= 0x415u)
  {
    v3 = __si_assert_copy_extra_268();
    v4 = v3;
    v5 = "";
    if (v3)
      v5 = v3;
    __message_assert("%s:%u: failed assertion '%s' %s ", "TermUpdateSet.c", 2371, "tu->termLen <= (1024+20)", v5);
    free(v4);
    if (__valid_fs(-1))
    {
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    MEMORY[0xC00] = -559038737;
    abort();
  }
  return (*a2)();
}

void SIUserCtxSetArgumentDictionary(uint64_t a1, CFTypeRef cf)
{
  const void *v4;

  if (a1)
  {
    v4 = *(const void **)(a1 + 168);
    if (v4)
      CFRelease(v4);
    *(_QWORD *)(a1 + 168) = 0;
    if (cf)
      CFRetain(cf);
    *(_QWORD *)(a1 + 168) = cf;
  }
}

uint64_t SIUserCtxGetEntitlements(uint64_t result)
{
  if (result)
    return *(unsigned int *)(result + 176);
  return result;
}

uint64_t SISetDefaultSchemaData(void *a1, size_t a2)
{
  uint64_t result;

  if (gDefaultSchema)
    return munmap(a1, a2);
  result = _MDPlistContainerCreateWithBytes();
  gDefaultSchema = result;
  return result;
}

_DWORD *TokenDataCreate(const char *a1, int a2)
{
  int64_t v4;
  _DWORD *v5;
  int64_t v6;
  int v7;

  v4 = strlen(a1);
  v5 = 0;
  if (v4)
  {
    v6 = v4;
    if (v4 <= 1022)
    {
      if (v4 >= 2 && a1[v4 - 1] == 42)
      {
        v7 = a1[v4 - 2];
        a2 |= v7 != 92;
        if (v7 != 92)
          v6 = v4 - 1;
      }
      if (v6 <= utf8_byte_length_noerror(unsigned char)::utf8_len_table[(unint64_t)*(unsigned __int8 *)a1 >> 4])
      {
        return 0;
      }
      else
      {
        if (*MEMORY[0x1E0C85AD8] <= 0x2FuLL)
          ++sTotal_3124;
        v5 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x30uLL, 0x31F9A007uLL);
        if (!v5)
          _log_fault_for_malloc_failure();
        *v5 = 0;
        v5[5] = v6;
        *((_QWORD *)v5 + 1) = strndup(a1, v6);
        v5[4] = a2;
      }
    }
  }
  return v5;
}

uint64_t TokenDataAddRange(uint64_t a1, int a2)
{
  char *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  int v8;
  unint64_t v9;
  int v10;
  int v11;
  char *v12;
  __int16 v13;
  __int16 v14;
  uint64_t v15;
  int v17;
  int v18;
  int v19;
  char *v20;
  int v21;
  uint64_t v22;
  uint64_t v23;

  if (!a1)
    return 0;
  os_unfair_lock_lock((os_unfair_lock_t)a1);
  v4 = *(char **)(a1 + 32);
  v6 = *(int *)(a1 + 40);
  v5 = *(int *)(a1 + 44);
  v7 = (unint64_t)(v6 - v5) >> 2;
  if ((int)v7 < 1)
  {
    v11 = 0;
    v14 = 0;
LABEL_15:
    if (v11 >= (int)v7 || v14 <= 0)
      v17 = v11;
    else
      v17 = v11 + 1;
    if ((int)v5 <= 3)
    {
      v18 = 2 * v6;
      if (!(_DWORD)v6)
        v18 = 128;
      do
      {
        v19 = v18;
        v18 *= 2;
      }
      while (v19 < 4);
      v20 = (char *)malloc_type_malloc(v19, 0xA1AE6110uLL);
      v4 = v20;
      v21 = v6 - v5;
      if (v21)
      {
        memcpy(&v20[v19 - v21], (const void *)(*(_QWORD *)(a1 + 32) + *(int *)(a1 + 40) - v21), v21);
        free(*(void **)(a1 + 32));
      }
      *(_QWORD *)(a1 + 32) = v4;
      *(_DWORD *)(a1 + 40) = v19;
      LODWORD(v5) = v19 - v21;
    }
    v22 = (int)v5 - 4;
    *(_DWORD *)(a1 + 44) = v22;
    if (v17)
    {
      v23 = v17;
      memmove(&v4[v22], &v4[(int)v5], 4 * v17);
      v4 = *(char **)(a1 + 32);
      LODWORD(v22) = *(_DWORD *)(a1 + 44);
    }
    else
    {
      v23 = 0;
    }
    *(_DWORD *)&v4[4 * v23 + (int)v22] = a2;
    if ((a2 >> 16) + (__int16)a2 == *(_DWORD *)(a1 + 20))
      ++*(_DWORD *)(a1 + 24);
    v15 = 1;
  }
  else
  {
    v8 = 0;
    v9 = (unint64_t)(v6 - v5) >> 2;
    while (1)
    {
      v10 = v9 + v8;
      if ((int)v9 + v8 < 0 != __OFADD__((_DWORD)v9, v8))
        ++v10;
      v11 = v10 >> 1;
      v12 = &v4[4 * v11 + v5];
      v13 = *((_WORD *)v12 + 1);
      v14 = HIWORD(a2) + a2 - (*(_WORD *)v12 + v13);
      if (!v14)
      {
        v14 = HIWORD(a2) - v13;
        if (HIWORD(a2) == v13)
          break;
      }
      if (v14 >= 0)
        v8 = v11 + 1;
      else
        LODWORD(v9) = v11;
      if (v8 >= (int)v9)
        goto LABEL_15;
    }
    v15 = 0;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)a1);
  return v15;
}

uint64_t TokenDataGetTokens(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  size_t v7;
  char *v8;
  int v9;
  _QWORD v11[9];

  v11[8] = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(result + 24))
  {
    v3 = result;
    v4 = *(int *)(result + 44);
    v5 = *(_QWORD *)(result + 32) + v4;
    v6 = (*(_DWORD *)(result + 40) - v4) >> 2;
    MEMORY[0x1E0C80A78](result);
    v8 = (char *)&v11[-1] - ((v7 + 15) & 0x3FFFFFFF0);
    bzero(v8, v7);
    v9 = *(__int16 *)(v3 + 20);
    v11[0] = MEMORY[0x1E0C809B0];
    v11[1] = 0x40000000;
    v11[2] = __TokenDataGetTokens_block_invoke;
    v11[3] = &unk_1E6E2F520;
    v11[4] = a2;
    v11[5] = v5;
    v11[6] = v8;
    v11[7] = v3;
    return TokenDataProcessStrings(v5, (__int16)(v6 - 1), v9, (uint64_t)v8, 0, (uint64_t)v11);
  }
  return result;
}

uint64_t TokenDataProcessStrings(uint64_t result, int a2, int a3, uint64_t a4, int a5, uint64_t a6)
{
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int16 *v13;
  int v14;
  unsigned __int16 v15;
  int v16;
  int v18;

  if ((a2 & 0x80000000) == 0)
  {
    v9 = a2;
    v10 = result;
    v11 = a5;
    v12 = (__int16)(a5 + 1);
    do
    {
      while (1)
      {
        v13 = (unsigned __int16 *)(v10 + 4 * (unsigned __int16)v9);
        v14 = *v13;
        v15 = v13[1] + v14;
        if (v15 != (unsigned __int16)a3)
          break;
        *(_WORD *)(a4 + 2 * v11) = v9;
        if (v14)
        {
          v16 = v9 - 1;
          result = TokenDataProcessStrings(v10, (__int16)(v9 - 1), (__int16)v14, a4, v12, a6);
        }
        else
        {
          result = (*(uint64_t (**)(uint64_t, uint64_t))(a6 + 16))(a6, v12);
          v16 = v9 - 1;
        }
        v18 = (__int16)v9;
        v9 = v16;
        if (v18 <= 0)
          return result;
      }
    }
    while ((__int16)v15 >= a3 && (__int16)v9-- > 0);
  }
  return result;
}

void TokenDataDispose(void **a1)
{
  if (a1)
  {
    free(a1[1]);
    free(a1[4]);
    free(a1);
  }
}

void _qsort_offset_triple(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  BOOL v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  _OWORD *v22;
  uint64_t v23;
  uint64_t *v24;
  char *v25;
  char *v26;
  const char *v27;
  uint64_t v28;
  __int128 v29;
  __int128 v30;

  v6 = malloc_type_malloc(0x800uLL, 0x1000040451B5BE8uLL);
  *v6 = 0;
  v6[1] = 0;
  v7 = 1;
  do
  {
    if (a3 > a2)
    {
      if (v7 <= 128)
        v8 = 128;
      else
        v8 = v7;
      v9 = &v6[2 * v7 + 1];
      while (a3 - a2 > 16)
      {
        v10 = _partition_offset_triple(a1, a2, a3);
        v11 = v10 - a2;
        if (v10 < a2)
        {
          v25 = __si_assert_copy_extra(0);
          v26 = v25;
          v27 = "";
          if (v25)
            v27 = v25;
          __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 1312, "q>=left", v27);
          free(v26);
          if (__valid_fs(-1))
            v28 = 2989;
          else
            v28 = 3072;
          *(_DWORD *)v28 = -559038737;
          abort();
        }
        if (v8 == v7)
        {
          heapsort_b((void *)(a1 + 24 * a2), a3 - a2 + 1, 0x18uLL, &__block_literal_global_3144);
          v7 = v8;
          goto LABEL_27;
        }
        v12 = v11 <= a3 - v10;
        if (v11 <= a3 - v10)
          v13 = v10 - 1;
        else
          v13 = a3;
        if (v12)
          v14 = a2;
        else
          v14 = v10;
        if (v12)
          a2 = v10;
        else
          a3 = v10 - 1;
        *(v9 - 1) = v14;
        *v9 = v13;
        ++v7;
        v9 += 2;
        if (a3 <= a2)
          goto LABEL_27;
      }
      v15 = a1 + 32 + 24 * a2;
      v16 = a2;
      do
      {
        v17 = v16++;
        v18 = a1 + 24 * v17;
        v19 = *(_QWORD *)(v18 + 24);
        v20 = *(_QWORD *)v18;
        v29 = *(_OWORD *)(v18 + 8);
        v30 = *(_OWORD *)(v18 + 32);
        v21 = v16;
        if (v20 > v19)
        {
          v22 = (_OWORD *)v15;
          do
          {
            v21 = v17;
            *((_QWORD *)v22 - 1) = v20;
            *v22 = v29;
            if (v17 <= a2)
              break;
            v20 = *((_QWORD *)v22 - 7);
            v29 = *(v22 - 3);
            v22 = (_OWORD *)((char *)v22 - 24);
            --v17;
          }
          while (v20 > v19);
        }
        v23 = a1 + 24 * v21;
        *(_QWORD *)v23 = v19;
        *(_OWORD *)(v23 + 8) = v30;
        v15 += 24;
      }
      while (v16 != a3);
    }
LABEL_27:
    --v7;
    v24 = &v6[2 * v7];
    a2 = *v24;
    a3 = v24[1];
  }
  while (v7);
  free(v6);
}

uint64_t _partition_offset_triple(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t *v7;
  unint64_t *v8;
  unint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  uint64_t *v15;
  uint64_t *v16;
  uint64_t v18;
  uint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  BOOL v25;
  uint64_t *v26;
  unint64_t *v27;
  unint64_t *v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t *v32;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v38;
  __int128 v39;
  unint64_t v40;
  uint64_t v41;
  _OWORD *v42;
  unint64_t v43;
  __int128 *v44;
  __int128 v45;
  __int128 *v46;
  unint64_t v47;
  __int128 v48;
  unint64_t v49;
  __int128 v51;
  __int128 v52;
  __int128 v53;

  v3 = a3 - a2;
  v4 = a3 - a2 + 1;
  v5 = (uint64_t *)(a1 + 24 * a2);
  v6 = a3 - a2 + 2;
  if (a3 - a2 >= -1)
    v6 = v3 + 1;
  v7 = &v5[3 * (v6 >> 1)];
  v8 = (unint64_t *)(a1 + 24 * a3);
  if (v3 < 1024)
  {
    v13 = (unint64_t *)(a1 + 24 * a2);
    v26 = v7;
    v27 = (unint64_t *)(a1 + 24 * a3);
  }
  else
  {
    v9 = v4 >> 3;
    v10 = (unint64_t *)&v5[3 * (v4 >> 3)];
    v11 = *v5;
    v12 = *v10;
    v13 = (unint64_t *)(a1 + 24 * a2);
    if (*v5 != *v10)
    {
      v13 = (unint64_t *)&v5[6 * v9];
      v14 = *v13;
      if (v11 >= *v13)
        v15 = &v5[6 * v9];
      else
        v15 = (uint64_t *)(a1 + 24 * a2);
      if (v12 > v14)
        v15 = (uint64_t *)v10;
      if (v11 >= v14)
        v16 = (uint64_t *)(a1 + 24 * a2);
      else
        v16 = &v5[6 * v9];
      if (v12 >= v14)
        v10 = (unint64_t *)v16;
      if (v11 >= v12)
        v10 = (unint64_t *)v15;
      if (v14 != v11 && v14 != v12)
        v13 = v10;
    }
    v18 = 2 * v9;
    v19 = -(uint64_t)v9;
    v20 = (unint64_t *)&v7[-3 * v9];
    v21 = *v20;
    v22 = *v7;
    if (*v20 == *v7)
    {
      v26 = &v7[-3 * v9];
    }
    else
    {
      v23 = (unint64_t *)&v7[3 * v9];
      v24 = *v23;
      v25 = *v23 == v21 || v24 == v22;
      v26 = &v7[3 * v9];
      if (!v25)
      {
        v26 = v7;
        if (v21 >= v22)
        {
          if (v22 <= v24)
          {
            if (v21 >= v24)
              v26 = (uint64_t *)v23;
            else
              v26 = (uint64_t *)v20;
          }
        }
        else if (v22 >= v24)
        {
          if (v21 >= v24)
            v26 = (uint64_t *)v20;
          else
            v26 = (uint64_t *)v23;
        }
      }
    }
    v27 = &v8[-3 * v18];
    v28 = &v8[3 * v19];
    v29 = *v27;
    v30 = *v28;
    if (*v27 != *v28)
    {
      v31 = *v8;
      if (v29 >= *v8)
        v32 = (unint64_t *)(a1 + 24 * a3);
      else
        v32 = v27;
      if (v30 > v31)
        v32 = v28;
      if (v29 < v31)
        v27 = (unint64_t *)(a1 + 24 * a3);
      if (v30 < v31)
        v27 = v28;
      if (v29 >= v30)
        v27 = v32;
      if (v31 == v29 || v31 == v30)
        v27 = (unint64_t *)(a1 + 24 * a3);
    }
  }
  v34 = *v13;
  v35 = *v26;
  if (*v13 == *v26)
  {
    v26 = (uint64_t *)v13;
  }
  else
  {
    v36 = *v27;
    if (*v27 == v34 || v36 == v35)
    {
      v26 = (uint64_t *)v27;
    }
    else if (v34 >= v35)
    {
      if (v35 <= v36)
      {
        if (v34 >= v36)
          v26 = (uint64_t *)v27;
        else
          v26 = (uint64_t *)v13;
      }
    }
    else if (v35 >= v36)
    {
      if (v34 >= v36)
        v26 = (uint64_t *)v13;
      else
        v26 = (uint64_t *)v27;
    }
  }
  v38 = *v26;
  v53 = *(_OWORD *)(v26 + 1);
  v39 = *(_OWORD *)v8;
  v26[2] = v8[2];
  *(_OWORD *)v26 = v39;
  *v8 = v38;
  *(_OWORD *)(v8 + 1) = v53;
  v40 = *v5;
  v52 = *(_OWORD *)(v5 + 1);
  v41 = a3 - a2;
  if (a3 > a2)
  {
    v42 = (_OWORD *)(a1 + 24 * a2 + 32);
    do
    {
      v43 = *((_QWORD *)v42 - 1);
      v51 = v52;
      v52 = *v42;
      if (v40 <= v38)
      {
        v44 = (__int128 *)(a1 + 24 * a2);
        v45 = *v44;
        *((_QWORD *)v42 - 2) = *((_QWORD *)v44 + 2);
        *(v42 - 2) = v45;
        *(_QWORD *)v44 = v40;
        *(__int128 *)((char *)v44 + 8) = v51;
        ++a2;
      }
      v42 = (_OWORD *)((char *)v42 + 24);
      v40 = v43;
      --v41;
    }
    while (v41);
  }
  v46 = (__int128 *)(a1 + 24 * a2);
  v47 = *((_QWORD *)v46 + 2);
  v48 = *v46;
  v49 = v8[2];
  *v46 = *(_OWORD *)v8;
  *((_QWORD *)v46 + 2) = v49;
  *(_OWORD *)v8 = v48;
  v8[2] = v47;
  return a2;
}

uint64_t ___qsort_offset_triple_block_invoke(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  unsigned int v3;

  if (*a2 == *a3)
    v3 = 0;
  else
    v3 = -1;
  if (*a2 > *a3)
    return 1;
  else
    return v3;
}

void _qsort_big_offset_triple(void *a1)
{
  uint64_t v1;
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  signed int v6;
  unint64_t i;
  uint64_t v8;
  uint64_t v10;
  host_t v11;
  mach_error_t v12;
  unint64_t v13;
  unint64_t v14;
  NSObject *v15;
  qos_class_t v16;
  NSObject *global_queue;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _DWORD *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  int v26;
  int v27;
  qos_class_t v28;
  NSObject *v29;
  qos_class_t v30;
  NSObject *v31;
  char *v32;
  char *v33;
  const char *v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  _QWORD block[5];
  mach_msg_type_number_t host_info_outCnt;
  integer_t host_info_out[4];
  __int128 v42;
  __int128 v43;

  v1 = *((_QWORD *)a1 + 1);
  v2 = *((_QWORD *)a1 + 2);
  v3 = *((_QWORD *)a1 + 3);
  v4 = *((_QWORD *)a1 + 4);
  v5 = *((_QWORD *)a1 + 5);
  v37 = *((_QWORD *)a1 + 6);
  v38 = *(_QWORD *)a1;
  v6 = *((_DWORD *)a1 + 14);
  v36 = *((_DWORD *)a1 + 15);
  OSAtomicEnqueue(&qsort_cached_allocations_3147, a1, 0);
  if (v2 > v1)
  {
    for (i = v4 + 1; ; ++i)
    {
      v8 = v2 - v1;
      if (v2 - v1 <= v5 || i > 9)
        break;
      if (v6 <= 1)
        v6 = 1;
      v10 = getSize_memSize_3149;
      if (!getSize_memSize_3149)
      {
        v42 = 0u;
        v43 = 0u;
        *(_OWORD *)host_info_out = 0u;
        v11 = MEMORY[0x1BCCB1010]();
        host_info_outCnt = 12;
        v12 = host_info(v11, 1, host_info_out, &host_info_outCnt);
        if (v12)
        {
          mach_error("flushsize", v12);
          exit(1);
        }
        v10 = *((_QWORD *)&v43 + 1);
        getSize_memSize_3149 = *((_QWORD *)&v43 + 1);
      }
      v13 = 3 * v10;
      v14 = (v13 * (unsigned __int128)0xCCCCCCCCCCCCCCCDLL) >> 64;
      v15 = v3;
      if (24 * v8 > v13 / 5)
        v15 = dispatch_group_create();
      if (v8 <= v37 || 24 * v8 >= v14 >> 2)
      {
        v18 = _partition_offset_triple(v38, v1, v2);
      }
      else
      {
        v16 = qos_class_self();
        global_queue = dispatch_get_global_queue(v16, 2uLL);
        v18 = _big_partition_offset_triple(v38, v1, v2, global_queue, v6);
      }
      v19 = v18;
      v20 = v18 - v1;
      if (v18 < v1)
      {
        v32 = __si_assert_copy_extra(0);
        v33 = v32;
        v34 = "";
        if (v32)
          v34 = v32;
        __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 1312, "q>=left", v34);
        free(v33);
        if (__valid_fs(-1))
          v35 = 2989;
        else
          v35 = 3072;
        *(_DWORD *)v35 = -559038737;
        abort();
      }
      v21 = OSAtomicDequeue(&qsort_cached_allocations_3147, 0);
      if (!v21)
        v21 = malloc_type_malloc(0x40uLL, 0x102004053A8A26AuLL);
      *((_QWORD *)v21 + 4) = i;
      *((_QWORD *)v21 + 5) = v5;
      *((_QWORD *)v21 + 6) = v37;
      v22 = v2 - v19;
      if (v20 <= v2 - v19)
      {
        v23 = v19 - 1;
      }
      else
      {
        v22 = v19 - 1 - v1;
        v23 = v2;
      }
      if (v20 > v2 - v19)
        v24 = v19;
      else
        v24 = v1;
      if (v20 > v2 - v19)
        v2 = v19 - 1;
      else
        v1 = v19;
      *(_QWORD *)v21 = v38;
      *((_QWORD *)v21 + 1) = v24;
      v25 = (int)(float)((float)((float)(v22 + 1) / (float)(v23 - v24 + 1)) * (float)v6);
      if (v25 <= 1)
        v26 = 1;
      else
        v26 = v25;
      if (v6 >= v25)
        v27 = v26;
      else
        v27 = 0;
      v21[14] = v6 - v27;
      v21[15] = v36;
      *((_QWORD *)v21 + 2) = v23;
      *((_QWORD *)v21 + 3) = v15;
      if (v15 == v3)
      {
        if (v6 >= v25)
          v6 = v26;
        v30 = qos_class_self();
        v31 = dispatch_get_global_queue(v30, 2uLL);
        dispatch_group_async_f(v3, v31, v21, (dispatch_function_t)_qsort_big_offset_triple);
      }
      else
      {
        v21[14] = v6;
        _qsort_big_offset_triple(v21);
        dispatch_group_wait(v15, 0xFFFFFFFFFFFFFFFFLL);
        dispatch_release(v15);
        v28 = qos_class_self();
        v29 = dispatch_get_global_queue(v28, 2uLL);
        block[0] = MEMORY[0x1E0C809B0];
        block[1] = 0x40000000;
        block[2] = ___qsort_big_offset_triple_block_invoke;
        block[3] = &__block_descriptor_tmp_62_3151;
        block[4] = v21;
        dispatch_async(v29, block);
      }
      if (v2 <= v1)
        return;
    }
    _qsort_offset_triple(v38, v1, v2);
  }
}

uint64_t _big_partition_offset_triple(uint64_t a1, uint64_t a2, uint64_t a3, NSObject *a4, unsigned int a5)
{
  uint64_t v7;
  BOOL v8;
  unint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t *v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t *v18;
  unint64_t v19;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t *v27;
  unint64_t v28;
  BOOL v29;
  uint64_t *v30;
  unint64_t *v31;
  unint64_t *v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t *v36;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;

  v7 = a3 - a2;
  v8 = __OFADD__(a3 - a2, 1);
  v9 = a3 - a2 + 1;
  v10 = (uint64_t *)(a1 + 24 * a2);
  v11 = v7 + 2;
  if (((v9 & 0x8000000000000000) != 0) == v8)
    v11 = v7 + 1;
  v12 = &v10[3 * (v11 >> 1)];
  v13 = (unint64_t *)(a1 + 24 * a3);
  if (v7 < 64)
  {
    v30 = v12;
    v18 = v10;
  }
  else
  {
    v14 = v9 >> 3;
    v15 = (unint64_t *)&v10[3 * (v9 >> 3)];
    v16 = *v10;
    v17 = *v15;
    v18 = v10;
    if (*v10 != *v15)
    {
      v18 = &v10[6 * v14];
      v19 = *v18;
      if (*v18 != v16 && v19 != v17)
      {
        if (v16 >= v19)
          v21 = &v10[6 * v14];
        else
          v21 = v10;
        if (v17 > v19)
          v21 = &v10[3 * (v9 >> 3)];
        if (v16 >= v19)
          v18 = v10;
        if (v17 < v19)
          v18 = &v10[3 * (v9 >> 3)];
        if (v16 >= v17)
          v18 = v21;
      }
    }
    v22 = 2 * v14;
    v23 = -(uint64_t)v14;
    v24 = &v12[-3 * v14];
    v25 = *v24;
    v26 = *v12;
    if (*v24 == *v12)
    {
      v30 = &v12[-3 * v14];
    }
    else
    {
      v27 = &v12[3 * v14];
      v28 = *v27;
      v29 = *v27 == v25 || v28 == v26;
      v30 = &v12[3 * v14];
      if (!v29)
      {
        v30 = v12;
        if (v25 >= v26)
        {
          if (v26 <= v28)
          {
            if (v25 >= v28)
              v30 = v27;
            else
              v30 = v24;
          }
        }
        else if (v26 >= v28)
        {
          if (v25 >= v28)
            v30 = v24;
          else
            v30 = v27;
        }
      }
    }
    v31 = &v13[-3 * v22];
    v32 = &v13[3 * v23];
    v33 = *v31;
    v34 = *v32;
    if (*v31 == *v32)
    {
      v13 = v31;
    }
    else
    {
      v35 = *v13;
      if (v33 >= *v13)
        v36 = v13;
      else
        v36 = v31;
      if (v34 > v35)
        v36 = v32;
      if (v33 < v35)
        v31 = v13;
      if (v34 < v35)
        v31 = v32;
      if (v33 >= v34)
        v31 = v36;
      if (v35 != v33 && v35 != v34)
        v13 = v31;
    }
  }
  v38 = *v18;
  v39 = *v30;
  if (*v18 == *v30)
  {
    v30 = v18;
  }
  else
  {
    v40 = *v13;
    if (*v13 == v38 || v40 == v39)
    {
      v30 = (uint64_t *)v13;
    }
    else if (v38 >= v39)
    {
      if (v39 <= v40)
      {
        if (v38 >= v40)
          v30 = (uint64_t *)v13;
        else
          v30 = v18;
      }
    }
    else if (v39 >= v40)
    {
      if (v38 >= v40)
        v30 = v18;
      else
        v30 = (uint64_t *)v13;
    }
  }
  return parallel_partition_offset_triple(v10, v9, *v30, a4, a5) + a2;
}

void ___qsort_big_offset_triple_block_invoke(uint64_t a1)
{
  madvise((void *)(**(_QWORD **)(a1 + 32) + 24 * *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8)), 24 * (*(_QWORD *)(*(_QWORD *)(a1 + 32) + 16) - *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8)), 4);
  OSAtomicEnqueue(&qsort_cached_allocations_3147, *(void **)(a1 + 32), 0);
}

uint64_t parallel_partition_offset_triple(void *a1, uint64_t a2, uint64_t a3, NSObject *a4, unsigned int a5)
{
  int v5;
  size_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD v17[2];
  _QWORD context[10];

  v5 = a5;
  v17[1] = v17;
  context[9] = *MEMORY[0x1E0C80C00];
  context[6] = a1;
  v10 = 8 * a5;
  MEMORY[0x1E0C80A78](a1);
  v12 = (char *)v17 - v11;
  bzero((char *)v17 - v11, v10);
  v13 = (a2 / 0x4000) << 13;
  context[1] = v13;
  context[2] = a2;
  context[4] = 0;
  context[5] = 0;
  v14 = a2 - v13;
  context[7] = a3;
  context[8] = v12;
  if (v5 >= 1)
    memset(v12, 255, v10);
  v15 = v13 + 0x2000;
  if (v14 > v13 + 0x2000)
    v15 = a2 - ((a2 / 0x4000) << 13);
  context[3] = v14 + ((v15 - v14 + 0x1FFF) & 0xFFFFFFFFFFFFE000);
  context[0] = 0;
  if (24 * a2 >= (unint64_t)(4 * *MEMORY[0x1E0C85AD8]))
    madvise(a1, 24 * a2, 3);
  if (a2 / 0x4000 < v5)
    v5 = a2 / 0x4000;
  dispatch_apply_f(v5, a4, context, (void (__cdecl *)(void *, size_t))partition_phase_offset_triple);
  return sequential_fixup_offset_triple((uint64_t)context, a2, v5);
}

int64_t partition_phase_offset_triple(OSAtomic_int64_aligned64_t *a1, uint64_t a2)
{
  OSAtomic_int64_aligned64_t v4;
  int64_t Left_Block_offset_triple;
  int64_t Right_Block_offset_triple;
  uint64_t v7;
  _BOOL4 v8;
  uint64_t v9;
  int v10;
  int v11;
  int64_t v12;
  uint64_t v14;
  uint64_t v15;

  v4 = a1[6];
  Left_Block_offset_triple = Get_Left_Block_offset_triple(a1);
  Right_Block_offset_triple = Get_Right_Block_offset_triple((uint64_t)a1);
  v7 = 0;
  v14 = 0;
  v15 = 0;
  v8 = Left_Block_offset_triple != -1;
  if (Right_Block_offset_triple == -1 || Left_Block_offset_triple == -1)
  {
    v9 = 0;
  }
  else
  {
    v9 = 0;
    v7 = 0;
    do
    {
      v10 = neutralize_offset_triple(v4 + 24 * Left_Block_offset_triple, v4 + 24 * Right_Block_offset_triple, a1[7], &v15, &v14);
      if ((v10 & 1) != 0
        || (v11 = v10,
            Left_Block_offset_triple = Get_Left_Block_offset_triple(a1),
            v15 = 0,
            ++v7,
            (v11 - 1) <= 1))
      {
        Right_Block_offset_triple = Get_Right_Block_offset_triple((uint64_t)a1);
        v14 = 0;
        ++v9;
      }
      v8 = Left_Block_offset_triple != -1;
    }
    while (Right_Block_offset_triple != -1 && Left_Block_offset_triple != -1);
  }
  if (v8)
    v12 = Left_Block_offset_triple;
  else
    v12 = Right_Block_offset_triple;
  *(_QWORD *)(a1[8] + 8 * a2) = v12;
  OSAtomicAdd64(v7 << 13, a1 + 4);
  return OSAtomicAdd64(v9 << 13, a1 + 5);
}

uint64_t sequential_fixup_offset_triple(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  BOOL v13;
  uint64_t v14;
  unint64_t v15;
  void *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  unint64_t *v40;
  unint64_t *v41;
  unint64_t v42;
  __int128 v43;
  unint64_t v44;
  uint64_t v45;
  char *v47;
  char *v48;
  const char *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;

  v6 = a3;
  qsort(*(void **)(a1 + 64), a3, 8uLL, (int (__cdecl *)(const void *, const void *))index_comp_3153);
  v51 = 0;
  v52 = 0;
  v7 = *(_QWORD *)(a1 + 64);
  v8 = a3 - 1;
  v9 = 0;
  if (a3 < 1)
    goto LABEL_91;
  while (*(_QWORD *)(v7 + 8 * v9) == -1)
  {
    if (v6 == ++v9)
    {
      v9 = v6;
      break;
    }
  }
  if (a3 == 1)
  {
    v8 = 0;
  }
  else
  {
LABEL_91:
    do
    {
      if (*(_QWORD *)(v7 + 8 * v8) != -1)
        break;
      --v8;
    }
    while (v8);
  }
  while (v9 < v8)
  {
    v10 = neutralize_offset_triple(*(_QWORD *)(a1 + 48) + 24 * *(_QWORD *)(v7 + 8 * v9), *(_QWORD *)(a1 + 48) + 24 * *(_QWORD *)(v7 + 8 * v8), *(_QWORD *)(a1 + 56), &v51, &v52);
    v7 = *(_QWORD *)(a1 + 64);
    if ((v10 & 1) == 0)
    {
      v11 = *(_QWORD *)(v7 + 8 * v9);
      if ((v11 & 0x8000000000000000) == 0 && v11 < *(_QWORD *)(a1 + 32))
      {
        *(_QWORD *)(v7 + 8 * v9) = -1;
        *(_QWORD *)(a1 + 32) += 0x2000;
      }
      ++v9;
      v51 = 0;
      if ((v10 - 1) > 1)
        continue;
    }
    v12 = *(_QWORD *)(v7 + 8 * v8);
    v13 = v12 >= a2 || v12 < a2 - *(_QWORD *)(a1 + 40);
    if (!v13)
    {
      *(_QWORD *)(v7 + 8 * v8) = -1;
      *(_QWORD *)(a1 + 40) += 0x2000;
    }
    --v8;
    v52 = 0;
  }
  v15 = *(_QWORD *)(a1 + 32);
  v14 = *(_QWORD *)(a1 + 40);
  v16 = malloc_type_malloc(0x30000uLL, 0x382807BCuLL);
  if (a3 < 1)
  {
    v31 = *(_QWORD *)a1;
    v32 = *(_QWORD *)(a1 + 16) - 1;
  }
  else
  {
    v17 = 0;
    v18 = ~v14 + a2;
    v19 = a3;
    v20 = *(uint64_t **)(a1 + 64);
    v21 = 8 * a3;
    do
    {
      v22 = v20[v17];
      if (v22 != -1 && v18 <= v22)
        break;
      if (v22 != -1)
      {
        if (v15 <= v22)
          break;
        v24 = *(_QWORD *)(a1 + 32);
        if (v24 > v22)
        {
          v25 = 0;
          do
          {
            if (v20[v25 / 8] == v24)
            {
              v24 += 0x2000;
              *(_QWORD *)(a1 + 32) = v24;
            }
            v25 += 8;
          }
          while (v21 != v25);
          if ((int64_t)v24 >= *(_QWORD *)a1)
            break;
          memcpy(v16, (const void *)(*(_QWORD *)(a1 + 48) + 24 * v20[v17]), 0x30000uLL);
          memcpy((void *)(*(_QWORD *)(a1 + 48) + 24 * *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8 * v17)), (const void *)(*(_QWORD *)(a1 + 48) + 24 * *(_QWORD *)(a1 + 32)), 0x30000uLL);
          memcpy((void *)(*(_QWORD *)(a1 + 48) + 24 * *(_QWORD *)(a1 + 32)), v16, 0x30000uLL);
          v20 = *(uint64_t **)(a1 + 64);
          v20[v17] = *(_QWORD *)(a1 + 32);
          *(_QWORD *)(a1 + 32) += 0x2000;
        }
      }
      ++v17;
    }
    while (v17 != v19);
    v26 = v19;
    do
    {
      v27 = v20[(v26 - 1)];
      if (v15 > v27)
        break;
      if (v27 != -1)
      {
        if (v18 > v27)
          break;
        v28 = (v26 - 1);
        v29 = *(_QWORD *)(a1 + 40) + 0x2000;
        *(_QWORD *)(a1 + 40) = v29;
        v30 = v19 + 1;
        do
        {
          if (v20[(v30 - 2)] == a2 - v29)
          {
            v29 += 0x2000;
            *(_QWORD *)(a1 + 40) = v29;
          }
          --v30;
        }
        while (v30 > 1);
        if ((unint64_t)(a2 - v29) < *(_QWORD *)(a1 + 16))
          break;
        memcpy(v16, (const void *)(*(_QWORD *)(a1 + 48) + 24 * v20[v28]), 0x30000uLL);
        memcpy((void *)(*(_QWORD *)(a1 + 48) + 24 * *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8 * v28)), (const void *)(*(_QWORD *)(a1 + 48) + 24 * (a2 - *(_QWORD *)(a1 + 40))), 0x30000uLL);
        memcpy((void *)(*(_QWORD *)(a1 + 48) + 24 * (a2 - *(_QWORD *)(a1 + 40))), v16, 0x30000uLL);
        v20 = *(uint64_t **)(a1 + 64);
        v20[v28] = a2 - *(_QWORD *)(a1 + 40);
      }
      v13 = v26-- <= 1;
    }
    while (!v13);
    v31 = *(_QWORD *)a1;
    v32 = *(_QWORD *)(a1 + 16) - 1;
    do
    {
      v34 = *v20++;
      v33 = v34;
      if (v34 != -1)
      {
        if (v33 < v31)
          v31 = v33;
        v35 = v33 + 0x2000;
        v36 = v33 + 0x1FFF;
        if (v35 > v32)
          v32 = v36;
        if (v32 >= a2)
        {
          v47 = __si_assert_copy_extra(0);
          v48 = v47;
          v49 = "";
          if (v47)
            v49 = v47;
          __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 1312, "right < count", v49);
          free(v48);
          if (__valid_fs(-1))
            v50 = 2989;
          else
            v50 = 3072;
          *(_DWORD *)v50 = -559038737;
          abort();
        }
      }
      --v19;
    }
    while (v19);
  }
  free(v16);
  if (v31 >= v32)
  {
    v37 = v31;
  }
  else
  {
    v37 = v31;
    do
    {
      v39 = *(_QWORD *)(a1 + 48);
      v38 = *(_QWORD *)(a1 + 56);
      v40 = (unint64_t *)(v39 + 24 * v31);
      while (*v40 < v38)
      {
        ++v37;
        v40 += 3;
        if (v37 >= v32)
        {
          if (v32 <= v31 + 1)
            v37 = v31 + 1;
          else
            v37 = v32;
          goto LABEL_80;
        }
      }
      if (v37 < v32)
      {
        v41 = (unint64_t *)(v39 + 24 * v32);
        while (*v41 > v38)
        {
          --v32;
          v41 -= 3;
          if (v37 >= v32)
            goto LABEL_80;
        }
        v42 = v41[2];
        v43 = *(_OWORD *)v41;
        v44 = v40[2];
        *(_OWORD *)v41 = *(_OWORD *)v40;
        v41[2] = v44;
        v45 = *(_QWORD *)(a1 + 48) + 24 * v37;
        *(_OWORD *)v45 = v43;
        *(_QWORD *)(v45 + 16) = v42;
        ++v37;
        --v32;
      }
      v31 = v37;
    }
    while (v37 < v32);
  }
LABEL_80:
  if (*(_QWORD *)(*(_QWORD *)(a1 + 48) + 24 * v37) >= *(_QWORD *)(a1 + 56))
    return v37;
  else
    return v37 + 1;
}

uint64_t index_comp_3153(_QWORD *a1, _QWORD *a2)
{
  unsigned int v2;

  if (*a1 >= *a2)
    v2 = 0;
  else
    v2 = -1;
  if (*a1 > *a2)
    return 1;
  else
    return v2;
}

uint64_t neutralize_offset_triple(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  uint64_t v12;
  __int128 *v13;
  uint64_t v14;
  __int128 v15;
  __int128 *v16;
  uint64_t v17;

  v5 = *a4;
  v6 = *a5;
  while (1)
  {
    if (v5 < 0x2000)
    {
      v7 = (unint64_t *)(a1 + 24 * v5);
      while (1)
      {
        v8 = *v7;
        v7 += 3;
        if (v8 > a3)
          break;
        if (++v5 == 0x2000)
        {
          v9 = 0x2000;
          goto LABEL_8;
        }
      }
    }
    v9 = v5;
LABEL_8:
    if (v6 < 0x2000)
    {
      v10 = (unint64_t *)(a2 + 24 * v6);
      while (1)
      {
        v11 = *v10;
        v10 += 3;
        if (v11 < a3)
          break;
        if (++v6 == 0x2000)
        {
          v5 = v9;
          goto LABEL_17;
        }
      }
    }
    v12 = v6;
    if (v9 == 0x2000 || v6 == 0x2000)
      break;
    v13 = (__int128 *)(a2 + 24 * v6);
    v14 = *((_QWORD *)v13 + 2);
    v15 = *v13;
    v16 = (__int128 *)(a1 + 24 * v9);
    v17 = *((_QWORD *)v16 + 2);
    *v13 = *v16;
    *((_QWORD *)v13 + 2) = v17;
    *v16 = v15;
    *((_QWORD *)v16 + 2) = v14;
    v5 = v9 + 1;
    v6 = v12 + 1;
    if (v9 > 8190 || v12 >= 0x1FFF)
      goto LABEL_17;
  }
  v5 = v9;
LABEL_17:
  *a4 = v5;
  *a5 = v6;
  if (v6 == 0x2000 && v5 == 0x2000)
    return 2;
  else
    return v5 != 0x2000;
}

int64_t Get_Left_Block_offset_triple(OSAtomic_int64_aligned64_t *__theValue)
{
  int64_t v2;

  if (*__theValue >= __theValue[1])
    return -1;
  v2 = OSAtomicAdd64(0x2000, __theValue);
  if (v2 > __theValue[1])
  {
    OSAtomicAdd64(-8192, __theValue);
    return -1;
  }
  return v2 - 0x2000;
}

int64_t Get_Right_Block_offset_triple(uint64_t a1)
{
  OSAtomic_int64_aligned64_t *v1;
  int64_t result;

  v1 = (OSAtomic_int64_aligned64_t *)(a1 + 16);
  if (*(_QWORD *)(a1 + 16) > *(_QWORD *)(a1 + 24))
  {
    result = OSAtomicAdd64(-8192, v1);
    if (result >= *(_QWORD *)(a1 + 24))
      return result;
    OSAtomicAdd64(0x2000, v1);
  }
  return -1;
}

void pqinit_offset_ptr(uint64_t a1)
{
  _QWORD *v2;

  *(_OWORD *)(a1 + 8) = xmmword_1B8631BF0;
  v2 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 0x220uLL, 0x6085D6BuLL);
  if (!v2)
    _log_fault_for_malloc_failure();
  *(_QWORD *)a1 = v2;
  *v2 = 0;
  v2[1] = 0;
}

void __directoryStoreGetFileListOffsets_block_invoke(uint64_t a1, int a2, unint64_t *a3)
{
  _directoryStoreGetFileListOffsets(*(uint64_t **)(a1 + 32), *(unsigned __int16 **)(a1 + 40), *(_QWORD *)(a1 + 48), a2, a3, *(_QWORD *)(a1 + 56), *(unsigned __int8 *)(a1 + 80), *(_QWORD *)(a1 + 64), *(_QWORD *)(a1 + 72));
}

void _directoryStoreGetFileListOffsets(uint64_t *a1, unsigned __int16 *a2, uint64_t a3, int a4, unint64_t *a5, uint64_t a6, int a7, unint64_t a8, uint64_t a9)
{
  unint64_t *DirectoryWithPath;
  size_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  _QWORD *v18;
  unint64_t v19;
  int64_t *ItemOffset;
  int64_t v21;
  char *v22;
  char *v23;
  const char *v24;
  unsigned __int16 *v25;
  int8x8_t v26;
  int64_t *v27;
  size_t v28;
  int64_t v29;
  unint64_t v30;
  int64_t v31;
  unint64_t *v32;
  _QWORD *v33;
  _QWORD *v34;
  BOOL v35;
  unint64_t v36;
  unint64_t v37;
  uint64_t v38;
  __int128 v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int8x16_t v45;
  int8x16_t v46;
  unint64_t v47;
  unint64_t v48;
  int32x2_t v49;
  int64x2_t v50;
  unsigned __int16 *v59;
  int8x8_t v60;
  unint64_t v61;
  size_t v62;
  unint64_t v63;
  uint64_t v64;
  unsigned int i;
  uint64_t v66;
  uint64_t Child;
  uint64_t v68;
  _QWORD *v69;
  unint64_t v70;
  unint64_t v71;
  uint64_t *v72;
  _QWORD *v73;
  _QWORD *v74;
  unsigned __int16 *Page;
  int8x8_t v76;
  unint64_t Size;
  unint64_t v78;
  uint64_t v79;
  unsigned int v80;
  uint64_t v81;
  _QWORD *v82;
  unint64_t v83;
  _QWORD *v84;
  _QWORD *v85;
  _QWORD *v86;
  char *v87;
  char *v88;
  const char *v89;
  char *v90;
  uint64_t v91;
  char *v92;
  const char *v93;
  char *v94;
  char *v95;
  const char *v96;
  uint64_t v97;
  char *v98;
  const char *v99;
  char *v100;
  const char *v101;
  char *v102;
  char *v103;
  const char *v104;
  uint64_t v105;
  void *ptr;
  uint64_t v111;
  unint64_t v112;
  BOOL v113;
  __int128 v114;

  v113 = 0;
  DirectoryWithPath = (unint64_t *)directoryStoreReaderGetDirectoryWithPath(a1, a2, a4 - 1, (uint64_t)a5);
  if (!DirectoryWithPath)
    return;
  v13 = DirectoryWithPath[1];
  if ((v13 & 0x8000000000000000) != 0)
  {
    v19 = v13 & 0x7FFFFFFFFFFFFFFFLL;
    if ((v13 & 0x7FFFFFFFFFFFFFFFLL) < a8)
    {
      if (!a9 || HIDWORD(v19))
        goto LABEL_134;
      v19 |= a9;
    }
    if (v19)
      goto LABEL_16;
LABEL_134:
    v100 = __si_assert_copy_extra(0);
    v23 = v100;
    v101 = "";
    if (v100)
      v101 = v100;
    __message_assert("%s:%u: failed assertion '%s' %s invalid posting 0x%llx for 0x%llx", "FileTree.c", 1701, "postingOffset", v101, v13, a8);
    goto LABEL_133;
  }
  if (!v13)
    return;
  if (a7)
  {
    ptr = 0;
    v111 = 0;
    v112 = 0;
    v14 = *DirectoryWithPath;
    pqinit_offset_ptr((uint64_t)&ptr);
    v16 = v111;
    v15 = v112;
    v17 = ptr;
    if ((uint64_t)(v112 + 2) >= v111)
    {
      if (v111 >= 4)
        v16 = 2 * v111;
      else
        v16 = 4;
      v111 = v16;
      if (ptr)
        v18 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, ptr, 16 * v16 + 32, 0xECA6AA46uLL);
      else
        v18 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 16 * v16 + 32, 0x8DDAA030uLL);
      v17 = v18;
      if (!v18)
        _log_fault_for_malloc_failure();
      ptr = v17;
      *v17 = 0;
      v17[1] = 0;
    }
    v31 = v15 + 1;
    v112 = v15 + 1;
    v32 = &v17[2 * v15];
    *v32 = v13;
    v32[1] = v14;
    if ((uint64_t)v15 >= 2)
    {
      do
      {
        v33 = &v17[2 * v15];
        v34 = &v17[2 * (v15 >> 1)];
        if ((*v33 & 0x3FFFFFFFFFFFFFFFuLL) > (*v34 & 0x3FFFFFFFFFFFFFFFuLL))
          break;
        v114 = *(_OWORD *)v33;
        *(_OWORD *)v33 = *(_OWORD *)v34;
        *(_OWORD *)v34 = v114;
        v35 = v15 > 3;
        v15 >>= 1;
      }
      while (v35);
      v16 = v111;
      v31 = v112;
      v17 = ptr;
    }
    while (1)
    {
      v36 = v31 - 1;
      if (v31 == 1)
      {
        v37 = 0;
        v38 = 0;
        v36 = 1;
LABEL_91:
        Page = _directoryStoreReaderGetPage(a1, v37, &v113);
        Size = directoryTreePageGetSize(*Page, *((_BYTE *)Page + 2), v76);
        if (!Size)
          goto LABEL_110;
        v78 = Size;
        v79 = 0;
        v80 = 0;
        while (1)
        {
          v81 = *(_QWORD *)&Page[4 * v79 + 4];
          if (v81 < 0)
            break;
          if (v81)
          {
            if ((uint64_t)(v36 + 2) >= v16)
            {
              if (v16 >= 4)
                v16 *= 2;
              else
                v16 = 4;
              if (v17)
                v82 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, v17, 16 * v16 + 32, 0xECA6AA46uLL);
              else
                v82 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 16 * v16 + 32, 0x8DDAA030uLL);
              v17 = v82;
              if (!v82)
                _log_fault_for_malloc_failure();
              *v17 = 0;
              v17[1] = 0;
            }
            v83 = v36 + 1;
            v84 = &v17[2 * v36];
            *v84 = v81;
            v84[1] = v38;
            if ((uint64_t)v36 >= 2)
            {
              do
              {
                v85 = &v17[2 * v36];
                v86 = &v17[2 * (v36 >> 1)];
                if ((*v85 & 0x3FFFFFFFFFFFFFFFuLL) > (*v86 & 0x3FFFFFFFFFFFFFFFuLL))
                  break;
                v114 = *(_OWORD *)v85;
                *(_OWORD *)v85 = *(_OWORD *)v86;
                *(_OWORD *)v86 = v114;
                v35 = v36 > 3;
                v36 >>= 1;
              }
              while (v35);
            }
            v36 = v83;
          }
          v79 = ++v80;
          if (v78 <= v80)
            goto LABEL_110;
        }
        v87 = __si_assert_copy_extra(0);
        v88 = v87;
        v89 = "";
        if (v87)
          v89 = v87;
        __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 1743, "!(offset & (1ull << 63))", v89);
LABEL_116:
        v90 = v88;
LABEL_117:
        free(v90);
        if (__valid_fs(-1))
          v91 = 2989;
        else
          v91 = 3072;
        *(_DWORD *)v91 = -559038737;
        abort();
      }
      v37 = v17[2];
      v38 = v17[3];
      v39 = *(_OWORD *)&v17[2 * v36];
      v40 = v17[2 * v36];
      *((_OWORD *)v17 + 1) = v39;
      v112 = v31 - 1;
      v41 = v40 & 0x3FFFFFFFFFFFFFFFLL;
      v42 = 1;
      v43 = 2;
      v44 = 3;
      while (1)
      {
        v45 = *(int8x16_t *)&v17[2 * v43];
        if (v44 >= v31)
        {
          v46 = (int8x16_t)xmmword_1B8631BE0;
          if (v43 >= v31)
            goto LABEL_60;
        }
        else
        {
          v46 = *(int8x16_t *)&v17[2 * v44];
        }
        v47 = v45.i64[0] & 0x3FFFFFFFFFFFFFFFLL;
        v48 = v46.i64[0] & 0x3FFFFFFFFFFFFFFFLL;
        if ((v45.i64[0] & 0x3FFFFFFFFFFFFFFFuLL) < v41)
        {
          v49 = vdup_n_s32(v48 < v47);
          v50.i64[0] = v49.u32[0];
          v50.i64[1] = v49.u32[1];
          v46 = vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v50, 0x3FuLL)), v46, v45);
          if (v48 >= v47)
            v44 = v43;
          goto LABEL_53;
        }
        if (v48 >= v41)
          break;
LABEL_53:
        _X13 = &v17[4 * v44];
        __asm { PRFM            #1, [X13] }
        if (v44 != v42)
        {
          v43 = 2 * v44;
          *(_OWORD *)&v17[2 * v44] = v39;
          *(int8x16_t *)&v17[2 * v42] = v46;
          v42 = v44;
          v35 = v44 < v16 >> 1;
          v44 = (2 * v44) | 1;
          if (v35)
            continue;
        }
        goto LABEL_60;
      }
      _X8 = &v17[4 * v42];
      __asm { PRFM            #1, [X8] }
LABEL_60:
      if (v37 >> 62 != 1)
        goto LABEL_91;
      v59 = _directoryStoreReaderGetPage(a1, v37, &v113);
      directoryStorePageGetSize(v59, v60);
      if (v61)
      {
        v63 = v61;
        v64 = 0;
        for (i = 0; i < v63; v64 = ++i)
        {
          v66 = *(_QWORD *)&v59[8 * v64 + 4];
          if (v66 >= 2)
          {
            if (!a3
              || (LODWORD(v114) = 0, (Child = negativeFindChild(a3 + 440, v66, &v114)) == 0)
              || *(_QWORD *)(Child + 8) != v38)
            {
              v68 = *(_QWORD *)&v59[8 * v64 + 8];
              if (v68 < 0)
              {
                v70 = v68 & 0x7FFFFFFFFFFFFFFFLL;
                if ((v68 & 0x7FFFFFFFFFFFFFFFuLL) < a8)
                {
                  if (!a9 || HIDWORD(v70))
                  {
LABEL_130:
                    v98 = __si_assert_copy_extra(0);
                    v23 = v98;
                    v99 = "";
                    if (v98)
                      v99 = v98;
                    __message_assert("%s:%u: failed assertion '%s' %s invalid posting 0x%llx for 0x%llx", "FileTree.c", 1724, "postingOffset", v99, v68, a8);
                    goto LABEL_133;
                  }
                  v70 |= a9;
                }
                if (!v70)
                  goto LABEL_130;
                oqpush_3167(a6, v70, v62);
              }
              else if (v68)
              {
                if ((uint64_t)(v36 + 2) >= v16)
                {
                  if (v16 >= 4)
                    v16 *= 2;
                  else
                    v16 = 4;
                  if (v17)
                    v69 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, v17, 16 * v16 + 32, 0xECA6AA46uLL);
                  else
                    v69 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 16 * v16 + 32, 0x8DDAA030uLL);
                  v17 = v69;
                  if (!v69)
                    _log_fault_for_malloc_failure();
                  *v17 = 0;
                  v17[1] = 0;
                }
                v71 = v36 + 1;
                v72 = &v17[2 * v36];
                *v72 = v68;
                v72[1] = v66;
                if ((uint64_t)v36 >= 2)
                {
                  do
                  {
                    v73 = &v17[2 * v36];
                    v74 = &v17[2 * (v36 >> 1)];
                    if ((*v73 & 0x3FFFFFFFFFFFFFFFuLL) > (*v74 & 0x3FFFFFFFFFFFFFFFuLL))
                      break;
                    v114 = *(_OWORD *)v73;
                    *(_OWORD *)v73 = *(_OWORD *)v74;
                    *(_OWORD *)v74 = v114;
                    v35 = v36 > 3;
                    v36 >>= 1;
                  }
                  while (v35);
                }
                v36 = v71;
              }
            }
          }
        }
      }
LABEL_110:
      v111 = v16;
      v112 = v36;
      v31 = v36;
      ptr = v17;
      if (v36 == 1)
      {
        free(v17);
        return;
      }
    }
  }
  if ((v13 & 0x4000000000000000) == 0)
  {
    ItemOffset = directoryStoreReaderTreeFindItemOffset(a1, v13, *a5, 0);
    if (!ItemOffset)
      return;
    v21 = ItemOffset[1];
    if ((v21 & 0x8000000000000000) == 0)
    {
      v92 = __si_assert_copy_extra(0);
      v88 = v92;
      v93 = "";
      if (v92)
        v93 = v92;
      __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 1773, "(offset & (1ull << 63))", v93);
      goto LABEL_116;
    }
    v19 = v21 & 0x7FFFFFFFFFFFFFFFLL;
    if ((v21 & 0x7FFFFFFFFFFFFFFFuLL) < a8)
    {
      if (!a9 || HIDWORD(v19))
        goto LABEL_25;
      v19 |= a9;
    }
    if (!v19)
    {
LABEL_25:
      v22 = __si_assert_copy_extra(0);
      v23 = v22;
      v24 = "";
      if (v22)
        v24 = v22;
      __message_assert("%s:%u: failed assertion '%s' %s invalid posting 0x%llx for 0x%llx", "FileTree.c", 1775, "postingOffset", v24, v21, a8);
LABEL_133:
      v90 = v23;
      goto LABEL_117;
    }
LABEL_16:
    oqpush_3167(a6, v19, v12);
    return;
  }
  v25 = _directoryStoreReaderGetPage(a1, v13, &v113);
  if (v25)
  {
    LODWORD(ptr) = 0;
    v27 = directoryStorePageFindItemOffset(*(_DWORD **)(*a1 + 216), (uint64_t)v25, *a5, (unsigned int *)&ptr, 0, v26);
    if (v27)
    {
      v29 = v27[1];
      if ((v29 & 0x8000000000000000) == 0)
      {
        v94 = __si_assert_copy_extra(0);
        v95 = v94;
        v96 = "";
        if (v94)
          v96 = v94;
        __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 1762, "(offset & (1ull << 63))", v96);
        free(v95);
        if (__valid_fs(-1))
          v97 = 2989;
        else
          v97 = 3072;
        *(_DWORD *)v97 = -559038737;
        abort();
      }
      v30 = v29 & 0x7FFFFFFFFFFFFFFFLL;
      if ((v29 & 0x7FFFFFFFFFFFFFFFuLL) < a8)
      {
        if (!a9 || HIDWORD(v30))
          goto LABEL_137;
        v30 |= a9;
      }
      if (v30)
      {
        oqpush_3167(a6, v30, v28);
        return;
      }
LABEL_137:
      v102 = __si_assert_copy_extra(0);
      v103 = v102;
      v104 = "";
      if (v102)
        v104 = v102;
      __message_assert("%s:%u: failed assertion '%s' %s invalid posting 0x%llx for 0x%llx", "FileTree.c", 1764, "postingOffset", v104, v29, a8);
      free(v103);
      if (__valid_fs(-1))
        v105 = 2989;
      else
        v105 = 3072;
      *(_DWORD *)v105 = -559038737;
      abort();
    }
  }
}

uint64_t directoryStoreReaderGetDirectoryWithPath(uint64_t *a1, unsigned __int16 *Page, int a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  int64_t v6;
  int8x8_t v10;
  int64_t *ItemOffset;
  BOOL v13;
  uint64_t v14;
  uint64_t v15;

  if (a3 != -1)
  {
    v14 = v4;
    v15 = v5;
    v13 = 0;
    v6 = *((_QWORD *)Page + 1);
    if (v6 < 1)
    {
      return 0;
    }
    else
    {
      Page = _directoryStoreReaderGetPage(a1, *((_QWORD *)Page + 1), &v13);
      if (Page)
      {
        if (v13)
          ItemOffset = directoryStorePageFindItemOffset(*(_DWORD **)(*a1 + 216), (uint64_t)Page, *(_QWORD *)(a4 + 8 * a3), 0, 0, v10);
        else
          ItemOffset = directoryStoreReaderTreeFindItemOffset(a1, v6, *(_QWORD *)(a4 + 8 * a3), 0);
        Page = (unsigned __int16 *)ItemOffset;
        if (ItemOffset)
          return directoryStoreReaderGetDirectoryWithPath(a1, ItemOffset, (a3 - 1), a4);
      }
    }
  }
  return (uint64_t)Page;
}

void oqpush_3167(uint64_t a1, uint64_t a2, size_t size)
{
  uint64_t v5;
  char *v6;
  char *v7;
  const char *v8;
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  size_t v13;
  void *v14;
  void *v15;
  uint64_t v16;
  char *v17;
  const char *v18;
  char *v19;
  uint64_t v20;

  if (*(_BYTE *)a1)
  {
    v17 = __si_assert_copy_extra(0);
    v7 = v17;
    v18 = "";
    if (v17)
      v18 = v17;
    __message_assert("%s:%u: failed assertion '%s' %s ", "OQueue.h", 327, "!oqueue->has_meta", v18);
LABEL_25:
    free(v7);
    if (__valid_fs(-1))
      v20 = 2989;
    else
      v20 = 3072;
    *(_DWORD *)v20 = -559038737;
    abort();
  }
  if (*(_DWORD *)(a1 + 56))
  {
    if (*(_QWORD *)(a1 + 64) < (a2 & 0x3FFFFFFFFFFFFFFFuLL))
    {
      v19 = __si_assert_copy_extra(0);
      v7 = v19;
      v8 = "";
      if (v19)
        v8 = v19;
      v9 = "!queue->split || queue->splitPoint >= offset_t_GET_VALUE(value)";
      goto LABEL_24;
    }
    v5 = *(_QWORD *)(a1 + 32);
    if (v5 >= *(_QWORD *)(a1 + 24))
    {
      v6 = __si_assert_copy_extra(0);
      v7 = v6;
      v8 = "";
      if (v6)
        v8 = v6;
      v9 = "!queue->split";
LABEL_24:
      __message_assert("%s:%u: failed assertion '%s' %s ", "OQueue.h", 247, v9, v8);
      goto LABEL_25;
    }
  }
  else
  {
    v10 = *(_QWORD *)(a1 + 24);
    v5 = *(_QWORD *)(a1 + 32);
    if (v5 >= v10)
    {
      v11 = 2 * v10;
      if (!v10)
        v11 = 4;
      *(_QWORD *)(a1 + 24) = v11;
      v12 = *(void **)(a1 + 16);
      v13 = 8 * v11;
      if (v12)
        v14 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, v12, v13, 0xECA6AA46uLL);
      else
        v14 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v13, 0x8DDAA030uLL);
      v15 = v14;
      if (!v14)
        _log_fault_for_malloc_failure();
      *(_QWORD *)(a1 + 16) = v15;
      v5 = *(_QWORD *)(a1 + 32);
    }
  }
  v16 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 32) = v5 + 1;
  *(_QWORD *)(v16 + 8 * v5) = a2;
}

unsigned __int16 *_directoryStoreReaderGetPage(uint64_t *a1, unint64_t a2, BOOL *a3)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t ptr;
  unsigned __int16 *result;
  unsigned __int16 *v8;
  char *v9;
  char *v10;
  const char *v11;
  uint64_t v12;

  *a3 = a2 >> 62 == 1;
  v4 = a2 & 0x3FFFFFFFFFFFFFFFLL;
  v5 = *a1;
  if ((a2 & 0x3FFFFFFFFFFFFFFFLL) >= *(_QWORD *)(v5 + 232))
    return 0;
  ptr = storage_reader_get_ptr(v5, a1[1], v4, 8uLL);
  if (ptr == -1)
    return 0;
  result = (unsigned __int16 *)storage_reader_get_ptr(*a1, a1[1], v4, 64 << *(_BYTE *)(ptr + 2));
  if ((unint64_t)result + 1 < 2)
    return 0;
  if ((64 << *((_BYTE *)result + 2)) - 8 < *result)
  {
    v8 = result;
    v9 = __si_assert_copy_extra(0);
    v10 = v9;
    v11 = "";
    if (v9)
      v11 = v9;
    __message_assert("%s:%u: failed assertion '%s' %s Got end %d and size %d", "FileTree.c", 254, "storePageEnd((StorePageRef)page) <= storePageDataSize((StorePageRef)page) && storePageDataSize((StorePageRef)page)", v11, *v8, (64 << *((_BYTE *)v8 + 2)) - 8);
    free(v10);
    if (__valid_fs(-1))
      v12 = 2989;
    else
      v12 = 3072;
    *(_DWORD *)v12 = -559038737;
    abort();
  }
  return result;
}

__int16 directoryStorePageGetSize@<H0>(unsigned __int16 *a1@<X0>, int8x8_t a2@<D0>)
{
  int v2;
  uint8x8_t v3;
  char *v4;
  char *v5;
  const char *v6;
  char *v7;
  const char *v8;
  uint64_t v9;

  if (!a1)
    return v3.i16[0];
  v2 = (64 << *((_BYTE *)a1 + 2)) - 8;
  if ((unint64_t)v2 >> 4 < (unint64_t)*a1 >> 4)
  {
    v4 = __si_assert_copy_extra(0);
    v5 = v4;
    v6 = "";
    if (v4)
      v6 = v4;
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 293, "storePageEnd((StorePageRef)page)/sizeof(CIDirectory_t) <= storePageDataSize((StorePageRef)page)/sizeof(CIDirectory_t)", v6);
LABEL_13:
    free(v5);
    if (__valid_fs(-1))
      v9 = 2989;
    else
      v9 = 3072;
    *(_DWORD *)v9 = -559038737;
    abort();
  }
  if (v2 < 0)
    v2 = (64 << *((_BYTE *)a1 + 2)) + 7;
  a2.i32[0] = (v2 >> 4) + 1;
  v3 = (uint8x8_t)vcnt_s8(a2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.i32[0] != 1)
  {
    v7 = __si_assert_copy_extra(0);
    v5 = v7;
    v8 = "";
    if (v7)
      v8 = v7;
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 295, "__builtin_popcount((storePageDataSize((StorePageRef)page))/((int)(sizeof(CIDirectory_t))) + 1) == 1", v8);
    goto LABEL_13;
  }
  return v3.i16[0];
}

unint64_t directoryTreePageGetSize(unsigned __int16 a1, char a2, int8x8_t a3)
{
  int v3;
  uint8x8_t v4;
  char *v6;
  char *v7;
  const char *v8;
  char *v9;
  const char *v10;
  uint64_t v11;

  v3 = (64 << a2) - 8;
  if (v3 < a1)
  {
    v6 = __si_assert_copy_extra(0);
    v7 = v6;
    v8 = "";
    if (v6)
      v8 = v6;
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 310, "storePageEnd((StorePageRef)page) <= storePageDataSize((StorePageRef)page)", v8);
LABEL_10:
    free(v7);
    if (__valid_fs(-1))
      v11 = 2989;
    else
      v11 = 3072;
    *(_DWORD *)v11 = -559038737;
    abort();
  }
  a3.i32[0] = (v3 >> 3) + 1;
  v4 = (uint8x8_t)vcnt_s8(a3);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.i32[0] != 1)
  {
    v9 = __si_assert_copy_extra(0);
    v7 = v9;
    v10 = "";
    if (v9)
      v10 = v9;
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 314, "__builtin_popcount((storePageDataSize((StorePageRef)page))/((int)(sizeof(disk_offset_t))) + 1) == 1", v10);
    goto LABEL_10;
  }
  return (unint64_t)v3 >> 3;
}

int64_t *directoryStorePageFindItemOffset(_DWORD *a1, uint64_t a2, int64_t a3, unsigned int *a4, int a5, int8x8_t a6)
{
  uint64_t v10;
  unint64_t v11;
  unsigned int Hash;
  unsigned int v13;
  uint64_t v14;
  int64_t *v15;
  int64_t v16;
  int64_t v17;
  unsigned int *v18;
  int v19;
  uint64_t v20;
  int v21;
  unsigned int v22;
  char v23;
  unint64_t v24;
  unint64_t v25;
  BOOL v26;
  _BOOL4 v27;
  uint64_t v28;
  int64_t v29;
  char *v31;
  char *v32;
  const char *v33;
  uint64_t v34;
  char *v35;
  char *v36;
  const char *v37;
  char *v38;
  const char *v39;
  unint64_t v41;
  unint64_t v42;

  directoryStorePageGetSize((unsigned __int16 *)a2, a6);
  v11 = v10;
  if (a5 == 1 && !*(_WORD *)(a2 + 6))
  {
    v38 = __si_assert_copy_extra(a1);
    v32 = v38;
    v39 = "";
    if (v38)
      v39 = v38;
    __message_assert("%s:%u: failed assertion '%s' %s Expected depth %d; page has %d",
      "FileTree.c",
      961,
      "getNum16(page->depth)==(unsigned)depth",
      v39,
      1,
      *(unsigned __int16 *)(a2 + 6));
LABEL_39:
    free(v32);
    if (__valid_fsp(a1))
      v34 = 2989;
    else
      v34 = 3072;
    *(_DWORD *)v34 = -559038737;
    abort();
  }
  if (*(unsigned __int16 *)(a2 + 6) != a5)
  {
    v31 = __si_assert_copy_extra(a1);
    v32 = v31;
    v33 = "";
    if (v31)
      v33 = v31;
    __message_assert("%s:%u: failed assertion '%s' %s Expected depth %d; page has %d",
      "FileTree.c",
      963,
      "getNum16(page->depth)==(unsigned)depth",
      v33,
      a5,
      *(unsigned __int16 *)(a2 + 6));
    goto LABEL_39;
  }
  v42 = 0;
  Hash = getHash(a3, v10, *(_BYTE *)(a2 + 2), a5, 10, &v42);
  v13 = Hash;
  if (*(_BYTE *)(a2 + 3))
    v42 <<= 8 * a5;
  v14 = a2 + 16 * Hash;
  v17 = *(_QWORD *)(v14 + 8);
  v15 = (int64_t *)(v14 + 8);
  v16 = v17;
  v18 = a4;
  if (v17)
  {
    v19 = 0;
    v20 = -1;
    while (1)
    {
      v21 = -1;
      if (v16 == a3 || v11 == v20)
        break;
      if (v16 == 1)
      {
        v35 = __si_assert_copy_extra(0);
        v36 = v35;
        if (v35)
          v37 = v35;
        else
          v37 = "";
        __message_assert("%s:%u: Unexpected code path %s ", "FileTree.c", 982, v37);
        free(v36);
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      if (v18)
      {
        v41 = 0;
        v22 = getHash(v16, v11, *(_BYTE *)(a2 + 2), a5, 10, &v41);
        if (*(_BYTE *)(a2 + 3))
          v23 = 8 * a5;
        else
          v23 = 0;
        v24 = v41 << v23;
        if (v24 <= v42)
        {
          v18 = a4;
          if (v16 > a3 && v24 == v42 && ((v19 ^ (v22 <= v13)) & 1) != 0)
          {
LABEL_27:
            v16 = *v15;
            v21 = v13;
            break;
          }
        }
        else
        {
          v18 = a4;
          if (((v19 ^ (v22 <= v13)) & 1) != 0)
            goto LABEL_27;
        }
        if ((v19 & (v22 <= v13)) == 1)
          goto LABEL_27;
      }
      v25 = v13 + 1;
      v26 = v11 > v25;
      v27 = v11 <= v25;
      if (v26)
        ++v13;
      else
        v13 = 0;
      v19 |= v27;
      v28 = a2 + 16 * v13;
      v29 = *(_QWORD *)(v28 + 8);
      v15 = (int64_t *)(v28 + 8);
      v16 = v29;
      ++v20;
      if (!v29)
        goto LABEL_26;
    }
  }
  else
  {
LABEL_26:
    v21 = -1;
  }
  if (v16 == a3)
  {
    if (!v18)
      return v15;
    goto LABEL_34;
  }
  v15 = 0;
  if (v18)
  {
    if (v21 != -1)
      v13 = v21;
LABEL_34:
    *v18 = v13;
  }
  return v15;
}

int64_t *directoryStoreReaderTreeFindItemOffset(uint64_t *a1, unint64_t a2, unint64_t a3, int a4)
{
  int v4;
  unint64_t v5;
  uint64_t *v6;
  int64_t *result;
  int8x8_t v8;
  int64_t *v9;
  unint64_t Size;
  int v11;
  int8x8_t v12;
  char *v13;
  char *v14;
  const char *v15;
  char *v16;
  const char *v17;
  uint64_t v18;
  unsigned int v19;
  BOOL v20;

  while (1)
  {
    v4 = a4;
    v5 = a3;
    v6 = a1;
    v20 = 0;
    result = (int64_t *)_directoryStoreReaderGetPage(a1, a2, &v20);
    if (!result)
      return result;
    if (v20)
    {
      v13 = __si_assert_copy_extra(0);
      v14 = v13;
      v15 = "";
      if (v13)
        v15 = v13;
      __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 847, "!flat", v15);
LABEL_17:
      free(v14);
      if (__valid_fs(-1))
        v18 = 2989;
      else
        v18 = 3072;
      *(_DWORD *)v18 = -559038737;
      abort();
    }
    v9 = result;
    if (*((unsigned __int16 *)result + 3) != v4)
    {
      v16 = __si_assert_copy_extra(0);
      v14 = v16;
      v17 = "";
      if (v16)
        v17 = v16;
      __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 849, "getNum16(page->depth)==(unsigned)pageDepth", v17);
      goto LABEL_17;
    }
    Size = directoryTreePageGetSize(*(_WORD *)result, *((_BYTE *)result + 2), v8);
    v11 = v4 + 1;
    a2 = v9[getHash(v5, Size, 0, v11, 0, 0) + 1];
    if (!a2)
      return 0;
    if (a2 >> 62 == 1)
      break;
    a1 = v6;
    a3 = v5;
    a4 = v11;
  }
  result = (int64_t *)_directoryStoreReaderGetPage(v6, a2, &v20);
  if (result)
  {
    v19 = 0;
    return directoryStorePageFindItemOffset(*(_DWORD **)(*v6 + 216), (uint64_t)result, v5, &v19, v11, v12);
  }
  return result;
}

uint64_t getHash(unint64_t a1, uint64_t a2, char a3, char a4, int a5, unint64_t *a6)
{
  int v10;
  unint64_t v11;
  int v12;
  unsigned int v13;
  char v14;
  unsigned int v15;
  char *v17;
  char *v18;
  const char *v19;
  uint64_t v20;

  if (!a2)
  {
    v17 = __si_assert_copy_extra(0);
    v18 = v17;
    v19 = "";
    if (v17)
      v19 = v17;
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 220, "pageSize", v19);
    free(v18);
    if (__valid_fs(-1))
      v20 = 2989;
    else
      v20 = 3072;
    *(_DWORD *)v20 = -559038737;
    abort();
  }
  v10 = a2;
  v11 = hash64(a1);
  if (a6)
    *a6 = v11;
  if (a5)
    v12 = ~(-1 << a5);
  else
    v12 = v10;
  v13 = v12 & (v11 >> -(char)(a5 + 8 * a4));
  v14 = a5 - a3 - 2;
  if (!a5)
    v14 = 0;
  v15 = v13 >> v14;
  if (v15 <= 1)
    v15 = 1;
  return v15 - 1;
}

unint64_t hash64(unint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;

  v1 = 0;
  do
  {
    v2 = vaddvq_s64((int64x2_t)vandq_s8((int8x16_t)vdupq_n_s64(v1 | result), (int8x16_t)xmmword_1B8631CF0));
    v3 = (0x9E3779B97F4A7C13 - v2) ^ ((v2 - 8) << 9);
    v4 = (-v2 - v3 + 16) ^ (v3 >> 8);
    v5 = (v2 - 8 - v3 - v4) ^ (v4 >> 38);
    v6 = (v3 - v4 - v5) ^ (v5 << 23);
    v7 = (v4 - v5 - v6) ^ (v6 >> 5);
    v8 = (v5 - v6 - v7) ^ (v7 >> 35);
    v9 = (v6 - v7 - v8) ^ (v8 << 49);
    v10 = (v7 - v8 - v9) ^ (v9 >> 11);
    v11 = (v8 - v9 - v10) ^ (v10 >> 12);
    result = (v10 - v11 - ((v9 - v10 - v11) ^ (v11 << 18))) ^ (((v9 - v10 - v11) ^ (v11 << 18)) >> 22);
    ++v1;
  }
  while ((~(((result & 0x7F7F7F7F7F7F7F7FLL) + 0x7F7F7F7F7F7F7F7FLL) | result) & 0x8080808080808080) != 0);
  return result;
}

char *_directoryStoreGetPageInner(uint64_t a1, unint64_t a2, BOOL *a3)
{
  unint64_t v4;
  char *v5;
  char *result;
  char *v7;
  char *v8;
  char *v9;
  const char *v10;
  uint64_t v11;

  *a3 = a2 >> 62 == 1;
  v4 = a2 & 0x3FFFFFFFFFFFFFFFLL;
  v5 = storageResolvePtr(a1, a2 & 0x3FFFFFFFFFFFFFFFLL, 8uLL, 1);
  result = storageResolvePtr(a1, v4, 64 << v5[2], 1);
  v7 = result;
  if (result && (64 << result[2]) - 8 < *(unsigned __int16 *)result)
  {
    v8 = __si_assert_copy_extra(0);
    v9 = v8;
    v10 = "";
    if (v8)
      v10 = v8;
    __message_assert("%s:%u: failed assertion '%s' %s Got end %d and size %d", "FileTree.c", 269, "storePageEnd((StorePageRef)page) <= storePageDataSize((StorePageRef)page)", v10, *(unsigned __int16 *)v7, (64 << v7[2]) - 8);
    free(v9);
    if (__valid_fs(-1))
      v11 = 2989;
    else
      v11 = 3072;
    *(_DWORD *)v11 = -559038737;
    abort();
  }
  return result;
}

unsigned __int16 *directoryStoreGetDirectoryWithPath(unsigned __int16 *result, uint64_t a2, unint64_t *a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  unsigned __int16 *v10;
  _OWORD *v14;
  unint64_t v15;
  int64_t v16;
  unsigned __int16 *v17;
  unint64_t v18;
  char *PageInner;
  int8x8_t v20;
  uint64_t v21;
  _OWORD *v22;
  uint64_t v23;
  __int128 *v24;
  unint64_t v25;
  char *v26;
  char *v27;
  const char *v28;
  uint64_t v29;
  __int128 v30;
  unint64_t v31;
  char v32;
  __int128 v33;
  unint64_t v34;
  unsigned int v35;
  BOOL v36;
  _OWORD v37[7];
  uint64_t v38;

  v10 = result;
  if (a4 == -1)
  {
    if (a7)
    {
      v18 = a3[1];
      if (v18)
      {
        *(_DWORD *)(a7 + 112) = 1604;
        *(_QWORD *)(a7 + 104) = v18;
        result = (unsigned __int16 *)_directoryStoreGetPageInner(a2, v18, (BOOL *)v37);
        if (*(_DWORD *)(a7 + 96) != result[3])
        {
          v26 = __si_assert_copy_extra(0);
          v27 = v26;
          v28 = "";
          if (v26)
            v28 = v26;
          __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 1608, "refPage->pathDepth==getNum16(page->depth)", v28);
          free(v27);
          if (__valid_fs(-1))
            v29 = 2989;
          else
            v29 = 3072;
          *(_DWORD *)v29 = -559038737;
          abort();
        }
      }
    }
    *(_OWORD *)v10 = *(_OWORD *)a3;
    *((_QWORD *)v10 + 2) = a3[2];
  }
  else
  {
    v38 = 0;
    memset(v37, 0, sizeof(v37));
    if (a7)
      v14 = (_OWORD *)a7;
    else
      v14 = v37;
    v36 = 0;
    v15 = a3[1];
    v16 = *(_QWORD *)(*a3 + 8);
    if (v15)
    {
      result = (unsigned __int16 *)_directoryStoreGetPageInner(a2, v15, &v36);
      v17 = result;
      *a3 = (unint64_t)&result[8 * *((unsigned int *)a3 + 4) + 4];
    }
    else
    {
      v17 = 0;
    }
    v35 = 0;
    if (v16 <= 0)
    {
      if ((a6 & 1) != 0)
      {
LABEL_28:
        v25 = *(_QWORD *)(a5 + 8 * a4);
        v32 = 0;
        v33 = 0uLL;
        v34 = 0;
        v30 = *(_OWORD *)a3;
        v31 = a3[2];
        insertDirectory_3213((uint64_t)&v33, a2, &v30, v35, v25, v25, 0, &v32, (uint64_t)v14);
        v21 = (a4 - 1);
        v30 = v33;
        v31 = v34;
        v24 = &v30;
        return (unsigned __int16 *)directoryStoreGetDirectoryWithPath(v10, a2, v24, v21, a5, a6, v14);
      }
    }
    else
    {
      PageInner = _directoryStoreGetPageInner(a2, v16, &v36);
      if (v36)
      {
        result = (unsigned __int16 *)directoryStorePageFindItemOffset(*(_DWORD **)(a2 + 216), (uint64_t)PageInner, *(_QWORD *)(a5 + 8 * a4), &v35, 0, v20);
        if (result)
        {
          *((_QWORD *)v14 + 14) = 0;
          v14[5] = 0u;
          v14[6] = 0u;
          v14[3] = 0u;
          v14[4] = 0u;
          v14[1] = 0u;
          v14[2] = 0u;
          *v14 = 0u;
          v21 = (a4 - 1);
          *(_QWORD *)&v33 = result;
          *((_QWORD *)&v33 + 1) = v16;
          LODWORD(v34) = v35;
LABEL_24:
          HIDWORD(v34) = 0;
          v24 = &v33;
          return (unsigned __int16 *)directoryStoreGetDirectoryWithPath(v10, a2, v24, v21, a5, a6, v14);
        }
      }
      else
      {
        result = (unsigned __int16 *)directoryStoreTreeFindItemOffset(a2, v16, *(_QWORD *)(a5 + 8 * a4), (uint64_t)v14, &v35, 0, a6);
        if (result)
        {
          v22 = v37;
          if (a7)
            v22 = (_OWORD *)a7;
          v23 = *((_QWORD *)v22 + 13);
          if (a4)
          {
            *((_QWORD *)v14 + 14) = 0;
            v14[5] = 0u;
            v14[6] = 0u;
            v14[3] = 0u;
            v14[4] = 0u;
            v14[1] = 0u;
            v14[2] = 0u;
            *v14 = 0u;
          }
          v21 = (a4 - 1);
          *(_QWORD *)&v33 = result;
          *((_QWORD *)&v33 + 1) = v23;
          LODWORD(v34) = v35;
          goto LABEL_24;
        }
      }
      if ((a6 & 1) != 0)
      {
        if (v17)
          *a3 = (unint64_t)&_directoryStoreGetPageInner(a2, a3[1], &v36)[16 * *((unsigned int *)a3 + 4) + 8];
        goto LABEL_28;
      }
    }
    *(_QWORD *)v10 = 0;
    *((_QWORD *)v10 + 1) = 0;
    *((_QWORD *)v10 + 2) = 0;
  }
  return result;
}

unint64_t shiftEntriesForDelete(uint64_t a1, uint64_t a2, unint64_t a3, char a4)
{
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t result;
  unint64_t v12;
  unint64_t *v13;
  __int128 v14;
  char *v15;
  char *v16;
  const char *v17;
  char *v18;
  char *v19;
  const char *v20;
  uint64_t v21;
  char *v22;
  const char *v23;
  uint64_t v24;

  v8 = a2 + 1;
  if (a2 + 1 >= a3)
  {
LABEL_6:
    if (!a2)
    {
LABEL_11:
      v15 = __si_assert_copy_extra(0);
      v16 = v15;
      if (v15)
        v17 = v15;
      else
        v17 = "";
      __message_assert("%s:%u: Unexpected code path %s ", "FileTree.c", 1111, v17);
      free(v16);
      goto LABEL_25;
    }
    v12 = 0;
    v10 = a3 - 1;
    v13 = (unint64_t *)(a1 + 8);
    while (1)
    {
      result = *v13;
      if (*v13 <= 1)
        break;
      result = getHash(result, a3, *(_BYTE *)(a1 + 2), a4, 10, 0);
      if (v12 == result)
        goto LABEL_20;
      v14 = *(_OWORD *)v13;
      v13 += 2;
      *(_OWORD *)(a1 + 16 * v10 + 8) = v14;
      v10 = v12++;
      if (a2 == v12)
        goto LABEL_11;
    }
    if (*v13 != 1)
      goto LABEL_20;
    v18 = __si_assert_copy_extra(0);
    v19 = v18;
    v20 = "";
    if (v18)
      v20 = v18;
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 1090, "!(page->items[i].fileId.storeOID==markerOid.storeOID)", v20);
LABEL_24:
    free(v19);
    if (!__valid_fs(-1))
    {
      v24 = 3072;
LABEL_27:
      *(_DWORD *)v24 = -559038737;
      abort();
    }
LABEL_25:
    v24 = 2989;
    goto LABEL_27;
  }
  v9 = (unint64_t *)(a1 + 16 * a2 + 24);
  while (1)
  {
    v10 = v8 - 1;
    result = *v9;
    if (*v9 <= 1)
      break;
    result = getHash(result, a3, *(_BYTE *)(a1 + 2), a4, 10, 0);
    if (v8 == result)
      goto LABEL_20;
    *((_OWORD *)v9 - 1) = *(_OWORD *)v9;
    ++v8;
    v9 += 2;
    if (a3 == v8)
      goto LABEL_6;
  }
  if (*v9 == 1)
  {
    v22 = __si_assert_copy_extra(0);
    v19 = v22;
    v23 = "";
    if (v22)
      v23 = v22;
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 1059, "!(page->items[i].fileId.storeOID==markerOid.storeOID)", v23);
    goto LABEL_24;
  }
LABEL_20:
  v21 = a1 + 16 * v10;
  *(_QWORD *)(v21 + 8) = 0;
  *(_QWORD *)(v21 + 16) = 0;
  return result;
}

int64_t *directoryStoreTreeFindItemOffset(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, unsigned int *a5, int a6, int a7)
{
  int v7;
  int v8;
  unsigned int *v9;
  uint64_t v10;
  unint64_t v11;
  int64_t v12;
  uint64_t v13;
  char *PageInner;
  int8x8_t v15;
  char *v16;
  unint64_t Size;
  uint64_t v18;
  uint64_t v19;
  int Hash;
  int v21;
  uint64_t v22;
  int64_t *result;
  unint64_t v24;
  char *v25;
  char *v26;
  int8x8_t v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  int8x8_t v31;
  uint64_t v32;
  unint64_t v33;
  char *v34;
  int8x8_t v35;
  char *v36;
  uint64_t v37;
  _QWORD v38[3];
  char v39;
  unint64_t v40;
  uint64_t v41;
  BOOL v42;

  while (1)
  {
    v7 = a7;
    v8 = a6;
    v9 = a5;
    v10 = a4;
    v11 = a3;
    v12 = a2;
    v13 = a1;
    v42 = 0;
    PageInner = _directoryStoreGetPageInner(a1, a2, &v42);
    if (v42 || (v16 = PageInner, *((unsigned __int16 *)PageInner + 3) != v8))
    {
LABEL_26:
      v36 = __si_assert_copy_extra(0);
      goto LABEL_30;
    }
    Size = directoryTreePageGetSize(*(_WORD *)PageInner, PageInner[2], v15);
    if (v10)
    {
      if (v12 <= 0)
        goto LABEL_26;
      *(_DWORD *)(v10 + 4 * *(unsigned int *)(v10 + 96) + 64) = 891;
      v18 = *(unsigned int *)(v10 + 96);
      *(_DWORD *)(v10 + 96) = v18 + 1;
      *(_QWORD *)(v10 + 8 * v18) = v12;
    }
    v19 = (v8 + 1);
    Hash = getHash(v11, Size, 0, v19, 0, 0);
    v21 = Hash;
    if (v7)
      break;
    v33 = *(_QWORD *)&v16[8 * Hash + 8];
    if (!v33)
      return 0;
    if (v33 >> 62 == 1)
    {
      v34 = _directoryStoreGetPageInner(v13, v33, &v42);
      if (v10)
      {
        *(_QWORD *)(v10 + 104) = v33;
        *(_DWORD *)(v10 + 112) = 934;
      }
      return directoryStorePageFindItemOffset(*(_DWORD **)(v13 + 216), (uint64_t)v34, v11, v9, v19, v35);
    }
    a1 = v13;
    a2 = v33;
    a3 = v11;
    a4 = v10;
    a5 = v9;
    a6 = v19;
    a7 = 0;
  }
  v22 = *(_QWORD *)&v16[8 * Hash + 8];
  v40 = v11;
  v41 = v22;
  v39 = 0;
  v38[1] = 0;
  v38[2] = 0;
  v38[0] = &v40;
  result = (int64_t *)directoryStoreEnsurePage(v13, (uint64_t)v38, 4 * (v22 == 0), v22 != 0, &v39, &v42, v19, v10);
  if (result)
  {
    v24 = (unint64_t)result;
    if (!v39)
      goto LABEL_11;
    v25 = _directoryStoreGetPageInner(v13, v12, &v42);
    if (v42)
      goto LABEL_29;
    *(_QWORD *)&v25[8 * v21 + 8] = v41;
    dirtyStoragePage(v13, (unint64_t)v25);
LABEL_11:
    if (v24 >> 62 == 1)
    {
      v26 = _directoryStoreGetPageInner(v13, v24, &v42);
      v28 = (uint64_t)v26;
      if (v10)
      {
        *(_QWORD *)(v10 + 104) = v24;
        *(_DWORD *)(v10 + 112) = 918;
      }
      v29 = *(unsigned __int16 *)v26;
      if ((64 << v26[2]) - 8 < (int)v29)
      {
        v36 = __si_assert_copy_extra(0);
        __message_assert("%s:%u: failed assertion '%s' %s Got end %d and size %d");
      }
      else
      {
        v30 = 5 * (v29 >> 4) + 5;
        v31 = (int8x8_t)directoryStorePageGetSize((unsigned __int16 *)v26, v27);
        if (v30 < 4 * v32)
          return directoryStorePageFindItemOffset(*(_DWORD **)(v13 + 216), v28, v11, v9, v19, v31);
LABEL_29:
        v36 = __si_assert_copy_extra(0);
LABEL_30:
        __message_assert("%s:%u: failed assertion '%s' %s ");
      }
      free(v36);
      if (__valid_fs(-1))
        v37 = 2989;
      else
        v37 = 3072;
      *(_DWORD *)v37 = -559038737;
      abort();
    }
    return (int64_t *)directoryStoreTreeFindItemOffset(v13, v24, v11, v10, v9, v19, 1);
  }
  return result;
}

unint64_t directoryStoreEnsurePage(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, _BYTE *a5, BOOL *a6, unsigned int a7, uint64_t a8)
{
  uint64_t v14;
  unint64_t v15;
  int64_t v16;
  char *v17;
  int8x8_t v18;
  char *v19;
  int v20;
  int v21;
  unint64_t v23;
  char *PageInner;
  int64_t *v25;
  uint64_t v26;
  int64_t v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int v30;
  int v31;
  unsigned int v32;
  unint64_t v33;
  char *v34;
  char v35;
  char *v36;
  int8x8_t v37;
  unsigned __int16 *v38;
  int8x8_t v39;
  uint64_t v40;
  unint64_t v41;
  unsigned __int16 *v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  int8x8_t Size;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  char *v51;
  char *v52;
  unsigned __int16 *v53;
  unsigned int v54;
  unint64_t v55;
  int8x8_t v56;
  uint64_t v57;
  uint64_t v58;
  char *v59;
  char v60;
  char *v61;
  int8x8_t v62;
  uint64_t ItemOffset;
  char *v64;
  char *v65;
  const char *v66;
  size_t v67;
  _QWORD *v68;
  int8x8_t v69;
  uint64_t v70;
  int v71;
  uint64_t v72;
  _OWORD *v73;
  uint64_t v74;
  char *v75;
  unsigned __int16 *v76;
  int8x8_t v77;
  unsigned __int16 *v78;
  uint64_t v79;
  unint64_t v80;
  __int128 v81;
  unint64_t v82;
  char *v83;
  unint64_t v84;
  int v85;
  char *v86;
  int8x8_t v87;
  unint64_t v88;
  char v89;
  unint64_t v90;
  char *v91;
  char *v93;
  const char *v94;
  char *v95;
  char *v96;
  const char *v97;
  char *v98;
  const char *v99;
  uint64_t v100;
  char *v101;
  const char *v102;
  int v103;
  int v104;
  char *v105;
  uint64_t v106;
  char *v107;
  const char *v108;
  char *v109;
  const char *v110;
  char *v111;
  char *v112;
  const char *v113;
  char *v114;
  const char *v115;
  char *v116;
  const char *v117;
  int *v118;
  char *v119;
  const char *v120;
  uint64_t v121;
  _BYTE v122[4];
  unsigned int v123;
  unsigned int v124;
  BOOL v125;
  __int128 v126;
  __int128 v127;
  __int128 v128;
  __int128 v129;
  __int128 v130;
  __int128 v131;
  __int128 v132;
  __int128 v133;
  __int128 v134;
  __int128 v135;
  __int128 v136;
  __int128 v137;
  uint64_t v138;

  v123 = a7;
  v138 = *MEMORY[0x1E0C80C00];
  v14 = *(_QWORD *)a2;
  v15 = *(_QWORD *)(v14 + 8);
  *a6 = 1;
  *a5 = 0;
  v16 = *(_QWORD *)(v14 + 8);
  if (v16 <= 0)
  {
    directoryStoreValidate(a1, v14);
    v23 = *(_QWORD *)(a2 + 8);
    if (v23)
    {
      PageInner = _directoryStoreGetPageInner(a1, v23, a6);
      v25 = (int64_t *)&PageInner[16 * *(unsigned int *)(a2 + 16) + 8];
      *(_QWORD *)a2 = v25;
    }
    else
    {
      PageInner = 0;
      v25 = *(int64_t **)a2;
    }
    *a5 = 1;
    if (a4)
      v26 = ((unint64_t)v16 >> 63) + 1;
    else
      v26 = a3;
    v27 = *v25;
    v28 = v16 & (v16 >> 63) & 0x7FFFFFFFFFFFFFFFLL;
    if ((unint64_t)(16 * v26) <= 0x4000)
    {
      v29 = v123;
      if (a8)
        *(_DWORD *)(a8 + 96) = v123;
      v30 = 16 * v26;
      v31 = 64;
      do
      {
        v32 = v31;
        v31 *= 2;
      }
      while (v32 < v30);
      v136 = 0u;
      v137 = 0u;
      v134 = 0u;
      v135 = 0u;
      v132 = 0u;
      v133 = 0u;
      v130 = 0u;
      v131 = 0u;
      v129 = 0u;
      v128 = 0u;
      v127 = 0u;
      v126 = 0u;
      v124 = 0;
      v33 = storageAllocOffset(a1, v32, (uint64_t)&v126, (int *)&v124);
      if (v124)
        dirtyStorageOffsets(a1, (unint64_t *)&v126, v124);
      if (v33)
      {
        v34 = storageResolvePtr(a1, v33, v32, 1);
        v29 = v123;
        bzero(v34, v32);
        *(_WORD *)v34 = 0;
        v35 = __clz(__rbit32(v32 >> 6));
        if (!v32)
          v35 = -1;
        v34[2] = v35;
        *((_WORD *)v34 + 3) = v29;
        *((_WORD *)v34 + 2) = 668;
        v34[3] = 0;
        dirtyStoragePage(a1, (unint64_t)v34);
      }
      v15 = v33 | 0x4000000000000000;
      if (!v28)
        goto LABEL_31;
    }
    else
    {
      v29 = v123;
      v15 = directoryStoreNewTreePage(a1, v123, 663, 0);
      *a6 = 0;
      if (!v28)
      {
LABEL_31:
        v43 = *(_QWORD *)(a2 + 8);
        if (v43)
        {
          PageInner = _directoryStoreGetPageInner(a1, v43, a6);
          *(_QWORD *)a2 = &PageInner[16 * *(unsigned int *)(a2 + 16) + 8];
        }
        if (PageInner)
          dirtyStoragePage(a1, (unint64_t)PageInner);
        goto LABEL_89;
      }
    }
    v124 = 0;
    v36 = _directoryStoreGetPageInner(a1, v15, a6);
    if (*a6)
    {
      v38 = (unsigned __int16 *)v36;
      if (!directoryStorePageFindItemOffset(*(_DWORD **)(a1 + 216), (uint64_t)v36, v27, &v124, v29, v37))
      {
LABEL_28:
        v40 = v124;
        if (*(_QWORD *)&v38[8 * v124 + 4] >= 2uLL)
        {
          directoryStorePageGetSize(v38, v39);
          shiftEntries((uint64_t)v38, v40, v41);
          v40 = v124;
        }
        v42 = &v38[8 * v40];
        *((_QWORD *)v42 + 1) = v27;
        *((_QWORD *)v42 + 2) = v28 | 0x8000000000000000;
        *v38 += 16;
        goto LABEL_31;
      }
    }
    else
    {
      *(_QWORD *)&v133 = 0;
      v131 = 0u;
      v132 = 0u;
      v129 = 0u;
      v130 = 0u;
      v128 = 0u;
      v127 = 0u;
      v126 = 0u;
      ItemOffset = directoryStoreTreeFindItemOffset(a1, v15, v27, &v126, &v124, v29, 1);
      v38 = (unsigned __int16 *)_directoryStoreGetPageInner(a1, *((unint64_t *)&v132 + 1), &v125);
      if (!ItemOffset)
        goto LABEL_28;
    }
    v64 = __si_assert_copy_extra(0);
    v65 = v64;
    v66 = "";
    if (v64)
      v66 = v64;
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 686, "element==0", v66);
    goto LABEL_111;
  }
  if ((v16 & 0x4000000000000000) == 0)
    return v15;
  directoryStoreValidate(a1, v14);
  v17 = _directoryStoreGetPageInner(a1, v16, a6);
  v19 = v17;
  v20 = *(unsigned __int16 *)v17;
  if (a4)
  {
    v21 = (64 << v17[2]) - 8;
    if (v21 < v20)
      goto LABEL_107;
    a3 = (v20 >> 4) + 1;
  }
  else
  {
    v21 = (64 << v17[2]) - 8;
  }
  if (v21 < v20)
  {
    v101 = __si_assert_copy_extra(0);
    v65 = v101;
    v102 = "";
    if (v101)
      v102 = v101;
    v103 = *(unsigned __int16 *)v19;
    v104 = 64 << v19[2];
    goto LABEL_110;
  }
  v44 = v20 >> 4;
  if (a3 >= v44)
    v45 = a3;
  else
    v45 = (v44 + 1);
  if (v45 >= 3)
    v46 = v45;
  else
    v46 = v45 + 1;
  Size = (int8x8_t)directoryStorePageGetSize((unsigned __int16 *)v17, v18);
  if (5 * v46 < 4 * v48)
    return v15;
  *a5 = 1;
  directoryStorePageGetSize((unsigned __int16 *)v19, Size);
  if (v49 != 1023 && (5 * v46) < 0xFFDuLL)
  {
    v50 = *(_QWORD *)(a2 + 8);
    if (v50)
    {
      v51 = _directoryStoreGetPageInner(a1, v50, a6);
      *(_QWORD *)a2 = &v51[16 * *(unsigned int *)(a2 + 16) + 8];
      dirtyStoragePage(a1, (unint64_t)v51);
    }
    v15 = *(_QWORD *)(*(_QWORD *)a2 + 8);
    v52 = _directoryStoreGetPageInner(a1, v15, &v125);
    v53 = (unsigned __int16 *)v52;
    v54 = 64 << v52[2];
    v55 = ((20 * (_DWORD)v46) & 0xFFFFFFF0) + 16;
    LODWORD(v46) = v54;
    do
      v46 = (2 * v46);
    while (v55 > v46);
    if ((int)(v54 - 8) < *(unsigned __int16 *)v52)
    {
      v107 = __si_assert_copy_extra(0);
      v65 = v107;
      v108 = "";
      if (v107)
        v108 = v107;
      __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 587, "storePageEnd((StorePageRef)page) <= storePageDataSize((StorePageRef)page)", v108);
    }
    else
    {
      dirtyStoragePage(a1, (unint64_t)v52);
      directoryStorePageGetSize(v53, v56);
      v58 = v57;
      if (storageExtendOffset(a1, v15, v54, v46))
      {
        v59 = _directoryStoreGetPageInner(a1, v15, (BOOL *)&v126);
        v60 = __clz(__rbit32(v46 >> 6));
        if (!(_DWORD)v46)
          v60 = -1;
        v59[2] = v60;
        dirtyStoragePage(a1, (unint64_t)v59);
        if (*(_QWORD *)(a1 + 232) > v15)
        {
          v61 = _directoryStoreGetPageInner(a1, v15, &v125);
          rehashPage(a1, (uint64_t)v61, v58, v123, v62);
          dirtyStoragePage(a1, (unint64_t)v61);
          if (!v15)
            return v15;
          goto LABEL_86;
        }
        v111 = __si_assert_copy_extra(*(_DWORD **)(a1 + 216));
        v112 = v111;
        v113 = "";
        if (v111)
          v113 = v111;
        __message_assert("%s:%u: failed assertion '%s' %s file tree", "FileTree.c", 595, "getOffset(info) < storageGetCount(store)", v113);
        goto LABEL_134;
      }
      v136 = 0u;
      v137 = 0u;
      v134 = 0u;
      v135 = 0u;
      v132 = 0u;
      v133 = 0u;
      v130 = 0u;
      v131 = 0u;
      v129 = 0u;
      v128 = 0u;
      v127 = 0u;
      v126 = 0u;
      v124 = 0;
      if (v46 <= 0x4000)
      {
        v84 = storageGrowOffset(a1, v15 & 0x3FFFFFFFFFFFFFFFLL, v54, v46, (uint64_t)&v126, (int *)&v124);
        if (v84)
        {
          v15 = v84;
          storageResolvePtr(a1, v84, v46, 1);
          if (v124)
            dirtyStorageOffsets(a1, (unint64_t *)&v126, v124);
          v85 = v123;
          if (v15 < *(_QWORD *)(a1 + 232))
          {
            v86 = _directoryStoreGetPageInner(a1, v15, &v125);
            v88 = (unint64_t)v86;
            *((_WORD *)v86 + 3) = v123;
            *((_WORD *)v86 + 2) = 808;
            v89 = __clz(__rbit32(v46 >> 6));
            if (!(_DWORD)v46)
              v89 = -1;
            v86[2] = v89;
            rehashPage(a1, (uint64_t)v86, v58, v85, v87);
            dirtyStoragePage(a1, v88);
LABEL_86:
            v90 = *(_QWORD *)(a2 + 8);
            if (v90)
            {
              v91 = _directoryStoreGetPageInner(a1, v90, a6);
              *(_QWORD *)a2 = &v91[16 * *(unsigned int *)(a2 + 16) + 8];
              dirtyStoragePage(a1, (unint64_t)v91);
            }
            v15 |= 0x4000000000000000uLL;
LABEL_89:
            *(_QWORD *)(*(_QWORD *)a2 + 8) = v15;
            return v15;
          }
          v119 = __si_assert_copy_extra(*(_DWORD **)(a1 + 216));
          v112 = v119;
          v120 = "";
          if (v119)
            v120 = v119;
          __message_assert("%s:%u: failed assertion '%s' %s file tree", "FileTree.c", 617, "getOffset(*newOffset) < storageGetCount(store)", v120);
        }
        else
        {
          v116 = __si_assert_copy_extra(*(_DWORD **)(a1 + 216));
          v112 = v116;
          if (v116)
            v117 = v116;
          else
            v117 = "";
          v118 = __error();
          __message_assert("%s:%u: failed assertion '%s' %s error %d expanding from old:%d new:%d", "FileTree.c", 323, "newRealOffset", v117, *v118, v54, v46);
        }
LABEL_134:
        free(v112);
        if (__valid_fsp(*(_DWORD **)(a1 + 216)))
          v121 = 2989;
        else
          v121 = 3072;
        *(_DWORD *)v121 = -559038737;
        abort();
      }
      v114 = __si_assert_copy_extra(0);
      v65 = v114;
      v115 = "";
      if (v114)
        v115 = v114;
      __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 609, "reSize<=((1<<(10))* sizeof(CIDirectory_t))", v115);
    }
LABEL_111:
    free(v65);
    if (__valid_fs(-1))
      v106 = 2989;
    else
      v106 = 3072;
    *(_DWORD *)v106 = -559038737;
    abort();
  }
  if ((64 << v19[2]) - 8 < *(unsigned __int16 *)v19)
  {
LABEL_107:
    v105 = __si_assert_copy_extra(0);
    v65 = v105;
    v102 = "";
    if (v105)
      v102 = v105;
    v103 = *(unsigned __int16 *)v19;
    v104 = 64 << v19[2];
LABEL_110:
    __message_assert("%s:%u: failed assertion '%s' %s Got end %d and size %d", "FileTree.c", 287, "storePageEnd((StorePageRef)page) <= storePageDataSize((StorePageRef)page)", v102, v103, v104 - 8);
    goto LABEL_111;
  }
  MEMORY[0x1E0C80A78](v49);
  v68 = &v122[-v67];
  bzero(&v122[-v67], v67);
  directoryStorePageGetSize((unsigned __int16 *)v19, v69);
  v71 = v19[3];
  v72 = 0;
  if (v70)
  {
    v73 = v19 + 8;
    do
    {
      if (*(uint64_t *)v73 >= 2)
        *(_OWORD *)&v68[2 * v72++] = *v73;
      ++v73;
      --v70;
    }
    while (v70);
  }
  *(_QWORD *)&v126 = v16 & 0x3FFFFFFFFFFFFFFFLL;
  storageFreeOffset(a1, v16 & 0x3FFFFFFFFFFFFFFFLL, 64 << v19[2]);
  dirtyStorageOffsets(a1, (unint64_t *)&v126, 1);
  v74 = v123;
  v15 = directoryStoreNewTreePage(a1, v123, 749, v71);
  if (v72)
  {
    while (1)
    {
      v124 = 0;
      *(_QWORD *)&v133 = 0;
      v131 = 0u;
      v132 = 0u;
      v129 = 0u;
      v130 = 0u;
      v128 = 0u;
      v127 = 0u;
      v126 = 0u;
      v75 = _directoryStoreGetPageInner(a1, v15, a6);
      dirtyStoragePage(a1, (unint64_t)v75);
      if (*a6)
        break;
      directoryStoreTreeFindItemOffset(a1, v15, *v68, &v126, &v124, v74, 1);
      v76 = (unsigned __int16 *)_directoryStoreGetPageInner(a1, *((unint64_t *)&v132 + 1), a6);
      if (!*a6)
      {
        v95 = __si_assert_copy_extra(0);
        v96 = v95;
        v97 = "";
        if (v95)
          v97 = v95;
        __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 762, "*flat", v97);
LABEL_100:
        free(v96);
        if (__valid_fs(-1))
          v100 = 2989;
        else
          v100 = 3072;
        *(_DWORD *)v100 = -559038737;
        abort();
      }
      if (*((_QWORD *)&v132 + 1) == v15)
      {
        v98 = __si_assert_copy_extra(0);
        v96 = v98;
        v99 = "";
        if (v98)
          v99 = v98;
        __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 763, "l_outPage.leafPageOffset != getOffset(newChildPage)", v99);
        goto LABEL_100;
      }
      v78 = v76;
      v79 = v124;
      if (*(_QWORD *)&v76[8 * v124 + 4] >= 2uLL)
      {
        directoryStorePageGetSize(v76, v77);
        shiftEntries((uint64_t)v78, v79, v80);
        v79 = v124;
      }
      v81 = *(_OWORD *)v68;
      v68 += 2;
      *(_OWORD *)&v78[8 * v79 + 4] = v81;
      *v78 += 16;
      dirtyStoragePage(a1, (unint64_t)v78);
      if (!--v72)
        goto LABEL_74;
    }
    v93 = __si_assert_copy_extra(0);
    v65 = v93;
    v94 = "";
    if (v93)
      v94 = v93;
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 759, "*flat==0", v94);
    goto LABEL_111;
  }
LABEL_74:
  v82 = *(_QWORD *)(a2 + 8);
  if (v82)
  {
    v83 = _directoryStoreGetPageInner(a1, v82, a6);
    *(_QWORD *)a2 = &v83[16 * *(unsigned int *)(a2 + 16) + 8];
    dirtyStoragePage(a1, (unint64_t)v83);
  }
  *(_QWORD *)(*(_QWORD *)a2 + 8) = v15;
  *a6 = 0;
  if (!_directoryStoreGetPageInner(a1, v15, a6))
  {
    v109 = __si_assert_copy_extra(0);
    v96 = v109;
    v110 = "";
    if (v109)
      v110 = v109;
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 796, "page", v110);
    goto LABEL_100;
  }
  return v15;
}

unint64_t directoryStoreNewTreePage(uint64_t a1, __int16 a2, __int16 a3, int a4)
{
  unint64_t v7;
  char *v8;
  int8x8_t v9;
  char *v11;
  char *v12;
  const char *v13;
  char *v14;
  const char *v15;
  uint64_t v16;
  unint64_t v17;
  int v18;
  _OWORD v19[12];
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  if (a4)
  {
    v11 = __si_assert_copy_extra(0);
    v12 = v11;
    v13 = "";
    if (v11)
      v13 = v11;
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 371, "specialBits == 0", v13);
LABEL_13:
    free(v12);
    if (__valid_fs(-1))
      v16 = 2989;
    else
      v16 = 3072;
    *(_DWORD *)v16 = -559038737;
    abort();
  }
  memset(v19, 0, sizeof(v19));
  v18 = 0;
  v7 = storageAllocOffset(a1, 0x800u, (uint64_t)v19, &v18);
  v17 = v7;
  if (v18)
    dirtyStorageOffsets(a1, (unint64_t *)v19, v18);
  if (v7)
  {
    v8 = storageResolvePtr(a1, v7, 0x800uLL, 1);
    bzero(v8, 0x800uLL);
    v8[2] = 5;
    *((_WORD *)v8 + 3) = a2;
    *((_WORD *)v8 + 2) = a3;
    directoryTreePageGetSize(0, 5, v9);
    dirtyStorageOffsets(a1, &v17, 1);
    if (v7 >> 62 == 1)
    {
      v14 = __si_assert_copy_extra(0);
      v12 = v14;
      v15 = "";
      if (v14)
        v15 = v14;
      __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 407, "!(((realOffset & (1ull << 63)) ==0) && (realOffset & (1ull << 62))==(1ull << 62))", v15);
      goto LABEL_13;
    }
  }
  return v7;
}

uint64_t shiftEntries(uint64_t result, uint64_t a2, unint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  char *v16;
  const char *v17;
  char *v18;
  char *v19;
  const char *v20;
  char *v21;
  const char *v22;
  char *v23;
  const char *v24;
  char *v25;
  const char *v26;
  uint64_t v27;
  char *v28;
  char *v29;
  const char *v30;
  char *v31;
  const char *v32;
  uint64_t v33;

  v3 = result + 16 * a2;
  v6 = *(_QWORD *)(v3 + 8);
  v4 = v3 + 8;
  v5 = v6;
  if (!v6)
  {
    v18 = __si_assert_copy_extra(0);
    v19 = v18;
    v20 = "";
    if (v18)
      v20 = v18;
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 1197, "dir.fileId.storeOID!=0", v20);
LABEL_36:
    free(v19);
    if (!__valid_fs(-1))
    {
      v27 = 3072;
LABEL_39:
      *(_DWORD *)v27 = -559038737;
      abort();
    }
LABEL_37:
    v27 = 2989;
    goto LABEL_39;
  }
  if (v5 == 1)
  {
    v21 = __si_assert_copy_extra(0);
    v19 = v21;
    v22 = "";
    if (v21)
      v22 = v21;
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 1198, "getStoreOID(dir.fileId)!=1", v22);
    goto LABEL_36;
  }
  v7 = *(_QWORD *)(v4 + 8);
  v8 = a2 + 1;
  if (a2 + 1 < a3)
  {
    v9 = (uint64_t *)(result + 16 * a2 + 24);
    while (1)
    {
      v10 = *v9;
      if ((unint64_t)*v9 <= 1)
        break;
      v11 = v9[1];
      ++v8;
      *v9 = v5;
      v9[1] = v7;
      v9 += 2;
      v5 = v10;
      v7 = v11;
      if (a3 == v8)
        goto LABEL_9;
    }
    if (*(_QWORD *)(result + 16 * v8 + 16))
    {
      v28 = __si_assert_copy_extra(0);
      v29 = v28;
      v30 = "";
      if (v28)
        v30 = v28;
      __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 1204, "page->items[i].childPage.offset==0", v30);
    }
    else
    {
      if (v10 != 1)
      {
        *v9 = v5;
        goto LABEL_23;
      }
      v31 = __si_assert_copy_extra(0);
      v29 = v31;
      v32 = "";
      if (v31)
        v32 = v31;
      __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 1205, "page->items[i].fileId.storeOID!=markerOid.storeOID", v32);
    }
    free(v29);
    if (__valid_fs(-1))
      v33 = 2989;
    else
      v33 = 3072;
    *(_DWORD *)v33 = -559038737;
    abort();
  }
  v11 = v7;
  v10 = v5;
LABEL_9:
  if (!a2)
  {
LABEL_13:
    v15 = __si_assert_copy_extra(0);
    v16 = v15;
    if (v15)
      v17 = v15;
    else
      v17 = "";
    __message_assert("%s:%u: Unexpected code path %s ", "FileTree.c", 1227, v17);
    free(v16);
    goto LABEL_37;
  }
  v8 = 0;
  v12 = (uint64_t *)(result + 8);
  while (1)
  {
    v13 = *v12;
    if ((unint64_t)*v12 <= 1)
      break;
    v14 = v12[1];
    ++v8;
    *v12 = v10;
    v12[1] = v11;
    v12 += 2;
    v10 = v13;
    v11 = v14;
    if (a2 == v8)
      goto LABEL_13;
  }
  if (*v12 == 1)
  {
    v23 = __si_assert_copy_extra(0);
    v19 = v23;
    v24 = "";
    if (v23)
      v24 = v23;
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 1216, "page->items[i].fileId.storeOID!=markerOid.storeOID", v24);
    goto LABEL_36;
  }
  if (*(_QWORD *)(result + 16 * v8 + 16))
  {
    v25 = __si_assert_copy_extra(0);
    v19 = v25;
    v26 = "";
    if (v25)
      v26 = v25;
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 1217, "page->items[i].childPage.offset==0", v26);
    goto LABEL_36;
  }
  *v12 = v10;
  v7 = v11;
LABEL_23:
  *(_QWORD *)(result + 16 * v8 + 16) = v7;
  return result;
}

void rehashPage(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int8x8_t a5)
{
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;
  char v18;
  int64_t v19;
  unsigned int Hash;
  int8x8_t v21;
  uint64_t v22;
  char *v23;
  char *v24;
  const char *v25;
  uint64_t v26;
  __int128 v27;
  unint64_t v28[3];
  unsigned int v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  directoryStorePageGetSize((unsigned __int16 *)a2, a5);
  if (*(unsigned __int16 *)(a2 + 6) != a4)
  {
    v23 = __si_assert_copy_extra(0);
    v24 = v23;
    v25 = "";
    if (v23)
      v25 = v23;
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 459, "getNum16(page->depth)==(unsigned)depth", v25);
    free(v24);
    if (__valid_fs(-1))
      v26 = 2989;
    else
      v26 = 3072;
    *(_DWORD *)v26 = -559038737;
    abort();
  }
  v10 = v9;
  v29 = 0;
  bzero((void *)(a2 + 16 * a3 + 8), 16 * (v9 - a3));
  MEMORY[0x1E0C80A78](v11);
  v12 = &v28[-2 * a3 - 1];
  bzero(v12, 16 * a3);
  if (a3)
  {
    v13 = 0;
    v14 = 8;
    do
    {
      v15 = a2 + v14;
      v16 = *(_QWORD *)(a2 + v14);
      if (v16)
      {
        if (v16 != 1)
          *(_OWORD *)&v12[2 * v13++] = *(_OWORD *)v15;
        *(_QWORD *)v15 = 0;
        *(_QWORD *)(v15 + 8) = 0;
      }
      v14 += 16;
      --a3;
    }
    while (a3);
    for (*(_WORD *)a2 = 0; v13; --v13)
    {
      v17 = *(_OWORD *)v12;
      v28[0] = 0;
      v18 = *(_BYTE *)(a2 + 2);
      v27 = v17;
      v19 = v17;
      Hash = getHash(v17, v10, v18, a4, 10, v28);
      v29 = Hash;
      if (*(_QWORD *)(a2 + 16 * Hash + 8))
      {
        directoryStorePageFindItemOffset(*(_DWORD **)(a1 + 216), a2, v19, &v29, a4, v21);
        v22 = v29;
        if (*(_QWORD *)(a2 + 16 * v29 + 8))
        {
          shiftEntries(a2, v29, v10);
          v22 = v29;
        }
      }
      else
      {
        v22 = Hash;
      }
      *(_OWORD *)(a2 + 16 * v22 + 8) = v27;
      *(_WORD *)a2 += 16;
      v12 += 2;
    }
  }
  else
  {
    *(_WORD *)a2 = 0;
  }
}

void insertDirectory_3213(uint64_t a1, uint64_t a2, __int128 *a3, unsigned int a4, unint64_t a5, uint64_t a6, uint64_t a7, _BYTE *a8, uint64_t a9)
{
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  char *v20;
  int8x8_t v21;
  unsigned __int16 *v22;
  int64_t *ItemOffset;
  int8x8_t v24;
  unint64_t v25;
  char *PageInner;
  char *v27;
  char *v28;
  uint64_t v29;
  unint64_t v30;
  unsigned __int16 *v31;
  uint64_t v32;
  unint64_t v33;
  unsigned int v34;
  char *v35;
  uint64_t v36;
  char *v37;
  char *v38;
  const char *v39;
  char *v40;
  const char *v41;
  char *v42;
  const char *v43;
  char *v44;
  const char *v45;
  uint64_t v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  uint64_t v54;
  BOOL v55;
  unsigned int v56;

  v56 = a4;
  if (a6 <= 1)
  {
    v35 = __si_assert_copy_extra(0);
LABEL_28:
    __message_assert("%s:%u: failed assertion '%s' %s ");
LABEL_29:
    free(v35);
    if (__valid_fs(-1))
      v36 = 2989;
    else
      v36 = 3072;
    *(_DWORD *)v36 = -559038737;
    abort();
  }
  v55 = 0;
  v16 = *((_QWORD *)a3 + 1);
  if (v16)
    *(_QWORD *)a3 = &_directoryStoreGetPageInner(a2, v16, &v55)[16 * *((unsigned int *)a3 + 4) + 8];
  v47 = *a3;
  *(_QWORD *)&v48 = *((_QWORD *)a3 + 2);
  v17 = directoryStoreEnsurePage(a2, (uint64_t)&v47, 0, 1, a8, &v55, 0, a9);
  if (a6 != a5)
  {
LABEL_27:
    v35 = __si_assert_copy_extra(0);
    goto LABEL_28;
  }
  v18 = v17;
  v19 = v17 & 0xC000000000000000;
  if (!*a8)
  {
    v25 = v17;
    if (v19 == 0x4000000000000000)
      goto LABEL_17;
    v54 = 0;
    v52 = 0u;
    v53 = 0u;
    v50 = 0u;
    v51 = 0u;
    v48 = 0u;
    v49 = 0u;
    v47 = 0u;
    if (directoryStoreTreeFindItemOffset(a2, v17, a5, (uint64_t)&v47, &v56, 0, 1))
    {
      v42 = __si_assert_copy_extra(0);
      v38 = v42;
      v43 = "";
      if (v42)
        v43 = v42;
      __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 1275, "elem==0", v43);
    }
    else
    {
      PageInner = _directoryStoreGetPageInner(a2, *((unint64_t *)&v53 + 1), &v55);
      if (v55)
      {
        v22 = (unsigned __int16 *)PageInner;
        v25 = *((_QWORD *)&v53 + 1);
        goto LABEL_16;
      }
      v44 = __si_assert_copy_extra(0);
      v38 = v44;
      v45 = "";
      if (v44)
        v45 = v44;
      __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 1278, "flat", v45);
    }
    goto LABEL_45;
  }
  if (v19 == 0x4000000000000000)
  {
    v20 = _directoryStoreGetPageInner(a2, v17, &v55);
    if (v55)
    {
      v22 = (unsigned __int16 *)v20;
      ItemOffset = directoryStorePageFindItemOffset(*(_DWORD **)(a2 + 216), (uint64_t)v20, a5, &v56, 0, v21);
      v25 = v18;
      goto LABEL_15;
    }
    v37 = __si_assert_copy_extra(0);
    v38 = v37;
    v39 = "";
    if (v37)
      v39 = v37;
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 1260, "flat", v39);
LABEL_45:
    free(v38);
    if (__valid_fs(-1))
      v46 = 2989;
    else
      v46 = 3072;
    *(_DWORD *)v46 = -559038737;
    abort();
  }
  ItemOffset = directoryStoreTreeFindItemOffset(a2, v17, a5, a9, &v56, 0, 1);
  v27 = _directoryStoreGetPageInner(a2, *(_QWORD *)(a9 + 104), &v55);
  if (!v55)
  {
    v40 = __si_assert_copy_extra(0);
    v38 = v40;
    v41 = "";
    if (v40)
      v41 = v40;
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 1267, "flat", v41);
    goto LABEL_45;
  }
  v22 = (unsigned __int16 *)v27;
  v25 = *(_QWORD *)(a9 + 104);
LABEL_15:
  if (ItemOffset)
    goto LABEL_27;
LABEL_16:
  if (v22)
    goto LABEL_19;
LABEL_17:
  v28 = _directoryStoreGetPageInner(a2, v18, &v55);
  if (!v55)
    goto LABEL_27;
  v22 = (unsigned __int16 *)v28;
LABEL_19:
  v29 = v56;
  if (*(_QWORD *)&v22[8 * v56 + 4] >= 2uLL)
  {
    directoryStorePageGetSize(v22, v24);
    shiftEntries((uint64_t)v22, v29, v30);
    v29 = v56;
  }
  v31 = &v22[8 * v29];
  *((_QWORD *)v31 + 1) = a5;
  *((_QWORD *)v31 + 2) = a7;
  *v22 += 16;
  directoryStorePageGetSize(v22, v24);
  v33 = *v22;
  if ((64 << *((_BYTE *)v22 + 2)) - 8 < (int)v33)
  {
    v35 = __si_assert_copy_extra(0);
    __message_assert("%s:%u: failed assertion '%s' %s Got end %d and size %d");
    goto LABEL_29;
  }
  if (5 * (v33 >> 4) >= 4 * v32)
    goto LABEL_27;
  dirtyStoragePage(a2, (unint64_t)v22);
  v34 = v56;
  *(_QWORD *)a1 = &v22[8 * v56 + 4];
  *(_QWORD *)(a1 + 8) = v25;
  *(_DWORD *)(a1 + 16) = v34;
}

uint64_t directoryStoreMoveDirectory(uint64_t result, int a2, unint64_t *a3, int a4, uint64_t a5)
{
  uint64_t v9;
  uint64_t *v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  int32_t v16;
  uint64_t v17;
  int v18;
  unint64_t v19;
  unsigned int v20;
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(_QWORD);
  int v25;
  NSObject *v26;
  uint64_t v27;
  int64_t v28;
  int64_t *ItemOffset;
  unint64_t v30;
  uint64_t v31;
  unsigned __int16 *PageInner;
  uint64_t v33;
  int8x8_t v34;
  unint64_t v35;
  unint64_t v36;
  unsigned __int16 *v37;
  int8x8_t v38;
  int64_t *v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  char *v43;
  char v44;
  int64_t v45;
  char *v46;
  int8x8_t v47;
  int64_t *v48;
  BOOL v49;
  unsigned int v50;
  int64_t *v51;
  char *v52;
  uint64_t v53;
  unsigned int v54;
  uint64_t v55;
  void (*v56)(_QWORD);
  char *v57;
  uint64_t v58;
  char *v59;
  char *v60;
  const char *v61;
  uint64_t v62;
  char *v63;
  const char *v64;
  int v65;
  int v66;
  __int128 v67;
  uint64_t v68;
  BOOL v69[31];
  char v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  uint64_t v78;
  unsigned int v79;
  __int128 v80;
  uint64_t v81;
  unint64_t v82;
  unint64_t v83;
  unint64_t v84;
  unint64_t v85;
  char v86;
  BOOL v87;
  uint8_t buf[32];
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  uint64_t v94;
  uint64_t v95;

  v95 = *MEMORY[0x1E0C80C00];
  if (result)
  {
    v9 = result;
    v10 = (uint64_t *)(result + 4416);
    v11 = setCrashStateTarget(3);
    *(_BYTE *)v9 = 1;
    if (a2)
    {
      if (a3[a2 - 1] == *v10)
        v12 = a2 - 1;
      else
        v12 = a2;
      if (a4)
        goto LABEL_7;
    }
    else
    {
      v12 = 0;
      if (a4)
      {
LABEL_7:
        if (*(_QWORD *)(a5 + 8 * (a4 - 1)) == *v10)
          v13 = a4 - 1;
        else
          v13 = a4;
        v14 = *v10;
LABEL_13:
        if (v14 != 2)
        {
          v57 = __si_assert_copy_extra(0);
          __message_assert("%s:%u: failed assertion '%s' %s ");
          goto LABEL_64;
        }
        v15 = v9 + 8;
        v87 = 0;
        v86 = 1;
        if (!storageResolvePtr(v9 + 8, 0, 1uLL, 1))
          goto LABEL_60;
        v16 = OSAtomicIncrement32((int32_t *)exceptionSequenceNum);
        v85 = 0;
        v84 = 0;
        v17 = *(_QWORD *)(v9 + 224);
        v66 = v11;
        if (v17)
          v18 = *(_DWORD *)(v17 + 44);
        else
          v18 = -1;
        v19 = setThreadIdAndInfo(v18, sStorageExceptionCallbacks, v9 + 8, 1, v16);
        v85 = __PAIR64__(v19, HIDWORD(v19));
        v84 = __PAIR64__(v20, v21);
        v22 = *(_QWORD *)&threadData[18 * v19 + 2];
        v23 = v22 + 320 * HIDWORD(v19);
        v65 = *(_DWORD *)(v23 + 312);
        v24 = *(void (**)(_QWORD))(v23 + 224);
        if (v24)
          v24(*(_QWORD *)(v22 + 320 * HIDWORD(v19) + 288));
        v83 = v85;
        v82 = v84;
        if (_setjmp((int *)v23))
        {
          v25 = *__error();
          v26 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315394;
            *(_QWORD *)&buf[4] = "directoryStoreMoveDirectory";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 2074;
            _os_log_error_impl(&dword_1B8270000, v26, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
          }
          *__error() = v25;
          *(_DWORD *)(v23 + 312) = v65;
          CIOnThreadCleanUpReset(v82);
          dropThreadId(HIDWORD(v83), 1, v16);
          CICleanUpReset(HIDWORD(v83), HIDWORD(v82));
LABEL_59:
          v11 = v66;
LABEL_60:
          result = setCrashStateTarget(v11);
          if (v86)
            return result;
          result = directoryStoreValidate(v15, (uint64_t)v10);
          if (*v10 == 2)
            return result;
          v59 = __si_assert_copy_extra(0);
          v60 = v59;
          v61 = "";
          if (v59)
            v61 = v59;
          __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 2084, "getStoreOID(root->fileId)==2", v61);
LABEL_71:
          free(v60);
          if (__valid_fs(-1))
            v62 = 2989;
          else
            v62 = 3072;
          *(_DWORD *)v62 = -559038737;
          abort();
        }
        directoryStoreValidate(v9 + 8, (uint64_t)v10);
        v27 = 0;
        *(_QWORD *)&buf[8] = 0;
        *(_QWORD *)&buf[16] = 0;
        v69[0] = 0;
        v71 = 0uLL;
        *(_QWORD *)&v72 = 0;
        *(_QWORD *)buf = v10;
        directoryStoreGetDirectoryWithPath((unsigned __int16 *)&v71, v9 + 8, (unint64_t *)buf, v12 - 2, (uint64_t)(a3 + 1), 0, 0);
        if (!(_QWORD)v71)
          goto LABEL_30;
        v28 = *(_QWORD *)(v71 + 8);
        if (v28 >= 1)
        {
          if ((v28 & 0x4000000000000000) == 0)
          {
            v27 = 0;
            v94 = 0;
            v92 = 0u;
            v93 = 0u;
            v90 = 0u;
            v91 = 0u;
            v89 = 0u;
            memset(buf, 0, sizeof(buf));
            LODWORD(v80) = 0;
            ItemOffset = directoryStoreTreeFindItemOffset(v9 + 8, v28, *a3, (uint64_t)buf, (unsigned int *)&v80, 0, 0);
            if (ItemOffset)
            {
              v30 = *ItemOffset;
              v31 = ItemOffset[1];
              *ItemOffset = 0;
              ItemOffset[1] = 0;
              PageInner = (unsigned __int16 *)_directoryStoreGetPageInner(v9 + 8, *((unint64_t *)&v93 + 1), v69);
              *PageInner -= 16;
              v33 = v80;
              directoryStorePageGetSize(PageInner, v34);
              shiftEntriesForDelete((uint64_t)PageInner, v33, v35, v93);
              if (!v69[0])
              {
                v63 = __si_assert_copy_extra(0);
                v60 = v63;
                v64 = "";
                if (v63)
                  v64 = v63;
                __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 1889, "flat", v64);
                goto LABEL_71;
              }
              v27 = v31;
              dirtyStoragePage(v9 + 8, (unint64_t)PageInner);
              goto LABEL_33;
            }
LABEL_30:
            v36 = 0;
LABEL_35:
            directoryStoreValidate(v9 + 8, (uint64_t)v10);
            if (!v36)
            {
LABEL_56:
              v86 = 0;
              v53 = *(_QWORD *)&threadData[18 * HIDWORD(v83) + 2];
              v54 = v83;
              v55 = v53 + 320 * v83;
              *(_DWORD *)(v55 + 312) = v65;
              v56 = *(void (**)(_QWORD))(v55 + 232);
              if (v56)
                v56(*(_QWORD *)(v53 + 320 * v54 + 288));
              dropThreadId(HIDWORD(v83), 0, v16);
              goto LABEL_59;
            }
            v94 = 0;
            v92 = 0u;
            v93 = 0u;
            v90 = 0u;
            v91 = 0u;
            v89 = 0u;
            memset(buf, 0, sizeof(buf));
            v80 = 0uLL;
            v81 = 0;
            *(_QWORD *)&v72 = 0;
            v71 = (unint64_t)v10;
            directoryStoreGetDirectoryWithPath((unsigned __int16 *)&v80, v9 + 8, (unint64_t *)&v71, v13 - 1, a5, 1, (uint64_t)buf);
            if (*((_QWORD *)&v80 + 1))
            {
              v43 = _directoryStoreGetPageInner(v9 + 8, *((unint64_t *)&v80 + 1), &v87);
              if (v43)
              {
                *(_QWORD *)&v80 = &v43[16 * v81 + 8];
                v44 = 0;
              }
              else
              {
                v44 = 1;
              }
            }
            else
            {
              v44 = 1;
            }
            v79 = 0;
            v45 = *(_QWORD *)(v80 + 8);
            if (v45 < 1)
            {
              v70 = 0;
              v50 = 0;
LABEL_55:
              v78 = 0;
              v76 = 0u;
              v77 = 0u;
              v74 = 0u;
              v75 = 0u;
              v72 = 0u;
              v73 = 0u;
              v71 = 0u;
              v67 = v80;
              v68 = v81;
              insertDirectory_3213((uint64_t)v69, v15, &v67, v50, v36, v36, v27, &v70, (uint64_t)&v71);
              goto LABEL_56;
            }
            v46 = _directoryStoreGetPageInner(v9 + 8, v45, &v87);
            if (v87)
            {
              v48 = directoryStorePageFindItemOffset(*(_DWORD **)(v9 + 224), (uint64_t)v46, v36, &v79, 0, v47);
              if (!v48)
              {
                v49 = 0;
                goto LABEL_51;
              }
              if (*v48 == v36)
              {
                v49 = 1;
LABEL_51:
                if ((v44 & 1) == 0)
                {
                  v52 = _directoryStoreGetPageInner(v15, *((unint64_t *)&v80 + 1), &v87);
                  *(_QWORD *)&v80 = &v52[16 * v81 + 8];
                }
                v70 = 0;
                if (v49)
                  goto LABEL_56;
                v50 = v79;
                goto LABEL_55;
              }
            }
            else
            {
              v78 = 0;
              v76 = 0u;
              v77 = 0u;
              v74 = 0u;
              v75 = 0u;
              v72 = 0u;
              v73 = 0u;
              v71 = 0u;
              v51 = directoryStoreTreeFindItemOffset(v9 + 8, *(_QWORD *)(v80 + 8), v36, (uint64_t)&v71, &v79, 0, 0);
              if (!v51 || *v51 == v36)
              {
                v49 = v51 != 0;
                goto LABEL_51;
              }
            }
            v57 = __si_assert_copy_extra(0);
            __message_assert("%s:%u: failed assertion '%s' %s %lld != %lld");
LABEL_64:
            free(v57);
            if (__valid_fs(-1))
              v58 = 2989;
            else
              v58 = 3072;
            *(_DWORD *)v58 = -559038737;
            abort();
          }
          v37 = (unsigned __int16 *)_directoryStoreGetPageInner(v9 + 8, v28, v69);
          *(_DWORD *)buf = 0;
          v39 = directoryStorePageFindItemOffset(*(_DWORD **)(v9 + 224), (uint64_t)v37, *a3, (unsigned int *)buf, 0, v38);
          if (v39)
          {
            v30 = *v39;
            v40 = v39[1];
            *(_OWORD *)v39 = xmmword_1B8631BC0;
            *v37 -= 16;
            v41 = *(unsigned int *)buf;
            directoryStorePageGetSize(v37, (int8x8_t)1);
            shiftEntriesForDelete((uint64_t)v37, v41, v42, 0);
            dirtyStoragePage(v9 + 8, (unint64_t)v37);
            v27 = v40;
LABEL_33:
            v36 = v30;
            goto LABEL_35;
          }
        }
        v27 = 0;
        v36 = 0;
        goto LABEL_35;
      }
    }
    v14 = *v10;
    v13 = 0;
    goto LABEL_13;
  }
  return result;
}

void freeForwardDirectoryStore(_QWORD *a1)
{
  const void *v2;

  storageClose((uint64_t)(a1 + 1));
  v2 = (const void *)a1[549];
  if (v2)
    CFRelease(v2);
  free(a1);
}

BOOL dirStoreInit(uint64_t a1, _DWORD *a2, int a3, char a4, void *aBlock)
{
  uint64_t v9;
  const __CFAllocator *v10;
  __CFBitVector *v11;
  int32_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  int v18;
  NSObject *v19;
  const char *v20;
  uint32_t v21;
  uint8_t *v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  _BYTE *v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  const __CFAllocator *v32;
  __CFBitVector *Mutable;
  char *v34;
  char *v35;
  const char *v36;
  uint64_t v37;
  unint64_t v38;
  int v39;
  unsigned int v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  void (*v44)(_QWORD);
  int v45;
  NSObject *v46;
  unint64_t v47;
  char *v48;
  uint64_t v49;
  unsigned int v50;
  uint64_t v51;
  void (*v52)(_QWORD);
  _BYTE *v54;
  char *v55;
  char *v56;
  const char *v57;
  uint64_t v58;
  char *v59;
  const char *v60;
  char *v61;
  const char *v62;
  uint8_t *v63;
  int v64;
  unsigned int v65;
  unsigned int v66;
  unsigned int v67;
  unsigned int v68;
  unsigned int v69;
  BOOL v70;
  uint8_t v71[4];
  const char *v72;
  __int16 v73;
  int v74;
  __int16 v75;
  _BYTE *v76;
  __int16 v77;
  uint64_t v78;
  _DWORD v79[256];
  uint8_t buf[32];
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  uint64_t v91;

  v91 = *MEMORY[0x1E0C80C00];
  v9 = a1 + 8;
  v70 = 0;
  if (!a3)
  {
    bzero(buf, 0x400uLL);
    v15 = fd_pread(a2, buf, 0x400uLL, 64);
    if (v15 == 1024)
    {
      v63 = &buf[8];
      v70 = storageHeaderRestore(v9, (char **)&v63);
      v16 = v70;
      if (v70)
        v16 = storageInit(v9, 0x10000, 0x40uLL, (uint64_t)a2, 0, 1, a4, 102, aBlock);
      v70 = v16;
      if (v16)
      {
        v22 = v63;
        v23 = 0;
        v24 = 0;
        do
        {
          v25 = v24;
          v26 = ((unint64_t)(*v22 & 0x7F) << v24) | v23;
          v27 = v22 + 1;
          if ((*v22 & 0x80) == 0)
            break;
          v24 += 7;
          ++v22;
          v23 = v26;
        }
        while (v25 != 63);
        *(_QWORD *)(a1 + 4424) = v26;
        v28 = 0;
        v29 = 0;
        do
        {
          v30 = v29;
          v31 = ((unint64_t)(*v27 & 0x7F) << v29) | v28;
          if ((*v27 & 0x80) == 0)
            break;
          ++v27;
          v29 += 7;
          v28 = v31;
        }
        while (v30 != 63);
        *(_QWORD *)(a1 + 4416) = v31;
        v32 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        *(_OWORD *)(a1 + 4376) = xmmword_1B8631C20;
        Mutable = CFBitVectorCreateMutable(v32, 0x2000);
        *(_QWORD *)(a1 + 4392) = Mutable;
        CFBitVectorSetCount(Mutable, 0x2000);
        if (*(_QWORD *)(a1 + 4392))
          goto LABEL_43;
        goto LABEL_20;
      }
      bzero(v79, 0x400uLL);
      v18 = *__error();
      v19 = _SILogForLogForCategory(6);
      if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
LABEL_26:
        *__error() = v18;
        goto LABEL_43;
      }
      v54 = fd_realpath(a2, v79);
      *(_DWORD *)v71 = 136315650;
      v72 = "dirStoreInit";
      v73 = 1024;
      v74 = 2369;
      v75 = 2080;
      v76 = v54;
      v20 = "%s:%d: init storage failed %s";
      v21 = 28;
    }
    else
    {
      v17 = v15;
      bzero(v79, 0x400uLL);
      v18 = *__error();
      v19 = _SILogForLogForCategory(6);
      if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        goto LABEL_26;
      *(_DWORD *)v71 = 136315906;
      v72 = "dirStoreInit";
      v73 = 1024;
      v74 = 2378;
      v75 = 2080;
      v76 = fd_realpath(a2, v79);
      v77 = 2048;
      v78 = v17;
      v20 = "%s:%d: init storage failed %s; could not read header got %ld bytes";
      v21 = 38;
    }
    _os_log_error_impl(&dword_1B8270000, v19, OS_LOG_TYPE_ERROR, v20, v71, v21);
    goto LABEL_26;
  }
  v70 = storageInit(a1 + 8, 0x10000, 0x40uLL, (uint64_t)a2, 1, 1, a4, 102, aBlock);
  v10 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  *(_OWORD *)(a1 + 4376) = xmmword_1B8631C20;
  v11 = CFBitVectorCreateMutable(v10, 0x2000);
  *(_QWORD *)(a1 + 4392) = v11;
  CFBitVectorSetCount(v11, 0x2000);
  if (!*(_QWORD *)(a1 + 4392))
  {
LABEL_20:
    v34 = __si_assert_copy_extra(0);
    v35 = v34;
    v36 = "";
    if (v34)
      v36 = v34;
    __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 47, "bv->_cfbv", v36);
    goto LABEL_23;
  }
  if (!v70)
    goto LABEL_43;
  v70 = 0;
  if (!storageResolvePtr(v9, 0, 1uLL, 1))
    goto LABEL_43;
  v12 = OSAtomicIncrement32((int32_t *)exceptionSequenceNum);
  v13 = *(_QWORD *)(a1 + 224);
  if (v13)
    v14 = *(_DWORD *)(v13 + 44);
  else
    v14 = -1;
  v38 = setThreadIdAndInfo(v14, sStorageExceptionCallbacks, v9, 1, v12);
  *(_DWORD *)v71 = HIDWORD(v38);
  v79[0] = v38;
  LODWORD(v63) = v39;
  v69 = v40;
  v41 = *(_QWORD *)&threadData[18 * v38 + 2];
  v42 = v41 + 320 * HIDWORD(v38);
  v43 = *(_DWORD *)(v42 + 312);
  v44 = *(void (**)(_QWORD))(v42 + 224);
  if (v44)
    v44(*(_QWORD *)(v41 + 320 * HIDWORD(v38) + 288));
  v68 = v79[0];
  v67 = *(_DWORD *)v71;
  v66 = v63;
  v65 = v69;
  if (_setjmp((int *)v42))
  {
    v45 = *__error();
    v46 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "dirStoreInit";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 2356;
      _os_log_error_impl(&dword_1B8270000, v46, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
    }
    *__error() = v45;
    *(_DWORD *)(v42 + 312) = v43;
    CIOnThreadCleanUpReset(v65);
    dropThreadId(v68, 1, v12);
    CICleanUpReset(v68, v66);
    goto LABEL_43;
  }
  v89 = 0u;
  v90 = 0u;
  v87 = 0u;
  v88 = 0u;
  v85 = 0u;
  v86 = 0u;
  v83 = 0u;
  v84 = 0u;
  v81 = 0u;
  v82 = 0u;
  memset(buf, 0, sizeof(buf));
  v64 = 0;
  v47 = storageAllocOffset(v9, 0x400u, (uint64_t)buf, &v64);
  if (v64)
    dirtyStorageOffsets(v9, (unint64_t *)buf, v64);
  if (v70)
  {
    v59 = __si_assert_copy_extra(0);
    v35 = v59;
    v60 = "";
    if (v59)
      v60 = v59;
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 2341, "!result", v60);
    goto LABEL_23;
  }
  if (v47)
  {
    if (v47 == 64)
    {
      v48 = storageResolvePtr(v9, 0x40uLL, 0x400uLL, 1);
      bzero(v48, 0x400uLL);
      v48[2] = 4;
      dirtyStoragePage(v9, (unint64_t)v48);
      *((_DWORD *)v48 + 1) = 0;
      goto LABEL_40;
    }
    v61 = __si_assert_copy_extra(0);
    v35 = v61;
    v62 = "";
    if (v61)
      v62 = v61;
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 2343, "realOffset==(64)", v62);
LABEL_23:
    free(v35);
    if (__valid_fs(-1))
      v37 = 2989;
    else
      v37 = 3072;
    *(_DWORD *)v37 = -559038737;
    abort();
  }
LABEL_40:
  v70 = 1;
  v49 = *(_QWORD *)&threadData[18 * v68 + 2];
  v50 = v67;
  v51 = v49 + 320 * v67;
  *(_DWORD *)(v51 + 312) = v43;
  v52 = *(void (**)(_QWORD))(v51 + 232);
  if (v52)
    v52(*(_QWORD *)(v49 + 320 * v50 + 288));
  dropThreadId(v68, 0, v12);
LABEL_43:
  *(_DWORD *)(a1 + 4400) = 1;
  if (v70 && !*(_QWORD *)(a1 + 224))
  {
    v55 = __si_assert_copy_extra(0);
    v56 = v55;
    v57 = "";
    if (v55)
      v57 = v55;
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 2383, "storageFdPtr(&dirStore->store)!=0", v57);
    free(v56);
    if (__valid_fs(-1))
      v58 = 2989;
    else
      v58 = 3072;
    *(_DWORD *)v58 = -559038737;
    abort();
  }
  return v70;
}

_BYTE *flushForwardStore(_BYTE *result, uint64_t a2)
{
  _QWORD *v3;
  int v4;
  int32_t v5;
  uint64_t v6;
  int v7;
  unint64_t v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  void (*v14)(_QWORD);
  int v15;
  NSObject *v16;
  char *v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  uint64x2_t v23;
  int32x2_t v24;
  uint64x2_t v25;
  int32x2_t v26;
  char v27;
  uint64x2_t v28;
  int16x8_t v29;
  uint64x2_t v30;
  int16x8_t v31;
  unint64_t v32;
  unint64_t v33;
  _BYTE *v34;
  uint64x2_t v35;
  int32x2_t v36;
  unint64_t v37;
  uint64x2_t v38;
  int32x2_t v39;
  char v40;
  uint64x2_t v41;
  int16x8_t v42;
  unint64_t v43;
  uint64x2_t v44;
  int16x8_t v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t v48;
  void (*v49)(_QWORD);
  unsigned int v50;
  unsigned int v51;
  unsigned int v52;
  unsigned int v53;
  _BYTE buf[12];
  __int16 v55;
  int v56;
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  if (*result)
  {
    v3 = result;
    v4 = setCrashStateTarget(3);
    if (!storageResolvePtr((uint64_t)(v3 + 1), 0, 1uLL, 1))
      return (_BYTE *)setCrashStateTarget(v4);
    v5 = OSAtomicIncrement32((int32_t *)exceptionSequenceNum);
    v6 = v3[28];
    if (v6)
      v7 = *(_DWORD *)(v6 + 44);
    else
      v7 = -1;
    v8 = setThreadIdAndInfo(v7, sStorageExceptionCallbacks, (uint64_t)(v3 + 1), 1, v5);
    v52 = HIDWORD(v8);
    v53 = v8;
    v50 = v10;
    v51 = v9;
    v11 = *(_QWORD *)&threadData[18 * v8 + 2];
    v12 = v11 + 320 * HIDWORD(v8);
    v13 = *(_DWORD *)(v12 + 312);
    v14 = *(void (**)(_QWORD))(v12 + 224);
    if (v14)
      v14(*(_QWORD *)(v11 + 320 * HIDWORD(v8) + 288));
    if (_setjmp((int *)v12))
    {
      v15 = *__error();
      v16 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)&buf[4] = "flushForwardStore";
        v55 = 1024;
        v56 = 2553;
        _os_log_error_impl(&dword_1B8270000, v16, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
      }
      *__error() = v15;
      *(_DWORD *)(v12 + 312) = v13;
      CIOnThreadCleanUpReset(v50);
      dropThreadId(v53, 1, v5);
      CICleanUpReset(v53, v51);
      return (_BYTE *)setCrashStateTarget(v4);
    }
    *(_QWORD *)storageResolvePtr((uint64_t)(v3 + 1), 0, 8uLL, 1) = a2;
    v17 = storageResolvePtr((uint64_t)(v3 + 1), 0x40uLL, 0x400uLL, 1);
    *(_QWORD *)buf = v17 + 8;
    storageHeaderStore((uint64_t)(v3 + 1), (uint64_t *)buf);
    v18 = *(_QWORD *)buf;
    v19 = *(_QWORD *)buf;
    v20 = v3[553];
    LOBYTE(v21) = v20;
    if (HIDWORD(v20))
    {
      if ((v20 & 0x8000000000000000) != 0)
      {
        v25 = (uint64x2_t)vdupq_n_s64(v20);
        v26.i32[0] = v3[553];
        v26.i32[1] = v20 >> 7;
        **(_QWORD **)buf = vorr_s8(vmovn_s16(vuzp1q_s16((int16x8_t)vmovn_hight_s64(v26, (int64x2_t)vshlq_u64(v25, (uint64x2_t)xmmword_1B8631B60)), (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v25, (uint64x2_t)xmmword_1B8631B70), (int32x4_t)vshlq_u64(v25, (uint64x2_t)xmmword_1B8631B80)))), (int8x8_t)0x8080808080808080);
        *(_BYTE *)(v19 + 8) = HIBYTE(v20) | 0x80;
        LOBYTE(v21) = 1;
        v22 = 9;
      }
      else if ((v20 & 0x7F00000000000000) != 0)
      {
        v23 = (uint64x2_t)vdupq_n_s64(v20);
        v24.i32[0] = v3[553];
        v24.i32[1] = v20 >> 7;
        **(_QWORD **)buf = vorr_s8(vmovn_s16(vuzp1q_s16((int16x8_t)vmovn_hight_s64(v24, (int64x2_t)vshlq_u64(v23, (uint64x2_t)xmmword_1B8631B60)), (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v23, (uint64x2_t)xmmword_1B8631B70), (int32x4_t)vshlq_u64(v23, (uint64x2_t)xmmword_1B8631B80)))), (int8x8_t)0x8080808080808080);
        v21 = (v20 & 0x7F00000000000000) >> 56;
        v22 = 8;
      }
      else
      {
        v27 = v20 | 0x80;
        if ((v20 & 0xFE000000000000) != 0)
        {
          **(_BYTE **)buf = v27;
          v28 = (uint64x2_t)vdupq_n_s64(v20);
          v29 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v28, (uint64x2_t)xmmword_1B8631BA0), (int32x4_t)vshlq_u64(v28, (uint64x2_t)xmmword_1B8631B90));
          v29.i64[0] = *(_QWORD *)&vmovn_s32((int32x4_t)v29) | 0x80008000800080;
          *(_DWORD *)(v19 + 1) = vmovn_s16(v29).u32[0];
          *(_BYTE *)(v19 + 5) = (v20 >> 35) | 0x80;
          *(_BYTE *)(v19 + 6) = (v20 >> 42) | 0x80;
          v21 = (v20 & 0xFE000000000000) >> 49;
          v22 = 7;
        }
        else
        {
          **(_BYTE **)buf = v27;
          v30 = (uint64x2_t)vdupq_n_s64(v20);
          v31 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v30, (uint64x2_t)xmmword_1B8631BA0), (int32x4_t)vshlq_u64(v30, (uint64x2_t)xmmword_1B8631B90));
          v31.i64[0] = *(_QWORD *)&vmovn_s32((int32x4_t)v31) | 0x80008000800080;
          *(_DWORD *)(v19 + 1) = vmovn_s16(v31).u32[0];
          if ((v20 & 0x1FC0000000000) != 0)
          {
            *(_BYTE *)(v19 + 5) = (v20 >> 35) | 0x80;
            v21 = (v20 & 0x1FC0000000000) >> 42;
            v22 = 6;
          }
          else
          {
            v21 = (v20 >> 35) & 0x7F;
            v22 = 5;
          }
        }
      }
    }
    else if ((v20 & 0x7F0000000) != 0)
    {
      **(_BYTE **)buf = v20 | 0x80;
      *(_BYTE *)(v19 + 1) = (v20 >> 7) | 0x80;
      *(_BYTE *)(v19 + 2) = (v20 >> 14) | 0x80;
      *(_BYTE *)(v19 + 3) = (v20 >> 21) | 0x80;
      v21 = (v20 & 0x7F0000000) >> 28;
      v22 = 4;
    }
    else if ((v20 & 0xFE00000) != 0)
    {
      **(_BYTE **)buf = v20 | 0x80;
      *(_BYTE *)(v19 + 1) = (v20 >> 7) | 0x80;
      *(_BYTE *)(v19 + 2) = (v20 >> 14) | 0x80;
      v21 = (v20 & 0xFE00000) >> 21;
      v22 = 3;
    }
    else if ((v20 & 0x1FC000) != 0)
    {
      **(_BYTE **)buf = v20 | 0x80;
      *(_BYTE *)(v19 + 1) = (v20 >> 7) | 0x80;
      v21 = (v20 & 0x1FC000) >> 14;
      v22 = 2;
    }
    else
    {
      v22 = v20 & 0x3F80;
      if (v22)
      {
        **(_BYTE **)buf = v21 | 0x80;
        v21 = v22 >> 7;
        v22 = 1;
      }
    }
    *(_BYTE *)(v19 + v22) = v21;
    v32 = v22 + 1;
    v33 = v3[552];
    if (HIDWORD(v33))
    {
      if ((v33 & 0x8000000000000000) != 0)
      {
        v38 = (uint64x2_t)vdupq_n_s64(v33);
        v39.i32[0] = v3[552];
        v39.i32[1] = v33 >> 7;
        *(int8x8_t *)(v19 + v32) = vorr_s8(vmovn_s16(vuzp1q_s16((int16x8_t)vmovn_hight_s64(v39, (int64x2_t)vshlq_u64(v38, (uint64x2_t)xmmword_1B8631B60)), (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v38, (uint64x2_t)xmmword_1B8631B70), (int32x4_t)vshlq_u64(v38, (uint64x2_t)xmmword_1B8631B80)))), (int8x8_t)0x8080808080808080);
        v32 = v22 + 10;
        *(_BYTE *)(v22 + v18 + 9) = HIBYTE(v33) | 0x80;
        LOBYTE(v18) = 1;
        goto LABEL_49;
      }
      if ((v33 & 0x7F00000000000000) != 0)
      {
        v35 = (uint64x2_t)vdupq_n_s64(v33);
        v36.i32[0] = v3[552];
        v36.i32[1] = v33 >> 7;
        *(int8x8_t *)(v19 + v32) = vorr_s8(vmovn_s16(vuzp1q_s16((int16x8_t)vmovn_hight_s64(v36, (int64x2_t)vshlq_u64(v35, (uint64x2_t)xmmword_1B8631B60)), (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v35, (uint64x2_t)xmmword_1B8631B70), (int32x4_t)vshlq_u64(v35, (uint64x2_t)xmmword_1B8631B80)))), (int8x8_t)0x8080808080808080);
        v32 = v22 + 9;
        v18 = (v33 & 0x7F00000000000000) >> 56;
        goto LABEL_49;
      }
      v40 = v33 | 0x80;
      if ((v33 & 0xFE000000000000) != 0)
      {
        *(_BYTE *)(v19 + v32) = v40;
        v41 = (uint64x2_t)vdupq_n_s64(v33);
        v42 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v41, (uint64x2_t)xmmword_1B8631BA0), (int32x4_t)vshlq_u64(v41, (uint64x2_t)xmmword_1B8631B90));
        v42.i64[0] = *(_QWORD *)&vmovn_s32((int32x4_t)v42) | 0x80008000800080;
        v43 = v22 + v18;
        *(_DWORD *)(v43 + 2) = vmovn_s16(v42).u32[0];
        *(_BYTE *)(v43 + 6) = (v33 >> 35) | 0x80;
        v32 = v22 + 8;
        *(_BYTE *)(v43 + 7) = (v33 >> 42) | 0x80;
        v18 = (v33 & 0xFE000000000000) >> 49;
        goto LABEL_49;
      }
      *(_BYTE *)(v19 + v32) = v40;
      v44 = (uint64x2_t)vdupq_n_s64(v33);
      v32 = v22 + 6;
      v45 = (int16x8_t)vuzp1q_s32((int32x4_t)vshlq_u64(v44, (uint64x2_t)xmmword_1B8631BA0), (int32x4_t)vshlq_u64(v44, (uint64x2_t)xmmword_1B8631B90));
      v45.i64[0] = *(_QWORD *)&vmovn_s32((int32x4_t)v45) | 0x80008000800080;
      *(_DWORD *)(v22 + v18 + 2) = vmovn_s16(v45).u32[0];
      if ((v33 & 0x1FC0000000000) == 0)
      {
        v18 = (v33 >> 35) & 0x7F;
        goto LABEL_49;
      }
      v46 = v22 + 7;
      *(_BYTE *)(v19 + v32) = (v33 >> 35) | 0x80;
      v18 = (v33 & 0x1FC0000000000) >> 42;
    }
    else
    {
      if ((v33 & 0x7F0000000) != 0)
      {
        *(_BYTE *)(v19 + v32) = v33 | 0x80;
        v34 = (_BYTE *)(v22 + v18);
        v34[2] = (v33 >> 7) | 0x80;
        v34[3] = (v33 >> 14) | 0x80;
        v32 = v22 + 5;
        v34[4] = (v33 >> 21) | 0x80;
        v18 = (v33 & 0x7F0000000) >> 28;
LABEL_49:
        *(_BYTE *)(v19 + v32) = v18;
        dirtyStoragePage((uint64_t)(v3 + 1), (unint64_t)v17);
        storageSyncPages((uint64_t)(v3 + 1), (uint64_t)(v3 + 547), 0x20000uLL);
        v47 = *(_QWORD *)&threadData[18 * v53 + 2];
        v48 = v47 + 320 * v52;
        *(_DWORD *)(v48 + 312) = v13;
        v49 = *(void (**)(_QWORD))(v48 + 232);
        if (v49)
          v49(*(_QWORD *)(v47 + 320 * v52 + 288));
        dropThreadId(v53, 0, v5);
        return (_BYTE *)setCrashStateTarget(v4);
      }
      if ((v33 & 0xFE00000) != 0)
      {
        *(_BYTE *)(v19 + v32) = v33 | 0x80;
        v37 = v22 + v18;
        *(_BYTE *)(v37 + 2) = (v33 >> 7) | 0x80;
        v32 = v22 + 4;
        *(_BYTE *)(v37 + 3) = (v33 >> 14) | 0x80;
        v18 = (v33 & 0xFE00000) >> 21;
        goto LABEL_49;
      }
      if ((v33 & 0x1FC000) != 0)
      {
        *(_BYTE *)(v19 + v32) = v33 | 0x80;
        v32 = v22 + 3;
        *(_BYTE *)(v22 + v18 + 2) = (v33 >> 7) | 0x80;
        v18 = (v33 & 0x1FC000) >> 14;
        goto LABEL_49;
      }
      if ((v33 & 0x3F80) == 0)
      {
        v18 = v3[552];
        goto LABEL_49;
      }
      v46 = v22 + 2;
      *(_BYTE *)(v19 + v32) = v3[552] | 0x80;
      v18 = (v33 & 0x3F80) >> 7;
    }
    v32 = v46;
    goto LABEL_49;
  }
  return result;
}

void bit_vector_init(uint64_t a1)
{
  const __CFAllocator *v2;
  __CFBitVector *Mutable;
  char *v4;
  char *v5;
  const char *v6;
  char *v7;
  const char *v8;
  uint64_t v9;

  if (!a1)
  {
    v4 = __si_assert_copy_extra(0);
    v5 = v4;
    v6 = "";
    if (v4)
      v6 = v4;
    __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 41, "bv", v6);
LABEL_10:
    free(v5);
    if (__valid_fs(-1))
      v9 = 2989;
    else
      v9 = 3072;
    *(_DWORD *)v9 = -559038737;
    abort();
  }
  v2 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  *(_OWORD *)a1 = xmmword_1B8631C20;
  Mutable = CFBitVectorCreateMutable(v2, 0x2000);
  *(_QWORD *)(a1 + 16) = Mutable;
  CFBitVectorSetCount(Mutable, 0x2000);
  if (!*(_QWORD *)(a1 + 16))
  {
    v7 = __si_assert_copy_extra(0);
    v5 = v7;
    v8 = "";
    if (v7)
      v8 = v7;
    __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 47, "bv->_cfbv", v8);
    goto LABEL_10;
  }
}

_OWORD *createForwardStore(int a1, const char *a2, void *a3)
{
  _OWORD *v6;
  _QWORD *v7;
  int v8;
  NSObject *v9;
  os_log_type_t v10;
  uint8_t buf[4];
  char *v13;
  char v14[1024];
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v6 = malloc_type_calloc(1uLL, 0x1160uLL, 0x10A0040E5DFC7CEuLL);
  bzero(v14, 0x400uLL);
  __sprintf_chk(v14, 0, 0x400uLL, "%s%s", a2, "directoryStoreFile");
  v7 = fd_create_protected(a1, v14, 1538, 3u);
  if (dirStoreInit((uint64_t)v6, v7, 1, 0, a3))
  {
    v8 = *__error();
    v9 = _SILogForLogForCategory(0);
    v10 = 2 * (gSILogLevels[0] < 4);
    if (os_log_type_enabled(v9, v10))
    {
      *(_DWORD *)buf = 136315138;
      v13 = v14;
      _os_log_impl(&dword_1B8270000, v9, v10, "createForwardStore:%s", buf, 0xCu);
    }
    *__error() = v8;
    v6[276] = xmmword_1B8631D00;
    flushForwardStore(v6, 0);
    *(_BYTE *)v6 = 1;
  }
  else
  {
    freeForwardDirectoryStore(v6);
    return 0;
  }
  return v6;
}

uint64_t recoverForwardStore(uint64_t a1, const char *a2, _DWORD *a3)
{
  int v6;
  NSObject *v7;
  os_log_type_t v8;
  uint8_t buf[4];
  char *v11;
  char v12[1024];
  char v13[1024];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  bzero(v13, 0x400uLL);
  __sprintf_chk(v13, 0, 0x400uLL, "%s%s", a2, "directoryStoreFile");
  bzero(v12, 0x400uLL);
  __sprintf_chk(v12, 0, 0x400uLL, "%s%s", a2, "directoryStoreFile.shadow");
  v6 = *__error();
  v7 = _SILogForLogForCategory(0);
  v8 = 2 * (gSILogLevels[0] < 4);
  if (os_log_type_enabled(v7, v8))
  {
    *(_DWORD *)buf = 136315138;
    v11 = v13;
    _os_log_impl(&dword_1B8270000, v7, v8, "recoverForwardStore:%s", buf, 0xCu);
  }
  *__error() = v6;
  return copyFileFallback(a1, v12, a1, v13, a3, 1, 1);
}

_QWORD *openForwardStore(int a1, const char *a2, int a3, int a4, int a5, void *a6)
{
  const char *v11;
  int v12;
  char v13;
  int v14;
  NSObject *v15;
  os_log_type_t v16;
  int v17;
  _QWORD *v18;
  _QWORD *v19;
  uint64_t v20;
  int32_t v21;
  uint64_t v22;
  int v23;
  int v24;
  NSObject *v25;
  unint64_t v27;
  unsigned int v28;
  unsigned int v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  void (*v33)(_QWORD);
  int v34;
  NSObject *v35;
  int i;
  uint64_t v37;
  unsigned int v38;
  uint64_t v39;
  void (*v40)(_QWORD);
  uint64_t v41;
  uint64_t v42;
  uint64_t j;
  void *v44;
  uint64_t v45;
  uint64_t v46;
  _QWORD *v47;
  uint64_t v48;
  size_t v49;
  _QWORD *v50;
  _QWORD *v51;
  uint64_t *v52;
  unint64_t v53;
  unint64_t v54;
  _QWORD *v55;
  _QWORD *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  _QWORD *v60;
  _QWORD *v61;
  uint64_t v62;
  unint64_t v63;
  _QWORD *v64;
  uint64_t v65;
  __int128 v66;
  uint64_t v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  int8x16_t v74;
  int8x16_t v75;
  unint64_t v76;
  unint64_t v77;
  int32x2_t v78;
  int64x2_t v79;
  int8x16_t v80;
  uint64_t v89;
  char *PageInner;
  int8x8_t v91;
  char *v92;
  unint64_t v93;
  unint64_t v94;
  _QWORD *v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  _QWORD *v99;
  uint64_t v100;
  uint64_t v101;
  int v102;
  uint64_t v103;
  uint64_t v104;
  _QWORD *v105;
  uint64_t v106;
  uint64_t v107;
  int v108;
  _QWORD *v109;
  uint64_t v110;
  uint64_t v111;
  unsigned int v112;
  uint64_t v113;
  _QWORD *v114;
  uint64_t v115;
  uint64_t *v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  _QWORD *v120;
  uint64_t v121;
  _QWORD *v122;
  unint64_t v123;
  _QWORD *v124;
  _QWORD *v125;
  uint64_t *v126;
  unint64_t v127;
  uint64_t v128;
  _QWORD *v129;
  unint64_t Size;
  unint64_t v131;
  uint64_t v132;
  int v133;
  uint64_t v134;
  uint64_t v135;
  _QWORD *v136;
  int v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  _QWORD *v144;
  uint64_t v145;
  _QWORD *v146;
  _QWORD *v147;
  _QWORD *v148;
  unint64_t v149;
  char v150;
  _QWORD *v151;
  NSObject *v152;
  int v153;
  uint64_t v154;
  uint64_t *v155;
  uint64_t v156;
  uint64_t v157;
  char v158;
  uint64_t v159;
  NSObject *v160;
  unsigned int v161;
  _QWORD *v162;
  unint64_t v163;
  unint64_t v164;
  _QWORD *v165;
  unsigned int v167;
  unsigned int v168;
  unsigned int v169;
  char v170;
  size_t v171;
  char v172[1024];
  uint8_t buf[32];
  int v174[6];
  uint64_t v175;

  v175 = *MEMORY[0x1E0C80C00];
  v165 = malloc_type_calloc(1uLL, 0x1160uLL, 0x10A0040E5DFC7CEuLL);
  bzero(v172, 0x400uLL);
  v11 = "directoryStoreFile";
  if (a5)
    v11 = "directoryStoreFile.shadow";
  v12 = a5 | a4;
  v13 = a5 | a4;
  __sprintf_chk(v172, 0, 0x400uLL, "%s%s", a2, v11);
  v14 = *__error();
  v15 = _SILogForLogForCategory(0);
  v16 = 2 * (gSILogLevels[0] < 4);
  if (os_log_type_enabled(v15, v16))
  {
    *(_DWORD *)buf = 136315138;
    *(_QWORD *)&buf[4] = v172;
    _os_log_impl(&dword_1B8270000, v15, v16, "openForwardStore:%s", buf, 0xCu);
  }
  *__error() = v14;
  if (v12)
    v17 = 0;
  else
    v17 = 2;
  v18 = fd_create_protected(a1, v172, v17, 3u);
  v19 = v165;
  if (!dirStoreInit((uint64_t)v165, v18, 0, v13, a6))
  {
    v24 = *__error();
    v25 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "openForwardStore";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 2484;
      goto LABEL_44;
    }
LABEL_14:
    *__error() = v24;
    freeForwardDirectoryStore(v19);
    return 0;
  }
  if ((v13 & 1) == 0)
  {
    v20 = (uint64_t)(v165 + 1);
    v170 = 0;
    if (storageResolvePtr((uint64_t)(v165 + 1), 0, 1uLL, 1))
    {
      v21 = OSAtomicIncrement32((int32_t *)exceptionSequenceNum);
      v174[0] = 0;
      LODWORD(v171) = 0;
      v22 = v165[28];
      if (v22)
        v23 = *(_DWORD *)(v22 + 44);
      else
        v23 = -1;
      v27 = setThreadIdAndInfo(v23, sStorageExceptionCallbacks, v20, 1, v21);
      LODWORD(v171) = HIDWORD(v27);
      v174[0] = v27;
      v168 = v29;
      v169 = v28;
      v30 = *(_QWORD *)&threadData[18 * v27 + 2];
      v31 = v30 + 320 * HIDWORD(v27);
      v32 = *(_DWORD *)(v31 + 312);
      v33 = *(void (**)(_QWORD))(v31 + 224);
      if (v33)
        v33(*(_QWORD *)(v30 + 320 * HIDWORD(v27) + 288));
      v167 = v174[0];
      if (_setjmp((int *)v31))
      {
        v34 = *__error();
        v35 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315394;
          *(_QWORD *)&buf[4] = "openForwardStore";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 2506;
          _os_log_error_impl(&dword_1B8270000, v35, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
        }
        *__error() = v34;
        *(_DWORD *)(v31 + 312) = v32;
        CIOnThreadCleanUpReset(v168);
        dropThreadId(v167, 1, v21);
        CICleanUpReset(v167, v169);
      }
      else
      {
        for (i = 0; i != 24; ++i)
          freeListVerify(v20, i);
        v170 = 1;
        v37 = *(_QWORD *)&threadData[18 * v167 + 2];
        v38 = v171;
        v39 = v37 + 320 * v171;
        *(_DWORD *)(v39 + 312) = v32;
        v40 = *(void (**)(_QWORD))(v39 + 232);
        if (v40)
          v40(*(_QWORD *)(v37 + 320 * v38 + 288));
        dropThreadId(v167, 0, v21);
      }
    }
    if (!v170)
    {
      v24 = *__error();
      v25 = _SILogForLogForCategory(10);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)&buf[4] = "openForwardStore";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 2512;
LABEL_44:
        _os_log_error_impl(&dword_1B8270000, v25, OS_LOG_TYPE_ERROR, "%s:%d: Failed to open dir store", buf, 0x12u);
        goto LABEL_14;
      }
      goto LABEL_14;
    }
  }
  v165[552] = 2;
  if (!a3)
    return v165;
  v41 = v165[553];
  v42 = v41;
  for (j = 2; j != 26; ++j)
  {
    if (!freeListVerify((uint64_t)(v165 + 1), (int)j - 2))
      v165[j] = 0;
  }
  if (!*((_DWORD *)v165 + 1100) || v41 <= 0)
    return v165;
  if ((v41 & 0x3FFFFFFFFFFFFFFFuLL) >= v165[30])
    goto LABEL_165;
  v44 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 0x300uLL, 0x6085D6BuLL);
  if (!v44)
    _log_fault_for_malloc_failure();
  memset(buf, 0, 24);
  pqinit_offset_ptr((uint64_t)buf);
  v45 = v41 & 0x3F;
  v46 = *(_QWORD *)&buf[16];
  if (*(_QWORD *)&buf[16] + 2 >= *(uint64_t *)&buf[8])
  {
    v48 = 4;
    if (*(uint64_t *)&buf[8] >= 4)
      v48 = 2 * *(_QWORD *)&buf[8];
    *(_QWORD *)&buf[8] = v48;
    v49 = 16 * v48 + 32;
    if (*(_QWORD *)buf)
      v50 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, *(void **)buf, v49, 0xECA6AA46uLL);
    else
      v50 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v49, 0x8DDAA030uLL);
    v51 = v50;
    if (!v50)
      _log_fault_for_malloc_failure();
    *(_QWORD *)buf = v51;
    *v51 = 0;
    v51[1] = 0;
    v47 = v51;
  }
  else
  {
    v47 = *(_QWORD **)buf;
  }
  *(_QWORD *)&buf[16] = v46 + 1;
  v52 = &v47[2 * v46];
  *v52 = v42;
  v52[1] = 0;
  if (v46 >= 2)
  {
    v53 = v46;
    do
    {
      v54 = v53;
      v55 = &v47[2 * v53];
      v56 = &v47[2 * (v54 >> 1)];
      if ((*v55 & 0x3FFFFFFFFFFFFFFFuLL) > (*v56 & 0x3FFFFFFFFFFFFFFFuLL))
        break;
      *(_OWORD *)v174 = *(_OWORD *)v55;
      *(_OWORD *)v55 = *(_OWORD *)v56;
      *(_OWORD *)v56 = *(_OWORD *)v174;
      v53 = v54 >> 1;
    }
    while (v54 > 3);
  }
  if (v45)
  {
    free(*(void **)buf);
    free(v44);
LABEL_165:
    v24 = *__error();
    v160 = _SILogForLogForCategory(10);
    if (os_log_type_enabled(v160, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "openForwardStore";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 2527;
      _os_log_error_impl(&dword_1B8270000, v160, OS_LOG_TYPE_ERROR, "%s:%d: Failed to open dir store", buf, 0x12u);
    }
    v19 = v165;
    goto LABEL_14;
  }
  v57 = *(_QWORD *)&buf[16];
  v58 = 32;
  v59 = 0;
  v60 = v44;
  do
  {
    v61 = v60;
    v62 = v57 - 1;
    if (v57 == 1)
    {
      v63 = 0;
      v57 = 1;
      v64 = v165;
      goto LABEL_76;
    }
    v65 = *(_QWORD *)buf;
    v63 = *(_QWORD *)(*(_QWORD *)buf + 16);
    v66 = *(_OWORD *)(*(_QWORD *)buf + 16 * v62);
    v67 = *(uint64_t *)&buf[8] >> 1;
    v68 = *(_QWORD *)(*(_QWORD *)buf + 16 * v62);
    *(_OWORD *)(*(_QWORD *)buf + 16) = v66;
    *(_QWORD *)&buf[16] = v57 - 1;
    v69 = v68 & 0x3FFFFFFFFFFFFFFFLL;
    v70 = 3;
    v71 = 2;
    v72 = 1;
    v64 = v165;
    while (1)
    {
      v73 = v70;
      v74 = *(int8x16_t *)(v65 + 16 * v71);
      if (v70 >= v57)
      {
        v75 = (int8x16_t)xmmword_1B8631BE0;
        if (v71 >= v57)
          goto LABEL_75;
      }
      else
      {
        v75 = *(int8x16_t *)(v65 + 16 * v70);
      }
      v76 = v74.i64[0] & 0x3FFFFFFFFFFFFFFFLL;
      v77 = v75.i64[0] & 0x3FFFFFFFFFFFFFFFLL;
      if ((v74.i64[0] & 0x3FFFFFFFFFFFFFFFuLL) < v69)
      {
        v78 = vdup_n_s32(v77 < v76);
        v79.i64[0] = v78.u32[0];
        v79.i64[1] = v78.u32[1];
        v80 = vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v79, 0x3FuLL)), v75, v74);
        if (v77 >= v76)
          v73 = v71;
        goto LABEL_68;
      }
      v80 = v75;
      if (v77 >= v69)
        break;
LABEL_68:
      _X15 = v65 + 32 * v73;
      __asm { PRFM            #1, [X15] }
      if (v73 != v72)
      {
        v71 = 2 * v73;
        v70 = (2 * v73) | 1;
        *(_OWORD *)(v65 + 16 * v73) = v66;
        *(int8x16_t *)(v65 + 16 * v72) = v80;
        v72 = v73;
        if (v73 < v67)
          continue;
      }
      goto LABEL_75;
    }
    _X8 = v65 + 32 * v72;
    __asm { PRFM            #1, [X8] }
LABEL_75:
    --v57;
LABEL_76:
    v89 = (v63 & 0x3F) == 0;
    LOBYTE(v171) = 0;
    v164 = v63;
    PageInner = _directoryStoreGetPageInner((uint64_t)(v165 + 1), v63, (BOOL *)&v171);
    v92 = PageInner;
    if ((_BYTE)v171)
    {
      directoryStorePageGetSize((unsigned __int16 *)PageInner, v91);
      v94 = v93;
      v95 = *(_QWORD **)buf;
      v96 = *(_QWORD *)&buf[8];
      if (v94)
      {
        v97 = v58;
        v98 = v59;
        v99 = v61;
        v100 = 0;
        v101 = v89;
        v102 = 0;
        v103 = v57;
        v104 = *(_QWORD *)&buf[8];
        v105 = *(_QWORD **)buf;
        v163 = v94;
        while (1)
        {
          v106 = v104;
          v107 = v103;
          v108 = v102;
          v109 = v99;
          v89 = v97;
          if (*(uint64_t *)&v92[16 * v100 + 8] < 2 || !*((_DWORD *)v64 + 1100))
            goto LABEL_113;
          v110 = *(_QWORD *)&v92[16 * v100 + 16];
          if (v110 < 0)
            break;
          if (v110)
          {
            v111 = *(_QWORD *)&v92[16 * v100 + 16];
            v112 = v101 & ((v110 & 0x3FFFFFFFFFFFFFFFuLL) < v64[30]);
            if ((v110 & 0x3F) != 0)
              v113 = 0;
            else
              v113 = v112;
            if (v103 + 2 >= v104)
            {
              if (v104 >= 4)
                v106 = 2 * v104;
              else
                v106 = 4;
              if (v105)
                v114 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, v105, 16 * v106 + 32, 0xECA6AA46uLL);
              else
                v114 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 16 * v106 + 32, 0x8DDAA030uLL);
              v105 = v114;
              v94 = v163;
              if (!v114)
              {
                _log_fault_for_malloc_failure();
                v94 = v163;
              }
              *v105 = 0;
              v105[1] = 0;
            }
            v121 = v107 + 1;
            v122 = &v105[2 * v107];
            *v122 = v111;
            v122[1] = 0;
            if (v107 >= 2)
            {
              do
              {
                v123 = v107;
                v124 = &v105[2 * v107];
                v107 = (unint64_t)v107 >> 1;
                v125 = &v105[2 * v107];
                if ((*v124 & 0x3FFFFFFFFFFFFFFFuLL) > (*v125 & 0x3FFFFFFFFFFFFFFFuLL))
                  break;
                *(_OWORD *)v174 = *(_OWORD *)v124;
                *(_OWORD *)v124 = *(_OWORD *)v125;
                *(_OWORD *)v125 = *(_OWORD *)v174;
              }
              while (v123 > 3);
            }
            v107 = v121;
            v101 = v113;
LABEL_112:
            v64 = v165;
          }
LABEL_113:
          v103 = v107;
          v104 = v106;
          v99 = v109;
          v102 = v108 + 1;
          v127 = (v108 + 1);
          v58 = v89;
          v97 = v89;
          v128 = v98;
          v100 = v127;
          LOBYTE(v89) = v101;
          v57 = v103;
          v96 = v104;
          v129 = v105;
          if (v94 <= v127)
            goto LABEL_142;
        }
        v115 = v110 & 0x7FFFFFFFFFFFFFFFLL;
        v116 = v99;
        v117 = v98;
        if (v98 >= 1)
        {
          do
          {
            v118 = *v116;
            v116 += 3;
            v101 = v101 & (v118 != v115);
            --v117;
          }
          while (v117);
        }
        v119 = v101;
        if (v98 >= v89)
        {
          v161 = v101;
          if (v89)
            v89 *= 2;
          else
            v89 = 4;
          v120 = v109
               ? malloc_type_zone_realloc((malloc_zone_t *)queryZone, v109, 24 * v89, 0xECA6AA46uLL)
               : malloc_type_zone_malloc((malloc_zone_t *)queryZone, 24 * v89, 0x8DDAA030uLL);
          v109 = v120;
          v94 = v163;
          v119 = v161;
          if (!v120)
          {
            _log_fault_for_malloc_failure();
            v119 = v161;
            v94 = v163;
          }
        }
        v126 = &v109[3 * v98];
        *v126 = v115;
        v126[1] = v164;
        v126[2] = v100;
        ++v98;
        v101 = v119;
        goto LABEL_112;
      }
      v109 = v61;
      v128 = v59;
      goto LABEL_141;
    }
    v162 = v61;
    Size = directoryTreePageGetSize(*(_WORD *)PageInner, PageInner[2], v91);
    v95 = *(_QWORD **)buf;
    v96 = *(_QWORD *)&buf[8];
    if (!Size)
    {
      v128 = v59;
      v109 = v61;
LABEL_141:
      v129 = v95;
      goto LABEL_142;
    }
    v131 = 0;
    v132 = v89;
    v133 = 0;
    v134 = v57;
    v135 = *(_QWORD *)&buf[8];
    v136 = *(_QWORD **)buf;
    do
    {
      v137 = v133;
      v138 = *(_QWORD *)&v92[8 * v131 + 8];
      if (v138)
      {
        if ((v138 & 0x3F) != 0)
          v139 = 0;
        else
          v139 = v132 & ((v138 & 0x3FFFFFFFFFFFFFFFuLL) < v64[30]);
        if (v134 + 2 >= v135)
        {
          if (v135 >= 4)
            v143 = 2 * v135;
          else
            v143 = 4;
          if (v136)
            v144 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, v136, 16 * v143 + 32, 0xECA6AA46uLL);
          else
            v144 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 16 * v143 + 32, 0x8DDAA030uLL);
          v136 = v144;
          if (!v144)
            _log_fault_for_malloc_failure();
          *v136 = 0;
          v136[1] = 0;
          v140 = v143;
          v64 = v165;
        }
        else
        {
          v140 = v135;
        }
        v145 = v134 + 1;
        v146 = &v136[2 * v134];
        *v146 = v138;
        v146[1] = 0;
        if (v134 >= 2)
        {
          do
          {
            v147 = &v136[2 * v134];
            v148 = &v136[2 * ((unint64_t)v134 >> 1)];
            if ((*v147 & 0x3FFFFFFFFFFFFFFFuLL) > (*v148 & 0x3FFFFFFFFFFFFFFFuLL))
              break;
            v149 = v134;
            *(_OWORD *)v174 = *(_OWORD *)v147;
            *(_OWORD *)v147 = *(_OWORD *)v148;
            *(_OWORD *)v148 = *(_OWORD *)v174;
            v134 = (unint64_t)v134 >> 1;
          }
          while (v149 > 3);
        }
        v129 = v136;
        v135 = v140;
        v141 = v145;
        v142 = v139;
      }
      else
      {
        v129 = v136;
        v141 = v134;
        v142 = v132;
      }
      v96 = v135;
      v131 = (v137 + 1);
      v132 = v142;
      v133 = v137 + 1;
      v134 = v141;
      v136 = v129;
    }
    while (Size > v131);
    v128 = v59;
    v109 = v162;
    v57 = v141;
    LOBYTE(v89) = v142;
LABEL_142:
    *(_QWORD *)&buf[8] = v96;
    *(_QWORD *)&buf[16] = v57;
    *(_QWORD *)buf = v129;
    v150 = v89 & 1;
    if (v57 == 1)
      break;
    v59 = v128;
    v60 = v109;
  }
  while ((v89 & 1) != 0);
  free(v129);
  if (v128 >= 2)
  {
    if (qos_class_self() >= 0x12 && v128 > 2047)
    {
      v151 = OSAtomicDequeue(&qsort_cached_allocations_3147, 0);
      if (!v151)
        v151 = malloc_type_malloc(0x40uLL, 0x102004053A8A26AuLL);
      v152 = dispatch_group_create();
      v151[3] = v152;
      v151[4] = 0;
      v151[1] = 0;
      v151[2] = v128 - 1;
      *v151 = v109;
      v153 = thread_count_3148;
      if (!thread_count_3148)
      {
        *(_QWORD *)v174 = 0x1900000006;
        v171 = 4;
        sysctl(v174, 2u, &thread_count_3148, &v171, 0, 0);
        v153 = thread_count_3148;
      }
      *((_DWORD *)v151 + 14) = v153;
      v151[5] = (uint64_t)sqrt((double)v128) / 2;
      if (!v153)
      {
        *(_QWORD *)v174 = 0x1900000006;
        v171 = 4;
        sysctl(v174, 2u, &thread_count_3148, &v171, 0, 0);
        v153 = thread_count_3148;
      }
      v154 = v128 / (2 * v153);
      if (v154 <= 0x8000)
      {
        v154 = 0x8000;
      }
      else if (!v153)
      {
        *(_QWORD *)v174 = 0x1900000006;
        v171 = 4;
        sysctl(v174, 2u, &thread_count_3148, &v171, 0, 0);
        v154 = v128 / (2 * thread_count_3148);
      }
      v151[6] = v154;
      if ((uint64_t)v151[5] <= 2047)
        v151[5] = 2048;
      _qsort_big_offset_triple(v151);
      dispatch_group_wait(v152, 0xFFFFFFFFFFFFFFFFLL);
      dispatch_release(v152);
    }
    else
    {
      _qsort_offset_triple((uint64_t)v109, 0, v128 - 1);
    }
    v155 = v109 + 3;
    v156 = *v109;
    v157 = v128 - 1;
    v158 = v150;
    do
    {
      v159 = *v155;
      v155 += 3;
      v158 &= v159 != v156;
      v156 = v159;
      v150 = v158;
      --v157;
    }
    while (v157);
  }
  free(v109);
  if ((v150 & 1) == 0)
    goto LABEL_165;
  return v165;
}

void shadowForwardStore(uint64_t a1, int a2, _DWORD *a3)
{
  BOOL v3;
  char v5;
  char *v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  NSObject *v12;
  int v13;
  char *sibling_protected;
  uint64_t v15;
  void *v16;
  void *v17;
  size_t v18;
  _DWORD *v19;
  int v20;
  int v21;
  NSObject *v22;
  int v23;
  uint64_t v24;
  int v25;
  int v26;
  CFIndex v27;
  unsigned int v28;
  uint64_t v29;
  CFIndex v30;
  uint64_t v31;
  uint8_t *v32;
  CFIndex v33;
  int v34;
  NSObject *v35;
  const char *v36;
  int v37;
  int v38;
  int v39;
  NSObject *v40;
  int v41;
  NSObject *v42;
  int v43;
  NSObject *v44;
  char *v45;
  char *v46;
  const char *v47;
  uint64_t v48;
  int v49;
  NSObject *v50;
  const char *v51;
  int v52;
  CFIndex *v53;
  unsigned int v54;
  unsigned int __fd;
  uint64_t v56;
  uint64_t v57;
  uint8_t buf[4];
  const char *v59;
  __int16 v60;
  int v61;
  __int16 v62;
  int v63;
  __int16 v64;
  char *v65;
  uint8_t v66[32];
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  char v90[1024];
  char v91[1024];
  uint64_t v92;

  v92 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)a1)
    v3 = 0;
  else
    v3 = a2 == 0;
  if (v3)
    return;
  v5 = a2;
  bzero(v91, 0x400uLL);
  bzero(v90, 0x400uLL);
  v7 = fd_name(*(_QWORD *)(a1 + 224), v91, 0x400uLL);
  if (!v7)
  {
    v11 = *__error();
    v12 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v66 = 136315394;
      *(_QWORD *)&v66[4] = "shadowForwardStore";
      *(_WORD *)&v66[12] = 1024;
      *(_DWORD *)&v66[14] = 2570;
      _os_log_error_impl(&dword_1B8270000, v12, OS_LOG_TYPE_ERROR, "%s:%d: no path for shadow", v66, 0x12u);
    }
    *__error() = v11;
    return;
  }
  v8 = v7;
  __strlcpy_chk();
  strlcat(v8, ".shadow", 0x400uLL);
  v9 = *(_QWORD *)(a1 + 224);
  if (v9)
    v10 = *(unsigned int *)(v9 + 44);
  else
    v10 = 0xFFFFFFFFLL;
  if (isRegisteredForCloning(v10) && (copyFileFallback(v10, v90, v10, v8, a3, 0, 1) & 1) != 0)
  {
    bit_vector_set_bits_3284(a1 + 4376, 0, *(_QWORD *)(a1 + 4376));
    return;
  }
  v13 = *(_DWORD *)(a1 + 240);
  directoryStoreValidate(a1 + 8, a1 + 4416);
  v88 = 0u;
  v89 = 0u;
  v86 = 0u;
  v87 = 0u;
  v84 = 0u;
  v85 = 0u;
  v82 = 0u;
  v83 = 0u;
  v80 = 0u;
  v81 = 0u;
  v78 = 0u;
  v79 = 0u;
  v76 = 0u;
  v77 = 0u;
  v74 = 0u;
  v75 = 0u;
  v72 = 0u;
  v73 = 0u;
  v70 = 0u;
  v71 = 0u;
  v68 = 0u;
  v69 = 0u;
  v67 = 0u;
  memset(v66, 0, sizeof(v66));
  v56 = 0;
  v57 = 0;
  sibling_protected = (char *)fd_create_sibling_protected(*(_QWORD *)(a1 + 224), v8, 514, 0);
  fd_no_cache((uint64_t)sibling_protected);
  if (!sibling_protected)
  {
    v20 = *__error();
    v21 = *__error();
    v22 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      v59 = "shadowForwardStore";
      v60 = 1024;
      v61 = 2605;
      v62 = 1024;
      v63 = v20;
      v64 = 2080;
      v65 = v8;
      _os_log_error_impl(&dword_1B8270000, v22, OS_LOG_TYPE_ERROR, "%s:%d: open err: %d, %s", buf, 0x22u);
    }
    v17 = 0;
    goto LABEL_68;
  }
  v15 = (v13 + 0x1FFFF) >> 17;
  if ((v5 & 1) == 0 && v15 >= *(_QWORD *)(a1 + 4376))
    v15 = *(_QWORD *)(a1 + 4376);
  v16 = malloc_type_malloc(0x20000uLL, 0x18D56B17uLL);
  if (!v16)
  {
    v45 = __si_assert_copy_extra(0);
    v46 = v45;
    v47 = "";
    if (v45)
      v47 = v45;
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 2615, "readBuffer", v47);
    free(v46);
    if (__valid_fs(-1))
      v48 = 2989;
    else
      v48 = 3072;
    *(_DWORD *)v48 = -559038737;
    abort();
  }
  v17 = v16;
  v18 = *(_QWORD *)(a1 + 240);
  v19 = *(_DWORD **)(a1 + 224);
  if (v18 >> 17)
  {
    v23 = _fd_acquire_fd((uint64_t)v19, &v56);
    if (v23 != -1)
    {
      LODWORD(v24) = v23;
      v25 = _fd_acquire_fd((uint64_t)sibling_protected, &v57);
      if (v25 == -1)
      {
        v39 = *__error();
        v21 = *__error();
        v40 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          v59 = "shadowForwardStore";
          v60 = 1024;
          v61 = 2638;
          v62 = 1024;
          v63 = v39;
          _os_log_error_impl(&dword_1B8270000, v40, OS_LOG_TYPE_ERROR, "%s:%d: fd_open err: %d", buf, 0x18u);
        }
        v26 = -1;
      }
      else
      {
        v26 = v25;
        if (v15 < 1)
        {
LABEL_59:
          _fd_release_fd(*(_DWORD **)(a1 + 224), v24, 0, v56);
          _fd_release_fd(sibling_protected, v26, 0, v57);
          goto LABEL_60;
        }
        v54 = v25;
        __fd = v24;
        v27 = 0;
        v28 = 0;
        v53 = (CFIndex *)(a1 + 4376);
        while (v28 != 100)
        {
LABEL_43:
          if ((v5 & 1) != 0 || *v53 > v27 && CFBitVectorGetBitAtIndex(*(CFBitVectorRef *)(a1 + 4392), v27))
            *(_DWORD *)&v66[4 * v28++] = v27;
          if (++v27 == v15)
          {
            v26 = v54;
            v24 = v24;
            if (v28)
            {
              v31 = v28;
              v32 = v66;
              while (1)
              {
                if (*a3 == 1 || *a3 == -1 && (v5 & 1) != 0)
                  goto LABEL_70;
                v33 = *(unsigned int *)v32;
                if (prot_pread(v24, v17, 0x20000uLL, v33 << 17) == -1)
                  break;
                if (*a3 == 1 || *a3 == -1 && (v5 & 1) != 0)
                  goto LABEL_75;
                if (prot_pwrite_guarded(v54, (uint64_t)&v57, (uint64_t)v17, 0x20000uLL, v33 << 17) == -1)
                {
                  v52 = *__error();
                  v21 = *__error();
                  v50 = _SILogForLogForCategory(0);
                  if (!os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
                    goto LABEL_89;
                  *(_DWORD *)buf = 136315650;
                  v59 = "shadowForwardStore";
                  v60 = 1024;
                  v61 = 2697;
                  v62 = 1024;
                  v63 = v52;
                  v51 = "%s:%d: pwrite err: %d";
                  goto LABEL_93;
                }
                bit_vector_internal_touch_for_set_3277(v53, v33);
                CFBitVectorSetBitAtIndex(*(CFMutableBitVectorRef *)(a1 + 4392), v33, 0);
                v32 += 4;
                --v31;
                v26 = v54;
                v24 = __fd;
                if (!v31)
                  goto LABEL_59;
              }
              v49 = *__error();
              v21 = *__error();
              v50 = _SILogForLogForCategory(0);
              if (!os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
              {
LABEL_89:
                LODWORD(v24) = __fd;
                goto LABEL_81;
              }
              *(_DWORD *)buf = 136315650;
              v59 = "shadowForwardStore";
              v60 = 1024;
              v61 = 2688;
              v62 = 1024;
              v63 = v49;
              v51 = "%s:%d: pread err: %d";
LABEL_93:
              _os_log_error_impl(&dword_1B8270000, v50, OS_LOG_TYPE_ERROR, v51, buf, 0x18u);
              goto LABEL_89;
            }
            goto LABEL_59;
          }
        }
        v29 = 0;
        while (1)
        {
          if (*a3 == 1 || *a3 == -1 && (v5 & 1) != 0)
          {
LABEL_75:
            v26 = v54;
            LODWORD(v24) = __fd;
            goto LABEL_70;
          }
          v30 = *(unsigned int *)&v66[v29];
          if (prot_pread(v24, v17, 0x20000uLL, v30 << 17) == -1)
          {
            v41 = *__error();
            v21 = *__error();
            v42 = _SILogForLogForCategory(0);
            v26 = v54;
            if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136315650;
              v59 = "shadowForwardStore";
              v60 = 1024;
              v61 = 2651;
              v62 = 1024;
              v63 = v41;
              _os_log_error_impl(&dword_1B8270000, v42, OS_LOG_TYPE_ERROR, "%s:%d: read err: %d", buf, 0x18u);
            }
            goto LABEL_69;
          }
          if (*a3 == 1 || *a3 == -1 && (v5 & 1) != 0)
            goto LABEL_75;
          if (prot_pwrite_guarded(v54, (uint64_t)&v57, (uint64_t)v17, 0x20000uLL, v30 << 17) == -1)
            break;
          bit_vector_internal_touch_for_set_3277(v53, v30);
          CFBitVectorSetBitAtIndex(*(CFMutableBitVectorRef *)(a1 + 4392), v30, 0);
          v29 += 4;
          if (v29 == 400)
          {
            v28 = 0;
            goto LABEL_43;
          }
        }
        v43 = *__error();
        v21 = *__error();
        v44 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          v59 = "shadowForwardStore";
          v60 = 1024;
          v61 = 2660;
          v62 = 1024;
          v63 = v43;
          _os_log_error_impl(&dword_1B8270000, v44, OS_LOG_TYPE_ERROR, "%s:%d: pwrite err: %d", buf, 0x18u);
        }
LABEL_81:
        v26 = v54;
      }
      goto LABEL_69;
    }
    v37 = *__error();
    v21 = *__error();
    v35 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315650;
      v59 = "shadowForwardStore";
      v60 = 1024;
      v61 = 2632;
      v62 = 1024;
      v63 = v37;
      v36 = "%s:%d: fd_open err: %d";
      goto LABEL_67;
    }
  }
  else
  {
    if (fd_pread(v19, v17, v18, 0) != -1)
    {
      if (fd_pwrite((uint64_t)sibling_protected, (uint64_t)v17, *(_QWORD *)(a1 + 240), 0) != -1)
      {
        bit_vector_internal_touch_for_set_3277((CFIndex *)(a1 + 4376), 0);
        CFBitVectorSetBitAtIndex(*(CFMutableBitVectorRef *)(a1 + 4392), 0, 0);
LABEL_60:
        fd_release(sibling_protected);
        free(v17);
        return;
      }
      v38 = *__error();
      v21 = *__error();
      v35 = _SILogForLogForCategory(0);
      if (!os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
        goto LABEL_68;
      *(_DWORD *)buf = 136315650;
      v59 = "shadowForwardStore";
      v60 = 1024;
      v61 = 2624;
      v62 = 1024;
      v63 = v38;
      v36 = "%s:%d: pwrite err: %d";
      goto LABEL_67;
    }
    v34 = *__error();
    v21 = *__error();
    v35 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315650;
      v59 = "shadowForwardStore";
      v60 = 1024;
      v61 = 2619;
      v62 = 1024;
      v63 = v34;
      v36 = "%s:%d: read err: %d";
LABEL_67:
      _os_log_error_impl(&dword_1B8270000, v35, OS_LOG_TYPE_ERROR, v36, buf, 0x18u);
    }
  }
LABEL_68:
  v26 = -1;
  LODWORD(v24) = -1;
LABEL_69:
  *__error() = v21;
LABEL_70:
  free(v17);
  _fd_release_fd(*(_DWORD **)(a1 + 224), v24, 0, v56);
  _fd_release_fd(sibling_protected, v26, 0, v57);
  fd_release(sibling_protected);
}

void bit_vector_internal_touch_for_set_3277(CFIndex *a1, CFIndex a2)
{
  CFIndex v4;
  CFIndex v5;
  char *v6;
  char *v7;
  const char *v8;
  uint64_t v9;
  const __CFBitVector *v10;
  const __CFAllocator *v11;
  __CFBitVector *MutableCopy;
  __CFBitVector *v13;
  const void *v14;
  char *v15;
  const char *v16;

  v4 = a1[1];
  if (v4 <= a2)
  {
    if (v4)
      v5 = a1[1];
    else
      v5 = 32;
    while (1)
    {
      v5 *= 2;
      if (v5 > a2)
        break;
      if (v5 <= v4)
      {
        v6 = __si_assert_copy_extra(0);
        v7 = v6;
        v8 = "";
        if (v6)
          v8 = v6;
        __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 111, "newCapacity > bv->capacity", v8);
        goto LABEL_13;
      }
    }
    v10 = (const __CFBitVector *)a1[2];
    v11 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    if (v10)
      MutableCopy = CFBitVectorCreateMutableCopy(v11, v5, v10);
    else
      MutableCopy = CFBitVectorCreateMutable(v11, v5);
    v13 = MutableCopy;
    if (!MutableCopy)
    {
      v15 = __si_assert_copy_extra(0);
      v7 = v15;
      v16 = "";
      if (v15)
        v16 = v15;
      __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 115, "newBV", v16);
LABEL_13:
      free(v7);
      if (__valid_fs(-1))
        v9 = 2989;
      else
        v9 = 3072;
      *(_DWORD *)v9 = -559038737;
      abort();
    }
    CFBitVectorSetCount(MutableCopy, v5);
    v14 = (const void *)a1[2];
    if (v14)
      CFRelease(v14);
    a1[1] = v5;
    a1[2] = (CFIndex)v13;
  }
  if (*a1 <= a2)
    *a1 = a2 + 1;
}

void bit_vector_set_bits_3284(uint64_t a1, CFIndex a2, CFIndex a3)
{
  char *v6;
  char *v7;
  const char *v8;
  uint64_t v9;
  CFRange v10;

  if (a2 < 0)
  {
    v6 = __si_assert_copy_extra(0);
    v7 = v6;
    v8 = "";
    if (v6)
      v8 = v6;
    __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 151, "range.location >= 0", v8);
    free(v7);
    if (__valid_fs(-1))
      v9 = 2989;
    else
      v9 = 3072;
    *(_DWORD *)v9 = -559038737;
    abort();
  }
  if (a3 >= 1)
  {
    bit_vector_internal_touch_for_set_3277((CFIndex *)a1, a3 + a2 - 1);
    v10.location = a2;
    v10.length = a3;
    CFBitVectorSetBits(*(CFMutableBitVectorRef *)(a1 + 16), v10, 0);
  }
}

uint64_t directoryStoreMakePathWithPostingsOffset(uint64_t a1, int a2, _QWORD *a3, unint64_t a4, uint64_t a5)
{
  uint64_t v10;
  int v11;
  int32_t v12;
  uint64_t v13;
  int v14;
  unint64_t v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  void (*v20)(_QWORD);
  int v21;
  NSObject *v22;
  _QWORD *v23;
  int v24;
  uint64_t v25;
  _BOOL4 v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  char *v30;
  const char *v31;
  char *v32;
  char *v33;
  const char *v34;
  uint64_t v35;
  uint64_t v36;
  unsigned int v37;
  uint64_t v38;
  void (*v39)(_QWORD);
  char *v41;
  const char *v42;
  char *v43;
  const char *v44;
  char *v45;
  const char *v46;
  char *v47;
  const char *v48;
  uint64_t v49;
  char *v50;
  const char *v51;
  uint64_t v52;
  int v53;
  __int128 v54;
  uint64_t v55;
  __int128 v56;
  uint64_t v57;
  __int128 v58;
  uint64_t v59;
  unint64_t v60;
  unsigned int v61;
  unsigned int v62;
  unsigned int v63;
  unint64_t v64;
  unsigned int v65;
  unsigned __int8 v66;
  uint8_t buf[32];
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  uint64_t v73;
  uint64_t v74;

  v74 = *MEMORY[0x1E0C80C00];
  v10 = a1 + 8;
  v66 = 0;
  v11 = setCrashStateTarget(3);
  if (!storageResolvePtr(v10, 0, 1uLL, 1))
    goto LABEL_40;
  v12 = OSAtomicIncrement32((int32_t *)exceptionSequenceNum);
  v65 = 0;
  v64 = 0;
  v63 = 0;
  v13 = *(_QWORD *)(a1 + 224);
  if (v13)
    v14 = *(_DWORD *)(v13 + 44);
  else
    v14 = -1;
  v15 = setThreadIdAndInfo(v14, sStorageExceptionCallbacks, v10, 1, v12);
  v65 = v15;
  v63 = v17;
  v64 = __PAIR64__(HIDWORD(v15), v16);
  v18 = *(_QWORD *)&threadData[18 * v15 + 2];
  v19 = v18 + 320 * HIDWORD(v15);
  v53 = *(_DWORD *)(v19 + 312);
  v20 = *(void (**)(_QWORD))(v19 + 224);
  if (v20)
    v20(*(_QWORD *)(v18 + 320 * HIDWORD(v15) + 288));
  v62 = v65;
  v61 = HIDWORD(v64);
  v60 = __PAIR64__(v64, v63);
  if (_setjmp((int *)v19))
  {
    v21 = *__error();
    v22 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "directoryStoreMakePathWithPostingsOffset";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 2859;
      _os_log_error_impl(&dword_1B8270000, v22, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
    }
    *__error() = v21;
    *(_DWORD *)(v19 + 312) = v53;
    CIOnThreadCleanUpReset(v60);
    dropThreadId(v62, 1, v12);
    CICleanUpReset(v62, HIDWORD(v60));
    goto LABEL_40;
  }
  *(_BYTE *)a1 = 1;
  if (a4 >= 0x7FFFFFFFFFFFFFFFLL)
  {
    v41 = __si_assert_copy_extra(0);
    v30 = v41;
    v42 = "";
    if (v41)
      v42 = v41;
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 2761, "postings<9223372036854775807", v42);
LABEL_53:
    free(v30);
    if (__valid_fs(-1))
      v49 = 2989;
    else
      v49 = 3072;
    *(_DWORD *)v49 = -559038737;
    abort();
  }
  v23 = (_QWORD *)(a1 + 4416);
  if (*v23 != 2)
  {
    v43 = __si_assert_copy_extra(0);
    v33 = v43;
    v44 = "";
    if (v43)
      v44 = v43;
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 2763, "getStoreOID(root.directory->fileId)==2", v44);
    goto LABEL_60;
  }
  if (a2)
  {
    v24 = a2 - 1;
    if (a3[a2 - 1] != 2)
      v24 = a2;
    if (v24 < 2)
    {
      v26 = 0;
      a2 = v24;
    }
    else
    {
      v25 = a3[1];
      v26 = *a3 == v25;
      if (*a3 == v25)
      {
        ++a3;
        a2 = v24 - 1;
      }
      else
      {
        a2 = v24;
      }
    }
  }
  else
  {
    v26 = 0;
  }
  directoryStoreValidate(v10, (uint64_t)v23);
  v73 = 0;
  v71 = 0u;
  v72 = 0u;
  v69 = 0u;
  v70 = 0u;
  v68 = 0u;
  memset(buf, 0, sizeof(buf));
  v58 = 0uLL;
  v59 = 0;
  v57 = 0;
  v56 = (unint64_t)v23;
  directoryStoreGetDirectoryWithPath((unsigned __int16 *)&v58, v10, (unint64_t *)&v56, a2 - 1, (uint64_t)a3, 1, (uint64_t)buf);
  v27 = v58;
  if (!a4)
  {
    if ((_QWORD)v58)
      goto LABEL_35;
    v32 = __si_assert_copy_extra(0);
    v33 = v32;
    v34 = "";
    if (v32)
      v34 = v32;
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 2847, "target.directory", v34);
LABEL_60:
    free(v33);
    if (__valid_fs(-1))
      v52 = 2989;
    else
      v52 = 3072;
    *(_DWORD *)v52 = -559038737;
    abort();
  }
  v28 = *(_QWORD *)(v58 + 8);
  if (v26)
  {
    if (v28)
    {
      v73 = 0;
      v71 = 0u;
      v72 = 0u;
      v69 = 0u;
      v70 = 0u;
      v68 = 0u;
      memset(buf, 0, sizeof(buf));
      v54 = v58;
      v55 = v59;
      directoryStoreGetDirectoryWithPath((unsigned __int16 *)&v56, v10, (unint64_t *)&v54, 0, (uint64_t)a3, 1, (uint64_t)buf);
      v58 = v56;
      v59 = v57;
      v27 = v56;
      if (*(_QWORD *)(v56 + 8))
      {
        v29 = __si_assert_copy_extra(0);
        v30 = v29;
        v31 = "";
        if (v29)
          v31 = v29;
        __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 2840, "!target.directory->childPage.offset", v31);
        goto LABEL_53;
      }
    }
    goto LABEL_34;
  }
  if (v28)
  {
    v50 = __si_assert_copy_extra(0);
    v33 = v50;
    v51 = "";
    if (v50)
      v51 = v50;
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 2842, "!target.directory->childPage.offset", v51);
    goto LABEL_60;
  }
LABEL_34:
  *(_QWORD *)(v27 + 8) = a4 | 0x8000000000000000;
LABEL_35:
  directoryStoreValidate(v10, (uint64_t)v23);
  if (*v23 != 2)
  {
    v45 = __si_assert_copy_extra(0);
    v33 = v45;
    v46 = "";
    if (v45)
      v46 = v45;
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 2849, "getStoreOID(root.directory->fileId)==2", v46);
    goto LABEL_60;
  }
  memcpy((void *)a5, a3, 8 * a2);
  *(_QWORD *)(a5 + 4096) = a2;
  v35 = *(_QWORD *)buf;
  *(_QWORD *)(a5 + 4104) = *((_QWORD *)&v72 + 1);
  *(_QWORD *)(a5 + 4112) = v35;
  if (v35 < 0)
  {
    v47 = __si_assert_copy_extra(0);
    v30 = v47;
    v48 = "";
    if (v47)
      v48 = v47;
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 2855, "!((refPage.pageOffset[0] & (1ull << 63)) || refPage.pageOffset[0]==0)", v48);
    goto LABEL_53;
  }
  *(_DWORD *)(a5 + 4120) = v72;
  v66 = 1;
  v36 = *(_QWORD *)&threadData[18 * v62 + 2];
  v37 = v61;
  v38 = v36 + 320 * v61;
  *(_DWORD *)(v38 + 312) = v53;
  v39 = *(void (**)(_QWORD))(v38 + 232);
  if (v39)
    v39(*(_QWORD *)(v36 + 320 * v37 + 288));
  dropThreadId(v62, 0, v12);
LABEL_40:
  setCrashStateTarget(v11);
  return v66;
}

void dumpDirectoryStore(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  _DWORD *v4;
  _DWORD *v5;
  int v6;
  int v7;
  _QWORD *v8;
  int v9;
  int32_t v10;
  unint64_t v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  void (*v16)(_QWORD);
  _DWORD *v17;
  int v18;
  NSObject *v19;
  int v20;
  NSObject *v21;
  os_log_type_t v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  BOOL v27;
  unint64_t v28;
  unint64_t v29;
  int v30;
  int v31;
  _BYTE *v32;
  int v33;
  unint64_t v34;
  unint64_t v35;
  int v36;
  int v37;
  _BYTE *v38;
  int v39;
  _BYTE *v40;
  uint64_t v41;
  _QWORD *v42;
  uint64_t v43;
  int v44;
  int v45;
  _BYTE *v46;
  int v47;
  int v48;
  uint64_t v49;
  uint64_t v50;
  _BYTE *v51;
  unsigned __int16 *Page;
  int8x8_t v53;
  unsigned __int16 *v54;
  unint64_t Size;
  _BYTE *v56;
  _QWORD *v57;
  unint64_t v58;
  unint64_t v59;
  unint64_t v60;
  int v61;
  int64_t v62;
  int v63;
  uint64_t v64;
  uint64_t v65;
  int64_t v66;
  int v67;
  _BYTE *v68;
  char v69;
  uint64_t v70;
  int64_t v71;
  char v72;
  int v73;
  _BYTE *v74;
  unint64_t v75;
  uint64_t v76;
  uint64_t (*v77)(void);
  uint64_t v78;
  uint64_t v79;
  void (*v80)(_QWORD);
  char *v81;
  uint64_t v82;
  char *v83;
  uint64_t v84;
  char *v85;
  char *v86;
  const char *v87;
  unint64_t v88;
  unint64_t v89;
  unint64_t v90;
  unsigned int v91;
  uint64_t v92;
  int v93;
  int v94;
  unsigned int v95;
  unsigned int v96;
  unsigned int v97;
  unsigned int v98;
  char v99;
  uint64_t v100;
  unsigned int *v101;
  uint64_t v102;
  int v103;
  _BYTE v104[24628];
  int v105;
  int v106;
  const char *v107;
  __int16 v108;
  int v109;
  _QWORD v110[515];

  v1 = MEMORY[0x1E0C80A78](a1);
  v3 = v2;
  v5 = v4;
  v7 = v6;
  v8 = (_QWORD *)v1;
  v110[512] = *MEMORY[0x1E0C80C00];
  bzero(v110, 0x1000uLL);
  v105 = 0;
  bzero(&v103, 0x6038uLL);
  v100 = 0;
  v101 = 0;
  v102 = 0;
  storage_reader_init((uint64_t)(v8 + 1), (uint64_t)&v100);
  v99 = 0;
  v9 = setCrashStateTarget(3);
  if ((_BYTE)v102)
  {
    v10 = OSAtomicIncrement32((int32_t *)exceptionSequenceNum);
    v11 = setThreadIdAndInfo(-1, sStorageReaderExceptionCallbacks, (uint64_t)&v100, 0, v10);
    v97 = HIDWORD(v11);
    v98 = v11;
    v95 = v13;
    v96 = v12;
    v14 = *(_QWORD *)&threadData[18 * v11 + 2];
    v15 = v14 + 320 * HIDWORD(v11);
    v93 = *(_DWORD *)(v15 + 312);
    v16 = *(void (**)(_QWORD))(v15 + 224);
    if (v16)
      v16(*(_QWORD *)(v14 + 320 * HIDWORD(v11) + 288));
    v94 = v10;
    if (_setjmp((int *)v15))
    {
      v17 = (_DWORD *)(v15 + 312);
      v18 = *__error();
      v19 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        v106 = 136315394;
        v107 = "dumpDirectoryStore";
        v108 = 1024;
        v109 = 3174;
        _os_log_error_impl(&dword_1B8270000, v19, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", (uint8_t *)&v106, 0x12u);
      }
      *__error() = v18;
      *v17 = v93;
      CIOnThreadCleanUpReset(v95);
      dropThreadId(v98, 1, v94);
      CICleanUpReset(v98, v96);
      goto LABEL_86;
    }
    v23 = (uint64_t)CICleanUpThreadLoc();
    v91 = threadData[18 * v23 + 8];
    v92 = v23;
    CICleanUpPush(v23, (uint64_t)cleanup, (uint64_t)&v103);
    v110[511] = 2;
    v24 = v8[553];
    v25 = v8[554];
    v26 = v8[555];
    v27 = v26 - v25 < 0x100000001 && v26 > v25;
    v28 = v26 & 0xFFFFFFFF00000000;
    if (v27)
      v29 = v28;
    else
      v29 = 0;
    v89 = v29;
    v90 = v8[554];
    v88 = v29;
    if ((v24 & 0x8000000000000000) == 0)
    {
      if (v24)
      {
        v30 = v105 + 1;
        if ((v24 & 0x4000000000000000) == 0)
        {
          v31 = v103;
          v32 = &v104[48 * v103];
          *(_DWORD *)v32 = v30;
          *(_QWORD *)(v32 + 12) = 0x200000000;
          *(_QWORD *)(v32 + 4) = 0;
          *(_QWORD *)(v32 + 20) = 0;
          *(_QWORD *)(v32 + 28) = 0;
          *(_QWORD *)(v32 + 36) = 0;
          *((_DWORD *)v32 + 11) = 0;
          *((_QWORD *)v32 + 3) = v24;
          v33 = v31 + 1;
          v103 = v31 + 1;
          if (v31 == -1)
          {
LABEL_83:
            CICleanUpReset(v92, v91);
            v78 = *(_QWORD *)&threadData[18 * v98 + 2];
            v79 = v78 + 320 * v97;
            *(_DWORD *)(v79 + 312) = v93;
            v80 = *(void (**)(_QWORD))(v79 + 232);
            if (v80)
              v80(*(_QWORD *)(v78 + 320 * v97 + 288));
            dropThreadId(v98, 0, v10);
            goto LABEL_86;
          }
          while (1)
          {
LABEL_30:
            if (v99 || *v5)
              goto LABEL_83;
            v36 = v33 - 1;
            v37 = *(_DWORD *)&v104[48 * (v33 - 1) + 16];
            if (v37 != 2)
              break;
            if (!*v5)
            {
              LOBYTE(v106) = 0;
              v51 = &v104[48 * v36];
              Page = _directoryStoreReaderGetPage(&v100, *((_QWORD *)v51 + 3), (BOOL *)&v106);
              if (Page)
              {
                if ((_BYTE)v106)
                {
                  v83 = __si_assert_copy_extra(0);
                  __message_assert("%s:%u: failed assertion '%s' %s ");
                  goto LABEL_95;
                }
                v54 = Page;
                Size = directoryTreePageGetSize(*Page, *((_BYTE *)Page + 2), v53);
                v56 = &v104[48 * v36];
                v59 = *((_QWORD *)v56 + 1);
                v57 = v56 + 8;
                v58 = v59;
                if (v59 >= Size)
                {
LABEL_46:
                  v63 = v103 - 1;
LABEL_47:
                  v103 = v63;
                }
                else
                {
                  v60 = v58;
                  *v57 = v58 + 1;
                  v61 = *(_DWORD *)v51;
                  while (!*v5)
                  {
                    v62 = *(_QWORD *)&v54[4 * v60 + 4];
                    if (v62 >= 1)
                    {
                      if ((v62 & 0x4000000000000000) == 0)
                      {
                        v73 = v103;
                        v74 = &v104[48 * v103];
                        *(_DWORD *)v74 = v61;
                        *(_QWORD *)(v74 + 4) = 0;
                        *(_QWORD *)(v74 + 20) = 0;
                        *(_QWORD *)(v74 + 28) = 0;
                        *(_QWORD *)(v74 + 36) = 0;
                        *(_QWORD *)(v74 + 12) = 0x200000000;
                        *((_DWORD *)v74 + 11) = 0;
                        *((_QWORD *)v74 + 3) = v62;
                        v63 = v73 + 1;
                        goto LABEL_47;
                      }
                      dumpDirectoryStorePage(&v100, v5, v62, v61, &v103, (uint64_t)v104);
                      break;
                    }
                    *v57 = v60 + 2;
                    if (Size == ++v60)
                      goto LABEL_46;
                  }
                }
              }
            }
LABEL_66:
            v33 = v103;
            if (!v103)
              goto LABEL_83;
          }
          if (v37 != 1)
          {
            v85 = __si_assert_copy_extra(0);
            v86 = v85;
            if (v85)
              v87 = v85;
            else
              v87 = "";
            __message_assert("%s:%u: Unexpected code path %s ", "FileTree.c", 3169, v87);
            free(v86);
            goto LABEL_91;
          }
          v38 = &v104[48 * v36];
          v39 = *(_DWORD *)v38;
          v40 = v38;
          v42 = v38 + 8;
          v41 = *((_QWORD *)v38 + 1);
          v43 = *((_QWORD *)v38 + 5);
          v44 = *(_DWORD *)v38;
          v45 = *(_DWORD *)v38;
          v48 = v40[24];
          v46 = v40 + 24;
          v47 = v48;
          if (v41 == v43)
          {
            if (v47 || (v7 & 1) != 0)
            {
              free(*((void **)v46 + 1));
              --v103;
              v69 = 0;
LABEL_65:
              v99 = v69;
              goto LABEL_66;
            }
            v49 = 0;
            *v42 = 0;
            *v46 = 1;
            v50 = *((_QWORD *)v46 + 1);
          }
          else
          {
            v64 = *((_QWORD *)v46 + 1);
            if (!v47)
            {
              v70 = *(_QWORD *)(v64 + 24 * v41 + 8);
              if (v70 < 2)
                goto LABEL_63;
              v71 = *(_QWORD *)(v64 + 24 * v41 + 16);
              v66 = v71;
              v110[511 - v45] = v70;
              if (v71 < 0)
              {
                v75 = v71 & 0x7FFFFFFFFFFFFFFFLL;
                v76 = v71 & 0x7FFFFFFFFFFFFFFFLL;
                if ((v71 & 0x7FFFFFFFFFFFFFFFuLL) < v90)
                {
                  if (!v88 || HIDWORD(v75))
                  {
LABEL_104:
                    v83 = __si_assert_copy_extra(0);
                    __message_assert("%s:%u: failed assertion '%s' %s invalid posting 0x%llx for 0x%llx");
LABEL_95:
                    free(v83);
                    if (__valid_fs(-1))
                      v84 = 2989;
                    else
                      v84 = 3072;
                    *(_DWORD *)v84 = -559038737;
                    abort();
                  }
                  v76 = v75 | v89;
                }
                if (!v76)
                  goto LABEL_104;
                if (v39 >= 1 && v70 != v110[512 - v44])
                  v110[510 - v39] = v70;
                v77 = *(uint64_t (**)(void))(v3 + 16);
              }
              else
              {
                if (!v71)
                  goto LABEL_63;
                if ((v7 & 1) != 0)
                {
                  v67 = v39 + 1;
                  if ((v71 & 0x4000000000000000) == 0)
                  {
LABEL_55:
                    v68 = &v104[48 * v33];
                    *(_DWORD *)v68 = v67;
                    *(_QWORD *)(v68 + 4) = 0;
                    *(_QWORD *)(v68 + 20) = 0;
                    *(_QWORD *)(v68 + 28) = 0;
                    *(_QWORD *)(v68 + 36) = 0;
                    *(_QWORD *)(v68 + 12) = 0x200000000;
                    *((_DWORD *)v68 + 11) = 0;
                    *((_QWORD *)v68 + 3) = v66;
                    v103 = v33 + 1;
LABEL_63:
                    v72 = 0;
LABEL_64:
                    ++*v42;
                    v69 = v72;
                    goto LABEL_65;
                  }
LABEL_62:
                  dumpDirectoryStorePage(&v100, v5, v66, v67, &v103, (uint64_t)v104);
                  goto LABEL_63;
                }
                v77 = *(uint64_t (**)(void))(v3 + 16);
              }
              v72 = v77();
              goto LABEL_64;
            }
            v50 = *((_QWORD *)v46 + 1);
            v49 = v41;
          }
          if (v7)
          {
            v81 = __si_assert_copy_extra(0);
            __message_assert("%s:%u: failed assertion '%s' %s ");
            goto LABEL_90;
          }
          v65 = *(_QWORD *)(v50 + 24 * v49 + 8);
          if (v65 < 2)
            goto LABEL_63;
          v66 = *(_QWORD *)(v50 + 24 * v49 + 16);
          if (v66 < 1)
            goto LABEL_63;
          v110[511 - v39] = v65;
          v67 = v45 + 1;
          if ((v66 & 0x4000000000000000) == 0)
            goto LABEL_55;
          goto LABEL_62;
        }
        dumpDirectoryStorePage(&v100, v5, v24, v30, &v103, (uint64_t)v104);
      }
LABEL_29:
      v33 = v103;
      if (v103)
        goto LABEL_30;
      goto LABEL_83;
    }
    v34 = v24 & 0x7FFFFFFFFFFFFFFFLL;
    v35 = v34;
    if (v34 < v25)
    {
      if (HIDWORD(v34) || !v29)
        goto LABEL_103;
      v35 = v29 | v34;
    }
    if (v35)
    {
      v110[510] = 2;
      (*(void (**)(void))(v3 + 16))();
      goto LABEL_29;
    }
LABEL_103:
    v81 = __si_assert_copy_extra(0);
    __message_assert("%s:%u: failed assertion '%s' %s invalid posting 0x%llx for 0x%llx");
LABEL_90:
    free(v81);
    if (__valid_fs(-1))
LABEL_91:
      v82 = 2989;
    else
      v82 = 3072;
    *(_DWORD *)v82 = -559038737;
    abort();
  }
  v20 = *__error();
  v21 = _SILogForLogForCategory(0);
  v22 = 2 * (gSILogLevels[0] < 4);
  if (os_log_type_enabled(v21, v22))
  {
    LOWORD(v106) = 0;
    _os_log_impl(&dword_1B8270000, v21, v22, "Skipping because index is shut down", (uint8_t *)&v106, 2u);
  }
  *__error() = v20;
LABEL_86:
  setCrashStateTarget(v9);
  if (v101)
    _release_read_window(&availableReaders, v101);
}

void cleanup(unsigned int *a1)
{
  unint64_t v1;
  unint64_t v3;
  void **v4;

  v1 = *a1;
  if ((_DWORD)v1)
  {
    v3 = 0;
    v4 = (void **)(a1 + 10);
    do
    {
      if (*((_DWORD *)v4 - 4) == 1)
      {
        free(*v4);
        v1 = *a1;
      }
      ++v3;
      v4 += 6;
    }
    while (v3 < v1);
  }
}

void dumpDirectoryStorePage(uint64_t *a1, _DWORD *a2, unint64_t a3, int a4, _DWORD *a5, uint64_t a6)
{
  unsigned __int16 *Page;
  int8x8_t v11;
  unsigned __int16 *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  size_t v16;
  char *v17;
  uint64_t v18;
  unsigned __int16 *v19;
  unint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  char *v24;
  const char *v25;
  char *v26;
  const char *v27;
  uint64_t v28;
  char *v29;
  uint64_t v30;
  BOOL v31;

  v31 = 0;
  Page = _directoryStoreReaderGetPage(a1, a3, &v31);
  if (Page)
  {
    if (!v31)
    {
      v26 = __si_assert_copy_extra(0);
      v24 = v26;
      v27 = "";
      if (v26)
        v27 = v26;
      __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 3030, "flat", v27);
LABEL_21:
      free(v24);
      if (__valid_fs(-1))
        v28 = 2989;
      else
        v28 = 3072;
      *(_DWORD *)v28 = -559038737;
      abort();
    }
    if (!*a2)
    {
      v12 = Page;
      v13 = *Page;
      if ((64 << *((_BYTE *)Page + 2)) - 8 < (int)v13)
      {
        v29 = __si_assert_copy_extra(0);
        __message_assert("%s:%u: failed assertion '%s' %s Got end %d and size %d");
      }
      else
      {
        directoryStorePageGetSize(Page, v11);
        if (v13 < 0x10)
          return;
        v15 = v14;
        v16 = v13 >> 4;
        v17 = (char *)malloc_type_malloc(24 * (v13 >> 4), 0x1000040504FFAC1uLL);
        v18 = 0;
        if (v15)
        {
          v19 = v12 + 4;
          do
          {
            if (*(_QWORD *)v19)
            {
              v20 = (unint64_t *)&v17[24 * v18];
              *(_OWORD *)(v20 + 1) = *(_OWORD *)v19;
              *v20 = hash64(v20[1]);
              ++v18;
            }
            else if (*((_QWORD *)v19 + 1))
            {
              v23 = __si_assert_copy_extra(0);
              v24 = v23;
              v25 = "";
              if (v23)
                v25 = v23;
              __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 3008, "page->items[i].childPage.offset==0", v25);
              goto LABEL_21;
            }
            v19 += 8;
            --v15;
          }
          while (v15);
        }
        if (v18 == v16)
        {
          qsort_b(v17, v16, 0x18uLL, &__block_literal_global_124);
          v21 = a6 + 48 * *a5;
          *(_DWORD *)v21 = a4;
          *(_QWORD *)(v21 + 4) = 0;
          *(_QWORD *)(v21 + 12) = 0x100000000;
          *(_QWORD *)(v21 + 20) = 0;
          *(_DWORD *)(v21 + 44) = 0;
          *(_QWORD *)(v21 + 36) = 0;
          *(_QWORD *)(v21 + 28) = 0;
          LODWORD(v21) = *a5;
          v22 = a6 + 48 * *a5;
          *(_BYTE *)(v22 + 24) = 0;
          *(_QWORD *)(v22 + 32) = v17;
          *(_QWORD *)(v22 + 40) = v16;
          *a5 = v21 + 1;
          return;
        }
        v29 = __si_assert_copy_extra(0);
        __message_assert("%s:%u: failed assertion '%s' %s ");
      }
      free(v29);
      if (__valid_fs(-1))
        v30 = 2989;
      else
        v30 = 3072;
      *(_DWORD *)v30 = -559038737;
      abort();
    }
  }
}

uint64_t __dumpSpecialDirectoryStorePage_block_invoke(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  if (*a2 < *a3)
    return 0xFFFFFFFFLL;
  if (*a2 > *a3)
    return 1;
  if (a2[1] < a3[1])
    return 0xFFFFFFFFLL;
  return 1;
}

void compactForwardDirectoryStore(uint64_t a1)
{
  uint64_t v1;
  _DWORD *v2;
  _DWORD *v3;
  _BYTE *v4;
  _BYTE *v5;
  uint64_t v6;
  _BYTE v7[4128];

  v1 = MEMORY[0x1E0C80A78](a1);
  v3 = v2;
  v5 = v4;
  v6 = v1;
  bzero(v7, 0x1020uLL);
  dumpDirectoryStore(v6);
  if (!*v3)
    flushForwardStore(v5, 0);
}

uint64_t __compactForwardDirectoryStore_block_invoke(uint64_t a1, int a2, _QWORD *a3, unint64_t a4)
{
  uint64_t v7;
  char *v8;
  char *v10;
  char *v11;
  const char *v12;
  uint64_t v13;

  if (a4)
  {
    v7 = *(_QWORD *)(a1 + 32);
    if (v7)
    {
      if (!(_DWORD)a4 || *(_DWORD *)(v7 + 4408) <= a4)
      {
        v10 = __si_assert_copy_extra(0);
        v11 = v10;
        v12 = "";
        if (v10)
          v12 = v10;
        __message_assert("%s:%u: failed assertion '%s' %s ", "storage.c", 1530, "position && position < inMap->count", v12);
        free(v11);
        if (__valid_fs(-1))
          v13 = 2989;
        else
          v13 = 3072;
        *(_DWORD *)v13 = -559038737;
        abort();
      }
      v8 = storageResolvePtr(v7, 4 * a4, 4uLL, 1);
      a4 = *(_QWORD *)storageResolvePtr(*(_QWORD *)(a1 + 40), 8 * *(unsigned int *)v8, 8uLL, 1);
    }
  }
  if (directoryStoreMakePathWithPostingsOffset(*(_QWORD *)(a1 + 48), a2, a3, a4, *(_QWORD *)(a1 + 56))
    && !**(_DWORD **)(a1 + 64))
  {
    return (*(uint64_t (**)(_QWORD))(a1 + 88))(*(_QWORD *)(a1 + 96));
  }
  else
  {
    return 1;
  }
}

void subvertForwardDirectoryStore(_QWORD *a1, uint64_t a2)
{
  char *v4;
  char *v5;
  char *v6;
  char *sibling_protected;
  char *v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  const char *v13;
  uint64_t v14;
  char v15[1024];
  char v16[1024];
  char v17[1024];
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  bzero(v17, 0x400uLL);
  v4 = fd_name(a1[28], v17, 0x400uLL);
  bzero(v16, 0x400uLL);
  v5 = fd_name(a1[28], v16, 0x400uLL);
  v6 = v5;
  if (v5)
  {
    strlcat(v5, ".shadow", 0x400uLL);
    sibling_protected = (char *)fd_create_sibling_protected(a1[28], v6, 0, 0);
    if (sibling_protected)
    {
      v8 = sibling_protected;
      _fd_unlink_with_origin((uint64_t)sibling_protected, 0);
      fd_release(v8);
    }
  }
  _fd_unlink_with_origin(a1[28], 0);
  freeForwardDirectoryStore(a1);
  if (strstr(v6, ".shadow.shadow"))
  {
    v11 = __si_assert_copy_extra(0);
    v12 = v11;
    v13 = "";
    if (v11)
      v13 = v11;
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 3223, "0==strstr(shadowpathPtr, \".shadow.shadow\")", v13);
    free(v12);
    if (__valid_fs(-1))
      v14 = 2989;
    else
      v14 = 3072;
    *(_DWORD *)v14 = -559038737;
    abort();
  }
  bzero(v15, 0x400uLL);
  v9 = fd_name(*(_QWORD *)(a2 + 224), v15, 0x400uLL);
  strlcat(v9, ".shadow", 0x400uLL);
  v10 = (char *)fd_create_sibling_protected(*(_QWORD *)(a2 + 224), v9, 0, 0);
  fd_rename(*(_QWORD *)(a2 + 224), v4);
  if (v10)
  {
    fd_rename((uint64_t)v10, v6);
    fd_release(v10);
  }
}

uint64_t unlinkDirectoryStore(const char *a1)
{
  char __str[1024];
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  bzero(__str, 0x400uLL);
  snprintf(__str, 0x400uLL, "%s%s", a1, "directoryStoreFile");
  return unlink(__str);
}

uint64_t unlinkDirectoryStoreShadow(const char *a1)
{
  char __str[1024];
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  bzero(__str, 0x400uLL);
  snprintf(__str, 0x400uLL, "%s%s.shadow", a1, "directoryStoreFile");
  return unlink(__str);
}

int64_t directoryStoreGetParent(uint64_t a1, unint64_t a2)
{
  int v4;
  uint64_t v5;
  int32_t v6;
  unint64_t v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  void (*v13)(_QWORD);
  int v14;
  NSObject *v15;
  int64_t v16;
  int v17;
  NSObject *v18;
  os_log_type_t v19;
  int64_t *ItemOffset;
  int64_t v21;
  uint64_t v22;
  uint64_t v23;
  void (*v24)(_QWORD);
  unsigned int v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  uint64_t v30;
  unsigned int *v31;
  uint64_t v32;
  uint8_t buf[4];
  const char *v34;
  __int16 v35;
  int v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v4 = setCrashStateTarget(2);
  v5 = a1 + 4416;
  db_read_lock(a1 + 4416);
  v30 = 0;
  v31 = 0;
  v32 = 0;
  storage_reader_init(a1, (uint64_t)&v30);
  if ((_BYTE)v32)
  {
    v6 = OSAtomicIncrement32((int32_t *)exceptionSequenceNum);
    v7 = setThreadIdAndInfo(-1, sStorageReaderExceptionCallbacks, (uint64_t)&v30, 0, v6);
    v28 = HIDWORD(v7);
    v29 = v7;
    v26 = v9;
    v27 = v8;
    v10 = *(_QWORD *)&threadData[18 * v7 + 2];
    v11 = v10 + 320 * HIDWORD(v7);
    v12 = *(_DWORD *)(v11 + 312);
    v13 = *(void (**)(_QWORD))(v11 + 224);
    if (v13)
      v13(*(_QWORD *)(v10 + 320 * HIDWORD(v7) + 288));
    if (_setjmp((int *)v11))
    {
      v14 = *__error();
      v15 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        v34 = "directoryStoreGetParent";
        v35 = 1024;
        v36 = 3381;
        _os_log_error_impl(&dword_1B8270000, v15, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
      }
      *__error() = v14;
      *(_DWORD *)(v11 + 312) = v12;
      CIOnThreadCleanUpReset(v26);
      dropThreadId(v29, 1, v6);
      CICleanUpReset(v29, v27);
      v16 = 0;
    }
    else
    {
      ItemOffset = directoryStoreReaderTreeFindItemOffset(&v30, 0x440uLL, a2, 0);
      if (ItemOffset)
        v21 = ItemOffset[1];
      else
        v21 = 0;
      v22 = *(_QWORD *)&threadData[18 * v29 + 2];
      v23 = v22 + 320 * v28;
      *(_DWORD *)(v23 + 312) = v12;
      v24 = *(void (**)(_QWORD))(v23 + 232);
      if (v24)
        v24(*(_QWORD *)(v22 + 320 * v28 + 288));
      dropThreadId(v29, 0, v6);
      v16 = v21;
    }
  }
  else
  {
    v17 = *__error();
    v18 = _SILogForLogForCategory(0);
    v19 = 2 * (gSILogLevels[0] < 4);
    if (os_log_type_enabled(v18, v19))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1B8270000, v18, v19, "Skipping because index is shut down", buf, 2u);
    }
    v16 = 0;
    *__error() = v17;
  }
  db_read_unlock(v5);
  if (v31)
  {
    _release_read_window(&availableReaders, v31);
    v31 = 0;
  }
  setCrashStateTarget(v4);
  return v16;
}

uint64_t directoryStoreGetPath(uint64_t a1, unint64_t a2, uint64_t a3)
{
  int v6;
  uint64_t v7;
  int32_t v8;
  unint64_t v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  void (*v15)(_QWORD);
  int v16;
  NSObject *v17;
  uint64_t v18;
  int v19;
  NSObject *v20;
  os_log_type_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  int64_t *ItemOffset;
  int64_t v27;
  uint64_t v28;
  uint64_t v29;
  void (*v30)(_QWORD);
  unsigned int v32;
  unsigned int v33;
  unsigned int v34;
  unsigned int v35;
  uint64_t v36;
  unsigned int *v37;
  uint64_t v38;
  uint8_t buf[4];
  const char *v40;
  __int16 v41;
  int v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  v6 = setCrashStateTarget(2);
  v7 = a1 + 4416;
  db_read_lock(a1 + 4416);
  v36 = 0;
  v37 = 0;
  v38 = 0;
  storage_reader_init(a1, (uint64_t)&v36);
  if ((_BYTE)v38)
  {
    v8 = OSAtomicIncrement32((int32_t *)exceptionSequenceNum);
    v9 = setThreadIdAndInfo(-1, sStorageReaderExceptionCallbacks, (uint64_t)&v36, 0, v8);
    v34 = HIDWORD(v9);
    v35 = v9;
    v32 = v11;
    v33 = v10;
    v12 = *(_QWORD *)&threadData[18 * v9 + 2];
    v13 = v12 + 320 * HIDWORD(v9);
    v14 = *(_DWORD *)(v13 + 312);
    v15 = *(void (**)(_QWORD))(v13 + 224);
    if (v15)
      v15(*(_QWORD *)(v12 + 320 * HIDWORD(v9) + 288));
    if (_setjmp((int *)v13))
    {
      v16 = *__error();
      v17 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        v40 = "directoryStoreGetPath";
        v41 = 1024;
        v42 = 3409;
        _os_log_error_impl(&dword_1B8270000, v17, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
      }
      *__error() = v16;
      *(_DWORD *)(v13 + 312) = v14;
      CIOnThreadCleanUpReset(v32);
      dropThreadId(v35, 1, v8);
      CICleanUpReset(v35, v33);
      v18 = 0;
    }
    else
    {
      if (a2 == 2)
      {
        v22 = 0;
      }
      else
      {
        v23 = 0;
        v24 = a2;
        do
        {
          v25 = v23;
          ItemOffset = directoryStoreReaderTreeFindItemOffset(&v36, 0x440uLL, v24, 0);
          if (!ItemOffset)
            break;
          v27 = ItemOffset[1];
          if (!v27)
            break;
          v24 = ItemOffset[1];
          v23 = v25 + 1;
          *(_QWORD *)(a3 + 8 * v25++) = v27;
        }
        while (v27 != 2);
        v22 = v25;
      }
      v28 = *(_QWORD *)&threadData[18 * v35 + 2];
      v29 = v28 + 320 * v34;
      *(_DWORD *)(v29 + 312) = v14;
      v30 = *(void (**)(_QWORD))(v29 + 232);
      if (v30)
        v30(*(_QWORD *)(v28 + 320 * v34 + 288));
      dropThreadId(v35, 0, v8);
      v18 = v22;
    }
  }
  else
  {
    v19 = *__error();
    v20 = _SILogForLogForCategory(0);
    v21 = 2 * (gSILogLevels[0] < 4);
    if (os_log_type_enabled(v20, v21))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1B8270000, v20, v21, "Skipping because index is shut down", buf, 2u);
    }
    v18 = 0;
    *__error() = v19;
  }
  db_read_unlock(v7);
  if (v37)
  {
    _release_read_window(&availableReaders, v37);
    v37 = 0;
  }
  setCrashStateTarget(v6);
  return v18;
}

int64_t directoryStoreWriterGetParent(uint64_t a1, unint64_t a2)
{
  int v4;
  int64_t v5;
  int32_t v6;
  uint64_t v7;
  int v8;
  unint64_t v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  void (*v15)(_QWORD);
  int v16;
  NSObject *v17;
  int64_t Parent;
  uint64_t v19;
  uint64_t v20;
  void (*v21)(_QWORD);
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  unsigned int v26;
  uint8_t buf[4];
  const char *v28;
  __int16 v29;
  int v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v4 = setCrashStateTarget(2);
  _db_write_lock(a1 + 4416);
  v5 = 0;
  if (storageResolvePtr(a1, 0, 1uLL, 1))
  {
    v6 = OSAtomicIncrement32((int32_t *)exceptionSequenceNum);
    v7 = *(_QWORD *)(a1 + 216);
    if (v7)
      v8 = *(_DWORD *)(v7 + 44);
    else
      v8 = -1;
    v9 = setThreadIdAndInfo(v8, sStorageExceptionCallbacks, a1, 1, v6);
    v25 = HIDWORD(v9);
    v26 = v9;
    v23 = v11;
    v24 = v10;
    v12 = *(_QWORD *)&threadData[18 * v9 + 2];
    v13 = v12 + 320 * HIDWORD(v9);
    v14 = *(_DWORD *)(v13 + 312);
    v15 = *(void (**)(_QWORD))(v13 + 224);
    if (v15)
      v15(*(_QWORD *)(v12 + 320 * HIDWORD(v9) + 288));
    if (_setjmp((int *)v13))
    {
      v16 = *__error();
      v17 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        v28 = "directoryStoreWriterGetParent";
        v29 = 1024;
        v30 = 3430;
        _os_log_error_impl(&dword_1B8270000, v17, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
      }
      *__error() = v16;
      *(_DWORD *)(v13 + 312) = v14;
      CIOnThreadCleanUpReset(v23);
      dropThreadId(v26, 1, v6);
      CICleanUpReset(v26, v24);
      v5 = 0;
    }
    else
    {
      Parent = _directoryStoreGetParent(a1, a2);
      v19 = *(_QWORD *)&threadData[18 * v26 + 2];
      v20 = v19 + 320 * v25;
      *(_DWORD *)(v20 + 312) = v14;
      v21 = *(void (**)(_QWORD))(v20 + 232);
      if (v21)
        v21(*(_QWORD *)(v19 + 320 * v25 + 288));
      dropThreadId(v26, 0, v6);
      v5 = Parent;
    }
  }
  db_write_unlock(a1 + 4416);
  setCrashStateTarget(v4);
  return v5;
}

int64_t _directoryStoreGetParent(uint64_t a1, unint64_t a2)
{
  int64_t *ItemOffset;
  int64_t result;
  BOOL v4;
  int v5;
  NSObject *v6;
  const char *v7;
  int *v8;
  _OWORD v9[6];
  __int128 v10;
  uint64_t v11;
  uint8_t buf[4];
  uint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v11 = 0;
  v10 = 0u;
  memset(v9, 0, sizeof(v9));
  ItemOffset = directoryStoreTreeFindItemOffset(a1, 0x440uLL, a2, (uint64_t)v9, 0, 0, 0);
  if (ItemOffset)
  {
    result = ItemOffset[1];
    if (result)
      v4 = 1;
    else
      v4 = dword_1EF19FCA4 < 5;
    if (!v4)
    {
      v5 = *__error();
      v6 = _SILogForLogForCategory(6);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134217984;
        v13 = *((_QWORD *)&v10 + 1);
        v7 = "leafPageOffset: %llx";
LABEL_13:
        _os_log_impl(&dword_1B8270000, v6, OS_LOG_TYPE_DEFAULT, v7, buf, 0xCu);
        goto LABEL_14;
      }
      goto LABEL_14;
    }
  }
  else
  {
    if (dword_1EF19FCA4 >= 5)
    {
      v5 = *__error();
      v6 = _SILogForLogForCategory(6);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134217984;
        v13 = *((_QWORD *)&v10 + 1);
        v7 = "_directoryStoreGetParent failed. leafPageOffset: %llx";
        goto LABEL_13;
      }
LABEL_14:
      v8 = __error();
      result = 0;
      *v8 = v5;
      return result;
    }
    return 0;
  }
  return result;
}

uint64_t dirtyStore(uint64_t a1)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t result;

  if (*(_DWORD *)(a1 + 4408))
  {
    v2 = *(_QWORD *)(a1 + 4632);
    if (v2)
      (*(void (**)(void))(v2 + 16))();
    v3 = (unint64_t)storageResolvePtr(a1, 0x40uLL, 0x400uLL, 1);
    *(_DWORD *)(v3 + 4) = 0;
    dirtyStoragePage(a1, v3);
    msync((void *)(v3 & ~*MEMORY[0x1E0C85AC0]), 0x1000uLL, 16);
    result = fd_sync(*(_QWORD *)(a1 + 216), 1);
    *(_DWORD *)(a1 + 4408) = 0;
  }
  else
  {
    if (*(_QWORD *)(a1 + 232) <= 0x43FuLL)
      storageAllocOffsetFromEnd(a1, *(_DWORD *)(a1 + 224) + 960);
    result = (uint64_t)storageResolvePtr(a1, 0x40uLL, 0x400uLL, 1);
    *(_DWORD *)(result + 4) = 0;
  }
  return result;
}

uint64_t directoryStoreSetParentForMove(uint64_t a1, unint64_t a2, uint64_t a3)
{
  int v6;
  int v7;
  uint64_t v8;
  int32_t v9;
  uint64_t v10;
  int v11;
  unint64_t v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  void (*v18)(_QWORD);
  int v19;
  NSObject *v20;
  int64_t *ItemOffset;
  unsigned __int16 *PageInner;
  int8x8_t v23;
  unsigned __int16 *v24;
  unsigned __int16 *v25;
  uint64_t v26;
  char *v27;
  char *v28;
  const char *v29;
  uint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unsigned __int16 *v33;
  uint64_t v34;
  uint64_t v35;
  void (*v36)(_QWORD);
  char *v38;
  char *v39;
  const char *v40;
  uint64_t v41;
  int v42;
  NSObject *v43;
  unsigned int v44;
  unsigned int v45;
  unsigned int v46;
  unsigned int v47;
  _OWORD v48[6];
  __int128 v49;
  uint64_t v50;
  unsigned int v51;
  uint8_t buf[4];
  const char *v53;
  __int16 v54;
  uint64_t v55;
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  v51 = 0;
  v50 = 0;
  v49 = 0u;
  memset(v48, 0, sizeof(v48));
  v6 = setCrashStateTarget(2);
  if (!a3)
  {
    v38 = __si_assert_copy_extra(*(_DWORD **)(a1 + 216));
    v39 = v38;
    v40 = "";
    if (v38)
      v40 = v38;
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 3482, "parent", v40);
    free(v39);
    if (__valid_fsp(*(_DWORD **)(a1 + 216)))
      v41 = 2989;
    else
      v41 = 3072;
    *(_DWORD *)v41 = -559038737;
    abort();
  }
  v7 = v6;
  v8 = a1 + 4416;
  _db_write_lock(a1 + 4416);
  if (storageResolvePtr(a1, 0, 1uLL, 1))
  {
    v9 = OSAtomicIncrement32((int32_t *)exceptionSequenceNum);
    v10 = *(_QWORD *)(a1 + 216);
    if (v10)
      v11 = *(_DWORD *)(v10 + 44);
    else
      v11 = -1;
    v12 = setThreadIdAndInfo(v11, sStorageExceptionCallbacks, a1, 1, v9);
    v46 = HIDWORD(v12);
    v47 = v12;
    v44 = v14;
    v45 = v13;
    v15 = *(_QWORD *)&threadData[18 * v12 + 2];
    v16 = v15 + 320 * HIDWORD(v12);
    v17 = *(_DWORD *)(v16 + 312);
    v18 = *(void (**)(_QWORD))(v16 + 224);
    if (v18)
      v18(*(_QWORD *)(v15 + 320 * HIDWORD(v12) + 288));
    if (_setjmp((int *)v16))
    {
      v19 = *__error();
      v20 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        v53 = "directoryStoreSetParentForMove";
        v54 = 1024;
        LODWORD(v55) = 3514;
        _os_log_error_impl(&dword_1B8270000, v20, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
      }
      *__error() = v19;
      *(_DWORD *)(v16 + 312) = v17;
      CIOnThreadCleanUpReset(v44);
      dropThreadId(v47, 1, v9);
      CICleanUpReset(v47, v45);
    }
    else
    {
      if (dword_1EF19FCA4 >= 5)
      {
        v42 = *__error();
        v43 = _SILogForLogForCategory(6);
        if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 134218240;
          v53 = (const char *)a2;
          v54 = 2048;
          v55 = a3;
          _os_log_impl(&dword_1B8270000, v43, OS_LOG_TYPE_DEFAULT, "Move %llx/%llx", buf, 0x16u);
        }
        *__error() = v42;
      }
      dirtyStore(a1);
      ItemOffset = directoryStoreTreeFindItemOffset(a1, 0x440uLL, a2, (uint64_t)v48, &v51, 0, 1);
      PageInner = (unsigned __int16 *)_directoryStoreGetPageInner(a1, *((unint64_t *)&v49 + 1), (BOOL *)buf);
      v24 = PageInner;
      v25 = PageInner;
      if (ItemOffset)
      {
        if (*ItemOffset != a2 || (v26 = v51, &PageInner[8 * v51 + 4] != (unsigned __int16 *)ItemOffset))
        {
          v27 = __si_assert_copy_extra(*(_DWORD **)(a1 + 216));
          v28 = v27;
          v29 = "";
          if (v27)
            v29 = v27;
          __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 3503, "(getStoreOID(element->fileId)==item && &page->items[slot]==element)", v29);
          free(v28);
          if (__valid_fsp(*(_DWORD **)(a1 + 216)))
            v30 = 2989;
          else
            v30 = 3072;
          *(_DWORD *)v30 = -559038737;
          abort();
        }
      }
      else
      {
        v31 = v51;
        if (*(_QWORD *)&PageInner[8 * v51 + 4] >= 2uLL)
        {
          directoryStorePageGetSize(PageInner, v23);
          shiftEntries((uint64_t)v25, v31, v32);
          v31 = v51;
        }
        *v25 += 16;
        v26 = v31;
      }
      v33 = &v24[8 * v26];
      *((_QWORD *)v33 + 1) = a2;
      *((_QWORD *)v33 + 2) = a3;
      dirtyStoragePage(a1, (unint64_t)v25);
      v34 = *(_QWORD *)&threadData[18 * v47 + 2];
      v35 = v34 + 320 * v46;
      *(_DWORD *)(v35 + 312) = v17;
      v36 = *(void (**)(_QWORD))(v35 + 232);
      if (v36)
        v36(*(_QWORD *)(v34 + 320 * v46 + 288));
      dropThreadId(v47, 0, v9);
    }
  }
  db_write_unlock(v8);
  return setCrashStateTarget(v7);
}

int64_t _directoryStoreSetParent(uint64_t a1, unint64_t a2, uint64_t a3)
{
  int64_t *ItemOffset;
  unsigned __int16 *PageInner;
  int8x8_t v8;
  unsigned __int16 *v9;
  char *v10;
  char *v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unsigned __int16 *v16;
  int64_t result;
  char *v18;
  char *v19;
  const char *v20;
  char *v21;
  const char *v22;
  uint64_t v23;
  int v24;
  NSObject *v25;
  char *v26;
  char *v27;
  const char *v28;
  _OWORD v29[6];
  __int128 v30;
  uint64_t v31;
  unsigned int v32;
  uint8_t buf[4];
  unint64_t v34;
  __int16 v35;
  uint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v32 = 0;
  v31 = 0;
  v30 = 0u;
  memset(v29, 0, sizeof(v29));
  if (!a3)
  {
    v18 = __si_assert_copy_extra(*(_DWORD **)(a1 + 216));
    v19 = v18;
    v20 = "";
    if (v18)
      v20 = v18;
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 3531, "parent", v20);
LABEL_22:
    free(v19);
    if (!__valid_fsp(*(_DWORD **)(a1 + 216)))
    {
LABEL_30:
      v23 = 3072;
LABEL_31:
      *(_DWORD *)v23 = -559038737;
      abort();
    }
LABEL_23:
    v23 = 2989;
    goto LABEL_31;
  }
  if (a2 == a3)
  {
    v21 = __si_assert_copy_extra(*(_DWORD **)(a1 + 216));
    v19 = v21;
    v22 = "";
    if (v21)
      v22 = v21;
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 3532, "item!=parent", v22);
    goto LABEL_22;
  }
  dirtyStore(a1);
  if (dword_1EF19FCA4 >= 5)
  {
    v24 = *__error();
    v25 = _SILogForLogForCategory(6);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134218240;
      v34 = a2;
      v35 = 2048;
      v36 = a3;
      _os_log_impl(&dword_1B8270000, v25, OS_LOG_TYPE_DEFAULT, "Set %llx/%llx", buf, 0x16u);
    }
    *__error() = v24;
  }
  ItemOffset = directoryStoreTreeFindItemOffset(a1, 0x440uLL, a2, (uint64_t)v29, &v32, 0, 1);
  PageInner = (unsigned __int16 *)_directoryStoreGetPageInner(a1, *((unint64_t *)&v30 + 1), (BOOL *)buf);
  v9 = PageInner;
  if (ItemOffset)
  {
    if (*ItemOffset != a2 || ItemOffset[1] != a3)
    {
      v10 = __si_assert_copy_extra(*(_DWORD **)(a1 + 216));
      v11 = v10;
      v12 = "";
      if (v10)
        v12 = v10;
      __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 3539, "(element==0 || (getStoreOID(element->fileId)==item && getOffset(element->childPage) == (offset_t)parent))", v12);
      free(v11);
      if (__valid_fsp(*(_DWORD **)(a1 + 216)))
        v13 = 2989;
      else
        v13 = 3072;
      *(_DWORD *)v13 = -559038737;
      abort();
    }
  }
  else
  {
    v14 = v32;
    if (*(_QWORD *)&PageInner[8 * v32 + 4] >= 2uLL)
    {
      directoryStorePageGetSize(PageInner, v8);
      shiftEntries((uint64_t)v9, v14, v15);
    }
    *v9 += 16;
  }
  v16 = &v9[8 * v32];
  *((_QWORD *)v16 + 1) = a2;
  *((_QWORD *)v16 + 2) = a3;
  dirtyStoragePage(a1, (unint64_t)v9);
  result = _directoryStoreGetParent(a1, a2);
  if (result != a3)
  {
    v26 = __si_assert_copy_extra(0);
    v27 = v26;
    v28 = "";
    if (v26)
      v28 = v26;
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 3557, "parent == _directoryStoreGetParent(store, item)", v28);
    free(v27);
    if (!__valid_fs(-1))
      goto LABEL_30;
    goto LABEL_23;
  }
  return result;
}

uint64_t directoryStoreEnsurePath(uint64_t a1, unint64_t a2, uint64_t *a3, int a4, uint64_t a5, _BYTE *a6, _QWORD *a7, unsigned int *a8)
{
  int v16;
  int v17;
  int32_t v18;
  uint64_t v19;
  int v20;
  unsigned int v22;
  BOOL v23;
  uint64_t v24;
  unint64_t v25;
  unsigned int v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  void (*v30)(_QWORD);
  _DWORD *v31;
  int v32;
  NSObject *v33;
  unsigned int v34;
  int v35;
  int32_t v36;
  unint64_t v37;
  unsigned int v38;
  unsigned int v39;
  uint64_t v40;
  uint64_t v41;
  void (*v42)(_QWORD);
  _DWORD *v43;
  int v44;
  NSObject *v45;
  int v46;
  int v47;
  unint64_t v48;
  int v49;
  unint64_t v50;
  int64_t Parent;
  int v52;
  unint64_t v53;
  int v54;
  int v55;
  unint64_t v56;
  int v57;
  int v58;
  NSObject *v59;
  int v60;
  uint64_t v61;
  uint64_t *v62;
  unint64_t v63;
  unint64_t v64;
  uint64_t *v65;
  uint64_t *v66;
  unint64_t v67;
  int v68;
  int v69;
  int v70;
  int v71;
  uint64_t v72;
  uint64_t v73;
  void (*v74)(_QWORD);
  uint64_t v75;
  uint64_t v76;
  void (*v77)(_QWORD);
  BOOL v78;
  uint64_t v79;
  char *v80;
  char *v81;
  const char *v82;
  char *v83;
  char *v84;
  uint64_t v85;
  char *v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  char *v94;
  char *v95;
  const char *v96;
  uint64_t v97;
  _QWORD *v98;
  int v99;
  int v100;
  int v101;
  int v102;
  int v103;
  unsigned int *v104;
  unsigned int v105;
  unsigned int v106;
  unsigned int v107;
  unsigned int v108;
  unsigned int v109;
  unsigned int v110;
  unsigned int v111;
  unsigned int v112;
  char v113;
  uint8_t buf[4];
  const char *v115;
  __int16 v116;
  int v117;
  __int16 v118;
  unint64_t v119;
  __int16 v120;
  uint64_t v121;
  uint64_t v122;

  v122 = *MEMORY[0x1E0C80C00];
  v16 = setCrashStateTarget(2);
  *a6 = 0;
  if (!a2)
    return 0;
  v17 = v16;
  _db_write_lock(a1 + 4416);
  v113 = 0;
  v103 = v17;
  if (!storageResolvePtr(a1, 0, 1uLL, 1))
  {
    v22 = 0;
    v23 = 0;
    v24 = a1 + 4416;
    goto LABEL_70;
  }
  v98 = a7;
  v18 = OSAtomicIncrement32((int32_t *)exceptionSequenceNum);
  v19 = *(_QWORD *)(a1 + 216);
  if (v19)
    v20 = *(_DWORD *)(v19 + 44);
  else
    v20 = -1;
  v25 = setThreadIdAndInfo(v20, sStorageExceptionCallbacks, a1, 1, v18);
  v111 = HIDWORD(v25);
  v112 = v25;
  v109 = v27;
  v110 = v26;
  v28 = *(_QWORD *)&threadData[18 * v25 + 2];
  v29 = v28 + 320 * HIDWORD(v25);
  v101 = *(_DWORD *)(v29 + 312);
  v30 = *(void (**)(_QWORD))(v29 + 224);
  if (v30)
    v30(*(_QWORD *)(v28 + 320 * HIDWORD(v25) + 288));
  v102 = v18;
  if (_setjmp((int *)v29))
  {
    v31 = (_DWORD *)(v29 + 312);
    v32 = *__error();
    v33 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v115 = "directoryStoreEnsurePath";
      v116 = 1024;
      v117 = 3657;
      _os_log_error_impl(&dword_1B8270000, v33, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
    }
    *__error() = v32;
    *v31 = v101;
    CIOnThreadCleanUpReset(v109);
    dropThreadId(v112, 1, v102);
    CICleanUpReset(v112, v110);
    v34 = 0;
    v35 = 0;
    v24 = a1 + 4416;
    goto LABEL_69;
  }
  dirtyStore(a1);
  v36 = OSAtomicIncrement32((int32_t *)exceptionSequenceNum);
  v37 = setThreadIdAndInfo(-1, sAssertExceptionCallbacks, 0, 0, v36);
  v107 = HIDWORD(v37);
  v108 = v37;
  v105 = v39;
  v106 = v38;
  v40 = *(_QWORD *)&threadData[18 * v37 + 2];
  v41 = v40 + 320 * HIDWORD(v37);
  v99 = *(_DWORD *)(v41 + 312);
  v42 = *(void (**)(_QWORD))(v41 + 224);
  if (v42)
    v42(*(_QWORD *)(v40 + 320 * HIDWORD(v37) + 288));
  v100 = v36;
  if (_setjmp((int *)v41))
  {
    v43 = (_DWORD *)(v41 + 312);
    v44 = *__error();
    v45 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v115 = "directoryStoreEnsurePath";
      v116 = 1024;
      v117 = 3656;
      _os_log_error_impl(&dword_1B8270000, v45, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
    }
    *__error() = v44;
    *v43 = v99;
    CIOnThreadCleanUpReset(v105);
    dropThreadId(v108, 1, v100);
    CICleanUpReset(v108, v106);
    v34 = 0;
    v35 = 0;
    v24 = a1 + 4416;
    v47 = v101;
    v46 = v102;
    goto LABEL_66;
  }
  v104 = a8;
  v48 = 0;
  v49 = -1;
  v50 = a2;
  while (1)
  {
    if (v50 == 2)
    {
      if (v49 == -1)
      {
        if (!(_DWORD)v48 || *(uint64_t *)((char *)a3 + ((uint64_t)((v48 << 32) - 0x100000000) >> 29)) != 2)
        {
          v49 = v48 + 1;
          a3[(int)v48] = 2;
          v57 = v48 + 1;
LABEL_46:
          a8 = v104;
          if (v49 < 1)
          {
            v64 = a2;
          }
          else
          {
            dirtyStore(a1);
            v61 = v49;
            v62 = a3;
            v63 = a2;
            do
            {
              v64 = v63;
              v65 = v62;
              _directoryStoreSetParent(a1, v63, *v62);
              v62 = v65 + 1;
              if (*v65 == 2)
                break;
              if (*v65 == a2)
              {
                v94 = __si_assert_copy_extra(*(_DWORD **)(a1 + 216));
                v95 = v94;
                v96 = "";
                if (v94)
                  v96 = v94;
                __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 3633, "item!=inItem", v96);
                free(v95);
                if (__valid_fsp(*(_DWORD **)(a1 + 216)))
                  v97 = 2989;
                else
                  v97 = 3072;
                *(_DWORD *)v97 = -559038737;
                abort();
              }
              v64 = *v65;
              v63 = *v65;
              --v61;
            }
            while (v61);
          }
          v66 = &a3[v49];
          if (v57 && v49 == v57)
          {
            v67 = *(v66 - 1);
            v68 = v49;
            if (v67 != 2)
            {
              _directoryStoreSetParent(a1, v67, 2);
              v68 = v49 + 1;
              a3[v49] = 2;
            }
          }
          else
          {
            v68 = v57;
            if (!v57 && !v49 && v64 != 2)
            {
              _directoryStoreSetParent(a1, v64, 2);
              v60 = 0;
              *a3 = 2;
              v55 = 1;
LABEL_61:
              v24 = a1 + 4416;
              goto LABEL_62;
            }
          }
          v69 = v68;
          v60 = 0;
          if (v49)
            *v98 = *(v66 - 1);
          v55 = v69;
          goto LABEL_61;
        }
        v49 = v48;
      }
      v57 = v48;
      goto LABEL_46;
    }
    Parent = _directoryStoreGetParent(a1, v50);
    if (Parent)
    {
      if (v48 < 0x200)
      {
        if (v50 != Parent)
        {
          a3[v48] = Parent;
          if (v49 == -1)
            v52 = v48;
          else
            v52 = v49;
          v53 = Parent;
          goto LABEL_33;
        }
        v55 = v48;
        v56 = v50;
LABEL_39:
        v58 = *__error();
        v59 = _SILogForLogForCategory(6);
        a8 = v104;
        v24 = a1 + 4416;
        if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
        {
          v79 = *a3;
          *(_DWORD *)buf = 136315906;
          v115 = "directoryStoreEnsurePath";
          v116 = 1024;
          v117 = 3648;
          v118 = 2048;
          v119 = v56;
          v120 = 2048;
          v121 = v79;
          _os_log_error_impl(&dword_1B8270000, v59, OS_LOG_TYPE_ERROR, "%s:%d: Move would loop in reverse directory store, skipping %lld to %lld", buf, 0x26u);
        }
        *__error() = v58;
        v60 = 1;
LABEL_62:
        v47 = v101;
        v46 = v102;
        v70 = v99;
        v71 = v100;
        v34 = v55;
        v113 = 1;
        v35 = v60;
        goto LABEL_63;
      }
      v80 = __si_assert_copy_extra(*(_DWORD **)(a1 + 216));
      v81 = v80;
      v82 = "";
      if (v80)
        v82 = v80;
      __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 3604, "depth<512", v82);
      v83 = v81;
LABEL_84:
      free(v83);
      if (__valid_fsp(*(_DWORD **)(a1 + 216)))
        v85 = 2989;
      else
        v85 = 3072;
      *(_DWORD *)v85 = -559038737;
      abort();
    }
    if ((uint64_t)v48 >= a4)
    {
      v84 = __si_assert_copy_extra(*(_DWORD **)(a1 + 216));
      __message_assert("%s:%u: failed assertion '%s' %s %d, %d, %d, %llx", "FileTree.c");
LABEL_83:
      v83 = v84;
      goto LABEL_84;
    }
    v53 = a3[v48];
    if (v50 == v53)
    {
      v84 = __si_assert_copy_extra(*(_DWORD **)(a1 + 216));
      __message_assert("%s:%u: failed assertion '%s' %s %d, %d, %d, %llx, %llx", "FileTree.c", 3596);
      goto LABEL_83;
    }
    if (v49 != -1)
      break;
    v52 = -1;
LABEL_33:
    v54 = v48 + 1;
    if (v53 != a2)
    {
      ++v48;
      v49 = v52;
      v50 = v53;
      if (v53 != a5)
        continue;
    }
    v55 = v54;
    v56 = v53;
    goto LABEL_39;
  }
  v86 = __si_assert_copy_extra(*(_DWORD **)(a1 + 216));
  si_analytics_log_3349((uint64_t)v86, v87, v88, v89, v90, v91, v92, v93, (char)"FileTree.c");
  free(v86);
  v35 = 0;
  v34 = v48;
  a8 = v104;
  v24 = a1 + 4416;
  v47 = v101;
  v46 = v102;
  v70 = v99;
  v71 = v100;
LABEL_63:
  *a6 = v35;
  v72 = *(_QWORD *)&threadData[18 * v108 + 2];
  v73 = v72 + 320 * v107;
  *(_DWORD *)(v73 + 312) = v70;
  v74 = *(void (**)(_QWORD))(v73 + 232);
  if (v74)
    v74(*(_QWORD *)(v72 + 320 * v107 + 288));
  dropThreadId(v108, 0, v71);
LABEL_66:
  v75 = *(_QWORD *)&threadData[18 * v112 + 2];
  v76 = v75 + 320 * v111;
  *(_DWORD *)(v76 + 312) = v47;
  v77 = *(void (**)(_QWORD))(v76 + 232);
  if (v77)
    v77(*(_QWORD *)(v75 + 320 * v111 + 288));
  dropThreadId(v112, 0, v46);
LABEL_69:
  v23 = v35 != 0;
  v22 = v34;
LABEL_70:
  v78 = v23;
  db_write_unlock(v24);
  *a8 = v22;
  setCrashStateTarget(v103);
  if (v78)
    return 0xFFFFFFFFLL;
  if (v113)
    return v22;
  return 0xFFFFFFFFLL;
}

void si_analytics_log_3349(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  xpc_object_t v9;
  xpc_object_t v10;
  char *string[2];
  xpc_object_t values;
  _BYTE keys[24];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  string[0] = 0;
  string[1] = &a9;
  vasprintf(string, "%s:%u: failure log '%s' %s %d, %d, %d", &a9);
  SISetCrashCStr(string[0]);
  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)keys = 136315138;
    *(char **)&keys[4] = string[0];
    _os_log_fault_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "%s", keys, 0xCu);
  }
  *(_QWORD *)keys = "crash_string";
  v9 = xpc_string_create(string[0]);
  values = v9;
  v10 = xpc_dictionary_create((const char *const *)keys, &values, 1uLL);
  analytics_send_event();
  xpc_release(v10);
  xpc_release(v9);
  free(string[0]);
}

uint64_t directoryStoreWriterGetPath(uint64_t a1, unint64_t a2, uint64_t a3)
{
  int v6;
  int32_t v7;
  uint64_t v8;
  int v9;
  unint64_t v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  void (*v16)(_QWORD);
  int v17;
  NSObject *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  int64_t Parent;
  uint64_t v25;
  uint64_t v26;
  void (*v27)(_QWORD);
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  unsigned int v32;
  uint8_t buf[4];
  const char *v34;
  __int16 v35;
  int v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v6 = setCrashStateTarget(2);
  _db_write_lock(a1 + 4416);
  if (!storageResolvePtr(a1, 0, 1uLL, 1))
  {
LABEL_11:
    v19 = 0;
    goto LABEL_21;
  }
  v7 = OSAtomicIncrement32((int32_t *)exceptionSequenceNum);
  v8 = *(_QWORD *)(a1 + 216);
  if (v8)
    v9 = *(_DWORD *)(v8 + 44);
  else
    v9 = -1;
  v10 = setThreadIdAndInfo(v9, sStorageExceptionCallbacks, a1, 1, v7);
  v31 = HIDWORD(v10);
  v32 = v10;
  v29 = v12;
  v30 = v11;
  v13 = *(_QWORD *)&threadData[18 * v10 + 2];
  v14 = v13 + 320 * HIDWORD(v10);
  v15 = *(_DWORD *)(v14 + 312);
  v16 = *(void (**)(_QWORD))(v14 + 224);
  if (v16)
    v16(*(_QWORD *)(v13 + 320 * HIDWORD(v10) + 288));
  if (_setjmp((int *)v14))
  {
    v17 = *__error();
    v18 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v34 = "directoryStoreWriterGetPath";
      v35 = 1024;
      v36 = 3681;
      _os_log_error_impl(&dword_1B8270000, v18, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
    }
    *__error() = v17;
    *(_DWORD *)(v14 + 312) = v15;
    CIOnThreadCleanUpReset(v29);
    dropThreadId(v32, 1, v7);
    CICleanUpReset(v32, v30);
    goto LABEL_11;
  }
  if (a2 == 2)
  {
    v20 = 0;
  }
  else
  {
    v21 = 0;
    v22 = a2;
    do
    {
      v23 = v21;
      Parent = _directoryStoreGetParent(a1, v22);
      if (!Parent)
        break;
      v22 = Parent;
      v21 = v23 + 1;
      *(_QWORD *)(a3 + 8 * v23++) = Parent;
    }
    while (Parent != 2);
    v20 = v23;
  }
  v25 = *(_QWORD *)&threadData[18 * v32 + 2];
  v26 = v25 + 320 * v31;
  *(_DWORD *)(v26 + 312) = v15;
  v27 = *(void (**)(_QWORD))(v26 + 232);
  if (v27)
    v27(*(_QWORD *)(v25 + 320 * v31 + 288));
  dropThreadId(v32, 0, v7);
  v19 = v20;
LABEL_21:
  db_write_unlock(a1 + 4416);
  setCrashStateTarget(v6);
  return v19;
}

BOOL reverseDirStoreInit(uint64_t a1, char *a2, int a3, char a4, void *aBlock)
{
  int32_t v9;
  uint64_t v10;
  int v11;
  uint8_t *v12;
  uint8x16_t v13;
  int8x16_t v14;
  int8x16_t v15;
  int8x16_t v16;
  uint8x16_t v17;
  uint64_t i;
  int8x16_t v19;
  char *v20;
  int8x16_t v21;
  int v22;
  NSObject *v23;
  unint64_t v24;
  int v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  void (*v30)(_QWORD);
  _DWORD *v31;
  int v32;
  NSObject *v33;
  unint64_t v34;
  char *v35;
  uint64_t v36;
  unsigned int v37;
  uint64_t v38;
  void (*v39)(_QWORD);
  char *v41;
  char *v42;
  const char *v43;
  uint64_t v44;
  uint8_t *v45;
  int v46;
  unsigned int v47;
  unsigned int v48;
  unsigned int v49;
  unsigned int v50;
  unsigned int v51;
  BOOL v52;
  uint8_t v53[4];
  const char *v54;
  __int16 v55;
  int v56;
  __int16 v57;
  _OWORD *v58;
  _OWORD v59[8];
  char v60;
  uint8_t buf[32];
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  uint64_t v72;
  int8x16x2_t v73;

  v72 = *MEMORY[0x1E0C80C00];
  v52 = 0;
  if (a3)
  {
    v52 = storageInit(a1, 0x10000, 0x40uLL, (uint64_t)a2, 1, 1, a4, 102, aBlock);
    if (v52)
    {
      v52 = 0;
      if (storageResolvePtr(a1, 0, 1uLL, 1))
      {
        v9 = OSAtomicIncrement32((int32_t *)exceptionSequenceNum);
        v10 = *(_QWORD *)(a1 + 216);
        if (v10)
          v11 = *(_DWORD *)(v10 + 44);
        else
          v11 = -1;
        v24 = setThreadIdAndInfo(v11, sStorageExceptionCallbacks, a1, 1, v9);
        *(_DWORD *)v53 = HIDWORD(v24);
        LODWORD(v59[0]) = v24;
        LODWORD(v45) = v25;
        v51 = v26;
        v27 = *(_QWORD *)&threadData[18 * v24 + 2];
        v28 = v27 + 320 * HIDWORD(v24);
        v29 = *(_DWORD *)(v28 + 312);
        v30 = *(void (**)(_QWORD))(v28 + 224);
        if (v30)
          v30(*(_QWORD *)(v27 + 320 * HIDWORD(v24) + 288));
        v50 = v59[0];
        v49 = *(_DWORD *)v53;
        v48 = v45;
        v47 = v51;
        if (_setjmp((int *)v28))
        {
          v31 = (_DWORD *)(v28 + 312);
          v32 = *__error();
          v33 = _SILogForLogForCategory(0);
          if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315394;
            *(_QWORD *)&buf[4] = "reverseDirStoreInit";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 3724;
            _os_log_error_impl(&dword_1B8270000, v33, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
          }
          *__error() = v32;
          *v31 = v29;
          CIOnThreadCleanUpReset(v47);
          dropThreadId(v50, 1, v9);
          CICleanUpReset(v50, v48);
        }
        else
        {
          v70 = 0u;
          v71 = 0u;
          v68 = 0u;
          v69 = 0u;
          v66 = 0u;
          v67 = 0u;
          v64 = 0u;
          v65 = 0u;
          v62 = 0u;
          v63 = 0u;
          memset(buf, 0, sizeof(buf));
          v46 = 0;
          v34 = storageAllocOffset(a1, 0x400u, (uint64_t)buf, &v46);
          if (v46)
            dirtyStorageOffsets(a1, (unint64_t *)buf, v46);
          if (v34)
          {
            v35 = storageResolvePtr(a1, v34, 0x400uLL, 1);
            bzero(v35, 0x400uLL);
            v35[2] = 4;
          }
          if (directoryStoreNewTreePage(a1, 0, 3720, 0) != 1088)
          {
            v41 = __si_assert_copy_extra(*(_DWORD **)(a1 + 216));
            v42 = v41;
            v43 = "";
            if (v41)
              v43 = v41;
            __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 3721, "getOffset(addr) == REVERSE_MAP_ROOT_OFFSET", v43);
            free(v42);
            if (__valid_fsp(*(_DWORD **)(a1 + 216)))
              v44 = 2989;
            else
              v44 = 3072;
            *(_DWORD *)v44 = -559038737;
            abort();
          }
          v52 = 1;
          v36 = *(_QWORD *)&threadData[18 * v50 + 2];
          v37 = v49;
          v38 = v36 + 320 * v49;
          *(_DWORD *)(v38 + 312) = v29;
          v39 = *(void (**)(_QWORD))(v38 + 232);
          if (v39)
            v39(*(_QWORD *)(v36 + 320 * v37 + 288));
          dropThreadId(v50, 0, v9);
        }
      }
    }
  }
  else
  {
    bzero(buf, 0x400uLL);
    v45 = buf;
    if (fd_pread(a2, buf, 0x400uLL, 72) == 1024)
    {
      v52 = storageHeaderRestore(a1, (char **)&v45);
      if (v52)
      {
        return storageInit(a1, 0x10000, 0x40uLL, (uint64_t)a2, 0, 1, a4, 102, aBlock);
      }
      else
      {
        v60 = 0;
        v12 = buf;
        v13.i64[0] = 0xA0A0A0A0A0A0A0A0;
        v13.i64[1] = 0xA0A0A0A0A0A0A0A0;
        v14.i64[0] = 0x3030303030303030;
        v14.i64[1] = 0x3030303030303030;
        v15.i64[0] = 0x3737373737373737;
        v15.i64[1] = 0x3737373737373737;
        v16.i64[0] = 0xF0F0F0F0F0F0F0FLL;
        v16.i64[1] = 0xF0F0F0F0F0F0F0FLL;
        memset(v59, 0, sizeof(v59));
        v17.i64[0] = 0xA0A0A0A0A0A0A0ALL;
        v17.i64[1] = 0xA0A0A0A0A0A0A0ALL;
        for (i = 0; i != 8; i += 2)
        {
          v19 = *(int8x16_t *)v12;
          v12 += 16;
          v20 = (char *)&v59[i];
          v73.val[0] = vbslq_s8((int8x16_t)vcgtq_u8(v13, (uint8x16_t)v19), (int8x16_t)vsraq_n_u8((uint8x16_t)v14, (uint8x16_t)v19, 4uLL), (int8x16_t)vsraq_n_u8((uint8x16_t)v15, (uint8x16_t)v19, 4uLL));
          v21 = vandq_s8(v19, v16);
          v73.val[1] = vbslq_s8((int8x16_t)vcgtq_u8(v17, (uint8x16_t)v21), vorrq_s8(v21, v14), vaddq_s8(v21, v15));
          vst2q_s8(v20, v73);
        }
        v22 = *__error();
        v23 = _SILogForLogForCategory(6);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)v53 = 136315650;
          v54 = "reverseDirStoreInit";
          v55 = 1024;
          v56 = 3742;
          v57 = 2080;
          v58 = v59;
          _os_log_error_impl(&dword_1B8270000, v23, OS_LOG_TYPE_ERROR, "%s:%d: init reverse failed %s", v53, 0x1Cu);
        }
        *__error() = v22;
        fd_release(a2);
      }
    }
  }
  return v52;
}

void _reverseStoreIterate(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int32_t v5;
  unint64_t v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  void (*v12)(_QWORD);
  int v13;
  NSObject *v14;
  int v15;
  NSObject *v16;
  os_log_type_t v17;
  unsigned __int16 *Page;
  int8x8_t v19;
  uint64_t v20;
  uint64_t v21;
  void (*v22)(_QWORD);
  char *v23;
  char *v24;
  const char *v25;
  uint64_t v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  uint64_t v31;
  unsigned int *v32;
  uint64_t v33;
  uint8_t buf[4];
  const char *v35;
  __int16 v36;
  int v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v4 = a1 + 4416;
    _db_write_lock(a1 + 4416);
    v31 = 0;
    v32 = 0;
    v33 = 0;
    storage_reader_init(a1, (uint64_t)&v31);
    if ((_BYTE)v33)
    {
      v5 = OSAtomicIncrement32((int32_t *)exceptionSequenceNum);
      v6 = setThreadIdAndInfo(-1, sStorageReaderExceptionCallbacks, (uint64_t)&v31, 0, v5);
      v29 = HIDWORD(v6);
      v30 = v6;
      v27 = v8;
      v28 = v7;
      v9 = *(_QWORD *)&threadData[18 * v6 + 2];
      v10 = v9 + 320 * HIDWORD(v6);
      v11 = *(_DWORD *)(v10 + 312);
      v12 = *(void (**)(_QWORD))(v10 + 224);
      if (v12)
        v12(*(_QWORD *)(v9 + 320 * HIDWORD(v6) + 288));
      if (_setjmp((int *)v10))
      {
        v13 = *__error();
        v14 = _SILogForLogForCategory(0);
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315394;
          v35 = "_reverseStoreIterate";
          v36 = 1024;
          v37 = 3969;
          _os_log_error_impl(&dword_1B8270000, v14, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
        }
        *__error() = v13;
        *(_DWORD *)(v10 + 312) = v11;
        CIOnThreadCleanUpReset(v27);
        dropThreadId(v30, 1, v5);
        CICleanUpReset(v30, v28);
      }
      else
      {
        buf[0] = 0;
        Page = _directoryStoreReaderGetPage(&v31, 0x440uLL, (BOOL *)buf);
        if (!Page || buf[0])
        {
          if (Page)
          {
            v23 = __si_assert_copy_extra(*(_DWORD **)(a1 + 216));
            v24 = v23;
            v25 = "";
            if (v23)
              v25 = v23;
            __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 3967, "(!page)", v25);
            free(v24);
            if (__valid_fsp(*(_DWORD **)(a1 + 216)))
              v26 = 2989;
            else
              v26 = 3072;
            *(_DWORD *)v26 = -559038737;
            abort();
          }
        }
        else
        {
          _reverseStoreIterateTreePage(a1, &v31, Page, (unsigned __int16 *)0x440, 0, a2, v19);
        }
        v20 = *(_QWORD *)&threadData[18 * v30 + 2];
        v21 = v20 + 320 * v29;
        *(_DWORD *)(v21 + 312) = v11;
        v22 = *(void (**)(_QWORD))(v21 + 232);
        if (v22)
          v22(*(_QWORD *)(v20 + 320 * v29 + 288));
        dropThreadId(v30, 0, v5);
      }
    }
    else
    {
      v15 = *__error();
      v16 = _SILogForLogForCategory(0);
      v17 = 2 * (gSILogLevels[0] < 4);
      if (os_log_type_enabled(v16, v17))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1B8270000, v16, v17, "Skipping because index is shut down", buf, 2u);
      }
      *__error() = v15;
    }
    db_write_unlock(v4);
    if (v32)
      _release_read_window(&availableReaders, v32);
  }
}

uint64_t _reverseStoreIterateTreePage(uint64_t a1, uint64_t *a2, unsigned __int16 *a3, unsigned __int16 *a4, int a5, uint64_t a6, int8x8_t a7)
{
  unsigned __int16 *v10;
  unint64_t Size;
  int v13;
  uint64_t *v14;
  int v15;
  NSObject *v16;
  os_log_type_t v17;
  uint64_t v18;
  unint64_t v19;
  unsigned __int16 *Page;
  int8x8_t v21;
  unsigned __int16 *v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  int v26;
  NSObject *v27;
  os_log_type_t v28;
  unint64_t v29;
  uint64_t *v30;
  unint64_t v31;
  unsigned __int16 *v32;
  uint64_t v33;
  int v34;
  BOOL v35;
  int v36;
  NSObject *v37;
  int v38;
  NSObject *v39;
  char *v41;
  char *v42;
  const char *v43;
  uint64_t v44;
  char *v45;
  char *v46;
  const char *v47;
  int v48;
  int v49;
  NSObject *v50;
  int v51;
  int log;
  NSObject *loga;
  int logb;
  uint64_t *v55;
  unsigned __int16 *v56;
  unint64_t v58;
  unsigned int v59;
  BOOL v60;
  char v61;
  uint8_t buf[4];
  unsigned __int16 *v63;
  __int16 v64;
  _BYTE v65[10];
  __int16 v66;
  _QWORD v67[4];

  *(_QWORD *)((char *)&v67[2] + 6) = *MEMORY[0x1E0C80C00];
  if (a3)
  {
    v10 = a3;
    Size = directoryTreePageGetSize(*a3, *((_BYTE *)a3 + 2), a7);
    v13 = v10[3];
    v58 = Size;
    if (dword_1EF19FCA4 >= 5)
    {
      v48 = v10[2];
      v49 = *__error();
      v50 = _SILogForLogForCategory(6);
      if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134219008;
        v63 = v10;
        v64 = 1024;
        *(_DWORD *)v65 = a5;
        *(_WORD *)&v65[4] = 1024;
        *(_DWORD *)&v65[6] = v13;
        v66 = 1024;
        LODWORD(v67[0]) = v48;
        WORD2(v67[0]) = 1024;
        *(_DWORD *)((char *)v67 + 6) = v58;
        _os_log_impl(&dword_1B8270000, v50, OS_LOG_TYPE_DEFAULT, "Tree page:%p level: %d depth: %d origin: %d size: %d", buf, 0x24u);
      }
      *__error() = v49;
      Size = v58;
    }
    if (v13 != a5)
    {
      v14 = a2;
      v15 = *__error();
      v16 = _SILogForLogForCategory(6);
      v17 = dword_1EF19FCA4 < 3;
      if (os_log_type_enabled(v16, (os_log_type_t)(dword_1EF19FCA4 < 3)))
      {
        *(_DWORD *)buf = 134218496;
        v63 = a4;
        v64 = 1024;
        *(_DWORD *)v65 = v13;
        *(_WORD *)&v65[4] = 1024;
        *(_DWORD *)&v65[6] = a5;
        _os_log_impl(&dword_1B8270000, v16, v17, "*warn* Flat page: 0x%8.8llx depth: %d exected: %d", buf, 0x18u);
      }
      *__error() = v15;
      a2 = v14;
      Size = v58;
    }
    if (Size)
    {
      v51 = v13;
      v18 = 0;
      v59 = a5 + 1;
      v55 = a2;
      v56 = v10;
      do
      {
        v19 = *(_QWORD *)&v10[4 * v18 + 4];
        if (v19)
        {
          if (dword_1EF19FCA4 >= 5)
          {
            v36 = *__error();
            v37 = _SILogForLogForCategory(6);
            if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 134218752;
              v63 = v10;
              v64 = 1024;
              *(_DWORD *)v65 = v51;
              *(_WORD *)&v65[4] = 1024;
              *(_DWORD *)&v65[6] = v18;
              v66 = 2048;
              v67[0] = v19;
              _os_log_impl(&dword_1B8270000, v37, OS_LOG_TYPE_DEFAULT, "page:%p depth: %d idx: %d offset: 0x%8.8llx", buf, 0x22u);
            }
            *__error() = v36;
          }
          v60 = 0;
          Page = _directoryStoreReaderGetPage(a2, v19, &v60);
          v22 = Page;
          if (v60)
          {
            v61 = 0;
            if (Page)
            {
              directoryStorePageGetSize(Page, v21);
              v24 = *v22;
              if ((64 << *((_BYTE *)v22 + 2)) - 8 < (int)v24)
              {
                v41 = __si_assert_copy_extra(0);
                v42 = v41;
                v43 = "";
                if (v41)
                  v43 = v41;
                __message_assert("%s:%u: failed assertion '%s' %s Got end %d and size %d", "FileTree.c", 287, "storePageEnd((StorePageRef)page) <= storePageDataSize((StorePageRef)page)", v43, *v22, (64 << *((_BYTE *)v22 + 2)) - 8);
                free(v42);
                if (__valid_fs(-1))
                  goto LABEL_56;
LABEL_60:
                v44 = 3072;
LABEL_61:
                *(_DWORD *)v44 = -559038737;
                abort();
              }
              v25 = v23;
              v26 = v22[3];
              if (dword_1EF19FCA4 >= 5)
              {
                logb = v22[2];
                v38 = *__error();
                v39 = _SILogForLogForCategory(6);
                if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 134219008;
                  v63 = v22;
                  v64 = 1024;
                  *(_DWORD *)v65 = v59;
                  *(_WORD *)&v65[4] = 1024;
                  *(_DWORD *)&v65[6] = v26;
                  v66 = 1024;
                  LODWORD(v67[0]) = logb;
                  WORD2(v67[0]) = 1024;
                  *(_DWORD *)((char *)v67 + 6) = v25;
                  _os_log_impl(&dword_1B8270000, v39, OS_LOG_TYPE_DEFAULT, "Flat page:%p level: %d depth: %d origin: %d size: %d", buf, 0x24u);
                }
                *__error() = v38;
              }
              if (v59 != v26)
              {
                log = *__error();
                v27 = _SILogForLogForCategory(6);
                v28 = dword_1EF19FCA4 < 3;
                if (os_log_type_enabled(v27, (os_log_type_t)(dword_1EF19FCA4 < 3)))
                {
                  *(_DWORD *)buf = 134218496;
                  v63 = (unsigned __int16 *)v19;
                  v64 = 1024;
                  *(_DWORD *)v65 = v26;
                  *(_WORD *)&v65[4] = 1024;
                  *(_DWORD *)&v65[6] = v59;
                  _os_log_impl(&dword_1B8270000, v27, v28, "*warn* Flat page: 0x%8.8llx depth: %d exected: %d", buf, 0x18u);
                }
                *__error() = log;
              }
              if (v25)
              {
                v29 = v24 >> 4;
                v30 = (uint64_t *)(v22 + 8);
                v31 = 1;
                Size = v58;
                do
                {
                  v32 = (unsigned __int16 *)*(v30 - 1);
                  if (v32)
                  {
                    v33 = *v30;
                    if (dword_1EF19FCA4 >= 5)
                    {
                      v34 = *__error();
                      loga = _SILogForLogForCategory(6);
                      if (os_log_type_enabled(loga, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_DWORD *)buf = 134218240;
                        v63 = v32;
                        v64 = 2048;
                        *(_QWORD *)v65 = v33;
                        _os_log_impl(&dword_1B8270000, loga, OS_LOG_TYPE_DEFAULT, "oid: %lld parent: %lld", buf, 0x16u);
                      }
                      *__error() = v34;
                      Size = v58;
                    }
                    --v29;
                    if (a6)
                      (*(void (**)(uint64_t, unsigned __int16 *, uint64_t, char *))(a6 + 16))(a6, v32, v33, &v61);
                  }
                  if (v31 >= v25)
                    break;
                  v30 += 2;
                  ++v31;
                }
                while (!v61);
                if (v61)
                  v35 = 1;
                else
                  v35 = v29 == 0;
                if (!v35)
                {
LABEL_57:
                  v45 = __si_assert_copy_extra(*(_DWORD **)(a1 + 216));
                  v46 = v45;
                  v47 = "";
                  if (v45)
                    v47 = v45;
                  __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 3830, "itemCount == 0", v47);
                  free(v46);
                  if (!__valid_fsp(*(_DWORD **)(a1 + 216)))
                    goto LABEL_60;
LABEL_56:
                  v44 = 2989;
                  goto LABEL_61;
                }
                a2 = v55;
                v10 = v56;
                if (v61)
                  return 1;
              }
              else
              {
                Size = v58;
                if (v24 > 0xF)
                  goto LABEL_57;
                a2 = v55;
                v10 = v56;
              }
            }
          }
          else if ((_reverseStoreIterateTreePage(a1, a2, Page, v19, v59, a6) & 1) != 0)
          {
            return 1;
          }
        }
        ++v18;
      }
      while (v18 != Size);
    }
  }
  return 0;
}

uint64_t flushReverseStore(uint64_t a1)
{
  int v2;
  int v3;
  int v6;
  NSObject *v7;
  os_log_type_t v8;
  int v9;
  uint64_t v10;
  int32_t v11;
  uint64_t v12;
  int v13;
  unint64_t v14;
  unsigned int v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  void (*v20)(_QWORD);
  _DWORD *v21;
  int v22;
  NSObject *v23;
  char *v24;
  uint64_t v25;
  int v26;
  NSObject *v27;
  os_log_type_t v28;
  uint64_t v29;
  unsigned int v30;
  uint64_t v31;
  void (*v32)(_QWORD);
  __int16 v34[6];
  unint64_t v35;
  unsigned int v36;
  unsigned int v37;
  unint64_t v38;
  unsigned int v39;
  unsigned int v40;
  _BYTE buf[12];
  __int16 v42;
  int v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  v2 = setCrashStateTarget(2);
  v3 = *(_DWORD *)(a1 + 4408);
  if (v3 == -1073623027 || v3 == -804450864 || v3 == 2)
  {
    v6 = *__error();
    v7 = _SILogForLogForCategory(6);
    v8 = 2 * (dword_1EF19FCA4 < 4);
    if (os_log_type_enabled(v7, v8))
    {
      v9 = *(_DWORD *)(a1 + 4408);
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = v9;
      _os_log_impl(&dword_1B8270000, v7, v8, "skip flushReverseStore; %x", buf, 8u);
    }
    v10 = 0;
    *__error() = v6;
  }
  else
  {
    if (!storageResolvePtr(a1, 0, 1uLL, 1))
    {
LABEL_22:
      v10 = 0;
      goto LABEL_28;
    }
    v11 = OSAtomicIncrement32((int32_t *)exceptionSequenceNum);
    v12 = *(_QWORD *)(a1 + 216);
    if (v12)
      v13 = *(_DWORD *)(v12 + 44);
    else
      v13 = -1;
    v14 = setThreadIdAndInfo(v13, sStorageExceptionCallbacks, a1, 1, v11);
    v39 = HIDWORD(v14);
    v40 = v14;
    v38 = __PAIR64__(v15, v16);
    v17 = *(_QWORD *)&threadData[18 * v14 + 2];
    v18 = v17 + 320 * HIDWORD(v14);
    v19 = *(_DWORD *)(v18 + 312);
    v20 = *(void (**)(_QWORD))(v18 + 224);
    if (v20)
      v20(*(_QWORD *)(v17 + 320 * HIDWORD(v14) + 288));
    v37 = v40;
    v36 = v39;
    v35 = v38;
    if (_setjmp((int *)v18))
    {
      v21 = (_DWORD *)(v18 + 312);
      v22 = *__error();
      v23 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        *(_QWORD *)&buf[4] = "flushReverseStore";
        v42 = 1024;
        v43 = 4048;
        _os_log_error_impl(&dword_1B8270000, v23, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
      }
      *__error() = v22;
      *v21 = v19;
      CIOnThreadCleanUpReset(v35);
      dropThreadId(v37, 1, v11);
      CICleanUpReset(v37, HIDWORD(v35));
      goto LABEL_22;
    }
    dirtyStore(a1);
    v24 = storageResolvePtr(a1, 0x40uLL, 0x400uLL, 1);
    *(_QWORD *)buf = v24 + 8;
    storageHeaderStore(a1, (uint64_t *)buf);
    dirtyStoragePage(a1, (unint64_t)v24);
    v25 = storageSyncPages(a1, a1 + 4368, 0x20000uLL);
    v26 = *__error();
    v27 = _SILogForLogForCategory(6);
    v28 = 2 * (dword_1EF19FCA4 < 4);
    if (os_log_type_enabled(v27, v28))
    {
      v34[0] = 0;
      _os_log_impl(&dword_1B8270000, v27, v28, "completed flushReverseStore", (uint8_t *)v34, 2u);
    }
    *__error() = v26;
    v29 = *(_QWORD *)&threadData[18 * v37 + 2];
    v30 = v36;
    v31 = v29 + 320 * v36;
    *(_DWORD *)(v31 + 312) = v19;
    v32 = *(void (**)(_QWORD))(v31 + 232);
    if (v32)
      v32(*(_QWORD *)(v29 + 320 * v30 + 288));
    dropThreadId(v37, 0, v11);
    v10 = v25;
  }
LABEL_28:
  setCrashStateTarget(v2);
  return v10;
}

uint64_t commitSyncReverseStore(uint64_t a1, int a2)
{
  int v4;
  uint64_t v5;
  int v6;
  int32_t v7;
  uint64_t v8;
  int v9;
  unint64_t v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  void (*v16)(_QWORD);
  int v17;
  NSObject *v18;
  char *v19;
  uint64_t v20;
  int v21;
  NSObject *v22;
  os_log_type_t v23;
  uint64_t v24;
  uint64_t v25;
  void (*v26)(_QWORD);
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  uint8_t buf[4];
  const char *v33;
  __int16 v34;
  int v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v4 = setCrashStateTarget(2);
  if (*(_DWORD *)(a1 + 4408) == -1073623027)
  {
    v5 = 0;
    goto LABEL_24;
  }
  if (a2)
    v6 = 2;
  else
    v6 = -804450864;
  *(_DWORD *)(a1 + 4408) = v6;
  if (!storageResolvePtr(a1, 0, 1uLL, 1))
  {
LABEL_16:
    v5 = 14;
    goto LABEL_24;
  }
  v7 = OSAtomicIncrement32((int32_t *)exceptionSequenceNum);
  v8 = *(_QWORD *)(a1 + 216);
  if (v8)
    v9 = *(_DWORD *)(v8 + 44);
  else
    v9 = -1;
  v10 = setThreadIdAndInfo(v9, sStorageExceptionCallbacks, a1, 1, v7);
  v30 = HIDWORD(v10);
  v31 = v10;
  v28 = v12;
  v29 = v11;
  v13 = *(_QWORD *)&threadData[18 * v10 + 2];
  v14 = v13 + 320 * HIDWORD(v10);
  v15 = *(_DWORD *)(v14 + 312);
  v16 = *(void (**)(_QWORD))(v14 + 224);
  if (v16)
    v16(*(_QWORD *)(v13 + 320 * HIDWORD(v10) + 288));
  if (_setjmp((int *)v14))
  {
    v17 = *__error();
    v18 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v33 = "commitSyncReverseStore";
      v34 = 1024;
      v35 = 4078;
      _os_log_error_impl(&dword_1B8270000, v18, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
    }
    *__error() = v17;
    *(_DWORD *)(v14 + 312) = v15;
    CIOnThreadCleanUpReset(v28);
    dropThreadId(v31, 1, v7);
    CICleanUpReset(v31, v29);
    goto LABEL_16;
  }
  v19 = storageResolvePtr(a1, 0x40uLL, 0x400uLL, 1);
  *((_DWORD *)v19 + 1) = *(_DWORD *)(a1 + 4408);
  v20 = msync((void *)((unint64_t)v19 & ~*MEMORY[0x1E0C85AC0]), 0x1000uLL, 16);
  if ((_DWORD)v20 == -1)
    v20 = *__error();
  v21 = *__error();
  v22 = _SILogForLogForCategory(6);
  v23 = 2 * (dword_1EF19FCA4 < 4);
  if (os_log_type_enabled(v22, v23))
  {
    *(_DWORD *)buf = 67109120;
    LODWORD(v33) = v20;
    _os_log_impl(&dword_1B8270000, v22, v23, "completed commitSyncReverseStore: %d", buf, 8u);
  }
  *__error() = v21;
  v24 = *(_QWORD *)&threadData[18 * v31 + 2];
  v25 = v24 + 320 * v30;
  *(_DWORD *)(v25 + 312) = v15;
  v26 = *(void (**)(_QWORD))(v25 + 232);
  if (v26)
    v26(*(_QWORD *)(v24 + 320 * v30 + 288));
  dropThreadId(v31, 0, v7);
  v5 = v20;
LABEL_24:
  setCrashStateTarget(v4);
  return v5;
}

uint64_t shadowReverseStore(uint64_t a1, char a2, _DWORD *a3)
{
  int v6;
  int32_t v7;
  uint64_t v8;
  int v9;
  unint64_t v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  void (*v16)(_QWORD);
  int v17;
  NSObject *v18;
  unsigned int v19;
  int v20;
  NSObject *v21;
  unsigned int v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t v26;
  void (*v27)(_QWORD);
  int v28;
  NSObject *v29;
  os_log_type_t v30;
  const char *v31;
  uint32_t v32;
  uint64_t v33;
  uint64_t v34;
  int v35;
  NSObject *v36;
  int v37;
  char *sibling_protected;
  uint64_t v39;
  void *v40;
  void *v41;
  size_t v42;
  _DWORD *v43;
  unsigned int v44;
  int v45;
  NSObject *v46;
  void *v47;
  int v48;
  int v49;
  int v50;
  unsigned int v51;
  unsigned int v52;
  CFIndex v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  CFIndex v57;
  uint64_t v58;
  uint64_t v59;
  unsigned int *v60;
  CFIndex v61;
  CFIndex FirstIndexOfBit;
  int v63;
  NSObject *v64;
  os_log_type_t v65;
  int v66;
  int v67;
  NSObject *v68;
  const char *v69;
  int v70;
  NSObject *v71;
  int v72;
  NSObject *v73;
  int v74;
  int v75;
  NSObject *v76;
  const char *v77;
  char *v78;
  char *v79;
  const char *v80;
  uint64_t v81;
  char *v82;
  char *v83;
  const char *v84;
  uint64_t v85;
  int v86;
  int v87;
  NSObject *v88;
  const char *v89;
  CFIndex v90;
  char *v91;
  char *v92;
  const char *v93;
  uint64_t v94;
  CFIndex *v95;
  unsigned int v96;
  unsigned int __fd;
  char *v98;
  int v99;
  uint64_t v100;
  uint64_t v101;
  unint64_t v102;
  unsigned int v103;
  unsigned int v104;
  unsigned int v105;
  unint64_t v106;
  unsigned int v107;
  uint8_t buf[4];
  const char *v109;
  __int16 v110;
  int v111;
  __int16 v112;
  unsigned int v113;
  __int16 v114;
  const char *v115;
  _OWORD v116[25];
  uint64_t v117;
  CFRange v118;

  v117 = *MEMORY[0x1E0C80C00];
  v6 = setCrashStateTarget(2);
  if (!storageResolvePtr(a1, 0, 1uLL, 1))
  {
LABEL_11:
    v19 = 0;
LABEL_12:
    v20 = *__error();
    v21 = _SILogForLogForCategory(6);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315650;
      v109 = "shadowReverseStore";
      v110 = 1024;
      v111 = 4200;
      v112 = 1024;
      v113 = v19;
      _os_log_error_impl(&dword_1B8270000, v21, OS_LOG_TYPE_ERROR, "%s:%d: shadowReverseStore fail. metadata = %d", buf, 0x18u);
    }
    *__error() = v20;
    return 104;
  }
  v7 = OSAtomicIncrement32((int32_t *)exceptionSequenceNum);
  v107 = 0;
  v106 = 0;
  v105 = 0;
  v8 = *(_QWORD *)(a1 + 216);
  if (v8)
    v9 = *(_DWORD *)(v8 + 44);
  else
    v9 = -1;
  v10 = setThreadIdAndInfo(v9, sStorageExceptionCallbacks, a1, 1, v7);
  v107 = v10;
  v105 = v12;
  v106 = __PAIR64__(HIDWORD(v10), v11);
  v13 = *(_QWORD *)&threadData[18 * v10 + 2];
  v14 = v13 + 320 * HIDWORD(v10);
  v15 = *(_DWORD *)(v14 + 312);
  v16 = *(void (**)(_QWORD))(v14 + 224);
  if (v16)
    v16(*(_QWORD *)(v13 + 320 * HIDWORD(v10) + 288));
  v104 = v107;
  v103 = HIDWORD(v106);
  v102 = __PAIR64__(v106, v105);
  if (_setjmp((int *)v14))
  {
    v17 = *__error();
    v18 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v109 = "shadowReverseStore";
      v110 = 1024;
      v111 = 4197;
      _os_log_error_impl(&dword_1B8270000, v18, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
    }
    *__error() = v17;
    *(_DWORD *)(v14 + 312) = v15;
    CIOnThreadCleanUpReset(v102);
    dropThreadId(v104, 1, v7);
    CICleanUpReset(v104, HIDWORD(v102));
    goto LABEL_11;
  }
  v23 = *((_DWORD *)storageResolvePtr(a1, 0x40uLL, 0x400uLL, 1) + 1);
  v24 = *(_QWORD *)&threadData[18 * v104 + 2];
  v25 = v103;
  v26 = v24 + 320 * v103;
  *(_DWORD *)(v26 + 312) = v15;
  v27 = *(void (**)(_QWORD))(v26 + 232);
  if (v27)
    v27(*(_QWORD *)(v24 + 320 * v25 + 288));
  dropThreadId(v104, 0, v7);
  if (!*(_DWORD *)(a1 + 4408) || !v23)
  {
    v19 = v23;
    goto LABEL_12;
  }
  if (v23 != -804450864)
  {
    if (v23 == 2)
    {
      v78 = __si_assert_copy_extra(*(_DWORD **)(a1 + 216));
      v79 = v78;
      v80 = "";
      if (v78)
        v80 = v78;
      __message_assert("%s:%u: failed assertion '%s' %s invalid state", "FileTree.c", 4206, "metadata != kIndexShutDownStateFastFlush", v80);
      free(v79);
      if (__valid_fsp(*(_DWORD **)(a1 + 216)))
        v81 = 2989;
      else
        v81 = 3072;
      *(_DWORD *)v81 = -559038737;
      abort();
    }
    v28 = *__error();
    v29 = _SILogForLogForCategory(6);
    v30 = 2 * (dword_1EF19FCA4 < 4);
    if (!os_log_type_enabled(v29, v30))
      goto LABEL_32;
    *(_DWORD *)buf = 67109120;
    LODWORD(v109) = v23;
    v31 = "shadowReverseStore: %d";
    v32 = 8;
    goto LABEL_31;
  }
  v33 = *(_QWORD *)(a1 + 216);
  if (v33)
    v34 = *(unsigned int *)(v33 + 44);
  else
    v34 = 0xFFFFFFFFLL;
  if (isRegisteredForCloning(v34))
  {
    if ((copyFileFallback(v34, "reverseDirectoryStore", v34, "reverseDirectoryStore.shadow", a3, 0, 1) & 1) != 0)
    {
      bit_vector_set_bits_3284(a1 + 4368, 0, *(_QWORD *)(a1 + 4368));
      v28 = *__error();
      v29 = _SILogForLogForCategory(6);
      v30 = 2 * (dword_1EF19FCA4 < 4);
      if (!os_log_type_enabled(v29, v30))
      {
LABEL_32:
        *__error() = v28;
        return 0;
      }
      *(_WORD *)buf = 0;
      v31 = "Completed shadowReverseStore";
      v32 = 2;
LABEL_31:
      _os_log_impl(&dword_1B8270000, v29, v30, v31, buf, v32);
      goto LABEL_32;
    }
    v35 = *__error();
    v36 = _SILogForLogForCategory(6);
    if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v109 = "shadowReverseStore";
      v110 = 1024;
      v111 = 4223;
      _os_log_error_impl(&dword_1B8270000, v36, OS_LOG_TYPE_ERROR, "%s:%d: copyFile error, src: reverseDirectoryStore, dst: reverseDirectoryStore.shadow", buf, 0x12u);
    }
    *__error() = v35;
  }
  v37 = *(_DWORD *)(a1 + 232);
  memset(v116, 0, sizeof(v116));
  v100 = 0;
  v101 = 0;
  sibling_protected = (char *)fd_create_sibling_protected(*(_QWORD *)(a1 + 216), "reverseDirectoryStore.shadow", 514, 0);
  fd_no_cache((uint64_t)sibling_protected);
  if (sibling_protected)
  {
    v39 = (v37 + 0x1FFFF) >> 17;
    if ((a2 & 1) == 0 && v39 >= *(_QWORD *)(a1 + 4368))
      v39 = *(_QWORD *)(a1 + 4368);
    v40 = malloc_type_malloc(0x20000uLL, 0xFFA4D75FuLL);
    if (!v40)
    {
      v82 = __si_assert_copy_extra(0);
      v83 = v82;
      v84 = "";
      if (v82)
        v84 = v82;
      __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 4257, "readBuffer", v84);
      free(v83);
      if (__valid_fs(-1))
        v85 = 2989;
      else
        v85 = 3072;
      *(_DWORD *)v85 = -559038737;
      abort();
    }
    v41 = v40;
    v42 = *(_QWORD *)(a1 + 232);
    v43 = *(_DWORD **)(a1 + 216);
    if (!(v42 >> 17))
    {
      if (fd_pread(v43, v41, v42, 0) != -1)
      {
        if (fd_pwrite((uint64_t)sibling_protected, (uint64_t)v41, *(_QWORD *)(a1 + 232), 0) != -1)
        {
          bit_vector_internal_touch_for_set_3277((CFIndex *)(a1 + 4368), 0);
          CFBitVectorSetBitAtIndex(*(CFMutableBitVectorRef *)(a1 + 4384), 0, 0);
          goto LABEL_83;
        }
        v66 = *__error();
        v67 = *__error();
        v68 = _SILogForLogForCategory(0);
        if (!os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
          goto LABEL_95;
        *(_DWORD *)buf = 136315650;
        v109 = "shadowReverseStore";
        v110 = 1024;
        v111 = 4266;
        v112 = 1024;
        v113 = v66;
        v69 = "%s:%d: pwrite err: %d";
        goto LABEL_94;
      }
      v66 = *__error();
      v67 = *__error();
      v68 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315650;
        v109 = "shadowReverseStore";
        v110 = 1024;
        v111 = 4261;
        v112 = 1024;
        v113 = v66;
        v69 = "%s:%d: read err: %d";
LABEL_94:
        _os_log_error_impl(&dword_1B8270000, v68, OS_LOG_TYPE_ERROR, v69, buf, 0x18u);
        goto LABEL_95;
      }
      goto LABEL_95;
    }
    v51 = _fd_acquire_fd((uint64_t)v43, &v100);
    if (v51 == -1)
    {
      v66 = *__error();
      v67 = *__error();
      v68 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315650;
        v109 = "shadowReverseStore";
        v110 = 1024;
        v111 = 4274;
        v112 = 1024;
        v113 = v66;
        v69 = "%s:%d: fd_open err: %d";
        goto LABEL_94;
      }
LABEL_95:
      v49 = v67;
      v50 = -1;
      v48 = -1;
LABEL_96:
      v47 = v41;
      v44 = v66;
      goto LABEL_97;
    }
    __fd = v51;
    v52 = _fd_acquire_fd((uint64_t)sibling_protected, &v101);
    if (v52 == -1)
    {
      v66 = *__error();
      v72 = *__error();
      v73 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v73, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315650;
        v109 = "shadowReverseStore";
        v110 = 1024;
        v111 = 4280;
        v112 = 1024;
        v113 = v66;
        _os_log_error_impl(&dword_1B8270000, v73, OS_LOG_TYPE_ERROR, "%s:%d: fd_open err: %d", buf, 0x18u);
      }
      v49 = v72;
      v48 = -1;
      v50 = __fd;
      goto LABEL_96;
    }
    v98 = sibling_protected;
    v96 = v52;
    if (v39 < 1)
    {
LABEL_82:
      prot_fsync(v96, 0);
      _fd_release_fd(*(_DWORD **)(a1 + 216), __fd, 0, v100);
      sibling_protected = v98;
      _fd_release_fd(v98, v96, 0, v101);
LABEL_83:
      v118.length = *(_QWORD *)(a1 + 4368);
      v118.location = 0;
      FirstIndexOfBit = CFBitVectorGetFirstIndexOfBit(*(CFBitVectorRef *)(a1 + 4384), v118, 1u);
      if (FirstIndexOfBit != -1 && FirstIndexOfBit < *(_QWORD *)(a1 + 232) >> 17)
      {
        v90 = FirstIndexOfBit;
        v91 = __si_assert_copy_extra(*(_DWORD **)(a1 + 216));
        v92 = v91;
        v93 = "";
        if (v91)
          v93 = v91;
        __message_assert("%s:%u: failed assertion '%s' %s Expected bitmap to be clean for index in state %x. Dirty bit at index %lx", "FileTree.c", 4375, "dirtyBitIx == kCFNotFound || dirtyBitIx >= (CFIndex)(storageGetCount(&store->storage)/STORAGE_SHADOWPAGESIZE)", v93, -804450864, v90);
        free(v92);
        if (__valid_fsp(*(_DWORD **)(a1 + 216)))
          v94 = 2989;
        else
          v94 = 3072;
        *(_DWORD *)v94 = -559038737;
        abort();
      }
      fd_release(sibling_protected);
      free(v41);
      v63 = *__error();
      v64 = _SILogForLogForCategory(6);
      v65 = 2 * (dword_1EF19FCA4 < 4);
      if (os_log_type_enabled(v64, v65))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1B8270000, v64, v65, "Completed shadowReverseStore", buf, 2u);
      }
      *__error() = v63;
      setCrashStateTarget(v6);
      return 0;
    }
    v53 = 0;
    v95 = (CFIndex *)(a1 + 4368);
    v54 = 0;
    v99 = v6;
    do
    {
      v55 = v54;
      if ((_DWORD)v54 == 100)
      {
        v56 = 0;
        while (*a3 != 1 && (*a3 != -1 || (a2 & 1) == 0))
        {
          v57 = *(unsigned int *)((char *)v116 + v56);
          if (prot_pread(__fd, v41, 0x20000uLL, v57 << 17) == -1)
          {
            v74 = *__error();
            v75 = *__error();
            v76 = _SILogForLogForCategory(0);
            if (!os_log_type_enabled(v76, OS_LOG_TYPE_ERROR))
            {
LABEL_111:
              v49 = v75;
              v48 = v96;
              v50 = __fd;
              v47 = v41;
              v44 = v74;
              v6 = v99;
              goto LABEL_112;
            }
            *(_DWORD *)buf = 136315650;
            v109 = "shadowReverseStore";
            v110 = 1024;
            v111 = 4293;
            v112 = 1024;
            v113 = v74;
            v77 = "%s:%d: read err: %d";
LABEL_121:
            _os_log_error_impl(&dword_1B8270000, v76, OS_LOG_TYPE_ERROR, v77, buf, 0x18u);
            goto LABEL_111;
          }
          if (*a3 == 1 || *a3 == -1 && (a2 & 1) != 0)
            break;
          if (prot_pwrite_guarded(v96, (uint64_t)&v101, (uint64_t)v41, 0x20000uLL, v57 << 17) == -1)
          {
            v74 = *__error();
            v75 = *__error();
            v76 = _SILogForLogForCategory(0);
            if (!os_log_type_enabled(v76, OS_LOG_TYPE_ERROR))
              goto LABEL_111;
            *(_DWORD *)buf = 136315650;
            v109 = "shadowReverseStore";
            v110 = 1024;
            v111 = 4302;
            v112 = 1024;
            v113 = v74;
            v77 = "%s:%d: pwrite err: %d";
            goto LABEL_121;
          }
          bit_vector_internal_touch_for_set_3277(v95, v57);
          CFBitVectorSetBitAtIndex(*(CFMutableBitVectorRef *)(a1 + 4384), v57, 0);
          v56 += 4;
          if (v56 == 400)
          {
            v55 = 0;
            v6 = v99;
            goto LABEL_65;
          }
        }
        v48 = v96;
        v50 = __fd;
        v47 = v41;
        v44 = 89;
        v6 = v99;
LABEL_107:
        sibling_protected = v98;
        goto LABEL_98;
      }
LABEL_65:
      if ((a2 & 1) != 0 || *v95 > v53 && CFBitVectorGetBitAtIndex(*(CFBitVectorRef *)(a1 + 4384), v53))
      {
        *((_DWORD *)v116 + v55) = v53;
        v58 = (v55 + 1);
      }
      else
      {
        v58 = v55;
      }
      ++v53;
      v54 = v58;
    }
    while (v53 != v39);
    if (!(_DWORD)v58)
      goto LABEL_82;
    v59 = v58;
    v60 = (unsigned int *)v116;
    while (1)
    {
      if (*a3 == 1)
      {
        v48 = v96;
        v50 = __fd;
        v47 = v41;
        v44 = 89;
        goto LABEL_107;
      }
      if (*a3 == -1 && (a2 & 1) != 0)
      {
LABEL_117:
        v48 = v96;
        v50 = __fd;
        v47 = v41;
        v44 = 89;
        goto LABEL_107;
      }
      v61 = *v60;
      if (prot_pread(__fd, v41, 0x20000uLL, v61 << 17) == -1)
      {
        v86 = *__error();
        v87 = *__error();
        v88 = _SILogForLogForCategory(0);
        if (!os_log_type_enabled(v88, OS_LOG_TYPE_ERROR))
          goto LABEL_130;
        *(_DWORD *)buf = 136315650;
        v109 = "shadowReverseStore";
        v110 = 1024;
        v111 = 4330;
        v112 = 1024;
        v113 = v86;
        v89 = "%s:%d: pread err: %d";
        goto LABEL_140;
      }
      if (*a3 == 1 || *a3 == -1 && (a2 & 1) != 0)
        goto LABEL_117;
      if (prot_pwrite_guarded(v96, (uint64_t)&v101, (uint64_t)v41, 0x20000uLL, v61 << 17) == -1)
        break;
      bit_vector_set_3415((uint64_t)v95, v61);
      ++v60;
      if (!--v59)
        goto LABEL_82;
    }
    v86 = *__error();
    v87 = *__error();
    v88 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v88, OS_LOG_TYPE_ERROR))
      goto LABEL_130;
    *(_DWORD *)buf = 136315650;
    v109 = "shadowReverseStore";
    v110 = 1024;
    v111 = 4339;
    v112 = 1024;
    v113 = v86;
    v89 = "%s:%d: pwrite err: %d";
LABEL_140:
    _os_log_error_impl(&dword_1B8270000, v88, OS_LOG_TYPE_ERROR, v89, buf, 0x18u);
LABEL_130:
    v49 = v87;
    v48 = v96;
    v50 = __fd;
    v47 = v41;
    v44 = v86;
LABEL_112:
    sibling_protected = v98;
  }
  else
  {
    v44 = *__error();
    v45 = *__error();
    v46 = _SILogForLogForCategory(6);
    if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      v109 = "shadowReverseStore";
      v110 = 1024;
      v111 = 4247;
      v112 = 1024;
      v113 = v44;
      v114 = 2080;
      v115 = "reverseDirectoryStore.shadow";
      _os_log_error_impl(&dword_1B8270000, v46, OS_LOG_TYPE_ERROR, "%s:%d: open err: %d, %s", buf, 0x22u);
    }
    v47 = 0;
    v48 = -1;
    v49 = v45;
    v50 = -1;
  }
LABEL_97:
  *__error() = v49;
LABEL_98:
  v70 = *__error();
  v71 = _SILogForLogForCategory(6);
  if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136315394;
    v109 = "shadowReverseStore";
    v110 = 1024;
    v111 = 4388;
    _os_log_error_impl(&dword_1B8270000, v71, OS_LOG_TYPE_ERROR, "%s:%d: Failed shadowReverseStore", buf, 0x12u);
  }
  *__error() = v70;
  free(v47);
  _fd_release_fd(*(_DWORD **)(a1 + 216), v50, 0, v100);
  _fd_release_fd(sibling_protected, v48, 0, v101);
  fd_release(sibling_protected);
  setCrashStateTarget(v6);
  if (v44)
    return v44;
  else
    return 0xFFFFFFFFLL;
}

void bit_vector_set_3415(uint64_t a1, CFIndex a2)
{
  bit_vector_internal_touch_for_set_3277((CFIndex *)a1, a2);
  CFBitVectorSetBitAtIndex(*(CFMutableBitVectorRef *)(a1 + 16), a2, 0);
}

uint64_t commitShadowReverseStore(uint64_t a1)
{
  int v2;
  int32_t v3;
  uint64_t v4;
  int v5;
  unint64_t v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  void (*v12)(_QWORD);
  int v13;
  NSObject *v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  int v18;
  NSObject *v19;
  os_log_type_t v20;
  uint64_t v21;
  uint64_t v22;
  void (*v23)(_QWORD);
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  unsigned int v28;
  uint8_t buf[4];
  const char *v30;
  __int16 v31;
  int v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v2 = setCrashStateTarget(2);
  if (!storageResolvePtr(a1, 0, 1uLL, 1))
  {
LABEL_11:
    v15 = 0xFFFFFFFFLL;
    goto LABEL_20;
  }
  v3 = OSAtomicIncrement32((int32_t *)exceptionSequenceNum);
  v4 = *(_QWORD *)(a1 + 216);
  if (v4)
    v5 = *(_DWORD *)(v4 + 44);
  else
    v5 = -1;
  v6 = setThreadIdAndInfo(v5, sStorageExceptionCallbacks, a1, 1, v3);
  v27 = HIDWORD(v6);
  v28 = v6;
  v25 = v8;
  v26 = v7;
  v9 = *(_QWORD *)&threadData[18 * v6 + 2];
  v10 = v9 + 320 * HIDWORD(v6);
  v11 = *(_DWORD *)(v10 + 312);
  v12 = *(void (**)(_QWORD))(v10 + 224);
  if (v12)
    v12(*(_QWORD *)(v9 + 320 * HIDWORD(v6) + 288));
  if (_setjmp((int *)v10))
  {
    v13 = *__error();
    v14 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v30 = "commitShadowReverseStore";
      v31 = 1024;
      v32 = 4415;
      _os_log_error_impl(&dword_1B8270000, v14, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
    }
    *__error() = v13;
    *(_DWORD *)(v10 + 312) = v11;
    CIOnThreadCleanUpReset(v25);
    dropThreadId(v28, 1, v3);
    CICleanUpReset(v28, v26);
    goto LABEL_11;
  }
  v16 = storageResolvePtr(a1, 0x40uLL, 0x400uLL, 1);
  if (v16)
  {
    *((_DWORD *)v16 + 1) = -1073623027;
    v17 = msync((void *)((unint64_t)v16 & ~*MEMORY[0x1E0C85AC0]), 0x1000uLL, 16);
  }
  else
  {
    v17 = 0xFFFFFFFFLL;
  }
  *(_DWORD *)(a1 + 4408) = -1073623027;
  v18 = *__error();
  v19 = _SILogForLogForCategory(6);
  v20 = 2 * (dword_1EF19FCA4 < 4);
  if (os_log_type_enabled(v19, v20))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1B8270000, v19, v20, "Completed commitShadowReverseStore", buf, 2u);
  }
  *__error() = v18;
  v21 = *(_QWORD *)&threadData[18 * v28 + 2];
  v22 = v21 + 320 * v27;
  *(_DWORD *)(v22 + 312) = v11;
  v23 = *(void (**)(_QWORD))(v22 + 232);
  if (v23)
    v23(*(_QWORD *)(v21 + 320 * v27 + 288));
  dropThreadId(v28, 0, v3);
  v15 = v17;
LABEL_20:
  setCrashStateTarget(v2);
  return v15;
}

void freeReverseDirStore(uint64_t a1)
{
  _QWORD *v2;
  const void *v3;
  const void *v4;

  v2 = (_QWORD *)(a1 + 4368);
  v3 = *(const void **)(a1 + 4384);
  if (v3)
  {
    CFRelease(v3);
    *(_QWORD *)(a1 + 4384) = 0;
  }
  *v2 = 0;
  v2[1] = 0;
  db_rwlock_destroy((pthread_mutex_t *)(a1 + 4416));
  storageClose(a1);
  v4 = *(const void **)(a1 + 4632);
  if (v4)
    _Block_release(v4);
  free((void *)a1);
}

void *createReverseStore(int a1, const char *a2, void *a3)
{
  void *v6;
  char *v7;
  char *v9;

  v6 = malloc_type_calloc(1uLL, 0x1220uLL, 0x10A0040356AAE28uLL);
  *((_OWORD *)v6 + 276) = 0u;
  *((_OWORD *)v6 + 277) = 0u;
  *((_OWORD *)v6 + 278) = 0u;
  *((_OWORD *)v6 + 279) = 0u;
  *((_OWORD *)v6 + 280) = 0u;
  *((_OWORD *)v6 + 281) = 0u;
  *((_OWORD *)v6 + 282) = 0u;
  *((_OWORD *)v6 + 283) = 0u;
  *((_OWORD *)v6 + 284) = 0u;
  *((_OWORD *)v6 + 285) = 0u;
  *((_OWORD *)v6 + 286) = 0u;
  *((_OWORD *)v6 + 287) = 0u;
  *((_OWORD *)v6 + 288) = 0u;
  *((_QWORD *)v6 + 578) = 0;
  pthread_mutex_init((pthread_mutex_t *)v6 + 69, 0);
  v9 = 0;
  asprintf(&v9, "%sreverseDirectoryStore", a2);
  v7 = (char *)fd_create_protected(a1, v9, 1538, 0);
  free(v9);
  if (reverseDirStoreInit((uint64_t)v6, v7, 1, 0, a3))
  {
    dirtyStore((uint64_t)v6);
  }
  else
  {
    freeReverseDirStore((uint64_t)v6);
    return 0;
  }
  return v6;
}

void *openReverseStore(int a1, int a2, int a3, int a4, _DWORD *a5, __int128 *a6, void *a7)
{
  int v14;
  int v15;
  __int128 *v16;
  void *v17;
  _DWORD *v18;
  int v19;
  int v20;
  int v21;
  NSObject *v22;
  os_log_type_t v23;
  const char *v24;
  int v25;
  char *v26;
  char *v27;
  void *v28;
  int state;
  __int128 v30;
  int v31;
  NSObject *v32;
  os_log_type_t v33;
  const char *v34;
  uint8_t *v35;
  _DWORD *v37;
  int v38;
  NSObject *v39;
  os_log_type_t v40;
  const __CFAllocator *v41;
  __CFBitVector *Mutable;
  int v43;
  int v44;
  NSObject *v45;
  os_log_type_t v46;
  char *v47;
  char *v48;
  const char *v49;
  uint64_t v50;
  char *v51;
  char *v52;
  const char *v53;
  uint64_t v54;
  int v55;
  uint8_t v56[2];
  uint8_t v57[16];
  __int16 v58;
  uint8_t v59[16];
  uint8_t buf[16];

  v14 = setCrashStateTarget(2);
  v15 = v14;
  if (!a3 || (a4 & 1) != 0)
  {
    if ((a3 & a4) != 0)
      v24 = "reverseDirectoryStore.shadow";
    else
      v24 = "reverseDirectoryStore";
  }
  else
  {
    v55 = a4;
    v16 = a6;
    v17 = a7;
    v18 = a5;
    v19 = a2;
    v20 = v14;
    v21 = *__error();
    v22 = _SILogForLogForCategory(0);
    v23 = 2 * (gSILogLevels[0] < 4);
    if (os_log_type_enabled(v22, v23))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1B8270000, v22, v23, "Recovering reverse store on open", buf, 2u);
    }
    *__error() = v21;
    v24 = "reverseDirectoryStore";
    a5 = v18;
    v15 = v20;
    a2 = v19;
    a7 = v17;
    a6 = v16;
    a4 = v55;
    if ((recoverReverseStore(a1, "reverseDirectoryStore.shadow", "reverseDirectoryStore", v18, 1) & 1) == 0)
      goto LABEL_24;
  }
  if (a4)
    v25 = 0;
  else
    v25 = 2;
  v26 = (char *)fd_create_protected(a1, v24, v25, 0);
  if (!v26)
    return 0;
  v27 = v26;
  v28 = malloc_type_calloc(1uLL, 0x1220uLL, 0x10A0040356AAE28uLL);
  *((_DWORD *)v28 + 1102) = -1073623027;
  *((_OWORD *)v28 + 276) = 0u;
  *((_OWORD *)v28 + 277) = 0u;
  *((_OWORD *)v28 + 278) = 0u;
  *((_OWORD *)v28 + 279) = 0u;
  *((_OWORD *)v28 + 280) = 0u;
  *((_OWORD *)v28 + 281) = 0u;
  *((_OWORD *)v28 + 282) = 0u;
  *((_OWORD *)v28 + 283) = 0u;
  *((_OWORD *)v28 + 284) = 0u;
  *((_OWORD *)v28 + 285) = 0u;
  *((_OWORD *)v28 + 286) = 0u;
  *((_OWORD *)v28 + 287) = 0u;
  *((_OWORD *)v28 + 288) = 0u;
  *((_QWORD *)v28 + 578) = 0;
  pthread_mutex_init((pthread_mutex_t *)v28 + 69, 0);
  if (!reverseDirStoreInit((uint64_t)v28, v27, 0, a4, a7))
  {
    freeReverseDirStore((uint64_t)v28);
    v31 = *__error();
    v32 = _SILogForLogForCategory(6);
    v33 = 2 * (dword_1EF19FCA4 < 4);
    if (!os_log_type_enabled(v32, v33))
    {
LABEL_23:
      *__error() = v31;
LABEL_24:
      setCrashStateTarget(v15);
      return 0;
    }
    *(_WORD *)v56 = 0;
    v34 = "Failed open for reverse store";
    v35 = v56;
LABEL_22:
    _os_log_impl(&dword_1B8270000, v32, v33, v34, v35, 2u);
    goto LABEL_23;
  }
  state = get_state((uint64_t)v28);
  *((_DWORD *)v28 + 1102) = state;
  if (!a6 || state != 2 || (a3 & 1) != 0 || (a4 & 1) != 0)
  {
    if (state == -804450864 && (a4 & 1) == 0)
    {
      v37 = a5;
      v38 = *__error();
      v39 = _SILogForLogForCategory(0);
      v40 = 2 * (gSILogLevels[0] < 4);
      if (os_log_type_enabled(v39, v40))
      {
        *(_WORD *)v59 = 0;
        _os_log_impl(&dword_1B8270000, v39, v40, "Shadowing reverse store on open", v59, 2u);
      }
      *__error() = v38;
      if (shadowReverseStore((uint64_t)v28, 1, v37)
        || (fd_sync(*((_QWORD *)v28 + 27), 1), commitShadowReverseStore((uint64_t)v28)))
      {
        freeReverseDirStore((uint64_t)v28);
        return 0;
      }
      fd_sync(*((_QWORD *)v28 + 27), 1);
    }
    v41 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    *((_OWORD *)v28 + 273) = xmmword_1B8631C20;
    Mutable = CFBitVectorCreateMutable(v41, 0x2000);
    *((_QWORD *)v28 + 548) = Mutable;
    CFBitVectorSetCount(Mutable, 0x2000);
    if (!*((_QWORD *)v28 + 548))
    {
      v51 = __si_assert_copy_extra(0);
      v52 = v51;
      v53 = "";
      if (v51)
        v53 = v51;
      __message_assert("%s:%u: failed assertion '%s' %s ", "bit_vector.h", 47, "bv->_cfbv", v53);
      free(v52);
      if (__valid_fs(-1))
        v54 = 2989;
      else
        v54 = 3072;
      *(_DWORD *)v54 = -559038737;
      abort();
    }
  }
  else
  {
    v30 = *a6;
    *((_QWORD *)v28 + 548) = *((_QWORD *)a6 + 2);
    *((_OWORD *)v28 + 273) = v30;
    *((_QWORD *)a6 + 1) = 0;
    *((_QWORD *)a6 + 2) = 0;
    *(_QWORD *)a6 = 0;
    dirtyStore((uint64_t)v28);
  }
  v43 = get_state((uint64_t)v28);
  *((_DWORD *)v28 + 1102) = v43;
  if (a2)
  {
    if ((_reverseStoreValidate((uint64_t)v28) & 1) != 0)
    {
      freeReverseDirStore((uint64_t)v28);
      v31 = *__error();
      v32 = _SILogForLogForCategory(6);
      v33 = 2 * (dword_1EF19FCA4 < 4);
      if (!os_log_type_enabled(v32, v33))
        goto LABEL_23;
      v58 = 0;
      v34 = "Opened corrupt reverse store";
      v35 = (uint8_t *)&v58;
      goto LABEL_22;
    }
    v43 = *((_DWORD *)v28 + 1102);
  }
  if (v43 == -804450864 && (a4 & 1) == 0)
  {
    v47 = __si_assert_copy_extra(*((_DWORD **)v28 + 27));
    v48 = v47;
    v49 = "";
    if (v47)
      v49 = v47;
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 4609, "(store->state != kIndexShutDownStateNeedsShadow || readOnly)", v49);
    free(v48);
    if (__valid_fsp(*((_DWORD **)v28 + 27)))
      v50 = 2989;
    else
      v50 = 3072;
    *(_DWORD *)v50 = -559038737;
    abort();
  }
  v44 = *__error();
  v45 = _SILogForLogForCategory(6);
  v46 = 2 * (dword_1EF19FCA4 < 4);
  if (os_log_type_enabled(v45, v46))
  {
    *(_WORD *)v57 = 0;
    _os_log_impl(&dword_1B8270000, v45, v46, "Successfully opened from reverse store", v57, 2u);
  }
  *__error() = v44;
  setCrashStateTarget(v15);
  return v28;
}

uint64_t recoverReverseStore(int a1, const char *a2, const char *a3, _DWORD *a4, int a5)
{
  int v10;
  NSObject *v11;
  os_log_type_t v12;
  char *v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  int v17;
  int v18;
  NSObject *v19;
  os_log_type_t v20;
  uint64_t result;
  int v22;
  NSObject *v23;
  const char *v24;
  uint8_t *v25;
  int *v26;
  int v27;
  NSObject *v28;
  int v29;
  NSObject *v30;
  uint64_t v31;
  uint8_t v32[4];
  const char *v33;
  __int16 v34;
  _BYTE v35[14];
  uint8_t buf[4];
  const char *v37;
  __int16 v38;
  int v39;
  __int16 v40;
  const char *v41;
  int v42;
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  v10 = *__error();
  v11 = _SILogForLogForCategory(0);
  v12 = 2 * (gSILogLevels[0] < 4);
  if (os_log_type_enabled(v11, v12))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1B8270000, v11, v12, "recoverReverseStore", buf, 2u);
  }
  *__error() = v10;
  if ((_copyFile(a1, a2, a1, a3, a4, 1088) & 1) == 0)
  {
    v22 = *__error();
    v23 = _SILogForLogForCategory(0);
    if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
LABEL_15:
      v26 = __error();
      result = 0;
      *v26 = v22;
      return result;
    }
    *(_DWORD *)buf = 136315650;
    v37 = "recoverReverseStore";
    v38 = 1024;
    v39 = 4484;
    v40 = 2080;
    v41 = a2;
    v24 = "%s:%d: Copy file failed for %s";
    v25 = buf;
LABEL_24:
    _os_log_error_impl(&dword_1B8270000, v23, OS_LOG_TYPE_ERROR, v24, v25, 0x1Cu);
    goto LABEL_15;
  }
  v13 = (char *)fd_create_protected(a1, a2, 0, 0);
  bzero(buf, 0x440uLL);
  v14 = fd_pread(v13, buf, 0x440uLL, 0);
  fd_release(v13);
  if (v14 != 1088)
  {
    v22 = *__error();
    v23 = _SILogForLogForCategory(6);
    if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      goto LABEL_15;
    *(_DWORD *)v32 = 136315650;
    v33 = "recoverReverseStore";
    v34 = 1024;
    *(_DWORD *)v35 = 4496;
    *(_WORD *)&v35[4] = 2080;
    *(_QWORD *)&v35[6] = a2;
    v24 = "%s:%d: Failed to read reverse store file %s";
    v25 = v32;
    goto LABEL_24;
  }
  v15 = (char *)fd_create_protected(a1, a3, 2, 0);
  v31 = 0;
  v16 = _fd_acquire_fd((uint64_t)v15, &v31);
  prot_fsync(v16, 1);
  v17 = v42;
  v42 = 0;
  if (prot_pwrite_guarded(v16, (uint64_t)&v31, (uint64_t)buf, 0x440uLL, 0) != 1088)
  {
    v27 = *__error();
    v28 = _SILogForLogForCategory(6);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v32 = 136315650;
      v33 = "recoverReverseStore";
      v34 = 1024;
      *(_DWORD *)v35 = 4511;
      *(_WORD *)&v35[4] = 2080;
      *(_QWORD *)&v35[6] = a3;
      _os_log_error_impl(&dword_1B8270000, v28, OS_LOG_TYPE_ERROR, "%s:%d: Failed to write reverse store header %s", v32, 0x1Cu);
    }
    *__error() = v27;
    goto LABEL_19;
  }
  prot_fsync(v16, 1);
  if (a5 && v17 != -1073623027 && v17 != -804450864)
  {
    v29 = *__error();
    v30 = _SILogForLogForCategory(6);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v32 = 136315650;
      v33 = "recoverReverseStore";
      v34 = 1024;
      *(_DWORD *)v35 = 4523;
      *(_WORD *)&v35[4] = 1024;
      *(_DWORD *)&v35[6] = v17;
      _os_log_error_impl(&dword_1B8270000, v30, OS_LOG_TYPE_ERROR, "%s:%d: Unexpected state in shadow header %x", v32, 0x18u);
    }
    *__error() = v29;
LABEL_19:
    _fd_release_fd(v15, v16, 0, v31);
    fd_release(v15);
    return 0;
  }
  v42 = -1073623027;
  prot_pwrite_guarded(v16, (uint64_t)&v31, (uint64_t)buf, 0x440uLL, 0);
  _fd_release_fd(v15, v16, 0, v31);
  fd_release(v15);
  v18 = *__error();
  v19 = _SILogForLogForCategory(6);
  v20 = 2 * (dword_1EF19FCA4 < 4);
  if (os_log_type_enabled(v19, v20))
  {
    *(_DWORD *)v32 = 136315650;
    v33 = a2;
    v34 = 2080;
    *(_QWORD *)v35 = a3;
    *(_WORD *)&v35[8] = 1024;
    *(_DWORD *)&v35[10] = v17;
    _os_log_impl(&dword_1B8270000, v19, v20, "Successfully recovered from %s to %s with state %x", v32, 0x1Cu);
  }
  *__error() = v18;
  return 1;
}

uint64_t get_state(uint64_t a1)
{
  int32_t v2;
  uint64_t v3;
  int v4;
  unint64_t v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  void (*v11)(_QWORD);
  int v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  void (*v16)(_QWORD);
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  int v26;
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v22 = -559038737;
  if (storageResolvePtr(a1, 0, 1uLL, 1))
  {
    v2 = OSAtomicIncrement32((int32_t *)exceptionSequenceNum);
    v3 = *(_QWORD *)(a1 + 216);
    if (v3)
      v4 = *(_DWORD *)(v3 + 44);
    else
      v4 = -1;
    v5 = setThreadIdAndInfo(v4, sStorageExceptionCallbacks, a1, 1, v2);
    v20 = HIDWORD(v5);
    v21 = v5;
    v18 = v7;
    v19 = v6;
    v8 = *(_QWORD *)&threadData[18 * v5 + 2];
    v9 = v8 + 320 * HIDWORD(v5);
    v10 = *(_DWORD *)(v9 + 312);
    v11 = *(void (**)(_QWORD))(v9 + 224);
    if (v11)
      v11(*(_QWORD *)(v8 + 320 * HIDWORD(v5) + 288));
    if (_setjmp((int *)v9))
    {
      v12 = *__error();
      v13 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        v24 = "get_state";
        v25 = 1024;
        v26 = 4475;
        _os_log_error_impl(&dword_1B8270000, v13, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
      }
      *__error() = v12;
      *(_DWORD *)(v9 + 312) = v10;
      CIOnThreadCleanUpReset(v18);
      dropThreadId(v21, 1, v2);
      CICleanUpReset(v21, v19);
    }
    else
    {
      if (*(_QWORD *)(a1 + 232) < 0x440uLL)
        v22 = 0;
      else
        v22 = *((_DWORD *)storageResolvePtr(a1, 0x40uLL, 0x400uLL, 1) + 1);
      v14 = *(_QWORD *)&threadData[18 * v21 + 2];
      v15 = v14 + 320 * v20;
      *(_DWORD *)(v15 + 312) = v10;
      v16 = *(void (**)(_QWORD))(v15 + 232);
      if (v16)
        v16(*(_QWORD *)(v14 + 320 * v20 + 288));
      dropThreadId(v21, 0, v2);
    }
  }
  return v22;
}

uint64_t _reverseStoreValidate(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  int32_t v3;
  unint64_t v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  void (*v10)(_QWORD);
  int v11;
  NSObject *v12;
  int v13;
  NSObject *v14;
  os_log_type_t v15;
  _BOOL8 v16;
  unsigned __int16 *Page;
  int8x8_t v18;
  _BOOL8 v19;
  uint64_t v20;
  uint64_t v21;
  void (*v22)(_QWORD);
  char *v23;
  char *v24;
  const char *v25;
  uint64_t v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  uint64_t v31;
  unsigned int *v32;
  uint64_t v33;
  uint8_t buf[4];
  const char *v35;
  __int16 v36;
  int v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  if (!result)
    return result;
  v1 = result;
  v2 = result + 4416;
  _db_write_lock(result + 4416);
  v31 = 0;
  v32 = 0;
  v33 = 0;
  storage_reader_init(v1, (uint64_t)&v31);
  if ((_BYTE)v33)
  {
    v3 = OSAtomicIncrement32((int32_t *)exceptionSequenceNum);
    v4 = setThreadIdAndInfo(-1, sStorageReaderExceptionCallbacks, (uint64_t)&v31, 0, v3);
    v29 = HIDWORD(v4);
    v30 = v4;
    v27 = v6;
    v28 = v5;
    v7 = *(_QWORD *)&threadData[18 * v4 + 2];
    v8 = v7 + 320 * HIDWORD(v4);
    v9 = *(_DWORD *)(v8 + 312);
    v10 = *(void (**)(_QWORD))(v8 + 224);
    if (v10)
      v10(*(_QWORD *)(v7 + 320 * HIDWORD(v4) + 288));
    if (!_setjmp((int *)v8))
    {
      buf[0] = 0;
      Page = _directoryStoreReaderGetPage(&v31, 0x440uLL, (BOOL *)buf);
      if (!Page || buf[0])
      {
        if (Page)
        {
          v23 = __si_assert_copy_extra(*(_DWORD **)(v1 + 216));
          v24 = v23;
          v25 = "";
          if (v23)
            v25 = v23;
          __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 3988, "(!page)", v25);
          free(v24);
          if (__valid_fsp(*(_DWORD **)(v1 + 216)))
            v26 = 2989;
          else
            v26 = 3072;
          *(_DWORD *)v26 = -559038737;
          abort();
        }
        v19 = 0;
      }
      else
      {
        v19 = _reverseStoreValidateTreePage(&v31, Page, (unsigned __int16 *)0x440, 0, v18);
      }
      v20 = *(_QWORD *)&threadData[18 * v30 + 2];
      v21 = v20 + 320 * v29;
      *(_DWORD *)(v21 + 312) = v9;
      v22 = *(void (**)(_QWORD))(v21 + 232);
      if (v22)
        v22(*(_QWORD *)(v20 + 320 * v29 + 288));
      dropThreadId(v30, 0, v3);
      v16 = v19;
      goto LABEL_21;
    }
    v11 = *__error();
    v12 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v35 = "_reverseStoreValidate";
      v36 = 1024;
      v37 = 3990;
      _os_log_error_impl(&dword_1B8270000, v12, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
    }
    *__error() = v11;
    *(_DWORD *)(v8 + 312) = v9;
    CIOnThreadCleanUpReset(v27);
    dropThreadId(v30, 1, v3);
    CICleanUpReset(v30, v28);
  }
  else
  {
    v13 = *__error();
    v14 = _SILogForLogForCategory(0);
    v15 = 2 * (gSILogLevels[0] < 4);
    if (os_log_type_enabled(v14, v15))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1B8270000, v14, v15, "Skipping because index is shut down", buf, 2u);
    }
    *__error() = v13;
  }
  v16 = 0;
LABEL_21:
  db_write_unlock(v2);
  if (v32)
    _release_read_window(&availableReaders, v32);
  return v16;
}

BOOL _reverseStoreValidateTreePage(uint64_t *a1, unsigned __int16 *a2, unsigned __int16 *a3, int a4, int8x8_t a5)
{
  unsigned __int16 *v7;
  unint64_t Size;
  int v9;
  int *v10;
  int *v11;
  int v12;
  NSObject *v13;
  os_log_type_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t *v17;
  unint64_t v18;
  unsigned __int16 *Page;
  int8x8_t v20;
  unsigned __int16 *v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  int v25;
  int *v26;
  int *v27;
  NSObject *v28;
  os_log_type_t v29;
  unint64_t v30;
  uint64_t *v31;
  unsigned __int16 *v32;
  int v33;
  NSObject *v34;
  int v35;
  NSObject *v36;
  int v37;
  NSObject *v38;
  char *v40;
  char *v41;
  const char *v42;
  uint64_t v43;
  int v44;
  int v45;
  NSObject *v46;
  int v47;
  unsigned __int16 *v48;
  int v50;
  uint64_t v51;
  int v52;
  unsigned int v53;
  BOOL v54;
  uint8_t buf[4];
  unsigned __int16 *v56;
  __int16 v57;
  _BYTE v58[10];
  __int16 v59;
  _QWORD v60[4];

  v7 = a2;
  *(_QWORD *)((char *)&v60[2] + 6) = *MEMORY[0x1E0C80C00];
  Size = directoryTreePageGetSize(*a2, *((_BYTE *)a2 + 2), a5);
  v9 = v7[3];
  v10 = (int *)&unk_1EF19F000;
  if (dword_1EF19FCA4 >= 5)
  {
    v44 = v7[2];
    v45 = *__error();
    v46 = _SILogForLogForCategory(6);
    if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 134219008;
      v56 = v7;
      v57 = 1024;
      *(_DWORD *)v58 = a4;
      *(_WORD *)&v58[4] = 1024;
      *(_DWORD *)&v58[6] = v9;
      v59 = 1024;
      LODWORD(v60[0]) = v44;
      WORD2(v60[0]) = 1024;
      *(_DWORD *)((char *)v60 + 6) = Size;
      _os_log_impl(&dword_1B8270000, v46, OS_LOG_TYPE_DEFAULT, "Tree page:%p level: %d depth: %d origin: %d size: %d", buf, 0x24u);
    }
    *__error() = v45;
    v10 = (_DWORD *)&unk_1EF19F000;
  }
  if (v9 != a4)
  {
    v11 = v10;
    v12 = *__error();
    v13 = _SILogForLogForCategory(6);
    v14 = v11[809] < 3;
    if (os_log_type_enabled(v13, v14))
    {
      *(_DWORD *)buf = 134218496;
      v56 = a3;
      v57 = 1024;
      *(_DWORD *)v58 = v9;
      *(_WORD *)&v58[4] = 1024;
      *(_DWORD *)&v58[6] = a4;
      _os_log_impl(&dword_1B8270000, v13, v14, "*warn* Flat page: 0x%8.8llx depth: %d exected: %d", buf, 0x18u);
    }
    *__error() = v12;
    v10 = (int *)&unk_1EF19F000;
  }
  if (Size)
  {
    v47 = v9;
    v15 = 0;
    v53 = a4 + 1;
    v16 = 1;
    v17 = a1;
    v48 = v7;
    do
    {
      v18 = *(_QWORD *)&v7[4 * v15 + 4];
      if (v18)
      {
        if (v10[809] >= 5)
        {
          v35 = *__error();
          v36 = _SILogForLogForCategory(6);
          if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 134218752;
            v56 = v7;
            v57 = 1024;
            *(_DWORD *)v58 = v47;
            *(_WORD *)&v58[4] = 1024;
            *(_DWORD *)&v58[6] = v15;
            v59 = 2048;
            v60[0] = v18;
            _os_log_impl(&dword_1B8270000, v36, OS_LOG_TYPE_DEFAULT, "page:%p depth: %d idx: %d offset: 0x%8.8llx", buf, 0x22u);
          }
          *__error() = v35;
        }
        v54 = 0;
        Page = _directoryStoreReaderGetPage(v17, v18, &v54);
        if (!Page)
          return v16;
        v21 = Page;
        if (v54)
        {
          directoryStorePageGetSize(Page, v20);
          v23 = *v21;
          if ((64 << *((_BYTE *)v21 + 2)) - 8 < (int)v23)
          {
            v40 = __si_assert_copy_extra(0);
            v41 = v40;
            v42 = "";
            if (v40)
              v42 = v40;
            __message_assert("%s:%u: failed assertion '%s' %s Got end %d and size %d", "FileTree.c", 287, "storePageEnd((StorePageRef)page) <= storePageDataSize((StorePageRef)page)", v42, *v21, (64 << *((_BYTE *)v21 + 2)) - 8);
            free(v41);
            if (__valid_fs(-1))
              v43 = 2989;
            else
              v43 = 3072;
            *(_DWORD *)v43 = -559038737;
            abort();
          }
          v24 = v22;
          v25 = v21[3];
          v26 = (int *)&unk_1EF19F000;
          if (dword_1EF19FCA4 >= 5)
          {
            v52 = v21[2];
            v37 = *__error();
            v38 = _SILogForLogForCategory(6);
            if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 134219008;
              v56 = v21;
              v57 = 1024;
              *(_DWORD *)v58 = v53;
              *(_WORD *)&v58[4] = 1024;
              *(_DWORD *)&v58[6] = v25;
              v59 = 1024;
              LODWORD(v60[0]) = v52;
              WORD2(v60[0]) = 1024;
              *(_DWORD *)((char *)v60 + 6) = v24;
              _os_log_impl(&dword_1B8270000, v38, OS_LOG_TYPE_DEFAULT, "Flat page:%p level: %d depth: %d origin: %d size: %d", buf, 0x24u);
            }
            *__error() = v37;
            v7 = v48;
            v17 = a1;
            v26 = (_DWORD *)&unk_1EF19F000;
          }
          if (v53 != v25)
          {
            v27 = v26;
            v50 = *__error();
            v28 = _SILogForLogForCategory(6);
            v29 = v27[809] < 3;
            if (os_log_type_enabled(v28, v29))
            {
              *(_DWORD *)buf = 134218496;
              v56 = (unsigned __int16 *)v18;
              v57 = 1024;
              *(_DWORD *)v58 = v25;
              *(_WORD *)&v58[4] = 1024;
              *(_DWORD *)&v58[6] = v53;
              _os_log_impl(&dword_1B8270000, v28, v29, "*warn* Flat page: 0x%8.8llx depth: %d exected: %d", buf, 0x18u);
            }
            *__error() = v50;
            v7 = v48;
            v17 = a1;
            v26 = (int *)&unk_1EF19F000;
          }
          v30 = v23 >> 4;
          if (v24)
          {
            v31 = (uint64_t *)(v21 + 8);
            do
            {
              v32 = (unsigned __int16 *)*(v31 - 1);
              if (v32)
              {
                --v30;
                if (v26[809] >= 5)
                {
                  v51 = *v31;
                  v33 = *__error();
                  v34 = _SILogForLogForCategory(6);
                  if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)buf = 134218240;
                    v56 = v32;
                    v57 = 2048;
                    *(_QWORD *)v58 = v51;
                    _os_log_impl(&dword_1B8270000, v34, OS_LOG_TYPE_DEFAULT, "oid: %lld parent: %lld", buf, 0x16u);
                  }
                  *__error() = v33;
                  v17 = a1;
                  v26 = (_DWORD *)&unk_1EF19F000;
                }
              }
              v31 += 2;
              --v24;
            }
            while (v24);
          }
          if (v30)
            return v16;
        }
        else if ((_reverseStoreValidateTreePage(v17, Page, v18, v53) & 1) != 0)
        {
          return v16;
        }
        v10 = (_DWORD *)&unk_1EF19F000;
      }
      v16 = ++v15 < Size;
    }
    while (v15 != Size);
  }
  return 0;
}

uint64_t reverseStoreNeedsRecover(int a1)
{
  char *v1;
  unsigned int v3;

  v1 = (char *)fd_create_protected(a1, "reverseDirectoryStore", 0, 0);
  v3 = 0;
  if (fd_pread(v1, &v3, 4uLL, 68) != 4)
    v3 = 0;
  fd_release(v1);
  return v3;
}

uint64_t reverseStoreUpdateState(uint64_t a1, int a2, _BYTE *a3)
{
  uint64_t updated;
  uint64_t v7;
  int v8;
  uint64_t v9;
  int v10;
  NSObject *v11;
  unsigned int v13;
  int v14;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  int v20;
  __int16 v21;
  int v22;
  __int16 v23;
  int v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v14 = 0;
  *a3 = 0;
  switch(a2)
  {
    case 1:
      updated = _reverseStoreUpdateState(a1, 0);
      if ((_DWORD)updated)
      {
        v7 = updated;
        v8 = 4681;
        goto LABEL_11;
      }
      if (isRegisteredForCloning(a1)
        && (copyFileFallback(a1, "reverseDirectoryStore.shadow", a1, "reverseDirectoryStore", &v14, 0, 1) & 1) != 0
        || (recoverReverseStore(a1, "reverseDirectoryStore.shadow", "reverseDirectoryStore", &v14, 1) & 1) != 0)
      {
        v7 = _reverseStoreUpdateState(a1, -1073623027);
        if (!(_DWORD)v7)
          goto LABEL_26;
        v8 = 4698;
      }
      else
      {
        v13 = *__error();
        if (v13)
          v7 = v13;
        else
          v7 = 0xFFFFFFFFLL;
        v8 = 4691;
      }
      goto LABEL_11;
    case 2:
      v7 = _reverseStoreUpdateState(a1, 2);
      if ((_DWORD)v7)
      {
        v8 = 4706;
        goto LABEL_11;
      }
      *a3 = 2;
      return v7;
    case 3:
      v9 = _reverseStoreUpdateState(a1, -804450864);
      if ((_DWORD)v9)
      {
        v7 = v9;
        v8 = 4715;
      }
      else if (isRegisteredForCloning(a1)
             && (copyFileFallback(a1, "reverseDirectoryStore", a1, "reverseDirectoryStore.shadow", &v14, 0, 1) & 1) != 0
             || recoverReverseStore(a1, "reverseDirectoryStore", "reverseDirectoryStore.shadow", &v14, 0))
      {
        v7 = _reverseStoreUpdateState(a1, -1073623027);
        if (!(_DWORD)v7)
        {
LABEL_26:
          *a3 = 4;
          return v7;
        }
        v8 = 4731;
      }
      else
      {
        v7 = 0xFFFFFFFFLL;
        v8 = 4725;
      }
LABEL_11:
      v10 = *__error();
      v11 = _SILogForLogForCategory(6);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136316162;
        v16 = "reverseStoreUpdateState";
        v17 = 1024;
        v18 = 4750;
        v19 = 1024;
        v20 = a2;
        v21 = 1024;
        v22 = v7;
        v23 = 1024;
        v24 = v8;
        _os_log_error_impl(&dword_1B8270000, v11, OS_LOG_TYPE_ERROR, "%s:%d: update state (%d) failed err:%d at %d", buf, 0x24u);
      }
      *__error() = v10;
      return v7;
    case 4:
      v7 = _reverseStoreUpdateState(a1, -1073623027);
      if (!(_DWORD)v7)
        goto LABEL_26;
      v8 = 4739;
      goto LABEL_11;
    default:
      return 0;
  }
}

uint64_t _reverseStoreUpdateState(int a1, int a2)
{
  char *v3;
  char *v4;
  uint64_t v5;
  unsigned int v6;
  int v8;

  v3 = (char *)fd_create_protected(a1, "reverseDirectoryStore", 2, 0);
  v4 = v3;
  if (v3
    && (v8 = 0, fd_pread(v3, &v8, 4uLL, 68) == 4)
    && (v8 == a2 || (v8 = a2, fd_pwrite((uint64_t)v4, (uint64_t)&v8, 4uLL, 68) == 4)))
  {
    v5 = 0;
  }
  else
  {
    v6 = *__error();
    if (v6)
      v5 = v6;
    else
      v5 = 0xFFFFFFFFLL;
  }
  fd_release(v4);
  return v5;
}

uint64_t reverseStoreRestoreDirtyBitmap(int a1, uint64_t a2)
{
  char *v3;
  size_t v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t v7;
  UInt8 *v8;
  int v9;
  int v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  int v15;
  CFIndex v16;
  unint64_t v17;
  size_t v18;
  uint64_t v19;
  char *v20;
  UInt8 *v21;
  size_t v22;
  size_t v23;
  CFBitVectorRef v24;
  const __CFBitVector *v25;
  CFIndex i;
  CFBit v27;
  uint64_t v28;
  int v30;
  int v31;
  off_t v32;
  char *v33;
  size_t v34;
  off_t v35;
  off_t v36;
  unint64_t v37;
  unsigned int __fd;
  uint64_t v39;
  char *v40;
  __int128 v41;
  off_t __offseta[2];
  __int128 v43;
  void *__buf[2];
  char __dst;

  v43 = 0u;
  *(_OWORD *)__buf = 0u;
  v41 = 0u;
  *(_OWORD *)__offseta = 0u;
  v3 = (char *)fd_create_protected(a1, "reverseStore.updates", 0, 0);
  if (!store_stream_init((uint64_t)&v41, v3, 0))
  {
    v8 = 0;
    goto LABEL_24;
  }
  v4 = v43;
  v40 = v3;
  if ((_QWORD)v43 - *((_QWORD *)&v43 + 1) < 6uLL)
  {
    v31 = 0;
    v6 = 0;
    __dst = 0;
    while (store_stream_read_bytes((unsigned int *)&v41, &__dst) == 1)
    {
      v6 |= (__dst & 0x7F) << v31;
      v31 += 7;
      if ((__dst & 0x80) == 0)
        goto LABEL_40;
    }
    v6 = 0;
LABEL_40:
    v7 = *((_QWORD *)&v43 + 1);
    v4 = v43;
    goto LABEL_13;
  }
  v5 = *((_QWORD *)&v43 + 1) + 1;
  v6 = *((unsigned __int8 *)__buf[0] + *((_QWORD *)&v43 + 1));
  if (*((char *)__buf[0] + *((_QWORD *)&v43 + 1)) < 0)
  {
    v7 = *((_QWORD *)&v43 + 1) + 2;
    v9 = *((char *)__buf[0] + v5);
    v10 = *((unsigned __int8 *)__buf[0] + v5);
    if (v9 < 0)
    {
      v11 = *((_QWORD *)&v43 + 1) + 3;
      v12 = *((unsigned __int8 *)__buf[0] + v7);
      if (*((char *)__buf[0] + v7) < 0)
      {
        v7 = *((_QWORD *)&v43 + 1) + 4;
        v14 = *((char *)__buf[0] + v11);
        v15 = *((unsigned __int8 *)__buf[0] + v11);
        if (v14 < 0)
        {
          v30 = *((char *)__buf[0] + v7);
          if (v30 < 0)
          {
            v7 = *((_QWORD *)&v43 + 1) + 5;
            v6 = ((v15 & 0x7F) << 21) | (v30 << 28) | ((v12 & 0x7F) << 14) | ((v10 & 0x7F) << 7) | v6 & 0x7F;
          }
          else
          {
            v6 = 0;
            LODWORD(__offseta[0]) = 22;
            v7 = *((_QWORD *)&v43 + 1) + 5;
          }
          goto LABEL_13;
        }
        v13 = ((v12 & 0x7F) << 14) | (v15 << 21) | ((v10 & 0x7F) << 7) | v6 & 0x7F;
      }
      else
      {
        v13 = ((v10 & 0x7F) << 7) | (v12 << 14) | v6 & 0x7F;
        v7 = *((_QWORD *)&v43 + 1) + 3;
      }
      v6 = v13;
    }
    else
    {
      v6 = v6 & 0x7F | (v10 << 7);
    }
  }
  else
  {
    v7 = *((_QWORD *)&v43 + 1) + 1;
  }
LABEL_13:
  v16 = v6;
  v17 = v6 + 7;
  v18 = v17 >> 3;
  v8 = (UInt8 *)malloc_type_malloc(v17 >> 3, 0xD92774D1uLL);
  bit_vector_init(a2);
  if (v7 + (v17 >> 3) > v4)
  {
    v39 = 0;
    __fd = v41;
    v22 = v17 >> 3;
    v21 = v8;
    v20 = (char *)__buf[0];
    v32 = __offseta[1];
    while (1)
    {
      v23 = v4 - v7;
      if (v4 != v7)
      {
        v33 = &v20[v7];
        v34 = v4 - v7;
        v35 = v32;
        memcpy(v21, v33, v34);
        v32 = v35;
      }
      v36 = v32;
      v37 = prot_pread(__fd, v20, v4, v32);
      if (v37 == -1)
      {
        *(_QWORD *)&v43 = v4;
        *((_QWORD *)&v43 + 1) = v4;
        __offseta[1] = v36;
        v23 = 0;
        LODWORD(__offseta[0]) = *__error();
        goto LABEL_43;
      }
      v32 = v36 + v37;
      if (!v37)
        break;
      v7 = 0;
      v21 += v23;
      v22 -= v23;
      v39 += v23;
      v4 = v37;
      if (v22 <= v37)
      {
        v7 = 0;
        __offseta[1] = v32;
        *(_QWORD *)&v43 = v37;
        v19 = v39;
        goto LABEL_15;
      }
    }
    v43 = 0uLL;
    __offseta[1] = v36;
LABEL_43:
    v19 = v39;
  }
  else
  {
    v19 = 0;
    v20 = (char *)__buf[0];
    v21 = v8;
    v22 = v18;
LABEL_15:
    memcpy(v21, &v20[v7], v22);
    *((_QWORD *)&v43 + 1) = v7 + v22;
    v23 = v22;
  }
  if (v23 + v19 == v18 && (v24 = CFBitVectorCreate(0, v8, v16)) != 0)
  {
    v25 = v24;
    if ((_DWORD)v16)
    {
      for (i = 0; i != v16; ++i)
      {
        v27 = CFBitVectorGetBitAtIndex(v25, i) != 0;
        bit_vector_internal_touch_for_set_3277((CFIndex *)a2, i);
        CFBitVectorSetBitAtIndex(*(CFMutableBitVectorRef *)(a2 + 16), i, v27);
      }
    }
    CFRelease(v25);
  }
  else
  {
    LODWORD(__offseta[0]) = -1;
  }
  v3 = v40;
LABEL_24:
  v28 = LODWORD(__offseta[0]);
  free(v8);
  store_stream_destroy((uint64_t)&v41);
  fd_release(v3);
  return v28;
}

uint64_t reverseStoreStoreDirtyBitmap(uint64_t a1)
{
  uint64_t v2;
  BOOL v3;
  uint64_t v4;
  uint64_t v5;
  size_t v6;
  UInt8 *v7;
  UInt8 *v8;
  char *sibling_protected;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _BYTE *v13;
  uint64_t v14;
  _BYTE *v15;
  CFRange v16;
  uint64_t v17;
  size_t v18;
  size_t v19;
  UInt8 *v20;
  uint64_t v21;
  _BYTE *v23;
  char *v24;
  char *v25;
  const char *v26;
  uint64_t v27;
  size_t v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  _OWORD __src[2];
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD *)(a1 + 4368);
  v4 = v2 + 7;
  v3 = v2 < -7;
  v5 = v2 + 14;
  if (!v3)
    v5 = v4;
  v6 = v5 >> 3;
  v7 = (UInt8 *)malloc_type_malloc(v5 >> 3, 0xD1F13C74uLL);
  if (!v7)
  {
    v24 = __si_assert_copy_extra(0);
    v25 = v24;
    v26 = "";
    if (v24)
      v26 = v24;
    __message_assert("%s:%u: failed assertion '%s' %s ", "FileTree.c", 4825, "bits", v26);
    free(v25);
    if (__valid_fs(-1))
      v27 = 2989;
    else
      v27 = 3072;
    *(_DWORD *)v27 = -559038737;
    abort();
  }
  v8 = v7;
  v31 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  sibling_protected = (char *)fd_create_sibling_protected(*(_QWORD *)(a1 + 216), "reverseStore.updates", 1538, 0);
  if ((store_stream_init((uint64_t)&v29, sibling_protected, 1) & 1) != 0)
  {
    v10 = *(_QWORD *)(a1 + 4368);
    v11 = *((_QWORD *)&v31 + 1);
    if ((_QWORD)v31 - *((_QWORD *)&v31 + 1) < 6uLL)
    {
      memset(__src, 0, sizeof(__src));
      if (v10 >> 28)
      {
        LOBYTE(__src[0]) = v10 | 0x80;
        BYTE1(__src[0]) = (v10 >> 7) | 0x80;
        BYTE2(__src[0]) = (v10 >> 14) | 0x80;
        BYTE3(__src[0]) = (v10 >> 21) | 0x80;
        BYTE4(__src[0]) = v10 >> 28;
        v28 = 5;
      }
      else if ((v10 & 0xFE00000) != 0)
      {
        LOBYTE(__src[0]) = v10 | 0x80;
        BYTE1(__src[0]) = (v10 >> 7) | 0x80;
        BYTE2(__src[0]) = (v10 >> 14) | 0x80;
        BYTE3(__src[0]) = (v10 & 0xFE00000) >> 21;
        v28 = 4;
      }
      else if ((v10 & 0x1FC000) != 0)
      {
        LOBYTE(__src[0]) = v10 | 0x80;
        BYTE1(__src[0]) = (v10 >> 7) | 0x80;
        BYTE2(__src[0]) = (v10 & 0x1FC000) >> 14;
        v28 = 3;
      }
      else if ((v10 & 0x3F80) != 0)
      {
        LOBYTE(__src[0]) = v10 | 0x80;
        BYTE1(__src[0]) = (unsigned __int16)(v10 & 0x3F80) >> 7;
        v28 = 2;
      }
      else
      {
        LOBYTE(__src[0]) = v10;
        v28 = 1;
      }
      store_stream_write_bytes((uint64_t)&v29, (char *)__src, v28);
    }
    else
    {
      v12 = v32;
      if (v10 >> 28)
      {
        v15 = (_BYTE *)(v32 + *((_QWORD *)&v31 + 1));
        *v15 = v10 | 0x80;
        v15[1] = (v10 >> 7) | 0x80;
        v15[2] = (v10 >> 14) | 0x80;
        v11 += 4;
        v15[3] = (v10 >> 21) | 0x80;
        LODWORD(v10) = v10 >> 28;
      }
      else if ((v10 & 0xFE00000) != 0)
      {
        v13 = (_BYTE *)(v32 + *((_QWORD *)&v31 + 1));
        *v13 = v10 | 0x80;
        v13[1] = (v10 >> 7) | 0x80;
        v11 += 3;
        v13[2] = (v10 >> 14) | 0x80;
        LODWORD(v10) = (v10 & 0xFE00000) >> 21;
      }
      else if ((v10 & 0x1FC000) != 0)
      {
        v23 = (_BYTE *)(v32 + *((_QWORD *)&v31 + 1));
        *v23 = v10 | 0x80;
        v11 += 2;
        v23[1] = (v10 >> 7) | 0x80;
        LODWORD(v10) = (v10 & 0x1FC000) >> 14;
      }
      else if ((v10 & 0x3F80) != 0)
      {
        *(_BYTE *)(v32 + *((_QWORD *)&v31 + 1)) = v10 | 0x80;
        ++v11;
        LODWORD(v10) = (unsigned __int16)(v10 & 0x3F80) >> 7;
      }
      *(_BYTE *)(v12 + v11) = v10;
      *((_QWORD *)&v31 + 1) = v11 + 1;
    }
    v16.length = *(_QWORD *)(a1 + 4368);
    if (v16.length)
    {
      v16.location = 0;
      CFBitVectorGetBits(*(CFBitVectorRef *)(a1 + 4384), v16, v8);
    }
    v17 = *((_QWORD *)&v31 + 1);
    v18 = v31;
    v19 = *((_QWORD *)&v31 + 1) + v6;
    v20 = v8;
    while (v19 >= v18)
    {
      v21 = v18 - v17;
      memcpy((void *)(v32 + v17), v20, v18 - v17);
      *((_QWORD *)&v31 + 1) += v21;
      if (store_stream_flush((unsigned int *)&v29, 0))
        goto LABEL_19;
      v20 += v21;
      v6 -= v21;
      v17 = *((_QWORD *)&v31 + 1);
      v18 = v31;
      v19 = *((_QWORD *)&v31 + 1) + v6;
    }
    memcpy((void *)(v32 + v17), v20, v6);
    *((_QWORD *)&v31 + 1) += v6;
LABEL_19:
    store_stream_flush((unsigned int *)&v29, 0);
    v14 = v30;
    store_stream_destroy((uint64_t)&v29);
  }
  else
  {
    v14 = v30;
  }
  fd_release(sibling_protected);
  free(v8);
  return v14;
}

void si_livequery_release2(uint64_t a1, uint64_t a2)
{
  si_livequery_release(a2);
}

void si_livequery_release(uint64_t a1)
{
  unsigned int v2;
  unsigned int v3;
  uint64_t v4;
  const void *v5;
  const void *v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;

  do
  {
    v2 = __ldaxr((unsigned int *)a1);
    v3 = v2 - 1;
  }
  while (__stlxr(v3, (unsigned int *)a1));
  if (!v3)
  {
    v4 = *(_QWORD *)(a1 + 8);
    si_querypipe_release(*(_QWORD *)(a1 + 40));
    v5 = *(const void **)(a1 + 16);
    if (v5)
      CFRelease(v5);
    v6 = *(const void **)(a1 + 24);
    if (v6)
      CFRelease(v6);
    free((void *)a1);
    v7 = (unsigned int *)(v4 + 584);
    do
    {
      v8 = __ldaxr(v7);
      v9 = v8 - 1;
    }
    while (__stlxr(v9, v7));
    if (!v9)
      si_query_free(v4);
  }
}

void si_perform_livequeries_directory_updates(uint64_t a1)
{
  uint64_t v1;
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  CFIndex Count;
  uint64_t v6;
  const void **v7;
  uint64_t v8;
  unsigned int *v9;
  unsigned int v10;
  uint64_t v11;
  const void *v12;
  dispatch_once_t *v13;
  uint64_t v14;
  _QWORD *scope_node;
  unsigned int *v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  const __CFArray *v22;
  CFIndex v23;
  __CFArray *Mutable;
  CFIndex v25;
  const __CFString *ValueAtIndex;
  CFTypeID v27;
  __CFArray *v28;
  const __CFString *v29;
  CFTypeID v30;
  CFIndex v31;
  CFIndex v32;
  const __CFString *v33;
  CFIndex Length;
  CFIndex v35;
  CFIndex v36;
  CFIndex v37;
  CFIndex v38;
  __CFArray *v39;
  CFStringRef v40;
  unsigned int *v41;
  unsigned int v42;
  int v43;
  NSObject *v44;
  uint64_t v45;
  __CFArray *theArray;
  const __CFString *cf2;
  CFIndex v48;
  const __CFString *prefix;
  _QWORD *v50;
  CFIndex v51;
  uint64_t v52;
  const __CFAllocator *alloc;
  uint64_t v54;
  uint64_t v55;
  CFStringRef cf1;
  char v57;
  _QWORD v58[8];
  uint64_t v59;
  uint64_t *v60;
  uint64_t v61;
  char v62;
  _QWORD v63[3];
  char v64;
  void *values[1024];
  int v66;
  const char *v67;
  __int16 v68;
  CFStringRef v69;
  __int16 v70;
  uint64_t v71;
  __int16 v72;
  __CFArray *v73;
  _QWORD v74[131];

  v1 = MEMORY[0x1E0C80A78](a1);
  v3 = v2;
  v4 = v1;
  v74[128] = *MEMORY[0x1E0C80C00];
  bzero(values, 0x2000uLL);
  pthread_mutex_lock((pthread_mutex_t *)(v4 + 1712));
  Count = CFSetGetCount(*(CFSetRef *)(v4 + 1776));
  v6 = Count;
  if (Count >= 1024)
  {
    v7 = (const void **)malloc_type_malloc(8 * Count, 0x2004093837F09uLL);
    CFSetGetValues(*(CFSetRef *)(v4 + 1776), v7);
  }
  else if (!Count
         || (v7 = (const void **)values, CFSetGetValues(*(CFSetRef *)(v4 + 1776), (const void **)values), v6 < 1))
  {
    pthread_mutex_unlock((pthread_mutex_t *)(v4 + 1712));
    return;
  }
  v8 = 0;
  do
  {
    v9 = (unsigned int *)v7[v8];
    do
      v10 = __ldaxr(v9);
    while (__stlxr(v10 + 1, v9));
    ++v8;
  }
  while (v8 != v6);
  pthread_mutex_unlock((pthread_mutex_t *)(v4 + 1712));
  v11 = 0;
  alloc = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v50 = v3;
  v52 = v4;
  v54 = v6;
  do
  {
    v12 = v7[v11];
    v13 = (dispatch_once_t *)*((_QWORD *)v12 + 1);
    v14 = *((_QWORD *)v12 + 5);
    v63[0] = 0;
    v63[1] = v63;
    v63[2] = 0x2000000000;
    v64 = 0;
    v59 = 0;
    v60 = &v59;
    v61 = 0x2000000000;
    v62 = 0;
    scope_node = si_query_get_scope_node(v4, v13, 0);
    v58[0] = MEMORY[0x1E0C809B0];
    v58[1] = 0x40000000;
    v58[2] = __si_query_evaluate_move_block_invoke;
    v58[3] = &unk_1E6E35248;
    v58[6] = v4;
    v58[7] = v3;
    v58[4] = &v59;
    v58[5] = v63;
    v74[0] = MEMORY[0x1E0C809B0];
    v74[1] = 0x40000000;
    v74[2] = __db_query_tree_apply_block_block_invoke;
    v74[3] = &unk_1E6E377F8;
    v74[4] = v58;
    db_query_tree_apply_block_with_meta(scope_node, (uint64_t)v74, 0);
    if (!*((_BYTE *)v60 + 24))
      goto LABEL_20;
    v55 = (uint64_t)v13;
    v16 = (unsigned int *)malloc_type_calloc(1uLL, 0x70uLL, 0x10A004060519A17uLL);
    v17 = (uint64_t)v16;
    atomic_store(1u, v16);
    do
      v18 = __ldaxr((unsigned int *)v14);
    while (__stlxr(v18 + 1, (unsigned int *)v14));
    *((_QWORD *)v16 + 10) = v14;
    *((_OWORD *)v16 + 3) = *(_OWORD *)(v14 + 48);
    *((_QWORD *)v16 + 1) = 0;
    *((_QWORD *)v16 + 4) = 0;
    *((_QWORD *)v16 + 5) = 0;
    v16[26] = 1;
    *((_BYTE *)v16 + 99) = *(_BYTE *)(v14 + 99);
    *((_BYTE *)v16 + 96) = *(_BYTE *)(v14 + 96);
    v19 = *(_QWORD *)(v14 + 88);
    if (v19)
      CFRetain(*(CFTypeRef *)(v14 + 88));
    *(_QWORD *)(v17 + 88) = v19;
    bzero(v74, 0x400uLL);
    v20 = *(_QWORD *)(v4 + 1416);
    if (*(_BYTE *)(v20 + 240))
      goto LABEL_17;
    v21 = (const char *)(*(uint64_t (**)(uint64_t, _QWORD, _QWORD *, _QWORD, _QWORD, _QWORD, _QWORD, uint64_t))(v20 + 40))(v20, *v3, v74, 0, 0, 0, 0, -1);
    if (!v21)
      goto LABEL_17;
    cf1 = CFStringCreateWithFileSystemRepresentation(alloc, v21);
    v22 = (const __CFArray *)v13[24];
    if (!v22)
    {
      Mutable = CFArrayCreateMutable(alloc, 0, MEMORY[0x1E0C9B378]);
LABEL_64:
      v4 = v52;
      v40 = cf1;
      CFArrayAppendValue(Mutable, cf1);
      goto LABEL_65;
    }
    v23 = CFArrayGetCount((CFArrayRef)v13[24]);
    Mutable = CFArrayCreateMutable(alloc, 0, MEMORY[0x1E0C9B378]);
    if (!v23)
    {
      v3 = v50;
      goto LABEL_64;
    }
    if (v23 < 1)
    {
      v3 = v50;
      v4 = v52;
      v40 = cf1;
      goto LABEL_65;
    }
    v25 = 0;
    v57 = 0;
    v51 = v23;
    do
    {
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v22, v25);
      v27 = CFGetTypeID(ValueAtIndex);
      if (v27 == CFStringGetTypeID())
      {
        v28 = Mutable;
        v29 = ValueAtIndex;
LABEL_29:
        ProcessPathForScope(v28, v29, cf1);
        goto LABEL_37;
      }
      v30 = CFGetTypeID(ValueAtIndex);
      if (v30 == CFArrayGetTypeID())
      {
        v31 = CFArrayGetCount((CFArrayRef)ValueAtIndex);
        if (v31)
        {
          v32 = v31;
          v29 = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)ValueAtIndex, 0);
          if (v32 == 1)
          {
            v28 = Mutable;
            goto LABEL_29;
          }
          v33 = v29;
          if (CFEqual(cf1, v29))
          {
LABEL_35:
            CFArrayAppendValue(Mutable, ValueAtIndex);
          }
          else if (CFStringHasPrefix(v33, cf1))
          {
            Length = CFStringGetLength(cf1);
            if (CFStringGetCharacterAtIndex(v33, Length) == 47)
              goto LABEL_35;
          }
          else if (CFStringHasPrefix(cf1, v33))
          {
            cf2 = v33;
            v35 = CFStringGetLength(v33);
            if (CFStringGetCharacterAtIndex(cf1, v35) == 47)
            {
              theArray = CFArrayCreateMutable(alloc, v32, MEMORY[0x1E0C9B378]);
              CFArrayAppendValue(theArray, cf1);
              v23 = v51;
              if (v32 < 2)
              {
LABEL_55:
                if ((v57 & 1) != 0)
                  goto LABEL_58;
                v39 = theArray;
                CFArrayAppendValue(Mutable, theArray);
              }
              else
              {
                v36 = 1;
                while (1)
                {
                  v48 = v36;
                  prefix = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)ValueAtIndex, v36);
                  if (CFEqual(cf1, cf2))
                    break;
                  if (CFStringHasPrefix(cf1, prefix))
                  {
                    v37 = CFStringGetLength(prefix);
                    if (CFStringGetCharacterAtIndex(cf1, v37) == 47)
                      break;
                  }
                  else if (CFStringHasPrefix(prefix, cf1))
                  {
                    v38 = CFStringGetLength(cf1);
                    if (CFStringGetCharacterAtIndex(prefix, v38) == 47)
                      CFArrayAppendValue(theArray, prefix);
                  }
                  v36 = v48 + 1;
                  if (v32 == v48 + 1)
                    goto LABEL_55;
                }
                v57 = 1;
LABEL_58:
                v39 = theArray;
              }
              CFRelease(v39);
              goto LABEL_37;
            }
          }
          v23 = v51;
        }
      }
LABEL_37:
      ++v25;
    }
    while (v25 < v23 && (v57 & 1) == 0);
    v3 = v50;
    v4 = v52;
    v40 = cf1;
    if ((v57 & 1) != 0)
    {
LABEL_66:
      CFRelease(Mutable);
      Mutable = 0;
      goto LABEL_67;
    }
LABEL_65:
    if (!CFArrayGetCount(Mutable))
      goto LABEL_66;
LABEL_67:
    if (dword_1EF19FC90 >= 5)
    {
      v43 = *__error();
      v44 = _SILogForLogForCategory(1);
      if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
      {
        v45 = *(_QWORD *)(v55 + 192);
        v66 = 136315906;
        v67 = "adds";
        v68 = 2112;
        v69 = cf1;
        v70 = 2112;
        v71 = v45;
        v72 = 2112;
        v73 = Mutable;
        _os_log_impl(&dword_1B8270000, v44, OS_LOG_TYPE_DEFAULT, "check (%s) %@ old:%@ new:%@", (uint8_t *)&v66, 0x2Au);
      }
      *__error() = v43;
      v40 = cf1;
    }
    CFRelease(v40);
    if (Mutable)
    {
      v41 = (unsigned int *)(v17 + 64);
      do
        v42 = __ldxr(v41);
      while (__stxr(v42 + 1, v41));
      _queryGoCracked(v55, v4, Mutable, v17);
      CFRelease(Mutable);
      si_querypipe_remove_process(v17, v55, 0, 0);
    }
LABEL_17:
    if (v17 != v14)
      si_querypipe_release(v17);
    v6 = v54;
LABEL_20:
    _Block_object_dispose(&v59, 8);
    _Block_object_dispose(v63, 8);
    si_livequery_release((uint64_t)v7[v11++]);
  }
  while (v11 != v6);
  if (v7 != (const void **)values)
    free(v7);
}

void si_perform_livequeries_bulk_updates(uint64_t a1)
{
  uint64_t v1;
  char v2;
  char v3;
  uint64_t v4;
  uint64_t v5;
  CFIndex Count;
  uint64_t v7;
  const void **v8;
  int v9;
  uint64_t v10;
  unsigned int *v11;
  unsigned int v12;
  unsigned int *v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  char v27;
  uint64_t v28;
  const void **v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36[5];
  void *values[1024];
  void (**v38)(SISearchCtx *__hidden);
  __int128 v39;
  __int128 v40;
  uint64_t v41;
  _BYTE v42[192];
  uint64_t v43;
  __int128 v44;
  __int128 v45;
  uint64_t v46;
  dispatch_time_t v47;
  int v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  int v52;
  uint64_t v53;
  uint64_t v54;
  int v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  uint64_t v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int16 v68;
  __int128 v69;
  __int128 v70;
  _BYTE v71[24];
  int v72;
  char v73;
  uint64_t v74;
  int v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  _BYTE v84[28];
  uint64_t v85;
  int v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  __int128 v103;
  __int16 v104;
  uint64_t v105;
  uint64_t v106;
  int v107;
  uint64_t v108;
  int v109;
  uint64_t v110;
  char v111;
  uint64_t v112;

  v1 = MEMORY[0x1E0C80A78](a1);
  v3 = v2;
  v31 = v4;
  v5 = v1;
  v112 = *MEMORY[0x1E0C80C00];
  bzero(values, 0x2000uLL);
  pthread_mutex_lock((pthread_mutex_t *)(v5 + 1712));
  Count = CFSetGetCount(*(CFSetRef *)(v5 + 1776));
  v7 = Count;
  if (Count >= 1024)
  {
    v8 = (const void **)malloc_type_malloc(8 * Count, 0x2004093837F09uLL);
    CFSetGetValues(*(CFSetRef *)(v5 + 1776), v8);
  }
  else
  {
    if (!Count)
    {
      v9 = 0;
      v8 = (const void **)values;
      goto LABEL_12;
    }
    v8 = (const void **)values;
    CFSetGetValues(*(CFSetRef *)(v5 + 1776), (const void **)values);
    if (v7 < 1)
    {
      v9 = 0;
      goto LABEL_12;
    }
  }
  v10 = 0;
  do
  {
    v11 = (unsigned int *)v8[v10];
    do
      v12 = __ldaxr(v11);
    while (__stlxr(v12 + 1, v11));
    ++v10;
  }
  while (v10 != v7);
  v9 = 1;
LABEL_12:
  pthread_mutex_unlock((pthread_mutex_t *)(v5 + 1712));
  if ((v3 & 1) != 0)
  {
    v13 = (unsigned int *)(v5 + 1452);
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 + 1, v13));
    si_scheduler_suspend(*(_QWORD *)(v5 + 872));
    do
      v15 = __ldaxr(v13);
    while (__stlxr(v15 - 1, v13));
  }
  v27 = v3;
  if (v9)
  {
    v16 = 0;
    v28 = v7;
    v29 = v8;
    do
    {
      v17 = v8[v16];
      v34 = v17[5];
      v18 = *(_QWORD *)(v34 + 88);
      if (v18)
        v33 = *(_QWORD *)(v18 + 120);
      else
        v33 = 0;
      v30 = v16;
      v19 = v17[1];
      v20 = *(_QWORD *)(v19 + 144);
      v38 = (void (**)(SISearchCtx *__hidden))MEMORY[0x1E0C809B0];
      *(_QWORD *)&v39 = 0x40000000;
      *((_QWORD *)&v39 + 1) = __query_once_block_invoke;
      *(_QWORD *)&v40 = &__block_descriptor_tmp_418;
      *((_QWORD *)&v40 + 1) = v19;
      if (v20 != -1)
        dispatch_once((dispatch_once_t *)(v19 + 144), &v38);
      v21 = *(_QWORD *)(v19 + 136);
      if (v21 >= 1)
      {
        v22 = *(_QWORD *)(v19 + 128);
        v32 = v22;
        do
        {
          if ((*(_BYTE *)(*(_QWORD *)v22 + 4) & 1) != 0)
          {
            bzero(v42, 0x480uLL);
            v23 = *(_BYTE *)(v5 + 2072);
            v24 = v5;
            v25 = (*(_DWORD *)(v5 + 6584) >> 18) & 1;
            v39 = 0u;
            v40 = 0u;
            v41 = 0;
            memset(&v42[8], 0, 41);
            memset(&v42[56], 0, 60);
            memset(&v42[128], 0, 64);
            v38 = off_1E6E29FF0;
            v43 = -1;
            v48 = 0;
            v44 = 0u;
            v45 = 0u;
            v50 = 0u;
            v51 = 0u;
            v49 = 0u;
            v36[0] = MEMORY[0x1E0C809B0];
            v36[1] = 0x40000000;
            v36[2] = (uint64_t)___ZN11SISearchCtxC2Ev_block_invoke;
            v36[3] = (uint64_t)&__block_descriptor_tmp_4;
            v36[4] = (uint64_t)&v38;
            v46 = md_deadline_once_create();
            v47 = dispatch_time(0, 500000000);
            v38 = (void (**)(SISearchCtx *__hidden))&off_1E6E2A138;
            v52 = 9;
            v53 = 0;
            v54 = 0;
            v55 = 0;
            v56 = 0u;
            v57 = 0u;
            v58 = 0u;
            v59 = 0u;
            v60 = 0u;
            v61 = 0u;
            v62 = 0u;
            v63 = 0;
            v64 = 0u;
            v65 = 0u;
            v66 = 0u;
            v67 = 0u;
            v68 = 0;
            v69 = 0u;
            v70 = 0u;
            memset(v71, 0, 22);
            v71[22] = v23;
            v72 = 0;
            v73 = v25;
            v5 = v24;
            v74 = 0;
            v75 = 0;
            v85 = 0;
            v86 = 0;
            v108 = 0;
            v109 = 0;
            v110 = 0;
            v111 = 0;
            v76 = 0u;
            v77 = 0u;
            v78 = 0u;
            v79 = 0u;
            v80 = 0u;
            v81 = 0u;
            v82 = 0u;
            v83 = 0u;
            memset(v84, 0, sizeof(v84));
            v104 = 0;
            v102 = 0u;
            v103 = 0u;
            v100 = 0u;
            v101 = 0u;
            v98 = 0u;
            v99 = 0u;
            v96 = 0u;
            v97 = 0u;
            v94 = 0u;
            v95 = 0u;
            v92 = 0u;
            v93 = 0u;
            v90 = 0u;
            v91 = 0u;
            v88 = 0u;
            v89 = 0u;
            v87 = 0u;
            v105 = 0;
            v106 = 0;
            v107 = 0;
            v35 = 0;
            v36[0] = 0;
            si_query_copy_grouping(v19, v36, &v35);
            SISearchCtx_METADATA::vinitContext((uint64_t)&v38, v19, v24, *(uint64_t **)v32, *(_QWORD *)(v32 + 8), *(const __CFArray **)(v19 + 176), *(_QWORD *)(v19 + 200), v33, v26, v34, *(const void **)(v19 + 16), v36[0], v35, *(_BYTE *)(v19 + 689));
            LOBYTE(v68) = 1;
            LODWORD(v69) = *(_DWORD *)(v31 + 48);
            SISearchCtx::executeSearchContext((SISearchCtx *)&v38, (SISearchCtx *)1);
            SISearchCtx_METADATA::~SISearchCtx_METADATA((SISearchCtx_METADATA *)&v38);
          }
          v22 += 16;
          --v21;
        }
        while (v21);
      }
      v8 = v29;
      si_livequery_release((uint64_t)v29[v30]);
      v16 = v30 + 1;
    }
    while (v30 + 1 != v28);
  }
  if ((v27 & 1) != 0)
    si_scheduler_resume(*(_QWORD *)(v5 + 872), (uint64_t)"/Library/Caches/com.apple.xbs/Sources/Spotlight_frameworks/spotlight/index/SpotlightIndex/SILiveQuerySupport.c", 325);
  if (v8 != (const void **)values)
    free(v8);
}

uint64_t __si_perform_livequeries_updates_block_invoke(_QWORD *a1, uint64_t a2)
{
  const char **v3;
  char *v4;
  int v6;
  uint64_t v7;
  int *v8;
  _DWORD *v9;
  _OWORD *v10;
  _DWORD *v11;
  unsigned int *v13;
  const __CFSet *v14;
  __CFArray *v15;
  uint64_t v16;
  _QWORD v18[2];
  void (*v19)(uint64_t, int);
  void *v20;
  uint64_t v21;
  __int128 v22;
  _OWORD v23[2];
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (*(_WORD *)(a2 + 40) != 4)
    return a2;
  v3 = *(const char ***)(a2 + 16);
  v4 = (char *)*v3;
  if (!*v3)
    return a2;
  if (!strcmp("*", *v3))
  {
    v13 = (unsigned int *)a1[4];
    v14 = (const __CFSet *)a1[5];
    v15 = *(__CFArray **)(a1[6] + 16);
    v16 = 0x40000000;
LABEL_15:
    update_lq_field_info(v13, v14, v15, (void *)v16);
    return a2;
  }
  v6 = strcmp("kMDItemTextContent", v4);
  v7 = a1[4];
  if (!v6)
  {
    v14 = (const __CFSet *)a1[5];
    v15 = *(__CFArray **)(a1[6] + 16);
    v13 = (unsigned int *)a1[4];
    v16 = 0;
    goto LABEL_15;
  }
  if (!*(_BYTE *)(v7 + 2072) || strcmp("_kMDItemBundleID", v4))
  {
    v8 = *(int **)(v7 + 1184);
    v18[0] = MEMORY[0x1E0C809B0];
    v18[1] = 0x40000000;
    v19 = __si_perform_livequeries_updates_block_invoke_2;
    v20 = &__block_descriptor_tmp_3489;
    v21 = v7;
    v22 = *(_OWORD *)(a1 + 5);
    memset(v23, 0, sizeof(v23));
    v9 = db_copy_field_ids_with_buffer(v8, v4, (uint64_t)v23, 8uLL);
    if (v9)
    {
      v10 = v9;
      if (*v9)
      {
        v11 = v9 + 1;
        do
          ((void (*)(_QWORD *))v19)(v18);
        while (*v11++);
      }
      if (v10 != v23)
        free(v10);
    }
  }
  return a2;
}

void __si_perform_livequeries_updates_block_invoke_3(uint64_t a1, int a2)
{
  update_lq_field_info(*(unsigned int **)(a1 + 32), *(CFSetRef *)(a1 + 40), *(__CFArray **)(*(_QWORD *)(a1 + 48) + 24), (void *)(a2 & 0x3FFFFFF));
}

void update_lq_field_info(unsigned int *a1, CFSetRef theSet, __CFArray *a3, void *value)
{
  const void *v8;

  if (!CFSetContainsValue(theSet, value))
  {
    CFSetAddValue(theSet, value);
    if (value)
    {
      CFArrayAppendValue(a3, value);
      if ((void *)a1[510] == value || (void *)a1[511] == value || (void *)a1[512] == value)
      {
        v8 = (const void *)a1[509];
        if (!CFSetContainsValue(theSet, v8))
        {
          CFSetAddValue(theSet, v8);
          CFArrayAppendValue(a3, v8);
        }
      }
    }
    else
    {
      CFArrayInsertValueAtIndex(a3, 0, 0);
    }
  }
}

void __si_perform_livequeries_updates_block_invoke_2(uint64_t a1, int a2)
{
  update_lq_field_info(*(unsigned int **)(a1 + 32), *(CFSetRef *)(a1 + 40), *(__CFArray **)(*(_QWORD *)(a1 + 48) + 16), (void *)(a2 & 0x3FFFFFF));
}

void si_perform_livequeries_reassignments(uint64_t a1)
{
  uint64_t v1;
  unint64_t *v2;
  unint64_t *v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  CFIndex Count;
  uint64_t v9;
  const void **v10;
  int v11;
  uint64_t v12;
  unsigned int *v13;
  unsigned int v14;
  uint64_t v15;
  int Path;
  unint64_t *v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  _OWORD *v25;
  _QWORD *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char **v35;
  int v36;
  int v37;
  CFMutableDictionaryRef Mutable;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  int v43;
  int v44;
  unint64_t *v45;
  uint64_t v46;
  uint64_t v47;
  unsigned int v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  char v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t *v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t v59;
  uint64_t v60;
  _QWORD *v61;
  uint64_t v62;
  BOOL v63;
  unint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  unsigned __int16 v68;
  uint64_t v69;
  uint64_t v70;
  int v71;
  NSObject *v72;
  int v73;
  NSObject *v74;
  unint64_t v75;
  uint64_t v76;
  uint64_t v77;
  int v78;
  NSObject *v79;
  unint64_t *v80;
  uint64_t v81;
  unint64_t v82;
  unint64_t v83;
  int v84;
  int v85;
  const void **v86;
  unint64_t *v87;
  int v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  __CFDictionary *v92;
  uint64_t v93;
  const __CFAllocator *allocator;
  uint64_t v95;
  uint64_t v96;
  _DWORD *v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102[2];
  __int128 v103;
  __int128 v104;
  unsigned int v105;
  uint64_t v106;
  __int128 v107;
  int v108;
  void (**v109)(CatInfoGotten_SDB *__hidden);
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  void *v114;
  void *v115[5];
  uint64_t v116;
  uint8_t buf[8];
  uint64_t v118;
  void (*v119)(uint64_t);
  void *v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  unint64_t *v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t (**v129)();
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  int v133;
  int v134;
  uint64_t v135;
  unint64_t *v136;
  unint64_t v137;
  uint64_t v138;
  const void *v139[1024];
  int v140;
  unint64_t v141;
  __int16 v142;
  uint64_t v143;
  uint64_t v144;

  v1 = MEMORY[0x1E0C80A78](a1);
  v3 = v2;
  v83 = v4;
  v6 = v5;
  v7 = v1;
  v144 = *MEMORY[0x1E0C80C00];
  bzero(v139, 0x2000uLL);
  pthread_mutex_lock((pthread_mutex_t *)(v7 + 1712));
  Count = CFSetGetCount(*(CFSetRef *)(v7 + 1776));
  v9 = Count;
  if (Count >= 1024)
  {
    v10 = (const void **)malloc_type_malloc(8 * Count, 0x2004093837F09uLL);
    CFSetGetValues(*(CFSetRef *)(v7 + 1776), v10);
  }
  else
  {
    if (!Count)
    {
      v11 = 0;
      v10 = v139;
      goto LABEL_12;
    }
    v10 = v139;
    CFSetGetValues(*(CFSetRef *)(v7 + 1776), v139);
    if (v9 < 1)
    {
      v11 = 0;
      goto LABEL_12;
    }
  }
  v12 = 0;
  do
  {
    v13 = (unsigned int *)v10[v12];
    do
      v14 = __ldaxr(v13);
    while (__stlxr(v14 + 1, v13));
    ++v12;
  }
  while (v12 != v9);
  v11 = 1;
LABEL_12:
  pthread_mutex_unlock((pthread_mutex_t *)(v7 + 1712));
  bzero(&v137, 0x1000uLL);
  v87 = 0;
  v88 = 0;
  if (v3)
  {
    v15 = *(_QWORD *)(v7 + 6624);
    if (v15)
    {
      v137 = v3[3];
      Path = directoryStoreGetPath(v15, v137, (uint64_t)&v138);
      v88 = Path + 1;
      if (Path == -1)
        v17 = 0;
      else
        v17 = &v137;
      v87 = v17;
    }
  }
  if (v11)
  {
    v18 = 0;
    allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    v80 = v3;
    v81 = v9;
    v86 = v10;
    v82 = v6;
    while (1)
    {
      v19 = v10[v18];
      v20 = v19[5];
      do
      {
        v21 = v20;
        v20 = *(_QWORD *)(v20 + 80);
      }
      while (v20);
      v22 = *(_QWORD *)(v21 + 40);
      if (!RLEOIDArrayContainsOid(v22, v6))
        goto LABEL_99;
      v96 = v18;
      v23 = v19[5];
      do
      {
        v24 = v23;
        v23 = *(_QWORD *)(v23 + 80);
      }
      while (v23);
      v97 = *(_DWORD **)(v24 + 8);
      v25 = malloc_type_calloc(1uLL, 0x40uLL, 0x10720403C4CCC75uLL);
      if (dword_1EF19FC94 >= 5)
      {
        v70 = v7;
        v71 = *__error();
        v72 = _SILogForLogForCategory(2);
        if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_1B8270000, v72, OS_LOG_TYPE_DEFAULT, "Passing up deletion", buf, 2u);
        }
        *__error() = v71;
        v7 = v70;
        v9 = v81;
      }
      v25[1] = *(_OWORD *)(v19[5] + 48);
      *((_QWORD *)v25 + 1) = si_querypipe_copy_jobid(v19[5]);
      *((_QWORD *)v25 + 5) = 0;
      *(_DWORD *)v25 = 7;
      v26 = malloc_type_malloc(0x10uLL, 0x100004000313F17uLL);
      RLEOIDArrayRemoveOid(v22, v6);
      *v26 = 0;
      v27 = v19[5];
      do
      {
        v28 = v27;
        v27 = *(_QWORD *)(v27 + 80);
      }
      while (v27);
      *v26 = ((unint64_t)*(unsigned int *)(*(_QWORD *)(v28 + 8) + 80) << 32) | 0xDE10001;
      v26[1] = v6;
      *((_QWORD *)v25 + 4) = _MDStoreOIDArrayCreateMutableWithOids();
      _MDStoreOIDArraySetShouldUseMalloc();
      *((_DWORD *)v25 + 14) = 3;
      v29 = (uint64_t)v97;
      pthread_mutex_lock((pthread_mutex_t *)(*(_QWORD *)v97 + 8));
      ++v97[21];
      pthread_mutex_unlock((pthread_mutex_t *)(*(_QWORD *)v97 + 8));
      if (!si_resultqueue_enqueue((uint64_t)v97, (int *)v25))
      {
        if (dword_1EF19FC94 >= 5)
        {
          v77 = v7;
          v78 = *__error();
          v79 = _SILogForLogForCategory(2);
          if (os_log_type_enabled(v79, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_1B8270000, v79, OS_LOG_TYPE_DEFAULT, "Attempt to append to queue failed. Releasing result batch", buf, 2u);
          }
          *__error() = v78;
          v7 = v77;
          v29 = (uint64_t)v97;
        }
        SIResultBatchFree((void **)v25);
      }
      v30 = v19[1];
      v31 = *(_QWORD *)(v30 + 576);
      if (!v31)
        goto LABEL_34;
      pthread_rwlock_wrlock((pthread_rwlock_t *)(v31 + 16));
      if (RLEOIDArrayContainsOid(v31, v6))
        break;
      pthread_rwlock_unlock((pthread_rwlock_t *)(v31 + 16));
      v18 = v96;
LABEL_98:
      si_resultqueue_start(v29);
LABEL_99:
      si_livequery_release((uint64_t)v10[v18++]);
      if (v18 == v9)
        goto LABEL_110;
    }
    RLEOIDArrayRemoveOid(v31, v6);
    pthread_rwlock_wrlock((pthread_rwlock_t *)(v31 + 16));
    SIValueSet<unsigned long long>::SIValueSetInsert((unint64_t *)(v31 + 216), v83);
    pthread_rwlock_unlock((pthread_rwlock_t *)(v31 + 16));
    pthread_rwlock_unlock((pthread_rwlock_t *)(v31 + 16));
    v30 = v19[1];
LABEL_34:
    v32 = v19[5];
    v33 = *(_QWORD *)(v30 + 144);
    *(_QWORD *)buf = MEMORY[0x1E0C809B0];
    v118 = 0x40000000;
    v119 = __query_once_block_invoke;
    v120 = &__block_descriptor_tmp_418;
    v121 = v30;
    if (v33 != -1)
      dispatch_once((dispatch_once_t *)(v30 + 144), buf);
    v34 = *(_QWORD *)(v32 + 88);
    v133 = 0;
    v135 = 0;
    v131 = 0;
    v132 = v34;
    v130 = v7;
    v129 = &off_1E6E2A268;
    v134 = v88;
    v136 = v87;
    v126 = v3;
    v127 = 0;
    v128 = 0;
    v91 = v34;
    if (v34)
      v35 = *(char ***)(v34 + 120);
    else
      v35 = 0;
    v93 = v32;
    v89 = *(_QWORD *)(v30 + 256);
    v90 = *(_QWORD *)(v30 + 248);
    v36 = *(unsigned __int8 *)(v30 + 60);
    v98 = v30;
    v37 = *(unsigned __int8 *)(v30 + 61);
    if (v36)
      db_eval_obj_with_options(*(_QWORD *)(v7 + 1184));
    Mutable = CFDictionaryCreateMutable(allocator, 0, 0, MEMORY[0x1E0C9B3A0]);
    bzero(buf, 0x11E0uLL);
    v92 = Mutable;
    PartialQueryResults::PartialQueryResults((uint64_t)buf, *(CFArrayRef *)(v98 + 16), *(const void **)(v98 + 24), 0, 0, Mutable, *(_DWORD *)(v98 + 152), 0, *(double *)(v98 + 360), 0, 0, 0, 0, 1);
    if (*(int *)(v98 + 152) > 3)
    {
      if (v122)
      {
        PartialQueryResults::attributeVector((PartialQueryResults *)buf);
        v49 = v122;
      }
      else
      {
        v49 = 0;
      }
      v10 = v86;
      v18 = v96;
      collectAttributesFromDBO(v7, v3, v49, (uint64_t)buf, v35);
      si_querypipe_addcoalescedresults(v93, (PartialQueryResults *)buf, *(int **)(v7 + 1184), 1);
    }
    else
    {
      v39 = v93;
      v40 = v93;
      do
      {
        v41 = v40;
        v40 = *(_QWORD *)(v40 + 80);
      }
      while (v40);
      v42 = RLEOIDArrayContainsOid(*(_QWORD *)(v41 + 40), *v3);
      v116 = 0;
      LOBYTE(v43) = 1;
      memset(&v115[1], 0, 32);
      if (v42)
        v44 = 2;
      else
        v44 = 1;
      v84 = v42;
      v85 = v44;
      v113 = 0;
      v114 = 0;
      v110 = 0;
      v111 = v7;
      v112 = v91;
      memset(v115, 0, sizeof(v115));
      if (v7)
        v43 = (*(unsigned __int8 *)(v7 + 6586) >> 1) & 1;
      LOBYTE(v116) = v43;
      v109 = &off_1E6E2A0F8;
      v114 = v3;
      LODWORD(v110) = 4;
      if (v37)
      {
        v45 = v3;
        v46 = 0;
        v47 = 0;
        v48 = -1;
      }
      else
      {
        v50 = v7;
        v99 = *(_QWORD *)(v98 + 288);
        if (v99 < 1)
        {
          v46 = 0;
          v47 = 0;
        }
        else
        {
          v51 = 0;
          v52 = 0;
          v46 = 0;
          v47 = 0;
          v53 = *(_QWORD *)(v98 + 264);
          v95 = v53;
          do
          {
            v54 = v53 + 24 * v51;
            v57 = *(_QWORD *)(v54 + 8);
            v56 = (uint64_t *)(v54 + 8);
            LOBYTE(v55) = v57;
            if (v57 < 1)
            {
              v59 = 0;
              v60 = 0;
            }
            else
            {
              v100 = v47;
              v101 = v46;
              v58 = 0;
              v59 = 0;
              v60 = 0;
              v61 = (_QWORD *)(v53 + 24 * v51);
              do
              {
                if (*(_QWORD *)(*v61 + 8 * v58))
                {
                  v62 = db_eval_obj_with_options(*(_QWORD *)(v50 + 1184)) != 0;
                  v63 = __CFADD__(v59, v62);
                  v59 += v62;
                  if (v63)
                    ++v60;
                }
                ++v58;
                v55 = *v56;
              }
              while (*v56 > v58);
              v47 = v100;
              v46 = v101;
              v53 = v95;
            }
            v64 = (v60 << v52) | (v59 >> 1 >> ~v52);
            if ((v52 & 0x40) != 0)
            {
              v64 = v59 << v52;
              v65 = 0;
            }
            else
            {
              v65 = v59 << v52;
            }
            v47 |= v64;
            v46 |= v65;
            v52 += v55;
            ++v51;
          }
          while (v99 > v51);
        }
        v29 = (uint64_t)v97;
        v48 = *(double *)(v98 + 360);
        v7 = v50;
        v45 = v80;
        v9 = v81;
        v39 = v93;
      }
      v66 = v39;
      v10 = v86;
      do
      {
        v67 = v66;
        v66 = *(_QWORD *)(v66 + 80);
      }
      while (v66);
      if (v84)
        v68 = 3213;
      else
        v68 = 2781;
      v69 = PartialQueryResults::start((PartialQueryResults *)buf, *(_DWORD *)(*(_QWORD *)(v67 + 8) + 80), v68, 2uLL, 0);
      LODWORD(v110) = v110 | 8;
      v102[0] = v46;
      v102[1] = v47;
      v103 = 0u;
      v104 = 0u;
      v105 = v48;
      v106 = 0;
      v107 = 0u;
      v108 = 0;
      writeDBOToPlistBytes(v7, v69, buf, v35, &v109, v91, v90, v89, 0, v102, 0, 0, 0, 0, 0, 0, 0, v98, 0);
      if (v124)
      {
        _MDPlistBytesEndArray();
        _MDPlistBytesEndPlist();
      }
      v18 = v96;
      Mutable = v92;
      v3 = v45;
      if (v123)
      {
        _MDStoreOIDArrayEndBulkAdd();
        _MDStoreOIDArrayEndSequence();
        v125 = 0;
      }
      v6 = v82;
      if (v114 == v3)
        v114 = 0;
      si_querypipe_addresults(v39, (uint64_t)buf, v85, 0, v98);
      if (dword_1EF19FC94 >= 5)
      {
        v73 = *__error();
        v74 = _SILogForLogForCategory(2);
        if (os_log_type_enabled(v74, OS_LOG_TYPE_DEFAULT))
        {
          v75 = *v3;
          v76 = *(_QWORD *)(v98 + 8);
          v140 = 134218242;
          v141 = v75;
          v142 = 2112;
          v143 = v76;
          _os_log_impl(&dword_1B8270000, v74, OS_LOG_TYPE_DEFAULT, "True live query: (%lld) %@", (uint8_t *)&v140, 0x16u);
        }
        *__error() = v73;
        v18 = v96;
        v29 = (uint64_t)v97;
      }
      v109 = &off_1E6E2A0F8;
      if (BYTE2(v116) && v114)
        free(v114);
      v109 = (void (**)(CatInfoGotten_SDB *__hidden))off_1E6E2A058;
      if (v115[2])
      {
        CFRelease(v115[2]);
        v115[2] = 0;
      }
      if (v115[4])
      {
        free(v115[4]);
        v115[4] = 0;
      }
      if (v115[3])
      {
        CFRelease(v115[3]);
        v115[3] = 0;
      }
      if (BYTE1(v116))
        free(v115[0]);
    }
    CFRelease(Mutable);
    PartialQueryResults::~PartialQueryResults((PartialQueryResults *)buf);
    v129 = &off_1E6E2A268;
    if (v135)
      (*(void (**)(uint64_t))(*(_QWORD *)v135 + 8))(v135);
    goto LABEL_98;
  }
LABEL_110:
  if (v10 != v139)
    free(v10);
}

uint64_t si_remove_livequery(uint64_t a1, const void *a2)
{
  pthread_mutex_t *v4;

  v4 = (pthread_mutex_t *)(a1 + 1712);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1712));
  CFSetRemoveValue(*(CFMutableSetRef *)(a1 + 1776), a2);
  return pthread_mutex_unlock(v4);
}

uint64_t si_dump_livequeries(uint64_t a1)
{
  pthread_mutex_t *v2;
  const __CFSet *v3;
  CFIndex Count;
  uint64_t v5;
  size_t v6;
  char *v7;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  NSObject *v12;
  int v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v19;
  pthread_mutex_t *v20;
  __int128 v21;
  uint8_t buf[4];
  int v23;
  __int16 v24;
  int v25;
  __int16 v26;
  int v27;
  __int16 v28;
  uint64_t v29;
  __int16 v30;
  unsigned int v31;
  __int16 v32;
  uint64_t v33;
  __int16 v34;
  uint64_t v35;
  __int16 v36;
  uint64_t v37;
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  v2 = (pthread_mutex_t *)(a1 + 1712);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1712));
  v3 = *(const __CFSet **)(a1 + 1776);
  if (v3)
  {
    Count = CFSetGetCount(v3);
    if (Count)
    {
      v5 = Count;
      v19 = (uint64_t)&v19;
      v20 = v2;
      MEMORY[0x1E0C80A78](Count);
      v7 = (char *)&v19 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
      bzero(v7, v6);
      CFSetGetValues(*(CFSetRef *)(a1 + 1776), (const void **)v7);
      if (v5 >= 1)
      {
        v9 = 0;
        *(_QWORD *)&v8 = 67110914;
        v21 = v8;
        do
        {
          v10 = *(_QWORD *)&v7[8 * v9];
          v11 = *__error();
          v12 = _SILogForLogForCategory(2);
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
          {
            v13 = *(_DWORD *)(a1 + 32);
            v14 = atomic_load((unsigned int *)v10);
            v15 = *(_QWORD *)(v10 + 40);
            v16 = *(_QWORD *)(v10 + 8);
            v17 = *(_QWORD *)(v16 + 8);
            *(_DWORD *)buf = v21;
            v23 = v13;
            v24 = 1024;
            v25 = v9;
            v26 = 1024;
            v27 = v5;
            v28 = 2048;
            v29 = v10;
            v30 = 1024;
            v31 = v14;
            v32 = 2048;
            v33 = v15;
            v34 = 2048;
            v35 = v16;
            v36 = 2112;
            v37 = v17;
            _os_log_impl(&dword_1B8270000, v12, OS_LOG_TYPE_DEFAULT, "### indexFd: %d live_query[%d,%d]: %p rc: %d pipe: %p q: %p %@", buf, 0x42u);
          }
          *__error() = v11;
          ++v9;
        }
        while (v5 != v9);
      }
      v2 = v20;
    }
  }
  return pthread_mutex_unlock(v2);
}

uint64_t siquerynode_compare(uint64_t a1, uint64_t a2)
{
  int v2;
  int v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  float v29;
  float v30;
  unsigned int v31;
  const void *v32;
  size_t v33;

  v2 = *(_DWORD *)(a1 + 4);
  v3 = *(_DWORD *)(a2 + 4);
  if (v2 != v3)
    return (v2 - v3);
  v4 = a1;
  while (1)
  {
    v5 = *(_DWORD *)v4;
    result = (*(_DWORD *)v4 - *(_DWORD *)a2);
    if (*(_DWORD *)v4 != *(_DWORD *)a2)
      return result;
    if (v5 != 2)
      break;
    v4 = *(_QWORD *)(v4 + 24);
    a2 = *(_QWORD *)(a2 + 24);
    v2 = *(_DWORD *)(v4 + 4);
    v3 = *(_DWORD *)(a2 + 4);
    if (v2 != v3)
      return (v2 - v3);
  }
  if (v5 < 2)
  {
    v7 = *(_QWORD *)(v4 + 24);
    v8 = *(_QWORD *)(a2 + 24);
    if (v7 != v8)
      return (v7 - v8);
    if (v7 >= 1)
    {
      v9 = *(_QWORD **)(v4 + 32);
      v10 = *(_QWORD **)(a2 + 32);
      do
      {
        result = siquerynode_compare(*v9, *v10);
        if ((_DWORD)result)
          break;
        ++v10;
        ++v9;
        --v7;
      }
      while (v7);
      return result;
    }
    return 0;
  }
  if (v5 != 3)
    return 0;
  v11 = *(_QWORD *)(v4 + 24);
  v12 = *(unsigned __int16 *)(v11 + 40);
  v13 = *(_QWORD *)(a2 + 24);
  v14 = *(unsigned __int16 *)(v13 + 40);
  result = (v12 - v14);
  if (v12 != v14)
    return result;
  v15 = *(unsigned __int8 *)(v11 + 48);
  v16 = *(unsigned __int8 *)(v13 + 48);
  result = (v15 - v16);
  if (v15 != v16)
    return result;
  if (v12 != 4)
    return 0;
  v17 = *(_QWORD *)(v11 + 16);
  v18 = *(_DWORD *)(v17 + 24);
  v19 = *(_QWORD *)(v13 + 16);
  v20 = *(_DWORD *)(v19 + 24);
  result = (v18 - v20);
  if (v18 != v20)
    return result;
  v21 = *(_DWORD *)(v17 + 40);
  v22 = *(_DWORD *)(v19 + 40);
  result = (v21 - v22);
  if (v21 != v22)
    return result;
  result = strcmp(*(const char **)v17, *(const char **)v19);
  if ((_DWORD)result)
    return result;
  if ((v18 - 11) < 2)
  {
    v23 = 0;
    v24 = 8 * (v21 & ~(v21 >> 31));
    while (v24 != v23)
    {
      result = strcmp(*(const char **)(*(_QWORD *)(v17 + 168) + v23), *(const char **)(*(_QWORD *)(v19 + 168) + v23));
      v23 += 8;
      if ((_DWORD)result)
        return result;
    }
    return 0;
  }
  if (v18 != 15)
    return strcmp(*(const char **)(v17 + 72), *(const char **)(v19 + 72));
  v25 = *(unsigned int *)(v17 + 60);
  v26 = v25 & 3;
  result = (*(_DWORD *)(v17 + 60) & 3) - (*(_DWORD *)(v19 + 60) & 3u);
  if ((*(_DWORD *)(v17 + 60) & 3) == (*(_DWORD *)(v19 + 60) & 3))
  {
    v27 = (v25 >> 2) & 3;
    v28 = (*(_DWORD *)(v19 + 60) >> 2) & 3;
    result = (v27 - v28);
    if ((_DWORD)v27 == v28)
    {
      v29 = *(float *)(v17 + 64);
      v30 = *(float *)(v19 + 64);
      if (v29 == v30)
      {
        result = *(_QWORD *)(v17 + 296);
        if (!result)
          return result;
        v32 = *(const void **)(v19 + 296);
        if (!v32)
          return 0;
        v33 = -1;
        if ((_DWORD)v26 != 3 && (_DWORD)v27 != 3)
          v33 = (vector_dimension_vec_sizes_10743[v26] * vector_size_elem_sizes_10742[v27]);
        return memcmp((const void *)result, v32, v33) == 0;
      }
      else
      {
        if (v29 >= v30)
          v31 = 0;
        else
          v31 = -1;
        if (v29 > v30)
          return 1;
        else
          return v31;
      }
    }
  }
  return result;
}

_QWORD *si_querynode_add(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;

  if (!a2)
    return (_QWORD *)a1;
  v4 = (_QWORD *)MEMORY[0x1E0C85AD8];
  if (*MEMORY[0x1E0C85AD8] <= 0x27uLL)
    ++sTotal_3522;
  v5 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x28uLL, 0x31F9A007uLL);
  if (!v5)
    _log_fault_for_malloc_failure();
  *(_DWORD *)v5 = 0;
  v5[3] = 2;
  if (*v4 <= 0xFuLL)
    ++sTotal_3522;
  v6 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x10uLL, 0x31F9A007uLL);
  if (!v6)
    _log_fault_for_malloc_failure();
  v5[4] = v6;
  *v6 = a1;
  *(_QWORD *)(v5[4] + 8) = a2;
  return v5;
}

_QWORD *si_querynode_join(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;

  if (!a2)
    return (_QWORD *)a1;
  v4 = (_QWORD *)MEMORY[0x1E0C85AD8];
  if (*MEMORY[0x1E0C85AD8] <= 0x27uLL)
    ++sTotal_3522;
  v5 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x28uLL, 0x31F9A007uLL);
  if (!v5)
    _log_fault_for_malloc_failure();
  *(_DWORD *)v5 = 1;
  v5[3] = 2;
  if (*v4 <= 0xFuLL)
    ++sTotal_3522;
  v6 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x10uLL, 0x31F9A007uLL);
  if (!v6)
    _log_fault_for_malloc_failure();
  v5[4] = v6;
  *v6 = a1;
  *(_QWORD *)(v5[4] + 8) = a2;
  return v5;
}

uint64_t __rewriteForSources_block_invoke(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  return siquerynode_compare(*a2, *a3);
}

_DWORD *clone_node_copyingkind(uint64_t a1, int a2, int *a3, unsigned int a4)
{
  int *v4;
  _DWORD *v8;
  _DWORD *v9;
  size_t v10;
  void *v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  unsigned int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  char *v20;
  char *v21;
  const char *v22;
  char *v23;
  const char *v24;
  uint64_t v25;

  v4 = a3;
  if (a4 > 1)
  {
    v8 = malloc_type_malloc(0x28uLL, 0x10A2040E651BF2BuLL);
    if (*(_DWORD *)a1 >= 4u)
    {
      v20 = __si_assert_copy_extra_268();
      v21 = v20;
      v22 = "";
      if (v20)
        v22 = v20;
      __message_assert("%s:%u: failed assertion '%s' %s ", "siquerynode.c", 228, "node->kind<=QN_FACTOR", v22);
    }
    else
    {
      v9 = v8;
      *v8 = *(_DWORD *)a1;
      v8[1] = 0;
      *((_WORD *)v8 + 7) = *(_WORD *)(a1 + 14);
      v10 = 8 * a4;
      if (!(a4 >> 14) && v10 > *MEMORY[0x1E0C85AD8])
        ++sTotal_3522;
      v11 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, v10, 0x31F9A007uLL);
      if (!v11)
        _log_fault_for_malloc_failure();
      *((_QWORD *)v9 + 3) = a4;
      *((_QWORD *)v9 + 4) = v11;
      *((_BYTE *)v9 + 13) = 0;
      v12 = *(_QWORD *)(a1 + 24);
      if (v12 < 1)
      {
        v15 = 0;
      }
      else
      {
        v13 = 0;
        v14 = 0;
        v15 = 0;
        do
        {
          v16 = *v4;
          v4 += 2;
          if (v16 == a2)
          {
            *(_QWORD *)(*((_QWORD *)v9 + 4) + 8 * v15) = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v14);
            v9[1] |= *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v14) + 4);
            ++v15;
            v13 |= *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * v14) + 13);
            *((_BYTE *)v9 + 13) = v13;
            v12 = *(_QWORD *)(a1 + 24);
          }
          ++v14;
        }
        while (v14 < v12);
      }
      if (v15 == a4)
        return v9;
      v23 = __si_assert_copy_extra_268();
      v21 = v23;
      v24 = "";
      if (v23)
        v24 = v23;
      __message_assert("%s:%u: failed assertion '%s' %s ", "siquerynode.c", 244, "count==scount", v24);
    }
    free(v21);
    if (__valid_fs(-1))
      v25 = 2989;
    else
      v25 = 3072;
    *(_DWORD *)v25 = -559038737;
    abort();
  }
  v17 = *(_QWORD *)(a1 + 24);
  if (v17 < 1)
    return 0;
  v18 = 0;
  v9 = 0;
  do
  {
    if (a3[v18] == a2)
      v9 = *(_DWORD **)(*(_QWORD *)(a1 + 32) + v18 * 4);
    v18 += 2;
    --v17;
  }
  while (v17);
  return v9;
}

uint64_t translateSDBQuery(uint64_t a1)
{
  uint64_t result;
  _QWORD v3[5];

  v3[0] = MEMORY[0x1E0C809B0];
  v3[1] = 0x40000000;
  v3[2] = __db_query_tree_apply_block_block_invoke;
  v3[3] = &unk_1E6E377F8;
  v3[4] = &__block_literal_global_31_3537;
  result = db_query_tree_apply_block_with_meta((_QWORD *)a1, (uint64_t)v3, (uint64_t)&__block_literal_global_34);
  if (a1)
  {
    if (result)
      *(_BYTE *)(result + 16) = *(_BYTE *)(a1 + 48) & 1;
  }
  return result;
}

void __initCharSets_block_invoke()
{
  const __CFAllocator *v0;
  __CFCharacterSet *Mutable;
  __CFCharacterSet *v2;
  CFRange v3;
  CFRange v4;
  CFRange v5;

  v0 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFCharacterSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00]);
  v3.location = 3584;
  v3.length = 128;
  CFCharacterSetAddCharactersInRange(Mutable, v3);
  _infixChars = (uint64_t)CFCharacterSetCreateCopy(v0, Mutable);
  CFRelease(Mutable);
  v2 = CFCharacterSetCreateMutable(v0);
  v4.location = 11904;
  v4.length = 52096;
  CFCharacterSetAddCharactersInRange(v2, v4);
  v5.location = 65376;
  v5.length = 80;
  CFCharacterSetAddCharactersInRange(v2, v5);
  _cjkChars = (uint64_t)CFCharacterSetCreateCopy(v0, v2);
  CFRelease(v2);
}

uint64_t rewriteForFSPostCheckInPlace(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  unsigned int v4;
  const char *v5;
  uint64_t tree_apply_block_with_meta;
  _QWORD *v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  int v11;
  unsigned int v12;
  char *v13;
  uint64_t v14;
  _QWORD v16[5];

  v2 = *(_QWORD **)a1;
  v3 = *(_QWORD *)(*(_QWORD *)a1 + 16);
  if (!v3)
  {
    v4 = 0;
LABEL_13:
    v7 = v2;
    goto LABEL_14;
  }
  v4 = *(_DWORD *)(v3 + 48);
  if ((*(_DWORD *)(v3 + 24) - 11) > 1)
    goto LABEL_13;
  v5 = *(const char **)v3;
  if (strncmp(*(const char **)v3, "kMDItemFS", 9uLL))
  {
    if (strncmp(v5, "_kMDItemFS", 0xAuLL))
      goto LABEL_13;
  }
  v16[0] = MEMORY[0x1E0C809B0];
  v16[1] = 0x40000000;
  v16[2] = __db_query_tree_apply_block_block_invoke;
  v16[3] = &unk_1E6E377F8;
  v16[4] = &__block_literal_global_17_10736;
  tree_apply_block_with_meta = db_query_tree_apply_block_with_meta(v2, (uint64_t)v16, (uint64_t)&__block_literal_global_20_10737);
  if (*MEMORY[0x1E0C85AD8] <= 0x47uLL)
    ++sTotal_3522;
  v7 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x48uLL, 0x31F9A007uLL);
  if (!v7)
    _log_fault_for_malloc_failure();
  *v7 = tree_apply_block_with_meta;
  v7[1] = v2;
  v8 = *(_QWORD *)(tree_apply_block_with_meta + 16);
  v9 = *(_DWORD *)(v8 + 24);
  if (v9 == 11)
  {
    *((_WORD *)v7 + 20) = 2;
    *(_DWORD *)(v8 + 24) = 8;
    v10 = v2[2];
    v11 = 7;
  }
  else
  {
    if (v9 != 12)
    {
      v10 = v2[2];
      goto LABEL_25;
    }
    *((_WORD *)v7 + 20) = 1;
    *(_DWORD *)(v8 + 24) = 3;
    v10 = v2[2];
    v11 = 4;
  }
  *(_DWORD *)(v10 + 24) = v11;
LABEL_25:
  *(_QWORD *)(v8 + 72) = **(_QWORD **)(v8 + 168);
  *(_QWORD *)(v10 + 72) = *(_QWORD *)(*(_QWORD *)(v10 + 168) + 8);
  free(*(void **)(*(_QWORD *)(v8 + 168) + 8));
  **(_QWORD **)(*(_QWORD *)(tree_apply_block_with_meta + 16) + 168) = 0;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(tree_apply_block_with_meta + 16) + 168) + 8) = 0;
  free(**(void ***)(v2[2] + 168));
  **(_QWORD **)(v2[2] + 168) = 0;
  *(_QWORD *)(*(_QWORD *)(v2[2] + 168) + 8) = 0;
  *(_DWORD *)(v2[2] + 40) = 0;
  *(_DWORD *)(*(_QWORD *)(tree_apply_block_with_meta + 16) + 40) = 0;
LABEL_14:
  *(_QWORD *)a1 = v7;
  v12 = v4;
  if (*v7)
    v12 = rewriteForFSPostCheckInPlace(v7);
  v14 = v7[1];
  v13 = (char *)(v7 + 1);
  if (v14)
    v4 = rewriteForFSPostCheckInPlace(v13);
  if ((int)v12 >= (int)v4)
    return v4;
  else
    return v12;
}

uint64_t keycompare_3559(uint64_t a1, int a2, uint64_t *a3, int a4, uint64_t *a5)
{
  unint64_t v5;
  unint64_t v6;
  BOOL v7;
  BOOL v8;
  unsigned int v9;
  int v10;
  int v11;
  unsigned int v12;
  BOOL v14;
  _BOOL4 v15;
  int v16;

  v5 = *a3;
  v6 = *a5;
  if (a2 == 8)
  {
    v7 = v5 >= v6;
    v8 = v5 > v6;
    if (v5 == v6)
      v9 = -1;
    else
      v9 = (v5 > v6) - (v5 < v6);
    v10 = v8;
    v11 = !v7;
    v12 = v10 - v11;
    if (a4 == 8)
      return v12;
    else
      return v9;
  }
  else if (a4 == 8)
  {
    if (v5 == v6)
      return 1;
    else
      return (v5 > v6) - (v5 < v6);
  }
  else
  {
    v14 = v5 >= v6;
    if (v5 == v6)
    {
      return strcmp((const char *)a3 + 14, (const char *)a5 + 14);
    }
    else
    {
      v15 = v5 > v6;
      v16 = !v14;
      return (v15 - v16);
    }
  }
}

void release_persistent_id_64_store(uint64_t a1)
{
  uint64_t *v2;
  int v3;
  NSObject *v4;
  uint64_t v5;
  const char *v6;
  uint64_t *v7;
  uint64_t v8;
  int v9;
  const char *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  uint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v2 = (uint64_t *)(a1 + 32);
  if (*(_QWORD *)(a1 + 32) > 0x7FFFFFFFFFFFFFFEuLL)
  {
    if (!_sqlite_insert((uint64_t *)a1, (char *)&master_fid_rec_3560, master_fid_rec_size_3562, (char *)(a1 + 32), 8, 0))goto LABEL_7;
    v3 = *__error();
    v4 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v8 = *v2;
      v9 = 136315650;
      v10 = "release_persistent_id_64_store";
      v11 = 1024;
      v12 = 298;
      v13 = 2048;
      v14 = v8;
      v6 = "%s:%d: psid-release: Failed to update the master fid! (0x%llx)\n";
      goto LABEL_13;
    }
  }
  else
  {
    v3 = *__error();
    v4 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      v5 = *v2;
      v9 = 136315650;
      v10 = "release_persistent_id_64_store";
      v11 = 1024;
      v12 = 285;
      v13 = 2048;
      v14 = v5;
      v6 = "%s:%d: release_psid_64_store: danger! master_fid %lld looks bad.\n";
LABEL_13:
      _os_log_error_impl(&dword_1B8270000, v4, OS_LOG_TYPE_ERROR, v6, (uint8_t *)&v9, 0x1Cu);
    }
  }
  *__error() = v3;
LABEL_7:
  v7 = *(uint64_t **)(a1 + 16);
  if (v7)
    sqlite3BtreeCloseCursor(v7);
  if (*(_QWORD *)a1)
    sqlite3BtreeClose(*(uint64_t **)a1);
  free((void *)a1);
}

uint64_t get_id_for_path_64(uint64_t a1, const char *a2, uint64_t *a3, _QWORD *a4, int a5, uint64_t a6)
{
  int v11;
  char *v12;
  uint64_t v13;
  const char *v14;
  int v15;
  const char *v16;
  int v17;
  __int16 v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  size_t v25;
  uint64_t result;
  _BYTE v27[4];
  int v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  _QWORD v32[36];

  v32[34] = *MEMORY[0x1E0C80C00];
  v31 = 0;
  memset(&v32[1], 0, 264);
  v32[0] = 2;
  *a3 = 0;
  if (a4)
    *a4 = 2;
  v11 = *(unsigned __int8 *)a2;
  if (*a2)
  {
    v29 = a6;
    v12 = (char *)&v32[1] + 6;
    v13 = 2;
    v14 = a2;
    do
    {
      while (v11 == 47)
      {
        v15 = *(unsigned __int8 *)++v14;
        v11 = v15;
      }
      v16 = v14;
      if (!v11)
        break;
      do
      {
        if (v11 == 47)
          break;
        v17 = *(unsigned __int8 *)++v16;
        v11 = v17;
      }
      while (v17);
      v18 = (_WORD)v16 - (_WORD)v14;
      if (((v16 - v14) & 0xFF00) != 0)
        v18 = 255;
      WORD2(v32[1]) = v18;
      v30 = v12;
      __strncpy_chk();
      v19 = WORD2(v32[1]);
      ++WORD2(v32[1]);
      *((_BYTE *)&v32[1] + v19 + 6) = 0;
      LODWORD(v32[1]) = 0;
      if (*v16 == 47)
        v14 = v16 + 1;
      else
        v14 = v16;
      v20 = psid_lookup_3588(a1, (uint64_t)v32, &v31);
      if ((_DWORD)v20)
      {
        if ((a5 & 1) == 0)
          return 2;
        v21 = (uint64_t *)a1;
        v22 = v29;
        if (v29)
        {
          v28 = a5;
          MEMORY[0x1E0C80A78](v20);
          v24 = &v27[-v23];
          bzero(&v27[-v23], v25);
          strncat(v24, a2, v14 - a2);
          v24[v14 - a2] = 0;
          v31 = (*(uint64_t (**)(uint64_t, char *))(v22 + 16))(v22, v24);
          a1 = (uint64_t)v21;
          result = psid_insert_with_id(v21, (uint64_t)v32, (char *)&v31);
          a5 = v28;
        }
        else
        {
          a1 = (uint64_t)v21;
          result = psid_insert(v21, (uint64_t)v32, (char *)&v31);
        }
        if ((_DWORD)result)
          return result;
      }
      if (a4)
        *a4 = v32[0];
      v12 = v30;
      v13 = v31;
      v32[0] = v31;
      v11 = *(unsigned __int8 *)v14;
    }
    while (*v14);
  }
  else
  {
    v13 = 2;
  }
  result = 0;
  *a3 = v13;
  return result;
}

uint64_t psid_lookup_3588(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v4;
  uint64_t result;
  uint64_t v6;
  uint64_t v7;

  v4 = *(unsigned __int16 *)(a2 + 12) + 16;
  v6 = 8;
  v7 = 0;
  result = _sqlite_get_psid(a1, a2, v4, (char *)&v7, (int *)&v6);
  if ((_DWORD)result)
    return 2;
  *a3 = v7;
  return result;
}

uint64_t psid_insert_with_id(uint64_t *a1, uint64_t a2, char *a3)
{
  int v4;
  NSObject *v5;
  os_log_type_t v6;
  uint64_t v7;
  int v9;
  uint64_t v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  if (*(_QWORD *)a3 > 1uLL)
    return _psid_insert_3590(a1, a2, a3);
  v4 = *__error();
  v5 = _SILogForLogForCategory(4);
  v6 = 2 * (dword_1EF19FC9C < 4);
  if (os_log_type_enabled(v5, v6))
  {
    v7 = *(_QWORD *)a3;
    v9 = 134217984;
    v10 = v7;
    _os_log_impl(&dword_1B8270000, v5, v6, "psid_insert_with_id: fid %lld not valid!\n", (uint8_t *)&v9, 0xCu);
  }
  *__error() = v4;
  return 22;
}

uint64_t psid_insert(uint64_t *a1, uint64_t a2, char *a3)
{
  unint64_t v4;
  int v5;
  NSObject *v6;
  os_log_type_t v7;
  uint64_t v8;
  int v10;
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v4 = a1[4];
  if (v4 > 1)
  {
    *(_QWORD *)a3 = v4;
    ++a1[4];
    return _psid_insert_3590(a1, a2, a3);
  }
  else
  {
    v5 = *__error();
    v6 = _SILogForLogForCategory(4);
    v7 = 2 * (dword_1EF19FC9C < 4);
    if (os_log_type_enabled(v6, v7))
    {
      v8 = a1[4];
      v10 = 134217984;
      v11 = v8;
      _os_log_impl(&dword_1B8270000, v6, v7, "psid_insert: master fid corrupted (%lld)\n", (uint8_t *)&v10, 0xCu);
    }
    *__error() = v5;
    return 22;
  }
}

uint64_t _psid_insert_3590(uint64_t *a1, uint64_t a2, char *a3)
{
  int v7;
  int v8;
  NSObject *v9;
  uint64_t v10;
  const char *v11;
  int *v12;
  unsigned int v13;
  int v14;
  unsigned int v15;
  uint64_t v16;
  int v17;
  NSObject *v18;
  const char *v19;
  NSObject *v20;
  uint64_t v21;
  int v22;
  const char *v23;
  __int16 v24;
  _BYTE v25[14];
  __int16 v26;
  uint64_t v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if (_sqlite_bulkBegin((uint64_t)a1))
    return 22;
  v7 = *(unsigned __int16 *)(a2 + 12) + 16;
  if (_sqlite_insert(a1, (char *)a2, *(unsigned __int16 *)(a2 + 12) + 16, a3, 8, 1))
  {
    v8 = *__error();
    v9 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v10 = a1[4];
      v22 = 136315906;
      v23 = "_psid_insert_locked";
      v24 = 1024;
      *(_DWORD *)v25 = 413;
      *(_WORD *)&v25[4] = 2048;
      *(_QWORD *)&v25[6] = v10;
      v26 = 2080;
      v27 = a2 + 14;
      v11 = "%s:%d: psid-insert: failed to store fid 0x%llx for path %s\n";
LABEL_21:
      _os_log_error_impl(&dword_1B8270000, v9, OS_LOG_TYPE_ERROR, v11, (uint8_t *)&v22, 0x26u);
      goto LABEL_9;
    }
    goto LABEL_9;
  }
  v12 = (int *)&unk_1EF19F000;
  if (dword_1EF19FC9C >= 5)
  {
    v17 = *__error();
    v18 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      v19 = *(const char **)a3;
      v22 = 134218242;
      v23 = v19;
      v24 = 2080;
      *(_QWORD *)v25 = a2 + 14;
      _os_log_impl(&dword_1B8270000, v18, OS_LOG_TYPE_DEFAULT, "psid-insert: fid 0x%llx for path %s\n", (uint8_t *)&v22, 0x16u);
    }
    *__error() = v17;
    v12 = (_DWORD *)&unk_1EF19F000;
  }
  if (_sqlite_insert(a1, a3, 8uLL, (char *)a2, v7, 1))
  {
    v8 = *__error();
    v9 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      v16 = a1[4];
      v22 = 136315906;
      v23 = "_psid_insert_locked";
      v24 = 1024;
      *(_DWORD *)v25 = 419;
      *(_WORD *)&v25[4] = 2080;
      *(_QWORD *)&v25[6] = a2 + 14;
      v26 = 2048;
      v27 = v16;
      v11 = "%s:%d: psid-insert: failed to store path %s for fid 0x%llx\n";
      goto LABEL_21;
    }
LABEL_9:
    v13 = 22;
    goto LABEL_10;
  }
  if (v12[807] < 5)
  {
    v13 = 0;
    goto LABEL_11;
  }
  v8 = *__error();
  v20 = _SILogForLogForCategory(4);
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    v21 = a1[4];
    v22 = 136315394;
    v23 = (const char *)(a2 + 14);
    v24 = 2048;
    *(_QWORD *)v25 = v21;
    _os_log_impl(&dword_1B8270000, v20, OS_LOG_TYPE_DEFAULT, "psid-insert: store path %s for fid 0x%llx\n", (uint8_t *)&v22, 0x16u);
  }
  v13 = 0;
LABEL_10:
  *__error() = v8;
LABEL_11:
  v14 = _sqlite_bulkEnd(a1);
  if (v13)
    v15 = v13;
  else
    v15 = 22;
  if (v14)
    return v15;
  else
    return v13;
}

uint64_t get_path_for_id_64(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4, int a5)
{
  uint64_t v7;
  int v8;
  uint64_t result;
  int v11;
  int v12;
  int v13;
  NSObject *v14;
  os_log_type_t v15;
  int v16;
  NSObject *v17;
  os_log_type_t v18;
  const char *v19;
  NSObject *v20;
  os_log_type_t v21;
  uint32_t v22;
  NSObject *v23;
  os_log_type_t v24;
  int v25;
  NSObject *v26;
  os_log_type_t v27;
  unint64_t v29;
  uint64_t v30;
  uint8_t buf[4];
  _BYTE v32[20];
  _QWORD v33[3];
  _OWORD v34[17];
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v30 = a2;
  v7 = a5;
  *(_BYTE *)(a4 + a5 - 1) = 0;
  if (a2 == 2)
  {
    v8 = 1;
  }
  else
  {
    v11 = a5 + 1;
    v8 = 1;
    memset(v34, 0, sizeof(v34));
    while (1)
    {
      v29 = 272;
      if (_sqlite_get(a1, (uint64_t)&v30, 8, (char *)v34, &v29))
        return 2;
      v12 = WORD6(v34[0]);
      if (WORD6(v34[0]) >= a5)
      {
        v16 = *__error();
        v17 = _SILogForLogForCategory(4);
        v18 = 2 * (dword_1EF19FC9C < 4);
        if (os_log_type_enabled(v17, v18))
        {
          *(_DWORD *)buf = 67109890;
          *(_DWORD *)v32 = WORD6(v34[0]);
          *(_WORD *)&v32[4] = 2048;
          *(_QWORD *)&v32[6] = *(_QWORD *)&v34[0];
          *(_WORD *)&v32[14] = 1024;
          *(_DWORD *)&v32[16] = DWORD2(v34[0]);
          LOWORD(v33[0]) = 2080;
          *(_QWORD *)((char *)v33 + 2) = (unint64_t)v34 | 0xE;
          v19 = "get_path_for_id: bogus part len %d (%lld/%d/%s)\n";
          v20 = v17;
          v21 = v18;
          v22 = 34;
          goto LABEL_21;
        }
LABEL_22:
        *__error() = v16;
        return 22;
      }
      if (*(_QWORD *)&v34[0] <= 1uLL)
      {
        v13 = *__error();
        v14 = _SILogForLogForCategory(4);
        v15 = 2 * (dword_1EF19FC9C < 4);
        if (os_log_type_enabled(v14, v15))
        {
          *(_DWORD *)buf = 134218498;
          *(_QWORD *)v32 = v30;
          *(_WORD *)&v32[8] = 2048;
          *(_QWORD *)&v32[10] = *(_QWORD *)&v34[0];
          *(_WORD *)&v32[18] = 2080;
          v33[0] = (unint64_t)v34 | 0xE;
          _os_log_impl(&dword_1B8270000, v14, v15, "get_path_for_id: bogus looking part fid (cur fid %lld, part fid %lld name %s)\n", buf, 0x20u);
        }
        *__error() = v13;
        v12 = WORD6(v34[0]);
      }
      if (v8 + v12 + 1 >= a5)
      {
        *(_BYTE *)(a4 + v8) = 0;
        v16 = *__error();
        v23 = _SILogForLogForCategory(4);
        v24 = 2 * (dword_1EF19FC9C < 4);
        if (os_log_type_enabled(v23, v24))
        {
          *(_DWORD *)buf = 67109634;
          *(_DWORD *)v32 = v8;
          *(_WORD *)&v32[4] = 1024;
          *(_DWORD *)&v32[6] = WORD6(v34[0]);
          *(_WORD *)&v32[10] = 2080;
          *(_QWORD *)&v32[12] = a4;
          v19 = "get_path_for_id: path index too large! (%d %d : %s)\n";
          v20 = v23;
          v21 = v24;
          v22 = 24;
LABEL_21:
          _os_log_impl(&dword_1B8270000, v20, v21, v19, buf, v22);
        }
        goto LABEL_22;
      }
      strncpy((char *)(a4 + v11 - (v8 + v12)), (const char *)((unint64_t)v34 | 0xE), v12 - 1);
      v8 += v12;
      *(_BYTE *)(a4 + v7 - v8) = 47;
      if (v30 == 2 && *(_QWORD *)&v34[0] != 2)
        break;
      v30 = *(_QWORD *)&v34[0];
      if (*(_QWORD *)&v34[0] == 2)
        goto LABEL_3;
    }
    v25 = *__error();
    v26 = _SILogForLogForCategory(4);
    v27 = 2 * (dword_1EF19FC9C < 4);
    if (os_log_type_enabled(v26, v27))
    {
      *(_DWORD *)buf = 134218240;
      *(_QWORD *)v32 = v30;
      *(_WORD *)&v32[8] = 2048;
      *(_QWORD *)&v32[10] = *(_QWORD *)&v34[0];
      _os_log_impl(&dword_1B8270000, v26, v27, "get_path_for_id: cur fid %lld should have parent fid 2 but part->fid == %lld\n", buf, 0x16u);
    }
    *__error() = v25;
  }
LABEL_3:
  result = 0;
  *a3 = a4 + v7 - v8;
  return result;
}

uint64_t set_id_for_path_64(uint64_t a1)
{
  uint64_t v1;
  char *v2;
  uint64_t v3;
  char *v4;
  __int128 v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t *v9;
  char *v10;
  char *v11;
  int v12;
  __int16 v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  size_t v18;
  uint64_t v19;
  unsigned int v20;
  int v21;
  NSObject *v22;
  char *v23;
  int v24;
  unint64_t v25;
  int *v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  int v30;
  NSObject *v31;
  uint64_t v32;
  int v33;
  int v34;
  int v35;
  NSObject *v36;
  int v37;
  NSObject *v38;
  uint64_t *v39;
  uint64_t v40;
  char *v41;
  int v42;
  int v43;
  char v44;
  int v45;
  int v46;
  NSObject *v47;
  os_log_type_t v48;
  int v49;
  int *v50;
  int v51;
  int v52;
  NSObject *v53;
  int v54;
  NSObject *v55;
  int v56;
  NSObject *v57;
  int v58;
  int v59;
  NSObject *v60;
  int v61;
  NSObject *v62;
  uint64_t v64;
  os_log_t v65;
  int v66;
  char *v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  char *v72;
  __int128 v73;
  __int128 v74;
  char *v75;
  char *v76;
  char *v77;
  char *v78;
  int v79;
  char *v80;
  char *v81;
  _OWORD v82[128];
  int v83;
  char *v84;
  __int16 v85;
  char *v86;
  _QWORD v87[34];
  _QWORD v88[34];
  uint8_t buf[4];
  _BYTE v90[24];
  uint64_t v91;

  v1 = MEMORY[0x1E0C80A78](a1);
  v91 = *MEMORY[0x1E0C80C00];
  v78 = v4;
  *((_QWORD *)&v5 + 1) = 0;
  memset(&v88[1], 0, 264);
  v88[0] = 2;
  v6 = *v2;
  if (!*v2)
    return v6;
  v7 = v3;
  v8 = v2;
  v9 = (uint64_t *)v1;
  v77 = 0;
  v75 = (char *)&v87[1] + 6;
  v72 = (char *)v82 + 14;
  *(_QWORD *)&v5 = 134218242;
  v69 = v5;
  *(_QWORD *)&v5 = 136315394;
  v68 = v5;
  *(_QWORD *)&v5 = 136315650;
  v73 = v5;
  *(_QWORD *)&v5 = 134218498;
  v71 = v5;
  *(_QWORD *)&v5 = 134217984;
  v70 = v5;
  *(_QWORD *)&v5 = 67109376;
  v74 = v5;
  v10 = v2;
  v76 = (char *)&v88[1] + 6;
  while (1)
  {
    while ((_DWORD)v6 == 47)
    {
      v20 = *++v10;
      v6 = v20;
    }
    v11 = v10;
    if (!(_DWORD)v6)
      return v6;
    do
    {
      if ((_DWORD)v6 == 47)
        break;
      v12 = *++v11;
      LODWORD(v6) = v12;
    }
    while (v12);
    v13 = (_WORD)v11 - (_WORD)v10;
    if (((v11 - v10) & 0xFF00) != 0)
      v13 = 255;
    WORD2(v88[1]) = v13;
    __strncpy_chk();
    v14 = WORD2(v88[1]);
    ++WORD2(v88[1]);
    *((_BYTE *)&v88[1] + v14 + 6) = 0;
    LODWORD(v88[1]) = 0;
    v10 = *v11 == 47 ? v11 + 1 : v11;
    v15 = psid_lookup_3588((uint64_t)v9, (uint64_t)v88, &v77);
    if ((_DWORD)v15)
      break;
    if (*v10)
      goto LABEL_84;
    if (v77 == v78)
    {
      if (dword_1EF19FCA4 < 5)
        goto LABEL_84;
      v21 = *__error();
      v22 = _SILogForLogForCategory(6);
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        v83 = v69;
        v84 = v78;
        v85 = 2080;
        v86 = v8;
        _os_log_impl(&dword_1B8270000, v22, OS_LOG_TYPE_DEFAULT, "Existing path for %lld at %s matches. Re-parent not needed.", (uint8_t *)&v83, 0x16u);
      }
      goto LABEL_23;
    }
    if (dword_1EF19FCA4 >= 5)
    {
      v56 = *__error();
      v57 = _SILogForLogForCategory(6);
      if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
      {
        v83 = v69;
        v84 = v78;
        v85 = 2080;
        v86 = v8;
        _os_log_impl(&dword_1B8270000, v57, OS_LOG_TYPE_DEFAULT, "Existing path for %lld at %s. Re-parent.", (uint8_t *)&v83, 0x16u);
      }
      *__error() = v56;
    }
    memcpy(v87, v88, sizeof(v87));
    v87[0] = 2;
    v23 = strncpy(v75, "SP_TMP_MOVE", 0x100uLL);
    WORD2(v87[1]) = strlen(v23);
    if (!psid_insert_with_id(v9, (uint64_t)v87, (char *)&v78))
    {
      v67 = v8;
      bzero(&v83, 0x2000uLL);
      while (1)
      {
        _sqlite_bulkBegin((uint64_t)v9);
        v81 = v77;
        v79 = 0;
        if (!v77)
          goto LABEL_81;
        v80 = 0;
        memset(v82, 0, 272);
        v24 = sqlite3BtreeMoveto(v9[2], (uint64_t)&v81, 8, &v79);
        if (v24 | v79)
        {
          v45 = v24;
          v46 = *__error();
          v47 = _SILogForLogForCategory(4);
          v48 = 2 * (dword_1EF19FC9C < 4);
          if (os_log_type_enabled(v47, v48))
          {
            *(_DWORD *)buf = v74;
            *(_DWORD *)v90 = v45;
            *(_WORD *)&v90[4] = 2048;
            *(_QWORD *)&v90[6] = v81;
            _os_log_impl(&dword_1B8270000, v47, v48, "psid_iterate: sqlite3BtreeMoveto failed; rc = %d for for dir_id %lld\n",
              buf,
              0x12u);
          }
          *__error() = v46;
LABEL_81:
          _sqlite_bulkEnd(v9);
          goto LABEL_82;
        }
        v25 = 0;
        v26 = (int *)&unk_1EF19F000;
        while (1)
        {
          v27 = v9[2];
          if (!*(_BYTE *)(v27 + 97))
            break;
          getCellInfo(v9[2]);
          v28 = *(_QWORD *)(v27 + 72);
          v27 = v9[2];
          if (v28 != 8)
            goto LABEL_46;
          if (getPayload(v9[2], 8, (char *)&v80, 0))
            goto LABEL_66;
          v29 = v80;
          if (v81)
          {
            if (v81 != v80)
              goto LABEL_66;
          }
          if (v26[807] >= 5)
          {
            v30 = *__error();
            v31 = _SILogForLogForCategory(4);
            if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = v70;
              *(_QWORD *)v90 = v29;
              _os_log_impl(&dword_1B8270000, v31, OS_LOG_TYPE_DEFAULT, "key: %lld # ", buf, 0xCu);
            }
            *__error() = v30;
            v26 = (_DWORD *)&unk_1EF19F000;
          }
LABEL_49:
          v32 = v9[2];
          if (!*(_BYTE *)(v32 + 97))
          {
            v33 = 0;
LABEL_56:
            if (getPayload(v32, v33, (char *)v82, 1))
              goto LABEL_66;
            if (v26[807] >= 5)
            {
              v35 = *__error();
              v36 = _SILogForLogForCategory(4);
              if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = v71;
                *(_QWORD *)v90 = *(_QWORD *)&v82[0];
                *(_WORD *)&v90[8] = 1024;
                *(_DWORD *)&v90[10] = DWORD2(v82[0]);
                *(_WORD *)&v90[14] = 2080;
                *(_QWORD *)&v90[16] = v72;
                _os_log_impl(&dword_1B8270000, v36, OS_LOG_TYPE_DEFAULT, "value: %lld / %d / %s\n", buf, 0x1Cu);
              }
              *__error() = v35;
            }
            goto LABEL_58;
          }
          getCellInfo(v9[2]);
          v33 = *(_DWORD *)(v32 + 80);
          v32 = v9[2];
          if (v33 != 8)
            goto LABEL_56;
          if (getPayload(v9[2], 8, (char *)&v80, 1))
            goto LABEL_66;
          if (v26[807] >= 5)
          {
            v37 = *__error();
            v38 = _SILogForLogForCategory(4);
            if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = v70;
              *(_QWORD *)v90 = v80;
              _os_log_impl(&dword_1B8270000, v38, OS_LOG_TYPE_DEFAULT, "value: %lld\n", buf, 0xCu);
            }
            *__error() = v37;
          }
          *((_QWORD *)&v83 + v25++) = v80;
          if (v25 >= 0x401)
          {
            v44 = 1;
            goto LABEL_68;
          }
LABEL_58:
          v34 = sqlite3BtreeNext(v9[2], &v79);
          if (v34 | v79)
            goto LABEL_66;
        }
        LODWORD(v28) = 0;
LABEL_46:
        if (!getPayload(v27, v28, (char *)v82, 0) && (!v81 || v81 == *(char **)&v82[0]))
          goto LABEL_49;
LABEL_66:
        if (!v25)
          goto LABEL_81;
        v44 = 0;
LABEL_68:
        v39 = (uint64_t *)&v83;
        do
        {
          bzero(v82, 0x800uLL);
          v81 = 0;
          v40 = *v39++;
          if (!get_path_for_id_64((uint64_t)v9, v40, &v81, (uint64_t)v82, 2048))
          {
            v41 = v81;
            v42 = rename_path_64(v9, v81, "/SP_TMP_MOVE", v7);
            if (dword_1EF19FCA4 >= 5)
            {
              v43 = v42;
              v66 = *__error();
              v65 = (os_log_t)_SILogForLogForCategory(6);
              if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = v73;
                *(_QWORD *)v90 = v41;
                *(_WORD *)&v90[8] = 2080;
                *(_QWORD *)&v90[10] = "/SP_TMP_MOVE";
                *(_WORD *)&v90[18] = 1024;
                *(_DWORD *)&v90[20] = v43;
                _os_log_impl(&dword_1B8270000, v65, OS_LOG_TYPE_DEFAULT, "Move %s to %s. (%d)", buf, 0x1Cu);
              }
              *__error() = v66;
            }
          }
          --v25;
        }
        while (v25);
        _sqlite_bulkEnd(v9);
        if ((v44 & 1) == 0)
        {
LABEL_82:
          v8 = v67;
          v49 = remove_path_64(v9, v67);
          v50 = (int *)&unk_1EF19F000;
          if (dword_1EF19FCA4 >= 5)
          {
            v58 = v49;
            v59 = *__error();
            v60 = _SILogForLogForCategory(6);
            if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
            {
              LODWORD(v82[0]) = v68;
              *(_QWORD *)((char *)v82 + 4) = v8;
              WORD6(v82[0]) = 1024;
              *(_DWORD *)((char *)v82 + 14) = v58;
              _os_log_impl(&dword_1B8270000, v60, OS_LOG_TYPE_DEFAULT, "Remove %s. (%d)", (uint8_t *)v82, 0x12u);
            }
            *__error() = v59;
            v50 = (_DWORD *)&unk_1EF19F000;
          }
          v51 = rename_path_64(v9, "/SP_TMP_MOVE", v8, v7);
          if (v50[809] < 5)
            break;
          v61 = v51;
          v21 = *__error();
          v62 = _SILogForLogForCategory(6);
          if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(v82[0]) = v73;
            *(_QWORD *)((char *)v82 + 4) = "/SP_TMP_MOVE";
            WORD6(v82[0]) = 2080;
            *(_QWORD *)((char *)v82 + 14) = v8;
            WORD3(v82[1]) = 1024;
            DWORD2(v82[1]) = v61;
            _os_log_impl(&dword_1B8270000, v62, OS_LOG_TYPE_DEFAULT, "Move %s to %s. (%d)", (uint8_t *)v82, 0x1Cu);
          }
LABEL_23:
          *__error() = v21;
          break;
        }
      }
    }
LABEL_84:
    v88[0] = v77;
    v6 = *v10;
    if (!*v10)
      return v6;
  }
  if (!*v10)
  {
    if (dword_1EF19FCA4 >= 5)
    {
      v52 = *__error();
      v53 = _SILogForLogForCategory(6);
      if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
      {
        v83 = v69;
        v84 = v78;
        v85 = 2080;
        v86 = v76;
        _os_log_impl(&dword_1B8270000, v53, OS_LOG_TYPE_DEFAULT, "%lld -> %s", (uint8_t *)&v83, 0x16u);
      }
      *__error() = v52;
    }
    v19 = psid_insert_with_id(v9, (uint64_t)v88, (char *)&v78);
    if (!(_DWORD)v19)
    {
      v77 = v78;
      goto LABEL_84;
    }
    return v19;
  }
  if (v7)
  {
    MEMORY[0x1E0C80A78](v15);
    v17 = (char *)&v64 - v16;
    bzero((char *)&v64 - v16, v18);
    strncpy(v17, v8, v10 - v8);
    v17[v10 - v8] = 0;
    v77 = (char *)(*(uint64_t (**)(uint64_t, char *))(v7 + 16))(v7, v17);
    v19 = psid_insert_with_id(v9, (uint64_t)v88, (char *)&v77);
    if (!(_DWORD)v19)
      goto LABEL_84;
    return v19;
  }
  v6 = psid_insert(v9, (uint64_t)v88, (char *)&v77);
  if (dword_1EF19FCA4 >= 5)
  {
    v54 = *__error();
    v55 = _SILogForLogForCategory(6);
    if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
    {
      v83 = v69;
      v84 = v77;
      v85 = 2080;
      v86 = v76;
      _os_log_impl(&dword_1B8270000, v55, OS_LOG_TYPE_DEFAULT, "%lld -> %s", (uint8_t *)&v83, 0x16u);
    }
    *__error() = v54;
  }
  if (!(_DWORD)v6)
    goto LABEL_84;
  return v6;
}

uint64_t rename_path_64(uint64_t *a1, char *a2, char *a3, uint64_t a4)
{
  char *v8;
  char *v9;
  uint64_t result;
  char *v11;
  int v12;
  int v13;
  int v14;
  int v15;
  NSObject *v16;
  const char *v17;
  unint64_t v18;
  int v19;
  NSObject *v20;
  int v21;
  NSObject *v22;
  char *v23;
  char *v24;
  int v25;
  NSObject *v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint8_t buf[4];
  const char *v32;
  __int16 v33;
  int v34;
  __int16 v35;
  _BYTE v36[24];
  __int16 v37;
  unint64_t v38;
  _OWORD v39[16];
  __int128 v40;
  char __dst[1024];
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  v29 = 0;
  v30 = 0;
  remove_path_64(a1, a3);
  if (get_id_for_path_64((uint64_t)a1, a2, &v30, &v29, 0, 0))
    return 2;
  strncpy(__dst, a3, 0x400uLL);
  __dst[1023] = 0;
  v8 = strrchr(__dst, 47);
  if (v8)
  {
    v9 = v8;
    *v8 = 0;
  }
  else
  {
    v9 = &__dst[-(__dst[0] != 47)];
  }
  v28 = 0;
  if (get_id_for_path_64((uint64_t)a1, __dst, &v28, 0, 1, a4))
    return 2;
  v40 = 0u;
  memset(v39, 0, sizeof(v39));
  v11 = strncpy((char *)((unint64_t)v39 | 0xE), v9 + 1, 0x100uLL);
  BYTE13(v40) = 0;
  v12 = strlen(v11);
  *(_QWORD *)&v39[0] = v28;
  WORD6(v39[0]) = v12 + 1;
  v13 = _sqlite_bulkBegin((uint64_t)a1);
  if (v13)
  {
    v14 = v13;
    v15 = *__error();
    v16 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136316418;
      v32 = "rename_path_64";
      v33 = 1024;
      v34 = 981;
      v35 = 1024;
      *(_DWORD *)v36 = v14;
      *(_WORD *)&v36[4] = 2048;
      *(_QWORD *)&v36[6] = v30;
      *(_WORD *)&v36[14] = 2048;
      *(_QWORD *)&v36[16] = *(_QWORD *)&v39[0];
      v37 = 2080;
      v38 = (unint64_t)v39 | 0xE;
      v17 = "%s:%d: psid-rename: begin error %d updating the file-fid record for fid %lld pid %lld / %s. \n";
LABEL_28:
      _os_log_error_impl(&dword_1B8270000, v16, OS_LOG_TYPE_ERROR, v17, buf, 0x36u);
      goto LABEL_26;
    }
    goto LABEL_26;
  }
  v18 = v12 + 17;
  if (_sqlite_insert(a1, (char *)&v30, 8uLL, (char *)v39, v12 + 17, 1))
  {
    v19 = *__error();
    v20 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315650;
      v32 = "rename_path_64";
      v33 = 1024;
      v34 = 989;
      v35 = 2048;
      *(_QWORD *)v36 = v30;
      _os_log_error_impl(&dword_1B8270000, v20, OS_LOG_TYPE_ERROR, "%s:%d: psid-rename: Could not update the file-fid record for fid %lld\n", buf, 0x1Cu);
    }
    *__error() = v19;
  }
  if (_sqlite_insert(a1, (char *)v39, v18, (char *)&v30, 8, 1))
  {
    v21 = *__error();
    v22 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      v32 = "rename_path_64";
      v33 = 1024;
      v34 = 997;
      v35 = 2048;
      *(_QWORD *)v36 = *(_QWORD *)&v39[0];
      *(_WORD *)&v36[8] = 2080;
      *(_QWORD *)&v36[10] = (unint64_t)v39 | 0xE;
      _os_log_error_impl(&dword_1B8270000, v22, OS_LOG_TYPE_ERROR, "%s:%d: psid-rename: failed to insert new record for %lld / %s.\n", buf, 0x26u);
    }
    *__error() = v21;
  }
  *(_QWORD *)&v39[0] = v29;
  v23 = strrchr(a2, 47);
  if (v23)
  {
    v24 = strncpy((char *)((unint64_t)v39 | 0xE), v23 + 1, 0x100uLL);
    BYTE13(v40) = 0;
    WORD6(v39[0]) = strlen(v24) + 1;
    if (_sqlite_delete((uint64_t)a1, (uint64_t)v39, WORD6(v39[0]) + 16))
    {
      v25 = *__error();
      v26 = _SILogForLogForCategory(4);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315906;
        v32 = "rename_path_64";
        v33 = 1024;
        v34 = 1019;
        v35 = 2048;
        *(_QWORD *)v36 = *(_QWORD *)&v39[0];
        *(_WORD *)&v36[8] = 2080;
        *(_QWORD *)&v36[10] = (unint64_t)v39 | 0xE;
        _os_log_error_impl(&dword_1B8270000, v26, OS_LOG_TYPE_ERROR, "%s:%d: psid-rename: failed to delete old record for %lld / %s\n", buf, 0x26u);
      }
      *__error() = v25;
    }
  }
  result = _sqlite_bulkEnd(a1);
  if ((_DWORD)result)
  {
    v27 = result;
    v15 = *__error();
    v16 = _SILogForLogForCategory(4);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136316418;
      v32 = "rename_path_64";
      v33 = 1024;
      v34 = 1025;
      v35 = 1024;
      *(_DWORD *)v36 = v27;
      *(_WORD *)&v36[4] = 2048;
      *(_QWORD *)&v36[6] = v30;
      *(_WORD *)&v36[14] = 2048;
      *(_QWORD *)&v36[16] = *(_QWORD *)&v39[0];
      v37 = 2080;
      v38 = (unint64_t)v39 | 0xE;
      v17 = "%s:%d: psid-rename: end error %d updating the file-fid record for fid %lld pid %lld / %s. \n";
      goto LABEL_28;
    }
LABEL_26:
    *__error() = v15;
    return 22;
  }
  return result;
}

uint64_t remove_path_64(uint64_t *a1, char *a2)
{
  unsigned int v5;
  int v6;
  NSObject *v7;
  char *v8;
  char *v9;
  char *v10;
  int v11;
  unsigned int v12;
  uint64_t v13;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  uint64_t v19;
  _OWORD v20[17];
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (_sqlite_bulkBegin((uint64_t)a1))
    return 22;
  memset(v20, 0, sizeof(v20));
  v13 = 0;
  if (get_id_for_path_64((uint64_t)a1, a2, (uint64_t *)v20, &v13, 0, 0))
  {
    v5 = 2;
  }
  else
  {
    if (_sqlite_delete((uint64_t)a1, (uint64_t)v20, 8))
    {
      v6 = *__error();
      v7 = _SILogForLogForCategory(4);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315650;
        v15 = "remove_path_locked";
        v16 = 1024;
        v17 = 813;
        v18 = 2048;
        v19 = *(_QWORD *)&v20[0];
        _os_log_error_impl(&dword_1B8270000, v7, OS_LOG_TYPE_ERROR, "%s:%d: psid-remove: Could not delete the file-fid record for fid %lld\n", buf, 0x1Cu);
      }
      *__error() = v6;
    }
    memset((char *)v20 + 8, 0, 264);
    *(_QWORD *)&v20[0] = v13;
    v8 = strrchr(a2, 47);
    v9 = a2 - 1;
    if (v8)
      v9 = v8;
    v10 = strncpy((char *)((unint64_t)v20 | 0xE), v9 + 1, 0x100uLL);
    BYTE13(v20[16]) = 0;
    WORD6(v20[0]) = strlen(v10) + 1;
    v5 = 2 * (_sqlite_delete((uint64_t)a1, (uint64_t)v20, WORD6(v20[0]) + 16) != 0);
  }
  v11 = _sqlite_bulkEnd(a1);
  if (v5)
    v12 = v5;
  else
    v12 = 22;
  if (v11)
    return v12;
  else
    return v5;
}

uint64_t si_CollectTMLifeBegin()
{
  return 0;
}

uint64_t si_CollectTMLifeEnd()
{
  return 0;
}

uint64_t si_getOID(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  (*(void (**)(void))(a9 + 16))();
  return 1;
}

BOOL si_dboIdMatches(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7)
{
  const char *v10;
  uint64_t v11;
  uint64_t v13;

  v10 = *(const char **)a7;
  if (!strcmp(*(const char **)a7, "_kMDItemIndexID"))
  {
    if (!a5)
      return 0;
    v11 = a5[4];
  }
  else
  {
    if (strcmp(v10, "_kMDItemOIDParent"))
    {
      if (a4)
      {
        v13 = a4;
        goto LABEL_12;
      }
      if (a5)
      {
        v11 = *a5;
        goto LABEL_11;
      }
      return 0;
    }
    if (!a5)
      return 0;
    v11 = a5[3];
  }
LABEL_11:
  v13 = v11;
LABEL_12:
  if ((*(_DWORD *)(a7 + 24) - 11) < 2)
    return _db_rangeCompare(7, a7, 4uLL, (unsigned int *)&v13, 0, 0, 0) == 1;
  if (convert_value_to_type(7u, a7))
    return 0;
  return db_compare_val(7);
}

uint64_t si_getFilesystemField(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v11;
  void (**v13)(CatInfoGotten_OID *__hidden);
  _QWORD v14[2];
  uint64_t v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  char v19;
  uint64_t v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if (!a8 && !*(_BYTE *)(a1 + 2072))
    {
      bzero(v14, 0x470uLL);
      v14[1] = a1;
      v15 = a3;
      v16 = 0u;
      v17 = 0u;
      v18 = 0u;
      v11 = (*(_DWORD *)(a1 + 6584) >> 17) & 1;
LABEL_7:
      v19 = v11;
      v13 = &off_1E6E2A0B8;
      v20 = a4;
      CatInfoGotten_OID::~CatInfoGotten_OID((CatInfoGotten_OID *)&v13);
    }
  }
  else if (!a8)
  {
    bzero(v14, 0x470uLL);
    v15 = a3;
    v16 = 0u;
    v17 = 0u;
    v18 = 0u;
    LOBYTE(v11) = 1;
    goto LABEL_7;
  }
  return 0;
}

uint64_t si_matchFilesystemField()
{
  return 0;
}

int *si_getOIDPath(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v10;
  _QWORD *v11;
  int v12;
  uint64_t v13;
  int *result;
  int v15;
  _QWORD *v16;
  _QWORD *Dbo;
  int Path;
  int v19;
  __CFString *Mutable;
  unint64_t v21;
  int v22;
  _QWORD v23[513];

  v13 = MEMORY[0x1E0C80A78](a1);
  v23[512] = *MEMORY[0x1E0C80C00];
  result = *(int **)(v13 + 1184);
  if (result)
  {
    if (*(_QWORD *)(v13 + 6624))
    {
      v15 = v12;
      v16 = v11;
      Dbo = v11;
      if (v11 || (Dbo = iterateToGetDbo(result, v10)) != 0)
      {
        if (Dbo[3]
          && (bzero(v23, 0x1000uLL),
              makeThreadId(),
              (Path = directoryStoreGetPath(*(_QWORD *)(v13 + 6624), Dbo[3], (uint64_t)v23)) != 0))
        {
          v19 = Path;
          Mutable = CFStringCreateMutable(0, 0);
          if (v19 >= 1)
          {
            v21 = v19 + 1;
            do
              CFStringAppendFormat(Mutable, 0, CFSTR("/%lld"), v23[(v21-- - 2)]);
            while (v21 > 1);
          }
          CFStringAppendFormat(Mutable, 0, CFSTR("/%lld"), Dbo[3]);
          CFStringAppendFormat(Mutable, 0, CFSTR("/%lld"), *Dbo);
          (*(void (**)(uint64_t, uint64_t, __CFString *, _QWORD, _QWORD, uint64_t))(a9 + 16))(a9, 34, Mutable, 0, v15, a10);
          CFRelease(Mutable);
          v22 = 1;
        }
        else
        {
          v22 = 0;
        }
        if (Dbo != v16)
          free(Dbo);
      }
      else
      {
        v22 = 0;
      }
      return (int *)(v22 != 0);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

BOOL si_getOIDParent(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (a5)
    (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, uint64_t))(a9 + 16))(a9, 23, *(_QWORD *)(a5 + 24), 0, a6, a10);
  return a5 != 0;
}

uint64_t si_getPSIDPath(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t result;
  uint64_t v14;
  _BYTE v15[1024];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (!*(_QWORD *)(a1 + 1184) || *(_BYTE *)(a1 + 2072))
    return 0;
  result = 0;
  if (a4 && *(_QWORD *)(a1 + 1416))
  {
    makeThreadId();
    bzero(v15, 0x400uLL);
    v14 = *(_QWORD *)(a1 + 1416);
    if (*(_BYTE *)(v14 + 240))
      return 0;
    result = (*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, _QWORD, _QWORD, _QWORD, _QWORD, uint64_t))(v14 + 40))(v14, a4, v15, 0, 0, 0, 0, -1);
    if (result)
    {
      (*(void (**)(uint64_t, uint64_t, uint64_t, _QWORD, _QWORD, uint64_t))(a9 + 16))(a9, 28, result, 0, a6, a10);
      return 1;
    }
  }
  return result;
}

uint64_t si_getFPIsTrashed(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t result;

  if (!*(_QWORD *)(a1 + 1184) || *(_BYTE *)(a1 + 2072))
    return 0;
  result = 0;
  if (a4)
  {
    if (*(_QWORD *)(a1 + 1416))
    {
      (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, uint64_t))(a9 + 16))(a9, 20, 0, 0, a6, a10);
      return 1;
    }
  }
  return result;
}

BOOL si_getIndexID(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (a5)
    (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, uint64_t))(a9 + 16))(a9, 19, *(_QWORD *)(a5 + 32), 0, a6, a10);
  return a5 != 0;
}

BOOL si_getCachedCachedIcon(uint64_t a1, int a2, int a3, unint64_t a4, uint64_t a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  char *v13;
  int v14;
  int v15;
  off_t v16;
  size_t v17;
  void *v18;
  void *v19;
  _BOOL8 v20;
  unint64_t v22;
  _BYTE *v23;
  char __str[1024];
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v22 = 0;
  v23 = 0;
  if (a5
    && (db_get_field_locked(*(int **)(a1 + 1184), a5, "_kMDItemThumbnailDataExists", &v22, &v23) || !*v23))
  {
    return 0;
  }
  bzero(__str, 0x400uLL);
  v13 = si_cache_relative_path_for_oid(a4, "img", __str, *(unsigned __int8 *)(a1 + 2072));
  if (!v13)
    return 0;
  v14 = openat(*(_DWORD *)(a1 + 32), v13, 0);
  if (v14 == -1)
    return 0;
  v15 = v14;
  v16 = lseek(v14, 0, 2);
  if (v16 >= 0x100000 || (v17 = v16, v18 = mmap(0, v16, 1, 1025, v15, 0), v18 == (void *)-1))
  {
    v20 = 0;
  }
  else
  {
    v19 = v18;
    v20 = (*(uint64_t (**)(uint64_t, uint64_t, void *, size_t, _QWORD, uint64_t))(a9 + 16))(a9, 33, v18, v17, a6, a10) != 0;
    munmap(v19, v17);
  }
  close(v15);
  return v20;
}

uint64_t si_dboMatchingAttributes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v12;
  uint64_t v13;
  char v14;
  unint64_t v15;
  int v16;
  int *v17;
  int v18;

  v12 = a6;
  v13 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, uint64_t))(a9 + 16))(a9, 6, 0, 0, a6, a10);
  if (a5)
  {
    if (*(_DWORD *)(a5 + 12) >= 0x31u)
    {
      v14 = 0;
      v15 = a5 + 48;
      while (!*(_BYTE *)(v15 + 12) || (*(_WORD *)(v15 + 2) & 0x100) != 0)
      {
LABEL_15:
        v15 += *(unsigned int *)(v15 + 8) + 13;
        if (v15 >= a5 + (unint64_t)*(unsigned int *)(a5 + 12))
          goto LABEL_16;
      }
      v16 = *(_DWORD *)(v15 + 4);
      if (v16 == *(_DWORD *)(a1 + 2052))
      {
        if ((v14 & 1) == 0)
        {
          v17 = *(int **)(a1 + 1184);
          v16 = *(_DWORD *)(a1 + 2016);
LABEL_11:
          addFieldName(a9, v13, v17, v16);
        }
      }
      else if (((v16 == *(_DWORD *)(a1 + 2016)) & v14) == 0)
      {
        v17 = *(int **)(a1 + 1184);
        goto LABEL_11;
      }
      v18 = *(_DWORD *)(v15 + 4);
      if (v18 == *(_DWORD *)(a1 + 2052) || v18 != *(_DWORD *)(a1 + 2016))
        v14 = 1;
      goto LABEL_15;
    }
LABEL_16:
    if ((*(_BYTE *)(a5 + 41) & 0x80) != 0
      && (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, _QWORD, uint64_t))(a9 + 16))(a9, 30, 0x40000000, 0, 0, v13))
    {
      (*(void (**)(uint64_t, uint64_t, const char *, uint64_t, _QWORD, uint64_t))(a9 + 16))(a9, 31, "kMDItemTextContent", 0x40000000, 0, v13);
    }
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t, _QWORD, uint64_t, uint64_t))(a9 + 16))(a9, 7, v13, 0, v12, a10);
  return 1;
}

BOOL si_getAccumulatedSizes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v10;
  uint64_t (*v12)(uint64_t, uint64_t, _QWORD, _QWORD);
  pthread_mutex_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v17;
  uint64_t v18;
  uint64_t i;
  uint64_t v20;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char v26;
  uint64_t v27;
  uint64_t j;
  _BYTE v29[2048];
  _QWORD v30[2];
  uint64_t v31;
  uint64_t v32;
  char __str[16];
  __int128 v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v10 = *(_QWORD *)(a1 + 1184);
  if (v10)
  {
    v12 = *(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD))(a9 + 16);
    v13 = (pthread_mutex_t *)(a1 + 6976);
    if (*(_BYTE *)(a1 + 2072))
    {
      v31 = a6;
      v14 = v12(a9, 10, 0, 0);
      v15 = pthread_mutex_lock(v13);
      v30[1] = v30;
      MEMORY[0x1E0C80A78](v15);
      bzero(v29, 0x800uLL);
      v16 = 0;
      v17 = 0;
      do
      {
        if ((*(_QWORD *)&v29[v16 + 8] & 0x8000000000000000) != 0)
        {
          v18 = 0;
          v17 = 1;
        }
        else
        {
          v18 = *(_QWORD *)(a1 + 7048 + v16);
        }
        *(_QWORD *)&v29[v16 + 8] = v18;
        v16 += 8;
      }
      while (v16 != 2040);
      v32 = a10;
      pthread_mutex_unlock(v13);
      for (i = 1; i != 256; ++i)
      {
        v20 = *(_QWORD *)&v29[8 * i];
        if (v20)
        {
          *(_OWORD *)__str = 0u;
          v34 = 0u;
          snprintf(__str, 0x20uLL, "%d", i);
          (*(void (**)(uint64_t, uint64_t, char *, _QWORD, uint64_t, uint64_t))(a9 + 16))(a9, 14, __str, 0, i - 1, v14);
          (*(void (**)(uint64_t, uint64_t, uint64_t, _QWORD, uint64_t, uint64_t))(a9 + 16))(a9, 23, v20, 0, i - 1, v14);
        }
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, _QWORD, uint64_t, uint64_t))(a9 + 16))(a9, 11, v14, 0, v31, v32);
      if ((v17 & 1) != 0)
        goto LABEL_13;
    }
    else
    {
      v22 = a6;
      v23 = v12(a9, 6, 0, 0);
      v24 = pthread_mutex_lock(v13);
      MEMORY[0x1E0C80A78](v24);
      v25 = 0;
      v26 = 0;
      memset(&v29[1872], 0, 176);
      do
      {
        v27 = *(_QWORD *)(a1 + 7048 + v25);
        v26 |= v27 < 0;
        *(_QWORD *)&v29[v25 + 1880] = v27 & ~(v27 >> 63);
        v25 += 8;
      }
      while (v25 != 168);
      pthread_mutex_unlock(v13);
      for (j = 0; j != 21; ++j)
        (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, uint64_t))(a9 + 16))(a9, 23, *(_QWORD *)&v29[8 * j + 1880], 0, j, v23);
      (*(void (**)(uint64_t, uint64_t, uint64_t, _QWORD, uint64_t, uint64_t))(a9 + 16))(a9, 7, v23, 0, v22, a10);
      if ((v26 & 1) != 0)
LABEL_13:
        _SIRecomputeSizesWithCallback(a1, 0, &__block_literal_global_6728);
    }
  }
  return v10 != 0;
}

uint64_t si_getCachedCachedIconPath(uint64_t a1, int a2, int a3, unint64_t a4, uint64_t a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  size_t v14;
  stat v16;
  unint64_t v17;
  _BYTE *v18;
  char __dst[2048];
  uint64_t v20;

  v20 = *MEMORY[0x1E0C80C00];
  v17 = 0;
  v18 = 0;
  if (a5
    && (db_get_field_locked(*(int **)(a1 + 1184), a5, "_kMDItemThumbnailDataExists", &v17, &v18) || !*v18))
  {
    return 0;
  }
  bzero(__dst, 0x800uLL);
  if (fcntl(*(_DWORD *)(a1 + 32), 50, __dst) < 0)
    return 0;
  if (!__dst[0])
    return 0;
  v14 = strlcat(__dst, "/", 0x400uLL);
  if (v14 > 0x3FF)
    return 0;
  si_cache_relative_path_for_oid(a4, "img", &__dst[v14], *(unsigned __int8 *)(a1 + 2072));
  memset(&v16, 0, sizeof(v16));
  if (!a5)
  {
    if (stat(__dst, &v16))
      return 0;
  }
  (*(void (**)(uint64_t, uint64_t, char *, _QWORD, _QWORD, uint64_t))(a9 + 16))(a9, 28, __dst, 0, a6, a10);
  return 1;
}

uint64_t si_getFinderOpenDate()
{
  return 0;
}

uint64_t si_matchFilesystemName()
{
  return 0;
}

BOOL si_getIndexRankingDate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  unint64_t v12;
  uint64_t v13;
  _BOOL4 v14;
  _BOOL8 v15;
  CFDateRef v16;
  unsigned int v18;

  if (!a5)
    return 0;
  v12 = *(_QWORD *)(a5 + 32);
  v13 = si_indexForDocId(a1, v12);
  if (!v13)
    return 0;
  v18 = 0;
  if (a8)
    v14 = (*(_BYTE *)(a8 + 8) & 4) == 0;
  else
    v14 = 1;
  _CIGetDocIDInfo(v13, v12, 0, &v18, 0, 0, v14);
  v15 = v18 != 0;
  if (v18)
  {
    v16 = CFDateCreate(0, (double)v18);
    (*(void (**)(uint64_t, uint64_t, CFDateRef, _QWORD, _QWORD, uint64_t))(a9 + 16))(a9, 34, v16, 0, a6, a10);
    CFRelease(v16);
  }
  return v15;
}

uint64_t si_getIndexRankingScore(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  unint64_t v12;
  uint64_t v13;
  _BOOL4 v14;
  uint64_t v15;
  unsigned int v17;

  if (!a5)
    return 0;
  v12 = *(_QWORD *)(a5 + 32);
  v13 = si_indexForDocId(a1, v12);
  if (!v13)
    return 0;
  v17 = 0;
  if (a8)
    v14 = (*(_BYTE *)(a8 + 8) & 4) == 0;
  else
    v14 = 1;
  v15 = _CIGetDocIDInfo(v13, v12, 0, 0, (unint64_t)&v17, 0, v14);
  if ((_DWORD)v15)
    (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, uint64_t))(a9 + 16))(a9, 26, v17, 0, a6, a10);
  return v15;
}

uint64_t si_dboDisplayNameMatchingAttributes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  int v12;

  if (a5)
  {
    v9 = *(unsigned int *)(a5 + 12);
    if (v9 >= 0x31)
    {
      v10 = a5 + v9;
      v11 = a5 + 48;
      do
      {
        if (*(_BYTE *)(v11 + 12))
        {
          if ((*(_WORD *)(v11 + 2) & 0x100) == 0)
          {
            v12 = *(_DWORD *)(v11 + 4);
            if (v12 == *(_DWORD *)(a1 + 2016) || v12 == *(_DWORD *)(a1 + 2052))
              break;
          }
        }
        v11 += *(unsigned int *)(v11 + 8) + 13;
      }
      while (v11 < v10);
    }
  }
  (*(void (**)(void))(a9 + 16))();
  return 1;
}

uint64_t si_getIndexRankingContainer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  unint64_t v12;
  uint64_t v13;
  _BOOL4 v14;
  uint64_t v15;
  unsigned int v17;

  if (!a5)
    return 0;
  v12 = *(_QWORD *)(a5 + 32);
  v13 = si_indexForDocId(a1, v12);
  if (!v13)
    return 0;
  v17 = 0;
  if (a8)
    v14 = (*(_BYTE *)(a8 + 8) & 4) == 0;
  else
    v14 = 1;
  v15 = _CIGetDocIDInfo(v13, v12, 0, 0, 0, (unint64_t)&v17, v14);
  if ((_DWORD)v15)
    (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, uint64_t))(a9 + 16))(a9, 22, v17, 0, a6, a10);
  return v15;
}

uint64_t si_getRenderValues(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  return si_getRenderOrEngagementValues(*(int **)(a1 + 1184), a4, a5, a6, a9, a10, "_kMDItemRenderData");
}

char **si_getRenderValuesRequired()
{
  return &si_getRenderValuesRequired(__SI *)::nameArray;
}

BOOL si_getIndexRankingDateSeconds(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  unint64_t v12;
  uint64_t v13;
  _BOOL4 v14;
  _BOOL8 v15;
  unsigned int v17;

  if (!a5)
    return 0;
  v12 = *(_QWORD *)(a5 + 32);
  v13 = si_indexForDocId(a1, v12);
  if (!v13)
    return 0;
  v17 = 0;
  if (a8)
    v14 = (*(_BYTE *)(a8 + 8) & 4) == 0;
  else
    v14 = 1;
  _CIGetDocIDInfo(v13, v12, 0, &v17, 0, 0, v14);
  v15 = v17 != 0;
  if (v17)
    (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, uint64_t))(a9 + 16))(a9, 22, v17, 0, a6, a10);
  return v15;
}

uint64_t si_getFSDisplayName()
{
  return 0;
}

BOOL si_getFPItemIdentifier(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  _BOOL8 result;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  const char *v19;
  size_t v20;
  uint64_t v21;
  const char *v22;
  const char *v23;
  int v24;
  uint64_t (*v25)(void);
  int v26;
  _WORD *v27;
  uint64_t v28;
  _BYTE v29[1024];
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  if (!*(_QWORD *)(a1 + 1184) || *(_BYTE *)(a1 + 2072))
    return 0;
  result = 0;
  if (a5 && a4 && *(_QWORD *)(a1 + 1416))
  {
    makeThreadId();
    if (a4 == 2)
    {
      (*(void (**)(uint64_t, uint64_t, const char *, _QWORD, _QWORD, uint64_t))(a9 + 16))(a9, 28, "NSFileProviderRootContainerItemIdentifier", 0, a6, a10);
LABEL_20:
      v18 = 1;
      return v18 != 0;
    }
    bzero(v29, 0x400uLL);
    v27 = 0;
    v28 = 0;
    v15 = 0;
    if (!db_get_field_locked(*(int **)(a1 + 1184), a5, "_kMDItemFileName", (unint64_t *)&v27, &v28))
    {
      if (*v27 != 11 || (v27[1] & 0x10) != 0)
      {
        v15 = 0;
      }
      else
      {
        v16 = *(_QWORD *)(a1 + 1416);
        if (v16 && !*(_BYTE *)(v16 + 160) && (v25 = *(uint64_t (**)(void))(v16 + 184)) != 0)
        {
          v15 = v29;
          v26 = v25();
          if (v26)
            v15 = 0;
          if (v26 != 45)
            goto LABEL_18;
        }
        else
        {
          v15 = 0;
          v29[0] = 0;
        }
      }
    }
    v17 = *(_QWORD *)(a1 + 1416);
    if (!*(_BYTE *)(v17 + 240))
    {
      v19 = (const char *)(*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, _QWORD, _QWORD, _QWORD, _QWORD, uint64_t))(v17 + 40))(v17, 2, v29, 0, 0, 0, 0, -1);
      if (v19)
      {
        v20 = strlen(v19);
        v21 = *(_QWORD *)(a1 + 1416);
        if (!*(_BYTE *)(v21 + 240))
        {
          v22 = (const char *)(*(uint64_t (**)(uint64_t, uint64_t, _BYTE *, _QWORD, _QWORD, _QWORD, _QWORD, uint64_t))(v21 + 40))(v21, a4, v29, 0, 0, 0, 0, -1);
          if (v22)
          {
            v23 = v22;
            if (strlen(v22) > v20)
            {
              v15 = (char *)&v23[v20 - 1];
              do
                v24 = *++v15;
              while (v24 == 47);
LABEL_19:
              (*(void (**)(uint64_t, uint64_t, char *, _QWORD, _QWORD, uint64_t))(a9 + 16))(a9, 28, v15, 0, a6, a10);
              goto LABEL_20;
            }
          }
        }
      }
    }
LABEL_18:
    if (!v15)
    {
      v18 = 0;
      return v18 != 0;
    }
    goto LABEL_19;
  }
  return result;
}

uint64_t si_getIndexCookie(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  const __CFUUID *v11;
  CFStringRef v12;

  v11 = (const __CFUUID *)si_storecookieRef(a1);
  v12 = CFUUIDCreateString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v11);
  (*(void (**)(uint64_t, uint64_t, CFStringRef, _QWORD, _QWORD, uint64_t))(a9 + 16))(a9, 34, v12, 0, a6, a10);
  CFRelease(v12);
  return 1;
}

uint64_t si_dboTopMatchingAttribute(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  unsigned __int16 *v14;
  unsigned __int16 *v15;
  float v16;
  const char *field_name_for_id_locked;
  char *v18;
  const __CFNumber *Value;
  uint64_t v21;
  char **v22;
  uint64_t v23;
  uint64_t v24;
  float valuePtr;
  _QWORD block[10];

  memset(&block[4], 0, 24);
  block[0] = MEMORY[0x1E0C809B0];
  block[2] = ___ZL26si_dboTopMatchingAttributeP4__SIPKcP11__SIUserCtxxP6db_objiPP8db_fieldP13CatInfoGottenU13block_pointerFPv15SI_OBJECT_EVENT15si_event_data_tmSC_ESC__block_invoke;
  block[3] = &__block_descriptor_tmp_3734;
  block[7] = constStrDictionaryCopyDescriptionCallBack;
  block[1] = 0x40000000;
  block[8] = constStrDictionaryEqualCallBack;
  block[9] = constStrDictionaryHashCallBack;
  if (si_dboTopMatchingAttribute(__SI *,char const*,__SIUserCtx *,long long,db_obj *,int,db_field **,CatInfoGotten *,void *({block_pointer})(SI_OBJECT_EVENT,si_event_data_t,unsigned long,void *),void *)::once == -1)
  {
    if (!a5)
      return 0;
  }
  else
  {
    dispatch_once(&si_dboTopMatchingAttribute(__SI *,char const*,__SIUserCtx *,long long,db_obj *,int,db_field **,CatInfoGotten *,void *({block_pointer})(SI_OBJECT_EVENT,si_event_data_t,unsigned long,void *),void *)::once, block);
    if (!a5)
      return 0;
  }
  if (*(_DWORD *)(a5 + 12) >= 0x31u)
  {
    v14 = 0;
    v15 = (unsigned __int16 *)(a5 + 48);
    v16 = 0.0;
    do
    {
      if (*((_BYTE *)v15 + 12) && (v15[1] & 0x100) == 0)
      {
        field_name_for_id_locked = (const char *)db_get_field_name_for_id_locked(*(int **)(a1 + 1184), *((_DWORD *)v15 + 1));
        v18 = *((_DWORD *)v15 + 1) == *(_DWORD *)(a1 + 2052) ? "kMDItemDisplayName" : (char *)field_name_for_id_locked;
        if (v18)
        {
          Value = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)si_dboTopMatchingAttribute(__SI *,char const*,__SIUserCtx *,long long,db_obj *,int,db_field **,CatInfoGotten *,void *({block_pointer})(SI_OBJECT_EVENT,si_event_data_t,unsigned long,void *),void *)::__attribute_importance_dictionary, v18);
          if (Value)
          {
            valuePtr = 0.0;
            if (CFNumberGetValue(Value, kCFNumberFloatType, &valuePtr))
            {
              if (valuePtr > v16 || v14 == 0)
              {
                v16 = valuePtr;
                v14 = v15;
              }
            }
          }
        }
      }
      v15 = (unsigned __int16 *)((char *)v15 + *((unsigned int *)v15 + 2) + 13);
    }
    while ((unint64_t)v15 < a5 + (unint64_t)*(unsigned int *)(a5 + 12));
    if (v14)
    {
      v21 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, uint64_t))(a9 + 16))(a9, 12, 0, 0, a6, a10);
      addFieldName(a9, v21, *(int **)(a1 + 1184), *((_DWORD *)v14 + 1));
      if (a3)
        v22 = *(char ***)(a3 + 120);
      else
        v22 = 0;
      v23 = 1;
      eventParseField((const char *)v14, *v14, a9, v21, *(int **)(a1 + 1184), v22, 0, 1);
      (*(void (**)(uint64_t, uint64_t, uint64_t, _QWORD, _QWORD, uint64_t))(a9 + 16))(a9, 13, v21, 0, a6, a10);
      return v23;
    }
  }
  if ((*(_BYTE *)(a5 + 41) & 0x80) == 0)
    return 0;
  v24 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, uint64_t))(a9 + 16))(a9, 12, 0, 0, a6, a10);
  if (!(*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, _QWORD, uint64_t))(a9 + 16))(a9, 30, 0x40000000, 0, 0, v24))(*(void (**)(uint64_t, uint64_t, const char *, uint64_t, _QWORD, uint64_t))(a9 + 16))(a9, 31, "kMDItemTextContent", 0x40000000, 0, v24);
  (*(void (**)(uint64_t, uint64_t, uint64_t, _QWORD, _QWORD, uint64_t))(a9 + 16))(a9, 13, v24, 0, a6, a10);
  return 1;
}

uint64_t si_fsGroupIdAttr(int a1, int a2, int a3, int a4, int a5, int a6, int a7, CatInfoGotten *this)
{
  if (this)
    CatInfoGotten::fastPath(this);
  return 0;
}

BOOL si_fsGroupIdMatch(int a1, int a2, int a3, int a4, int a5, CatInfoGotten *this, uint64_t a7)
{
  if (this)
    CatInfoGotten::fastPath(this);
  convert_value_to_type(5u, a7);
  return db_compare_val(5);
}

uint64_t si_getEngagementValues(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  return si_getRenderOrEngagementValues(*(int **)(a1 + 1184), a4, a5, a6, a9, a10, "_kMDItemEngagementData");
}

char **si_getEngagementValuesRequired()
{
  return &si_getEngagementValuesRequired(__SI *)::nameArray;
}

uint64_t si_getHealthCheckDate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t result;
  const void *v12;

  if (!*(_QWORD *)(a1 + 1184))
    return 0;
  result = (uint64_t)SICopyProperty(a1, CFSTR("kStorePropertyHealthCheckCompleteTime"));
  if (result)
  {
    v12 = (const void *)result;
    (*(void (**)(uint64_t, uint64_t, uint64_t, _QWORD, _QWORD, uint64_t))(a9 + 16))(a9, 34, result, 0, a6, a10);
    CFRelease(v12);
    return 1;
  }
  return result;
}

uint64_t si_getCachedTextContent(uint64_t result, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v12;
  const char *v13;
  int v14;
  off_t v15;
  size_t v16;
  void *v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  unint64_t v22;
  BOOL v23;
  char v24;
  unsigned __int8 *v25;
  int v26;
  uint64_t v27;
  char v28;
  _BYTE v29[1008];
  uint64_t v30;
  char v31[1024];
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  if (result)
  {
    v12 = result;
    bzero(v31, 0x400uLL);
    v13 = si_cache_relative_path_for_oid(a4, "txt", v31, *(unsigned __int8 *)(v12 + 2072));
    if (v13)
    {
      v13 = (const char *)openat(*(_DWORD *)(v12 + 32), v13, 0);
      if ((_DWORD)v13 != -1)
      {
        v14 = (int)v13;
        v15 = lseek((int)v13, 0, 2);
        if (v15 >= 1)
        {
          v16 = v15 >= 0x20000 ? 0x20000 : v15;
          v17 = mmap(0, v16, 1, 1025, v14, 0);
          if (v17 != (void *)-1)
          {
            v18 = v17;
            (*(void (**)(uint64_t, uint64_t, void *, size_t, _QWORD, uint64_t))(a9 + 16))(a9, 33, v17, v16, a6, a10);
            munmap(v18, v16);
            close(v14);
            return 1;
          }
        }
        v13 = (const char *)close(v14);
      }
    }
    if (!*(_QWORD *)(v12 + 1296))
      return 0;
    MEMORY[0x1E0C80A78](v13);
    bzero(v29, 0x3E9uLL);
    v30 = 0;
    if (doc_store_get_document(*(const void **)(v12 + 1296), a4, (uint64_t)v29, (uint64_t)&v30))
      return 0;
    v19 = v30;
    if (!v30)
      return 0;
    v20 = v30 - 1;
    v21 = (char)v29[v30 - 1];
    if ((v21 & 0x80000000) == 0)
    {
LABEL_17:
      v29[v19] = 0;
      (*(void (**)(uint64_t, uint64_t, _BYTE *, _QWORD, _QWORD, uint64_t))(a9 + 16))(a9, 28, v29, 0, a6, a10);
      return 1;
    }
    if ((v21 + 62) > 0x32u)
    {
      if (v29[v30 - 1] > 0xBFu)
        goto LABEL_17;
      v20 = v30 - 2;
      v22 = v29[v30 - 2];
      if ((v22 + 32) > 0x14u)
      {
        if ((char)v22 > -65)
          goto LABEL_17;
        v27 = v30 - 3;
        v28 = v29[v30 - 3];
        if ((v28 + 16) > 4u)
          goto LABEL_17;
        if (((byte_1B86307F2[v22 >> 4] >> (v28 & 7)) & 1) == 0)
          goto LABEL_17;
        v30 -= 3;
        v19 -= 3;
        if (v27)
          goto LABEL_17;
        return 0;
      }
      v23 = v22 > 0xEF;
      v24 = v22 & 7;
      v25 = (unsigned __int8 *)&a00000000000000[v22 & 0xF];
      v26 = v29[v30 - 1] >> 5;
      if (v23)
      {
        LOBYTE(v26) = v24;
        v25 = &byte_1B86307F2[(unint64_t)v29[v30 - 1] >> 4];
      }
      if (((*v25 >> v26) & 1) == 0)
        goto LABEL_17;
    }
    v30 = v20;
    v19 = v20;
    if (v20)
      goto LABEL_17;
    return 0;
  }
  return result;
}

uint64_t si_getFSDisplayKind()
{
  return 0;
}

uint64_t si_fsKindMatch()
{
  return 0;
}

uint64_t si_legacyGroupIdAttr()
{
  return 0;
}

BOOL si_getIndexGroupId(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  unint64_t v12;
  uint64_t v13;
  unsigned int v14;

  if (a5)
  {
    v12 = *(_QWORD *)(a5 + 32);
    v13 = si_indexForDocId(a1, v12);
    v14 = _CIGetGroupForDocId(v13, v12);
    (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, uint64_t))(a9 + 16))(a9, 18, v14, 0, a6, a10);
  }
  return a5 != 0;
}

void *si_dboNoAttrRequired()
{
  return &si_dboNoAttrRequired(__SI *)::nameArray;
}

uint64_t si_getItemRecipientEmailAddresses(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  int *v10;
  BOOL v11;
  uint64_t v12;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  CFDictionaryRef v23;
  CFDictionaryRef v24;
  unsigned __int8 *v25;
  unint64_t v26;
  const __CFAllocator *v27;
  unsigned __int16 *v28;
  CFDictionaryRef v29;
  CFDictionaryRef v30;
  CFDictionaryRef v31;
  int v33[2];
  _QWORD v34[2];
  uint64_t (*v35)(uint64_t, const __CFArray *);
  void *v36;
  uint64_t v37;
  _QWORD *v38;
  uint64_t v39;
  _QWORD v40[3];
  int v41;
  uint64_t v42;

  v10 = *(int **)(a1 + 1184);
  if (a5)
    v11 = v10 == 0;
  else
    v11 = 1;
  v12 = !v11;
  if (!v11)
  {
    v17 = a6;
    v18 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, uint64_t))(a9 + 16))(a9, 6, 0, 0, a6, a10);
    v42 = 0;
    v40[0] = 0;
    v40[1] = v40;
    v40[2] = 0x2000000000;
    v41 = 0;
    v34[0] = MEMORY[0x1E0C809B0];
    v34[1] = 0x40000000;
    v35 = ___ZL33si_getItemRecipientEmailAddressesP4__SIPKcP11__SIUserCtxxP6db_objiPP8db_fieldP13CatInfoGottenU13block_pointerFPv15SI_OBJECT_EVENT15si_event_data_tmSC_ESC__block_invoke;
    v36 = &unk_1E6E2FA20;
    v37 = a9;
    v38 = v40;
    v39 = v18;
    if (a6 && a7)
    {
      v19 = (uint64_t *)(a7 + 8 * v17);
      v20 = *v19;
      v21 = v19[1];
      v22 = v19[2];
      if (*v19)
      {
        v42 = v20 + 13;
        v23 = _decodeSDBField(*(_QWORD *)(a1 + 1184), (unsigned __int16 *)v20, (unsigned __int8 *)(v20 + 13), 0, 0, 0, 1, (CFAllocatorRef)*MEMORY[0x1E0C9AE00]);
        v35((uint64_t)v34, v23);
        CFRelease(v23);
      }
      if (v21)
      {
        v42 = v21 + 13;
        v24 = _decodeSDBField(*(_QWORD *)(a1 + 1184), (unsigned __int16 *)v21, (unsigned __int8 *)(v21 + 13), 0, 0, 0, 1, (CFAllocatorRef)*MEMORY[0x1E0C9AE00]);
        v35((uint64_t)v34, v24);
        CFRelease(v24);
      }
      if (!v22)
        goto LABEL_23;
      v25 = (unsigned __int8 *)(v22 + 13);
      v42 = v22 + 13;
      v26 = *(_QWORD *)(a1 + 1184);
      v27 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v28 = (unsigned __int16 *)v22;
    }
    else
    {
      *(_QWORD *)v33 = 0;
      if (!db_get_field_locked(v10, a5, "kMDItemPrimaryRecipientEmailAddresses", (unint64_t *)v33, &v42))
      {
        v29 = _decodeSDBField(*(_QWORD *)(a1 + 1184), *(unsigned __int16 **)v33, (unsigned __int8 *)(*(_QWORD *)v33 + 13), 0, 0, 0, 1, (CFAllocatorRef)*MEMORY[0x1E0C9AE00]);
        v35((uint64_t)v34, v29);
        CFRelease(v29);
      }
      if (!db_get_field_locked(v10, a5, "kMDItemAdditionalRecipientEmailAddresses", (unint64_t *)v33, &v42))
      {
        v30 = _decodeSDBField(*(_QWORD *)(a1 + 1184), *(unsigned __int16 **)v33, (unsigned __int8 *)(*(_QWORD *)v33 + 13), 0, 0, 0, 1, (CFAllocatorRef)*MEMORY[0x1E0C9AE00]);
        v35((uint64_t)v34, v30);
        CFRelease(v30);
      }
      if (db_get_field_locked(v10, a5, "kMDItemHiddenAdditionalRecipientEmailAddresses", (unint64_t *)v33, &v42))goto LABEL_23;
      v26 = *(_QWORD *)(a1 + 1184);
      v28 = *(unsigned __int16 **)v33;
      v25 = (unsigned __int8 *)(*(_QWORD *)v33 + 13);
      v27 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
    }
    v31 = _decodeSDBField(v26, v28, v25, 0, 0, 0, 1, v27);
    v35((uint64_t)v34, v31);
    CFRelease(v31);
LABEL_23:
    (*(void (**)(uint64_t, uint64_t, uint64_t, _QWORD, uint64_t, uint64_t))(a9 + 16))(a9, 7, v18, 0, v17, a10);
    _Block_object_dispose(v40, 8);
  }
  return v12;
}

BOOL si_itemRecipientEmailAddressesMatch(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  int *v8;
  uint64_t v11;
  unint64_t v12;

  v7 = 0;
  if (a5)
  {
    v8 = *(int **)(a1 + 1184);
    if (v8)
    {
      v11 = 0;
      v12 = 0;
      if (convert_value_to_type(0xBu, a7))
        return 0;
      if (db_get_field_locked(v8, a5, "kMDItemPrimaryRecipientEmailAddresses", &v12, &v11)
        || (v7 = 1, !do_compare((uint64_t)v8)))
      {
        if (db_get_field_locked(v8, a5, "kMDItemAdditionalRecipientEmailAddresses", &v12, &v11)
          || (v7 = 1, !do_compare((uint64_t)v8)))
        {
          if (!db_get_field_locked(v8, a5, "kMDItemHiddenAdditionalRecipientEmailAddresses", &v12, &v11))
            return do_compare((uint64_t)v8);
          return 0;
        }
      }
    }
  }
  return v7;
}

char **si_getItemRecipientEmailAddressesRequired()
{
  return si_getItemRecipientEmailAddressesRequired(__SI *)::nameArray;
}

BOOL si_dboLastModAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  if (a5)
    (*(void (**)(uint64_t, uint64_t, double, _QWORD, _QWORD, uint64_t))(a9 + 16))(a9, 25, (double)*(unint64_t *)(a5 + 16) / 1000000.0 - *MEMORY[0x1E0C9ADF8], 0, a6, a10);
  return a5 != 0;
}

BOOL si_dboLastModMatches(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  double v8;

  if (!a5)
    return 0;
  if ((*(_DWORD *)(a7 + 24) - 11) >= 2)
  {
    return !convert_value_to_type(0xCu, a7) && db_compare_val(12);
  }
  else
  {
    v8 = (double)*(unint64_t *)(a5 + 16) / 1000000.0 - *MEMORY[0x1E0C9ADF8];
    return _db_rangeCompare(12, a7, 8uLL, (unsigned int *)&v8, 0, 0, 0) == 1;
  }
}

uint64_t si_getDisplayNameWithExtensionsSynth(uint64_t a1, int a2, uint64_t a3, int a4, uint64_t a5, int a6, uint64_t a7, int a8, uint64_t a9, uint64_t a10)
{
  int *v12;
  char **v13;
  uint64_t result;
  int field_locked;
  void *key;
  uint64_t v17;

  v12 = *(int **)(a1 + 1184);
  if (a3)
  {
    v13 = *(char ***)(a3 + 120);
    if (!v12)
      return 0;
  }
  else
  {
    v13 = 0;
    if (!v12)
      return 0;
  }
  if (a5 && a6 && a7)
  {
    result = *(_QWORD *)(a7 + 8 * a6);
    if (!result)
    {
      result = *(_QWORD *)(a7 + 8 * a6 + 8);
      if (!result)
        return result;
    }
LABEL_17:
    eventParseField((const char *)result, *(unsigned __int16 *)result, a9, a10, v12, v13, 0, a6);
    return 1;
  }
  if (!a5)
    return 0;
  key = 0;
  v17 = 0;
  if (!db_get_field_locked(v12, a5, "_kMDItemDisplayNameWithExtensions", (unint64_t *)&key, &v17)
    && v17
    || (field_locked = db_get_field_locked(v12, a5, "kMDItemDisplayName", (unint64_t *)&key, &v17),
        result = 0,
        !field_locked)
    && v17)
  {
    result = (uint64_t)key;
    goto LABEL_17;
  }
  return result;
}

uint64_t si_collectDisplayNameWithExtensionsSynth(uint64_t a1, int a2, uint64_t a3, __CFSet *a4, char **a5)
{
  uint64_t v5;
  int *v6;
  BOOL v10;
  CFDictionaryRef v11;
  int v13[2];
  uint64_t v14;

  v5 = 0;
  if (a3)
  {
    v6 = *(int **)(a1 + 1184);
    if (v6)
    {
      *(_QWORD *)v13 = 0;
      v14 = 0;
      if (db_get_field_locked(v6, a3, "_kMDItemDisplayNameWithExtensions", (unint64_t *)v13, &v14))
        v10 = 1;
      else
        v10 = v14 == 0;
      if (!v10
        || (v5 = 0, !db_get_field_locked(v6, a3, "kMDItemDisplayName", (unint64_t *)v13, &v14))
        && v14)
      {
        v5 = 1;
        v11 = _decodeSDBField((unint64_t)v6, *(unsigned __int16 **)v13, (unsigned __int8 *)(*(_QWORD *)v13 + 13), a5, 0, 0, 1, 0);
        CFSetAddValue(a4, v11);
        CFRelease(v11);
      }
    }
  }
  return v5;
}

char **si_getDisplayNameWithExtensionsSynthRequired()
{
  return si_getDisplayNameWithExtensionsSynthRequired(__SI *)::nameArray;
}

uint64_t si_dboFileId(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  (*(void (**)(uint64_t, uint64_t, uint64_t, _QWORD, _QWORD, uint64_t))(a9 + 16))(a9, 23, a4, 0, a6, a10);
  return 1;
}

uint64_t si_getLabelIDs(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  int *v10;
  BOOL v11;
  uint64_t v12;
  uint64_t v15;
  int v16;
  unint64_t v17;
  const char *field_name_for_id_locked;
  const char *v19;
  char *v20;
  uint64_t v22;

  v10 = *(int **)(a1 + 1184);
  if (a5)
    v11 = v10 == 0;
  else
    v11 = 1;
  v12 = !v11;
  if (!v11)
  {
    v22 = a6;
    v15 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD))(a9 + 16))(a9, 6, 0, 0);
    if (*(_DWORD *)(a5 + 12) >= 0x31u)
    {
      v16 = 0;
      v17 = a5 + 48;
      do
      {
        if (*(int *)(a1 + 1276) < 73 || (*(_WORD *)(v17 + 2) & 4) != 0)
        {
          field_name_for_id_locked = (const char *)db_get_field_name_for_id_locked(v10, *(_DWORD *)(v17 + 4));
          if (field_name_for_id_locked)
          {
            v19 = field_name_for_id_locked;
            if (!strncmp("kMDLabel_", field_name_for_id_locked, 9uLL))
            {
              v20 = rindex(v19, 95);
              (*(void (**)(uint64_t, uint64_t, char *, _QWORD, _QWORD, uint64_t))(a9 + 16))(a9, 28, v20 + 1, 0, v16++, v15);
            }
          }
        }
        v17 += *(unsigned int *)(v17 + 8) + 13;
      }
      while (v17 < a5 + (unint64_t)*(unsigned int *)(a5 + 12));
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t, _QWORD, uint64_t, uint64_t))(a9 + 16))(a9, 7, v15, 0, v22, a10);
  }
  return v12;
}

uint64_t si_matchLabelIDs()
{
  return 0;
}

uint64_t si_getServerVersion(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  (*(void (**)(uint64_t, uint64_t, uint64_t, _QWORD, _QWORD, uint64_t))(a9 + 16))(a9, 28, sysVersionCStr, 0, a6, a10);
  return 1;
}

uint64_t si_getFPParentFileItemID()
{
  return 0;
}

uint64_t si_getSDBInfo(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v10;
  unint64_t v11;
  void *v12;
  int v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t result;
  uint64_t v17;
  int v18;
  uint64_t *v19;
  unint64_t v20;
  uint64_t v21;
  int obj;
  BOOL v23;
  __CFDictionary *Mutable;
  int v25;
  _DWORD *v26;
  CFDateRef v27;
  CFNumberRef v28;
  CFNumberRef v29;
  CFNumberRef v30;
  uint64_t v31;
  _BOOL4 v32;
  CFDateRef v33;
  CFNumberRef v34;
  CFNumberRef v35;
  CFNumberRef v36;
  CFNumberRef v37;
  uint64_t v38;
  unint64_t v39;
  int Path;
  int v41;
  __CFString *v42;
  unint64_t v43;
  uint64_t v44;
  CFDictionaryRef v45;
  CFDictionaryRef v46;
  const char *v47;
  CFStringRef v48;
  CFStringRef v49;
  unsigned int v50;
  float v51;
  unsigned int v52;
  unint64_t valuePtr;
  _QWORD v54[7];
  int v55;
  void *v56;
  _QWORD v57[513];

  v15 = (_QWORD *)MEMORY[0x1E0C80A78](a1);
  v57[512] = *MEMORY[0x1E0C80C00];
  v56 = v12;
  result = v15[148];
  if (result)
  {
    v17 = v14;
    v18 = v13;
    v19 = (uint64_t *)v12;
    v20 = v11;
    v21 = v10;
    if (v12
      || ((obj = db_get_obj((_DWORD *)result, v11, &v56, 0), result = 0, !obj) ? (v23 = v56 == 0) : (v23 = 1), !v23))
    {
      makeThreadId();
      Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
      if (v21)
        v25 = *(_DWORD *)(v21 + 176);
      else
        v25 = 0;
      v26 = (_DWORD *)v15[148];
      v54[0] = MEMORY[0x1E0C809B0];
      v54[1] = 0x40000000;
      v54[2] = ___ZL13si_getSDBInfoP4__SIPKcP11__SIUserCtxxP6db_objiPP8db_fieldP13CatInfoGottenU13block_pointerFPv15SI_OBJECT_EVENT15si_event_data_tmSC_ESC__block_invoke;
      v54[3] = &__block_descriptor_tmp_171;
      v55 = v25;
      v54[4] = v15;
      v54[5] = v56;
      v54[6] = Mutable;
      _enumerate_dbo(v26, (uint64_t)v56, 1, (uint64_t)v54);
      v27 = CFDateCreate(0, (double)*((unint64_t *)v56 + 2) / 1000000.0 - *MEMORY[0x1E0C9ADF8]);
      CFDictionaryAddValue(Mutable, CFSTR("kMDItemAttributeChangeDate"), v27);
      CFRelease(v27);
      valuePtr = *(_QWORD *)v56;
      v28 = CFNumberCreate(0, kCFNumberSInt64Type, &valuePtr);
      CFDictionaryAddValue(Mutable, CFSTR("oid"), v28);
      CFRelease(v28);
      valuePtr = *((_QWORD *)v56 + 3);
      v29 = CFNumberCreate(0, kCFNumberSInt64Type, &valuePtr);
      CFDictionaryAddValue(Mutable, CFSTR("parent_oid"), v29);
      CFRelease(v29);
      valuePtr = *((_QWORD *)v56 + 4);
      v30 = CFNumberCreate(0, kCFNumberSInt64Type, &valuePtr);
      CFDictionaryAddValue(Mutable, CFSTR("index_id"), v30);
      CFRelease(v30);
      v52 = 0;
      v31 = si_indexForDocId((uint64_t)v15, valuePtr);
      if (v31)
      {
        LODWORD(v57[0]) = 0;
        v50 = 0;
        v51 = 0.0;
        v32 = !v17 || (*(_BYTE *)(v17 + 8) & 4) == 0;
        if (_CIGetDocIDInfo(v31, v19[4], &v52, v57, (unint64_t)&v51, (unint64_t)&v50, v32))
        {
          if (LODWORD(v57[0]))
          {
            v33 = CFDateCreate(0, (double)LODWORD(v57[0]));
            CFDictionaryAddValue(Mutable, CFSTR("index_ranking_date"), v33);
            CFRelease(v33);
          }
          if (v51 != 0.0)
          {
            v34 = CFNumberCreate(0, kCFNumberFloatType, &v51);
            CFDictionaryAddValue(Mutable, CFSTR("index_ranking_score"), v34);
            CFRelease(v34);
          }
          if (v50)
          {
            valuePtr = v50;
            v35 = CFNumberCreate(0, kCFNumberSInt64Type, &valuePtr);
            CFDictionaryAddValue(Mutable, CFSTR("index_ranking_container"), v35);
            CFRelease(v35);
          }
        }
      }
      v36 = CFNumberCreate(0, kCFNumberSInt8Type, &v52);
      CFDictionaryAddValue(Mutable, CFSTR("index_group"), v36);
      CFRelease(v36);
      v37 = CFNumberCreate(0, kCFNumberSInt32Type, (char *)v56 + 40);
      CFDictionaryAddValue(Mutable, CFSTR("flags"), v37);
      CFRelease(v37);
      v38 = v15[828];
      if (v38)
      {
        v39 = *((_QWORD *)v56 + 3);
        if (v39)
        {
          bzero(v57, 0x1000uLL);
          Path = directoryStoreGetPath(v38, v39, (uint64_t)v57);
          if (Path)
          {
            v41 = Path;
            v42 = CFStringCreateMutable(0, 0);
            if (v41 >= 1)
            {
              v43 = v41 + 1;
              do
                CFStringAppendFormat(v42, 0, CFSTR("/%lld"), v57[(v43-- - 2)]);
              while (v43 > 1);
            }
            CFStringAppendFormat(v42, 0, CFSTR("/%lld"), *((_QWORD *)v56 + 3));
            CFStringAppendFormat(v42, 0, CFSTR("/%lld"), *(_QWORD *)v56);
            CFDictionaryAddValue(Mutable, CFSTR("oid_path"), v42);
            CFRelease(v42);
          }
        }
      }
      v44 = v15[177];
      if (v44)
      {
        bzero(v57, 0x400uLL);
        if (!*(_BYTE *)(v44 + 240))
        {
          v47 = (const char *)(*(uint64_t (**)(uint64_t, unint64_t, _QWORD *, _QWORD, _QWORD, _QWORD, _QWORD, uint64_t))(v44 + 40))(v44, v20, v57, 0, 0, 0, 0, -1);
          if (v47)
          {
            v48 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v47, 0x8000100u);
            if (v48)
            {
              v49 = v48;
              CFDictionaryAddValue(Mutable, CFSTR("_kMDItemPSIDPath"), v48);
              CFRelease(v49);
            }
          }
        }
      }
      if (*(_QWORD *)v56 == 2)
      {
        v45 = SICopyProperties((uint64_t)v15);
        if (v45)
        {
          v46 = v45;
          CFDictionaryAddValue(Mutable, CFSTR("store_properties"), v45);
          CFRelease(v46);
        }
      }
      (*(void (**)(uint64_t, uint64_t, __CFDictionary *, _QWORD, _QWORD, uint64_t))(a9 + 16))(a9, 34, Mutable, 0, v18, a10);
      CFRelease(Mutable);
      if (v56 != v19)
        free(v56);
      return 1;
    }
  }
  return result;
}

uint64_t si_getOnBootVolumeField(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  _QWORD *v10;

  if ((*(_DWORD *)(a1 + 6584) & 1) != 0)
    v10 = (_QWORD *)MEMORY[0x1E0C9AE50];
  else
    v10 = (_QWORD *)MEMORY[0x1E0C9AE40];
  (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, uint64_t))(a9 + 16))(a9, 34, *v10, 0, a6, a10);
  return 1;
}

uint64_t si_fsContentTypeAttr(int a1, int a2, int a3, int a4, int a5, int a6, int a7, CatInfoGotten *this)
{
  if (this)
    CatInfoGotten::fastPath(this);
  return 0;
}

uint64_t si_fsContentTypeMatch(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _QWORD *a6, uint64_t a7)
{
  _BYTE *v9;

  if (!convert_value_to_type(0xBu, a7))
  {
    if (*(_DWORD *)(a7 + 24) == 5 && (v9 = *(_BYTE **)(a7 + 72), *v9 == 42))
    {
      if (!a6 || !v9[1])
        return 0;
    }
    else if (!a6)
    {
      return 0;
    }
    CatInfoGotten::fastPath(a6);
  }
  return 0;
}

uint64_t si_fsContentTypeTreeAttr()
{
  return 0;
}

uint64_t si_fsContentTypeTreeMatch()
{
  return 0;
}

uint64_t si_getAppEngagementValues(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  return si_getRenderOrEngagementValues(*(int **)(a1 + 1184), a4, a5, a6, a9, a10, "_kMDItemAppEngagementData");
}

char **si_getAppEngagementValuesRequired()
{
  return &si_getAppEngagementValuesRequired(__SI *)::nameArray;
}

uint64_t si_getTMLifeBegin()
{
  return 0;
}

uint64_t si_getTMLifeEnd()
{
  return 0;
}

uint64_t si_getUserFSBundleID(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t result;

  if (!*(_QWORD *)(a1 + 1184) || *(_BYTE *)(a1 + 2072))
    return 0;
  result = 0;
  if (a4)
  {
    if (*(_QWORD *)(a1 + 1416))
    {
      (*(void (**)(uint64_t, uint64_t, const char *, _QWORD, _QWORD, uint64_t))(a9 + 16))(a9, 28, "com.apple.filesystems.UserFS.FileProvider", 0, a6, a10);
      return 1;
    }
  }
  return result;
}

uint64_t si_getRenderOrEngagementValues(int *a1, uint64_t a2, _DWORD *a3, int a4, uint64_t a5, uint64_t a6, char *__s)
{
  _DWORD *Dbo;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  unsigned __int8 *v27;
  unsigned __int8 *v28;
  int v29;
  int v30;
  unint64_t v31;
  int v32;
  uint64_t v33;
  uint64_t i;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  int v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0;
  Dbo = a3;
  if (!a3)
  {
    Dbo = iterateToGetDbo(a1, a2);
    if (!Dbo)
      return 0;
  }
  v36 = 0;
  v37 = 0;
  if (db_get_field_locked(a1, (uint64_t)Dbo, __s, &v37, &v36))
    goto LABEL_41;
  if (*(_WORD *)v37 != 14)
    goto LABEL_41;
  v14 = *(_DWORD *)(v37 + 8);
  if (v14 < 2)
    goto LABEL_41;
  v15 = v36;
  if (*(_BYTE *)v36 != 9)
    goto LABEL_41;
  v16 = 0;
  v17 = v14 - 1;
  v39 = 0;
  v38 = 0;
  if (v17 < 9)
    goto LABEL_42;
  v18 = llround(((double)(86400 * ((unint64_t)CFAbsoluteTimeGetCurrent() / 0x15180)) - *(double *)(v36 + 1)) / 86400.0);
  if (v18 > 0x16D || (_DWORD)v17 == 9)
    goto LABEL_41;
  v20 = 0;
  v21 = 0;
  v22 = 0;
  v23 = 0;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  v27 = (unsigned __int8 *)(v15 + 9);
  v28 = (unsigned __int8 *)(v15 + 11);
  do
  {
    v29 = *v27;
    v26 += v29;
    if (v29 == 255 && !v27[3])
    {
      v26 += *v28;
      v30 = 1;
    }
    else
    {
      v30 = 0;
    }
    v31 = v18 - (__int16)v26;
    v32 = v27[1];
    if (v18 == (__int16)v26)
    {
      v25 += v32;
      LOWORD(v38) = v25;
LABEL_20:
      v24 += v32;
      WORD1(v38) = v24;
LABEL_21:
      v23 += v32;
      WORD2(v38) = v23;
LABEL_22:
      v22 += v32;
      HIWORD(v38) = v22;
LABEL_23:
      v21 += v32;
      LOWORD(v39) = v21;
LABEL_24:
      v20 += v32;
      HIWORD(v39) = v20;
      goto LABEL_25;
    }
    if ((uint64_t)v31 <= 6)
      goto LABEL_20;
    if (v31 <= 0x1D)
      goto LABEL_21;
    if (v31 <= 0x59)
      goto LABEL_22;
    if (v31 <= 0xB5)
      goto LABEL_23;
    if (v31 <= 0x16C)
      goto LABEL_24;
LABEL_25:
    v27 += 4;
    if (!v30)
      v27 = v28;
    if ((v31 & 0x8000000000000000) != 0)
      break;
    v28 = v27 + 2;
  }
  while ((unint64_t)(v27 + 2) <= v15 + 1 + v17);
  if (v32)
  {
    v33 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, uint64_t))(a5 + 16))(a5, 6, 0, 0, a4, a6);
    for (i = 0; i != 6; ++i)
      (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, uint64_t))(a5 + 16))(a5, 17, *((unsigned __int16 *)&v38 + i), 0, i, v33);
    (*(void (**)(uint64_t, uint64_t, uint64_t, _QWORD, _QWORD, uint64_t))(a5 + 16))(a5, 7, v33, 0, a4, a6);
    v16 = 1;
    goto LABEL_42;
  }
LABEL_41:
  v16 = 0;
LABEL_42:
  if (Dbo != a3)
    free(Dbo);
  return v16;
}

_DWORD *iterateToGetDbo(int *a1, uint64_t a2)
{
  unint64_t *v2;
  double v3;
  double v4;
  __n128 v5;
  unsigned int *v6;
  unsigned int *v7;
  _DWORD *v8;
  _DWORD *v9;
  unint64_t v11;
  uint64_t v12;

  v12 = a2;
  v2 = db_obj_iter_create_with_filter(a1, 1uLL, (uint64_t)&v12, 0, 0, 16, 0, 0, 0);
  v6 = db_obj_iter_next((uint64_t)v2, &v11, 1, v3, v4, v5);
  if (v6)
  {
    v7 = v6;
    v8 = malloc_type_malloc(v6[3], 0x1142DA9BuLL);
    v9 = v8;
    if (v8)
    {
      memcpy(v8, v7, v7[3]);
      v9[2] = v7[3];
    }
  }
  else
  {
    v9 = 0;
  }
  db_obj_iter_release((uint64_t)v2);
  return v9;
}

void ___ZL13si_getSDBInfoP4__SIPKcP11__SIUserCtxxP6db_objiPP8db_fieldP13CatInfoGottenU13block_pointerFPv15SI_OBJECT_EVENT15si_event_data_tmSC_ESC__block_invoke(uint64_t a1, char *a2, uint64_t a3)
{
  CFStringRef v6;
  CFStringRef v7;
  CFDictionaryRef v8;
  CFDictionaryRef v9;

  if (isEntitledForAttribute(*(_DWORD *)(a1 + 56), a2))
  {
    v6 = CFStringCreateWithCString(0, a2, 0x8000100u);
    if (v6)
    {
      v7 = v6;
      v8 = _decodeSDBField(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 1184), (unsigned __int16 *)a3, (unsigned __int8 *)(a3 + 13), 0, 0, 0, 1, (CFAllocatorRef)*MEMORY[0x1E0C9AE00]);
      if (v8)
      {
        v9 = v8;
        CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 48), v7, v8);
        CFRelease(v9);
      }
      CFRelease(v7);
    }
  }
}

uint64_t ___ZL33si_getItemRecipientEmailAddressesP4__SIPKcP11__SIUserCtxxP6db_objiPP8db_fieldP13CatInfoGottenU13block_pointerFPv15SI_OBJECT_EVENT15si_event_data_tmSC_ESC__block_invoke(uint64_t a1, const __CFArray *a2)
{
  CFTypeID TypeID;
  CFIndex i;
  uint64_t result;
  uint64_t v7;
  const void *ValueAtIndex;
  CFTypeID v9;
  uint64_t v10;

  TypeID = CFArrayGetTypeID();
  if (TypeID == CFGetTypeID(a2))
  {
    for (i = 0; ; ++i)
    {
      result = CFArrayGetCount(a2);
      if (result <= i)
        break;
      v7 = *(_QWORD *)(a1 + 32);
      ValueAtIndex = CFArrayGetValueAtIndex(a2, i);
      ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
      (*(void (**)(uint64_t, uint64_t, const void *, _QWORD))(v7 + 16))(v7, 34, ValueAtIndex, 0);
    }
  }
  else
  {
    v9 = CFStringGetTypeID();
    result = CFGetTypeID(a2);
    if (v9 == result)
    {
      v10 = *(_QWORD *)(a1 + 32);
      ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
      return (*(uint64_t (**)(void))(v10 + 16))();
    }
  }
  return result;
}

BOOL constStrDictionaryEqualCallBack(const char *a1, const char *a2)
{
  return strcmp(a1, a2) == 0;
}

uint64_t constStrDictionaryHashCallBack(const char *a1)
{
  int v2;
  int v3;
  int v4;
  const char *v5;
  int v6;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  unint64_t v11;
  int v12;
  int v14;
  int v15;
  unint64_t v16;
  int v17;
  unsigned int v18;

  v2 = -1759636613;
  v3 = strlen(a1);
  if (v3 >= 0)
    v4 = v3;
  else
    v4 = v3 + 3;
  v5 = &a1[v4 & 0xFFFFFFFC];
  if ((v3 + 3) >= 7)
  {
    v8 = -(v4 >> 2);
    v9 = -1789642873;
    v10 = 718793509;
    do
    {
      v9 = 5 * v9 + 2071795100;
      v10 = 5 * v10 + 1808688022;
      HIDWORD(v11) = v9 * *(_DWORD *)&v5[4 * v8];
      LODWORD(v11) = HIDWORD(v11);
      v12 = (v11 >> 21) * v10;
      HIDWORD(v11) = v2;
      LODWORD(v11) = v2;
      v2 = v12 ^ (5 * (v11 >> 19) + 1390208809);
    }
    while (!__CFADD__(v8++, 1));
    v7 = 5 * v9 + 2071795100;
    v6 = 5 * v10 + 1808688022;
  }
  else
  {
    v6 = 1107688271;
    v7 = 1713515327;
  }
  v14 = 0;
  v15 = v3 & 3;
  switch(v15)
  {
    case 1:
      goto LABEL_15;
    case 2:
LABEL_14:
      v14 |= *((unsigned __int8 *)v5 + 1) << 8;
LABEL_15:
      HIDWORD(v16) = (v14 ^ *(unsigned __int8 *)v5) * v7;
      LODWORD(v16) = HIDWORD(v16);
      v17 = (v16 >> 21) * v6;
      HIDWORD(v16) = v2;
      LODWORD(v16) = v2;
      v2 = v17 ^ (5 * (v16 >> 19) + 1390208809);
      break;
    case 3:
      v14 = *((unsigned __int8 *)v5 + 2) << 16;
      goto LABEL_14;
  }
  v18 = -1028477387 * ((-2048144789 * (v2 ^ v3)) ^ ((-2048144789 * (v2 ^ v3)) >> 13));
  return v18 ^ HIWORD(v18);
}

CFStringRef constStrDictionaryCopyDescriptionCallBack(char *cStr)
{
  return CFStringCreateWithCString(0, cStr, 0x8000100u);
}

void ___ZL26si_dboTopMatchingAttributeP4__SIPKcP11__SIUserCtxxP6db_objiPP8db_fieldP13CatInfoGottenU13block_pointerFPv15SI_OBJECT_EVENT15si_event_data_tmSC_ESC__block_invoke(uint64_t a1)
{
  uint64_t v1;
  const __CFString *v2;
  const char *CStringPtr;
  CFNumberRef v4;
  _OWORD v5[16];
  uint64_t v6;

  v6 = *MEMORY[0x1E0C80C00];
  v1 = 0;
  si_dboTopMatchingAttribute(__SI *,char const*,__SIUserCtx *,long long,db_obj *,int,db_field **,CatInfoGotten *,void *({block_pointer})(SI_OBJECT_EVENT,si_event_data_t,unsigned long,void *),void *)::__attribute_importance_dictionary = (uint64_t)CFDictionaryCreateMutable(0, 41, (const CFDictionaryKeyCallBacks *)(a1 + 32), MEMORY[0x1E0C9B3A0]);
  do
  {
    v2 = *(__CFString **)((char *)&get_attribute_importance_table(int *)::__attribute_importance_table + v1);
    CStringPtr = CFStringGetCStringPtr(v2, 0);
    memset(v5, 0, sizeof(v5));
    if (CStringPtr || (CStringPtr = (const char *)v5, CFStringGetCString(v2, (char *)v5, 256, 0x8000100u)))
    {
      if (*CStringPtr)
      {
        v4 = CFNumberCreate(0, kCFNumberFloatType, (char *)&get_attribute_importance_table(int *)::__attribute_importance_table + v1 + 8);
        CFDictionarySetValue((CFMutableDictionaryRef)si_dboTopMatchingAttribute(__SI *,char const*,__SIUserCtx *,long long,db_obj *,int,db_field **,CatInfoGotten *,void *({block_pointer})(SI_OBJECT_EVENT,si_event_data_t,unsigned long,void *),void *)::__attribute_importance_dictionary, CStringPtr, v4);
        CFRelease(v4);
      }
    }
    v1 += 16;
  }
  while (v1 != 656);
}

uint64_t addFieldName(uint64_t a1, uint64_t a2, int *a3, int a4)
{
  uint64_t v8;
  uint64_t result;
  uint64_t field_name_for_id_locked;
  const char *v11;

  v8 = a4 | 0x40000000u;
  result = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, _QWORD, uint64_t))(a1 + 16))(a1, 30, 0, v8, 0, a2);
  if (!result)
  {
    field_name_for_id_locked = db_get_field_name_for_id_locked(a3, a4);
    if (field_name_for_id_locked)
      v11 = (const char *)field_name_for_id_locked;
    else
      v11 = "";
    return (*(uint64_t (**)(uint64_t, uint64_t, const char *, uint64_t, _QWORD, uint64_t))(a1 + 16))(a1, 31, v11, v8, 0, a2);
  }
  return result;
}

void _log_fault_for_malloc_failure()
{
  uint8_t v0[16];

  if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)v0 = 0;
    _os_log_fault_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "allocation function returned null", v0, 2u);
  }
}

void *zone_reallocate(void *ptr, size_t size, int a3, malloc_zone_t *zone)
{
  return malloc_type_zone_realloc(zone, ptr, size, 0x3455C427uLL);
}

CFAllocatorRef __query_zone_init_block_invoke()
{
  CFAllocatorRef result;
  CFAllocatorContext context;

  queryZone = (uint64_t)malloc_create_zone(0x10000uLL, 0);
  malloc_set_zone_name((malloc_zone_t *)queryZone, "SIQueryMallocZone");
  context.version = 0;
  context.info = (void *)queryZone;
  memset(&context.retain, 0, 24);
  context.allocate = (CFAllocatorAllocateCallBack)zone_allocate;
  context.reallocate = (CFAllocatorReallocateCallBack)zone_reallocate;
  context.deallocate = (CFAllocatorDeallocateCallBack)zone_deallocate;
  context.preferredSize = (CFAllocatorPreferredSizeCallBack)zone_preferredSize;
  result = CFAllocatorCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], &context);
  kCIQueryZoneAllocator = (uint64_t)result;
  return result;
}

float automaton_state_score(uint64_t a1, int a2)
{
  unint64_t v2;
  float result;
  int v4;
  double v5;
  float v6;
  uint64_t v7;

  if (!a1)
    return INFINITY;
  v2 = a1 & -a1;
  if (!v2)
    return INFINITY;
  result = INFINITY;
  do
  {
    v4 = __clz(__rbit64(v2));
    if (a2 + ((103 * v4) >> 9))
    {
      v5 = (double)(v4 - 5 * ((103 * v4) >> 9))
         / (double)(a2 + ((103 * v4) >> 9));
      if (v5 < result)
      {
        v6 = v5;
        result = v6;
      }
    }
    v7 = (-2 * v2) & a1;
    if (!v7)
      break;
    v2 = v7 & -v7;
  }
  while (v2);
  return result;
}

_QWORD *la_init(uint64_t a1, char a2)
{
  _QWORD *v3;
  _BYTE *v4;
  uint64_t v5;
  char *v6;
  unint64_t v7;
  char *v8;
  uint8x8_t v9;
  _BOOL8 v10;
  char *v11;
  char *v12;
  unint64_t v13;
  char *v14;
  unint64_t **v15;
  unint64_t v16;
  unint64_t v17;
  uint8x8_t v18;
  unint64_t v19;
  void **v20;
  void **v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  unsigned int v26;
  int i;
  uint64_t v28;
  int v29;
  uint64_t v30;
  int v31;
  unsigned int v32;
  unsigned __int8 j;
  char v34;
  char v35;
  unsigned int v36;
  unsigned int v37;
  char v38;
  int v39;
  unsigned int v40;
  char v41;
  char v42;
  uint64_t v43;
  char v44;
  uint64_t v45;
  uint64_t v46;
  unsigned __int8 v47;
  unsigned __int8 v48;
  BOOL v49;
  uint64_t v50;
  uint64_t v51;
  unsigned __int8 v52;
  BOOL v53;
  char v54;
  uint64_t v55;
  uint64_t v56;
  BOOL v57;
  char v58;
  unint64_t v59;
  uint64_t v60;
  unint64_t v61;
  unint64_t v62;
  uint64_t v63;
  unint64_t v64;
  unint64_t v65;
  uint64_t v66;
  unint64_t v67;
  unint64_t v68;
  uint8x8_t v69;
  uint64_t v70;
  uint64_t ***v71;
  uint64_t **k;
  unint64_t v73;
  unsigned int v74;
  char *v76;
  float v77;
  float v78;
  _BOOL8 v79;
  unint64_t v80;
  unint64_t v81;
  size_t v82;
  uint64_t v83;
  _QWORD *v84;
  unint64_t v85;
  _QWORD *v86;
  _QWORD *v87;
  int v88;
  int item_count;
  int v90;
  unsigned int info;
  uint64_t v92;
  uint64_t v93;
  void *v94;
  uint64_t v95;
  uint64_t v96;
  char v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  unsigned int v101;
  _QWORD *v102;
  uint64_t v103;
  _BYTE *node;
  uint64_t v105;
  uint64_t v106;
  int v107;
  _BYTE *v108;
  uint64_t v109;
  _BYTE *v110;
  unsigned __int8 v111;
  _BYTE *v112;
  unsigned __int8 v113;
  _QWORD *v114;
  uint64_t v115;
  size_t v116;
  unint64_t v117;
  uint64_t v118;
  unint64_t v119;
  uint64_t v120;
  unint64_t v121;
  uint8x8_t v122;
  unint64_t v123;
  uint64_t ***v124;
  uint64_t **m;
  unint64_t v126;
  _QWORD *v127;
  float v128;
  float v129;
  _BOOL8 v130;
  unint64_t v131;
  unint64_t v132;
  size_t v133;
  uint64_t v134;
  _QWORD *v135;
  unint64_t v136;
  unint64_t v137;
  uint8x8_t v138;
  unint64_t v139;
  void **v140;
  _QWORD *v141;
  unint64_t v142;
  float v143;
  float v144;
  _BOOL8 v145;
  unint64_t v146;
  unint64_t v147;
  size_t v148;
  uint64_t v149;
  _QWORD *v150;
  unint64_t v151;
  unsigned __int8 v154;
  _QWORD *v155;
  unsigned int v156;
  _BYTE *v157;
  int v158;
  int v159;
  char *__s1[2];
  void *__p[2];
  uint64_t v162;
  _OWORD v163[2];
  uint64_t v164;
  unint64_t v165;

  v3 = malloc_type_malloc(0x48uLL, 0x10300400E37CE8CuLL);
  v3[7] = a1;
  v4 = malloc_type_malloc(0x10uLL, 0x10200405F07FB98uLL);
  v4[8] = 1;
  v5 = operator new();
  *(_OWORD *)v5 = 0u;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_DWORD *)(v5 + 32) = 1065353216;
  std::__hash_table<std::__hash_value_type<std::string,int>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,int>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,int>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,int>>>::__rehash<true>(v5, 0x4BuLL);
  *(_QWORD *)v4 = v5;
  memset(v163, 0, sizeof(v163));
  v164 = 1065353216;
  *(_OWORD *)__s1 = 0u;
  *(_OWORD *)__p = 0u;
  v162 = 1065353216;
  v6 = (char *)operator new(0x18uLL);
  *(_QWORD *)v6 = 0;
  *(int64x2_t *)(v6 + 8) = vdupq_n_s64(1uLL);
  std::__hash_table<std::__hash_value_type<std::string,int>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,int>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,int>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,int>>>::__rehash<true>((uint64_t)__s1, 1uLL);
  v8 = __s1[0];
  v7 = (unint64_t)__s1[1];
  v9 = (uint8x8_t)vcnt_s8((int8x8_t)__s1[1]);
  v9.i16[0] = vaddlv_u8(v9);
  v10 = 1;
  v11 = __s1[1] - 1;
  if (__s1[1] <= (char *)1)
    v10 = __s1[1] != (char *)1;
  if (v9.u32[0] <= 1uLL)
    v10 = ((uint64_t)__s1[1] & 1) == 0;
  v12 = *(char **)&__s1[0][8 * v10];
  if (v12)
  {
    *(_QWORD *)v6 = *(_QWORD *)v12;
  }
  else
  {
    *(void **)v6 = __p[0];
    __p[0] = v6;
    *(_QWORD *)&v8[8 * v10] = __p;
    if (!*(_QWORD *)v6)
      goto LABEL_14;
    v13 = *(_QWORD *)(*(_QWORD *)v6 + 8);
    if (v9.u32[0] > 1uLL)
    {
      if (v13 >= v7)
        v13 %= v7;
    }
    else
    {
      v13 &= (unint64_t)v11;
    }
    v12 = &__s1[0][8 * v13];
  }
  *(_QWORD *)v12 = v6;
LABEL_14:
  v49 = __CFADD__(__p[1], 1);
  v14 = (char *)++__p[1];
  v155 = v3;
  if (!v49)
  {
    v157 = v4;
    while (1)
    {
      v15 = (unint64_t **)__p[0];
      if (!__p[0])
        __assert_rtn("compute_transitions", "transition_table.mm", 129, "it != unprocessed.end()");
      v16 = (unint64_t)__s1[1];
      v17 = *((_QWORD *)__p[0] + 1);
      v18 = (uint8x8_t)vcnt_s8((int8x8_t)__s1[1]);
      v18.i16[0] = vaddlv_u8(v18);
      if (v18.u32[0] > 1uLL)
      {
        if ((char *)v17 >= __s1[1])
          v17 %= (unint64_t)__s1[1];
      }
      else
      {
        v17 &= (unint64_t)(__s1[1] - 1);
      }
      v19 = *((_QWORD *)__p[0] + 2);
      v20 = *(void ***)&__s1[0][8 * v17];
      do
      {
        v21 = v20;
        v20 = (void **)*v20;
      }
      while (v20 != __p[0]);
      if (v21 == __p)
        goto LABEL_34;
      v22 = (unint64_t)v21[1];
      if (v18.u32[0] > 1uLL)
      {
        if ((char *)v22 >= __s1[1])
          v22 %= (unint64_t)__s1[1];
      }
      else
      {
        v22 &= (unint64_t)(__s1[1] - 1);
      }
      if (v22 != v17)
      {
LABEL_34:
        if (!*(_QWORD *)__p[0])
          goto LABEL_35;
        v23 = *(_QWORD *)(*(_QWORD *)__p[0] + 8);
        if (v18.u32[0] > 1uLL)
        {
          if ((char *)v23 >= __s1[1])
            v23 %= (unint64_t)__s1[1];
        }
        else
        {
          v23 &= (unint64_t)(__s1[1] - 1);
        }
        if (v23 != v17)
LABEL_35:
          *(_QWORD *)&__s1[0][8 * v17] = 0;
      }
      v24 = *v15;
      if (*v15)
      {
        v25 = v24[1];
        if (v18.u32[0] > 1uLL)
        {
          if (v25 >= v16)
            v25 %= v16;
        }
        else
        {
          v25 &= v16 - 1;
        }
        if (v25 != v17)
        {
          *(_QWORD *)&__s1[0][8 * v25] = v21;
          v24 = *v15;
        }
      }
      *v21 = v24;
      __p[1] = v14 - 1;
      operator delete(v15);
      std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>((uint64_t)v163, v19, v19);
      if (!v19)
        __assert_rtn("state_find_max_i", "generic_state.c", 149, "s != 0");
      v26 = (103 * (__clz(v19) ^ 0x3F)) >> 9;
      v154 = (2 * v4[8]) | 1;
      if (v26 <= v154)
        break;
LABEL_153:
      v14 = (char *)__p[1];
      v3 = v155;
      if (!__p[1])
        goto LABEL_154;
    }
    v158 = __clz(__rbit64(v19));
LABEL_46:
    v156 = v26;
    for (i = v26 << 8; ; i = v88 | ((_DWORD)v28 << 8))
    {
      v28 = BYTE1(i);
      if (BYTE1(i) == 128)
      {
        v26 = v156 + 1;
        if ((v156 + 1) > v154)
          goto LABEL_153;
        goto LABEL_46;
      }
      v29 = i;
      v30 = 0;
      v31 = v4[8];
      v159 = v29;
      v32 = v29;
      for (j = v158; ; j = __clz(__rbit64(v59)))
      {
        v34 = j / 5u;
        v35 = j % 5u;
        v36 = (v28 - j / 5u);
        v37 = v32 >> (j / 5u);
        if (v36 >= 2)
        {
          v38 = __clz(__rbit32(v37));
          if (v37)
            LOBYTE(v39) = v38;
          else
            v39 = (v28 - v34);
          if ((_BYTE)v39)
          {
            v40 = (v28 - v34);
            v41 = v35 + 1;
            v42 = 5 * v34;
            if (j < 0x32u && (v35 + 1) < 5u)
              v43 = 1 << (5 * v34 + v41);
            else
              v43 = 0;
            v44 = v34 + 1;
            v45 = 1 << (v42 + 5 + v41);
            if (j >= 0x2Du || (v35 + 1) >= 5u)
              v45 = 0;
            v46 = v45 | v43;
            v47 = v44 + v39;
            v48 = v39 + v35;
            v49 = v48 >= 5u || v47 >= 0xAu;
            v50 = 1 << (5 * v47 + v48);
            if (v49)
              v50 = 0;
            v51 = v46 | v50;
            if (v40 <= v39)
              v51 = v46;
            goto LABEL_87;
          }
LABEL_76:
          v57 = j % 5u >= 5 || j >= 0x2Du;
          v58 = 5 * v34 + 5;
LABEL_84:
          v51 = 1 << (v58 + v35);
          if (v57)
            v51 = 0;
          goto LABEL_87;
        }
        if (v36 != 1)
        {
          v57 = ++v35 >= 5u || j >= 0x32u;
          v58 = 5 * v34;
          goto LABEL_84;
        }
        if ((v37 & 1) != 0)
          goto LABEL_76;
        v52 = v35 + 1;
        v53 = v52 < 5u;
        v54 = 5 * v34;
        if (j < 0x32u && v53)
          v55 = 1 << (v54 + v52);
        else
          v55 = 0;
        v56 = 1 << (v54 + 5 + v52);
        if (j >= 0x2Du || !v53)
          v56 = 0;
        v51 = v56 | v55;
LABEL_87:
        v30 |= v51;
        v59 = (-2 << j) & v19;
        if (!v59)
          break;
      }
      v60 = 0x210842108421 << (v31 + 1);
      LOBYTE(v61) = v31 + 2;
      if ((v31 + 2) <= 4u)
      {
        v62 = (v28 + v31);
        v63 = (v31 + 2);
        if (v62 <= v61)
          v61 = v61;
        else
          v61 = v62;
        do
        {
          if (v61 == v63)
            break;
          v60 |= 0x210842108421 << v63++;
        }
        while (v63 != 5);
      }
      v165 = v30 & ~v60;
      state_reduce(&v165);
      v64 = v165;
      v65 = v165 >> (5 * ((103 * __clz(__rbit64(v64 & -(uint64_t)v64))) >> 9));
      v66 = *(_QWORD *)v4;
      v67 = v28 + 196613 * v32 + 6291469 * v19;
      v68 = *(_QWORD *)(v66 + 8);
      if (v68)
      {
        v69 = (uint8x8_t)vcnt_s8((int8x8_t)v68);
        v69.i16[0] = vaddlv_u8(v69);
        if (v69.u32[0] > 1uLL)
        {
          v70 = v28 + 196613 * v32 + 6291469 * v19;
          if (v67 >= v68)
            v70 = v67 % v68;
        }
        else
        {
          v70 = v67 & (v68 - 1);
        }
        v71 = *(uint64_t ****)(*(_QWORD *)v66 + 8 * v70);
        if (v71)
        {
          for (k = *v71; k; k = (uint64_t **)*k)
          {
            v73 = (unint64_t)k[1];
            if (v73 == v67)
            {
              v74 = *((unsigned __int16 *)k + 12);
              if ((_DWORD)v28 == v74 >> 8
                && ((v159 ^ v74) & ~(-1 << v28)) == 0
                && k[2] == (uint64_t *)v19)
              {
                goto LABEL_139;
              }
            }
            else
            {
              if (v69.u32[0] > 1uLL)
              {
                if (v73 >= v68)
                  v73 %= v68;
              }
              else
              {
                v73 &= v68 - 1;
              }
              if (v73 != v70)
                break;
            }
          }
        }
      }
      else
      {
        v70 = 0;
      }
      v76 = (char *)operator new(0x30uLL);
      *(_QWORD *)v76 = 0;
      *((_QWORD *)v76 + 1) = v67;
      *((_QWORD *)v76 + 2) = v19;
      *((_WORD *)v76 + 12) = v159;
      *((_WORD *)v76 + 15) = 0;
      *(_DWORD *)(v76 + 26) = 0;
      *((_QWORD *)v76 + 4) = v65;
      *((_QWORD *)v76 + 5) = (((103 * __clz(__rbit64(v64))) >> 9)
                                             - ((103 * v158) >> 9));
      v77 = (float)(unint64_t)(*(_QWORD *)(v66 + 24) + 1);
      v78 = *(float *)(v66 + 32);
      if (!v68 || (float)(v78 * (float)v68) < v77)
      {
        v79 = (v68 & (v68 - 1)) != 0;
        if (v68 < 3)
          v79 = 1;
        v80 = v79 | (2 * v68);
        v81 = vcvtps_u32_f32(v77 / v78);
        if (v80 <= v81)
          v82 = v81;
        else
          v82 = v80;
        std::__hash_table<std::__hash_value_type<std::string,int>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,int>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,int>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,int>>>::__rehash<true>(v66, v82);
        v68 = *(_QWORD *)(v66 + 8);
        if ((v68 & (v68 - 1)) != 0)
        {
          if (v67 >= v68)
            v70 = v67 % v68;
          else
            v70 = v67;
        }
        else
        {
          v70 = (v68 - 1) & v67;
        }
      }
      v83 = *(_QWORD *)v66;
      v84 = *(_QWORD **)(*(_QWORD *)v66 + 8 * v70);
      if (v84)
      {
        *(_QWORD *)v76 = *v84;
        goto LABEL_137;
      }
      *(_QWORD *)v76 = *(_QWORD *)(v66 + 16);
      *(_QWORD *)(v66 + 16) = v76;
      *(_QWORD *)(v83 + 8 * v70) = v66 + 16;
      if (*(_QWORD *)v76)
      {
        v85 = *(_QWORD *)(*(_QWORD *)v76 + 8);
        if ((v68 & (v68 - 1)) != 0)
        {
          if (v85 >= v68)
            v85 %= v68;
        }
        else
        {
          v85 &= v68 - 1;
        }
        v84 = (_QWORD *)(*(_QWORD *)v66 + 8 * v85);
LABEL_137:
        *v84 = v76;
      }
      ++*(_QWORD *)(v66 + 24);
LABEL_139:
      v86 = std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>((uint64_t)__s1[0], (unint64_t)__s1[1], v65);
      v87 = std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::find<unsigned long long>(*(uint64_t *)&v163[0], *((unint64_t *)&v163[0] + 1), v65);
      if (v65 && !v87 && !v86)
        std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>((uint64_t)__s1, v65, v65);
      if (v159 + 1 == (1 << v28))
      {
        v88 = 128;
        LODWORD(v28) = 128;
        v4 = v157;
      }
      else
      {
        v4 = v157;
        if ((_BYTE)v159)
        {
          if ((((((unsigned __int16)v159 & -(unsigned __int16)v159) + (unsigned __int16)v159) | (((((v159 & -(unsigned __int16)v159) + v159) ^ v159) >> 2)
                                                                                                / (v159 & -(unsigned __int16)v159))) & (1 << v28)) != 0)
            LOBYTE(v88) = (4
                         * (((1 << v28) - 1) & (((v159 & -(unsigned __int16)v159) + v159) | (((((v159 & -(unsigned __int16)v159) + v159) ^ v159) >> 2)
                                                                                           / (v159 & -(unsigned __int16)v159))))) | 3;
          else
            LOBYTE(v88) = ((v159 & -(unsigned __int16)v159) + v159) | (((((v159 & -(unsigned __int16)v159) + v159) ^ v159) >> 2)
                                                                     / (v159 & -(unsigned __int16)v159));
          v88 = v88;
        }
        else
        {
          v88 = 1;
        }
      }
    }
  }
LABEL_154:
  std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::~__hash_table((uint64_t)__s1);
  std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::~__hash_table((uint64_t)v163);
  *v3 = v4;
  *((_BYTE *)v3 + 32) = 1;
  *((_BYTE *)v3 + 48) = a2;
  v3[7] = a1;
  item_count = icu_search_context_item_get_item_count();
  v90 = 0;
  v3[8] = malloc_type_malloc(item_count, 0x100004077774924uLL);
  *((_DWORD *)v3 + 4) = 0;
  while (v90 < (int)icu_search_context_item_get_item_count())
  {
    *(_QWORD *)&v163[0] = 0;
    __s1[0] = 0;
    LODWORD(v165) = 0;
    info = icu_search_context_item_get_info();
    if (info > 7)
      __assert_rtn("compute_non_combining_chars", "levenstein_automaton.mm", 110, "false");
    if (((1 << info) & 0xC7) == 0 && (*(_QWORD *)&v163[0] || __s1[0] || (int)v165 >= 1))
    {
      v92 = v3[8];
      v93 = *((unsigned int *)v3 + 4);
      *((_DWORD *)v3 + 4) = v93 + 1;
      *(_BYTE *)(v92 + v93) = v90;
    }
    ++v90;
  }
  v94 = malloc_type_malloc(*((unsigned int *)v3 + 4), 0x100004077774924uLL);
  v3[1] = v94;
  bzero(v94, *((unsigned int *)v3 + 4));
  LODWORD(v95) = *((_DWORD *)v3 + 4);
  if ((int)v95 >= 1)
  {
    v96 = 0;
    v97 = 97;
    v98 = 1;
    do
    {
      v99 = v155[1];
      if (*(_BYTE *)(v99 + v96))
      {
        ++v96;
      }
      else
      {
        *(_BYTE *)(v99 + v96) = v97;
        v95 = *((int *)v155 + 4);
        v100 = v98;
        if (v96 + 1 < v95)
        {
          do
          {
            *(_QWORD *)&v163[0] = 0;
            __s1[0] = 0;
            icu_search_context_item_get_info();
            v165 = 0;
            icu_search_context_item_get_info();
            ++v100;
            LODWORD(v95) = *((_DWORD *)v155 + 4);
          }
          while ((int)v95 > (int)v100);
        }
        ++v97;
        ++v96;
      }
      ++v98;
    }
    while (v96 < (int)v95);
  }
  v101 = 0;
  v102 = v155;
  v155[5] = malloc_type_malloc(24 * (v95 + 1), 0x10200405AF6BDC9uLL);
  v103 = (2 * *((unsigned __int8 *)v155 + 32)) | 1;
  do
  {
    node = _lt_trie_make_node();
    v105 = 0;
    v106 = v101;
    do
    {
      if (v105 + v106 >= (unint64_t)*((unsigned int *)v102 + 4))
        break;
      if (v105 == 255)
        __assert_rtn("lt_trie_make_with_icu_element_at_index", "transition_trie.c", 102, "user_data != _LTTrieNoUserData");
      *(_QWORD *)&v163[0] = 0;
      __s1[0] = 0;
      LODWORD(v165) = 0;
      v107 = icu_search_context_item_get_info();
      if ((v107 - 4) >= 2)
      {
        if (v107 != 3 || !__s1[0])
          __assert_rtn("lt_trie_make_with_icu_element_at_index", "transition_trie.c", 137, "false");
        v113 = strlen(__s1[0]);
        v108 = lt_trie_make_with_unicode((unsigned __int8 *)__s1[0], v113, v105);
      }
      else
      {
        v108 = _lt_trie_make_node();
        if ((int)v165 >= 1)
        {
          v109 = 0;
          do
          {
            v110 = lt_trie_make_with_unicode((unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)&v163[0] + 8 * v109) + 1), **(unsigned __int8 **)(*(_QWORD *)&v163[0] + 8 * v109), v105);
            v108 = lt_trie_union((uint64_t)v108, (uint64_t)v110);
            ++v109;
          }
          while (v109 < (int)v165);
        }
        if (__s1[0])
        {
          v111 = strlen(__s1[0]);
          v112 = lt_trie_make_with_unicode((unsigned __int8 *)__s1[0], v111, v105);
          v108 = lt_trie_union((uint64_t)v108, (uint64_t)v112);
        }
        v102 = v155;
      }
      node = lt_trie_union((uint64_t)node, (uint64_t)v108);
      ++v105;
    }
    while (v105 != v103);
    v114 = (_QWORD *)(v102[5] + 24 * v106);
    v114[1] = 0;
    v114[2] = 0;
    *v114 = node;
    v101 = v106 + 1;
  }
  while ((v106 + 1) <= *((_DWORD *)v102 + 4));
  v115 = operator new();
  v116 = *((unsigned int *)v102 + 4);
  *(_OWORD *)v115 = 0u;
  *(_OWORD *)(v115 + 16) = 0u;
  *(_DWORD *)(v115 + 32) = 1065353216;
  std::__hash_table<std::__hash_value_type<std::string,int>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,int>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,int>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,int>>>::__rehash<true>(v115, v116);
  v102[3] = v115;
  if (*((_DWORD *)v102 + 4))
  {
    v117 = 0;
    while (1)
    {
      v118 = v102[1];
      v119 = *(unsigned __int8 *)(v118 + v117);
      v120 = v102[3];
      if (std::__hash_table<std::__hash_value_type<unsigned char,unsigned int>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,unsigned int>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,unsigned int>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,unsigned int>>>::find<unsigned char>((_QWORD *)v120, *(_BYTE *)(v118 + v117)))
      {
        goto LABEL_229;
      }
      v121 = *(_QWORD *)(v120 + 8);
      if (v121)
      {
        v122 = (uint8x8_t)vcnt_s8((int8x8_t)v121);
        v122.i16[0] = vaddlv_u8(v122);
        if (v122.u32[0] > 1uLL)
        {
          v123 = v119;
          if (v121 <= v119)
            v123 = v119 % v121;
        }
        else
        {
          v123 = ((_DWORD)v121 - 1) & v119;
        }
        v124 = *(uint64_t ****)(*(_QWORD *)v120 + 8 * v123);
        if (v124)
        {
          for (m = *v124; m; m = (uint64_t **)*m)
          {
            v126 = (unint64_t)m[1];
            if (v126 == v119)
            {
              if (*((unsigned __int8 *)m + 16) == (_DWORD)v119)
                goto LABEL_229;
            }
            else
            {
              if (v122.u32[0] > 1uLL)
              {
                if (v126 >= v121)
                  v126 %= v121;
              }
              else
              {
                v126 &= v121 - 1;
              }
              if (v126 != v123)
                break;
            }
          }
        }
      }
      else
      {
        v123 = 0;
      }
      v127 = operator new(0x18uLL);
      *v127 = 0;
      v127[1] = v119;
      *((_BYTE *)v127 + 16) = v119;
      *((_DWORD *)v127 + 5) = 0;
      v128 = (float)(unint64_t)(*(_QWORD *)(v120 + 24) + 1);
      v129 = *(float *)(v120 + 32);
      if (!v121 || (float)(v129 * (float)v121) < v128)
      {
        v130 = (v121 & (v121 - 1)) != 0;
        if (v121 < 3)
          v130 = 1;
        v131 = v130 | (2 * v121);
        v132 = vcvtps_u32_f32(v128 / v129);
        if (v131 <= v132)
          v133 = v132;
        else
          v133 = v131;
        std::__hash_table<std::__hash_value_type<std::string,int>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,int>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,int>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,int>>>::__rehash<true>(v120, v133);
        v121 = *(_QWORD *)(v120 + 8);
        if ((v121 & (v121 - 1)) != 0)
        {
          if (v121 <= v119)
            v123 = v119 % v121;
          else
            v123 = v119;
        }
        else
        {
          v123 = ((_DWORD)v121 - 1) & v119;
        }
      }
      v134 = *(_QWORD *)v120;
      v135 = *(_QWORD **)(*(_QWORD *)v120 + 8 * v123);
      if (v135)
        break;
      *v127 = *(_QWORD *)(v120 + 16);
      *(_QWORD *)(v120 + 16) = v127;
      *(_QWORD *)(v134 + 8 * v123) = v120 + 16;
      if (*v127)
      {
        v136 = *(_QWORD *)(*v127 + 8);
        if ((v121 & (v121 - 1)) != 0)
        {
          if (v136 >= v121)
            v136 %= v121;
        }
        else
        {
          v136 &= v121 - 1;
        }
        v135 = (_QWORD *)(*(_QWORD *)v120 + 8 * v136);
        goto LABEL_227;
      }
LABEL_228:
      ++*(_QWORD *)(v120 + 24);
      v120 = v155[3];
LABEL_229:
      v137 = *(_QWORD *)(v120 + 8);
      if (v137)
      {
        v138 = (uint8x8_t)vcnt_s8((int8x8_t)v137);
        v138.i16[0] = vaddlv_u8(v138);
        if (v138.u32[0] > 1uLL)
        {
          v139 = v119;
          if (v137 <= v119)
            v139 = v119 % v137;
        }
        else
        {
          v139 = ((_DWORD)v137 - 1) & v119;
        }
        v140 = *(void ***)(*(_QWORD *)v120 + 8 * v139);
        if (v140)
        {
          v141 = *v140;
          if (*v140)
          {
            do
            {
              v142 = v141[1];
              if (v142 == v119)
              {
                if (*((unsigned __int8 *)v141 + 16) == (_DWORD)v119)
                  goto LABEL_268;
              }
              else
              {
                if (v138.u32[0] > 1uLL)
                {
                  if (v142 >= v137)
                    v142 %= v137;
                }
                else
                {
                  v142 &= v137 - 1;
                }
                if (v142 != v139)
                  break;
              }
              v141 = (_QWORD *)*v141;
            }
            while (v141);
          }
        }
      }
      else
      {
        v139 = 0;
      }
      v141 = operator new(0x18uLL);
      *v141 = 0;
      v141[1] = v119;
      *((_BYTE *)v141 + 16) = v119;
      *((_DWORD *)v141 + 5) = 0;
      v143 = (float)(unint64_t)(*(_QWORD *)(v120 + 24) + 1);
      v144 = *(float *)(v120 + 32);
      if (!v137 || (float)(v144 * (float)v137) < v143)
      {
        v145 = (v137 & (v137 - 1)) != 0;
        if (v137 < 3)
          v145 = 1;
        v146 = v145 | (2 * v137);
        v147 = vcvtps_u32_f32(v143 / v144);
        if (v146 <= v147)
          v148 = v147;
        else
          v148 = v146;
        std::__hash_table<std::__hash_value_type<std::string,int>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,int>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,int>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,int>>>::__rehash<true>(v120, v148);
        v137 = *(_QWORD *)(v120 + 8);
        if ((v137 & (v137 - 1)) != 0)
        {
          if (v137 <= v119)
            v139 = v119 % v137;
          else
            v139 = v119;
        }
        else
        {
          v139 = ((_DWORD)v137 - 1) & v119;
        }
      }
      v149 = *(_QWORD *)v120;
      v150 = *(_QWORD **)(*(_QWORD *)v120 + 8 * v139);
      if (v150)
      {
        *v141 = *v150;
      }
      else
      {
        *v141 = *(_QWORD *)(v120 + 16);
        *(_QWORD *)(v120 + 16) = v141;
        *(_QWORD *)(v149 + 8 * v139) = v120 + 16;
        if (!*v141)
          goto LABEL_267;
        v151 = *(_QWORD *)(*v141 + 8);
        if ((v137 & (v137 - 1)) != 0)
        {
          if (v151 >= v137)
            v151 %= v137;
        }
        else
        {
          v151 &= v137 - 1;
        }
        v150 = (_QWORD *)(*(_QWORD *)v120 + 8 * v151);
      }
      *v150 = v141;
LABEL_267:
      ++*(_QWORD *)(v120 + 24);
LABEL_268:
      *((_DWORD *)v141 + 5) |= 1 << v117++;
      v102 = v155;
      if (v117 >= *((unsigned int *)v155 + 4))
        return v102;
    }
    *v127 = *v135;
LABEL_227:
    *v135 = v127;
    goto LABEL_228;
  }
  return v102;
}

void sub_1B84698EC(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v3;

  v3 = std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::~__hash_table(v1);
  MEMORY[0x1BCCB06A4](v3, 0x10A0C408EF24B1CLL);
  _Unwind_Resume(a1);
}

uint64_t **std::__hash_table<std::__hash_value_type<unsigned char,unsigned int>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,unsigned int>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,unsigned int>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,unsigned int>>>::find<unsigned char>(_QWORD *a1, unsigned __int8 a2)
{
  unint64_t v2;
  uint8x8_t v3;
  unint64_t v4;
  uint64_t ***v5;
  uint64_t **result;
  unint64_t v7;

  v2 = a1[1];
  if (!v2)
    return 0;
  v3 = (uint8x8_t)vcnt_s8((int8x8_t)v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    v4 = a2;
    if (v2 <= a2)
      v4 = a2 % v2;
  }
  else
  {
    v4 = ((_DWORD)v2 - 1) & a2;
  }
  v5 = *(uint64_t ****)(*a1 + 8 * v4);
  if (!v5)
    return 0;
  for (result = *v5; result; result = (uint64_t **)*result)
  {
    v7 = (unint64_t)result[1];
    if (v7 == a2)
    {
      if (*((unsigned __int8 *)result + 16) == a2)
        return result;
    }
    else
    {
      if (v3.u32[0] > 1uLL)
      {
        if (v7 >= v2)
          v7 %= v2;
      }
      else
      {
        v7 &= v2 - 1;
      }
      if (v7 != v4)
        return 0;
    }
  }
  return result;
}

void la_free(void *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;

  v2 = *((_QWORD *)a1 + 3);
  if (v2)
  {
    v3 = std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::~__hash_table(v2);
    MEMORY[0x1BCCB06A4](v3, 0x10A0C408EF24B1CLL);
  }
  v4 = *(uint64_t **)a1;
  v5 = **(_QWORD **)a1;
  if (v5)
  {
    v6 = std::__hash_table<std::__hash_value_type<int,float>,std::__unordered_map_hasher<int,std::__hash_value_type<int,float>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,float>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,float>>>::~__hash_table(v5);
    MEMORY[0x1BCCB06A4](v6, 0x10A0C408EF24B1CLL);
  }
  free(v4);
  v7 = 0;
  do
    lt_trie_free(*(_QWORD *)(*((_QWORD *)a1 + 5) + 24 * v7++));
  while (v7 <= *((_DWORD *)a1 + 4));
  free(*((void **)a1 + 1));
  free(*((void **)a1 + 5));
  free(*((void **)a1 + 8));
  free(a1);
}

uint64_t la_new_state_from_state_with_char_at_index(uint64_t a1, uint64_t a2, int a3, unsigned int a4)
{
  char v4;
  int v7;
  uint64_t **v8;
  unsigned __int16 v9;
  uint64_t v11;
  char v12;

  v4 = a3;
  if (((2 * *(unsigned __int8 *)(a1 + 32)) | 1u) >= *(_DWORD *)(a1 + 16) - a3)
    v7 = *(_DWORD *)(a1 + 16) - a3;
  else
    LOWORD(v7) = (2 * *(unsigned __int8 *)(a1 + 32)) | 1;
  v8 = std::__hash_table<std::__hash_value_type<unsigned char,unsigned int>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,unsigned int>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,unsigned int>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,unsigned int>>>::find<unsigned char>(*(_QWORD **)(a1 + 24), *(_BYTE *)(*(_QWORD *)(a1 + 8) + a4));
  if (v8)
    v9 = ((_WORD)v7 << 8) | ((*((_DWORD *)v8 + 5) >> v4) & ~(-1 << v7));
  else
    v9 = v7 << 8;
  v12 = 0;
  v11 = 0;
  if (tt_transition_for_state(**(_QWORD ***)a1, a2, v9, &v11, &v12))
    return v11;
  else
    return 0;
}

CFTimeZoneRef __si_calendar_retain_block_invoke()
{
  CFTimeZoneRef result;

  si_calendar_retain_s_local_tz = (uint64_t)CFTimeZoneCopySystem();
  result = CFTimeZoneCreateWithTimeIntervalFromGMT((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0.0);
  si_calendar_retain_s_gmt_tz = (uint64_t)result;
  return result;
}

CFCalendarRef ___expandFunctions_block_invoke()
{
  CFCalendarRef result;

  result = CFCalendarCreateWithIdentifier((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (CFCalendarIdentifier)*MEMORY[0x1E0C9B008]);
  _expandFunctions_calendar = (uint64_t)result;
  return result;
}

void si_querypipe_addcoalescedresults(uint64_t a1, PartialQueryResults *this, int *a3, char a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  char v14;
  uint64_t v15;
  unsigned __int16 v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const __CFArray *v21;
  uint64_t v22;
  const __CFArray *v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unsigned int *v38;
  const void *v39;
  const void *Value;
  int v41;
  CFIndex Count;
  uint64_t v43;
  uint64_t v44;
  unsigned int v45;
  uint64_t v46;
  uint64_t v47;
  char *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  _OWORD *v53;
  unint64_t *v54;
  unint64_t *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  int v60;
  NSObject *v61;
  int v62;
  NSObject *log;
  char v64;
  CFIndex v65;
  _BYTE buf[12];
  __int16 v67;
  const void *v68;
  __int16 v69;
  uint64_t v70;
  uint64_t v71;

  v71 = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)(a1 + 96))
  {
    v8 = a1;
    do
    {
      v9 = v8;
      v8 = *(_QWORD *)(v8 + 80);
    }
    while (v8);
    if (!*(_BYTE *)(*(_QWORD *)(v9 + 8) + 12))
    {
      v10 = a1;
      do
      {
        v11 = v10;
        v10 = *(_QWORD *)(v10 + 80);
      }
      while (v10);
      v12 = *(_DWORD *)(*(_QWORD *)(v11 + 8) + 80);
      v13 = *(_QWORD *)(a1 + 80);
      if (!v13)
        goto LABEL_12;
      v14 = 0;
      v15 = a1;
      do
      {
        v14 ^= *(_DWORD *)(v15 + 104) == 0;
        v15 = v13;
        v13 = *(_QWORD *)(v13 + 80);
      }
      while (v13);
      if ((v14 & 1) != 0)
        v16 = 3553;
      else
LABEL_12:
        v16 = 2781;
      v17 = (void *)PartialQueryResults::start(this, v12, v16, 2uLL, 0);
      v18 = PartialQueryResults::attributeIdVector(this, a3);
      v19 = *((_QWORD *)this + 29);
      v64 = a4;
      if (*(_BYTE *)this)
      {
        if (v19 && !*((_QWORD *)this + 23))
        {
          v20 = *((_QWORD *)this + 13);
          if (!v20)
          {
            v21 = (const __CFArray *)*((_QWORD *)this + 16);
            if (v21)
            {
              *(_QWORD *)buf = 0;
              SIFlattenArrayToCStringVector(v21, (char **)this + 13, (size_t *)buf, &v65);
              v20 = *((_QWORD *)this + 13);
            }
            else
            {
              v20 = 0;
            }
          }
          PartialQueryResults::setupCannedCollectAttributeVector((uint64_t)this, v20, (_QWORD *)this + 23, buf);
        }
        v33 = (char *)this + 184;
      }
      else
      {
        if (v19 && !*((_QWORD *)this + 22))
        {
          v22 = *((_QWORD *)this + 12);
          if (!v22)
          {
            v23 = (const __CFArray *)*((_QWORD *)this + 15);
            if (v23)
            {
              SIFlattenArrayToCStringVector(v23, (char **)this + 12, (size_t *)this + 30, (CFIndex *)this + 29);
              v22 = *((_QWORD *)this + 12);
              if (!v22)
              {
                v24 = __si_assert_copy_extra_268();
                __message_assert_272((uint64_t)v24, v25, v26, v27, v28, v29, v30, v31, (char)"SISearchCtx.h");
                free(v24);
                if (__valid_fs(-1))
                  v32 = 2989;
                else
                  v32 = 3072;
                *(_DWORD *)v32 = -559038737;
                abort();
              }
            }
            else
            {
              v22 = 0;
            }
          }
          PartialQueryResults::setupCannedCollectAttributeVector((uint64_t)this, v22, (_QWORD *)this + 22, (_QWORD *)this + 2);
        }
        v33 = (char *)this + 176;
      }
      v34 = *(_QWORD *)v33;
      v35 = *((_QWORD *)this + 29);
      _MDPlistBytesBeginArray();
      if (v35 >= 1)
      {
        v36 = 0;
        v37 = 0;
        while (1)
        {
          if (v18 && (v38 = *(unsigned int **)(v18 + 8 * v36)) != 0)
          {
            v39 = (const void *)*v38;
          }
          else
          {
            v39 = *(const void **)(v34 + 8 * v36);
            if (!v39)
            {
              Value = 0;
              goto LABEL_41;
            }
          }
          Value = CFDictionaryGetValue(*((CFDictionaryRef *)this + 14), v39);
          if (!Value)
          {
            Value = CFSetCreateMutable((CFAllocatorRef)kCIQueryZoneAllocator, 0, MEMORY[0x1E0C9B3B0]);
            CFDictionarySetValue(*((CFMutableDictionaryRef *)this + 14), v39, Value);
            CFRelease(Value);
          }
LABEL_41:
          if (dword_1EF19FC90 >= 5)
          {
            v41 = *__error();
            log = _SILogForLogForCategory(1);
            if (os_log_type_enabled(log, OS_LOG_TYPE_DEFAULT))
            {
              v62 = v41;
              if (Value)
                Count = CFSetGetCount((CFSetRef)Value);
              else
                Count = 0;
              v43 = *((_QWORD *)PartialQueryResults::attributeVector(this) + v36);
              *(_DWORD *)buf = 134218498;
              *(_QWORD *)&buf[4] = Count;
              v67 = 2048;
              v68 = Value;
              v69 = 2080;
              v70 = v43;
              _os_log_impl(&dword_1B8270000, log, OS_LOG_TYPE_DEFAULT, "Encoding %ld items from set %p for field %s", buf, 0x20u);
              v41 = v62;
            }
            *__error() = v41;
            if (!Value)
            {
LABEL_51:
              _MDPlistBytesAddNull();
              goto LABEL_52;
            }
          }
          else if (!Value)
          {
            goto LABEL_51;
          }
          if (!CFSetGetCount((CFSetRef)Value))
            goto LABEL_51;
          v37 += CFSetGetCount((CFSetRef)Value);
          _MDPlistBytesBeginArray();
          CFSetApplyFunction((CFSetRef)Value, (CFSetApplierFunction)encodeCTypeField, v17);
          _MDPlistBytesEndArray();
LABEL_52:
          if (v35 == ++v36)
            goto LABEL_55;
        }
      }
      v37 = 0;
LABEL_55:
      _MDPlistBytesEndArray();
      if (*((_QWORD *)this + 186))
      {
        _MDPlistBytesEndArray();
        _MDPlistBytesEndPlist();
      }
      if (*((_QWORD *)this + 58))
      {
        _MDStoreOIDArrayEndBulkAdd();
        _MDStoreOIDArrayEndSequence();
        *((_QWORD *)this + 443) = 0;
      }
      if (v37 != *(_QWORD *)(a1 + 72) || (v64 & 1) != 0)
      {
        v44 = *((_QWORD *)this + 186);
        *((_QWORD *)this + 186) = 0;
        v45 = *((_DWORD *)this + 884);
        if (v44)
        {
LABEL_68:
          _MDPlistBytesAppendMultiplePlistBytes();
        }
        else
        {
          v46 = 0;
          if (v45 <= 1)
            v47 = 1;
          else
            v47 = v45;
          v48 = (char *)this + 1496;
          v49 = v47 - 1;
          while (v49 != v46)
          {
            v44 = *(_QWORD *)&v48[8 * v46];
            *(_QWORD *)&v48[8 * v46++] = 0;
            if (v44)
              goto LABEL_68;
          }
          v44 = 0;
        }
        v50 = a1;
        do
        {
          v51 = v50;
          v50 = *(_QWORD *)(v50 + 80);
        }
        while (v50);
        if (*MEMORY[0x1E0C85AD8] <= 0x3FuLL)
          ++sTotal;
        v52 = *(_QWORD *)(v51 + 8);
        v53 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x40uLL, 0x31F9A007uLL);
        if (!v53)
          _log_fault_for_malloc_failure();
        v53[1] = *(_OWORD *)(a1 + 48);
        *((_QWORD *)v53 + 1) = si_querypipe_copy_jobid(a1);
        v54 = (unint64_t *)malloc_type_malloc(0x10uLL, 0x100004000313F17uLL);
        v55 = v54;
        v54[1] = 2;
        if (*(_QWORD *)(a1 + 72))
        {
          v54[1] = 1;
          *((_QWORD *)v53 + 5) = v44;
          *((_QWORD *)v53 + 4) = _MDStoreOIDArrayCreateMutableWithOids();
          v56 = a1;
          do
          {
            v57 = v56;
            v56 = *(_QWORD *)(v56 + 80);
          }
          while (v56);
          *v55 = ((unint64_t)*(unsigned int *)(*(_QWORD *)(v57 + 8) + 80) << 32) | 0xC8D0001;
          *((_DWORD *)v53 + 14) = 2;
          *(_DWORD *)v53 = 7;
        }
        else
        {
          *((_QWORD *)v53 + 5) = v44;
          *(_DWORD *)v53 = 1;
          *((_QWORD *)v53 + 4) = _MDStoreOIDArrayCreateMutableWithOids();
          v58 = a1;
          do
          {
            v59 = v58;
            v58 = *(_QWORD *)(v58 + 80);
          }
          while (v58);
          *v55 = ((unint64_t)*(unsigned int *)(*(_QWORD *)(v59 + 8) + 80) << 32) | 0xADD0001;
        }
        _MDStoreOIDArraySetShouldUseMalloc();
        *(_QWORD *)(a1 + 72) = v37;
        if (!si_resultqueue_enqueue(v52, (int *)v53))
        {
          if (dword_1EF19FC90 >= 5)
          {
            v60 = *__error();
            v61 = _SILogForLogForCategory(1);
            if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl(&dword_1B8270000, v61, OS_LOG_TYPE_DEFAULT, "Attempt to append to queue failed. Releasing result batch", buf, 2u);
            }
            *__error() = v60;
          }
          SIResultBatchFree((void **)v53);
        }
      }
    }
  }
}

const __CFArray *PartialQueryResults::_attributeVector(PartialQueryResults *this)
{
  CFIndex *v2;
  uint64_t v3;
  const __CFArray *result;
  char **v5;
  BOOL v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v2 = (CFIndex *)((char *)this + 232);
  v3 = *((_QWORD *)this + 29);
  v5 = (char **)((char *)this + 96);
  result = (const __CFArray *)*((_QWORD *)this + 12);
  if (v3)
    v6 = result == 0;
  else
    v6 = 0;
  if (v6)
  {
    result = (const __CFArray *)*((_QWORD *)this + 15);
    if (result)
    {
      SIFlattenArrayToCStringVector(result, v5, (size_t *)this + 30, v2);
      result = (const __CFArray *)*((_QWORD *)this + 12);
      if (!result)
      {
        v7 = __si_assert_copy_extra_268();
        __message_assert_272((uint64_t)v7, v8, v9, v10, v11, v12, v13, v14, (char)"SISearchCtx.h");
        free(v7);
        if (__valid_fs(-1))
          v15 = 2989;
        else
          v15 = 3072;
        *(_DWORD *)v15 = -559038737;
        abort();
      }
    }
  }
  return result;
}

_DWORD *encodeCTypeField(uint64_t a1)
{
  _DWORD *result;
  int v3;
  NSObject *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  result = (_DWORD *)__MDPlistBytesAddObject();
  if (dword_1EF19FC90 >= 5)
  {
    v3 = *__error();
    v4 = _SILogForLogForCategory(1);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      v5 = 138412290;
      v6 = a1;
      _os_log_impl(&dword_1B8270000, v4, OS_LOG_TYPE_DEFAULT, "Appended datum: %@", (uint8_t *)&v5, 0xCu);
    }
    result = __error();
    *result = v3;
  }
  return result;
}

void __si_querypipe_addresults_block_invoke_2(uint64_t a1, const void *a2, const void *a3)
{
  const void *MutableCopy;
  uint64_t Vector;
  unsigned int VectorCount;
  unint64_t i;
  unsigned __int16 *v10;
  uint64_t v11;
  const void *v12;

  if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) != *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8)
                                                                                + 24))
  {
    MutableCopy = (const void *)_MDStoreOIDArrayCreateMutableCopy();
    _MDStoreOIDArrayGetVectorCount();
    _MDStoreOIDArrayApplyBlock();
    Vector = _MDStoreOIDArrayGetVector();
    VectorCount = _MDStoreOIDArrayGetVectorCount();
    if (VectorCount)
    {
      for (i = 0; i < VectorCount; i += v11 + 1)
      {
        v10 = (unsigned __int16 *)(Vector + 8 * i);
        v11 = *v10;
        v10[1] = 3213;
      }
    }
    v12 = (const void *)_MDPlistBytesCreateMutableCopy();
    _si_querypipe_addoids(*(_QWORD *)(a1 + 56), 2, MutableCopy, 0, v12, 0, *(_QWORD *)(a1 + 64));
  }
  _MDStoreOIDArrayGetVectorCount();
  _MDStoreOIDArrayApplyBlock();
  _si_querypipe_addoids(*(_QWORD *)(a1 + 56), *(_DWORD *)(a1 + 72), a2, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24), a3, 0, *(_QWORD *)(a1 + 64));
}

uint64_t PartialQueryResults::ownOidArray(PartialQueryResults *this)
{
  uint64_t v1;
  char *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (*((_QWORD *)this + 443))
  {
    v3 = __si_assert_copy_extra_268();
    __message_assert_272((uint64_t)v3, v4, v5, v6, v7, v8, v9, v10, (char)"SISearchCtx.h");
    free(v3);
    if (__valid_fs(-1))
      v11 = 2989;
    else
      v11 = 3072;
    *(_DWORD *)v11 = -559038737;
    abort();
  }
  v1 = *((_QWORD *)this + 58);
  *((_QWORD *)this + 58) = 0;
  _MDStoreOIDArrayAppendMultipleOIDArrays();
  return v1;
}

uint64_t PartialQueryResults::ownFields(PartialQueryResults *this)
{
  uint64_t v1;
  unsigned int v2;
  uint64_t v3;
  uint64_t v4;
  char *v5;
  uint64_t v6;

  v1 = *((_QWORD *)this + 186);
  *((_QWORD *)this + 186) = 0;
  v2 = *((_DWORD *)this + 884);
  if (v1)
  {
LABEL_8:
    _MDPlistBytesAppendMultiplePlistBytes();
  }
  else
  {
    v3 = 0;
    if (v2 <= 1)
      v4 = 1;
    else
      v4 = v2;
    v5 = (char *)this + 1496;
    v6 = v4 - 1;
    while (v6 != v3)
    {
      v1 = *(_QWORD *)&v5[8 * v3];
      *(_QWORD *)&v5[8 * v3++] = 0;
      if (v1)
        goto LABEL_8;
    }
    return 0;
  }
  return v1;
}

uint64_t _oidCmp(_QWORD *a1, _QWORD *a2)
{
  if (*a1 < *a2)
    return 0xFFFFFFFFLL;
  else
    return *a1 > *a2;
}

uint64_t __si_querypipe_addresults_block_invoke_5(uint64_t result, uint64_t a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  if (!a3 || !*(_DWORD *)(result + 48))
  {
    v3 = *(_QWORD *)(result + 40);
    v4 = *(_QWORD *)(*(_QWORD *)(result + 32) + 8);
    v5 = *(_QWORD *)(v4 + 24);
    *(_QWORD *)(v4 + 24) = v5 + 1;
    *(_QWORD *)(v3 + 8 * v5) = a2;
  }
  return result;
}

uint64_t __si_querypipe_addresults_block_invoke_3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6;
  uint64_t v7;
  void *v8;
  uint64_t v10;
  unint64_t v11;
  int v12;
  uint64_t v13;
  int v14;

  v6 = *(_QWORD *)(a1 + 32);
  v7 = (a5 - 1);
  pthread_rwlock_rdlock((pthread_rwlock_t *)(v6 + 16));
  if ((_DWORD)v7)
  {
    v8 = (void *)(a4 + 8);
    if (*(_BYTE *)(v6 + 384))
    {
      bzero(v8, 8 * v7);
      return pthread_rwlock_unlock((pthread_rwlock_t *)(v6 + 16));
    }
    v10 = 0;
    while (1)
    {
      v11 = *((_QWORD *)v8 + v10);
      v12 = *(_DWORD *)(v6 + 224);
      if (v12 && (*(_QWORD *)(v6 + 216) ^ v11) >> (-4 * v12))
        goto LABEL_6;
      v13 = *(_QWORD *)(v6 + 256 + 8 * ((v11 >> ((60 - 4 * v12) & 0xFC)) & 0xF));
      if ((v13 & 1) != 0)
      {
        v14 = v12 + 2;
        do
          v13 = *(_QWORD *)((v13 & 0xFFFFFFFFFFFFFFFELL) + 8 * ((v11 >> ((64 - 4 * v14++) & 0xFC)) & 0xF));
        while ((v13 & 1) != 0);
      }
      if (!v13 || ((*(uint64_t (**)(uint64_t))(*(_QWORD *)v13 + 16))(v13) & 1) == 0)
        goto LABEL_6;
      while (1)
      {
        if (++v10 == v7)
          return pthread_rwlock_unlock((pthread_rwlock_t *)(v6 + 16));
        if (!*(_BYTE *)(v6 + 384))
          break;
LABEL_6:
        *((_QWORD *)v8 + v10) = 0;
      }
    }
  }
  return pthread_rwlock_unlock((pthread_rwlock_t *)(v6 + 16));
}

uint64_t __si_querypipe_addresults_block_invoke_4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  int v12;
  uint64_t v13;
  int v14;

  v6 = *(_QWORD *)(a1 + 32);
  v7 = (a5 - 1);
  pthread_rwlock_rdlock((pthread_rwlock_t *)(v6 + 16));
  if ((_DWORD)v7 && !*(_BYTE *)(v6 + 384))
  {
    v9 = 0;
    v10 = a4 + 8;
LABEL_7:
    v11 = *(_QWORD *)(v10 + 8 * v9);
    v12 = *(_DWORD *)(v6 + 224);
    if (!v12 || !((*(_QWORD *)(v6 + 216) ^ v11) >> (-4 * v12)))
    {
      v13 = *(_QWORD *)(v6 + 256 + 8 * ((v11 >> ((60 - 4 * v12) & 0xFC)) & 0xF));
      if ((v13 & 1) != 0)
      {
        v14 = v12 + 2;
        do
          v13 = *(_QWORD *)((v13 & 0xFFFFFFFFFFFFFFFELL) + 8 * ((v11 >> ((64 - 4 * v14++) & 0xFC)) & 0xF));
        while ((v13 & 1) != 0);
      }
      if (v13 && (*(unsigned int (**)(uint64_t))(*(_QWORD *)v13 + 16))(v13))
        *(_QWORD *)(v10 + 8 * v9) = 0;
    }
    while (++v9 != v7)
    {
      if (!*(_BYTE *)(v6 + 384))
        goto LABEL_7;
    }
  }
  return pthread_rwlock_unlock((pthread_rwlock_t *)(v6 + 16));
}

void si_querypipe_addcompletions(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  unsigned int *v9;
  unsigned int *v10;
  _OWORD *v11;
  int v12;
  const char **v13;
  const char *v14;
  int v15;
  NSObject *v16;
  os_log_type_t v17;
  uint64_t v18;
  malloc_zone_t **v19;
  unsigned int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  _OWORD *v24;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD v28[6];
  _QWORD v29[4];
  __int128 buf;
  uint64_t v31;
  uint64_t MutableUsingMallocWithZone;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(a1 + 96))
    goto LABEL_5;
  v7 = a1;
  do
  {
    v8 = v7;
    v7 = *(_QWORD *)(v7 + 80);
  }
  while (v7);
  if (*(_BYTE *)(*(_QWORD *)(v8 + 8) + 12))
  {
LABEL_5:
    v9 = si_querypipe_copy_jobid(a1);
    if (v9)
    {
      v10 = v9;
      if (*MEMORY[0x1E0C85AD8] <= 0x3FuLL)
        ++sTotal;
      v11 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x40uLL, 0x31F9A007uLL);
      if (!v11)
        _log_fault_for_malloc_failure();
      v11[1] = *(_OWORD *)(a1 + 48);
      *((_QWORD *)v11 + 1) = v10;
      *(_DWORD *)v11 = 9;
      *((_QWORD *)v11 + 4) = _MDStoreOIDArrayCreate();
      si_querypipe_remove_process(a1, a4, (void **)v11, 0);
    }
  }
  else
  {
    v12 = *(_DWORD *)(a2 + 320);
    if (*(_QWORD *)a4 && (v13 = *(const char ***)(*(_QWORD *)a4 + 120)) != 0)
    {
      v14 = *v13;
      v15 = *__error();
      v16 = _SILogForLogForCategory(1);
      v17 = 2 * (dword_1EF19FC90 < 4);
      if (os_log_type_enabled(v16, v17))
      {
        LODWORD(buf) = 136315138;
        *(_QWORD *)((char *)&buf + 4) = v14;
        _os_log_impl(&dword_1B8270000, v16, v17, "Setting locale to %s", (uint8_t *)&buf, 0xCu);
      }
      *__error() = v15;
    }
    else
    {
      v14 = "en-US";
    }
    *(_QWORD *)&buf = 0;
    *((_QWORD *)&buf + 1) = &buf;
    v31 = 0x2000000000;
    MutableUsingMallocWithZone = 0;
    MutableUsingMallocWithZone = _MDPlistBytesCreateMutableUsingMallocWithZone();
    _MDPlistBytesBeginPlist();
    _MDPlistBytesBeginArray();
    v29[0] = 0;
    v29[1] = v29;
    v29[2] = 0x2000000000;
    v29[3] = 0;
    if ((v12 & 0x100) != 0)
    {
      v20 = *(_DWORD *)(a2 + 320);
      if (v14)
      {
        v19 = (malloc_zone_t **)&unk_1EDBEA000;
        v21 = !strncmp("ja", v14, 2uLL)
           || !strncmp("zh", v14, 2uLL)
           || !strncmp("ko", v14, 2uLL)
           || strncmp("yue", v14, 3uLL) == 0;
      }
      else
      {
        v21 = 0;
        v19 = (malloc_zone_t **)&unk_1EDBEA000;
      }
      v22 = *(_QWORD *)(a2 + 424);
      v23 = *(_QWORD *)(a2 + 312);
      v28[0] = MEMORY[0x1E0C809B0];
      v28[1] = 0x40000000;
      v28[2] = __si_querypipe_addcompletions_block_invoke;
      v28[3] = &unk_1E6E2FC40;
      v28[4] = &buf;
      v28[5] = v29;
      SIPommesEnumerateSuggestions(v22, v23, (v20 >> 9) & 1, (v20 & 0x400) != 0, (v20 >> 11) & 1, v21, (uint64_t)v14, (uint64_t)v28);
    }
    else
    {
      v18 = atomic_load((unint64_t *)(a2 + 328));
      SICompletionModelEnumerateCompletions(v18);
      v19 = (malloc_zone_t **)&unk_1EDBEA000;
    }
    _MDPlistBytesEndArray();
    _MDPlistBytesEndPlist();
    if (*MEMORY[0x1E0C85AD8] <= 0x3FuLL)
      ++sTotal;
    v24 = malloc_type_zone_calloc(v19[114], 1uLL, 0x40uLL, 0x31F9A007uLL);
    if (!v24)
      _log_fault_for_malloc_failure();
    v24[1] = *(_OWORD *)(a1 + 48);
    *((_QWORD *)v24 + 1) = si_querypipe_copy_jobid(a1);
    v25 = malloc_type_malloc(8uLL, 0x100004000313F17uLL);
    *((_QWORD *)v24 + 5) = *(_QWORD *)(*((_QWORD *)&buf + 1) + 24);
    *(_DWORD *)v24 = 9;
    *((_QWORD *)v24 + 4) = _MDStoreOIDArrayCreateMutableWithOids();
    v26 = a1;
    do
    {
      v27 = v26;
      v26 = *(_QWORD *)(v26 + 80);
    }
    while (v26);
    *v25 = ((unint64_t)*(unsigned int *)(*(_QWORD *)(v27 + 8) + 80) << 32) | 0xADF0000;
    _MDStoreOIDArraySetShouldUseMalloc();
    si_querypipe_remove_process(a1, a4, (void **)v24, 0);
    _Block_object_dispose(v29, 8);
    _Block_object_dispose(&buf, 8);
  }
}

uint64_t __si_querypipe_addcompletions_block_invoke(uint64_t a1, uint64_t a2)
{
  const __CFArray *v4;
  CFIndex Count;
  CFIndex v6;
  CFIndex i;
  const __CFString *ValueAtIndex;
  uint64_t result;

  _MDPlistBytesBeginArray();
  _MDPlistBytesAddString();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddReal();
  _MDPlistBytesAddReal();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddReal();
  _MDPlistBytesAddReal();
  _MDPlistBytesAddReal();
  _MDPlistBytesAddReal();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddInteger();
  _MDPlistBytesBeginArray();
  v4 = *(const __CFArray **)(a2 + 184);
  if (v4)
  {
    Count = CFArrayGetCount(v4);
    if (Count >= 1)
    {
      v6 = Count;
      for (i = 0; i != v6; ++i)
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 184), i);
        if (CFStringGetCStringPtr(ValueAtIndex, 0x8000100u))
          _MDPlistBytesAddCString();
      }
    }
  }
  _MDPlistBytesEndArray();
  result = _MDPlistBytesEndArray();
  ++*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  return result;
}

uint64_t __si_querypipe_addcompletions_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  NSObject *v5;
  int v6;
  uint64_t string_for_id;
  uint64_t v8;
  uint64_t result;
  uint8_t buf[4];
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  _MDPlistBytesBeginArray();
  _MDPlistBytesAddString();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddReal();
  _MDPlistBytesAddReal();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddReal();
  _MDPlistBytesAddReal();
  _MDPlistBytesAddReal();
  _MDPlistBytesAddReal();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddInteger();
  _MDPlistBytesAddInteger();
  _MDPlistBytesBeginArray();
  if (*(int *)(a2 + 164) >= 1)
  {
    v4 = 0;
    v5 = MEMORY[0x1E0C81028];
    do
    {
      v6 = *(_DWORD *)(a2 + 168 + 4 * v4);
      if (v6)
      {
        if (!_MDPlistBytesAddRawInternedCStringKey())
        {
          string_for_id = db_get_string_for_id(*(int **)(a1 + 48), v6);
          if (string_for_id)
          {
            v8 = string_for_id;
            if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136315138;
              v11 = v8;
              _os_log_impl(&dword_1B8270000, v5, OS_LOG_TYPE_DEFAULT, "String: %s", buf, 0xCu);
            }
            _MDPlistBytesAddRawInternedCStringKeyWithString();
          }
        }
      }
      ++v4;
    }
    while (v4 < *(int *)(a2 + 164));
  }
  _MDPlistBytesEndArray();
  result = _MDPlistBytesEndArray();
  ++*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  return result;
}

uint64_t FileBackedBloomMap::grow(FileBackedBloomMap *this)
{
  if (_fd_ftruncate(*(unsigned int *)this, (*((_DWORD *)this + 6) << 17) + 0x20000))
    return -*__error();
  *((_QWORD *)this + 3) = (*((_DWORD *)this + 6) + 1);
  FileBackedBloomMap::unmap(this);
  return FileBackedBloomMap::map(this);
}

int *FileBackedBloomMap::unmap(FileBackedBloomMap *this)
{
  int *result;
  _QWORD *v3;
  size_t v4;

  v3 = (_QWORD *)((char *)this + 8);
  result = (int *)*((_QWORD *)this + 1);
  if (result)
  {
    v4 = *((_QWORD *)this + 2);
    *v3 = 0;
    v3[1] = 0;
    result = (int *)munmap(result, v4);
    if ((_DWORD)result)
      return __error();
  }
  return result;
}

uint64_t FileBackedBloomMap::map(FileBackedBloomMap *this)
{
  char *v2;
  uint64_t v3;
  int *v4;
  uint64_t v5;
  int v6;
  NSObject *v7;
  const char *v8;
  int *v9;
  int __errnum;
  int __errnuma;
  uint8_t buf[4];
  char *v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v2 = (char *)mmap(0, (uint64_t)*((int *)this + 6) << 17, 1, 1, *(_DWORD *)this, 0);
  if (*((_QWORD *)this + 1) == -1)
  {
    v9 = __error();
    v5 = -*v9;
    if (gSILogLevels[0] >= 5)
    {
      __errnuma = *v9;
      v6 = *__error();
      v7 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315138;
        v14 = strerror(__errnuma);
        v8 = "mmap: %s\n";
        goto LABEL_9;
      }
LABEL_10:
      *__error() = v6;
    }
  }
  else
  {
    v3 = (uint64_t)*((int *)this + 6) << 17;
    *((_QWORD *)this + 1) = v2;
    *((_QWORD *)this + 2) = v3;
    if (!mprotect(&v2[v3 - 0x20000], 0x20000uLL, 3))
      return 0;
    v4 = __error();
    v5 = -*v4;
    if (gSILogLevels[0] >= 5)
    {
      __errnum = *v4;
      v6 = *__error();
      v7 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315138;
        v14 = strerror(__errnum);
        v8 = "mprotect: %s\n";
LABEL_9:
        _os_log_impl(&dword_1B8270000, v7, OS_LOG_TYPE_DEFAULT, v8, buf, 0xCu);
        goto LABEL_10;
      }
      goto LABEL_10;
    }
  }
  return v5;
}

uint64_t FileBackedBloomMap::Update(FileBackedBloomMap *this, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  int v9;
  unint64_t v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unint64_t v14;
  unsigned int v15;
  unint64_t v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  int *v20;
  int v21;
  void (*v22)(_QWORD);
  unsigned int v23;
  int v24;
  NSObject *v25;
  uint64_t v27;
  uint64_t v28;
  uint64_t *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  void (*v33)(_QWORD);
  unsigned int v35;
  _QWORD v36[2];
  _QWORD v37[3];
  uint8_t buf[4];
  const char *v39;
  __int16 v40;
  int v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  if (*((_DWORD *)this + 7) < *((_DWORD *)this + 8) || (v6 = FileBackedBloomMap::grow(this), !(_DWORD)v6))
  {
    v7 = *((_QWORD *)this + 2);
    v37[0] = *((_QWORD *)this + 1);
    v37[1] = v7;
    v37[2] = 0;
    v36[0] = 1;
    v36[1] = v37;
    do
    {
      v8 = __ldxr(exceptionSequenceNum);
      v9 = v8 + 1;
    }
    while (__stxr(v8 + 1, exceptionSequenceNum));
    v10 = setThreadIdAndInfo(-1, (__int128 *)sMappingExceptionCallbacks, (uint64_t)v36, 0, v9);
    v13 = v12;
    v14 = HIDWORD(v10);
    v15 = v10;
    v16 = HIDWORD(v10);
    v17 = v11;
    v18 = *(_QWORD *)&threadData[18 * v10 + 2];
    v19 = v18 + 320 * HIDWORD(v10);
    v20 = (int *)v19;
    *(_BYTE *)(v19 + 216) = 0;
    v21 = *(_DWORD *)(v19 + 312);
    v22 = *(void (**)(_QWORD))(v19 + 224);
    if (v22)
    {
      v23 = v11;
      v22(*(_QWORD *)(v18 + 320 * v14 + 288));
      v20 = (int *)v19;
      v17 = v23;
    }
    v35 = v17;
    if (_setjmp(v20))
    {
      v24 = *__error();
      v25 = _SILogForLogForCategory(0);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        v39 = "Update";
        v40 = 1024;
        v41 = 94;
        _os_log_error_impl(&dword_1B8270000, v25, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
      }
      *__error() = v24;
      *(_DWORD *)(v19 + 312) = v21;
      CIOnThreadCleanUpReset(v13);
      dropThreadId(v15, 1, v9);
      CICleanUpReset(v15, v35);
      return 4294967261;
    }
    else
    {
      v27 = *((unsigned int *)this + 9);
      if ((int)v27 >= 1)
      {
        v28 = *((_QWORD *)this + 1) + (*((_DWORD *)this + 6) << 17) - 0x20000;
        v29 = bloom_filter_hash_moduli;
        do
        {
          v30 = *v29++;
          *(_BYTE *)(v28 + (((a3 + ((unint64_t)(v30 * a2) >> 32)) >> 3) & 0x1FFFF)) |= 1 << ((a3 + ((unint64_t)(v30 * a2) >> 32)) & 7);
          --v27;
        }
        while (v27);
      }
      v31 = *(_QWORD *)&threadData[18 * v15 + 2];
      v32 = v31 + 320 * v16;
      *(_DWORD *)(v32 + 312) = v21;
      v33 = *(void (**)(_QWORD))(v32 + 232);
      if (v33)
        v33(*(_QWORD *)(v31 + 320 * v16 + 288));
      dropThreadId(v15, 0, v9);
      ++*((_DWORD *)this + 7);
      return 0;
    }
  }
  return v6;
}

uint64_t FileBackedBloomMap::CalcMayContainBitset(FileBackedBloomMap *this, uint64_t a2, unsigned __int8 *a3, int a4)
{
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  int v10;
  unint64_t v11;
  unsigned int v12;
  unsigned int v13;
  unint64_t v14;
  unsigned int v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  void (*v19)(_QWORD);
  int v20;
  uint64_t v21;
  _DWORD *v22;
  int v23;
  NSObject *v24;
  uint64_t v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;
  _BYTE *v29;
  uint64_t v30;
  int v31;
  uint8_t *v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  const unsigned __int8 *v38;
  _BYTE *v39;
  int v40;
  int v41;
  uint64_t v42;
  uint64_t v43;
  char *v44;
  char *v45;
  _BYTE *v46;
  uint64_t v47;
  char v48;
  char *v49;
  uint64_t v50;
  unsigned __int8 *v51;
  char v52;
  uint64_t v53;
  unsigned int v54;
  uint64_t v55;
  int v56;
  void (*v57)(_QWORD);
  uint8_t *v59;
  uint64_t v60;
  unsigned int v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  size_t v65;
  uint64_t v66;
  char *v67;
  char *v68;
  uint64_t v69;
  uint8_t **v70;
  int v71;
  unsigned __int8 *v72;
  int v73;
  int v74;
  unsigned int v75;
  unsigned int v76;
  unsigned int v77;
  unsigned int v78;
  _QWORD v79[2];
  _QWORD v80[3];
  uint8_t buf[4];
  const char *v82;
  __int16 v83;
  int v84;
  uint64_t v85;

  v71 = a4;
  v85 = *MEMORY[0x1E0C80C00];
  v7 = *((_QWORD *)this + 1);
  if (!v7)
  {
    v25 = FileBackedBloomMap::map(this);
    if ((_DWORD)v25)
      return v25;
    v7 = *((_QWORD *)this + 1);
  }
  v72 = a3;
  v8 = *((_QWORD *)this + 2);
  v80[0] = v7;
  v80[1] = v8;
  v80[2] = 0;
  v79[0] = 1;
  v79[1] = v80;
  do
  {
    v9 = __ldxr(exceptionSequenceNum);
    v10 = v9 + 1;
  }
  while (__stxr(v9 + 1, exceptionSequenceNum));
  v11 = setThreadIdAndInfo(-1, (__int128 *)sMappingExceptionCallbacks, (uint64_t)v79, 0, v10);
  v13 = v12;
  v14 = v11;
  v16 = v15;
  v17 = *(_QWORD *)&threadData[18 * v11 + 2];
  v18 = v17 + 320 * HIDWORD(v11);
  *(_BYTE *)(v18 + 216) = 0;
  v73 = *(_DWORD *)(v18 + 312);
  v19 = *(void (**)(_QWORD))(v18 + 224);
  if (v19)
    v19(*(_QWORD *)(v17 + 320 * HIDWORD(v11) + 288));
  v20 = v10;
  v77 = HIDWORD(v14);
  v78 = v14;
  v75 = v13;
  v76 = v16;
  v21 = _setjmp((int *)v18);
  if ((_DWORD)v21)
  {
    v22 = (_DWORD *)(v18 + 312);
    v23 = *__error();
    v24 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v82 = "CalcMayContainBitset";
      v83 = 1024;
      v84 = 125;
      _os_log_error_impl(&dword_1B8270000, v24, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
    }
    *__error() = v23;
    *v22 = v73;
    CIOnThreadCleanUpReset(v75);
    dropThreadId(v78, 1, v20);
    CICleanUpReset(v78, v76);
  }
  else
  {
    v74 = v10;
    v70 = &v59;
    v26 = v71;
    MEMORY[0x1E0C80A78](v21);
    v27 = (v26 + 15) & 0x1FFFFFFF0;
    v68 = (char *)&v59 - v27;
    bzero((char *)&v59 - v27, v26);
    MEMORY[0x1E0C80A78](v28);
    v67 = (char *)&v59 - v27;
    v69 = v26;
    bzero((char *)&v59 - v27, v26);
    bzero((char *)&v59 - v27, (int)v26);
    v66 = *((int *)this + 6);
    if ((int)v66 >= 1)
    {
      v29 = v67;
      v65 = (int)v26;
      v64 = *((_QWORD *)this + 1);
      v63 = *((unsigned int *)this + 9);
      v62 = 0x1FFFFLL;
      v61 = v26 - 0x20000;
      v30 = 0;
      do
      {
        v60 = v30;
        v31 = v63;
        memset(v29, 255, v65);
        if (v31 >= 1)
        {
          v32 = (uint8_t *)(v64 + (v60 << 17));
          v33 = &bloom_filter_hash_moduli;
          v59 = &v32[v62];
          v34 = v63;
          do
          {
            v35 = *v33++;
            v36 = ((unint64_t)(v35 * a2) >> 32) & 7;
            v37 = ((unint64_t)(v35 * a2) >> 35) & 0x1FFFF;
            if ((unint64_t)(v37 + (int)v26) >> 17)
            {
              v41 = v37;
              buf[0] = *v59;
              buf[1] = *v32;
              v42 = a2;
              v43 = v37 ^ 0x1FFFF;
              do_shifted_and(v29, &v32[v37], v37 ^ 0x1FFFF, v36);
              v44 = &v67[v43];
              do_shifted_and(v44, buf, 1, v36);
              v39 = v44 + 1;
              a2 = v42;
              v40 = v61 + v41;
              v38 = v32;
            }
            else
            {
              v38 = &v32[v37];
              v39 = v29;
              v40 = v71;
            }
            do_shifted_and(v39, v38, v40, v36);
            --v34;
          }
          while (v34);
        }
        v45 = v29;
        v46 = v68;
        v47 = v69;
        if (v71 >= 1)
        {
          do
          {
            v48 = *v45++;
            *v46++ |= v48;
            --v47;
          }
          while (v47);
        }
        v30 = v60 + 1;
      }
      while (v60 + 1 != v66);
    }
    if (v71 >= 1)
    {
      v49 = v68;
      v50 = v69;
      v51 = v72;
      do
      {
        v52 = *v49++;
        *v51++ &= v52;
        --v50;
      }
      while (v50);
    }
    v53 = *(_QWORD *)&threadData[18 * v78 + 2];
    v54 = v77;
    v55 = v53 + 320 * v77;
    v56 = v74;
    *(_DWORD *)(v55 + 312) = v73;
    v57 = *(void (**)(_QWORD))(v55 + 232);
    if (v57)
      v57(*(_QWORD *)(v53 + 320 * v54 + 288));
    dropThreadId(v78, 0, v56);
  }
  return 0;
}

uint64_t ends(uint64_t a1, char *a2)
{
  size_t v2;
  uint64_t v3;
  unsigned __int8 *v4;
  BOOL v5;

  v2 = *a2;
  v3 = *(int *)(a1 + 8);
  v4 = (unsigned __int8 *)(*(_QWORD *)a1 + v3);
  v5 = a2[v2] != *v4 || (int)v3 + 1 < (int)v2;
  if (v5 || memcmp(&v4[-v2 + 1], a2 + 1, v2))
    return 0;
  *(_DWORD *)(a1 + 12) = v3 - v2;
  return 1;
}

uint64_t m(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  int v4;
  uint64_t i;
  unsigned int v6;
  unint64_t v7;
  int v9;
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  uint64_t j;
  unsigned int v17;
  unint64_t v18;
  int v20;
  int v21;
  uint64_t k;
  unsigned int v23;
  unint64_t v24;
  int v26;

  v1 = *((unsigned int *)a1 + 3);
  if ((v1 & 0x80000000) != 0)
    return 0;
  v2 = 0;
  v3 = *a1;
  while (1)
  {
    v4 = 0;
    for (i = v2; ; --i)
    {
      HIDWORD(v7) = *(char *)(v3 + i) - 97;
      LODWORD(v7) = HIDWORD(v7);
      v6 = v7 >> 1;
      if (v6 != 12)
        break;
      if (!i)
        goto LABEL_12;
      v4 ^= 1u;
    }
    if (v6 <= 0xA && ((1 << v6) & 0x495) != 0)
    {
      v9 = 0;
      goto LABEL_13;
    }
LABEL_12:
    v9 = 1;
LABEL_13:
    if (v9 == v4)
      break;
    if (++v2 == v1 + 1)
      return 0;
  }
  result = 0;
LABEL_17:
  v11 = (int)v2;
  if ((int)v2 <= (int)v1)
    v12 = v1;
  else
    v12 = v2;
  v13 = v2 + 2;
  while (v11 != v12)
  {
    v14 = v11;
    LODWORD(v2) = v13;
    v15 = 0;
    for (j = ++v11; ; --j)
    {
      HIDWORD(v18) = *(char *)(v3 + j) - 97;
      LODWORD(v18) = HIDWORD(v18);
      v17 = v18 >> 1;
      if (v17 != 12)
        break;
      if (!j)
        goto LABEL_31;
      v15 ^= 1u;
    }
    if (v17 <= 0xA && ((1 << v17) & 0x495) != 0)
    {
      v20 = 0;
      goto LABEL_32;
    }
LABEL_31:
    v20 = 1;
LABEL_32:
    v13 = v2 + 1;
    if (v20 != v15)
    {
      result = (result + 1);
      if (v14 + 2 > (int)v1)
        return result;
      v2 = (int)v2;
      while (1)
      {
        v21 = 0;
        for (k = v2; ; --k)
        {
          HIDWORD(v24) = *(char *)(v3 + k) - 97;
          LODWORD(v24) = HIDWORD(v24);
          v23 = v24 >> 1;
          if (v23 != 12)
            break;
          if (!k)
            goto LABEL_44;
          v21 ^= 1u;
        }
        if (v23 <= 0xA && ((1 << v23) & 0x495) != 0)
        {
          v26 = 0;
          goto LABEL_45;
        }
LABEL_44:
        v26 = 1;
LABEL_45:
        if (v26 == v21)
          goto LABEL_17;
        if (v2++ >= v1)
          return result;
      }
    }
  }
  return result;
}

uint64_t vowelinstem(uint64_t a1, int a2)
{
  uint64_t v2;
  int v3;
  uint64_t i;
  unsigned int v5;
  unint64_t v6;
  int v8;

  if (a2 < 0)
    return 0;
  v2 = 0;
  while (1)
  {
    v3 = 0;
    for (i = v2; ; --i)
    {
      HIDWORD(v6) = *(char *)(a1 + i) - 97;
      LODWORD(v6) = HIDWORD(v6);
      v5 = v6 >> 1;
      if (v5 != 12)
        break;
      if (!i)
        goto LABEL_12;
      v3 ^= 1u;
    }
    if (v5 <= 0xA && ((1 << v5) & 0x495) != 0)
    {
      v8 = 0;
      goto LABEL_13;
    }
LABEL_12:
    v8 = 1;
LABEL_13:
    if (v8 == v3)
      return 1;
    if (++v2 == a2 + 1)
      return 0;
  }
}

uint64_t doublec(_QWORD *a1, int a2)
{
  int v2;
  unsigned int v3;
  uint64_t i;
  unsigned int v5;
  unint64_t v6;
  _BOOL4 v9;

  if (a2 < 1)
    return 0;
  v2 = *(unsigned __int8 *)(*a1 + a2);
  if (v2 != *(unsigned __int8 *)(*a1 + (a2 - 1)))
    return 0;
  v3 = 0;
  for (i = a2; ; --i)
  {
    HIDWORD(v6) = (char)v2 - 97;
    LODWORD(v6) = HIDWORD(v6);
    v5 = v6 >> 1;
    if (v5 != 12)
      break;
    if (!i)
    {
      v9 = 1;
      return v9 ^ v3;
    }
    LOBYTE(v2) = *(_BYTE *)(*a1 - 1 + i);
    v3 ^= 1u;
  }
  v9 = v5 > 0xA || ((1 << v5) & 0x495) == 0;
  return v9 ^ v3;
}

BOOL cvc(uint64_t *a1, unsigned int a2)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  uint64_t i;
  unsigned int v6;
  unint64_t v7;
  int v9;
  int v10;
  uint64_t j;
  unsigned int v12;
  unint64_t v13;
  int v15;
  int k;
  unsigned int v17;
  unint64_t v18;
  int v20;

  v2 = a2 - 2;
  if ((int)a2 < 2)
    return 0;
  v3 = 0;
  v4 = *a1;
  for (i = a2; ; --i)
  {
    HIDWORD(v7) = *(char *)(v4 + i) - 97;
    LODWORD(v7) = HIDWORD(v7);
    v6 = v7 >> 1;
    if (v6 != 12)
      break;
    if (!i)
      goto LABEL_11;
    v3 ^= 1u;
  }
  if (v6 <= 0xA && ((1 << v6) & 0x495) != 0)
  {
    v9 = 0;
    goto LABEL_12;
  }
LABEL_11:
  v9 = 1;
LABEL_12:
  if (v9 == v3)
    return 0;
  v10 = 0;
  for (j = a2 - 1; ; --j)
  {
    HIDWORD(v13) = *(char *)(v4 + j) - 97;
    LODWORD(v13) = HIDWORD(v13);
    v12 = v13 >> 1;
    if (v12 != 12)
      break;
    if (!j)
      goto LABEL_22;
    v10 ^= 1u;
  }
  if (v12 <= 0xA && ((1 << v12) & 0x495) != 0)
  {
    v15 = 0;
    goto LABEL_23;
  }
LABEL_22:
  v15 = 1;
LABEL_23:
  if (v15 != v10)
    return 0;
  for (k = 0; ; k ^= 1u)
  {
    HIDWORD(v18) = *(char *)(v4 + v2) - 97;
    LODWORD(v18) = HIDWORD(v18);
    v17 = v18 >> 1;
    if (v17 != 12)
      break;
    if (!v2)
      goto LABEL_33;
    --v2;
  }
  if (v17 <= 0xA && ((1 << v17) & 0x495) != 0)
  {
    v20 = 0;
    return v20 != k && *(unsigned __int8 *)(v4 + a2) - 122 < 0xFFFFFFFD;
  }
LABEL_33:
  v20 = 1;
  return v20 != k && *(unsigned __int8 *)(v4 + a2) - 122 < 0xFFFFFFFD;
}

uint64_t step5(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  int v4;

  v1 = result;
  v2 = *(_QWORD *)result;
  v3 = *(int *)(result + 8);
  *(_DWORD *)(result + 12) = v3;
  v4 = *(unsigned __int8 *)(v2 + v3);
  if (v4 == 101)
  {
    result = m((uint64_t *)result);
    if ((int)result < 2)
    {
      if ((_DWORD)result != 1)
        return result;
      LODWORD(v3) = v3 - 1;
      result = cvc((uint64_t *)v1, v3);
      if ((_DWORD)result)
        return result;
    }
    else
    {
      LODWORD(v3) = v3 - 1;
    }
    *(_DWORD *)(v1 + 8) = v3;
    v4 = *(unsigned __int8 *)(v2 + (int)v3);
  }
  if (v4 == 108)
  {
    result = doublec((_QWORD *)v1, v3);
    if ((_DWORD)result)
    {
      result = m((uint64_t *)v1);
      if ((int)result >= 2)
        *(_DWORD *)(v1 + 8) = v3 - 1;
    }
  }
  return result;
}

unint64_t SISearchCtx_METADATA::queryContext(SISearchCtx_METADATA *this)
{
  unint64_t *v1;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v1 = (unint64_t *)((char *)this + 1136);
  if (!*((_QWORD *)this + 142))
  {
    v3 = operator new();
    v5 = *((_QWORD *)this + 2);
    v4 = *((_QWORD *)this + 3);
    *(_QWORD *)(v3 + 16) = this;
    *(_QWORD *)(v3 + 24) = v5;
    *(_BYTE *)(v3 + 32) = 0;
    *(_QWORD *)v3 = &off_1E6E2A2C0;
    *(_QWORD *)(v3 + 8) = v4;
    *(_QWORD *)(v3 + 40) = 0;
    __dmb(0xBu);
    while (!__ldaxr(v1))
    {
      if (!__stlxr(v3, v1))
        return *v1;
    }
    __clrex();
    (*(void (**)(unint64_t))(*(_QWORD *)v3 + 16))(v3);
  }
  return *v1;
}

uint64_t SISearchCtx_METADATA::vinitContext(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5, const __CFArray *a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, const void *a11, uint64_t a12, uint64_t a13, char a14)
{
  int v20;
  unsigned int v21;
  char *v22;
  uint64_t v23;
  _QWORD *v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _QWORD *scope_node;
  _QWORD *v30;
  _QWORD *tree_apply_block_with_meta;
  _QWORD *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  const __CFString *v36;
  char *v38;
  char *v39;
  const char *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t (*v44)(uint64_t);
  void *v45;
  void *v46;

  SISearchCtx::initContext(a1, a2, a3, a4, a5, a6, a7, a8, a10, a11, a12, a13);
  v20 = *(_DWORD *)(a2 + 152);
  if ((v20 - 1) < 3 || v20 == 4 && *(_QWORD *)(a1 + 176))
  {
    v21 = currentCategoryCount(a3);
    *(_DWORD *)(a1 + 652) = v21;
    v22 = (char *)malloc_type_malloc(32 * v21 + 40, 0x2127DC5uLL);
    *(_QWORD *)(a1 + 928) = v22;
    v23 = *(unsigned int *)(a1 + 652);
    *(_OWORD *)v22 = 0u;
    *((_OWORD *)v22 + 1) = 0u;
    *((_QWORD *)v22 + 4) = 0;
    *((_DWORD *)v22 + 1) = v23;
    if ((_DWORD)v23)
    {
      v24 = v22 + 56;
      do
      {
        *(v24 - 2) = L1ComboQueueInit();
        *(v24 - 1) = L1ComboQueueInit();
        *v24 = 0;
        v24[1] = 0;
        v24 += 4;
        --v23;
      }
      while (v23);
    }
  }
  if (!*(_QWORD *)(a3 + 1184))
  {
    v38 = __si_assert_copy_extra_268();
    v39 = v38;
    v40 = "";
    if (v38)
      v40 = v38;
    __message_assert("%s:%u: failed assertion '%s' %s ", "SISearchCtx_METADATA.cpp", 5200, "db->store", v40);
    free(v39);
    if (__valid_fs(-1))
      v41 = 2989;
    else
      v41 = 3072;
    *(_DWORD *)v41 = -559038737;
    abort();
  }
  *(_BYTE *)(a1 + 644) = 1;
  *(_DWORD *)(a1 + 832) = 1;
  if (*MEMORY[0x1E0C85AD8] <= 0x2FuLL)
    ++sTotal;
  v25 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x30uLL, 0x31F9A007uLL);
  if (!v25)
    _log_fault_for_malloc_failure();
  *(_QWORD *)(a1 + 840) = v25;
  if (a5)
  {
    v26 = compileToSDBTree(a5, (uint64_t (*)(void))factorRewrite);
    setupCannedFields(v26);
    *(_QWORD *)(*(_QWORD *)(a1 + 840) + 16) = v26;
    v27 = 255;
    if (!*(_BYTE *)(a1 + 650))
      v27 = 21;
    *(_QWORD *)(a1 + 192) = v27;
    if ((*(_DWORD *)(a1 + 304) & 0x80000000) == 0)
      *(_DWORD *)(a1 + 304) = 0;
  }
  else
  {
    v28 = 255;
    if (!*(_BYTE *)(a1 + 650))
      v28 = 21;
    *(_QWORD *)(a1 + 192) = v28;
    if ((*(_DWORD *)(a1 + 304) & 0x80000000) == 0)
      *(_DWORD *)(a1 + 304) = 1;
  }
  **(_QWORD **)(a1 + 840) = compileToIndexQuery((uint64_t)a4, *(double *)(a2 + 360));
  if (a6 && (*(_QWORD *)(a3 + 6624) || (*(_BYTE *)(a3 + 6584) & 0x10) != 0))
  {
    scope_node = si_query_get_scope_node(a3, (dispatch_once_t *)a2, a6);
    if (scope_node)
    {
      v30 = scope_node;
      v42 = MEMORY[0x1E0C809B0];
      v43 = 0x40000000;
      v44 = __db_query_tree_apply_block_block_invoke;
      v45 = &unk_1E6E377F8;
      v46 = &__block_literal_global_17_10736;
      tree_apply_block_with_meta = (_QWORD *)db_query_tree_apply_block_with_meta(scope_node, (uint64_t)&v42, (uint64_t)&__block_literal_global_20_10737);
      if (*(_QWORD **)(a2 + 224) != v30)
        db_free_query_node(v30);
      _rewriteQuery(tree_apply_block_with_meta, *(double *)(a2 + 360));
      **(_QWORD **)(a1 + 840) = makeAndNode(**(_QWORD **)(a1 + 840), (uint64_t)tree_apply_block_with_meta, 1, 1);
      CFRelease(*(CFTypeRef *)(a1 + 32));
      *(_QWORD *)(a1 + 32) = 0;
    }
  }
  if (!*(_QWORD *)(*(_QWORD *)(a1 + 840) + 16))
  {
    v32 = *(_QWORD **)(a2 + 280);
    if (v32)
    {
      v42 = MEMORY[0x1E0C809B0];
      v43 = 0x40000000;
      v44 = __db_query_tree_apply_block_block_invoke;
      v45 = &unk_1E6E377F8;
      v46 = &__block_literal_global_17_10736;
      *(_QWORD *)(*(_QWORD *)(a1 + 840) + 16) = db_query_tree_apply_block_with_meta(v32, (uint64_t)&v42, (uint64_t)&__block_literal_global_20_10737);
    }
  }
  v33 = *(_QWORD *)(a3 + 1384);
  *(_QWORD *)(a1 + 584) = v33;
  if (v33)
  {
    v34 = *(unsigned int *)(v33 + 8);
    *(_QWORD *)(a1 + 560) = v34;
    *(_QWORD *)(a1 + 552) = *(int *)(a3 + 1400);
    if ((_DWORD)v34)
      goto LABEL_38;
  }
  else
  {
    *(_QWORD *)(a1 + 560) = 0;
    *(_QWORD *)(a1 + 552) = *(int *)(a3 + 1400);
  }
  v35 = *(_QWORD *)(a3 + 1392);
  *(_QWORD *)(a1 + 576) = v35;
  if (v35)
    v35 = *(unsigned int *)(v35 + 8);
  *(_QWORD *)(a1 + 568) = v35;
LABEL_38:
  if ((*(_BYTE *)(a1 + 42) & 2) != 0)
  {
    *(_BYTE *)(a1 + 649) = 1;
    v36 = *(const __CFString **)(a2 + 8);
    if (v36)
    {
      if (CFStringCompare(v36, CFSTR("*=*"), 0) == kCFCompareEqualTo)
        *(_WORD *)(a1 + 648) = 1;
    }
  }
  *(_BYTE *)(a1 + 1184) = a14;
  *(_OWORD *)(a1 + 688) = xmmword_1B8631D10;
  *(_QWORD *)(a1 + 704) = 0;
  *(_DWORD *)(a1 + 712) = 0;
  *(_QWORD *)(a1 + 720) = 4292677391;
  *(_QWORD *)(a1 + 728) = 0;
  *(_DWORD *)(a1 + 736) = 0;
  *(_QWORD *)(a1 + 744) = 4292677391;
  *(_QWORD *)(a1 + 752) = 0;
  *(_DWORD *)(a1 + 760) = 0;
  *(_QWORD *)(a1 + 768) = 4292677391;
  *(_QWORD *)(a1 + 776) = 0;
  *(_DWORD *)(a1 + 784) = 0;
  *(_QWORD *)(a1 + 792) = 4292677391;
  *(_QWORD *)(a1 + 800) = 0;
  *(_DWORD *)(a1 + 808) = 0;
  return 1;
}

uint64_t SISearchCtx_METADATA::matchingAttributeNodes(SISearchCtx_METADATA *this, uint64_t *a2)
{
  *a2 = *((_QWORD *)this + 108);
  return *((_QWORD *)this + 107);
}

uint64_t SISearchCtx_METADATA::matchingArrayIndexNodes(SISearchCtx_METADATA *this, uint64_t *a2)
{
  *a2 = *((_QWORD *)this + 110);
  return *((_QWORD *)this + 109);
}

uint64_t SISearchCtx_METADATA::computeForPhotosNodes(SISearchCtx_METADATA *this, uint64_t *a2)
{
  *a2 = *((_QWORD *)this + 112);
  return *((_QWORD *)this + 111);
}

_QWORD *L1ComboQueueInit()
{
  _QWORD *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v0 = malloc_type_calloc(1uLL, 0x18uLL, 0x20040960023A9uLL);
  v1 = operator new();
  *(_OWORD *)(v1 + 8) = xmmword_1B8631BB0;
  *(_QWORD *)v1 = 0;
  *v0 = v1;
  v2 = operator new();
  *(_OWORD *)(v2 + 8) = xmmword_1B8631BB0;
  *(_QWORD *)v2 = 0;
  v0[1] = v2;
  v3 = operator new();
  *(_OWORD *)(v3 + 8) = xmmword_1B8631BB0;
  *(_QWORD *)v3 = 0;
  v0[2] = v3;
  return v0;
}

uint64_t QueryFunctionCallbackContext_METADATA::postCheck(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v7;
  unint64_t v8;
  unsigned int v9;
  uint64_t result;
  unsigned int v11;

  v4 = *a4;
  if (*a4 == -1)
    return 2;
  if (!v4)
    return 2;
  v5 = *(_QWORD *)(v4 + 56);
  if (!v5)
    return 2;
  v7 = *(_QWORD *)(a2 + 32);
  v8 = *(_QWORD *)(v5 + 72);
  if (v8 > v7)
    return 2;
  if (v8 + *(unsigned int *)(v5 + 60) <= v7)
    return 2;
  v9 = *(_DWORD *)(a3 + 24);
  if ((ContentIndexDocSetNeedsPostcheckForDocId(*a4, v7) & 1) != 0)
    return 2;
  LODWORD(result) = ContentIndexDocSetContainsDocId(v4, *(_QWORD *)(a2 + 32));
  v11 = result ^ 1;
  if (((1 << v9) & 0x5060) == 0)
    v11 = result;
  if (v9 <= 0xE)
    return v11;
  else
    return result;
}

uint64_t QueryFunctionCallbackContext::matchPath(QueryFunctionCallbackContext *this)
{
  return 1;
}

const void *QueryFunctionCallbackContext_METADATA::gotten(uint64_t a1, void *key)
{
  const __CFDictionary *v4;
  const void *Value;
  char *v6;
  uint64_t v7;
  uint64_t v8;

  v4 = *(const __CFDictionary **)(a1 + 40);
  if (v4)
  {
    Value = CFDictionaryGetValue(v4, key);
    if (Value)
      return Value;
  }
  else
  {
    *(_QWORD *)(a1 + 40) = CFDictionaryCreateMutable((CFAllocatorRef)kCIQueryZoneAllocator, 0, 0, 0);
  }
  v6 = (char *)operator new();
  Value = v6;
  v7 = *(_QWORD *)(a1 + 8);
  v8 = *(_QWORD *)(a1 + 24);
  *((_QWORD *)v6 + 2) = v7;
  *((_QWORD *)v6 + 3) = v8;
  LOBYTE(v8) = 1;
  v6[32] = 1;
  *((_OWORD *)v6 + 3) = 0u;
  *((_OWORD *)v6 + 4) = 0u;
  *((_QWORD *)v6 + 10) = 0;
  if (v7)
    LODWORD(v8) = (*(unsigned __int8 *)(v7 + 6586) >> 1) & 1;
  v6[88] = v8;
  *(_WORD *)(v6 + 89) = 0;
  *(_QWORD *)v6 = &off_1E6E2A0F8;
  *((_QWORD *)v6 + 5) = key;
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 40), key, v6);
  return Value;
}

uint64_t QueryFunctionCallbackContext_METADATA::gotten(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_QWORD *)a3)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
  (*(void (**)(uint64_t, uint64_t))(a3 + 8))(a2, a3);
  if (*(_QWORD *)a3)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
  else
    return 0;
}

uint64_t QueryFunctionCallbackContext_METADATA::findContent(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v6;
  uint64_t v8;
  const UInt8 *v9;
  size_t v10;
  int v11;
  const __CFString *v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;

  v6 = *a4;
  if (*a4 == -1)
  {
    v11 = 0;
  }
  else if (v6)
  {
    v11 = ContentIndexDocSetContainsDocId(v6, *(_QWORD *)(a2 + 32));
  }
  else
  {
    v8 = *(_QWORD *)(a3 + 32);
    v9 = *(const UInt8 **)(a3 + 72);
    if (v9)
      v10 = strlen(*(const char **)(a3 + 72));
    else
      v10 = 0;
    v12 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v9, v10, 0x8000100u, 0);
    v13 = *(_QWORD *)(a1 + 8);
    v14 = *(_QWORD *)(a2 + 32);
    v15 = si_indexForDocId(v13, v14);
    if (!v15)
    {
      v11 = 0;
      if (!v12)
        return v11 ^ ((*(_DWORD *)(a3 + 24) - 5) < 2);
      goto LABEL_17;
    }
    v16 = (v8 >> 4) & 1;
    if ((v8 & 0x800000) != 0)
      v16 = (v8 >> 4) & 1 | ((*(_BYTE *)(a3 + 28) & 0x7F) << 18) | 0x10000;
    v17 = *(_QWORD *)(a1 + 24);
    if (v17)
      v18 = *(_QWORD *)(v17 + 144);
    else
      v18 = 0;
    v11 = ContentIndexContainsContentByDocId(v15, v14, v12, v16 | (v8 >> 4) & 2, v18, (*(_DWORD *)(v13 + 6584) >> 19) & 3, *(_BYTE *)(a1 + 32)) != 0;
    if (v12)
LABEL_17:
      CFRelease(v12);
  }
  return v11 ^ ((*(_DWORD *)(a3 + 24) - 5) < 2);
}

uint64_t QueryFunctionCallbackContext_METADATA::findPath(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v6;
  int v7;
  char *v9;
  char *v10;
  const char *v11;

  v6 = *a5;
  if (*a5 == -1)
  {
    v7 = 0;
  }
  else
  {
    if (!v6)
    {
      v9 = __si_assert_copy_extra_268();
      v10 = v9;
      if (v9)
        v11 = v9;
      else
        v11 = "";
      __message_assert("%s:%u: Unexpected code path %s ", "SISearchCtx_METADATA.cpp", 852, v11);
      free(v10);
      MEMORY[0xBAD] = -559038737;
      abort();
    }
    v7 = ContentIndexDocSetContainsDocId(v6, *(_QWORD *)(*(_QWORD *)a3 + 32));
  }
  return v7 ^ ((*(_DWORD *)(a4 + 24) - 5) < 2);
}

const void *QueryFunctionCallbackContext_METADATA::getDocSet(uint64_t a1, _QWORD *a2)
{
  if (a2[15])
    return (const void *)a2[15];
  else
    return CFDictionaryGetValue(*(CFDictionaryRef *)(*(_QWORD *)(a1 + 16) + 216), a2);
}

uint64_t deleteValue(const void *a1, const void *a2, void *a3)
{
  uint64_t result;

  if (a2)
    return (*(uint64_t (**)(const void *))(*(_QWORD *)a2 + 8))(a2);
  return result;
}

uint64_t ___ZN20SISearchCtx_METADATA7cleanUpEb_block_invoke(uint64_t a1, uint64_t a2)
{
  _BYTE *v3;
  uint64_t result;
  int v6;
  NSObject *v7;
  os_log_type_t v8;
  int v9;
  int *v10;
  _DWORD v11[2];
  __int16 v12;
  uint64_t v13;
  __int16 v14;
  uint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a2 + 48) != *(_DWORD *)(a1 + 40))
    return 1;
  v3 = (_BYTE *)(a2 + 16440);
  if (*(_BYTE *)(a2 + 16440))
    return 0;
  v6 = *__error();
  v7 = _SILogForLogForCategory(1);
  v8 = 2 * (dword_1EF19FC90 < 4);
  if (os_log_type_enabled(v7, v8))
  {
    v9 = *(_DWORD *)(a1 + 40);
    v11[0] = 67109634;
    v11[1] = v9;
    v12 = 2048;
    v13 = a2;
    v14 = 2080;
    v15 = a2 + 15168;
    _os_log_impl(&dword_1B8270000, v7, v8, "Index Should Merge id:%d %p %s", (uint8_t *)v11, 0x1Cu);
  }
  v10 = __error();
  result = 0;
  *v10 = v6;
  *v3 = 1;
  *(_BYTE *)(*(_QWORD *)(a1 + 32) + 647) = 1;
  return result;
}

uint64_t ___ZN20SISearchCtx_METADATA7cleanUpEb_block_invoke_1(uint64_t a1, uint64_t a2)
{
  _BYTE *v3;
  uint64_t result;
  int v6;
  NSObject *v7;
  os_log_type_t v8;
  int v9;
  int *v10;
  _DWORD v11[2];
  __int16 v12;
  uint64_t v13;
  __int16 v14;
  uint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a2 + 48) != *(_DWORD *)(a1 + 40))
    return 1;
  v3 = (_BYTE *)(a2 + 15166);
  if (*(_BYTE *)(a2 + 15166))
    return 0;
  v6 = *__error();
  v7 = _SILogForLogForCategory(1);
  v8 = 2 * (dword_1EF19FC90 < 4);
  if (os_log_type_enabled(v7, v8))
  {
    v9 = *(_DWORD *)(a1 + 40);
    v11[0] = 67109634;
    v11[1] = v9;
    v12 = 2048;
    v13 = a2;
    v14 = 2080;
    v15 = a2 + 15168;
    _os_log_impl(&dword_1B8270000, v7, v8, "Index Should Merge id:%d %p %s", (uint8_t *)v11, 0x1Cu);
  }
  v10 = __error();
  result = 0;
  *v10 = v6;
  *v3 = 1;
  *(_BYTE *)(*(_QWORD *)(a1 + 32) + 646) = 1;
  return result;
}

uint64_t ___ZN20SISearchCtx_METADATA7cleanUpEb_block_invoke_3(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  if (*(_DWORD *)(a2 + 48) != *(_DWORD *)(a1 + 40))
    return 1;
  if (!*(_BYTE *)(a2 + 16440))
    return 0;
  result = 0;
  *(_BYTE *)(*(_QWORD *)(a1 + 32) + 647) = 1;
  return result;
}

uint64_t SISearchCtx_METADATA::addMatchingAttributeNodes(SISearchCtx_METADATA *this, CFArrayRef theArray, const int *a3, uint64_t *a4, char a5)
{
  unint64_t Count;
  unint64_t v11;
  void *v12;
  CFMutableSetRef Mutable;
  _QWORD *v14;
  const void *v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD v19[12];
  char v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  _QWORD v29[3];
  uint64_t v30;
  uint64_t v31;
  uint64_t *v32;
  uint64_t v33;
  uint64_t v34;
  _QWORD v35[5];

  Count = CFArrayGetCount(theArray);
  v31 = 0;
  v32 = &v31;
  v33 = 0x2000000000;
  v34 = 0;
  v29[0] = 0;
  v29[1] = v29;
  v29[2] = 0x2000000000;
  v30 = 0;
  v25 = 0;
  v26 = &v25;
  v27 = 0x2000000000;
  v28 = 0;
  if (Count)
  {
    v11 = Count;
    v30 = 2 * Count;
    if (((Count >> 13) & 0x7FFFFFFFFFFFLL) == 0 && 16 * Count > *MEMORY[0x1E0C85AD8])
      ++sTotal;
    v12 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 2 * Count, 8uLL, 0x31F9A007uLL);
    if (!v12)
      _log_fault_for_malloc_failure();
    v26[3] = (uint64_t)v12;
    Mutable = CFSetCreateMutable((CFAllocatorRef)kCIQueryZoneAllocator, 0, &dbqpSetCallbacks);
    v21 = 0;
    v22 = &v21;
    v23 = 0x2000000000;
    v24 = 0;
    v14 = (_QWORD *)**((_QWORD **)this + 105);
    v19[0] = MEMORY[0x1E0C809B0];
    v19[1] = 0x40000000;
    v19[2] = ___ZN20SISearchCtx_METADATA25addMatchingAttributeNodesEPK9__CFArrayPKiPlb_block_invoke;
    v19[3] = &unk_1E6E2FDB0;
    v20 = a5;
    v19[4] = &v31;
    v19[5] = v29;
    v19[8] = Mutable;
    v19[9] = v11;
    v19[10] = theArray;
    v19[11] = a3;
    v19[6] = &v25;
    v19[7] = &v21;
    v35[0] = MEMORY[0x1E0C809B0];
    v35[1] = 0x40000000;
    v35[2] = __db_query_tree_apply_block_block_invoke;
    v35[3] = &unk_1E6E377F8;
    v35[4] = v19;
    db_query_tree_apply_block_with_meta(v14, (uint64_t)v35, 0);
    v15 = (const void *)v22[3];
    if (v15)
      CFRelease(v15);
    CFRelease(Mutable);
    _Block_object_dispose(&v21, 8);
    v16 = v32[3];
    v17 = v26[3];
  }
  else
  {
    v17 = 0;
    v16 = 0;
  }
  *a4 = v16;
  _Block_object_dispose(&v25, 8);
  _Block_object_dispose(v29, 8);
  _Block_object_dispose(&v31, 8);
  return v17;
}

void cleanUp(SISearchCtx_METADATA *a1)
{
  unint64_t v2;
  uint64_t v3;
  unint64_t i;
  uint64_t v5;

  SISearchCtx_METADATA::cleanUp(a1, 0);
  v2 = *((unsigned int *)a1 + 208);
  if ((_DWORD)v2)
  {
    v3 = 0;
    for (i = 0; i < v2; ++i)
    {
      v5 = *(_QWORD *)(*((_QWORD *)a1 + 105) + v3);
      if (v5)
      {
        clear_node_caches(v5);
        v2 = *((unsigned int *)a1 + 208);
      }
      v3 += 48;
    }
  }
}

CFArrayRef ___ZN20SISearchCtx_METADATA10preIterateEv_block_invoke()
{
  CFArrayRef result;
  __int128 v1;
  const __CFString *v2;
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  v1 = xmmword_1E6E2FE10;
  v2 = CFSTR("kMDItemPhotosPeopleNamesAlternatives");
  result = CFArrayCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)&v1, 3, MEMORY[0x1E0C9B378]);
  SISearchCtx_METADATA::preIterate(void)::sAttributesToConsider = (uint64_t)result;
  return result;
}

uint64_t ___ZN20SISearchCtx_METADATA25addMatchingAttributeNodesEPK9__CFArrayPKiPlb_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t tree_apply_block_with_meta;
  uint64_t v6;
  _QWORD *v7;
  CFIndex v8;
  uint64_t v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  void **v13;
  char *v14;
  char **v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const void **v21;
  const __CFDictionary *v22;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  CFIndex v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t (*v39)(uint64_t);
  void *v40;
  void *v41;
  char __s1[1024];
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  bzero(__s1, 0x400uLL);
  if ((query_node_is_double_star(a2) & 1) != 0 || isQueryNodeMatchingAnyField(a2))
  {
    if (*(_BYTE *)(a1 + 96))
    {
      v4 = MEMORY[0x1E0C809B0];
      v37 = MEMORY[0x1E0C809B0];
      v38 = 0x40000000;
      v39 = __db_query_tree_apply_block_block_invoke;
      v40 = &unk_1E6E377F8;
      v41 = &__block_literal_global_17_10736;
      tree_apply_block_with_meta = db_query_tree_apply_block_with_meta((_QWORD *)a2, (uint64_t)&v37, (uint64_t)&__block_literal_global_20_10737);
      v6 = tree_apply_block_with_meta;
      if (tree_apply_block_with_meta)
      {
        v7 = *(_QWORD **)(tree_apply_block_with_meta + 16);
        if (v7)
        {
          if (*v7)
          {
            if (CFSetContainsValue(*(CFSetRef *)(a1 + 64), v7))
            {
LABEL_8:
              v37 = v4;
              v38 = 0x40000000;
              v39 = __db_query_tree_apply_block_block_invoke;
              v40 = &unk_1E6E377F8;
              v41 = &__block_literal_global_143;
              db_query_tree_apply_block_with_meta((_QWORD *)v6, (uint64_t)&v37, 0);
              return a2;
            }
            v31 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
            v32 = *(_QWORD *)(v31 + 24);
            v33 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
            if (v32 == *(_QWORD *)(v33 + 24))
            {
              *(_QWORD *)(v33 + 24) = 2 * v32;
              *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) = malloc_type_realloc(*(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8)+ 24), 8* *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8)+ 24), 0x2004093837F09uLL);
              v31 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
              v32 = *(_QWORD *)(v31 + 24);
            }
            v34 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24);
            *(_QWORD *)(v31 + 24) = v32 + 1;
            *(_QWORD *)(v34 + 8 * v32) = v6;
LABEL_52:
            CFSetAddValue(*(CFMutableSetRef *)(a1 + 64), *(const void **)(v6 + 16));
            return a2;
          }
        }
      }
      goto LABEL_47;
    }
    if (*(uint64_t *)(a1 + 72) < 1)
      return a2;
    v8 = 0;
    v9 = MEMORY[0x1E0C809B0];
    while (!cStringFromCFStringArray(*(const __CFArray **)(a1 + 80), v8, __s1))
    {
LABEL_25:
      if (++v8 >= *(_QWORD *)(a1 + 72))
        return a2;
    }
    if (a2)
    {
      if (*(_WORD *)(a2 + 40) == 4)
      {
        v10 = *(_QWORD **)(a2 + 16);
        if (v10)
        {
          if (*v10)
          {
            v37 = v9;
            v38 = 0x40000000;
            v39 = __db_query_tree_apply_block_block_invoke;
            v40 = &unk_1E6E377F8;
            v41 = &__block_literal_global_17_10736;
            v11 = (_QWORD *)db_query_tree_apply_block_with_meta((_QWORD *)a2, (uint64_t)&v37, (uint64_t)&__block_literal_global_20_10737);
            v12 = v11;
            if (!v11)
            {
LABEL_24:
              db_free_query_node(v12);
              goto LABEL_25;
            }
            v13 = (void **)v11[2];
            if (v13 && *v13)
            {
              free(*v13);
              v14 = strdup(__s1);
              v15 = (char **)v12[2];
              *v15 = v14;
              if (v14)
              {
                if (CFSetContainsValue(*(CFSetRef *)(a1 + 64), v15))
                {
                  v37 = v9;
                  v38 = 0x40000000;
                  v39 = __db_query_tree_apply_block_block_invoke;
                  v40 = &unk_1E6E377F8;
                  v41 = &__block_literal_global_143;
                  db_query_tree_apply_block_with_meta(v12, (uint64_t)&v37, 0);
                }
                else
                {
                  v16 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
                  v17 = *(_QWORD *)(v16 + 24);
                  v18 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
                  if (v17 == *(_QWORD *)(v18 + 24))
                  {
                    *(_QWORD *)(v18 + 24) = 2 * v17;
                    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) = malloc_type_realloc(*(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8)+ 24), 8* *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8)+ 24), 0x2004093837F09uLL);
                    v16 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
                    v17 = *(_QWORD *)(v16 + 24);
                  }
                  v19 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24);
                  *(_QWORD *)(v16 + 24) = v17 + 1;
                  *(_QWORD *)(v19 + 8 * v17) = v12;
                  CFSetAddValue(*(CFMutableSetRef *)(a1 + 64), (const void *)v12[2]);
                  v20 = *(_QWORD *)(a1 + 88);
                  if (v20)
                    LODWORD(v20) = *(_DWORD *)(v20 + 4 * v8);
                  *(_DWORD *)(v12[2] + 80) = v20;
                }
                goto LABEL_25;
              }
              goto LABEL_24;
            }
            v37 = v9;
            v38 = 0x40000000;
            v39 = __db_query_tree_apply_block_block_invoke;
            v40 = &unk_1E6E377F8;
            v41 = &__block_literal_global_143;
            db_query_tree_apply_block_with_meta(v11, (uint64_t)&v37, 0);
          }
        }
      }
    }
    v12 = 0;
    goto LABEL_24;
  }
  if (a2)
  {
    if (*(_WORD *)(a2 + 40) == 4)
    {
      v21 = *(const void ***)(a2 + 16);
      if (v21)
      {
        if (*v21)
        {
          v22 = *(const __CFDictionary **)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24);
          if (v22)
            goto LABEL_66;
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24) = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, &kCStringDictionaryKeyCallBacks, &kIntDictionaryValueCallBacks);
          if (*(uint64_t *)(a1 + 72) >= 1)
          {
            v35 = 0;
            do
            {
              if (cStringFromCFStringArray(*(const __CFArray **)(a1 + 80), v35, __s1))
              {
                v36 = *(_QWORD *)(a1 + 88);
                if (v36)
                  LODWORD(v36) = *(_DWORD *)(v36 + 4 * v35);
                CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24), __s1, (const void *)(int)v36);
              }
              ++v35;
            }
            while (v35 < *(_QWORD *)(a1 + 72));
          }
          v22 = *(const __CFDictionary **)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24);
          if (v22)
          {
            if (*(_WORD *)(a2 + 40) == 4)
            {
              v21 = *(const void ***)(a2 + 16);
              if (v21)
              {
LABEL_66:
                if (*v21 && CFDictionaryContainsKey(v22, *v21) && **(_QWORD **)(a2 + 16))
                {
                  v4 = MEMORY[0x1E0C809B0];
                  v37 = MEMORY[0x1E0C809B0];
                  v38 = 0x40000000;
                  v39 = __db_query_tree_apply_block_block_invoke;
                  v40 = &unk_1E6E377F8;
                  v41 = &__block_literal_global_17_10736;
                  v23 = db_query_tree_apply_block_with_meta((_QWORD *)a2, (uint64_t)&v37, (uint64_t)&__block_literal_global_20_10737);
                  v6 = v23;
                  if (v23)
                  {
                    v24 = *(_QWORD **)(v23 + 16);
                    if (v24)
                    {
                      if (*v24)
                      {
                        if (CFSetContainsValue(*(CFSetRef *)(a1 + 64), v24))
                          goto LABEL_8;
                        v25 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
                        v26 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
                        if (v25 == *(_QWORD *)(v26 + 24))
                        {
                          *(_QWORD *)(v26 + 24) = 2 * v25;
                          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) = malloc_type_realloc(*(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24), 8* *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24), 0x2004093837F09uLL);
                        }
                        *(_DWORD *)(*(_QWORD *)(v6 + 16) + 80) = CFDictionaryGetValue(*(CFDictionaryRef *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24), **(const void ***)(v6 + 16));
                        v27 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24);
                        v28 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
                        v29 = *(_QWORD *)(v28 + 24);
                        *(_QWORD *)(v28 + 24) = v29 + 1;
                        *(_QWORD *)(v27 + 8 * v29) = v6;
                        goto LABEL_52;
                      }
                    }
                  }
LABEL_47:
                  db_free_query_node((_QWORD *)v6);
                }
              }
            }
          }
        }
      }
    }
  }
  return a2;
}

BOOL cStringFromCFStringArray(const __CFArray *a1, CFIndex a2, char *a3)
{
  const __CFString *ValueAtIndex;
  CFTypeID v5;

  ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a1, a2);
  v5 = CFGetTypeID(ValueAtIndex);
  return v5 == CFStringGetTypeID() && CFStringGetCString(ValueAtIndex, a3, 1024, 0x8000100u) != 0;
}

uint64_t ___ZL11emitResultsP20SISearchCtx_METADATAP19PartialQueryResultsb_block_invoke(uint64_t a1, uint64_t a2)
{
  const void *v3;
  _DWORD *Value;
  int8x8_t v5;
  _DWORD *v6;
  int v7;
  _DWORD **v8;
  uint64_t v9;

  v3 = *(const void **)(a2 + 16);
  if (v3)
  {
    Value = CFDictionaryGetValue(*(CFDictionaryRef *)(*(_QWORD *)(a1 + 32) + 216), v3);
    if (Value)
    {
      v6 = Value;
      v7 = Value[12];
      LODWORD(Value) = 0;
      switch(v7)
      {
        case 0:
        case 2:
          break;
        case 1:
          LODWORD(Value) = *(_DWORD *)(*((_QWORD *)v6 + 7) + 60);
          break;
        case 3:
        case 8:
          v9 = *((_QWORD *)v6 + 8);
          if (v9)
          {
            v8 = (_DWORD **)(v9 + 88);
LABEL_7:
            Value = *v8;
            if (*v8)
              LODWORD(Value) = lockedCountItemsInRange(Value, Value[5], Value[6], v5);
          }
          else
          {
            LODWORD(Value) = 0;
          }
          break;
        case 4:
        case 5:
        case 6:
        case 7:
        case 9:
          v8 = (_DWORD **)(v6 + 20);
          goto LABEL_7;
        default:
          assert_invalid_doc_type(v6);
      }
    }
    *(_QWORD *)(*(_QWORD *)(a2 + 16) + 152) += Value;
  }
  return a2;
}

uint64_t ___ZL11emitResultsP20SISearchCtx_METADATAP19PartialQueryResultsb_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = a2;
  if (*(_QWORD *)(a2 + 16))
  {
    malloc_size(**(const void ***)(a1 + 32));
    _db_render_query_tree((uint64_t)&v3);
    _MDPlistContainerAddCString();
    _MDPlistContainerAddInt64Value();
    return v3;
  }
  return a2;
}

uint64_t SISearchCtx_METADATA::updateGroupingCount(SISearchCtx_METADATA *this)
{
  int v2;
  uint64_t v3;
  uint64_t result;
  unsigned int *v5;
  unsigned int *v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int *v9;
  unint64_t v10;
  unsigned int *Info;
  int v12;
  unsigned int v13;
  uint64_t v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int *v17;

  v2 = currentCategoryCount(*((_QWORD *)this + 3));
  v3 = (*((_DWORD *)this + 275) + v2);
  result = *((unsigned int *)this + 163);
  if (v3 > result)
  {
    v5 = (unsigned int *)*((_QWORD *)this + 116);
    if (v5 && v5[1] < v3)
    {
      v6 = (unsigned int *)malloc_type_realloc(*((void **)this + 116), 32 * (*((_DWORD *)this + 275) + v2) + 40, 0x90F2FCCCuLL);
      v5 = v6;
      v7 = v6[1];
      if (v7 < v3)
      {
        v8 = v3 - v7;
        v9 = &v6[8 * v7 + 14];
        do
        {
          *((_QWORD *)v9 - 2) = L1ComboQueueInit();
          *((_QWORD *)v9 - 1) = L1ComboQueueInit();
          *(_QWORD *)v9 = 0;
          *((_QWORD *)v9 + 1) = 0;
          v9 += 8;
          --v8;
        }
        while (v8);
      }
      v5[1] = v3;
    }
    *((_QWORD *)this + 116) = v5;
    v10 = *((_QWORD *)this + 22);
    if (v10 || (v10 = *((_QWORD *)this + 23)) != 0)
    {
      if (v10 <= *((_QWORD *)this + 21))
        v10 = *((_QWORD *)this + 21);
      v10 = v10;
    }
    Info = (unsigned int *)*((_QWORD *)this + 139);
    v12 = *((_DWORD *)this + 275);
    v13 = v12 + v2;
    if ((*((_DWORD *)this + 40) & 0xFFFFFFFD) == 1)
      v14 = 0;
    else
      v14 = v10;
    if (Info)
    {
      if (*Info < v13)
      {
        Info = (unsigned int *)malloc_type_zone_realloc((malloc_zone_t *)queryZone, *((void **)this + 139), 40 * v13 + 8, 0xECA6AA46uLL);
        if (!Info)
          _log_fault_for_malloc_failure();
        v15 = *Info;
        if (*Info < v13)
        {
          v16 = v2 + v12 - v15;
          v17 = &Info[10 * v15 + 8];
          do
          {
            pqinit_rankAndFetchInfo_t((_QWORD *)v17 - 3, v14);
            *(_QWORD *)v17 = 0;
            *((_QWORD *)v17 + 1) = 0;
            v17 += 10;
            --v16;
          }
          while (v16);
        }
        *Info = v13;
      }
    }
    else
    {
      Info = createFetchInfo(v12 + v2, v14);
    }
    *((_QWORD *)this + 139) = Info;
    result = (*((_DWORD *)this + 275) + v2);
    *((_DWORD *)this + 163) = result;
  }
  return result;
}

void readSDBForOids(SISearchCtx_METADATA *a1, uint64_t a2, uint64_t a3, uint64_t a4, int *a5, unsigned int *a6, size_t a7, _BYTE *a8, PartialQueryResults *a9, uint64_t a10, unsigned __int8 a11)
{
  uint64_t v15;
  _DWORD *v16;
  int v17;
  NSObject *v18;
  qos_class_t v19;
  dispatch_queue_t current_queue;
  uint64_t v21;
  const char *v22;
  NSObject *v23;
  uint32_t v24;
  SISearchCtx_METADATA *v25;
  uint64_t v26;
  const __CFString *v27;
  unsigned int v28;
  PartialQueryResults *v29;
  _BOOL4 v30;
  _BOOL4 v31;
  int v32;
  __CFString *v33;
  double Current;
  int v35;
  SISearchCtx_METADATA *v36;
  uint64_t v37;
  unsigned int v38;
  BOOL v39;
  int v40;
  BOOL v41;
  unsigned int updated;
  _BYTE *v43;
  unint64_t v44;
  _QWORD *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  _DWORD *v49;
  uint64_t v50;
  uint64_t v51;
  size_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  _OWORD *v56;
  SISearchCtx_METADATA *v57;
  unint64_t v58;
  int *v59;
  _QWORD *v60;
  os_unfair_lock_s *v61;
  _BYTE *v62;
  _QWORD *v63;
  _QWORD *v64;
  SISearchCtx_METADATA *v65;
  SISearchCtx_METADATA *v66;
  uint64_t v67;
  uint64_t v68;
  _OWORD *v69;
  uint64_t *v70;
  uint64_t *v71;
  uint64_t v72;
  uint64_t v73;
  __int128 *v74;
  __int128 v75;
  __int128 v76;
  uint64_t v77;
  __int128 *v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  uint64_t v82;
  __int128 *v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  _BYTE *v94;
  _BYTE *v95;
  unsigned int v96;
  os_unfair_lock_s *v97;
  _BYTE *v98;
  uint64_t v99;
  _QWORD *v100;
  _BYTE *v101;
  _QWORD *v102;
  SISearchCtx_METADATA *v103;
  SISearchCtx_METADATA *v104;
  uint64_t v105;
  uint64_t *v106;
  _OWORD *v107;
  uint64_t *v108;
  uint64_t v109;
  uint64_t v110;
  __int128 *v111;
  __int128 v112;
  __int128 v113;
  uint64_t v114;
  __int128 *v115;
  __int128 v116;
  __int128 v117;
  __int128 v118;
  uint64_t v119;
  __int128 *v120;
  __int128 v121;
  __int128 v122;
  __int128 v123;
  __int128 v124;
  __int128 v125;
  __int128 v126;
  __int128 v127;
  __int128 v128;
  __int128 v129;
  __int128 v130;
  _QWORD *v131;
  __int128 v132;
  __int128 v133;
  __int128 v134;
  __int128 v135;
  __int128 v136;
  __int128 v137;
  __int128 v138;
  __int128 v139;
  __int128 v140;
  __int128 v141;
  __int128 v142;
  __int128 v143;
  __int128 v144;
  __int128 v145;
  __int128 v146;
  __int128 *v147;
  int *v148;
  uint64_t v149;
  _BYTE *v150;
  BOOL v151;
  BOOL v152;
  BOOL v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  double v158;
  NSObject *Log;
  SISearchCtx_METADATA *v160;
  os_signpost_id_t v161;
  PartialQueryResults *v162;
  uint64_t v163;
  BOOL v164;
  uint64_t v165;
  char v166;
  char v167;
  char v168;
  int v169;
  uint64_t v170;
  uint64_t v171;
  const __CFArray *v172;
  uint64_t v173;
  const __CFArray *v174;
  NSObject *v175;
  _BOOL4 v176;
  uint64_t v177;
  qos_class_t v178;
  int v179;
  int v180;
  uint64_t v181;
  _DWORD *Info;
  uint64_t Mutable;
  char *v184;
  unsigned __int16 *v185;
  _BYTE *v186;
  size_t v187;
  unint64_t *v188;
  uint64_t v189;
  unint64_t v190;
  char v191;
  unsigned int v192;
  __int16 v193;
  unsigned __int16 v194;
  uint64_t v195;
  uint64_t v196;
  unint64_t v197;
  unint64_t v198;
  unint64_t v199;
  uint64_t v200;
  unint64_t v201;
  int v202;
  unint64_t v203;
  unint64_t v204;
  BOOL v205;
  int v206;
  int v207;
  int v208;
  char v209;
  unint64_t v210;
  unint64_t v211;
  os_unfair_lock_s *v212;
  unint64_t v213;
  char *v214;
  unsigned __int16 *v215;
  unint64_t *v216;
  uint64_t v217;
  unint64_t v218;
  char v219;
  unsigned int v220;
  __int16 v221;
  unsigned __int16 v222;
  uint64_t v223;
  uint64_t v224;
  unint64_t v225;
  unint64_t v226;
  unint64_t v227;
  uint64_t v228;
  unint64_t v229;
  int v230;
  unint64_t v231;
  unint64_t v232;
  BOOL v233;
  int v234;
  int v235;
  int v236;
  char v237;
  unint64_t v238;
  unint64_t v239;
  os_unfair_lock_s *v240;
  unint64_t v241;
  uint64_t v242;
  unint64_t v243;
  os_unfair_lock_s *v244;
  unint64_t v245;
  SISearchCtx_METADATA *v246;
  uint64_t **v247;
  uint64_t v248;
  __int128 *v249;
  __int128 v250;
  __int128 v251;
  uint64_t v252;
  __int128 *v253;
  __int128 *v254;
  uint64_t v255;
  __int128 *v256;
  __int128 *v257;
  __int128 v258;
  char *v259;
  __int128 v260;
  __int128 v261;
  __int128 v262;
  __int128 v263;
  __int128 v264;
  __int128 v265;
  uint64_t v266;
  _QWORD *v267;
  uint64_t v268;
  _DWORD **v269;
  _DWORD **v270;
  __int128 *v271;
  unint64_t v272;
  unint64_t v273;
  float v274;
  float v275;
  char *v276;
  unsigned int v277;
  float v278;
  unsigned int v279;
  float v280;
  float v281;
  unint64_t v282;
  unint64_t v283;
  char *v284;
  _DWORD *v287;
  _DWORD *v288;
  uint64_t v289;
  uint64_t v290;
  uint64_t *v291;
  _BYTE *v292;
  _BYTE *v293;
  int *v294;
  unsigned __int16 *v295;
  unint64_t *v296;
  unsigned int *v297;
  int *v298;
  int *v299;
  unsigned int *v300;
  unsigned int v301;
  __int16 v302;
  unsigned __int16 v303;
  uint64_t v304;
  int v305;
  uint64_t v306;
  _OWORD *v307;
  __int128 v308;
  __int128 v309;
  __int128 v310;
  uint64_t v311;
  int v312;
  uint64_t v313;
  uint64_t v314;
  unint64_t v315;
  unint64_t v316;
  uint64_t v317;
  uint64_t v318;
  unint64_t v319;
  int v320;
  unint64_t v321;
  uint64_t v322;
  uint64_t v323;
  int v324;
  float v325;
  float v326;
  int v327;
  float v328;
  unsigned int v329;
  uint64_t v330;
  uint64_t v331;
  unint64_t v332;
  unsigned int v333;
  unint64_t v334;
  uint64_t v335;
  uint64_t v336;
  uint64_t v337;
  _WORD *v338;
  _BYTE *v339;
  uint64_t *v340;
  unint64_t v341;
  unint64_t *v342;
  unint64_t v343;
  char *v344;
  char *v345;
  char *v346;
  char *v347;
  unsigned int v348;
  float v349;
  float v350;
  unint64_t v351;
  unint64_t v352;
  char *v353;
  uint64_t v355;
  __int128 *v356;
  uint64_t v357;
  __int128 *v358;
  _DWORD *v359;
  _BYTE *v360;
  _QWORD *v361;
  uint64_t *v362;
  _QWORD *v363;
  __int128 *v364;
  unsigned int v365;
  float v366;
  float v367;
  BOOL v368;
  unint64_t v369;
  unint64_t v370;
  __int128 *v371;
  unint64_t v372;
  uint64_t v373;
  _QWORD *v374;
  _BYTE *v375;
  _WORD *v376;
  _QWORD *v377;
  uint64_t *v378;
  uint64_t v379;
  uint64_t v380;
  _DWORD *v381;
  _QWORD *v382;
  _DWORD *v383;
  uint64_t v384;
  uint64_t v385;
  uint64_t v386;
  _DWORD *v387;
  _QWORD *v388;
  _BYTE *v389;
  _WORD *v390;
  _QWORD *v391;
  uint64_t *v392;
  unint64_t v393;
  unint64_t v394;
  uint64_t v395;
  _DWORD *v396;
  _QWORD *v397;
  _BYTE *v398;
  int v399;
  _QWORD *v400;
  unint64_t v401;
  uint64_t *v402;
  int v403;
  int v404;
  NSObject *v405;
  uint64_t v406;
  uint64_t v407;
  const __CFArray *v408;
  uint64_t v409;
  const __CFArray *v410;
  SISearchCtx_METADATA *v411;
  unsigned int v412;
  _WORD *v413;
  int v414;
  uint64_t v415;
  SISearchCtx_METADATA *v416;
  uint64_t v417;
  uint64_t v418;
  void *v419;
  uint64_t v420;
  size_t v421;
  void *v422;
  size_t v423;
  const void *v424;
  const void *v425;
  uint64_t v426;
  uint64_t v427;
  _BYTE *v428;
  int *v429;
  uint64_t v430;
  uint64_t v431;
  uint64_t v432;
  uint64_t v433;
  _QWORD *v434;
  char v435;
  uint64_t v436;
  uint64_t *v437;
  uint64_t v438;
  uint64_t v439;
  uint64_t v440;
  uint64_t v441;
  uint64_t v442;
  _QWORD *v443;
  uint64_t v444;
  uint64_t *v445;
  uint64_t v446;
  unsigned int v447;
  unint64_t v448;
  SISearchCtx_METADATA *v449;
  unint64_t v450;
  size_t v451;
  char *v452;
  uint64_t v453;
  double v454;
  double v455;
  __n128 v456;
  int v457;
  NSObject *v458;
  os_log_type_t v459;
  CFAbsoluteTime v460;
  SISearchCtx_METADATA *v461;
  uint64_t v462;
  unint64_t v463;
  uint64_t v464;
  _QWORD *v465;
  _QWORD *v466;
  _QWORD *v467;
  _QWORD *v468;
  unsigned int v469;
  _BOOL4 v470;
  int v472;
  uint64_t v473;
  uint64_t *v474;
  uint64_t v475;
  uint64_t v476;
  double v477;
  uint64_t v478;
  uint64_t v479;
  uint64_t v480;
  const __CFArray *v481;
  uint64_t v482;
  uint64_t v483;
  _QWORD *v484;
  uint64_t v485;
  uint64_t *v486;
  uint64_t v487;
  const __CFArray *v488;
  char *v489;
  uint64_t v490;
  uint64_t v491;
  uint64_t v492;
  uint64_t v493;
  uint64_t v494;
  uint64_t v495;
  uint64_t v496;
  uint64_t v497;
  _QWORD *v498;
  uint64_t v499;
  const __CFArray *v500;
  const __CFArray *v501;
  char *v502;
  uint64_t v503;
  uint64_t v504;
  uint64_t v505;
  uint64_t v506;
  uint64_t v507;
  uint64_t v508;
  uint64_t v509;
  _QWORD *v510;
  int v511;
  size_t v512;
  uint64_t v513;
  uint64_t *v514;
  uint64_t v515;
  uint64_t v516;
  uint64_t *v517;
  uint64_t v518;
  char *v519;
  SISearchCtx_METADATA *v520;
  unint64_t v521;
  int v522;
  uint64_t v523;
  uint64_t v524;
  uint64_t v525;
  uint64_t v526;
  uint64_t v527;
  uint64_t v528;
  char v529;
  unsigned __int16 v530;
  uint64_t v531;
  char v532;
  uint64_t v533;
  uint64_t v534;
  uint64_t v535;
  uint64_t v536;
  int v537;
  char v538;
  uint64_t v539;
  _QWORD *v540;
  unint64_t v541;
  int v542;
  NSObject *v543;
  os_log_type_t v544;
  CFAbsoluteTime v545;
  _DWORD *v546;
  uint64_t v547;
  SISearchCtx_METADATA *v548;
  uint64_t v549;
  uint64_t v550;
  void *v551;
  NSObject *v552;
  SISearchCtx_METADATA *v553;
  os_signpost_id_t v554;
  int *v555;
  NSObject *v556;
  uint64_t v557;
  qos_class_t v558;
  int v559;
  NSObject *v560;
  uint64_t v561;
  int v562;
  NSObject *v563;
  NSObject *v564;
  char *v565;
  const char *v566;
  uint64_t v567;
  NSObject *v568;
  int v569;
  NSObject *v570;
  char *v571;
  char *v572;
  const char *v573;
  char *v574;
  const char *v575;
  char *v576;
  const char *v577;
  unint64_t v578;
  _BYTE *v579;
  _QWORD *v580;
  uint64_t *v581;
  _BYTE *v582;
  _QWORD *v583;
  uint64_t *v584;
  _BYTE *v585;
  _BYTE *v586;
  _QWORD *v587;
  _QWORD *v588;
  uint64_t *v589;
  _BYTE *v590;
  _BYTE *v591;
  _QWORD *v592;
  _QWORD *v593;
  uint64_t *v594;
  _BYTE *v595;
  _DWORD *v596;
  pthread_rwlock_t *v597;
  __int128 *v598;
  __int128 *v599;
  uint64_t v600;
  uint64_t v601;
  char *v602;
  int v603;
  int v604;
  uint64_t v605;
  uint64_t v606;
  uint64_t v607;
  uint64_t v608;
  int v609;
  _BOOL4 v610;
  _BOOL4 v611;
  uint64_t *v612;
  int *v613;
  unsigned int *v614;
  uint64_t v615;
  unint64_t v616;
  int v617;
  unint64_t *v618;
  unint64_t v619;
  _BYTE *v620;
  uint64_t *v621;
  unsigned int v622;
  uint64_t v623;
  _BYTE *v624;
  uint64_t v625;
  PartialQueryResults *v626;
  char *v627;
  char *v628;
  unsigned __int16 *v629;
  __int128 v630;
  __int128 v631;
  __int128 v632;
  __int128 v633;
  __int128 v634;
  __int128 v635;
  __int128 v636;
  __int128 v637;
  __int128 v638;
  __int128 v639;
  __int128 v640;
  __int128 v641;
  __int128 v642;
  __int128 v643;
  __int128 v644;
  size_t v645;
  unint64_t v646;
  _QWORD v647[27];
  unsigned int v648;
  int v649;
  int v650;
  char v651;
  char v652;
  char v653;
  _QWORD v654[9];
  BOOL v655;
  _QWORD v656[10];
  unsigned int v657;
  _QWORD v658[6];
  unsigned int v659;
  float v660;
  int v661;
  float v662;
  float v663;
  char v664;
  char v665;
  _BYTE v666[18];
  uint64_t v667;
  _BYTE v668[13];
  _BYTE v669[19];
  uint64_t v670;
  _QWORD v671[6];
  int v672;
  float v673;
  int v674;
  float v675;
  float v676;
  char v677;
  char v678;
  _BYTE v679[18];
  uint64_t v680;
  _BYTE v681[13];
  _BYTE v682[19];
  uint64_t v683;
  _QWORD v684[6];
  int v685;
  float v686;
  int v687;
  float v688;
  float v689;
  char v690;
  char v691;
  _BYTE v692[18];
  uint64_t v693;
  _BYTE v694[13];
  _BYTE v695[19];
  uint64_t v696;
  _QWORD v697[6];
  unsigned int v698;
  float v699;
  int v700;
  float v701;
  float v702;
  char v703;
  char v704;
  _BYTE v705[18];
  uint64_t v706;
  _BYTE v707[13];
  _BYTE v708[19];
  uint64_t v709;
  __int16 v710;
  char v711;
  int v712;
  char v713;
  _OWORD v714[9];
  unint64_t v715[6];
  int v716;
  int v717;
  int v718;
  uint64_t v719;
  char v720;
  char v721;
  uint64_t v722;
  __int16 v723;
  unint64_t v724[6];
  int v725;
  int v726;
  int v727;
  uint64_t v728;
  char v729;
  char v730;
  uint64_t v731;
  __int16 v732;
  uint64_t v733;
  OSQueueHead v734;
  SISearchCtx_METADATA *v735;
  _QWORD v736[6];
  int v737;
  float v738;
  int v739;
  float v740;
  float v741;
  char v742;
  char v743;
  _BYTE v744[18];
  uint64_t v745;
  _BYTE v746[13];
  _BYTE v747[19];
  uint64_t v748;
  uint64_t v749;
  __int16 v750;
  _OWORD v751[5];
  uint64_t v752;
  uint64_t v753;
  _BYTE v754[13];
  _BYTE v755[35];
  _OWORD v756[3];
  __int128 v757;
  __int128 v758;
  __int128 v759;
  _OWORD v760[2];
  __int128 v761;
  __int128 v762;
  __int128 v763;
  __int128 v764;
  __int128 v765;
  __int128 v766;
  __int128 v767;
  __int128 v768;
  uint64_t (*v769)(uint64_t, uint64_t);
  void *v770;
  SISearchCtx_METADATA **v771;
  uint64_t v772;

  v613 = a5;
  v614 = a6;
  v629 = (unsigned __int16 *)a3;
  v618 = (unint64_t *)a2;
  v772 = *MEMORY[0x1E0C80C00];
  v735 = a1;
  v15 = *((_QWORD *)a1 + 1);
  v16 = &unk_1EF19F000;
  if (v15 && *(_QWORD *)(v15 + 8))
  {
    if (dword_1EF19FC90 < 5)
      goto LABEL_7;
    v17 = *__error();
    v18 = _SILogForLogForCategory(1);
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      goto LABEL_578;
    v19 = qos_class_self();
    current_queue = dispatch_get_current_queue();
    v21 = *(_QWORD *)(*((_QWORD *)a1 + 1) + 8);
    LODWORD(v756[0]) = 134218754;
    *(_QWORD *)((char *)v756 + 4) = a1;
    WORD6(v756[0]) = 1024;
    *(_DWORD *)((char *)v756 + 14) = v19;
    v16 = (_DWORD *)&unk_1EF19F000;
    WORD1(v756[1]) = 2112;
    *(_QWORD *)((char *)&v756[1] + 4) = current_queue;
    WORD6(v756[1]) = 2112;
    *(_QWORD *)((char *)&v756[1] + 14) = v21;
    v22 = "readSDBForOids %p QoS %d queue %@ query %@";
    v23 = v18;
    v24 = 38;
    goto LABEL_577;
  }
  if (dword_1EF19FC90 < 5)
    goto LABEL_7;
  v17 = *__error();
  v568 = _SILogForLogForCategory(1);
  if (os_log_type_enabled(v568, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(v756[0]) = 134218498;
    *(_QWORD *)((char *)v756 + 4) = a1;
    WORD6(v756[0]) = 1024;
    *(_DWORD *)((char *)v756 + 14) = qos_class_self();
    v16 = (_DWORD *)&unk_1EF19F000;
    WORD1(v756[1]) = 2112;
    *(_QWORD *)((char *)&v756[1] + 4) = dispatch_get_current_queue();
    v22 = "readSDBForOids %p QoS %d queue %@ query (missing)";
    v23 = v568;
    v24 = 28;
LABEL_577:
    _os_log_impl(&dword_1B8270000, v23, OS_LOG_TYPE_DEFAULT, v22, (uint8_t *)v756, v24);
  }
LABEL_578:
  *__error() = v17;
LABEL_7:
  if (SIIsAppleInternal_onceToken != -1)
    dispatch_once(&SIIsAppleInternal_onceToken, &__block_literal_global_4644);
  v25 = v735;
  v626 = a9;
  if (SIIsAppleInternal_internal
    && *((_BYTE *)v735 + 650)
    && (v26 = *((_QWORD *)v735 + 1)) != 0
    && (v27 = *(const __CFString **)(v26 + 32)) != 0)
  {
    v610 = CFStringGetLength(v27) > 3;
    v25 = v735;
  }
  else
  {
    v610 = 0;
  }
  v28 = *(_DWORD *)(*((_QWORD *)v25 + 3) + 6584);
  v29 = v626;
  if (*((_BYTE *)v626 + 432))
  {
    v30 = *((_BYTE *)v626 + 433) != 0;
    if (a8)
    {
LABEL_17:
      v31 = 1;
      goto LABEL_18;
    }
  }
  else
  {
    v30 = PartialQueryResults::__needsWhatFieldsMatched(v626);
    *((_BYTE *)v626 + 433) = v30;
    *((_BYTE *)v29 + 432) = 1;
    if (a8)
      goto LABEL_17;
  }
  if (a4)
  {
    v43 = (_BYTE *)(a4 + 69);
    v44 = 1;
    do
    {
      if (*v43)
        v31 = *(v43 - 1) != 0;
      else
        v31 = *(_OWORD *)(v43 - 37) != 0;
      if (v44 >= a7)
        break;
      ++v44;
      v43 += 80;
    }
    while (!v31);
  }
  else
  {
    v31 = 0;
  }
LABEL_18:
  if (*((_BYTE *)v735 + 641))
    v32 = 1;
  else
    v32 = v31;
  v617 = v32;
  if (v30 && !*(_QWORD *)(*((_QWORD *)v735 + 105) + 24))
  {
    v33 = (__CFString *)queryFromCFString(*(_QWORD *)(*((_QWORD *)v735 + 1) + 8));
    *(_QWORD *)(*((_QWORD *)v735 + 105) + 24) = v33;
    Current = CFAbsoluteTimeGetCurrent();
    decorateExpandingFunctions(v33, **((_QWORD **)v735 + 1), *(const void **)(*((_QWORD *)v735 + 1) + 656), Current);
  }
  v35 = v16[804];
  v611 = v30;
  if (v35 >= 5)
  {
    v559 = *__error();
    v560 = _SILogForLogForCategory(1);
    if (os_log_type_enabled(v560, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v756[0]) = 134218240;
      *(_QWORD *)((char *)v756 + 4) = v735;
      WORD6(v756[0]) = 2048;
      *(_QWORD *)((char *)v756 + 14) = a7;
      _os_log_impl(&dword_1B8270000, v560, OS_LOG_TYPE_DEFAULT, "readSDBForOids %p item count: %ld", (uint8_t *)v756, 0x16u);
    }
    *__error() = v559;
    v30 = v611;
  }
  v36 = v735;
  LODWORD(v37) = (_DWORD)v629;
  if (v629
    && ((v38 = *((_DWORD *)v735 + 40), v39 = v38 > 6, v40 = (1 << v38) & 0x4A, !v39) ? (v41 = v40 == 0) : (v41 = 1),
        !v41 || (v37 = *((_QWORD *)v735 + 29)) != 0))
  {
    updated = SISearchCtx_METADATA::updateGroupingCount(v735);
    LODWORD(v37) = 1;
    v36 = v735;
  }
  else
  {
    updated = 0;
  }
  v609 = v37;
  v45 = (_QWORD *)*((_QWORD *)v36 + 1);
  v46 = v45[79];
  v607 = v45[78];
  v608 = v46;
  v47 = v45[81];
  v48 = v45[80];
  if (!(v48 | v47))
  {
    v47 = -1;
    v48 = -1;
  }
  v605 = v48;
  v606 = v47;
  v734.opaque2 = 0;
  v734.opaque1 = 0;
  v49 = *(_DWORD **)(*((_QWORD *)v36 + 13) + 24);
  v622 = updated;
  if (v49)
  {
    v49 = _Block_copy(v49);
    updated = v622;
    v619 = (unint64_t)v49;
  }
  else
  {
    v619 = 0;
  }
  v615 = a10;
  v604 = !v30;
  if (updated <= 1)
    v50 = 1;
  else
    v50 = updated;
  if ((int)v16[804] >= 5)
  {
    v561 = v50;
    v562 = *__error();
    v563 = _SILogForLogForCategory(1);
    if (os_log_type_enabled(v563, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v756[0]) = 134217984;
      *(_QWORD *)((char *)v756 + 4) = v561;
      _os_log_impl(&dword_1B8270000, v563, OS_LOG_TYPE_DEFAULT, "categoryCount:%ld", (uint8_t *)v756, 0xCu);
    }
    v49 = __error();
    *v49 = v562;
    v50 = v561;
  }
  v612 = (uint64_t *)&v578;
  v603 = (v28 >> 18) & 1;
  v51 = v50;
  v52 = 8 * v50;
  MEMORY[0x1E0C80A78](v49);
  v628 = (char *)&v578 - ((v52 + 15) & 0xFFFFFFFF0);
  bzero(v628, v52);
  v623 = v51;
  v53 = 240 * v51;
  MEMORY[0x1E0C80A78](v54);
  bzero(&v578 - 30 * v51, 240 * v51);
  v55 = 0;
  do
  {
    v56 = (_OWORD *)((char *)&v578 + v55 - v53);
    v56[12] = xmmword_1B8630AB0;
    v56[13] = unk_1B8630AC0;
    v56[14] = xmmword_1B8630AD0;
    v56[8] = xmmword_1B8630A70;
    v56[9] = unk_1B8630A80;
    v56[10] = xmmword_1B8630A90;
    v56[11] = unk_1B8630AA0;
    v56[4] = xmmword_1B8630A30;
    v56[5] = unk_1B8630A40;
    v56[6] = xmmword_1B8630A50;
    v56[7] = unk_1B8630A60;
    *v56 = ZERO_COMBO_BITS;
    v56[1] = unk_1B8630A00;
    v55 += 240;
    v56[2] = xmmword_1B8630A10;
    v56[3] = unk_1B8630A20;
  }
  while (v53 != v55);
  v627 = (char *)&v578 - v53;
  v57 = v735;
  v58 = *((_QWORD *)v735 + 22);
  if (v58 || (v58 = *((_QWORD *)v735 + 23)) != 0)
  {
    if (v58 <= *((_QWORD *)v735 + 21))
      v58 = *((_QWORD *)v735 + 21);
    v646 = v58;
  }
  else
  {
    v646 = 0;
  }
  v59 = (_DWORD *)&unk_1EF19F000;
  v624 = a8;
  v625 = a4;
  v733 = 0;
  v60 = (_QWORD *)&unk_1B862B000;
  v639 = unk_1B8630AA0;
  v640 = unk_1B8630A80;
  v637 = xmmword_1B8630A30;
  v638 = xmmword_1B8630A90;
  v635 = unk_1B8630A60;
  v636 = unk_1B8630A40;
  v633 = ZERO_COMBO_BITS;
  v634 = xmmword_1B8630A50;
  v631 = unk_1B8630A20;
  v632 = unk_1B8630A00;
  v630 = xmmword_1B8630A10;
  v643 = unk_1B8630AC0;
  v644 = xmmword_1B8630AB0;
  v641 = xmmword_1B8630A70;
  v642 = xmmword_1B8630AD0;
  if (!a4 || !v646 || *(_QWORD *)(*((_QWORD *)v735 + 1) + 216))
  {
    if (!v646)
    {
      if ((int)v623 < 1)
      {
        v131 = 0;
        v94 = 0;
        v95 = v624;
      }
      else
      {
        bzero(v628, v52);
        v133 = v630;
        v132 = v631;
        v135 = v632;
        v134 = v633;
        v137 = v634;
        v136 = v635;
        v139 = v636;
        v138 = v637;
        v141 = v638;
        v140 = v639;
        v143 = v640;
        v142 = v641;
        v145 = v642;
        v144 = v643;
        v146 = v644;
        v147 = (__int128 *)v627;
        v131 = (_QWORD *)v623;
        v95 = v624;
        do
        {
          v147[12] = v146;
          v147[13] = v144;
          v147[14] = v145;
          v147[8] = v142;
          v147[9] = v143;
          v147[10] = v141;
          v147[11] = v140;
          v147[4] = v138;
          v147[5] = v139;
          v147[6] = v137;
          v147[7] = v136;
          *v147 = v134;
          v147[1] = v135;
          v147[2] = v133;
          v147[3] = v132;
          v147 += 15;
          v131 = (_QWORD *)((char *)v131 - 1);
        }
        while (v131);
        v94 = 0;
      }
      goto LABEL_113;
    }
    goto LABEL_86;
  }
  if (!v31 && *((_BYTE *)v735 + 641))
  {
LABEL_86:
    v645 = a7;
    v97 = (os_unfair_lock_s *)*((_QWORD *)v735 + 116);
    v98 = (_BYTE *)v623;
    v99 = 32 * v623;
    if (!v97)
    {
      v100 = malloc_type_malloc(v99 + 40, 0xC7170BEDuLL);
      *((_QWORD *)v735 + 116) = v100;
      v100[4] = 0;
      *(_OWORD *)v100 = 0u;
      *((_OWORD *)v100 + 1) = 0u;
      *((_DWORD *)v100 + 1) = (_DWORD)v98;
      v101 = v98;
      v102 = v100 + 7;
      do
      {
        *(v102 - 2) = L1ComboQueueInit();
        *(v102 - 1) = L1ComboQueueInit();
        *v102 = 0;
        v102[1] = 0;
        v102 += 4;
        --v101;
      }
      while (v101);
      v103 = v735;
      LODWORD(v98) = v623;
      *((_DWORD *)v735 + 163) = v623;
      v97 = (os_unfair_lock_s *)*((_QWORD *)v103 + 116);
    }
    os_unfair_lock_lock(v97);
    v104 = v735;
    if ((int)v98 >= 1)
    {
      v105 = 0;
      v107 = v627;
      v106 = (uint64_t *)v628;
      do
      {
        v108 = *(uint64_t **)(*((_QWORD *)v104 + 116) + v105 + 40);
        v109 = L1ComboQueueCount(v108);
        *v106 = v109;
        if (v109)
        {
          v110 = *(_QWORD *)v108[2];
          if (v110)
            v111 = (__int128 *)(v110 + 80);
          else
            v111 = &ZERO_RANKING_WRAPPED_BITS;
          v112 = v111[3];
          v756[2] = v111[2];
          v757 = v112;
          v758 = v111[4];
          v113 = *v111;
          v756[1] = v111[1];
          v756[0] = v113;
          v114 = *(_QWORD *)*v108;
          if (v114)
            v115 = (__int128 *)(v114 + 80);
          else
            v115 = &ZERO_RANKING_WRAPPED_BITS;
          v759 = *v115;
          v116 = v115[1];
          v117 = v115[2];
          v118 = v115[4];
          v761 = v115[3];
          v762 = v118;
          v760[0] = v116;
          v760[1] = v117;
          v119 = *(_QWORD *)v108[1];
          if (v119)
            v120 = (__int128 *)(v119 + 80);
          else
            v120 = &ZERO_RANKING_WRAPPED_BITS;
          v763 = *v120;
          v121 = v120[1];
          v122 = v120[2];
          v123 = v120[4];
          v766 = v120[3];
          v767 = v123;
          v764 = v121;
          v765 = v122;
        }
        else
        {
          v765 = v644;
          v766 = v643;
          v767 = v642;
          v761 = v641;
          v762 = v640;
          v764 = v639;
          v763 = v638;
          v758 = v637;
          v759 = v636;
          v760[1] = v635;
          v760[0] = v634;
          v756[0] = v633;
          v756[1] = v632;
          v757 = v631;
          v756[2] = v630;
        }
        v124 = v766;
        v107[12] = v765;
        v107[13] = v124;
        v107[14] = v767;
        v125 = v762;
        v107[8] = v761;
        v107[9] = v125;
        v126 = v764;
        v107[10] = v763;
        v107[11] = v126;
        v127 = v759;
        v107[4] = v758;
        v107[5] = v127;
        v128 = v760[1];
        v107[6] = v760[0];
        v107[7] = v128;
        v129 = v756[1];
        *v107 = v756[0];
        v107[1] = v129;
        v130 = v757;
        v105 += 32;
        v107[2] = v756[2];
        v107[3] = v130;
        v107 += 15;
        ++v106;
      }
      while (v99 != v105);
    }
    os_unfair_lock_unlock(*((os_unfair_lock_t *)v104 + 116));
    v131 = 0;
    v94 = 0;
    v57 = v735;
    v59 = (_DWORD *)&unk_1EF19F000;
    a7 = v645;
    v95 = v624;
    a4 = v625;
    v60 = (_QWORD *)&unk_1B862B000;
    goto LABEL_113;
  }
  LODWORD(v621) = a11;
  v645 = a7;
  v61 = (os_unfair_lock_s *)*((_QWORD *)v735 + 116);
  v62 = (_BYTE *)v623;
  if (!v61)
  {
    v63 = malloc_type_malloc(32 * v623 + 40, 0x17859774uLL);
    *((_QWORD *)v735 + 116) = v63;
    v63[4] = 0;
    *(_OWORD *)v63 = 0u;
    *((_OWORD *)v63 + 1) = 0u;
    *((_DWORD *)v63 + 1) = (_DWORD)v62;
    v64 = v63 + 7;
    do
    {
      *(v64 - 2) = L1ComboQueueInit();
      *(v64 - 1) = L1ComboQueueInit();
      *v64 = 0;
      v64[1] = 0;
      v64 += 4;
      --v62;
    }
    while (v62);
    v65 = v735;
    LODWORD(v62) = v623;
    *((_DWORD *)v735 + 163) = v623;
    v61 = (os_unfair_lock_s *)*((_QWORD *)v65 + 116);
  }
  os_unfair_lock_lock(v61);
  v66 = v735;
  if ((int)v62 >= 1)
  {
    v67 = 0;
    v68 = 32 * v623;
    v69 = v627;
    v70 = (uint64_t *)v628;
    do
    {
      v71 = *(uint64_t **)(*((_QWORD *)v66 + 116) + v67 + 40);
      v72 = L1ComboQueueCount(v71);
      *v70 = v72;
      if (v72)
      {
        v73 = *(_QWORD *)v71[2];
        if (v73)
          v74 = (__int128 *)(v73 + 80);
        else
          v74 = &ZERO_RANKING_WRAPPED_BITS;
        v75 = v74[3];
        v756[2] = v74[2];
        v757 = v75;
        v758 = v74[4];
        v76 = *v74;
        v756[1] = v74[1];
        v756[0] = v76;
        v77 = *(_QWORD *)*v71;
        if (v77)
          v78 = (__int128 *)(v77 + 80);
        else
          v78 = &ZERO_RANKING_WRAPPED_BITS;
        v759 = *v78;
        v79 = v78[1];
        v80 = v78[2];
        v81 = v78[4];
        v761 = v78[3];
        v762 = v81;
        v760[0] = v79;
        v760[1] = v80;
        v82 = *(_QWORD *)v71[1];
        if (v82)
          v83 = (__int128 *)(v82 + 80);
        else
          v83 = &ZERO_RANKING_WRAPPED_BITS;
        v763 = *v83;
        v84 = v83[1];
        v85 = v83[2];
        v86 = v83[4];
        v766 = v83[3];
        v767 = v86;
        v764 = v84;
        v765 = v85;
      }
      else
      {
        v765 = v644;
        v766 = v643;
        v767 = v642;
        v761 = v641;
        v762 = v640;
        v764 = v639;
        v763 = v638;
        v758 = v637;
        v759 = v636;
        v760[1] = v635;
        v760[0] = v634;
        v756[0] = v633;
        v756[1] = v632;
        v757 = v631;
        v756[2] = v630;
      }
      v87 = v766;
      v69[12] = v765;
      v69[13] = v87;
      v69[14] = v767;
      v88 = v762;
      v69[8] = v761;
      v69[9] = v88;
      v89 = v764;
      v69[10] = v763;
      v69[11] = v89;
      v90 = v759;
      v69[4] = v758;
      v69[5] = v90;
      v91 = v760[1];
      v69[6] = v760[0];
      v69[7] = v91;
      v92 = v756[1];
      *v69 = v756[0];
      v69[1] = v92;
      v93 = v757;
      v67 += 32;
      v69[2] = v756[2];
      v69[3] = v93;
      v69 += 15;
      ++v70;
    }
    while (v68 != v67);
  }
  os_unfair_lock_unlock(*((os_unfair_lock_t *)v66 + 116));
  v57 = v735;
  if ((v621 & 1) != 0)
  {
    v94 = 0;
    v59 = (_DWORD *)&unk_1EF19F000;
    a7 = v645;
    v95 = v624;
    a4 = v625;
    v96 = v622;
    goto LABEL_84;
  }
  v59 = (int *)&unk_1EF19F000;
  a7 = v645;
  v95 = v624;
  a4 = v625;
  v96 = v622;
  v60 = &unk_1B862B000;
  if (*((_BYTE *)v735 + 1128))
    goto LABEL_111;
  v179 = *((_DWORD *)v735 + 40);
  if (v179 == 2)
  {
    v180 = v623;
    if (v646 >= 0x1389)
    {
LABEL_111:
      v94 = 0;
      goto LABEL_112;
    }
  }
  else
  {
    v180 = v623;
    if (v646 > 0x1388 || v179 != 4)
    {
      v94 = 0;
      if (v646 > 0x64 || (v179 & 0xFFFFFFFD) != 1)
        goto LABEL_112;
    }
  }
  if (!*((_QWORD *)v735 + 139))
  {
    if ((v179 & 0xFFFFFFFD) == 1)
      v181 = 0;
    else
      v181 = v646;
    Info = createFetchInfo(v180, v181);
    v57 = v735;
    *((_QWORD *)v735 + 139) = Info;
  }
  Mutable = *((_QWORD *)v57 + 140);
  if (!Mutable)
  {
    Mutable = RLEOIDArrayCreateMutable((const __CFAllocator *)*MEMORY[0x1E0C9AE00]);
    v57 = v735;
    *((_QWORD *)v735 + 140) = Mutable;
  }
  v600 = *((_QWORD *)v57 + 139);
  v601 = Mutable;
  v597 = (pthread_rwlock_t *)(Mutable + 16);
  pthread_rwlock_wrlock((pthread_rwlock_t *)(Mutable + 16));
  if (v95)
  {
    v184 = (char *)(a4 + 69);
    v185 = v629;
    v186 = v95;
    v187 = a7;
    v188 = v618;
    v189 = v601;
    while (1)
    {
      v190 = *v188++;
      if (!RLEOIDArrayContainsOid_locked(v189, v190) && !*v186)
      {
        v191 = *v184;
        if (*v184)
        {
          if (!*(v184 - 1))
            goto LABEL_184;
        }
        else if (*(_OWORD *)(v184 - 37) == 0)
        {
LABEL_184:
          if (v622)
          {
            v192 = *v185;
            v193 = v192 & 0xFFDF;
            if (v622 <= (v192 & 0xFFFFFFDF))
              v193 = 18;
            if (v622 <= v192)
              LOWORD(v192) = 0;
            if (*((_BYTE *)v735 + 650))
              v194 = v192;
            else
              v194 = v193;
          }
          else
          {
            v194 = 0;
          }
          v195 = *(_QWORD *)(v184 - 69);
          v196 = *(_QWORD *)(v184 - 61);
          if ((*((_OWORD *)v735 + 25) & *(_OWORD *)(v184 - 69)) == 0)
          {
            if (!(*((_QWORD *)v735 + 58) & v195 | *((_QWORD *)v735 + 59) & v196))
            {
              v200 = 0;
              v199 = 0;
              v198 = *(_QWORD *)(v184 - 69);
              v197 = *(_QWORD *)(v184 - 61);
LABEL_204:
              if (*((_DWORD *)v735 + 163) > v194)
              {
                v206 = *(_DWORD *)(v184 - 21);
                v207 = *(_DWORD *)(v184 - 17);
                v208 = *(_DWORD *)(v184 - 13);
                v209 = *(v184 - 1);
                v210 = *(_QWORD *)(v184 - 37);
                v211 = *(_QWORD *)(v184 - 29);
                v212 = (os_unfair_lock_s *)*((_QWORD *)v735 + 116);
                v213 = *((_QWORD *)v735 + 22);
                v724[0] = v198;
                v724[1] = v197;
                v724[2] = v200;
                v724[3] = v199;
                v724[5] = v211;
                v724[4] = v210;
                v725 = v206;
                v726 = v207;
                v727 = v208;
                v728 = *(_QWORD *)(v184 - 9);
                v729 = v209;
                v730 = v191;
                v731 = 0;
                v732 = 0;
                ci_donebits_push(v212, v646, v213, v194, v724);
              }
              goto LABEL_178;
            }
            v198 = *(_QWORD *)(v184 - 69);
            v197 = *(_QWORD *)(v184 - 61);
          }
          else
          {
            v197 = *((_QWORD *)v735 + 53) & v196;
            v198 = *((_QWORD *)v735 + 52) & v195;
            v199 = *((_QWORD *)v735 + 58) & v195 | *((_QWORD *)v735 + 59) & v196;
            if (!v199)
            {
              v200 = 0;
              goto LABEL_204;
            }
          }
          v201 = *((_QWORD *)v735 + 62) & v195;
          v202 = *((_DWORD *)v735 + 129);
          v203 = ((*((_QWORD *)v735 + 63) & v196) << v202) | (v201 >> 1 >> ~(_BYTE)v202);
          v204 = v201 << v202;
          v205 = (v202 & 0x40) == 0;
          if ((v202 & 0x40) != 0)
            v199 = v204;
          else
            v199 = v203;
          if (!v205)
            v204 = 0;
          v200 = v204 | 1;
          goto LABEL_204;
        }
      }
LABEL_178:
      ++v186;
      v184 += 80;
      ++v185;
      if (!--v187)
        goto LABEL_240;
    }
  }
  v214 = (char *)(a4 + 69);
  v215 = v629;
  v216 = v618;
  v217 = v601;
  do
  {
    v218 = *v216++;
    if (RLEOIDArrayContainsOid_locked(v217, v218))
      goto LABEL_211;
    v219 = *v214;
    if (*v214)
    {
      if (*(v214 - 1))
        goto LABEL_211;
    }
    else if (*(_OWORD *)(v214 - 37) != 0)
    {
      goto LABEL_211;
    }
    if (v622)
    {
      v220 = *v215;
      v221 = v220 & 0xFFDF;
      if (v622 <= (v220 & 0xFFFFFFDF))
        v221 = 18;
      if (v622 <= v220)
        LOWORD(v220) = 0;
      if (*((_BYTE *)v735 + 650))
        v222 = v220;
      else
        v222 = v221;
    }
    else
    {
      v222 = 0;
    }
    v223 = *(_QWORD *)(v214 - 69);
    v224 = *(_QWORD *)(v214 - 61);
    if ((*((_OWORD *)v735 + 25) & *(_OWORD *)(v214 - 69)) == 0)
    {
      if (*((_QWORD *)v735 + 58) & v223 | *((_QWORD *)v735 + 59) & v224)
      {
        v226 = *(_QWORD *)(v214 - 69);
        v225 = *(_QWORD *)(v214 - 61);
LABEL_231:
        v229 = *((_QWORD *)v735 + 62) & v223;
        v230 = *((_DWORD *)v735 + 129);
        v231 = ((*((_QWORD *)v735 + 63) & v224) << v230) | (v229 >> 1 >> ~(_BYTE)v230);
        v232 = v229 << v230;
        v233 = (v230 & 0x40) == 0;
        if ((v230 & 0x40) != 0)
          v227 = v232;
        else
          v227 = v231;
        if (!v233)
          v232 = 0;
        v228 = v232 | 1;
        goto LABEL_237;
      }
      v228 = 0;
      v227 = 0;
      v226 = *(_QWORD *)(v214 - 69);
      v225 = *(_QWORD *)(v214 - 61);
    }
    else
    {
      v225 = *((_QWORD *)v735 + 53) & v224;
      v226 = *((_QWORD *)v735 + 52) & v223;
      v227 = *((_QWORD *)v735 + 58) & v223 | *((_QWORD *)v735 + 59) & v224;
      if (v227)
        goto LABEL_231;
      v228 = 0;
    }
LABEL_237:
    if (*((_DWORD *)v735 + 163) > v222)
    {
      v234 = *(_DWORD *)(v214 - 21);
      v235 = *(_DWORD *)(v214 - 17);
      v236 = *(_DWORD *)(v214 - 13);
      v237 = *(v214 - 1);
      v238 = *(_QWORD *)(v214 - 37);
      v239 = *(_QWORD *)(v214 - 29);
      v240 = (os_unfair_lock_s *)*((_QWORD *)v735 + 116);
      v241 = *((_QWORD *)v735 + 22);
      v715[0] = v226;
      v715[1] = v225;
      v715[2] = v228;
      v715[3] = v227;
      v715[5] = v239;
      v715[4] = v238;
      v716 = v234;
      v717 = v235;
      v718 = v236;
      v719 = *(_QWORD *)(v214 - 9);
      v720 = v237;
      v721 = v219;
      v722 = 0;
      v723 = 0;
      ci_donebits_push(v240, v646, v241, v222, v715);
    }
LABEL_211:
    v214 += 80;
    ++v215;
    --a7;
  }
  while (a7);
LABEL_240:
  v242 = 0;
  v243 = 100;
  if (v646 < 0x64)
    v243 = v646;
  v616 = v243;
  v620 = v754;
  v621 = (uint64_t *)v760;
  v598 = &v763;
  v599 = &v759;
  while (2)
  {
    v244 = (os_unfair_lock_s *)*((_QWORD *)v735 + 116);
    v245 = L1ComboQueueCount(*(uint64_t **)&v244[8 * v242 + 10]._os_unfair_lock_opaque);
    *(_QWORD *)&v628[8 * v242] = v245;
    os_unfair_lock_lock(v244);
    if (v245)
    {
      v246 = v735;
      v247 = *(uint64_t ***)(*((_QWORD *)v735 + 116) + 32 * v242 + 40);
      v248 = *v247[2];
      if (v248)
        v249 = (__int128 *)(v248 + 80);
      else
        v249 = &ZERO_RANKING_WRAPPED_BITS;
      v250 = v249[3];
      v756[2] = v249[2];
      v757 = v250;
      v758 = v249[4];
      v251 = *v249;
      v756[1] = v249[1];
      v756[0] = v251;
      v252 = **v247;
      if (v252)
        v253 = (__int128 *)(v252 + 80);
      else
        v253 = &ZERO_RANKING_WRAPPED_BITS;
      v254 = v599;
      *v599 = *v253;
      v254[4] = v253[4];
      v254[3] = v253[3];
      v254[2] = v253[2];
      v254[1] = v253[1];
      v255 = *v247[1];
      if (v255)
        v256 = (__int128 *)(v255 + 80);
      else
        v256 = &ZERO_RANKING_WRAPPED_BITS;
      v257 = v598;
      v598[1] = v256[1];
      v257[2] = v256[2];
      v257[3] = v256[3];
      v257[4] = v256[4];
      *v257 = *v256;
    }
    else
    {
      v765 = v644;
      v766 = v643;
      v767 = v642;
      v761 = v641;
      v762 = v640;
      v764 = v639;
      v763 = v638;
      v758 = v637;
      v759 = v636;
      v760[1] = v635;
      v760[0] = v634;
      v756[0] = v633;
      v756[1] = v632;
      v757 = v631;
      v756[2] = v630;
      v246 = v735;
    }
    v258 = v766;
    v259 = &v627[240 * v242];
    *((_OWORD *)v259 + 12) = v765;
    *((_OWORD *)v259 + 13) = v258;
    *((_OWORD *)v259 + 14) = v767;
    v260 = v762;
    *((_OWORD *)v259 + 8) = v761;
    *((_OWORD *)v259 + 9) = v260;
    v261 = v764;
    *((_OWORD *)v259 + 10) = v763;
    *((_OWORD *)v259 + 11) = v261;
    v262 = v759;
    *((_OWORD *)v259 + 4) = v758;
    *((_OWORD *)v259 + 5) = v262;
    v263 = v760[1];
    *((_OWORD *)v259 + 6) = v760[0];
    *((_OWORD *)v259 + 7) = v263;
    v264 = v756[1];
    *(_OWORD *)v259 = v756[0];
    *((_OWORD *)v259 + 1) = v264;
    v265 = v757;
    *((_OWORD *)v259 + 2) = v756[2];
    *((_OWORD *)v259 + 3) = v265;
    os_unfair_lock_unlock(*((os_unfair_lock_t *)v246 + 116));
    if (v245 >= v646)
    {
      v266 = v600 + 40 * v242;
      if (*(_QWORD *)(v266 + 24) - 1 > v646)
      {
        v267 = (_QWORD *)(v266 + 8);
        v602 = v259 + 80;
        v268 = v600 + 40 * v242;
        v269 = (_DWORD **)(v268 + 32);
        v270 = (_DWORD **)(v268 + 40);
        do
        {
          if (*v267)
            v271 = (__int128 *)(*v267 + 144);
          else
            v271 = &ZERO_FETCHINFO;
          v273 = *(_QWORD *)v271;
          v272 = *((_QWORD *)v271 + 1);
          v274 = *((float *)v271 + 15);
          v275 = *((float *)v271 + 16);
          if (*((_BYTE *)v271 + 69))
          {
            v276 = v259 + 160;
            if (v275 == 0.0)
              goto LABEL_267;
          }
          else
          {
            v276 = v259 + 160;
            if (!(v273 | v272))
              goto LABEL_267;
          }
          v276 = v259;
          if (v274 == v275)
            v276 = v602;
LABEL_267:
          v277 = *((_DWORD *)v271 + 12);
          v278 = *((float *)v271 + 13);
          v279 = *((_DWORD *)v276 + 12);
          v280 = *((float *)v276 + 13);
          if (v276[69])
          {
            v281 = *((float *)v276 + 15);
            if (v281 <= v274)
            {
              if (v281 != v274)
                break;
LABEL_277:
              if (v280 <= v278 && (v280 != v278 || v279 >= v277))
                break;
            }
          }
          else
          {
            v284 = v276;
            v282 = *(_QWORD *)v276;
            v283 = *((_QWORD *)v284 + 1);
            if (__PAIR128__(v272, v273) >= __PAIR128__(v283, v282))
            {
              if (v283 != v272 || v282 != v273)
                break;
              goto LABEL_277;
            }
          }
          v761 = 0u;
          memset(v760, 0, sizeof(v760));
          v759 = 0u;
          v758 = 0u;
          v757 = 0u;
          memset(v756, 0, sizeof(v756));
          pqpop_rankAndFetchInfo_t((uint64_t)v756, v267);
          if (DWORD2(v757))
          {
            v287 = *v269;
            if (!*v269)
            {
              v287 = container_fetch_table_create(v616);
              *v269 = v287;
            }
            v714[6] = v760[0];
            v714[7] = v760[1];
            v714[8] = v761;
            v714[2] = v756[2];
            v714[3] = v757;
            v714[5] = v759;
            v714[4] = v758;
            v714[1] = v756[1];
            v714[0] = v756[0];
            container_fetch_table_check_and_insert(v287, (uint64_t)v714);
            v288 = *v270;
            if (!*v270)
            {
              v288 = container_fetch_table_q2_create(v616);
              *v270 = v288;
            }
            memset(&v755[20], 0, 15);
            v751[2] = v756[2];
            v751[3] = v757;
            v751[4] = v758;
            v751[1] = v756[1];
            v751[0] = v756[0];
            v289 = *((_QWORD *)&v759 + 1);
            v290 = v759;
            v292 = v620;
            v291 = v621;
            *(_DWORD *)v620 = *(_DWORD *)v621;
            v292[4] = *((_BYTE *)v291 + 4);
            v752 = v290;
            v753 = v289;
            v754[8] = BYTE8(v760[0]);
            v754[9] = BYTE9(v760[0]);
            v754[10] = BYTE10(v760[0]);
            v754[11] = BYTE11(v760[0]);
            v754[12] = BYTE12(v760[0]);
            *(_QWORD *)v755 = *(_QWORD *)((char *)v760 + 13);
            *(_DWORD *)&v755[7] = DWORD1(v760[1]);
            *(_QWORD *)&v755[11] = *((_QWORD *)&v760[1] + 1);
            v755[19] = v761;
            container_fetch_table_q2_check_and_insert(v288, (uint64_t)v751);
          }
        }
        while (v267[2] - 1 > v646);
      }
    }
    if (++v242 != v623)
      continue;
    break;
  }
  *(_QWORD *)&v644 = malloc_type_malloc(v645, 0x100004077774924uLL);
  *(_QWORD *)&v643 = 0;
  v586 = v668;
  v587 = v666;
  v584 = &v670;
  v585 = &v668[5];
  v582 = v746;
  v583 = v744;
  v581 = &v748;
  v592 = v679;
  v591 = v681;
  v590 = &v681[5];
  v589 = &v683;
  v598 = (__int128 *)v692;
  v595 = &v694[5];
  v596 = v694;
  *(_QWORD *)&v631 = v705;
  *(_QWORD *)&v630 = v707;
  v623 = (uint64_t)&v707[5];
  v580 = v669;
  v579 = v747;
  v588 = v682;
  v593 = v695;
  v594 = &v696;
  v620 = v708;
  v621 = &v709;
  *(_QWORD *)&v642 = v601 + 216;
  v293 = v624;
  v294 = (int *)(v625 + 48);
  v295 = v629;
  v296 = v618;
  v298 = v613;
  v297 = v614;
  v299 = v613;
  v300 = v614;
  v59 = (int *)&unk_1EF19F000;
  while (2)
  {
    if (RLEOIDArrayContainsOid_locked(v601, *v296))
      goto LABEL_366;
    if (v622)
    {
      v301 = *v295;
      v302 = v301 & 0xFFDF;
      if (v622 <= (v301 & 0xFFFFFFDF))
        v302 = 18;
      if (v622 <= v301)
        LOWORD(v301) = 0;
      if (*((_BYTE *)v735 + 650))
        v303 = v301;
      else
        v303 = v302;
    }
    else
    {
      v303 = 0;
    }
    v304 = v644;
    if (v624 && *v293)
    {
LABEL_305:
      v306 = v643;
      v618[(_QWORD)v643] = *v296;
      v629[v306] = *v295;
      v307 = (_OWORD *)(v625 + 80 * v306);
      *v307 = *((_OWORD *)v294 - 3);
      v308 = *((_OWORD *)v294 - 2);
      v309 = *((_OWORD *)v294 - 1);
      v310 = *((_OWORD *)v294 + 1);
      v307[3] = *(_OWORD *)v294;
      v307[4] = v310;
      v307[1] = v308;
      v307[2] = v309;
      v624[v306] = *v293;
      v311 = (uint64_t)v298 + 5 * v306;
      v312 = *v299;
      *(_BYTE *)(v311 + 4) = *((_BYTE *)v299 + 4);
      *(_DWORD *)v311 = v312;
      *(_OWORD *)&v297[4 * v306] = *(_OWORD *)v300;
      *(_BYTE *)(v304 + v306) = 1;
      *(_QWORD *)&v643 = v306 + 1;
      goto LABEL_366;
    }
    v305 = *((unsigned __int8 *)v294 + 21);
    if (!*((_BYTE *)v294 + 21))
    {
      if (*((_OWORD *)v294 - 1) == 0)
        goto LABEL_307;
      goto LABEL_305;
    }
    if (*((_BYTE *)v294 + 20))
      goto LABEL_305;
LABEL_307:
    v749 = 0;
    v750 = 0;
    v710 = 0;
    v711 = 0;
    v313 = *((_QWORD *)v294 - 6);
    v314 = *((_QWORD *)v294 - 5);
    if ((*((_OWORD *)v735 + 25) & *((_OWORD *)v294 - 3)) == 0)
    {
      v316 = *((_QWORD *)v294 - 6);
      v315 = *((_QWORD *)v294 - 5);
      if (*((_QWORD *)v735 + 58) & v313 | *((_QWORD *)v735 + 59) & v314)
        goto LABEL_311;
      v317 = 0;
      v318 = 0;
      v316 = *((_QWORD *)v294 - 6);
      v315 = *((_QWORD *)v294 - 5);
    }
    else
    {
      v315 = *((_QWORD *)v735 + 53) & v314;
      v316 = *((_QWORD *)v735 + 52) & v313;
      if (!(*((_QWORD *)v735 + 58) & v313 | *((_QWORD *)v735 + 59) & v314))
      {
        v317 = 0;
        v318 = 0;
        goto LABEL_318;
      }
LABEL_311:
      v319 = *((_QWORD *)v735 + 62) & v313;
      v320 = *((_DWORD *)v735 + 129);
      v321 = ((*((_QWORD *)v735 + 63) & v314) << v320) | (v319 >> 1 >> ~(_BYTE)v320);
      v322 = v319 << v320;
      if ((v320 & 0x40) != 0)
        v318 = v322;
      else
        v318 = v321;
      if ((v320 & 0x40) != 0)
        v323 = 0;
      else
        v323 = v322;
      v317 = v323 | 1;
    }
LABEL_318:
    v324 = *((unsigned __int8 *)v294 + 20);
    v326 = *((float *)v294 + 3);
    v325 = *((float *)v294 + 4);
    v327 = v294[2];
    v328 = *((float *)v294 + 1);
    v329 = *v294;
    v330 = *((_QWORD *)v294 - 2);
    v331 = *((_QWORD *)v294 - 1);
    v712 = *v299;
    v713 = *((_BYTE *)v299 + 4);
    v332 = *v300 | ((unint64_t)*((unsigned __int8 *)v300 + 4) << 32);
    *(_QWORD *)&v768 = *(_QWORD *)((char *)v300 + 5);
    *(_DWORD *)((char *)&v768 + 7) = v300[3];
    v333 = v303;
    v334 = *v296;
    if (*(_QWORD *)&v628[8 * v303] < v646)
    {
      v697[0] = v316;
      v697[1] = v315;
      v335 = v600 + 40 * v303 + 8;
      v697[2] = v317;
      v697[3] = v318;
      v697[4] = v330;
      v697[5] = v331;
      v698 = v329;
      v699 = v328;
      v700 = v327;
      v701 = v326;
      v702 = v325;
      v703 = v324;
      v704 = v305;
      v336 = v631;
      *(_QWORD *)v631 = 0;
      *(_WORD *)(v336 + 8) = 0;
      *(_QWORD *)&v705[10] = v313;
      v706 = v314;
      v337 = v630;
      *(_DWORD *)v630 = *v299;
      *(_BYTE *)(v337 + 4) = *((_BYTE *)v299 + 4);
      v338 = (_WORD *)v623;
      *(_BYTE *)(v623 + 2) = 0;
      *v338 = 0;
      v707[12] = BYTE4(v332);
      *(_DWORD *)&v707[8] = v332;
      v339 = v620;
      *(_QWORD *)v620 = *(_QWORD *)((char *)v300 + 5);
      *(_DWORD *)(v339 + 7) = v300[3];
      *(_QWORD *)&v708[11] = v334;
      v340 = v621;
      *v621 = 0;
      v340[1] = 0;
      v341 = v334;
      pqpush_rankAndFetchInfo_t(v335, (uint64_t)v697);
      v342 = (unint64_t *)v642;
      v343 = v341;
      goto LABEL_320;
    }
    v344 = &v627[240 * v303];
    v345 = v344 + 160;
    if (v326 == v325)
      v346 = v344 + 80;
    else
      v346 = &v627[240 * v333];
    if (v316 | v315)
      v347 = v346;
    else
      v347 = v344 + 160;
    if (v326 == v325)
      v344 += 80;
    if (v325 == 0.0)
      v344 = v345;
    if (v305)
      v347 = v344;
    v348 = *((_DWORD *)v347 + 12);
    v349 = *((float *)v347 + 13);
    if (!v347[69])
    {
      v353 = v347;
      v351 = *(_QWORD *)v347;
      v352 = *((_QWORD *)v353 + 1);
      if (__PAIR128__(v352, v351) < __PAIR128__(v315, v316))
        goto LABEL_346;
      if (v352 == v315 && v351 == v316)
        goto LABEL_343;
      goto LABEL_368;
    }
    v350 = *((float *)v347 + 15);
    if (v350 >= v326)
    {
      if (v350 != v326)
        goto LABEL_368;
LABEL_343:
      if (v349 >= v328 && (v349 != v328 || v348 < v329))
        goto LABEL_368;
    }
LABEL_346:
    v355 = v600 + 40 * v333;
    v356 = (__int128 *)(v355 + 8);
    if (*(_QWORD *)(v355 + 24) - 1 < v646)
    {
      *(_QWORD *)&v641 = v315;
      v602 = (char *)v334;
      LODWORD(v637) = v324;
      *(_QWORD *)&v640 = v313;
      LODWORD(v639) = v305;
      *(_QWORD *)&v638 = v314;
      v616 = v332;
      *(_QWORD *)&v632 = v317;
      v357 = v318;
      LODWORD(v636) = v327;
      LODWORD(v635) = v329;
      *(_QWORD *)&v634 = v330;
      *(_QWORD *)&v633 = v331;
      v599 = (__int128 *)(v355 + 8);
      SIValueSet<unsigned long long>::SIValueSetInsert((unint64_t *)v642, v334);
      v684[1] = v641;
      v684[0] = v316;
      v684[3] = v357;
      v684[2] = v632;
      v684[5] = v633;
      v684[4] = v634;
      v685 = v635;
      v686 = v328;
      v687 = v636;
      v688 = v326;
      v689 = v325;
      v690 = v637;
      v691 = v639;
      v358 = v598;
      *(_QWORD *)v598 = 0;
      *((_WORD *)v358 + 4) = 0;
      v693 = v638;
      *(_QWORD *)&v692[10] = v640;
      v360 = v595;
      v359 = v596;
      *v596 = v712;
      *((_BYTE *)v359 + 4) = v713;
      LOWORD(v358) = v710;
      v360[2] = v711;
      *(_WORD *)v360 = (_WORD)v358;
      v694[12] = BYTE4(v616);
      *(_DWORD *)&v694[8] = v616;
      v361 = v593;
      *v593 = v768;
      *(_DWORD *)((char *)v361 + 7) = *(_DWORD *)((char *)&v768 + 7);
      *(_QWORD *)&v695[11] = v602;
      v362 = v594;
      *v594 = 0;
      v362[1] = 0;
      v363 = v684;
      goto LABEL_364;
    }
    v364 = (__int128 *)(*(_QWORD *)v356 + 144);
    if (!*(_QWORD *)v356)
      v364 = &ZERO_FETCHINFO;
    v365 = *((_DWORD *)v364 + 12);
    v366 = *((float *)v364 + 13);
    if (*((unsigned __int8 *)v364 + 69) | v305)
    {
      v367 = *((float *)v364 + 15);
      v368 = v326 == v367;
      if (v326 > v367)
        goto LABEL_363;
LABEL_358:
      if (v368 && (v328 > v366 || v328 == v366 && v329 < v365))
        goto LABEL_363;
LABEL_368:
      if (v327)
      {
        *(_QWORD *)&v641 = v315;
        v602 = (char *)v334;
        v379 = v600;
        v380 = v600 + 40 * v333;
        v383 = *(_DWORD **)(v380 + 32);
        v382 = (_QWORD *)(v380 + 32);
        v381 = v383;
        *(_QWORD *)&v640 = v313;
        LODWORD(v639) = v305;
        *(_QWORD *)&v638 = v314;
        LODWORD(v637) = v324;
        *(_QWORD *)&v632 = v317;
        LODWORD(v636) = v327;
        LODWORD(v635) = v329;
        *(_QWORD *)&v634 = v330;
        *(_QWORD *)&v633 = v331;
        if (!v383)
        {
          v616 = v332;
          v578 = v318;
          v381 = container_fetch_table_create(v646);
          v331 = v633;
          v330 = v634;
          v329 = v635;
          v327 = v636;
          v318 = v578;
          v317 = v632;
          LOBYTE(v324) = v637;
          v332 = v616;
          v314 = v638;
          LOBYTE(v305) = v639;
          v313 = v640;
          v379 = v600;
          *v382 = v381;
        }
        v384 = v379 + 40 * v333;
        v385 = *(_QWORD *)(v384 + 40);
        v599 = (__int128 *)(v384 + 40);
        if (!v385)
        {
          v616 = v332;
          v386 = v317;
          v578 = v318;
          v387 = container_fetch_table_q2_create(v646);
          v331 = v633;
          v330 = v634;
          v329 = v635;
          v327 = v636;
          v318 = v578;
          v317 = v386;
          LOBYTE(v324) = v637;
          v332 = v616;
          v314 = v638;
          LOBYTE(v305) = v639;
          v313 = v640;
          *(_QWORD *)v599 = v387;
          v381 = (_DWORD *)*v382;
        }
        v658[0] = v316;
        v658[1] = v641;
        v658[2] = v317;
        v658[3] = v318;
        v658[4] = v330;
        v658[5] = v331;
        v659 = v329;
        v660 = v328;
        v661 = v327;
        v662 = v326;
        v663 = v325;
        v664 = v324;
        v665 = v305;
        v389 = v586;
        v388 = v587;
        *v587 = 0;
        *((_WORD *)v388 + 4) = 0;
        *(_QWORD *)&v666[10] = v313;
        v667 = v314;
        *(_DWORD *)v389 = v712;
        v389[4] = v713;
        v390 = v585;
        v585[2] = 0;
        *v390 = 0;
        v668[12] = BYTE4(v332);
        *(_DWORD *)&v668[8] = v332;
        v391 = v580;
        *v580 = v768;
        *(_DWORD *)((char *)v391 + 7) = *(_DWORD *)((char *)&v768 + 7);
        *(_QWORD *)&v669[11] = v602;
        v392 = v584;
        *v584 = 0;
        v392[1] = 0;
        v393 = v316;
        v394 = v332;
        v395 = v318;
        LODWORD(v616) = container_fetch_table_check_and_insert(v381, (uint64_t)v658);
        v396 = *(_DWORD **)v599;
        v736[1] = v641;
        v736[0] = v393;
        v736[3] = v395;
        v736[2] = v632;
        v736[5] = v633;
        v736[4] = v634;
        v737 = v635;
        v738 = v328;
        v739 = v636;
        v740 = v326;
        v741 = v325;
        v742 = v637;
        v743 = v639;
        v398 = v582;
        v397 = v583;
        *v583 = v749;
        *((_WORD *)v397 + 4) = v750;
        v745 = v638;
        *(_QWORD *)&v744[10] = v640;
        v399 = v712;
        v398[4] = v713;
        *(_DWORD *)v398 = v399;
        *(_QWORD *)&v746[5] = v394 << 24;
        v400 = v579;
        *(_DWORD *)(v579 + 7) = *(_DWORD *)((char *)&v768 + 7);
        *v400 = v768;
        v401 = (unint64_t)v602;
        *(_QWORD *)&v747[11] = v602;
        v402 = v581;
        *v581 = 0;
        v402[1] = 0;
        v403 = container_fetch_table_q2_check_and_insert(v396, (uint64_t)v736);
        v343 = v401;
        v59 = (_DWORD *)&unk_1EF19F000;
        if ((v616 & 1) != 0 || v403)
        {
          v342 = (unint64_t *)v642;
LABEL_320:
          SIValueSet<unsigned long long>::SIValueSetInsert(v342, v343);
        }
      }
    }
    else
    {
      v371 = v364;
      v369 = *(_QWORD *)v364;
      v370 = *((_QWORD *)v371 + 1);
      if (__PAIR128__(v370, v369) >= __PAIR128__(v315, v316))
      {
        v368 = v315 == v370 && v316 == v369;
        goto LABEL_358;
      }
LABEL_363:
      *(_QWORD *)&v641 = v315;
      v372 = v334;
      LODWORD(v637) = v324;
      *(_QWORD *)&v640 = v313;
      LODWORD(v639) = v305;
      *(_QWORD *)&v638 = v314;
      v578 = v316;
      v616 = v332;
      *(_QWORD *)&v632 = v317;
      v373 = v318;
      LODWORD(v636) = v327;
      LODWORD(v635) = v329;
      *(_QWORD *)&v634 = v330;
      *(_QWORD *)&v633 = v331;
      v599 = v356;
      pqpop_rankAndFetchInfo_t((uint64_t)v756, v356);
      SIValueSet<unsigned long long>::SIValueSetInsert((unint64_t *)v642, v372);
      v671[1] = v641;
      v671[0] = v578;
      v671[3] = v373;
      v671[2] = v632;
      v671[5] = v633;
      v671[4] = v634;
      v672 = v635;
      v673 = v328;
      v674 = v636;
      v675 = v326;
      v676 = v325;
      v677 = v637;
      v678 = v639;
      v375 = v591;
      v374 = v592;
      *v592 = 0;
      *((_WORD *)v374 + 4) = 0;
      v680 = v638;
      *(_QWORD *)&v679[10] = v640;
      *(_DWORD *)v375 = v712;
      v375[4] = v713;
      LOWORD(v374) = v710;
      v376 = v590;
      v590[2] = v711;
      *v376 = (_WORD)v374;
      v681[12] = BYTE4(v616);
      *(_DWORD *)&v681[8] = v616;
      v377 = v588;
      *v588 = v768;
      *(_DWORD *)((char *)v377 + 7) = *(_DWORD *)((char *)&v768 + 7);
      *(_QWORD *)&v682[11] = v372;
      v378 = v589;
      *v589 = 0;
      v378[1] = 0;
      v363 = v671;
LABEL_364:
      pqpush_rankAndFetchInfo_t((uint64_t)v599, (uint64_t)v363);
    }
    v298 = v613;
    v297 = v614;
LABEL_366:
    v300 += 4;
    v299 = (int *)((char *)v299 + 5);
    v294 += 20;
    ++v296;
    ++v293;
    ++v295;
    if (--v645)
      continue;
    break;
  }
  pthread_rwlock_unlock(v597);
  a7 = v643;
  if (!(_QWORD)v643)
  {
    if (v619)
      _Block_release((const void *)v619);
    if (v59[804] < 5)
      goto LABEL_558;
    v404 = *__error();
    v405 = _SILogForLogForCategory(1);
    if (os_log_type_enabled(v405, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v756[0]) = 134217984;
      *(_QWORD *)((char *)v756 + 4) = v735;
      _os_log_impl(&dword_1B8270000, v405, OS_LOG_TYPE_DEFAULT, "readSDBForOids early exit %p", (uint8_t *)v756, 0xCu);
    }
LABEL_569:
    *__error() = v404;
    goto LABEL_558;
  }
  v57 = v735;
  *(_QWORD *)(*((_QWORD *)v735 + 1) + 512) += v643;
  v95 = v624;
  a4 = v625;
  v96 = v622;
  v94 = (_BYTE *)v644;
LABEL_84:
  v60 = (_QWORD *)&unk_1B862B000;
LABEL_112:
  v656[0] = MEMORY[0x1E0C809B0];
  v656[1] = v60[58];
  v656[2] = ___ZL14readSDBForOidsP20SISearchCtx_METADATAPxPtP16ci_rankingbits_sP17ci_tc_distances_tP21ci_vector_distances_tmPhP19PartialQueryResultsP14__MDPlistBytesbb_block_invoke;
  v656[3] = &__block_descriptor_tmp_94;
  v657 = v96;
  v656[4] = v57;
  v656[5] = v629;
  v656[6] = v628;
  v656[7] = v646;
  v131 = v656;
  v656[8] = v627;
  v656[9] = a4;
LABEL_113:
  v148 = v59;
  *(_QWORD *)&v643 = v131;
  if (v617 && !*((_BYTE *)v57 + 641) && !v94)
  {
    v94 = malloc_type_malloc(a7, 0x100004077774924uLL);
    v149 = 0;
    v150 = (_BYTE *)(a4 + 69);
    while (!v95)
    {
      if (a4)
        goto LABEL_124;
      v151 = 0;
LABEL_131:
      v94[v149++] = v151;
      v150 += 80;
      if (a7 == v149)
      {
        v57 = v735;
        goto LABEL_133;
      }
    }
    v151 = v95[v149] != 0;
    if (v95[v149])
      v152 = 1;
    else
      v152 = a4 == 0;
    if (v152)
      goto LABEL_131;
LABEL_124:
    if (*v150)
      v153 = *(v150 - 1) == 0;
    else
      v153 = *(_OWORD *)(v150 - 37) == 0;
    v151 = !v153;
    goto LABEL_131;
  }
LABEL_133:
  *(_QWORD *)&v644 = v94;
  v154 = *((_QWORD *)v57 + 13);
  do
  {
    v155 = v154;
    v154 = *(_QWORD *)(v154 + 80);
  }
  while (v154);
  v156 = *(_QWORD *)(v155 + 40);
  v654[0] = MEMORY[0x1E0C809B0];
  v157 = v60[58];
  v654[1] = v157;
  v654[2] = ___ZL14readSDBForOidsP20SISearchCtx_METADATAPxPtP16ci_rankingbits_sP17ci_tc_distances_tP21ci_vector_distances_tmPhP19PartialQueryResultsP14__MDPlistBytesbb_block_invoke_2;
  v654[3] = &__block_descriptor_tmp_95;
  v654[4] = &v733;
  v654[5] = v618;
  v655 = v610;
  v654[6] = v156;
  v654[7] = a4;
  v654[8] = v57;
  v158 = CFAbsoluteTimeGetCurrent();
  kdebug_trace();
  Log = _MDPerf_QueryLog();
  v160 = v735;
  v161 = *((_QWORD *)v735 + 1);
  if (v161 + 1 >= 2)
  {
    v175 = Log;
    v176 = os_signpost_enabled(Log);
    v162 = v626;
    if (v176)
    {
      v177 = *(_QWORD *)(v161 + 608);
      v178 = qos_class_self();
      LODWORD(v756[0]) = 134218240;
      *(_QWORD *)((char *)v756 + 4) = v177;
      WORD6(v756[0]) = 1024;
      *(_DWORD *)((char *)v756 + 14) = v178;
      _os_signpost_emit_with_name_impl(&dword_1B8270000, v175, OS_SIGNPOST_INTERVAL_BEGIN, v161, "QueryReadSDB", "QueryId=%{signpost.description:attribute}lld CurrentQoS=%{signpost.description:attribute}x", (uint8_t *)v756, 0x12u);
      v160 = v735;
    }
  }
  else
  {
    v162 = v626;
  }
  PartialQueryResults::attributeIdVector(v162, *(int **)(*((_QWORD *)v160 + 3) + 1184));
  v163 = *((_QWORD *)v735 + 5);
  v164 = (v163 & 0x80) == 0;
  v165 = *((_QWORD *)v735 + 3);
  v166 = *(_BYTE *)(v165 + 6586);
  v645 = a7;
  if ((v166 & 4) != 0)
    v167 = 8 * *(_BYTE *)(v165 + 2072);
  else
    v167 = 0;
  if (v611)
    v168 = 6;
  else
    v168 = 4;
  v169 = *(unsigned __int8 *)v162;
  v170 = *((_QWORD *)v162 + 29);
  *(_QWORD *)&v642 = (char *)v162 + 232;
  if (!v169)
  {
    if (!v170)
      goto LABEL_402;
    if (*((_QWORD *)v162 + 24))
      goto LABEL_386;
    v173 = *((_QWORD *)v162 + 12);
    if (!v173)
    {
      v174 = (const __CFArray *)*((_QWORD *)v162 + 15);
      if (v174)
      {
        SIFlattenArrayToCStringVector(v174, (char **)v162 + 12, (size_t *)v162 + 30, (CFIndex *)v642);
        v173 = *((_QWORD *)v162 + 12);
        if (!v173)
          goto LABEL_512;
      }
      else
      {
        v173 = 0;
      }
    }
    PartialQueryResults::setupCannedAttributeVector((uint64_t)v162, v173, (_QWORD *)v162 + 24, (_QWORD *)v162 + 1);
    goto LABEL_386;
  }
  if (!v170)
    goto LABEL_402;
  if (!*((_QWORD *)v162 + 25))
  {
    v171 = *((_QWORD *)v162 + 13);
    if (!v171)
    {
      v172 = (const __CFArray *)*((_QWORD *)v162 + 16);
      if (v172)
      {
        *(_QWORD *)&v756[0] = 0;
        SIFlattenArrayToCStringVector(v172, (char **)v162 + 13, (size_t *)v756, (CFIndex *)&v768);
        v171 = *((_QWORD *)v162 + 13);
      }
      else
      {
        v171 = 0;
      }
    }
    PartialQueryResults::setupCannedAttributeVector((uint64_t)v162, v171, (_QWORD *)v162 + 25, v756);
    v164 = (v163 & 0x80) == 0;
  }
LABEL_386:
  v406 = *((_QWORD *)v162 + 29);
  if (!*(_BYTE *)v162)
  {
    if (!v406 || *((_QWORD *)v162 + 22))
      goto LABEL_402;
    v409 = *((_QWORD *)v162 + 12);
    if (!v409)
    {
      v410 = (const __CFArray *)*((_QWORD *)v162 + 15);
      if (v410)
      {
        SIFlattenArrayToCStringVector(v410, (char **)v162 + 12, (size_t *)v162 + 30, (CFIndex *)v642);
        v409 = *((_QWORD *)v162 + 12);
        if (!v409)
          goto LABEL_497;
      }
      else
      {
        v409 = 0;
      }
    }
    PartialQueryResults::setupCannedCollectAttributeVector((uint64_t)v162, v409, (_QWORD *)v162 + 22, (_QWORD *)v162 + 2);
    goto LABEL_402;
  }
  if (v406 && !*((_QWORD *)v162 + 23))
  {
    v407 = *((_QWORD *)v162 + 13);
    if (!v407)
    {
      v408 = (const __CFArray *)*((_QWORD *)v162 + 16);
      if (v408)
      {
        *(_QWORD *)&v756[0] = 0;
        SIFlattenArrayToCStringVector(v408, (char **)v162 + 13, (size_t *)v756, (CFIndex *)&v768);
        v407 = *((_QWORD *)v162 + 13);
      }
      else
      {
        v407 = 0;
      }
    }
    PartialQueryResults::setupCannedCollectAttributeVector((uint64_t)v162, v407, (_QWORD *)v162 + 23, v756);
  }
LABEL_402:
  v411 = v735;
  if (*((_DWORD *)v735 + 40) == 3)
  {
    PartialQueryResults::completionAttributeIdVector((uint64_t)v162, *(int **)(*((_QWORD *)v735 + 3) + 1184));
    if ((*((_BYTE *)v162 + 321) & 1) == 0)
    {
      if (v59[804] >= 5)
      {
        v569 = *__error();
        v570 = _SILogForLogForCategory(1);
        if (os_log_type_enabled(v570, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v756[0]) = 0;
          _os_log_impl(&dword_1B8270000, v570, OS_LOG_TYPE_DEFAULT, "Will generate spotlight completions", (uint8_t *)v756, 2u);
        }
        *__error() = v569;
      }
      dispatch_get_global_queue(-32768, 0);
      md_deadline_once_start();
    }
    v411 = v735;
    if (!*((_QWORD *)v735 + 44))
    {
      v412 = v622;
      v413 = malloc_type_calloc(1uLL, 24 * v622 + 8, 0x7BAF06EDuLL);
      v411 = v735;
      *((_QWORD *)v735 + 44) = v413;
      v413[2] = v412;
      if (v412)
      {
        v414 = 0;
        do
        {
          v415 = *((_QWORD *)v735 + 44) + 24 * (unsigned __int16)v414;
          *(_OWORD *)(v415 + 16) = xmmword_1B8631BB0;
          *(_QWORD *)(v415 + 8) = 0;
          ++v414;
        }
        while (v412 > (unsigned __int16)v414);
        v411 = v735;
      }
    }
  }
  prepareFieldIds(v411, v162);
  v416 = v735;
  if (*((_DWORD *)v735 + 40) == 3)
  {
    v417 = v644;
    if ((*((_BYTE *)v162 + 321) & 1) == 0)
    {
      SILanguageModelReserve();
      v417 = v644;
      v416 = v735;
    }
  }
  else
  {
    v417 = v644;
  }
  v418 = *((_QWORD *)v416 + 114);
  if (!v418)
    goto LABEL_444;
  if (*(_DWORD *)v418 != 3506)
  {
    v574 = __si_assert_copy_extra_268();
    v572 = v574;
    v575 = "";
    if (v574)
      v575 = v574;
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 693, v575);
    goto LABEL_595;
  }
  if (!*(_BYTE *)(v418 + 74))
  {
    v565 = __si_assert_copy_extra_2151(0, -1);
    v502 = v565;
    v566 = "";
    if (v565)
      v566 = v565;
    __message_assert("%s:%u: failed assertion '%s' %s ", "sdb2.c", 12576, "dboi->isSuspended", v566);
    goto LABEL_573;
  }
  *(_BYTE *)(v418 + 75) = 0;
  *(_QWORD *)(v418 + 184) = 0;
  v420 = *(_QWORD *)(v418 + 24);
  v419 = *(void **)(v418 + 32);
  if (*(_QWORD *)(v418 + 136) < v645 || !v419)
  {
    free(v419);
    v421 = 32 * v645;
    v422 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 32 * v645, 0x6085D6BuLL);
    if (v422)
    {
      *(_QWORD *)(v418 + 32) = v422;
      madvise(v422, v421, 3);
      goto LABEL_422;
    }
    if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
    {
      LOWORD(v756[0]) = 0;
      _os_log_fault_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "allocation function returned null", (uint8_t *)v756, 2u);
    }
    *(_QWORD *)(v418 + 32) = 0;
    db_obj_iter_release(*((_QWORD *)v735 + 114));
    v416 = v735;
    v417 = (uint64_t)v624;
    v162 = v626;
LABEL_444:
    v423 = v645;
    v428 = db_obj_iter_create_with_filter(*(int **)(*((_QWORD *)v416 + 3) + 1184), v645, (uint64_t)v618, (uint64_t)v629, v417, (v168 | v167) | v164, v654, (const void *)v643, *((_QWORD *)v416 + 115));
    *((_QWORD *)v735 + 114) = v428;
    if (*(_DWORD *)v428 == 3506)
    {
      v428[72] = 1;
      v432 = v615;
      v429 = v148;
      goto LABEL_446;
    }
    v576 = __si_assert_copy_extra_268();
    v572 = v576;
    v577 = "";
    if (v576)
      v577 = v576;
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 707, v577);
LABEL_595:
    free(v572);
LABEL_574:
    v567 = 2989;
    goto LABEL_580;
  }
LABEL_422:
  v423 = v645;
  *(_QWORD *)(v418 + 136) = v645;
  atomic_store(0, (unint64_t *)(v418 + 144));
  *(_QWORD *)(v418 + 160) = 0;
  v424 = *(const void **)(v418 + 48);
  if (v424)
    _Block_release(v424);
  *(_QWORD *)(v418 + 48) = _Block_copy((const void *)v643);
  v425 = *(const void **)(v418 + 40);
  v426 = (uint64_t)v629;
  v427 = (uint64_t)v618;
  if (v425)
    _Block_release(v425);
  v428 = _Block_copy(v654);
  *(_QWORD *)(v418 + 40) = v428;
  v429 = v148;
  if ((*(_BYTE *)(v420 + 804) & 1) != 0 && (v163 & 0x80) != 0)
  {
    v430 = 0;
    v431 = 16;
    v162 = v626;
    v432 = v615;
    v433 = v644;
    do
    {
      v434 = (_QWORD *)(*(_QWORD *)(v418 + 32) + v431);
      *(v434 - 2) = *(_QWORD *)(v427 + 8 * v430);
      *v434 = 0;
      if (v433)
        v435 = *(_BYTE *)(v433 + v430);
      else
        v435 = 0;
      *(_BYTE *)(*(_QWORD *)(v418 + 32) + v431 + 8) = *(_BYTE *)(*(_QWORD *)(v418 + 32) + v431 + 8) & 0xFB | (4 * (v435 & 1));
      v436 = *(_QWORD *)(v418 + 32) + v431;
      *(_BYTE *)(v436 + 9) = 0;
      *(_BYTE *)(v436 + 8) &= ~1u;
      *(_QWORD *)(*(_QWORD *)(v418 + 32) + v431) |= 0x400000000uLL;
      *(_BYTE *)(*(_QWORD *)(v418 + 32) + v431 + 8) &= ~2u;
      v437 = (uint64_t *)(*(_QWORD *)(v418 + 32) + v431);
      v438 = *v437 | 0x3FFFFFFFCLL;
      *(v437 - 1) = v430;
      *v437 = v438;
      if (v426)
        v439 = (*(_WORD *)(v426 + 2 * v430) & 0xFFDF) == 17;
      else
        v439 = 3;
      *(_QWORD *)(*(_QWORD *)(v418 + 32) + v431) = *(_QWORD *)(*(_QWORD *)(v418 + 32) + v431) & 0xFFFFFFFFFFFFFFFCLL | v439;
      ++v430;
      v431 += 32;
    }
    while (v423 != v430);
  }
  else
  {
    v162 = v626;
    v440 = v644;
    if ((_QWORD)v644)
    {
      v441 = 0;
      v442 = 16;
      v432 = v615;
      do
      {
        v443 = (_QWORD *)(*(_QWORD *)(v418 + 32) + v442);
        *(v443 - 2) = *(_QWORD *)(v427 + 8 * v441);
        *v443 = 0;
        *(_BYTE *)(*(_QWORD *)(v418 + 32) + v442 + 8) = *(_BYTE *)(*(_QWORD *)(v418 + 32) + v442 + 8) & 0xFB | (4 * (*(_BYTE *)(v440 + v441) & 1));
        v444 = *(_QWORD *)(v418 + 32) + v442;
        *(_BYTE *)(v444 + 9) = 0;
        *(_BYTE *)(v444 + 8) &= ~1u;
        *(_QWORD *)(*(_QWORD *)(v418 + 32) + v442) |= 0x400000000uLL;
        *(_BYTE *)(*(_QWORD *)(v418 + 32) + v442 + 8) &= ~2u;
        v445 = (uint64_t *)(*(_QWORD *)(v418 + 32) + v442);
        v446 = *v445 | 0x3FFFFFFFCLL;
        *(v445 - 1) = v441;
        *v445 = v446;
        *(_QWORD *)(*(_QWORD *)(v418 + 32) + v442) &= 0xFFFFFFFFFFFFFFFCLL;
        ++v441;
        v442 += 32;
      }
      while (v423 != v441);
    }
    else
    {
      v482 = 0;
      v483 = 16;
      v432 = v615;
      do
      {
        v484 = (_QWORD *)(*(_QWORD *)(v418 + 32) + v483);
        *(v484 - 2) = *(_QWORD *)(v427 + 8 * v482);
        *v484 = 0;
        *(_BYTE *)(*(_QWORD *)(v418 + 32) + v483 + 8) &= ~4u;
        v485 = *(_QWORD *)(v418 + 32) + v483;
        *(_BYTE *)(v485 + 9) = 0;
        *(_BYTE *)(v485 + 8) &= ~1u;
        *(_QWORD *)(*(_QWORD *)(v418 + 32) + v483) |= 0x400000000uLL;
        *(_BYTE *)(*(_QWORD *)(v418 + 32) + v483 + 8) &= ~2u;
        v486 = (uint64_t *)(*(_QWORD *)(v418 + 32) + v483);
        v487 = *v486 | 0x3FFFFFFFCLL;
        *(v486 - 1) = v482;
        *v486 = v487;
        *(_QWORD *)(*(_QWORD *)(v418 + 32) + v483) &= 0xFFFFFFFFFFFFFFFCLL;
        ++v482;
        v483 += 32;
      }
      while (v423 != v482);
    }
  }
LABEL_446:
  v447 = gCPUCount >> 1;
  if (gCPUCount >> 1 <= 1)
    v447 = 1;
  if (gCPUCount >= 0x100)
    v448 = 128;
  else
    v448 = v447;
  v449 = v735;
  if (v432 || *((_DWORD *)v735 + 40) == 4 || (*(_BYTE *)(*((_QWORD *)v735 + 3) + 6586) & 4) == 0)
  {
    v450 = 1;
  }
  else if (v423 < v448)
  {
    v450 = 1;
  }
  else
  {
    v450 = v448;
  }
  MEMORY[0x1E0C80A78](v428);
  v452 = (char *)&v578 - ((v451 + 15) & 0x7FFFFFFF0);
  *(_QWORD *)&v641 = v451;
  bzero(v452, v451);
  ++*(_QWORD *)(*((_QWORD *)v449 + 1) + 480);
  v453 = *((_QWORD *)v449 + 114);
  *(_QWORD *)&v643 = v450;
  db_obj_iter_create_subiterators(v453, v450, v452, v454, v455, v456);
  v457 = *__error();
  v458 = _SILogForLogForCategory(1);
  v459 = 2 * (v429[804] < 4);
  if (os_log_type_enabled(v458, v459))
  {
    v460 = CFAbsoluteTimeGetCurrent();
    LODWORD(v756[0]) = 134218240;
    *(_QWORD *)((char *)v756 + 4) = v423;
    WORD6(v756[0]) = 2048;
    *(double *)((char *)v756 + 14) = v460 - v158;
    _os_log_impl(&dword_1B8270000, v458, v459, "Created iterator for %ld oids in %f seconds!", (uint8_t *)v756, 0x16u);
  }
  *__error() = v457;
  v461 = v735;
  if (v617)
  {
    if (!*((_BYTE *)v735 + 642))
    {
      preparePostCheckQueries(&v735);
      v461 = v735;
    }
    if (!*((_BYTE *)v461 + 643))
    {
      if (*((_DWORD *)v461 + 208))
      {
        v462 = 0;
        v463 = 0;
        do
        {
          v464 = *((_QWORD *)v461 + 105);
          v465 = *(_QWORD **)(v464 + v462 + 8);
          if (v465)
          {
            *(_QWORD *)&v768 = MEMORY[0x1E0C809B0];
            *((_QWORD *)&v768 + 1) = v157;
            v769 = ___ZL23cacheQPDataForPostCheckRP20SISearchCtx_METADATAP10query_node_block_invoke;
            v770 = &__block_descriptor_tmp_124;
            v771 = &v735;
            *(_QWORD *)&v756[0] = MEMORY[0x1E0C809B0];
            *((_QWORD *)&v756[0] + 1) = v157;
            *(_QWORD *)&v756[1] = __db_query_tree_apply_block_block_invoke;
            *((_QWORD *)&v756[1] + 1) = &unk_1E6E377F8;
            *(_QWORD *)&v756[2] = &v768;
            db_query_tree_apply_block_with_meta(v465, (uint64_t)v756, 0);
            v461 = v735;
            v464 = *((_QWORD *)v735 + 105);
          }
          v466 = *(_QWORD **)(v464 + v462 + 24);
          if (v466)
          {
            *(_QWORD *)&v768 = MEMORY[0x1E0C809B0];
            *((_QWORD *)&v768 + 1) = v157;
            v769 = ___ZL23cacheQPDataForPostCheckRP20SISearchCtx_METADATAP10query_node_block_invoke;
            v770 = &__block_descriptor_tmp_124;
            v771 = &v735;
            *(_QWORD *)&v756[0] = MEMORY[0x1E0C809B0];
            *((_QWORD *)&v756[0] + 1) = v157;
            *(_QWORD *)&v756[1] = __db_query_tree_apply_block_block_invoke;
            *((_QWORD *)&v756[1] + 1) = &unk_1E6E377F8;
            *(_QWORD *)&v756[2] = &v768;
            db_query_tree_apply_block_with_meta(v466, (uint64_t)v756, 0);
            v461 = v735;
            v464 = *((_QWORD *)v735 + 105);
          }
          v467 = *(_QWORD **)(v464 + v462 + 16);
          if (v467)
          {
            *(_QWORD *)&v768 = MEMORY[0x1E0C809B0];
            *((_QWORD *)&v768 + 1) = v157;
            v769 = ___ZL23cacheQPDataForPostCheckRP20SISearchCtx_METADATAP10query_node_block_invoke;
            v770 = &__block_descriptor_tmp_124;
            v771 = &v735;
            *(_QWORD *)&v756[0] = MEMORY[0x1E0C809B0];
            *((_QWORD *)&v756[0] + 1) = v157;
            *(_QWORD *)&v756[1] = __db_query_tree_apply_block_block_invoke;
            *((_QWORD *)&v756[1] + 1) = &unk_1E6E377F8;
            *(_QWORD *)&v756[2] = &v768;
            db_query_tree_apply_block_with_meta(v467, (uint64_t)v756, 0);
            v461 = v735;
            v464 = *((_QWORD *)v735 + 105);
          }
          v468 = *(_QWORD **)(v464 + v462);
          if (v468)
          {
            *(_QWORD *)&v768 = MEMORY[0x1E0C809B0];
            *((_QWORD *)&v768 + 1) = v157;
            v769 = ___ZL23cacheQPDataForPostCheckRP20SISearchCtx_METADATAP10query_node_block_invoke;
            v770 = &__block_descriptor_tmp_124;
            v771 = &v735;
            *(_QWORD *)&v756[0] = MEMORY[0x1E0C809B0];
            *((_QWORD *)&v756[0] + 1) = v157;
            *(_QWORD *)&v756[1] = __db_query_tree_apply_block_block_invoke;
            *((_QWORD *)&v756[1] + 1) = &unk_1E6E377F8;
            *(_QWORD *)&v756[2] = &v768;
            db_query_tree_apply_block_with_meta(v468, (uint64_t)v756, 0);
            v461 = v735;
          }
          ++v463;
          v462 += 48;
        }
        while (v463 < *((unsigned int *)v461 + 208));
      }
      *((_BYTE *)v461 + 643) = 1;
      v162 = v626;
      v423 = v645;
      v432 = v615;
    }
  }
  v469 = *((_DWORD *)v461 + 212);
  v41 = v469 == 1;
  v470 = v469 > 1;
  if (!v41 || v625 == 0)
    v472 = v470;
  else
    v472 = 2;
  v473 = *(_QWORD *)(*((_QWORD *)v461 + 3) + 1184);
  v474 = (uint64_t *)v642;
  v475 = *(_QWORD *)v642;
  v477 = CFAbsoluteTimeGetCurrent();
  v478 = *v474;
  if (*v474)
  {
    if (*((_QWORD *)v162 + 18)
      || (v479 = PartialQueryResults::attributeIdVector(v162, *(int **)(*((_QWORD *)v735 + 3) + 1184)),
          PartialQueryResults::setupFieldIdVector((uint64_t)v162, v479, (size_t *)v162 + 19, (void **)v162 + 18, 0),
          PartialQueryResults::setupFieldIdVector((uint64_t)v162, v479, (size_t *)v162 + 21, (void **)v162 + 20, 1),
          (v478 = *((_QWORD *)v162 + 29)) != 0))
    {
      if (!*((_QWORD *)v162 + 28))
      {
        if (*(_BYTE *)v162)
        {
          v480 = *((_QWORD *)v162 + 13);
          if (v480)
            goto LABEL_500;
          v481 = (const __CFArray *)*((_QWORD *)v162 + 16);
          if (v481)
          {
            *(_QWORD *)&v756[0] = 0;
            SIFlattenArrayToCStringVector(v481, (char **)v162 + 13, (size_t *)v756, (CFIndex *)&v768);
            v480 = *((_QWORD *)v162 + 13);
            goto LABEL_500;
          }
LABEL_499:
          v480 = 0;
          goto LABEL_500;
        }
        v480 = *((_QWORD *)v162 + 12);
        if (v478 && !v480)
        {
          v488 = (const __CFArray *)*((_QWORD *)v162 + 15);
          if (!v488)
            goto LABEL_499;
          SIFlattenArrayToCStringVector(v488, (char **)v162 + 12, (size_t *)v162 + 30, (CFIndex *)v642);
          v480 = *((_QWORD *)v162 + 12);
          if (!v480)
          {
LABEL_497:
            v489 = __si_assert_copy_extra_268();
            __message_assert_272((uint64_t)v489, v490, v491, v492, v493, v494, v495, v496, (char)"SISearchCtx.h");
            free(v489);
            if (__valid_fs(-1))
              v497 = 2989;
            else
              v497 = 3072;
            *(_DWORD *)v497 = -559038737;
            abort();
          }
        }
LABEL_500:
        PartialQueryResults::setupFixedFunctionVector((uint64_t)v162, v480, (_QWORD *)v162 + 28);
        v478 = *((_QWORD *)v162 + 29);
      }
    }
  }
  if (!*(_BYTE *)v162)
  {
    if (!v478)
      goto LABEL_518;
    v498 = (_QWORD *)((char *)v162 + 192);
    if (*((_QWORD *)v162 + 24))
      goto LABEL_518;
    v499 = *((_QWORD *)v162 + 12);
    if (!v499)
    {
      v501 = (const __CFArray *)*((_QWORD *)v162 + 15);
      if (v501)
      {
        SIFlattenArrayToCStringVector(v501, (char **)v162 + 12, (size_t *)v162 + 30, (CFIndex *)v642);
        v499 = *((_QWORD *)v162 + 12);
        if (!v499)
        {
LABEL_512:
          v502 = __si_assert_copy_extra_268();
          __message_assert_272((uint64_t)v502, v503, v504, v505, v506, v507, v508, v509, (char)"SISearchCtx.h");
LABEL_573:
          free(v502);
          if (__valid_fs(-1))
            goto LABEL_574;
          v567 = 3072;
LABEL_580:
          *(_DWORD *)v567 = -559038737;
          abort();
        }
      }
      else
      {
        v499 = 0;
      }
    }
    v510 = (_QWORD *)((char *)v162 + 8);
    goto LABEL_517;
  }
  if (v478)
  {
    v498 = (_QWORD *)((char *)v162 + 200);
    if (!*((_QWORD *)v162 + 25))
    {
      v499 = *((_QWORD *)v162 + 13);
      if (!v499)
      {
        v500 = (const __CFArray *)*((_QWORD *)v162 + 16);
        if (v500)
        {
          *(_QWORD *)&v756[0] = 0;
          SIFlattenArrayToCStringVector(v500, (char **)v162 + 13, (size_t *)v756, (CFIndex *)&v768);
          v499 = *((_QWORD *)v162 + 13);
        }
        else
        {
          v499 = 0;
        }
      }
      v510 = v756;
LABEL_517:
      PartialQueryResults::setupCannedAttributeVector((uint64_t)v162, v499, v498, v510);
    }
  }
LABEL_518:
  *(_QWORD *)&v642 = v475;
  *(_QWORD *)&v640 = v473;
  v511 = v472;
  *(_QWORD *)&v639 = &v578;
  v512 = v641;
  v513 = MEMORY[0x1E0C80A78](v476);
  v514 = (uint64_t *)((char *)&v578 - ((v512 + 15) & 0x7FFFFFFF0));
  v515 = MEMORY[0x1E0C80A78](v513);
  v517 = (uint64_t *)((char *)&v578 - v516);
  MEMORY[0x1E0C80A78](v515);
  v519 = (char *)&v578 - v518;
  bzero((char *)&v578 - v518, v512);
  bzero(v514, v512);
  bzero(v517, v512);
  v520 = v735;
  if (*((_DWORD *)v735 + 40) == 4)
  {
    v521 = v619;
    v522 = v511;
    if (!*(_BYTE *)(*((_QWORD *)v735 + 13) + 99) && !v432 && !v619)
      goto LABEL_522;
LABEL_536:
    v531 = v643;
    if ((unint64_t)v643 <= 1)
      v531 = 1;
    v540 = v519;
    v532 = v609;
    v534 = v607;
    v533 = v608;
    v536 = v605;
    v535 = v606;
    v538 = v603;
    v537 = v604;
    v539 = v640;
    do
    {
      *v540++ = v432;
      --v531;
    }
    while (v531);
  }
  else
  {
    v521 = v619;
    v522 = v511;
    if (v432 | v619)
      goto LABEL_536;
LABEL_522:
    v523 = 0;
    if ((unint64_t)v643 <= 1)
      v524 = 1;
    else
      v524 = v643;
    do
    {
      v525 = *((_QWORD *)v735 + 13);
      v526 = v525;
      do
      {
        v527 = v526;
        v526 = *(_QWORD *)(v526 + 80);
      }
      while (v526);
      v528 = *(_QWORD *)(v525 + 80);
      if (!v528)
        goto LABEL_532;
      v529 = 0;
      do
      {
        v529 ^= *(_DWORD *)(v525 + 104) == 0;
        v525 = v528;
        v528 = *(_QWORD *)(v528 + 80);
      }
      while (v528);
      if ((v529 & 1) != 0)
        v530 = 3553;
      else
LABEL_532:
        v530 = 2781;
      *(_QWORD *)&v519[8 * v523] = PartialQueryResults::start(v162, *(_DWORD *)(*(_QWORD *)(v527 + 8) + 80), v530, *(_QWORD *)(*(_QWORD *)&v452[8 * v523] + 56), v523);
      ++v523;
    }
    while (v523 != v524);
    LOBYTE(v531) = 1;
    v520 = v735;
    v423 = v645;
    v521 = v619;
    v532 = v609;
    v534 = v607;
    v533 = v608;
    v536 = v605;
    v535 = v606;
    v538 = v603;
    v537 = v604;
    v539 = v640;
  }
  v647[0] = MEMORY[0x1E0C809B0];
  v647[1] = v157;
  v647[2] = ___ZL14readSDBForOidsP20SISearchCtx_METADATAPxPtP16ci_rankingbits_sP17ci_tc_distances_tP21ci_vector_distances_tmPhP19PartialQueryResultsP14__MDPlistBytesbb_block_invoke_97;
  v647[3] = &unk_1E6E30058;
  v647[8] = v521;
  v647[9] = v520;
  v647[10] = v452;
  v647[11] = v519;
  v651 = v538;
  v647[12] = &v734;
  v647[13] = v423;
  v647[14] = v539;
  v647[15] = v642;
  v647[4] = v536;
  v647[5] = v535;
  v647[6] = v534;
  v647[7] = v533;
  v647[16] = v628;
  v647[17] = v629;
  v647[18] = v624;
  v647[19] = v646;
  v648 = v622;
  v649 = v522;
  v647[20] = v625;
  v647[21] = v613;
  v647[22] = v614;
  v647[23] = v162;
  v650 = v537;
  v652 = v532;
  v653 = v531;
  v647[24] = v627;
  v647[25] = v514;
  v647[26] = v517;
  v541 = v643;
  dispatch_apply(v643, 0, v647);
  v542 = *__error();
  v543 = _SILogForLogForCategory(1);
  v544 = 2 * (dword_1EF19FC90 < 4);
  if (os_log_type_enabled(v543, v544))
  {
    v545 = CFAbsoluteTimeGetCurrent();
    LODWORD(v756[0]) = 134218240;
    *(_QWORD *)((char *)v756 + 4) = v423;
    WORD6(v756[0]) = 2048;
    *(double *)((char *)v756 + 14) = v545 - v477;
    _os_log_impl(&dword_1B8270000, v543, v544, "Read/evaluated %ld dbos in %f seconds!", (uint8_t *)v756, 0x16u);
  }
  *__error() = v542;
  if (v619)
    _Block_release((const void *)v619);
  v546 = (_DWORD *)*((_QWORD *)v735 + 114);
  if (*v546 != 3506)
  {
    v571 = __si_assert_copy_extra_268();
    v572 = v571;
    v573 = "";
    if (v571)
      v573 = v571;
    __message_assert("%s:%u: Unexpected code path %s ", "core-db.c", 702, v573);
    goto LABEL_595;
  }
  db2_obj_iter_suspend(v546);
  if (v541 <= 1)
    v547 = 1;
  else
    v547 = v541;
  v548 = v735;
  do
  {
    v549 = *v514++;
    *(_QWORD *)(*((_QWORD *)v548 + 1) + 464) += v549;
    v550 = *v517++;
    *(_QWORD *)(*((_QWORD *)v548 + 1) + 488) += v550;
    --v547;
  }
  while (v547);
  while (1)
  {
    v551 = OSAtomicDequeue(&v734, 0);
    if (!v551)
      break;
    free(v551);
  }
  kdebug_trace();
  v552 = _MDPerf_QueryLog();
  v553 = v735;
  v554 = *((_QWORD *)v735 + 1);
  if (v554 + 1 >= 2)
  {
    v556 = v552;
    v555 = (_DWORD *)&unk_1EF19F000;
    if (os_signpost_enabled(v552))
    {
      v557 = *(_QWORD *)(v554 + 608);
      v558 = qos_class_self();
      LODWORD(v756[0]) = 134218240;
      *(_QWORD *)((char *)v756 + 4) = v557;
      WORD6(v756[0]) = 1024;
      *(_DWORD *)((char *)v756 + 14) = v558;
      _os_signpost_emit_with_name_impl(&dword_1B8270000, v556, OS_SIGNPOST_INTERVAL_END, v554, "QueryReadSDB", "QueryId=%{signpost.description:attribute}lld CurrentQoS=%{signpost.description:attribute}x", (uint8_t *)v756, 0x12u);
      v553 = v735;
    }
  }
  else
  {
    v555 = (int *)&unk_1EF19F000;
  }
  if (*((_DWORD *)v553 + 40) == 3 && (*((_BYTE *)v626 + 321) & 1) == 0)
    SILanguageModelUnreserve();
  if (v555[804] >= 5)
  {
    v404 = *__error();
    v564 = _SILogForLogForCategory(1);
    if (os_log_type_enabled(v564, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v756[0]) = 134217984;
      *(_QWORD *)((char *)v756 + 4) = v735;
      _os_log_impl(&dword_1B8270000, v564, OS_LOG_TYPE_DEFAULT, "readSDBForOids exit %p", (uint8_t *)v756, 0xCu);
    }
    goto LABEL_569;
  }
LABEL_558:
  free((void *)v644);
}

__n128 ___ZL11emitResultsP20SISearchCtx_METADATAP19PartialQueryResultsb_block_invoke_3(_QWORD *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  __int16 v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  __n128 result;

  v2 = a1[6];
  v3 = a1[7];
  v4 = *(unsigned __int8 *)(*(_QWORD *)(a1[4] + 8) + 24);
  v5 = *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24);
  v6 = a1[8];
  v7 = a1[9];
  v8 = a1[11];
  *(_QWORD *)(a1[10] + 8 * v5) = *(_QWORD *)(a2 + 120);
  *(_WORD *)(v6 + 2 * v5) = v4;
  v9 = v8 + 80 * v5;
  *(_OWORD *)v9 = *(_OWORD *)a2;
  v11 = *(_OWORD *)(a2 + 48);
  v10 = *(_OWORD *)(a2 + 64);
  v12 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(v9 + 16) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(v9 + 32) = v12;
  *(_OWORD *)(v9 + 48) = v11;
  *(_OWORD *)(v9 + 64) = v10;
  v13 = *(_QWORD *)(a2 + 88);
  *(_QWORD *)v9 = *(_QWORD *)(a2 + 80);
  *(_QWORD *)(v9 + 8) = v13;
  v14 = v2 + 5 * v5;
  LODWORD(v9) = *(_DWORD *)(a2 + 96);
  *(_BYTE *)(v14 + 4) = *(_BYTE *)(a2 + 100);
  *(_DWORD *)v14 = v9;
  result = *(__n128 *)(a2 + 104);
  *(__n128 *)(v3 + 16 * v5) = result;
  *(_BYTE *)(v7 + v5) = *(_BYTE *)(a2 + 128);
  ++*(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24);
  return result;
}

__n128 ___ZL11emitResultsP20SISearchCtx_METADATAP19PartialQueryResultsb_block_invoke_4(_QWORD *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  __int16 v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  __n128 result;

  v2 = a1[6];
  v3 = a1[7];
  v4 = *(unsigned __int8 *)(*(_QWORD *)(a1[4] + 8) + 24);
  v5 = *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24);
  v6 = a1[8];
  v7 = a1[9];
  v8 = a1[11];
  *(_QWORD *)(a1[10] + 8 * v5) = *(_QWORD *)(a2 + 120);
  *(_WORD *)(v6 + 2 * v5) = v4;
  v9 = v8 + 80 * v5;
  *(_OWORD *)v9 = *(_OWORD *)a2;
  v11 = *(_OWORD *)(a2 + 48);
  v10 = *(_OWORD *)(a2 + 64);
  v12 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(v9 + 16) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(v9 + 32) = v12;
  *(_OWORD *)(v9 + 48) = v11;
  *(_OWORD *)(v9 + 64) = v10;
  v13 = *(_QWORD *)(a2 + 88);
  *(_QWORD *)v9 = *(_QWORD *)(a2 + 80);
  *(_QWORD *)(v9 + 8) = v13;
  v14 = v2 + 5 * v5;
  LODWORD(v9) = *(_DWORD *)(a2 + 96);
  *(_BYTE *)(v14 + 4) = *(_BYTE *)(a2 + 100);
  *(_DWORD *)v14 = v9;
  result = *(__n128 *)(a2 + 104);
  *(__n128 *)(v3 + 16 * v5) = result;
  *(_BYTE *)(v7 + v5) = *(_BYTE *)(a2 + 128);
  ++*(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24);
  return result;
}

uint64_t L1ComboQueueCount(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = a1[2];
  if (v1)
    v1 = *(_QWORD *)(v1 + 16) - 1;
  v2 = a1[1];
  if (v2)
    v2 = *(_QWORD *)(v2 + 16) - 1;
  v3 = *a1;
  if (*a1)
    v3 = *(_QWORD *)(v3 + 16) - 1;
  return v2 + v1 + v3;
}

BOOL ___ZL14readSDBForOidsP20SISearchCtx_METADATAPxPtP16ci_rankingbits_sP17ci_tc_distances_tP21ci_vector_distances_tmPhP19PartialQueryResultsP14__MDPlistBytesbb_block_invoke(uint64_t a1, uint64_t a2)
{
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  float v14;
  float v15;
  unsigned int v16;
  float v17;
  unsigned int v18;
  float v19;
  float v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  os_unfair_lock_s *v26;
  unint64_t v27;
  __int128 v28;
  __int128 v29;
  _OWORD v31[5];

  v3 = *(_DWORD *)(a1 + 80);
  if (v3)
  {
    v4 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 40) + 2 * a2);
    if (*(_BYTE *)(*(_QWORD *)(a1 + 32) + 650))
    {
      if (v3 <= v4)
        LOWORD(v3) = 0;
      else
        LOWORD(v3) = *(_WORD *)(*(_QWORD *)(a1 + 40) + 2 * a2);
    }
    else
    {
      v5 = v4 & 0xFFFFFFDF;
      if (v3 <= v5)
        LOWORD(v3) = 18;
      else
        LOWORD(v3) = v5;
    }
  }
  v6 = *(_QWORD *)(a1 + 56);
  if (*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8 * (unsigned __int16)v3) < v6)
    return 1;
  v7 = *(_QWORD *)(a1 + 72);
  v8 = *(_QWORD *)(a1 + 64) + 240 * (unsigned __int16)v3;
  v9 = (unint64_t *)(v7 + 80 * a2);
  v10 = *v9;
  v11 = v9[1];
  v12 = *(_QWORD *)(a1 + 32);
  if ((*(_OWORD *)(v12 + 400) & *(_OWORD *)v9) != 0)
  {
    v11 &= *(_QWORD *)(v12 + 424);
    v10 &= *(_QWORD *)(v12 + 416);
  }
  v13 = v7 + 80 * a2;
  v14 = *(float *)(v13 + 60);
  v15 = *(float *)(v13 + 64);
  if (*(_BYTE *)(v13 + 69))
  {
    if (v15 != 0.0)
      goto LABEL_14;
LABEL_17:
    v8 += 160;
    goto LABEL_18;
  }
  if (!(v10 | v11))
    goto LABEL_17;
LABEL_14:
  if (v14 == v15)
    v8 += 80;
LABEL_18:
  v16 = *(_DWORD *)(v13 + 48);
  v17 = *(float *)(v13 + 52);
  v18 = *(_DWORD *)(v8 + 48);
  v19 = *(float *)(v8 + 52);
  if (*(_BYTE *)(v8 + 69))
  {
    v20 = *(float *)(v8 + 60);
    if (v20 < v14)
      return 1;
    if (v20 != v14)
    {
LABEL_33:
      v26 = *(os_unfair_lock_s **)(v12 + 928);
      v27 = *(_QWORD *)(v12 + 176);
      v28 = *((_OWORD *)v9 + 3);
      v31[2] = *((_OWORD *)v9 + 2);
      v31[3] = v28;
      v31[4] = *((_OWORD *)v9 + 4);
      v29 = *((_OWORD *)v9 + 1);
      v31[0] = *(_OWORD *)v9;
      v31[1] = v29;
      return ci_donebits_check(v26, v6, v27, v3, (unint64_t *)v31);
    }
  }
  else
  {
    v23 = v8;
    v21 = *(_QWORD *)v8;
    v22 = *(_QWORD *)(v23 + 8);
    if (__PAIR128__(v22, v21) < __PAIR128__(v11, v10))
      return 1;
    if (v22 != v11 || v21 != v10)
      goto LABEL_33;
  }
  if (v19 >= v17 && (v19 != v17 || v18 < v16))
    goto LABEL_33;
  return 1;
}

uint64_t ___ZL14readSDBForOidsP20SISearchCtx_METADATAPxPtP16ci_rankingbits_sP17ci_tc_distances_tP21ci_vector_distances_tmPhP19PartialQueryResultsP14__MDPlistBytesbb_block_invoke_2(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v8;
  int v9;
  NSObject *v10;
  _BOOL4 v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  const char *v20;
  NSObject *v21;
  uint32_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  __int16 v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  __int16 v34;
  int v35;
  __int16 v36;
  uint64_t v37;
  __int16 v38;
  uint64_t v39;
  __int16 v40;
  uint64_t v41;
  uint64_t v42;

  v42 = *MEMORY[0x1E0C80C00];
  v2 = *(_QWORD **)(a1 + 32);
  v3 = *(_QWORD *)(a1 + 40);
  v4 = *(_QWORD *)(v3 + 8 * a2);
  if (*v2 != v4)
  {
    *v2 = v4;
    if (!RLEOIDArrayContainsOid(*(_QWORD *)(a1 + 48), *(_QWORD *)(v3 + 8 * a2)))
    {
      if (!*(_BYTE *)(a1 + 72) || *(_DWORD *)(*(_QWORD *)(a1 + 40) + 8 * a2 + 4) != 2147284299)
        return 1;
      v8 = *(_QWORD *)(a1 + 56);
      v9 = *__error();
      v10 = _SILogForLogForCategory(1);
      v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
      if (v8)
      {
        if (v11)
        {
          v12 = *(_QWORD *)(a1 + 64);
          v13 = *(_QWORD *)(v12 + 8);
          v14 = *(_QWORD *)(v13 + 608);
          v15 = *(_QWORD *)(v13 + 616);
          LODWORD(v13) = *(_DWORD *)(v13 + 152);
          v16 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * a2);
          v17 = (uint64_t *)(*(_QWORD *)(a1 + 56) + 80 * a2);
          v19 = *v17;
          v18 = v17[1];
          v28 = 134219520;
          v29 = v12;
          v30 = 2048;
          v31 = v14;
          v32 = 2048;
          v33 = v15;
          v34 = 1024;
          v35 = v13;
          v36 = 2048;
          v37 = v16;
          v38 = 2048;
          v39 = v18;
          v40 = 2048;
          v41 = v19;
          v20 = "### query: %p qid: (%lld,%lld) kind:%d found 0x%llx %llx%016llx";
          v21 = v10;
          v22 = 68;
LABEL_12:
          _os_log_impl(&dword_1B8270000, v21, OS_LOG_TYPE_DEFAULT, v20, (uint8_t *)&v28, v22);
        }
      }
      else if (v11)
      {
        v23 = *(_QWORD *)(a1 + 64);
        v24 = *(_QWORD *)(v23 + 8);
        v25 = *(_QWORD *)(v24 + 608);
        v26 = *(_QWORD *)(v24 + 616);
        LODWORD(v24) = *(_DWORD *)(v24 + 152);
        v27 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8 * a2);
        v28 = 134219008;
        v29 = v23;
        v30 = 2048;
        v31 = v25;
        v32 = 2048;
        v33 = v26;
        v34 = 1024;
        v35 = v24;
        v36 = 2048;
        v37 = v27;
        v20 = "### query: %p qid: (%lld,%lld) kind:%d found 0x%llx";
        v21 = v10;
        v22 = 48;
        goto LABEL_12;
      }
      *__error() = v9;
      return 1;
    }
  }
  return 0;
}

uint64_t PartialQueryResults::completionAttributeIdVector(uint64_t a1, int *a2)
{
  unint64_t v3;
  uint64_t *v5;
  uint64_t v6;
  const __CFArray *v7;
  size_t v8;
  BOOL v9;
  void *v10;
  uint64_t v11;
  uint64_t i;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  char *v19;
  char *v20;
  const char *v21;
  uint64_t v22;

  v3 = *(_QWORD *)(a1 + 360);
  if (v3 && !*(_QWORD *)(a1 + 392))
  {
    v5 = (uint64_t *)(a1 + 360);
    v6 = *(_QWORD *)(a1 + 376);
    if (!v6)
    {
      v7 = *(const __CFArray **)(a1 + 368);
      if (v7)
      {
        SIFlattenArrayToCStringVector(v7, (char **)(a1 + 376), (size_t *)(a1 + 352), (CFIndex *)(a1 + 360));
        v6 = *(_QWORD *)(a1 + 376);
        if (!v6)
        {
          v19 = __si_assert_copy_extra_268();
          v20 = v19;
          v21 = "";
          if (v19)
            v21 = v19;
          __message_assert("%s:%u: failed assertion '%s' %s ", "SISearchCtx.h", 1010, "fCompletionAttributeVector", v21);
          free(v20);
          if (__valid_fs(-1))
            v22 = 2989;
          else
            v22 = 3072;
          *(_DWORD *)v22 = -559038737;
          abort();
        }
        v3 = *v5;
      }
      else
      {
        v6 = 0;
      }
    }
    v8 = 8 * v3;
    if (v3 >> 14)
      v9 = 0;
    else
      v9 = v8 > *MEMORY[0x1E0C85AD8];
    if (v9)
      ++sTotal;
    v10 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, v8, 0x31F9A007uLL);
    if (!v10)
      _log_fault_for_malloc_failure();
    *(_QWORD *)(a1 + 392) = v10;
    v11 = *(_QWORD *)(a1 + 360);
    if (v11 >= 1)
    {
      for (i = 0; i < v11; ++i)
      {
        if (a2)
        {
          v13 = db_copy_field_ids_with_buffer(a2, *(char **)(v6 + 8 * i), 0, 0);
          v11 = *v5;
        }
        else
        {
          v13 = 0;
        }
        *(_QWORD *)(*(_QWORD *)(a1 + 392) + 8 * i) = v13;
      }
    }
    if (!*(_QWORD *)(a1 + 272))
    {
      if (a2)
        v14 = db_copy_field_ids_with_buffer(a2, "kMDItemLastUsedDate", 0, 0);
      else
        v14 = 0;
      *(_QWORD *)(a1 + 272) = v14;
    }
    if (!*(_QWORD *)(a1 + 280))
    {
      if (a2)
        v15 = db_copy_field_ids_with_buffer(a2, "kMDItemContentCreationDate", 0, 0);
      else
        v15 = 0;
      *(_QWORD *)(a1 + 280) = v15;
    }
    if (!*(_QWORD *)(a1 + 288))
    {
      if (a2)
        v16 = db_copy_field_ids_with_buffer(a2, "kMDItemEmailConversationID", 0, 0);
      else
        v16 = 0;
      *(_QWORD *)(a1 + 288) = v16;
    }
    if (!*(_QWORD *)(a1 + 296))
    {
      if (a2)
        v17 = db_copy_field_ids_with_buffer(a2, "_kMDItemLaunchString", 0, 0);
      else
        v17 = 0;
      *(_QWORD *)(a1 + 296) = v17;
    }
  }
  return *(_QWORD *)(a1 + 392);
}

void ___ZL14readSDBForOidsP20SISearchCtx_METADATAPxPtP16ci_rankingbits_sP17ci_tc_distances_tP21ci_vector_distances_tmPhP19PartialQueryResultsP14__MDPlistBytesbb_block_invoke_97(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  qos_class_t v7;
  dispatch_queue_t v8;
  NSObject *v9;
  dispatch_queue_t v10;
  dispatch_semaphore_t v11;
  NSObject *v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  CFMutableDictionaryRef *v16;
  unsigned int v17;
  int v18;
  unint64_t v19;
  unsigned int v20;
  unsigned int v21;
  unint64_t v22;
  unsigned int v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  void (*v27)(_QWORD);
  _DWORD *v28;
  int v29;
  NSObject *v30;
  uint64_t v31;
  const char *v32;
  void *v33;
  unsigned int v34;
  int v35;
  unint64_t v36;
  unsigned int v37;
  unsigned int v38;
  unint64_t v39;
  unsigned int v40;
  unsigned int v41;
  uint64_t v42;
  uint64_t v43;
  void (*v44)(_QWORD);
  uint64_t v45;
  __n128 v46;
  _DWORD *v47;
  int v48;
  NSObject *v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  char v54;
  unint64_t v55;
  const char *v56;
  uint64_t v57;
  const char *v58;
  uint64_t v59;
  const char *v60;
  char v61;
  _QWORD *v62;
  unint64_t v63;
  uint64_t v64;
  uint64_t v65;
  _QWORD *v66;
  const char *v67;
  unint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  unsigned int *v73;
  uint64_t *v74;
  unsigned int *v75;
  uint64_t v76;
  const char *v77;
  char v78;
  unint64_t v79;
  char v80;
  int v81;
  uint64_t v82;
  unsigned int *v83;
  char v84;
  const char *v85;
  int v86;
  NSObject *v87;
  os_log_type_t v88;
  int *v89;
  uint64_t v90;
  _QWORD *v91;
  uint64_t v92;
  char v93;
  int v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  __int128 v102;
  uint64_t v103;
  unint64_t v104;
  _QWORD *v105;
  const char **v106;
  const char *v107;
  uint64_t v108;
  unint64_t v109;
  const char *v110;
  int v111;
  NSObject *v112;
  os_log_type_t v113;
  const char *v114;
  int *v115;
  const char ***v116;
  __int16 v117;
  uint64_t v118;
  unint64_t v119;
  const char *v120;
  unint64_t v121;
  uint64_t v122;
  unsigned int v123;
  uint64_t v124;
  void (*v125)(_QWORD);
  uint64_t v126;
  unsigned int v127;
  uint64_t v128;
  void (*v129)(_QWORD);
  CFMutableDictionaryRef v130;
  __n128 v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  int v137;
  NSObject *v138;
  os_log_type_t v139;
  uint64_t v140;
  uint64_t v141;
  char v142;
  char *v143;
  char *v144;
  const char *v145;
  uint64_t v146;
  const char *v147;
  uint64_t *v148;
  int v149;
  int v150;
  uint64_t v151;
  int v152;
  int v153;
  uint64_t v154;
  CFMutableDictionaryRef *v155;
  NSObject *queue;
  NSObject *v157;
  NSObject *dsema;
  uint64_t *v159;
  unsigned int *v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  _QWORD block[4];
  __int128 v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  CFDictionaryKeyCallBacks *p_keyCallBacks;
  uint64_t v170;
  uint64_t v171;
  unint64_t v172;
  CFMutableDictionaryRef *v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  NSObject *v181;
  uint64_t v182;
  uint64_t v183;
  __int128 v184;
  __int128 v185;
  _QWORD *v186;
  uint64_t v187;
  uint64_t v188;
  NSObject *v189;
  int v190;
  int v191;
  uint64_t v192;
  char v193;
  BOOL v194;
  unsigned int v195;
  unsigned int v196;
  unsigned int v197;
  unsigned int v198;
  unsigned int v199;
  unsigned int v200;
  unsigned int v201;
  unsigned int v202;
  uint64_t v203;
  unint64_t v204;
  CFDictionaryKeyCallBacks keyCallBacks;
  uint8_t buf[4];
  const char *v207;
  __int16 v208;
  int v209;
  uint64_t v210;

  v210 = *MEMORY[0x1E0C80C00];
  v4 = *(_QWORD *)(a1 + 64);
  if (v4)
    v5 = (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(v4 + 16))(v4, 0, 0, 0, 0, *(_QWORD *)(*(_QWORD *)(a1 + 72) + 24));
  else
    v5 = 0;
  v161 = v5;
  v6 = *(_QWORD **)(*(_QWORD *)(a1 + 80) + 8 * a2);
  v154 = *(_QWORD *)(*(_QWORD *)(a1 + 88) + 8 * a2);
  v7 = qos_class_self();
  v8 = 0;
  v9 = dispatch_queue_attr_make_with_qos_class(0, v7, 0);
  v10 = 0;
  v11 = 0;
  if (*(_BYTE *)(a1 + 228))
    goto LABEL_9;
  v12 = v9;
  v10 = dispatch_queue_create("Query result pack queue", v9);
  if (*(_BYTE *)(a1 + 228))
  {
    v8 = 0;
LABEL_8:
    v11 = 0;
    goto LABEL_9;
  }
  v8 = dispatch_queue_create("Query result check queue", v12);
  if (*(_BYTE *)(a1 + 228))
    goto LABEL_8;
  v11 = dispatch_semaphore_create(16);
LABEL_9:
  v157 = v10;
  dsema = v11;
  queue = v8;
  v13 = OSAtomicDequeue(*(OSQueueHead **)(a1 + 96), 0);
  if (!v13)
  {
    v13 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 0x48000uLL, 0x6085D6BuLL);
    if (!v13)
      _log_fault_for_malloc_failure();
  }
  v162 = a1;
  v14 = a1 + 72;
  v151 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 840) + 16);
  v203 = 0;
  v204 = 0;
  v15 = *(_QWORD *)(a1 + 64);
  v16 = (CFMutableDictionaryRef *)malloc_type_malloc(0x10uLL, 0xE0040CF218873uLL);
  keyCallBacks = *(CFDictionaryKeyCallBacks *)byte_1E6E2FC88;
  *v16 = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, &keyCallBacks, 0);
  if (v15)
  {
    memset(&keyCallBacks, 0, 32);
    *(_OWORD *)&keyCallBacks.equal = xmmword_1E6E2FD98;
    v16[1] = CFDictionaryCreateMutable(0, 0, &keyCallBacks, 0);
  }
  else
  {
    v16[1] = 0;
  }
  v155 = v16;
  v163 = a2;
  keyCallBacks.version = 0;
  keyCallBacks.retain = (CFDictionaryRetainCallBack)&keyCallBacks;
  v159 = (uint64_t *)(a1 + 72);
  v160 = (unsigned int *)v6;
  keyCallBacks.release = (CFDictionaryReleaseCallBack)0x2000000000;
  LOBYTE(keyCallBacks.copyDescription) = 0;
  makeThreadId();
  do
  {
    v17 = __ldxr(exceptionSequenceNum);
    v18 = v17 + 1;
  }
  while (__stxr(v17 + 1, exceptionSequenceNum));
  v19 = setThreadIdAndInfo(*(_DWORD *)(*(_QWORD *)(*(_QWORD *)v14 + 24) + 32), sFdExceptionCallbacks, 0, 1, v18);
  v21 = v20;
  v22 = v19;
  v24 = v23;
  v25 = *(_QWORD *)&threadData[18 * v19 + 2];
  v26 = v25 + 320 * HIDWORD(v19);
  *(_BYTE *)(v26 + 216) = 0;
  v152 = *(_DWORD *)(v26 + 312);
  v27 = *(void (**)(_QWORD))(v26 + 224);
  if (v27)
    v27(*(_QWORD *)(v25 + 320 * HIDWORD(v19) + 288));
  v201 = HIDWORD(v22);
  v202 = v22;
  v199 = v21;
  v200 = v24;
  if (_setjmp((int *)v26))
  {
    v28 = (_DWORD *)(v26 + 312);
    v29 = *__error();
    v30 = _SILogForLogForCategory(0);
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v207 = "readSDBForOids_block_invoke";
      v208 = 1024;
      v209 = 3801;
      _os_log_error_impl(&dword_1B8270000, v30, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
    }
    *__error() = v29;
    *v28 = v152;
    CIOnThreadCleanUpReset(v199);
    dropThreadId(v202, 1, v18);
    CICleanUpReset(v202, v200);
    v31 = 0;
    v32 = 0;
    v33 = v13;
    goto LABEL_91;
  }
  v153 = v18;
  do
  {
    v34 = __ldxr(exceptionSequenceNum);
    v35 = v34 + 1;
  }
  while (__stxr(v34 + 1, exceptionSequenceNum));
  v36 = setThreadIdAndInfo(-1, (__int128 *)sSDBExceptionCallbacks, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v14 + 24) + 1184), 0x40000000, v35);
  v38 = v37;
  v39 = v36;
  v41 = v40;
  v42 = *(_QWORD *)&threadData[18 * v36 + 2];
  v43 = v42 + 320 * HIDWORD(v36);
  *(_BYTE *)(v43 + 216) = 0;
  v149 = *(_DWORD *)(v43 + 312);
  v44 = *(void (**)(_QWORD))(v43 + 224);
  if (v44)
    v44(*(_QWORD *)(v42 + 320 * HIDWORD(v36) + 288));
  v197 = HIDWORD(v39);
  v198 = v39;
  v195 = v38;
  v196 = v41;
  v45 = _setjmp((int *)v43);
  if ((_DWORD)v45)
  {
    v47 = (_DWORD *)(v43 + 312);
    v48 = *__error();
    v49 = _SILogForLogForCategory(0);
    v50 = v153;
    if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      v207 = "readSDBForOids_block_invoke";
      v208 = 1024;
      v209 = 3800;
      _os_log_error_impl(&dword_1B8270000, v49, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
    }
    *__error() = v48;
    *v47 = v149;
    CIOnThreadCleanUpReset(v195);
    dropThreadId(v198, 1, v35);
    CICleanUpReset(v198, v196);
    v51 = 0;
    v32 = 0;
    v33 = v13;
    goto LABEL_88;
  }
  v150 = v35;
  v148 = v6 + 3;
  v52 = 134217984;
  v53 = 134217984;
  v54 = 0;
  v55 = 0;
  v56 = 0;
  v57 = 0;
  v58 = 0;
  while (1)
  {
    v147 = v56;
    v59 = v45;
    v60 = v58;
    v61 = v54;
    v62 = v13;
    v63 = v55;
    v64 = v57;
    while (1)
    {
      v65 = v64;
      v66 = v62;
      v67 = v60;
      if (*(_BYTE *)(*(_QWORD *)(*v159 + 104) + 96))
        goto LABEL_83;
      v68 = v63;
      v69 = v59;
      v70 = *(_QWORD *)(*v159 + 104);
      v71 = v162;
      do
      {
        v72 = v70;
        v70 = *(_QWORD *)(v70 + 80);
      }
      while (v70);
      if (*(_BYTE *)(*(_QWORD *)(v72 + 8) + 12))
      {
LABEL_83:
        v107 = v67;
        v33 = v66;
        v118 = v64;
        goto LABEL_85;
      }
      if ((v61 & 1) != 0)
      {
        v73 = _db_obj_iter_next((uint64_t)v160, &v204, 1, *(double *)&v52, *(double *)&v53, v46);
        if (!v73)
        {
          if (!v68)
          {
            v119 = 0;
            v108 = v69;
            v33 = v66;
            v107 = v67;
            v93 = 0;
            v118 = v65;
            goto LABEL_76;
          }
          if (v203)
          {
            v143 = __si_assert_copy_extra_268();
            v144 = v143;
            v145 = "";
            if (v143)
              v145 = v143;
            __message_assert("%s:%u: failed assertion '%s' %s ", "SISearchCtx_METADATA.cpp", 3732, "!page", v145);
            free(v144);
            if (__valid_fs(-1))
              v146 = 2989;
            else
              v146 = 3072;
            *(_DWORD *)v146 = -559038737;
            abort();
          }
          if (*((_QWORD *)v160 + 12))
          {
            v203 = *((_QWORD *)v160 + 12);
            *((_QWORD *)v160 + 12) = 0;
            v74 = v148;
          }
          else
          {
            v74 = &v203;
          }
          v83 = 0;
          *v74 = 0;
          v78 = 1;
          v81 = -1;
          v82 = v65;
          v84 = 0;
          goto LABEL_57;
        }
      }
      else
      {
        v65 = v64 + 1;
        v73 = db_obj_subiter_next(v160, &v204, *(double *)&v52, *(double *)&v53, v46);
        if (!v73)
        {
          v86 = *__error();
          v87 = _SILogForLogForCategory(1);
          v88 = 2 * (dword_1EF19FC90 < 4);
          if (os_log_type_enabled(v87, v88))
          {
            *(_DWORD *)buf = 134217984;
            v207 = v67;
            _os_log_impl(&dword_1B8270000, v87, v88, "Iterator out of results after %ld items", buf, 0xCu);
          }
          v89 = __error();
          v84 = 0;
          *v89 = v86;
          if (!v68)
          {
            v108 = v69;
            v33 = v66;
            v107 = v67;
            v93 = 0;
            v118 = v65;
            v119 = 0;
            goto LABEL_76;
          }
          v78 = 1;
          v81 = v69;
          v82 = v65;
          v83 = 0;
LABEL_57:
          v85 = v67;
          goto LABEL_58;
        }
      }
      v75 = v73;
      v76 = v65;
      v77 = v67 + 1;
      if (v68 == 2048)
      {
        v78 = 0;
      }
      else
      {
        v79 = v204;
        v80 = 1;
        if (*(_QWORD *)(v162 + 104) > v204 || !v68)
        {
          v90 = v69;
          v91 = v66;
          v83 = v75;
          v92 = v76;
          goto LABEL_65;
        }
        v78 = 0;
      }
      v81 = v69;
      v82 = v65;
      v83 = v75;
      v84 = 1;
      v85 = v67 + 1;
LABEL_58:
      v93 = v84;
      v94 = v81;
      if (*(_BYTE *)(v162 + 228))
      {
        v71 = v162;
        processItems(*(_QWORD *)(v162 + 112), *(_QWORD *)(v162 + 120), v68, v155, *(_QWORD *)(v162 + 128), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v162 + 72) + 8) + 216) != 0, *(_QWORD *)(v162 + 64), v161, *(_QWORD *)(v162 + 32), *(_QWORD *)(v162 + 40), *(_QWORD *)(v162 + 48), *(_QWORD *)(v162 + 56), v163, *(_QWORD *)(v162 + 144), 1, *(_DWORD *)(v162 + 216), *(_QWORD *)(v162 + 152), v151 != 0, v157,
          v203,
          v81,
          v154,
          *(_DWORD *)(v162 + 220),
          *(_QWORD *)(v162 + 160),
          *(_QWORD *)(v162 + 168),
          *(_QWORD *)(v162 + 176),
          *(_QWORD **)(v162 + 184),
          v159,
          *(_DWORD *)(v162 + 224),
          (_BYTE *)keyCallBacks.retain + 24,
          v66,
          *(OSQueueHead **)(v162 + 96),
          *(_QWORD *)(v162 + 192),
          0);
      }
      else
      {
        dispatch_semaphore_wait(dsema, 0xFFFFFFFFFFFFFFFFLL);
        v95 = *(_QWORD *)(v162 + 120);
        v170 = *(_QWORD *)(v162 + 112);
        v171 = v95;
        v97 = *(_QWORD *)(v162 + 64);
        v96 = *(_QWORD *)(v162 + 72);
        v98 = *(_QWORD *)(v162 + 136);
        v174 = *(_QWORD *)(v162 + 128);
        v175 = v96;
        v99 = *(_QWORD *)(v162 + 56);
        v166 = *(_QWORD *)(v162 + 48);
        v167 = v99;
        v176 = v161;
        v177 = v98;
        v100 = *(_QWORD *)(v162 + 144);
        v101 = *(_QWORD *)(v162 + 152);
        v178 = v163;
        v179 = v100;
        v193 = *(_BYTE *)(v162 + 228);
        v190 = *(_DWORD *)(v162 + 216);
        block[0] = MEMORY[0x1E0C809B0];
        block[1] = 0x40000000;
        block[2] = ___ZL14readSDBForOidsP20SISearchCtx_METADATAPxPtP16ci_rankingbits_sP17ci_tc_distances_tP21ci_vector_distances_tmPhP19PartialQueryResultsP14__MDPlistBytesbb_block_invoke_102;
        block[3] = &unk_1E6E2FFD0;
        v172 = v68;
        v173 = v155;
        v165 = *(_OWORD *)(v162 + 32);
        v194 = v151 != 0;
        v180 = v101;
        v181 = v157;
        v191 = v94;
        v182 = v203;
        v183 = v154;
        v102 = *(_OWORD *)(v162 + 176);
        v184 = *(_OWORD *)(v162 + 160);
        v185 = v102;
        v192 = *(_QWORD *)(v162 + 220);
        v168 = v97;
        p_keyCallBacks = &keyCallBacks;
        v103 = *(_QWORD *)(v162 + 96);
        v186 = v66;
        v187 = v103;
        v188 = *(_QWORD *)(v162 + 192);
        v189 = dsema;
        dispatch_async(queue, block);
      }
      v203 = 0;
      v104 = v204;
      if (*(_QWORD *)(v71 + 104) <= v204)
      {
        v33 = 0;
        v107 = v85;
        v118 = v82;
        goto LABEL_85;
      }
      v105 = OSAtomicDequeue(*(OSQueueHead **)(v71 + 96), 0);
      if (v105 || (v105 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, 0x48000uLL, 0x6085D6BuLL)) != 0)
      {
        v79 = v104;
        v90 = 0xFFFFFFFFLL;
        v68 = 0;
        v91 = v105;
        v77 = v85;
        v80 = v93;
        v92 = v82;
        if ((v78 & 1) == 0)
          goto LABEL_65;
        v108 = 0xFFFFFFFFLL;
        v33 = v105;
LABEL_75:
        v107 = v85;
        v118 = v82;
        v119 = 0;
LABEL_76:
        v120 = v147;
        goto LABEL_78;
      }
      _log_fault_for_malloc_failure();
      v79 = v104;
      v90 = 0xFFFFFFFFLL;
      v68 = 0;
      v91 = 0;
      v77 = v85;
      v80 = v93;
      v92 = v82;
      if ((v78 & 1) != 0)
      {
        v108 = 0xFFFFFFFFLL;
        v33 = 0;
        goto LABEL_75;
      }
LABEL_65:
      v106 = (const char **)v83;
      v93 = v80;
      v107 = v77;
      v108 = v90;
      v109 = v79;
      v110 = *v106;
      if (*v106 != v147)
        break;
      v59 = v90;
      v60 = v77;
      v61 = v80;
      v62 = v91;
      v63 = v68;
      v64 = v92;
      if (_ZZZL14readSDBForOidsP20SISearchCtx_METADATAPxPtP16ci_rankingbits_sP17ci_tc_distances_tP21ci_vector_distances_tmPhP19PartialQueryResultsP14__MDPlistBytesbbEUb_E7_COUNT_ >= 1)
      {
        --_ZZZL14readSDBForOidsP20SISearchCtx_METADATAPxPtP16ci_rankingbits_sP17ci_tc_distances_tP21ci_vector_distances_tmPhP19PartialQueryResultsP14__MDPlistBytesbbEUb_E7_COUNT_;
        v111 = *__error();
        v112 = _SILogForLogForCategory(1);
        v113 = 2 * (dword_1EF19FC90 < 4);
        if (os_log_type_enabled(v112, v113))
        {
          v114 = *v106;
          *(_DWORD *)buf = 134217984;
          v207 = v114;
          _os_log_impl(&dword_1B8270000, v112, v113, "duplicate oid 0x%llx", buf, 0xCu);
        }
        v115 = __error();
        v59 = v108;
        *v115 = v111;
        v60 = v107;
        v61 = v93;
        v62 = v91;
        v63 = v68;
        v64 = v92;
      }
    }
    v116 = (const char ***)&v91[18 * v68];
    *v116 = v106;
    v116[1] = (const char **)v109;
    v71 = v162;
    v117 = *(unsigned __int8 *)(v162 + 229);
    if (*(_BYTE *)(v162 + 229))
      v117 = *(_WORD *)(*(_QWORD *)(v162 + 136) + 2 * v204);
    v120 = v110;
    v121 = v68 + 1;
    LOWORD(v91[18 * v68 + 2]) = v117;
    v33 = v91;
    v118 = v92;
    v119 = v121;
LABEL_78:
    v45 = v108;
    v58 = v107;
    v54 = v93;
    v13 = v33;
    v55 = v119;
    v56 = v120;
    v57 = v118;
    if (*(_QWORD *)(v71 + 104) <= v204)
    {
      v45 = v108;
      v58 = v107;
      v54 = v93;
      v13 = v33;
      v55 = v119;
      v56 = v120;
      v57 = v118;
      if (!v119)
        break;
    }
  }
LABEL_85:
  v51 = v118;
  v32 = v107;
  v122 = *(_QWORD *)&threadData[18 * v198 + 2];
  v123 = v197;
  v124 = v122 + 320 * v197;
  *(_DWORD *)(v124 + 312) = v149;
  v125 = *(void (**)(_QWORD))(v124 + 232);
  if (v125)
    v125(*(_QWORD *)(v122 + 320 * v123 + 288));
  dropThreadId(v198, 0, v150);
  a2 = v163;
  v16 = v155;
  v50 = v153;
LABEL_88:
  v126 = *(_QWORD *)&threadData[18 * v202 + 2];
  v127 = v201;
  v128 = v126 + 320 * v201;
  *(_DWORD *)(v128 + 312) = v152;
  v129 = *(void (**)(_QWORD))(v128 + 232);
  if (v129)
    v129(*(_QWORD *)(v126 + 320 * v127 + 288));
  dropThreadId(v202, 0, v50);
  v31 = v51;
LABEL_91:
  if (queue)
  {
    dispatch_sync(queue, &__block_literal_global_106_4177);
    dispatch_release(queue);
  }
  if (v157)
  {
    dispatch_sync(v157, &__block_literal_global_109);
    dispatch_release(v157);
  }
  if (dsema)
    dispatch_release(dsema);
  v130 = v16[1];
  if (v130)
    CFRelease(v130);
  if (*v16)
    CFRelease(*v16);
  free(v16);
  if (v203)
    db_obj_iter_return_page(*(_QWORD *)(*v159 + 912), v203);
  if (v33)
    OSAtomicEnqueue(*(OSQueueHead **)(v162 + 96), v33, 0);
  if (*(_BYTE *)(v162 + 230))
  {
    v132 = *(_QWORD *)(v162 + 184);
    if (*(_QWORD *)(v132 + 464 + 8 * a2 + 1024))
    {
      _MDPlistBytesEndArray();
      _MDPlistBytesEndPlist();
    }
    if (*(_QWORD *)(v132 + 464 + 8 * a2))
    {
      _MDStoreOIDArrayEndBulkAdd();
      _MDStoreOIDArrayEndSequence();
      *(_QWORD *)(v132 + 8 * a2 + 3544) = 0;
    }
  }
  v133 = *(_QWORD *)(v162 + 64);
  if (v133)
    (*(void (**)(uint64_t, uint64_t, uint64_t, _QWORD, _QWORD, _QWORD))(v133 + 16))(v133, 1, v161, 0, 0, 0);
  v134 = *(_QWORD *)(*v159 + 104);
  if (!*(_BYTE *)(v134 + 96))
  {
    v135 = *(_QWORD *)(*v159 + 104);
    do
    {
      v136 = v135;
      v135 = *(_QWORD *)(v135 + 80);
    }
    while (v135);
    if (!*(_BYTE *)(*(_QWORD *)(v136 + 8) + 12))
      goto LABEL_119;
  }
  v137 = *__error();
  v138 = _SILogForLogForCategory(1);
  v139 = 2 * (dword_1EF19FC90 < 4);
  if (os_log_type_enabled(v138, v139))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1B8270000, v138, v139, "Query was canceled", buf, 2u);
  }
  *__error() = v137;
  v134 = *(_QWORD *)(*v159 + 104);
  if (*(_BYTE *)(v134 + 96))
  {
    v142 = 1;
  }
  else
  {
LABEL_119:
    v140 = v134;
    do
    {
      v141 = v140;
      v140 = *(_QWORD *)(v140 + 80);
    }
    while (v140);
    v142 = *(_BYTE *)(*(_QWORD *)(v141 + 8) + 12) != 0;
  }
  db_obj_subiter_release((unint64_t *)v160, v142, v131);
  *(_QWORD *)(*(_QWORD *)(v162 + 200) + 8 * a2) = v31;
  *(_QWORD *)(*(_QWORD *)(v162 + 208) + 8 * a2) = v32;
  _Block_object_dispose(&keyCallBacks, 8);
}

void ___ZL14readSDBForOidsP20SISearchCtx_METADATAPxPtP16ci_rankingbits_sP17ci_tc_distances_tP21ci_vector_distances_tmPhP19PartialQueryResultsP14__MDPlistBytesbb_block_invoke_102(uint64_t a1)
{
  uint64_t v1;

  v1 = a1 + 120;
  processItems(*(_QWORD *)(a1 + 80), *(_QWORD *)(v1 - 32), *(_QWORD *)(v1 - 24), *(CFMutableDictionaryRef **)(v1 - 16), *(_QWORD *)(v1 - 8), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 120) + 8) + 216) != 0, *(_QWORD *)(v1 - 56), *(_QWORD *)(v1 + 8), *(_QWORD *)(v1 - 88), *(_QWORD *)(v1 - 80), *(_QWORD *)(v1 - 72), *(_QWORD *)(v1 - 64), *(_QWORD *)(v1 + 24), *(_QWORD *)(v1 + 32), *(_BYTE *)(v1 + 152), *(_DWORD *)(v1 + 136), *(_QWORD *)(v1 + 40), *(_BYTE *)(v1 + 153), *(NSObject **)(v1 + 48),
    *(_QWORD *)(v1 + 56),
    *(_DWORD *)(v1 + 140),
    *(_QWORD *)(v1 + 64),
    *(_DWORD *)(v1 + 144),
    *(_QWORD *)(v1 + 72),
    *(_QWORD *)(v1 + 80),
    *(_QWORD *)(v1 + 88),
    *(_QWORD **)(v1 + 96),
    (uint64_t *)v1,
    *(_DWORD *)(v1 + 148),
    (_BYTE *)(*(_QWORD *)(*(_QWORD *)(v1 - 48) + 8) + 24),
    *(_QWORD **)(v1 + 104),
    *(OSQueueHead **)(v1 + 112),
    *(_QWORD *)(v1 + 120),
    *(_QWORD *)(v1 + 128));
}

void processItems(uint64_t a1, uint64_t a2, unint64_t a3, CFMutableDictionaryRef *a4, uint64_t a5, unsigned __int8 a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, int a16, unint64_t a17, char a18, NSObject *a19, uint64_t a20,int a21,uint64_t a22,int a23,uint64_t a24,uint64_t a25,uint64_t a26,_QWORD *a27,uint64_t *a28,int a29,_BYTE *a30,_QWORD *a31,OSQueueHead *a32,uint64_t a33,uint64_t a34)
{
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t *v41;
  uint64_t *v42;
  uint64_t v43;
  uint64_t v44;
  _QWORD *v45;
  unsigned int v46;
  unint64_t v47;
  size_t v48;
  unint64_t v49;
  uint64_t v50;
  uint64_t v51;
  unsigned int v52;
  _QWORD *v53;
  uint64_t v54;
  _QWORD v59[26];
  int v60;
  unsigned __int8 v61;
  _QWORD block[18];
  int v63;
  int v64;
  int v65;
  char v66;
  unsigned __int8 v67;

  v37 = *a28;
  v38 = *(_QWORD *)(*a28 + 960);
  if (v38)
  {
    v39 = 0;
    v40 = 0;
    v41 = *(uint64_t **)(v37 + 968);
    v42 = *(uint64_t **)(v37 + 976);
    do
    {
      v43 = *v41++;
      v39 += v43;
      v44 = *v42++;
      v40 += v44;
      --v38;
    }
    while (v38);
  }
  else
  {
    v40 = 0;
    v39 = 0;
  }
  if (a3 < 0x800)
  {
    v45 = &a31[18 * a3];
    *v45 = 0;
    *((_WORD *)v45 + 8) = 0;
    *((_OWORD *)v45 + 4) = xmmword_1B86318D0;
    *((_OWORD *)v45 + 5) = unk_1B86318E0;
    *((_OWORD *)v45 + 6) = xmmword_1B86318F0;
    *((_OWORD *)v45 + 2) = ZERO_RANKING_BITS;
    *((_OWORD *)v45 + 3) = unk_1B86318C0;
    *((_DWORD *)v45 + 28) = 0;
    *((_BYTE *)v45 + 116) = 0;
    v45[15] = 0;
    v45[16] = 0;
  }
  if (a15)
    v46 = 2;
  else
    v46 = 4;
  if (v46 >= gCPUCount)
    v47 = gCPUCount;
  else
    v47 = v46;
  do
  {
    v48 = v47;
    v49 = (a3 - 1 + v47) / v47;
    if (v47 < 2)
      break;
    v47 >>= 1;
  }
  while (v49 < 0x80);
  v50 = MEMORY[0x1E0C809B0];
  block[0] = MEMORY[0x1E0C809B0];
  block[1] = 0x40000000;
  block[2] = ___ZL12processItemsP14datastore_infommP24si_localized_value_cachePmbU13block_pointerFPv15SI_OBJECT_EVENT15si_event_data_tmS4_ES4_ooPtmPhbjmbP16dispatch_queue_sS4_jP14__MDPlistBytes14ranking_mode_sP16ci_rankingbits_sP17ci_tc_distances_tP21ci_vector_distances_tP19PartialQueryResultsRP20SISearchCtx_METADATAiRbP10ReadData_sPV3__0P22ci_combobits_wrapped_sP20dispatch_semaphore_s_block_invoke;
  block[3] = &__block_descriptor_tmp_127;
  block[4] = a28;
  block[5] = v49;
  block[6] = a3;
  block[7] = a31;
  block[8] = a30;
  block[9] = a14;
  v66 = a18;
  block[10] = a1;
  block[11] = a24;
  block[12] = a17;
  block[13] = a5;
  block[14] = v40;
  block[15] = v39;
  v63 = a16;
  v64 = a23;
  v67 = a6;
  v65 = a29;
  block[16] = a25;
  block[17] = a26;
  dispatch_apply(v48, 0, block);
  if ((a15 & 1) != 0)
  {
    v52 = *(_DWORD *)(*a28 + 848);
    if (v52)
      v53 = *(_QWORD **)(*(_QWORD *)(*a28 + 840) + 48 * v52);
    else
      v53 = 0;
    packItems(a2, a3, a4, a7, a8, a9, a10, v51, a11, a12, a13, a14, a17, a20, a22, a27, a28, *a30 != 0, a31,
      a32,
      v53,
      a6);
  }
  else
  {
    v54 = *a28;
    v59[0] = v50;
    v59[1] = 0x40000000;
    v59[2] = ___ZL12processItemsP14datastore_infommP24si_localized_value_cachePmbU13block_pointerFPv15SI_OBJECT_EVENT15si_event_data_tmS4_ES4_ooPtmPhbjmbP16dispatch_queue_sS4_jP14__MDPlistBytes14ranking_mode_sP16ci_rankingbits_sP17ci_tc_distances_tP21ci_vector_distances_tP19PartialQueryResultsRP20SISearchCtx_METADATAiRbP10ReadData_sPV3__0P22ci_combobits_wrapped_sP20dispatch_semaphore_s_block_invoke_128;
    v59[3] = &unk_1E6E30128;
    v59[10] = a3;
    v59[11] = a4;
    v59[8] = a7;
    v59[9] = a2;
    v59[12] = a5;
    v59[13] = a8;
    v59[4] = a9;
    v59[5] = a10;
    v59[6] = a11;
    v59[7] = a12;
    v59[14] = a13;
    v59[15] = a14;
    v59[16] = a17;
    v59[17] = a20;
    v60 = a21;
    v59[18] = a22;
    v59[19] = a27;
    v59[20] = v54;
    v59[21] = a30;
    v59[22] = a31;
    v59[23] = a32;
    v61 = a6;
    v59[24] = a33;
    v59[25] = a34;
    dispatch_async(a19, v59);
  }
}

void ___ZL12processItemsP14datastore_infommP24si_localized_value_cachePmbU13block_pointerFPv15SI_OBJECT_EVENT15si_event_data_tmS4_ES4_ooPtmPhbjmbP16dispatch_queue_sS4_jP14__MDPlistBytes14ranking_mode_sP16ci_rankingbits_sP17ci_tc_distances_tP21ci_vector_distances_tP19PartialQueryResultsRP20SISearchCtx_METADATAiRbP10ReadData_sPV3__0P22ci_combobits_wrapped_sP20dispatch_semaphore_s_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unsigned int v10;
  int v11;
  unint64_t v12;
  unsigned int v13;
  unsigned int v14;
  unint64_t v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  void (*v20)(_QWORD);
  int v21;
  NSObject *v22;
  unint64_t v23;
  unsigned int v24;
  int v25;
  unint64_t v26;
  unsigned int v27;
  unsigned int v28;
  unint64_t v29;
  unsigned int v30;
  unsigned int v31;
  uint64_t v32;
  uint64_t v33;
  void (*v34)(_QWORD);
  _DWORD *v35;
  int v36;
  NSObject *v37;
  uint64_t v38;
  unsigned int v39;
  BOOL v40;
  int v41;
  BOOL v42;
  _BOOL4 v43;
  _BOOL4 v44;
  uint64_t v45;
  unint64_t v46;
  unint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t v57;
  __int16 v58;
  _OWORD *v59;
  uint64_t v60;
  _OWORD *v61;
  uint64_t v62;
  uint64_t v63;
  unsigned __int8 v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  int v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  os_unfair_lock_s *v74;
  uint64_t v75;
  unsigned __int8 v76;
  os_unfair_lock_s *v77;
  uint64_t **v78;
  uint64_t v79;
  __int128 *v80;
  __int128 v81;
  __int128 v82;
  uint64_t v83;
  __int128 *v84;
  uint64_t v85;
  __int128 *v86;
  uint64_t v87;
  unint64_t *v88;
  unint64_t v89;
  unint64_t v90;
  float v91;
  float v92;
  float *v93;
  unint64_t v94;
  uint64_t v95;
  unint64_t v96;
  uint64_t v97;
  os_unfair_lock_s *v98;
  uint64_t v99;
  uint64_t v100;
  os_unfair_lock_s *v101;
  uint64_t **v102;
  uint64_t v103;
  __int128 *v104;
  __int128 v105;
  __int128 v106;
  uint64_t v107;
  __int128 *v108;
  uint64_t v109;
  __int128 *v110;
  uint64_t v111;
  uint64_t **v112;
  uint64_t v113;
  uint64_t v114;
  float v115;
  __int128 *v116;
  uint64_t v117;
  float *v118;
  unsigned int v119;
  float v120;
  uint64_t v121;
  unsigned int v122;
  float v123;
  float v124;
  unint64_t v125;
  unint64_t v126;
  float *v127;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  char v144;
  uint64_t v145;
  uint64_t v146;
  unint64_t v147;
  unint64_t v148;
  _QWORD *v149;
  unint64_t v150;
  int v151;
  unint64_t v152;
  uint64_t v153;
  int v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  int v160;
  int v161;
  unint64_t v162;
  uint64_t *v163;
  unint64_t v164;
  uint64_t v165;
  char v166;
  uint64_t v167;
  unint64_t v168;
  uint64_t v169;
  int v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t *v173;
  const char *v174;
  int v175;
  uint64_t *v176;
  uint64_t v177;
  _QWORD *v178;
  int *v179;
  uint64_t v180;
  unsigned int v181;
  float v182;
  uint64_t v183;
  _QWORD *v184;
  _BOOL4 *v185;
  int v186;
  int v187;
  BOOL v188;
  _BOOL4 v189;
  int v190;
  _QWORD *v191;
  float v192;
  BOOL v193;
  int v194;
  int v195;
  _QWORD *v196;
  uint64_t v197;
  _QWORD *v198;
  _QWORD *v199;
  int v200;
  NSObject *v201;
  os_log_type_t v202;
  _QWORD *v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  _QWORD *v207;
  uint64_t v208;
  int v209;
  uint64_t v210;
  _BOOL4 v211;
  BOOL v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  _QWORD *v217;
  uint64_t v218;
  int v219;
  uint64_t v220;
  _BOOL4 v221;
  BOOL v222;
  int v223;
  _QWORD *v224;
  int v225;
  float *v226;
  int v227;
  float v228;
  float v229;
  BOOL v230;
  float v231;
  float *v232;
  BOOL v233;
  int v234;
  _QWORD *v235;
  int v236;
  int *v237;
  float v238;
  int v239;
  BOOL v240;
  _QWORD *v241;
  _QWORD *v242;
  BOOL v243;
  int v244;
  unsigned int v245;
  unsigned int v246;
  int v247;
  unsigned int v248;
  _BOOL4 v249;
  int v250;
  int v251;
  float v252;
  int v253;
  unsigned int v254;
  unsigned int v255;
  int v256;
  unsigned int v257;
  float *v258;
  _BOOL4 v259;
  int v260;
  int v261;
  float v262;
  int v263;
  unsigned int v264;
  void **v265;
  uint64_t v266;
  void **v267;
  uint64_t v268;
  unint64_t *v269;
  unint64_t v270;
  unint64_t v271;
  float v272;
  float v273;
  __int128 *v274;
  float *v275;
  unsigned int v276;
  float v277;
  uint64_t v278;
  unsigned int v279;
  float v280;
  float v281;
  unint64_t v282;
  unint64_t v283;
  float *v284;
  unsigned __int8 v287;
  unint64_t v288;
  uint64_t v289;
  unsigned __int8 v290;
  __int128 *v291;
  uint64_t v292;
  uint64_t v293;
  _BYTE *v294;
  _OWORD *v295;
  uint64_t v296;
  uint64_t v297;
  uint64_t v298;
  __int128 *v299;
  uint64_t v300;
  uint64_t v301;
  _BYTE *v302;
  _OWORD *v303;
  uint64_t v304;
  uint64_t v305;
  _OWORD *v306;
  uint64_t v307;
  uint64_t v308;
  int v309;
  NSObject *v310;
  uint64_t v311;
  uint64_t v312;
  unint64_t v313;
  uint64_t v314;
  unsigned int v315;
  uint64_t v316;
  void (*v317)(_QWORD);
  uint64_t v318;
  unsigned int v319;
  uint64_t v320;
  void (*v321)(_QWORD);
  unint64_t v322;
  uint64_t v323;
  char *v324;
  char *v325;
  const char *v326;
  uint64_t v327;
  uint64_t v328;
  uint64_t v329;
  uint64_t v330;
  uint64_t v331;
  uint64_t v332;
  uint64_t v333;
  uint64_t v334;
  char *v335;
  uint64_t v336;
  uint64_t v337;
  uint64_t v338;
  uint64_t v339;
  uint64_t v340;
  uint64_t v341;
  uint64_t v342;
  uint64_t v343;
  float *v344;
  uint64_t v345;
  unint64_t v346;
  uint64_t v347;
  uint64_t v348;
  uint64_t v349;
  const char *v350;
  uint64_t v351;
  uint64_t v352;
  int v353;
  __int128 v354;
  unsigned __int8 v355;
  uint64_t v356;
  uint64_t v357;
  uint64_t v358;
  unint64_t v359;
  uint64_t v360;
  _BOOL4 v361;
  int v362;
  int v363;
  int v364;
  int v365;
  unint64_t v366;
  uint64_t v367[2];
  uint64_t v368;
  unsigned int v369;
  unsigned int v370;
  unsigned int v371;
  unsigned int v372;
  unsigned int v373;
  unsigned int v374;
  unsigned int v375;
  unsigned int v376;
  unint64_t v377;
  char v378;
  _QWORD v379[6];
  _QWORD v380[14];
  __int128 v381;
  __int128 v382;
  __int128 v383;
  __int128 v384;
  __int128 v385;
  __int128 v386;
  __int128 v387;
  __int128 v388;
  __int128 v389;
  __int128 v390;
  __int128 v391;
  __int128 v392;
  __int128 v393;
  __int128 v394;
  __int128 v395;
  uint8_t buf[4];
  const char *v397;
  __int16 v398;
  uint64_t *v399;
  _QWORD v400[4];
  __int128 v401;
  __int128 v402;
  __int128 v403;
  __int128 v404;
  __int128 v405;
  __int128 v406;
  __int128 v407;
  __int128 v408;
  __int128 v409;
  __int128 v410;
  __int128 v411;
  __int128 v412;
  __int128 v413;
  uint64_t v414;

  v1 = MEMORY[0x1E0C80A78](a1);
  v2 = v1;
  v414 = *MEMORY[0x1E0C80C00];
  v379[4] = 0;
  v3 = *(_QWORD *)(v1 + 40);
  v4 = **(_QWORD **)(v1 + 32);
  v6 = *(_QWORD *)(v4 + 16);
  v5 = *(_QWORD *)(v4 + 24);
  v379[2] = v4;
  v379[3] = v6;
  v379[1] = v5;
  v379[0] = &off_1E6E2A2C0;
  v379[5] = 0;
  v8 = v3 * v7;
  v9 = v3 * v7 + v3;
  if (v9 >= *(_QWORD *)(v1 + 48))
    v9 = *(_QWORD *)(v1 + 48);
  v366 = v9;
  v378 = 0;
  v377 = 0;
  makeThreadId();
  do
  {
    v10 = __ldxr(exceptionSequenceNum);
    v11 = v10 + 1;
  }
  while (__stxr(v10 + 1, exceptionSequenceNum));
  v12 = setThreadIdAndInfo(*(_DWORD *)(*(_QWORD *)(**(_QWORD **)(v2 + 32) + 24) + 32), sFdExceptionCallbacks, 0, 1, v11);
  v14 = v13;
  v15 = v12;
  v17 = v16;
  v18 = *(_QWORD *)&threadData[18 * v12 + 2];
  v19 = v18 + 320 * HIDWORD(v12);
  *(_BYTE *)(v19 + 216) = 0;
  v364 = *(_DWORD *)(v19 + 312);
  v20 = *(void (**)(_QWORD))(v19 + 224);
  if (v20)
    v20(*(_QWORD *)(v18 + 320 * HIDWORD(v12) + 288));
  v365 = v11;
  v375 = HIDWORD(v15);
  v376 = v15;
  v374 = v17;
  v373 = v14;
  if (_setjmp((int *)v19))
  {
    v21 = *__error();
    v22 = _SILogForLogForCategory(0);
    v23 = v366;
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      LODWORD(v400[0]) = 136315394;
      *(_QWORD *)((char *)v400 + 4) = "processItems_block_invoke";
      WORD2(v400[1]) = 1024;
      *(_DWORD *)((char *)&v400[1] + 6) = 2927;
      _os_log_error_impl(&dword_1B8270000, v22, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", (uint8_t *)v400, 0x12u);
    }
    *__error() = v21;
    *(_DWORD *)(v19 + 312) = v364;
    CIOnThreadCleanUpReset(v373);
    dropThreadId(v376, 1, v11);
    CICleanUpReset(v376, v374);
    goto LABEL_373;
  }
  do
  {
    v24 = __ldxr(exceptionSequenceNum);
    v25 = v24 + 1;
  }
  while (__stxr(v24 + 1, exceptionSequenceNum));
  v26 = setThreadIdAndInfo(-1, (__int128 *)sSDBExceptionCallbacks, *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(v2 + 32) + 24) + 1184), 0x40000000, v25);
  v28 = v27;
  v29 = v26;
  v31 = v30;
  v32 = *(_QWORD *)&threadData[18 * v26 + 2];
  v33 = v32 + 320 * HIDWORD(v26);
  *(_BYTE *)(v33 + 216) = 0;
  v362 = *(_DWORD *)(v33 + 312);
  v34 = *(void (**)(_QWORD))(v33 + 224);
  if (v34)
    v34(*(_QWORD *)(v32 + 320 * HIDWORD(v26) + 288));
  v363 = v25;
  v371 = HIDWORD(v29);
  v372 = v29;
  v370 = v31;
  v369 = v28;
  if (_setjmp((int *)v33))
  {
    v35 = (_DWORD *)(v33 + 312);
    v36 = *__error();
    v37 = _SILogForLogForCategory(0);
    v23 = v366;
    if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
    {
      LODWORD(v400[0]) = 136315394;
      *(_QWORD *)((char *)v400 + 4) = "processItems_block_invoke";
      WORD2(v400[1]) = 1024;
      *(_DWORD *)((char *)&v400[1] + 6) = 2926;
      _os_log_error_impl(&dword_1B8270000, v37, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", (uint8_t *)v400, 0x12u);
    }
    *__error() = v36;
    *v35 = v362;
    CIOnThreadCleanUpReset(v369);
    dropThreadId(v372, 1, v363);
    CICleanUpReset(v372, v370);
    goto LABEL_370;
  }
  v38 = **(_QWORD **)(v2 + 32);
  v39 = *(_DWORD *)(v38 + 160);
  v40 = v39 > 6;
  v41 = (1 << v39) & 0x4A;
  v42 = v40 || v41 == 0;
  v43 = 1;
  v23 = v366;
  if (v42)
    v43 = *(_QWORD *)(v38 + 232) != 0;
  if (v8 >= v366)
    goto LABEL_367;
  v44 = v43;
  v45 = 144 * v8;
  v46 = v8;
  v361 = v44;
  do
  {
    v47 = v46;
    v48 = v45;
    v49 = *(_QWORD *)(v2 + 56);
    v50 = *(_QWORD *)(v49 + 144 * v46);
    if (!v50)
      break;
    v360 = v48;
    v51 = *(_QWORD *)(v2 + 32);
    if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)v51 + 104) + 96))
      goto LABEL_365;
    v52 = *(_QWORD *)(v49 + 144 * v47 + 8);
    v357 = v52;
    v53 = *(_QWORD *)(*(_QWORD *)v51 + 104);
    do
    {
      v54 = v53;
      v53 = *(_QWORD *)(v53 + 80);
    }
    while (v53);
    if (*(_BYTE *)(*(_QWORD *)(v54 + 8) + 12))
    {
LABEL_365:
      **(_BYTE **)(v2 + 64) = 1;
      v312 = v360;
      v313 = v47;
      do
      {
        *(_QWORD *)(*(_QWORD *)(v2 + 56) + v312) = 0;
        ++v313;
        v312 += 144;
      }
      while (v313 < v23);
      break;
    }
    if (*(_QWORD *)(v2 + 48) <= v47)
    {
      v324 = __si_assert_copy_extra_268();
      v325 = v324;
      v326 = "";
      if (v324)
        v326 = v324;
      __message_assert("%s:%u: failed assertion '%s' %s ", "SISearchCtx_METADATA.cpp", 2678, "batchCount > i", v326);
LABEL_381:
      free(v325);
      if (__valid_fs(-1))
        v327 = 2989;
      else
        v327 = 3072;
      *(_DWORD *)v327 = -559038737;
      abort();
    }
    v356 = v50;
    v358 = v50;
    v359 = v47;
    v367[0] = v50;
    v367[1] = 0;
    v368 = 0;
    if ((*(_BYTE *)(*(_QWORD *)(*(_QWORD *)v51 + 840) + 40)
       || (v55 = *(_QWORD *)(v2 + 72)) != 0 && *(_BYTE *)(v55 + v52))
      && !db_eval_obj_with_options(*(_QWORD *)(v2 + 80))
      || *(_BYTE *)(v2 + 156) && !db_eval_obj_with_options(*(_QWORD *)(v2 + 80)))
    {
      v57 = v359;
      *(_QWORD *)(*(_QWORD *)(v2 + 56) + 144 * v359) = 0;
      v59 = (_OWORD *)(*(_QWORD *)(v2 + 56) + 144 * v359);
      v59[4] = xmmword_1B86318D0;
      v59[5] = unk_1B86318E0;
      v59[6] = xmmword_1B86318F0;
      v59[2] = ZERO_RANKING_BITS;
      v59[3] = unk_1B86318C0;
      goto LABEL_44;
    }
    v56 = *(_QWORD *)(v2 + 56);
    if (v44)
    {
      v57 = v359;
      if (*(_DWORD *)(v2 + 144) <= *(_WORD *)(v56 + 144 * v359 + 16))
        LOBYTE(v58) = 18;
      else
        v58 = *(_WORD *)(v56 + 144 * v359 + 16);
    }
    else
    {
      LOBYTE(v58) = 0;
      v57 = v359;
    }
    v61 = (_OWORD *)(v56 + 144 * v57);
    v61[4] = xmmword_1B86318D0;
    v61[5] = unk_1B86318E0;
    v61[6] = xmmword_1B86318F0;
    v61[2] = ZERO_RANKING_BITS;
    v61[3] = unk_1B86318C0;
    v62 = *(_QWORD *)(v2 + 56) + 144 * v57;
    *(_DWORD *)(v62 + 112) = 0;
    *(_BYTE *)(v62 + 116) = 0;
    v63 = *(_QWORD *)(v2 + 56) + 144 * v57;
    v64 = v58;
    *(_QWORD *)(v63 + 120) = 0;
    *(_QWORD *)(v63 + 128) = 0;
    v65 = *(_QWORD *)(v2 + 88);
    if (v65)
    {
      v66 = v65 + 80 * v357;
      v67 = *(_QWORD *)(v66 + 40);
      v68 = *(unsigned __int8 *)(v66 + 68);
      v69 = *(_QWORD *)(v66 + 32);
      v70 = v67;
    }
    else
    {
      v68 = 0;
      v70 = 0;
      v69 = 0;
    }
    v71 = v356;
    v72 = v70;
    v73 = v69;
    if (!(v69 | v70) && !v68)
    {
      if (!*(_BYTE *)(v2 + 157))
        goto LABEL_334;
      v354 = xmmword_1B86318D0;
      v412 = 0u;
      v413 = 0u;
      v410 = 0u;
      v411 = 0u;
      v408 = 0u;
      v409 = 0u;
      v406 = 0u;
      v407 = 0u;
      v404 = 0u;
      v405 = 0u;
      v402 = 0u;
      v403 = 0u;
      v401 = 0u;
      memset(v400, 0, sizeof(v400));
      LODWORD(v402) = -1;
      LODWORD(v407) = -1;
      LODWORD(v412) = -1;
      v74 = *(os_unfair_lock_s **)(**(_QWORD **)(v2 + 32) + 928);
      if (v74[1]._os_unfair_lock_opaque > v64)
      {
        v75 = v64;
        if (*(_QWORD *)&v74[8 * v64 + 10]._os_unfair_lock_opaque)
        {
          v76 = v64;
          os_unfair_lock_lock(v74);
          v77 = *(os_unfair_lock_s **)(**(_QWORD **)(v2 + 32) + 928);
          v78 = *(uint64_t ***)&v77[8 * v75 + 10]._os_unfair_lock_opaque;
          v79 = *v78[2];
          if (v79)
            v80 = (__int128 *)(v79 + 80);
          else
            v80 = &ZERO_RANKING_WRAPPED_BITS;
          v81 = v80[3];
          v401 = v80[2];
          v402 = v81;
          v403 = v80[4];
          v82 = v80[1];
          *(_OWORD *)v400 = *v80;
          *(_OWORD *)&v400[2] = v82;
          v83 = **v78;
          if (v83)
            v84 = (__int128 *)(v83 + 80);
          else
            v84 = &ZERO_RANKING_WRAPPED_BITS;
          v404 = *v84;
          v408 = v84[4];
          v407 = v84[3];
          v406 = v84[2];
          v405 = v84[1];
          v85 = *v78[1];
          if (v85)
            v86 = (__int128 *)(v85 + 80);
          else
            v86 = &ZERO_RANKING_WRAPPED_BITS;
          v410 = v86[1];
          v411 = v86[2];
          v412 = v86[3];
          v413 = v86[4];
          v409 = *v86;
          os_unfair_lock_unlock(v77);
          v64 = v76;
          v71 = v356;
          v65 = *(_QWORD *)(v2 + 88);
        }
      }
      v87 = v65;
      v88 = (unint64_t *)(v65 + 80 * v357);
      v90 = *v88;
      v89 = v88[1];
      v92 = *((float *)v88 + 15);
      v91 = *((float *)v88 + 16);
      if (*((_BYTE *)v88 + 69))
      {
        v93 = (float *)&v409;
        if (v91 == 0.0)
          goto LABEL_98;
      }
      else
      {
        v93 = (float *)&v409;
        if (!(v90 | v89))
        {
LABEL_98:
          v118 = v93;
          v119 = *((_DWORD *)v93 + 12);
          v120 = v118[13];
          v121 = v87 + 80 * v357;
          v122 = *(_DWORD *)(v121 + 48);
          v123 = *(float *)(v121 + 52);
          if (*((_BYTE *)v118 + 69))
          {
            v124 = v118[15];
            v57 = v359;
            if (v124 < v91)
              goto LABEL_334;
            if (v124 != v91)
              goto LABEL_333;
          }
          else
          {
            v127 = v118;
            v125 = *(_QWORD *)v118;
            v126 = *((_QWORD *)v127 + 1);
            v57 = v359;
            if (__PAIR128__(v126, v125) < __PAIR128__(v89, v90))
              goto LABEL_334;
            if (v126 != v89 || v125 != v90)
              goto LABEL_333;
          }
          if (v120 >= v123 && (v120 != v123 || v119 < v122))
            goto LABEL_333;
          goto LABEL_334;
        }
      }
      if (v92 == v91)
        v93 = (float *)&v404;
      else
        v93 = (float *)v400;
      goto LABEL_98;
    }
    v354 = xmmword_1B86318D0;
    v94 = *(_QWORD *)(v2 + 96);
    v355 = v64;
    if (!v94)
    {
      v394 = 0u;
      v395 = 0u;
      v392 = 0u;
      v393 = 0u;
      v390 = 0u;
      v391 = 0u;
      v388 = 0u;
      v389 = 0u;
      v386 = 0u;
      v387 = 0u;
      v384 = 0u;
      v385 = 0u;
      v382 = 0u;
      v383 = 0u;
      v381 = 0u;
      LODWORD(v384) = -1;
      LODWORD(v389) = -1;
      LODWORD(v97) = 1;
      LODWORD(v394) = -1;
      goto LABEL_84;
    }
    v95 = v64;
    v96 = *(_QWORD *)(*(_QWORD *)(v2 + 104) + 8 * v64);
    v394 = 0u;
    v395 = 0u;
    v392 = 0u;
    v393 = 0u;
    v390 = 0u;
    v391 = 0u;
    v388 = 0u;
    v389 = 0u;
    v386 = 0u;
    v387 = 0u;
    v384 = 0u;
    v385 = 0u;
    v382 = 0u;
    v383 = 0u;
    v381 = 0u;
    LODWORD(v384) = -1;
    LODWORD(v389) = -1;
    LODWORD(v394) = -1;
    if (v96 < v94)
    {
      LODWORD(v97) = 1;
      goto LABEL_84;
    }
    v98 = *(os_unfair_lock_s **)(**(_QWORD **)(v2 + 32) + 928);
    if (v98[1]._os_unfair_lock_opaque <= v64)
      goto LABEL_83;
    v97 = *(_QWORD *)&v98[8 * v64 + 10]._os_unfair_lock_opaque;
    if (v97)
    {
      v99 = v70;
      v100 = v73;
      os_unfair_lock_lock(v98);
      v101 = *(os_unfair_lock_s **)(**(_QWORD **)(v2 + 32) + 928);
      v102 = *(uint64_t ***)&v101[8 * v95 + 10]._os_unfair_lock_opaque;
      v103 = *v102[2];
      if (v103)
        v104 = (__int128 *)(v103 + 80);
      else
        v104 = &ZERO_RANKING_WRAPPED_BITS;
      v105 = v104[3];
      v383 = v104[2];
      v384 = v105;
      v385 = v104[4];
      v106 = v104[1];
      v381 = *v104;
      v382 = v106;
      v107 = **v102;
      if (v107)
        v108 = (__int128 *)(v107 + 80);
      else
        v108 = &ZERO_RANKING_WRAPPED_BITS;
      v386 = *v108;
      v390 = v108[4];
      v389 = v108[3];
      v388 = v108[2];
      v387 = v108[1];
      v109 = *v102[1];
      if (v109)
        v110 = (__int128 *)(v109 + 80);
      else
        v110 = &ZERO_RANKING_WRAPPED_BITS;
      v392 = v110[1];
      v393 = v110[2];
      v394 = v110[3];
      v395 = v110[4];
      v391 = *v110;
      os_unfair_lock_unlock(v101);
      v73 = v100;
      v72 = v99;
      v64 = v355;
      v71 = v356;
      v57 = v359;
LABEL_83:
      LODWORD(v97) = 0;
    }
LABEL_84:
    v353 = v97;
    if (*(_DWORD *)(v2 + 148) != 2)
    {
      v113 = *(_QWORD *)(v2 + 88);
      v114 = v113 + 80 * v357;
      v115 = *(float *)(v114 + 64);
      if (*(_BYTE *)(v114 + 69))
      {
        v116 = &v391;
        if (v115 == 0.0)
          goto LABEL_113;
      }
      else
      {
        v116 = &v391;
        if (*(_OWORD *)v114 == 0)
        {
LABEL_113:
          v129 = **(_QWORD **)(v2 + 32);
          if (*(uint64_t *)(v129 + 960) < 1)
          {
            v170 = *(_DWORD *)(v2 + 148);
            v111 = **(_QWORD **)(v2 + 32);
LABEL_151:
            if (v170 != 1)
            {
              v117 = v113;
              goto LABEL_310;
            }
            v117 = v113;
            if (!*(_BYTE *)(v113 + 80 * v357 + 68))
              goto LABEL_310;
            v112 = (uint64_t **)(*(_QWORD *)(v111 + 840) + 48 * (*(_DWORD *)(v111 + 832) - 1) + 8);
            goto LABEL_154;
          }
          v130 = *(_QWORD *)(v2 + 112);
          v131 = *(_QWORD *)(v2 + 120);
          v132 = *(_QWORD *)(v129 + 960);
          v133 = *(_QWORD *)(v2 + 88);
          v134 = **(_QWORD **)(v2 + 32);
          v135 = v133;
          v346 = *(_QWORD *)v116;
          v347 = *((_QWORD *)v116 + 1);
          v136 = v134;
          v348 = v73;
          v349 = v72;
          while (1)
          {
            v137 = 0;
            v138 = v131;
            v139 = v132;
            v140 = v134;
            v141 = v132 - 1;
            v132 = v141;
            v142 = *(_QWORD *)(*(_QWORD *)(v136 + 968) + 8 * v141);
            v131 -= v142;
            v143 = *(_QWORD *)(*(_QWORD *)(v136 + 976) + 8 * v141);
            v144 = v130 - v143;
            LOBYTE(v130) = v130 - v143;
            v145 = -1 << v143;
            if ((v143 & 0x40) != 0)
              v146 = 0;
            else
              v146 = -1 << v143;
            v147 = v145 | (0x7FFFFFFFFFFFFFFFuLL >> ~(_BYTE)v143);
            if ((*(_QWORD *)(*(_QWORD *)(v136 + 976) + 8 * v141) & 0x40) != 0)
              v147 = v145;
            v148 = (~v147 << v144) | ((unint64_t)~v146 >> 1 >> ~v144);
            if ((v144 & 0x40) != 0)
              v148 = ~v146 << v144;
            else
              v137 = ~v146 << v144;
            if (!(v137 & v73 | v148 & v72))
              break;
            v149 = (_QWORD *)(v135 + 80 * v357);
            v150 = v149[1] & ~v148;
            *v149 &= ~v137;
            v149[1] = v150;
            if (*(_QWORD *)(*(_QWORD *)(v140 + 968) + 8 * v141))
            {
              v345 = v139;
              v151 = 0;
              v152 = 0;
              v153 = 48 * v138 - 48 * v142 + 56;
              do
              {
                if (db_eval_obj_with_options(*(_QWORD *)(v2 + 80)))
                  v154 = v151 + 1;
                else
                  v154 = v151;
                ++v152;
                v153 += 48;
                v151 = v154;
              }
              while (v152 < *(_QWORD *)(*(_QWORD *)(**(_QWORD **)(v2 + 32) + 968) + 8 * v141));
              v155 = *(_QWORD *)(v2 + 88);
              v156 = **(_QWORD **)(v2 + 32);
              v73 = v348;
              v72 = v349;
              v139 = v345;
            }
            else
            {
              v155 = v133;
              v156 = v140;
              v154 = 0;
            }
            v158 = 0;
            v159 = v155;
            v160 = 1 << *(_DWORD *)(*(_QWORD *)(v156 + 976) + 8 * v141);
            v161 = v160 - 1;
            if (v154 < v160)
              v161 = v154;
            v162 = ((uint64_t)v161 >> 63 << v144) | ((unint64_t)v161 >> 1 >> ~(_BYTE)v130);
            if ((v144 & 0x40) != 0)
              v162 = (uint64_t)v161 << v144;
            else
              v158 = (uint64_t)v161 << v144;
            v163 = (uint64_t *)(v159 + 80 * v357);
            v164 = v162 | v163[1];
            v165 = v158 | *v163;
            *v163 = v165;
            v163[1] = v164;
            v42 = v161 == 0;
            v166 = v353;
            if (!v42)
              v166 = 1;
            if ((v166 & 1) != 0)
            {
              v133 = v159;
              v157 = v156;
              v135 = v159;
              v136 = v156;
              goto LABEL_142;
            }
            v167 = 0;
            v168 = (-1 << v144) | (0x7FFFFFFFFFFFFFFFuLL >> ~(_BYTE)v130);
            if ((v144 & 0x40) != 0)
              v168 = -1 << v144;
            else
              v167 = -1 << v144;
            if (__PAIR128__(v164, v165) < __PAIR128__(v168 & v347, v167 & v346))
            {
LABEL_149:
              v169 = v159;
              v170 = *(_DWORD *)(v2 + 148);
              v111 = v156;
              v113 = v169;
              v23 = v366;
              v44 = v361;
              v57 = v359;
              v71 = v356;
              v64 = v355;
              goto LABEL_151;
            }
            v133 = v159;
            v134 = v156;
            v135 = v159;
            v136 = v156;
LABEL_148:
            if (v139 <= 1)
              goto LABEL_149;
          }
          v157 = v140;
LABEL_142:
          v134 = v157;
          v159 = v133;
          v156 = v157;
          goto LABEL_148;
        }
      }
      if (*(float *)(v114 + 60) == v115)
        v116 = &v386;
      else
        v116 = &v381;
      goto LABEL_113;
    }
    if (!*(_BYTE *)(*(_QWORD *)(v2 + 88) + 80 * v357 + 68))
    {
      v117 = *(_QWORD *)(v2 + 88);
      goto LABEL_310;
    }
    v111 = **(_QWORD **)(v2 + 32);
    v112 = (uint64_t **)(*(_QWORD *)(v111 + 840) + 56);
LABEL_154:
    v171 = 0;
    v172 = *(_QWORD *)(v2 + 80);
    v173 = *v112;
    v351 = *(_QWORD *)(v111 + 152);
    v352 = v172;
    memset(&v380[1], 0, 104);
    v380[0] = 0x400000004;
    bzero(&v400[2], 0xBFF0uLL);
    v400[0] = v173;
    v400[1] = 0;
    v174 = "<>";
    if (!v172)
      v174 = "<<anon store>>";
    v350 = v174;
    v175 = 0;
    v176 = v173;
    v177 = 0;
    while (v175 != 1)
    {
      v178 = &v400[3 * v177];
      v179 = (int *)(v178 + 2);
      if (!v175)
      {
        v180 = v176[7];
        if (v180)
        {
          if (v180 == v368)
          {
            LODWORD(v400[3 * v177 + 1]) = (*((unsigned __int16 *)v176 + 24) >> 10) & 1;
            *v179 = 1;
            if (!v177)
              goto LABEL_295;
            goto LABEL_173;
          }
        }
      }
      v181 = v176[5] & 0xFFF7;
      if (v181 > 3)
      {
        if (v181 == 4)
        {
          v195 = compare_file_by_dbo(v352, v367, v176[2], (uint64_t)(v176 + 4), v351, (uint64_t)v379, 0, (uint64_t)v380, 0);
          LODWORD(v400[3 * v177 + 1]) = v195;
          v183 = v176[2];
          if (!v183)
            goto LABEL_201;
          if (v195)
            goto LABEL_187;
        }
        else
        {
          if (v181 != 16)
          {
            if (v181 == 32)
            {
              LODWORD(v400[3 * v177 + 1]) = 1;
              v182 = *((float *)v176 + 16);
              if (v182 != 0.0)
                goto LABEL_202;
              v183 = v176[2];
              if (!v183)
              {
LABEL_201:
                v182 = 0.0;
LABEL_202:
                *((float *)&v400[3 * v177 + 1] + 1) = v182;
LABEL_203:
                *v179 = 1;
                goto LABEL_204;
              }
LABEL_187:
              v182 = *(float *)(v183 + 52);
              goto LABEL_202;
            }
LABEL_195:
            v200 = *__error();
            v201 = _SILogForLogForCategory(1);
            v202 = 2 * (dword_1EF19FC90 < 4);
            if (os_log_type_enabled(v201, v202))
            {
              *(_DWORD *)buf = 136315394;
              v397 = v350;
              v398 = 2048;
              v399 = v176;
              _os_log_impl(&dword_1B8270000, v201, v202, "%s : node @ 0x%p looks trashed", buf, 0x16u);
            }
            *__error() = v200;
          }
          LODWORD(v400[3 * v177 + 1]) = 0;
          v182 = *((float *)v176 + 16);
          if (v182 != 0.0)
            goto LABEL_202;
          v183 = v176[2];
          if (!v183)
            goto LABEL_201;
        }
        v182 = *(float *)(v183 + 56);
        goto LABEL_202;
      }
      if (v181 == 1)
      {
        if ((v175 - 2) >= 2)
        {
          if (v175)
          {
            *v179 = 4;
            if (*((_DWORD *)v178 + 10) != 1)
              goto LABEL_388;
            v235 = &v400[3 * v177];
            v236 = *((_DWORD *)v235 + 2);
            v237 = (int *)(v235 + 1);
            v238 = *((float *)v235 + 3);
            v235 = (_QWORD *)((char *)v235 + 12);
            *(float *)v235 = fmaxf(v238, *((float *)v178 + 9));
            v344 = (float *)v235;
            v239 = *((_DWORD *)v178 + 8);
            if (v236)
              v240 = (v236 & 0x80000001) == 0;
            else
              v240 = 0;
            if (v240)
            {
              if (v239)
                v243 = (v239 & 0x80000001) == 0;
              else
                v243 = 0;
              if (v243)
              {
                v244 = v239 ^ v236;
                v245 = v239 & v236;
                if (v245 >= 2)
                {
                  v246 = 0;
                  v247 = v244;
                  do
                  {
                    v248 = v245;
                    if ((v245 & 2) != 0)
                    {
                      v249 = db_eval_obj_qp_array_union_for_value((uint64_t)v380, v246);
                      v250 = v246 >= 0x1E ? 0 : 2 << v246;
                      v251 = v250 | v247;
                      if (v249)
                        v247 = v251;
                    }
                    v245 = v248 >> 1;
                    ++v246;
                    v244 = v247;
                  }
                  while (v248 > 3);
                }
                v236 = v244;
                if (!v244)
                  *v344 = 0.0;
              }
              else if (v239)
              {
                v236 = v239;
              }
            }
            else if (!v236)
            {
              v236 = v239;
            }
            *v237 = v236;
            *v179 = 1;
            v252 = *((float *)v176 + 16);
            if (v252 != 0.0)
              *v344 = fmaxf(*v344, v252);
          }
          else
          {
            v213 = *v176;
            v214 = v176[1];
            v215 = v171;
            if (v177 >= v171)
            {
              v215 = v177 + 1;
              if (v177 >= 2047)
              {
LABEL_388:
                v335 = __si_assert_copy_extra_268();
                __message_assert_272((uint64_t)v335, v336, v337, v338, v339, v340, v341, v342, (char)"core-query.c");
                free(v335);
                if (__valid_fs(-1))
                  v343 = 2989;
                else
                  v343 = 3072;
                *(_DWORD *)v343 = -559038737;
                abort();
              }
            }
            v171 = v215;
            v216 = v176[1];
            v217 = &v400[3 * v177 + 3];
            v217[1] = 0;
            *((_DWORD *)v217 + 4) = 0;
            if (*(_DWORD *)(v213 + 44) <= *(_DWORD *)(v214 + 44)
              || (v218 = *(_QWORD *)(v213 + 56), v219 = 3, v218) && v218 == v368)
            {
              v220 = *(_QWORD *)(v214 + 56);
              v221 = v220 != 0;
              LODWORD(v220) = v220 == v368;
              v222 = (v221 & v220) == 0;
              if ((v221 & v220) != 0)
                v216 = v214;
              else
                v216 = v213;
              if (v222)
                v219 = 2;
              else
                v219 = 3;
            }
            *v217 = v216;
            *v179 = v219;
            ++v177;
          }
        }
        else
        {
          if (*((_DWORD *)v178 + 10) != 1)
            goto LABEL_388;
          v196 = &v400[3 * v177];
          *((_DWORD *)v196 + 2) = *((_DWORD *)v178 + 8);
          *((_DWORD *)v196 + 3) = *((_DWORD *)v178 + 9);
          v197 = v171;
          if (v177 >= v171)
          {
            v197 = v177 + 1;
            if (v177 >= 2047)
            {
              v325 = __si_assert_copy_extra_268();
              __message_assert_272((uint64_t)v325, v328, v329, v330, v331, v332, v333, v334, (char)"core-query.c");
              goto LABEL_381;
            }
          }
          v42 = v175 == 2;
          v198 = v176 + 1;
          if (!v42)
            v198 = v176;
          v199 = &v400[3 * v177 + 3];
          *v199 = *v198;
          v199[1] = 0;
          v171 = v197;
          *((_DWORD *)v199 + 4) = 0;
          *v179 = 4;
          ++v177;
        }
      }
      else
      {
        if (v181 != 2)
          goto LABEL_195;
        if ((v175 - 2) >= 2)
        {
          if (v175)
          {
            *v179 = 4;
            if (*((_DWORD *)v178 + 10) != 1)
              goto LABEL_388;
            v223 = *((_DWORD *)v178 + 8);
            v224 = &v400[3 * v177];
            v227 = *((_DWORD *)v224 + 2);
            v226 = (float *)(v224 + 1);
            v225 = v227;
            v228 = *((float *)v178 + 9);
            v229 = v226[1];
            v230 = v229 == 0.0 || v228 == 0.0;
            v231 = v229 + v228;
            if (v230)
              v231 = 0.0;
            v226[1] = v231;
            v232 = v226 + 1;
            if (v223)
              v233 = v225 == 0;
            else
              v233 = 1;
            if (v233)
            {
              v234 = 0;
            }
            else if ((v223 & 0x80000001) != 0)
            {
              if ((v225 & 0x80000001) != 0)
                v234 = 1;
              else
                v234 = v225;
            }
            else
            {
              v234 = v223;
              if ((v225 & 0x80000001) == 0)
              {
                v253 = v225 ^ v223;
                v254 = v225 & v223;
                if (v254 >= 2)
                {
                  v255 = 0;
                  v256 = v253;
                  do
                  {
                    v257 = v254;
                    if ((v254 & 2) != 0)
                    {
                      v258 = v232;
                      v259 = db_eval_obj_qp_array_intersect_for_value((uint64_t)v380, v255);
                      v232 = v258;
                      v260 = v255 >= 0x1E ? 0 : 2 << v255;
                      v261 = v260 | v256;
                      if (v259)
                        v256 = v261;
                    }
                    v254 = v257 >> 1;
                    ++v255;
                    v253 = v256;
                  }
                  while (v257 > 3);
                }
                v234 = v253;
                if (!v253)
                  *v232 = 0.0;
              }
            }
            *(_DWORD *)v226 = v234;
            v262 = *((float *)v176 + 16);
            if (v262 != 0.0)
              *v232 = *v232 + v262;
            goto LABEL_203;
          }
          v204 = *v176;
          v205 = v176[1];
          v206 = v205;
          v207 = &v400[3 * v177];
          *((_DWORD *)v207 + 3) = 1065353216;
          if (v177 >= v171)
            v171 = v177 + 1;
          v207[4] = 0;
          *((_DWORD *)v207 + 10) = 0;
          if (*(_DWORD *)(v204 + 44) <= *(_DWORD *)(v205 + 44)
            || (v208 = *(_QWORD *)(v204 + 56), v209 = 3, v208) && v208 == v368)
          {
            v210 = *(_QWORD *)(v205 + 56);
            v211 = v210 != 0;
            LODWORD(v210) = v210 == v368;
            v212 = (v211 & v210) == 0;
            if ((v211 & v210) != 0)
              v206 = v205;
            else
              v206 = v204;
            if (v212)
              v209 = 2;
            else
              v209 = 3;
          }
          ++v177;
          v207[3] = v206;
          *v179 = v209;
        }
        else
        {
          if (*((_DWORD *)v178 + 10) != 1)
            goto LABEL_388;
          v190 = *((_DWORD *)v178 + 8);
          v191 = &v400[3 * v177];
          *((_DWORD *)v191 + 2) = v190;
          v192 = *((float *)v178 + 9) * *((float *)v191 + 3);
          *((float *)v191 + 3) = v192;
          v193 = (v190 & 0x80000001) != 0 || v190 == 0;
          if (v193 && v192 == 0.0)
          {
            v194 = 1;
          }
          else
          {
            if (v177 >= v171)
              v171 = v177 + 1;
            ++v177;
            v42 = v175 == 2;
            v241 = v176 + 1;
            if (!v42)
              v241 = v176;
            v242 = &v400[3 * v177];
            *v242 = *v241;
            v242[1] = 0;
            *((_DWORD *)v242 + 4) = 0;
            v194 = 4;
          }
          *v179 = v194;
        }
      }
LABEL_204:
      v203 = &v400[3 * v177];
      v176 = (uint64_t *)*v203;
      v175 = *((_DWORD *)v203 + 4);
    }
    v184 = &v400[3 * v177];
    v187 = *((_DWORD *)v184 + 2);
    v185 = (_BOOL4 *)(v184 + 1);
    v186 = v187;
    v188 = v187;
    if ((v176[5] & 8) != 0)
    {
      v189 = v186 == 0;
      *v185 = v189;
      v188 = v189;
    }
    v176[7] = v368;
    *((_WORD *)v176 + 24) = v176[6] & 0xFBFF | (v188 << 10);
    if (v177)
    {
LABEL_173:
      --v177;
      goto LABEL_204;
    }
LABEL_295:
    v263 = HIDWORD(v400[1]);
    v264 = HIDWORD(v380[0]);
    if (HIDWORD(v380[0]) >= 5)
      v265 = (void **)v380[2];
    else
      v265 = (void **)&v380[2];
    v44 = v361;
    if ((v380[0] & 1) != 0)
    {
      v23 = v366;
      if (LODWORD(v380[1]))
      {
        v266 = LODWORD(v380[1]);
        v267 = v265 + 2;
        do
        {
          if (*((_DWORD *)v267 - 2) >= 0x41u)
          {
            free(*v267);
            *((_DWORD *)v267 - 1) = 0;
            *v267 = 0;
          }
          v267 += 3;
          --v266;
        }
        while (v266);
        v264 = HIDWORD(v380[0]);
        v44 = v361;
      }
    }
    else
    {
      v23 = v366;
    }
    if (v264 >= 5)
      free(v265);
    v268 = *(_QWORD *)(v2 + 88);
    v71 = v356;
    *(_DWORD *)(v268 + 80 * v357 + 64) = v263;
    v117 = v268;
    v57 = v359;
    v64 = v355;
LABEL_310:
    if (v353)
      goto LABEL_334;
    v269 = (unint64_t *)(v117 + 80 * v357);
    v271 = *v269;
    v270 = v269[1];
    v273 = *((float *)v269 + 15);
    v272 = *((float *)v269 + 16);
    if (*((_BYTE *)v269 + 69))
    {
      v274 = &v391;
      if (v272 == 0.0)
        goto LABEL_318;
    }
    else
    {
      v274 = &v391;
      if (!(v271 | v270))
        goto LABEL_318;
    }
    if (v273 == v272)
      v274 = &v386;
    else
      v274 = &v381;
LABEL_318:
    v275 = (float *)v274;
    v276 = *((_DWORD *)v274 + 12);
    v277 = v275[13];
    v278 = v117 + 80 * v357;
    v279 = *(_DWORD *)(v278 + 48);
    v280 = *(float *)(v278 + 52);
    if (!*((_BYTE *)v275 + 69))
    {
      v284 = v275;
      v282 = *(_QWORD *)v275;
      v283 = *((_QWORD *)v284 + 1);
      v57 = v359;
      if (__PAIR128__(v283, v282) >= __PAIR128__(v270, v271))
      {
        if (v283 == v270 && v282 == v271)
          goto LABEL_328;
        goto LABEL_333;
      }
LABEL_334:
      if (!*(_DWORD *)(v2 + 152))
      {
        v287 = v64;
        if (*(_DWORD *)(v358 + 12) >= 0x31u)
        {
          v288 = v71 + 48;
          do
          {
            *(_BYTE *)(v288 + 12) = 0;
            v288 += *(unsigned int *)(v288 + 8) + 13;
          }
          while (v288 < v71 + (unint64_t)*(unsigned int *)(v358 + 12));
        }
        db_eval_obj_with_options(*(_QWORD *)(v2 + 80));
        v57 = v359;
        v64 = v287;
      }
      if ((*(_DWORD *)(**(_QWORD **)(v2 + 32) + 160) | 2) == 3)
      {
        v289 = *(_QWORD *)(v2 + 88);
        v290 = v64;
        if (v289)
          v291 = (__int128 *)(v289 + 80 * v357);
        else
          v291 = &ZERO_RANKING_BITS;
        v292 = *(_QWORD *)(v2 + 128);
        v293 = *(_QWORD *)(v2 + 136);
        v294 = (_BYTE *)(v292 + 5 * v357);
        if (!v292)
          v294 = &ZERO_WORD_DISTANCES;
        LODWORD(v381) = *(_DWORD *)v294;
        BYTE4(v381) = v294[4];
        v295 = (_OWORD *)(v293 + 16 * v357);
        if (!v293)
          v295 = &ZERO_VECTOR_DISTANCES;
        *(_OWORD *)v400 = *v295;
        v296 = 9 * v57;
        memmove((void *)(*(_QWORD *)(v2 + 56) + 144 * v57 + 32), v291, 0x50uLL);
        v297 = *(_QWORD *)(v2 + 56) + 16 * v296;
        *(_BYTE *)(v297 + 116) = BYTE4(v381);
        *(_DWORD *)(v297 + 112) = v381;
        *(_OWORD *)(*(_QWORD *)(v2 + 56) + 16 * v296 + 120) = *(_OWORD *)v400;
        *(_WORD *)(*(_QWORD *)(v2 + 56) + 16 * v296 + 16) = v290;
      }
      else
      {
        v298 = *(_QWORD *)(v2 + 88);
        if (v298)
          v299 = (__int128 *)(v298 + 80 * v357);
        else
          v299 = &ZERO_RANKING_BITS;
        v300 = *(_QWORD *)(v2 + 128);
        v301 = *(_QWORD *)(v2 + 136);
        v302 = (_BYTE *)(v300 + 5 * v357);
        if (!v300)
          v302 = &ZERO_WORD_DISTANCES;
        LODWORD(v380[0]) = *(_DWORD *)v302;
        BYTE4(v380[0]) = v302[4];
        v303 = (_OWORD *)(v301 + 16 * v357);
        if (!v301)
          v303 = &ZERO_VECTOR_DISTANCES;
        *(_OWORD *)v400 = *v303;
        v304 = 9 * v57;
        memmove((void *)(*(_QWORD *)(v2 + 56) + 144 * v57 + 32), v299, 0x50uLL);
        v305 = *(_QWORD *)(v2 + 56) + 16 * v304;
        *(_BYTE *)(v305 + 116) = BYTE4(v380[0]);
        *(_DWORD *)(v305 + 112) = v380[0];
        *(_OWORD *)(*(_QWORD *)(v2 + 56) + 16 * v304 + 120) = *(_OWORD *)v400;
        if (dword_1EF19FC90 >= 5)
        {
          v309 = *__error();
          v310 = _SILogForLogForCategory(1);
          if (os_log_type_enabled(v310, OS_LOG_TYPE_DEFAULT))
          {
            v311 = *(_QWORD *)(*(_QWORD *)(v2 + 56) + 144 * v359 + 32);
            LODWORD(v381) = 134217984;
            *(_QWORD *)((char *)&v381 + 4) = v311;
            _os_log_impl(&dword_1B8270000, v310, OS_LOG_TYPE_DEFAULT, "Set match bits %llx", (uint8_t *)&v381, 0xCu);
          }
          *__error() = v309;
          v23 = v366;
          v44 = v361;
        }
      }
      v57 = v359;
      v60 = v360;
      if (!*(_DWORD *)(v2 + 152))
        *(_QWORD *)(*(_QWORD *)(v2 + 56) + 144 * v359) = v358;
      goto LABEL_358;
    }
    v281 = v275[15];
    v57 = v359;
    if (v281 < v272)
      goto LABEL_334;
    if (v281 != v272)
      goto LABEL_333;
LABEL_328:
    if (v277 < v280)
      goto LABEL_334;
    if (v277 == v280 && v276 >= v279)
      goto LABEL_334;
LABEL_333:
    if (*(_BYTE *)(v2 + 157))
      goto LABEL_334;
    *(_QWORD *)(*(_QWORD *)(v2 + 56) + 144 * v57) = 0;
    v306 = (_OWORD *)(*(_QWORD *)(v2 + 56) + 144 * v57);
    v306[4] = v354;
    v306[5] = unk_1B86318E0;
    v306[6] = xmmword_1B86318F0;
    v306[2] = ZERO_RANKING_BITS;
    v306[3] = unk_1B86318C0;
    v307 = *(_QWORD *)(v2 + 56) + 144 * v57;
    *(_DWORD *)(v307 + 112) = 0;
    *(_BYTE *)(v307 + 116) = 0;
    v308 = *(_QWORD *)(v2 + 56) + 144 * v57;
    *(_QWORD *)(v308 + 120) = 0;
    *(_QWORD *)(v308 + 128) = 0;
LABEL_44:
    v60 = v360;
LABEL_358:
    v377 = v57;
    v46 = v57 + 1;
    v45 = v60 + 144;
  }
  while (v57 + 1 != v23);
LABEL_367:
  v378 = 1;
  v314 = *(_QWORD *)&threadData[18 * v372 + 2];
  v315 = v371;
  v316 = v314 + 320 * v371;
  *(_DWORD *)(v316 + 312) = v362;
  v317 = *(void (**)(_QWORD))(v316 + 232);
  if (v317)
    v317(*(_QWORD *)(v314 + 320 * v315 + 288));
  dropThreadId(v372, 0, v363);
LABEL_370:
  v318 = *(_QWORD *)&threadData[18 * v376 + 2];
  v319 = v375;
  v320 = v318 + 320 * v375;
  *(_DWORD *)(v320 + 312) = v364;
  v321 = *(void (**)(_QWORD))(v320 + 232);
  if (v321)
    v321(*(_QWORD *)(v318 + 320 * v319 + 288));
  dropThreadId(v376, 0, v365);
LABEL_373:
  if (!v378)
  {
    v322 = v23 - v377;
    if (v23 > v377)
    {
      v323 = 144 * v377;
      do
      {
        *(_QWORD *)(*(_QWORD *)(v2 + 56) + v323) = 0;
        v323 += 144;
        --v322;
      }
      while (v322);
    }
  }
  QueryFunctionCallbackContext_METADATA::~QueryFunctionCallbackContext_METADATA((QueryFunctionCallbackContext_METADATA *)v379);
}

intptr_t ___ZL12processItemsP14datastore_infommP24si_localized_value_cachePmbU13block_pointerFPv15SI_OBJECT_EVENT15si_event_data_tmS4_ES4_ooPtmPhbjmbP16dispatch_queue_sS4_jP14__MDPlistBytes14ranking_mode_sP16ci_rankingbits_sP17ci_tc_distances_tP21ci_vector_distances_tP19PartialQueryResultsRP20SISearchCtx_METADATAiRbP10ReadData_sPV3__0P22ci_combobits_wrapped_sP20dispatch_semaphore_s_block_invoke_128(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  CFMutableDictionaryRef *v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  _QWORD *v9;

  v2 = a1 + 160;
  v3 = *(_QWORD *)(a1 + 160);
  v4 = *(_QWORD *)(a1 + 80);
  v5 = *(CFMutableDictionaryRef **)(a1 + 88);
  v7 = *(_QWORD *)(a1 + 64);
  v6 = *(_QWORD *)(a1 + 72);
  v8 = *(_DWORD *)(v3 + 848);
  if (v8)
    v9 = *(_QWORD **)(*(_QWORD *)(v3 + 840) + 48 * v8);
  else
    v9 = 0;
  packItems(v6, v4, v5, v7, *(_QWORD *)(v2 - 56), *(_QWORD *)(v2 - 128), *(_QWORD *)(v2 - 120), *(_QWORD *)(v2 + 16), *(_QWORD *)(v2 - 112), *(_QWORD *)(v2 - 104), *(_QWORD *)(v2 - 48), *(_QWORD *)(v2 - 40), *(_QWORD *)(v2 - 32), *(_QWORD *)(v2 - 24), *(_QWORD *)(v2 - 16), *(_QWORD **)(v2 - 8), (uint64_t *)v2, **(_BYTE **)(v2 + 8) != 0, *(_QWORD **)(v2 + 16),
    *(OSQueueHead **)(v2 + 24),
    v9,
    *(_BYTE *)(a1 + 212));
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 200));
}

void packItems(uint64_t a1, uint64_t a2, CFMutableDictionaryRef *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, unint64_t a13, uint64_t a14, uint64_t a15, _QWORD *a16, uint64_t *a17, char a18, _QWORD *a19, OSQueueHead *a20,_QWORD *a21,unsigned __int8 a22)
{
  unint64_t v22;
  unsigned int v23;
  int v24;
  unint64_t v25;
  unsigned int v26;
  unsigned int v27;
  unint64_t v28;
  unsigned int v29;
  unsigned int v30;
  uint64_t v31;
  uint64_t v32;
  void (*v33)(_QWORD);
  int v34;
  NSObject *v35;
  _QWORD *v36;
  uint64_t *v37;
  uint64_t v38;
  OSQueueHead *v39;
  unsigned int v40;
  int v41;
  unint64_t v42;
  unsigned int v43;
  unsigned int v44;
  unint64_t v45;
  unsigned int v46;
  unsigned int v47;
  uint64_t v48;
  unint64_t v49;
  unint64_t v50;
  void (*v51)(_QWORD);
  unint64_t v52;
  _DWORD *v53;
  int v54;
  NSObject *v55;
  int v56;
  int v57;
  int *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  _QWORD *v72;
  unint64_t *v73;
  unint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  int v83;
  int v84;
  unsigned __int16 v85;
  uint64_t v86;
  unint64_t v87;
  unint64_t v88;
  _QWORD *v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  unint64_t v93;
  uint64_t *v94;
  uint64_t *v95;
  uint64_t v96;
  _QWORD *v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t MutableUsingMalloc;
  unint64_t *v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  int v109;
  uint64_t v110;
  int v111;
  char *v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  int v117;
  int v118;
  int v119;
  int v120;
  int v121;
  char v122;
  char v123;
  uint32_t v124;
  unint64_t v125;
  char *v126;
  uint64_t v127;
  unint64_t v128;
  int v129;
  uint64_t v130;
  uint64_t v131;
  int v132;
  char *v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  unsigned int v142;
  int v143;
  float v144;
  int v145;
  int v146;
  float v147;
  int v148;
  int v149;
  uint32_t v150;
  uint32_t v151;
  uint64_t v152;
  BOOL v154;
  int *v155;
  int *v156;
  os_unfair_lock_s *v157;
  _QWORD *v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  unint64_t v162;
  unint64_t v163;
  uint64_t v164;
  uint64_t v165;
  const __CFArray *v166;
  CFIndex v167;
  CFIndex *v168;
  unint64_t v169;
  char **v170;
  uint64_t v171;
  uint64_t v172;
  os_unfair_lock_s *v173;
  uint32_t v174;
  unint64_t v175;
  uint64_t v176;
  unint64_t v177;
  unint64_t v178;
  int v179;
  unint64_t v180;
  unint64_t v181;
  unint64_t v182;
  unint64_t v183;
  int v184;
  uint64_t v185;
  unint64_t v186;
  uint64_t v187;
  unint64_t v188;
  uint64_t v189;
  unint64_t v190;
  os_unfair_lock_s *v191;
  unint64_t v192;
  uint64_t v193;
  uint64_t v194;
  const __CFArray *v195;
  const __CFArray *v196;
  const __CFArray *v197;
  unint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t *v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t *v204;
  uint64_t v205;
  _QWORD *v206;
  __int128 *v207;
  unsigned int v208;
  float v209;
  BOOL v210;
  float v211;
  BOOL v212;
  __int128 *v213;
  unint64_t v214;
  int v215;
  uint64_t v216;
  unint64_t v217;
  uint64_t v218;
  unint64_t v219;
  uint64_t v220;
  unint64_t v221;
  os_unfair_lock_s *v222;
  unint64_t v223;
  unint64_t v224;
  unint64_t v225;
  __int128 *v226;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  _OWORD *v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  _QWORD *v236;
  uint64_t v237;
  uint64_t v238;
  unsigned int v239;
  float v240;
  int v241;
  float v242;
  char v243;
  uint64_t v244;
  __int128 v245;
  uint64_t v246;
  __int128 v247;
  uint64_t v248;
  uint64_t v249;
  uint64_t v250;
  uint64_t v251;
  uint64_t v252;
  uint64_t v253;
  unint64_t v254;
  unsigned int v255;
  float v256;
  int v257;
  float v258;
  int v259;
  uint64_t v260;
  __int128 v261;
  uint64_t v262;
  uint64_t v263;
  unsigned int v264;
  float v265;
  int v266;
  float v267;
  int v268;
  uint64_t v269;
  uint64_t v270;
  uint64_t v271;
  int v272;
  int v273;
  __int128 *v275;
  uint64_t v276;
  uint64_t v277;
  unsigned int v278;
  int *v279;
  uint64_t *v280;
  __int128 *v281;
  __int128 *v282;
  int *v283;
  __int128 *v284;
  uint64_t v285;
  uint64_t v286;
  BOOL v287;
  uint64_t v292;
  __int128 v293;
  int v294;
  uint64_t v295;
  __int128 v296;
  uint64_t v297;
  BOOL v298;
  uint64_t v301;
  unint64_t v302;
  BOOL v303;
  unint64_t v304;
  uint64_t v305;
  unint64_t v306;
  unint64_t v307;
  int v308;
  uint64_t v309;
  unint64_t v310;
  unint64_t v311;
  os_unfair_lock_s *v312;
  unint64_t v313;
  uint64_t v314;
  uint64_t v315;
  int v316;
  int v317;
  int v318;
  int v319;
  int v320;
  uint64_t v321;
  uint64_t v322;
  uint64_t v323;
  int v324;
  int v325;
  char v326;
  char v327;
  unsigned int v328;
  uint64_t v329;
  int v330;
  unint64_t v331;
  unint64_t v332;
  unint64_t v333;
  int v334;
  int v335;
  uint64_t v336;
  uint64_t v337;
  char **v338;
  uint64_t v339;
  uint64_t v340;
  unint64_t v341;
  uint64_t v342;
  uint64_t v343;
  uint64_t v344;
  unint64_t v345;
  uint64_t v346;
  uint64_t v347;
  unint64_t v348;
  unint64_t v349;
  int v350;
  uint64_t v351;
  unint64_t v352;
  unint64_t v353;
  os_unfair_lock_s *v354;
  unint64_t v355;
  unint64_t *v356;
  unint64_t v357;
  uint64_t v358;
  unsigned int v359;
  uint64_t v360;
  void (*v361)(_QWORD);
  uint64_t v362;
  unsigned int v363;
  uint64_t v364;
  void (*v365)(_QWORD);
  int v366;
  NSObject *v367;
  char *v368;
  uint64_t v369;
  uint64_t v370;
  uint64_t v371;
  uint64_t v372;
  uint64_t v373;
  uint64_t v374;
  uint64_t v375;
  uint64_t v376;
  char *v377;
  uint64_t v378;
  uint64_t v379;
  uint64_t v380;
  uint64_t v381;
  uint64_t v382;
  uint64_t v383;
  uint64_t v384;
  uint64_t v385;
  uint64_t v386;
  uint64_t v387;
  uint64_t v388;
  char v389;
  int v390;
  int v391;
  char v392;
  uint64_t v393;
  uint64_t v394;
  uint64_t v395;
  char v396;
  int v397;
  unsigned int v398;
  uint64_t v399;
  uint64_t v400;
  uint64_t v401;
  uint64_t v402;
  unsigned int v403;
  unint64_t v404;
  unint64_t v405;
  uint64_t *v406;
  CFIndex v407;
  uint32_t v408;
  BOOL v409;
  uint64_t v410;
  uint64_t v411;
  uint64_t v412;
  uint64_t v413;
  int v414;
  int v415;
  CFIndex v416;
  CFIndex v417;
  CFIndex v418;
  CFIndex v419;
  unint64_t *v420;
  int v421;
  CFIndex v422;
  char v423;
  CFIndex v424;
  unsigned int v425;
  char v426;
  unsigned int v427;
  unsigned int v428;
  int v429;
  unsigned int v430;
  uint64_t v431;
  uint64_t v432;
  uint64_t v433;
  unint64_t v434;
  uint64_t v435;
  _QWORD *v436;
  uint64_t v437;
  unint64_t v438;
  unint64_t v439;
  uint64_t v440;
  size_t *v441;
  char **v442;
  os_unfair_lock_s *lock;
  CFIndex **v444;
  char **v445;
  CFIndex *v446;
  uint64_t v447;
  uint64_t v448;
  uint64_t v449;
  uint64_t v450;
  uint64_t v451;
  uint64_t v452;
  uint64_t v453;
  uint64_t v454;
  uint64_t v455;
  uint64_t v456;
  int v457;
  int v458;
  int v466;
  int v467;
  unint64_t v468;
  uint64_t v469;
  uint64_t v470;
  unint64_t v471;
  uint64_t v472;
  uint64_t v473;
  int v474;
  int v475;
  int v476;
  uint64_t v477;
  char v478;
  char v479;
  _OWORD v480[5];
  uint64_t v481[6];
  int v482;
  float v483;
  int v484;
  float v485;
  int v486;
  char v487;
  char v488;
  uint64_t v489;
  __int16 v490;
  _QWORD v491[6];
  int v492;
  float v493;
  int v494;
  float v495;
  int v496;
  char v497;
  char v498;
  uint64_t v499;
  __int16 v500;
  unint64_t v501;
  uint64_t v502;
  uint64_t v503;
  unint64_t v504;
  uint64_t v505;
  uint64_t v506;
  int v507;
  float v508;
  int v509;
  float v510;
  int v511;
  char v512;
  char v513;
  unint64_t v514;
  uint64_t v515;
  uint64_t v516;
  unint64_t v517;
  uint64_t v518;
  uint64_t v519;
  int v520;
  float v521;
  int v522;
  float v523;
  int v524;
  char v525;
  char v526;
  unint64_t v527;
  uint64_t v528;
  uint64_t v529;
  unint64_t v530;
  uint64_t v531;
  uint64_t v532;
  int v533;
  int v534;
  int v535;
  int v536;
  int v537;
  char v538;
  char v539;
  unint64_t v540;
  uint64_t v541;
  uint64_t v542;
  unint64_t v543;
  uint64_t v544;
  uint64_t v545;
  int v546;
  int v547;
  int v548;
  int v549;
  int v550;
  char v551;
  char v552;
  unsigned int v553;
  unsigned int v554;
  unsigned int v555;
  unsigned int v556;
  unsigned int v557;
  unsigned int v558;
  unsigned int v559;
  unsigned int v560;
  char v561;
  CFIndex v562[8];
  unsigned int v563;
  float v564;
  unsigned int v565;
  float v566;
  int v567;
  char v568;
  char v569;
  uint64_t v570;
  __int16 v571;
  BOOL v572;
  _BYTE v573[15];
  int v574;
  char v575;
  __int128 v576;
  __int128 v577;
  int v578;
  char v579;
  __int128 v580;
  __int128 v581;
  int v582;
  char v583;
  uint64_t v584;
  __int16 v585;
  uint64_t v586;
  __int16 v587;
  _BYTE buf[32];
  __int128 v589;
  __int128 v590;
  __int128 v591;
  __int128 v592;
  BOOL v593;
  _BYTE v594[15];
  _QWORD v595[2];
  __int128 v596;
  uint64_t v597;
  __int16 v598;
  __int128 v599;
  __int128 v600;
  uint64_t v601;
  __int16 v602;
  __int128 v603;
  uint64_t v604;
  __int16 v605;
  __int128 v606;
  __int128 v607;
  __int128 v608;
  __int128 v609;
  uint64_t v610;

  v22 = (unint64_t)a16;
  v610 = *MEMORY[0x1E0C80C00];
  makeThreadId();
  v561 = 0;
  do
  {
    v23 = __ldxr(exceptionSequenceNum);
    v24 = v23 + 1;
  }
  while (__stxr(v23 + 1, exceptionSequenceNum));
  v25 = setThreadIdAndInfo(*(_DWORD *)(*(_QWORD *)(*a17 + 24) + 32), sFdExceptionCallbacks, 0, 1, v24);
  v27 = v26;
  v28 = v25;
  v30 = v29;
  v31 = *(_QWORD *)&threadData[18 * v25 + 2];
  v32 = v31 + 320 * HIDWORD(v25);
  *(_BYTE *)(v32 + 216) = 0;
  v466 = *(_DWORD *)(v32 + 312);
  v33 = *(void (**)(_QWORD))(v32 + 224);
  if (v33)
    v33(*(_QWORD *)(v31 + 320 * HIDWORD(v25) + 288));
  v467 = v24;
  v559 = HIDWORD(v28);
  v560 = v28;
  v558 = v30;
  v557 = v27;
  if (_setjmp((int *)v32))
  {
    v34 = *__error();
    v35 = _SILogForLogForCategory(0);
    v36 = a19;
    if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "packItems";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 2508;
      _os_log_error_impl(&dword_1B8270000, v35, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
    }
    *__error() = v34;
    *(_DWORD *)(v32 + 312) = v466;
    CIOnThreadCleanUpReset(v557);
    dropThreadId(v560, 1, v467);
    CICleanUpReset(v560, v558);
    v37 = a17;
    v38 = a14;
    v39 = a20;
    goto LABEL_299;
  }
  do
  {
    v40 = __ldxr(exceptionSequenceNum);
    v41 = v40 + 1;
  }
  while (__stxr(v40 + 1, exceptionSequenceNum));
  v42 = setThreadIdAndInfo(-1, (__int128 *)sSDBExceptionCallbacks, *(_QWORD *)(*(_QWORD *)(*a17 + 24) + 1184), 0x40000000, v41);
  v44 = v43;
  v45 = v42;
  v47 = v46;
  v48 = *(_QWORD *)&threadData[18 * v42 + 2];
  v49 = v48 + 320 * HIDWORD(v42);
  v50 = v49;
  *(_BYTE *)(v49 + 216) = 0;
  v457 = *(_DWORD *)(v49 + 312);
  v51 = *(void (**)(_QWORD))(v49 + 224);
  if (v51)
    v51(*(_QWORD *)(v48 + 320 * HIDWORD(v42) + 288));
  v458 = v41;
  v555 = HIDWORD(v45);
  v556 = v45;
  v554 = v47;
  v553 = v44;
  if (_setjmp((int *)v49))
  {
    v53 = (_DWORD *)(v49 + 312);
    v54 = *__error();
    v55 = _SILogForLogForCategory(0);
    v39 = a20;
    v56 = v467;
    v57 = v466;
    if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "packItems";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 2507;
      _os_log_error_impl(&dword_1B8270000, v55, OS_LOG_TYPE_ERROR, "%s:%d: Caught mach exception", buf, 0x12u);
    }
    *__error() = v54;
    *v53 = v457;
    CIOnThreadCleanUpReset(v553);
    dropThreadId(v556, 1, v458);
    CICleanUpReset(v556, v554);
    v36 = a19;
    v38 = a14;
    v37 = a17;
    goto LABEL_296;
  }
  v58 = *(int **)(*(_QWORD *)(*a17 + 24) + 1184);
  v456 = (uint64_t)v58;
  if (*(_BYTE *)(*(_QWORD *)(*a17 + 8) + 753))
  {
    v387 = *(_QWORD *)(SISearchCtx_METADATA::photosDerivedAttributes(*a17, v58) + 16);
    v59 = *(_QWORD *)SISearchCtx_METADATA::photosDerivedAttributes(*a17, v58);
    v60 = *(_QWORD *)(SISearchCtx_METADATA::photosDerivedAttributes(*a17, v58) + 24);
    v61 = *(_QWORD *)(SISearchCtx_METADATA::photosDerivedAttributes(*a17, v58) + 32);
    v386 = *(_QWORD *)(SISearchCtx_METADATA::photosDerivedAttributes(*a17, v58) + 8);
    v62 = *(_QWORD *)(SISearchCtx_METADATA::photosDerivedAttributes(*a17, v58) + 48);
    v50 = *(_QWORD *)(SISearchCtx_METADATA::photosDerivedAttributes(*a17, v58) + 40);
    v63 = *(_QWORD *)(SISearchCtx_METADATA::photosDerivedAttributes(*a17, v58) + 56);
    v64 = *(_QWORD *)(SISearchCtx_METADATA::photosDerivedAttributes(*a17, v58) + 64);
    v65 = v63;
    v66 = v62;
    v67 = v61;
    v68 = v386;
    v69 = v387;
    v70 = v50;
  }
  else
  {
    v65 = 0;
    v66 = 0;
    v67 = 0;
    v59 = 0;
    v69 = 0;
    v60 = 0;
    v68 = 0;
    v70 = 0;
    v64 = 0;
  }
  v455 = v64;
  v454 = v70;
  v453 = v68;
  v452 = v60;
  v451 = v69;
  v450 = v59;
  v449 = v67;
  v448 = v66;
  v447 = v65;
  v36 = a19;
  v71 = a2;
  if (!a2)
  {
    v346 = 0;
    v37 = a17;
    goto LABEL_291;
  }
  v72 = &a16[a11];
  v73 = v72 + 314;
  v446 = a16 + 29;
  v445 = (char **)(a16 + 13);
  v444 = (CFIndex **)(v72 + 443);
  lock = (os_unfair_lock_s *)(a16 + 571);
  v442 = (char **)(a16 + 12);
  v441 = a16 + 30;
  v74 = 65533;
  v75 = 0;
  v76 = 0;
  v77 = 224;
  v37 = a17;
  v420 = v73;
  do
  {
    v438 = v52;
    v439 = v77;
    v78 = v76;
    if (*v73 >= v74)
    {
      v79 = *(_QWORD *)(*v37 + 104);
      do
      {
        v80 = v79;
        v79 = *(_QWORD *)(v79 + 80);
      }
      while (v79);
      v81 = *(_QWORD *)(*(_QWORD *)(*v37 + 104) + 80);
      if (!v81)
        goto LABEL_29;
      v82 = *(_QWORD *)(*v37 + 104);
      v83 = 0;
      do
      {
        v84 = v83 ^ (*(_DWORD *)(v82 + 104) == 0);
        v82 = v81;
        v81 = *(_QWORD *)(v81 + 80);
        v83 = v84;
      }
      while (v81);
      if ((v84 & 1) != 0)
        v85 = 3553;
      else
LABEL_29:
        v85 = 2781;
      PartialQueryResults::prepare((uint64_t)a16, *(_DWORD *)(*(_QWORD *)(v80 + 8) + 80), v85, a11);
    }
    v86 = v36[18 * v75];
    v36[18 * v75] = 0;
    if (!v86)
    {
      v87 = v438;
      v90 = v439;
      v91 = v78;
      goto LABEL_279;
    }
    if ((a18 & 1) != 0)
      goto LABEL_33;
    v433 = v86;
    v435 = v86;
    v92 = *v37;
    v440 = v78;
    if (*(_BYTE *)(*(_QWORD *)(*v37 + 8) + 753))
    {
      v436 = (_QWORD *)v22;
      v437 = v75;
      v434 = v50;
      v93 = v74;
      *(_QWORD *)buf = 0;
      v94 = v37;
      v95 = (uint64_t *)(*(uint64_t (**)(uint64_t, _BYTE *))(*(_QWORD *)v92 + 88))(v92, buf);
      v96 = *v94;
      v97 = (_QWORD *)*v95;
      v98 = (uint64_t)a16;
      v99 = a16[55];
      if (!v99)
      {
        os_unfair_lock_lock(lock);
        if (!a16[55])
        {
          MutableUsingMalloc = _MDPlistBytesCreateMutableUsingMalloc();
          _MDPlistBytesBeginPlist();
          _MDPlistBytesBeginArray();
          __dmb(0xBu);
          a16[55] = MutableUsingMalloc;
          v98 = (uint64_t)a16;
        }
        os_unfair_lock_unlock(lock);
        v99 = *(_QWORD *)(v98 + 440);
        v94 = a17;
      }
      v101 = v73;
      v102 = v456;
      v103 = v435;
      extractSynonymUnalignedMatchingField(v96, v456, v435, v450, v451, v452, v449, v453, v98, v97, v99);
      v104 = *v94;
      v105 = *(_QWORD *)buf;
      v106 = *(_QWORD *)(v98 + 448);
      if (!v106)
      {
        os_unfair_lock_lock(lock);
        if (!*(_QWORD *)(v98 + 448))
        {
          v107 = _MDPlistBytesCreateMutableUsingMalloc();
          _MDPlistBytesBeginPlist();
          _MDPlistBytesBeginArray();
          __dmb(0xBu);
          a16[56] = v107;
          v98 = (uint64_t)a16;
        }
        os_unfair_lock_unlock(lock);
        v106 = *(_QWORD *)(v98 + 448);
        v102 = v456;
        v94 = a17;
        v103 = v435;
      }
      extractPersonUnalignedMatchingField(v104, v102, v103, v454, v447, v455, v448, v98, v95, v105, v106);
      v108 = *v94;
      v73 = v101;
      v74 = v93;
      v78 = v440;
      v50 = v434;
      v22 = (unint64_t)v436;
      v75 = v437;
    }
    else
    {
      v108 = *v37;
    }
    if (*(_BYTE *)(v108 + 650))
      v109 = 18;
    else
      v109 = 2;
    v110 = *(_QWORD *)(v108 + 104);
    if (!a1 || !*(_BYTE *)(v110 + 99))
    {
      v126 = (char *)&a19[18 * v75];
      v128 = *((_QWORD *)v126 + 4);
      v127 = *((_QWORD *)v126 + 5);
      v393 = *((_QWORD *)v126 + 9);
      v388 = *((_QWORD *)v126 + 8);
      v129 = *((_DWORD *)v126 + 21);
      v390 = *((_DWORD *)v126 + 22);
      v391 = *((_DWORD *)v126 + 20);
      v130 = *(_QWORD *)(v126 + 92);
      v389 = v126[100];
      v392 = v126[101];
      if (*(_BYTE *)(v110 + 98) && !*(_BYTE *)(v110 + 99))
      {
        v167 = *(_QWORD *)v435;
        ++*v73;
        v168 = *v444;
        *v168 = v167;
        *v444 = v168 + 1;
        v89 = (_QWORD *)v22;
        v169 = v50;
        v71 = a2;
LABEL_93:
        v172 = *a17;
        v173 = *(os_unfair_lock_s **)(*a17 + 928);
        if (v173 && (v174 = LOBYTE(a19[18 * v75 + 2]), *(_DWORD *)(v172 + 652) > v174))
        {
          if (*(_QWORD *)(v172 + 400) & v128 | *(_QWORD *)(v172 + 408) & v127)
          {
            v175 = *(_QWORD *)(v172 + 416) & v128;
            v469 = *(_QWORD *)(v172 + 424) & v127;
            v468 = v175;
          }
          else
          {
            v468 = v128;
            v469 = v127;
          }
          v176 = *(_QWORD *)(v172 + 464) & v128 | *(_QWORD *)(v172 + 472) & v127;
          if (v176)
          {
            v177 = 0;
            v178 = *(_QWORD *)(v172 + 496) & v128;
            v179 = *(_DWORD *)(v172 + 516);
            v180 = v178 << v179;
            v181 = ((*(_QWORD *)(v172 + 504) & v127) << v179) | (v178 >> 1 >> ~(_BYTE)v179);
            if ((v179 & 0x40) != 0)
              v181 = v180;
            else
              v177 = v180;
            v176 = v177 | 1;
          }
          else
          {
            v181 = 0;
          }
          v78 = v440;
          v182 = *(_QWORD *)(v172 + 176);
          v470 = v176;
          v471 = v181;
          v472 = v388;
          v473 = v393;
          v474 = v391;
          v475 = v129;
          v476 = v390;
          v477 = v130;
          v478 = v389 & 1;
          v479 = v392 & 1;
          ci_donebits_push(v173, a13, v182, v174, &v468);
          v87 = v438;
          v88 = v439;
          v50 = v169;
        }
        else
        {
          v87 = v438;
          v88 = v439;
          v50 = v169;
          v78 = v440;
        }
        goto LABEL_278;
      }
      v592 = 0u;
      v591 = 0u;
      v590 = 0u;
      v589 = 0u;
      *(_OWORD *)&buf[16] = 0u;
      *(_OWORD *)buf = 0u;
      v131 = *(_QWORD *)(v108 + 16);
      *(_QWORD *)&buf[16] = *(_QWORD *)(v108 + 24);
      *(_QWORD *)&buf[24] = v131;
      LOBYTE(v589) = 1;
      v590 = 0u;
      v591 = 0u;
      *(_QWORD *)&v592 = 0;
      if (*(_QWORD *)&buf[16])
        v132 = (*(unsigned __int8 *)(*(_QWORD *)&buf[16] + 6586) >> 1) & 1;
      else
        LOBYTE(v132) = 1;
      v158 = (_QWORD *)v435;
      BYTE8(v592) = v132;
      *(_QWORD *)buf = &off_1E6E2A0F8;
      *((_QWORD *)&v589 + 1) = v435;
      *(_DWORD *)&buf[8] = v109 | 8;
      if (a4)
      {
        v22 &= 0xFFFFFF0000000000;
        eventParseDBO(*(_QWORD *)(v108 + 24), a4, a5, a16, *(char ***)(v108 + 152), buf, *(_QWORD *)(v108 + 16), 0, 0, 0, 0, (uint64_t)&ZERO_RANKING_BITS, v22, SBYTE4(v22), 0, 0, 0, v108, a21);
        v159 = *(_QWORD *)(*a17 + 104);
        do
        {
          v160 = v159;
          v159 = *(_QWORD *)(v159 + 80);
        }
        while (v159);
        v161 = *(_QWORD *)(v160 + 40);
        v162 = **((_QWORD **)&v589 + 1);
        pthread_rwlock_wrlock((pthread_rwlock_t *)(v161 + 16));
        SIValueSet<unsigned long long>::SIValueSetInsert((unint64_t *)(v161 + 216), v162);
        pthread_rwlock_unlock((pthread_rwlock_t *)(v161 + 16));
        v163 = v50;
      }
      else
      {
        v164 = *(_QWORD *)(v108 + 24);
        if (*(_DWORD *)(v108 + 160) == 4)
        {
          v165 = a16[29];
          if (*(_BYTE *)a16)
          {
            v71 = a2;
            if (v165)
            {
              if (!*v445)
              {
                v166 = (const __CFArray *)a16[16];
                if (v166)
                {
                  v562[0] = 0;
                  SIFlattenArrayToCStringVector(v166, v445, (size_t *)v562, (CFIndex *)&v606);
                }
              }
            }
          }
          else
          {
            v71 = a2;
            if (v165)
            {
              if (!*v442)
              {
                v197 = (const __CFArray *)a16[15];
                if (v197)
                {
                  SIFlattenArrayToCStringVector(v197, v442, v441, v446);
                  v158 = (_QWORD *)v435;
                  if (!*v442)
                  {
                    v377 = __si_assert_copy_extra_268();
                    __message_assert_272((uint64_t)v377, v378, v379, v380, v381, v382, v383, v384, (char)"SISearchCtx.h");
                    free(v377);
                    if (__valid_fs(-1))
                      v385 = 2989;
                    else
                      v385 = 3072;
                    *(_DWORD *)v385 = -559038737;
                    abort();
                  }
                }
              }
            }
          }
          collectAttributesFromDBO(v164, v158, a1, (uint64_t)a16, *(char ***)(*a17 + 152));
          v163 = v50;
          goto LABEL_90;
        }
        v170 = *(char ***)(v108 + 152);
        v171 = *(_QWORD *)(v108 + 16);
        v480[3] = unk_1B86318E0;
        v480[4] = xmmword_1B86318F0;
        memset(v480, 0, 48);
        v163 = v50 & 0xFFFFFF0000000000;
        writeDBOToPlistBytes(v164, a15, a16, v170, buf, v171, 0, 0, 0, (uint64_t *)v480, 0, (v50 & 0xFFFFFF0000000000) >> 32, 0, 0, 0, a11, v108, *(_QWORD *)(v108 + 8), a21);
      }
      v71 = a2;
LABEL_90:
      if (*((_QWORD *)&v589 + 1) == v433)
        *((_QWORD *)&v589 + 1) = 0;
      CatInfoGotten_SDB::~CatInfoGotten_SDB((CatInfoGotten_SDB *)buf);
      v89 = (_QWORD *)v22;
      v169 = v163;
      v36 = a19;
      goto LABEL_93;
    }
    v111 = *(_DWORD *)(v108 + 160);
    if (v111 == 4)
    {
      if (!a13 && !*(_QWORD *)(v108 + 176))
      {
LABEL_117:
        v193 = *(_QWORD *)(*a17 + 24);
        v194 = a16[29];
        if (*(_BYTE *)a16)
        {
          v71 = a2;
          if (v194)
          {
            if (!*v445)
            {
              v195 = (const __CFArray *)a16[16];
              if (v195)
              {
                *(_QWORD *)buf = 0;
                SIFlattenArrayToCStringVector(v195, v445, (size_t *)buf, v562);
              }
            }
          }
        }
        else
        {
          v71 = a2;
          if (v194)
          {
            if (!*v442)
            {
              v196 = (const __CFArray *)a16[15];
              if (v196)
              {
                SIFlattenArrayToCStringVector(v196, v442, v441, v446);
                v78 = v440;
                if (!*v442)
                {
                  v368 = __si_assert_copy_extra_268();
                  __message_assert_272((uint64_t)v368, v369, v370, v371, v372, v373, v374, v375, (char)"SISearchCtx.h");
                  free(v368);
                  if (__valid_fs(-1))
                    v376 = 2989;
                  else
                    v376 = 3072;
                  *(_DWORD *)v376 = -559038737;
                  abort();
                }
              }
            }
          }
        }
        collectAttributesFromDBO(v193, (_QWORD *)v435, a1, (uint64_t)a16, *(char ***)(*a17 + 152));
LABEL_33:
        v87 = v438;
        v88 = v439;
        v89 = (_QWORD *)v22;
        goto LABEL_278;
      }
      v112 = (char *)&a19[18 * v75];
      v113 = *((_QWORD *)v112 + 4);
      v114 = *((_QWORD *)v112 + 5);
      v115 = *((_QWORD *)v112 + 9);
      v116 = *((_QWORD *)v112 + 8);
      v117 = *((_DWORD *)v112 + 20);
      v118 = *((_DWORD *)v112 + 21);
      v119 = *((_DWORD *)v112 + 22);
      v121 = *((_DWORD *)v112 + 23);
      v120 = *((_DWORD *)v112 + 24);
      v122 = v112[100];
      v123 = v112[101];
      v124 = v112[16];
      if (*(_BYTE *)(a12 + *((_QWORD *)v112 + 1)))
        goto LABEL_55;
      if (v112[101])
      {
        if (!v112[100])
        {
LABEL_133:
          if (*(_QWORD *)(v108 + 400) & v113 | *(_QWORD *)(v108 + 408) & v114)
          {
            v198 = *(_QWORD *)(v108 + 416) & v113;
            v528 = *(_QWORD *)(v108 + 424) & v114;
            v527 = v198;
          }
          else
          {
            v527 = *((_QWORD *)v112 + 4);
            v528 = v114;
          }
          if (*(_QWORD *)(v108 + 464) & v113 | *(_QWORD *)(v108 + 472) & v114)
          {
            v214 = *(_QWORD *)(v108 + 496) & v113;
            v215 = *(_DWORD *)(v108 + 516);
            v216 = v214 << v215;
            v217 = ((*(_QWORD *)(v108 + 504) & v114) << v215) | (v214 >> 1 >> ~(_BYTE)v215);
            if ((v215 & 0x40) != 0)
            {
              v217 = v216;
              v218 = 0;
            }
            else
            {
              v218 = v216;
            }
            v219 = v217;
            v220 = v218 | 1;
            v221 = v219;
          }
          else
          {
            v221 = 0;
            v220 = 0;
          }
          v222 = *(os_unfair_lock_s **)(v108 + 928);
          v223 = *(_QWORD *)(v108 + 176);
          v529 = v220;
          v530 = v221;
          v531 = v116;
          v532 = v115;
          v533 = v117;
          v534 = v118;
          v535 = v119;
          v536 = v121;
          v537 = v120;
          v538 = v122 & 1;
          v539 = v123 & 1;
          if (ci_donebits_check(v222, a13, v223, v124, &v527))
            goto LABEL_117;
          goto LABEL_156;
        }
      }
      else if (*((_OWORD *)v112 + 4) == 0)
      {
        goto LABEL_133;
      }
LABEL_55:
      if (*(_QWORD *)(v108 + 400) & v113 | *(_QWORD *)(v108 + 408) & v114)
      {
        v125 = *(_QWORD *)(v108 + 416) & v113;
        v541 = *(_QWORD *)(v108 + 424) & v114;
        v540 = v125;
      }
      else
      {
        v540 = *((_QWORD *)v112 + 4);
        v541 = v114;
      }
      if (*(_QWORD *)(v108 + 464) & v113 | *(_QWORD *)(v108 + 472) & v114)
      {
        v183 = *(_QWORD *)(v108 + 496) & v113;
        v184 = *(_DWORD *)(v108 + 516);
        v185 = v183 << v184;
        v186 = ((*(_QWORD *)(v108 + 504) & v114) << v184) | (v183 >> 1 >> ~(_BYTE)v184);
        if ((v184 & 0x40) != 0)
        {
          v186 = v185;
          v187 = 0;
        }
        else
        {
          v187 = v185;
        }
        v188 = v186;
        v189 = v187 | 1;
        v190 = v188;
      }
      else
      {
        v190 = 0;
        v189 = 0;
      }
      v191 = *(os_unfair_lock_s **)(v108 + 928);
      v192 = *(_QWORD *)(v108 + 176);
      v542 = v189;
      v543 = v190;
      v544 = v116;
      v545 = v115;
      v546 = v117;
      v547 = v118;
      v548 = v119;
      v549 = v121;
      v550 = v120;
      v551 = v122 & 1;
      v552 = v123 & 1;
      if ((ci_donebits_push(v191, a13, v192, v124, &v540) & 1) != 0)
        goto LABEL_117;
LABEL_156:
      v87 = v438;
      v88 = v439;
      v89 = (_QWORD *)v22;
      v71 = a2;
      goto LABEL_278;
    }
    v429 = v109;
    v133 = (char *)&a19[18 * v75];
    v134 = *((_QWORD *)v133 + 4);
    v135 = *((_QWORD *)v133 + 5);
    v136 = v135;
    v137 = v134;
    v138 = *((_QWORD *)v133 + 8);
    v422 = *((_QWORD *)v133 + 7);
    v417 = *((_QWORD *)v133 + 6);
    v139 = *((_QWORD *)v133 + 9);
    v140 = v139;
    v141 = v138;
    v142 = *((_DWORD *)v133 + 20);
    v143 = v142;
    v144 = *((float *)v133 + 21);
    v145 = *((_DWORD *)v133 + 22);
    v147 = *((float *)v133 + 23);
    v146 = *((_DWORD *)v133 + 24);
    v148 = v133[100];
    v149 = v133[101];
    v426 = v133[101];
    v586 = *(_QWORD *)(v133 + 102);
    v587 = *((_WORD *)v133 + 55);
    v428 = v133[116];
    v427 = *((_DWORD *)v133 + 28);
    v150 = v133[16];
    v151 = v150;
    v431 = *((_QWORD *)v133 + 16);
    v432 = *((_QWORD *)v133 + 15);
    v416 = v134;
    v430 = v150;
    v423 = v148;
    v419 = v135;
    if (v111 != 3)
      goto LABEL_236;
    ++*(_QWORD *)(v108 + 80);
    v152 = *(_QWORD *)(v108 + 24);
    v584 = v586;
    v585 = v587;
    _ZF = (v134 & a9) == a6 && (v135 & a10) == a7;
    v154 = _ZF;
    if (!v152)
      goto LABEL_236;
    v155 = *(int **)(v152 + 1184);
    if (!v155)
      goto LABEL_236;
    v409 = v154;
    v410 = v138;
    v411 = v139;
    v412 = v135;
    v413 = v134;
    v414 = v148;
    v415 = v149;
    v418 = v138;
    v421 = v142;
    v424 = v139;
    v425 = v145;
    v407 = *(_QWORD *)v435;
    v408 = v150;
    if (*(_QWORD *)(v108 + 352))
    {
      v156 = *(int **)(v152 + 1184);
      *(_QWORD *)&v606 = *(unsigned int *)(v152 + 2064);
      *(_QWORD *)&v580 = 0;
      *(_QWORD *)&v576 = 0;
      if (!db_get_field_by_id(v155, v435, (int *)&v606, (unint64_t *)&v580, (unint64_t *)&v576)&& *(_WORD *)v580 == 11&& (*(_WORD *)(v580 + 2) & 0x10) != 0)
      {
        db_get_string_for_id_locked(v156, *(_DWORD *)(v580 + 13));
      }
      v157 = *(os_unfair_lock_s **)(v108 + 352);
    }
    else
    {
      v157 = 0;
    }
    os_unfair_lock_lock(v157);
    v199 = *(_QWORD *)(v108 + 352);
    if (*(unsigned __int16 *)(v199 + 4) <= v430)
      goto LABEL_235;
    v200 = v199 + 24 * v408;
    v203 = *(_QWORD *)(v200 + 24);
    v201 = (uint64_t *)(v200 + 24);
    v202 = v203;
    v204 = v201 - 2;
    v205 = v203 - 1;
    if (v203 - 1 <= *(_QWORD *)(v108 + 168))
    {
      memset(v573, 0, sizeof(v573));
      v570 = v586;
      v571 = v587;
      v562[0] = v407;
      v562[1] = 0;
      v562[2] = v416;
      v562[3] = v419;
      v562[4] = v417;
      v562[5] = v422;
      v562[6] = v418;
      v562[7] = v424;
      v563 = v142;
      v564 = v144;
      v565 = v425;
      v566 = v147;
      v567 = v146;
      v568 = v423;
      v569 = v426;
      v572 = v409;
      v213 = (__int128 *)v562;
      goto LABEL_234;
    }
    v206 = (_QWORD *)*v204;
    if (*v204)
      v207 = (__int128 *)(*v204 + 112);
    else
      v207 = &ZERO_OIDINFO;
    v208 = *((_DWORD *)v207 + 16);
    v209 = *((float *)v207 + 17);
    if (*((_BYTE *)v207 + 85))
      v210 = 0;
    else
      v210 = v415 == 0;
    if (v210)
    {
      v226 = v207 + 1;
      v224 = *((_QWORD *)v207 + 2);
      v225 = *((_QWORD *)v226 + 1);
      if (__PAIR128__(v225, v224) >= __PAIR128__(v412, v413))
      {
        v212 = v412 == v225 && v413 == v224;
LABEL_161:
        if (!v212)
          goto LABEL_235;
        if (v144 <= v209 && (v144 != v209 || v142 >= v208))
          goto LABEL_235;
      }
    }
    else
    {
      v211 = *((float *)v207 + 19);
      v212 = v147 == v211;
      if (v147 <= v211)
        goto LABEL_161;
    }
    if (v202 == 1)
    {
      v228 = *(_QWORD *)(v108 + 352);
      *(_QWORD *)((char *)v595 + 7) = 0;
      v595[0] = 0;
      v229 = 0;
      v230 = v228;
      goto LABEL_233;
    }
    v231 = *v204;
    v232 = (_OWORD *)(*v204 + 112);
    v233 = v206[15];
    v234 = *(_QWORD *)((char *)v206 + 209);
    v235 = v206[27];
    v236 = &v206[14 * v205];
    v599 = *(_OWORD *)v236;
    v237 = v236[2];
    v238 = v236[3];
    v580 = *((_OWORD *)v236 + 2);
    v581 = *((_OWORD *)v236 + 3);
    v239 = *((_DWORD *)v236 + 16);
    v240 = *((float *)v236 + 17);
    v241 = *((_DWORD *)v236 + 18);
    v242 = *((float *)v236 + 19);
    v578 = *((_DWORD *)v236 + 20);
    v579 = *((_BYTE *)v236 + 84);
    v243 = *((_BYTE *)v236 + 85);
    v244 = *(_QWORD *)((char *)v236 + 86);
    v602 = *((_WORD *)v236 + 47);
    v601 = v244;
    v600 = *((_OWORD *)v236 + 6);
    *v232 = *(_OWORD *)v236;
    *(_QWORD *)(v231 + 128) = v237;
    *(_QWORD *)(v231 + 136) = v238;
    v245 = v581;
    *(_OWORD *)(v231 + 144) = v580;
    *(_OWORD *)(v231 + 160) = v245;
    *(_DWORD *)(v231 + 176) = v239;
    *(float *)(v231 + 180) = v240;
    *(_DWORD *)(v231 + 184) = v241;
    *(float *)(v231 + 188) = v242;
    LODWORD(v232) = v578;
    *(_DWORD *)(v231 + 192) = v578;
    *(_BYTE *)(v231 + 196) = v579;
    *(_BYTE *)(v231 + 197) = v243;
    LOWORD(v236) = v602;
    *(_WORD *)(v231 + 206) = v602;
    v246 = v601;
    *(_QWORD *)(v231 + 198) = v601;
    v247 = v600;
    *(_OWORD *)(v231 + 208) = v600;
    v401 = *v201;
    v402 = v233;
    --*v201;
    v577 = v581;
    v576 = v580;
    v595[0] = v234;
    *(_QWORD *)((char *)v595 + 7) = v235;
    v404 = v238;
    v405 = v237;
    v399 = v237;
    v400 = v238;
    v403 = v239;
    v397 = v241;
    v398 = v239;
    v396 = v243;
    v575 = v579;
    v574 = (int)v232;
    v597 = v246;
    v598 = (__int16)v236;
    v596 = v247;
    v395 = *(uint64_t *)(v199 + 24 * v408 + 16) >> 1;
    v609 = v599;
    v248 = 3;
    v249 = 2;
    v250 = 1;
    v406 = v201 - 2;
    while (1)
    {
      v394 = v250;
      v251 = *v204;
      v252 = *v204 + 112 * v249;
      v253 = *(_QWORD *)(v252 + 16);
      v254 = *(_QWORD *)(v252 + 24);
      v255 = *(_DWORD *)(v252 + 64);
      v256 = *(float *)(v252 + 68);
      v257 = *(_DWORD *)(v252 + 72);
      v258 = *(float *)(v252 + 76);
      v259 = *(unsigned __int8 *)(v252 + 85);
      v260 = *v204 + 112 * v248;
      v261 = *(_OWORD *)v260;
      v263 = *(_QWORD *)(v260 + 16);
      v262 = *(_QWORD *)(v260 + 24);
      v606 = *(_OWORD *)(v260 + 32);
      v607 = *(_OWORD *)(v260 + 48);
      v608 = v261;
      v264 = *(_DWORD *)(v260 + 64);
      v265 = *(float *)(v260 + 68);
      v266 = *(_DWORD *)(v260 + 72);
      v267 = *(float *)(v260 + 76);
      v582 = *(_DWORD *)(v260 + 80);
      v583 = *(_BYTE *)(v260 + 84);
      v268 = *(unsigned __int8 *)(v260 + 85);
      v269 = *(_QWORD *)(v260 + 86);
      v605 = *(_WORD *)(v260 + 94);
      v604 = v269;
      v603 = *(_OWORD *)(v260 + 96);
      if (v248 >= v401)
        break;
      v270 = v263;
      v271 = v262;
      v272 = v266;
      v273 = v268;
      if (!v259)
        goto LABEL_178;
LABEL_173:
      if (v258 < v242)
        goto LABEL_187;
      if (v258 != v242)
        goto LABEL_211;
LABEL_184:
      if (v256 >= v240 && (v256 != v240 || v255 <= v403))
        goto LABEL_211;
LABEL_187:
      v275 = (__int128 *)v252;
      v276 = v254;
      v277 = v253;
      v278 = v255;
      v279 = (int *)(v252 + 80);
      v280 = (uint64_t *)(v252 + 86);
      v281 = (__int128 *)(v252 + 96);
      if (v273)
      {
        if (v267 < v258 || v267 == v258 && (v265 < v256 || v265 == v256 && v264 > v255))
          goto LABEL_196;
      }
      else
      {
        if (__PAIR128__(v271, v270) < __PAIR128__(v254, v253))
        {
          LOBYTE(v273) = 0;
LABEL_196:
          v282 = &v603;
          v280 = &v604;
          v283 = &v582;
          v284 = &v606;
          v275 = &v608;
          v278 = v264;
          v285 = v271;
LABEL_197:
          v286 = v248;
          goto LABEL_208;
        }
        v287 = v271 == v254 && v270 == v253;
        if (v287 && (v265 < v256 || v265 == v256 && v264 > v255))
        {
          LOBYTE(v273) = 0;
          v282 = &v603;
          v280 = &v604;
          v283 = &v582;
          v284 = &v606;
          v275 = &v608;
          v278 = v264;
          v270 = v277;
          v285 = v276;
          goto LABEL_197;
        }
      }
      v284 = (__int128 *)(v252 + 32);
      v283 = v279;
      v282 = v281;
      LOBYTE(v273) = v259;
      v267 = v258;
      v272 = v257;
      v265 = v256;
      v270 = v277;
      v285 = v276;
      v286 = v249;
LABEL_208:
      v599 = *v275;
      v576 = *v284;
      v577 = v284[1];
      v574 = *v283;
      v575 = *((_BYTE *)v283 + 4);
      v597 = *v280;
      v598 = *((_WORD *)v280 + 4);
      v596 = *v282;
      _X8 = v251 + 224 * v286;
      __asm { PRFM            #1, [X8] }
      if (v286 != v394)
      {
        v292 = v251 + 112 * v286;
        v293 = v609;
        *(_OWORD *)v292 = v609;
        *(_QWORD *)(v292 + 24) = v400;
        *(_QWORD *)(v292 + 16) = v399;
        *(_OWORD *)(v292 + 32) = v580;
        *(_OWORD *)(v292 + 48) = v581;
        *(_DWORD *)(v292 + 64) = v398;
        *(float *)(v292 + 68) = v240;
        *(_DWORD *)(v292 + 72) = v397;
        *(float *)(v292 + 76) = v242;
        v294 = v578;
        *(_DWORD *)(v292 + 80) = v578;
        *(_BYTE *)(v292 + 84) = v579;
        *(_BYTE *)(v292 + 85) = v396;
        *(_WORD *)(v292 + 94) = v602;
        v295 = v601;
        *(_QWORD *)(v292 + 86) = v601;
        v296 = v600;
        *(_OWORD *)(v292 + 96) = v600;
        v204 = v406;
        v297 = *v406 + 112 * v394;
        *(_OWORD *)v297 = v599;
        *(_QWORD *)(v297 + 16) = v270;
        *(_QWORD *)(v297 + 24) = v285;
        *(_OWORD *)(v297 + 48) = v577;
        *(_OWORD *)(v297 + 32) = v576;
        *(float *)(v297 + 68) = v265;
        v248 = (2 * v286) | 1;
        *(_DWORD *)(v297 + 64) = v278;
        *(_DWORD *)(v297 + 72) = v272;
        *(float *)(v297 + 76) = v267;
        *(_BYTE *)(v297 + 84) = v575;
        *(_DWORD *)(v297 + 80) = v574;
        *(_BYTE *)(v297 + 85) = v273;
        *(_WORD *)(v297 + 94) = v598;
        *(_QWORD *)(v297 + 86) = v597;
        *(_OWORD *)(v297 + 96) = v596;
        v599 = v293;
        v577 = v581;
        v576 = v580;
        v575 = v579;
        v574 = v294;
        v598 = v602;
        v597 = v295;
        v596 = v296;
        v250 = v286;
        v249 = 2 * v286;
        if (v286 < v395)
          continue;
      }
      goto LABEL_232;
    }
    v582 = 0;
    v583 = 0;
    v606 = xmmword_1B8631990;
    v607 = unk_1B86319A0;
    v608 = MAX_OIDINFO;
    v604 = 0;
    v605 = 0;
    v603 = 0uLL;
    if (v249 >= v401)
      goto LABEL_232;
    v264 = 0;
    v265 = 0.0;
    v267 = 3.4028e38;
    v271 = -1;
    v270 = -1;
    v272 = 0;
    v273 = 0;
    if (v259)
      goto LABEL_173;
LABEL_178:
    if (__PAIR128__(v254, v253) < __PAIR128__(v404, v405))
      goto LABEL_187;
    if (v254 == v404 && v253 == v405)
      goto LABEL_184;
LABEL_211:
    if (v273)
    {
      if (v267 >= v242 && (v267 != v242 || v265 >= v240 && (v265 != v240 || v264 <= v403)))
        goto LABEL_231;
LABEL_220:
      v282 = &v603;
      v280 = &v604;
      v283 = &v582;
      v284 = &v606;
      v275 = &v608;
      v278 = v264;
      v285 = v271;
LABEL_221:
      v286 = v248;
      goto LABEL_208;
    }
    if (__PAIR128__(v271, v270) < __PAIR128__(v404, v405))
    {
      LOBYTE(v273) = 0;
      goto LABEL_220;
    }
    v298 = v271 == v404 && v270 == v405;
    if (v298 && (v265 < v240 || v265 == v240 && v264 > v403))
    {
      LOBYTE(v273) = 0;
      v282 = &v603;
      v280 = &v604;
      v283 = &v582;
      v284 = &v606;
      v275 = &v608;
      v278 = v264;
      v270 = v399;
      v285 = v400;
      goto LABEL_221;
    }
LABEL_231:
    _X8 = v251 + 224 * v394;
    __asm { PRFM            #1, [X8] }
LABEL_232:
    v230 = *(_QWORD *)(v108 + 352);
    v229 = v402;
LABEL_233:
    *(_QWORD *)buf = v407;
    *(_QWORD *)&buf[8] = v229;
    v204 = (uint64_t *)(v230 + 24 * v408 + 8);
    *(_QWORD *)&buf[16] = v416;
    *(_QWORD *)&buf[24] = v419;
    *(_QWORD *)&v589 = v417;
    *((_QWORD *)&v589 + 1) = v422;
    *(_QWORD *)&v590 = v418;
    *((_QWORD *)&v590 + 1) = v424;
    *(_QWORD *)&v591 = __PAIR64__(LODWORD(v144), v421);
    *((_QWORD *)&v591 + 1) = __PAIR64__(LODWORD(v147), v425);
    LODWORD(v592) = v146;
    BYTE4(v592) = v423;
    BYTE5(v592) = v426;
    *(_QWORD *)((char *)&v592 + 6) = v584;
    HIWORD(v592) = v585;
    v593 = v409;
    *(_QWORD *)v594 = v595[0];
    *(_QWORD *)&v594[7] = *(_QWORD *)((char *)v595 + 7);
    v213 = (__int128 *)buf;
LABEL_234:
    pqpush_oid_and_rankinfo_t((uint64_t)v204, v213);
LABEL_235:
    os_unfair_lock_unlock(*(os_unfair_lock_t *)(v108 + 352));
    v151 = v430;
    v145 = v425;
    v140 = v424;
    v143 = v421;
    v141 = v418;
    v136 = v419;
    v137 = v416;
    v149 = v415;
    v148 = v414;
    v135 = v412;
    v134 = v413;
    v138 = v410;
    v139 = v411;
LABEL_236:
    if (a13 || *(_QWORD *)(*a17 + 176))
    {
      v71 = a2;
      v78 = v440;
      if (*(_BYTE *)(a12 + a19[18 * v75 + 1]))
      {
        v301 = *a17;
        goto LABEL_240;
      }
      v303 = (v138 | v139) != 0;
      if (v149)
        v303 = v148 != 0;
      v301 = *a17;
      if (v303 || a22)
      {
LABEL_240:
        if (*(_QWORD *)(v301 + 400) & v134 | *(_QWORD *)(v301 + 408) & v135)
        {
          v302 = *(_QWORD *)(v301 + 416) & v134;
          v515 = *(_QWORD *)(v301 + 424) & v135;
          v514 = v302;
        }
        else
        {
          v514 = v137;
          v515 = v136;
        }
        v305 = *(_QWORD *)(v301 + 464) & v134 | *(_QWORD *)(v301 + 472) & v135;
        if (v305)
        {
          v306 = 0;
          v307 = *(_QWORD *)(v301 + 496) & v134;
          v308 = *(_DWORD *)(v301 + 516);
          v309 = (*(_QWORD *)(v301 + 504) & v135) << v308;
          v310 = v307 << v308;
          v311 = v309 | (v307 >> 1 >> ~(_BYTE)v308);
          if ((v308 & 0x40) != 0)
            v311 = v310;
          else
            v306 = v310;
          v305 = v306 | 1;
        }
        else
        {
          v311 = 0;
        }
        v312 = *(os_unfair_lock_s **)(v301 + 928);
        v313 = *(_QWORD *)(v301 + 176);
        v516 = v305;
        v517 = v311;
        v314 = v141;
        v518 = v141;
        v315 = v140;
        v519 = v140;
        v316 = v143;
        v520 = v143;
        v521 = v144;
        v317 = v145;
        v522 = v145;
        v523 = v147;
        v524 = v146;
        v525 = v148 & 1;
        v526 = v149 & 1;
        v318 = ci_donebits_push(v312, a13, v313, v151, &v514);
      }
      else
      {
        if (*(_QWORD *)(v301 + 400) & v134 | *(_QWORD *)(v301 + 408) & v135)
        {
          v304 = *(_QWORD *)(v301 + 416) & v134;
          v502 = *(_QWORD *)(v301 + 424) & v135;
          v501 = v304;
        }
        else
        {
          v501 = v137;
          v502 = v136;
        }
        v347 = *(_QWORD *)(v301 + 464) & v134 | *(_QWORD *)(v301 + 472) & v135;
        if (v347)
        {
          v348 = 0;
          v349 = *(_QWORD *)(v301 + 496) & v134;
          v350 = *(_DWORD *)(v301 + 516);
          v351 = (*(_QWORD *)(v301 + 504) & v135) << v350;
          v352 = v349 << v350;
          v353 = v351 | (v349 >> 1 >> ~(_BYTE)v350);
          if ((v350 & 0x40) != 0)
            v353 = v352;
          else
            v348 = v352;
          v347 = v348 | 1;
        }
        else
        {
          v353 = 0;
        }
        v354 = *(os_unfair_lock_s **)(v301 + 928);
        v355 = *(_QWORD *)(v301 + 176);
        v503 = v347;
        v504 = v353;
        v314 = v141;
        v505 = v141;
        v315 = v140;
        v506 = v140;
        v316 = v143;
        v507 = v143;
        v508 = v144;
        v317 = v145;
        v509 = v145;
        v510 = v147;
        v511 = v146;
        v512 = v148 & 1;
        v513 = v149 & 1;
        v318 = ci_donebits_check(v354, a13, v355, v151, &v501);
      }
      v319 = v318;
      v320 = a22 | v318;
      v321 = *a17;
      v145 = v317;
      v140 = v315;
      v143 = v316;
      v74 = 65533;
      v136 = v419;
      v141 = v314;
      v137 = v416;
    }
    else
    {
      v320 = 1;
      v321 = *a17;
      v319 = 0;
      v71 = a2;
      v78 = v440;
    }
    if (*(_BYTE *)(*(_QWORD *)(v321 + 8) + 672))
    {
      v322 = v417;
      v323 = v422;
      v324 = v143;
      v325 = v145;
      v326 = v423;
      v327 = v426;
      v73 = v420;
    }
    else
    {
      v322 = v417;
      v323 = v422;
      v324 = v143;
      v325 = v145;
      v326 = v423;
      v327 = v426;
      v73 = v420;
      if (*(_DWORD *)(v321 + 832) == 1)
      {
        v586 = 0;
        v587 = 0;
        v325 = 0;
        v324 = -1;
        v144 = 0.0;
        v136 = 0;
        v322 = 0;
        v323 = 0;
        v141 = 0;
        v140 = 0;
        v137 = 0;
        v147 = 0.0;
        v146 = 0;
        v326 = 0;
        v327 = 0;
      }
    }
    if (v320)
    {
      v328 = *(_DWORD *)(v435 + 40);
      v592 = 0u;
      v591 = 0u;
      v590 = 0u;
      v589 = 0u;
      *(_OWORD *)&buf[16] = 0u;
      *(_OWORD *)buf = 0u;
      v329 = *(_QWORD *)(v321 + 16);
      *(_QWORD *)&buf[16] = *(_QWORD *)(v321 + 24);
      *(_QWORD *)&buf[24] = v329;
      LOBYTE(v589) = 1;
      v590 = 0u;
      v591 = 0u;
      *(_QWORD *)&v592 = 0;
      if (*(_QWORD *)&buf[16])
        v330 = (*(unsigned __int8 *)(*(_QWORD *)&buf[16] + 6586) >> 1) & 1;
      else
        LOBYTE(v330) = 1;
      v333 = v427 | ((unint64_t)v428 << 32);
      v334 = (v328 >> 15) & 1;
      BYTE8(v592) = v330;
      *(_QWORD *)buf = &off_1E6E2A0F8;
      *((_QWORD *)&v589 + 1) = v435;
      if (v319)
        v335 = 8;
      else
        v335 = 0;
      *(_DWORD *)&buf[8] = v335 | v429 | v334;
      v337 = *(_QWORD *)(v321 + 16);
      v336 = *(_QWORD *)(v321 + 24);
      v338 = *(char ***)(v321 + 152);
      v339 = *(_QWORD *)(v321 + 224);
      v340 = *(_QWORD *)(v321 + 232);
      if (a4)
      {
        v491[0] = v137;
        v491[1] = v136;
        v491[2] = v322;
        v491[3] = v323;
        v491[4] = v141;
        v491[5] = v140;
        v492 = v324;
        v493 = v144;
        v494 = v325;
        v495 = v147;
        v496 = v146;
        v497 = v326;
        v498 = v327;
        v499 = v586;
        v341 = v438 & 0xFFFFFF0000000000 | v333 & 0xFFFFFFFFFFLL;
        v500 = v587;
        eventParseDBO(v336, a4, a5, a16, v338, buf, v337, v339, v340, SHIDWORD(v340), v430, (uint64_t)v491, v427, SBYTE4(v341), v432, v431, a3, v321, a21);
        v342 = *(_QWORD *)(*a17 + 104);
        do
        {
          v343 = v342;
          v342 = *(_QWORD *)(v342 + 80);
        }
        while (v342);
        v344 = *(_QWORD *)(v343 + 40);
        v345 = **((_QWORD **)&v589 + 1);
        pthread_rwlock_wrlock((pthread_rwlock_t *)(v344 + 16));
        SIValueSet<unsigned long long>::SIValueSetInsert((unint64_t *)(v344 + 216), v345);
        pthread_rwlock_unlock((pthread_rwlock_t *)(v344 + 16));
        v332 = v341;
        v331 = v439;
        v78 = v440;
        v71 = a2;
      }
      else
      {
        v481[0] = v137;
        v481[1] = v136;
        v481[2] = v322;
        v481[3] = v323;
        v481[4] = v141;
        v481[5] = v140;
        v482 = v324;
        v483 = v144;
        v484 = v325;
        v485 = v147;
        v486 = v146;
        v487 = v326;
        v488 = v327;
        v489 = v586;
        v490 = v587;
        v331 = v439 & 0xFFFFFF0000000000 | v333 & 0xFFFFFFFFFFLL;
        writeDBOToPlistBytes(v336, a15, a16, v338, buf, v337, v339, v340, v430, v481, v427, SBYTE4(v331), v432, v431, *a3, a11, v321, *(_QWORD *)(v321 + 8), a21);
        v332 = v438;
      }
      if (*((_QWORD *)&v589 + 1) == v433)
        *((_QWORD *)&v589 + 1) = 0;
      CatInfoGotten_SDB::~CatInfoGotten_SDB((CatInfoGotten_SDB *)buf);
    }
    else
    {
      v332 = v438;
      v331 = v439;
    }
    v87 = v332;
    v88 = v331;
    v89 = (_QWORD *)v22;
    v36 = a19;
LABEL_278:
    v90 = v88;
    v91 = v78 + 1;
    v22 = (unint64_t)v89;
    v37 = a17;
LABEL_279:
    v77 = v90;
    v346 = v91;
    v52 = v87;
    ++v75;
    v76 = v91;
  }
  while (v75 != v71);
LABEL_291:
  v356 = (unint64_t *)(*v37 + 544);
  do
    v357 = __ldaxr(v356);
  while (__stlxr(v357 + v346, v356));
  v561 = 1;
  v358 = *(_QWORD *)&threadData[18 * v556 + 2];
  v359 = v555;
  v360 = v358 + 320 * v555;
  *(_DWORD *)(v360 + 312) = v457;
  v361 = *(void (**)(_QWORD))(v360 + 232);
  v38 = a14;
  v39 = a20;
  v56 = v467;
  v57 = v466;
  if (v361)
    v361(*(_QWORD *)(v358 + 320 * v359 + 288));
  dropThreadId(v556, 0, v458);
LABEL_296:
  v362 = *(_QWORD *)&threadData[18 * v560 + 2];
  v363 = v559;
  v364 = v362 + 320 * v559;
  *(_DWORD *)(v364 + 312) = v57;
  v365 = *(void (**)(_QWORD))(v364 + 232);
  if (v365)
    v365(*(_QWORD *)(v362 + 320 * v363 + 288));
  dropThreadId(v560, 0, v56);
LABEL_299:
  OSAtomicEnqueue(v39, v36, 0);
  if (v38)
    db_obj_iter_return_page(*(_QWORD *)(*v37 + 912), v38);
  if (!v561)
  {
    v366 = *__error();
    v367 = _SILogForLogForCategory(7);
    if (os_log_type_enabled(v367, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      *(_QWORD *)&buf[4] = "packItems";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 2524;
      _os_log_error_impl(&dword_1B8270000, v367, OS_LOG_TYPE_ERROR, "%s:%d: Assertion caught during query", buf, 0x12u);
    }
    *__error() = v366;
  }
}

uint64_t SISearchCtx_METADATA::photosDerivedAttributes(uint64_t a1, int *a2)
{
  uint64_t result;
  unint64_t v5;
  size_t v6;
  _QWORD *v8;
  int v9;
  uint64_t i;
  void *v11;

  result = *(_QWORD *)(a1 + 1176);
  if (!result)
  {
    os_unfair_lock_lock(&SISearchCtx_METADATA::photosDerivedAttributes(datastore_info *)::initLock);
    if (!*(_QWORD *)(a1 + 1176))
    {
      v5 = *(int *)(a1 + 360);
      v6 = 8 * v5;
      if (((v5 >> 14) & 0x7FFFFFFFFFFFLL) == 0 && v6 > *MEMORY[0x1E0C85AD8])
        ++sTotal;
      v8 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, v6, 0x31F9A007uLL);
      if (!v8)
        _log_fault_for_malloc_failure();
      v9 = *(_DWORD *)(a1 + 360);
      if (v9 >= 1)
      {
        for (i = 0; i < v9; v8[i++] = v11)
        {
          if (a2)
          {
            v11 = db_copy_field_ids_with_buffer(a2, off_1E6E30098[i], 0, 0);
            v9 = *(_DWORD *)(a1 + 360);
          }
          else
          {
            v11 = 0;
          }
        }
      }
      __dmb(0xBu);
      *(_QWORD *)(a1 + 1176) = v8;
    }
    os_unfair_lock_unlock(&SISearchCtx_METADATA::photosDerivedAttributes(datastore_info *)::initLock);
    return *(_QWORD *)(a1 + 1176);
  }
  return result;
}

uint64_t PartialQueryResults::prepare(uint64_t this, int a2, unsigned __int16 a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v6;
  _QWORD *v7;
  char *v8;
  char *v9;
  const char *v10;
  char *v11;
  const char *v12;
  uint64_t v13;

  v4 = this + 464 + 8 * a4;
  if (*(_QWORD *)(v4 + 2048) >= 0xFFFDuLL)
  {
    v6 = this;
    if (*(_QWORD *)(this + 8 * a4 + 1488))
    {
      if (*(_QWORD *)(this + 464 + 8 * a4))
      {
        v7 = (_QWORD *)(v4 + 2048);
        _MDPlistBytesEndArray();
        _MDPlistBytesEndPlist();
        _MDStoreOIDArrayEndBulkAdd();
        _MDStoreOIDArrayEndSequence();
        *(_QWORD *)(v6 + 8 * a4 + 3544) = 0;
        _MDPlistBytesBeginPlist();
        _MDPlistBytesBeginArray();
        _MDPlistBytesAddNull();
        _MDStoreOIDArrayBeginSequence();
        this = _MDStoreOIDArrayBeginBulkAdd();
        *v7 = 0;
        return this;
      }
      v11 = __si_assert_copy_extra_268();
      v9 = v11;
      v12 = "";
      if (v11)
        v12 = v11;
      __message_assert("%s:%u: failed assertion '%s' %s ", "SISearchCtx.h", 951, "fOids[slot]", v12);
    }
    else
    {
      v8 = __si_assert_copy_extra_268();
      v9 = v8;
      v10 = "";
      if (v8)
        v10 = v8;
      __message_assert("%s:%u: failed assertion '%s' %s ", "SISearchCtx.h", 950, "fPlistBytes[slot]", v10);
    }
    free(v9);
    if (__valid_fs(-1))
      v13 = 2989;
    else
      v13 = 3072;
    *(_DWORD *)v13 = -559038737;
    abort();
  }
  return this;
}

void extractSynonymUnalignedMatchingField(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, _QWORD *a10, uint64_t a11)
{
  uint64_t v11;
  int *v12;
  int *v13;
  int *v14;
  int *v15;
  int *v16;
  int *v17;
  int *v18;
  int *v19;
  uint64_t v20;
  uint64_t v21;
  int *v22;
  int *v23;
  uint64_t v24;
  int *v25;
  unint64_t v26;
  uint64_t field_by_id;
  uint64_t v28;
  size_t v29;
  void *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  uint64_t v36;
  int v37;
  int *v38;
  unsigned int v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  char *v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  uint64_t v50;
  int v51;
  unsigned int v52;
  uint64_t *v53;
  unint64_t v54;
  unint64_t v55;
  unsigned int v56;
  unsigned int v57;
  unint64_t v58;
  unint64_t v59;
  char *v60;
  unint64_t v61;
  unint64_t v63;
  uint64_t v64;
  unsigned int v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  int *v69;
  os_unfair_lock_t v70;
  uint64_t *v71;
  uint64_t v72;
  _QWORD *v73;
  uint64_t v74;
  unint64_t v75;
  char *v76;
  unint64_t v77;
  _QWORD v78[9];
  int v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t *v82;
  uint64_t v83;
  char v84;
  unsigned int v85;
  uint64_t *v86;
  uint64_t v87;
  unint64_t v88;
  unint64_t v89;
  _QWORD v90[9];
  int v91;
  _QWORD *v92;
  uint64_t v93;
  unint64_t v94;
  unint64_t v95;
  unint64_t v96;
  unint64_t v97;
  uint64_t v98;
  uint64_t *v99;
  uint64_t v100;
  char v101;
  _QWORD v102[258];

  v11 = MEMORY[0x1E0C80A78](a1);
  v13 = v12;
  v15 = v14;
  v17 = v16;
  v19 = v18;
  v21 = v20;
  v23 = v22;
  v24 = v11;
  v102[256] = *MEMORY[0x1E0C80C00];
  v96 = 0;
  v97 = 0;
  v94 = 0;
  v95 = 0;
  if (!db_get_field_by_id(v22, v20, v25, &v97, &v96) && (~*(unsigned __int16 *)(v97 + 2) & 0x30) != 0)
  {
    if (v96)
    {
      v26 = *(unsigned int *)(v97 + 8);
      field_by_id = db_get_field_by_id(v23, v21, v13, &v95, &v94);
      if (!(_DWORD)field_by_id)
      {
        v75 = v26 >> 3;
        MEMORY[0x1E0C80A78](field_by_id);
        v76 = (char *)&v68 - v28;
        bzero((char *)&v68 - v28, v29);
        os_unfair_lock_lock((os_unfair_lock_t)(v24 + 1152));
        if (!*(_QWORD *)(v24 + 1144))
        {
          v30 = malloc_type_malloc(0x48uLL, 0x2004093837F09uLL);
          v31 = 0;
          *(_QWORD *)(v24 + 1144) = v30;
          do
          {
            *(_QWORD *)(*(_QWORD *)(v24 + 1144) + v31) = 0;
            v31 += 8;
          }
          while (v31 != 72);
        }
        if (v26 <= 7)
        {
          os_unfair_lock_unlock((os_unfair_lock_t)(v24 + 1152));
          return;
        }
        v69 = v17;
        v70 = (os_unfair_lock_t)(v24 + 1152);
        v71 = &v68;
        v32 = 0;
        LODWORD(v77) = 0;
        v74 = a11;
        v73 = a10;
        v72 = a9;
        v33 = v75 <= 1 ? 1 : v75;
        do
        {
          v34 = *(_QWORD *)(v95 + 8 * v32 + 13);
          if (v34 <= 8)
          {
            v35 = *(_QWORD *)(v96 + 8 * v32);
            v36 = *(_QWORD *)(*(_QWORD *)(v24 + 1144) + 8 * v34);
            if (!v36)
            {
              v36 = SIUINT64SetCreate();
              *(_QWORD *)(*(_QWORD *)(v24 + 1144) + 8 * v34) = v36;
            }
            if (SIValueSet<unsigned long long>::SIValueSetInsert((unint64_t *)(v36 + 16), v35))
            {
              v37 = v77;
              *(_DWORD *)&v76[4 * v77] = v32;
              LODWORD(v77) = v37 + 1;
            }
          }
          ++v32;
        }
        while (v33 != v32);
        os_unfair_lock_unlock(v70);
        if ((_DWORD)v77)
        {
          v92 = 0;
          v93 = 0;
          bzero(v102, 0x800uLL);
          if (db_get_field_by_id(v23, v21, v19, (unint64_t *)&v93, (unint64_t *)&v92))
          {
            v38 = v69;
          }
          else
          {
            v38 = v69;
            if ((~*(unsigned __int16 *)(v93 + 2) & 0x30) != 0 || *(_WORD *)v93 != 11)
            {
              LODWORD(v77) = 0;
            }
            else
            {
              v39 = *(_DWORD *)(v93 + 13);
              LODWORD(v89) = 2048;
              v92 = copyDataForUniquedValue((uint64_t)v23, v39, v102, (unsigned int *)&v89);
              v40 = v89;
              if ((_DWORD)v89)
              {
                v41 = 0;
                LODWORD(v42) = 0;
                LODWORD(v70) = 0;
                v43 = v77;
                v45 = v75;
                v44 = v76;
                do
                {
                  v46 = v42;
                  do
                  {
                    v42 = v46;
                    v47 = *(unsigned int *)&v44[4 * v46++];
                  }
                  while (v41 > v47 && v42 < v43);
                  if (v41 == v47 && v41 < v45)
                  {
                    v81 = 1;
                    v98 = 0;
                    v99 = &v98;
                    v100 = 0x2000000000;
                    v101 = 0;
                    v50 = *(_QWORD *)(v24 + 152);
                    v90[0] = MEMORY[0x1E0C809B0];
                    v90[1] = 0x40000000;
                    v90[2] = ___ZL36extractSynonymUnalignedMatchingFieldP20SISearchCtx_METADATAP14datastore_infoP6db_objPKjS6_S6_S6_S6_P19PartialQueryResultsP10query_nodeP14__MDPlistBytes_block_invoke;
                    v90[3] = &unk_1E6E30150;
                    v90[4] = &v98;
                    v90[5] = v72;
                    v91 = v41;
                    v90[6] = v96;
                    v90[7] = v74;
                    v90[8] = v95;
                    db_query_enumerate_matched_qps_for_dbf((uint64_t)v23, v73, v93, (uint64_t)v92 + 4 * v41, (uint64_t)&v81, v50, (uint64_t)v90);
                    if (!*((_BYTE *)v99 + 24))
                    {
                      v51 = (int)v70;
                      *(_DWORD *)&v76[4 * v70] = v41;
                      LODWORD(v70) = v51 + 1;
                    }
                    _Block_object_dispose(&v98, 8);
                    v44 = v76;
                  }
                  ++v41;
                }
                while (v41 < v40 && v77 > v42);
              }
              else
              {
                LODWORD(v70) = 0;
              }
              LODWORD(v77) = (_DWORD)v70;
              v38 = v69;
            }
            if (v92 != v102)
              free(v92);
            if (!(_DWORD)v77)
              return;
          }
          bzero(&v98, 0x800uLL);
          v88 = 0;
          v89 = 0;
          if (!db_get_field_by_id(v23, v21, v15, &v89, &v88)
            && (~*(unsigned __int16 *)(v89 + 2) & 0x30) != 0)
          {
            v86 = 0;
            v87 = 0;
            if (!db_get_field_by_id(v23, v21, v38, (unint64_t *)&v87, (unint64_t *)&v86)
              && (~*(unsigned __int16 *)(v87 + 2) & 0x30) == 0
              && *(_WORD *)v87 == 11)
            {
              v52 = *(_DWORD *)(v87 + 13);
              v85 = 2048;
              v53 = (uint64_t *)copyDataForUniquedValue((uint64_t)v23, v52, &v98, &v85);
              v86 = v53;
              if (v85 >= 4)
              {
                v54 = 0;
                LODWORD(v55) = 0;
                v56 = 0;
                v57 = v85 >> 2;
                v58 = v77;
                v59 = v75;
                v60 = v76;
                LODWORD(v70) = v85 >> 2;
                v77 = v77;
                while (1)
                {
                  v61 = *(unsigned int *)&v60[4 * v54];
                  if (v61 <= v55 || v55 >= v59)
                  {
                    if (v55 < v59)
                    {
                      v63 = v88;
LABEL_65:
                      v81 = 0;
                      v82 = &v81;
                      v83 = 0x2000000000;
                      v84 = 0;
                      v64 = *(_QWORD *)(v63 + 8 * v55);
                      v65 = v56 + v64;
                      if (v56 < v56 + v64)
                      {
                        v66 = 4 * v56;
                        do
                        {
                          if (*((_BYTE *)v82 + 24))
                            break;
                          v80 = 1;
                          v67 = *(_QWORD *)(v24 + 152);
                          v78[0] = MEMORY[0x1E0C809B0];
                          v78[1] = 0x40000000;
                          v78[2] = ___ZL36extractSynonymUnalignedMatchingFieldP20SISearchCtx_METADATAP14datastore_infoP6db_objPKjS6_S6_S6_S6_P19PartialQueryResultsP10query_nodeP14__MDPlistBytes_block_invoke_2;
                          v78[3] = &unk_1E6E30178;
                          v78[4] = &v81;
                          v78[5] = v72;
                          v79 = v55;
                          v78[6] = v96;
                          v78[7] = v74;
                          v78[8] = v95;
                          db_query_enumerate_matched_qps_for_dbf((uint64_t)v23, v73, v87, (uint64_t)v86 + v66, (uint64_t)&v80, v67, (uint64_t)v78);
                          v66 += 4;
                          LODWORD(v64) = v64 - 1;
                        }
                        while ((_DWORD)v64);
                      }
                      _Block_object_dispose(&v81, 8);
                      v56 = v65;
                      v59 = v75;
                      v60 = v76;
                      v57 = v70;
                      v58 = v77;
                    }
                  }
                  else
                  {
                    v63 = v88;
                    v55 = v55;
                    do
                      v56 += *(_QWORD *)(v88 + 8 * v55++);
                    while (v55 < v61 && v55 < v59);
                    if (v55 < v59)
                      goto LABEL_65;
                  }
                  if (v56 < v57)
                  {
                    ++v54;
                    LODWORD(v55) = v55 + 1;
                    if (v54 < v58)
                      continue;
                  }
                  v53 = v86;
                  break;
                }
              }
              if (v53 != &v98)
                free(v53);
            }
          }
        }
      }
    }
  }
}

void extractPersonUnalignedMatchingField(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t *a9, uint64_t a10, uint64_t a11)
{
  uint64_t v11;
  uint64_t v12;
  int *v13;
  int *v14;
  int *v15;
  int *v16;
  int *v17;
  int *v18;
  int *v19;
  int *v20;
  uint64_t v21;
  uint64_t v22;
  int *v23;
  int *v24;
  unsigned int v25;
  void *v26;
  unsigned int v27;
  unint64_t v28;
  uint64_t v29;
  char *v30;
  size_t v31;
  uint64_t v32;
  os_unfair_lock_s *v33;
  uint64_t v34;
  unsigned int v35;
  uint64_t v36;
  int v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  uint64_t v46;
  uint64_t *v47;
  _QWORD *v48;
  uint64_t v49;
  int v50;
  unsigned int v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  uint64_t *v59;
  uint64_t v60;
  _QWORD *v61;
  uint64_t v62;
  int v63;
  unsigned int v64;
  uint64_t v65;
  int field_by_id;
  unint64_t v67;
  uint64_t v68;
  unsigned int v69;
  uint64_t *v70;
  unint64_t v71;
  unint64_t v72;
  unsigned int v73;
  unsigned int v74;
  unint64_t v75;
  unint64_t v76;
  unint64_t v78;
  int *v79;
  unint64_t v80;
  uint64_t *v81;
  uint64_t k;
  _QWORD *v83;
  uint64_t v84;
  unsigned int *v85;
  unsigned int v86;
  int *v87;
  unint64_t v88;
  uint64_t v89;
  unint64_t v90;
  uint64_t v91;
  uint64_t i;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t *v97;
  uint64_t v98;
  uint64_t j;
  _QWORD *v100;
  uint64_t v101;
  uint64_t v102;
  int *v105;
  unint64_t v106;
  int **v107;
  uint64_t v108;
  unint64_t v109;
  int *v110;
  unint64_t v111;
  uint64_t *v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  _QWORD v117[9];
  int v118;
  _QWORD v119[10];
  int v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t *v123;
  uint64_t v124;
  char v125;
  unsigned int v126;
  uint64_t *v127;
  uint64_t v128;
  unint64_t v129;
  unint64_t v130;
  _QWORD v131[10];
  int v132;
  uint64_t *v133;
  uint64_t v134;
  _QWORD v135[9];
  int v136;
  void *v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t *v140;
  uint64_t v141;
  char v142;
  uint64_t v143;
  uint64_t *v144;
  uint64_t v145;
  char v146;
  _QWORD v147[258];

  v11 = MEMORY[0x1E0C80A78](a1);
  v115 = v12;
  v116 = v11;
  v14 = v13;
  v16 = v15;
  v18 = v17;
  v20 = v19;
  v22 = v21;
  v24 = v23;
  v147[256] = *MEMORY[0x1E0C80C00];
  v138 = 0;
  v137 = 0;
  bzero(v147, 0x800uLL);
  if (!db_get_field_by_id(v24, v22, v14, (unint64_t *)&v138, (unint64_t *)&v137))
  {
    if ((~*(unsigned __int16 *)(v138 + 2) & 0x30) != 0)
    {
      v27 = *(_DWORD *)(v138 + 8);
      v26 = v137;
      if (!v137)
        return;
    }
    else
    {
      v25 = *(_DWORD *)(v138 + 13);
      LODWORD(v143) = 2048;
      v26 = copyDataForUniquedValue((uint64_t)v24, v25, v147, (unsigned int *)&v143);
      v137 = v26;
      v27 = v143;
      if (!v26)
        return;
    }
    v109 = (unint64_t)v16;
    v110 = v20;
    v28 = v27 >> 2;
    MEMORY[0x1E0C80A78](v26);
    v30 = (char *)&v105 - v29;
    bzero((char *)&v105 - v29, v31);
    v32 = v116;
    v33 = (os_unfair_lock_s *)(v116 + 1168);
    os_unfair_lock_lock((os_unfair_lock_t)(v116 + 1168));
    if (!*(_QWORD *)(v32 + 1160))
      *(_QWORD *)(v116 + 1160) = SIUINT32SetCreate();
    if (v27 <= 3)
    {
      os_unfair_lock_unlock((os_unfair_lock_t)(v32 + 1168));
      return;
    }
    v108 = v22;
    v34 = 0;
    v35 = 0;
    v113 = a10;
    v112 = a9;
    v114 = a11;
    if (v28 <= 1)
      v36 = 1;
    else
      v36 = v28;
    do
    {
      if ((SIUINT32SetContainsValue(*(_QWORD *)(v116 + 1160), *((_DWORD *)v137 + v34)) & 1) == 0)
        *(_DWORD *)&v30[4 * v35++] = v34;
      ++v34;
    }
    while (v36 != v34);
    os_unfair_lock_unlock(v33);
    if (v35)
    {
      v105 = v18;
      v111 = v28;
      v107 = &v105;
      if (v113 >= 1)
      {
        v37 = 0;
        v38 = v112;
        v39 = v113;
        do
        {
          v40 = *v38++;
          v37 |= isQueryNodePhotosPersonIdentifier(v40);
          --v39;
        }
        while (v39);
        if ((v37 & 1) != 0 && (~*(unsigned __int16 *)(v138 + 2) & 0x30) == 0)
        {
          v41 = 0;
          LODWORD(v42) = 0;
          LODWORD(v106) = 0;
          do
          {
            v43 = v42;
            do
            {
              v42 = v43;
              v44 = *(unsigned int *)&v30[4 * v43++];
            }
            while (v41 > v44 && v42 < v35);
            if (v41 == v44)
            {
              v139 = 1;
              v143 = 0;
              v144 = &v143;
              v145 = 0x2000000000;
              v47 = v112;
              v46 = v113;
              v146 = 0;
              do
              {
                v48 = (_QWORD *)*v47;
                if (isQueryNodePhotosPersonIdentifier(*v47))
                {
                  v49 = *(_QWORD *)(v116 + 152);
                  v135[0] = MEMORY[0x1E0C809B0];
                  v135[1] = 0x40000000;
                  v135[2] = ___ZL35extractPersonUnalignedMatchingFieldP20SISearchCtx_METADATAP14datastore_infoP6db_objPKjS6_S6_S6_P19PartialQueryResultsPP10query_nodelP14__MDPlistBytes_block_invoke;
                  v135[3] = &unk_1E6E301A0;
                  v135[4] = &v143;
                  v135[5] = v137;
                  v136 = v41;
                  v135[6] = v115;
                  v135[7] = v114;
                  v135[8] = v24;
                  db_query_enumerate_matched_qps_for_dbf((uint64_t)v24, v48, v138, (uint64_t)v137 + 4 * v41, (uint64_t)&v139, v49, (uint64_t)v135);
                }
                ++v47;
                --v46;
              }
              while (v46);
              if (!*((_BYTE *)v144 + 24))
              {
                v50 = v106;
                *(_DWORD *)&v30[4 * v106] = v41;
                LODWORD(v106) = v50 + 1;
              }
              _Block_object_dispose(&v143, 8);
            }
            ++v41;
          }
          while (v41 < v111 && v35 > v42);
        }
      }
      v133 = 0;
      v134 = 0;
      bzero(&v143, 0x800uLL);
      if (!db_get_field_by_id(v24, v108, v110, (unint64_t *)&v134, (unint64_t *)&v133))
      {
        if ((~*(unsigned __int16 *)(v134 + 2) & 0x30) != 0 || *(_WORD *)v134 != 11)
        {
          v64 = 0;
        }
        else
        {
          v51 = *(_DWORD *)(v134 + 13);
          LODWORD(v130) = 2048;
          v133 = (uint64_t *)copyDataForUniquedValue((uint64_t)v24, v51, &v143, (unsigned int *)&v130);
          v52 = v130;
          if ((_DWORD)v130)
          {
            v53 = 0;
            LODWORD(v54) = 0;
            LODWORD(v110) = 0;
            v106 = v130;
            do
            {
              v55 = v54;
              do
              {
                v54 = v55;
                v56 = *(unsigned int *)&v30[4 * v55++];
              }
              while (v53 > v56 && v54 < v35);
              if (v53 == v56 && v53 < v111)
              {
                v122 = 1;
                v139 = 0;
                v140 = &v139;
                v141 = 0x2000000000;
                v59 = v112;
                v60 = v113;
                v142 = 0;
                if (v113 < 1)
                  goto LABEL_60;
                do
                {
                  v61 = (_QWORD *)*v59;
                  if (isQueryNodeMatchingAnyField(*v59))
                  {
                    v62 = *(_QWORD *)(v116 + 152);
                    v131[0] = MEMORY[0x1E0C809B0];
                    v131[1] = 0x40000000;
                    v131[2] = ___ZL35extractPersonUnalignedMatchingFieldP20SISearchCtx_METADATAP14datastore_infoP6db_objPKjS6_S6_S6_P19PartialQueryResultsPP10query_nodelP14__MDPlistBytes_block_invoke_2;
                    v131[3] = &unk_1E6E301C8;
                    v131[4] = &v139;
                    v131[5] = v137;
                    v132 = v53;
                    v131[6] = v116;
                    v131[7] = v115;
                    v131[8] = v114;
                    v131[9] = v24;
                    db_query_enumerate_matched_qps_for_dbf((uint64_t)v24, v61, v134, (uint64_t)v133 + 4 * v53, (uint64_t)&v122, v62, (uint64_t)v131);
                  }
                  ++v59;
                  --v60;
                }
                while (v60);
                if (!*((_BYTE *)v140 + 24))
                {
LABEL_60:
                  v63 = (int)v110;
                  *(_DWORD *)&v30[4 * v110] = v53;
                  LODWORD(v110) = v63 + 1;
                }
                _Block_object_dispose(&v139, 8);
                v52 = v106;
              }
              ++v53;
            }
            while (v53 < v52 && v35 > v54);
          }
          else
          {
            LODWORD(v110) = 0;
          }
          v64 = v110;
        }
        if (v133 != &v143)
          free(v133);
        if (v64)
        {
          bzero(&v139, 0x800uLL);
          v129 = 0;
          v130 = 0;
          v65 = v108;
          if (!db_get_field_by_id(v24, v108, (int *)v109, &v130, &v129)
            && (~*(unsigned __int16 *)(v130 + 2) & 0x30) != 0)
          {
            v127 = 0;
            v128 = 0;
            field_by_id = db_get_field_by_id(v24, v65, v105, (unint64_t *)&v128, (unint64_t *)&v127);
            v67 = v111;
            if (!field_by_id)
            {
              v68 = v128;
              if ((~*(unsigned __int16 *)(v128 + 2) & 0x30) != 0 || *(_WORD *)v128 != 11)
              {
                v85 = (unsigned int *)(v128 + 8);
                v86 = *(_DWORD *)(v128 + 8);
                if (v86)
                {
                  v87 = 0;
                  LODWORD(v88) = 0;
                  v89 = 0;
                  v109 = v64;
                  do
                  {
                    v90 = *(unsigned int *)&v30[4 * (_QWORD)v87];
                    if (v90 <= v88)
                      goto LABEL_120;
                    v88 = v88;
                    do
                    {
                      v91 = *(_QWORD *)(v129 + 8 * v88);
                      if (v91)
                      {
                        for (i = 0; i != v91; ++i)
                        {
                          if (v89 < v86)
                          {
                            v89 = v89;
                            while (*((_BYTE *)v127 + v89))
                            {
                              if (v86 == ++v89)
                              {
                                LODWORD(v89) = v86;
                                break;
                              }
                            }
                          }
                          v89 = (v89 + 1);
                        }
                      }
                      ++v88;
                    }
                    while (v88 < v90 && v88 < v67);
                    if (v88 < v67)
                    {
LABEL_120:
                      v122 = 0;
                      v123 = &v122;
                      v124 = 0x2000000000;
                      v125 = 0;
                      v93 = v89;
                      v94 = *(_QWORD *)(v129 + 8 * v88);
                      if (v94)
                      {
                        v95 = 0;
                        v96 = *v85;
                        LODWORD(v93) = v89;
                        do
                        {
                          if (v93 < v96)
                          {
                            v93 = v93;
                            while (*((_BYTE *)v127 + v93))
                            {
                              if (v96 == ++v93)
                              {
                                LODWORD(v93) = v96;
                                break;
                              }
                            }
                          }
                          v93 = (v93 + 1);
                          ++v95;
                        }
                        while (v95 != v94);
                      }
                      v110 = v87;
                      if (v89 < v93)
                      {
                        v97 = &v122;
                        LODWORD(v98) = v89;
                        do
                        {
                          if (*((_BYTE *)v97 + 24))
                            break;
                          v121 = 1;
                          if (v113 < 1)
                            goto LABEL_139;
                          for (j = 0; j < v113; ++j)
                          {
                            v100 = (_QWORD *)v112[j];
                            if ((isQueryNodeMatchingAnyField((uint64_t)v100) & 1) != 0
                              || isQueryNodeMatchingPersonNamesAlternatives((uint64_t)v100))
                            {
                              v101 = *(_QWORD *)(v116 + 152);
                              v117[0] = MEMORY[0x1E0C809B0];
                              v117[1] = 0x40000000;
                              v117[2] = ___ZL35extractPersonUnalignedMatchingFieldP20SISearchCtx_METADATAP14datastore_infoP6db_objPKjS6_S6_S6_P19PartialQueryResultsPP10query_nodelP14__MDPlistBytes_block_invoke_4;
                              v117[3] = &unk_1E6E30218;
                              v117[4] = &v122;
                              v117[5] = v137;
                              v118 = v88;
                              v117[6] = v24;
                              v117[7] = v115;
                              v117[8] = v114;
                              db_query_enumerate_matched_qps_for_dbf((uint64_t)v24, v100, v128, (uint64_t)v127 + v98, (uint64_t)&v121, v101, (uint64_t)v117);
                              v97 = v123;
                            }
                            if (*((_BYTE *)v97 + 24))
                              break;
                          }
                          v67 = v111;
                          if (!*((_BYTE *)v97 + 24))
                          {
LABEL_139:
                            v102 = *(unsigned int *)(v128 + 8);
                            if (v98 < v102)
                            {
                              v98 = v98;
                              while (*((_BYTE *)v127 + v98))
                              {
                                if (v102 == ++v98)
                                {
                                  LODWORD(v98) = *(_DWORD *)(v128 + 8);
                                  break;
                                }
                              }
                            }
                            LODWORD(v98) = v98 + 1;
                          }
                        }
                        while (v98 < v93);
                      }
                      _Block_object_dispose(&v122, 8);
                      v68 = v128;
                      v89 = v93;
                      v87 = v110;
                    }
                    v87 = (int *)((char *)v87 + 1);
                    LODWORD(v88) = v88 + 1;
                    v85 = (unsigned int *)(v68 + 8);
                    v86 = *(_DWORD *)(v68 + 8);
                  }
                  while (v89 < v86
                       && v88 < v67
                       && (unint64_t)v87 < v109);
                }
              }
              else
              {
                v69 = *(_DWORD *)(v128 + 13);
                v126 = 2048;
                v70 = (uint64_t *)copyDataForUniquedValue((uint64_t)v24, v69, &v139, &v126);
                v127 = v70;
                if (v126 >= 4)
                {
                  v71 = 0;
                  LODWORD(v72) = 0;
                  v73 = 0;
                  v74 = v126 >> 2;
                  v75 = v64;
                  LODWORD(v108) = v126 >> 2;
                  v106 = v64;
                  while (1)
                  {
                    v76 = *(unsigned int *)&v30[4 * v71];
                    if (v76 <= v72 || v72 >= v67)
                    {
                      if (v72 < v67)
                      {
                        v78 = v129;
LABEL_88:
                        v122 = 0;
                        v123 = &v122;
                        v124 = 0x2000000000;
                        v125 = 0;
                        v79 = (int *)(v73 + *(_QWORD *)(v78 + 8 * v72));
                        v109 = v71;
                        v110 = v79;
                        if (v73 < v79)
                        {
                          v80 = v73;
                          v81 = &v122;
                          do
                          {
                            if (*((_BYTE *)v81 + 24))
                              break;
                            v121 = 1;
                            if (v113 >= 1)
                            {
                              for (k = 0; k < v113; ++k)
                              {
                                v83 = (_QWORD *)v112[k];
                                if ((isQueryNodeMatchingAnyField((uint64_t)v83) & 1) != 0
                                  || isQueryNodeMatchingPersonNamesAlternatives((uint64_t)v83))
                                {
                                  v84 = *(_QWORD *)(v116 + 152);
                                  v119[0] = MEMORY[0x1E0C809B0];
                                  v119[1] = 0x40000000;
                                  v119[2] = ___ZL35extractPersonUnalignedMatchingFieldP20SISearchCtx_METADATAP14datastore_infoP6db_objPKjS6_S6_S6_P19PartialQueryResultsPP10query_nodelP14__MDPlistBytes_block_invoke_3;
                                  v119[3] = &unk_1E6E301F0;
                                  v119[4] = &v122;
                                  v119[5] = v137;
                                  v120 = v72;
                                  v119[6] = v116;
                                  v119[7] = v115;
                                  v119[8] = v114;
                                  v119[9] = v24;
                                  db_query_enumerate_matched_qps_for_dbf((uint64_t)v24, v83, v128, (uint64_t)v127 + 4 * v80, (uint64_t)&v121, v84, (uint64_t)v119);
                                  v81 = v123;
                                }
                                if (*((_BYTE *)v81 + 24))
                                  break;
                              }
                            }
                            ++v80;
                          }
                          while ((int *)v80 != v110);
                        }
                        _Block_object_dispose(&v122, 8);
                        v73 = v110;
                        v67 = v111;
                        v71 = v109;
                        v74 = v108;
                        v75 = v106;
                      }
                    }
                    else
                    {
                      v78 = v129;
                      v72 = v72;
                      do
                        v73 += *(_QWORD *)(v129 + 8 * v72++);
                      while (v72 < v76 && v72 < v67);
                      if (v72 < v67)
                        goto LABEL_88;
                    }
                    if (v73 < v74)
                    {
                      ++v71;
                      LODWORD(v72) = v72 + 1;
                      if (v71 < v75)
                        continue;
                    }
                    v70 = v127;
                    break;
                  }
                }
                if (v70 != &v139)
                  free(v70);
              }
            }
          }
        }
      }
    }
  }
}

void collectAttributesFromDBO(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4, char **a5)
{
  int *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const __CFArray *v13;
  uint64_t v14;
  const __CFArray *v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  const void *v27;
  const void *Value;
  CFDictionaryRef v29;
  unsigned int *v30;
  uint64_t v31;
  void *Mutable;
  CFTypeID v33;
  CFIndex Count;
  CFIndex v35;
  CFIndex i;
  const void *ValueAtIndex;
  char **v38;
  uint64_t v40;
  unsigned __int8 *v41;
  unsigned __int16 *v42;

  v9 = *(int **)(a1 + 1184);
  v10 = PartialQueryResults::attributeIdVector((_QWORD *)a4, v9);
  v11 = *(_QWORD *)(a4 + 232);
  if (*(_BYTE *)a4)
  {
    if (v11 && !*(_QWORD *)(a4 + 184))
    {
      v12 = *(_QWORD *)(a4 + 104);
      if (!v12)
      {
        v13 = *(const __CFArray **)(a4 + 128);
        if (v13)
        {
          v42 = 0;
          SIFlattenArrayToCStringVector(v13, (char **)(a4 + 104), (size_t *)&v42, (CFIndex *)&v41);
          v12 = *(_QWORD *)(a4 + 104);
        }
        else
        {
          v12 = 0;
        }
      }
      PartialQueryResults::setupCannedCollectAttributeVector(a4, v12, (_QWORD *)(a4 + 184), &v42);
    }
    v25 = (uint64_t *)(a4 + 184);
  }
  else
  {
    if (v11 && !*(_QWORD *)(a4 + 176))
    {
      v14 = *(_QWORD *)(a4 + 96);
      if (!v14)
      {
        v15 = *(const __CFArray **)(a4 + 120);
        if (v15)
        {
          SIFlattenArrayToCStringVector(v15, (char **)(a4 + 96), (size_t *)(a4 + 240), (CFIndex *)(a4 + 232));
          v14 = *(_QWORD *)(a4 + 96);
          if (!v14)
          {
            v16 = __si_assert_copy_extra_268();
            __message_assert_272((uint64_t)v16, v17, v18, v19, v20, v21, v22, v23, (char)"SISearchCtx.h");
            free(v16);
            if (__valid_fs(-1))
              v24 = 2989;
            else
              v24 = 3072;
            *(_DWORD *)v24 = -559038737;
            abort();
          }
        }
        else
        {
          v14 = 0;
        }
      }
      PartialQueryResults::setupCannedCollectAttributeVector(a4, v14, (_QWORD *)(a4 + 176), (_QWORD *)(a4 + 16));
    }
    v25 = (uint64_t *)(a4 + 176);
  }
  if (a3 >= 1)
  {
    v26 = 0;
    v40 = *v25;
    v38 = a5;
    do
    {
      v41 = 0;
      v42 = 0;
      if (a2)
      {
        if (db_get_field_by_id(v9, (uint64_t)a2, *(int **)(v10 + 8 * v26), (unint64_t *)&v42, (unint64_t *)&v41))
        {
          v27 = *(const void **)(v40 + 8 * v26);
          if (v27)
          {
            Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a4 + 112), *(const void **)(v40 + 8 * v26));
            if (!Value)
            {
              Value = CFSetCreateMutable((CFAllocatorRef)kCIQueryZoneAllocator, 0, MEMORY[0x1E0C9B3B0]);
              CFDictionarySetValue(*(CFMutableDictionaryRef *)(a4 + 112), v27, Value);
              CFRelease(Value);
            }
            ((void (*)(uint64_t, _QWORD, _QWORD *, const void *, char **))v27)(a1, *a2, a2, Value, a5);
          }
        }
        else
        {
          v29 = _decodeSDBField((unint64_t)v9, v42, v41, a5, 0, 0, 1, (CFAllocatorRef)kCIQueryZoneAllocator);
          v30 = *(unsigned int **)(v10 + 8 * v26);
          if (v30)
            v31 = *v30;
          else
            v31 = 4294967294;
          Mutable = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(a4 + 112), (const void *)v31);
          if (!Mutable)
          {
            Mutable = CFSetCreateMutable((CFAllocatorRef)kCIQueryZoneAllocator, 0, MEMORY[0x1E0C9B3B0]);
            CFDictionarySetValue(*(CFMutableDictionaryRef *)(a4 + 112), (const void *)v31, Mutable);
            CFRelease(Mutable);
          }
          v33 = CFGetTypeID(v29);
          if (v33 == CFArrayGetTypeID())
          {
            Count = CFArrayGetCount(v29);
            if (Count >= 1)
            {
              v35 = Count;
              for (i = 0; i != v35; ++i)
              {
                ValueAtIndex = CFArrayGetValueAtIndex(v29, i);
                CFSetAddValue((CFMutableSetRef)Mutable, ValueAtIndex);
              }
            }
          }
          else
          {
            CFSetAddValue((CFMutableSetRef)Mutable, v29);
          }
          CFRelease(v29);
          a5 = v38;
        }
      }
      ++v26;
    }
    while (v26 != a3);
  }
}

__n128 pqpush_oid_and_rankinfo_t(uint64_t a1, __int128 *a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  size_t v8;
  _OWORD *v9;
  _OWORD *v10;
  uint64_t v11;
  __int128 v12;
  __int128 v13;
  __n128 result;
  __int128 v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  float v19;
  float v20;
  float v21;
  unint64_t v22;
  unint64_t v23;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  _OWORD *v31;
  BOOL v32;
  __int128 v33;
  __int128 v34;
  __n128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;

  v4 = *(_QWORD *)(a1 + 8);
  v5 = *(_QWORD *)(a1 + 16);
  v6 = v5;
  if ((uint64_t)(v5 + 2) >= v4)
  {
    v7 = 2 * v4;
    if (v4 < 4)
      v7 = 4;
    *(_QWORD *)(a1 + 8) = v7;
    v8 = 112 * v7 + 224;
    if (*(_QWORD *)a1)
      v9 = malloc_type_zone_realloc((malloc_zone_t *)queryZone, *(void **)a1, v8, 0xECA6AA46uLL);
    else
      v9 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, v8, 0x8DDAA030uLL);
    v10 = v9;
    if (!v9)
      _log_fault_for_malloc_failure();
    *(_QWORD *)a1 = v10;
    *v10 = ZERO_OIDINFO;
    v10[1] = *(_OWORD *)algn_1B8631910;
    v10[6] = xmmword_1B8631960;
    v10[4] = xmmword_1B8631940;
    v10[5] = unk_1B8631950;
    v10[2] = xmmword_1B8631920;
    v10[3] = unk_1B8631930;
    v6 = *(_QWORD *)(a1 + 16);
  }
  *(_QWORD *)(a1 + 16) = v6 + 1;
  v11 = *(_QWORD *)a1 + 112 * v5;
  v12 = a2[2];
  v13 = *a2;
  *(_OWORD *)(v11 + 16) = a2[1];
  *(_OWORD *)(v11 + 32) = v12;
  result = (__n128)a2[3];
  v15 = a2[4];
  v16 = a2[6];
  *(_OWORD *)(v11 + 80) = a2[5];
  *(_OWORD *)(v11 + 96) = v16;
  *(__n128 *)(v11 + 48) = result;
  *(_OWORD *)(v11 + 64) = v15;
  *(_OWORD *)v11 = v13;
  if ((uint64_t)v5 >= 2)
  {
    do
    {
      v17 = *(_QWORD *)a1 + 112 * v5;
      result.n128_u32[0] = *(_DWORD *)(v17 + 68);
      v18 = *(_QWORD *)a1 + 112 * (v5 >> 1);
      v19 = *(float *)(v18 + 68);
      if (*(_BYTE *)(v17 + 85))
      {
        v20 = *(float *)(v17 + 76);
        v21 = *(float *)(v18 + 76);
        if (v20 < v21)
          goto LABEL_27;
        if (v20 != v21)
          return result;
      }
      else
      {
        v23 = *(_QWORD *)(v17 + 16);
        v22 = *(_QWORD *)(v17 + 24);
        if (__PAIR128__(v22, v23) < *(_OWORD *)(v18 + 16))
          goto LABEL_27;
        if (v22 != *(_QWORD *)(v18 + 24) || v23 != *(_QWORD *)(v18 + 16))
          return result;
      }
      if (result.n128_f32[0] >= v19 && (result.n128_f32[0] != v19 || *(_DWORD *)(v17 + 64) < *(_DWORD *)(v18 + 64)))
        return result;
LABEL_27:
      v37 = *(_OWORD *)(v17 + 64);
      v38 = *(_OWORD *)(v17 + 80);
      v39 = *(_OWORD *)(v17 + 96);
      v33 = *(_OWORD *)v17;
      v34 = *(_OWORD *)(v17 + 16);
      v35 = *(__n128 *)(v17 + 32);
      v36 = *(_OWORD *)(v17 + 48);
      v27 = *(_OWORD *)(v18 + 16);
      v26 = *(_OWORD *)(v18 + 32);
      *(_OWORD *)v17 = *(_OWORD *)v18;
      *(_OWORD *)(v17 + 16) = v27;
      *(_OWORD *)(v17 + 32) = v26;
      v28 = *(_OWORD *)(v18 + 96);
      v30 = *(_OWORD *)(v18 + 48);
      v29 = *(_OWORD *)(v18 + 64);
      *(_OWORD *)(v17 + 80) = *(_OWORD *)(v18 + 80);
      *(_OWORD *)(v17 + 96) = v28;
      *(_OWORD *)(v17 + 48) = v30;
      *(_OWORD *)(v17 + 64) = v29;
      v31 = (_OWORD *)(*(_QWORD *)a1 + 112 * (v5 >> 1));
      *v31 = v33;
      v31[1] = v34;
      v31[5] = v38;
      v31[6] = v39;
      result = v35;
      v31[2] = v35;
      v31[3] = v36;
      v31[4] = v37;
      v32 = v5 > 3;
      v5 >>= 1;
    }
    while (v32);
  }
  return result;
}

uint64_t eventParseDBO(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4, char **a5, _DWORD *a6, uint64_t a7, uint64_t a8, unsigned int a9, int a10, int a11, uint64_t a12, int a13, char a14, uint64_t a15, uint64_t a16, CFMutableDictionaryRef *a17, uint64_t a18, _QWORD *a19)
{
  int *v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  uint64_t (*v28)(uint64_t, uint64_t, uint64_t, _QWORD, _QWORD, uint64_t);
  CFIndex CountOfBit;
  const __CFBitVector *v30;
  CFIndex v31;
  CFIndex v32;
  uint64_t v33;
  const __CFArray *v34;
  const __CFArray *v35;
  char *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  size_t v44;
  _QWORD *v45;
  void **v46;
  uint64_t v47;
  char *v48;
  uint64_t v49;
  uint64_t v50;
  char *v51;
  unint64_t v52;
  CFIndex v53;
  BOOL v55;
  int v56;
  _QWORD *(*v57)(_QWORD *, _QWORD *);
  unint64_t v58;
  const char *v59;
  int v60;
  CFIndex v61;
  _QWORD *(*v62)(_QWORD *, _QWORD *);
  unint64_t v63;
  uint64_t v64;
  uint64_t v65;
  CFIndex v66;
  uint64_t *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  _QWORD *(*v71)(_QWORD *, _QWORD *);
  _QWORD *v72;
  unint64_t v73;
  char *v74;
  const __CFArray *v75;
  char **v76;
  const __CFArray *v77;
  char **v78;
  double v79;
  double v80;
  uint64_t v81;
  int *v82;
  double v83;
  int *v84;
  double v85;
  const char *v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  int v90;
  int v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  size_t v96;
  _QWORD *(*v97)(_QWORD *, _QWORD *);
  CFIndex v98;
  _QWORD *v99;
  _QWORD *(*v100)(_QWORD *, _QWORD *);
  uint64_t v101;
  uint64_t v102;
  size_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  char **v108;
  uint64_t v109;
  size_t v110;
  uint64_t v111;
  CFIndex v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t i;
  unint64_t v117;
  unsigned int v118;
  _QWORD *matched;
  size_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t (*v124)(uint64_t, uint64_t, _QWORD, _QWORD, CFIndex, uint64_t);
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  unint64_t v128;
  uint64_t v129;
  uint64_t v130;
  unint64_t v131;
  size_t *v132;
  uint64_t v133;
  _QWORD *v134;
  _QWORD *v135;
  uint64_t v136;
  void (*v137)(uint64_t, _QWORD, uint64_t, uint64_t, _QWORD *, CFIndex, _QWORD, _DWORD *, uint64_t, uint64_t);
  unint64_t v138;
  uint64_t v139;
  uint64_t v140;
  char *v141;
  const __CFArray *v142;
  int *v144;
  uint64_t v145;
  void **v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  char *v150;
  const char *v151;
  char *v152;
  char *v153;
  const char *v154;
  uint64_t v155;
  char *v156;
  const char *v157;
  uint64_t v158;
  char *v159;
  const char *v160;
  char *v161;
  const char *v162;
  char *v163;
  char *v164;
  const char *v165;
  _QWORD *v166;
  uint64_t v167;
  int v168;
  const char *v169;
  uint64_t v170;
  int v171;
  size_t *v172;
  CFMutableDictionaryRef *v173;
  uint64_t v174;
  uint64_t v175;
  size_t *v176;
  CFIndex v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  char **v182;
  _QWORD *v183;
  CFIndex *v184;
  _DWORD *v185;
  uint64_t v186;
  uint64_t v187;
  char **v188;
  uint64_t v189;
  _QWORD *v190;
  unint64_t v191;
  _QWORD *v192;
  _QWORD *v193;
  CFIndex v194;
  uint64_t v195;
  char **v196;
  int *v197;
  const __CFBitVector *v198;
  _QWORD *v199;
  CFIndex v200;
  char *v201;
  unint64_t v202;
  _QWORD v203[7];
  _QWORD v204[7];
  int *v205[8];
  _QWORD v206[5];
  CFIndex v207[3];
  _QWORD v208[2];
  int v209;
  char v210;
  size_t v211;
  uint64_t v212;
  uint64_t (*v213)(uint64_t, const void *);
  void *v214;
  uint64_t v215;
  uint64_t v216;
  char v217;
  CFIndex v218[3];
  CFRange v219;

  v180 = a8;
  v187 = a7;
  v218[1] = *MEMORY[0x1E0C80C00];
  v209 = a13;
  v210 = a14;
  v208[0] = a15;
  v208[1] = a16;
  v186 = a1;
  v24 = *(int **)(a1 + 1184);
  v25 = (*(uint64_t (**)(_DWORD *))(*(_QWORD *)a6 + 32))(a6);
  if (!v25)
  {
    v159 = __si_assert_copy_extra_268();
    v153 = v159;
    v160 = "";
    if (v159)
      v160 = v159;
    __message_assert("%s:%u: failed assertion '%s' %s ", "SISearchCtx_METADATA.cpp", 6283, "oid", v160);
LABEL_153:
    free(v153);
    if (__valid_fs(-1))
LABEL_154:
      v155 = 2989;
    else
      v155 = 3072;
    *(_DWORD *)v155 = -559038737;
    abort();
  }
  v26 = v25;
  v196 = a5;
  v197 = v24;
  v27 = a6[2];
  v28 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, _QWORD, uint64_t))(a2 + 16);
  v181 = a3;
  CountOfBit = v28(a2, 2, v25, 0, 0, a3);
  v200 = CountOfBit;
  v30 = 0;
  v31 = a4[29];
  v184 = a4 + 29;
  v202 = v31;
  if ((v27 & 8) == 0)
  {
    v30 = (const __CFBitVector *)a4[31];
    if (v30)
    {
      v219.location = 0;
      v219.length = v31;
      CountOfBit = CFBitVectorGetCountOfBit((CFBitVectorRef)a4[31], v219, 1u);
      v202 = CountOfBit;
    }
    else
    {
      v202 = v31;
    }
  }
  v199 = 0;
  if (v197 && v31)
  {
    CountOfBit = (*(uint64_t (**)(_DWORD *))(*(_QWORD *)a6 + 16))(a6);
    v199 = (_QWORD *)CountOfBit;
  }
  v185 = a6;
  v32 = *v184;
  v198 = v30;
  if (v32 && !a4[28])
  {
    if (*(_BYTE *)a4)
    {
      v33 = a4[13];
      if (v33)
      {
LABEL_20:
        PartialQueryResults::setupFixedFunctionVector((uint64_t)a4, v33, a4 + 28);
        v30 = v198;
        goto LABEL_21;
      }
      v34 = (const __CFArray *)a4[16];
      if (v34)
      {
        v211 = 0;
        SIFlattenArrayToCStringVector(v34, (char **)a4 + 13, &v211, v207);
        v33 = a4[13];
        goto LABEL_20;
      }
    }
    else
    {
      v33 = a4[12];
      if (v33)
        goto LABEL_20;
      v35 = (const __CFArray *)a4[15];
      if (v35)
      {
        SIFlattenArrayToCStringVector(v35, (char **)a4 + 12, a4 + 30, v184);
        v33 = a4[12];
        if (!v33)
        {
LABEL_18:
          v36 = __si_assert_copy_extra_268();
          __message_assert_272((uint64_t)v36, v37, v38, v39, v40, v41, v42, v43, (char)"SISearchCtx.h");
          goto LABEL_158;
        }
        goto LABEL_20;
      }
    }
    v33 = 0;
    goto LABEL_20;
  }
LABEL_21:
  v195 = a4[28];
  MEMORY[0x1E0C80A78](CountOfBit);
  v201 = (char *)&v166 - ((v44 + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v201, v44);
  v193 = a4;
  v45 = v199;
  v189 = v26;
  if (v199)
  {
    if (*v184)
    {
      v46 = (void **)(a4 + 18);
      if (a4[18])
      {
        v47 = 18;
        if ((v27 & 8) == 0)
          v47 = 20;
        v48 = (char *)a4[v47];
      }
      else
      {
        v144 = v197;
        v145 = PartialQueryResults::attributeIdVector(a4, v197);
        PartialQueryResults::setupFieldIdVector((uint64_t)a4, v145, a4 + 19, (void **)a4 + 18, 0);
        v146 = (void **)(a4 + 20);
        PartialQueryResults::setupFieldIdVector((uint64_t)a4, v145, a4 + 21, (void **)a4 + 20, 1);
        v147 = 18;
        if ((v27 & 8) == 0)
          v147 = 20;
        v48 = (char *)a4[v147];
        if (a4[29])
        {
          v26 = v189;
          a4 = v193;
          if (!*v46)
          {
            v148 = PartialQueryResults::attributeIdVector(v193, v144);
            PartialQueryResults::setupFieldIdVector((uint64_t)a4, v148, a4 + 19, v46, 0);
            v149 = v148;
            v26 = v189;
            PartialQueryResults::setupFieldIdVector((uint64_t)a4, v149, a4 + 21, v146, 1);
          }
        }
        else
        {
          a4 = v193;
          v26 = v189;
        }
      }
      v30 = v198;
    }
    else
    {
      v49 = 18;
      if ((v27 & 8) == 0)
        v49 = 20;
      v48 = (char *)a4[v49];
    }
    v50 = 19;
    if ((v27 & 8) == 0)
      v50 = 21;
    v51 = v48;
    v45 = v199;
    db_get_offsets_for_fields((char *)v197, (uint64_t)v199, v51, a4[v50], (uint64_t)v201);
    if (*v45)
    {
      if (*v45 != v26)
      {
        v161 = __si_assert_copy_extra_268();
        v153 = v161;
        v162 = "";
        if (v161)
          v162 = v161;
        __message_assert("%s:%u: failed assertion '%s' %s ", "SISearchCtx_METADATA.cpp", 6316, "!dbo || !dbo->oid || dbo->oid == oid", v162);
        goto LABEL_153;
      }
    }
  }
  v207[1] = 0;
  v207[2] = 0;
  v207[0] = (CFIndex)v45;
  if (v31)
  {
    v52 = 0;
    v53 = 0;
    v174 = a18;
    v171 = a11;
    v167 = a11;
    v179 = a9;
    v170 = v27 & 1;
    v169 = (char *)v208 + 4;
    v166 = a19;
    if (a18)
      v55 = a19 == 0;
    else
      v55 = 1;
    v56 = v55;
    v168 = v56;
    v192 = a4 + 25;
    v188 = (char **)(a4 + 13);
    v178 = a12;
    v172 = a4 + 1;
    v182 = (char **)(a4 + 12);
    v183 = a4 + 24;
    v176 = a4 + 30;
    v57 = __eventParseDBO_block_invoke_2;
    v194 = v31;
    do
    {
      if (v30)
      {
        if (!CFBitVectorGetBitAtIndex(v30, v53))
        {
          v58 = v52;
          goto LABEL_136;
        }
      }
      else
      {
        if (v52 != v53)
        {
          v152 = __si_assert_copy_extra_268();
          v153 = v152;
          v154 = "";
          if (v152)
            v154 = v152;
          __message_assert("%s:%u: failed assertion '%s' %s ", "SISearchCtx_METADATA.cpp", 6324, "dbfIndex == j", v154);
          goto LABEL_153;
        }
        if (v202 != v31)
        {
          v156 = __si_assert_copy_extra_268();
          v36 = v156;
          v157 = "";
          if (v156)
            v157 = v156;
          __message_assert("%s:%u: failed assertion '%s' %s ", "SISearchCtx_METADATA.cpp", 6325, "packCount == attributeCount", v157);
LABEL_158:
          free(v36);
          if (__valid_fs(-1))
            v158 = 2989;
          else
            v158 = 3072;
          *(_DWORD *)v158 = -559038737;
          abort();
        }
      }
      if (v52 >= v202)
      {
        v150 = __si_assert_copy_extra_268();
        v36 = v150;
        v151 = "";
        if (v150)
          v151 = v150;
        __message_assert("%s:%u: failed assertion '%s' %s ", "SISearchCtx_METADATA.cpp", 6331, "dbfIndex < packCount", v151);
        goto LABEL_158;
      }
      v58 = v52 + 1;
      v59 = *(const char **)&v201[8 * v52];
      if (v59)
      {
        v60 = *(unsigned __int16 *)v59;
        if ((v60 - 1) <= 0xF)
        {
          v61 = v200;
          v62 = v57;
          v63 = v58;
          v64 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, CFIndex, CFIndex))(a2 + 16))(a2, 4, 0, 0, v53, v200);
          eventParseField(v59, v60, a2, v64, v197, v196, a17, v53);
          v65 = v64;
          v66 = v61;
          a4 = v193;
          v31 = v194;
          (*(void (**)(uint64_t, uint64_t, uint64_t, _QWORD, CFIndex, CFIndex))(a2 + 16))(a2, 5, v65, 0, v53, v66);
          v58 = v63;
          v57 = v62;
        }
        v30 = v198;
        goto LABEL_136;
      }
      v67 = v199;
      if (v199 && *(_DWORD *)(v195 + 4 * v53))
      {
        v191 = v58;
        v68 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, CFIndex, CFIndex))(a2 + 16))(a2, 4, 0, 0, v53, v200);
        v69 = v68;
        switch(*(_DWORD *)(v195 + 4 * v53))
        {
          case 1:
            dateScaled(v67, v197, (uint64_t)a4);
            v80 = v79 * v79;
            goto LABEL_73;
          case 2:
          case 5:
            (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD, CFIndex, uint64_t))(a2 + 16))(a2, 24, *(_QWORD *)v178, *(_QWORD *)(v178 + 8), v53, v68);
            goto LABEL_106;
          case 3:
            if (v171)
            {
              (*(void (**)(uint64_t, uint64_t, uint64_t, _QWORD, CFIndex, uint64_t))(a2 + 16))(a2, 20, v167, 0, v53, v68);
              goto LABEL_106;
            }
            if (!v179)
              goto LABEL_121;
            v136 = 0;
            break;
          case 4:
            v173 = a17;
            v81 = v68;
            v82 = v197;
            PartialQueryResults::messageAttrIds((uint64_t)v205, (uint64_t)a4, v197);
            v83 = si_fancyMailRelevance((uint64_t)v67, v205);
            v84 = v82;
            v69 = v81;
            a17 = v173;
            dateScaled(v67, v84, (uint64_t)a4);
            v80 = v83 + v85 * 0.05 * 0.000244140625;
LABEL_73:
            (*(void (**)(uint64_t, uint64_t, double, _QWORD, CFIndex, uint64_t))(a2 + 16))(a2, 27, COERCE_DOUBLE(*(_QWORD *)&v80), 0, v53, v69);
            goto LABEL_106;
          case 6:
            v86 = (const char *)&v209;
            v87 = a2;
            v88 = v69;
            v89 = v53;
            v90 = 2;
            v91 = 5;
            goto LABEL_94;
          case 7:
            (*(void (**)(uint64_t, uint64_t, uint64_t, _QWORD, CFIndex, uint64_t))(a2 + 16))(a2, 15, v170, 0, v53, v68);
            goto LABEL_106;
          case 8:
            (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD, CFIndex, uint64_t))(a2 + 16))(a2, 26, *(unsigned int *)(v178 + 64), 0, v53, v68);
            goto LABEL_106;
          case 9:
            if (v168)
            {
              v92 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, CFIndex, uint64_t))(a2 + 16))(a2, 6, 0, 0, v53, v68);
              goto LABEL_105;
            }
            v173 = a17;
            matched = TokenMatchNew((const __CFAllocator *)kCIQueryZoneAllocator);
            v120 = MEMORY[0x1E0C809B0];
            v206[0] = MEMORY[0x1E0C809B0];
            v206[1] = 0x40000000;
            v206[2] = __eventParseDBO_block_invoke;
            v206[3] = &__block_descriptor_tmp_46_4219;
            v206[4] = matched;
            v121 = v69;
            v122 = v174;
            v123 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v174 + 56))(v174);
            v211 = v120;
            v212 = 0x40000000;
            v213 = ___ZL31enumerate_matching_query_piecesP11SISearchCtxP14datastore_infoP6db_objPPKcbP10query_nodeU13block_pointerFvP11query_piecePK15db_obj_eval_ctxE_block_invoke;
            v214 = &__block_descriptor_tmp_160;
            v215 = v122;
            v216 = (uint64_t)v67;
            v217 = 0;
            db_query_enumerate_matched_qps_for_dbo((uint64_t)v197, v166, (uint64_t)v67, (uint64_t)v196, v123, (uint64_t)&v211, (uint64_t)v206);
            TokenMatchConvertToSnippetHints((uint64_t)matched);
            v124 = *(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, CFIndex, uint64_t))(a2 + 16);
            v175 = v121;
            v125 = v124(a2, 6, 0, 0, v53, v121);
            v126 = matched[2];
            if (matched[3] != v126)
            {
              v127 = 0;
              v128 = 0;
              v177 = v53;
              do
              {
                (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, uint64_t))(a2 + 16))(a2, 29, *(_QWORD *)(v126 + 56 * v128 + 8), *(_QWORD *)(v126 + 56 * v128 + 16), v127++, v125);
                v126 = matched[2];
                v129 = *(_QWORD *)(v126 + 56 * v128 + 24);
                if (*(_QWORD *)(v126 + 56 * v128 + 32) != v129)
                {
                  v130 = 0;
                  v131 = 0;
                  do
                  {
                    (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD, unint64_t, uint64_t))(a2 + 16))(a2, 29, *(_QWORD *)(v129 + v130), *(_QWORD *)(v129 + v130 + 8), v127 + v131++, v125);
                    v126 = matched[2];
                    v129 = *(_QWORD *)(v126 + 56 * v128 + 24);
                    v130 += 24;
                  }
                  while (v131 < 0xAAAAAAAAAAAAAAABLL * ((*(_QWORD *)(v126 + 56 * v128 + 32) - v129) >> 3));
                  v127 += v131;
                  v31 = v194;
                  v53 = v177;
                  v57 = __eventParseDBO_block_invoke_2;
                }
                ++v128;
              }
              while (v128 < 0x6DB6DB6DB6DB6DB7 * ((matched[3] - v126) >> 3));
            }
            v69 = v175;
            (*(void (**)(uint64_t, uint64_t, uint64_t, _QWORD, CFIndex, uint64_t))(a2 + 16))(a2, 7, v125, 0, v53, v175);
            TokenMatchFree(matched);
            a4 = v193;
            v30 = v198;
            a17 = v173;
            goto LABEL_106;
          case 0xA:
            v175 = v68;
            v93 = v174;
            if (!v174)
              goto LABEL_104;
            v173 = a17;
            v218[0] = 0;
            v94 = (*(uint64_t (**)(uint64_t, CFIndex *))(*(_QWORD *)v174 + 72))(v174, v218);
            v95 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, CFIndex, uint64_t))(a2 + 16))(a2, 6, 0, 0, v53, v175);
            v96 = MEMORY[0x1E0C809B0];
            v97 = v57;
            if (v218[0] >= 1)
            {
              v98 = 0;
              do
              {
                v99 = *(_QWORD **)(v94 + 8 * v98);
                v204[0] = v96;
                v204[1] = 0x40000000;
                v204[2] = v97;
                v204[3] = &unk_1E6E2FE50;
                v204[4] = a2;
                v204[5] = v53;
                v204[6] = v95;
                v100 = v97;
                v101 = v95;
                v102 = a2;
                v103 = v96;
                v104 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v93 + 56))(v93);
                v211 = v103;
                v212 = 0x40000000;
                v213 = ___ZL31enumerate_matching_query_piecesP11SISearchCtxP14datastore_infoP6db_objPPKcbP10query_nodeU13block_pointerFvP11query_piecePK15db_obj_eval_ctxE_block_invoke;
                v214 = &__block_descriptor_tmp_160;
                v215 = v93;
                v216 = (uint64_t)v199;
                v217 = 0;
                db_query_enumerate_matched_qps_for_dbo((uint64_t)v197, v99, (uint64_t)v199, (uint64_t)v196, v104, (uint64_t)&v211, (uint64_t)v204);
                v96 = v103;
                a2 = v102;
                v95 = v101;
                v97 = v100;
                ++v98;
              }
              while (v98 < v218[0]);
            }
            v69 = v175;
            (*(void (**)(uint64_t, uint64_t, uint64_t, _QWORD, CFIndex, uint64_t))(a2 + 16))(a2, 7, v95, 0, v53, v175);
            a4 = v193;
            v31 = v194;
            v30 = v198;
            a17 = v173;
            v57 = v97;
            goto LABEL_106;
          case 0xB:
            v175 = v68;
            v105 = v174;
            if (v174)
            {
              v173 = a17;
              v218[0] = 0;
              v106 = (*(uint64_t (**)(uint64_t, CFIndex *))(*(_QWORD *)v174 + 80))(v174, v218);
              v107 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, CFIndex, uint64_t))(a2 + 16))(a2, 6, 0, 0, v53, v175);
              v108 = v196;
              v109 = v105;
              v110 = MEMORY[0x1E0C809B0];
              v111 = a2;
              if (v218[0] >= 1)
              {
                v112 = 0;
                do
                {
                  v190 = *(_QWORD **)(v106 + 8 * v112);
                  v203[0] = v110;
                  v203[1] = 0x40000000;
                  v203[2] = __eventParseDBO_block_invoke_3;
                  v203[3] = &unk_1E6E2FEA0;
                  v203[4] = v111;
                  v203[5] = v53;
                  v203[6] = v107;
                  v113 = v109;
                  v114 = v107;
                  v115 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v109 + 56))(v109);
                  v211 = v110;
                  v212 = 0x40000000;
                  v213 = ___ZL31enumerate_matching_query_piecesP11SISearchCtxP14datastore_infoP6db_objPPKcbP10query_nodeU13block_pointerFvP11query_piecePK15db_obj_eval_ctxE_block_invoke;
                  v214 = &__block_descriptor_tmp_160;
                  v215 = v113;
                  v216 = (uint64_t)v199;
                  v217 = 1;
                  db_query_enumerate_matched_qps_for_dbo((uint64_t)v197, v190, (uint64_t)v199, (uint64_t)v108, v115, (uint64_t)&v211, (uint64_t)v203);
                  v109 = v113;
                  v107 = v114;
                  ++v112;
                }
                while (v112 < v218[0]);
              }
              a2 = v111;
              v69 = v175;
              (*(void (**)(uint64_t, uint64_t, uint64_t, _QWORD, CFIndex, uint64_t))(v111 + 16))(v111, 7, v107, 0, v53, v175);
              a4 = v193;
              v31 = v194;
              v30 = v198;
              a17 = v173;
              v57 = __eventParseDBO_block_invoke_2;
            }
            else
            {
LABEL_104:
              v69 = v175;
              v92 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, CFIndex, uint64_t))(a2 + 16))(a2, 6, 0, 0, v53, v175);
LABEL_105:
              (*(void (**)(uint64_t, uint64_t, uint64_t, _QWORD, CFIndex, uint64_t))(a2 + 16))(a2, 7, v92, 0, v53, v69);
            }
            goto LABEL_106;
          case 0xC:
            for (i = 0; i != 3; ++i)
            {
              if (!*((_BYTE *)v208 + i))
                *((_DWORD *)v208 + i + 1) = 2139095039;
            }
            v87 = a2;
            v88 = v69;
            v89 = v53;
            v90 = 9;
            v86 = v169;
            v91 = 3;
LABEL_94:
            addScalarArray(v87, v88, v89, v90, 0, v86, v91);
            goto LABEL_106;
          case 0xD:
            v117 = 0;
            v118 = 0;
            do
            {
              if (*((_BYTE *)v208 + v117))
                v118 |= 2u;
              if (v117 > 1)
                break;
              ++v117;
            }
            while ((v118 & 2) == 0);
            if (!v118 || *(float *)(v178 + 64) > 0.0)
              v118 |= 1u;
            (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD, CFIndex, uint64_t))(a2 + 16))(a2, 20, v118, 0, v53, v68);
            goto LABEL_106;
          default:
            v163 = __si_assert_copy_extra_268();
            v164 = v163;
            if (v163)
              v165 = v163;
            else
              v165 = "";
            __message_assert("%s:%u: Unexpected code path %s ", "SISearchCtx_METADATA.cpp", 6349, v165);
            free(v164);
            goto LABEL_154;
        }
        while (!grouping_db_eval_obj_with_options((uint64_t)v197))
        {
          if (v179 == ++v136)
          {
LABEL_121:
            (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD, CFIndex, uint64_t))(a2 + 16))(a2, 20, 0, 0, v53, v69);
            goto LABEL_106;
          }
        }
        (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD, CFIndex, uint64_t))(a2 + 16))(a2, 20, (v136 + 1), 0, v53, v69);
LABEL_106:
        (*(void (**)(uint64_t, uint64_t, uint64_t, _QWORD, CFIndex, CFIndex))(a2 + 16))(a2, 5, v69, 0, v53, v200);
        v58 = v191;
        goto LABEL_136;
      }
      v70 = a4[29];
      v71 = v57;
      if (*(_BYTE *)a4)
      {
        v72 = v192;
        if (!v70)
          goto LABEL_125;
        v72 = v192;
        if (*v192)
          goto LABEL_125;
        v73 = v58;
        v74 = *v188;
        if (!*v188)
        {
          v75 = (const __CFArray *)a4[16];
          if (v75)
          {
            v211 = 0;
            v76 = v188;
            SIFlattenArrayToCStringVector(v75, v188, &v211, v218);
            v74 = *v76;
          }
          else
          {
            v74 = 0;
          }
        }
        v132 = &v211;
        v133 = (uint64_t)a4;
        v134 = v192;
        v135 = v192;
      }
      else
      {
        v72 = v183;
        if (!v70)
          goto LABEL_125;
        v72 = v183;
        if (*v183)
          goto LABEL_125;
        v73 = v58;
        v74 = *v182;
        if (!*v182)
        {
          v77 = (const __CFArray *)a4[15];
          if (v77)
          {
            v78 = v182;
            SIFlattenArrayToCStringVector(v77, v182, v176, v184);
            v74 = *v78;
            if (!*v78)
              goto LABEL_18;
          }
          else
          {
            v74 = 0;
          }
        }
        v133 = (uint64_t)a4;
        v134 = v183;
        v135 = v183;
        v132 = v172;
      }
      PartialQueryResults::setupCannedAttributeVector(v133, (uint64_t)v74, v135, v132);
      v72 = v134;
      v58 = v73;
LABEL_125:
      v137 = *(void (**)(uint64_t, _QWORD, uint64_t, uint64_t, _QWORD *, CFIndex, _QWORD, _DWORD *, uint64_t, uint64_t))(*v72 + 8 * v53);
      if (v137)
      {
        v138 = v58;
        v139 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, CFIndex, CFIndex))(a2 + 16))(a2, 4, 0, 0, v53, v200);
        v140 = a4[29];
        if (*(_BYTE *)a4)
        {
          v141 = *v188;
          if (v140 && !v141)
          {
            v142 = (const __CFArray *)a4[16];
            v211 = 0;
            SIFlattenArrayToCStringVector(v142, v188, &v211, v218);
            v141 = (char *)a4[13];
          }
        }
        else
        {
          v141 = *v182;
          if (v140)
          {
            if (!v141)
            {
              SIFlattenArrayToCStringVector((const __CFArray *)a4[15], v182, v176, v184);
              v141 = (char *)a4[12];
              if (!v141)
                goto LABEL_18;
            }
          }
        }
        v137(v186, *(_QWORD *)&v141[8 * v53], v187, v189, v199, v53, 0, v185, a2, v139);
        (*(void (**)(uint64_t, uint64_t, uint64_t, _QWORD, CFIndex, CFIndex))(a2 + 16))(a2, 5, v139, 0, v53, v200);
        v30 = v198;
        v58 = v138;
      }
      else
      {
        v30 = v198;
      }
      v57 = v71;
LABEL_136:
      ++v53;
      v52 = v58;
    }
    while (v53 != v31);
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, CFIndex, _QWORD, _QWORD, uint64_t))(a2 + 16))(a2, 3, v200, 0, 0, v181);
}

void __writeDBOToPlistBytes_block_invoke(uint64_t a1, uint64_t a2)
{
  TokenMatchTrack(*(_QWORD *)(a1 + 32), *(char **)a2, *(const char **)(a2 + 72), (*(_QWORD *)(a2 + 32) & 0x80000000) != 0, (*(_QWORD *)(a2 + 32) & 0x40000000) != 0, (*(_QWORD *)(a2 + 32) & 0x20000000) != 0);
}

uint64_t ___ZL31enumerate_matching_query_piecesP11SISearchCtxP14datastore_infoP6db_objPPKcbP10query_nodeU13block_pointerFvP11query_piecePK15db_obj_eval_ctxE_block_invoke(uint64_t a1, const void *a2)
{
  const void *Value;
  uint64_t result;

  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(*(_QWORD *)(a1 + 32) + 216), a2);
  result = ContentIndexDocSetContainsDocId((uint64_t)Value, *(_QWORD *)(*(_QWORD *)(a1 + 40) + 32));
  if ((_DWORD)result)
  {
    if (*(_BYTE *)(a1 + 48)
      || ContentIndexDocSetNeedsPostcheckForDocId((uint64_t)Value, *(_QWORD *)(*(_QWORD *)(a1 + 40) + 32)))
    {
      return 2;
    }
    else
    {
      return 1;
    }
  }
  return result;
}

_DWORD *dateScaled(uint64_t *a1, int *a2, uint64_t a3)
{
  _DWORD *result;
  int v6;
  NSObject *v7;
  os_log_type_t v8;
  uint64_t v9;
  double v10;
  double v11;
  NSObject *v12;
  os_log_type_t v13;
  uint64_t v14;
  const char *v15;
  uint64_t v16;
  uint64_t v17;
  double *v18;
  unint64_t v19;
  uint8_t buf[4];
  uint64_t v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  v18 = 0;
  v19 = 0;
  result = (_DWORD *)db_get_field_by_id(a2, (uint64_t)a1, *(int **)(a3 + 272), &v19, (unint64_t *)&v18);
  if ((_DWORD)result)
  {
    v6 = *__error();
    v7 = _SILogForLogForCategory(1);
    v8 = 2 * (dword_1EF19FC90 < 4);
    if (os_log_type_enabled(v7, v8))
    {
      v9 = *a1;
      *(_DWORD *)buf = 134217984;
      v21 = v9;
LABEL_11:
      _os_log_impl(&dword_1B8270000, v7, v8, "No last opened date for %llx", buf, 0xCu);
    }
  }
  else
  {
    if (*v18 > 0.0)
    {
      v10 = *(double *)(a3 + 304);
      if (v10 > 0.0)
      {
        v11 = *v18 / v10;
        if (v11 <= 1.0)
        {
          if (v11 >= 0.0)
            return result;
          v6 = *__error();
          v12 = _SILogForLogForCategory(1);
          v13 = 2 * (dword_1EF19FC90 < 4);
          if (!os_log_type_enabled(v12, v13))
            goto LABEL_17;
          v17 = *a1;
          *(_DWORD *)buf = 134217984;
          v21 = v17;
          v15 = "Clipping at 0.0 for %llx";
        }
        else
        {
          v6 = *__error();
          v12 = _SILogForLogForCategory(1);
          v13 = 2 * (dword_1EF19FC90 < 4);
          if (!os_log_type_enabled(v12, v13))
            goto LABEL_17;
          v14 = *a1;
          *(_DWORD *)buf = 134217984;
          v21 = v14;
          v15 = "Clipping at 1.0 for %llx";
        }
        _os_log_impl(&dword_1B8270000, v12, v13, v15, buf, 0xCu);
        goto LABEL_17;
      }
    }
    v6 = *__error();
    v7 = _SILogForLogForCategory(1);
    v8 = 2 * (dword_1EF19FC90 < 4);
    if (os_log_type_enabled(v7, v8))
    {
      v16 = *a1;
      *(_DWORD *)buf = 134217984;
      v21 = v16;
      goto LABEL_11;
    }
  }
LABEL_17:
  result = __error();
  *result = v6;
  return result;
}

BOOL grouping_db_eval_obj_with_options(uint64_t a1)
{
  return db_eval_obj_with_options(a1) != 0;
}

__n128 PartialQueryResults::messageAttrIds(uint64_t a1, uint64_t a2, int *a3)
{
  uint64_t v4;
  __int128 v7;
  __n128 result;
  __int128 v9;

  v4 = a2 + 32;
  if (!*(_BYTE *)(a2 + 88))
  {
    *(_QWORD *)(a2 + 32) = db_copy_field_ids_with_buffer(a3, "kMDItemAuthorEmailAddresses", 0, 0);
    *(_QWORD *)(a2 + 40) = db_copy_field_ids_with_buffer(a3, "kMDItemAuthors", 0, 0);
    *(_QWORD *)(a2 + 48) = db_copy_field_ids_with_buffer(a3, "kMDItemRecipientEmailAddresses", 0, 0);
    *(_QWORD *)(a2 + 56) = db_copy_field_ids_with_buffer(a3, "kMDItemRecipients", 0, 0);
    *(_QWORD *)(a2 + 64) = db_copy_field_ids_with_buffer(a3, "kMDItemSubject", 0, 0);
    *(_QWORD *)(a2 + 72) = db_copy_field_ids_with_buffer(a3, "kMDItemContentCreationDate", 0, 0);
    *(_QWORD *)(a2 + 80) = db_copy_field_ids_with_buffer(a3, "kMDItemContentModificationDate", 0, 0);
    *(_BYTE *)(a2 + 88) = 1;
  }
  v7 = *(_OWORD *)(v4 + 16);
  *(_OWORD *)a1 = *(_OWORD *)v4;
  *(_OWORD *)(a1 + 16) = v7;
  result = *(__n128 *)(v4 + 32);
  v9 = *(_OWORD *)(v4 + 48);
  *(__n128 *)(a1 + 32) = result;
  *(_OWORD *)(a1 + 48) = v9;
  return result;
}

double si_fancyMailRelevance(uint64_t a1, int **a2)
{
  uint64_t v2;
  unsigned int v3;
  unint64_t v4;
  unint64_t v5;
  float v6;
  unsigned int v7;
  int v8;
  int *v9;
  int v10;
  int *v11;
  int v12;
  int *v13;
  int v14;
  int *v15;
  int v16;
  int *v17;
  int v18;
  int *v19;
  int v20;
  int *v21;
  int v22;
  int *v23;
  int v24;
  int *v25;
  int v26;
  int *v27;
  int v28;
  int *v29;
  int v30;
  int *v31;
  int v32;
  int *v33;
  int v34;
  int *v35;
  int v36;
  int v37;

  v2 = *(unsigned int *)(a1 + 12);
  if (v2 >= 0x31)
  {
    v3 = 0;
    v4 = a1 + v2;
    v5 = a1 + 48;
    v6 = 0.0;
    while (1)
    {
      v7 = *(unsigned __int8 *)(v5 + 12);
      if (!*(_BYTE *)(v5 + 12) || (*(_WORD *)(v5 + 2) & 0x100) != 0)
        goto LABEL_48;
      v8 = *(_DWORD *)(v5 + 4);
      v9 = *a2;
      if (*a2)
      {
        v10 = *v9;
        if (*v9)
          break;
      }
LABEL_10:
      v13 = a2[1];
      if (v13)
      {
        v14 = *v13;
        if (*v13)
        {
          v15 = v13 + 1;
          while (v14 != v8)
          {
            v16 = *v15++;
            v14 = v16;
            if (!v16)
              goto LABEL_15;
          }
LABEL_41:
          v3 |= 8u;
          v6 = v6 + (float)((float)((float)((float)v7 + -1.0) * 0.0625) * 0.05);
          goto LABEL_48;
        }
      }
LABEL_15:
      v17 = a2[2];
      if (v17)
      {
        v18 = *v17;
        if (*v17)
        {
          v19 = v17 + 1;
          while (v18 != v8)
          {
            v20 = *v19++;
            v18 = v20;
            if (!v20)
              goto LABEL_20;
          }
          goto LABEL_42;
        }
      }
LABEL_20:
      v21 = a2[3];
      if (v21)
      {
        v22 = *v21;
        if (*v21)
        {
          v23 = v21 + 1;
          while (v22 != v8)
          {
            v24 = *v23++;
            v22 = v24;
            if (!v24)
              goto LABEL_25;
          }
LABEL_42:
          v3 |= 4u;
          v6 = v6 + (float)((float)((float)((float)v7 + -1.0) * 0.0625) * 0.003125);
          goto LABEL_48;
        }
      }
LABEL_25:
      v25 = a2[4];
      if (v25)
      {
        v26 = *v25;
        if (*v25)
        {
          v27 = v25 + 1;
          while (v26 != v8)
          {
            v28 = *v27++;
            v26 = v28;
            if (!v28)
              goto LABEL_30;
          }
          if (v7 <= 1)
            v37 = 2;
          else
            v37 = 6;
          v3 |= v37;
          v6 = v6 + (float)((float)((float)((float)v7 + -1.0) * 0.0625) * 0.00019531);
          goto LABEL_48;
        }
      }
LABEL_30:
      v29 = a2[5];
      if (v29 && (v30 = *v29) != 0)
      {
        v31 = v29 + 1;
        while (v30 != v8)
        {
          v32 = *v31++;
          v30 = v32;
          if (!v32)
            goto LABEL_35;
        }
      }
      else
      {
LABEL_35:
        v33 = a2[6];
        if (!v33)
          goto LABEL_48;
        v34 = *v33;
        if (!*v33)
          goto LABEL_48;
        v35 = v33 + 1;
        while (v34 != v8)
        {
          v36 = *v35++;
          v34 = v36;
          if (!v36)
            goto LABEL_48;
        }
      }
      v3 |= 1u;
LABEL_48:
      v5 += *(unsigned int *)(v5 + 8) + 13;
      if (v5 >= v4)
        return dbl_1B8630B80[(*(_DWORD *)(a1 + 40) >> 15) & 1 | v3] + v6;
    }
    v11 = v9 + 1;
    while (v10 != v8)
    {
      v12 = *v11++;
      v10 = v12;
      if (!v12)
        goto LABEL_10;
    }
    goto LABEL_41;
  }
  v3 = 0;
  v6 = 0.0;
  return dbl_1B8630B80[(*(_DWORD *)(a1 + 40) >> 15) & 1 | v3] + v6;
}

uint64_t __writeDBOToPlistBytes_block_invoke_52(uint64_t a1, _QWORD *a2)
{
  uint64_t result;

  if (a2)
  {
    if (*a2)
      return _MDPlistBytesAddInternedCString();
  }
  return result;
}

uint64_t __writeDBOToPlistBytes_block_invoke_2(uint64_t result, uint64_t a2, uint64_t a3)
{
  _QWORD v3[5];

  if (a2)
  {
    if (*(_DWORD *)(a2 + 80) == *(_DWORD *)(result + 32))
    {
      v3[0] = MEMORY[0x1E0C809B0];
      v3[1] = 0x40000000;
      v3[2] = __writeDBOToPlistBytes_block_invoke_3;
      v3[3] = &__block_descriptor_tmp_54_4200;
      v3[4] = *(_QWORD *)(result + 40);
      return qp_array_match_indexes(a3, a2, (uint64_t)v3);
    }
  }
  return result;
}

BOOL __writeDBOToPlistBytes_block_invoke_4(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return plistBlock(a2, a3, a4, a6);
}

BOOL plistBlock(int a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _BOOL8 result;

  result = 0;
  switch(a1)
  {
    case 6:
    case 8:
    case 12:
      _MDPlistBytesBeginArray();
      return a4;
    case 7:
    case 9:
    case 13:
      _MDPlistBytesEndArray();
      goto LABEL_16;
    case 10:
      _MDPlistBytesBeginDictionary();
      return a4;
    case 11:
      _MDPlistBytesEndDictionary();
      goto LABEL_16;
    case 14:
    case 28:
    case 29:
      _MDPlistBytesAddCString();
      goto LABEL_16;
    case 15:
      _MDPlistBytesAddBoolean();
      goto LABEL_16;
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
      _MDPlistBytesAddInteger();
      goto LABEL_16;
    case 25:
      _MDPlistBytesAddDate();
      goto LABEL_16;
    case 26:
    case 27:
      _MDPlistBytesAddReal();
      goto LABEL_16;
    case 30:
      return _MDPlistBytesAddRawInternedCStringKey() != 0;
    case 31:
      _MDPlistBytesAddRawInternedCStringKeyWithString();
      goto LABEL_16;
    case 33:
      _MDPlistBytesAddData();
      goto LABEL_16;
    case 34:
      __MDPlistBytesAddObject();
LABEL_16:
      result = 0;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t __writeDBOToPlistBytes_block_invoke_3()
{
  return _MDPlistBytesAddInteger();
}

void eventParseField(const char *key, int a2, uint64_t a3, uint64_t a4, int *a5, char **a6, CFMutableDictionaryRef *a7, int a8)
{
  unint64_t v13;
  int v14;
  __int16 v15;
  uint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  void (*v21)(uint64_t, uint64_t, char *, unint64_t, uint64_t, uint64_t);
  uint64_t v22;
  uint64_t v23;
  char *v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v29;
  const char *v30;
  const char *v31;
  void (*v32)(uint64_t, uint64_t, const char *, _QWORD, uint64_t, uint64_t);
  const char *v33;
  uint64_t v34;
  uint64_t v35;
  unsigned int *v36;
  uint64_t v37;
  const char *v38;
  void **v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  char *vector_for_id_locked;
  const void *v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  uint64_t v51;
  void *v52;
  unsigned int v53;
  unsigned int v54;
  uint64_t v55;
  unsigned __int16 v56;
  char *v57;
  uint64_t v58;
  int v59;
  int v60;
  char *v61;
  char *v62;
  const char *v63;
  uint64_t v64;
  uint64_t v65;
  unsigned int v66;
  unint64_t v67;
  void *value[2];
  void *v69[2];
  __int128 v70;
  __int128 v71;
  __int128 v72;
  uint64_t v73;

  v73 = *MEMORY[0x1E0C80C00];
  v13 = *((unsigned int *)key + 2);
  v14 = *((unsigned __int16 *)key + 1);
  if (a2 != 14)
  {
    if ((v14 & 0x80) == 0)
    {
      if ((v14 & 0x20) != 0)
      {
        if (a2 == 11)
        {
          if ((v14 & 0x8000) != 0 && (_DWORD)v13 != 4)
          {
            v61 = __si_assert_copy_extra_268();
            v62 = v61;
            v63 = "";
            if (v61)
              v63 = v61;
            __message_assert("%s:%u: failed assertion '%s' %s ", "SISearchCtx_METADATA.cpp", 6242, "field->data_len==sizeof(uint32_t)", v63);
            free(v62);
            if (__valid_fs(-1))
              v64 = 2989;
            else
              v64 = 3072;
            *(_DWORD *)v64 = -559038737;
            abort();
          }
          v35 = a8;
          v36 = (unsigned int *)(key + 13);
          v67 = (unint64_t)(key + 13);
          if ((~v14 & 0x8010) != 0)
          {
            v48 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, uint64_t))(a3 + 16))(a3, 6, 0, 0, a8, a4);
            if ((_DWORD)v13)
            {
              v49 = 0;
              v50 = (unint64_t)v36 + v13;
              do
              {
                v51 = v49 + 1;
                addString(a3, v48, v49, a5, v14, (const char **)&v67);
                v49 = v51;
              }
              while (v67 < v50);
            }
            (*(void (**)(uint64_t, uint64_t, uint64_t, _QWORD, uint64_t, uint64_t))(a3 + 16))(a3, 7, v48, 0, v35, a4);
          }
          else
          {
            v37 = *v36;
            if (!(*(uint64_t (**)(uint64_t, uint64_t, _QWORD, uint64_t, _QWORD, uint64_t))(a3 + 16))(a3, 32, 0, v37, a8, a4))
            {
              v71 = 0u;
              v72 = 0u;
              *(_OWORD *)v69 = 0u;
              v70 = 0u;
              v66 = 64;
              v38 = (const char *)copyDataForUniquedValue((uint64_t)a5, v37, v69, &v66);
              v67 = (unint64_t)v38;
              if (v38)
              {
                v39 = (void **)v38;
                v40 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, uint64_t))(a3 + 16))(a3, 8, 0, 0, (int)v35, a4);
                if (v66)
                {
                  v41 = 0;
                  v42 = (unint64_t)v39 + v66;
                  do
                  {
                    v43 = v41 + 1;
                    addString(a3, v40, v41, a5, v14, (const char **)&v67);
                    v41 = v43;
                  }
                  while (v67 < v42);
                }
                (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, uint64_t))(a3 + 16))(a3, 9, v40, v37, (int)v35, a4);
                if (v39 != v69)
                  free(v39);
              }
              else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
              {
                LODWORD(value[0]) = 67109120;
                HIDWORD(value[0]) = v37;
                _os_log_fault_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "No data for uniqued array %u", (uint8_t *)value, 8u);
              }
            }
          }
        }
        else
        {
          addScalarArray(a3, a4, a8, a2, v14, key + 13, v13 / kSDBTypeSizes[a2]);
        }
      }
      else
      {
        addValue(a3, a4, a8, a5, a2, v14, key + 13);
      }
      return;
    }
    v29 = a8;
    v69[0] = (void *)(key + 13);
    v67 = 0;
    if (a7 && (v14 & 0x10) != 0 && (v30 = (const char *)CFDictionaryGetValue(*a7, key)) != 0)
    {
      v31 = v30;
      value[0] = 0;
      if (CFDictionaryGetValueIfPresent(a7[1], key, (const void **)value))
      {
        (*(void (**)(uint64_t, uint64_t, const char *, void *, uint64_t, uint64_t))(a3 + 16))(a3, 29, v31, value[0], v29, a4);
        return;
      }
      v32 = *(void (**)(uint64_t, uint64_t, const char *, _QWORD, uint64_t, uint64_t))(a3 + 16);
      v34 = a3;
      v33 = v31;
    }
    else
    {
      if (db_get_localized_string(a5, (uint64_t)key, a6, (uint64_t)v69, (uint64_t)&v67, 1))
      {
        v32 = *(void (**)(uint64_t, uint64_t, const char *, _QWORD, uint64_t, uint64_t))(a3 + 16);
        v33 = "";
      }
      else
      {
        if ((*((_WORD *)key + 1) & 0x10) != 0)
        {
          v45 = (const void *)(v67 - (unint64_t)v69[0]);
          if (v67)
            v46 = 29;
          else
            v46 = 28;
          (*(void (**)(uint64_t, uint64_t))(a3 + 16))(a3, v46);
          if (a7)
          {
            v52 = malloc_type_zone_malloc((malloc_zone_t *)queryZone, *((unsigned int *)key + 2) + 13, 0x6085D6BuLL);
            if (!v52)
              _log_fault_for_malloc_failure();
            memcpy(v52, key, *((unsigned int *)key + 2) + 13);
            CFDictionarySetValue(*a7, v52, v69[0]);
            if (v67)
              CFDictionarySetValue(a7[1], v52, v45);
          }
          return;
        }
        v33 = (const char *)v69[0];
        if (v67)
        {
          (*(void (**)(uint64_t, uint64_t, void *, unint64_t, uint64_t, uint64_t))(a3 + 16))(a3, 29, v69[0], v67 - (unint64_t)v69[0], v29, a4);
          return;
        }
        v32 = *(void (**)(uint64_t, uint64_t, const char *, _QWORD, uint64_t, uint64_t))(a3 + 16);
      }
      v34 = a3;
    }
    v32(v34, 28, v33, 0, v29, a4);
    return;
  }
  if ((~v14 & 0x5020) != 0 || !_os_feature_enabled_impl())
  {
    v21 = *(void (**)(uint64_t, uint64_t, char *, unint64_t, uint64_t, uint64_t))(a3 + 16);
    v24 = (char *)(key + 13);
    v26 = a8;
    v22 = a3;
    v23 = 33;
    v25 = v13;
LABEL_16:
    v21(v22, v23, v24, v25, v26, a4);
    return;
  }
  v15 = *((_WORD *)key + 1);
  if ((v15 & 8) != 0)
  {
    LODWORD(v69[0]) = 0;
    LODWORD(v67) = 0;
    if ((v15 & 0x10) != 0)
    {
      if ((_DWORD)v13 == 4)
      {
        v47 = *(unsigned int *)(key + 13);
      }
      else
      {
        if ((_DWORD)v13 != 8)
          return;
        v47 = *(_QWORD *)(key + 13);
      }
      vector_for_id_locked = (char *)db_get_vector_for_id_locked((uint64_t)a5, v47, v69, &v67);
    }
    else
    {
      vector_for_id_locked = (char *)(key + 15);
      LOWORD(v67) = *(_WORD *)(key + 13);
      LODWORD(v69[0]) = *((_DWORD *)key + 2) - 2;
    }
    if (vector_for_id_locked)
    {
      if (LODWORD(v69[0]) >= 3)
      {
        v53 = v67;
        if (v67 <= 2uLL)
        {
          v54 = BYTE1(v67);
          if (BYTE1(v67) <= 2u)
          {
            v55 = (vector_dimension_vec_sizes_10743[BYTE1(v67)]
                               * vector_size_elem_sizes_10742[v67]);
            if (v55 <= v13)
            {
              v56 = WORD1(v67);
              if ((*((_WORD *)key + 1) & 0x20) != 0)
              {
                v57 = &vector_for_id_locked[v13];
                v65 = a8;
                v58 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD))(a3 + 16))(a3, 6, 0, 0);
                v59 = 0;
                do
                {
                  v60 = v59 + 1;
                  emitVector(a3, v58, v54, v53, v56, (uint64_t)vector_for_id_locked, v55, v59);
                  vector_for_id_locked += v55;
                  v59 = v60;
                }
                while (&vector_for_id_locked[v55] <= v57);
                (*(void (**)(uint64_t, uint64_t, uint64_t, _QWORD, uint64_t, uint64_t))(a3 + 16))(a3, 7, v58, 0, v65, a4);
              }
              else
              {
                emitVector(a3, a4, BYTE1(v67), v67, WORD1(v67), (uint64_t)vector_for_id_locked, (vector_dimension_vec_sizes_10743[BYTE1(v67)]* vector_size_elem_sizes_10742[v67]), a8);
              }
            }
          }
        }
      }
    }
  }
  else if ((v15 & 0x10) != 0)
  {
    v16 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, uint64_t))(a3 + 16))(a3, 6, 0, 0, a8, a4);
    if (v13 >= 8)
    {
      v17 = (unint64_t *)(key + 13);
      v18 = v13 >> 3;
      do
      {
        v19 = *v17++;
        LODWORD(v69[0]) = 0;
        LODWORD(v67) = 0;
        v20 = db_get_vector_for_id_locked((uint64_t)a5, v19, v69, &v67);
        if (v20)
          emitVector(a3, a4, BYTE1(v67), v67, WORD1(v67), v20, LODWORD(v69[0]), a8);
        --v18;
      }
      while (v18);
    }
    v21 = *(void (**)(uint64_t, uint64_t, char *, unint64_t, uint64_t, uint64_t))(a3 + 16);
    v22 = a3;
    v23 = 7;
    v24 = (char *)v16;
    v25 = 0;
    v26 = a8;
    goto LABEL_16;
  }
}

void __eventParseDBO_block_invoke(uint64_t a1, uint64_t a2)
{
  TokenMatchTrack(*(_QWORD *)(a1 + 32), *(char **)a2, *(const char **)(a2 + 72), (*(_QWORD *)(a2 + 32) & 0x80000000) != 0, (*(_QWORD *)(a2 + 32) & 0x40000000) != 0, (*(_QWORD *)(a2 + 32) & 0x20000000) != 0);
}

uint64_t addScalarArray(uint64_t a1, uint64_t a2, uint64_t a3, int a4, __int16 a5, const char *a6, int a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v14 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, uint64_t))(a1 + 16))(a1, 6, 0, 0, a3, a2);
  if (a7)
  {
    v15 = 0;
    v16 = kSDBTypeSizes[a4];
    do
    {
      addValue(a1, v14, v15, 0, a4, a5, a6);
      a6 += v16;
      ++v15;
    }
    while (a7 != v15);
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, uint64_t, uint64_t))(a1 + 16))(a1, 7, v14, 0, a3, a2);
}

_QWORD *__eventParseDBO_block_invoke_2(_QWORD *result, _QWORD *a2)
{
  if (a2)
  {
    if (*a2)
      return (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD))(result[4] + 16))(result[4], 28, *a2, 0, result[5], result[6]);
  }
  return result;
}

_QWORD *__eventParseDBO_block_invoke_3(_QWORD *result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  _QWORD v4[7];

  if (a2)
  {
    v3 = result[5];
    if (*(_DWORD *)(a2 + 80) == (_DWORD)v3)
    {
      v4[0] = MEMORY[0x1E0C809B0];
      v4[1] = 0x40000000;
      v4[2] = __eventParseDBO_block_invoke_4;
      v4[3] = &unk_1E6E2FE78;
      v4[4] = result[4];
      v4[5] = v3;
      v4[6] = result[6];
      return (_QWORD *)qp_array_match_indexes(a3, a2, (uint64_t)v4);
    }
  }
  return result;
}

uint64_t __eventParseDBO_block_invoke_4(_QWORD *a1, unsigned __int16 a2)
{
  return (*(uint64_t (**)(_QWORD, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD))(a1[4] + 16))(a1[4], 21, a2, 0, a1[5], a1[6]);
}

void addValue(uint64_t a1, uint64_t a2, uint64_t a3, int *a4, int a5, __int16 a6, const char *a7)
{
  void (*v7)(void);
  char *v8;
  char *v9;
  const char *v10;
  const char *v11;

  v11 = a7;
  switch(a5)
  {
    case 1:
      if ((a6 & 0x400) != 0)
        goto LABEL_9;
      goto LABEL_11;
    case 2:
      if ((a6 & 0x400) == 0)
        goto LABEL_11;
      goto LABEL_9;
    case 3:
    case 4:
      if ((a6 & 0x400) == 0)
        goto LABEL_11;
      goto LABEL_9;
    case 5:
    case 6:
      if ((a6 & 0x400) == 0)
        goto LABEL_11;
      goto LABEL_9;
    case 7:
    case 8:
      if ((a6 & 0x400) != 0)
        goto LABEL_9;
LABEL_11:
      v7 = *(void (**)(void))(a1 + 16);
      goto LABEL_12;
    case 9:
      if ((a6 & 0x400) != 0)
        goto LABEL_9;
      goto LABEL_16;
    case 10:
      if ((a6 & 0x400) != 0)
LABEL_9:
        v7 = *(void (**)(void))(a1 + 16);
      else
LABEL_16:
        v7 = *(void (**)(void))(a1 + 16);
      goto LABEL_12;
    case 11:
      addString(a1, a2, a3, a4, a6, &v11);
      return;
    case 12:
      v7 = *(void (**)(void))(a1 + 16);
LABEL_12:
      v7();
      return;
    default:
      v8 = __si_assert_copy_extra_268();
      v9 = v8;
      if (v8)
        v10 = v8;
      else
        v10 = "";
      __message_assert("%s:%u: Unexpected code path %s ", "SISearchCtx_METADATA.cpp", 5949, v10);
      free(v9);
      MEMORY[0xBAD] = -559038737;
      abort();
  }
}

void addString(uint64_t a1, uint64_t a2, uint64_t a3, int *a4, char a5, const char **a6)
{
  const char *v10;
  uint64_t (*v11)(uint64_t, uint64_t, const char *, size_t, uint64_t, uint64_t);
  size_t v12;
  uint64_t v13;
  size_t v15;
  const char *string_for_id_locked;
  int v17;
  NSObject *v18;
  int v19;
  const char *v20;
  __int16 v21;
  int v22;
  __int16 v23;
  int v24;
  uint64_t v25;

  v25 = *MEMORY[0x1E0C80C00];
  v10 = *a6;
  v11 = *(uint64_t (**)(uint64_t, uint64_t, const char *, size_t, uint64_t, uint64_t))(a1 + 16);
  if ((a5 & 0x10) != 0)
  {
    v15 = *(unsigned int *)v10;
    if (!v11(a1, 30, 0, v15, a3, a2))
    {
      if ((_DWORD)v15 == -2)
      {
        string_for_id_locked = "";
      }
      else
      {
        string_for_id_locked = (const char *)db_get_string_for_id_locked(a4, v15);
        if (!string_for_id_locked)
        {
          if ((_DWORD)v15 == -1)
          {
            v17 = *__error();
            v18 = _SILogForLogForCategory(7);
            if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
            {
              v19 = 136315650;
              v20 = "addString";
              v21 = 1024;
              v22 = 5852;
              v23 = 1024;
              v24 = -1;
              _os_log_error_impl(&dword_1B8270000, v18, OS_LOG_TYPE_ERROR, "%s:%d: Bad string id for %d", (uint8_t *)&v19, 0x18u);
            }
            *__error() = v17;
          }
          else if (os_log_type_enabled(MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT))
          {
            v19 = 67109120;
            LODWORD(v20) = v15;
            _os_log_fault_impl(&dword_1B8270000, MEMORY[0x1E0C81028], OS_LOG_TYPE_FAULT, "No data for uniqued string %u", (uint8_t *)&v19, 8u);
          }
          goto LABEL_8;
        }
      }
      (*(void (**)(uint64_t, uint64_t, const char *, size_t, uint64_t, uint64_t))(a1 + 16))(a1, 31, string_for_id_locked, v15, a3, a2);
    }
LABEL_8:
    v13 = 4;
    goto LABEL_9;
  }
  v12 = strlen(*a6);
  v11(a1, 29, v10, v12, a3, a2);
  v13 = v12 + 1;
LABEL_9:
  *a6 = &v10[v13];
}

uint64_t emitVector(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, unsigned int a5, uint64_t a6, uint64_t a7, int a8)
{
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;

  v15 = a8;
  v16 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, uint64_t))(a1 + 16))(a1, 10, 0, 0, a8, a2);
  if (!a4)
  {
    v17 = 0;
    if (!a5)
      goto LABEL_4;
    goto LABEL_3;
  }
  (*(void (**)(uint64_t, uint64_t, const char *, _QWORD, _QWORD, uint64_t))(a1 + 16))(a1, 14, "vec_format", 0, 0, v16);
  (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD, _QWORD, uint64_t))(a1 + 16))(a1, 16, a3, 0, 0, v16);
  (*(void (**)(uint64_t, uint64_t, const char *, _QWORD, uint64_t, uint64_t))(a1 + 16))(a1, 14, "vec_dim", 0, 1, v16);
  (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, uint64_t))(a1 + 16))(a1, 16, a4, 0, 1, v16);
  v17 = 2;
  if (a5)
  {
LABEL_3:
    v18 = v17;
    (*(void (**)(uint64_t, uint64_t, const char *, _QWORD, _QWORD, uint64_t))(a1 + 16))(a1, 14, "vec_version", 0, v17, v16);
    v17 |= 1u;
    (*(void (**)(uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, uint64_t))(a1 + 16))(a1, 21, a5, 0, v18, v16);
  }
LABEL_4:
  (*(void (**)(uint64_t, uint64_t, const char *, _QWORD, _QWORD, uint64_t))(a1 + 16))(a1, 14, "vec_data", 0, v17, v16);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, uint64_t))(a1 + 16))(a1, 33, a6, a7, v17, v16);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, uint64_t, uint64_t))(a1 + 16))(a1, 11, v16, 0, v15, a2);
}

uint64_t isQueryNodePhotosPersonIdentifier(uint64_t result)
{
  uint64_t *v1;

  if (result)
  {
    if (*(_WORD *)(result + 40) == 4 && (v1 = *(uint64_t **)(result + 16)) != 0)
    {
      result = *v1;
      if (*v1)
        return strcmp((const char *)result, "kMDItemPhotosPeoplePersonIdentifiers") == 0;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void ___ZL35extractPersonUnalignedMatchingFieldP20SISearchCtx_METADATAP14datastore_infoP6db_objPKjS6_S6_S6_P19PartialQueryResultsPP10query_nodelP14__MDPlistBytes_block_invoke(uint64_t a1)
{
  int v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t data_locked;
  uint64_t i;
  unint64_t v8;
  int v9;
  unint64_t v10;
  int v11;
  NSObject *v12;
  int v13;
  NSObject *v14;
  int v15;
  const char *v16;
  int v17;
  int v18;
  uint64_t v19;
  uint8_t buf[4];
  const char *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  unint64_t v25;
  __int16 v26;
  unint64_t v27;
  __int16 v28;
  int v29;
  __int16 v30;
  uint64_t v31;
  __int16 v32;
  int v33;
  __int16 v34;
  const char *v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    v2 = *(_DWORD *)(*(_QWORD *)(a1 + 40) + 4 * *(unsigned int *)(a1 + 72));
    os_unfair_lock_lock((os_unfair_lock_t)(*(_QWORD *)(a1 + 48) + 4568));
    v3 = v2 & 0x7FFFFFFF;
    if (v3 <= 0x7FFFFFFD)
    {
      v4 = *(_QWORD *)(a1 + 64);
      v5 = *(_QWORD *)(v4 + 888);
      if ((*(_BYTE *)(v4 + 804) & 0x14) != 0)
      {
        v19 = 0;
        data_locked = data_map_get_data_locked(v5, v3, &v19);
        if (data_locked)
        {
          for (i = v19; data_locked + i - 1 > data_locked; --i)
          {
            if (*(_BYTE *)(data_locked + i - 1) == 22 && *(_BYTE *)(data_locked + i) == 2)
              v19 = i - 1;
          }
        }
        else
        {
          v8 = data_map_count(v5);
          if (v8 < v3)
          {
            v10 = v8;
            v11 = *__error();
            v12 = _SILogForLogForCategory(7);
            if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
            {
              v18 = *(_DWORD *)(v4 + 4);
              v15 = data_map_valid((_DWORD *)v5);
              *(_DWORD *)buf = 136316930;
              v16 = "n";
              v21 = "_get_string_and_length_for_id";
              v22 = 1024;
              v23 = 571;
              if (v15)
                v16 = "y";
              v24 = 2048;
              v25 = v3;
              v26 = 2048;
              v27 = v10;
              v28 = 1024;
              v29 = 1;
              v30 = 2080;
              v31 = v4 + 324;
              v32 = 1024;
              v33 = v18;
              v34 = 2080;
              v35 = v16;
              _os_log_error_impl(&dword_1B8270000, v12, OS_LOG_TYPE_ERROR, "%s:%d: Invalid string_id:%lu, map_count:%lu, index:%d, dst->name:%s, dst->flags:0x%x valid:%s", buf, 0x46u);
            }
            *__error() = v11;
            if ((*(_BYTE *)(v4 + 4) & 0x20) != 0)
            {
              v13 = *__error();
              v14 = _SILogForLogForCategory(7);
              if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
              {
                v17 = *(_DWORD *)(v4 + 4);
                *(_DWORD *)buf = 136315906;
                v21 = "_get_string_and_length_for_id";
                v22 = 1024;
                v23 = 573;
                v24 = 2080;
                v25 = v4 + 324;
                v26 = 1024;
                LODWORD(v27) = v17;
                _os_log_error_impl(&dword_1B8270000, v14, OS_LOG_TYPE_ERROR, "%s:%d: marking invalid %s flags:0x%x", buf, 0x22u);
              }
              *__error() = v13;
              *(_DWORD *)(v4 + 4) |= 0x40u;
            }
          }
        }
      }
      else if (*(_DWORD *)(v5 + 56) <= v3 || !*(_QWORD *)(*(_QWORD *)(v5 + 32) + 8 * v3))
      {
        v9 = *(_DWORD *)(v4 + 4);
        if ((v9 & 0x20) != 0)
        {
          *(_DWORD *)(v4 + 4) = v9 | 0x40;
        }
        else if (SIIsAppleInternal_onceToken != -1)
        {
          dispatch_once(&SIIsAppleInternal_onceToken, &__block_literal_global_4644);
        }
      }
    }
    _MDPlistBytesAddCString();
    os_unfair_lock_unlock((os_unfair_lock_t)(*(_QWORD *)(a1 + 48) + 4568));
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
  }
}

uint64_t isQueryNodeMatchingAnyField(uint64_t result)
{
  uint64_t *v1;

  if (result)
  {
    if (*(_WORD *)(result + 40) == 4 && (v1 = *(uint64_t **)(result + 16)) != 0)
    {
      result = *v1;
      if (*v1)
        return strcmp((const char *)result, "*") == 0;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void ___ZL35extractPersonUnalignedMatchingFieldP20SISearchCtx_METADATAP14datastore_infoP6db_objPKjS6_S6_S6_P19PartialQueryResultsPP10query_nodelP14__MDPlistBytes_block_invoke_2(uint64_t a1)
{
  uint64_t v2;
  int v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t data_locked;
  uint64_t i;
  unint64_t v9;
  int v10;
  unint64_t v11;
  int v12;
  NSObject *v13;
  int v14;
  NSObject *v15;
  int v16;
  const char *v17;
  int v18;
  int v19;
  uint64_t v20;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  int v24;
  __int16 v25;
  unint64_t v26;
  __int16 v27;
  unint64_t v28;
  __int16 v29;
  int v30;
  __int16 v31;
  uint64_t v32;
  __int16 v33;
  int v34;
  __int16 v35;
  const char *v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    v2 = *(unsigned int *)(*(_QWORD *)(a1 + 40) + 4 * *(unsigned int *)(a1 + 80));
    os_unfair_lock_lock((os_unfair_lock_t)(*(_QWORD *)(a1 + 48) + 1168));
    v3 = SIValueSet<unsigned int>::SIValueSetInsert((unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 1160) + 16), v2);
    os_unfair_lock_unlock((os_unfair_lock_t)(*(_QWORD *)(a1 + 48) + 1168));
    if (v3)
    {
      os_unfair_lock_lock((os_unfair_lock_t)(*(_QWORD *)(a1 + 56) + 4568));
      v4 = v2 & 0x7FFFFFFF;
      if (v4 <= 0x7FFFFFFD)
      {
        v5 = *(_QWORD *)(a1 + 72);
        v6 = *(_QWORD *)(v5 + 888);
        if ((*(_BYTE *)(v5 + 804) & 0x14) != 0)
        {
          v20 = 0;
          data_locked = data_map_get_data_locked(v6, v4, &v20);
          if (data_locked)
          {
            for (i = v20; data_locked + i - 1 > data_locked; --i)
            {
              if (*(_BYTE *)(data_locked + i - 1) == 22 && *(_BYTE *)(data_locked + i) == 2)
                v20 = i - 1;
            }
          }
          else
          {
            v9 = data_map_count(v6);
            if (v9 < v4)
            {
              v11 = v9;
              v12 = *__error();
              v13 = _SILogForLogForCategory(7);
              if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
              {
                v19 = *(_DWORD *)(v5 + 4);
                v16 = data_map_valid((_DWORD *)v6);
                *(_DWORD *)buf = 136316930;
                v17 = "n";
                v22 = "_get_string_and_length_for_id";
                v23 = 1024;
                v24 = 571;
                if (v16)
                  v17 = "y";
                v25 = 2048;
                v26 = v4;
                v27 = 2048;
                v28 = v11;
                v29 = 1024;
                v30 = 1;
                v31 = 2080;
                v32 = v5 + 324;
                v33 = 1024;
                v34 = v19;
                v35 = 2080;
                v36 = v17;
                _os_log_error_impl(&dword_1B8270000, v13, OS_LOG_TYPE_ERROR, "%s:%d: Invalid string_id:%lu, map_count:%lu, index:%d, dst->name:%s, dst->flags:0x%x valid:%s", buf, 0x46u);
              }
              *__error() = v12;
              if ((*(_BYTE *)(v5 + 4) & 0x20) != 0)
              {
                v14 = *__error();
                v15 = _SILogForLogForCategory(7);
                if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
                {
                  v18 = *(_DWORD *)(v5 + 4);
                  *(_DWORD *)buf = 136315906;
                  v22 = "_get_string_and_length_for_id";
                  v23 = 1024;
                  v24 = 573;
                  v25 = 2080;
                  v26 = v5 + 324;
                  v27 = 1024;
                  LODWORD(v28) = v18;
                  _os_log_error_impl(&dword_1B8270000, v15, OS_LOG_TYPE_ERROR, "%s:%d: marking invalid %s flags:0x%x", buf, 0x22u);
                }
                *__error() = v14;
                *(_DWORD *)(v5 + 4) |= 0x40u;
              }
            }
          }
        }
        else if (*(_DWORD *)(v6 + 56) <= v4 || !*(_QWORD *)(*(_QWORD *)(v6 + 32) + 8 * v4))
        {
          v10 = *(_DWORD *)(v5 + 4);
          if ((v10 & 0x20) != 0)
          {
            *(_DWORD *)(v5 + 4) = v10 | 0x40;
          }
          else if (SIIsAppleInternal_onceToken != -1)
          {
            dispatch_once(&SIIsAppleInternal_onceToken, &__block_literal_global_4644);
          }
        }
      }
      _MDPlistBytesAddCString();
      os_unfair_lock_unlock((os_unfair_lock_t)(*(_QWORD *)(a1 + 56) + 4568));
    }
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
  }
}

uint64_t isQueryNodeMatchingPersonNamesAlternatives(uint64_t result)
{
  uint64_t *v1;

  if (result)
  {
    if (*(_WORD *)(result + 40) == 4 && (v1 = *(uint64_t **)(result + 16)) != 0)
    {
      result = *v1;
      if (*v1)
        return strcmp((const char *)result, "kMDItemPhotosPeopleNamesAlternatives") == 0;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void ___ZL35extractPersonUnalignedMatchingFieldP20SISearchCtx_METADATAP14datastore_infoP6db_objPKjS6_S6_S6_P19PartialQueryResultsPP10query_nodelP14__MDPlistBytes_block_invoke_3(uint64_t a1)
{
  uint64_t v2;
  int v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t data_locked;
  uint64_t i;
  unint64_t v9;
  int v10;
  unint64_t v11;
  int v12;
  NSObject *v13;
  int v14;
  NSObject *v15;
  int v16;
  const char *v17;
  int v18;
  int v19;
  uint64_t v20;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  int v24;
  __int16 v25;
  unint64_t v26;
  __int16 v27;
  unint64_t v28;
  __int16 v29;
  int v30;
  __int16 v31;
  uint64_t v32;
  __int16 v33;
  int v34;
  __int16 v35;
  const char *v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    v2 = *(unsigned int *)(*(_QWORD *)(a1 + 40) + 4 * *(unsigned int *)(a1 + 80));
    os_unfair_lock_lock((os_unfair_lock_t)(*(_QWORD *)(a1 + 48) + 1168));
    v3 = SIValueSet<unsigned int>::SIValueSetInsert((unsigned int *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 1160) + 16), v2);
    os_unfair_lock_unlock((os_unfair_lock_t)(*(_QWORD *)(a1 + 48) + 1168));
    if (v3)
    {
      os_unfair_lock_lock((os_unfair_lock_t)(*(_QWORD *)(a1 + 56) + 4568));
      v4 = v2 & 0x7FFFFFFF;
      if (v4 <= 0x7FFFFFFD)
      {
        v5 = *(_QWORD *)(a1 + 72);
        v6 = *(_QWORD *)(v5 + 888);
        if ((*(_BYTE *)(v5 + 804) & 0x14) != 0)
        {
          v20 = 0;
          data_locked = data_map_get_data_locked(v6, v4, &v20);
          if (data_locked)
          {
            for (i = v20; data_locked + i - 1 > data_locked; --i)
            {
              if (*(_BYTE *)(data_locked + i - 1) == 22 && *(_BYTE *)(data_locked + i) == 2)
                v20 = i - 1;
            }
          }
          else
          {
            v9 = data_map_count(v6);
            if (v9 < v4)
            {
              v11 = v9;
              v12 = *__error();
              v13 = _SILogForLogForCategory(7);
              if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
              {
                v19 = *(_DWORD *)(v5 + 4);
                v16 = data_map_valid((_DWORD *)v6);
                *(_DWORD *)buf = 136316930;
                v17 = "n";
                v22 = "_get_string_and_length_for_id";
                v23 = 1024;
                v24 = 571;
                if (v16)
                  v17 = "y";
                v25 = 2048;
                v26 = v4;
                v27 = 2048;
                v28 = v11;
                v29 = 1024;
                v30 = 1;
                v31 = 2080;
                v32 = v5 + 324;
                v33 = 1024;
                v34 = v19;
                v35 = 2080;
                v36 = v17;
                _os_log_error_impl(&dword_1B8270000, v13, OS_LOG_TYPE_ERROR, "%s:%d: Invalid string_id:%lu, map_count:%lu, index:%d, dst->name:%s, dst->flags:0x%x valid:%s", buf, 0x46u);
              }
              *__error() = v12;
              if ((*(_BYTE *)(v5 + 4) & 0x20) != 0)
              {
                v14 = *__error();
                v15 = _SILogForLogForCategory(7);
                if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
                {
                  v18 = *(_DWORD *)(v5 + 4);
                  *(_DWORD *)buf = 136315906;
                  v22 = "_get_string_and_length_for_id";
                  v23 = 1024;
                  v24 = 573;
                  v25 = 2080;
                  v26 = v5 + 324;
                  v27 = 1024;
                  LODWORD(v28) = v18;
                  _os_log_error_impl(&dword_1B8270000, v15, OS_LOG_TYPE_ERROR, "%s:%d: marking invalid %s flags:0x%x", buf, 0x22u);
                }
                *__error() = v14;
                *(_DWORD *)(v5 + 4) |= 0x40u;
              }
            }
          }
        }
        else if (*(_DWORD *)(v6 + 56) <= v4 || !*(_QWORD *)(*(_QWORD *)(v6 + 32) + 8 * v4))
        {
          v10 = *(_DWORD *)(v5 + 4);
          if ((v10 & 0x20) != 0)
          {
            *(_DWORD *)(v5 + 4) = v10 | 0x40;
          }
          else if (SIIsAppleInternal_onceToken != -1)
          {
            dispatch_once(&SIIsAppleInternal_onceToken, &__block_literal_global_4644);
          }
        }
      }
      _MDPlistBytesAddCString();
      os_unfair_lock_unlock((os_unfair_lock_t)(*(_QWORD *)(a1 + 56) + 4568));
    }
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
  }
}

void ___ZL35extractPersonUnalignedMatchingFieldP20SISearchCtx_METADATAP14datastore_infoP6db_objPKjS6_S6_S6_P19PartialQueryResultsPP10query_nodelP14__MDPlistBytes_block_invoke_4(uint64_t a1)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t data_locked;
  uint64_t i;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  int v10;
  NSObject *v11;
  int v12;
  NSObject *v13;
  int v14;
  int v15;
  int v16;
  const char *v17;
  int v18;
  uint64_t v19;
  uint8_t buf[4];
  const char *v21;
  __int16 v22;
  int v23;
  __int16 v24;
  unint64_t v25;
  __int16 v26;
  unint64_t v27;
  __int16 v28;
  int v29;
  __int16 v30;
  uint64_t v31;
  __int16 v32;
  int v33;
  __int16 v34;
  const char *v35;
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    v2 = *(_DWORD *)(*(_QWORD *)(a1 + 40) + 4 * *(unsigned int *)(a1 + 72)) & 0x7FFFFFFF;
    if (v2 <= 0x7FFFFFFD)
    {
      v3 = *(_QWORD *)(a1 + 48);
      v4 = *(_QWORD *)(v3 + 888);
      if ((*(_BYTE *)(v3 + 804) & 0x14) != 0)
      {
        v19 = 0;
        data_locked = data_map_get_data_locked(v4, v2, &v19);
        if (!data_locked)
        {
          v7 = v3;
          v8 = data_map_count(v4);
          if (v8 < v2)
          {
            v9 = v8;
            v10 = *__error();
            v11 = _SILogForLogForCategory(7);
            if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
            {
              v15 = *(_DWORD *)(v7 + 4);
              v16 = data_map_valid((_DWORD *)v4);
              *(_DWORD *)buf = 136316930;
              v17 = "n";
              v21 = "_get_string_and_length_for_id";
              v22 = 1024;
              v23 = 571;
              if (v16)
                v17 = "y";
              v24 = 2048;
              v25 = v2;
              v26 = 2048;
              v27 = v9;
              v28 = 1024;
              v29 = 1;
              v30 = 2080;
              v31 = v7 + 324;
              v32 = 1024;
              v33 = v15;
              v34 = 2080;
              v35 = v17;
              _os_log_error_impl(&dword_1B8270000, v11, OS_LOG_TYPE_ERROR, "%s:%d: Invalid string_id:%lu, map_count:%lu, index:%d, dst->name:%s, dst->flags:0x%x valid:%s", buf, 0x46u);
            }
            *__error() = v10;
            if ((*(_BYTE *)(v7 + 4) & 0x20) != 0)
            {
              v12 = *__error();
              v13 = _SILogForLogForCategory(7);
              if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
              {
                v18 = *(_DWORD *)(v7 + 4);
                *(_DWORD *)buf = 136315906;
                v21 = "_get_string_and_length_for_id";
                v22 = 1024;
                v23 = 573;
                v24 = 2080;
                v25 = v7 + 324;
                v26 = 1024;
                LODWORD(v27) = v18;
                _os_log_error_impl(&dword_1B8270000, v13, OS_LOG_TYPE_ERROR, "%s:%d: marking invalid %s flags:0x%x", buf, 0x22u);
              }
              *__error() = v12;
              *(_DWORD *)(v7 + 4) |= 0x40u;
            }
          }
          goto LABEL_14;
        }
        for (i = v19; data_locked + i - 1 > data_locked; --i)
        {
          if (*(_BYTE *)(data_locked + i - 1) == 22 && *(_BYTE *)(data_locked + i) == 2)
            v19 = i - 1;
        }
      }
      else if (*(_DWORD *)(v4 + 56) <= v2 || !*(_QWORD *)(*(_QWORD *)(v4 + 32) + 8 * v2))
      {
        v14 = *(_DWORD *)(v3 + 4);
        if ((v14 & 0x20) != 0)
        {
          *(_DWORD *)(v3 + 4) = v14 | 0x40;
        }
        else if (SIIsAppleInternal_onceToken != -1)
        {
          dispatch_once(&SIIsAppleInternal_onceToken, &__block_literal_global_4644);
        }
        goto LABEL_14;
      }
      os_unfair_lock_lock((os_unfair_lock_t)(*(_QWORD *)(a1 + 56) + 4568));
      _MDPlistBytesAddCString();
      os_unfair_lock_unlock((os_unfair_lock_t)(*(_QWORD *)(a1 + 56) + 4568));
    }
LABEL_14:
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
  }
}

void ___ZL36extractSynonymUnalignedMatchingFieldP20SISearchCtx_METADATAP14datastore_infoP6db_objPKjS6_S6_S6_S6_P19PartialQueryResultsP10query_nodeP14__MDPlistBytes_block_invoke(uint64_t a1)
{
  if (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    os_unfair_lock_lock((os_unfair_lock_t)(*(_QWORD *)(a1 + 40) + 4568));
    _MDPlistBytesBeginArray();
    _MDPlistBytesAddInteger();
    _MDPlistBytesAddInteger();
    _MDPlistBytesEndArray();
    os_unfair_lock_unlock((os_unfair_lock_t)(*(_QWORD *)(a1 + 40) + 4568));
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
  }
}

void ___ZL36extractSynonymUnalignedMatchingFieldP20SISearchCtx_METADATAP14datastore_infoP6db_objPKjS6_S6_S6_S6_P19PartialQueryResultsP10query_nodeP14__MDPlistBytes_block_invoke_2(uint64_t a1)
{
  if (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    os_unfair_lock_lock((os_unfair_lock_t)(*(_QWORD *)(a1 + 40) + 4568));
    _MDPlistBytesBeginArray();
    _MDPlistBytesAddInteger();
    _MDPlistBytesAddInteger();
    _MDPlistBytesEndArray();
    os_unfair_lock_unlock((os_unfair_lock_t)(*(_QWORD *)(a1 + 40) + 4568));
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
  }
}

BOOL DBFieldCFDictionaryEqualCallBack(char *a1, _DWORD *a2)
{
  size_t v2;

  if (*(unsigned __int16 *)a1 == *(unsigned __int16 *)a2 && (v2 = *((unsigned int *)a1 + 2), (_DWORD)v2 == a2[2]))
    return memcmp(a1 + 13, (char *)a2 + 13, v2) == 0;
  else
    return 0;
}

unint64_t DBFieldCFDictionaryHashCallBack(unsigned int *a1)
{
  uint64_t v1;

  v1 = a1[2];
  if ((_DWORD)v1)
    return *(unsigned int *)((char *)a1 + 13) | (unint64_t)(v1 << 32);
  else
    return 0;
}

void DBFieldCFDictionaryReleaseCallBack(const __CFAllocator *a1, void *a2)
{
  free(a2);
}

uint64_t PartialQueryResults::totalcount(PartialQueryResults *this)
{
  unint64_t v1;
  unint64_t v3;
  uint64_t v4;
  char *v5;
  uint64_t VectorCount;

  v1 = *((unsigned int *)this + 884);
  if (!(_DWORD)v1)
    return 0;
  v3 = 0;
  v4 = 0;
  v5 = (char *)this + 464;
  do
  {
    if (*(_QWORD *)&v5[8 * v3])
    {
      VectorCount = _MDStoreOIDArrayGetVectorCount();
      v1 = *((unsigned int *)this + 884);
    }
    else
    {
      VectorCount = 0;
    }
    v4 += VectorCount;
    ++v3;
  }
  while (v3 < v1);
  return v4;
}

_DWORD *packOids(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, PartialQueryResults *this, uint64_t a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  char v18;
  unsigned __int16 v19;
  double Current;
  unsigned int v21;
  BOOL v22;
  int v23;
  BOOL v24;
  unsigned int updated;
  uint64_t v26;
  unint64_t *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  char v34;
  unsigned __int16 v35;
  uint64_t v36;
  _QWORD *v37;
  unsigned int v38;
  os_unfair_lock_s *v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  uint64_t v45;
  unint64_t v46;
  int v47;
  unint64_t v48;
  unint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  int v53;
  int v54;
  int v55;
  uint64_t v56;
  char v57;
  char v58;
  unint64_t v59;
  int v60;
  NSObject *v61;
  os_log_type_t v62;
  CFAbsoluteTime v63;
  _DWORD *result;
  char *v65;
  char *v66;
  const char *v67;
  uint64_t v68;
  uint64_t v69;
  unint64_t v71;
  uint64_t v72;
  uint64_t v73;
  unint64_t v74;
  uint64_t v75;
  uint64_t v76;
  int v77;
  int v78;
  int v79;
  uint64_t v80;
  char v81;
  char v82;
  uint8_t buf[4];
  unint64_t v84;
  __int16 v85;
  double v86;
  uint64_t v87;

  v87 = *MEMORY[0x1E0C80C00];
  v13 = *(_QWORD *)(a1 + 104);
  if (*(_BYTE *)(v13 + 99) && *((_QWORD *)this + 29))
  {
    v65 = __si_assert_copy_extra_268();
    v66 = v65;
    v67 = "";
    if (v65)
      v67 = v65;
    __message_assert("%s:%u: failed assertion '%s' %s ", "SISearchCtx_METADATA.cpp", 1554, "attributeCount==0", v67);
    free(v66);
    if (__valid_fs(-1))
      v68 = 2989;
    else
      v68 = 3072;
    *(_DWORD *)v68 = -559038737;
    abort();
  }
  if (!a7)
  {
    v14 = *(_QWORD *)(a1 + 104);
    do
    {
      v15 = v14;
      v14 = *(_QWORD *)(v14 + 80);
    }
    while (v14);
    v16 = *(_DWORD *)(*(_QWORD *)(v15 + 8) + 80);
    v17 = *(_QWORD *)(v13 + 80);
    if (!v17)
      goto LABEL_11;
    v18 = 0;
    do
    {
      v18 ^= *(_DWORD *)(v13 + 104) == 0;
      v13 = v17;
      v17 = *(_QWORD *)(v17 + 80);
    }
    while (v17);
    if ((v18 & 1) != 0)
      v19 = 3553;
    else
LABEL_11:
      v19 = 2781;
    PartialQueryResults::start(this, v16, v19, a5, 0);
  }
  Current = CFAbsoluteTimeGetCurrent();
  v21 = *(_DWORD *)(a1 + 160);
  v22 = v21 > 6;
  v23 = (1 << v21) & 0x4A;
  v24 = v22 || v23 == 0;
  v69 = a7;
  if (v24)
  {
    updated = 0;
    if (!a5)
      goto LABEL_62;
  }
  else
  {
    updated = SISearchCtx_METADATA::updateGroupingCount((SISearchCtx_METADATA *)a1);
    if (!a5)
      goto LABEL_62;
  }
  v26 = 0;
  v27 = (unint64_t *)(a1 + 544);
  do
  {
    v28 = *(_QWORD *)(a1 + 104);
    if (*(_BYTE *)(v28 + 96))
      break;
    v29 = *(_QWORD *)(a1 + 104);
    do
    {
      v30 = v29;
      v29 = *(_QWORD *)(v29 + 80);
    }
    while (v29);
    if (*(_BYTE *)(*(_QWORD *)(v30 + 8) + 12))
      break;
    if (*((_QWORD *)this + 314) >= 0xFFFDuLL)
    {
      v31 = *(_QWORD *)(a1 + 104);
      do
      {
        v32 = v31;
        v31 = *(_QWORD *)(v31 + 80);
      }
      while (v31);
      v33 = *(_QWORD *)(v28 + 80);
      if (!v33)
        goto LABEL_33;
      v34 = 0;
      do
      {
        v34 ^= *(_DWORD *)(v28 + 104) == 0;
        v28 = v33;
        v33 = *(_QWORD *)(v33 + 80);
      }
      while (v33);
      if ((v34 & 1) != 0)
        v35 = 3553;
      else
LABEL_33:
        v35 = 2781;
      PartialQueryResults::prepare((uint64_t)this, *(_DWORD *)(*(_QWORD *)(v32 + 8) + 80), v35, 0);
    }
    if (*(_DWORD *)(a1 + 160) != 4)
    {
      v36 = *(_QWORD *)(a2 + 8 * v26);
      ++*((_QWORD *)this + 314);
      v37 = (_QWORD *)*((_QWORD *)this + 443);
      *v37 = v36;
      *((_QWORD *)this + 443) = v37 + 1;
      if (*(_BYTE *)(*(_QWORD *)(a1 + 104) + 99))
        _MDPlistBytesAddNull();
    }
    if (updated)
    {
      v38 = *(unsigned __int16 *)(a3 + 2 * v26);
      if (*(_BYTE *)(a1 + 650))
      {
        if (updated <= v38)
          v38 = 0;
      }
      else
      {
        v38 &= ~0x20u;
        if (updated <= v38)
          v38 = 18;
      }
    }
    else
    {
      v38 = 0;
    }
    if (*(_DWORD *)(a1 + 832) >= 2u && v38 < *(_DWORD *)(a1 + 652))
    {
      v39 = *(os_unfair_lock_s **)(a1 + 928);
      if (v39)
      {
        v40 = a4 + 80 * v26;
        v42 = *(_QWORD *)v40;
        v41 = *(_QWORD *)(v40 + 8);
        v43 = *(_QWORD *)(a1 + 184);
        if (*(_QWORD *)(a1 + 168))
          v44 = *(_QWORD *)(a1 + 168);
        else
          v44 = *(_QWORD *)(a1 + 184);
        if (*(_QWORD *)(a1 + 400) & v42 | *(_QWORD *)(a1 + 408) & v41)
        {
          v45 = *(_QWORD *)(a1 + 424) & v41;
          v71 = *(_QWORD *)(a1 + 416) & v42;
          v72 = v45;
        }
        else
        {
          v71 = *(_QWORD *)v40;
          v72 = v41;
        }
        if (*(_QWORD *)(a1 + 464) & v42 | *(_QWORD *)(a1 + 472) & v41)
        {
          v46 = *(_QWORD *)(a1 + 496) & v42;
          v47 = *(_DWORD *)(a1 + 516);
          v48 = ((*(_QWORD *)(a1 + 504) & v41) << v47) | (v46 >> 1 >> ~(_BYTE)v47);
          v49 = v46 << v47;
          if ((v47 & 0x40) != 0)
          {
            v48 = v49;
            v49 = 0;
          }
          v50 = v49 | 1;
        }
        else
        {
          v50 = 0;
          v48 = 0;
        }
        v52 = *(_QWORD *)(v40 + 32);
        v51 = *(_QWORD *)(v40 + 40);
        v53 = *(_DWORD *)(v40 + 48);
        v54 = *(_DWORD *)(v40 + 52);
        v55 = *(_DWORD *)(v40 + 56);
        v56 = *(_QWORD *)(v40 + 60);
        v57 = *(_BYTE *)(v40 + 68);
        v58 = *(_BYTE *)(v40 + 69);
        v73 = v50;
        v74 = v48;
        v75 = v52;
        v76 = v51;
        v77 = v53;
        v78 = v54;
        v79 = v55;
        v80 = v56;
        v81 = v57 & 1;
        v82 = v58 & 1;
        ci_donebits_push(v39, v44, v43, (unsigned __int16)v38, &v71);
      }
    }
    do
      v59 = __ldaxr(v27);
    while (__stlxr(v59 + 1, v27));
    ++v26;
  }
  while (v26 != a5);
LABEL_62:
  v60 = *__error();
  v61 = _SILogForLogForCategory(1);
  v62 = 2 * (dword_1EF19FC90 < 4);
  if (os_log_type_enabled(v61, v62))
  {
    v63 = CFAbsoluteTimeGetCurrent();
    *(_DWORD *)buf = 134218240;
    v84 = a5;
    v85 = 2048;
    v86 = v63 - Current;
    _os_log_impl(&dword_1B8270000, v61, v62, "Read/evaluated %ld oids in %f seconds!", buf, 0x16u);
  }
  result = __error();
  *result = v60;
  if (!v69)
  {
    if (*((_QWORD *)this + 186))
    {
      _MDPlistBytesEndArray();
      _MDPlistBytesEndPlist();
    }
    result = (_DWORD *)*((_QWORD *)this + 58);
    if (result)
    {
      _MDStoreOIDArrayEndBulkAdd();
      result = (_DWORD *)_MDStoreOIDArrayEndSequence();
      *((_QWORD *)this + 443) = 0;
    }
  }
  return result;
}

void L1ComboQueueDestroy(void ***a1)
{
  L1RankQueueDestroy(*a1);
  L1RankQueueDestroy(a1[1]);
  L1RankQueueDestroy(a1[2]);
  free(a1);
}

CFStringRef copyName(const char *a1)
{
  size_t v2;

  v2 = strlen(a1);
  return CFStringCreateWithBytes((CFAllocatorRef)kCIQueryZoneAllocator, (const UInt8 *)a1, v2, 0x8000100u, 0);
}

void collectCompletionsFromDBO(uint64_t a1, uint64_t a2, uint64_t *a3, _OWORD *a4, unsigned __int8 a5, uint64_t a6, const char **a7, const char **a8)
{
  int *v10;
  uint64_t v17;
  uint64_t v18;
  const __CFArray *v19;
  uint64_t v20;
  const char *v21;
  int v22;
  unint64_t v23;
  uint64_t v24;
  int v25;
  int v26;
  int v27;
  int *v28;
  uint64_t v29;
  int *v30;
  int *v31;
  uint64_t *v32;
  uint64_t v33;
  char *v34;
  char *v35;
  unint64_t v36;
  size_t v37;
  uint64_t v38;
  __int128 v39;
  __int128 v40;
  int *v41;
  __int16 v42;
  char *v43;
  size_t v44;
  uint64_t v45;
  __int128 v46;
  __int128 v47;
  char *v48;
  int *v49;
  uint64_t *v50;
  uint64_t v51;
  char *v52;
  uint64_t v53;
  uint64_t *v54;
  uint64_t v55;
  char *v56;
  size_t v57;
  uint64_t v58;
  __int128 v59;
  __int128 v60;
  size_t v61;
  const char *v62;
  uint64_t v63;
  uint64_t v64;
  size_t v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  int *v70;
  uint64_t *v71;
  unint64_t v72;
  int v73;
  _QWORD *v74;
  _OWORD *v75;
  uint64_t *v76;
  int *v77;
  int v78;
  _BYTE *v79;
  unsigned int v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  unint64_t v85;
  uint64_t v86;
  unsigned int v87;
  uint64_t v88;
  char *v89;
  unsigned int v90;
  char v91;
  __int128 v92;
  __int128 v93;
  uint64_t v94;
  __int128 *v95;
  __int128 v96;
  __int128 v97;
  uint64_t v98;
  uint64_t string_for_id_locked;
  int v100;
  NSObject *v101;
  int v102;
  NSObject *v103;
  char *v104;
  char *v105;
  const char *v106;
  uint64_t v107;
  const char *v108;
  int v109;
  NSObject *v110;
  int *v111;
  uint64_t *v112;
  int v113;
  NSObject *v114;
  uint64_t v115;
  char v116;
  int *v117;
  uint64_t *v118;
  uint64_t *v119;
  unsigned __int8 v120;
  UErrorCode v121;
  uint64_t v122;
  uint64_t v123;
  _OWORD *v124;
  char **v125;
  int v126;
  const char *v127;
  const void *v128;
  const char *v129;
  char *__s1;
  int v131;
  _QWORD *v132;
  _OWORD v133[5];
  _OWORD v134[5];
  _OWORD v135[5];
  _OWORD v136[5];
  _OWORD v137[5];
  unint64_t v138;
  _OWORD v139[5];
  _OWORD v140[5];
  char *__s;
  uint64_t v142;
  _QWORD v143[12];
  _QWORD v144[3];
  char v145;
  _QWORD v146[3];
  char v147;
  _QWORD v148[3];
  int v149;
  _QWORD v150[4];
  char __dst[8];
  int v152[2];
  uint64_t v153;

  v153 = *MEMORY[0x1E0C80C00];
  if (a2)
  {
    if (a6)
    {
      v10 = *(int **)(a2 + 1184);
      if (v10)
      {
        v17 = PartialQueryResults::completionAttributeIdVector(a6, *(int **)(a2 + 1184));
        v18 = *(_QWORD *)(a6 + 376);
        if (*(_QWORD *)(a6 + 360) && !v18)
        {
          v19 = *(const __CFArray **)(a6 + 368);
          if (!v19)
          {
            v18 = 0;
            if (!v17)
              return;
            goto LABEL_9;
          }
          SIFlattenArrayToCStringVector(v19, (char **)(a6 + 376), (size_t *)(a6 + 352), (CFIndex *)(a6 + 360));
          v18 = *(_QWORD *)(a6 + 376);
          if (!v18)
          {
            v104 = __si_assert_copy_extra_268();
            v105 = v104;
            v106 = "";
            if (v104)
              v106 = v104;
            __message_assert("%s:%u: failed assertion '%s' %s ", "SISearchCtx.h", 1010, "fCompletionAttributeVector", v106);
            free(v105);
            if (__valid_fs(-1))
              v107 = 2989;
            else
              v107 = 3072;
            *(_DWORD *)v107 = -559038737;
            abort();
          }
        }
        if (!v17)
          return;
LABEL_9:
        v122 = v18;
        v132 = CIRetainIndexingTokenizer(3u);
        v20 = *(_QWORD *)(a6 + 288);
        v152[0] = *(_DWORD *)(a2 + 2064);
        v152[1] = 0;
        v150[0] = 0;
        v150[1] = v150;
        v150[2] = 0x2000000000;
        v150[3] = 0;
        v148[0] = 0;
        v148[1] = v148;
        v148[2] = 0x2000000000;
        v149 = 0;
        v146[0] = 0;
        v146[1] = v146;
        v146[2] = 0x2000000000;
        v147 = 0;
        v144[0] = 0;
        v144[1] = v144;
        v144[2] = 0x2000000000;
        v145 = 0;
        v143[0] = MEMORY[0x1E0C809B0];
        v143[1] = 0x40000000;
        v143[2] = __collectCompletionsFromDBO_block_invoke;
        v143[3] = &unk_1E6E2FF68;
        v143[4] = v144;
        v143[5] = v150;
        v143[8] = a3;
        v143[9] = v10;
        v143[10] = a6;
        v143[11] = v20;
        v143[6] = v148;
        v143[7] = v146;
        if (a7)
          v127 = *a7;
        else
          v127 = 0;
        v142 = 0;
        __s = 0;
        v125 = (char **)a7;
        v120 = a5;
        if (db_get_field_by_id(v10, (uint64_t)a3, v152, (unint64_t *)&v142, (unint64_t *)&__s)|| *(_WORD *)v142 != 11)
        {
          v22 = 0;
          v21 = "";
        }
        else
        {
          v21 = "";
          if ((*(_WORD *)(v142 + 2) & 0x10) != 0)
          {
            v22 = *(_DWORD *)(v142 + 13);
            string_for_id_locked = db_get_string_for_id_locked(v10, v22);
            if (string_for_id_locked)
              v21 = (const char *)string_for_id_locked;
          }
          else
          {
            v22 = 0;
          }
        }
        v131 = *(_DWORD *)(a6 + 360);
        v124 = a4;
        v121 = v22;
        if ((*(_BYTE *)(a6 + 321) & 1) == 0)
        {
          v23 = atomic_load((unint64_t *)(a6 + 328));
          if (v23 || (md_deadline_once_wait(), (v23 = atomic_load((unint64_t *)(a6 + 328))) != 0))
          {
            v123 = v23;
            v129 = v21;
            v24 = (uint64_t)v132;
            if (dword_1EF19FC90 >= 5)
            {
              v111 = v10;
              v112 = a3;
              v113 = *__error();
              v114 = _SILogForLogForCategory(1);
              if (os_log_type_enabled(v114, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)__dst = 0;
                _os_log_impl(&dword_1B8270000, v114, OS_LOG_TYPE_DEFAULT, "Generating spotlight completions", (uint8_t *)__dst, 2u);
              }
              *__error() = v113;
              v24 = (uint64_t)v132;
              a3 = v112;
              v10 = v111;
            }
            v25 = v131;
            if (v131 >= 1)
            {
              v26 = 0;
              v27 = *(_DWORD *)(v123 + 4);
              while (1)
              {
                if ((v27 & 0x80) != 0 && v26 == 8)
                {
                  v28 = *(int **)(v17 + 64);
                  if (v28)
                  {
                    if (*(_QWORD *)(v17 + 72))
                    {
                      v29 = v17;
                      *(_QWORD *)__dst = 0;
                      v138 = 0;
                      v30 = v10;
                      v31 = v10;
                      v32 = a3;
                      if (!db_get_field_by_id(v31, (uint64_t)a3, v28, (unint64_t *)&v142, (unint64_t *)&__s)&& !db_get_field_by_id(v30, (uint64_t)a3, *(int **)(v29 + 72), (unint64_t *)__dst, &v138)&& *(_WORD *)v142 == 11&& (*(_WORD *)(v142 + 2) & 0x20) != 0&& **(_WORD **)__dst == 10&& (*(_WORD *)(*(_QWORD *)__dst + 2) & 0x20) != 0)
                      {
                        v33 = *(unsigned int *)(v142 + 8);
                        if ((_DWORD)v33)
                        {
                          v34 = __s;
                          v35 = &__s[v33];
                          v36 = v138;
                          do
                          {
                            v37 = strlen(v34);
                            v36 += 8;
                            v38 = *(_QWORD *)(a6 + 312);
                            v39 = v124[3];
                            v137[2] = v124[2];
                            v137[3] = v39;
                            v137[4] = v124[4];
                            v40 = v124[1];
                            v137[0] = *v124;
                            v137[1] = v40;
                            SICompletionModelProcessUTF8String(v123, (uint64_t)v132, v38, (uint64_t)v34, v37, v137, *v32, v121, v129, 8, v127, v120, (uint64_t)v143);
                            v24 = (uint64_t)v132;
                            v34 += v37 + 1;
                          }
                          while (v34 < v35);
                        }
                      }
                      v26 = 9;
                      a3 = v32;
                      v10 = v30;
                      v25 = v131;
                      v17 = v29;
                      a4 = v124;
                      goto LABEL_67;
                    }
                  }
                }
                v41 = *(int **)(v17 + 8 * v26);
                if (v41)
                {
                  if (!db_get_field_by_id(v10, (uint64_t)a3, v41, (unint64_t *)&v142, (unint64_t *)&__s))
                  {
                    v42 = *(_WORD *)(v142 + 2);
                    if (v125 || (v42 & 0x80) == 0)
                    {
                      if ((v42 & 0x80) != 0)
                      {
                        v138 = 0;
                        if (!db_get_localized_string(v10, v142, v125, (uint64_t)&__s, (uint64_t)&v138, 1))
                        {
                          bzero(__dst, 0x400uLL);
                          v48 = __s;
                          if (v138)
                          {
                            v49 = v10;
                            v50 = a3;
                            v51 = v138 - (_QWORD)__s;
                            if ((int)v138 - (int)__s >= 1023)
                            {
                              v52 = strndup(__s, (v138 - (_DWORD)__s));
                              v53 = *(_QWORD *)(a6 + 312);
                            }
                            else
                            {
                              v52 = __dst;
                              strlcpy(__dst, __s, ((v51 << 32) + 0x100000000) >> 32);
                              v53 = *(_QWORD *)(a6 + 312);
                              if (!v138)
                              {
                                v52 = __dst;
                                v48 = __s;
                                a3 = v50;
                                v10 = v49;
                                goto LABEL_55;
                              }
                            }
                            v61 = (int)v51;
                            a3 = v50;
                            v10 = v49;
                          }
                          else
                          {
                            v53 = *(_QWORD *)(a6 + 312);
                            v52 = __s;
LABEL_55:
                            v61 = strlen(v48);
                          }
                          v68 = a4[3];
                          v136[2] = a4[2];
                          v136[3] = v68;
                          v136[4] = a4[4];
                          v69 = a4[1];
                          v136[0] = *a4;
                          v136[1] = v69;
                          SICompletionModelProcessUTF8String(v123, (uint64_t)v132, v53, (uint64_t)v52, v61, v136, *a3, v121, v129, v26, v127, v120, (uint64_t)v143);
                          if (v52 != __dst)
                            free(v52);
                          v24 = (uint64_t)v132;
LABEL_66:
                          v25 = v131;
                        }
                      }
                      else if (*(_WORD *)v142 == 11)
                      {
                        v43 = __s;
                        if ((v42 & 0x20) != 0)
                        {
                          v117 = v10;
                          v54 = a3;
                          v55 = *(unsigned int *)(v142 + 8);
                          v56 = &__s[v55];
                          if ((v42 & 0x10) == 0)
                          {
                            v118 = v54;
                            if ((_DWORD)v55)
                            {
                              do
                              {
                                v57 = strlen(v43);
                                v58 = *(_QWORD *)(a6 + 312);
                                v59 = a4[3];
                                v134[2] = a4[2];
                                v134[3] = v59;
                                v134[4] = a4[4];
                                v60 = a4[1];
                                v134[0] = *a4;
                                v134[1] = v60;
                                SICompletionModelProcessUTF8String(v123, (uint64_t)v132, v58, (uint64_t)v43, v57, v134, *v54, v121, v129, v26, v127, v120, (uint64_t)v143);
                                v43 += v57 + 1;
                              }
                              while (v43 < v56);
                            }
                            v10 = v117;
                            a3 = v118;
                            v25 = v131;
                            v24 = (uint64_t)v132;
                            goto LABEL_67;
                          }
                          if ((_DWORD)v55)
                          {
                            do
                            {
                              v62 = (const char *)db_get_string_for_id_locked(v117, *(_DWORD *)v43);
                              if (v62)
                              {
                                v63 = (uint64_t)v62;
                                v64 = *(_QWORD *)(a6 + 312);
                                v65 = strlen(v62);
                                v66 = a4[3];
                                v135[2] = a4[2];
                                v135[3] = v66;
                                v135[4] = a4[4];
                                v67 = a4[1];
                                v135[0] = *a4;
                                v135[1] = v67;
                                SICompletionModelProcessUTF8String(v123, (uint64_t)v132, v64, v63, v65, v135, *v54, v121, v129, v26, v127, v120, (uint64_t)v143);
                              }
                              v43 += 4;
                            }
                            while (v43 < v56);
                          }
                          v24 = (uint64_t)v132;
                          a3 = v54;
                          v10 = v117;
                          goto LABEL_66;
                        }
                        v44 = strlen(__s);
                        v45 = *(_QWORD *)(a6 + 312);
                        v46 = a4[3];
                        v133[2] = a4[2];
                        v133[3] = v46;
                        v133[4] = a4[4];
                        v47 = a4[1];
                        v133[0] = *a4;
                        v133[1] = v47;
                        SICompletionModelProcessUTF8String(v123, v24, v45, (uint64_t)__s, v44, v133, *a3, v121, v129, v26, v127, v120, (uint64_t)v143);
                      }
                    }
                  }
                }
LABEL_67:
                if (++v26 >= v25)
                  goto LABEL_107;
              }
            }
          }
          else
          {
            v100 = *__error();
            v101 = _SILogForLogForCategory(1);
            v24 = (uint64_t)v132;
            if (os_log_type_enabled(v101, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)__dst = 0;
              _os_log_impl(&dword_1B8270000, v101, OS_LOG_TYPE_DEFAULT, "Not generating spotlight completions; completion model did not populate in time.",
                (uint8_t *)__dst,
                2u);
            }
            *__error() = v100;
          }
          goto LABEL_107;
        }
        v70 = v10;
        v71 = a3;
        v128 = *(const void **)(a2 + 1296);
        if (dword_1EF19FC90 >= 5)
        {
          v108 = v21;
          v109 = *__error();
          v110 = _SILogForLogForCategory(1);
          if (os_log_type_enabled(v110, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)__dst = 0;
            _os_log_impl(&dword_1B8270000, v110, OS_LOG_TYPE_DEFAULT, "Generating pommmes completions", (uint8_t *)__dst, 2u);
          }
          *__error() = v109;
          v21 = v108;
        }
        v72 = atomic_load((unint64_t *)(a1 + 280));
        if (!v72)
        {
          md_deadline_once_wait();
          v72 = atomic_load((unint64_t *)(a1 + 280));
          if (!v72)
          {
            v102 = *__error();
            v103 = _SILogForLogForCategory(1);
            if (os_log_type_enabled(v103, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)__dst = 0;
              _os_log_impl(&dword_1B8270000, v103, OS_LOG_TYPE_DEFAULT, "Not generating pommmes completions; suggestions model did not populate in time.",
                (uint8_t *)__dst,
                2u);
            }
            *__error() = v102;
            v24 = (uint64_t)v132;
            goto LABEL_107;
          }
        }
        __s1 = (char *)v21;
        v73 = _os_feature_enabled_impl();
        v74 = *(_QWORD **)(a6 + 312);
        v75 = *(_OWORD **)(a6 + 384);
        v76 = v71;
        v77 = v70;
        if (v74)
        {
          v78 = v121;
          if (!v75)
          {
            v126 = v73;
            v119 = v76;
            if (*MEMORY[0x1E0C85AD8] <= 0x1FuLL)
              ++sTotal;
            v75 = malloc_type_zone_calloc((malloc_zone_t *)queryZone, 1uLL, 0x20uLL, 0x31F9A007uLL);
            if (!v75)
              _log_fault_for_malloc_failure();
            *(_QWORD *)(a6 + 384) = v75;
            v79 = (_BYTE *)*v74;
            *v75 = 0u;
            v75[1] = 0u;
            v80 = *v79;
            if (*v79)
            {
              v81 = 0;
              v82 = 0;
              v83 = 0;
              v84 = 0;
              do
              {
                if ((v80 & 0x80) == 0)
                  goto LABEL_91;
                v85 = (unint64_t)v80 >> 4;
                if ((~(_BYTE)v85 & 0xC) != 0)
                  goto LABEL_91;
                v86 = utf8_byte_length(unsigned char)::utf8_len_table[v85];
                v87 = utf8_to_code_point(unsigned char const*)::utf8_first_char_mask[v86] & v80;
                v86 = v86 <= 2 ? 2 : v86;
                v88 = v86 - 1;
                v89 = v79 + 1;
                do
                {
                  v90 = v87;
                  v91 = *v89++;
                  v87 = v91 & 0x3F | (v87 << 6);
                  --v88;
                }
                while (v88);
                if (v87 >> 8 >= 0x11
                  && ((v90 & 0x3FFFFFC) == 0x44 || ((v90 << 6) - 11904) >> 7 < 0x197 || v87 - 65376 <= 0x4F))
                {
                  if (v87 - 12448 > 0x5F)
                  {
                    if (v87 - 12352 > 0x5F)
                      *((_QWORD *)v75 + 2) = ++v84;
                    else
                      *((_QWORD *)v75 + 1) = ++v83;
                  }
                  else
                  {
                    *(_QWORD *)v75 = ++v82;
                  }
                }
                else
                {
LABEL_91:
                  *((_QWORD *)v75 + 3) = ++v81;
                }
                v79 += utf8_byte_length_noerror(unsigned char)::utf8_len_table[(unint64_t)*v79 >> 4];
                v80 = *v79;
              }
              while (*v79);
            }
            v76 = v119;
            v73 = v126;
          }
          if (v73)
            goto LABEL_103;
        }
        else
        {
          v78 = v121;
          if (v73)
          {
LABEL_103:
            v92 = a4[3];
            v140[2] = a4[2];
            v140[3] = v92;
            v140[4] = a4[4];
            v93 = a4[1];
            v140[0] = *a4;
            v140[1] = v93;
            v94 = *(_QWORD *)(a1 + 8);
            v116 = *(_BYTE *)(v94 + 752);
            v115 = *(_QWORD *)(v94 + 696);
            v95 = v140;
LABEL_106:
            v98 = v72;
            v24 = (uint64_t)v132;
            SIPommesSuggestionsProcessDBO(v128, v77, v76, v17, v131, v122, v98, (uint64_t)v132, (uint64_t)v74, (uint64_t)v75, v95, v78, __s1, a8, v115, v116, (uint64_t)v143);
LABEL_107:
            CIReleaseIndexingTokenizer(v24);
            _Block_object_dispose(v144, 8);
            _Block_object_dispose(v146, 8);
            _Block_object_dispose(v148, 8);
            _Block_object_dispose(v150, 8);
            return;
          }
        }
        v96 = a4[3];
        v139[2] = a4[2];
        v139[3] = v96;
        v139[4] = a4[4];
        v97 = a4[1];
        v139[0] = *a4;
        v139[1] = v97;
        v116 = 0;
        v115 = 0;
        v95 = v139;
        goto LABEL_106;
      }
    }
  }
}

uint64_t __collectCompletionsFromDBO_block_invoke(uint64_t result, _DWORD *a2, BOOL *a3)
{
  uint64_t v4;
  uint64_t *v6;
  int *v7;
  uint64_t v8;
  int *v9;
  double v10;
  int v11;
  NSObject *v12;
  uint64_t v13;
  double v14;
  uint64_t v15;
  int v16;
  int v17;
  int v18;
  unsigned __int8 *v19;
  int v20;
  int v21;
  uint64_t v22;
  int v23;
  int v24;
  unint64_t v25;
  int v26;
  int v28;
  int v29;
  unint64_t v30;
  int v31;
  unsigned int v32;
  uint64_t v33;
  uint64_t v34;
  unsigned __int8 *v35;
  unint64_t v36;
  double *v37;
  unint64_t v38;
  uint8_t buf[4];
  uint64_t v40;
  uint64_t v41;

  v4 = result;
  v41 = *MEMORY[0x1E0C80C00];
  if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24))
    goto LABEL_35;
  v35 = 0;
  v36 = 0;
  v6 = *(uint64_t **)(result + 64);
  v7 = *(int **)(result + 72);
  v8 = *(_QWORD *)(result + 80);
  v37 = 0;
  v38 = 0;
  if (!v6
    || (v9 = *(int **)(v8 + 280),
        result = db_get_field_by_id(v7, (uint64_t)v6, *(int **)(v8 + 272), &v38, (unint64_t *)&v37),
        *a3 = (_DWORD)result == 0,
        (_DWORD)result)
    && (result = db_get_field_by_id(v7, (uint64_t)v6, v9, &v38, (unint64_t *)&v37), (_DWORD)result))
  {
    v10 = 0.0;
    if (dword_1EF19FC90 >= 5)
    {
      v11 = *__error();
      v12 = _SILogForLogForCategory(1);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        v13 = *v6;
        *(_DWORD *)buf = 134217984;
        v40 = v13;
LABEL_38:
        _os_log_impl(&dword_1B8270000, v12, OS_LOG_TYPE_DEFAULT, "No useful date for %llx", buf, 0xCu);
        goto LABEL_39;
      }
      goto LABEL_39;
    }
  }
  else if (*v37 <= 0.0 || (v14 = *(double *)(v8 + 304), v14 <= 0.0))
  {
    v10 = 0.0;
    if (dword_1EF19FC90 >= 5)
    {
      v11 = *__error();
      v12 = _SILogForLogForCategory(1);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        v34 = *v6;
        *(_DWORD *)buf = 134217984;
        v40 = v34;
        goto LABEL_38;
      }
LABEL_39:
      result = (uint64_t)__error();
      *(_DWORD *)result = v11;
    }
  }
  else
  {
    v10 = v14 - *v37;
  }
  *(double *)(*(_QWORD *)(*(_QWORD *)(v4 + 40) + 8) + 24) = v10;
  v15 = *(_QWORD *)(v4 + 64);
  if (!v15)
    goto LABEL_30;
  result = db_get_field_by_id(*(int **)(v4 + 72), v15, *(int **)(v4 + 88), &v36, (unint64_t *)&v35);
  if ((_DWORD)result)
    goto LABEL_30;
  v16 = -1759636613;
  v17 = *(_DWORD *)(v36 + 8);
  if (v17 >= 0)
    v18 = *(_DWORD *)(v36 + 8);
  else
    v18 = v17 + 3;
  v19 = &v35[v18 & 0xFFFFFFFC];
  if ((v17 + 3) >= 7)
  {
    v22 = -(v18 >> 2);
    v23 = -1789642873;
    v24 = 718793509;
    do
    {
      v23 = 5 * v23 + 2071795100;
      v24 = 5 * v24 + 1808688022;
      HIDWORD(v25) = v23 * *(_DWORD *)&v19[4 * v22];
      LODWORD(v25) = HIDWORD(v25);
      v26 = (v25 >> 21) * v24;
      HIDWORD(v25) = v16;
      LODWORD(v25) = v16;
      v16 = v26 ^ (5 * (v25 >> 19) + 1390208809);
    }
    while (!__CFADD__(v22++, 1));
    v21 = 5 * v23 + 2071795100;
    v20 = 5 * v24 + 1808688022;
  }
  else
  {
    v20 = 1107688271;
    v21 = 1713515327;
  }
  v28 = 0;
  v29 = *(_DWORD *)(v36 + 8) & 3;
  switch(v29)
  {
    case 1:
      goto LABEL_28;
    case 2:
LABEL_27:
      v28 |= v19[1] << 8;
LABEL_28:
      HIDWORD(v30) = (v28 ^ *v19) * v21;
      LODWORD(v30) = HIDWORD(v30);
      v31 = (v30 >> 21) * v20;
      HIDWORD(v30) = v16;
      LODWORD(v30) = v16;
      v16 = v31 ^ (5 * (v30 >> 19) + 1390208809);
      break;
    case 3:
      v28 = v19[2] << 16;
      goto LABEL_27;
  }
  v32 = -1028477387 * ((-2048144789 * (v16 ^ v17)) ^ ((-2048144789 * (v16 ^ v17)) >> 13));
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v4 + 48) + 8) + 24) = v32 ^ HIWORD(v32);
LABEL_30:
  if (*a3)
  {
    v33 = *(_QWORD *)(v4 + 64);
    if (v33)
    {
      result = db_get_field_by_id(*(int **)(v4 + 72), v33, *(int **)(*(_QWORD *)(v4 + 80) + 296), &v36, (unint64_t *)&v35);
      if (!(_DWORD)result)
      {
        result = matche(**(unsigned __int8 ***)(*(_QWORD *)(v4 + 80) + 312), v35, 7u, 0, 0);
        *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v4 + 56) + 8) + 24) = (_DWORD)result != 0;
      }
    }
  }
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v4 + 32) + 8) + 24) = 1;
LABEL_35:
  *a2 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v4 + 48) + 8) + 24);
  return result;
}

CFStringRef __CIIndexSetCopyDebugDescription(uint64_t a1)
{
  int v1;

  v1 = *(_DWORD *)(a1 + 16);
  if (v1 == -2)
    return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<CIIndexSet: %p count: %u>"), a1, 0);
  else
    return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, CFSTR("<CIIndexSet: %p count: %u isBitMap: %d>"), a1, (-2 - v1), v1 < -9);
}

void CIIndexSetReleaseToCache(uint64_t *a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;

  if (a2 >= 1)
  {
    v4 = a2;
    v6 = 0;
    do
    {
      v7 = *a1;
      if (*(_DWORD *)(*a1 + 16) <= 0xFFFFFFF6)
      {
        blob_free(*(_QWORD **)(v7 + 40), *(_DWORD *)(v7 + 32), a3);
        *(_DWORD *)(v7 + 32) = 0;
      }
      *(_QWORD *)(v7 + 40) = v6;
      ++a1;
      v6 = v7;
      --v4;
    }
    while (v4);
    cicachelistenqueue(*a3 + 8, v7, 20);
  }
}

uint64_t countItemsInRangeByEnumeration(_DWORD *a1, unsigned int a2, unsigned int a3)
{
  unsigned int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  uint64_t i;
  unsigned int v12[2];
  uint64_t v13;
  _DWORD *v14;

  if (a1[6] >= a3)
    v5 = a3;
  else
    v5 = a1[6];
  v6 = a1[4];
  if (a1[5] > a2)
    a2 = a1[5];
  v12[0] = v5;
  v12[1] = a2;
  v13 = 0;
  v14 = a1;
  if (v6 < 1)
  {
    if (v6 < 0xFFFFFFF7)
      goto LABEL_16;
    if (v6 <= 0xFFFFFFFD)
    {
      if (v5 >= a1[8])
      {
        v9 = 0;
        goto LABEL_15;
      }
      if (v6 != -3)
      {
        if (v5 >= a1[9])
        {
          v9 = 1;
          goto LABEL_15;
        }
        if (v6 != -4)
        {
          if (v5 >= a1[10])
          {
            v9 = 2;
            goto LABEL_15;
          }
          if (v6 != -5)
          {
            if (v5 >= a1[11])
            {
              v9 = 3;
              goto LABEL_15;
            }
            if (v6 != -6)
            {
              if (v5 >= a1[12])
              {
                v9 = 4;
                goto LABEL_15;
              }
              if (v6 != -7)
              {
                if (v5 >= a1[13])
                {
                  v9 = 5;
                  goto LABEL_15;
                }
                if (v6 != -8 && v5 >= a1[14])
                {
                  v9 = 6;
                  goto LABEL_15;
                }
              }
            }
          }
        }
      }
    }
    v8 = -2;
  }
  else
  {
    v7 = binarySearchMap((uint64_t)a1, v5);
    LODWORD(v13) = v7;
    if (v7 != a1[9])
      goto LABEL_16;
    v6 = a1[4];
    v8 = a1[8] + v7;
  }
  v9 = v8 - v6;
LABEL_15:
  LODWORD(v13) = v9;
LABEL_16:
  for (i = 0; _CIIndexSetEnumeratorNext(v12); i = (i + 1))
    ;
  return i;
}

void CIIndexSetInvertRange(uint64_t a1, unsigned int a2, unsigned int a3)
{
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  const void **v9;
  int v10;
  uint64_t v11;
  int v12;
  char v13;
  uint64_t v14;
  int v15;
  int *v16;
  int v17;
  int v18;
  int v19;
  int v20;
  uint64_t v21;

  if (CFGetTypeID((CFTypeRef)a1) == __kCIIndexSetInvertedTypeID)
    _CIIndexSetForceBitmap(a1, 0, 0);
  v7 = *(_DWORD *)(a1 + 20);
  v6 = *(_DWORD *)(a1 + 24);
  if (v6 >= a3)
  {
    if (v7 > a2)
    {
      v8 = a2 <= 1 ? 1 : a2;
      if (v8 <= v6)
      {
        v9 = (const void **)a1;
LABEL_21:
        _CIIndexSetSetIndexRangeWithCache(v9, v8, v6, 0, 0);
      }
    }
  }
  else
  {
    if (v7 > a2)
    {
      if (a2 <= 1)
        v8 = 1;
      else
        v8 = a2;
      if (v8 > a3)
        goto LABEL_22;
      goto LABEL_20;
    }
    if (v7 <= 1)
      v8 = 1;
    else
      v8 = *(_DWORD *)(a1 + 20);
    if (v8 <= a3)
    {
LABEL_20:
      v9 = (const void **)a1;
      v6 = a3;
      goto LABEL_21;
    }
  }
LABEL_22:
  if (*(int *)(a1 + 16) >= -9)
    _CIIndexSetForceBitmap(a1, 0, 0);
  v10 = *(_DWORD *)(a1 + 24);
  v11 = (v10 - a3) >> 5;
  v12 = (v10 - a3) & 0x1F;
  v13 = v10 - a2;
  v14 = (v10 - a2) >> 5;
  v15 = v13 & 0x1F;
  v16 = (int *)(*(_QWORD *)(a1 + 40) + 4 * v11);
  v17 = *v16;
  if ((_DWORD)v11 == (_DWORD)v14)
  {
    v18 = v15 + 1;
    v19 = masks[v12];
    if (v12 != v18)
      v19 = masks[v18] & ~v19;
  }
  else
  {
    v20 = masks[v12];
    *v16 = v20 & v17;
    *(_DWORD *)(*(_QWORD *)(a1 + 40) + 4 * v11) |= ~(v20 | v17);
    v21 = (v11 + 1);
    if (v21 < v14)
    {
      do
      {
        *(_DWORD *)(*(_QWORD *)(a1 + 40) + 4 * v21) = ~*(_DWORD *)(*(_QWORD *)(a1 + 40) + 4 * v21);
        ++v21;
      }
      while (v14 != v21);
    }
    v16 = (int *)(*(_QWORD *)(a1 + 40) + 4 * v14);
    v17 = *v16;
    v19 = masks[v15 + 1];
    v11 = v14;
  }
  *v16 = v17 & ~v19;
  *(_DWORD *)(*(_QWORD *)(a1 + 40) + 4 * v11) |= v19 & ~v17;
}

void _CIIndexSetSetIndexRangeWithCache(const void **cf, unsigned int a2, unsigned int a3, int a4, _QWORD *a5)
{
  int8x8_t v10;
  int v11;
  unsigned int v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  unint64_t v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int v30;
  unint64_t v31;
  unsigned int v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  int v36;
  _DWORD *v37;
  _DWORD *v38;
  char v39;
  unsigned int v40;
  unint64_t v41;
  unint64_t v42;
  _DWORD *v43;
  unsigned int v44;
  uint64_t v45;
  unsigned int v46;

  if (*((_DWORD *)cf + 6) == a3 && *((_DWORD *)cf + 5) == a2)
    return;
  if (CFGetTypeID(cf) == __kCIIndexSetInvertedTypeID)
    _CIIndexSetForceBitmap((uint64_t)cf, a5, 0);
  v11 = *((_DWORD *)cf + 4);
  if (v11 > -10)
  {
    v21 = *((_DWORD *)cf + 5);
    if (v21 >= a2)
    {
      v22 = *((_DWORD *)cf + 6);
      if (v22 <= a3)
      {
LABEL_28:
        LODWORD(v29) = *((_DWORD *)cf + 4);
        goto LABEL_57;
      }
      if (v11 < 0)
      {
LABEL_26:
        if (v22 > a3)
          _CIIndexSetClearRange((int *)cf, a3, v22);
        goto LABEL_28;
      }
    }
    else if (v11 < 0)
    {
      _CIIndexSetClearRange((int *)cf, v21, a2);
      v22 = *((_DWORD *)cf + 6);
      goto LABEL_26;
    }
    v27 = *((int *)cf + 9);
    if ((_DWORD)v27 != v11)
    {
      memmove((char *)cf[5] + 4 * v27, (char *)cf[5] + 4 * (v27 - v11 + *((_DWORD *)cf + 8)), 4 * (v11 - (int)v27));
      v11 = *((_DWORD *)cf + 4);
      *((_DWORD *)cf + 9) = v11;
    }
    if (v11 < 1)
    {
      LODWORD(v28) = 0;
    }
    else
    {
      v28 = 0;
      while (*((_DWORD *)cf[5] + v28) > a3)
      {
        if (v11 == ++v28)
          goto LABEL_48;
      }
    }
    if ((int)v28 >= v11)
    {
LABEL_48:
      LODWORD(v29) = 0;
    }
    else
    {
      v29 = 0;
      v28 = v28;
      do
      {
        v43 = cf[5];
        v44 = v43[v28];
        if (v44 < a2)
          break;
        v43[v29] = v44;
        ++v28;
        ++v29;
      }
      while (*((_DWORD *)cf + 4) > (int)v28);
    }
    *((_DWORD *)cf + 4) = v29;
    *((_DWORD *)cf + 9) = v29;
    goto LABEL_57;
  }
  v12 = a3 - a2;
  if (a3 - a2 > *((_DWORD *)cf + 6) - *((_DWORD *)cf + 5)
    && _CIIndexSetConvertIfArrayIsMuchMoreEfficient((int *)cf, a2, a3, a4, a5, v10))
  {
    if (*((_DWORD *)cf + 5) > *((_DWORD *)cf + 6))
    {
      v13 = __si_assert_copy_extra_268();
      __message_assert_272((uint64_t)v13, v14, v15, v16, v17, v18, v19, v20, (char)"CIIndexSet.c");
      free(v13);
      if (__valid_fs(-1))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
    return;
  }
  v23 = (v12 + 32) >> 5;
  v24 = *((_DWORD *)cf + 8);
  if (v24 < v23)
  {
    v25 = 4 * v23;
    if (v25 >= *MEMORY[0x1E0C85AD8] >> 1)
    {
      v26 = (char *)mmap(0, (v25 + *MEMORY[0x1E0C85AD8] - 1) & -*MEMORY[0x1E0C85AD8], 3, 4098, -134217728, 0);
      memcpy(v26, cf[5], 4 * *((unsigned int *)cf + 8));
      blob_free(cf[5], *((_DWORD *)cf + 8), a5);
    }
    else
    {
      v26 = (char *)blob_realloc(cf[5], v24, (v12 + 32) >> 5, a5);
    }
    cf[5] = v26;
    bzero(&v26[4 * *((unsigned int *)cf + 8)], 4 * (v23 - *((_DWORD *)cf + 8)));
    *((_DWORD *)cf + 8) = v23;
    v24 = (v12 + 32) >> 5;
  }
  v30 = *((_DWORD *)cf + 6);
  v31 = v30 - a3;
  if (v30 >= a3)
  {
    if (v30 > a3)
    {
      v39 = (v30 - a3) & 0x1F;
      v40 = v31 >> 5;
      if (v24 != (v31 >> 5) + 1)
      {
        v41 = 0;
        v42 = v31 >> 5;
        do
        {
          *((_DWORD *)cf[5] + v41) = (*((_DWORD *)cf[5] + (v42 + v41 + 1)) >> (v39 ^ 0x1F)) | (*((_DWORD *)cf[5] + (v42 + v41)) << v39);
          ++v41;
          v24 = *((_DWORD *)cf + 8);
        }
        while (v41 < v24 + ~v40);
      }
      *((_DWORD *)cf[5] + v24 - 1 - v40) = *((_DWORD *)cf[5] + v24 - 1) << v39;
    }
  }
  else
  {
    v32 = a3 - v30;
    v33 = v32 >> 5;
    v34 = v32 & 0x1F;
    if (v34)
    {
      v35 = v24 + ~(_DWORD)v33;
      if ((int)v35 > 0)
      {
        v36 = v24 - v33;
        do
        {
          v37 = cf[5];
          v38 = &v37[v35--];
          v38[v33] = (*v38 << v34) | (v37[v35] >> 1 >> (v34 ^ 0x1F));
          --v36;
        }
        while (v36 > 1);
      }
      *((_DWORD *)cf[5] + v33) = *(_DWORD *)cf[5] << v34;
    }
    else
    {
      memmove((char *)cf[5] + 4 * v33, cf[5], 4 * (v24 - v33));
    }
    bzero((void *)cf[5], (4 * v33));
  }
  if (*((_DWORD *)cf + 5) > a2)
  {
    v45 = 4 * (v12 >> 5);
    *(_DWORD *)((char *)cf[5] + v45) &= masks[(v12 & 0x1F) + 1];
    bzero((char *)cf[5] + v45 + 4, 4 * (v23 + ~(v12 >> 5)));
  }
  v46 = a4 - *((_DWORD *)cf + 4) - 10;
  if (v46 >= v12 + 1)
    v46 = v12 + 1;
  LODWORD(v29) = -10 - v46;
  *((_DWORD *)cf + 4) = v29;
LABEL_57:
  *((_DWORD *)cf + 5) = a2;
  *((_DWORD *)cf + 6) = a3;
  if ((int)v29 <= -10)
    _CIIndexSetConvertIfInvertedArrayIsMoreEfficient(cf, a5, v10);
}

uint64_t CIIndexSetClearRange_Array(uint64_t a1, int a2, unsigned int a3)
{
  unsigned int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t result;
  int v14;
  int v15;
  BOOL v16;
  int v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  if (a2)
    v5 = a2 - 1;
  else
    v5 = 0;
  v6 = binarySearchMap(a1, v5);
  v7 = v6;
  v8 = *(_DWORD *)(a1 + 16);
  v9 = *(_DWORD *)(a1 + 32);
  if (v9 != v8)
  {
    v10 = *(int *)(a1 + 36);
    if ((_DWORD)v10 == v6)
      goto LABEL_10;
    v11 = *(_QWORD *)(a1 + 40);
    if ((int)v10 >= v6)
    {
      memmove((void *)(v11 + 4 * (v9 - (v8 - v6))), (const void *)(v11 + 4 * v6), 4 * ((int)v10 - v6));
      v8 = *(_DWORD *)(a1 + 16);
    }
    else
    {
      memmove((void *)(v11 + 4 * v10), (const void *)(v11 + 4 * (v10 + v9 - v8)), 4 * (v6 - (v10 + v9 - v8)));
      v8 = *(_DWORD *)(a1 + 16);
      v7 = v7 - *(_DWORD *)(a1 + 32) + v8;
    }
  }
  *(_DWORD *)(a1 + 36) = v7;
LABEL_10:
  v12 = v7 - v8;
  if (v12)
    v7 = v12 + *(_DWORD *)(a1 + 32);
  result = binarySearchMap(a1, a3);
  if (v7 != (_DWORD)result)
  {
    v14 = *(_DWORD *)(a1 + 16);
    v15 = *(_DWORD *)(a1 + 36) - result;
    v16 = __OFSUB__(v14, v15);
    v17 = v14 - v15;
    if (v17 < 0 != v16)
    {
      v18 = __si_assert_copy_extra_268();
      __message_assert_272((uint64_t)v18, v19, v20, v21, v22, v23, v24, v25, (char)"CIIndexSet.c");
      free(v18);
      if (__valid_fs(-1))
      {
        MEMORY[0xBAD] = -559038737;
        abort();
      }
      MEMORY[0xC00] = -559038737;
      abort();
    }
    *(_DWORD *)(a1 + 16) = v17;
    *(_DWORD *)(a1 + 36) = result;
  }
  return result;
}

BOOL CIIndexSetAddIndexExpandingRange(const void **cf, unsigned int a2, int8x8_t a3)
{
  int v5;
  unsigned int v6;
  unsigned int v7;
  int v9;

  if (*((_DWORD *)cf + 6) < a2)
  {
    v5 = 1 << -(char)__clz(a2);
    do
    {
      v6 = v5;
      v5 *= 2;
    }
    while (v6 < a2);
    v7 = *((_DWORD *)cf + 5) <= 1u ? 1 : *((_DWORD *)cf + 5);
    if (v7 <= v6)
      _CIIndexSetSetIndexRangeWithCache(cf, v7, v6, 1, 0);
  }
  v9 = -1;
  return _CIIndexSetAddIndex((unsigned int *)cf, a2, 0, &v9, a3);
}

BOOL CIIndexSetHasIndexWithHint(_BOOL8 cf, unsigned int a2, _DWORD *a3)
{
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;
  BOOL v7;
  unsigned int v8;
  int v9;
  unsigned int v10;
  unsigned int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  unsigned int v17;
  int v18;
  unsigned int v19;
  unsigned int v20;
  _BOOL4 v21;
  unsigned int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;

  if (!cf)
    return cf;
  v4 = cf;
  v5 = *(_DWORD *)(cf + 20);
  if (v5 > a2)
    return 0;
  v6 = *(_DWORD *)(cf + 24);
  v7 = v6 >= a2;
  v8 = v6 - a2;
  if (!v7)
    return 0;
  v9 = *(_DWORD *)(cf + 16);
  if (v9 <= -10)
  {
    v10 = *(_DWORD *)(*(_QWORD *)(cf + 40) + 4 * (v8 >> 5));
    return (v10 >> v8) & 1;
  }
  if ((v9 & 0x80000000) == 0)
  {
    if (CFGetTypeID((CFTypeRef)cf) != __kCIIndexSetInvertedTypeID)
    {
      v14 = *(_DWORD *)(v4 + 16);
      v16 = *(_DWORD *)(v4 + 32);
      v15 = *(_DWORD *)(v4 + 36);
      v17 = searchMapWithHint(v4, a2, a3, 0);
      if (v17 < *(_DWORD *)(v4 + 36) || v17 >= v16 - v14 + v15 && v17 < *(_DWORD *)(v4 + 32))
      {
        v18 = *(_DWORD *)(*(_QWORD *)(v4 + 40) + 4 * v17);
        return v18 == a2;
      }
      return 0;
    }
    v5 = *(_DWORD *)(v4 + 20);
  }
  if (v5 > a2)
    return 0;
  v12 = *(_DWORD *)(v4 + 24);
  v8 = v12 - a2;
  if (v12 < a2)
    return 0;
  v13 = *(_DWORD *)(v4 + 16);
  if (v13 <= -10)
  {
    v10 = *(_DWORD *)(*(_QWORD *)(v4 + 40) + 4 * (v8 >> 5));
    return (v10 >> v8) & 1;
  }
  if (v13 < 0)
  {
    if (v13 <= 0xFFFFFFFD)
    {
      v23 = *(_DWORD *)(v4 + 32);
      cf = v23 == a2;
      if (v23 == a2)
        return cf;
      if (v13 == -3)
        return cf;
      v24 = *(_DWORD *)(v4 + 36);
      cf = v24 == a2;
      if (v24 == a2)
        return cf;
      if (v13 == -4)
        return cf;
      v25 = *(_DWORD *)(v4 + 40);
      cf = v25 == a2;
      if (v25 == a2)
        return cf;
      if (v13 == -5)
        return cf;
      v26 = *(_DWORD *)(v4 + 44);
      cf = v26 == a2;
      if (v26 == a2)
        return cf;
      if (v13 == -6)
        return cf;
      v27 = *(_DWORD *)(v4 + 48);
      cf = v27 == a2;
      if (v27 == a2)
        return cf;
      if (v13 == -7)
        return cf;
      v28 = *(_DWORD *)(v4 + 52);
      cf = v28 == a2;
      if (v28 == a2 || v13 == -8)
        return cf;
      v18 = *(_DWORD *)(v4 + 56);
      return v18 == a2;
    }
    return 0;
  }
  v19 = binarySearchMap(v4, a2);
  v20 = *(_DWORD *)(v4 + 36);
  if (v19 < v20 || (v21 = 0, v22 = *(_DWORD *)(v4 + 32), v19 < v22) && v19 >= v22 + v20 - *(_DWORD *)(v4 + 16))
    v21 = *(_DWORD *)(*(_QWORD *)(v4 + 40) + 4 * v19) == a2;
  return v21 ^ (CFGetTypeID((CFTypeRef)v4) == __kCIIndexSetInvertedTypeID);
}

